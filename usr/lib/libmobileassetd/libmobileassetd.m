void __setupMemoryPressureMonitor_block_invoke(uint64_t a1)
{
  int64_t data;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __CFString *v6;
  __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  data = dispatch_source_get_data(*(dispatch_source_t *)(a1 + 32));
  if (data <= 3)
  {
    if (data == 1)
    {
      _MobileAssetLog( 0LL,  5,  (uint64_t)"setupMemoryPressureMonitor_block_invoke",  @"{setupMemoryPressureMonitor} DISPATCH_MEMORYPRESSURE_NORMAL",  v2,  v3,  v4,  v5,  v9);
      v8 = 0LL;
      goto LABEL_14;
    }

    if (data != 2) {
      goto LABEL_15;
    }
    v7 = @"{setupMemoryPressureMonitor} DISPATCH_MEMORYPRESSURE_WARN";
LABEL_12:
    _MobileAssetLog(0LL, 5, (uint64_t)"setupMemoryPressureMonitor_block_invoke", v7, v2, v3, v4, v5, v9);
    v8 = 100LL;
    goto LABEL_14;
  }

  switch(data)
  {
    case 4LL:
      v6 = @"{setupMemoryPressureMonitor} DISPATCH_MEMORYPRESSURE_CRITICAL";
      goto LABEL_10;
    case 16LL:
      v7 = @"{setupMemoryPressureMonitor} DISPATCH_MEMORYPRESSURE_PROC_LIMIT_WARN";
      goto LABEL_12;
    case 32LL:
      v6 = @"{setupMemoryPressureMonitor} DISPATCH_MEMORYPRESSURE_PROC_LIMIT_CRITICAL";
LABEL_10:
      _MobileAssetLog(0LL, 5, (uint64_t)"setupMemoryPressureMonitor_block_invoke", v6, v2, v3, v4, v5, v9);
      v8 = 200LL;
LABEL_14:
      +[MADAutoAssetControlManager memoryPressureMonitor:]( &OBJC_CLASS___MADAutoAssetControlManager,  "memoryPressureMonitor:",  v8);
      return;
  }

LABEL_15:
  _MobileAssetLog( 0LL,  5,  (uint64_t)"setupMemoryPressureMonitor_block_invoke",  @"{setupMemoryPressureMonitor} unknown memory pressure source:%lu",  v2,  v3,  v4,  v5,  data);
}

      v17 = (__CFString *)objc_claimAutoreleasedReturnValue( -[ASAssetMetadataUpdatePolicy checkPreferencesForOverride:]( self,  "checkPreferencesForOverride:",  v4));
      if (!v17) {
        v17 = v16;
      }
      if ((-[__CFString hasSuffix:](v17, "hasSuffix:", @"/") & 1) == 0)
      {
        v18 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@/", v17));

        v17 = (__CFString *)v18;
      }

      goto LABEL_22;
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ASAssetMetadataUpdatePolicy serverURLForAssetType:]",  @"Train name is nil, defaulting to mesu",  v10,  v11,  v12,  v13,  v20);
LABEL_11:
    else {
      v16 = @"https://mesu.apple.com/assets/tv/";
    }
    if (!v4) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }

  v7 = @"https://basejumper.apple.com/systemassets/";
LABEL_6:
  v8 = (void *)objc_claimAutoreleasedReturnValue(-[ASAssetMetadataUpdatePolicy getSystemAppURL:](self, "getSystemAppURL:", v7));
LABEL_23:

  return v8;
}

      -[MADAutoAssetControlManager _scheduledAndRouteClientRequest:fromLocation:]( self,  "_scheduledAndRouteClientRequest:fromLocation:",  v5,  @"RouteClientRequest");
      goto LABEL_19;
    }

    v29 = objc_alloc(&OBJC_CLASS___NSString);
    v27 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
    v28 = -[NSString initWithFormat:]( v29,  "initWithFormat:",  @"{RouteClientRequest} invalid eventInfo (instance:MISSING) | eventInfo:%@",  v27);
LABEL_18:
    v30 = v28;
    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v5,  6102LL,  @"RouteClientRequest",  v28);

    goto LABEL_19;
  }

  v10 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager clientRequestMessageSetInstance:withEventInfo:]( self,  "clientRequestMessageSetInstance:withEventInfo:",  @"RouteClientRequest",  v5));
  if (!v10)
  {
    v26 = objc_alloc(&OBJC_CLASS___NSString);
    v27 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
    v28 = -[NSString initWithFormat:]( v26,  "initWithFormat:",  @"{RouteClientRequest} invalid set-eventInfo (instance:MISSING) | set-eventInfo:%@",  v27);
    goto LABEL_18;
  }

  if (!-[MADAutoAssetControlManager _isClientRequestSubjectToElimination:]( self,  "_isClientRequestSubjectToElimination:",  v5)
    || !-[MADAutoAssetControlManager _setInstanceBeingEliminated:fromLocation:]( self,  "_setInstanceBeingEliminated:fromLocation:",  v10,  @"RouteClientRequest"))
  {
    goto LABEL_15;
  }

  v11 = objc_alloc(&OBJC_CLASS___NSString);
  v12 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  v13 = (void *)objc_claimAutoreleasedReturnValue([v12 summary]);
  v14 = -[NSString initWithFormat:]( v11,  "initWithFormat:",  @"in-progress elimination blocking new set-request | clientRequest:%@",  v13);
  -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v5,  6114LL,  @"RouteClientRequest",  v14);

  v15 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  v16 = (os_log_s *)objc_claimAutoreleasedReturnValue([v15 oslog]);

  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
    -[MADAutoAssetControlManager action_RouteClientRequest:error:].cold.1(v5);
  }
LABEL_13:

LABEL_19:
  return 0LL;
}

  if (-[MADAutoAssetConnector _isMarkerBeingMonitored:](self, "_isMarkerBeingMonitored:", v6))
  {
    if (a4)
    {
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry", 0LL));
      v30 = [v29 countByEnumeratingWithState:&v45 objects:v49 count:16];
      if (v30)
      {
        v31 = v30;
        v32 = *(void *)v46;
        while (2)
        {
          v33 = 0LL;
          do
          {
            if (*(void *)v46 != v32) {
              objc_enumerationMutation(v29);
            }
            if ([*(id *)(*((void *)&v45 + 1) + 8 * (void)v33) isEqual:v6])
            {

              goto LABEL_34;
            }

            v33 = (char *)v33 + 1;
          }

          while (v31 != v33);
          v31 = [v29 countByEnumeratingWithState:&v45 objects:v49 count:16];
          if (v31) {
            continue;
          }
          break;
        }
      }

      v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry"));
      [v34 addObject:v6];

      -[MADAutoAssetConnector _logMarkerRequiringRetry:addedMarker:]( self,  "_logMarkerRequiringRetry:addedMarker:",  @"_refreshTrackingOfFinishedMarker",  v6);
    }

    else
    {
      v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry"));
      v36 = [v35 count];

      if (v36)
      {
        v37 = 0LL;
        while (1)
        {
          v38 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry"));
          v39 = (void *)objc_claimAutoreleasedReturnValue([(id)v38 objectAtIndex:v37]);

          LOBYTE(v38) = [v39 isEqual:v6];
          if ((v38 & 1) != 0) {
            break;
          }
          ++v37;
          v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry"));
          v41 = [v40 count];
        }

        v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry"));
        v43 = [v42 count];

        if (v37 < (unint64_t)v43)
        {
          v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector markersRequiringRetry](self, "markersRequiringRetry"));
          [v44 removeObjectAtIndex:v37];

          -[MADAutoAssetConnector _logMarkerRequiringRetry:removedMarker:]( self,  "_logMarkerRequiringRetry:removedMarker:",  @"_refreshTrackingOfFinishedMarker",  v6);
        }
      }
    }
  }
}

  v35 = (void *)objc_claimAutoreleasedReturnValue([v18 allAvailableForStagingAttributes]);
  if (!v35) {
    goto LABEL_16;
  }
LABEL_21:

  return v35;
}

  v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v31 oslog]);

  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
    v33 = (void *)objc_claimAutoreleasedReturnValue([v6 summary]);
    v34 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
    v38 = 138543874;
    v39 = v32;
    v40 = 2114;
    v41 = v33;
    v42 = 2114;
    v43 = v34;
    _os_log_impl( &dword_0,  v19,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {_doesSelector:matchDescriptor} not a match | checkMatchSelector:%{public}@ | candidateDescriptor:%{public}@",  (uint8_t *)&v38,  0x20u);
  }

  v35 = 0;
LABEL_18:

  return v35;
}

            p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
            v18 = v41;
            v35 = v44;
          }

          v15 = v42;
          v19 = v40;
        }

        objc_autoreleasePoolPop(v25);
        v23 = (char *)v23 + 1;
      }

      while (v21 != v23);
      v37 = [v19 countByEnumeratingWithState:&v45 objects:v53 count:16];
      v21 = v37;
      if (!v37)
      {
LABEL_24:

        v12 = v38;
        break;
      }
    }
  }
}

    goto LABEL_16;
  }

  v19 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v9 lookupCacheQueue]);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __69__MADAutoAssetLookupCache_recordLookupResult_forSelector_forStaging___block_invoke;
  block[3] = &unk_34E8C0;
  v33 = v5;
  v27 = v9;
  v28 = v7;
  v29 = v8;
  v30 = v14;
  v31 = v18;
  v32 = v15;
  dispatch_sync(v19, block);

LABEL_16:
}

  return v16;
}

  return a7;
}

    v36 = objc_alloc(&OBJC_CLASS___NSString);
    v21 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
    v35 = -[NSString initWithFormat:]( v36,  "initWithFormat:",  @"[ALTER] incomplete set-eventInfo | set-eventInfo:%@",  v21);
    goto LABEL_16;
  }

  v34 = objc_alloc(&OBJC_CLASS___NSString);
  v21 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
  v35 = -[NSString initWithFormat:]( v34,  "initWithFormat:",  @"[ALTER] invalid set-eventInfo (instance:MISSING) | set-eventInfo:%@",  v21);
LABEL_16:
  v37 = v35;
  -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v7,  6102LL,  @"handleSetClientAlterEntriesRepresentingAtomicRequest",  v35);

LABEL_17:
}
}

        objc_autoreleasePoolPop(v17);
      }

      v12 = [obj countByEnumeratingWithState:&v71 objects:v82 count:16];
    }

    while (v12);
  }

  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v59 = v61;
  v29 = v57;
  obja = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v59,  "countByEnumeratingWithState:objects:count:",  &v67,  v75,  16LL);
  if (obja)
  {
    v30 = *(void *)v68;
    do
    {
      v31 = 0LL;
      do
      {
        if (*(void *)v68 != v30) {
          objc_enumerationMutation(v59);
        }
        v32 = *(void *)(*((void *)&v67 + 1) + 8LL * (void)v31);
        v33 = objc_autoreleasePoolPush();
        v34 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetAtomicInstancesByInstance]( self,  "knownSetAtomicInstancesByInstance"));
        v35 = [v34 safeObjectForKey:v32 ofClass:objc_opt_class(MADAutoSetAtomicInstance)];
        v36 = (void *)objc_claimAutoreleasedReturnValue(v35);

        if (v36)
        {
          v37 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceNewEntryIDForSetAtomicInstance:]( self,  "atomicInstanceNewEntryIDForSetAtomicInstance:",  v36));
          v38 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( self,  "persistedKnownSetAtomicInstances"));
          v39 = (void *)objc_claimAutoreleasedReturnValue([v38 persistedEntry:v37 fromLocation:v29]);

          if (v39)
          {
            v40 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( self,  "persistedKnownSetAtomicInstances"));
            [v40 removePersistedEntry:v37 fromLocation:v29];

            v41 = (void *)objc_claimAutoreleasedReturnValue([v36 instanceEntries]);
            v42 = v39;
            v43 = v32;
            v44 = v30;
            v45 = [v41 count];
            v62 = v33;
            v46 = (void *)objc_claimAutoreleasedReturnValue([v36 clientDomainName]);
            v60 = v37;
            v47 = (void *)objc_claimAutoreleasedReturnValue([v36 assetSetIdentifier]);
            v48 = (void *)objc_claimAutoreleasedReturnValue([v36 atomicInstanceUUID]);
            v49 = v45;
            v30 = v44;
            v32 = v43;
            v39 = v42;
            +[MADAutoAssetHistory recordOperation:toHistoryType:fromLayer:usageCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromLayer:usageCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:",  300LL,  2LL,  1LL,  v49,  v46,  v47,  v48);

            v29 = v57;
            v37 = v60;

            v33 = v62;
            self = v64;
            -[MADAutoAssetControlManager _logPersistedSetAtomicInstanceRemoved:removedPersistedEntryID:removedSetAtomicInstance:message:]( v64,  "_logPersistedSetAtomicInstanceRemoved:removedPersistedEntryID:removedSetAtomicInstance:message:",  v57,  v60,  v36,  @"eliminated by client");
            -[MADAutoAssetControlManager _clearAtomicInstanceFromLatestToVend:fromLocation:]( v64,  "_clearAtomicInstanceFromLatestToVend:fromLocation:",  v36,  v57);
          }

          else
          {
            v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            v51 = (os_log_s *)objc_claimAutoreleasedReturnValue([v50 oslog]);

            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v64, "_updateLatestSummary"));
              v53 = objc_claimAutoreleasedReturnValue([v36 summary]);
              *(_DWORD *)buf = 138543874;
              v77 = v63;
              v78 = 2114;
              v79 = v29;
              v80 = 2114;
              v81 = v53;
              v54 = (void *)v53;
              _os_log_error_impl( &dword_0,  v51,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to load persisted-set-atomic-instance file | nextRemoveSetInstance:%{public}@",  buf,  0x20u);
            }

            self = v64;
          }
        }

        v52 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetAtomicInstancesByInstance]( self,  "knownSetAtomicInstancesByInstance"));
        [v52 removeObjectForKey:v32];

        objc_autoreleasePoolPop(v33);
        v31 = (char *)v31 + 1;
      }

      while (obja != v31);
      obja = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v59,  "countByEnumeratingWithState:objects:count:",  &v67,  v75,  16LL);
    }

    while (obja);
  }
}
}

  return v24;
}

    if ((a1 & 0xFFFFFFFFFFFFFFFCLL) == 0x50) {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"timeoutWithDetail");
    }
    v18 = @"checkFilesystemState";
    v19 = @"checkNetwork";
    switch(a1)
    {
      case 4uLL:
      case 7uLL:
      case 0x21uLL:
      case 0x26uLL:
      case 0x4CuLL:
        goto LABEL_25;
      case 0xBuLL:
      case 0xCuLL:
      case 0x13uLL:
      case 0x14uLL:
      case 0x15uLL:
      case 0x16uLL:
      case 0x17uLL:
      case 0x27uLL:
      case 0x4AuLL:
        goto LABEL_18;
      case 0x33uLL:
      case 0x34uLL:
      case 0x35uLL:
      case 0x37uLL:
      case 0x38uLL:
      case 0x50uLL:
      case 0x51uLL:
      case 0x52uLL:
      case 0x53uLL:
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"checkTimeoutConditions");
        v20 = a1 - 33;
        if (a1 - 33 > 0x2B) {
          goto LABEL_26;
        }
        if (((1LL << v20) & 0xDB9200000LL) != 0)
        {
          v19 = @"checkNetwork";
        }

        else
        {
          if (((1LL << v20) & 0x80000000021LL) != 0) {
            goto LABEL_24;
          }
          if (a1 != 74) {
            goto LABEL_26;
          }
LABEL_18:
          v19 = @"checkClient";
        }

  return v16;
}

  __break(1u);
  return result;
}

      __break(1u);
LABEL_16:
      __break(1u);
      goto LABEL_17;
    }

    __break(1u);
    goto LABEL_15;
  }

  return result;
}

  __break(1u);
  return result;
}

    __break(1u);
    goto LABEL_16;
  }

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

void _MobileAssetLog( uint64_t a1, int a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = a4;
  if (gForceNSLog | gForceStdOut)
  {
    *(void *)buf = &a9;
    v12 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);
    v13 = v12;
    v14 = @"Unable to allocate log message";
    if (v12) {
      v14 = v12;
    }
    v15 = v14;

    if (gForceNSLog) {
      NSLog(@"%@", v15);
    }
    if (gForceStdOut)
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSFileHandle fileHandleWithStandardOutput]( &OBJC_CLASS___NSFileHandle,  "fileHandleWithStandardOutput"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString dataUsingEncoding:](v15, "dataUsingEncoding:", 2LL));
      [v16 writeData:v17];

      v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSFileHandle fileHandleWithStandardOutput]( &OBJC_CLASS___NSFileHandle,  "fileHandleWithStandardOutput"));
      v19 = (void *)objc_claimAutoreleasedReturnValue([@"\n" dataUsingEncoding:2]);
      [v18 writeData:v19];
    }
  }

  if (!gExclusivelyNSLog)
  {
    if (a2 == 7)
    {
      id v26 = logDebug();
      v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
      BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);

      if (v28)
      {
        *(void *)buf = &a9;
        v23 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);
        id v29 = logDebug();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
          _MobileAssetLog_cold_2();
        }
        goto LABEL_21;
      }
    }

    else if (a2 == 3)
    {
      id v20 = logError();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);

      if (v22)
      {
        *(void *)buf = &a9;
        v23 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);
        id v24 = logError();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          _MobileAssetLog_cold_1();
        }
LABEL_21:
      }
    }

    else
    {
      id v30 = logInfo();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
      BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);

      if (v32)
      {
        v23 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);
        id v33 = logInfo();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = a3;
          __int16 v35 = 2114;
          v36 = v23;
          _os_log_impl(&dword_0, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}@", buf, 0x16u);
        }

        goto LABEL_21;
      }
    }
  }
}

LABEL_148:
          break;
        case 0x23u:
          [*(id *)(a1 + 32) handleReportingRequest:*(void *)(a1 + 40) message:v52 clientName:v236];
          break;
        case 0x24u:
          [*(id *)(a1 + 32) handleGetServerUrl:v238 message:v52 client:*(void *)(a1 + 40) clientName:v236];
          break;
        case 0x25u:
          [*(id *)(a1 + 32) handleGetAllowNonUserInitiated:*(void *)(a1 + 40) message:v52 clientName:v236];
          break;
        case 0x26u:
          [*(id *)(a1 + 32) handleEnsureDataVault:v238 message:v52 client:*(void *)(a1 + 40) clientName:v236];
          break;
        case 0x27u:
          [*(id *)(a1 + 32) handleDataMigrator:*(void *)(a1 + 40) message:v52 clientName:v236];
          break;
        case 0x28u:
          [*(id *)(a1 + 32) handleGetMABrainInfo:*(void *)(a1 + 40) message:v52 clientName:v236];
          break;
        case 0x29u:
          [*(id *)(a1 + 32) handleUpdateMABrain:*(void *)(a1 + 40) message:v52 clientName:v236];
          break;
        case 0x2Au:
          v149 = xpc_dictionary_get_string(v52, "MobileAssetInstallAssetPath");
          if (!v149)
          {
            v62 = 0LL;
            goto LABEL_144;
          }

          v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v149));
          if (v62)
          {
            v154 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
            v155 = [v154 fileExistsAtPath:v62];

            if ((v155 & 1) == 0)
            {
              _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"Unable to locate directory: %@",  v156,  v157,  v158,  v159,  (uint64_t)v62);
              sendClientResponse(*(void **)(a1 + 40), v52, 5LL);
LABEL_145:
              v230 = 0LL;
              v231 = 0LL;
              v234 = 0LL;
              v59 = 0LL;
              v60 = 0LL;
              v61 = 0LL;
              goto LABEL_35;
            }

        v124 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager statistics](self, "statistics"));
        v125 = v124;
        if (v144)
        {
          if (v143) {
            objc_msgSend( v124,  "setFinishedJobSchedulerNetworkFailure:",  (char *)objc_msgSend(v124, "finishedJobSchedulerNetworkFailure") + 1);
          }
          else {
            objc_msgSend( v124,  "setFinishedJobSchedulerNotNetworkRelated:",  (char *)objc_msgSend(v124, "finishedJobSchedulerNotNetworkRelated") + 1);
          }
        }

        else if (v143)
        {
          objc_msgSend( v124,  "setFinishedJobClientNetworkFailure:",  (char *)objc_msgSend(v124, "finishedJobClientNetworkFailure") + 1);
        }

        else
        {
          objc_msgSend( v124,  "setFinishedJobClientNotNetworkRelated:",  (char *)objc_msgSend(v124, "finishedJobClientNotNetworkRelated") + 1);
        }

        v126 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        v127 = (os_log_s *)objc_claimAutoreleasedReturnValue([v126 oslog]);

        if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
        {
          v128 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          *(_DWORD *)buf = 138543618;
          v151 = v128;
          v152 = 2114;
          v153 = v138;
          _os_log_impl(&dword_0, v127, OS_LOG_TYPE_DEFAULT, "[%{public}@] {removeCurrentJob} %{public}@", buf, 0x16u);
        }

        id v24 = v136;
        goto LABEL_46;
      }

      v98 = (void *)objc_claimAutoreleasedReturnValue([v94 activeJobsByUUID]);
      [v98 removeObjectForKey:v97];
    }

    else
    {
      v99 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      v98 = (void *)objc_claimAutoreleasedReturnValue([v99 oslog]);

      if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT))
      {
        v100 = (NSMutableString *)(id)objc_claimAutoreleasedReturnValue([v136 summary]);
        v130 = v21;
        v101 = v18;
        v102 = (id)objc_claimAutoreleasedReturnValue([v94 summary]);
        *(_DWORD *)buf = 138544130;
        v151 = v11;
        v152 = 2114;
        v153 = v100;
        v154 = 2114;
        v155 = v101;
        v156 = 2114;
        v157 = v102;
        _os_log_impl( &dword_0,  (os_log_t)v98,  OS_LOG_TYPE_DEFAULT,  "\n [ELIMINATE]{%{public}@:removeCurrentJob} no active job withoutVersionSelector:%{public}@ | autoAssetJobUUID:%{ public}@ | eliminateTracker:%{public}@",  buf,  0x2Au);

        v18 = v101;
        v21 = v130;
      }
    }

    __int16 v35 = v137;

    goto LABEL_121;
  }

  -[MADAutoAssetControlManager removeCurrentSetJob:schedulerInvolved:potentialNetworkFailure:fromLocation:historyOperation:]( self,  "removeCurrentSetJob:schedulerInvolved:potentialNetworkFailure:fromLocation:historyOperation:",  v10,  v8,  v7,  v11,  332LL);
LABEL_47:
}

LABEL_144:
            sendClientResponse( *(void **)(a1 + 40),  v52,  (int64_t)[*(id *)(a1 + 32) handleInstallAsset:v62 forType:v238]);
            goto LABEL_145;
          }

          _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"Failed to read directory path: %s",  v150,  v151,  v152,  v153,  (uint64_t)v149);
LABEL_172:
          v102 = 2LL;
LABEL_173:
          sendClientResponse(*(void **)(a1 + 40), v52, v102);
          break;
        case 0x2Bu:
          v160 = xpc_dictionary_get_string(v52, "tokenValue");
          if (v160) {
            v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v160));
          }
          else {
            v69 = 0LL;
          }
          [*(id *)(a1 + 32) setPreferenceKeyAsync:@"MobileAssetTokenOverride" andValue:v69 allowNilToClear:1 replyUsing:*(void *)(a1 + 40) and:v52];
          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"Done setting tokenValue",  v200,  v201,  v202,  v203,  v225);
          goto LABEL_148;
        case 0x2Cu:
          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"%@ requested Pallas URL for asset type %@",  v55,  v56,  v57,  v58,  (uint64_t)v236);
          v161 = (void *)objc_claimAutoreleasedReturnValue( +[DownloadManager getPallasUrl:assetType:]( &OBJC_CLASS___DownloadManager,  "getPallasUrl:assetType:",  IsInternalAllowed,  v238));
          reply = xpc_dictionary_create_reply(v52);
          v166 = 2LL;
          if (reply && v161)
          {
            v167 = objc_claimAutoreleasedReturnValue([v161 absoluteString]);
            xpc_dictionary_set_string(reply, "pallasUrl", (const char *)[v167 UTF8String]);

            v166 = 0LL;
          }

          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"%@ found Pallas URL %@ for asset type %@",  v162,  v163,  v164,  v165,  (uint64_t)v236);
          sendReply(*(void **)(a1 + 40), reply, v166);

LABEL_164:
          v230 = 0LL;
          v231 = 0LL;
          v234 = 0LL;
          v59 = 0LL;
          v60 = 0LL;
          v61 = 0LL;
LABEL_165:
          v62 = 0LL;
          v63 = 0LL;
          v64 = 0LL;
          v65 = 0LL;
          v66 = 0LL;
          goto LABEL_38;
        case 0x2Du:
          [*(id *)(a1 + 32) handleSecureMABundleCommand:*(void *)(a1 + 40) message:v52 clientName:v236];
          break;
        case 0x2Eu:
          data = xpc_dictionary_get_data(v52, (const char *)[@"MAPreferences" UTF8String], &length);
          if (data)
          {
            v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  data,  length,  0LL));
            if (v65)
            {
              v239 = 0LL;
              v63 = -[NSKeyedUnarchiver initForReadingFromData:error:]( objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver),  "initForReadingFromData:error:",  v65,  &v239);
              v173 = v239;
              if (v173)
              {
                v66 = v173;
                v178 = (void *)objc_claimAutoreleasedReturnValue([v173 description]);
                _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"Unable to initialize keyed unarchiver, error: %@",  v179,  v180,  v181,  v182,  (uint64_t)v178);

                sendClientResponse(*(void **)(a1 + 40), v52, 2LL);
                v64 = 0LL;
LABEL_178:
                v210 = stringForMAXpcCommand(uint64);
                v227 = (void *)objc_claimAutoreleasedReturnValue(v210);
                _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"Unknown Command: %lld (%@) from client: %@",  v211,  v212,  v213,  v214,  uint64);

                sendClientResponse(*(void **)(a1 + 40), v52, 5LL);
                v230 = 0LL;
                v231 = 0LL;
                v234 = 0LL;
                v59 = 0LL;
                v60 = 0LL;
                v61 = 0LL;
                v62 = 0LL;
                goto LABEL_37;
              }

              if (v63)
              {
                v64 = (void *)objc_claimAutoreleasedReturnValue( -[NSKeyedUnarchiver decodePropertyListForKey:]( v63,  "decodePropertyListForKey:",  NSKeyedArchiveRootObjectKey));
                -[NSKeyedUnarchiver finishDecoding](v63, "finishDecoding");
                if (v64)
                {
                  v219 = objc_opt_class(&OBJC_CLASS___NSDictionary);
                  if ((objc_opt_isKindOfClass(v64, v219) & 1) != 0)
                  {
                    [*(id *)(a1 + 32) setPreferences:v64 replyUsing:*(void *)(a1 + 40) and:v52];
                    v230 = 0LL;
                    v231 = 0LL;
                    v234 = 0LL;
                    v59 = 0LL;
                    v60 = 0LL;
                    v61 = 0LL;
                    v62 = 0LL;
                    goto LABEL_36;
                  }

                  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"maPreferences is not a dictionary, skipping",  v220,  v221,  v222,  v223,  v225);
                  sendClientResponse(*(void **)(a1 + 40), v52, 2LL);
                  goto LABEL_177;
                }

                _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"maPreferences is nil, skipping",  v215,  v216,  v217,  v218,  v225);
                sendClientResponse(*(void **)(a1 + 40), v52, 2LL);
              }

              else
              {
                _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  @"Keyed archive is nil, skipping.",  v174,  v175,  v176,  v177,  v225);
                sendClientResponse(*(void **)(a1 + 40), v52, 2LL);
                v63 = 0LL;
              }

              v64 = 0LL;
LABEL_177:
              v66 = 0LL;
              goto LABEL_178;
            }

            v204 = @"data is nil, skipping";
          }

          else
          {
            v204 = @"rawData is null skipping";
          }

          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  v204,  v169,  v170,  v171,  v172,  v225);
          sendClientResponse(*(void **)(a1 + 40), v52, 2LL);
LABEL_176:
          v63 = 0LL;
          v64 = 0LL;
          v65 = 0LL;
          goto LABEL_177;
        default:
          goto LABEL_176;
      }
    }

    v231 = 0LL;
    v234 = 0LL;
LABEL_32:
    v59 = 0LL;
    v230 = 0LL;
LABEL_33:
    v60 = 0LL;
LABEL_34:
    v61 = 0LL;
    v62 = 0LL;
LABEL_35:
    v63 = 0LL;
    v64 = 0LL;
    v65 = 0LL;
LABEL_36:
    v66 = 0LL;
LABEL_37:
    reply = 0LL;
LABEL_38:

    _Block_object_dispose(&v251, 8);
    v4 = v232;
    goto LABEL_39;
  }

  if (type != (xpc_type_t)&_xpc_type_error)
  {
    v224 = (uint64_t)type;
    v10 = @"Unexpected xpc object %@";
LABEL_4:
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  v10,  v6,  v7,  v8,  v9,  v224);
    goto LABEL_39;
  }

  if (v3 == &_xpc_error_connection_invalid) {
    goto LABEL_39;
  }
  if (v3 == &_xpc_error_termination_imminent)
  {
    v10 = @"Termination imminent";
    goto LABEL_4;
  }

  else {
    v13 = @"Unknown Error";
  }
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleClientConnection:on:]_block_invoke",  v13,  v6,  v7,  v8,  v9,  v224);
  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 40));
LABEL_39:
  objc_autoreleasePoolPop(v4);
}

void sub_4C88(_Unwind_Exception *a1)
{
}

id logInfo()
{
  if (logInfo_logInfoOnce != -1) {
    dispatch_once(&logInfo_logInfoOnce, &__block_literal_global_11);
  }
  return (id)logInfo_infoLog;
}
}

id stringWithoutNewlines(uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", a1));
  v2 = (void *)objc_claimAutoreleasedReturnValue([v1 stringByReplacingOccurrencesOfString:@"\n" withString:@" "]);

  return v2;
}

__CFString *stringForMAXpcCommand(unsigned int a1)
{
  if (a1 >= 0x2F) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAXpcCommand%llu",  a1));
  }
  else {
    return *(&off_3502E8 + (int)a1);
  }
}

uint64_t _MAPreferencesIsInternalAllowed()
{
  if (_MAPreferencesIsInternalAllowed_onceToken != -1) {
    dispatch_once(&_MAPreferencesIsInternalAllowed_onceToken, &__block_literal_global_794);
  }
  return _MAPreferencesIsInternalAllowed__isAppleInternal;
}

LABEL_22:
    LOBYTE(v10) = 1;
    goto LABEL_23;
  }

  if (!v10) {
    goto LABEL_19;
  }
LABEL_6:
  v16 = objc_opt_class(&OBJC_CLASS___NSString);
  if ((objc_opt_isKindOfClass(v9, v16) & 1) == 0)
  {
    BOOL v22 = stringForMAXpcCommand(a3);
    v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager isEntitledForCommand:forConnection:forAssetType:]",  @"failed entitlement check for: nil asset type for command: %lld (%@)",  v24,  v25,  v26,  v27,  a3);
LABEL_16:

    goto LABEL_17;
  }

  if (!isWellFormedAssetType(v9))
  {
    BOOL v28 = stringForMAXpcCommand(a3);
    v23 = (void *)objc_claimAutoreleasedReturnValue(v28);
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager isEntitledForCommand:forConnection:forAssetType:]",  @"failed entitlement check for: %@ with MalformedAssetType for command: %lld (%@)",  v29,  v30,  v31,  v32,  (uint64_t)v9);
    goto LABEL_16;
  }

  if (-[ControlManager isAllowlistedForCommand:](self, "isAllowlistedForCommand:", a3) && _isAssetTypeAllowlisted(v9)
    || !checkConnectionAccessToAssetType(v8, v9))
  {
    goto LABEL_22;
  }

  if (!-[ControlManager isAssetTypeOptionalForCommand:](self, "isAssetTypeOptionalForCommand:", a3))
  {
    v38 = stringForMAXpcCommand(a3);
    v23 = (void *)objc_claimAutoreleasedReturnValue(v38);
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager isEntitledForCommand:forConnection:forAssetType:]",  @"failed entitlement check for: %@ with %d for command: %lld (%@)",  v39,  v40,  v41,  v42,  (uint64_t)v9);
    goto LABEL_16;
  }

  if (!_MobileAssetCheckConnectionEntitlementWithName( (uint64_t)v8,  @"com.apple.private.assets.change-daemon-config")) {
    goto LABEL_22;
  }
  v17 = stringForMAXpcCommand(a3);
  v45 = (void *)objc_claimAutoreleasedReturnValue(v17);
  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager isEntitledForCommand:forConnection:forAssetType:]",  @"no global entitlement found, command %lld (%@) requires asset-type specific entitlement for type not on allowlist. status: %d",  v18,  v19,  v20,  v21,  a3);

LABEL_17:
  LOBYTE(v10) = 0;
LABEL_23:

  return v10;
}

      goto LABEL_23;
    }

    if (a2)
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      v38 = 0LL;
      v15 = (void *)objc_claimAutoreleasedReturnValue([v14 contentsOfDirectoryAtPath:v6 error:&v38]);
      v9 = v38;

      if (v15)
      {
        v31 = v15;
        BOOL v32 = v9;
        v36 = 0u;
        v37 = 0u;
        v34 = 0u;
        __int16 v35 = 0u;
        v16 = v15;
        v17 = [v16 countByEnumeratingWithState:&v34 objects:v40 count:16];
        if (v17)
        {
          v18 = v17;
          v19 = *(void *)v35;
          do
          {
            for (i = 0LL; i != v18; i = (char *)i + 1)
            {
              if (*(void *)v35 != v19) {
                objc_enumerationMutation(v16);
              }
              v21 = *(void **)(*((void *)&v34 + 1) + 8LL * (void)i);
              BOOL v22 = objc_autoreleasePoolPush();
              if ((v3 & 1) != 0)
              {
                v23 = [v21 hasPrefix:@"purpose_"];
                v3 = v23 ^ 1;
                if (v23) {
                  id v24 = v33;
                }
                else {
                  id v24 = v33 - 1;
                }
              }

              else
              {
                v3 = 0LL;
                id v24 = v33 - 1;
              }

              v25 = (void *)objc_claimAutoreleasedReturnValue([v6 stringByAppendingPathComponent:v21]);
              finishPartiallyPurgedAssets(v25, v24, v3);

              objc_autoreleasePoolPop(v22);
            }

            v18 = [v16 countByEnumeratingWithState:&v34 objects:v40 count:16];
          }

          while (v18);
        }

        v15 = v31;
        v9 = v32;
      }

      goto LABEL_22;
    }
  }

  return v8;
}

        v23 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"set-policy invalid: setPolicy|%@ must be NO for request:%@",  v16,  v11);
        -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v6,  v20,  v7,  v23);

        v21 = 1;
LABEL_23:

        goto LABEL_24;
      }

      BOOL v22 = @"blockCheckDownload|";
      v19 = v18;
    }

    -[NSMutableString appendString:](v16, "appendString:", v22);
    id v20 = v19;
    goto LABEL_22;
  }

  -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v6,  6570LL,  v7,  @"set-policy invalid: client-request is not for a set-job");
  v21 = 1;
LABEL_25:

  return v21;
}

          v43 = (void *)objc_claimAutoreleasedReturnValue([v8 latestDownloadedAtomicInstance]);
          [v27 removeObjectForKey:v43];

          if (![v27 count])
          {
            [v57 removeObjectForKey:v9];
            if (![v57 count])
            {
              v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager setLockUsageMap](self, "setLockUsageMap"));
              [v44 removeObjectForKey:v50];

              v45 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager setLockUsageMap](self, "setLockUsageMap"));
              v46 = [v45 count];

              if (!v46)
              {
                v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                v37 = (NSNumber *)objc_claimAutoreleasedReturnValue([v47 oslog]);

                if (os_log_type_enabled((os_log_t)v37, OS_LOG_TYPE_DEFAULT))
                {
                  v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                  *(_DWORD *)buf = 138543362;
                  v63 = v38;
                  _os_log_impl( &dword_0,  (os_log_t)v37,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {setLockUsageMapEndedLockForSetDescriptor} no remaining set-locks in set-lock-usage-map",  buf,  0xCu);
LABEL_17:
                }
              }
            }
          }

          v25 = (char *)v25 + 1;
          v17 = v57;
        }

        while (v56 != v25);
        v48 = [obj countByEnumeratingWithState:&v58 objects:v64 count:16];
        v56 = v48;
      }

      while (v48);
    }

    v19 = obj;
  }

  else
  {
    v19 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
    id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 diag]);
    v21 = objc_alloc(&OBJC_CLASS___NSString);
    BOOL v22 = (void *)objc_claimAutoreleasedReturnValue([v8 summary]);
    v23 = v21;
    v17 = 0LL;
    id v24 = -[NSString initWithFormat:]( v23,  "initWithFormat:",  @"{setLockUsageMapEndedLockForSetDescriptor} just ended locks when no setIdentifierByLockReason in lock-usage-map | justEndedReason:%@ | justEndedLockCount:%ld | setDescriptor:%@ ",  v9,  a5,  v22);
    [v20 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v24 withResult:6108 withError:0];
  }
}
}
}

  return v13;
}

          v7 = v51;

          goto LABEL_23;
        }

        id v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
        v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v29 oslog]);

        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          v57 = v6;
          _os_log_error_impl( &dword_0,  v19,  OS_LOG_TYPE_ERROR,  "{resumeFromPersistedWithDownloadedSelectors} | unable to determine previous status for entry:%{public}@",  buf,  0xCu);
        }

  return 0LL;
}

        v13 = v42 + 1;
      }

      while ((id)(v42 + 1) != v41);
      v41 = [obj countByEnumeratingWithState:&v53 objects:v58 count:16];
      if (!v41)
      {
LABEL_24:

        v12 = -[NSMutableDictionary count](v43, "count");
        LOBYTE(v12) = v12 == [obj count];

        v7 = v36;
        break;
      }
    }
  }

  return (char)v12;
}

      v48 = (void *)objc_claimAutoreleasedReturnValue([v10 latestDowloadedAtomicInstanceEntries]);
      if (v48
        || (v48 = (void *)objc_claimAutoreleasedReturnValue([v10 newerDiscoveredAtomicEntries])) != 0)
      {
        LODWORD(v16) = 1;
      }

      else
      {
        v54 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
        v55 = (void *)objc_claimAutoreleasedReturnValue([v54 diag]);
        v56 = objc_alloc(&OBJC_CLASS___NSString);
        v69 = v23;
        v57 = v8;
        v58 = (void *)objc_claimAutoreleasedReturnValue([v10 summary]);
        v16 = -[NSString initWithFormat:]( v56,  "initWithFormat:",  @"{%@} set-job current-set-status does not include latestDowloadedEntries | jobAtomicInstance:%@ | currentSetStatus:%@",  v13,  v9,  v58);
        [v55 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v16 withResult:6111 withError:0];

        v8 = v57;
        v23 = v69;

        v15 = 0LL;
        LODWORD(v16) = 0;
        v48 = 0LL;
      }

      goto LABEL_26;
    }

    v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
    v38 = (void *)objc_claimAutoreleasedReturnValue([v37 diag]);
    v39 = v8;
    v40 = objc_alloc(&OBJC_CLASS___NSString);
    v41 = (void *)objc_claimAutoreleasedReturnValue([v10 summary]);
    v42 = -[NSString initWithFormat:]( v40,  "initWithFormat:",  @"{%@} set-job current-set-status has no set-configuration | jobAtomicInstance:%@ | currentSetStatus:%@",  v13,  v9,  v41);
    [v38 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v42 withResult:6111 withError:0];

    v8 = v39;
    v23 = 0LL;

LABEL_19:
    LODWORD(v16) = 0;
    v15 = 0LL;
LABEL_26:

    goto LABEL_27;
  }

  LODWORD(v16) = 0;
LABEL_27:
  v49 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  v50 = (os_log_s *)objc_claimAutoreleasedReturnValue([v49 oslog]);

  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    if ((_DWORD)v16) {
      v51 = @"Should";
    }
    else {
      v51 = @"Should not";
    }
    v52 = (void *)objc_claimAutoreleasedReturnValue([v14 summary]);
    *(_DWORD *)buf = 138543874;
    v75 = v13;
    v76 = 2112;
    v77 = v51;
    v78 = 2112;
    v79 = v52;
    _os_log_impl( &dword_0,  v50,  OS_LOG_TYPE_DEFAULT,  "{%{public}@}: %@ adopt as latest. jobAtomicInstance: %@",  buf,  0x20u);
  }

LABEL_33:
  return (char)v16;
}

  id v26 = -[MADCacheDeleteManager totalSpaceRequired:]( self,  "totalSpaceRequired:",  [v5 totalRequiredFreeSpace]);
  [v5 setTotalRequiredSpaceForAllRequests:v26];
  [v5 setTotalAvailableOnFS:v12];
  v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADCacheDeleteManager logger](self, "logger"));
  BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue([v27 oslog]);

  id v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if ((unint64_t)v12 >= v26)
  {
    if (v29)
    {
      v37 = [v5 totalRequiredFreeSpace];
      buf.f_bsize = 134218496;
      *(void *)&buf.f_iosize = v26;
      WORD2(buf.f_blocks) = 2048;
      *(uint64_t *)((char *)&buf.f_blocks + 6) = (uint64_t)v37;
      HIWORD(buf.f_bfree) = 2048;
      buf.f_bavail = (uint64_t)v12;
      _os_log_impl( &dword_0,  v28,  OS_LOG_TYPE_DEFAULT,  "FS Check: Enough free space.  Grand Total Required: %llu, Required space for request: %llu, Available Space: %llu",  (uint8_t *)&buf,  0x20u);
    }

    __int16 v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADCacheDeleteManager stateMachine](self, "stateMachine"));
    v17 = v35;
    v36 = @"FileSystemHasEnoughSpace";
  }

  else
  {
    if (v29)
    {
      id v30 = [v5 totalRequiredFreeSpace];
      buf.f_bsize = 134218496;
      *(void *)&buf.f_iosize = v26;
      WORD2(buf.f_blocks) = 2048;
      *(uint64_t *)((char *)&buf.f_blocks + 6) = (uint64_t)v30;
      HIWORD(buf.f_bfree) = 2048;
      buf.f_bavail = (uint64_t)v12;
      _os_log_impl( &dword_0,  v28,  OS_LOG_TYPE_DEFAULT,  "FS Check: NOT enough free space.  Grand Total Required: %llu, Required space for request: %llu, Available Space: %llu",  (uint8_t *)&buf,  0x20u);
    }

    v31 = [v5 cacheDeleteUrgency];
    BOOL v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADCacheDeleteManager logger](self, "logger"));
    id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue([v32 oslog]);

    v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    if (v31 == -1)
    {
      if (v34)
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_impl( &dword_0,  v33,  OS_LOG_TYPE_DEFAULT,  "Cache delete level is undefined.  Not attempting any cache delete",  (uint8_t *)&buf,  2u);
      }

      __int16 v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADCacheDeleteManager stateMachine](self, "stateMachine"));
      v17 = v35;
      v36 = @"NotEnoughPurgeable";
    }

    else
    {
      if (v34)
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_impl(&dword_0, v33, OS_LOG_TYPE_DEFAULT, "Will be checking for purgeable", (uint8_t *)&buf, 2u);
      }

      __int16 v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADCacheDeleteManager stateMachine](self, "stateMachine"));
      v17 = v35;
      v36 = @"CheckPurgeable";
    }
  }

  [v35 postEvent:v36 withInfo:v5];
  v16 = 0LL;
LABEL_36:

  return 0LL;
}

  return (char)v7;
}

  if (a7) {
    *a7 = v18;
  }
  if (a8) {
    *a8 = v17;
  }
  if (a9 && (uint64_t)v19 >= 1)
  {
    v23 = -[ControlManager reclaimSpace](self, "reclaimSpace");
    id v24 = 1000000LL;
    if (v23) {
      id v24 = (int64_t)v19;
    }
    *a9 = v24;
  }

  return v20;
}

        -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, v19);
LABEL_24:
        v18 = @"checkFilesystemState";
        goto LABEL_25;
      case 0x36uLL:
      case 0x39uLL:
      case 0x3CuLL:
      case 0x3DuLL:
      case 0x3EuLL:
      case 0x40uLL:
      case 0x41uLL:
      case 0x43uLL:
      case 0x44uLL:
        goto LABEL_22;
      default:
        goto LABEL_26;
    }
  }

  switch(a1)
  {
    case 0x1CuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x24uLL:
    case 0x30uLL:
      goto LABEL_12;
    case 0x1DuLL:
      goto LABEL_10;
    case 0x1EuLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2EuLL:
    case 0x2FuLL:
      goto LABEL_15;
    case 0x25uLL:
      v18 = @"checkSpaceNeeded";
      goto LABEL_25;
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2DuLL:
      goto LABEL_14;
    default:
      if (a1 != 70) {
        goto LABEL_15;
      }
      v18 = @"checkClockAndCerts";
LABEL_25:
      -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, v18);
      break;
  }

          v7 = v52;

          goto LABEL_23;
        }

        BOOL v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
        v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v28 oslog]);

        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          v58 = v6;
          _os_log_error_impl( &dword_0,  v19,  OS_LOG_TYPE_ERROR,  "{resumeFromPersistedWithDownloadedSelectors} | unable to determine previous status for entry:%{public}@",  buf,  0xCu);
        }

    v18 = 4294967233LL;
    goto LABEL_21;
  }

  if (*(void *)(a1 + 64) + 16LL < a4) {
    goto LABEL_22;
  }
  cc_clear(0x30uLL, __s);
  __memcpy_chk(__s, a5, a4, 48LL);
LABEL_11:
  update(a1, (uint64_t)__s);
LABEL_12:
  v24[1] = v24;
  inc_uint(a1 + 40, 8uLL);
  ccctr_init_internal(*(void *)(a1 + 56));
  for (i = -(int)a2 & 0xFLL; a2; a2 -= v20)
  {
    if (a2 >= 0x80) {
      id v20 = 128LL;
    }
    else {
      id v20 = a2;
    }
    ccctr_update_internal(*(void *)(a1 + 56), (uint64_t)v11, v20, (uint64_t)&zeros, a3);
    a3 += v20;
  }

  ccctr_update_internal(*(void *)(a1 + 56), (uint64_t)v11, i, (uint64_t)&zeros, (uint64_t)v25);
  cc_clear(i, v25);
  if (a4) {
    v21 = __s;
  }
  else {
    v21 = &zeros;
  }
  update_with_ctr(a1, (uint64_t)v11, (uint64_t)v21);
  BOOL v22 = cczp_n(*(void *)(a1 + 56));
  cc_clear(v22, v11);
  v18 = 0LL;
  ++*(void *)(a1 + 48);
LABEL_21:
  cc_clear(0x30uLL, __s);
  return v18;
}

        v27 = v13;
        BOOL v28 = sub_2121E4((_BYTE *)&dword_0 + 1, v10, 1, v11);
        v13 = v27;
        id v11 = v28;
        if (!v27) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }

  __break(1u);
LABEL_23:
  swift_once(&qword_3A7D18, sub_2384DC);
LABEL_5:
  v37 = off_3A8E78[0];
  v82 = off_3A8E78[0];
  (*(void (**)(char *, uint64_t, uint64_t))(v30 + 16))(v33, v77, v13);
  swift_retain(v37);
  sub_21E9B8((uint64_t)v33, v13, v65, v83);
  if (!(_DWORD)a5)
  {
    __break(1u);
LABEL_25:
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
  }

  v63 = a10;
  v77 = v83[0];
  v65 = (uint64_t)v83 + 1;
  swift_retain(v37);
  LOBYTE(v3_Block_object_dispose((const void *)(v1 - 136), 8) = 1;
  v39 = v69;
  while (1)
  {
    v83[0] = v77;
    swift_retain(v77);
    sub_210E4C(v83, v74, v76);
    v83[0] = (uint64_t)v37;
    v40 = sub_235074();
    sub_2116A0((uint64_t)v83, v25, (uint64_t)&type metadata for SecureBytes, v40);
    v42 = v70;
    v41 = v71;
    (*(void (**)(char *, uint64_t, uint64_t))(v70 + 16))(v21, v73, v71);
    v43 = v75;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v39 + 48))(v21, 1LL, v75) == 1)
    {
      (*(void (**)(char *, uint64_t))(v42 + 8))(v21, v41);
    }

    else
    {
      v44 = (uint64_t)v64;
      (*(void (**)(char *, char *, uint64_t))(v39 + 32))(v64, v21, v43);
      sub_2116A0(v44, v25, v43, v63);
      (*(void (**)(uint64_t, uint64_t))(v39 + 8))(v44, v43);
    }

    LOBYTE(v83[0]) = v38;
    sub_211B5C((uint64_t)v83, v65, v25);
    v45 = v66;
    sub_2117B0(v25, v46, v66);
    v47 = v68;
    WitnessTable = swift_getWitnessTable(&unk_280724, v68);
    v49 = sub_23C1EC((uint64_t)v45, v47, WitnessTable);
    (*(void (**)(char *, uint64_t))(v72 + 8))(v45, v47);
    swift_release(v37);
    v50 = swift_retain(v49);
    sub_234608(v50);
    swift_release(v49);
    (*(void (**)(char *, uint64_t))(v67 + 8))(v29, v25);
    v38 = v38 + 1;
    v37 = (int *)v49;
    if ((v38 & 0x100) != 0)
    {
      __break(1u);
      break;
    }
  }

  v51 = v62;
  if (v62 < 0) {
    goto LABEL_25;
  }
  v52 = (uint64_t)v82;
  swift_beginAccess(v82 + 4, v83, 0LL, 0LL);
  v53 = *(void *)(v52 + 16);
  v54 = sub_234134(0LL, v51, v53, v52);
  if ((v55 & 1) != 0) {
    v56 = v53;
  }
  else {
    v56 = v54;
  }
  if ((v56 | v53) < 0) {
    goto LABEL_26;
  }
  if (v53 < v56) {
    goto LABEL_27;
  }
  v78 = 0LL;
  v79 = v56;
  v80 = v52;
  swift_retain(v52);
  v57 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A89B8);
  v58 = type metadata accessor for SecureBytes.Backing(0LL);
  v59 = sub_22E92C();
  Slice<>.withUnsafeBytes<A>(_:)(&v81, sub_23A8B8, 0LL, v57, v58, v59);
  swift_release(v49);
  swift_release(v77);
  result = swift_release_n(v52, 2LL);
  *v61 = v81;
  return result;
}

  __break(1u);
  return result;
}

BOOL isWellFormedAssetType(void *a1)
{
  id v1 = a1;
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    && [v1 hasPrefix:@"com.apple.MobileAsset."]
    && (id v3 = [v1 length], v3 > objc_msgSend(@"com.apple.MobileAsset.", "length"))
    && ([v1 containsString:@".."] & 1) == 0)
  {
    id v6 = assetTypeDisallowedCharacterSet();
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    BOOL v4 = [v1 rangeOfCharacterFromSet:v7] == (id)0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    BOOL v4 = 0LL;
  }

  return v4;
}

id assetTypeDisallowedCharacterSet()
{
  if (assetTypeDisallowedCharacterSet_once != -1) {
    dispatch_once(&assetTypeDisallowedCharacterSet_once, &__block_literal_global_642);
  }
  return (id)assetTypeDisallowedCharacterSet_disallowedSet;
}

LABEL_10:
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager isAllowlistedForCommand:]",  @"Unknown Command: %lld (using default command behavior of not allowlisting)",  v3,  v4,  v5,  v6,  a3);
  }

  return 0;
}

  v10 = v9;

  return v10;
}

  v27 = (void *)objc_claimAutoreleasedReturnValue(+[MADAnalyticsManager getAnalyticsManager](&OBJC_CLASS___MADAnalyticsManager, "getAnalyticsManager"));
  BOOL v28 = (void *)objc_claimAutoreleasedReturnValue([v11 assetSpecifier]);
  id v29 = (void *)objc_claimAutoreleasedReturnValue([v11 assetType]);
  id v30 = (void *)objc_claimAutoreleasedReturnValue([v11 assetVersion]);
  v31 =  [v27 recordMobileAssetPromotionAttempt:v28 assetType:v29 assetVersion:v30 osPromotion:0 successfullyPromoted:v15 != 0];

  return v15;
}

    goto LABEL_11;
  }

  id v11 = 0LL;
  while (1)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted currentEntryIDs](self, "currentEntryIDs"));
    v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v11]);
    v14 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v6, v13);

    if ((v14 & 1) != 0) {
      break;
    }
    ++v11;
    v15 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted currentEntryIDs](self, "currentEntryIDs"));
    v16 = [v15 count];
  }

  v21 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted moduleName](self, "moduleName"));
  BOOL v22 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetPersisted persistedStateFilename:forFileID:ofEntryName:]( &OBJC_CLASS___MADAutoAssetPersisted,  "persistedStateFilename:forFileID:ofEntryName:",  v21,  @"Entry",  v6));

  v23 = (void *)objc_claimAutoreleasedReturnValue([v22 lastPathComponent]);
  id v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted persistedEntry:fromLocation:](self, "persistedEntry:fromLocation:", v6, v7));
  v25 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted currentEntryIDs](self, "currentEntryIDs"));
  [v25 removeObjectAtIndex:v11];

  -[MADAutoAssetPersisted _persistStatusChange:ofEntryName:withEntrySummary:currentStatus:fromLocation:]( self,  "_persistStatusChange:ofEntryName:withEntrySummary:currentStatus:fromLocation:",  v24,  v6,  @"removing entry",  4LL,  v7);
  -[MADAutoAssetPersisted _removeEntryFile:reason:fromLocation:]( self,  "_removeEntryFile:reason:fromLocation:",  v22,  @"requested-by-module",  v7);
  if (-[MADAutoAssetPersisted cachingEnabled](self, "cachingEnabled") && v23)
  {
    id v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted knownPersistedStates](self, "knownPersistedStates"));
    [v26 removeObjectForKey:v23];
  }

  -[MADAutoAssetPersisted _persistTableOfContents:forEntryName:withEntryStatus:]( self,  "_persistTableOfContents:forEntryName:withEntryStatus:",  @"removePersistedEntry",  v6,  4LL);

LABEL_11:
}

  return v31;
}

  BOOL v22 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Failed to ungraft: %@", v19));
  v23 = [v22 UTF8String];
  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[SecureMobileAssetBundle ungraft:]",  @"[SMA] %s",  v24,  v25,  v26,  v27,  (uint64_t)v23);

  if (!a3) {
    goto LABEL_12;
  }
  v19 = v19;
  BOOL v28 = 0;
  *a3 = v19;
LABEL_15:

  return v28;
}

  return v4;
}

  id v24 = 0LL;
LABEL_11:
  v47 = v17;
  if (v20)
  {
    v25 = v17 == 0LL;
    id v26 = v16;
    v27 = v25;
    BOOL v28 = v20;
    id v29 = objc_claimAutoreleasedReturnValue([v20 checkedDescription]);
    id v30 = v23;
    v31 = v15;
    BOOL v32 = (void *)v29;
    LOBYTE(v42) = 0;
    LOBYTE(v41) = v18 == 0LL;
    LOBYTE(v40) = v27;
    v16 = v26;
    LOBYTE(v39) = v19 == 0LL;
    v38 = v26;
    v34 = (void *)v44;
    id v33 = v45;
    __int16 v35 = (void *)v43;
    v36 =  [v45 recordMobileAssetSecureAttempt:v44 assetType:v43 assetVersion:v50 clientName:v51 operation:a6 secureReason:v30 fromLocation:v38 suces sfullyPersonalized:v39 personalizeFailureReason:v49 sucessfullyMounted:v40 mountingFailureReason:v48 successfullyGrafted:v41 g raftingFailureReason:v24 successfullyMappedToExclave:v42 mapToExclaveFailureReason:v29];

    v15 = v31;
    if (v18) {
      goto LABEL_16;
    }
  }

  else
  {
    BOOL v28 = 0LL;
    LOBYTE(v42) = 1;
    LOBYTE(v41) = v18 == 0LL;
    LOBYTE(v40) = v17 == 0LL;
    LOBYTE(v39) = v19 == 0LL;
    v34 = (void *)v44;
    id v33 = v45;
    __int16 v35 = (void *)v43;
    v37 =  [v45 recordMobileAssetSecureAttempt:v44 assetType:v43 assetVersion:v50 clientName:v51 operation:a6 secureReason:v23 fromLocation:v16 suces sfullyPersonalized:v39 personalizeFailureReason:v49 sucessfullyMounted:v40 mountingFailureReason:v48 successfullyGrafted:v41 g raftingFailureReason:v24 successfullyMappedToExclave:v42 mapToExclaveFailureReason:0];
    if (v18) {
LABEL_16:
    }
  }

  if (v47) {

  }
  if (v19) {
}
  }

        BOOL v32 = @"N";
        goto LABEL_11;
      }
    }

    id v33 = @"N";
    if (v20) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }

  id v24 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager clientRequestMessageSetPolicy:]( self,  "clientRequestMessageSetPolicy:",  v18));
  -[MADAutoAssetControlManager initialStatusForSetJob:withJobUUID:usingSetDescriptor:usingSetPolicy:]( self,  "initialStatusForSetJob:withJobUUID:usingSetDescriptor:usingSetPolicy:",  v15,  v17,  v21,  v24);

LABEL_19:
}

  return v10;
}
  }

  v5 = 0LL;
  do
  {
    id v6 = *v3++;
    v5 = v6 | (v5 << 8);
    --v2;
  }

  while (v2);
  result = 0LL;
  *a2 = v5;
  return result;
}

  *(void *)(a1 + 16) = v13;
  return result;
}

    id v6 = 5;
    goto LABEL_12;
  }

  if (qword_3A7D68)
  {
    if (byte_3A7D78 == result)
    {
LABEL_16:
      id v6 = 4;
      goto LABEL_12;
    }

    if (qword_3A7D68 != 1)
    {
      for (i = &stru_20.segname[1]; ; ++i)
      {
        id v11 = i - 39;
        if (__OFADD__(i - 40, 1LL)) {
          break;
        }
        if (v11 == qword_3A7D68) {
          return result;
        }
      }

      goto LABEL_24;
    }
  }

  return result;
}

BOOL _isAssetTypeAllowlisted(void *value)
{
  if (_isAssetTypeAllowlisted_allowListOnce != -1) {
    dispatch_once(&_isAssetTypeAllowlisted_allowListOnce, &__block_literal_global_13);
  }
  return CFSetContainsValue((CFSetRef)_isAssetTypeAllowlisted_explicitAllowList, value) != 0;
}

uint64_t checkConnectionAccessToAssetType(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  CFErrorRef error = 0LL;
  xpc_connection_get_audit_token(v3, &v49);
  audit_token_t token = v49;
  v5 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &token);
  id v6 = v5;
  if (!v5)
  {
    uint64_t pid = xpc_connection_get_pid(v3);
    _MobileAssetLog( 0LL,  3,  (uint64_t)"checkConnectionAccessToAssetType",  @"Couldn't create secure task for client %d",  v16,  v17,  v18,  v19,  pid);
    uint64_t v14 = 5LL;
    goto LABEL_33;
  }

  CFTypeRef v7 = SecTaskCopyValueForEntitlement(v5, @"com.apple.private.assets.bypass-asset-types-check", &error);
  if (v7)
  {
    id v8 = (id)v7;
    CFTypeID v9 = CFGetTypeID(v7);
    if (v9 != CFBooleanGetTypeID())
    {
      _MobileAssetLog( 0LL,  5,  (uint64_t)"checkConnectionAccessToAssetType",  @"Entitlement '%@' is not an BOOLean value",  v10,  v11,  v12,  v13,  (uint64_t)@"com.apple.private.assets.bypass-asset-types-check");
      goto LABEL_31;
    }

    if (CFBooleanGetValue((CFBooleanRef)v8))
    {
      uint64_t v14 = 0LL;
LABEL_32:
      CFRelease(v8);
      goto LABEL_33;
    }

    CFRelease(v8);
  }

  CFTypeRef v20 = SecTaskCopyValueForEntitlement(v6, @"com.apple.private.assets.accessible-asset-types", &error);
  if (!v20)
  {
    if (error) {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"checkConnectionAccessToAssetType",  @"Unable to look up client's entitlement: %@",  v21,  v22,  v23,  v24,  (uint64_t)error);
    }
    else {
      _MobileAssetLog( 0LL,  7,  (uint64_t)"checkConnectionAccessToAssetType",  @"Client process does not have '%@' entitlement",  v21,  v22,  v23,  v24,  (uint64_t)@"com.apple.private.assets.accessible-asset-types");
    }
    id v8 = 0LL;
LABEL_31:
    uint64_t v14 = _checkBooleanEntitlement(v6, v4);
    if (!v8) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }

  id v8 = (id)v20;
  CFTypeID v25 = CFGetTypeID(v20);
  if (v25 != CFArrayGetTypeID())
  {
    _MobileAssetLog( 0LL,  5,  (uint64_t)"checkConnectionAccessToAssetType",  @"Entitlement '%@' is not an array",  v26,  v27,  v28,  v29,  (uint64_t)@"com.apple.private.assets.accessible-asset-types");
    goto LABEL_31;
  }

  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  id v8 = v8;
  id v30 = [v8 countByEnumeratingWithState:&v43 objects:v50 count:16];
  if (!v30)
  {
LABEL_25:

    goto LABEL_31;
  }

  id v31 = v30;
  uint64_t v32 = *(void *)v44;
LABEL_13:
  uint64_t v33 = 0LL;
  while (1)
  {
    if (*(void *)v44 != v32) {
      objc_enumerationMutation(v8);
    }
    v34 = *(void **)(*((void *)&v43 + 1) + 8 * v33);
    __int16 v35 = objc_autoreleasePoolPush();
LABEL_23:
    objc_autoreleasePoolPop(v35);
    if (v31 == (id)++v33)
    {
      id v31 = [v8 countByEnumeratingWithState:&v43 objects:v50 count:16];
      if (v31) {
        goto LABEL_13;
      }
      goto LABEL_25;
    }
  }

  v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "substringToIndex:", (char *)objc_msgSend( v34,  "length") - 1));
  if ([v36 isEqualToString:@"com.apple.MobileAsset."])
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"checkConnectionAccessToAssetType",  @"Use of the wildcard asset type 'com.apple.MobileAsset.*' is not allowed",  v37,  v38,  v39,  v40,  v42);
LABEL_22:

    goto LABEL_23;
  }

LABEL_39:
  objc_autoreleasePoolPop(v35);

  uint64_t v14 = 0LL;
  if (v8) {
    goto LABEL_32;
  }
LABEL_33:
  if (error)
  {
    CFRelease(error);
    CFErrorRef error = 0LL;
  }

  if (v6) {
    CFRelease(v6);
  }

  return v14;
}

id getAssetTypeFromTaskDescriptor(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    CFTypeID v9 = 0LL;
    v5 = 0LL;
LABEL_9:
    id v6 = 0LL;
    goto LABEL_10;
  }

  id v3 = disassembleTaskDescriptor(v1);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  v5 = v4;
  if (!v4)
  {
    CFTypeID v9 = 0LL;
    goto LABEL_9;
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:@"isXml"]);
  if (!v6)
  {
LABEL_6:
    CFTypeID v9 = 0LL;
    goto LABEL_10;
  }

  CFTypeRef v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKey:@"normalizedAssetType"]);
  id v8 = assetTypeFromNormalized(v7);
  CFTypeID v9 = (void *)objc_claimAutoreleasedReturnValue(v8);

  if (!isWellFormedAssetType(v9))
  {

    goto LABEL_6;
  }

NSMutableDictionary *disassembleTaskDescriptor(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 pathExtension]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 componentsSeparatedByString:@"."]);
  if ((unint64_t)[v3 count] < 3)
  {
    CFTypeRef v7 = 0LL;
  }

  else
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:1]);

    v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:2]);
    id v6 = normalizePurpose(v5);
    CFTypeRef v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

    uint64_t v2 = (void *)v4;
  }

  if ((unint64_t)[v3 count] < 4)
  {
    id v8 = 0LL;
    if (v2) {
      goto LABEL_6;
    }
LABEL_11:
    CFTypeID v9 = 0LL;
    goto LABEL_24;
  }

  id v8 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:3]);
  if (!v2) {
    goto LABEL_11;
  }
LABEL_6:
  CFTypeID v9 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  if ([v2 isEqualToString:@"xml"])
  {
    if (v8) {
      uint64_t v10 = 4LL;
    }
    else {
      uint64_t v10 = 1LL;
    }
  }

  else if ([v2 isEqualToString:@"pmv"])
  {
    uint64_t v10 = 3LL;
  }

  else
  {
    if (v8) {
      uint64_t v10 = 5LL;
    }
    else {
      uint64_t v10 = 2LL;
    }
    -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v2, @"assetIdentifier");
  }

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v10));
  -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v11, @"isXml");

  if (v7) {
    -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v7, @"Purpose");
  }
  if (v8) {
    -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v8, @"AutoAssetJob");
  }
  id v12 = [v1 rangeOfString:@"."];
  if (v12 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "substringWithRange:", 0, v12));
    -[NSMutableDictionary setValue:forKey:](v9, "setValue:forKey:", v13, @"normalizedAssetType");
  }

LABEL_24:
  return v9;
}

  v99 = objc_alloc((Class)p_ivars[137]);
  v96 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  if (v96) {
    uint64_t v27 = @"Y";
  }
  else {
    uint64_t v27 = @"N";
  }
  v80 = v27;
  v93 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager serverConnectionPolicy](self, "serverConnectionPolicy"));
  if (v93) {
    uint64_t v28 = @"Y";
  }
  else {
    uint64_t v28 = @"N";
  }
  v76 = v28;
  v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager connectionServer](self, "connectionServer"));
  if (v90) {
    uint64_t v29 = @"Y";
  }
  else {
    uint64_t v29 = @"N";
  }
  v72 = v29;
  v87 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager stateTable](self, "stateTable"));
  if (v87) {
    id v30 = @"Y";
  }
  else {
    id v30 = @"N";
  }
  v70 = v30;
  v84 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
  if (v84) {
    id v31 = @"Y";
  }
  else {
    id v31 = @"N";
  }
  v66 = v31;
  v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
  if (v82) {
    uint64_t v32 = @"Y";
  }
  else {
    uint64_t v32 = @"N";
  }
  v63 = v32;
  v78 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownDescriptors](self, "persistedKnownDescriptors"));
  if (v78) {
    uint64_t v33 = @"Y";
  }
  else {
    uint64_t v33 = @"N";
  }
  v62 = v33;
  v74 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownSetConfigurations](self, "persistedKnownSetConfigurations"));
  if (v74) {
    v34 = @"Y";
  }
  else {
    v34 = @"N";
  }
  v61 = v34;
  v68 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( self,  "persistedKnownSetAtomicInstances"));
  if (v68) {
    __int16 v35 = @"Y";
  }
  else {
    __int16 v35 = @"N";
  }
  v60 = v35;
  v64 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
  if (v64) {
    v36 = @"Y";
  }
  else {
    v36 = @"N";
  }
  v59 = v36;
  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedDownloadedSetDescriptors]( self,  "persistedDownloadedSetDescriptors"));
  if (v37) {
    uint64_t v38 = @"Y";
  }
  else {
    uint64_t v38 = @"N";
  }
  uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedSetTargets](self, "persistedSetTargets"));
  uint64_t v40 = p_ivars;
  if (v39) {
    v41 = @"Y";
  }
  else {
    v41 = @"N";
  }
  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedSetLookupResults](self, "persistedSetLookupResults"));
  if (v42) {
    __int128 v43 = @"Y";
  }
  else {
    __int128 v43 = @"N";
  }
  __int128 v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager setLockUsageMap](self, "setLockUsageMap"));
  __int128 v45 = @"Y:";
  if (!v44) {
    __int128 v45 = @"N";
  }
  v58 = v41;
  p_ivars = v40;
  v100 = (__CFString *)[v99 initWithFormat:@"logger:%@|policy:%@|server:%@|table:%@|FSM:%@|(persisted)active:%@,known:%@,configs:%@,AI:%@|(sets)active:%@,desc:%@,targets:%@,lookups:%@,map:%@", v80, v76, v72, v70, v66, v63, v62, v61, v60, v59, v38, v58, v43, v45];

LABEL_66:
  v85 = objc_alloc((Class)p_ivars[137]);
  v97 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentStatusBySelector](self, "currentStatusBySelector"));
  v83 = [v97 count];
  v94 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentSetStatusByInstance](self, "currentSetStatusByInstance"));
  v79 = [v94 count];
  v91 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsBySelector](self, "currentJobsBySelector"));
  v75 = [v91 count];
  v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentSetJobsByIdentifier](self, "currentSetJobsByIdentifier"));
  v71 = [v88 count];
  v81 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsByUUID](self, "currentJobsByUUID"));
  v69 = [v81 count];
  v77 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager lookupGrantsByAssetType](self, "lookupGrantsByAssetType"));
  v67 = [v77 count];
  v73 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetConfigurationsByIdentifier]( self,  "knownSetConfigurationsByIdentifier"));
  v65 = [v73 count];
  __int128 v46 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetAtomicInstancesByInstance]( self,  "knownSetAtomicInstancesByInstance"));
  v47 = [v46 count];
  v48 = -[MADAutoAssetControlManager locateDownloadedCurrentDownloadedCount]( self,  "locateDownloadedCurrentDownloadedCount");
  audit_token_t v49 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( self,  "downloadedSetDescriptorsByInstance"));
  v50 = [v49 count];
  v51 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager alreadyScheduledSelectors](self, "alreadyScheduledSelectors"));
  v52 = [v51 count];
  v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager timedOperations](self, "timedOperations"));
  v54 = [v53 count];
  v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager clientRequestsBeingTracked](self, "clientRequestsBeingTracked"));
  v56 = [v85 initWithFormat:@"%@|status:%ld(set:%ld)|jobs:%ld(set:%ld)(UUID:%ld)|grants:%ld|configs:%ld|AI:%ld|FS:%ld(set:%ld)|sched:%ld|timed:%ld|client:%ld", v100, v83, v79, v75, v71, v69, v67, v65, v47, v48, v50, v52, v54, objc_msgSend(v55, "count")];

  return v56;
}

          _os_log_impl(&dword_0, v38, OS_LOG_TYPE_DEFAULT, v39, buf, 0x16u);

          self = v120;
        }

        else
        {
          self = v120;
          __int128 v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v120, "logger"));
          v34 = (os_log_s *)objc_claimAutoreleasedReturnValue([v44 oslog]);

          if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          __int16 v35 = (void *)objc_claimAutoreleasedReturnValue([v12 summary]);
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v18 summary]);
          *(_DWORD *)buf = 138543618;
          v134 = (uint64_t)v35;
          v135 = 2114;
          v136 = (uint64_t)v37;
          _os_log_error_impl( &dword_0,  v34,  OS_LOG_TYPE_ERROR,  "\n {chooseNewerSetStatus} ignoring (invalid restore version) | nextLeftEntry:%{public}@ | foundRightEntry:%{public}@",  buf,  0x16u);
        }

        goto LABEL_26;
      }

      ++v111;
      if (!v119) {
        goto LABEL_29;
      }
      uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v27 = (id)objc_claimAutoreleasedReturnValue([v40 oslog]);

      if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT))
      {
        v41 = (void *)objc_claimAutoreleasedReturnValue([v12 fullAssetSelector]);
        id v31 = (id)objc_claimAutoreleasedReturnValue([v41 summary]);
        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([0 fullAssetSelector]);
        __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([v42 summary]);
        *(_DWORD *)buf = 138543618;
        v134 = (uint64_t)v31;
        v135 = 2114;
        v136 = (uint64_t)v43;
        _os_log_impl( &dword_0,  (os_log_t)v27,  OS_LOG_TYPE_DEFAULT,  "\n{chooseNewerSetStatus} | rightNotPresent | left:%{public}@ | right:%{public}@",  buf,  0x16u);

        goto LABEL_27;
      }

            CFTypeID v9 = v18;
          }
        }

        objc_autoreleasePoolPop(v15);
        uint64_t v13 = (char *)v13 + 1;
      }

      while (v11 != v13);
      id v30 = [v9 countByEnumeratingWithState:&v32 objects:v36 count:16];
      uint64_t v11 = v30;
    }

    while (v30);
  }

  if (!*(_BYTE *)(a1 + 64)) {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
  }
}

  return v11;
}

  v110 = objc_alloc((Class)p_ivars[137]);
  v107 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  if (v107) {
    uint64_t v27 = @"Y";
  }
  else {
    uint64_t v27 = @"N";
  }
  v91 = v27;
  v104 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager serverConnectionPolicy](self, "serverConnectionPolicy"));
  if (v104) {
    uint64_t v28 = @"Y";
  }
  else {
    uint64_t v28 = @"N";
  }
  v87 = v28;
  v101 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager connectionServer](self, "connectionServer"));
  if (v101) {
    uint64_t v29 = @"Y";
  }
  else {
    uint64_t v29 = @"N";
  }
  v83 = v29;
  v98 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager stateTable](self, "stateTable"));
  if (v98) {
    id v30 = @"Y";
  }
  else {
    id v30 = @"N";
  }
  v81 = v30;
  v95 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
  if (v95) {
    id v31 = @"Y";
  }
  else {
    id v31 = @"N";
  }
  v77 = v31;
  v93 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
  if (v93) {
    uint64_t v32 = @"Y";
  }
  else {
    uint64_t v32 = @"N";
  }
  v73 = v32;
  v89 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownDescriptors](self, "persistedKnownDescriptors"));
  if (v89) {
    uint64_t v33 = @"Y";
  }
  else {
    uint64_t v33 = @"N";
  }
  v69 = v33;
  v85 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownSetConfigurations](self, "persistedKnownSetConfigurations"));
  if (v85) {
    v34 = @"Y";
  }
  else {
    v34 = @"N";
  }
  v67 = v34;
  v79 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( self,  "persistedKnownSetAtomicInstances"));
  if (v79) {
    __int16 v35 = @"Y";
  }
  else {
    __int16 v35 = @"N";
  }
  v65 = v35;
  v75 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
  if (v75) {
    v36 = @"Y";
  }
  else {
    v36 = @"N";
  }
  v63 = v36;
  v71 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedDownloadedSetDescriptors]( self,  "persistedDownloadedSetDescriptors"));
  if (v71) {
    uint64_t v37 = @"Y";
  }
  else {
    uint64_t v37 = @"N";
  }
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedSetTargets](self, "persistedSetTargets"));
  uint64_t v39 = p_ivars;
  if (v38) {
    uint64_t v40 = @"Y";
  }
  else {
    uint64_t v40 = @"N";
  }
  v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedSetLookupResults](self, "persistedSetLookupResults"));
  if (v41) {
    uint64_t v42 = @"Y";
  }
  else {
    uint64_t v42 = @"N";
  }
  __int128 v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager setLockUsageMap](self, "setLockUsageMap"));
  if (v43) {
    __int128 v44 = @"Y";
  }
  else {
    __int128 v44 = @"N";
  }
  v59 = v40;
  p_ivars = v39;
  v111 = (__CFString *)[v110 initWithFormat:@"logger:%@|policy:%@|server:%@|table:%@|FSM:%@|(persisted)activeJobs:%@,knownDescriptors:%@,setConfigurations:%@,setAtomicInstances:%@,activeSes:%@,downloadedSets:%@,setTargets:%@,setLookupConfigurations:%@,setLockUsageMap:%@", v91, v87, v83, v81, v77, v73, v69, v67, v65, v63, v37, v59, v42, v44];

LABEL_67:
  v94 = objc_alloc((Class)p_ivars[137]);
  v108 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentStatusBySelector](self, "currentStatusBySelector"));
  v90 = [v108 count];
  v105 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentSetStatusByInstance](self, "currentSetStatusByInstance"));
  v88 = [v105 count];
  v102 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsBySelector](self, "currentJobsBySelector"));
  v84 = [v102 count];
  v99 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentSetJobsByIdentifier](self, "currentSetJobsByIdentifier"));
  v80 = [v99 count];
  v96 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsByUUID](self, "currentJobsByUUID"));
  v76 = [v96 count];
  v92 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager stagerCurrentJob](self, "stagerCurrentJob"));
  if (v92) {
    __int128 v45 = @"Y";
  }
  else {
    __int128 v45 = @"N";
  }
  v74 = v45;
  if (-[MADAutoAssetControlManager receivedDownloadManagerSync](self, "receivedDownloadManagerSync")) {
    __int128 v46 = @"Y";
  }
  else {
    __int128 v46 = @"N";
  }
  v72 = v46;
  v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager lookupGrantsByAssetType](self, "lookupGrantsByAssetType"));
  v68 = [v86 count];
  v82 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetConfigurationsByIdentifier]( self,  "knownSetConfigurationsByIdentifier"));
  v64 = [v82 count];
  v78 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetAtomicInstancesByInstance]( self,  "knownSetAtomicInstancesByInstance"));
  v62 = [v78 count];
  v61 = -[MADAutoAssetControlManager locateDownloadedCurrentDownloadedCount]( self,  "locateDownloadedCurrentDownloadedCount");
  v70 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( self,  "downloadedSetDescriptorsByInstance"));
  v60 = [v70 count];
  v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager alreadyScheduledSelectors](self, "alreadyScheduledSelectors"));
  v47 = [v66 count];
  v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager timedOperations](self, "timedOperations"));
  audit_token_t v49 = [v48 count];
  v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager clientRequestsBeingTracked](self, "clientRequestsBeingTracked"));
  v51 = [v50 count];
  v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager clientRequestsAwaitingSync](self, "clientRequestsAwaitingSync"));
  v53 = [v52 count];
  v54 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager clientRequestsAwaitingFirstUnlock]( self,  "clientRequestsAwaitingFirstUnlock"));
  v55 = [v54 count];
  v56 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadManagerEventsAwaitingResumed]( self,  "downloadManagerEventsAwaitingResumed"));
  v57 = [v94 initWithFormat:@"%@|statusBySelector:%ld(set:%ld)|jobsByInstance:%ld(setJobsByID:%ld)|jobsByUUID:%ld|stagerJob:%@|DMSync:%@|lookupGrants:%ld|setConfigs:%ld|atomicInstances:%ld|downloaded:%ld(set:%ld)|scheduledSelectors:%ld|timedOps:%ld|clientRequests:%ld|awaitingSync:%ld|awaitingUnlock:%ld|awaitingResume:%ld", v111, v90, v88, v84, v80, v76, v74, v72, v68, v64, v62, v61, v60, v47, v49, v51, v53, v55, objc_msgSend(v56, "count")];

  return v57;
}

  return 0LL;
}
}

    uint64_t v17 = 0LL;
    goto LABEL_25;
  }

  CFTypeRef v20 = v3;
  v109 = objc_alloc(&OBJC_CLASS___MANAutoAssetSetStatus);
  v160 = (void *)objc_claimAutoreleasedReturnValue([v20 clientDomainName]);
  v158 = (void *)objc_claimAutoreleasedReturnValue([v20 assetSetIdentifier]);
  v142 = (void *)objc_claimAutoreleasedReturnValue([v20 configuredAssetEntries]);
  v159 = +[MASAutoAssetSetEntry newShimmedArrayFromFramework:]( &OBJC_CLASS___MASAutoAssetSetEntry,  "newShimmedArrayFromFramework:",  v142);
  v134 = objc_claimAutoreleasedReturnValue([v20 atomicInstancesDownloaded]);
  v128 = objc_claimAutoreleasedReturnValue([v20 catalogCachedAssetSetID]);
  v116 = objc_claimAutoreleasedReturnValue([v20 catalogDownloadedFromLive]);
  v157 = (id)objc_claimAutoreleasedReturnValue([v20 catalogLastTimeChecked]);
  v122 = objc_claimAutoreleasedReturnValue([v20 catalogPostedDate]);
  v156 = (void *)objc_claimAutoreleasedReturnValue([v20 newerAtomicInstanceDiscovered]);
  v143 = (id)objc_claimAutoreleasedReturnValue([v20 newerDiscoveredAtomicEntries]);
  v155 = +[MASAutoAssetSetAtomicEntry newShimmedArrayFromFramework:]( &OBJC_CLASS___MASAutoAssetSetAtomicEntry,  "newShimmedArrayFromFramework:");
  v162 = (id)objc_claimAutoreleasedReturnValue([v20 latestDownloadedAtomicInstance]);
  v141 = (void *)objc_claimAutoreleasedReturnValue([v20 latestDowloadedAtomicInstanceEntries]);
  v161 = +[MASAutoAssetSetAtomicEntry newShimmedArrayFromFramework:]( &OBJC_CLASS___MASAutoAssetSetAtomicEntry,  "newShimmedArrayFromFramework:");
  v147 = (void *)objc_claimAutoreleasedReturnValue([v20 downloadedCatalogCachedAssetSetID]);
  v152 = (id)objc_claimAutoreleasedReturnValue([v20 downloadedCatalogDownloadedFromLive]);
  v146 = (void *)objc_claimAutoreleasedReturnValue([v20 downloadedCatalogLastTimeChecked]);
  v149 = (id)objc_claimAutoreleasedReturnValue([v20 downloadedCatalogPostedDate]);
  v140 = (void *)objc_claimAutoreleasedReturnValue([v20 currentNotifications]);
  v148 = +[MASAutoAssetSetNotifications newShimmedFromFramework:]( &OBJC_CLASS___MASAutoAssetSetNotifications,  "newShimmedFromFramework:");
  v139 = (void *)objc_claimAutoreleasedReturnValue([v20 currentNeedPolicy]);
  v144 = +[MASAutoAssetSetPolicy newShimmedFromFramework:]( &OBJC_CLASS___MASAutoAssetSetPolicy,  "newShimmedFromFramework:");
  v105 = objc_claimAutoreleasedReturnValue([v20 schedulerPolicy]);
  v111 = +[MASAutoAssetSetPolicy newShimmedFromFramework:]( &OBJC_CLASS___MASAutoAssetSetPolicy,  "newShimmedFromFramework:",  v105);
  v102 = (void *)objc_claimAutoreleasedReturnValue([v20 stagerPolicy]);
  v90 = +[MASAutoAssetSetPolicy newShimmedFromFramework:]( &OBJC_CLASS___MASAutoAssetSetPolicy,  "newShimmedFromFramework:",  v102);
  v96 = [v20 haveReceivedLookupResponse];
  v93 = [v20 downloadUserInitiated];
  v99 = (void *)objc_claimAutoreleasedReturnValue([v20 downloadProgress]);
  uint64_t v21 = +[MASAutoAssetSetProgress newShimmedFromFramework:]( &OBJC_CLASS___MASAutoAssetSetProgress,  "newShimmedFromFramework:",  v99);
  uint64_t v22 = [v20 downloadedNetworkBytes];
  uint64_t v23 = [v20 downloadedFilesystemBytes];
  v87 = (void *)objc_claimAutoreleasedReturnValue([v20 currentLockUsage]);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v20 selectorsForStaging]);
  CFTypeID v25 = (void *)objc_claimAutoreleasedReturnValue([v20 availableForUseError]);
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v20 newerVersionError]);

  v83 = v22;
  uint64_t v27 = v21;
  BYTE1(v82) = v93;
  LOBYTE(v82) = v96;
  uint64_t v14 = (void *)v122;
  v15 = (void *)v128;
  uint64_t v16 = (void *)v134;
  uint64_t v17 = -[MANAutoAssetSetStatus initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:withCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:]( v109,  "initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:withC atalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewe rAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloa dedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDow nloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:w ithSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:withDownloadUserInitiated:withDownloadProgres s:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withCurrentLockUsage:withSelectorsForStaging:withAv ailableForUseError:withNewerVersionError:",  v160,  v158,  v159,  v134,  v128,  v116,  v157,  v122,  v156,  v155,  v162,  v161,  v147,  v152,  v146,  v149,  v148,  v144,  v111,  v90,  v82,  v21,  v83,  v23,  v87,  v24,  v25,  v26);

  uint64_t v13 = (void *)v116;
  uint64_t v28 = (void *)v105;
LABEL_18:

LABEL_19:
LABEL_25:

  return v17;
}

          id v30 = sub_222964();
          id v31 = swift_allocError(&type metadata for CryptoKitASN1Error, v30, 0LL, 0LL);
          *uint64_t v32 = 3;
          swift_willThrow(v31);
          swift_unknownObjectRelease(v25);
          swift_bridgeObjectRelease(v24);
          sub_225AA4((uint64_t *)v50);
          sub_225BF0( (uint64_t)v49,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
          sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
          sub_22293C(&v65);
          sub_222AE4((uint64_t)&v44, (uint64_t)v64, &qword_3A8950);
          uint64_t v23 = v64;
          return sub_22489C(v23);
        }

        CFTypeRef v20 = sub_222964();
        uint64_t v21 = swift_allocError(&type metadata for CryptoKitASN1Error, v20, 0LL, 0LL);
        *uint64_t v22 = 1;
        swift_willThrow(v21);
        sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
      }

      v67 = v43;
      sub_22293C(&v67);
      sub_222AE4((uint64_t)&v44, (uint64_t)v66, &qword_3A8950);
      uint64_t v23 = v66;
      return sub_22489C(v23);
    }
  }

  id v6 = sub_222964();
  CFTypeRef v7 = swift_allocError(&type metadata for CryptoKitASN1Error, v6, 0LL, 0LL);
  *id v8 = 3;
  return (void *)swift_willThrow(v7);
}

  *a1 = v10;
  a1[1] = a3;
  return a3;
}

  *a1 = v8;
  a1[1] = a3;
  return a3;
}

  *a1 = v9;
  a1[1] = a3;
  return a3;
}

  *a1 = v9;
  a1[1] = a3;
  return a3;
}

  *a1 = v8;
  a1[1] = a3;
  return a3;
}

id assetTypeFromNormalized(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString string](&OBJC_CLASS___NSMutableString, "string"));
  [v2 appendString:v1];

  objc_msgSend( v2,  "replaceOccurrencesOfString:withString:options:range:",  @"_",  @".",  2,  0,  objc_msgSend(v2, "length"));
  return v2;
}

id isSoftwareUpdateType(void *a1)
{
  id v1 = a1;
  if (v1 && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v1, v2) & 1) != 0))
  {
    id SoftwareUpdateTypes = getSoftwareUpdateTypes();
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(SoftwareUpdateTypes);
    id v5 = [v4 containsObject:v1];
  }

  else
  {
    id v5 = 0LL;
  }

  return v5;
}

id getSoftwareUpdateTypes()
{
  if (getSoftwareUpdateTypes_softwareUpdateTypesOnce != -1) {
    dispatch_once(&getSoftwareUpdateTypes_softwareUpdateTypesOnce, &__block_literal_global_835);
  }
  return (id)getSoftwareUpdateTypes_softwareUpdateAssetTypes;
}

id logError()
{
  if (logError_logErrorOnce != -1) {
    dispatch_once(&logError_logErrorOnce, &__block_literal_global_180);
  }
  return (id)logError_infoError;
}

void _MobileAssetLog_cold_1()
{
}

uint64_t _checkBooleanEntitlement(__SecTask *a1, void *a2)
{
  id v3 = a2;
  CFErrorRef error = 0LL;
  uint64_t v4 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(a1, v3, &error);
  if (!v4)
  {
    if (error) {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"_checkBooleanEntitlement",  @"Unable to look up client's entitlement: %@",  v5,  v6,  v7,  v8,  (uint64_t)error);
    }
    else {
      _MobileAssetLog( 0LL,  5,  (uint64_t)"_checkBooleanEntitlement",  @"Client process does not have '%@' entitlement",  v5,  v6,  v7,  v8,  (uint64_t)v3);
    }
    uint64_t v15 = 22LL;
    goto LABEL_13;
  }

  CFTypeID v9 = v4;
  CFTypeID v10 = CFGetTypeID(v4);
  if (v10 != CFBooleanGetTypeID())
  {
    uint64_t v16 = @"Entitlement '%@' is not a BOOLean";
LABEL_11:
    _MobileAssetLog(0LL, 5, (uint64_t)"_checkBooleanEntitlement", v16, v11, v12, v13, v14, (uint64_t)v3);
    uint64_t v15 = 22LL;
    goto LABEL_12;
  }

  if (!CFBooleanGetValue(v9))
  {
    uint64_t v16 = @"Value for entitlement %@ is false";
    goto LABEL_11;
  }

  uint64_t v15 = 0LL;
LABEL_12:
  CFRelease(v9);
LABEL_13:
  if (error) {
    CFRelease(error);
  }

  return v15;
}

BOOL sendClientResponse(void *a1, void *a2, int64_t a3)
{
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  BOOL v7 = sendReply(v5, reply, a3);

  return v7;
}

BOOL sendReply(void *a1, void *a2, int64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v11 = v6;
  if (v6)
  {
    xpc_dictionary_set_int64(v6, "Result", a3);
    xpc_connection_send_message(v5, v11);
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"sendReply",  @"Could not send XPC reply with result %lld, because there was no xpc reply dictionary",  v7,  v8,  v9,  v10,  a3);
  }

  return v11 != 0LL;
}

uint64_t _MobileAssetCheckConnectionEntitlementWithName(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_connection_get_audit_token(a1, &v13);
  audit_token_t v12 = v13;
  uint64_t v4 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &v12);
  if (v4)
  {
    uint64_t v9 = v4;
    uint64_t v10 = _checkBooleanEntitlement(v4, v3);
    CFRelease(v9);
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetCheckConnectionEntitlementWithName",  @"Couldn't create secure task",  v5,  v6,  v7,  v8,  *(uint64_t *)v12.val);
    uint64_t v10 = 5LL;
  }

  return v10;
}

uint64_t _MAPreferencesSync(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000LL;
  char v18 = 0;
  id v5 = _preferencesDomainProtectionDispatchQueue();
  uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = ___MAPreferencesSync_block_invoke;
  block[3] = &unk_34DE88;
  id v13 = v4;
  uint64_t v14 = &v15;
  id v12 = v3;
  id v7 = v4;
  id v8 = v3;
  dispatch_sync(v6, block);

  uint64_t v9 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  return v9;
}

id getDownloadManager()
{
  if (getDownloadManager_downloadManagerOnce != -1) {
    dispatch_once(&getDownloadManager_downloadManagerOnce, &__block_literal_global_1000);
  }
  return (id)getDownloadManager_downloadManager;
}

id _MAPreferencesCopyValue(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v33 = 0LL;
    v34 = &v33;
    uint64_t v35 = 0x3032000000LL;
    v36 = __Block_byref_object_copy__2;
    uint64_t v37 = __Block_byref_object_dispose__2;
    id v38 = 0LL;
    id v2 = _preferencesDomainProtectionDispatchQueue();
    id v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v2);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = ___MAPreferencesCopyValue_block_invoke;
    block[3] = &unk_34DEB0;
    id v4 = v1;
    id v31 = v4;
    uint64_t v32 = &v33;
    dispatch_sync(v3, block);

    id v5 = newPrefsCopyValueForKey(v4);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    uint64_t v24 = 0LL;
    CFTypeID v25 = &v24;
    uint64_t v26 = 0x3032000000LL;
    uint64_t v27 = __Block_byref_object_copy__2;
    uint64_t v28 = __Block_byref_object_dispose__2;
    id v29 = 0LL;
    id v7 = _preferencesDomainProtectionDispatchQueue();
    id v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v7);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = ___MAPreferencesCopyValue_block_invoke_2;
    v21[3] = &unk_34DB48;
    uint64_t v23 = &v24;
    id v22 = v4;
    dispatch_sync(v8, v21);

    uint64_t v9 = (void *)v34[5];
    if (v9)
    {
      uint64_t v10 = @"defaults";
    }

    else if (v6)
    {
      uint64_t v10 = @"profile";
      uint64_t v9 = v6;
    }

    else
    {
      uint64_t v9 = (void *)v25[5];
      if (!v9)
      {
        id v12 = 0LL;
        goto LABEL_10;
      }

      uint64_t v10 = @"userdefaults";
    }

    id v12 = v9;
    id v13 = (objc_class *)objc_opt_class(v12);
    uint64_t v14 = NSStringFromClass(v13);
    CFTypeRef v20 = (void *)objc_claimAutoreleasedReturnValue(v14);

LABEL_10:
    id v11 = v12;

    _Block_object_dispose(&v24, 8);
    _Block_object_dispose(&v33, 8);

    goto LABEL_11;
  }

  id v11 = 0LL;
LABEL_11:

  return v11;
}

void sub_7308(_Unwind_Exception *a1)
{
}

id getControlManager()
{
  if (getControlManager_controlManagerOnce != -1) {
    dispatch_once(&getControlManager_controlManagerOnce, &__block_literal_global_628);
  }
  return (id)getControlManager_controlManager;
}

void sub_790C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

__CFString *stringForMAQueryReturnTypes(unint64_t a1)
{
  if (a1 >= 7) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAQueryReturnTypes%llu",  a1));
  }
  else {
    return *(&off_350278 + a1);
  }
}

__CFString *normalizePurposeFromUtf8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
    if (v1)
    {
      id v2 = v1;
      id v3 = normalizePurpose(v1);
      id v4 = (__CFString *)objc_claimAutoreleasedReturnValue(v3);
    }

    else
    {
      id v4 = &stru_355768;
    }
  }

  else
  {
    id v4 = 0LL;
  }

  return v4;
}

BOOL isWellFormedPurpose(void *a1)
{
  id v1 = a1;
  BOOL v7 = 1;
  if (v1)
  {
    uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v1, v2) & 1) == 0
      || ![v1 length]
      || (unint64_t)[v1 length] > 0x3C
      || (id v3 = purposeDisallowedCharacterSet(),
          id v4 = (void *)objc_claimAutoreleasedReturnValue(v3),
          [v1 rangeOfCharacterFromSet:v4],
          uint64_t v6 = v5,
          v4,
          v6))
    {
      BOOL v7 = 0;
    }
  }

  return v7;
}

id queryDecodeClasses()
{
  if (queryDecodeClasses_once != -1) {
    dispatch_once(&queryDecodeClasses_once, &__block_literal_global_613);
  }
  return (id)queryDecodeClasses__queryDecodeClasses;
}

uint64_t isAssetTaskDescriptor(void *a1)
{
  return isTypeDescriptorOfType(a1, 2);
}

uint64_t isTypeDescriptorOfType(void *a1, int a2)
{
  id v3 = disassembleTaskDescriptor(a1);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  uint64_t v5 = v4;
  if (v4 && (uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:@"isXml"])) != 0)
  {
    BOOL v7 = v6;
    unsigned int v8 = [v6 intValue];
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKey:@"normalizedAssetType"]);
    id v10 = assetTypeFromNormalized(v9);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);

    if (v11) {
      BOOL v12 = v8 == a2;
    }
    else {
      BOOL v12 = 0;
    }
    uint64_t v13 = v12;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  return v13;
}

NSMutableSet *getPreinstalledAssetIds(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = -[NSMutableSet initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableSet), "initWithCapacity:", 0LL);
  id RepositoryPath = getRepositoryPath(@"/System/Library/PreinstalledAssetsV2/RequiredByOs");
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  id v16 = normalizedAssetType((uint64_t)v5, v9, v10, v11, v12, v13, v14, v15);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v8 stringByAppendingPathComponent:v17]);
  InstalledAssetIds = getInstalledAssetIds(v18);
  CFTypeRef v20 = (NSMutableSet *)objc_claimAutoreleasedReturnValue(InstalledAssetIds);

  if (v20) {
    -[NSMutableSet unionSet:](v6, "unionSet:", v20);
  }
  else {
    CFTypeRef v20 = -[NSMutableSet initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableSet), "initWithCapacity:", 0LL);
  }
  id v21 = getRepositoryPath(@"/private/var/MobileAsset/PreinstalledAssetsV2/InstallWithOs");
  id v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
  id v30 = normalizedAssetType((uint64_t)v5, v23, v24, v25, v26, v27, v28, v29);
  id v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v22 stringByAppendingPathComponent:v31]);
  uint64_t v33 = getInstalledAssetIds(v32);
  v34 = (NSMutableSet *)objc_claimAutoreleasedReturnValue(v33);

  if (v34)
  {
    -[NSMutableSet unionSet:](v6, "unionSet:", v34);
    if (!a2) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  v34 = -[NSMutableSet initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableSet), "initWithCapacity:", 0LL);
  if (a2) {
LABEL_6:
  }
    *a2 = v20;
LABEL_7:
  if (a3) {
    *a3 = v34;
  }
  -[NSMutableSet unionSet:](v6, "unionSet:", v34);

  return v6;
}

id normalizedAssetType( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString stringWithString:](&OBJC_CLASS___NSMutableString, "stringWithString:", a1));
    objc_msgSend( v8,  "replaceOccurrencesOfString:withString:options:range:",  @".",  @"_",  2,  0,  objc_msgSend(v8, "length"));
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"normalizedAssetType",  @"Could not create normalized asset type",  a5,  a6,  a7,  a8,  v10);
    unsigned int v8 = 0LL;
  }

  return v8;
}

NSMutableSet *getInstalledAssetIds(void *a1)
{
  id v1 = opendir((const char *)[a1 UTF8String]);
  if (v1)
  {
    uint64_t v2 = v1;
    id v3 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
    for (i = readdir(v2); i; i = readdir(v2))
    {
      d_name = i->d_name;
      size_t v6 = strlen(i->d_name);
      if ((uint64_t)(v6 - 5) >= 1)
      {
        size_t v7 = v6;
        if (!strcmp(&d_name[v6 - 5], "asset"))
        {
          d_name[v7 - 6] = 0;
          unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", d_name));
          -[NSMutableSet addObject:](v3, "addObject:", v8);
        }
      }
    }

    closedir(v2);
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

__CFString *repositoryPath(void *a1)
{
  id RepositoryPath = getRepositoryPath(@"/private/var/MobileAsset/AssetsV2");
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue(RepositoryPath);
}

id getRepositoryPath(void *a1)
{
  id v5 = a1;
  if (v5 && (uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v5, v6) & 1) != 0))
  {
    id v7 = v5;
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"getRepositoryPath",  @"ERROR: Invalid string passed to %s",  v1,  v2,  v3,  v4,  (uint64_t)"getRepositoryPath");
    id v7 = 0LL;
  }

  return v7;
}

void sub_92C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id getPathToAssetFileWithPurpose(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v12 = normalizedAssetType((uint64_t)v4, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  v13,  @"xml"));
  uint64_t v15 = repositoryPath(v4);
  id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);

  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 stringByAppendingPathComponent:v13]);
  if (v3)
  {
    id v18 = purposeDirectoryName(v3);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    uint64_t v20 = objc_claimAutoreleasedReturnValue([v17 stringByAppendingPathComponent:v19]);

    uint64_t v17 = (void *)v20;
  }

  id v21 = (void *)objc_claimAutoreleasedReturnValue([v17 stringByAppendingPathComponent:v14]);

  return v21;
}

id filterResults(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (v4)
  {
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    id v5 = v3;
    id v6 = [v5 countByEnumeratingWithState:&v16 objects:v20 count:16];
    uint64_t v7 = v4;
    if (v6)
    {
      id v8 = v6;
      uint64_t v9 = *(void *)v17;
      uint64_t v7 = v4;
      do
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = v7;
        do
        {
          if (*(void *)v17 != v9) {
            objc_enumerationMutation(v5);
          }
          id v12 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)v10);
          uint64_t v13 = objc_autoreleasePoolPush();
          uint64_t v14 = applyFilter(v12, v11);
          uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v14);

          objc_autoreleasePoolPop(v13);
          uint64_t v10 = (char *)v10 + 1;
          uint64_t v11 = v7;
        }

        while (v8 != v10);
        id v8 = [v5 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }

      while (v8);
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  return v7;
}

NSMutableDictionary *dataFillInstalledWithPurpose(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  __int128 v18 = v12;
  id v84 = v13;
  if (!v9 || !v10 || !v12)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"preqs are nil for dataFilling",  v14,  v15,  v16,  v17,  v74);
    goto LABEL_42;
  }

  v80 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  if (!v80)
  {
LABEL_42:
    v80 = 0LL;
    goto LABEL_43;
  }

  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  id v75 = v10;
  id obj = v10;
  id v83 = [obj countByEnumeratingWithState:&v86 objects:v90 count:16];
  if (!v83) {
    goto LABEL_40;
  }
  uint64_t v82 = *(void *)v87;
  id v77 = v11;
  v78 = v9;
  id v76 = v12;
  do
  {
    __int128 v19 = 0LL;
    do
    {
      if (*(void *)v87 != v82) {
        objc_enumerationMutation(obj);
      }
      uint64_t v20 = *(void **)(*((void *)&v86 + 1) + 8LL * (void)v19);
      uint64_t v25 = objc_autoreleasePoolPush();
      if (!v20)
      {
        _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Got a nil assetId when forming installed asset list, skipping",  v21,  v22,  v23,  v24,  v74);
        goto LABEL_24;
      }

      if (v11) {
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKey:v20]);
      }
      else {
        uint64_t v26 = 0LL;
      }
      id PathToAssetWithPurpose = getPathToAssetWithPurpose(v18, v9, v20, v84);
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(PathToAssetWithPurpose);
      uint64_t v33 = v28;
      if (v26)
      {
        id v34 = v26;
LABEL_17:
        if (v84 && v33) {
          [v34 setObject:v84 forKey:@"AssetPurpose"];
        }
        if (_MAPreferencesIsVerboseLoggingEnabled()) {
          _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Path to asset dir: %@",  v35,  v36,  v37,  v38,  (uint64_t)v33);
        }
        -[NSMutableDictionary setObject:forKey:](v80, "setObject:forKey:", v34, v20);
        goto LABEL_23;
      }

      if (v28)
      {
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v28 URLByAppendingPathComponent:@"Info.plist"]);
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v33 URLByAppendingPathComponent:@"AssetData"]);
        v79 = v39;
        v41 = (void *)objc_claimAutoreleasedReturnValue([v39 absoluteString]);
        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithContentsOfFile:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithContentsOfFile:",  v41));

        if (!v42
          || (v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager")),
              v48 = (void *)objc_claimAutoreleasedReturnValue([v40 path]),
              unsigned __int8 v49 = [v47 fileExistsAtPath:v48],
              v48,
              v47,
              (v49 & 1) == 0))
        {
          _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Got a malformed asset when reading %@, cleaning up",  v43,  v44,  v45,  v46,  (uint64_t)v33);
          v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          v62 = (void *)objc_claimAutoreleasedReturnValue([v33 path]);
          id v85 = 0LL;
          [v61 removeItemAtPath:v62 error:&v85];
          id v63 = v85;

          if (v63) {
            _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Could not clean up malformed asset: %@",  v64,  v65,  v66,  v67,  (uint64_t)v63);
          }

          id v34 = 0LL;
          id v11 = v77;
          id v9 = v78;
          __int128 v18 = v76;
          goto LABEL_23;
        }

        id v34 = (id)objc_claimAutoreleasedReturnValue([v42 objectForKey:@"MobileAssetProperties"]);
        id v9 = v78;
        AssetIdFromDict = getAssetIdFromDict(v78, v34);
        v51 = (void *)objc_claimAutoreleasedReturnValue(AssetIdFromDict);
        v56 = v51;
        if (v51)
        {
          if (([v51 isEqual:v20] & 1) == 0) {
            _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Asset that is installed has different asset ID when looking at its Info.plist: %@ in %@ generates ID %@ when looking at its Info.plist.",  v57,  v58,  v59,  v60,  (uint64_t)v20);
          }
        }

        else
        {
          _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Asset that could not determine an asset ID from Info.plist: %@ in %@",  v52,  v53,  v54,  v55,  (uint64_t)v20);
        }

        __int128 v18 = v76;
        id v11 = v77;
        if (v34) {
          goto LABEL_17;
        }
        _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"Got a nil attributes when reading Info.plist, skipping",  v68,  v69,  v70,  v71,  v74);
      }

      else
      {
        _MobileAssetLog( 0LL,  6,  (uint64_t)"dataFillInstalledWithPurpose",  @"attempted to create fullpath to asset and it failed",  v29,  v30,  v31,  v32,  v74);
        id v34 = 0LL;
      }

LABEL_23:
LABEL_24:
      objc_autoreleasePoolPop(v25);
      __int128 v19 = (char *)v19 + 1;
    }

    while (v83 != v19);
    id v72 = [obj countByEnumeratingWithState:&v86 objects:v90 count:16];
    id v83 = v72;
  }

  while (v72);
LABEL_40:

  id v10 = v75;
LABEL_43:

  return v80;
}
}

  return (char)v7;
}

                objc_autoreleasePoolPop(context);
                __int128 v18 = (char *)v18 + 1;
              }

              while (v151 != v18);
              v41 = [v17 countByEnumeratingWithState:&v165 objects:v184 count:16];
              v151 = v41;
            }

            while (v41);
          }

          -[NSMutableArray addObject:](v140, "addObject:", v153);
          self = v145;
LABEL_40:
          uint64_t v16 = v146;
          i = v148;
        }

        else
        {
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
          uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v138 summary]);
            *(_DWORD *)buf = 138543618;
            v177 = v44;
            v178 = 2114;
            v179 = v45;
            _os_log_impl( &dword_0,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {FormCandidatesDecideDetermine} nil encountered on alreadyDownloaded array | eventInfo:%{public}@",  buf,  0x16u);
          }
        }

        objc_autoreleasePoolPop(v16);
      }

      v144 = [obj countByEnumeratingWithState:&v169 objects:v185 count:16];
    }

    while (v144);
  }

  -[MADAutoAssetStager setAlreadyDownloadedDescriptors:](self, "setAlreadyDownloadedDescriptors:", v140);
  uint64_t v57 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v58 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager alreadyDownloadedDescriptors](self, "alreadyDownloadedDescriptors"));
  if (v58
    && (uint64_t v59 = (void *)v58,
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager alreadyDownloadedDescriptors](self, "alreadyDownloadedDescriptors")),
        v61 = [v60 count],
        v60,
        v59,
        v61))
  {
    v62 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager alreadyDownloadedDescriptors](self, "alreadyDownloadedDescriptors"));
    id v63 = (char *)[v62 count];

    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue([v64 oslog]);

    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      uint64_t v67 = @"s";
      *(_DWORD *)buf = 138544130;
      v178 = 2048;
      v177 = v66;
      if (v63 == (_BYTE *)&dword_0 + 1) {
        uint64_t v67 = &stru_355768;
      }
      v179 = v63;
      v180 = 2114;
      v181 = v67;
      v182 = 2114;
      v183 = v67;
      _os_log_impl( &dword_0,  v65,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {FormCandidatesDecideDetermine} auto-control-manager provided %ld downloaded descriptor%{public}@ - potential candidate%{public}@ for staging",  buf,  0x2Au);
    }

    v163 = 0u;
    v164 = 0u;
    v161 = 0u;
    v162 = 0u;
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager alreadyDownloadedDescriptors](self, "alreadyDownloadedDescriptors"));
    uint64_t v69 = [v68 countByEnumeratingWithState:&v161 objects:v175 count:16];
    if (v69)
    {
      uint64_t v70 = v69;
      uint64_t v71 = 0LL;
      id v72 = *(void *)v162;
      do
      {
        v73 = 0LL;
        uint64_t v74 = v71;
        do
        {
          if (*(void *)v162 != v72) {
            objc_enumerationMutation(v68);
          }
          uint64_t v71 = *(id *)(*((void *)&v161 + 1) + 8LL * (void)v73);

          id v75 = objc_autoreleasePoolPush();
          -[MADAutoAssetStager _maintainLatestCandidate:candidateDescriptor:]( v145,  "_maintainLatestCandidate:candidateDescriptor:",  v57,  v71);
          objc_autoreleasePoolPop(v75);
          v73 = (char *)v73 + 1;
          uint64_t v74 = v71;
        }

        while (v70 != v73);
        uint64_t v70 = [v68 countByEnumeratingWithState:&v161 objects:v175 count:16];
      }

      while (v70);

      self = v145;
    }
  }

  else
  {
    id v76 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v76 oslog]);

    if (os_log_type_enabled((os_log_t)v68, OS_LOG_TYPE_DEFAULT))
    {
      id v77 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543362;
      v177 = v77;
      _os_log_impl( &dword_0,  (os_log_t)v68,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {FormCandidatesDecideDetermine} auto-control-manager provided no downloaded descriptors - no candi date(s) for staging",  buf,  0xCu);
    }
  }

  v78 = v139;

  if (-[NSMutableArray count](v57, "count"))
  {
    v79 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager _trimConsideringToLatestDownloaded:]( self,  "_trimConsideringToLatestDownloaded:",  v57));

    v80 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v81 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v157 = 0u;
    v158 = 0u;
    v159 = 0u;
    v160 = 0u;
    uint64_t v57 = v79;
    uint64_t v82 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v157,  v174,  16LL);
    if (v82)
    {
      id v83 = v82;
      v147 = v81;
      v152 = v80;
      id v84 = 0LL;
      id v85 = *(void *)v158;
      v154 = 1;
      contexta = v57;
      do
      {
        for (j = 0LL; j != v83; j = (char *)j + 1)
        {
          __int128 v87 = v84;
          if (*(void *)v158 != v85) {
            objc_enumerationMutation(contexta);
          }
          id v84 = *(id *)(*((void *)&v157 + 1) + 8LL * (void)j);

          __int128 v88 = objc_autoreleasePoolPush();
          if (v84)
          {
            if (-[MADAutoAssetStager stagingClientUsingGroups](self, "stagingClientUsingGroups"))
            {
              if (([v84 isPreSUStagingRequired] & v139) == 1)
              {
                __int128 v89 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActiveRequired](self, "_targetNameActiveRequired"));
                -[NSMutableArray addObject:](v152, "addObject:", v84);
                v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
                v91 = (os_log_s *)objc_claimAutoreleasedReturnValue([v90 oslog]);

                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                {
                  v92 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
                  v93 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActive](self, "_targetNameActive"));
                  v94 = (__CFString *)objc_claimAutoreleasedReturnValue([v84 summary]);
                  *(_DWORD *)buf = 138543874;
                  v177 = v92;
                  v178 = 2114;
                  v179 = v93;
                  v180 = 2114;
                  v181 = v94;
                  _os_log_impl( &dword_0,  v91,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[%{public}@] {FormCandidatesDecideDetermine} [REQUIRED] candidateDescriptor:%{public}@",  buf,  0x20u);

                  self = v145;
                }

                v154 = 0;
              }

              else if (([v84 isPreSUStagingRequired] | v137 ^ 1))
              {
                v100 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
                v91 = (os_log_s *)objc_claimAutoreleasedReturnValue([v100 oslog]);

                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                {
                  v101 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
                  v102 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActive](self, "_targetNameActive"));
                  v103 = (__CFString *)objc_claimAutoreleasedReturnValue([v84 summary]);
                  *(_DWORD *)buf = 138543874;
                  v177 = v101;
                  v178 = 2114;
                  v179 = v102;
                  v180 = 2114;
                  v181 = v103;
                  _os_log_impl( &dword_0,  v91,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[%{public}@] {FormCandidatesDecideDetermine} [IGNORED] candidateDescriptor:%{public}@",  buf,  0x20u);
                }

                __int128 v89 = @"IGNORED";
              }

              else
              {
                __int128 v89 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActiveOptional](self, "_targetNameActiveOptional"));
                -[NSMutableArray addObject:](v147, "addObject:", v84);
                v104 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
                v91 = (os_log_s *)objc_claimAutoreleasedReturnValue([v104 oslog]);

                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                {
                  v105 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
                  v106 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActive](self, "_targetNameActive"));
                  v107 = (__CFString *)objc_claimAutoreleasedReturnValue([v84 summary]);
                  *(_DWORD *)buf = 138543874;
                  v177 = v105;
                  v178 = 2114;
                  v179 = v106;
                  v180 = 2114;
                  v181 = v107;
                  _os_log_impl( &dword_0,  v91,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[%{public}@] {FormCandidatesDecideDetermine} [OPTIONAL] candidateDescriptor:%{public}@",  buf,  0x20u);

                  self = v145;
                }
              }
            }

            else
            {
              v96 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager candidatesForStaging](self, "candidatesForStaging"));
              [v96 addObject:v84];

              v97 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
              v91 = (os_log_s *)objc_claimAutoreleasedReturnValue([v97 oslog]);

              if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
              {
                v98 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
                v99 = (void *)objc_claimAutoreleasedReturnValue([v84 summary]);
                *(_DWORD *)buf = 138543618;
                v177 = v98;
                v178 = 2114;
                v179 = v99;
                _os_log_impl( &dword_0,  v91,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[AUTO-STAGER] {FormCandidatesDecideDetermine} [ALL-MODE] candidateDescriptor:%{public}@",  buf,  0x16u);
              }

              __int128 v89 = @"ALL";
            }

            v108 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"[%@] adding candidate (from downloaded that support staging)",  v89);
            -[MADAutoAssetStager _persistDescriptor:operation:persistingDescriptor:withRepresentation:message:]( self,  "_persistDescriptor:operation:persistingDescriptor:withRepresentation:message:",  @"FormCandidatesDecideDetermine",  @"ENTRY_ADD",  v84,  600LL,  v108);

            p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
          }

          else
          {
            v95 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
            __int128 v89 = (__CFString *)objc_claimAutoreleasedReturnValue([v95 oslog]);

            if (os_log_type_enabled((os_log_t)v89, OS_LOG_TYPE_ERROR)) {
              -[MADAutoAssetStager action_FormCandidatesDecideDetermine:error:].cold.2((uint64_t)v173, (uint64_t)self);
            }
          }

          objc_autoreleasePoolPop(v88);
        }

        uint64_t v57 = contexta;
        id v83 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( contexta,  "countByEnumeratingWithState:objects:count:",  &v157,  v174,  16LL);
      }

      while (v83);

      LODWORD(v7_Block_object_dispose(va, 8) = v139;
      v80 = v152;
      v81 = v147;
    }

    else
    {
      v154 = 1;
    }

    if (-[MADAutoAssetStager stagingClientUsingGroups](self, "stagingClientUsingGroups"))
    {
      -[MADAutoAssetStager _blendOptionalCandidates:intoRequired:]( self,  "_blendOptionalCandidates:intoRequired:",  v81,  v80);
      if ((v78 | v137) == 1)
      {
        v114 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetTrainName](self, "assetTargetTrainName"));
        v115 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetRestoreVersion](self, "assetTargetRestoreVersion"));
        v116 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager targetLookupResultsKeyForTrainName:withRestoreVersion:]( self,  "targetLookupResultsKeyForTrainName:withRestoreVersion:",  v114,  v115));

        v117 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager candidatesForStagingRequiredByTarget]( self,  "candidatesForStagingRequiredByTarget"));
        [v117 setSafeObject:v80 forKey:v116];

        v118 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager candidatesForStagingOptionalByTarget]( self,  "candidatesForStagingOptionalByTarget"));
        [v118 setSafeObject:v81 forKey:v116];

        if (-[NSMutableArray count](v80, "count")) {
          v119 = v139;
        }
        else {
          v119 = 0;
        }
        v120 = v80;
        if ((v119 & 1) != 0
          || (-[NSMutableArray count](v81, "count", v80) ? (v121 = v137) : (v121 = 0), v120 = v81, v121 == 1))
        {
          -[MADAutoAssetStager setCandidatesForStaging:](self, "setCandidatesForStaging:", v120);
        }
      }

      else
      {
        v116 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
        v122 = (void *)objc_claimAutoreleasedReturnValue([v116 diag]);
        [v122 trackAnomaly:@"AUTO-STAGER" forReason:@"{FormCandidatesDecideDetermine} [BY-GROUP-MODE] forming candidates yet not involving required or optional" withResult:6110 withError:0];
      }
    }

    if (-[MADAutoAssetStager stagingClientUsingGroups](self, "stagingClientUsingGroups"))
    {
      v123 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager candidatesForStagingRequiredByTarget]( self,  "candidatesForStagingRequiredByTarget"));
      v124 = (char *)[v123 count];
      v125 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager candidatesForStagingOptionalByTarget]( self,  "candidatesForStagingOptionalByTarget"));
      v126 = &v124[(void)[v125 count]];
    }

    else
    {
      v123 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager candidatesForStaging](self, "candidatesForStaging"));
      v126 = (char *)[v123 count];
    }

    v127 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](self, "persistedState"));
    v128 = (void *)objc_claimAutoreleasedReturnValue([v127 persistedConfig]);
    [v128 persistULL:v126 forKey:@"candidateAssetCount" shouldPersist:1];

    if (v126)
    {
      v129 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"found candidate(s) for staging | totalCandidatesForStaging:%llu",  v126);
      -[MADAutoAssetStager _logPersistedConfigSet:message:]( self,  "_logPersistedConfigSet:message:",  @"FormCandidatesDecideDetermine",  v129);

      v112 = @"DetermineHaveCandidates";
      -[MADAutoAssetStager _logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:]( self,  "_logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:",  @"FormCandidatesDecideDetermine",  @"DetermineHaveCandidates",  @"have downloaded auto-asset candidate(s) for staging");
    }

    else
    {
      v112 = @"DetermineNoCandidates";
    }

    v78 = v139;

    v113 = v154 & 1;
  }

  else
  {
    v109 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    v110 = (os_log_s *)objc_claimAutoreleasedReturnValue([v109 oslog]);

    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
    {
      v111 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543362;
      v177 = v111;
      _os_log_impl( &dword_0,  v110,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[AUTO-STAGER] {FormCandidatesDecideDetermine} no candidate descriptors for staging",  buf,  0xCu);
    }

    v112 = @"DetermineNoCandidates";
    v113 = 1LL;
  }

  if (-[__objc2_ivar_list stringIsEqual:to:]( p_ivars[155],  "stringIsEqual:to:",  v112,  @"DetermineHaveCandidates")
    && !-[MADAutoAssetStager _formCandidateSetLookupArray:involvingRequired:involvingOptional:providingOptional:]( self,  "_formCandidateSetLookupArray:involvingRequired:involvingOptional:providingOptional:",  @"FormCandidatesDecideDetermine",  v78,  v137,  v113))
  {
    v130 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    v131 = (os_log_s *)objc_claimAutoreleasedReturnValue([v130 oslog]);

    if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetStager action_FormCandidatesDecideDetermine:error:].cold.1(self);
    }

    v112 = @"DetermineNoCandidates";
  }

  -[MADAutoAssetStager _acknowlegdeAndClearAllEliminations](self, "_acknowlegdeAndClearAllEliminations");
  v132 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
  v133 = objc_alloc(&OBJC_CLASS___MADAutoAssetStagerParam);
  v134 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
  v135 = -[MADAutoAssetStagerParam initWithSafeSummary:](v133, "initWithSafeSummary:", v134);
  [v132 followupEvent:v112 withInfo:v135];

  return 0LL;
}

    uint64_t v35 = 1;
    goto LABEL_18;
  }

          objc_autoreleasePoolPop(context);
          if (v72 == (id)++v17)
          {
            uint64_t v39 = [v15 countByEnumeratingWithState:&v78 objects:v87 count:16];
            id v72 = v39;
            if (!v39)
            {

              uint64_t v2 = v66;
              goto LABEL_41;
            }

            goto LABEL_9;
          }
        }

        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v20 assetSpecifier]);

        uint64_t v33 = v16[155];
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v14 assetType]);
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v20 assetType]);
        id v34 = -[__objc2_ivar_list stringIsEqual:to:](v33, "stringIsEqual:to:", v23, v24);
        uint64_t v35 = v34;
        if (v32)
        {
          if (!v34) {
            goto LABEL_22;
          }
          uint64_t v36 = v16[155];
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v14 assetSpecifier]);
          uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v20 assetSpecifier]);
          LODWORD(v36) = -[__objc2_ivar_list stringIsEqual:to:](v36, "stringIsEqual:to:", v37, v38);

          uint64_t v14 = v69;
          if ((_DWORD)v36)
          {
            uint64_t v2 = v66;
            uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v66, "logger"));
            uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue([v52 oslog]);

            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v66, "summary"));
              v47 = (void *)objc_claimAutoreleasedReturnValue([v69 summary]);
              *(_DWORD *)buf = 138543618;
              __int128 v89 = v46;
              v90 = 2114;
              v91 = v47;
              v48 = v44;
              unsigned __int8 v49 = "%{public}@\n"
                    "[AUTO-STAGER] {_removeEliminatedFromStaged} elimination-selector for asset-type + asset-specifier be"
                    "ing eliminated - removed from successfully-staged | descriptor:%{public}@";
              goto LABEL_39;
            }

            goto LABEL_40;
          }

          goto LABEL_23;
        }

        if (!v35) {
          goto LABEL_23;
        }
        uint64_t v2 = v66;
        v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v66, "logger"));
        uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue([v50 oslog]);

        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v66, "summary"));
          v47 = (void *)objc_claimAutoreleasedReturnValue([v14 summary]);
          *(_DWORD *)buf = 138543618;
          __int128 v89 = v46;
          v90 = 2114;
          v91 = v47;
          v48 = v44;
          unsigned __int8 v49 = "%{public}@\n"
                "[AUTO-STAGER] {_removeEliminatedFromStaged} elimination-selector for asset-type being eliminated - remov"
                "ed from successfully-staged | descriptor:%{public}@";
          goto LABEL_39;
        }

        objc_autoreleasePoolPop(v7);
      }

      v50 = [obj countByEnumeratingWithState:&v52 objects:v60 count:16];
      if (!v50)
      {
LABEL_25:

        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) locksBySelector]);
        uint64_t v38 = (char *)[v37 count];

        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
        uint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue([v39 oslog]);

        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          v41 = @"s";
          if (v38 == (_BYTE *)&dword_0 + 1) {
            v41 = &stru_355768;
          }
          *(_DWORD *)buf = 134218242;
          uint64_t v57 = v38;
          uint64_t v58 = 2114;
          uint64_t v59 = v41;
          _os_log_impl( &dword_0,  v40,  OS_LOG_TYPE_DEFAULT,  "{resumeFromPersistedWithDownloadedSelectors} | %ld lock%{public}@ (by selector) | MA_MILESTONE",  buf,  0x16u);
        }

        id v4 = v45;
        goto LABEL_32;
      }
    }
  }

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
  uint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( &dword_0,  v40,  OS_LOG_TYPE_DEFAULT,  "{resumeFromPersistedWithDownloadedSelectors} | no locked auto-assets | MA_MILESTONE",  buf,  2u);
  }

                  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager cancelAllDownloading:withPurpose:includingAssets:includingCatalog:includi ngOther:clientName:then:]_block_invoke",  v29,  v25,  v26,  v27,  v28,  *(void *)(a1 + 32));
                  [v14 cancel];
                }
              }
            }

            else if (v20)
            {
              goto LABEL_20;
            }

  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager checkSplunkStatus:failureReason:productVersion:sessionId:nonce:url:statusCode:assetAudien ce:version:receiptResults:baseUrl:discretionary:deviceCheck:]_block_invoke",  v18,  v6,  v7,  v8,  v9,  v50);
LABEL_24:
}

      uint64_t v14 = v43 + 1;
      id v6 = v41;
    }

    while ((id)(v43 + 1) != v42);
    uint64_t v42 = [obj countByEnumeratingWithState:&v54 objects:v59 count:16];
  }

  while (v42);
LABEL_25:

  uint64_t v7 = v37;
LABEL_26:
  id v12 = -[NSMutableDictionary count](v44, "count");
  LOBYTE(v12) = v12 == [v7 count];

LABEL_27:
  return (char)v12;
}

  if (v25)
  {
    uint64_t v45 = objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _currentSetStatusClearDownloadProgress:clearingSetStatus:forClearingReason:]( v32,  "_currentSetStatusClearDownloadProgress:clearingSetStatus:forClearingReason:",  v33,  v29,  v25));

    uint64_t v29 = (id)v45;
  }

  __int128 v88 = v18;
  v109 = v33;
  -[MADAutoAssetControlManager _updateCurrentSetStatus:forSetIdentifier:withSetStatus:]( v32,  "_updateCurrentSetStatus:forSetIdentifier:withSetStatus:",  @"FINAL_SET_STATUS",  v16,  v29);
  uint64_t v46 = objc_claimAutoreleasedReturnValue(-[__CFString message](v110, "message"));
  v47 = +[MASAutoAssetSetInfoInstance newShimmedFromFrameworkMessage:forKey:]( &OBJC_CLASS___MASAutoAssetSetInfoInstance,  "newShimmedFromFrameworkMessage:forKey:",  v46,  @"setInstance");
  v92 = +[MASAutoAssetSetInfoFound newShimmedFromFrameworkMessage:forKey:]( &OBJC_CLASS___MASAutoAssetSetInfoFound,  "newShimmedFromFrameworkMessage:forKey:",  v46,  @"setFound");
  v107 = +[MASAutoAssetSetInfoDesire newShimmedFromFrameworkMessage:forKey:]( &OBJC_CLASS___MASAutoAssetSetInfoDesire,  "newShimmedFromFrameworkMessage:forKey:",  v46,  @"setDesire");
  __int128 v87 = (void *)v46;
  id v85 = +[MASAutoAssetSetInfoEnd newShimmedFromFrameworkMessage:forKey:]( &OBJC_CLASS___MASAutoAssetSetInfoEnd,  "newShimmedFromFrameworkMessage:forKey:",  v46,  @"setEnd");
  v48 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  unsigned __int8 v49 = v29;
  if (v47)
  {
    v50 = +[MASAutoAssetSetInfoInstance newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoInstance,  "newShimmedToFramework:",  v47);
    -[NSMutableDictionary setSafeObject:forKey:](v48, "setSafeObject:forKey:", v50, @"setInstance");
  }

  id v84 = v48;
  __int128 v86 = v47;
  v106 = (void *)objc_claimAutoreleasedReturnValue([v49 clientDomainName]);
  v105 = (void *)objc_claimAutoreleasedReturnValue([v49 assetSetIdentifier]);
  v51 = objc_claimAutoreleasedReturnValue([v49 atomicInstancesDownloaded]);
  v104 = (void *)objc_claimAutoreleasedReturnValue([v49 catalogCachedAssetSetID]);
  uint64_t v52 = objc_claimAutoreleasedReturnValue([v49 catalogDownloadedFromLive]);
  v102 = (void *)objc_claimAutoreleasedReturnValue([v49 catalogLastTimeChecked]);
  v101 = (void *)objc_claimAutoreleasedReturnValue([v49 catalogPostedDate]);
  v100 = (void *)objc_claimAutoreleasedReturnValue([v49 newerAtomicInstanceDiscovered]);
  v99 = (void *)objc_claimAutoreleasedReturnValue([v49 newerDiscoveredAtomicEntries]);
  v98 = (void *)objc_claimAutoreleasedReturnValue([v49 latestDownloadedAtomicInstance]);
  v94 = (void *)objc_claimAutoreleasedReturnValue([v49 latestDowloadedAtomicInstanceEntries]);
  v96 = (void *)objc_claimAutoreleasedReturnValue([v49 downloadedCatalogCachedAssetSetID]);
  v95 = (void *)objc_claimAutoreleasedReturnValue([v49 downloadedCatalogDownloadedFromLive]);
  id v83 = (void *)objc_claimAutoreleasedReturnValue([v49 downloadedCatalogLastTimeChecked]);
  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v49 downloadedCatalogPostedDate]);
  v81 = (void *)objc_claimAutoreleasedReturnValue([v49 currentNotifications]);
  v80 = (void *)objc_claimAutoreleasedReturnValue([v49 currentNeedPolicy]);
  uint64_t v53 = objc_claimAutoreleasedReturnValue([v49 clientDomainName]);
  v78 = (void *)objc_claimAutoreleasedReturnValue([v49 assetSetIdentifier]);
  v79 = (void *)v53;
  uint64_t v54 = +[MADAutoAssetScheduler newSetPolicyForDomainName:forAssetSetIdentifier:]( &OBJC_CLASS___MADAutoAssetScheduler,  "newSetPolicyForDomainName:forAssetSetIdentifier:",  v53);
  id v77 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager stagerSetPolicy]( &OBJC_CLASS___MADAutoAssetControlManager,  "stagerSetPolicy"));
  uint64_t v55 = -[MADAutoAssetControlManager _haveReceivedLookupResponseForClientDomainName:forAssetSetIdentifier:]( v32,  "_haveReceivedLookupResponseForClientDomainName:forAssetSetIdentifier:",  v113,  v16);
  v56 = -[MADAutoAssetControlManager _vendingAtomicInstanceForConfiguredEntriesForClientDomainName:forAssetSetIdentifier:]( v32,  "_vendingAtomicInstanceForConfiguredEntriesForClientDomainName:forAssetSetIdentifier:",  v113,  v16);
  uint64_t v57 = [v49 downloadUserInitiated];
  v108 = v16;
  v103 = (void *)v51;
  v97 = (void *)v52;
  if (v114) {
    v91 = 0LL;
  }
  else {
    v91 = (void *)objc_claimAutoreleasedReturnValue([v49 downloadProgress]);
  }
  uint64_t v58 = [v49 downloadedNetworkBytes];
  uint64_t v59 = [v49 downloadedFilesystemBytes];
  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v49 selectorsForStaging]);
  v61 = (void *)objc_claimAutoreleasedReturnValue([v49 availableForUseError]);
  v62 = (void *)objc_claimAutoreleasedReturnValue([v49 newerVersionError]);
  LOBYTE(v76) = 1;
  BYTE2(v75) = v57;
  BYTE1(v75) = v56;
  LOBYTE(v75) = v55;
  v112 = -[MADAutoAssetControlManager newAssetSetStatus:forReason:forClientDomain:forAssetSetIdentifier:withAtomicInstancesDownloaded:withCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:extendingWithCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:]( v111,  "newAssetSetStatus:forReason:forClientDomain:forAssetSetIdentifier:withAtomicInstancesDownloaded:withCatalogCa chedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomic InstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAto micInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownload edCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withS chedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:withDo wnloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:extendingWi thCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:",  v109,  @"issuing response to client",  v106,  v105,  v103,  v104,  v97,  v102,  v101,  v100,  v99,  v98,  v94,  v96,  v95,  v83,  v82,  v81,  v80,  v54,  v77,  v75,  v91,  v58,  v59,  v76,  v60,  v61,  v62);

  if (!v114) {
  uint64_t v36 = v112;
  }

  id v63 = -[MANAutoAssetSetInfoFound initForAssetSetIdentifier:reportingStatus:]( objc_alloc(&OBJC_CLASS___MANAutoAssetSetInfoFound),  "initForAssetSetIdentifier:reportingStatus:",  v108,  v36);
  if (v63) {
    uint64_t v64 = v63;
  }
  else {
    uint64_t v64 = v92;
  }
  uint64_t v65 = +[MASAutoAssetSetInfoFound newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoFound,  "newShimmedToFramework:",  v64);
  v41 = v113;
  uint64_t v23 = v110;
  -[NSMutableDictionary setSafeObject:forKey:](v84, "setSafeObject:forKey:", v65, @"setFound");

  if (v107)
  {
    uint64_t v66 = +[MASAutoAssetSetInfoDesire newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoDesire,  "newShimmedToFramework:",  v107);
    -[NSMutableDictionary setSafeObject:forKey:](v84, "setSafeObject:forKey:", v66, @"setDesire");
  }

  if (v85)
  {
    uint64_t v67 = +[MASAutoAssetSetInfoEnd newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoEnd,  "newShimmedToFramework:",  v85);
    -[NSMutableDictionary setSafeObject:forKey:](v84, "setSafeObject:forKey:", v67, @"setEnd");
  }

  uint64_t v68 = objc_alloc(&OBJC_CLASS___SUCoreConnectMessage);
  uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString messageName](v110, "messageName"));
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString clientID](v110, "clientID"));
  uint64_t v31 = -[SUCoreConnectMessage initWithType:messageName:clientID:version:message:]( v68,  "initWithType:messageName:clientID:version:message:",  2LL,  v69,  v70,  0LL,  v84);

  uint64_t v35 = v36;
  uint64_t v20 = v93;
  uint64_t v25 = v90;
  __int128 v18 = v88;
  uint64_t v16 = v108;
  uint64_t v15 = v109;
LABEL_40:
  uint64_t v71 = v31;

  return v71;
}

  return v22;
}

            uint64_t v17 = v80;
          }

          log = (os_log_t)-[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v85,  v94,  16LL);
        }

        while (log);
        id v9 = v67;
        self = v68;
        id v12 = v66;
        id v11 = v69;
LABEL_35:
        uint64_t v26 = v65;
LABEL_36:

        uint64_t v20 = (os_log_s *)v72;
LABEL_37:
        if ((v70 & 1) != 0)
        {
          id v13 = v71;
        }

        else
        {
          id v83 = 0u;
          id v84 = 0u;
          v81 = 0u;
          uint64_t v82 = 0u;
          loga = (os_log_t)objc_claimAutoreleasedReturnValue(-[os_log_s autoAssetEntries](v20, "autoAssetEntries"));
          v47 = -[os_log_s countByEnumeratingWithState:objects:count:]( loga,  "countByEnumeratingWithState:objects:count:",  &v81,  v93,  16LL);
          if (v47)
          {
            v48 = v47;
            unsigned __int8 v49 = *(void *)v82;
            v50 = &MobileAssetKeyManager__metaData.ivars;
            do
            {
              for (j = 0LL; j != v48; j = (char *)j + 1)
              {
                if (*(void *)v82 != v49) {
                  objc_enumerationMutation(loga);
                }
                uint64_t v52 = *(void **)(*((void *)&v81 + 1) + 8LL * (void)j);
                uint64_t v53 = v50[155];
                uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v52, "assetSelector", v64));
                uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v54 assetType]);
                v56 = (void *)objc_claimAutoreleasedReturnValue([v4 assetType]);
                if ((-[__objc2_ivar_list stringIsEqual:to:](v53, "stringIsEqual:to:", v55, v56) & 1) != 0)
                {
                  uint64_t v57 = v50[155];
                  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v52 assetSelector]);
                  uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v58 assetSpecifier]);
                  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v76 assetSpecifier]);
                  LOBYTE(v57) = -[__objc2_ivar_list stringIsEqual:to:]( v57,  "stringIsEqual:to:",  v59,  v60);

                  v50 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                  id v4 = v76;

                  if ((v57 & 1) != 0)
                  {
                    uint64_t v70 = 1;
                    id v9 = v67;
                    self = v68;
                    id v12 = v66;
                    id v11 = v69;
                    id v13 = v71;
                    uint64_t v17 = v80;
                    goto LABEL_52;
                  }
                }

                else
                {
                }

                uint64_t v17 = v80;
              }

              v48 = -[os_log_s countByEnumeratingWithState:objects:count:]( loga,  "countByEnumeratingWithState:objects:count:",  &v81,  v93,  16LL);
            }

            while (v48);
            id v9 = v67;
            self = v68;
            id v12 = v66;
            id v11 = v69;
          }

          id v13 = v71;
LABEL_52:

          uint64_t v20 = (os_log_s *)v72;
        }

  _Block_object_dispose(&v87, 8);
}
    }
  }

  id v4 = 0;
  if (a3) {
    *a3 = @"MobileAsset space check disabled because MobileAsset does not have entitlements to call cache delete";
  }
LABEL_26:

  return v4;
}

    uint64_t v17 = 0;
    goto LABEL_24;
  }

  uint64_t v17 = 1;
LABEL_25:

  return v17;
}

    id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 domain]);
    id v12 = [v11 isEqualToString:NSURLErrorDomain];

    if (!v12)
    {
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v5 domain]);
      uint64_t v17 = [v16 isEqualToString:NSPOSIXErrorDomain];

      if (v17)
      {
        if ([v5 code] == &dword_1C) {
          id v8 = 37LL;
        }
        else {
          id v8 = v7;
        }
        goto LABEL_67;
      }

        objc_autoreleasePoolPop(v7);
      }

      v51 = [obj countByEnumeratingWithState:&v53 objects:v61 count:16];
      if (!v51)
      {
LABEL_25:

        uint64_t v36 = (char *)[*(id *)(v1 + 32) locateLocksCurrentLocksCount];
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
        uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue([v37 oslog]);

        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v39 = @"s";
          if (v36 == (_BYTE *)&dword_0 + 1) {
            uint64_t v39 = &stru_355768;
          }
          *(_DWORD *)buf = 134218242;
          uint64_t v58 = v36;
          uint64_t v59 = 2114;
          uint64_t v60 = v39;
          uint64_t v40 = "{resumeFromPersistedWithDownloadedSelectors} | %ld lock%{public}@ (by selector) | MA_MILESTONE";
          v41 = v38;
          uint64_t v42 = 22;
LABEL_31:
          _os_log_impl(&dword_0, v41, OS_LOG_TYPE_DEFAULT, v40, buf, v42);
        }

        goto LABEL_32;
      }
    }
  }

  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
  uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue([v43 oslog]);

  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    uint64_t v40 = "{resumeFromPersistedWithDownloadedSelectors} | no locked auto-assets | MA_MILESTONE";
    v41 = v38;
    uint64_t v42 = 2;
    goto LABEL_31;
  }

    objc_autoreleasePoolPop(context);
    uint64_t v2 = v27;
  }

  else
  {
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) logger]);
    uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v24 oslog]);

    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v25, OS_LOG_TYPE_DEFAULT, "Failed to obtain BAA certificate chain", buf, 2u);
    }
  }
}

  __break(1u);
LABEL_24:
  swift_once(&qword_3A7D18, sub_2384DC);
LABEL_5:
  id v9 = off_3A8E78[0];
  uint64_t v44 = off_3A8E78[0];
  uint64_t v35 = sub_2348C8(v4);
  if (!v6)
  {
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
  }

  uint64_t v31 = a4;
  uint64_t v32 = v5;
  id v10 = (char *)&v43 + 8;
  swift_retain_n(v9, 2LL);
  LOBYTE(v11) = 1;
  id v34 = v6;
  while (1)
  {
    id v12 = swift_retain(v35);
    sub_22C6B8(v12, &v43);
    swift_beginAccess(v9 + 4, v47, 0LL, 0LL);
    id v13 = (uint64_t)v9 + *((void *)v9 + 2) + 32;
    swift_retain(v9);
    sub_21D3B0((char *)v9 + 32, v13);
    swift_release(v9);
    if (a2 >> 60 != 15) {
      __asm { BR              X8 }
    }

    LOBYTE(v46[0]) = v11;
    uint64_t v14 = v10;
    sub_21D3B0((char *)v46, (uint64_t)v46 + 1);
    uint64_t v15 = v43;
    sub_21D6E4((uint64_t)v46);
    uint64_t v42 = v15;
    v37[0] = v46[0];
    v37[1] = v46[1];
    swift_retain(v15);
    sub_21D3B0((char *)v37, (uint64_t)&v38);
    uint64_t v16 = v42;
    swift_retain(v42);
    sub_21D6E4((uint64_t)&v39);
    swift_release_n(v16, 2LL);
    uint64_t v36 = v39;
    __int128 v18 = v40;
    uint64_t v17 = v41;
    __int128 v19 = type metadata accessor for SecureBytes.Backing(0LL);
    uint64_t v20 = swift_allocObject(v19, 64LL, 7LL);
    *(_OWORD *)(v20 + 16) = xmmword_281340;
    _swift_stdlib_malloc_size((const void *)v20);
    *(_OWORD *)(v20 + 32) = v36;
    *(void *)(v20 + 4_Block_object_dispose(va, 8) = v18;
    *(void *)(v20 + 56) = v17;
    swift_beginAccess(v20 + 16, v45, 1LL, 0LL);
    *(void *)(v20 + 16) = 32LL;
    uint64_t v21 = _swift_stdlib_malloc_size((const void *)v20);
    swift_release(v9);
    if (v21 < 64)
    {
      __break(1u);
      JUMPOUT(0x22DA5CLL);
    }

    uint64_t v22 = swift_retain(v20);
    sub_234608(v22);
    swift_release(*((void *)&v15 + 1));
    swift_release(v15);
    swift_release(v20);
    id v11 = v11 + 1;
    id v9 = (int *)v20;
    id v10 = v14;
    if ((v11 & 0x100) != 0)
    {
      __break(1u);
      break;
    }
  }

  if (v32 < 0) {
    goto LABEL_26;
  }
  uint64_t v23 = (uint64_t)v44;
  swift_beginAccess(v44 + 4, v46, 0LL, 0LL);
  uint64_t v24 = *(void *)(v23 + 16);
  uint64_t v25 = sub_234134(0LL, v32, v24, v23);
  if ((v26 & 1) != 0) {
    uint64_t v27 = v24;
  }
  else {
    uint64_t v27 = v25;
  }
  if ((v27 | v24) < 0) {
    goto LABEL_27;
  }
  if (v24 < v27) {
    goto LABEL_28;
  }
  *(void *)&uint64_t v39 = 0LL;
  *((void *)&v39 + 1) = v27;
  uint64_t v40 = v23;
  swift_retain(v23);
  uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A89B8);
  uint64_t v29 = sub_22E92C();
  Slice<>.withUnsafeBytes<A>(_:)(v37, sub_23A8B8, 0LL, v28, v19, v29);
  swift_release(v20);
  swift_release(v35);
  result = swift_release_n(v23, 2LL);
  void *v31 = *(void *)&v37[0];
  return result;
}

  __break(1u);
LABEL_24:
  swift_once(&qword_3A7D18, sub_2384DC);
LABEL_5:
  id v9 = off_3A8E78[0];
  uint64_t v46 = off_3A8E78[0];
  uint64_t v35 = sub_2348C8(v4);
  if (!v6)
  {
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
  }

  uint64_t v31 = a4;
  uint64_t v32 = v5;
  id v10 = (char *)&v45 + 8;
  swift_retain_n(v9, 2LL);
  LOBYTE(v11) = 1;
  id v34 = v6;
  while (1)
  {
    id v12 = swift_retain(v35);
    sub_22C388( v12,  (uint64_t (*)(void))ccsha384_di,  &qword_3A87E0,  (void (*)(uint64_t, uint64_t))sub_21D3A4,  (char *)sub_22CB48,  &v45);
    swift_beginAccess(v9 + 4, v49, 0LL, 0LL);
    id v13 = (uint64_t)v9 + *((void *)v9 + 2) + 32;
    swift_retain(v9);
    sub_21D3A4((char *)v9 + 32, v13);
    swift_release(v9);
    if (a2 >> 60 != 15) {
      __asm { BR              X8 }
    }

    LOBYTE(v48[0]) = v11;
    uint64_t v14 = v10;
    sub_21D3A4((char *)v48, (uint64_t)v48 + 1);
    uint64_t v15 = v45;
    sub_21D77C((uint64_t)v48);
    uint64_t v44 = v15;
    v38[0] = v48[0];
    v38[1] = v48[1];
    v38[2] = v48[2];
    swift_retain(v15);
    sub_21D3A4((char *)v38, (uint64_t)&v39);
    uint64_t v16 = v44;
    swift_retain(v44);
    sub_21D77C((uint64_t)&v40);
    swift_release_n(v16, 2LL);
    uint64_t v36 = v41;
    uint64_t v37 = v40;
    __int128 v18 = v42;
    uint64_t v17 = v43;
    __int128 v19 = type metadata accessor for SecureBytes.Backing(0LL);
    uint64_t v20 = swift_allocObject(v19, 96LL, 7LL);
    *(_OWORD *)(v20 + 16) = xmmword_281330;
    _swift_stdlib_malloc_size((const void *)v20);
    *(_OWORD *)(v20 + 32) = v37;
    *(_OWORD *)(v20 + 4_Block_object_dispose(va, 8) = v36;
    *(void *)(v20 + 64) = v18;
    *(void *)(v20 + 72) = v17;
    swift_beginAccess(v20 + 16, v47, 1LL, 0LL);
    *(void *)(v20 + 16) = 48LL;
    uint64_t v21 = _swift_stdlib_malloc_size((const void *)v20);
    swift_release(v9);
    if (v21 < 80)
    {
      __break(1u);
      JUMPOUT(0x22E04CLL);
    }

    uint64_t v22 = swift_retain(v20);
    sub_234608(v22);
    swift_release(*((void *)&v15 + 1));
    swift_release(v15);
    swift_release(v20);
    id v11 = v11 + 1;
    id v9 = (int *)v20;
    id v10 = v14;
    if ((v11 & 0x100) != 0)
    {
      __break(1u);
      break;
    }
  }

  if (v32 < 0) {
    goto LABEL_26;
  }
  uint64_t v23 = (uint64_t)v46;
  swift_beginAccess(v46 + 4, v48, 0LL, 0LL);
  uint64_t v24 = *(void *)(v23 + 16);
  uint64_t v25 = sub_234134(0LL, v32, v24, v23);
  if ((v26 & 1) != 0) {
    uint64_t v27 = v24;
  }
  else {
    uint64_t v27 = v25;
  }
  if ((v27 | v24) < 0) {
    goto LABEL_27;
  }
  if (v24 < v27) {
    goto LABEL_28;
  }
  *(void *)&uint64_t v40 = 0LL;
  *((void *)&v40 + 1) = v27;
  *(void *)&v41 = v23;
  swift_retain(v23);
  uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A89B8);
  uint64_t v29 = sub_22E92C();
  Slice<>.withUnsafeBytes<A>(_:)(v38, sub_23A8B8, 0LL, v28, v19, v29);
  swift_release(v20);
  swift_release(v35);
  result = swift_release_n(v23, 2LL);
  void *v31 = *(void *)&v38[0];
  return result;
}

  __break(1u);
LABEL_24:
  swift_once(&qword_3A7D18, sub_2384DC);
LABEL_5:
  id v9 = off_3A8E78[0];
  v48 = off_3A8E78[0];
  uint64_t v35 = sub_2348C8(v4);
  if (!v6)
  {
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
  }

  uint64_t v31 = a4;
  uint64_t v32 = v5;
  id v10 = (char *)&v47 + 8;
  swift_retain_n(v9, 2LL);
  LOBYTE(v11) = 1;
  id v34 = v6;
  while (1)
  {
    id v12 = swift_retain(v35);
    sub_22C388( v12,  (uint64_t (*)(void))ccsha512_di,  &qword_3A87D8,  (void (*)(uint64_t, uint64_t))sub_21D398,  (char *)sub_22C9CC,  &v47);
    swift_beginAccess(v9 + 4, v51, 0LL, 0LL);
    id v13 = (uint64_t)v9 + *((void *)v9 + 2) + 32;
    swift_retain(v9);
    sub_21D398((char *)v9 + 32, v13);
    swift_release(v9);
    if (a2 >> 60 != 15) {
      __asm { BR              X8 }
    }

    LOBYTE(v50[0]) = v11;
    uint64_t v14 = v10;
    sub_21D398((char *)v50, (uint64_t)v50 + 1);
    uint64_t v15 = v47;
    sub_21D81C(v50);
    uint64_t v46 = v15;
    v39[0] = v50[0];
    v39[1] = v50[1];
    v39[2] = v50[2];
    v39[3] = v50[3];
    swift_retain(v15);
    sub_21D398((char *)v39, (uint64_t)&v40);
    uint64_t v16 = v46;
    swift_retain(v46);
    sub_21D81C(&v41);
    swift_release_n(v16, 2LL);
    uint64_t v37 = v42;
    uint64_t v38 = v41;
    uint64_t v36 = v43;
    __int128 v18 = v44;
    uint64_t v17 = v45;
    __int128 v19 = type metadata accessor for SecureBytes.Backing(0LL);
    uint64_t v20 = swift_allocObject(v19, 96LL, 7LL);
    *(_OWORD *)(v20 + 16) = xmmword_281330;
    _swift_stdlib_malloc_size((const void *)v20);
    *(_OWORD *)(v20 + 32) = v38;
    *(_OWORD *)(v20 + 4_Block_object_dispose(va, 8) = v37;
    *(_OWORD *)(v20 + 64) = v36;
    *(void *)(v20 + 80) = v18;
    *(void *)(v20 + 8_Block_object_dispose(va, 8) = v17;
    swift_beginAccess(v20 + 16, v49, 1LL, 0LL);
    *(void *)(v20 + 16) = 64LL;
    uint64_t v21 = _swift_stdlib_malloc_size((const void *)v20);
    swift_release(v9);
    if (v21 < 96)
    {
      __break(1u);
      JUMPOUT(0x22E654LL);
    }

    uint64_t v22 = swift_retain(v20);
    sub_234608(v22);
    swift_release(*((void *)&v15 + 1));
    swift_release(v15);
    swift_release(v20);
    id v11 = v11 + 1;
    id v9 = (int *)v20;
    id v10 = v14;
    if ((v11 & 0x100) != 0)
    {
      __break(1u);
      break;
    }
  }

  if (v32 < 0) {
    goto LABEL_26;
  }
  uint64_t v23 = (uint64_t)v48;
  swift_beginAccess(v48 + 4, v50, 0LL, 0LL);
  uint64_t v24 = *(void *)(v23 + 16);
  uint64_t v25 = sub_234134(0LL, v32, v24, v23);
  if ((v26 & 1) != 0) {
    uint64_t v27 = v24;
  }
  else {
    uint64_t v27 = v25;
  }
  if ((v27 | v24) < 0) {
    goto LABEL_27;
  }
  if (v24 < v27) {
    goto LABEL_28;
  }
  *(void *)&v41 = 0LL;
  *((void *)&v41 + 1) = v27;
  *(void *)&uint64_t v42 = v23;
  swift_retain(v23);
  uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A89B8);
  uint64_t v29 = sub_22E92C();
  Slice<>.withUnsafeBytes<A>(_:)(v39, sub_23A8B8, 0LL, v28, v19, v29);
  swift_release(v20);
  swift_release(v35);
  result = swift_release_n(v23, 2LL);
  void *v31 = *(void *)&v39[0];
  return result;
}

void mergeDictionaries(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      __int128 v13 = 0u;
      __int128 v14 = 0u;
      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v14;
        do
        {
          for (i = 0LL; i != v7; i = (char *)i + 1)
          {
            if (*(void *)v14 != v8) {
              objc_enumerationMutation(v5);
            }
            uint64_t v10 = *(void *)(*((void *)&v13 + 1) + 8LL * (void)i);
            id v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKey:v10]);

            if (!v11)
            {
              id v12 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKey:v10]);
              [v3 setObject:v12 forKey:v10];
            }
          }

          id v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
        }

        while (v7);
      }
    }
  }
}

id getPreInstalledAssets(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v17 = normalizedAssetType((uint64_t)v8, v10, v11, v12, v13, v14, v15, v16);
  __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v7 stringByAppendingPathComponent:v18]);
  InstalledAssetIds = getInstalledAssetIds(v19);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(InstalledAssetIds);

  if (!v21)
  {
    uint64_t v23 = 0LL;
    if (!a4) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  uint64_t v22 = dataFillInstalledWithPurpose(v8, v21, 0LL, v7, 0LL);
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  if (a4) {
LABEL_3:
  }
    *a4 = v21;
LABEL_4:
  id v24 = filterResults(v9, v23);
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);

  return v25;
}

__CFString *stringForMAQueryResult(unint64_t a1)
{
  if (a1 >= 0xF) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAQueryResult%llu",  a1));
  }
  else {
    return *(&off_350200 + a1);
  }
}

LABEL_19:
  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%lld",  [v19 count]));
  analyticsQueue = (dispatch_queue_s *)v41->_analyticsQueue;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __173__ControlManager_sendQueryResults_assetType_purpose_catalogInfo_returnTypes_postedDate_lastFetchedDate_result_isFiltered_requireSpecificAsset_connection_message_clientName___block_invoke;
  block[3] = &unk_34FD60;
  void block[4] = v41;
  uint64_t v64 = v58;
  uint64_t v65 = v55;
  uint64_t v66 = v56;
  uint64_t v67 = v46;
  uint64_t v68 = a10;
  uint64_t v69 = v40;
  uint64_t v70 = a11;
  uint64_t v71 = a12;
  v48 = v46;
  unsigned __int8 v49 = v56;
  v50 = v55;
  v51 = v58;
  dispatch_async(analyticsQueue, block);
}

      goto LABEL_20;
    }

    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v17 autoAssetEntries]);

    if (!v37)
    {
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v11 summary]);
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v17 summary]);
        *(_DWORD *)buf = 138544130;
        uint64_t v59 = v44;
        uint64_t v60 = 2114;
        v61 = v10;
        v62 = 2114;
        id v63 = v45;
        uint64_t v64 = 2114;
        uint64_t v65 = v46;
        _os_log_impl( &dword_0,  v43,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {setConfigurationFromMessageName} auto-asset-entries learned for pre-existing set-configuration | messageName:%{public}@, setInfoInstance:%{public}@, setConfiguration:%{public}@",  buf,  0x2Au);
      }

      v47 = (void *)objc_claimAutoreleasedReturnValue([v11 autoAssetEntries]);
      [v17 setAutoAssetEntries:v47];

      goto LABEL_20;
    }

    if (-[MADAutoAssetControlManager setConfiguration:matchesAssetEntriesFromInfoInstance:]( self,  "setConfiguration:matchesAssetEntriesFromInfoInstance:",  v17,  v11))
    {
LABEL_20:
      uint64_t v28 = 0LL;
      uint64_t v29 = 0LL;
      goto LABEL_21;
    }

    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue([v38 oslog]);

    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v11 summary]);
      v56 = (void *)objc_claimAutoreleasedReturnValue([v17 summary]);
      *(_DWORD *)buf = 138544130;
      uint64_t v59 = v54;
      uint64_t v60 = 2114;
      v61 = v10;
      v62 = 2114;
      id v63 = v55;
      uint64_t v64 = 2114;
      uint64_t v65 = v56;
      _os_log_error_impl( &dword_0,  v39,  OS_LOG_TYPE_ERROR,  "[%{public}@] {setConfigurationFromMessageName} different auto-asset-entries than are currently defined | message Name:%{public}@, setInfoInstance:%{public}@, setConfiguration:%{public}@",  buf,  0x2Au);
    }

    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    id v17 = 0LL;
  }

  else if ((!-[MADAutoAssetControlManager _setMessageCanCreateSetConfiguration:]( self,  "_setMessageCanCreateSetConfiguration:",  v10) | v18) == 1)
  {
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue([v26 oslog]);

    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([v11 summary]);
      *(_DWORD *)buf = 138543874;
      uint64_t v59 = v48;
      uint64_t v60 = 2114;
      v61 = v10;
      v62 = 2114;
      id v63 = v49;
      _os_log_error_impl( &dword_0,  v27,  OS_LOG_TYPE_ERROR,  "[%{public}@] {setConfigurationFromMessageName} no set-configuration found for command requiring pre-defined set- configuration | messageName:%{public}@, setInfoInstance:%{public}@",  buf,  0x20u);
    }

    id v17 = 0LL;
    uint64_t v28 = @"no known set-configuration for command requiring pre-defined set-configuration";
    uint64_t v29 = 6558LL;
  }

  else
  {
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v11 autoAssetEntries]);

    if (v30)
    {
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v11 autoAssetEntries]);
      uint64_t v32 = [v31 count];

      if (v32)
      {
        uint64_t v57 = 0LL;
        uint64_t v29 = -[MADAutoAssetControlManager setConfigurationNewSetConfiguration:forSetInfoInstance:dueToMessageName:selectedConfig:]( self,  "setConfigurationNewSetConfiguration:forSetInfoInstance:dueToMessageName:selectedConfig:",  @"setConfigurationFromMessageName",  v11,  v10,  &v57);
        id v17 = v57;
        if (v17)
        {
          uint64_t v28 = 0LL;
        }

        else
        {
          uint64_t v28 = @"unable to create set-configuration from provided asset-entries";
          uint64_t v29 = 6101LL;
        }
      }

      else
      {
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        v41 = (os_log_s *)objc_claimAutoreleasedReturnValue([v40 oslog]);

        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v11 summary]);
          *(_DWORD *)buf = 138543874;
          uint64_t v59 = v52;
          uint64_t v60 = 2114;
          v61 = v10;
          v62 = 2114;
          id v63 = v53;
          _os_log_error_impl( &dword_0,  v41,  OS_LOG_TYPE_ERROR,  "[%{public}@] {setConfigurationFromMessageName} no known set-configuration and empty provided asset-entries | messageName:%{public}@, setInfoInstance:%{public}@",  buf,  0x20u);
        }

        id v17 = 0LL;
        uint64_t v28 = @"no known set-configuration and empty provided asset-entries";
        uint64_t v29 = 6555LL;
      }
    }

    else
    {
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue([v35 oslog]);

      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        v51 = (void *)objc_claimAutoreleasedReturnValue([v11 summary]);
        *(_DWORD *)buf = 138543874;
        uint64_t v59 = v50;
        uint64_t v60 = 2114;
        v61 = v10;
        v62 = 2114;
        id v63 = v51;
        _os_log_error_impl( &dword_0,  v36,  OS_LOG_TYPE_ERROR,  "[%{public}@] {setConfigurationFromMessageName} no known set-configuration and no asset-entries provided | mess ageName:%{public}@, setInfoInstance:%{public}@",  buf,  0x20u);
      }

      id v17 = 0LL;
      uint64_t v28 = @"no known set-configuration and no asset-entries provided";
      uint64_t v29 = 6551LL;
    }
  }

  uint64_t v35 = 0u;
  uint64_t v36 = 0u;
  uint64_t v33 = 0u;
  id v34 = 0u;
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetScheduler schedulerIntervalAggressiveAssetTypes]( self,  "schedulerIntervalAggressiveAssetTypes",  0LL));
  uint64_t v16 = -[os_log_s countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v33,  v41,  16LL);
  if (!v16)
  {
LABEL_27:

    uint64_t v10 = v9;
    goto LABEL_28;
  }

  id v17 = v16;
  __int128 v18 = *(void *)v34;
LABEL_21:
  __int128 v19 = 0LL;
  while (1)
  {
    if (*(void *)v34 != v18) {
      objc_enumerationMutation(v11);
    }
    if (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v8,  *(void *)(*((void *)&v33 + 1) + 8 * v19))) {
      break;
    }
    if (v17 == (id)++v19)
    {
      id v17 = -[os_log_s countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v33,  v41,  16LL);
      if (v17) {
        goto LABEL_21;
      }
      goto LABEL_27;
    }
  }

  uint64_t v10 = -[MADAutoAssetScheduler _aggressiveIntervalSecs](self, "_aggressiveIntervalSecs");
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler logger](self, "logger"));
  uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v31 oslog]);

  if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_41;
  }
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler summary](self, "summary"));
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
  *(_DWORD *)buf = 138544130;
  uint64_t v44 = v27;
  uint64_t v45 = 2114;
  uint64_t v46 = v28;
  v47 = 2114;
  v48 = v8;
  unsigned __int8 v49 = 2048;
  v50 = v10;
  uint64_t v29 = "%{public}@ | {AUTO-SCHEDULER:_decideTriggerIntervalSecs} aggressive | assetSelector:%{public}@ | scheduledJobAss"
        "etType:%{public}@ | determinedIntervalSecs:%ld";
LABEL_40:
  _os_log_impl(&dword_0, v26, OS_LOG_TYPE_DEFAULT, v29, buf, 0x2Au);

LABEL_41:
LABEL_42:

  return v10;
}

  return (char)v13;
}

      objc_autoreleasePoolPop(v7);
      id v5 = (char *)v5 + 1;
      self = v53;
    }

    while (v54 != v5);
    id v34 = [obj countByEnumeratingWithState:&v55 objects:v65 count:16];
    uint64_t v54 = v34;
  }

  while (v34);
LABEL_24:
  uint64_t v35 = 0;
LABEL_33:

  return v35;
}

        id v9 = 0LL;
        goto LABEL_20;
      }

      uint64_t v20 = objc_opt_respondsToSelector(v14, "initClearingAfter:");

      if ((v20 & 1) == 0) {
        goto LABEL_19;
      }
      uint64_t v12 = objc_msgSend( [MAAutoAssetInfoControl alloc],  "initClearingAfter:",  objc_msgSend(v3, "clearingAfter"));
    }

    id v9 = v12;
    goto LABEL_20;
  }

  id v5 = objc_alloc(&OBJC_CLASS___MAAutoAssetInfoControl);
  id v6 = objc_opt_respondsToSelector(v5, "initWithVolumeToReclaim:withUrgency:targetingPurgeAmount:");

  if ((v6 & 1) == 0) {
    goto LABEL_19;
  }
  id v7 = objc_alloc(&OBJC_CLASS___MAAutoAssetInfoControl);
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v3 volumeToReclaim]);
  id v9 = objc_msgSend( v7,  "initWithVolumeToReclaim:withUrgency:targetingPurgeAmount:",  v8,  objc_msgSend(v3, "cacheDeleteUrgency"),  objc_msgSend(v3, "targetingPurgeAmount"));

LABEL_20:
  return v9;
}
}

          id v8 = v27;
          goto LABEL_20;
        }

        -[NSMutableDictionary setSafeObject:forKey:](v46, "setSafeObject:forKey:", v15, v31);
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v27, "logger"));
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue([v38 oslog]);

        if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_19;
        }
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v27, "_updateLatestSummary"));
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v21, "summary"));
        v41 = (void *)objc_claimAutoreleasedReturnValue([v13 summary]);
        *(_DWORD *)buf = 138543874;
        uint64_t v53 = v39;
        uint64_t v54 = 2114;
        uint64_t v55 = v40;
        v56 = 2114;
        uint64_t v57 = v41;
        _os_log_impl( &dword_0,  v35,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {CLOUDCHANNELS:handlePushNotifications} requesting push | autoAssetSelector:%{public}@ | pushNoti fication:%{public}@",  buf,  0x20u);

        id v8 = v44;
LABEL_20:

        id v9 = v45;
LABEL_21:

        objc_autoreleasePoolPop(v14);
      }

      uint64_t v11 = [v9 countByEnumeratingWithState:&v48 objects:v58 count:16];
    }

    while (v11);
  }

  if (-[NSMutableDictionary count](v46, "count")) {
    -[MADAutoAssetControlManager _schedulePushNotifications:](v8, "_schedulePushNotifications:", v46);
  }

  return 0LL;
}

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue([v28 oslog]);

    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = (NSMutableString *)objc_claimAutoreleasedReturnValue([v10 summary]);
      *(_DWORD *)buf = 138543618;
      v94 = v13;
      v95 = 2114;
      v96 = v30;
      _os_log_impl( &dword_0,  v29,  OS_LOG_TYPE_DEFAULT,  "[MORE_CLIENT_REQUESTS] {%{public}@:removeCurrentSetJob} set-job indicated removal but has more to do | eventInfo:%{public}@",  buf,  0x16u);
    }

    goto LABEL_22;
  }

  uint64_t v26 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
  id v83 = v26;
  if (v17)
  {
    uint64_t v27 = v26;
    __int128 v86 = (uint64_t)v17;
  }

  else
  {
    __int128 v86 = objc_claimAutoreleasedReturnValue([(id)v18 autoAssetSetIdentifier]);
    uint64_t v31 = objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetJobForClientDomain:byIdentifier:]( self,  "locateSetJobForClientDomain:byIdentifier:",  v15));

    uint64_t v25 = (void *)v31;
    uint64_t v27 = v83;
  }

  uint64_t v32 = (id)v18;
  __int128 v88 = v15;
  id v84 = v32;
  if (v18)
  {
    uint64_t v33 = (os_log_s *)v32;
    -[NSMutableString appendFormat:](v27, "appendFormat:", @" | byUUID:%@", v12);
  }

  else
  {
    -[NSMutableString appendString:](v27, "appendString:", @" | byIdentifier");
    uint64_t v33 = v25;
    if (!v33)
    {
      id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue([v75 oslog]);

      id v17 = (void *)v86;
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        id v76 = (NSMutableString *)objc_claimAutoreleasedReturnValue([v10 summary]);
        *(_DWORD *)buf = 138543618;
        v94 = v13;
        v95 = 2114;
        v96 = v76;
        _os_log_impl( &dword_0,  v70,  OS_LOG_TYPE_DEFAULT,  "[NO_JOB_FOUND] {%{public}@:removeCurrentSetJob} set-job not found | eventInfo:%{public}@",  buf,  0x16u);
      }

      uint64_t v71 = v83;
      goto LABEL_69;
    }
  }

  id v85 = v33;
  id v34 = v86;
  if (v86)
  {
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v10 setJobInformation]);
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 currentSetStatus]);

    if (v36)
    {
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v10 clientRequest]);
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v37 responseMessage]);
      uint64_t v39 =  -[MADAutoAssetControlManager updateAutoAssetSetStatus:forClientDomain:forAssetSetIdentifier:forJobResponse:withResponseError:clearingDownloadProgressReason:withAssetSetStatus:]( self,  "updateAutoAssetSetStatus:forClientDomain:forAssetSetIdentifier:forJobResponse:withResponseError:clearing DownloadProgressReason:withAssetSetStatus:",  v13,  v88,  v86,  v38,  0LL,  @"removing current set-job",  0LL);
    }
  }

  -[MADAutoAssetControlManager atomicInstanceRemovedSetJob:removingForReason:historyOperation:]( self,  "atomicInstanceRemovedSetJob:removingForReason:historyOperation:",  v85,  v13,  a7);
  if (v12 && v84)
  {
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsByUUID](self, "currentJobsByUUID"));
    [v40 removeObjectForKey:v12];
  }

  v41 = v88;
  if (v86 && v25)
  {
    uint64_t v42 = -[MADAutoAssetControlManager newSetEntryIDForClientDomain:forAssetSetIdentifier:]( self,  "newSetEntryIDForClientDomain:forAssetSetIdentifier:",  v88,  v86);
    if (v42)
    {
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentSetJobsByIdentifier](self, "currentSetJobsByIdentifier"));
      [v43 removeObjectForKey:v42];

      v41 = v88;
    }
  }

  -[MADAutoAssetControlManager removeSetDescriptorActiveJobByClientDomain:forAssetSetIdentifier:fromLocation:]( self,  "removeSetDescriptorActiveJobByClientDomain:forAssetSetIdentifier:fromLocation:",  v41,  v86,  v13);
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v92 discoveredAtomicInstance]);

  if (v44)
  {
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v92 discoveredAtomicInstance]);
    -[MADAutoAssetControlManager removeSetDescriptorActiveJobByAtomicInstanceUUID:]( self,  "removeSetDescriptorActiveJobByAtomicInstanceUUID:",  v45);
  }

  uint64_t v46 = objc_claimAutoreleasedReturnValue([v92 latestDownloadedAtomicInstance]);
  if (v46)
  {
    v47 = (void *)v46;
    v48 = (void *)objc_claimAutoreleasedReturnValue([v92 latestDownloadedAtomicInstance]);
    unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([v92 discoveredAtomicInstance]);
    v81 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v48, v49);

    id v34 = v86;
    if ((v81 & 1) == 0)
    {
      v50 = (void *)objc_claimAutoreleasedReturnValue([v92 latestDownloadedAtomicInstance]);
      -[MADAutoAssetControlManager removeSetDescriptorActiveJobByAtomicInstanceUUID:]( self,  "removeSetDescriptorActiveJobByAtomicInstanceUUID:",  v50);
    }
  }

  v51 = -[MAAutoAssetSelector initForAssetType:withAssetSpecifier:]( objc_alloc(&OBJC_CLASS___MAAutoAssetSelector),  "initForAssetType:withAssetSpecifier:",  v88,  v34);
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager activelyEliminatingSelectors](self, "activelyEliminatingSelectors"));
  v80 = v51;
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v51 persistedEntryID]);
  uint64_t v54 = [v52 safeObjectForKey:v53 ofClass:objc_opt_class(MADAutoAssetEliminate)];
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);

  uint64_t v82 = v55;
  if (v12 && v55)
  {
    v56 = (void *)objc_claimAutoreleasedReturnValue([v55 activeJobsByUUID]);
    uint64_t v57 = [v56 safeObjectForKey:v12 ofClass:objc_opt_class(NSString)];
    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(v57);

    if (v58)
    {
      if (+[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v58, v12))
      {
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v82 activeJobsByUUID]);
        [v59 removeObjectForKey:v58];
      }
    }

    else
    {
      uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      v61 = (os_log_s *)objc_claimAutoreleasedReturnValue([v60 oslog]);

      log = v61;
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        v62 = (void *)objc_claimAutoreleasedReturnValue([v82 summary]);
        *(_DWORD *)buf = 138544386;
        v94 = v13;
        v95 = 2114;
        v96 = v88;
        v97 = 2114;
        v98 = v34;
        v99 = 2114;
        v100 = v12;
        v101 = 2114;
        v102 = v62;
        _os_log_impl( &dword_0,  log,  OS_LOG_TYPE_DEFAULT,  "\n [SET-ELIMINATE]{%{public}@:removeCurrentSetJob} no active job for clientDomainName:%{public}@ | setJobIdentifi er:%{public}@ | autoAssetJobUUID:%{public}@ | eliminateTracker:%{public}@",  buf,  0x34u);
      }
    }

    uint64_t v55 = v82;
  }

  -[MADAutoAssetControlManager _eliminateCompleteIfAllDone:](self, "_eliminateCompleteIfAllDone:", v55);
  id v63 = v89;
  uint64_t v64 = v90;
  if (v84)
  {
    uint64_t v64 = [v84 earlierSchedulerInvolved] | v90;
    id v63 = [v84 earlierPotentialNetworkFailure] | v89;
  }

  if (v25)
  {
    uint64_t v65 = v64 | [v25 earlierSchedulerInvolved];
    uint64_t v66 = [v25 earlierPotentialNetworkFailure];
    id v17 = (void *)v86;
    if ((v65 & 1) != 0)
    {
      id v63 = v63 | v66;
LABEL_58:
      if ((_DWORD)v63)
      {
        __int128 v87 = (void *)objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6401LL,  v13,  0LL,  @"auto-asset-scheduler involved set-job finished with potential network-connectivity failure"));
        loga = (os_log_t)objc_claimAutoreleasedReturnValue([v92 clientDomainName]);
        id v77 = (void *)objc_claimAutoreleasedReturnValue([v92 assetSetIdentifier]);
        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v92 discoveredAtomicInstance]);
        +[MADAutoAssetHistory recordFailedOperation:fromLayer:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:failingWithError:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordFailedOperation:fromLayer:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:failingWithError:",  504LL,  1LL,  loga,  v77,  v67,  v87);
      }

      +[MADAutoAssetScheduler jobFinishedForSetDomainName:forAssetSetIdentifier:withPotentialNetworkFailure:]( &OBJC_CLASS___MADAutoAssetScheduler,  "jobFinishedForSetDomainName:forAssetSetIdentifier:withPotentialNetworkFailure:",  v88,  v17,  v63);
    }
  }

  else
  {
    id v17 = (void *)v86;
    if (v64) {
      goto LABEL_58;
    }
  }

  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager statistics](self, "statistics"));
  uint64_t v69 = v68;
  if (v90)
  {
    uint64_t v70 = v85;
    if (v89) {
      objc_msgSend( v68,  "setFinishedJobSchedulerNetworkFailure:",  (char *)objc_msgSend(v68, "finishedJobSchedulerNetworkFailure") + 1);
    }
    else {
      objc_msgSend( v68,  "setFinishedJobSchedulerNotNetworkRelated:",  (char *)objc_msgSend(v68, "finishedJobSchedulerNotNetworkRelated") + 1);
    }
  }

  else
  {
    uint64_t v70 = v85;
    if (v89) {
      objc_msgSend( v68,  "setFinishedJobClientNetworkFailure:",  (char *)objc_msgSend(v68, "finishedJobClientNetworkFailure") + 1);
    }
    else {
      objc_msgSend( v68,  "setFinishedJobClientNotNetworkRelated:",  (char *)objc_msgSend(v68, "finishedJobClientNotNetworkRelated") + 1);
    }
  }

  uint64_t v71 = v83;

LABEL_69:
  id v72 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  v73 = (os_log_s *)objc_claimAutoreleasedReturnValue([v72 oslog]);

  if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v74 = (NSString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
    *(_DWORD *)buf = 138543618;
    v94 = v74;
    v95 = 2114;
    v96 = v71;
    _os_log_impl(&dword_0, v73, OS_LOG_TYPE_DEFAULT, "[%{public}@] {removeCurrentSetJob} %{public}@", buf, 0x16u);
  }

  uint64_t v15 = v88;
LABEL_22:
}

    if (!v16) {
      uint64_t v16 = (id)objc_claimAutoreleasedReturnValue([v15 autoAssetSelector]);
    }
    goto LABEL_21;
  }

  if (a5) {
    *a5 = v20;
  }

  return v19;
}

  uint64_t v36 = *(void **)(v1 + 48);
  uint64_t v37 = *(void *)(v1 + 88);
  uint64_t v38 = [v2 checkedCode];
  uint64_t v39 = *(void *)(v1 + 56);
  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v2 checkedDescription]);
  [v36 issueResponseForEventInfo:v37 withErrorCode:v38 fromAction:v39 withDescription:v40];
LABEL_21:
}

    uint64_t v27 = v19 & v26;
  }

  else
  {
    uint64_t v27 = 0;
  }

  return v27;
}

  return v7;
}
}

    uint64_t v14 = v48;

    uint64_t v20 = v49;
    goto LABEL_20;
  }

  uint64_t v35 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v15 summary]);
  uint64_t v37 = -[NSString initWithFormat:]( v35,  "initWithFormat:",  @"unable to allocate client-lock-reason | client:%@, selector:%@, reason:%@",  v13,  v36,  v17);

  uint64_t v31 = (id)objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6101LL,  @"AUTO-LOCKER:endedLockByClient",  0LL,  v37));
LABEL_21:

  return v31;
}

        __break(1u);
        goto LABEL_20;
      }

    __int128 v19 = v15 & 0xC;
    result = v15;
    if (v19 == v14) {
      result = sub_22378C(v15, a1, a2);
    }
    uint64_t v20 = result >> 16;
    if (result >> 16 >= v11) {
      break;
    }
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      result = String.UTF8View._foreignSubscript(position:)();
      uint64_t v21 = result;
      if (v19 != v14) {
        goto LABEL_29;
      }
    }

    else if ((a2 & 0x2000000000000000LL) != 0)
    {
      v32[0] = a1;
      v32[1] = v25;
      uint64_t v21 = *((_BYTE *)v32 + v20);
      if (v19 != v14) {
        goto LABEL_29;
      }
    }

    else
    {
      result = v24;
      if ((a1 & 0x1000000000000000LL) == 0) {
        result = _StringObject.sharedUTF8.getter(a1, a2);
      }
      uint64_t v21 = *(_BYTE *)(result + v20);
      if (v19 != v14)
      {
LABEL_29:
        if ((a2 & 0x1000000000000000LL) != 0) {
          goto LABEL_33;
        }
        goto LABEL_30;
      }
    }

    result = sub_22378C(v15, a1, a2);
    uint64_t v15 = result;
    if ((a2 & 0x1000000000000000LL) != 0)
    {
LABEL_33:
      if (v11 <= v15 >> 16) {
        goto LABEL_45;
      }
      uint64_t v15 = String.UTF8View._foreignIndex(after:)(v15, a1, a2);
      goto LABEL_35;
    }

  swift_release(v26);
  uint64_t v22 = v6[3];
  if (v22 >= 2)
  {
    uint64_t v23 = v22 >> 1;
    uint64_t v21 = __OFSUB__(v23, v7);
    id v24 = v23 - v7;
    if (v21) {
      goto LABEL_25;
    }
    v6[2] = v24;
  }

  return v6;
}

  swift_release(v24);
  uint64_t v20 = v4[3];
  if (v20 >= 2)
  {
    uint64_t v21 = v20 >> 1;
    __int128 v19 = __OFSUB__(v21, v5);
    uint64_t v22 = v21 - v5;
    if (v19) {
      goto LABEL_25;
    }
    v4[2] = v22;
  }

  return v4;
}

  swift_release(v25);
  uint64_t v21 = v5[3];
  if (v21 >= 2)
  {
    uint64_t v22 = v21 >> 1;
    uint64_t v20 = __OFSUB__(v22, v6);
    uint64_t v23 = v22 - v6;
    if (v20) {
      goto LABEL_25;
    }
    v5[2] = v23;
  }

  return v5;
}

  swift_release(v25);
  uint64_t v21 = v5[3];
  if (v21 >= 2)
  {
    uint64_t v22 = v21 >> 1;
    uint64_t v20 = __OFSUB__(v22, v6);
    uint64_t v23 = v22 - v6;
    if (v20) {
      goto LABEL_25;
    }
    v5[2] = v23;
  }

  return v5;
}

  swift_release(v24);
  uint64_t v20 = v4[3];
  if (v20 >= 2)
  {
    uint64_t v21 = v20 >> 1;
    __int128 v19 = __OFSUB__(v21, v5);
    uint64_t v22 = v21 - v5;
    if (v19) {
      goto LABEL_25;
    }
    v4[2] = v22;
  }

  return v4;
}

CFStringRef queryResultString(unint64_t a1)
{
  if (a1 > 0xE) {
    return @"MAQueryResult";
  }
  else {
    return *(&off_350020 + a1);
  }
}

void sub_A654(_Unwind_Exception *a1)
{
}

uint64_t _MAPreferencesIsVerboseLoggingEnabled()
{
  if (_MAPreferencesIsVerboseLoggingEnabled_onceToken != -1) {
    dispatch_once(&_MAPreferencesIsVerboseLoggingEnabled_onceToken, &__block_literal_global_797);
  }
  return _MAPreferencesIsVerboseLoggingEnabled__verboseLoggingEnabled;
}

uint64_t _isAssetTypeAllowedToGetServerUrl(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString);
    char isKindOfClass = objc_opt_isKindOfClass(v1, v2);
  }

  else
  {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

LABEL_169:
      goto LABEL_212;
    case 0xALL:
      uint64_t v29 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue(-[SUCoreConnectMessage summary](self->_responseMessage, "summary"));
      if (self->_setJobInformation) {
        uint64_t v30 = @"Y";
      }
      else {
        uint64_t v30 = @"N";
      }
      if (self->_clientRequest) {
        uint64_t v31 = @"Y";
      }
      else {
        uint64_t v31 = @"N";
      }
      if (self->_clientReplyCompletion) {
        uint64_t v32 = @"Y";
      }
      else {
        uint64_t v32 = @"N";
      }
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MAAutoAssetSelector summary](self->_autoAssetSelector, "summary"));
      uint64_t v33 = -[NSString initWithFormat:]( v29,  "initWithFormat:",  @"CLIENT_REPLY[%@]|setJobInfo:%@|clientRequest:%@|reply:%@|selector[%@]|jobID[%@]",  v12,  v30,  v31,  v32,  v26,  self->_autoAssetUUID);
      goto LABEL_129;
    case 0xBLL:
      id v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJobInformation currentStatus](self->_jobInformation, "currentStatus"));
      uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue([v34 downloadProgress]);

      if (!v12) {
        uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MAAutoAssetStatus downloadProgress](self->_autoAssetStatus, "downloadProgress"));
      }
      uint64_t v35 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MAAutoAssetSelector summary](self->_autoAssetSelector, "summary"));
      uint64_t v36 = self->_autoAssetUUID;
      if (v12) {
        uint64_t v37 = (__CFString *)objc_claimAutoreleasedReturnValue(-[__CFString summary](v12, "summary"));
      }
      else {
        uint64_t v37 = @"N";
      }
      if (self->_lockForUseError)
      {
        v100 = objc_alloc(&OBJC_CLASS___NSString);
        v101 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetClientRequest responseErrorSummary:]( &OBJC_CLASS___MADAutoAssetClientRequest,  "responseErrorSummary:",  self->_lockForUseError));
        v102 = -[NSString initWithFormat:](v100, "initWithFormat:", @"|lockError:%@", v101);
        id v3 = -[NSString initWithFormat:]( v35,  "initWithFormat:",  @"CLIENT_PROGRESS|selector[%@]|jobID[%@]|progress[%@]%@",  v26,  v36,  v37,  v102);
      }

      else
      {
        id v3 = -[NSString initWithFormat:]( v35,  "initWithFormat:",  @"CLIENT_PROGRESS|selector[%@]|jobID[%@]|progress[%@]%@",  v26,  v36,  v37,  &stru_355768);
      }

      if (v12) {

      }
      goto LABEL_169;
    case 0xCLL:
      uint64_t v38 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v39 = objc_claimAutoreleasedReturnValue(-[MAAutoAssetSelector summary](self->_autoAssetSelector, "summary"));
      uint64_t v12 = (__CFString *)v39;
      uint64_t v40 = @"Y";
      if (self->_fromAutoAssetJob) {
        v41 = @"Y";
      }
      else {
        v41 = @"N";
      }
      if (self->_schedulerInvolved) {
        uint64_t v42 = @"Y";
      }
      else {
        uint64_t v42 = @"N";
      }
      if (!self->_potentialNetworkFailure) {
        uint64_t v40 = @"N";
      }
      uint64_t v43 = -[NSString initWithFormat:]( v38,  "initWithFormat:",  @"FINISHED|selector[%@]|UUID[%@]|fromAutoAssetJob:%@|schedulerInvolved:%@|potentialNetworkFailure:%@",  v39,  self->_autoAssetUUID,  v41,  v42,  v40,  v131);
      goto LABEL_211;
    case 0xDLL:
      uint64_t v44 = objc_alloc(&OBJC_CLASS___NSString);
      if (self->_setJobInformation) {
        uint64_t v45 = @"Y";
      }
      else {
        uint64_t v45 = @"N";
      }
      id v7 = -[NSString initWithFormat:]( v44,  "initWithFormat:",  @"SET_PERSISTED|setJobInfo:%@|domain:%@|identifier:%@|jobID:[%@]",  v45,  self->_clientDomainName,  self->_assetSetIdentifier,  self->_autoAssetUUID,  v130,  v131);
      goto LABEL_215;
    case 0xELL:
      uint64_t v46 = objc_alloc(&OBJC_CLASS___NSString);
      if (self->_setJobInformation) {
        v47 = @"Y";
      }
      else {
        v47 = @"N";
      }
      v134 = *(_OWORD *)&self->_clientDomainName;
      v48 = self->_autoAssetUUID;
      unsigned __int8 v49 = objc_claimAutoreleasedReturnValue(-[SUCoreConnectMessage summary](self->_responseMessage, "summary"));
      uint64_t v12 = (__CFString *)v49;
      if (self->_clientReplyCompletion) {
        v50 = @"Y";
      }
      else {
        v50 = @"N";
      }
      uint64_t v43 = -[NSString initWithFormat:]( v46,  "initWithFormat:",  @"SET_CLIENT_REPLY|setJobInfo:%@|domain:%@|identifier:%@|jobID[%@]|clientRequest[%@]|clientReply[%@]",  v47,  v134,  v48,  v49,  v50);
      goto LABEL_211;
    case 0xFLL:
      v51 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v52 = @"N";
      setJobInformation = self->_setJobInformation;
      if (setJobInformation) {
        uint64_t v54 = @"Y";
      }
      else {
        uint64_t v54 = @"N";
      }
      clientDomainName = self->_clientDomainName;
      assetSetIdentifier = self->_assetSetIdentifier;
      uint64_t v57 = self->_autoAssetUUID;
      uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoSetJobInformation currentSetStatus](setJobInformation, "currentSetStatus"));
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString downloadProgress](v12, "downloadProgress"));
      if (v26)
      {
        v133 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoSetJobInformation currentSetStatus](self->_setJobInformation, "currentSetStatus"));
        v132 = (void *)objc_claimAutoreleasedReturnValue([v133 downloadProgress]);
        uint64_t v52 = (__CFString *)objc_claimAutoreleasedReturnValue([v132 summary]);
      }

      if (self->_lockForUseError)
      {
        v103 = objc_alloc(&OBJC_CLASS___NSString);
        v104 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetClientRequest responseErrorSummary:]( &OBJC_CLASS___MADAutoAssetClientRequest,  "responseErrorSummary:",  self->_lockForUseError));
        v105 = -[NSString initWithFormat:](v103, "initWithFormat:", @"|lockError[%@]", v104);
        id v3 = -[NSString initWithFormat:]( v51,  "initWithFormat:",  @"SET_CLIENT_PROGRESS|setJobInfo:%@|domain:%@|identifier[%@]|jobID[%@]|progress[%@]%@",  v54,  clientDomainName,  assetSetIdentifier,  v57,  v52,  v105);
      }

      else
      {
        id v3 = -[NSString initWithFormat:]( v51,  "initWithFormat:",  @"SET_CLIENT_PROGRESS|setJobInfo:%@|domain:%@|identifier[%@]|jobID[%@]|progress[%@]%@",  v54,  clientDomainName,  assetSetIdentifier,  v57,  v52,  &stru_355768);
      }

      if (v26)
      {
      }

      goto LABEL_169;
    case 0x10LL:
      uint64_t v58 = objc_alloc(&OBJC_CLASS___NSString);
      if (self->_setJobInformation) {
        uint64_t v59 = @"Y";
      }
      else {
        uint64_t v59 = @"N";
      }
      id v7 = -[NSString initWithFormat:]( v58,  "initWithFormat:",  @"SET_JOB_IDENTIFIER|setJobInfo:%@|domain:%@|identifier[%@]",  v59,  self->_clientDomainName,  self->_assetSetIdentifier,  v129,  v130,  v131);
      goto LABEL_215;
    case 0x11LL:
      uint64_t v60 = objc_alloc(&OBJC_CLASS___NSString);
      v61 = @"Y";
      if (self->_setJobInformation) {
        v62 = @"Y";
      }
      else {
        v62 = @"N";
      }
      if (self->_schedulerInvolved) {
        id v63 = @"Y";
      }
      else {
        id v63 = @"N";
      }
      if (!self->_potentialNetworkFailure) {
        v61 = @"N";
      }
      id v7 = -[NSString initWithFormat:]( v60,  "initWithFormat:",  @"SET_JOB_FINISHED|setJobInfo:%@|domain:%@|identifier:%@jobID[%@]|schedulerInvolved:%@|potentialNetworkFailure:%@",  v62,  *(_OWORD *)&self->_clientDomainName,  self->_autoAssetUUID,  v63,  v61);
      goto LABEL_215;
    case 0x12LL:
      uint64_t v64 = -[NSArray count](self->_setOfAutoAssetSelectors, "count");
      if (v64 - 9 <= 0xFFFFFFFFFFFFFFF7LL)
      {
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"SCHEDULER|count:%ld",  v64,  v127,  v128,  v129,  v130,  v131);
        goto LABEL_215;
      }

      v141 = 0u;
      v142 = 0u;
      v139 = 0u;
      v140 = 0u;
      id v84 = self->_setOfAutoAssetSelectors;
      id v85 = -[NSArray countByEnumeratingWithState:objects:count:]( v84,  "countByEnumeratingWithState:objects:count:",  &v139,  v144,  16LL);
      if (v85)
      {
        __int128 v86 = v85;
        uint64_t v12 = 0LL;
        __int128 v87 = *(void *)v140;
        do
        {
          for (i = 0LL; i != v86; i = (char *)i + 1)
          {
            if (*(void *)v140 != v87) {
              objc_enumerationMutation(v84);
            }
            __int128 v89 = *(void **)(*((void *)&v139 + 1) + 8LL * (void)i);
            if (v12)
            {
              -[__CFString appendFormat:](v12, "appendFormat:", @", %@", v90);
            }

            else
            {
              v91 = objc_alloc(&OBJC_CLASS___NSMutableString);
              v90 = (void *)objc_claimAutoreleasedReturnValue([v89 summary]);
              uint64_t v12 = -[NSMutableString initWithFormat:](v91, "initWithFormat:", @"%@", v90);
            }
          }

          __int128 v86 = -[NSArray countByEnumeratingWithState:objects:count:]( v84,  "countByEnumeratingWithState:objects:count:",  &v139,  v144,  16LL);
        }

        while (v86);
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      uint64_t v43 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"SCHEDULER|count:%ld|selectors:%@",  -[NSArray count](self->_setOfAutoAssetSelectors, "count"),  v12,  v128,  v129,  v130,  v131);
      goto LABEL_211;
    case 0x13LL:
      uint64_t v65 = -[NSArray count](self->_triggeredSets, "count");
      if (v65 - 9 <= 0xFFFFFFFFFFFFFFF7LL)
      {
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"SET-SCHEDULER|count:%ld",  v65,  v127,  v128,  v129,  v130,  v131);
        goto LABEL_215;
      }

      v137 = 0u;
      v138 = 0u;
      v135 = 0u;
      v136 = 0u;
      v92 = self->_triggeredSets;
      v93 = -[NSArray countByEnumeratingWithState:objects:count:]( v92,  "countByEnumeratingWithState:objects:count:",  &v135,  v143,  16LL);
      if (v93)
      {
        v94 = v93;
        uint64_t v12 = 0LL;
        v95 = *(void *)v136;
        do
        {
          for (j = 0LL; j != v94; j = (char *)j + 1)
          {
            if (*(void *)v136 != v95) {
              objc_enumerationMutation(v92);
            }
            v97 = *(void **)(*((void *)&v135 + 1) + 8LL * (void)j);
            if (v12)
            {
              -[__CFString appendFormat:](v12, "appendFormat:", @", %@", v98);
            }

            else
            {
              v99 = objc_alloc(&OBJC_CLASS___NSMutableString);
              v98 = (void *)objc_claimAutoreleasedReturnValue([v97 summary]);
              uint64_t v12 = -[NSMutableString initWithFormat:](v99, "initWithFormat:", @"%@", v98);
            }
          }

          v94 = -[NSArray countByEnumeratingWithState:objects:count:]( v92,  "countByEnumeratingWithState:objects:count:",  &v135,  v143,  16LL);
        }

        while (v94);
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      uint64_t v43 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"SET-SCHEDULER|count:%ld|triggeredSets:%@",  -[NSArray count](self->_triggeredSets, "count"),  v12,  v128,  v129,  v130,  v131);
LABEL_211:
      id v3 = (__CFString *)v43;
LABEL_212:

      return v3;
    case 0x14LL:
      return @"SCHEDULER_NO_ACTIVITY";
    case 0x15LL:
      id v4 = objc_alloc(&OBJC_CLASS___NSString);
      v126 = -[NSArray count](self->_pushNotifications, "count");
      id v5 = @"PUSH_NOTIFICATIONS|count:%ld";
      goto LABEL_214;
    case 0x16LL:
      uint64_t v66 = -[NSArray count](self->_autoAssetDescriptors, "count");
      if (v66 == 1)
      {
        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[NSArray objectAtIndex:](self->_autoAssetDescriptors, "objectAtIndex:", 0LL));
        if (v67)
        {
          uint64_t v68 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v67 summary]);
          uint64_t v12 = -[NSString initWithFormat:](v68, "initWithFormat:", @"secureDescriptor:%@", v69);
        }

        else
        {
          uint64_t v12 = @"BAD-DESCRIPTORS-ARRAY";
        }
      }

      else
      {
        uint64_t v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"secureDescriptors:%ld",  v66);
      }

      v123 = objc_alloc(&OBJC_CLASS___NSString);
      setDescriptor = self->_setDescriptor;
      if (setDescriptor) {
        id v72 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoSetDescriptor summary](self->_setDescriptor, "summary"));
      }
      else {
        id v72 = @"N";
      }
      finishedError = self->_finishedError;
      if (finishedError)
      {
        v125 = (void *)objc_claimAutoreleasedReturnValue(-[NSError checkedDescription](finishedError, "checkedDescription"));
        id v3 = -[NSString initWithFormat:]( v123,  "initWithFormat:",  @"SECURE_OPERATIONS_FINISHED|setDescriptor:%@|%@|finishedError:%@",  v72,  v12,  v125);
      }

      else
      {
        v110 = -[NSString initWithFormat:]( v123,  "initWithFormat:",  @"SECURE_OPERATIONS_FINISHED|setDescriptor:%@|%@|finishedError:%@",  v72,  v12,  @"N",  v129,  v130,  v131);
LABEL_204:
        id v3 = v110;
      }

LABEL_205:
      if (setDescriptor) {
      goto LABEL_212;
      }
    case 0x17LL:
      id v4 = objc_alloc(&OBJC_CLASS___NSString);
      v126 = -[NSArray count](self->_autoAssetDescriptors, "count");
      id v5 = @"STAGER_DESCRIPTORS|count:%ld";
      goto LABEL_214;
    case 0x18LL:
      uint64_t v70 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoSetConfiguration summary](self->_setConfiguration, "summary"));
      setDescriptor = self->_setPolicy;
      if (setDescriptor) {
        id v72 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MANAutoAssetSetPolicy summary](self->_setPolicy, "summary"));
      }
      else {
        id v72 = @"N";
      }
      assetTargetOSVersion = (const __CFString *)self->_assetTargetOSVersion;
      assetTargetBuildVersion = (const __CFString *)self->_assetTargetBuildVersion;
      if (!assetTargetOSVersion) {
        assetTargetOSVersion = @"N";
      }
      if (!assetTargetBuildVersion) {
        assetTargetBuildVersion = @"N";
      }
      assetTargetTrainName = (const __CFString *)self->_assetTargetTrainName;
      assetTargetRestoreVersion = (const __CFString *)self->_assetTargetRestoreVersion;
      if (!assetTargetTrainName) {
        assetTargetTrainName = @"N";
      }
      if (!assetTargetRestoreVersion) {
        assetTargetRestoreVersion = @"N";
      }
      v110 = -[NSString initWithFormat:]( v70,  "initWithFormat:",  @"STAGER_SET_START|setConfig[%@]|policy:%@|assetTarget[OSVersion:%@|BuildVersion:%@|TrainName:%@|RestoreVersion:%@",  v12,  v72,  assetTargetOSVersion,  assetTargetBuildVersion,  assetTargetTrainName,  assetTargetRestoreVersion);
      goto LABEL_204;
    case 0x19LL:
      v73 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MAAutoAssetSelector summary](self->_autoAssetSelector, "summary"));
      setDescriptor = self->_baseForPatchDescriptor;
      if (setDescriptor) {
        id v72 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetDescriptor assetVersion](self->_baseForPatchDescriptor, "assetVersion"));
      }
      else {
        id v72 = @"N";
      }
      if (self->_autoAssetCatalog) {
        v111 = @"Y";
      }
      else {
        v111 = @"N";
      }
      setPolicy = self->_setPolicy;
      if (setPolicy) {
        v113 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MANAutoAssetSetPolicy summary](self->_setPolicy, "summary"));
      }
      else {
        v113 = @"N";
      }
      v118 = (const __CFString *)self->_assetTargetOSVersion;
      v119 = (const __CFString *)self->_assetTargetBuildVersion;
      if (!v118) {
        v118 = @"N";
      }
      if (!v119) {
        v119 = @"N";
      }
      id v3 = -[NSString initWithFormat:]( v73,  "initWithFormat:",  @"STAGER_START|selector[%@]|patchingFrom:%@|catalog:%@|policy:%@|assetTargetOSVersion:%@|assetTargetBuildVersion:%@",  v12,  v72,  v111,  v113,  v118,  v119);
      if (setPolicy) {

      }
      goto LABEL_205;
    case 0x1ALL:
      uint64_t v74 = objc_alloc(&OBJC_CLASS___NSString);
      jobInformation = self->_jobInformation;
      if (jobInformation) {
        id v76 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJobInformation summary](self->_jobInformation, "summary"));
      }
      else {
        id v76 = @"N";
      }
      if (self->_finishedError)
      {
        v114 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetClientRequest responseErrorSummary:]( &OBJC_CLASS___MADAutoAssetClientRequest,  "responseErrorSummary:"));
        v115 = -[NSString initWithFormat:]( v74,  "initWithFormat:",  @"STAGER_INFO|jobInfo[%@]|finished[%@]",  v76,  v114);
        goto LABEL_193;
      }

      id v3 = -[NSString initWithFormat:]( v74,  "initWithFormat:",  @"STAGER_INFO|jobInfo[%@]|finished[%@]",  v76,  @"SUCCESS");
      goto LABEL_194;
    case 0x1BLL:
      id v4 = objc_alloc(&OBJC_CLASS___NSString);
      if (self->_autoAssetCatalog) {
        id v77 = @"Y";
      }
      else {
        id v77 = @"N";
      }
      v78 = -[NSArray count](self->_baseForStagingDescriptors, "count");
      v79 = v78;
      if (self->_finishedError)
      {
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetClientRequest responseErrorSummary:]( &OBJC_CLASS___MADAutoAssetClientRequest,  "responseErrorSummary:"));
        id v17 = -[NSString initWithFormat:]( v4,  "initWithFormat:",  @"STAGER_LOOKUP|autoAssetCatalog:%@|baseDescriptors:%ld|determineError[%@]",  v77,  v79,  v16);
        goto LABEL_162;
      }

      v127 = (const __CFString *)v78;
      v128 = @"SUCCESS";
      v126 = v77;
      id v5 = @"STAGER_LOOKUP|autoAssetCatalog:%@|baseDescriptors:%ld|determineError[%@]";
      goto LABEL_214;
    case 0x1CLL:
      id v4 = objc_alloc(&OBJC_CLASS___NSString);
      stagedToDownloaded = self->_stagedToDownloaded;
      if (stagedToDownloaded) {
        v81 = -[NSArray count](stagedToDownloaded, "count");
      }
      else {
        v81 = 0LL;
      }
      stagedSetLookupResults = self->_stagedSetLookupResults;
      if (stagedSetLookupResults) {
        stagedSetLookupResults = -[NSArray count](stagedSetLookupResults, "count");
      }
      v126 = v81;
      v127 = (const __CFString *)stagedSetLookupResults;
      id v5 = @"STAGER_PROMOTED|stagedToDownloaded:%ld|stagedSetLookupResults:%ld";
      goto LABEL_214;
    case 0x1DLL:
      id v4 = objc_alloc(&OBJC_CLASS___NSString);
      autoAssetSelector = self->_autoAssetSelector;
      if (autoAssetSelector)
      {
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MAAutoAssetSelector summary](autoAssetSelector, "summary"));
        id v17 = -[NSString initWithFormat:]( v4,  "initWithFormat:",  @"ASSET_SELECTOR|autoAssetSelector:%@",  v16,  v127,  v128);
        goto LABEL_162;
      }

      v126 = @"N";
      id v5 = @"ASSET_SELECTOR|autoAssetSelector:%@";
      goto LABEL_214;
    case 0x1ELL:
      id v83 = self->_setDescriptor;
      id v4 = objc_alloc(&OBJC_CLASS___NSString);
      jobInformation = self->_setConfiguration;
      if (v83)
      {
        if (jobInformation) {
          id v76 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoSetConfiguration summary](self->_setConfiguration, "summary"));
        }
        else {
          id v76 = @"N";
        }
        v114 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoSetDescriptor summary](self->_setDescriptor, "summary"));
        v115 = -[NSString initWithFormat:]( v4,  "initWithFormat:",  @"SET_CONFIGURATION|setConfiguration:%@|setDescriptor:%@",  v76,  v114);
LABEL_193:
        id v3 = v115;

LABEL_194:
        if (jobInformation) {

        }
        return v3;
      }

      if (!jobInformation)
      {
        v126 = @"N";
        id v5 = @"SET_CONFIGURATION|setConfiguration:%@";
LABEL_214:
        id v7 = -[NSString initWithFormat:](v4, "initWithFormat:", v5, v126, v127, v128, v129, v130, v131);
LABEL_215:
        id v3 = (__CFString *)v7;
        return v3;
      }

      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoSetConfiguration summary](self->_setConfiguration, "summary"));
      id v17 = -[NSString initWithFormat:]( v4,  "initWithFormat:",  @"SET_CONFIGURATION|setConfiguration:%@",  v16,  v127,  v128);
LABEL_162:
      v117 = v17;

      return v117;
    case 0x1FLL:
      return @"TIMER_FIRED";
    default:
      return @"UNKNOWN_TYPE";
  }

LABEL_58:
    LOBYTE(v_Block_object_dispose(va, 8) = 0;
  }

        v51 = 0LL;
        v61 = 0LL;
        uint64_t v52 = 0LL;
LABEL_79:

        p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
LABEL_80:

        objc_autoreleasePoolPop(v25);
      }

      v131 = [obj countByEnumeratingWithState:&v132 objects:v140 count:16];
      if (!v131)
      {
LABEL_85:

        self = v122;
        v118 = v126;
        v113 = v127;
        goto LABEL_86;
      }
    }
  }

  v113 = (void *)v17;
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager sendDownloadResult:with:extraInfo:]",  @"Skipping due to no downloadInfo. CFNetwork error: %@",  v18,  v19,  v20,  v21,  v17);
  v118 = 0LL;
LABEL_86:
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager sendDownloadResult:with:extraInfo:]",  @"reporting download attempt %@",  v114,  v115,  v116,  v117,  (uint64_t)v8);
  -[DownloadManager reportDownloadAttemptResult:with:](self, "reportDownloadAttemptResult:with:", v8, value);
}

        objc_autoreleasePoolPop(v47);
        uint64_t v45 = (char *)v45 + 1;
      }

      while (v102 != v45);
      v79 = [v44 countByEnumeratingWithState:&v105 objects:v113 count:16];
      v102 = v79;
      if (!v79)
      {
LABEL_64:

        uint64_t v35 = v84;
LABEL_65:

LABEL_66:
        v80 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedSetTargets](v2, "persistedSetTargets"));
        [v80 removeAllPersistedEntries:v35];
        id v34 = v85;
LABEL_67:
        __int128 v18 = v87;
        goto LABEL_68;
      }
    }
  }

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager bootedOSVersion](v2, "bootedOSVersion"));
  if ((+[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v8, v15) & 1) == 0)
  {

    goto LABEL_29;
  }

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager bootedOBuildVersion](v2, "bootedOBuildVersion"));
  id v17 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v86, v16);

  if (!v17)
  {
LABEL_29:
    uint64_t v35 = @"previous MA daemon execution was running from different OS version than booted OS version";
    goto LABEL_30;
  }

  __int128 v18 = v87;
  if (![v87 count])
  {
    v81 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
    v80 = (void *)objc_claimAutoreleasedReturnValue([v81 oslog]);

    id v34 = (void *)v8;
    if (os_log_type_enabled((os_log_t)v80, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v2, "_updateLatestSummary"));
      *(_DWORD *)buf = 138543362;
      v115 = v82;
      _os_log_impl( &dword_0,  (os_log_t)v80,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {loadPersistedSetConfigurations} no persisted set-targets to be resumed",  buf,  0xCu);
    }

    goto LABEL_67;
  }

  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  id obj = v87;
  __int128 v19 = [obj countByEnumeratingWithState:&v109 objects:v118 count:16];
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = *(void *)v110;
    do
    {
      for (i = 0LL; i != v20; i = (char *)i + 1)
      {
        if (*(void *)v110 != v21) {
          objc_enumerationMutation(obj);
        }
        uint64_t v23 = *(void *)(*((void *)&v109 + 1) + 8LL * (void)i);
        id v24 = objc_autoreleasePoolPush();
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedSetTargets](v2, "persistedSetTargets"));
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 persistedEntry:v23 fromLocation:@"loadPersistedSetTargets"]);

        if (v26)
        {
          uint64_t v27 = [v26 secureCodedObjectForKey:@"setTarget" ofClass:objc_opt_class(MADAutoSetTarget)];
          uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
          if (v28)
          {
            -[MADAutoAssetControlManager _logPersistedSetTarget:operation:forPersistedEntryID:withSetTarget:message:]( v2,  "_logPersistedSetTarget:operation:forPersistedEntryID:withSetTarget:message:",  @"loadPersistedSetTargets",  @"ENTRY_LOAD",  v23,  v28,  @"set-target validated");
          }

          else
          {
            uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
            uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue([v31 oslog]);

            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            {
              uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v99, "_updateLatestSummary"));
              *(_DWORD *)buf = 138543618;
              v115 = v33;
              v116 = 2114;
              v117 = v23;
              _os_log_error_impl( &dword_0,  v32,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetTargets} unable to load set-target | entryID:%{public}@",  buf,  0x16u);
            }

            uint64_t v2 = v99;
          }
        }

        else
        {
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
          uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue([v29 oslog]);

          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v2, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543618;
            v115 = v30;
            v116 = 2114;
            v117 = v23;
            _os_log_error_impl( &dword_0,  v28,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetTargets} unable to determine previous status | entryID:%{public}@",  buf,  0x16u);
          }
        }

        objc_autoreleasePoolPop(v24);
      }

      uint64_t v20 = [obj countByEnumeratingWithState:&v109 objects:v118 count:16];
    }

    while (v20);
    id v34 = v85;
    __int128 v18 = v87;
  }

  else
  {
    id v34 = (void *)v8;
  }

  v80 = obj;
LABEL_68:

  -[MADAutoAssetControlManager _logPersistedSetTargetTableOfContents:]( v2,  "_logPersistedSetTargetTableOfContents:",  @"loadPersistedSetTargets");
}

        uint64_t v58 = v99;
        goto LABEL_60;
      }

      id v24 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s fullAssetSelector](v22, "fullAssetSelector"));

      uint64_t v25 = *(void **)(v1 + 32);
      if (!v24)
      {
        __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v25 logger]);
        __int128 v88 = (os_log_s *)objc_claimAutoreleasedReturnValue([v87 oslog]);

        log = (NSMutableArray *)v88;
        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          v121 = v100;
          id v85 = v88;
          __int128 v86 = "{currentSetLockUsageEliminatingOtherThanSetAtomicInstances} | missing asset selector for entry:%{public}@";
LABEL_64:
          _os_log_error_impl(&dword_0, v85, OS_LOG_TYPE_ERROR, v86, buf, 0xCu);
        }

        goto LABEL_58;
      }

      v95 = v18;
      v96 = v16;
      log = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v102 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v112 = 0u;
      v113 = 0u;
      v114 = 0u;
      v115 = 0u;
      v106 = (id)objc_claimAutoreleasedReturnValue(-[os_log_s lockReasons](v23, "lockReasons"));
      v105 = v23;
      v109 = [v106 countByEnumeratingWithState:&v112 objects:v126 count:16];
      if (!v109) {
        goto LABEL_39;
      }
      v108 = *(void *)v113;
      do
      {
        uint64_t v26 = 0LL;
        do
        {
          if (*(void *)v113 != v108) {
            objc_enumerationMutation(v106);
          }
          uint64_t v27 = *(void **)(*((void *)&v112 + 1) + 8LL * (void)v26);
          uint64_t v28 = objc_autoreleasePoolPush();
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s lockReasons](v23, "lockReasons"));
          uint64_t v30 = [v29 safeObjectForKey:v27 ofClass:objc_opt_class(v15[316])];
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);

          uint64_t v32 = *(void **)(v1 + 32);
          if (v31)
          {
            v110 = v28;
            uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue([v32 atomicInstanceUUIDForLockTracker:v31]);
            id v34 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(v1 + 32) setAtomicInstanceForUUID:v33 fromSetAtomicInstances:*(void *)(v1 + 40)]);
            if (v34)
            {
              uint64_t v35 = objc_alloc(&OBJC_CLASS___NSString);
              uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v34 clientDomainName]);
              uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v34 assetSetIdentifier]);
              uint64_t v38 = -[NSString initWithFormat:](v35, "initWithFormat:", @"%@_%@", v36, v37);

              uint64_t v39 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v104,  "safeObjectForKey:ofClass:",  v38,  objc_opt_class(p_ivars[143]));
              uint64_t v40 = (id)objc_claimAutoreleasedReturnValue(v39);
              if (!v40)
              {
                uint64_t v40 = objc_alloc_init((Class)p_ivars[143]);
                -[NSMutableDictionary setSafeObject:forKey:](v104, "setSafeObject:forKey:", v40, v38);
              }

              v107 = v38;
              v41 = (void *)objc_claimAutoreleasedReturnValue([v31 clientLockReason]);
              uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 lockReason]);
              uint64_t v43 = [v40 safeObjectForKey:v42 ofClass:objc_opt_class(p_ivars[143])];
              uint64_t v44 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(v43);

              if (!v44)
              {
                uint64_t v44 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
                uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v31 clientLockReason]);
                uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v45 lockReason]);
                [v40 setSafeObject:v44 forKey:v46];
              }

              v47 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v44,  "safeObjectForKey:ofClass:",  v33,  objc_opt_class(&OBJC_CLASS___NSNumber));
              v48 = (NSNumber *)objc_claimAutoreleasedReturnValue(v47);
              if (v48)
              {
                unsigned __int8 v49 = v48;
                v50 = -[NSNumber longValue](v48, "longValue");
                if ([v31 activeLockCount] != v50)
                {
                  v51 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
                  uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue([v51 oslog]);

                  if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                  {
                    v56 = (void *)objc_claimAutoreleasedReturnValue([v31 summary]);
                    *(_DWORD *)buf = 134218242;
                    v121 = v50;
                    v122 = 2114;
                    v123 = v56;
                    _os_log_error_impl( &dword_0,  v52,  OS_LOG_TYPE_ERROR,  "{currentSetLockUsageEliminatingOtherThanSetAtomicInstances} | additional locked auto-asset for alr eady tracked lock-reason+set-atomic-instance count mismatch - using first count for set-lock-usage -map | alreadyTrackedCount:%ld | nextLockTracker:%{public}@",  buf,  0x16u);
                  }

                  id v1 = v101;
                }

        __break(0x5513u);
        goto LABEL_59;
      }

      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        uint64_t v10 = v32;
        uint64_t v12 = v33;
        goto LABEL_47;
      }
    }

    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0LL;
      }

      else
      {
        uint64_t v25 = (__int16 *)(a3 + 24LL * v13 + 16);
        uint64_t v26 = a2 - (unint64_t)v13;
        result = 0LL;
        while (1)
        {
          uint64_t v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }

        return 5LL;
      }
    }
  }

  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0LL;
    }
    else {
      return 3LL;
    }
  }

  return result;
}

LABEL_59:
  return (char)v8;
}

      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v31 latestDownloadedAtomicInstance]);
      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v30 latestAtomicInstanceToVend]);
      uint64_t v66 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v64, v65);

      if (v66)
      {
        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v67 oslog]);

        if (os_log_type_enabled((os_log_t)v35, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v68 = (__CFString *)objc_claimAutoreleasedReturnValue([v30 summary]);
          *(_DWORD *)buf = 138543362;
          v150 = v68;
          _os_log_impl( &dword_0,  (os_log_t)v35,  OS_LOG_TYPE_DEFAULT,  "{IssueClientReplySetJob}\n [JOB-UUID] same version found already tracked as latest-to-vend | setConfiguration:%{public}@",  buf,  0xCu);
        }

        goto LABEL_66;
      }

      -[MADAutoAssetControlManager setConfigurationAdoptLatestToVend:fromSetDescriptor:toSetConfiguration:]( self,  "setConfigurationAdoptLatestToVend:fromSetDescriptor:toSetConfiguration:",  @"IssueClientReplySetJob",  v31,  v30);
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v69 oslog]);

      if (!os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_65;
      }
      uint64_t v60 = (__CFString *)objc_claimAutoreleasedReturnValue([v30 summary]);
      *(_DWORD *)buf = 138543362;
      v150 = v60;
      v61 = "{IssueClientReplySetJob}\n"
            "[LATEST-TO-VEND] same version found is always latestAtomicInstanceToVend | setConfiguration:%{public}@";
      goto LABEL_64;
    }

    if (v141)
    {
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v141 latestDownloadedAtomicInstance]);
      v47 = (void *)objc_claimAutoreleasedReturnValue([v31 latestDownloadedAtomicInstance]);
      v48 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v46, v47);

      unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      v50 = (os_log_s *)objc_claimAutoreleasedReturnValue([v49 oslog]);

      v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
      if (v48)
      {
        if (v51)
        {
          uint64_t v52 = (__CFString *)objc_claimAutoreleasedReturnValue([v31 summary]);
          *(_DWORD *)buf = 138543362;
          v150 = v52;
          uint64_t v53 = "{IssueClientReplySetJob}\n"
                "[JOB-UUID] set-job with set-job descriptor that is already a downloaded set-descriptor | setDescriptor:%{public}@";
LABEL_57:
          _os_log_impl(&dword_0, v50, OS_LOG_TYPE_DEFAULT, v53, buf, 0xCu);
        }
      }

      else if (v51)
      {
        uint64_t v52 = (__CFString *)objc_claimAutoreleasedReturnValue([v141 summary]);
        *(_DWORD *)buf = 138543362;
        v150 = v52;
        uint64_t v53 = "{IssueClientReplySetJob}\n"
              "[JOB-UUID] set-job with set-job descriptor that is different from already downloaded set-descriptor (using"
              " already downloaded) | setJobDescriptor:%{public}@";
        goto LABEL_57;
      }
    }

    else
    {
      v62 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      v50 = (os_log_s *)objc_claimAutoreleasedReturnValue([v62 oslog]);

      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v52 = (__CFString *)objc_claimAutoreleasedReturnValue([v31 summary]);
        *(_DWORD *)buf = 138543362;
        v150 = v52;
        uint64_t v53 = "{IssueClientReplySetJob}\n"
              "[JOB-UUID] set-job with no set-job descriptor yet jobAtomicInstance is already downloaded set-descriptor |"
              " setDescriptor:%{public}@";
        goto LABEL_57;
      }
    }

    goto LABEL_59;
  }
          }

          else
          {
            uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
            id v83 = (os_log_s *)objc_claimAutoreleasedReturnValue([v82 oslog]);

            log = v83;
            if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543362;
              v125 = (os_log_s *)v19;
              _os_log_error_impl( &dword_0,  v83,  OS_LOG_TYPE_ERROR,  "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} Skipping malformed asset directory | assetDir:%{public}@ ",  buf,  0xCu);
            }
          }

          __int128 v18 = (char *)v18 + 1;
        }

        while (v18 != v15);
        uint64_t v15 = [v13 countByEnumeratingWithState:&v119 objects:v133 count:16];
      }

      while (v15);
    }

    id v85 = (os_log_s *)-[NSMutableArray count](v98, "count");
    __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue([v86 oslog]);

    __int128 v87 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if ((uint64_t)v85 <= 0)
    {
      id v8 = v93;
      if (v87)
      {
        *(_DWORD *)buf = 138543362;
        v125 = (os_log_s *)v6;
        __int128 v89 = "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} No pre-installed auto-assets were relocated | path:%{public}@";
        v90 = v12;
        v91 = 12;
LABEL_72:
        _os_log_impl(&dword_0, v90, OS_LOG_TYPE_DEFAULT, v89, buf, v91);
      }
    }

    else
    {
      id v8 = v93;
      if (v87)
      {
        __int128 v88 = @"s";
        *(_DWORD *)buf = 134218498;
        v125 = v85;
        v126 = 2114;
        v127 = (void *)v88;
        v128 = 2114;
        v129 = (os_log_s *)v6;
        __int128 v89 = "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} %ld pre-installed auto-asset%{public}@ successfully"
              " relocated | path:%{public}@";
        v90 = v12;
        v91 = 32;
        goto LABEL_72;
      }
    }

    id v9 = 0LL;
    goto LABEL_74;
  }

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue([v11 oslog]);

  if (v9)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager _preInstalledRelocateAutoAssets].cold.1();
    }
  }

  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v125 = (os_log_s *)v6;
    _os_log_impl( &dword_0,  v12,  OS_LOG_TYPE_DEFAULT,  "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} No directories found at path to pre-installed assets | path:%{public}@",  buf,  0xCu);
  }

  v98 = 0LL;
LABEL_74:

  return v98;
}

  __break(1u);
  return result;
}

LABEL_173:
    uint64_t v13 = v14;
    goto LABEL_174;
  }

  uint64_t v13 = 0LL;
LABEL_174:

  return v13;
}

id extractorDecodeClasses()
{
  if (extractorDecodeClasses_once != -1) {
    dispatch_once(&extractorDecodeClasses_once, &__block_literal_global_27);
  }
  return (id)extractorDecodeClasses__extractorDecodeClasses;
}

id getObjectFromMessageLogIfDesired(void *a1, const char *a2, const char *a3, void *a4, int a5)
{
  id v9 = a1;
  id v10 = a4;
  size_t length = (unint64_t)xpc_dictionary_get_double(v9, a2);
  if (!length) {
    goto LABEL_10;
  }
  data = xpc_dictionary_get_data(v9, a3, &length);
  if (!data)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"getObjectFromMessageLogIfDesired",  @"Failed to get key: %s due to not beinng present",  v12,  v13,  v14,  v15,  (uint64_t)a3);
LABEL_10:
    uint64_t v21 = 0LL;
    uint64_t v28 = 0LL;
    goto LABEL_15;
  }

  uint64_t v16 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", data, length));
  if (!v16)
  {
    if (a5) {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"getObjectFromMessageLogIfDesired",  @"Failed to get key: %s",  v17,  v18,  v19,  v20,  (uint64_t)a3);
    }
    goto LABEL_10;
  }

  uint64_t v21 = (void *)v16;
  id v30 = 0LL;
  uint64_t v22 = -[NSKeyedUnarchiver initForReadingFromData:error:]( objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver),  "initForReadingFromData:error:",  v16,  &v30);
  id v27 = v30;
  if (v27 || !v22)
  {
    if (a5) {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"getObjectFromMessageLogIfDesired",  @"getObjectFromMessage: could not decode object for key: %s error: %@",  v23,  v24,  v25,  v26,  (uint64_t)a3);
    }
    uint64_t v28 = 0LL;
  }

  else
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( -[NSKeyedUnarchiver decodeObjectOfClasses:forKey:]( v22,  "decodeObjectOfClasses:forKey:",  v10,  NSKeyedArchiveRootObjectKey));
  }

  -[NSKeyedUnarchiver finishDecoding](v22, "finishDecoding");

LABEL_15:
  return v28;
}

id preservedIdsDecodeClasses()
{
  if (preservedIdsDecodeClasses_once != -1) {
    dispatch_once(&preservedIdsDecodeClasses_once, &__block_literal_global_611);
  }
  return (id)preservedIdsDecodeClasses__preservedIdsDecodeClasses;
}

uint64_t backgroundDownloadsPossibleWithInfo(BOOL *a1)
{
  uint64_t PreferenceLong = getPreferenceLong(@"forceInProcessDownloads");
  if (PreferenceLong == 1)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"backgroundDownloadsPossibleWithInfo",  @"Using in-process downloads; forceInProcess: %ld backgroundDownloadsPossible: %d",
      v2,
      v3,
      v4,
      v5,
      1LL);
    uint64_t v7 = 0LL;
  }

  else
  {
    if ((objc_opt_respondsToSelector(&OBJC_CLASS___NSURLSession, "_backgroundServiceAvailable") & 1) != 0
      && (+[NSURLSession _backgroundServiceAvailable]( &OBJC_CLASS___NSURLSession,  "_backgroundServiceAvailable") & 1) == 0)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"backgroundDownloadsPossibleWithInfo",  @"Using in-process downloads; forceInProcess: %ld backgroundDownloadsPossible: %d",
        v8,
        v9,
        v10,
        v11,
        PreferenceLong);
      uint64_t v7 = 0LL;
    }

    else
    {
      uint64_t v7 = 1LL;
    }

    if ((unint64_t)(PreferenceLong - 2) <= 0xFFFFFFFFFFFFFFFCLL) {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"backgroundDownloadsPossibleWithInfo",  @"Unusual pref value for forceInProcess: %ld backgroundDownloadsPossible: %d",  v8,  v9,  v10,  v11,  PreferenceLong);
    }
  }

  if (a1) {
    *a1 = PreferenceLong == 1;
  }
  return v7;
}

uint64_t getPreferenceLong(void *a1)
{
  id v1 = _MAPreferencesCopyValue(a1);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  uint64_t v3 = v2;
  if (v2) {
    uint64_t v4 = (uint64_t)[v2 integerValue];
  }
  else {
    uint64_t v4 = -1LL;
  }

  return v4;
}

id getPurposeFromTaskDescriptor(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    uint64_t v9 = 0LL;
    uint64_t v5 = 0LL;
LABEL_7:
    id v6 = 0LL;
    goto LABEL_9;
  }

  uint64_t v3 = disassembleTaskDescriptor(v1);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  uint64_t v5 = v4;
  if (!v4)
  {
    uint64_t v9 = 0LL;
    goto LABEL_7;
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:@"isXml"]);
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKey:@"Purpose"]);
    uint64_t v8 = normalizePurpose(v7);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

LABEL_9:
  id v10 = v9;
  return v10;
}

    uint64_t v15 = 0LL;
    goto LABEL_10;
  }

  id v6 = v3;
  uint64_t v23 = objc_alloc(&OBJC_CLASS___MANAutoAssetSetEntry);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v6 assetSelector]);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v24 assetType]);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 assetSelector]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 assetSpecifier]);
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v6 assetSelector]);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 assetVersion]);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 assetSelector]);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 downloadDecryptionKey]);
  uint64_t v14 = [v6 assetLockedInhibitsRemoval];

  uint64_t v15 = -[MANAutoAssetSetEntry initForAssetType:withAssetSpecifier:withAssetVersion:usingDecryptionKey:assetLockedInhibitsRemoval:]( v23,  "initForAssetType:withAssetSpecifier:withAssetVersion:usingDecryptionKey:assetLockedInhibitsRemoval:",  v7,  v9,  v11,  v13,  v14);
  uint64_t v16 = v24;
LABEL_8:

LABEL_10:
  return v15;
}

  return v8;
}
}

    goto LABEL_10;
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v4 assetVersion]);

  if (v10)
  {
    uint64_t v16 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v4 assetType]);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v4 assetSpecifier]);
    uint64_t v12 = (os_log_s *)-[MAAutoAssetSelector initForAssetType:withAssetSpecifier:]( v16,  "initForAssetType:withAssetSpecifier:",  v17,  v18);

    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager simulateOperationsBySelector](self, "simulateOperationsBySelector"));
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s persistedEntryID](v12, "persistedEntryID"));
    uint64_t v21 = [v19 safeObjectForKey:v20 ofClass:objc_opt_class(MANAutoAssetInfoControl)];
    id v10 = (void *)objc_claimAutoreleasedReturnValue(v21);

    if (v10)
    {
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue([v22 oslog]);

      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v12, "summary"));
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v10 summary]);
        uint64_t v28 = 138543874;
        uint64_t v29 = v24;
        id v30 = 2114;
        uint64_t v31 = v25;
        uint64_t v32 = 2114;
        uint64_t v33 = v26;
        _os_log_impl( &dword_0,  v23,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {jobControlInformationForSelector} SIMULATE(wildcarded) | found control information | assetSelect or:%{public}@ | associatedControlInfo:%{public}@",  (uint8_t *)&v28,  0x20u);
      }
    }

    goto LABEL_9;
  }

  if (v7 == a5 + 1)
  {
LABEL_10:
    *a6 = result;
    a6[1] = a2;
    a6[2] = a3;
    a6[3] = a4;
    a6[4] = a5;
    return result;
  }

    uint64_t v9 = 0;
    goto LABEL_10;
  }

  if (v8) {
    goto LABEL_9;
  }
  if (!a3) {
LABEL_12:
  }
    __break(1u);
  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

__CFString *normalizePurpose(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1 && !isWellFormedPurpose(v1))
  {
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v2, v3) & 1) != 0)
    {
      id v4 = purposeIgnoredCharacterSet();
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      -[__CFString rangeOfCharacterFromSet:](v2, "rangeOfCharacterFromSet:", v5);
      uint64_t v7 = v6;

      if (v7)
      {
        id v8 = purposeIgnoredCharacterSet();
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
        id v10 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString componentsSeparatedByCharactersInSet:]( v2,  "componentsSeparatedByCharactersInSet:",  v9));
        uint64_t v11 = objc_claimAutoreleasedReturnValue([v10 componentsJoinedByString:&stru_355768]);

        uint64_t v2 = (__CFString *)v11;
      }
    }

    if (!isWellFormedPurpose(v2))
    {

      uint64_t v2 = &stru_355768;
    }
  }

  return v2;
}

LABEL_14:
    uint64_t v23 = 8LL;
    goto LABEL_15;
  }

  uint64_t v18 = *(void *)(a1 + 64);
  [*(id *)(a1 + 32) count];
  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager purgeAll:and:assetTypesList:clientName:]_block_invoke_2",  @"{purgeAll} %@ requested purge-all where unable to completely purge all assets | asset-types:%ld\n%@",  v19,  v20,  v21,  v22,  v18);
  if (!*(_BYTE *)(a1 + 88)) {
    goto LABEL_14;
  }
  uint64_t v23 = 5LL;
LABEL_15:
  sendClientResponse(*(void **)(a1 + 72), *(void **)(a1 + 80), v23);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager purgeAll:and:assetTypesList:clientName:]_block_invoke_2",  @"[CONTROL_MANAGER_ASSET_QUEUE] {purgeAll} ...purging all indicated assets",  v29,  v30,  v31,  v32,  v34);
}

  uint64_t v31 = v11;

  return v31;
}

    goto LABEL_15;
  }

  return v5;
}

  return v6;
}

    goto LABEL_15;
  }

  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v6 assetSpecifier]);

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v7 assetType]);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 assetType]);
  uint64_t v25 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v11, v12);
  uint64_t v26 = v25;
  if (!v24)
  {

    if (v26)
    {
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v37 oslog]);

      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v6 summary]);
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
        uint64_t v38 = 138543874;
        uint64_t v39 = v20;
        uint64_t v40 = 2114;
        v41 = v21;
        uint64_t v42 = 2114;
        uint64_t v43 = v22;
        uint64_t v23 = "%{public}@\n"
              "[AUTO-STAGER] {_doesSelector:matchDescriptor} match for asset-type of active stager-job | checkMatchSelect"
              "or:%{public}@ | candidateDescriptor:%{public}@";
        goto LABEL_22;
      }

      goto LABEL_23;
    }

    goto LABEL_15;
  }

  if (!v25) {
    goto LABEL_14;
  }
  id v27 = (void *)objc_claimAutoreleasedReturnValue([v7 assetSpecifier]);
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v6 assetSpecifier]);
  uint64_t v29 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v27, v28);

  if (v29)
  {
    id v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v6 summary]);
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
      uint64_t v38 = 138543874;
      uint64_t v39 = v20;
      uint64_t v40 = 2114;
      v41 = v21;
      uint64_t v42 = 2114;
      uint64_t v43 = v22;
      uint64_t v23 = "%{public}@\n"
            "[AUTO-STAGER] {_doesSelector:matchDescriptor} match for asset-type + asset-specifier of active stager-job | "
            "checkMatchSelector:%{public}@ | candidateDescriptor:%{public}@";
      goto LABEL_22;
    }

              uint64_t v23 = v98;
            }
          }

          else
          {
            uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
            id v30 = (void *)objc_claimAutoreleasedReturnValue([v31 oslog]);

            if (os_log_type_enabled((os_log_t)v30, OS_LOG_TYPE_ERROR))
            {
              uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
              *(_DWORD *)buf = 138543618;
              v117 = v32;
              v118 = 2114;
              v119 = v25;
              _os_log_error_impl( &dword_0,  (os_log_t)v30,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {_persistRebuildTrackingNewHandedOffDescriptors} unable to determine previous status for entry:%{public}@",  buf,  0x16u);
            }
          }

          objc_autoreleasePoolPop(v101);
          uint64_t v24 = (char *)v24 + 1;
        }

        while (v22 != v24);
        uint64_t v66 = [obj countByEnumeratingWithState:&v110 objects:v120 count:16];
        uint64_t v22 = v66;
      }

      while (v66);

      uint64_t v20 = v93;
      id v4 = v94;
      if ((v96 & 1) != 0)
      {
        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](self, "persistedState"));
        uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v67 persistedConfig]);
        [v68 persistState];

        -[MADAutoAssetStager _logPersistedConfigSet:message:]( self,  "_logPersistedConfigSet:message:",  @"_persistRebuildTrackingNewHandedOffDescriptors",  @"encountered staged descriptors");
      }
    }

    else
    {
    }
  }

  if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v4,  @"ResumeRunningTargetVersion") & 1) != 0 || +[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v4,  @"ResumePromotingAllStaged"))
  {
    uint64_t v69 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v106 = 0u;
    v107 = 0u;
    v108 = 0u;
    v109 = 0u;
    uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager successfullyStaged](self, "successfullyStaged"));
    uint64_t v71 = [v70 countByEnumeratingWithState:&v106 objects:v115 count:16];
    if (v71)
    {
      id v72 = v71;
      v73 = *(void *)v107;
      do
      {
        for (i = 0LL; i != v72; i = (char *)i + 1)
        {
          if (*(void *)v107 != v73) {
            objc_enumerationMutation(v70);
          }
          id v75 = *(void *)(*((void *)&v106 + 1) + 8LL * (void)i);
          id v76 = objc_autoreleasePoolPush();
          id v77 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager successfullyStaged](self, "successfullyStaged"));
          v78 = [v77 safeObjectForKey:v75 ofClass:objc_opt_class(MADAutoAssetDescriptor)];
          v79 = (void *)objc_claimAutoreleasedReturnValue(v78);

          if (v79) {
            -[NSMutableArray addObject:](v69, "addObject:", v79);
          }

          objc_autoreleasePoolPop(v76);
        }

        id v72 = [v70 countByEnumeratingWithState:&v106 objects:v115 count:16];
      }

      while (v72);
    }

    if (-[NSMutableArray count](v69, "count"))
    {
      v104 = 0u;
      v105 = 0u;
      v102 = 0u;
      v103 = 0u;
      v80 = v69;
      v81 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v80,  "countByEnumeratingWithState:objects:count:",  &v102,  v114,  16LL);
      if (v81)
      {
        uint64_t v82 = v81;
        id v83 = *(void *)v103;
        do
        {
          for (j = 0LL; j != v82; j = (char *)j + 1)
          {
            if (*(void *)v103 != v83) {
              objc_enumerationMutation(v80);
            }
            id v85 = *(void *)(*((void *)&v102 + 1) + 8LL * (void)j);
            __int128 v86 = objc_autoreleasePoolPush();
            -[MADAutoAssetStager _removeDescriptorFromSuccessfullyStaged:message:]( self,  "_removeDescriptorFromSuccessfullyStaged:message:",  v85,  @"NEW-OS-PROMOTION");
            objc_autoreleasePoolPop(v86);
          }

          uint64_t v82 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v80,  "countByEnumeratingWithState:objects:count:",  &v102,  v114,  16LL);
        }

        while (v82);
      }

      __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
      uint64_t v69 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v87 oslog]);

      id v4 = v94;
      if (os_log_type_enabled((os_log_t)v69, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
        __int128 v89 = -[NSMutableArray count](v80, "count");
        *(_DWORD *)buf = 138543618;
        v117 = v88;
        v118 = 2048;
        v119 = v89;
        _os_log_impl( &dword_0,  (os_log_t)v69,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[AUTO-STAGER] {_persistRebuildTrackingNewHandedOffDescriptors} promoted descriptor count:%ld",  buf,  0x16u);
      }
    }

    else
    {
      v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
      v91 = (void *)objc_claimAutoreleasedReturnValue([v90 diag]);
      [v91 trackAnomaly:@"AUTO-STAGER" forReason:@"{_persistRebuildTrackingNewHandedOffDescriptors} | should have asset(s) to be promoted yet none to hand off to auto-control-manager" withResult:6111 withError:0];

      v80 = 0LL;
      id v4 = v94;
    }

    uint64_t v20 = v93;
  }

  else
  {
    v80 = 0LL;
  }

  return v80;
}
}

  return v8;
}

  return v29;
}

LABEL_18:
  id v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v37, "logger"));
  id v30 = (os_log_s *)objc_claimAutoreleasedReturnValue([v34 oslog]);

  uint64_t v31 = v38;
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v37, "_updateLatestSummary"));
    *(_DWORD *)buf = 138544386;
    v47 = v35;
    v48 = 2114;
    unsigned __int8 v49 = v38;
    v50 = 2114;
    v51 = v10;
    uint64_t v52 = 2114;
    uint64_t v53 = v40;
    uint64_t v54 = 2114;
    uint64_t v55 = v39;
    _os_log_impl( &dword_0,  v30,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@:_latestDownloadedDescriptor} no match on downloaded descriptor | assetType:%{public}@, as setSpecifier:%{public}@, assetVersion:%{public}@",  buf,  0x34u);
  }

  uint64_t v21 = 0LL;
LABEL_21:

  return v21;
}

        objc_autoreleasePoolPop(v17);
        uint64_t v14 = (char *)v14 + 1;
      }

      while (v51 != v14);
      uint64_t v39 = [obj countByEnumeratingWithState:&v57 objects:v62 count:16];
      v51 = v39;
    }

    while (v39);
  }

  uint64_t v55 = 0u;
  v56 = 0u;
  uint64_t v53 = 0u;
  uint64_t v54 = 0u;
  uint64_t v40 = v47;
  v41 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v40,  "countByEnumeratingWithState:objects:count:",  &v53,  v61,  16LL);
  if (v41)
  {
    uint64_t v42 = v41;
    uint64_t v43 = *(void *)v54;
    do
    {
      for (i = 0LL; i != v42; i = (char *)i + 1)
      {
        if (*(void *)v54 != v43) {
          objc_enumerationMutation(v40);
        }
        -[MADAutoAssetControlManager atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:]( self,  "atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:",  @"atomicInstanceRemovedSetJob",  *(void *)(*((void *)&v53 + 1) + 8LL * (void)i),  v45,  a5);
      }

      uint64_t v42 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v40,  "countByEnumeratingWithState:objects:count:",  &v53,  v61,  16LL);
    }

    while (v42);
  }
}

          objc_autoreleasePoolPop(v24);
          uint64_t v22 = (char *)v22 + 1;
        }

        while (v18 != v22);
        uint64_t v18 = [v16 countByEnumeratingWithState:&v91 objects:v115 count:16];
        if (!v18)
        {
          uint64_t v15 = v78;
          break;
        }
      }
    }

    uint64_t v58 = @"missing";
LABEL_37:

    uint64_t v57 = v82;
LABEL_38:
    uint64_t v59 = v81;
    goto LABEL_53;
  }

  if (!v10)
  {
    v101 = 0u;
    v102 = 0u;
    v99 = 0u;
    v100 = 0u;
    v80 = v14;
    uint64_t v60 = v14;
    v61 = [v60 countByEnumeratingWithState:&v99 objects:v117 count:16];
    if (v61)
    {
      v62 = v61;
      id v63 = 0LL;
      uint64_t v64 = *(void *)v100;
      do
      {
        for (i = 0LL; i != v62; i = (char *)i + 1)
        {
          if (*(void *)v100 != v64) {
            objc_enumerationMutation(v60);
          }
          uint64_t v66 = *(void *)(*((void *)&v99 + 1) + 8LL * (void)i);
          uint64_t v67 = objc_autoreleasePoolPush();
          uint64_t v68 = [v60 safeObjectForKey:v66 ofClass:objc_opt_class(MADAutoAssetDescriptor)];
          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(v68);
          uint64_t v70 = v69;
          if (v69)
          {
            uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v69 assetType]);
            id v72 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v71, v90);

            v63 += v72;
          }

          objc_autoreleasePoolPop(v67);
        }

        v62 = [v60 countByEnumeratingWithState:&v99 objects:v117 count:16];
      }

      while (v62);
    }

    else
    {
      id v63 = 0LL;
    }

    uint64_t v58 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"descriptorsOfAssetType:%ld",  v63);
    uint64_t v57 = v82;
    uint64_t v15 = v80;
    goto LABEL_38;
  }

  id v84 = -[NSMutableString initWithString:]( objc_alloc(&OBJC_CLASS___NSMutableString),  "initWithString:",  @"versionsOfSpecifier:");
  v95 = 0u;
  v96 = 0u;
  v97 = 0u;
  v98 = 0u;
  uint64_t v37 = v15;
  uint64_t v38 = [v37 countByEnumeratingWithState:&v95 objects:v116 count:16];
  if (!v38)
  {

    uint64_t v58 = @"descriptorsOfAssetType(missing)";
    uint64_t v57 = v82;
    goto LABEL_52;
  }

  uint64_t v39 = v38;
  v79 = v15;
  __int128 v86 = 0;
  uint64_t v40 = *(void *)v96;
  v41 = &MobileAssetKeyManager__metaData.ivars;
  uint64_t v42 = &MobileAssetKeyManager__metaData.ivars;
  do
  {
    uint64_t v43 = 0LL;
    __int128 v88 = v39;
    do
    {
      if (*(void *)v96 != v40) {
        objc_enumerationMutation(v37);
      }
      uint64_t v44 = *(void *)(*((void *)&v95 + 1) + 8LL * (void)v43);
      uint64_t v45 = objc_autoreleasePoolPush();
      uint64_t v46 = [v37 safeObjectForKey:v44 ofClass:objc_opt_class(v41[223])];
      v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
      v48 = v47;
      if (v47)
      {
        unsigned __int8 v49 = v42[155];
        v50 = (void *)objc_claimAutoreleasedReturnValue([v47 assetType]);
        if (-[__objc2_ivar_list stringIsEqual:to:](v49, "stringIsEqual:to:", v50, v90))
        {
          v51 = v40;
          uint64_t v52 = v41;
          uint64_t v53 = v42;
          uint64_t v54 = v42[155];
          uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v48 assetSpecifier]);
          LODWORD(v54) = -[__objc2_ivar_list stringIsEqual:to:](v54, "stringIsEqual:to:", v55, v89);

          if (!(_DWORD)v54)
          {
            uint64_t v42 = v53;
            v41 = v52;
            uint64_t v40 = v51;
            uint64_t v39 = v88;
            goto LABEL_33;
          }

          v56 = objc_claimAutoreleasedReturnValue([v48 assetVersion]);
          v50 = (void *)v56;
          if ((v86 & 1) != 0) {
            -[NSMutableString appendFormat:](v84, "appendFormat:", @",%@", v56);
          }
          else {
            -[NSMutableString appendString:](v84, "appendString:", v56);
          }
          __int128 v86 = 1;
          uint64_t v42 = v53;
          v41 = v52;
          uint64_t v40 = v51;
          uint64_t v39 = v88;
        }
      }

    -[MADAutoAssetControlManager _logSetDescriptorEntries:forSetDescriptor:]( v43,  "_logSetDescriptorEntries:forSetDescriptor:",  v30,  v20);
    uint64_t v17 = v44;
    uint64_t v16 = v45;
    goto LABEL_15;
  }

  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v37 diag]);
  uint64_t v39 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v20 summary]);
  id v30 = v46;
  v41 = -[NSString initWithFormat:]( v39,  "initWithFormat:",  @"{%@:_logPersistedSetDescriptor} %@:%@ | no persistedEntryID | %@ | jobUUID:%@ | setDescriptor:%@",  v46,  v16,  v17,  v21,  v19,  v40);
  [v38 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v41 withResult:6110 withError:0];

  uint64_t v29 = v47;
LABEL_15:
}

      uint64_t v7 = v17;
    }
  }

  else
  {
    LOBYTE(v10) = 1;
  }

  return (char)v10;
}
  }

  else
  {
    LOBYTE(v10) = 1;
  }

  return (char)v10;
}
  }

  else
  {
    LOBYTE(v10) = 1;
  }

  return (char)v10;
}

  return v5;
}

  if (v10 == [v5 count])
  {
    uint64_t v35 = @"Number of Directories Migrated";
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v10));
    uint64_t v36 = v15;
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v36,  &v35,  1LL));
    [v16 writeToFile:@"/private/var/MobileSoftwareUpdate/.MACDMigrated.plist" atomically:1];

    [v3 setTaskCompleted];
    uint64_t v17 = 0LL;
  }

  else
  {
    uint64_t v25 = 0LL;
    uint64_t v18 = [v3 setTaskExpiredWithRetryAfter:&v25 error:0.0];
    uint64_t v19 = (const __CFString *)v25;
    uint64_t v17 = (__CFString *)v19;
    if ((v18 & 1) == 0)
    {
      uint64_t v24 = @"Unknown";
      if (v19) {
        uint64_t v24 = v19;
      }
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleCacheDeleteMigration:]",  @"Failed to expire task with error: %@",  v20,  v21,  v22,  v23,  (uint64_t)v24);
      [v3 setTaskCompleted];
    }
  }

  _Block_object_dispose(&v31, 8);
}

    uint64_t v21 = 8LL;
    goto LABEL_15;
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager purgeCatalogs:and:assetTypesList:clientName:]_block_invoke_2",  @"%@ unable to completely purge all catalogs for %@ with purpose: %@",  v17,  v18,  v19,  v20,  *(void *)(a1 + 48));
  if (!*(_BYTE *)(a1 + 80)) {
    goto LABEL_14;
  }
  uint64_t v21 = 5LL;
LABEL_15:
  sendClientResponse(*(void **)(a1 + 64), *(void **)(a1 + 72), v21);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager purgeCatalogs:and:assetTypesList:clientName:]_block_invoke_2",  @"[CONTROL_MANAGER_ASSET_QUEUE] {purgeCatalogs} ...purging catalogs",  v22,  v23,  v24,  v25,  v27);
}

  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v25));
  AssetsAtPath = getAssetsAtPath(v43);
  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(AssetsAtPath);
  if (v45)
  {
    uint64_t v71 = v43;
    id v72 = v22;
    v73 = v25;
    uint64_t v74 = v31;
    id v75 = a1;
    v81 = 0u;
    uint64_t v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    id obj = v45;
    v50 = [obj countByEnumeratingWithState:&v79 objects:v84 count:16];
    if (v50)
    {
      v51 = v50;
      uint64_t v52 = 0LL;
      id v76 = 0LL;
      uint64_t v53 = 0LL;
      uint64_t v54 = *(void *)v80;
      while (2)
      {
        for (i = 0LL; i != v51; i = (char *)i + 1)
        {
          if (*(void *)v80 != v54) {
            objc_enumerationMutation(obj);
          }
          v56 = *(void **)(*((void *)&v79 + 1) + 8LL * (void)i);
          uint64_t v57 = objc_autoreleasePoolPush();
          if (v56)
          {
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v56 lastPathComponent]);

            if (v35)
            {
              uint64_t v58 = v28;
              uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v28 stringByAppendingPathComponent:v35]);

              if ([v77 fileExistsAtPath:v33])
              {
                id v63 = @"Skipping asset: %@ as it already exists";
              }

              else
              {
                id v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  v33,  1LL));

                if (copyTargetToDirectory(v56, v34))
                {
                  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleMigrateAssetsRequest:using:and:]_block_invoke",  @"Failed to move asset: %@ in migration",  v59,  v60,  v61,  v62,  (uint64_t)v56);
                  objc_autoreleasePoolPop(v57);

                  uint64_t v36 = 2LL;
                  goto LABEL_36;
                }

                id v63 = @"Moved asset: %@ in migration";
                id v76 = v34;
              }

              _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleMigrateAssetsRequest:using:and:]_block_invoke",  v63,  v59,  v60,  v61,  v62,  (uint64_t)v56);
              uint64_t v52 = v33;
              uint64_t v53 = v35;
              uint64_t v28 = v58;
            }

            else
            {
              uint64_t v53 = 0LL;
            }
          }

          objc_autoreleasePoolPop(v57);
        }

        v51 = [obj countByEnumeratingWithState:&v79 objects:v84 count:16];
        if (v51) {
          continue;
        }
        break;
      }
    }

    else
    {
      uint64_t v52 = 0LL;
      id v76 = 0LL;
      uint64_t v53 = 0LL;
    }

    uint64_t v36 = 0LL;
    uint64_t v33 = v52;
    id v34 = v76;
    uint64_t v35 = v53;
LABEL_36:
    uint64_t v31 = v74;
    a1 = v75;
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleMigrateAssetsRequest:using:and:]_block_invoke",  @"Migration skipped due to not having a V1 assets directory",  v46,  v47,  v48,  v49,  v70);

    uint64_t v33 = 0LL;
    id v34 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = 0LL;
  }

  if (v13) {
    goto LABEL_41;
  }
  if ((v8 & 0x80000) == 0) {
    goto LABEL_33;
  }
LABEL_18:
  size_t length = (unint64_t)xpc_dictionary_get_double(v10, "stExtractorLength");
  if (!length) {
    goto LABEL_33;
  }
  data = xpc_dictionary_get_data(v10, "stExtractor", &length);
  if (!data)
  {
    uint64_t v13 = @"Failed to read extractor bytes from client request message";
    goto LABEL_41;
  }

  uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", data, length));
  if (!v21)
  {
    uint64_t v13 = @"Failed to read extractor data from client request message";
    goto LABEL_41;
  }

  uint64_t v22 = (void *)v21;
  uint64_t v38 = 0LL;
  uint64_t v23 = -[NSKeyedUnarchiver initForReadingFromData:error:]( objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver),  "initForReadingFromData:error:",  v21,  &v38);
  uint64_t v24 = v38;
  if (v24 || !v23)
  {
    -[NSKeyedUnarchiver finishDecoding](v23, "finishDecoding");
    uint64_t v13 = v24
        ? (__CFString *)-[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to decode extractor data with error:%@",  v24)
        : @"Failed to create unarchived extractor data";
  }

  else
  {
    uint64_t v25 = extractorDecodeClasses();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
    id v27 = (void *)objc_claimAutoreleasedReturnValue( -[NSKeyedUnarchiver decodeObjectOfClasses:forKey:]( v23,  "decodeObjectOfClasses:forKey:",  v26,  NSKeyedArchiveRootObjectKey));

    -[NSKeyedUnarchiver finishDecoding](v23, "finishDecoding");
    if (v27)
    {
      [v11 associateClientExtractorData:v22 ofLength:length];
      uint64_t v28 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"Using client-extractor (of %lld bytes)",  [v11 clientExtractorLen]);
      +[MADActivityManager noticeForActivity:reason:]( &OBJC_CLASS___MADActivityManager,  "noticeForActivity:reason:",  v12,  v28);

      [v12 extendLogLeader:@"client-extractor" withValue:@"YES"];
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = @"Failed to create unarchived extractor data";
    }

    uint64_t v24 = 0LL;
  }

  if (!v13) {
    goto LABEL_33;
  }
LABEL_41:

  return v13;
}

    uint64_t v16 = 0LL;
    goto LABEL_24;
  }

  if (!a5) {
    goto LABEL_14;
  }
  uint64_t v18 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to get key:%s (length:%lld bytes too small)",  a3,  0LL);
LABEL_13:
  uint64_t v16 = 0LL;
  *a5 = v18;
LABEL_24:

  return v16;
}

        __break(1u);
LABEL_15:
        __break(1u);
        goto LABEL_16;
      }
    }
  }

  uint64_t v7 = a4 + result;
  if (!__OFADD__(a4, result))
  {
    if (v5 >= v7) {
      goto LABEL_8;
    }
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  id v10 = a5 << ((8 - v7) & 0x38);
  else {
    LOBYTE(v_Block_object_dispose(va, 8) = v10;
  }
LABEL_11:
  *a6 = v8;
  return nullsub_1;
}

    uint64_t v35 = v56;
    result = swift_beginAccess(v56 + 4, v55, 0LL, 0LL);
    if (*((void *)v35 + 2) == v40)
    {
      *uint64_t v39 = v35;
      return result;
    }

    __break(1u);
  }

  LODWORD(v3_Block_object_dispose(va, 8) = 0;
  uint64_t v37 = (int **)&dword_10;
  result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD000000000000016LL,  0x80000000003059D0LL,  "CryptoKit_Static/ANSIx963.swift",  31LL,  2LL);
  __break(1u);
  return result;
}

      __break(1u);
      return result;
    }

    __break(1u);
    goto LABEL_14;
  }

  return result;
}

          uint64_t v9 = __OFADD__(v7++, 1LL);
          if (v9) {
            goto LABEL_27;
          }
        }

        uint64_t v9 = __OFADD__(v10++, 1LL);
        if (v9) {
          goto LABEL_26;
        }
      }

      goto LABEL_25;
    }

    uint64_t v9 = __OFADD__(v7++, 1LL);
  }

  while (!v9);
  __break(1u);
LABEL_9:
  swift_release(v4);
  id v10 = *(void *)(v4 + 16);
  uint64_t v7 = v10;
  return sub_23C3B4(v7, v10);
}

  __break(1u);
  return result;
}

id getAssetsAtPath(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( [v2 contentsOfDirectoryAtURL:v1 includingPropertiesForKeys:&__NSArray0__struct options:0 error:0]);

  id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"pathExtension='asset'"));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 filteredArrayUsingPredicate:v4]);

  return v5;
}

id getPurposeDirectoriesAtPath(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( [v2 contentsOfDirectoryAtURL:v1 includingPropertiesForKeys:&__NSArray0__struct options:0 error:0]);

  id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"lastPathComponent BEGINSWITH 'purpose_'"));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 filteredArrayUsingPredicate:v4]);

  return v5;
}

void finishPartiallyPurgedAssets(void *a1, unsigned int a2, char a3)
{
  LOBYTE(v3) = a3;
  id v5 = a1;
  uint64_t v6 = v5;
  unsigned int v33 = a2;
  if ((a2 & 0x80000000) == 0)
  {
    if ([v5 hasSuffix:@".purged"])
    {
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      id v39 = 0LL;
      unsigned __int8 v8 = [v7 removeItemAtPath:v6 error:&v39];
      id v9 = v39;

      if ((v8 & 1) != 0)
      {
        _MobileAssetLog( 0LL,  6,  (uint64_t)"finishPartiallyPurgedAssets",  @"{finishPartiallyPurgedAssets} successful purged cleanup | path:%@ | depth:%d",  v10,  v11,  v12,  v13,  (uint64_t)v6);
      }

      else
      {
        id v30 = (void *)objc_claimAutoreleasedReturnValue([v9 checkedSummary]);
        _MobileAssetLog( 0LL,  3,  (uint64_t)"finishPartiallyPurgedAssets",  @"{finishPartiallyPurgedAssets} unable to finish purged cleanup | path:%@ | depth:%d | error:%@\n%@",  v26,  v27,  v28,  v29,  (uint64_t)v6);
      }

id getPathToAssetWithPurpose(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  uint64_t v11 = 0LL;
  if (!v7 || !v8)
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    goto LABEL_14;
  }

  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  if (v9)
  {
    if ((objc_opt_respondsToSelector(v7, "stringByAppendingPathComponent:") & 1) != 0)
    {
      id v21 = normalizedAssetType((uint64_t)v8, v14, v15, v16, v17, v18, v19, v20);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v21);
      if (v12)
      {
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v7 stringByAppendingPathComponent:v12]);
        if (v10)
        {
          id v22 = purposeDirectoryName(v10);
          unsigned int v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
          uint64_t v24 = objc_claimAutoreleasedReturnValue([v13 stringByAppendingPathComponent:v23]);

          uint64_t v13 = (void *)v24;
        }

        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v13));
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  v9,  @"asset"));
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v25 URLByAppendingPathComponent:v26]);

        if (_MAPreferencesIsVerboseLoggingEnabled()) {
          _MobileAssetLog( 0LL,  7,  (uint64_t)"getPathToAssetWithPurpose",  @"URL to asset: %@",  v27,  v28,  v29,  v30,  (uint64_t)v11);
        }
        goto LABEL_14;
      }

      uint64_t v11 = 0LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
    }

    uint64_t v13 = 0LL;
  }

__CFString *getAssetIdFromDict(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  0LL));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 keyEnumerator]);
  uint64_t v7 = objc_claimAutoreleasedReturnValue([v6 nextObject]);
  if (v7)
  {
    id v8 = (void *)v7;
    do
    {
      if (isAttributePartOfAssetIdHash(v8))
      {
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v8]);
        -[__CFString setObject:forKey:](v5, "setObject:forKey:", v9, v8);
      }

      uint64_t v10 = objc_claimAutoreleasedReturnValue([v6 nextObject]);

      id v8 = (void *)v10;
    }

    while (v10);
  }

  uint64_t v11 = (__CFString *)_MobileAssetHashAssetData((uint64_t)kCFAllocatorDefault, v3, v5);

  return v11;
}

id isAttributePartOfAssetIdHash(void *a1)
{
  id v1 = a1;
  if (![v1 hasPrefix:@"_"]
    || ([v1 isEqualToString:@"_ContentVersion"] & 1) != 0
    || ([v1 isEqualToString:@"_CompatibilityVersion"] & 1) != 0)
  {
    id v2 = &dword_0 + 1;
  }

  else
  {
    id v2 = [v1 isEqualToString:@"_MasteredVersion"];
  }

  return v2;
}

CFStringRef _MobileAssetHashAssetData(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  return _MobileAssetHashAssetDataOptCompatibility(a1, a2, a3, 1LL);
}

CFStringRef _MobileAssetHashAssetDataOptCompatibility( uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t v6 = _hashCFType(a2, a4);
  if (!v6)
  {
    id v8 = 0LL;
    goto LABEL_7;
  }

  uint64_t v7 = _hashCFType(a3, a4);
  id v8 = v7;
  if (!v7)
  {
LABEL_7:
    CFStringRef v10 = 0LL;
    goto LABEL_8;
  }

  for (uint64_t i = 0LL; i != 20; ++i)
    v6[i] ^= v7[i];
  CFStringRef v10 = _hashToCFString(v6);
LABEL_8:
  free(v6);
  free(v8);
  return v10;
}

unsigned __int8 *_hashCFType(const __CFString *a1, uint64_t a2)
{
  if (!a1)
  {
    if ((a2 & 1) == 0)
    {
      CFIndex Length = CFStringGetLength(@"NULL");
      uint64_t v14 = @"NULL";
      uint64_t v15 = 0LL;
      return _hashCFStringOfLength(v14, Length, v15, v9, v10, v11, v12, v13);
    }

    return 0LL;
  }

  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFBooleanGetTypeID())
  {
    id v5 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
    Boolean Value = CFBooleanGetValue((CFBooleanRef)a1);
    p_Boolean Value = &Value;
    CC_LONG v7 = 1;
LABEL_12:
    CC_SHA1(p_Value, v7, v5);
    return v5;
  }

  if (v4 == CFStringGetTypeID())
  {
    CFIndex Length = CFStringGetLength(a1);
    uint64_t v14 = a1;
    uint64_t v15 = a2;
    return _hashCFStringOfLength(v14, Length, v15, v9, v10, v11, v12, v13);
  }

  if (v4 == CFDateGetTypeID())
  {
    id v5 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
    CFAbsoluteTime data = CFDateGetAbsoluteTime((CFDateRef)a1);
    p_Boolean Value = (Boolean *)&data;
    CC_LONG v7 = 8;
    goto LABEL_12;
  }

  if (v4 == CFDataGetTypeID())
  {
    CFIndex v17 = CFDataGetLength((CFDataRef)a1);
    return _hashCFDataOfLength((const __CFData *)a1, v17, v18, v19, v20, v21, v22, v23);
  }

  if (v4 != CFArrayGetTypeID())
  {
    if (v4 == CFDictionaryGetTypeID()) {
      return (unsigned __int8 *)_hashCFDictionary((const __CFDictionary *)a1, a2);
    }
    if (v4 == CFNumberGetTypeID()) {
      return _hashCFNumber((const __CFNumber *)a1);
    }
    return 0LL;
  }

  if ((_DWORD)a2) {
    return _hashCFArrayLegacy((const __CFArray *)a1);
  }
  else {
    return _hashCFArrayNoLegacy((const __CFArray *)a1);
  }
}

unsigned __int8 *_hashCFStringOfLength( const __CFString *a1, CFIndex length, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (length >= 0x7FFFFFFF) {
    _hashCFStringOfLength_cold_1((uint64_t)a1, length, a3, a4, a5, a6, a7, a8);
  }
  char v8 = a3;
  if ((a3 & 1) == 0)
  {
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(length, 0x8000100u);
    size_t length = MaximumSizeForEncoding;
    if (MaximumSizeForEncoding >= 0x7FFFFFFF) {
      _hashCFStringOfLength_cold_3(MaximumSizeForEncoding, MaximumSizeForEncoding, v11, v12, v13, v14, v15, v16);
    }
  }

  CFIndex v17 = length + 1;
  uint64_t v18 = (char *)calloc(1uLL, length + 1);
  uint64_t CString = CFStringGetCString(a1, v18, v17, 0x8000100u);
  if (!(_DWORD)CString && (v8 & 1) == 0) {
    _hashCFStringOfLength_cold_2(CString, v20, v21, v22, v23, v24, v25, v26);
  }
  uint64_t v27 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
  CC_SHA1(v18, v17, v27);
  free(v18);
  return v27;
}

void *_hashCFDictionary(const __CFDictionary *a1, uint64_t a2)
{
  if (CFDictionaryGetCount(a1) || (a2 & 1) == 0)
  {
    id v5 = (void *)_hashCFType(@"dictionary", a2);
    int64_t Count = CFDictionaryGetCount(a1);
    int64_t valuePtr = Count;
    CC_LONG v7 = (const void **)calloc(Count, 8uLL);
    if (!v7)
    {
      if (v5) {
        free(v5);
      }
      return 0LL;
    }

    char v8 = v7;
    CFDictionaryGetKeysAndValues(a1, v7, 0LL);
    if (Count < 1)
    {
LABEL_16:
      if ((a2 & 1) != 0)
      {
        CFTypeID v4 = v5;
LABEL_33:
        free(v8);
        return v4;
      }

      CFIndex v17 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
      uint64_t v18 = _hashCFNumber(v17);
      if (v17) {
        CFRelease(v17);
      }
      if (v5 && v18)
      {
        CC_SHA1_Init(&v23);
        CC_SHA1_Update(&v23, v5, 0x14u);
        CC_SHA1_Update(&v23, v18, 0x14u);
        CC_SHA1_Final((unsigned __int8 *)v5, &v23);
        uint64_t v19 = v5;
      }

      else
      {
        uint64_t v19 = v5;
        CFTypeID v4 = v5;
        if (!v18) {
          goto LABEL_33;
        }
      }
    }

    else
    {
      uint64_t v9 = 0LL;
      while (1)
      {
        uint64_t v10 = (void *)_hashCFType(v8[v9], a2);
        Boolean Value = CFDictionaryGetValue(a1, v8[v9]);
        uint64_t v12 = (void *)_hashCFType(Value, a2);
        uint64_t v13 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
        uint64_t v14 = v13;
        if (!v13) {
          break;
        }
        if (!v10 || v12 == 0LL) {
          break;
        }
        CC_SHA1_Init(&c);
        CC_SHA1_Update(&c, v10, 0x14u);
        CC_SHA1_Update(&c, v12, 0x14u);
        CC_SHA1_Final(v14, &c);
        if (v5)
        {
          for (uint64_t i = 0LL; i != 20; ++i)
            *((_BYTE *)v5 + i) ^= v14[i];
        }

        free(v14);
        free(v10);
        free(v12);
        if (Count <= ++v9) {
          goto LABEL_16;
        }
      }

      if (v13) {
        free(v13);
      }
      if (v10) {
        free(v10);
      }
      if (v12) {
        free(v12);
      }
      uint64_t v19 = 0LL;
      CFTypeID v4 = 0LL;
      uint64_t v18 = (unsigned __int8 *)v5;
      if (!v5) {
        goto LABEL_33;
      }
    }

    free(v18);
    CFTypeID v4 = v19;
    goto LABEL_33;
  }

  return 0LL;
}

_BYTE *_hashCFArrayLegacy(const __CFArray *a1)
{
  if (!CFArrayGetCount(a1)) {
    return 0LL;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    CFIndex v4 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v4);
      v17.location = 0LL;
      v17.size_t length = v3;
      if (CFArrayGetCountOfValue(a1, v17, ValueAtIndex) >= 2) {
        break;
      }
      if (v3 == ++v4) {
        goto LABEL_6;
      }
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"_hashCFArrayLegacy",  @"Failing to hash due to duplicate array entries",  v6,  v7,  v8,  v9,  v16);
    return 0LL;
  }

LABEL_6:
  uint64_t v10 = (_BYTE *)_hashCFType(@"array", 1LL);
  if (CFArrayGetCount(a1) >= 1)
  {
    CFIndex v11 = 0LL;
    while (1)
    {
      uint64_t v12 = CFArrayGetValueAtIndex(a1, v11);
      uint64_t v13 = (_BYTE *)_hashCFType(v12, 1LL);
      if (!v13) {
        break;
      }
      if (v10)
      {
        for (uint64_t i = 0LL; i != 20; ++i)
          v10[i] ^= v13[i];
      }

      free(v13);
      if (CFArrayGetCount(a1) <= ++v11) {
        return v10;
      }
    }

    free(v10);
    return 0LL;
  }

  return v10;
}

      CC_SHA1_CTX v23 = (NSString *)v22;

      uint64_t v21 = v23;
      goto LABEL_33;
    }

    if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v10,  @"MA-AUTO-STAGE:DOWNLOAD_ALL") & 1) == 0 && (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v10,  @"MA-AUTO-STAGE:PURGE_ALL") & 1) == 0 && (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v10,  @"MA-AUTO-STAGE:ERASE_ALL") & 1) == 0)
    {
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v67 diag]);
      uint64_t v69 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"{%@} staging-client-request received of unknown messageName:%@",  v95,  v10);
      [v68 trackAnomaly:@"AUTO-STAGER" forReason:v69 withResult:6106 withError:0];

      uint64_t v21 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"staging-client-request of unknown messageName:%@",  v10);
      -[MADAutoAssetStager _replyToStagingClient:replyingToRequest:withErrorCode:withUnderlyingError:withDescription:]( self,  "_replyToStagingClient:replyingToRequest:withErrorCode:withUnderlyingError:withDescription:",  v95,  v96,  6106LL,  0LL,  v21);
      goto LABEL_38;
    }
  }

  +[MADAutoAssetControlManager stagerCancelCurrentJob]( &OBJC_CLASS___MADAutoAssetControlManager,  "stagerCancelCurrentJob");
}
}
}
}

  if (v15)
  {
    uint64_t v16 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Failed to unmount and eject cryptex disk image: %@", v15));
    CFRange v17 = [v16 UTF8String];
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[SecureMobileAssetBundle unmount:]",  @"[SMA] %s",  v18,  v19,  v20,  v21,  (uint64_t)v17);

    if (a3) {
      *a3 = v15;
    }
  }

  return v15 == 0LL;
}
}

  return 0LL;
}

    uint64_t v13 = 1296000000000000LL;
    goto LABEL_7;
  }

  _MobileAssetLog( 0LL,  3,  (uint64_t)"markItemPurgeableWithUrgencyAndGarbageCollectionPolicy",  @"API MISUSE: markItemPurgeableWithUrgencyAndGarbageCollectionPolicy called with NeverCollected policy",  v8,  v9,  v10,  v11,  v16);
  started = 0LL;
LABEL_8:

  return started;
}
}
}

        goto LABEL_7;
      }

      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(-[MobileAssetKeyManager logger](self, "logger"));
      CFRange v17 = (os_log_s *)objc_claimAutoreleasedReturnValue([v25 oslog]);

      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        -[MobileAssetKeyManager decryptFileAtURL:iv:tag:cryptor:].cold.8();
      }
    }

    uint64_t v18 = 81;
    goto LABEL_6;
  }

  uint64_t v18 = *__error();
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MobileAssetKeyManager logger](self, "logger"));
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue([v19 oslog]);

  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = [v13 fileSystemRepresentation];
    uint64_t v22 = strerror(v18);
    -[MobileAssetKeyManager decryptFileAtURL:iv:tag:cryptor:].cold.1((uint64_t)v21, (uint64_t)v22, (uint64_t)v48);
  }

LABEL_12:
  return v18;
}

    update((uint64_t)a1, (uint64_t)__s);
    CFIndex v11 = 0LL;
    a1[6] = 1LL;
LABEL_7:
    cc_clear(a1[8] + 16LL, __s);
  }

  return v11;
}

  if (__OFSUB__(a5, a4))
  {
LABEL_26:
    __break(1u);
    goto LABEL_27;
  }

  if (a4 != a5)
  {
LABEL_27:
    __break(1u);
    goto LABEL_28;
  }

  return result;
}

unsigned __int8 *_hashCFNumber(const __CFNumber *a1)
{
  id v2 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
  CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
  else {
    size_t v3 = 4LL;
  }
  else {
    CFNumberType v4 = kCFNumberSInt64Type;
  }
  id v5 = calloc(1uLL, v3);
  CFNumberGetValue(a1, v4, v5);
  CC_SHA1(v5, v3, v2);
  free(v5);
  return v2;
}

CFStringRef _hashToCFString(unsigned __int8 *a1)
{
  return CFStringCreateWithCString(kCFAllocatorDefault, __str, 0x8000100u);
}

uint64_t __isPlatformVersionAtLeast(int a1, int a2, int a3, int a4)
{
  if (qword_3B1C60 == -1)
  {
    if (qword_3B1C68)
    {
LABEL_3:
      v10[0] = a1;
      v10[1] = (a2 << 16) | (a3 << 8) | a4;
      return _availability_version_check(1LL, v10);
    }
  }

  else
  {
    dispatch_once_f(&qword_3B1C60, 0LL, (dispatch_function_t)initializeAvailabilityCheck);
    if (qword_3B1C68) {
      goto LABEL_3;
    }
  }

  if (qword_3B1C58 == -1)
  {
    BOOL v9 = _MergedGlobals < a2;
    if (_MergedGlobals > a2) {
      return 1LL;
    }
  }

  else
  {
    dispatch_once_f(&qword_3B1C58, 0LL, (dispatch_function_t)compatibilityInitializeAvailabilityCheck);
    BOOL v9 = _MergedGlobals < a2;
    if (_MergedGlobals > a2) {
      return 1LL;
    }
  }

  if (v9) {
    return 0LL;
  }
  if (dword_3B1C4C > a3) {
    return 1LL;
  }
  return dword_3B1C4C >= a3 && dword_3B1C50 >= a4;
}

LABEL_25:
              size_t v3 = v42;
              BOOL v9 = v46;
              goto LABEL_29;
            }

            goto LABEL_29;
          }

          goto LABEL_28;
        }

        uint64_t v24 = objc_alloc(&OBJC_CLASS___MAAutoAssetSetEntry);
        uint64_t v25 = objc_opt_respondsToSelector( v24,  "initForAssetType:withAssetSpecifier:usingDecryptionKey:assetLockedInhibitsRemoval:");

        if ((v25 & 1) != 0)
        {
          uint64_t v26 = v3;
          uint64_t v27 = objc_opt_class(&OBJC_CLASS___NSArray);
          if ((objc_opt_isKindOfClass(v26, v27) & 1) != 0)
          {
            BOOL v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            uint64_t v28 = (char *)[v26 count];
            if ((uint64_t)v28 >= 1)
            {
              uint64_t v29 = v28;
              uint64_t v46 = v9;
              v48 = v26;
              uint64_t v42 = v3;
              uint64_t v30 = 0LL;
              uint64_t v45 = v28;
              do
              {
                id v31 = (void *)objc_claimAutoreleasedReturnValue([v26 objectAtIndex:v30]);
                if (v31)
                {
                  id v32 = objc_opt_class(p_ivars[157]);
                  if ((objc_opt_isKindOfClass(v31, v32) & 1) != 0)
                  {
                    unsigned int v33 = objc_alloc(&OBJC_CLASS___MANAutoAssetSetEntry);
                    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v31 assetSelector]);
                    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v34 assetType]);
                    __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v31 assetSelector]);
                    __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v36 assetSpecifier]);
                    id v38 = (void *)objc_claimAutoreleasedReturnValue([v31 assetSelector]);
                    id v39 = (void *)objc_claimAutoreleasedReturnValue([v38 downloadDecryptionKey]);
                    uint64_t v40 = -[MANAutoAssetSetEntry initForAssetType:withAssetSpecifier:usingDecryptionKey:assetLockedInhibitsRemoval:]( v33,  "initForAssetType:withAssetSpecifier:usingDecryptionKey:assetLockedInhibitsRemoval:",  v35,  v37,  v39,  [v31 assetLockedInhibitsRemoval]);

                    if (v40) {
                      -[NSMutableArray addObject:](v46, "addObject:", v40);
                    }

                    p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                    uint64_t v26 = v48;
                    uint64_t v29 = v45;
                  }
                }

                ++v30;
              }

              while (v29 != v30);
              goto LABEL_25;
            }

  if (-[MANAutoAssetSetInfoDesire checkWaitTimeoutSecs](self, "checkWaitTimeoutSecs") == -101
    && -[MANAutoAssetSetInfoDesire lockWaitTimeoutSecs](self, "lockWaitTimeoutSecs") == -101)
  {
    if (-[MANAutoAssetSetInfoDesire awaitDownloadingOfDiscovered](self, "awaitDownloadingOfDiscovered")) {
      uint64_t v16 = @"Y";
    }
    else {
      uint64_t v16 = @"N";
    }
    if (-[MANAutoAssetSetInfoDesire downloadProgressDesired](self, "downloadProgressDesired")) {
      CFRange v17 = @"Y";
    }
    else {
      CFRange v17 = @"N";
    }
    uint64_t v18 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@|awaitDowload:%@|progressDesired:%@",  v11,  v16,  v17,  v26,  v27);
  }

  else if (-[MANAutoAssetSetInfoDesire checkWaitTimeoutSecs](self, "checkWaitTimeoutSecs") == -101)
  {
    if (-[MANAutoAssetSetInfoDesire awaitDownloadingOfDiscovered](self, "awaitDownloadingOfDiscovered")) {
      uint64_t v19 = @"Y";
    }
    else {
      uint64_t v19 = @"N";
    }
    if (-[MANAutoAssetSetInfoDesire downloadProgressDesired](self, "downloadProgressDesired")) {
      uint64_t v20 = @"Y";
    }
    else {
      uint64_t v20 = @"N";
    }
    uint64_t v18 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@|awaitDowload:%@|lockSecs:%@,progressDesired:%@",  v11,  v19,  v13,  v20,  v27);
  }

  else
  {
    uint64_t v21 = -[MANAutoAssetSetInfoDesire lockWaitTimeoutSecs](self, "lockWaitTimeoutSecs");
    if (-[MANAutoAssetSetInfoDesire awaitDownloadingOfDiscovered](self, "awaitDownloadingOfDiscovered")) {
      uint64_t v22 = @"Y";
    }
    else {
      uint64_t v22 = @"N";
    }
    if (-[MANAutoAssetSetInfoDesire downloadProgressDesired](self, "downloadProgressDesired")) {
      CC_SHA1_CTX v23 = @"Y";
    }
    else {
      CC_SHA1_CTX v23 = @"N";
    }
    if (v21 == -101) {
      uint64_t v18 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@|awaitDowload:%@|checkSecs:%@,progressDesired:%@",  v11,  v22,  p_isa,  v23,  v27);
    }
    else {
      uint64_t v18 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@|awaitDowload:%@|checkSecs:%@,lockSecs:%@,progressDesired:%@",  v11,  v22,  p_isa,  v13,  v23);
    }
  }

  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v18);

  return v24;
}

    CFRange v17 = 0LL;
    goto LABEL_26;
  }

  v163 = (void *)objc_claimAutoreleasedReturnValue([v3 clientDomainName]);
  v162 = (void *)objc_claimAutoreleasedReturnValue([v3 assetSetIdentifier]);
  v141 = (void *)objc_claimAutoreleasedReturnValue([v3 configuredAssetEntries]);
  v161 = +[MASAutoAssetSetEntry newShimmedArrayToFramework:]( &OBJC_CLASS___MASAutoAssetSetEntry,  "newShimmedArrayToFramework:",  v141);
  v114 = objc_claimAutoreleasedReturnValue([v3 atomicInstancesDownloaded]);
  v132 = objc_claimAutoreleasedReturnValue([v3 catalogCachedAssetSetID]);
  v126 = objc_claimAutoreleasedReturnValue([v3 catalogDownloadedFromLive]);
  v160 = (id)objc_claimAutoreleasedReturnValue([v3 catalogLastTimeChecked]);
  v120 = objc_claimAutoreleasedReturnValue([v3 catalogPostedDate]);
  v155 = (void *)objc_claimAutoreleasedReturnValue([v3 newerAtomicInstanceDiscovered]);
  v142 = (id)objc_claimAutoreleasedReturnValue([v3 newerDiscoveredAtomicEntries]);
  v154 = +[MASAutoAssetSetAtomicEntry newShimmedArrayToFramework:]( &OBJC_CLASS___MASAutoAssetSetAtomicEntry,  "newShimmedArrayToFramework:");
  v158 = (id)objc_claimAutoreleasedReturnValue([v3 latestDownloadedAtomicInstance]);
  v140 = (void *)objc_claimAutoreleasedReturnValue([v3 latestDowloadedAtomicInstanceEntries]);
  v156 = +[MASAutoAssetSetAtomicEntry newShimmedArrayToFramework:]( &OBJC_CLASS___MASAutoAssetSetAtomicEntry,  "newShimmedArrayToFramework:");
  v149 = (void *)objc_claimAutoreleasedReturnValue([v3 downloadedCatalogCachedAssetSetID]);
  v152 = (id)objc_claimAutoreleasedReturnValue([v3 downloadedCatalogDownloadedFromLive]);
  v148 = (void *)objc_claimAutoreleasedReturnValue([v3 downloadedCatalogLastTimeChecked]);
  v150 = (id)objc_claimAutoreleasedReturnValue([v3 downloadedCatalogPostedDate]);
  v139 = (void *)objc_claimAutoreleasedReturnValue([v3 currentNotifications]);
  v146 = +[MASAutoAssetSetNotifications newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetNotifications,  "newShimmedToFramework:");
  v138 = (void *)objc_claimAutoreleasedReturnValue([v3 currentNeedPolicy]);
  v143 = +[MASAutoAssetSetPolicy newShimmedToFramework:](&OBJC_CLASS___MASAutoAssetSetPolicy, "newShimmedToFramework:");
  v111 = objc_claimAutoreleasedReturnValue([v3 schedulerPolicy]);
  v103 = +[MASAutoAssetSetPolicy newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetPolicy,  "newShimmedToFramework:",  v111);
  v109 = (void *)objc_claimAutoreleasedReturnValue([v3 stagerPolicy]);
  v91 = +[MASAutoAssetSetPolicy newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetPolicy,  "newShimmedToFramework:",  v109);
  v100 = [v3 haveReceivedLookupResponse];
  v97 = [v3 vendingAtomicInstanceForConfiguredEntries];
  v94 = [v3 downloadUserInitiated];
  v106 = (void *)objc_claimAutoreleasedReturnValue([v3 downloadProgress]);
  __int128 v89 = +[MASAutoAssetSetProgress newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetProgress,  "newShimmedToFramework:",  v106);
  uint64_t v8 = [v3 downloadedNetworkBytes];
  BOOL v9 = [v3 downloadedFilesystemBytes];
  __int128 v88 = (void *)objc_claimAutoreleasedReturnValue([v3 currentLockUsage]);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v3 selectorsForStaging]);
  CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue([v3 availableForUseError]);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v3 newerVersionError]);
  __int128 v86 = v8;
  BYTE2(v85) = v94;
  BYTE1(v85) = v97;
  LOBYTE(v85) = v100;
  uint64_t v14 = (void *)v114;
  uint64_t v13 = (void *)v120;
  uint64_t v16 = (void *)v126;
  uint64_t v15 = (void *)v132;
  CFRange v17 = objc_msgSend( v7,  "initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:withC atalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewe rAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloa dedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDow nloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:w ithSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:wit hDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withCurre ntLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:",  v163,  v162,  v161,  v114,  v132,  v126,  v160,  v120,  v155,  v154,  v158,  v156,  v149,  v152,  v148,  v150,  v146,  v143,  v103,  v91,  v85,  v89,  v86,  v9,  v88,  v10,  v11,  v12);

  uint64_t v18 = (void *)v111;
LABEL_17:

LABEL_18:
LABEL_26:

  return v17;
}
}

        objc_autoreleasePoolPop(v16);
      }

      uint64_t v12 = [v9 countByEnumeratingWithState:&v40 objects:v52 count:16];
      if (!v12) {
        goto LABEL_30;
      }
    }
  }

  id v38 = 0LL;
LABEL_29:
  uint64_t v13 = v36;
LABEL_30:

  return v38;
}

            uint64_t v13 = v44;
LABEL_26:
            __int128 v35 = v48;

            goto LABEL_29;
          }

          uint64_t v13 = v44;
        }

        else
        {
          id v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v32 oslog]);

          if (os_log_type_enabled((os_log_t)v20, OS_LOG_TYPE_ERROR))
          {
            unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543618;
            uint64_t v59 = v33;
            uint64_t v60 = 2114;
            v61 = v15;
            _os_log_error_impl( &dword_0,  (os_log_t)v20,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {newTargetLookupResultsForTargetTrainName} unable to retrieve target-lookup-results | entryID:%{public}@",  buf,  0x16u);
          }
        }

        __int128 v35 = v48;
LABEL_29:

        objc_autoreleasePoolPop(v35);
      }

      uint64_t v46 = [obj countByEnumeratingWithState:&v53 objects:v62 count:16];
      if (!v46)
      {
LABEL_31:

        uint64_t v12 = v39;
        p_super = v40;
        break;
      }
    }
  }

  if (-[NSMutableArray count](v9, "count", v39, v40))
  {
    __int128 v37 = v9;

    p_super = &v37->super;
  }

  return p_super;
}

    goto LABEL_26;
  }

  if (!v15)
  {
    CC_SHA1_CTX v23 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue([v23 oslog]);

    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v8 summary]);
      *(_DWORD *)buf = 138543874;
      __int128 v37 = v17;
      id v38 = 2114;
      id v39 = v22;
      uint64_t v40 = 2114;
      v41 = v13;
      uint64_t v24 = "{AUTO-LOOKUP-CACHE[%{public}@]:recordLookupResult:forSetConfiguration:} | by-set-configuration lookup-cache "
            "disabled | setConfiguration:%{public}@ | assetAudience:%{public}@";
LABEL_22:
      uint64_t v26 = v20;
      uint64_t v27 = 32;
      goto LABEL_23;
    }

    goto LABEL_25;
  }

  uint64_t v18 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v9 lookupCacheQueue]);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __77__MADAutoAssetLookupCache_recordLookupResult_forSetConfiguration_forStaging___block_invoke;
  block[3] = &unk_34E8C0;
  __int128 v35 = v5;
  uint64_t v29 = v9;
  uint64_t v30 = v7;
  id v31 = v8;
  id v32 = v13;
  unsigned int v33 = v17;
  __int128 v34 = v14;
  dispatch_sync(v18, block);

LABEL_26:
}

                  CFRange v17 = v45;
                }
              }

              v47 = [v17 countByEnumeratingWithState:&v52 objects:v61 count:16];
            }

            while (v47);
            self = v39;
            CFIndex v11 = v42;
            BOOL v9 = v43;
            uint64_t v14 = v37;
          }
        }

        goto LABEL_31;
      }

      self = v39;
      CFIndex v11 = v42;
      BOOL v9 = v43;
LABEL_32:

      objc_autoreleasePoolPop(v11);
      BOOL v9 = (char *)v9 + 1;
    }

    while (v9 != v41);
    __int128 v34 = [obj countByEnumeratingWithState:&v56 objects:v62 count:16];
    v41 = v34;
  }

  while (v34);
LABEL_38:

  return v44 & 1;
}

      goto LABEL_26;
    }
  }

  LOBYTE(v13) = 1;
LABEL_26:

  return (char)v13;
}

      objc_autoreleasePoolPop(v32);
      uint64_t v30 = (char *)v30 + 1;
    }

    while (v89 != v30);
    unsigned __int8 v49 = [obj countByEnumeratingWithState:&v99 objects:v104 count:16];
    __int128 v89 = v49;
  }

  while (v49);
LABEL_50:

  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  uint64_t v22 = v86;
  uint64_t v69 = -[os_log_s countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v94,  v103,  16LL);
  if (v69)
  {
    uint64_t v70 = v69;
    uint64_t v71 = *(void *)v95;
    do
    {
      for (uint64_t i = 0LL; i != v70; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v95 != v71) {
          objc_enumerationMutation(v22);
        }
        v73 = *(void *)(*((void *)&v94 + 1) + 8LL * (void)i);
        uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v10 autoAssetSetClientName]);
        id v75 =  +[MADAutoAssetLocker eliminateAllPreviousSetLocksByClient:forSetDescriptor:]( &OBJC_CLASS___MADAutoAssetLocker,  "eliminateAllPreviousSetLocksByClient:forSetDescriptor:",  v74,  v73);

        uint64_t v29 = v91;
        -[MADAutoAssetControlManager secureCheckUngraftAll:forSetDescriptorNoLongerLocked:]( v91,  "secureCheckUngraftAll:forSetDescriptorNoLongerLocked:",  @"handleSetClientEndAtomicLocksForClientRequest",  v73);
        -[MADAutoAssetControlManager _removeDownloadedSetDescriptorWithNewerDownloaded:fromLocation:]( v91,  "_removeDownloadedSetDescriptorWithNewerDownloaded:fromLocation:",  v73,  @"handleSetClientEndAtomicLocksForClientRequest");
      }

      uint64_t v70 = -[os_log_s countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v94,  v103,  16LL);
    }

    while (v70);
  }

  id v76 = v85;
  if (v85)
  {

    uint64_t v6 = v82;
    -[MADAutoAssetControlManager issueResponseForEventInfo:withAutoAssetError:fromAction:withDescription:]( v29,  "issueResponseForEventInfo:withAutoAssetError:fromAction:withDescription:",  v82,  v85,  @"handleSetClientEndAtomicLocksForClientRequest",  @"failed to end all locks due to SHORT-TERM locks");
    uint64_t v12 = v80;
    uint64_t v7 = v81;
    uint64_t v14 = v83;
    goto LABEL_62;
  }

  id v77 = (void *)objc_claimAutoreleasedReturnValue([v10 clientDomainName]);
  v78 = (void *)objc_claimAutoreleasedReturnValue([v10 assetSetIdentifier]);
  -[MADAutoAssetControlManager setLockUsageMapEliminateForClientDomain:forSetIdentifier:]( v29,  "setLockUsageMapEliminateForClientDomain:forSetIdentifier:",  v77,  v78);

  uint64_t v7 = v81;
  uint64_t v6 = v82;
  self = v29;
  uint64_t v12 = v80;
LABEL_61:
  uint64_t v14 = v83;

  -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v6,  0LL,  @"handleSetClientEndAtomicLocksForClientRequest",  @"Completed end of all atomic-locks of auto-asset-set for MA_END_ATOMIC_LOCKS_ALL_INSTANCES request");
  id v76 = (void *)objc_claimAutoreleasedReturnValue([v10 clientDomainName]);
  v79 = (void *)objc_claimAutoreleasedReturnValue([v10 assetSetIdentifier]);
  -[MADAutoAssetControlManager finishSetEliminateIfAwaitingUnlocked:forClientDomain:forAssetSetIdentifier:]( self,  "finishSetEliminateIfAwaitingUnlocked:forClientDomain:forAssetSetIdentifier:",  @"handleSetClientEndAtomicLocksForClientRequest",  v76,  v79);

LABEL_62:
LABEL_36:
}
}

LABEL_26:
  return v30;
}

  -[MADAutoAssetControlManager _logPersistedSetLookupResultTableOfContents:]( self,  "_logPersistedSetLookupResultTableOfContents:",  @"loadPersistedSetLookupResults");
}

      uint64_t v14 = v11;

      uint64_t v7 = v14;
      uint64_t v8 = v10;
LABEL_26:
    }

    if (v13) {
LABEL_23:
    }

    goto LABEL_25;
  }

  uint64_t v8 = 0LL;
LABEL_4:
  if (v7 && (v8 & 0x8000000000000000LL) == 0) {
    [v4 removeObjectAtIndex:v8];
  }
LABEL_8:

  return v7;
}
            }

            else
            {
              CFRange v17 = v57;
            }

            goto LABEL_27;
          }

          CFRange v17 = v57;
          self = v60;
          uint64_t v15 = v61;
        }

          CFRange v17 = (__CFString *)v23;
          uint64_t v14 = 0LL;
          goto LABEL_29;
        }

        CC_SHA1_CTX v23 = @"Client request cannot specify both assetType and assetTypesList";
      }

      else
      {
        CC_SHA1_CTX v23 = @"Invalid asset type list provided";
      }

      goto LABEL_25;
    }

    if (!v17) {
      goto LABEL_3;
    }
LABEL_21:
    uint64_t v14 = 0LL;
    goto LABEL_182;
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

  unsigned __int8 *v2 = v7;
  return result;
}

  __break(1u);
  return result;
}

LABEL_29:
            goto LABEL_27;
          }

  dispatch_semaphore_signal((dispatch_semaphore_t)self->SoftwareUpdateSSOCompletionSemaphore);
}

        v47 = 0LL;
        goto LABEL_30;
      }

      goto LABEL_26;
    }

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v15 clientRequestMessage]);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v28 message]);

    uint64_t v30 = [v29 safeObjectForKey:@"instance" ofClass:objc_opt_class(MAAutoAssetInfoInstance)];
    id v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
    id v32 = v31;
    if (!v31)
    {
LABEL_23:

      goto LABEL_24;
    }

    unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v31 clientAssetSelector]);
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v33 assetVersion]);
    if (v34)
    {
    }

    else
    {
      __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v32 clientAssetSelector]);
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v35 assetSpecifier]);
      uint64_t v53 = +[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v36,  @"MAAutoAsset-all-asset-specifiers");

      uint64_t v21 = (__CFString *)v54;
      uint64_t v24 = v15;

      if (v53)
      {
        __int128 v37 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
        id v38 = (id)objc_claimAutoreleasedReturnValue([v32 clientAssetSelector]);
        id v39 = (void *)objc_claimAutoreleasedReturnValue([v38 assetType]);
        uint64_t v40 = v37;
        uint64_t v21 = (__CFString *)v54;
        v41 = -[MAAutoAssetSelector initForAssetType:](v40, "initForAssetType:", v39);
        uint64_t v42 = *p_assetSelector;
        *p_assetSelector = v41;

        uint64_t v24 = v15;
LABEL_22:

        goto LABEL_23;
      }
    }

    uint64_t v43 = objc_claimAutoreleasedReturnValue([v32 clientAssetSelector]);
    id v38 = *p_assetSelector;
    *p_assetSelector = (id)v43;
    goto LABEL_22;
  }

  uint64_t v24 = v15;
  if (!v15 || !v54 || !v55)
  {
    uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v25 oslog]);

    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      if (v15) {
        uint64_t v27 = (__CFString *)objc_claimAutoreleasedReturnValue([v15 summary]);
      }
      else {
        uint64_t v27 = @"N";
      }
      v50 = v54;
      v51 = v55;
      if (!v54) {
        v50 = @"N";
      }
      *(_DWORD *)buf = 138543874;
      if (!v55) {
        v51 = @"N";
      }
      uint64_t v58 = v27;
      uint64_t v59 = 2114;
      uint64_t v60 = (__CFString *)v50;
      v61 = 2114;
      v62 = v51;
      _os_log_error_impl( &dword_0,  v26,  OS_LOG_TYPE_ERROR,  "{AUTO-ELIMINATE:initWithClientRequest} MISSING required auto-asset-set information | clientRequest:%{public}@, c lientDomainName:%{public}@, assetSetIdentifier:%{public}@",  buf,  0x20u);
LABEL_45:
      if (v24) {

      }
      uint64_t v21 = (__CFString *)v54;
      goto LABEL_29;
    }

    goto LABEL_29;
  }

  return v11;
}

  (*(void (**)(void))(*(void *)(a1 + 96) + 16LL))();
}
            }

            p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
            goto LABEL_31;
          }

          uint64_t v21 = v19;
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          CC_SHA1_CTX v23 = (os_log_s *)objc_claimAutoreleasedReturnValue([v22 oslog]);

          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            v41 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            uint64_t v42 = (void *)v41;
            *(_DWORD *)buf = 138543618;
            uint64_t v43 = @"N";
            if (v16) {
              uint64_t v43 = v16;
            }
            v127 = v41;
            v128 = 2114;
            v129 = v43;
            _os_log_error_impl( &dword_0,  v23,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [OVERFLOW-TRIM] {atomicInstanceTrimOverflowAfterPersisting} unable to determine previous status | entryID:%{public}@",  buf,  0x16u);
          }

          uint64_t v19 = v21;
          if (v16) {
            -[NSMutableArray addObject:](v100, "addObject:", v16);
          }
LABEL_31:

          objc_autoreleasePoolPop(v17);
          uint64_t v15 = (char *)v15 + 1;
        }

        while (v13 != v15);
        uint64_t v66 = [obj countByEnumeratingWithState:&v120 objects:v132 count:16];
        uint64_t v13 = v66;
        if (!v66)
        {
LABEL_57:

          v118 = 0u;
          v119 = 0u;
          v116 = 0u;
          v117 = 0u;
          v108 = v100;
          uint64_t v67 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v108,  "countByEnumeratingWithState:objects:count:",  &v116,  v125,  16LL);
          if (v67)
          {
            uint64_t v68 = v67;
            uint64_t v69 = *(void *)v117;
            do
            {
              for (uint64_t i = 0LL; i != v68; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v117 != v69) {
                  objc_enumerationMutation(v108);
                }
                uint64_t v71 = *(void *)(*((void *)&v116 + 1) + 8LL * (void)i);
                id v72 = objc_autoreleasePoolPush();
                v73 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( v111,  "persistedKnownSetAtomicInstances"));
                uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue( [v73 persistedEntry:v71 fromLocation:@"atomicInstanceTrimOverflowAfterPersisting"]);

                id v75 = [v74 secureCodedObjectForKey:@"setAtomicInstance" ofClass:objc_opt_class(MADAutoSetAtomicInstance)];
                id v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
                id v77 = (void *)objc_claimAutoreleasedReturnValue([v76 atomicInstanceUUID]);
                -[MADAutoAssetControlManager atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:]( v111,  "atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:",  @"atomicInstanceTrimOverflowAfterPersisting",  v77,  @"dropping to avoid overflow",  335LL);

                objc_autoreleasePoolPop(v72);
              }

              uint64_t v68 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v108,  "countByEnumeratingWithState:objects:count:",  &v116,  v125,  16LL);
            }

            while (v68);
          }

          v114 = 0u;
          v115 = 0u;
          v112 = 0u;
          v113 = 0u;
          v106 = v94;
          v78 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v106,  "countByEnumeratingWithState:objects:count:",  &v112,  v124,  16LL);
          if (v78)
          {
            v79 = v78;
            v109 = *(id *)v113;
            do
            {
              for (j = 0LL; j != v79; j = (char *)j + 1)
              {
                if (*(id *)v113 != v109) {
                  objc_enumerationMutation(v106);
                }
                v81 = *(void *)(*((void *)&v112 + 1) + 8LL * (void)j);
                uint64_t v82 = objc_autoreleasePoolPush();
                id v83 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( v111,  "downloadedSetDescriptorsByInstance"));
                id v84 = [v83 safeObjectForKey:v81 ofClass:objc_opt_class(MADAutoSetDescriptor)];
                id v85 = (void *)objc_claimAutoreleasedReturnValue(v84);

                __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v85 clientDomainName]);
                __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v85 assetSetIdentifier]);
                __int128 v88 = (void *)objc_claimAutoreleasedReturnValue( +[MANAutoAssetSetStatus shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:]( &OBJC_CLASS___MANAutoAssetSetStatus,  "shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:",  v86,  v87,  v81));

                -[MADAutoAssetControlManager removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:]( v111,  "removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:hi storyOperationSD:",  v85,  @"atomicInstanceTrimOverflowAfterPersisting",  0LL,  0LL,  336LL,  380LL);
                __int128 v89 =  -[MADAutoAssetControlManager _shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:]( v111,  "_shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:",  @"atomicInstanceTrimOverflowAfterPersisting",  v88,  v110,  @"atomic-instance shared lock directory (eliminated set-identifier)");

                objc_autoreleasePoolPop(v82);
              }

              v79 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v106,  "countByEnumeratingWithState:objects:count:",  &v112,  v124,  16LL);
            }

            while (v79);
          }

          uint64_t v7 = v93;
          uint64_t v10 = v94;
          goto LABEL_74;
        }
      }
    }

    v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    v91 = (os_log_s *)objc_claimAutoreleasedReturnValue([v90 oslog]);

    v110 = v91;
    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager atomicInstanceTrimOverflowAfterPersisting:].cold.1(self);
    }
LABEL_74:
  }
}
        }

        else
        {
          uint64_t v8 = v44;
          uint64_t v7 = v45;
          p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
          uint64_t v10 = v48;
        }

        uint64_t v13 = v47;

LABEL_31:
        uint64_t v10 = (char *)v10 + 1;
      }

      while (v10 != v7);
      uint64_t v7 = [obj countByEnumeratingWithState:&v53 objects:v66 count:16];
    }

    while (v7);
  }
}

  __int128 v89 = 0LL;
LABEL_37:
  __int128 v88 = 0LL;
LABEL_19:
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob currentSetStatus](self, "currentSetStatus"));
  CFRange v17 = objc_claimAutoreleasedReturnValue([v16 downloadProgress]);

  uint64_t v66 = objc_alloc(&OBJC_CLASS___MANAutoAssetSetStatus);
  id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v18 = objc_claimAutoreleasedReturnValue([v75 clientDomainName]);
  uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v19 = objc_claimAutoreleasedReturnValue([v74 assetSetIdentifier]);
  v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob setConfiguration](self, "setConfiguration"));
  id v84 = (void *)objc_claimAutoreleasedReturnValue([v73 autoAssetEntries]);
  id v72 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  id v83 = -[MADAutoAssetJob newAtomicInstancesDownloadedForDescriptor:]( self,  "newAtomicInstancesDownloadedForDescriptor:");
  uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v71 catalogCachedAssetSetID]);
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  v81 = (void *)objc_claimAutoreleasedReturnValue([v70 catalogDownloadedFromLive]);
  uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  v80 = (void *)objc_claimAutoreleasedReturnValue([v69 catalogLastTimeChecked]);
  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  v79 = (void *)objc_claimAutoreleasedReturnValue([v68 catalogPostedDate]);
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  v78 = (void *)objc_claimAutoreleasedReturnValue([v67 discoveredAtomicInstance]);
  uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v65 latestDowloadedAtomicInstanceEntries]);
  id v76 = v6;
  __int128 v86 = (void *)v18;
  __int128 v87 = (void *)v17;
  id v85 = (void *)v19;
  if (v64)
  {
    v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
    id v77 = (void *)objc_claimAutoreleasedReturnValue([v50 latestDowloadedAtomicInstanceEntries]);
  }

  else
  {
    id v77 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetJob foundSetNewerDiscoveredAtomicEntries]( self,  "foundSetNewerDiscoveredAtomicEntries"));
  }

  id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v63 discoveredAtomicInstance]);
  v62 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  v56 = (void *)objc_claimAutoreleasedReturnValue([v62 latestDowloadedAtomicInstanceEntries]);
  v61 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v61 downloadedCatalogCachedAssetSetID]);
  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v60 downloadedCatalogDownloadedFromLive]);
  uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v59 downloadedCatalogLastTimeChecked]);
  uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  v51 = (void *)objc_claimAutoreleasedReturnValue([v57 downloadedCatalogPostedDate]);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob currentSetNotifications](self, "currentSetNotifications"));
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob aggregatedClientSetPolicy](self, "aggregatedClientSetPolicy"));
  uint64_t v21 = -[MADAutoAssetJob haveReceivedLookupResponse](self, "haveReceivedLookupResponse");
  uint64_t v22 = -[MADAutoAssetJob vendingAtomicInstanceForConfiguredEntries](self, "vendingAtomicInstanceForConfiguredEntries");
  CC_SHA1_CTX v23 = -[MADAutoAssetJob downloadingUserInitiated](self, "downloadingUserInitiated");
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  uint64_t v25 = [v24 downloadedNetworkBytes];
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetDescriptor](self, "autoAssetSetDescriptor"));
  BYTE2(v49) = v23;
  BYTE1(v49) = v22;
  LOBYTE(v49) = v21;
  uint64_t v27 = -[MANAutoAssetSetStatus initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:withCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:]( v66,  "initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:withC atalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewe rAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloa dedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDow nloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:w ithSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:wit hDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withCurre ntLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:",  v86,  v85,  v84,  v83,  v82,  v81,  v80,  v79,  v78,  v77,  v58,  v56,  v55,  v53,  v54,  v51,  v20,  v52,  0,  0,  v49,  v17,  v25,  [v26 downloadedFilesystemBytes],  0,  0,  v88,  v89);
  -[MADAutoAssetJob setCurrentSetStatus:](self, "setCurrentSetStatus:", v27);

  uint64_t v28 = v77;
  if (v64)
  {

    uint64_t v28 = v50;
  }

  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob currentSetStatus](self, "currentSetStatus"));
  uint64_t v30 = [v29 copy];
  id v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob setJobInformation](self, "setJobInformation"));
  [v31 setCurrentSetStatus:v30];

  id v32 = objc_alloc(&OBJC_CLASS___MANAutoAssetSetInfoFound);
  unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetIdentifier](self, "autoAssetSetIdentifier"));
  __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob currentSetStatus](self, "currentSetStatus"));
  __int128 v35 = -[MANAutoAssetSetInfoFound initForAssetSetIdentifier:reportingStatus:]( v32,  "initForAssetSetIdentifier:reportingStatus:",  v33,  v34);
  -[MADAutoAssetJob setResultSetFound:](self, "setResultSetFound:", v35);

  __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob resultSetFound](self, "resultSetFound"));
  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob setJobInformation](self, "setJobInformation"));
  [v37 setFoundContent:v36];
}
}

LABEL_28:
          BOOL v9 = 0LL;
          goto LABEL_29;
        }
      }
    }
  }

  BOOL v9 = 0LL;
LABEL_27:

  return v9;
}

LABEL_29:
      v47 = v123;
      if (!v23) {
        v47 = v123 + 1;
      }
      v123 = v47;

      objc_autoreleasePoolPop(v13);
    }

    v121 = [obj countByEnumeratingWithState:&v129 objects:v148 count:16];
  }

  while (v121);
LABEL_35:

  v127 = 0u;
  v128 = 0u;
  v125 = 0u;
  v126 = 0u;
  v110 = (id)objc_claimAutoreleasedReturnValue([v116 latestDowloadedAtomicInstanceEntries]);
  v118 = [v110 countByEnumeratingWithState:&v125 objects:v147 count:16];
  unsigned __int8 v49 = 0LL;
  if (v118)
  {
    v112 = 0LL;
    obja = *(id *)v126;
    *(void *)&v48 = 138412546LL;
    v104 = v48;
    while (1)
    {
      for (j = 0LL; j != v118; j = (char *)j + 1)
      {
        if (*(id *)v126 != obja) {
          objc_enumerationMutation(v110);
        }
        v51 = *(void **)(*((void *)&v125 + 1) + 8LL * (void)j);
        v122 = objc_autoreleasePoolPush();
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v52 assetType]);
        uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v54 assetSpecifier]);
        v56 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager findAtomicEntryForAssetType:forAssetSpecifier:representedByStatus:]( self,  "findAtomicEntryForAssetType:forAssetSpecifier:representedByStatus:",  v53,  v55,  v115));

        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
        uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v57 assetType]);
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v59 assetSpecifier]);
        v61 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager findSetEntryForAssetType:forAssetSpecifier:representedByConfiguration:]( self,  "findSetEntryForAssetType:forAssetSpecifier:representedByConfiguration:",  v58,  v60,  v124));

        if (v56)
        {
          v62 = objc_alloc(&OBJC_CLASS___SUCoreRestoreVersion);
          id v63 = (void *)objc_claimAutoreleasedReturnValue([v56 fullAssetSelector]);
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v63 assetVersion]);
          uint64_t v65 = [v62 initWithRestoreVersion:v64];

          uint64_t v66 = objc_alloc(&OBJC_CLASS___SUCoreRestoreVersion);
          uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v67 assetVersion]);
          uint64_t v69 = [v66 initWithRestoreVersion:v68];

          if ([v65 isComparable:v69])
          {
            uint64_t v70 = (char *)[v65 compare:v69];
            self = v120;
            if (v70 == (char *)-1LL)
            {
              ++v108;
              if (!v119) {
                goto LABEL_63;
              }
              __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v120, "logger"));
              id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue([v86 oslog]);

              if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_62;
              }
              v105 = (void *)objc_claimAutoreleasedReturnValue([v56 fullAssetSelector]);
              v73 = (void *)objc_claimAutoreleasedReturnValue([v105 summary]);
              uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
              id v75 = (void *)objc_claimAutoreleasedReturnValue([v74 summary]);
              *(_DWORD *)buf = 138543618;
              v134 = (uint64_t)v73;
              v135 = 2114;
              v136 = (uint64_t)v75;
              id v76 = v72;
              id v77 = "\n{chooseNewerSetStatus} | rightIsNewer | left:%{public}@ | right:%{public}@";
            }

            else
            {
              if (v70 == (_BYTE *)&dword_0 + 1)
              {
                ++v107;
                if (v119)
                {
                  uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v120, "logger"));
                  id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue([v71 oslog]);

                  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
                  {
                    v105 = (void *)objc_claimAutoreleasedReturnValue([v56 fullAssetSelector]);
                    v73 = (void *)objc_claimAutoreleasedReturnValue([v105 summary]);
                    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
                    id v75 = (void *)objc_claimAutoreleasedReturnValue([v74 summary]);
                    *(_DWORD *)buf = 138543618;
                    v134 = (uint64_t)v73;
                    v135 = 2114;
                    v136 = (uint64_t)v75;
                    id v76 = v72;
                    id v77 = "\n{chooseNewerSetStatus} | leftIsNewer | left:%{public}@ | right:%{public}@";
                    goto LABEL_60;
                  }
              }

              uint64_t v58 = -[os_log_s countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v59,  v73,  16LL);
              if (!v58)
              {
                CFNumberType v4 = v56;
                goto LABEL_33;
              }
            }
          }
        }

        else
        {
          v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
          v48 = (os_log_s *)objc_claimAutoreleasedReturnValue([v47 oslog]);

          uint64_t v55 = v48;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
            -[MADAutoAssetStager _extendLookupByAssetTypeWithSetConfigurations:].cold.1((uint64_t)v74, (uint64_t)self);
          }
LABEL_33:
        }

        objc_autoreleasePoolPop(context);
        uint64_t v7 = v54 + 1;
      }

      while ((id)(v54 + 1) != v52);
      uint64_t v52 = [obj countByEnumeratingWithState:&v63 objects:v76 count:16];
    }

    while (v52);
  }
}

LABEL_29:
        uint64_t v13 = v78;
        uint64_t v12 = v80;
        uint64_t v25 = log;
        uint64_t v19 = v83;
LABEL_34:
        uint64_t v15 = v85;
        goto LABEL_35;
      }

      v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
      v51 = (os_log_s *)objc_claimAutoreleasedReturnValue([v73 oslog]);

      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        v56 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
        *(_DWORD *)buf = 138544130;
        __int128 v87 = v56;
        __int128 v88 = 2114;
        __int128 v89 = v13;
        v90 = 2114;
        v91 = v14;
        v92 = 2114;
        v93 = v15;
        _os_log_error_impl( &dword_0,  v51,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {_extendLookupByAssetType} [%{public}@] unable to create asset-set-entry | assetType:%{public}@ | assetSpecifier:%{public}@",  buf,  0x2Au);
        goto LABEL_37;
      }
    }

    __int128 v34 = 0LL;
    __int128 v37 = 0LL;
    id v38 = 0LL;
    unsigned int v33 = 0LL;
    uint64_t v22 = 0LL;
    goto LABEL_28;
  }

  uint64_t v22 = v21;
  CC_SHA1_CTX v23 = (void *)objc_claimAutoreleasedReturnValue([v21 assetSetEntryForAssetType:v14 forAssetSpecifier:v15]);

  if (!v23)
  {
    id v39 = objc_alloc(&OBJC_CLASS___NSMutableArray);
    id v84 = v19;
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v22 autoAssetEntries]);
    v41 = -[NSMutableArray initWithArray:](v39, "initWithArray:", v40);

    uint64_t v19 = v84;
    id v85 = v15;
    if (v84)
    {
      uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue([v84 assetSetEntryForAssetType:v14 forAssetSpecifier:v15]);
      if (!v42)
      {
        uint64_t v43 = (os_log_s *)v41;
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
        uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue([v44 oslog]);

        loga = v45;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
          *(_DWORD *)buf = 138544130;
          __int128 v87 = v46;
          __int128 v88 = 2114;
          __int128 v89 = v13;
          v90 = 2114;
          v91 = v14;
          v92 = 2114;
          v93 = v85;
          v47 = "%{public}@\n"
                "[AUTO-STAGER] {_extendLookupByAssetType} [%{public}@] unable to locate additional asset-set-entry | asse"
                "tType:%{public}@ | assetSpecifier:%{public}@";
LABEL_39:
          _os_log_error_impl(&dword_0, loga, OS_LOG_TYPE_ERROR, v47, buf, 0x2Au);

          goto LABEL_32;
        }

        goto LABEL_32;
      }
    }

    else
    {
      uint64_t v42 = -[MANAutoAssetSetEntry initForAssetType:withAssetSpecifier:usingDecryptionKey:]( objc_alloc(&OBJC_CLASS___MANAutoAssetSetEntry),  "initForAssetType:withAssetSpecifier:usingDecryptionKey:",  v14,  v15,  0LL);
      if (!v42)
      {
        uint64_t v43 = (os_log_s *)v41;
        uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
        id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue([v74 oslog]);

        loga = v75;
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
          *(_DWORD *)buf = 138544130;
          __int128 v87 = v46;
          __int128 v88 = 2114;
          __int128 v89 = v13;
          v90 = 2114;
          v91 = v14;
          v92 = 2114;
          v93 = v85;
          v47 = "%{public}@\n"
                "[AUTO-STAGER] {_extendLookupByAssetType} [%{public}@] unable to create asset-set-entry | assetType:%{pub"
                "lic}@ | assetSpecifier:%{public}@";
          goto LABEL_39;
        }

  v50 = v9;
  if (-[NSMutableDictionary count](v8, "count"))
  {
    v50 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);

    uint64_t v68 = 0u;
    uint64_t v69 = 0u;
    uint64_t v66 = 0u;
    uint64_t v67 = 0u;
    v51 = v8;
    uint64_t v52 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v51,  "countByEnumeratingWithState:objects:count:",  &v66,  v74,  16LL);
    if (v52)
    {
      uint64_t v53 = v52;
      uint64_t v54 = *(void *)v67;
      do
      {
        for (j = 0LL; j != v53; j = (char *)j + 1)
        {
          if (*(void *)v67 != v54) {
            objc_enumerationMutation(v51);
          }
          v56 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v51,  "safeObjectForKey:ofClass:",  *(void *)(*((void *)&v66 + 1) + 8LL * (void)j),  objc_opt_class(p_ivars[223]));
          uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
          if (v57) {
            -[NSMutableArray addObject:](v50, "addObject:", v57);
          }
        }

        uint64_t v53 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v51,  "countByEnumeratingWithState:objects:count:",  &v66,  v74,  16LL);
      }

      while (v53);
    }

    BOOL v9 = v60;
    uint64_t v8 = v61;
  }

  return v50;
}

        v50 = *(void **)(*(void *)(*(void *)(v1 + 48) + 8LL) + 40LL);
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue([v11 fullAssetSelector]);
        [v50 addObject:v14];
LABEL_32:

LABEL_33:
        objc_autoreleasePoolPop(v28);
        uint64_t v7 = (char *)v7 + 1;
      }

      while (v3 != v7);
      size_t v3 = [obj countByEnumeratingWithState:&v58 objects:v68 count:16];
    }

    while (v3);
  }
}
      }

      uint64_t v58 = [v12 countByEnumeratingWithState:&v64 objects:v69 count:16];
    }

    while (v58);
  }

  __int128 v35 = v14;
  _MobileAssetLog( 0LL,  5,  (uint64_t)"-[DownloadManager _logResponseBody:nonce:extraServerOptions:]",  @"Pallas response nonce: %@. Total asset count: %ld. The response body is: %@",  v36,  v37,  v38,  v39,  (uint64_t)v9);
  if (v14 >= 1 && (v13 & 1) != 0)
  {
    uint64_t v44 = (char *)-[NSMutableArray count](v11, "count");
    if ((char *)v35 != v44) {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager _logResponseBody:nonce:extraServerOptions:]",  @"{_logResponseBody} ANOLMALY:_parseForAssetDetailsToLog: number of asset details to log do not match assets found.  Assets found: %ld.  Asset details to log: %ld",  v40,  v41,  v42,  v43,  v35);
    }
    if ((uint64_t)v44 >= 1)
    {
      uint64_t v45 = 0LL;
      do
      {
        uint64_t v46 = v45 + 1;
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:"));
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[DownloadManager _logResponseBody:nonce:extraServerOptions:]",  @"Pallas response nonce: %@. Details for asset #%ld [of %ld] is: %@",  v47,  v48,  v49,  v50,  (uint64_t)v9);

        uint64_t v45 = v46;
      }

      while (v44 != v46);
    }
  }
}

        uint64_t v52 = v41;
        v41 = log;

LABEL_35:
        objc_autoreleasePoolPop(v48);
        uint64_t v12 = (char *)v12 + 1;
      }

      while (v12 != v9);
      BOOL v9 = [obj countByEnumeratingWithState:&v68 objects:v78 count:16];
      if (!v9)
      {
LABEL_40:

        id v38 = v41;
        uint64_t v7 = v40;
        goto LABEL_41;
      }
    }
  }

  id v38 = 0LL;
LABEL_41:

  return v38;
}

LABEL_5:
  uint64_t v15 = v46;
  uint64_t v20 = 0LL;
  uint64_t v21 = v15;
LABEL_34:

  BOOL v9 = v44;
  if (a5) {
LABEL_35:
  }
    *a5 = v21;
LABEL_36:

  return v20;
}

        objc_autoreleasePoolPop(context);
        uint64_t v12 = v117 + 1;
      }

      while ((id)(v117 + 1) != v114);
      v114 = [v9 countByEnumeratingWithState:&v141 objects:v160 count:16];
      if (!v114) {
        goto LABEL_32;
      }
    }
  }

  v112 = 0LL;
LABEL_32:

  v136 = 0u;
  v134 = 0u;
  v135 = 0u;
  v133 = 0u;
  v126 = v107;
  v47 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v126,  "countByEnumeratingWithState:objects:count:",  &v133,  v158,  16LL);
  if (v47)
  {
    v48 = v47;
    unsigned __int8 v49 = *(void *)v134;
    do
    {
      for (j = 0LL; j != v48; j = (char *)j + 1)
      {
        if (*(void *)v134 != v49) {
          objc_enumerationMutation(v126);
        }
        v51 = *(void *)(*((void *)&v133 + 1) + 8LL * (void)j);
        uint64_t v52 = objc_autoreleasePoolPush();
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v113 clientRequest]);
        uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v53 clientRequestMessage]);

        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v54 message]);
        v56 = [v55 safeObjectForKey:@"instance" ofClass:objc_opt_class(MAAutoAssetInfoInstance)];
        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
        uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v57 autoAssetClientName]);
        if (v58) {
          uint64_t v59 = objc_claimAutoreleasedReturnValue([v57 autoAssetClientName]);
        }
        else {
          uint64_t v59 = objc_claimAutoreleasedReturnValue([v57 clientProcessName]);
        }
        uint64_t v60 = (void *)v59;

        -[MADAutoAssetControlManager _removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:]( v118,  "_removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:",  @"_removeAllContentForEliminateTracker",  v51,  300LL,  v60);
        objc_autoreleasePoolPop(v52);
      }

      v48 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v126,  "countByEnumeratingWithState:objects:count:",  &v133,  v158,  16LL);
    }

    while (v48);
  }

  v61 = v118;
  v62 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v118, "logger"));
  id v63 = (os_log_s *)objc_claimAutoreleasedReturnValue([v62 oslog]);

  uint64_t v64 = v113;
  uint64_t v66 = v110;
  uint64_t v65 = v111;
  if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v118, "_updateLatestSummary"));
    uint64_t v68 = [v110 count];
    uint64_t v69 = -[NSMutableArray count](v126, "count");
    uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v113 summary]);
    uint64_t v71 = [v111 count];
    *(_DWORD *)buf = 138544642;
    v147 = v67;
    v148 = 2048;
    v149 = v68;
    v150 = 2048;
    v151 = v69;
    v152 = 2048;
    v153 = v112;
    v154 = 2114;
    v155 = v70;
    v156 = 2048;
    v157 = v71;
    _os_log_impl( &dword_0,  v63,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {_removeAllContentForEliminateTracker} reviewed all downloadedDescriptorsBySelector(%ld) | removeDesc riptors:%ld | notRemovedStillLocked:%ld | eliminateTracker:%{public}@, lockedEliminateSelectors:%ld",  buf,  0x3Eu);

    v61 = v118;
  }

  id v72 = (void *)objc_claimAutoreleasedReturnValue([v113 assetSelector]);
  v73 = (void *)objc_claimAutoreleasedReturnValue([v72 assetSpecifier]);

  if (!v73)
  {
    if ([v111 count])
    {
      uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v61, "autoControlManagerFSM"));
      id v75 = (void *)objc_claimAutoreleasedReturnValue([v74 diag]);
      id v76 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"{_removeAllContentForEliminateTracker} still have locked selectors | lockedEliminateSelectors:%ld",  [v111 count]);
      [v75 trackAnomaly:@"AUTO-CONTROL" forReason:v76 withResult:6109 withError:0];
      goto LABEL_76;
    }

    id v77 = (void *)objc_claimAutoreleasedReturnValue([v122 assetType]);
    AutoLocalUrlFromTypeWithPurpose = getAutoLocalUrlFromTypeWithPurpose(v77, 2LL, @"auto");
    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(AutoLocalUrlFromTypeWithPurpose);

    if (!v74)
    {
      id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v61, "autoControlManagerFSM"));
      id v76 = (NSString *)objc_claimAutoreleasedReturnValue([v75 diag]);
      __int128 v88 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v82 = (id)objc_claimAutoreleasedReturnValue([v113 summary]);
      __int128 v89 = -[NSString initWithFormat:]( v88,  "initWithFormat:",  @"{_removeAllContentForEliminateTracker} no assetTypeRepoLocation | eliminateTracker:%@",  v82);
      -[NSString trackAnomaly:forReason:withResult:withError:]( v76,  "trackAnomaly:forReason:withResult:withError:",  @"AUTO-CONTROL",  v89,  6101LL,  0LL);
      goto LABEL_75;
    }

    id v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v76 = (NSString *)objc_claimAutoreleasedReturnValue([v74 path]);
    v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    v80 = [v79 fileExistsAtPath:v76];

    if (v80)
    {
      v132 = 0LL;
      v81 = (NSString *)objc_claimAutoreleasedReturnValue([v75 contentsOfDirectoryAtPath:v76 error:&v132]);
      uint64_t v82 = v132;
      obja = v76;
      v115 = v81;
      if (v82)
      {
        id v83 = (NSString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v61, "autoControlManagerFSM"));
        id v84 = (void *)objc_claimAutoreleasedReturnValue(-[NSString diag](v83, "diag"));
        id v85 = objc_alloc(&OBJC_CLASS___NSString);
        __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v113 summary]);
        __int128 v87 = -[NSString initWithFormat:]( v85,  "initWithFormat:",  @"{_removeAllContentForEliminateTracker} unable to get repo directory | eliminateTracker:%@ | assetDirectory:%@",  v86,  obja);
        [v84 trackAnomaly:@"AUTO-CONTROL" forReason:v87 withResult:6101 withError:v82];

        id v76 = obja;
        goto LABEL_74;
      }

      v130 = 0u;
      v131 = 0u;
      v128 = 0u;
      v129 = 0u;
      v119 = v81;
      v90 = -[NSString countByEnumeratingWithState:objects:count:]( v119,  "countByEnumeratingWithState:objects:count:",  &v128,  v145,  16LL);
      if (!v90) {
        goto LABEL_73;
      }
      v91 = v90;
      v121 = v75;
      v109 = v74;
      v92 = *(void *)v129;
      while (1)
      {
        for (k = 0LL; k != v91; k = (char *)k + 1)
        {
          if (*(void *)v129 != v92) {
            objc_enumerationMutation(v119);
          }
          v94 = (void *)objc_claimAutoreleasedReturnValue( -[NSString stringByAppendingPathComponent:]( v76,  "stringByAppendingPathComponent:",  *(void *)(*((void *)&v128 + 1) + 8LL * (void)k)));
          if (!v94)
          {
            v99 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v61, "autoControlManagerFSM"));
            v95 = (NSURL *)objc_claimAutoreleasedReturnValue([v99 diag]);
            v98 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"{_removeAllContentForEliminateTracker} unable to determine local repository path for assetDirectory:%@",  v76);
            -[NSURL trackAnomaly:forReason:withResult:withError:]( v95,  "trackAnomaly:forReason:withResult:withError:",  @"AUTO-CONTROL",  v98,  6101LL,  0LL);
            goto LABEL_70;
          }

          v95 = -[NSURL initFileURLWithPath:](objc_alloc(&OBJC_CLASS___NSURL), "initFileURLWithPath:", v94);
          if (-[NSURL hasDirectoryPath](v95, "hasDirectoryPath"))
          {
            ControlManager = getControlManager();
            v97 = (void *)objc_claimAutoreleasedReturnValue(ControlManager);
            v98 = (NSString *)objc_claimAutoreleasedReturnValue([v97 getSAFRegistrationBundleID:v95]);
          }

          else
          {
            v98 = 0LL;
          }

          v127 = 0LL;
          [v121 removeItemAtPath:v94 error:&v127];
          v99 = v127;
          v100 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v61, "logger"));
          v101 = (os_log_s *)objc_claimAutoreleasedReturnValue([v100 oslog]);

          if (v99)
          {
            id v76 = obja;
            if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
            {
              v102 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v61, "_updateLatestSummary"));
              v103 = (void *)objc_claimAutoreleasedReturnValue([v113 summary]);
              *(_DWORD *)buf = 138544130;
              v147 = v102;
              v148 = 2114;
              v149 = v103;
              v150 = 2114;
              v151 = v94;
              v152 = 2114;
              v153 = v99;
              _os_log_error_impl( &dword_0,  v101,  OS_LOG_TYPE_ERROR,  "[%{public}@] {_removeAllContentForEliminateTracker} unable to remove repo entry (after eliminate-all-for -asset-type) | eliminateTracker:%{public}@ | filename:%{public}@ | error:%{public}@",  buf,  0x2Au);

              v61 = v118;
              id v76 = obja;
            }

            goto LABEL_69;
          }

          if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
          {
            v104 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v61, "_updateLatestSummary"));
            v105 = (void *)objc_claimAutoreleasedReturnValue([v113 summary]);
            *(_DWORD *)buf = 138543874;
            v147 = v104;
            v148 = 2114;
            v149 = v105;
            v150 = 2114;
            v151 = v94;
            _os_log_impl( &dword_0,  v101,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {_removeAllContentForEliminateTracker} removed repo entry (after eliminate-all-for-asset-type) | eliminateTracker:%{public}@ | removed:%{public}@",  buf,  0x20u);

            v61 = v118;
          }

          id v76 = obja;
          if (v98)
          {
            v106 = getControlManager();
            v101 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);
            -[os_log_s updateSpaceAttributionForBundleID:assetPath:doRegistration:]( v101,  "updateSpaceAttributionForBundleID:assetPath:doRegistration:",  v98,  v95,  0LL);
LABEL_69:
          }

        CC_SHA1_CTX v23 = v48;
        uint64_t v21 = v49;
        goto LABEL_29;
      }

      if (v20)
      {
        if (!v29) {
          goto LABEL_28;
        }
        id v39 = [v21 newSummaryWithoutSelector];
        uint64_t v40 = +[MADAutoAssetControlManager newSummaryForRequestMessage:includingSelector:]( &OBJC_CLASS___MADAutoAssetControlManager,  "newSummaryForRequestMessage:includingSelector:",  v53,  0LL);
        *(_DWORD *)buf = 138547970;
        uint64_t v55 = @"PERSISTED";
        v56 = 2114;
        uint64_t v57 = v17;
        uint64_t v58 = 2114;
        uint64_t v59 = v18;
        uint64_t v60 = 2114;
        v61 = v26;
        v62 = 2114;
        id v63 = @">----->";
        uint64_t v64 = 2114;
        uint64_t v65 = v51;
        uint64_t v66 = 2114;
        uint64_t v67 = v48;
        uint64_t v68 = 2114;
        uint64_t v69 = v26;
        uint64_t v70 = 2114;
        uint64_t v71 = v47;
        id v72 = 2114;
        v73 = v52;
        uint64_t v74 = 2114;
        id v75 = v39;
        id v76 = 2114;
        id v77 = v26;
        v78 = 2114;
        v79 = v47;
        v80 = 2114;
        v81 = v40;
        uint64_t v82 = 2114;
        id v83 = v26;
        id v84 = 2114;
        id v85 = v47;
        __int128 v86 = 2114;
        __int128 v87 = v20;
        __int128 v88 = 2114;
        __int128 v89 = v26;
        v90 = 2114;
        v91 = @"<-----<";
        v41 = "[%{public}@][%{public}@][%{public}@]\n"
              "#_%{public}@:%{public}@ {%{public}@} %{public}@\n"
              "#_%{public}@:(%{public}@) [%{public}@] | %{public}@\n"
              "#_%{public}@:(%{public}@) clientRequest:%{public}@\n"
              "#_%{public}@:(%{public}@) jobUUID:%{public}@\n"
              "#_%{public}@:%{public}@";
        goto LABEL_15;
      }

      if (!v29) {
        goto LABEL_28;
      }
      id v39 = [v21 newSummaryWithoutSelector];
      uint64_t v40 = +[MADAutoAssetControlManager newSummaryForRequestMessage:includingSelector:]( &OBJC_CLASS___MADAutoAssetControlManager,  "newSummaryForRequestMessage:includingSelector:",  v53,  0LL);
      *(_DWORD *)buf = 138547202;
      uint64_t v55 = @"PERSISTED";
      v56 = 2114;
      uint64_t v57 = v17;
      uint64_t v58 = 2114;
      uint64_t v59 = v18;
      uint64_t v60 = 2114;
      v61 = v26;
      v62 = 2114;
      id v63 = @">----->";
      uint64_t v64 = 2114;
      uint64_t v65 = v51;
      uint64_t v66 = 2114;
      uint64_t v67 = v48;
      uint64_t v68 = 2114;
      uint64_t v69 = v26;
      uint64_t v70 = 2114;
      uint64_t v71 = v47;
      id v72 = 2114;
      v73 = v52;
      uint64_t v74 = 2114;
      id v75 = v39;
      id v76 = 2114;
      id v77 = v26;
      v78 = 2114;
      v79 = v47;
      v80 = 2114;
      v81 = v40;
      uint64_t v82 = 2114;
      id v83 = v26;
      id v84 = 2114;
      id v85 = @"<-----<";
      v41 = "[%{public}@][%{public}@][%{public}@]\n"
            "#_%{public}@:%{public}@ {%{public}@} %{public}@\n"
            "#_%{public}@:(%{public}@) [%{public}@] | %{public}@\n"
            "#_%{public}@:(%{public}@) clientRequest:%{public}@\n"
            "#_%{public}@:%{public}@";
    }

    uint64_t v42 = v28;
    uint64_t v43 = 162;
    goto LABEL_26;
  }

  __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
  __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v34 diag]);
  __int128 v36 = objc_alloc(&OBJC_CLASS___NSString);
  v50 = v22;
  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v21 summary]);
  uint64_t v30 = v51;
  id v38 = -[NSString initWithFormat:]( v36,  "initWithFormat:",  @"{%@:_logPersistedEntry} %@:%@ | no persistedEntryID | %@ | jobUUID:%@ | assetDescriptor:%@",  v51,  v17,  v18,  v23,  v20,  v37);
  [v35 trackAnomaly:@"AUTO-CONTROL" forReason:v38 withResult:6110 withError:0];

  uint64_t v22 = v50;
LABEL_29:
}

  if (v25->_autoAssetSelector) {
    objc_storeStrong((id *)&v25->_autoAssetInstance, a3);
  }
  objc_storeStrong((id *)&v25->_autoAssetUUID, v48);
  v25->_clientRequestCFIndex Count = 0LL;
  *(_WORD *)&v25->_earlierSchedulerInvolved = 0;
  v25->_earlierPotentialNetworkFailure = 0;
  latestSafeSummary = v25->_latestSafeSummary;
  v25->_latestSafeSummary = (NSString *)@"INIT";

  v25->_schedulerInvolved = 0;
  v25->_potentialNetworkFailure = 0;
  v25->_stagerJob = v50;
  *(_WORD *)&v25->_stagerJobDownloadContent = 0;
  stagerAssetTargetOSVersion = v25->_stagerAssetTargetOSVersion;
  v25->_stagerAssetTargetOSVersion = 0LL;

  stagerAssetTargetBuildVersion = v25->_stagerAssetTargetBuildVersion;
  v25->_stagerAssetTargetBuildVersion = 0LL;

  stagerAssetTargetTrainName = v25->_stagerAssetTargetTrainName;
  v25->_stagerAssetTargetTrainName = 0LL;

  stagerAssetTargetRestoreVersion = v25->_stagerAssetTargetRestoreVersion;
  v25->_stagerAssetTargetRestoreVersion = 0LL;

  stagerJobAutoAssetCatalog = v25->_stagerJobAutoAssetCatalog;
  v25->_stagerJobAutoAssetCatalog = 0LL;

  v99 = -[SUCoreLog initWithCategory:](objc_alloc(&OBJC_CLASS___SUCoreLog), "initWithCategory:", @"AUTO-JOB");
  logger = v25->_logger;
  v25->_logger = v99;

  p_ivars = &MobileAssetKeyManager__metaData.ivars;
  v102 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  activeJobTasks = v25->_activeJobTasks;
  v25->_activeJobTasks = v102;

  v104 = [(id)objc_opt_class(MADAutoAssetJob) _getAutoAssetJobStateTable];
  v105 = objc_claimAutoreleasedReturnValue(v104);
  stateTable = v25->_stateTable;
  v25->_stateTable = (NSDictionary *)v105;

  bondedWithJob = v25->_bondedWithJob;
  v25->_bondedWithJob = 0LL;

  activeInstance = v25->_activeInstance;
  v25->_activeInstance = 0LL;

  activeDesire = v25->_activeDesire;
  v25->_activeDesire = 0LL;

  activeFound = v25->_activeFound;
  v25->_activeFound = 0LL;

  activeEnd = v25->_activeEnd;
  v25->_activeEnd = 0LL;

  activeListen = v25->_activeListen;
  v25->_activeListen = 0LL;

  autoAssetJobInformation = v25->_autoAssetJobInformation;
  v25->_autoAssetJobInformation = 0LL;

  v114 = objc_alloc_init(&OBJC_CLASS___MAAutoAssetPolicy);
  aggregatedClientAssetPolicy = v25->_aggregatedClientAssetPolicy;
  v25->_aggregatedClientAssetPolicy = v114;

  *(_WORD *)&v25->_aggregatedClientAssetPolicySpecified = 0;
  if (!v25->_autoAssetSetJob)
  {
    if (!v239)
    {
      firstClientName = v25->_firstClientName;
      v25->_firstClientName = 0LL;
      goto LABEL_41;
    }

    firstClientName = (NSString *)objc_claimAutoreleasedReturnValue([v239 autoAssetClientName]);
    if (firstClientName)
    {
      v117 = objc_claimAutoreleasedReturnValue([v239 autoAssetClientName]);
      goto LABEL_40;
    }

    v118 = v239;
LABEL_39:
    v117 = objc_claimAutoreleasedReturnValue([v118 clientProcessName]);
    goto LABEL_40;
  }

  firstClientName = (NSString *)objc_claimAutoreleasedReturnValue([v46 autoAssetSetClientName]);
  if (!firstClientName)
  {
    v118 = v46;
    goto LABEL_39;
  }

  v117 = objc_claimAutoreleasedReturnValue([v46 autoAssetSetClientName]);
LABEL_40:
  v119 = v25->_firstClientName;
  v25->_firstClientName = (NSString *)v117;

LABEL_41:
  jobCreationTriggeringLayer = v25->_jobCreationTriggeringLayer;
  v121 = @"Stager";
  if (!v50) {
    v121 = 0LL;
  }
  v25->_jobCreationTriggeringLayer = &v121->isa;

  onFilesystemByVersion = v25->_onFilesystemByVersion;
  v25->_onFilesystemByVersion = 0LL;

  checkUUIDBasePortion = v25->_checkUUIDBasePortion;
  v25->_checkUUIDBasePortion = 0LL;

  v124 = v25->_checkUUID;
  v25->_checkUUID = 0LL;

  *(_WORD *)&v25->_holdingLookupGrant = 0;
  v25->_rampingForegroundLatched = 0;
  catalogDownloadOptions = v25->_catalogDownloadOptions;
  v25->_catalogDownloadOptions = 0LL;

  assetDownloadOptions = v25->_assetDownloadOptions;
  v25->_assetDownloadOptions = 0LL;

  objc_storeStrong((id *)&v25->_baseForPatch, v49);
  foundNewerPatch = v25->_foundNewerPatch;
  v25->_foundNewerPatch = 0LL;

  foundNewerFull = v25->_foundNewerFull;
  v25->_foundNewerFull = 0LL;

  newerFoundAssetDescriptor = v25->_newerFoundAssetDescriptor;
  v25->_newerFoundAssetDescriptor = 0LL;

  objc_storeStrong((id *)&v25->_downloadingAssetDescriptor, v47);
  v25->_schedulerTriggerReceived = 0;
  if (v25->_downloadingUserInitiated)
  {
    v25->_wasPatched = 0;
    *(_DWORD *)&v25->_boostedToUserInitiated = 0;
  }

  else
  {
    v130 = [v233 downloadUserInitiated];
    v25->_downloadingUserInitiated = v130;
    *(_DWORD *)&v25->_boostedToUserInitiated = 0;
    v25->_wasPatched = 0;
    if (!v130) {
      goto LABEL_47;
    }
  }

  -[MAAutoAssetPolicy setUserInitiated:](v25->_aggregatedClientAssetPolicy, "setUserInitiated:", 1LL);
  -[MANAutoAssetSetPolicy setUserInitiated:](v25->_aggregatedClientSetPolicy, "setUserInitiated:", 1LL);
LABEL_47:
  latestInstalledAssetVersion = v25->_latestInstalledAssetVersion;
  v25->_latestInstalledAssetVersion = 0LL;

  latestInstalledAssetBuild = v25->_latestInstalledAssetBuild;
  v25->_latestInstalledAssetBuild = 0LL;

  if (v25->_autoAssetSetJob)
  {
    currentStatus = v25->_currentStatus;
    v25->_currentStatus = 0LL;

    v224 = objc_alloc(&OBJC_CLASS___MANAutoAssetSetStatus);
    v228 = (void *)objc_claimAutoreleasedReturnValue([v46 clientDomainName]);
    v223 = (void *)objc_claimAutoreleasedReturnValue([v46 assetSetIdentifier]);
    v222 = (id)objc_claimAutoreleasedReturnValue([v242 autoAssetEntries]);
    v220 = (void *)objc_claimAutoreleasedReturnValue([v241 catalogCachedAssetSetID]);
    v219 = (id)objc_claimAutoreleasedReturnValue([v241 catalogDownloadedFromLive]);
    id obj = (id)objc_claimAutoreleasedReturnValue([v241 catalogLastTimeChecked]);
    location = (id *)objc_claimAutoreleasedReturnValue([v241 catalogPostedDate]);
    v218 = (id)objc_claimAutoreleasedReturnValue([v241 downloadedCatalogCachedAssetSetID]);
    v214 = (void *)objc_claimAutoreleasedReturnValue([v241 downloadedCatalogDownloadedFromLive]);
    v213 = (void *)objc_claimAutoreleasedReturnValue([v241 downloadedCatalogLastTimeChecked]);
    v134 = (void *)objc_claimAutoreleasedReturnValue([v241 downloadedCatalogPostedDate]);
    v135 = objc_alloc_init(&OBJC_CLASS___MANAutoAssetSetNotifications);
    v136 = v25->_aggregatedClientSetPolicy;
    haveReceivedLookupResponse = v25->_haveReceivedLookupResponse;
    v138 = *(_WORD *)&v25->_vendingAtomicInstanceForConfiguredEntries;
    v139 = objc_alloc_init(&OBJC_CLASS___MANAutoAssetSetProgress);
    *(_WORD *)((char *)&v212 + 1) = v138;
    LOBYTE(v212) = haveReceivedLookupResponse;
    v140 = -[MANAutoAssetSetStatus initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:withCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:]( v224,  "initStatusForClientDomain:forAssetSetIdentifier:withConfiguredAssetEntries:withAtomicInstancesDownloaded:wi thCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:wi thNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLat estDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFrom Live:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurr entNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForCon figuredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFile systemBytes:withCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:",  v228,  v223,  v222,  0LL,  v220,  v219,  obj,  location,  0LL,  0LL,  0LL,  0LL,  v218,  v214,  v213,  v134,  v135,  v136,  0LL,  0LL,  v212,  v139,  -1LL,  -1LL,  0LL,  0LL,  0LL,  0LL);
    currentSetStatus = v25->_currentSetStatus;
    v25->_currentSetStatus = v140;

    p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
    v142 = -[MANAutoAssetSetStatus copy](v25->_currentSetStatus, "copy");
    -[MADAutoSetJobInformation setCurrentSetStatus:](v25->_setJobInformation, "setCurrentSetStatus:", v142);
    v143 = a11;
    p_assignedSetDescriptor = (id *)&v25->_assignedSetDescriptor;
    goto LABEL_66;
  }

  v145 = objc_alloc(&OBJC_CLASS___MAAutoAssetStatus);
  v146 = objc_opt_respondsToSelector( v145,  "initWithAssetSelector:withNotifications:withAvailableForUseAttributes:withNewerVersionAttributes:withNeverBee nLocked:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemByt es:withDownloadedAsPatch:withPatchedFromBaseSelector:withPatchedFromBaseFilesystemBytes:withPatchingAttempted :withStagedPriorToAvailable:withStagedFromOSVersion:withStagedFromBuildVersion:withCurrentLockUsage:withAvail ableForUseError:withPatchingAttemptError:withNewerVersionError:");

  v147 = objc_alloc(&OBJC_CLASS___MAAutoAssetStatus);
  v148 = v147;
  if ((v146 & 1) != 0)
  {
    v225 = v25->_autoAssetSelector;
    v229 = objc_alloc_init(&OBJC_CLASS___MAAutoAssetNotifications);
    v149 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetDescriptor metadata](v25->_downloadingAssetDescriptor, "metadata"));
    downloadingUserInitiated = v25->_downloadingUserInitiated;
    v151 = v233;
    if (v233)
    {
      v152 = [v233 patchingAttempted];
      v153 = [v233 stagedPriorToAvailable];
      v154 = (void *)objc_claimAutoreleasedReturnValue([v233 stagedFromOSVersion]);
      v155 = (void *)objc_claimAutoreleasedReturnValue([v233 stagedFromBuildVersion]);
      v156 = (void *)objc_claimAutoreleasedReturnValue([v233 patchingAttemptError]);
    }

    else
    {
      v155 = 0LL;
      v153 = 0;
      v152 = 0;
      v154 = 0LL;
      v156 = 0LL;
    }

    v162 = downloadingUserInitiated;
    BYTE1(v211) = v153;
    LOBYTE(v211) = v152;
    LOBYTE(v209) = 0;
    v158 = v229;
    v163 = -[MAAutoAssetStatus initWithAssetSelector:withNotifications:withAvailableForUseAttributes:withNewerVersionAttributes:withNeverBeenLocked:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withDownloadedAsPatch:withPatchedFromBaseSelector:withPatchedFromBaseFilesystemBytes:withPatchingAttempted:withStagedPriorToAvailable:withStagedFromOSVersion:withStagedFromBuildVersion:withCurrentLockUsage:withAvailableForUseError:withPatchingAttemptError:withNewerVersionError:]( v148,  "initWithAssetSelector:withNotifications:withAvailableForUseAttributes:withNewerVersionAttributes:withNeverB eenLocked:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesyste mBytes:withDownloadedAsPatch:withPatchedFromBaseSelector:withPatchedFromBaseFilesystemBytes:withPatchingAtt empted:withStagedPriorToAvailable:withStagedFromOSVersion:withStagedFromBuildVersion:withCurrentLockUsage:w ithAvailableForUseError:withPatchingAttemptError:withNewerVersionError:",  v225,  v229,  v149,  0LL,  1LL,  v162,  0LL,  -1LL,  -1LL,  v209,  0LL,  -1LL,  v211,  v154,  v155,  0LL,  0LL,  v156,  0LL);
  }

  else
  {
    v157 = objc_opt_respondsToSelector( v147,  "initWithAssetSelector:withNotifications:withAvailableForUseAttributes:withNewerVersionAttributes:withDownlo adUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withDownloade dAsPatch:withPatchedFromBaseSelector:withPatchedFromBaseFilesystemBytes:withPatchingAttempted:withStagedPri orToAvailable:withStagedFromOSVersion:withStagedFromBuildVersion:withCurrentLockUsage:withAvailableForUseEr ror:withPatchingAttemptError:withNewerVersionError:");

    if ((v157 & 1) == 0)
    {
      v158 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[SUCoreLog oslog](v25->_logger, "oslog"));
      if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR)) {
        -[MADAutoAssetJob initForInstance:orForSelector:orForDescriptor:orForSetInstance:withSetDesire:withSchedulerSetPolicy:withStagerSetPolicy:usingSetConfiguration:usingSetDescriptor:withBaseForPatchDescriptor:withAutoAssetUUID:downloadingUserInitiated:asStagerJob:usingCachedAutoAssetCatalog:].cold.1(v21);
      }
      v143 = a11;
      goto LABEL_65;
    }

    v230 = objc_alloc(&OBJC_CLASS___MAAutoAssetStatus);
    v226 = v25->_autoAssetSelector;
    v158 = objc_alloc_init(&OBJC_CLASS___MAAutoAssetNotifications);
    v149 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetDescriptor metadata](v25->_downloadingAssetDescriptor, "metadata"));
    v159 = v25->_downloadingUserInitiated;
    v151 = v233;
    if (v233)
    {
      v160 = [v233 patchingAttempted];
      v161 = [v233 stagedPriorToAvailable];
      v154 = (void *)objc_claimAutoreleasedReturnValue([v233 stagedFromOSVersion]);
      v155 = (void *)objc_claimAutoreleasedReturnValue([v233 stagedFromBuildVersion]);
      v156 = (void *)objc_claimAutoreleasedReturnValue([v233 patchingAttemptError]);
    }

    else
    {
      v155 = 0LL;
      v161 = 0;
      v160 = 0;
      v154 = 0LL;
      v156 = 0LL;
    }

    BYTE1(v210) = v161;
    LOBYTE(v210) = v160;
    LOBYTE(v20_Block_object_dispose(va, 8) = 0;
    v163 = -[MAAutoAssetStatus initWithAssetSelector:withNotifications:withAvailableForUseAttributes:withNewerVersionAttributes:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withDownloadedAsPatch:withPatchedFromBaseSelector:withPatchedFromBaseFilesystemBytes:withPatchingAttempted:withStagedPriorToAvailable:withStagedFromOSVersion:withStagedFromBuildVersion:withCurrentLockUsage:withAvailableForUseError:withPatchingAttemptError:withNewerVersionError:]( v230,  "initWithAssetSelector:withNotifications:withAvailableForUseAttributes:withNewerVersionAttributes:withDownlo adUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:withDownloade dAsPatch:withPatchedFromBaseSelector:withPatchedFromBaseFilesystemBytes:withPatchingAttempted:withStagedPri orToAvailable:withStagedFromOSVersion:withStagedFromBuildVersion:withCurrentLockUsage:withAvailableForUseEr ror:withPatchingAttemptError:withNewerVersionError:",  v226,  v158,  v149,  0LL,  v159,  0LL,  -1LL,  -1LL,  v208,  0LL,  -1LL,  v210,  v154,  v155,  0LL,  0LL,  v156,  0LL);
  }

  v164 = v25->_currentStatus;
  v25->_currentStatus = v163;

  if (v151)
  {
  }

  v143 = a11;
  p_ivars = &MobileAssetKeyManager__metaData.ivars;
LABEL_65:
  p_assignedSetDescriptor = (id *)&v25->_assignedSetDescriptor;

  v142 = v25->_currentSetStatus;
  v25->_currentSetStatus = 0LL;
LABEL_66:

  lastReportedPatchProgress = v25->_lastReportedPatchProgress;
  *(_OWORD *)&v25->_progressReportPhase = 0u;

  resultSelector = v25->_resultSelector;
  v25->_resultSelector = 0LL;

  resultInstance = v25->_resultInstance;
  v25->_resultInstance = 0LL;

  resultFound = v25->_resultFound;
  v25->_resultFound = 0LL;

  resultEnd = v25->_resultEnd;
  v25->_resultEnd = 0LL;

  resultListen = v25->_resultListen;
  v25->_resultListen = 0LL;

  simulateDescriptor = v25->_simulateDescriptor;
  *(_OWORD *)&v25->_simulateOperation = 0u;
  *(_OWORD *)&v25->_simulateTriggered = 0u;

  simulateBaseForPatch = v25->_simulateBaseForPatch;
  v25->_simulateBaseForPatch = 0LL;

  currentSetNotifications = v25->_currentSetNotifications;
  v25->_currentSetNotifications = 0LL;

  *(_OWORD *)&v25->_setProgressOverallTotalWrittenBytes = 0u;
  objc_storeStrong(p_assignedSetDescriptor, v143);
  latestAssetDescriptorOnFilesystemBySpecifier = v25->_latestAssetDescriptorOnFilesystemBySpecifier;
  v25->_latestAssetDescriptorOnFilesystemBySpecifier = 0LL;

  foundSetPatchDescriptorsBySpecifier = v25->_foundSetPatchDescriptorsBySpecifier;
  v25->_foundSetPatchDescriptorsBySpecifier = 0LL;

  foundSetFullDescriptorsBySpecifier = v25->_foundSetFullDescriptorsBySpecifier;
  v25->_foundSetFullDescriptorsBySpecifier = 0LL;

  foundSetNewerDiscoveredAtomicEntries = v25->_foundSetNewerDiscoveredAtomicEntries;
  v25->_foundSetNewerDiscoveredAtomicEntries = 0LL;

  v25->_foundSameAtomicInstanceAlreadyDownloaded = 0;
  v178 = (NSMutableArray *)objc_alloc_init((Class)p_ivars[139]);
  prePersonalizedSelectors = v25->_prePersonalizedSelectors;
  v25->_prePersonalizedSelectors = v178;

  v180 = (NSMutableArray *)objc_alloc_init((Class)p_ivars[139]);
  tryPersonalizeDescriptors = v25->_tryPersonalizeDescriptors;
  v25->_tryPersonalizeDescriptors = v180;

  tryPersonalizeSelector = v25->_tryPersonalizeSelector;
  v25->_tryPersonalizeSelector = 0LL;

  *(_WORD *)&v25->_tryPersonalizeSuccess = 0;
  v25->_becameLatestToVend = 0;
  newestDownloadedSetStatus = v25->_newestDownloadedSetStatus;
  v25->_newestDownloadedSetStatus = 0LL;

  v184 = -[MADAutoSetDescriptor copy](v25->_assignedSetDescriptor, "copy");
  autoAssetSetDescriptor = v25->_autoAssetSetDescriptor;
  v25->_autoAssetSetDescriptor = v184;

  v25->_nextSetSpecifierToDownload = 0LL;
  latestAutoAssetSummary = v25->_latestAutoAssetSummary;
  v25->_latestAutoAssetSummary = 0LL;

  *(_WORD *)&v25->_anomalyNoAssignedSetDescriptor = 0;
  setSpaceCheckedUUID = v25->_setSpaceCheckedUUID;
  v25->_setSpaceCheckedUUID = 0LL;

  resultSetFound = v25->_resultSetFound;
  v25->_resultSetFound = 0LL;

  v25->_reportingProgress = 0;
  v25->_progressLogsFilteredCFIndex Count = 0;
  autoAssetSetJob = v25->_autoAssetSetJob;
  stagerJob = v25->_stagerJob;
  v191 = objc_alloc(&OBJC_CLASS___NSString);
  autoAssetUUID = v25->_autoAssetUUID;
  if (autoAssetSetJob)
  {
    if (stagerJob)
    {
      v193 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoSetConfiguration assetSetIdentifier](v25->_setConfiguration, "assetSetIdentifier"));
      v194 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoSetConfiguration autoAssetEntries](v25->_setConfiguration, "autoAssetEntries"));
      v195 = -[NSString initWithFormat:]( v191,  "initWithFormat:",  @"[JOB-SET-STAGER][%@]setIdentifier:%@[entries:%ld]",  autoAssetUUID,  v193,  [v194 count]);
    }

    else
    {
      v193 = (__CFString *)objc_claimAutoreleasedReturnValue([v243 assetSetIdentifier]);
      v194 = (void *)objc_claimAutoreleasedReturnValue([v243 clientDomainName]);
      v195 = -[NSString initWithFormat:]( v191,  "initWithFormat:",  @"[JOB-SET][%@]setIdentifier:%@[%@]",  autoAssetUUID,  v193,  v194);
    }

    autoJobName = v25->_autoJobName;
    v25->_autoJobName = v195;
    uint64_t v21 = v231;
  }

  else
  {
    if (stagerJob)
    {
      uint64_t v21 = v231;
      if (v231) {
        v193 = (__CFString *)objc_claimAutoreleasedReturnValue([v231 summary]);
      }
      else {
        v193 = @"byUUID";
      }
      v197 = @"bySelector";
      if (v240) {
        v197 = @"byUUID";
      }
      v198 = -[NSString initWithFormat:]( v191,  "initWithFormat:",  @"[JOB-AUTO-STAGER][%@]selector:%@[%@]",  autoAssetUUID,  v193,  v197);
    }

    else
    {
      uint64_t v21 = v231;
      if (v231) {
        v193 = (__CFString *)objc_claimAutoreleasedReturnValue([v231 summary]);
      }
      else {
        v193 = @"byUUID";
      }
      v199 = @"bySelector";
      if (v240) {
        v199 = @"byUUID";
      }
      v198 = -[NSString initWithFormat:]( v191,  "initWithFormat:",  @"[JOB-AUTO][%@]selector:%@[%@]",  autoAssetUUID,  v193,  v199);
    }

    v200 = v25->_autoJobName;
    v25->_autoJobName = v198;

    if (!v21) {
      goto LABEL_86;
    }
  }

LABEL_86:
  v201 = (SUCoreFSM *)-[SUCoreFSM initMachine:withTable:startingIn:usingDelegate:registeringAllInfoClass:]( objc_alloc(&OBJC_CLASS___SUCoreFSM),  "initMachine:withTable:startingIn:usingDelegate:registeringAllInfoClass:",  v25->_autoJobName,  v25->_stateTable,  @"ReadyToStartJob",  v25,  objc_opt_class(&OBJC_CLASS___MADAutoAssetJobParam));
  autoJobFSM = v25->_autoJobFSM;
  v25->_autoJobFSM = v201;

  uint64_t v22 = v233;
  if (!v25->_autoJobFSM)
  {
    v203 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[SUCoreLog oslog](v25->_logger, "oslog"));
    if (os_log_type_enabled(v203, OS_LOG_TYPE_ERROR))
    {
      if (v25->_autoAssetSetJob) {
        v205 = objc_claimAutoreleasedReturnValue([v243 assetSetIdentifier]);
      }
      else {
        v205 = objc_claimAutoreleasedReturnValue([v21 summary]);
      }
      v207 = (void *)v205;
      *(_DWORD *)buf = 138543362;
      v246 = v205;
      _os_log_error_impl( &dword_0,  v203,  OS_LOG_TYPE_ERROR,  "%{public}@|{initForInstance} failed to initialize AutoJob FSM",  buf,  0xCu);
    }

    uint64_t v22 = v233;
  }

  -[MADAutoAssetJob simulateEnd:](self, "simulateEnd:", 1LL);
  -[MADAutoAssetJob simulateSet:](self, "simulateSet:", v4);
  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v11 clientAssetPolicy]);

  if (!v40)
  {
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v12 clientAssetSetPolicy]);

    if (!v53) {
      goto LABEL_64;
    }
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
    uint64_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue([v54 oslog]);

    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      v56 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v12 clientAssetSetPolicy]);
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v57 summary]);
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
      *(_DWORD *)buf = 138543874;
      v91 = v56;
      v92 = 2114;
      v93 = v58;
      v94 = 2114;
      v95 = v59;
      _os_log_impl( &dword_0,  v55,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {addToActiveJobTasks} aggregating | clientAssetSetPolicy:%{public}@ | job:%{public}@}",  buf,  0x20u);
    }

    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v12 clientAssetSetPolicy]);
    -[MADAutoAssetJob mergeSetPolicyIntoAggregated:](self, "mergeSetPolicyIntoAggregated:", v60);

    if (-[MADAutoAssetJob aggregatedClientSetPolicySpecified](self, "aggregatedClientSetPolicySpecified"))
    {
      v61 = (void *)objc_claimAutoreleasedReturnValue([v12 clientAssetSetPolicy]);
      if ([v61 userInitiated])
      {
        v62 = -[MADAutoAssetJob boostedToUserInitiated](self, "boostedToUserInitiated");

        if ((v62 & 1) != 0) {
          goto LABEL_61;
        }
        -[MADAutoAssetJob desireChangedToUserInitiated](self, "desireChangedToUserInitiated");
        id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
        v61 = (void *)objc_claimAutoreleasedReturnValue([v63 oslog]);

        if (os_log_type_enabled((os_log_t)v61, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
          *(_DWORD *)buf = 138543618;
          v91 = v64;
          v92 = 2114;
          v93 = v65;
          uint64_t v66 = "%{public}@ | {addToActiveJobTasks} additional auto-asset-set-policy | boosted to user-initiated | job:%{public}@}";
LABEL_59:
          _os_log_impl(&dword_0, (os_log_t)v61, OS_LOG_TYPE_DEFAULT, v66, buf, 0x16u);

          goto LABEL_60;
        }
      }

      goto LABEL_60;
    }

    -[MADAutoAssetJob setAggregatedClientSetPolicySpecified:](self, "setAggregatedClientSetPolicySpecified:", 1LL);
    uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v12 clientAssetSetPolicy]);
    if ([v71 userInitiated])
    {
      id v72 = -[MADAutoAssetJob boostedToUserInitiated](self, "boostedToUserInitiated");

      if ((v72 & 1) == 0)
      {
        -[MADAutoAssetJob desireChangedToUserInitiated](self, "desireChangedToUserInitiated");
        v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
        v61 = (void *)objc_claimAutoreleasedReturnValue([v73 oslog]);

        if (os_log_type_enabled((os_log_t)v61, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
          *(_DWORD *)buf = 138543618;
          v91 = v64;
          v92 = 2114;
          v93 = v65;
          uint64_t v66 = "%{public}@ | {addToActiveJobTasks} first auto-asset-set-policy encountered indicating user-initiated | job:%{public}@}";
          goto LABEL_59;
        }

      objc_autoreleasePoolPop(v23);
      uint64_t v20 = v62;
    }

    uint64_t v66 = [v62 countByEnumeratingWithState:&v71 objects:v75 count:16];
  }

  while (v66);

  uint64_t v42 = v68;
  if (v68)
  {
    uint64_t v43 = v59;
    -[NSMutableDictionary setObject:forKey:](v54, "setObject:forKey:", v59, v68);
    a8 = v52;
    uint64_t v44 = v53;
    a7 = v51;
    uint64_t v45 = v55;
    uint64_t v46 = v63;
    v47 = v58;
  }

  else
  {
    a8 = v52;
    uint64_t v44 = v53;
    a7 = v51;
    uint64_t v45 = v55;
    uint64_t v46 = v63;
    v47 = v58;
    uint64_t v43 = v59;
  }

        uint64_t v16 = v36;
      }

      objc_autoreleasePoolPop(v21);
      uint64_t v19 = (char *)v19 + 1;
    }

    while (v19 != v16);
    uint64_t v16 = [v13 countByEnumeratingWithState:&v41 objects:v46 count:16];
    if (v16) {
      continue;
    }
    break;
  }

  if (v17) {
    goto LABEL_44;
  }
LABEL_46:

  return v13;
}

  uint64_t v29 = updated;
  CC_SHA1_CTX v23 = v33;
LABEL_27:
  cc_clear(**(void **)(a1 + 8), v23);
  cc_clear(*(void *)(*(void *)(a1 + 8) + 8LL), v12);
  return v29;
}

  __break(1u);
  return result;
}

LABEL_21:
  if (a5) {
    *a5 = v29;
  }
  if (a6) {
    *a6 = v28;
  }

  return v17;
}

  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6534LL,  v9,  0LL,  @"unable to endAccess for secure asset (no underlying error provided)"));
  id v38 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  id v39 = (os_log_s *)objc_claimAutoreleasedReturnValue([v38 oslog]);

  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    v41 = (__CFString *)objc_claimAutoreleasedReturnValue([v37 checkedDescription]);
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
    *(_DWORD *)buf = 138543874;
    v51 = v9;
    uint64_t v52 = 2114;
    uint64_t v53 = v41;
    uint64_t v54 = 2114;
    uint64_t v55 = (uint64_t)v42;
    _os_log_error_impl( &dword_0,  v39,  OS_LOG_TYPE_ERROR,  "\n [AUTO-SECURE][AUTO-GRAFT-REMOVE] {%{public}@} ungraft|unmount endAccess ERROR | error:%{public}@ | autoAssetDescriptor:%{public}@",  buf,  0x20u);
  }

  if (a5) {
    *a5 = v37;
  }

  return 0;
}

    goto LABEL_22;
  }

  CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue([v8 domain]);
  uint64_t v10 = @"RequiredErrorBlocksOTA";
  if (!+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v11,  @"com.apple.MobileAssetError.Download")) {
    goto LABEL_21;
  }
  uint64_t v12 = -[MADAutoAssetStager _maDownloadErrorConsideredFatal:]( self,  "_maDownloadErrorConsideredFatal:",  [v8 code]);

  if (!v12) {
    uint64_t v10 = @"RequiredErrorNonFatal";
  }
LABEL_22:
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
  uint64_t v19 = objc_alloc(&OBJC_CLASS___MADAutoAssetStagerParam);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v5 jobInformation]);
  uint64_t v21 = -[MADAutoAssetStagerParam initWithJobInformation:withDownloadedDescriptor:withOperationError:]( v19,  "initWithJobInformation:withDownloadedDescriptor:withOperationError:",  v20,  0LL,  v8);
  [v18 followupEvent:v10 withInfo:v21];

  return 0LL;
}
}

        objc_autoreleasePoolPop(v27);
        uint64_t v12 = (char *)v12 + 1;
      }

      while (v52 != v12);
      id v31 = [v8 countByEnumeratingWithState:&v60 objects:v65 count:16];
      uint64_t v52 = v31;
      if (!v31)
      {
LABEL_25:

        uint64_t v58 = 0u;
        uint64_t v59 = 0u;
        v56 = 0u;
        uint64_t v57 = 0u;
        id v32 = v47;
        unsigned int v33 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v32,  "countByEnumeratingWithState:objects:count:",  &v56,  v64,  16LL);
        uint64_t v6 = v45;
        CFNumberType v4 = v46;
        if (v33)
        {
          __int128 v34 = v33;
          __int128 v35 = *(void *)v57;
          do
          {
            for (uint64_t i = 0LL; i != v34; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v57 != v35) {
                objc_enumerationMutation(v32);
              }
              if (*(void *)(*((void *)&v56 + 1) + 8LL * (void)i)) {
                objc_msgSend(v8, "removeObjectForKey:");
              }
            }

            __int128 v34 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v32,  "countByEnumeratingWithState:objects:count:",  &v56,  v64,  16LL);
          }

          while (v34);
        }

LABEL_35:
        objc_msgSend(v4, "setSafeObject:forKey:", v6, *(void *)(a1 + 72), v45);
        __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
        id v38 = (os_log_s *)objc_claimAutoreleasedReturnValue([v37 oslog]);

        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          id v39 = *(void *)(a1 + 64);
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) summary]);
          v41 = *(void *)(a1 + 56);
          *(_DWORD *)buf = 138543874;
          uint64_t v67 = v39;
          uint64_t v68 = 2114;
          uint64_t v69 = v40;
          uint64_t v70 = 2114;
          uint64_t v71 = v41;
          _os_log_impl( &dword_0,  v38,  OS_LOG_TYPE_DEFAULT,  "{AUTO-LOOKUP-CACHE[%{public}@]:recordLookupResult:forSelector:} | updated auto-asset-lookup-cache | selector :%{public}@ | assetAudience:%{public}@",  buf,  0x20u);
          goto LABEL_37;
        }

        goto LABEL_39;
      }
    }
  }

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  id v38 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
  {
    uint64_t v43 = *(void *)(a1 + 64);
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) summary]);
    uint64_t v44 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138543874;
    uint64_t v67 = v43;
    uint64_t v68 = 2114;
    uint64_t v69 = v40;
    uint64_t v70 = 2114;
    uint64_t v71 = v44;
    _os_log_error_impl( &dword_0,  v38,  OS_LOG_TYPE_ERROR,  "{AUTO-LOOKUP-CACHE[%{public}@]:recordLookupResult:forSelector:} | unable to create lookup-result | selector:%{publ ic}@ | assetAudience:%{public}@",  buf,  0x20u);
LABEL_37:
  }

    goto LABEL_22;
  }

  CFNumberType v4 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue([v4 oslog]);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetHistoryTracker historyTypeName](self, "historyTypeName"));
    *(_DWORD *)buf = 138544130;
    uint64_t v27 = v6;
    uint64_t v28 = 2048;
    uint64_t v29 = -[MADAutoAssetHistoryTracker currentBucketFileIndex](self, "currentBucketFileIndex");
    uint64_t v30 = 2048;
    id v31 = -[MADAutoAssetHistoryTracker currentBucketFilesystemBytes](self, "currentBucketFilesystemBytes");
    id v32 = 2048;
    unsigned int v33 = -[MADAutoAssetHistoryTracker maximumBucketFilesystemBytes](self, "maximumBucketFilesystemBytes");
    _os_log_impl( &dword_0,  v5,  OS_LOG_TYPE_DEFAULT,  "{AUTO-HISTORY-TRACKER[%{public}@]:loadPersistedState} | additional trigger to load from persisted-state when alrea dy loaded | currentBucketFileIndex:%ld | currentBucketFilesystemBytes:%ld | maximumBucketFilesystemBytes:%ld",  buf,  0x2Au);
LABEL_23:
  }
}

  uint64_t v19 = 0LL;
  if (!a2) {
    goto LABEL_15;
  }
LABEL_22:
  *a2 = v19;
  if (a3) {
LABEL_23:
  }
    *a3 = v10;
LABEL_24:
  free(v11);

  return v10 == 0LL;
}
}

  uint64_t v55 = 0LL;
LABEL_22:

  return v55;
}

  v139 = 0;
LABEL_22:
  uint64_t v25 = [v144 awaitDownloadingOfDiscovered];
  uint64_t v26 = @"replying to check-atomic awaiting download of discovered";
  if (!v25) {
    uint64_t v26 = 0LL;
  }
  v140 = v26;
  v145 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v27 = v16 ^ 1;
  if (!v9) {
    uint64_t v27 = 1;
  }
  if ((v27 & 1) == 0)
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v147 clientDomainName]);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v5 assetSetIdentifier]);
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetConfigurationByClientDomain:forAssetSetIdentifier:]( self,  "locateSetConfigurationByClientDomain:forAssetSetIdentifier:",  v28,  v29));

    id v31 = (id)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedByAtomicInstanceUUID:]( self,  "locateSetDescriptorDownloadedByAtomicInstanceUUID:",  v148));
    if (!v30)
    {
LABEL_67:
      uint64_t v45 = v31;
      goto LABEL_68;
    }

    id v32 = (void *)objc_claimAutoreleasedReturnValue([v30 autoAssetEntries]);
    unsigned int v33 = -[MADAutoAssetControlManager doesSetDescriptor:coverRequestedAutoAssetEntries:]( self,  "doesSetDescriptor:coverRequestedAutoAssetEntries:",  v141,  v32);

    if (!v33)
    {
      if (!v31)
      {
        uint64_t v45 = 0LL;
LABEL_68:

        goto LABEL_69;
      }

      goto LABEL_59;
    }

    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v30 latestAtomicInstanceToVend]);
    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetAtomicInstanceByInstanceUUID:]( self,  "locateSetAtomicInstanceByInstanceUUID:",  v34));

    if (v35)
    {
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v30 autoAssetEntries]);
      __int128 v37 = -[MADAutoAssetControlManager doesSetDescriptor:coverAllForAutoAssetEntries:]( self,  "doesSetDescriptor:coverAllForAutoAssetEntries:",  v141,  v36);

      if (v37)
      {
        id v38 = (void *)objc_claimAutoreleasedReturnValue([v141 latestDownloadedAtomicInstance]);
        id v39 = (void *)objc_claimAutoreleasedReturnValue([v30 latestAtomicInstanceToVend]);
        uint64_t v40 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v38, v39);

        v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue([v41 oslog]);

        uint64_t v43 = os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT);
        if (!v40)
        {
          if (v43)
          {
            id v63 = (__CFString *)objc_claimAutoreleasedReturnValue([v141 summary]);
            *(_DWORD *)buf = 138543362;
            v150 = v63;
            _os_log_impl( &dword_0,  v42,  OS_LOG_TYPE_DEFAULT,  "{IssueClientReplySetJob}\n [JOB-UUID] set-job found same content already latest-to-vend | setJobDescriptor:%{public}@",  buf,  0xCu);
          }

          goto LABEL_66;
        }

        if (v43)
        {
          uint64_t v44 = (__CFString *)objc_claimAutoreleasedReturnValue([v141 summary]);
          *(_DWORD *)buf = 138543362;
          v150 = v44;
          _os_log_impl( &dword_0,  v42,  OS_LOG_TYPE_DEFAULT,  "{IssueClientReplySetJob}\n[JOB-UUID] set-job matches latest-to-vend | setJobDescriptor:%{public}@",  buf,  0xCu);
        }

        BOOL v9 = 0LL;
        uint64_t v45 = 0LL;
        if (!v31) {
          goto LABEL_68;
        }
        goto LABEL_59;
      }
    }

    if (!v31)
    {
      uint64_t v54 = v139;
      if (!v141) {
        uint64_t v54 = 0;
      }
      if ((v54 & 1) == 0)
      {
        id v31 = 0LL;
        goto LABEL_66;
      }

      id v31 = v141;

      uint64_t v55 = [v31 isDiscoveredFullyDownloaded];
      v56 = (void *)objc_claimAutoreleasedReturnValue([v31 discoveredAtomicInstance]);
      uint64_t v57 = [v31 isDiscoveredFullyDownloaded];
      BYTE2(v137) = [v31 isDiscoveredFullyDownloaded];
      BYTE1(v137) = v57;
      LOBYTE(v137) = 0;
      LODWORD(v55) = -[MADAutoAssetControlManager trackSetDescriptor:fromLocation:forLatestDownloaded:forSpecificAtomicInstance:withCurrentSetStatus:changedWhileTerminated:changedNeverBeenLocked:notifyingIfJustDownloaded:latestToVend:historyOperation:firstClientName:]( self,  "trackSetDescriptor:fromLocation:forLatestDownloaded:forSpecificAtomicInstance:withCurrentSetStatu s:changedWhileTerminated:changedNeverBeenLocked:notifyingIfJustDownloaded:latestToVend:historyOpe ration:firstClientName:",  v31,  @"IssueClientReplySetJob",  v55,  v56,  v146,  0LL,  v137,  357LL,  @"com.apple.MobileAsset.daemon.internal");

      if ((_DWORD)v55)
      {
        uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v58 oslog]);

        if (!os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT))
        {
LABEL_65:

          __int128 v35 = v9;
          BOOL v9 = 0LL;
LABEL_66:

          goto LABEL_67;
        }

        uint64_t v60 = (__CFString *)objc_claimAutoreleasedReturnValue([v30 summary]);
        *(_DWORD *)buf = 138543362;
        v150 = v60;
        v61 = "{IssueClientReplySetJob}\n"
              "[LATEST-TO-VEND] same version found first-tracked as downloaded set-descriptor | setConfiguration:%{public}@";
LABEL_64:
        _os_log_impl(&dword_0, (os_log_t)v59, OS_LOG_TYPE_DEFAULT, v61, buf, 0xCu);

        goto LABEL_65;
      }

  v48 = 0u;
  unsigned __int8 v49 = 0u;
  uint64_t v46 = 0u;
  v47 = 0u;
  obja = (id)objc_claimAutoreleasedReturnValue([v8 autoAssetEntries]);
  uint64_t v22 = [obja countByEnumeratingWithState:&v46 objects:v59 count:16];
  if (v22)
  {
    CC_SHA1_CTX v23 = v22;
    uint64_t v24 = *(void *)v47;
    while (1)
    {
      uint64_t v25 = 0LL;
LABEL_24:
      if (*(void *)v47 != v24) {
        objc_enumerationMutation(obja);
      }
      uint64_t v26 = *(void **)(*((void *)&v46 + 1) + 8 * v25);
      uint64_t v42 = 0u;
      uint64_t v43 = 0u;
      uint64_t v44 = 0u;
      uint64_t v45 = 0u;
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v6 autoAssetEntries]);
      uint64_t v28 = [v27 countByEnumeratingWithState:&v42 objects:v58 count:16];
      if (!v28) {
        break;
      }
      uint64_t v29 = v28;
      uint64_t v30 = *(void *)v43;
LABEL_28:
      id v31 = 0LL;
      while (1)
      {
        if (*(void *)v43 != v30) {
          objc_enumerationMutation(v27);
        }
        if (v29 == (id)++v31)
        {
          uint64_t v29 = [v27 countByEnumeratingWithState:&v42 objects:v58 count:16];
          if (v29) {
            goto LABEL_28;
          }
          goto LABEL_51;
        }
      }

      if ((id)++v25 != v23) {
        goto LABEL_24;
      }
      CC_SHA1_CTX v23 = [obja countByEnumeratingWithState:&v46 objects:v59 count:16];
      id v32 = 1;
      if (!v23) {
        goto LABEL_53;
      }
    }
}

  return v18;
}

    uint64_t v20 = (float)(v21 * v22);
    goto LABEL_22;
  }

  if (-[ControlManager reclaimUrgency](self, "reclaimUrgency") >= 2)
  {
    switch(a5)
    {
      case 0LL:
      case 1LL:
      case 2LL:
        goto LABEL_12;
      case 3LL:
      case 4LL:
        goto LABEL_17;
      case 5LL:
LABEL_37:
        uint64_t v20 = -1.0;
        if (a10 > 799) {
          goto LABEL_22;
        }
LABEL_9:
        uint64_t v21 = a3;
        uint64_t v22 = 0.25;
        break;
      case 6LL:
        goto LABEL_6;
      case 7LL:
        uint64_t v20 = -1.0;
        if (a10 > 799) {
          goto LABEL_22;
        }
LABEL_12:
        uint64_t v21 = a3;
        uint64_t v22 = 0.5;
        break;
      default:
        goto LABEL_18;
    }

    goto LABEL_21;
  }

  switch(a5)
  {
    case 3LL:
    case 4LL:
LABEL_17:
      uint64_t v20 = -1.0;
      break;
    case 5LL:
    case 7LL:
      if (a10 <= 799) {
        uint64_t v20 = a3;
      }
      else {
        uint64_t v20 = -1.0;
      }
      break;
    case 6LL:
LABEL_6:
      uint64_t v20 = 0.0;
      break;
    default:
LABEL_18:
      uint64_t v20 = a3;
      break;
  }

      __break(1u);
      goto LABEL_22;
    }

  __break(1u);
  return result;
}

LABEL_73:
              goto LABEL_74;
            }
          }

          else
          {
            id v83 = (void *)objc_claimAutoreleasedReturnValue([v146 autoAssetEntries]);
            id v84 = -[MADAutoAssetControlManager doesSetDescriptor:coverRequestedAutoAssetEntries:]( self,  "doesSetDescriptor:coverRequestedAutoAssetEntries:",  v73,  v83);

            uint64_t v18 = v151;
            if (!v84) {
              goto LABEL_71;
            }
          }

          v150 = v73;
          id v85 = (void *)objc_claimAutoreleasedReturnValue([v73 clientDomainName]);
          __int128 v86 = +[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v85,  @"FROM_STAGED_FOR_ALL");

          if (!v86)
          {
            v95 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            v96 = (os_log_s *)objc_claimAutoreleasedReturnValue([v95 oslog]);

            uint64_t v59 = v150;
            if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
            {
              v97 = (NSString *)objc_claimAutoreleasedReturnValue([v150 summary]);
              *(_DWORD *)buf = 138543618;
              v164 = v159;
              v165 = 2114;
              v166 = v97;
              _os_log_impl( &dword_0,  v96,  OS_LOG_TYPE_DEFAULT,  "{%{public}@} lock-atomic found newer and latest - newer not from PSUS (vending latest) | newerDownloaded SetDescriptor:%{public}@",  buf,  0x16u);
            }

            goto LABEL_73;
          }

          __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v146 clientDomainName]);
          __int128 v88 = (void *)objc_claimAutoreleasedReturnValue([v146 assetSetIdentifier]);
          __int128 v89 = (void *)objc_claimAutoreleasedReturnValue([v146 autoAssetEntries]);
          LOBYTE(v140) = 1;
          v90 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedPreferringByAtomicInstance:elseByClientDomain:forAssetSetIdentifier:forSetConfiguration:requestedAutoAssetEntries:performingNoWait:creatingIfPreviouslyStagedFound:fromLocation:]( self,  "locateSetDescriptorDownloadedPreferringByAtomicInstance:elseByClientDomain:forAssetSetIdenti fier:forSetConfiguration:requestedAutoAssetEntries:performingNoWait:creatingIfPreviouslyStag edFound:fromLocation:",  0LL,  v87,  v88,  v146,  v89,  1LL,  v140,  v159));

          if (v90)
          {
            v91 = v90;

            v92 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            v93 = (os_log_s *)objc_claimAutoreleasedReturnValue([v92 oslog]);

            uint64_t v18 = v151;
            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
            {
              v94 = (NSString *)objc_claimAutoreleasedReturnValue([v37 summary]);
              *(_DWORD *)buf = 138543618;
              v164 = v159;
              v165 = 2114;
              v166 = v94;
              _os_log_impl( &dword_0,  v93,  OS_LOG_TYPE_DEFAULT,  "{%{public}@} lock-atomic found newer(PSUS) and latest - vending new from PSUS | chosenDownloadedSetDescr iptor:%{public}@",  buf,  0x16u);
            }

            uint64_t v22 = v146;
          }

          else
          {
            v138 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            v139 = (os_log_s *)objc_claimAutoreleasedReturnValue([v138 oslog]);

            uint64_t v18 = v151;
            if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR)) {
              -[MADAutoAssetControlManager handleSetClientLockAtomic:forAutoJob:instance:desire:fromLocation:].cold.1();
            }

            uint64_t v22 = v146;
            v93 = (os_log_s *)v150;
          }

          uint64_t v59 = v90;
          if (v90) {
            goto LABEL_74;
          }
        }

        else
        {
          if (!v37) {
            goto LABEL_50;
          }
          if (v59)
          {
LABEL_74:
            if (!+[MADAutoAssetSecure isPersonalizationRequired:forSetDescriptor:]( &OBJC_CLASS___MADAutoAssetSecure,  "isPersonalizationRequired:forSetDescriptor:",  v159,  v59))
            {
              v101 = v59;

              v102 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              v103 = (os_log_s *)objc_claimAutoreleasedReturnValue([v102 oslog]);

              if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
              {
                v104 = (NSString *)objc_claimAutoreleasedReturnValue([v101 summary]);
                *(_DWORD *)buf = 138543618;
                v164 = v159;
                v165 = 2114;
                v166 = v104;
                _os_log_impl( &dword_0,  v103,  OS_LOG_TYPE_DEFAULT,  "{%{public}@} lock-atomic found newer (not awaiting any secure operation) | chosenDownloadedSetDescriptor:%{public}@",  buf,  0x16u);
              }

              v148 = v101;
              __int128 v37 = v101;
              goto LABEL_79;
            }

            -[MADAutoAssetControlManager securePersonalizeGraftLockSet:lockingSetDescriptor:forEventInfo:fallingBackToSetDescriptor:]( self,  "securePersonalizeGraftLockSet:lockingSetDescriptor:forEventInfo:fallingBackToSetDescriptor:",  v159,  v59,  v11,  v37);

LABEL_83:
            v51 = 0;
            goto LABEL_84;
          }
        }

        v148 = 0LL;
        goto LABEL_79;
      }
    }

    uint64_t v59 = 0LL;
    goto LABEL_34;
  }

  unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v13 clientAssetSetPolicy]);
  __int128 v34 = [v33 supportingShortTermLocks];

  id v31 = 0;
  if (v34) {
    uint64_t v30 = @"lockAtomic[NO_WAIT][SUPPORTING-SHORT-TERM]";
  }
  else {
    uint64_t v30 = @"lockAtomic[NO_WAIT]";
  }
  id v32 = 1;
  if (!v23) {
    goto LABEL_11;
  }
LABEL_21:
  v47 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@ requested when device is before first-unlock",  v30);
  v48 = self;
  unsigned __int8 v49 = v11;
  v50 = 6101LL;
LABEL_23:
  -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( v48,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v49,  v50,  v159,  v47);

  v51 = 0;
LABEL_85:

  return v51;
}

LABEL_26:
              goto LABEL_27;
            }

            ++v106;
            if (!v119) {
              goto LABEL_27;
            }
            uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v120, "logger"));
            __int128 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue([v46 oslog]);

            if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_26;
            }
            v109 = (id)objc_claimAutoreleasedReturnValue([v12 fullAssetSelector]);
            __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v109 summary]);
            __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v18 fullAssetSelector]);
            __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v36 summary]);
            *(_DWORD *)buf = 138543618;
            v134 = (uint64_t)v35;
            v135 = 2114;
            v136 = (uint64_t)v37;
            id v38 = v34;
            id v39 = "\n{chooseNewerSetStatus} | leftRightSame | left:%{public}@ | right:%{public}@";
          }

        v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "jobsBySelector", v45));
        [v41 removeObjectForKey:v48];

        if (v49)
        {
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) persistedState]);
          [v42 removePersistedEntry:v51 fromLocation:@"forceGlobalForget"];

          uint64_t v43 = *(void **)(a1 + 32);
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v24 assetSelector]);
          [v43 _logPersistedRemovedEntry:@"forceGlobalForget" removedSelector:v44 message:@"forgot scheduled job"];
        }

        objc_autoreleasePoolPop(obja);
        uint64_t v21 = v55 + 1;
      }

      while ((id)(v55 + 1) != v46);
      uint64_t v46 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v47,  "countByEnumeratingWithState:objects:count:",  &v56,  v64,  16LL);
    }

    while (v46);
  }
}

  *(_WORD *)&v19->_awaitingSchedulerAck = 0;
  v19->_awaitingStagerAck = 0;
  v19->_awaitingSecureOperations = 0;
  uint64_t v45 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  activeJobsByUUID = v19->_activeJobsByUUID;
  v19->_activeJobsByUUID = v45;

  v19->_limitedToCancelActivity = 0;
LABEL_27:
  v47 = v19;
  uint64_t v24 = v15;
  uint64_t v21 = (__CFString *)v54;
LABEL_30:

  return v47;
}

              objc_autoreleasePoolPop(v16);
              uint64_t v14 = (char *)v14 + 1;
            }

            while (v14 != v12);
            __int128 v37 = [obj countByEnumeratingWithState:&v51 objects:v61 count:16];
            uint64_t v12 = v37;
          }

          while (v37);
        }

        id v38 = objc_alloc(&OBJC_CLASS___MADAutoAssetStagerParam);
        id v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStagerParam baseForStagingDescriptors](v7, "baseForStagingDescriptors"));
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStagerParam operationError](v7, "operationError"));
        uint64_t v8 = -[MADAutoAssetStagerParam initWithAutoAssetCatalog:withBaseForStagingDescriptors:withOperationError:]( v38,  "initWithAutoAssetCatalog:withBaseForStagingDescriptors:withOperationError:",  v49,  v39,  v40);

        v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStagerParam jobInformation](v7, "jobInformation"));
        if (v41)
        {
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
          uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            -[MADAutoAssetStager _adjustPallasResponseBasedOnPreferences:].cold.1(v7);
          }
        }
      }
    }
  }

  return v8;
}

  [obj addObject:v7];
  v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v57, "logger"));
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue([v48 oslog]);

  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v57, "summary"));
    v50 = v7;
    v51 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
    *(_DWORD *)buf = 138543618;
    uint64_t v65 = v49;
    uint64_t v66 = 2114;
    uint64_t v67 = v51;
    _os_log_impl( &dword_0,  v12,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[AUTO-STAGER] {_maintainLatestCandidate} accepted as candidate | descriptor:%{public}@",  buf,  0x16u);

    uint64_t v7 = v50;
  }

  uint64_t v6 = v56;
LABEL_37:
}

LABEL_27:
      -[MADAutoAssetControlManager _scheduledAndRouteClientRequest:fromLocation:]( self,  "_scheduledAndRouteClientRequest:fromLocation:",  v5,  @"QueueClientRequestBefore1st");
      goto LABEL_32;
    }

    v47 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
    uint64_t v46 = -[NSString initWithFormat:]( v47,  "initWithFormat:",  @"invalid eventInfo (instance:MISSING)| eventInfo:%@",  v45);
LABEL_30:
    v48 = v46;
    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v5,  6102LL,  @"QueueClientRequestBefore1st",  v46);

    goto LABEL_31;
  }

  CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager clientRequestMessageSetInstance:withEventInfo:]( self,  "clientRequestMessageSetInstance:withEventInfo:",  @"QueueClientRequestBefore1st",  v5));
  if (!v11)
  {
    uint64_t v44 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
    uint64_t v46 = -[NSString initWithFormat:]( v44,  "initWithFormat:",  @"invalid set-eventInfo (instance:MISSING) | set-eventInfo:%@",  v45);
    goto LABEL_30;
  }

  if (-[MADAutoAssetControlManager _isClientRequestSubjectToElimination:]( self,  "_isClientRequestSubjectToElimination:",  v5)
    && -[MADAutoAssetControlManager _setInstanceBeingEliminated:fromLocation:]( self,  "_setInstanceBeingEliminated:fromLocation:",  v11,  @"QueueClientRequestBefore1st"))
  {
    uint64_t v12 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 summary]);
    uint64_t v15 = -[NSString initWithFormat:]( v12,  "initWithFormat:",  @"in-progress elimination blocking new set-request | clientRequest:%@",  v14);
    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v5,  6114LL,  @"QueueClientRequestBefore1st",  v15);

    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    CFRange v17 = (os_log_s *)objc_claimAutoreleasedReturnValue([v16 oslog]);

    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager action_QueueClientRequestBefore1st:error:].cold.1(v5);
    }
LABEL_15:

    goto LABEL_31;
  }

  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager clientRequestMessageName:](self, "clientRequestMessageName:", v29));
  id v31 = -[MADAutoAssetControlManager _messageBlockedUntilFirstUnlock:forSetInstance:]( self,  "_messageBlockedUntilFirstUnlock:forSetInstance:",  v30,  v11);

  if (!v31) {
    goto LABEL_26;
  }
  id v32 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager clientRequestMessageName:](self, "clientRequestMessageName:", v32));

  if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v18,  @"MA-AUTO-SET:CHECK_ATOMIC") & 1) == 0 && !+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v18,  @"MA-AUTO-SET:LOCK_ATOMIC"))
  {
    if (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v18,  @"MA-AUTO:MAP_LOCKED_CONTENT_TO_EXCLAVE"))
    {
      -[MADAutoAssetControlManager handleClientMapLockedToExclaveRequest:fromLocation:]( self,  "handleClientMapLockedToExclaveRequest:fromLocation:",  v5,  @"QueueClientRequestBefore1st");
      goto LABEL_9;
    }

    goto LABEL_39;
  }

  uint64_t v58 = 0LL;
  unsigned int v33 = -[MADAutoAssetControlManager setConfigurationSelectUsingInfoInstance:dueToMessageName:selectedConfig:]( self,  "setConfigurationSelectUsingInfoInstance:dueToMessageName:selectedConfig:",  v11,  v18,  &v58);
  if (v33)
  {
    __int128 v34 = v33;
    __int128 v35 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unable to determine valid set-configuration when REQUIRED for operation [%@]",  v18);
    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v5,  v34,  @"QueueClientRequestBefore1st",  v35);

    __int128 v36 = 0;
    __int128 v37 = 1;
  }

  else
  {
    __int128 v37 = -[MADAutoAssetControlManager handleClientPotentialSetJob:forAutoJob:fromLocation:]( self,  "handleClientPotentialSetJob:forAutoJob:fromLocation:",  v5,  0LL,  @"QueueClientRequestBefore1st");
    __int128 v36 = v37;
  }

  if ((v36 & 1) != 0)
  {
    if ((v37 & 1) != 0) {
      goto LABEL_40;
    }
    goto LABEL_27;
  }

        objc_autoreleasePoolPop(v48);
        uint64_t v13 = (char *)v13 + 1;
      }

      while (v44 != v13);
      __int128 v35 = [v10 countByEnumeratingWithState:&v49 objects:v53 count:16];
      uint64_t v44 = v35;
    }

    while (v35);
  }

  return v11;
}
            }
          }

          uint64_t v20 = v41;
        }

        objc_autoreleasePoolPop(v24);
      }

      uint64_t v43 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v20,  "countByEnumeratingWithState:objects:count:",  &v45,  v57,  16LL);
    }

    while (v43);
  }
}

  unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v7 atomicInstanceUUID]);
  __int128 v34 = self;
  __int128 v35 = 227LL;
LABEL_34:
  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceNewSetAtomicInstance:recordingHistoryOperation:forSetInfoInstance:asSubAtomicFrom:]( v34,  "atomicInstanceNewSetAtomicInstance:recordingHistoryOperation:forSetInfoInstance:asSubAtomicFrom:",  @"atomicInstanceNewSubAtomicFromAtomic",  v35,  v8,  v33));

  id v39 = 0LL;
LABEL_35:

  if (v39)
  {
LABEL_36:

    uint64_t v40 = 0LL;
    if (a5) {
      *a5 = v39;
    }
  }

  uint64_t v7 = v33;
LABEL_27:

  return v16 & 1;
}

      objc_autoreleasePoolPop(v13);
      CFIndex v11 = (char *)v11 + 1;
    }

    while (v10 != v11);
    uint64_t v54 = [v8 countByEnumeratingWithState:&v119 objects:v132 count:16];
    uint64_t v10 = v54;
  }

  while (v54);
LABEL_48:

  v117 = 0u;
  v118 = 0u;
  v115 = 0u;
  v116 = 0u;
  uint64_t v55 = v97;
  v99 = v55;
  contexta = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v115,  v124,  16LL);
  if (contexta)
  {
    v56 = *(void *)v116;
    v106 = *(void *)v116;
    do
    {
      for (uint64_t i = 0LL; i != contexta; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v116 != v56) {
          objc_enumerationMutation(v55);
        }
        uint64_t v58 = *(void *)(*((void *)&v115 + 1) + 8LL * (void)i);
        uint64_t v59 = objc_autoreleasePoolPush();
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedDownloadedSetDescriptors]( self,  "persistedDownloadedSetDescriptors"));
        v61 = (void *)objc_claimAutoreleasedReturnValue( [v60 persistedEntry:v58 fromLocation:@"loadPersistedSetDownloadedDescriptors"]);

        v62 = [v61 secureCodedObjectForKey:@"assetSetDescriptor" ofClass:objc_opt_class(MADAutoSetDescriptor)];
        id v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
        if (v63)
        {
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager setDescriptorDedupDownloadedEntries:forSetDescriptor:]( self,  "setDescriptorDedupDownloadedEntries:forSetDescriptor:",  @"loadPersistedSetDownloadedDescriptors",  v63));
          if (v64)
          {
            -[MADAutoAssetControlManager persistSetDescriptorDownloadedJob:fromLocation:]( self,  "persistSetDescriptorDownloadedJob:fromLocation:",  v64,  @"loadPersistedSetDownloadedDescriptors");
            uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue([v65 oslog]);

            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v64 summary]);
              *(_DWORD *)buf = 138543618;
              v126 = v67;
              v127 = 2114;
              v128 = v68;
              _os_log_impl( &dword_0,  v66,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {loadPersistedSetDownloadedDescriptors}\n[SELF-HEAL] deduped setDescriptor:%{public}@",  buf,  0x16u);

              uint64_t v55 = v99;
            }

            v56 = v106;
          }
        }

        objc_autoreleasePoolPop(v59);
      }

      contexta = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v115,  v124,  16LL);
    }

    while (contexta);
  }

  v113 = 0u;
  v114 = 0u;
  v111 = 0u;
  v112 = 0u;
  uint64_t v69 = v102;
  v107 = -[os_log_s countByEnumeratingWithState:objects:count:]( v69,  "countByEnumeratingWithState:objects:count:",  &v111,  v123,  16LL);
  if (v107)
  {
    v103 = *(void *)v112;
    uint64_t v70 = @"loadPersistedSetDownloadedDescriptors";
    v101 = v69;
    do
    {
      for (j = 0LL; j != v107; j = (char *)j + 1)
      {
        if (*(void *)v112 != v103) {
          objc_enumerationMutation(v69);
        }
        id v72 = *(void *)(*((void *)&v111 + 1) + 8LL * (void)j);
        contextb = objc_autoreleasePoolPush();
        v73 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedDownloadedSetDescriptors]( self,  "persistedDownloadedSetDescriptors"));
        uint64_t v74 = v70;
        id v75 = (void *)objc_claimAutoreleasedReturnValue([v73 persistedEntry:v72 fromLocation:v70]);

        id v76 = [v75 secureCodedObjectForKey:@"assetSetDescriptor" ofClass:objc_opt_class(MADAutoSetDescriptor)];
        id v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
        v78 = (void *)objc_claimAutoreleasedReturnValue([v77 clientDomainName]);
        v79 = (void *)objc_claimAutoreleasedReturnValue([v77 assetSetIdentifier]);
        v80 = (void *)objc_claimAutoreleasedReturnValue([v77 latestDownloadedAtomicInstance]);
        v81 = (void *)objc_claimAutoreleasedReturnValue( +[MANAutoAssetSetStatus shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:]( &OBJC_CLASS___MANAutoAssetSetStatus,  "shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:",  v78,  v79,  v80));

        if (-[MADAutoAssetControlManager setDescriptorLocked:](self, "setDescriptorLocked:", v77))
        {
          uint64_t v82 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          id v83 = v82;
          if (v77) {
            -[NSMutableArray addObject:](v82, "addObject:", v77);
          }
          id v84 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetLocker eliminateAllPreviousSetLocksNoLongerTracked:]( &OBJC_CLASS___MADAutoAssetLocker,  "eliminateAllPreviousSetLocksNoLongerTracked:",  v83));
          id v85 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          __int128 v86 = (os_log_s *)objc_claimAutoreleasedReturnValue([v85 oslog]);

          __int128 v87 = os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
          if (v84)
          {
            if (v87)
            {
              __int128 v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              __int128 v89 = [v84 count];
              *(_DWORD *)buf = 138543618;
              v126 = v88;
              v127 = 2048;
              v128 = v89;
              v90 = v86;
              v91 = "[%{public}@] {loadPersistedSetDownloadedDescriptors} just unlocked selectors:%ld";
              v92 = 22;
              goto LABEL_74;
            }
          }

          else if (v87)
          {
            __int128 v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543362;
            v126 = v88;
            v90 = v86;
            v91 = "[%{public}@] {loadPersistedSetDownloadedDescriptors} no selectors just unlocked";
            v92 = 12;
LABEL_74:
            _os_log_impl(&dword_0, v90, OS_LOG_TYPE_DEFAULT, v91, buf, v92);
          }

          uint64_t v69 = v101;
        }

        uint64_t v70 = v74;
        -[MADAutoAssetControlManager secureCheckUngraftAll:forSetDescriptorNoLongerLocked:]( self,  "secureCheckUngraftAll:forSetDescriptorNoLongerLocked:",  v74,  v77);
        -[MADAutoAssetControlManager removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:]( self,  "removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:",  v77,  v74,  0LL,  0LL,  329LL,  373LL);
        v93 =  -[MADAutoAssetControlManager _shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:]( self,  "_shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:",  v74,  v81,  v104,  @"atomic-instance shared lock directory (eliminated set-identifier)");

        objc_autoreleasePoolPop(contextb);
      }

      v107 = -[os_log_s countByEnumeratingWithState:objects:count:]( v69,  "countByEnumeratingWithState:objects:count:",  &v111,  v123,  16LL);
    }

    while (v107);
  }

  uint64_t v7 = v96;
LABEL_81:

  -[MADAutoAssetControlManager _logPersistedSetDescriptorTableOfContents:forComponentType:]( self,  "_logPersistedSetDescriptorTableOfContents:forComponentType:",  @"loadPersistedSetDownloadedDescriptors",  @"SET_DOWNLOADED_DESCRIPTORS");
}

            uint64_t v13 = v27;
            uint64_t v16 = v51;
LABEL_29:
            uint64_t v15 = v52;
          }
        }

        else
        {
          id v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          CC_SHA1_CTX v23 = (void *)objc_claimAutoreleasedReturnValue([v31 oslog]);

          if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            uint64_t v70 = v54;
            uint64_t v71 = 2114;
            id v72 = v18;
            _os_log_error_impl( &dword_0,  (os_log_t)v23,  OS_LOG_TYPE_ERROR,  "{%{public}@} unable to load persisted entry | entryID:%{public}@",  buf,  0x16u);
          }
        }

        goto LABEL_32;
      }

      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v30 oslog]);

      if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        uint64_t v70 = v54;
        _os_log_error_impl(&dword_0, (os_log_t)v21, OS_LOG_TYPE_ERROR, "{%{public}@} no entryID", buf, 0xCu);
      }
}
          }
        }

        else
        {
          uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
          uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue([v66 oslog]);

          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
            uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
            v47 = (void *)objc_claimAutoreleasedReturnValue([v46 assetSpecifier]);
            v48 = (void *)objc_claimAutoreleasedReturnValue([v35 assetSpecifier]);
            unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([v35 summary]);
            *(_DWORD *)buf = 138544130;
            v205 = v45;
            v206 = 2114;
            v207 = v47;
            v208 = 2114;
            v209 = v48;
            v210 = 2114;
            v211 = v49;
            v50 = v44;
            v51 = "%{public}@ | {ReportCatalogDecideFound} filtering out asset (specifier mismatch) | [specifier]required"
                  ":%{public}@ != metadata:%{public}@ | filtered:%{public}@";
LABEL_39:
            _os_log_impl(&dword_0, v50, OS_LOG_TYPE_DEFAULT, v51, buf, 0x2Au);

            self = v191;
          }

        objc_autoreleasePoolPop(v15);
      }

      uint64_t v42 = [v10 countByEnumeratingWithState:&v43 objects:v47 count:16];
    }

    while (v42);
  }

  return v12;
}

  if (isDownloadResultSuggestingTryAgainLater(a1)) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"tryAgainLater");
  }
  if (a1 <= 0x18 && ((1LL << a1) & 0x1002306) != 0) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"retryWithBackoff");
  }
  if (isDownloadResultSuggestingCheckConfiguration(a1)) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"checkConfiguration");
  }
  if (a1 <= 0x23)
  {
    if (((1LL << a1) & 0x900000108LL) != 0)
    {
      uint64_t v21 = @"generic";
LABEL_40:
      -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, v21);
      goto LABEL_41;
    }

    if (a1 == 18)
    {
      uint64_t v21 = @"pallasNoPMVMatchFound";
      goto LABEL_40;
    }
  }

  if (a1 == 75)
  {
    uint64_t v21 = @"checkSSO";
    goto LABEL_40;
  }

  id v38 = v17;

  return v38;
}

  __break(1u);
  return result;
}

LABEL_62:
                  id v83 = v122;
LABEL_64:

                  goto LABEL_65;
                }

  v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue([v73 oslog]);

  if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
    -[MADAutoAssetStager newAssetMetadataFromAssetCatalog:forAssetype:forAssetSpecifier:].cold.1();
  }
LABEL_64:

  id v85 = 0LL;
LABEL_65:

  return v85;
}

        uint64_t v7 = 51LL;
LABEL_65:

        goto LABEL_66;
      case 0xFFFFFFFFFFFFFC18LL:
        uint64_t v14 = 0LL;
        uint64_t v15 = 0LL;
        uint64_t v7 = 49LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC19LL:
        uint64_t v14 = 0LL;
        uint64_t v15 = 0LL;
        uint64_t v7 = 48LL;
        goto LABEL_65;
      default:
        if (v13 == (id)-2000LL) {
          uint64_t v7 = 57LL;
        }
        uint64_t v14 = 0LL;
        uint64_t v15 = 0LL;
        goto LABEL_65;
    }
  }

  switch(a1)
  {
    case 400:
      uint64_t v7 = 40LL;
      uint64_t v8 = 40LL;
      if (v5) {
        goto LABEL_23;
      }
      break;
    case 401:
      uint64_t v7 = 41LL;
      uint64_t v8 = 41LL;
      if (v5) {
        goto LABEL_23;
      }
      break;
    case 403:
      uint64_t v7 = 43LL;
      uint64_t v8 = 43LL;
      goto LABEL_22;
    case 404:
      uint64_t v7 = 44LL;
      uint64_t v8 = 44LL;
      if (v5) {
        goto LABEL_23;
      }
      break;
    default:
      goto LABEL_8;
  }

LABEL_63:
                id v83 = v122;
                goto LABEL_64;
              }

              ++v106;
              if (!v119) {
                goto LABEL_63;
              }
              __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v120, "logger"));
              id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue([v87 oslog]);

              if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_62;
              }
              v105 = (void *)objc_claimAutoreleasedReturnValue([v56 fullAssetSelector]);
              v73 = (void *)objc_claimAutoreleasedReturnValue([v105 summary]);
              uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
              id v75 = (void *)objc_claimAutoreleasedReturnValue([v74 summary]);
              *(_DWORD *)buf = v104;
              v134 = (uint64_t)v73;
              v135 = 2112;
              v136 = (uint64_t)v75;
              id v76 = v72;
              id v77 = "\n{chooseNewerSetStatus} | leftRightSame | left:%@ | right:%@";
            }

        goto LABEL_64;
      }
    }

    else
    {
    }

    uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
    v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v70 oslog]);

    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      v51 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
      *(_DWORD *)buf = 138543618;
      v91 = v50;
      v92 = 2114;
      v93 = v51;
      uint64_t v52 = "%{public}@ | {addToActiveJobTasks} first auto-asset-encountered [remaining] discretionary | job:%{public}@}";
      goto LABEL_51;
    }

    goto LABEL_63;
  }

  v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v11 clientAssetPolicy]);
  v48 = -[MADAutoAssetJob boostedToUserInitiated](self, "boostedToUserInitiated");

  if ((v48 & 1) == 0)
  {
    -[MADAutoAssetJob desireChangedToUserInitiated](self, "desireChangedToUserInitiated");
    unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
    v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v49 oslog]);

    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      v51 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
      *(_DWORD *)buf = 138543618;
      v91 = v50;
      v92 = 2114;
      v93 = v51;
      uint64_t v52 = "%{public}@ | {addToActiveJobTasks} additional auto-asset-policy | boosted to user-initiated | job:%{public}@}";
LABEL_51:
      _os_log_impl(&dword_0, v47, OS_LOG_TYPE_DEFAULT, v52, buf, 0x16u);

      goto LABEL_63;
    }

    goto LABEL_63;
  }

LABEL_60:
            _os_log_impl(&dword_0, v76, OS_LOG_TYPE_DEFAULT, v77, buf, 0x16u);
            self = v120;
          }

          else
          {
            self = v120;
            id v84 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v120, "logger"));
            id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue([v84 oslog]);

            if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
              goto LABEL_62;
            }
            v73 = (void *)objc_claimAutoreleasedReturnValue([v56 summary]);
            id v85 = (void *)objc_claimAutoreleasedReturnValue([v51 summary]);
            *(_DWORD *)buf = 138543618;
            v134 = (uint64_t)v73;
            v135 = 2114;
            v136 = (uint64_t)v85;
            _os_log_error_impl( &dword_0,  v72,  OS_LOG_TYPE_ERROR,  "\n {chooseNewerSetStatus} ignoring (invalid restore version) | foundLeftEntry:%{public}@ | nextRightEntry:%{public}@",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        ++v112;
        if (!v119)
        {
          id v83 = v122;
          goto LABEL_66;
        }

        v78 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v65 = (id)objc_claimAutoreleasedReturnValue([v78 oslog]);

        if (os_log_type_enabled((os_log_t)v65, OS_LOG_TYPE_DEFAULT))
        {
          v79 = (void *)objc_claimAutoreleasedReturnValue([0 fullAssetSelector]);
          v80 = (void *)objc_claimAutoreleasedReturnValue([v79 summary]);
          v81 = (void *)objc_claimAutoreleasedReturnValue([v51 fullAssetSelector]);
          uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v81 summary]);
          *(_DWORD *)buf = 138543618;
          v134 = (uint64_t)v80;
          v135 = 2114;
          v136 = (uint64_t)v82;
          _os_log_impl( &dword_0,  (os_log_t)v65,  OS_LOG_TYPE_DEFAULT,  "\n{chooseNewerSetStatus} | leftNotPresent | left:%{public}@ | right:%{public}@",  buf,  0x16u);
        }

        id v83 = v122;
LABEL_65:

LABEL_66:
        if (!v61) {
          ++v49;
        }

        objc_autoreleasePoolPop(v83);
      }

      v118 = [v110 countByEnumeratingWithState:&v125 objects:v147 count:16];
      if (!v118) {
        goto LABEL_72;
      }
    }
  }

  v112 = 0LL;
LABEL_72:

  if (v108 > 0 || v112)
  {
    v90 = v116;
    if (v107 <= 0 && !v111)
    {
      v92 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v92 oslog]);

      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134219520;
        v134 = v112;
        v135 = 2048;
        v136 = v123;
        v137 = 2048;
        v138 = v107;
        v139 = 2048;
        v140 = 0LL;
        v141 = 2048;
        v142 = v49;
        v143 = 2048;
        v144 = v108;
        v145 = 2048;
        v146 = v106;
        v93 = "\n"
              "{chooseNewerSetStatus} right chosen | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, (right)NotPresen"
              "t:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
LABEL_86:
        _os_log_impl(&dword_0, v89, OS_LOG_TYPE_DEFAULT, v93, buf, 0x48u);
        goto LABEL_87;
      }

      goto LABEL_87;
    }

    if (v107 <= v108)
    {
      if (v108 > v107)
      {
        v95 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v95 oslog]);

        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134219520;
          v134 = v112;
          v135 = 2048;
          v136 = v123;
          v137 = 2048;
          v138 = v107;
          v139 = 2048;
          v140 = v111;
          v141 = 2048;
          v142 = v49;
          v143 = 2048;
          v144 = v108;
          v145 = 2048;
          v146 = v106;
          v93 = "\n"
                "{chooseNewerSetStatus} decided right (more newer) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, "
                "(right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
          goto LABEL_86;
        }

LABEL_61:
        id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
        v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v75 oslog]);

        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          id v76 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
          id v77 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob aggregatedClientSetPolicy](self, "aggregatedClientSetPolicy"));
          v78 = (void *)objc_claimAutoreleasedReturnValue([v77 summary]);
          v79 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
          *(_DWORD *)buf = 138543874;
          v91 = v76;
          v92 = 2114;
          v93 = v78;
          v94 = 2114;
          v95 = v79;
          _os_log_impl( &dword_0,  v47,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {addToActiveJobTasks} SET-POLICY | aggregatedClientSetPolicy:%{public}@ | job:%{public}@}",  buf,  0x20u);
        }

        goto LABEL_63;
      }
    }

    else
    {
    }

    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
    v61 = (void *)objc_claimAutoreleasedReturnValue([v74 oslog]);

    if (os_log_type_enabled((os_log_t)v61, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
      *(_DWORD *)buf = 138543618;
      v91 = v64;
      v92 = 2114;
      v93 = v65;
      uint64_t v66 = "%{public}@ | {addToActiveJobTasks} first auto-asset-set-encountered [remaining] discretionary | job:%{public}@}";
      goto LABEL_59;
    }

    goto LABEL_60;
  }

  v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
  uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue([v41 oslog]);

  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v11 clientAssetPolicy]);
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v44 summary]);
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
    *(_DWORD *)buf = 138543874;
    v91 = v43;
    v92 = 2114;
    v93 = v45;
    v94 = 2114;
    v95 = v46;
    _os_log_impl( &dword_0,  v42,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {addToActiveJobTasks} aggregating | clientAssetPolicy:%{public}@ | job:%{public}@}",  buf,  0x20u);
  }

  if (!-[MADAutoAssetJob aggregatedClientAssetPolicySpecified](self, "aggregatedClientAssetPolicySpecified"))
  {
    -[MADAutoAssetJob setAggregatedClientAssetPolicySpecified:](self, "setAggregatedClientAssetPolicySpecified:", 1LL);
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v11 clientAssetPolicy]);
    if ([v67 userInitiated])
    {
      uint64_t v68 = -[MADAutoAssetJob boostedToUserInitiated](self, "boostedToUserInitiated");

      if ((v68 & 1) == 0)
      {
        -[MADAutoAssetJob desireChangedToUserInitiated](self, "desireChangedToUserInitiated");
        uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
        v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v69 oslog]);

        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
          v51 = (void *)objc_claimAutoreleasedReturnValue([v4 summary]);
          *(_DWORD *)buf = 138543618;
          v91 = v50;
          v92 = 2114;
          v93 = v51;
          uint64_t v52 = "%{public}@ | {addToActiveJobTasks} first auto-asset-policy encountered indicating user-initiated | job:%{public}@}";
          goto LABEL_51;
        }

LABEL_87:
        v96 = v116;
        v97 = v115;
        __int128 v89 = (os_log_s *)v115;
        goto LABEL_108;
      }

      if (v111 < 1 || v112 > 0)
      {
        if (v112 < 1 || v111 > 0)
        {
          if (v49 < 1 || v123 > 0)
          {
            v101 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger", v104));
            __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v101 oslog]);

            v102 = os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT);
            if (v123 >= 1 && v49 <= 0)
            {
              if (!v102) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 134219520;
              v134 = v112;
              v135 = 2048;
              v136 = v123;
              v137 = 2048;
              v138 = v107;
              v139 = 2048;
              v140 = v111;
              v141 = 2048;
              v142 = v49;
              v143 = 2048;
              v144 = v108;
              v145 = 2048;
              v146 = v106;
              v93 = "\n"
                    "{chooseNewerSetStatus} decided right (left not configured) | (left)NotPresent:%ld,NotConfigured:%ld,"
                    "IsNewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
              goto LABEL_86;
            }

            if (!v102) {
              goto LABEL_107;
            }
            *(_DWORD *)buf = 134219520;
            v134 = v112;
            v135 = 2048;
            v136 = v123;
            v137 = 2048;
            v138 = v107;
            v139 = 2048;
            v140 = v111;
            v141 = 2048;
            v142 = v49;
            v143 = 2048;
            v144 = v108;
            v145 = 2048;
            v146 = v106;
            v91 = "\n"
                  "{chooseNewerSetStatus} decided left (mixed results) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%"
                  "ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
          }

          else
          {
            v100 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v100 oslog]);

            if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_107;
            }
            *(_DWORD *)buf = 134219520;
            v134 = v112;
            v135 = 2048;
            v136 = v123;
            v137 = 2048;
            v138 = v107;
            v139 = 2048;
            v140 = v111;
            v141 = 2048;
            v142 = v49;
            v143 = 2048;
            v144 = v108;
            v145 = 2048;
            v146 = v106;
            v91 = "\n"
                  "{chooseNewerSetStatus} decided left (right not configured) | (left)NotPresent:%ld,NotConfigured:%ld,Is"
                  "Newer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
          }
        }

        else
        {
          v99 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v99 oslog]);

          if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_107;
          }
          *(_DWORD *)buf = 134219520;
          v134 = v112;
          v135 = 2048;
          v136 = v123;
          v137 = 2048;
          v138 = v107;
          v139 = 2048;
          v140 = v111;
          v141 = 2048;
          v142 = v49;
          v143 = 2048;
          v144 = v108;
          v145 = 2048;
          v146 = v106;
          v91 = "\n"
                "{chooseNewerSetStatus} decided right (left not present) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer"
                ":%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
        }
      }

      else
      {
        v98 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v98 oslog]);

        if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 134219520;
        v134 = v112;
        v135 = 2048;
        v136 = v123;
        v137 = 2048;
        v138 = v107;
        v139 = 2048;
        v140 = v111;
        v141 = 2048;
        v142 = v49;
        v143 = 2048;
        v144 = v108;
        v145 = 2048;
        v146 = v106;
        v91 = "\n"
              "{chooseNewerSetStatus} decided left (right not present) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%"
              "ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
      }
    }

    else
    {
      v94 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v94 oslog]);

      if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 134219520;
      v134 = v112;
      v135 = 2048;
      v136 = v123;
      v137 = 2048;
      v138 = v107;
      v139 = 2048;
      v140 = v111;
      v141 = 2048;
      v142 = v49;
      v143 = 2048;
      v144 = v108;
      v145 = 2048;
      v146 = v106;
      v91 = "\n"
            "{chooseNewerSetStatus} decided left (more newer) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, (righ"
            "t)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
    }

LABEL_106:
    _os_log_impl(&dword_0, v89, OS_LOG_TYPE_DEFAULT, v91, buf, 0x48u);
    goto LABEL_107;
  }

  __int128 v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  __int128 v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v88 oslog]);

  v90 = v116;
  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134219520;
    v134 = 0LL;
    v135 = 2048;
    v136 = v123;
    v137 = 2048;
    v138 = v107;
    v139 = 2048;
    v140 = v111;
    v141 = 2048;
    v142 = v49;
    v143 = 2048;
    v144 = v108;
    v145 = 2048;
    v146 = v106;
    v91 = "\n"
          "{chooseNewerSetStatus} left chosen | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, (right)NotPresent:%ld"
          ",NotConfigured:%ld,IsNewer:%ld, same:%ld";
    goto LABEL_106;
  }

LABEL_107:
  v97 = v115;
  v96 = v115;
LABEL_108:

  return v96;
}

LABEL_12:
  return v8;
}

  return v8;
}

  return v7;
}

  return (char)v7;
}

  uint64_t v27 = v80;
  uint64_t v28 = v78;
  uint64_t v29 = -[MADAutoAssetScheduledJob initForAssetSelector:withActivityInterval:forPushedJob:forSetJob:withSetPolicy:requiringRetry:]( objc_alloc(&OBJC_CLASS___MADAutoAssetScheduledJob),  "initForAssetSelector:withActivityInterval:forPushedJob:forSetJob:withSetPolicy:requiringRetry:",  v80,  v72,  v74,  v76,  v78,  0LL);
  if (v29)
  {
    uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue([v80 persistedEntryID]);
    id v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler persistedState](v79, "persistedState"));
    id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 persistedEntry:v30 fromLocation:@"_scheduleSelector"]);

    [v29 setRemainingSecs:v71];
    unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler jobsAwaitingTrigger](v79, "jobsAwaitingTrigger"));
    [v33 addObject:v29];

    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler jobsBySelector](v79, "jobsBySelector"));
    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v80 persistedEntryID]);
    [v34 setSafeObject:v29 forKey:v35];

    [v32 persistSecureCodedObject:v80 forKey:@"assetSelector"];
    objc_msgSend(v32, "persistULL:forKey:", objc_msgSend(v29, "intervalSecs"), @"intervalSecs");
    objc_msgSend(v32, "persistULL:forKey:", objc_msgSend(v29, "remainingSecs"), @"remainingSecs");
    [v32 persistBoolean:v74 forKey:@"pushJob"];
    [v32 persistBoolean:v76 forKey:@"setJob"];
    __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v29 setPolicy]);

    if (v36)
    {
      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v29 setPolicy]);
      [v32 persistSecureCodedObject:v37 forKey:@"setPolicy"];
    }

    id v38 = (void *)objc_claimAutoreleasedReturnValue([v29 pushedPolicy]);

    if (v38)
    {
      id v39 = (void *)objc_claimAutoreleasedReturnValue([v29 pushedPolicy]);
      [v32 persistSecureCodedObject:v39 forKey:@"pushedPolicy"];
    }

    [v32 persistBoolean:0 forKey:@"requiringRetry"];
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler persistedState](v79, "persistedState"));
    v41 = (void *)objc_claimAutoreleasedReturnValue([v29 summary]);
    [v40 storePersistedEntry:v30 withEntrySummary:v41 fromLocation:@"_scheduleSelector"];

    uint64_t v42 = [v29 intervalSecs];
    uint64_t v43 = [v29 remainingSecs];
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v29 pushedPolicy]);
    LOBYTE(v70) = 0;
    LOBYTE(v69) = v76;
    -[MADAutoAssetScheduler _logPersistedEntry:operation:persistingSelector:intervalSecs:remainingSecs:pushedJob:setJob:setPolicy:pushedPolicy:requiringRetry:message:]( v79,  "_logPersistedEntry:operation:persistingSelector:intervalSecs:remainingSecs:pushedJob:setJob:setPolicy:pushedPolicy :requiringRetry:message:",  @"_scheduleSelector",  @"ENTRY_ADD",  v80,  v42,  v43,  v74,  v69,  v78,  v44,  v70,  @"now tracking scheduled job");

    uint64_t v27 = v80;
    if (a9)
    {
      uint64_t v45 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      -[NSMutableArray addObject:](v45, "addObject:", v80);
      -[MADAutoAssetScheduler _informConnectorTriggeredSelectors:withTriggeredRequiringRetry:]( v79,  "_informConnectorTriggeredSelectors:withTriggeredRequiringRetry:",  0LL,  v45);
    }

    uint64_t v28 = v78;
  }

  else
  {
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler logger](v79, "logger"));
    uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue([v52 oslog]);

    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetScheduler _scheduleSelector:triggeringAtIntervalSecs:withRemainingSecs:forPushedJob:forSetJob:withSetPolicy:triggeringIfLearned:resettingRemaining:].cold.1( v79,  v80,  v30);
    }
  }

LABEL_50:
}

  return (char)v6;
}

  return v7;
}

  return v7;
}

  return (char)v5;
}
}

  return v7;
}

  return (char)v4;
}

  -[MADAutoAssetControlManager issueResponseToFailedAutoAssetLockRequest:forEventInfo:withResponseError:forAttemptedDescriptor:]( self,  "issueResponseToFailedAutoAssetLockRequest:forEventInfo:withResponseError:forAttemptedDescriptor:",  @"IssueClientReplyJobResponse",  v5,  v22,  0LL);

  uint64_t v22 = 0LL;
LABEL_13:
  uint64_t v25 = v64;
LABEL_14:
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v5 fromAutoAssetJob]);

  if (v26)
  {
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v5 fromAutoAssetJob]);
    if ((uint64_t)[v27 clientRequestCount] < 1)
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 diag]);
      id v31 = objc_alloc(&OBJC_CLASS___NSString);
      id v32 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
      unsigned int v33 = -[NSString initWithFormat:]( v31,  "initWithFormat:",  @"auto-job indicating issue-reply when no tracked client-requests | eventInfo:%@",  v32);
      [v30 trackAnomaly:@"AUTO-CONTROL" forReason:v33 withResult:6110 withError:0];
    }

    else
    {
      objc_msgSend(v27, "setClientRequestCount:", (char *)objc_msgSend(v27, "clientRequestCount") - 1);
    }
  }

LABEL_22:
  return 0LL;
}

      uint64_t v13 = (char *)v13 + 1;
    }

    while (v10 != v13);
    uint64_t v10 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
  }

  while (v10);
  uint64_t v24 = 0;
LABEL_15:
  uint64_t v6 = v26;
LABEL_17:

  return v24;
}

  return v8;
}

  return v8;
}

    id v5 = 0LL;
    goto LABEL_17;
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 diag]);
  [v8 trackAnomaly:@"AUTO-CONTROL" forReason:@"{notifyLockerAsIndicatedByJob} [NOTIFY-LOCKER] should never be called for set-job" withResult:6103 withError:0];

  BOOL v9 = objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6103LL,  @"IssueClientReplyJobResponse",  0LL,  @"{notifyLockerAsIndicatedByJob} [NOTIFY-LOCKER] should never be called for set-job"));
  id v5 = (id)v9;
LABEL_18:

  return v5;
}

  return v19 != 0LL;
}

      objc_autoreleasePoolPop(v19);
      CFRange v17 = (char *)v17 + 1;
      p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
      if (v14 == v17)
      {
        uint64_t v14 = [obj countByEnumeratingWithState:&v42 objects:v56 count:16];
        if (v14) {
          goto LABEL_3;
        }
        goto LABEL_14;
      }
    }

LABEL_11:
    goto LABEL_12;
  }

  return (char)v10;
}

        objc_autoreleasePoolPop(v10);
      }

      id v5 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (!v5) {
        goto LABEL_16;
      }
    }
  }

  uint64_t v6 = 0LL;
LABEL_16:

  return v6;
}

  return 0LL;
}

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 assetType]);
  -[NSMutableDictionary setSafeObject:forKey:](v6, "setSafeObject:forKey:", v16, @"AssetType");

  CFRange v17 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 assetSpecifier]);
  -[NSMutableDictionary setSafeObject:forKey:](v6, "setSafeObject:forKey:", v18, @"AssetSpecifier");

  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 assetVersion]);

  if (v20)
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 assetVersion]);
    -[NSMutableDictionary setSafeObject:forKey:](v6, "setSafeObject:forKey:", v22, @"AssetVersion");
  }

  return v6;
}
}
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  return v7;
}

  uint64_t v18 = *(_OWORD *)(a1 + 40);
  uint64_t v12 = stringForMACancelDownloadResult(v7);
  CFRange v17 = (void *)objc_claimAutoreleasedReturnValue(v12);
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager cancelDownload:using:for:assetType:purpose:withExtension:]_block_invoke_2",  @"%@ cancel result for %@ %@ is: %ld (%@ %@)",  v13,  v14,  v15,  v16,  v18);

  sendClientResponse(*(void **)(a1 + 64), *(void **)(a1 + 72), v7);
}

    CFIndex v11 = 0LL;
    return v11;
  }

  if (v6)
  {
    *(_WORD *)uint64_t v13 = 0;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Successfully fetched dsme key", v13, 2u);
  }

  CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  *(void *)buf,  v14,  1LL));
  return v11;
}

    result = ccec_make_pub_from_priv_ws(a1, a2, a5, (uint64_t)&a7[3 * **a7 + 2], 0LL, a7);
    if (!(_DWORD)result)
    {
      if ((~a6 & 9) == 0) {
        ccec_compact_transform_key_ws(a1, a7);
      }
      if (ccec_pairwise_consistency_check_ws( a1,  (unint64_t **)a7,  (uint64_t (**)(void, unint64_t, void *))a5)) {
        return 4294967278LL;
      }
      else {
        return 0LL;
      }
    }

    return result;
  }

  memset(v17, 0, sizeof(v17));
  uint64_t v14 = ((unint64_t)(cczp_bitlen((uint64_t)a2) + 62) >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  uint64_t v15 = a3 - v14;
  result = ccrng_sequence_non_repeat_init( (uint64_t (**)(uint64_t, unint64_t, uint64_t))v17,  (uint64_t (*)(uint64_t, unint64_t, uint64_t))v15,  (uint64_t (*)(uint64_t, unint64_t, uint64_t))&__src[v14]);
  if (!(_DWORD)result)
  {
    result = ccec_generate_scalar_fips_retry_ws(a1, a2, v17, &a7[3 * **a7 + 2]);
    if (!(_DWORD)result) {
      goto LABEL_12;
    }
  }

  return result;
}

  if ((v13 & 0x8000000000000000LL) == 0)
  {
    uint64_t v15 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000LL) == 0) {
      uint64_t v15 = v6 & 0xFFFFFFFFFFFFLL;
    }
    if (v15 < v13) {
      goto LABEL_26;
    }
    result = (v13 << 16) | 4;
    goto LABEL_17;
  }

  if ((v13 & 0x8000000000000000LL) == 0)
  {
    uint64_t v16 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000LL) == 0) {
      uint64_t v16 = v6 & 0xFFFFFFFFFFFFLL;
    }
    if (v16 < v13) {
      goto LABEL_26;
    }
    uint64_t v15 = (v13 << 16) | 4;
    goto LABEL_17;
  }

  __break(1u);
}

  uint64_t v14 = *((void *)v7 + 2);
  if ((*((void *)v7 + 3) >> 1) - v14 < v6) {
    goto LABEL_19;
  }
  memcpy(&v7[8 * v14 + 32], (const void *)(a2 + 8 * a3), 8 * v6);
  if (v6 <= 0)
  {
LABEL_16:
    *CFNumberType v4 = v7;
    return;
  }

  uint64_t v15 = *((void *)v7 + 2);
  uint64_t v16 = __OFADD__(v15, v6);
  CFRange v17 = v15 + v6;
  if (!v16)
  {
    *((void *)v7 + 2) = v17;
    goto LABEL_16;
  }

  uint64_t v14 = *((void *)v7 + 2);
  if ((*((void *)v7 + 3) >> 1) - v14 < v6) {
    goto LABEL_19;
  }
  memcpy(&v7[v14 + 32], (const void *)(a2 + a3), v6);
  if (v6 <= 0)
  {
LABEL_16:
    *CFNumberType v4 = v7;
    return;
  }

  uint64_t v15 = *((void *)v7 + 2);
  uint64_t v16 = __OFADD__(v15, v6);
  CFRange v17 = v15 + v6;
  if (!v16)
  {
    *((void *)v7 + 2) = v17;
    goto LABEL_16;
  }

void sub_1F8BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_48:
  return v15;
}

  return v23;
}

                  uint64_t v10 = v95;
                  goto LABEL_49;
                }

                uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
                uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue([v59 oslog]);

                if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                {
                  v61 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
                  v62 = (void *)objc_claimAutoreleasedReturnValue([v30 summary]);
                  *(_DWORD *)buf = 138543874;
                  v104 = v61;
                  v105 = 2114;
                  v106 = v95;
                  v107 = 2114;
                  v108 = v62;
                  _os_log_impl( &dword_0,  v60,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} patch provided | considering:%{public}@",  buf,  0x20u);

                  uint64_t v10 = v95;
                }

                unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 assetSpecifier]);
                id v63 = v91;
LABEL_42:
                [v63 setSafeObject:v30 forKey:v49];
                goto LABEL_49;
              }

              id v39 = (os_log_s *)objc_claimAutoreleasedReturnValue([v90 safeObjectForKey:v45 ofClass:v46]);

              if (!v39)
              {
                uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
                uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue([v64 oslog]);

                if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
                  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v30 summary]);
                  *(_DWORD *)buf = 138543874;
                  v104 = v66;
                  v105 = 2114;
                  v106 = v95;
                  v107 = 2114;
                  v108 = v67;
                  _os_log_impl( &dword_0,  v65,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} full provided | considering:%{public}@",  buf,  0x20u);

                  uint64_t v10 = v95;
                }

                unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 assetSpecifier]);
                id v63 = v90;
                goto LABEL_42;
              }

              uint64_t v54 = -[MADAutoAssetJob isMorePreferredFormat:comparedTo:]( self,  "isMorePreferredFormat:comparedTo:",  v30,  v39);
              uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
              unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue([v55 oslog]);

              v56 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
              if (v54)
              {
                if (v56)
                {
                  uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
                  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v30 summary]);
                  *(_DWORD *)buf = 138543874;
                  v104 = v57;
                  v105 = 2114;
                  v106 = v95;
                  v107 = 2114;
                  v108 = v58;
                  _os_log_impl( &dword_0,  v49,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} more preferred full provided | now considering:%{public}@",  buf,  0x20u);
                }

                unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 assetSpecifier]);
                uint64_t v53 = v90;
LABEL_35:
                [v53 setSafeObject:v30 forKey:v49];
                goto LABEL_48;
              }

              if (!v56) {
                goto LABEL_48;
              }
              __int128 v89 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
              uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v30 summary]);
              *(_DWORD *)buf = 138543874;
              v104 = v89;
              v105 = 2114;
              uint64_t v10 = v95;
              v106 = v95;
              v107 = 2114;
              v108 = v68;
              uint64_t v69 = v49;
              uint64_t v70 = "%{public}@ | {%{public}@} filtering out asset (additional full of less-preferred format) | filtered:%{public}@";
LABEL_47:
              _os_log_impl(&dword_0, v69, OS_LOG_TYPE_DEFAULT, v70, buf, 0x20u);

LABEL_49:
LABEL_50:
              uint64_t v21 = v93;
            }

            else
            {
              uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
              id v39 = (os_log_s *)objc_claimAutoreleasedReturnValue([v40 oslog]);

              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
                uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v30 assetSpecifier]);
                uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v30 summary]);
                *(_DWORD *)buf = 138544130;
                v104 = v41;
                v105 = 2114;
                v106 = v95;
                v107 = 2114;
                v108 = v42;
                v109 = 2114;
                v110 = v43;
                _os_log_impl( &dword_0,  v39,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} filtering out asset (specifier not requested) | response specifier:%{public} @ | filtered:%{public}@",  buf,  0x2Au);

                uint64_t v10 = v95;
                goto LABEL_50;
              }
            }

            p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
          }

          else
          {
            id v39 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"{%@} auto-asset metadata considered invalid | %@",  v10,  v26);
            -[MADAutoAssetJob trackAnomaly:forReason:](self, "trackAnomaly:forReason:", 6108LL, v39);
          }

          goto LABEL_53;
        }

        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v25 oslog]);

        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v23 safeSummary]);
          *(_DWORD *)buf = 138543874;
          v104 = v27;
          v105 = 2114;
          v106 = v10;
          v107 = 2114;
          v108 = v28;
          _os_log_impl( &dword_0,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} filtering out asset (empty entry) | metadata:%{public}@",  buf,  0x20u);
        }

uint64_t updateClientUsageDate(void *a1)
{
  id v5 = a1;
  uint64_t v21 = 0LL;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2020000000LL;
  char v24 = 0;
  if (v5)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    [v6 timeIntervalSince1970];
    double v8 = v7;

    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v8));
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v9,  0LL,  0LL));

    id v11 = filesystemProtectionQueue();
    uint64_t v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v11);
    v16[0] = (uint64_t)_NSConcreteStackBlock;
    v16[1] = 3221225472LL;
    v16[2] = (uint64_t)__updateClientUsageDate_block_invoke;
    v16[3] = (uint64_t)&unk_34F900;
    double v20 = v8;
    id v18 = v10;
    uint64_t v19 = &v21;
    id v17 = v5;
    id v13 = v10;
    dispatch_sync(v12, v16);
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"updateClientUsageDate",  @"Cannot update client usage with nil location",  v1,  v2,  v3,  v4,  v16[0]);
  }

  uint64_t v14 = *((unsigned __int8 *)v22 + 24);
  _Block_object_dispose(&v21, 8);

  return v14;
}

void sub_27968( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id filesystemProtectionQueue()
{
  if (filesystemProtectionQueue_dispatchOnceFilesystemProtectionQueue != -1) {
    dispatch_once(&filesystemProtectionQueue_dispatchOnceFilesystemProtectionQueue, &__block_literal_global_23);
  }
  return (id)filesystemProtectionQueue___filesystemProtectionQueue;
}

void __updateClientUsageDate_block_invoke(uint64_t a1)
{
  id RefreshDate = filesystemMetadataLastRefreshDate();
  id v11 = (id)objc_claimAutoreleasedReturnValue(RefreshDate);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) absoluteString]);
  uint64_t v4 = -[NSNumber initWithLongLong:]( objc_alloc(&OBJC_CLASS___NSNumber),  "initWithLongLong:",  (uint64_t)*(double *)(a1 + 56));
  id v5 = [v11 safeObjectForKey:v3 ofClass:objc_opt_class(NSNumber)];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  if (v6
    && (double v7 = -[NSNumber longLongValue](v4, "longLongValue"),
        (uint64_t)v7 <= (uint64_t)((char *)[v6 longLongValue] + 21600)))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = setValue( *(void **)(a1 + 40), @"ClientUsage", (const char *)[*(id *)(a1 + 32) fileSystemRepresentation]);
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
    {
      if ((unint64_t)[v11 count] < 0x400)
      {
        uint64_t v10 = v11;
      }

      else
      {
        removeOldestMetadataRefreshData();
        id v8 = filesystemMetadataLastRefreshDate();
        uint64_t v9 = objc_claimAutoreleasedReturnValue(v8);

        uint64_t v10 = (void *)v9;
      }

      id v11 = v10;
      [v10 setSafeObject:v4 forKey:v3];
    }
  }
}

id filesystemMetadataLastRefreshDate()
{
  if (filesystemMetadataLastRefreshDate_dispatchOnceFilesystemMetadataLastRefreshDateQueue != -1) {
    dispatch_once( &filesystemMetadataLastRefreshDate_dispatchOnceFilesystemMetadataLastRefreshDateQueue,  &__block_literal_global_630);
  }
  return (id)filesystemMetadataLastRefreshDate___filesystemMetadataLastRefreshDate;
}

LABEL_17:
}

  uint64_t v15 = 0;
LABEL_19:

  return v15;
}

  -[MADAutoAssetStager _acknowlegdeAndClearAllEliminations](self, "_acknowlegdeAndClearAllEliminations");
}

  if ((length & 3) != 0)
  {
    uint64_t v29 = 1027423549;
    uint64_t v30 = 0LL;
    __memcpy_chk(&v29, &v28[length & 0xFFFFFFFFFFFFFFFCLL], length & 3, 4LL);
    +[PallasResponseVerifier base64DecodeString:toBuffer:length:]( &OBJC_CLASS___PallasResponseVerifier,  "base64DecodeString:toBuffer:length:",  &v29,  &v17[v14],  &v30);
    if (!v30)
    {
      -[NSMutableData setLength:](v13, "setLength:", 0LL);
      uint64_t v25 = @"{CopyDataFromEncodedBase64} decode error, decoded data size is 0";
LABEL_21:
      _MobileAssetLog( 0LL,  6,  (uint64_t)"+[PallasResponseVerifier CopyDataFromEncodedBase64:range:]",  v25,  v21,  v22,  v23,  v24,  v27);
    }
  }

        objc_autoreleasePoolPop(v6);
        uint64_t v4 = (char *)v4 + 1;
      }

      while (v39 != v4);
      double v20 = [v2 countByEnumeratingWithState:&v45 objects:v50 count:16];
      id v39 = v20;
    }

    while (v20);
  }

  uint64_t v43 = 0u;
  uint64_t v44 = 0u;
  v41 = 0u;
  uint64_t v42 = 0u;
  uint64_t v21 = v35;
  uint64_t v22 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v41,  v49,  16LL);
  if (v22)
  {
    uint64_t v23 = v22;
    char v24 = *(void *)v42;
    do
    {
      for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v42 != v24) {
          objc_enumerationMutation(v21);
        }
        uint64_t v26 = *(void *)(*((void *)&v41 + 1) + 8LL * (void)i);
        uint64_t v27 = objc_autoreleasePoolPush();
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) locksBySelector]);
        uint64_t v29 = [v28 safeObjectForKey:v26 ofClass:objc_opt_class(MANAutoAssetSetLock)];
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);

        id v31 = *(void **)(a1 + 32);
        id v32 = (void *)objc_claimAutoreleasedReturnValue([v30 fullAssetSelector]);
        [v31 _removeAssetLock:v30 lastClient:0 forSelector:v32 message:@"force global unlock"];

        objc_autoreleasePoolPop(v27);
      }

      uint64_t v23 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v41,  v49,  16LL);
    }

    while (v23);
  }
}

  return v9;
}

  return v21;
}

        objc_autoreleasePoolPop(v12);
        uint64_t v10 = (char *)v10 + 1;
      }

      while (v8 != v10);
      uint64_t v22 = [obj countByEnumeratingWithState:&v27 objects:v33 count:16];
      id v8 = v22;
      if (!v22)
      {
LABEL_23:

        uint64_t v6 = v24;
        break;
      }
    }
  }

  return v25;
}

  return v25;
}

  return (char)v8;
}

      objc_autoreleasePoolPop(v8);
      uint64_t v6 = (char *)v6 + 1;
      p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
    }

    while (v52 != v6);
    __int128 v34 = [obj countByEnumeratingWithState:&v55 objects:v63 count:16];
    uint64_t v52 = v34;
  }

  while (v34);
LABEL_22:
  __int128 v35 = 0;
LABEL_31:

  return v35;
}

        objc_autoreleasePoolPop(v6);
        uint64_t v4 = (char *)v4 + 1;
      }

      while (v37 != v4);
      double v20 = [v3 countByEnumeratingWithState:&v44 objects:v49 count:16];
      __int128 v37 = v20;
    }

    while (v20);
  }

  uint64_t v42 = 0u;
  uint64_t v43 = 0u;
  uint64_t v40 = 0u;
  v41 = 0u;
  uint64_t v21 = v32;
  uint64_t v22 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v40,  v48,  16LL);
  if (v22)
  {
    uint64_t v23 = v22;
    char v24 = *(void *)v41;
    do
    {
      for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v41 != v24) {
          objc_enumerationMutation(v21);
        }
        uint64_t v26 = *(void *)(*((void *)&v40 + 1) + 8LL * (void)i);
        uint64_t v27 = objc_autoreleasePoolPush();
        uint64_t v28 = [v39 safeObjectForKey:v26 ofClass:objc_opt_class(MAAutoAssetLock)];
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
        uint64_t v30 = *(void **)(v38 + 32);
        id v31 = (void *)objc_claimAutoreleasedReturnValue([v29 fullAssetSelector]);
        [v30 _removeAssetLock:v29 lastClient:0 forSelector:v31 message:@"force global unlock"];

        objc_autoreleasePoolPop(v27);
      }

      uint64_t v23 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v40,  v48,  16LL);
    }

    while (v23);
  }
}

  cc_clear(8 * v12, v24);
  cc_clear(8 * v12, a6);
LABEL_18:
  *(void *)(a1 + 16) = v35;
  return v29;
}

  uint64_t v6 = *a1;
  double v7 = v6 >= 8;
  id v8 = v6 - 8;
  if (!v7) {
    id v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  double v7 = v6 >= 4;
  id v8 = v6 - 4;
  if (!v7) {
    id v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  double v7 = v6 >= 3;
  id v8 = v6 - 3;
  if (!v7) {
    id v8 = -1;
  }
  return (v8 + 1);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

      __break(1u);
      return result;
    }

    __break(1u);
  }

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

void sub_29AB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

LABEL_33:
  uint64_t v58 = v22 != 0LL;
  return v58;
}

LABEL_34:
        id v13 = 0LL;
        goto LABEL_35;
      }

      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v14 logger]);
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 138543874;
      id v38 = v10;
      id v39 = 2114;
      uint64_t v40 = v7;
      v41 = 2114;
      uint64_t v42 = v8;
      uint64_t v26 = "\n"
            "[AUTO-SECURE][LOCAL-CONTENT-URL] {%{public}@} unable to initialize SecureMobileAssetBundle | assetType:%{pub"
            "lic}@ | assetId:%{public}@";
    }

    else
    {
      char v24 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v24 oslog]);

      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 138543874;
      id v38 = v10;
      id v39 = 2114;
      uint64_t v40 = v7;
      v41 = 2114;
      uint64_t v42 = v8;
      uint64_t v26 = "\n"
            "[AUTO-SECURE][LOCAL-CONTENT-URL] {%{public}@} no MADAutoAssetSecure instance | assetType:%{public}@ | assetId:%{public}@";
    }

    __int128 v35 = v25;
    __int128 v36 = 32;
    goto LABEL_48;
  }

  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v23 oslog]);

  if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543874;
    id v38 = v10;
    id v39 = 2114;
    uint64_t v40 = v7;
    v41 = 2114;
    uint64_t v42 = v8;
    _os_log_error_impl( &dword_0,  (os_log_t)v14,  OS_LOG_TYPE_ERROR,  "\n [AUTO-SECURE][LOCAL-CONTENT-URL] {%{public}@} unable to form default URL [before considering whether secure-asset] | assetType:%{public}@ | assetId:%{public}@",  buf,  0x20u);
  }

  id v13 = 0LL;
LABEL_36:

  return v13;
}

  uint64_t v46 = [[MAAutoAssetInfoStaged alloc] initWithByGroupTotalStagedBytes:v10 withByGroupAssetsSuccessfullyStaged:v11];

LABEL_37:
  return v46;
}
}

  v48 = v78;
  unsigned __int8 v49 = -[NSMutableArray count](v78, "count");
  if (v49 == [v25 count])
  {
    v50 = objc_alloc(&OBJC_CLASS___MADAutoSetDescriptor);
    v51 = v25;
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v79 clientDomainName]);
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v79 assetSetIdentifier]);
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([obj atomicInstanceUUID]);
    uint64_t v10 = -[MADAutoSetDescriptor initForClientDomainName:forAssetSetIdentifier:withDiscoveredAtomicInstance:withDiscoveredAtomicEntries:]( v50,  "initForClientDomainName:forAssetSetIdentifier:withDiscoveredAtomicInstance:withDiscoveredAtomicEntries:",  v52,  v53,  v54,  v78);

    [v10 setRequestedAutoAssetEntries:v51];
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v23 catalogCachedAssetSetID]);
    [v10 setCatalogCachedAssetSetID:v55];

    v56 = (void *)objc_claimAutoreleasedReturnValue([v23 catalogDownloadedFromLive]);
    [v10 setCatalogDownloadedFromLive:v56];

    uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v23 catalogLastTimeChecked]);
    [v10 setCatalogLastTimeChecked:v57];

    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v23 catalogPostedDate]);
    [v10 setCatalogPostedDate:v58];

    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v23 downloadedCatalogCachedAssetSetID]);
    [v10 setDownloadedCatalogCachedAssetSetID:v59];

    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v23 downloadedCatalogDownloadedFromLive]);
    [v10 setDownloadedCatalogDownloadedFromLive:v60];

    v61 = (void *)objc_claimAutoreleasedReturnValue([v23 downloadedCatalogLastTimeChecked]);
    [v10 setDownloadedCatalogLastTimeChecked:v61];

    v62 = (void *)objc_claimAutoreleasedReturnValue([v23 downloadedCatalogPostedDate]);
    [v10 setDownloadedCatalogPostedDate:v62];

    v48 = v78;
    id v63 = (void *)objc_claimAutoreleasedReturnValue([obj atomicInstanceUUID]);
    [v10 setLatestDownloadedAtomicInstance:v63];

    [v10 setLatestDowloadedAtomicInstanceEntries:v78];
    [v10 setIsOnFilesystem:1];
    [v10 setIsDiscoveredFullyDownloaded:1];
    [v10 setAtomicInstanceDownloadedNotified:1];
    [v10 setNeverBeenLocked:1];
    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v10 latestDownloadedAtomicInstance]);
    uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v79 autoAssetSetClientName]);
    BYTE2(v76) = 1;
    LOWORD(v76) = 0;
    -[MADAutoAssetControlManager trackSetDescriptor:fromLocation:forLatestDownloaded:forSpecificAtomicInstance:withCurrentSetStatus:changedWhileTerminated:changedNeverBeenLocked:notifyingIfJustDownloaded:latestToVend:historyOperation:firstClientName:]( v24,  "trackSetDescriptor:fromLocation:forLatestDownloaded:forSpecificAtomicInstance:withCurrentSetStatus:changedWhileTer minated:changedNeverBeenLocked:notifyingIfJustDownloaded:latestToVend:historyOperation:firstClientName:",  v10,  v82,  1LL,  v64,  0LL,  0LL,  v76,  354LL,  v65);

    uint64_t v6 = v77;
    -[MADAutoAssetControlManager updateAutoAssetSetStatus:forSetDescriptor:]( v24,  "updateAutoAssetSetStatus:forSetDescriptor:",  v77,  v10);
    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v24, "logger"));
    uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue([v66 oslog]);

    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v24, "_updateLatestSummary"));
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v79 summary]);
      uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v10 summary]);
      *(_DWORD *)buf = 138544130;
      v97 = v68;
      v98 = 2114;
      v99 = v82;
      v100 = 2114;
      v101 = v69;
      v102 = 2114;
      v103 = v70;
      _os_log_impl( &dword_0,  v67,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@}\n [VEND] new set-descriptor generated without lookup required | setInfoInstance:%{public}@, newSetDescriptor:%{public}@",  buf,  0x2Au);

      uint64_t v6 = v77;
    }

    uint64_t v23 = v85;
    uint64_t v71 = v81;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v71 = v81;
    uint64_t v6 = v77;
  }

LABEL_46:
LABEL_47:

  return v10;
}

          objc_autoreleasePoolPop(v11);
          uint64_t v9 = (char *)v9 + 1;
        }

        while (v48 != v9);
        uint64_t v42 = [v8 countByEnumeratingWithState:&v49 objects:v59 count:16];
        v48 = v42;
        if (!v42)
        {
          double v7 = v45;
          break;
        }
      }
    }
  }

  else
  {
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    id v8 = (id)objc_claimAutoreleasedReturnValue([v43 oslog]);

    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      *(_DWORD *)buf = 138543362;
      uint64_t v54 = v44;
      _os_log_impl( &dword_0,  (os_log_t)v8,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {loadPersistedDescriptors} no persisted auto-asset-jobs to be resumed",  buf,  0xCu);
    }
  }

  -[MADAutoAssetControlManager _logPersistedTableOfContents:forComponentType:]( self,  "_logPersistedTableOfContents:forComponentType:",  @"loadPersistedDescriptors",  @"KNOWN_DESCRIPTORS");
}

      objc_autoreleasePoolPop(v45);
      uint64_t v43 = (char *)v43 + 1;
    }

    while (v39 != v43);
    id v39 = [v37 countByEnumeratingWithState:&v95 objects:v116 count:16];
  }

  while (v39);

  uint64_t v57 = v82;
  if ((v86 & 1) != 0) {
    uint64_t v58 = v84;
  }
  else {
    uint64_t v58 = @"descriptorsOfAssetType(missing)";
  }
  uint64_t v15 = v79;
LABEL_52:
  uint64_t v59 = v81;

LABEL_53:
  v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v59, "logger"));
  uint64_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue([v73 oslog]);

  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
  {
    id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v59, "_updateLatestSummary"));
    *(_DWORD *)buf = 138544642;
    id v76 = @"N";
    id v77 = v89;
    v104 = v75;
    if (!v89) {
      id v77 = @"N";
    }
    v105 = 2114;
    if (v83) {
      id v76 = v83;
    }
    v106 = v57;
    v107 = 2114;
    v108 = v90;
    v109 = 2114;
    v110 = v77;
    v111 = 2114;
    v112 = v76;
    v113 = 2114;
    v114 = v58;
    _os_log_impl( &dword_0,  v74,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@:_logTrackedDescriptors} assetType:%{public}@, assetSpecifier:%{public}@, assetVersion:%{p ublic}@ | downloadedBySelector:%{public}@",  buf,  0x3Eu);
  }
}

    if (v8 < 0)
    {
      uint64_t v29 = objc_opt_class(&OBJC_CLASS___MAAssetDiff);
      DecodeClasses = loadDecodeClasses();
      id v31 = (void *)objc_claimAutoreleasedReturnValue(DecodeClasses);
      __int128 v37 = 0LL;
      id v32 = (void *)objc_claimAutoreleasedReturnValue( -[ControlManager decodeXpcObject:ofClass:dataKey:lengthKey:decodeClasses:error:]( self,  "decodeXpcObject:ofClass:dataKey:lengthKey:decodeClasses:error:",  v10,  v29,  @"allowedDifferences",  @"allowedDifferencesLength",  v31,  &v37));
      unsigned int v33 = v37;

      if (v33)
      {
        id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to decode allow-differences with error:%@",  v33);
      }

      else
      {
        if (v32)
        {
          [v11 associateAllowDifferences:v32];
          __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v11 allowDifferences]);
          __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v34 summary]);
          [v12 extendLogLeader:@"allowedDifferences" withValue:v35];
        }

        id v13 = 0LL;
      }
    }

    else
    {
      id v13 = 0LL;
    }

    goto LABEL_41;
  }

      a1 = sub_212558(0LL, *((void *)a1 + 2) + 1LL, 1, a1);
      goto LABEL_13;
    }

    if ((swift_isUniquelyReferenced_nonNull_native(a1) & 1) == 0) {
      a1 = sub_212558(0LL, *((void *)a1 + 2) + 1LL, 1, a1);
    }
    uint64_t v23 = *((void *)a1 + 2);
    __int128 v36 = *((void *)a1 + 3);
    if (v23 >= v36 >> 1) {
      a1 = sub_212558((char *)(v36 > 1), v23 + 1, 1, a1);
    }
    *((void *)a1 + 2) = v23 + 1;
    __int128 v37 = &a1[48 * v23];
    v37[32] = v12;
    *((void *)v37 + 5) = a2;
    *((_OWORD *)v37 + 3) = 0u;
    *((_OWORD *)v37 + 4) = 0u;
    *a3 = a1;
    if (!v17)
    {
      swift_unknownObjectRelease(v40);
      return;
    }

    while (1)
    {
      sub_226F28(v44, a2 + 1, a3);
      if (__OFSUB__(v46 >> 1, v45)) {
        break;
      }
    }

    __break(1u);
LABEL_32:
    __break(1u);
    goto LABEL_33;
  }

  unsigned int v33 = sub_222964();
  swift_allocError(&type metadata for CryptoKitASN1Error, v33, 0LL, 0LL);
  NSMutableSet *v34 = 5;
  __int128 v35 = swift_unknownObjectRetain(v18);
  swift_willThrow(v35);
LABEL_21:
  swift_unknownObjectRelease(v44[0]);
}

id SoftwareUpdateSSOlogInfo()
{
  if (SoftwareUpdateSSOlogInfo_logInfoOnce != -1) {
    dispatch_once(&SoftwareUpdateSSOlogInfo_logInfoOnce, &__block_literal_global_0);
  }
  return (id)SoftwareUpdateSSOlogInfo_infoLog;
}

id SoftwareUpdateSSOlogError()
{
  if (SoftwareUpdateSSOlogError_logErrorOnce != -1) {
    dispatch_once(&SoftwareUpdateSSOlogError_logErrorOnce, &__block_literal_global_3);
  }
  return (id)SoftwareUpdateSSOlogError_infoError;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

LABEL_13:
    char v24 = 0LL;
    goto LABEL_14;
  }

  id v18 = (void *)v17;
  uint64_t v19 = objc_claimAutoreleasedReturnValue([v11 assetSpecifier]);
  if (!v19)
  {

    goto LABEL_11;
  }

  double v20 = (void *)v19;
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v11 assetVersion]);

  if (!v21) {
    goto LABEL_11;
  }
  uint64_t v22 = v14->_lockedAssetSelectors;
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v11 persistedEntryID]);
  -[NSMutableDictionary setObject:forKey:](v22, "setObject:forKey:", v11, v23);

LABEL_7:
  char v24 = v14;
LABEL_14:

  return v24;
}

  return v15;
}

    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler jobsBySelector](self, "jobsBySelector"));
    [v23 removeObjectForKey:v6];

    if (v10)
    {
      char v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler persistedState](self, "persistedState"));
      [v24 removePersistedEntry:v6 fromLocation:@"_eliminateSpecificSelector"];

      -[MADAutoAssetScheduler _logPersistedRemovedEntry:removedSelector:message:]( self,  "_logPersistedRemovedEntry:removedSelector:message:",  @"_eliminateSpecificSelector",  v4,  @"eliminated specific asset-selector scheduled job");
    }
  }

  else
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue([v21 oslog]);

    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetScheduler _eliminateSpecificSelector:].cold.1(v4);
    }
  }
}
}

      objc_autoreleasePoolPop(v14);
      id v11 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
    }

    uint64_t v64 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v9,  "countByEnumeratingWithState:objects:count:",  &v70,  v81,  16LL);
    if (v64) {
      continue;
    }
    break;
  }

        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[MADActivityTracker logLeader](self, "logLeader"));
        [v23 appendFormat:@"%@%@", v9, @"|"];

        -[MADActivityTracker setDownloadInfo:](self, "setDownloadInfo:", v24);
        goto LABEL_14;
      }

      id v17 = (v15 - 1);
      uint64_t v16 = v13;
    }

    id v18 = (void *)objc_claimAutoreleasedReturnValue([v16 objectAtIndexedSubscript:v17]);
    goto LABEL_6;
  }

  return v11;
}

  return v14;
}

  return 0LL;
}

      objc_autoreleasePoolPop(v12);
    }

    id v8 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v8) {
      continue;
    }
    break;
  }

  uint64_t v15 = 0LL;
LABEL_18:
  uint64_t v4 = v20;
LABEL_20:

LABEL_21:
  return v15;
}

    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v10 limitedToClientDomains]);

    if (v16)
    {
      uint64_t v22 = 0u;
      uint64_t v23 = 0u;
      double v20 = 0u;
      uint64_t v21 = 0u;
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "limitedToClientDomains", 0));
      id v13 = [v12 countByEnumeratingWithState:&v20 objects:v28 count:16];
      if (v13)
      {
        id v17 = *(void *)v21;
        while (2)
        {
          for (j = 0LL; j != v13; j = (char *)j + 1)
          {
            if (*(void *)v21 != v17) {
              objc_enumerationMutation(v12);
            }
            if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v8,  *(void *)(*((void *)&v20 + 1) + 8LL * (void)j)) & 1) != 0)
            {
              LOBYTE(v13) = 1;
              goto LABEL_25;
            }
          }

          id v13 = [v12 countByEnumeratingWithState:&v20 objects:v28 count:16];
          if (v13) {
            continue;
          }
          break;
        }
      }

  return v24;
}

  return v10;
}

  return v15;
}
}

  uint64_t v22 = xdict;
  uint64_t v23 = 0LL;
  char v24 = 0LL;
  if (!xdict) {
    goto LABEL_43;
  }
LABEL_14:
  sendReply(*(void **)(a1 + 56), v22, v21);
LABEL_44:
}

  id v31 = v28;

  return v31;
}

  if (v6 == v3) {
    return result;
  }
  result = swift_isUniquelyReferenced_nonNull_native(v7);
  if ((result & 1) == 0) {
    goto LABEL_30;
  }
  do
  {
    while (1)
    {
      if (v6 <= v3)
      {
        __break(1u);
LABEL_24:
        __break(1u);
LABEL_25:
        __break(1u);
LABEL_26:
        __break(1u);
        goto LABEL_27;
      }

      id v13 = v6 - 1 + v5;
      if (__OFADD__(v6 - 1, v5)) {
        goto LABEL_24;
      }
      uint64_t v14 = v6 - 1;
      if (v6 < 1) {
        goto LABEL_25;
      }
      uint64_t v15 = *(void *)(v7 + 16);
      if (v14 >= v15) {
        goto LABEL_26;
      }
      if (v13 < v15) {
        break;
      }
LABEL_27:
      __break(1u);
LABEL_28:
      __break(1u);
LABEL_29:
      __break(1u);
LABEL_30:
      result = (uint64_t)sub_237300(v7);
      double v7 = result;
    }

    *(_BYTE *)(v7 + 32 + v13) = *(_BYTE *)(v7 + v6-- + 31);
  }

  while (v14 != v3);
  *uint64_t v4 = v7;
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

LABEL_11:
  return (char)v8;
}

  return (char)v7;
}

  -[NSMutableDictionary setSafeObject:forKey:]( v29,  "setSafeObject:forKey:",  @"N/A",  @"PersonalizeFailureReason",  v48);
  id v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL));
  -[NSMutableDictionary setSafeObject:forKey:](v29, "setSafeObject:forKey:", v38, @"PersonalizeResult");

  id v39 = (__CFString *)v53;
  if ((unint64_t)(a7 - 1) > 1)
  {
LABEL_21:
    -[NSMutableDictionary setSafeObject:forKey:](v29, "setSafeObject:forKey:", @"N/A", @"MapExclaveResult");
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL));
    uint64_t v42 = @"MapExclaveFailureReason";
    goto LABEL_22;
  }

  if (v37) {
    uint64_t v40 = v37;
  }
  else {
    uint64_t v40 = @"N/A";
  }
  -[NSMutableDictionary setSafeObject:forKey:](v29, "setSafeObject:forKey:", v40, @"MapExclaveFailureReason");
  v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v50));
  uint64_t v42 = @"MapExclaveResult";
LABEL_22:
  -[NSMutableDictionary setSafeObject:forKey:](v29, "setSafeObject:forKey:", v41, v42);

  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( -[MADAnalyticsManager recordEventWithName:assetType:payload:]( self,  "recordEventWithName:assetType:payload:",  @"com.apple.mobileassetd.Secure.Attempt",  v21,  v29));
  return v46;
}

  return v3;
}
}

  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 diag]);
  id v39 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetOSVersion](self, "assetTargetOSVersion"));
  if (v40) {
    uint64_t v28 = (const __CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetOSVersion](self, "assetTargetOSVersion"));
  }
  else {
    uint64_t v28 = @"N";
  }
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetBuildVersion](self, "assetTargetBuildVersion"));
  if (v29) {
    uint64_t v30 = (const __CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetBuildVersion](self, "assetTargetBuildVersion"));
  }
  else {
    uint64_t v30 = @"N";
  }
  id v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetTrainName](self, "assetTargetTrainName"));
  v41 = v26;
  if (v31) {
    id v32 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager assetTargetTrainName](self, "assetTargetTrainName"));
  }
  else {
    id v32 = @"N";
  }
  unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v6 summary]);
  __int128 v37 = (__CFString *)v30;
  id v38 = (__CFString *)v28;
  __int128 v34 = -[NSString initWithFormat:]( v39,  "initWithFormat:",  @"{%@} staging-client-request considered matching active-target yet some mismatches [BY-GROUP-MODE] | assetTarget(OSVersion:%@ | BuildVersion:%@ | TrainName:%@) | request:%@",  v43,  v28,  v30,  v32,  v33);
  __int128 v35 = v27;
  [v27 trackAnomaly:@"AUTO-STAGER" forReason:v34 withResult:6111 withError:0];

  if (v31) {
  id v13 = v42;
  }
  char v24 = (void *)v45;
  if (v29) {

  }
  uint64_t v25 = (void *)v44;
  if (v40) {

  }
  LOBYTE(v19) = 1;
  uint64_t v10 = v43;
LABEL_27:

  return v19;
}

  return (char)v8;
}

  return (char)v7;
}

  return (char)v6;
}

  return v3;
}

  __int128 v36 = assembleTaskDescriptorWithPurpose((uint64_t)v50, (uint64_t)@"pmv", v30);
  v41 = (void *)objc_claimAutoreleasedReturnValue(v36);
  if (v41)
  {
    IsInternalAllowed = _MAPreferencesIsInternalAllowed();
    PmvUrl = getPmvUrl(IsInternalAllowed, (uint64_t)@"com.apple.MobileAsset.SoftwareUpdate");
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(PmvUrl);
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager registerPmvDownloadJob:using:with:clientName:]_block_invoke",  @"PMV download is being forced as client asked. Downloading %@ for %@ client: %@",  v45,  v46,  v47,  v48,  (uint64_t)v44);
    [*(id *)(a1 + 48) startDownloadAndUpdateState:v44 for:v41 modified:0 options:v14 using:*(void *)(a1 + 56) with:*(void *)(a1 + 40) clientName:*(void *)(a1 + 64) autoAssetJob:0 ofJobType:@"PMV_job"];
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager registerPmvDownloadJob:using:with:clientName:]_block_invoke",  @"Trying to create a download job with nil task descriptor, bailing, %@",  v37,  v38,  v39,  v40,  (uint64_t)@"com.apple.MobileAsset.SoftwareUpdate");
    [*(id *)(a1 + 48) sendDownloadCannotStartResult:3 assetType:@"com.apple.MobileAsset.SoftwareUpdate" connection:*(void *)(a1 + 56) requestMessage:*(void *)(a1 + 40) clientName:*(void *)(a1 + 64) autoAssetJobID:0 ofJobType:@"PMV_job" underlyingError:0];
  }

LABEL_15:
}

      uint64_t v12 = @"EMPTY";
      goto LABEL_12;
    }

    id v5 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoSetDescriptor discoveredAtomicEntries](self, "discoveredAtomicEntries"));
  }

  id v8 = v5;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectAtIndex:0]);

  if (!v9) {
    goto LABEL_11;
  }
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 fullAssetSelector]);
LABEL_7:
  id v11 = v10;
  uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue([v10 assetType]);

LABEL_12:
  return v12;
}

  return 0LL;
}

      objc_autoreleasePoolPop(v14);
      uint64_t v12 = (char *)v12 + 1;
    }

    while (v10 != v12);
    uint64_t v22 = [obj countByEnumeratingWithState:&v92 objects:v105 count:16];
    uint64_t v10 = v22;
  }

  while (v22);

  uint64_t v23 = v85;
  if (!v85)
  {
    uint64_t v10 = 0LL;
    uint64_t v6 = v77;
    goto LABEL_47;
  }

  char v24 = v87;
  uint64_t v6 = v77;
  id obj = (id)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceNewSetAtomicInstance:recordingHistoryOperation:forSetInfoInstance:asSubAtomicFrom:]( v87,  "atomicInstanceNewSetAtomicInstance:recordingHistoryOperation:forSetInfoInstance:asSubAtomicFrom:",  v82,  222LL,  v79,  0LL));
  if (!obj)
  {
    uint64_t v10 = 0LL;
    goto LABEL_46;
  }

  v81 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v78 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  uint64_t v25 = v84;
  uint64_t v26 = [v25 countByEnumeratingWithState:&v88 objects:v104 count:16];
  if (!v26) {
    goto LABEL_33;
  }
  uint64_t v27 = v26;
  id v83 = *(void *)v89;
  v80 = v25;
  while (2)
  {
    uint64_t v28 = 0LL;
    while (2)
    {
      if (*(void *)v89 != v83) {
        objc_enumerationMutation(v80);
      }
      uint64_t v29 = *(void **)(*((void *)&v88 + 1) + 8 * v28);
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 assetSelector]);
      id v31 = (void *)objc_claimAutoreleasedReturnValue([v30 assetType]);
      id v32 = (void *)objc_claimAutoreleasedReturnValue([v29 assetSelector]);
      unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v32 assetSpecifier]);
      __int128 v34 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager findAtomicEntryForAssetType:forAssetSpecifier:representedByDescriptor:]( v24,  "findAtomicEntryForAssetType:forAssetSpecifier:representedByDescriptor:",  v31,  v33,  v23));

      if (v34)
      {
        __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v34 fullAssetSelector]);
        __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v35 persistedEntryID]);

        __int128 v37 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v81,  "safeObjectForKey:ofClass:",  v36,  objc_opt_class(&OBJC_CLASS___MANAutoAssetSetAtomicEntry));
        id v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
        if (v38)
        {
          id v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v24, "autoControlManagerFSM"));
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v39 diag]);
          v41 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v34 summary]);
          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v79 summary]);
          uint64_t v44 = -[NSString initWithFormat:]( v41,  "initWithFormat:",  @"{%@} duplicate nextAtomicEntry ignored | nextAtomicEntry:%@ | setInfoInstance:%@",  v82,  v42,  v43);
          [v40 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v44 withResult:6109 withError:0];

          uint64_t v23 = v85;
          char v24 = v87;

          goto LABEL_29;
        }

        -[NSMutableDictionary setSafeObject:forKey:](v81, "setSafeObject:forKey:", v34, v36);
        -[NSMutableArray addObject:](v78, "addObject:", v34);
      }

      else
      {
        __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v24, "autoControlManagerFSM"));
        id v38 = (void *)objc_claimAutoreleasedReturnValue([v36 diag]);
        uint64_t v45 = objc_alloc(&OBJC_CLASS___NSString);
        id v39 = (void *)objc_claimAutoreleasedReturnValue([v29 summary]);
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v23 summary]);
        v47 = -[NSString initWithFormat:]( v45,  "initWithFormat:",  @"{%@} no nextAtomicEntry | nextSetEntry:%@ | satisfyingSetDescriptor:%@",  v82,  v39,  v46);
        [v38 trackAnomaly:@"AUTO-CONTROL" forReason:v47 withResult:6101 withError:0];

LABEL_29:
      }

      if (v27 != (id)++v28) {
        continue;
      }
      break;
    }

    uint64_t v25 = v80;
    uint64_t v27 = [v80 countByEnumeratingWithState:&v88 objects:v104 count:16];
    if (v27) {
      continue;
    }
    break;
  }

  if (a7)
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue([v28 oslog]);

    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager notifyLockerAsIndicatedBySetJob:withSetInstance:withSetDesire:forSetDescriptor:withClientReplyCompletion:].cold.1();
    }
  }

  return (char)v7;
}

  -[MADAutoAssetJob doneWithAllJobs:withLookupError:]( self,  "doneWithAllJobs:withLookupError:",  @"SetJobFailedSchedule",  v8);
  -[MADAutoAssetJob autoAssetJobFinished:forJobFinishedReason:failingWithError:]( self,  "autoAssetJobFinished:forJobFinishedReason:failingWithError:",  @"SetJobFailedSchedule",  @"FAILED",  v8);

  return 0LL;
}

  return (char)v7;
}

  return v7;
}

  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));

  if (v27)
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob onFilesystemByVersion](self, "onFilesystemByVersion"));
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 assetVersion]);
    id v31 = [v28 safeObjectForKey:v30 ofClass:objc_opt_class(MADAutoAssetDescriptor)];
    id v32 = objc_claimAutoreleasedReturnValue(v31);

    if (v32)
    {
      unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
      [v33 setIsOnFilesystem:1];

      if (-[MADAutoAssetJob stagerJob](self, "stagerJob"))
      {
LABEL_16:
        uint64_t v10 = (void *)v32;
        goto LABEL_20;
      }

      __int128 v34 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
      __int128 v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob currentJobInformation:](self, "currentJobInformation:", 0LL));
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob firstClientName](self, "firstClientName"));
      +[MADAutoAssetControlManager persistForJobSelector:persistingJobDescriptor:withJobInformation:withFirstClientName:]( &OBJC_CLASS___MADAutoAssetControlManager,  "persistForJobSelector:persistingJobDescriptor:withJobInformation:withFirstClientName:",  v46,  v34,  v35,  v36);
    }

    else
    {
      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerPatch](self, "foundNewerPatch"));

      if (v37 || -[MADAutoAssetJob stagerJob](self, "stagerJob"))
      {
        uint64_t v10 = 0LL;
        goto LABEL_20;
      }

      id v38 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
      id v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
      uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v39 assetType]);
      v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 assetSpecifier]);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v43 assetVersion]);
      __int128 v34 = -[MAAutoAssetSelector initForAssetType:withAssetSpecifier:matchingAssetVersion:]( v38,  "initForAssetType:withAssetSpecifier:matchingAssetVersion:",  v40,  v42,  v44);

      __int128 v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](self, "foundNewerFull"));
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob currentJobInformation:](self, "currentJobInformation:", 0LL));
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob firstClientName](self, "firstClientName"));
      +[MADAutoAssetControlManager persistForJobSelector:persistingJobDescriptor:withJobInformation:withFirstClientName:]( &OBJC_CLASS___MADAutoAssetControlManager,  "persistForJobSelector:persistingJobDescriptor:withJobInformation:withFirstClientName:",  v34,  v35,  v36,  v45);

      id v32 = 0LL;
    }

    goto LABEL_16;
  }

    id v5 = v19;
  }

  return (char)v9;
}
}
}

  sendClientResponse(*(void **)(a1 + 40), *(void **)(a1 + 48), v36);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager handleMigrateAssetsRequest:using:and:]_block_invoke",  @"[CONTROL_MANAGER_ASSET_QUEUE] {handleMigrateAssetsRequest} ...migrating assets",  v37,  v38,  v39,  v40,  v70);
}

  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ could not move old file: %@ to: %@ error: %@",  v10,  v11,  v12,  v13,  *(void *)(a1 + 40));

  id v17 = *(void *)(a1 + 32);
  uint64_t v68 = 0LL;
  id v18 = [v2 removeItemAtPath:v17 error:&v68];
  uint64_t v9 = v68;
  uint64_t v23 = *(void *)(a1 + 40);
  if ((v18 & 1) == 0)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ could not remove file: %@ (after initial error moving it to: %@) with removal error: %@",  v19,  v20,  v21,  v22,  v23);
    goto LABEL_32;
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ removed existing file: %@ (after initial error moving it to: %@)",  v19,  v20,  v21,  v22,  v23);
LABEL_13:
  if ([v2 fileExistsAtPath:*(void *)(a1 + 32)])
  {

    char v24 = *(void *)(a1 + 32);
    uint64_t v67 = 0LL;
    uint64_t v25 = [v2 removeItemAtPath:v24 error:&v67];
    uint64_t v9 = v67;
    if ((v25 & 1) == 0)
    {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ could not remove file: %@ error: %@",  v26,  v27,  v28,  v29,  *(void *)(a1 + 40));
      goto LABEL_32;
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ removed existing file: %@",  v26,  v27,  v28,  v29,  *(void *)(a1 + 40));
  }

  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stringByAppendingString:@".new.purged"]);
  if ([v2 fileExistsAtPath:v30]
    && (v9,
        uint64_t v66 = 0LL,
        id v31 = [v2 removeItemAtPath:v30 error:&v66],
        uint64_t v9 = v66,
        (v31 & 1) == 0))
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ could not remove prior temp file: %@ (will fall back to directly writing) error: %@",  v32,  v33,  v34,  v35,  *(void *)(a1 + 40));
  }

  else
  {
    __int128 v36 = -[NSOutputStream initToFileAtPath:append:]( objc_alloc(&OBJC_CLASS___NSOutputStream),  "initToFileAtPath:append:",  v30,  0LL);
    if (v36)
    {
      v41 = v36;
      uint64_t v42 = 1;
      goto LABEL_25;
    }
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ failed to create json stream: %@",  v37,  v38,  v39,  v40,  *(void *)(a1 + 40));
  v47 = -[NSOutputStream initToFileAtPath:append:]( objc_alloc(&OBJC_CLASS___NSOutputStream),  "initToFileAtPath:append:",  *(void *)(a1 + 32),  0LL);
  if (v47)
  {
    v41 = v47;
    uint64_t v42 = 0;
LABEL_25:

    -[NSOutputStream open](v41, "open");
    uint64_t v52 = *(void *)(a1 + 48);
    uint64_t v65 = 0LL;
    +[NSJSONSerialization writeJSONObject:toStream:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "writeJSONObject:toStream:options:error:",  v52,  v41,  1LL,  &v65);
    uint64_t v53 = v65;
    if (v53)
    {
      uint64_t v9 = v53;
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ failed to write json to: %@ error: %@",  v54,  v55,  v56,  v57,  *(void *)(a1 + 40));
LABEL_27:
      uint64_t v58 = 7LL;
LABEL_35:
      -[NSOutputStream close](v41, "close");

      goto LABEL_36;
    }

    if (v42)
    {
      uint64_t v59 = *(void *)(a1 + 32);
      uint64_t v64 = 0LL;
      uint64_t v60 = [v2 moveItemAtPath:v30 toPath:v59 error:&v64];
      uint64_t v9 = v64;
      if ((v60 & 1) == 0)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ could not move json from: %@ to: %@ error: %@",  v54,  v55,  v56,  v57,  *(void *)(a1 + 40));
        goto LABEL_27;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ succeeded",  v54,  v55,  v56,  v57,  *(void *)(a1 + 40));
    uint64_t v58 = 0LL;
    goto LABEL_35;
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ failed to create json stream: %@",  v48,  v49,  v50,  v51,  *(void *)(a1 + 40));

LABEL_32:
  uint64_t v58 = 7LL;
LABEL_36:
  if (*(void *)(a1 + 48) && !isDownloadResultFailure(v58))
  {
    uint64_t v71 = @"productMarketingVersions";
    id v72 = *(void *)(a1 + 48);
    v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v72,  &v71,  1LL));
  }

  else
  {
    v61 = 0LL;
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager writeJsonDictionaryToFile:to:with:]_block_invoke",  @"writeJsonDictionaryToFile %@ notifying download manager move complete",  v43,  v44,  v45,  v46,  *(void *)(a1 + 40));
  DownloadManager = getDownloadManager();
  id v63 = (void *)objc_claimAutoreleasedReturnValue(DownloadManager);
  [v63 taskFinishedUpdateState:*(void *)(a1 + 40) with:v58 extraInfo:v61];
}
}

  result = sub_2169C8(v5, *a3, a3[1]);
  uint64_t v14 = v13 + result;
  uint64_t v16 = v13 + v15;
  if (!v13)
  {
    uint64_t v16 = 0LL;
    uint64_t v14 = 0LL;
  }

  *a3 = v14;
  a3[1] = v16;
  return result;
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

LABEL_8:
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector triggeredMarkersRequiringRetry](self, "triggeredMarkersRequiringRetry"));
  double v20 = [v19 count];

  if (v20)
  {
    uint64_t v21 = 0LL;
    while (1)
    {
      uint64_t v22 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector triggeredMarkersRequiringRetry](self, "triggeredMarkersRequiringRetry"));
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([(id)v22 objectAtIndex:v21]);

      LOBYTE(v22) = [v23 isEqual:v6];
      if ((v22 & 1) != 0) {
        break;
      }
      ++v21;
      char v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector triggeredMarkersRequiringRetry](self, "triggeredMarkersRequiringRetry"));
      uint64_t v25 = [v24 count];
    }

    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector triggeredMarkersRequiringRetry](self, "triggeredMarkersRequiringRetry"));
    uint64_t v27 = [v26 count];

    if (v21 < (unint64_t)v27)
    {
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector triggeredMarkersRequiringRetry](self, "triggeredMarkersRequiringRetry"));
      [v28 removeObjectAtIndex:v21];

      -[MADAutoAssetConnector _logTriggeredMarkerRequiringRetry:removedMarker:]( self,  "_logTriggeredMarkerRequiringRetry:removedMarker:",  @"_refreshTrackingOfFinishedMarker",  v6);
    }
  }

    uint64_t v19 = 1;
    goto LABEL_12;
  }

  uint64_t v22 = 0LL;
  uint64_t v15 = [v6 createDirectoryAtPath:v11 withIntermediateDirectories:1 attributes:0 error:&v22];
  id v13 = (os_log_s *)v22;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetPersisted logger](self, "logger"));
  id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue([v16 oslog]);

  if (v15)
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      id v18 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetPersisted _summaryLeader:fromLocation:]( self,  "_summaryLeader:fromLocation:",  @"_verifyPersistedDirectoryExistsOrCreate",  v4));
      *(_DWORD *)buf = 138543618;
      char v24 = v18;
      uint64_t v25 = 2114;
      uint64_t v26 = v11;
      _os_log_impl( &dword_0,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | created persisted directory for modulePersistedPath:%{public}@",  buf,  0x16u);
    }

    goto LABEL_8;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetPersisted _summaryLeader:fromLocation:]( self,  "_summaryLeader:fromLocation:",  @"_verifyPersistedDirectoryExistsOrCreate",  v4));
    *(_DWORD *)buf = 138543874;
    char v24 = v21;
    uint64_t v25 = 2114;
    uint64_t v26 = v11;
    uint64_t v27 = 2114;
    uint64_t v28 = v13;
    _os_log_error_impl( &dword_0,  v17,  OS_LOG_TYPE_ERROR,  "%{public}@ | unable to create persisted directory for modulePersistedPath:%{public}@, error:%{public}@",  buf,  0x20u);
  }

  uint64_t v19 = 0;
LABEL_12:

  return v19;
}
  }
}

    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetStatusForDomainName:byIdentifier:]( v111,  "locateSetStatusForDomainName:byIdentifier:",  v113,  v16));
    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _currentSetStatusClearDownloadProgress:clearingSetStatus:forClearingReason:]( v111,  "_currentSetStatusClearDownloadProgress:clearingSetStatus:forClearingReason:",  v15,  v34,  v31));

    v114 = v31;
    if (v35) {
      -[MADAutoAssetControlManager _updateCurrentSetStatus:forSetIdentifier:withSetStatus:]( v111,  "_updateCurrentSetStatus:forSetIdentifier:withSetStatus:",  v31,  v16,  v35);
    }
    __int128 v36 = 0LL;
    id v31 = v23;
    goto LABEL_15;
  }

  v110 = v23;
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString message](v23, "message"));
  uint64_t v27 = +[MASAutoAssetSetInfoFound newShimmedFromFrameworkMessage:forKey:]( &OBJC_CLASS___MASAutoAssetSetInfoFound,  "newShimmedFromFrameworkMessage:forKey:",  v26,  @"setFound");

  __int128 v89 = v27;
  uint64_t v28 = objc_claimAutoreleasedReturnValue([v27 currentSetStatus]);
  uint64_t v29 = (id)v28;
  v93 = v20;
  v90 = v25;
  if (!v20 || v28)
  {
    id v31 = v25;
    id v32 = self;
    unsigned int v33 = v15;
    if (v28) {
      goto LABEL_19;
    }
    __int128 v37 = objc_alloc_init(&OBJC_CLASS___MANAutoAssetSetNotifications);
    id v38 = +[MADAutoAssetScheduler newSetPolicyForDomainName:forAssetSetIdentifier:]( &OBJC_CLASS___MADAutoAssetScheduler,  "newSetPolicyForDomainName:forAssetSetIdentifier:",  v113,  v16);
    id v39 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager stagerSetPolicy]( &OBJC_CLASS___MADAutoAssetControlManager,  "stagerSetPolicy"));
    uint64_t v40 = -[MADAutoAssetControlManager _haveReceivedLookupResponseForClientDomainName:forAssetSetIdentifier:]( v111,  "_haveReceivedLookupResponseForClientDomainName:forAssetSetIdentifier:",  v113,  v16);
    LOBYTE(v76) = 0;
    BYTE2(v75) = 0;
    BYTE1(v75) = -[MADAutoAssetControlManager _vendingAtomicInstanceForConfiguredEntriesForClientDomainName:forAssetSetIdentifier:]( v111,  "_vendingAtomicInstanceForConfiguredEntriesForClientDomainName:forAssetSetIdentifier:",  v113,  v16);
    LOBYTE(v75) = v40;
    if (v18)
    {
      uint64_t v29 = -[MADAutoAssetControlManager newAssetSetStatus:forReason:forClientDomain:forAssetSetIdentifier:withAtomicInstancesDownloaded:withCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:extendingWithCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:]( v111,  "newAssetSetStatus:forReason:forClientDomain:forAssetSetIdentifier:withAtomicInstancesDownloaded:withCatalo gCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewer AtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDow loadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive: withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentN eedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfig uredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesy stemBytes:extendingWithCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:",  v15,  @"set-job failed (generating current-status)",  v113,  v16,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  v37,  0LL,  v38,  v39,  v75,  0LL,  -1LL,  -1LL,  v76,  0LL,  v18,  v18);
      id v31 = @"set-job failed";
    }

    else
    {
      uint64_t v29 = -[MADAutoAssetControlManager newAssetSetStatus:forReason:forClientDomain:forAssetSetIdentifier:withAtomicInstancesDownloaded:withCatalogCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewerAtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDowloadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive:withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentNeedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesystemBytes:extendingWithCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:]( v111,  "newAssetSetStatus:forReason:forClientDomain:forAssetSetIdentifier:withAtomicInstancesDownloaded:withCatalo gCachedAssetSetID:withCatalogDownloadedFromLive:withCatalogLastTimeChecked:withCatalogPostedDate:withNewer AtomicInstanceDiscovered:withNewerDiscoveredAtomicEntries:withLatestDownloadedAtomicInstance:withLatestDow loadedAtomicInstanceEntries:withDownloadedCatalogCachedAssetSetID:withDownloadedCatalogDownloadedFromLive: withDownloadedCatalogLastTimeChecked:withDownloadedCatalogPostedDate:withCurrentNotifications:withCurrentN eedPolicy:withSchedulerPolicy:withStagerPolicy:havingReceivedLookupResponse:vendingAtomicInstanceForConfig uredEntries:withDownloadUserInitiated:withDownloadProgress:withDownloadedNetworkBytes:withDownloadedFilesy stemBytes:extendingWithCurrentLockUsage:withSelectorsForStaging:withAvailableForUseError:withNewerVersionError:",  v15,  @"set-job success (generating current-status)",  v113,  v16,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  v37,  0LL,  v38,  v39,  v75,  0LL,  -1LL,  -1LL,  v76,  0LL,  0LL,  0LL);
      id v31 = @"generic final successful set-job status";
    }

    uint64_t v25 = v90;
    if (v29)
    {
      id v32 = v111;
      goto LABEL_19;
    }

    v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v111, "autoControlManagerFSM"));
    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v73 diag]);
    [v74 trackAnomaly:@"AUTO-SET-CONTROL" forReason:@"{updateAutoAssetSetStatus} no final status" withResult:6101 withError:0];

    double v20 = v93;
    uint64_t v23 = v110;
    goto LABEL_8;
  }

  uint64_t v30 = v20;
  uint64_t v29 = v30;
  if (v18)
  {
    [v30 setAvailableForUseError:v18];
    [v29 setNewerVersionError:v18];
  }

  id v31 = v25;
  id v32 = self;
  unsigned int v33 = v15;
LABEL_19:
  uint64_t v42 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v29 atomicInstancesDownloaded]);
  v114 = v31;
  if (v42)
  {
LABEL_22:

    goto LABEL_23;
  }

  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v29 latestDownloadedAtomicInstance]);

  if (v43)
  {
    uint64_t v42 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v29 latestDownloadedAtomicInstance]);
    -[NSMutableArray addObject:](v42, "addObject:", v44);

    [v29 setAtomicInstancesDownloaded:v42];
    goto LABEL_22;
  }

LABEL_9:
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v12 clientRequestMessage]);
  double v20 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetAuthorizationPolicy authorizationAssetTypeFromMessage:alreadyOnStateQueue:]( &OBJC_CLASS___MADAutoAssetAuthorizationPolicy,  "authorizationAssetTypeFromMessage:alreadyOnStateQueue:",  v19,  v6));

  uint64_t v21 = repositoryPath(v20);
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
  AutoLocalUrlFromTypeGivenDefaultRepoWithPurpose = getAutoLocalUrlFromTypeGivenDefaultRepoWithPurpose( v20,  1LL,  v22,  @"auto");
  char v24 = (void *)objc_claimAutoreleasedReturnValue(AutoLocalUrlFromTypeGivenDefaultRepoWithPurpose);
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 path]);

  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v12 clientRequestMessage]);
  uint64_t v27 = v26;
  if (v26)
  {
    [v26 clientConnectionAuditToken];
  }

  else
  {
    uint64_t v64 = 0u;
    uint64_t v65 = 0u;
  }

  id v63 = v12;

  *(_OWORD *)buf = v64;
  *(_OWORD *)&buf[16] = v65;
  id v32 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetAuthorizationPolicy issueSandboxExtensionForAuditToken:path:]( &OBJC_CLASS___MADAutoAssetAuthorizationPolicy,  "issueSandboxExtensionForAuditToken:path:",  buf,  v25));
  if (v32)
  {
    v62 = v11;
    unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v13 message]);
    __int128 v34 = [v33 mutableCopy];

    v61 = v32;
    [v34 setSafeObject:v32 forKey:@"sandboxExtensionKey"];
    [v34 setSafeObject:v25 forKey:@"sandboxExtensionPathKey"];
    __int128 v35 = objc_alloc(&OBJC_CLASS___SUCoreConnectMessage);
    __int128 v36 = [v13 messageType];
    __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v13 messageName]);
    id v38 = v25;
    id v39 = (void *)objc_claimAutoreleasedReturnValue([v13 clientIDRaw]);
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v13 version]);
    uint64_t v60 = (os_log_s *)v34;
    v41 = -[SUCoreConnectMessage initWithType:messageName:clientID:version:message:]( v35,  "initWithType:messageName:clientID:version:message:",  v36,  v37,  v39,  v40,  v34);

    uint64_t v25 = v38;
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      if (v13) {
        uint64_t v45 = (__CFString *)objc_claimAutoreleasedReturnValue([v13 summary]);
      }
      else {
        uint64_t v45 = @"N";
      }
      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v63 summary]);
      *(_DWORD *)buf = 138544386;
      *(void *)&buf[4] = v44;
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v20;
      *(_WORD *)&buf[22] = 2114;
      *(void *)&buf[24] = v38;
      uint64_t v67 = 2114;
      uint64_t v68 = v45;
      uint64_t v69 = 2114;
      uint64_t v70 = v55;
      _os_log_impl( &dword_0,  v43,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {_updateSandboxExtensionForResponse} MADAutoAssetAuthorizationPolicy successfully set sandbox exten sion for response message | assetType=%{public}@, path=%{public}@, responseMessage:%{public}@, clientRequest:%{public}@",  buf,  0x34u);
      if (v13) {
    }
      }

    id v32 = v61;
    id v11 = v62;
    v47 = v60;
  }

  else
  {
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v46 oslog]);

    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      uint64_t v57 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      if (v13) {
        uint64_t v58 = (__CFString *)objc_claimAutoreleasedReturnValue([v13 summary]);
      }
      else {
        uint64_t v58 = @"N";
      }
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v63 summary]);
      *(_DWORD *)buf = 138544386;
      *(void *)&buf[4] = v57;
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v20;
      *(_WORD *)&buf[22] = 2114;
      *(void *)&buf[24] = v25;
      uint64_t v67 = 2114;
      uint64_t v68 = v58;
      uint64_t v69 = 2114;
      uint64_t v70 = v59;
      _os_log_error_impl( &dword_0,  v47,  OS_LOG_TYPE_ERROR,  "[%{public}@] {_updateSandboxExtensionForResponse} MADAutoAssetAuthorizationPolicy failed set sandbox extension f or response message | assetType=%{public}@, path=%{public}@, responseMessage:%{public}@, clientRequest:%{public}@",  buf,  0x34u);
      if (v13) {
    }
      }

    v41 = (SUCoreConnectMessage *)v13;
  }

  uint64_t v12 = v63;
LABEL_42:

  return v41;
}
}

  return v12;
}

  return v17;
}

  return v20;
}

  return v19;
}

  if (a5 && v11) {
    *a5 = v11;
  }

  return v25;
}

  if (v5 < a3)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  if (v5 < v6)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }

  if (v6 < 0) {
LABEL_16:
  }
    __break(1u);
}

LABEL_34:
}

  [*(id *)(a1 + 40) _personalizeGraftSetDownloaded:*(void *)(a1 + 48) forSetDescriptor:*(void *)(a1 + 64) allowingNetwork:v28 != 0 requiringPersonalization:v36 requiringGrafting:v37 shouldGraft:*(unsigned __int8 *)(a1 + 81) completion:*(void *)(a1 + 72)];
LABEL_38:
}

  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v90 = (id)objc_claimAutoreleasedReturnValue( +[MADAutoAssetScheduler jobsAwaitingTrigger]( &OBJC_CLASS___MADAutoAssetScheduler,  "jobsAwaitingTrigger"));
  v91 = [v90 countByEnumeratingWithState:&v146 objects:v158 count:16];
  if (!v91)
  {
LABEL_43:
    v142 = 0LL;
    v99 = v90;
LABEL_47:

    goto LABEL_8;
  }

  v92 = v91;
  v93 = *(void *)v147;
LABEL_36:
  v94 = 0LL;
  while (1)
  {
    if (*(void *)v147 != v93) {
      objc_enumerationMutation(v90);
    }
    v95 = *(void **)(*((void *)&v146 + 1) + 8 * v94);
    if (([v95 setJob] & 1) == 0)
    {
      v96 = (void *)objc_claimAutoreleasedReturnValue([v95 assetSelector]);
      v97 = (void *)objc_claimAutoreleasedReturnValue([v2 clientAssetSelector]);
      v98 = +[MADAutoAssetScheduler isSelector:consideredEqualTo:]( &OBJC_CLASS___MADAutoAssetScheduler,  "isSelector:consideredEqualTo:",  v96,  v97);

      if ((v98 & 1) != 0) {
        break;
      }
    }

    if (v92 == (id)++v94)
    {
      v92 = [v90 countByEnumeratingWithState:&v146 objects:v158 count:16];
      if (v92) {
        goto LABEL_36;
      }
      goto LABEL_43;
    }
  }

  v99 = v95;

  if (v99)
  {
    __int128 v88 = v140;
    goto LABEL_46;
  }

  v142 = 0LL;
LABEL_8:
  if (v142)
  {
    id v31 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v32 = objc_alloc(&OBJC_CLASS___MAAutoAssetInfoFound);
    unsigned int v33 = v139;
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v139 clientAssetSelector]);
    __int128 v35 = (NSString *)-[MAAutoAssetInfoFound initForSelector:withLocalContentURL:withAssetAttributes:reportingStatus:]( v32,  "initForSelector:withLocalContentURL:withAssetAttributes:reportingStatus:",  v34,  0LL,  0LL,  v142);

    -[NSMutableDictionary setSafeObject:forKey:](v31, "setSafeObject:forKey:", v139, @"instance");
    -[NSMutableDictionary setSafeObject:forKey:](v31, "setSafeObject:forKey:", v35, @"found");
    __int128 v36 = objc_alloc(&OBJC_CLASS___SUCoreConnectMessage);
    __int128 v37 = v140;
    id v38 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 40) clientRequestMessage]);
    id v39 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager replyMessageNameForRequest:]( &OBJC_CLASS___MADAutoAssetControlManager,  "replyMessageNameForRequest:",  v38));
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 40) clientRequestMessage]);
    v41 = (void *)objc_claimAutoreleasedReturnValue([v40 clientID]);
    uint64_t v42 = -[SUCoreConnectMessage initWithType:messageName:clientID:version:message:]( v36,  "initWithType:messageName:clientID:version:message:",  2LL,  v39,  v41,  0LL,  v31);

    [*(id *)(v37 + 32) issueBuiltResponseForEventInfo:*(void *)(v37 + 40) issuingResponseMessage:v42 withResponseError:0 fromLocation:@"handleClientCurrentStatusRequest"];
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 32) logger]);
    uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue([v43 oslog]);

    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 32) _updateLatestSummary]);
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v139 clientAssetSelector]);
      v47 = (void *)objc_claimAutoreleasedReturnValue([v142 summary]);
      v48 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 40) summary]);
      *(_DWORD *)buf = 138544130;
      v151 = v45;
      v152 = 2114;
      v153 = v46;
      v154 = 2114;
      v155 = v47;
      v156 = 2114;
      v157 = v48;
      _os_log_impl( &dword_0,  v44,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {handleClientCurrentStatusRequest} current status request | selector:%{public}@, lastJobStatus:%{pu blic}@, event:%{public}@",  buf,  0x2Au);

      __int128 v37 = v140;
    }

    if ([*(id *)(v37 + 32) simulateOperationRequested])
    {
      unsigned __int8 v49 = v138;
      if (v138
        || (v50 = *(void **)(v37 + 32),
            v51 = (void *)objc_claimAutoreleasedReturnValue([v139 clientAssetSelector]),
            unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([v50 currentJobBySelector:v51]),
            v51,
            v49))
      {
        uint64_t v52 = *(void **)(v37 + 32);
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v139 clientAssetSelector]);
        uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v52 jobControlInformationForSelector:v53]);
        [v49 clientRequestedStatus:v54];
      }
    }

    else
    {
      unsigned __int8 v49 = v138;
    }
  }

  else
  {
    uint64_t v55 = *(void **)(v140 + 32);
    v56 = *(void *)(v140 + 40);
    uint64_t v57 = objc_alloc(&OBJC_CLASS___NSString);
    unsigned int v33 = v139;
    id v31 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue([v139 summary]);
    __int128 v35 = -[NSString initWithFormat:]( v57,  "initWithFormat:",  @"current status requested for unknown asset-selector (no status available for instance:%@)",  v31);
    [v55 issueResponseForEventInfo:v56 withErrorCode:6301 fromAction:@"RouteClientRequest" withDescription:v35];
    unsigned __int8 v49 = v138;
  }
}

LABEL_35:
          objc_autoreleasePoolPop(v12);
          uint64_t v10 = (char *)v10 + 1;
        }

        while (v73 != v10);
        uint64_t v45 = [obj countByEnumeratingWithState:&v79 objects:v90 count:16];
        v73 = v45;
      }

      while (v45);
    }

    id v8 = v68;
    if (-[NSMutableArray count](v68, "count"))
    {
      obja = objc_autoreleasePoolPush();
      id v75 = 0u;
      id v76 = 0u;
      id v77 = 0u;
      v78 = 0u;
      uint64_t v46 = v68;
      v47 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v46,  "countByEnumeratingWithState:objects:count:",  &v75,  v83,  16LL);
      if (v47)
      {
        v48 = v47;
        unsigned __int8 v49 = *(void *)v76;
        v50 = @"loadPersistedActiveJobs";
        do
        {
          v51 = 0LL;
          uint64_t v74 = v48;
          do
          {
            if (*(void *)v76 != v49) {
              objc_enumerationMutation(v46);
            }
            uint64_t v52 = *(const __CFString **)(*((void *)&v75 + 1) + 8LL * (void)v51);
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
            uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v53 persistedEntry:v52 fromLocation:v50]);

            if (v54)
            {
              uint64_t v55 = [v54 secureCodedObjectForKey:@"assetDescriptor" ofClass:objc_opt_class(MADAutoAssetDescriptor)];
              v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
              uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
              [v57 removePersistedEntry:v52 fromLocation:v50];

              if (v56)
              {
                -[MADAutoAssetControlManager _logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:]( self,  "_logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:",  v50,  @"ACTIVE-JOBS",  v52,  v56,  @"removing stale active-persisted job encountered while loading persisted state");
              }

              else
              {
                uint64_t v58 = v50;
                uint64_t v59 = v49;
                uint64_t v60 = v46;
                v61 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                v62 = (os_log_s *)objc_claimAutoreleasedReturnValue([v61 oslog]);

                if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                {
                  id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                  *(_DWORD *)buf = 138543618;
                  id v85 = (uint64_t)v63;
                  __int128 v86 = 2114;
                  __int128 v87 = v52;
                  _os_log_error_impl( &dword_0,  v62,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedActiveJobs} no persisted job descriptor for previously active-job | entryID:%{public}@",  buf,  0x16u);
                }

                uint64_t v46 = v60;
                unsigned __int8 v49 = v59;
                v50 = v58;
                v48 = v74;
              }
            }

            v51 = (char *)v51 + 1;
          }

          while (v48 != v51);
          v48 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v46,  "countByEnumeratingWithState:objects:count:",  &v75,  v83,  16LL);
        }

        while (v48);
      }

      objc_autoreleasePoolPop(obja);
      id v8 = v68;
    }
  }

  else
  {
    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue([v64 oslog]);

    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      *(_DWORD *)buf = 138543362;
      id v85 = (uint64_t)v66;
      _os_log_impl( &dword_0,  v65,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {loadPersistedActiveJobs} no persisted auto-asset active-jobs to be resumed",  buf,  0xCu);
    }
  }

  -[MADAutoAssetControlManager _logPersistedTableOfContents:forComponentType:]( self,  "_logPersistedTableOfContents:forComponentType:",  @"loadPersistedActiveJobs",  @"ACTIVE-JOBS");
}

          uint64_t v16 = v62;
        }

        objc_autoreleasePoolPop(v19);
        id v17 = (char *)v17 + 1;
      }

      while (v15 != v17);
      v41 = [obj countByEnumeratingWithState:&v68 objects:v81 count:16];
      uint64_t v15 = v41;
      if (!v41)
      {
LABEL_39:

        uint64_t v6 = v51;
        break;
      }
    }
  }

  uint64_t v66 = 0u;
  uint64_t v67 = 0u;
  uint64_t v64 = 0u;
  uint64_t v65 = 0u;
  uint64_t v42 = v60;
  uint64_t v43 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v64,  v72,  16LL);
  if (v43)
  {
    uint64_t v44 = v43;
    uint64_t v45 = *(void *)v65;
    do
    {
      for (uint64_t i = 0LL; i != v44; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v65 != v45) {
          objc_enumerationMutation(v42);
        }
        v47 = *(void *)(*((void *)&v64 + 1) + 8LL * (void)i);
        v48 = objc_autoreleasePoolPush();
        -[MADAutoAssetControlManager _removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:]( self,  "_removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:",  v10,  v47,  402LL,  0LL);
        objc_autoreleasePoolPop(v48);
      }

      uint64_t v44 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v64,  v72,  16LL);
    }

    while (v44);
  }
}

          objc_autoreleasePoolPop(v28);
          uint64_t v26 = (char *)v26 + 1;
        }

        while (v109 != v26);
        uint64_t v57 = [v106 countByEnumeratingWithState:&v112 objects:v126 count:16];
        v109 = v57;
      }

      while (v57);
LABEL_39:

      id v18 = v95;
      uint64_t v16 = v96;
      uint64_t v58 = v99;
      if (-[NSMutableArray count](log, "count"))
      {
        uint64_t v59 = -[NSMutableArray count](log, "count");
        uint64_t v60 = v59 == -[NSMutableArray count](v102, "count");
        uint64_t v58 = v99;
        if (v60)
        {
          v61 = (char *)-[NSMutableArray count](log, "count");
          if ((uint64_t)v61 >= 1)
          {
            v62 = v61;
            for (uint64_t i = 0LL; i != v62; ++i)
            {
              uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndex:](log, "objectAtIndex:", i));
              uint64_t v65 = objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndex:](v102, "objectAtIndex:", i));
              uint64_t v66 = (void *)v65;
              if (v64)
              {
                if (v65)
                {
                  uint64_t v67 = *(void **)(v1 + 32);
                  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v64 clientLockReason]);
                  uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v68 autoAssetClientName]);
                  uint64_t v70 = v62;
                  uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v66 fullAssetSelector]);
                  id v72 = (void *)objc_claimAutoreleasedReturnValue([v64 clientLockReason]);
                  v73 = (void *)objc_claimAutoreleasedReturnValue([v72 lockReason]);
                  uint64_t v74 = [v64 activeLockCount];
                  v111 = 0LL;
                  [v67 _endLocksByClient:v69 forAllClientNames:0 forClientProcessName:0 withClientProcessID:0 forClientDomainName:0 for AssetSetIdentifier:0 forAssetSelector:v71 forSetAtomicInstance:0 forLockReason:v73 removingLockCount:v74 endError:&v111];
                  id v75 = v111;

                  uint64_t v58 = v99;
                  uint64_t v1 = v101;

                  v62 = v70;
                  id v76 = v75;

                  p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                  id v18 = v95;
                  uint64_t v16 = v96;
                  if (v76)
                  {
                    id v77 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
                    v78 = (os_log_s *)objc_claimAutoreleasedReturnValue([v77 oslog]);

                    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
                    {
                      v79 = (void *)objc_claimAutoreleasedReturnValue([v66 summary]);
                      v80 = (void *)objc_claimAutoreleasedReturnValue([v64 summary]);
                      v81 = (void *)objc_claimAutoreleasedReturnValue([v76 checkedSummary]);
                      *(_DWORD *)buf = 138543874;
                      v121 = v79;
                      v122 = 2114;
                      v123 = v80;
                      v124 = 2114;
                      v125 = v81;
                      _os_log_error_impl( &dword_0,  v78,  OS_LOG_TYPE_ERROR,  "{AUTO-LOCKER:currentSetLockUsageEliminatingOtherThanSetAtomicInstances} failed to drop stale loc k | dropFromAssetLock:%{public}@, dropLockTracker:%{public}@ | error:%{public}@",  buf,  0x20u);

                      p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                    }

                    id v18 = v95;
                    uint64_t v16 = v96;
                    uint64_t v58 = v99;
                  }
                }
              }
            }
          }
        }
      }

      uint64_t v3 = v92;
      uint64_t v15 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
      uint64_t v23 = v105;
LABEL_60:

LABEL_61:
      objc_autoreleasePoolPop(v18);
      uint64_t v16 = (char *)v16 + 1;
    }

    while (v16 != v98);
    __int128 v89 = [obj countByEnumeratingWithState:&v116 objects:v127 count:16];
    v98 = v89;
  }

  while (v89);
LABEL_66:

  if (-[NSMutableDictionary count](v104, "count")) {
    objc_storeStrong((id *)(*(void *)(*(void *)(v1 + 48) + 8LL) + 40LL), v104);
  }

LABEL_69:
}

LABEL_20:
  }

  else
  {
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetConnector logger](self, "logger"));
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue([v27 oslog]);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetConnector _removeObserverForMarker:].cold.1(self, v4);
    }
  }
}

  id v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager availableForStaging](v2, "availableForStaging"));
  id v32 = [v31 count];

  if (v32)
  {
    unsigned int v33 = 0LL;
    __int128 v34 = -1LL;
    while (1)
    {
      __int128 v35 = objc_autoreleasePoolPush();
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager availableForStaging](v2, "availableForStaging"));
      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v36 objectAtIndex:v33]);

      v62 = 0u;
      id v63 = 0u;
      uint64_t v60 = 0u;
      v61 = 0u;
      id v38 = v58;
      id v39 = [v38 countByEnumeratingWithState:&v60 objects:v68 count:16];
      if (v39)
      {
        uint64_t v40 = v39;
        uint64_t v57 = v34;
        v41 = *(void *)v61;
        while (2)
        {
          for (j = 0LL; j != v40; j = (char *)j + 1)
          {
            if (*(void *)v61 != v41) {
              objc_enumerationMutation(v38);
            }
            uint64_t v43 = *(void *)(*((void *)&v60 + 1) + 8LL * (void)j);
            uint64_t v44 = objc_autoreleasePoolPush();
            uint64_t v45 = [v38 safeObjectForKey:v43 ofClass:objc_opt_class(MAAutoAssetSelector)];
            uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
            v47 = -[MADAutoAssetStager _doesSelector:matchDescriptor:](v59, "_doesSelector:matchDescriptor:", v46, v37);

            objc_autoreleasePoolPop(v44);
            if ((v47 & 1) != 0)
            {
              __int128 v34 = v33;
              uint64_t v2 = v59;
              goto LABEL_32;
            }
          }

          uint64_t v40 = [v38 countByEnumeratingWithState:&v60 objects:v68 count:16];
          if (v40) {
            continue;
          }
          break;
        }

        uint64_t v2 = v59;
        __int128 v34 = v57;
      }
}
}

  double v7 = v34;
  uint64_t v6 = v35;
LABEL_21:

  return v18 & 1;
}

        if (v11)
        {
          __int128 v34 = objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager chooseNewerSetDescriptor:considering:]( self,  "chooseNewerSetDescriptor:considering:",  v11,  v17));

          id v11 = (id)v34;
        }

        else
        {
          id v11 = v17;
        }

  if (!*(_BYTE *)(a1 + 104))
  {
    v48 = 0LL;
    goto LABEL_29;
  }

  v41 = 0;
LABEL_22:
  uint64_t v42 = *(void **)(a1 + 48);
  uint64_t v43 = *(void *)(a1 + 64);
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) clientDomainName]);
  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) assetSetIdentifier]);
  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) clientRequest]);
  v47 = (void *)objc_claimAutoreleasedReturnValue([v46 responseMessage]);
  v48 = (void *)objc_claimAutoreleasedReturnValue( [v42 updateAutoAssetSetStatus:v43 forClientDomain:v44 forAssetSetIdentifier:v45 forJobResponse:v47 withResponseError:v2 clea ringDownloadProgressReason:@"reached [secure operation] lock phase" withAssetSetStatus:0]);

LABEL_23:
  [*(id *)(a1 + 48) issueBuiltResponseForEventInfo:*(void *)(a1 + 88) issuingResponseMessage:v48 withResponseError:v2 fromLocation:*(void *)(a1 + 64)];
  if ((v41 & 1) == 0)
  {
    unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) autoAssetSetClientName]);
    v50 = *(void **)(a1 + 72);
    if (v49) {
      v51 = objc_claimAutoreleasedReturnValue([v50 autoAssetSetClientName]);
    }
    else {
      v51 = objc_claimAutoreleasedReturnValue([v50 clientProcessName]);
    }
    uint64_t v52 = (void *)v51;
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) clientDomainName]);
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) assetSetIdentifier]);
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) latestDownloadedAtomicInstance]);
    +[MADAutoAssetHistory recordFailedOperation:fromClient:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:failingWithError:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordFailedOperation:fromClient:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:failingWithError:",  504LL,  v52,  v53,  v54,  v55,  v2);
  }

            uint64_t v29 = (char *)v29 + 1;
          }

          while (v27 != v29);
          uint64_t v27 = [obj countByEnumeratingWithState:&v58 objects:v66 count:16];
        }

        while (v27);
LABEL_22:

        uint64_t v14 = v44;
        self = v45;
        uint64_t v16 = v47;
        id v11 = v48;
        p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
        id v13 = v46;
        char v24 = v50;
LABEL_23:

        uint64_t v21 = v52;
LABEL_24:

        objc_autoreleasePoolPop(context);
        uint64_t v16 = (char *)v16 + 1;
      }

      while (v16 != v13);
      id v13 = [v11 countByEnumeratingWithState:&v62 objects:v67 count:16];
      uint64_t v42 = 0;
      if (!v13) {
        goto LABEL_28;
      }
    }
  }

  uint64_t v42 = 0;
LABEL_28:

  return v42;
}
        }
      }

      objc_autoreleasePoolPop(v13);
      id v11 = (char *)v11 + 1;
    }

    while (v49 != v11);
    unsigned int v33 = [v9 countByEnumeratingWithState:&v54 objects:v59 count:16];
    unsigned __int8 v49 = v33;
  }

  while (v33);
LABEL_26:

  uint64_t v52 = 0u;
  uint64_t v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  __int128 v34 = v41;
  __int128 v35 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v50,  v58,  16LL);
  if (v35)
  {
    __int128 v36 = v35;
    __int128 v37 = *(void *)v51;
    do
    {
      for (uint64_t i = 0LL; i != v36; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v51 != v37) {
          objc_enumerationMutation(v34);
        }
        id v39 = *(void *)(*((void *)&v50 + 1) + 8LL * (void)i);
        uint64_t v40 = objc_autoreleasePoolPush();
        -[MADAutoAssetControlManager _removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:]( v44,  "_removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:",  @"_removeUnlockedForOlderSelectorsWithoutVersion",  v39,  402LL,  0LL);
        objc_autoreleasePoolPop(v40);
      }

      __int128 v36 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v50,  v58,  16LL);
    }

    while (v36);
  }

  uint64_t v4 = v47;
LABEL_34:
}

    goto LABEL_21;
  }

  if (![v8 foundByLookupWithoutAssetVersion])
  {
LABEL_21:
    uint64_t v27 = 0;
    goto LABEL_22;
  }

  double v20 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v8 assetType]);
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v8 assetSpecifier]);
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v8 assetVersion]);
  char v24 = -[MAAutoAssetSelector initForAssetType:withAssetSpecifier:matchingAssetVersion:]( v20,  "initForAssetType:withAssetSpecifier:matchingAssetVersion:",  v21,  v22,  v23);

  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetLocker lockedSelectorsForEliminate:]( &OBJC_CLASS___MADAutoAssetLocker,  "lockedSelectorsForEliminate:",  v24));
  uint64_t v26 = [v25 count];
  uint64_t v27 = v26 != 0LL;
  if (!v26)
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _newestVersionDownloaded:](self, "_newestVersionDownloaded:", v8));
    if (v28
      && !-[MADAutoAssetControlManager _isDownloadedDescriptorPartOfLatestToVend:fromLocation:]( self,  "_isDownloadedDescriptorPartOfLatestToVend:fromLocation:",  v8,  v13))
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue([v29 oslog]);

      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        *(_DWORD *)buf = 138544130;
        id v39 = v37;
        uint64_t v40 = 2114;
        v41 = v13;
        uint64_t v42 = 2114;
        id v31 = (void *)objc_claimAutoreleasedReturnValue([v8 summary]);
        uint64_t v43 = v31;
        uint64_t v44 = 2114;
        uint64_t v45 = objc_claimAutoreleasedReturnValue([v28 summary]);
        id v32 = (void *)v45;
        _os_log_impl( &dword_0,  v30,  OS_LOG_TYPE_DEFAULT,  "[%{public}@]\n [REMOVAL] {%{public}@} removing older downloaded descriptor | removingDescriptor:%{public}@, keepingDescriptor:%{public}@",  buf,  0x2Au);
      }

      [v9 addObject:v8];
    }
  }

LABEL_22:
  return v27;
}
}
}
}
}
}

          if (xpc_array_get_count(v11) <= ++v12) {
            goto LABEL_23;
          }
        }

        v14 |= strncmp(v19, "com.apple.cache_delete.public", 0x1EuLL) == 0;
LABEL_18:
        if ((v13 & 1) == 0) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }

    if (([v28 isEqualToString:@"NeverCollected"] & 1) == 0
      && (a3 == 6 || v29 > -1.0))
    {
      id v39 = [(id)v94[5] safeIntegerForKey:@"_RetentionPolicy"];
      uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
      _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | asset:%@ | Before alterSecondsBeforeCollection, number of seconds: %f",  v41,  v42,  v43,  v44,  (uint64_t)v40);

      __int128 v88 = 0LL;
      -[ControlManager alterSecondsBeforeCollection:forAssetTypeDir:determinedDescriptorType:fromDescriptors:isAutoAsset:autoAssetDescriptor:assetFilesystemSize:retentionPolicy:]( self,  "alterSecondsBeforeCollection:forAssetTypeDir:determinedDescriptorType:fromDescriptors:isAutoAsset:autoAssetDescr iptor:assetFilesystemSize:retentionPolicy:",  v21,  a3,  v87,  &v99,  &v88,  &v89,  v29,  v39,  v12,  *(void *)&v29);
      uint64_t v29 = v45;
      __int128 v36 = v88;
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
      _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | asset:%@ | After alterSecondsBeforeCollection, number of seconds: %f",  v47,  v48,  v49,  v50,  (uint64_t)v46);
    }

    else
    {
      __int128 v36 = 0LL;
    }

    if (([v28 isEqualToString:@"NeverCollected"] & 1) != 0
      || a3 != 6 && v29 <= -1.0)
    {
      v51 = (id)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
      _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | will not delete (never remove) | asset:%@",  v52,  v53,  v54,  v55,  (uint64_t)v51);
      __int128 v37 = 0LL;
LABEL_52:

      goto LABEL_53;
    }

    -[ControlManager currentTimeInSeconds](self, "currentTimeInSeconds");
    uint64_t v57 = v56;
    v51 = +[MADAutoAssetControlManager allocIntervalString:]( &OBJC_CLASS___MADAutoAssetControlManager,  "allocIntervalString:",  (uint64_t)v29);
    uint64_t v58 = v57 - ExistingClientUsage;
    __int128 v86 = +[MADAutoAssetControlManager allocIntervalString:]( &OBJC_CLASS___MADAutoAssetControlManager,  "allocIntervalString:",  (uint64_t)v58);
    if (a3 != 6 && v58 <= v29)
    {
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
      _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | will not delete (recent client interest) | asset:%@ | gapDuration:%@, removalThreshold:%@",  v60,  v61,  v62,  v63,  (uint64_t)v59);
      __int128 v37 = 0LL;
LABEL_51:

      goto LABEL_52;
    }

    uint64_t v64 = -[ControlManager reclaimSpace](self, "reclaimSpace");
    if (-[ControlManager reclaimSpace](self, "reclaimSpace"))
    {
      if (v99)
      {
        if (!v36)
        {
          __int128 v37 = 0LL;
          goto LABEL_50;
        }

        if (!+[MADAutoAssetControlManager assetBeingGarbageCollected:atEmergencyUrgency:]( &OBJC_CLASS___MADAutoAssetControlManager,  "assetBeingGarbageCollected:atEmergencyUrgency:",  v36,  -[ControlManager reclaimUrgency](self, "reclaimUrgency") > 3))
        {
          __int128 v37 = 0LL;
LABEL_50:
          uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
          _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | will not delete (%@) | asset:%@ | gapDuration:%@, removalThreshold:%@",  v80,  v81,  v82,  v83,  (uint64_t)v59);
          goto LABEL_51;
        }
      }

      else if ((v64 & 1) == 0)
      {
        __int128 v37 = 0LL;
        goto LABEL_50;
      }

      __int128 v37 = (int64_t)v89;
    }

    else
    {
      __int128 v37 = (int64_t)v89;
      if (!v64) {
        goto LABEL_50;
      }
    }

    uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v21 path]);
    uint64_t v66 = renameWithExtThenRemove(v65, @".purged");

    if (v66 == 3)
    {
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
      _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | old asset content did not exist | asset:%@ | gapDuration:%@, removalThreshold:%@",  v71,  v72,  v73,  v74,  (uint64_t)v59);
    }

    else
    {
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager cacheDeleteOperationName](self, "cacheDeleteOperationName"));
      if (v66)
      {
        id v75 = stringForMAPurgeResult(v66);
        id v85 = (void *)objc_claimAutoreleasedReturnValue(v75);
        _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | failed to remove old asset content | asset:%@ | gapDuration:%@, removalThreshold:%@ | result:%lld(%@)",  v76,  v77,  v78,  v79,  (uint64_t)v59);
      }

      else
      {
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} %@ | removed old asset content | asset:%@ | gapDuration:%@, removalThreshold:%@",  v67,  v68,  v69,  v70,  (uint64_t)v59);
      }
    }

    goto LABEL_51;
  }

  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager performGarbageCollectionOfType:forAssetTypeDir:fromDescriptors:cacheDeleteResults:]",  @"[GARBAGE_COLLECTION] {performGarbageCollectionOfType} Could not read asset attributes from assetDirectory(asset could be non-existent): %@, skipping asset.",  v22,  v23,  v24,  v25,  (uint64_t)v21);
  __int128 v36 = 0LL;
  __int128 v37 = 0LL;
LABEL_53:

  _Block_object_dispose(&v93, 8);
  return v37;
}
}

    if (!v8) {
      goto LABEL_52;
    }
    goto LABEL_21;
  }

  id v17 = (void *)objc_claimAutoreleasedReturnValue(-[MobileAssetKeyManager logger](self, "logger"));
  id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v17 oslog]);

  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
    -[MobileAssetKeyManager getDecryptionKeyFromAssetMetadataOrDownloadOptionsInternal:downloadOptions:error:].cold.1( v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25);
  }

  uint64_t v26 = (id)objc_claimAutoreleasedReturnValue( -[MobileAssetKeyManager buildKeyManagerError:underlying:description:]( self,  "buildKeyManagerError:underlying:description:",  30001LL,  0LL,  @"No attributes dict or download options passed to get decryption key function"));
  uint64_t v14 = 0LL;
LABEL_58:
  objc_autoreleasePoolPop(v11);
  if (a5 && v26)
  {
    uint64_t v26 = v26;
    *a5 = v26;
  }

    __break(1u);
    goto LABEL_21;
  }

  uint64_t v12 = v8(a2, a3);
  if (v12 < 0)
  {
    __break(1u);
    goto LABEL_20;
  }

  uint64_t v14 = v12;
  if (v12)
  {
    uint64_t v15 = (void *)static Array._allocateBufferUninitialized(minimumCapacity:)(v12, &type metadata for UInt8);
    v15[2] = v14;
    bzero(v15 + 4, v14);
  }

  else
  {
    uint64_t v15 = _swiftEmptyArrayStorage;
  }

  uint64_t v30 = v15;
  sub_2111CC(v5 + 32, v5 + 32 + *(void *)(v5 + 16), (uint64_t)&v30, a2, a3);
  swift_release(v5);
  sub_1F8384(v29, (uint64_t)v32);
  swift_bridgeObjectRelease(v30);
LABEL_18:
  id v17 = *(void (**)(uint64_t, uint64_t))(a3 + 32);
  type metadata accessor for HMAC(0LL, a2, a3, v9);
  v17(a2, a3);
  id v18 = v33;
  uint64_t v19 = v34;
  __swift_project_boxed_opaque_existential_1(v32, (uint64_t)v33);
  double v20 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_2113C8, 0LL, v20, v18, v19);
  uint64_t v21 = *(void *)&v29[0];
  uint64_t v22 = sub_2129F8( (unint64_t *)&qword_3A8070,  &qword_3A8060,  (uint64_t)&protocol conformance descriptor for <A> [A]);
  sub_235FD8((uint64_t)v29, a2, v20, a3, v22);
  swift_bridgeObjectRelease(v21);
  v17(a2, a3);
  uint64_t v23 = v33;
  char v24 = v34;
  __swift_project_boxed_opaque_existential_1(v32, (uint64_t)v33);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_2114C0, 0LL, v20, v23, v24);
  uint64_t v25 = *(void *)&v29[0];
  sub_235FD8((uint64_t)v29, a2, v20, a3, v22);
  __swift_destroy_boxed_opaque_existential_1Tm(v32);
  return swift_bridgeObjectRelease(v25);
}

          __break(1u);
LABEL_21:
          __break(1u);
          goto LABEL_22;
        }

        if (v19 <= v8) {
          goto LABEL_72;
        }
      }

      if (v19 < 0) {
        goto LABEL_73;
      }
    }

    uint64_t v22 = v19 - v13;
    if (__OFSUB__(v19, v13)) {
      goto LABEL_74;
    }
    if (v22 < 0) {
      goto LABEL_75;
    }
    uint64_t v23 = v5 - v13;
    if (__OFSUB__(v5, v13)) {
      goto LABEL_76;
    }
    if (!v22 || v23 < 0 || (id v18 = v5, v23 >= v22))
    {
      id v18 = v19;
      if (__OFADD__(v13, v22)) {
        goto LABEL_80;
      }
      if (v5 < v19) {
        goto LABEL_77;
      }
    }

    if (v18 <= v8) {
      goto LABEL_78;
    }
    if (v13 != v19)
    {
      if (v13 >= v19) {
        goto LABEL_82;
      }
      char v24 = *(void *)(a2 + 48 * v13 + 8);
      if (v17 >= v24) {
        goto LABEL_83;
      }
      uint64_t v25 = v8 + 2;
      if (v8 + 2 != v19)
      {
        if (v8 + 2 >= v19) {
          goto LABEL_85;
        }
        uint64_t v26 = (void *)(v43 + 48 * v8);
        while (v25 > v8)
        {
          if (v17 >= *v26) {
            goto LABEL_67;
          }
          ++v25;
          v26 += 6;
          if (v19 == v25) {
            goto LABEL_40;
          }
        }

        __break(1u);
LABEL_67:
        __break(1u);
LABEL_68:
        __break(1u);
        goto LABEL_69;
      }

  uint64_t v19 = v49;
  if (__OFSUB__(v49, v47)) {
    goto LABEL_45;
  }
  if (v49 == v47) {
    goto LABEL_15;
  }
  double v20 = *((void *)v3 + 2);
  uint64_t v21 = v48;
  uint64_t v43 = v46;
  uint64_t v44 = v47;
  uint64_t v22 = sub_232798(v45, v49, v46, v47, v48, v5);
  char v24 = *v23;
  result = (char *)((uint64_t (*)(_BYTE *, void))v22)(v45, 0LL);
  uint64_t v25 = v19 - 1;
  if (v19 < 1) {
    goto LABEL_47;
  }
  uint64_t v26 = v21;
  uint64_t v42 = (71 - __clz(v21)) >> 3;
  if (v42 < v19) {
    goto LABEL_47;
  }
  uint64_t v27 = v44;
  uint64_t v28 = -v44;
LABEL_26:
  while (1)
  {
    uint64_t v29 = *((void *)v3 + 3);
    uint64_t v30 = v29 >> 1;
    id v31 = v20 + 1;
    id v32 = (_BYTE *)(v20 - v30);
    if (v20 < v30) {
      goto LABEL_28;
    }
LABEL_25:
    *((void *)v3 + 2) = v20;
  }

  id v38 = v3;
  id v39 = v26;
  result = sub_2121E4((char *)(v29 > 1), v20 + 1, 1, v38);
  uint64_t v26 = v39;
  uint64_t v27 = v44;
  uint64_t v3 = result;
  uint64_t v30 = *((void *)result + 3) >> 1;
  id v32 = (_BYTE *)(v20 - v30);
  if (v20 >= v30) {
    goto LABEL_25;
  }
LABEL_28:
  v3[v20 + 32] = v24;
  if (__OFSUB__(v25, v27)) {
    goto LABEL_46;
  }
  uint64_t v40 = v30;
  if (v25 == v27)
  {
LABEL_42:
    *((void *)v3 + 2) = v31;
    goto LABEL_15;
  }

  id v11 = v20;
  uint64_t v6 = 0LL;
  v41 = (_BYTE *)(v28 + v25);
  unsigned int v33 = v32 + 1;
  __int128 v34 = v3 + 33;
  while (1)
  {
    __int128 v35 = v26;
    __int128 v36 = sub_232798(v45, v25 + v6, v43, v27, v26, v32);
    char v24 = *v37;
    result = (char *)((uint64_t (*)(_BYTE *, void))v36)(v45, 0LL);
    if (v25 > v42 || v25 + v6 < 1) {
      break;
    }
    uint64_t v26 = v35;
    if (v33 == (_BYTE *)v6)
    {
      uint64_t v25 = v25 + v6 - 1;
      uint64_t v28 = -v44;
      double v20 = v40;
      uint64_t v27 = v44;
      *((void *)v3 + 2) = v40;
      goto LABEL_26;
    }

    v34[v11] = v24;
    uint64_t v27 = v44;
    if (__OFSUB__(v25 + v6 - 1, v44)) {
      goto LABEL_44;
    }
    --v6;
    ++v34;
    id v32 = v41;
    if (!&v41[v6]) {
      goto LABEL_41;
    }
  }

  __break(1u);
LABEL_44:
  __break(1u);
LABEL_45:
  __break(1u);
LABEL_46:
  __break(1u);
LABEL_47:
  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
}

LABEL_18:
    uint64_t v15 = 1;
    goto LABEL_19;
  }

    LOBYTE(v13) = 1;
  }

        if (v6)
        {
          char v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectForKeyedSubscript:@"requiredFeatures"]);
          uint64_t v25 = v24;
          if (v24 && [v24 count])
          {
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v6 attributes]);
            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 objectForKeyedSubscript:@"SupportedFeatures"]);

            if (v27)
            {
              uint64_t v28 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"New brain features: %@", v27));
              uint64_t v29 = [v28 UTF8String];
              _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainScanner locateAvailableUpdateBrain:options:completion:]_block_invoke_2",  @"[MAB] %s",  v30,  v31,  v32,  v33,  (uint64_t)v29);

              uint64_t v58 = 0LL;
              uint64_t v59 = 0LL;
              __int128 v34 = [v25 areRequirementsMetByBrainFeatures:v27 missingRequirements:&v59 error:&v58];
              uint64_t v53 = v59;
              id v5 = v58;
              if ((v34 & 1) != 0)
              {
                __int128 v35 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"New brain meets asset requirements - going forward with the update"));
                __int128 v36 = [v35 UTF8String];
                _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainScanner locateAvailableUpdateBrain:options:completion:]_block_invoke_2",  @"[MAB] %s",  v37,  v38,  v39,  v40,  (uint64_t)v36);
              }

              else
              {
                v47 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"New brain doesn't meet requirements: %@", v53));
                v48 = [v47 UTF8String];
                _MobileAssetLog( 0LL,  3,  (uint64_t)"-[MABrainScanner locateAvailableUpdateBrain:options:completion:]_block_invoke_2",  @"[MAB] %s",  v49,  v50,  v51,  v52,  (uint64_t)v48);

                __int128 v35 = v6;
                uint64_t v6 = 0LL;
              }
            }

            else
            {
              v41 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Available brain doesn't have any declared features. Asset requires: %@", v25));
              uint64_t v42 = [v41 UTF8String];
              _MobileAssetLog( 0LL,  3,  (uint64_t)"-[MABrainScanner locateAvailableUpdateBrain:options:completion:]_block_invoke_2",  @"[MAB] %s",  v43,  v44,  v45,  v46,  (uint64_t)v42);

              uint64_t v6 = 0LL;
              id v5 = 0LL;
            }
          }

          else
          {
            id v5 = 0LL;
          }

          goto LABEL_33;
        }

      goto LABEL_19;
    }

    id v31 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
    uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v31 oslog]);

    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138545154;
      __int128 v34 = @">----->";
      __int128 v35 = 2114;
      __int128 v36 = v15;
      __int128 v37 = 2114;
      id v38 = @"EVENT";
      id v39 = 2114;
      uint64_t v40 = v11;
      v41 = 2114;
      uint64_t v42 = @"EVENT";
      uint64_t v43 = 2114;
      uint64_t v44 = v12;
      uint64_t v45 = 2114;
      uint64_t v46 = v16;
      v47 = 2114;
      v48 = (unint64_t)@"<-----<";
      _os_log_impl( &dword_0,  v25,  OS_LOG_TYPE_DEFAULT,  "AUTO-CONTROL\n #_NOTIF:%{public}@ {%{public}@:postNotificationName}\n #_NOTIF:(%{public}@) posting notification:%{public}@\n #_NOTIF:(%{public}@) assetType:%{public}@%{public}@\n #_NOTIF:%{public}@",  buf,  0x52u);
    }

    goto LABEL_18;
  }

  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  id v17 = (id)objc_claimAutoreleasedReturnValue([v29 oslog]);

  if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138545154;
    __int128 v34 = @">----->";
    __int128 v35 = 2114;
    __int128 v36 = v15;
    __int128 v37 = 2114;
    id v38 = @"EVENT";
    id v39 = 2114;
    uint64_t v40 = v11;
    v41 = 2114;
    uint64_t v42 = @"EVENT";
    uint64_t v43 = 2114;
    uint64_t v44 = v12;
    uint64_t v45 = 2114;
    uint64_t v46 = v16;
    v47 = 2114;
    v48 = (unint64_t)@"<-----<";
    _os_log_impl( &dword_0,  (os_log_t)v17,  OS_LOG_TYPE_DEFAULT,  "AUTO-CONTROL\n !_NOTIF:%{public}@ {%{public}@:postNotificationName}\n !_NOTIF:(%{public}@) un-posted notification:%{public}@\n !_NOTIF:(%{public}@) assetType:%{public}@%{public}@\n !_NOTIF:%{public}@",  buf,  0x52u);
  }

          uint64_t v15 = v42 + 1;
        }

        while ((id)(v42 + 1) != v41);
        v41 = [obj countByEnumeratingWithState:&v51 objects:v56 count:16];
      }

      while (v41);
    }

    id v32 = -[NSMutableDictionary count](v38, "count");
    uint64_t v6 = v36;
    unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v36 autoAssetEntries]);
    __int128 v34 = v32 == [v33 count];
  }

  else
  {
    __int128 v34 = 0;
  }

  return v34;
}

              if (!v28) {
                goto LABEL_29;
              }
LABEL_26:
              if (v46)
              {
                unsigned int v33 = objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager chooseNewerSetDescriptor:considering:]( v47,  "chooseNewerSetDescriptor:considering:",  v46,  v18));

                uint64_t v46 = (id)v33;
              }

              else
              {
                uint64_t v46 = v18;
              }

              goto LABEL_29;
            }
          }

          else
          {

            uint64_t v28 = 0;
            if (!v27) {
              goto LABEL_24;
            }
          }

          uint64_t v9 = v42;

          a5 = v39;
        }

        if ((v21 & 1) == 0) {
          goto LABEL_25;
        }
        goto LABEL_18;
      }

      char v24 = p_ivars[155];
      uint64_t v25 = objc_claimAutoreleasedReturnValue([v18 assetSetIdentifier]);
      uint64_t v26 = v24;
      uint64_t v9 = (id)v25;
      if (-[__objc2_ivar_list stringIsEqual:to:](v26, "stringIsEqual:to:", v25, v38))
      {

        goto LABEL_26;
      }

      if (a5)
      {
        uint64_t v27 = 1;
        goto LABEL_12;
      }

LABEL_30:
      objc_autoreleasePoolPop(v48);
      uint64_t v14 = (char *)v14 + 1;
    }

    while (v45 != v14);
    __int128 v34 = [obj countByEnumeratingWithState:&v49 objects:v53 count:16];
    uint64_t v45 = v34;
  }

  while (v34);
LABEL_36:

  return v46;
}

        objc_autoreleasePoolPop(v33);
      }

      uint64_t v28 = [obj countByEnumeratingWithState:&v56 objects:v64 count:16];
      if (!v28)
      {
LABEL_20:

        v41 = objc_alloc(&OBJC_CLASS___MADAutoAssetEliminate);
        uint64_t v42 = v27;
        id v13 = v49;
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v49 clientRequest]);
        id v18 = v48;
        char v24 = (os_log_s *)v51;
        uint64_t v15 = v52;
        uint64_t v22 = -[MADAutoAssetEliminate initWithClientRequest:withAssetSelector:forClientDomain:forSetIdentifier:withDownloadedSetDescriptors:awaitingUnlocked:]( v41,  "initWithClientRequest:withAssetSelector:forClientDomain:forSetIdentifier:withDownloadedSetDescriptors:awaitingUnlocked:",  v43,  v48,  v42,  v52,  v51,  v47);

        if (v22)
        {
          uint64_t v12 = v50;
          uint64_t v44 = -[MADAutoAssetControlManager isSetIdentifierCurrentlyLocked:forClientDomainName:forAssetSetIdentifier:]( v55,  "isSetIdentifierCurrentlyLocked:forClientDomainName:forAssetSetIdentifier:",  v50,  v42,  v52);
          -[MADAutoAssetControlManager setIdentifierEliminate:usingEliminateTracker:whenCurrentlyLocked:beginningToEliminate:removingContent:]( v55,  "setIdentifierEliminate:usingEliminateTracker:whenCurrentlyLocked:beginningToEliminate:removingContent:",  v50,  v22,  v44,  1LL,  !v44 || !v47);
          goto LABEL_27;
        }

        uint64_t v12 = v50;
        -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( v55,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v49,  6101LL,  v50,  @"unable to allocate eliminate operation tracking entry");
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v55, "logger"));
        uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v46 oslog]);

        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          -[MADAutoAssetControlManager setDescriptorEliminate:triggeredByClient:forClientDomainName:forAssetSetIdentifier:awaitingUnlocked:].cold.1();
        }
LABEL_26:

        goto LABEL_27;
      }
    }
  }

  if (!-[MADAutoAssetEliminate awaitingUnlocked](v22, "awaitingUnlocked") || v7)
  {
    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v13,  6113LL,  v12,  @"already performing eliminate operation for the specified auto-asset-set identifier");
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue([v45 oslog]);

    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager setDescriptorEliminate:triggeredByClient:forClientDomainName:forAssetSetIdentifier:awaitingUnlocked:].cold.2();
    }
  }

  else
  {
    -[MADAutoAssetControlManager setIdentifierEliminate:usingEliminateTracker:whenCurrentlyLocked:beginningToEliminate:removingContent:]( self,  "setIdentifierEliminate:usingEliminateTracker:whenCurrentlyLocked:beginningToEliminate:removingContent:",  v12,  v22,  1LL,  0LL,  1LL);
    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v13,  0LL,  v12,  @"hard-eliminate completed (pending soft-eliminate should also have completed)");
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue([v23 oslog]);

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetEliminate summary](v22, "summary"));
      *(_DWORD *)buf = 138543618;
      v61 = v12;
      v62 = 2114;
      id v63 = v25;
      _os_log_impl( &dword_0,  v24,  OS_LOG_TYPE_DEFAULT,  "\n [SET-ELIMINATE]{%{public}@:setDescriptorEliminate} [SUCCESS] hard-eliminate (pending soft-eliminate should also have completed) | eliminateTracker:%{public}@",  buf,  0x16u);
      goto LABEL_26;
    }
  }

        objc_autoreleasePoolPop(v11);
        uint64_t v9 = (char *)v9 + 1;
      }

      while (v40 != v9);
      __int128 v35 = [obj countByEnumeratingWithState:&v41 objects:v49 count:16];
      uint64_t v40 = v35;
      if (!v35)
      {
LABEL_30:

        id v8 = v36;
        break;
      }
    }
  }
}
}

        objc_autoreleasePoolPop(v8);
        uint64_t v6 = (char *)v6 + 1;
      }

      while (v38 != v6);
      uint64_t v30 = [obj countByEnumeratingWithState:&v40 objects:v46 count:16];
      id v38 = v30;
      if (!v30)
      {
LABEL_23:

        id v5 = v32;
        break;
      }
    }
  }

  return v33;
}

      __break(1u);
      goto LABEL_19;
    }
  }

  id v8 = a4 + v7;
  if (!__OFADD__(a4, v7)) {
    goto LABEL_10;
  }
LABEL_22:
  __break(1u);
  return result;
}

  sub_222AE4(v1, v2, &qword_3A82C0);
  return v3;
}

  __break(1u);
}

  __break(1u);
  return result;
}

void OUTLINED_FUNCTION_0( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_3( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void sub_3F880(_Unwind_Exception *a1)
{
}

LABEL_30:
}

        -[MADAutoAssetJob setSimulateTriggered:]( self,  "setSimulateTriggered:",  -[MADAutoAssetJob simulateOperation](self, "simulateOperation"));
        -[MADAutoAssetJob simulateEnd:](self, "simulateEnd:", 0LL);
        goto LABEL_46;
      }

      if (!v31) {
        goto LABEL_30;
      }
      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      *(_DWORD *)buf = 138543874;
      uint64_t v70 = v37;
      uint64_t v71 = 2114;
      id v72 = v8;
      v73 = 2048;
      uint64_t v74 = -[MADAutoAssetJob simulateOperation](self, "simulateOperation");
      id v38 = "%{public}@ {%{public}@:requestDownloadManagerAssetDownload} | SIMULATE_OPERATION(%lld) | not starting asset "
            "download - immediate simulateEnd";
LABEL_29:
      _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, v38, buf, 0x20u);

      goto LABEL_30;
    }

    -[MADAutoAssetJob setDownloadingAssetDescriptor:](self, "setDownloadingAssetDescriptor:", v9);
    -[MADAutoAssetJob _extendAssetDownloadOptionsWithAnalyticsData:forDescriptor:withBaseForPatch:]( self,  "_extendAssetDownloadOptionsWithAnalyticsData:forDescriptor:withBaseForPatch:",  v8,  v9,  v10);
    id v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob assetDownloadOptions](self, "assetDownloadOptions"));
    uint64_t v64 = objc_alloc(&OBJC_CLASS___NSString);
    unsigned int v33 = @"Y";
    else {
      __int128 v34 = @"N";
    }
    v61 = v34;
    uint64_t v68 = +[MADAutoAssetControlManager allocIntervalString:]( MADAutoAssetControlManager,  "allocIntervalString:",  [v32 timeoutIntervalForResource]);
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v9 assetId]);
    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v32 decryptionKey]);
    if (!v35) {
      unsigned int v33 = @"N";
    }
    __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v32 sourceDirectory]);
    v62 = v32;
    if (v36) {
      uint64_t v66 = (__CFString *)objc_claimAutoreleasedReturnValue([v32 sourceDirectory]);
    }
    else {
      uint64_t v66 = @"N";
    }
    id v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob assetDownloadOptions](self, "assetDownloadOptions"));
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v39 analyticsData]);
    id v63 = v8;
    if (v40)
    {
      uint64_t v60 = v35;
      v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob assetDownloadOptions](self, "assetDownloadOptions"));
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 analyticsData]);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v42 safeSummary]);
      uint64_t v65 = -[NSString initWithFormat:]( v64,  "initWithFormat:",  @"discretionary:%@, timeout:%@ | assetId:%@ | decrypt:%@, source:%@ | analyticsData:%@",  v61,  v68,  v67,  v33,  v66,  v43);

      id v8 = v63;
      __int128 v35 = v60;
    }

    else
    {
      uint64_t v65 = -[NSString initWithFormat:]( v64,  "initWithFormat:",  @"discretionary:%@, timeout:%@ | assetId:%@ | decrypt:%@, source:%@ | analyticsData:%@",  v61,  v68,  v67,  v33,  v66,  @"N");
    }

    if (v36) {
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
    }
    uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue([v44 oslog]);

    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      *(_DWORD *)buf = 138543874;
      uint64_t v70 = v46;
      uint64_t v71 = 2114;
      id v72 = v8;
      v73 = 2114;
      uint64_t v74 = (int64_t)v65;
      _os_log_impl( &dword_0,  v45,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} DM:registerAssetDownloadJob | options:%{public}@",  buf,  0x20u);
    }

    if (-[MADAutoAssetJob autoAssetSetJob](self, "autoAssetSetJob"))
    {
      v47 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob verifyDownloadNotBlockedBySetPolicy:](self, "verifyDownloadNotBlockedBySetPolicy:", 1LL));
      if (v47)
      {
        v48 = (void *)v47;
        unsigned __int8 v49 = objc_alloc(&OBJC_CLASS___MADAutoAssetJobParam);
        v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetUUID](self, "autoAssetUUID"));
        v51 = -[MADAutoAssetJobParam initForFinishedJobID:withError:](v49, "initForFinishedJobID:withError:", v50, v48);

        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobFSM](self, "autoJobFSM"));
        [v52 postEvent:@"PolicyBlockCatalogDownload" withInfo:v51];
        uint64_t v53 = v62;
LABEL_45:

        goto LABEL_46;
      }

      v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSetAssetType](self, "autoAssetSetAssetType"));
      -[MADAutoAssetJob setNextSetSpecifierToDownload:]( self,  "setNextSetSpecifierToDownload:",  (char *)-[MADAutoAssetJob nextSetSpecifierToDownload](self, "nextSetSpecifierToDownload") + 1);
    }

    else
    {
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
      v48 = (void *)objc_claimAutoreleasedReturnValue([v54 assetType]);
    }

    DownloadManager = getDownloadManager();
    v51 = (id)objc_claimAutoreleasedReturnValue(DownloadManager);
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetUUID](self, "autoAssetUUID"));
    v56 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob clientName](self, "clientName"));
    uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v9 assetId]);
    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v9 metadata]);
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob setSpaceCheckedUUID](self, "setSpaceCheckedUUID"));
    uint64_t v53 = v62;
    [v51 registerAssetDownloadJob:v52 forAssetType:v48 withPurpose:@"auto" clientName:v56 usingDownloadOptions:v62 forAssetId:v57 withCatalogMetadata:v58 w ithSpaceCheckedUUID:v59];

    id v8 = v63;
    goto LABEL_45;
  }

  -[MADAutoAssetJob setSimulateTriggered:](self, "setSimulateTriggered:", v14);
  -[MADAutoAssetJob setSimulateDescriptor:](self, "setSimulateDescriptor:", v9);
  -[MADAutoAssetJob setSimulateBaseForPatch:](self, "setSimulateBaseForPatch:", v10);
  uint64_t v15 = objc_opt_respondsToSelector(&OBJC_CLASS___MANAutoAssetInfoControl, "nameOfSimulateOperation:");
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
  id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue([v16 oslog]);

  id v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if ((v15 & 1) != 0)
  {
    if (v18)
    {
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      double v20 = (void *)objc_claimAutoreleasedReturnValue( +[MANAutoAssetInfoControl nameOfSimulateOperation:]( &OBJC_CLASS___MANAutoAssetInfoControl,  "nameOfSimulateOperation:",  -[MADAutoAssetJob simulateOperation](self, "simulateOperation")));
      *(_DWORD *)buf = 138543874;
      uint64_t v70 = v19;
      uint64_t v71 = 2114;
      id v72 = v8;
      v73 = 2114;
      uint64_t v74 = (int64_t)v20;
      _os_log_impl( &dword_0,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}@ {%{public}@:requestDownloadManagerAssetDownload} | SIMULATE_OPERATION(%{public}@) | call to registerA ssetDownloadJob postponed",  buf,  0x20u);
    }
  }

  else if (v18)
  {
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
    *(_DWORD *)buf = 138543874;
    uint64_t v70 = v28;
    uint64_t v71 = 2114;
    id v72 = v8;
    v73 = 2048;
    uint64_t v74 = -[MADAutoAssetJob simulateOperation](self, "simulateOperation");
    _os_log_impl( &dword_0,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}@ {%{public}@:requestDownloadManagerAssetDownload} | SIMULATE_OPERATION(%lld) | call to registerAssetDown loadJob postponed",  buf,  0x20u);
  }

LABEL_46:
}

      return v5;
    case 6LL:
      id v18 = objc_alloc(&OBJC_CLASS___NSString);
      assetTargetRestoreVersion = @"N";
      assetTargetTrainName = (const __CFString *)self->_assetTargetTrainName;
      if (!assetTargetTrainName) {
        assetTargetTrainName = @"N";
      }
      if (self->_assetTargetRestoreVersion) {
        assetTargetRestoreVersion = (const __CFString *)self->_assetTargetRestoreVersion;
      }
      uint64_t v21 = -[NSString initWithFormat:]( v18,  "initWithFormat:",  @"STAGER_TARGET|[(assetTarget)OSVersion:%@|BuildVersion:%@|TrainName:%@|RestoreVersion:%@]|%@",  self->_assetTargetOSVersion,  self->_assetTargetBuildVersion,  assetTargetTrainName,  assetTargetRestoreVersion,  v4);
      goto LABEL_29;
    case 7LL:
      uint64_t v22 = objc_alloc(&OBJC_CLASS___NSString);
      double v7 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetDescriptor summary](self->_autoAssetDescriptor, "summary"));
      id v8 = -[NSString initWithFormat:]( v22,  "initWithFormat:",  @"IN_FLIGHT_DOWNLOAD|autoAssetDescriptor:%@|%@",  v7,  v4,  v28,  v29);
      goto LABEL_23;
    case 8LL:
      uint64_t v21 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"CONTROL_INFO|%@",  v4,  v26,  v28,  v29,  v30);
      goto LABEL_29;
    default:
      id v5 = @"UNKNOWN_TYPE";
      goto LABEL_30;
  }

            objc_autoreleasePoolPop(context);
            __int128 v35 = 1;
            goto LABEL_31;
          }
        }
      }

    uint64_t v15 = (v15 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_35:
    uint64_t v22 = 0LL;
    if (v16 < 0x4000 || v17 != v21) {
      goto LABEL_43;
    }
  }

  __break(1u);
LABEL_45:
  __break(1u);
LABEL_46:
  __break(1u);
  return result;
}

void sub_3FF3C(_Unwind_Exception *a1)
{
}

void sub_402B8(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

id _preferencesDomainProtectionDispatchQueue()
{
  if (_preferencesDomainProtectionDispatchQueue_preferencesDomainQueueOnce != -1) {
    dispatch_once(&_preferencesDomainProtectionDispatchQueue_preferencesDomainQueueOnce, &__block_literal_global_4);
  }
  return (id)_preferencesDomainProtectionDispatchQueue_preferencesDomainQueue;
}

void ___preferencesDomainProtectionDispatchQueue_block_invoke(id a1)
{
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.MobileAsset.preferencesDomain", 0LL);
  uint64_t v2 = (void *)_preferencesDomainProtectionDispatchQueue_preferencesDomainQueue;
  _preferencesDomainProtectionDispatchQueue_preferencesDomainQueue = (uint64_t)v1;
}

BOOL syncPreferences(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = _preferencesDomainProtectionDispatchQueue();
  uint64_t v6 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v5);
  dispatch_assert_queue_V2(v6);

  uint64_t v7 = CFPreferencesAppSynchronize(@"com.apple.MobileAsset");
  int v12 = v7;
  if ((_DWORD)v7) {
    _MobileAssetLog( 0LL,  5,  (uint64_t)"syncPreferences",  @"[MA_PREFS] {%@} [%@] Synchronized preferences for %@",  v8,  v9,  v10,  v11,  (uint64_t)v4);
  }
  else {
    _MobileAssetLog( v7,  3,  (uint64_t)"syncPreferences",  @"[MA_PREFS] {%@} [%@] Could not synchronize preferences for %@ - this may be a permissions error",  v8,  v9,  v10,  v11,  (uint64_t)v4);
  }

  return v12 != 0;
}

id _MAPreferencesCopyNSDataValue(void *a1)
{
  id v1 = a1;
  id v2 = _MAPreferencesCopyValue(v1);
  id v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFDataGetTypeID())
    {
      id v3 = v3;
    }

    else
    {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesCopyNSDataValue",  @"[MA_PREFS] {_MAPreferencesCopyNSDataValue} invalid type for key:%@ | expecting data",  v5,  v6,  v7,  v8,  (uint64_t)v1);
      id v3 = 0LL;
    }
  }

  return v3;
}

__CFString *_MAPreferencesCopyNSStringValue(void *a1)
{
  id v1 = a1;
  id v2 = (__CFString *)_MAPreferencesCopyValue(v1);
  id v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t v5 = v3;
    }

    else
    {
      CFTypeID v6 = CFGetTypeID(v3);
      if (v6 == CFNumberGetTypeID())
      {
        uint64_t v5 = (__CFString *)objc_claimAutoreleasedReturnValue(-[__CFString stringValue](v3, "stringValue"));
      }

      else
      {
        CFTypeID v7 = CFGetTypeID(v3);
        if (v7 != CFBooleanGetTypeID())
        {
          _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesCopyNSStringValue",  @"[MA_PREFS] {_MAPreferencesCopyNSStringValue} invalid type for key:%@ | expecting string or number or BOOLean",  v8,  v9,  v10,  v11,  (uint64_t)v1);
          id v3 = 0LL;
          goto LABEL_11;
        }

        int Value = CFBooleanGetValue((CFBooleanRef)v3);
        id v13 = @"YES";
        if (!Value) {
          id v13 = @"NO";
        }
        uint64_t v5 = v13;
      }
    }

    id v3 = v5;
  }

NSMutableArray *_MAPreferencesCopyArrayOfNumbers(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = v7;
  if (!v7 || (int v9 = [v7 count], v9 < 1))
  {
    uint64_t v10 = 0LL;
    goto LABEL_16;
  }

  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSNumberFormatter);
  -[NSNumberFormatter setNumberStyle:](v11, "setNumberStyle:", 1LL);
  uint64_t v12 = 0LL;
  while (1)
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndex:v12]);
    uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v13, v14) & 1) == 0) {
      break;
    }
    uint64_t v15 = objc_claimAutoreleasedReturnValue(-[NSNumberFormatter numberFromString:](v11, "numberFromString:", v13));
    if (!v15)
    {
      uint64_t v22 = @"[MA_PREFS] {_MAPreferencesCopyArrayOfNumbers} invalid entry for key:%@ | value:%@ | index:%d | not a number (from string)";
      goto LABEL_14;
    }

    double v20 = (void *)v15;
    -[NSMutableArray addObject:](v10, "addObject:", v15);

LABEL_9:
    if (v9 == ++v12) {
      goto LABEL_15;
    }
  }

  uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v13, v21) & 1) != 0)
  {
    -[NSMutableArray addObject:](v10, "addObject:", v13);
    goto LABEL_9;
  }

  uint64_t v22 = @"[MA_PREFS] {_MAPreferencesCopyArrayOfNumbers} invalid entry for key:%@ | value:%@ | index:%d | not a number";
LABEL_14:
  _MobileAssetLog(0LL, 3, (uint64_t)"_MAPreferencesCopyArrayOfNumbers", v22, v16, v17, v18, v19, (uint64_t)v5);

  uint64_t v10 = 0LL;
LABEL_15:

LABEL_16:
  return v10;
}

id _MAPreferencesCopyNSArrayOfNumbersValue(void *a1)
{
  id v1 = a1;
  id v2 = _MAPreferencesCopyValue(v1);
  id v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFStringGetTypeID())
    {
      id v5 = v3;
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 componentsSeparatedByString:@","]);
      id v7 = _MAPreferencesCopyArrayOfNumbers(v1, v5, v6);
      id v3 = (void *)objc_claimAutoreleasedReturnValue(v7);
    }

    else
    {
      CFTypeID v8 = CFGetTypeID(v3);
      if (v8 == CFArrayGetTypeID())
      {
        id v13 = _MAPreferencesCopyArrayOfNumbers(v1, @"CFArray", v3);
        id v3 = (void *)objc_claimAutoreleasedReturnValue(v13);
      }

      else
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesCopyNSArrayOfNumbersValue",  @"[MA_PREFS] {_MAPreferencesCopyNSArrayOfNumbersValue} invalid type for key:%@ | expecting array of numbers",  v9,  v10,  v11,  v12,  (uint64_t)v1);
        id v3 = 0LL;
      }
    }
  }

  return v3;
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

id newPrefsCopyValueForKey(void *a1)
{
  id v1 = a1;
  id v2 = -[NSDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithContentsOfFile:",  @"/Library/Managed Preferences/mobile/com.apple.MobileAsset.plist");
  id v3 = v2;
  if (v2)
  {
    CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKey:](v2, "objectForKey:", v1));
    id v5 = [v4 copy];
  }

  else
  {
    id v5 = 0LL;
  }

  return v5;
}

id _MAPreferencesGetAppBooleanValue(void *a1, _BYTE *a2)
{
  id v3 = _MAPreferencesCopyValue(a1);
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
    char isKindOfClass = objc_opt_isKindOfClass(v4, v5);
    char v7 = isKindOfClass ^ 1;
    char v8 = isKindOfClass & 1;
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  char v8 = 0;
  char v7 = 1;
  if (a2) {
LABEL_3:
  }
    *a2 = v8;
LABEL_4:
  if ((v7 & 1) != 0) {
    id v9 = 0LL;
  }
  else {
    id v9 = [v4 BOOLValue];
  }

  return v9;
}

id _MAPreferencesGetAppIntegerValue(void *a1, _BYTE *a2)
{
  id v3 = _MAPreferencesCopyValue(a1);
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
    char isKindOfClass = objc_opt_isKindOfClass(v4, v5);
    char v7 = isKindOfClass ^ 1;
    char v8 = isKindOfClass & 1;
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  char v8 = 0;
  char v7 = 1;
  if (a2) {
LABEL_3:
  }
    *a2 = v8;
LABEL_4:
  if ((v7 & 1) != 0) {
    id v9 = 0LL;
  }
  else {
    id v9 = [v4 integerValue];
  }

  return v9;
}

uint64_t _MAPreferencesSetDataValue(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v14 = a4;
  uint64_t v25 = 0LL;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000LL;
  char v28 = 0;
  if (v7)
  {
    id v15 = _preferencesDomainProtectionDispatchQueue();
    uint64_t v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v15);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = ___MAPreferencesSetDataValue_block_invoke;
    block[3] = &unk_34DED8;
    id v20 = v7;
    id v21 = v8;
    id v22 = v9;
    id v23 = v14;
    char v24 = &v25;
    dispatch_sync(v16, block);
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesSetDataValue",  @"[MA_PREFS] {%@} [%@] nil preference key provided",  v10,  v11,  v12,  v13,  (uint64_t)v9);
  }

  uint64_t v17 = *((unsigned __int8 *)v26 + 24);
  _Block_object_dispose(&v25, 8);

  return v17;
}

void sub_44184(_Unwind_Exception *a1)
{
}

BOOL isValidTypeForPreferences(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  BOOL v6 = 0;
  if (v1)
  {
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFStringGetTypeID()
      || (CFTypeID v4 = CFGetTypeID(v2), v4 == CFNumberGetTypeID())
      || (CFTypeID v5 = CFGetTypeID(v2), v5 == CFBooleanGetTypeID()))
    {
      BOOL v6 = 1;
    }
  }

  return v6;
}

void _MAPreferencesSetKeyForValue(void *a1, void *a2)
{
  key = a1;
  id v3 = a2;
  id v4 = _preferencesDomainProtectionDispatchQueue();
  CFTypeID v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v4);
  dispatch_assert_queue_V2(v5);

  if (v3 && !isValidTypeForPreferences(v3))
  {
    CFTypeID v6 = CFGetTypeID(v3);
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesSetKeyForValue",  @"value of unsupported type %lu provided to set default was invalid",  v7,  v8,  v9,  v10,  v6);
  }

  else
  {
    CFPreferencesSetAppValue(key, v3, @"com.apple.MobileAsset");
  }
}

BOOL _MAPreferencesSetValues(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v24 = 0LL;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000LL;
  char v27 = 0;
  uint64_t v8 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[MA_PREFS] {%@} [%@] (%@) |",  @"com.apple.MobileAsset",  v6,  v7));
  uint64_t v13 = (void *)v8;
  if (v5)
  {
    id v14 = _preferencesDomainProtectionDispatchQueue();
    id v15 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v14);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = ___MAPreferencesSetValues_block_invoke;
    block[3] = &unk_34DED8;
    id v19 = v5;
    id v20 = v6;
    id v21 = v7;
    id v22 = v13;
    id v23 = &v24;
    dispatch_sync(v15, block);

    int v16 = *((unsigned __int8 *)v25 + 24);
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesSetValues",  @"%@ nil preference key provided",  v9,  v10,  v11,  v12,  v8);
    int v16 = *((unsigned __int8 *)v25 + 24);
  }

  _Block_object_dispose(&v24, 8);
  return v16 != 0;
}

void sub_44574(_Unwind_Exception *a1)
{
}

BOOL _MAPreferencesSetStringValue(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  uint64_t v28 = 0LL;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2020000000LL;
  char v31 = 0;
  uint64_t v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[MA_PREFS] {%@} [%@] (%@) |",  @"com.apple.MobileAsset",  v9,  v10));
  int v16 = (void *)v11;
  if (v7)
  {
    id v17 = _preferencesDomainProtectionDispatchQueue();
    uint64_t v18 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v17);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = ___MAPreferencesSetStringValue_block_invoke;
    block[3] = &unk_34DF40;
    id v22 = v7;
    id v23 = v8;
    id v24 = v9;
    id v25 = v10;
    id v26 = v16;
    char v27 = &v28;
    dispatch_sync(v18, block);

    int v19 = *((unsigned __int8 *)v29 + 24);
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MAPreferencesSetStringValue",  @"%@ nil preference key provided",  v12,  v13,  v14,  v15,  v11);
    int v19 = *((unsigned __int8 *)v29 + 24);
  }

  _Block_object_dispose(&v28, 8);
  return v19 != 0;
}

void sub_44808(_Unwind_Exception *a1)
{
}

uint64_t _MAPreferencesIsCentralizedCacheDeleteEnabled()
{
  if (_MAPreferencesIsCentralizedCacheDeleteEnabled_onceToken != -1) {
    dispatch_once(&_MAPreferencesIsCentralizedCacheDeleteEnabled_onceToken, &__block_literal_global_798);
  }
  return _MAPreferencesIsCentralizedCacheDeleteEnabled__centralizedCacheDeleteEnabled;
}

LABEL_7:
    uint64_t v12 = 0LL;
  }

  return v12;
}

  _Block_object_dispose(&v34, 8);

  return v15;
}

  if (v148)
  {
    if (v9) {
      goto LABEL_9;
    }
LABEL_20:
    if (((v14 | v15 | +[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v142,  @"MA-AUTO-SET(REPLY):LOCK_ATOMIC")) & 1) != 0) {
      goto LABEL_10;
    }
    goto LABEL_21;
  }

  id v17 = (void *)objc_claimAutoreleasedReturnValue([v5 autoAssetUUID]);

  if (v17)
  {
    v148 = (os_log_s *)objc_claimAutoreleasedReturnValue([v5 autoAssetUUID]);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v18 oslog]);

    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      id v20 = (__CFString *)objc_claimAutoreleasedReturnValue([v5 summary]);
      *(_DWORD *)buf = 138543362;
      v150 = v20;
      _os_log_impl( &dword_0,  v19,  OS_LOG_TYPE_DEFAULT,  "{IssueClientReplySetJob}\n [JOB-UUID] set-job with no assigned UUID - using event information | eventInfo:%{public}@",  buf,  0xCu);
    }
  }

  else
  {
    id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceUUIDFromCurrentStatus:]( self,  "atomicInstanceUUIDFromCurrentStatus:",  v146));
    int v19 = v21;
    if (v21)
    {
      int v19 = v21;
      id v22 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue([v22 oslog]);

      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        id v24 = (__CFString *)objc_claimAutoreleasedReturnValue([v146 summary]);
        *(_DWORD *)buf = 138543362;
        v150 = v24;
        _os_log_impl( &dword_0,  v23,  OS_LOG_TYPE_DEFAULT,  "{IssueClientReplySetJob}\n [JOB-UUID] set-job with no assigned UUID, no event UUID - using current set status | currentSetStatus:%{public}@",  buf,  0xCu);
      }
    }

    v148 = v19;
  }

  if (!v9) {
    goto LABEL_20;
  }
LABEL_9:
  if ((v14 | v15) == 1)
  {
LABEL_10:
    v139 = -[MADAutoAssetControlManager setJobFoundAllContent:forJobAtomicInstance:withCurrentSetStatus:]( self,  "setJobFoundAllContent:forJobAtomicInstance:withCurrentSetStatus:",  @"IssueClientReplySetJob",  v148,  v146);
    goto LABEL_22;
  }

  return v10;
}

  return v14;
}

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

    id v7 = (char *)v4;
    if ((unint64_t)(v8 - v4) <= 8)
    {
      if (v4 == v8)
      {
        id v5 = 0LL;
        if (!a2) {
          return 1LL;
        }
      }

      else
      {
        id v5 = 0LL;
        do
        {
          id v6 = *v4++;
          id v5 = v6 | (v5 << 8);
        }

        while (v4 != v8);
        if (!a2) {
          return 1LL;
        }
      }

      *a2 = v5;
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

  sub_1F83C0(result, a2);
  sub_234B20(v7, v6);
  __int128 v34 = v33;
  swift_beginAccess(a3 + 16, v68, 0LL, 0LL);
  __int128 v35 = *(void *)(a3 + 16);
  __int128 v36 = a3 + 32;
  __int128 v37 = v36 + v35;
  id v38 = swift_retain(v34);
  sub_22C388( v38,  (uint64_t (*)(void))ccsha512_di,  &qword_3A87D8,  (void (*)(uint64_t, uint64_t))sub_21D398,  (char *)sub_22C9CC,  &v63);
  id v39 = (char *)UnsafeRawBufferPointer.regions.getter(v36, v37);
  sub_21D398(v39, v40);
  v41 = v63;
  sub_21D81C(&v64);
  v62 = v41;
  uint64_t v52 = v64;
  uint64_t v53 = v65;
  uint64_t v54 = v66;
  uint64_t v55 = v67;
  swift_retain(v41);
  sub_21D398((char *)&v52, (uint64_t)&v56);
  uint64_t v42 = v62;
  swift_retain(v62);
  sub_21D81C(&v57);
  swift_release(*((void *)&v41 + 1));
  swift_release(v41);
  swift_release_n(v42, 2LL);
  v48 = v58;
  v51 = v57;
  uint64_t v46 = v59;
  uint64_t v43 = v60;
  uint64_t v44 = v61;
  swift_release(v34);
  sub_1F86D4(v7, v6);
  uint64_t v45 = type metadata accessor for SecureBytes.Backing(0LL);
  a3 = swift_allocObject(v45, 96LL, 7LL);
  *(_OWORD *)(a3 + 16) = xmmword_281330;
  _swift_stdlib_malloc_size((const void *)a3);
  *(_OWORD *)(a3 + 32) = v51;
  *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 80), 8) = v48;
  *(_OWORD *)(a3 + 64) = v46;
  *(void *)(a3 + 80) = v43;
  *(void *)(a3 + 8_Block_object_dispose((const void *)(v1 - 80), 8) = v44;
  swift_beginAccess(a3 + 16, &v64, 1LL, 0LL);
  *(void *)(a3 + 16) = 64LL;
  result = _swift_stdlib_malloc_size((const void *)a3);
  if (result < 96) {
    __break(1u);
  }
LABEL_8:
  *a5 = a3;
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

      __break(1u);
      JUMPOUT(0x238368LL);
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  goto LABEL_7;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

LABEL_35:
          goto LABEL_36;
        }

        id v32 = (void *)objc_claimAutoreleasedReturnValue([v14 logger]);
        id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v32 oslog]);

        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          else {
            unsigned int v33 = @"NO";
          }
          *(_DWORD *)buf = 138544386;
          else {
            __int128 v34 = @"NO";
          }
          id v38 = v10;
          id v39 = 2114;
          uint64_t v40 = v33;
          v41 = 2114;
          uint64_t v42 = v34;
          uint64_t v43 = 2114;
          uint64_t v44 = v7;
          uint64_t v45 = 2114;
          uint64_t v46 = v8;
          id v26 = "\n"
                "[AUTO-SECURE][LOCAL-CONTENT-URL] {%{public}@} SecureMobileAssetBundle accessible yet no accessPath | isS"
                "ecureMobileAsset:%{public}@ | isAccessible:%{public}@ | assetType:%{public}@ | assetId:%{public}@";
LABEL_45:
          __int128 v35 = v25;
          __int128 v36 = 52;
LABEL_48:
          _os_log_error_impl(&dword_0, v35, OS_LOG_TYPE_ERROR, v26, buf, v36);
        }

LABEL_36:
        objc_autoreleasePoolPop(v12);
        id v10 = (char *)v10 + 1;
      }

      while (v9 != v10);
      v50 = [obj countByEnumeratingWithState:&v65 objects:v79 count:16];
      id v9 = v50;
      if (!v50)
      {
LABEL_46:

        v51 = v54;
        id v5 = v55;
        id v6 = v59;
        goto LABEL_50;
      }
    }
  }

  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  v51 = (os_log_s *)objc_claimAutoreleasedReturnValue([v52 oslog]);

  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
    +[MADAutoAssetSecure latestDownloadedAtomicInstanceEntries:forSetDescriptor:].cold.1();
  }
  v61 = (NSMutableArray *)v7;
LABEL_50:

  return v61;
}

    if (v47) {
      goto LABEL_44;
    }
LABEL_41:
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler logger](v79, "logger"));
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v53 oslog]);

    if (os_log_type_enabled((os_log_t)v54, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler summary](v79, "summary"));
      v56 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
      *(_DWORD *)buf = 138543618;
      __int128 v86 = v55;
      __int128 v87 = 2114;
      __int128 v88 = v56;
      _os_log_impl( &dword_0,  (os_log_t)v54,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {AUTO-SCHEDULER:_scheduleSelector} already scheduled | alreadyAwaiting:%{public}@",  buf,  0x16u);
    }

    goto LABEL_49;
  }
}

                      -[NSMutableArray addObject:](v91, "addObject:", v32);
                      goto LABEL_36;
                    }

                    p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                    uint64_t v40 = v87;
                    id v38 = v88;
                    uint64_t v43 = v86;
                  }

                  uint64_t v30 = v89;
                  uint64_t v29 = v39;
                }

                break;
              }

              goto LABEL_35;
            }
          }

          else
          {
            id v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
            id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v24 oslog]);

            p_ivars = v13;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](v79, "_updateLatestSummary"));
              *(_DWORD *)buf = 138543618;
              v103 = v27;
              v104 = 2114;
              v105 = v14;
              _os_log_error_impl( &dword_0,  v25,  OS_LOG_TYPE_ERROR,  "[%{public}@] {updateLookupResultsJustStaged} unable to load set-lookup-result | entryID:%{public}@",  buf,  0x16u);
            }
          }

          self = v79;
        }

        else
        {
          id v22 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
          id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue([v22 oslog]);

          log = v23;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            id v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543618;
            v103 = v26;
            v104 = 2114;
            v105 = v14;
            _os_log_error_impl( &dword_0,  v23,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {updateLookupResultsJustStaged} unable to retrieve set-lookup-result | entryID:%{public}@",  buf,  0x16u);
          }

          p_ivars = v13;
        }

        objc_autoreleasePoolPop(context);
      }

      id v9 = [obj countByEnumeratingWithState:&v97 objects:v106 count:16];
      if (!v9)
      {
LABEL_42:

        id v7 = v77;
        break;
      }
    }
  }
}

          objc_autoreleasePoolPop(v15);
        }

        uint64_t v69 = [v12 countByEnumeratingWithState:&v72 objects:v82 count:16];
        if (!v69)
        {
          id v9 = v61;
          id v5 = v62;
          id v10 = v65;
          break;
        }
      }
    }
  }

  else
  {
    v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v12 = (id)objc_claimAutoreleasedReturnValue([v47 oslog]);

    if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( &dword_0,  (os_log_t)v12,  OS_LOG_TYPE_DEFAULT,  "\n[AUTO-SECURE][AUTO-PERSONALIZATION][STARTUP] {DecideNeedPersonalize} no persisted known-descriptors",  buf,  2u);
    }
  }

  if (-[NSMutableDictionary count](v10, "count") || -[NSMutableDictionary count](v63, "count"))
  {
    -[MADAutoAssetControlManager secureStartupEstablishOperationSequence:forRequiringPersonalization:forRequiringGrafting:]( self,  "secureStartupEstablishOperationSequence:forRequiringPersonalization:forRequiringGrafting:",  @"DecideNeedPersonalize",  v10,  v63,  v61,  v62);
    if (-[NSMutableDictionary count](v10, "count"))
    {
      -[MADAutoAssetControlManager setSecureHealingPersonalizationAttempted:]( self,  "setSecureHealingPersonalizationAttempted:",  1LL);
      v48 = @"HaveNeedingPersonalize";
    }

    else
    {
      unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager prePersonalizedSelectors](self, "prePersonalizedSelectors"));
      v50 = [v49 count];

      if (v50)
      {
        v51 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager prePersonalizedSelectors](self, "prePersonalizedSelectors"));
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetSecure commitPrePersonalizedSync:committingSelectors:]( &OBJC_CLASS___MADAutoAssetSecure,  "commitPrePersonalizedSync:committingSelectors:",  @"DecideNeedPersonalize",  v51));

        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue([v53 oslog]);

        if (v52)
        {
          self = v66;
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
            -[MADAutoAssetControlManager action_DecideNeedPersonalize:error:].cold.1();
          }
        }

        else
        {
          self = v66;
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager prePersonalizedSelectors](v66, "prePersonalizedSelectors"));
            v56 = (const __CFString *)[v55 count];
            *(_DWORD *)buf = 134217984;
            id v77 = v56;
            _os_log_impl( &dword_0,  v54,  OS_LOG_TYPE_DEFAULT,  "\n [SECURE][AUTO-PERSONALIZATION-COMMIT][STARTUP] {DecideNeedPersonalize} | commit pre-personalized asset-sel ectors SUCCESS | prePersonalizedSelectors:%ld",  buf,  0xCu);

            self = v66;
          }
        }

        uint64_t v57 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        -[MADAutoAssetControlManager setPrePersonalizedSelectors:](self, "setPrePersonalizedSelectors:", v57);
      }

      v48 = @"HaveNeedingGraft";
    }
  }

  else
  {
    v48 = @"NoneNeedingPersonalize";
  }

  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM", v61, v62));
  uint64_t v59 = -[MADAutoAssetControlManagerParam initWithSafeSummary:]( objc_alloc(&OBJC_CLASS___MADAutoAssetControlManagerParam),  "initWithSafeSummary:",  @"DecideNeedPersonalize");
  [v58 followupEvent:v48 withInfo:v59];

  return 0LL;
}

              p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
              id v32 = (void *)v79;
LABEL_38:
              v41 = v77;
            }

            else
            {
              v78 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              uint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue([v78 oslog]);

              id v77 = v40;
              if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                goto LABEL_38;
              }

              -[MADAutoAssetControlManager considerSetDescriptorsForLatestToVend].cold.5((uint64_t)v109, (uint64_t)v18);
              v41 = v40;
              p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
            }
          }

          else
          {
            id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v39 = (os_log_s *)objc_claimAutoreleasedReturnValue([v38 oslog]);

            id v77 = v39;
            if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              goto LABEL_35;
            }
            -[MADAutoAssetControlManager considerSetDescriptorsForLatestToVend].cold.4((uint64_t)v110, (uint64_t)v18);
            v41 = v39;
            p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
            id v32 = (void *)v79;
          }

          goto LABEL_22;
        }

        id v21 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v21 oslog]);

        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR)) {
          -[MADAutoAssetControlManager considerSetDescriptorsForLatestToVend].cold.1(&v97, v98, (os_log_s *)v15);
        }
LABEL_24:

        objc_autoreleasePoolPop(v13);
        uint64_t v11 = (char *)v11 + 1;
      }

      while (v10 != v11);
      uint64_t v42 = [obj countByEnumeratingWithState:&v99 objects:v113 count:16];
      id v10 = v42;
      if (!v42)
      {
LABEL_43:

        v95 = 0u;
        v96 = 0u;
        v93 = 0u;
        v94 = 0u;
        uint64_t v43 = v7;
        obja = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v43,  "countByEnumeratingWithState:objects:count:",  &v93,  v108,  16LL);
        if (!obja) {
          goto LABEL_79;
        }
        v81 = *(void *)v94;
        v80 = v43;
        __int128 v86 = self;
        while (1)
        {
          uint64_t v44 = 0LL;
          do
          {
            if (*(void *)v94 != v81) {
              objc_enumerationMutation(v43);
            }
            uint64_t v45 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v43,  "safeObjectForKey:ofClass:",  *(void *)(*((void *)&v93 + 1) + 8LL * (void)v44),  objc_opt_class(&OBJC_CLASS___NSArray));
            uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
            __int128 v88 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            __int128 v89 = 0u;
            v90 = 0u;
            v91 = 0u;
            v92 = 0u;
            v47 = v46;
            v48 = [v47 countByEnumeratingWithState:&v89 objects:v107 count:16];
            if (!v48)
            {
              v50 = 0LL;
              uint64_t v66 = (os_log_s *)v47;
              goto LABEL_71;
            }

            id v85 = v44;
            unsigned __int8 v49 = 0LL;
            v50 = 0LL;
            v51 = *(void *)v90;
            do
            {
              for (uint64_t i = 0LL; i != v48; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v90 != v51) {
                  objc_enumerationMutation(v47);
                }
                uint64_t v53 = *(void **)(*((void *)&v89 + 1) + 8LL * (void)i);
                if (v53)
                {
                  if (v50
                    || (uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v89 + 1) + 8 * (void)i) clientDomainName]),  v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "assetSetIdentifier")),  v50 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetConfigurationByClientDomain:forAssetSetIdentifier:]( v86,  "locateSetConfigurationByClientDomain:forAssetSetIdentifier:",  v54,  v55)),  v55,  v54,  v50))
                  {
                    v56 = (void *)objc_claimAutoreleasedReturnValue([v53 latestDownloadedAtomicInstance]);
                    uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v50 latestAtomicInstanceToVend]);
                    uint64_t v58 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v56, v57);

                    if (v58)
                    {
                      uint64_t v59 = v53;

                      unsigned __int8 v49 = v59;
                    }

                    else
                    {
                      -[NSMutableArray addObject:](v88, "addObject:", v53);
                    }
                  }
                }
              }

              v48 = [v47 countByEnumeratingWithState:&v89 objects:v107 count:16];
            }

            while (v48);

            if (!v50
              || (-[MADAutoAssetControlManager decideSetDescriptorAsLatestToVend:currentlyVendingSetDescriptor:withOtherCandidateSetDescriptors:]( v86,  "decideSetDescriptorAsLatestToVend:currentlyVendingSetDescriptor:withOtherCandidateSetDescriptors:",  v50,  v49,  v88),  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v50 latestAtomicInstanceToVend]),  v60,  !v60))
            {
              uint64_t v43 = v80;
              uint64_t v44 = v85;
              goto LABEL_73;
            }

            v61 = (void *)objc_claimAutoreleasedReturnValue([v50 latestAtomicInstanceToVend]);
            v48 = (id)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedByAtomicInstanceUUID:]( v86,  "locateSetDescriptorDownloadedByAtomicInstanceUUID:",  v61));

            uint64_t v43 = v80;
            uint64_t v44 = v85;
            if (v48)
            {
              v62 = (void *)objc_claimAutoreleasedReturnValue([v50 autoAssetEntries]);
              id v63 = -[MADAutoAssetControlManager doesSetDescriptor:coverRequestedAutoAssetEntries:]( v86,  "doesSetDescriptor:coverRequestedAutoAssetEntries:",  v48,  v62);

              if ((v63 & 1) == 0)
              {
                uint64_t v64 = -[MADAutoAssetControlManager firstDaemonStartupSinceDeviceBoot]( v86,  "firstDaemonStartupSinceDeviceBoot");
                uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v86, "logger"));
                uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue([v65 oslog]);

                uint64_t v67 = os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
                if (v64)
                {
                  if (v67)
                  {
                    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v48 summary]);
                    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v50 summary]);
                    *(_DWORD *)buf = 138543618;
                    v104 = v68;
                    v105 = 2114;
                    v106 = v69;
                    _os_log_impl( &dword_0,  v66,  OS_LOG_TYPE_DEFAULT,  "{considerSetDescriptorsForLatestToVend} set-descriptor being vended does not cover current set-con figuration - triggering scheduler job | beingVendedSetDescriptor:%{public}@ | setConfiguration:%{public}@",  buf,  0x16u);
                  }

                  uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue([v50 clientDomainName]);
                  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v50 assetSetIdentifier]);
                  +[MADAutoAssetScheduler triggerWithRetrySetDomainName:forAssetSetIdentifier:usingSetUpdatePolicy:]( &OBJC_CLASS___MADAutoAssetScheduler,  "triggerWithRetrySetDomainName:forAssetSetIdentifier:usingSetUpdatePolicy:",  v66,  v70,  0LL);
                }

                else if (v67)
                {
                  uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v48 summary]);
                  id v72 = (void *)objc_claimAutoreleasedReturnValue([v50 summary]);
                  *(_DWORD *)buf = 138543618;
                  v104 = v71;
                  v105 = 2114;
                  v106 = v72;
                  _os_log_impl( &dword_0,  v66,  OS_LOG_TYPE_DEFAULT,  "{considerSetDescriptorsForLatestToVend} set-descriptor being vended does not cover current set-confi guration (not first MA daemon exeution) | beingVendedSetDescriptor:%{public}@ | setConfiguration:%{public}@",  buf,  0x16u);
                }

  v48 = v47 & 1;
  uint64_t v18 = v44;
  int v19 = v54;
LABEL_36:
  if (a7) {
    *a7 = v48;
  }
  if (a8) {
    *a8 = v46;
  }
  if (a9) {
    *a9 = v60;
  }
  if (a10) {
    *a10 = v67;
  }
  if (a11) {
    *a11 = v45;
  }
  unsigned __int8 v49 = v19;

  return v49;
}

void sub_48AC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void sub_49320( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_4A654(_Unwind_Exception *a1)
{
}

void sub_4DBF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

LABEL_86:
  v128 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) logger]);
  v129 = a1;
  v122 = (os_log_s *)objc_claimAutoreleasedReturnValue([v128 oslog]);

  if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
  {
    v130 = *(void *)(v129 + 40);
    v131 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(v129 + 56) summary]);
    *(_DWORD *)buf = 138543618;
    v186 = v130;
    v187 = 2114;
    v188 = v131;
    _os_log_impl( &dword_0,  v122,  OS_LOG_TYPE_DEFAULT,  "[\n [AUTO-SECURE][AUTO-PERSONALIZATION-GRAFT-SET] {%{public}@} personalize+graft|mount set SUCCESS | setDescriptor:%{public}@",  buf,  0x16u);
  }

  id v5 = 0LL;
LABEL_92:

  v132 = (void *)objc_claimAutoreleasedReturnValue(+[SUCore sharedCore](&OBJC_CLASS___SUCore, "sharedCore"));
  v133 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v132 selectCompletionQueue:0]);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __152__MADAutoAssetSecure__personalizeGraftSetDownloaded_forSetDescriptor_allowingNetwork_requiringPersonalization_requiringGrafting_shouldGraft_completion___block_invoke_753;
  block[3] = &unk_34E0F0;
  v170 = *(id *)(v166 + 72);
  v168 = *(id *)(v166 + 56);
  v169 = v5;
  v134 = v5;
  dispatch_async(v133, block);
}

  if (v145 <= v146)
  {
    v118 = v150;
    v117 = v151;
    if (v146 > v145)
    {
      v121 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
      v116 = (void *)objc_claimAutoreleasedReturnValue([v121 oslog]);

      if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT))
      {
LABEL_95:

        v120 = v151;
        v116 = v150;
        goto LABEL_96;
      }

      *(_DWORD *)buf = 134219520;
      v172 = obja;
      v173 = 2048;
      v174 = v160;
      v175 = 2048;
      v176 = v145;
      v177 = 2048;
      v178 = v147;
      v179 = 2048;
      v180 = v161;
      v181 = 2048;
      v182 = v146;
      v183 = 2048;
      v184 = v144;
      v122 = "\n"
             "{chooseNewerSetDescriptor} decided right (more newer) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld,"
             " (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
LABEL_94:
      _os_log_impl(&dword_0, (os_log_t)v116, OS_LOG_TYPE_DEFAULT, v122, buf, 0x48u);
      goto LABEL_95;
    }

    if (v147 < 1 || (uint64_t)obja > 0)
    {
      if ((uint64_t)obja < 1 || v147 > 0)
      {
        if (v161 < 1 || v160 > 0)
        {
          if (v160 >= 1 && v161 <= 0)
          {
            v127 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
            v116 = (void *)objc_claimAutoreleasedReturnValue([v127 oslog]);

            if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_95;
            }
            *(_DWORD *)buf = 134219520;
            v172 = obja;
            v173 = 2048;
            v174 = v160;
            v175 = 2048;
            v176 = v145;
            v177 = 2048;
            v178 = v147;
            v179 = 2048;
            v180 = v161;
            v181 = 2048;
            v182 = v146;
            v183 = 2048;
            v184 = v144;
            v122 = "\n"
                   "{chooseNewerSetDescriptor} decided right (left not configured) | (left)NotPresent:%ld,NotConfigured:%"
                   "ld,IsNewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
            goto LABEL_94;
          }

          if (((HIDWORD(v142) ^ 1 | v142) & 1) == 0)
          {
            v133 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
            v116 = (void *)objc_claimAutoreleasedReturnValue([v133 oslog]);

            if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_95;
            }
            *(_DWORD *)buf = 134219520;
            v172 = obja;
            v173 = 2048;
            v174 = v160;
            v175 = 2048;
            v176 = v145;
            v177 = 2048;
            v178 = v147;
            v179 = 2048;
            v180 = v161;
            v181 = 2048;
            v182 = v146;
            v183 = 2048;
            v184 = v144;
            v122 = "\n"
                   "{chooseNewerSetDescriptor} decided right (left previously staged) | (left)NotPresent:%ld,NotConfigure"
                   "d:%ld,IsNewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
            goto LABEL_94;
          }

          if (((v142 ^ 1 | HIDWORD(v142)) & 1) != 0)
          {
            v128 = (void *)objc_claimAutoreleasedReturnValue([v150 latestDowloadedAtomicInstanceEntries]);
            v129 = [v128 count];
            v130 = (void *)objc_claimAutoreleasedReturnValue([v151 latestDowloadedAtomicInstanceEntries]);
            v131 = [v130 count];

            if (v129 >= v131)
            {
              v135 = (void *)objc_claimAutoreleasedReturnValue([v151 latestDowloadedAtomicInstanceEntries]);
              v136 = [v135 count];
              v137 = (void *)objc_claimAutoreleasedReturnValue([v150 latestDowloadedAtomicInstanceEntries]);
              v138 = [v137 count];

              v139 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
              v116 = (void *)objc_claimAutoreleasedReturnValue([v139 oslog]);

              v140 = os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT);
              if (v136 < v138)
              {
                if (!v140) {
                  goto LABEL_95;
                }
                *(_DWORD *)buf = 134219520;
                v172 = obja;
                v173 = 2048;
                v174 = v160;
                v175 = 2048;
                v176 = v145;
                v177 = 2048;
                v178 = v147;
                v179 = 2048;
                v180 = v161;
                v181 = 2048;
                v182 = v146;
                v183 = 2048;
                v184 = v144;
                v122 = "\n"
                       "{chooseNewerSetDescriptor} decided right (fewer assets) | (left)NotPresent:%ld,NotConfigured:%ld,"
                       "IsNewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
                goto LABEL_94;
              }

              if (!v140) {
                goto LABEL_90;
              }
              *(_DWORD *)buf = 134219520;
              v172 = obja;
              v173 = 2048;
              v174 = v160;
              v175 = 2048;
              v176 = v145;
              v177 = 2048;
              v178 = v147;
              v179 = 2048;
              v180 = v161;
              v181 = 2048;
              v182 = v146;
              v183 = 2048;
              v184 = v144;
              v119 = "\n"
                     "{chooseNewerSetDescriptor} decided left (mixed results) | (left)NotPresent:%ld,NotConfigured:%ld,Is"
                     "Newer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
            }

            else
            {
              v132 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
              v116 = (void *)objc_claimAutoreleasedReturnValue([v132 oslog]);

              if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_90;
              }
              *(_DWORD *)buf = 134219520;
              v172 = obja;
              v173 = 2048;
              v174 = v160;
              v175 = 2048;
              v176 = v145;
              v177 = 2048;
              v178 = v147;
              v179 = 2048;
              v180 = v161;
              v181 = 2048;
              v182 = v146;
              v183 = 2048;
              v184 = v144;
              v119 = "\n"
                     "{chooseNewerSetDescriptor} decided left (fewer assets) | (left)NotPresent:%ld,NotConfigured:%ld,IsN"
                     "ewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
            }
          }

          else
          {
            v134 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
            v116 = (void *)objc_claimAutoreleasedReturnValue([v134 oslog]);

            if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_90;
            }
            *(_DWORD *)buf = 134219520;
            v172 = obja;
            v173 = 2048;
            v174 = v160;
            v175 = 2048;
            v176 = v145;
            v177 = 2048;
            v178 = v147;
            v179 = 2048;
            v180 = v161;
            v181 = 2048;
            v182 = v146;
            v183 = 2048;
            v184 = v144;
            v119 = "\n"
                   "{chooseNewerSetDescriptor} decided left (right previously staged) | (left)NotPresent:%ld,NotConfigure"
                   "d:%ld,IsNewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
          }
        }

        else
        {
          v126 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
          v116 = (void *)objc_claimAutoreleasedReturnValue([v126 oslog]);

          if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_90;
          }
          *(_DWORD *)buf = 134219520;
          v172 = obja;
          v173 = 2048;
          v174 = v160;
          v175 = 2048;
          v176 = v145;
          v177 = 2048;
          v178 = v147;
          v179 = 2048;
          v180 = v161;
          v181 = 2048;
          v182 = v146;
          v183 = 2048;
          v184 = v144;
          v119 = "\n"
                 "{chooseNewerSetDescriptor} decided left (right not configured) | (left)NotPresent:%ld,NotConfigured:%ld"
                 ",IsNewer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
        }
      }

      else
      {
        v125 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
        v116 = (void *)objc_claimAutoreleasedReturnValue([v125 oslog]);

        if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_90;
        }
        *(_DWORD *)buf = 134219520;
        v172 = obja;
        v173 = 2048;
        v174 = v160;
        v175 = 2048;
        v176 = v145;
        v177 = 2048;
        v178 = v147;
        v179 = 2048;
        v180 = v161;
        v181 = 2048;
        v182 = v146;
        v183 = 2048;
        v184 = v144;
        v119 = "\n"
               "{chooseNewerSetDescriptor} decided right (left not present) | (left)NotPresent:%ld,NotConfigured:%ld,IsNe"
               "wer:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
      }
    }

    else
    {
      v124 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
      v116 = (void *)objc_claimAutoreleasedReturnValue([v124 oslog]);

      if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 134219520;
      v172 = obja;
      v173 = 2048;
      v174 = v160;
      v175 = 2048;
      v176 = v145;
      v177 = 2048;
      v178 = v147;
      v179 = 2048;
      v180 = v161;
      v181 = 2048;
      v182 = v146;
      v183 = 2048;
      v184 = v144;
      v119 = "\n"
             "{chooseNewerSetDescriptor} decided left (right not present) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewe"
             "r:%ld, (right)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
    }

void OUTLINED_FUNCTION_0_0( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

uint64_t OUTLINED_FUNCTION_5_0(uint64_t a1, uint64_t a2)
{
  return a2;
}

void OUTLINED_FUNCTION_6( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t OUTLINED_FUNCTION_9()
{
  return *(void *)(v0 + 56);
}

void sub_519FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

LABEL_44:
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler persistedState](v79, "persistedState"));
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v57 persistedEntry:v25 fromLocation:@"_scheduleSelector"]);

      id v77 = [v54 BOOLeanForKey:@"requiringRetry"];
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v22 assetSelector]);
      [v54 persistSecureCodedObject:v58 forKey:@"assetSelector"];

      objc_msgSend(v54, "persistULL:forKey:", objc_msgSend(v22, "intervalSecs"), @"intervalSecs");
      objc_msgSend(v54, "persistULL:forKey:", objc_msgSend(v22, "remainingSecs"), @"remainingSecs");
      objc_msgSend(v54, "persistBoolean:forKey:", objc_msgSend(v22, "pushedJob"), @"pushJob");
      objc_msgSend(v54, "persistBoolean:forKey:", objc_msgSend(v22, "setJob"), @"setJob");
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v22 setPolicy]);

      if (v59)
      {
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v22 setPolicy]);
        [v54 persistSecureCodedObject:v60 forKey:@"setPolicy"];
      }

      v61 = (void *)objc_claimAutoreleasedReturnValue([v22 pushedPolicy]);

      if (v61)
      {
        v62 = (void *)objc_claimAutoreleasedReturnValue([v22 pushedPolicy]);
        [v54 persistSecureCodedObject:v62 forKey:@"pushedPolicy"];
      }

      id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler persistedState](v79, "persistedState"));
      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
      [v63 storePersistedEntry:v25 withEntrySummary:v64 fromLocation:@"_scheduleSelector"];

      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v22 assetSelector]);
      id v75 = [v22 intervalSecs];
      v73 = [v22 remainingSecs];
      uint64_t v66 = [v22 pushedJob];
      LOBYTE(v64) = [v22 setJob];
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v22 setPolicy]);
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v22 pushedPolicy]);
      LOBYTE(v70) = v77;
      LOBYTE(v69) = (_BYTE)v64;
      -[MADAutoAssetScheduler _logPersistedEntry:operation:persistingSelector:intervalSecs:remainingSecs:pushedJob:setJob:setPolicy:pushedPolicy:requiringRetry:message:]( v79,  "_logPersistedEntry:operation:persistingSelector:intervalSecs:remainingSecs:pushedJob:setJob:setPolicy:pushedPoli cy:requiringRetry:message:",  @"_scheduleSelector",  @"ENTRY_MODIFY",  v65,  v75,  v73,  v66,  v69,  v67,  v68,  v70,  @"already scheduled job (adjusted)");

      uint64_t v29 = v17;
      char v27 = v80;
      uint64_t v28 = v78;
LABEL_49:

      objc_autoreleasePoolPop(v23);
      goto LABEL_50;
    }

              -[NSMutableArray addObject:](v177, "addObject:", v17);
              uint64_t v43 = v24;
LABEL_45:

              uint64_t v15 = v174;
              uint64_t v14 = v175;
              goto LABEL_46;
            }

            unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v22 assetVersion]);

            if (v33)
            {
              if (v24)
              {
                v173 = v24;
                __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v24 assetVersion]);

                if (v34)
                {
                  if (([v22 isOnFilesystem] & 1) == 0
                    && !-[MADAutoAssetControlManager jobDescriptorInFlightNowOnFilesystem:]( self,  "jobDescriptorInFlightNowOnFilesystem:",  v22))
                  {
                    __int128 v35 = objc_claimAutoreleasedReturnValue([v22 assetVersion]);
                    if (v35)
                    {
                      __int128 v36 = (void *)v35;
                      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v22 assetId]);

                      if (v37)
                      {
                        id v38 = (void *)objc_claimAutoreleasedReturnValue([v20 stringForKey:@"autoAssetUUID"]);
                        id v39 = [v20 secureCodedObjectForKey:@"clientRequestMessage" ofClass:objc_opt_class(SUCoreConnectMessage)];
                        v156 = (void *)objc_claimAutoreleasedReturnValue(v39);
                        uint64_t v40 = [v20 secureCodedObjectForKey:@"baseForPatchDescriptor" ofClass:objc_opt_class(MADAutoAssetDescriptor)];
                        v41 = objc_claimAutoreleasedReturnValue(v40);
                        uint64_t v42 = (void *)v41;
                        if (v38)
                        {
                          uint64_t v43 = v173;
                          v162 = (os_log_t)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager currentJobBySelector:]( self,  "currentJobBySelector:",  v173));
                          if (v42 && [v42 isBlankEntry])
                          {

                            uint64_t v42 = 0LL;
                          }

                          v157 = v42;
                          if (v162)
                          {
                            uint64_t v44 = v38;
                            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                            uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue([v45 oslog]);

                            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                            {
                              v47 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                              *(_DWORD *)buf = 138543874;
                              v195 = (uint64_t)v47;
                              v196 = 2114;
                              v197 = v9;
                              v198 = 2114;
                              v199 = (uint64_t)v17;
                              _os_log_impl( &dword_0,  v46,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@} auto-asset-job already resumed | entry:%{public}@",  buf,  0x20u);
                            }

                            -[NSMutableArray addObject:](v177, "addObject:", v17);
                            uint64_t v43 = v173;
                            id v38 = v44;
                            goto LABEL_114;
                          }

                          if (+[MADAutoAssetControlManager isDeviceConsideredBeforeFirstUnlock]( &OBJC_CLASS___MADAutoAssetControlManager,  "isDeviceConsideredBeforeFirstUnlock")
                            || (v92 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updatePolicyForSelector:]( self,  "_updatePolicyForSelector:",  v173))) == 0LL)
                          {
                            -[MADAutoAssetControlManager _moveFromAwaitingResumedInto:forSelector:]( self,  "_moveFromAwaitingResumedInto:forSelector:",  v155,  v173);
LABEL_84:
                          }

                          else
                          {
                            v150 = v92;
                            if (v151 && ([v92 blockIfBeforeFirstUnlock] & 1) != 0)
                            {
                              -[MADAutoAssetControlManager _moveFromAwaitingResumedInto:forSelector:]( self,  "_moveFromAwaitingResumedInto:forSelector:",  v155,  v173);
                              -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJ obUUID:withAssetDescriptor:baseForPatchDescriptor:message:",  v9,  @"ACTIVE-JOBS",  @"ENTRY_LOAD",  v17,  v156,  v38,  v22,  v42,  @"auto-asset-job resume postponed (awaiting first-unlock)");

                              goto LABEL_84;
                            }

                            v149 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                            -[MADAutoAssetControlManager _moveFromAwaitingResumedInto:forSelector:]( self,  "_moveFromAwaitingResumedInto:forSelector:");
                            v162 = -[MADAutoAssetJob initForDescriptor:baseForPatchDescriptor:withAutoAssetUUID:]( objc_alloc(&OBJC_CLASS___MADAutoAssetJob),  "initForDescriptor:baseForPatchDescriptor:withAutoAssetUUID:",  v22,  v42,  v38);
                            if (v162)
                            {
                              if (-[MADAutoAssetControlManager _inMatchedTaskDescriptors:addingMatchingJobUUID:]( self,  "_inMatchedTaskDescriptors:addingMatchingJobUUID:",  v154,  v38))
                              {
                                v97 = v38;
                                -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:wit hJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:",  v9,  @"ACTIVE-JOBS",  @"ENTRY_LOAD",  v17,  v156,  v38,  v22,  v157,  @"in-flight taskDescriptor repeated (already mapped to additional job)");
                                v98 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                                v99 = (os_log_s *)objc_claimAutoreleasedReturnValue([v98 oslog]);

                                if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
                                {
                                  v119 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                                  v120 = (void *)objc_claimAutoreleasedReturnValue([v173 summary]);
                                  *(_DWORD *)buf = 138544130;
                                  v195 = (uint64_t)v119;
                                  v196 = 2112;
                                  v197 = v9;
                                  v198 = 2114;
                                  v199 = (uint64_t)v120;
                                  v200 = 2114;
                                  v201 = (uint64_t)v97;
                                  _os_log_error_impl( &dword_0,  v99,  OS_LOG_TYPE_ERROR,  "[%{public}@] {resumeJobsWhenBeforeFirstUnlock:%@} in-flight taskDescriptor repeated (already mapped to additional job) | selector:%{public}@, UUID:%{public}@",  buf,  0x2Au);

                                  uint64_t v43 = v173;
                                }

                                id v38 = v97;
                              }

                              else
                              {
                                v148 = v38;
                                v106 = (void *)objc_claimAutoreleasedReturnValue([v156 messageName]);
                                v107 = -[MADAutoAssetControlManager _messageShouldBeScheduled:forAssetSelector:]( self,  "_messageShouldBeScheduled:forAssetSelector:",  v106,  v173);

                                if (v107) {
                                  -[MADAutoAssetControlManager _scheduleSelector:](self, "_scheduleSelector:", v173);
                                }
                                -[MADAutoAssetControlManager _removeJobFromDownloadsInFlight:]( self,  "_removeJobFromDownloadsInFlight:",  v148);
                                -[MADAutoAssetControlManager addToCurrentJobs:usingSelector:withJobUUID:triggeredByClientMessage:downloadingDescriptor:baseForPatchDescriptor:usingSetDescriptor:]( self,  "addToCurrentJobs:usingSelector:withJobUUID:triggeredByClientMessage:downloadingDescrip tor:baseForPatchDescriptor:usingSetDescriptor:",  v162,  v173,  v148,  v156,  v22,  v42,  0LL);
                                -[MADAutoAssetControlManager _trackActiveDescriptor:operation:usingSelector:withJobUUID:triggeredByClientMessage:downloadingDescriptor:baseForPatchDescriptor:message:]( self,  "_trackActiveDescriptor:operation:usingSelector:withJobUUID:triggeredByClientMessage:do wnloadingDescriptor:baseForPatchDescriptor:message:",  v9,  @"ENTRY_LOAD",  v173,  v148,  v156,  v22,  v42,  @"auto-asset-job resumed");
                                -[MADAutoAssetControlManager _statsIncrementResumedInFlightJobs]( self,  "_statsIncrementResumedInFlightJobs");
                                -[MADAutoAssetControlManager _statsIncrementAutoAssetJobsStarted]( self,  "_statsIncrementAutoAssetJobsStarted");
                                v108 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager jobControlInformationForSelector:]( self,  "jobControlInformationForSelector:",  v173));
                                -[os_log_s startResumingInFlightDownload:withControlInformation:]( v162,  "startResumingInFlightDownload:withControlInformation:",  v22,  v108);

                                v186 = 0u;
                                v187 = 0u;
                                v184 = 0u;
                                v185 = 0u;
                                v161 = v149;
                                v166 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v161,  "countByEnumeratingWithState:objects:count:",  &v184,  v193,  16LL);
                                if (v166)
                                {
                                  v109 = *(os_log_t *)v185;
                                  v159 = *(os_log_t *)v185;
                                  do
                                  {
                                    for (uint64_t i = 0LL; i != v166; uint64_t i = (char *)i + 1)
                                    {
                                      if (*(os_log_t *)v185 != v109) {
                                        objc_enumerationMutation(v161);
                                      }
                                      v111 = *(void **)(*((void *)&v184 + 1) + 8LL * (void)i);
                                      loga = (os_log_t)objc_autoreleasePoolPush();
                                      switch((unint64_t)[v111 paramType])
                                      {
                                        case 5uLL:
                                          v112 = (void *)objc_claimAutoreleasedReturnValue([v111 autoAssetJobID]);
                                          v113 = (void *)objc_claimAutoreleasedReturnValue([v111 finishedError]);
                                          -[os_log_s handleDownloadAssetJobFinished:downloadError:]( v162,  "handleDownloadAssetJobFinished:downloadError:",  v112,  v113);
                                          break;
                                        case 6uLL:
                                          v112 = (void *)objc_claimAutoreleasedReturnValue([v111 autoAssetJobID]);
                                          v113 = (void *)objc_claimAutoreleasedReturnValue([v111 autoAssetCatalog]);
                                          v115 = (void *)objc_claimAutoreleasedReturnValue([v111 finishedError]);
                                          -[os_log_s handleDownloadCatalogJobFinished:withCatalog:downloadError:]( v162,  "handleDownloadCatalogJobFinished:withCatalog:downloadError:",  v112,  v113,  v115);
                                          goto LABEL_107;
                                        case 7uLL:
                                          v112 = (void *)objc_claimAutoreleasedReturnValue([v111 autoAssetJobID]);
                                          v113 = (void *)objc_claimAutoreleasedReturnValue([v111 finishedError]);
                                          -[os_log_s handleDownloadConfigJobFinished:configError:]( v162,  "handleDownloadConfigJobFinished:configError:",  v112,  v113);
                                          break;
                                        case 8uLL:
                                          v112 = (void *)objc_claimAutoreleasedReturnValue([v111 autoAssetJobID]);
                                          v113 = (void *)objc_claimAutoreleasedReturnValue([v111 downloadProgress]);
                                          -[os_log_s handleDownloadAssetProgressForJob:withProgress:]( v162,  "handleDownloadAssetProgressForJob:withProgress:",  v112,  v113);
                                          break;
                                        default:
                                          v112 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager autoControlManagerFSM]( self,  "autoControlManagerFSM"));
                                          v113 = (void *)objc_claimAutoreleasedReturnValue([v112 diag]);
                                          v158 = objc_alloc(&OBJC_CLASS___NSString);
                                          v114 = [v111 paramType];
                                          v115 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                                          v116 = -[NSString initWithFormat:]( v158,  "initWithFormat:",  @"{%@} unknown paramType(%ld) on earlyDownloadManagerEvents | %@",  v179,  v114,  v115);
                                          [v113 trackAnomaly:@"AUTO-CONTROL" forReason:v116 withResult:6108 withError:0];

LABEL_107:
                                          v109 = v159;
                                          break;
                                      }

                                      objc_autoreleasePoolPop(loga);
                                      uint64_t v43 = v173;
                                    }

                                    v166 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v161,  "countByEnumeratingWithState:objects:count:",  &v184,  v193,  16LL);
                                  }

                                  while (v166);
                                }

                                ++v153;

                                id v9 = v179;
                                id v38 = v148;
                              }
                            }

                            else
                            {
                              loge = (os_log_t)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager autoControlManagerFSM]( self,  "autoControlManagerFSM"));
                              v102 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s diag](loge, "diag"));
                              v103 = objc_alloc(&OBJC_CLASS___NSString);
                              v147 = v38;
                              v104 = (void *)objc_claimAutoreleasedReturnValue([v173 summary]);
                              v105 = -[NSString initWithFormat:]( v103,  "initWithFormat:",  @"{%@} unable to allocate autoAssetJob | selector:%@",  v9,  v104);
                              [v102 trackAnomaly:@"AUTO-CONTROL" forReason:v105 withResult:6101 withError:0];

                              id v38 = v147;
                              uint64_t v43 = v173;

                              -[MADAutoAssetControlManager _statsIncrementFailuresToStartJobs]( self,  "_statsIncrementFailuresToStartJobs");
                              -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJ obUUID:withAssetDescriptor:baseForPatchDescriptor:message:",  v9,  @"ACTIVE-JOBS",  @"ENTRY_LOAD",  v17,  v156,  v147,  v22,  v157,  @"unable to create auto-asset-job (not removing from active jobs persisted-state since may be able to recover on next MA daemon startup)");
                            }

LABEL_114:
                          }
                        }

                        else
                        {
                          v157 = (void *)v41;
                          v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                          v91 = (os_log_s *)objc_claimAutoreleasedReturnValue([v90 oslog]);

                          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
                          {
                            logd = (os_log_t)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                            v100 = objc_claimAutoreleasedReturnValue([v173 summary]);
                            *(_DWORD *)buf = 138544386;
                            v195 = (uint64_t)logd;
                            v196 = 2114;
                            v197 = v9;
                            v198 = 2114;
                            v199 = (uint64_t)v17;
                            v200 = 2114;
                            v201 = v100;
                            v101 = (void *)v100;
                            v202 = 2114;
                            v203 = @"MISSING";
                            _os_log_error_impl( &dword_0,  v91,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to determine previous information | entryID:%{public}@, s elector:%{public}@, UUID:%{public}@",  buf,  0x34u);
                          }

                          -[NSMutableArray addObject:](v177, "addObject:", v17);
                          uint64_t v43 = v173;
                          id v38 = 0LL;
                        }

                        goto LABEL_45;
                      }
                    }
                  }

                  if (-[MADAutoAssetControlManager jobDescriptorInFlightNowOnFilesystem:]( self,  "jobDescriptorInFlightNowOnFilesystem:",  v22))
                  {
                    uint64_t v53 = objc_claimAutoreleasedReturnValue([v22 assetVersion]);
                    if (v53)
                    {
                      uint64_t v54 = (void *)v53;
                      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v22 assetId]);

                      if (v55)
                      {
                        logb = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
                        v164 = (void *)objc_claimAutoreleasedReturnValue([v22 assetType]);
                        v56 = (void *)objc_claimAutoreleasedReturnValue([v22 assetSpecifier]);
                        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v22 assetVersion]);
                        uint64_t v58 = -[MAAutoAssetSelector initForAssetType:withAssetSpecifier:matchingAssetVersion:]( logb,  "initForAssetType:withAssetSpecifier:matchingAssetVersion:",  v164,  v56,  v57);

                        uint64_t v59 = v58;
                        if (v58)
                        {
                          v165 = v58;
                          uint64_t v60 = objc_claimAutoreleasedReturnValue([v58 persistedEntryID]);
                          v61 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownDescriptors]( self,  "persistedKnownDescriptors"));
                          v62 = [v61 persistedEntryAlreadyExists:v60 fromLocation:v9];

                          log = (os_log_t)v60;
                          if (v62)
                          {
                            id v63 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownDescriptors]( self,  "persistedKnownDescriptors"));
                            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v63 persistedEntry:v60 fromLocation:v9]);

                            if (v64)
                            {
                              v160 = v64;
                              uint64_t v65 = [v64 secureCodedObjectForKey:@"assetDescriptor" ofClass:objc_opt_class(MADAutoAssetDescriptor)];
                              uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
                              uint64_t v43 = v173;
                              v163 = v66;
                              if (-[os_log_s isOnFilesystem](v66, "isOnFilesystem"))
                              {
                                uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                                uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue([v67 oslog]);

                                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                                {
                                  uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                                  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v163, "summary"));
                                  *(_DWORD *)buf = 138543874;
                                  v195 = (uint64_t)v69;
                                  v196 = 2114;
                                  v197 = v9;
                                  v198 = 2114;
                                  v199 = (uint64_t)v70;
                                  uint64_t v71 = v68;
                                  id v72 = "[%{public}@] {%{public}@} previously in-flight already downloaded | nowDownloade"
                                        "dDescriptor:%{public}@";
                                  goto LABEL_81;
                                }

                                goto LABEL_82;
                              }

                              -[os_log_s setIsOnFilesystem:](v66, "setIsOnFilesystem:", 1LL);
                              -[MADAutoAssetControlManager _preInstalledMakeDescriptorAvailable:fromLocation:]( self,  "_preInstalledMakeDescriptorAvailable:fromLocation:",  v66,  @"resumeJobsWhenBeforeFirstUnlock(nowDownloadedDescriptor)");
                              v96 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                              uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue([v96 oslog]);

                              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                              {
                                uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                                uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v163, "summary"));
                                *(_DWORD *)buf = 138543874;
                                v195 = (uint64_t)v69;
                                v196 = 2114;
                                v197 = v9;
                                v198 = 2114;
                                v199 = (uint64_t)v70;
                                uint64_t v71 = v68;
                                id v72 = "[%{public}@] {%{public}@} previously in-flight already downloaded (known descripto"
                                      "r) | nowDownloadedDescriptor:%{public}@";
LABEL_81:
                                _os_log_impl(&dword_0, v71, OS_LOG_TYPE_DEFAULT, v72, buf, 0x20u);

                                uint64_t v43 = v173;
LABEL_82:
                                id v83 = log;
                              }

                              else
                              {
                                id v83 = log;
                              }

                              uint64_t v64 = v160;
                            }

                            else
                            {
                              v93 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                              v94 = (os_log_s *)objc_claimAutoreleasedReturnValue([v93 oslog]);

                              v163 = v94;
                              v95 = os_log_type_enabled(v94, OS_LOG_TYPE_ERROR);
                              uint64_t v43 = v173;
                              if (v95)
                              {
                                v117 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                                v118 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
                                *(_DWORD *)buf = 138543874;
                                v195 = (uint64_t)v117;
                                v196 = 2114;
                                v197 = v9;
                                v198 = 2114;
                                v199 = (uint64_t)v118;
                                _os_log_error_impl( &dword_0,  v163,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} no persisted descriptor entry yet entry already exists | job Descriptor:%{public}@",  buf,  0x20u);

                                uint64_t v43 = v173;
                              }

                              id v83 = log;
                            }
                          }

                          else
                          {
                            [v22 setIsOnFilesystem:1];
                            -[MADAutoAssetControlManager _preInstalledMakeDescriptorAvailable:fromLocation:]( self,  "_preInstalledMakeDescriptorAvailable:fromLocation:",  v22,  @"resumeJobsWhenBeforeFirstUnlock(new jobDescriptor)");
                            __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v87 oslog]);

                            if (os_log_type_enabled((os_log_t)v64, OS_LOG_TYPE_DEFAULT))
                            {
                              __int128 v88 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                              __int128 v89 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
                              *(_DWORD *)buf = 138543874;
                              v195 = (uint64_t)v88;
                              v196 = 2114;
                              v197 = v9;
                              v198 = 2114;
                              v199 = (uint64_t)v89;
                              _os_log_impl( &dword_0,  (os_log_t)v64,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@} previously in-flight already downloaded (now downloaded descri ptor) | jobDescriptor:%{public}@",  buf,  0x20u);
                            }

                            id v83 = log;
                            uint64_t v43 = v173;
                          }

                          uint64_t v59 = v165;
                        }

                        else
                        {
                          v81 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                          uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue([v81 oslog]);

                          id v83 = v82;
                          id v84 = os_log_type_enabled(v82, OS_LOG_TYPE_ERROR);
                          uint64_t v43 = v173;
                          if (v84)
                          {
                            logCC_SHA1_CTX c = v83;
                            id v85 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                            __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
                            *(_DWORD *)buf = 138543874;
                            v195 = (uint64_t)v85;
                            v196 = 2114;
                            v197 = v9;
                            v198 = 2114;
                            v199 = (uint64_t)v86;
                            _os_log_error_impl( &dword_0,  logc,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to record downloaded-when-in-flight | jobDescriptor:%{public}@",  buf,  0x20u);

                            uint64_t v43 = v173;
                            id v83 = logc;
                          }
                        }

                        -[NSMutableArray addObject:](v177, "addObject:", v17);
                        goto LABEL_45;
                      }
                    }
                  }

                  v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                  uint64_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue([v73 oslog]);

                  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                  {
                    id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                    id v76 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
                    *(_DWORD *)buf = 138543874;
                    v195 = (uint64_t)v75;
                    v196 = 2114;
                    v197 = v9;
                    v198 = 2114;
                    v199 = (uint64_t)v76;
                    id v77 = v74;
                    v78 = "[%{public}@] {%{public}@} not considering resuming | jobDescriptor:%{public}@";
                    v79 = 32;
                    goto LABEL_61;
                  }
                }

                else
                {
                  v80 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                  uint64_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue([v80 oslog]);

                  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                  {
                    id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                    id v76 = (void *)objc_claimAutoreleasedReturnValue([v24 summary]);
                    *(_DWORD *)buf = 138544130;
                    v195 = (uint64_t)v75;
                    v196 = 2114;
                    v197 = v9;
                    v198 = 2114;
                    v199 = (uint64_t)v17;
                    v200 = 2114;
                    v201 = (uint64_t)v76;
                    id v77 = v74;
                    v78 = "[%{public}@] {%{public}@} encountered auto-asset-descriptor with persisted asset-selector with"
                          "out asset-version | entryID:%{public}@ | jobSelector:%{public}@";
                    v79 = 42;
LABEL_61:
                    _os_log_impl(&dword_0, v77, OS_LOG_TYPE_DEFAULT, v78, buf, v79);
                  }
                }

                -[NSMutableArray addObject:](v177, "addObject:", v17);
                uint64_t v43 = v173;
                goto LABEL_45;
              }

              uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v52 oslog]);

              if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_44;
              }
              char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              *(_DWORD *)buf = 138543874;
              v195 = (uint64_t)v27;
              v196 = 2114;
              v197 = v9;
              v198 = 2114;
              v199 = (uint64_t)v17;
              uint64_t v28 = v26;
              uint64_t v29 = "[%{public}@] {%{public}@} encountered auto-asset-descriptor without persisted asset-selector | entryID:%{public}@";
            }

            else
            {
              v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v48 oslog]);

              if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_44;
              }
              char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              *(_DWORD *)buf = 138543874;
              v195 = (uint64_t)v27;
              v196 = 2114;
              v197 = v9;
              v198 = 2114;
              v199 = (uint64_t)v17;
              uint64_t v28 = v26;
              uint64_t v29 = "[%{public}@] {%{public}@} encountered auto-asset-descriptor without asset-version | entryID:%{public}@";
            }

  sub_222AE4(a2 + 72, (uint64_t)v44, &qword_3A8910);
  result = sub_222AE4((uint64_t)v44, (uint64_t)v47, &qword_3A8910);
  if (*(void *)&v47[0])
  {
    v43[0] = v47[0];
    v43[1] = v47[1];
    __chkstk_darwin(result, v35);
    __int128 v37 = v43;
    return sub_22A5B0(161, v4, sub_2224C4, (uint64_t)v36);
  }

  return result;
}

LABEL_37:
    _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, v24, buf, 0x2Au);
    goto LABEL_42;
  }

  if (_MAPreferencesIsInternalAllowed()
    && !+[MADAutoAssetControlManager preferenceScheduledAsIfNotInternal]( &OBJC_CLASS___MADAutoAssetControlManager,  "preferenceScheduledAsIfNotInternal"))
  {
    id v10 = 86400LL;
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler logger](self, "logger"));
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    id v22 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler summary](self, "summary"));
    id v23 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
    *(_DWORD *)buf = 138544130;
    uint64_t v44 = v22;
    uint64_t v45 = 2114;
    uint64_t v46 = v23;
    v47 = 2114;
    v48 = v8;
    unsigned __int8 v49 = 2048;
    v50 = 86400LL;
    id v24 = "%{public}@ | {AUTO-SCHEDULER:_decideTriggerIntervalSecs} internal image | assetSelector:%{public}@ | scheduled"
          "JobAssetType:%{public}@ | determinedIntervalSecs:%ld";
    goto LABEL_37;
  }

  id v39 = 0u;
  uint64_t v40 = 0u;
  __int128 v37 = 0u;
  id v38 = 0u;
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetScheduler schedulerIntervalHeightenedAssetTypes]( self,  "schedulerIntervalHeightenedAssetTypes"));
  uint64_t v12 = -[os_log_s countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v37,  v42,  16LL);
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v38;
LABEL_13:
    uint64_t v15 = 0LL;
    while (1)
    {
      if (*(void *)v38 != v14) {
        objc_enumerationMutation(v11);
      }
      if (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v8,  *(void *)(*((void *)&v37 + 1) + 8 * v15))) {
        break;
      }
      if (v13 == (id)++v15)
      {
        uint64_t v13 = -[os_log_s countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v37,  v42,  16LL);
        if (v13) {
          goto LABEL_13;
        }
        goto LABEL_19;
      }
    }

    id v10 = -[MADAutoAssetScheduler _heightenedIntervalSecs](self, "_heightenedIntervalSecs");
    id v25 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler logger](self, "logger"));
    id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v25 oslog]);

    if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_41;
    }
    char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetScheduler summary](self, "summary"));
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
    *(_DWORD *)buf = 138544130;
    uint64_t v44 = v27;
    uint64_t v45 = 2114;
    uint64_t v46 = v28;
    v47 = 2114;
    v48 = v8;
    unsigned __int8 v49 = 2048;
    v50 = v10;
    uint64_t v29 = "%{public}@ | {AUTO-SCHEDULER:_decideTriggerIntervalSecs} heightened | assetSelector:%{public}@ | scheduledJobA"
          "ssetType:%{public}@ | determinedIntervalSecs:%ld";
    goto LABEL_40;
  }
}

          objc_autoreleasePoolPop(v27);
        }

        id v23 = [v21 countByEnumeratingWithState:&v121 objects:v132 count:16];
      }

      while (v23);
    }

    v119 = 0u;
    v120 = 0u;
    v117 = 0u;
    v118 = 0u;
    uint64_t v65 = v7;
    uint64_t v66 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v117,  v131,  16LL);
    if (v66)
    {
      uint64_t v67 = v66;
      uint64_t v68 = 0LL;
      uint64_t v69 = 0LL;
      uint64_t v70 = 0LL;
      p_ivars = &MobileAssetKeyManager__metaData.ivars;
      v115 = *(void *)v118;
      v107 = v65;
      do
      {
        id v72 = 0LL;
        v108 = v67;
        do
        {
          v73 = v70;
          if (*(void *)v118 != v115) {
            objc_enumerationMutation(v65);
          }
          uint64_t v74 = *(void *)(*((void *)&v117 + 1) + 8LL * (void)v72);
          uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKey:](v65, "objectForKey:", v74));

          if (v70)
          {
            id v75 = p_ivars[155];
            id v76 = (void *)objc_claimAutoreleasedReturnValue([v70 taskDescription]);
            LODWORD(v75) = -[__objc2_ivar_list stringIsEqual:to:](v75, "stringIsEqual:to:", v74, v76);

            if ((_DWORD)v75)
            {
              id v77 = (void *)objc_claimAutoreleasedReturnValue([v70 originalRequest]);

              if (v77)
              {
                v78 = objc_claimAutoreleasedReturnValue([v77 URL]);

                if (v78)
                {
                  v109 = objc_opt_new(&OBJC_CLASS___MADownloadOptions);
                  v129[0] = @"allowsCellularAccess";
                  v111 = (void *)v78;
                  v110 = -[NSNumber initWithBool:]( [NSNumber alloc],  "initWithBool:",  [v77 allowsCellularAccess]);
                  v130[0] = v110;
                  v129[1] = @"allowsExpensive";
                  v79 = -[NSNumber initWithBool:]( [NSNumber alloc],  "initWithBool:",  [v77 allowsExpensiveNetworkAccess]);
                  v130[1] = v79;
                  v129[2] = @"prefersInfraWiFi";
                  v80 = -[NSNumber initWithBool:]( [NSNumber alloc],  "initWithBool:",  [v77 allowsConstrainedNetworkAccess]);
                  v130[2] = v80;
                  v129[3] = @"timeoutIntervalForResource";
                  v81 = objc_alloc(&OBJC_CLASS___NSNumber);
                  [v77 timeoutInterval];
                  uint64_t v82 = -[NSNumber initWithDouble:](v81, "initWithDouble:");
                  v130[3] = v82;
                  v129[4] = @"canUseLocalCacheServer";
                  id v83 = -[NSNumber initWithBool:]( [NSNumber alloc],  "initWithBool:",  (unint64_t)[v77 cachePolicy] < 5);
                  v130[4] = v83;
                  id v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v130,  v129,  5LL));
                  id v85 = -[MADownloadOptions initWithPlist:](v109, "initWithPlist:", v84);

                  __int128 v86 = -[DownloadInfo initWithUrl:clientName:options:]( objc_alloc(&OBJC_CLASS___DownloadInfo),  "initWithUrl:clientName:options:",  v111,  @"<resume>",  v85);
                  __int128 v87 = v86;
                  if (v86)
                  {
                    -[DownloadInfo setTaskDescriptor:](v86, "setTaskDescriptor:", v74);
                    -[DownloadInfo setTask:](v87, "setTask:", v70);
                    _MobileAssetLog( 0LL,  5,  (uint64_t)"-[DownloadManager queryNSUrlSessiondAndUpdateState]_block_invoke_4",  @"Discovered task: %@ new info: %@",  v88,  v89,  v90,  v91,  v74);
                    v92 = (void *)objc_claimAutoreleasedReturnValue([v70 taskDescription]);
                    -[NSMutableDictionary setSafeObject:forKey:](v113, "setSafeObject:forKey:", v87, v92);
                  }

                  else
                  {
                    [v70 cancel];
                  }

                  uint64_t v65 = v107;
                  uint64_t v67 = v108;

                  uint64_t v68 = v111;
                  uint64_t v69 = v77;
                  p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                }

                else
                {
                  [v70 cancel];
                  uint64_t v68 = 0LL;
                  uint64_t v69 = v77;
                }
              }

              else
              {
                [v70 cancel];
                uint64_t v69 = 0LL;
              }
            }
          }

          id v72 = (char *)v72 + 1;
        }

        while (v67 != v72);
        uint64_t v67 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v117,  v131,  16LL);
      }

      while (v67);
    }

    else
    {
      uint64_t v68 = 0LL;
      uint64_t v69 = 0LL;
      uint64_t v70 = 0LL;
    }

    v93 = v114;
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager queryNSUrlSessiondAndUpdateState]_block_invoke_4",  @"No tasks in nsurl state",  v3,  v4,  v5,  v6,  v105);
    uint64_t v68 = 0LL;
    uint64_t v69 = 0LL;
    uint64_t v70 = 0LL;
    v93 = 0LL;
    uint64_t v65 = 0LL;
  }

  v94 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) downloadTasksInFlight]);
  [*(id *)(a1 + 32) setDownloadTasksInFlight:v113];
  v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allKeys](v113, "allKeys"));
  ControlManager = getControlManager();
  v97 = (void *)objc_claimAutoreleasedReturnValue(ControlManager);
  [v97 removeDownloadsNotRecentlyInFlight:v95];

  +[MADAutoAssetControlManager downloadManagerStateSyncDetermined:]( &OBJC_CLASS___MADAutoAssetControlManager,  "downloadManagerStateSyncDetermined:",  v95);
  [*(id *)(a1 + 32) updateStateAndNotifyIfRequired];
  v98 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) downloadTasksInFlight]);
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager queryNSUrlSessiondAndUpdateState]_block_invoke_4",  @"queryNSUrlSessiondAndUpdateState complete, _downloadStateQueue resumed _downloadTasksInFlight: %@",  v99,  v100,  v101,  v102,  (uint64_t)v98);

  v103 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) dedupNSURLSessionSyncQueue]);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __51__DownloadManager_queryNSUrlSessiondAndUpdateState__block_invoke_5;
  block[3] = &unk_34DBC0;
  void block[4] = *(void *)(a1 + 32);
  dispatch_sync(v103, block);

  v104 = (dispatch_object_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) downloadStateQueue]);
  dispatch_resume(v104);
}

          _os_log_impl(&dword_0, v61, OS_LOG_TYPE_DEFAULT, v62, buf, 0x16u);

          uint64_t v12 = v153;
          goto LABEL_38;
        }

        ++v147;
        if (v152)
        {
          id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
          unsigned __int8 v49 = (id)objc_claimAutoreleasedReturnValue([v63 oslog]);

          if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v29 fullAssetSelector]);
            uint64_t v53 = (char *)objc_claimAutoreleasedReturnValue([v64 summary]);
            uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([0 fullAssetSelector]);
            uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v65 summary]);
            *(_DWORD *)buf = 138543618;
            v172 = v53;
            v173 = 2114;
            v174 = (uint64_t)v66;
            _os_log_impl( &dword_0,  (os_log_t)v49,  OS_LOG_TYPE_DEFAULT,  "\n{chooseNewerSetDescriptor} | rightNotPresent | left:%{public}@ | right:%{public}@",  buf,  0x16u);

            goto LABEL_40;
          }

          goto LABEL_41;
        }
}

        id v6 = v122;
        goto LABEL_18;
      }

      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleInstallAsset:forType:]",  @"Got malformed asset attributes when reading info plist",  v22,  v23,  v24,  v25,  v114);
    }

    else
    {
      v116 = (void *)objc_claimAutoreleasedReturnValue([v14 path]);
      v117 = (void *)objc_claimAutoreleasedReturnValue([v15 path]);
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleInstallAsset:forType:]",  @"Got a malformed asset when reading %@, cleaning up. plist: %@, infoPlistPath: %@, assetDataPath: %@",  v45,  v46,  v47,  v48,  (uint64_t)v12);
    }
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager handleInstallAsset:forType:]",  @"unable to create NSURL from path: %@",  v8,  v9,  v10,  v11,  (uint64_t)v5);
  }

  unsigned __int8 v49 = 2LL;
LABEL_18:

  return v49;
}

      __break(1u);
LABEL_38:
      __break(1u);
LABEL_39:
      __break(1u);
LABEL_40:
      __break(1u);
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
LABEL_43:
      __break(1u);
LABEL_44:
      __break(1u);
LABEL_45:
      __break(1u);
LABEL_46:
      __break(1u);
LABEL_47:
      __break(1u);
LABEL_48:
      __break(1u);
    }
  }

  return result;
}

    __break(1u);
LABEL_38:
    result = (uint64_t)sub_237300(a3);
    a3 = result;
LABEL_11:
    if (v13 >= *(void *)(a3 + 16))
    {
      __break(1u);
      goto LABEL_40;
    }

    int v16 = a3 + 32;
    *(_BYTE *)(a3 + 32 + v13) = (v4 >> 3) | 0x80;
    *a2 = (char *)a3;
    if (v7 < *(void *)(a3 + 16))
    {
      *(_BYTE *)(v16 + v7) = v10 >> (8 * (((_BYTE)v8 - 1) & 7u));
      if (v8 == (_BYTE *)&dword_0 + 1) {
        goto LABEL_32;
      }
      if (v7 + 1 < *(void *)(a3 + 16))
      {
        *(_BYTE *)(v16 + v7 + 1) = v10 >> (8 * (((_BYTE)v8 - 2) & 7u));
        if (v8 == (_BYTE *)&dword_0 + 2) {
          goto LABEL_32;
        }
        if (v7 + 2 < *(void *)(a3 + 16))
        {
          *(_BYTE *)(v16 + v7 + 2) = v10 >> (8 * (((_BYTE)v8 - 3) & 7u));
          if (v8 == (_BYTE *)&dword_0 + 3) {
            goto LABEL_32;
          }
          if (v7 + 3 < *(void *)(a3 + 16))
          {
            *(_BYTE *)(v16 + v7 + 3) = v10 >> (8 * (((_BYTE)v8 - 4) & 7u));
            if (v7 + 4 < *(void *)(a3 + 16))
            {
              *(_BYTE *)(v16 + v7 + 4) = v10 >> (8 * (((_BYTE)v8 - 5) & 7u));
              if (v8 == (_BYTE *)&dword_4 + 1) {
                goto LABEL_32;
              }
              if (v7 + 5 < *(void *)(a3 + 16))
              {
                *(_BYTE *)(v16 + v7 + 5) = v10 >> (8 * (((_BYTE)v8 - 6) & 7u));
                if (v8 == (_BYTE *)&dword_4 + 2) {
                  goto LABEL_32;
                }
                if (v7 + 6 < *(void *)(a3 + 16))
                {
                  *(_BYTE *)(v16 + v7 + 6) = v10 >> (8 * (((_BYTE)v8 - 7) & 7u));
                  if (v8 == (_BYTE *)&dword_4 + 3) {
                    goto LABEL_32;
                  }
                  if (v7 + 7 < *(void *)(a3 + 16))
                  {
                    *(_BYTE *)(v16 + v7 + 7) = v10 >> (v4 & 0x38);
LABEL_32:
                    *a2 = (char *)a3;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }

    __break(1u);
LABEL_35:
    id v8 = sub_2121E4(0LL, *((void *)v8 + 2) + 1LL, 1, v8);
  }

  if ((v10 & 0x8000000000000000LL) != 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  result = swift_isUniquelyReferenced_nonNull_native(*a2);
  if ((result & 1) != 0) {
    goto LABEL_30;
  }
LABEL_41:
  result = (uint64_t)sub_237300(a3);
  a3 = result;
LABEL_30:
  if (v13 < *(void *)(a3 + 16))
  {
    *(_BYTE *)(a3 + v13 + 32) = v10;
    goto LABEL_32;
  }

  __break(1u);
  return result;
}

    __break(1u);
LABEL_38:
    result = (uint64_t)sub_237300(a4);
    a4 = result;
LABEL_11:
    if ((unint64_t)v9 >= *(void *)(a4 + 16))
    {
      __break(1u);
      goto LABEL_40;
    }

    int v16 = a4 + 32;
    v9[a4 + 32] = (v11 >> 3) | 0x80;
    *a2 = (char *)a4;
    if (v8 < *(void *)(a4 + 16))
    {
      *(_BYTE *)(v16 + v_Block_object_dispose(va, 8) = v13 >> (8 * (((_BYTE)a3 - 1) & 7u));
      if (v8 + 1 < *(void *)(a4 + 16))
      {
        *(_BYTE *)(v16 + v8 + 1) = v13 >> (8 * (((_BYTE)a3 - 2) & 7u));
        if (v8 + 2 < *(void *)(a4 + 16))
        {
          *(_BYTE *)(v16 + v8 + 2) = v13 >> (8 * (((_BYTE)a3 - 3) & 7u));
          if (v8 + 3 < *(void *)(a4 + 16))
          {
            *(_BYTE *)(v16 + v8 + 3) = v13 >> (8 * (((_BYTE)a3 - 4) & 7u));
            if (v8 + 4 < *(void *)(a4 + 16))
            {
              *(_BYTE *)(v16 + v8 + 4) = v13 >> (8 * (((_BYTE)a3 - 5) & 7u));
              if (v8 + 5 < *(void *)(a4 + 16))
              {
                *(_BYTE *)(v16 + v8 + 5) = v13 >> (8 * (((_BYTE)a3 - 6) & 7u));
                if (v8 + 6 < *(void *)(a4 + 16))
                {
                  *(_BYTE *)(v16 + v8 + 6) = v13 >> (8 * (((_BYTE)a3 - 7) & 7u));
                  if (v8 + 7 < *(void *)(a4 + 16))
                  {
                    *(_BYTE *)(v16 + v8 + 7) = v13 >> (v11 & 0x38);
LABEL_32:
                    *a2 = (char *)a4;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }

    __break(1u);
LABEL_35:
    id v9 = sub_2121E4(0LL, *((void *)v9 + 2) + 1LL, 1, v9);
  }

  if ((v13 & 0x8000000000000000LL) != 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  result = swift_isUniquelyReferenced_nonNull_native(*a2);
  if ((result & 1) != 0) {
    goto LABEL_30;
  }
LABEL_41:
  result = (uint64_t)sub_237300(a4);
  a4 = result;
LABEL_30:
  if ((unint64_t)v9 < *(void *)(a4 + 16))
  {
    v9[a4 + 32] = v13;
    goto LABEL_32;
  }

  __break(1u);
  return result;
}

    __break(1u);
LABEL_38:
    result = (uint64_t)sub_237300((uint64_t)a3);
    a3 = (char *)result;
LABEL_11:
    if (v13 >= *((void *)a3 + 2))
    {
      __break(1u);
      goto LABEL_40;
    }

    int v16 = a3 + 32;
    a3[v13 + 32] = (v4 >> 3) | 0x80;
    *a2 = a3;
    if (v7 < *((void *)a3 + 2))
    {
      v16[v7] = v10 >> (8 * (((_BYTE)v8 - 1) & 7u));
      if (v8 == (_BYTE *)&dword_0 + 1) {
        goto LABEL_32;
      }
      if (v7 + 1 < *((void *)a3 + 2))
      {
        v16[v7 + 1] = v10 >> (8 * (((_BYTE)v8 - 2) & 7u));
        if (v8 == (_BYTE *)&dword_0 + 2) {
          goto LABEL_32;
        }
        if (v7 + 2 < *((void *)a3 + 2))
        {
          v16[v7 + 2] = v10 >> (8 * (((_BYTE)v8 - 3) & 7u));
          if (v8 == (_BYTE *)&dword_0 + 3) {
            goto LABEL_32;
          }
          if (v7 + 3 < *((void *)a3 + 2))
          {
            v16[v7 + 3] = v10 >> (8 * (((_BYTE)v8 - 4) & 7u));
            if (v7 + 4 < *((void *)a3 + 2))
            {
              v16[v7 + 4] = v10 >> (8 * (((_BYTE)v8 - 5) & 7u));
              if (v8 == (_BYTE *)&dword_4 + 1) {
                goto LABEL_32;
              }
              if (v7 + 5 < *((void *)a3 + 2))
              {
                v16[v7 + 5] = v10 >> (8 * (((_BYTE)v8 - 6) & 7u));
                if (v8 == (_BYTE *)&dword_4 + 2) {
                  goto LABEL_32;
                }
                if (v7 + 6 < *((void *)a3 + 2))
                {
                  v16[v7 + 6] = v10 >> (8 * (((_BYTE)v8 - 7) & 7u));
                  if (v8 == (_BYTE *)&dword_4 + 3) {
                    goto LABEL_32;
                  }
                  if (v7 + 7 < *((void *)a3 + 2))
                  {
                    v16[v7 + 7] = v10 >> (v4 & 0x38);
LABEL_32:
                    *a2 = a3;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }

    __break(1u);
LABEL_35:
    id v8 = sub_2121E4(0LL, *((void *)v8 + 2) + 1LL, 1, v8);
  }

  if ((v10 & 0x8000000000000000LL) != 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  result = swift_isUniquelyReferenced_nonNull_native(*a2);
  if ((result & 1) != 0) {
    goto LABEL_30;
  }
LABEL_41:
  result = (uint64_t)sub_237300((uint64_t)a3);
  a3 = (char *)result;
LABEL_30:
  if (v13 < *((void *)a3 + 2))
  {
    a3[v13 + 32] = v10;
    goto LABEL_32;
  }

  __break(1u);
  return result;
}

    __break(1u);
LABEL_38:
    result = (uint64_t)sub_237300((uint64_t)a3);
    a3 = (char *)result;
LABEL_11:
    if (v13 >= *((void *)a3 + 2))
    {
      __break(1u);
      goto LABEL_40;
    }

    id v20 = a3 + 32;
    a3[v13 + 32] = (v4 >> 3) | 0x80;
    *a2 = a3;
    if (v7 < *((void *)a3 + 2))
    {
      v20[v7] = v10 >> (8 * (((_BYTE)v8 - 1) & 7u));
      if (v8 == (_BYTE *)&dword_0 + 1) {
        goto LABEL_32;
      }
      if (v7 + 1 < *((void *)a3 + 2))
      {
        v20[v7 + 1] = v10 >> (8 * (((_BYTE)v8 - 2) & 7u));
        if (v8 == (_BYTE *)&dword_0 + 2) {
          goto LABEL_32;
        }
        if (v7 + 2 < *((void *)a3 + 2))
        {
          v20[v7 + 2] = v10 >> (8 * (((_BYTE)v8 - 3) & 7u));
          if (v8 == (_BYTE *)&dword_0 + 3) {
            goto LABEL_32;
          }
          if (v7 + 3 < *((void *)a3 + 2))
          {
            v20[v7 + 3] = v10 >> (8 * (((_BYTE)v8 - 4) & 7u));
            if (v7 + 4 < *((void *)a3 + 2))
            {
              v20[v7 + 4] = v10 >> (8 * (((_BYTE)v8 - 5) & 7u));
              if (v8 == (_BYTE *)&dword_4 + 1) {
                goto LABEL_32;
              }
              if (v7 + 5 < *((void *)a3 + 2))
              {
                v20[v7 + 5] = v10 >> (8 * (((_BYTE)v8 - 6) & 7u));
                if (v8 == (_BYTE *)&dword_4 + 2) {
                  goto LABEL_32;
                }
                if (v7 + 6 < *((void *)a3 + 2))
                {
                  v20[v7 + 6] = v10 >> (8 * (((_BYTE)v8 - 7) & 7u));
                  if (v8 == (_BYTE *)&dword_4 + 3) {
                    goto LABEL_32;
                  }
                  if (v7 + 7 < *((void *)a3 + 2))
                  {
                    v20[v7 + 7] = v10 >> (v4 & 0x38);
LABEL_32:
                    *a2 = a3;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }

    __break(1u);
LABEL_35:
    id v8 = sub_2121E4(0LL, *((void *)v8 + 2) + 1LL, 1, v8);
  }

  if ((v10 & 0x8000000000000000LL) != 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  result = swift_isUniquelyReferenced_nonNull_native(*a2);
  if ((result & 1) != 0) {
    goto LABEL_30;
  }
LABEL_41:
  result = (uint64_t)sub_237300((uint64_t)a3);
  a3 = (char *)result;
LABEL_30:
  if (v13 < *((void *)a3 + 2))
  {
    a3[v13 + 32] = v10;
    goto LABEL_32;
  }

  __break(1u);
  return result;
}

    __break(1u);
LABEL_38:
    result = (uint64_t)sub_237300((uint64_t)a3);
    a3 = (char *)result;
LABEL_11:
    if (v13 >= *((void *)a3 + 2))
    {
      __break(1u);
      goto LABEL_40;
    }

    int v16 = a3 + 32;
    a3[v13 + 32] = (v4 >> 3) | 0x80;
    *a2 = a3;
    if (v7 < *((void *)a3 + 2))
    {
      v16[v7] = v10 >> (8 * (((_BYTE)v8 - 1) & 7u));
      if (v8 == (_BYTE *)&dword_0 + 1) {
        goto LABEL_32;
      }
      if (v7 + 1 < *((void *)a3 + 2))
      {
        v16[v7 + 1] = v10 >> (8 * (((_BYTE)v8 - 2) & 7u));
        if (v8 == (_BYTE *)&dword_0 + 2) {
          goto LABEL_32;
        }
        if (v7 + 2 < *((void *)a3 + 2))
        {
          v16[v7 + 2] = v10 >> (8 * (((_BYTE)v8 - 3) & 7u));
          if (v8 == (_BYTE *)&dword_0 + 3) {
            goto LABEL_32;
          }
          if (v7 + 3 < *((void *)a3 + 2))
          {
            v16[v7 + 3] = v10 >> (8 * (((_BYTE)v8 - 4) & 7u));
            if (v7 + 4 < *((void *)a3 + 2))
            {
              v16[v7 + 4] = v10 >> (8 * (((_BYTE)v8 - 5) & 7u));
              if (v8 == (_BYTE *)&dword_4 + 1) {
                goto LABEL_32;
              }
              if (v7 + 5 < *((void *)a3 + 2))
              {
                v16[v7 + 5] = v10 >> (8 * (((_BYTE)v8 - 6) & 7u));
                if (v8 == (_BYTE *)&dword_4 + 2) {
                  goto LABEL_32;
                }
                if (v7 + 6 < *((void *)a3 + 2))
                {
                  v16[v7 + 6] = v10 >> (8 * (((_BYTE)v8 - 7) & 7u));
                  if (v8 == (_BYTE *)&dword_4 + 3) {
                    goto LABEL_32;
                  }
                  if (v7 + 7 < *((void *)a3 + 2))
                  {
                    v16[v7 + 7] = v10 >> (v4 & 0x38);
LABEL_32:
                    *a2 = a3;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }

    __break(1u);
LABEL_35:
    id v8 = sub_2121E4(0LL, *((void *)v8 + 2) + 1LL, 1, v8);
  }

  if ((v10 & 0x8000000000000000LL) != 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  result = swift_isUniquelyReferenced_nonNull_native(*a2);
  if ((result & 1) != 0) {
    goto LABEL_30;
  }
LABEL_41:
  result = (uint64_t)sub_237300((uint64_t)a3);
  a3 = (char *)result;
LABEL_30:
  if (v13 < *((void *)a3 + 2))
  {
    a3[v13 + 32] = v10;
    goto LABEL_32;
  }

  __break(1u);
  return result;
}

void sub_5742C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_5ADA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void OUTLINED_FUNCTION_1_1( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_2_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_3_1(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void OUTLINED_FUNCTION_4_1(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
}

  ;
}

void OUTLINED_FUNCTION_7_0(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

uint64_t OUTLINED_FUNCTION_9_0(uint64_t a1, uint64_t a2)
{
  return a2;
}

  ;
}

  ;
}

  ;
}

  ;
}

uint64_t OUTLINED_FUNCTION_15(uint64_t result, float a2)
{
  *id v3 = a2;
  void *v2 = result;
  return result;
}

  ;
}

void sub_69958( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

void sub_69DA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_6A118( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_6BDE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

LABEL_64:
      uint64_t v57 = 0;
      uint64_t v58 = @"ResumePurging";
      goto LABEL_65;
    }

    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue([v69 oslog]);

    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v71 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543874;
      v196 = v71;
      v197 = 2114;
      v198 = (__CFString *)v165;
      v199 = 2114;
      v200 = v163;
      _os_log_impl( &dword_0,  v70,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {LoadPersistedDecideResume} had determined available for staging (resuming determined) | %{public}@ | %{public}@",  buf,  0x20u);
    }

    uint64_t v57 = 0;
    if (-[MADAutoAssetStager stagingClientUsingGroups](self, "stagingClientUsingGroups")) {
      uint64_t v58 = @"ResumeGroupsAvailable";
    }
    else {
      uint64_t v58 = @"ResumeAllAvailable";
    }
  }

  else
  {
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    uint64_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue([v54 oslog]);

    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      v56 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543618;
      v196 = v56;
      v197 = 2114;
      v198 = (__CFString *)v165;
      _os_log_impl( &dword_0,  v55,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {LoadPersistedDecideResume} no persisted indication of any pre-software-update-staging status | %{public}@",  buf,  0x16u);
    }

    uint64_t v57 = 0;
    uint64_t v58 = @"ResumeNothingAvailable";
    v163 = @"INVALID";
    uint64_t v44 = v164;
  }

LABEL_65:
  v78 = 0;
LABEL_66:

  return v78;
}

  -[MADAutoAssetJob setClientRequestedOperation:](self, "setClientRequestedOperation:", 1LL);
  v80 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob jobCreationTriggeringLayer](self, "jobCreationTriggeringLayer"));

  if (!v80)
  {
    v81 = (void *)objc_claimAutoreleasedReturnValue([v4 clientRequest]);
    uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v81 clientRequestMessage]);
    id v83 = (void *)objc_claimAutoreleasedReturnValue([v82 messageName]);

    if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO:INTEREST_IN_CONTENT") & 1) != 0 || (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO-SET:NEED_FOR_ATOMIC") & 1) != 0)
    {
      id v84 = @"ClientInterest";
    }

    else if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO:CHECK_FOR_NEWER") & 1) != 0 || (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO-SET:CHECK_ATOMIC") & 1) != 0)
    {
      id v84 = @"ClientCheck";
    }

    else if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO:LOCK_CONTENT") & 1) != 0 || (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO-SET:LOCK_ATOMIC") & 1) != 0)
    {
      id v84 = @"ClientLock";
    }

    else if (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v83,  @"MA-AUTO:DETERMINE_IF_AVAILABLE"))
    {
      id v84 = @"ClientDetermine";
    }

    else
    {
      id v84 = @"Unknown";
    }

    -[MADAutoAssetJob setJobCreationTriggeringLayer:](self, "setJobCreationTriggeringLayer:", v84);
  }

LABEL_70:
  id v85 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob activeJobTasks](self, "activeJobTasks"));
  __int128 v86 = [v85 count];

  if (!v86) {
    -[MADAutoAssetJob setCurrentJobTask:](self, "setCurrentJobTask:", v4);
  }
  __int128 v87 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob activeJobTasks](self, "activeJobTasks"));
  [v87 addObject:v4];

LABEL_73:
}

LABEL_65:
  v182 = self;
  if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v58,  @"ResumeNothingAvailable") & 1) != 0 || (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v58,  @"ResumePurging") & 1) != 0 || (+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v58,  @"ResumeGroupsAvailable") & 1) != 0)
  {
    v81 = 0LL;
    goto LABEL_69;
  }

  v158 = v57;
  v107 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](self, "persistedState"));
  v108 = (void *)objc_claimAutoreleasedReturnValue([v107 persistedEntryIDs:@"LoadPersistedDecideResume"]);

  if (![v108 count])
  {
    v135 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    v136 = (os_log_s *)objc_claimAutoreleasedReturnValue([v135 oslog]);

    if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
    {
      v151 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543874;
      v196 = v151;
      v197 = 2114;
      v198 = (__CFString *)v165;
      v199 = 2114;
      v200 = v163;
      _os_log_error_impl( &dword_0,  v136,  OS_LOG_TYPE_ERROR,  "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} no persisted entries (purging) | %{public}@ | %{public}@",  buf,  0x20u);
    }

    v81 = 0LL;
    uint64_t v58 = @"ResumePurging";
    goto LABEL_157;
  }

  v168 = v58;
  v192 = 0u;
  v193 = 0u;
  v190 = 0u;
  v191 = 0u;
  id obj = v108;
  v179 = [obj countByEnumeratingWithState:&v190 objects:v217 count:16];
  if (v179)
  {
    v153 = 0LL;
    v154 = 0uLL;
    v155 = 0LL;
    v156 = 0LL;
    v177 = *(void *)v191;
    v174 = v108;
    do
    {
      v109 = 0LL;
      do
      {
        if (*(void *)v191 != v177) {
          objc_enumerationMutation(obj);
        }
        v110 = *(__CFString **)(*((void *)&v190 + 1) + 8LL * (void)v109);
        v111 = objc_autoreleasePoolPush();
        v112 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](self, "persistedState"));
        v113 = (void *)objc_claimAutoreleasedReturnValue([v112 persistedEntry:v110 fromLocation:@"LoadPersistedDecideResume"]);

        if (v113)
        {
          v114 = (os_log_s *)objc_claimAutoreleasedReturnValue([v113 stringForKey:@"lastStagingFromOSVersion"]);
          v115 = (void *)objc_claimAutoreleasedReturnValue([v113 stringForKey:@"lastStagingFromBuildVersion"]);
          v116 = objc_claimAutoreleasedReturnValue([v113 stringForKey:@"assetTargetOSVersion"]);
          v117 = objc_claimAutoreleasedReturnValue([v113 stringForKey:@"assetTargetBuildVersion"]);
          v118 = (__CFString *)[v113 ullForKey:@"assetRepresentation"];
          v180 = (void *)v116;
          if (-[__objc2_ivar_list stringIsEqual:to:](v43[155], "stringIsEqual:to:", v175, v114)
            && -[__objc2_ivar_list stringIsEqual:to:](v43[155], "stringIsEqual:to:", v172, v115)
            && -[__objc2_ivar_list stringIsEqual:to:](v43[155], "stringIsEqual:to:", v171, v116)
            && -[__objc2_ivar_list stringIsEqual:to:](v43[155], "stringIsEqual:to:", v170, v117))
          {
            v169 = (void *)v117;
            switch((unint64_t)v118)
            {
              case 0x258uLL:
                v155 = (__CFString *)((char *)v155 + 1);
                self = v182;
                v119 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v182, "logger"));
                v120 = (os_log_s *)objc_claimAutoreleasedReturnValue([v119 oslog]);

                if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                {
                  v121 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
                  *(_DWORD *)buf = 138543618;
                  v196 = v121;
                  v197 = 2114;
                  v198 = v110;
                  v122 = v120;
                  v123 = "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} candidate entry:%{public}@";
                  goto LABEL_122;
                }

                break;
              case 0x259uLL:
                ++*((void *)&v154 + 1);
                self = v182;
                v129 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v182, "logger"));
                v120 = (os_log_s *)objc_claimAutoreleasedReturnValue([v129 oslog]);

                if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                {
                  v121 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
                  *(_DWORD *)buf = 138543618;
                  v196 = v121;
                  v197 = 2114;
                  v198 = v110;
                  v122 = v120;
                  v123 = "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} available entry:%{public}@";
                  goto LABEL_122;
                }

                break;
              case 0x25AuLL:
                *(void *)&v154 = v154 + 1;
                self = v182;
                v130 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v182, "logger"));
                v120 = (os_log_s *)objc_claimAutoreleasedReturnValue([v130 oslog]);

                if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                {
                  v121 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
                  *(_DWORD *)buf = 138543618;
                  v196 = v121;
                  v197 = 2114;
                  v198 = v110;
                  v122 = v120;
                  v123 = "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} staging entry:%{public}@";
                  goto LABEL_122;
                }

                break;
              case 0x25BuLL:
                ++v156;
                v153 = &v153[(void)[v113 ullForKey:@"assetContentBytes"]];
                self = v182;
                v131 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v182, "logger"));
                v120 = (os_log_s *)objc_claimAutoreleasedReturnValue([v131 oslog]);

                if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                {
                  v121 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
                  *(_DWORD *)buf = 138543618;
                  v196 = v121;
                  v197 = 2114;
                  v198 = v110;
                  v122 = v120;
                  v123 = "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} staged entry:%{public}@";
LABEL_122:
                  _os_log_impl(&dword_0, v122, OS_LOG_TYPE_DEFAULT, v123, buf, 0x16u);
                }

                break;
              default:
                v132 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v182, "logger"));
                v120 = (os_log_s *)objc_claimAutoreleasedReturnValue([v132 oslog]);

                if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
                {
                  v133 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
                  *(_DWORD *)buf = 138543874;
                  v196 = v133;
                  v197 = 2048;
                  v198 = v118;
                  self = v182;
                  v199 = 2114;
                  v200 = v110;
                  _os_log_error_impl( &dword_0,  v120,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {LoadPersistedDecideResume} unknown representation(%ld) for entry:%{public}@",  buf,  0x20u);
                }

                else
                {
                  self = v182;
                }

                break;
            }

            v124 = v169;
          }

          else
          {
            v124 = (void *)v117;
            self = v182;
            v125 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v182, "logger"));
            v120 = (os_log_s *)objc_claimAutoreleasedReturnValue([v125 oslog]);

            if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
            {
              v127 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
              *(_DWORD *)buf = 138543618;
              v196 = v127;
              v197 = 2114;
              v198 = v110;
              _os_log_error_impl( &dword_0,  v120,  OS_LOG_TYPE_ERROR,  "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} mismatched entry:%{public}@",  buf,  0x16u);
            }
          }

          uint64_t v43 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
          v108 = v174;
        }

        else
        {
          v126 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
          v114 = (os_log_s *)objc_claimAutoreleasedReturnValue([v126 oslog]);

          if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
          {
            v128 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
            *(_DWORD *)buf = 138543618;
            v196 = v128;
            v197 = 2114;
            v198 = v110;
            _os_log_error_impl( &dword_0,  v114,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {LoadPersistedDecideResume} unable to determine previous status for entry:%{public}@",  buf,  0x16u);
          }
        }

        objc_autoreleasePoolPop(v111);
        v109 = (char *)v109 + 1;
      }

      while (v179 != v109);
      v134 = [obj countByEnumeratingWithState:&v190 objects:v217 count:16];
      v179 = v134;
    }

    while (v134);
  }

  else
  {
    v153 = 0LL;
    v154 = 0uLL;
    v155 = 0LL;
    v156 = 0LL;
  }

  if (v166 == v155
    && __PAIR128__((unint64_t)v161, (void)v160 + *((void *)&v160 + 1)) == v154
    && v162 == v156
    && (char *)v159 == v153)
  {
    v137 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    v138 = (os_log_s *)objc_claimAutoreleasedReturnValue([v137 oslog]);

    uint64_t v44 = v164;
    p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
    if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
    {
      v139 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543362;
      v196 = v139;
      _os_log_impl( &dword_0,  v138,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} persisted entry counts match staging summary counts",  buf,  0xCu);
    }

    uint64_t v58 = v168;
    v81 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager _persistRebuildTrackingNewHandedOffDescriptors:]( self,  "_persistRebuildTrackingNewHandedOffDescriptors:",  v168));
    goto LABEL_157;
  }

  p_ivars = &MobileAssetKeyManager__metaData.ivars;
  v140 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"candidates:%llu,determinedAvailable:%llu,activelyStaging:%llu | [stagedAssets]count:%llu,totalContentBytes:%llu",  v155,  *((void *)&v154 + 1),  (void)v154,  v156,  v153);
  v141 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  v142 = (os_log_s *)objc_claimAutoreleasedReturnValue([v141 oslog]);

  uint64_t v44 = v164;
  if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
  {
    v152 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
    *(_DWORD *)buf = 138543874;
    v196 = v152;
    v197 = 2114;
    v198 = v163;
    v199 = 2114;
    v200 = (__CFString *)v140;
    _os_log_error_impl( &dword_0,  v142,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {LoadPersistedDecideResume} staging summary differs from per-entry totals | stagingSummary:%{public} @ | entryTotals:%{public}@",  buf,  0x20u);
  }

  v143 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  v144 = (os_log_s *)objc_claimAutoreleasedReturnValue([v143 oslog]);

  if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134220544;
    v196 = v166;
    v197 = 2048;
    v198 = v155;
    v199 = 2048;
    v200 = v161;
    v201 = 2048;
    v202 = *((void *)&v154 + 1);
    v203 = 2048;
    v204 = *((void *)&v160 + 1);
    v205 = 2048;
    v206 = v160;
    v207 = 2048;
    v208 = v154;
    v209 = 2048;
    v210 = v162;
    v211 = 2048;
    v212 = v156;
    v213 = 2048;
    v214 = v159;
    v215 = 2048;
    v216 = v153;
    _os_log_error_impl( &dword_0,  v144,  OS_LOG_TYPE_ERROR,  "{LoadPersistedDecideResume} comparisons made | candidateAssetCount(%llu) to entryCandidateAssetCount(%llu) | deter minedAvailableAssetCount(%llu) to entryDeterminedAvailableAssetCount(%llu) | (activelyStagingAssetCount(%llu) + aw aitingStagingAssetCount(%llu)) to entryActivelyStagingAssetCount(%llu) | stagedAssetCount(%llu) to entryStagedAsse tCount(%llu) | stagedAssetTotalContentBytes(%llu) to entryStagedAssetTotalContentBytes(%llu)",  buf,  0x70u);
  }

  if ((-[__objc2_ivar_list stringIsEqual:to:]( v43[155],  "stringIsEqual:to:",  v168,  @"ResumePromotingAllStaged") & 1) == 0 && (-[__objc2_ivar_list stringIsEqual:to:]( v43[155],  "stringIsEqual:to:",  v168,  @"ResumeRunningTargetVersion") & 1) == 0)
  {
    v81 = 0LL;
    v145 = @"ResumePurging";
    if (!-[__objc2_ivar_list stringIsEqual:to:]( v43[155],  "stringIsEqual:to:",  v168,  @"ResumeStaged")
      || !v156)
    {
      goto LABEL_156;
    }
      }

      objc_autoreleasePoolPop(context);
      uint64_t v13 = v57 + 1;
    }

    while ((id)(v57 + 1) != v7);
    id v7 = [v4 countByEnumeratingWithState:&v65 objects:v76 count:16];
  }

  while (v7);

  if (!v9)
  {
LABEL_71:
    unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[SUCoreLog oslog](self->_logger, "oslog", v51));
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetJob _newSelectorForCachedAssetCatalog:].cold.1(v4);
    }

    id v9 = 0LL;
  }

  return v9;
}

LABEL_153:
    v148 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    v149 = (os_log_s *)objc_claimAutoreleasedReturnValue([v148 oslog]);

    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
      v150 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      *(_DWORD *)buf = 138543362;
      v196 = v150;
      _os_log_impl( &dword_0,  v149,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} preserving successfully staged content",  buf,  0xCu);
    }

    v145 = v168;
    v81 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager _persistRebuildTrackingNewHandedOffDescriptors:]( self,  "_persistRebuildTrackingNewHandedOffDescriptors:",  v168));
    goto LABEL_156;
  }

  if (v156) {
    goto LABEL_153;
  }
  v81 = 0LL;
  v145 = @"ResumePurging";
LABEL_156:

  uint64_t v58 = v145;
LABEL_157:

  uint64_t v57 = v158;
LABEL_69:
  v167 = v58;
  if (-[__objc2_ivar_list stringIsEqual:to:]( v43[155],  "stringIsEqual:to:",  v58,  @"ResumeNothingAvailable"))
  {
    -[MADAutoAssetStager _persistRemoveAll:message:removingDetermined:loggingConfig:]( self,  "_persistRemoveAll:message:removingDetermined:loggingConfig:",  @"LoadPersistedDecideResume",  @"removed all persisted-state (nothing available)",  1LL,  1LL);
    if ((v57 & 1) != 0) {
      goto LABEL_88;
    }
  }

  else
  {
    v157 = v57;
    uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](self, "persistedState"));
    id v83 = (void *)objc_claimAutoreleasedReturnValue([v82 persistedEntryIDs:@"LoadPersistedDecideResume"]);

    if ([v83 count])
    {
      v176 = v83;
      v178 = v81;
      v188 = 0u;
      v189 = 0u;
      v186 = 0u;
      v187 = 0u;
      id v84 = v83;
      id v85 = [v84 countByEnumeratingWithState:&v186 objects:v194 count:16];
      if (v85)
      {
        __int128 v86 = v85;
        __int128 v87 = *(void *)v187;
        do
        {
          for (uint64_t i = 0LL; i != v86; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v187 != v87) {
              objc_enumerationMutation(v84);
            }
            __int128 v89 = *(__CFString **)(*((void *)&v186 + 1) + 8LL * (void)i);
            v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](self, "persistedState"));
            v91 = (void *)objc_claimAutoreleasedReturnValue([v90 persistedEntry:v89 fromLocation:@"LoadPersistedDecideResume"]);

            if (v91)
            {
              v92 = [v91 ullForKey:@"assetRepresentation"];
              v93 = [v91 secureCodedObjectForKey:@"assetDescriptor" ofClass:objc_opt_class(MADAutoAssetDescriptor)];
              v94 = (os_log_s *)objc_claimAutoreleasedReturnValue(v93);
              -[MADAutoAssetStager _persistDescriptor:operation:persistingDescriptor:withRepresentation:message:]( self,  "_persistDescriptor:operation:persistingDescriptor:withRepresentation:message:",  @"LoadPersistedDecideResume",  @"ENTRY_LOAD",  v94,  v92,  @"loaded and validated entry");
            }

            else
            {
              v95 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
              v94 = (os_log_s *)objc_claimAutoreleasedReturnValue([v95 oslog]);

              if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
              {
                v96 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v182, "summary"));
                *(_DWORD *)buf = 138543618;
                v196 = v96;
                v197 = 2114;
                v198 = v89;
                _os_log_error_impl( &dword_0,  v94,  OS_LOG_TYPE_ERROR,  "%{public}@\n[AUTO-STAGER] {LoadPersistedDecideResume} unable to load entry:%{public}@",  buf,  0x16u);
              }

              self = v182;
            }
          }

          __int128 v86 = [v84 countByEnumeratingWithState:&v186 objects:v194 count:16];
        }

        while (v86);
      }

      uint64_t v44 = v164;
      uint64_t v43 = &MobileAssetKeyManager__metaData.ivars;
      p_ivars = &MobileAssetKeyManager__metaData.ivars;
      id v83 = v176;
      v81 = v178;
    }

    -[MADAutoAssetStager _logPersistedTableOfContents:]( self,  "_logPersistedTableOfContents:",  @"LoadPersistedDecideResume");

    if ((v157 & 1) != 0) {
      goto LABEL_88;
    }
  }

  if (!-[MADAutoAssetStager alwaysPromoteStagedAssets](self, "alwaysPromoteStagedAssets"))
  {
    v97 = 0LL;
    if (v81) {
      goto LABEL_89;
    }
    goto LABEL_91;
  }

LABEL_88:
  v97 = -[MADAutoAssetStager newSetLookupResultsForTargetOS](self, "newSetLookupResultsForTargetOS");
  if (v81)
  {
LABEL_89:
    v98 = (__CFString *)objc_msgSend( objc_alloc((Class)p_ivars[137]),  "initWithFormat:",  @"loaded persisted-state (handedOffAsPromoted:%ld)",  objc_msgSend(v81, "count"));
    goto LABEL_92;
  }

  if ((a3 & 0x1000000) == 0) {
    goto LABEL_97;
  }
  uint64_t v65 = v14;
  uint64_t v66 = getDownloadManager();
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(v66);
  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v67 downloadManagerDecodeClasses]);
  v139 = 0LL;
  uint64_t v69 = getObjectFromMessageWithFailureReason(v10, "downloadConfigLength", "downloadConfig", v68, &v139);
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
  id v17 = (__CFString *)v139;

  if (v70)
  {
    uint64_t v71 = objc_opt_class(&OBJC_CLASS___MADownloadConfig);
    if ((objc_opt_isKindOfClass(v70, v71) & 1) != 0)
    {
      [v11 associateDownloadConfig:v70];
      id v72 = (__CFString *)objc_claimAutoreleasedReturnValue([v70 summary]);
      [v12 extendLogLeader:@"downloadConfig" withValue:v72];
    }

    else
    {
      id v72 = v17;
      id v17 = @"Invalid download config class provided by client";
    }

    uint64_t v14 = v65;
  }

  else
  {
    uint64_t v14 = v65;
  }

LABEL_96:
  if (v17) {
    goto LABEL_182;
  }
LABEL_97:
  v73 = v127;
  if ((a3 & 0x400000000000LL) == 0) {
    goto LABEL_102;
  }
  uint64_t v74 = xpc_dictionary_get_uint64(v10, "assetState");
  if (v74 <= 6)
  {
    [v11 associateAssetState:v74];
    id v75 = stringForMAAssetState((unint64_t)[v11 assetState]);
    id v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
    [v12 extendLogLeader:@"assetState" withValue:v76];

    goto LABEL_102;
  }

  uint64_t v59 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown current state [%llu] provided by client",  v74);
  if (v59)
  {
LABEL_101:
    id v17 = (__CFString *)v59;
    goto LABEL_182;
  }

      objc_autoreleasePoolPop(v96);
    }

    v92 = [objb countByEnumeratingWithState:&v175 objects:v200 count:16];
    if (v92) {
      continue;
    }
    break;
  }

    __break(1u);
    goto LABEL_89;
  }

  swift_bridgeObjectRelease(a2);
  id v2 = *((void *)v8 + 2);
  if (!v2) {
    goto LABEL_49;
  }
LABEL_36:
  uint64_t v28 = v8 + 32;
  uint64_t v29 = v8;
  uint64_t v31 = *((void *)v8 + 4);
  uint64_t v30 = *((void *)v8 + 5);
  id v32 = *((void *)v29 + 6);
  unsigned int v33 = *((void *)v29 + 7);
  __int128 v34 = (uint64_t)v29;
  __int128 v87 = (uint64_t)v28;
  __int128 v35 = &v28[32 * v2];
  __int128 v36 = *((void *)v35 - 4);
  __int128 v37 = *((void *)v35 - 3);
  id v39 = *((void *)v35 - 2);
  id v38 = *((void *)v35 - 1);
  swift_bridgeObjectRetain(v33);
  swift_bridgeObjectRetain(v38);
  v93 = sub_2231B4( 0x4745422D2D2D2D2DuLL,  0xEB00000000204E49LL,  0x2D2D2D2D2DuLL,  0xE500000000000000LL,  v31,  v30,  v32,  v33);
  v41 = v40;
  swift_bridgeObjectRelease(v33);
  if (!v41)
  {
    uint64_t v46 = v38;
LABEL_51:
    swift_bridgeObjectRelease(v46);
    goto LABEL_53;
  }

  swift_bridgeObjectRetain(v41);
  uint64_t v42 = sub_2231B4( 0x444E452D2D2D2D2DuLL,  0xE900000000000020LL,  0x2D2D2D2D2DuLL,  0xE500000000000000LL,  v36,  v37,  v39,  v38);
  id v10 = v43;
  swift_bridgeObjectRelease(v38);
  if (!v10)
  {
    swift_bridgeObjectRelease_n(v41, 2LL);
LABEL_53:
    uint64_t v57 = sub_222964();
    uint64_t v55 = swift_allocError(&type metadata for CryptoKitASN1Error, v57, 0LL, 0LL);
LABEL_54:
    void *v56 = 7;
    swift_willThrow(v55);
    return swift_bridgeObjectRelease(v34);
  }

  if (v93 == v42 && v41 == v10)
  {
    swift_bridgeObjectRelease(v41);
    swift_bridgeObjectRelease(v10);
  }

  else
  {
    uint64_t v45 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease(v41);
    swift_bridgeObjectRelease(v10);
    if ((v45 & 1) == 0)
    {
      uint64_t v46 = v41;
      goto LABEL_51;
    }
  }

  result = sub_222B64(1LL, v34, v87, 1LL, (2 * v2) | 1);
  if (__OFSUB__(v61 >> 1, v60))
  {
    __break(1u);
    goto LABEL_91;
  }

  id v9 = result;
  if ((uint64_t)((v61 >> 1) - v60) < 1)
  {
LABEL_82:
    swift_bridgeObjectRelease(v41);
LABEL_83:
    v79 = sub_222964();
    v80 = swift_allocError(&type metadata for CryptoKitASN1Error, v79, 0LL, 0LL);
    *v81 = 7;
    swift_willThrow(v80);
    return swift_unknownObjectRelease(v9);
  }

  id v83 = v59;
  id v84 = v61 >> 1;
  id v85 = v60;
  __int128 v88 = result;
  uint64_t v82 = v61;
  result = sub_222B64(1LL, result, v59, v60, v61);
  uint64_t v64 = result;
  id v5 = v65 >> 1;
  if (v63 != v65 >> 1)
  {
    uint64_t v66 = v63;
    id v8 = (char *)(v62 + 32 * v63 + 16);
    do
    {
      if (v66 >= v5) {
        goto LABEL_87;
      }
      uint64_t v67 = *((void *)v8 - 2);
      id v10 = *((void *)v8 - 1);
      uint64_t v68 = *(void *)v8;
      id v2 = *((void *)v8 + 1);
      uint64_t v69 = (*(void *)v8 >> 59) & 1LL;
      if ((v2 & 0x1000000000000000LL) == 0) {
        LOBYTE(v69) = 1;
      }
      id v9 = 4LL << v69;
      if ((*((void *)v8 - 2) & 0xCLL) == 4LL << v69)
      {
        result = sub_22378C(*((void *)v8 - 2), *(void *)v8, *((void *)v8 + 1));
        uint64_t v67 = result;
      }

      if ((v10 & 0xC) == v9)
      {
        id v9 = v64;
        result = sub_22378C(v10, v68, v2);
        id v10 = result;
        if ((v2 & 0x1000000000000000LL) == 0)
        {
LABEL_71:
          result = (v10 >> 16) - (v67 >> 16);
          if (result != 64) {
            goto LABEL_80;
          }
          goto LABEL_72;
        }
      }

      else if ((v2 & 0x1000000000000000LL) == 0)
      {
        goto LABEL_71;
      }

      uint64_t v70 = HIBYTE(v2) & 0xF;
      if ((v2 & 0x2000000000000000LL) == 0) {
        uint64_t v70 = v68 & 0xFFFFFFFFFFFFLL;
      }
      if (v70 < v67 >> 16) {
        goto LABEL_93;
      }
      if (v70 < v10 >> 16) {
        goto LABEL_94;
      }
      id v9 = v64;
      result = String.UTF8View._foreignDistance(from:to:)(v67, v10, v68, v2);
      if (result != 64)
      {
LABEL_80:
        id v9 = v88;
        swift_unknownObjectRetain(v88);
        swift_bridgeObjectRelease(v41);
        swift_unknownObjectRelease(v64);
        goto LABEL_83;
      }

LABEL_91:
  v98 = @"loaded persisted-state (no promotion)";
LABEL_92:
  -[MADAutoAssetStager _logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:]( self,  "_logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:",  @"LoadPersistedDecideResume",  v167,  v98);
  if (-[__objc2_ivar_list stringIsEqual:to:]( v43[155],  "stringIsEqual:to:",  v167,  @"ResumeGroupsAvailable"))
  {
    -[MADAutoAssetStager setAssetTargetOSVersion:](self, "setAssetTargetOSVersion:", v175);
    -[MADAutoAssetStager setAssetTargetBuildVersion:](self, "setAssetTargetBuildVersion:", v172);
    -[MADAutoAssetStager setAssetTargetTrainName:](self, "setAssetTargetTrainName:", v171);
    -[MADAutoAssetStager setAssetTargetRestoreVersion:](self, "setAssetTargetRestoreVersion:", v170);
  }

  -[MADAutoAssetStager _logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:]( self,  "_logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:",  @"LoadPersistedDecideResume",  0LL,  @"after resuming from persisted-state");
  v99 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager selectDispatchQueue:]( &OBJC_CLASS___MADAutoAssetControlManager,  "selectDispatchQueue:",  0LL));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __61__MADAutoAssetStager_action_LoadPersistedDecideResume_error___block_invoke;
  block[3] = &unk_34DB98;
  v184 = v81;
  v185 = v97;
  v100 = v97;
  v101 = v81;
  dispatch_async(v99, block);

  v102 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
  v103 = objc_alloc(&OBJC_CLASS___MADAutoAssetStagerParam);
  v104 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
  v105 = -[MADAutoAssetStagerParam initWithSafeSummary:](v103, "initWithSafeSummary:", v104);
  [v102 followupEvent:v167 withInfo:v105];

  return 0LL;
}

LABEL_38:
  return 0LL;
}
}

LABEL_39:
                uint64_t v40 = v154;
              }

        objc_autoreleasePoolPop(v24);
        if ((v20 & 1) == 0) {
          goto LABEL_30;
        }
        goto LABEL_39;
      }

      objc_autoreleasePoolPop(v24);
      id v20 = 1;
    }

    int v19 = [obj countByEnumeratingWithState:&v93 objects:v103 count:16];
    if (v19) {
      continue;
    }
    break;
  }

  char v27 = (void *)objc_claimAutoreleasedReturnValue([v9 latestDownloadedAtomicInstance]);
  id v10 = v89;
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v89 latestAtomicInstanceToVend]);
  uint64_t v29 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v27, v28);

  if ((v29 & 1) != 0)
  {
    uint64_t v30 = 1;
    id v8 = v88;
LABEL_40:
    uint64_t v13 = v92;
    goto LABEL_34;
  }

  id v8 = v88;
  uint64_t v13 = v92;
  if (-[MADAutoAssetControlManager setDescriptorVerifyNoDuplicates:](self, "setDescriptorVerifyNoDuplicates:", v9))
  {
    p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
  }

  else
  {
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager setDescriptorDedupDownloadedEntries:forSetDescriptor:]( self,  "setDescriptorDedupDownloadedEntries:forSetDescriptor:",  v92,  v9));
    p_ivars = &MobileAssetKeyManager__metaData.ivars;
    if (v59)
    {
      -[MADAutoAssetControlManager persistSetDescriptorDownloadedJob:fromLocation:]( self,  "persistSetDescriptorDownloadedJob:fromLocation:",  v59,  v92);
      uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      v61 = (os_log_s *)objc_claimAutoreleasedReturnValue([v60 oslog]);

      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        v62 = (void *)objc_claimAutoreleasedReturnValue([v59 summary]);
        *(_DWORD *)buf = 138543618;
        v98 = v92;
        v99 = 2114;
        v100 = v62;
        _os_log_impl( &dword_0,  v61,  OS_LOG_TYPE_DEFAULT,  "{%{public}@}\n[SELF-HEAL] deduped setDescriptor:%{public}@",  buf,  0x16u);
      }

      id v63 = v59;
      id v9 = v63;
    }
  }

  if (!-[MADAutoAssetControlManager setDescriptorVerifyNoDuplicates:](self, "setDescriptorVerifyNoDuplicates:", v9))
  {
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
    id v77 = (void *)objc_claimAutoreleasedReturnValue([v31 diag]);
    v78 = objc_alloc((Class)p_ivars[137]);
    v79 = (void *)objc_claimAutoreleasedReturnValue([v9 summary]);
    v80 = (void *)objc_claimAutoreleasedReturnValue([v89 summary]);
    v81 = [v78 initWithFormat:@"{%@} all entries available yet set-descriptor contains duplicate selectors | setDescriptor:%@| setConfiguration:%@", v92, v79, v80];
    [v77 trackAnomaly:@"LATEST-TO-VEND" forReason:v81 withResult:6108 withError:0];

LABEL_28:
LABEL_33:
    uint64_t v30 = 0;
    goto LABEL_34;
  }

  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v9 latestDownloadedAtomicInstance]);
  uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetAtomicInstanceByInstanceUUID:]( self,  "locateSetAtomicInstanceByInstanceUUID:",  v64));

  uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v9 latestDownloadedAtomicInstance]);
  [v89 setLatestAtomicInstanceToVend:v66];

  [v89 setHaveReceivedLookupResponse:1];
  [v89 setVendingAtomicInstanceForConfiguredEntries:1];
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue([v67 oslog]);

  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v89 summary]);
    *(_DWORD *)buf = 138543618;
    v98 = v92;
    v99 = 2114;
    v100 = v69;
    _os_log_impl( &dword_0,  v68,  OS_LOG_TYPE_DEFAULT,  "{%{public}@}\n [LATEST-TO-VEND] update to set-configuration latestAtomicInstanceToVend | setConfiguration:%{public}@",  buf,  0x16u);
  }

  -[MADAutoAssetControlManager setConfigurationPersist:fromLocation:dueToAlter:forHistoryOperation:]( self,  "setConfigurationPersist:fromLocation:dueToAlter:forHistoryOperation:",  v89,  v92,  0LL,  9999LL);
  __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v89 autoAssetEntries]);
  id v84 = [v87 count];
  __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v9 requestedAutoAssetEntries]);
  id v83 = [v86 count];
  id v85 = (void *)objc_claimAutoreleasedReturnValue([v9 discoveredAtomicEntries]);
  uint64_t v82 = [v85 count];
  obja = v65;
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v65 instanceEntries]);
  uint64_t v71 = [v70 count];
  id v72 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
  v73 = (void *)objc_claimAutoreleasedReturnValue([v89 assetSetIdentifier]);
  uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v89 latestAtomicInstanceToVend]);
  id v75 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _specifierVersionNamesForSetDescriptor:]( self,  "_specifierVersionNamesForSetDescriptor:",  v9));
  uint64_t v30 = 1;
  +[MADAutoAssetHistory recordOperation:toHistoryType:fromLayer:configuredCount:requestedCount:fromPallasCount:vendingCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:withAddendumMessage:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromLayer:configuredCount:requestedCount:fromPallasCount:vendingCount:forClientDomainN ame:forAssetSetIdentifier:forAtomicInstance:withAddendumMessage:",  441LL,  2LL,  1LL,  v84,  v83,  v82,  v71,  v72,  v73,  v74,  v75);

  id v10 = v89;
  -[MADAutoAssetControlManager _reclaimDownloadedDescriptorsWhenJustDownloaded:fromLocation:]( self,  "_reclaimDownloadedDescriptorsWhenJustDownloaded:fromLocation:",  v9,  v92);
  id v76 = (void *)objc_claimAutoreleasedReturnValue([v89 assetSetIdentifier]);
  +[MADAutoAssetControlManager postSetNotificationName:forAssetSetIdentifier:fromModule:fromLocation:]( &OBJC_CLASS___MADAutoAssetControlManager,  "postSetNotificationName:forAssetSetIdentifier:fromModule:fromLocation:",  @"ATOMIC_INSTANCE_DOWNLOADED",  v76,  @"AUTO-CONTROL",  v92);

  [v9 setAtomicInstanceDownloadedNotified:1];
  id v8 = v88;
LABEL_34:

  return v30;
}

  return v40;
}

      uint64_t v28 = *(void *)(a1 + 48);
      if (v28)
      {
        uint64_t v29 = objc_opt_class(&OBJC_CLASS___NSDate);
        if ((objc_opt_isKindOfClass(v28, v29) & 1) != 0)
        {
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKey:@"PostingDate"]);
          uint64_t v30 = objc_opt_class(&OBJC_CLASS___NSString);
          if ((objc_opt_isKindOfClass(v11, v30) & 1) != 0)
          {
            uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) dateFromString:v11]);
            if ([v31 compare:*(void *)(a1 + 48)] == (char *)&dword_0 + 1)
            {
              ++*(void *)(*(void *)(*(void *)(a1 + 120) + 8LL) + 24LL);

              goto LABEL_43;
            }
          }

          else
          {
            ++*(void *)(*(void *)(*(void *)(a1 + 128) + 8LL) + 24LL);
          }
        }
      }

      id v32 = *(void *)(a1 + 64);
      if (v32)
      {
        unsigned int v33 = objc_opt_class(&OBJC_CLASS___NSDate);
        if ((objc_opt_isKindOfClass(v32, v33) & 1) != 0)
        {
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKey:@"ExpirationDate"]);
          __int128 v34 = objc_opt_class(&OBJC_CLASS___NSString);
          if ((objc_opt_isKindOfClass(v18, v34) & 1) != 0)
          {
            __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) dateFromString:v18]);
            if ([v35 compare:*(void *)(a1 + 64)] == (char *)&dword_0 + 1)
            {
              ++*(void *)(*(void *)(*(void *)(a1 + 136) + 8LL) + 24LL);

              goto LABEL_32;
            }
          }

          else
          {
            ++*(void *)(*(void *)(*(void *)(a1 + 144) + 8LL) + 24LL);
          }
        }
      }

      uint64_t v14 = 1LL;
      goto LABEL_11;
    }
  }

  uint64_t v13 = v5;
LABEL_10:
  uint64_t v14 = 0LL;
  ++*(void *)(*(void *)(*(void *)(a1 + 152) + 8LL) + 24LL);
LABEL_11:

  return v14;
}

          uint64_t v12 = uint_public_value;
          goto LABEL_36;
        }

        id v21 = &a5[((unint64_t)(cczp_bitlen((uint64_t)a2) + 7) >> 3) + 1];
        id v22 = &a6[*a2];
        id v23 = cczp_bitlen((uint64_t)a2);
        uint64_t v12 = ccn_read_uint_public_value(v11, v22, (unint64_t)(v23 + 7) >> 3, v21);
        if (!(_DWORD)v12)
        {
          if (a3 != 2 || (a6[*a2] & 1LL) == (*a5 & 1))
          {
LABEL_35:
            uint64_t v12 = 0LL;
            goto LABEL_36;
          }

          uint64_t v12 = 4294967125LL;
        }
      }

    __break(1u);
    goto LABEL_39;
  }

  if ((v4 & 0x8000000000000000LL) == 0)
  {
    result = swift_isUniquelyReferenced_nonNull_native(*a2);
    if ((result & 1) != 0) {
      goto LABEL_32;
    }
    goto LABEL_42;
  }

LABEL_39:
                      objc_autoreleasePoolPop(context);
                      goto LABEL_40;
                    }
                  }
                }
}

    goto LABEL_40;
  }

  if (a5)
  {
    v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Manifest storage service unavailable"));
    v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    [v48 setObject:v47 forKeyedSubscript:NSDebugDescriptionErrorKey];
    [v48 setObject:0 forKeyedSubscript:NSUnderlyingErrorKey];
    unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  -5LL,  v48));

    *a5 = v49;
  }

  v50 = 0;
LABEL_41:

  return v50;
}

        goto LABEL_40;
      }

LABEL_40:
        v103 = objc_autoreleasePoolPush();
        v104 = objc_alloc_init(&OBJC_CLASS___MobileAssetKeyManager);
        v105 = (void *)objc_claimAutoreleasedReturnValue( +[DownloadManager pathToCatalogLookupServer:usingDownloadOptions:]( &OBJC_CLASS___DownloadManager,  "pathToCatalogLookupServer:usingDownloadOptions:",  v196,  v11));
        IsKnoxSupportedFromPallasURL = getIsKnoxSupportedFromPallasURL(v105);
        v111 = IsKnoxSupportedFromPallasURL ^ 1u;
        v112 = @"disabled";
        if (IsKnoxSupportedFromPallasURL) {
          v112 = @"enabled";
        }
        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Knox lookup for decryption key %@",  v107,  v108,  v109,  v110,  (uint64_t)v112);
        v117 = [v11 discretionary];
        if ((_DWORD)v117) {
          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Will not prompt user for AppleConnect token for key retrieval due to discretionary download",  v113,  v114,  v115,  v116,  v191);
        }
        if (__isPlatformVersionAtLeast(3, 17, 0, 0) && [v11 disableUI])
        {
          v118 = [v11 disableUI];
          v123 = @"Will not prompt";
          if (v118) {
            v123 = @"Will prompt(if required)";
          }
          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"%@ user for AppleConnect token for key retrieval due to override on downloadOptions",  v119,  v120,  v121,  v122,  (uint64_t)v123);
          v117 = &dword_0 + 1;
        }

        v198 = 0LL;
        v124 = (NSData *)objc_claimAutoreleasedReturnValue( -[MobileAssetKeyManager getDecryptionKey:downloadOptions:apTicket:skipKnoxLookup:disableUI:error:]( v104,  "getDecryptionKey:downloadOptions:apTicket:skipKnoxLookup:disableUI:error:",  v10,  v11,  0LL,  v111,  v117,  &v198));
        v125 = v198;
        v130 = v125;
        if (!v124 || v125)
        {
          if (v125)
          {
            v131 = (void *)objc_claimAutoreleasedReturnValue([v125 description]);
            _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Unable to obtain decryption key: error: %@",  v132,  v133,  v134,  v135,  (uint64_t)v131);
          }

          else
          {
            _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Unable to obtain decryption key: error: %@",  v126,  v127,  v128,  v129,  (uint64_t)@"None");
          }

          if (-[__CFString isEqualToString:](v18, "isEqualToString:", @"AppleEncryptedArchive"))
          {
            v141 = MAErrorForDownloadResultWithUnderlying( 0x54uLL,  v130,  @"Failed to obtain decryption key",  v136,  v137,  v138,  v139,  v140,  v192);
            uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v141);

            objc_autoreleasePoolPop(v103);
            v41 = 0LL;
            v142 = v194;
            uint64_t v13 = v196;
            goto LABEL_79;
          }

          objc_autoreleasePoolPop(v103);
          if (!v124)
          {
            uint64_t v13 = v196;
            goto LABEL_68;
          }
        }

        else
        {

          objc_autoreleasePoolPop(v103);
        }

        v143 = objc_opt_class(&OBJC_CLASS___NSString);
        v142 = v194;
        uint64_t v13 = v196;
        if ((objc_opt_isKindOfClass(v124, v143) & 1) != 0)
        {
          v144 = -[NSData initWithBase64EncodedString:options:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBase64EncodedString:options:",  v124,  0LL);

          v124 = v144;
          if (!v144)
          {
            v150 = MAErrorForDownloadResultWithUnderlying( 0x17uLL,  0LL,  @"[%s:%d] [%s] unable to base64 decode string decryption key",  v145,  v146,  v147,  v148,  v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
            uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v150);
LABEL_75:
            v41 = 0LL;
            goto LABEL_79;
          }
        }

        else
        {
          v151 = objc_opt_class(&OBJC_CLASS___NSData);
          if ((objc_opt_isKindOfClass(v124, v151) & 1) == 0)
          {
            object_getClassName(v124);
            v157 = MAErrorForDownloadResultWithUnderlying( 0x17uLL,  0LL,  @"[%s:%d] [%s] decryption key is not an NSString or NSData: %s",  v152,  v153,  v154,  v155,  v156,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
            goto LABEL_74;
          }
        }

        if ((char *)-[NSData length](v124, "length") == (char *)&stru_20.nsects + 1)
        {
          [v194 setAsymmetricDecryptionKey:v124];
LABEL_68:
          if (v10)
          {
            v158 = objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"ArchiveID"]);
            if (v158)
            {
              v159 = (void *)v158;
              v160 = objc_opt_class(&OBJC_CLASS___NSString);
              if ((objc_opt_isKindOfClass(v159, v160) & 1) != 0)
              {
                v161 = -[NSData initWithBase64EncodedString:options:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBase64EncodedString:options:",  v159,  0LL);

                v159 = v161;
                if (!v161)
                {
                  v167 = MAErrorForDownloadResultWithUnderlying( 0x17uLL,  0LL,  @"[%s:%d] [%s] unable to base64 decode string archive ID",  v162,  v163,  v164,  v165,  v166,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
                  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v167);
LABEL_84:

                  v41 = 0LL;
                  v142 = v194;
LABEL_79:

                  if (!a6) {
                    goto LABEL_82;
                  }
                  goto LABEL_80;
                }
              }

              else
              {
                v177 = objc_opt_class(&OBJC_CLASS___NSData);
                if ((objc_opt_isKindOfClass(v159, v177) & 1) == 0)
                {
                  object_getClassName(v124);
                  v184 = MAErrorForDownloadResultWithUnderlying( 0x17uLL,  0LL,  @"[%s:%d] [%s] archive ID is not an NSString or NSData: %s",  v179,  v180,  v181,  v182,  v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
                  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v184);

                  goto LABEL_84;
                }
              }

              [v194 setArchiveID:v159];
            }
          }

          v142 = v194;
          v41 = v194;

          uint64_t v40 = 0LL;
          goto LABEL_79;
        }

        if ((segment_command_64 *)-[NSData length](v124, "length") == &stru_20)
        {
          [v194 setSymmetricDecryptionKey:v124];
          goto LABEL_68;
        }

        -[NSData length](v124, "length");
        _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"[%s:%d] [%s] invalid decryption key length: %lu (should be 32 or 97 bytes)",  v168,  v169,  v170,  v171,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
        -[NSData length](v124, "length");
        v142 = v194;
        v157 = MAErrorForDownloadResultWithUnderlying( 0x17uLL,  0LL,  @"[%s:%d] [%s] invalid decryption key length: %lu (should be 32 or 97 bytes)",  v172,  v173,  v174,  v175,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
LABEL_74:
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v157);

        goto LABEL_75;
      }

      _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"[%s:%d] [%s] Failed to allocate AEAExtractor/STRemoteExtractor",  v55,  v56,  v57,  v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
      id v77 = MAErrorForDownloadResultWithUnderlying( 0x10uLL,  0LL,  @"[%s:%d] [%s] failed to allocate AEAExtractor/STRemoteExtractor",  v72,  v73,  v74,  v75,  v76,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
    }

    else
    {
      _MobileAssetLog( (uint64_t)v46,  3,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Unknown asset format:%@",  v42,  v43,  v44,  v45,  (uint64_t)v18);
      id v77 = MAErrorForDownloadResultWithUnderlying( 0x10uLL,  0LL,  @"[%s:%d] [%s] Unknown asset format:%@",  v78,  v79,  v80,  v81,  v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileAssetBrain/ControlManager.m");
    }

    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v77);
    v41 = 0LL;
    if (!a6) {
      goto LABEL_82;
    }
    goto LABEL_80;
  }

  v195 = v18;
  id v23 = v13;
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Creating asset extractor for streaming zip asset",  v19,  v20,  v21,  v22,  v185);
  id v24 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKey:@"_Measurement"]);
  id v25 = (void *)objc_claimAutoreleasedReturnValue(-[ControlManager hashToString:](self, "hashToString:", v24));

  id v26 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKey:@"_DownloadSize"]);
  char v27 = [v26 unsignedLongLongValue];

  uint64_t v28 = objc_claimAutoreleasedReturnValue([v10 objectForKey:@"_StartOfDataRange"]);
  unsigned int v33 = objc_claimAutoreleasedReturnValue([v10 objectForKey:@"_LengthOfDataRange"]);
  if (v28 | v33)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager newExtractor:downloadOptions:sessionID:error:]",  @"Asset metadata specifies a range for download but extractor not set up for it",  v29,  v30,  v31,  v32,  v186);
    id v39 = MAErrorForDownloadResultWithUnderlying( 0x10uLL,  0LL,  @"Asset metadata specifies a range for download but extractor not set up for it",  v34,  v35,  v36,  v37,  v38,  v187);
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
    v41 = 0LL;
  }

  else
  {
    v193 = a6;
    v202[0] = SZExtractorHashTypeSHA1;
    v201[0] = SZExtractorOptionsHashType;
    v201[1] = SZExtractorOptionsHashesArray;
    v200 = v25;
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v200, 1LL));
    v202[1] = v59;
    v202[2] = &__kCFBooleanTrue;
    v201[2] = SZExtractorOptionsDenyInvalidSymlinks;
    v201[3] = SZExtractorOptionsHashedChunkSize;
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v27));
    v202[3] = v60;
    v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v202,  v201,  4LL));

    v62 = [[SZExtractor alloc] initWithOptions:v61];
    id v63 = v62;
    if (v17) {
      [v62 setPrivileged:1];
    }
    v41 = v63;

    uint64_t v40 = 0LL;
    a6 = v193;
  }

  uint64_t v13 = v23;
  uint64_t v18 = v195;
  if (a6)
  {
LABEL_80:
    if (v40) {
      *a6 = v40;
    }
  }

      a3 = sub_237300((uint64_t)a3);
      goto LABEL_13;
    }

LABEL_5:
  id v9 = @"EmptyHaveAvailable";
LABEL_6:
  id v10 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
  uint64_t v11 = objc_alloc(&OBJC_CLASS___MADAutoAssetStagerParam);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
  uint64_t v13 = -[MADAutoAssetStagerParam initWithSafeSummary:](v11, "initWithSafeSummary:", v12);
  [v10 followupEvent:v9 withInfo:v13];

  return 0LL;
}

  id v6 = 0LL;
LABEL_15:

  return v7;
}

  *a3 = result;
  a3[1] = v5;
  return result;
}

  id v10 = v9 + 1;
  if (v9 + 1 < v1)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

  if (v9 >= -1)
  {
    uint64_t v11 = v0[3] & 1 | (2 * v10);
    v0[2] = v10;
    uint64_t v12 = swift_unknownObjectRetain(v7);
    sub_232F8C(v12, v8, v1, v11);
    return;
  }

LABEL_32:
  id v21 = 0LL;
LABEL_33:
  v80 = (void *)objc_claimAutoreleasedReturnValue([v14 clientProcessName]);
  -[MADAutoAssetStager setStagingClientName:](self, "setStagingClientName:", v80);

  if (v17)
  {
    -[MADAutoAssetStager _stagingClientRequestDetermineTrack:trackingRequest:forStagingTargetName:]( self,  "_stagingClientRequestDetermineTrack:trackingRequest:forStagingTargetName:",  v95,  v96,  v21);
  }

  else if (v19)
  {
    -[MADAutoAssetStager _stagingClientRequestDownloadTrack:trackingRequest:forStagingTargetName:]( self,  "_stagingClientRequestDownloadTrack:trackingRequest:forStagingTargetName:",  v95,  v96,  v21);
  }

  else
  {
    -[MADAutoAssetStager _stagingClientRequestGeneralTrack:trackingRequest:]( self,  "_stagingClientRequestGeneralTrack:trackingRequest:",  v95,  v96);
  }

        uint64_t v65 = v22;
LABEL_33:

        id v22 = v65;
        id v25 = v43;
        goto LABEL_34;
      }
    }

    v79 = v16;
    loga = v42;
    -[NSMutableArray addObject:](v41, "addObject:", v42);
    uint64_t v58 = objc_alloc(&OBJC_CLASS___MADAutoSetConfiguration);
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v22 clientDomainName]);
    uint64_t v60 = v13;
    v61 = v12;
    v62 = (void *)objc_claimAutoreleasedReturnValue([v22 autoAssetSetClientName]);
    id v63 = (void *)objc_claimAutoreleasedReturnValue([v22 assetSetIdentifier]);
    LOWORD(v76) = 257;
    uint64_t v64 = v58;
    uint64_t v43 = (os_log_s *)v41;
    uint64_t v65 = -[MADAutoSetConfiguration initForClientDomainName:forSetClientName:forAssetSetIdentifier:withAutoAssetEntries:withLatestAtomicInstanceToVend:inhibitingImpliedScheduling:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:]( v64,  "initForClientDomainName:forSetClientName:forAssetSetIdentifier:withAutoAssetEntries:withLatestAtomicInstance ToVend:inhibitingImpliedScheduling:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:",  v59,  v62,  v63,  v41,  0LL,  1LL,  v76);

    uint64_t v66 = v61;
    uint64_t v67 = v61;
    uint64_t v13 = v60;
    [v67 setSafeObject:v65 forKey:v14];
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
    uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue([v68 oslog]);

    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
      uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v65 summary]);
      id v72 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](loga, "summary"));
      *(_DWORD *)buf = 138544130;
      __int128 v87 = v70;
      __int128 v88 = 2114;
      __int128 v89 = v60;
      v90 = 2114;
      v91 = v71;
      v92 = 2114;
      v93 = v72;
      _os_log_impl( &dword_0,  v69,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {_extendLookupByAssetType} [%{public}@] extended set-configuration for staging | setConfiguration: %{public}@ | assetSetEntry:%{public}@",  buf,  0x2Au);
    }

    uint64_t v12 = v66;
    int v16 = v79;
    int v19 = v84;
    goto LABEL_33;
  }

  id v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v24 oslog]);

  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    id v26 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
    char v27 = v25;
    uint64_t v28 = (void *)v26;
    uint64_t v29 = v19;
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v22 summary]);
    *(_DWORD *)buf = 138544386;
    __int128 v87 = v28;
    __int128 v88 = 2114;
    __int128 v89 = v13;
    v90 = 2114;
    v91 = v30;
    v92 = 2114;
    v93 = v14;
    v94 = 2114;
    v95 = v15;
    _os_log_impl( &dword_0,  v27,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {_extendLookupByAssetType} [%{public}@] asset-selector already tracked as candidate | setConfigurati on:%{public}@ | assetType:%{public}@ | assetSpecifier:%{public}@",  buf,  0x34u);

    int v19 = v29;
    id v25 = v27;
  }

      objc_autoreleasePoolPop(v35);
      v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager availableForStaging](v2, "availableForStaging"));
      unsigned __int8 v49 = v48;
      if ((v34 & 0x8000000000000000LL) == 0) {
        break;
      }
      ++v33;
      v50 = [v48 count];
    }

    [v48 removeObjectAtIndex:v34];

    v51 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](v2, "persistedState"));
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 persistedConfig]);
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager availableForStaging](v2, "availableForStaging"));
    objc_msgSend( v52,  "persistULL:forKey:shouldPersist:",  objc_msgSend(v53, "count"),  @"determinedAvailableAssetCount",  1);
  }

  [*(id *)(v1 + 32) _logPersistedTableOfContents:@"resumeFromPersistedWithDownloadedSelectors"];
  uint64_t v43 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager selectDispatchQueue:]( &OBJC_CLASS___MADAutoAssetControlManager,  "selectDispatchQueue:",  0LL));
  dispatch_async(v43, &__block_literal_global_650);
}

            objc_autoreleasePoolPop(v7);
            __int128 v35 = 1;
            goto LABEL_33;
          }
        }
      }

  return 0LL;
}

LABEL_33:
                uint64_t v12 = v67;
LABEL_34:

                uint64_t v15 = v70;
                goto LABEL_35;
              }

              if ((v27 & 1) != 0) {
                goto LABEL_33;
              }
              id v32 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
              unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v19 assetType]);
              __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v19 assetSpecifier]);
              __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v19 assetVersion]);
              uint64_t v29 = (os_log_s *)-[MAAutoAssetSelector initForAssetType:withAssetSpecifier:matchingAssetVersion:]( v32,  "initForAssetType:withAssetSpecifier:matchingAssetVersion:",  v33,  v34,  v35);

              __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s persistedEntryID](v29, "persistedEntryID"));
              __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager locksPriorToSecureHealing](v66, "locksPriorToSecureHealing"));
              id v38 = [v37 safeObjectForKey:v36 ofClass:objc_opt_class(MAAutoAssetLock)];
              id v39 = (void *)objc_claimAutoreleasedReturnValue(v38);

              if (v39)
              {
                uint64_t v64 = v39;
                -[NSMutableDictionary setSafeObject:forKey:](v63, "setSafeObject:forKey:", v19, v24);
                uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v66, "logger"));
                v41 = (os_log_s *)objc_claimAutoreleasedReturnValue([v40 oslog]);

                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v42 = (__CFString *)objc_claimAutoreleasedReturnValue([v19 summary]);
                  *(_DWORD *)buf = 138543362;
                  id v77 = v42;
                  _os_log_impl( &dword_0,  v41,  OS_LOG_TYPE_DEFAULT,  "\n [AUTO-SECURE][AUTO-GRAFT][STARTUP] {DecideNeedPersonalize} will graft|mount (part of locked latest-t o-vend) | downloadedDescriptor:%{public}@",  buf,  0xCu);
                }

                id v39 = v64;
              }
            }

            else
            {
              uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue([v43 oslog]);

              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                if (v26) {
                  uint64_t v44 = @"Y";
                }
                else {
                  uint64_t v44 = @"N";
                }
                if (v27) {
                  uint64_t v45 = @"Y";
                }
                else {
                  uint64_t v45 = @"N";
                }
                uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "summary", v61, v62));
                *(_DWORD *)buf = 138543874;
                id v77 = v44;
                v78 = 2114;
                v79 = v45;
                v80 = 2114;
                v81 = v46;
                _os_log_impl( &dword_0,  v29,  OS_LOG_TYPE_DEFAULT,  "\n [AUTO-SECURE][AUTO-PERSONALIZATION][STARTUP] {DecideNeedPersonalize} secure not part of latest-to-vend yet managed as set (not considering for secure-healing) | personalizationRequired:%{public}@ | grafte dOrMounted:%{public}@ | downloadedDescriptor:%{public}@",  buf,  0x20u);
              }
            }

            self = v66;
            goto LABEL_32;
          }

          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          int v19 = (void *)objc_claimAutoreleasedReturnValue([v31 oslog]);

          if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            id v77 = v14;
            _os_log_error_impl( &dword_0,  (os_log_t)v19,  OS_LOG_TYPE_ERROR,  "\n [AUTO-SECURE][AUTO-PERSONALIZATION][STARTUP] {DecideNeedPersonalize} unable to determine previous status | entryID:%{public}@",  buf,  0xCu);
          }

        objc_autoreleasePoolPop(v38);
        __int128 v36 = (char *)v36 + 1;
      }

      while (obja != v36);
      obja = [v89 countByEnumeratingWithState:&v98 objects:v107 count:16];
    }

    while (obja);
  }

  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  objb = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager activeSetDescriptorsByInstance](self, "activeSetDescriptorsByInstance"));
  v61 = [objb countByEnumeratingWithState:&v94 objects:v106 count:16];
  if (v61)
  {
    v62 = v61;
    id v63 = *(void *)v95;
    do
    {
      uint64_t v64 = 0LL;
      do
      {
        if (*(void *)v95 != v63) {
          objc_enumerationMutation(objb);
        }
        uint64_t v65 = *(void *)(*((void *)&v94 + 1) + 8LL * (void)v64);
        uint64_t v66 = objc_autoreleasePoolPush();
        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager activeSetDescriptorsByInstance]( self,  "activeSetDescriptorsByInstance"));
        uint64_t v68 = [v67 safeObjectForKey:v65 ofClass:objc_opt_class(MADAutoSetDescriptor)];
        uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(v68);

        if (v69)
        {
          uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v69 clientDomainName]);
          uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v69 assetSetIdentifier]);
          id v72 = -[MADAutoAssetControlManager newSetEntryIDForClientDomain:forAssetSetIdentifier:]( self,  "newSetEntryIDForClientDomain:forAssetSetIdentifier:",  v70,  v71);

          v73 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v93,  "safeObjectForKey:ofClass:",  v72,  objc_opt_class(&OBJC_CLASS___MANAutoAssetSetOverview));
          uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(v73);
          id v75 = v74;
          if (v74) {
            [v74 setDiscoveredAtomicInstance:v65];
          }
        }

        objc_autoreleasePoolPop(v66);
        uint64_t v64 = (char *)v64 + 1;
      }

      while (v62 != v64);
      v62 = [objb countByEnumeratingWithState:&v94 objects:v106 count:16];
    }

    while (v62);
  }

  id v76 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v77 = +[MASAutoAssetSetOverview newShimmedArrayToFramework:]( &OBJC_CLASS___MASAutoAssetSetOverview,  "newShimmedArrayToFramework:",  v87);
  -[NSMutableDictionary setSafeObject:forKey:](v76, "setSafeObject:forKey:", v77, @"setOverview");

  v78 = objc_alloc(&OBJC_CLASS___SUCoreConnectMessage);
  v79 = (void *)objc_claimAutoreleasedReturnValue([v86 clientRequestMessage]);
  v80 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager replyMessageNameForRequest:]( &OBJC_CLASS___MADAutoAssetControlManager,  "replyMessageNameForRequest:",  v79));
  v81 = (void *)objc_claimAutoreleasedReturnValue([v86 clientRequestMessage]);
  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v81 clientID]);
  id v83 = -[SUCoreConnectMessage initWithType:messageName:clientID:version:message:]( v78,  "initWithType:messageName:clientID:version:message:",  2LL,  v80,  v82,  0LL,  v76);

  -[MADAutoAssetControlManager issueBuiltResponseForEventInfo:issuingResponseMessage:withResponseError:fromLocation:]( self,  "issueBuiltResponseForEventInfo:issuingResponseMessage:withResponseError:fromLocation:",  v86,  v83,  0LL,  @"handleSetControlClientAssetSetsOverviewRequest");
}

            goto LABEL_33;
          }

          if (-[os_log_s isBlankEntry](v15, "isBlankEntry"))
          {
            id v17 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v17 oslog]);

            if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_32;
            }
            int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543618;
            uint64_t v54 = v19;
            uint64_t v55 = 2114;
            v56 = v10;
            id v20 = v18;
            id v21 = "[%{public}@] {loadPersistedDescriptors} encountered blank auto-asset-descriptor | entryID:%{public}@";
            goto LABEL_22;
          }

          id v24 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s metadata](v16, "metadata"));

          if (!v24)
          {
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v29 oslog]);

            if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_32;
            }
            int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543618;
            uint64_t v54 = v19;
            uint64_t v55 = 2114;
            v56 = v10;
            id v20 = v18;
            id v21 = "[%{public}@] {loadPersistedDescriptors} encountered auto-asset-descriptor with metadata=nil | entryID:%{public}@";
LABEL_22:
            _os_log_impl(&dword_0, v20, OS_LOG_TYPE_DEFAULT, v21, buf, 0x16u);
LABEL_23:

            goto LABEL_32;
          }

          if (-[os_log_s isOnFilesystem](v16, "isOnFilesystem"))
          {
            id v25 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
            id v26 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s assetType](v16, "assetType"));
            char v27 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s assetSpecifier](v16, "assetSpecifier"));
            uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s assetVersion](v16, "assetVersion"));
            uint64_t v18 = (os_log_s *)-[MAAutoAssetSelector initForAssetType:withAssetSpecifier:matchingAssetVersion:]( v25,  "initForAssetType:withAssetSpecifier:matchingAssetVersion:",  v26,  v27,  v28);

            if (-[MADAutoAssetControlManager jobDescriptorOnFilesystemValidated:]( self,  "jobDescriptorOnFilesystemValidated:",  v16))
            {
              -[MADAutoAssetControlManager _statsIncrementPreviouslyDownloadedForDescriptor:]( self,  "_statsIncrementPreviouslyDownloadedForDescriptor:",  v16);
              -[MADAutoAssetControlManager trackDescriptor:persisting:fromLocation:changedWhileTerminated:changedNeverBeenLocked:historyOperation:firstClientName:]( self,  "trackDescriptor:persisting:fromLocation:changedWhileTerminated:changedNeverBeenLocked:historyOperation:firstClientName:",  v16,  0LL,  @"loadPersistedDescriptors",  0LL,  0LL,  0LL,  0LL);
              -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAsset Descriptor:baseForPatchDescriptor:message:",  @"loadPersistedDescriptors",  @"DOWNLOADED_DESCRIPTORS",  @"ENTRY_LOAD",  v10,  0LL,  0LL,  v16,  0LL,  @"content on filesystem validated");
            }

            else
            {
              __int128 v36 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager descriptorsDroppedOnStartup]( self,  "descriptorsDroppedOnStartup"));
              [v36 addObject:v16];

              __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownDescriptors](self, "persistedKnownDescriptors"));
              [v37 removePersistedEntry:v10 fromLocation:@"loadPersistedDescriptors"];

              -[MADAutoAssetControlManager _logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:]( self,  "_logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:",  @"loadPersistedDescriptors",  @"INVALID_DESCRIPTORS",  v10,  v16,  @"stale descriptor (filesystem content did not validate)");
              id v38 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s assetId](v16, "assetId"));
              +[MADAutoAssetHistory recordOperation:toHistoryType:fromLayer:forAssetID:withSelector:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromLayer:forAssetID:withSelector:",  401LL,  0LL,  1LL,  v38,  v18);
            }

            id v8 = v46;
            goto LABEL_32;
          }

          if (-[MADAutoAssetControlManager jobDescriptorInFlightNowOnFilesystem:]( self,  "jobDescriptorInFlightNowOnFilesystem:",  v16))
          {
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v16, "summary"));
              *(_DWORD *)buf = 138543874;
              uint64_t v54 = v32;
              uint64_t v55 = 2114;
              v56 = v10;
              uint64_t v57 = 2114;
              uint64_t v58 = v33;
              _os_log_impl( &dword_0,  v31,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {loadPersistedDescriptors} previously in-flight now on filesystem validated | entryID:%{pub lic}@, adoptedDescriptor:%{public}@",  buf,  0x20u);

              id v8 = v46;
            }

            -[MADAutoAssetControlManager _statsIncrementPreviouslyDownloadedForDescriptor:]( self,  "_statsIncrementPreviouslyDownloadedForDescriptor:",  v16);
            -[os_log_s setIsOnFilesystem:](v16, "setIsOnFilesystem:", 1LL);
            __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s metadata](v16, "metadata"));
            __int128 v35 = [v34 safeIntegerForKey:@"_UnarchivedSize"];

            if ((uint64_t)v35 >= 1)
            {
              -[os_log_s setDownloadedNetworkBytes:](v16, "setDownloadedNetworkBytes:", v35);
              -[os_log_s setDownloadedFilesystemBytes:](v16, "setDownloadedFilesystemBytes:", v35);
            }

            -[MADAutoAssetControlManager trackDescriptor:persisting:fromLocation:changedWhileTerminated:changedNeverBeenLocked:historyOperation:firstClientName:]( self,  "trackDescriptor:persisting:fromLocation:changedWhileTerminated:changedNeverBeenLocked:historyOperation:firstClientName:",  v16,  1LL,  @"loadPersistedDescriptors",  1LL,  0LL,  0LL,  0LL);
            -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDe scriptor:baseForPatchDescriptor:message:",  @"loadPersistedDescriptors",  @"DOWNLOADED_DESCRIPTORS",  @"ENTRY_LOAD",  v10,  0LL,  0LL,  v16,  0LL,  @"previously in-flight now on filesystem validated");
          }

          else
          {
            id v39 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s assetId](v16, "assetId"));

            if (v39)
            {
              -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAsset Descriptor:baseForPatchDescriptor:message:",  @"loadPersistedDescriptors",  @"JOB_DESCRIPTORS",  @"ENTRY_LOAD",  v10,  0LL,  0LL,  v16,  0LL,  @"previously in-flight not on filesystem (will resume once active)");
            }

            else
            {
              uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownDescriptors](self, "persistedKnownDescriptors"));
              [v40 removePersistedEntry:v10 fromLocation:@"loadPersistedDescriptors"];

              v41 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager descriptorsDroppedOnStartup]( self,  "descriptorsDroppedOnStartup"));
              [v41 addObject:v16];

              -[MADAutoAssetControlManager _logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:]( self,  "_logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:",  @"loadPersistedDescriptors",  @"JOB_DESCRIPTORS",  v10,  v16,  @"not adopting previous job (since not representing dowloaded or downloading content)");
            }
          }

      objc_autoreleasePoolPop(v19);
      id v17 = (char *)v17 + 1;
    }

    while (v17 != v15);
    uint64_t v15 = [v13 countByEnumeratingWithState:&v63 objects:v73 count:16];
  }

  while (v15);
LABEL_34:

LABEL_35:
  uint64_t v57 = 0u;
  uint64_t v58 = 0u;
  uint64_t v55 = 0u;
  v56 = 0u;
  __int128 v34 = v50;
  __int128 v35 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v55,  v67,  16LL);
  if (v35)
  {
    __int128 v36 = v35;
    uint64_t v53 = *(void *)v56;
    do
    {
      for (j = 0LL; j != v36; j = (char *)j + 1)
      {
        if (*(void *)v56 != v53) {
          objc_enumerationMutation(v34);
        }
        id v38 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v34,  "safeObjectForKey:ofClass:",  *(void *)(*((void *)&v55 + 1) + 8LL * (void)j),  objc_opt_class(&OBJC_CLASS___MADAutoSetDescriptor));
        id v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
        if (v39)
        {
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          v41 = (void *)objc_claimAutoreleasedReturnValue([v39 clientDomainName]);
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v39 assetSetIdentifier]);
          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v39 latestDownloadedAtomicInstance]);
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( +[MANAutoAssetSetStatus shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:]( &OBJC_CLASS___MANAutoAssetSetStatus,  "shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:",  v41,  v42,  v43));

          uint64_t v45 =  -[MADAutoAssetControlManager _shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:]( self,  "_shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:",  @"loadPersistedCrossCheckTrimAtomicInstances",  v44,  v40,  @"atomic-instance shared lock directory (eliminated set-identifier)");
          uint64_t v46 =  +[MADAutoAssetLocker eliminateAllPreviousSetLocksByClient:forSetDescriptor:]( &OBJC_CLASS___MADAutoAssetLocker,  "eliminateAllPreviousSetLocksByClient:forSetDescriptor:",  @"ALL_INSTANCES",  v39);
          -[MADAutoAssetControlManager secureCheckUngraftAll:forSetDescriptorNoLongerLocked:]( self,  "secureCheckUngraftAll:forSetDescriptorNoLongerLocked:",  @"loadPersistedCrossCheckTrimAtomicInstances",  v39);
          v47 = (void *)objc_claimAutoreleasedReturnValue([v39 latestDownloadedAtomicInstance]);
          -[MADAutoAssetControlManager atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:]( self,  "atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:",  v54,  v47,  @"incomplete set-descriptor atomic-instance",  338LL);

          -[MADAutoAssetControlManager removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:]( self,  "removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:",  v39,  v54,  0LL,  1LL,  338LL,  381LL);
        }
      }

      __int128 v36 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v55,  v67,  16LL);
    }

    while (v36);
  }

  id v4 = v48;
LABEL_45:
  -[MADAutoAssetControlManager setDescriptorsDroppedOnStartup:](self, "setDescriptorsDroppedOnStartup:", 0LL);
}

              -[NSMutableArray addObject:](v60, "addObject:", v24);
            }

            else
            {
              uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              {
                uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                *(_DWORD *)buf = 138543874;
                uint64_t v74 = v40;
                id v75 = 2114;
                id v76 = v10;
                id v77 = 2114;
                v78 = v18;
                _os_log_error_impl( &dword_0,  v31,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [CONSIDER-REMOVAL] {%{public}@} unable to load auto-asset-descriptor | entryID:%{public}@",  buf,  0x20u);
              }
            }

            uint64_t v13 = v61;
            goto LABEL_34;
          }

          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          id v24 = (void *)objc_claimAutoreleasedReturnValue([v28 oslog]);

          if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_ERROR))
          {
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543874;
            uint64_t v74 = v29;
            id v75 = 2114;
            id v76 = v10;
            id v77 = 2114;
            v78 = v18;
            _os_log_error_impl( &dword_0,  (os_log_t)v24,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n[CONSIDER-REMOVAL] {%{public}@} unable to determine previous status | entryID:%{public}@",  buf,  0x20u);
            goto LABEL_30;
          }

LABEL_33:
      objc_autoreleasePoolPop(v8);
    }

    v47 = [obj countByEnumeratingWithState:&v55 objects:v62 count:16];
  }

  while (v47);

  if ((v42 & 1) != 0) {
    goto LABEL_38;
  }
  id v39 = 0LL;
LABEL_39:
  uint64_t v40 = v39;

  return v40;
}
}

  return v59;
}

  [*(id *)(v1 + 32) _logPersistedTableOfContents:@"resumeFromPersistedWithDownloadedSelectors"];
  uint64_t v44 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager selectDispatchQueue:]( &OBJC_CLASS___MADAutoAssetControlManager,  "selectDispatchQueue:",  0LL));
  dispatch_async(v44, &__block_literal_global_733);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  swift_unknownObjectRelease(v18);
  uint64_t v13 = 0;
  return v13 & 1;
}

LABEL_16:
}

  return v16;
}

    uint64_t v42 = v8;
    __int128 v34 = -[SecureMobileAssetBundle mount:](v7, "mount:", &v42);
    __int128 v35 = v42;

    goto LABEL_17;
  }

  objc_sync_exit(v7);

  __int128 v34 = 0;
  if (!a3) {
    goto LABEL_21;
  }
LABEL_19:
  if (v8) {
    *a3 = v8;
  }
LABEL_21:

  return v34;
}

LABEL_19:
  return v10;
}

      id v17 = @"locked(blocked unless emergency)";
      goto LABEL_17;
    }
  }

  uint64_t v18 = v12;
LABEL_18:

  objc_autoreleasePoolPop(v10);
  if (!v18) {
    goto LABEL_20;
  }
  id v21 = 0;
LABEL_36:
  if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL))
  {
    if ((v21 & 1) != 0) {
      goto LABEL_47;
    }
  }

  else
  {
    +[MADAutoAssetStager garbageCollectEliminateSelector:]( &OBJC_CLASS___MADAutoAssetStager,  "garbageCollectEliminateSelector:",  *(void *)(a1 + 48));
    if ((v21 & 1) != 0) {
      goto LABEL_47;
    }
  }

  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL))
  {
    [*(id *)(a1 + 32) secureForceUngraft:@"assetBeingGarbageCollected" forDescriptorBeingRemoved:v18];
    if ([v18 secureOperationEliminating])
    {
      uint64_t v42 = *(void *)(*(void *)(a1 + 56) + 8LL);
      uint64_t v43 = *(void **)(v42 + 40);
      *(void *)(v42 + 40) = @"elimination triggered while ungrafting";

      [*(id *)(a1 + 32) eliminateUngraftDescriptor:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) forAutoAssetDescriptor:v18 failingClientRequestForEventInfo:0];
    }

    else
    {
      +[MADAutoAssetLocker forceGlobalUnlock:]( &OBJC_CLASS___MADAutoAssetLocker,  "forceGlobalUnlock:",  *(void *)(a1 + 48));
      if (v13) {
        uint64_t v44 = 406LL;
      }
      else {
        uint64_t v44 = 405LL;
      }
      objc_msgSend( *(id *)(a1 + 32),  "_removeDescriptorFromFilesystem:droppingDescriptor:forHistoryOperation:firstClientName:",  @"assetBeingGarbageCollected",  v18,  v44,  0,  (void)v50);
    }
  }

              continue;
            }

            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

            if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_16;
            }
            id v26 = (NSString *)objc_claimAutoreleasedReturnValue([v12 summary]);
            *(_DWORD *)buf = 138543362;
            v56 = v26;
            char v27 = v25;
            uint64_t v28 = "\n"
                  "[AUTO-SECURE][AUTO-PERSONALIZATION][STARTUP] {PersonalizeSuccessDecideMore} pre-personalization SUCCES"
                  "S (not locked) | nextPrePersonalizedDescriptor:%{public}@";
LABEL_14:
            _os_log_impl(&dword_0, v27, OS_LOG_TYPE_DEFAULT, v28, buf, 0xCu);
          }

          else
          {
            uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
            id v21 = (void *)objc_claimAutoreleasedReturnValue([v18 diag]);
            uint64_t v29 = objc_alloc(&OBJC_CLASS___NSString);
            id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue([v12 summary]);
            id v26 = -[NSString initWithFormat:]( v29,  "initWithFormat:",  @"{PersonalizeSuccessDecideMore} | unable to initialize asset-selector | nextPrePersonalizedDescriptor:%@",  v25);
            [v21 trackAnomaly:@"AUTO-CONTROL" forReason:v26 withResult:6110 withError:0];
          }

          goto LABEL_16;
        }
      }

      id v9 = [obj countByEnumeratingWithState:&v51 objects:v57 count:16];
    }

    while (v9);
  }

  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager descriptorsRequiringPersonalization]( self,  "descriptorsRequiringPersonalization"));
  id v32 = [v31 count];

  if (v32)
  {
    unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
    __int128 v34 = v33;
    __int128 v35 = @"HaveNeedingPersonalize";
  }

  else
  {
    __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager descriptorsRequiringGrafting](self, "descriptorsRequiringGrafting"));
    __int128 v37 = [v36 count];

    if (v37)
    {
      id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager prePersonalizedSelectors](self, "prePersonalizedSelectors"));
      id v39 = [v38 count];

      if (v39)
      {
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager prePersonalizedSelectors](self, "prePersonalizedSelectors"));
        v41 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetSecure commitPrePersonalizedSync:committingSelectors:]( &OBJC_CLASS___MADAutoAssetSecure,  "commitPrePersonalizedSync:committingSelectors:",  @"DecideNeedPersonalize",  v40));

        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

        if (v41)
        {
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            -[MADAutoAssetControlManager action_PersonalizeSuccessDecideMore:error:].cold.1();
          }
        }

        else
        {
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager prePersonalizedSelectors](self, "prePersonalizedSelectors"));
            uint64_t v45 = (NSString *)[v44 count];
            *(_DWORD *)buf = 134217984;
            v56 = v45;
            _os_log_impl( &dword_0,  v43,  OS_LOG_TYPE_DEFAULT,  "\n [SECURE][AUTO-PERSONALIZATION-COMMIT][STARTUP] {PersonalizeSuccessDecideMore} | commit pre-personalized as set-selectors SUCCESS | prePersonalizedSelectors:%ld",  buf,  0xCu);
          }

          -[MADAutoAssetControlManager setConfigurationsPrePersonalizedJustCommitted:]( self,  "setConfigurationsPrePersonalizedJustCommitted:",  @"PersonalizeSuccessDecideMore[NO-GRAFTING]");
        }

        uint64_t v46 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        -[MADAutoAssetControlManager setPrePersonalizedSelectors:](self, "setPrePersonalizedSelectors:", v46);
      }

      unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
      __int128 v34 = v33;
      __int128 v35 = @"HaveNeedingGraft";
    }

    else
    {
      unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
      __int128 v34 = v33;
      __int128 v35 = @"NoneNeedingPersonalize";
    }
  }

  [v33 postEvent:v35 withInfo:v48];

  return 0LL;
}

        objc_autoreleasePoolPop(v19);
        self = v71;
      }

      uint64_t v15 = [obj countByEnumeratingWithState:&v76 objects:v91 count:16];
    }

    while (v15);
  }

  uint64_t v74 = 0u;
  id v75 = 0u;
  id v72 = 0u;
  v73 = 0u;
  v62 = v67;
  uint64_t v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v62,  "countByEnumeratingWithState:objects:count:",  &v72,  v80,  16LL);
  id v32 = v63;
  if (v31)
  {
    unsigned int v33 = v31;
    __int128 v34 = *(void *)v73;
    do
    {
      __int128 v35 = 0LL;
      v61 = v33;
      do
      {
        if (*(void *)v73 != v34) {
          objc_enumerationMutation(v62);
        }
        __int128 v36 = *(id *)(*((void *)&v72 + 1) + 8LL * (void)v35);
        __int128 v37 = objc_autoreleasePoolPush();
        id v38 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetAtomicInstancesByInstance]( self,  "knownSetAtomicInstancesByInstance"));
        id v39 = [v38 safeObjectForKey:v36 ofClass:objc_opt_class(MADAutoSetAtomicInstance)];
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);

        if (v40)
        {
          obja = v36;
          v41 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceNewEntryIDForSetAtomicInstance:]( self,  "atomicInstanceNewEntryIDForSetAtomicInstance:",  v40));
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( self,  "persistedKnownSetAtomicInstances"));
          uint64_t v43 = objc_claimAutoreleasedReturnValue([v42 persistedEntry:v41 fromLocation:v32]);

          uint64_t v68 = (void *)v43;
          if (v43)
          {
            -[MADAutoAssetControlManager _clearAtomicInstanceFromLatestToVend:fromLocation:]( self,  "_clearAtomicInstanceFromLatestToVend:fromLocation:",  v40,  v32);
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( self,  "persistedKnownSetAtomicInstances"));
            [v44 removePersistedEntry:v41 fromLocation:v32];

            uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v40 instanceEntries]);
            uint64_t v46 = v41;
            v47 = v37;
            v48 = v34;
            unsigned __int8 v49 = [v45 count];
            v50 = (void *)objc_claimAutoreleasedReturnValue([v40 clientDomainName]);
            v51 = (void *)objc_claimAutoreleasedReturnValue([v40 assetSetIdentifier]);
            uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v40 atomicInstanceUUID]);
            uint64_t v53 = v49;
            __int128 v34 = v48;
            __int128 v37 = v47;
            v41 = v46;
            +[MADAutoAssetHistory recordOperation:toHistoryType:fromLayer:usageCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromLayer:usageCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:",  a6,  2LL,  1LL,  v53,  v50,  v51,  v52);

            id v32 = v63;
            self = v71;

            unsigned int v33 = v61;
            uint64_t v54 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"removed set-atomic-instance | removalReason:%@",  v64);
            -[MADAutoAssetControlManager _logPersistedSetAtomicInstanceRemoved:removedPersistedEntryID:removedSetAtomicInstance:message:]( v71,  "_logPersistedSetAtomicInstanceRemoved:removedPersistedEntryID:removedSetAtomicInstance:message:",  v63,  v41,  v40,  v54);
          }

          else
          {
            uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v54 = (NSString *)objc_claimAutoreleasedReturnValue([v55 oslog]);

            if (os_log_type_enabled((os_log_t)v54, OS_LOG_TYPE_ERROR))
            {
              uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              uint64_t v57 = objc_claimAutoreleasedReturnValue([v40 summary]);
              *(_DWORD *)buf = 138544130;
              uint64_t v82 = v65;
              id v83 = 2114;
              id v84 = v32;
              id v85 = 2114;
              __int128 v86 = v64;
              __int128 v87 = 2114;
              __int128 v88 = v57;
              uint64_t v58 = (void *)v57;
              _os_log_error_impl( &dword_0,  (os_log_t)v54,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [CONSIDER-REMOVAL] (%{public}@) {%{public}@} unable to load persisted-set-atomic-instance file | nextRem oveSetInstance:%{public}@",  buf,  0x2Au);
            }
          }

          __int128 v36 = obja;
        }

        v56 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager knownSetAtomicInstancesByInstance]( self,  "knownSetAtomicInstancesByInstance"));
        [v56 removeObjectForKey:v36];

        objc_autoreleasePoolPop(v37);
        __int128 v35 = (char *)v35 + 1;
      }

      while (v33 != v35);
      unsigned int v33 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v62,  "countByEnumeratingWithState:objects:count:",  &v72,  v80,  16LL);
    }

    while (v33);
  }
}
          }

          goto LABEL_18;
        }

        id v22 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v22 oslog]);

        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR))
        {
          id v23 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          *(_DWORD *)buf = 138543618;
          uint64_t v46 = v23;
          v47 = 2114;
          v48 = v10;
          _os_log_error_impl( &dword_0,  (os_log_t)v15,  OS_LOG_TYPE_ERROR,  "[%{public}@] {_removeFromPersistedActiveJobs} unable to determine previous status | entryID:%{public}@",  buf,  0x16u);
        }
}

            goto LABEL_17;
          }

          if ([v17 isOnFilesystem]
            && [v17 foundAsPreInstalled])
          {
            -[NSMutableArray addObject:](v25, "addObject:", v17);
          }
        }

        else
        {
          id v20 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          id v17 = (void *)objc_claimAutoreleasedReturnValue([v20 oslog]);

          if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            id v32 = v11;
            _os_log_error_impl( &dword_0,  (os_log_t)v17,  OS_LOG_TYPE_ERROR,  "[AUTO-PRE-INSTALLED] {_preInstalledAtomicInstanceDescriptors} unable to determine previous status | entryID:%{public}@",  buf,  0xCu);
          }
        }

          memcpy(v11 + 32, (const void *)(v5 + 32), v13);
          goto LABEL_17;
        }

    __break(1u);
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

  if (v8 > v4)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }

  if (v7[0])
  {
    if (v6 == (char *)v7[0])
    {
      v5[2] = v8;
      return (uint64_t)v5;
    }

    goto LABEL_19;
  }

  __break(1u);
  return result;
}

  __break(1u);
LABEL_17:
  __break(1u);
LABEL_18:
  __break(1u);
  return result;
}

    __break(1u);
  }

LABEL_4:
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v11 clientReplyCompletion]);
  if (!v13)
  {
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager autoStagerFSM](self, "autoStagerFSM"));
    int v19 = (void *)objc_claimAutoreleasedReturnValue([v18 diag]);
    [v19 trackAnomaly:@"AUTO-STAGER" forReason:@"{ReplyNothingStaged} intending to reply to staging-client with indication of nothing staged (pending staging-client-request with no reply-completion)" withResult:6111 withError:0];

LABEL_14:
    goto LABEL_15;
  }

  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v11 clientRequestMessage]);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager replyMessageNameForRequest:]( &OBJC_CLASS___MADAutoAssetControlManager,  "replyMessageNameForRequest:",  v14));

  int v16 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v32 = v6;
  if (-[MADAutoAssetStager stagingClientUsingGroups](self, "stagingClientUsingGroups")) {
    id v17 = -[MADAutoAssetStager newStagedInfoWithGroupsSuccessfullyStaged:indicatingHaveStaged:]( self,  "newStagedInfoWithGroupsSuccessfullyStaged:indicatingHaveStaged:",  @"_replyNothingStaged",  0LL);
  }
  else {
    id v17 = [[MAAutoAssetInfoStaged alloc] initWithTotalStagedBytes:0 withAssetsSuccessfullyStaged:0];
  }
  id v20 = v17;
  -[NSMutableDictionary setSafeObject:forKey:](v16, "setSafeObject:forKey:", v17, @"staged");
  id v21 = objc_alloc(&OBJC_CLASS___SUCoreConnectMessage);
  id v22 = (void *)objc_claimAutoreleasedReturnValue([v11 clientID]);
  id v23 = -[SUCoreConnectMessage initWithType:messageName:clientID:version:message:]( v21,  "initWithType:messageName:clientID:version:message:",  2LL,  v15,  v22,  0LL,  v16);

  id v24 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager statisticsClientRepliesSuccess](self, "statisticsClientRepliesSuccess"));
  id v25 = (void *)objc_claimAutoreleasedReturnValue([v11 clientRequestMessage]);
  id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 messageName]);
  [v24 incrementForClientRequestMessage:v26];

  char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue([v27 oslog]);

  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActive](self, "_targetNameActive"));
    *(_DWORD *)buf = 138543874;
    __int128 v34 = v29;
    __int128 v35 = 2114;
    __int128 v36 = v30;
    __int128 v37 = 2114;
    id v38 = v15;
    _os_log_impl( &dword_0,  v28,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [%{public}@] {_replyNothingStaged} [STAGING-CLIENT-REPLY] %{public}@ reply to staging-client (nothing staged)",  buf,  0x20u);
  }

  uint64_t v31 = (void (**)(void, void, void))objc_claimAutoreleasedReturnValue([v11 clientReplyCompletion]);
  ((void (**)(void, SUCoreConnectMessage *, void))v31)[2](v31, v23, 0LL);

  id v6 = v32;
LABEL_15:
}

  CFRelease(ApplePinned);
  if (trust)
  {
    CFRelease(trust);
    trust = 0LL;
  }

      id v25 = v19;
      CFRelease(v13);
      int v19 = v25;
      goto LABEL_5;
    }

    if (!v11)
    {
LABEL_24:
      v263 = v12;
      v56 = MABrainUtilityCopyEcid();
      uint64_t v57 = objc_claimAutoreleasedReturnValue(v56);
      uint64_t v58 = MABrainUtilityCopyChipId();
      uint64_t v59 = objc_claimAutoreleasedReturnValue(v58);
      uint64_t v60 = MABrainUtilityCopyBoardId();
      id v20 = objc_claimAutoreleasedReturnValue(v60);
      v61 = MABrainUtilityCopySecurityDomain();
      v260 = (void *)objc_claimAutoreleasedReturnValue(v61);
      v62 = MABrainUtilityCopyCertificateSecurityMode();
      id v63 = objc_claimAutoreleasedReturnValue(v62);
      uint64_t v64 = MABrainUtilityCopySigningFuse();
      v259 = objc_claimAutoreleasedReturnValue(v64);
      v258 = &__NSDictionary0__struct;
      if (v57 && v59 && v20 && v260 && v63 && v259)
      {
        v325[0] = kAMAuthInstallApParameterECID;
        v325[1] = kAMAuthInstallApParameterChipID;
        v326[0] = v57;
        v326[1] = v59;
        v325[2] = kAMAuthInstallApParameterBoardID;
        v325[3] = kAMAuthInstallApParameterSecurityDomain;
        v326[2] = v20;
        v326[3] = v260;
        v325[4] = kAMAuthInstallApParameterSecurityMode;
        v325[5] = kAMAuthInstallApParameterProductionMode;
        v326[4] = v63;
        v326[5] = v259;
        v258 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v326,  v325,  6LL));
      }

      v255 = v63;
      v256 = v20;
      v254 = v59;
      v257 = v13;
      v324 = 0LL;
      v322 = 0u;
      v323 = 0u;
      v321 = 0u;
      uint64_t v65 = img4_nonce_domain_preroll_nonce(&_img4_nonce_domain_cryptex1_asset, &v321);
      if (v65)
      {
        uint64_t v66 = v65;
        uint64_t v67 = (void *)v57;
        if (v65 != 45)
        {
          v319[0] = NSDebugDescriptionErrorKey;
          id v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to pre-roll the Cryptex1 MobileAssetBrain nonce"));
          v320[0] = v85;
          v319[1] = NSUnderlyingErrorKey;
          __int128 v86 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v66,  0LL));
          v320[1] = v86;
          __int128 v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v320,  v319,  2LL));
          v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  108LL,  v87));

          v262 = 0;
          v264 = 0LL;
          v266 = 0LL;
          v273 = 0LL;
          uint64_t v18 = v67;
          int v19 = (void *)v254;
          goto LABEL_38;
        }

        uint64_t v68 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Cryptex1 nonce management is not available on this host."));
        uint64_t v69 = [v68 UTF8String];
        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v70,  v71,  v72,  v73,  (uint64_t)v69);

        v273 = 0LL;
      }

      else
      {
        uint64_t v67 = (void *)v57;
        uint64_t v74 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Successfully pre-rolled the Cryptex1 MobileAssetBrain nonce."));
        id v75 = [v74 UTF8String];
        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v76,  v77,  v78,  v79,  (uint64_t)v75);

        v80 = objc_alloc(&OBJC_CLASS___NSData);
        v273 = -[NSData initWithBytes:length:](v80, "initWithBytes:length:", (char *)&v321 + 2, HIDWORD(v324));
      }

      v81 = AMAuthInstallApSetParameters(v13, v258);
      if ((_DWORD)v81)
      {
        v317 = NSDebugDescriptionErrorKey;
        uint64_t v82 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallApSetParameters() failed with error %d (%@)",  v81,  AMAuthInstallGetLocalizedStatusString(v13, v81));
        id v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
        v318 = v83;
        id v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v318,  &v317,  1LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v84));

        v262 = 0;
        v264 = 0LL;
        v266 = 0LL;
        uint64_t v18 = v67;
        int v19 = (void *)v254;
        goto LABEL_39;
      }

      v253 = v67;
      if (_cryptex1_product_class_onceToken_0 != -1) {
        dispatch_once(&_cryptex1_product_class_onceToken_0, &__block_literal_global_21);
      }
      __int128 v88 = (id)_cryptex1_product_class_productClass_0;
      v315[0] = kAMAuthInstallTagCryptex1ChipId;
      v315[1] = kAMAuthInstallTagCryptex1Type;
      v316[0] = @"0xFF10";
      v316[1] = &off_38F010;
      v315[2] = kAMAuthInstallTagCryptex1SubType;
      v315[3] = kAMAuthInstallTagCryptex1ProductClass;
      v316[2] = &off_38F028;
      v264 = v88;
      v316[3] = v88;
      v266 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v316,  v315,  4LL));
      __int128 v89 = AMAuthInstallApSoftwareCoprocessorSetParameters(v13, v266);
      if ((_DWORD)v89)
      {
        v313 = NSDebugDescriptionErrorKey;
        v90 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallApSoftwareCoprocessorSetParameters() failed with error %d (%@)",  v89,  AMAuthInstallGetLocalizedStatusString(v13, v89));
        v91 = (void *)objc_claimAutoreleasedReturnValue(v90);
        v314 = v91;
        v92 = &v314;
        v93 = &v313;
LABEL_45:
        v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v92,  v93,  1LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v94));

        v262 = 0;
        goto LABEL_46;
      }

      if (v260)
      {
        v95 = AMAuthInstallSetUpdaterRequestEntry( v13,  kAMAuthInstallTagApSecurityDomain,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"0x%02X",  [v260 intValue]));
        if ((_DWORD)v95)
        {
          v311 = NSDebugDescriptionErrorKey;
          v96 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallSetUpdaterRequestEntry() failed with error %d (%@)",  v95,  AMAuthInstallGetLocalizedStatusString(v13, v95));
          v91 = (void *)objc_claimAutoreleasedReturnValue(v96);
          v312 = v91;
          v92 = &v312;
          v93 = &v311;
          goto LABEL_45;
        }
      }

      v97 = AMAuthInstallUpdaterCryptex1SetInfo(v13, v271, v272, @"MobileAsset Brain", v12, v273, 0LL, &v285);
      if (v285)
      {
        v269 = v285;
        v262 = 0;
        v285 = 0LL;
LABEL_46:
        id v23 = (void *)v259;
        id v21 = v260;
        id v24 = v258;
        uint64_t v18 = v253;
        int v19 = (void *)v254;
        id v22 = (void *)v255;
        if (!v13) {
          goto LABEL_5;
        }
        goto LABEL_4;
      }

      id v21 = v260;
      id v22 = (void *)v255;
      if ((_DWORD)v97)
      {
        v309 = NSDebugDescriptionErrorKey;
        v98 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallUpdaterCryptex1SetInfo() failed with error %d (%@)",  v97,  AMAuthInstallGetLocalizedStatusString(v13, v97));
        v99 = (void *)objc_claimAutoreleasedReturnValue(v98);
        v310 = v99;
        v100 = &v310;
        v101 = &v309;
LABEL_56:
        v102 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v100,  v101,  1LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v102));

        v262 = 0;
        id v24 = v258;
        id v23 = (void *)v259;
        goto LABEL_71;
      }

      v103 = AMAuthInstallUpdaterPersonalize(v13, @"Cryptex1", v272, &v285);
      v104 = v285;
      cf = (CFTypeRef)v103;
      v269 = v285;
      if (v285)
      {
        v285 = 0LL;
        v105 = (void *)objc_claimAutoreleasedReturnValue([v104 domain]);
        if (![v105 isEqualToString:kAMAuthInstallErrorDomain])
        {

          goto LABEL_67;
        }

        v106 = (char *)[v104 code];

        v107 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Proceeding on Tatsu authorization failure because unpersonalized brains are allowed: %@", v269));
        v108 = [v107 UTF8String];
        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v109,  v110,  v111,  v112,  (uint64_t)v108);
      }

      else if (!v103)
      {
        v307 = NSDebugDescriptionErrorKey;
        v121 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallUpdaterPersonalize() failed with error %d (%@)",  0LL,  AMAuthInstallGetLocalizedStatusString(v13, 0LL));
        v99 = (void *)objc_claimAutoreleasedReturnValue(v121);
        v308 = v99;
        v100 = &v308;
        v101 = &v307;
        goto LABEL_56;
      }

      context = objc_autoreleasePoolPush();
      v305[0] = @"MobileAssetTrustCache";
      v305[1] = @"mobileassetbrain_root_hash";
      v306[0] = kAMAuthInstallBuildIdentityCryptex1SystemTrustCacheKey;
      v306[1] = kAMAuthInstallBuildIdentityCryptex1SystemVolumeKey;
      v305[2] = @"MobileAssetBrain.cryptex";
      v306[2] = kAMAuthInstallBuildIdentityCryptex1SystemOSKey;
      v243 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v306,  v305,  3LL));
      v303[0] = @"MobileAssetTrustCache";
      v303[1] = @"mobileassetbrain_root_hash";
      v304[0] = kAMAuthInstallBuildIdentityCryptex1MobileAssetBrainTrustCacheKey;
      v304[1] = kAMAuthInstallBuildIdentityCryptex1MobileAssetBrainVolumeKey;
      v303[2] = @"MobileAssetBrain.cryptex";
      v304[2] = kAMAuthInstallBuildIdentityCryptex1MobileAssetBrainOSKey;
      v250 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v304,  v303,  3LL));
      v284 = 0LL;
      v113 = AMAuthInstallBundleCopyBuildIdentityForVariant(v13, v271, @"MobileAsset Brain", &v284);
      if ((_DWORD)v113)
      {
        v301 = NSDebugDescriptionErrorKey;
        v114 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallBundleCopyBuildIdentityForVariant() failed with error %d (%@)",  v113,  AMAuthInstallGetLocalizedStatusString(v13, v113));
        v115 = (void *)objc_claimAutoreleasedReturnValue(v114);
        v302 = v115;
        v116 = &v302;
        v117 = &v301;
LABEL_65:
        v118 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v116,  v117,  1LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v118));

        objc_autoreleasePoolPop(context);
LABEL_67:
        v262 = 0;
        v119 = v273;
        goto LABEL_68;
      }

      v240 = v284;
      if (!v284)
      {
        v299 = NSDebugDescriptionErrorKey;
        v115 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallBundleCopyBuildIdentityForVariant() returned a NULL buildIdentity"));
        v300 = v115;
        v116 = &v300;
        v117 = &v299;
        goto LABEL_65;
      }

      v239 = (void *)v10;
      v284 = 0LL;
      v280 = 0u;
      v281 = 0u;
      v282 = 0u;
      v283 = 0u;
      v122 = v250;
      v245 = [v122 countByEnumeratingWithState:&v280 objects:v298 count:16];
      v242 = v122;
      v123 = 0LL;
      if (v245)
      {
        v244 = *(void *)v281;
        while (2)
        {
          v124 = 0LL;
          do
          {
            if (*(void *)v281 != v244)
            {
              v125 = v124;
              objc_enumerationMutation(v122);
              v124 = v125;
            }

            v126 = v124;
            v127 = *(void *)(*((void *)&v280 + 1) + 8 * v124);
            v251 = objc_autoreleasePoolPush();
            v128 = (void *)objc_claimAutoreleasedReturnValue([v240 objectForKeyedSubscript:@"Manifest"]);
            v129 = (void *)objc_claimAutoreleasedReturnValue([v122 objectForKeyedSubscript:v127]);
            v130 = objc_claimAutoreleasedReturnValue([v128 objectForKeyedSubscript:v129]);

            v131 = (void *)v130;
            if (!v130)
            {
              v132 = (void *)objc_claimAutoreleasedReturnValue([v240 objectForKeyedSubscript:@"Manifest"]);
              v133 = (void *)objc_claimAutoreleasedReturnValue([v243 objectForKeyedSubscript:v127]);
              v134 = objc_claimAutoreleasedReturnValue([v132 objectForKeyedSubscript:v133]);

              v131 = (void *)v134;
              if (!v134)
              {
                v296 = NSDebugDescriptionErrorKey;
                v177 = (void *)objc_claimAutoreleasedReturnValue([v122 objectForKeyedSubscript:v127]);
                v178 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Could not find manifest entry for %@",  v177));
                v297 = v178;
                v179 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v297,  &v296,  1LL));
                v180 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v179));

                objc_autoreleasePoolPop(v251);
                v149 = 2;
                v123 = (void *)v180;
LABEL_100:

                v252 = v123;
                goto LABEL_101;
              }
            }

            v135 = v127;
            v136 = v131;
            v137 = (void *)objc_claimAutoreleasedReturnValue([v131 objectForKeyedSubscript:@"Info"]);
            v138 = (void *)objc_claimAutoreleasedReturnValue([v137 objectForKeyedSubscript:@"Path"]);

            if (v138)
            {
              v139 = (void *)objc_claimAutoreleasedReturnValue( -[NSString stringByAppendingPathComponent:]( self->_bundlePath,  "stringByAppendingPathComponent:",  v138));
              v140 = (void *)objc_claimAutoreleasedReturnValue([v270 stringByAppendingPathComponent:v135]);
              v141 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Attempting to copy file from %@ to %@", v139, v140));
              v142 = [v141 UTF8String];
              _MobileAssetLog( 0LL,  7,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v143,  v144,  v145,  v146,  (uint64_t)v142);

              v147 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
              v279 = v123;
              v148 = v147;
              v247 = [v147 copyItemAtPath:v139 toPath:v140 error:&v279];
              v246 = v279;

              v122 = v242;
              if (v247) {
                v149 = 0;
              }
              else {
                v149 = 2;
              }
              v123 = v246;
            }

            else
            {
              v294 = NSDebugDescriptionErrorKey;
              v150 = (void *)objc_claimAutoreleasedReturnValue([v122 objectForKeyedSubscript:v135]);
              v151 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Manifest entry for %@ has no path",  v150));
              v295 = v151;
              v152 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v295,  &v294,  1LL));
              v248 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v152));

              v149 = 2;
              v123 = (void *)v248;
            }

            objc_autoreleasePoolPop(v251);
            if (v149) {
              goto LABEL_100;
            }
            v124 = v126 + 1;
          }

          while (v245 != (id)(v126 + 1));
          v245 = [v122 countByEnumeratingWithState:&v280 objects:v298 count:16];
          if (v245) {
            continue;
          }
          break;
        }
      }

      v153 = objc_autoreleasePoolPush();
      v154 = (void *)objc_claimAutoreleasedReturnValue( -[NSString stringByAppendingPathComponent:]( self->_bundlePath,  "stringByAppendingPathComponent:",  @"BuildManifest.plist"));
      v155 = (void *)objc_claimAutoreleasedReturnValue([v270 stringByAppendingPathComponent:@"BuildManifest.plist"]);
      v156 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Attempting to copy BuildManifest from %@ to %@", v154, v155));
      v157 = [v156 UTF8String];
      _MobileAssetLog( 0LL,  7,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v158,  v159,  v160,  v161,  (uint64_t)v157);

      v162 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      v278 = v123;
      v163 = [v162 copyItemAtPath:v154 toPath:v155 error:&v278];
      v252 = v278;

      if (v163)
      {
        if (v269)
        {
LABEL_95:
          v149 = 0;
          goto LABEL_98;
        }

        v164 = [(id)AMAuthInstallBundleGetManifestPath() stringByAppendingPathComponent:@"Cryptex1"];
        v165 = (void *)objc_claimAutoreleasedReturnValue(v164);
        v166 = (void *)objc_claimAutoreleasedReturnValue([v165 stringByAppendingPathComponent:kAMAuthInstallTagCryptex1Img4Ticket]);

        v167 = objc_claimAutoreleasedReturnValue([v239 stringByAppendingPathComponent:v166]);
        v168 = objc_claimAutoreleasedReturnValue([v270 stringByAppendingPathComponent:@"cryptex1ticket.der"]);

        v169 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Attempting to copy Cryptex1 ticket from %@ to %@", v167, v168));
        v170 = [v169 UTF8String];
        _MobileAssetLog( 0LL,  7,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v171,  v172,  v173,  v174,  (uint64_t)v170);

        v175 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
        v277 = v252;
        LODWORD(v165) = [v175 copyItemAtPath:v167 toPath:v168 error:&v277];
        v176 = v277;

        if ((_DWORD)v165)
        {
          v154 = (void *)v167;
          v155 = (void *)v168;
          v252 = v176;
          goto LABEL_95;
        }

        v149 = 2;
        v154 = (void *)v167;
        v155 = (void *)v168;
        v252 = v176;
      }

      else
      {
        v149 = 2;
      }

LABEL_102:
                uint64_t v15 = 1;
                goto LABEL_103;
              }

              __int128 v87 = v86;
              __int128 v88 = *(void *)v119;
LABEL_78:
              __int128 v89 = 0LL;
              while (1)
              {
                if (*(void *)v119 != v88) {
                  objc_enumerationMutation(v16);
                }
                v90 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v118 + 1) + 8 * v89) assetType]);
                v91 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v90, v4);

                if ((v91 & 1) != 0) {
                  break;
                }
                if (v87 == (id)++v89)
                {
                  __int128 v87 = [v16 countByEnumeratingWithState:&v118 objects:v160 count:16];
                  if (v87) {
                    goto LABEL_78;
                  }
                  goto LABEL_84;
                }
              }
            }
          }
        }
      }
    }

    goto LABEL_102;
  }

  uint64_t v15 = 1;
LABEL_104:

  return v15;
}

        goto LABEL_103;
      }
    }
  }

  id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  id v76 = (os_log_s *)objc_claimAutoreleasedReturnValue([v75 oslog]);

  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    id v77 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
    *(_DWORD *)buf = 138543618;
    v133 = (uint64_t)v77;
    v134 = 2114;
    v135 = v8;
    _os_log_impl( &dword_0,  v76,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@} no persisted auto-asset-set-jobs to be resumed | MA_MILESTONE",  buf,  0x16u);
    goto LABEL_102;
  }

  if ((a3 & 0x8000000) != 0)
  {
    v138 = 0LL;
    id v77 = (void *)objc_claimAutoreleasedReturnValue( -[ControlManager dictionaryWithArrayOfStringValues:forXpcKey:andLengthKey:failureReason:]( v127,  "dictionaryWithArrayOfStringValues:forXpcKey:andLengthKey:failureReason:",  v10,  "purgeAssetTypePreservingList",  "purgeAssetTypePreservingListLength",  &v138));
    id v17 = (__CFString *)v138;
    if (v77)
    {
      v119 = v10;
      v121 = v14;
      v118 = v11;
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      id obj = (id)objc_claimAutoreleasedReturnValue([v77 allKeys]);
      v78 = [obj countByEnumeratingWithState:&v134 objects:v144 count:16];
      v124 = v77;
      if (v78)
      {
        v79 = v78;
        v80 = *(void *)v135;
        v122 = v13;
        v123 = v12;
        v126 = a3;
        while (2)
        {
          for (uint64_t i = 0LL; i != v79; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v135 != v80) {
              objc_enumerationMutation(obj);
            }
            uint64_t v82 = *(void **)(*((void *)&v134 + 1) + 8LL * (void)i);
            id v83 = objc_autoreleasePoolPush();
            if (!v17)
            {
              if (!isWellFormedAssetType(v82))
              {
                id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Asset identifiers to ignore included assetType:%@ that is not well formed",  v82);
                objc_autoreleasePoolPop(v83);
                goto LABEL_129;
              }

              v132 = 0u;
              v133 = 0u;
              v130 = 0u;
              v131 = 0u;
              id v84 = (void *)objc_claimAutoreleasedReturnValue([v77 objectForKey:v82]);
              id v17 = (__CFString *)[v84 countByEnumeratingWithState:&v130 objects:v143 count:16];
              if (v17)
              {
                id v85 = *(void *)v131;
                while (2)
                {
                  for (j = 0LL; j != v17; j = (__CFString *)((char *)j + 1))
                  {
                    if (*(void *)v131 != v85) {
                      objc_enumerationMutation(v84);
                    }
                    __int128 v87 = *(void **)(*((void *)&v130 + 1) + 8LL * (void)j);
                    __int128 v88 = objc_autoreleasePoolPush();
                    if (!isWellFormedAssetId(v87))
                    {
                      id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Asset identifiers to ignore included assetId:%@ that is not well formed",  v87);
                      objc_autoreleasePoolPop(v88);
                      goto LABEL_123;
                    }

                    objc_autoreleasePoolPop(v88);
                  }

                  id v17 = (__CFString *)[v84 countByEnumeratingWithState:&v130 objects:v143 count:16];
                  if (v17) {
                    continue;
                  }
                  break;
                }

LABEL_43:
      [v140 addObject:v50];
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v146, "logger"));
      v51 = (id)objc_claimAutoreleasedReturnValue([v59 oslog]);

      if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v146, "summary"));
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _targetNameActive](v146, "_targetNameActive"));
        v62 = (os_log_s *)objc_claimAutoreleasedReturnValue([v50 summary]);
        *(_DWORD *)buf = 138544642;
        v214 = v60;
        v215 = 2114;
        v216 = v61;
        v217 = 2114;
        v218 = v138;
        v219 = 2048;
        v220 = j + 1;
        v221 = 2048;
        v222 = (os_log_s *)v139;
        v223 = 2114;
        v224 = v62;
        _os_log_impl( &dword_0,  (os_log_t)v51,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [%{public}@] {%{public}@:_formCandidateSetLookupArray} set-configuration (%ld of %ld) [OPTIONAL]:%{public}@",  buf,  0x3Eu);
LABEL_49:

LABEL_50:
LABEL_51:
      }
    }

    else
    {
      id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v146, "logger"));
      v51 = (id)objc_claimAutoreleasedReturnValue([v63 oslog]);

      if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v146, "summary"));
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue([v50 summary]);
        *(_DWORD *)buf = 138544386;
        v214 = v60;
        v215 = 2114;
        v216 = v138;
        v217 = 2048;
        v218 = (os_log_s *)(j + 1);
        v219 = 2048;
        v220 = v139;
        v221 = 2114;
        v222 = v61;
        _os_log_impl( &dword_0,  (os_log_t)v51,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n [AUTO-STAGER] {%{public}@:_formCandidateSetLookupArray} set-configuration (%ld of %ld):%{public}@",  buf,  0x34u);
        goto LABEL_50;
      }
    }

LABEL_53:
  }

  uint64_t v66 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  v143 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  v157 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  uint64_t v67 = v66;
  v160 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  v189 = 0u;
  v190 = 0u;
  v191 = 0u;
  v192 = 0u;
  id obj = v153;
  uint64_t v68 = [obj countByEnumeratingWithState:&v189 objects:v212 count:16];
  v142 = v66;
  if (v68)
  {
    uint64_t v69 = v68;
    uint64_t v70 = *(void *)v190;
    v144 = *(void *)v190;
    do
    {
      uint64_t v71 = 0LL;
      v147 = v69;
      do
      {
        if (*(void *)v190 != v70) {
          objc_enumerationMutation(obj);
        }
        id v72 = *(void **)(*((void *)&v189 + 1) + 8LL * (void)v71);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v72 firstEntryAssetType]);
        if (v73)
        {
          uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v67, "objectForKeyedSubscript:", v73));
          if (v74)
          {
            v151 = v73;
            v154 = v71;
            v187 = 0u;
            v188 = 0u;
            v185 = 0u;
            v186 = 0u;
            id v75 = (void *)objc_claimAutoreleasedReturnValue([v72 autoAssetEntries]);
            id v76 = [v75 countByEnumeratingWithState:&v185 objects:v211 count:16];
            if (v76)
            {
              id v77 = v76;
              v78 = *(void *)v186;
              do
              {
                for (k = 0LL; k != v77; k = (char *)k + 1)
                {
                  if (*(void *)v186 != v78) {
                    objc_enumerationMutation(v75);
                  }
                  v80 = *(void **)(*((void *)&v185 + 1) + 8LL * (void)k);
                  v181 = 0u;
                  v182 = 0u;
                  v183 = 0u;
                  v184 = 0u;
                  v81 = v74;
                  uint64_t v82 = [v81 countByEnumeratingWithState:&v181 objects:v210 count:16];
                  if (v82)
                  {
                    id v83 = v82;
                    id v84 = *(void *)v182;
                    while (2)
                    {
                      for (m = 0LL; m != v83; m = (char *)m + 1)
                      {
                        if (*(void *)v182 != v84) {
                          objc_enumerationMutation(v81);
                        }
                        if ([v80 isEqual:*(void *)(*((void *)&v181 + 1) + 8 * (void)m)])
                        {

                          goto LABEL_76;
                        }
                      }

                      id v83 = [v81 countByEnumeratingWithState:&v181 objects:v210 count:16];
                      if (v83) {
                        continue;
                      }
                      break;
                    }
                  }

                  [v81 addObject:v80];
LABEL_76:
                  ;
                }

                id v77 = [v75 countByEnumeratingWithState:&v185 objects:v211 count:16];
              }

              while (v77);
            }

            uint64_t v67 = v142;
            v73 = v151;
            -[NSMutableDictionary setObject:forKeyedSubscript:](v142, "setObject:forKeyedSubscript:", v74, v151);
            uint64_t v70 = v144;
            uint64_t v69 = v147;
            uint64_t v71 = v154;
          }

          else
          {
            __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v72 autoAssetEntries]);
            __int128 v87 = [v86 mutableCopy];
            -[NSMutableDictionary setObject:forKeyedSubscript:](v67, "setObject:forKeyedSubscript:", v87, v73);
          }
        }

        uint64_t v71 = (char *)v71 + 1;
      }

      while (v71 != v69);
      uint64_t v69 = [obj countByEnumeratingWithState:&v189 objects:v212 count:16];
    }

    while (v69);
  }

  v179 = 0u;
  v180 = 0u;
  v177 = 0u;
  v178 = 0u;
  v148 = v140;
  __int128 v88 = [v148 countByEnumeratingWithState:&v177 objects:v209 count:16];
  __int128 v89 = v143;
  if (v88)
  {
    v90 = v88;
    v91 = *(void *)v178;
    v141 = *(void *)v178;
    do
    {
      v92 = 0LL;
      v145 = v90;
      do
      {
        if (*(void *)v178 != v91) {
          objc_enumerationMutation(v148);
        }
        v93 = *(void **)(*((void *)&v177 + 1) + 8LL * (void)v92);
        v94 = (void *)objc_claimAutoreleasedReturnValue([v93 firstEntryAssetType]);
        if (v94)
        {
          v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v89, "objectForKeyedSubscript:", v94));
          if (v95)
          {
            v152 = v94;
            v155 = v92;
            v175 = 0u;
            v176 = 0u;
            v173 = 0u;
            v174 = 0u;
            v96 = (void *)objc_claimAutoreleasedReturnValue([v93 autoAssetEntries]);
            v97 = [v96 countByEnumeratingWithState:&v173 objects:v208 count:16];
            if (v97)
            {
              v98 = v97;
              v99 = *(void *)v174;
              do
              {
                for (n = 0LL; n != v98; n = (char *)n + 1)
                {
                  if (*(void *)v174 != v99) {
                    objc_enumerationMutation(v96);
                  }
                  v101 = *(void **)(*((void *)&v173 + 1) + 8LL * (void)n);
                  v169 = 0u;
                  v170 = 0u;
                  v171 = 0u;
                  v172 = 0u;
                  v102 = v95;
                  v103 = [v102 countByEnumeratingWithState:&v169 objects:v207 count:16];
                  if (v103)
                  {
                    v104 = v103;
                    v105 = *(void *)v170;
                    while (2)
                    {
                      for (iuint64_t i = 0LL; ii != v104; iuint64_t i = (char *)ii + 1)
                      {
                        if (*(void *)v170 != v105) {
                          objc_enumerationMutation(v102);
                        }
                        if ([v101 isEqual:*(void *)(*((void *)&v169 + 1) + 8 * (void)ii)])
                        {

                          goto LABEL_105;
                        }
                      }

                      v104 = [v102 countByEnumeratingWithState:&v169 objects:v207 count:16];
                      if (v104) {
                        continue;
                      }
                      break;
                    }
                  }

                  [v102 addObject:v101];
LABEL_105:
                  ;
                }

                v98 = [v96 countByEnumeratingWithState:&v173 objects:v208 count:16];
              }

              while (v98);
            }

            __int128 v89 = v143;
            v94 = v152;
            -[NSMutableDictionary setObject:forKeyedSubscript:](v143, "setObject:forKeyedSubscript:", v95, v152);
            v91 = v141;
            v90 = v145;
            v92 = v155;
          }

          else
          {
            v107 = (void *)objc_claimAutoreleasedReturnValue([v93 autoAssetEntries]);
            v108 = [v107 mutableCopy];
            -[NSMutableDictionary setObject:forKeyedSubscript:](v89, "setObject:forKeyedSubscript:", v108, v94);
          }
        }

        v92 = (char *)v92 + 1;
      }

      while (v92 != v90);
      v90 = [v148 countByEnumeratingWithState:&v177 objects:v209 count:16];
    }

    while (v90);
  }

  v167 = 0u;
  v168 = 0u;
  v165 = 0u;
  v166 = 0u;
  v109 = v142;
  v110 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v109,  "countByEnumeratingWithState:objects:count:",  &v165,  v206,  16LL);
  if (v110)
  {
    v111 = v110;
    v112 = *(void *)v166;
    do
    {
      for (jj = 0LL; jj != v111; jj = (char *)jj + 1)
      {
        if (*(void *)v166 != v112) {
          objc_enumerationMutation(v109);
        }
        v114 = *(void *)(*((void *)&v165 + 1) + 8LL * (void)jj);
        v115 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v109, "objectForKeyedSubscript:", v114));
        v116 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@_%@",  @"AUTO_ASSET_STAGER_SET",  v114);
        LOWORD(v132) = 257;
        v117 = -[MADAutoSetConfiguration initForClientDomainName:forSetClientName:forAssetSetIdentifier:withAutoAssetEntries:withLatestAtomicInstanceToVend:inhibitingImpliedScheduling:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:]( objc_alloc(&OBJC_CLASS___MADAutoSetConfiguration),  "initForClientDomainName:forSetClientName:forAssetSetIdentifier:withAutoAssetEntries:withLatestAtomicIns tanceToVend:inhibitingImpliedScheduling:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:",  @"com.apple.MobileAsset.AutoAssetStager.client",  @"AUTO_ASSET_STAGER_AS_CLIENT",  v116,  v115,  0LL,  1LL,  v132);
        -[NSMutableArray addObject:](v157, "addObject:", v117);
      }

      v111 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v109,  "countByEnumeratingWithState:objects:count:",  &v165,  v206,  16LL);
    }

    while (v111);
  }

  v158 = v157;
  v163 = 0u;
  v164 = 0u;
  v161 = 0u;
  v162 = 0u;
  v118 = v143;
  v119 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v118,  "countByEnumeratingWithState:objects:count:",  &v161,  v205,  16LL);
  if (v119)
  {
    v120 = v119;
    v121 = *(void *)v162;
    do
    {
      for (kk = 0LL; kk != v120; kk = (char *)kk + 1)
      {
        if (*(void *)v162 != v121) {
          objc_enumerationMutation(v118);
        }
        v123 = *(void *)(*((void *)&v161 + 1) + 8LL * (void)kk);
        v124 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v118, "objectForKeyedSubscript:", v123));
        v125 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@_%@",  @"AUTO_ASSET_STAGER_SET",  v123);
        LOWORD(v133) = 257;
        v126 = -[MADAutoSetConfiguration initForClientDomainName:forSetClientName:forAssetSetIdentifier:withAutoAssetEntries:withLatestAtomicInstanceToVend:inhibitingImpliedScheduling:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:]( objc_alloc(&OBJC_CLASS___MADAutoSetConfiguration),  "initForClientDomainName:forSetClientName:forAssetSetIdentifier:withAutoAssetEntries:withLatestAtomicIns tanceToVend:inhibitingImpliedScheduling:havingReceivedLookupResponse:vendingAtomicInstanceForConfiguredEntries:",  @"com.apple.MobileAsset.AutoAssetStager.client",  @"AUTO_ASSET_STAGER_AS_CLIENT",  v125,  v124,  0LL,  1LL,  v133);
        -[NSMutableArray addObject:](v160, "addObject:", v126);
      }

      v120 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v118,  "countByEnumeratingWithState:objects:count:",  &v161,  v205,  16LL);
    }

    while (v120);
  }

  v127 = v160;
  self = v146;
  if (-[MADAutoAssetStager stagingClientUsingGroups](v146, "stagingClientUsingGroups"))
  {
    v128 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager candidateSetConfigurationsRequiredByTarget]( v146,  "candidateSetConfigurationsRequiredByTarget"));
    [v128 setSafeObject:v158 forKey:v135];

    v129 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetStager candidateSetConfigurationsOptionalByTarget]( v146,  "candidateSetConfigurationsOptionalByTarget"));
    [v129 setSafeObject:v127 forKey:v135];
  }

  uint64_t v42 = @"Y";
  id v9 = v136;
LABEL_129:
  v130 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"done forming set-lookups | haveSetLookups:%@",  v42);
  -[MADAutoAssetStager _logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:]( self,  "_logMilestoneFromLocation:resultingInEvent:forMilestoneActivity:",  v138,  0LL,  v130);

  return (uint64_t)v139 > 0;
}

        if ([v45 preSoftwareUpdateAssetStaging])
        {
          self = v113;
          -[MADAutoAssetStager addToAvailableForStaging:](v113, "addToAvailableForStaging:", v45);
          v61 = (void *)v115;
          v81 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"[%@] adding to availableForStaging (from downloaded that support staging)",  v115);
          id v10 = v112;
          -[MADAutoAssetStager _persistDescriptor:operation:persistingDescriptor:withRepresentation:message:]( v113,  "_persistDescriptor:operation:persistingDescriptor:withRepresentation:message:",  v112,  @"ENTRY_ADD",  v45,  601LL,  v81);

          uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager persistedState](v113, "persistedState"));
          id v83 = v45;
          id v84 = (void *)objc_claimAutoreleasedReturnValue([v82 persistedConfig]);
          id v85 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager availableForStaging](v113, "availableForStaging"));
          objc_msgSend( v84,  "persistULL:forKey:shouldPersist:",  objc_msgSend(v85, "count"),  @"determinedAvailableAssetCount",  1);

          uint64_t v53 = v83;
          __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v83 metadata]);
          -[MADAutoAssetStager setOverallStagedTotalExpectedBytes:]( v113,  "setOverallStagedTotalExpectedBytes:",  (char *)[v86 safeIntegerForKey:@"_UnarchivedSize"]
          + -[MADAutoAssetStager overallStagedTotalExpectedBytes](v113, "overallStagedTotalExpectedBytes"));

          -[MADAutoAssetStager _logPersistedConfigSet:message:]( v113,  "_logPersistedConfigSet:message:",  v112,  @"added to available for staging");
LABEL_48:
          uint64_t v11 = v111;
          id v32 = v119;
          uint64_t v52 = v121;
        }

        else
        {
          uint64_t v53 = v45;
          self = v113;
          v92 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](v113, "logger"));
          v93 = (os_log_s *)objc_claimAutoreleasedReturnValue([v92 oslog]);

          uint64_t v11 = v111;
          id v10 = v112;
          id v32 = v119;
          uint64_t v52 = v121;
          v61 = (void *)v115;
          if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
          {
            v94 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](v113, "summary"));
            v95 = (__CFString *)objc_claimAutoreleasedReturnValue([v53 summary]);
            *(_DWORD *)buf = 138544130;
            v136 = v94;
            v137 = 2114;
            v138 = v115;
            v139 = 2114;
            v140 = v112;
            v141 = 2114;
            v142 = v95;
            _os_log_impl( &dword_0,  v93,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[%{public}@] {%{public}@} not pre-SU-staging descriptor:%{public}@",  buf,  0x2Au);
          }
        }

        v51 = v116;
LABEL_55:

LABEL_56:
        unsigned int v33 = v52 + 1;
      }

      while (v33 != v120);
      v100 = [obj countByEnumeratingWithState:&v130 objects:v147 count:16];
      v120 = v100;
    }

    while (v100);
  }

LABEL_63:
  v101 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  v102 = (os_log_s *)objc_claimAutoreleasedReturnValue([v101 oslog]);

  if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
  {
    v103 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager summary](self, "summary"));
    *(_DWORD *)buf = 138544130;
    v104 = @"N";
    v136 = v103;
    if (v108) {
      v104 = v108;
    }
    v137 = 2114;
    v138 = v109;
    v139 = 2114;
    v140 = v107;
    v141 = 2114;
    v142 = v104;
    _os_log_impl( &dword_0,  v102,  OS_LOG_TYPE_DEFAULT,  "%{public}@\n[%{public}@] {%{public}@} end determine-if-available | assetType:%{public}@",  buf,  0x2Au);
  }

  -[MADAutoAssetStager setActiveJobDescriptor:](self, "setActiveJobDescriptor:", 0LL);
}

      objc_autoreleasePoolPop(context);
      id v20 = v66 + 1;
    }

    while ((id)(v66 + 1) != v16);
    int v16 = [v14 countByEnumeratingWithState:&v74 objects:v85 count:16];
  }

  while (v16);

  if (v62)
  {
    v50 = v62;
    uint64_t v11 = v57;
    v51 = v64;
    goto LABEL_52;
  }

  uint64_t v11 = v57;
  v51 = v64;
LABEL_49:
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
  uint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue([v52 oslog]);

  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
  {
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
    v56 = (__CFString *)objc_claimAutoreleasedReturnValue([v14 safeSummary]);
    *(_DWORD *)buf = 138543874;
    v80 = (uint64_t)v55;
    v81 = 2114;
    uint64_t v82 = v69;
    id v83 = 2114;
    id v84 = v56;
    _os_log_error_impl( &dword_0,  v53,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {assetMetadataFromAssetCatalog} Assets array in set-catalog lookup response missing asset-specifier | assetSpecifier:%{public}@ | autoAssetSetCatalog:%{public}@",  buf,  0x20u);
  }

  v50 = 0LL;
LABEL_52:

  return v50;
}

  return v45;
}

      if (v23 != v16 + 1) {
        goto LABEL_67;
      }
    }

    uint64_t v15 = v30 & 1 | (2 * v17);
    result = swift_unknownObjectRetain(v29);
    uint64_t v14 = v13;
    id v6 = v22;
    id v7 = a3;
LABEL_45:
    *(_BYTE *)id v9 = v12;
    *(void *)(v9 + _Block_object_dispose(va, 8) = result;
    *(void *)(v9 + 16) = v5;
    *(void *)(v9 + 24) = v14;
    *(void *)(v9 + 32) = v15;
    *(void *)(v9 + 40) = v16;
    *(_BYTE *)(v9 + 4_Block_object_dispose(va, 8) = (v12 & 0x20) == 0;
    if (v10 == v7) {
      goto LABEL_49;
    }
    id v5 = v31;
    if (v6 == v8)
    {
      id v6 = (unint64_t)v30 >> 1;
      id v7 = v10;
      result = v26;
      id v4 = v29;
      goto LABEL_6;
    }

    ++v10;
    v9 += 56LL;
    if (v6 >= v8) {
      goto LABEL_48;
    }
  }

  if (v13 >= v8) {
    goto LABEL_64;
  }
  id v17 = v6 + 1;
  if (v16 >= *(void *)(v5 + 48 * v13 + 8))
  {
LABEL_24:
    if (v17 < 0) {
      goto LABEL_57;
    }
    goto LABEL_25;
  }

  id v17 = (unint64_t)v30 >> 1;
  if (v6 + 2 == v8)
  {
LABEL_23:
    if (v17 <= v6) {
      goto LABEL_56;
    }
    goto LABEL_24;
  }

  uint64_t v18 = (void *)(v27 + 48 * v6);
  id v17 = v6 + 2;
  while (v17 < v8)
  {
    if (v16 >= *v18) {
      goto LABEL_23;
    }
    int v19 = v17 + 1;
    if (__OFADD__(v17, 1LL)) {
      goto LABEL_55;
    }
    ++v17;
    v18 += 6;
    if (v19 == v8)
    {
      id v17 = (unint64_t)v30 >> 1;
      goto LABEL_23;
    }
  }

    uint64_t v28 = v6[3];
    uint64_t v29 = v6;
    unsigned __int8 v49 = v16;
    uint64_t v30 = v28 & 0xFFFFFFFFFFFFFFFELL;
    if (v30 <= 1) {
      uint64_t v31 = 1LL;
    }
    else {
      uint64_t v31 = v30;
    }
    id v32 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8980);
    id v6 = (void *)swift_allocObject(v32, 56 * v31 + 32, 7LL);
    unsigned int v33 = (uint64_t)(_swift_stdlib_malloc_size(v6) - 32) / 56;
    v6[2] = v31;
    v6[3] = 2 * v33;
    __int128 v34 = (unint64_t)(v6 + 4);
    __int128 v35 = v29[3] >> 1;
    __int128 v36 = 7 * v35;
    if (v29[2])
    {
      v29[2] = 0LL;
    }

    id v38 = v29;
    uint64_t v11 = (void *)(v34 + v36 * 8);
    id v4 = (v33 & 0x7FFFFFFFFFFFFFFFLL) - v35;
    result = swift_release(v38);
    id v8 = v18;
    id v10 = v44;
    goto LABEL_56;
  }

  id v4 = 0LL;
LABEL_62:
  uint64_t v40 = v6[3];
  if (v40 >= 2)
  {
    v41 = v40 >> 1;
    id v39 = __OFSUB__(v41, v4);
    uint64_t v42 = v41 - v4;
    if (v39) {
      goto LABEL_86;
    }
    v6[2] = v42;
  }

  return (uint64_t)v6;
}

  __break(1u);
}

LABEL_41:
            uint64_t v68 = (char *)v68 + 1;
          }

          while (v66 != v68);
          uint64_t v66 = [v124 countByEnumeratingWithState:&v125 objects:v134 count:16];
          if (v66) {
            continue;
          }
          break;
        }

          v62 = (void *)v40;

          self = v59;
          uint64_t v14 = v60;
          id v17 = v58;
          int v16 = v61;
          goto LABEL_42;
        }

        v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue([v47 oslog]);

        id obj = v48;
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
          *(_DWORD *)buf = 138543618;
          v80 = (uint64_t)v27;
          v81 = 2114;
          uint64_t v82 = v21;
          uint64_t v30 = v48;
          uint64_t v31 = "%{public}@\n"
                "[AUTO-STAGER] {assetMetadataFromAssetCatalog} key value is not an array | setCatalogKey:%{public}@";
          id v32 = 22;
          goto LABEL_18;
        }

        goto LABEL_42;
      }

              -[NSMutableArray addObject:](v95, "addObject:", v43);
            }

            id v39 = v91;
          }

          else
          {
            uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue([v58 oslog]);

            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543874;
              v123 = v101;
              v124 = 2114;
              v125 = v100;
              v126 = 2114;
              v127 = v92;
              _os_log_error_impl( &dword_0,  v59,  OS_LOG_TYPE_ERROR,  "\n [SET-ELIMINATE]{%{public}@} unable to load persisted entry | clientDomainName:%{public}@ | assetSetIdent ifier:%{public}@",  buf,  0x20u);
            }

            -[NSMutableArray addObject:](v95, "addObject:", v43);
          }

          p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
          goto LABEL_45;
        }

        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v57 oslog]);

        if (os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543874;
          v123 = v101;
          v124 = 2114;
          v125 = v100;
          v126 = 2114;
          v127 = v92;
          _os_log_error_impl( &dword_0,  (os_log_t)v46,  OS_LOG_TYPE_ERROR,  "\n[SET-ELIMINATE]{%{public}@:} no entryID | clientDomainName:%{public}@ | assetSetIdentifier:%{public}@",  buf,  0x20u);
        }

                    -[NSMutableArray addObject:](v102, "addObject:", v12);
                    v48 = (void *)v98;
LABEL_42:
                    uint64_t v28 = v97;
LABEL_43:

                    id v10 = v96;
LABEL_36:

                    goto LABEL_37;
                  }

                  v48 = (void *)v98;
                  if (v98)
                  {
                    if (v99)
                    {
                      unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateActiveAutoJobForSetDescriptor:]( self,  "locateActiveAutoJobForSetDescriptor:",  v18));
                      if (v49)
                      {
                        ++v93;
                        -[MADAutoAssetControlManager updateAutoAssetSetStatus:forSetDescriptor:]( self,  "updateAutoAssetSetStatus:forSetDescriptor:",  @"resumeSetJobsWhenBeforeFirstUnlock",  v18);
                      }

                      else
                      {
                        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                        uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue([v59 oslog]);

                        v61 = v60;
                        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
                        {
                          id v63 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                          v91 = v61;
                          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v18 summary]);
                          *(_DWORD *)buf = 138543618;
                          v114 = (uint64_t)v63;
                          v115 = 2114;
                          v116 = (uint64_t)v64;
                          _os_log_error_impl( &dword_0,  v91,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetActiveJobDescriptors} active-set-job set-descriptor yet no act ive active auto-asset-job | dropping presumed-stale previously active set-job | setJobDescriptor:%{public}@",  buf,  0x16u);

                          v61 = v91;
                        }

                        -[NSMutableArray addObject:](v102, "addObject:", v12);
                        uint64_t v28 = v97;
                        unsigned __int8 v49 = 0LL;
                      }

                      goto LABEL_43;
                    }

                    uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                    uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue([v57 oslog]);

                    uint64_t v52 = v58;
                    if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                    {
LABEL_51:

                      -[NSMutableArray addObject:](v102, "addObject:", v12);
                      goto LABEL_42;
                    }

                    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                    loga = v52;
                    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v18 summary]);
                    *(_DWORD *)buf = 138543618;
                    v114 = (uint64_t)v53;
                    v115 = 2114;
                    v116 = (uint64_t)v54;
                    uint64_t v55 = loga;
                    v56 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} active-set-job set-descriptor yet no set-a"
                          "tomic-instance | dropping presumed-stale previously active set-job | setJobDescriptor:%{public}@";
                  }

                  else
                  {
                    v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                    v51 = (os_log_s *)objc_claimAutoreleasedReturnValue([v50 oslog]);

                    uint64_t v52 = v51;
                    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_51;
                    }
                    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                    loga = v52;
                    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v18 summary]);
                    *(_DWORD *)buf = 138543618;
                    v114 = (uint64_t)v53;
                    v115 = 2114;
                    v116 = (uint64_t)v54;
                    uint64_t v55 = loga;
                    v56 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} active-set-job set-descriptor yet no set-c"
                          "onfiguration | dropping presumed-stale previously active set-job | setJobDescriptor:%{public}@";
                  }

                  _os_log_error_impl(&dword_0, v55, OS_LOG_TYPE_ERROR, v56, buf, 0x16u);

                  uint64_t v52 = loga;
                  goto LABEL_51;
                }

                uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                __int128 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue([v46 oslog]);

                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                {
                  id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                  *(_DWORD *)buf = 138543618;
                  v114 = (uint64_t)v38;
                  v115 = 2114;
                  v116 = (uint64_t)v12;
                  uint64_t v40 = v37;
                  v41 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} encountered auto-asset-set-descriptor withou"
                        "t discoveredAtomicEntries | entryID:%{public}@";
LABEL_33:
                  _os_log_impl(&dword_0, v40, OS_LOG_TYPE_DEFAULT, v41, buf, 0x16u);
LABEL_34:
                }
              }

              else
              {
                uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                __int128 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                {
                  id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                  *(_DWORD *)buf = 138543618;
                  v114 = (uint64_t)v38;
                  v115 = 2114;
                  v116 = (uint64_t)v12;
                  uint64_t v40 = v37;
                  v41 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} encountered auto-asset-set-descriptor withou"
                        "t discoveredAtomicInstance | entryID:%{public}@";
                  goto LABEL_33;
                }
              }
            }

            else
            {
              id v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              __int128 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue([v39 oslog]);

              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
              {
                id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                *(_DWORD *)buf = 138543618;
                v114 = (uint64_t)v38;
                v115 = 2114;
                v116 = (uint64_t)v12;
                uint64_t v40 = v37;
                v41 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} encountered auto-asset-set-descriptor without "
                      "assetSetIdentifier | entryID:%{public}@";
                goto LABEL_33;
              }
            }
          }

          else
          {
            __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            __int128 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue([v36 oslog]);

            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              *(_DWORD *)buf = 138543618;
              v114 = (uint64_t)v38;
              v115 = 2114;
              v116 = (uint64_t)v12;
              _os_log_error_impl( &dword_0,  v37,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetActiveJobDescriptors} unable to load auto-asset-set-descriptor | entryID:%{public}@",  buf,  0x16u);
              goto LABEL_34;
            }
          }

          -[NSMutableArray addObject:](v102, "addObject:", v12);
          goto LABEL_36;
        }
      }

      __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      __int128 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue([v34 oslog]);

      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        uint64_t v43 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        uint64_t v44 = (void *)v43;
        *(_DWORD *)buf = 138543618;
        uint64_t v45 = @"N";
        if (v12) {
          uint64_t v45 = v12;
        }
        v114 = v43;
        v115 = 2114;
        v116 = (uint64_t)v45;
        _os_log_error_impl( &dword_0,  v35,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetActiveJobDescriptors} unable to determine previous status | entryID:%{public}@",  buf,  0x16u);
      }

      if (v12) {
        -[NSMutableArray addObject:](v102, "addObject:", v12);
      }
LABEL_37:
      objc_autoreleasePoolPop(v13);
      uint64_t v11 = (char *)v11 + 1;
    }

    while (v9 != v11);
    uint64_t v65 = [obj countByEnumeratingWithState:&v108 objects:v119 count:16];
    id v9 = v65;
  }

  while (v65);
LABEL_64:

  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  uint64_t v67 = v102;
  uint64_t v69 = -[os_log_s countByEnumeratingWithState:objects:count:]( v67,  "countByEnumeratingWithState:objects:count:",  &v104,  v112,  16LL);
  if (v69)
  {
    uint64_t v70 = v69;
    uint64_t v71 = *(void *)v105;
    v103 = v67;
    do
    {
      for (uint64_t i = 0LL; i != v70; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v105 != v71) {
          objc_enumerationMutation(v103);
        }
        v73 = *(void *)(*((void *)&v104 + 1) + 8LL * (void)i);
        uint64_t v74 = objc_autoreleasePoolPush();
        if (v73)
        {
          id v75 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
          id v76 = (void *)objc_claimAutoreleasedReturnValue( [v75 persistedEntry:v73 fromLocation:@"loadPersistedSetActiveJobDescriptors"]);

          id v77 = [v76 secureCodedObjectForKey:@"assetSetDescriptor" ofClass:objc_opt_class(MADAutoSetDescriptor)];
          v78 = (void *)objc_claimAutoreleasedReturnValue(v77);
          v79 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
          [v79 removePersistedEntry:v73 fromLocation:@"resumeSetJobsWhenBeforeFirstUnlock"];

          -[MADAutoAssetControlManager _logPersistedSetDescriptorRemoved:forComponentType:removedPersistedEntryID:removedSetDescriptor:message:]( self,  "_logPersistedSetDescriptorRemoved:forComponentType:removedPersistedEntryID:removedSetDescriptor:message:",  @"loadPersistedSetActiveJobDescriptors",  @"SET_ACTIVE_JOB_DESCRIPTORS",  v73,  v78,  @"removing stale active-persisted set-job");
        }

        else
        {
          id v76 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
          v78 = (void *)objc_claimAutoreleasedReturnValue([v76 diag]);
          v80 = objc_alloc(&OBJC_CLASS___NSString);
          v81 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          uint64_t v82 = -[NSString initWithFormat:]( v80,  "initWithFormat:",  @"{loadPersistedSetActiveJobDescriptors} nil entryID encountered on staleActivePersistedEntryIDs | %@",  v81);
          [v78 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v82 withResult:6108 withError:0];
        }

        objc_autoreleasePoolPop(v74);
      }

      uint64_t v67 = v103;
      uint64_t v70 = -[os_log_s countByEnumeratingWithState:objects:count:]( v103,  "countByEnumeratingWithState:objects:count:",  &v104,  v112,  16LL);
    }

    while (v70);
  }

  id v83 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  id v84 = (os_log_s *)objc_claimAutoreleasedReturnValue([v83 oslog]);

  id v85 = os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT);
  if (v93 < 1)
  {
    if (v85)
    {
      __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      *(_DWORD *)buf = 138543362;
      v114 = (uint64_t)v86;
      __int128 v88 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} no set-jobs resumed | MA_MILESTONE";
      __int128 v89 = v84;
      v90 = 12;
      goto LABEL_81;
    }
  }

  else if (v85)
  {
    __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
    __int128 v87 = @"s";
    *(_DWORD *)buf = 138543874;
    v114 = (uint64_t)v86;
    if (v93 == 1) {
      __int128 v87 = &stru_355768;
    }
    v115 = 2048;
    v116 = v93;
    v117 = 2114;
    v118 = (uint64_t)v87;
    __int128 v88 = "[%{public}@] {loadPersistedSetActiveJobDescriptors} resumed %ld set-job%{public}@ | MA_MILESTONE";
    __int128 v89 = v84;
    v90 = 32;
LABEL_81:
    _os_log_impl(&dword_0, v89, OS_LOG_TYPE_DEFAULT, v88, buf, v90);
  }

  id v7 = v92;
LABEL_83:

  -[MADAutoAssetControlManager _logPersistedTableOfContents:forComponentType:]( self,  "_logPersistedTableOfContents:forComponentType:",  @"loadPersistedSetActiveJobDescriptors",  @"SET_ACTIVE_JOB_DESCRIPTORS");
}

  if (v9)
  {
LABEL_44:
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v8 autoAssetEntries]);
    uint64_t v46 = -[MADAutoAssetControlManager doesSetDescriptor:coverRequestedAutoAssetEntries:]( self,  "doesSetDescriptor:coverRequestedAutoAssetEntries:",  v9,  v45);

    if (!v46) {
      goto LABEL_46;
    }

    id v10 = v85;
    goto LABEL_89;
  }

        if (!v12)
        {
LABEL_78:

          goto LABEL_79;
        }

        v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v31 persistedEntryID]);
        if (([v14 isOnFilesystem] & 1) == 0
          && ![v30 isOnFilesystem])
        {
          uint64_t v52 = 0LL;
LABEL_65:
          if ([v14 isOnFilesystem])
          {
            id v63 = v52;
          }

          else
          {
            v80 = v30;
            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
            uint64_t v65 = [v64 persistedEntryAlreadyExists:v47 fromLocation:v15];

            uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
            id v63 = (void *)objc_claimAutoreleasedReturnValue([v66 persistedEntry:v47 fromLocation:v15]);

            if (v63)
            {
              if (v65) {
                uint64_t v67 = @"ENTRY_MODIFY";
              }
              else {
                uint64_t v67 = @"ENTRY_ADD";
              }
              [v63 persistSecureCodedObject:v14 forKey:@"assetDescriptor"];
              uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
              uint64_t v69 = v31;
              uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v14 summary]);
              [v68 storePersistedEntry:v47 withEntrySummary:v70 fromLocation:v86];

              uint64_t v31 = v69;
              uint64_t v15 = v86;

              -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAsset Descriptor:baseForPatchDescriptor:message:",  v86,  @"JOB_DESCRIPTORS",  v67,  v47,  0LL,  0LL,  v14,  0LL,  v36);
            }

            else
            {
              uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              id v72 = (os_log_s *)objc_claimAutoreleasedReturnValue([v71 oslog]);

              if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
              {
                id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                id v76 = v31;
                id v77 = (__CFString *)objc_claimAutoreleasedReturnValue([v31 summary]);
                *(_DWORD *)buf = 138543874;
                __int128 v89 = v75;
                v90 = 2114;
                v91 = v86;
                v92 = 2114;
                v93 = v77;
                _os_log_error_impl( &dword_0,  v72,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@:trackDescriptor} unable to load active-job persisted-descriptor file | selector:%{public}@",  buf,  0x20u);

                uint64_t v31 = v76;
                uint64_t v15 = v86;
              }
            }

            uint64_t v30 = v80;
          }

          int v16 = v85;
          goto LABEL_77;
        }

        id v84 = v36;
        v50 = v30;
        v51 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownDescriptors](self, "persistedKnownDescriptors"));
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 persistedEntry:v47 fromLocation:v15]);

        if (!v52)
        {
          v56 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue([v56 oslog]);

          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
          {
            v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            uint64_t v74 = (__CFString *)objc_claimAutoreleasedReturnValue([v31 summary]);
            *(_DWORD *)buf = 138543874;
            __int128 v89 = v73;
            v90 = 2114;
            v91 = v15;
            v92 = 2114;
            v93 = v74;
            _os_log_error_impl( &dword_0,  v54,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@:trackDescriptor} unable to load persisted-descriptor file | selector:%{public}@",  buf,  0x20u);
          }

          uint64_t v52 = 0LL;
          goto LABEL_63;
        }

        uint64_t v30 = v50;
        uint64_t v53 = v50;
        if (v35)
        {
          uint64_t v54 = (os_log_s *)v14;
          uint64_t v55 = @"ENTRY_ADD";
        }

        else
        {
          uint64_t v54 = v53;
          if ((-[os_log_s isOnFilesystem](v53, "isOnFilesystem") & 1) == 0)
          {
            uint64_t v57 = (os_log_s *)v14;

            v79 = @"ENTRY_MODIFY";
            uint64_t v54 = v57;
            uint64_t v30 = v50;
            goto LABEL_55;
          }

          uint64_t v55 = @"ENTRY_MODIFY";
        }

        v79 = v55;
LABEL_55:
        if ([v14 isOnFilesystem])
        {
          uint64_t v58 = [v52 secureCodedObjectForKey:@"assetDescriptor" ofClass:objc_opt_class(MADAutoAssetDescriptor)];
          uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
          if (v59)
          {
            objc_msgSend(v59, "setNeverBeenLocked:", -[os_log_s neverBeenLocked](v54, "neverBeenLocked"));
            objc_msgSend(v59, "setIsOnFilesystem:", -[os_log_s isOnFilesystem](v54, "isOnFilesystem"));
            uint64_t v60 = v59;

            uint64_t v54 = v60;
            uint64_t v30 = v50;
          }
        }

        if (v87) {
          -[os_log_s setNeverBeenLocked:](v54, "setNeverBeenLocked:", 0LL);
        }
        [v52 persistSecureCodedObject:v54 forKey:@"assetDescriptor"];
        v61 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedKnownDescriptors](self, "persistedKnownDescriptors"));
        v62 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v54, "summary"));
        [v61 storePersistedEntry:v47 withEntrySummary:v62 fromLocation:v15];

        -[MADAutoAssetControlManager _logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescriptor:baseForPatchDescriptor:message:]( self,  "_logPersistedEntry:forComponentType:operation:forPersistedEntryID:forClientRequest:withJobUUID:withAssetDescri ptor:baseForPatchDescriptor:message:",  v15,  v81,  v79,  v47,  0LL,  0LL,  v54,  0LL,  v84);
LABEL_63:
        uint64_t v30 = v50;
LABEL_64:

        __int128 v36 = v84;
        goto LABEL_65;
      }
    }

    else
    {
      v81 = 0LL;
      __int128 v36 = @"job has just updated status";
      int v16 = v85;
      uint64_t v15 = v86;
      if (!a8) {
        goto LABEL_30;
      }
    }

    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v14 assetId]);
    if (v16) {
      +[MADAutoAssetHistory recordOperation:toHistoryType:fromClient:forAssetID:withSelector:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromClient:forAssetID:withSelector:",  a8,  0LL,  v16,  v43,  v31);
    }
    else {
      +[MADAutoAssetHistory recordOperation:toHistoryType:fromLayer:forAssetID:withSelector:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromLayer:forAssetID:withSelector:",  a8,  0LL,  1LL,  v43,  v31);
    }

    uint64_t v15 = v86;
    goto LABEL_30;
  }

  int v19 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
  id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 diag]);
  id v21 = objc_alloc(&OBJC_CLASS___NSString);
  id v22 = (void *)objc_claimAutoreleasedReturnValue([v14 summary]);
  id v23 = -[NSString initWithFormat:]( v21,  "initWithFormat:",  @"{trackDescriptor} nil or blank-entry jobDescriptor:%@",  v22);
  [v20 trackAnomaly:@"AUTO-CONTROL" forReason:v23 withResult:6103 withError:0];

LABEL_79:
}

        id v23 = v193;
        p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
        goto LABEL_42;
      }

      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue([v28 oslog]);

      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v26 safeSummary]);
        *(_DWORD *)buf = 138543618;
        v205 = v30;
        v206 = 2114;
        v207 = v31;
        _os_log_impl( &dword_0,  v29,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {ReportCatalogDecideFound} filtering out asset (empty entry) | metadata:%{public}@",  buf,  0x16u);
      }

  id v22 = MAErrorWithUnderlyingUserInfoAndString(@"com.apple.MobileAssetError.Download", a1, v11, v17, v15);
  id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);

  return v23;
}

  objc_autoreleasePoolPop(v16);
  if (a7 && v29) {
    *a7 = v29;
  }
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v60 = v32;

  return v60;
}

  __break(1u);
LABEL_42:
  result = (uint64_t)sub_237300((uint64_t)a3);
  a3 = (char *)result;
LABEL_32:
  if (v17 < *((void *)a3 + 2))
  {
    a3[v17 + 32] = v4;
    goto LABEL_34;
  }

  __break(1u);
  return result;
}

LABEL_36:
}

        uint64_t v60 = NSDebugDescriptionErrorKey;
        id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No MobileAssetBrain update was found"));
        v61 = v7;
        id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v61,  &v60,  1LL));
        id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  122LL,  v8));
        id v6 = 0LL;
        goto LABEL_4;
      }
    }

    else
    {
      id v20 = 0LL;
      if (v19) {
        goto LABEL_9;
      }
    }

    id v22 = 0LL;
    goto LABEL_18;
  }

  id v5 = v4;
  id v6 = 0LL;
LABEL_3:
  v62[0] = NSDebugDescriptionErrorKey;
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MobileAssetBrain scan failed"));
  v62[1] = NSUnderlyingErrorKey;
  v63[0] = v7;
  v63[1] = v5;
  id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v63,  v62,  2LL));
  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  120LL,  v8));

LABEL_4:
LABEL_5:
  objc_storeStrong((id *)(*(void *)(a1 + 56) + 32LL), v6);
  id v10 = *(void **)(a1 + 64);
  uint64_t v11 = *(dispatch_queue_s **)(*(void *)(a1 + 56) + 16LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __64__MABrainScanner_locateAvailableUpdateBrain_options_completion___block_invoke_3;
  block[3] = &unk_34E0F0;
  v56 = v9;
  uint64_t v57 = v10;
  uint64_t v55 = v6;
  uint64_t v12 = v9;
  uint64_t v13 = v6;
  dispatch_async(v11, block);
}

      *(void *)(a1 + 16) = v14;
      return v12;
    case 2:
      uint64_t v13 = *a5 - 8;
      uint64_t v12 = 4294967125LL;
      goto LABEL_19;
  }

  if (a3 != 3) {
    return 4294967289LL;
  }
  uint64_t v13 = *a5 - 4;
  uint64_t v12 = 4294967135LL;
LABEL_19:
  if (v13 >= 0xFFFFFFFE) {
    goto LABEL_20;
  }
  return v12;
}

LABEL_40:
        objc_autoreleasePoolPop(context);
        -[NSMutableArray addObject:](v61, "addObject:", v14);
LABEL_41:
        id v7 = v62;
        id v6 = v63;
        p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
LABEL_42:

        objc_autoreleasePoolPop(v67);
        id v10 = v68 + 1;
      }

      while ((id)(v68 + 1) != v6);
      id v6 = [obj countByEnumeratingWithState:&v82 objects:v92 count:16];
    }

    while (v6);
  }

  id v76 = 0u;
  id v77 = 0u;
  uint64_t v74 = 0u;
  id v75 = 0u;
  uint64_t v54 = v61;
  uint64_t v55 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v54,  "countByEnumeratingWithState:objects:count:",  &v74,  v86,  16LL);
  if (v55)
  {
    v56 = v55;
    uint64_t v57 = *(void *)v75;
    do
    {
      for (uint64_t i = 0LL; i != v56; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v75 != v57) {
          objc_enumerationMutation(v54);
        }
        uint64_t v59 = *(void *)(*((void *)&v74 + 1) + 8LL * (void)i);
        uint64_t v60 = objc_autoreleasePoolPush();
        -[MADAutoAssetStager _removeDescriptorFromSuccessfullyStaged:message:]( v66,  "_removeDescriptorFromSuccessfullyStaged:message:",  v59,  @"remove all eliminate-selectors from set of successfully staged descriptors");
        -[MADAutoAssetStager _removeStagedAssetFromFilesystem:forHistoryOperation:]( v66,  "_removeStagedAssetFromFilesystem:forHistoryOperation:",  v59,  300LL);
        objc_autoreleasePoolPop(v60);
      }

      v56 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v54,  "countByEnumeratingWithState:objects:count:",  &v74,  v86,  16LL);
    }

    while (v56);
  }
}

      __int128 v35 = v77 + 1;
      if ((id)(v77 + 1) == v76)
      {
        id v76 = [v7 countByEnumeratingWithState:&v92 objects:v102 count:16];
        if (!v76) {
          goto LABEL_46;
        }
        goto LABEL_19;
      }
    }

    obja = v41;

LABEL_39:
    goto LABEL_40;
  }

  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 40) locksBySelector]);
  id v4 = v1;
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) persistedEntryID]);
  id v6 = [v3 safeObjectForKey:v5 ofClass:objc_opt_class(MANAutoAssetSetLock)];
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

  if (v7)
  {
    uint64_t v82 = v4;
    __int128 v86 = 0u;
    __int128 v87 = 0u;
    id v84 = 0u;
    id v85 = 0u;
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 lockReasons]);
    id v9 = [v8 countByEnumeratingWithState:&v84 objects:v96 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v85;
      uint64_t v12 = &MobileAssetKeyManager__metaData.ivars;
      v78 = *(void *)v85;
      do
      {
        uint64_t v13 = 0LL;
        id obj = v10;
        do
        {
          if (*(void *)v85 != v11) {
            objc_enumerationMutation(v8);
          }
          uint64_t v14 = *(void *)(*((void *)&v84 + 1) + 8LL * (void)v13);
          uint64_t v15 = objc_autoreleasePoolPush();
          int v16 = (void *)objc_claimAutoreleasedReturnValue([v7 lockReasons]);
          id v17 = [v16 safeObjectForKey:v14 ofClass:objc_opt_class(v12[246])];
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);

          if (v18)
          {
            int v19 = (void *)objc_claimAutoreleasedReturnValue([v18 clientLockReason]);
            id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 lockReason]);

            if (v20)
            {
              id v21 = v8;
              id v22 = v7;
              id v23 = *(void **)(*(void *)(*(void *)(v82 + 48) + 8LL) + 40LL);
              id v24 = (void *)objc_claimAutoreleasedReturnValue([v18 clientLockReason]);
              id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 lockReason]);
              id v26 = [v23 safeObjectForKey:v25 ofClass:objc_opt_class(NSNumber)];
              char v27 = (void *)objc_claimAutoreleasedReturnValue(v26);

              uint64_t v28 = objc_alloc(&OBJC_CLASS___NSNumber);
              if (v27)
              {
                uint64_t v29 = -[NSNumber initWithLong:]( v28,  "initWithLong:",  (char *)[v18 activeLockCount] + (int)objc_msgSend(v27, "intValue"));
              }

              else
              {
                uint64_t v29 = -[NSNumber initWithLong:](v28, "initWithLong:", [v18 activeLockCount]);
              }

              uint64_t v30 = *(void **)(*(void *)(*(void *)(v82 + 48) + 8LL) + 40LL);
              uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v18 clientLockReason]);
              id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 lockReason]);
              [v30 setSafeObject:v29 forKey:v32];

              id v7 = v22;
              id v8 = v21;
              uint64_t v11 = v78;
              id v10 = obj;
              uint64_t v12 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
            }
          }

          objc_autoreleasePoolPop(v15);
          uint64_t v13 = (char *)v13 + 1;
        }

        while (v10 != v13);
        id v10 = [v8 countByEnumeratingWithState:&v84 objects:v96 count:16];
      }

      while (v10);
    }
  }

  else
  {
    uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 40) logger]);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v71 oslog]);

    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      id v72 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 40) summary]);
      v73 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 32) summary]);
      *(_DWORD *)buf = 138543618;
      v98 = v72;
      v99 = 2114;
      v100 = v73;
      _os_log_impl( &dword_0,  (os_log_t)v8,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {newCurrentLockUsageForSelector} no assetLock on locksBySelector for fullAssetSelector:%{public}@",  buf,  0x16u);
    }
  }

LABEL_46:
}

LABEL_41:
              goto LABEL_42;
            }

            ++v144;
            if (!v152) {
              goto LABEL_40;
            }
            uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
            v56 = (os_log_s *)objc_claimAutoreleasedReturnValue([v69 oslog]);

            if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_38;
            }
            uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v29 fullAssetSelector]);
            uint64_t v58 = (char *)objc_claimAutoreleasedReturnValue([v57 summary]);
            uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v154 fullAssetSelector]);
            uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v59 summary]);
            *(_DWORD *)buf = 138543618;
            v172 = v58;
            v173 = 2114;
            v174 = (uint64_t)v60;
            v61 = v56;
            v62 = "\n{chooseNewerSetDescriptor} | leftRightSame | left:%{public}@ | right:%{public}@";
          }

          id v17 = v192;
        }

      if (v24 != v17 + 1) {
        goto LABEL_84;
      }
    }

    int v16 = v45 | (2 * v19);
    result = swift_unknownObjectRetain(v10);
    v48 = a2;
    uint64_t v14 = v10;
    if (v4)
    {
      unsigned __int8 v49 = v16;
      id v8 = v18;
      a2 = v47;
      char v27 = v47;
      uint64_t v14 = v10;
      goto LABEL_57;
    }

    __break(1u);
LABEL_41:
    id v39 = v13;
    id v32 = sub_212358((char *)(v11 > 1), v4, 1, a4);
    uint64_t v13 = v39;
    a4 = v32;
LABEL_22:
    *((void *)a4 + 2) = v4;
    *(void *)&a4[8 * v13 + 32] = 0LL;
    id v25 = *((void *)v6 + 2);
    if (v25)
    {
      id v25 = *(void *)v8;
      id v23 = *((void *)a4 + 3);
      v13 += 2LL;
      if (v4 < v23 >> 1)
      {
LABEL_24:
        *((void *)a4 + 2) = v13;
        *(void *)&a4[8 * v4 + 32] = v25;
LABEL_37:
        uint64_t v44 = a4;
        sub_2328BC((uint64_t)v6, v8, *((void *)v6 + 2) != 0LL, (2LL * *((void *)v6 + 2)) | 1);
        swift_bridgeObjectRelease(v6);
        sub_222A18(v9);
        swift_unknownObjectRelease(v7);
        return v44;
      }
    }

    else
    {
      __break(1u);
    }

    __int128 v37 = v25;
    uint64_t v40 = v13;
    unsigned int v33 = sub_212358((char *)(v23 > 1), v13, 1, a4);
    id v25 = v37;
    uint64_t v13 = v40;
    a4 = v33;
    goto LABEL_24;
  }

  id v4 = _swiftEmptyArrayStorage[2];
  if (v4 >= 2) {
    goto LABEL_19;
  }
LABEL_15:
  swift_bridgeObjectRelease(v6);
  id v20 = sub_222964();
  id v21 = swift_allocError(&type metadata for CryptoKitASN1Error, v20, 0LL, 0LL);
  *id v22 = 2;
  swift_willThrow(v21);
  sub_222A18(v9);
  return (char *)swift_unknownObjectRelease(v45);
}

LABEL_51:
      objc_autoreleasePoolPop(v18);
      int v16 = (char *)v16 + 1;
    }

    while (v16 != v87);
    uint64_t v68 = [v13 countByEnumeratingWithState:&v93 objects:v104 count:16];
    __int128 v87 = v68;
  }

  while (v68);

  id v9 = v81;
  if ((v76 & 1) != 0)
  {
    if ((v88 & 1) == 0)
    {
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager logger](self, "logger"));
      uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue([v69 oslog]);

      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
      {
        uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetStager _updateLatestSummary](self, "_updateLatestSummary"));
        id v72 = (__CFString *)objc_claimAutoreleasedReturnValue([v13 safeSummary]);
        *(_DWORD *)buf = 138543874;
        v99 = (uint64_t)v71;
        v100 = 2114;
        v101 = v10;
        v102 = 2114;
        v103 = v72;
        _os_log_error_impl( &dword_0,  v70,  OS_LOG_TYPE_ERROR,  "%{public}@\n [AUTO-STAGER] {newAssetMetadataFromAssetCatalog} Assets array in set-catalog lookup response missing asset-spe cifier | assetSpecifier:%{public}@ | autoAssetSetCatalog:%{public}@",  buf,  0x20u);
      }

      goto LABEL_64;
    }

    goto LABEL_65;
  }

LABEL_52:
  v51 = [v6 patchedFromBaseFilesystemBytes];
  if (v51 != [v7 patchedFromBaseFilesystemBytes])
  {
    objc_msgSend(v6, "setPatchedFromBaseFilesystemBytes:", objc_msgSend(v7, "patchedFromBaseFilesystemBytes"));
    LOBYTE(v26) = 1;
  }

  uint64_t v52 = [v6 patchingAttempted];
  if (v52 != [v7 patchingAttempted])
  {
    objc_msgSend(v6, "setPatchingAttempted:", objc_msgSend(v7, "patchingAttempted"));
    LOBYTE(v26) = 1;
  }

  uint64_t v53 = [v6 stagedPriorToAvailable];
  if (v53 != [v7 stagedPriorToAvailable])
  {
    objc_msgSend(v6, "setStagedPriorToAvailable:", objc_msgSend(v7, "stagedPriorToAvailable"));
    LOBYTE(v26) = 1;
  }

  uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v6 stagedFromOSVersion]);
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v7 stagedFromOSVersion]);
  v56 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v54, v55);

  if ((v56 & 1) == 0)
  {
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v7 stagedFromOSVersion]);
    [v6 setStagedFromOSVersion:v26];

    LOBYTE(v26) = 1;
  }

  uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v6 stagedFromBuildVersion]);
  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v7 stagedFromBuildVersion]);
  uint64_t v59 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v57, v58);

  if ((v59 & 1) == 0)
  {
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v7 stagedFromBuildVersion]);
    [v6 setStagedFromBuildVersion:v26];

    LOBYTE(v26) = 1;
  }

  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v6 patchingAttemptError]);
  if (v60)
  {
  }

  else
  {
    v61 = (void *)objc_claimAutoreleasedReturnValue([v7 patchingAttemptError]);

    if (v61)
    {
      id v26 = (void *)objc_claimAutoreleasedReturnValue([v7 patchingAttemptError]);
      [v6 setPatchingAttemptError:v26];

      LOBYTE(v26) = 1;
    }
  }

    id v32 = 0;
  }

  else
  {
    id v32 = 1;
  }

                      id v2 = v108;

                      goto LABEL_52;
                    }

                    id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
                    __int128 v36 = (os_log_s *)objc_claimAutoreleasedReturnValue([v38 oslog]);

                    id v39 = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
                    if (v35)
                    {
                      if (!v39) {
                        goto LABEL_51;
                      }
                      *(_DWORD *)buf = 138543874;
                      v125 = (os_log_s *)v6;
                      v126 = 2114;
                      v127 = log;
                      v128 = 2114;
                      v129 = v35;
                      uint64_t v40 = v36;
                      v41 = "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} Unable to create descriptor | path:%{"
                            "public}@ | assetType:%{public}@ | reasons:%{public}@";
                      uint64_t v42 = 32;
                    }

                    else
                    {
                      if (!v39) {
                        goto LABEL_51;
                      }
                      *(_DWORD *)buf = 138543618;
                      v125 = (os_log_s *)v6;
                      v126 = 2114;
                      v127 = log;
                      uint64_t v40 = v36;
                      v41 = "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} Unable to create descriptor | path:%{"
                            "public}@ | assetType:%{public}@";
                      uint64_t v42 = 22;
                    }

                    _os_log_error_impl(&dword_0, v40, OS_LOG_TYPE_ERROR, v41, buf, v42);
                    goto LABEL_51;
                  }

                  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
                  __int128 v34 = (id)objc_claimAutoreleasedReturnValue([v37 oslog]);

                  if (os_log_type_enabled((os_log_t)v34, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138543874;
                    v125 = (os_log_s *)v6;
                    v126 = 2114;
                    v127 = log;
                    v128 = 2114;
                    v129 = (os_log_s *)v27;
                    _os_log_impl( &dword_0,  (os_log_t)v34,  OS_LOG_TYPE_DEFAULT,  "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} Not migrating since not an auto-asset | pat h:%{public}@ | assetType:%{public}@ | assetID:%{public}@",  buf,  0x20u);
                  }

                  __int128 v35 = 0LL;
LABEL_52:

                  objc_autoreleasePoolPop(v28);
                  id v26 = (char *)v26 + 1;
                  id v25 = log;
                  p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                  id v23 = v110;
                }

                while (v111 != v26);
                v111 = [obj countByEnumeratingWithState:&v115 objects:v132 count:16];
                if (!v111)
                {
                  uint64_t v13 = v95;
                  uint64_t v15 = v96;
                  id v17 = v94;
                  uint64_t v18 = v97;
                  id v24 = obj;
                  goto LABEL_59;
                }
              }
            }

            id v84 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
            id v24 = (void *)objc_claimAutoreleasedReturnValue([v84 oslog]);

            if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138543618;
              v125 = (os_log_s *)v6;
              v126 = 2114;
              v127 = log;
              _os_log_impl( &dword_0,  (os_log_t)v24,  OS_LOG_TYPE_DEFAULT,  "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} No pre-installed assets for asset-type | path:%{p ublic}@ | assetType:%{public}@",  buf,  0x16u);
            }

LABEL_42:
        int v19 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
        goto LABEL_43;
      }

      if (-[__objc2_ivar_list stringIsEqual:to:](p_ivars[155], "stringIsEqual:to:", v21, @"Assets"))
      {
        __int128 v34 = objc_opt_class(v19[153]);
        if ((objc_opt_isKindOfClass(v67, v34) & 1) != 0)
        {
          __int128 v35 = [v14 safeObjectForKey:@"Assets" ofClass:objc_opt_class(v19[153])];
          __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
          uint64_t v70 = 0u;
          uint64_t v71 = 0u;
          id v72 = 0u;
          v73 = 0u;
          id obj = v36;
          __int128 v37 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v70,  v78,  16LL);
          if (v37)
          {
            id v38 = v37;
            id v39 = *(void *)v71;
            uint64_t v40 = (unint64_t)v62;
            while (2)
            {
              for (uint64_t i = 0LL; i != v38; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v71 != v39) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v42 = *(void **)(*((void *)&v70 + 1) + 8LL * (void)i);
                uint64_t v43 = objc_autoreleasePoolPush();
                uint64_t v44 = objc_claimAutoreleasedReturnValue([v42 safeStringForKey:@"AssetFormat"]);
                uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v42 safeStringForKey:@"AssetSpecifier"]);
                if (-[__objc2_ivar_list stringIsEqual:to:](p_ivars[155], "stringIsEqual:to:", v45, v69))
                {
                  if (!v6)
                  {
                    unsigned __int8 v49 = v42;

                    objc_autoreleasePoolPop(v43);
                    uint64_t v40 = (unint64_t)v49;
                    goto LABEL_41;
                  }

                  if (-[__objc2_ivar_list stringIsEqual:to:](p_ivars[155], "stringIsEqual:to:", v45, v69))
                  {
                    if (v44 | v40)
                    {
                      if (+[MADAutoAssetDescriptor isMorePreferredAssetFormat:comparedTo:]( &OBJC_CLASS___MADAutoAssetDescriptor,  "isMorePreferredAssetFormat:comparedTo:",  v44,  v64))
                      {
                        id v63 = v42;

                        uint64_t v46 = (id)v44;
                        uint64_t v64 = v46;
                        uint64_t v40 = (unint64_t)v63;
                      }

                      p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                    }

                    else
                    {
                      uint64_t v40 = v42;
                    }
                  }
                }

                objc_autoreleasePoolPop(v43);
              }

              id v38 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v70,  v78,  16LL);
              if (v38) {
                continue;
              }
              break;
            }
          }

          else
          {
            uint64_t v40 = (unint64_t)v62;
          }

      id v39 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue([v39 oslog]);

      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        v41 = (NSMutableString *)objc_claimAutoreleasedReturnValue([v10 summary]);
        *(_DWORD *)buf = 138543618;
        v151 = v11;
        v152 = 2114;
        v153 = v41;
        _os_log_impl( &dword_0,  v40,  OS_LOG_TYPE_DEFAULT,  "[MORE_CLIENT_REQUESTS] {%{public}@:removeCurrentJob} auto-asset-job indicated removal but has more to do | eve ntInfo:%{public}@",  buf,  0x16u);
      }

      goto LABEL_45;
    }

    if (v29 && [v29 autoAssetSetJob])
    {
      -[MADAutoAssetControlManager removeCurrentSetJob:schedulerInvolved:potentialNetworkFailure:fromLocation:historyOperation:]( self,  "removeCurrentSetJob:schedulerInvolved:potentialNetworkFailure:fromLocation:historyOperation:",  v10,  v144,  v143,  v11,  333LL);
LABEL_45:

LABEL_46:
      goto LABEL_47;
    }

    uint64_t v42 = objc_claimAutoreleasedReturnValue([v10 autoAssetSelector]);
    v138 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    if (v42)
    {
      v133 = (void *)v42;
    }

    else
    {
      v133 = (void *)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
      unsigned __int8 v49 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobBySelector:](self, "currentJobBySelector:"));

      if (v49)
      {
        v50 = (void *)objc_claimAutoreleasedReturnValue([v133 assetVersion]);

        v51 = v133;
        if (v50) {
          uint64_t v52 = v21;
        }
        else {
          uint64_t v52 = v24;
        }
        if (!v50) {
          id v24 = v51;
        }
        v133 = v51;
        if (v50) {
          id v21 = v51;
        }

        __int128 v35 = (void *)v49;
      }

      else
      {
        __int128 v35 = 0LL;
      }
    }

    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v10 autoAssetStatus]);

    v137 = v35;
    if (v53)
    {
      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v10 autoAssetStatus]);
      if (v21)
      {
        uint64_t v55 = (NSString *)objc_claimAutoreleasedReturnValue([v21 assetVersion]);
        v134 = v24;
        v56 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@(with-version)",  v11);
        -[MADAutoAssetControlManager updateAutoAssetStatus:forActiveJobUUID:withLatestJobStatus:matchingAssetVersion:fromLocation:]( self,  "updateAutoAssetStatus:forActiveJobUUID:withLatestJobStatus:matchingAssetVersion:fromLocation:",  v21,  v18,  v54,  v55,  v56);

        id v24 = v134;
      }

      else
      {
        uint64_t v55 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@(without-version)",  v11);
        -[MADAutoAssetControlManager updateAutoAssetStatus:forActiveJobUUID:withLatestJobStatus:matchingAssetVersion:fromLocation:]( self,  "updateAutoAssetStatus:forActiveJobUUID:withLatestJobStatus:matchingAssetVersion:fromLocation:",  v24,  v18,  v54,  0LL,  v55);
      }

      __int128 v35 = v137;
    }

    if (v38)
    {
      -[NSMutableString appendString:](v138, "appendString:", @" | bySelector");
    }

    else
    {
      uint64_t v57 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager stagerCurrentJob](self, "stagerCurrentJob"));
      if (v57
        && (uint64_t v58 = (void *)v57,
            v135 = v24,
            uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager stagerCurrentJobUUID](self, "stagerCurrentJobUUID")),
            uint64_t v60 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v18, v59),
            v59,
            id v24 = v135,
            v58,
            v60))
      {
        -[NSMutableString appendString:](v138, "appendString:", @" | stager-current-job");
      }

      else
      {
        v61 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsByUUID](self, "currentJobsByUUID"));
        [v61 removeObjectForKey:v18];

        -[NSMutableString appendFormat:](v138, "appendFormat:", @" | autoAssetJobUUID:%@", v18);
      }

      __int128 v35 = v137;
    }

    if (v35)
    {
      v62 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager jobSelectorKey:](self, "jobSelectorKey:", v133));
      if (v62)
      {
        id v63 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager currentJobsBySelector](self, "currentJobsBySelector"));
        [v63 removeObjectForKey:v62];

        if (v38)
        {
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v137 summary]);
          -[NSMutableString appendFormat:](v138, "appendFormat:", @" | autoJobBySelector:%@ | job:%@", v62, v64);
        }

        else
        {
          -[NSMutableString appendFormat:](v138, "appendFormat:", @" | autoJobBySelector:%@", v62);
        }

        __int128 v35 = v137;
      }

      else
      {
        -[NSMutableString appendString:](v138, "appendString:", @" | nil-jobSelectorKey");
      }

      if (v29)
      {
        uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v35 summary]);
        -[NSMutableString appendFormat:](v138, "appendFormat:", @"job:%@", v65);
      }
    }

    else
    {
      -[NSMutableString appendString:](v138, "appendString:", @" | byUUID");
    }

    if (!v21)
    {
      uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
      id v21 = (id)objc_claimAutoreleasedReturnValue([v66 assetVersion]);

      if (v21) {
        id v21 = (id)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
      }
    }

    v132 = v29;
    if (!v24)
    {
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);

      if (v67)
      {
        uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
        uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v68 assetVersion]);

        if (v69)
        {
          uint64_t v70 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
          uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
          id v72 = (void *)objc_claimAutoreleasedReturnValue([v71 assetType]);
          v73 = (void *)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
          uint64_t v74 = v18;
          id v75 = (void *)objc_claimAutoreleasedReturnValue([v73 assetSpecifier]);
          id v76 = -[MAAutoAssetSelector initForAssetType:withAssetSpecifier:]( v70,  "initForAssetType:withAssetSpecifier:",  v72,  v75);

          uint64_t v18 = v74;
          uint64_t v29 = v132;

          id v24 = v76;
        }

        else
        {
          id v24 = (id)objc_claimAutoreleasedReturnValue([v29 autoAssetSelector]);
        }

        __int128 v35 = v137;
      }

      else
      {
        id v24 = 0LL;
      }
    }

    -[MADAutoAssetControlManager removeActiveJobForFullSelector:removingFullSelector:alsoRemovingNoVersionSelector:]( self,  "removeActiveJobForFullSelector:removingFullSelector:alsoRemovingNoVersionSelector:",  v11,  v21,  v24);
    v136 = v24;
    if (v21)
    {
      id v77 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager activelyEliminatingSelectors](self, "activelyEliminatingSelectors"));
      v78 = (void *)objc_claimAutoreleasedReturnValue([v21 persistedEntryID]);
      v79 = [v77 safeObjectForKey:v78 ofClass:objc_opt_class(MADAutoAssetEliminate)];
      v80 = (void *)objc_claimAutoreleasedReturnValue(v79);

      v81 = 0;
      id obj = v80;
      if (v80 && v18)
      {
        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v80 activeJobsByUUID]);
        id v83 = [v82 safeObjectForKey:v18 ofClass:objc_opt_class(NSString)];
        id v84 = (void *)objc_claimAutoreleasedReturnValue(v83);

        __int128 v35 = v137;
        if (v84)
        {
          if (+[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v84, v18))
          {
            id v85 = (void *)objc_claimAutoreleasedReturnValue([v80 activeJobsByUUID]);
            [v85 removeObjectForKey:v84];

            v81 = 1;
          }

          else
          {
            v81 = 0;
          }
        }

        else
        {
          __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          __int128 v87 = (os_log_s *)objc_claimAutoreleasedReturnValue([v86 oslog]);

          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
          {
            __int128 v88 = (NSMutableString *)(id)objc_claimAutoreleasedReturnValue([v21 summary]);
            __int128 v89 = v29;
            v90 = (id)objc_claimAutoreleasedReturnValue([obj summary]);
            *(_DWORD *)buf = 138544130;
            v151 = v11;
            v152 = 2114;
            v153 = v88;
            v154 = 2114;
            v155 = v18;
            v156 = 2114;
            v157 = v90;
            _os_log_impl( &dword_0,  v87,  OS_LOG_TYPE_DEFAULT,  "\n [ELIMINATE]{%{public}@:removeCurrentJob} no active job withVersionSelector:%{public}@ | autoAssetJobUUID:% {public}@ | eliminateTracker:%{public}@",  buf,  0x2Au);

            uint64_t v29 = v89;
          }

          v81 = 0;
          __int128 v35 = v137;
        }

        id v24 = v136;
      }

      else
      {
        __int128 v35 = v137;
      }
    }

    else
    {
      v81 = 0;
      id obj = 0LL;
    }

    if (!v24 || v81)
    {
      v94 = obj;
      if (v81) {
        goto LABEL_133;
      }
      goto LABEL_122;
    }

    v91 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager activelyEliminatingSelectors](self, "activelyEliminatingSelectors"));
    v92 = (void *)objc_claimAutoreleasedReturnValue([v24 persistedEntryID]);
    v93 = [v91 safeObjectForKey:v92 ofClass:objc_opt_class(MADAutoAssetEliminate)];
    v94 = (void *)objc_claimAutoreleasedReturnValue(v93);

    if (!v94 || !v18)
    {
      if (!v18) {
        goto LABEL_134;
      }
      goto LABEL_123;
    }

    v95 = (void *)objc_claimAutoreleasedReturnValue([v94 activeJobsByUUID]);
    v96 = [v95 safeObjectForKey:v18 ofClass:objc_opt_class(NSString)];
    v97 = (void *)objc_claimAutoreleasedReturnValue(v96);

    v81 = v97 != 0LL;
    if (v97)
    {
      if (!+[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v97, v18))
      {
        v81 = 0;
        __int128 v35 = v137;
LABEL_121:

        uint64_t v29 = v132;
        if (v81) {
          goto LABEL_133;
        }
LABEL_122:
        if (v18)
        {
LABEL_123:
          v142 = v18;
          v129 = v11;
          v131 = v21;
          v147 = 0u;
          v148 = 0u;
          v145 = 0u;
          v146 = 0u;
          obja = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager activelyEliminatingSelectors](self, "activelyEliminatingSelectors"));
          v103 = [obja countByEnumeratingWithState:&v145 objects:v149 count:16];
          if (v103)
          {
            v104 = v103;
            v105 = *(void *)v146;
            while (2)
            {
              v106 = 0LL;
              v107 = v94;
              do
              {
                if (*(void *)v146 != v105) {
                  objc_enumerationMutation(obja);
                }
                v108 = *(void *)(*((void *)&v145 + 1) + 8LL * (void)v106);
                v109 = objc_autoreleasePoolPush();
                v110 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager activelyEliminatingSelectors]( self,  "activelyEliminatingSelectors"));
                v111 = [v110 safeObjectForKey:v108 ofClass:objc_opt_class(MADAutoAssetEliminate)];
                v94 = (void *)objc_claimAutoreleasedReturnValue(v111);

                if (v94)
                {
                  v112 = (void *)objc_claimAutoreleasedReturnValue([v94 activeJobsByUUID]);
                  v113 = [v112 safeObjectForKey:v142 ofClass:objc_opt_class(NSString)];
                  v114 = (void *)objc_claimAutoreleasedReturnValue(v113);

                  if (v114)
                  {
                    v119 = (void *)objc_claimAutoreleasedReturnValue([v94 activeJobsByUUID]);
                    [v119 removeObjectForKey:v114];

                    objc_autoreleasePoolPop(v109);
                    uint64_t v11 = v129;
                    id v21 = v131;
                    uint64_t v18 = v142;
                    uint64_t v29 = v132;
                    __int128 v35 = v137;
                    goto LABEL_140;
                  }
                }

                objc_autoreleasePoolPop(v109);
                v106 = (char *)v106 + 1;
                v107 = v94;
              }

              while (v104 != v106);
              v104 = [obja countByEnumeratingWithState:&v145 objects:v149 count:16];
              if (v104) {
                continue;
              }
              break;
            }
          }

          uint64_t v11 = v129;
          id v21 = v131;
          uint64_t v18 = v142;
          uint64_t v29 = v132;
          goto LABEL_134;
        }

        uint64_t v70 = v160;
        if (!v45) {
          uint64_t v70 = v160 + 1;
        }
        v160 = v70;
      }

      objc_autoreleasePoolPop(v30);
    }

    v158 = [obj countByEnumeratingWithState:&v167 objects:v186 count:16];
  }

  while (v158);
LABEL_49:

  v165 = 0u;
  v166 = 0u;
  v163 = 0u;
  v164 = 0u;
  v155 = (id)objc_claimAutoreleasedReturnValue([v151 latestDowloadedAtomicInstanceEntries]);
  v159 = [v155 countByEnumeratingWithState:&v163 objects:v185 count:16];
  if (!v159)
  {
    v161 = 0LL;
    obja = 0LL;
    goto LABEL_86;
  }

  v161 = 0LL;
  obja = 0LL;
  v157 = *(void *)v164;
  while (2)
  {
    v73 = 0LL;
    while (2)
    {
      if (*(void *)v164 != v157) {
        objc_enumerationMutation(v155);
      }
      uint64_t v74 = *(void **)(*((void *)&v163 + 1) + 8 * v73);
      id v75 = objc_autoreleasePoolPush();
      id v76 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      id v77 = (void *)objc_claimAutoreleasedReturnValue([v76 assetType]);
      v78 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      v79 = (void *)objc_claimAutoreleasedReturnValue([v78 assetSpecifier]);
      v80 = (void *)objc_claimAutoreleasedReturnValue([v12 assetSetEntryForAssetType:v77 forAssetSpecifier:v79]);

      if (!v80) {
        goto LABEL_82;
      }
      v81 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v81 assetType]);
      id v83 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      id v84 = (void *)objc_claimAutoreleasedReturnValue([v83 assetSpecifier]);
      id v85 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager findAtomicEntryForAssetType:forAssetSpecifier:representedByDescriptor:]( v162,  "findAtomicEntryForAssetType:forAssetSpecifier:representedByDescriptor:",  v82,  v84,  v150));

      __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v86 assetType]);
      __int128 v88 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      __int128 v89 = (void *)objc_claimAutoreleasedReturnValue([v88 assetSpecifier]);
      v90 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager findSetEntryForAssetType:forAssetSpecifier:representedByConfiguration:]( v162,  "findSetEntryForAssetType:forAssetSpecifier:representedByConfiguration:",  v87,  v89,  v12));

      if (!v85)
      {
        ++obja;
        if (!v152) {
          goto LABEL_79;
        }
        v107 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
        v94 = (os_log_s *)objc_claimAutoreleasedReturnValue([v107 oslog]);

        if (!os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        v102 = (char *)objc_claimAutoreleasedReturnValue([0 fullAssetSelector]);
        v98 = (char *)objc_claimAutoreleasedReturnValue([v102 summary]);
        v108 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue([v108 summary]);
        *(_DWORD *)buf = 138543618;
        v172 = v98;
        v173 = 2114;
        v174 = (uint64_t)v101;
        _os_log_impl( &dword_0,  v94,  OS_LOG_TYPE_DEFAULT,  "\n{chooseNewerSetDescriptor} | leftNotPresent | left:%{public}@ | right:%{public}@",  buf,  0x16u);

LABEL_75:
        goto LABEL_76;
      }

      v91 = objc_alloc(&OBJC_CLASS___SUCoreRestoreVersion);
      v92 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
      v93 = (void *)objc_claimAutoreleasedReturnValue([v92 assetVersion]);
      v94 = (os_log_s *)[v91 initWithRestoreVersion:v93];

      v95 = objc_alloc(&OBJC_CLASS___SUCoreRestoreVersion);
      v96 = (void *)objc_claimAutoreleasedReturnValue([v85 fullAssetSelector]);
      v97 = (void *)objc_claimAutoreleasedReturnValue([v96 assetVersion]);
      v98 = (char *)[v95 initWithRestoreVersion:v97];

      if (![v98 isComparable:v94])
      {
        v109 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue([v109 oslog]);

        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
        {
          v113 = (char *)objc_claimAutoreleasedReturnValue([v85 summary]);
          v114 = (void *)objc_claimAutoreleasedReturnValue([v74 summary]);
          *(_DWORD *)buf = 138543618;
          v172 = v113;
          v173 = 2114;
          v174 = (uint64_t)v114;
          _os_log_error_impl( &dword_0,  v101,  OS_LOG_TYPE_ERROR,  "\n {chooseNewerSetDescriptor} ignoring (invalid restore version) | foundLeftEntry:%{public}@ | nextRightEntry:%{public}@",  buf,  0x16u);
        }

        uint64_t v12 = v153;
        goto LABEL_76;
      }

      v99 = (char *)[v98 compare:v94];
      if (v99 == (char *)-1LL)
      {
        ++v146;
        uint64_t v12 = v153;
        if (!v152) {
          goto LABEL_77;
        }
        v110 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue([v110 oslog]);

        if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_76;
        }
        v143 = (void *)objc_claimAutoreleasedReturnValue([v85 fullAssetSelector]);
        v102 = (char *)objc_claimAutoreleasedReturnValue([v143 summary]);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
        v104 = (void *)objc_claimAutoreleasedReturnValue([v103 summary]);
        *(_DWORD *)buf = 138412546;
        v172 = v102;
        v173 = 2112;
        v174 = (uint64_t)v104;
        v105 = v101;
        v106 = "\n{chooseNewerSetDescriptor} | rightIsNewer | left:%@ | right:%@";
LABEL_74:
        _os_log_impl(&dword_0, v105, OS_LOG_TYPE_DEFAULT, v106, buf, 0x16u);

        uint64_t v12 = v153;
        goto LABEL_75;
      }

      uint64_t v12 = v153;
      if (v99 != (_BYTE *)&dword_0 + 1)
      {
        ++v144;
        if (!v152) {
          goto LABEL_77;
        }
        v111 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue([v111 oslog]);

        if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_76;
        }
        v143 = (void *)objc_claimAutoreleasedReturnValue([v85 fullAssetSelector]);
        v102 = (char *)objc_claimAutoreleasedReturnValue([v143 summary]);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
        v104 = (void *)objc_claimAutoreleasedReturnValue([v103 summary]);
        *(_DWORD *)buf = 138412546;
        v172 = v102;
        v173 = 2112;
        v174 = (uint64_t)v104;
        v105 = v101;
        v106 = "\n{chooseNewerSetDescriptor} | leftRightSame | left:%@ | right:%@";
        goto LABEL_74;
      }

      ++v145;
      if (v152)
      {
        v100 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue([v100 oslog]);

        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
        {
          v143 = (void *)objc_claimAutoreleasedReturnValue([v85 fullAssetSelector]);
          v102 = (char *)objc_claimAutoreleasedReturnValue([v143 summary]);
          v103 = (void *)objc_claimAutoreleasedReturnValue([v74 fullAssetSelector]);
          v104 = (void *)objc_claimAutoreleasedReturnValue([v103 summary]);
          *(_DWORD *)buf = 138543618;
          v172 = v102;
          v173 = 2114;
          v174 = (uint64_t)v104;
          v105 = v101;
          v106 = "\n{chooseNewerSetDescriptor} | leftIsNewer | left:%{public}@ | right:%{public}@";
          goto LABEL_74;
        }

  return (char)v26;
}

              -[NSMutableArray addObject:](v102, "addObject:", v12);
LABEL_43:
              id v8 = v98;
LABEL_44:
              id v10 = v100;
              goto LABEL_25;
            }

            id v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue([v32 oslog]);

            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v18 summary]);
              *(_DWORD *)buf = 138543618;
              v126 = v52;
              v127 = 2114;
              v128 = v53;
              _os_log_error_impl( &dword_0,  v30,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetDownloadedDescriptors} set-descriptor without latestDownloadedAtomicInstan ce - dropped | setDescriptor:%{public}@",  buf,  0x16u);
            }
          }

          else
          {
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue([v29 oslog]);

            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              *(_DWORD *)buf = 138543618;
              v126 = v31;
              v127 = 2114;
              v128 = v12;
              _os_log_error_impl( &dword_0,  v30,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetDownloadedDescriptors} unable to load set-descriptor | entryID:%{public}@",  buf,  0x16u);
            }
          }

          -[NSMutableArray addObject:](v102, "addObject:", v12);
LABEL_25:

          uint64_t v13 = v105;
          goto LABEL_26;
        }

        char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue([v27 oslog]);

        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          v51 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          *(_DWORD *)buf = 138543618;
          v126 = v51;
          v127 = 2114;
          v128 = v12;
          _os_log_error_impl( &dword_0,  v28,  OS_LOG_TYPE_ERROR,  "[%{public}@] {loadPersistedSetDownloadedDescriptors} unable to determine previous status | entryID:%{public}@",  buf,  0x16u);
        }

        -[NSMutableArray addObject:](v102, "addObject:", v12);
      }

      else
      {
        id v26 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v26 oslog]);

        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR)) {
          -[MADAutoAssetControlManager loadPersistedSetDownloadedDescriptors].cold.1((uint64_t)v131, (uint64_t)self);
        }
      }

            _os_log_impl(&dword_0, v28, OS_LOG_TYPE_DEFAULT, v29, buf, 0x20u);
          }

          else
          {
            id v32 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue([v32 oslog]);

            if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              goto LABEL_44;
            }
            char v27 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543874;
            v195 = (uint64_t)v27;
            v196 = 2114;
            v197 = v9;
            v198 = 2114;
            v199 = (uint64_t)v17;
            _os_log_error_impl( &dword_0,  v26,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to load auto-asset-descriptor | entryID:%{public}@",  buf,  0x20u);
          }

          goto LABEL_44;
        }
      }

      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue([v30 oslog]);

      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v49 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        v50 = (void *)v49;
        *(_DWORD *)buf = 138543874;
        v51 = @"N";
        if (v17) {
          v51 = v17;
        }
        v195 = v49;
        v196 = 2114;
        v197 = v9;
        v198 = 2114;
        v199 = (uint64_t)v51;
        _os_log_error_impl( &dword_0,  v31,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to determine previous status | entryID:%{public}@",  buf,  0x20u);
      }

      if (v17) {
        -[NSMutableArray addObject:](v177, "addObject:", v17);
      }
LABEL_46:
      objc_autoreleasePoolPop(v18);
      int v16 = (char *)v16 + 1;
    }

    while (v16 != v14);
    v121 = [obj countByEnumeratingWithState:&v188 objects:v204 count:16];
    uint64_t v14 = v121;
  }

  while (v121);
LABEL_121:

  v182 = 0u;
  v183 = 0u;
  v180 = 0u;
  v181 = 0u;
  v178 = v177;
  v125 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v178,  "countByEnumeratingWithState:objects:count:",  &v180,  v192,  16LL);
  if (v125)
  {
    v126 = v125;
    v127 = *(void *)v181;
    do
    {
      for (j = 0LL; j != v126; j = (char *)j + 1)
      {
        if (*(void *)v181 != v127) {
          objc_enumerationMutation(v178);
        }
        v129 = *(void *)(*((void *)&v180 + 1) + 8LL * (void)j);
        v130 = objc_autoreleasePoolPush();
        if (v129)
        {
          v131 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
          v132 = (void *)objc_claimAutoreleasedReturnValue([v131 persistedEntry:v129 fromLocation:v179]);

          v133 = [v132 secureCodedObjectForKey:@"assetDescriptor" ofClass:objc_opt_class(MADAutoAssetDescriptor)];
          v134 = (void *)objc_claimAutoreleasedReturnValue(v133);
          v135 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager persistedActiveJobs](self, "persistedActiveJobs"));
          [v135 removePersistedEntry:v129 fromLocation:@"resumeJobsWhenBeforeFirstUnlock"];

          -[MADAutoAssetControlManager _logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:]( self,  "_logPersistedRemovedEntry:forComponentType:removedPersistedEntryID:removedDescriptor:message:",  v179,  @"ACTIVE-JOBS",  v129,  v134,  @"removing stale active-persisted job");
        }

        else
        {
          v132 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
          v134 = (void *)objc_claimAutoreleasedReturnValue([v132 diag]);
          v136 = objc_alloc(&OBJC_CLASS___NSString);
          v137 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          v138 = -[NSString initWithFormat:]( v136,  "initWithFormat:",  @"{%@} nil entryID encountered on staleActivePersistedEntryIDs | %@",  v179,  v137);
          [v134 trackAnomaly:@"AUTO-CONTROL" forReason:v138 withResult:6108 withError:0];
        }

        objc_autoreleasePoolPop(v130);
      }

      v126 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v178,  "countByEnumeratingWithState:objects:count:",  &v180,  v192,  16LL);
    }

    while (v126);
  }

  v139 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  v140 = (os_log_s *)objc_claimAutoreleasedReturnValue([v139 oslog]);

  v141 = os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT);
  if (v153 < 1)
  {
    id v9 = v179;
    v123 = (os_log_s *)v154;
    if (v141)
    {
      v142 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      *(_DWORD *)buf = 138543618;
      v195 = (uint64_t)v142;
      v196 = 2114;
      v197 = v179;
      v144 = "[%{public}@] {%{public}@} no jobs resumed (now active) | MA_MILESTONE";
      v145 = v140;
      v146 = 22;
      goto LABEL_138;
    }
  }

  else
  {
    id v9 = v179;
    v123 = (os_log_s *)v154;
    if (v141)
    {
      v142 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      v143 = @"s";
      *(_DWORD *)buf = 138544130;
      v195 = (uint64_t)v142;
      v196 = 2114;
      if (v153 == 1) {
        v143 = &stru_355768;
      }
      v197 = v179;
      v198 = 2048;
      v199 = v153;
      v200 = 2114;
      v201 = (uint64_t)v143;
      v144 = "[%{public}@] {%{public}@} resumed %ld job%{public}@ (now active) | MA_MILESTONE";
      v145 = v140;
      v146 = 42;
LABEL_138:
      _os_log_impl(&dword_0, v145, OS_LOG_TYPE_DEFAULT, v144, buf, v146);
    }
  }

  uint64_t v11 = v152;
  uint64_t v12 = v155;
LABEL_140:

  -[MADAutoAssetControlManager _logPersistedTableOfContents:forComponentType:]( self,  "_logPersistedTableOfContents:forComponentType:",  v9,  @"ACTIVE-JOBS");
  -[MADAutoAssetControlManager setDownloadManagerEventsAwaitingResumed:]( self,  "setDownloadManagerEventsAwaitingResumed:",  v12);
}

                    goto LABEL_43;
                  }

                  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                  uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue([v55 oslog]);

                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                  {
                    v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                    *(_DWORD *)buf = 138543874;
                    v133 = (uint64_t)v47;
                    v134 = 2114;
                    v135 = v123;
                    v136 = 2114;
                    v137 = (uint64_t)v20;
                    unsigned __int8 v49 = v46;
                    v50 = "[%{public}@] {%{public}@} encountered auto-asset-set-descriptor without discoveredAtomicEntrie"
                          "s | entryID:%{public}@";
LABEL_39:
                    _os_log_impl(&dword_0, v49, OS_LOG_TYPE_DEFAULT, v50, buf, 0x20u);
LABEL_40:
                  }
                }

                else
                {
                  v51 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                  uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue([v51 oslog]);

                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                  {
                    v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                    *(_DWORD *)buf = 138543874;
                    v133 = (uint64_t)v47;
                    v134 = 2114;
                    v135 = v123;
                    v136 = 2114;
                    v137 = (uint64_t)v20;
                    unsigned __int8 v49 = v46;
                    v50 = "[%{public}@] {%{public}@} encountered auto-asset-set-descriptor without discoveredAtomicInstan"
                          "ce | entryID:%{public}@";
                    goto LABEL_39;
                  }
                }
              }

              else
              {
                v48 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue([v48 oslog]);

                if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                {
                  v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                  *(_DWORD *)buf = 138543874;
                  v133 = (uint64_t)v47;
                  v134 = 2114;
                  v135 = v123;
                  v136 = 2114;
                  v137 = (uint64_t)v20;
                  unsigned __int8 v49 = v46;
                  v50 = "[%{public}@] {%{public}@} encountered auto-asset-set-descriptor without assetSetIdentifier | entryID:%{public}@";
                  goto LABEL_39;
                }
              }
            }

            else
            {
              uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
              uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue([v45 oslog]);

              if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
              {
                v47 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                *(_DWORD *)buf = 138543874;
                v133 = (uint64_t)v47;
                v134 = 2114;
                v135 = v123;
                v136 = 2114;
                v137 = (uint64_t)v20;
                _os_log_error_impl( &dword_0,  v46,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to load auto-asset-set-descriptor | entryID:%{public}@",  buf,  0x20u);
                goto LABEL_40;
              }
            }

            -[NSMutableArray addObject:](v122, "addObject:", v20);
            id v8 = v123;
            goto LABEL_42;
          }
        }

        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue([v43 oslog]);

        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          uint64_t v52 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          uint64_t v53 = (void *)v52;
          *(_DWORD *)buf = 138543874;
          uint64_t v54 = @"N";
          if (v20) {
            uint64_t v54 = v20;
          }
          v133 = v52;
          v134 = 2114;
          v135 = v8;
          v136 = 2114;
          v137 = (uint64_t)v54;
          _os_log_error_impl( &dword_0,  v44,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} unable to determine previous status | entryID:%{public}@",  buf,  0x20u);
        }

        if (v20) {
          -[NSMutableArray addObject:](v122, "addObject:", v20);
        }
LABEL_43:
        objc_autoreleasePoolPop(v21);
        int v19 = (char *)v19 + 1;
      }

      while (v17 != v19);
      uint64_t v74 = [obj countByEnumeratingWithState:&v128 objects:v143 count:16];
      id v17 = v74;
      if (!v74)
      {
LABEL_70:

        id v76 = (os_log_s *)v122;
        v78 = (char *)-[NSMutableArray count](v122, "count");
        v79 = v111;
        if (v111)
        {
          v80 = v78;
          uint64_t v15 = v110;
          if ((uint64_t)v78 >= 1)
          {
            v81 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue([v81 oslog]);

            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
            {
              id v83 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              id v84 = @"s";
              *(_DWORD *)buf = 138544130;
              v133 = (uint64_t)v83;
              v134 = 2114;
              if (v80 == (_BYTE *)&dword_0 + 1) {
                id v84 = &stru_355768;
              }
              v135 = v8;
              v136 = 2048;
              v137 = (uint64_t)v80;
              v138 = 2114;
              v139 = (uint64_t)v84;
              _os_log_impl( &dword_0,  v82,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {%{public}@} discovered %ld potentially stale active-set-job%{public}@ (when before first u nlock) | waiting to be beyond first-unlock before clearing",  buf,  0x2Au);
            }

            goto LABEL_89;
          }
        }

        else
        {
          v126 = 0u;
          v127 = 0u;
          v124 = 0u;
          v125 = 0u;
          uint64_t v82 = v122;
          id v85 = -[os_log_s countByEnumeratingWithState:objects:count:]( v82,  "countByEnumeratingWithState:objects:count:",  &v124,  v142,  16LL);
          if (v85)
          {
            __int128 v86 = v85;
            __int128 v87 = *(void *)v125;
            do
            {
              for (uint64_t i = 0LL; i != v86; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v125 != v87) {
                  objc_enumerationMutation(v82);
                }
                __int128 v89 = *(void *)(*((void *)&v124 + 1) + 8LL * (void)i);
                v90 = objc_autoreleasePoolPush();
                if (v89)
                {
                  v91 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
                  v92 = (void *)objc_claimAutoreleasedReturnValue([v91 persistedEntry:v89 fromLocation:v8]);

                  v93 = [v92 secureCodedObjectForKey:@"assetSetDescriptor" ofClass:objc_opt_class(MADAutoSetDescriptor)];
                  v94 = (void *)objc_claimAutoreleasedReturnValue(v93);
                  v95 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
                  [v95 removePersistedEntry:v89 fromLocation:@"resumeSetJobsWhenBeforeFirstUnlock"];

                  id v8 = v123;
                  -[MADAutoAssetControlManager _logPersistedSetDescriptorRemoved:forComponentType:removedPersistedEntryID:removedSetDescriptor:message:]( self,  "_logPersistedSetDescriptorRemoved:forComponentType:removedPersistedEntryID:removedSetDescriptor:message:",  v123,  @"SET_ACTIVE_JOB_DESCRIPTORS",  v89,  v94,  @"removing stale active-persisted set-job");
                }

                else
                {
                  v92 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
                  v94 = (void *)objc_claimAutoreleasedReturnValue([v92 diag]);
                  v96 = objc_alloc(&OBJC_CLASS___NSString);
                  v97 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                  v98 = -[NSString initWithFormat:]( v96,  "initWithFormat:",  @"{%@} nil entryID encountered on staleActivePersistedEntryIDs | %@",  v123,  v97);
                  [v94 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v98 withResult:6108 withError:0];

                  id v8 = v123;
                }

                objc_autoreleasePoolPop(v90);
              }

              __int128 v86 = -[os_log_s countByEnumeratingWithState:objects:count:]( v82,  "countByEnumeratingWithState:objects:count:",  &v124,  v142,  16LL);
            }

            while (v86);
            uint64_t v15 = v110;
            v79 = 0;
          }

          else
          {
            uint64_t v15 = v110;
          }

          id v76 = (os_log_s *)v122;
LABEL_89:
        }

        v99 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        id v77 = (os_log_s *)objc_claimAutoreleasedReturnValue([v99 oslog]);

        v100 = os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT);
        if (v112 < 1)
        {
          if (v100)
          {
            v101 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            v107 = @"now active";
            *(_DWORD *)buf = 138543874;
            v133 = (uint64_t)v101;
            v134 = 2114;
            if (v79) {
              v107 = @"before first-unlock";
            }
            v135 = v8;
            v136 = 2114;
            v137 = (uint64_t)v107;
            v104 = "[%{public}@] {%{public}@} no set-jobs resumed (%{public}@) | MA_MILESTONE";
            v105 = v77;
            v106 = 32;
LABEL_101:
            _os_log_impl(&dword_0, v105, OS_LOG_TYPE_DEFAULT, v104, buf, v106);
          }
        }

        else if (v100)
        {
          v101 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          v102 = @"s";
          *(_DWORD *)buf = 138544386;
          v133 = (uint64_t)v101;
          if (v112 == 1) {
            v102 = &stru_355768;
          }
          v103 = @"now active";
          v136 = 2048;
          v137 = v112;
          v134 = 2114;
          v135 = v8;
          v138 = 2114;
          if (v79) {
            v103 = @"before first-unlock";
          }
          v139 = (uint64_t)v102;
          v140 = 2114;
          v141 = v103;
          v104 = "[%{public}@] {%{public}@} resumed %ld set-job%{public}@ (%{public}@) | MA_MILESTONE";
          v105 = v77;
          v106 = 52;
          goto LABEL_101;
        }

      objc_autoreleasePoolPop(v27);
      id v25 = (char *)v25 + 1;
    }

    while (v23 != v25);
    v91 = [obj countByEnumeratingWithState:&v200 objects:v212 count:16];
    id v23 = v91;
  }

  while (v91);
LABEL_94:

  if (v189 == 0)
  {
    -[MADAutoAssetJob statusChange:catalogFailure:forReason:]( self,  "statusChange:catalogFailure:forReason:",  @"ReportCatalogDecideFound",  6110LL,  @"successful catalog download yet no available patch or full asset found");
    id v10 = @"CatalogFoundNoNewer";
    uint64_t v14 = v186;
    id v5 = v187;
    goto LABEL_142;
  }

  uint64_t v14 = v186;
  id v5 = v187;
  if ((void)v189)
  {
    if (*((void *)&v189 + 1))
    {
      v119 = (void *)objc_claimAutoreleasedReturnValue([(id)v189 assetVersion]);
      v120 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v189 + 1) assetVersion]);
      v121 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v119, v120);

      if ((v121 & 1) == 0)
      {
        v130 = objc_alloc(&OBJC_CLASS___NSString);
        v131 = (void *)objc_claimAutoreleasedReturnValue([(id)v189 assetVersion]);
        v132 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v189 + 1) assetVersion]);
        v133 = -[NSString initWithFormat:]( v130,  "initWithFormat:",  @"auto-asset patch and full entries for different versions | patch:%@, full:%@",  v131,  v132);
        -[MADAutoAssetJob statusChange:catalogAnomaly:forReason:]( self,  "statusChange:catalogAnomaly:forReason:",  @"ReportCatalogDecideFound",  6109LL,  v133);

LABEL_114:
        id v10 = @"CatalogFoundNoNewer";
        goto LABEL_142;
      }
    }
  }

  if ((v188 & 1) == 0) {
    goto LABEL_117;
  }
  if (-[MADAutoAssetJob determiningAssetContent](self, "determiningAssetContent")
    && !-[MADAutoAssetJob checkingAssetContent](self, "checkingAssetContent")
    && !-[MADAutoAssetJob lockingAssetContent](self, "lockingAssetContent"))
  {
    goto LABEL_105;
  }

  v122 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  v123 = (void *)objc_claimAutoreleasedReturnValue([v122 assetVersion]);
  if (v123)
  {

    goto LABEL_105;
  }

  v134 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  v135 = (void *)objc_claimAutoreleasedReturnValue([v134 assetVersion]);
  if (v135)
  {

    goto LABEL_117;
  }

  v184 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob onFilesystemByVersion](self, "onFilesystemByVersion"));
  v185 = [v184 count];

  if (v185)
  {
LABEL_105:
    v124 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
    v125 = (os_log_s *)objc_claimAutoreleasedReturnValue([v124 oslog]);

    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      v126 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
      v127 = (void *)*((void *)&v189 + 1);
      if (!*((void *)&v189 + 1)) {
        v127 = (void *)v189;
      }
      v128 = (void *)objc_claimAutoreleasedReturnValue([v127 summary]);
      *(_DWORD *)buf = 138543618;
      v205 = v126;
      v206 = 2114;
      v207 = v128;
      _os_log_impl( &dword_0,  v125,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {ReportCatalogDecideFound} postponing[RAMPED] autoAsset:%{public}@",  buf,  0x16u);
    }

    goto LABEL_114;
  }

LABEL_101:
}

uint64_t OUTLINED_FUNCTION_8()
{
  return v0;
}

  ;
}

  ;
}

uint64_t _MobileAssetCreateDirectoryWorldWriteable(void *a1, int a2)
{
  id v3 = a1;
  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 path]);
  if (a2)
  {
    v35[0] = NSFileOwnerAccountName;
    v35[1] = NSFileGroupOwnerAccountName;
    v36[0] = @"mobile";
    v36[1] = @"mobile";
    v35[2] = NSFilePosixPermissions;
    v35[3] = NSFileProtectionKey;
    v36[2] = &off_38EE48;
    v36[3] = NSFileProtectionNone;
    id v6 = v36;
    id v7 = v35;
    uint64_t v8 = 4LL;
  }

  else
  {
    v33[0] = NSFileOwnerAccountName;
    v33[1] = NSFileGroupOwnerAccountName;
    v34[0] = @"mobile";
    v34[1] = @"mobile";
    v33[2] = NSFileProtectionKey;
    v34[2] = NSFileProtectionNone;
    id v6 = v34;
    id v7 = v33;
    uint64_t v8 = 3LL;
  }

  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v7,  v8));
  if ([v4 fileExistsAtPath:v5])
  {
    if ([v9 count])
    {
      _MobileAssetLog( 0LL,  7,  (uint64_t)"_MobileAssetCreateDirectoryWorldWriteable",  @"Directory at %@ already exists, updating attributes",  v14,  v15,  v16,  v17,  (uint64_t)v5);
      id v31 = 0LL;
      unsigned __int8 v18 = [v4 setAttributes:v9 ofItemAtPath:v5 error:&v31];
      id v23 = v31;
      if ((v18 & 1) == 0)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetCreateDirectoryWorldWriteable",  @"Unable to set attributes for directory '%@': %@",  v19,  v20,  v21,  v22,  (uint64_t)v5);
LABEL_10:
        uint64_t v29 = 4LL;
        goto LABEL_15;
      }
    }

    else
    {
      id v23 = 0LL;
    }
  }

  else
  {
    _MobileAssetLog( 0LL,  7,  (uint64_t)"_MobileAssetCreateDirectoryWorldWriteable",  @"Creating directory at %@",  v10,  v11,  v12,  v13,  (uint64_t)v3);
    id v32 = 0LL;
    unsigned __int8 v24 = [v4 createDirectoryAtURL:v3 withIntermediateDirectories:1 attributes:v9 error:&v32];
    id v23 = v32;
    if ((v24 & 1) == 0)
    {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetCreateDirectoryWorldWriteable",  @"Unable to create directory '%@': %@",  v25,  v26,  v27,  v28,  (uint64_t)v3);
      goto LABEL_10;
    }
  }

  uint64_t v29 = 0LL;
LABEL_15:

  return v29;
}

void sub_96638( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void sub_96D5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_990F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __Block_byref_object_copy__7(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void sub_9B5F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t __Block_byref_object_copy__8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

void sub_9BEF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_9C2CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __logInfo_block_invoke(id a1)
{
  os_log_t v1 = os_log_create("com.apple.mobileassetd", "Notice");
  id v2 = (void *)logInfo_infoLog;
  logInfo_infoLog = (uint64_t)v1;
}

void __logError_block_invoke(id a1)
{
  os_log_t v1 = os_log_create("com.apple.mobileassetd", "Error");
  id v2 = (void *)logError_infoError;
  logError_infoError = (uint64_t)v1;
}

id logDebug()
{
  if (logDebug_logDebugOnce != -1) {
    dispatch_once(&logDebug_logDebugOnce, &__block_literal_global_182);
  }
  return (id)logDebug_infoDebug;
}

void __logDebug_block_invoke(id a1)
{
  os_log_t v1 = os_log_create("com.apple.mobileassetd", "Debug");
  id v2 = (void *)logDebug_infoDebug;
  logDebug_infoDebug = (uint64_t)v1;
}

id logFault()
{
  if (logFault_logFaultOnce != -1) {
    dispatch_once(&logFault_logFaultOnce, &__block_literal_global_184);
  }
  return (id)logFault_infoFault;
}

void __logFault_block_invoke(id a1)
{
  os_log_t v1 = os_log_create("com.apple.mobileassetd", "Fault");
  id v2 = (void *)logFault_infoFault;
  logFault_infoFault = (uint64_t)v1;
}

void _MobileAssetFault( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v9 = a2;
  uint64_t v10 = -[NSString initWithFormat:arguments:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:arguments:", v9, &a9);

  id v11 = logFault();
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
    _MobileAssetFault_cold_1();
  }
}

void sub_A3FB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

uint64_t __Block_byref_object_copy__9(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
}

void sub_A4960( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void ___isAssetTypeAllowlisted_block_invoke(id a1)
{
  _isAssetTypeAllowlisted_explicitAllowList = (uint64_t)CFSetCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeSetCallBacks);
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.DictionaryServices.dictionaryOSX");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.DictionaryServices.dictionary2");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.DictionaryServices.availableDictionaries");
  CFSetAddValue((CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList, @"com.apple.MobileAsset.Font3");
  CFSetAddValue((CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList, @"com.apple.MobileAsset.Font4");
  CFSetAddValue((CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList, @"com.apple.MobileAsset.Font5");
  CFSetAddValue((CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList, @"com.apple.MobileAsset.Font6");
  CFSetAddValue((CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList, @"com.apple.MobileAsset.Font7");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.TextInput.SpellChecker");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.TextInput.Dictionary");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.WebKitBlocklist");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.MacinTalkVoiceAssets");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.LinguisticData");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.VoiceServices.CustomVoice");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.VoiceServices.CombinedVocalizerVoices");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.VoiceServicesVocalizerVoice");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.VoiceServices.VoiceResources");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.TuriCoreAsset");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.CreateMLAsset");
  CFSetAddValue((CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList, @"com.apple.MobileAsset.Avatar");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.RawCamera.Camera");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.VoiceServices.GryphonVoice");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.TTSAXResourceModelAssets");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.SpotlightResources");
  CFSetAddValue( (CFMutableSetRef)_isAssetTypeAllowlisted_explicitAllowList,  @"com.apple.MobileAsset.LinguisticDataAuto");
}

unsigned __int8 *_hashCFDataOfLength( const __CFData *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x80000000LL) {
    _hashCFDataOfLength_cold_1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  CC_LONG v8 = a2;
  uint64_t v10 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
  BytePtr = CFDataGetBytePtr(a1);
  CC_SHA1(BytePtr, v8, v10);
  return v10;
}

unsigned __int8 *_hashCFArrayNoLegacy(const __CFArray *a1)
{
  id v2 = (void *)_hashCFType(@"array", 0LL);
  CC_SHA1_Update(&c, v2, 0x14u);
  if (v2) {
    free(v2);
  }
  uint64_t valuePtr = CFArrayGetCount(a1);
  id v3 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
  id v4 = _hashCFNumber(v3);
  CC_SHA1_Update(&c, v4, 0x14u);
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    free(v4);
  }
  CFIndex idx = 0LL;
  if (valuePtr >= 1)
  {
    do
    {
      id v5 = CFNumberCreate(0LL, kCFNumberCFIndexType, &idx);
      id v6 = _hashCFNumber(v5);
      CC_SHA1_Update(&c, v6, 0x14u);
      if (v5) {
        CFRelease(v5);
      }
      if (v6) {
        free(v6);
      }
      ValueAtIndex = CFArrayGetValueAtIndex(a1, idx);
      CC_LONG v8 = (void *)_hashCFType(ValueAtIndex, 0LL);
      CC_SHA1_Update(&c, v8, 0x14u);
      if (v8) {
        free(v8);
      }
      ++idx;
    }

    while (idx < valuePtr);
  }

  id v9 = (unsigned __int8 *)calloc(1uLL, 0x14uLL);
  CC_SHA1_Final(v9, &c);
  return v9;
}

void OUTLINED_FUNCTION_0_2( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

LABEL_57:
        v41 = -[NSString initWithFormat:]( v77,  "initWithFormat:",  v80,  v131,  v132,  v92,  v96,  v100,  v105,  v111,  v113,  v116,  v117);
        v81 = v121;
        goto LABEL_58;
      }

      if (!((unint64_t)v69 | (unint64_t)v71))
      {
        id v77 = objc_alloc(&OBJC_CLASS___NSString);
        if ((void)v122)
        {
          if (!*((void *)&v122 + 1))
          {
            v79 = (__CFString *)v119;
            v78 = (__CFString *)v120;
            v111 = v119;
            v113 = v26;
            v100 = v120;
            v105 = (const __CFString *)v122;
            v92 = v118;
            v96 = v27;
            v80 = @"time=%@ op=%@ %@=%@ %@ asset=%@%@%@";
            goto LABEL_57;
          }

          v79 = (__CFString *)v119;
          v113 = v119;
          v116 = v26;
          v111 = (const __CFString *)*((void *)&v122 + 1);
          uint64_t v82 = (const __CFString *)v122;
        }

        else
        {
          v79 = (__CFString *)v119;
          v113 = v119;
          v116 = v26;
          v111 = (const __CFString *)*((void *)&v122 + 1);
          uint64_t v82 = @"UNKNOWN                                 ";
        }

        v78 = (__CFString *)v120;
        v100 = v120;
        v105 = v82;
        v92 = v118;
        v96 = v27;
        v80 = @"time=%@ op=%@ %@=%@ %@ asset=%@ selector=%@%@%@";
        goto LABEL_57;
      }

      v41 = @"BLANK_ENTRY";
      v78 = (__CFString *)v120;
      v81 = v121;
      v79 = (__CFString *)v119;
LABEL_58:

      id v39 = v131;
      id v38 = (void *)v132;
      uint64_t v43 = (void *)v133;
      __int128 v37 = (__CFString *)*((void *)&v122 + 1);
      __int128 v35 = v122;
      uint64_t v42 = (void *)*((void *)&v133 + 1);
      uint64_t v45 = self;
      uint64_t v44 = v128;
LABEL_84:
      id v84 = v45;
      id v85 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetHistoryTracker protectionQueue](v45, "protectionQueue"));
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = __276__MADAutoAssetHistoryTracker_recordHistoryEntry_toHistoryType_fromClient_fromLayer_forAssetID_withSelector_usageCount_configuredCount_requestedCount_fromPallasCount_vendingCount_forClientDomainName_forAssetSetIdentifier_forAtomicInstance_withAddendumMessage_failingWithError___block_invoke;
      block[3] = &unk_34DB98;
      v138 = v41;
      v139 = v84;
      __int128 v86 = v41;
      dispatch_async(v85, block);

      objc_autoreleasePoolPop(context);
      return;
    case 4LL:
      __int128 v37 = (__CFString *)v36;
      uint64_t v66 = v35 | v36;
      v47 = objc_alloc(&OBJC_CLASS___NSString);
      if (v66)
      {
        if (!v35)
        {
          v115 = v26;
          uint64_t v42 = (void *)*((void *)&v133 + 1);
          id v38 = (void *)v132;
          id v39 = v131;
          v41 = -[NSString initWithFormat:]( v47,  "initWithFormat:",  @"time=%@ op=%@ %@=%@ domain=%@ set=%@ selector=%@%@",  v131,  v132,  v28,  v27,  v134,  *((void *)&v133 + 1),  v37,  v115);
LABEL_74:
          uint64_t v43 = (void *)v133;
          uint64_t v44 = v128;
          uint64_t v45 = self;
          __int128 v35 = 0LL;
          goto LABEL_84;
        }

        uint64_t v42 = (void *)*((void *)&v133 + 1);
        id v38 = (void *)v132;
        uint64_t v43 = (void *)v133;
        if (v37)
        {
          v113 = v37;
          v116 = v26;
          v103 = (void *)*((void *)&v133 + 1);
          v110 = (const __CFString *)v35;
          v94 = v27;
          v98 = (int64_t)v134;
          v90 = v28;
          uint64_t v67 = @"time=%@ op=%@ %@=%@ domain=%@ set=%@ asset=%@ selector=%@%@";
        }

        else
        {
          v110 = (const __CFString *)v35;
          v113 = v26;
          v98 = (int64_t)v134;
          v103 = (void *)*((void *)&v133 + 1);
          v90 = v28;
          v94 = v27;
          uint64_t v67 = @"time=%@ op=%@ %@=%@ domain=%@ set=%@ asset=%@%@";
        }
}

  objc_autoreleasePoolPop(context);
  id v6 = v58;
LABEL_58:

LABEL_59:
LABEL_60:

  return log;
}

LABEL_80:
        id v39 = v131;
        id v83 = -[NSString initWithFormat:](v47, "initWithFormat:", v67, v131, v38, v90, v94, v98, v103, v110, v113, v116);
LABEL_81:
        v41 = v83;
      }

      else
      {
        v109 = v26;
        uint64_t v42 = (void *)*((void *)&v133 + 1);
        id v38 = (void *)v132;
        id v39 = v131;
        v41 = -[NSString initWithFormat:]( v47,  "initWithFormat:",  @"time=%@ op=%@ %@=%@ domain=%@ set=%@%@",  v131,  v132,  v28,  v27,  v134,  *((void *)&v133 + 1),  v109);
LABEL_19:
        uint64_t v43 = (void *)v133;
      }

      uint64_t v44 = v128;
LABEL_83:
      uint64_t v45 = self;
      goto LABEL_84;
    case 5LL:
    case 6LL:
      __int128 v37 = (__CFString *)v36;
      v108 = v26;
      id v38 = (void *)v132;
      id v39 = (void *)v25;
      uint64_t v40 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"time=%@ op=%@ %@=%@ asset=%@ selector=%@%@",  v25,  v132,  v28,  v27,  v35,  v36,  v108);
      goto LABEL_18;
    default:
      v41 = @"BLANK_ENTRY";
      uint64_t v42 = (void *)*((void *)&v133 + 1);
      uint64_t v43 = (void *)v133;
      uint64_t v44 = v128;
      uint64_t v45 = self;
      id v39 = v131;
      id v38 = (void *)v132;
      __int128 v37 = (__CFString *)v36;
      goto LABEL_84;
  }
}

LABEL_27:
        id v5 = 0LL;
LABEL_33:

        if (v5) {
          goto LABEL_3;
        }
        if (v6)
        {
          id v9 = 0LL;
          goto LABEL_5;
        }

    uint64_t v70 = 0;
    v201 = 0LL;
    v199 = 0LL;
    goto LABEL_31;
  }

  uint64_t v58 = objc_claimAutoreleasedReturnValue( +[PallasResponseVerifier CopyDataFromEncodedBase64:range:]( &OBJC_CLASS___PallasResponseVerifier,  "CopyDataFromEncodedBase64:range:",  v43,  v224,  v225));
  uint64_t v59 = v34;
  if (!v58)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Pallas headerData decoding base 64 failed",  v54,  v55,  v56,  v57,  v180);
    v203 = 0LL;
    if ((v34 & 1) == 0)
    {
      v204 = -2LL;
      uint64_t v71 = @"V2 headerData decoding base 64 failed";
      goto LABEL_29;
    }

    goto LABEL_27;
  }

  uint64_t v64 = objc_claimAutoreleasedReturnValue( +[PallasResponseVerifier CopyDataFromEncodedBase64:range:]( &OBJC_CLASS___PallasResponseVerifier,  "CopyDataFromEncodedBase64:range:",  v43,  v226,  v227));
  v203 = (void *)v58;
  if (!v64)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Pallas responseData decoding base 64 failed",  v60,  v61,  v62,  v63,  v180);
    v201 = 0LL;
    if ((v34 & 1) != 0)
    {
      uint64_t v70 = 0;
      v199 = 0LL;
      goto LABEL_31;
    }

    v204 = -3LL;
    uint64_t v71 = @"V2 responseData decoding base 64 failed";
LABEL_30:

    v199 = 0LL;
    uint64_t v70 = 0;
    v212 = (__CFString *)v71;
    goto LABEL_31;
  }

  uint64_t v65 = objc_claimAutoreleasedReturnValue( +[PallasResponseVerifier CopyDataFromEncodedBase64:range:]( &OBJC_CLASS___PallasResponseVerifier,  "CopyDataFromEncodedBase64:range:",  v43,  v228,  v229));
  v201 = (void *)v64;
  if (v65)
  {
    v199 = (void *)v65;
    uint64_t v70 = 1;
    goto LABEL_31;
  }

  _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:the n:]_block_invoke",  @"Pallas signature decoding base 64 failed, skipping verification for now",  v66,  v67,  v68,  v69,  v180);
  if ((v34 & 1) == 0)
  {
    v204 = -4LL;
    uint64_t v71 = @"V2 signature decoding base 64 failed";
    goto LABEL_30;
  }

  v199 = 0LL;
  uint64_t v70 = 0;
LABEL_31:
  objc_autoreleasePoolPop(v42);
  if (!v70)
  {
    unsigned __int8 v24 = 0LL;
    v186 = 0LL;
    v208 = 0LL;
    goto LABEL_36;
  }

  id v72 = objc_autoreleasePoolPush();
  v219 = 0LL;
  v206 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v203,  0LL,  &v219));
  v208 = v219;
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:the n:]_block_invoke",  @"The pallas response %@ header is: %@",  v73,  v74,  v75,  v76,  *(void *)(v213 + 32));
  if (v208)
  {
    id v77 = (void *)objc_claimAutoreleasedReturnValue([v208 description]);
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Error in getting JSON from the headerJson of Pallas response: %@",  v78,  v79,  v80,  v81,  (uint64_t)v77);

    if ((v59 & 1) != 0)
    {
      v200 = 0LL;
      v202 = 0LL;
    }

    else
    {

      v200 = 0LL;
      v202 = 0LL;
      v204 = -5LL;
      v212 = @"V2 Error in getting JSON from the header";
    }
  }

  else
  {
    v200 = (void *)objc_claimAutoreleasedReturnValue([v206 objectForKey:@"alg"]);
    v202 = (void *)objc_claimAutoreleasedReturnValue([v206 objectForKey:@"x5c"]);
  }

  objc_autoreleasePoolPop(v72);
  if (v208)
  {
    unsigned __int8 v24 = 0LL;
    v186 = 0LL;
    goto LABEL_37;
  }

  if (v202)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Certs present, checking they are valid",  v20,  v21,  v22,  v23,  v181);
    v103 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v213 + 40) pallasVerifier]);
    v104 = [v103 determineAlg:v200];

    if ((v104 & 1) == 0)
    {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName :then:]_block_invoke",  @"Pallas invalid alg specified",  v105,  v106,  v107,  v108,  v181);
      if ((v59 & 1) == 0)
      {

        unsigned __int8 v24 = 0LL;
        v186 = 0LL;
        v208 = 0LL;
        v209 = 0LL;
        v189 = 0LL;
        v190 = 0LL;
        v191 = 0LL;
        v193 = 0LL;
        v197 = 0LL;
        v198 = 0LL;
        v195 = 0LL;
        id v32 = 0LL;
        unsigned int v33 = -6LL;
        v135 = @"V2 invalid alg specified";
LABEL_92:
        v212 = (__CFString *)v135;
        goto LABEL_39;
      }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager registerAssetDownloadJob:withPurpose:usingDownloadOptions:forAssetId:withBase:relativeTo: startingAt:withLength:extractWith:allocateExtractorIfNecessary:usingXPCConnection:withXPCMessage:clientName :performingAutoAssetJob:notify:withCatalogMetadata:withSpaceCheckedUUID:]_block_invoke_2",  @"Full URL is %@",  v38,  v39,  v40,  v41,  (uint64_t)v59);
  [*(id *)(a1 + 96) startDownloadAndUpdateState:v59 for:*(void *)(*(void *)(*(void *)(a1 + 152) + 8) + 40) startingAt:*(void *)(a1 + 104) withLength:*(void *)(a1 + 112) extractWith:*(void *)(a1 + 40) modified:0 options:*(void *)(a1 + 80) downloadSize:*(void *)(*(void *)(*(void *)(a1 + 160) + 8) + 24) using:*(void *)(a1 + 120) with:*(void *)(a1 + 128) clientNam e:*(void *)(a1 + 136) autoAssetJob:*(void *)(a1 + 144) ofJobType:@"asset_job" notify:*(void *)(a1 + 176) spaceCheckedUUID:*(void *)(*(void *)(*(void *)(a1 + 168) + 8) + 40)];
}

  id v9 = v47;
LABEL_28:
  if (v30)
  {
    v41 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 diag]);
    objc_msgSend( v42,  "trackAnomaly:forReason:withResult:withError:",  @"AUTO-SET-CONTROL",  @"set-descriptor not lockable",  objc_msgSend(v30, "code"),  v30);
  }

  if (a5) {
    *a5 = v30;
  }

  return v30 == 0LL;
}

            goto LABEL_15;
          }

          __int128 v35 = @"atomic-instance lock to be mapped to exclave environment with autoAssetEntries count other than 1 (limited to mapping a single asset-selector per set-identifier)";
          __int128 v36 = self;
          __int128 v37 = v7;
          id v38 = 6108LL;
        }

        else
        {
          __int128 v35 = @"atomic-instance lock to be mapped to exclave environment MISSING autoAssetEntries";
          __int128 v36 = self;
          __int128 v37 = v7;
          id v38 = 6102LL;
        }
      }

      else
      {
        __int128 v35 = @"atomic-instance lock to be mapped to exclave environment is not currently locked";
        __int128 v36 = self;
        __int128 v37 = v7;
        id v38 = 6501LL;
      }
    }

    else
    {
      __int128 v35 = @"atomic-instance lock to be mapped to exclave environment is not downloaded";
      __int128 v36 = self;
      __int128 v37 = v7;
      id v38 = 6551LL;
    }

    -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( v36,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v37,  v38,  v11,  v35);
LABEL_15:

    goto LABEL_16;
  }

  id v32 = objc_alloc(&OBJC_CLASS___NSString);
  unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue([v7 summary]);
  __int128 v34 = -[NSString initWithFormat:]( v32,  "initWithFormat:",  @"invalid set-eventInfo (instance:MISSING) | set-eventInfo:%@",  v33);
  -[MADAutoAssetControlManager issueResponseForEventInfo:withErrorCode:fromAction:withDescription:]( self,  "issueResponseForEventInfo:withErrorCode:fromAction:withDescription:",  v7,  6102LL,  v11,  v34);

LABEL_16:
}
}

LABEL_28:
  return v27;
}
  }

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
  uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 persistedEntryIDs:@"atomicInstanceHasDownloadedSetDescriptor"]);

  if (-[os_log_s count](v43, "count"))
  {
    v105 = 0u;
    v106 = 0u;
    v103 = 0u;
    v104 = 0u;
    uint64_t v44 = v43;
    uint64_t v45 = -[os_log_s countByEnumeratingWithState:objects:count:]( v44,  "countByEnumeratingWithState:objects:count:",  &v103,  v111,  16LL);
    if (!v45)
    {
      uint64_t v74 = 0;
      goto LABEL_67;
    }

    uint64_t v46 = v45;
    v96 = v4;
    id obj = v44;
    v47 = @"atomicInstanceHasDownloadedSetDescriptor";
    v48 = *(void *)v104;
LABEL_31:
    unsigned __int8 v49 = 0LL;
    while (1)
    {
      if (*(void *)v104 != v48) {
        objc_enumerationMutation(obj);
      }
      v50 = *(void **)(*((void *)&v103 + 1) + 8 * v49);
      v51 = objc_autoreleasePoolPush();
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedActiveJobSetDescriptors]( self,  "persistedActiveJobSetDescriptors"));
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v52 persistedEntry:v50 fromLocation:v47]);

      if (!v53)
      {
        uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v70 = (os_log_s *)objc_claimAutoreleasedReturnValue([v69 oslog]);

        if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
        {
          uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          *(_DWORD *)buf = 138543618;
          v113 = v71;
          v114 = 2114;
          v115 = v50;
          _os_log_error_impl( &dword_0,  v70,  OS_LOG_TYPE_ERROR,  "[%{public}@] {atomicInstanceHasDownloadedSetDescriptor} unable to determine previous status (active-job set- descriptors) | entryID:%{public}@",  buf,  0x16u);
        }

        goto LABEL_48;
      }

      uint64_t v54 = [v53 secureCodedObjectForKey:@"assetSetDescriptor" ofClass:objc_opt_class(MADAutoSetDescriptor)];
      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
      v102 = v55;
      if (v55)
      {
        v98 = v50;
        v56 = v53;
        uint64_t v57 = v48;
        uint64_t v58 = self;
        uint64_t v59 = v51;
        uint64_t v60 = v47;
        v61 = (void *)objc_claimAutoreleasedReturnValue([v55 latestDownloadedAtomicInstance]);
        v62 = (void *)objc_claimAutoreleasedReturnValue([v99 atomicInstanceUUID]);
        id v63 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v61, v62);

        if (v63)
        {
          id v85 = v59;
          if (v96)
          {
            __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v58, "logger"));
            __int128 v87 = (os_log_s *)objc_claimAutoreleasedReturnValue([v86 oslog]);

            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
            {
              __int128 v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v58, "_updateLatestSummary"));
              __int128 v89 = (void *)objc_claimAutoreleasedReturnValue([v99 summary]);
              v90 = (void *)objc_claimAutoreleasedReturnValue([v102 summary]);
              *(_DWORD *)buf = 138544130;
              v113 = v88;
              v114 = 2114;
              v115 = v89;
              v116 = 2114;
              v117 = v98;
              v118 = 2114;
              v119 = (uint64_t)v90;
              _os_log_impl( &dword_0,  v87,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {atomicInstanceHasDownloadedSetDescriptor} [VERBOSE] ActiveJobSetDescriptors matched | setA tomicInstance:%{public}@ | entryID:%{public}@ | nextSetDescriptor:%{public}@",  buf,  0x2Au);
            }
          }

          v81 = v85;
          goto LABEL_65;
        }

        if (!v96)
        {
          v47 = v60;
          v51 = v59;
          self = v58;
          v48 = v57;
          uint64_t v53 = v56;
          goto LABEL_47;
        }

        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v58, "logger"));
        uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue([v64 oslog]);

        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          v94 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v58, "_updateLatestSummary"));
          uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v99 summary]);
          uint64_t v67 = objc_claimAutoreleasedReturnValue([v102 summary]);
          *(_DWORD *)buf = 138544130;
          v113 = v94;
          v114 = 2114;
          v115 = v66;
          v116 = 2114;
          v117 = v98;
          v118 = 2114;
          v119 = v67;
          uint64_t v68 = (void *)v67;
          _os_log_impl( &dword_0,  v65,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {atomicInstanceHasDownloadedSetDescriptor} [VERBOSE] ActiveJobSetDescriptors no match | setAtom icInstance:%{public}@ | entryID:%{public}@ | nextSetDescriptor:%{public}@",  buf,  0x2Au);
        }

        v47 = v60;
        v51 = v59;
        self = v58;
        v48 = v57;
        uint64_t v53 = v56;
      }

      else
      {
        id v72 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue([v72 oslog]);

        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          v73 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          *(_DWORD *)buf = 138543618;
          v113 = v73;
          v114 = 2114;
          v115 = v50;
          _os_log_error_impl( &dword_0,  v65,  OS_LOG_TYPE_ERROR,  "[%{public}@] {atomicInstanceHasDownloadedSetDescriptor} unable to load set-descriptor (active-job) | entryID:%{public}@",  buf,  0x16u);
        }
      }

LABEL_47:
      uint64_t v70 = (os_log_s *)v102;
LABEL_48:

      objc_autoreleasePoolPop(v51);
      if (v46 == (id)++v49)
      {
        uint64_t v46 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v103,  v111,  16LL);
        if (v46) {
          goto LABEL_31;
        }
        uint64_t v74 = 0;
        goto LABEL_66;
      }
    }
  }

  if (v4)
  {
    uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    id v83 = (os_log_s *)objc_claimAutoreleasedReturnValue([v82 oslog]);

    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
    {
      id v84 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      *(_DWORD *)buf = 138543362;
      v113 = v84;
      _os_log_impl( &dword_0,  v83,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {atomicInstanceHasDownloadedSetDescriptor} [VERBOSE] ActiveJobSetDescriptors no persistedEntryIDs",  buf,  0xCu);
    }

    uint64_t v74 = 0;
    uint64_t v44 = v83;
    goto LABEL_68;
  }

  uint64_t v74 = 0;
LABEL_69:

  return v74;
}

        p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
LABEL_28:

LABEL_29:
        objc_autoreleasePoolPop(v20);
        unsigned __int8 v18 = (char *)v18 + 1;
      }

      while (v63 != v18);
      unsigned __int8 v49 = [v15 countByEnumeratingWithState:&v64 objects:v72 count:16];
      id v63 = v49;
      if (!v49)
      {
LABEL_41:

        CC_LONG v8 = v52;
        id v4 = v53;
        v50 = v54;
        goto LABEL_42;
      }
    }
  }

  v50 = 0LL;
LABEL_42:

  return v50;
}

          uint64_t v45 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
          uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue([v10 fullAssetSelector]);
          [v45 addObject:v14];
          goto LABEL_29;
        }

        v51 = v8;
        uint64_t v13 = v5[155];
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue([v10 fullAssetSelector]);
        uint64_t v15 = v5;
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s assetType](v14, "assetType"));
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) assetType]);
        if ((-[__objc2_ivar_list stringIsEqual:to:](v13, "stringIsEqual:to:", v16, v17) & 1) != 0)
        {
          unsigned __int8 v18 = v15[155];
          v48 = (void *)objc_claimAutoreleasedReturnValue([v10 fullAssetSelector]);
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v48 assetSpecifier]);
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) assetSpecifier]);
          if (-[__objc2_ivar_list stringIsEqual:to:](v18, "stringIsEqual:to:", v19, v20))
          {
            v47 = v15[155];
            uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v10 fullAssetSelector]);
            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v46 assetVersion]);
            uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) assetVersion]);
            LODWORD(v47) = -[__objc2_ivar_list stringIsEqual:to:](v47, "stringIsEqual:to:", v21, v22);

            id v2 = v49;
            id v3 = v50;
            p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
            id v5 = v15;
            CC_LONG v8 = v51;
            if (!(_DWORD)v47) {
              goto LABEL_30;
            }
            id v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) logger]);
            unsigned __int8 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue([v23 oslog]);

            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) summary]);
              uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) summary]);
              *(_DWORD *)buf = 138543618;
              uint64_t v59 = v25;
              uint64_t v60 = 2114;
              v61 = v26;
              uint64_t v27 = v24;
              uint64_t v28 = "%{public}@ | {lockedSelectorsForEliminate} eliminate-selector for asset-type + asset-specifier + ass"
                    "et-version associated with current lock | eliminateSelector:%{public}@";
              goto LABEL_26;
            }

            goto LABEL_27;
          }

          id v2 = v49;
          id v3 = v50;
          p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
        }

        else
        {

          id v3 = v50;
        }

        id v5 = v15;
        CC_LONG v8 = v51;
LABEL_29:

LABEL_30:
        objc_autoreleasePoolPop(v8);
      }

      uint64_t v52 = [v2 countByEnumeratingWithState:&v54 objects:v64 count:16];
    }

    while (v52);
  }
}

  __break(1u);
  return result;
}

id _MobileAssetGetWorkQueue()
{
  if (_MobileAssetGetWorkQueue_workQueueOnce != -1) {
    dispatch_once(&_MobileAssetGetWorkQueue_workQueueOnce, &__block_literal_global_15);
  }
  return (id)_MobileAssetGetWorkQueue_workQueue;
}

void _ASSetAssetServerURLForAssetType(void *a1, uint64_t a2, int a3)
{
  id v8 = a1;
  id v5 = @"MobileAssetServerURL";
  if (a2)
  {
    id v6 = "";
    if (a3) {
      id v6 = "default-";
    }
    id v5 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s%@-%@",  v6,  @"MobileAssetServerURL",  a2));
  }

  id v7 = (void *)objc_claimAutoreleasedReturnValue([v8 absoluteString]);
  _MAPreferencesSetStringValue(v5, v7, @"_ASSetAssetServerURLForAssetType", @"persisting server URL");
}

uint64_t repositoryDownloadsAreRestricted(void *a1)
{
  id v1 = a1;
  id RepositoryPath = getRepositoryPath(@"/private/var/MobileAsset/AssetsV2");
  id v3 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  [v1 isEqualToString:v3];

  return 0LL;
}

BOOL repositoryUsesDownloadsFolder(void *a1)
{
  id v1 = a1;
  repositoryDownloadsAreRestricted(v1);
  if (([v1 isEqualToString:@"/System/Volumes/Update/MobileAsset/AssetsV2"] & 1) != 0
    || ([v1 isEqualToString:@"/private/var/MobileSoftwareUpdate/MobileAsset/AssetsV2"] & 1) != 0)
  {
    BOOL v2 = 1LL;
  }

  else
  {
    self_entitlements = _xpc_runtime_get_self_entitlements();
    id v4 = (void *)objc_claimAutoreleasedReturnValue(self_entitlements);
    id v5 = v4;
    BOOL v2 = v4 && xpc_dictionary_get_BOOL(v4, "com.apple.private.mobileassetd.use-download-dir");
  }

  return v2;
}

id getRepositoryStagingUrl(void *a1, int a2)
{
  if (a1)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([a1 stringByAppendingPathComponent:@"staging"]);
    uint64_t v4 = objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](&OBJC_CLASS___NSURL, "fileURLWithPath:isDirectory:", v3, 1LL));
    id v5 = (void *)v4;
    if (v3 && a2 && v4) {
      id v6 = ensureDirectory(v3);
    }
  }

  else
  {
    id v5 = 0LL;
  }

  return v5;
}

id getRepositoryDownloadsUrl(void *a1, int a2)
{
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3 && repositoryUsesDownloadsFolder(v3))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 stringByAppendingPathComponent:@"downloadDir"]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](&OBJC_CLASS___NSURL, "fileURLWithPath:isDirectory:", v5, 1LL));
    id v7 = v6;
    if (v5 && a2 && v6 && _MobileAssetCreateDirectoryWorldWriteable(v6, 1)) {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"getRepositoryDownloadsUrl",  @"Could not make temporary directory %@ error %d",  v8,  v9,  v10,  v11,  (uint64_t)v5);
    }
  }

  else
  {
    id v7 = 0LL;
  }

  return v7;
}

id getPathToStagedFile(void *a1, void *a2, int a3)
{
  id v5 = a2;
  id v6 = repositoryPath(a1);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  id RepositoryStagingUrl = getRepositoryStagingUrl(v7, a3);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(RepositoryStagingUrl);

  uint64_t v10 = 0LL;
  if (v5 && v9) {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 URLByAppendingPathComponent:v5 isDirectory:0]);
  }

  return v10;
}

id getPathToTempDownloadFile(void *a1, void *a2, int a3)
{
  id v5 = a2;
  id v6 = repositoryPath(a1);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  id RepositoryDownloadsUrl = getRepositoryDownloadsUrl(v7, a3);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(RepositoryDownloadsUrl);

  uint64_t v10 = 0LL;
  if (v5 && v9) {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 URLByAppendingPathComponent:v5 isDirectory:0]);
  }

  return v10;
}

id getLocalUrlFromTypeAndIdWithPurpose(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  id v8 = a2;
  id v9 = a1;
  uint64_t v10 = repositoryPath(v9);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  id LocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose = getLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose( v9,  v8,  a3,  v11,  v7);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(LocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose);

  return v13;
}

id getAutoLocalUrlFromTypeWithPurpose(void *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = a1;
  id v7 = repositoryPath(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  id AutoLocalUrlFromTypeGivenDefaultRepoWithPurpose = getAutoLocalUrlFromTypeGivenDefaultRepoWithPurpose(v6, a2, v8, v5);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(AutoLocalUrlFromTypeGivenDefaultRepoWithPurpose);

  return v10;
}

id getAutoLocalUrlFromTypeAndIdWithPurpose(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  uint64_t v10 = 0LL;
  if (v7 && v8)
  {
    uint64_t v11 = repositoryPath(v7);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    if (v12)
    {
      Autoid LocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose = getAutoLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose( v7,  v8,  a3,  v12,  v9);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(AutoLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose);
    }

    else
    {
      uint64_t v10 = 0LL;
    }
  }

  return v10;
}

LABEL_50:
          id v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
          [v84 setObject:v45 forKeyedSubscript:NSDebugDescriptionErrorKey];
          [v84 setObject:0 forKeyedSubscript:NSUnderlyingErrorKey];
          id v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  114LL,  v84));
          __int128 v86 = 0LL;
          goto LABEL_51;
        }

        uint64_t v16 = v30;
LABEL_36:

        v50 = 0;
LABEL_37:
        id v7 = v94;
        goto LABEL_38;
      }

      v50 = 1;
    }

    else
    {
      uint64_t v66 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Failed to commit staged manifests: %@", v16));
      uint64_t v67 = [v66 UTF8String];
      _MobileAssetLog( 0LL,  3,  (uint64_t)"+[SecureMobileAssetBundle commitStagedManifestsForSelectors:darwinOnly:error:]",  @"[SMA] %s",  v68,  v69,  v70,  v71,  (uint64_t)v67);

      if (a5)
      {
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to commit staged manifests"));
        id v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
        [v72 setObject:v29 forKeyedSubscript:NSDebugDescriptionErrorKey];
        [v72 setObject:0 forKeyedSubscript:NSUnderlyingErrorKey];
        v73 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  114LL,  v72));

        v50 = 0;
        *a5 = v73;
LABEL_38:

        goto LABEL_39;
      }

      v50 = 0;
    }

    goto LABEL_48;
  }

      uint64_t v21 = v69;

      goto LABEL_51;
    }

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s latestDowloadedAtomicInstanceEntries](v13, "latestDowloadedAtomicInstanceEntries"));
    uint64_t v29 = [v28 count];

    if (v29 == v60) {
      break;
    }
LABEL_48:
    uint64_t v21 = v69;
LABEL_51:

LABEL_52:
    objc_autoreleasePoolPop(context);
    id v7 = v21 + 1;
    if (v7 == v67)
    {
      uint64_t v67 = [obj countByEnumeratingWithState:&v90 objects:v101 count:16];
      if (!v67) {
        goto LABEL_54;
      }
      goto LABEL_5;
    }
  }

  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  uint64_t v30 = (os_log_t)objc_claimAutoreleasedReturnValue([v59 latestDowloadedAtomicInstanceEntries]);
  v61 = -[os_log_s countByEnumeratingWithState:objects:count:]( v30,  "countByEnumeratingWithState:objects:count:",  &v86,  v95,  16LL);
  if (!v61) {
    goto LABEL_57;
  }
  v62 = *(void *)v87;
  uint64_t v65 = v30;
  while (2)
  {
    id v31 = 0LL;
    while (2)
    {
      if (*(void *)v87 != v62) {
        objc_enumerationMutation(v30);
      }
      id v63 = v31;
      id v32 = *(void **)(*((void *)&v86 + 1) + 8 * v31);
      uint64_t v82 = 0u;
      id v83 = 0u;
      id v84 = 0u;
      id v85 = 0u;
      id v77 = (id)objc_claimAutoreleasedReturnValue(-[os_log_s latestDowloadedAtomicInstanceEntries](log, "latestDowloadedAtomicInstanceEntries"));
      v80 = [v77 countByEnumeratingWithState:&v82 objects:v94 count:16];
      if (!v80)
      {
LABEL_49:

        id v6 = v58;
        goto LABEL_50;
      }

      v79 = *(void *)v83;
      v73 = v32;
      while (2)
      {
        unsigned int v33 = 0LL;
LABEL_30:
        if (*(void *)v83 != v79) {
          objc_enumerationMutation(v77);
        }
        __int128 v34 = *(void **)(*((void *)&v82 + 1) + 8 * v33);
        __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v34 fullAssetSelector]);
        __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v35 assetType]);
        __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v32 fullAssetSelector]);
        id v38 = (void *)objc_claimAutoreleasedReturnValue([v37 assetType]);
        if (!+[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v36, v38))
        {
LABEL_41:

LABEL_42:
          if (v80 == (id)++v33)
          {
            v80 = [v77 countByEnumeratingWithState:&v82 objects:v94 count:16];
            if (v80) {
              continue;
            }
            goto LABEL_49;
          }

          goto LABEL_30;
        }

        break;
      }

      v81 = v35;
      v78 = (void *)objc_claimAutoreleasedReturnValue([v34 fullAssetSelector]);
      id v39 = (void *)objc_claimAutoreleasedReturnValue([v78 assetSpecifier]);
      uint64_t v40 = (NSString *)objc_claimAutoreleasedReturnValue([v32 fullAssetSelector]);
      v41 = (void *)objc_claimAutoreleasedReturnValue(-[NSString assetSpecifier](v40, "assetSpecifier"));
      if (!+[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v39, v41))
      {

        uint64_t v55 = v78;
LABEL_40:

        __int128 v35 = v81;
        goto LABEL_41;
      }

      uint64_t v74 = v34;
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v34 fullAssetSelector]);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v42 assetVersion]);
      id v75 = v39;
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v32 fullAssetSelector]);
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v44 assetVersion]);
      id v76 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v43, v45);

      id v32 = v73;
      if (!v76) {
        goto LABEL_42;
      }
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      v47 = (os_log_s *)objc_claimAutoreleasedReturnValue([v46 oslog]);

      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        v48 = (void *)objc_claimAutoreleasedReturnValue([v74 localContentURL]);
        unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([v73 localContentURL]);
        *(_DWORD *)buf = 138412546;
        v97 = v48;
        v98 = 2112;
        v99 = v49;
        _os_log_impl( &dword_0,  v47,  OS_LOG_TYPE_DEFAULT,  "{alreadyHaveSetDescriptorMatching} nextEntry localContent URL: %@, checkEntry localContent URL: %@",  buf,  0x16u);

        id v32 = v73;
      }

      v50 = (void *)objc_claimAutoreleasedReturnValue([v74 localContentURL]);
      v51 = (void *)objc_claimAutoreleasedReturnValue([v32 localContentURL]);
      uint64_t v52 = v32;
      uint64_t v53 = [v50 isEqual:v51];

      if ((v53 & 1) == 0)
      {
        v81 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
        __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v81 diag]);
        uint64_t v54 = objc_alloc(&OBJC_CLASS___NSString);
        __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v52 localContentURL]);
        id v38 = (void *)objc_claimAutoreleasedReturnValue([v37 absoluteURL]);
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v74 localContentURL]);
        v56 = objc_claimAutoreleasedReturnValue([v55 absoluteURL]);
        uint64_t v40 = -[NSString initWithFormat:]( v54,  "initWithFormat:",  @"{alreadyHaveSetDescriptorMatching} Set atomic entries with identical asset type, specifier and version has different paths on the filesystem. foundEntry: %@, persistedEntry:%@",  v38,  v56);
        [v36 trackAnomaly:@"AUTO-CONTROL" forReason:v40 withResult:6108 withError:0];
        id v32 = v52;
        id v39 = (void *)v56;
        goto LABEL_40;
      }

      id v31 = v63 + 1;
      uint64_t v30 = v65;
      if ((id)(v63 + 1) != v61) {
        continue;
      }
      break;
    }

    v61 = -[os_log_s countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v86,  v95,  16LL);
    if (v61) {
      continue;
    }
    break;
  }
                      }

                      else
                      {
                        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
                        __int128 v36 = (os_log_s *)objc_claimAutoreleasedReturnValue([v43 oslog]);

                        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue([v34 summary]);
                          *(_DWORD *)buf = 138543874;
                          v125 = (os_log_s *)v6;
                          v126 = 2114;
                          v127 = log;
                          v128 = 2114;
                          v129 = v44;
                          _os_log_error_impl( &dword_0,  v36,  OS_LOG_TYPE_ERROR,  "[AUTO-PRE-INSTALLED] {_preInstalledRelocateAutoAssets} Descriptor created for auto-asset met adata does not describe an auto-asset | path:%{public}@ | assetType:%{public}@ | descriptor:%{public}@",  buf,  0x20u);
                          goto LABEL_50;
                        }
                      }

void sub_B5674(_Unwind_Exception *a1)
{
}

void sub_B59B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t __Block_byref_object_copy__10(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

LABEL_95:
    if (!v254) {
      goto LABEL_25;
    }
    goto LABEL_96;
  }

  v278 = v329;

  v329 = 0LL;
  v226 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallUpdaterCryptex1MobileAssetCopyImg4WithRestoreInfo() failed with error %d (%@)",  v280,  AMAuthInstallGetLocalizedStatusString(cf, v280));
  v288 = (void *)objc_claimAutoreleasedReturnValue(v226);
  v227 = v278;
  v228 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  [v228 setObject:v288 forKeyedSubscript:NSDebugDescriptionErrorKey];
  [v228 setObject:v227 forKeyedSubscript:NSUnderlyingErrorKey];
  id v23 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  102LL,  v228));

  uint64_t v29 = 0;
  uint64_t v28 = 0LL;
LABEL_96:
  CFRelease(v254);
LABEL_25:
  if (cf) {
    CFRelease(cf);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (!v29)
  {
    uint64_t v58 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Failed to personalize asset bundle: %@", v23));
    uint64_t v59 = [v58 UTF8String];
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[SecureMobileAssetBundle _personalize:error:]",  @"[SMA] %s",  v60,  v61,  v62,  v63,  (uint64_t)v59);

    if (a4) {
      *a4 = v23;
    }
    -[SecureMobileAssetBundle depersonalize:](self, "depersonalize:", 0LL);
  }

  return v29;
}

void _securemobileassetbundle_log(int a1, uint64_t a2)
{
  if (a1 >= 4)
  {
    if ((a1 - 4) >= 3)
    {
      id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s", a2));
      id v6 = [v13 UTF8String];
      if (a1 >= 7)
      {
        _MobileAssetLog( 0LL,  7,  (uint64_t)"_securemobileassetbundle_log",  @"[SMA] %s",  v7,  v8,  v9,  v10,  (uint64_t)v6);
        goto LABEL_6;
      }
    }

    else
    {
      id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s", a2));
      id v6 = [v13 UTF8String];
    }

    _MobileAssetLog(0LL, 6, (uint64_t)"_securemobileassetbundle_log", @"[SMA] %s", v7, v8, v9, v10, (uint64_t)v6);
  }

  else
  {
    id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s", a2));
    id v12 = [v13 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"_securemobileassetbundle_log", @"[SMA] %s", v2, v3, v4, v5, (uint64_t)v12);
  }

LABEL_45:
LABEL_46:
          uint64_t v27 = 1;
          goto LABEL_47;
        }

        uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to read cryptex integrity catalog"));
        uint64_t v22 = v43;
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
        [v59 setObject:v58 forKeyedSubscript:NSDebugDescriptionErrorKey];
        [v59 setObject:v22 forKeyedSubscript:NSUnderlyingErrorKey];
        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  102LL,  v59));

        *a5 = v60;
        v48 = v80;
LABEL_29:

        uint64_t v27 = 0;
LABEL_47:
        id v31 = v81;
        goto LABEL_48;
      }

      v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to get integrity catalog path"));
      v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      [v56 setObject:v48 forKeyedSubscript:NSDebugDescriptionErrorKey];
      [v56 setObject:0 forKeyedSubscript:NSUnderlyingErrorKey];
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  102LL,  v56));
LABEL_28:

      *a5 = v57;
      goto LABEL_29;
    }

    uint64_t v55 = @"failed to store manifest";
LABEL_27:
    v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", v55));
    uint64_t v22 = v22;
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    [v56 setObject:v48 forKeyedSubscript:NSDebugDescriptionErrorKey];
    [v56 setObject:v22 forKeyedSubscript:NSUnderlyingErrorKey];
    uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  102LL,  v56));

    goto LABEL_28;
  }

  unsigned __int8 v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Manifest storage service unavailable"));
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  [v25 setObject:v24 forKeyedSubscript:NSDebugDescriptionErrorKey];
  [v25 setObject:0 forKeyedSubscript:NSUnderlyingErrorKey];
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  -5LL,  v25));

  *a5 = v26;
  uint64_t v27 = 0;
LABEL_50:

  return v27;
}

        objc_autoreleasePoolPop(v44);
        uint64_t v42 = (char *)v42 + 1;
      }

      while (v39 != v42);
      id v39 = [obja countByEnumeratingWithState:&v109 objects:v128 count:16];
    }

    while (v39);
  }

  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  __int128 v89 = v95;
  v61 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v89,  "countByEnumeratingWithState:objects:count:",  &v105,  v121,  16LL);
  if (!v61) {
    goto LABEL_60;
  }
  v62 = v61;
  id v63 = *(void *)v106;
  do
  {
    for (k = 0LL; k != v62; k = (char *)k + 1)
    {
      if (*(void *)v106 != v63) {
        objc_enumerationMutation(v89);
      }
      uint64_t v65 = *(void *)(*((void *)&v105 + 1) + 8LL * (void)k);
      uint64_t v66 = objc_autoreleasePoolPush();
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedDownloadedSetDescriptors]( v104,  "persistedDownloadedSetDescriptors"));
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v67 persistedEntry:v65 fromLocation:v101]);

      uint64_t v69 = [v68 secureCodedObjectForKey:@"assetSetDescriptor" ofClass:objc_opt_class(MADAutoSetDescriptor)];
      uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
      uint64_t v71 = v70;
      v96 = v68;
      objb = v66;
      if (v70)
      {
        id v72 = (void *)objc_claimAutoreleasedReturnValue([v70 latestDownloadedAtomicInstance]);

        if (v72)
        {
          v73 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( v104,  "downloadedSetDescriptorsByInstance"));
          uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v71 latestDownloadedAtomicInstance]);
          [v73 removeObjectForKey:v74];

          id v75 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedDownloadedSetDescriptors]( v104,  "persistedDownloadedSetDescriptors"));
          [v75 removePersistedEntry:v65 fromLocation:v101];

          id v76 = (void *)objc_claimAutoreleasedReturnValue([v71 latestDowloadedAtomicInstanceEntries]);
          id v77 = [v76 count];
          v78 = (void *)objc_claimAutoreleasedReturnValue([v71 clientDomainName]);
          v79 = v62;
          v80 = (void *)objc_claimAutoreleasedReturnValue([v71 assetSetIdentifier]);
          v81 = v63;
          uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v71 discoveredAtomicInstance]);
          +[MADAutoAssetHistory recordOperation:toHistoryType:fromLayer:usageCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromLayer:usageCount:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:",  377LL,  2LL,  1LL,  v77,  v78,  v80,  v82);

          id v63 = v81;
          v62 = v79;

          -[MADAutoAssetControlManager _logPersistedSetDescriptorRemoved:forComponentType:removedPersistedEntryID:removedSetDescriptor:message:]( v104,  "_logPersistedSetDescriptorRemoved:forComponentType:removedPersistedEntryID:removedSetDescriptor:message:",  v101,  @"SET_DOWNLOADED_DESCRIPTORS",  v65,  v71,  @"removing previously persisted downloaded-set-descriptor that has been eliminated");
          goto LABEL_58;
        }

        id v83 = @"EntryID: %@. latestDownloadAtomicInstance in descriptor to be dropped is nil";
      }

      else
      {
        id v83 = @"EntryID: %@. descriptor to be dropped is nil";
      }

      id v84 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", v83, v65);
      id v85 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v104, "autoControlManagerFSM"));
      __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v85 diag]);
      [v86 trackAnomaly:@"setDescriptorEliminateMatching" forReason:v84 withResult:6101 withError:0];

LABEL_58:
      objc_autoreleasePoolPop(objb);
    }

    v62 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v89,  "countByEnumeratingWithState:objects:count:",  &v105,  v121,  16LL);
  }

  while (v62);
LABEL_60:

  __int128 v37 = v87;
LABEL_61:

LABEL_62:
}

    id v13 = 0LL;
    goto LABEL_46;
  }

  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v13, v14) & 1) == 0)
  {
    if (a6) {
      *a6 = @"Invalid field type encountered when dictionary expected";
    }
LABEL_44:

    goto LABEL_45;
  }

  uint64_t v43 = 0u;
  uint64_t v44 = 0u;
  v41 = 0u;
  uint64_t v42 = 0u;
  id v13 = v13;
  uint64_t v15 = [v13 countByEnumeratingWithState:&v41 objects:v46 count:16];
  if (!v15)
  {

    goto LABEL_46;
  }

  uint64_t v16 = v15;
  __int128 v34 = a6;
  LOBYTE(v17) = 0;
  unsigned __int8 v18 = *(void *)v42;
  __int128 v35 = v13;
  while (2)
  {
    uint64_t v19 = 0LL;
    __int128 v36 = v16;
    do
    {
      if (*(void *)v42 != v18) {
        objc_enumerationMutation(v13);
      }
      uint64_t v20 = *(void *)(*((void *)&v41 + 1) + 8LL * (void)v19);
      uint64_t v21 = objc_autoreleasePoolPush();
      if ((v17 & 1) != 0)
      {
        uint64_t v17 = 1;
      }

      else
      {
        if (!v20 || (uint64_t v22 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v20, v22) & 1) == 0))
        {
          if (v34) {
            NSMutableSet *v34 = @"Invalid field type for dictionary provided by client";
          }
          goto LABEL_43;
        }

        id v23 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKey:v20]);
        if (!v23 || (unsigned __int8 v24 = objc_opt_class(&OBJC_CLASS___NSArray), (objc_opt_isKindOfClass(v23, v24) & 1) == 0))
        {
          if (v34) {
            NSMutableSet *v34 =  -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Invalid field type for dictionary where array values expected key:%@",  v20);
          }

LABEL_43:
          objc_autoreleasePoolPop(v21);

          goto LABEL_44;
        }

        id v39 = 0u;
        uint64_t v40 = 0u;
        __int128 v37 = 0u;
        id v38 = 0u;
        uint64_t v25 = v23;
        uint64_t v26 = [v25 countByEnumeratingWithState:&v37 objects:v45 count:16];
        if (v26)
        {
          uint64_t v27 = v26;
          uint64_t v28 = *(void *)v38;
          while (2)
          {
            uint64_t v29 = v18;
            for (uint64_t i = 0LL; i != v27; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v38 != v28) {
                objc_enumerationMutation(v25);
              }
              id v31 = *(void *)(*((void *)&v37 + 1) + 8LL * (void)i);
              if (v31)
              {
                id v32 = objc_opt_class(&OBJC_CLASS___NSString);
                if ((objc_opt_isKindOfClass(v31, v32) & 1) != 0) {
                  continue;
                }
              }

              if (v34) {
                NSMutableSet *v34 =  -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Invalid field type for dictionary of arrays where array values expected to be strings key:%@",  v20);
              }
              uint64_t v17 = 1;
              unsigned __int8 v18 = v29;
              id v13 = v35;
              goto LABEL_28;
            }

            uint64_t v27 = [v25 countByEnumeratingWithState:&v37 objects:v45 count:16];
            uint64_t v17 = 0;
            unsigned __int8 v18 = v29;
            id v13 = v35;
            if (v27) {
              continue;
            }
            break;
          }
        }

        else
        {
          uint64_t v17 = 0;
        }

      __int128 v36 = v29;
      uint64_t v43 = v26;
      result = sub_212358((char *)(v27 > 1), v29, 1, a4);
      uint64_t v26 = v43;
      uint64_t v29 = v36;
      a4 = result;
      goto LABEL_32;
    }

void sub_BAB68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, uint64_t a15, unsigned int a16, unsigned int a17)
{
  if (v17) {
    CFRelease(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t __os_cleanup_iorelease(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((_DWORD)result)
  {
    uint64_t result = IOObjectRelease(result);
    if ((_DWORD)result) {
      __os_cleanup_iorelease_cold_1(&v2, v3);
    }
  }

  return result;
}

uint64_t __os_cleanup_ioclose(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((_DWORD)result)
  {
    uint64_t result = IOServiceClose(result);
    if ((_DWORD)result) {
      __os_cleanup_ioclose_cold_1(&v2, v3);
    }
  }

  return result;
}

uint64_t __os_cleanup_close(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((_DWORD)result != -1)
  {
    uint64_t result = close(result);
    if ((_DWORD)result == -1) {
      __os_cleanup_close_cold_1(&v2, v3);
    }
  }

  return result;
}

void sub_BB4A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, unsigned int a23, int a24, unsigned int a25)
{
  if (v25) {
    CFRelease(v25);
  }
  if (v26) {
    CFRelease(v26);
  }
  __os_cleanup_iorelease(&a23);
  _Unwind_Resume(a1);
}

NSString *NSStringFromCFType(void *a1)
{
  if (a1)
  {
    CFRetain(a1);
    uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0)
    {
      uint64_t v3 = a1;
    }

    else
    {
      uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSData);
      if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0)
      {
        id v5 = a1;
        if ([v5 bytes])
        {
          id v6 = objc_alloc(&OBJC_CLASS___NSString);
          id v7 = v5;
          uint64_t v3 = -[NSString initWithBytes:length:encoding:]( v6,  "initWithBytes:length:encoding:",  [v7 bytes],  objc_msgSend(v7, "length"),  4);
        }

        else
        {
          uint64_t v3 = 0LL;
        }
      }

      else
      {
        uint64_t v3 = 0LL;
      }
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  return v3;
}

BOOL eject(void *a1, void *a2)
{
  kern_return_t v9;
  __objc2_ivar_list **p_ivars;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  void *v24;
  io_object_t v25;
  io_object_t v26;
  id v27;
  CFTypeRef CFProperty;
  const void *v29;
  void *v30;
  int v31;
  int v32;
  BOOL v33;
  io_object_t v34;
  int v35;
  uint64_t v36;
  NSString *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  NSString *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  io_object_t v47;
  void *v48;
  io_iterator_t iterator;
  void v50[2];
  void v51[2];
  void v52[2];
  void v53[2];
  NSErrorUserInfoKey v54;
  void *v55;
  void v56[3];
  void v57[3];
  void v58[3];
  void v59[3];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    uint64_t v17 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Nothing to eject!"));
    unsigned __int8 v18 = [v17 UTF8String];
    _MobileAssetLog(0LL, 7, (uint64_t)"eject", @"[SMA] %s", v19, v20, v21, v22, (uint64_t)v18);

    id v23 = 1LL;
    goto LABEL_32;
  }

  id v5 = objc_claimAutoreleasedReturnValue([v3 lastPathComponent]);
  id v6 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)[v5 fileSystemRepresentation]);

  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v6);
  if (!MatchingService)
  {
    v50[0] = NSDebugDescriptionErrorKey;
    v50[1] = @"BSD Name";
    v51[0] = @"eject failed: could not find matching IOService for volume";
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v4 lastPathComponent]);
    v51[1] = v14;
    unsigned __int8 v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v51,  v50,  2LL));
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  113LL,  v24));

    goto LABEL_28;
  }

  io_object_t v8 = MatchingService;
  iterator = 0;
  uint64_t v9 = IORegistryEntryCreateIterator(MatchingService, "IOService", 3u, &iterator);
  p_ivars = &MobileAssetKeyManager__metaData.ivars;
  if (!v9)
  {
    uint64_t v25 = IOIteratorNext(iterator);
    if (!v25)
    {
      uint64_t v14 = 0LL;
LABEL_25:
      IOObjectRelease(iterator);
      if (v14) {
        goto LABEL_5;
      }
LABEL_26:
      uint64_t v16 = 0LL;
      goto LABEL_27;
    }

    uint64_t v26 = v25;
    v47 = v8;
    v48 = a2;
    uint64_t v27 = 0LL;
    uint64_t v14 = 0LL;
    while (1)
    {
      if (!IOObjectConformsTo(v26, "IOMedia")) {
        goto LABEL_15;
      }
      CFProperty = IORegistryEntryCreateCFProperty(v26, @"BSD Name", kCFAllocatorDefault, 0);
      if (!CFProperty) {
        goto LABEL_15;
      }
      uint64_t v29 = CFProperty;
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([@"/dev/" stringByAppendingPathComponent:CFProperty]);

      CFRelease(v29);
      uint64_t v27 = v30;
      id v31 = open((const char *)[v27 fileSystemRepresentation], 0);
      if ((v31 & 0x80000000) == 0) {
        break;
      }
      __int128 v35 = *__error();
      __int128 v36 = v35;
      v58[0] = NSDebugDescriptionErrorKey;
      __int128 v37 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", strerror(v35));
      id v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
      v59[0] = v38;
      v59[1] = @"open";
      v58[1] = @"syscall";
      v58[2] = @"devNodePath";
      v59[2] = v27;
      id v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v59,  v58,  3LL));
      uint64_t v40 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v36,  v39));

      unsigned int v33 = 0;
      uint64_t v14 = (void *)v40;
LABEL_16:
      IOObjectRelease(v26);
      __int128 v34 = IOIteratorNext(iterator);
      if (v34)
      {
        uint64_t v26 = v34;
        if (v33) {
          continue;
        }
      }

      a2 = v48;
      io_object_t v8 = v47;
      p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
      goto LABEL_25;
    }

    id v32 = v31;
    if (ioctl(v31, 0x20006415uLL, 0LL) == -1)
    {
      v41 = *__error();
      unsigned int v33 = v41 == 25;
      if ((_DWORD)v41 != 25)
      {
        v56[0] = NSDebugDescriptionErrorKey;
        uint64_t v42 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", strerror(v41));
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
        v57[0] = v43;
        v57[1] = @"ioctl";
        v56[1] = @"syscall";
        v56[2] = @"devNodePath";
        v57[2] = v27;
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v57,  v56,  3LL));
        uint64_t v45 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v41,  v44));

        uint64_t v14 = (void *)v45;
      }

      close(v32);
      goto LABEL_16;
    }

    close(v32);
LABEL_15:
    unsigned int v33 = 1;
    goto LABEL_16;
  }

  uint64_t v11 = v9;
  uint64_t v54 = NSDebugDescriptionErrorKey;
  id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"IORegistryEntryCreateIterator() failed: 0x%04x",  v9 & 0x3FFF));
  uint64_t v55 = v12;
  id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v55,  &v54,  1LL));
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"IOKitErrorDomain",  v11,  v13));

  if (!v14) {
    goto LABEL_26;
  }
LABEL_5:
  v52[0] = NSDebugDescriptionErrorKey;
  v52[1] = NSUnderlyingErrorKey;
  v53[0] = @"eject failed";
  v53[1] = v14;
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( -[__objc2_ivar_list dictionaryWithObjects:forKeys:count:]( p_ivars[140],  "dictionaryWithObjects:forKeys:count:",  v53,  v52,  2LL));
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"SecureMobileAssetErrorDomain",  113LL,  v15));

LABEL_27:
  IOObjectRelease(v8);
LABEL_28:

  if (a2 && v16) {
    *a2 = v16;
  }
  id v23 = v16 == 0LL;

LABEL_32:
  return v23;
}

void sub_BD164( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14)
{
}

void sub_BD268(_Unwind_Exception *a1)
{
}

void sub_BD2DC(_Unwind_Exception *a1)
{
}

BOOL getMappedExclavePath(int a1, void *a2, void *a3)
{
  size_t __count = 0LL;
  unsigned int v33 = 0LL;
  if (fsctl("/", 0xC010411BuLL, &__count, 0))
  {
    uint64_t v6 = *__error();
    if ((_DWORD)v6 != 25)
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      io_object_t v8 = strerror(v6);
      if (v8)
      {
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8));
        [v7 setObject:v9 forKeyedSubscript:NSDebugDescriptionErrorKey];
      }

      [v7 setObject:@"fsctl()" forKeyedSubscript:@"syscall"];
      [v7 setObject:@"FSIOC_EXCLAVE_FS_GET_BASE_DIRS" forKeyedSubscript:@"request"];
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v6,  v7));

      uint64_t v11 = 0LL;
      goto LABEL_21;
    }

    goto LABEL_12;
  }

  uint64_t v12 = __count;
  if (!(_DWORD)__count)
  {
LABEL_12:
    uint64_t v11 = 0LL;
LABEL_13:
    uint64_t v19 = 0LL;
    goto LABEL_14;
  }

  id v13 = (char *)calloc(__count, 0x20uLL);
  uint64_t v11 = v13;
  if (!v13)
  {
    uint64_t v19 = 0LL;
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  12LL,  0LL));
    uint64_t v11 = 0LL;
    if (a2) {
      goto LABEL_22;
    }
LABEL_15:
    if (!a3) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

  unsigned int v33 = v13;
  if (fsctl("/", 0xC010411BuLL, &__count, 0))
  {
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    int v15 = *__error();
    uint64_t v16 = strerror(v15);
    if (v16)
    {
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v16));
      [v14 setObject:v17 forKeyedSubscript:NSDebugDescriptionErrorKey];
    }

    [v14 setObject:@"fsctl()" forKeyedSubscript:@"syscall"];
    [v14 setObject:@"FSIOC_EXCLAVE_FS_GET_BASE_DIRS" forKeyedSubscript:@"request"];
    unsigned __int8 v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v12));
    [v14 setObject:v18 forKeyedSubscript:@"alloc_count"];

    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v15,  v14));
  }

  else
  {
    if (__count > v12)
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
      goto LABEL_21;
    }

    if (!(_DWORD)__count) {
      goto LABEL_13;
    }
    uint64_t v21 = 0LL;
    while (*(_DWORD *)&v11[v21] != a1)
    {
      v21 += 32LL;
    }

    uint64_t v22 = &v11[v21];
    uint64_t v23 = *(void *)&v11[v21 + 4];
    if ((fsgetpath(v34, 0x400uLL, (fsid_t *)&v11[v21 + 4], *(void *)&v11[v21 + 16]) & 0x8000000000000000LL) == 0)
    {
      unsigned __int8 v24 = realpath_DARWIN_EXTSN(v34, 0LL);
      if (v24) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v34;
      }
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v25));
      free(v24);
LABEL_14:
      uint64_t v10 = 0LL;
      if (a2) {
        goto LABEL_22;
      }
      goto LABEL_15;
    }

    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    int v27 = *__error();
    uint64_t v28 = strerror(v27);
    if (v28)
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v28));
      [v26 setObject:v29 forKeyedSubscript:NSDebugDescriptionErrorKey];
    }

    [v26 setObject:@"fsgetpath()" forKeyedSubscript:@"syscall"];
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"0x%llx", v23));
    [v26 setObject:v30 forKeyedSubscript:@"fsid"];

    id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  *((void *)v22 + 2)));
    [v26 setObject:v31 forKeyedSubscript:@"inode"];

    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v27,  v26));
  }

void sub_BDF60(_Unwind_Exception *a1)
{
}

uint64_t unregisterMappedExclavePath(const char *a1, void *a2)
{
  int v13 = 0;
  uint64_t v4 = fsctl(a1, 0x8004411AuLL, &v13, 0);
  if (!(_DWORD)v4)
  {
    uint64_t v11 = 0LL;
    if (!a2) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  int v5 = *__error();
  uint64_t v6 = v5;
  id v7 = strerror(v5);
  io_object_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  if (v7)
  {
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7));
    [v8 setObject:v9 forKeyedSubscript:NSDebugDescriptionErrorKey];
  }

  [v8 setObject:@"fsctl()" forKeyedSubscript:@"syscall"];
  [v8 setObject:@"FSIOC_EXCLAVE_FS_UNREGISTER" forKeyedSubscript:@"request"];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
  [v8 setObject:v10 forKeyedSubscript:@"base_dir"];

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v6,  v8));
  if (a2) {
LABEL_5:
  }
    *a2 = v11;
LABEL_6:

  return v4;
}

void sub_BE194(_Unwind_Exception *a1)
{
}

void sub_BF0B4(_Unwind_Exception *a1)
{
}

void sub_BF574(_Unwind_Exception *a1)
{
}

void sub_BF5F8(_Unwind_Exception *a1)
{
}

void sub_BF678(_Unwind_Exception *a1)
{
}

void ___cryptex1_product_class_block_invoke(id a1)
{
  int v1 = img4_chip_instantiate();
  if (v1) {
    _os_assumes_log(v1);
  }
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"0x%lX", 0LL));
  id v3 = (void *)_cryptex1_product_class_productClass;
  _cryptex1_product_class_productClass = v2;
}

uint64_t OUTLINED_FUNCTION_0_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _os_log_send_and_compose_impl(a1, v6, v5, 80LL, a5, v7, 16LL);
}

BOOL OUTLINED_FUNCTION_1_2()
{
  return os_log_type_enabled(v0, OS_LOG_TYPE_ERROR);
}

  ;
}

double OUTLINED_FUNCTION_3_2(void *a1, _OWORD *a2)
{
  *a1 = 0LL;
  double result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

uint64_t OUTLINED_FUNCTION_4_3(uint64_t a1)
{
  return _os_crash_msg(*v1, a1);
}

void sub_BFD94(_Unwind_Exception *a1)
{
}

uint64_t _MobileAssetVerifyAssetMapSignature(const __CFDictionary *a1)
{
  int Value = (const __CFData *)CFDictionaryGetValue(a1, @"Signature");
  if (!Value)
  {
    uint64_t v43 = @"No signature in asset map";
LABEL_16:
    _MobileAssetLog(0LL, 3, (uint64_t)"_MobileAssetVerifyAssetMapSignature", v43, v3, v4, v5, v6, v117);
    return 7LL;
  }

  uint64_t v7 = Value;
  CFTypeID v8 = CFGetTypeID(Value);
  if (v8 != CFDataGetTypeID())
  {
    uint64_t v43 = @"Signature data is not CFData";
    goto LABEL_16;
  }

  uint64_t v9 = (const __CFData *)CFDictionaryGetValue(a1, @"Certificate");
  if (!v9)
  {
    uint64_t v43 = @"No certificate in asset map";
    goto LABEL_16;
  }

  uint64_t v10 = v9;
  CFTypeID v11 = CFGetTypeID(v9);
  if (v11 != CFDataGetTypeID())
  {
    uint64_t v43 = @"Certificate data is not CFData";
    goto LABEL_16;
  }

  SecCertificateRef v12 = SecCertificateCreateWithData(kCFAllocatorDefault, v10);
  if (!v12)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyAssetMapSignature",  @"Could not create certificate from data",  v13,  v14,  v15,  v16,  v117);
    return 5LL;
  }

  SecCertificateRef v17 = v12;
  SecTrustRef trust = 0LL;
  _MobileAssetLog( 0LL,  6,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Obtaining public key from certificate",  v13,  v14,  v15,  v16,  v117);
  uint64_t MobileAsset = SecPolicyCreateMobileAsset();
  if (!MobileAsset)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Could not create MobileAsset certificate policy",  v19,  v20,  v21,  v22,  v118);
    uint64_t v46 = 0LL;
    uint64_t v44 = 5LL;
    goto LABEL_33;
  }

  uint64_t v23 = (const void *)MobileAsset;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Failed to allocate array",  v25,  v26,  v27,  v28,  v118);
    goto LABEL_22;
  }

  uint64_t v29 = Mutable;
  CFArrayAppendValue(Mutable, v17);
  uint64_t v30 = (const void *)SecCertificateCreateWithBytes(0LL, &iPhoneCACert_crt, iPhoneCACert_crt_len);
  if (!v30
    || (__int128 v35 = v30,
        CFArrayAppendValue(v29, v30),
        CFRelease(v35),
        (__int128 v36 = (const void *)SecCertificateCreateWithBytes(0LL, &iphoneCACert2, 1096LL)) == 0LL))
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Failed to create Apple iPhone CA certificate",  v31,  v32,  v33,  v34,  v118);
    CFRelease(v29);
LABEL_22:
    uint64_t v46 = 0LL;
    SecKeyRef v47 = 0LL;
    uint64_t v44 = 5LL;
    goto LABEL_28;
  }

  __int128 v37 = v36;
  CFArrayAppendValue(v29, v36);
  OSStatus v38 = SecTrustCreateWithCertificates(v29, v23, &trust);
  if (v38)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Could not create secure trust object: %ld",  v39,  v40,  v41,  v42,  v38);
LABEL_25:
    uint64_t v46 = 0LL;
    SecKeyRef v47 = 0LL;
    goto LABEL_26;
  }

  OSStatus v48 = SecTrustEvaluate(trust, &result);
  if (v48)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Could not evaluate trust: %ld",  v49,  v50,  v51,  v52,  v48);
    goto LABEL_25;
  }

  if (result != kSecTrustResultProceed && result != kSecTrustResultUnspecified)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Certificate trust evaluation failed: %ld",  v49,  v50,  v51,  v52,  result);
    goto LABEL_25;
  }

  SecKeyRef v104 = SecTrustCopyPublicKey(trust);
  SecKeyRef v47 = v104;
  if (v104)
  {
    uint64_t v46 = (__SecKey *)CFRetain(v104);
    _MobileAssetLog( 0LL,  6,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Successfully extracted public key from trust object",  v109,  v110,  v111,  v112,  v118);
    uint64_t v44 = 0LL;
    goto LABEL_27;
  }

  _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyStrongSigning",  @"Could not extract public key from trust object",  v105,  v106,  v107,  v108,  v118);
  uint64_t v46 = 0LL;
LABEL_26:
  uint64_t v44 = 24LL;
LABEL_27:
  CFRelease(v29);
  CFRelease(v37);
LABEL_28:
  CFRelease(v23);
  if (trust)
  {
    CFRelease(trust);
    SecTrustRef trust = 0LL;
  }

  if (v47) {
    CFRelease(v47);
  }
  if (!(_DWORD)v44) {
    goto LABEL_57;
  }
LABEL_33:
  if ((os_variant_has_internal_content("com.apple.MobileAsset") & 1) == 0)
  {
    uint64_t v57 = os_variant_allows_internal_security_policies("com.apple.MobileAsset");
    if (!(_DWORD)v57)
    {
      uint64_t v120 = v44;
      id v77 = @"Could not verify production asset map signing: %d";
LABEL_56:
      int v84 = 5;
      goto LABEL_67;
    }
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"_MobileAssetVerifyAssetMapSignature",  @"Attempting to verify Development signed metadata",  v53,  v54,  v55,  v56,  v119);
  SecTrustRef trust = 0LL;
  uint64_t MobileAssetDevelopment = SecPolicyCreateMobileAssetDevelopment();
  if (!MobileAssetDevelopment)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyDevelopmentSigning",  @"Could not create X509 policy",  v59,  v60,  v61,  v62,  v119);
    uint64_t v46 = 0LL;
    uint64_t v44 = 5LL;
LABEL_55:
    uint64_t v120 = v44;
    id v77 = @"Could not verify asset map signing: %d";
    uint64_t v57 = 0LL;
    goto LABEL_56;
  }

  id v63 = (const void *)MobileAssetDevelopment;
  uint64_t v64 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  uint64_t v69 = v64;
  if (!v64)
  {
    v78 = @"Failed to allocate array";
LABEL_44:
    _MobileAssetLog(0LL, 3, (uint64_t)"_MobileAssetVerifyDevelopmentSigning", v78, v65, v66, v67, v68, v119);
    uint64_t v46 = 0LL;
    uint64_t v44 = 5LL;
    goto LABEL_50;
  }

  CFArrayAppendValue(v64, v17);
  uint64_t v70 = (const void *)SecCertificateCreateWithBytes(0LL, &iphoneCACert2, 1096LL);
  if (!v70)
  {
    v78 = @"Failed to create Apple iPhone CA certificate";
    goto LABEL_44;
  }

  uint64_t v71 = v70;
  CFArrayAppendValue(v69, v70);
  OSStatus v72 = SecTrustCreateWithCertificates(v69, v63, &trust);
  if (v72)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyDevelopmentSigning",  @"Could not create secure trust object: %ld",  v73,  v74,  v75,  v76,  v72);
LABEL_47:
    uint64_t v46 = 0LL;
    goto LABEL_48;
  }

  OSStatus v79 = SecTrustEvaluate(trust, &result);
  if (v79)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyDevelopmentSigning",  @"Could not evaluate trust: %ld",  v80,  v81,  v82,  v83,  v79);
    goto LABEL_47;
  }

  if (result != kSecTrustResultProceed && result != kSecTrustResultUnspecified)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyDevelopmentSigning",  @"Certificate trust evaluation failed: %ld",  v80,  v81,  v82,  v83,  result);
    goto LABEL_47;
  }

  uint64_t v46 = SecTrustCopyPublicKey(trust);
  if (v46)
  {
    uint64_t v44 = 0LL;
    goto LABEL_49;
  }

  _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetVerifyDevelopmentSigning",  @"Could not extract public key from trust object",  v113,  v114,  v115,  v116,  v119);
LABEL_48:
  uint64_t v44 = 24LL;
LABEL_49:
  CFRelease(v71);
LABEL_50:
  CFRelease(v63);
  if (trust)
  {
    CFRelease(trust);
    SecTrustRef trust = 0LL;
  }

  if (v69) {
    CFRelease(v69);
  }
  if ((_DWORD)v44) {
    goto LABEL_55;
  }
LABEL_57:
  _MobileAssetLog( 0LL,  6,  (uint64_t)"_MobileAssetVerifyAssetMapSignature",  @"Verifying metadata signature...",  v53,  v54,  v55,  v56,  v119);
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, a1);
  if (MutableCopy)
  {
    v90 = MutableCopy;
    CFDictionaryRemoveValue(MutableCopy, @"Certificate");
    CFDictionaryRemoveValue(v90, @"Signature");
    CFDictionaryRemoveValue(v90, @"SigningKey");
    v95 = (uint8_t *)_hashCFDictionary(v90, 1LL);
    if (v95)
    {
      BytePtr = CFDataGetBytePtr(v7);
      size_t Length = CFDataGetLength(v7);
      uint64_t v98 = SecKeyRawVerify(v46, 0x8002u, v95, 0x14uLL, BytePtr, Length);
      if ((_DWORD)v98)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetDecryptAndVerifySignature",  @"Could not verify signature using public key: %d",  v99,  v100,  v101,  v102,  v98);
        char v103 = 0;
        uint64_t v44 = 24LL;
      }

      else
      {
        uint64_t v44 = 0LL;
        char v103 = 1;
      }
    }

    else
    {
      _MobileAssetLog( 0LL,  5,  (uint64_t)"_MobileAssetDecryptAndVerifySignature",  @"Could not hash asset map dictionary",  v91,  v92,  v93,  v94,  v120);
      char v103 = 0;
      uint64_t v44 = 23LL;
    }

    free(v95);
    CFRelease(v90);
    if ((v103 & 1) != 0)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"_MobileAssetVerifyAssetMapSignature",  @"Successfully verified metadata signature...",  v53,  v54,  v55,  v56,  v120);
      uint64_t v44 = 0LL;
      goto LABEL_68;
    }
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"_MobileAssetDecryptAndVerifySignature",  @"Could not copy asset map dictionary",  v86,  v87,  v88,  v89,  v120);
    uint64_t v44 = 5LL;
  }

  id v77 = @"Could not validate asset map signature";
  uint64_t v57 = 0LL;
  int v84 = 3;
LABEL_67:
  _MobileAssetLog(v57, v84, (uint64_t)"_MobileAssetVerifyAssetMapSignature", v77, v53, v54, v55, v56, v120);
LABEL_68:
  CFRelease(v17);
  if (v46) {
    CFRelease(v46);
  }
  return v44;
}

void MABrainLoadFeaturesOverrides()
{
  if (_MAPreferencesIsInternalAllowed())
  {
    id v0 = _MAPreferencesCopyValue(@"SupportedFeaturesOverride");
    id v11 = (id)objc_claimAutoreleasedReturnValue(v0);
    if (v11)
    {
      uint64_t v1 = objc_opt_class(&OBJC_CLASS___NSDictionary);
      if ((objc_opt_isKindOfClass(v11, v1) & 1) != 0)
      {
        id v2 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Overriding supported features: %@", v11));
        id v3 = [v2 UTF8String];
        _MobileAssetLog(0LL, 6, (uint64_t)"MABrainLoadFeaturesOverrides", @"[MAB] %s", v4, v5, v6, v7, (uint64_t)v3);

        id v8 = [&off_38FC50 mutableCopy];
        [v8 addEntriesFromDictionary:v11];
        uint64_t v9 = (_UNKNOWN **)[v8 copy];
        uint64_t v10 = _brainSupportedFeatures;
        _brainSupportedFeatures = v9;
      }
    }
  }

id downloadManagerDecodeClasses()
{
  if (downloadManagerDecodeClasses_once != -1) {
    dispatch_once(&downloadManagerDecodeClasses_once, &__block_literal_global_17);
  }
  return (id)downloadManagerDecodeClasses__downloadManagerDecodeClasses;
}

void __downloadManagerDecodeClasses_block_invoke(id a1)
{
  uint64_t v1 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSData);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSDate);
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSString);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSNumber);
  uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSArray);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSMutableData);
  uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSMutableString);
  uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v15 = objc_opt_class(&OBJC_CLASS___MADownloadOptions);
  uint64_t v16 = objc_opt_class(&OBJC_CLASS___MAMsuDownloadOptions);
  uint64_t v17 = objc_opt_class(&OBJC_CLASS___MADownloadConfig);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v5, 13LL));
  id v3 = -[NSSet initWithArray:](v1, "initWithArray:", v2, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
  uint64_t v4 = (void *)downloadManagerDecodeClasses__downloadManagerDecodeClasses;
  downloadManagerDecodeClasses__downloadManagerDecodeClasses = (uint64_t)v3;
}

NSDictionary *pallasStringParams()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __pallasStringParams_block_invoke;
  block[3] = &unk_34DBC0;
  id v0 = (id)objc_claimAutoreleasedReturnValue(+[SUCoreDevice sharedDevice](&OBJC_CLASS___SUCoreDevice, "sharedDevice"));
  id v15 = v0;
  if (pallasStringParams_once != -1) {
    dispatch_once(&pallasStringParams_once, block);
  }
  uint64_t v1 = objc_alloc(&OBJC_CLASS___NSMutableDictionary);
  id v2 = -[NSMutableDictionary initWithDictionary:](v1, "initWithDictionary:", pallasStringParams_params);
  if ((objc_opt_respondsToSelector(v0, "hasSplat") & 1) != 0 && [v0 hasSplat])
  {
    if ((objc_opt_respondsToSelector(v0, "hasSplat") & 1) != 0)
    {
      else {
        id v3 = @"false";
      }
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v3, @"SplatSupported");
    }

    if ((objc_opt_respondsToSelector(v0, "splatCryptex1RestoreVersion") & 1) != 0)
    {
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v0 splatCryptex1RestoreVersion]);
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v4, @"SplatRestoreVersion");
    }

    if ((objc_opt_respondsToSelector(v0, "splatCryptex1ProductVersion") & 1) != 0)
    {
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v0 splatCryptex1ProductVersion]);
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v5, @"SplatProductVersion");
    }

    if ((objc_opt_respondsToSelector(v0, "splatCryptex1ProductVersionExtra") & 1) != 0)
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v0 splatCryptex1ProductVersionExtra]);
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v6, @"SplatProductVersionExtra");
    }

    if ((objc_opt_respondsToSelector(v0, "splatCryptex1BuildVersion") & 1) != 0)
    {
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v0 splatCryptex1BuildVersion]);
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v7, @"SplatBuildVersion");
    }

    if ((objc_opt_respondsToSelector(v0, "splatCryptex1ReleaseType") & 1) != 0)
    {
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v0 splatCryptex1ReleaseType]);
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v8, @"SplatReleaseType");
    }

    if ((objc_opt_respondsToSelector(v0, "hasSplatOnlyUpdateInstalled") & 1) != 0)
    {
      else {
        uint64_t v9 = @"false";
      }
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v9, @"SplatHasUpdateInstalled");
    }

    if ((objc_opt_respondsToSelector(v0, "hasEligibleRollback") & 1) != 0)
    {
      else {
        uint64_t v10 = @"false";
      }
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v10, @"SplatHasEligibleRollback");
    }

    if ((objc_opt_respondsToSelector(v0, "hasSemiSplatActive") & 1) != 0)
    {
      else {
        uint64_t v11 = @"false";
      }
      -[NSMutableDictionary setSafeObject:forKey:](v2, "setSafeObject:forKey:", v11, @"SplatHasSemiSplatActive");
    }
  }

  uint64_t v12 = -[NSDictionary initWithDictionary:](objc_alloc(&OBJC_CLASS___NSDictionary), "initWithDictionary:", v2);

  return v12;
}

void __pallasStringParams_block_invoke(uint64_t a1)
{
  id v2 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  id v3 = (void *)pallasStringParams_params;
  pallasStringParams_params = (uint64_t)v2;

  v21[0] = @"BuildID";
  v21[1] = @"BuildVersion";
  v21[2] = @"DeviceName";
  v21[3] = @"DeviceVariant";
  void v21[4] = @"ProductName";
  v21[5] = @"ProductType";
  v21[6] = @"ProductVersion";
  v21[7] = @"ReleaseType";
  v21[8] = @"SystemImageID";
  v21[9] = @"HardwarePlatform";
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v4 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v21, 10LL));
  id v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v17;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v16 + 1) + 8LL * (void)i);
        uint64_t v10 = (void *)pallasStringParams_params;
        uint64_t v11 = (void *)MGGetStringAnswer(v9);
        objc_msgSend(v10, "setSafeObject:forKey:", v11, v9, (void)v16);
      }

      id v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v6);
  }

  if ((objc_opt_respondsToSelector(*(void *)(a1 + 32), "hwModelString") & 1) != 0)
  {
    uint64_t v12 = (void *)pallasStringParams_params;
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) hwModelString]);
    [v12 setSafeObject:v13 forKey:@"HWModelStr"];
  }

  if ((objc_opt_respondsToSelector(*(void *)(a1 + 32), "restoreVersion") & 1) != 0)
  {
    uint64_t v14 = (void *)pallasStringParams_params;
    id v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) restoreVersion]);
    [v14 setSafeObject:v15 forKey:@"RestoreVersion"];
  }
}

id isXMLAssetType(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (isXMLAssetType_once == -1)
  {
    if (!v1)
    {
LABEL_9:
      id v4 = 0LL;
      goto LABEL_10;
    }
  }

  else
  {
    dispatch_once(&isXMLAssetType_once, &__block_literal_global_678);
    if (!v2) {
      goto LABEL_9;
    }
  }

  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSString);
  if ((objc_opt_isKindOfClass(v2, v3) & 1) == 0) {
    goto LABEL_9;
  }
  if (([(id)isXMLAssetType_assetTypes containsObject:v2] & 1) != 0
    || ([v2 hasPrefix:@"com.apple.MobileAsset.UARP"] & 1) != 0)
  {
    id v4 = &dword_0 + 1;
  }

  else
  {
    id v4 = [v2 hasPrefix:@"com.apple.MobileAsset.MobileAccessoryUpdate"];
  }

void __isXMLAssetType_block_invoke(id a1)
{
  id v1 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", &off_38FAF0);
  id v2 = (void *)isXMLAssetType_assetTypes;
  isXMLAssetType_assetTypes = (uint64_t)v1;
}

uint64_t isExternalPreReleaseAssetType(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (isExternalPreReleaseAssetType_once == -1)
  {
    if (!v1)
    {
LABEL_18:
      uint64_t v10 = 0LL;
      goto LABEL_19;
    }
  }

  else
  {
    dispatch_once(&isExternalPreReleaseAssetType_once, &__block_literal_global_977);
    if (!v2) {
      goto LABEL_18;
    }
  }

  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSString);
  if ((objc_opt_isKindOfClass(v2, v3) & 1) == 0) {
    goto LABEL_18;
  }
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v4 = (id)isExternalPreReleaseAssetType_assetTypes;
  id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v12 + 1) + 8LL * (void)i);
        if ((objc_msgSend(v2, "isEqual:", v9, (void)v12) & 1) != 0
          || ([v2 hasPrefix:v9] & 1) != 0)
        {
          uint64_t v10 = 1LL;
          goto LABEL_16;
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      uint64_t v10 = 0LL;
      if (v6) {
        continue;
      }
      break;
    }
  }

  else
  {
    uint64_t v10 = 0LL;
  }

void __isExternalPreReleaseAssetType_block_invoke(id a1)
{
  id v1 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", &off_38FB08);
  id v2 = (void *)isExternalPreReleaseAssetType_assetTypes;
  isExternalPreReleaseAssetType_assetTypes = (uint64_t)v1;
}

uint64_t isAppleDynamicOverridesSupportedAssetType(void *a1)
{
  id v1 = a1;
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    && (__int128 v12 = 0u,
        __int128 v13 = 0u,
        __int128 v10 = 0u,
        __int128 v11 = 0u,
        (id v3 = [&off_38FB20 countByEnumeratingWithState:&v10 objects:v14 count:16]) != 0))
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(&off_38FB20);
        }
        uint64_t v7 = *(void *)(*((void *)&v10 + 1) + 8LL * (void)i);
        if (([v1 isEqual:v7] & 1) != 0
          || ([v1 hasPrefix:v7] & 1) != 0)
        {
          uint64_t v8 = 1LL;
          goto LABEL_14;
        }
      }

      id v4 = [&off_38FB20 countByEnumeratingWithState:&v10 objects:v14 count:16];
      uint64_t v8 = 0LL;
      if (v4) {
        continue;
      }
      break;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

void __getDownloadManager_block_invoke(id a1)
{
  id v1 = objc_opt_new(&OBJC_CLASS___DownloadManager);
  uint64_t v2 = (void *)getDownloadManager_downloadManager;
  getDownloadManager_downloadManager = (uint64_t)v1;

  [(id)getDownloadManager_downloadManager initializeSessionsAsync];
}

NSString *_currentTimeInMilliseconds()
{
  id v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
  [v0 timeIntervalSince1970];
  double v2 = v1;

  return +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  (unint64_t)(v2 * *(double *)""));
}

BOOL isForcedResultPreferenceSetForAssetType(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (_MAPreferencesIsInternalAllowed())
  {
    char v16 = 0;
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@-%@", v5, v6));
    AppIntegerint Value = _MAPreferencesGetAppIntegerValue(v7, &v16);
    BOOL v13 = v16 != 0;
    if (v16)
    {
      id v14 = AppIntegerValue;
      _MobileAssetLog( 0LL,  6,  (uint64_t)"isForcedResultPreferenceSetForAssetType",  @"Found %@ preference override. Will force result %ld.",  v9,  v10,  v11,  v12,  (uint64_t)v7);
      if (a3) {
        *a3 = v14;
      }
    }
  }

  else
  {
    BOOL v13 = 0LL;
  }

  return v13;
}

BOOL isForcedBuildPreferenceSetForAssetType(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (!_MAPreferencesIsInternalAllowed())
  {
    BOOL v14 = 0LL;
    uint64_t v9 = 0LL;
    if (!a3) {
      goto LABEL_13;
    }
    goto LABEL_9;
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@-%@", v5, v6));
  uint64_t v8 = _MAPreferencesCopyNSStringValue(v7);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  BOOL v14 = isWellFormedSystemBuildId(v9);
  if (v14)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"isForcedBuildPreferenceSetForAssetType",  @"Found %@ preference override. Will force build '%@'.",  v10,  v11,  v12,  v13,  (uint64_t)v7);
  }

  else if (v9)
  {
    __int128 v15 = (objc_class *)objc_opt_class(v9);
    char v16 = NSStringFromClass(v15);
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v16);
    _MobileAssetLog( 0LL,  3,  (uint64_t)"isForcedBuildPreferenceSetForAssetType",  @"Found %@ preference override. Was not well formed, will ignore '%@' (%@).",  v17,  v18,  v19,  v20,  (uint64_t)v7);

    uint64_t v9 = 0LL;
  }

  if (a3)
  {
LABEL_9:
    if (v14) {
      uint64_t v21 = v9;
    }
    else {
      uint64_t v21 = 0LL;
    }
    *a3 = v21;
  }

id getStandardUrl(void *a1, void *a2)
{
  id v3 = a1;
  id v8 = a2;
  if (!v3)
  {
    __int128 v35 = @"Nil asset type when trying to get standard url";
LABEL_11:
    _MobileAssetLog(0LL, 6, (uint64_t)"getStandardUrl", v35, v4, v5, v6, v7, v39);
LABEL_12:
    uint64_t v34 = 0LL;
    goto LABEL_13;
  }

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[ASAssetMetadataUpdatePolicy policy](&OBJC_CLASS___ASAssetMetadataUpdatePolicy, "policy"));
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 serverURLForAssetType:v3]);

  if (!v10)
  {
    __int128 v35 = @"Nil url when trying serverURLForAssetType";
    goto LABEL_11;
  }

  if (![v3 isEqualToString:@"com.apple.MobileAsset.SystemApp"])
  {
    if (v8)
    {
      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v10 URLByAppendingPathComponent:v8]);

      OSStatus v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@%@%@",  v8,  @".",  @"xml"));
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v37 URLByAppendingPathComponent:v38]);

      goto LABEL_13;
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"getStandardUrl",  @"Nil normalizedAssetTypeStr when trying to assemble url",  v11,  v12,  v13,  v14,  v39);

    goto LABEL_12;
  }

  __int128 v15 = (void *)MGCopyAnswer(@"BuildID", 0LL);
  char v16 = (void *)MGCopyAnswer(@"SystemImageID", 0LL);
  id v41 = 0LL;
  BOOL v17 = isForcedBuildPreferenceSetForAssetType(@"ForceSystemAssetBuildId", v3, &v41);
  id v18 = v41;
  uint64_t v23 = v18;
  if (v17)
  {
    id v24 = v23;

    __int128 v15 = v24;
  }

  id v40 = 0LL;
  BOOL v25 = isForcedBuildPreferenceSetForAssetType(@"ForceSystemAssetSystemImageId", v3, &v40);
  id v26 = v40;
  uint64_t v31 = v26;
  if (v25)
  {
    id v32 = v31;

    char v16 = v32;
  }

  id v33 = augmentPathForSystemApp(v3, v10, (uint64_t)v15, v16);
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(v33);

LABEL_13:
  return v34;
}

id getPmvUrl(uint64_t a1, uint64_t a2)
{
  int v2 = a1;
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[DownloadManager getPallasUrl:assetType:]( &OBJC_CLASS___DownloadManager,  "getPallasUrl:assetType:",  a1,  a2));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 absoluteString]);
  unsigned int v5 = [v4 containsString:@"/assets"];

  if (v5)
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v3 URLByDeletingLastPathComponent]);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 URLByAppendingPathComponent:@"pmv"]);
  }

  else if (v2)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"getPmvUrl",  @"The pallas URL doesn't contain /assets, so we cannot substitute /pmv. Falling back to static PMV: %@",  v6,  v7,  v8,  v9,  (uint64_t)@"https://gdmf.apple.com/v2/pmv");
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  @"https://gdmf.apple.com/v2/pmv"));
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  return v11;
}

LABEL_31:
          goto LABEL_32;
        }

        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager sendEvents:sessionId:]",  @"SPLUNK Failed due to nil path to file",  v38,  v39,  v40,  v41,  v65);

LABEL_13:
        __int128 v36 = 0LL;
LABEL_32:

        goto LABEL_33;
      }
    }

    else
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager sendEvents:sessionId:]",  @"SPLUNK unable to create payload",  v20,  v21,  v22,  v23,  v65);
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager sendEvents:sessionId:]",  @"SPLUNK Failed due to nil data",  v25,  v26,  v27,  v28,  v65);
    __int128 v35 = 0LL;
    goto LABEL_13;
  }

LABEL_32:
              objc_autoreleasePoolPop(v20);
              uint64_t v11 = v84;
              goto LABEL_33;
            }

            id v33 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v26 = (id)objc_claimAutoreleasedReturnValue([v33 oslog]);

            if (!os_log_type_enabled((os_log_t)v26, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_32;
            }
            uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            id v32 = (void *)objc_claimAutoreleasedReturnValue([v13 summary]);
            *(_DWORD *)buf = 138543618;
            v90 = v28;
            uint64_t v91 = 2114;
            uint64_t v92 = v32;
            _os_log_impl( &dword_0,  (os_log_t)v26,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {ScheduleSetJobs} no auto-asset-entries (so not scheuling set-job) | schedulerTriggered:%{public}@",  buf,  0x16u);
          }

          else
          {
            uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v26 = (id)objc_claimAutoreleasedReturnValue([v31 oslog]);

            if (!os_log_type_enabled((os_log_t)v26, OS_LOG_TYPE_ERROR)) {
              goto LABEL_32;
            }
            uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            id v32 = (void *)objc_claimAutoreleasedReturnValue([v13 summary]);
            *(_DWORD *)buf = 138543618;
            v90 = v28;
            uint64_t v91 = 2114;
            uint64_t v92 = v32;
            _os_log_error_impl( &dword_0,  (os_log_t)v26,  OS_LOG_TYPE_ERROR,  "[%{public}@] {ScheduleSetJobs} MISSING required field(s) | schedulerTriggered:%{public}@",  buf,  0x16u);
          }

          goto LABEL_31;
        }

        BOOL v17 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v17 oslog]);

        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([v13 summary]);
          *(_DWORD *)buf = 138543362;
          v90 = v19;
          _os_log_impl( &dword_0,  v18,  OS_LOG_TYPE_DEFAULT,  "\n [SET-ELIMINATE]{ScheduleSetJobs} [IGNORED] set-identifier being eliminated - scheduler trigger ignored | sch edulerTriggered:%{public}@",  buf,  0xCu);
        }

LABEL_33:
        uint64_t v12 = (char *)v12 + 1;
      }

      while (v10 != v12);
      uint64_t v10 = [v8 countByEnumeratingWithState:&v85 objects:v93 count:16];
    }

    while (v10);
  }

  -[MADAutoAssetControlManager secureCheckProcessLifeLocks:]( self,  "secureCheckProcessLifeLocks:",  @"ScheduleSetJobs");
  -[MADAutoAssetControlManager _statsMaintainReporting](self, "_statsMaintainReporting");

  return 0LL;
}

    id v41 = (SUCoreConnectMessage *)v13;
    goto LABEL_42;
  }

  char v16 = (void *)objc_claimAutoreleasedReturnValue([v13 messageName]);
  if (([v16 isEqualToString:@"MA-AUTO(REPLY):LOCK_CONTENT"] & 1) == 0)
  {
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue([v13 messageName]);
    if ([v17 isEqualToString:@"MA-AUTO(REPLY):CONTINUE_LOCK_USAGE"])
    {
LABEL_7:

      goto LABEL_8;
    }

    id v18 = (void *)objc_claimAutoreleasedReturnValue([v13 messageName]);
    if ([v18 isEqualToString:@"MA-AUTO-SET(REPLY):LOCK_ATOMIC"])
    {

      goto LABEL_7;
    }

    uint64_t v51 = v12;
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v13 messageName]);
    uint64_t v53 = [v52 isEqualToString:@"MA-AUTO-SET(REPLY):CONTINUE_ATOMIC_LOCK"];

    uint64_t v12 = v51;
    if ((v53 & 1) != 0) {
      goto LABEL_9;
    }
    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue([v54 oslog]);

    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
      if (v13) {
        uint64_t v30 = (__CFString *)objc_claimAutoreleasedReturnValue([v13 summary]);
      }
      else {
        uint64_t v30 = @"N";
      }
      OSStatus v48 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetClientRequest responseErrorSummary:]( &OBJC_CLASS___MADAutoAssetClientRequest,  "responseErrorSummary:",  v11));
      uint64_t v49 = (__CFString *)objc_claimAutoreleasedReturnValue([v51 summary]);
      *(_DWORD *)buf = 138544130;
      *(void *)&buf[4] = v29;
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v30;
      *(_WORD *)&buf[22] = 2114;
      *(void *)&buf[24] = v48;
      uint64_t v67 = 2114;
      uint64_t v68 = v49;
      uint64_t v50 = "[%{public}@] {_updateSandboxExtensionForResponse} MADAutoAssetAuthorizationPolicy not applicable for this me"
            "ssage | responseMessage:%{public}@, responseError:%{public}@, clientRequest:%{public}@";
LABEL_28:
      _os_log_impl(&dword_0, v20, OS_LOG_TYPE_DEFAULT, v50, buf, 0x2Au);
      if (v13) {

      }
      goto LABEL_31;
    }

    goto LABEL_31;
  }
    }
  }

  else
  {
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) logger]);
    id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v17 oslog]);

    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( &dword_0,  v18,  OS_LOG_TYPE_DEFAULT,  "{persistSetJobDescriptor}: no existing atomic-instance representing assets in this set descriptor",  buf,  2u);
    }

    uint64_t v19 = *(void **)(a1 + 32);
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) assetSetIdentifier]);
    [v19 _updateCurrentSetStatus:@"PERSISTED_SET_DESCRIPTOR" forSetIdentifier:v20 withSetStatus:*(void *)(a1 + 48)];

    uint64_t v21 = *(void **)(a1 + 32);
    uint64_t v22 = *(void **)(a1 + 40);
    uint64_t v23 = [v22 isDiscoveredFullyDownloaded];
    id v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) discoveredAtomicInstance]);
    BOOL v25 = *(void *)(a1 + 48);
    id v26 = [*(id *)(a1 + 40) isDiscoveredFullyDownloaded];
    BYTE2(v55) = [*(id *)(a1 + 40) isDiscoveredFullyDownloaded];
    BYTE1(v55) = v26;
    LOBYTE(v55) = 0;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = objc_msgSend( v21,  "trackSetDescriptor:fromLocation:forL atestDownloaded:forSpecificAtomicIns tance:withCurrentSetStatus:changedWh ileTerminated:changedNeverBeenLocked :notifyingIfJustDownloaded:latestToV end:historyOperation:firstClientName:",  v22,  @"persistSetJobDescriptor",  v23,  v24,  v25,  0,  v55,  0,  *(void *)(a1 + 56));

    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) logger]);
    uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue([v27 oslog]);

    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) summary]);
      *(_DWORD *)buf = 138543362;
      uint64_t v64 = v29;
      _os_log_impl( &dword_0,  v28,  OS_LOG_TYPE_DEFAULT,  "{persistSetJobDescriptor}\n [SET-DESCRIPTOR][VEND] update to set-descriptor provided by set-job | setJobDescriptor:%{public}@",  buf,  0xCu);
    }

    if ([*(id *)(a1 + 40) isDiscoveredFullyDownloaded])
    {
      uint64_t v60 = 0u;
      uint64_t v61 = 0u;
      uint64_t v58 = 0u;
      uint64_t v59 = 0u;
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) latestDowloadedAtomicInstanceEntries]);
      uint64_t v30 = [v9 countByEnumeratingWithState:&v58 objects:v62 count:16];
      if (v30)
      {
        uint64_t v31 = v30;
        uint64_t v56 = a1;
        id obj = v9;
        id v32 = *(void *)v59;
        do
        {
          for (uint64_t i = 0LL; i != v31; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v59 != v32) {
              objc_enumerationMutation(obj);
            }
            uint64_t v34 = *(void **)(*((void *)&v58 + 1) + 8LL * (void)i);
            __int128 v35 = objc_autoreleasePoolPush();
            __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v34 assetID]);

            if (v36)
            {
              __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v34 fullAssetSelector]);
              OSStatus v38 = (void *)objc_claimAutoreleasedReturnValue([v37 assetType]);
              uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v34 assetID]);
              AutoLocalUrlFromTypeAndIdWithPurpose = getAutoLocalUrlFromTypeAndIdWithPurpose( v38,  v39,  2LL,  @"auto");
              id v41 = (void *)objc_claimAutoreleasedReturnValue(AutoLocalUrlFromTypeAndIdWithPurpose);
              uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 path]);

              if (v42)
              {
                uint64_t v43 = -[NSURL initFileURLWithPath:](objc_alloc(&OBJC_CLASS___NSURL), "initFileURLWithPath:", v42);
                updateClientUsageDate(v43);
              }

              else
              {
                uint64_t v43 = (NSURL *)objc_claimAutoreleasedReturnValue([*(id *)(v56 + 32) autoControlManagerFSM]);
                uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(-[NSURL diag](v43, "diag"));
                uint64_t v45 = objc_alloc(&OBJC_CLASS___NSString);
                uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v34 summary]);
                SecKeyRef v47 = -[NSString initWithFormat:]( v45,  "initWithFormat:",  @"{persistSetJobDescriptor} unable to determine local repository path for nextDownloadedAtomicEntry:%@",  v46);
                [v44 trackAnomaly:@"AUTO-CONTROL" forReason:v47 withResult:6101 withError:0];
              }
            }

            objc_autoreleasePoolPop(v35);
          }

          uint64_t v31 = [obj countByEnumeratingWithState:&v58 objects:v62 count:16];
        }

        while (v31);
        int v2 = 0LL;
        uint64_t v9 = obj;
      }

      goto LABEL_31;
    }
  }
}

LABEL_32:
}

            uint64_t v101 = (void *)v38;
            v95 = 0LL;
            v96 = 0LL;
            uint64_t v94 = 0LL;
            goto LABEL_32;
          }

          _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager checkAndInitiateDownloadForAssetType:message:forClientName:usingConnection:requiri ngClientExtractor:]",  @"Failed to read extractor",  v54,  v55,  v56,  v57,  v85);
          sendClientResponse(v15, v13, 11LL);

LABEL_30:
          goto LABEL_24;
        }

        if (v38 && v39)
        {
          uint64_t v44 = (void *)v38;
          uint64_t v45 = (void *)v39;
          uint64_t v99 = v44;
          if ((uint64_t)[v44 longLongValue] <= 0)
          {
            _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager checkAndInitiateDownloadForAssetType:message:forClientName:usingConnection:requi ringClientExtractor:]",  @"Invalid range request: negative start %@ %@",  v46,  v47,  v48,  v49,  (uint64_t)v99);
            sendClientResponse(v15, v13, 23LL);

            goto LABEL_39;
          }

          uint64_t v50 = (uint64_t)[v45 longLongValue] <= 0;
          uint64_t v39 = (uint64_t)v45;
          OSStatus v38 = (uint64_t)v99;
          if (!v50) {
            goto LABEL_12;
          }
          uint64_t v88 = (uint64_t)v99;
          uint64_t v81 = @"Invalid range request: zero length %@ %@";
        }

        else
        {
          uint64_t v88 = v38;
          uint64_t v81 = @"Invalid range request: incomplete %@ %@";
        }

        uint64_t v82 = (void *)v39;
        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[ControlManager checkAndInitiateDownloadForAssetType:message:forClientName:usingConnection:requiring ClientExtractor:]",  v81,  v40,  v41,  v42,  v43,  v88);
        sendClientResponse(v15, v13, 23LL);

LABEL_39:
        goto LABEL_27;
      }

      sendClientResponse(v15, v13, 74LL);
    }

    else
    {
      sendClientResponse(v15, v13, 20LL);
    }
  }

  else
  {
    sendClientResponse(v15, v13, 20LL);
  }

                -[NSMutableDictionary setSafeObject:forKey:](v44, "setSafeObject:forKey:", v49, v33);
              }

              else
              {
                uint64_t v49 = -[NSNumber initWithLong:]( [NSNumber alloc],  "initWithLong:",  [v31 activeLockCount]);
                if (v49) {
                  goto LABEL_31;
                }
                uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
                uint64_t v49 = (NSNumber *)objc_claimAutoreleasedReturnValue([v54 oslog]);

                if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v31 summary]);
                  *(_DWORD *)buf = 138543618;
                  v121 = v100;
                  v122 = 2114;
                  v123 = v55;
                  _os_log_error_impl( &dword_0,  (os_log_t)v49,  OS_LOG_TYPE_ERROR,  "{currentSetLockUsageEliminatingOtherThanSetAtomicInstances} | unable to allocate usage-map countForR easonByAtomicInstance - not representing entry:%{public}@ | nextLockTracker:%{public}@",  buf,  0x16u);
                }
              }

              p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
              __int128 v15 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
              uint64_t v23 = v105;
            }

            else
            {
              -[NSMutableArray addObject:](log, "addObject:", v31);
              -[NSMutableArray addObject:](v102, "addObject:", v23);
            }

            uint64_t v28 = v110;
            goto LABEL_34;
          }

          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v32 logger]);
          id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue([v53 oslog]);

          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            v121 = v100;
            v122 = 2114;
            v123 = v27;
            _os_log_error_impl( &dword_0,  v33,  OS_LOG_TYPE_ERROR,  "{currentSetLockUsageEliminatingOtherThanSetAtomicInstances} | unable to load lock-tracker | entry:%{public }@ | lockReasonKey:%{public}@",  buf,  0x16u);
          }

void sub_C8574( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

void sub_CA6F0(_Unwind_Exception *a1)
{
}

__CFString *ensureNSStringFromData(void *a1)
{
  id v1 = a1;
  int v2 = v1;
  if (v1) {
    id v3 = (__CFString *)v1;
  }
  else {
    id v3 = @"Unknown";
  }

  return v3;
}

void addAdditionalParams(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  unsigned int v5 = v4;
  if (v3 && v4)
  {
    __int128 v86 = 0u;
    __int128 v87 = 0u;
    __int128 v84 = 0u;
    __int128 v85 = 0u;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 allKeys]);
    id v7 = [v6 countByEnumeratingWithState:&v84 objects:v90 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v67 = *(void *)v85;
      p_ivars = &MobileAssetKeyManager__metaData.ivars;
      uint64_t v64 = v5;
      uint64_t v65 = v3;
      id v63 = v6;
      do
      {
        uint64_t v10 = 0LL;
        id v66 = v8;
        do
        {
          if (*(void *)v85 != v67)
          {
            uint64_t v11 = v10;
            objc_enumerationMutation(v6);
            uint64_t v10 = v11;
          }

          uint64_t v69 = v10;
          uint64_t v12 = *(void *)(*((void *)&v84 + 1) + 8 * v10);
          context = objc_autoreleasePoolPush();
          BOOL v17 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKey:v12]);
          if (v17)
          {
            uint64_t v18 = objc_opt_class(&OBJC_CLASS___NSString);
            if ((objc_opt_isKindOfClass(v17, v18) & 1) != 0
              || (uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v17, v19) & 1) != 0))
            {
              [v3 setObject:v17 forKey:v12];
            }

            else
            {
              uint64_t v20 = objc_opt_class(&OBJC_CLASS___NSArray);
              if ((objc_opt_isKindOfClass(v17, v20) & 1) != 0)
              {
                uint64_t v21 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                __int128 v80 = 0u;
                __int128 v81 = 0u;
                __int128 v82 = 0u;
                __int128 v83 = 0u;
                id v22 = v17;
                id v75 = [v22 countByEnumeratingWithState:&v80 objects:v89 count:16];
                if (v75)
                {
                  uint64_t v23 = *(void *)v81;
                  uint64_t v73 = v12;
                  uint64_t v74 = v17;
                  id v71 = v22;
                  OSStatus v72 = v21;
                  uint64_t v70 = *(void *)v81;
                  do
                  {
                    id v24 = 0LL;
                    do
                    {
                      if (*(void *)v81 != v23) {
                        objc_enumerationMutation(v22);
                      }
                      BOOL v25 = *(void **)(*((void *)&v80 + 1) + 8LL * (void)v24);
                      id v26 = objc_autoreleasePoolPush();
                      uint64_t v27 = objc_opt_class(&OBJC_CLASS___NSString);
                      if ((objc_opt_isKindOfClass(v25, v27) & 1) != 0
                        || (uint64_t v28 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v25, v28) & 1) != 0))
                      {
                        -[NSMutableArray addObject:](v21, "addObject:", v25);
                      }

                      else
                      {
                        uint64_t v29 = objc_opt_class(p_ivars[140]);
                        if ((objc_opt_isKindOfClass(v25, v29) & 1) != 0)
                        {
                          id v34 = v25;
                          __int128 v76 = 0u;
                          __int128 v77 = 0u;
                          __int128 v78 = 0u;
                          __int128 v79 = 0u;
                          id v35 = v34;
                          id v36 = [v35 countByEnumeratingWithState:&v76 objects:v88 count:16];
                          if (v36)
                          {
                            id v37 = v36;
                            uint64_t v38 = *(void *)v77;
                            while (2)
                            {
                              for (uint64_t i = 0LL; i != v37; uint64_t i = (char *)i + 1)
                              {
                                if (*(void *)v77 != v38) {
                                  objc_enumerationMutation(v35);
                                }
                                uint64_t v40 = *(void *)(*((void *)&v76 + 1) + 8LL * (void)i);
                                id v41 = objc_autoreleasePoolPush();
                                uint64_t v42 = objc_opt_class(&OBJC_CLASS___NSString);
                                if ((objc_opt_isKindOfClass(v40, v42) & 1) == 0)
                                {
                                  _MobileAssetLog( 0LL,  6,  (uint64_t)"addAdditionalParams",  @"Pallas request creation, array element dictionary entry key is not an NSString | skipped",  v43,  v44,  v45,  v46,  v62);
LABEL_41:
                                  objc_autoreleasePoolPop(v41);

                                  p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                                  uint64_t v12 = v73;
                                  BOOL v17 = v74;
                                  uint64_t v21 = v72;
                                  goto LABEL_42;
                                }

                                SecKeyRef v47 = (void *)objc_claimAutoreleasedReturnValue([v35 objectForKey:v40]);
                                uint64_t v48 = objc_opt_class(&OBJC_CLASS___NSString);
                                if ((objc_opt_isKindOfClass(v47, v48) & 1) == 0)
                                {
                                  uint64_t v49 = objc_opt_class(&OBJC_CLASS___NSNumber);
                                  if ((objc_opt_isKindOfClass(v47, v49) & 1) == 0)
                                  {
                                    _MobileAssetLog( 0LL,  3,  (uint64_t)"addAdditionalParams",  @"Pallas request creation, array element dictionary entry key:%@ holds value that is not an NSString or NSNumber | skipped",  v50,  v51,  v52,  v53,  v40);

                                    goto LABEL_41;
                                  }
                                }

                                objc_autoreleasePoolPop(v41);
                              }

                              id v37 = [v35 countByEnumeratingWithState:&v76 objects:v88 count:16];
                              if (v37) {
                                continue;
                              }
                              break;
                            }
                          }

                          uint64_t v21 = v72;
                          -[NSMutableArray addObject:](v72, "addObject:", v35);
                          p_ivars = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
                          uint64_t v12 = v73;
                          BOOL v17 = v74;
LABEL_42:

                          uint64_t v23 = v70;
                          id v22 = v71;
                        }

                        else
                        {
                          _MobileAssetLog( 0LL,  6,  (uint64_t)"addAdditionalParams",  @"Pallas request creation, unknown value '%@' skipped for key: %@",  v30,  v31,  v32,  v33,  (uint64_t)v25);
                        }
                      }

                      objc_autoreleasePoolPop(v26);
                      id v24 = (char *)v24 + 1;
                    }

                    while (v24 != v75);
                    id v54 = [v22 countByEnumeratingWithState:&v80 objects:v89 count:16];
                    id v75 = v54;
                  }

                  while (v54);
                }

                uint64_t v55 = v21;
                id v3 = v65;
                [v65 setObject:v55 forKey:v12];

                uint64_t v6 = v63;
                unsigned int v5 = v64;
                id v8 = v66;
              }

              else
              {
                uint64_t v56 = objc_opt_class(&OBJC_CLASS___NSNull);
                if ((objc_opt_isKindOfClass(v17, v56) & 1) != 0) {
                  [v3 removeObjectForKey:v12];
                }
                else {
                  _MobileAssetLog( 0LL,  6,  (uint64_t)"addAdditionalParams",  @"Pallas request creation, invalid value for key: %@",  v57,  v58,  v59,  v60,  v12);
                }
              }
            }
          }

          else
          {
            _MobileAssetLog( 0LL,  6,  (uint64_t)"addAdditionalParams",  @"Pallas request creation, nil value skipping key: %@",  v13,  v14,  v15,  v16,  v12);
          }

          objc_autoreleasePoolPop(context);
          uint64_t v10 = v69 + 1;
        }

        while ((id)(v69 + 1) != v8);
        id v61 = [v6 countByEnumeratingWithState:&v84 objects:v90 count:16];
        id v8 = v61;
      }

      while (v61);
    }
  }
}

__CFString *getCurrentOSType()
{
  id v0 = (__CFString *)MGCopyAnswer(@"ReleaseType", 0LL);
  if (!v0) {
    id v0 = @"user";
  }
  return v0;
}

void sub_CE45C(_Unwind_Exception *a1)
{
}

LABEL_78:
      id v24 = 0LL;
      v186 = 0LL;
      v208 = 0LL;
      goto LABEL_37;
    }

    uint64_t v109 = objc_opt_class(&OBJC_CLASS___NSArray);
    if ((objc_opt_isKindOfClass(v202, v109) & 1) == 0)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName :then:]_block_invoke",  @"Pallas Cert data was not an array, skipping",  v110,  v111,  v112,  v113,  v181);
      if ((v59 & 1) == 0)
      {

        id v24 = 0LL;
        v186 = 0LL;
        v208 = 0LL;
        v209 = 0LL;
        v189 = 0LL;
        v190 = 0LL;
        v191 = 0LL;
        v193 = 0LL;
        v197 = 0LL;
        v198 = 0LL;
        v195 = 0LL;
        uint64_t v32 = 0LL;
        uint64_t v33 = -7LL;
        v135 = @"V2 certs were not an array";
        goto LABEL_92;
      }

      goto LABEL_78;
    }

    uint64_t v114 = objc_autoreleasePoolPush();
    v216[0] = _NSConcreteStackBlock;
    v216[1] = 3221225472LL;
    v216[2] = __110__DownloadManager_pallasRequestV2_normalizedType_withPurpose_options_using_with_autoAssetJob_clientName_then___block_invoke_2;
    v216[3] = &unk_34EDF8;
    v218 = v220;
    uint64_t v115 = v196;
    v217 = v115;
    [v202 enumerateObjectsUsingBlock:v216];
    uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v213 + 40) pallasVerifier]);
    uint64_t v117 = [v116 verifyCerts:v115 error:0];

    if ((v117 & 1) == 0)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName :then:]_block_invoke",  @"Pallas: Failure attempting to verify the certificates aborting",  v118,  v119,  v120,  v121,  v181);
      if ((v59 & 1) == 0)
      {

        v204 = -14LL;
        v212 = @"V2 could not verify the certificates";
      }
    }

    objc_autoreleasePoolPop(v114);
    if (!v117) {
      goto LABEL_78;
    }
  }

  v122 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v213 + 40) pallasVerifier]);
  v123 = [v122 verifyResponse:v201 signature:v199 error:0];

  if ((v123 & 1) == 0)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Pallas: Unable to verify the payload, signature check failed aborting",  v124,  v125,  v126,  v127,  v181);
    if ((v59 & 1) == 0)
    {

      id v24 = 0LL;
      v186 = 0LL;
      v208 = 0LL;
      v209 = 0LL;
      v189 = 0LL;
      v190 = 0LL;
      v191 = 0LL;
      v193 = 0LL;
      v197 = 0LL;
      v198 = 0LL;
      v195 = 0LL;
      uint64_t v32 = 0LL;
      uint64_t v33 = -8LL;
      v135 = @"V2 signature failed verification";
      goto LABEL_92;
    }

    goto LABEL_78;
  }

  context = objc_autoreleasePoolPush();
  v215 = 0LL;
  v198 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v201,  1LL,  &v215));
  v208 = v215;
  if (v208)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Error in getting JSON from the data of Pallas response",  v128,  v129,  v130,  v131,  v181);
    v132 = 0LL;
    v133 = 0;
    if ((v59 & 1) != 0)
    {
LABEL_64:
      v186 = 0LL;
      v189 = 0LL;
      v190 = 0LL;
      v191 = 0LL;
      v193 = 0LL;
      v195 = 0LL;
      v197 = 0LL;
      uint64_t v32 = 0LL;
LABEL_65:
      v209 = 0LL;
      id v24 = 0LL;
      v134 = 0LL;
      goto LABEL_97;
    }

    v155 = v212;
    v156 = @"V2 could not get response JSON";
    v157 = -9LL;
    goto LABEL_94;
  }

  v197 = (void *)objc_claimAutoreleasedReturnValue([v198 objectForKey:@"Nonce"]);
  if (!v197)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Pallas response contains nil nonce",  v136,  v137,  v138,  v139,  v181);
    v132 = 0LL;
    v133 = 0;
    if ((v59 & 1) != 0) {
      goto LABEL_64;
    }
    v155 = v212;
    v156 = @"V2 response contains nil nonce";
    v157 = -10LL;
LABEL_94:
    v204 = v157;
    v158 = 0LL;
    v189 = 0LL;
    v190 = 0LL;
    v191 = 0LL;
    v193 = 0LL;
    v212 = (__CFString *)v156;
    v195 = 0LL;
    v197 = 0LL;
    uint64_t v32 = 0LL;
LABEL_95:
    v209 = 0LL;
    v134 = 0LL;
LABEL_96:

    id v24 = v132;
    v186 = (void *)v158;
    goto LABEL_97;
  }

  v140 = objc_claimAutoreleasedReturnValue([v198 objectForKey:@"PallasNonce"]);
  if (v140) {
    uint64_t v32 = (const __CFString *)v140;
  }
  else {
    uint64_t v32 = @"Unknown";
  }
  v195 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", v197);
  if ((-[NSUUID isEqual:](v195, "isEqual:", *(void *)(v213 + 32)) & 1) == 0)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Pallas response contains nonce mismatch, original %@, skipping: %@",  v141,  v142,  v143,  v144,  *(void *)(v213 + 32));
    v132 = 0LL;
    v133 = 0;
    if ((v59 & 1) != 0)
    {
LABEL_105:
      v186 = 0LL;
      v189 = 0LL;
      v190 = 0LL;
      v191 = 0LL;
      v193 = 0LL;
      goto LABEL_65;
    }

    v204 = -11LL;
    v155 = v212;
    v172 = @"V2 response contains nonce mismatch";
LABEL_108:
    v158 = 0LL;
    v189 = 0LL;
    v190 = 0LL;
    v191 = 0LL;
    v193 = 0LL;
LABEL_109:
    v212 = (__CFString *)v172;
    goto LABEL_95;
  }

  [*(id *)(v213 + 40) _logResponseBody:v198 nonce:v197 extraServerOptions:*(void *)(v213 + 48)];
  if (v204 != 201)
  {
    v158 = objc_claimAutoreleasedReturnValue([v198 objectForKey:@"AssetSetId"]);
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"asset set id for %@ from server is: %@",  v160,  v161,  v162,  v163,  *(void *)(v213 + 32));
    v222 = @"isLiveServer";
    v223 = &__kCFBooleanTrue;
    v189 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v223,  &v222,  1LL));
    v190 = (void *)objc_claimAutoreleasedReturnValue([v198 objectForKey:@"PostingDate"]);
    v164 = *(void *)(v213 + 64);
    v192 = *(void *)(v213 + 72);
    v194 = *(void **)(v213 + 40);
    v210 = *(void *)(v213 + 80);
    v187 = objc_claimAutoreleasedReturnValue([v198 objectForKey:@"Assets"]);
    v165 = (void *)objc_claimAutoreleasedReturnValue([v198 objectForKey:@"Transformations"]);
    v166 = *(void **)(v213 + 72);
    v167 = *(void **)(v213 + 88);
    v168 = repositoryPath(v166);
    v169 = (void *)objc_claimAutoreleasedReturnValue(v168);
    v170 = assembleXmlPathWithPurpose((uint64_t)v166, v167, v169, *(void **)(v213 + 96));
    v171 = (void *)objc_claimAutoreleasedReturnValue(v170);
    v214 = 0LL;
    LOBYTE(v183) = v164 == 0;
    v134 = (char *)[v194 massageXmlAndPersist:v192 catalogInfo:v189 descriptor:v210 assets:v187 transformations:v165 to:v171 postedDate:v190 receiptResults:&v214 ass etSetId:v158 pallasUrl:*(void *)(v213 + 56) considerCaching:v183];
    v209 = v214;

    v132 = 0LL;
    v191 = 0LL;
    v193 = 0LL;
    v133 = 1;
    v155 = (void *)v187;
    goto LABEL_96;
  }

  v191 = (void *)objc_claimAutoreleasedReturnValue([v198 objectForKey:@"LegacyXmlUrl"]);
  if (!v191)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Received %d and nil url returned by Pallas server using: %@",  v145,  v146,  v147,  v148,  201LL);
    v132 = 0LL;
    v133 = 0;
    if ((v59 & 1) != 0)
    {
      v204 = 201LL;
      goto LABEL_105;
    }

    v204 = -12LL;
    v155 = v212;
    v172 = @"V2 Received requested legacy and nil url returned";
    goto LABEL_108;
  }

  v193 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:"));
  if (!v193) {
    goto LABEL_116;
  }
  v153 = objc_opt_class(&OBJC_CLASS___NSURL);
  if ((objc_opt_isKindOfClass(v193, v153) & 1) == 0) {
    goto LABEL_116;
  }
  v154 = (void *)objc_claimAutoreleasedReturnValue([v193 scheme]);
  if ([v154 isEqualToString:@"https"])
  {

    goto LABEL_114;
  }

  v173 = (void *)objc_claimAutoreleasedReturnValue([v193 scheme]);
  v174 = [v173 isEqualToString:@"http"];

  if (!v174)
  {
LABEL_116:
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Received %d from pallas but url is invalid: %@ using: %@",  v149,  v150,  v151,  v152,  201LL);
    v132 = 0LL;
    v133 = 0;
    if ((v59 & 1) != 0)
    {
      v204 = 201LL;
      v186 = 0LL;
      v189 = 0LL;
      v190 = 0LL;
      goto LABEL_65;
    }

    v204 = -13LL;
    v155 = v212;
    v172 = @"V2 invalid url from pallas";
    v158 = 0LL;
    v189 = 0LL;
    v190 = 0LL;
    goto LABEL_109;
  }

LABEL_114:
  v182 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v213 + 56) scheme]);
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:the n:]_block_invoke",  @"Over riding url with url from pallas: %@, %@",  v175,  v176,  v177,  v178,  (uint64_t)v193);

  v179 = v193;
  v132 = v179;
  v158 = 0LL;
  v133 = 0;
  if ((v59 & 1) == 0)
  {
    v204 = -15LL;
    v155 = v212;
    v189 = 0LL;
    v190 = 0LL;
    v193 = v179;
    v212 = @"V2 Server instructed us to fallback";
    v209 = 0LL;
    v134 = 0LL;
    goto LABEL_96;
  }

  v204 = 201LL;
  v189 = 0LL;
  v190 = 0LL;
  id v24 = v179;
  v193 = v179;
  v209 = 0LL;
  v186 = 0LL;
  v134 = 0LL;
LABEL_97:
  objc_autoreleasePoolPop(context);
  if (v134 == (_BYTE *)&dword_1C + 3) {
    v159 = v133;
  }
  else {
    v159 = 0;
  }
  if (v159 != 1) {
    goto LABEL_38;
  }
  __int128 v82 = v213;
  *(void *)(*(void *)(*(void *)(v213 + 160) + 8LL) + 24LL) = 0LL;
  uint64_t v33 = v204;
LABEL_40:
  __int128 v83 = v33;
  v205 = (__CFString *)v32;
  _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:the n:]_block_invoke",  @"The pallas response was { RequestNonce: %@ ResponseNonce: %@ code: %ld",  v20,  v21,  v22,  v23,  *(void *)(v82 + 32));
  __int128 v84 = v213;
  __int128 v85 = v24;
  if (*(void *)(*(void *)(*(void *)(v213 + 160) + 8LL) + 24LL) == 2LL && v24 == 0LL)
  {
    StandardUrl = getStandardUrl(*(void **)(v213 + 72), *(void **)(v213 + 88));
    uint64_t v88 = objc_claimAutoreleasedReturnValue(StandardUrl);
    __int128 v84 = v213;
    __int128 v85 = (void *)v88;
  }

  uint64_t v89 = v85;
  (*(void (**)(void))(*(void *)(v84 + 152) + 16LL))();
  updated = isSoftwareUpdateType(*(void **)(v213 + 72));
  if ((_DWORD)updated)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Check splunk for %@ status code: %ld",  v91,  v92,  v93,  v94,  *(void *)(v213 + 72));
    v95 = *(void *)(v213 + 72);
    v97 = *(void *)(v213 + 104);
    v96 = *(void *)(v213 + 112);
    uint64_t v99 = *(void *)(v213 + 32);
    uint64_t v98 = *(void **)(v213 + 40);
    uint64_t v100 = *(void *)(v213 + 56);
    uint64_t v102 = *(void *)(v213 + 120);
    uint64_t v101 = *(void *)(v213 + 128);
    LOBYTE(v184) = [*(id *)(v213 + 136) discretionary];
    [v98 checkSplunkStatus:v95 failureReason:v212 productVersion:v97 sessionId:v96 nonce:v99 url:v100 statusCode:v83 assetAudience:v102 version:@"2" receiptResults :v209 baseUrl:v101 discretionary:v184 deviceCheck:*(void *)(v213 + 144)];
  }

  else
  {
    _MobileAssetLog( (uint64_t)updated,  6,  (uint64_t)"-[DownloadManager pallasRequestV2:normalizedType:withPurpose:options:using:with:autoAssetJob:clientName:t hen:]_block_invoke",  @"Skipping splunk for %@",  v91,  v92,  v93,  v94,  *(void *)(v213 + 72));
  }

  _Block_object_dispose(v220, 8);
}

void sub_CF65C(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__11(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

void sub_D3E74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

void sub_D4D60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_E261C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_E4428( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

uint64_t __Block_byref_object_copy__12(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

void sub_E4A0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

LABEL_47:
  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "logger", (void)v50));
  uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue([v45 oslog]);

  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    SecKeyRef v47 = @"N";
    if ((v21 & 1) != 0) {
      uint64_t v48 = @"N";
    }
    else {
      uint64_t v48 = (__CFString *)objc_claimAutoreleasedReturnValue([v18 summary]);
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL)) {
      SecKeyRef v47 = *(const __CFString **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    }
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) summary]);
    *(_DWORD *)buf = 138543874;
    uint64_t v55 = v48;
    uint64_t v56 = 2114;
    uint64_t v57 = v47;
    uint64_t v58 = 2114;
    uint64_t v59 = v49;
    _os_log_impl( &dword_0,  v46,  OS_LOG_TYPE_DEFAULT,  "{assetBeingGarbageCollected} | downloadedDescriptor:%{public}@ | blockGarbageCollectionReason:%{public}@ | descrip torToBeRemoved:%{public}@",  buf,  0x20u);
    if ((v21 & 1) == 0) {
  }
    }
}

LABEL_48:
          uint64_t v9 = v103;
          uint64_t v10 = v96;
          goto LABEL_49;
        }

        if (!-[MADAutoAssetControlManager atomicInstanceHasDownloadedSetDescriptor:verboseLogging:]( self,  "atomicInstanceHasDownloadedSetDescriptor:verboseLogging:",  v20,  0LL))
        {
          -[MADAutoAssetControlManager atomicInstanceHasDownloadedSetDescriptor:verboseLogging:]( self,  "atomicInstanceHasDownloadedSetDescriptor:verboseLogging:",  v20,  1LL);
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
          uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue([v42 oslog]);

          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
            *(_DWORD *)buf = 138543618;
            uint64_t v120 = v52;
            v121 = 2114;
            v122 = v12;
            _os_log_error_impl( &dword_0,  v43,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [REMOVAL] {loadPersistedCrossCheckTrimAtomicInstances} atomic-instance without backing set-descriptor | en tryID:%{public}@",  buf,  0x16u);
          }

          -[NSMutableArray addObject:](v100, "addObject:", v12);
          id v7 = v95;
          goto LABEL_48;
        }

        uint64_t v33 = -[NSMutableDictionary safeObjectForKey:ofClass:]( v7,  "safeObjectForKey:ofClass:",  v22,  objc_opt_class(&OBJC_CLASS___NSMutableArray));
        uint64_t v29 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(v33);
        if (!v29)
        {
          uint64_t v29 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          if (!v29) {
            goto LABEL_47;
          }
        }

        -[NSMutableArray addObject:](v29, "addObject:", v20);
        -[NSMutableDictionary setSafeObject:forKey:](v7, "setSafeObject:forKey:", v29, v22);
        if ((unint64_t)-[NSMutableArray count](v29, "count") < 7
          || +[MADAutoAssetControlManager preferenceAutoAssetNoPersistedOverflowLimit]( &OBJC_CLASS___MADAutoAssetControlManager,  "preferenceAutoAssetNoPersistedOverflowLimit"))
        {
          goto LABEL_47;
        }

        uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceOverflowRemove:]( self,  "atomicInstanceOverflowRemove:",  v29));
        if (v93)
        {
          uint64_t v92 = objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager atomicInstanceNewEntryIDForSetAtomicInstance:]( self,  "atomicInstanceNewEntryIDForSetAtomicInstance:",  v93));
          if (v92)
          {
            id v34 = (void *)objc_claimAutoreleasedReturnValue([v93 atomicInstanceUUID]);
            uint64_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedByAtomicInstanceUUID:]( self,  "locateSetDescriptorDownloadedByAtomicInstanceUUID:",  v34));

            id v35 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue([v35 oslog]);

            id v37 = v91;
            uint64_t v38 = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
            if (v91)
            {
              if (v38)
              {
                uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
                log = v36;
                uint64_t v60 = (__CFString *)objc_claimAutoreleasedReturnValue([v93 summary]);
                id v61 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s summary](v91, "summary"));
                *(_DWORD *)buf = 138543874;
                uint64_t v120 = v59;
                v121 = 2114;
                v122 = v60;
                v123 = 2114;
                v124 = v61;
                _os_log_error_impl( &dword_0,  log,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [REMOVAL] {loadPersistedCrossCheckTrimAtomicInstances} [WARNING] over threshold for atomic-instances b y set-identifier (trimming) | setAtomicInstance:%{public}@ | setDescriptor:%{public}@",  buf,  0x20u);

                id v36 = log;
                id v37 = v91;
              }

              uint64_t v39 = (void *)v92;
              -[NSMutableArray addObject:](v100, "addObject:", v92);
              uint64_t v40 = v37;
              id v41 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s latestDownloadedAtomicInstance](v37, "latestDownloadedAtomicInstance"));
              -[NSMutableArray addObject:](v94, "addObject:", v41);

              id v37 = v40;
LABEL_62:

LABEL_63:
              id v7 = v95;

              goto LABEL_47;
            }

            if (v38)
            {
              uint64_t v62 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              loga = v36;
              id v63 = (__CFString *)objc_claimAutoreleasedReturnValue([v93 summary]);
              *(_DWORD *)buf = 138543618;
              uint64_t v120 = v62;
              v121 = 2114;
              v122 = v63;
              _os_log_error_impl( &dword_0,  loga,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [REMOVAL] {loadPersistedCrossCheckTrimAtomicInstances} atomic-instance without backing set-descriptor | removedOverflowAtomicInstance:%{public}@",  buf,  0x16u);

              id v36 = loga;
              id v37 = 0LL;
            }

            -[NSMutableArray addObject:](v100, "addObject:", v12);
          }

          else
          {
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
            id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue([v53 oslog]);

            id v37 = v54;
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            {
              uint64_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
              uint64_t v56 = (__CFString *)objc_claimAutoreleasedReturnValue([v93 summary]);
              *(_DWORD *)buf = 138543618;
              uint64_t v120 = v55;
              v121 = 2114;
              v122 = v56;
              _os_log_error_impl( &dword_0,  v54,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [CONSIDER-REMOVAL] {loadPersistedCrossCheckTrimAtomicInstances} unable to determine persisted-set-atomic -instance file | setAtomicInstance:%{public}@",  buf,  0x16u);

              id v37 = v54;
            }
          }

          uint64_t v39 = (void *)v92;
          goto LABEL_62;
        }

        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v50 oslog]);

        if (os_log_type_enabled((os_log_t)v39, OS_LOG_TYPE_ERROR))
        {
          id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
          uint64_t v51 = (__CFString *)objc_claimAutoreleasedReturnValue([v20 summary]);
          *(_DWORD *)buf = 138543618;
          uint64_t v120 = v37;
          v121 = 2114;
          v122 = v51;
          _os_log_error_impl( &dword_0,  (os_log_t)v39,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [CONSIDER-REMOVAL] {loadPersistedCrossCheckTrimAtomicInstances} over threshold for atomic-instances by set-i dentifier (unable to reduce) | setAtomicInstance:%{public}@",  buf,  0x16u);

          goto LABEL_62;
        }

        goto LABEL_63;
      }

      BOOL v17 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v17 oslog]);

      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        uint64_t v46 = objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](self, "_updateLatestSummary"));
        SecKeyRef v47 = (void *)v46;
        *(_DWORD *)buf = 138543618;
        uint64_t v48 = @"N";
        if (v12) {
          uint64_t v48 = v12;
        }
        uint64_t v120 = (os_log_s *)v46;
        v121 = 2114;
        v122 = v48;
        _os_log_error_impl( &dword_0,  v18,  OS_LOG_TYPE_ERROR,  "[%{public}@]\n [CONSIDER-REMOVAL] {loadPersistedCrossCheckTrimAtomicInstances} unable to determine previous status | entryID:%{public}@",  buf,  0x16u);
      }

      if (v12) {
        -[NSMutableArray addObject:](v100, "addObject:", v12);
      }
LABEL_49:

      objc_autoreleasePoolPop(v13);
      uint64_t v11 = (char *)v11 + 1;
    }

    while (v9 != v11);
    uint64_t v64 = [obj countByEnumeratingWithState:&v113 objects:v125 count:16];
    uint64_t v9 = v64;
  }

  while (v64);
LABEL_65:
  SecKeyRef v104 = self;

  uint64_t v111 = 0u;
  uint64_t v112 = 0u;
  uint64_t v109 = 0u;
  uint64_t v110 = 0u;
  obja = v100;
  uint64_t v65 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v109,  v118,  16LL);
  if (v65)
  {
    id v66 = v65;
    uint64_t v67 = *(void *)v110;
    do
    {
      for (uint64_t i = 0LL; i != v66; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v110 != v67) {
          objc_enumerationMutation(obja);
        }
        uint64_t v69 = *(void *)(*((void *)&v109 + 1) + 8LL * (void)i);
        uint64_t v70 = objc_autoreleasePoolPush();
        id v71 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager persistedKnownSetAtomicInstances]( v104,  "persistedKnownSetAtomicInstances"));
        OSStatus v72 = (void *)objc_claimAutoreleasedReturnValue( [v71 persistedEntry:v69 fromLocation:@"loadPersistedCrossCheckTrimAtomicInstances"]);

        uint64_t v73 = [v72 secureCodedObjectForKey:@"setAtomicInstance" ofClass:objc_opt_class(MADAutoSetAtomicInstance)];
        uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(v73);
        id v75 = (void *)objc_claimAutoreleasedReturnValue([v74 atomicInstanceUUID]);
        -[MADAutoAssetControlManager atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:]( v104,  "atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:",  @"loadPersistedCrossCheckTrimAtomicInstances",  v75,  @"dropping to avoid overflow",  334LL);

        objc_autoreleasePoolPop(v70);
      }

      id v66 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v109,  v118,  16LL);
    }

    while (v66);
  }

  uint64_t v107 = 0u;
  uint64_t v108 = 0u;
  uint64_t v105 = 0u;
  uint64_t v106 = 0u;
  v97 = v94;
  __int128 v76 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v97,  "countByEnumeratingWithState:objects:count:",  &v105,  v117,  16LL);
  if (v76)
  {
    __int128 v77 = v76;
    uint64_t v101 = *(void *)v106;
    do
    {
      for (j = 0LL; j != v77; j = (char *)j + 1)
      {
        if (*(void *)v106 != v101) {
          objc_enumerationMutation(v97);
        }
        __int128 v79 = *(void *)(*((void *)&v105 + 1) + 8LL * (void)j);
        __int128 v80 = objc_autoreleasePoolPush();
        __int128 v81 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( v104,  "downloadedSetDescriptorsByInstance"));
        __int128 v82 = [v81 safeObjectForKey:v79 ofClass:objc_opt_class(MADAutoSetDescriptor)];
        __int128 v83 = (void *)objc_claimAutoreleasedReturnValue(v82);

        __int128 v84 = (void *)objc_claimAutoreleasedReturnValue([v83 clientDomainName]);
        __int128 v85 = (void *)objc_claimAutoreleasedReturnValue([v83 assetSetIdentifier]);
        __int128 v86 = (void *)objc_claimAutoreleasedReturnValue( +[MANAutoAssetSetStatus shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:]( &OBJC_CLASS___MANAutoAssetSetStatus,  "shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:",  v84,  v85,  v79));

        -[MADAutoAssetControlManager removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:]( v104,  "removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:",  v83,  @"loadPersistedCrossCheckTrimAtomicInstances",  0LL,  0LL,  330LL,  374LL);
        __int128 v87 =  -[MADAutoAssetControlManager _shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:]( v104,  "_shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:",  @"loadPersistedCrossCheckTrimAtomicInstances",  v86,  v102,  @"atomic-instance shared lock directory (eliminated set-identifier)");

        objc_autoreleasePoolPop(v80);
      }

      __int128 v77 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v97,  "countByEnumeratingWithState:objects:count:",  &v105,  v117,  16LL);
    }

    while (v77);
  }

  uint64_t v6 = v90;
LABEL_80:
}

                        -[NSMutableArray addObject:](v122, "addObject:", v20);
                        id v8 = v123;
LABEL_48:
                        id v36 = v117;
                      }

                      else if (v119)
                      {
                        id v8 = v123;
                        if (!v118)
                        {
                          uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                          id v63 = (os_log_s *)objc_claimAutoreleasedReturnValue([v62 oslog]);

                          uint64_t v64 = v63;
                          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                          {
                            uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                            logb = v64;
                            id v71 = (void *)objc_claimAutoreleasedReturnValue([v26 summary]);
                            *(_DWORD *)buf = 138543874;
                            v133 = (uint64_t)v70;
                            v134 = 2114;
                            v135 = v123;
                            v136 = 2114;
                            v137 = (uint64_t)v71;
                            _os_log_error_impl( &dword_0,  logb,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} active-set-job set-descriptor yet no set-atomic-instance | dropp ing presumed-stale previously active set-job | setJobDescriptor:%{public}@",  buf,  0x20u);

                            uint64_t v64 = logb;
                          }

                          -[NSMutableArray addObject:](v122, "addObject:", v20);
                          goto LABEL_48;
                        }

                        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateActiveAutoJobForSetDescriptor:]( self,  "locateActiveAutoJobForSetDescriptor:",  v26));
                        if (v57)
                        {
                          ++v112;
                          -[MADAutoAssetControlManager updateAutoAssetSetStatus:forSetDescriptor:]( self,  "updateAutoAssetSetStatus:forSetDescriptor:",  @"resumeSetJobsWhenBeforeFirstUnlock",  v26);
                        }

                        else
                        {
                          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                          id v66 = (os_log_s *)objc_claimAutoreleasedReturnValue([v65 oslog]);

                          uint64_t v67 = v66;
                          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                          {
                            OSStatus v72 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                            uint64_t v109 = v67;
                            uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v26 summary]);
                            *(_DWORD *)buf = 138543874;
                            v133 = (uint64_t)v72;
                            v134 = 2114;
                            v135 = v123;
                            v136 = 2114;
                            v137 = (uint64_t)v73;
                            _os_log_error_impl( &dword_0,  v109,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} active-set-job set-descriptor yet no active active auto-asset-jo b | dropping presumed-stale previously active set-job | setJobDescriptor:%{public}@",  buf,  0x20u);

                            uint64_t v67 = v109;
                          }

                          -[NSMutableArray addObject:](v122, "addObject:", v20);
                          id v36 = v117;
                          uint64_t v57 = 0LL;
                        }
                      }

                      else
                      {
                        uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
                        uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue([v58 oslog]);

                        uint64_t v60 = v59;
                        id v61 = os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
                        id v8 = v123;
                        if (v61)
                        {
                          uint64_t v108 = (os_log_t)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager _updateLatestSummary]( self,  "_updateLatestSummary"));
                          loga = v60;
                          uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v26 summary]);
                          *(_DWORD *)buf = 138543874;
                          v133 = (uint64_t)v108;
                          v134 = 2114;
                          v135 = v123;
                          v136 = 2114;
                          v137 = (uint64_t)v69;
                          _os_log_error_impl( &dword_0,  loga,  OS_LOG_TYPE_ERROR,  "[%{public}@] {%{public}@} active-set-job set-descriptor yet no set-configuration | dropping presumed-stale previously active set-job | setJobDescriptor:%{public}@",  buf,  0x20u);

                          uint64_t v60 = loga;
                        }

                        -[NSMutableArray addObject:](v122, "addObject:", v20);
                      }

                      uint64_t v18 = v116;
                    }
}

LABEL_69:
  if (!v9)
  {
    uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v143 foundContent]);
    id v71 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
    OSStatus v72 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager clientRequestMessageName:](self, "clientRequestMessageName:", v71));

    if ((+[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v72,  @"MA-AUTO-SET:LOCK_ATOMIC") & 1) == 0)
    {
      uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v5 clientDomainName]);
      uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v5 assetSetIdentifier]);
      id v75 = -[MADAutoAssetControlManager newSetInfoLimitedToCheckInformation:forAssetSetIdentifier:fromSetInfoFound:]( self,  "newSetInfoLimitedToCheckInformation:forAssetSetIdentifier:fromSetInfoFound:",  v73,  v74,  v70);

      uint64_t v70 = v75;
    }

    __int128 v76 = (void *)objc_claimAutoreleasedReturnValue([v143 clientInstance]);
    __int128 v77 = +[MASAutoAssetSetInfoInstance newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoInstance,  "newShimmedToFramework:",  v76);
    -[NSMutableDictionary setSafeObject:forKey:](v145, "setSafeObject:forKey:", v77, @"setInstance");

    __int128 v78 = +[MASAutoAssetSetInfoFound newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoFound,  "newShimmedToFramework:",  v70);
    -[NSMutableDictionary setSafeObject:forKey:](v145, "setSafeObject:forKey:", v78, @"setFound");

    __int128 v79 = (void *)objc_claimAutoreleasedReturnValue([v143 clientDesire]);
    __int128 v80 = +[MASAutoAssetSetInfoDesire newShimmedToFramework:]( &OBJC_CLASS___MASAutoAssetSetInfoDesire,  "newShimmedToFramework:",  v79);
    -[NSMutableDictionary setSafeObject:forKey:](v145, "setSafeObject:forKey:", v80, @"setDesire");
  }

  __int128 v81 = objc_alloc(&OBJC_CLASS___SUCoreConnectMessage);
  __int128 v82 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  __int128 v83 = (void *)objc_claimAutoreleasedReturnValue([v82 clientRequestMessage]);
  __int128 v84 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager replyMessageNameForRequest:]( &OBJC_CLASS___MADAutoAssetControlManager,  "replyMessageNameForRequest:",  v83));
  __int128 v85 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([v85 clientID]);
  __int128 v87 = -[SUCoreConnectMessage initWithType:messageName:clientID:version:message:]( v81,  "initWithType:messageName:clientID:version:message:",  2LL,  v84,  v86,  0LL,  v145);

  v138 = v87;
  if (v87)
  {
    uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
    [v88 setResponseMessage:v87];
    uint64_t v89 = v147;
  }

  else
  {
    v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([v90 oslog]);

    uint64_t v89 = v147;
    if (os_log_type_enabled((os_log_t)v88, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager action_IssueClientReplySetJob:error:].cold.3(v5);
    }
  }

  if (v9) {
    goto LABEL_92;
  }
  uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
  uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v89 assetSetIdentifier]);
  uint64_t v93 = -[MADAutoAssetControlManager isSetIdentifierBeingEliminated:forClientDomainName:ofSetIdentifier:]( self,  "isSetIdentifierBeingEliminated:forClientDomainName:ofSetIdentifier:",  @"IssueClientReplySetJob",  v91,  v92);

  if (v93)
  {
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6114LL,  @"IssueClientReplySetJob",  0LL,  @"set-identifier is being eliminated"));
    uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    v95 = (os_log_s *)objc_claimAutoreleasedReturnValue([v94 oslog]);

    if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
      -[MADAutoAssetControlManager action_IssueClientReplySetJob:error:].cold.1(v5);
    }

    v96 = @"set-identifier being eliminated";
    goto LABEL_82;
  }

  v97 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  uint64_t v98 = objc_claimAutoreleasedReturnValue([v97 clientReplyCompletion]);
  if (!v98)
  {

    goto LABEL_91;
  }

  uint64_t v99 = (void *)v98;
  uint64_t v100 = +[SUCore stringIsEqual:to:]( &OBJC_CLASS___SUCore,  "stringIsEqual:to:",  v142,  @"MA-AUTO-SET(REPLY):LOCK_ATOMIC");

  if (!v100)
  {
LABEL_91:
    uint64_t v9 = 0LL;
    goto LABEL_92;
  }

  uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v146 latestDownloadedAtomicInstance]);
  uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
  char v103 = (void *)objc_claimAutoreleasedReturnValue([v89 assetSetIdentifier]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedPreferringByAtomicInstance:elseByClientDomain:forAssetSetIdentifier:fromLocation:]( self,  "locateSetDescriptorDownloadedPreferringByAtomicInstance:elseByClientDomain:forAssetSetIdentifier:fromLocation:",  v101,  v102,  v103,  @"IssueClientReplySetJob"));

  if (!v9)
  {
    v133 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
    v134 = (void *)objc_claimAutoreleasedReturnValue([v89 assetSetIdentifier]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedByClientDomain:forAssetSetIdentifier:consideringPreviouslyStaged:]( self,  "locateSetDescriptorDownloadedByClientDomain:forAssetSetIdentifier:consideringPreviouslyStaged:",  v133,  v134,  0LL));

    if (!v9
      || (v135 = (void *)objc_claimAutoreleasedReturnValue([v146 latestDowloadedAtomicInstanceEntries]),
          v136 = -[MADAutoAssetControlManager doesSetDescriptor:coverAllForAtomicInstanceEntries:]( self,  "doesSetDescriptor:coverAllForAtomicInstanceEntries:",  v9,  v135),  v135,  (v136 & 1) == 0))
    {

      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6504LL,  @"IssueClientReplySetJob",  0LL,  @"set-job successfully downloaded atomic-instance yet atomic-instance not present on the filesystem"));
      v96 = @"downloaded yet atomic-instance not present on the filesystem";
LABEL_82:
      v140 = v96;
      goto LABEL_92;
    }
  }

  if (![v9 secureOperationInProgress])
  {
    -[MADAutoAssetControlManager securePersonalizeGraftLockSet:lockingSetDescriptor:forEventInfo:fallingBackToSetDescriptor:]( self,  "securePersonalizeGraftLockSet:lockingSetDescriptor:forEventInfo:fallingBackToSetDescriptor:",  @"IssueClientReplySetJob",  v9,  v5,  0LL);
    goto LABEL_109;
  }

  SecKeyRef v104 = objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6532LL,  @"IssueClientReplySetJob",  0LL,  @"set-identifier already performing a secure-operation"));
  uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  uint64_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue([v105 oslog]);

  if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR)) {
    -[MADAutoAssetControlManager action_IssueClientReplySetJob:error:].cold.2(v5);
  }

  v140 = @"downloaded when secure operation in progress";
  uint64_t v9 = (void *)v104;
LABEL_92:
  uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v5 assetSetIdentifier]);
  uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetConfigurationByClientDomain:forAssetSetIdentifier:]( self,  "locateSetConfigurationByClientDomain:forAssetSetIdentifier:",  v107,  v108));

  uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  uint64_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue([v110 oslog]);

  if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v112 = v109 ? (__CFString *)objc_claimAutoreleasedReturnValue([v109 summary]) : @"None";
    *(_DWORD *)buf = 138543362;
    v150 = v112;
    _os_log_impl( &dword_0,  v111,  OS_LOG_TYPE_DEFAULT,  "{IssueClientReplySetJob} set-configuration before sending reply: %{public}@",  buf,  0xCu);
    if (v109) {
  }
    }

  uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
  uint64_t v114 = (void *)objc_claimAutoreleasedReturnValue([v5 assetSetIdentifier]);
  uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue([v5 clientRequest]);
  uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([v115 responseMessage]);
  uint64_t v117 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager updateAutoAssetSetStatus:forClientDomain:forAssetSetIdentifier:forJobResponse:withResponseError:clearingDownloadProgressReason:withAssetSetStatus:]( self,  "updateAutoAssetSetStatus:forClientDomain:forAssetSetIdentifier:forJobResponse:withResponseError:cle aringDownloadProgressReason:withAssetSetStatus:",  @"IssueClientReplySetJob",  v113,  v114,  v116,  v9,  v140,  v146));

  -[MADAutoAssetControlManager issueBuiltResponseForEventInfo:issuingResponseMessage:withResponseError:fromLocation:]( self,  "issueBuiltResponseForEventInfo:issuingResponseMessage:withResponseError:fromLocation:",  v5,  v117,  v9,  @"IssueClientReplySetJob");
  uint64_t v118 = v139;
  if (!v9) {
    uint64_t v118 = 1;
  }
  if ((v118 & 1) == 0)
  {
    uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue([v147 autoAssetSetClientName]);
    uint64_t v120 = v119
         ? objc_claimAutoreleasedReturnValue([v147 autoAssetSetClientName])
         : objc_claimAutoreleasedReturnValue([v147 clientProcessName]);
    v121 = (void *)v120;
    v122 = (void *)objc_claimAutoreleasedReturnValue([v147 clientDomainName]);
    v123 = (void *)objc_claimAutoreleasedReturnValue([v147 assetSetIdentifier]);
    +[MADAutoAssetHistory recordFailedOperation:fromClient:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:failingWithError:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordFailedOperation:fromClient:forClientDomainName:forAssetSetIdentifier:forAtomicInstance:failingWithError:",  504LL,  v121,  v122,  v123,  v148,  v9);

    if (v148)
    {
      v124 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager locateSetDescriptorDownloadedPreferringByAtomicInstance:elseByClientDomain:forAssetSetIdentifier:fromLocation:]( self,  "locateSetDescriptorDownloadedPreferringByAtomicInstance:elseByClientDomain:forAssetSetIdentifier:fromLocation:",  v148,  0LL,  0LL,  @"IssueClientReplySetJob"));
      if (!v124) {
        -[MADAutoAssetControlManager atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:]( self,  "atomicInstanceRemove:setAtomicInstanceUUID:removingForReason:historyOperation:",  @"IssueClientReplySetJob",  v148,  @"failure where atomic-instance never reached downloaded stage",  321LL);
      }
    }
  }

  uint64_t v89 = v147;
LABEL_109:

  v125 = (void *)objc_claimAutoreleasedReturnValue([v5 fromAutoAssetJob]);
  if (v125)
  {
    v126 = (void *)objc_claimAutoreleasedReturnValue([v5 fromAutoAssetJob]);
    if ((uint64_t)[v126 clientRequestCount] < 1)
    {
      v127 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](self, "autoControlManagerFSM"));
      v128 = (void *)objc_claimAutoreleasedReturnValue([v127 diag]);
      v129 = objc_alloc(&OBJC_CLASS___NSString);
      v130 = (void *)objc_claimAutoreleasedReturnValue([v5 summary]);
      v131 = -[NSString initWithFormat:]( v129,  "initWithFormat:",  @"set-job indicating issue-reply when no tracked client-requests | eventInfo:%@",  v130);
      [v128 trackAnomaly:@"AUTO-SET-CONTROL" forReason:v131 withResult:6110 withError:0];

      uint64_t v89 = v147;
    }

    else
    {
      objc_msgSend(v126, "setClientRequestCount:", (char *)objc_msgSend(v126, "clientRequestCount") - 1);
    }
  }

  return 0LL;
}

          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }

        return 3LL;
      }

      uint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3LL;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3LL;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3LL;
      }
      uint64_t v15 = 0LL;
      uint64_t v21 = (v19 - 1);
      id v22 = v7 - v21 - 2;
      uint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1LL)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        uint64_t v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        id v24 = *v14++;
        uint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          id v26 = v25;
          SecTrustResultType result = 3LL;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            uint64_t v27 = v22;
          }
          else {
            uint64_t v27 = v15;
          }
          uint64_t v10 = (unint64_t)v5 >= v23;
          uint64_t v28 = &v5[-v23];
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0LL;
        }
      }
    }

          __break(1u);
LABEL_70:
          __break(1u);
LABEL_71:
          __break(1u);
LABEL_72:
          __break(1u);
LABEL_73:
          __break(1u);
LABEL_74:
          __break(1u);
LABEL_75:
          __break(1u);
LABEL_76:
          __break(1u);
LABEL_77:
          __break(1u);
LABEL_78:
          __break(1u);
LABEL_79:
          __break(1u);
LABEL_80:
          __break(1u);
LABEL_81:
          __break(1u);
LABEL_82:
          __break(1u);
LABEL_83:
          __break(1u);
LABEL_84:
          __break(1u);
LABEL_85:
          __break(1u);
LABEL_86:
          __break(1u);
LABEL_87:
          __break(1u);
          return result;
        }

LABEL_133:
        if (v81)
        {
LABEL_140:
          -[MADAutoAssetControlManager _eliminateCompleteIfAllDone:](self, "_eliminateCompleteIfAllDone:", v94);
          goto LABEL_148;
        }

LABEL_134:
        uint64_t v115 = v144;
        uint64_t v116 = v143;
        if (v29)
        {
          uint64_t v115 = [v29 earlierSchedulerInvolved] | v144;
          uint64_t v116 = [v29 earlierPotentialNetworkFailure] | v143;
        }

        id v35 = v137;
        if (v137)
        {
          objb = v116;
          uint64_t v117 = v115 | [v137 earlierSchedulerInvolved];
          uint64_t v118 = [v137 earlierPotentialNetworkFailure];
          if ((v117 & 1) != 0)
          {
            uint64_t v116 = objb | v118;
LABEL_142:
            if ((_DWORD)v116)
            {
              uint64_t v120 = v116;
              v121 = (void *)objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6401LL,  v11,  0LL,  @"auto-asset-scheduler involved job finished with potential network-connectivity failure"));
              v122 = (void *)objc_claimAutoreleasedReturnValue([v10 autoAssetSelector]);
              id v35 = v137;
              +[MADAutoAssetHistory recordFailedOperation:fromLayer:forAssetID:withSelector:failingWithError:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordFailedOperation:fromLayer:forAssetID:withSelector:failingWithError:",  504LL,  1LL,  @"UNKNOWN",  v122,  v121);

              uint64_t v29 = v132;
              uint64_t v116 = v120;
            }

            if (v136) {
              v123 = v136;
            }
            else {
              v123 = v21;
            }
            +[MADAutoAssetScheduler jobFinishedForSelector:withPotentialNetworkFailure:]( &OBJC_CLASS___MADAutoAssetScheduler,  "jobFinishedForSelector:withPotentialNetworkFailure:",  v123,  v116);
          }
        }

        else if (v115)
        {
          goto LABEL_142;
        }

LABEL_76:
      }
  }
}

LABEL_77:
LABEL_78:
LABEL_79:
      uint64_t v112 = v161;
      if (!v90) {
        uint64_t v112 = v161 + 1;
      }
      v161 = v112;

LABEL_82:
      objc_autoreleasePoolPop(v75);
      if (v159 != (id)++v73) {
        continue;
      }
      break;
    }

    v159 = [v155 countByEnumeratingWithState:&v163 objects:v185 count:16];
    if (v159) {
      continue;
    }
    break;
  }

LABEL_89:
    _os_log_impl(&dword_0, (os_log_t)v116, OS_LOG_TYPE_DEFAULT, v119, buf, 0x48u);
    goto LABEL_90;
  }

  uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v162, "logger"));
  uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([v115 oslog]);

  uint64_t v118 = v150;
  uint64_t v117 = v151;
  if (os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134219520;
    v172 = obja;
    v173 = 2048;
    v174 = v160;
    v175 = 2048;
    v176 = v145;
    v177 = 2048;
    v178 = v147;
    v179 = 2048;
    v180 = v161;
    v181 = 2048;
    v182 = v146;
    v183 = 2048;
    v184 = v144;
    uint64_t v119 = "\n"
           "{chooseNewerSetDescriptor} decided left (more newer) | (left)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, (r"
           "ight)NotPresent:%ld,NotConfigured:%ld,IsNewer:%ld, same:%ld";
    goto LABEL_89;
  }

    __int128 v80 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
    __int128 v81 = (os_log_s *)objc_claimAutoreleasedReturnValue([v80 oslog]);

    if (!os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    __int128 v82 = (void *)objc_claimAutoreleasedReturnValue([v8 summary]);
    *(_DWORD *)buf = 138543362;
    uint64_t v116 = v82;
    __int128 v83 = "{loadPersistedSetDescriptorAsLatestToVend} preserved latest-to-vend | setConfiguration:%{public}@";
LABEL_93:
    _os_log_impl(&dword_0, v81, OS_LOG_TYPE_DEFAULT, v83, buf, 0xCu);

    goto LABEL_98;
  }

  return v25;
}

      id v8 = sub_212458(0LL, *((void *)v8 + 2) + 1LL, 1, v8);
      goto LABEL_46;
    }

LABEL_90:
  uint64_t v120 = v118;
LABEL_96:

  return v120;
}

void sub_1179EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_53:
        objc_autoreleasePoolPop(context);
        uint64_t v13 = (char *)v13 + 1;
      }

      while (v13 != v11);
      id v61 = [v9 countByEnumeratingWithState:&v89 objects:v98 count:16];
      uint64_t v11 = v61;
      if (!v61)
      {
LABEL_60:

        uint64_t v62 = v70 & 1;
        id v8 = v64;
        goto LABEL_61;
      }
    }
  }

  uint64_t v62 = 0;
LABEL_61:

  return v62;
}

LABEL_49:
  return v32;
}

        objc_autoreleasePoolPop(v24);
      }

      uint64_t v19 = [obj countByEnumeratingWithState:&v99 objects:v111 count:16];
      if (!v19)
      {
LABEL_70:

        __int128 v78 = v92 & 1;
        uint64_t v14 = v87;
        uint64_t v11 = v88;
        BOOL v17 = v86;
        goto LABEL_66;
      }
    }
  }

  __int128 v80 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob latestInstalledAssetVersion](self, "latestInstalledAssetVersion"));

  if (v80)
  {
    __int128 v81 = objc_alloc(&OBJC_CLASS___NSString);
    __int128 v82 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob latestInstalledAssetVersion](self, "latestInstalledAssetVersion"));
    __int128 v83 = -[NSString initWithFormat:]( v81,  "initWithFormat:",  @"successful catalog download yet no assets in catalog | have installed atomic-instance:%@ | REVOKED",  v82);
    -[MADAutoAssetJob statusChange:catalogFailure:forReason:]( self,  "statusChange:catalogFailure:forReason:",  v10,  6110LL,  v83);

    goto LABEL_65;
  }

  __int128 v84 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](self, "logger"));
  uint64_t v74 = (NSString *)objc_claimAutoreleasedReturnValue([v84 oslog]);

  if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v85 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](self, "autoJobName"));
    *(_DWORD *)buf = 138543618;
    SecKeyRef v104 = v85;
    uint64_t v105 = 2114;
    uint64_t v106 = v10;
    _os_log_impl( &dword_0,  (os_log_t)v74,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {%{public}@} no assets provided (and no latest-installed atomic-instance)",  buf,  0x16u);
  }

LABEL_55:
        }

        uint64_t v62 = [v60 countByEnumeratingWithState:&v160 objects:v171 count:16];
      }

      while (v62);
    }

    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v16 clientDomainName]);
    id v75 = (void *)objc_claimAutoreleasedReturnValue([v16 assetSetIdentifier]);
    -[MADAutoAssetControlManager setDescriptorEliminateMatching:forClientDomainName:forAssetSetIdentifier:eliminatingSetIdentifer:]( v147,  "setDescriptorEliminateMatching:forClientDomainName:forAssetSetIdentifier:eliminatingSetIdentifer:",  v146,  v74,  v75,  1LL);

    __int128 v76 = (void *)objc_claimAutoreleasedReturnValue([v16 clientDomainName]);
    __int128 v77 = (void *)objc_claimAutoreleasedReturnValue([v16 assetSetIdentifier]);
    -[MADAutoAssetControlManager atomicInstanceEliminate:forClientDomainName:forAssetSetIdentifier:]( v147,  "atomicInstanceEliminate:forClientDomainName:forAssetSetIdentifier:",  v146,  v76,  v77);

    __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([v16 clientDomainName]);
    __int128 v79 = (void *)objc_claimAutoreleasedReturnValue([v16 assetSetIdentifier]);
    -[MADAutoAssetControlManager setConfigurationEliminate:forClientDomainName:forAssetSetIdentifier:]( v147,  "setConfigurationEliminate:forClientDomainName:forAssetSetIdentifier:",  v146,  v78,  v79);

    __int128 v80 = (void *)objc_claimAutoreleasedReturnValue([v16 clientDomainName]);
    __int128 v81 = (void *)objc_claimAutoreleasedReturnValue([v16 assetSetIdentifier]);
    -[MADAutoAssetControlManager clearDownloadedFromSetStatus:forClientDomainName:forAssetSetIdentifier:]( v147,  "clearDownloadedFromSetStatus:forClientDomainName:forAssetSetIdentifier:",  v146,  v80,  v81);

    v158 = 0u;
    v159 = 0u;
    v156 = 0u;
    v157 = 0u;
    __int128 v82 = v139;
    __int128 v83 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v82,  "countByEnumeratingWithState:objects:count:",  &v156,  v170,  16LL);
    __int128 v84 = &MobileAssetKeyManager__metaData.ivars;
    if (v83)
    {
      __int128 v85 = v83;
      __int128 v86 = *(void *)v157;
      do
      {
        for (j = 0LL; j != v85; j = (char *)j + 1)
        {
          if (*(void *)v157 != v86) {
            objc_enumerationMutation(v82);
          }
          -[MADAutoAssetControlManager removeShortTermLockingOfSetDescriptor:forSetDescriptor:endingAll:error:]( v147,  "removeShortTermLockingOfSetDescriptor:forSetDescriptor:endingAll:error:",  v146,  *(void *)(*((void *)&v156 + 1) + 8LL * (void)j),  0LL,  0LL);
        }

        __int128 v85 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v82,  "countByEnumeratingWithState:objects:count:",  &v156,  v170,  16LL);
      }

      while (v85);
    }

    v132 = v82;

    v154 = 0u;
    v155 = 0u;
    v152 = 0u;
    v153 = 0u;
    v137 = (id)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( v147,  "downloadedSetDescriptorsByInstance"));
    uint64_t v88 = [v137 countByEnumeratingWithState:&v152 objects:v169 count:16];
    uint64_t v89 = v145;
    if (v88)
    {
      v90 = v88;
      v140 = *(id *)v153;
      do
      {
        for (k = 0LL; k != v90; k = (char *)k + 1)
        {
          if (*(id *)v153 != v140) {
            objc_enumerationMutation(v137);
          }
          uint64_t v92 = *(void *)(*((void *)&v152 + 1) + 8LL * (void)k);
          uint64_t v93 = objc_autoreleasePoolPush();
          uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( v147,  "downloadedSetDescriptorsByInstance"));
          v95 = [v94 safeObjectForKey:v92 ofClass:objc_opt_class(MADAutoSetDescriptor)];
          v96 = (void *)objc_claimAutoreleasedReturnValue(v95);

          if (v92)
          {
            v97 = v84[155];
            uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue([v96 clientDomainName]);
            uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
            if ((-[__objc2_ivar_list stringIsEqual:to:](v97, "stringIsEqual:to:", v98, v99) & 1) != 0)
            {
              uint64_t v100 = v84[155];
              uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v96 assetSetIdentifier]);
              uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([v145 assetSetIdentifier]);
              LODWORD(v100) = -[__objc2_ivar_list stringIsEqual:to:]( v100,  "stringIsEqual:to:",  v101,  v102);

              __int128 v84 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
              uint64_t v89 = v145;

              if ((_DWORD)v100)
              {
                char v103 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager setLockUsageMapForSetDescriptor:]( v147,  "setLockUsageMapForSetDescriptor:",  v96));

                if (v103)
                {
                  SecKeyRef v104 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetLocker eliminateAllPreviousSetLocksByClient:forSetDescriptor:]( &OBJC_CLASS___MADAutoAssetLocker,  "eliminateAllPreviousSetLocksByClient:forSetDescriptor:",  @"ELIMINATING_ALL_CLIENTS",  v96));
                  uint64_t v105 = v104;
                  if (v104 && [v104 count])
                  {
                    uint64_t v106 =  +[MADAutoAssetLocker eliminateAllPreviousSetLocksByClient:forSetDescriptor:]( &OBJC_CLASS___MADAutoAssetLocker,  "eliminateAllPreviousSetLocksByClient:forSetDescriptor:",  @"ALL_INSTANCES",  v96);
                    -[MADAutoAssetControlManager secureForceUngraftAll:forSetDescriptorBeingRemoved:]( v147,  "secureForceUngraftAll:forSetDescriptorBeingRemoved:",  v146,  v96);
                  }
                }

                -[NSMutableArray addObject:](v135, "addObject:", v92);
              }
            }

            else
            {
            }
          }

          objc_autoreleasePoolPop(v93);
        }

        v90 = [v137 countByEnumeratingWithState:&v152 objects:v169 count:16];
      }

      while (v90);
    }

    uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v89 clientDomainName]);
    uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v89 assetSetIdentifier]);
    +[MADAutoAssetLocker eliminateSetEndAllLocks:forClientDomainName:forAssetSetIdentifier:]( &OBJC_CLASS___MADAutoAssetLocker,  "eliminateSetEndAllLocks:forClientDomainName:forAssetSetIdentifier:",  v144,  v107,  v108);

    v150 = 0u;
    v151 = 0u;
    v148 = 0u;
    v149 = 0u;
    uint64_t v109 = v135;
    uint64_t v110 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v109,  "countByEnumeratingWithState:objects:count:",  &v148,  v168,  16LL);
    if (v110)
    {
      uint64_t v111 = v110;
      uint64_t v112 = *(void *)v149;
      v141 = v109;
      do
      {
        for (m = 0LL; m != v111; m = (char *)m + 1)
        {
          if (*(void *)v149 != v112) {
            objc_enumerationMutation(v141);
          }
          uint64_t v114 = *(void *)(*((void *)&v148 + 1) + 8LL * (void)m);
          uint64_t v115 = objc_autoreleasePoolPush();
          uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue( -[MADAutoAssetControlManager downloadedSetDescriptorsByInstance]( v147,  "downloadedSetDescriptorsByInstance"));
          uint64_t v117 = [v116 safeObjectForKey:v114 ofClass:objc_opt_class(MADAutoSetDescriptor)];
          uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue(v117);

          uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue([v118 clientDomainName]);
          uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v118 assetSetIdentifier]);
          v121 = (void *)objc_claimAutoreleasedReturnValue( +[MANAutoAssetSetStatus shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:]( &OBJC_CLASS___MANAutoAssetSetStatus,  "shortTermLockFilename:forAssetSetIdentifier:forSetAtomicInstance:",  v119,  v120,  v114));

          -[MADAutoAssetControlManager removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:]( v147,  "removeSetDescriptorDownloaded:fromLocation:checkingByInstance:regardlessOfLatest:historyOperationAI:historyOperationSD:",  v118,  v144,  1LL,  1LL,  328LL,  372LL);
          v122 =  -[MADAutoAssetControlManager _shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:]( v147,  "_shortTermSharedLockRemove:removingSharedLockFilename:usingFileManager:removingDescription:",  v146,  v121,  obja,  @"atomic-instance shared lock directory (eliminated set-identifier)");

          objc_autoreleasePoolPop(v115);
        }

        uint64_t v109 = v141;
        uint64_t v111 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v141,  "countByEnumeratingWithState:objects:count:",  &v148,  v168,  16LL);
      }

      while (v111);
    }

    uint64_t v16 = v145;
    v123 = (void *)objc_claimAutoreleasedReturnValue([v145 clientDomainName]);
    v124 = (void *)objc_claimAutoreleasedReturnValue([v145 assetSetIdentifier]);
    -[MADAutoAssetControlManager setLockUsageMapEliminateForClientDomain:forSetIdentifier:]( v147,  "setLockUsageMapEliminateForClientDomain:forSetIdentifier:",  v123,  v124);

    [v145 setAwaitingUnlocked:0];
    v125 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v147, "logger"));
    v126 = (os_log_s *)objc_claimAutoreleasedReturnValue([v125 oslog]);

    v127 = os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT);
    if (v133)
    {
      if (v127)
      {
        v128 = (void *)objc_claimAutoreleasedReturnValue([v145 summary]);
        *(_DWORD *)buf = 138543618;
        v174 = v146;
        v175 = 2114;
        *(void *)v176 = v128;
        _os_log_impl( &dword_0,  v126,  OS_LOG_TYPE_DEFAULT,  "\n [SET-ELIMINATE]{%{public}@} [REMOVE-CONTENT] elimination operations in progress | eliminateTracker:%{public}@",  buf,  0x16u);
      }
    }

    else
    {
      if (v127)
      {
        v131 = (void *)objc_claimAutoreleasedReturnValue([v145 summary]);
        *(_DWORD *)buf = 138543618;
        v174 = v146;
        v175 = 2114;
        *(void *)v176 = v131;
        _os_log_impl( &dword_0,  v126,  OS_LOG_TYPE_DEFAULT,  "\n [SET-ELIMINATE]{%{public}@} [REMOVE-CONTENT] no elimination operations in progress | eliminateTracker:%{public}@",  buf,  0x16u);
      }

      -[MADAutoAssetControlManager _eliminateCompleteIfAllDone:](v147, "_eliminateCompleteIfAllDone:", v145);
    }
  }

  else
  {
    [v16 setAwaitingUnlocked:1];
    v129 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v147, "logger"));
    uint64_t v109 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v129 oslog]);

    if (os_log_type_enabled((os_log_t)v109, OS_LOG_TYPE_DEFAULT))
    {
      v130 = (void *)objc_claimAutoreleasedReturnValue([v16 summary]);
      *(_DWORD *)buf = 138543618;
      v174 = v146;
      v175 = 2114;
      *(void *)v176 = v130;
      _os_log_impl( &dword_0,  (os_log_t)v109,  OS_LOG_TYPE_DEFAULT,  "\n[SET-ELIMINATE]{%{public}@} AWAIT-UNLOCKED elimination operations in progress | eliminateTracker:%{public}@",  buf,  0x16u);
    }
  }
}

  __int128 v86 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager activelyEliminatingSelectors](v72, "activelyEliminatingSelectors"));
  __int128 v87 = (void *)objc_claimAutoreleasedReturnValue([v81 persistedEntryID]);
  [v86 setSafeObject:v21 forKey:v87];

  uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v72, "logger"));
  uint64_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v88 oslog]);

  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    v90 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager _updateLatestSummary](v72, "_updateLatestSummary"));
    uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetEliminate summary](v21, "summary"));
    *(_DWORD *)buf = 138543618;
    uint64_t v112 = v90;
    uint64_t v113 = 2114;
    uint64_t v114 = v91;
    _os_log_impl( &dword_0,  v89,  OS_LOG_TYPE_DEFAULT,  "[%{public}@] {_eliminateBegin} all elimination operations in progress | eliminateTracker:%{public}@",  buf,  0x16u);
  }

LABEL_58:
}

LABEL_56:
LABEL_57:
                goto LABEL_58;
              }

              id v66 = (id)objc_claimAutoreleasedReturnValue(-[os_log_s clientDomainName](v55, "clientDomainName"));
              uint64_t v67 = (NSString *)objc_claimAutoreleasedReturnValue(-[os_log_s assetSetIdentifier](v55, "assetSetIdentifier"));
              -[MADAutoAssetControlManager _eliminateAtomicTriggeredWhileLoading:forClientDomainName:forAssetSetIdentifier:]( v99,  "_eliminateAtomicTriggeredWhileLoading:forClientDomainName:forAssetSetIdentifier:",  @"loadPersistedSetTargets",  v66,  v67);
LABEL_55:

              int v2 = v99;
              goto LABEL_56;
            }

            id v66 = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v99, "autoControlManagerFSM"));
            uint64_t v67 = (NSString *)objc_claimAutoreleasedReturnValue([v66 diag]);
            uint64_t v73 = v43;
            uint64_t v74 = objc_alloc(&OBJC_CLASS___NSString);
            id v75 = (void *)objc_claimAutoreleasedReturnValue([v52 summary]);
            __int128 v76 = -[NSString initWithFormat:]( v74,  "initWithFormat:",  @"{loadPersistedSetTargets} set-target versions not comparable (ignoring) | setTarget:%@",  v75);
            -[NSString trackAnomaly:forReason:withResult:withError:]( v67,  "trackAnomaly:forReason:withResult:withError:",  @"AUTO-CONTROL",  v76,  6103LL,  0LL);

            uint64_t v43 = v73;
            uint64_t v44 = v98;
          }

          else
          {
            uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager autoControlManagerFSM](v2, "autoControlManagerFSM"));
            __int128 v77 = (void *)objc_claimAutoreleasedReturnValue([v57 diag]);
            __int128 v78 = objc_alloc(&OBJC_CLASS___NSString);
            id v66 = (id)objc_claimAutoreleasedReturnValue([v52 summary]);
            uint64_t v67 = -[NSString initWithFormat:]( v78,  "initWithFormat:",  @"{loadPersistedSetTargets} no set-configuration for set-target | setTarget:%@",  v66);
            uint64_t v100 = v77;
            [v77 trackAnomaly:@"AUTO-CONTROL" forReason:v67 withResult:6103 withError:0];
          }

          SecKeyRef v47 = obja;
          goto LABEL_55;
        }

        id v71 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v2, "logger"));
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v71 oslog]);

        if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          uint64_t v115 = v46;
          _os_log_error_impl( &dword_0,  (os_log_t)v52,  OS_LOG_TYPE_ERROR,  "{loadPersistedSetTargets} | unable to determine previous status for entry:%{public}@",  buf,  0xCu);
        }

LABEL_71:
              }

              uint64_t v49 = v48;
              goto LABEL_73;
            }

            uint64_t v49 = 0LL;
LABEL_73:

            uint64_t v44 = (char *)v44 + 1;
          }

          while (v44 != obja);
          uint64_t v73 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v43,  "countByEnumeratingWithState:objects:count:",  &v93,  v108,  16LL);
          obja = v73;
          if (!v73)
          {
LABEL_79:

            uint64_t v6 = v74;
            goto LABEL_80;
          }
        }
      }
    }
  }

        uint64_t v18 = v253;
        uint64_t v19 = (void *)v254;
        if (!v13) {
          goto LABEL_5;
        }
        goto LABEL_4;
      }

      v286 = NSDebugDescriptionErrorKey;
      uint64_t v13 = v257;
      v236 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallUpdaterPersonalize() failed with error %d (%@)",  0LL,  AMAuthInstallGetLocalizedStatusString(v257, 0LL));
      v237 = (void *)objc_claimAutoreleasedReturnValue(v236);
      v287 = v237;
      v238 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v287,  &v286,  1LL));
      v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v238));

      v262 = 0;
      v273 = v200;
      uint64_t v18 = v253;
      uint64_t v19 = (void *)v254;
      uint64_t v10 = (uint64_t)v239;
LABEL_38:
      uint64_t v20 = v256;
LABEL_39:
      uint64_t v23 = (void *)v259;
      uint64_t v21 = v260;
      id v22 = (void *)v255;
      id v24 = v258;
      if (!v13) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }

    uint64_t v40 = objc_opt_class(&OBJC_CLASS___NSData);
    if ((objc_opt_isKindOfClass(v11, v40) & 1) == 0)
    {
      id v41 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Invalid ssoToken=%@", v11));
      uint64_t v43 = [v41 UTF8String];
      _MobileAssetLog( 0LL,  3,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v44,  v45,  v46,  v47,  (uint64_t)v43);
LABEL_23:

      goto LABEL_24;
    }

    id v41 = (id)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", @"https://gsra.apple.com:443"));
    if (AMAuthInstallSetSigningServerURL(v13, v41))
    {
      uint64_t v42 = @"Unable to set secure TSS URL for user authlisting";
    }

    else
    {
      if (!AMAuthInstallSsoSetToken(v13, v11))
      {
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"User-authlisting enabled."));
        uint64_t v49 = 6;
        goto LABEL_22;
      }

      uint64_t v42 = @"Unable to set SSO token for user authlisting";
    }

    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", v42));
    uint64_t v49 = 3;
LABEL_22:
    uint64_t v50 = v48;
    uint64_t v51 = [v50 UTF8String];
    _MobileAssetLog( 0LL,  v49,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v52,  v53,  v54,  v55,  (uint64_t)v51);

    goto LABEL_23;
  }

  v327 = NSDebugDescriptionErrorKey;
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Symbol not found: _%s",  "AMAuthInstallSetUpdaterRequestEntry"));
  v328 = v28;
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v328,  &v327,  1LL));
  v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v29));

  id v26 = 0LL;
  v266 = 0LL;
  v273 = 0LL;
  uint64_t v27 = 0LL;
  uint64_t v23 = 0LL;
  id v22 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v18 = 0LL;
  v262 = 0;
  id v24 = &__NSDictionary0__struct;
LABEL_7:
  if (!a5)
  {
    uint64_t v30 = v24;
    uint64_t v31 = v23;
    uint64_t v32 = v22;
    uint64_t v33 = (void *)v20;
    id v34 = (void *)v10;
    uint64_t v38 = v269;
LABEL_12:
    id v35 = v19;
    goto LABEL_13;
  }

  if (!v269)
  {
    uint64_t v30 = v24;
    uint64_t v31 = v23;
    uint64_t v32 = v22;
    uint64_t v33 = (void *)v20;
    id v34 = (void *)v10;
    uint64_t v38 = 0LL;
    goto LABEL_12;
  }

  v265 = v27;
  uint64_t v30 = v24;
  uint64_t v31 = v23;
  uint64_t v32 = v22;
  uint64_t v33 = (void *)v20;
  id v34 = (void *)v10;
  id v35 = v19;
  id v36 = v26;
  id v37 = v269;
  id v26 = v36;
  uint64_t v27 = v265;
  uint64_t v38 = v37;
  *a5 = v37;
LABEL_13:

  return v262 & 1;
}

LABEL_46:
  uint64_t v89 = objc_alloc_init((Class)p_ivars[139]);
  uint64_t v101 = 0u;
  uint64_t v102 = 0u;
  char v103 = 0u;
  SecKeyRef v104 = 0u;
  SecKeyRef v47 = obj;
  uint64_t v48 = [v47 countByEnumeratingWithState:&v101 objects:v114 count:16];
  if (v48)
  {
    uint64_t v49 = v48;
    uint64_t v50 = *(void *)v102;
    do
    {
      for (k = 0LL; k != v49; k = (char *)k + 1)
      {
        if (*(void *)v102 != v50) {
          objc_enumerationMutation(v47);
        }
        uint64_t v52 = *(void *)(*((void *)&v101 + 1) + 8LL * (void)k);
        if (v52)
        {
          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v8 autoAssetEntries]);
          id v54 = -[MADAutoAssetControlManager doesSetDescriptor:coverRequestedAutoAssetEntries:]( v96,  "doesSetDescriptor:coverRequestedAutoAssetEntries:",  v52,  v53);

          if (v54) {
            [v89 addObject:v52];
          }
        }
      }

      uint64_t v49 = [v47 countByEnumeratingWithState:&v101 objects:v114 count:16];
    }

    while (v49);
  }

  uint64_t v99 = 0u;
  uint64_t v100 = 0u;
  v97 = 0u;
  uint64_t v98 = 0u;
  uint64_t v55 = v89;
  uint64_t v94 = [v55 countByEnumeratingWithState:&v97 objects:v113 count:16];
  if (!v94)
  {

    uint64_t v40 = 0LL;
LABEL_82:
    uint64_t v74 = 0LL;
    uint64_t v10 = v85;
    uint64_t v9 = v86;
LABEL_83:
    self = v96;
    goto LABEL_84;
  }

  uint64_t v56 = 0LL;
  uint64_t v57 = *(id *)v98;
  uint64_t v58 = &MobileAssetKeyManager__metaData.ivars;
  obja = *(id *)v98;
  __int128 v87 = v55;
  do
  {
    for (m = 0LL; m != v94; m = (char *)m + 1)
    {
      if (*(id *)v98 != v57) {
        objc_enumerationMutation(v55);
      }
      uint64_t v60 = *(void **)(*((void *)&v97 + 1) + 8LL * (void)m);
      if (!v56)
      {
        uint64_t v56 = v60;
        continue;
      }

      id v61 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v97 + 1) + 8 * (void)m) catalogLastTimeChecked]);
      uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v56 catalogLastTimeChecked]);
      id v63 = (char *)[v61 compare:v62];

      if (v63 == (char *)-1LL)
      {
        id v8 = v95;
        continue;
      }

      id v8 = v95;
      if (v63 == (_BYTE *)&dword_0 + 1)
      {
        uint64_t v64 = v60;

        uint64_t v56 = v64;
        continue;
      }

      uint64_t v65 = v58[155];
      id v66 = (void *)objc_claimAutoreleasedReturnValue([v56 clientDomainName]);
      if (-[__objc2_ivar_list stringIsEqual:to:]( v65,  "stringIsEqual:to:",  v66,  @"FROM_STAGED_FOR_ALL"))
      {

        uint64_t v55 = v87;
LABEL_71:
        uint64_t v69 = v60;

        uint64_t v56 = v69;
        goto LABEL_72;
      }

      uint64_t v67 = v58[155];
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v56 assetSetIdentifier]);
      LODWORD(v67) = -[__objc2_ivar_list stringIsEqual:to:]( v67,  "stringIsEqual:to:",  v68,  @"FROM_STAGED_FOR_ALL");

      id v8 = v95;
      uint64_t v55 = v87;
      if ((_DWORD)v67) {
        goto LABEL_71;
      }
LABEL_72:
      uint64_t v58 = (__objc2_ivar_list **)(&MobileAssetKeyManager__metaData + 48);
      uint64_t v57 = obja;
    }

    uint64_t v94 = [v55 countByEnumeratingWithState:&v97 objects:v113 count:16];
  }

  while (v94);

  uint64_t v10 = v85;
  uint64_t v9 = v86;
  if (!v56)
  {
    uint64_t v40 = 0LL;
    uint64_t v74 = 0LL;
    goto LABEL_83;
  }

  self = v96;
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](v96, "logger"));
  id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue([v70 oslog]);

  if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
  {
    OSStatus v72 = (void *)objc_claimAutoreleasedReturnValue([v56 summary]);
    uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v8 summary]);
    *(_DWORD *)buf = 138543618;
    uint64_t v116 = v72;
    uint64_t v117 = 2114;
    uint64_t v118 = v73;
    _os_log_impl( &dword_0,  v71,  OS_LOG_TYPE_DEFAULT,  "{loadPersistedSetDescriptorAsLatestToVend} considering covering | mostRecentSetDescriptor:%{public}@ | setConfigur ation:%{public}@",  buf,  0x16u);
  }

  uint64_t v40 = v56;
  if (-[MADAutoAssetControlManager setConfigurationPotentialLatestToVend:forSetDescriptor:forSetConfiguration:]( v96,  "setConfigurationPotentialLatestToVend:forSetDescriptor:forSetConfiguration:",  @"loadPersistedSetDescriptorAsLatestToVend",  v56,  v8)
    && -[MADAutoAssetControlManager setConfigurationAdoptLatestToVend:fromSetDescriptor:toSetConfiguration:]( v96,  "setConfigurationAdoptLatestToVend:fromSetDescriptor:toSetConfiguration:",  @"loadPersistedSetDescriptorAsLatestToVend",  v56,  v8))
  {
    uint64_t v40 = v56;
    uint64_t v74 = v40;
  }

  else
  {
    uint64_t v74 = 0LL;
  }

LABEL_47:
LABEL_48:
    -[MADAutoAssetJob setSimulateEnd:](self, "setSimulateEnd:", 0LL, *(_OWORD *)v50, *(void *)&v50[16]);
    -[MADAutoAssetJob setSimulateTriggered:](self, "setSimulateTriggered:", 0LL);
    -[MADAutoAssetJob setSimulateDescriptor:](self, "setSimulateDescriptor:", 0LL);
    -[MADAutoAssetJob setSimulateBaseForPatch:](self, "setSimulateBaseForPatch:", 0LL);
  }

      v194 = v94;

      v216 = objc_alloc(&OBJC_CLASS___NSString);
      v203 = [*(id *)(v227 + 48) reclaimV2AssetCount];
      uint64_t v117 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimV2AssetSpace]);
      uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue(v117);
      v201 = [*(id *)(v227 + 48) reclaimUnlockedUnreferencedAutoAssetCount];
      uint64_t v119 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimUnlockedUnreferencedAutoAssetSpace]);
      contextb = (void *)objc_claimAutoreleasedReturnValue(v119);
      v199 = [*(id *)(v227 + 48) reclaimUnlockedReferencedAutoAssetCount];
      uint64_t v120 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimUnlockedReferencedAutoAssetSpace]);
      v220 = (void *)objc_claimAutoreleasedReturnValue(v120);
      v196 = [*(id *)(v227 + 48) reclaimLockedOverridableAutoAssetCount];
      v121 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimLockedOverridableAutoAssetSpace]);
      v122 = (void *)objc_claimAutoreleasedReturnValue(v121);
      v195 = [*(id *)(v227 + 48) reclaimLockedNeverRemoveAutoAssetCount];
      v123 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimLockedNeverRemoveAutoAssetSpace]);
      v124 = (void *)objc_claimAutoreleasedReturnValue(v123);
      v125 = [*(id *)(v227 + 48) reclaimStagedAutoAssetCount];
      v126 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimStagedAutoAssetSpace]);
      v127 = (void *)objc_claimAutoreleasedReturnValue(v126);
      v128 = [*(id *)(v227 + 48) reclaimMetadataBlockedCount];
      v129 = allocStringForBytes((uint64_t)[*(id *)(v227 + 48) reclaimMetadataBlockedSpace]);
      v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
      if (*(_BYTE *)(v227 + 76)) {
        v131 = @"reclaimed";
      }
      else {
        v131 = @"reclaimable";
      }
      v132 = allocStringForBytes(v93);
      v133 = (void *)objc_claimAutoreleasedReturnValue(v132);
      v217 = -[NSString initWithFormat:]( v216,  "initWithFormat:",  @"(reclaimAssets) v2Assets:%ld(%@), unlocked[unreferenced]:%ld(%@), unlocked[referenced]:%ld(%@), lockedOverridable:%ld(%@), lockedNeverRemove:%ld(%@), staged:%ld(%@), metadataBlocked:%ld(%@) | totalAmount(%@):%@",  v203,  v118,  v201,  contextb,  v199,  v220,  v196,  v122,  v195,  v124,  v125,  v127,  v128,  v130,  v131,  v133);

      v134 = (id *)(v227 + 32);
      v135 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) cacheDeleteOperationName]);
      contextCC_SHA1_CTX c = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) targetingAmountString]);
      v204 = [*(id *)(v227 + 32) reclaimUrgency];
      v221 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimUrgencyName]);
      v136 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimVolume]);
      v137 = [obj count];
      [*(id *)(v227 + 32) preciousNumberOfSeconds];
      v139 = +[MADAutoAssetControlManager allocIntervalString:]( &OBJC_CLASS___MADAutoAssetControlManager,  "allocIntervalString:",  (uint64_t)v138);
      if (*(_BYTE *)(v227 + 77)) {
        v140 = @"(from preference)";
      }
      else {
        v140 = &stru_355768;
      }
      [*v134 defaultNumberOfSeconds];
      v142 = +[MADAutoAssetControlManager allocIntervalString:]( &OBJC_CLASS___MADAutoAssetControlManager,  "allocIntervalString:",  (uint64_t)v141);
      if (*(_BYTE *)(v227 + 78)) {
        v143 = @"(from preference)";
      }
      else {
        v143 = &stru_355768;
      }
      [*v134 deltaToCurrentTimeSeconds];
      if (v148 <= 0.0)
      {
        v192 = v210;
        v193 = v217;
        v189 = v143;
        v191 = &stru_355768;
        v187 = v140;
        v188 = v142;
        v185 = v137;
        v186 = v139;
        v183 = v221;
        v184 = v136;
        v181 = v204;
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:t hen:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} ...%@ | targetingPurgeAmount:%@ | urgency:%d(%@) | volume:%@ | assetTypeDirs:%ld | preciousInterval:%@%@, defaultInterval:%@%@%@ | autoAssetStatus:%@ | %@ | MA_MILESTONE",  v144,  v145,  v146,  v147,  (uint64_t)v135);
      }

      else
      {
        v149 = objc_alloc(&OBJC_CLASS___NSString);
        [*(id *)(v227 + 32) deltaToCurrentTimeSeconds];
        v151 = +[MADAutoAssetControlManager allocIntervalString:]( &OBJC_CLASS___MADAutoAssetControlManager,  "allocIntervalString:",  (uint64_t)v150);
        v192 = v210;
        v193 = v217;
        v189 = v143;
        v191 = -[NSString initWithFormat:](v149, "initWithFormat:", @", deltaToCurrentTime:%@", v151);
        v187 = v140;
        v188 = v142;
        v185 = v137;
        v186 = v139;
        v183 = v221;
        v184 = v136;
        v181 = v204;
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:t hen:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} ...%@ | targetingPurgeAmount:%@ | urgency:%d(%@) | volume:%@ | assetTypeDirs:%ld | preciousInterval:%@%@, defaultInterval:%@%@%@ | autoAssetStatus:%@ | %@ | MA_MILESTONE",  v152,  v153,  v154,  v155,  (uint64_t)v135);
      }

      v233 = 0.0;
      v234 = &v233;
      v235 = 0x3032000000LL;
      v236 = __Block_byref_object_copy__15;
      v237 = __Block_byref_object_dispose__15;
      v238 = [*(id *)(v227 + 48) copy];
      v156 = v227;
      if (_MAPreferencesIsVerboseLoggingEnabled())
      {
        v157 = *(void *)(v227 + 40);
        [*(id *)(v227 + 32) reclaimUrgency];
        v158 = [*(id *)(v227 + 32) reclaimSpace];
        v159 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) analytics]);
        v160 = stringForAnalyticsReportingLevel((uint64_t)[v159 reportingLevel]);
        v181 = v158;
        v183 = (void *)objc_claimAutoreleasedReturnValue(v160);
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:t hen:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} Volume: %@ | Urgency: %d | Operation: %hhu | | reportingLevel %@",  v161,  v162,  v163,  v164,  v157);

        v165 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v234 + 5) description]);
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:t hen:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} Using Cache Delete Results: %@",  v166,  v167,  v168,  v169,  (uint64_t)v165);

        v156 = v227;
      }

      v170 = *(void *)(v156 + 32);
      v171 = *(void **)(v156 + 40);
      v172 = *(dispatch_queue_s **)(v170 + 64);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = __106__ControlManager_respondToCacheDelete_targetingPurgeAmount_cacheDeleteResults_withUrgency_forVolume_then___block_invoke_2;
      block[3] = &unk_34FE78;
      v232 = v95;
      void block[4] = v170;
      v230 = &v233;
      v231 = v93;
      v229 = v171;
      dispatch_async(v172, block);
      v173 = [*(id *)(v156 + 32) reclaimSpace];
      v174 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v156 + 32) unlockedUnreferencedDescriptors]);
      v175 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v156 + 32) unlockedReferencedDescriptors]);
      v176 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v156 + 32) lockedOverridableAutoAssetDescriptors]);
      v177 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v156 + 32) lockedNeverRemoveAutoAssetDescriptors]);
      v178 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v156 + 32) stagedAutoAssetDescriptors]);
      +[MADAutoAssetControlManager garbageCollectionOperationComplete:originalUnlockedUnreferencedDescriptors:originalUnlockedReferencedDescriptors:originalLockedOverridableDescriptors:originalLockedNeverRemoveDescriptors:originalStagedDescriptors:totalReclaimedSpace:results:]( &OBJC_CLASS___MADAutoAssetControlManager,  "garbageCollectionOperationComplete:originalUnlockedUnreferencedDescriptors:originalUnlockedReferencedDescriptors :originalLockedOverridableDescriptors:originalLockedNeverRemoveDescriptors:originalStagedDescriptors:totalReclai medSpace:results:",  v173,  v174,  v175,  v176,  v177,  v178,  v93,  *(void *)(v156 + 48),  v181,  v183,  v184,  v185,  v186,  v187,  v188,  v189,  v191,  v192,  v193);

      [*(id *)(v227 + 32) setUnlockedUnreferencedDescriptors:0];
      [*(id *)(v227 + 32) setUnlockedReferencedDescriptors:0];
      [*(id *)(v227 + 32) setLockedOverridableAutoAssetDescriptors:0];
      [*(id *)(v227 + 32) setLockedNeverRemoveAutoAssetDescriptors:0];
      [*(id *)(v227 + 32) setStagedAutoAssetDescriptors:0];

      _Block_object_dispose(&v233, 8);
    }

    else
    {
      __int128 v77 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) targetingAmountString]);
      [*(id *)(v227 + 32) reclaimUrgency];
      __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimUrgencyName]);
      __int128 v83 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimVolume]);
      if (v83)
      {
        v182 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimVolume]);
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:t hen:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} skipping garbage collection (no asset-type directories, volume reported by cache delete might be invalid) | targetingPurgeAmount:%@ | urgency:%d(%@) | volume:%@",  v84,  v85,  v86,  v87,  (uint64_t)v77);
      }

      else
      {
        _MobileAssetLog( 0LL,  5,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:t hen:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} skipping garbage collection (no asset-type directories, volume reported by cache delete might be invalid) | targetingPurgeAmount:%@ | urgency:%d(%@) | volume:%@",  v79,  v80,  v81,  v82,  (uint64_t)v77);
      }

      uint64_t v93 = 0LL;
    }

    uint64_t v88 = v227;
  }

  else
  {
    id v22 = (void *)objc_claimAutoreleasedReturnValue([v20 targetingAmountString]);
    [*(id *)(v227 + 32) reclaimUrgency];
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimUrgencyName]);
    id v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimVolume]);
    if (v24) {
      BOOL v25 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(v227 + 32) reclaimVolume]);
    }
    else {
      BOOL v25 = @"N";
    }
    uint64_t v88 = v227;
    [*(id *)(v227 + 32) currentTimeInSeconds];
    _MobileAssetLog( 0LL,  3,  (uint64_t)"-[ControlManager respondToCacheDelete:targetingPurgeAmount:cacheDeleteResults:withUrgency:forVolume:then:]_block_invoke",  @"[GARBAGE_COLLECTION] {respondToCacheDelete} skipping garbage collection | targetingPurgeAmount:%@ | urgency:%d(%@) | volume:%@ | current time is not valid | currentTimeInSeconds:%f, numberOfSecondsInAYear:%llu",  v89,  v90,  v91,  v92,  (uint64_t)v22);
    if (v24) {

    }
    uint64_t v93 = 0LL;
  }

  SecTrustResultType result = *(void *)(v227 + 56);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, v93);
  }
  return result;
}

                uint64_t v39 = v67;

LABEL_47:
                if (v39 == (id)++v41)
                {
                  uint64_t v39 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v37,  "countByEnumeratingWithState:objects:count:",  &v69,  v77,  16LL);
                  if (v39) {
                    goto LABEL_28;
                  }
                  break;
                }
              }
            }

            id v26 = (id)objc_claimAutoreleasedReturnValue( -[MobileAssetKeyManager buildKeyManagerError:underlying:description:]( self,  "buildKeyManagerError:underlying:description:",  30012LL,  0LL,  @"Unable to read valid key from provided key file"));
            uint64_t v14 = 0LL;
            id v8 = v64;
            uint64_t v58 = v37;
LABEL_56:
            a5 = v62;
            uint64_t v9 = v63;

            uint64_t v31 = v65;
          }

          else
          {
            id v26 = 0LL;
            uint64_t v14 = 0LL;
          }

          goto LABEL_58;
        }

LABEL_84:
  uint64_t v40 = v74;
  if (!v74)
  {
LABEL_88:
    if (!v9)
    {
      __int128 v84 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
      __int128 v81 = (os_log_s *)objc_claimAutoreleasedReturnValue([v84 oslog]);

      if (!os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_98;
      }
      __int128 v82 = (void *)objc_claimAutoreleasedReturnValue([v8 summary]);
      *(_DWORD *)buf = 138543362;
      uint64_t v116 = v82;
      __int128 v83 = "{loadPersistedSetDescriptorAsLatestToVend} no latest-to-vend | setConfiguration:%{public}@";
      goto LABEL_93;
    }

LABEL_85:
  id v75 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetControlManager logger](self, "logger"));
  __int128 v76 = (os_log_s *)objc_claimAutoreleasedReturnValue([v75 oslog]);

  __int128 v77 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (v77)
    {
      __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([v40 summary]);
      *(_DWORD *)buf = 138543362;
      uint64_t v116 = v78;
      __int128 v79 = "{loadPersistedSetDescriptorAsLatestToVend} replaced latest-to-vend | adoptedSetDescriptor:%{public}@";
      goto LABEL_96;
    }
  }

  else if (v77)
  {
    __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([v40 summary]);
    *(_DWORD *)buf = 138543362;
    uint64_t v116 = v78;
    __int128 v79 = "{loadPersistedSetDescriptorAsLatestToVend} adopted when no pre-existing latest-to-vend | adoptedSetDescriptor:%{public}@";
LABEL_96:
    _os_log_impl(&dword_0, v76, OS_LOG_TYPE_DEFAULT, v79, buf, 0xCu);
  }

  __int128 v81 = (os_log_s *)v40;
LABEL_98:
}

LABEL_103:
  -[MADAutoAssetControlManager _logPersistedTableOfContents:forComponentType:]( self,  "_logPersistedTableOfContents:forComponentType:",  v8,  @"SET_ACTIVE_JOB_DESCRIPTORS");
LABEL_104:
}

void sub_1399A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_13A1D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_13AA90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_13AE14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_13F0EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_70:
        }

        uint64_t v91 = -[NSString countByEnumeratingWithState:objects:count:]( v119,  "countByEnumeratingWithState:objects:count:",  &v128,  v145,  16LL);
        if (!v91)
        {
          uint64_t v64 = v113;
          id v66 = v110;
          uint64_t v65 = v111;
          uint64_t v74 = v109;
          id v75 = v121;
LABEL_73:
          __int128 v82 = 0LL;
          __int128 v83 = v119;
LABEL_74:

          uint64_t v89 = v115;
LABEL_75:

          break;
        }
      }
    }

LABEL_52:
}

  if ((a3 & 0x10000000000000LL) == 0) {
    goto LABEL_62;
  }
  CFAbsoluteTime data = xpc_dictionary_get_data(v10, (const char *)[@"QueryParams" UTF8String], &length);
  if (data)
  {
    uint64_t v120 = v14;
    v125 = a3;
    id v35 = v11;
    id v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  data,  length,  0LL));
    id v37 = -[NSKeyedUnarchiver initForReadingFromData:error:]( objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver),  "initForReadingFromData:error:",  v36,  0LL);
    DecodeClasses = queryDecodeClasses();
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(DecodeClasses);
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue( -[NSKeyedUnarchiver decodeObjectOfClasses:forKey:]( v37,  "decodeObjectOfClasses:forKey:",  v39,  NSKeyedArchiveRootObjectKey));

    -[NSKeyedUnarchiver finishDecoding](v37, "finishDecoding");
    id v41 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    if ((objc_opt_isKindOfClass(v40, v41) & 1) != 0)
    {
      [v35 associateQueryParams:v40];
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v35 queryParams]);
      uint64_t v43 = stringWithoutNewlines((uint64_t)v42);
      uint64_t v44 = v13;
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v43);
      [v12 extendLogLeader:@"QueryParams" withValue:v45];

      uint64_t v13 = v44;
      BOOL v17 = 0LL;
    }

    else
    {
      BOOL v17 = @"Invalid query parameters class provided by client (expecting dictionary)";
    }

    uint64_t v11 = v35;
    a3 = v125;
    uint64_t v14 = v120;
  }

  else
  {
    BOOL v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Client request missing key:%@",  @"QueryParams");
  }

        objc_autoreleasePoolPop(v11);
        id v26 = 0LL;
        goto LABEL_61;
      }

      uint64_t v14 = (NSData *)objc_claimAutoreleasedReturnValue([(id)v9 decryptionKey]);
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MobileAssetKeyManager logger](self, "logger"));
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue([v28 oslog]);

      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( &dword_0,  v29,  OS_LOG_TYPE_DEFAULT,  "[KeyFromMetaDataOrOptions]: Decryption key found in client provided downloadOptions. Returning key from options.",  buf,  2u);
      }
    }

LABEL_61:
}
      }

      else
      {
        uint64_t v60 = 0LL;
      }

      unsigned int v5 = v71;
      id v4 = v72;
      id v8 = v70;
    }

    else
    {
      uint64_t v60 = 0LL;
    }
  }

  else
  {
    uint64_t v60 = 0LL;
  }

  return v60;
}

  if (v17) {
    goto LABEL_182;
  }
LABEL_62:
  if ((a3 & 4) != 0)
  {
    uint64_t v49 = objc_claimAutoreleasedReturnValue( +[ControlManager getStringFromXpcMessage:forKey:]( &OBJC_CLASS___ControlManager,  "getStringFromXpcMessage:forKey:",  v10,  "RelativeUrlKey"));

    if (v49)
    {
      [v11 associateRelativeUrl:v49];
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v11 relativeUrl]);
      [v12 extendLogLeader:@"RelativeUrlKey" withValue:v50];

      uint64_t v14 = (__CFString *)v49;
    }

    else
    {
      uint64_t v59 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Client request missing key:%@",  @"RelativeUrlKey");
      uint64_t v14 = 0LL;
      if (v59) {
        goto LABEL_101;
      }
    }
  }

  if ((a3 & 0x200000) != 0)
  {
    uint64_t v51 = v14;
    DownloadManager = getDownloadManager();
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(DownloadManager);
    id v54 = (void *)objc_claimAutoreleasedReturnValue([v53 downloadManagerDecodeClasses]);
    v140 = 0LL;
    uint64_t v55 = getObjectFromMessageWithFailureReason(v10, "downloadOptionsLength", "downloadOptions", v54, &v140);
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
    BOOL v17 = (__CFString *)v140;

    if (v56)
    {
      uint64_t v57 = objc_opt_class(&OBJC_CLASS___MADownloadOptions);
      if ((objc_opt_isKindOfClass(v56, v57) & 1) != 0)
      {
        [v11 associateDownloadOptions:v56];
        uint64_t v58 = (__CFString *)objc_claimAutoreleasedReturnValue([v56 tightSummaryIncludingAdditional:0]);
        [v12 extendLogLeader:@"downloadOptions" withValue:v58];
      }

      else
      {
        uint64_t v58 = v17;
        BOOL v17 = @"Invalid download options class provided by client";
      }

      uint64_t v14 = v51;
    }

    else
    {
      uint64_t v14 = v51;
    }
  }

  else
  {
    BOOL v17 = 0LL;
  }

  uint64_t v60 = v17 == 0LL;
  if ((a3 & 0x200000000000LL) != 0 && !v17)
  {
    id v61 = xpc_dictionary_get_uint64(v10, "downloadSize");
    if (v61)
    {
      [v11 associateDownloadSize:v61];
      uint64_t v62 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"%llu",  [v11 downloadSize]);
      [v12 extendLogLeader:@"downloadSize" withValue:v62];
    }

    uint64_t v60 = 1;
  }

  if ((a3 & 0x1000) == 0 || v17)
  {
LABEL_87:
    if (!v60) {
      goto LABEL_96;
    }
    goto LABEL_88;
  }

  id v63 = xpc_dictionary_get_uint64(v10, "notificationInterval");
  if (!v63)
  {
    BOOL v17 = 0LL;
    goto LABEL_87;
  }

  [v11 associateNotificationInterval:v63];
  uint64_t v64 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"%llu",  [v11 notificationInterval]);
  [v12 extendLogLeader:@"notificationInterval" withValue:v64];

  if (!v60)
  {
    BOOL v17 = 0LL;
    goto LABEL_96;
  }

  return v14;
}

void OUTLINED_FUNCTION_16_0(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

id OUTLINED_FUNCTION_24(void *a1, const char *a2)
{
  return [a1 count];
}

BOOL MABrainUtilityWalkDirectory(void *a1, char a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = a3;
  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 enumeratorAtPath:v5]);

  if (v8)
  {
    uint64_t v9 = objc_autoreleasePoolPush();
    uint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = v10;
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 nextObject]);

      if (!v10) {
        break;
      }
      if ((a2 & 1) == 0) {
        [v8 skipDescendants];
      }
      if ((v6[2](v6, v10) & 1) == 0)
      {
        id v12 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Caller canceled enumeration"));
        id v13 = [v12 UTF8String];
        _MobileAssetLog( 0LL,  7,  (uint64_t)"MABrainUtilityWalkDirectory",  @"[MAB] %s",  v14,  v15,  v16,  v17,  (uint64_t)v13);

        break;
      }
    }

    objc_autoreleasePoolPop(v9);
  }

  else
  {
    id v18 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Could not create directory enumerator for %@", v5));
    id v19 = [v18 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityWalkDirectory", @"[MAB] %s", v20, v21, v22, v23, (uint64_t)v19);
  }

  return v8 != 0LL;
}

uint64_t MABrainUtilityAllowUnpersonalizedBrain()
{
  uint64_t result = os_variant_has_internal_content("com.apple.mobileassetd");
  if ((_DWORD)result) {
    return _MAPreferencesGetAppBooleanValue(@"MABrainAllowUnpersonalized", 0LL) != 0;
  }
  return result;
}

BOOL MABrainUtilityAllowSameVersionBrain()
{
  return _MAPreferencesGetAppBooleanValue(@"MABrainAllowSameVersion", 0LL) != 0;
}

uint64_t MABrainUtilityAllowCrossBuildGroupBrain()
{
  uint64_t result = os_variant_has_internal_content("com.apple.mobileassetd");
  if ((_DWORD)result) {
    return _MAPreferencesGetAppBooleanValue(@"MABrainAllowCrossBuildGroup", 0LL) != 0;
  }
  return result;
}

uint64_t MABrainUtilityCrashLoopTestMode()
{
  uint64_t result = os_variant_has_internal_content("com.apple.mobileassetd");
  if ((_DWORD)result) {
    return _MAPreferencesGetAppBooleanValue(@"MABrainCrashLoopTestMode", 0LL) != 0;
  }
  return result;
}

BOOL MABrainUtilityReleaseTestMode()
{
  return _MAPreferencesGetAppBooleanValue(@"MABrainReleaseTestMode", 0LL) != 0;
}

double MABrainUtilityScanInterval()
{
  id v0 = _MAPreferencesCopyValue(@"MABrainScanInterval");
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  double v2 = 43200.0;
  if (v1)
  {
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSNumber);
    if ((objc_opt_isKindOfClass(v1, v3) & 1) != 0)
    {
      [v1 doubleValue];
      if (v4 >= 60.0) {
        double v2 = v4;
      }
      else {
        double v2 = 60.0;
      }
    }
  }

  return v2;
}

double MABrainUtilityReleaseTestModeInterval()
{
  id v0 = _MAPreferencesCopyValue(@"MABrainReleaseTestModeInterval");
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (v1 && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v1, v2) & 1) != 0))
  {
    id v3 = v1;
    [v3 doubleValue];
    double v4 = 60.0;
    if (v5 > 60.0)
    {
      [v3 doubleValue];
      double v4 = v6;
    }
  }

  else
  {
    double v4 = 60.0;
  }

  return v4;
}

id MABrainUtilityGetImageUUID()
{
  uint64_t v0 = 0LL;
  uint64_t v1 = &stru_20;
  while (*(int *)((char *)&dword_0 + (void)v1) != 27)
  {
    uint64_t v1 = (segment_command_64 *)((char *)v1 + *(unsigned int *)((char *)&dword_4 + (void)v1));
    if (++v0 == 61)
    {
      uuid_clear(dst);
      goto LABEL_6;
    }
  }

  uuid_copy(dst, (const unsigned __int8 *)&dword_8 + (void)v1);
LABEL_6:
  uuid_unparse_lower(dst, out);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  out,  1LL));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 stringByReplacingOccurrencesOfString:@"-" withString:&stru_355768]);

  return v3;
}

id MABrainUtilityBootSessionUUID()
{
  size_t __size = 0LL;
  if (sysctlbyname("kern.bootsessionuuid", 0LL, &__size, 0LL, 0LL))
  {
    uint64_t v0 = *__error();
    uint64_t v1 = __error();
    uint64_t v23 = v0;
    id v24 = strerror(*v1);
    uint64_t v2 = @"Could not look up boot session UUID: %d (%s)";
LABEL_3:
    id v3 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", v2, v23, v24);
LABEL_4:
    id v4 = objc_claimAutoreleasedReturnValue(v3);
    id v5 = [v4 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityBootSessionUUID", @"[MAB] %s", v6, v7, v8, v9, (uint64_t)v5);

    uint64_t v10 = 0LL;
    return v10;
  }

  if (!__size)
  {
    id v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Boot session UUID has an invalid length (%zu)",  0LL,  v24);
    goto LABEL_4;
  }

  id v12 = malloc(__size);
  if (!v12)
  {
    uint64_t v2 = @"Could not allocate buffer to copy boot session UUID";
    goto LABEL_3;
  }

  id v13 = v12;
  if (sysctlbyname("kern.bootsessionuuid", v12, &__size, 0LL, 0LL))
  {
    uint64_t v14 = *__error();
    uint64_t v15 = __error();
    uint64_t v16 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Could not copy boot session UUID: %d (%s)",  v14,  strerror(*v15));
    id v17 = objc_claimAutoreleasedReturnValue(v16);
    id v18 = [v17 UTF8String];
    _MobileAssetLog( 0LL,  3,  (uint64_t)"MABrainUtilityBootSessionUUID",  @"[MAB] %s",  v19,  v20,  v21,  v22,  (uint64_t)v18);

    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  v13,  4LL));
  }

  free(v13);
  return v10;
}

uint64_t MABrainUtilityIsPasscodeLocked()
{
  v2[0] = kMKBUserSessionIDKey;
  v2[1] = @"ExtendedDeviceLockState";
  v3[0] = &off_38EFF8;
  v3[1] = &__kCFBooleanTrue;
  unsigned int v0 = MKBGetDeviceLockState( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v3,  v2,  2LL));
  return (v0 < 7) & (0x46u >> v0);
}

void MABrainUtilityScheduleDeviceUnlockAction(void *a1, void *a2, int *a3, void *a4)
{
  uint64_t v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (a3) {
    *a3 = -1;
  }
  if ((MABrainUtilityIsPasscodeLocked() & 1) != 0)
  {
    out_audit_token_t token = -1;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = __MABrainUtilityScheduleDeviceUnlockAction_block_invoke_2;
    handler[3] = &unk_34F598;
    id v10 = v8;
    id v19 = v10;
    id v20 = v9;
    notify_register_dispatch("com.apple.mobile.keybagd.lock_status", &out_token, v7, handler);
    id v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Device unlock action %@ is scheduled (token=%d)", v10, out_token));
    id v12 = [v11 UTF8String];
    _MobileAssetLog( 0LL,  6,  (uint64_t)"MABrainUtilityScheduleDeviceUnlockAction",  @"[MAB] %s",  v13,  v14,  v15,  v16,  (uint64_t)v12);

    if (a3) {
      *a3 = out_token;
    }

    id v17 = v19;
  }

  else
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = __MABrainUtilityScheduleDeviceUnlockAction_block_invoke;
    block[3] = &unk_34ED80;
    id v23 = v8;
    id v24 = v9;
    dispatch_async(v7, block);

    id v17 = v23;
  }
}

uint64_t __MABrainUtilityScheduleDeviceUnlockAction_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(const __CFString **)(a1 + 32);
  if (!v2) {
    uint64_t v2 = @"(unnamed)";
  }
  id v3 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Device is already unlocked. Starting action %@", v2));
  id v4 = [v3 UTF8String];
  _MobileAssetLog( 0LL,  6,  (uint64_t)"MABrainUtilityScheduleDeviceUnlockAction_block_invoke",  @"[MAB] %s",  v5,  v6,  v7,  v8,  (uint64_t)v4);

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void __MABrainUtilityScheduleDeviceUnlockAction_block_invoke_2(uint64_t a1, uint64_t a2)
{
  char IsPasscodeLocked = MABrainUtilityIsPasscodeLocked();
  uint64_t v5 = *(const __CFString **)(a1 + 32);
  if (!v5) {
    uint64_t v5 = @"(unnamed)";
  }
  if ((IsPasscodeLocked & 1) != 0)
  {
    id v17 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Device is still locked. Deferring action %@ (token=%d)", v5, a2));
    id v6 = [v17 UTF8String];
    _MobileAssetLog( 0LL,  6,  (uint64_t)"MABrainUtilityScheduleDeviceUnlockAction_block_invoke_2",  @"[MAB] %s",  v7,  v8,  v9,  v10,  (uint64_t)v6);
  }

  else
  {
    id v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Device is now unlocked. Starting action %@ (token=%d)", v5, a2));
    id v12 = [v11 UTF8String];
    _MobileAssetLog( 0LL,  6,  (uint64_t)"MABrainUtilityScheduleDeviceUnlockAction_block_invoke_2",  @"[MAB] %s",  v13,  v14,  v15,  v16,  (uint64_t)v12);

    notify_cancel(a2);
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }

void MABrainUtilityCancelDeviceUnlockAction(uint64_t a1)
{
  if ((_DWORD)a1 != -1)
  {
    if (notify_cancel(a1))
    {
      uint64_t v2 = *__error();
      id v3 = __error();
      id v4 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error canceling device unlock action (token=%d). errno=%d (%s)",  a1,  v2,  strerror(*v3));
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      int v6 = 3;
    }

    else
    {
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Canceled device unlock action (token=%d)...",  a1));
      int v6 = 6;
    }

    id v12 = v5;
    id v7 = [v12 UTF8String];
    _MobileAssetLog( 0LL,  v6,  (uint64_t)"MABrainUtilityCancelDeviceUnlockAction",  @"[MAB] %s",  v8,  v9,  v10,  v11,  (uint64_t)v7);
  }

uint64_t MABrainUtilityWriteDictionary(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v21 = 0LL;
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v5,  100LL,  0LL,  &v21));
  id v8 = v21;
  uint64_t v9 = v8;
  if (v7)
  {
    id v20 = v8;
    unsigned __int8 v10 = [v7 writeToFile:v6 options:0 error:&v20];
    id v11 = v20;

    if ((v10 & 1) != 0)
    {
      uint64_t v12 = 1LL;
      goto LABEL_8;
    }
  }

  else
  {
    id v11 = v8;
  }

  id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Failed to write %@ with contents of dictionary:%@\n%@", v6, v11, v5));
  id v14 = [v13 UTF8String];
  _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityWriteDictionary", @"[MAB] %s", v15, v16, v17, v18, (uint64_t)v14);

  if (a3)
  {
    id v11 = v11;
    uint64_t v12 = 0LL;
    *a3 = v11;
  }

  else
  {
    uint64_t v12 = 0LL;
  }

uint64_t MABrainUtilityForceSecureAssetMount()
{
  uint64_t result = os_variant_has_internal_content("com.apple.mobileassetd");
  if ((_DWORD)result) {
    return _MAPreferencesGetAppBooleanValue(@"SecureMobileAssetForceMount", 0LL) != 0;
  }
  return result;
}

uint64_t MABrainUtilityDeviceSupportsExclaves()
{
  if (MABrainUtilityDeviceSupportsExclaves_onceToken != -1) {
    dispatch_once(&MABrainUtilityDeviceSupportsExclaves_onceToken, &__block_literal_global_19);
  }
  return MABrainUtilityDeviceSupportsExclaves_answer;
}

uint64_t MABrainUtilityConclaveEnabled()
{
  if (MABrainUtilityConclaveEnabled_onceToken != -1) {
    dispatch_once(&MABrainUtilityConclaveEnabled_onceToken, &__block_literal_global_245);
  }
  return MABrainUtilityConclaveEnabled_answer;
}

CFNumberRef MABrainUtilityCopyEcid()
{
  uint64_t valuePtr = 0LL;
  unsigned int v0 = (const __CFData *)_copy_value_from_IONode(@"unique-chip-id");
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFDataGetTypeID())
    {
      uint64_t valuePtr = *(void *)CFDataGetBytePtr(v1);
      CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
    }

    else
    {
      id v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
      id v12 = [v11 UTF8String];
      _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopyEcid", @"[MAB] %s", v13, v14, v15, v16, (uint64_t)v12);

      CFNumberRef v3 = 0LL;
    }

    CFRelease(v1);
    return v3;
  }

  else
  {
    id v4 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
    id v5 = [v4 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopyEcid", @"[MAB] %s", v6, v7, v8, v9, (uint64_t)v5);

    return (CFNumberRef)0LL;
  }

CFTypeRef _copy_value_from_IONode(const __CFString *a1)
{
  io_registry_entry_t v2 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
  if (!v2) {
    return 0LL;
  }
  io_object_t v3 = v2;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v2, a1, kCFAllocatorDefault, 0);
  IOObjectRelease(v3);
  if (CFProperty)
  {
    CFTypeID v5 = CFGetTypeID(CFProperty);
    if (v5 != CFDataGetTypeID())
    {
      id v6 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a non-CFData return value from IORegistryEntryCreateCFProperty for property %@", a1));
      id v7 = [v6 UTF8String];
      _MobileAssetLog(0LL, 6, (uint64_t)"_copy_value_from_IONode", @"[MAB] %s", v8, v9, v10, v11, (uint64_t)v7);

      CFRelease(CFProperty);
      return 0LL;
    }
  }

  return CFProperty;
}

CFNumberRef MABrainUtilityCopyBoardId()
{
  int valuePtr = 0;
  unsigned int v0 = (const __CFData *)_copy_value_from_IONode(@"board-id");
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFDataGetTypeID())
    {
      int valuePtr = *(_DWORD *)CFDataGetBytePtr(v1);
      CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }

    else
    {
      id v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
      id v12 = [v11 UTF8String];
      _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopyBoardId", @"[MAB] %s", v13, v14, v15, v16, (uint64_t)v12);

      CFNumberRef v3 = 0LL;
    }

    CFRelease(v1);
    return v3;
  }

  else
  {
    id v4 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
    id v5 = [v4 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopyBoardId", @"[MAB] %s", v6, v7, v8, v9, (uint64_t)v5);

    return (CFNumberRef)0LL;
  }

CFNumberRef MABrainUtilityCopyChipId()
{
  int valuePtr = 0;
  unsigned int v0 = (const __CFData *)_copy_value_from_IONode(@"chip-id");
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFDataGetTypeID())
    {
      int valuePtr = *(_DWORD *)CFDataGetBytePtr(v1);
      CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }

    else
    {
      id v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
      id v12 = [v11 UTF8String];
      _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopyChipId", @"[MAB] %s", v13, v14, v15, v16, (uint64_t)v12);

      CFNumberRef v3 = 0LL;
    }

    CFRelease(v1);
    return v3;
  }

  else
  {
    id v4 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
    id v5 = [v4 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopyChipId", @"[MAB] %s", v6, v7, v8, v9, (uint64_t)v5);

    return (CFNumberRef)0LL;
  }

CFNumberRef MABrainUtilityCopySecurityDomain()
{
  int valuePtr = 0;
  unsigned int v0 = (const __CFData *)_copy_value_from_IONode(@"security-domain");
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFDataGetTypeID())
    {
      int valuePtr = *(_DWORD *)CFDataGetBytePtr(v1);
      CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }

    else
    {
      id v11 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
      id v12 = [v11 UTF8String];
      _MobileAssetLog( 0LL,  3,  (uint64_t)"MABrainUtilityCopySecurityDomain",  @"[MAB] %s",  v13,  v14,  v15,  v16,  (uint64_t)v12);

      CFNumberRef v3 = 0LL;
    }

    CFRelease(v1);
    return v3;
  }

  else
  {
    id v4 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
    id v5 = [v4 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopySecurityDomain", @"[MAB] %s", v6, v7, v8, v9, (uint64_t)v5);

    return (CFNumberRef)0LL;
  }

CFBooleanRef MABrainUtilityCopyCertificateSecurityMode()
{
  CFBooleanRef v0 = kCFBooleanFalse;
  uint64_t v1 = (const __CFData *)_copy_value_from_IONode(@"certificate-security-mode");
  if (v1)
  {
    CFTypeID v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFDataGetTypeID())
    {
      if (*(void *)CFDataGetBytePtr(v2)) {
        CFBooleanRef v0 = kCFBooleanTrue;
      }
    }

    else
    {
      id v10 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
      id v11 = [v10 UTF8String];
      _MobileAssetLog( 0LL,  3,  (uint64_t)"MABrainUtilityCopyCertificateSecurityMode",  @"[MAB] %s",  v12,  v13,  v14,  v15,  (uint64_t)v11);
    }

    CFRelease(v2);
  }

  else
  {
    id v4 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
    id v5 = [v4 UTF8String];
    _MobileAssetLog( 0LL,  3,  (uint64_t)"MABrainUtilityCopyCertificateSecurityMode",  @"[MAB] %s",  v6,  v7,  v8,  v9,  (uint64_t)v5);
  }

  return v0;
}

CFBooleanRef MABrainUtilityCopySigningFuse()
{
  CFBooleanRef v0 = kCFBooleanTrue;
  uint64_t v1 = (const __CFData *)_copy_value_from_IONode(@"development-cert");
  if (v1)
  {
    CFTypeID v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFDataGetTypeID())
    {
      if (*(void *)CFDataGetBytePtr(v2) == 1LL) {
        CFBooleanRef v0 = kCFBooleanFalse;
      }
    }

    else
    {
      id v10 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
      id v11 = [v10 UTF8String];
      _MobileAssetLog( 0LL,  3,  (uint64_t)"MABrainUtilityCopySigningFuse",  @"[MAB] %s",  v12,  v13,  v14,  v15,  (uint64_t)v11);
    }

    CFRelease(v2);
  }

  else
  {
    id v4 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Got a NULL return from IORegistryEntryCreateCFProperty"));
    id v5 = [v4 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"MABrainUtilityCopySigningFuse", @"[MAB] %s", v6, v7, v8, v9, (uint64_t)v5);
  }

  return v0;
}

void cleanUpLegacyItems()
{
  CFBooleanRef v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  [v0 removeItemAtPath:@"/private/var/MobileAsset/PreinstalledAssets/com_apple_MobileAsset_CoreSuggestionsQPAssets.cpio" error:0];

  id v1 = (id)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  [v1 removeItemAtPath:@"/private/var/MobileAsset/PreinstalledAssets/com_apple_MobileAsset_CoreSuggestionsQPAssets.xml" error:0];
}

uint64_t mobileassetd_main(uint64_t a1, uint64_t a2, void *a3)
{
  id v3 = a3;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"built-in"]);
  unsigned int v5 = [v4 BOOLValue];

  uint64_t v6 = objc_autoreleasePoolPush();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"MobileAssetProperties"]);
  uint64_t v8 = (__CFString *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"Build"]);

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"mobileassetd-trainname"]);
  if (v5)
  {
    id v10 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Starting built-in MobileAsset brain built Nov 10 2024 02:43:46"));
    id v11 = [v10 UTF8String];
    _MobileAssetLog(0LL, 6, (uint64_t)"mobileassetd_main", @"[MAB] %s", v12, v13, v14, v15, (uint64_t)v11);

    uint64_t v16 = v8;
    uint64_t v8 = @"BuiltIn";
  }

  else
  {
    uint64_t v16 = (__CFString *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Starting downloaded MobileAsset brain (version: %@) built Nov 10 2024 02:43:46", v8));
    id v17 = -[__CFString UTF8String](v16, "UTF8String");
    _MobileAssetLog(0LL, 6, (uint64_t)"mobileassetd_main", @"[MAB] %s", v18, v19, v20, v21, (uint64_t)v17);
  }

  cleanUpLegacyItems();
  else {
    id v26 = @"Unable to set temp directory";
  }
  _MobileAssetLog(0LL, 5, (uint64_t)"mobileassetd_main", v26, v22, v23, v24, v25, v65);
  MABrainLoadFeaturesOverrides();
  id v27 = getControlManager();
  id v28 = getDownloadManager();
  id ControlManager = getControlManager();
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(ControlManager);
  [v30 registerForCacheDeleteMigration];

  id DownloadManager = getDownloadManager();
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(DownloadManager);
  [v32 setBrainVersion:v8];

  if (v9 && (uint64_t v37 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v9, v37) & 1) != 0))
  {
    _MobileAssetLog( 0LL,  5,  (uint64_t)"mobileassetd_main",  @"Setting train name on DownloadManger to %@",  v33,  v34,  v35,  v36,  (uint64_t)v9);
    id v38 = getDownloadManager();
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
    [v39 setTrainName:v9];
  }

  else
  {
    _MobileAssetLog( 0LL,  5,  (uint64_t)"mobileassetd_main",  @"Train name not passed in via options",  v33,  v34,  v35,  v36,  v66);
  }

  id v40 = getDownloadManager();
  id v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
  [v41 triggerVPN];

  id v42 =  +[MADAutoAssetControlManager autoControlManager]( &OBJC_CLASS___MADAutoAssetControlManager,  "autoControlManager");
  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"allow-st-extractor-plugin"]);

  if (v43)
  {
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"allow-st-extractor-plugin"]);
    id v45 = [v44 BOOLValue];
    id v46 = getControlManager();
    SecKeyRef v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
    [v47 setAllowSTExtractorPluginLoadFromDownloadedMABrain:v45];
  }

  if ((usingCentralizedCachedelete() & 1) == 0) {
    CacheDeleteRegisterInfoCallbacks( @"com.apple.mobileassetd.cache-delete",  &__block_literal_global_20,  &__block_literal_global_643,  0LL,  0LL);
  }
  uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(+[MABrainRestartManager sharedInstance](&OBJC_CLASS___MABrainRestartManager, "sharedInstance"));
  [v48 setupSignalHandlers];

  dispatch_queue_attr_t v49 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v50 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v49);
  uint64_t v51 = dispatch_queue_create("com.apple.MobileAsset.memoryPressureMonitor", v50);

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = __setupMemoryPressureMonitor_block_invoke;
  handler[3] = &unk_34DBC0;
  dispatch_source_t v70 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_memorypressure, 0LL, 0x37uLL, v51);
  uint64_t v52 = v70;
  dispatch_source_set_event_handler(v52, handler);
  dispatch_resume(v52);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"setupMemoryPressureMonitor",  @"{setupMemoryPressureMonitor} monitoring for memory pressure indications",  v53,  v54,  v55,  v56,  v67);

  if (objc_opt_class(&OBJC_CLASS___APSConnection))
  {
    LOBYTE(handler[0]) = 0;
    if (_MAPreferencesGetAppBooleanValue(@"DisableAutomaticPushNotificationSubscription", handler)
      && LOBYTE(handler[0]))
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"mobileassetd_main",  @"Automatically subscribing to cloud channels disabled",  v57,  v58,  v59,  v60,  v68);
    }

    else
    {
      id v61 = (void *)objc_claimAutoreleasedReturnValue( +[MAPushNotificationServiceDaemon sharedInstance]( &OBJC_CLASS___MAPushNotificationServiceDaemon,  "sharedInstance"));
      [v61 subscribeToChannelForCurrentPlatform];
    }

    uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue( +[MAPushNotificationServiceDaemon sharedInstance]( &OBJC_CLASS___MAPushNotificationServiceDaemon,  "sharedInstance"));
    [v62 startListeningForConnections];
  }

  id v63 = (void *)objc_claimAutoreleasedReturnValue(+[MABrainUpdater sharedInstance](&OBJC_CLASS___MABrainUpdater, "sharedInstance"));
  [v63 start:v3];

  objc_autoreleasePoolPop(v6);
  CFRunLoopRun();

  return 0LL;
}

__CFDictionary *__cdecl __mobileassetd_main_block_invoke(id a1, int a2, __CFDictionary *a3)
{
  uint64_t v4 = *(void *)&a2;
  unsigned int v5 = objc_autoreleasePoolPush();
  uint64_t v6 = a3;
  id v7 = (id)objc_claimAutoreleasedReturnValue( -[__CFDictionary objectForKeyedSubscript:]( v6,  "objectForKeyedSubscript:",  @"CACHE_DELETE_VOLUME"));
  uint64_t v31 = 0LL;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2020000000LL;
  uint64_t v34 = 0LL;
  uint64_t v8 = (void *)os_transaction_create("com.apple.MobileAsset.handleCacheDeletePurgeableCallback");
  dispatch_semaphore_t v9 = dispatch_semaphore_create(0LL);
  id WorkQueue = _MobileAssetGetWorkQueue();
  id v11 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(WorkQueue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __handleCacheDeletePurgeableCallbackForVolume_block_invoke;
  block[3] = &unk_34F688;
  int v30 = v4;
  id v12 = v7;
  id v27 = v12;
  uint64_t v29 = &v31;
  uint64_t v13 = v9;
  id v28 = v13;
  dispatch_async(v11, block);

  dispatch_semaphore_wait(v13, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v14 = stringForCacheDeleteUrgency(v4);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  uint64_t v16 = allocStringForBytes(v32[3]);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"handleCacheDeletePurgeableCallbackForVolume",  @"[GARBAGE_COLLECTION] {handleCacheDeletePurgeableCallbackForVolume} determining reclaimable space | urgency:%d(%@), volume:%@ | ...respondToCacheDelete | reclaimable:%@",  v18,  v19,  v20,  v21,  v4);

  uint64_t v22 = v32[3];
  _Block_object_dispose(&v31, 8);

  v35[0] = @"CACHE_DELETE_VOLUME";
  v35[1] = @"CACHE_DELETE_AMOUNT";
  v36[0] = v12;
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v22));
  v36[1] = v23;
  uint64_t v24 = (__CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v36,  v35,  2LL));

  objc_autoreleasePoolPop(v5);
  return v24;
}

void sub_157530( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

__CFDictionary *__cdecl __mobileassetd_main_block_invoke_2(id a1, int a2, __CFDictionary *a3)
{
  uint64_t v4 = *(void *)&a2;
  context = objc_autoreleasePoolPush();
  unsigned int v5 = a3;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( -[__CFDictionary objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"CACHE_DELETE_VOLUME"));
  id v7 = (void *)objc_claimAutoreleasedReturnValue( -[__CFDictionary objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"CACHE_DELETE_AMOUNT"));
  id v8 = [v7 longLongValue];
  id v9 = v6;
  uint64_t v37 = 0LL;
  id v38 = &v37;
  uint64_t v39 = 0x2020000000LL;
  uint64_t v40 = 0LL;
  id v10 = (void *)os_transaction_create("com.apple.MobileAsset.handleCacheDeletePurgeCallback");
  dispatch_semaphore_t v11 = dispatch_semaphore_create(0LL);
  id WorkQueue = _MobileAssetGetWorkQueue();
  uint64_t v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(WorkQueue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __handleCacheDeletePurgeCallbackForVolume_block_invoke;
  block[3] = &unk_34F6B0;
  int v36 = v4;
  id v14 = v9;
  id v32 = v14;
  uint64_t v34 = &v37;
  id v35 = v8;
  uint64_t v15 = v11;
  uint64_t v33 = v15;
  dispatch_async(v13, block);

  dispatch_semaphore_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v16 = stringForCacheDeleteUrgency(v4);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = allocStringForBytes((uint64_t)v8);
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = allocStringForBytes(v38[3]);
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v20);
  _MobileAssetLog( 0LL,  6,  (uint64_t)"handleCacheDeletePurgeCallbackForVolume",  @"[GARBAGE_COLLECTION] {handleCacheDeletePurgeCallbackForVolume} reclaiming space | urgency:%d(%@), volume:%@, targeting:%@ | ...respondToCacheDelete | reclaimed:%@",  v21,  v22,  v23,  v24,  v4);

  uint64_t v25 = v38[3];
  _Block_object_dispose(&v37, 8);

  v41[1] = @"CACHE_DELETE_AMOUNT";
  v42[0] = v14;
  v41[0] = @"CACHE_DELETE_VOLUME";
  id v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v25));
  v42[1] = v26;
  id v27 = (__CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v42,  v41,  2LL));

  objc_autoreleasePoolPop(context);
  return v27;
}

void sub_1577D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void __handleCacheDeletePurgeableCallbackForVolume_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 56);
  id v3 = stringForCacheDeleteUrgency(*(_DWORD *)(a1 + 56));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"handleCacheDeletePurgeableCallbackForVolume_block_invoke",  @"[GARBAGE_COLLECTION] {handleCacheDeletePurgeableCallbackForVolume} determining reclaimable space | urgency:%d(%@), volume:%@ | respondToCacheDelete...",  v5,  v6,  v7,  v8,  v2);

  id ControlManager = getControlManager();
  id v10 = (void *)objc_claimAutoreleasedReturnValue(ControlManager);
  dispatch_semaphore_t v11 = objc_alloc_init(&OBJC_CLASS___MADAnalyticsCacheDeleteResults);
  uint64_t v12 = *(unsigned int *)(a1 + 56);
  uint64_t v13 = *(void *)(a1 + 32);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = __handleCacheDeletePurgeableCallbackForVolume_block_invoke_2;
  v16[3] = &unk_34F660;
  __int128 v15 = *(_OWORD *)(a1 + 40);
  id v14 = (id)v15;
  __int128 v17 = v15;
  [v10 respondToCacheDelete:0 targetingPurgeAmount:0 cacheDeleteResults:v11 withUrgency:v12 forVolume:v13 then:v16];
}

uint64_t __handleCacheDeletePurgeableCallbackForVolume_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __handleCacheDeletePurgeCallbackForVolume_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 64);
  id v3 = stringForCacheDeleteUrgency(*(_DWORD *)(a1 + 64));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  uint64_t v5 = allocStringForBytes(*(void *)(a1 + 56));
  __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(v5);
  _MobileAssetLog( 0LL,  5,  (uint64_t)"handleCacheDeletePurgeCallbackForVolume_block_invoke",  @"[GARBAGE_COLLECTION] {handleCacheDeletePurgeCallbackForVolume} reclaiming space | urgency:%d(%@), volume:%@, targeting:%@ | respondToCacheDelete...",  v6,  v7,  v8,  v9,  v2);

  id ControlManager = getControlManager();
  dispatch_semaphore_t v11 = (void *)objc_claimAutoreleasedReturnValue(ControlManager);
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v13 = objc_alloc_init(&OBJC_CLASS___MADAnalyticsCacheDeleteResults);
  uint64_t v14 = *(unsigned int *)(a1 + 64);
  uint64_t v15 = *(void *)(a1 + 32);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472LL;
  v19[2] = __handleCacheDeletePurgeCallbackForVolume_block_invoke_2;
  v19[3] = &unk_34F660;
  __int128 v18 = *(_OWORD *)(a1 + 40);
  id v16 = (id)v18;
  __int128 v20 = v18;
  [v11 respondToCacheDelete:1 targetingPurgeAmount:v12 cacheDeleteResults:v13 withUrgency:v14 forVolume:v15 then:v19];
}

uint64_t __handleCacheDeletePurgeCallbackForVolume_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id _targetPath(uint64_t a1)
{
  id v1 = (void *)objc_claimAutoreleasedReturnValue( [@"/private/var/MobileSoftwareUpdate/MobileAsset/MobileAssetBrain" stringByAppendingPathComponent:a1]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned int v3 = [v2 fileExistsAtPath:v1];

  if (!v3)
  {
    id v7 = 0LL;
    uint64_t v4 = 0LL;
    goto LABEL_5;
  }

  id v29 = 0LL;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithContentsOfFile:encoding:error:]( &OBJC_CLASS___NSString,  "stringWithContentsOfFile:encoding:error:",  v1,  4LL,  &v29));
  id v5 = v29;
  if (v5)
  {
    uint64_t v6 = v5;
    id v7 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Error loading contents of %@: %@", v1, v5));
    id v8 = [v7 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"_targetPath", @"[MAB] %s", v9, v10, v11, v12, (uint64_t)v8);
LABEL_14:

    id v7 = 0LL;
    goto LABEL_15;
  }

  if (![v4 length])
  {
    uint64_t v22 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Invalid target path at %@",  v1);
LABEL_12:
    id v7 = objc_claimAutoreleasedReturnValue(v22);
    id v23 = [v7 UTF8String];
    _MobileAssetLog(0LL, 7, (uint64_t)"_targetPath", @"[MAB] %s", v24, v25, v26, v27, (uint64_t)v23);
    goto LABEL_13;
  }

  uint64_t v13 = objc_claimAutoreleasedReturnValue( [@"/private/var/MobileSoftwareUpdate/MobileAsset/MobileAssetBrain" stringByAppendingPathComponent:v4]);
  if (!v13)
  {
    uint64_t v22 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Allocating targetPath failed for target %@",  v4);
    goto LABEL_12;
  }

  id v7 = (id)v13;
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned __int8 v15 = [v14 fileExistsAtPath:v7];

  if ((v15 & 1) == 0)
  {
    id v16 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@ does not exist", v7));
    id v17 = [v16 UTF8String];
    _MobileAssetLog(0LL, 7, (uint64_t)"_targetPath", @"[MAB] %s", v18, v19, v20, v21, (uint64_t)v17);

LABEL_13:
    uint64_t v6 = 0LL;
    goto LABEL_14;
  }

LABEL_98:
      objc_autoreleasePoolPop(v153);
      v122 = v242;
LABEL_101:

      objc_autoreleasePoolPop(context);
      if (v149 == 2)
      {
        v262 = 0;
        uint64_t v119 = v273;
        v269 = v252;
LABEL_116:
        uint64_t v20 = v256;
        uint64_t v13 = v257;
        uint64_t v10 = (uint64_t)v239;
        uint64_t v21 = v260;
        uint64_t v22 = (void *)v255;
        goto LABEL_68;
      }

      if (v269)
      {
LABEL_103:
        uint64_t v119 = v273;
        uint64_t v20 = v256;
        uint64_t v13 = v257;
        uint64_t v10 = (uint64_t)v239;
        uint64_t v21 = v260;
        uint64_t v22 = (void *)v255;
LABEL_104:
        v262 = 1;
        v269 = v252;
        goto LABEL_68;
      }

      v181 = AMAuthInstallUpdaterSaveToReceipt(v257, @"Cryptex1", v272, &v285);
      v269 = v285;
      if (v285)
      {

        v262 = 0;
        v285 = 0LL;
LABEL_115:
        uint64_t v119 = v273;
        goto LABEL_116;
      }

      if (!v181)
      {
        v292 = NSDebugDescriptionErrorKey;
        v189 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallUpdaterSaveToReceipt() failed"));
        v293 = v189;
        v192 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v293,  &v292,  1LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v192));

        goto LABEL_114;
      }

      if (!v268) {
        goto LABEL_103;
      }
      v324 = 0LL;
      v322 = 0u;
      v323 = 0u;
      v321 = 0u;
      v182 = img4_nonce_domain_copy_nonce(&_img4_nonce_domain_pdi, &v321);
      if ((_DWORD)v182)
      {
        v183 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Failed to copy the PDI MobileAssetBrain nonce: %d", v182));
        v184 = [v183 UTF8String];
        _MobileAssetLog( 0LL,  3,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v185,  v186,  v187,  v188,  (uint64_t)v184);

        v290[0] = NSDebugDescriptionErrorKey;
        v189 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to pre-roll the PDI MobileAssetBrain nonce"));
        v291[0] = v189;
        v290[1] = NSUnderlyingErrorKey;
        v190 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  (int)v182,  0LL));
        v291[1] = v190;
        v191 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v291,  v290,  2LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  108LL,  v191));

LABEL_114:
        v262 = 0;
        goto LABEL_115;
      }

      v193 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Successfully copied the Cryptex1 MobileAssetBrain PDI nonce."));
      v194 = [v193 UTF8String];
      _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v195,  v196,  v197,  v198,  (uint64_t)v194);

      v199 = objc_alloc(&OBJC_CLASS___NSData);
      v200 = -[NSData initWithBytes:length:](v199, "initWithBytes:length:", (char *)&v321 + 2, HIDWORD(v324));

      v201 = v200;
      v202 = AMAuthInstallUpdaterCryptex1SetInfo(v257, v271, v272, @"MobileAsset Brain", v263, v200, 0LL, &v285);
      v269 = v285;
      if (v285)
      {

        v262 = 0;
        v285 = 0LL;
LABEL_119:
        uint64_t v13 = v257;
LABEL_122:
        uint64_t v10 = (uint64_t)v239;
        uint64_t v22 = (void *)v255;
        uint64_t v20 = v256;
        uint64_t v21 = v260;
        uint64_t v119 = v201;
        goto LABEL_68;
      }

      if ((_DWORD)v202)
      {
        v288 = NSDebugDescriptionErrorKey;
        uint64_t v13 = v257;
        v203 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AMAuthInstallUpdaterCryptex1SetInfo() failed with error %d (%@)",  v202,  AMAuthInstallGetLocalizedStatusString(v257, v202));
        v204 = (void *)objc_claimAutoreleasedReturnValue(v203);
        v289 = v204;
        v205 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v289,  &v288,  1LL));
        v269 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"MobileAssetBrainErrorDomain",  102LL,  v205));

        v262 = 0;
        goto LABEL_122;
      }

      if (cf) {
        CFRelease(cf);
      }
      cf = (CFTypeRef)AMAuthInstallUpdaterPersonalize(v257, @"Cryptex1", v272, &v285);
      v269 = v285;
      if (v285)
      {

        v285 = 0LL;
        v206 = (void *)objc_claimAutoreleasedReturnValue([v269 domain]);
        if ([v206 isEqualToString:kAMAuthInstallErrorDomain])
        {
          v207 = (char *)[v269 code];

          if (v207 == (_BYTE *)&stru_C38.flags + 2 && (MABrainUtilityAllowUnpersonalizedBrain() & 1) != 0)
          {
            v208 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Proceeding on Tatsu authorization failure because unpersonalized brains are allowed: %@", v269));
            v209 = [v208 UTF8String];
            _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v210,  v211,  v212,  v213,  (uint64_t)v209);

            v252 = 0LL;
            goto LABEL_132;
          }
        }

        else
        {
        }

        v262 = 0;
        goto LABEL_119;
      }

      if (cf)
      {
        v269 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Successfully personalized 2nd brain ticket with current-boot-only PDI nonce"));
        v214 = [v269 UTF8String];
        _MobileAssetLog( 0LL,  6,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v215,  v216,  v217,  v218,  (uint64_t)v214);
LABEL_132:

        v219 = objc_autoreleasePoolPush();
        v220 = [(id)AMAuthInstallBundleGetManifestPath() stringByAppendingPathComponent:@"Cryptex1"];
        v221 = (void *)objc_claimAutoreleasedReturnValue(v220);
        v222 = (void *)objc_claimAutoreleasedReturnValue([v221 stringByAppendingPathComponent:kAMAuthInstallTagCryptex1Img4Ticket]);

        uint64_t v10 = (uint64_t)v239;
        v223 = (void *)objc_claimAutoreleasedReturnValue([v239 stringByAppendingPathComponent:v222]);
        v224 = MABrainUtilityBootSessionUUID();
        v225 = (void *)objc_claimAutoreleasedReturnValue(v224);
        v226 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"cryptex1ticket.%@.der",  v225));
        v227 = (void *)objc_claimAutoreleasedReturnValue([v270 stringByAppendingPathComponent:v226]);

        v228 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Attempting to copy Cryptex1 ticket for current boot from %@ to %@", v223, v227));
        v229 = [v228 UTF8String];
        _MobileAssetLog( 0LL,  7,  (uint64_t)"-[MABrainBundle personalize:options:error:]",  @"[MAB] %s",  v230,  v231,  v232,  v233,  (uint64_t)v229);

        v234 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
        v276 = v252;
        v274 = [v234 copyItemAtPath:v223 toPath:v227 error:&v276];
        v235 = v276;

        objc_autoreleasePoolPop(v219);
        v262 = 0;
        v269 = v235;
        v252 = v235;
        uint64_t v20 = v256;
        uint64_t v13 = v257;
        uint64_t v21 = v260;
        uint64_t v22 = (void *)v255;
        uint64_t v119 = v201;
        if (v274) {
          goto LABEL_104;
        }
LABEL_68:
        uint64_t v24 = v258;
        id v23 = (void *)v259;
        if (cf)
        {
          uint64_t v120 = v119;
          CFRelease(cf);
          v273 = v120;
        }

        else
        {
          v273 = v119;
        }

void _mabrainbundle_log(int a1, uint64_t a2)
{
  if (a1 >= 4)
  {
    if ((a1 - 4) >= 3)
    {
      id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s", a2));
      id v6 = [v13 UTF8String];
      if (a1 >= 7)
      {
        _MobileAssetLog(0LL, 7, (uint64_t)"_mabrainbundle_log", @"[MAB] %s", v7, v8, v9, v10, (uint64_t)v6);
        goto LABEL_6;
      }
    }

    else
    {
      id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s", a2));
      id v6 = [v13 UTF8String];
    }

    _MobileAssetLog(0LL, 6, (uint64_t)"_mabrainbundle_log", @"[MAB] %s", v7, v8, v9, v10, (uint64_t)v6);
  }

  else
  {
    id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s", a2));
    id v12 = [v13 UTF8String];
    _MobileAssetLog(0LL, 3, (uint64_t)"_mabrainbundle_log", @"[MAB] %s", v2, v3, v4, v5, (uint64_t)v12);
  }

void ___cryptex1_product_class_block_invoke_0(id a1)
{
  int v1 = img4_chip_instantiate();
  if (v1) {
    _os_assumes_log(v1);
  }
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"0x%lX", 0LL));
  uint64_t v3 = (void *)_cryptex1_product_class_productClass_0;
  _cryptex1_product_class_productClass_0 = v2;
}

#error "16247C: too big function (funcsize=0)"
int64_t __cdecl -[MADAutoAssetJob performAction:onEvent:inState:withInfo:nextState:error:]( MADAutoAssetJob *self,  SEL a2,  id a3,  id a4,  id a5,  id a6,  id a7,  id *a8)
{
  id v11;
  id v12;
  int64_t v13;
  int64_t v14;
  uint64_t v11 = a3;
  id v12 = a6;
  if (([v11 isEqualToString:kSUCoreFSMActionNoOp] & 1) == 0)
  {
    if ([v11 isEqualToString:@"AddTaskDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddTaskDecideFilesystem:error:]( self,  "action_AddTaskDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddTaskSchedulerDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddTaskSchedulerDecideFilesystem:error:]( self,  "action_AddTaskSchedulerDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddTaskCheckDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddTaskCheckDecideFilesystem:error:]( self,  "action_AddTaskCheckDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddTaskDetermineDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddTaskDetermineDecideFilesystem:error:]( self,  "action_AddTaskDetermineDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddTaskInterestDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddTaskInterestDecideFilesystem:error:]( self,  "action_AddTaskInterestDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddTaskLockDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddTaskLockDecideFilesystem:error:]( self,  "action_AddTaskLockDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"StagerDetermineDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_StagerDetermineDecideFilesystem:error:]( self,  "action_StagerDetermineDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"StagerDownloadDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_StagerDownloadDecideFilesystem:error:]( self,  "action_StagerDownloadDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"DecideStartupDownloading"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_DecideStartupDownloading:error:]( self,  "action_DecideStartupDownloading:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"DecideDonePurging"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_DecideDonePurging:error:](self, "action_DecideDonePurging:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"AddAtomicAlterDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddAtomicAlterDecideFilesystem:error:]( self,  "action_AddAtomicAlterDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddAtomicNeedDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddAtomicNeedDecideFilesystem:error:]( self,  "action_AddAtomicNeedDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddAtomicCheckDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddAtomicCheckDecideFilesystem:error:]( self,  "action_AddAtomicCheckDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddAtomicLockDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddAtomicLockDecideFilesystem:error:]( self,  "action_AddAtomicLockDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddAtomicContinueDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddAtomicContinueDecideFilesystem:error:]( self,  "action_AddAtomicContinueDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"AddAtomicEndDecideFilesystem"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_AddAtomicEndDecideFilesystem:error:]( self,  "action_AddAtomicEndDecideFilesystem:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicAlterNeeds"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicAlterNeeds:error:](self, "action_MergeAtomicAlterNeeds:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicNeeds"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicNeeds:error:](self, "action_MergeAtomicNeeds:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicAddLock"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicAddLock:error:](self, "action_MergeAtomicAddLock:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicContinueLock"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicContinueLock:error:]( self,  "action_MergeAtomicContinueLock:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicEndLockDecideInterest"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicEndLockDecideInterest:error:]( self,  "action_MergeAtomicEndLockDecideInterest:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicAlterDecideLookup"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicAlterDecideLookup:error:]( self,  "action_MergeAtomicAlterDecideLookup:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicNeedsDecideLookup"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicNeedsDecideLookup:error:]( self,  "action_MergeAtomicNeedsDecideLookup:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicAlterDecideLookupBoost"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicAlterDecideLookupBoost:error:]( self,  "action_MergeAtomicAlterDecideLookupBoost:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicNeedsDecideLookupBoost"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicNeedsDecideLookupBoost:error:]( self,  "action_MergeAtomicNeedsDecideLookupBoost:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicLockDecideLookupBoost"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicLockDecideLookupBoost:error:]( self,  "action_MergeAtomicLockDecideLookupBoost:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"MergeAtomicCntnuDecideLookupBoost"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_MergeAtomicCntnuDecideLookupBoost:error:]( self,  "action_MergeAtomicCntnuDecideLookupBoost:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"SetCalculateDownloadSpace"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetCalculateDownloadSpace:error:]( self,  "action_SetCalculateDownloadSpace:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"SetDecideDownload"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetDecideDownload:error:](self, "action_SetDecideDownload:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"SetDoneDetermine"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetDoneDetermine:error:](self, "action_SetDoneDetermine:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"SetLookupSuccessContinue"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetLookupSuccessContinue:error:]( self,  "action_SetLookupSuccessContinue:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"SetLookupNoneContinue"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetLookupNoneContinue:error:](self, "action_SetLookupNoneContinue:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"SetLookupNoNewerContinue"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetLookupNoNewerContinue:error:]( self,  "action_SetLookupNoNewerContinue:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"SetJobNoneSchedule"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetJobNoneSchedule:error:](self, "action_SetJobNoneSchedule:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"SetJobNoNewerSchedule"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetJobNoNewerSchedule:error:](self, "action_SetJobNoNewerSchedule:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"SetJobFailedSchedule"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetJobFailedSchedule:error:](self, "action_SetJobFailedSchedule:error:", v12, a8);
    }

    else if ([v11 isEqualToString:@"SetJobLookupRevokedContinue"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetJobLookupRevokedContinue:error:]( self,  "action_SetJobLookupRevokedContinue:error:",  v12,  a8);
    }

    else if ([v11 isEqualToString:@"SetJobHealPersonalizeNext"])
    {
      uint64_t v14 = -[MADAutoAssetJob action_SetJobHealPersonalizeNext:error:]( self,  "action_SetJobHealPersonalizeNext:error:",  v12,  a8);
    }

    else
    {
      if (![v11 isEqualToString:@"SetDownloadNewestFull"])
      {
        if ([v11 isEqualToString:@"SetDownloadNext"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetDownloadNext:error:](self, "action_SetDownloadNext:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetDownloadSameFull"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetDownloadSameFull:error:](self, "action_SetDownloadSameFull:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"UserInitiatedSetDownloadNext"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_UserInitiatedSetDownloadNext:error:]( self,  "action_UserInitiatedSetDownloadNext:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"ReportFailBoostSetDownloadNext"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_ReportFailBoostSetDownloadNext:error:]( self,  "action_ReportFailBoostSetDownloadNext:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetJobSuccessSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetJobSuccessSchedule:error:]( self,  "action_SetJobSuccessSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetJobSuccessFoundSameSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetJobSuccessFoundSameSchedule:error:]( self,  "action_SetJobSuccessFoundSameSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetJobSuccessFoundPromoted"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetJobSuccessFoundPromoted:error:]( self,  "action_SetJobSuccessFoundPromoted:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetJobSuccessAwaiting"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetJobSuccessAwaiting:error:]( self,  "action_SetJobSuccessAwaiting:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetJobFailedAwaiting"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetJobFailedAwaiting:error:]( self,  "action_SetJobFailedAwaiting:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SetJobTryPersonalizeHeal"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SetJobTryPersonalizeHeal:error:]( self,  "action_SetJobTryPersonalizeHeal:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"AddTaskScheduler"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_AddTaskScheduler:error:](self, "action_AddTaskScheduler:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeNeeds"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeNeeds:error:](self, "action_MergeNeeds:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeNeedsDecideLookup"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeNeedsDecideLookup:error:]( self,  "action_MergeNeedsDecideLookup:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeNeedsDecideBoost"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeNeedsDecideBoost:error:]( self,  "action_MergeNeedsDecideBoost:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeNeedsDecideLookupBoost"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeNeedsDecideLookupBoost:error:]( self,  "action_MergeNeedsDecideLookupBoost:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeAddLock"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeAddLock:error:](self, "action_MergeAddLock:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeContinueLock"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeContinueLock:error:](self, "action_MergeContinueLock:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeRemoveLock"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeRemoveLock:error:](self, "action_MergeRemoveLock:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeRemoveLockDecideInterest"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeRemoveLockDecideInterest:error:]( self,  "action_MergeRemoveLockDecideInterest:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeAddLockDecideBoost"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeAddLockDecideBoost:error:]( self,  "action_MergeAddLockDecideBoost:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"MergeContinueLockDecideBoost"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_MergeContinueLockDecideBoost:error:]( self,  "action_MergeContinueLockDecideBoost:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"AdoptRegister"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_AdoptRegister:error:](self, "action_AdoptRegister:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"RequestLookupGrant"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_RequestLookupGrant:error:](self, "action_RequestLookupGrant:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"DownloadCatalog"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_DownloadCatalog:error:](self, "action_DownloadCatalog:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"RemoveClient"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_RemoveClient:error:](self, "action_RemoveClient:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"RemoveClientDecideInterest"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_RemoveClientDecideInterest:error:]( self,  "action_RemoveClientDecideInterest:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"ReportCatalogDecideFound"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_ReportCatalogDecideFound:error:]( self,  "action_ReportCatalogDecideFound:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"DecideDownloadOrPostpone"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_DecideDownloadOrPostpone:error:]( self,  "action_DecideDownloadOrPostpone:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"RequestSpecificPersisted"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_RequestSpecificPersisted:error:]( self,  "action_RequestSpecificPersisted:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"PersistedDecideDownload"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_PersistedDecideDownload:error:]( self,  "action_PersistedDecideDownload:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"DownloadNewestPatch"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_DownloadNewestPatch:error:](self, "action_DownloadNewestPatch:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"DownloadNewestFull"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_DownloadNewestFull:error:](self, "action_DownloadNewestFull:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"UserInitiatedDownloadNewestFull"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_UserInitiatedDownloadNewestFull:error:]( self,  "action_UserInitiatedDownloadNewestFull:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"DownloadSuccessDecideMore"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_DownloadSuccessDecideMore:error:]( self,  "action_DownloadSuccessDecideMore:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"FailedPatchDecideTryFull"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_FailedPatchDecideTryFull:error:]( self,  "action_FailedPatchDecideTryFull:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"BoostToUserInitiated"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_BoostToUserInitiated:error:]( self,  "action_BoostToUserInitiated:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"BoostAndRequestLookupGrant"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_BoostAndRequestLookupGrant:error:]( self,  "action_BoostAndRequestLookupGrant:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"NowUserInitiated"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_NowUserInitiated:error:](self, "action_NowUserInitiated:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"ReportFailureUserInitiated"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_ReportFailureUserInitiated:error:]( self,  "action_ReportFailureUserInitiated:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"DownloadSuccessDecidePersonalize"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_DownloadSuccessDecidePersonalize:error:]( self,  "action_DownloadSuccessDecidePersonalize:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"SecureBundlePersonalize"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_SecureBundlePersonalize:error:]( self,  "action_SecureBundlePersonalize:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"PersonalizeSuccessDecideMore"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_PersonalizeSuccessDecideMore:error:]( self,  "action_PersonalizeSuccessDecideMore:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"PersonalizeFailureDecideMore"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_PersonalizeFailureDecideMore:error:]( self,  "action_PersonalizeFailureDecideMore:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"PersonalizeHealSuccessDecideMore"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_PersonalizeHealSuccessDecideMore:error:]( self,  "action_PersonalizeHealSuccessDecideMore:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"PersonalizeHealFailureDecideMore"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_PersonalizeHealFailureDecideMore:error:]( self,  "action_PersonalizeHealFailureDecideMore:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"LookupSuccessContinue"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_LookupSuccessContinue:error:]( self,  "action_LookupSuccessContinue:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"LookupNoNewerContinue"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_LookupNoNewerContinue:error:]( self,  "action_LookupNoNewerContinue:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"LookupRevokedContinue"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_LookupRevokedContinue:error:]( self,  "action_LookupRevokedContinue:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"LookupFailedContinue"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_LookupFailedContinue:error:]( self,  "action_LookupFailedContinue:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessPatchedAwaiting"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessPatchedAwaiting:error:]( self,  "action_JobSuccessPatchedAwaiting:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessDownloadedAwaiting"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessDownloadedAwaiting:error:]( self,  "action_JobSuccessDownloadedAwaiting:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessFoundSameSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessFoundSameSchedule:error:]( self,  "action_JobSuccessFoundSameSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessFoundPromoted"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessFoundPromoted:error:]( self,  "action_JobSuccessFoundPromoted:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessPatchedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessPatchedSchedule:error:]( self,  "action_JobSuccessPatchedSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessDownloadedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessDownloadedSchedule:error:]( self,  "action_JobSuccessDownloadedSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessAlreadyDownloaded"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessAlreadyDownloaded:error:]( self,  "action_JobSuccessAlreadyDownloaded:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobSuccessPersonalized"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobSuccessPersonalized:error:]( self,  "action_JobSuccessPersonalized:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobNoNewerSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobNoNewerSchedule:error:](self, "action_JobNoNewerSchedule:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobRevokedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobRevokedSchedule:error:](self, "action_JobRevokedSchedule:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobFailedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobFailedSchedule:error:](self, "action_JobFailedSchedule:error:", v12, a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"ReleaseGrantJobFailedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_ReleaseGrantJobFailedSchedule:error:]( self,  "action_ReleaseGrantJobFailedSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobPostponedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobPostponedSchedule:error:]( self,  "action_JobPostponedSchedule:error:",  v12,  a8);
          goto LABEL_229;
        }

        if ([v11 isEqualToString:@"JobEndedSchedule"])
        {
          uint64_t v14 = -[MADAutoAssetJob action_JobEndedSchedule:error:](self, "action_JobEndedSchedule:error:", v12, a8);
          goto LABEL_229;
        }

        if (![v11 isEqualToString:@"SetDownloadNewestFull"])
        {
          if ([v11 isEqualToString:@"SetJobEndedSchedule"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_SetJobEndedSchedule:error:]( self,  "action_SetJobEndedSchedule:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"RecordSimulateOperation"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_RecordSimulateOperation:error:]( self,  "action_RecordSimulateOperation:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"CheckSimulateEndStatusRequest"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_CheckSimulateEndStatusRequest:error:]( self,  "action_CheckSimulateEndStatusRequest:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"SimulateSuspendCatalogLookupIssue"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_SimulateSuspendCatalogLookupIssue:error:]( self,  "action_SimulateSuspendCatalogLookupIssue:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"CancelAssetDownload"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_CancelAssetDownload:error:]( self,  "action_CancelAssetDownload:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"ReleaseGrantCanceling"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_ReleaseGrantCanceling:error:]( self,  "action_ReleaseGrantCanceling:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"FailRequestCanceling"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_FailRequestCanceling:error:]( self,  "action_FailRequestCanceling:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"JobFailedCanceled"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_JobFailedCanceled:error:](self, "action_JobFailedCanceled:error:", v12, a8);
          }

          else if ([v11 isEqualToString:@"ReleaseGrantJobFailedCanceled"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_ReleaseGrantJobFailedCanceled:error:]( self,  "action_ReleaseGrantJobFailedCanceled:error:",  v12,  a8);
          }

          else if ([v11 isEqualToString:@"DoneReportingProgress"])
          {
            uint64_t v14 = -[MADAutoAssetJob action_DoneReportingProgress:error:]( self,  "action_DoneReportingProgress:error:",  v12,  a8);
          }

          else
          {
            uint64_t v14 = -[MADAutoAssetJob actionUnknownAction:error:](self, "actionUnknownAction:error:", v11, a8);
          }

          goto LABEL_229;
        }
      }

      uint64_t v14 = -[MADAutoAssetJob action_SetDownloadNewestFull:error:](self, "action_SetDownloadNewestFull:error:", v12, a8);
    }

LABEL_229:
    id v13 = v14;
    goto LABEL_230;
  }

  id v13 = 0LL;
LABEL_230:

  return v13;
}

LABEL_117:
  v136 = (void *)*((void *)&v189 + 1);
  if (!*((void *)&v189 + 1)) {
    v136 = (void *)v189;
  }
  v137 = objc_claimAutoreleasedReturnValue([v136 assetVersion]);
  v198 = 0;
  v138 = objc_alloc(&OBJC_CLASS___MAAutoAssetSelector);
  v139 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  v140 = (void *)objc_claimAutoreleasedReturnValue([v139 assetType]);
  v141 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  v142 = (void *)objc_claimAutoreleasedReturnValue([v141 assetSpecifier]);
  v143 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](self, "autoAssetSelector"));
  v144 = (void *)objc_claimAutoreleasedReturnValue([v143 downloadDecryptionKey]);
  v197 = (void *)v137;
  v145 = -[MAAutoAssetSelector initForAssetType:withAssetSpecifier:matchingAssetVersion:usingDecryptionKey:]( v138,  "initForAssetType:withAssetSpecifier:matchingAssetVersion:usingDecryptionKey:",  v140,  v142,  v137,  v144);
  -[MADAutoAssetJob setResultSelector:](v191, "setResultSelector:", v145);

  v146 = objc_alloc(&OBJC_CLASS___MAAutoAssetInfoInstance);
  obja = (id)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob activeInstance](v191, "activeInstance"));
  v147 = (void *)objc_claimAutoreleasedReturnValue([obja autoAssetClientName]);
  v148 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob activeInstance](v191, "activeInstance"));
  v149 = (void *)objc_claimAutoreleasedReturnValue([v148 clientProcessName]);
  v150 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob activeInstance](v191, "activeInstance"));
  v151 = [v150 clientProcessID];
  v152 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob resultSelector](v191, "resultSelector"));
  v153 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob activeInstance](v191, "activeInstance"));
  v154 = (void *)objc_claimAutoreleasedReturnValue([v153 frameworkInstanceUUID]);
  v155 = v151;
  self = v191;
  v156 = -[MAAutoAssetInfoInstance initForClientName:withProcessName:withProcessID:usingAssetSelector:associatingFrameworkUUID:]( v146,  "initForClientName:withProcessName:withProcessID:usingAssetSelector:associatingFrameworkUUID:",  v147,  v149,  v155,  v152,  v154);
  -[MADAutoAssetJob setResultInstance:](v191, "setResultInstance:", v156);

  -[MADAutoAssetJob setFoundNewerPatch:](v191, "setFoundNewerPatch:", (void)v189);
  v157 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerPatch](v191, "foundNewerPatch"));

  uint64_t v5 = v187;
  id v17 = v192;
  if (v157)
  {
    v158 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](v191, "autoAssetSelector"));
    v159 = (void *)objc_claimAutoreleasedReturnValue([v158 assetVersion]);

    if (!v159)
    {
      v160 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerPatch](v191, "foundNewerPatch"));
      [v160 setFoundByLookupWithoutAssetVersion:1];
    }

    v161 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerPatch](v191, "foundNewerPatch"));
    [v161 setIsPatch:1];

    v162 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](v191, "logger"));
    v163 = (os_log_s *)objc_claimAutoreleasedReturnValue([v162 oslog]);

    if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
    {
      v164 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](v191, "autoJobName"));
      v165 = (void *)objc_claimAutoreleasedReturnValue([(id)v189 summary]);
      *(_DWORD *)buf = 138543618;
      v205 = v164;
      v206 = 2114;
      v207 = v165;
      _os_log_impl( &dword_0,  v163,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {ReportCatalogDecideFound} found newer patch | descriptor:%{public}@",  buf,  0x16u);
    }
  }

  -[MADAutoAssetJob setFoundNewerFull:](v191, "setFoundNewerFull:", *((void *)&v189 + 1));
  v166 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](v191, "foundNewerFull"));

  if (v166)
  {
    v167 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](v191, "autoAssetSelector"));
    v168 = (void *)objc_claimAutoreleasedReturnValue([v167 assetVersion]);

    if (!v168)
    {
      v169 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](v191, "foundNewerFull"));
      [v169 setFoundByLookupWithoutAssetVersion:1];
    }

    v170 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob foundNewerFull](v191, "foundNewerFull"));
    [v170 setIsPatch:0];

    v171 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob logger](v191, "logger"));
    v172 = (os_log_s *)objc_claimAutoreleasedReturnValue([v171 oslog]);

    if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
    {
      v173 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobName](v191, "autoJobName"));
      v174 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v189 + 1) summary]);
      *(_DWORD *)buf = 138543618;
      v205 = v173;
      v206 = 2114;
      v207 = v174;
      _os_log_impl( &dword_0,  v172,  OS_LOG_TYPE_DEFAULT,  "%{public}@ | {ReportCatalogDecideFound} found newer full | descriptor:%{public}@",  buf,  0x16u);
    }
  }

  -[MADAutoAssetJob latchWhetherDownloadingUserInitiated](v191, "latchWhetherDownloadingUserInitiated");
  -[MADAutoAssetJob refreshFoundToManager](v191, "refreshFoundToManager");
  if (-[MADAutoAssetJob isFoundAlreadyOnFilesystem:](v191, "isFoundAlreadyOnFilesystem:", &v198))
  {
    if (v198)
    {
      -[MADAutoAssetJob statusChangeCatalogFoundNewer:]( v191,  "statusChangeCatalogFoundNewer:",  @"ReportCatalogDecideFound");
      v175 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob tryPersonalizeDescriptors](v191, "tryPersonalizeDescriptors"));
      v176 = [v175 count];

      if (v176) {
        uint64_t v10 = @"CatalogFoundPromotedHeal";
      }
      else {
        uint64_t v10 = @"CatalogFoundPromoted";
      }
    }

    else
    {
      -[MADAutoAssetJob statusChangeCatalogFoundSame:]( v191,  "statusChangeCatalogFoundSame:",  @"ReportCatalogDecideFound");
      uint64_t v10 = @"CatalogFoundSameDownloaded";
    }
  }

  else
  {
    -[MADAutoAssetJob statusChangeCatalogFoundNewer:]( v191,  "statusChangeCatalogFoundNewer:",  @"ReportCatalogDecideFound");
    uint64_t v10 = @"CatalogFoundNewer";
    if (!-[MADAutoAssetJob stagerJob](v191, "stagerJob"))
    {
      v177 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob resultSelector](v191, "resultSelector"));
      v178 = (void *)objc_claimAutoreleasedReturnValue( +[MADAutoAssetControlManager autoAssetJob:bondWithStagerDownloading:]( &OBJC_CLASS___MADAutoAssetControlManager,  "autoAssetJob:bondWithStagerDownloading:",  v191,  v177));
      -[MADAutoAssetJob setBondedWithJob:](v191, "setBondedWithJob:", v178);

      v179 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob bondedWithJob](v191, "bondedWithJob"));
      if (v179) {
        uint64_t v10 = @"CatalogFoundNoNewer";
      }
      uint64_t v14 = v186;
      v180 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](v191, "autoAssetSelector"));
      v181 = (void *)objc_claimAutoreleasedReturnValue([v180 assetType]);
      v182 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoAssetSelector](v191, "autoAssetSelector"));
      v183 = (void *)objc_claimAutoreleasedReturnValue([v182 assetSpecifier]);
      +[MADAutoAssetControlManager postNotificationName:forAssetType:forAssetSpecifier:fromModule:fromLocation:]( &OBJC_CLASS___MADAutoAssetControlManager,  "postNotificationName:forAssetType:forAssetSpecifier:fromModule:fromLocation:",  @"ASSET_VERSION_DISCOVERED",  v181,  v183,  @"AUTO-JOB",  @"ReportCatalogDecideFound");

      uint64_t v5 = v187;
    }
  }

LABEL_142:
LABEL_83:

LABEL_86:
  uint64_t v106 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob autoJobFSM](self, "autoJobFSM"));
  uint64_t v107 = objc_alloc(&OBJC_CLASS___MADAutoAssetJobParam);
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetJob _updateLatestSummary](self, "_updateLatestSummary"));
  uint64_t v109 = -[MADAutoAssetJobParam initWithSafeSummary:](v107, "initWithSafeSummary:", v108);
  [v106 followupEvent:v10 withInfo:v109];

LABEL_87:
  return 0LL;
}

id OUTLINED_FUNCTION_15_0()
{
  return [v0 simulateEnd];
}

uint64_t OUTLINED_FUNCTION_16_1()
{
  return v0;
}

  ;
}

uint64_t makeDataVaultAtUrl(void *a1, void *a2)
{
  id v3 = a1;
  id v11 = a2;
  if (!v3)
  {
    uint64_t v37 = @"cannot make data vault as asset type is nil";
LABEL_10:
    _MobileAssetLog(0LL, 6, (uint64_t)"makeDataVaultAtUrl", v37, v7, v8, v9, v10, v49);
    uint64_t v38 = 32LL;
    goto LABEL_20;
  }

  id v12 = normalizedAssetType((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10);
  uint64_t v13 = objc_claimAutoreleasedReturnValue(v12);
  if (!v13)
  {
    uint64_t v37 = @"cannot make data vault as normalized asset type is nil";
    goto LABEL_10;
  }

  uint64_t v14 = (void *)v13;
  if (v11)
  {
    unsigned __int8 v15 = (void *)objc_claimAutoreleasedReturnValue([v11 path]);
    id v16 = ensureDirectory(v15);

    id v17 = (void *)objc_claimAutoreleasedReturnValue([v11 URLByAppendingPathComponent:v14]);
    id v18 = objc_claimAutoreleasedReturnValue([v17 path]);
    id v19 = [v18 UTF8String];
    id v20 = [v3 UTF8String];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    unsigned __int8 v22 = [v21 fileExistsAtPath:v18 isDirectory:0];

    if ((v22 & 1) != 0)
    {
      uint64_t v23 = rootless_check_datavault_flag(v19, v20);
      if ((_DWORD)v23)
      {
        uint64_t v28 = rootless_convert_to_datavault(v19, v20);
        if ((_DWORD)v28)
        {
          __error();
          _MobileAssetLog( 0LL,  6,  (uint64_t)"makeDataVaultAtUrl",  @"The attempt to make data vault failed, path: %s, errno: %lli",  v33,  v34,  v35,  v36,  (uint64_t)v19);
LABEL_14:

          uint64_t v38 = 32LL;
LABEL_19:
          id v11 = v17;
          goto LABEL_20;
        }

        _MobileAssetLog( v28,  6,  (uint64_t)"makeDataVaultAtUrl",  @"The attempt to make data vault succeeded, path: %s",  v29,  v30,  v31,  v32,  (uint64_t)v19);
      }

      else
      {
        _MobileAssetLog( v23,  6,  (uint64_t)"makeDataVaultAtUrl",  @"No need to convertpath: %s is already a datavault",  v24,  v25,  v26,  v27,  (uint64_t)v19);
      }
    }

    else
    {
      uint64_t v39 = rootless_mkdir_datavault(v19, 493LL, v20);
      if ((_DWORD)v39)
      {
        __error();
        _MobileAssetLog( 0LL,  6,  (uint64_t)"makeDataVaultAtUrl",  @"The attempt to create data vault failed, path: %s , mode: %o, errno: %lli",  v44,  v45,  v46,  v47,  (uint64_t)v19);
        goto LABEL_14;
      }

      _MobileAssetLog( v39,  6,  (uint64_t)"makeDataVaultAtUrl",  @"The attempt to create data vault succeeded, path: %s",  v40,  v41,  v42,  v43,  (uint64_t)v19);
    }

    uint64_t v38 = 0LL;
    goto LABEL_19;
  }

  _MobileAssetLog( 0LL,  6,  (uint64_t)"makeDataVaultAtUrl",  @"cannot make data vault as basePath is nil",  v7,  v8,  v9,  v10,  v49);
  uint64_t v38 = 32LL;
  id v11 = v14;
LABEL_20:

  return v38;
}

NSURL *ensureDirectory(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned __int8 v3 = [v2 fileExistsAtPath:v1];

  if ((v3 & 1) != 0)
  {
    id v4 = 0LL;
  }

  else
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v14 = 0LL;
    unsigned __int8 v6 = [v5 createDirectoryAtPath:v1 withIntermediateDirectories:1 attributes:0 error:&v14];
    id v4 = v14;

    if ((v6 & 1) == 0)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"ensureDirectory",  @"Could not create target folder: %@,   %@",  v7,  v8,  v9,  v10,  (uint64_t)v1);
      id v11 = 0LL;
      goto LABEL_7;
    }
  }

  id v11 = v1;
  if (!v11)
  {
LABEL_7:
    id v12 = 0LL;
    goto LABEL_8;
  }

  id v12 = -[NSURL initFileURLWithPath:](objc_alloc(&OBJC_CLASS___NSURL), "initFileURLWithPath:", v11);
LABEL_8:

  return v12;
}

id valueForKey(void *a1, const char *a2)
{
  unsigned __int8 v3 = (const char *)[a1 UTF8String];
  ssize_t v4 = getxattr(a2, v3, 0LL, 0LL, 0, 1);
  if (v4 < 0)
  {
    id v8 = 0LL;
  }

  else
  {
    size_t v5 = v4;
    id v6 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData, "dataWithLength:", v4));
    ssize_t v7 = getxattr(a2, v3, [v6 mutableBytes], v5, 0, 1);
    if (v7 < 0)
    {
      id v8 = 0LL;
    }

    else
    {
      [v6 setLength:v7];
      id v8 = v6;
    }
  }

  return v8;
}

BOOL setValue(void *a1, void *a2, const char *a3)
{
  id v5 = a1;
  id v6 = a2;
  ssize_t v7 = (const char *)[v6 UTF8String];
  id v8 = v5;
  int v9 = setxattr(a3, v7, [v8 bytes], (size_t)objc_msgSend(v8, "length"), 0, 1);
  if (v9)
  {
    __error();
    uint64_t v10 = __error();
    strerror(*v10);
    _MobileAssetLog( 0LL,  3,  (uint64_t)"setValue",  @"Failed to set xattr '%@'='%@' on path '%s' with errno %lld (%s)",  v11,  v12,  v13,  v14,  (uint64_t)v6);
  }

  return v9 == 0;
}

double getExistingClientUsage(void *a1, double *a2)
{
  id v3 = a1;
  ssize_t v4 = v3;
  double v5 = 0.0;
  if (!v3)
  {
    id v8 = 0LL;
    uint64_t v11 = 0LL;
    id v6 = 0LL;
    goto LABEL_14;
  }

  id v6 = (char *)[v3 fileSystemRepresentation];
  if (!v6)
  {
    id v8 = 0LL;
    uint64_t v11 = 0LL;
    goto LABEL_14;
  }

  if (a2)
  {
    id v7 = valueForKey(@"GCOverride", v6);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    if (v8)
    {
      id v9 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(&OBJC_CLASS___NSNumber),  v8,  0LL);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      uint64_t v11 = v10;
      if (v10) {
        *a2 = (double)(uint64_t)[v10 longLongValue];
      }
      goto LABEL_11;
    }
  }

  else
  {
    id v8 = 0LL;
  }

  uint64_t v11 = 0LL;
LABEL_11:
  id v12 = valueForKey(@"ClientUsage", v6);
  id v6 = (char *)objc_claimAutoreleasedReturnValue(v12);
  if (v6)
  {
    id v13 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(&OBJC_CLASS___NSNumber),  v6,  0LL);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    if (v14)
    {
      unsigned __int8 v15 = v14;
      [v14 doubleValue];
      double v5 = v16;
    }
  }

BOOL updateGCOverride(void *a1, uint64_t a2)
{
  id v7 = a1;
  if (v7)
  {
    uint64_t v8 = 86400 * a2;
    id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  (double)(unint64_t)v8));
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v9,  0LL,  0LL));

    BOOL v11 = setValue( v10, @"GCOverride", (const char *)[v7 fileSystemRepresentation]);
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"updateGCOverride",  @"Cannot update client usage with nil location",  v3,  v4,  v5,  v6,  v13);
    BOOL v11 = 0LL;
  }

  return v11;
}

void __filesystemProtectionQueue_block_invoke(id a1)
{
  id v1 = (const char *)[@"com.apple.MobileAsset.filesystem.manager" UTF8String];
  dispatch_queue_attr_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v5 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v2);
  dispatch_queue_t v3 = dispatch_queue_create(v1, v5);
  uint64_t v4 = (void *)filesystemProtectionQueue___filesystemProtectionQueue;
  filesystemProtectionQueue___filesystemProtectionQueue = (uint64_t)v3;
}

void __filesystemMetadataLastRefreshDate_block_invoke(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  dispatch_queue_attr_t v2 = (void *)filesystemMetadataLastRefreshDate___filesystemMetadataLastRefreshDate;
  filesystemMetadataLastRefreshDate___filesystemMetadataLastid RefreshDate = (uint64_t)v1;
}

void removeOldestMetadataRefreshData()
{
  id v0 = filesystemProtectionQueue();
  id v1 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v0);
  dispatch_assert_queue_V2(v1);

  id RefreshDate = filesystemMetadataLastRefreshDate();
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v3 = (id)objc_claimAutoreleasedReturnValue(RefreshDate);
  id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  uint64_t v5 = v3;
  if (!v4) {
    goto LABEL_13;
  }
  id v6 = v4;
  uint64_t v7 = 0LL;
  uint64_t v5 = 0LL;
  uint64_t v8 = *(void *)v18;
  do
  {
    for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v18 != v8) {
        objc_enumerationMutation(v3);
      }
      uint64_t v10 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
      BOOL v11 = objc_autoreleasePoolPush();
      uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSNumber);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "safeObjectForKey:ofClass:", v10, v12, (void)v17));
      id v14 = [v13 longLongValue];
      uint64_t v15 = (uint64_t)v14;
      if (!v5 || (uint64_t)v14 < v7)
      {
        id v16 = v10;

        uint64_t v7 = v15;
        uint64_t v5 = v16;
      }

      objc_autoreleasePoolPop(v11);
    }

    id v6 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  }

  while (v6);

  if (v5)
  {
    [v3 removeObjectForKey:v5];
LABEL_13:
  }
}

id mountPointForPath(void *a1)
{
  id v1 = a1;
  bzero(&v16, 0x878uLL);
  if (v1)
  {
    id v6 = v1;
    if (!statfs((const char *)[v6 UTF8String], &v16))
    {
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v16.f_mntonname));
      goto LABEL_7;
    }

    id v7 = [v6 UTF8String];
    __error();
    uint64_t v8 = __error();
    strerror(*v8);
    _MobileAssetLog( 0LL,  3,  (uint64_t)"mountPointForPath",  @"statfs failed for %s : %lld (%s)",  v9,  v10,  v11,  v12,  (uint64_t)v7);
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"mountPointForPath",  @"statfs failed for (null) : not possible",  v2,  v3,  v4,  v5,  v15);
  }

  uint64_t v13 = 0LL;
LABEL_7:

  return v13;
}

id isPathOnVolume(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  id v6 = &dword_0 + 1;
  if (v3 && v4)
  {
    id v7 = mountPointForPath(v3);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    id v6 = [v8 isEqual:v5];
    if ((_DWORD)v6) {
      uint64_t v13 = @"Path %@ is on volume %@";
    }
    else {
      uint64_t v13 = @"Path %@ is not on volume %@";
    }
    _MobileAssetLog(0LL, 6, (uint64_t)"isPathOnVolume", v13, v9, v10, v11, v12, (uint64_t)v3);
  }

  return v6;
}

id getAssetTypeDirectoriesForVolume(void *a1)
{
  id v1 = a1;
  id RepositoryPath = getRepositoryPath(@"/private/var/MobileAsset/AssetsV2");
  id v3 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  unsigned int v4 = isPathOnVolume(v3, v1);

  if (v4)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v6 = getRepositoryPath(@"/private/var/MobileAsset/AssetsV2");
    id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v7));
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( [v5 contentsOfDirectoryAtURL:v8 includingPropertiesForKeys:&__NSArray0__struct options:0 error:0]);

    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"lastPathComponent BEGINSWITH 'com_apple_MobileAsset_'"));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 filteredArrayUsingPredicate:v10]);
  }

  else
  {
    uint64_t v11 = &__NSArray0__struct;
  }

  return v11;
}

uint64_t assetExistsAndIsValidWithPurpose(void *a1, void *a2, void *a3, void *a4)
{
  id PathToAssetWithPurpose = getPathToAssetWithPurpose(a1, a2, a3, a4);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(PathToAssetWithPurpose);
  if (!v9)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"assetExistsAndIsValidWithPurpose",  @"getStateOfAsset, attempting to get state failed at getPathToAsset",  v5,  v6,  v7,  v8,  v21);
    goto LABEL_7;
  }

  char v22 = 0;
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 path]);
  unsigned int v12 = [v10 fileExistsAtPath:v11 isDirectory:&v22];

  uint64_t v17 = 0LL;
  if (v12)
  {
    if (v22)
    {
      uint64_t v17 = 1LL;
      goto LABEL_8;
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"assetExistsAndIsValidWithPurpose",  @"Asset dir: %@ exists and is not directory, deleting",  v13,  v14,  v15,  v16,  (uint64_t)v9);
    __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v9 path]);
    [v18 removeItemAtPath:v19 error:0];

LABEL_7:
    uint64_t v17 = 0LL;
  }

id augmentPathForSystemApp(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a2;
  uint64_t v8 = 0LL;
  if (a3 && a4)
  {
    id v9 = a4;
    id v10 = a1;
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v7 URLByAppendingPathComponent:a3]);

    unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([v11 URLByAppendingPathComponent:v9]);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 stringByReplacingOccurrencesOfString:@"." withString:@"_"]);

    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v12 URLByAppendingPathComponent:v13]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v13 stringByAppendingString:@".xml"]);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 URLByAppendingPathComponent:v15]);

    id v7 = v16;
    uint64_t v8 = v7;
  }

  return v8;
}

id dictionaryFromJsonFile(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfFile:](&OBJC_CLASS___NSData, "dataWithContentsOfFile:", v1));
    if (v2) {
      id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v2,  0LL,  0LL));
    }
    else {
      id v3 = 0LL;
    }
  }

  else
  {
    id v3 = 0LL;
    uint64_t v2 = 0LL;
  }

  return v3;
}

id getPathToSplunkData(void *a1)
{
  id v1 = a1;
  id RepositoryPath = getRepositoryPath(@"/private/var/MobileSoftwareUpdate/MobileAsset/AssetsV2/SplunkRecords");
  id v3 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  unsigned int v4 = ensureDirectory(v3);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);

  if (v5)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 URLByAppendingPathComponent:v1]);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

id getPathToSplunkRetry(void *a1)
{
  id v1 = a1;
  id RepositoryPath = getRepositoryPath(@"/private/var/MobileSoftwareUpdate/MobileAsset/AssetsV2/SplunkRecords/SplunkRetry");
  id v3 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  unsigned int v4 = ensureDirectory(v3);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);

  if (v5)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 URLByAppendingPathComponent:v1]);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

id ensureTargetDirectory(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 stringByAppendingPathComponent:a2]);
  id v3 = ensureDirectory(v2);
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue(v3);

  return v4;
}

id assembleXmlPathWithPurpose(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  id v9 = ensureTargetDirectory(v7, (uint64_t)v6);
  uint64_t v10 = objc_claimAutoreleasedReturnValue(v9);
  if (v10)
  {
    id v11 = (id)v10;
    if (v8)
    {
      if (!isWellFormedPurpose(v8))
      {
        __int128 v19 = 0LL;
        goto LABEL_9;
      }

      id v12 = purposeDirectoryName(v8);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v7 stringByAppendingPathComponent:v6]);
      id v15 = ensureTargetDirectory(v14, (uint64_t)v13);

      uint64_t v16 = objc_claimAutoreleasedReturnValue([v11 URLByAppendingPathComponent:v13]);
      id v11 = (id)v16;
    }

    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  v6,  @"xml"));
    __int128 v18 = (void *)objc_claimAutoreleasedReturnValue([v11 URLByAppendingPathComponent:v17]);
  }

  else
  {
    __int128 v18 = 0LL;
  }

  id v11 = v18;
  __int128 v19 = v11;
LABEL_9:

  return v19;
}

NSMutableArray *getFailedSplunkFiles(void *a1)
{
  id v1 = a1;
  uint64_t v2 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  id v3 = v1;
  unsigned int v4 = opendir((const char *)[v3 UTF8String]);
  if (v4)
  {
    uint64_t v5 = v4;
    for (uint64_t i = readdir(v4); i; uint64_t i = readdir(v5))
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", i->d_name));
      if (([v7 isEqualToString:@"."] & 1) == 0
        && ([v7 isEqualToString:@".."] & 1) == 0
        && ([v7 isEqualToString:@"SplunkRetry"] & 1) == 0)
      {
        -[NSMutableArray addObject:](v2, "addObject:", v7);
      }
    }

    closedir(v5);
  }

  return v2;
}

uint64_t removeItem(void *a1)
{
  id v1 = a1;
  id v2 = [v1 checkResourceIsReachableAndReturnError:0];
  if ((_DWORD)v2)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v21 = 0LL;
    unsigned int v8 = [v7 removeItemAtURL:v1 error:&v21];
    id v9 = v21;

    if (!v8)
    {
      __int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v9 description]);
      _MobileAssetLog( 0LL,  3,  (uint64_t)"removeItem",  @"Failed to remove %@, error is: %@",  v15,  v16,  v17,  v18,  (uint64_t)v1);

      uint64_t v14 = 0LL;
      goto LABEL_7;
    }

    _MobileAssetLog(0LL, 7, (uint64_t)"removeItem", @"Removed %@", v10, v11, v12, v13, (uint64_t)v1);
  }

  else
  {
    _MobileAssetLog( (uint64_t)v2,  7,  (uint64_t)"removeItem",  @"Location %@ doesn't exist",  v3,  v4,  v5,  v6,  (uint64_t)v1);
  }

  uint64_t v14 = 1LL;
LABEL_7:

  return v14;
}

uint64_t atomicallyCopyURLToURL(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = a1;
  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 globallyUniqueString]);

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 URLByDeletingLastPathComponent]);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 URLByAppendingPathComponent:v9]);

  LODWORD(v10) = [v7 copyItemAtURL:v6 toURL:v11 error:a3];
  if (_DWORD)v10 && ([v7 moveItemAtURL:v11 toURL:v5 error:a3])
  {
    uint64_t v12 = 1LL;
  }

  else
  {
    removeItem(v11);
    uint64_t v12 = 0LL;
  }

  return v12;
}

BOOL atomicallyMoveURLToURLUsingCopy(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  BOOL v6 = atomicallyCopyURLToURL(v5, a2, a3) && (removeItem(v5) & 1) != 0;

  return v6;
}

uint64_t moveTargetURLToDirectory(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v9 = v4;
  if (v3 && v4)
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 path]);
    unsigned __int8 v12 = [v10 fileExistsAtPath:v11];

    if ((v12 & 1) == 0)
    {
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      id v22 = 0LL;
      unsigned __int8 v14 = [v13 moveItemAtURL:v3 toURL:v9 error:&v22];
      id v15 = v22;

      if ((v14 & 1) == 0)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"moveTargetURLToDirectory",  @"Failed to move %@ to %@, error is: %@",  v16,  v17,  v18,  v19,  (uint64_t)v3);

        uint64_t v20 = 7LL;
        goto LABEL_8;
      }

      _MobileAssetLog( 0LL,  6,  (uint64_t)"moveTargetURLToDirectory",  @"Moved %@ to %@",  v16,  v17,  v18,  v19,  (uint64_t)v3);
    }

    uint64_t v20 = 0LL;
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"moveTargetURLToDirectory",  @"Failed to copy %@ to %@ (missing current/target path)",  v5,  v6,  v7,  v8,  (uint64_t)v3);
    uint64_t v20 = 77LL;
  }

uint64_t moveTargetToDirectory(void *a1, void *a2)
{
  return moveTargetURLToDirectory(a1, a2);
}

uint64_t copyTargetToDirectory(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v9 = v4;
  if (v3 && v4)
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 path]);
    unsigned __int8 v12 = [v10 fileExistsAtPath:v11];

    if ((v12 & 1) == 0)
    {
      id v21 = 0LL;
      BOOL v13 = atomicallyMoveURLToURLUsingCopy(v3, v9, (uint64_t)&v21);
      id v18 = v21;
      if (!v13)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"copyTargetToDirectory",  @"Failed to copy %@ to %@, error is: %@",  v14,  v15,  v16,  v17,  (uint64_t)v3);

        uint64_t v19 = 76LL;
        goto LABEL_8;
      }

      _MobileAssetLog( 0LL,  6,  (uint64_t)"copyTargetToDirectory",  @"Copied %@ to %@",  v14,  v15,  v16,  v17,  (uint64_t)v3);
    }

    uint64_t v19 = 0LL;
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"copyTargetToDirectory",  @"Failed to copy %@ to %@ (missing current/target path)",  v5,  v6,  v7,  v8,  (uint64_t)v3);
    uint64_t v19 = 77LL;
  }

void sub_1B46C4(_Unwind_Exception *a1)
{
}

void sub_1B5A6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

uint64_t __Block_byref_object_copy__13(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
}

void sub_1B9258( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __Block_byref_object_copy__14(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

void sub_1B9904( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id ASHTTPDateStringForDate(void *a1)
{
  id v1 = a1;
  id v2 = ASDateFormatterWithFormat(@"EEE',' dd MMM yyyy HH':'mm':'ss 'GMT'");
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 stringFromDate:v1]);

  return v4;
}

NSDateFormatter *ASDateFormatterWithFormat(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v2, "setDateFormat:", v1);

  id v3 = -[NSLocale initWithLocaleIdentifier:]( objc_alloc(&OBJC_CLASS___NSLocale),  "initWithLocaleIdentifier:",  @"en_US_POSIX");
  -[NSDateFormatter setLocale:](v2, "setLocale:", v3);

  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSTimeZone timeZoneForSecondsFromGMT:](&OBJC_CLASS___NSTimeZone, "timeZoneForSecondsFromGMT:", 0LL));
  -[NSDateFormatter setTimeZone:](v2, "setTimeZone:", v4);

  return v2;
}

id ASDateForHTTPDateString(void *a1)
{
  id v1 = a1;
  id v2 = ASDateFormatterWithFormat(@"EEE',' dd MMM yyyy HH':'mm':'ss z");
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 dateFromString:v1]);
  if (v4)
  {
    uint64_t v5 = (void *)v4;
  }

  else
  {
    uint64_t v6 = ASDateFormatterWithFormat(@"EEEE',' dd'-'MMM'-'yy HH':'mm':'ss z");
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

    uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 dateFromString:v1]);
    if (v8)
    {
      uint64_t v5 = (void *)v8;
      id v3 = v7;
    }

    else
    {
      uint64_t v9 = ASDateFormatterWithFormat(@"EEE MMM dd HH':'mm':'ss yyyy");
      id v3 = (void *)objc_claimAutoreleasedReturnValue(v9);

      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 dateFromString:v1]);
      if (!v5) {
        _MobileAssetLog( 0LL,  5,  (uint64_t)"ASDateForHTTPDateString",  @"Could not convert date string %@",  v10,  v11,  v12,  v13,  (uint64_t)v1);
      }
    }
  }

  return v5;
}

void __extractorDecodeClasses_block_invoke(id a1)
{
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (objc_opt_class(&OBJC_CLASS___IXPromisedStreamingZipTransfer)) {
    -[NSMutableArray addObject:](v3, "addObject:", objc_opt_class(&OBJC_CLASS___IXPromisedStreamingZipTransfer));
  }
  if (objc_opt_class(&OBJC_CLASS___IXPromisedOutOfBandStreamingZipTransfer)) {
    -[NSMutableArray addObject:]( v3,  "addObject:",  objc_opt_class(&OBJC_CLASS___IXPromisedOutOfBandStreamingZipTransfer));
  }
  -[NSMutableArray addObject:](v3, "addObject:", objc_opt_class(&OBJC_CLASS___NSArray));
  -[NSMutableArray addObject:](v3, "addObject:", objc_opt_class(&OBJC_CLASS___NSString));
  -[NSMutableArray addObject:](v3, "addObject:", objc_opt_class(&OBJC_CLASS___SZExtractor));
  -[NSMutableArray addObject:](v3, "addObject:", objc_opt_class(&OBJC_CLASS___STRemoteExtractor));
  id v1 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", v3);
  id v2 = (void *)extractorDecodeClasses__extractorDecodeClasses;
  extractorDecodeClasses__extractorDecodeClasses = (uint64_t)v1;
}

void __preservedIdsDecodeClasses_block_invoke(id a1)
{
  id v1 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSArray);
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSString);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v5, 3LL));
  id v3 = -[NSSet initWithArray:](v1, "initWithArray:", v2, v5, v6);
  uint64_t v4 = (void *)preservedIdsDecodeClasses__preservedIdsDecodeClasses;
  preservedIdsDecodeClasses__preservedIdsDecodeClasses = (uint64_t)v3;
}

void __queryDecodeClasses_block_invoke(id a1)
{
  id v1 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSData);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSDate);
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSString);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSNumber);
  uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSArray);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSMutableData);
  uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSMutableString);
  uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v15 = objc_opt_class(&OBJC_CLASS___NSNull);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v5, 11LL));
  id v3 = -[NSSet initWithArray:](v1, "initWithArray:", v2, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
  uint64_t v4 = (void *)queryDecodeClasses__queryDecodeClasses;
  queryDecodeClasses__queryDecodeClasses = (uint64_t)v3;
}

id loadDecodeClasses()
{
  if (loadDecodeClasses_once != -1) {
    dispatch_once(&loadDecodeClasses_once, &__block_literal_global_621);
  }
  return (id)loadDecodeClasses__loadDecodeClasses;
}

void __loadDecodeClasses_block_invoke(id a1)
{
  id v1 = objc_alloc(&OBJC_CLASS___NSSet);
  v5[0] = objc_opt_class(&OBJC_CLASS___NSData);
  v5[1] = objc_opt_class(&OBJC_CLASS___NSDate);
  v5[2] = objc_opt_class(&OBJC_CLASS___NSString);
  v5[3] = objc_opt_class(&OBJC_CLASS___NSNumber);
  v5[4] = objc_opt_class(&OBJC_CLASS___NSArray);
  v5[5] = objc_opt_class(&OBJC_CLASS___NSDictionary);
  v5[6] = objc_opt_class(&OBJC_CLASS___NSMutableData);
  v5[7] = objc_opt_class(&OBJC_CLASS___NSMutableString);
  v5[8] = objc_opt_class(&OBJC_CLASS___NSMutableArray);
  v5[9] = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
  v5[10] = objc_opt_class(&OBJC_CLASS___MAAssetDiff);
  v5[11] = objc_opt_class(&OBJC_CLASS___MAAbsoluteAssetId);
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v5, 12LL));
  id v3 = -[NSSet initWithArray:](v1, "initWithArray:", v2);
  uint64_t v4 = (void *)loadDecodeClasses__loadDecodeClasses;
  loadDecodeClasses__loadDecodeClasses = (uint64_t)v3;
}

id _getDaemonAsyncConnectionQueue()
{
  if (_getDaemonAsyncConnectionQueue_once != -1) {
    dispatch_once(&_getDaemonAsyncConnectionQueue_once, &__block_literal_global_624);
  }
  return (id)_getDaemonAsyncConnectionQueue_queue;
}

void ___getDaemonAsyncConnectionQueue_block_invoke(id a1)
{
  dispatch_queue_attr_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v4 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v1);
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.MobileAsset.daemon.connection.asynchandler", v4);
  id v3 = (void *)_getDaemonAsyncConnectionQueue_queue;
  _getDaemonAsyncConnectionQueue_queue = (uint64_t)v2;
}

id _getDaemonAsyncHandlerQueue()
{
  if (_getDaemonAsyncHandlerQueue_once != -1) {
    dispatch_once(&_getDaemonAsyncHandlerQueue_once, &__block_literal_global_626);
  }
  return (id)_getDaemonAsyncHandlerQueue_queue;
}

void ___getDaemonAsyncHandlerQueue_block_invoke(id a1)
{
  dispatch_queue_attr_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v4 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v1);
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.MobileAsset.daemon.asynchandler", v4);
  id v3 = (void *)_getDaemonAsyncHandlerQueue_queue;
  _getDaemonAsyncHandlerQueue_queue = (uint64_t)v2;
}

void __getControlManager_block_invoke(id a1)
{
  dispatch_queue_attr_t v1 = objc_opt_new(&OBJC_CLASS___ControlManager);
  dispatch_queue_t v2 = (void *)getControlManager_controlManager;
  getControlManager_controlManager = (uint64_t)v1;

  id DaemonAsyncHandlerQueue = _getDaemonAsyncHandlerQueue();
  uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(DaemonAsyncHandlerQueue);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.mobileassetd.v2", v4, 1uLL);
  uint64_t v6 = (void *)getControlManager_connection;
  getControlManager_connection = (uint64_t)mach_service;

  uint64_t v7 = (void *)getControlManager_controlManager;
  uint64_t v8 = getControlManager_connection;
  id DaemonAsyncConnectionQueue = _getDaemonAsyncConnectionQueue();
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(DaemonAsyncConnectionQueue);
  [v7 setServerConnectionHandler:v8 with:@"server" and:v10];

  xpc_connection_activate((xpc_connection_t)getControlManager_connection);
}

NSMutableDictionary *applyFilter(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v30 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  if (v3)
  {
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKey:@"queryKey"]);
    id v20 = v3;
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKey:@"queryValue"]);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    uint64_t v24 = v5;
    unsigned int v21 = [v5 containsObject:v6];
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    id obj = (id)objc_claimAutoreleasedReturnValue([v4 allKeys]);
    id v27 = [obj countByEnumeratingWithState:&v36 objects:v41 count:16];
    if (!v27) {
      goto LABEL_30;
    }
    uint64_t v25 = *(void *)v37;
    id v23 = v4;
    while (1)
    {
      for (uint64_t i = 0LL; i != v27; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v37 != v25) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void *)(*((void *)&v36 + 1) + 8LL * (void)i);
        uint64_t v9 = objc_autoreleasePoolPush();
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v8]);
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v31 objectForKey:v26]);
        if (v10)
        {
          uint64_t v28 = v9;
          uint64_t v29 = i;
          __int128 v34 = 0u;
          __int128 v35 = 0u;
          __int128 v32 = 0u;
          __int128 v33 = 0u;
          id v11 = v24;
          id v12 = [v11 countByEnumeratingWithState:&v32 objects:v40 count:16];
          if (!v12) {
            goto LABEL_25;
          }
          id v13 = v12;
          uint64_t v14 = *(void *)v33;
          while (1)
          {
            for (j = 0LL; j != v13; j = (char *)j + 1)
            {
              if (*(void *)v33 != v14) {
                objc_enumerationMutation(v11);
              }
              uint64_t v16 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)j);
              if (v16 != v6)
              {
                if ((objc_opt_respondsToSelector(v10, "isEqualToString:") & 1) != 0)
                {
                }

                else if ((objc_opt_respondsToSelector(v10, "stringValue") & 1) != 0)
                {
                  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v10 stringValue]);
                  unsigned __int8 v18 = [v17 isEqualToString:v16];

                  if ((v18 & 1) != 0) {
                    goto LABEL_22;
                  }
                }

                else if ((objc_opt_respondsToSelector(v10, "containsObject:") & 1) != 0 {
                       && [v10 containsObject:v16])
                }
                {
LABEL_22:
                  -[NSMutableDictionary setObject:forKey:](v30, "setObject:forKey:", v31, v8);
                  continue;
                }
              }
            }

            id v13 = [v11 countByEnumeratingWithState:&v32 objects:v40 count:16];
            if (!v13)
            {
LABEL_25:

              id v4 = v23;
              uint64_t v9 = v28;
              uint64_t i = v29;
              goto LABEL_28;
            }
          }
        }

        if (v21) {
          -[NSMutableDictionary setObject:forKey:](v30, "setObject:forKey:", v31, v8);
        }
LABEL_28:

        objc_autoreleasePoolPop(v9);
      }

      id v27 = [obj countByEnumeratingWithState:&v36 objects:v41 count:16];
      if (!v27)
      {
LABEL_30:

        id v3 = v20;
        break;
      }
    }
  }

  return v30;
}

uint64_t getSandboxExtension(void *a1, void *a2, uint64_t *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = [v5 fileSystemRepresentation];
  xpc_connection_get_audit_token(v6, v10);

  v9[0] = v10[0];
  v9[1] = v10[1];
  uint64_t result = sandbox_extension_issue_file_to_process("com.apple.assets.read", v7, 0LL, v9);
  *a3 = result;
  return result;
}

void createExtension(void *a1, void *a2, void *a3)
{
  xpc_connection_t connection = a1;
  id v5 = a2;
  id v27 = 0LL;
  id v6 = a3;
  id v7 = repositoryPath(v6);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  id v16 = normalizedAssetType((uint64_t)v6, v9, v10, v11, v12, v13, v14, v15);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

  unsigned __int8 v18 = (void *)objc_claimAutoreleasedReturnValue([v8 stringByAppendingPathComponent:v17]);
  getSandboxExtension(v18, connection, (uint64_t *)&v27);
  id v23 = v27;
  if (v27)
  {
    _MobileAssetLog(0LL, 6, (uint64_t)"createExtension", @"extension set", v19, v20, v21, v22, (uint64_t)connection);
    xpc_object_t reply = xpc_dictionary_create_reply(v5);
    if (reply)
    {
      xpc_dictionary_set_string(reply, (const char *)[@"sandboxExtensionKey" UTF8String], v23);
      free(v23);
      xpc_dictionary_set_int64(reply, "Result", 0LL);
      xpc_connection_send_message(connectiona, reply);
    }
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"createExtension",  @"Cannot create extension",  v19,  v20,  v21,  v22,  (uint64_t)connection);
  }
}

NSMutableDictionary *getAssetsFromXml(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  __int128 v38 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  if (!v4)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"getAssetsFromXml",  @"For asset-type: %@ Could not get assets from xml",  v5,  v6,  v7,  v8,  (uint64_t)v3);
    id v14 = 0LL;
    goto LABEL_23;
  }

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:@"Assets"]);
  id v14 = v9;
  if (!v9)
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"getAssetsFromXml",  @"For asset-type: %@ Assets array nil in xml",  v10,  v11,  v12,  v13,  (uint64_t)v3);
    goto LABEL_23;
  }

  if ([v9 count] == (char *)&dword_0 + 1)
  {
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectAtIndexedSubscript:0]);
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKey:@"__Empty"]);
    unsigned int v17 = [v16 isEqualToString:@"Empty"];

    if (v17)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"getAssetsFromXml",  @"For asset-type: %@ query was skipped due to special __Empty keyword",  v18,  v19,  v20,  v21,  (uint64_t)v3);
LABEL_23:
      uint64_t v25 = 0LL;
      goto LABEL_24;
    }
  }

  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  id v14 = v14;
  id v22 = [v14 countByEnumeratingWithState:&v39 objects:v43 count:16];
  if (!v22)
  {

    goto LABEL_23;
  }

  id v23 = v22;
  id v37 = v4;
  char v24 = 0;
  uint64_t v25 = 0LL;
  uint64_t v26 = *(void *)v40;
  do
  {
    id v27 = 0LL;
    uint64_t v28 = v25;
    do
    {
      if (*(void *)v40 != v26) {
        objc_enumerationMutation(v14);
      }
      uint64_t v29 = *(void **)(*((void *)&v39 + 1) + 8LL * (void)v27);
      uint64_t v30 = objc_autoreleasePoolPush();
      AssetIdFromDict = getAssetIdFromDict(v3, v29);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(AssetIdFromDict);

      if (v25) {
        -[NSMutableDictionary setObject:forKey:](v38, "setObject:forKey:", v29, v25);
      }
      else {
        char v24 = 1;
      }
      objc_autoreleasePoolPop(v30);
      id v27 = (char *)v27 + 1;
      uint64_t v28 = v25;
    }

    while (v23 != v27);
    id v23 = [v14 countByEnumeratingWithState:&v39 objects:v43 count:16];
  }

  while (v23);

  if ((v24 & 1) != 0) {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"getAssetsFromXml",  @"For asset-type: %@ asset(s) skipped due to nil assetId during query",  v32,  v33,  v34,  v35,  (uint64_t)v3);
  }
  id v4 = v37;
LABEL_24:

  return v38;
}

id getAssetFromXml(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  AssetsFromXml = getAssetsFromXml(a1, a3);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(AssetsFromXml);
  uint64_t v8 = v7;
  uint64_t v9 = 0LL;
  if (v5 && v7)
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v5]);
    uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
    char isKindOfClass = objc_opt_isKindOfClass(v10, v11);

    if ((isKindOfClass & 1) != 0) {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v5]);
    }
    else {
      uint64_t v9 = 0LL;
    }
  }

  return v9;
}

void handleGetInstalledAssetIds(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = a3;
  xpc_object_t reply = xpc_dictionary_create_reply(a4);
  if (reply)
  {
    id v18 = normalizedAssetType((uint64_t)v7, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    uint64_t v20 = repositoryPath(v7);
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 stringByAppendingPathComponent:v19]);

    InstalledAssetIds = getInstalledAssetIds(v22);
    char v24 = (void *)objc_claimAutoreleasedReturnValue(InstalledAssetIds);
    uint64_t v25 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v30 = v25;
    if (v24)
    {
      -[NSMutableDictionary setObject:forKey:](v25, "setObject:forKey:", v24, @"QueryAssetIds");
      id v45 = 0LL;
      id v31 = (id)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v30,  1LL,  &v45));
      id v32 = v45;
      uint64_t v33 = v32;
      int64_t v34 = 3LL;
      if (v31 && !v32)
      {
        id v35 = objc_msgSend(v24, "count", 3);
        _MobileAssetLog( 0LL,  6,  (uint64_t)"handleGetInstalledAssetIds",  @"getInstalledAssetIds result is %ld for:%@",  v36,  v37,  v38,  v39,  (uint64_t)v35);
        key = (char *)[@"QueryAssetIdsResponse" UTF8String];
        id v31 = v31;
        id v40 = v8;
        id v41 = [v31 bytes];
        id v42 = [v31 length];
        uint64_t v43 = v41;
        id v8 = v40;
        xpc_dictionary_set_data(reply, key, v43, (size_t)v42);
        uint64_t v33 = 0LL;
        int64_t v34 = 0LL;
      }
    }

    else
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"handleGetInstalledAssetIds",  @"Got nil assets for getInstalledAssetIds: %@",  v26,  v27,  v28,  v29,  (uint64_t)v7);
      uint64_t v33 = 0LL;
      id v31 = 0LL;
      int64_t v34 = 3LL;
    }

    xpc_dictionary_set_int64(reply, "Result", v34);
    xpc_connection_send_message(v9, reply);
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"handleGetInstalledAssetIds",  @"Could not create reply for getInstalledAssetIds: %@",  v13,  v14,  v15,  v16,  (uint64_t)v7);
  }
}

void checkSpaceForDownload(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v29 = 0LL;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2020000000LL;
  uint64_t v32 = 2LL;
  unint64_t v28 = 0LL;
  if (determineUnarchiveSizeFromMessage(v4, (uint64_t *)&v28))
  {
    _MobileAssetLog(0LL, 6, (uint64_t)"checkSpaceForDownload", @"Doing check for %lld", v5, v6, v7, v8, v28);
    if (&_CPFreeSpaceRequestBytesAtPathWithCompletionBlock)
    {
      uint64_t v33 = kCPFreeSpaceEffortLevelKey;
      int64_t v34 = &off_38F0B8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v34,  &v33,  1LL);
      unint64_t v10 = v28;
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3221225472LL;
      v23[2] = __checkSpaceForDownload_block_invoke;
      v23[3] = &unk_34FCF0;
      uint64_t v26 = &v29;
      unint64_t v27 = v28;
      id v24 = v3;
      id v25 = v4;
      CPFreeSpaceRequestBytesAtPathWithCompletionBlock(v10, 0LL, v9, v23);

      id v11 = v24;
    }

    else
    {
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      id v22 = 0LL;
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 attributesOfFileSystemForPath:@"/" error:&v22]);
      id v11 = v22;
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKey:NSFileSystemFreeSize]);
      id v15 = [v14 unsignedLongLongValue];

      uint64_t v20 = v28;
      if ((unint64_t)v15 <= v28)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"checkSpaceForDownload",  @"Space check result: Not enough space to download and unarchive asset: need %llu and %llu available. error: %@",  v16,  v17,  v18,  v19,  v28);
      }

      else
      {
        v30[3] = 0LL;
        _MobileAssetLog( 0LL,  6,  (uint64_t)"checkSpaceForDownload",  @"Space check result: Space check successful: need %llu and %llu available",  v16,  v17,  v18,  v19,  v20);
      }

      sendClientResponse(v3, v4, v30[3]);
    }
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"checkSpaceForDownload",  @"Space check fails, unable to determine required size",  v5,  v6,  v7,  v8,  v21);
    sendClientResponse(v3, v4, v30[3]);
  }

  _Block_object_dispose(&v29, 8);
}

void sub_1C5A44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

BOOL __checkSpaceForDownload_block_invoke( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0LL;
  }
  else {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"checkSpaceForDownload_block_invoke",  @"Space check result: Not enough space to download and unarchive asset: need %llu and %llu available",  v10,  v11,  v12,  v13,  *(void *)(a1 + 56));
  }
  return sendClientResponse( *(void **)(a1 + 32),  *(void **)(a1 + 40),  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
}

void cleanV1Assets(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = a1;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v16 = normalizedAssetType((uint64_t)v5, v9, v10, v11, v12, v13, v14, v15);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

  id RepositoryPath = getRepositoryPath(@"/private/var/MobileAsset/Assets");
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@/%@", v19, v17));

  id v21 = [v8 fileExistsAtPath:v20];
  if ((_DWORD)v21)
  {
    id v33 = 0LL;
    unsigned __int8 v26 = [v8 removeItemAtPath:v20 error:&v33];
    id v31 = v33;
    if ((v26 & 1) == 0)
    {
      _MobileAssetLog( 0LL,  6,  (uint64_t)"cleanV1Assets",  @"Deletion of %@ failed due to: %@",  v27,  v28,  v29,  v30,  (uint64_t)v20);

      int64_t v32 = 2LL;
      goto LABEL_7;
    }

    _MobileAssetLog( 0LL,  6,  (uint64_t)"cleanV1Assets",  @"%@ assets folder successfully deleted",  v27,  v28,  v29,  v30,  (uint64_t)v20);
  }

  else
  {
    _MobileAssetLog( (uint64_t)v21,  6,  (uint64_t)"cleanV1Assets",  @"No need to clean, %@ does not exist",  v22,  v23,  v24,  v25,  (uint64_t)v20);
  }

  int64_t v32 = 0LL;
LABEL_7:
  sendClientResponse(v7, v6, v32);
}

void finishAllPartiallyPurgedAssets(void *a1)
{
  id v1 = a1;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  dispatch_queue_t v2 = allRepositoryPathsForPurging(1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    id v9 = v4;
    uint64_t v10 = *(void *)v14;
    do
    {
      uint64_t v11 = 0LL;
      do
      {
        if (*(void *)v14 != v10) {
          objc_enumerationMutation(v3);
        }
        uint64_t v12 = *(void **)(*((void *)&v13 + 1) + 8LL * (void)v11);
        _MobileAssetLog( 0LL,  5,  (uint64_t)"finishAllPartiallyPurgedAssets",  @"[GARBAGE_COLLECTION] {finishAllPartiallyPurgedAssets} %@ | checking for purged assets at path:%@",  v5,  v6,  v7,  v8,  (uint64_t)v1);
        finishPartiallyPurgedAssets(v12, 2u, 1);
        uint64_t v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v9 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }

    while (v9);
  }
}

NSMutableArray *allRepositoryPathsForPurging(int a1)
{
  dispatch_queue_t v2 = objc_alloc(&OBJC_CLASS___NSMutableArray);
  id RepositoryPath = getRepositoryPath(@"/private/var/MobileAsset/AssetsV2");
  id v4 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  uint64_t v5 = -[NSMutableArray initWithObjects:](v2, "initWithObjects:", v4, 0LL);

  if (a1)
  {
    id v6 = getRepositoryPath(@"/private/var/MobileAsset/PreinstalledAssetsV2/InstallWithOs");
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    -[NSMutableArray addObject:](v5, "addObject:", v7);
  }

  -[NSMutableArray addObject:](v5, "addObject:", @"/private/var/MobileSoftwareUpdate/MobileAsset/AssetsV2");
  return v5;
}

void sub_1C6CFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

NSMutableString *stringForQueryArray(void *a1)
{
  id v1 = a1;
  dispatch_queue_t v2 = -[NSMutableString initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableString), "initWithCapacity:", 0LL);
  -[NSMutableString appendString:](v2, "appendString:", @"[ ");
  if (v1)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    id v19 = v1;
    id obj = v1;
    id v22 = [obj countByEnumeratingWithState:&v29 objects:v34 count:16];
    if (v22)
    {
      char v4 = 1;
      uint64_t v21 = *(void *)v30;
      do
      {
        uint64_t v5 = 0LL;
        do
        {
          if (*(void *)v30 != v21) {
            objc_enumerationMutation(obj);
          }
          id v6 = *(void **)(*((void *)&v29 + 1) + 8LL * (void)v5);
          context = objc_autoreleasePoolPush();
          uint64_t v7 = objc_claimAutoreleasedReturnValue([v6 objectForKey:@"queryKey"]);
          uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKey:@"queryValue"]);
          if ((v4 & 1) != 0) {
            id v9 = @"%@:";
          }
          else {
            id v9 = @" and %@:";
          }
          uint64_t v23 = (void *)v7;
          -[NSMutableString appendFormat:](v2, "appendFormat:", v9, v7);
          unsigned int v10 = [v8 containsObject:v3];
          if (v10) {
            -[NSMutableString appendString:](v2, "appendString:", @"NULL");
          }
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          __int128 v25 = 0u;
          __int128 v26 = 0u;
          id v11 = v8;
          id v12 = [v11 countByEnumeratingWithState:&v25 objects:v33 count:16];
          if (v12)
          {
            id v13 = v12;
            char v14 = v10 ^ 1;
            uint64_t v15 = *(void *)v26;
            do
            {
              __int128 v16 = 0LL;
              do
              {
                if (*(void *)v26 != v15) {
                  objc_enumerationMutation(v11);
                }
                if (*(void **)(*((void *)&v25 + 1) + 8LL * (void)v16) != v3)
                {
                  if ((v14 & 1) != 0) {
                    uint64_t v17 = @"'%@'";
                  }
                  else {
                    uint64_t v17 = @",'%@'";
                  }
                  -[NSMutableString appendFormat:]( v2,  "appendFormat:",  v17,  *(void *)(*((void *)&v25 + 1) + 8LL * (void)v16));
                  char v14 = 0;
                }

                __int128 v16 = (char *)v16 + 1;
              }

              while (v13 != v16);
              id v13 = [v11 countByEnumeratingWithState:&v25 objects:v33 count:16];
            }

            while (v13);
          }

          objc_autoreleasePoolPop(context);
          char v4 = 0;
          uint64_t v5 = (char *)v5 + 1;
        }

        while (v5 != v22);
        char v4 = 0;
        id v22 = [obj countByEnumeratingWithState:&v29 objects:v34 count:16];
      }

      while (v22);
    }

    id v1 = v19;
  }

  -[NSMutableString appendString:](v2, "appendString:", @"]");

  return v2;
}

void ensureAssetDirectory(void *a1, int a2)
{
  id v8 = a1;
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](&OBJC_CLASS___NSURL, "fileURLWithPath:isDirectory:"));
  if (_MobileAssetCreateDirectoryWorldWriteable(v3, a2)) {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"ensureAssetDirectory",  @"Could not ensure directory %@ %@error %d",  v4,  v5,  v6,  v7,  (uint64_t)v8);
  }
}

id ensureRepositoryPath(void *a1)
{
  id v1 = repositoryPath(a1);
  dispatch_queue_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  ensureAssetDirectory(v2, 0);
  return v2;
}

BOOL isRecentlyDownloaded(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v8 = v5;
  v9 = (v5 || (id v8 = v6) != 0) && [v8 compare:v7] != (id)-1;

  return v9;
}

id isInFlight(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v4)
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v6 = v4;
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v14;
      while (2)
      {
        for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v8) {
            objc_enumerationMutation(v6);
          }
          uint64_t v10 = *(void *)(*((void *)&v13 + 1) + 8LL * (void)i);
          id v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "lastPathComponent", (void)v13));
          LOBYTE(v10) = [v11 isEqual:v10];

          if ((v10 & 1) != 0)
          {
            id v7 = &dword_0 + 1;
            goto LABEL_12;
          }
        }

        id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (v7) {
          continue;
        }
        break;
      }
    }

uint64_t removeDownloadsNotRecentlyInFlight(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  [v7 count];
  _MobileAssetLog( 0LL,  5,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} dir:%@ | referenceDateForRecent:%@ | tasksInFlight:%ld",  v8,  v9,  v10,  v11,  (uint64_t)v5);
  id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  v87[0] = NSFileCreationDate;
  v87[1] = NSFileModificationDate;
  v87[2] = NSURLContentModificationDateKey;
  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v87, 3LL));
  id v85 = 0LL;
  __int128 v14 = (void *)objc_claimAutoreleasedReturnValue( [v12 contentsOfDirectoryAtURL:v5 includingPropertiesForKeys:v13 options:0 error:&v85]);
  id v15 = v85;

  if (!v14)
  {
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v15 domain]);
    unsigned int v52 = [v51 isEqual:NSCocoaErrorDomain];

    if (v52)
    {
      if ([v15 code] == &stru_B8.reserved3)
      {
LABEL_32:
        uint64_t v58 = 0LL;
        goto LABEL_33;
      }

      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v15 checkedSummary]);
      _MobileAssetLog( 0LL,  3,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} failed to determine contents of directory:%@ | error:%@\n%@",  v54,  v55,  v56,  v57,  (uint64_t)v5);
    }

    else
    {
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v15 checkedSummary]);
      _MobileAssetLog( 0LL,  3,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} error determining contents of directory:%@ | error:%@\n%@",  v59,  v60,  v61,  v62,  (uint64_t)v5);
    }

    goto LABEL_32;
  }

  id v69 = v15;
  dispatch_source_t v70 = v12;
  id v71 = v5;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  __int128 v81 = 0u;
  __int128 v82 = 0u;
  uint64_t v68 = v14;
  id obj = v14;
  id v76 = [obj countByEnumeratingWithState:&v81 objects:v86 count:16];
  if (v76)
  {
    char v73 = 0;
    uint64_t v75 = *(void *)v82;
    id v72 = v7;
    do
    {
      __int128 v16 = 0LL;
      do
      {
        if (*(void *)v82 != v75) {
          objc_enumerationMutation(obj);
        }
        uint64_t v17 = *(void **)(*((void *)&v81 + 1) + 8LL * (void)v16);
        uint64_t v18 = objc_autoreleasePoolPush();
        id v79 = 0LL;
        id v80 = 0LL;
        [v17 getResourceValue:&v80 forKey:NSURLContentModificationDateKey error:&v79];
        id v19 = v80;
        id v20 = v79;
        id v77 = 0LL;
        id v78 = 0LL;
        [v17 getResourceValue:&v78 forKey:NSFileCreationDate error:&v77];
        id v21 = v78;
        id v22 = v77;
        if (v20)
        {
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v20 checkedSummary]);
          _MobileAssetLog( 0LL,  5,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} could not determine content modification date, continuing anyway | URL:%@ | error:%@\n%@",  v23,  v24,  v25,  v26,  (uint64_t)v17);
        }

        if (v22
          && (uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v22 checkedSummary]),
              _MobileAssetLog( 0LL,  5,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} could not determine creation date, continuing anyway | URL:%@ | error:%@\n%@",  v27,  v28,  v29,  v30,  (uint64_t)v17),  v65,  v20)
          || isRecentlyDownloaded(v19, v21, v6))
        {
          __int128 v31 = (void *)objc_claimAutoreleasedReturnValue([v17 baseURL]);
          [v6 timeIntervalSinceReferenceDate];
          id v33 = epochToDate(v32);
          uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(v33);
          _MobileAssetLog( 0LL,  4,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} skipping %@ since it was modified before %@",  v34,  v35,  v36,  v37,  (uint64_t)v31);
        }

        else if (v7)
        {
          if ((isInFlight(v17, v7) & 1) == 0)
          {
            id v38 = v6;
            uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v17 path]);
            unint64_t v40 = renameWithExtThenRemove(v39, @".purged");

            id v6 = v38;
            if (v40 != 3)
            {
              if (v40)
              {
                id v45 = stringForMAPurgeResult(v40);
                uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(v45);
                _MobileAssetLog( 0LL,  3,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} could not remove old in-flight download tracking file (not in-flight) | URL:%@ | result:%@",  v46,  v47,  v48,  v49,  (uint64_t)v17);
              }

              else
              {
                _MobileAssetLog( 0LL,  5,  (uint64_t)"removeDownloadsNotRecentlyInFlight",  @"[GARBAGE_COLLECTION] {removeDownloadsNotRecentlyInFlight} removed old in-flight download tracking file (not in-flight) | URL:%@",  v41,  v42,  v43,  v44,  (uint64_t)v17);
              }
            }

            id v7 = v72;
          }
        }

        else
        {
          char v73 = 1;
        }

        objc_autoreleasePoolPop(v18);
        __int128 v16 = (char *)v16 + 1;
      }

      while (v76 != v16);
      id v50 = [obj countByEnumeratingWithState:&v81 objects:v86 count:16];
      id v76 = v50;
    }

    while (v50);
  }

  else
  {
    char v73 = 0;
  }

  uint64_t v58 = v73 & 1;
  id v12 = v70;
  id v5 = v71;
  __int128 v14 = v68;
  id v15 = v69;
LABEL_33:

  return v58;
}

uint64_t renameWithExtThenRemove(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v6 = [v5 fileExistsAtPath:v3];
  if ((_DWORD)v6)
  {
    if (v4)
    {
      id v11 = (id)objc_claimAutoreleasedReturnValue([v3 stringByAppendingString:v4]);
      if ([v5 fileExistsAtPath:v11])
      {
        id v38 = 0LL;
        unsigned __int8 v12 = [v5 removeItemAtPath:v11 error:&v38];
        id v17 = v38;
        if ((v12 & 1) == 0) {
          _MobileAssetLog( 0LL,  3,  (uint64_t)"renameWithExtThenRemove",  @"Couldn't remove previous purging asset: %@ due to error: %@",  v13,  v14,  v15,  v16,  (uint64_t)v11);
        }
      }

      else
      {
        id v17 = 0LL;
      }

      id v37 = v17;
      unsigned __int8 v20 = [v5 moveItemAtPath:v3 toPath:v11 error:&v37];
      id v19 = v37;

      if ((v20 & 1) == 0)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"renameWithExtThenRemove",  @"Couldn't purge asset: %@ when first moving to: %@ due to error: %@",  v21,  v22,  v23,  v24,  (uint64_t)v3);
        uint64_t v18 = 4LL;
        goto LABEL_14;
      }
    }

    else
    {
      id v11 = v3;
      id v19 = 0LL;
    }

    uint64_t v25 = v19;
    id v36 = v19;
    unsigned __int8 v26 = [v5 removeItemAtPath:v11 error:&v36];
    id v19 = v36;

    if ((v26 & 1) != 0)
    {

      _MobileAssetLog( 0LL,  6,  (uint64_t)"renameWithExtThenRemove",  @"Successfully purged asset from: %@",  v31,  v32,  v33,  v34,  (uint64_t)v3);
      uint64_t v18 = 0LL;
      goto LABEL_15;
    }

    _MobileAssetLog( 0LL,  3,  (uint64_t)"renameWithExtThenRemove",  @"Couldn't purge asset: %@ when removing due to error: %@",  v27,  v28,  v29,  v30,  (uint64_t)v11);
    uint64_t v18 = 12LL;
LABEL_14:

    goto LABEL_15;
  }

  uint64_t v18 = 3LL;
  _MobileAssetLog( (uint64_t)v6,  3,  (uint64_t)"renameWithExtThenRemove",  @"Couldn't purge asset: %@ does not exist",  v7,  v8,  v9,  v10,  (uint64_t)v3);
LABEL_15:

  return v18;
}

id epochToDate(double a1)
{
  if (epochToDate_onceToken != -1) {
    dispatch_once(&epochToDate_onceToken, &__block_literal_global_2328);
  }
  dispatch_queue_t v2 = (void *)dateFormatter;
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSince1970:](&OBJC_CLASS___NSDate, "dateWithTimeIntervalSince1970:", a1));
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v2 stringFromDate:v3]);

  return v4;
}

void sub_1CAD14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_82:
  return v41;
}

void sub_1CEBB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void sub_1D0710( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52)
{
}

void sub_1D0998( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

LABEL_3:
  if ((a3 & 0x10) == 0)
  {
    uint64_t v14 = 0LL;
    goto LABEL_30;
  }

  uint64_t v24 = (__CFString *)objc_claimAutoreleasedReturnValue( +[ControlManager getStringFromXpcMessage:forKey:]( &OBJC_CLASS___ControlManager,  "getStringFromXpcMessage:forKey:",  v10,  "AssetId"));
  uint64_t v14 = v24;
  if (v24)
  {
    if (isWellFormedAssetId(v24))
    {
      [v11 associateAssetId:v14];
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v11 assetId]);
      [v12 extendLogLeader:@"AssetId" withValue:v25];

      goto LABEL_30;
    }

    uint64_t v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Client request with %@:%@ (which is not well formed)",  @"AssetId",  v14);
  }

  else
  {
    uint64_t v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Client request missing key:%@",  @"AssetId",  v117);
  }

  id v17 = (__CFString *)v27;
LABEL_29:
  if (v17) {
    goto LABEL_182;
  }
LABEL_30:
  v127 = self;
  if ((a3 & 0x10000000000LL) != 0)
  {
    uint64 = xpc_dictionary_get_uint64(v10, "returnAssetTypes");
    if (uint64 > 6)
    {
      id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown return types [%llu] provided by client",  uint64);
      goto LABEL_35;
    }

    [v11 associateReturnTypes:uint64];
    uint64_t v29 = stringForMAQueryReturnTypes((unint64_t)[v11 returnTypes]);
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    [v12 extendLogLeader:@"returnAssetTypes" withValue:v30];
  }

  id v17 = 0LL;
LABEL_35:
  uint64_t v31 = v17 == 0LL;
  if ((a3 & 0x20000000000LL) != 0 && !v17)
  {
    uint64_t v31 = 1;
    if (xpc_dictionary_get_BOOL(v10, "doNotBlockBeforeFirstUnlock"))
    {
      [v11 associateDoNotBlockBeforeFirstUnlock:1];
      else {
        uint64_t v32 = @"NO";
      }
      [v12 extendLogLeader:@"doNotBlockBeforeFirstUnlock" withValue:v32];
    }
  }

  if ((a3 & 0x40000000000LL) == 0 || v17)
  {
LABEL_51:
    if (!v31) {
      goto LABEL_61;
    }
    goto LABEL_52;
  }

  if (!xpc_dictionary_get_BOOL(v10, "doNotBlockOnNetworkStatus"))
  {
    id v17 = 0LL;
    goto LABEL_51;
  }

  [v11 associateDoNotBlockOnNetworkStatus:1];
  else {
    uint64_t v33 = @"NO";
  }
  [v12 extendLogLeader:@"doNotBlockOnNetworkStatus" withValue:v33];
  if (!v31)
  {
    id v17 = 0LL;
    goto LABEL_61;
  }

    ++v6;
  }

  while (v6 < v5);
  return v6;
}

LABEL_123:
                uint64_t v13 = v122;
                unsigned __int8 v12 = v123;
                id v77 = v124;
                a3 = v126;
              }
            }

            objc_autoreleasePoolPop(v83);
          }

          id v79 = [obj countByEnumeratingWithState:&v134 objects:v144 count:16];
          if (v79) {
            continue;
          }
          break;
        }
      }

LABEL_129:
      uint64_t v89 = v13;
      id v11 = v118;
      if (!v17) {
        [v118 associateAssetIdsToPreserve:v77];
      }
      v90 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v118 assetIdsToPreserve]);
      uint64_t v92 = stringWithoutNewlines((uint64_t)v91);
      uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue(v92);
      uint64_t v94 = -[NSString initWithFormat:](v90, "initWithFormat:", @"Preserving asset types / identifiers: %@", v93);
      id v77 = v124;
      +[MADActivityManager noticeForActivity:reason:]( &OBJC_CLASS___MADActivityManager,  "noticeForActivity:reason:",  v12,  v94);

      [v12 extendLogLeader:@"preserving" withValue:@"YES"];
      uint64_t v10 = v119;
      uint64_t v14 = v121;
      uint64_t v13 = v89;
      char v73 = v127;
    }

    if ((a3 & 0x4000000000LL) == 0) {
      goto LABEL_139;
    }
  }

  else
  {
    id v17 = 0LL;
    if ((a3 & 0x4000000000LL) == 0) {
      goto LABEL_139;
    }
  }

  if (!v17)
  {
    if (xpc_dictionary_get_BOOL(v10, "pallasEnabled"))
    {
      [v11 associatePallasEnabled:1];
      else {
        v95 = @"NO";
      }
      [v12 extendLogLeader:@"pallasEnabled" withValue:v95];
    }

    goto LABEL_140;
  }

LABEL_139:
  if (!v17)
  {
LABEL_140:
    if ((a3 & 0x100000000000LL) != 0)
    {
      v96 = v73;
      v97 = objc_claimAutoreleasedReturnValue( +[ControlManager getStringFromXpcMessage:forKey:]( &OBJC_CLASS___ControlManager,  "getStringFromXpcMessage:forKey:",  v10,  "serverUrlOverride"));

      if (v97)
      {
        [v11 associateServerUrl:v97];
        uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue([v11 serverUrl]);
        [v12 extendLogLeader:@"serverUrlOverride" withValue:v98];

        id v17 = 0LL;
        uint64_t v14 = (__CFString *)v97;
      }

      else
      {
        id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Client request missing key:%@",  @"serverUrlOverride");
        uint64_t v14 = 0LL;
      }

      char v73 = v96;
    }

    else
    {
      id v17 = 0LL;
    }
  }

  if ((a3 & 0x8000000000000LL) != 0 && !v17)
  {
    uint64_t v99 = xpc_dictionary_get_uint64(v10, (const char *)[@"_UnarchivedSize" UTF8String]);
    if (v99)
    {
      [v11 associateUnarchiveSize:v99];
      uint64_t v100 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"%lld",  [v11 unarchiveSize]);
      [v12 extendLogLeader:@"_UnarchivedSize" withValue:v100];
    }
  }

  if ((a3 & 0x1000000000000LL) != 0 && !v17)
  {
    uint64_t v101 = xpc_dictionary_get_uint64(v10, "GCOverrideDays");
    if (v101)
    {
      [v11 associateReturnTypes:v101];
      uint64_t v102 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"%llu",  [v11 returnTypes]);
      [v12 extendLogLeader:@"GCOverrideDays" withValue:v102];
    }
  }

  if ((a3 & 8) != 0 && !v17 && xpc_dictionary_get_BOOL(v10, "NSUrlState"))
  {
    [v11 associateCleanupInFlightDownloads:1];
    else {
      char v103 = @"NO";
    }
    [v12 extendLogLeader:@"NSUrlState" withValue:v103];
  }

  if ((a3 & 0x2000000000LL) != 0 && !v17)
  {
    SecKeyRef v104 = objc_claimAutoreleasedReturnValue( +[ControlManager getStringFromXpcMessage:forKey:]( &OBJC_CLASS___ControlManager,  "getStringFromXpcMessage:forKey:",  v10,  "pallasUrl"));

    if (v104) {
      uint64_t v14 = (__CFString *)v104;
    }
    else {
      uint64_t v14 = &stru_355768;
    }
    [v11 associatePallasUrl:v14];
    uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue([v11 pallasUrl]);
    [v12 extendLogLeader:@"pallasUrl" withValue:v105];
  }

  if ((a3 & 0x4000000000LL) == 0 || v17)
  {
    if (v17) {
      goto LABEL_182;
    }
  }

  else
  {
    uint64_t v106 = objc_claimAutoreleasedReturnValue( +[ControlManager getStringFromXpcMessage:forKey:]( &OBJC_CLASS___ControlManager,  "getStringFromXpcMessage:forKey:",  v10,  "pallasAudience"));

    if (v106) {
      uint64_t v14 = (__CFString *)v106;
    }
    else {
      uint64_t v14 = &stru_355768;
    }
    [v11 associatePallasAudience:v14];
    uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v11 pallasAudience]);
    [v12 extendLogLeader:@"pallasAudience" withValue:v107];
  }

  if ((a3 & 0x20000000) != 0)
  {
    uint64_t v108 = v14;
    uint64_t v109 = objc_opt_class(&OBJC_CLASS___MAAbsoluteAssetId);
    uint64_t v110 = loadDecodeClasses();
    uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue(v110);
    v129 = 0LL;
    uint64_t v112 = (void *)objc_claimAutoreleasedReturnValue( -[ControlManager decodeXpcObject:ofClass:dataKey:lengthKey:decodeClasses:error:]( v73,  "decodeXpcObject:ofClass:dataKey:lengthKey:decodeClasses:error:",  v10,  v109,  @"loadAssetId",  @"loadAssetIdLength",  v111,  &v129));
    uint64_t v113 = v129;

    if (v113)
    {
      id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to decode absolute asset identifier with error:%@",  v113);
    }

    else if (v112)
    {
      [v11 associateAbsoluteId:v112];
      uint64_t v114 = (void *)objc_claimAutoreleasedReturnValue([v112 summary]);
      [v12 extendLogLeader:@"loadAssetId" withValue:v114];

      id v17 = 0LL;
    }

    else
    {
      id v17 = @"Failed to decode absolute asset identifier";
    }

    uint64_t v14 = v108;
  }

  else
  {
    id v17 = 0LL;
  }

LABEL_182:
  uint64_t v115 = v17;
  return v115;
}

void __epochToDate_block_invoke(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  dispatch_queue_t v2 = (void *)dateFormatter;
  dateFormatter = (uint64_t)v1;

  objc_msgSend((id)dateFormatter, "setDateFormat:", @"EEEE, MMM d, yyyy hh:mm:ss a");
}

id assetIdDisallowedCharacterSet()
{
  if (assetIdDisallowedCharacterSet_once != -1) {
    dispatch_once(&assetIdDisallowedCharacterSet_once, &__block_literal_global_638);
  }
  return (id)assetIdDisallowedCharacterSet_disallowedSet;
}

void __assetIdDisallowedCharacterSet_block_invoke(id a1)
{
  id v1 = objc_autoreleasePoolPush();
  dispatch_queue_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @"0123456789abcdefABCDEF"));
  uint64_t v3 = objc_claimAutoreleasedReturnValue([v2 invertedSet]);
  id v4 = (void *)assetIdDisallowedCharacterSet_disallowedSet;
  assetIdDisallowedCharacterSet_disallowedSet = v3;

  objc_autoreleasePoolPop(v1);
}

void __assetTypeDisallowedCharacterSet_block_invoke(id a1)
{
  id v1 = objc_autoreleasePoolPush();
  dispatch_queue_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @"0123456789.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"));
  uint64_t v3 = objc_claimAutoreleasedReturnValue([v2 invertedSet]);
  id v4 = (void *)assetTypeDisallowedCharacterSet_disallowedSet;
  assetTypeDisallowedCharacterSet_disallowedSet = v3;

  objc_autoreleasePoolPop(v1);
}

id tokenFileDisallowedCharacterSet()
{
  if (tokenFileDisallowedCharacterSet_once != -1) {
    dispatch_once(&tokenFileDisallowedCharacterSet_once, &__block_literal_global_645);
  }
  return (id)tokenFileDisallowedCharacterSet_disallowedSet;
}

void __tokenFileDisallowedCharacterSet_block_invoke(id a1)
{
  id v1 = objc_autoreleasePoolPush();
  dispatch_queue_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @"0123456789.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-/"));
  uint64_t v3 = objc_claimAutoreleasedReturnValue([v2 invertedSet]);
  id v4 = (void *)tokenFileDisallowedCharacterSet_disallowedSet;
  tokenFileDisallowedCharacterSet_disallowedSet = v3;

  objc_autoreleasePoolPop(v1);
}

id purposeDisallowedCharacterSet()
{
  if (purposeDisallowedCharacterSet_once != -1) {
    dispatch_once(&purposeDisallowedCharacterSet_once, &__block_literal_global_648);
  }
  return (id)purposeDisallowedCharacterSet_disallowedSet;
}

void __purposeDisallowedCharacterSet_block_invoke(id a1)
{
  id v1 = objc_autoreleasePoolPush();
  dispatch_queue_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @"0123456789-abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"));
  uint64_t v3 = objc_claimAutoreleasedReturnValue([v2 invertedSet]);
  id v4 = (void *)purposeDisallowedCharacterSet_disallowedSet;
  purposeDisallowedCharacterSet_disallowedSet = v3;

  objc_autoreleasePoolPop(v1);
}

id purposeIgnoredCharacterSet()
{
  if (purposeIgnoredCharacterSet_once != -1) {
    dispatch_once(&purposeIgnoredCharacterSet_once, &__block_literal_global_651);
  }
  return (id)purposeIgnoredCharacterSet_ignoredSet;
}

void __purposeIgnoredCharacterSet_block_invoke(id a1)
{
  id v1 = objc_autoreleasePoolPush();
  uint64_t v2 = objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @";'\\/@?%*|<>.{}"));
  uint64_t v3 = (void *)purposeIgnoredCharacterSet_ignoredSet;
  purposeIgnoredCharacterSet_ignoredSet = v2;

  objc_autoreleasePoolPop(v1);
}

id supportedAssetFormatsArray()
{
  if (supportedAssetFormatsArray_orderedOnceToken != -1) {
    dispatch_once(&supportedAssetFormatsArray_orderedOnceToken, &__block_literal_global_667);
  }
  return (id)supportedAssetFormatsArray___orderedCompressionTypes;
}

void __supportedAssetFormatsArray_block_invoke(id a1)
{
  id v1 = _MAPreferencesCopyValue(@"SupportedAssetFormats");
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  if (v2)
  {
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSArray);
    if ((objc_opt_isKindOfClass(v2, v3) & 1) != 0)
    {
      uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      id v9 = v2;
      id v10 = [v9 countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (v10)
      {
        id v15 = v10;
        uint64_t v16 = *(void *)v32;
        do
        {
          id v17 = 0LL;
          do
          {
            if (*(void *)v32 != v16) {
              objc_enumerationMutation(v9);
            }
            uint64_t v18 = *(void *)(*((void *)&v31 + 1) + 8LL * (void)v17);
            if (v18 && (uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v18, v19) & 1) != 0)) {
              -[NSMutableArray addObject:](v8, "addObject:", v18);
            }
            else {
              _MobileAssetLog( 0LL,  3,  (uint64_t)"supportedAssetFormatsArray_block_invoke",  @"SupportedAssetFormats: Found unexpected non-string item in SupportedAssetFormats preferences, dropping entry",  v11,  v12,  v13,  v14,  v30);
            }
            id v17 = (char *)v17 + 1;
          }

          while (v15 != v17);
          id v15 = [v9 countByEnumeratingWithState:&v31 objects:v35 count:16];
        }

        while (v15);
      }

      if (v8 && -[NSMutableArray count](v8, "count"))
      {
        objc_storeStrong((id *)&supportedAssetFormatsArray___orderedCompressionTypes, v8);
        unsigned __int8 v20 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( (id)supportedAssetFormatsArray___orderedCompressionTypes,  "componentsJoinedByString:",  @", "));
        _MobileAssetLog( 0LL,  6,  (uint64_t)"supportedAssetFormatsArray_block_invoke",  @"SupportedAssetFormats: Using preferences override supported asset format types: [%@]",  v21,  v22,  v23,  v24,  (uint64_t)v20);
      }
    }

    else
    {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"supportedAssetFormatsArray_block_invoke",  @"SupportedAssetFormats: Found unexpected non-array type in SupportedAssetFormats preferences, dropping preference",  v4,  v5,  v6,  v7,  v30);
    }
  }

  if (!supportedAssetFormatsArray___orderedCompressionTypes)
  {
    supportedAssetFormatsArray___orderedCompressionTypes = (uint64_t)&off_38FBB0;

    uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( (id)supportedAssetFormatsArray___orderedCompressionTypes,  "componentsJoinedByString:",  @", "));
    _MobileAssetLog( 0LL,  6,  (uint64_t)"supportedAssetFormatsArray_block_invoke",  @"SupportedAssetFormats: Using default supported asset format types: [%@]",  v26,  v27,  v28,  v29,  (uint64_t)v25);
  }
}

id getObjectFromMessageWithFailureReason(void *a1, const char *a2, const char *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a4;
  size_t length = (unint64_t)xpc_dictionary_get_double(v9, a2);
  if (length)
  {
    CFAbsoluteTime data = xpc_dictionary_get_data(v9, a3, &length);
    if (data)
    {
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", data, length));
      if (!v12)
      {
        if (a5)
        {
          uint64_t v19 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v16 = 0LL;
          *a5 =  -[NSString initWithFormat:]( v19,  "initWithFormat:",  @"Failed to get NSData object from message for key:%s length:%lld bytes",  a3,  length);
        }

        else
        {
          uint64_t v16 = 0LL;
        }

        goto LABEL_23;
      }

      id v22 = 0LL;
      uint64_t v13 = -[NSKeyedUnarchiver initForReadingFromData:error:]( objc_alloc(&OBJC_CLASS___NSKeyedUnarchiver),  "initForReadingFromData:error:",  v12,  &v22);
      id v14 = v22;
      if (v14 || !v13)
      {
        if (!a5)
        {
          uint64_t v16 = 0LL;
          goto LABEL_22;
        }

        id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Could not decode object for key:%s error:%@",  a3,  v14);
      }

      else
      {
        uint64_t v15 = objc_claimAutoreleasedReturnValue( -[NSKeyedUnarchiver decodeObjectOfClasses:forKey:]( v13,  "decodeObjectOfClasses:forKey:",  v10,  NSKeyedArchiveRootObjectKey));
        uint64_t v16 = (void *)v15;
        if (!a5 || v15) {
          goto LABEL_22;
        }
        id v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to decode object for key:%s",  a3,  v21);
      }

      uint64_t v16 = 0LL;
      *a5 = v17;
LABEL_22:
      -[NSKeyedUnarchiver finishDecoding](v13, "finishDecoding");

LABEL_23:
      goto LABEL_24;
    }

    if (a5)
    {
      uint64_t v18 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Failed to get object from message since key:%s is not present",  a3,  v21);
      goto LABEL_13;
    }

id getObjectFromMessage(void *a1, const char *a2, const char *a3, void *a4)
{
  return getObjectFromMessageLogIfDesired(a1, a2, a3, a4, 1);
}

uint64_t calculateTimeout( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (((unint64_t)a1 >> 10) * (unsigned __int128)0x2492492492492493uLL) >> 64;
  if (a1 > 0x102661BFFLL) {
    uint64_t v8 = 604800LL;
  }
  if (a1 >= 6451200) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 900LL;
  }
  _MobileAssetLog( 0LL,  6,  (uint64_t)"calculateTimeout",  @"Calculated the download timeout to be %ld hrs %ld mins %ld secs (%ld) for size %lld",  a5,  a6,  a7,  a8,  ((unint64_t)v9 * (unsigned __int128)0x123456789ABCE0uLL) >> 64);
  return v9;
}

BOOL determineUnarchiveSizeFromMessage(void *a1, uint64_t *a2)
{
  id v3 = a1;
  string = xpc_dictionary_get_string(v3, (const char *)[@"_UnarchivedSize" UTF8String]);

  if (string) {
    *a2 = strtoll(string, 0LL, 10);
  }
  return string != 0LL;
}

void ensureAndIncrementNumberAtKey(void *a1, void *a2, void *a3)
{
  id v16 = a1;
  id v5 = a2;
  id v10 = a3;
  if (v16 && v5)
  {
    uint64_t v11 = objc_claimAutoreleasedReturnValue([v16 objectForKey:v5]);
    uint64_t v12 = (void *)v11;
    if (v10)
    {
      uint64_t v13 = (char *)[v10 longValue];
      if (v12) {
        goto LABEL_5;
      }
    }

    else
    {
      uint64_t v13 = (_BYTE *)(&dword_0 + 1);
      if (v11)
      {
LABEL_5:
        id v14 = -[NSNumber initWithLong:]( [NSNumber alloc],  "initWithLong:",  &v13[(void)[v12 longValue]]);

        if (!v14) {
          goto LABEL_11;
        }
        goto LABEL_10;
      }
    }

    id v14 = -[NSNumber initWithLong:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithLong:", v13);
    if (v14)
    {
LABEL_10:
      [v16 setObject:v14 forKey:v5];
    }
  }

  else
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"ensureAndIncrementNumberAtKey",  @"in ensureAndIncrementNumberAtKey nil dict or key value, skipped",  v6,  v7,  v8,  v9,  v15);
  }

uint64_t isCatalogTaskDescriptor(void *a1)
{
  return isTypeDescriptorOfType(a1, 1);
}

uint64_t isPmvTaskDescriptor(void *a1)
{
  return isTypeDescriptorOfType(a1, 3);
}

id getAutoAssetJobIDFromTaskDescriptor(void *a1)
{
  if (a1)
  {
    id v1 = disassembleTaskDescriptor(a1);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
    id v3 = v2;
    if (v2) {
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKey:@"AutoAssetJob"]);
    }
    else {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  return v4;
}

id assembleTaskDescriptorWithPurpose(uint64_t a1, uint64_t a2, void *a3)
{
  return assembleTaskDescriptorWithPurposeAndAutoAssetJobID(a1, a2, a3, 0LL);
}

id assembleTaskDescriptorWithPurposeAndAutoAssetJobID(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@%@%@",  a1,  @".",  a2));
  if (v7)
  {
    id v10 = normalizePurpose(v7);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);

    uint64_t v12 = objc_claimAutoreleasedReturnValue([v9 stringByAppendingFormat:@"%@%@", @".", v11]);
    uint64_t v9 = (void *)v12;
  }

  if (v8)
  {
    if ([v8 containsString:@"."])
    {
      _MobileAssetLog( 0LL,  3,  (uint64_t)"assembleTaskDescriptorWithPurposeAndAutoAssetJobID",  @"{assembleTaskDescriptorWithPurposeAndAutoAssetJobID} invalid autoAssetJobID(ignored):%@",  v13,  v14,  v15,  v16,  (uint64_t)v8);
    }

    else
    {
      uint64_t v17 = objc_claimAutoreleasedReturnValue([v9 stringByAppendingFormat:@"%@%@", @".", v8]);

      uint64_t v9 = (void *)v17;
    }
  }

  return v9;
}

CFStringRef convertGarbageCollectionOperationToString(uint64_t a1)
{
  id v1 = @"<reason>";
  if (a1 == 1) {
    id v1 = @"ReclaimSpace";
  }
  if (a1) {
    return v1;
  }
  else {
    return @"DetermineReclaimable";
  }
}

id getPathToPmvFile(uint64_t a1)
{
  if (a1)
  {
    id RepositoryPath = getRepositoryPath(@"/private/var/MobileAsset/AssetsV2");
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v2));
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 URLByAppendingPathComponent:@"AppleSoftwareLookup.json" isDirectory:0]);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  return v4;
}

id purposeDirectoryName(void *a1)
{
  if (a1)
  {
    id v1 = normalizePurpose(a1);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"purpose_%@", v2));
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

NSString *getAssetDirectoryName(uint64_t a1)
{
  return +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@.%@", a1, @"asset");
}

BOOL isWellFormedAssetId(void *a1)
{
  id v1 = a1;
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    && (unint64_t)[v1 length] >= 0x14
    && (unint64_t)[v1 length] <= 0x3C)
  {
    id v5 = assetIdDisallowedCharacterSet();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    BOOL v3 = [v1 rangeOfCharacterFromSet:v6] == (id)0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}

BOOL isWellFormedSystemBuildId(void *a1)
{
  id v1 = a1;
  if (v1
    && (uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    && (unint64_t)[v1 length] >= 0x14
    && (unint64_t)[v1 length] <= 0x64)
  {
    id v5 = assetTypeDisallowedCharacterSet();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    BOOL v3 = [v1 rangeOfCharacterFromSet:v6] == (id)0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}

BOOL isWellFormedNormalizedAssetType(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"));
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue([v2 invertedSet]);

  BOOL v6 = v1
    && (uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v1, v4) & 1) != 0)
    && [v1 hasPrefix:@"com_apple_MobileAsset_"]
    && (id v5 = [v1 length], v5 > objc_msgSend(@"com_apple_MobileAsset_", "length"))
    && [v1 rangeOfCharacterFromSet:v3] == (id)0x7FFFFFFFFFFFFFFFLL;

  return v6;
}

uint64_t isWellFormedTokenFileName(void *a1)
{
  id v5 = a1;
  if (v5)
  {
    uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v5, v6) & 1) != 0)
    {
      if ((unint64_t)[v5 length] >= 5 && (unint64_t)objc_msgSend(v5, "length") <= 0x80)
      {
        id v10 = tokenFileDisallowedCharacterSet();
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
        id v12 = [v5 rangeOfCharacterFromSet:v11];

        if (v12 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          if ([v5 hasSuffix:@".tok"])
          {
            uint64_t v8 = 1LL;
            goto LABEL_9;
          }

          id v7 = @"TokenFileName passed in has an invalid file suffix";
        }

        else
        {
          id v7 = @"TokenFileName passed in contains invalid characters in string";
        }
      }

      else
      {
        id v7 = @"TokenFileName passed in has an invalid length";
      }
    }

    else
    {
      id v7 = @"TokenFileName passed in is not a string";
    }
  }

  else
  {
    id v7 = @"TokenFileName passed in was null";
  }

  _MobileAssetLog(0LL, 3, (uint64_t)"isWellFormedTokenFileName", v7, v1, v2, v3, v4, v13);
  uint64_t v8 = 0LL;
LABEL_9:

  return v8;
}

id getSupportedAnalyticsEventFields()
{
  if (getSupportedAnalyticsEventFields_supportedAnalyticsEventsFieldsOnce != -1) {
    dispatch_once(&getSupportedAnalyticsEventFields_supportedAnalyticsEventsFieldsOnce, &__block_literal_global_759);
  }
  return (id)getSupportedAnalyticsEventFields_supportedAnalyticsEventsFields;
}

void __getSupportedAnalyticsEventFields_block_invoke(id a1)
{
  uint64_t v1 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", &off_38FBC8);
  uint64_t v2 = (void *)getSupportedAnalyticsEventFields_supportedAnalyticsEventsFields;
  getSupportedAnalyticsEventFields_supportedAnalyticsEventsFields = (uint64_t)v1;
}

id isSupportedMAAnalyticsEventFieldName(void *a1)
{
  id v5 = a1;
  if (v5 && (uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v5, v6) & 1) != 0))
  {
    id SupportedAnalyticsEventFields = getSupportedAnalyticsEventFields();
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(SupportedAnalyticsEventFields);
    id v9 = [v8 containsObject:v5];
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"isSupportedMAAnalyticsEventFieldName",  @"%s: Field is invalid",  v1,  v2,  v3,  v4,  (uint64_t)"isSupportedMAAnalyticsEventFieldName");
    id v9 = 0LL;
  }

  return v9;
}

uint64_t usingCentralizedCachedelete()
{
  if (usingCentralizedCachedelete_onceToken != -1) {
    dispatch_once(&usingCentralizedCachedelete_onceToken, &__block_literal_global_818);
  }
  return usingCentralizedCachedelete_eapfsEnabled;
}

void __usingCentralizedCachedelete_block_invoke(id a1)
{
  if (_MAPreferencesIsCentralizedCacheDeleteEnabled())
  {
    io_registry_entry_t v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/filesystems");
    if (v1)
    {
      io_object_t v2 = v1;
      CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v1, @"e-apfs", kCFAllocatorDefault, 0);
      if (CFProperty)
      {
        CFRelease(CFProperty);
        usingCentralizedCachedelete_eapfsEnabled = 1;
      }

      IOObjectRelease(v2);
    }
  }

  else
  {
    usingCentralizedCachedelete_eapfsEnabled = 0;
  }

BOOL isDirStatsEnabledForDirectory(void *a1)
{
  id v1 = a1;
  int v2 = fsctl((const char *)[v1 UTF8String], 0xC1104A71uLL, v12, 0);
  if (v2)
  {
    __error();
    _MobileAssetLog( 0LL,  3,  (uint64_t)"isDirStatsEnabledForDirectory",  @"Unable to check dirstats for directory %@, error %i",  v3,  v4,  v5,  v6,  (uint64_t)v1);
  }

  else if (_MAPreferencesIsVerboseLoggingEnabled())
  {
    _MobileAssetLog( 0LL,  6,  (uint64_t)"isDirStatsEnabledForDirectory",  @"%@:\ndescendants: %llu\nphysical size: %llu\ngen-count: %llu\n",  v7,  v8,  v9,  v10,  (uint64_t)v1);
  }

  return v2 == 0;
}

BOOL enableDirStatsForDirectory(void *a1)
{
  DWORD1(v8[0]) = 1;
  id v1 = a1;
  int v2 = fsctl((const char *)[v1 UTF8String], 0xC1104A71uLL, v8, 0);
  if (v2)
  {
    __error();
    _MobileAssetLog( 0LL,  3,  (uint64_t)"enableDirStatsForDirectory",  @"Unable to enable dirstats for directory %@, error %i",  v3,  v4,  v5,  v6,  (uint64_t)v1);
  }

  return v2 == 0;
}

BOOL markItemPurgeableWithFlagsAndStartTime(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  if (![v6 fileExistsAtPath:@"/private/var/MobileSoftwareUpdate/.MAAMigrated.plist"])
  {

    goto LABEL_6;
  }

  BOOL v7 = isDirStatsEnabledForDirectory(v5);

  if (!v7)
  {
LABEL_6:
    BOOL v14 = 0LL;
    goto LABEL_7;
  }

  uint64_t v27 = 0LL;
  id v8 = v5;
  if (fsctl((const char *)[v8 UTF8String], 0xC0084A44uLL, &v27, 0))
  {
    uint64_t v9 = __error();
    _MobileAssetLog( 0LL,  3,  (uint64_t)"markItemPurgeableWithFlagsAndStartTime",  @"Failed to clear purgability, errno:%d",  v10,  v11,  v12,  v13,  *v9);
    goto LABEL_6;
  }

  uint64_t v22 = a2;
  __int128 v23 = xmmword_27EEE0;
  uint64_t v24 = 0LL;
  uint64_t v25 = a3;
  uint64_t v26 = 0LL;
  int v16 = fsctl((const char *)[v8 UTF8String], 0xC0304A6FuLL, &v22, 0);
  BOOL v14 = v16 == 0;
  if (v16)
  {
    uint64_t v17 = __error();
    _MobileAssetLog( 0LL,  3,  (uint64_t)"markItemPurgeableWithFlagsAndStartTime",  @"Failed to mark purgeable with label, errno:%d",  v18,  v19,  v20,  v21,  *v17);
  }

BOOL markItemPurgeableWithUrgencyAndGarbageCollectionPolicy(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  BOOL v7 = v6;
  if (!v6) {
    goto LABEL_6;
  }
  if (![v6 isEqualToString:@"NeverCollected"])
  {
    if ([v7 isEqualToString:@"Precious"])
    {
      uint64_t v13 = 2678400000000000LL;
LABEL_7:
      __uint64_t v14 = clock_gettime_nsec_np(_CLOCK_REALTIME);
      BOOL started = markItemPurgeableWithFlagsAndStartTime(v5, a2 | 0x10000, v14 + v13);
      goto LABEL_8;
    }

BOOL markAssetPurgeable(void *a1)
{
  return markItemPurgeableWithUrgencyAndGarbageCollectionPolicy(a1, 512LL, @"Default");
}

BOOL markLockedAssetPurgeable(void *a1)
{
  return markItemPurgeableWithUrgencyAndGarbageCollectionPolicy(a1, 0x8000LL, @"Default");
}

void __getSoftwareUpdateTypes_block_invoke(id a1)
{
  id v1 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", &off_38FBE0);
  int v2 = (void *)getSoftwareUpdateTypes_softwareUpdateAssetTypes;
  getSoftwareUpdateTypes_softwareUpdateAssetTypes = (uint64_t)v1;
}

uint64_t getIsKnoxSupportedFromPallasURL(void *a1)
{
  id v1 = a1;
  int v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  @"https://gdmf.apple.com/v2/assets"));
  if ([v1 isEqual:v2])
  {
    uint64_t v3 = 0LL;
  }

  else
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  @"https://gdmf.apple.com/assets"));
    unsigned int v5 = [v1 isEqual:v4];

    uint64_t v3 = v5 ^ 1;
  }

  return v3;
}

uint64_t urlSupportsAuthenticatedPallas(void *a1)
{
  id v1 = a1;
  id v6 = v1;
  if (urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallasDispatchOnce == -1)
  {
    if (v1) {
      goto LABEL_3;
    }
LABEL_19:
    __int128 v23 = "urlSupportsAuthenticatedPallas";
    uint64_t v20 = @"[AuthenticatedPallas]: Invalid url passed to %s";
    goto LABEL_20;
  }

  dispatch_once( &urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallasDispatchOnce,  &__block_literal_global_838);
  if (!v6) {
    goto LABEL_19;
  }
LABEL_3:
  if (!urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallas)
  {
    uint64_t v20 = @"[AuthenticatedPallas]: domainsSupportingAuthenticatedPallas not initialized";
LABEL_20:
    _MobileAssetLog(0LL, 3, (uint64_t)"urlSupportsAuthenticatedPallas", v20, v2, v3, v4, v5, (uint64_t)v23);
    uint64_t v21 = 0LL;
    goto LABEL_21;
  }

  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  id v7 = (id)urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallas;
  id v8 = [v7 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v25;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v24 + 1) + 8LL * (void)i);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v6 scheme]);
        if ([v13 isEqualToString:@"https"])
        {
          __uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v6 host]);
          unsigned int v15 = [v14 isEqualToString:v12];

          if (v15)
          {
            _MobileAssetLog( 0LL,  5,  (uint64_t)"urlSupportsAuthenticatedPallas",  @"[AuthenticatedPallas]: URL %@ supports authenticated pallas",  v16,  v17,  v18,  v19,  (uint64_t)v6);
            uint64_t v21 = 1LL;
            goto LABEL_17;
          }
        }

        else
        {
        }
      }

      id v9 = [v7 countByEnumeratingWithState:&v24 objects:v28 count:16];
    }

    while (v9);
  }

  uint64_t v21 = 0LL;
LABEL_17:

LABEL_21:
  return v21;
}

void __urlSupportsAuthenticatedPallas_block_invoke(id a1)
{
  id v1 = -[NSMutableSet initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableSet), "initWithArray:", &off_38FBF8);
  uint64_t v2 = (void *)urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallas;
  urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallas = (uint64_t)v1;

  if (os_variant_has_internal_content("com.apple.MobileAssetSSO"))
  {
    uint64_t v3 = _MAPreferencesCopyNSStringValue(@"AdditionalAuthenticatedPallasServer");
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    if (v4)
    {
      id v9 = v4;
      _MobileAssetLog( 0LL,  5,  (uint64_t)"urlSupportsAuthenticatedPallas_block_invoke",  @"[AuthenticatedPallas]: {urlSupportsAuthenticatedPallas} Adding %@ to set of domains supporting authenticated pallas",  v5,  v6,  v7,  v8,  (uint64_t)v4);
      [(id)urlSupportsAuthenticatedPallas_domainsSupportingAuthenticatedPallas addObject:v9];
      uint64_t v4 = v9;
    }
  }

id getLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose(void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a4;
  id v19 = a5;
  if (!v9)
  {
    __int128 v27 = @"Attempting to get local url with nil asset type";
LABEL_9:
    _MobileAssetLog( 0LL,  3,  (uint64_t)"getLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose",  v27,  v15,  v16,  v17,  v18,  v44);
    uint64_t v28 = 0LL;
    __int128 v25 = 0LL;
LABEL_12:
    uint64_t v30 = 0LL;
    goto LABEL_13;
  }

  if (!v10)
  {
    __int128 v27 = @"Attempting to get local url with nil asset id";
    goto LABEL_9;
  }

  id v20 = normalizedAssetType((uint64_t)v9, v12, v13, v14, v15, v16, v17, v18);
  __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(v20);
  if (!v25)
  {
    uint64_t v29 = @"Attempting to get local URL with asset-type that could not be normalized";
LABEL_11:
    _MobileAssetLog( 0LL,  3,  (uint64_t)"getLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose",  v29,  v21,  v22,  v23,  v24,  v44);
    uint64_t v28 = 0LL;
    goto LABEL_12;
  }

  if (a3 == 5)
  {
    __int128 v26 = @"/System/Library/PreinstalledAssetsV2/RequiredByOs";
    goto LABEL_15;
  }

  if (a3 != 6)
  {
    if (v11)
    {
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v11));
      goto LABEL_18;
    }

    uint64_t v29 = @"Attempting to get local url with nil default repo for a non preinstalled asset";
    goto LABEL_11;
  }

  __int128 v26 = @"/private/var/MobileAsset/PreinstalledAssetsV2/InstallWithOs";
LABEL_15:
  id RepositoryPath = getRepositoryPath(v26);
  __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v34));

LABEL_18:
  id v36 = (void *)objc_claimAutoreleasedReturnValue([v35 URLByAppendingPathComponent:v25]);

  if (v19)
  {
    id v37 = purposeDirectoryName(v19);
    id v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
    uint64_t v39 = objc_claimAutoreleasedReturnValue([v36 URLByAppendingPathComponent:v38]);

    id v36 = (void *)v39;
  }

  unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  v10,  @"asset"));
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v40 stringByAppendingPathComponent:@"AssetData"]);

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v36 URLByAppendingPathComponent:v30]);
  if (v19)
  {
    id v41 = purposeDirectoryName(v19);
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
    uint64_t v43 = objc_claimAutoreleasedReturnValue([v28 URLByAppendingPathComponent:v42]);

    uint64_t v28 = (void *)v43;
  }

id getAutoLocalUrlFromTypeGivenDefaultRepoWithPurpose(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a3;
  id v16 = a4;
  if (!v7)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"getAutoLocalUrlFromTypeGivenDefaultRepoWithPurpose",  @"Attempting to get local URL with nil asset-type",  v12,  v13,  v14,  v15,  v33);
    uint64_t v24 = 0LL;
    uint64_t v22 = 0LL;
    goto LABEL_15;
  }

  id v17 = normalizedAssetType((uint64_t)v7, v9, v10, v11, v12, v13, v14, v15);
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v17);
  if (!v22)
  {
    __int128 v25 = @"Attempting to get local URL with asset-type that could not be normalized";
LABEL_8:
    _MobileAssetLog(0LL, 3, (uint64_t)"getAutoLocalUrlFromTypeGivenDefaultRepoWithPurpose", v25, v18, v19, v20, v21, v33);
    uint64_t v24 = 0LL;
    goto LABEL_15;
  }

  if (a2 == 5)
  {
    uint64_t v23 = @"/System/Library/PreinstalledAssetsV2/RequiredByOs";
    goto LABEL_10;
  }

  if (a2 == 6)
  {
    uint64_t v23 = @"/private/var/MobileAsset/PreinstalledAssetsV2/InstallWithOs";
LABEL_10:
    id RepositoryPath = getRepositoryPath(v23);
    __int128 v27 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v27));

    goto LABEL_13;
  }

  if (!v8)
  {
    __int128 v25 = @"Attempting to get local url with nil default repo for a non preinstalled asset";
    goto LABEL_8;
  }

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v8));
LABEL_13:
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v28 URLByAppendingPathComponent:v22]);

  if (v16)
  {
    id v29 = purposeDirectoryName(v16);
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    uint64_t v31 = objc_claimAutoreleasedReturnValue([v24 URLByAppendingPathComponent:v30]);

    uint64_t v24 = (void *)v31;
  }

id getAutoLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose( void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a4;
  id v19 = a5;
  if (!v9)
  {
    __int128 v27 = @"Attempting to get local url with nil asset type";
LABEL_9:
    _MobileAssetLog( 0LL,  3,  (uint64_t)"getAutoLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose",  v27,  v15,  v16,  v17,  v18,  v39);
    uint64_t v28 = 0LL;
    __int128 v25 = 0LL;
    goto LABEL_19;
  }

  if (!v10)
  {
    __int128 v27 = @"Attempting to get local url with nil asset id";
    goto LABEL_9;
  }

  id v20 = normalizedAssetType((uint64_t)v9, v12, v13, v14, v15, v16, v17, v18);
  __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(v20);
  if (!v25) {
    goto LABEL_18;
  }
  if (a3 == 5)
  {
    __int128 v26 = @"/System/Library/PreinstalledAssetsV2/RequiredByOs";
    goto LABEL_11;
  }

  if (a3 != 6)
  {
    if (v11)
    {
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v11));
      goto LABEL_14;
    }

    _MobileAssetLog( 0LL,  3,  (uint64_t)"getAutoLocalUrlFromTypeAndIdGivenDefaultRepoWithPurpose",  @"Attempting to get local url with nil default repo for a non preinstalled asset",  v21,  v22,  v23,  v24,  v39);
LABEL_18:
    uint64_t v28 = 0LL;
    goto LABEL_19;
  }

  __int128 v26 = @"/private/var/MobileAsset/PreinstalledAssetsV2/InstallWithOs";
LABEL_11:
  id RepositoryPath = getRepositoryPath(v26);
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(RepositoryPath);
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v30));

LABEL_14:
  __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v31 URLByAppendingPathComponent:v25]);

  if (v19)
  {
    id v33 = purposeDirectoryName(v19);
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
    uint64_t v35 = objc_claimAutoreleasedReturnValue([v32 URLByAppendingPathComponent:v34]);

    __int128 v32 = (void *)v35;
  }

  id v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  v10,  @"asset"));
  id v37 = (void *)objc_claimAutoreleasedReturnValue([v32 URLByAppendingPathComponent:v36]);

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v37 URLByAppendingPathComponent:@"AssetData"]);
LABEL_19:

  return v28;
}

NSMutableArray *filterPMV(void *a1, int a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  id v13 = a1;
  id v64 = a3;
  id v58 = a4;
  id v59 = a5;
  id v60 = a6;
  id v61 = a7;
  uint64_t v66 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  context = objc_autoreleasePoolPush();
  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v62 = v13;
  if ((objc_opt_isKindOfClass(v13, v14) & 1) != 0)
  {
    uint64_t v129 = 0LL;
    v130 = &v129;
    uint64_t v131 = 0x2020000000LL;
    uint64_t v132 = 0LL;
    uint64_t v125 = 0LL;
    v126 = &v125;
    uint64_t v127 = 0x2020000000LL;
    uint64_t v128 = 0LL;
    uint64_t v121 = 0LL;
    v122 = &v121;
    uint64_t v123 = 0x2020000000LL;
    uint64_t v124 = 0LL;
    uint64_t v117 = 0LL;
    uint64_t v118 = &v117;
    uint64_t v119 = 0x2020000000LL;
    uint64_t v120 = 0LL;
    uint64_t v113 = 0LL;
    uint64_t v114 = &v113;
    uint64_t v115 = 0x2020000000LL;
    uint64_t v116 = 0LL;
    uint64_t v109 = 0LL;
    uint64_t v110 = &v109;
    uint64_t v111 = 0x2020000000LL;
    uint64_t v112 = 0LL;
    uint64_t v104 = 0LL;
    uint64_t v105 = 0LL;
    uint64_t v106 = &v105;
    uint64_t v107 = 0x2020000000LL;
    uint64_t v108 = 0LL;
    uint64_t v101 = 0LL;
    uint64_t v102 = &v101;
    uint64_t v103 = 0x2020000000LL;
    uint64_t v97 = 0LL;
    uint64_t v98 = &v97;
    uint64_t v99 = 0x2020000000LL;
    uint64_t v100 = 0LL;
    uint64_t v93 = 0LL;
    uint64_t v94 = &v93;
    uint64_t v95 = 0x2020000000LL;
    uint64_t v96 = 0LL;
    uint64_t v89 = 0LL;
    v90 = &v89;
    uint64_t v91 = 0x2020000000LL;
    uint64_t v92 = 0LL;
    uint64_t v15 = objc_opt_new(&OBJC_CLASS___NSDateFormatter);
    -[NSDateFormatter setDateFormat:](v15, "setDateFormat:", @"yyyy-MM-dd");
    uint64_t v51 = v15;
    uint64_t v16 = @"PublicAssetSets";
    if (a2) {
      uint64_t v16 = @"AssetSets";
    }
    uint64_t v53 = v16;
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKey:"));
    uint64_t v18 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    int isKindOfClass = objc_opt_isKindOfClass(v17, v18);
    if ((isKindOfClass & 1) == 0)
    {

      uint64_t v17 = 0LL;
    }

    if (v64 && (uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v64, v19) & 1) != 0))
    {
      id v20 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKey:v64]);
      if (v20 && (uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSArray), (objc_opt_isKindOfClass(v20, v21) & 1) != 0))
      {
        -[NSMutableArray addObjectsFromArray:](v66, "addObjectsFromArray:", v20);
        int v54 = 0;
      }

      else
      {
        int v54 = 1;
      }

      char v23 = 1;
    }

    else
    {
      char v23 = 0;
      int v54 = 0;
    }

    __int128 v87 = 0u;
    __int128 v88 = 0u;
    __int128 v85 = 0u;
    __int128 v86 = 0u;
    id v24 = v17;
    id v25 = [v24 countByEnumeratingWithState:&v85 objects:v133 count:16];
    if (v25)
    {
      uint64_t v65 = 0LL;
      uint64_t v67 = 0LL;
      uint64_t v26 = *(void *)v86;
      do
      {
        for (uint64_t i = 0LL; i != v25; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v86 != v26) {
            objc_enumerationMutation(v24);
          }
          uint64_t v28 = *(void **)(*((void *)&v85 + 1) + 8LL * (void)i);
          id v29 = objc_autoreleasePoolPush();
          uint64_t v30 = objc_opt_class(&OBJC_CLASS___NSString);
          if ((objc_opt_isKindOfClass(v28, v30) & 1) != 0)
          {
            uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKey:v28]);
            uint64_t v32 = objc_opt_class(&OBJC_CLASS___NSArray);
            if ((objc_opt_isKindOfClass(v31, v32) & 1) != 0)
            {
              if ((v23 & 1) == 0) {
                -[NSMutableArray addObjectsFromArray:](v66, "addObjectsFromArray:", v31);
              }
              if ([v28 isEqual:@"iOS"])
              {
                v67 += (uint64_t)[v31 count];
              }

              else if ([v28 isEqual:@"macOS"])
              {
                v65 += (uint64_t)[v31 count];
              }
            }
          }

          objc_autoreleasePoolPop(v29);
        }

        id v25 = [v24 countByEnumeratingWithState:&v85 objects:v133 count:16];
      }

      while (v25);
    }

    else
    {
      uint64_t v65 = 0LL;
      uint64_t v67 = 0LL;
    }

    id v33 = [v24 count];
    int v34 = v54;
    if (!v33) {
      int v34 = 1;
    }
    int v55 = v34;
    v68[0] = _NSConcreteStackBlock;
    v68[1] = 3221225472LL;
    v68[2] = __filterPMV_block_invoke;
    v68[3] = &unk_3501E0;
    id v35 = v58;
    id v69 = v35;
    uint64_t v74 = &v125;
    uint64_t v75 = &v109;
    id v36 = v59;
    id v70 = v36;
    id v76 = &v89;
    id v77 = &v93;
    id v78 = &v105;
    id v79 = &v121;
    id v37 = v60;
    id v71 = v37;
    id v38 = v51;
    id v72 = v38;
    id v80 = &v117;
    __int128 v81 = &v101;
    id v39 = v61;
    id v73 = v39;
    __int128 v82 = &v113;
    __int128 v83 = &v97;
    __int128 v84 = &v129;
    unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSPredicate predicateWithBlock:](&OBJC_CLASS___NSPredicate, "predicateWithBlock:", v68));
    id v41 = -[NSMutableArray count](v66, "count");
    -[NSMutableArray filterUsingPredicate:](v66, "filterUsingPredicate:", v40);
    id v42 = -[NSMutableArray count](v66, "count");
    unsigned int v52 = v38;
    if (a8)
    {
      id v43 = v42;
      uint64_t v44 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSMutableString stringWithCapacity:]( &OBJC_CLASS___NSMutableString,  "stringWithCapacity:",  500LL));
      uint64_t v22 = v44;
      id v45 = @"public";
      if (a2) {
        id v45 = @"supervised";
      }
      -[__CFString appendFormat:]( v44,  "appendFormat:",  @"Filtered PMV to %ld/%ld entries (from %@: %ld iOS, %ld macOS) using [",  v43,  v41,  v45,  v67,  v65);
      uint64_t v46 = @"false";
      if (a2) {
        uint64_t v46 = @"true";
      }
      -[__CFString appendFormat:](v22, "appendFormat:", @"includeSupervised: %@ ", v46);
      if (v64) {
        -[__CFString appendFormat:](v22, "appendFormat:", @" platformExactMatch: %@", v64);
      }
      if (v35) {
        -[__CFString appendFormat:](v22, "appendFormat:", @" versionPrefix: %@", v35);
      }
      if (v36) {
        -[__CFString appendFormat:](v22, "appendFormat:", @" supportedDevicePrefix: %@", v36);
      }
      if (v37) {
        -[__CFString appendFormat:](v22, "appendFormat:", @" postedBefore: %@", v37);
      }
      if (v39) {
        -[__CFString appendFormat:](v22, "appendFormat:", @" notExpiredBefore: %@", v39);
      }
      -[__CFString appendFormat:](v22, "appendFormat:", @"].");
      uint64_t v47 = v130[3];
      if ((v47 > 0) | (isKindOfClass ^ 1 | v55) & 1)
      {
        if (v47) {
          -[__CFString appendFormat:](v22, "appendFormat:", @" Filtered out %ld due to", v130[3]);
        }
        if (v126[3]) {
          -[__CFString appendFormat:](v22, "appendFormat:", @" ProductVersion: %ld", v126[3]);
        }
        if (v122[3]) {
          -[__CFString appendFormat:](v22, "appendFormat:", @" SupportedDevices: %ld", v122[3]);
        }
        if (v118[3]) {
          -[__CFString appendFormat:](v22, "appendFormat:", @" PostingDate: %ld", v118[3]);
        }
        if (v114[3]) {
          -[__CFString appendFormat:](v22, "appendFormat:", @" ExpirationDate: %ld", v114[3]);
        }
        if (((isKindOfClass ^ 1 | v55) & 1) != 0 || v110[3] || v106[3] || v102[3] || v98[3])
        {
          -[__CFString appendFormat:](v22, "appendFormat:", @" -- ISSUES: ");
          if ((isKindOfClass & 1) == 0) {
            -[__CFString appendFormat:](v22, "appendFormat:", @" missingSet: %@", v53);
          }
          char v48 = v55 ^ 1;
          if (!v64) {
            char v48 = 1;
          }
          if ((v48 & 1) != 0)
          {
            if (v55) {
              -[__CFString appendFormat:](v22, "appendFormat:", @" missingAllPlatforms");
            }
          }

          else
          {
            -[__CFString appendFormat:](v22, "appendFormat:", @" missingPlatform: %@", v64);
          }

          if (v110[3] || v106[3] || v94[3] || v102[3] || v98[3])
          {
            -[__CFString appendFormat:]( v22,  "appendFormat:",  @" -- Some entries missed potential filtering due to");
            if (v110[3]) {
              -[__CFString appendFormat:](v22, "appendFormat:", @" missingProductVersion: %ld", v110[3]);
            }
            if (v106[3]) {
              -[__CFString appendFormat:](v22, "appendFormat:", @" missingSupportedDevices: %ld", v106[3]);
            }
            if (v94[3]) {
              -[__CFString appendFormat:](v22, "appendFormat:", @" emptySupportedDevices: %ld", v94[3]);
            }
            if (v102[3]) {
              -[__CFString appendFormat:](v22, "appendFormat:", @" missingPostingDate: %ld", v102[3]);
            }
            if (v98[3]) {
              -[__CFString appendFormat:](v22, "appendFormat:", @" missingExpirationDate: %ld", v98[3]);
            }
          }

          if (v90[3]) {
            -[__CFString appendFormat:]( v22,  "appendFormat:",  @" -- filtering saw a total of %ld individual SupportedDevices that were nil or not strings",  v90[3]);
          }
        }
      }
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    _Block_object_dispose(&v89, 8);
    _Block_object_dispose(&v93, 8);
    _Block_object_dispose(&v97, 8);
    _Block_object_dispose(&v101, 8);
    _Block_object_dispose(&v105, 8);
    _Block_object_dispose(&v109, 8);
    _Block_object_dispose(&v113, 8);
    _Block_object_dispose(&v117, 8);
    _Block_object_dispose(&v121, 8);
    _Block_object_dispose(&v125, 8);
    _Block_object_dispose(&v129, 8);
  }

  else
  {
    uint64_t v22 = @"Filtered PMV to 0/0 entries. PMV was not a dictionary.";
  }

  objc_autoreleasePoolPop(context);
  if (a8) {
    *a8 = v22;
  }

  return v66;
}

void sub_1DC234( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
}

uint64_t __filterPMV_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    if ((objc_opt_isKindOfClass(v5, v7) & 1) != 0)
    {
      id v8 = v5;
      uint64_t v9 = *(void *)(a1 + 32);
      if (v9)
      {
        uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0)
        {
          id v11 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKey:@"ProductVersion"]);
          if (v11 && (uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v11, v12) & 1) != 0))
          {
            if (([v11 hasPrefix:*(void *)(a1 + 32)] & 1) == 0)
            {
              ++*(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL);
LABEL_43:

              goto LABEL_10;
            }
          }

          else
          {
            ++*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL);
          }
        }
      }

      uint64_t v16 = *(void *)(a1 + 40);
      if (v16)
      {
        uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v16, v17) & 1) != 0)
        {
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKey:@"SupportedDevices"]);
          if (v18 && (uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSArray), (objc_opt_isKindOfClass(v18, v19) & 1) != 0))
          {
            id v36 = v8;
            id v37 = v18;
            __int128 v40 = 0u;
            __int128 v41 = 0u;
            __int128 v38 = 0u;
            __int128 v39 = 0u;
            id v20 = v18;
            id v21 = [v20 countByEnumeratingWithState:&v38 objects:v42 count:16];
            if (v21)
            {
              id v22 = v21;
              char v23 = 0;
              uint64_t v24 = *(void *)v39;
              do
              {
                for (uint64_t i = 0LL; i != v22; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v39 != v24) {
                    objc_enumerationMutation(v20);
                  }
                  uint64_t v26 = *(void **)(*((void *)&v38 + 1) + 8LL * (void)i);
                  uint64_t v27 = objc_opt_class(&OBJC_CLASS___NSString);
                  if ((objc_opt_isKindOfClass(v26, v27) & 1) != 0)
                  {
                  }

                  else
                  {
                    ++*(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL);
                  }
                }

                id v22 = [v20 countByEnumeratingWithState:&v38 objects:v42 count:16];
              }

              while (v22);
            }

            else
            {
              char v23 = 0;
            }

            if (![v20 count]) {
              ++*(void *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL);
            }
            uint64_t v18 = v37;
            if ((v23 & 1) != 0)
            {

              id v8 = v36;
              goto LABEL_38;
            }
          }

          else
          {
            ++*(void *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL);
          }

          ++*(void *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 24LL);
LABEL_32:

          goto LABEL_10;
        }
      }

__CFString *stringForMAAssetState(unint64_t a1)
{
  if (a1 >= 7) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAAssetState%llu",  a1));
  }
  else {
    return *(&off_3502B0 + a1);
  }
}

__CFString *stringForMAXpcError(unint64_t a1)
{
  if (a1 >= 9) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAXpcError%llu",  a1));
  }
  else {
    return *(&off_350460 + a1);
  }
}

CFStringRef stringForAnalyticsReportingLevel(uint64_t a1)
{
  id v1 = @"<undefined-level>";
  uint64_t v2 = @"MADAnalyticsLevelUnchanged";
  uint64_t v3 = @"MADAnalyticsLevelImmediate";
  if (a1 != 10) {
    uint64_t v3 = @"<undefined-level>";
  }
  if (a1) {
    uint64_t v2 = v3;
  }
  if (a1 == -10) {
    id v1 = @"MADAnalyticsLevelDoNotSend";
  }
  if (a1 == -20) {
    id v1 = @"MADAnalyticsLevelDoNotSave";
  }
  if (a1 < 0) {
    return v1;
  }
  else {
    return v2;
  }
}

CFStringRef stringForCacheDeleteUrgency(int a1)
{
  if (a1 > 4) {
    return @"BEYOND-EMERGENCY";
  }
  return *(&off_3504A8 + a1);
}

__CFString *allocStringForBytes(uint64_t a1)
{
  if (!a1) {
    return @"0 bytes";
  }
  uint64_t v2 = &stru_355768;
  if (a1 >= 0)
  {
    uint64_t v3 = a1;
  }

  else
  {
    uint64_t v2 = @"NEGATIVE ";
    uint64_t v3 = a1 + 0x3FFFFFFF;
  }

  uint64_t v4 = v2;
  uint64_t v5 = a1 - (v3 & 0xFFFFFFFFC0000000LL);
  else {
    uint64_t v6 = v5 + 0xFFFFF;
  }
  uint64_t v7 = v5 - (v6 & 0xFFFFFFFFFFF00000LL);
  else {
    uint64_t v8 = v7 + 1023;
  }
  uint64_t v9 = v7 - (v8 & 0xFFFFFFFFFFFFFC00LL);
  if (v9 == 1)
  {
    uint64_t v10 = @" 1 byte";
  }

  else if (v9 < 2)
  {
    uint64_t v10 = &stru_355768;
  }

  else
  {
    uint64_t v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @" %lld bytes",  v7 - (v8 & 0xFFFFFFFFFFFFFC00LL));
  }

  uint64_t v12 = v6 >> 20;
  if (a1 < 0x40000000)
  {
    if (v5 < 0x100000)
    {
      uint64_t v14 = objc_alloc(&OBJC_CLASS___NSString);
      if (v7 < 1024) {
        id v13 = -[NSString initWithFormat:](v14, "initWithFormat:", @"%@%lld bytes", v4, a1, v16, v17, v18);
      }
      else {
        id v13 = -[NSString initWithFormat:](v14, "initWithFormat:", @"%@%lldKB%@", v4, v8 >> 10, v10, v17, v18);
      }
    }

    else
    {
      id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@%lldMB %lldKB%@",  v4,  v12,  v8 >> 10,  v10,  v18);
    }
  }

  else
  {
    id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@%lldGB %lldMB %lldKB%@",  v4,  v3 >> 30,  v12,  v8 >> 10,  v10);
  }

  uint64_t v15 = v13;

  return (__CFString *)v15;
}

__CFString *stringForMAOperationResult(unint64_t a1)
{
  if (a1 >= 6) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAOperationResult%llu",  a1));
  }
  else {
    return *(&off_3504D0 + a1);
  }
}

__CFString *stringForMADownloadResult(unint64_t a1)
{
  if (a1 >= 0x56) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MADownloadResult%llu",  a1));
  }
  else {
    return *(&off_350500 + a1);
  }
}

__CFString *stringForMACancelDownloadResult(unint64_t a1)
{
  if (a1 >= 8) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MACancelDownloadResult%llu",  a1));
  }
  else {
    return *(&off_3507B0 + a1);
  }
}

__CFString *stringForMAPurgeResult(unint64_t a1)
{
  if (a1 >= 0xD) {
    return (__CFString *)(id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MAPurgeResult%llu",  a1));
  }
  else {
    return *(&off_3507F0 + a1);
  }
}

id errorStringForMACancelDownloadResult(unint64_t a1)
{
  if (a1 >= 8)
  {
    uint64_t v3 = stringForMACancelDownloadResult(a1);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Download failed due to Error %lld (%@).",  a1,  v4));
  }

  else
  {
    uint64_t v2 = *(&off_350858 + a1);
  }

  return v2;
}

id errorStringForMADownloadResult(unint64_t a1)
{
  if (a1 >= 0x56)
  {
    uint64_t v3 = stringForMADownloadResult(a1);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Download failed due to Error %lld (%@).",  a1,  v4));
  }

  else
  {
    uint64_t v2 = *(&off_350898 + a1);
  }

  return v2;
}

CFStringRef stringForSecureMABundleCommand(int a1)
{
  else {
    return *(&off_350B48 + a1 - 2);
  }
}

id MAErrorWithUnderlyingUserInfoAndString(void *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v14 = v13;
  if (v12) {
    -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v12, NSLocalizedDescriptionKey);
  }
  if (v10) {
    -[NSMutableDictionary setObject:forKey:](v14, "setObject:forKey:", v10, NSUnderlyingErrorKey);
  }
  if (v11)
  {
    uint64_t v25 = a2;
    id v26 = v10;
    id v27 = v9;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id v15 = v11;
    id v16 = [v15 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = *(void *)v29;
      do
      {
        uint64_t v19 = 0LL;
        do
        {
          if (*(void *)v29 != v18) {
            objc_enumerationMutation(v15);
          }
          uint64_t v20 = *(void *)(*((void *)&v28 + 1) + 8LL * (void)v19);
          id v21 = objc_autoreleasePoolPush();
          id v22 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKey:v20]);
          -[NSMutableDictionary setObject:forKey:](v14, "setObject:forKey:", v22, v20);

          objc_autoreleasePoolPop(v21);
          uint64_t v19 = (char *)v19 + 1;
        }

        while (v17 != v19);
        id v17 = [v15 countByEnumeratingWithState:&v28 objects:v32 count:16];
      }

      while (v17);
    }

    id v10 = v26;
    id v9 = v27;
    a2 = v25;
  }

  char v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v9,  a2,  v14));

  return v23;
}

id MAError( void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = a3;
  id v12 = a1;
  id v13 = -[NSString initWithFormat:arguments:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:arguments:", v11, &a9);

  id v14 = MAErrorWithUnderlyingUserInfoAndString(v12, a2, 0LL, 0LL, v13);
  id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);

  return v15;
}

id MAErrorWithUnderlying( void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v12 = a4;
  id v13 = a3;
  id v14 = a1;
  id v15 = -[NSString initWithFormat:arguments:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:arguments:", v12, &a9);

  id v16 = MAErrorWithUnderlyingUserInfoAndString(v14, a2, v13, 0LL, v15);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

  return v17;
}

BOOL isDownloadResultFailure(uint64_t a1)
{
  if (a1) {
    BOOL v1 = a1 == 14;
  }
  else {
    BOOL v1 = 1;
  }
  return !v1;
}

uint64_t downloadResultForNetworkFailure(int a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1 <= 399)
  {
    uint64_t v8 = 3LL;
    uint64_t v7 = 47LL;
    if (a1 == 200 || a1 == 206 || a1 == 304)
    {
LABEL_22:
      if (!v5) {
        goto LABEL_67;
      }
    }

    else
    {
LABEL_8:
      uint64_t v9 = 47LL;
      uint64_t v10 = 42LL;
      if (a1 < 0) {
        uint64_t v10 = 3LL;
      }
      else {
        uint64_t v9 = 42LL;
      }
      if (a1 <= 499) {
        uint64_t v7 = v9;
      }
      else {
        uint64_t v7 = 45LL;
      }
      if (a1 <= 499) {
        uint64_t v8 = v10;
      }
      else {
        uint64_t v8 = 45LL;
      }
      if (!v5) {
        goto LABEL_67;
      }
    }

LABEL_66:
      uint64_t v8 = v7;
      goto LABEL_67;
    }

    id v13 = [v5 code];
    id v14 = 0LL;
    id v15 = 0LL;
    switch((unint64_t)v13)
    {
      case 0xFFFFFFFFFFFFFC04LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 69LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC05LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 68LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC06LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 67LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC07LL:
      case 0xFFFFFFFFFFFFFC08LL:
      case 0xFFFFFFFFFFFFFC09LL:
      case 0xFFFFFFFFFFFFFC0ALL:
      case 0xFFFFFFFFFFFFFC0BLL:
      case 0xFFFFFFFFFFFFFC0CLL:
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC0DLL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 50LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC0ELL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 66LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC0FLL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 65LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC10LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 64LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC11LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 63LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC12LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 62LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC13LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 61LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC14LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 60LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC15LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 59LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC16LL:
        id v14 = 0LL;
        id v15 = 0LL;
        uint64_t v7 = 58LL;
        goto LABEL_65;
      case 0xFFFFFFFFFFFFFC17LL:
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v5 userInfo]);
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKey:@"_kCFStreamErrorCodeKey"]);

        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v5 userInfo]);
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKey:@"_kCFStreamErrorDomainKey"]);

        if (v14
          && (uint64_t v20 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v14, v20) & 1) != 0)
          && v15
          && (uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v15, v21) & 1) != 0))
        {
          id v22 = [v14 integerValue];
          if ([v15 integerValue] == &dword_4)
          {
            switch((unint64_t)v22)
            {
              case 0xFFFFFFFFFFFFF7C6LL:
                uint64_t v7 = 56LL;
                break;
              case 0xFFFFFFFFFFFFF7C7LL:
                uint64_t v7 = 55LL;
                break;
              case 0xFFFFFFFFFFFFF7C8LL:
                uint64_t v7 = 54LL;
                break;
              case 0xFFFFFFFFFFFFF7C9LL:
                uint64_t v7 = 53LL;
                break;
              case 0xFFFFFFFFFFFFF7CALL:
                uint64_t v7 = 52LL;
                break;
              default:
                goto LABEL_62;
            }

            goto LABEL_65;
          }
        }

        else if (v6)
        {
          if ([v6 currentTotalWritten])
          {
            if ([v6 numStalled])
            {
              id v23 = [v6 numStalled];
              if (v23 == [v6 numNoLongerStalled]) {
                uint64_t v7 = 83LL;
              }
              else {
                uint64_t v7 = 81LL;
              }
            }

            else
            {
              uint64_t v7 = 82LL;
            }
          }

          else
          {
            uint64_t v7 = 80LL;
          }

          goto LABEL_65;
        }

LABEL_67:
  return v8;
}

uint64_t resultForGraftOrUngraft(int a1, int a2)
{
  uint64_t v2 = 3LL;
  if (!a1) {
    uint64_t v2 = 4LL;
  }
  uint64_t v3 = 5LL;
  if (!a1) {
    uint64_t v3 = 6LL;
  }
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

BOOL isDownloadResultSuggestingCheckClockAndCerts(uint64_t a1)
{
  return a1 == 70;
}

uint64_t isDownloadResultSuggestingCheckTimeoutConditions(uint64_t a1)
{
  return ((unint64_t)(a1 - 51) < 0x21) & (0x1E0000037uLL >> (a1 - 51));
}

uint64_t isDownloadResultSuggestingCheckNetwork(uint64_t a1)
{
  return ((unint64_t)(a1 - 54) < 0xF) & (0x6DC9u >> (a1 - 54));
}

BOOL isDownloadResultSuggestingTryAgainLater(uint64_t a1)
{
  BOOL result = 1LL;
  return result;
}

BOOL isDownloadResultSuggestingCheckConfiguration(uint64_t a1)
{
  BOOL result = 1LL;
  return result;
}

id MAErrorForCancelDownloadResultWithUnderlying( unint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = a3;
  id v12 = a2;
  if (v11)
  {
    id v13 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);
  }

  else
  {
    id v14 = errorStringForMACancelDownloadResult(a1);
    id v13 = (NSString *)objc_claimAutoreleasedReturnValue(v14);
  }

  id v15 = v13;
  id v16 = MAErrorWithUnderlyingUserInfoAndString(@"com.apple.MobileAssetError.CancelDownload", a1, a2, 0LL, v13);
  unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

  return v17;
}

id MAErrorForDownloadResultWithUnderlying( unint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = a2;
  id v12 = a3;
  if (v12)
  {
    id v13 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v12,  &a9);
  }

  else
  {
    id v14 = errorStringForMADownloadResult(a1);
    id v13 = (NSString *)objc_claimAutoreleasedReturnValue(v14);
  }

  id v15 = v13;
  id v16 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  unsigned int v17 = v16;
  if ((uint64_t)a1 <= 27)
  {
    if (a1 - 14 < 2 || !a1 || a1 == 10)
    {
LABEL_10:
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"usableDownload");
      if (a1 == 10 || a1 == 28)
      {
LABEL_12:
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"requeryIsHelpful");
        if (a1 <= 0x2D && ((1LL << a1) & 0x260000000000LL) != 0) {
LABEL_14:
        }
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"checkServer");
      }
    }

uint64_t xpcRequestFieldsRequired(unsigned int a1)
{
  if (a1 > 0x2F) {
    return 2049LL;
  }
  else {
    return qword_27EF78[a1];
  }
}

uint64_t xpcRequestFieldsOptional(unsigned int a1)
{
  if (a1 > 0x2F) {
    return 0LL;
  }
  else {
    return qword_27F0F8[a1];
  }
}

id safeAtomicWriteToPath(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  if (!v4)
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"safeAtomicWriteToPath",  @"Invalid path passed to %s",  v5,  v6,  v7,  v8,  (uint64_t)"safeAtomicWriteToPath");
LABEL_13:
    id v21 = 0LL;
    goto LABEL_16;
  }

  if (!v3
    || (uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSDictionary), (objc_opt_isKindOfClass(v3, v10) & 1) == 0)
    && (uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSData), (objc_opt_isKindOfClass(v3, v11) & 1) == 0)
    && (uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v3, v12) & 1) == 0))
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"safeAtomicWriteToPath",  @"Invalid data passed to %s",  v5,  v6,  v7,  v8,  (uint64_t)"safeAtomicWriteToPath");
    goto LABEL_13;
  }

  id v13 = (void *)objc_claimAutoreleasedReturnValue([v4 stringByDeletingLastPathComponent]);
  id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
  id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 UUIDString]);
  id v16 = (void *)objc_claimAutoreleasedReturnValue([v13 stringByAppendingPathComponent:v15]);

  if ([v3 writeToFile:v16 atomically:0]
    && !rename( (const char *)[v16 fileSystemRepresentation], (const char *)objc_msgSend(v4, "fileSystemRepresentation")))
  {
    id v21 = &dword_0 + 1;
  }

  else
  {
    _MobileAssetLog( 0LL,  3,  (uint64_t)"safeAtomicWriteToPath",  @"%s: Failed to write item to path %@",  v17,  v18,  v19,  v20,  (uint64_t)"safeAtomicWriteToPath");
    id v21 = 0LL;
    if ([v9 fileExistsAtPath:v16 isDirectory:0])
    {
      id v27 = 0LL;
      [v9 removeItemAtPath:v16 error:&v27];
      id v21 = v27;
      if (v21)
      {
        _MobileAssetLog( 0LL,  3,  (uint64_t)"safeAtomicWriteToPath",  @"%s: Atomic write to path failed and failed to remove temp path(%@): %@",  v22,  v23,  v24,  v25,  (uint64_t)"safeAtomicWriteToPath");

        id v21 = 0LL;
      }
    }
  }

LABEL_16:
  return v21;
}

void sub_1E01CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

uint64_t __Block_byref_object_copy__16(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
}

void sub_1E0780( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_1E0CA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1E128C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_1E1820( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_1E1D90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

LABEL_68:
      uint64_t v20 = v147;
      uint64_t v57 = a12;
    }

    if (v58 < v57)
    {
      v90 = objc_claimAutoreleasedReturnValue( +[MAAutoAssetError buildError:fromOperation:underlyingError:withDescription:]( &OBJC_CLASS___MAAutoAssetError,  "buildError:fromOperation:underlyingError:withDescription:",  6109LL,  @"AUTO-LOCKER:endLocksByClient",  0LL,  @"cannot accept ended locks when fewer locks exist than requested unlock count"));

      __int128 v39 = (id)v90;
    }

    if (v39)
    {
LABEL_72:
      uint64_t v89 = 0;
      goto LABEL_106;
    }
  }

  v151 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v175 = 0u;
  v176 = 0u;
  v177 = 0u;
  v178 = 0u;
  objb = (id)objc_claimAutoreleasedReturnValue([v56 lockReasons]);
  uint64_t v91 = [objb countByEnumeratingWithState:&v175 objects:v200 count:16];
  if (!v91) {
    goto LABEL_92;
  }
  uint64_t v92 = v91;
  uint64_t v93 = 0LL;
  v161 = *(void *)v176;
  while (2)
  {
    for (k = 0LL; k != v92; k = (char *)k + 1)
    {
      if (*(void *)v176 != v161) {
        objc_enumerationMutation(objb);
      }
      uint64_t v95 = *(void *)(*((void *)&v175 + 1) + 8LL * (void)k);
      uint64_t v96 = objc_autoreleasePoolPush();
      uint64_t v97 = (void *)objc_claimAutoreleasedReturnValue([v56 lockReasons]);
      uint64_t v98 = [v97 safeObjectForKey:v95 ofClass:objc_opt_class(MAAutoAssetLockTracker)];
      uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue(v98);

      uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v99 clientLockReason]);
      uint64_t v101 = v100;
      if (!a4)
      {
        uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([v100 autoAssetClientName]);
        uint64_t v103 = +[SUCore stringIsEqual:to:](&OBJC_CLASS___SUCore, "stringIsEqual:to:", v170, v102);

        uint64_t v57 = a12;
        if (!v103) {
          goto LABEL_88;
        }
      }

      if (v57 != -1)
      {
        uint64_t v104 = [v99 activeLockCount];
        uint64_t v105 = [v99 activeLockCount];
        if ((uint64_t)v104 > v57)
        {
          [v99 setActiveLockCount:(char *)v105 - v57];
          v93 += v57;

          uint64_t v99 = 0LL;
          goto LABEL_86;
        }

        v93 += (int64_t)v105;
      }

      if (v99) {
        -[NSMutableDictionary setSafeObject:forKey:](v151, "setSafeObject:forKey:", v99, v95);
      }
LABEL_86:
      if (v57 != -1 && v93 >= v57)
      {

        objc_autoreleasePoolPop(v96);
        goto LABEL_92;
      }

    __break(0x5513u);
    goto LABEL_69;
  }

  uint64_t v9 = *v6;
  uint64_t v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3LL;
  }
  uint64_t v8 = 0LL;
  BOOL result = 3LL;
  while (v7 >= 2)
  {
    uint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    uint64_t v12 = (char *)(v6 + 1);
    --v7;
    id v13 = *v6;
    uint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3LL;
      }
      goto LABEL_20;
    }
  }

  return result;
}

LABEL_92:
  v173 = 0u;
  v174 = 0u;
  v171 = 0u;
  v172 = 0u;
  uint64_t v106 = v151;
  uint64_t v107 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v106,  "countByEnumeratingWithState:objects:count:",  &v171,  v199,  16LL);
  if (v107)
  {
    uint64_t v108 = v107;
    uint64_t v109 = *(void *)v172;
    do
    {
      for (m = 0LL; m != v108; m = (char *)m + 1)
      {
        if (*(void *)v172 != v109) {
          objc_enumerationMutation(v106);
        }
        uint64_t v111 = *(void *)(*((void *)&v171 + 1) + 8LL * (void)m);
        uint64_t v112 = (void *)objc_claimAutoreleasedReturnValue([v56 lockReasons]);
        [v112 removeObjectForKey:v111];
      }

      uint64_t v108 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v106,  "countByEnumeratingWithState:objects:count:",  &v171,  v199,  16LL);
    }

    while (v108);
  }

  uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v56 lockReasons]);
  uint64_t v114 = [v113 count];

  if (v114)
  {
    uint64_t v115 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([v56 lockReasons]);
    uint64_t v117 = -[NSString initWithFormat:]( v115,  "initWithFormat:",  @"client ended specified number of locks (or all locks) for all lock-reasons | assetLock.lockReasons:%ld",  [v116 count]);
    -[MADAutoAssetLocker _persistAssetLock:operation:forAssetLock:message:]( v158,  "_persistAssetLock:operation:forAssetLock:message:",  @"_endLocksByClient",  @"ENTRY_MODIFY",  v56,  v117);

    else {
      uint64_t v118 = 250LL;
    }
    uint64_t v119 = -[MADAutoAssetLocker _currentLockCountOfLock:](v158, "_currentLockCountOfLock:", v56);
    uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue(-[MADAutoAssetLocker _assetIDOfLock:](v158, "_assetIDOfLock:", v56));
    +[MADAutoAssetHistory recordOperation:toHistoryType:fromClient:usageCount:forAssetID:withSelector:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordOperation:toHistoryType:fromClient:usageCount:forAssetID:withSelector:",  v118,  1LL,  v170,  v119,  v120,  v165);
  }

  else
  {
    -[MADAutoAssetLocker _removeAssetLock:lastClient:forSelector:message:]( v158,  "_removeAssetLock:lastClient:forSelector:message:",  v56,  v170,  v165,  @"endedLock for all reasons [specific count] (all locks have ended)");
  }

  __int128 v39 = 0LL;
  uint64_t v89 = 1;
  uint64_t v20 = v147;
LABEL_106:

  uint64_t v17 = v149;
  uint64_t v18 = 0LL;
  uint64_t v19 = v154;
LABEL_122:
  v140 = (void *)objc_claimAutoreleasedReturnValue(+[SUCoreLog sharedLogger](&OBJC_CLASS___SUCoreLog, "sharedLogger"));
  v141 = (os_log_s *)objc_claimAutoreleasedReturnValue([v140 oslog]);

  if (v39)
  {
    if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
    {
      v145 = (void *)objc_claimAutoreleasedReturnValue([v165 summary]);
      *(_DWORD *)buf = 138544130;
      v192 = v170;
      v193 = 2114;
      v194 = v145;
      v195 = 2114;
      v196 = v164;
      v197 = 2114;
      v198 = (int64_t)v39;
      _os_log_error_impl( &dword_0,  v141,  OS_LOG_TYPE_ERROR,  "{AUTO-LOCKER:_endLocksByClient} failed end-lock(s) | client:%{public}@, selector:%{public}@, reason:%{public}@ | error:%{public}@",  buf,  0x2Au);
    }

    +[MADAutoAssetHistory recordFailedOperation:fromClient:forAssetID:withSelector:failingWithError:]( &OBJC_CLASS___MADAutoAssetHistory,  "recordFailedOperation:fromClient:forAssetID:withSelector:failingWithError:",  502LL,  v170,  @"UNKNOWN",  v165,  v39);
    if (a13) {
      *a13 = v39;
    }
    v142 = v165;
  }

  else
  {
    v142 = v165;
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      v143 = (void *)objc_claimAutoreleasedReturnValue([v165 summary]);
      *(_DWORD *)buf = 138544130;
      v192 = v170;
      v193 = 2114;
      v194 = v143;
      v195 = 2114;
      v196 = v164;
      v197 = 2048;
      v198 = a12;
      _os_log_impl( &dword_0,  v141,  OS_LOG_TYPE_DEFAULT,  "{AUTO-LOCKER:_endLocksByClient} successful end-lock(s) | client:%{public}@, selector:%{public}@, reason:%{public }@, ended locks:%ld",  buf,  0x2Au);
    }

    uint64_t v89 = 1;
  }

  return v89;
}

void sub_1E3278( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1E3B18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1E3CF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1E4EB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1E711C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_54:
        id v58 = v20;
        goto LABEL_61;
      }

      id v21 = [v20 secureCodedObjectForKey:@"assetLock" ofClass:objc_opt_class(MAAutoAssetLock) encodeClasses:v94];
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      uint64_t v23 = v22;
      if (!v22)
      {
        __int128 v83 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) logger]);
        __int128 v84 = (os_log_s *)objc_claimAutoreleasedReturnValue([v83 oslog]);

        log = (NSMutableArray *)v84;
        if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          uint64_t v121 = v100;
          __int128 v85 = v84;
          __int128 v86 = "{currentSetLockUsageEliminatingOtherThanSetAtomicInstances} | no asset-lock entry found for entry:%{public}@";
          goto LABEL_64;
        }

  __break(1u);
LABEL_55:
  __break(1u);
LABEL_56:
  __break(1u);
LABEL_57:
  __break(1u);
LABEL_58:
  __break(1u);
LABEL_59:
  __break(1u);
LABEL_60:
  __break(1u);
LABEL_61:
  __break(1u);
LABEL_62:
  __break(1u);
LABEL_63:
  __break(1u);
LABEL_64:
  __break(1u);
LABEL_65:
  __break(1u);
LABEL_66:
  __break(1u);
LABEL_67:
  __break(1u);
LABEL_68:
  __break(1u);
LABEL_69:
  __break(1u);
LABEL_70:
  __break(1u);
  return result;
}

void sub_1E8188( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_1E8A6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1E9210( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1E941C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1E97AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t get_aks_client_connection()
{
  if (get_aks_client_dispatch_queue_onceToken != -1) {
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_168);
  }
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_150);
  uint64_t result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }

  return result;
}

char *_iterate_path(char *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    v9[0] = result;
    v9[1] = 0LL;
    uint64_t result = (char *)fts_open(v9, 84, 0LL);
    if (result)
    {
      uint64_t v5 = (FTS *)result;
      uint64_t v6 = fts_read((FTS *)result);
      if (v6)
      {
        uint64_t v7 = v6;
        do
        {
          int fts_info = v7->fts_info;
          if (fts_info != 6)
          {
            if (fts_info == 1)
            {
              if (a2)
              {
              }
            }

            else if (a3 && fts_info == 8)
            {
              (*(void (**)(uint64_t, FTSENT *))(a3 + 16))(a3, v7);
            }
          }

          uint64_t v7 = fts_read(v5);
        }

        while (v7);
      }

      return (char *)fts_close(v5);
    }
  }

  return result;
}

void __get_aks_client_connection_block_invoke(id a1)
{
  if (!get_aks_client_connection_connection) {
    get_aks_client_connection_xpc_connection_t connection = _copy_aks_client_connection( "IOService:/IOResources/AppleKeyStore",  "AppleKeyStore");
  }
}

void __get_aks_client_dispatch_queue_block_invoke(id a1)
{
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)dispatch_queue_create("aks-client-queue", 0LL);
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  kern_return_t v5;
  CFDictionaryRef v6;
  io_service_t MatchingService;
  io_object_t v8;
  uint64_t result;
  kern_return_t v10;
  io_connect_t connect;
  connect = 0;
  io_service_t v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (!v3 || (io_object_t v4 = v3, v5 = IOServiceOpen(v3, mach_task_self_, 0, &connect), IOObjectRelease(v4), v5))
  {
    uint64_t v6 = IOServiceMatching(a2);
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
    if (MatchingService)
    {
      uint64_t v8 = MatchingService;
      IOServiceOpen(MatchingService, mach_task_self_, 0, &connect);
      IOObjectRelease(v8);
    }
  }

  uint64_t result = connect;
  if (connect)
  {
    uint64_t v10 = IOConnectCallMethod(connect, 0, 0LL, 0, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
    uint64_t result = connect;
    if (v10)
    {
      IOServiceClose(connect);
      return 0LL;
    }
  }

  return result;
}

uint64_t aks_get_dsme_key(void *a1, size_t *a2)
{
  size_t __count = 0x4000LL;
  aks_client_xpc_connection_t connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v5 = 3758097090LL;
    if (a1 && a2)
    {
      uint64_t v6 = IOConnectCallMethod(aks_client_connection, 0x96u, 0LL, 0, 0LL, 0LL, 0LL, 0LL, __src, &__count);
      if ((_DWORD)v6)
      {
        uint64_t v5 = v6;
      }

      else
      {
        uint64_t v7 = calloc(__count, 1uLL);
        *a1 = v7;
        if (v7)
        {
          size_t v8 = __count;
          *a2 = __count;
          memcpy(v7, __src, v8);
          uint64_t v5 = 0LL;
        }

        else
        {
          uint64_t v5 = 3758097085LL;
        }
      }
    }
  }

  else
  {
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_get_dsme_key",  ":",  3600,  "",  0,  "",  "");
    uint64_t v5 = 3758097084LL;
  }

  memset_s(__src, 0x4000uLL, 0, 0x4000uLL);
  return v5;
}

uint64_t _set_path_class(const char *a1, int a2, int a3, char a4)
{
  uint64_t v16 = 0LL;
  __int128 v15 = xmmword_27F2A0;
  uint64_t v14 = 0LL;
  if (getattrlist(a1, &v15, &v14, 8uLL, 0)) {
    return *__error();
  }
  if (HIDWORD(v14) == a3 || a2 != -1 && HIDWORD(v14) != a2) {
    return 0LL;
  }
  if (a2 == -1)
  {
    if ((a4 & 1) != 0) {
      fprintf(__stdoutp, "%s set %i\n");
    }
  }

  else if ((a4 & 1) != 0)
  {
    fprintf(__stdoutp, "%s update %i -> %i\n");
  }

  int v13 = a3;
  if (!setattrlist(a1, &v15, &v13, 4uLL, 0)) {
    return 0LL;
  }
  size_t v8 = __error();
  uint64_t v9 = *v8;
  uint64_t v10 = __stderrp;
  uint64_t v11 = strerror(*v8);
  fprintf(v10, "failed (%s) to update class for %s\n", v11, a1);
  return v9;
}

uint64_t aks_migrate_path(const char *a1, int a2, int a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(v18, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, v18)) {
    return 0xFFFFFFFFLL;
  }
  int v8 = a2 | 0x18;
  v14[0] = _NSConcreteStackBlock;
  if ((a2 & 0x1C) != 0) {
    int v8 = a2;
  }
  v14[1] = 0x40000000LL;
  v14[2] = __aks_migrate_path_block_invoke;
  v14[3] = &__block_descriptor_tmp;
  int v15 = v8;
  int v16 = a3;
  int v17 = a4;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = __aks_migrate_path_block_invoke_2;
  v10[3] = &__block_descriptor_tmp_16;
  int v11 = a3;
  int v12 = v8;
  int v13 = a4;
  _iterate_path(v18, (uint64_t)v14, (uint64_t)v10);
  return 0LL;
}

uint64_t __aks_migrate_path_block_invoke(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[8];
  if ((v2 & 4) != 0)
  {
    uint64_t v6 = *(const char **)(a2 + 48);
    int v4 = a1[9];
    int v5 = a1[10];
    io_service_t v3 = v6;
    goto LABEL_5;
  }

  if ((v2 & 8) != 0)
  {
    io_service_t v3 = *(const char **)(a2 + 48);
    int v4 = -1;
    int v5 = 0;
LABEL_5:
    _set_path_class(v3, v4, v5, v2);
  }

  return 1LL;
}

_DWORD *__aks_migrate_path_block_invoke_2(_DWORD *result, uint64_t a2)
{
  int v3 = result[8];
  if (v3)
  {
    int v4 = result[9];
    if ((v4 & 0x10) != 0)
    {
      if (result[10]) {
        int v5 = result[10];
      }
      else {
        int v5 = 3;
      }
      return (_DWORD *)_set_path_class(*(const char **)(a2 + 48), v3, v5, v4);
    }
  }

  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 4) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != 4) {
    return 1LL;
  }
  unsigned int v5 = 0;
  if (v5 < a2) {
    return 0xFFFFFFFFLL;
  }
  return v5 > a2;
}

uint64_t DERImg4Decode(void *a1, unint64_t a2)
{
  uint64_t result = 6LL;
  if (a1)
  {
    if (a2)
    {
      unint64_t v6 = 0LL;
      unint64_t v7 = 0LL;
      uint64_t v8 = 0LL;
      uint64_t result = DERDecodeItem((uint64_t)a1, &v6);
      if (!(_DWORD)result)
      {
        if (v6 == 0x2000000000000010LL)
        {
          uint64_t v5 = a1[1];
          if (__CFADD__(*a1, v5) || __CFADD__(v7, v8))
          {
            __break(0x5513u);
          }

          else if (*a1 + v5 == v7 + v8)
          {
            uint64_t result = DERParseSequenceContentToObject(&v7, 4u, (uint64_t)&DERImg4ItemSpecs, a2, 0x40uLL, 0LL);
            if (!(_DWORD)result) {
              return 2 * (DERImg4DecodeTagCompare(a2, 0x494D4734u) != 0);
            }
          }

          else
          {
            return 7LL;
          }
        }

        else
        {
          return 2LL;
        }
      }
    }
  }

  return result;
}

uint64_t DERImg4DecodePayloadCompression(unint64_t *a1, char **a2)
{
  unsigned int v5 = 2;
  uint64_t result = 6LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = DERParseSequenceContentToObject( a1,  2u,  (uint64_t)&DERImg4CompressionItemSpecs,  (unint64_t)a2,  0x20uLL,  0LL);
      if (!(_DWORD)result)
      {
        uint64_t result = DERParseInteger(a2, &v5);
        if (!(_DWORD)result)
        {
          if (v5 <= 1) {
            return 0LL;
          }
          else {
            return 6LL;
          }
        }
      }
    }
  }

  return result;
}

uint64_t DERImg4DecodePayloadWithProperties(uint64_t a1, unint64_t a2)
{
  uint64_t result = 6LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = DERParseSequenceToObject(a1, 7u, (uint64_t)&DERImg4PayloadWithPropertiesItemSpecs, a2, 0xA0uLL, 0LL);
      if (!(_DWORD)result)
      {
        if (DERImg4DecodeTagCompare(a2, 0x494D3450u))
        {
          return 2LL;
        }

        else if (!*(void *)(a2 + 80) {
               || (__int128 v7 = 0u,
        }
                   __int128 v8 = 0u,
                   uint64_t result = DERImg4DecodePayloadCompression((unint64_t *)(a2 + 80), (char **)&v7),
                   !(_DWORD)result))
        {
          uint64_t v6 = *(void *)(a2 + 96);
          unsigned int v5 = (void *)(a2 + 96);
          if (!v6) {
            return 0LL;
          }
          __int128 v7 = 0u;
          __int128 v8 = 0u;
          uint64_t result = (uint64_t)DERImg4DecodePayloadProperties(v5, (unint64_t)&v7);
          if (!(_DWORD)result) {
            return 0LL;
          }
        }
      }
    }
  }

  return result;
}

void *DERImg4DecodePayloadProperties(void *result, unint64_t a2)
{
  if (result)
  {
    if (!a2) {
      return (void *)(&dword_4 + 2);
    }
    if (*result && result[1])
    {
      uint64_t result = (void *)DERParseSequenceToObject( (uint64_t)result,  2u,  (uint64_t)&DERImg4PayloadPropertiesItemSpecs,  a2,  0x20uLL,  0LL);
      if ((_DWORD)result) {
        return result;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t DERImg4DecodePayload(uint64_t a1, unint64_t a2)
{
  uint64_t result = 6LL;
  if (a1 && a2)
  {
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    uint64_t result = DERImg4DecodePayloadWithProperties(a1, (unint64_t)&v11);
    if ((_DWORD)result)
    {
      uint64_t result = DERParseSequenceToObject(a1, 6u, (uint64_t)&DERImg4PayloadItemSpecs, a2, 0x90uLL, 0LL);
      if (!(_DWORD)result)
      {
        if (DERImg4DecodeTagCompare(a2, 0x494D3450u))
        {
          return 2LL;
        }

        else
        {
          uint64_t v6 = *(void *)(a2 + 80);
          unsigned int v5 = (unint64_t *)(a2 + 80);
          if (!v6) {
            return 0LL;
          }
          memset(v10, 0, sizeof(v10));
          uint64_t result = DERImg4DecodePayloadCompression(v5, (char **)v10);
          if (!(_DWORD)result) {
            return 0LL;
          }
        }
      }
    }

    else
    {
      __int128 v7 = v12;
      *(_OWORD *)a2 = v11;
      *(_OWORD *)(a2 + 16) = v7;
      __int128 v8 = v14;
      *(_OWORD *)(a2 + 32) = v13;
      *(_OWORD *)(a2 + 4_Block_object_dispose(va, 8) = v8;
      __int128 v9 = v16;
      *(_OWORD *)(a2 + 64) = v15;
      *(_OWORD *)(a2 + 80) = v9;
    }
  }

  return result;
}

uint64_t DERImg4DecodeManifest(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeManifestCommon( void *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result = 6LL;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1]) {
      return 0LL;
    }
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }

    uint64_t result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0LL);
    if (!(_DWORD)result)
    {
      unsigned int v9 = 0;
      uint64_t result = DERParseInteger((char **)(a4 + 16), &v9);
      if ((_DWORD)result) {
        return result;
      }
      if (v9 > 2) {
        return 2LL;
      }
      return 0LL;
    }
  }

  return result;
}

void *DERImg4DecodeRestoreInfo(void *result, unint64_t a2)
{
  if (result)
  {
    if (!a2) {
      return (void *)(&dword_4 + 2);
    }
    if (*result && result[1])
    {
      uint64_t result = (void *)DERParseSequenceToObject( (uint64_t)result,  2u,  (uint64_t)&DERImg4RestoreInfoItemSpecs,  a2,  0x20uLL,  0LL);
      if ((_DWORD)result) {
        return result;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t Img4DecodeGetManifest(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t result = 6LL;
  if (a1 && a2 && a3)
  {
    uint64_t v5 = *(void *)(a1 + 24);
    *a2 = v5;
    int v6 = *(_DWORD *)(a1 + 32);
    *a3 = v6;
    if (v5) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    int v8 = v7;
    return (v8 << 31 >> 31);
  }

  return result;
}

double Img4DecodeInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (a3)
    {
      v9[0] = a1;
      v9[1] = a2;
      __int128 v7 = 0u;
      __int128 v8 = 0u;
      __int128 v5 = 0u;
      __int128 v6 = 0u;
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 80) = 0u;
      *(_OWORD *)(a3 + 96) = 0u;
      *(_OWORD *)(a3 + 112) = 0u;
      *(_OWORD *)(a3 + 12_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a3 + 144) = 0u;
      *(_OWORD *)(a3 + 160) = 0u;
      *(_OWORD *)(a3 + 176) = 0u;
      *(_OWORD *)(a3 + 192) = 0u;
      *(_OWORD *)(a3 + 20_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a3 + 224) = 0u;
      *(_OWORD *)(a3 + 240) = 0u;
      *(_OWORD *)(a3 + 256) = 0u;
      *(_OWORD *)(a3 + 272) = 0u;
      *(_OWORD *)(a3 + 28_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a3 + 304) = 0u;
      *(_OWORD *)(a3 + 320) = 0u;
      *(_OWORD *)(a3 + 336) = 0u;
      *(_OWORD *)(a3 + 352) = 0u;
      *(_OWORD *)(a3 + 36_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a3 + 384) = 0u;
      *(_OWORD *)(a3 + 400) = 0u;
      *(_OWORD *)(a3 + 416) = 0u;
      *(_OWORD *)(a3 + 432) = 0u;
      *(void *)(a3 + 44_Block_object_dispose(va, 8) = 0LL;
      if (!DERImg4Decode(v9, (unint64_t)&v5)
        && !DERImg4DecodePayload((uint64_t)&v6, a3 + 88)
        && !DERImg4DecodeManifest(&v7, a3 + 232)
        && !DERImg4DecodeRestoreInfo(&v8, a3 + 424))
      {
        *(_OWORD *)(a3 + _Block_object_dispose(va, 8) = v6;
        double result = *(double *)&v7;
        *(_OWORD *)(a3 + 24) = v7;
      }
    }
  }

  return result;
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0LL);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3LL;
  }
  int v4 = *(_BYTE **)result;
  if (*(void *)result == -1LL) {
    goto LABEL_68;
  }
  __int128 v5 = &v4[v3];
  __int128 v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    __int128 v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1LL)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      __int128 v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0LL;
            }
LABEL_34:
            double result = 0LL;
            *a3 = v15;
            return result;
          }

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, &v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4))
    {
      return 7LL;
    }

    else
    {
      uint64_t result = 0LL;
      *a2 = v4;
    }
  }

  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3LL;
  }
  unint64_t v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3LL;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7LL;
    }
    goto LABEL_10;
  }

  if (v2 >= 2)
  {
    if (v2 > 9) {
      return 7LL;
    }
  }

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[0] = 0LL;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1LL;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0LL);
  if (!(_DWORD)result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0LL;
        *a1 = v9;
        return result;
      }

      __break(0x5519u);
    }

    __break(0x5513u);
  }

  return result;
}

uint64_t DERParseSequenceToObject( uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0LL);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010LL) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t DERParseSequenceContentToObject( unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v32 = 0LL;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }

  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    __int128 v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result) {
        break;
      }
      if (a2 <= v13) {
        return 2LL;
      }
      while (1)
      {
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24LL * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24LL * v13 + 8)) {
          break;
        }
        uint64_t result = 2LL;
        if ((v18 & 1) != 0)
        {
          ++v13;
        }

        return result;
      }

      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24LL * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7LL;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3LL;
            }

            goto LABEL_59;
          }

          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }

          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }

      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }

void sub_1EDEE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
}

void sub_1EE028( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1EE274( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1EF150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_1EF8D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

id MAInternalServerTrustCredential(void *a1)
{
  BOOL v1 = (void *)objc_claimAutoreleasedReturnValue([a1 protectionSpace]);
  unint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 authenticationMethod]);
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 host]);
  unsigned int v4 = [v3 hasSuffix:@".sd.apple.com"];
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    unsigned int v6 = 0LL;
  }

  else
  {
    unint64_t v7 = (__SecTrust *)[v1 serverTrust];
    if (MAInternalServerAnchorCertificates_once != -1) {
      dispatch_once(&MAInternalServerAnchorCertificates_once, &__block_literal_global_30);
    }
    SecTrustSetAnchorCertificates(v7, (CFArrayRef)MAInternalServerAnchorCertificates_anchors);
    SecTrustSetAnchorCertificatesOnly(v7, 0);
    unsigned int v6 = 0LL;
    if (SecTrustEvaluateWithError(v7, 0LL)) {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSURLCredential credentialForTrust:](&OBJC_CLASS___NSURLCredential, "credentialForTrust:", v7));
    }
  }

  return v6;
}

void sub_1F292C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

void sub_1F48F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, unsigned int a13)
{
}

uint64_t __os_cleanup_close_0(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((_DWORD)result != -1)
  {
    uint64_t result = close(result);
    if ((_DWORD)result == -1) {
      -[MobileAssetKeyManager decryptFileAtURL:iv:tag:cryptor:].cold.2();
    }
  }

  return result;
}

void sub_1F4ABC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1F4C78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1F4E7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1F50B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1F5468( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_1F57F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void OUTLINED_FUNCTION_0_4( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

uint64_t OUTLINED_FUNCTION_6_1(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = result;
  *(_WORD *)(a3 + 12) = 2080;
  *(void *)(a3 + 14) = a2;
  return result;
}

  ;
}

  ;
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext((char *)a1 + (int)result, -(result >> 32), 0LL, 0LL);
    *a1 = result;
  }

  return result;
}

unint64_t sub_1F6F7C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2)
  {
    unsigned int v4 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }

  __swift_instantiateConcreteTypeFromMangledName(&qword_3A7C38);
  uint64_t v3 = static _DictionaryStorage.allocate(capacity:)(v2);
  unsigned int v4 = (void *)v3;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5)
  {
LABEL_9:
    swift_bridgeObjectRelease(a1);
    return (unint64_t)v4;
  }

  uint64_t v6 = v3 + 64;
  uint64_t v7 = a1 + 32;
  swift_retain(v3);
  while (1)
  {
    sub_1F8818(v7, (uint64_t)&v16);
    uint64_t v8 = v16;
    uint64_t v9 = v17;
    unint64_t result = sub_1F82B0(v16, v17);
    if ((v11 & 1) != 0) {
      break;
    }
    *(void *)(v6 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << result;
    uint64_t v12 = (uint64_t *)(v4[6] + 16 * result);
    uint64_t *v12 = v8;
    v12[1] = v9;
    unint64_t result = (unint64_t)sub_1F70B8(&v18, (_OWORD *)(v4[7] + 32 * result));
    uint64_t v13 = v4[2];
    BOOL v14 = __OFADD__(v13, 1LL);
    uint64_t v15 = v13 + 1;
    if (v14) {
      goto LABEL_11;
    }
    v4[2] = v15;
    v7 += 48LL;
    if (!--v5)
    {
      swift_release(v4);
      goto LABEL_9;
    }
  }

  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

void type metadata accessor for MAKeyManagerError(uint64_t a1)
{
}

_OWORD *sub_1F70B8(_OWORD *a1, _OWORD *a2)
{
  __int128 v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

uint64_t sub_1F70C8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, __SecKey *a5)
{
  if (_stdlib_isOSVersionAtLeast(_:_:_:)(0x11uLL, 0LL, 0LL))
  {
    if (&type metadata accessor for HPKE) {
      BOOL v11 = &type metadata for HPKE == 0LL;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11 && &nominal type descriptor for HPKE != 0LL)
    {
      CFDataRef v13 = SecKeyCopyExternalRepresentation(a5, 0LL);
      if (v13)
      {
        CFDataRef v14 = v13;
        v69[0] = static Data._unconditionallyBridgeFromObjectiveC(_:)();
        v69[1] = v15;
        uint64_t v71 = type metadata accessor for P256.KeyAgreement.PrivateKey(0LL);
        id v72 = &protocol witness table for P256.KeyAgreement.PrivateKey;
        __swift_allocate_boxed_opaque_existential_1(&v70);
        P256.KeyAgreement.PrivateKey.init<A>(x963Representation:)( v69,  &type metadata for Data,  &protocol witness table for Data);
        if (v5)
        {

LABEL_17:
          __swift_deallocate_boxed_opaque_existential_1(&v70);
          return a2;
        }

        *(void *)&__int128 v60 = a1;
        *((void *)&v60 + 1) = a2;
      }

      else
      {
        uint64_t v71 = type metadata accessor for SecureEnclave.P256.KeyAgreement.PrivateKey();
        id v72 = &protocol witness table for SecureEnclave.P256.KeyAgreement.PrivateKey;
        __swift_allocate_boxed_opaque_existential_1(&v70);
        SecureEnclave.P256.KeyAgreement.PrivateKey.init(from:)(a5);
        if (v5) {
          goto LABEL_17;
        }
        *(void *)&__int128 v60 = a1;
        *((void *)&v60 + 1) = a2;
      }

      sub_1F8384(&v70, (uint64_t)v73);
      uint64_t v67 = &v57;
      uint64_t v68 = type metadata accessor for HPKE.Ciphersuite(0LL);
      uint64_t v78 = *(void *)(v68 - 8);
      uint64_t v65 = *(void *)(v78 + 64);
      ((void (*)(void))__chkstk_darwin)();
      unint64_t v66 = (v30 + 15) & 0xFFFFFFFFFFFFFFF0LL;
      __int128 v31 = (char *)&v57 - v66;
      type metadata accessor for HPKE.KEM(0LL);
      id v64 = &v57;
      ((void (*)(void))__chkstk_darwin)();
      unint64_t v33 = (char *)&v57 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      (*(void (**)(char *, void))(v34 + 104))(v33, enum case for HPKE.KEM.P256_HKDF_SHA256(_:));
      type metadata accessor for HPKE.KDF(0LL);
      id v63 = &v57;
      ((void (*)(void))__chkstk_darwin)();
      id v36 = (char *)&v57 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      (*(void (**)(char *, void))(v37 + 104))(v36, enum case for HPKE.KDF.HKDF_SHA256(_:));
      type metadata accessor for HPKE.AEAD(0LL);
      ((void (*)(void))__chkstk_darwin)();
      __int128 v39 = (char *)&v57 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      (*(void (**)(char *, void))(v40 + 104))(v39, enum case for HPKE.AEAD.AES_GCM_256(_:));
      HPKE.Ciphersuite.init(kem:kdf:aead:)(v33, v36, v39);
      uint64_t v41 = type metadata accessor for HPKE.Recipient(0LL);
      id v64 = &v57;
      uint64_t v58 = *(void *)(v41 - 8);
      uint64_t v59 = v41;
      ((void (*)(void))__chkstk_darwin)();
      id v43 = (char *)&v57 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v44 = v74;
      id v63 = v75;
      id v45 = __swift_project_boxed_opaque_existential_1(v73, v74);
      uint64_t v62 = &v57;
      __chkstk_darwin(v45, v45);
      uint64_t v47 = (char *)&v57 - ((v46 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v49 = (*(uint64_t (**)(char *))(v48 + 16))(v47);
      id v61 = &v57;
      __chkstk_darwin(v49, v50);
      uint64_t v51 = (char *)&v57 - v66;
      (*(void (**)(char *, char *, uint64_t))(v78 + 16))((char *)&v57 - v66, v31, v68);
      sub_1F83C0(a3, a4);
      unint64_t v66 = (unint64_t)v43;
      HPKE.Recipient.init<A>(privateKey:ciphersuite:info:encapsulatedKey:)( v47,  v51,  0LL,  0xC000000000000000LL,  a3,  a4,  v44,  v63);
      uint64_t v53 = v58;
      uint64_t v52 = v59;
      uint64_t v54 = v78;
      uint64_t v55 = v68;
      __int128 v70 = v60;
      unint64_t v56 = sub_1F8404();
      a2 = HPKE.Recipient.open<A>(_:)(&v70, &type metadata for Data, v56);
      (*(void (**)(unint64_t, uint64_t))(v53 + 8))(v66, v52);
      (*(void (**)(char *, uint64_t))(v54 + 8))(v31, v55);
      __swift_destroy_boxed_opaque_existential_1Tm(v73);
      return a2;
    }

    uint64_t v21 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A7B98);
    uint64_t inited = swift_initStackObject(v21, &v76);
    *(_OWORD *)(inited + 16) = xmmword_27F7D0;
    *(void *)(inited + 32) = static String._unconditionallyBridgeFromObjectiveC(_:)(NSLocalizedDescriptionKey);
    *(void *)(inited + 40) = v22;
    *(void *)(inited + 72) = &type metadata for String;
    unint64_t v19 = 0xD00000000000001CLL;
    __int128 v20 = "CryptoKit.HPKE not available";
  }

  else
  {
    uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A7B98);
    uint64_t inited = swift_initStackObject(v16, v77);
    *(_OWORD *)(inited + 16) = xmmword_27F7D0;
    *(void *)(inited + 32) = static String._unconditionallyBridgeFromObjectiveC(_:)(NSLocalizedDescriptionKey);
    *(void *)(inited + 40) = v18;
    *(void *)(inited + 72) = &type metadata for String;
    unint64_t v19 = 0xD000000000000017LL;
    __int128 v20 = "CryptoKit not available";
  }

  *(void *)(inited + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v19;
  *(void *)(inited + 56) = (unint64_t)(v20 - 32) | 0x8000000000000000LL;
  unint64_t v23 = sub_1F6F7C(inited);
  type metadata accessor for MAKeyManagerError(0LL);
  uint64_t v25 = v24;
  *(void *)&__int128 v70 = 30030LL;
  uint64_t v26 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  unint64_t v27 = v23;
  a2 = v25;
  unint64_t v28 = _BridgedStoredNSError.init(_:userInfo:)(v73, &v70, v27, v25, v26);
  swift_willThrow(v28);
  return a2;
}

char *sub_1F76E8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, __SecKey *a5)
{
  uint64_t v69 = a3;
  unint64_t v70 = a4;
  uint64_t v59 = a2;
  uint64_t v58 = a1;
  id v61 = type metadata accessor for HPKE.Recipient();
  Description = (void (**)(uint64_t, ValueMetadata *))v61[-1].Description;
  __chkstk_darwin(v61, v6);
  uint64_t v72 = (uint64_t)&v58 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v66 = _s4AEADOMa();
  id v64 = (void (**)(char *, uint64_t, ValueMetadata *))v66[-1].Description;
  __chkstk_darwin(v66, v8);
  uint64_t v65 = (char *)&v58 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v63 = _s3KDFOMa();
  uint64_t v62 = (void (**)(char *, void, ValueMetadata *))v63[-1].Description;
  __chkstk_darwin(v63, v10);
  uint64_t v12 = (char *)&v58 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  CFDataRef v13 = _s3KEMOMa();
  CFDataRef v14 = v13[-1].Description;
  __chkstk_darwin(v13, v15);
  uint64_t v17 = (char *)&v58 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v68 = _s11CiphersuiteVMa();
  uint64_t v67 = (void (**)(__int16 *, _BYTE *, ValueMetadata *))v68[-1].Description;
  uint64_t v19 = __chkstk_darwin(v68, v18);
  uint64_t v21 = (__int16 *)((char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  __chkstk_darwin(v19, v22);
  uint64_t v71 = (char *)&v58 - v23;
  uint64_t v24 = _s12KeyAgreementO10PrivateKeyVMa();
  id v73 = (void (**)(char *, uint64_t *, ValueMetadata *))v24[-1].Description;
  uint64_t v74 = v24;
  uint64_t v26 = __chkstk_darwin(v24, v25);
  unint64_t v28 = (char *)&v58 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = __chkstk_darwin(v26, v29);
  uint64_t v32 = (uint64_t *)((char *)&v58 - v31);
  __chkstk_darwin(v30, v33);
  uint64_t v76 = (char *)&v58 - v34;
  CFDataRef v35 = SecKeyCopyExternalRepresentation(a5, 0LL);
  if (v35)
  {
    CFDataRef v36 = v35;
    uint64_t v77 = static Data._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v78 = v37;
    uint64_t v38 = v75;
    sub_242E88((uint64_t)&v77, (uint64_t)&type metadata for Data, (uint64_t)&protocol witness table for Data, v32);

    if (!v38)
    {
      __int128 v39 = v73;
      v73[4](v76, v32, v74);
      (*((void (**)(_BYTE *, void, ValueMetadata *))v14 + 13))(v17, 0LL, v13);
      v62[13](v12, 0LL, v63);
      uint64_t v40 = v65;
      v64[13](v65, 1LL, v66);
      uint64_t v41 = v71;
      sub_230380(v17, v12, v40, v71);
      uint64_t v42 = (uint64_t)v74;
      v39[2](v28, (uint64_t *)v76, v74);
      id v43 = v67;
      uint64_t v44 = v68;
      v67[2](v21, v41, v68);
      uint64_t v46 = v69;
      unint64_t v45 = v70;
      sub_1F83C0(v69, v70);
      uint64_t v47 = v46;
      uint64_t v48 = v42;
      sub_20F098((uint64_t)v28, v21, 0LL, 0xC000000000000000LL, v47, v45, v42, (uint64_t)&off_3A8208, v72);
      uint64_t v77 = v58;
      uint64_t v78 = v59;
      sub_1F8404();
      uint64_t v56 = v72;
      uint64_t v12 = (char *)sub_20F830((uint64_t)&v77, (uint64_t)&type metadata for Data);
      Description[1](v56, v61);
      ((void (*)(_BYTE *, ValueMetadata *))v43[1])(v71, v44);
      ((void (*)(char *, uint64_t))v73[1])(v76, v48);
    }
  }

  else
  {
    uint64_t v49 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A7B98);
    uint64_t inited = swift_initStackObject(v49, v79);
    *(_OWORD *)(inited + 16) = xmmword_27F7D0;
    *(void *)(inited + 32) = static String._unconditionallyBridgeFromObjectiveC(_:)(NSLocalizedDescriptionKey);
    *(void *)(inited + 40) = v51;
    *(void *)(inited + 72) = &type metadata for String;
    *(void *)(inited + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0xD000000000000022LL;
    *(void *)(inited + 56) = 0x8000000000305410LL;
    uint64_t v12 = (char *)sub_1F6F7C(inited);
    type metadata accessor for MAKeyManagerError(0LL);
    uint64_t v53 = v52;
    uint64_t v80 = 30030LL;
    uint64_t v54 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
    uint64_t v55 = _BridgedStoredNSError.init(_:userInfo:)(&v77, &v80, v12, v53, v54);
    swift_willThrow(v55);
  }

  return v12;
}

char *sub_1F7C3C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, __SecKey *a5)
{
  unint64_t result = (char *)sub_1F70C8(a1, a2, a3, a4, a5);
  if (v5)
  {
    type metadata accessor for Code(0LL);
    uint64_t v13 = v12;
    uint64_t v15 = 30030LL;
    swift_errorRetain(v5);
    uint64_t v14 = sub_1F84A0( &qword_3A7BB8,  (uint64_t (*)(uint64_t))type metadata accessor for Code,  (uint64_t)&unk_27F9E0);
    LOBYTE(v13) = static _ErrorCodeProtocol.~= infix(_:_:)(&v15, v5, v13, v14);
    unint64_t result = (char *)swift_errorRelease(v5);
    if ((v13 & 1) != 0)
    {
      swift_errorRelease(v5);
      return sub_1F76E8(a1, a2, a3, a4, a5);
    }
  }

  return result;
}

id sub_1F7F50()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for CryptoKitWrapper();
  return objc_msgSendSuper2(&v2, "dealloc");
}

id sub_1F7F80()
{
  return *v0;
}

uint64_t sub_1F7F88@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t sub_1F7F90(uint64_t a1)
{
  uint64_t v2 = sub_1F84A0( &qword_3A7C10,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F940);
  return Error<>._domain.getter(a1, v2);
}

uint64_t sub_1F7FD0(uint64_t a1)
{
  uint64_t v2 = sub_1F84A0( &qword_3A7C10,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F940);
  return Error<>._code.getter(a1, v2);
}

uint64_t sub_1F8014(uint64_t a1)
{
  uint64_t v2 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  return _BridgedStoredNSError._getEmbeddedNSError()(a1, v2);
}

uint64_t sub_1F8054()
{
  return static String._unconditionallyBridgeFromObjectiveC(_:)(@"MAKeyManagerErrorDomain");
}

uint64_t sub_1F8064(uint64_t a1)
{
  uint64_t v2 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  return _BridgedStoredNSError.errorCode.getter(a1, v2);
}

uint64_t sub_1F80A4(uint64_t a1)
{
  uint64_t v2 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  return _BridgedStoredNSError.errorUserInfo.getter(a1, v2);
}

uint64_t sub_1F80E4(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  return _BridgedStoredNSError.init(_bridgedNSError:)(a1, a2, v4);
}

uint64_t sub_1F8148()
{
  id v1 = *v0;
  uint64_t v2 = NSObject.hashValue.getter();

  return v2;
}

uint64_t sub_1F817C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  return _BridgedStoredNSError.hash(into:)(a1, a2, v4);
}

Swift::Int sub_1F81CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[9] = *v3;
  Hasher.init(_seed:)(v7);
  dispatch thunk of Hashable.hash(into:)(v7, a2, a3);
  return Hasher._finalize()();
}

void *sub_1F8228@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *result;
  *(_BYTE *)(a2 + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  return result;
}

void sub_1F8238(void *a1@<X8>)
{
  *a1 = *v1;
}

BOOL sub_1F8244(void *a1, void *a2)
{
  return *a1 == *a2;
}

uint64_t sub_1F8258(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
  return static _BridgedStoredNSError.== infix(_:_:)(a1, a2, a3, v6);
}

unint64_t sub_1F82B0(uint64_t a1, uint64_t a2)
{
  Swift::Int v4 = Hasher._finalize()();
  return sub_1F8718(a1, a2, v4);
}

void *__swift_allocate_boxed_opaque_existential_1(void *a1)
{
  id v1 = a1;
  if ((*(_BYTE *)(*(void *)(a1[3] - 8LL) + 82LL) & 2) != 0)
  {
    *a1 = swift_allocBox();
    return (void *)v2;
  }

  return v1;
}

void *__swift_deallocate_boxed_opaque_existential_1(void *result)
{
  uint64_t v1 = *(void *)(result[3] - 8LL);
  if ((*(_DWORD *)(v1 + 80) & 0x20000) != 0) {
    return (void *)swift_slowDealloc( *result,  *(void *)(v1 + 64)
  }
                     + ((*(_DWORD *)(v1 + 80) + 16LL) & ~(unint64_t)*(_DWORD *)(v1 + 80)),
                       *(_DWORD *)(v1 + 80) | 7LL);
  return result;
}

uint64_t sub_1F8384(__int128 *a1, uint64_t a2)
{
  __int128 v2 = *a1;
  __int128 v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

void *__swift_project_boxed_opaque_existential_1(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) + 16LL) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80LL)));
  return result;
}

uint64_t sub_1F83C0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    ((void (*)(void))swift_retain)();
  }

  return swift_retain(a2 & 0x3FFFFFFFFFFFFFFFLL);
}

unint64_t sub_1F8404()
{
  unint64_t result = qword_3A7BB0;
  if (!qword_3A7BB0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Data, &type metadata for Data);
    atomic_store(result, (unint64_t *)&qword_3A7BB0);
  }

  return result;
}

void type metadata accessor for Code(uint64_t a1)
{
}

void sub_1F845C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if (!*a2)
  {
    ForeignTypeMetaCFAbsoluteTime data = swift_getForeignTypeMetadata(0LL, a3);
    if (!v5) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }

uint64_t sub_1F84A0(unint64_t *a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = a2(255LL);
    uint64_t result = swift_getWitnessTable(a3, v6);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t type metadata accessor for CryptoKitWrapper()
{
  return objc_opt_self(&OBJC_CLASS____TtC21MobileAssetKeyManager16CryptoKitWrapper);
}

uint64_t sub_1F8500()
{
  return sub_1F84A0( &qword_3A7BF8,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F868);
}

uint64_t sub_1F852C()
{
  return sub_1F84A0( &qword_3A7C00,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F890);
}

uint64_t sub_1F8558()
{
  return sub_1F84A0( &qword_3A7C08,  (uint64_t (*)(uint64_t))type metadata accessor for Code,  (uint64_t)&unk_27F980);
}

uint64_t sub_1F8584()
{
  return sub_1F84A0( &qword_3A7BA0,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27FA18);
}

uint64_t sub_1F85B0()
{
  return sub_1F84A0( &qword_3A7C10,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F940);
}

uint64_t sub_1F85DC()
{
  return sub_1F84A0( &qword_3A7C18,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F910);
}

uint64_t sub_1F8608()
{
  return sub_1F84A0( &qword_3A7C20,  (uint64_t (*)(uint64_t))type metadata accessor for MAKeyManagerError,  (uint64_t)&unk_27F8D0);
}

uint64_t sub_1F8634()
{
  return sub_1F84A0( &qword_3A7BB8,  (uint64_t (*)(uint64_t))type metadata accessor for Code,  (uint64_t)&unk_27F9E0);
}

uint64_t sub_1F8660()
{
  return sub_1F84A0( &qword_3A7C28,  (uint64_t (*)(uint64_t))type metadata accessor for Code,  (uint64_t)&unk_27F9A8);
}

unint64_t sub_1F8690()
{
  unint64_t result = qword_3A7C30;
  if (!qword_3A7C30)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int);
    atomic_store(result, (unint64_t *)&qword_3A7C30);
  }

  return result;
}

uint64_t sub_1F86D4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    ((void (*)(void))swift_release)();
  }

  return swift_release(a2 & 0x3FFFFFFFFFFFFFFFLL);
}

unint64_t sub_1F8718(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if (((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0)
  {
    uint64_t v9 = *(void *)(v3 + 48);
    uint64_t v10 = (void *)(v9 + 16 * v6);
    BOOL v11 = *v10 == a1 && v10[1] == a2;
    if (!v11 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      uint64_t v12 = ~v5;
      do
      {
        unint64_t v6 = (v6 + 1) & v12;
        if (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) == 0) {
          break;
        }
        uint64_t v13 = (void *)(v9 + 16 * v6);
        BOOL v14 = *v13 == a1 && v13[1] == a2;
      }

      while (!v14 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0);
    }
  }

  return v6;
}

uint64_t __swift_destroy_boxed_opaque_existential_1Tm(void *a1)
{
  uint64_t v1 = *(void *)(a1[3] - 8LL);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0) {
    return swift_release(*a1);
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t sub_1F8818(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A7C40);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t ccder_blob_decode_bitstring(unsigned __int8 **a1, uint64_t a2, unint64_t *a3)
{
  uint64_t result = ccder_blob_decode_range(a1, 3LL, (unsigned __int8 **)a2);
  if ((_DWORD)result)
  {
    *a3 = 0LL;
    unint64_t v6 = *(unsigned __int8 **)a2;
    uint64_t v7 = *(void *)(a2 + 8);
    if (v7 != *(void *)a2)
    {
      unint64_t v8 = 8 * (~(unint64_t)v6 + v7);
      unint64_t v9 = *v6;
      BOOL v10 = v8 >= v9;
      unint64_t v11 = v8 - v9;
      if (v10) {
        *a3 = v11;
      }
      *(void *)a2 = v6 + 1;
    }
  }

  return result;
}

int8x16_t *ccaes_arm_decrypt_cbc(int8x16_t *result, int8x16_t *a2, uint64_t a3, int8x16_t *a4, int8x16_t *a5)
{
  if (a3)
  {
    uint64_t v5 = result[15].u32[0];
    if (v5 == 160 || v5 == 192 || v5 == 224)
    {
      int8x16_t v6 = *a2;
      BOOL v7 = a3 < 16;
      for (uint64_t i = a3 - 16; !v7; i -= 16LL)
      {
        int8x16_t v9 = *a4;
        a4 += 16;
        int8x16_t v10 = v9;
        int8x16_t v11 = a4[-13];
        int8x16_t v12 = a4[-12];
        int8x16_t v13 = a4[-11];
        int8x16_t v14 = a4[-10];
        int8x16_t v15 = a4[-9];
        int8x16_t v16 = a4[-8];
        int8x16_t v17 = a4[-7];
        int8x16_t v18 = a4[-6];
        _Q16 = *(__int128 *)((char *)result + v5);
        int8x16_t v20 = a4[-5];
        int8x16_t v21 = *result;
        int8x16_t v22 = a4[-4];
        uint64_t v23 = v5 - 16;
        do
        {
          __asm
          {
            AESD            V0.16B, V16.16B
            AESIMC          V0.16B, V0.16B
            AESD            V1.16B, V16.16B
            AESIMC          V1.16B, V1.16B
            AESD            V2.16B, V16.16B
            AESIMC          V2.16B, V2.16B
            AESD            V3.16B, V16.16B
            AESIMC          V3.16B, V3.16B
            AESD            V4.16B, V16.16B
            AESIMC          V4.16B, V4.16B
            AESD            V5.16B, V16.16B
            AESIMC          V5.16B, V5.16B
            AESD            V6.16B, V16.16B
            AESIMC          V6.16B, V6.16B
            AESD            V7.16B, V16.16B
            AESIMC          V7.16B, V7.16B
            AESD            V8.16B, V16.16B
            AESIMC          V8.16B, V8.16B
            AESD            V9.16B, V16.16B
            AESIMC          V9.16B, V9.16B
            AESD            V10.16B, V16.16B
            AESIMC          V10.16B, V10.16B
            AESD            V11.16B, V16.16B
            AESIMC          V11.16B, V11.16B
            AESD            V12.16B, V16.16B
            AESIMC          V12.16B, V12.16B
            AESD            V13.16B, V16.16B
            AESIMC          V13.16B, V13.16B
            AESD            V14.16B, V16.16B
            AESIMC          V14.16B, V14.16B
            AESD            V15.16B, V16.16B
            AESIMC          V15.16B, V15.16B
          }

          _Q16 = *(__int128 *)((char *)result + v23);
          BOOL v7 = v23 <= 16;
          v23 -= 16LL;
        }

        while (!v7);
        a5 += 16;
        __asm
        {
          AESD            V0.16B, V16.16B
          AESD            V1.16B, V16.16B
        }

        int8x16_t v62 = veorq_s8(veorq_s8(_Q0, v21), v6);
        int8x16_t v6 = a4[-1];
        __asm { AESD            V2.16B, V16.16B }

        int8x16_t v64 = veorq_s8(veorq_s8(_Q1, v21), v10);
        int8x16_t v65 = a4[-3];
        __asm { AESD            V3.16B, V16.16B }

        int8x16_t v67 = veorq_s8(veorq_s8(_Q2, v21), a4[-15]);
        int8x16_t v68 = a4[-2];
        __asm { AESD            V4.16B, V16.16B }

        int8x16_t v70 = veorq_s8(veorq_s8(_Q3, v21), a4[-14]);
        a5[-16] = v62;
        __asm { AESD            V5.16B, V16.16B }

        a5[-15] = v64;
        __asm { AESD            V6.16B, V16.16B }

        a5[-14] = v67;
        __asm { AESD            V7.16B, V16.16B }

        a5[-13] = v70;
        __asm { AESD            V8.16B, V16.16B }

        a5[-12] = veorq_s8(veorq_s8(_Q4, v21), v11);
        __asm { AESD            V9.16B, V16.16B }

        a5[-11] = veorq_s8(veorq_s8(_Q5, v21), v12);
        __asm { AESD            V10.16B, V16.16B }

        a5[-10] = veorq_s8(veorq_s8(_Q6, v21), v13);
        __asm { AESD            V11.16B, V16.16B }

        a5[-9] = veorq_s8(veorq_s8(_Q7, v21), v14);
        __asm { AESD            V12.16B, V16.16B }

        a5[-8] = veorq_s8(veorq_s8(_Q8, v21), v15);
        __asm { AESD            V13.16B, V16.16B }

        a5[-7] = veorq_s8(veorq_s8(_Q9, v21), v16);
        __asm { AESD            V14.16B, V16.16B }

        a5[-6] = veorq_s8(veorq_s8(_Q10, v21), v17);
        __asm { AESD            V15.16B, V16.16B }

        a5[-5] = veorq_s8(veorq_s8(_Q11, v21), v18);
        a5[-4] = veorq_s8(veorq_s8(_Q12, v21), v20);
        a5[-3] = veorq_s8(veorq_s8(_Q13, v21), v22);
        a5[-2] = veorq_s8(veorq_s8(_Q14, v21), v65);
        a5[-1] = veorq_s8(veorq_s8(_Q15, v21), v68);
        BOOL v7 = i < 16;
      }

      BOOL v7 = i < -8;
      for (uint64_t j = i + 8; !v7; j -= 8LL)
      {
        int8x16_t v83 = *a4;
        a4 += 8;
        int8x16_t v84 = v83;
        int8x16_t v85 = a4[-7];
        int8x16_t v86 = a4[-6];
        int8x16_t v87 = a4[-5];
        int8x16_t v88 = a4[-4];
        _Q16 = *(__int128 *)((char *)result + v5);
        int8x16_t v90 = a4[-3];
        int8x16_t v91 = *result;
        int8x16_t v92 = a4[-2];
        uint64_t v93 = v5 - 16;
        do
        {
          __asm
          {
            AESD            V0.16B, V16.16B
            AESIMC          V0.16B, V0.16B
            AESD            V1.16B, V16.16B
            AESIMC          V1.16B, V1.16B
            AESD            V2.16B, V16.16B
            AESIMC          V2.16B, V2.16B
            AESD            V3.16B, V16.16B
            AESIMC          V3.16B, V3.16B
            AESD            V4.16B, V16.16B
            AESIMC          V4.16B, V4.16B
            AESD            V5.16B, V16.16B
            AESIMC          V5.16B, V5.16B
            AESD            V6.16B, V16.16B
            AESIMC          V6.16B, V6.16B
            AESD            V7.16B, V16.16B
            AESIMC          V7.16B, V7.16B
          }

          _Q16 = *(__int128 *)((char *)result + v93);
          BOOL v7 = v93 <= 16;
          v93 -= 16LL;
        }

        while (!v7);
        a5 += 8;
        __asm
        {
          AESD            V0.16B, V16.16B
          AESD            V1.16B, V16.16B
        }

        int8x16_t v112 = veorq_s8(veorq_s8(_Q0, v91), v6);
        int8x16_t v6 = a4[-1];
        __asm { AESD            V2.16B, V16.16B }

        a5[-8] = v112;
        __asm { AESD            V3.16B, V16.16B }

        a5[-7] = veorq_s8(veorq_s8(_Q1, v91), v84);
        __asm { AESD            V4.16B, V16.16B }

        a5[-6] = veorq_s8(veorq_s8(_Q2, v91), v85);
        __asm { AESD            V5.16B, V16.16B }

        a5[-5] = veorq_s8(veorq_s8(_Q3, v91), v86);
        __asm { AESD            V6.16B, V16.16B }

        a5[-4] = veorq_s8(veorq_s8(_Q4, v91), v87);
        __asm { AESD            V7.16B, V16.16B }

        a5[-3] = veorq_s8(veorq_s8(_Q5, v91), v88);
        a5[-2] = veorq_s8(veorq_s8(_Q6, v91), v90);
        a5[-1] = veorq_s8(veorq_s8(_Q7, v91), v92);
        BOOL v7 = j < 8;
      }

      BOOL v7 = j < -4;
      for (uint64_t k = j + 4; !v7; k -= 4LL)
      {
        int8x16_t v120 = *a4;
        a4 += 4;
        int8x16_t v121 = v120;
        int8x16_t v122 = a4[-3];
        _Q16 = *(__int128 *)((char *)result + v5);
        int8x16_t v124 = a4[-2];
        int8x16_t v125 = *result;
        uint64_t v126 = v5 - 16;
        do
        {
          __asm
          {
            AESD            V0.16B, V16.16B
            AESIMC          V0.16B, V0.16B
            AESD            V1.16B, V16.16B
            AESIMC          V1.16B, V1.16B
            AESD            V2.16B, V16.16B
            AESIMC          V2.16B, V2.16B
            AESD            V3.16B, V16.16B
            AESIMC          V3.16B, V3.16B
          }

          _Q16 = *(__int128 *)((char *)result + v126);
          BOOL v7 = v126 <= 16;
          v126 -= 16LL;
        }

        while (!v7);
        a5 += 4;
        __asm
        {
          AESD            V0.16B, V16.16B
          AESD            V1.16B, V16.16B
        }

        int8x16_t v137 = veorq_s8(veorq_s8(_Q0, v125), v6);
        int8x16_t v6 = a4[-1];
        __asm { AESD            V2.16B, V16.16B }

        a5[-4] = v137;
        __asm { AESD            V3.16B, V16.16B }

        a5[-3] = veorq_s8(veorq_s8(_Q1, v125), v121);
        a5[-2] = veorq_s8(veorq_s8(_Q2, v125), v122);
        a5[-1] = veorq_s8(veorq_s8(_Q3, v125), v124);
        BOOL v7 = k < 4;
      }

      BOOL v7 = k <= -4;
      for (uint64_t m = k + 4; !v7; --m)
      {
        _Q16 = *(__int128 *)((char *)result + v5);
        uint64_t v142 = v5 - 16;
        ++a4;
        do
        {
          __asm
          {
            AESD            V0.16B, V16.16B
            AESIMC          V0.16B, V0.16B
          }

          _Q16 = *(__int128 *)((char *)result + v142);
          BOOL v7 = v142 <= 16;
          v142 -= 16LL;
        }

        while (!v7);
        __asm { AESD            V0.16B, V16.16B }

        int8x16_t v146 = veorq_s8(veorq_s8(_Q0, *result), v6);
        int8x16_t v6 = a4[-1];
        *a5++ = v146;
        BOOL v7 = m <= 1;
      }

      uint64_t result = 0LL;
      *a2 = v6;
    }

    else
    {
      return (int8x16_t *)-1LL;
    }
  }

  return result;
}

uint64_t ccaes_arm_encrypt_cbc(uint64_t result, int8x16_t *a2, uint64_t a3, uint64_t a4, int8x16_t *a5)
{
  if (a3)
  {
    uint64_t v5 = *(unsigned int *)(result + 240);
    if ((_DWORD)v5 == 160 || (_DWORD)v5 == 192 || (_DWORD)v5 == 224)
    {
      do
      {
        uint64_t v6 = v5 - 16;
        a4 += 16LL;
        _Q2 = *(int8x16_t *)result;
        BOOL v7 = (int8x16_t *)(result + 16);
        do
        {
          __asm
          {
            AESE            V0.16B, V2.16B
            AESMC           V0.16B, V0.16B
          }

          _Q2 = *v7++;
          BOOL v15 = v6 <= 16;
          v6 -= 16LL;
        }

        while (!v15);
        __asm { AESE            V0.16B, V2.16B }

        int8x16_t v17 = veorq_s8(_Q0, *v7);
        uint64_t result = (uint64_t)v7->i64 - v5;
        *a5++ = v17;
        BOOL v15 = a3-- <= 1;
      }

      while (!v15);
      uint64_t result = 0LL;
      *a2 = v17;
    }

    else
    {
      return -1LL;
    }
  }

  return result;
}

uint64_t ccec_generate_scalar_legacy_ws(uint64_t a1, uint64_t *a2, size_t a3, void *__src, void *__dst)
{
  BOOL v7 = a2 + 4;
  uint64_t v6 = *a2;
  size_t v8 = 8 * *a2;
  if (v8 > a3) {
    return 4294967276LL;
  }
  uint64_t v12 = (uint64_t)&v7[5 * v6];
  memcpy(__dst, __src, v8);
  char v13 = cczp_bitlen((uint64_t)&v7[5 * *a2]);
  if ((v13 & 0x3F) != 0) {
    *((void *)__dst + v6 - 1) &= 0xFFFFFFFFFFFFFFFFLL >> -(v13 & 0x3F);
  }
  uint64_t v14 = *(void *)(a1 + 16);
  BOOL v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  int8x16_t v16 = (unint64_t *)cczp_prime(v12);
  BOOL v17 = ccn_sub_ws(a1, v6, v15, (uint64_t *)__dst, v16);
  ccn_mux(v6, !v17, (uint64_t *)__dst, v15, (uint64_t *)__dst);
  uint64_t result = 0LL;
  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccentropy_rng_init(void *a1, uint64_t a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  *a1 = &entropy_rng_info;
  a1[1] = a2;
  cc_disable_dit_with_sb((unsigned int *)&v5);
  return 0LL;
}

uint64_t ccentropy_rng_get_seed(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 8))();
}

BOOL ccder_blob_encode_body(void *a1, unint64_t a2, const void *a3)
{
  if (!a3) {
    return a2 == 0;
  }
  __dst[0] = 0LL;
  __dst[1] = 0LL;
  BOOL v5 = ccder_blob_reserve(a1, a2, __dst);
  if (v5) {
    memmove(__dst[0], a3, a2);
  }
  return v5;
}

uint64_t aes_key_expansion(unint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = &Rcon;
  *(_DWORD *)(a2 + 240) = 16 * a4;
  if (a3 == 6)
  {
    unint64_t v15 = *a1;
    unint64_t v16 = a1[1];
    uint64_t v14 = (uint64_t *)(a1 + 2);
    *(void *)a2 = v15;
    *(void *)(a2 + _Block_object_dispose((const void *)(v11 - 96), 8) = v16;
    BOOL v17 = (uint64_t *)(a2 + 16);
    uint64_t v18 = *v14;
    uint64_t *v17 = *v14;
    uint64_t v19 = (unint64_t *)(v17 + 1);
    int v20 = 4 * a4 - 2;
    do
    {
      HIDWORD(v21) = HIDWORD(v18);
      LODWORD(v21) = HIDWORD(v18);
      unsigned int v22 = *v4++;
      uint64_t result = v22;
      uint64_t v23 = (AESSubBytesWordTable[BYTE5(v18)] | (AESSubBytesWordTable[(v21 >> 8) >> 24] << 24) | (AESSubBytesWordTable[((v21 >> 8) >> 16)] << 16) | (AESSubBytesWordTable[(unsigned __int16)(HIDWORD(v18) >> 8) >> 8] << 8)) ^ v22;
      v15 ^= v23 ^ ((v15 ^ v23) << 32);
      v16 ^= HIDWORD(v15) ^ ((v16 ^ HIDWORD(v15)) << 32);
      v18 ^= HIDWORD(v16) ^ ((v18 ^ HIDWORD(v16)) << 32);
      unint64_t *v19 = v15;
      v19[1] = v16;
      uint64_t v24 = v19 + 2;
      *uint64_t v24 = v18;
      uint64_t v19 = v24 + 1;
      BOOL v13 = __OFSUB__(v20, 6);
      v20 -= 6;
    }

    while (!((v20 < 0) ^ v13 | (v20 == 0)));
  }

  else if (a3 == 8)
  {
    unint64_t v26 = *a1;
    unint64_t v27 = a1[1];
    uint64_t v25 = a1 + 2;
    *(void *)a2 = v26;
    *(void *)(a2 + _Block_object_dispose((const void *)(v11 - 96), 8) = v27;
    unint64_t v28 = (unint64_t *)(a2 + 16);
    unint64_t v29 = *v25;
    unint64_t v30 = v25[1];
    *unint64_t v28 = *v25;
    v28[1] = v30;
    uint64_t v31 = v28 + 2;
    int v32 = 4 * a4 - 4;
    do
    {
      HIDWORD(v33) = HIDWORD(v30);
      LODWORD(v33) = HIDWORD(v30);
      unsigned int v34 = *v4++;
      uint64_t result = v34;
      uint64_t v35 = (AESSubBytesWordTable[BYTE5(v30)] | (AESSubBytesWordTable[(v33 >> 8) >> 24] << 24) | (AESSubBytesWordTable[((v33 >> 8) >> 16)] << 16) | (AESSubBytesWordTable[(unsigned __int16)(HIDWORD(v30) >> 8) >> 8] << 8)) ^ v34;
      v26 ^= v35 ^ ((v26 ^ v35) << 32);
      v27 ^= HIDWORD(v26) ^ ((v27 ^ HIDWORD(v26)) << 32);
      unint64_t *v31 = v26;
      v31[1] = v27;
      CFDataRef v36 = v31 + 2;
      int v37 = v32 - 4;
      if (!v37) {
        break;
      }
      uint64_t result = AESSubBytesWordTable[HIBYTE(HIDWORD(v27))];
      uint64_t v38 = AESSubBytesWordTable[BYTE4(v27)] | ((_DWORD)result << 24) | (AESSubBytesWordTable[BYTE6(v27)] << 16) | (AESSubBytesWordTable[BYTE5(v27)] << 8);
      v29 ^= v38 ^ ((v29 ^ v38) << 32);
      v30 ^= HIDWORD(v29) ^ ((v30 ^ HIDWORD(v29)) << 32);
      unint64_t *v36 = v29;
      v36[1] = v30;
      uint64_t v31 = v36 + 2;
      BOOL v13 = __OFSUB__(v37, 4);
      int v32 = v37 - 4;
    }

    while (!((v32 < 0) ^ v13 | (v32 == 0)));
  }

  else
  {
    unint64_t v5 = *a1;
    unint64_t v6 = a1[1];
    *(void *)a2 = *a1;
    *(void *)(a2 + _Block_object_dispose((const void *)(v11 - 96), 8) = v6;
    BOOL v7 = (unint64_t *)(a2 + 16);
    int v8 = 4 * a4;
    do
    {
      HIDWORD(v9) = HIDWORD(v6);
      LODWORD(v9) = HIDWORD(v6);
      unsigned int v11 = *v4++;
      uint64_t result = v11;
      uint64_t v12 = (AESSubBytesWordTable[BYTE5(v6)] | (AESSubBytesWordTable[(v9 >> 8) >> 24] << 24) | (AESSubBytesWordTable[((v9 >> 8) >> 16)] << 16) | (AESSubBytesWordTable[(unsigned __int16)(HIDWORD(v6) >> 8) >> 8] << 8)) ^ v11;
      v5 ^= v12 ^ ((v5 ^ v12) << 32);
      v6 ^= HIDWORD(v5) ^ ((v6 ^ HIDWORD(v5)) << 32);
      unint64_t *v7 = v5;
      v7[1] = v6;
      v7 += 2;
      BOOL v13 = __OFSUB__(v8, 4);
      v8 -= 4;
    }

    while (!((v8 < 0) ^ v13 | (v8 == 0)));
  }

  return result;
}

uint64_t ccaes_arm_encrypt_key128(unint64_t *a1, uint64_t a2)
{
  return aes_key_expansion(a1, a2, 4, 10);
}

uint64_t ccaes_arm_encrypt_key192(unint64_t *a1, uint64_t a2)
{
  return aes_key_expansion(a1, a2, 6, 12);
}

uint64_t ccaes_arm_encrypt_key256(unint64_t *a1, uint64_t a2)
{
  return aes_key_expansion(a1, a2, 8, 14);
}

__n128 aes_dkey_expansion(unint64_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = (__n128 *)(a2 + 16);
  uint64_t v5 = a4 - 1;
  do
  {
    --v5;
    _Q0 = *v4;
    __asm { AESIMC          V0.16B, V0.16B }

    *v4++ = result;
  }

  while (!(_NF ^ _VF | _ZF));
  return result;
}

double ccaes_arm_decrypt_key128(unint64_t *a1, uint64_t a2)
{
  *(void *)&double result = aes_dkey_expansion(a1, a2, 4, 10LL).n128_u64[0];
  return result;
}

double ccaes_arm_decrypt_key192(unint64_t *a1, uint64_t a2)
{
  *(void *)&double result = aes_dkey_expansion(a1, a2, 6, 12LL).n128_u64[0];
  return result;
}

double ccaes_arm_decrypt_key256(unint64_t *a1, uint64_t a2)
{
  *(void *)&double result = aes_dkey_expansion(a1, a2, 8, 14LL).n128_u64[0];
  return result;
}

uint64_t ccaes_arm_encrypt_key(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v6 = a2;
  unint64_t v8 = a3;
  if (a3 > 32) {
    unint64_t v8 = (unint64_t)a3 >> 3;
  }
  switch(v8)
  {
    case 0x10uLL:
      ccaes_arm_encrypt_key128(a4, v6);
      break;
    case 0x18uLL:
      ccaes_arm_encrypt_key192(a4, v6);
      break;
    case 0x20uLL:
      ccaes_arm_encrypt_key256(a4, v6);
      break;
    default:
      return -1LL;
  }

  return 0LL;
}

uint64_t ccaes_arm_decrypt_key(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v6 = a2;
  unint64_t v8 = a3;
  if (a3 > 32) {
    unint64_t v8 = (unint64_t)a3 >> 3;
  }
  switch(v8)
  {
    case 0x10uLL:
      ccaes_arm_decrypt_key128(a4, v6);
      break;
    case 0x18uLL:
      ccaes_arm_decrypt_key192(a4, v6);
      break;
    case 0x20uLL:
      ccaes_arm_decrypt_key256(a4, v6);
      break;
    default:
      return -1LL;
  }

  return 0LL;
}

uint64_t *ccrng_prng(_DWORD *a1)
{
  BOOL v3 = timingsafe_enable_if_supported();
  pthread_once(&ccrng_prng_init_pred, (void (*)(void))init);
  if (a1) {
    *a1 = 0;
  }
  cc_disable_dit_with_sb((unsigned int *)&v3);
  return &rng_ctx;
}

uint64_t init()
{
  if (ccrng_process_init( (uint64_t)&process_rng_ctx,  get_time_nsec,  (uint64_t (**)(void, uint64_t, _OWORD *))&ccrng_getentropy)) {
    cc_abort();
  }
  uint64_t result = pthread_atfork((void (*)(void))atfork_prepare, (void (*)(void))atfork_parent, (void (*)(void))atfork_child);
  if ((_DWORD)result) {
    cc_abort();
  }
  rng_ctx = (uint64_t)generate;
  return result;
}

uint64_t *ccrng(_DWORD *a1)
{
  return &rng_ctx;
}

uint64_t get_time_nsec()
{
  v1.tv_seCC_SHA1_CTX c = 0LL;
  v1.tv_nseCC_SHA1_CTX c = 0LL;
  if (clock_gettime(_CLOCK_MONOTONIC, &v1)) {
    cc_abort();
  }
  return v1.tv_nsec + 1000000000 * v1.tv_sec;
}

uint64_t atfork_prepare()
{
  uint64_t result = ccrng_process_atfork_prepare((os_unfair_lock_s *)&process_rng_ctx);
  if ((_DWORD)result) {
    cc_abort();
  }
  return result;
}

uint64_t atfork_parent()
{
  uint64_t result = ccrng_process_atfork_parent((os_unfair_lock_s *)&process_rng_ctx);
  if ((_DWORD)result) {
    cc_abort();
  }
  return result;
}

uint64_t atfork_child()
{
  uint64_t result = ccrng_process_atfork_child((uint64_t)&process_rng_ctx);
  if ((_DWORD)result) {
    cc_abort();
  }
  return result;
}

uint64_t generate()
{
  uint64_t result = process_rng_ctx();
  if ((_DWORD)result) {
    cc_abort();
  }
  return result;
}

uint64_t ccaes_arm_encrypt_key_with_length_check(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 > 127)
  {
    if (a3 != 128 && a3 != 256 && a3 != 192) {
      return 4294967289LL;
    }
    return ccaes_arm_encrypt_key(a1, a2, a3, a4);
  }

  return 4294967289LL;
}

uint64_t ccec_mult_blinded_ws( uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (**a6)(void, uint64_t, uint64_t *))
{
  unint64_t v10 = *a2;
  unint64_t v11 = ccn_bitlen_internal(*a2, a4);
  uint64_t v17 = 1LL;
  if (a6)
  {
    uint64_t result = (*a6)(a6, 8LL, &v17);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v13 = v17 | 0x80000000LL;
  }

  else
  {
    uint64_t v13 = 2147483649LL;
  }

  uint64_t v17 = v13;
  uint64_t v14 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v10);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v10);
  ccn_mux_seed_mask(v17);
  uint64_t v17 = v17;
  uint64_t result = ccec_mult_ws(a1, (uint64_t)a2);
  if (!(_DWORD)result)
  {
    uint64_t v16 = 0LL;
    ccn_divmod_ws(a1, v10, a4, v10, v15, 1LL, (char *)&v16, (uint64_t)&v17);
    cczp_bitlen((uint64_t)a2);
    uint64_t result = ccec_mult_ws(a1, (uint64_t)a2);
    if (!(_DWORD)result)
    {
      uint64_t result = ccec_mult_ws(a1, (uint64_t)a2);
      if (!(_DWORD)result)
      {
        ccec_full_add_ws(a1, (uint64_t)a2);
        uint64_t result = 0LL;
      }
    }
  }

  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccaes_arm_encrypt_key_with_key_length_check( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 > 127)
  {
    if (a3 != 128 && a3 != 256 && a3 != 192) {
      return 4294967289LL;
    }
    return ccaes_arm_encrypt_key(a1, a2, a3, a4);
  }

  return 4294967289LL;
}

uint64_t ccecdh_compute_shared_secret_ws( uint64_t a1, unint64_t **a2, unint64_t **a3, unint64_t *a4, char *a5, uint64_t (**a6)(void, uint64_t, uint64_t *))
{
  unint64_t v11 = *a2;
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v12 = 3 * **a2;
  uint64_t v13 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  unint64_t v15 = *a4;
  *a4 = 0LL;
  unint64_t v16 = ccn_write_uint_size_internal(*v11, v11 + 3);
  if (v15 < v16
    || *a2 != *a3
    || (unint64_t v17 = v16,
        ccec_validate_point_and_projectify_ws(a1, (uint64_t *)v11, (uint64_t)v14, (uint64_t)(a3 + 2)))
    || ccec_validate_scalar(v11, (uint64_t)&a2[3 * **a2 + 2])
    || ccec_mult_blinded_ws(a1, v11, (uint64_t)v13, (uint64_t)&a2[3 * **a2 + 2], (uint64_t)v14, a6)
    || !ccec_is_point_projective_ws(a1, v11)
    || ccec_affinify_x_only_ws(a1, (uint64_t *)v11, (uint64_t)v13, (uint64_t)v13))
  {
    uint64_t v18 = 0xFFFFFFFFLL;
  }

  else
  {
    ccn_write_uint_padded_ct_internal(*v11, v13, v17, a5);
    uint64_t v18 = 0LL;
    *a4 = v17;
  }

  cc_clear(24 * *v11, v13);
  cc_clear(24 * *v11, v14);
  *(void *)(a1 + 16) = v21;
  return v18;
}

uint64_t ccecdh_compute_shared_secret( unint64_t **a1, unint64_t **a2, unint64_t *a3, char *a4, uint64_t (**a5)(void, uint64_t, uint64_t *))
{
  BOOL v15 = timingsafe_enable_if_supported();
  unint64_t v10 = *a1;
  v13[0] = cc_malloc_clear(232 * **a1);
  v13[1] = 29 * *v10;
  v13[2] = 0LL;
  v13[3] = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v13[0])
  {
    uint64_t v11 = ccecdh_compute_shared_secret_ws((uint64_t)v13, a1, a2, a3, a4, a5);
    v14((uint64_t)v13);
  }

  else
  {
    uint64_t v11 = 4294967283LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v11;
}

void *ccaes_cbc_encrypt_mode()
{
  return &ccaes_arm_cbc_encrypt_mode;
}

uint64_t ccec_generate_scalar_fips_retry_ws( uint64_t a1, void *a2, uint64_t (**a3)(void, unint64_t, void *), void *a4)
{
  unint64_t v8 = a2 + 4;
  uint64_t v9 = (uint64_t)&a2[5 * *a2 + 4];
  uint64_t v10 = cczp_n(v9);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v10);
  uint64_t v13 = (void *)cczp_prime(v9);
  ccn_set(v10, v12, v13);
  *v12 &= ~1uLL;
  uint64_t v14 = 100LL;
  while (1)
  {
    uint64_t v15 = cczp_bitlen((uint64_t)&v8[5 * *a2]);
    uint64_t result = ccn_random_bits_fips(v15, a4, a3);
    if ((_DWORD)result) {
      break;
    }
    if ((ccn_cmp_public_value(v10, a4, v12) & 0x80000000) != 0)
    {
      ccn_add1_ws(a1, v10, a4, a4, 1LL);
      uint64_t result = 0LL;
      break;
    }

    if (!--v14)
    {
      uint64_t result = 4294967281LL;
      break;
    }
  }

  *(void *)(a1 + 16) = v11;
  return result;
}

uint64_t ccn_cond_swap(uint64_t a1, char a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = ccn_mux_next_mask();
  for (uint64_t i = __ROR8__(0x5555555555555555LL, a2 | (2 * result)); a1; --a1)
  {
    uint64_t v10 = *a4 ^ *a3;
    *a3 ^= result;
    uint64_t v11 = *a4 ^ result;
    *a4 = v11;
    uint64_t v12 = *a3 ^ v10 & 0x5555555555555555LL;
    uint64_t v13 = v11 ^ v10 & 0x5555555555555555LL;
    uint64_t v14 = v10 & i;
    *a3++ = v12 ^ v14 ^ result;
    *a4++ = v13 ^ v14 ^ result;
  }

  return result;
}

uint64_t ccec_sign_internal_inner_ws( uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t (**a10)(void, uint64_t, uint64_t *))
{
  uint64_t v15 = *a2;
  uint64_t v22 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, unint64_t))(a1 + 24))(a1, *a2);
  unint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v15);
  uint64_t result = ccec_mult_blinded_ws(a1, a2, (uint64_t)v16, a5, a6, a10);
  if (!(_DWORD)result)
  {
    uint64_t result = ccec_affinify_x_only_ws(a1, (uint64_t *)a2, (uint64_t)v16, (uint64_t)v16);
    if (!(_DWORD)result)
    {
      uint64_t v18 = (uint64_t)&a2[5 * v15 + 4];
      uint64_t v19 = (unint64_t *)cczp_prime(v18);
      BOOL v20 = ccn_sub_ws(a1, v15, a8, v16, v19);
      uint64_t v21 = (uint64_t *)cczp_prime(v18);
      ccn_cond_add(v15, v20, a8, a8, v21);
      if (ccn_n(v15, a8))
      {
        cczp_mul_ws(a1, v18);
        cczp_mul_ws(a1, v18);
        cczp_mul_ws(a1, v18);
        cczp_mul_ws(a1, v18);
        cczp_add_ws(a1, v18);
        uint64_t result = cczp_inv_ws(a1, v18);
        if (!(_DWORD)result)
        {
          cczp_mul_ws(a1, v18);
          if (ccn_n(v15, a9)) {
            uint64_t result = 0LL;
          }
          else {
            uint64_t result = 4294967131LL;
          }
        }
      }

      else
      {
        uint64_t result = 4294967131LL;
      }
    }
  }

  *(void *)(a1 + 16) = v22;
  return result;
}

uint64_t ccec_sign_internal_ws( uint64_t a1, uint64_t **a2, unint64_t a3, uint64_t a4, void *a5, void *a6, uint64_t (**a7)(void, unint64_t, void *))
{
  uint64_t v11 = *a2;
  uint64_t v13 = (uint64_t)(*a2 + 4);
  uint64_t v12 = **a2;
  if (a3 <= 0xF)
  {
    uint64_t v31 = (os_log_s *)cc_log_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
      ccec_verify_internal_with_base_ws_cold_1(a3, v31);
    }
  }

  uint64_t v35 = *(void *)(a1 + 16);
  uint64_t v14 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  __int128 v39 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v12);
  uint64_t uint_internal = ccec_projectify_ws(a1, (uint64_t)v11);
  int v32 = a7;
  int v37 = (void *)v15;
  uint64_t v17 = **a2;
  uint64_t v18 = cczp_bitlen(v13 + 40 * *v11);
  uint64_t v19 = a2;
  unint64_t v20 = v18;
  unint64_t v21 = (unint64_t)(v18 + 7) >> 3 >= a3 ? a3 : (unint64_t)(v18 + 7) >> 3;
  uint64_t uint_internal = ccn_read_uint_internal(v12, v14, v21, a4);
  if ((uint_internal & 0x80000000) != 0)
  {
LABEL_20:
    uint64_t v29 = uint_internal;
    uint64_t v24 = a5;
  }

  else
  {
    uint64_t v22 = (uint64_t)&v19[3 * v17 + 2];
    if (v20 < 8 * a3) {
      ccn_shift_right(v12, v14, v14, -(int)v20 & 7LL);
    }
    uint64_t v23 = (unint64_t *)cczp_prime(v13 + 40 * v12);
    uint64_t v24 = a5;
    char v25 = ccn_sub_ws(a1, v12, a5, v14->i64, v23);
    ccn_mux(v12, v25, v14->i64, v14->i64, a5);
    uint64_t scalar_fips_retry_ws = ccec_validate_scalar(v11, v22);
    if (!(_DWORD)scalar_fips_retry_ws)
    {
      int v27 = 10;
      while (1)
      {
        uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws(a1, v11, v32, v39);
        if ((_DWORD)scalar_fips_retry_ws) {
          break;
        }
        uint64_t scalar_fips_retry_ws = ccec_generate_scalar_fips_retry_ws(a1, v11, v32, v37);
        if ((_DWORD)scalar_fips_retry_ws) {
          break;
        }
        uint64_t v28 = ccec_sign_internal_inner_ws( a1,  (unint64_t *)v11,  (uint64_t)v14,  v22,  (uint64_t)v39,  v36,  (uint64_t)v37,  a5,  (uint64_t)a6,  (uint64_t (**)(void, uint64_t, uint64_t *))v32);
        uint64_t v29 = v28;
        if (!(_DWORD)v28) {
          goto LABEL_18;
        }
        if ((_DWORD)v28 != -165) {
          goto LABEL_17;
        }
        if (!--v27) {
          cc_try_abort();
        }
      }
    }

    uint64_t v29 = scalar_fips_retry_ws;
  }

uint64_t cczp_inv_field_ws(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = cczp_n(a2);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  uint64_t v11 = (unint64_t *)cczp_prime(a2);
  if (ccn_sub1(v8, v10, v11, 2uLL)) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = cczp_power_fast_ws(a1, a2, a3, a4, (uint64_t)v10);
  }
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t *ccaes_ctr_crypt_mode()
{
  unint64_t v0 = ((*(void *)ccaes_ecb_encrypt_mode() + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 48;
  timespec v1 = ccaes_ecb_encrypt_mode();
  ctr_crypt = v0;
  unk_3AA3B8 = xmmword_27FB90;
  qword_3AA3C8 = (uint64_t)ccmode_ctr_init;
  unk_3AA3D0 = ccmode_ctr_setctr;
  qword_3AA3D8 = (uint64_t)ccaes_vng_ctr_crypt;
  unk_3AA3E0 = v1;
  return &ctr_crypt;
}

void *ccaes_ecb_encrypt_mode()
{
  return &ccaes_arm_ecb_encrypt_mode;
}

uint64_t *ccaes_gcm_decrypt_mode()
{
  unint64_t v0 = 5 * ((*((void *)ccaes_ecb_encrypt_mode() + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v1 = v0 + ((*(void *)ccaes_ecb_encrypt_mode() + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 384;
  __int128 v2 = ccaes_ecb_encrypt_mode();
  gcm_decrypt = v1;
  qword_3AA3F0 = 78647LL;
  qword_3AA3F8 = 1LL;
  unk_3AA400 = ccmode_gcm_init;
  qword_3AA408 = (uint64_t)ccmode_gcm_set_iv;
  unk_3AA410 = ccmode_gcm_aad;
  qword_3AA418 = (uint64_t)ccaes_vng_gcm_decrypt;
  unk_3AA420 = ccmode_gcm_finalize;
  qword_3AA428 = (uint64_t)ccmode_gcm_reset;
  unk_3AA430 = v2;
  return &gcm_decrypt;
}

uint64_t *ccaes_gcm_encrypt_mode()
{
  unint64_t v0 = 5 * ((*((void *)ccaes_ecb_encrypt_mode() + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v1 = v0 + ((*(void *)ccaes_ecb_encrypt_mode() + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 384;
  __int128 v2 = ccaes_ecb_encrypt_mode();
  gcm_encrypt = v1;
  qword_3AA440 = 4073947LL;
  qword_3AA448 = 1LL;
  unk_3AA450 = ccmode_gcm_init;
  qword_3AA458 = (uint64_t)ccmode_gcm_set_iv;
  unk_3AA460 = ccmode_gcm_aad;
  qword_3AA468 = (uint64_t)ccaes_vng_gcm_encrypt;
  unk_3AA470 = ccmode_gcm_finalize;
  qword_3AA478 = (uint64_t)ccmode_gcm_reset;
  unk_3AA480 = v2;
  return &gcm_encrypt;
}

uint64_t ccder_blob_encode_eckey_internal( uint64_t *a1, uint64_t a2, uint64_t a3, const void *a4, unint64_t a5, const void *a6)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v10 = a1[1];
  if (a5 && a6)
  {
    char v13 = 0;
    if (!ccder_blob_encode_body(a1, a5, a6)
      || !ccder_blob_encode_body(a1, 1uLL, &v13)
      || !ccder_blob_encode_tl(a1, 3uLL, v10 - a1[1]))
    {
      return 0LL;
    }

    uint64_t result = ccder_blob_encode_tl(a1, 0xA000000000000001LL, v10 - a1[1]);
    if (!(_DWORD)result) {
      return result;
    }
  }

  if (!a4
    || (uint64_t v12 = a1[1], result = ccder_blob_encode_oid(a1, a4), (_DWORD)result)
    && (uint64_t result = ccder_blob_encode_tl(a1, 0xA000000000000000LL, v12 - a1[1]), (_DWORD)result))
  {
    uint64_t result = ccder_blob_encode_raw_octet_string((uint64_t)a1, a2, a3);
    if ((_DWORD)result)
    {
      uint64_t result = ccder_blob_encode_uint64(a1, 1uLL);
      if ((_DWORD)result) {
        return ccder_blob_encode_tl(a1, 0x2000000000000010uLL, v10 - a1[1]);
      }
    }
  }

  return result;
}

uint64_t ccec_compact_export_pub(char *a1, uint64_t *a2)
{
  BOOL v3 = (unint64_t *)(a2 + 2);
  uint64_t v4 = (unint64_t *)*a2;
  unint64_t v6 = (unint64_t)(cczp_bitlen(*a2) + 7) >> 3;
  return ccec_export_affine_point_public_value(v4, 4, v3, &v6, a1);
}

uint64_t ccder_blob_decode_range(unsigned __int8 **a1, uint64_t a2, unsigned __int8 **a3)
{
  unint64_t v8 = 0LL;
  uint64_t result = ccder_blob_decode_tl_internal(a1, a2, &v8, 0);
  if ((_DWORD)result)
  {
    unint64_t v6 = *a1;
    BOOL v7 = &(*a1)[v8];
    *a1 = v7;
    *a3 = v6;
    a3[1] = v7;
  }

  else
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  return result;
}

uint64_t ccder_blob_decode_len_strict(unsigned __int8 **a1, unint64_t *a2)
{
  return ccder_blob_decode_len_internal(a1, a2, 1);
}

uint64_t ccder_blob_decode_len_internal(unsigned __int8 **a1, unint64_t *a2, int a3)
{
  uint64_t v4 = *a1;
  unint64_t v3 = (unint64_t)a1[1];
  if (*a1) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  BOOL v7 = v4 + 1;
  unint64_t v8 = *v4;
  if ((char)*v4 < 0)
  {
    switch(*v4)
    {
      case 0x81u:
        if ((uint64_t)(v3 - (void)v7) >= 1)
        {
          BOOL v7 = v4 + 2;
          int v10 = (char)v4[1];
          unint64_t v8 = v10;
          if (!a3 || v10 < 0) {
            break;
          }
        }

        goto LABEL_10;
      case 0x82u:
        if ((uint64_t)(v3 - (void)v7) >= 2)
        {
          BOOL v7 = v4 + 3;
          unint64_t v8 = __rev16(*(unsigned __int16 *)(v4 + 1));
          if (!a3 || v8 >= 0x100) {
            break;
          }
        }

        goto LABEL_10;
      case 0x83u:
        if ((uint64_t)(v3 - (void)v7) >= 3)
        {
          BOOL v7 = v4 + 4;
          unint64_t v8 = ((unint64_t)v4[1] << 16) | ((unint64_t)v4[2] << 8) | v4[3];
          if (!a3 || v8 >= 0x10000) {
            break;
          }
        }

        goto LABEL_10;
      case 0x84u:
        if ((uint64_t)(v3 - (void)v7) >= 4)
        {
          BOOL v7 = v4 + 5;
          unint64_t v8 = bswap32(*(_DWORD *)(v4 + 1));
          if (!a3 || v8 >> 24) {
            break;
          }
        }

        goto LABEL_10;
      default:
        goto LABEL_10;
    }
  }

  if (v3 - (unint64_t)v7 < v8)
  {
LABEL_10:
    uint64_t result = 0LL;
    *a2 = 0LL;
  }

  else
  {
    *a2 = v8;
    *a1 = v7;
    return 1LL;
  }

  return result;
}

uint64_t ccder_blob_decode_len(unsigned __int8 **a1, unint64_t *a2)
{
  return ccder_blob_decode_len_internal(a1, a2, 0);
}

uint64_t ccder_blob_decode_oid(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unint64_t v3 = *a1;
  v6[0] = 0LL;
  v6[1] = 0LL;
  uint64_t result = ccder_blob_decode_range(a1, 6LL, v6);
  if ((_DWORD)result) {
    BOOL v5 = v3;
  }
  else {
    BOOL v5 = 0LL;
  }
  *a2 = v5;
  return result;
}

uint64_t ccder_blob_decode_sequence_tl(unsigned __int8 **a1, unsigned __int8 **a2)
{
  return ccder_blob_decode_range(a1, 0x2000000000000010LL, a2);
}

uint64_t ccder_blob_decode_tag(unsigned __int8 **a1, unint64_t *a2)
{
  __int128 v2 = *a1;
  unint64_t v3 = (unint64_t)a1[1];
  if (*a1) {
    BOOL v4 = (unint64_t)v2 >= v3;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0LL;
  }
  unsigned int v8 = *v2;
  unint64_t v6 = v2 + 1;
  unint64_t v7 = v8;
  unint64_t v9 = v8 & 0x1F;
  if (v9 == 31)
  {
    unint64_t v9 = 0LL;
    while (1)
    {
      uint64_t v5 = 0LL;
      unint64_t v10 = v9;
      if (v9 >> 57) {
        break;
      }
      char v11 = *v6++;
      unint64_t v9 = v11 & 0x7F | (v9 << 7);
      if ((v11 & 0x80) == 0)
      {
        if (v10 >> 54) {
          return 0LL;
        }
        goto LABEL_13;
      }
    }
  }

  else
  {
LABEL_13:
    *a2 = v9 | (v7 >> 5 << 61);
    *a1 = v6;
    return 1LL;
  }

  return v5;
}

uint64_t ccder_blob_decode_tl_internal(unsigned __int8 **a1, uint64_t a2, unint64_t *a3, int a4)
{
  unint64_t v10 = 0LL;
  *a3 = 0LL;
  int v8 = ccder_blob_decode_tag(a1, &v10);
  uint64_t result = 0LL;
  if (v8 && v10 == a2)
  {
    if (a4) {
      return ccder_blob_decode_len_strict(a1, a3);
    }
    else {
      return ccder_blob_decode_len(a1, a3);
    }
  }

  return result;
}

uint64_t ccder_blob_decode_uint64(unsigned __int8 **a1, unint64_t *a2)
{
  if (a2) {
    *a2 = 0LL;
  }
  unint64_t v7 = 0LL;
  int v8 = 0LL;
  uint64_t result = ccder_blob_decode_range(a1, 2LL, (unsigned __int8 **)&v7);
  if ((_DWORD)result)
  {
    BOOL v4 = (unsigned __int8 *)v7;
    if (*v7) {
      goto LABEL_7;
    }
    BOOL v4 = (unsigned __int8 *)(v7 + 1);
    if (v7 + 1 == (char *)v8)
    {
      BOOL v4 = v8;
    }

    else if (((char)*v4 & 0x80000000) == 0)
    {
      return 0LL;
    }

BOOL ccder_blob_reserve(void *a1, unint64_t a2, void *a3)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = v3 - *a1;
  if (v4 < a2)
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  else
  {
    a1[1] = v3 - a2;
    *a3 = v3 - a2;
    a3[1] = v3;
  }

  return v4 >= a2;
}

uint64_t ccder_blob_reserve_tl(uint64_t *a1, unint64_t a2, unint64_t a3, void *a4)
{
  __int128 v9 = 0uLL;
  *a4 = 0LL;
  a4[1] = 0LL;
  uint64_t result = ccder_blob_reserve(a1, a3, &v9);
  if ((_DWORD)result)
  {
    uint64_t result = ccder_blob_encode_tl(a1, a2, a3);
    if ((_DWORD)result)
    {
      *(_OWORD *)a4 = v9;
      return 1LL;
    }
  }

  return result;
}

uint64_t ccder_blob_encode_implicit_integer( uint64_t *a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  char v11 = 0LL;
  uint64_t v12 = 0LL;
  unint64_t v8 = ccn_write_int_size_public_value(a3, a4);
  uint64_t v9 = ccder_blob_reserve_tl(a1, a2, v8, &v11);
  if ((_DWORD)v9) {
    ccn_write_int_public_value(a3, a4, v12 - (void)v11, v11);
  }
  return v9;
}

uint64_t ccder_blob_encode_implicit_uint64(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a3;
  return ccder_blob_encode_implicit_integer(a1, a2, 1uLL, &v4);
}

uint64_t ccder_blob_encode_len(uint64_t *a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    return 0LL;
  }
  uint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  if (a2 > 0x7F)
  {
    if (a2 > 0xFF)
    {
      if (a2 >> 16)
      {
        if (a2 >> 24)
        {
          if (v3 + 5 <= v2)
          {
            *(_BYTE *)(v2 - 5) = -124;
            unint64_t v4 = v2 - 5;
            *(_DWORD *)(v4 + 1) = bswap32(a2);
            goto LABEL_17;
          }
        }

        else if (v3 + 4 <= v2)
        {
          *(_BYTE *)(v2 - 4) = -125;
          unint64_t v4 = v2 - 4;
          *(_WORD *)(v4 + 2) = bswap32(a2) >> 16;
          *(_BYTE *)(v4 + 1) = BYTE2(a2);
          goto LABEL_17;
        }
      }

      else if (v3 + 3 <= v2)
      {
        *(_BYTE *)(v2 - 3) = -126;
        unint64_t v4 = v2 - 3;
        *(_WORD *)(v4 + 1) = bswap32(a2) >> 16;
        goto LABEL_17;
      }
    }

    else if (v3 + 2 <= v2)
    {
      *(_BYTE *)(v2 - 2) = -127;
      unint64_t v4 = v2 - 2;
      *(_BYTE *)(v4 + 1) = a2;
      goto LABEL_17;
    }

    return 0LL;
  }

  if (v3 + 1 > v2) {
    return 0LL;
  }
  *(_BYTE *)(v2 - 1) = a2;
  unint64_t v4 = v2 - 1;
LABEL_17:
  *a1 = v3;
  a1[1] = v4;
  return 1LL;
}

BOOL ccder_blob_encode_oid(void *a1, const void *a2)
{
  unint64_t v4 = ccoid_size((uint64_t)a2);
  return ccder_blob_encode_body(a1, v4, a2);
}

uint64_t ccder_blob_encode_raw_octet_string(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ccder_blob_encode_implicit_raw_octet_string(a1, 4LL, a2, a3);
}

uint64_t ccder_blob_encode_tag(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  unint64_t v4 = a2 & 0x1FFFFFFFFFFFFFFFLL;
  if ((a2 & 0x1FFFFFFFFFFFFFFFLL) > 0x1E)
  {
    if (v4 <= 0x7F)
    {
      *(_BYTE *)(v2 - 1) = a2;
      unsigned int v6 = (_BYTE *)(v2 - 1);
LABEL_18:
      *(v6 - 1) = HIBYTE(a2) | 0x1F;
      unint64_t v5 = v6 - 1;
      goto LABEL_19;
    }

    if (v4 >> 14)
    {
      if (v4 >> 21)
      {
        unint64_t v9 = v2 - v3;
        if (v4 >> 28)
        {
          if (v9 < 6) {
            return 0LL;
          }
          uint64x2_t v11 = (uint64x2_t)vdupq_n_s64(a2);
          int16x8_t v12 = (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_27FBD0),  (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_27FBC0));
          v12.i64[0] = *(void *)&vmovn_s32((int32x4_t)v12) | 0x80008000800080LL;
          *(_DWORD *)(v2 - 5) = vmovn_s16(v12).u32[0];
          unsigned int v6 = (_BYTE *)(v2 - 5);
          v6[4] = a2 & 0x7F;
          goto LABEL_18;
        }

        if (v9 < 5) {
          return 0LL;
        }
        *(_BYTE *)(v2 - 4) = (a2 >> 21) | 0x80;
        unsigned int v6 = (_BYTE *)(v2 - 4);
        v6[3] = a2 & 0x7F;
        v6[2] = (a2 >> 7) | 0x80;
        unsigned int v8 = a2 >> 14;
      }

      else
      {
        *(_BYTE *)(v2 - 3) = (a2 >> 14) | 0x80;
        unsigned int v6 = (_BYTE *)(v2 - 3);
        v6[2] = a2 & 0x7F;
        unsigned int v8 = a2 >> 7;
      }

      char v7 = v8 | 0x80;
    }

    else
    {
      char v7 = a2 & 0x7F;
      *(_BYTE *)(v2 - 2) = (a2 >> 7) | 0x80;
      unsigned int v6 = (_BYTE *)(v2 - 2);
    }

    v6[1] = v7;
    goto LABEL_18;
  }

  if (v2 != v3)
  {
    *(_BYTE *)(v2 - 1) = HIBYTE(a2) & 0xE0 | a2;
    unint64_t v5 = (_BYTE *)(v2 - 1);
LABEL_19:
    *a1 = v3;
    a1[1] = (uint64_t)v5;
    return 1LL;
  }

  return 0LL;
}

uint64_t ccder_blob_encode_tl(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t result = ccder_blob_encode_len(a1, a3);
  if ((_DWORD)result) {
    return ccder_blob_encode_tag(a1, a2);
  }
  return result;
}

uint64_t ccder_blob_encode_uint64(uint64_t *a1, unint64_t a2)
{
  return ccder_blob_encode_implicit_uint64(a1, 2uLL, a2);
}

uint64_t ccder_sizeof(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = ccder_sizeof_tag(a1);
  return v3 + a2 + ccder_sizeof_len(a2);
}

uint64_t ccder_blob_encode_body_tl(uint64_t *a1, unint64_t a2, unint64_t a3, const void *a4)
{
  uint64_t result = ccder_blob_encode_body(a1, a3, a4);
  if ((_DWORD)result) {
    return ccder_blob_encode_tl(a1, a2, a3);
  }
  return result;
}

uint64_t ccrng_schedule_read(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8)) {
    return 3LL;
  }
  uint64_t result = (**(uint64_t (***)(uint64_t))a1)(a1);
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = (_DWORD)result == 3;
  return result;
}

uint64_t ccrng_schedule_notify_reseed(_BYTE *a1)
{
  a1[8] = 0;
  return (*(uint64_t (**)(_BYTE *))(*(void *)a1 + 8LL))(a1);
}

uint64_t ccrng_schedule_atomic_flag_init(uint64_t result)
{
  *(void *)uint64_t result = ccrng_schedule_atomic_flag_info;
  *(_BYTE *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  *(_DWORD *)(result + 16) = 1;
  return result;
}

uint64_t ccrng_schedule_atomic_flag_set(uint64_t result)
{
  *(_DWORD *)(result + 16) = 3;
  return result;
}

uint64_t ccrng_schedule_timer_init(uint64_t a1, uint64_t (*a2)(void), uint64_t a3)
{
  *(void *)a1 = ccrng_schedule_timer_info;
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  uint64_t result = a2();
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t ccrng_schedule_tree_init(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)uint64_t result = ccrng_schedule_tree_info;
  *(_BYTE *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = a3;
  return result;
}

uint64_t ccrng_schedule_atomic_flag_read(uint64_t a1)
{
  unint64_t v1 = (unsigned int *)(a1 + 16);
  do
    uint64_t result = __ldxr(v1);
  while (__stxr(1u, v1));
  return result;
}

uint64_t ccrng_schedule_timer_read(uint64_t a1)
{
  else {
    return 3LL;
  }
}

uint64_t ccrng_schedule_timer_notify_reseed(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1 + 16))();
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t ccrng_schedule_tree_read(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (*(_BYTE *)(v2 + 8))
  {
    unsigned int v3 = 3;
  }

  else
  {
    unsigned int v3 = (**(uint64_t (***)(void))v2)(*(void *)(a1 + 16));
    *(_BYTE *)(v2 + _Block_object_dispose((const void *)(v11 - 96), 8) = v3 == 3;
  }

  uint64_t v4 = *(void *)(a1 + 24);
  if (*(_BYTE *)(v4 + 8))
  {
    LODWORD(result) = 3;
  }

  else
  {
    LODWORD(result) = (**(uint64_t (***)(uint64_t))v4)(v4);
    *(_BYTE *)(v4 + _Block_object_dispose((const void *)(v11 - 96), 8) = (_DWORD)result == 3;
  }

  else {
    return v3;
  }
}

uint64_t ccrng_schedule_tree_notify_reseed(uint64_t a1)
{
  uint64_t v2 = *(_BYTE **)(a1 + 16);
  v2[8] = 0;
  (*(void (**)(_BYTE *))(*(void *)v2 + 8LL))(v2);
  unsigned int v3 = *(_BYTE **)(a1 + 24);
  v3[8] = 0;
  return (*(uint64_t (**)(_BYTE *))(*(void *)v3 + 8LL))(v3);
}

uint64_t ccder_sizeof_implicit_integer(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  unint64_t v4 = ccn_write_int_size_public_value(a2, a3);
  return ccder_sizeof(a1, v4);
}

uint64_t ccder_sizeof_implicit_uint64(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  return ccder_sizeof_implicit_integer(a1, 1uLL, &v3);
}

uint64_t ccder_blob_decode_eckey_internal( unsigned __int8 **a1, unint64_t *a2, void *a3, void *a4, unsigned __int8 **a5, void *a6, void *a7, unint64_t *a8)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  __int128 v22 = 0uLL;
  uint64_t result = ccder_blob_decode_sequence_tl(a1, (unsigned __int8 **)&v22);
  if ((_DWORD)result)
  {
    uint64_t result = ccder_blob_decode_uint64((unsigned __int8 **)&v22, a2);
    if ((_DWORD)result)
    {
      if (*a2 == 1)
      {
        uint64_t result = ccder_blob_decode_range((unsigned __int8 **)&v22, 4LL, &v23);
        if (!(_DWORD)result) {
          return result;
        }
        unint64_t v16 = v23;
        uint64_t v17 = v24;
        *a4 = v23;
        *a3 = v17 - (void)v16;
        __int128 v21 = v22;
        if ((ccder_blob_decode_range((unsigned __int8 **)&v21, 0xA000000000000000LL, &v23) & 1) != 0)
        {
          uint64_t result = ccder_blob_decode_oid(&v23, a5);
          if (!(_DWORD)result) {
            return result;
          }
          __int128 v22 = v21;
        }

        else
        {
          *a5 = 0LL;
        }

        __int128 v20 = v22;
        if ((ccder_blob_decode_range((unsigned __int8 **)&v20, 0xA000000000000001LL, &v23) & 1) != 0)
        {
          uint64_t result = ccder_blob_decode_bitstring(&v23, (uint64_t)&v23, a8);
          if ((_DWORD)result)
          {
            uint64_t v18 = v23;
            uint64_t v19 = v24;
            *a7 = v23;
            *a6 = v19 - (void)v18;
            return 1LL;
          }
        }

        else
        {
          *a7 = 0LL;
          *a6 = 0LL;
          uint64_t result = 1LL;
          *a8 = 0LL;
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t ccder_sizeof_len(unint64_t a1)
{
  if (a1 < 0x80) {
    return 1LL;
  }
  uint64_t v2 = 3LL;
  uint64_t v3 = 4LL;
  uint64_t v4 = 5LL;
  uint64_t v5 = 6LL;
  uint64_t v6 = 7LL;
  uint64_t v7 = 8LL;
  if (HIBYTE(a1)) {
    uint64_t v7 = 9LL;
  }
  if (HIWORD(a1)) {
    uint64_t v6 = v7;
  }
  if (a1 >> 40) {
    uint64_t v5 = v6;
  }
  if (HIDWORD(a1)) {
    uint64_t v4 = v5;
  }
  if (a1 >> 24) {
    uint64_t v3 = v4;
  }
  if (a1 >= 0x10000) {
    uint64_t v2 = v3;
  }
  if (a1 >= 0x100) {
    return v2;
  }
  else {
    return 2LL;
  }
}

uint64_t ccn_n_asm(uint64_t result, uint64_t *a2)
{
  if (result)
  {
    unint64_t v2 = result;
    uint64_t result = 0LL;
    unint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *a2++;
      ++v3;
      if (v4) {
        uint64_t result = v3;
      }
    }

    while (v3 < v2);
  }

  return result;
}

uint64_t ccaes_vng_ctr_crypt( void *a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a1[1];
  if (a2)
  {
    unint64_t v10 = a2;
    uint64_t v11 = *a1;
    unint64_t v12 = (unint64_t)(*(void *)(*a1 + 8LL) + 7LL) >> 3;
    char v13 = a1 + 2;
    uint64_t v14 = (int8x16_t *)&a1[2 * v12 + 2];
    uint64_t v15 = (int8x16_t *)&a1[v12 + 2];
    unint64_t v16 = &a1[v12];
    while (1)
    {
      if (v7 == 16)
      {
        if (v10 >= 0x10)
        {
          aes_ctr_crypt(a3, a4, v10 & 0xFFFFFFFFFFFFFFF0LL, v15, v14, a6);
          a4 = (int8x16_t *)((char *)a4 + (v10 & 0xFFFFFFFFFFFFFFF0LL));
          a3 = (int8x16_t *)((char *)a3 + (v10 & 0xFFFFFFFFFFFFFFF0LL));
          v10 &= 0xFu;
        }

        (*(void (**)(int8x16_t *, uint64_t, int8x16_t *, void *))(v11 + 24))(v14, 1LL, v15, a1 + 2);
        uint64_t v17 = 31LL;
        do
        {
          __int16 v18 = (*((_BYTE *)v16 + v17--))++ + 1;
        }

        while ((v18 & 0x100) != 0);
        uint64_t v7 = 0LL;
        uint64_t v19 = 0LL;
        if (!v10) {
          break;
        }
      }

      uint64_t v20 = 0LL;
      do
      {
        uint64_t v21 = v20 + 1;
        a4->i8[v20] = *((_BYTE *)v13 + v7 + v20) ^ a3->i8[v20];
        BOOL v22 = (unint64_t)(v20 + 1 + v7) > 0xF || v10 - 1 == v20;
        ++v20;
      }

      while (!v22);
      v7 += v21;
      a3 = (int8x16_t *)((char *)a3 + v21);
      a4 = (int8x16_t *)((char *)a4 + v21);
      v10 -= v21;
      if (!v10) {
        goto LABEL_17;
      }
    }
  }

  else
  {
LABEL_17:
    uint64_t v19 = v7;
  }

  a1[1] = v19;
  return 0LL;
}

uint64_t ccder_sizeof_tag(uint64_t a1)
{
  unint64_t v1 = a1 & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v2 = 2LL;
  uint64_t v3 = 3LL;
  uint64_t v4 = 4LL;
  uint64_t v5 = 5LL;
  if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >> 28) {
    uint64_t v5 = 6LL;
  }
  if (v1 >= 0x200000) {
    uint64_t v4 = v5;
  }
  if (v1 >= 0x4000) {
    uint64_t v3 = v4;
  }
  if (v1 >= 0x80) {
    uint64_t v2 = v3;
  }
  if (v1 >= 0x1F) {
    return v2;
  }
  else {
    return 1LL;
  }
}

uint64_t ccder_sizeof_uint64(unint64_t a1)
{
  return ccder_sizeof_implicit_uint64(2LL, a1);
}

void *cczp_to_default_ws(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = cczp_n(a2);
  return ccn_set(v6, a3, a4);
}

uint64_t cczp_to_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 56LL))();
}

void cc_try_abort()
{
}

uint64_t cc_try_abort_if (uint64_t result)
{
  if ((_DWORD)result) {
    cc_abort();
  }
  return result;
}

unint64_t cczp_negate(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v6 = cczp_n(a1);
  BOOL v7 = ccn_n(v6, a3) != 0;
  unsigned int v8 = (uint64_t *)cczp_prime(a1);
  return ccn_cond_rsub(v6, v7, a2, a3, v8);
}

unint64_t cczp_cond_negate(uint64_t a1, unsigned __int8 a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = cczp_n(a1);
  uint64_t v9 = (ccn_n(v8, a4) != 0) & a2;
  unint64_t v10 = (uint64_t *)cczp_prime(a1);
  return ccn_cond_rsub(v8, v9, a3, a4, v10);
}

void *cczp_from_default_ws(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = cczp_n(a2);
  return ccn_set(v6, a3, a4);
}

uint64_t cczp_from_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 64LL))();
}

uint64_t ccec_compact_transform_key_ws(uint64_t a1, uint64_t **a2)
{
  uint64_t v4 = a2 + 2;
  uint64_t v3 = *a2;
  uint64_t v5 = **a2;
  uint64_t v6 = (unint64_t *)&a2[v5 + 2];
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v5);
  cczp_negate((uint64_t)v3, v8, v6);
  uint64_t result = ccn_cmp_public_value(v5, v8, v6);
  if ((result & 0x80000000) != 0)
  {
    ccn_set(v5, v6, v8);
    unint64_t v10 = (uint64_t *)cczp_prime((uint64_t)&v3[5 * *v3 + 4]);
    uint64_t result = ccn_sub_ws(a1, v5, &v4[3 * v5], v10, (unint64_t *)&v4[3 * v5]);
  }

  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccec_compact_generate_key( uint64_t *a1, uint64_t (**a2)(void, uint64_t, uint64_t *), uint64_t **a3)
{
  BOOL v15 = timingsafe_enable_if_supported();
  uint64_t v6 = cc_malloc_clear(392 * *a1);
  uint64_t v7 = 49 * *a1;
  v11[0] = v6;
  v11[1] = v7;
  uint64_t v12 = 0LL;
  char v13 = cc_ws_alloc;
  uint64_t v14 = cc_ws_free;
  if (v6)
  {
    uint64_t key_internal_fips_ws = ccec_generate_key_internal_fips_ws((uint64_t)v11, a1, a2, a3);
    if ((_DWORD)key_internal_fips_ws)
    {
      uint64_t v9 = key_internal_fips_ws;
    }

    else
    {
      ccec_compact_transform_key_ws((uint64_t)v11, a3);
      if (ccec_pairwise_consistency_check_ws( (uint64_t)v11,  (unint64_t **)a3,  (uint64_t (**)(void, unint64_t, void *))a2)) {
        uint64_t v9 = 4294967278LL;
      }
      else {
        uint64_t v9 = 0LL;
      }
    }

    uint64_t v12 = 0LL;
    v14((uint64_t)v11);
  }

  else
  {
    uint64_t v9 = 4294967283LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v15);
  return v9;
}

unint64_t ccn_mul1_asm(uint64_t a1, void *a2, unint64_t *a3, unint64_t a4)
{
  unint64_t v4 = 0LL;
  if ((a1 & 1) != 0)
  {
    unint64_t v5 = *a3++;
    unint64_t v4 = (v5 * (unsigned __int128)a4) >> 64;
    *a2++ = v5 * a4;
    --a1;
  }

  if ((a1 & 2) != 0)
  {
    unint64_t v6 = *a3;
    unint64_t v7 = a3[1];
    a3 += 2;
    unsigned __int128 v8 = v6 * (unsigned __int128)a4 + __PAIR128__(v7 * a4, v4);
    unint64_t v4 = (__CFADD__(__CFADD__(v6 * a4, v4), (v6 * (unsigned __int128)a4) >> 64) | __CFADD__( v7 * a4,  *((void *)&v8 + 1)))
       + ((v7 * (unsigned __int128)a4) >> 64);
    *(_OWORD *)a2 = v8;
    a2 += 2;
    a1 -= 2LL;
  }

  while (1)
  {
    BOOL v9 = a1 < 4;
    a1 -= 4LL;
    if (v9) {
      break;
    }
    unint64_t v11 = *a3;
    unint64_t v12 = a3[1];
    unint64_t v10 = a3 + 2;
    unint64_t v14 = *v10;
    unint64_t v15 = v10[1];
    a3 = v10 + 2;
    uint64_t v16 = (v12 * (unsigned __int128)a4) >> 64;
    BOOL v17 = __CFADD__(__CFADD__(v11 * a4, v4), (v11 * (unsigned __int128)a4) >> 64);
    unsigned __int128 v13 = v11 * (unsigned __int128)a4 + __PAIR128__(v12 * a4, v4);
    *(_OWORD *)a2 = v13;
    __int16 v18 = a2 + 2;
    uint64_t v19 = (v14 * (unsigned __int128)a4) >> 64;
    uint64_t v20 = v16 + (v17 | __CFADD__(v12 * a4, *((void *)&v13 + 1))) + v14 * a4;
    uint64_t v22 = __CFADD__(v17 | __CFADD__(v12 * a4, *((void *)&v13 + 1)), v14 * a4) | __CFADD__(v16, (v17 | __CFADD__(v12 * a4, *((void *)&v13 + 1))) + v14 * a4);
    BOOL v17 = __CFADD__(v22, v19);
    uint64_t v21 = v22 + v19;
    unint64_t v4 = (v17 | __CFADD__(v15 * a4, v21)) + ((v15 * (unsigned __int128)a4) >> 64);
    void *v18 = v20;
    v18[1] = v15 * a4 + v21;
    a2 = v18 + 2;
  }

  return v4;
}

uint64_t ccdigest_internal(uint64_t a1, size_t a2, char *a3, uint64_t a4)
{
  size_t v8 = (*(void *)(a1 + 8) + *(void *)(a1 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL;
  BOOL v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v9, v8);
  ccdigest_init_internal(a1, v9);
  ccdigest_update_internal((unint64_t *)a1, v9, a2, a3);
  (*(void (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v9, a4);
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL, v9);
}

uint64_t ccdigest_final_64be(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  size_t v9 = (v7 + v6 + 19) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = (uint64_t *)((char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  bzero(v10, v9);
  memcpy(v10, a2, v7 + v6 + 12);
  uint64_t v11 = (char *)v10 + v7;
  uint64_t v12 = (uint64_t)v10 + v7 + 8;
  unsigned __int128 v13 = (char *)(v12 + v6);
  uint64_t v14 = *(unsigned int *)(v12 + v6);
  *v10 += (8 * v14);
  *(_DWORD *)(v12 + v6) = v14 + 1;
  *(_BYTE *)(v12 + v14) = 0x80;
  unint64_t v15 = *(unsigned int *)(v12 + v6);
  if (v15 < 0x39)
  {
    if (v15 == 56) {
      goto LABEL_9;
    }
  }

  else
  {
    if (v15 <= 0x3F)
    {
      do
      {
        *(_DWORD *)unsigned __int128 v13 = v15 + 1;
        *(_BYTE *)(v12 + v15) = 0;
        unint64_t v15 = *(unsigned int *)v13;
      }

      while (v15 < 0x40);
    }

    (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1LL);
    unint64_t v15 = 0LL;
    uint64_t v11 = (char *)v10 + *(void *)(a1 + 8);
    uint64_t v12 = (uint64_t)(v11 + 8);
    unsigned __int128 v13 = &v11[*(void *)(a1 + 16) + 8];
    *(_DWORD *)unsigned __int128 v13 = 0;
  }

  do
  {
    *(_DWORD *)unsigned __int128 v13 = v15 + 1;
    *(_BYTE *)(v12 + v15) = 0;
    unint64_t v15 = *(unsigned int *)v13;
  }

  while (v15 < 0x38);
LABEL_9:
  *((void *)v11 + _Block_object_dispose((const void *)(v11 - 96), 8) = bswap64(*v10);
  (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1LL);
  if (*(void *)a1 >= 4uLL)
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0LL;
    unsigned int v18 = 1;
    do
    {
      *(_DWORD *)(a3 + v16) = bswap32(*((_DWORD *)v10 + v17 + 2));
      unint64_t v17 = v18++;
      v16 += 4;
    }

    while (v17 < *(void *)a1 >> 2);
  }

  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL, v10);
}

uint64_t ccdigest_final_64le(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  size_t v9 = (v7 + v6 + 19) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = (uint64_t *)((char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  bzero(v10, v9);
  memcpy(v10, a2, v7 + v6 + 12);
  uint64_t v11 = (char *)v10 + v7;
  uint64_t v12 = (uint64_t)v10 + v7 + 8;
  unsigned __int128 v13 = (char *)(v12 + v6);
  uint64_t v14 = *(unsigned int *)(v12 + v6);
  *v10 += (8 * v14);
  *(_DWORD *)(v12 + v6) = v14 + 1;
  *(_BYTE *)(v12 + v14) = 0x80;
  unint64_t v15 = *(unsigned int *)(v12 + v6);
  if (v15 < 0x39)
  {
    if (v15 == 56) {
      goto LABEL_9;
    }
  }

  else
  {
    if (v15 <= 0x3F)
    {
      do
      {
        *(_DWORD *)unsigned __int128 v13 = v15 + 1;
        *(_BYTE *)(v12 + v15) = 0;
        unint64_t v15 = *(unsigned int *)v13;
      }

      while (v15 < 0x40);
    }

    (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1LL);
    unint64_t v15 = 0LL;
    uint64_t v11 = (char *)v10 + *(void *)(a1 + 8);
    uint64_t v12 = (uint64_t)(v11 + 8);
    unsigned __int128 v13 = &v11[*(void *)(a1 + 16) + 8];
    *(_DWORD *)unsigned __int128 v13 = 0;
  }

  do
  {
    *(_DWORD *)unsigned __int128 v13 = v15 + 1;
    *(_BYTE *)(v12 + v15) = 0;
    unint64_t v15 = *(unsigned int *)v13;
  }

  while (v15 < 0x38);
LABEL_9:
  *((void *)v11 + _Block_object_dispose((const void *)(v11 - 96), 8) = *v10;
  (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1LL);
  if (*(void *)a1 >= 4uLL)
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0LL;
    unsigned int v18 = 1;
    do
    {
      *(_DWORD *)(a3 + v16) = *((_DWORD *)v10 + v17 + 2);
      unint64_t v17 = v18++;
      v16 += 4;
    }

    while (v17 < *(void *)a1 >> 2);
  }

  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL, v10);
}

uint64_t ccec_generate_scalar_fips_extrabits_ws( uint64_t a1, void *a2, unint64_t a3, uint64_t a4, char *a5)
{
  unint64_t v10 = a2 + 4;
  uint64_t v11 = (uint64_t)&a2[5 * *a2 + 4];
  uint64_t v12 = cczp_n(v11);
  uint64_t v13 = *(void *)(a1 + 16);
  if (a3 < (unint64_t)(cczp_bitlen((uint64_t)&v10[5 * *a2]) + 71) >> 3)
  {
    uint64_t result = 4294967276LL;
  }

  else if (a3 > 0x80)
  {
    uint64_t result = 4294967289LL;
  }

  else
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 16LL);
    unint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
    unsigned int v16 = (void *)cczp_prime(v11);
    ccn_set(v12, v15, v16);
    *v15 &= ~1uLL;
    uint64_t result = ccn_read_uint_internal(16LL, v14, a3, a4);
    if (!(_DWORD)result)
    {
      ccn_divmod_ws(a1, (a3 + 7) >> 3, v14, 0LL, 0LL, v12, a5, (uint64_t)v15);
      ccn_add1_ws(a1, v12, a5, (uint64_t *)a5, 1LL);
      uint64_t result = 0LL;
    }
  }

  *(void *)(a1 + 16) = v13;
  return result;
}

void *ccdigest_init_internal(uint64_t a1, void *a2)
{
  uint64_t result = memcpy(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  *a2 = 0LL;
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  return result;
}

uint64_t ccdigest_init(uint64_t a1, void *a2)
{
  BOOL v5 = timingsafe_enable_if_supported();
  memcpy(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  *a2 = 0LL;
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  return cc_disable_dit_with_sb((unsigned int *)&v5);
}

unint64_t ccec_signature_r_s_size(uint64_t *a1)
{
  return (unint64_t)(cczp_bitlen(*a1) + 7) >> 3;
}

unint64_t *ccdigest_update_internal(unint64_t *result, void *a2, size_t a3, char *__src)
{
  size_t v5 = a3;
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (uint64_t)a2 + result[1] + 8;
  if (a3)
  {
    unint64_t v10 = a2 + 1;
    do
    {
      size_t v11 = v7[2];
      uint64_t v12 = (char *)v10 + v7[1];
      uint64_t v13 = *(unsigned int *)&v12[v11];
      if (v5 > v11 && (_DWORD)v13 == 0)
      {
        if (v11 == 128)
        {
          size_t v22 = v5 >> 7;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFF80LL;
        }

        else if (v11 == 64)
        {
          size_t v22 = v5 >> 6;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          size_t v22 = v5 / v11;
          size_t v16 = v5 / v11 * v11;
        }

        uint64_t result = (unint64_t *)((uint64_t (*)(void *, size_t, char *))v7[6])(a2 + 1, v22, __src);
        *a2 += 8 * v16;
      }

      else
      {
        size_t v15 = v11 - v13;
        if (v15 >= v5) {
          size_t v16 = v5;
        }
        else {
          size_t v16 = v15;
        }
        uint64_t result = (unint64_t *)memcpy(&v12[v13], __src, v16);
        unint64_t v17 = v7[2];
        unsigned int v18 = (char *)v10 + v7[1];
        uint64_t v19 = (*(_DWORD *)&v18[v17] + v16);
        *(_DWORD *)&v18[v17] = v19;
        if (v17 == v19)
        {
          uint64_t result = (unint64_t *)((uint64_t (*)(void *, uint64_t))v7[6])(a2 + 1, 1LL);
          unint64_t v20 = v7[2];
          uint64_t v21 = (char *)v10 + v7[1];
          *a2 += (8 * *(_DWORD *)&v21[v20]);
          *(_DWORD *)&v21[v20] = 0;
        }
      }

      __src += v16;
      v5 -= v16;
    }

    while (v5);
  }

  return result;
}

uint64_t ccdigest_update(unint64_t *a1, void *a2, size_t a3, char *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  ccdigest_update_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb((unsigned int *)&v9);
}

void *ccdrbg_factory_nistctr(void *result, uint64_t a2)
{
  *uint64_t result = 88LL;
  result[1] = init_0;
  result[2] = reseed;
  result[3] = generate_0;
  result[4] = done;
  result[5] = a2;
  result[6] = must_reseed;
  return result;
}

uint64_t init_0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(uint64_t **)(a1 + 40);
  cc_clear(0x58uLL, (void *)a2);
  uint64_t v19 = *v13;
  rsize_t v20 = v13[1];
  *(void *)(a2 + 56) = *v13;
  *(void *)(a2 + 64) = v20;
  *(_DWORD *)(a2 + 72) = *((_DWORD *)v13 + 4);
  uint64_t v21 = v13[3];
  *(void *)(a2 + 80) = v21;
  if (v20 >= 0x21 || *(void *)(v19 + 16) != 16LL) {
    cc_try_abort();
  }
  if (!v21)
  {
    if (v20 + 16 >= a7 && v20 + 16 == a3)
    {
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 __s = 0u;
      __memcpy_chk(&__s, a4, a3, 48LL);
      for (; a7; --a7)
        *((_BYTE *)&v27 + a7 + 7) ^= *(_BYTE *)(a8 - 1 + a7);
      goto LABEL_8;
    }

    uint64_t v22 = 4294967233LL;
LABEL_16:
    cc_clear(0x20uLL, (void *)a2);
    cc_clear(0x10uLL, (void *)(a2 + 32));
    uint64_t v24 = -1LL;
    goto LABEL_9;
  }

  uint64_t v22 = 4294967233LL;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 __s = 0u;
  HIBYTE(v27) = HIBYTE(a8);
  uint64_t v23 = derive(a2, &__s, 3u, v14, v15, v16, v17, v18, a3);
  if ((_DWORD)v23)
  {
    uint64_t v22 = v23;
    goto LABEL_16;
  }

  rsize_t v20 = *(void *)(a2 + 64);
LABEL_8:
  cc_clear(v20, (void *)a2);
  cc_clear(0x10uLL, (void *)(a2 + 32));
  update(a2, (uint64_t)&__s);
  uint64_t v22 = 0LL;
  uint64_t v24 = 1LL;
LABEL_9:
  *(void *)(a2 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v24;
  cc_clear(0x30uLL, &__s);
  return v22;
}

uint64_t generate_0(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  v25[0] = 0LL;
  v25[1] = 0LL;
  size_t v10 = (cczp_n(*(void *)(a1 + 56)) + 15) & 0xFFFFFFFFFFFFFFF0LL;
  size_t v11 = (char *)v24 - v10;
  bzero((char *)v24 - v10, v10);
  if (a2 > 0x10000) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 72) && *(void *)(a1 + 48) > 0x1000000000000uLL)
  {
    uint64_t v18 = 4294967234LL;
    goto LABEL_21;
  }

  if (!a4) {
    goto LABEL_12;
  }
  if (*(void *)(a1 + 80))
  {
    if (a4 <= 0x10000)
    {
      uint64_t v17 = derive(a1, __s, 1u, v12, v13, v14, v15, v16, a4);
      if ((_DWORD)v17)
      {
        uint64_t v18 = v17;
        goto LABEL_21;
      }

      goto LABEL_11;
    }

uint64_t reseed( void *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = a4;
  memset(__s, 0, sizeof(__s));
  if (!a1[10])
  {
    unint64_t v14 = a1[8] + 16LL;
    if (v14 < a4 || v14 != a2) {
      return 4294967233LL;
    }
    __memcpy_chk(__s, a3, a2, 48LL);
    for (; v9; --v9)
      *((_BYTE *)&v16 + v9 + 7) ^= *(_BYTE *)(a5 - 1 + v9);
    goto LABEL_6;
  }

  uint64_t v11 = 4294967233LL;
  if (a2 <= 0x10000 && a4 <= 0x10000 && *(void *)(a1[7] + 16LL) <= a2)
  {
    HIBYTE(v16) = HIBYTE(a5);
    uint64_t v12 = derive((uint64_t)a1, __s, 2u, a4, a5, a6, a7, a8, a2);
    if ((_DWORD)v12)
    {
      uint64_t v11 = v12;
      goto LABEL_7;
    }

uint64_t done(char *__s)
{
  uint64_t result = cc_clear(0x10uLL, __s + 32);
  *((void *)__s + 6) = -1LL;
  return result;
}

BOOL must_reseed(uint64_t a1)
{
  return *(_DWORD *)(a1 + 72) && *(void *)(a1 + 48) > 0x1000000000000uLL;
}

uint64_t derive( uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v15 = &a9;
  if (a3)
  {
    uint64_t v10 = a3;
    uint64_t v11 = (uint64_t *)v16 + 1;
    uint64_t v12 = a3;
    do
    {
      uint64_t v13 = v15;
      *uint64_t v11 = *v15;
      v15 += 2;
      *(v11 - 1) = v13[1];
      v11 += 2;
      --v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  return ccdrbg_df_derive_keys(*(uint64_t (***)(void))(a1 + 80), v10, (uint64_t)v16, *(void *)(a1 + 64) + 16LL, a2);
}

uint64_t update(uint64_t a1, uint64_t a2)
{
  size_t v4 = (cczp_n(*(void *)(a1 + 56)) + 15) & 0xFFFFFFFFFFFFFFF0LL;
  size_t v5 = (char *)&v8 - v4;
  bzero((char *)&v8 - v4, v4);
  inc_uint(a1 + 40, 8uLL);
  ccctr_init_internal(*(void *)(a1 + 56));
  update_with_ctr(a1, (uint64_t)v5, a2);
  rsize_t v6 = cczp_n(*(void *)(a1 + 56));
  return cc_clear(v6, v5);
}

uint64_t update_with_ctr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ccctr_update_internal(*(void *)(a1 + 56), a2, 16LL, a3 + *(void *)(a1 + 64), a1 + 32);
}

uint64_t ccec_affinify_jacobian_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *a2;
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  uint64_t v9 = cczp_inv_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_from_ws(a1, (uint64_t)a2);
  cczp_from_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v8;
  return v9;
}

uint64_t ccec_affinify_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 80LL))();
}

uint64_t ccec_affinify_x_only_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *a2;
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  cczp_sqr_ws(a1, (uint64_t)a2);
  uint64_t v9 = cczp_inv_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_from_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v8;
  return v9;
}

uint64_t ccn_sqr_ws(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * a2);
  uint64_t result = ccn_mul1(a2 - 1, v9 + 8, a4 + 1, *a4);
  *(void *)(v9 + 8 * a2) = result;
  __int128 v11 = *a4;
  *a3 = *a4 * *a4;
  unint64_t v12 = *(void *)(v9 + 8);
  else {
    uint64_t v13 = v12 >> 63;
  }
  a3[1] = (__PAIR128__(2LL, v11) * v11) >> 64;
  unint64_t v14 = a2 - 2;
  if (a2 >= 2)
  {
    uint64_t v15 = 0LL;
    uint64_t v16 = v9 + 8 * a2 + 8;
    uint64_t v17 = (unint64_t *)(v9 + 24);
    uint64_t v18 = a3 + 3;
    do
    {
      uint64_t result = ccn_addmul1(v14, v17, &a4[v15 + 2], a4[v15 + 1]);
      *(void *)(v16 + v15 * _Block_object_dispose((const void *)(v11 - 96), 8) = result;
      unint64_t v19 = a4[v15 + 1];
      uint64_t v20 = (v19 * (unsigned __int128)v19) >> 64;
      unint64_t v21 = v19 * v19;
      BOOL v22 = __CFADD__(v21, v13);
      unint64_t v23 = v21 + v13;
      if (v22) {
        ++v20;
      }
      unint64_t v24 = *(v17 - 1);
      *(v18 - 1) = v23 + 2 * v24;
      unint64_t v25 = *v17;
      v17 += 2;
      uint64_t v26 = v25 >> 63;
      BOOL v22 = __CFADD__(v20, 2 * v25);
      uint64_t v27 = v20 + 2 * v25;
      if (v22) {
        uint64_t v28 = v26 + 1;
      }
      else {
        uint64_t v28 = v26;
      }
      BOOL v22 = __CFADD__(__CFADD__(v23, 2 * v24), v27) | __CFADD__(v24 >> 63, __CFADD__(v23, 2 * v24) + v27);
      unint64_t v29 = (v24 >> 63) + __CFADD__(v23, 2 * v24) + v27;
      if (v22) {
        uint64_t v13 = v28 + 1;
      }
      else {
        uint64_t v13 = v28;
      }
      unint64_t *v18 = v29;
      v18 += 2;
      ++v15;
      --v14;
    }

    while (v14 != -1LL);
  }

  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccn_p256_to_ws(uint64_t a1, uint64_t a2)
{
  return cczp_mul_ws(a1, a2);
}

uint64_t ccn_p384_to_ws(uint64_t a1, uint64_t a2)
{
  return cczp_mul_ws(a1, a2);
}

void *ccec_cp_521()
{
  return &ccec_cp521;
}

uint64_t ccn_mod_521_ws(uint64_t a1, uint64_t a2, uint64_t *a3, int8x16_t *a4)
{
  uint64_t v15 = 0LL;
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = 0LL;
  memset(v12, 0, sizeof(v12));
  ccn_shift_right(9LL, v12, a4 + 4, 9LL);
  v13 += a4[4].i64[0] & 0x1FF;
  uint64_t v8 = ccn_add_ws(a1, 8LL, v12, v12[0].i64, a4->i64);
  v13 += v8;
  uint64_t v9 = (unint64_t *)cczp_prime(a2);
  char v10 = ccn_sub_ws(a1, 9LL, v14, v12[0].i64, v9);
  return ccn_mux(9LL, v10, a3, v12[0].i64, (uint64_t *)v14);
}

uint64_t ccec_double_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_sub_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t ccec_export_pub(uint64_t *a1, char *a2)
{
  uint64_t v3 = (unint64_t *)(a1 + 2);
  uint64_t v4 = (unint64_t *)*a1;
  unint64_t v6 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 2) | 1;
  return ccec_export_affine_point_public_value(v4, 1, v3, &v6, a2);
}

uint64_t ccec_add_normalized_ws(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v9 = *a2;
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, *a2);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  if (a6) {
    cczp_add_ws(a1, (uint64_t)a2);
  }
  else {
    cczp_sub_ws(a1, (uint64_t)a2);
  }
  if (ccn_n(v9, v10) || ccn_n(v9, v11))
  {
    if (ccn_n(v9, v10) || !ccn_n(v9, v11))
    {
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      uint64_t result = cczp_div2_ws(a1, (uint64_t)a2, (int8x16_t *)&a3[v9], &a3[v9]);
    }

    else
    {
      ccn_seti(v9, a3, 1LL);
      cczp_to_ws(a1, (uint64_t)a2);
      ccn_set(v9, &a3[v9], a3);
      uint64_t result = cc_clear(8 * v9, &a3[2 * v9]);
    }
  }

  else
  {
    uint64_t result = ccec_double_ws(a1, a2);
  }

  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_full_add_normalized_ws(uint64_t a1, uint64_t *a2, char *a3, uint64_t a4, char *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *a2;
  if (ccec_is_point_at_infinity(a2, a4))
  {
    ccn_set(v11, a3, a5);
    ccn_set(v11, &a3[8 * *a2], &a5[8 * *a2]);
    uint64_t result = (uint64_t)ccn_set(v11, &a3[16 * *a2], &a5[16 * *a2]);
  }

  else
  {
    uint64_t result = ccec_add_normalized_ws(a1, a2, a3, a4, (uint64_t)a5, 0);
  }

  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccec_full_add_default_ws(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = cczp_n((uint64_t)a2);
  uint64_t v16 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  ccec_map_to_homogeneous_ws(a1, (uint64_t)a2);
  ccec_map_to_homogeneous_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  uint64_t v7 = cczp_n((uint64_t)a2);
  uint64_t v8 = *a2;
  uint64_t v9 = &a3[*a2];
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  ccn_set(v7, v10, v9);
  cczp_from_ws(a1, (uint64_t)a2);
  BOOL v12 = ccn_n(v7, v11) == 1 && *v11 == 1LL;
  uint64_t v13 = &a3[2 * v8];
  if (ccn_n(v7, a3)) {
    BOOL v12 = 0;
  }
  char v14 = v12 & (ccn_n(v7, v13) == 0);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  ccn_mux(v7, v14, a3, (uint64_t *)v10, a3);
  uint64_t result = ccn_mux(v7, v14, v9, (uint64_t *)v10, v9);
  *(void *)(a1 + 16) = v16;
  return result;
}

uint64_t ccec_map_to_homogeneous_ws(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = cczp_n(a2);
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_mul_ws(a1, a2);
  cczp_sqr_ws(a1, a2);
  uint64_t result = cczp_mul_ws(a1, a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t ccec_full_add_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 88LL))();
}

uint64_t ccec_full_sub_normalized_ws(uint64_t a1, uint64_t *a2, char *a3, uint64_t a4, char *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *a2;
  if (ccec_is_point_at_infinity(a2, a4))
  {
    ccn_set(v11, a3, a5);
    cczp_negate((uint64_t)a2, (uint64_t *)&a3[8 * *a2], (unint64_t *)&a5[8 * *a2]);
    uint64_t result = (uint64_t)ccn_set(v11, &a3[16 * *a2], &a5[16 * *a2]);
  }

  else
  {
    uint64_t result = ccec_add_normalized_ws(a1, a2, a3, a4, (uint64_t)a5, 1);
  }

  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t ccec_full_sub_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, char *a5)
{
  uint64_t v8 = *a2;
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *a2);
  ccn_set(v8, v10, a5);
  cczp_negate((uint64_t)a2, (uint64_t *)&v10[8 * *a2], (unint64_t *)&a5[8 * *a2]);
  ccn_set(v8, &v10[16 * *a2], &a5[16 * *a2]);
  uint64_t result = ccec_full_add_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v9;
  return result;
}

int8x16_t *aes_ctr_crypt(int8x16_t *a1, int8x16_t *a2, uint64_t a3, int8x16_t *a4, int8x16_t *a5, uint64_t a6)
{
  int v6 = a5[15].i32[0];
  BOOL v8 = __OFSUB__(a3, 128LL);
  BOOL v7 = a3 - 128 < 0;
  uint64_t v9 = a3 - 128;
  if (v7 != v8) {
    return Decrypt_Main_Loop_End(a1, a2, v9, a4, a5, a6, v6);
  }
  else {
    return (int8x16_t *)Decrypt_Main_Loop(a1, a2, v9, (uint64_t)a4, a5, a6, v6);
  }
}

uint64_t Decrypt_Main_Loop( _OWORD *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, int8x16_t *a5, uint64_t a6, int a7)
{
  do
  {
    int64x2_t v8 = vaddq_s64(v7, vaddq_s64(v7, vaddq_s64(v7, vaddq_s64(v7, v8))));
    _Q20 = *a5;
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[1];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[2];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[3];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[4];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[5];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[6];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[7];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[8];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a5[9];
    int8x16_t v167 = a5[10];
    if (a7 > 160)
    {
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = a5[10];
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = a5[11];
      int8x16_t v167 = a5[12];
      if (a7 > 192)
      {
        __asm
        {
          AESE            V22.16B, V20.16B
          AESMC           V22.16B, V22.16B
          AESE            V23.16B, V20.16B
          AESMC           V23.16B, V23.16B
          AESE            V24.16B, V20.16B
          AESMC           V24.16B, V24.16B
          AESE            V25.16B, V20.16B
          AESMC           V25.16B, V25.16B
          AESE            V26.16B, V20.16B
          AESMC           V26.16B, V26.16B
          AESE            V27.16B, V20.16B
          AESMC           V27.16B, V27.16B
          AESE            V28.16B, V20.16B
          AESMC           V28.16B, V28.16B
          AESE            V29.16B, V20.16B
          AESMC           V29.16B, V29.16B
        }

        _Q20 = a5[12];
        __asm
        {
          AESE            V22.16B, V20.16B
          AESMC           V22.16B, V22.16B
          AESE            V23.16B, V20.16B
          AESMC           V23.16B, V23.16B
          AESE            V24.16B, V20.16B
          AESMC           V24.16B, V24.16B
          AESE            V25.16B, V20.16B
          AESMC           V25.16B, V25.16B
          AESE            V26.16B, V20.16B
          AESMC           V26.16B, V26.16B
          AESE            V27.16B, V20.16B
          AESMC           V27.16B, V27.16B
          AESE            V28.16B, V20.16B
          AESMC           V28.16B, V28.16B
          AESE            V29.16B, V20.16B
          AESMC           V29.16B, V29.16B
        }

        _Q20 = a5[13];
        int8x16_t v167 = a5[14];
      }
    }

    int8x16_t v235 = *(int8x16_t *)a1;
    int8x16_t v236 = *((int8x16_t *)a1 + 1);
    int8x16_t v237 = *((int8x16_t *)a1 + 2);
    int8x16_t v238 = *((int8x16_t *)a1 + 3);
    v234 = a1 + 4;
    __asm
    {
      AESE            V22.16B, V20.16B
      AESE            V23.16B, V20.16B
      AESE            V24.16B, V20.16B
      AESE            V25.16B, V20.16B
    }

    int8x16_t v243 = veorq_s8(v235, veorq_s8(_Q22, v167));
    int8x16_t v244 = veorq_s8(v236, veorq_s8(_Q23, v167));
    int8x16_t v245 = veorq_s8(v237, veorq_s8(_Q24, v167));
    int8x16_t v246 = veorq_s8(v238, veorq_s8(_Q25, v167));
    int8x16_t v247 = *(int8x16_t *)v234;
    int8x16_t v248 = *((int8x16_t *)v234 + 1);
    int8x16_t v249 = *((int8x16_t *)v234 + 2);
    int8x16_t v250 = *((int8x16_t *)v234 + 3);
    a1 = v234 + 4;
    __asm
    {
      AESE            V26.16B, V20.16B
      AESE            V27.16B, V20.16B
      AESE            V28.16B, V20.16B
      AESE            V29.16B, V20.16B
    }

    *a2 = v243;
    a2[1] = v244;
    a2[2] = v245;
    a2[3] = v246;
    v255 = a2 + 4;
    int8x16_t *v255 = veorq_s8(v247, veorq_s8(_Q26, v167));
    v255[1] = veorq_s8(v248, veorq_s8(_Q27, v167));
    v255[2] = veorq_s8(v249, veorq_s8(_Q28, v167));
    v255[3] = veorq_s8(v250, veorq_s8(_Q29, v167));
    a2 = v255 + 4;
    _VF = __OFSUB__(a3, 128LL);
    _NF = a3 - 128 < 0;
    a3 -= 128LL;
  }

  while (_NF == _VF);
  return Decrypt_Main_Loop_End();
}

int8x16_t *Decrypt_Main_Loop_End( int8x16_t *result, int8x16_t *a2, uint64_t a3, int8x16_t *a4, int8x16_t *a5, uint64_t a6, int a7)
{
  BOOL v10 = a3 < -112;
  for (uint64_t i = a3 + 112; !v10; i -= 16LL)
  {
    _Q4 = *a5;
    _Q5 = a5[1];
    _Q6 = a5[2];
    int64x2_t v9 = vaddq_s64(v7, v9);
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q4 = a5[3];
    _Q5 = a5[4];
    _Q6 = a5[5];
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q4 = a5[6];
    _Q5 = a5[7];
    _Q6 = a5[8];
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q20 = a5[9];
    _Q21 = a5[10];
    if (a7 > 160)
    {
      __asm
      {
        AESE            V7.16B, V20.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V21.16B
        AESMC           V7.16B, V7.16B
      }

      _Q20 = a5[11];
      _Q21 = a5[12];
      if (a7 > 192)
      {
        __asm
        {
          AESE            V7.16B, V20.16B
          AESMC           V7.16B, V7.16B
          AESE            V7.16B, V21.16B
          AESMC           V7.16B, V7.16B
        }

        _Q20 = a5[13];
        _Q21 = a5[14];
      }
    }

    __asm { AESE            V7.16B, V20.16B }

    int8x16_t v54 = *result++;
    *a2++ = veorq_s8(v54, veorq_s8(_Q7, _Q21));
    BOOL v10 = i < 16;
  }

  *a4 = vqtbl1q_s8((int8x16_t)v9, v8);
  return result;
}

void gcmEncrypt( int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, uint64_t a4, uint64x2_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10 = *(unsigned int *)(a6 + 240);
  int8x16_t v11 = vqtbl1q_s8(a3[1], *(int8x16_t *)Lbswap_mask_0);
  if (a4 < 128) {
    JUMPOUT(0x1FEEA8LL);
  }
  _Q20 = *(int8x16_t *)a6;
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 16);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 32);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 48);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 64);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 80);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 96);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 112);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 128);
  __asm
  {
    AESE            V22.16B, V20.16B
    AESMC           V22.16B, V22.16B
    AESE            V23.16B, V20.16B
    AESMC           V23.16B, V23.16B
    AESE            V24.16B, V20.16B
    AESMC           V24.16B, V24.16B
    AESE            V25.16B, V20.16B
    AESMC           V25.16B, V25.16B
    AESE            V26.16B, V20.16B
    AESMC           V26.16B, V26.16B
    AESE            V27.16B, V20.16B
    AESMC           V27.16B, V27.16B
    AESE            V28.16B, V20.16B
    AESMC           V28.16B, V28.16B
    AESE            V29.16B, V20.16B
    AESMC           V29.16B, V29.16B
  }

  _Q20 = *(_OWORD *)(a6 + 144);
  int8x16_t v170 = *(int8x16_t *)(a6 + 160);
  if ((int)v10 > 160)
  {
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = *(_OWORD *)(a6 + 160);
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = *(_OWORD *)(a6 + 176);
    int8x16_t v170 = *(int8x16_t *)(a6 + 192);
    if ((int)v10 > 192)
    {
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = *(_OWORD *)(a6 + 192);
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = *(_OWORD *)(a6 + 208);
      int8x16_t v170 = *(int8x16_t *)(a6 + 224);
    }
  }

  int8x16_t v238 = *a1;
  int8x16_t v239 = a1[1];
  int8x16_t v240 = a1[2];
  int8x16_t v241 = a1[3];
  int8x16_t v237 = a1 + 4;
  __asm
  {
    AESE            V22.16B, V20.16B
    AESE            V23.16B, V20.16B
    AESE            V24.16B, V20.16B
    AESE            V25.16B, V20.16B
  }

  *a2 = veorq_s8(veorq_s8(_Q22, v170), v238);
  a2[1] = veorq_s8(veorq_s8(_Q23, v170), v239);
  a2[2] = veorq_s8(veorq_s8(_Q24, v170), v240);
  a2[3] = veorq_s8(veorq_s8(_Q25, v170), v241);
  int8x16_t v246 = a2 + 4;
  int8x16_t v248 = *v237;
  int8x16_t v249 = v237[1];
  int8x16_t v250 = v237[2];
  int8x16_t v251 = v237[3];
  int8x16_t v247 = v237 + 4;
  __asm
  {
    AESE            V26.16B, V20.16B
    AESE            V27.16B, V20.16B
    AESE            V28.16B, V20.16B
    AESE            V29.16B, V20.16B
  }

  *int8x16_t v246 = veorq_s8(veorq_s8(_Q26, v170), v248);
  v246[1] = veorq_s8(veorq_s8(_Q27, v170), v249);
  v246[2] = veorq_s8(veorq_s8(_Q28, v170), v250);
  v246[3] = veorq_s8(veorq_s8(_Q29, v170), v251);
  v256 = v246 + 4;
  BOOL v257 = a4 < 256;
  uint64_t v258 = a4 - 256;
  if (v257) {
    Encrypt_Main_Loop_End(v247, v256, a3, v258, a5, (int8x16_t *)a6, v10, v11);
  }
  else {
    Encrypt_Main_Loop(v247, v256, (uint64_t)a3, v258, a5, (int8x16_t *)a6, v10, (uint64_t)qword_1FE140, v11, a9, a10);
  }
}

uint64_t Encrypt_Main_Loop( _OWORD *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64x2_t *a5, int8x16_t *a6, uint64_t a7, uint64_t a8, int8x16_t a9, uint64_t a10, uint64_t a11)
{
  do
  {
    int8x16_t v307 = veorq_s8(v14, a9);
    int8x16_t v306 = v15;
    int8x16_t v305 = v16;
    int8x16_t v304 = v17;
    int8x16_t v303 = v18;
    int8x16_t v302 = v19;
    int8x16_t v301 = (int8x16_t)v20;
    int32x4_t v22 = vaddq_s32(v11, vaddq_s32(v11, vaddq_s32(v11, vaddq_s32(v11, v22))));
    _Q20 = *a6;
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v35 = veorq_s8( (int8x16_t)vmull_p64(a5[8].u64[0], veorq_s8(vextq_s8(v21, v21, 8uLL), v21).u64[0]),  (int8x16_t)vmull_p64(a5[9].u64[0], veorq_s8(v301, vextq_s8(v301, v301, 8uLL)).u64[0]));
    uint64x2_t v36 = a5[1];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v41 = veorq_s8((int8x16_t)vmull_high_p64(*a5, (uint64x2_t)v21), (int8x16_t)vmull_high_p64(v36, v20));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v46 = veorq_s8((int8x16_t)vmull_p64(a5->i64[0], v21.u64[0]), (int8x16_t)vmull_p64(v36.u64[0], v301.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[1];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    uint64x2_t v56 = a5[2];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v61 = veorq_s8(v41, (int8x16_t)vmull_high_p64(v56, (uint64x2_t)v302));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v66 = veorq_s8(v46, (int8x16_t)vmull_p64(v56.u64[0], v302.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[2];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    uint64x2_t v76 = a5[3];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v81 = veorq_s8(v61, (int8x16_t)vmull_high_p64(v76, (uint64x2_t)v303));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v86 = veorq_s8(v66, (int8x16_t)vmull_p64(v76.u64[0], v303.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[3];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    uint64x2_t v96 = a5[4];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v101 = veorq_s8(v81, (int8x16_t)vmull_high_p64(v96, (uint64x2_t)v304));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v106 = veorq_s8(v86, (int8x16_t)vmull_p64(v96.u64[0], v304.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[4];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    uint64x2_t v116 = a5[5];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v121 = veorq_s8(v101, (int8x16_t)vmull_high_p64(v116, (uint64x2_t)v305));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v126 = veorq_s8(v106, (int8x16_t)vmull_p64(v116.u64[0], v305.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[5];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    uint64x2_t v136 = a5[6];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v141 = veorq_s8(v121, (int8x16_t)vmull_high_p64(v136, (uint64x2_t)v306));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v146 = veorq_s8(v126, (int8x16_t)vmull_p64(v136.u64[0], v306.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[6];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    uint64x2_t v156 = a5[7];
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v161 = veorq_s8(v141, (int8x16_t)vmull_high_p64(v156, (uint64x2_t)v307));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v166 = veorq_s8(v146, (int8x16_t)vmull_p64(v156.u64[0], v307.u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[7];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    int8x16_t v172 = veorq_s8( v166,  veorq_s8( v161,  veorq_s8( veorq_s8( veorq_s8( veorq_s8( veorq_s8( veorq_s8( v35,  (int8x16_t)vmull_p64(a5[10].u64[0], veorq_s8(v302, vextq_s8(v302, v302, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[11].u64[0], veorq_s8(v303, vextq_s8(v303, v303, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[12].u64[0], veorq_s8(v304, vextq_s8(v304, v304, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[13].u64[0], veorq_s8(v305, vextq_s8(v305, v305, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[14].u64[0], veorq_s8(v306, vextq_s8(v306, v306, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[15].u64[0], veorq_s8(v307, vextq_s8(v307, v307, 8uLL)).u64[0]))));
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v179 = veorq_s8(vextq_s8(v23, v172, 8uLL), v166);
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v182 = veorq_s8(vextq_s8(v179, v179, 8uLL), (int8x16_t)vmull_p64(v13, v179.u64[0]));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a6[8];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    a9 = veorq_s8( veorq_s8(vextq_s8(v172, v23, 8uLL), v161),  veorq_s8(vextq_s8(v182, v182, 8uLL), (int8x16_t)vmull_p64(v13, v182.u64[0])));
    _Q20 = a6[9];
    int8x16_t v207 = a6[10];
    if ((int)a7 > 160)
    {
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = a6[10];
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = a6[11];
      int8x16_t v207 = a6[12];
      if ((int)a7 > 192)
      {
        __asm
        {
          AESE            V22.16B, V20.16B
          AESMC           V22.16B, V22.16B
          AESE            V23.16B, V20.16B
          AESMC           V23.16B, V23.16B
          AESE            V24.16B, V20.16B
          AESMC           V24.16B, V24.16B
          AESE            V25.16B, V20.16B
          AESMC           V25.16B, V25.16B
          AESE            V26.16B, V20.16B
          AESMC           V26.16B, V26.16B
          AESE            V27.16B, V20.16B
          AESMC           V27.16B, V27.16B
          AESE            V28.16B, V20.16B
          AESMC           V28.16B, V28.16B
          AESE            V29.16B, V20.16B
          AESMC           V29.16B, V29.16B
        }

        _Q20 = a6[12];
        __asm
        {
          AESE            V22.16B, V20.16B
          AESMC           V22.16B, V22.16B
          AESE            V23.16B, V20.16B
          AESMC           V23.16B, V23.16B
          AESE            V24.16B, V20.16B
          AESMC           V24.16B, V24.16B
          AESE            V25.16B, V20.16B
          AESMC           V25.16B, V25.16B
          AESE            V26.16B, V20.16B
          AESMC           V26.16B, V26.16B
          AESE            V27.16B, V20.16B
          AESMC           V27.16B, V27.16B
          AESE            V28.16B, V20.16B
          AESMC           V28.16B, V28.16B
          AESE            V29.16B, V20.16B
          AESMC           V29.16B, V29.16B
        }

        _Q20 = a6[13];
        int8x16_t v207 = a6[14];
      }
    }

    int8x16_t v275 = *(int8x16_t *)a1;
    int8x16_t v276 = *((int8x16_t *)a1 + 1);
    int8x16_t v277 = *((int8x16_t *)a1 + 2);
    int8x16_t v278 = *((int8x16_t *)a1 + 3);
    v274 = a1 + 4;
    __asm
    {
      AESE            V22.16B, V20.16B
      AESE            V23.16B, V20.16B
      AESE            V24.16B, V20.16B
      AESE            V25.16B, V20.16B
    }

    int8x16_t v283 = veorq_s8(veorq_s8(_Q22, v207), v275);
    int8x16_t v284 = veorq_s8(veorq_s8(_Q23, v207), v276);
    int8x16_t v285 = veorq_s8(veorq_s8(_Q24, v207), v277);
    int8x16_t v286 = veorq_s8(veorq_s8(_Q25, v207), v278);
    *a2 = v283;
    a2[1] = v284;
    a2[2] = v285;
    a2[3] = v286;
    v287 = a2 + 4;
    int8x16_t v14 = vqtbl1q_s8(v283, v12);
    int8x16_t v15 = vqtbl1q_s8(v284, v12);
    int8x16_t v16 = vqtbl1q_s8(v285, v12);
    int8x16_t v17 = vqtbl1q_s8(v286, v12);
    int8x16_t v288 = *(int8x16_t *)v274;
    int8x16_t v289 = *((int8x16_t *)v274 + 1);
    int8x16_t v290 = *((int8x16_t *)v274 + 2);
    int8x16_t v291 = *((int8x16_t *)v274 + 3);
    a1 = v274 + 4;
    __asm
    {
      AESE            V26.16B, V20.16B
      AESE            V27.16B, V20.16B
      AESE            V28.16B, V20.16B
      AESE            V29.16B, V20.16B
    }

    int8x16_t v296 = veorq_s8(veorq_s8(_Q26, v207), v288);
    int8x16_t v297 = veorq_s8(veorq_s8(_Q27, v207), v289);
    int8x16_t v298 = veorq_s8(veorq_s8(_Q28, v207), v290);
    int8x16_t v299 = veorq_s8(veorq_s8(_Q29, v207), v291);
    int8x16_t *v287 = v296;
    v287[1] = v297;
    v287[2] = v298;
    v287[3] = v299;
    a2 = v287 + 4;
    int8x16_t v18 = vqtbl1q_s8(v296, v12);
    int8x16_t v19 = vqtbl1q_s8(v297, v12);
    uint64x2_t v20 = (uint64x2_t)vqtbl1q_s8(v298, v12);
    int8x16_t v21 = vqtbl1q_s8(v299, v12);
    _VF = __OFSUB__(a4, 128LL);
    _NF = a4 - 128 < 0;
    a4 -= 128LL;
  }

  while (_NF == _VF);
  return Encrypt_Main_Loop_End( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a10,  a11,  v301.i64[0],  v301.i64[1],  v302.i64[0],  v302.i64[1],  v303.i64[0],  v303.i64[1]);
}

int8x16_t Encrypt_Main_Loop_End( int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, uint64_t a4, uint64x2_t *a5, int8x16_t *a6, int a7, int8x16_t a8)
{
  uint64_t v21 = a4 + 128;
  int8x16_t v147 = veorq_s8(a8, v11);
  uint64x2_t v22 = a5[1];
  int8x16_t v23 = veorq_s8((int8x16_t)vmull_high_p64(*a5, (uint64x2_t)v18), (int8x16_t)vmull_high_p64(v22, (uint64x2_t)v17));
  int8x16_t v24 = veorq_s8((int8x16_t)vmull_p64(a5->i64[0], v18.u64[0]), (int8x16_t)vmull_p64(v22.u64[0], v17.u64[0]));
  uint64x2_t v25 = a5[2];
  int8x16_t v26 = veorq_s8(v23, (int8x16_t)vmull_high_p64(v25, (uint64x2_t)v16));
  int8x16_t v27 = veorq_s8(v24, (int8x16_t)vmull_p64(v25.u64[0], v16.u64[0]));
  uint64x2_t v28 = a5[3];
  int8x16_t v29 = veorq_s8(v26, (int8x16_t)vmull_high_p64(v28, (uint64x2_t)v15));
  int8x16_t v30 = veorq_s8(v27, (int8x16_t)vmull_p64(v28.u64[0], v15.u64[0]));
  uint64x2_t v31 = a5[4];
  int8x16_t v32 = veorq_s8(v29, (int8x16_t)vmull_high_p64(v31, (uint64x2_t)v14));
  int8x16_t v33 = veorq_s8(v30, (int8x16_t)vmull_p64(v31.u64[0], v14.u64[0]));
  uint64x2_t v34 = a5[5];
  int8x16_t v35 = veorq_s8(v32, (int8x16_t)vmull_high_p64(v34, (uint64x2_t)v13));
  int8x16_t v36 = veorq_s8(v33, (int8x16_t)vmull_p64(v34.u64[0], v13.u64[0]));
  uint64x2_t v37 = a5[6];
  int8x16_t v38 = veorq_s8(v35, (int8x16_t)vmull_high_p64(v37, (uint64x2_t)v12));
  int8x16_t v39 = veorq_s8(v36, (int8x16_t)vmull_p64(v37.u64[0], v12.u64[0]));
  uint64x2_t v40 = a5[7];
  int8x16_t v41 = veorq_s8(v38, (int8x16_t)vmull_high_p64(v40, (uint64x2_t)v147));
  int8x16_t v42 = veorq_s8(v39, (int8x16_t)vmull_p64(v40.u64[0], v147.u64[0]));
  int8x16_t v43 = veorq_s8( v42,  veorq_s8( v41,  veorq_s8( veorq_s8( veorq_s8( veorq_s8( veorq_s8( veorq_s8( veorq_s8( (int8x16_t)vmull_p64(a5[8].u64[0], veorq_s8(vextq_s8(v18, v18, 8uLL), v18).u64[0]),  (int8x16_t)vmull_p64(a5[9].u64[0], veorq_s8(v17, vextq_s8(v17, v17, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[10].u64[0], veorq_s8(v16, vextq_s8(v16, v16, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[11].u64[0], veorq_s8(v15, vextq_s8(v15, v15, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[12].u64[0], veorq_s8(v14, vextq_s8(v14, v14, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[13].u64[0], veorq_s8(v13, vextq_s8(v13, v13, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[14].u64[0], veorq_s8(v12, vextq_s8(v12, v12, 8uLL)).u64[0])),  (int8x16_t)vmull_p64(a5[15].u64[0], veorq_s8(v147, vextq_s8(v147, v147, 8uLL)).u64[0]))));
  int8x16_t v44 = veorq_s8(vextq_s8(v20, v43, 8uLL), v42);
  int8x16_t v45 = veorq_s8(vextq_s8(v44, v44, 8uLL), (int8x16_t)vmull_p64(v10, v44.u64[0]));
  int8x16_t v46 = veorq_s8( veorq_s8(vextq_s8(v43, v20, 8uLL), v41),  veorq_s8(vextq_s8(v45, v45, 8uLL), (int8x16_t)vmull_p64(v10, v45.u64[0])));
  BOOL v47 = v21 < 16;
  uint64_t v48 = v21 - 16;
  if (!v47)
  {
    _Q4 = *a6;
    _Q5 = a6[1];
    _Q6 = a6[2];
    int32x4_t v19 = vaddq_s32(v8, v19);
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q4 = a6[3];
    _Q5 = a6[4];
    _Q6 = a6[5];
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q4 = a6[6];
    _Q5 = a6[7];
    _Q6 = a6[8];
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q20 = a6[9];
    _Q21 = a6[10];
    if (a7 > 160)
    {
      __asm
      {
        AESE            V7.16B, V20.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V21.16B
        AESMC           V7.16B, V7.16B
      }

      _Q20 = a6[11];
      _Q21 = a6[12];
      if (a7 > 192)
      {
        __asm
        {
          AESE            V7.16B, V20.16B
          AESMC           V7.16B, V7.16B
          AESE            V7.16B, V21.16B
          AESMC           V7.16B, V7.16B
        }

        _Q20 = a6[13];
        _Q21 = a6[14];
      }
    }

    __asm { AESE            V7.16B, V20.16B }

    int8x16_t v92 = *a1;
    int8x16_t v91 = a1 + 1;
    int8x16_t v93 = veorq_s8(v92, veorq_s8(_Q7, _Q21));
    *a2 = v93;
    uint64_t v94 = a2 + 1;
    int8x16_t v95 = veorq_s8(v46, vqtbl1q_s8(v93, v9));
    uint64x2_t v96 = *(uint64x2_t *)((char *)a5 + v48);
    int8x16_t v97 = (int8x16_t)vmull_high_p64(v96, (uint64x2_t)v95);
    int8x16_t v98 = (int8x16_t)vmull_p64(v96.u64[0], v95.u64[0]);
    int8x16_t v99 = (int8x16_t)vmull_p64( *(unint64_t *)((char *)a5[8].u64 + v48),  veorq_s8(vextq_s8(v95, v95, 8uLL), v95).u64[0]);
    BOOL v47 = v48 < 16;
    for (uint64_t i = v48 - 16; !v47; i -= 16LL)
    {
      _Q4 = *a6;
      _Q5 = a6[1];
      _Q6 = a6[2];
      int32x4_t v19 = vaddq_s32(v8, v19);
      __asm
      {
        AESE            V7.16B, V4.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V5.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V6.16B
        AESMC           V7.16B, V7.16B
      }

      _Q4 = a6[3];
      _Q5 = a6[4];
      _Q6 = a6[5];
      __asm
      {
        AESE            V7.16B, V4.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V5.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V6.16B
        AESMC           V7.16B, V7.16B
      }

      _Q4 = a6[6];
      _Q5 = a6[7];
      _Q6 = a6[8];
      __asm
      {
        AESE            V7.16B, V4.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V5.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V6.16B
        AESMC           V7.16B, V7.16B
      }

      _Q20 = a6[9];
      _Q21 = a6[10];
      if (a7 > 160)
      {
        __asm
        {
          AESE            V7.16B, V20.16B
          AESMC           V7.16B, V7.16B
          AESE            V7.16B, V21.16B
          AESMC           V7.16B, V7.16B
        }

        _Q20 = a6[11];
        _Q21 = a6[12];
        if (a7 > 192)
        {
          __asm
          {
            AESE            V7.16B, V20.16B
            AESMC           V7.16B, V7.16B
            AESE            V7.16B, V21.16B
            AESMC           V7.16B, V7.16B
          }

          _Q20 = a6[13];
          _Q21 = a6[14];
        }
      }

      __asm { AESE            V7.16B, V20.16B }

      int8x16_t v139 = *v91++;
      int8x16_t v140 = veorq_s8(v139, veorq_s8(_Q7, _Q21));
      *v94++ = v140;
      int8x16_t v141 = vqtbl1q_s8(v140, v9);
      uint64x2_t v142 = *(uint64x2_t *)((char *)a5 + i);
      int8x16_t v97 = veorq_s8(v97, (int8x16_t)vmull_high_p64(v142, (uint64x2_t)v141));
      int8x16_t v98 = veorq_s8(v98, (int8x16_t)vmull_p64(v142.u64[0], v141.u64[0]));
      int8x16_t v99 = veorq_s8( v99,  (int8x16_t)vmull_p64( *(unint64_t *)((char *)a5[8].u64 + i),  veorq_s8(vextq_s8(v141, v141, 8uLL), v141).u64[0]));
      BOOL v47 = i < 16;
    }

    int8x16_t v143 = veorq_s8(v98, veorq_s8(v97, v99));
    int8x16_t v144 = veorq_s8(vextq_s8(v20, v143, 8uLL), v98);
    int8x16_t v145 = veorq_s8(vextq_s8(v144, v144, 8uLL), (int8x16_t)vmull_p64(v10, v144.u64[0]));
    int8x16_t v46 = veorq_s8( veorq_s8(vextq_s8(v143, v20, 8uLL), v97),  veorq_s8(vextq_s8(v145, v145, 8uLL), (int8x16_t)vmull_p64(v10, v145.u64[0])));
  }

  int8x16_t result = vqtbl1q_s8(v46, v9);
  a3[1] = result;
  a3[2] = vqtbl1q_s8((int8x16_t)v19, v9);
  return result;
}

void gcmDecrypt(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, uint64_t a4, uint64x2_t *a5, int8x16_t *a6)
{
  int v6 = a6[15].i32[0];
  int8x16_t v7 = vqtbl1q_s8(a3[1], *(int8x16_t *)Lbswap_mask_0);
  BOOL v8 = a4 < 128;
  uint64_t v9 = a4 - 128;
  if (v8) {
    Decrypt_Main_Loop_End_0(a1, a2, a3, v9, (uint64_t)a5, a6, v6, v7);
  }
  else {
    Decrypt_Main_Loop_0(a1, a2, v7, (uint64_t)a3, v9, a5, a6, v6);
  }
}

uint64_t Decrypt_Main_Loop_0( int8x16_t *a1, int8x16_t *a2, int8x16_t a3, uint64_t a4, uint64_t a5, uint64x2_t *a6, int8x16_t *a7, int a8)
{
  do
  {
    int8x16_t v13 = vqtbl1q_s8(a1[7], v9);
    int8x16_t v14 = (int8x16_t)vmull_high_p64(*a6, (uint64x2_t)v13);
    int8x16_t v15 = (int8x16_t)vmull_p64(a6->i64[0], v13.u64[0]);
    int32x4_t v11 = vaddq_s32(v8, vaddq_s32(v8, vaddq_s32(v8, vaddq_s32(v8, v11))));
    int8x16_t v16 = (int8x16_t)vmull_p64(a6[8].u64[0], veorq_s8(vextq_s8(v13, v13, 8uLL), v13).u64[0]);
    _Q20 = *a7;
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v24 = a6[1];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v27 = vqtbl1q_s8(a1[6], v9);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v30 = veorq_s8(v14, (int8x16_t)vmull_high_p64(v24, (uint64x2_t)v27));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v33 = veorq_s8(v15, (int8x16_t)vmull_p64(v24.u64[0], v27.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v40 = veorq_s8(v16, (int8x16_t)vmull_p64(a6[9].u64[0], veorq_s8(v27, vextq_s8(v27, v27, 8uLL)).u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[1];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v46 = a6[2];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v49 = vqtbl1q_s8(a1[5], v9);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v52 = veorq_s8(v30, (int8x16_t)vmull_high_p64(v46, (uint64x2_t)v49));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v55 = veorq_s8(v33, (int8x16_t)vmull_p64(v46.u64[0], v49.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v62 = veorq_s8(v40, (int8x16_t)vmull_p64(a6[10].u64[0], veorq_s8(v49, vextq_s8(v49, v49, 8uLL)).u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[2];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v68 = a6[3];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v71 = vqtbl1q_s8(a1[4], v9);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v74 = veorq_s8(v52, (int8x16_t)vmull_high_p64(v68, (uint64x2_t)v71));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v77 = veorq_s8(v55, (int8x16_t)vmull_p64(v68.u64[0], v71.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v84 = veorq_s8(v62, (int8x16_t)vmull_p64(a6[11].u64[0], veorq_s8(v71, vextq_s8(v71, v71, 8uLL)).u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[3];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v90 = a6[4];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v93 = vqtbl1q_s8(a1[3], v9);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v96 = veorq_s8(v74, (int8x16_t)vmull_high_p64(v90, (uint64x2_t)v93));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v99 = veorq_s8(v77, (int8x16_t)vmull_p64(v90.u64[0], v93.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v106 = veorq_s8(v84, (int8x16_t)vmull_p64(a6[12].u64[0], veorq_s8(v93, vextq_s8(v93, v93, 8uLL)).u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[4];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v112 = a6[5];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v115 = vqtbl1q_s8(a1[2], v9);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v118 = veorq_s8(v96, (int8x16_t)vmull_high_p64(v112, (uint64x2_t)v115));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v121 = veorq_s8(v99, (int8x16_t)vmull_p64(v112.u64[0], v115.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v128 = veorq_s8(v106, (int8x16_t)vmull_p64(a6[13].u64[0], veorq_s8(v115, vextq_s8(v115, v115, 8uLL)).u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[5];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v134 = a6[6];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v137 = vqtbl1q_s8(a1[1], v9);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v140 = veorq_s8(v118, (int8x16_t)vmull_high_p64(v134, (uint64x2_t)v137));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v143 = veorq_s8(v121, (int8x16_t)vmull_p64(v134.u64[0], v137.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
    }

    int8x16_t v150 = veorq_s8(v128, (int8x16_t)vmull_p64(a6[14].u64[0], veorq_s8(v137, vextq_s8(v137, v137, 8uLL)).u64[0]));
    __asm
    {
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[6];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    uint64x2_t v156 = a6[7];
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
    }

    int8x16_t v159 = veorq_s8(vqtbl1q_s8(*a1, v9), a3);
    __asm
    {
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
    }

    int8x16_t v162 = veorq_s8(v140, (int8x16_t)vmull_high_p64(v156, (uint64x2_t)v159));
    __asm
    {
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v165 = veorq_s8(v143, (int8x16_t)vmull_p64(v156.u64[0], v159.u64[0]));
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[7];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
    }

    int8x16_t v177 = veorq_s8( v165,  veorq_s8( v162,  veorq_s8(v150, (int8x16_t)vmull_p64(a6[15].u64[0], veorq_s8(v159, vextq_s8(v159, v159, 8uLL)).u64[0]))));
    __asm
    {
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
    }

    int8x16_t v184 = veorq_s8(vextq_s8(v12, v177, 8uLL), v165);
    __asm
    {
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
    }

    int8x16_t v187 = veorq_s8(vextq_s8(v184, v184, 8uLL), (int8x16_t)vmull_p64(v10, v184.u64[0]));
    __asm
    {
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    _Q20 = a7[8];
    __asm
    {
      AESE            V22.16B, V20.16B
      AESMC           V22.16B, V22.16B
      AESE            V23.16B, V20.16B
      AESMC           V23.16B, V23.16B
      AESE            V24.16B, V20.16B
      AESMC           V24.16B, V24.16B
      AESE            V25.16B, V20.16B
      AESMC           V25.16B, V25.16B
      AESE            V26.16B, V20.16B
      AESMC           V26.16B, V26.16B
      AESE            V27.16B, V20.16B
      AESMC           V27.16B, V27.16B
      AESE            V28.16B, V20.16B
      AESMC           V28.16B, V28.16B
      AESE            V29.16B, V20.16B
      AESMC           V29.16B, V29.16B
    }

    a3 = veorq_s8( veorq_s8(vextq_s8(v177, v12, 8uLL), v162),  veorq_s8(vextq_s8(v187, v187, 8uLL), (int8x16_t)vmull_p64(v10, v187.u64[0])));
    _Q20 = a7[9];
    int8x16_t v212 = a7[10];
    if (a8 > 160)
    {
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = a7[10];
      __asm
      {
        AESE            V22.16B, V20.16B
        AESMC           V22.16B, V22.16B
        AESE            V23.16B, V20.16B
        AESMC           V23.16B, V23.16B
        AESE            V24.16B, V20.16B
        AESMC           V24.16B, V24.16B
        AESE            V25.16B, V20.16B
        AESMC           V25.16B, V25.16B
        AESE            V26.16B, V20.16B
        AESMC           V26.16B, V26.16B
        AESE            V27.16B, V20.16B
        AESMC           V27.16B, V27.16B
        AESE            V28.16B, V20.16B
        AESMC           V28.16B, V28.16B
        AESE            V29.16B, V20.16B
        AESMC           V29.16B, V29.16B
      }

      _Q20 = a7[11];
      int8x16_t v212 = a7[12];
      if (a8 > 192)
      {
        __asm
        {
          AESE            V22.16B, V20.16B
          AESMC           V22.16B, V22.16B
          AESE            V23.16B, V20.16B
          AESMC           V23.16B, V23.16B
          AESE            V24.16B, V20.16B
          AESMC           V24.16B, V24.16B
          AESE            V25.16B, V20.16B
          AESMC           V25.16B, V25.16B
          AESE            V26.16B, V20.16B
          AESMC           V26.16B, V26.16B
          AESE            V27.16B, V20.16B
          AESMC           V27.16B, V27.16B
          AESE            V28.16B, V20.16B
          AESMC           V28.16B, V28.16B
          AESE            V29.16B, V20.16B
          AESMC           V29.16B, V29.16B
        }

        _Q20 = a7[12];
        __asm
        {
          AESE            V22.16B, V20.16B
          AESMC           V22.16B, V22.16B
          AESE            V23.16B, V20.16B
          AESMC           V23.16B, V23.16B
          AESE            V24.16B, V20.16B
          AESMC           V24.16B, V24.16B
          AESE            V25.16B, V20.16B
          AESMC           V25.16B, V25.16B
          AESE            V26.16B, V20.16B
          AESMC           V26.16B, V26.16B
          AESE            V27.16B, V20.16B
          AESMC           V27.16B, V27.16B
          AESE            V28.16B, V20.16B
          AESMC           V28.16B, V28.16B
          AESE            V29.16B, V20.16B
          AESMC           V29.16B, V29.16B
        }

        _Q20 = a7[13];
        int8x16_t v212 = a7[14];
      }
    }

    int8x16_t v280 = *a1;
    int8x16_t v281 = a1[1];
    int8x16_t v282 = a1[2];
    int8x16_t v283 = a1[3];
    v279 = a1 + 4;
    __asm
    {
      AESE            V22.16B, V20.16B
      AESE            V23.16B, V20.16B
      AESE            V24.16B, V20.16B
      AESE            V25.16B, V20.16B
    }

    int8x16_t v288 = veorq_s8(v280, veorq_s8(_Q22, v212));
    int8x16_t v289 = veorq_s8(v281, veorq_s8(_Q23, v212));
    int8x16_t v290 = veorq_s8(v282, veorq_s8(_Q24, v212));
    int8x16_t v291 = veorq_s8(v283, veorq_s8(_Q25, v212));
    int8x16_t v292 = *v279;
    int8x16_t v293 = v279[1];
    int8x16_t v294 = v279[2];
    int8x16_t v295 = v279[3];
    a1 = v279 + 4;
    __asm
    {
      AESE            V26.16B, V20.16B
      AESE            V27.16B, V20.16B
      AESE            V28.16B, V20.16B
      AESE            V29.16B, V20.16B
    }

    *a2 = v288;
    a2[1] = v289;
    a2[2] = v290;
    a2[3] = v291;
    v300 = a2 + 4;
    int8x16_t *v300 = veorq_s8(v292, veorq_s8(_Q26, v212));
    v300[1] = veorq_s8(v293, veorq_s8(_Q27, v212));
    v300[2] = veorq_s8(v294, veorq_s8(_Q28, v212));
    v300[3] = veorq_s8(v295, veorq_s8(_Q29, v212));
    a2 = v300 + 4;
    _VF = __OFSUB__(a5, 128LL);
    _NF = a5 - 128 < 0;
    a5 -= 128LL;
  }

  while (_NF == _VF);
  return Decrypt_Main_Loop_End_0();
}

int8x16_t Decrypt_Main_Loop_End_0( int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, uint64_t a4, uint64_t a5, int8x16_t *a6, int a7, int8x16_t a8)
{
  BOOL v13 = a4 < -112;
  uint64_t v14 = a4 + 112;
  if (!v13)
  {
    uint64x2_t v15 = *(uint64x2_t *)(a5 + v14);
    int8x16_t v16 = veorq_s8(a8, vqtbl1q_s8(*a1, v9));
    int8x16_t v17 = (int8x16_t)vmull_high_p64(v15, (uint64x2_t)v16);
    int8x16_t v18 = (int8x16_t)vmull_p64(v15.u64[0], v16.u64[0]);
    int8x16_t v19 = (int8x16_t)vmull_p64(*(void *)(a5 + v14 + 128), veorq_s8(vextq_s8(v16, v16, 8uLL), v16).u64[0]);
    _Q4 = *a6;
    _Q5 = a6[1];
    _Q6 = a6[2];
    int32x4_t v11 = vaddq_s32(v8, v11);
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q4 = a6[3];
    _Q5 = a6[4];
    _Q6 = a6[5];
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q4 = a6[6];
    _Q5 = a6[7];
    _Q6 = a6[8];
    __asm
    {
      AESE            V7.16B, V4.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V5.16B
      AESMC           V7.16B, V7.16B
      AESE            V7.16B, V6.16B
      AESMC           V7.16B, V7.16B
    }

    _Q20 = a6[9];
    _Q21 = a6[10];
    if (a7 > 160)
    {
      __asm
      {
        AESE            V7.16B, V20.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V21.16B
        AESMC           V7.16B, V7.16B
      }

      _Q20 = a6[11];
      _Q21 = a6[12];
      if (a7 > 192)
      {
        __asm
        {
          AESE            V7.16B, V20.16B
          AESMC           V7.16B, V7.16B
          AESE            V7.16B, V21.16B
          AESMC           V7.16B, V7.16B
        }

        _Q20 = a6[13];
        _Q21 = a6[14];
      }
    }

    __asm { AESE            V7.16B, V20.16B }

    int8x16_t v63 = *a1;
    int8x16_t v62 = a1 + 1;
    *a2 = veorq_s8(v63, veorq_s8(_Q7, _Q21));
    int8x16_t v64 = a2 + 1;
    BOOL v13 = v14 < 16;
    for (uint64_t i = v14 - 16; !v13; i -= 16LL)
    {
      int8x16_t v66 = vqtbl1q_s8(*v62, v9);
      uint64x2_t v67 = *(uint64x2_t *)(a5 + i);
      int8x16_t v17 = veorq_s8(v17, (int8x16_t)vmull_high_p64(v67, (uint64x2_t)v66));
      int8x16_t v18 = veorq_s8(v18, (int8x16_t)vmull_p64(v67.u64[0], v66.u64[0]));
      int8x16_t v19 = veorq_s8( v19,  (int8x16_t)vmull_p64(*(void *)(a5 + i + 128), veorq_s8(vextq_s8(v66, v66, 8uLL), v66).u64[0]));
      _Q4 = *a6;
      _Q5 = a6[1];
      _Q6 = a6[2];
      int32x4_t v11 = vaddq_s32(v8, v11);
      __asm
      {
        AESE            V7.16B, V4.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V5.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V6.16B
        AESMC           V7.16B, V7.16B
      }

      _Q4 = a6[3];
      _Q5 = a6[4];
      _Q6 = a6[5];
      __asm
      {
        AESE            V7.16B, V4.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V5.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V6.16B
        AESMC           V7.16B, V7.16B
      }

      _Q4 = a6[6];
      _Q5 = a6[7];
      _Q6 = a6[8];
      __asm
      {
        AESE            V7.16B, V4.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V5.16B
        AESMC           V7.16B, V7.16B
        AESE            V7.16B, V6.16B
        AESMC           V7.16B, V7.16B
      }

      _Q20 = a6[9];
      _Q21 = a6[10];
      if (a7 > 160)
      {
        __asm
        {
          AESE            V7.16B, V20.16B
          AESMC           V7.16B, V7.16B
          AESE            V7.16B, V21.16B
          AESMC           V7.16B, V7.16B
        }

        _Q20 = a6[11];
        _Q21 = a6[12];
        if (a7 > 192)
        {
          __asm
          {
            AESE            V7.16B, V20.16B
            AESMC           V7.16B, V7.16B
            AESE            V7.16B, V21.16B
            AESMC           V7.16B, V7.16B
          }

          _Q20 = a6[13];
          _Q21 = a6[14];
        }
      }

      __asm { AESE            V7.16B, V20.16B }

      int8x16_t v106 = *v62++;
      *v64++ = veorq_s8(v106, veorq_s8(_Q7, _Q21));
      BOOL v13 = i < 16;
    }

    int8x16_t v107 = veorq_s8(v18, veorq_s8(v17, v19));
    int8x16_t v108 = veorq_s8(vextq_s8(v12, v107, 8uLL), v18);
    int8x16_t v109 = veorq_s8(vextq_s8(v108, v108, 8uLL), (int8x16_t)vmull_p64(v10, v108.u64[0]));
    a8 = veorq_s8( veorq_s8(vextq_s8(v107, v12, 8uLL), v17),  veorq_s8(vextq_s8(v109, v109, 8uLL), (int8x16_t)vmull_p64(v10, v109.u64[0])));
  }

  int8x16_t result = vqtbl1q_s8(a8, v9);
  a3[1] = result;
  a3[2] = vqtbl1q_s8((int8x16_t)v11, v9);
  return result;
}

uint64_t ccec_affine_point_from_x_ws(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *a2;
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v7);
  if ((ccn_cmp_public_value(*a2, a4, a2 + 3) & 0x80000000) != 0)
  {
    cczp_to_ws(a1, (uint64_t)a2);
    cczp_sqr_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_add_ws(a1, (uint64_t)a2);
    cczp_add_ws(a1, (uint64_t)a2);
    cczp_sub_ws(a1, (uint64_t)a2);
    cczp_add_ws(a1, (uint64_t)a2);
    uint64_t result = cczp_sqrt_ws(a1, (uint64_t)a2);
    if (!(_DWORD)result)
    {
      cczp_from_ws(a1, (uint64_t)a2);
      cczp_from_ws(a1, (uint64_t)a2);
      uint64_t result = 0LL;
    }
  }

  else
  {
    uint64_t result = 4294967289LL;
  }

  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccec_mult_default_ws( uint64_t a1, uint64_t *a2, uint64_t *a3, _BYTE *a4, unint64_t a5, uint64_t *a6)
{
  int8x16_t v12 = a2 + 4;
  uint64_t v51 = a3;
  __srCC_SHA1_CTX c = a4;
  int8x16_t v54 = v12;
  uint64_t v14 = *a2;
  unint64_t v15 = (a5 + 63) >> 6;
  uint64_t v53 = *(void *)(a1 + 16);
  uint64_t v16 = 3 * *a2;
  int8x16_t v17 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v16);
  int8x16_t v18 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v14);
  BOOL v55 = ccn_n(v14, a6) == 0;
  if (a5 + 63 >= 0x40) {
    ccn_set((a5 + 63) >> 6, v18, a4);
  }
  ccn_zero(v14 - v15, (char *)v18 + 8 * v15);
  v18->i64[v15 - 1] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)a5;
  unint64_t v50 = (a5 + 63) >> 6;
  uint64_t v57 = v18;
  ccn_shift_right(v50, v18, v18, v55);
  ccec_double_ws(a1, a2);
  ccn_mux(3 * v14, !v55, v17, a6, v17);
  if (!ccn_n(v14, v17))
  {
LABEL_13:
    uint64_t result = 0xFFFFFFFFLL;
    goto LABEL_16;
  }

  if (cczp_bitlen((uint64_t)&v54[5 * *a2]) >= a5)
  {
    uint64_t v19 = *a2;
    if (ccn_n(*a2, v17))
    {
      uint64_t v47 = v16;
      uint64_t v45 = *(void *)(a1 + 16);
      uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v19);
      uint64_t v49 = v19;
      uint64_t v21 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v19);
      uint64_t v56 = 2 * v19;
      uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v19);
      uint64_t v23 = *a2;
      uint64_t v42 = *(void *)(a1 + 16);
      __uuid_t dst = (void *)v22;
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, *a2);
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v23);
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v23);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      cczp_add_ws(a1, (uint64_t)a2);
      uint64x2_t v46 = v17;
      cczp_mul_ws(a1, (uint64_t)a2);
      cczp_sqr_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      cczp_sub_ws(a1, (uint64_t)a2);
      uint64_t v24 = a1;
      uint64_t v25 = a1;
      int8x16_t v26 = (uint64_t *)v20;
      cczp_sub_ws(v24, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_sqr_ws(v25, (uint64_t)a2);
      cczp_add_ws(v25, (uint64_t)a2);
      cczp_sub_ws(v25, (uint64_t)a2);
      uint64_t v48 = v25;
      *(void *)(v25 + 16) = v42;
      int8x16_t v27 = v18;
      unint64_t v28 = *(unint64_t *)((char *)v18->i64 + (((a5 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (a5
                                                                                                 - 1);
      char v29 = v28 & 1;
      unsigned __int8 v30 = !(v28 & 1);
      unint64_t v31 = a5 - 2;
      if (a5 == 2)
      {
        char v43 = !(v28 & 1);
        LOBYTE(v32) = v28 & 1;
      }

      else
      {
        LOBYTE(v32) = v28 & 1;
        do
        {
          char v33 = v32;
          uint64_t v32 = (*(unint64_t *)((char *)v27->i64 + ((v31 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v31) & 1;
          cczp_cond_negate((uint64_t)a2, v30, &v21[v49], (unint64_t *)&v21[v49]);
          ccn_cond_swap(v56, v32 ^ v33 | v29 ^ 1, v26, v21);
          ccec_mult_XYCZaddC_ws(v25, a2);
          ccec_mult_XYCZadd_ws(v25, a2);
          unsigned __int8 v30 = v32 & (v29 ^ 1);
          int8x16_t v27 = v18;
          v29 |= v32;
          --v31;
        }

        while (v31);
        char v43 = v29 ^ 1;
      }

      cczp_cond_negate((uint64_t)a2, v30, &v21[v49], (unint64_t *)&v21[v49]);
      ccn_cond_swap(v56, v27->i8[0] & 1 ^ v32, v26, v21);
      ccec_mult_XYCZaddC_ws(v25, a2);
      ccn_set(v56, __dst, v21);
      uint64_t v41 = v27->i64[0] & 1;
      ccn_cond_swap(v56, v27->i8[0] & 1, v26, v21);
      uint64x2_t v34 = v26;
      a1 = v25;
      int8x16_t v35 = v51;
      uint64_t v40 = *(void *)(v25 + 16);
      cczp_sub_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_sqr_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      *(void *)(v25 + 16) = v40;
      ccn_cond_swap(v56, v41, v34, v21);
      ccec_mult_XYCZadd_ws(v25, a2);
      ccn_mux(v56, v41, v34, v21, v34);
      cczp_mul_ws(v25, (uint64_t)a2);
      cczp_mul_ws(v25, (uint64_t)a2);
      int8x16_t v36 = (unint64_t *)cczp_prime((uint64_t)&v54[5 * *a2]);
      ccn_sub1(v49, __dst, v36, 1uLL);
      unsigned __int8 v37 = (ccn_cmpn_internal(v50, v57, v49, __dst) & 1) == 0;
      BOOL is_point_at_infinity = ccec_is_point_at_infinity(a2, (uint64_t)v46);
      ccn_mux(3 * v49, v43 | is_point_at_infinity | v37, v35, v46, v35);
      cczp_cond_negate((uint64_t)a2, v37, &v35[*a2], (unint64_t *)&v35[*a2]);
      char v39 = v43 & ~v57->i32[0] & 1;
      ccn_cond_clear(v49, v39, &v51[2 * *a2]);
      ccn_seti(v49, v34, 1LL);
      cczp_to_ws(v48, (uint64_t)a2);
      ccn_mux(v49, v39, v35, v34, v35);
      ccn_mux(v49, v39, &v35[*a2], v34, &v35[*a2]);
      *(void *)(v48 + 16) = v45;
      ccec_full_add_ws(v48, (uint64_t)a2);
      ccn_mux(v47, *__src & v55, v35, v46, v35);
      uint64_t result = 0LL;
      goto LABEL_16;
    }

    goto LABEL_13;
  }

  uint64_t result = 4294967289LL;
LABEL_16:
  *(void *)(a1 + 16) = v53;
  return result;
}

uint64_t ccec_mult_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 96LL))();
}

uint64_t ccec_mult_XYCZaddC_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_sub_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

uint64_t ccec_mult_XYCZadd_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_sub_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

unint64_t ccn_addmul1_asm( uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  unint64_t v4 = 0LL;
  if ((a1 & 1) != 0)
  {
    unint64_t v5 = *a3++;
    unint64_t v4 = (v5 * (unsigned __int128)a4 + *a2) >> 64;
    *a2++ += v5 * a4;
    --a1;
  }

  if ((a1 & 2) != 0)
  {
    unint64_t v6 = *a3;
    unint64_t v7 = a3[1];
    a3 += 2;
    unsigned __int128 v8 = *(_OWORD *)a2 + __PAIR128__(v7 * a4, v4);
    unsigned __int128 v9 = v8 + v6 * (unsigned __int128)a4;
    unint64_t v4 = (__CFADD__(__CFADD__((void)v8, v6 * a4), *((void *)&v8 + 1)) | __CFADD__( (v6 * (unsigned __int128)a4) >> 64,  *((void *)&v9 + 1)))
    *(_OWORD *)a2 = v9;
    a2 += 2;
    a1 -= 2LL;
  }

  while (1)
  {
    BOOL v10 = a1 < 4;
    a1 -= 4LL;
    if (v10) {
      break;
    }
    unint64_t v11 = a2[2];
    unint64_t v12 = a2[3];
    unint64_t v14 = *a3;
    unint64_t v15 = a3[1];
    BOOL v13 = a3 + 2;
    unint64_t v16 = *v13;
    unint64_t v17 = v13[1];
    a3 = v13 + 2;
    uint64_t v18 = (v15 * (unsigned __int128)a4) >> 64;
    unsigned __int128 v19 = *(_OWORD *)a2 + __PAIR128__(v15 * a4, v4);
    BOOL v20 = __CFADD__( __CFADD__(__CFADD__(*a2, v4), a2[1]) | __CFADD__(v15 * a4, *((void *)&v19 + 1)),  v11);
    unint64_t v21 = (__CFADD__(__CFADD__(*a2, v4), a2[1]) | __CFADD__(v15 * a4, *((void *)&v19 + 1))) + v11;
    v20 |= __CFADD__(v18, v21);
    v21 += v18;
    BOOL v23 = v20;
    BOOL v20 = __CFADD__(v20, v12);
    unint64_t v22 = v23 + v12;
    v20 |= __CFADD__(v17 * a4, v22);
    v22 += v17 * a4;
    uint64_t v24 = v20 + ((v17 * (unsigned __int128)a4) >> 64);
    unsigned __int128 v25 = v19 + v14 * (unsigned __int128)a4;
    *(_OWORD *)a2 = v25;
    int8x16_t v26 = a2 + 2;
    uint64_t v27 = (v16 * (unsigned __int128)a4) >> 64;
    uint64_t v29 = __CFADD__(__CFADD__((void)v19, v14 * a4), *((void *)&v19 + 1)) | __CFADD__( (v14 * (unsigned __int128)a4) >> 64,  *((void *)&v25 + 1));
    BOOL v20 = __CFADD__(v29, v21);
    uint64_t v28 = v29 + v21;
    uint64_t v31 = v20 | __CFADD__(v16 * a4, v28);
    BOOL v20 = __CFADD__(v31, v22);
    uint64_t v30 = v31 + v22;
    unint64_t v4 = (v20 | __CFADD__(v27, v30)) + v24;
    *int8x16_t v26 = v16 * a4 + v28;
    v26[1] = v27 + v30;
    a2 = v26 + 2;
  }

  return v4;
}

uint64_t ccec_pairwise_consistency_check_ws( uint64_t a1, unint64_t **a2, uint64_t (**a3)(void, unint64_t, void *))
{
  unint64_t v6 = **a2;
  char v13 = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  unsigned __int128 v8 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  unsigned __int128 v9 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v6);
  BOOL v10 = (unint64_t *)ccsha256_di();
  uint64_t result = ccec_sign_composite_msg_ws(a1, a2, v10, 0LL, &v13, v8, v9, a3);
  if (!(_DWORD)result)
  {
    v14[0] = 0LL;
    v14[1] = 0LL;
    unint64_t v12 = (unint64_t *)ccsha256_di();
    uint64_t result = ccec_verify_composite_msg_ws(a1, (uint64_t *)a2, v12, 0LL, &v13, (uint64_t)v8, (uint64_t)v9, v14);
    if (!(_DWORD)result)
    {
      cc_cmp_safe_internal(16LL, CCEC_FAULT_CANARY, (char *)v14);
      uint64_t result = 0LL;
    }
  }

  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t (**ccec_projectify_jacobian_ws( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, unint64_t, uint64_t)))(void, unint64_t, uint64_t)
{
  unint64_t v5 = a5;
  uint64_t v9 = *(void *)(a1 + 16);
  if (a5)
  {
    uint64_t v10 = cczp_bitlen((uint64_t)a2);
    unint64_t v5 = (uint64_t (**)(void, unint64_t, uint64_t))ccn_random_bits(v10 - 1, a3 + 16 * *a2, v5);
    ccn_set_bit(a3 + 16 * *a2, v10 - 2, 1LL);
    cczp_sqr_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
    cczp_mul_ws(a1, (uint64_t)a2);
  }

  else
  {
    ccn_seti(*a2, (void *)(a3 + 16 * *a2), 1LL);
    cczp_to_ws(a1, (uint64_t)a2);
  }

  cczp_to_ws(a1, (uint64_t)a2);
  cczp_to_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v9;
  return v5;
}

uint64_t ccec_projectify_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 72LL))();
}

uint64_t ccec_twin_mult_ws(uint64_t a1, uint64_t *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7)
{
  uint64_t v12 = *a2;
  uint64_t v24 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  char v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v25 = 3 * v12;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 12 * v12);
  uint64_t v15 = v14 + 48 * v12;
  uint64_t v26 = v14;
  uint64_t v16 = v14 + 72 * v12;
  ccec_full_add_ws(a1, (uint64_t)a2);
  ccec_full_sub_ws(a1, a2, v16, a5, a7);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  unsigned int v23 = cczp_inv_ws(a1, (uint64_t)a2);
  if (!v23)
  {
    ccec_twin_mult_normalize_ws(a1, a2);
    ccec_twin_mult_normalize_ws(a1, a2);
    ccec_twin_mult_normalize_ws(a1, a2);
    ccec_twin_mult_normalize_ws(a1, a2);
    ccn_seti(v12, v13, 1LL);
    cczp_to_ws(a1, (uint64_t)a2);
    ccn_set(v12, (void *)(v26 + 24 * v12 + 16 * *a2), (void *)(v26 + 16 * *a2));
    ccn_set(v12, (void *)(v15 + 16 * *a2), (void *)(v26 + 16 * *a2));
    ccn_set(v12, (void *)(v16 + 16 * *a2), (void *)(v26 + 16 * *a2));
    unint64_t v17 = ccn_bitlen_internal(v12, a4);
    unint64_t v18 = ccn_bitlen_internal(v12, a6);
    v27[1] = 0LL;
    v27[2] = 0LL;
    if (v17 <= v18) {
      unint64_t v17 = v18;
    }
    v27[0] = 0LL;
    ccn_recode_jsf_init((uint64_t)v27, v17, a4, a6);
    ccn_set(v12, a3, (void *)(v26 + 16 * *a2));
    ccn_set(v12, &a3[8 * *a2], (void *)(v26 + 16 * *a2));
    cc_clear(8 * v12, &a3[16 * *a2]);
    for (; v17 != -1LL; --v17)
    {
      ccec_double_ws(a1, a2);
      uint64_t v28 = 0LL;
      ccn_recode_jsf_column((uint64_t)v27, v17, (uint64_t)&v28);
      if (v28)
      {
        unsigned __int128 v19 = (char *)(v26 + 8 * ccn_recode_jsf_index(&v28) * v25);
        else {
          ccec_full_sub_normalized_ws(a1, a2, a3, (uint64_t)a3, v19);
        }
      }
    }
  }

  *(void *)(a1 + 16) = v24;
  return v23;
}

uint64_t ccec_twin_mult_normalize_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  uint64_t result = cczp_mul_ws(a1, (uint64_t)a2);
  *(void *)(a1 + 16) = v5;
  return result;
}

unint64_t cc_cmp_safe_internal(uint64_t a1, char *a2, char *a3)
{
  if (!a1) {
    return 1LL;
  }
  unsigned __int8 v3 = 0;
  do
  {
    char v5 = *a2++;
    char v4 = v5;
    char v6 = *a3++;
    v3 |= v6 ^ v4;
    --a1;
  }

  while (a1);
  return ((unint64_t)v3 + 0xFFFFFFFF) >> 32;
}

unint64_t cc_cmp_safe(uint64_t a1, char *a2, char *a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  if (a1)
  {
    unsigned __int8 v6 = 0;
    do
    {
      char v8 = *a2++;
      char v7 = v8;
      char v9 = *a3++;
      v6 |= v9 ^ v7;
      --a1;
    }

    while (a1);
    unint64_t v10 = ((unint64_t)v6 + 0xFFFFFFFF) >> 32;
  }

  else
  {
    unint64_t v10 = 1LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccec_generate_key_fips_ws( uint64_t a1, uint64_t *a2, uint64_t (**a3)(void, uint64_t, uint64_t *), uint64_t **a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t result = ccec_generate_key_internal_fips_ws(a1, a2, a3, a4);
  if (!(_DWORD)result)
  {
    if (ccec_pairwise_consistency_check_ws( a1,  (unint64_t **)a4,  (uint64_t (**)(void, unint64_t, void *))a3)) {
      uint64_t result = 4294967278LL;
    }
    else {
      uint64_t result = 0LL;
    }
  }

  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccec_generate_key_fips( uint64_t *a1, uint64_t (**a2)(void, uint64_t, uint64_t *), uint64_t **a3)
{
  BOOL v12 = timingsafe_enable_if_supported();
  unsigned __int8 v6 = cc_malloc_clear(392 * *a1);
  uint64_t v7 = 49 * *a1;
  v10[0] = v6;
  v10[1] = v7;
  void v10[2] = 0LL;
  v10[3] = cc_ws_alloc;
  unint64_t v11 = cc_ws_free;
  if (v6)
  {
    uint64_t key_fips_ws = ccec_generate_key_fips_ws((uint64_t)v10, a1, a2, a3);
    cc_try_abort_if ((_DWORD)key_fips_ws == -18);
    v11((uint64_t)v10);
  }

  else
  {
    uint64_t key_fips_ws = 4294967283LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v12);
  return key_fips_ws;
}

uint64_t ccec_x963_export(int a1, char *a2, uint64_t *a3)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v6 = ccec_export_pub(a3, a2);
  uint64_t v7 = v6;
  if (a1 && !(_DWORD)v6)
  {
    uint64_t v8 = *a3;
    unint64_t v9 = *(void *)*a3;
    unint64_t v10 = (unint64_t)(cczp_bitlen(*a3 + 40 * v9 + 32) + 7) >> 3;
    uint64_t v11 = cczp_bitlen(v8);
    int v12 = ccn_write_uint_padded_ct_internal( v9,  (unint64_t *)&a3[3 * v9 + 2],  v10,  &a2[((unint64_t)(v11 + 7) >> 2) | 1]);
    uint64_t v7 = v12 & (v12 >> 31);
  }

  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v7;
}

uint64_t ccec_x963_import_priv_ws( uint64_t a1, unint64_t *a2, unint64_t a3, unsigned __int8 *a4, unint64_t **a5)
{
  unsigned int v5 = *a4;
  BOOL v6 = v5 > 7;
  int v7 = (1 << v5) & 0xD0;
  if (v6 || v7 == 0) {
    return 4294967289LL;
  }
  BOOL v14 = a2 + 4;
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = cczp_bitlen((uint64_t)&v14[5 * *a2]);
  uint64_t result = ccec_x963_import_pub_ws(a1, a2, a3 - ((unint64_t)(v16 + 7) >> 3), a4, a5);
  if (!(_DWORD)result)
  {
    unint64_t v18 = *a2;
    uint64_t v19 = (uint64_t)&a5[3 * **a5 + 2];
    unint64_t v20 = (unint64_t)(cczp_bitlen((uint64_t)&v14[5 * *a2]) + 7) >> 3;
    uint64_t v21 = cczp_bitlen((uint64_t)a2);
    uint64_t result = ccn_read_uint_internal(v18, v19, v20, &a4[((unint64_t)(v21 + 7) >> 2) | 1]);
  }

  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t ccec_x963_import_priv( unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t **a4)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v8 = cc_malloc_clear(160 * *a1);
  uint64_t v9 = 20 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  v12[2] = 0LL;
  unint64_t v12[3] = cc_ws_alloc;
  char v13 = cc_ws_free;
  if (v8)
  {
    uint64_t v10 = ccec_x963_import_priv_ws((uint64_t)v12, a1, a2, a3, a4);
    v13((uint64_t)v12);
  }

  else
  {
    uint64_t v10 = 4294967283LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v10;
}

uint64_t ccec_x963_import_pub_ws( uint64_t a1, unint64_t *a2, uint64_t a3, unsigned __int8 *a4, unint64_t **a5)
{
  if (!a3) {
    return 4294967289LL;
  }
  if (a3 == 1)
  {
    int v10 = *a4;
    if (!*a4) {
      return 4294967136LL;
    }
  }

  else
  {
    int v10 = *a4;
  }

  unsigned int v12 = v10 - 2;
  if (v12 > 5 || ((0x37u >> v12) & 1) == 0) {
    return 4294967289LL;
  }
  int v13 = dword_27FC60[(char)v12];
  uint64_t v14 = *(void *)(a1 + 16);
  *a5 = a2;
  uint64_t result = ccec_import_affine_point_ws(a1, a2, v13, a3, a4, a5 + 2);
  if (!(_DWORD)result)
  {
    ccn_seti(*a2, &a5[2 * **a5 + 2], 1LL);
    uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * *a2);
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, (uint64_t *)a2, v15, (uint64_t)(a5 + 2));
  }

  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_x963_import_pub(unint64_t *a1, uint64_t a2, unsigned __int8 *a3, unint64_t **a4)
{
  uint64_t v8 = cc_malloc_clear(160 * *a1);
  uint64_t v9 = 20 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  v12[2] = 0LL;
  unint64_t v12[3] = cc_ws_alloc;
  int v13 = cc_ws_free;
  if (!v8) {
    return 4294967283LL;
  }
  uint64_t v10 = ccec_x963_import_pub_ws((uint64_t)v12, a1, a2, a3, a4);
  v13((uint64_t)v12);
  return v10;
}

uint64_t ccrng_crypto_generate(uint64_t a1, rsize_t a2, char *a3)
{
  if (!a2) {
    return 0LL;
  }
  rsize_t v6 = a2;
  int v7 = a3;
  while (1)
  {
    uint64_t v8 = *(os_unfair_lock_s **)(a1 + 24);
    if (v8)
    {
      os_unfair_lock_lock(v8);
      uint64_t v9 = *(os_unfair_lock_s **)(a1 + 24);
      if (v9) {
        os_unfair_lock_assert_owner(v9);
      }
    }

    memset(v29, 0, sizeof(v29));
    rsize_t v10 = *(void *)(a1 + 56);
    int v11 = ccrng_schedule_read(*(void *)(a1 + 16));
    if (v11 == 1) {
      goto LABEL_13;
    }
    int v12 = v11;
    uint64_t seed = ccentropy_get_seed(*(uint64_t (****)(void, uint64_t, uint64_t))(a1 + 8), v10, (uint64_t)v29);
    if ((_DWORD)seed == -10) {
      break;
    }
    uint64_t v14 = seed;
    if ((_DWORD)seed) {
      goto LABEL_40;
    }
    uint64_t v15 = drbg_reseed((void *)a1, v10, (uint64_t)v29, 0LL, 0LL);
    if ((_DWORD)v15)
    {
      uint64_t v14 = v15;
LABEL_40:
      cc_clear(v10, v29);
      goto LABEL_36;
    }

    ccrng_schedule_notify_reseed(*(_BYTE **)(a1 + 16));
    cc_clear(v10, v29);
LABEL_13:
    if (v6 >= *(void *)(a1 + 48)) {
      unint64_t v16 = *(void *)(a1 + 48);
    }
    else {
      unint64_t v16 = v6;
    }
    unint64_t v17 = *(os_unfair_lock_s **)(a1 + 24);
    if (v17) {
      os_unfair_lock_assert_owner(v17);
    }
    if (a2 <= 0xB && (unint64_t v18 = *(void *)(a1 + 64), v18 >= v16))
    {
      uint64_t v21 = *(void *)(a1 + 72);
      uint64_t v22 = *(void *)(a1 + 80);
      unsigned int v23 = (void *)(v21 + v22);
      uint64_t v24 = v21 + v18;
      unint64_t v25 = v24 - (v21 + v22);
      if (v25 >= v16) {
        size_t v26 = v16;
      }
      else {
        size_t v26 = v24 - (v21 + v22);
      }
      memcpy(v7, (const void *)(v21 + v22), v26);
      cc_clear(v26, v23);
      *(void *)(a1 + 80) += v26;
      if (v25 < v16)
      {
        uint64_t v19 = drbg_generate((void *)a1, *(void *)(a1 + 64), *(void *)(a1 + 72));
        if ((_DWORD)v19)
        {
LABEL_41:
          uint64_t v14 = v19;
          goto LABEL_36;
        }

        memcpy(&v7[v26], *(const void **)(a1 + 72), v16 - v26);
        cc_clear(v16 - v26, *(void **)(a1 + 72));
        *(void *)(a1 + 80) = v16 - v26;
      }
    }

    else
    {
      uint64_t v19 = drbg_generate((void *)a1, v16, (uint64_t)v7);
      if ((_DWORD)v19) {
        goto LABEL_41;
      }
    }

    unint64_t v20 = *(os_unfair_lock_s **)(a1 + 24);
    if (v20) {
      os_unfair_lock_unlock(v20);
    }
    v7 += v16;
    v6 -= v16;
    if (!v6) {
      return 0LL;
    }
  }

  if (v12 == 2) {
    goto LABEL_13;
  }
  if (v12 == 3) {
    uint64_t v14 = 4294967134LL;
  }
  else {
    uint64_t v14 = 0xFFFFFFFFLL;
  }
LABEL_36:
  uint64_t v28 = *(os_unfair_lock_s **)(a1 + 24);
  if (v28) {
    os_unfair_lock_unlock(v28);
  }
  cc_clear(a2, a3);
  return v14;
}

uint64_t drbg_reseed(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  rsize_t v10 = (os_unfair_lock_s *)a1[3];
  if (v10) {
    os_unfair_lock_assert_owner(v10);
  }
  uint64_t result = ccdrbg_reseed(a1[4], a1[5], a2, a3, a4, a5);
  if (!(_DWORD)result) {
    a1[10] = a1[8];
  }
  return result;
}

uint64_t ccrng_crypto_init( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a8 > 0x40) {
    return 4294967291LL;
  }
  uint64_t result = 0LL;
  *a1 = generate_1;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = a5;
  a1[5] = a6;
  a1[6] = a7;
  a1[7] = a8;
  a1[8] = a9;
  a1[9] = a10;
  a1[10] = a9;
  return result;
}

uint64_t drbg_generate(void *a1, uint64_t a2, uint64_t a3)
{
  rsize_t v6 = (os_unfair_lock_s *)a1[3];
  if (v6) {
    os_unfair_lock_assert_owner(v6);
  }
  return ccdrbg_generate(a1[4], a1[5], a2, a3, 0LL, 0LL);
}

uint64_t cczp_inv_default_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = a2;
  unint64_t v8 = cczp_n(a2);
  uint64_t v9 = cczp_prime(v6);
  if ((ccn_cmp_public_value(v8, a4, v9) & 0x80000000) == 0) {
    return 4294967289LL;
  }
  uint64_t v46 = *(void *)(a1 + 16);
  __int128 __s = a3;
  int v11 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  int v12 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  cczp_from_ws(a1, v6);
  int v13 = (void *)cczp_prime(v6);
  ccn_set(v8, v12, v13);
  uint64_t v14 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  uint64_t v15 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  uint64_t v53 = v14;
  ccn_seti(v8, v14, 1LL);
  uint64_t __n = 8 * v8;
  int8x16_t v54 = v15;
  cc_clear(8 * v8, v15);
  int8x16_t v52 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v8);
  unint64_t v16 = (v8 << 7) | 0x1E;
  if (v16 != 30)
  {
    uint64_t v17 = 0LL;
    unint64_t v49 = v8 - 1;
    unint64_t v50 = v16 / 0x1F;
    unint64_t v48 = v8 - 2;
    uint64_t v51 = (void *)v6;
    uint64_t v56 = v8;
    do
    {
      uint64_t v18 = v11[v49];
      uint64_t v19 = v12[v49];
      uint64_t v55 = v17;
      if (v8 >= 2)
      {
        unint64_t v20 = v48;
        do
        {
          char v21 = __clz(v19 | v18 | 1);
          uint64_t v18 = (v11[v20] >> v22) | (v18 << v21);
          uint64_t v19 = (v12[v20--] >> v22) | (v19 << v21);
        }

        while (v20 < v8);
      }

      unint64_t v23 = 0LL;
      uint64_t v24 = 0LL;
      unint64_t v25 = v18 & 0xFFFFFFFF80000000LL | *v11 & 0x7FFFFFFFLL;
      unint64_t v26 = v19 & 0xFFFFFFFF80000000LL | *v12 & 0x7FFFFFFFLL;
      uint64_t v27 = 31LL;
      uint64_t v28 = 0x80000000LL;
      unint64_t v29 = 0x80000000LL;
      do
      {
        unint64_t v30 = v25 & 1;
        unint64_t v31 = v25 >> !(v25 & 1);
        unint64_t v32 = v31 ^ v26;
        unint64_t v33 = v25 & ((((v31 - v26) ^ v31 | v31 ^ v26) ^ v31) >> 63);
        uint64_t v34 = -(uint64_t)v33;
        unint64_t v35 = v26 & -(uint64_t)v33--;
        unint64_t v36 = v33 & v31 | v35;
        unint64_t v26 = v32 ^ v36;
        unint64_t v37 = v33 & v29 | v24 & v34;
        v24 ^= v29 ^ v37;
        unint64_t v38 = v33 & v23 | v28 & v34;
        v28 ^= v23 ^ v38;
        unint64_t v25 = (v36 - (v26 & -(uint64_t)v30)) >> v30;
        unint64_t v29 = (v37 - (v24 & -(uint64_t)v30)) & 0x8000000000000000LL | ((v37 - (v24 & -(uint64_t)v30)) >> 1);
        unint64_t v23 = (v38 - (v28 & -(uint64_t)v30)) & 0x8000000000000000LL | ((v38 - (v28 & -(uint64_t)v30)) >> 1);
        --v27;
      }

      while (v27);
      uint64_t v39 = a1;
      unint64_t updated = cczp_inv_update_ws( a1,  v8,  v52,  v11,  (v37 - (v24 & -(uint64_t)v30)) & 0x8000000000000000LL | ((v37 - (v24 & -(uint64_t)v30)) >> 1),  v12,  (v38 - (v28 & -(uint64_t)v30)) & 0x8000000000000000LL | ((v38 - (v28 & -(uint64_t)v30)) >> 1));
      unint64_t v41 = cczp_inv_update_ws(v39, v56, v12, v11, v24, v12, v28);
      ccn_set(v56, v11, v52);
      unint64_t v42 = updated - 1;
      uint64_t v43 = -(uint64_t)updated;
      a1 = v39;
      uint64_t v44 = v42 & v23 | v43 & -(uint64_t)v23;
      uint64_t v6 = (uint64_t)v51;
      unint64_t v8 = v56;
      cczp_inv_update_redc_ws(v39, v51, v52, v53, v42 & v29 | v43 & -(uint64_t)v29, v54, v44);
      cczp_inv_update_redc_ws( v39,  v51,  v54,  v53,  (v41 - 1) & v24 | -(uint64_t)v41 & -v24,  v54,  (v41 - 1) & v28 | -(uint64_t)v41 & -v28);
      ccn_set(v56, v53, v52);
      uint64_t v17 = v55 + 1;
    }

    while (v55 + 1 != v50);
  }

  if (ccn_n(v8, v12) == 1 && *v12 == 1LL)
  {
    cczp_to_ws(a1, v6);
    uint64_t result = 0LL;
  }

  else
  {
    cc_clear(__n, __s);
    uint64_t result = 4294967289LL;
  }

  *(void *)(a1 + 16) = v46;
  return result;
}

unint64_t cczp_inv_update_ws( uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v13 = a2 + 1;
  uint64_t v14 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, a2 + 1);
  uint64_t v15 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  if (a2) {
    ccn_set(a2, v14, a4);
  }
  ccn_zero(1LL, (char *)v14 + 8 * a2);
  ccn_cond_neg(v13, a5 < 0, v14->i64, v14->i64);
  if (a2) {
    ccn_set(a2, v15, a6);
  }
  ccn_zero(1LL, &v15[8 * a2]);
  ccn_cond_neg(v13, a7 < 0, (uint64_t *)v15, (uint64_t *)v15);
  ccn_mul1(v13, v14, v14, (a5 ^ (a5 >> 63)) + ((unint64_t)a5 >> 63));
  ccn_addmul1(v13, v14, v15, (a7 ^ (a7 >> 63)) + ((unint64_t)a7 >> 63));
  unint64_t v16 = (unint64_t)v14->i64[a2] >> 63;
  ccn_cond_neg(v13, v14->i64[a2] < 0, v14->i64, v14->i64);
  ccn_shift_right(v13, v14, v14, 31LL);
  ccn_set(a2, a3, v14);
  *(void *)(a1 + 16) = v19;
  return v16;
}

uint64_t cczp_inv_update_redc_ws( uint64_t a1, void *a2, void *a3, unint64_t *a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v12 = cczp_n((uint64_t)a2);
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v13 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12 + 1);
  uint64_t v14 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  cczp_cond_negate((uint64_t)a2, a5 < 0, v13->i64, a4);
  cczp_cond_negate((uint64_t)a2, a7 < 0, v14, a6);
  v13->i64[v12] = ccn_mul1(v12, v13, v13, (a5 ^ (a5 >> 63)) + ((unint64_t)a5 >> 63));
  v13->i64[v12] += ccn_addmul1(v12, v13, v14, (a7 ^ (a7 >> 63)) + ((unint64_t)a7 >> 63));
  uint64_t v15 = cczp_prime((uint64_t)a2);
  v13->i64[v12] += ccn_addmul1(v12, v13, v15, (LODWORD(a2[*a2 + 3]) * v13->i32[0]) & 0x7FFFFFFF);
  ccn_shift_right(v12 + 1, v13, v13, 31LL);
  ccn_set(v12, a3, v13);
  unint64_t v16 = (unint64_t *)cczp_prime((uint64_t)a2);
  char v17 = ccn_subn(v12 + 1, v13, v13->i64, v12, v16);
  uint64_t result = ccn_mux(v12, v17, (uint64_t *)a3, (uint64_t *)a3, v13->i64);
  *(void *)(a1 + 16) = v21;
  return result;
}

uint64_t cczp_inv_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 40LL))();
}

uint64_t cczp_n(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cczp_bitlen(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *ccmd5_di()
{
  return &ccmd5_ltc_di;
}

unint64_t md5_compress(unint64_t result, uint64_t a2, _DWORD *a3)
{
  int8x16_t v85 = (_DWORD *)result;
  if (a2)
  {
    int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v5 = *(_DWORD *)(result + 8);
    int v6 = *(_DWORD *)(result + 12);
    do
    {
      int v7 = a3[1];
      uint64_t result = a3[2];
      int v8 = a3[3];
      int v10 = a3[4];
      int v9 = a3[5];
      int v11 = a3[6];
      int v12 = a3[7];
      int v13 = a3[8];
      int v14 = a3[9];
      int v15 = a3[10];
      int v16 = a3[11];
      int v17 = a3[12];
      int v18 = a3[13];
      int v20 = a3[14];
      int v19 = a3[15];
      HIDWORD(v21) = v3 + (v5 & v4 | v6 & ~v4) - 680876936 + *a3;
      LODWORD(v21) = HIDWORD(v21);
      int v22 = (v21 >> 25) + v4;
      HIDWORD(v21) = v6 + v7 - 389564586 + (v4 & v22 | v5 & ~v22);
      LODWORD(v21) = HIDWORD(v21);
      int v23 = (v21 >> 20) + v22;
      HIDWORD(v21) = v5 + result + 606105819 + (v22 & v23 | v4 & ~v23);
      LODWORD(v21) = HIDWORD(v21);
      int v24 = (v21 >> 15) + v23;
      HIDWORD(v21) = v4 + v8 - 1044525330 + (v23 & v24 | v22 & ~v24);
      LODWORD(v21) = HIDWORD(v21);
      int v25 = (v21 >> 10) + v24;
      HIDWORD(v21) = v10 + v22 - 176418897 + (v24 & v25 | v23 & ~v25);
      LODWORD(v21) = HIDWORD(v21);
      int v26 = (v21 >> 25) + v25;
      HIDWORD(v21) = v9 + v23 + 1200080426 + (v25 & v26 | v24 & ~v26);
      LODWORD(v21) = HIDWORD(v21);
      int v27 = (v21 >> 20) + v26;
      HIDWORD(v21) = v11 + v24 - 1473231341 + (v26 & v27 | v25 & ~v27);
      LODWORD(v21) = HIDWORD(v21);
      int v28 = (v21 >> 15) + v27;
      HIDWORD(v21) = v12 + v25 - 45705983 + (v27 & v28 | v26 & ~v28);
      LODWORD(v21) = HIDWORD(v21);
      int v29 = (v21 >> 10) + v28;
      HIDWORD(v21) = v13 + v26 + 1770035416 + (v28 & v29 | v27 & ~v29);
      LODWORD(v21) = HIDWORD(v21);
      int v30 = (v21 >> 25) + v29;
      HIDWORD(v21) = v14 + v27 - 1958414417 + (v29 & v30 | v28 & ~v30);
      LODWORD(v21) = HIDWORD(v21);
      int v31 = (v21 >> 20) + v30;
      HIDWORD(v21) = v15 + v28 - 42063 + (v30 & v31 | v29 & ~v31);
      LODWORD(v21) = HIDWORD(v21);
      int v32 = (v21 >> 15) + v31;
      HIDWORD(v21) = v16 + v29 - 1990404162 + (v31 & v32 | v30 & ~v32);
      LODWORD(v21) = HIDWORD(v21);
      int v33 = (v21 >> 10) + v32;
      HIDWORD(v21) = v17 + v30 + 1804603682 + (v32 & v33 | v31 & ~v33);
      LODWORD(v21) = HIDWORD(v21);
      int v34 = (v21 >> 25) + v33;
      HIDWORD(v21) = v18 + v31 - 40341101 + (v33 & v34 | v32 & ~v34);
      LODWORD(v21) = HIDWORD(v21);
      int v35 = (v21 >> 20) + v34;
      HIDWORD(v21) = v20 + v32 - 1502002290 + (v34 & v35 | v33 & ~v35);
      LODWORD(v21) = HIDWORD(v21);
      int v36 = (v21 >> 15) + v35;
      HIDWORD(v21) = v19 + v33 + 1236535329 + (v35 & v36 | v34 & ~v36);
      LODWORD(v21) = HIDWORD(v21);
      int v37 = (v21 >> 10) + v36;
      HIDWORD(v21) = v7 + v34 - 165796510 + (v37 & v35 | v36 & ~v35);
      LODWORD(v21) = HIDWORD(v21);
      int v38 = (v21 >> 27) + v37;
      HIDWORD(v21) = v11 + v35 - 1069501632 + (v38 & v36 | v37 & ~v36);
      LODWORD(v21) = HIDWORD(v21);
      int v39 = (v21 >> 23) + v38;
      HIDWORD(v21) = v16 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
      LODWORD(v21) = HIDWORD(v21);
      int v40 = (v21 >> 18) + v39;
      HIDWORD(v21) = *a3 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
      LODWORD(v21) = HIDWORD(v21);
      int v41 = (v21 >> 12) + v40;
      HIDWORD(v21) = v9 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
      LODWORD(v21) = HIDWORD(v21);
      int v42 = (v21 >> 27) + v41;
      HIDWORD(v21) = v15 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
      LODWORD(v21) = HIDWORD(v21);
      int v43 = (v21 >> 23) + v42;
      HIDWORD(v21) = v19 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
      LODWORD(v21) = HIDWORD(v21);
      int v44 = (v21 >> 18) + v43;
      HIDWORD(v21) = v10 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
      LODWORD(v21) = HIDWORD(v21);
      int v45 = (v21 >> 12) + v44;
      HIDWORD(v21) = v14 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
      LODWORD(v21) = HIDWORD(v21);
      int v46 = (v21 >> 27) + v45;
      HIDWORD(v21) = v20 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
      LODWORD(v21) = HIDWORD(v21);
      int v47 = (v21 >> 23) + v46;
      HIDWORD(v21) = v8 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
      LODWORD(v21) = HIDWORD(v21);
      int v48 = (v21 >> 18) + v47;
      HIDWORD(v21) = v13 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
      LODWORD(v21) = HIDWORD(v21);
      int v49 = (v21 >> 12) + v48;
      HIDWORD(v21) = v18 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
      LODWORD(v21) = HIDWORD(v21);
      int v50 = (v21 >> 27) + v49;
      HIDWORD(v21) = result + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
      LODWORD(v21) = HIDWORD(v21);
      int v51 = (v21 >> 23) + v50;
      HIDWORD(v21) = v12 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
      LODWORD(v21) = HIDWORD(v21);
      int v52 = (v21 >> 18) + v51;
      HIDWORD(v21) = v17 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
      LODWORD(v21) = HIDWORD(v21);
      int v53 = (v21 >> 12) + v52;
      HIDWORD(v21) = v9 + v50 - 378558 + (v52 ^ v51 ^ v53);
      LODWORD(v21) = HIDWORD(v21);
      int v54 = (v21 >> 28) + v53;
      HIDWORD(v21) = v13 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
      LODWORD(v21) = HIDWORD(v21);
      int v55 = (v21 >> 21) + v54;
      HIDWORD(v21) = v16 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
      LODWORD(v21) = HIDWORD(v21);
      int v56 = (v21 >> 16) + v55;
      HIDWORD(v21) = v20 + v53 - 35309556 + (v55 ^ v54 ^ v56);
      LODWORD(v21) = HIDWORD(v21);
      int v57 = (v21 >> 9) + v56;
      HIDWORD(v21) = v7 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
      LODWORD(v21) = HIDWORD(v21);
      int v58 = (v21 >> 28) + v57;
      HIDWORD(v21) = v10 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
      LODWORD(v21) = HIDWORD(v21);
      int v59 = (v21 >> 21) + v58;
      HIDWORD(v21) = v12 + v56 - 155497632 + (v58 ^ v57 ^ v59);
      LODWORD(v21) = HIDWORD(v21);
      int v60 = (v21 >> 16) + v59;
      HIDWORD(v21) = v15 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
      LODWORD(v21) = HIDWORD(v21);
      int v61 = (v21 >> 9) + v60;
      HIDWORD(v21) = v18 + v58 + 681279174 + (v60 ^ v59 ^ v61);
      LODWORD(v21) = HIDWORD(v21);
      int v62 = (v21 >> 28) + v61;
      HIDWORD(v21) = *a3 + v59 - 358537222 + (v61 ^ v60 ^ v62);
      LODWORD(v21) = HIDWORD(v21);
      int v63 = (v21 >> 21) + v62;
      HIDWORD(v21) = v8 + v60 - 722521979 + (v62 ^ v61 ^ v63);
      LODWORD(v21) = HIDWORD(v21);
      int v64 = (v21 >> 16) + v63;
      HIDWORD(v21) = v11 + v61 + 76029189 + (v63 ^ v62 ^ v64);
      LODWORD(v21) = HIDWORD(v21);
      int v65 = (v21 >> 9) + v64;
      HIDWORD(v21) = v14 + v62 - 640364487 + (v64 ^ v63 ^ v65);
      LODWORD(v21) = HIDWORD(v21);
      int v66 = (v21 >> 28) + v65;
      HIDWORD(v21) = v17 + v63 - 421815835 + (v65 ^ v64 ^ v66);
      LODWORD(v21) = HIDWORD(v21);
      int v67 = (v21 >> 21) + v66;
      HIDWORD(v21) = v19 + v64 + 530742520 + (v66 ^ v65 ^ v67);
      LODWORD(v21) = HIDWORD(v21);
      int v68 = (v21 >> 16) + v67;
      HIDWORD(v21) = result + v65 - 995338651 + (v67 ^ v66 ^ v68);
      LODWORD(v21) = HIDWORD(v21);
      int v69 = (v21 >> 9) + v68;
      HIDWORD(v21) = *a3 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
      LODWORD(v21) = HIDWORD(v21);
      int v70 = (v21 >> 26) + v69;
      HIDWORD(v21) = v12 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
      LODWORD(v21) = HIDWORD(v21);
      int v71 = (v21 >> 22) + v70;
      HIDWORD(v21) = v20 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
      LODWORD(v21) = HIDWORD(v21);
      int v72 = (v21 >> 17) + v71;
      HIDWORD(v21) = v9 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
      LODWORD(v21) = HIDWORD(v21);
      int v73 = (v21 >> 11) + v72;
      HIDWORD(v21) = v17 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
      LODWORD(v21) = HIDWORD(v21);
      int v74 = (v21 >> 26) + v73;
      HIDWORD(v21) = v8 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
      LODWORD(v21) = HIDWORD(v21);
      int v75 = (v21 >> 22) + v74;
      HIDWORD(v21) = v15 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
      LODWORD(v21) = HIDWORD(v21);
      int v76 = (v21 >> 17) + v75;
      HIDWORD(v21) = v7 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
      LODWORD(v21) = HIDWORD(v21);
      int v77 = (v21 >> 11) + v76;
      HIDWORD(v21) = v13 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
      LODWORD(v21) = HIDWORD(v21);
      int v78 = (v21 >> 26) + v77;
      HIDWORD(v21) = v19 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
      LODWORD(v21) = HIDWORD(v21);
      int v79 = (v21 >> 22) + v78;
      HIDWORD(v21) = v11 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
      LODWORD(v21) = HIDWORD(v21);
      int v80 = (v21 >> 17) + v79;
      HIDWORD(v21) = v18 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
      LODWORD(v21) = HIDWORD(v21);
      int v81 = (v21 >> 11) + v80;
      HIDWORD(v21) = v10 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
      LODWORD(v21) = HIDWORD(v21);
      int v82 = (v21 >> 26) + v81;
      HIDWORD(v21) = v16 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
      LODWORD(v21) = HIDWORD(v21);
      int v83 = (v21 >> 22) + v82;
      HIDWORD(v21) = result + v80 + 718787259 + ((v83 | ~v81) ^ v82);
      LODWORD(v21) = HIDWORD(v21);
      int v84 = (v21 >> 17) + v83;
      v3 += v82;
      HIDWORD(v21) = v14 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
      LODWORD(v21) = HIDWORD(v21);
      v4 += v84 + (v21 >> 11);
      v5 += v84;
      v6 += v83;
      *int8x16_t v85 = v3;
      v85[1] = v4;
      v85[2] = v5;
      v85[3] = v6;
      a3 += 16;
      --a2;
    }

    while (a2);
  }

  return result;
}

uint64_t ccn_mul(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    result *= -8LL;
    int v4 = (unint64_t *)(a2 - result);
    uint64_t v5 = a3 - result;
    uint64_t v6 = a4 - result;
    uint64_t v7 = result;
    uint64_t v8 = result;
    unint64_t v9 = 0LL;
    unint64_t v10 = *(void *)(v6 + result);
    do
    {
      unsigned __int128 v11 = *(unint64_t *)(v5 + v8) * (unsigned __int128)v10 + v9;
      *(unint64_t *)((char *)v4 + v_Block_object_dispose((const void *)(v11 - 96), 8) = v11;
      unint64_t v9 = *((void *)&v11 + 1);
      v8 += 8LL;
    }

    while (v8);
    while (1)
    {
      *int v4 = v9;
      v7 += 8LL;
      if (!v7) {
        break;
      }
      ++v4;
      uint64_t v12 = result;
      unint64_t v9 = 0LL;
      unint64_t v13 = *(void *)(v6 + v7);
      do
      {
        unsigned __int128 v14 = *(unint64_t *)(v5 + v12) * (unsigned __int128)v13 + v9 + *(unint64_t *)((char *)v4 + v12);
        *(unint64_t *)((char *)v4 + v12) = v14;
        unint64_t v9 = *((void *)&v14 + 1);
        v12 += 8LL;
      }

      while (v12);
    }
  }

  return result;
}

uint64_t ccec_generate_key_deterministic_ws( uint64_t a1, uint64_t *a2, unint64_t a3, char *__src, uint64_t (**a5)(void, uint64_t, uint64_t *), int a6, uint64_t **a7)
{
  *a7 = a2;
  if ((~a6 & 0x19) != 0)
  {
    if ((a6 & 1) != 0)
    {
      uint64_t result = ccec_generate_scalar_fips_extrabits_ws(a1, a2, a3, (uint64_t)__src, (char *)&a7[3 * *a2 + 2]);
      if ((_DWORD)result) {
        return result;
      }
    }

    else
    {
      if ((a6 & 4) == 0) {
        return 4294967275LL;
      }
      uint64_t result = ccec_generate_scalar_legacy_ws(a1, a2, a3, __src, &a7[3 * *a2 + 2]);
      if ((_DWORD)result) {
        return result;
      }
    }

uint64_t ccec_generate_key_deterministic( uint64_t *a1, unint64_t a2, char *a3, uint64_t (**a4)(void, uint64_t, uint64_t *), int a5, uint64_t **a6)
{
  BOOL v18 = timingsafe_enable_if_supported();
  uint64_t v12 = cc_malloc_clear(392 * *a1);
  uint64_t v13 = 49 * *a1;
  v16[0] = v12;
  v16[1] = v13;
  v16[2] = 0LL;
  _OWORD v16[3] = cc_ws_alloc;
  int v17 = cc_ws_free;
  if (v12)
  {
    uint64_t key_deterministic_ws = ccec_generate_key_deterministic_ws((uint64_t)v16, a1, a2, a3, a4, a5, a6);
    v17((uint64_t)v16);
  }

  else
  {
    uint64_t key_deterministic_ws = 4294967283LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v18);
  return key_deterministic_ws;
}

uint64_t ccmode_ctr_init(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a1 + 48);
  *a2 = v8;
  uint64_t v9 = (*(uint64_t (**)(void))(v8 + 16))();
  (*(void (**)(uint64_t, void *, uint64_t))(a1 + 32))(a1, a2, a5);
  return v9;
}

uint64_t ccmode_gcm_finalize( uint64_t a1, size_t a2, char *a3, double a4, double a5, double a6, double a7, double a8, int8x16_t a9)
{
  if (*(_WORD *)(a1 + 80) != 3) {
    return 4294967228LL;
  }
  unint64_t v18 = *(void *)(a1 + 96);
  if ((v18 & 0xF) != 0)
  {
    ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), v12, v13, v14, v15, v16, v17);
    unint64_t v18 = *(void *)(a1 + 96);
  }

  unint64_t v19 = *(void *)(a1 + 88);
  *(_BYTE *)(a1 + 64) = v19 >> 53;
  *(_BYTE *)(a1 + 65) = v19 >> 45;
  *(_BYTE *)(a1 + 66) = v19 >> 37;
  *(_BYTE *)(a1 + 67) = v19 >> 29;
  *(_BYTE *)(a1 + 6_Block_object_dispose((const void *)(v11 - 96), 8) = v19 >> 21;
  *(_BYTE *)(a1 + 69) = v19 >> 13;
  *(_BYTE *)(a1 + 70) = v19 >> 5;
  *(_BYTE *)(a1 + 71) = 8 * v19;
  *(_BYTE *)(a1 + 72) = v18 >> 53;
  *(_BYTE *)(a1 + 73) = v18 >> 45;
  *(_BYTE *)(a1 + 74) = v18 >> 37;
  *(_BYTE *)(a1 + 75) = v18 >> 29;
  *(_BYTE *)(a1 + 76) = v18 >> 21;
  *(_BYTE *)(a1 + 77) = v18 >> 13;
  *(_BYTE *)(a1 + 7_Block_object_dispose((const void *)(v11 - 96), 8) = v18 >> 5;
  *(_BYTE *)(a1 + 79) = 8 * v18;
  int8x16_t v20 = *(int8x16_t *)(a1 + 64);
  int8x16_t v21 = veorq_s8(v20, *(int8x16_t *)(a1 + 16));
  *(int8x16_t *)(a1 + 16) = v21;
  int8x16_t v26 = 0uLL;
  double v22 = ccmode_gcm_mult_h( (uint64x2_t *)a1,  (int8x16_t *)(a1 + 16),  *(double *)v21.i64,  *(double *)v20.i64,  v14,  v15,  v16,  v17);
  (*(void (**)(void, uint64_t, uint64_t, uint64_t, double))(*(void *)(a1 + 104) + 24LL))( *(void *)(a1 + 112),  1LL,  a1 + 48,  a1 + 64,  v22);
  int8x16_t v26 = veorq_s8(*(int8x16_t *)(a1 + 64), *(int8x16_t *)(a1 + 16));
  if (a2 >= 0x10) {
    a2 = 16LL;
  }
  if (*(_DWORD *)(a1 + 120) == 78647)
  {
    unsigned int v23 = cc_cmp_safe_internal(a2, v26.i8, a3);
    unint64_t v24 = -(((v23 | ((unint64_t)(int)v23 >> 32)) + 0xFFFFFFFF) >> 32) & 0xFFFFFFBB;
  }

  else
  {
    unint64_t v24 = 0LL;
  }

  memcpy(a3, &v26, a2);
  *(_WORD *)(a1 + 80) = 4;
  return v24;
}

uint64_t ccrng_sequence_non_repeat_init( uint64_t (**a1)(uint64_t a1, unint64_t a2, uint64_t a3), uint64_t (*a2)(uint64_t a1, unint64_t a2, uint64_t a3), uint64_t (*a3)(uint64_t a1, unint64_t a2, uint64_t a3))
{
  *a1 = non_repeat_sequence_generate;
  a1[1] = a3;
  a1[2] = a2;
  return 0LL;
}

uint64_t non_repeat_sequence_generate(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 < a2) {
    return 4294967286LL;
  }
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
      *(_BYTE *)(a3 + i) = *(_BYTE *)(*(void *)(a1 + 8) + i);
    unint64_t v3 = *(void *)(a1 + 16);
  }

  uint64_t v4 = 0LL;
  *(void *)(a1 + 8) += a2;
  *(void *)(a1 + 16) = v3 - a2;
  return v4;
}

uint64_t ccn_cmpn_public_value(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a1 >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = a1;
  }
  if (a1 >= a3) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = a4;
  }
  if (a1 <= a3) {
    unint64_t v6 = a3;
  }
  else {
    unint64_t v6 = a1;
  }
  if (a1 < a3) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = 1;
  }
  unsigned int v8 = ccn_cmp_public_value(v4, a2, a4);
  if (ccn_n(v6 - v4, v5 + 8 * v4)) {
    return v7;
  }
  else {
    return v8;
  }
}

uint64_t ccmode_gcm_aad( uint64_t a1, unint64_t a2, int8x16_t *a3, double a4, double a5, double a6, double a7, double a8, int8x16_t a9)
{
  if (*(_WORD *)(a1 + 80) != 2) {
    return 4294967228LL;
  }
  uint64_t v9 = a3;
  unint64_t v10 = a2;
  double v12 = (int8x16_t *)(a1 + 16);
  uint64_t v13 = *(void *)(a1 + 88);
  unsigned int v14 = v13 & 0xF;
  if ((v13 & 0xF) != 0)
  {
    uint64_t v15 = 16 - v14;
    uint64_t v16 = (v13 & 0xF) + a1 + 15;
    uint64_t v17 = 16 - v14;
    do
    {
      *(_BYTE *)(v16 + v17) ^= a3[-1].u8[v17 + 15];
      --v17;
    }

    while (v17);
    ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), a4, a5, a6, a7, a8, a9);
    v10 -= v15;
    uint64_t v9 = (int8x16_t *)((char *)v9 + v15);
    *(void *)(a1 + 88) += v15;
  }

  if (v10 >= 0x10)
  {
    unint64_t v18 = v10 & 0xFFFFFFFFFFFFFFF0LL;
    gcm_ghash(v12, (uint64x2_t *)(a1 + 128), v9, v10 & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v14 = 0;
    uint64_t v9 = (int8x16_t *)((char *)v9 + (v10 & 0xFFFFFFFFFFFFFFF0LL));
    v10 &= 0xFu;
    *(void *)(a1 + 88) += v18;
LABEL_9:
    if (v10) {
      goto LABEL_10;
    }
    return 0LL;
  }

  unsigned int v14 = 0;
  if (!v10) {
    return 0LL;
  }
LABEL_10:
  uint64_t v19 = a1 + v14 + 15;
  unint64_t v20 = v10;
  do
  {
    *(_BYTE *)(v19 + v20) ^= v9[-1].u8[v20 + 15];
    --v20;
  }

  while (v20);
  uint64_t result = 0LL;
  *(void *)(a1 + 88) += v10;
  return result;
}

uint64_t ccmode_gcm_init(uint64_t a1, int8x16_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (*(void *)(v2 + 8) != 16LL) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = a2 + 8;
  a2[6].i64[1] = v2;
  a2[7].i64[0] = (uint64_t)a2[24].i64;
  a2[7].i32[2] = *(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t))(v2 + 16))(v2);
  a2[5].i16[1] = 0;
  ccmode_gcm_reset((uint64_t)a2);
  double v5 = (*(double (**)(uint64_t, uint64_t, int8x16_t *, int8x16_t *))(v2 + 24))(a2[7].i64[0], 1LL, a2 + 1, a2);
  gcm_init(v4, a2, v5, v6, v7, v8, v9, v10);
  return 0LL;
}

double ccmode_gcm_mult_h( uint64x2_t *a1, int8x16_t *a2, double a3, double a4, double a5, double a6, double a7, int8x16_t a8)
{
  *(void *)&double result = gcm_gmult(a2, a1 + 8, a2, a3, a4, a5, a6, a7, a8).u64[0];
  return result;
}

uint64_t ccec_der_import_priv(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  BOOL v23 = timingsafe_enable_if_supported();
  unint64_t v8 = 26 * *a1;
  if (20 * *a1 > v8) {
    unint64_t v8 = 20 * *a1;
  }
  double v9 = cc_malloc_clear(8 * v8);
  unint64_t v10 = 26 * *a1;
  if (20 * *a1 > v10) {
    unint64_t v10 = 20 * *a1;
  }
  v21[0] = v9;
  v21[1] = v10;
  v21[2] = 0LL;
  v21[3] = cc_ws_alloc;
  double v22 = cc_ws_free;
  if (v9)
  {
    uint64_t v19 = 0LL;
    unint64_t v20 = 0LL;
    uint64_t v17 = 0LL;
    unint64_t v18 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    *a4 = a1;
    if (ccder_decode_eckey_internal(&v20, &v19, &v17, &v15, &v18, &v16, a3, &a3[a2])
      && (uint64_t v11 = v19, v11 == (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3)
      && !ccn_read_uint_internal(*a1, &a4[3 * **a4 + 2], v19, v17))
    {
      if (v16 && (unint64_t v12 = v18, (((unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 2) | 1) <= v12 >> 3))
      {
        else {
          uint64_t pub_from_priv_ws = 0LL;
        }
      }

      else
      {
        uint64_t pub_from_priv_ws = ccec_make_pub_from_priv_ws((uint64_t)v21, a1, 0LL, (uint64_t)&a4[3 * **a4 + 2], 0LL, a4);
      }
    }

    else
    {
      uint64_t pub_from_priv_ws = 0xFFFFFFFFLL;
    }

    v22((uint64_t)v21);
  }

  else
  {
    uint64_t pub_from_priv_ws = 4294967283LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v23);
  return pub_from_priv_ws;
}

uint64_t cczp_sqrt_tonelli_shanks_precomp_ws( uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, unint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v12 = cczp_n(a2);
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  unsigned int v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t v16 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12);
  uint64_t result = cczp_power_fast_ws(a1, a2, a3, a4, a6);
  uint64_t v18 = v23;
  if (!(_DWORD)result)
  {
    ccn_seti(v12, v16, 1LL);
    int v25 = v16;
    cczp_to_ws(a1, a2);
    ccn_set(v12, v15, a7);
    cczp_sqr_ws(a1, a2);
    cczp_mul_ws(a1, a2);
    cczp_mul_ws(a1, a2);
    if (a5 >= 2)
    {
      while (1)
      {
        ccn_set(v12, v14, v13);
        if (a5 - 1 < 2) {
          break;
        }
        uint64_t v19 = 2LL;
        do
        {
          cczp_sqr_ws(a1, a2);
          ++v19;
        }

        while (a5 != v19);
        char v20 = ccn_cmp_public_value(v12, v14, v25) & 1;
        cczp_mul_ws(a1, a2);
        ccn_mux(v12, v20, a3, (uint64_t *)v14, a3);
        cczp_sqr_ws(a1, a2);
        cczp_mul_ws(a1, a2);
        ccn_mux(v12, v20, (uint64_t *)v13, (uint64_t *)v14, (uint64_t *)v13);
        --a5;
      }

      char v21 = ccn_cmp_public_value(v12, v14, v25) & 1;
      cczp_mul_ws(a1, a2);
      ccn_mux(v12, v21, a3, (uint64_t *)v14, a3);
      cczp_sqr_ws(a1, a2);
      cczp_mul_ws(a1, a2);
      ccn_mux(v12, v21, (uint64_t *)v13, (uint64_t *)v14, (uint64_t *)v13);
    }

    cczp_sqr_ws(a1, a2);
    else {
      uint64_t result = 0LL;
    }
    uint64_t v18 = v23;
  }

  *(void *)(a1 + 16) = v18;
  return result;
}

uint64_t cczp_sqrt_default_ws(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = ~*(_DWORD *)cczp_prime(a2) & 3LL;
  uint64_t v9 = cczp_n(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
  uint64_t v12 = (void *)cczp_prime(a2);
  if (v8)
  {
    ccn_set(v9, v11, v12);
    v11->i64[0] &= ~1uLL;
    unint64_t v14 = ccn_trailing_zeros(v9, (uint64_t)v11);
    ccn_shift_right_multi(v9, v11, v11, v14);
    uint64_t v15 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
    ccn_sub1(v9, v15, (unint64_t *)v11, 1uLL);
    ccn_shift_right(v9, v15, v15, 1LL);
    uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v9);
    ccn_seti(v9, v16, 1LL);
    uint64_t result = cczp_power_fast_ws(a1, a2, v16, v16, (uint64_t)v11);
    if (!(_DWORD)result) {
      uint64_t result = cczp_sqrt_tonelli_shanks_precomp_ws(a1, a2, a3, a4, v14, (uint64_t)v15, v16);
    }
  }

  else
  {
    ccn_add1_ws(a1, v9, v11, (uint64_t *)v12, 1LL);
    ccn_shift_right(v9, v11, v11, 2LL);
    uint64_t result = cczp_power_fast_ws(a1, a2, a3, a4, (uint64_t)v11);
    if (!(_DWORD)result)
    {
      cczp_sqr_ws(a1, a2);
      else {
        uint64_t result = 0LL;
      }
    }
  }

  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_sqrt_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 48LL))();
}

uint64_t ccmode_gcm_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 84) = 0;
  *(_WORD *)(a1 + 80) = 1;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  return 0LL;
}

uint64_t ccmode_gcm_set_iv(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  if (*(_WORD *)(a1 + 80) != 1 || (*(_WORD *)(a1 + 82) & 1) != 0) {
    return 4294967228LL;
  }
  unint64_t v4 = a2;
  uint64_t result = 4294967228LL;
  if (a2)
  {
    double v6 = a3;
    if (a3)
    {
      double v7 = (void *)(a1 + 32);
      if (a2 == 12)
      {
        uint64_t v8 = *a3;
        *(_DWORD *)(a1 + 40) = *((_DWORD *)a3 + 2);
        void *v7 = v8;
        *(_DWORD *)(a1 + 44) = 0x1000000;
      }

      else
      {
        int8x16_t v18 = 0uLL;
        cc_clear(8uLL, &v18);
        v18.i64[1] = bswap64(8 * v4);
        cc_clear(0x10uLL, (void *)(a1 + 32));
        if (v4 < 0x10) {
          goto LABEL_20;
        }
        do
        {
          for (uint64_t i = 0LL; i != -16; --i)
            *(_BYTE *)(a1 + i + 47) ^= *((_BYTE *)v6 + i + 15);
          double v9 = ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 32), v9, v10, v11, v12, v13, v14);
          v6 += 2;
          v4 -= 16LL;
        }

        while (v4 > 0xF);
        if (v4)
        {
LABEL_20:
          do
          {
            *(_BYTE *)(a1 + v4 + 31) ^= *((_BYTE *)v6 + v4 - 1);
            --v4;
          }

          while (v4);
          ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 32), v9, v10, v11, v12, v13, v14);
        }

        double v16 = *(double *)v18.i64;
        int8x16_t v17 = veorq_s8(v18, *(int8x16_t *)(a1 + 32));
        *(int8x16_t *)(a1 + 32) = v17;
        ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 32), *(double *)v17.i64, v16, v11, v12, v13, v14);
      }

      *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)v7;
      ccmode_gcm_update_pad(a1);
      uint64_t result = 0LL;
      *(_WORD *)(a1 + 80) = 2;
    }
  }

  return result;
}

BOOL ccec_is_point_projective_ws(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(a1 + 24))(a1, *a2);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, v4);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sub_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  cczp_mul_ws(a1, (uint64_t)a2);
  cczp_add_ws(a1, (uint64_t)a2);
  cczp_sqr_ws(a1, (uint64_t)a2);
  BOOL result = ccn_cmp_public_value(v4, v7, v6) == 0;
  *(void *)(a1 + 16) = v5;
  return result;
}

BOOL ccec_is_point_at_infinity(void *a1, uint64_t a2)
{
  return ccn_n(*a1, a2 + 16LL * *a1) == 0;
}

uint64_t ccentropy_get_seed(uint64_t (***a1)(void, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = (**a1)(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

uint64_t ccec_make_pub_from_priv_ws( uint64_t a1, uint64_t *a2, uint64_t (**a3)(void, uint64_t, uint64_t *), uint64_t a4, uint64_t a5, uint64_t **a6)
{
  *a6 = a2;
  uint64_t v12 = *a2;
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * *a2);
  if (ccec_validate_scalar(a2, a4))
  {
    uint64_t result = 4294967274LL;
    goto LABEL_10;
  }

  if (a5)
  {
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, a2, v14, a5);
    if ((_DWORD)result) {
      goto LABEL_10;
    }
  }

  else
  {
    uint64_t result = ccec_projectify_ws(a1, (uint64_t)a2);
    if ((_DWORD)result) {
      goto LABEL_10;
    }
  }

  if (ccec_mult_blinded_ws(a1, (unint64_t *)a2, (uint64_t)(a6 + 2), a4, v14, a3))
  {
    uint64_t result = 4294967280LL;
  }

  else if (ccec_is_point_projective_ws(a1, a2))
  {
    if (ccec_affinify_ws(a1, (uint64_t)a2))
    {
      uint64_t result = 4294967279LL;
    }

    else
    {
      ccn_seti(v12, &a6[2 * **a6 + 2], 1LL);
      uint64_t result = 0LL;
    }
  }

  else
  {
    uint64_t result = 4294967277LL;
  }

uint64_t ccn_recode_jsf_init(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0LL;
  unint64_t v5 = (unint64_t)(a2 - 1) >> 6;
  *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = a3;
  *(void *)(result + 16) = a4;
  char v6 = (a2 - 1) & 0x3F;
  unint64_t v7 = (unint64_t)(a2 - 2) >> 6;
  char v8 = (a2 - 2) & 0x3F;
  v16[0] = a3;
  v16[1] = a4;
  unint64_t v9 = (unint64_t)(a2 - 3) >> 6;
  char v10 = (a2 - 3) & 0x3F;
  unint64_t v11 = (unint64_t)(a2 - 4) >> 6;
  char v12 = (a2 - 4) & 0x3F;
  char v13 = 1;
  do
  {
    char v14 = v13;
    uint64_t v15 = v16[v4];
    *(_BYTE *)(result + v4) = (8 * ((*(void *)(v15 + 8 * v5) >> v6) & 1)) | (4
                                                                             * ((*(void *)(v15 + 8 * v7) >> v8) & 1)) | (2 * ((*(void *)(v15 + 8 * v9) >> v10) & 1)) | (*(void *)(v15 + 8 * v11) >> v12) & 1;
    uint64_t v4 = 1LL;
    char v13 = 0;
  }

  while ((v14 & 1) != 0);
  return result;
}

uint64_t ccn_recode_jsf_column(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  __int16 v10 = 0;
  if ((*(_BYTE *)result & 0x20) != 0) {
    char v4 = *(_BYTE *)result & 0x1F ^ 0x1F;
  }
  else {
    char v4 = *(_BYTE *)result & 0x1F;
  }
  LOBYTE(v10) = v4;
  if ((*(_BYTE *)(result + 1) & 0x20) != 0) {
    char v5 = *(_BYTE *)(result + 1) & 0x1F ^ 0x1F;
  }
  else {
    char v5 = *(_BYTE *)(result + 1) & 0x1F;
  }
  HIBYTE(v10) = v5;
  __int128 v11 = *(_OWORD *)(result + 8);
  char v6 = 1;
  do
  {
    char v7 = v6;
    if (a2 < 5) {
      LOBYTE(v_Block_object_dispose((const void *)(v11 - 96), 8) = 0;
    }
    else {
      uint64_t v8 = (*(void *)(*((void *)&v11 + v3) + 8 * ((a2 - 5) >> 6)) >> ((a2 - 5) & 0x3F)) & 1LL;
    }
    if (*((unsigned __int8 *)&v10 + v3) >= F_2_2_11[*((unsigned __int8 *)&v10 + (v3 ^ 1))])
    {
      LOBYTE(v_Block_object_dispose((const void *)(v11 - 96), 8) = v8 | 0x20;
      if ((*(_BYTE *)(result + v3) & 0x20) != 0) {
        int v9 = -1;
      }
      else {
        int v9 = 1;
      }
    }

    else
    {
      int v9 = 0;
    }

    char v6 = 0;
    *(_DWORD *)(a3 + 4 * v3) = v9;
    *(_BYTE *)(result + v3) = v8 ^ (2 * *(_BYTE *)(result + v3));
    uint64_t v3 = 1LL;
  }

  while ((v7 & 1) != 0);
  return result;
}

unint64_t ccn_recode_jsf_index(_DWORD *a1)
{
  return (*a1 & 1 | (2 * (a1[1] & 1u))) - (unint64_t)(*a1 + a1[1] != 0);
}

uint64_t ccn_recode_jsf_direction(unsigned int *a1)
{
  uint64_t result = *a1;
  if ((_DWORD)result != -1)
  {
    if (!(_DWORD)result && a1[1] == -1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 1LL;
    }
  }

  return result;
}

uint64_t ccec_compressed_x962_import_pub( unint64_t *a1, uint64_t a2, unsigned __int8 *a3, unint64_t **a4)
{
  LODWORD(result) = ccec_x963_import_pub(a1, a2, a3, a4);
  if ((_DWORD)result == -7) {
    return 4294967135LL;
  }
  else {
    return result;
  }
}

BOOL ccn_add_ws(uint64_t a1, BOOL a2, void *a3, uint64_t *a4, uint64_t *a5)
{
  return ccn_add_asm(a2, a3, a4, a5);
}

uint64_t cc_log_default()
{
  if (cc_log_default_initp != -1) {
    _os_once(&cc_log_default_initp, &cc_log_default_log, cc_log_init);
  }
  return cc_log_default_log;
}

os_log_t cc_log_init(os_log_t *a1)
{
  os_log_t result = os_log_create("com.apple.corecrypto", "default");
  *a1 = result;
  return result;
}

BOOL ccn_add_asm(BOOL result, void *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL v4 = 0;
  if (result)
  {
    if (result)
    {
      uint64_t v6 = *a3++;
      uint64_t v5 = v6;
      uint64_t v7 = *a4++;
      BOOL v4 = __CFADD__(v5, v7);
      *a2++ = v5 + v7;
    }

    if (result & 2)
    {
      uint64_t v8 = *a3;
      uint64_t v9 = a3[1];
      a3 += 2;
      uint64_t v10 = *a4;
      uint64_t v11 = a4[1];
      a4 += 2;
      uint64_t v13 = v4 + v8;
      BOOL v4 = __CFADD__(v4, v8) | __CFADD__(v10, v13);
      uint64_t v12 = v10 + v13;
      uint64_t v14 = v4 + v9;
      BOOL v4 = __CFADD__(v4, v9) | __CFADD__(v11, v14);
      *a2 = v12;
      a2[1] = v11 + v14;
      a2 += 2;
    }

    BOOL v15 = result & 0xFFFFFFFC;
    if (v15)
    {
      int v16 = v15 - 4;
      uint64_t v18 = *a3;
      uint64_t v19 = a3[1];
      int8x16_t v17 = a3 + 2;
      uint64_t v21 = *a4;
      uint64_t v22 = a4[1];
      char v20 = a4 + 2;
      uint64_t v24 = *v17;
      uint64_t v25 = v17[1];
      uint64_t v23 = v17 + 2;
      uint64_t v27 = *v20;
      uint64_t v28 = v20[1];
      for (uint64_t i = v20 + 2; v16; uint64_t i = v38 + 2)
      {
        uint64_t v30 = v4 + v18;
        BOOL v4 = __CFADD__(v4, v18) | __CFADD__(v21, v30);
        uint64_t v29 = v21 + v30;
        uint64_t v32 = v4 + v19;
        BOOL v4 = __CFADD__(v4, v19) | __CFADD__(v22, v32);
        uint64_t v31 = v22 + v32;
        uint64_t v18 = *v23;
        uint64_t v19 = v23[1];
        int v33 = v23 + 2;
        uint64_t v35 = v4 + v24;
        BOOL v4 = __CFADD__(v4, v24) | __CFADD__(v27, v35);
        uint64_t v34 = v27 + v35;
        *a2 = v29;
        a2[1] = v31;
        int v36 = a2 + 2;
        uint64_t v37 = v4 + v25;
        BOOL v4 = __CFADD__(v4, v25) | __CFADD__(v28, v37);
        uint64_t v21 = *i;
        uint64_t v22 = i[1];
        int v38 = i + 2;
        void *v36 = v34;
        v36[1] = v28 + v37;
        a2 = v36 + 2;
        v16 -= 4;
        uint64_t v24 = *v33;
        uint64_t v25 = v33[1];
        uint64_t v23 = v33 + 2;
        uint64_t v27 = *v38;
        uint64_t v28 = v38[1];
      }

      uint64_t v40 = v4 + v18;
      BOOL v4 = __CFADD__(v4, v18) | __CFADD__(v21, v40);
      uint64_t v39 = v21 + v40;
      uint64_t v42 = v4 + v19;
      BOOL v4 = __CFADD__(v4, v19) | __CFADD__(v22, v42);
      uint64_t v41 = v22 + v42;
      uint64_t v44 = v4 + v24;
      BOOL v4 = __CFADD__(v4, v24) | __CFADD__(v27, v44);
      uint64_t v43 = v27 + v44;
      uint64_t v45 = v4 + v25;
      BOOL v4 = __CFADD__(v4, v25) | __CFADD__(v28, v45);
      *a2 = v39;
      a2[1] = v41;
      int v46 = a2 + 2;
      *int v46 = v43;
      v46[1] = v28 + v45;
    }

    return v4;
  }

  return result;
}

BOOL ccn_add1_ws(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, uint64_t a5)
{
  if (a2) {
    return ccn_add1_asm(a2, a3, a4, a5);
  }
  else {
    return a5;
  }
}

uint64_t ccn_mux(uint64_t result, char a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t v5 = state ^ (state << 13) ^ ((state ^ (unint64_t)(state << 13)) >> 7);
  uint64_t v6 = v5 ^ (v5 << 17);
  state = v6;
  for (uint64_t i = __ROR8__(0x5555555555555555LL, a2 | (2 * v6)); result; --result)
  {
    uint64_t v9 = *a4++;
    uint64_t v8 = v9;
    uint64_t v10 = *a5++;
    *a3 = v10 ^ v6;
    *a3++ = (v10 ^ v8) & 0x5555555555555555LL ^ v10 ^ v6 ^ (v10 ^ v8) & i ^ v6;
  }

  return result;
}

uint64_t ccn_mux_next_mask()
{
  unint64_t v0 = state ^ (state << 13) ^ ((state ^ (unint64_t)(state << 13)) >> 7);
  uint64_t result = v0 ^ (v0 << 17);
  state = result;
  return result;
}

uint64_t ccn_mux_seed_mask(uint64_t result)
{
  state ^= result;
  return result;
}

uint64_t cczp_power_fast_ws(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v10 = cczp_n(a2);
  uint64_t v11 = ccn_bitlen_internal(v10, a5);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v17 = *(void *)(a1 + 16);
    uint64_t v13 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v10);
    ccn_set(v10, v13, a4);
    cczp_sqr_ws(a1, a2);
    cczp_mul_ws(a1, a2);
    uint64_t v14 = (*(void *)(a5 + (((unint64_t)(v12 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v12 - 1)) & 1LL;
    if ((v12 & 1) == 0) {
      uint64_t v14 = (*(void *)(a5 + (((unint64_t)(v12 - 2) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v12 - 2)) & 1LL | (2 * v14);
    }
    ccn_set(v10, a3, &v13[8 * (v14 - 1) * v10]);
    if ((v12 | 0xFFFFFFFFFFFFFFFELL) + v12)
    {
      unint64_t v15 = v12 + (v12 | 0xFFFFFFFFFFFFFFFELL) - 1;
      do
      {
        cczp_sqr_ws(a1, a2);
        cczp_sqr_ws(a1, a2);
        v15 -= 2LL;
      }

      while (v15 != -1LL);
    }

    *(void *)(a1 + 16) = v17;
  }

  else
  {
    ccn_seti(v10, a3, 1LL);
    cczp_to_ws(a1, a2);
  }

  return 0LL;
}

unint64_t ccn_bitlen_public_value(unint64_t result, unint64_t *a2)
{
  if (result)
  {
    unint64_t v2 = result;
    uint64_t result = 0LL;
    uint64_t v3 = 64LL;
    do
    {
      unint64_t v4 = *a2++;
      uint64_t result = ((((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32) - 1) & result | (v3 - __clz(v4 | 1)) & -(uint64_t)(((v4 | HIDWORD(v4)) + 0xFFFFFFFF) >> 32);
      v3 += 64LL;
      --v2;
    }

    while (v2);
  }

  return result;
}

uint64_t ccn_cmp(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t v6 = ccn_cmp_asm(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return v6;
}

void cc_abort()
{
}

uint64_t ccec_raw_import_pub(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t **a4)
{
  unint64_t v7 = *a1;
  unint64_t v8 = (unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 3;
  *a4 = a1;
  uint64_t v9 = a4 + 2;
  if (ccn_read_uint_public_value(v7, a4 + 2, v8, a3)
    || ccn_read_uint_public_value(v7, &v9[**a4], v8, &a3[v8]))
  {
    return 0xFFFFFFFFLL;
  }

  ccn_seti(*a1, &v9[2 * **a4], 1LL);
  return 0LL;
}

uint64_t ccec_raw_import_priv_only(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  BOOL v11 = timingsafe_enable_if_supported();
  if (a2 == (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3)
  {
    uint64_t v8 = *a1;
    *a4 = a1;
    memset(a4 + 2, 255, 8 * v8);
    memset(&a4[*a1 + 2], 255, 8 * v8);
    uint64_t uint_internal = ccn_read_uint_internal(v8, &a4[3 * **a4 + 2], a2, a3);
  }

  else
  {
    uint64_t uint_internal = 0xFFFFFFFFLL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v11);
  return uint_internal;
}

uint64_t ccn_mul_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return ccn_mul(a2, a3, a4, a5);
}

uint64_t ccn_divmod_ws( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v12 = ccn_n(a6, a8);
  unint64_t v13 = a2 - v12;
  uint64_t v50 = *(void *)(a1 + 16);
  uint64_t v14 = v12 + 1;
  unint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12 + 1);
  int v16 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12 + 1);
  uint64_t v59 = a1;
  uint64_t v17 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v12 + 1);
  v15[v12] = 0LL;
  uint64_t v57 = v12 - 1;
  unint64_t v18 = __clz(*(void *)(a8 + 8 * (v12 - 1)));
  ccn_shift_left(v12, (uint64_t)v15, a8, v18, v19);
  int v20 = -(int)v18;
  unint64_t v60 = v18;
  unint64_t v21 = v18 + 0xFFFFFFFF;
  if (v12) {
    ccn_set(v12, v16, (void *)(a3 + 8 * v13));
  }
  uint64_t v53 = -(uint64_t)HIDWORD(v21);
  char v54 = v20 & 0x3F;
  ccn_zero(1LL, (char *)v16 + 8 * v12);
  ccn_shift_left(v14, (uint64_t)v16, (uint64_t)v16, v60, v22);
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = v15[v57];
  uint64_t v27 = -v26;
  unint64_t v29 = (unsigned __int128)-(__int128)__PAIR128__(v28, v26) >> 64;
  uint64_t v30 = 65LL;
  unint64_t v31 = v26;
  do
  {
    unsigned __int128 v32 = __PAIR128__(v29, v27) - __PAIR128__(v31, v23);
    unint64_t v33 = (unint64_t)((__PAIR128__(v29, v27) - __PAIR128__(v31, v23)) >> 64) >> 63;
    uint64_t v34 = v29 & ((uint64_t)((__PAIR128__(v29, v27) - __PAIR128__(v31, v23)) >> 64) >> 63);
    uint64_t v27 = (v33 - 1) & v32 | v27 & (*((uint64_t *)&v32 + 1) >> 63);
    *((void *)&v35 + 1) = v25;
    *(void *)&__int128 v35 = v24;
    uint64_t v25 = v35 >> 63;
    *((void *)&v35 + 1) = v24;
    *(void *)&__int128 v35 = *((void *)&v32 + 1);
    unint64_t v29 = (v33 != 0 ? 0 : *((void *)&v32 + 1)) | v34;
    uint64_t v24 = (v35 >> 63) ^ 1;
    *((void *)&v35 + 1) = v31;
    *(void *)&__int128 v35 = v23;
    unint64_t v23 = v35 >> 1;
    v31 >>= 1;
    --v30;
  }

  while (v30);
  unint64_t v56 = (v24 + 2) | ((((HIDWORD(v15[v57]) ^ 0x80000000 | v15[v57]) + 0xFFFFFFFF) >> 32) - 1);
  size_t v52 = 8 * v12;
  uint64_t v58 = v12;
  int v36 = (void *)(a3 - 8 * v12 + 8 * a2);
  unint64_t v37 = v13;
  do
  {
    unint64_t v38 = v13;
    uint64_t v39 = *v36 << v60;
    v16->i64[0] = v39;
    if (v37) {
      v16->i64[0] = ((*(v36 - 1) & (unint64_t)v53) >> v54) | v39;
    }
    unint64_t v40 = v16->u64[v58];
    uint64_t v41 = v16->i64[v57];
    uint64_t v63 = v15[v57];
    unint64_t v42 = ((__PAIR128__(v40, v41) - (unint64_t)v63) >> 64) + ((v40 * (unsigned __int128)v56) >> 64) + 2;
    if (v42 < v40) {
      unint64_t v42 = -1LL;
    }
    unint64_t v62 = v42;
    v65[0] = 0LL;
    v65[1] = 0LL;
    ccn_mul(1LL, (uint64_t)v65, (uint64_t)&v62, (uint64_t)&v63);
    v64[0] = v41;
    v64[1] = v40;
    BOOL v43 = ccn_sub_ws(0LL, 2LL, v65, v64, (unint64_t *)v65);
    v62 -= 2 * v43;
    BOOL v44 = ccn_add1_ws(0LL, 2LL, v65, v65, v63);
    unint64_t v45 = v62 + v44;
    v17[v58] = ccn_mul1(v58, v17, v15, v62 + v44);
    BOOL v46 = ccn_sub_ws(v59, v14, v16, v16->i64, v17);
    uint64_t v47 = v46 - ccn_cond_add(v14, v46, v16->i64, v16->i64, v15);
    uint64_t result = ccn_cond_add(v14, v47, v16->i64, v16->i64, v15);
    if (a5 && v37 < a4) {
      *(void *)(a5 + 8 * v37) = v45 - (v46 + v47);
    }
    if (v37) {
      uint64_t result = (uint64_t)memmove(&v16->u64[1], v16, v52);
    }
    --v37;
    --v36;
    unint64_t v13 = v38;
  }

  while (v37 <= v38);
  if (a5 && a4 > v38 + 1) {
    uint64_t result = cc_clear(8 * (a4 - (v38 + 1)), (void *)(a5 + 8 * (v38 + 1)));
  }
  if (a7)
  {
    ccn_shift_right(v58, v16, v16, v60);
    if (v58) {
      ccn_set(v58, a7, v16);
    }
    uint64_t result = ccn_zero(a6 - v58, &a7[8 * v58]);
  }

  *(void *)(v59 + 16) = v50;
  return result;
}

uint64_t cccbc_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t cccbc_set_iv_internal(uint64_t a1, void *__dst, void *__src)
{
  if (__src) {
    memcpy(__dst, __src, *(void *)(a1 + 8));
  }
  else {
    cc_clear(*(void *)(a1 + 8), __dst);
  }
  return 0LL;
}

uint64_t cccbc_update_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5, a6);
}

uint64_t cccbc_one_shot_explicit_internal( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, uint64_t a8, uint64_t a9)
{
  if (*(void *)(a1 + 8) != a4 || a3 && a3 != a4) {
    return 4294967289LL;
  }
  size_t v16 = (*(void *)a1 + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  uint64_t v17 = (char *)&v22 - v16;
  bzero((char *)&v22 - v16, v16);
  size_t v18 = (*(void *)(a1 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  uint64x2_t v19 = (char *)&v22 - v18;
  bzero((char *)&v22 - v18, v18);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a1 + 16))(a1, v17, a2, a6);
  if ((_DWORD)v20) {
    return v20;
  }
  if (a7) {
    memcpy(v19, a7, *(void *)(a1 + 8));
  }
  else {
    cc_clear(*(void *)(a1 + 8), v19);
  }
  uint64_t v15 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(a1 + 24))(v17, v19, a5, a8, a9);
  cc_clear(*(void *)a1, v17);
  return v15;
}

uint64_t ccmode_ctr_setctr(int a1, void *a2, void *__src)
{
  uint64_t v3 = *a2;
  a2[1] = *(void *)(*a2 + 8LL);
  memcpy((char *)a2 + ((*(void *)(v3 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 16, __src, *(void *)(v3 + 8));
  return 0LL;
}

uint64_t ccn_random_bits( uint64_t a1, uint64_t a2, uint64_t (**a3)(void, unint64_t, uint64_t))
{
  char v4 = a1;
  unint64_t v5 = (unint64_t)(a1 + 63) >> 6;
  uint64_t result = (*a3)(a3, 8 * v5, a2);
  if (!(_DWORD)result) {
    *(void *)(a2 + 8 * v5 - 8) &= 0xFFFFFFFFFFFFFFFFLL >> -(((((unint64_t)(v4 & 0x3F) + 0xFFFFFFFF) >> 32) - 1) & 0x40 | v4 & 0x3F);
  }
  return result;
}

uint64_t ccn_random_bits_fips( uint64_t a1, void *a2, uint64_t (**a3)(void, unint64_t, void *))
{
  char v4 = a1;
  unint64_t v5 = (unint64_t)(a1 + 63) >> 6;
  if ((unint64_t)(a1 + 63) > 0x7F)
  {
    uint64_t v6 = (*a3)(a3, 8 * v5, a2);
  }

  else
  {
    int v9 = 0;
    __srCC_SHA1_CTX c = 0LL;
    uint64_t v6 = (*a3)(a3, 12uLL, &__src);
    memcpy(a2, &__src, 8 * v5);
    cc_clear(8 * v5, &__src);
  }

  if (!(_DWORD)v6) {
    *((void *)a2 + v5 - 1) &= 0xFFFFFFFFFFFFFFFFLL >> -(((((unint64_t)(v4 & 0x3F) + 0xFFFFFFFF) >> 32) - 1) & 0x40 | v4 & 0x3F);
  }
  return v6;
}

uint64_t ccn_read_uint_public_value( unint64_t a1, void *a2, unint64_t a3, unsigned __int8 *a4)
{
  unint64_t v4 = 8 * a1;
  if (a3 > 8 * a1)
  {
    int v5 = 0;
    unint64_t v6 = a3 - v4;
    unint64_t v7 = a4;
    do
    {
      int v8 = *v7++;
      v5 |= v8;
      --a3;
    }

    while (a3 > v4);
    if (v5) {
      return 4294967289LL;
    }
    a4 += v6;
    a3 = 8 * a1;
  }

  if (a3 < 8)
  {
    unint64_t v10 = 0LL;
  }

  else
  {
    unint64_t v10 = ((a3 - 8) >> 3) + 1;
    BOOL v11 = a2;
    unint64_t v12 = v10;
    do
    {
      *v11++ = bswap64(*(void *)&a4[a3 - 8]);
      a3 -= 8LL;
      --v12;
    }

    while (v12);
  }

  if (a3)
  {
    unint64_t v13 = 0LL;
    uint64_t v14 = -(uint64_t)a3;
    do
      unint64_t v13 = a4[a3 + v14] | (v13 << 8);
    while (!__CFADD__(v14++, 1LL));
    a2[v10++] = v13;
  }

  if (v10 < a1) {
    bzero(&a2[v10], v4 - 8 * v10);
  }
  return 0LL;
}

void *ccn_set(uint64_t a1, void *__dst, void *__src)
{
  return memmove(__dst, __src, 8 * a1);
}

uint64_t ccrng_process_init( uint64_t a1, uint64_t (*a2)(void), uint64_t (**a3)(void, uint64_t, _OWORD *))
{
  uint64_t v6 = a1 + 128;
  ccrng_schedule_timer_init(a1 + 128, a2, 5000000000LL);
  ccrng_schedule_atomic_flag_init(a1 + 168);
  ccrng_schedule_tree_init(a1 + 96, v6, a1 + 168);
  uint64_t result = cc_lock_init((_DWORD *)(a1 + 208));
  if (!(_DWORD)result)
  {
    uint64_t result = ccentropy_rng_init((void *)(a1 + 192), (uint64_t)a3);
    if (!(_DWORD)result)
    {
      int v8 = ccaes_cbc_encrypt_mode();
      uint64_t result = ccdrbg_df_bc_init_internal((void *)(a1 + 224), v8, 0x20uLL);
      if (!(_DWORD)result)
      {
        int v9 = ccaes_ctr_crypt_mode();
        __int128 v10 = xmmword_27FCB0;
        DWORD2(v10) = 1;
        uint64_t v11 = a1 + 224;
        ccdrbg_factory_nistctr((void *)(a1 + 768), (uint64_t)&v9);
        memset(v13, 0, sizeof(v13));
        uint64_t result = (*a3)(a3, 32LL, v13);
        if (!(_DWORD)result)
        {
          a2();
          strcpy(v12, "corecrypto process rng");
          uint64_t result = ccdrbg_init_internal(a1 + 768);
          if (!(_DWORD)result)
          {
            uint64_t result = ccrng_crypto_init( (void *)(a1 + 8),  a1 + 192,  a1 + 96,  a1 + 208,  a1 + 768,  a1 + 824,  4096LL,  0x20uLL,  256LL,  a1 + 2104);
            if (!(_DWORD)result) {
              *(void *)a1 = generate_2;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t generate_2(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a1 + 8);
}

uint64_t ccrng_process_atfork_prepare(os_unfair_lock_s *a1)
{
  return 0LL;
}

uint64_t ccrng_process_atfork_parent(os_unfair_lock_s *a1)
{
  return 0LL;
}

uint64_t ccrng_process_atfork_child(uint64_t a1)
{
  return cc_lock_init((_DWORD *)(a1 + 208));
}

uint64_t ccec_verify_composite_digest_ws( uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  if (a7)
  {
    *a7 = 0LL;
    a7[1] = 0LL;
  }

  __int128 v21 = 0uLL;
  uint64_t v13 = *(void *)*a2;
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v13);
  unint64_t v17 = ccec_signature_r_s_size(a2);
  if (ccn_read_uint_internal(v13, v15, v17, a5)
    || (unint64_t v18 = ccec_signature_r_s_size(a2), ccn_read_uint_internal(v13, v16, v18, a6)))
  {
    uint64_t result = 4294967289LL;
  }

  else
  {
    uint64_t result = ccec_verify_internal_ws(a1, (unint64_t **)a2, a3, a4, v15, v16, (uint64_t)&v21);
    if (a7 && !(_DWORD)result) {
      *(_OWORD *)a7 = v21;
    }
  }

  *(void *)(a1 + 16) = v14;
  return result;
}

uint64_t ccec_verify_composite_msg_ws( uint64_t a1, uint64_t *a2, unint64_t *a3, size_t a4, char *a5, uint64_t a6, uint64_t a7, void *a8)
{
  return ccec_verify_composite_digest_ws(a1, a2, *a3, (uint64_t)v15, a6, a7, a8);
}

uint64_t ccn_shift_right(uint64_t result, int8x16_t *a2, int8x16_t *a3, uint64_t a4)
{
  if (result) {
    return ccn_shift_right_asm(result, a2, a3, a4);
  }
  return result;
}

uint64_t ccn_shift_right_multi(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t a4)
{
  uint64_t result = ccn_shift_right(a1, a2, a3, a4 & 0x3F);
  if (a1)
  {
    uint64_t v8 = 0LL;
    do
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = v8;
      do
      {
        v9 |= ((((v10 ^ ((_DWORD)v8 + (a4 >> 6)) | ((v10 ^ (v8 + (a4 >> 6))) >> 32))
               + 0xFFFFFFFF) >> 32)
             - 1) & a2->i64[v10];
        ++v10;
      }

      while (a1 != v10);
      a2->i64[v8++] = v9;
    }

    while (v8 != a1);
  }

  return result;
}

BOOL ccn_sub_ws(uint64_t a1, BOOL a2, void *a3, uint64_t *a4, unint64_t *a5)
{
  return ccn_sub_asm(a2, a3, a4, a5);
}

BOOL ccn_sub(BOOL a1, void *a2, uint64_t *a3, unint64_t *a4)
{
  BOOL v12 = timingsafe_enable_if_supported();
  v10[0] = xmmword_351730;
  v10[1] = unk_351740;
  uint64_t v11 = cc_ws_free_null;
  BOOL v8 = ccn_sub_asm(a1, a2, a3, a4);
  cc_ws_free_null(v10);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v8;
}

BOOL ccn_sub_asm(BOOL result, void *a2, uint64_t *a3, unint64_t *a4)
{
  _BOOL1 v4 = 1;
  if (result)
  {
    if (result)
    {
      unint64_t v6 = *a3++;
      unint64_t v5 = v6;
      unint64_t v7 = *a4++;
      _BOOL1 v4 = v5 >= v7;
      *a2++ = v5 - v7;
    }

    if (result & 2)
    {
      uint64_t v8 = *a3;
      uint64_t v9 = a3[1];
      a3 += 2;
      unint64_t v10 = *a4;
      unint64_t v11 = a4[1];
      a4 += 2;
      _BOOL1 v13 = v4;
      _BOOL1 v4 = __CFSUB__(v8, v10, v4);
      uint64_t v12 = v8 - (v10 + !v13);
      _BOOL1 v14 = v4;
      _BOOL1 v4 = __CFSUB__(v9, v11, v4);
      *a2 = v12;
      a2[1] = v9 - (v11 + !v14);
      a2 += 2;
    }

    BOOL v15 = result & 0xFFFFFFFC;
    if (v15)
    {
      int v16 = v15 - 4;
      uint64_t v18 = *a3;
      uint64_t v19 = a3[1];
      unint64_t v17 = a3 + 2;
      unint64_t v21 = *a4;
      uint64_t v22 = a4[1];
      uint64_t v20 = (uint64_t *)(a4 + 2);
      uint64_t v24 = *v17;
      uint64_t v25 = v17[1];
      unint64_t v23 = v17 + 2;
      uint64_t v27 = *v20;
      uint64_t v28 = v20[1];
      for (uint64_t i = v20 + 2; v16; uint64_t i = v38 + 2)
      {
        _BOOL1 v30 = v4;
        _BOOL1 v4 = __CFSUB__(v18, v21, v4);
        uint64_t v29 = v18 - (v21 + !v30);
        _BOOL1 v32 = v4;
        _BOOL1 v4 = __CFSUB__(v19, v22, v4);
        uint64_t v31 = v19 - (v22 + !v32);
        uint64_t v18 = *v23;
        uint64_t v19 = v23[1];
        unint64_t v33 = v23 + 2;
        _BOOL1 v35 = v4;
        _BOOL1 v4 = __CFSUB__(v24, v27, v4);
        uint64_t v34 = v24 - (v27 + !v35);
        *a2 = v29;
        a2[1] = v31;
        int v36 = a2 + 2;
        _BOOL1 v37 = v4;
        _BOOL1 v4 = __CFSUB__(v25, v28, v4);
        unint64_t v21 = *i;
        uint64_t v22 = i[1];
        unint64_t v38 = i + 2;
        void *v36 = v34;
        v36[1] = v25 - (v28 + !v37);
        a2 = v36 + 2;
        v16 -= 4;
        uint64_t v24 = *v33;
        uint64_t v25 = v33[1];
        unint64_t v23 = v33 + 2;
        uint64_t v27 = *v38;
        uint64_t v28 = v38[1];
      }

      _BOOL1 v40 = v4;
      _BOOL1 v4 = __CFSUB__(v18, v21, v4);
      uint64_t v39 = v18 - (v21 + !v40);
      _BOOL1 v42 = v4;
      _BOOL1 v4 = __CFSUB__(v19, v22, v4);
      uint64_t v41 = v19 - (v22 + !v42);
      _BOOL1 v44 = v4;
      _BOOL1 v4 = __CFSUB__(v24, v27, v4);
      uint64_t v43 = v24 - (v27 + !v44);
      _BOOL1 v45 = v4;
      _BOOL1 v4 = __CFSUB__(v25, v28, v4);
      *a2 = v39;
      a2[1] = v41;
      BOOL v46 = a2 + 2;
      *BOOL v46 = v43;
      v46[1] = v25 - (v28 + !v45);
    }

    return !v4;
  }

  return result;
}

unint64_t ccn_sub1(uint64_t a1, void *a2, unint64_t *a3, unint64_t a4)
{
  {
    unint64_t v4 = *a3++;
    unsigned __int128 v5 = v4 - (unsigned __int128)a4;
    *a2++ = v5;
    a4 = *((void *)&v5 + 1) >> 63;
  }

  return a4;
}

unint64_t ccn_write_int_size_public_value(unint64_t a1, unint64_t *a2)
{
  unint64_t v2 = ccn_bitlen_public_value(a1, a2);
  if ((v2 & 7) != 0) {
    return (v2 + 7) >> 3;
  }
  else {
    return ((v2 + 7) >> 3) + 1;
  }
}

unint64_t ccn_write_int_public_value( unint64_t a1, unint64_t *a2, unint64_t a3, _BYTE *a4)
{
  if ((ccn_bitlen_public_value(a1, a2) & 7) == 0)
  {
    *a4++ = 0;
    --a3;
  }

  return ccn_write_uint_public_value(a1, a2, a3, (uint64_t)a4);
}

unint64_t ccn_write_uint_size_internal(unint64_t a1, unint64_t *a2)
{
  return (ccn_bitlen_public_value(a1, a2) + 7) >> 3;
}

uint64_t ccn_write_uint_padded_ct_internal( unint64_t a1, unint64_t *a2, unint64_t a3, char *__s)
{
  if (a3 > 0x7FFFFFFE) {
    return 4294967289LL;
  }
  unint64_t v6 = 8 * a1;
  if (8 * a1 > 0x7FFFFFFE) {
    return 4294967289LL;
  }
  unint64_t v7 = __s;
  unint64_t v8 = a3;
  unint64_t v10 = a3 - v6;
  if (a3 <= v6)
  {
    LODWORD(v10) = 0;
  }

  else
  {
    cc_clear(a3 - v6, __s);
    v7 += v10;
    unint64_t v8 = v6;
  }

  unint64_t v11 = ccn_bitlen_public_value(a1, a2);
  if (v8 < (v11 + 7) >> 3) {
    return 4294967289LL;
  }
  uint64_t result = (_DWORD)v10 + (_DWORD)v8 - ((v11 + 7) >> 3);
  if (v8 < 8)
  {
    unint64_t v12 = 0LL;
  }

  else
  {
    unint64_t v12 = ((v8 - 8) >> 3) + 1;
    _BOOL1 v13 = a2;
    unint64_t v14 = v12;
    do
    {
      unint64_t v15 = *v13++;
      *(void *)&v7[v8 - 8] = bswap64(v15);
      v8 -= 8LL;
      --v14;
    }

    while (v14);
  }

  if (v8)
  {
    unint64_t v16 = a2[v12];
    unint64_t v17 = &v7[v8 - 1];
    do
    {
      *v17-- = v16;
      v16 >>= 8;
      --v8;
    }

    while (v8);
  }

  return result;
}

unint64_t ccn_write_uint_public_value( unint64_t a1, unint64_t *a2, unint64_t a3, uint64_t a4)
{
  unint64_t result = ccn_bitlen_public_value(a1, a2);
  unint64_t v9 = (result + 7) >> 3;
  if (v9 >= a3) {
    unint64_t v10 = a3;
  }
  else {
    unint64_t v10 = (result + 7) >> 3;
  }
  uint64_t v11 = a4 + v10;
  unint64_t v12 = v9 - v10;
  unint64_t v13 = v12 >> 3;
  unint64_t v14 = v12 & 7;
  unint64_t v15 = a2[v12 >> 3] >> (8 * (v12 & 7u));
  if (v10 >= 8)
  {
    do
    {
      unint64_t v16 = v10 - 8;
      unint64_t v17 = v14 - 8;
      do
      {
        *(_BYTE *)--uint64_t v11 = v15;
        v15 >>= 8;
      }

      while (!__CFADD__(v17++, 1LL));
      if (v13 + 1 < a1) {
        unint64_t v15 = a2[++v13];
      }
      unint64_t v10 = v16 + v14;
      unint64_t v14 = 0LL;
    }

    while (v10 > 7);
  }

  if (v10)
  {
    uint64_t v19 = (_BYTE *)(v11 - 1);
    do
    {
      *v19-- = v15;
      v15 >>= 8;
      --v10;
    }

    while (v10);
  }

  return result;
}

BOOL ccn_add1_asm(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  if (!a1) {
    return a4;
  }
  uint64_t v5 = *a3;
  unint64_t v4 = a3 + 1;
  BOOL v6 = __CFADD__(v5, a4);
  *a2 = v5 + a4;
  for (uint64_t i = a2 + 1; --a1; ++i)
  {
    uint64_t v8 = *v4++;
    BOOL v9 = v6;
    BOOL v6 = __CFADD__(v6, v8);
    void *i = v9 + v8;
  }

  return v6;
}

uint64_t ccn_cond_neg(uint64_t a1, char a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = ccn_mux_next_mask();
  uint64_t v9 = __ROR8__(0x5555555555555555LL, a2 | (2 * result));
  if (a1)
  {
    BOOL v10 = 1LL;
    do
    {
      uint64_t v12 = *a4++;
      uint64_t v11 = v12;
      BOOL v13 = v10 + ~v12;
      BOOL v10 = __CFADD__(v10, ~v12);
      uint64_t v14 = v11 ^ v13;
      uint64_t v15 = v11 ^ result;
      *a3 = v15;
      *a3++ = v14 & v9 ^ v14 & 0x5555555555555555LL ^ v15 ^ result;
      --a1;
    }

    while (a1);
  }

  return result;
}

unint64_t ccec_compressed_x962_export_pub_size(uint64_t a1)
{
  return ((unint64_t)(cczp_bitlen(a1) + 7) >> 3) + 1;
}

uint64_t ccec_compressed_x962_export_pub(uint64_t *a1, char *a2)
{
  uint64_t v3 = (unint64_t *)(a1 + 2);
  unint64_t v4 = (unint64_t *)*a1;
  unint64_t v6 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 3) + 1;
  return ccec_export_affine_point_public_value(v4, 3, v3, &v6, a2);
}

uint64_t sizeof_cc_unit()
{
  return 8LL;
}

BOOL ccec_validate_pub(uint64_t **a1)
{
  BOOL v19 = timingsafe_enable_if_supported();
  unint64_t v2 = *a1;
  uint64_t v3 = **a1;
  unint64_t v4 = sizeof_cc_unit();
  unint64_t v5 = 5 * v3 + (v4 + 7) / v4 + 3;
  if (v5 <= 7 * v3) {
    unint64_t v5 = 7 * v3;
  }
  unint64_t v6 = cc_malloc_clear(8 * (v5 + 3 * v3));
  v15[0] = v6;
  uint64_t v7 = *v2;
  unint64_t v8 = sizeof_cc_unit();
  unint64_t v9 = 5 * v7 + (v8 + 7) / v8 + 3;
  if (v9 <= 7 * v7) {
    unint64_t v9 = 7 * v7;
  }
  v15[1] = v9 + 3 * v7;
  uint64_t v16 = 0LL;
  unint64_t v17 = cc_ws_alloc;
  uint64_t v18 = cc_ws_free;
  if (v6)
  {
    BOOL v10 = *a1;
    uint64_t v11 = cc_ws_alloc(v15, 3 * **a1);
    int v12 = ccec_validate_point_and_projectify_ws((uint64_t)v15, v10, v11, (uint64_t)(a1 + 2));
    uint64_t v16 = 0LL;
    v18((uint64_t)v15);
    BOOL v13 = v12 == 0;
  }

  else
  {
    BOOL v13 = 0LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v19);
  return v13;
}

uint64_t cc_lock_init(_DWORD *a1)
{
  *a1 = 0;
  return 0LL;
}

uint64_t cccmac_final_generate_internal(char *__s, size_t a2, void *a3)
{
  __src[0] = 0LL;
  __src[1] = 0LL;
  unint64_t v4 = (void *)*((void *)__s + 8);
  unint64_t v5 = *((void *)__s + 6);
  unint64_t v6 = *((void *)__s + 7) + v5;
  *((void *)__s + 7) = v6;
  if (v5 > 0x10)
  {
    uint64_t v10 = 0xFFFFFFFFLL;
  }

  else
  {
    if (v5) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = v6 == 0;
    }
    char v9 = !v8;
    uint64_t v10 = 0xFFFFFFFFLL;
    if (a2 - 17 >= 0xFFFFFFFFFFFFFFF0LL && (v9 & 1) == 0)
    {
      int v12 = __s + 32;
      BOOL v13 = __s;
      if (v5 != 16)
      {
        BOOL v13 = __s + 16;
        uint64_t v14 = &v12[v5];
        cc_clear(16 - v5, &v12[v5]);
        char *v14 = 0x80;
      }

      for (uint64_t i = 0LL; i != -16; --i)
        __s[i + 47] ^= v13[i + 15];
      cccbc_update_internal( (uint64_t)v4,  (uint64_t)(__s + 72),  (uint64_t)&__s[*v4 + 72],  1LL,  (uint64_t)(__s + 32),  (uint64_t)__src);
      memcpy(a3, __src, a2);
      uint64_t v10 = 0LL;
      unint64_t v4 = (void *)*((void *)__s + 8);
    }
  }

  cc_clear(v4[1] + *v4 + 80LL, __s);
  return v10;
}

uint64_t cccmac_final_generate(char *a1, size_t a2, void *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t internal = cccmac_final_generate_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return internal;
}

uint64_t ccder_encode_eckey_internal( uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, const void *a5, uint64_t a6, uint64_t a7)
{
  if (!a7) {
    return 0LL;
  }
  uint64_t v8 = a6;
  uint64_t v9 = a7;
  else {
    return 0LL;
  }
}

unsigned __int8 *ccder_decode_eckey_internal( unint64_t *a1, void *a2, void *a3, unsigned __int8 **a4, unint64_t *a5, void *a6, unsigned __int8 *a7, unsigned __int8 *a8)
{
  v10[0] = a7;
  v10[1] = a8;
  uint64_t v9 = 0LL;
  else {
    return 0LL;
  }
}

unint64_t ccn_subn(uint64_t a1, void *a2, uint64_t *a3, BOOL a4, unint64_t *a5)
{
  uint64_t v5 = a1 - a4;
  unint64_t v6 = &a2[a4];
  uint64_t v7 = (unint64_t *)&a3[a4];
  unint64_t v8 = ccn_sub_ws(0LL, a4, a2, a3, a5);
  return ccn_sub1(v5, v6, v7, v8);
}

uint64_t ccaes_vng_gcm_encrypt( uint64_t a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4, double a5, double a6, double a7, double a8, double a9, int8x16_t a10)
{
  uint64_t v14 = *(void *)(a1 + 96);
  ccmode_gcm_aad_finalize(a1, a5, a6, a7, a8, a9, a10);
  if (*(_WORD *)(a1 + 80) != 3) {
    return 4294967228LL;
  }
  uint64_t v23 = *(void *)(a1 + 96);
  uint64_t result = 4294967229LL;
  if (!__CFADD__(v23, a2) && v23 + a2 <= 0xFFFFFFFE0LL)
  {
    unsigned int v25 = v14 & 0xF;
    if ((v14 & 0xF) != 0)
    {
      uint64_t v26 = 16 - v25;
      if (a2 < v26)
      {
LABEL_19:
        if (!a2) {
          return 0LL;
        }
        uint64_t v40 = v25;
        uint64_t v41 = &a4[-1].i8[15];
        uint64_t v42 = a1 + v25 + 63;
        unint64_t v43 = a2;
        do
        {
          v41[v43] = *(_BYTE *)(v42 + v43) ^ a3[-1].i8[v43 + 15];
          --v43;
        }

        while (v43);
        uint64_t v44 = v40 + a1 + 15;
        unint64_t v45 = a2;
        do
        {
          *(_BYTE *)(v44 + v45) ^= v41[v45];
          --v45;
        }

        while (v45);
        uint64_t result = 0LL;
        *(void *)(a1 + 96) += a2;
        return result;
      }

      uint64_t v27 = &a4[-1].i8[15];
      uint64_t v28 = v26;
      do
      {
        v27[v28] = *(_BYTE *)((v14 & 0xF) + a1 + 63 + v28) ^ a3[-1].i8[v28 + 15];
        --v28;
      }

      while (v28);
      uint64_t v29 = v26;
      do
      {
        *(_BYTE *)((v14 & 0xF) + a1 + 15 + v29) ^= v27[v29];
        --v29;
      }

      while (v29);
      ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), v17, v18, v19, v20, v21, v22);
      a2 -= v26;
      a3 = (int8x16_t *)((char *)a3 + v26);
      a4 = (int8x16_t *)((char *)a4 + v26);
      *(void *)(a1 + 96) += v26;
      ccmode_gcm_update_pad(a1);
    }

    if (a2 >= 0x10)
    {
      gcmEncrypt( a3,  a4,  (int8x16_t *)a1,  a2 & 0xFFFFFFF0,  (uint64x2_t *)(a1 + 128),  *(void *)(a1 + 112),  v15,  v16,  v46,  v47);
      uint64_t v30 = a2 & 0xFFFFFFF0;
      a2 &= 0xFFFFFFFF0000000FLL;
      a3 = (int8x16_t *)((char *)a3 + v30);
      a4 = (int8x16_t *)((char *)a4 + v30);
      uint64_t v31 = *(void *)(a1 + 104);
      *(void *)(a1 + 96) += v30;
      (*(void (**)(void, uint64_t, uint64_t, uint64_t))(v31 + 24))( *(void *)(a1 + 112),  1LL,  a1 + 32,  a1 + 64);
      if (a2 >= 0x10)
      {
        do
        {
          for (uint64_t i = 0LL; i != -16; --i)
            a4->i8[i + 15] = *(_BYTE *)(a1 + i + 79) ^ a3->i8[i + 15];
          for (uint64_t j = 0LL; j != -16; --j)
            *(_BYTE *)(a1 + j + 31) ^= a4->u8[j + 15];
          ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), v32, v33, v34, v35, v36, v37);
          a2 -= 16LL;
          ++a3;
          ++a4;
          *(void *)(a1 + 96) += 16LL;
          ccmode_gcm_update_pad(a1);
        }

        while (a2 > 0xF);
      }
    }

    unsigned int v25 = 0;
    goto LABEL_19;
  }

  return result;
}

uint64_t cc_fault_canary_set(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  for (unint64_t i = 0LL; i != 16; ++i)
    *(_BYTE *)(result + i) = *(_BYTE *)(a5 + i % a3) ^ *(_BYTE *)(a4 + i % a3) ^ *(_BYTE *)(a2 + i);
  if (a3 >= 0x11)
  {
    for (uint64_t j = 16LL; j != a3; ++j)
      *(_BYTE *)(result + (j & 0xF)) ^= *(_BYTE *)(a5 + j) ^ *(_BYTE *)(a4 + j);
  }

  return result;
}

uint64_t ccec_validate_scalar(void *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = cczp_prime((uint64_t)&a1[5 * *a1 + 4]);
  if ((ccn_cmp_public_value(v4, a2, v5) & 0x80000000) == 0) {
    return 0xFFFFFFFFLL;
  }
  if (ccn_n(*a1, a2)) {
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}

int32x4_t *AccelerateCrypto_SHA256_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v4 = *a3;
    int8x16_t v5 = a3[1];
    int8x16_t v6 = a3[2];
    int8x16_t v7 = a3[3];
    uint64_t v3 = a3 + 4;
    _Q1 = (int32x4_t)vrev32q_s8(v5);
    int32x4_t v9 = *result;
    _Q2 = (int32x4_t)vrev32q_s8(v6);
    _Q17 = result[1];
    _Q3 = (int32x4_t)vrev32q_s8(v7);
    _Q18 = *result;
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v4), (int32x4_t)K256);
    _Q5 = vaddq_s32(_Q1, (int32x4_t)xmmword_2061A0);
    _Q19 = _Q17;
    _Q6 = vaddq_s32(_Q2, (int32x4_t)xmmword_2061B0);
    _Q7 = vaddq_s32(_Q3, (int32x4_t)xmmword_2061C0);
    double v19 = &xmmword_2061D0;
    int v20 = 3;
    do
    {
      _Q20 = _Q18;
      int32x4_t v22 = (int32x4_t)*v19;
      __asm { SHA256SU0       V0.4S, V1.4S }

      int32x4_t v28 = (int32x4_t)v19[1];
      __asm { SHA256H         Q18, Q19, V4.4S }

      int32x4_t v30 = (int32x4_t)v19[2];
      __asm { SHA256SU1       V0.4S, V2.4S, V3.4S }

      int32x4_t v32 = (int32x4_t)v19[3];
      __asm { SHA256H2        Q19, Q20, V4.4S }

      v19 += 4;
      _Q4 = vaddq_s32(_Q0, v22);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V1.4S, V2.4S
        SHA256H         Q18, Q19, V5.4S
        SHA256SU1       V1.4S, V3.4S, V0.4S
        SHA256H2        Q19, Q20, V5.4S
      }

      _Q5 = vaddq_s32(_Q1, v28);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V2.4S, V3.4S
        SHA256H         Q18, Q19, V6.4S
        SHA256SU1       V2.4S, V0.4S, V1.4S
        SHA256H2        Q19, Q20, V6.4S
      }

      _Q6 = vaddq_s32(_Q2, v30);
      --v20;
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V3.4S, V0.4S
        SHA256H         Q18, Q19, V7.4S
        SHA256SU1       V3.4S, V1.4S, V2.4S
        SHA256H2        Q19, Q20, V7.4S
      }

      _Q7 = vaddq_s32(_Q3, v32);
    }

    while (!(_NF ^ _VF | _ZF));
    BOOL v44 = a2 <= 1;
    uint64_t v45 = a2 - 1;
    if (!v44)
    {
      uint64_t v46 = (int32x4_t *)(v19 - 16);
      do
      {
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V4.4S }

        int8x16_t v49 = v3[1];
        int8x16_t v50 = v3[2];
        __asm { SHA256H2        Q19, Q20, V4.4S }

        int8x16_t v52 = v3[3];
        _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(*v3), *v46);
        _Q20 = _Q18;
        v3 += 4;
        __asm { SHA256H         Q18, Q19, V5.4S }

        _Q1 = (int32x4_t)vrev32q_s8(v49);
        __asm { SHA256H2        Q19, Q20, V5.4S }

        _Q5 = vaddq_s32(_Q1, v46[1]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V6.4S }

        _Q2 = (int32x4_t)vrev32q_s8(v50);
        __asm { SHA256H2        Q19, Q20, V6.4S }

        _Q6 = vaddq_s32(_Q2, v46[2]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V7.4S }

        _Q3 = (int32x4_t)vrev32q_s8(v52);
        __asm { SHA256H2        Q19, Q20, V7.4S }

        _Q7 = vaddq_s32(_Q3, v46[3]);
        int32x4_t v9 = vaddq_s32(v9, _Q18);
        _Q17 = vaddq_s32(_Q17, _Q19);
        _Q20 = v9;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }

        _Q4 = vaddq_s32(_Q0, v46[4]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }

        _Q5 = vaddq_s32(_Q1, v46[5]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }

        _Q6 = vaddq_s32(_Q2, v46[6]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }

        _Q7 = vaddq_s32(_Q3, v46[7]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }

        _Q4 = vaddq_s32(_Q0, v46[8]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }

        _Q5 = vaddq_s32(_Q1, v46[9]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }

        _Q6 = vaddq_s32(_Q2, v46[10]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }

        _Q7 = vaddq_s32(_Q3, v46[11]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }

        _Q4 = vaddq_s32(_Q0, v46[12]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }

        _Q5 = vaddq_s32(_Q1, v46[13]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }

        _Q6 = vaddq_s32(_Q2, v46[14]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }

        _Q7 = vaddq_s32(_Q3, v46[15]);
        BOOL v44 = v45-- <= 1;
      }

      while (!v44);
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V4.4S
      SHA256H2        Q19, Q20, V4.4S
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V5.4S
      SHA256H2        Q19, Q20, V5.4S
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V6.4S
      SHA256H2        Q19, Q20, V6.4S
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V7.4S
      SHA256H2        Q19, Q20, V7.4S
    }

    *uint64_t result = vaddq_s32(v9, _Q18);
    result[1] = vaddq_s32(_Q17, _Q19);
  }

  return result;
}

uint64_t *AccelerateCrypto_SHA512_compress(uint64_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v4 = *a3;
    uint64_t v3 = a3 + 8;
    int64x2_t v5 = (int64x2_t)vrev64q_s8(v4);
    int64x2_t v6 = (int64x2_t)vrev64q_s8(v3[-7]);
    int64x2_t v7 = (int64x2_t)vrev64q_s8(v3[-6]);
    int64x2_t v8 = (int64x2_t)vrev64q_s8(v3[-5]);
    int64x2_t v9 = (int64x2_t)vrev64q_s8(v3[-4]);
    int64x2_t v10 = (int64x2_t)vrev64q_s8(v3[-3]);
    int64x2_t v11 = (int64x2_t)vrev64q_s8(v3[-2]);
    int64x2_t v12 = (int64x2_t)vrev64q_s8(v3[-1]);
    i8 = &xmmword_2800B0;
    int64x2_t v240 = vaddq_s64((int64x2_t)sha512_K, v5);
    int64x2_t v241 = vaddq_s64(unk_280040, v6);
    int64x2_t v242 = vaddq_s64(unk_280050, v7);
    int64x2_t v243 = vaddq_s64(unk_280060, v8);
    int64x2_t v244 = vaddq_s64((int64x2_t)xmmword_280070, v9);
    int64x2_t v245 = vaddq_s64(unk_280080, v10);
    int64x2_t v246 = vaddq_s64(unk_280090, v11);
    int64x2_t v247 = vaddq_s64(unk_2800A0, v12);
    while (1)
    {
      uint64_t v14 = *result;
      uint64_t v15 = result[1];
      uint64_t v16 = result[2];
      uint64_t v17 = result[3];
      uint64_t v18 = result[4];
      uint64_t v19 = result[5];
      uint64_t v20 = result[6];
      uint64_t v21 = result[7];
      int v22 = 4;
      do
      {
        int64x2_t v23 = (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
        int8x16_t v24 = (int8x16_t)vshrq_n_u64((uint64x2_t)v12, 0x13uLL);
        int64x2_t v25 = vshlq_n_s64(v12, 3uLL);
        uint64_t v26 = v21
            + v240.i64[0]
            + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41))
            + ((v19 ^ v20) & v18 ^ v20);
        int8x16_t v27 = (int8x16_t)vshrq_n_u64((uint64x2_t)v23, 1uLL);
        int64x2_t v28 = vshlq_n_s64(v23, 0x38uLL);
        uint64_t v29 = v17 + v26;
        uint64_t v30 = v26 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
        int8x16_t v31 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v12, 6uLL), v24), (int8x16_t)v25),  (int8x16_t)vshrq_n_u64((uint64x2_t)v24, 0x2AuLL));
        int64x2_t v32 = (int64x2_t)*i8;
        double v33 = (int64x2_t *)(i8 + 1);
        int64x2_t v5 = vaddq_s64( vaddq_s64( vaddq_s64(v5, (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL)),  (int64x2_t)veorq_s8(v31, (int8x16_t)vshlq_n_s64(v25, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v23, 7uLL), v27), (int8x16_t)v28),  (int8x16_t)vshrq_n_u64((uint64x2_t)v27, 7uLL)),  (int8x16_t)vshlq_n_s64(v28, 7uLL)));
        uint64_t v34 = v20
            + v240.i64[1]
            + (__ROR8__(v29, 14) ^ __ROR8__(v29, 18) ^ __ROR8__(v29, 41))
            + ((v18 ^ v19) & v29 ^ v19);
        uint64_t v35 = v16 + v34;
        uint64_t v36 = v34 + (__ROR8__(v30, 28) ^ __ROR8__(v30, 34) ^ __ROR8__(v30, 39)) + ((v14 ^ v15) & v30 ^ v14 & v15);
        int64x2_t v240 = vaddq_s64(v32, v5);
        int64x2_t v37 = (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL);
        int8x16_t v38 = (int8x16_t)vshrq_n_u64((uint64x2_t)v5, 0x13uLL);
        int64x2_t v39 = vshlq_n_s64(v5, 3uLL);
        uint64_t v40 = v19
            + v241.i64[0]
            + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41))
            + ((v29 ^ v18) & v35 ^ v18);
        int8x16_t v41 = (int8x16_t)vshrq_n_u64((uint64x2_t)v37, 1uLL);
        int64x2_t v42 = vshlq_n_s64(v37, 0x38uLL);
        uint64_t v43 = v15 + v40;
        uint64_t v44 = v40 + (__ROR8__(v36, 28) ^ __ROR8__(v36, 34) ^ __ROR8__(v36, 39)) + ((v30 ^ v14) & v36 ^ v30 & v14);
        int8x16_t v45 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v5, 6uLL), v38), (int8x16_t)v39),  (int8x16_t)vshrq_n_u64((uint64x2_t)v38, 0x2AuLL));
        int64x2_t v46 = *v33++;
        int64x2_t v6 = vaddq_s64( vaddq_s64( vaddq_s64(v6, (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL)),  (int64x2_t)veorq_s8(v45, (int8x16_t)vshlq_n_s64(v39, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v37, 7uLL), v41), (int8x16_t)v42),  (int8x16_t)vshrq_n_u64((uint64x2_t)v41, 7uLL)),  (int8x16_t)vshlq_n_s64(v42, 7uLL)));
        uint64_t v47 = v18
            + v241.i64[1]
            + (__ROR8__(v43, 14) ^ __ROR8__(v43, 18) ^ __ROR8__(v43, 41))
            + ((v35 ^ v29) & v43 ^ v29);
        uint64_t v48 = v14 + v47;
        uint64_t v49 = v47 + (__ROR8__(v44, 28) ^ __ROR8__(v44, 34) ^ __ROR8__(v44, 39)) + ((v36 ^ v30) & v44 ^ v36 & v30);
        int64x2_t v241 = vaddq_s64(v46, v6);
        int64x2_t v50 = (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL);
        int8x16_t v51 = (int8x16_t)vshrq_n_u64((uint64x2_t)v6, 0x13uLL);
        int64x2_t v52 = vshlq_n_s64(v6, 3uLL);
        uint64_t v53 = v29
            + v242.i64[0]
            + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41))
            + ((v43 ^ v35) & v48 ^ v35);
        int8x16_t v54 = (int8x16_t)vshrq_n_u64((uint64x2_t)v50, 1uLL);
        int64x2_t v55 = vshlq_n_s64(v50, 0x38uLL);
        uint64_t v56 = v30 + v53;
        uint64_t v57 = v53 + (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + ((v44 ^ v36) & v49 ^ v44 & v36);
        int8x16_t v58 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v6, 6uLL), v51), (int8x16_t)v52),  (int8x16_t)vshrq_n_u64((uint64x2_t)v51, 0x2AuLL));
        int64x2_t v59 = *v33++;
        int64x2_t v7 = vaddq_s64( vaddq_s64( vaddq_s64(v7, (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL)),  (int64x2_t)veorq_s8(v58, (int8x16_t)vshlq_n_s64(v52, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v50, 7uLL), v54), (int8x16_t)v55),  (int8x16_t)vshrq_n_u64((uint64x2_t)v54, 7uLL)),  (int8x16_t)vshlq_n_s64(v55, 7uLL)));
        uint64_t v60 = v35
            + v242.i64[1]
            + (__ROR8__(v56, 14) ^ __ROR8__(v56, 18) ^ __ROR8__(v56, 41))
            + ((v48 ^ v43) & v56 ^ v43);
        uint64_t v61 = v36 + v60;
        uint64_t v62 = v60 + (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + ((v49 ^ v44) & v57 ^ v49 & v44);
        int64x2_t v242 = vaddq_s64(v59, v7);
        int64x2_t v63 = (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL);
        int8x16_t v64 = (int8x16_t)vshrq_n_u64((uint64x2_t)v7, 0x13uLL);
        int64x2_t v65 = vshlq_n_s64(v7, 3uLL);
        uint64_t v66 = v43
            + v243.i64[0]
            + (__ROR8__(v61, 14) ^ __ROR8__(v61, 18) ^ __ROR8__(v61, 41))
            + ((v56 ^ v48) & v61 ^ v48);
        int8x16_t v67 = (int8x16_t)vshrq_n_u64((uint64x2_t)v63, 1uLL);
        int64x2_t v68 = vshlq_n_s64(v63, 0x38uLL);
        uint64_t v69 = v44 + v66;
        uint64_t v70 = v66 + (__ROR8__(v62, 28) ^ __ROR8__(v62, 34) ^ __ROR8__(v62, 39)) + ((v57 ^ v49) & v62 ^ v57 & v49);
        int8x16_t v71 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v7, 6uLL), v64), (int8x16_t)v65),  (int8x16_t)vshrq_n_u64((uint64x2_t)v64, 0x2AuLL));
        int64x2_t v72 = *v33++;
        int64x2_t v8 = vaddq_s64( vaddq_s64( vaddq_s64(v8, (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL)),  (int64x2_t)veorq_s8(v71, (int8x16_t)vshlq_n_s64(v65, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v63, 7uLL), v67), (int8x16_t)v68),  (int8x16_t)vshrq_n_u64((uint64x2_t)v67, 7uLL)),  (int8x16_t)vshlq_n_s64(v68, 7uLL)));
        uint64_t v73 = v48
            + v243.i64[1]
            + (__ROR8__(v69, 14) ^ __ROR8__(v69, 18) ^ __ROR8__(v69, 41))
            + ((v61 ^ v56) & v69 ^ v56);
        uint64_t v74 = v49 + v73;
        uint64_t v75 = v73 + (__ROR8__(v70, 28) ^ __ROR8__(v70, 34) ^ __ROR8__(v70, 39)) + ((v62 ^ v57) & v70 ^ v62 & v57);
        int64x2_t v243 = vaddq_s64(v72, v8);
        int64x2_t v76 = (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL);
        int8x16_t v77 = (int8x16_t)vshrq_n_u64((uint64x2_t)v8, 0x13uLL);
        int64x2_t v78 = vshlq_n_s64(v8, 3uLL);
        uint64_t v79 = v56
            + v244.i64[0]
            + (__ROR8__(v74, 14) ^ __ROR8__(v74, 18) ^ __ROR8__(v74, 41))
            + ((v69 ^ v61) & v74 ^ v61);
        int8x16_t v80 = (int8x16_t)vshrq_n_u64((uint64x2_t)v76, 1uLL);
        int64x2_t v81 = vshlq_n_s64(v76, 0x38uLL);
        uint64_t v82 = v57 + v79;
        uint64_t v83 = v79 + (__ROR8__(v75, 28) ^ __ROR8__(v75, 34) ^ __ROR8__(v75, 39)) + ((v70 ^ v62) & v75 ^ v70 & v62);
        int8x16_t v84 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v8, 6uLL), v77), (int8x16_t)v78),  (int8x16_t)vshrq_n_u64((uint64x2_t)v77, 0x2AuLL));
        int64x2_t v85 = *v33++;
        int64x2_t v9 = vaddq_s64( vaddq_s64( vaddq_s64(v9, (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL)),  (int64x2_t)veorq_s8(v84, (int8x16_t)vshlq_n_s64(v78, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v76, 7uLL), v80), (int8x16_t)v81),  (int8x16_t)vshrq_n_u64((uint64x2_t)v80, 7uLL)),  (int8x16_t)vshlq_n_s64(v81, 7uLL)));
        uint64_t v86 = v61
            + v244.i64[1]
            + (__ROR8__(v82, 14) ^ __ROR8__(v82, 18) ^ __ROR8__(v82, 41))
            + ((v74 ^ v69) & v82 ^ v69);
        uint64_t v87 = v62 + v86;
        uint64_t v88 = v86 + (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39)) + ((v75 ^ v70) & v83 ^ v75 & v70);
        int64x2_t v244 = vaddq_s64(v85, v9);
        int64x2_t v89 = (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL);
        int8x16_t v90 = (int8x16_t)vshrq_n_u64((uint64x2_t)v9, 0x13uLL);
        int64x2_t v91 = vshlq_n_s64(v9, 3uLL);
        uint64_t v92 = v69
            + v245.i64[0]
            + (__ROR8__(v87, 14) ^ __ROR8__(v87, 18) ^ __ROR8__(v87, 41))
            + ((v82 ^ v74) & v87 ^ v74);
        int8x16_t v93 = (int8x16_t)vshrq_n_u64((uint64x2_t)v89, 1uLL);
        int64x2_t v94 = vshlq_n_s64(v89, 0x38uLL);
        uint64_t v95 = v70 + v92;
        uint64_t v96 = v92 + (__ROR8__(v88, 28) ^ __ROR8__(v88, 34) ^ __ROR8__(v88, 39)) + ((v83 ^ v75) & v88 ^ v83 & v75);
        int8x16_t v97 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v9, 6uLL), v90), (int8x16_t)v91),  (int8x16_t)vshrq_n_u64((uint64x2_t)v90, 0x2AuLL));
        int64x2_t v98 = *v33++;
        int64x2_t v10 = vaddq_s64( vaddq_s64( vaddq_s64(v10, (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL)),  (int64x2_t)veorq_s8(v97, (int8x16_t)vshlq_n_s64(v91, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v89, 7uLL), v93), (int8x16_t)v94),  (int8x16_t)vshrq_n_u64((uint64x2_t)v93, 7uLL)),  (int8x16_t)vshlq_n_s64(v94, 7uLL)));
        uint64_t v99 = v74
            + v245.i64[1]
            + (__ROR8__(v95, 14) ^ __ROR8__(v95, 18) ^ __ROR8__(v95, 41))
            + ((v87 ^ v82) & v95 ^ v82);
        uint64_t v100 = v75 + v99;
        uint64_t v101 = v99 + (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + ((v88 ^ v83) & v96 ^ v88 & v83);
        int64x2_t v245 = vaddq_s64(v98, v10);
        int64x2_t v102 = (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL);
        int8x16_t v103 = (int8x16_t)vshrq_n_u64((uint64x2_t)v10, 0x13uLL);
        int64x2_t v104 = vshlq_n_s64(v10, 3uLL);
        uint64_t v105 = v82
             + v246.i64[0]
             + (__ROR8__(v100, 14) ^ __ROR8__(v100, 18) ^ __ROR8__(v100, 41))
             + ((v95 ^ v87) & v100 ^ v87);
        int8x16_t v106 = (int8x16_t)vshrq_n_u64((uint64x2_t)v102, 1uLL);
        int64x2_t v107 = vshlq_n_s64(v102, 0x38uLL);
        uint64_t v21 = v83 + v105;
        uint64_t v17 = v105 + (__ROR8__(v101, 28) ^ __ROR8__(v101, 34) ^ __ROR8__(v101, 39)) + ((v96 ^ v88) & v101 ^ v96 & v88);
        int8x16_t v108 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v10, 6uLL), v103), (int8x16_t)v104),  (int8x16_t)vshrq_n_u64((uint64x2_t)v103, 0x2AuLL));
        int64x2_t v109 = *v33++;
        int64x2_t v11 = vaddq_s64( vaddq_s64( vaddq_s64(v11, (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL)),  (int64x2_t)veorq_s8(v108, (int8x16_t)vshlq_n_s64(v104, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v102, 7uLL), v106), (int8x16_t)v107),  (int8x16_t)vshrq_n_u64((uint64x2_t)v106, 7uLL)),  (int8x16_t)vshlq_n_s64(v107, 7uLL)));
        uint64_t v110 = v87
             + v246.i64[1]
             + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41))
             + ((v100 ^ v95) & v21 ^ v95);
        uint64_t v20 = v88 + v110;
        uint64_t v16 = v110 + (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + ((v101 ^ v96) & v17 ^ v101 & v96);
        int64x2_t v246 = vaddq_s64(v109, v11);
        int64x2_t v111 = (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL);
        int8x16_t v112 = (int8x16_t)vshrq_n_u64((uint64x2_t)v11, 0x13uLL);
        int64x2_t v113 = vshlq_n_s64(v11, 3uLL);
        uint64_t v114 = v95
             + v247.i64[0]
             + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41))
             + ((v21 ^ v100) & v20 ^ v100);
        int8x16_t v115 = (int8x16_t)vshrq_n_u64((uint64x2_t)v111, 1uLL);
        int64x2_t v116 = vshlq_n_s64(v111, 0x38uLL);
        uint64_t v19 = v96 + v114;
        uint64_t v15 = v114 + (__ROR8__(v16, 28) ^ __ROR8__(v16, 34) ^ __ROR8__(v16, 39)) + ((v17 ^ v101) & v16 ^ v17 & v101);
        int8x16_t v117 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v11, 6uLL), v112), (int8x16_t)v113),  (int8x16_t)vshrq_n_u64((uint64x2_t)v112, 0x2AuLL));
        int64x2_t v118 = *v33;
        i8 = (__int128 *)v33[1].i8;
        int64x2_t v12 = vaddq_s64( vaddq_s64( vaddq_s64(v12, (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL)),  (int64x2_t)veorq_s8(v117, (int8x16_t)vshlq_n_s64(v113, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v111, 7uLL), v115), (int8x16_t)v116),  (int8x16_t)vshrq_n_u64((uint64x2_t)v115, 7uLL)),  (int8x16_t)vshlq_n_s64(v116, 7uLL)));
        uint64_t v119 = v100
             + v247.i64[1]
             + (__ROR8__(v19, 14) ^ __ROR8__(v19, 18) ^ __ROR8__(v19, 41))
             + ((v20 ^ v21) & v19 ^ v21);
        uint64_t v18 = v101 + v119;
        uint64_t v14 = v119 + (__ROR8__(v15, 28) ^ __ROR8__(v15, 34) ^ __ROR8__(v15, 39)) + ((v16 ^ v17) & v15 ^ v16 & v17);
        int64x2_t v247 = vaddq_s64(v118, v12);
        BOOL v120 = __OFSUB__(v22--, 1);
      }

      while (!((v22 < 0) ^ v120 | (v22 == 0)));
      int8x16_t v121 = i8 - 40;
      if (!--a2) {
        break;
      }
      int8x16_t v123 = *v3;
      int8x16_t v122 = v3 + 1;
      uint64_t v124 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
      int64x2_t v126 = (int64x2_t)*v121;
      int8x16_t v125 = (int64x2_t *)(v121 + 1);
      uint64_t v127 = v17 + v124;
      uint64_t v128 = v124 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
      int64x2_t v5 = (int64x2_t)vrev64q_s8(v123);
      uint64_t v129 = v20
           + v240.i64[1]
           + (__ROR8__(v127, 14) ^ __ROR8__(v127, 18) ^ __ROR8__(v127, 41))
           + ((v18 ^ v19) & v127 ^ v19);
      uint64_t v130 = v16 + v129;
      int64x2_t v240 = vaddq_s64(v126, v5);
      uint64_t v131 = v129 + (__ROR8__(v128, 28) ^ __ROR8__(v128, 34) ^ __ROR8__(v128, 39)) + ((v14 ^ v15) & v128 ^ v14 & v15);
      int8x16_t v132 = *v122++;
      uint64_t v133 = v19
           + v241.i64[0]
           + (__ROR8__(v130, 14) ^ __ROR8__(v130, 18) ^ __ROR8__(v130, 41))
           + ((v127 ^ v18) & v130 ^ v18);
      int64x2_t v134 = *v125++;
      uint64_t v135 = v15 + v133;
      uint64_t v136 = v133 + (__ROR8__(v131, 28) ^ __ROR8__(v131, 34) ^ __ROR8__(v131, 39)) + ((v128 ^ v14) & v131 ^ v128 & v14);
      int64x2_t v6 = (int64x2_t)vrev64q_s8(v132);
      uint64_t v137 = v18
           + v241.i64[1]
           + (__ROR8__(v135, 14) ^ __ROR8__(v135, 18) ^ __ROR8__(v135, 41))
           + ((v130 ^ v127) & v135 ^ v127);
      uint64_t v138 = v14 + v137;
      int64x2_t v241 = vaddq_s64(v134, v6);
      uint64_t v139 = v137
           + (__ROR8__(v136, 28) ^ __ROR8__(v136, 34) ^ __ROR8__(v136, 39))
           + ((v131 ^ v128) & v136 ^ v131 & v128);
      int8x16_t v140 = *v122++;
      uint64_t v141 = v127
           + v242.i64[0]
           + (__ROR8__(v138, 14) ^ __ROR8__(v138, 18) ^ __ROR8__(v138, 41))
           + ((v135 ^ v130) & v138 ^ v130);
      int64x2_t v142 = *v125++;
      uint64_t v143 = v128 + v141;
      uint64_t v144 = v141
           + (__ROR8__(v139, 28) ^ __ROR8__(v139, 34) ^ __ROR8__(v139, 39))
           + ((v136 ^ v131) & v139 ^ v136 & v131);
      int64x2_t v7 = (int64x2_t)vrev64q_s8(v140);
      uint64_t v145 = v130
           + v242.i64[1]
           + (__ROR8__(v143, 14) ^ __ROR8__(v143, 18) ^ __ROR8__(v143, 41))
           + ((v138 ^ v135) & v143 ^ v135);
      uint64_t v146 = v131 + v145;
      int64x2_t v242 = vaddq_s64(v142, v7);
      uint64_t v147 = v145
           + (__ROR8__(v144, 28) ^ __ROR8__(v144, 34) ^ __ROR8__(v144, 39))
           + ((v139 ^ v136) & v144 ^ v139 & v136);
      int8x16_t v148 = *v122++;
      uint64_t v149 = v135
           + v243.i64[0]
           + (__ROR8__(v146, 14) ^ __ROR8__(v146, 18) ^ __ROR8__(v146, 41))
           + ((v143 ^ v138) & v146 ^ v138);
      int64x2_t v150 = *v125++;
      uint64_t v151 = v136 + v149;
      uint64_t v152 = v149
           + (__ROR8__(v147, 28) ^ __ROR8__(v147, 34) ^ __ROR8__(v147, 39))
           + ((v144 ^ v139) & v147 ^ v144 & v139);
      int64x2_t v8 = (int64x2_t)vrev64q_s8(v148);
      uint64_t v153 = v138
           + v243.i64[1]
           + (__ROR8__(v151, 14) ^ __ROR8__(v151, 18) ^ __ROR8__(v151, 41))
           + ((v146 ^ v143) & v151 ^ v143);
      uint64_t v154 = v139 + v153;
      int64x2_t v243 = vaddq_s64(v150, v8);
      uint64_t v155 = v153
           + (__ROR8__(v152, 28) ^ __ROR8__(v152, 34) ^ __ROR8__(v152, 39))
           + ((v147 ^ v144) & v152 ^ v147 & v144);
      int8x16_t v156 = *v122++;
      uint64_t v157 = v143
           + v244.i64[0]
           + (__ROR8__(v154, 14) ^ __ROR8__(v154, 18) ^ __ROR8__(v154, 41))
           + ((v151 ^ v146) & v154 ^ v146);
      int64x2_t v158 = *v125++;
      uint64_t v159 = v144 + v157;
      uint64_t v160 = v157
           + (__ROR8__(v155, 28) ^ __ROR8__(v155, 34) ^ __ROR8__(v155, 39))
           + ((v152 ^ v147) & v155 ^ v152 & v147);
      int64x2_t v9 = (int64x2_t)vrev64q_s8(v156);
      uint64_t v161 = v146
           + v244.i64[1]
           + (__ROR8__(v159, 14) ^ __ROR8__(v159, 18) ^ __ROR8__(v159, 41))
           + ((v154 ^ v151) & v159 ^ v151);
      uint64_t v162 = v147 + v161;
      int64x2_t v244 = vaddq_s64(v158, v9);
      uint64_t v163 = v161
           + (__ROR8__(v160, 28) ^ __ROR8__(v160, 34) ^ __ROR8__(v160, 39))
           + ((v155 ^ v152) & v160 ^ v155 & v152);
      int8x16_t v164 = *v122++;
      uint64_t v165 = v151
           + v245.i64[0]
           + (__ROR8__(v162, 14) ^ __ROR8__(v162, 18) ^ __ROR8__(v162, 41))
           + ((v159 ^ v154) & v162 ^ v154);
      int64x2_t v166 = *v125++;
      uint64_t v167 = v152 + v165;
      uint64_t v168 = v165
           + (__ROR8__(v163, 28) ^ __ROR8__(v163, 34) ^ __ROR8__(v163, 39))
           + ((v160 ^ v155) & v163 ^ v160 & v155);
      int64x2_t v10 = (int64x2_t)vrev64q_s8(v164);
      uint64_t v169 = v154
           + v245.i64[1]
           + (__ROR8__(v167, 14) ^ __ROR8__(v167, 18) ^ __ROR8__(v167, 41))
           + ((v162 ^ v159) & v167 ^ v159);
      uint64_t v170 = v155 + v169;
      int64x2_t v245 = vaddq_s64(v166, v10);
      uint64_t v171 = v169
           + (__ROR8__(v168, 28) ^ __ROR8__(v168, 34) ^ __ROR8__(v168, 39))
           + ((v163 ^ v160) & v168 ^ v163 & v160);
      int8x16_t v172 = *v122++;
      uint64_t v173 = v159
           + v246.i64[0]
           + (__ROR8__(v170, 14) ^ __ROR8__(v170, 18) ^ __ROR8__(v170, 41))
           + ((v167 ^ v162) & v170 ^ v162);
      int64x2_t v174 = *v125++;
      uint64_t v175 = v160 + v173;
      uint64_t v176 = v173
           + (__ROR8__(v171, 28) ^ __ROR8__(v171, 34) ^ __ROR8__(v171, 39))
           + ((v168 ^ v163) & v171 ^ v168 & v163);
      int64x2_t v11 = (int64x2_t)vrev64q_s8(v172);
      uint64_t v177 = v162
           + v246.i64[1]
           + (__ROR8__(v175, 14) ^ __ROR8__(v175, 18) ^ __ROR8__(v175, 41))
           + ((v170 ^ v167) & v175 ^ v167);
      uint64_t v178 = v163 + v177;
      int64x2_t v246 = vaddq_s64(v174, v11);
      uint64_t v179 = v177
           + (__ROR8__(v176, 28) ^ __ROR8__(v176, 34) ^ __ROR8__(v176, 39))
           + ((v171 ^ v168) & v176 ^ v171 & v168);
      int8x16_t v180 = *v122;
      uint64_t v3 = v122 + 1;
      uint64_t v181 = v167
           + v247.i64[0]
           + (__ROR8__(v178, 14) ^ __ROR8__(v178, 18) ^ __ROR8__(v178, 41))
           + ((v175 ^ v170) & v178 ^ v170);
      int64x2_t v182 = *v125;
      i8 = (__int128 *)v125[1].i8;
      uint64_t v183 = v168 + v181;
      uint64_t v184 = v181
           + (__ROR8__(v179, 28) ^ __ROR8__(v179, 34) ^ __ROR8__(v179, 39))
           + ((v176 ^ v171) & v179 ^ v176 & v171);
      int64x2_t v12 = (int64x2_t)vrev64q_s8(v180);
      uint64_t v185 = v170
           + v247.i64[1]
           + (__ROR8__(v183, 14) ^ __ROR8__(v183, 18) ^ __ROR8__(v183, 41))
           + ((v178 ^ v175) & v183 ^ v175);
      int64x2_t v247 = vaddq_s64(v182, v12);
      uint64_t v186 = result[1] + v184;
      *result += v185
               + (__ROR8__(v184, 28) ^ __ROR8__(v184, 34) ^ __ROR8__(v184, 39))
               + ((v179 ^ v176) & v184 ^ v179 & v176);
      result[1] = v186;
      uint64_t v187 = result[3] + v176;
      result[2] += v179;
      result[3] = v187;
      uint64_t v188 = result[5] + v183;
      result[4] += v171 + v185;
      result[5] = v188;
      uint64_t v189 = result[7] + v175;
      result[6] += v178;
      result[7] = v189;
    }

    uint64_t v190 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
    uint64_t v191 = v17 + v190;
    uint64_t v192 = v190 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
    uint64_t v193 = v20
         + v240.i64[1]
         + (__ROR8__(v191, 14) ^ __ROR8__(v191, 18) ^ __ROR8__(v191, 41))
         + ((v18 ^ v19) & v191 ^ v19);
    uint64_t v194 = v16 + v193;
    uint64_t v195 = v193 + (__ROR8__(v192, 28) ^ __ROR8__(v192, 34) ^ __ROR8__(v192, 39)) + ((v14 ^ v15) & v192 ^ v14 & v15);
    uint64_t v196 = v19
         + v241.i64[0]
         + (__ROR8__(v194, 14) ^ __ROR8__(v194, 18) ^ __ROR8__(v194, 41))
         + ((v191 ^ v18) & v194 ^ v18);
    uint64_t v197 = v15 + v196;
    uint64_t v198 = v196 + (__ROR8__(v195, 28) ^ __ROR8__(v195, 34) ^ __ROR8__(v195, 39)) + ((v192 ^ v14) & v195 ^ v192 & v14);
    uint64_t v199 = v18
         + v241.i64[1]
         + (__ROR8__(v197, 14) ^ __ROR8__(v197, 18) ^ __ROR8__(v197, 41))
         + ((v194 ^ v191) & v197 ^ v191);
    uint64_t v200 = v14 + v199;
    uint64_t v201 = v199 + (__ROR8__(v198, 28) ^ __ROR8__(v198, 34) ^ __ROR8__(v198, 39)) + ((v195 ^ v192) & v198 ^ v195 & v192);
    uint64_t v202 = v191
         + v242.i64[0]
         + (__ROR8__(v200, 14) ^ __ROR8__(v200, 18) ^ __ROR8__(v200, 41))
         + ((v197 ^ v194) & v200 ^ v194);
    uint64_t v203 = v192 + v202;
    uint64_t v204 = v202 + (__ROR8__(v201, 28) ^ __ROR8__(v201, 34) ^ __ROR8__(v201, 39)) + ((v198 ^ v195) & v201 ^ v198 & v195);
    uint64_t v205 = v194
         + v242.i64[1]
         + (__ROR8__(v203, 14) ^ __ROR8__(v203, 18) ^ __ROR8__(v203, 41))
         + ((v200 ^ v197) & v203 ^ v197);
    uint64_t v206 = v195 + v205;
    uint64_t v207 = v205 + (__ROR8__(v204, 28) ^ __ROR8__(v204, 34) ^ __ROR8__(v204, 39)) + ((v201 ^ v198) & v204 ^ v201 & v198);
    uint64_t v208 = v197
         + v243.i64[0]
         + (__ROR8__(v206, 14) ^ __ROR8__(v206, 18) ^ __ROR8__(v206, 41))
         + ((v203 ^ v200) & v206 ^ v200);
    uint64_t v209 = v198 + v208;
    uint64_t v210 = v208 + (__ROR8__(v207, 28) ^ __ROR8__(v207, 34) ^ __ROR8__(v207, 39)) + ((v204 ^ v201) & v207 ^ v204 & v201);
    uint64_t v211 = v200
         + v243.i64[1]
         + (__ROR8__(v209, 14) ^ __ROR8__(v209, 18) ^ __ROR8__(v209, 41))
         + ((v206 ^ v203) & v209 ^ v203);
    uint64_t v212 = v201 + v211;
    uint64_t v213 = v211 + (__ROR8__(v210, 28) ^ __ROR8__(v210, 34) ^ __ROR8__(v210, 39)) + ((v207 ^ v204) & v210 ^ v207 & v204);
    uint64_t v214 = v203
         + v244.i64[0]
         + (__ROR8__(v212, 14) ^ __ROR8__(v212, 18) ^ __ROR8__(v212, 41))
         + ((v209 ^ v206) & v212 ^ v206);
    uint64_t v215 = v204 + v214;
    uint64_t v216 = v214 + (__ROR8__(v213, 28) ^ __ROR8__(v213, 34) ^ __ROR8__(v213, 39)) + ((v210 ^ v207) & v213 ^ v210 & v207);
    uint64_t v217 = v206
         + v244.i64[1]
         + (__ROR8__(v215, 14) ^ __ROR8__(v215, 18) ^ __ROR8__(v215, 41))
         + ((v212 ^ v209) & v215 ^ v209);
    uint64_t v218 = v207 + v217;
    uint64_t v219 = v217 + (__ROR8__(v216, 28) ^ __ROR8__(v216, 34) ^ __ROR8__(v216, 39)) + ((v213 ^ v210) & v216 ^ v213 & v210);
    uint64_t v220 = v209
         + v245.i64[0]
         + (__ROR8__(v218, 14) ^ __ROR8__(v218, 18) ^ __ROR8__(v218, 41))
         + ((v215 ^ v212) & v218 ^ v212);
    uint64_t v221 = v210 + v220;
    uint64_t v222 = v220 + (__ROR8__(v219, 28) ^ __ROR8__(v219, 34) ^ __ROR8__(v219, 39)) + ((v216 ^ v213) & v219 ^ v216 & v213);
    uint64_t v223 = v212
         + v245.i64[1]
         + (__ROR8__(v221, 14) ^ __ROR8__(v221, 18) ^ __ROR8__(v221, 41))
         + ((v218 ^ v215) & v221 ^ v215);
    uint64_t v224 = v213 + v223;
    uint64_t v225 = v223 + (__ROR8__(v222, 28) ^ __ROR8__(v222, 34) ^ __ROR8__(v222, 39)) + ((v219 ^ v216) & v222 ^ v219 & v216);
    uint64_t v226 = v215
         + v246.i64[0]
         + (__ROR8__(v224, 14) ^ __ROR8__(v224, 18) ^ __ROR8__(v224, 41))
         + ((v221 ^ v218) & v224 ^ v218);
    uint64_t v227 = v216 + v226;
    uint64_t v228 = v226 + (__ROR8__(v225, 28) ^ __ROR8__(v225, 34) ^ __ROR8__(v225, 39)) + ((v222 ^ v219) & v225 ^ v222 & v219);
    uint64_t v229 = v218
         + v246.i64[1]
         + (__ROR8__(v227, 14) ^ __ROR8__(v227, 18) ^ __ROR8__(v227, 41))
         + ((v224 ^ v221) & v227 ^ v221);
    uint64_t v230 = v219 + v229;
    uint64_t v231 = v229 + (__ROR8__(v228, 28) ^ __ROR8__(v228, 34) ^ __ROR8__(v228, 39)) + ((v225 ^ v222) & v228 ^ v225 & v222);
    uint64_t v232 = v221
         + v247.i64[0]
         + (__ROR8__(v230, 14) ^ __ROR8__(v230, 18) ^ __ROR8__(v230, 41))
         + ((v227 ^ v224) & v230 ^ v224);
    uint64_t v233 = v222 + v232;
    uint64_t v234 = v232 + (__ROR8__(v231, 28) ^ __ROR8__(v231, 34) ^ __ROR8__(v231, 39)) + ((v228 ^ v225) & v231 ^ v228 & v225);
    uint64_t v235 = v224
         + v247.i64[1]
         + (__ROR8__(v233, 14) ^ __ROR8__(v233, 18) ^ __ROR8__(v233, 41))
         + ((v230 ^ v227) & v233 ^ v227);
    uint64_t v236 = result[1] + v234;
    *result += v235
             + (__ROR8__(v234, 28) ^ __ROR8__(v234, 34) ^ __ROR8__(v234, 39))
             + ((v231 ^ v228) & v234 ^ v231 & v228);
    result[1] = v236;
    uint64_t v237 = result[3] + v228;
    result[2] += v231;
    result[3] = v237;
    uint64_t v238 = result[5] + v233;
    result[4] += v225 + v235;
    result[5] = v238;
    uint64_t v239 = result[7] + v227;
    result[6] += v230;
    result[7] = v239;
  }

  return result;
}

uint64_t ccec_import_affine_point_ws( uint64_t a1, unint64_t *a2, int a3, uint64_t a4, unsigned __int8 *a5, void *a6)
{
  if (!a4) {
    return 4294967289LL;
  }
  unint64_t v11 = *a2;
  if (a4 == 1 && !*a5) {
    return 4294967136LL;
  }
  switch(a3)
  {
    case 4:
      uint64_t v12 = 4294967124LL;
      goto LABEL_20;
    case 1:
      uint64_t v12 = 4294967126LL;
      if (*a5 != 4) {
        return v12;
      }
LABEL_20:
      uint64_t v14 = *(void *)(a1 + 16);
      uint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v11);
      if (a3 == 4) {
        uint64_t v16 = a5;
      }
      else {
        uint64_t v16 = a5 + 1;
      }
      uint64_t v17 = cczp_bitlen((uint64_t)a2);
      uint64_t uint_public_value = ccn_read_uint_public_value(v11, a6, (unint64_t)(v17 + 7) >> 3, v16);
      if (ccn_cmp_public_value(v11, a6, a2 + 3) == -1)
      {
        if ((a3 - 3) <= 1)
        {
          uint64_t uint_public_value = ccec_affine_point_from_x_ws(a1, a2, (uint64_t)a6, (uint64_t)a6);
          if (!(_DWORD)uint_public_value)
          {
            cczp_negate((uint64_t)a2, v15, &a6[*a2]);
            uint64_t v19 = &a6[*a2];
            if (a3 == 4) {
              unsigned int v20 = ccn_cmp_public_value(v11, v15, v19) >> 31;
            }
            else {
              LOBYTE(v20) = (*v19 & 1) != (*a5 & 1);
            }
            ccn_mux(v11, v20, v19, v15, v19);
            goto LABEL_35;
          }

uint64_t cccmac_generate_subkeys(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  __s[0] = 0LL;
  __s[1] = 0LL;
  uint64_t result = cccbc_one_shot_explicit_internal(a1, a2, 16LL, *(void *)(a1 + 8), 1LL, a3, v17, (uint64_t)__s, (uint64_t)__s);
  if (!(_DWORD)result)
  {
    LOBYTE(v_Block_object_dispose((const void *)(v11 - 96), 8) = 0;
    unsigned int v9 = SLOBYTE(__s[0]);
    for (uint64_t i = 15LL; i != -1; --i)
    {
      unsigned int v11 = *((unsigned __int8 *)__s + i);
      a4[i] = v8 | (2 * v11);
      unsigned int v8 = v11 >> 7;
    }

    LOBYTE(v12) = 0;
    a4[15] ^= (v9 >> 7) & 0x87;
    unsigned int v13 = *a4;
    for (uint64_t j = 15LL; j != -1; --j)
    {
      unsigned int v15 = a4[j];
      *(_BYTE *)(a5 + j) = v12 | (2 * v15);
      unsigned int v12 = v15 >> 7;
    }

    *(_BYTE *)(a5 + 15) ^= (v13 >> 7) & 0x87;
    cc_clear(0x10uLL, __s);
    return 0LL;
  }

  return result;
}

void *ccsha1_di()
{
  return &ccsha1_vng_arm_di;
}

int8x16_t gcm_init( int8x16_t *a1, int8x16_t *a2, double a3, double a4, double a5, double a6, double a7, int8x16_t a8)
{
  int32x4_t v8 = (int32x4_t)vqtbl1q_s8(*a2, *(int8x16_t *)qword_208440);
  int8x16_t v9 = veorq_s8(a8, a8);
  int8x16_t v10 = veorq_s8( vandq_s8( vextq_s8(*(int8x16_t *)&qword_208440[2], *(int8x16_t *)&qword_208440[2], 8uLL),  (int8x16_t)vshrq_n_s32(vdupq_laneq_s32(v8, 3), 0x1FuLL)),  vorrq_s8( vextq_s8(v9, (int8x16_t)vshrq_n_u64((uint64x2_t)v8, 0x3FuLL), 8uLL),  (int8x16_t)vshlq_n_s64((int64x2_t)v8, 1uLL)));
  *a1 = v10;
  a1[8] = veorq_s8(v10, vextq_s8(v10, v10, 8uLL));
  int8x16_t v11 = (int8x16_t)vmull_high_p64((uint64x2_t)v10, (uint64x2_t)v10);
  int8x16_t v12 = (int8x16_t)vmull_p64(v10.u64[0], v10.u64[0]);
  int8x16_t v13 = veorq_s8( v12,  veorq_s8( v11,  (int8x16_t)vmull_p64( veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0],  veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0])));
  int8x16_t v14 = veorq_s8(vextq_s8(v9, v13, 8uLL), v12);
  int8x16_t v15 = veorq_s8(vextq_s8(v14, v14, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v14.u64[0]));
  int8x16_t v16 = veorq_s8( veorq_s8(vextq_s8(v13, v9, 8uLL), v11),  veorq_s8(vextq_s8(v15, v15, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v15.u64[0])));
  a1[1] = v16;
  a1[9] = veorq_s8(v16, vextq_s8(v16, v16, 8uLL));
  v13.i64[0] = veorq_s8(v16, vextq_s8(v16, v16, 8uLL)).u64[0];
  int8x16_t v17 = (int8x16_t)vmull_high_p64((uint64x2_t)v16, (uint64x2_t)v10);
  int8x16_t v18 = (int8x16_t)vmull_p64(v16.u64[0], v10.u64[0]);
  int8x16_t v19 = veorq_s8(v18, veorq_s8(v17, (int8x16_t)vmull_p64(veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0], v13.u64[0])));
  int8x16_t v20 = veorq_s8(vextq_s8(v9, v19, 8uLL), v18);
  int8x16_t v21 = veorq_s8(vextq_s8(v20, v20, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v20.u64[0]));
  int8x16_t v22 = veorq_s8( veorq_s8(vextq_s8(v19, v9, 8uLL), v17),  veorq_s8(vextq_s8(v21, v21, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v21.u64[0])));
  a1[2] = v22;
  a1[10] = veorq_s8(v22, vextq_s8(v22, v22, 8uLL));
  v19.i64[0] = veorq_s8(v22, vextq_s8(v22, v22, 8uLL)).u64[0];
  int8x16_t v23 = (int8x16_t)vmull_high_p64((uint64x2_t)v22, (uint64x2_t)v10);
  int8x16_t v24 = (int8x16_t)vmull_p64(v22.u64[0], v10.u64[0]);
  int8x16_t v25 = veorq_s8(v24, veorq_s8(v23, (int8x16_t)vmull_p64(veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0], v19.u64[0])));
  int8x16_t v26 = veorq_s8(vextq_s8(v9, v25, 8uLL), v24);
  int8x16_t v27 = veorq_s8(vextq_s8(v26, v26, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v26.u64[0]));
  int8x16_t v28 = veorq_s8( veorq_s8(vextq_s8(v25, v9, 8uLL), v23),  veorq_s8(vextq_s8(v27, v27, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v27.u64[0])));
  a1[3] = v28;
  a1[11] = veorq_s8(v28, vextq_s8(v28, v28, 8uLL));
  v25.i64[0] = veorq_s8(v28, vextq_s8(v28, v28, 8uLL)).u64[0];
  int8x16_t v29 = (int8x16_t)vmull_high_p64((uint64x2_t)v28, (uint64x2_t)v10);
  int8x16_t v30 = (int8x16_t)vmull_p64(v28.u64[0], v10.u64[0]);
  int8x16_t v31 = veorq_s8(v30, veorq_s8(v29, (int8x16_t)vmull_p64(veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0], v25.u64[0])));
  int8x16_t v32 = veorq_s8(vextq_s8(v9, v31, 8uLL), v30);
  int8x16_t v33 = veorq_s8(vextq_s8(v32, v32, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v32.u64[0]));
  int8x16_t v34 = veorq_s8( veorq_s8(vextq_s8(v31, v9, 8uLL), v29),  veorq_s8(vextq_s8(v33, v33, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v33.u64[0])));
  a1[4] = v34;
  a1[12] = veorq_s8(v34, vextq_s8(v34, v34, 8uLL));
  v31.i64[0] = veorq_s8(v34, vextq_s8(v34, v34, 8uLL)).u64[0];
  int8x16_t v35 = (int8x16_t)vmull_high_p64((uint64x2_t)v34, (uint64x2_t)v10);
  int8x16_t v36 = (int8x16_t)vmull_p64(v34.u64[0], v10.u64[0]);
  int8x16_t v37 = veorq_s8(v36, veorq_s8(v35, (int8x16_t)vmull_p64(veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0], v31.u64[0])));
  int8x16_t v38 = veorq_s8(vextq_s8(v9, v37, 8uLL), v36);
  int8x16_t v39 = veorq_s8(vextq_s8(v38, v38, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v38.u64[0]));
  int8x16_t v40 = veorq_s8( veorq_s8(vextq_s8(v37, v9, 8uLL), v35),  veorq_s8(vextq_s8(v39, v39, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v39.u64[0])));
  a1[5] = v40;
  a1[13] = veorq_s8(v40, vextq_s8(v40, v40, 8uLL));
  v37.i64[0] = veorq_s8(v40, vextq_s8(v40, v40, 8uLL)).u64[0];
  int8x16_t v41 = (int8x16_t)vmull_high_p64((uint64x2_t)v40, (uint64x2_t)v10);
  int8x16_t v42 = (int8x16_t)vmull_p64(v40.u64[0], v10.u64[0]);
  int8x16_t v43 = veorq_s8(v42, veorq_s8(v41, (int8x16_t)vmull_p64(veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0], v37.u64[0])));
  int8x16_t v44 = veorq_s8(vextq_s8(v9, v43, 8uLL), v42);
  int8x16_t v45 = veorq_s8(vextq_s8(v44, v44, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v44.u64[0]));
  int8x16_t v46 = veorq_s8( veorq_s8(vextq_s8(v43, v9, 8uLL), v41),  veorq_s8(vextq_s8(v45, v45, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v45.u64[0])));
  a1[6] = v46;
  a1[14] = veorq_s8(v46, vextq_s8(v46, v46, 8uLL));
  v43.i64[0] = veorq_s8(v46, vextq_s8(v46, v46, 8uLL)).u64[0];
  int8x16_t v47 = (int8x16_t)vmull_high_p64((uint64x2_t)v46, (uint64x2_t)v10);
  int8x16_t v48 = (int8x16_t)vmull_p64(v46.u64[0], v10.u64[0]);
  int8x16_t v49 = veorq_s8(v48, veorq_s8(v47, (int8x16_t)vmull_p64(veorq_s8(v10, vextq_s8(v10, v10, 8uLL)).u64[0], v43.u64[0])));
  int8x16_t v50 = veorq_s8(vextq_s8(v9, v49, 8uLL), v48);
  int8x16_t v51 = veorq_s8(vextq_s8(v50, v50, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v50.u64[0]));
  int8x16_t result = veorq_s8( veorq_s8(vextq_s8(v49, v9, 8uLL), v47),  veorq_s8(vextq_s8(v51, v51, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v51.u64[0])));
  a1[7] = result;
  a1[15] = veorq_s8(result, vextq_s8(result, result, 8uLL));
  return result;
}

int8x16_t gcm_gmult( int8x16_t *a1, uint64x2_t *a2, int8x16_t *a3, double a4, double a5, double a6, double a7, double a8, int8x16_t a9)
{
  int8x16_t v9 = vqtbl1q_s8(*a1, *(int8x16_t *)qword_208440);
  int8x16_t v10 = veorq_s8(a9, a9);
  unint64_t v11 = veorq_s8(v9, vextq_s8(v9, v9, 8uLL)).u64[0];
  int8x16_t v12 = (int8x16_t)vmull_high_p64((uint64x2_t)v9, *a2);
  int8x16_t v13 = (int8x16_t)vmull_p64(v9.u64[0], a2->i64[0]);
  int8x16_t v14 = veorq_s8( v13,  veorq_s8( v12,  (int8x16_t)vmull_p64( veorq_s8(*(int8x16_t *)a2, vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 8uLL)).u64[0],  v11)));
  int8x16_t v15 = veorq_s8(vextq_s8(v10, v14, 8uLL), v13);
  int8x16_t v16 = veorq_s8(vextq_s8(v15, v15, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v15.u64[0]));
  int8x16_t result = vqtbl1q_s8( veorq_s8( veorq_s8(vextq_s8(v14, v10, 8uLL), v12),  veorq_s8(vextq_s8(v16, v16, 8uLL), (int8x16_t)vmull_p64(0xC200000000000000LL, v16.u64[0]))),  *(int8x16_t *)qword_208440);
  *a3 = result;
  return result;
}

int8x16_t gcm_ghash(int8x16_t *a1, uint64x2_t *a2, int8x16_t *a3, uint64_t a4)
{
  int8x16_t v5 = veorq_s8(v4, v4);
  int8x16_t v6 = vqtbl1q_s8(*a1, *(int8x16_t *)qword_208440);
  BOOL v7 = a4 < 128;
  for (uint64_t i = a4 - 128; !v7; i -= 128LL)
  {
    int8x16_t v9 = vqtbl1q_s8(a3[7], *(int8x16_t *)qword_208440);
    int8x16_t v10 = (int8x16_t)vmull_p64(a2->i64[0], v9.u64[0]);
    int8x16_t v11 = (int8x16_t)vmull_high_p64(*a2, (uint64x2_t)v9);
    int8x16_t v12 = (int8x16_t)vmull_p64(a2[8].u64[0], veorq_s8(v9, vextq_s8(v9, v9, 8uLL)).u64[0]);
    int8x16_t v13 = vqtbl1q_s8(a3[6], *(int8x16_t *)qword_208440);
    uint64x2_t v14 = a2[1];
    int8x16_t v15 = veorq_s8(v10, (int8x16_t)vmull_p64(v14.u64[0], v13.u64[0]));
    int8x16_t v16 = veorq_s8(v11, (int8x16_t)vmull_high_p64(v14, (uint64x2_t)v13));
    int8x16_t v17 = veorq_s8(v12, (int8x16_t)vmull_p64(a2[9].u64[0], veorq_s8(v13, vextq_s8(v13, v13, 8uLL)).u64[0]));
    int8x16_t v18 = vqtbl1q_s8(a3[5], *(int8x16_t *)qword_208440);
    uint64x2_t v19 = a2[2];
    int8x16_t v20 = veorq_s8(v15, (int8x16_t)vmull_p64(v19.u64[0], v18.u64[0]));
    int8x16_t v21 = veorq_s8(v16, (int8x16_t)vmull_high_p64(v19, (uint64x2_t)v18));
    int8x16_t v22 = veorq_s8(v17, (int8x16_t)vmull_p64(a2[10].u64[0], veorq_s8(v18, vextq_s8(v18, v18, 8uLL)).u64[0]));
    int8x16_t v23 = vqtbl1q_s8(a3[4], *(int8x16_t *)qword_208440);
    uint64x2_t v24 = a2[3];
    int8x16_t v25 = veorq_s8(v20, (int8x16_t)vmull_p64(v24.u64[0], v23.u64[0]));
    int8x16_t v26 = veorq_s8(v21, (int8x16_t)vmull_high_p64(v24, (uint64x2_t)v23));
    int8x16_t v27 = veorq_s8(v22, (int8x16_t)vmull_p64(a2[11].u64[0], veorq_s8(v23, vextq_s8(v23, v23, 8uLL)).u64[0]));
    int8x16_t v28 = vqtbl1q_s8(a3[3], *(int8x16_t *)qword_208440);
    uint64x2_t v29 = a2[4];
    int8x16_t v30 = veorq_s8(v25, (int8x16_t)vmull_p64(v29.u64[0], v28.u64[0]));
    int8x16_t v31 = veorq_s8(v26, (int8x16_t)vmull_high_p64(v29, (uint64x2_t)v28));
    int8x16_t v32 = veorq_s8(v27, (int8x16_t)vmull_p64(a2[12].u64[0], veorq_s8(v28, vextq_s8(v28, v28, 8uLL)).u64[0]));
    int8x16_t v33 = vqtbl1q_s8(a3[2], *(int8x16_t *)qword_208440);
    uint64x2_t v34 = a2[5];
    int8x16_t v35 = veorq_s8(v30, (int8x16_t)vmull_p64(v34.u64[0], v33.u64[0]));
    int8x16_t v36 = veorq_s8(v31, (int8x16_t)vmull_high_p64(v34, (uint64x2_t)v33));
    int8x16_t v37 = veorq_s8(v32, (int8x16_t)vmull_p64(a2[13].u64[0], veorq_s8(v33, vextq_s8(v33, v33, 8uLL)).u64[0]));
    int8x16_t v38 = vqtbl1q_s8(a3[1], *(int8x16_t *)qword_208440);
    uint64x2_t v39 = a2[6];
    int8x16_t v40 = veorq_s8(v35, (int8x16_t)vmull_p64(v39.u64[0], v38.u64[0]));
    int8x16_t v41 = veorq_s8(v36, (int8x16_t)vmull_high_p64(v39, (uint64x2_t)v38));
    int8x16_t v42 = veorq_s8(v37, (int8x16_t)vmull_p64(a2[14].u64[0], veorq_s8(v38, vextq_s8(v38, v38, 8uLL)).u64[0]));
    uint64x2_t v43 = a2[7];
    int8x16_t v44 = veorq_s8(vqtbl1q_s8(*a3, *(int8x16_t *)qword_208440), v6);
    int8x16_t v45 = veorq_s8(v40, (int8x16_t)vmull_p64(v43.u64[0], v44.u64[0]));
    int8x16_t v46 = veorq_s8(v41, (int8x16_t)vmull_high_p64(v43, (uint64x2_t)v44));
    int8x16_t v47 = veorq_s8( v46,  veorq_s8( v45,  veorq_s8(v42, (int8x16_t)vmull_p64(a2[15].u64[0], veorq_s8(v44, vextq_s8(v44, v44, 8uLL)).u64[0]))));
    int8x16_t v48 = veorq_s8(v45, vextq_s8(v5, v47, 8uLL));
    int8x16_t v49 = veorq_s8((int8x16_t)vmull_p64(0xC200000000000000LL, v48.u64[0]), vextq_s8(v48, v48, 8uLL));
    int8x16_t v6 = veorq_s8( veorq_s8(v46, vextq_s8(v47, v5, 8uLL)),  veorq_s8((int8x16_t)vmull_p64(0xC200000000000000LL, v49.u64[0]), vextq_s8(v49, v49, 8uLL)));
    a3 += 8;
    BOOL v7 = i < 128;
  }

  BOOL v7 = i < -112;
  uint64_t v50 = i + 112;
  if (!v7)
  {
    int8x16_t v52 = *a3;
    int8x16_t v51 = a3 + 1;
    int8x16_t v53 = veorq_s8(v6, vqtbl1q_s8(v52, *(int8x16_t *)qword_208440));
    int8x16_t v54 = (uint64x2_t *)((char *)a2 + v50);
    uint64x2_t v55 = *(uint64x2_t *)((char *)a2 + v50);
    int8x16_t v56 = (int8x16_t)vmull_p64(v53.u64[0], v55.u64[0]);
    int8x16_t v57 = (int8x16_t)vmull_high_p64((uint64x2_t)v53, v55);
    int8x16_t v58 = (int8x16_t)vmull_p64( veorq_s8(v53, vextq_s8(v53, v53, 8uLL)).u64[0],  *(unint64_t *)((char *)a2[8].u64 + v50));
    BOOL v7 = v50 < 16;
    for (uint64_t j = v50 - 16; !v7; j -= 16LL)
    {
      --v54;
      int8x16_t v60 = *v51++;
      int8x16_t v61 = vqtbl1q_s8(v60, *(int8x16_t *)qword_208440);
      int8x16_t v56 = veorq_s8(v56, (int8x16_t)vmull_p64(v61.u64[0], v54->i64[0]));
      int8x16_t v57 = veorq_s8(v57, (int8x16_t)vmull_high_p64((uint64x2_t)v61, *v54));
      int8x16_t v58 = veorq_s8(v58, (int8x16_t)vmull_p64(veorq_s8(v61, vextq_s8(v61, v61, 8uLL)).u64[0], v54[8].u64[0]));
      BOOL v7 = j < 16;
    }

    int8x16_t v62 = veorq_s8(v57, veorq_s8(v56, v58));
    int8x16_t v63 = veorq_s8(v56, vextq_s8(v5, v62, 8uLL));
    int8x16_t v64 = veorq_s8((int8x16_t)vmull_p64(0xC200000000000000LL, v63.u64[0]), vextq_s8(v63, v63, 8uLL));
    int8x16_t v6 = veorq_s8( veorq_s8(v57, vextq_s8(v62, v5, 8uLL)),  veorq_s8((int8x16_t)vmull_p64(0xC200000000000000LL, v64.u64[0]), vextq_s8(v64, v64, 8uLL)));
  }

  int8x16_t result = vqtbl1q_s8(v6, *(int8x16_t *)qword_208440);
  *a1 = result;
  return result;
}

int64x2_t *AccelerateCrypto_SHA512_compress_hwassist(int64x2_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int64x2_t v3 = *result;
    int64x2_t v4 = result[1];
    int64x2_t v5 = result[2];
    int64x2_t v6 = result[3];
    do
    {
      _Q24 = v3;
      _Q25 = v4;
      _Q0 = vrev64q_s8(*a3);
      _Q1 = vrev64q_s8(a3[1]);
      _Q2 = vrev64q_s8(a3[2]);
      _Q3 = vrev64q_s8(a3[3]);
      _Q4 = vrev64q_s8(a3[4]);
      _Q5 = vrev64q_s8(a3[5]);
      _Q6 = vrev64q_s8(a3[6]);
      _Q7 = vrev64q_s8(a3[7]);
      a3 += 8;
      _Q29 = vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v4, (int8x16_t)v5, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v26 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v29 = (int8x16_t)vaddq_s64(v4, v26);
      _Q29 = vextq_s8(v29, (int8x16_t)v5, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v3, v29, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v35 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v38 = (int8x16_t)vaddq_s64(v3, v35);
      _Q29 = vextq_s8(v38, v29, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v38, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v44 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v47 = (int8x16_t)vaddq_s64(_Q27, v44);
      _Q29 = vextq_s8(v47, v38, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v47, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v53 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v56 = (int8x16_t)vaddq_s64(_Q26, v53);
      _Q29 = vextq_s8(v56, v47, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v56, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v62 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v65 = (int8x16_t)vaddq_s64(_Q25, v62);
      _Q29 = vextq_s8(v65, v56, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v65, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v71 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v74 = (int8x16_t)vaddq_s64(_Q24, v71);
      _Q29 = vextq_s8(v74, v65, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v74, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v80 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v83 = (int8x16_t)vaddq_s64(_Q27, v80);
      _Q29 = vextq_s8(v83, v74, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v83, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v89 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v92 = (int8x16_t)vaddq_s64(_Q26, v89);
      _Q29 = vextq_s8(v92, v83, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v92, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v98 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v101 = (int8x16_t)vaddq_s64(_Q25, v98);
      _Q29 = vextq_s8(v101, v92, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v101, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v107 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v110 = (int8x16_t)vaddq_s64(_Q24, v107);
      _Q29 = vextq_s8(v110, v101, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v110, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v116 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v119 = (int8x16_t)vaddq_s64(_Q27, v116);
      _Q29 = vextq_s8(v119, v110, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v119, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v125 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v128 = (int8x16_t)vaddq_s64(_Q26, v125);
      _Q29 = vextq_s8(v128, v119, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v128, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v134 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v137 = (int8x16_t)vaddq_s64(_Q25, v134);
      _Q29 = vextq_s8(v137, v128, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v137, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v143 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v146 = (int8x16_t)vaddq_s64(_Q24, v143);
      _Q29 = vextq_s8(v146, v137, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v146, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v152 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v155 = (int8x16_t)vaddq_s64(_Q27, v152);
      _Q29 = vextq_s8(v155, v146, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v155, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v161 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v164 = (int8x16_t)vaddq_s64(_Q26, v161);
      _Q29 = vextq_s8(v164, v155, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v164, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v170 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v173 = (int8x16_t)vaddq_s64(_Q25, v170);
      _Q29 = vextq_s8(v173, v164, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v173, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v179 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v182 = (int8x16_t)vaddq_s64(_Q24, v179);
      _Q29 = vextq_s8(v182, v173, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v182, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v188 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v191 = (int8x16_t)vaddq_s64(_Q27, v188);
      _Q29 = vextq_s8(v191, v182, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v191, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v197 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v200 = (int8x16_t)vaddq_s64(_Q26, v197);
      _Q29 = vextq_s8(v200, v191, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v200, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v206 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v209 = (int8x16_t)vaddq_s64(_Q25, v206);
      _Q29 = vextq_s8(v209, v200, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v209, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v215 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v218 = (int8x16_t)vaddq_s64(_Q24, v215);
      _Q29 = vextq_s8(v218, v209, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v218, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v224 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v227 = (int8x16_t)vaddq_s64(_Q27, v224);
      _Q29 = vextq_s8(v227, v218, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v227, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v233 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v236 = (int8x16_t)vaddq_s64(_Q26, v233);
      _Q29 = vextq_s8(v236, v227, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v236, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v242 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v245 = (int8x16_t)vaddq_s64(_Q25, v242);
      _Q29 = vextq_s8(v245, v236, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v245, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v251 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v254 = (int8x16_t)vaddq_s64(_Q24, v251);
      _Q29 = vextq_s8(v254, v245, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v254, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v260 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v263 = (int8x16_t)vaddq_s64(_Q27, v260);
      _Q29 = vextq_s8(v263, v254, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v263, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v269 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v272 = (int8x16_t)vaddq_s64(_Q26, v269);
      _Q29 = vextq_s8(v272, v263, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v272, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v278 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v281 = (int8x16_t)vaddq_s64(_Q25, v278);
      _Q29 = vextq_s8(v281, v272, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v281, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v287 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v290 = (int8x16_t)vaddq_s64(_Q24, v287);
      _Q29 = vextq_s8(v290, v281, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v290, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v296 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v299 = (int8x16_t)vaddq_s64(_Q27, v296);
      _Q29 = vextq_s8(v299, v290, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v299, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v305 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v308 = (int8x16_t)vaddq_s64(_Q26, v305);
      _Q29 = vextq_s8(v308, v299, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v308, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }

      int8x16_t v313 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v313, v308, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v313, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }

      int8x16_t v318 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v318, v313, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v318, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }

      int8x16_t v323 = (int8x16_t)vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8(v323, v318, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v323, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }

      int8x16_t v328 = (int8x16_t)vaddq_s64(_Q26, _Q30);
      _Q29 = vextq_s8(v328, v323, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v328, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }

      int8x16_t v333 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v333, v328, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v333, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }

      int8x16_t v338 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v338, v333, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v338, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }

      int64x2_t v343 = vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8((int8x16_t)v343, v338, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, (int8x16_t)v343, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }

      int64x2_t v3 = vaddq_s64(v3, _Q24);
      int64x2_t v4 = vaddq_s64(v4, _Q25);
      int64x2_t v5 = vaddq_s64(v5, vaddq_s64(_Q26, _Q30));
      int64x2_t v6 = vaddq_s64(v6, v343);
    }

    while (a2-- > 1);
    *int8x16_t result = v3;
    result[1] = v4;
    result[2] = v5;
    result[3] = v6;
  }

  return result;
}

int32x4_t *AccelerateCrypto_SHA1_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v5 = *a3;
    int8x16_t v6 = a3[1];
    int8x16_t v7 = a3[2];
    int8x16_t v8 = a3[3];
    int64x2_t v4 = a3 + 4;
    int32x4_t v10 = *result;
    int8x16_t v9 = result + 1;
    int32x4_t v11 = v10;
    v10.i32[0] = v9->i32[0];
    int8x16_t v12 = v9 - 1;
    v3.i32[0] = v10.i32[0];
    _Q1 = (int32x4_t)vrev32q_s8(v6);
    _Q2 = (int32x4_t)vrev32q_s8(v7);
    _Q3 = (int32x4_t)vrev32q_s8(v8);
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v5), *(int32x4_t *)K_XMM_AR);
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
    _Q19 = v3;
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = v11.i32[0];
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, loc_208D00);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, loc_208D00);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, loc_208D00);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, loc_208D00);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, loc_208D00);
    BOOL v105 = a2 <= 1;
    for (uint64_t i = a2 - 1; !v105; --i)
    {
      int8x16_t v107 = *v4;
      int8x16_t v108 = v4[1];
      int8x16_t v109 = v4[2];
      int8x16_t v110 = v4[3];
      v4 += 4;
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
      }

      _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v107), *(int32x4_t *)K_XMM_AR);
      _Q1 = (int32x4_t)vrev32q_s8(v108);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
      _Q2 = (int32x4_t)vrev32q_s8(v109);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
      _Q3 = (int32x4_t)vrev32q_s8(v110);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
      }

      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
      _Q19 = vaddq_s32(v3, _Q19);
      int32x4_t v11 = vaddq_s32(v11, _Q18);
      int32x4_t v3 = _Q19;
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = v11.i32[0];
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, loc_208D00);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, loc_208D00);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, loc_208D00);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, loc_208D00);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, loc_208D00);
      BOOL v105 = i <= 1;
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
    }

    int32x4_t *v12 = vaddq_s32(v11, _Q18);
    int8x16_t result = v12 + 1;
    result->i32[0] = vaddq_s32(v3, _Q19).u32[0];
  }

  return result;
}

uint64_t ccder_sizeof_eckey(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = ccder_sizeof_uint64(1uLL);
  unint64_t v7 = ccder_sizeof(4LL, a1) + v6;
  if (a2)
  {
    unint64_t v8 = ccder_sizeof_oid(a2);
    v7 += ccder_sizeof(0xA000000000000000LL, v8);
  }

  if (a3)
  {
    unint64_t v9 = ccder_sizeof(3LL, a3 + 1);
    v7 += ccder_sizeof(0xA000000000000001LL, v9);
  }

  return ccder_sizeof(0x2000000000000010LL, v7);
}

void *ccec_cp_256_asm()
{
  return &ccec_cp256_asm;
}

_OWORD *ccn_p256_mul_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, unint64_t *a5)
{
  return ccn_mulmod_p256(a3, a4, a5);
}

_OWORD *ccn_p256_sqr_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  return ccn_mulmod_p256(a3, a4, a4);
}

uint64_t ccn_p256_inv_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = 4;
  unint64_t v9 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4LL);
  int32x4_t v10 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4LL);
  int32x4_t v11 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 4LL);
  ccn_mulmod_p256(v11, a4, a4);
  ccn_mulmod_p256(v10, v11, a4);
  ccn_mulmod_p256(v10, v10, v10);
  ccn_mulmod_p256(v10, v10, v10);
  ccn_mulmod_p256(v9, v10, a4);
  ccn_mulmod_p256(v10, v9, v11);
  do
  {
    ccn_mulmod_p256(v10, v10, v10);
    --v8;
  }

  while (v8);
  ccn_mulmod_p256(v9, v9, v10);
  ccn_mulmod_p256(v10, v9, v11);
  int v12 = 8;
  do
  {
    ccn_mulmod_p256(v10, v10, v10);
    --v12;
  }

  while (v12);
  ccn_mulmod_p256(v9, v9, v10);
  ccn_mulmod_p256(v10, v9, v11);
  int v13 = 16;
  do
  {
    ccn_mulmod_p256(v10, v10, v10);
    --v13;
  }

  while (v13);
  ccn_mulmod_p256(v9, v9, v10);
  ccn_mulmod_p256(v10, v9, v11);
  ccn_set(4LL, v11, v10);
  int v14 = 32;
  do
  {
    ccn_mulmod_p256(v11, v11, v11);
    --v14;
  }

  while (v14);
  ccn_mulmod_p256(v11, v11, a4);
  int v15 = 128;
  do
  {
    ccn_mulmod_p256(v11, v11, v11);
    --v15;
  }

  while (v15);
  ccn_mulmod_p256(v11, v11, v10);
  int v16 = 32;
  do
  {
    ccn_mulmod_p256(v11, v11, v11);
    --v16;
  }

  while (v16);
  ccn_mulmod_p256(v11, v11, v10);
  int v17 = 32;
  do
  {
    ccn_mulmod_p256(v11, v11, v11);
    --v17;
  }

  while (v17);
  ccn_mulmod_p256(v10, v11, v9);
  ccn_mulmod_p256(v9, v10, a4);
  v19[0] = xmmword_27FF68;
  v19[1] = unk_27FF78;
  ccn_mulmod_p256(v9, v9, (unint64_t *)v19);
  if (ccn_n(4LL, v9) == 1 && *v9 == 1)
  {
    ccn_set(4LL, a3, v10);
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = 4294967254LL;
  }

  *(void *)(a1 + 16) = v7;
  return result;
}

_OWORD *ccn_p256_from_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  v5[0] = xmmword_27FF68;
  v5[1] = unk_27FF78;
  return ccn_mulmod_p256(a3, a4, (unint64_t *)v5);
}

uint64_t cczp_mm_redc_ws(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = cczp_n((uint64_t)a2);
  uint64_t v9 = v8;
  if (v8)
  {
    uint64_t v10 = a2[*a2 + 3];
    int32x4_t v11 = a4;
    uint64_t v12 = v8;
    do
    {
      uint64_t v13 = cczp_prime((uint64_t)a2);
      *int32x4_t v11 = ccn_addmul1(v9, v11, v13, *v11 * v10);
      ++v11;
      --v12;
    }

    while (v12);
  }

  BOOL v14 = ccn_add_ws(a1, v9, &a4[v9], &a4[v9], a4);
  int v15 = (unint64_t *)cczp_prime((uint64_t)a2);
  char v16 = ccn_sub_ws(a1, v9, a4, &a4[v9], v15) ^ v14;
  return ccn_mux(v9, v16, a3, &a4[v9], a4);
}

uint64_t ccgcm_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_set_iv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t inc_uint(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = (_BYTE *)(a2 + result - 1);
    unint64_t v3 = 2LL;
    do
    {
      if (++*v2--) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v3 > a2;
      }
      ++v3;
    }

    while (!v5);
  }

  return result;
}

uint64_t ccmode_gcm_update_pad(uint64_t a1)
{
  unint64_t v1 = (_BYTE *)(a1 + 47);
  unint64_t v2 = 1LL;
  do
  {
    char v3 = *v1 + 1;
    *v1-- = v3;
    if (v2 > 3) {
      break;
    }
    ++v2;
  }

  while (!v3);
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 104) + 24LL))( *(void *)(a1 + 112),  1LL,  a1 + 32,  a1 + 64);
}

uint64_t ccgcm_aad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccgcm_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v12 = timingsafe_enable_if_supported();
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48))(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v12);
  return v10;
}

uint64_t ccgcm_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

void ccmode_gcm_aad_finalize( uint64_t a1, double a2, double a3, double a4, double a5, double a6, int8x16_t a7)
{
  if (*(_WORD *)(a1 + 80) == 2)
  {
    if ((*(_BYTE *)(a1 + 88) & 0xF) != 0) {
      ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), a2, a3, a4, a5, a6, a7);
    }
    *(_WORD *)(a1 + 80) = 3;
  }

uint64_t ccn_cond_clear(uint64_t a1, char a2, uint64_t *a3)
{
  uint64_t result = ccn_mux_next_mask();
  for (uint64_t i = __ROR8__(0x5555555555555555LL, a2 | (2 * result)); a1; --a1)
  {
    uint64_t v8 = *a3;
    uint64_t v9 = *a3 ^ result;
    *a3 = v9;
    *a3++ = v9 ^ v8 & 0x5555555555555555LL ^ v8 & i ^ result;
  }

  return result;
}

uint64_t ccsha512_final(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  unint64_t v9 = v7 + 8 + v6;
  size_t v10 = (v9 + 11) & 0xFFFFFFFFFFFFFFF8LL;
  int32x4_t v11 = (uint64_t *)((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  bzero(v11, v10);
  memcpy(v11, a2, v9 + 4);
  BOOL v12 = (char *)v11 + v7 + 8;
  uint64_t v13 = *(unsigned int *)&v12[v6];
  *v11 += (8 * v13);
  *(_DWORD *)&v12[v6] = v13 + 1;
  v12[v13] = 0x80;
  unint64_t v14 = *(unsigned int *)&v12[v6];
  if (v6 - 16 < v14)
  {
    while (v6 > v14)
    {
      *(_DWORD *)&v12[v6] = v14 + 1;
      v12[v14] = 0;
      unint64_t v14 = *(unsigned int *)&v12[v6];
    }

    (*(void (**)(void *, uint64_t))(a1 + 48))(v11 + 1, 1LL);
    LODWORD(v14) = 0;
    uint64_t v7 = *(void *)(a1 + 8);
    unint64_t v6 = *(void *)(a1 + 16);
    *(_DWORD *)((char *)v11 + v7 + v6 + _Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  }

  uint64_t v15 = (uint64_t)v11 + v7 + 8;
  char v16 = (_DWORD *)(v15 + v6);
  if (v6 - 8 > v14)
  {
    unint64_t v17 = v14;
    do
    {
      _DWORD *v16 = v14 + 1;
      *(_BYTE *)(v15 + v17) = 0;
      unint64_t v17 = *v16;
      LODWORD(v14) = *v16;
    }

    while (v6 - 8 > v17);
  }

  *((void *)v16 - 1) = bswap64(*v11);
  (*(void (**)(void *, uint64_t))(a1 + 48))(v11 + 1, 1LL);
  if (*(void *)a1 >= 8uLL)
  {
    unsigned int v18 = 0;
    unint64_t v19 = 0LL;
    unsigned int v20 = 1;
    do
    {
      *(void *)(a3 + v1_Block_object_dispose((const void *)(v11 - 96), 8) = bswap64(v11[v19 + 1]);
      unint64_t v19 = v20++;
      v18 += 8;
    }

    while (v19 < *(void *)a1 >> 3);
  }

  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL, v11);
}

uint64_t ccn_shift_right_asm(uint64_t result, int8x16_t *a2, int8x16_t *a3, uint64_t a4)
{
  if (result)
  {
    unint64_t v4 = a3->i64[0];
    char v5 = 64 - a4;
    uint64x2_t v6 = (uint64x2_t)vdupq_n_s64(64 - a4);
    uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(-a4);
    BOOL v8 = result == 4;
    BOOL v9 = result < 4;
    result -= 4LL;
    if (!v9)
    {
      if (v8)
      {
        int8x16_t v13 = a3[1];
        *a2 = veorq_s8( (int8x16_t)vshlq_u64(*(uint64x2_t *)a3, v7),  (int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(*a3, v13, 8uLL), v6));
        a2[1] = veorq_s8( (int8x16_t)vshlq_u64((uint64x2_t)v13, v7),  (int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(v13, v13, 8uLL).u64[0], v6));
        return result;
      }

      do
      {
        int8x16_t v10 = *a3;
        int8x16_t v11 = a3[1];
        a3 += 2;
        unint64_t v4 = a3->i64[0];
        v12.i64[0] = vextq_s8(v11, v11, 8uLL).u64[0];
        v12.i64[1] = a3->i64[0];
        *a2 = veorq_s8( (int8x16_t)vshlq_u64((uint64x2_t)v10, v7),  (int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(v10, v11, 8uLL), v6));
        a2[1] = veorq_s8((int8x16_t)vshlq_u64((uint64x2_t)v11, v7), (int8x16_t)vshlq_u64(v12, v6));
        a2 += 2;
        BOOL v9 = result <= 4;
        result -= 4LL;
      }

      while (!v9);
    }

    uint64_t v14 = result + 4;
    uint64_t v15 = &a3->u64[1];
    BOOL v16 = v14 == 2;
    BOOL v9 = v14 < 2;
    uint64_t result = v14 - 2;
    if (!v9)
    {
      if (v16)
      {
        uint64_t v19 = *v15 >> a4;
        a2->i64[0] = (v4 >> a4) | (*v15 << v5) & (((unint64_t)(64 - a4) >> 6) - 1);
        a2->i64[1] = v19;
        return result;
      }

      do
      {
        unint64_t v17 = *v15;
        unint64_t v18 = v15[1];
        v15 += 2;
        a2->i64[0] = (v4 >> a4) | (v17 << v5) & (((unint64_t)(64 - a4) >> 6) - 1);
        a2->i64[1] = (v17 >> a4) | (v18 << v5) & (((unint64_t)(64 - a4) >> 6) - 1);
        ++a2;
        unint64_t v4 = v18;
        BOOL v9 = result <= 2;
        result -= 2LL;
      }

      while (!v9);
    }

    a2->i64[0] = v4 >> a4;
  }

  return result;
}

uint64_t ccn_set_bit(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = 1LL << a2;
  uint64_t v4 = (a2 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  if (a3) {
    uint64_t v5 = *(void *)(result + v4) | v3;
  }
  else {
    uint64_t v5 = *(void *)(result + v4) & ~v3;
  }
  *(void *)(result + v4) = v5;
  return result;
}

uint64_t ccn_zero(uint64_t a1, void *a2)
{
  return cc_clear(8 * a1, a2);
}

uint64_t ccn_seti(uint64_t a1, void *a2, uint64_t a3)
{
  *a2 = a3;
  return cc_clear(8 * a1 - 8, a2 + 1);
}

unint64_t ccn_cond_rsub(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, uint64_t *a5)
{
  masuint64_t k = ccn_mux_next_mask();
  uint64_t v11 = __ROR8__(0x5555555555555555LL, a2 | (2 * mask));
  if (a1)
  {
    uint64_t v12 = 0LL;
    do
    {
      unint64_t v14 = *a4++;
      unint64_t v13 = v14;
      uint64_t v15 = *a5++;
      unsigned __int128 v16 = __PAIR128__(v12, v12) - v13;
      uint64_t v17 = v16 + v15;
      if (__CFADD__((void)v16, v15)) {
        uint64_t v18 = *((void *)&v16 + 1) + 1LL;
      }
      else {
        uint64_t v18 = (__PAIR128__(v12, v12) - v13) >> 64;
      }
      uint64_t v12 = v18 >> 63;
      uint64_t v19 = v13 ^ v17;
      uint64_t v20 = v13 ^ mask;
      *a3 = v20;
      *a3++ = v19 & v11 ^ v19 & 0x5555555555555555LL ^ v20 ^ mask;
      --a1;
    }

    while (a1);
    unint64_t v21 = (unint64_t)v18 >> 63;
  }

  else
  {
    unint64_t v21 = 0LL;
  }

  return v21 & a2;
}

BOOL timingsafe_enable_if_supported()
{
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000LL) != 0)
  {
    BOOL v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) != 0;
    __asm { MSR             DIT, #1 }
  }

  else
  {
    BOOL v0 = 0LL;
  }

  if ((MEMORY[0xFFFFFC010] & 0x200000000000LL) != 0)
  {
    sb();
  }

  else
  {
    __dsb(0xFu);
    __isb(0xFu);
  }

  return v0;
}

uint64_t timingsafe_restore_if_supported(uint64_t result)
{
  if ((result & 1) == 0 && (MEMORY[0xFFFFFC010] & 0x200000000000000LL) != 0) {
    __asm { MSR             DIT, #0 }
  }

  return result;
}

void sb()
{
  __asm { SB }

uint64_t AccelerateCrypto_ecb_AES_encrypt(__int128 *a1, int a2, uint64_t a3, int8x16_t *a4)
{
  uint64_t v4 = *((unsigned int *)a1 + 60);
  _VF = __OFSUB__(a2, 4);
  int v6 = a2 - 4;
  for (int8x16_t i = *(int8x16_t *)((char *)a1 + v4); v6 < 0 == _VF; v6 -= 4)
  {
    _Q4 = *a1;
    uint64_t v9 = 16LL;
    a3 += 64LL;
    do
    {
      __asm
      {
        AESE            V0.16B, V4.16B
        AESMC           V0.16B, V0.16B
        AESE            V1.16B, V4.16B
        AESMC           V1.16B, V1.16B
        AESE            V2.16B, V4.16B
        AESMC           V2.16B, V2.16B
        AESE            V3.16B, V4.16B
        AESMC           V3.16B, V3.16B
      }

      _Q4 = a1[(unint64_t)v9 / 0x10];
      v9 += 16LL;
    }

    while (v9 < v4);
    __asm
    {
      AESE            V0.16B, V4.16B
      AESE            V1.16B, V4.16B
      AESE            V2.16B, V4.16B
      AESE            V3.16B, V4.16B
    }

    *a4 = veorq_s8(_Q0, i);
    a4[1] = veorq_s8(_Q1, i);
    a4[2] = veorq_s8(_Q2, i);
    a4[3] = veorq_s8(_Q3, i);
    a4 += 4;
    _VF = __OFSUB__(v6, 4);
  }

  int v25 = v6 & 3;
  if (v25)
  {
    do
    {
      _Q4 = *a1;
      uint64_t v27 = 16LL;
      a3 += 16LL;
      do
      {
        __asm
        {
          AESE            V0.16B, V4.16B
          AESMC           V0.16B, V0.16B
        }

        _Q4 = a1[(unint64_t)v27 / 0x10];
        v27 += 16LL;
      }

      while (v27 < v4);
      __asm { AESE            V0.16B, V4.16B }

      *a4++ = veorq_s8(_Q0, i);
      _VF = __OFSUB__(v25--, 1);
    }

    while (!((v25 < 0) ^ _VF | (v25 == 0)));
  }

  return 0LL;
}

uint64_t ccec_der_export_priv_size(uint64_t *a1, uint64_t a2, int a3)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t v6 = cczp_bitlen(*a1 + 40LL * *(void *)*a1 + 32);
  if (a3) {
    unint64_t v7 = ((unint64_t)(cczp_bitlen(*a1) + 7) >> 2) | 1;
  }
  else {
    unint64_t v7 = 0LL;
  }
  uint64_t v8 = ccder_encode_eckey_size((unint64_t)(v6 + 7) >> 3, a2, v7);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return v8;
}

uint64_t ccec_der_export_priv(unint64_t **a1, const void *a2, int a3, uint64_t a4, uint64_t a5)
{
  BOOL v23 = timingsafe_enable_if_supported();
  BOOL v10 = *a1;
  v19[0] = cc_malloc_clear(24 * **a1 + 8);
  v19[1] = 3 * *v10 + 1;
  uint64_t v20 = 0LL;
  unint64_t v21 = cc_ws_alloc;
  uint64_t v22 = cc_ws_free;
  if (v19[0])
  {
    unint64_t v11 = **a1;
    unint64_t v12 = (unint64_t)(cczp_bitlen((uint64_t)&(*a1)[5 * v11 + 4]) + 7) >> 3;
    unint64_t v13 = (char *)cc_ws_alloc(v19, v11);
    if ((ccn_write_uint_padded_ct_internal(v11, (unint64_t *)&a1[3 * **a1 + 2], v12, v13) & 0x80000000) != 0)
    {
      uint64_t v15 = 4294967289LL;
    }

    else
    {
      if (a3) {
        unint64_t v14 = ((unint64_t)(cczp_bitlen((uint64_t)*a1) + 7) >> 2) | 1;
      }
      else {
        unint64_t v14 = 0LL;
      }
      unsigned __int128 v16 = (char *)v21(v19, (2 * v11) | 1);
      if (a3)
      {
        uint64_t v17 = ccec_export_pub((uint64_t *)a1, v16);
        if ((_DWORD)v17)
        {
          uint64_t v15 = v17;
          goto LABEL_13;
        }
      }

      else {
        uint64_t v15 = 0xFFFFFFFFLL;
      }
    }

    uint64_t v20 = 0LL;
LABEL_13:
    v22((uint64_t)v19);
    goto LABEL_14;
  }

  uint64_t v15 = 4294967283LL;
LABEL_14:
  cc_disable_dit_with_sb((unsigned int *)&v23);
  return v15;
}

unint64_t ccec_export_affine_point_size(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1:
    case 2:
      unint64_t result = ((unint64_t)(cczp_bitlen(a1) + 7) >> 2) | 1;
      break;
    case 3:
      unint64_t result = ccec_compressed_x962_export_pub_size(a1);
      break;
    case 4:
      unint64_t result = (unint64_t)(cczp_bitlen(a1) + 7) >> 3;
      break;
    default:
      unint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t ccec_export_affine_point_public_value( unint64_t *a1, int a2, unint64_t *a3, unint64_t *a4, char *a5)
{
  unint64_t v10 = ccec_export_affine_point_size((uint64_t)a1, a2);
  if (!v10) {
    return 4294967289LL;
  }
  if (*a4 < v10) {
    return 4294967133LL;
  }
  *a4 = v10;
  unsigned int v11 = a2 - 1;
  unint64_t v12 = *a1;
  if (a2 == 4) {
    unint64_t v13 = a5;
  }
  else {
    unint64_t v13 = a5 + 1;
  }
  uint64_t v14 = cczp_bitlen((uint64_t)a1);
  if (v11 <= 1)
  {
    uint64_t v15 = &v13[(unint64_t)(cczp_bitlen((uint64_t)a1) + 7) >> 3];
    unsigned __int128 v16 = &a3[*a1];
    uint64_t v17 = cczp_bitlen((uint64_t)a1);
  }

  uint64_t result = 0LL;
  if ((a2 & 0xFFFFFFFE) == 2) {
    *a5 |= a3[*a1] & 1;
  }
  return result;
}

unint64_t ccn_trailing_zeros(unint64_t result, uint64_t a2)
{
  if (result)
  {
    unint64_t v2 = result;
    uint64_t result = 0LL;
    unint64_t v3 = v2 - 1;
    uint64_t v4 = (v2 << 6) - 64;
    do
    {
      unint64_t v5 = *(void *)(a2 + 8 * v3);
      --v3;
      v4 -= 64LL;
    }

    while (v3 < v2);
  }

  return result;
}

uint64_t ccec_verify_internal_with_base_ws( uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = (uint64_t *)*a2;
  uint64_t v16 = (uint64_t)(*a2 + 4);
  unint64_t v15 = **a2;
  if (a3 <= 0xF)
  {
    uint64x2_t v34 = (os_log_s *)cc_log_default();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT)) {
      ccec_verify_internal_with_base_ws_cold_1(a3, v34);
    }
  }

  if (!ccec_validate_scalar(v14, a5) && !ccec_validate_scalar(v14, a6))
  {
    int8x16_t v38 = (unint64_t *)a5;
    uint64_t v41 = *(void *)(a1 + 16);
    uint64_t v19 = (int8x16_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64x2_t v39 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64_t v44 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    uint64_t v43 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    int8x16_t v40 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v15);
    int8x16_t v42 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * v15);
    size_t v20 = ccec_signature_r_s_size((uint64_t *)a2);
    int8x16_t v36 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    memset(v36, 170, v20);
    __int128 __s = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v15);
    unint64_t v37 = v20;
    memset(__s, 255, v20);
    uint64_t v21 = cczp_bitlen(v16 + 40 * *v14);
    unint64_t v22 = v21;
    else {
      unint64_t v23 = (unint64_t)(v21 + 7) >> 3;
    }
    uint64_t uint_internal = ccn_read_uint_internal(v15, v19, v23, a4);
    if ((uint_internal & 0x80000000) == 0)
    {
      if (v22 < 8 * a3) {
        ccn_shift_right(v15, v19, v19, -(int)v22 & 7LL);
      }
      int v25 = (unint64_t *)cczp_prime(v16 + 40 * v15);
      if (!ccn_sub_ws(a1, v15, v39, v19->i64, v25)) {
        ccn_set(v15, v19, v39);
      }
      if (cczp_inv_ws(a1, v16 + 40 * v15)
        || (cczp_mul_ws(a1, v16 + 40 * v15),
            cczp_mul_ws(a1, v16 + 40 * v15),
            int64x2_t v26 = a2 + 2,
            ccn_n(v15, &a2[2 * *v14 + 2]) != 1)
        || v26[2 * *v14] != (unint64_t *)((char *)&dword_0 + 1))
      {
LABEL_37:
        uint64_t v17 = 4294967289LL;
LABEL_39:
        uint64_t v29 = v41;
LABEL_34:
        *(void *)(a1 + 16) = v29;
        return v17;
      }

      uint64_t v27 = v16 + 40 * v15;
      uint64_t uint_internal = ccec_projectify_ws(a1, (uint64_t)v14);
      if (!(_DWORD)uint_internal)
      {
        uint64_t uint_internal = ccec_projectify_ws(a1, (uint64_t)v14);
        if (!(_DWORD)uint_internal)
        {
          if (ccec_is_point_ws(a1, v14, v42))
          {
            uint64_t v28 = *v14;
            if (ccn_cmp_public_value(*v14, v16 + 16 * *v14 + 8 * *v14, v26))
            {
              uint64_t v17 = ccec_twin_mult_ws(a1, v14, v40, v44, (uint64_t)v40, v43, v42);
              uint64_t v29 = v41;
              if ((_DWORD)v17) {
                goto LABEL_34;
              }
            }

            else
            {
              uint64_t v30 = v16 + 40 * v28;
              uint64_t v31 = *(void *)(a1 + 16);
              (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, 3 * v28);
              cczp_bitlen(v30);
              if (ccec_mult_ws(a1, (uint64_t)v14)
                || (cczp_bitlen(v30), ccec_mult_ws(a1, (uint64_t)v14)))
              {
                uint64_t v17 = 0xFFFFFFFFLL;
              }

              else
              {
                ccec_full_add_ws(a1, (uint64_t)v14);
                uint64_t v17 = 0LL;
              }

              uint64_t v29 = v41;
              *(void *)(a1 + 16) = v31;
              if ((_DWORD)v17) {
                goto LABEL_34;
              }
            }

            if (ccec_affinify_x_only_ws(a1, v14, (uint64_t)v40, (uint64_t)v40))
            {
              uint64_t v17 = 4294967289LL;
            }

            else
            {
              uint64_t v32 = cczp_prime(v27);
              if ((ccn_cmp_public_value(v15, v40, v32) & 0x80000000) == 0)
              {
                int8x16_t v33 = (unint64_t *)cczp_prime(v27);
                ccn_sub_ws(a1, v15, v40, (uint64_t *)v40, v33);
              }

              else {
                uint64_t v17 = 0LL;
              }
              ccn_write_uint_padded_ct_internal(v15, v38, v37, (char *)v36);
              ccn_write_uint_padded_ct_internal(v15, (unint64_t *)v40, v37, (char *)__s);
              cc_fault_canary_set(a8, (uint64_t)&CCEC_FAULT_CANARY, v37, (uint64_t)v36, (uint64_t)__s);
            }

            goto LABEL_34;
          }

          goto LABEL_37;
        }
      }
    }

    uint64_t v17 = uint_internal;
    goto LABEL_39;
  }

  return 4294967289LL;
}

uint64_t ccec_verify_internal_ws( uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return ccec_verify_internal_with_base_ws(a1, a2, a3, a4, a5, a6, (uint64_t)&(*a2)[2 * **a2 + 4 + **a2], a7);
}

double ccn_shift_left(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64x2_t a5)
{
  uint64_t v5 = a2 + 8 * a1;
  uint64x2_t v6 = (uint64x2_t)vdupq_n_s64(a4);
  uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(a4 - 64);
  uint64_t v8 = (unint64_t *)(a3 + 8 * a1 - 8);
  BOOL v9 = a1 == 4;
  BOOL v10 = a1 < 4;
  uint64_t v11 = a1 - 4;
  if (!v10)
  {
    if (v9)
    {
      v16.i64[0] = 0LL;
      v16.i64[1] = *(v8 - 3);
      a5 = (uint64x2_t)veorq_s8((int8x16_t)vshlq_u64(v16, v7), (int8x16_t)vshlq_u64(*(uint64x2_t *)(v8 - 3), v6));
      int8x16_t v17 = veorq_s8( (int8x16_t)vshlq_u64(*((uint64x2_t *)v8 - 1), v7),  (int8x16_t)vshlq_u64(*(uint64x2_t *)(v8 - 1), v6));
      *(uint64x2_t *)(v5 - 32) = a5;
      *(int8x16_t *)(v5 - 16) = v17;
      return *(double *)a5.i64;
    }

    do
    {
      uint64x2_t v12 = *(uint64x2_t *)(v8 - 3);
      uint64x2_t v13 = *(uint64x2_t *)(v8 - 1);
      uint64x2_t v14 = *((uint64x2_t *)v8 - 2);
      uint64x2_t v15 = *((uint64x2_t *)v8 - 1);
      v8 -= 4;
      a5 = (uint64x2_t)veorq_s8((int8x16_t)vshlq_u64(v14, v7), (int8x16_t)vshlq_u64(v12, v6));
      *(uint64x2_t *)(v5 - 32) = a5;
      *(int8x16_t *)(v5 - 16) = veorq_s8((int8x16_t)vshlq_u64(v15, v7), (int8x16_t)vshlq_u64(v13, v6));
      v5 -= 32LL;
      BOOL v10 = v11 <= 4;
      v11 -= 4LL;
    }

    while (!v10);
  }

  uint64_t v18 = v11 & 3;
  if (!v18) {
    return *(double *)a5.i64;
  }
  if (v18 == 3)
  {
    uint64x2_t v19 = *((uint64x2_t *)v8 - 1);
  }

  else
  {
    if ((v18 & 2) == 0) {
      goto LABEL_13;
    }
    v19.i64[0] = 0LL;
    v19.i64[1] = *(v8 - 1);
  }

  a5 = (uint64x2_t)veorq_s8((int8x16_t)vshlq_u64(*(uint64x2_t *)(v8 - 1), v6), (int8x16_t)vshlq_u64(v19, v7));
  v8 -= 2;
  *(uint64x2_t *)(v5 - 16) = a5;
  v5 -= 16LL;
LABEL_13:
  if ((v18 & 1) != 0)
  {
    a5.i64[0] = *v8;
    a5.i64[0] = vshlq_u64(a5, v6).u64[0];
    *(void *)(v5 - _Block_object_dispose((const void *)(v11 - 96), 8) = a5.i64[0];
  }

  return *(double *)a5.i64;
}

void *ccn_mulmod_p384(void *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v3 = a2 + 2;
  unint64_t v6 = *v3;
  unint64_t v7 = v3[1];
  v3 += 2;
  unint64_t v8 = *v3;
  unint64_t v9 = v3[1];
  unint64_t v11 = *a3;
  unint64_t v12 = a3[1];
  BOOL v10 = a3 + 2;
  unint64_t v13 = *v10;
  unint64_t v14 = v10[1];
  v10 += 2;
  unint64_t v15 = *v10;
  unint64_t v16 = v10[1];
  unsigned __int128 v17 = v5 * (unsigned __int128)v11 + ((v4 * (unsigned __int128)v11) >> 64);
  unsigned __int128 v18 = v17 + v4 * (unsigned __int128)v12;
  uint64_t v19 = __CFADD__(__CFADD__((void)v17, v4 * v12), *((void *)&v17 + 1)) | __CFADD__( (v4 * (unsigned __int128)v12) >> 64,  *((void *)&v18 + 1));
  uint64_t v20 = (v6 * (unsigned __int128)v11) >> 64;
  uint64_t v21 = *((void *)&v18 + 1) + v6 * v11;
  _BOOL1 v22 = __CFADD__(__CFADD__(*((void *)&v18 + 1), v6 * v11), v19);
  uint64_t v23 = __CFADD__(*((void *)&v18 + 1), v6 * v11) + v19;
  v22 |= __CFADD__(v20, v23);
  v23 += v20;
  BOOL v24 = v22;
  uint64_t v25 = (v5 * (unsigned __int128)v12) >> 64;
  _BOOL1 v22 = __CFADD__(v21, v5 * v12);
  unint64_t v26 = v21 + v5 * v12;
  BOOL v28 = v22;
  _BOOL1 v22 = __CFADD__(v22, v23);
  uint64_t v27 = v28 + v23;
  v22 |= __CFADD__(v25, v27);
  v27 += v25;
  BOOL v29 = v22 + v24;
  uint64_t v30 = (v4 * (unsigned __int128)v13) >> 64;
  _BOOL1 v22 = __CFADD__(v26, v4 * v13);
  unint64_t v31 = v26 + v4 * v13;
  BOOL v33 = v22;
  _BOOL1 v22 = __CFADD__(v22, v27);
  uint64_t v32 = v33 + v27;
  v22 |= __CFADD__(v30, v32);
  v32 += v30;
  BOOL v34 = v22 + v29;
  uint64_t v35 = (v7 * (unsigned __int128)v11) >> 64;
  _BOOL1 v22 = __CFADD__(v32, v7 * v11);
  uint64_t v36 = v32 + v7 * v11;
  BOOL v38 = v22;
  _BOOL1 v22 = __CFADD__(v22, v34);
  uint64_t v37 = v38 + v34;
  v22 |= __CFADD__(v35, v37);
  v37 += v35;
  BOOL v39 = v22;
  uint64_t v40 = (v6 * (unsigned __int128)v12) >> 64;
  _BOOL1 v22 = __CFADD__(v36, v6 * v12);
  uint64_t v41 = v36 + v6 * v12;
  BOOL v43 = v22;
  _BOOL1 v22 = __CFADD__(v22, v37);
  uint64_t v42 = v43 + v37;
  v22 |= __CFADD__(v40, v42);
  v42 += v40;
  BOOL v44 = v22 + v39;
  uint64_t v45 = (v5 * (unsigned __int128)v13) >> 64;
  _BOOL1 v22 = __CFADD__(v41, v5 * v13);
  uint64_t v46 = v41 + v5 * v13;
  BOOL v48 = v22;
  _BOOL1 v22 = __CFADD__(v22, v42);
  uint64_t v47 = v48 + v42;
  v22 |= __CFADD__(v45, v47);
  v47 += v45;
  BOOL v49 = v22 + v44;
  uint64_t v50 = (v4 * (unsigned __int128)v14) >> 64;
  _BOOL1 v22 = __CFADD__(v46, v4 * v14);
  unint64_t v51 = v46 + v4 * v14;
  BOOL v53 = v22;
  _BOOL1 v22 = __CFADD__(v22, v47);
  uint64_t v52 = v53 + v47;
  v22 |= __CFADD__(v50, v52);
  v52 += v50;
  BOOL v54 = v22 + v49;
  uint64_t v55 = (*v3 * (unsigned __int128)v11) >> 64;
  _BOOL1 v22 = __CFADD__(v52, *v3 * v11);
  uint64_t v56 = v52 + *v3 * v11;
  BOOL v58 = v22;
  _BOOL1 v22 = __CFADD__(v22, v54);
  uint64_t v57 = v58 + v54;
  v22 |= __CFADD__(v55, v57);
  v57 += v55;
  BOOL v59 = v22;
  uint64_t v60 = (v7 * (unsigned __int128)v12) >> 64;
  _BOOL1 v22 = __CFADD__(v56, v7 * v12);
  uint64_t v61 = v56 + v7 * v12;
  BOOL v63 = v22;
  _BOOL1 v22 = __CFADD__(v22, v57);
  uint64_t v62 = v63 + v57;
  v22 |= __CFADD__(v60, v62);
  v62 += v60;
  BOOL v64 = v22 + v59;
  uint64_t v65 = (v6 * (unsigned __int128)v13) >> 64;
  _BOOL1 v22 = __CFADD__(v61, v6 * v13);
  uint64_t v66 = v61 + v6 * v13;
  BOOL v68 = v22;
  _BOOL1 v22 = __CFADD__(v22, v62);
  uint64_t v67 = v68 + v62;
  v22 |= __CFADD__(v65, v67);
  v67 += v65;
  BOOL v69 = v22 + v64;
  uint64_t v70 = (v5 * (unsigned __int128)v14) >> 64;
  _BOOL1 v22 = __CFADD__(v66, v5 * v14);
  uint64_t v71 = v66 + v5 * v14;
  BOOL v73 = v22;
  _BOOL1 v22 = __CFADD__(v22, v67);
  uint64_t v72 = v73 + v67;
  v22 |= __CFADD__(v70, v72);
  v72 += v70;
  BOOL v74 = v22 + v69;
  uint64_t v75 = (v4 * (unsigned __int128)v15) >> 64;
  _BOOL1 v22 = __CFADD__(v71, v4 * v15);
  unint64_t v76 = v71 + v4 * v15;
  BOOL v78 = v22;
  _BOOL1 v22 = __CFADD__(v22, v72);
  uint64_t v77 = v78 + v72;
  v22 |= __CFADD__(v75, v77);
  v77 += v75;
  BOOL v79 = v22 + v74;
  uint64_t v80 = (v9 * (unsigned __int128)v11) >> 64;
  _BOOL1 v22 = __CFADD__(v77, v9 * v11);
  uint64_t v81 = v77 + v9 * v11;
  BOOL v83 = v22;
  _BOOL1 v22 = __CFADD__(v22, v79);
  uint64_t v82 = v83 + v79;
  v22 |= __CFADD__(v80, v82);
  v82 += v80;
  BOOL v84 = v22;
  uint64_t v85 = (*v3 * (unsigned __int128)v12) >> 64;
  _BOOL1 v22 = __CFADD__(v81, *v3 * v12);
  uint64_t v86 = v81 + *v3 * v12;
  BOOL v88 = v22;
  _BOOL1 v22 = __CFADD__(v22, v82);
  uint64_t v87 = v88 + v82;
  v22 |= __CFADD__(v85, v87);
  v87 += v85;
  BOOL v89 = v22 + v84;
  uint64_t v90 = (v7 * (unsigned __int128)v13) >> 64;
  _BOOL1 v22 = __CFADD__(v86, v7 * v13);
  uint64_t v91 = v86 + v7 * v13;
  BOOL v93 = v22;
  _BOOL1 v22 = __CFADD__(v22, v87);
  uint64_t v92 = v93 + v87;
  v22 |= __CFADD__(v90, v92);
  v92 += v90;
  BOOL v94 = v22 + v89;
  uint64_t v95 = (v6 * (unsigned __int128)v14) >> 64;
  _BOOL1 v22 = __CFADD__(v91, v6 * v14);
  uint64_t v96 = v91 + v6 * v14;
  BOOL v98 = v22;
  _BOOL1 v22 = __CFADD__(v22, v92);
  uint64_t v97 = v98 + v92;
  v22 |= __CFADD__(v95, v97);
  v97 += v95;
  BOOL v99 = v22 + v94;
  uint64_t v100 = (v5 * (unsigned __int128)v15) >> 64;
  _BOOL1 v22 = __CFADD__(v96, v5 * v15);
  uint64_t v101 = v96 + v5 * v15;
  BOOL v103 = v22;
  _BOOL1 v22 = __CFADD__(v22, v97);
  uint64_t v102 = v103 + v97;
  v22 |= __CFADD__(v100, v102);
  v102 += v100;
  BOOL v104 = v22 + v99;
  uint64_t v105 = (v4 * (unsigned __int128)v16) >> 64;
  _BOOL1 v22 = __CFADD__(v101, v4 * v16);
  unint64_t v106 = v101 + v4 * v16;
  BOOL v108 = v22;
  _BOOL1 v22 = __CFADD__(v22, v102);
  uint64_t v107 = v108 + v102;
  v22 |= __CFADD__(v105, v107);
  v107 += v105;
  unint64_t v109 = 0x100000001LL * v4 * v11;
  unint64_t v110 = HIDWORD(v109);
  unint64_t v111 = HIDWORD(v109) + __CFADD__(v4 * v11, (v4 * v11) << 32) + (void)v18;
  unsigned __int128 v112 = __PAIR128__( v51,  __CFADD__(__CFADD__(v4 * v11, (v4 * v11) << 32), (void)v18) | __CFADD__( HIDWORD(v109),  __CFADD__( v4 * v11,  (v4 * v11) << 32)
                                                                                            + (void)v18))
       + v31;
  BOOL v113 = __CFADD__( __CFADD__( __CFADD__(__CFADD__(v4 * v11, (v4 * v11) << 32), (void)v18) | __CFADD__( HIDWORD(v109),  __CFADD__( v4 * v11,  (v4 * v11) << 32)
                                                                                              + (void)v18),
             v31),
           v51);
  unsigned __int128 v114 = __PAIR128__(v106, v113) + v76;
  BOOL v116 = __CFADD__(__CFADD__(v113, v76), v106);
  unint64_t v115 = v109 + v116 + v107;
  unint64_t v117 = (__CFADD__(v116, v107) | __CFADD__(v109, v116 + v107)) + v22 + v104;
  _BOOL1 v22 = v111 >= (v4 * v11) << 32;
  unsigned __int128 v120 = __PAIR128__(v112, v111) - __PAIR128__(v109, (v4 * v11) << 32);
  unint64_t v119 = v120 >> 64;
  uint64_t v118 = v120;
  BOOL v121 = !__CFSUB__((void)v112, v109, v22);
  _BOOL1 v22 = v119 >= v110;
  unsigned __int128 v124 = __PAIR128__(*((unint64_t *)&v112 + 1), v119) - __PAIR128__(v121, v110);
  uint64_t v123 = v124 >> 64;
  uint64_t v122 = v124;
  _BOOL1 v126 = __CFSUB__(*((void *)&v112 + 1), v121, v22);
  unint64_t v125 = v114 - !v126;
  BOOL v128 = (unint64_t)v114 >= !v126;
  unint64_t v127 = *((void *)&v114 + 1) - !v128;
  unsigned __int128 v129 = __PAIR128__(v117, v115) - (*((void *)&v114 + 1) < (unint64_t)!v128);
  unsigned __int128 v130 = v129 + v9 * (unsigned __int128)v12;
  unsigned __int128 v131 = v130 + v8 * (unsigned __int128)v13;
  unsigned __int128 v132 = v131 + v7 * (unsigned __int128)v14;
  unsigned __int128 v133 = v132 + v6 * (unsigned __int128)v15;
  unsigned __int128 v134 = v133 + v5 * (unsigned __int128)v16;
  uint64_t v135 = 0x100000001LL * v118;
  unint64_t v136 = (unint64_t)(0x100000001LL * v118) >> 32;
  _BOOL1 v22 = __CFADD__(__CFADD__(v118, v118 << 32), v122);
  unint64_t v137 = __CFADD__(v118, v118 << 32) + v122;
  v22 |= __CFADD__(v136, v137);
  v137 += v136;
  uint64_t v138 = v22 + v123;
  BOOL v139 = __CFADD__(v22, v123);
  unsigned __int128 v140 = __PAIR128__(v127, v139) + v125;
  BOOL v142 = __CFADD__(__CFADD__(v139, v125), v127);
  unint64_t v141 = v142 + v134;
  uint64_t v143 = v135 + __CFADD__(v142, (void)v134) + *((void *)&v134 + 1);
  unint64_t v144 = (__CFADD__(__CFADD__(v142, (void)v134), *((void *)&v134 + 1)) | __CFADD__( v135,  __CFADD__( v142,  (void)v134)
                                                                                              + *((void *)&v134 + 1)))
       + (__CFADD__(__CFADD__((void)v133, v5 * v16), *((void *)&v133 + 1)) | __CFADD__( (v5 * (unsigned __int128)v16) >> 64,  *((void *)&v134 + 1)))
       + (__CFADD__(__CFADD__((void)v132, v6 * v15), *((void *)&v132 + 1)) | __CFADD__( (v6 * (unsigned __int128)v15) >> 64,  *((void *)&v133 + 1)))
       + (__CFADD__(__CFADD__((void)v131, v7 * v14), *((void *)&v131 + 1)) | __CFADD__( (v7 * (unsigned __int128)v14) >> 64,  *((void *)&v132 + 1)))
       + (__CFADD__(__CFADD__((void)v130, v8 * v13), *((void *)&v130 + 1)) | __CFADD__( (v8 * (unsigned __int128)v13) >> 64,  *((void *)&v131 + 1)))
       + (unint64_t)(__CFADD__(__CFADD__((void)v129, v9 * v12), *((void *)&v129 + 1)) | __CFADD__((v9 * (unsigned __int128)v12) >> 64, *((void *)&v130 + 1)));
  _BOOL1 v22 = v137 >= v135 << 32;
  unint64_t v145 = v137 - (v135 << 32);
  LOBYTE(v142) = v22;
  _BOOL1 v22 = __CFSUB__(v138, v135, v22);
  unint64_t v146 = v138 - (v135 + !v142);
  uint64_t v147 = !v22;
  _BOOL1 v22 = v146 >= v136;
  unsigned __int128 v150 = __PAIR128__(v140, v146) - __PAIR128__(v147, v136);
  uint64_t v149 = v150 >> 64;
  uint64_t v148 = v150;
  _BOOL1 v152 = __CFSUB__((void)v140, v147, v22);
  unint64_t v151 = *((void *)&v140 + 1) - !v152;
  BOOL v154 = *((void *)&v140 + 1) >= (unint64_t)!v152;
  _BOOL1 v22 = v141 >= !v154;
  unint64_t v153 = v141 - !v154;
  unsigned __int128 v155 = __PAIR128__(v144, v143) - !v22;
  unsigned __int128 v156 = v155 + v9 * (unsigned __int128)v13;
  unsigned __int128 v157 = v156 + v8 * (unsigned __int128)v14;
  unsigned __int128 v158 = v157 + v7 * (unsigned __int128)v15;
  unsigned __int128 v159 = v158 + v6 * (unsigned __int128)v16;
  uint64_t v160 = 0x100000001LL * v145;
  unint64_t v161 = (0x100000001LL * v145) >> 32;
  _BOOL1 v22 = __CFADD__(__CFADD__(v145, v145 << 32), v148);
  unint64_t v162 = __CFADD__(v145, v145 << 32) + v148;
  v22 |= __CFADD__(v161, v162);
  v162 += v161;
  uint64_t v163 = v22 + v149;
  BOOL v164 = __CFADD__(v22, v149);
  unsigned __int128 v165 = __PAIR128__(v153, v164) + v151;
  BOOL v167 = __CFADD__(__CFADD__(v164, v151), v153);
  unint64_t v166 = v167 + v159;
  uint64_t v168 = v160 + __CFADD__(v167, (void)v159) + *((void *)&v159 + 1);
  unint64_t v169 = (__CFADD__(__CFADD__(v167, (void)v159), *((void *)&v159 + 1)) | __CFADD__( v160,  __CFADD__( v167,  (void)v159)
                                                                                              + *((void *)&v159 + 1)))
       + (__CFADD__(__CFADD__((void)v158, v6 * v16), *((void *)&v158 + 1)) | __CFADD__( (v6 * (unsigned __int128)v16) >> 64,  *((void *)&v159 + 1)))
       + (__CFADD__(__CFADD__((void)v157, v7 * v15), *((void *)&v157 + 1)) | __CFADD__( (v7 * (unsigned __int128)v15) >> 64,  *((void *)&v158 + 1)))
       + (__CFADD__(__CFADD__((void)v156, v8 * v14), *((void *)&v156 + 1)) | __CFADD__( (v8 * (unsigned __int128)v14) >> 64,  *((void *)&v157 + 1)))
       + (unint64_t)(__CFADD__(__CFADD__((void)v155, v9 * v13), *((void *)&v155 + 1)) | __CFADD__((v9 * (unsigned __int128)v13) >> 64, *((void *)&v156 + 1)));
  _BOOL1 v22 = v162 >= v160 << 32;
  unint64_t v170 = v162 - (v160 << 32);
  LOBYTE(v167) = v22;
  _BOOL1 v22 = __CFSUB__(v163, v160, v22);
  unint64_t v171 = v163 - (v160 + !v167);
  uint64_t v172 = !v22;
  _BOOL1 v22 = v171 >= v161;
  unsigned __int128 v175 = __PAIR128__(v165, v171) - __PAIR128__(v172, v161);
  uint64_t v174 = v175 >> 64;
  uint64_t v173 = v175;
  _BOOL1 v177 = __CFSUB__((void)v165, v172, v22);
  unint64_t v176 = *((void *)&v165 + 1) - !v177;
  BOOL v179 = *((void *)&v165 + 1) >= (unint64_t)!v177;
  _BOOL1 v22 = v166 >= !v179;
  unint64_t v178 = v166 - !v179;
  unsigned __int128 v180 = __PAIR128__(v169, v168) - !v22;
  unsigned __int128 v181 = v180 + v9 * (unsigned __int128)v14;
  unsigned __int128 v182 = v181 + v8 * (unsigned __int128)v15;
  unsigned __int128 v183 = v182 + v7 * (unsigned __int128)v16;
  uint64_t v184 = 0x100000001LL * v170;
  unint64_t v185 = (0x100000001LL * v170) >> 32;
  _BOOL1 v22 = __CFADD__(__CFADD__(v170, v170 << 32), v173);
  unint64_t v186 = __CFADD__(v170, v170 << 32) + v173;
  v22 |= __CFADD__(v185, v186);
  v186 += v185;
  uint64_t v187 = v22 + v174;
  BOOL v188 = __CFADD__(v22, v174);
  unsigned __int128 v189 = __PAIR128__(v178, v188) + v176;
  BOOL v191 = __CFADD__(__CFADD__(v188, v176), v178);
  unint64_t v190 = v191 + v183;
  uint64_t v192 = v184 + __CFADD__(v191, (void)v183) + *((void *)&v183 + 1);
  unint64_t v193 = (__CFADD__(__CFADD__(v191, (void)v183), *((void *)&v183 + 1)) | __CFADD__( v184,  __CFADD__( v191,  (void)v183)
                                                                                              + *((void *)&v183 + 1)))
       + (__CFADD__(__CFADD__((void)v182, v7 * v16), *((void *)&v182 + 1)) | __CFADD__( (v7 * (unsigned __int128)v16) >> 64,  *((void *)&v183 + 1)))
       + (__CFADD__(__CFADD__((void)v181, v8 * v15), *((void *)&v181 + 1)) | __CFADD__( (v8 * (unsigned __int128)v15) >> 64,  *((void *)&v182 + 1)))
       + (unint64_t)(__CFADD__(__CFADD__((void)v180, v9 * v14), *((void *)&v180 + 1)) | __CFADD__((v9 * (unsigned __int128)v14) >> 64, *((void *)&v181 + 1)));
  _BOOL1 v22 = v186 >= v184 << 32;
  unint64_t v194 = v186 - (v184 << 32);
  LOBYTE(v191) = v22;
  _BOOL1 v22 = __CFSUB__(v187, v184, v22);
  unint64_t v195 = v187 - (v184 + !v191);
  uint64_t v196 = !v22;
  _BOOL1 v22 = v195 >= v185;
  unsigned __int128 v199 = __PAIR128__(v189, v195) - __PAIR128__(v196, v185);
  uint64_t v198 = v199 >> 64;
  uint64_t v197 = v199;
  _BOOL1 v201 = __CFSUB__((void)v189, v196, v22);
  unint64_t v200 = *((void *)&v189 + 1) - !v201;
  BOOL v203 = *((void *)&v189 + 1) >= (unint64_t)!v201;
  _BOOL1 v22 = v190 >= !v203;
  unint64_t v202 = v190 - !v203;
  unsigned __int128 v204 = __PAIR128__(v193, v192) - !v22;
  unsigned __int128 v205 = v204 + v9 * (unsigned __int128)v15;
  unsigned __int128 v206 = v205 + v8 * (unsigned __int128)v16;
  uint64_t v207 = 0x100000001LL * v194;
  unint64_t v208 = (0x100000001LL * v194) >> 32;
  _BOOL1 v22 = __CFADD__(__CFADD__(v194, v194 << 32), v197);
  unint64_t v209 = __CFADD__(v194, v194 << 32) + v197;
  v22 |= __CFADD__(v208, v209);
  v209 += v208;
  uint64_t v210 = v22 + v198;
  BOOL v211 = __CFADD__(v22, v198);
  unsigned __int128 v212 = __PAIR128__(v202, v211) + v200;
  BOOL v214 = __CFADD__(__CFADD__(v211, v200), v202);
  unint64_t v213 = v214 + v206;
  uint64_t v215 = v207 + __CFADD__(v214, (void)v206) + *((void *)&v206 + 1);
  unint64_t v216 = (__CFADD__(__CFADD__(v214, (void)v206), *((void *)&v206 + 1)) | __CFADD__( v207,  __CFADD__( v214,  (void)v206)
                                                                                              + *((void *)&v206 + 1)))
       + (__CFADD__(__CFADD__((void)v205, v8 * v16), *((void *)&v205 + 1)) | __CFADD__( (v8 * (unsigned __int128)v16) >> 64,  *((void *)&v206 + 1)))
       + (unint64_t)(__CFADD__(__CFADD__((void)v204, v9 * v15), *((void *)&v204 + 1)) | __CFADD__((v9 * (unsigned __int128)v15) >> 64, *((void *)&v205 + 1)));
  _BOOL1 v22 = v209 >= v207 << 32;
  unint64_t v217 = v209 - (v207 << 32);
  LOBYTE(v214) = v22;
  _BOOL1 v22 = __CFSUB__(v210, v207, v22);
  unint64_t v218 = v210 - (v207 + !v214);
  uint64_t v219 = !v22;
  _BOOL1 v22 = v218 >= v208;
  unsigned __int128 v222 = __PAIR128__(v212, v218) - __PAIR128__(v219, v208);
  uint64_t v221 = v222 >> 64;
  uint64_t v220 = v222;
  _BOOL1 v224 = __CFSUB__((void)v212, v219, v22);
  unint64_t v223 = *((void *)&v212 + 1) - !v224;
  BOOL v226 = *((void *)&v212 + 1) >= (unint64_t)!v224;
  _BOOL1 v22 = v213 >= !v226;
  unint64_t v225 = v213 - !v226;
  unsigned __int128 v227 = __PAIR128__(v216, v215) - !v22;
  unsigned __int128 v228 = v227 + v9 * (unsigned __int128)v16;
  uint64_t v229 = 0x100000001LL * v217;
  unint64_t v230 = (0x100000001LL * v217) >> 32;
  _BOOL1 v22 = __CFADD__(__CFADD__(v217, v217 << 32), v220);
  unint64_t v231 = __CFADD__(v217, v217 << 32) + v220;
  v22 |= __CFADD__(v230, v231);
  v231 += v230;
  uint64_t v232 = v22 + v221;
  BOOL v233 = __CFADD__(v22, v221);
  unsigned __int128 v234 = __PAIR128__(v225, v233) + v223;
  BOOL v236 = __CFADD__(__CFADD__(v233, v223), v225);
  unint64_t v235 = v236 + v228;
  uint64_t v237 = v229 + __CFADD__(v236, (void)v228) + *((void *)&v228 + 1);
  unint64_t v238 = (__CFADD__(__CFADD__(v236, (void)v228), *((void *)&v228 + 1)) | __CFADD__( v229,  __CFADD__( v236,  (void)v228)
                                                                                              + *((void *)&v228 + 1)))
       + (unint64_t)(__CFADD__(__CFADD__((void)v227, v9 * v16), *((void *)&v227 + 1)) | __CFADD__((v9 * (unsigned __int128)v16) >> 64, *((void *)&v228 + 1)));
  _BOOL1 v22 = v231 >= v229 << 32;
  unint64_t v239 = v231 - (v229 << 32);
  LOBYTE(v236) = v22;
  _BOOL1 v22 = __CFSUB__(v232, v229, v22);
  unint64_t v240 = v232 - (v229 + !v236);
  uint64_t v241 = !v22;
  _BOOL1 v22 = v240 >= v230;
  unsigned __int128 v244 = __PAIR128__(v234, v240) - __PAIR128__(v241, v230);
  uint64_t v243 = v244 >> 64;
  uint64_t v242 = v244;
  _BOOL1 v246 = __CFSUB__((void)v234, v241, v22);
  uint64_t v245 = *((void *)&v234 + 1) - !v246;
  BOOL v248 = *((void *)&v234 + 1) >= (unint64_t)!v246;
  _BOOL1 v22 = v235 >= !v248;
  unint64_t v247 = v235 - !v248;
  unsigned __int128 v249 = __PAIR128__(v238, v237) - !v22;
  _BOOL1 v22 = v239 >= 0xFFFFFFFF;
  unint64_t v250 = v239 - 0xFFFFFFFF;
  _BOOL1 v252 = v22;
  _BOOL1 v22 = __CFSUB__(v242, 0xFFFFFFFF00000000LL, v22);
  uint64_t v251 = v242 - (!v252 - 0x100000000LL);
  _BOOL1 v254 = v22;
  _BOOL1 v22 = __CFSUB__(v243, -2LL, v22);
  uint64_t v253 = v243 - (!v254 - 2LL);
  _BOOL1 v256 = v22;
  _BOOL1 v22 = __CFSUB__(v245, -1LL, v22);
  uint64_t v255 = v245 - (!v256 - 1LL);
  _BOOL1 v258 = v22;
  _BOOL1 v22 = __CFSUB__(v247, -1LL, v22);
  unint64_t v257 = v247 - (!v258 - 1LL);
  uint64_t v259 = v249 - (!v22 - 1LL);
  uint64_t v260 = *((void *)&v249 + 1) - !__CFSUB__((void)v249, -1LL, v22);
  _BOOL1 v22 = __CFADD__(__CFADD__(v250, (v260 & 0xFFFFFFFF00000000LL) >> 32), v251);
  uint64_t v261 = __CFADD__(v250, (v260 & 0xFFFFFFFF00000000LL) >> 32) + v251;
  uint64_t v263 = v22 | __CFADD__(v260 & 0xFFFFFFFF00000000LL, v261);
  _BOOL1 v22 = __CFADD__(v263, v253);
  uint64_t v262 = v263 + v253;
  uint64_t v265 = v22 | __CFADD__(v260 & 0xFFFFFFFFFFFFFFFELL, v262);
  _BOOL1 v22 = __CFADD__(v265, v255);
  uint64_t v264 = v265 + v255;
  uint64_t v267 = v22 | __CFADD__(v260, v264);
  _BOOL1 v22 = __CFADD__(v267, v257);
  uint64_t v266 = v267 + v257;
  *a1 = v250 + ((v260 & 0xFFFFFFFF00000000LL) >> 32);
  a1[1] = (v260 & 0xFFFFFFFF00000000LL) + v261;
  v268 = a1 + 2;
  void *v268 = (v260 & 0xFFFFFFFFFFFFFFFELL) + v262;
  v268[1] = v260 + v264;
  uint64_t result = v268 + 2;
  *uint64_t result = v260 + v266;
  result[1] = v260 + (v22 | __CFADD__(v260, v266)) + v259;
  return result;
}

uint64_t cc_clear(rsize_t __n, void *__s)
{
  return memset_s(__s, __n, 0, __n);
}

uint64_t ccn_cond_add(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  masuint64_t k = ccn_mux_next_mask();
  uint64_t v11 = __ROR8__(0x5555555555555555LL, a2 | (2 * mask));
  uint64_t v12 = 0LL;
  if (a1)
  {
    uint64_t v13 = 0LL;
    do
    {
      uint64_t v15 = *a4++;
      uint64_t v14 = v15;
      uint64_t v17 = *a5++;
      uint64_t v16 = v17;
      BOOL v18 = __CFADD__(v12, v14);
      uint64_t v19 = v12 + v14;
      if (v18) {
        uint64_t v13 = 1LL;
      }
      BOOL v18 = __CFADD__(v19, v16);
      uint64_t v20 = v19 + v16;
      if (v18) {
        uint64_t v12 = v13 + 1;
      }
      else {
        uint64_t v12 = v13;
      }
      uint64_t v21 = v14 ^ v20;
      uint64_t v22 = v14 ^ mask;
      *a3 = v22;
      *a3++ = v21 & v11 ^ v21 & 0x5555555555555555LL ^ v22 ^ mask;
      uint64_t v13 = 0LL;
      --a1;
    }

    while (a1);
  }

  return v12 & a2;
}

uint64_t ccec_sign_composite_ws( uint64_t a1, unint64_t **a2, unint64_t a3, uint64_t a4, char *a5, char *a6, uint64_t (**a7)(void, unint64_t, void *))
{
  unint64_t v14 = **a2;
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v16 = (unint64_t *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  uint64_t v17 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, v14);
  uint64_t v18 = ccec_sign_internal_ws(a1, (uint64_t **)a2, a3, a4, v16, v17, a7);
  if (!(_DWORD)v18)
  {
    unint64_t v19 = **a2;
    unint64_t v20 = ccec_signature_r_s_size((uint64_t *)a2);
    ccn_write_uint_padded_ct_internal(v19, v16, v20, a5);
    unint64_t v21 = **a2;
    unint64_t v22 = ccec_signature_r_s_size((uint64_t *)a2);
    ccn_write_uint_padded_ct_internal(v21, (unint64_t *)v17, v22, a6);
  }

  *(void *)(a1 + 16) = v15;
  return v18;
}

uint64_t ccec_sign_composite_msg_ws( uint64_t a1, unint64_t **a2, unint64_t *a3, size_t a4, char *a5, char *a6, char *a7, uint64_t (**a8)(void, unint64_t, void *))
{
  return ccec_sign_composite_ws(a1, a2, *a3, (uint64_t)v15, a6, a7, a8);
}

uint64_t cczp_is_quadratic_residue_ws(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = cczp_n(a2);
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  unint64_t v9 = (void *)cczp_prime(a2);
  ccn_set(v6, v8, v9);
  v8->i64[0] &= ~1uLL;
  BOOL v10 = (int8x16_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  ccn_shift_right(v6, v10, v8, 1LL);
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v6);
  unsigned int v12 = cczp_power_fast_ws(a1, a2, v11, a3, (uint64_t)v10);
  cczp_from_ws(a1, a2);
  BOOL v13 = ccn_n(v6, v11) == 1 && *v11 == 1LL;
  uint64_t result = v13 & ~(((v12 | ((unint64_t)(int)v12 >> 32)) + 0xFFFFFFFF) >> 32);
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t ccdrbg_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

uint64_t ccdrbg_reseed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 16))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t ccdrbg_generate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v14 = timingsafe_enable_if_supported();
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, a3, a4, a5, a6);
  cc_disable_dit_with_sb((unsigned int *)&v14);
  return v12;
}

uint64_t cczp_add_default_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = cczp_n(a2);
  uint64_t v12 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v11);
  LOBYTE(a5) = ccn_add_ws(a1, v11, a3, a4, a5);
  BOOL v13 = (unint64_t *)cczp_prime(a2);
  BOOL v14 = ccn_sub_ws(a1, v11, v12, a3, v13);
  uint64_t result = ccn_mux(v11, !v14 | a5, a3, v12, a3);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_add_ws(uint64_t a1, uint64_t a2)
{
  return (**(uint64_t (***)(void))(a2 + 16))();
}

void *ccec_cp_384_asm()
{
  return &ccec_cp384_asm;
}

void *ccn_p384_mul_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, unint64_t *a5)
{
  return ccn_mulmod_p384(a3, a4, a5);
}

void *ccn_p384_sqr_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  return ccn_mulmod_p384(a3, a4, a4);
}

uint64_t ccn_p384_inv_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 6LL);
  unint64_t v9 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 6LL);
  uint64_t v10 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 6LL);
  ccn_mulmod_p384(v10, a4, a4);
  ccn_mulmod_p384(v9, v10, a4);
  ccn_mulmod_p384(v9, v9, v9);
  ccn_mulmod_p384(v9, v9, v9);
  ccn_mulmod_p384(v8, v9, a4);
  ccn_mulmod_p384(v9, v8, v10);
  int v11 = 4;
  do
  {
    ccn_mulmod_p384(v9, v9, v9);
    --v11;
  }

  while (v11);
  ccn_mulmod_p384(v8, v8, v9);
  ccn_mulmod_p384(v9, v8, v10);
  int v12 = 8;
  do
  {
    ccn_mulmod_p384(v9, v9, v9);
    --v12;
  }

  while (v12);
  ccn_mulmod_p384(v8, v8, v9);
  ccn_mulmod_p384(v9, v8, v10);
  int v13 = 16;
  do
  {
    ccn_mulmod_p384(v9, v9, v9);
    --v13;
  }

  while (v13);
  ccn_mulmod_p384(v8, v8, v9);
  ccn_mulmod_p384(v9, v8, a4);
  ccn_mulmod_p384(v10, v9, a4);
  int v14 = 32;
  do
  {
    ccn_mulmod_p384(v10, v10, v10);
    --v14;
  }

  while (v14);
  ccn_mulmod_p384(v9, v10, v9);
  int v15 = 64;
  do
  {
    ccn_mulmod_p384(v10, v10, v10);
    --v15;
  }

  while (v15);
  ccn_mulmod_p384(v10, v10, v8);
  ccn_mulmod_p384(v8, v9, a4);
  int v16 = 64;
  do
  {
    ccn_mulmod_p384(v8, v8, v8);
    --v16;
  }

  while (v16);
  ccn_mulmod_p384(v9, v8, v9);
  ccn_mulmod_p384(v8, v9, a4);
  int v17 = 128;
  do
  {
    ccn_mulmod_p384(v8, v8, v8);
    --v17;
  }

  while (v17);
  ccn_mulmod_p384(v8, v8, v9);
  int v18 = 128;
  do
  {
    ccn_mulmod_p384(v8, v8, v8);
    --v18;
  }

  while (v18);
  ccn_mulmod_p384(v9, v8, v10);
  ccn_mulmod_p384(v8, v9, a4);
  uint64_t v23 = 0LL;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  unint64_t v20 = 1LL;
  ccn_mulmod_p384(v8, v8, &v20);
  if (ccn_n(6LL, v8) == 1 && *v8 == 1)
  {
    ccn_set(6LL, a3, v9);
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = 4294967254LL;
  }

  *(void *)(a1 + 16) = v7;
  return result;
}

void *ccn_p384_from_asm_ws(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v8 = 0LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  unint64_t v5 = 1LL;
  return ccn_mulmod_p384(a3, a4, &v5);
}

uint64_t cczp_div2_ws(uint64_t a1, uint64_t a2, int8x16_t *a3, uint64_t *a4)
{
  uint64_t v7 = cczp_n(a2);
  uint64_t v8 = *a4 & 1;
  unint64_t v9 = (uint64_t *)cczp_prime(a2);
  uint64_t v10 = ccn_cond_add(v7, v8, a3->i64, a4, v9);
  uint64_t result = ccn_shift_right(v7, a3, a3, 1LL);
  a3->i64[v7 - 1] |= v10 << 63;
  return result;
}

uint64_t cczp_modn_ws(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4, char *a5)
{
  unint64_t v10 = cczp_n((uint64_t)a2);
  uint64_t v11 = v10;
  if ((a4 - 1) / v10 <= 1) {
    unint64_t v12 = 1LL;
  }
  else {
    unint64_t v12 = (a4 - 1) / v10;
  }
  uint64_t v17 = a4;
  uint64_t v18 = *(void *)(a1 + 16);
  int v13 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v10);
  unint64_t v19 = a5;
  ccn_set(v11, v13, a5);
  unint64_t v14 = v12 - 1;
  if (v12 != 1)
  {
    int v15 = &v19[8 * v11];
    do
    {
      ccn_set(v11, &v13[8 * v11], v15);
      cczp_mm_redc_ws(a1, a2, (uint64_t *)v13, (uint64_t *)v13);
      v15 += 8 * v11;
      --v14;
    }

    while (v14);
  }

  if (v17 != v12 * v11) {
    ccn_set(v17 - v12 * v11, &v13[8 * v11], &v19[8 * v12 * v11]);
  }
  ccn_zero(v11 - (v17 - v12 * v11), &v13[8 * v11 + 8 * (v17 - v12 * v11)]);
  cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v13);
  do
  {
    ccn_mul_ws(a1, v11, (uint64_t)v13, (uint64_t)a3, (uint64_t)&a2[*a2 + 4]);
    uint64_t result = cczp_mm_redc_ws(a1, a2, a3, (uint64_t *)v13);
    --v12;
  }

  while (v12);
  *(void *)(a1 + 16) = v18;
  return result;
}

uint64_t cczp_mod_default_ws(uint64_t a1, void *a2, uint64_t *a3, char *a4)
{
  uint64_t v8 = 2 * cczp_n((uint64_t)a2);
  return cczp_modn_ws(a1, a2, a3, v8, a4);
}

uint64_t cczp_mod_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 32LL))();
}

uint64_t cczp_mul_default_ws(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = cczp_n(a2);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, 2 * v10);
  uint64_t v12 = cczp_n(a2);
  ccn_mul_ws(a1, v12, v11, a4, a5);
  uint64_t result = cczp_mod_ws(a1, a2);
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t cczp_mul_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 16LL))();
}

_OWORD *ccn_mulmod_p256(void *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v3 = a2 + 2;
  unint64_t v6 = *v3;
  unint64_t v7 = v3[1];
  unint64_t v9 = *a3;
  unint64_t v10 = a3[1];
  uint64_t v8 = a3 + 2;
  unint64_t v11 = *v8;
  unint64_t v12 = v8[1];
  unint64_t v13 = v4 * v9;
  uint64_t v14 = (v5 * (unsigned __int128)v9) >> 64;
  uint64_t v15 = *v3 * v9;
  uint64_t v16 = (v6 * (unsigned __int128)v9) >> 64;
  unint64_t v18 = v9;
  uint64_t v17 = (__PAIR128__(v5, v4) * v9) >> 64;
  _BOOL1 v19 = __CFADD__(__CFADD__((v4 * (unsigned __int128)v9) >> 64, v5 * v9), v14);
  uint64_t v20 = __CFADD__((v4 * (unsigned __int128)v9) >> 64, v5 * v9) + v14;
  v19 |= __CFADD__(v15, v20);
  v20 += v15;
  uint64_t v21 = (v7 * (unsigned __int128)v9) >> 64;
  uint64_t v22 = (v7 * (unsigned __int128)v10) >> 64;
  BOOL v24 = v19;
  _BOOL1 v19 = __CFADD__(v19, v16);
  uint64_t v23 = v24 + v16;
  v19 |= __CFADD__(v7 * v9, v23);
  v23 += v7 * v9;
  BOOL v26 = v19;
  _BOOL1 v19 = __CFADD__(v19, v21);
  uint64_t v25 = v26 + v21;
  v19 |= __CFADD__(v7 * v10, v25);
  v25 += v7 * v10;
  uint64_t v27 = v7 * *v8;
  uint64_t v28 = (v7 * (unsigned __int128)v11) >> 64;
  BOOL v30 = v19;
  _BOOL1 v19 = __CFADD__(v19, v22);
  uint64_t v29 = v30 + v22;
  v19 |= __CFADD__(v27, v29);
  v29 += v27;
  BOOL v32 = v19;
  _BOOL1 v19 = __CFADD__(v19, v28);
  uint64_t v31 = v32 + v28;
  v19 |= __CFADD__(v7 * v12, v31);
  v31 += v7 * v12;
  uint64_t v33 = v19 + ((v7 * (unsigned __int128)v12) >> 64);
  uint64_t v34 = (v4 * (unsigned __int128)v10) >> 64;
  _BOOL1 v19 = __CFADD__(v17, v4 * v10);
  uint64_t v35 = (__PAIR128__(v10, v18) * __PAIR128__(v5, v4)) >> 64;
  BOOL v37 = v19;
  _BOOL1 v19 = __CFADD__(v19, v20);
  uint64_t v36 = v37 + v20;
  v19 |= __CFADD__(v34, v36);
  v36 += v34;
  uint64_t v38 = (v6 * (unsigned __int128)v10) >> 64;
  BOOL v40 = v19;
  _BOOL1 v19 = __CFADD__(v19, v23);
  uint64_t v39 = v40 + v23;
  v19 |= __CFADD__(v6 * v10, v39);
  v39 += v6 * v10;
  BOOL v42 = v19;
  _BOOL1 v19 = __CFADD__(v19, v25);
  uint64_t v41 = v42 + v25;
  v19 |= __CFADD__(v38, v41);
  v41 += v38;
  uint64_t v43 = (v6 * (unsigned __int128)v12) >> 64;
  BOOL v45 = v19;
  _BOOL1 v19 = __CFADD__(v19, v29);
  uint64_t v44 = v45 + v29;
  v19 |= __CFADD__(v6 * v12, v44);
  v44 += v6 * v12;
  BOOL v47 = v19;
  _BOOL1 v19 = __CFADD__(v19, v31);
  uint64_t v46 = v47 + v31;
  v19 |= __CFADD__(v43, v46);
  v46 += v43;
  uint64_t v48 = v19 + v33;
  uint64_t v49 = (v5 * (unsigned __int128)v10) >> 64;
  _BOOL1 v19 = __CFADD__(v36, v5 * v10);
  uint64_t v50 = v36 + v5 * v10;
  BOOL v52 = v19;
  _BOOL1 v19 = __CFADD__(v19, v39);
  uint64_t v51 = v52 + v39;
  v19 |= __CFADD__(v49, v51);
  v51 += v49;
  uint64_t v53 = (v6 * (unsigned __int128)v11) >> 64;
  BOOL v55 = v19;
  _BOOL1 v19 = __CFADD__(v19, v41);
  uint64_t v54 = v55 + v41;
  v19 |= __CFADD__(v6 * v11, v54);
  v54 += v6 * v11;
  BOOL v57 = v19;
  _BOOL1 v19 = __CFADD__(v19, v44);
  uint64_t v56 = v57 + v44;
  v19 |= __CFADD__(v53, v56);
  v56 += v53;
  BOOL v58 = v19;
  uint64_t v59 = (v4 * (unsigned __int128)v11) >> 64;
  _BOOL1 v19 = __CFADD__(v50, v4 * v11);
  uint64_t v60 = v50 + v4 * v11;
  BOOL v62 = v19;
  _BOOL1 v19 = __CFADD__(v19, v51);
  uint64_t v61 = v62 + v51;
  v19 |= __CFADD__(v59, v61);
  v61 += v59;
  uint64_t v63 = (v5 * (unsigned __int128)v12) >> 64;
  BOOL v65 = v19;
  _BOOL1 v19 = __CFADD__(v19, v54);
  uint64_t v64 = v65 + v54;
  v19 |= __CFADD__(v5 * v12, v64);
  v64 += v5 * v12;
  BOOL v67 = v19;
  _BOOL1 v19 = __CFADD__(v19, v56);
  uint64_t v66 = v67 + v56;
  v19 |= __CFADD__(v63, v66);
  v66 += v63;
  uint64_t v68 = v19 + v58;
  uint64_t v69 = (v5 * (unsigned __int128)v11) >> 64;
  _BOOL1 v19 = __CFADD__(v61, v5 * v11);
  uint64_t v70 = v61 + v5 * v11;
  BOOL v72 = v19;
  _BOOL1 v19 = __CFADD__(v19, v64);
  uint64_t v71 = v72 + v64;
  v19 |= __CFADD__(v69, v71);
  v71 += v69;
  uint64_t v73 = v19;
  uint64_t v74 = (v4 * (unsigned __int128)v12) >> 64;
  _BOOL1 v19 = __CFADD__(v70, v4 * v12);
  uint64_t v75 = v70 + v4 * v12;
  BOOL v77 = v19;
  _BOOL1 v19 = __CFADD__(v19, v71);
  uint64_t v76 = v77 + v71;
  v19 |= __CFADD__(v74, v76);
  v76 += v74;
  BOOL v79 = v19;
  _BOOL1 v19 = __CFADD__(v19, v66);
  uint64_t v78 = v79 + v66;
  v19 |= __CFADD__(v73, v78);
  v78 += v73;
  BOOL v81 = v19;
  _BOOL1 v19 = __CFADD__(v19, v46);
  uint64_t v80 = v81 + v46;
  v19 |= __CFADD__(v68, v80);
  v80 += v68;
  uint64_t v82 = v19 + v48;
  _BOOL1 v19 = __CFADD__(v35, v13 << 32);
  unint64_t v83 = v35 + (v13 << 32);
  BOOL v85 = v19;
  _BOOL1 v19 = __CFADD__(v19, v60);
  uint64_t v84 = v85 + v60;
  v19 |= __CFADD__(HIDWORD(v13), v84);
  v84 += HIDWORD(v13);
  BOOL v87 = v19;
  _BOOL1 v19 = __CFADD__(v19, v75);
  uint64_t v86 = v87 + v75;
  v19 |= __CFADD__(0xFFFFFFFF00000001LL * v13, v86);
  v86 += 0xFFFFFFFF00000001LL * v13;
  uint64_t v88 = v19 + ((v13 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64);
  _BOOL1 v19 = __CFADD__(v84, v83 << 32);
  unint64_t v89 = v84 + (v83 << 32);
  BOOL v91 = v19;
  _BOOL1 v19 = __CFADD__(v19, v86);
  uint64_t v90 = v91 + v86;
  v19 |= __CFADD__(HIDWORD(v83), v90);
  v90 += HIDWORD(v83);
  BOOL v93 = v19;
  _BOOL1 v19 = __CFADD__(v19, v76);
  uint64_t v92 = v93 + v76;
  v19 |= __CFADD__(0xFFFFFFFF00000001LL * v83, v92);
  v92 += 0xFFFFFFFF00000001LL * v83;
  uint64_t v94 = v19 + ((v83 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64);
  _BOOL1 v19 = __CFADD__(v90, v89 << 32);
  unint64_t v95 = v90 + (v89 << 32);
  BOOL v97 = v19;
  _BOOL1 v19 = __CFADD__(v19, v92);
  uint64_t v96 = v97 + v92;
  v19 |= __CFADD__(HIDWORD(v89), v96);
  v96 += HIDWORD(v89);
  BOOL v99 = v19;
  _BOOL1 v19 = __CFADD__(v19, v78);
  uint64_t v98 = v99 + v78;
  v19 |= __CFADD__(0xFFFFFFFF00000001LL * v89, v98);
  v98 += 0xFFFFFFFF00000001LL * v89;
  uint64_t v100 = v19 + ((v89 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64);
  _BOOL1 v19 = __CFADD__(v96, v95 << 32);
  uint64_t v101 = v96 + (v95 << 32);
  BOOL v103 = v19;
  _BOOL1 v19 = __CFADD__(v19, v98);
  uint64_t v102 = v103 + v98;
  v19 |= __CFADD__(HIDWORD(v95), v102);
  v102 += HIDWORD(v95);
  BOOL v105 = v19;
  _BOOL1 v19 = __CFADD__(v19, v80);
  uint64_t v104 = v105 + v80;
  v19 |= __CFADD__(0xFFFFFFFF00000001LL * v95, v104);
  v104 += 0xFFFFFFFF00000001LL * v95;
  uint64_t v106 = v19 + ((v95 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64);
  _BOOL1 v19 = __CFADD__(v88, v101);
  uint64_t v107 = v88 + v101;
  BOOL v109 = v19;
  _BOOL1 v19 = __CFADD__(v19, v94);
  uint64_t v108 = v109 + v94;
  v19 |= __CFADD__(v102, v108);
  v108 += v102;
  BOOL v111 = v19;
  _BOOL1 v19 = __CFADD__(v19, v100);
  unint64_t v110 = v111 + v100;
  v19 |= __CFADD__(v104, v110);
  v110 += v104;
  BOOL v113 = v19;
  _BOOL1 v19 = __CFADD__(v19, v106);
  uint64_t v112 = v113 + v106;
  v19 |= __CFADD__(v82, v112);
  v112 += v82;
  BOOL v114 = v19;
  _BOOL1 v19 = __CFADD__(v107++, 1LL);
  LOBYTE(v113) = v19;
  _BOOL1 v19 = __CFSUB__(v108, 0xFFFFFFFFLL, v19);
  uint64_t v115 = v108 - (!v113 + 0xFFFFFFFFLL);
  LOBYTE(v113) = v19;
  _BOOL1 v19 = v110 >= !v19;
  unint64_t v116 = v110 - !v113;
  LOBYTE(v113) = v19;
  _BOOL1 v19 = __CFSUB__(v112, 0xFFFFFFFF00000001LL, v19);
  BOOL v117 = v114 - !v19;
  uint64_t v118 = v114 - !v19;
  _BOOL1 v19 = __CFADD__(__CFADD__(v107, v117), v115);
  uint64_t v119 = __CFADD__(v107, v117) + v115;
  *a1 = v107 + v117;
  a1[1] = v118 + v119;
  uint64_t result = a1 + 2;
  return result;
}

uint64_t cccmac_update_internal(void *a1, unint64_t a2, char *__src)
{
  uint64_t result = 0LL;
  if (a2)
  {
    unint64_t v5 = __src;
    if (__src)
    {
      unint64_t v6 = a2;
      unint64_t v7 = (void *)a1[8];
      memset(&v12[2], 0, 224);
      unint64_t v8 = a1[6];
      if (16 - v8 >= a2) {
        size_t v9 = a2;
      }
      else {
        size_t v9 = 16 - v8;
      }
      memset(v12, 0, 32);
      if (v8 > 0x10) {
        return 0xFFFFFFFFLL;
      }
      if (v8)
      {
        memcpy((char *)a1 + v8 + 32, __src, v9);
        a1[6] += v9;
        v6 -= v9;
        if (!v6) {
          return 0LL;
        }
        v5 += v9;
        cccbc_update_internal( (uint64_t)v7,  (uint64_t)(a1 + 9),  (uint64_t)a1 + *v7 + 72,  1LL,  (uint64_t)(a1 + 4),  (uint64_t)v12);
        a1[7] += 16LL;
      }

      if (v6 >= 0x11)
      {
        unint64_t v10 = (v6 - 1) >> 4;
        do
        {
          if (v10 >= 0x10) {
            uint64_t v11 = 16LL;
          }
          else {
            uint64_t v11 = v10;
          }
          cccbc_update_internal((uint64_t)v7, (uint64_t)(a1 + 9), (uint64_t)a1 + *v7 + 72, v11, (uint64_t)v5, (uint64_t)v12);
          v5 += 16 * v11;
          v10 -= v11;
        }

        while (v10);
      }

      __memcpy_chk(a1 + 4, v5, v6 - ((v6 - 1) & 0xFFFFFFFFFFFFFFF0LL), 16LL);
      uint64_t result = 0LL;
      a1[6] = v6 - ((v6 - 1) & 0xFFFFFFFFFFFFFFF0LL);
    }
  }

  return result;
}

uint64_t cccmac_update(void *a1, unint64_t a2, char *a3)
{
  BOOL v8 = timingsafe_enable_if_supported();
  uint64_t updated = cccmac_update_internal(a1, a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v8);
  return updated;
}

uint64_t cczp_sqr_default_ws(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = cczp_n(a2);
  size_t v9 = (void *)(*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 2 * v8);
  ccn_sqr_ws(a1, v8, v9, a4);
  uint64_t result = cczp_mod_ws(a1, a2);
  *(void *)(a1 + 16) = v7;
  return result;
}

uint64_t cczp_sqr_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 24LL))();
}

uint64_t cczp_prime(uint64_t a1)
{
  return a1 + 24;
}

uint64_t cczp_sub_default_ws(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unint64_t *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = cczp_n(a2);
  BOOL v12 = ccn_sub_ws(a1, v11, a3, a4, a5);
  unint64_t v13 = (uint64_t *)cczp_prime(a2);
  uint64_t result = ccn_cond_add(v11, v12, a3, a3, v13);
  *(void *)(a1 + 16) = v10;
  return result;
}

uint64_t cczp_sub_ws(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 8LL))();
}

uint64_t cccmac_init_internal(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t result = 4294967289LL;
  if (a3 <= 0x20 && ((1LL << a3) & 0x101010000LL) != 0)
  {
    uint64_t v9 = a2 + 72;
    cccbc_init_internal((uint64_t)a1);
    __src[0] = 0LL;
    __src[1] = 0LL;
    cccbc_set_iv_internal((uint64_t)a1, (void *)(v9 + *a1), __src);
    *(void *)(a2 + 56) = 0LL;
    *(void *)(a2 + 64) = a1;
    *(void *)(a2 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    return cccmac_generate_subkeys((uint64_t)a1, a3, a4, (char *)a2, a2 + 16);
  }

  return result;
}

uint64_t cccmac_init(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v10 = timingsafe_enable_if_supported();
  uint64_t inited = cccmac_init_internal(a1, a2, a3, a4);
  cc_disable_dit_with_sb((unsigned int *)&v10);
  return inited;
}

uint64_t ccrng_getentropy_generate(int a1, unint64_t a2, char *buffer)
{
  if (a2)
  {
    unint64_t v4 = a2;
    do
    {
      if (v4 >= 0x100) {
        size_t v5 = 256LL;
      }
      else {
        size_t v5 = v4;
      }
      if (getentropy(buffer, v5) == -1) {
        cc_abort();
      }
      buffer += v5;
      v4 -= v5;
    }

    while (v4);
  }

  return 0LL;
}

uint64_t ccaes_vng_gcm_decrypt( uint64_t a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4, double a5, double a6, double a7, double a8, double a9, int8x16_t a10)
{
  uint64_t v14 = *(void *)(a1 + 96);
  ccmode_gcm_aad_finalize(a1, a5, a6, a7, a8, a9, a10);
  if (*(_WORD *)(a1 + 80) != 3) {
    return 4294967228LL;
  }
  uint64_t v21 = *(void *)(a1 + 96);
  uint64_t result = 4294967229LL;
  if (!__CFADD__(v21, a2) && v21 + a2 <= 0xFFFFFFFE0LL)
  {
    unsigned int v23 = v14 & 0xF;
    if ((v14 & 0xF) != 0)
    {
      uint64_t v24 = 16 - v23;
      if (a2 < v24)
      {
LABEL_19:
        if (!a2) {
          return 0LL;
        }
        uint64_t v39 = v23;
        BOOL v40 = &a3[-1].i8[15];
        uint64_t v41 = a1 + v23 + 15;
        unint64_t v42 = a2;
        do
        {
          *(_BYTE *)(v41 + v42) ^= v40[v42];
          --v42;
        }

        while (v42);
        uint64_t v43 = v39 + a1 + 63;
        unint64_t v44 = a2;
        do
        {
          a4[-1].i8[v44 + 15] = *(_BYTE *)(v43 + v44) ^ v40[v44];
          --v44;
        }

        while (v44);
        uint64_t result = 0LL;
        *(void *)(a1 + 96) += a2;
        return result;
      }

      uint64_t v25 = v14 & 0xF;
      BOOL v26 = &a3[-1].i8[15];
      uint64_t v27 = 16 - v23;
      do
      {
        *(_BYTE *)(v25 + a1 + 15 + v27) ^= v26[v27];
        --v27;
      }

      while (v27);
      ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), v15, v16, v17, v18, v19, v20);
      uint64_t v28 = v24;
      do
      {
        a4[-1].i8[v28 + 15] = *(_BYTE *)(v25 + a1 + 63 + v28) ^ v26[v28];
        --v28;
      }

      while (v28);
      a2 -= v24;
      a3 = (int8x16_t *)((char *)a3 + v24);
      a4 = (int8x16_t *)((char *)a4 + v24);
      *(void *)(a1 + 96) += v24;
      ccmode_gcm_update_pad(a1);
    }

    if (a2 >= 0x10)
    {
      gcmDecrypt(a3, a4, (int8x16_t *)a1, a2 & 0xFFFFFFF0, (uint64x2_t *)(a1 + 128), *(int8x16_t **)(a1 + 112));
      uint64_t v29 = a2 & 0xFFFFFFF0;
      a2 &= 0xFFFFFFFF0000000FLL;
      a3 = (int8x16_t *)((char *)a3 + v29);
      a4 = (int8x16_t *)((char *)a4 + v29);
      uint64_t v30 = *(void *)(a1 + 104);
      *(void *)(a1 + 96) += v29;
      (*(void (**)(void, uint64_t, uint64_t, uint64_t))(v30 + 24))( *(void *)(a1 + 112),  1LL,  a1 + 32,  a1 + 64);
      if (a2 >= 0x10)
      {
        do
        {
          for (uint64_t i = 0LL; i != -16; --i)
            *(_BYTE *)(a1 + i + 31) ^= a3->u8[i + 15];
          ccmode_gcm_mult_h((uint64x2_t *)a1, (int8x16_t *)(a1 + 16), v31, v32, v33, v34, v35, v36);
          for (uint64_t j = 0LL; j != -16; --j)
            a4->i8[j + 15] = *(_BYTE *)(a1 + j + 79) ^ a3->i8[j + 15];
          a2 -= 16LL;
          ++a3;
          ++a4;
          *(void *)(a1 + 96) += 16LL;
          ccmode_gcm_update_pad(a1);
        }

        while (a2 > 0xF);
      }
    }

    unsigned int v23 = 0;
    goto LABEL_19;
  }

  return result;
}

void *ccsha256_di()
{
  return &ccsha256_vng_arm_di;
}

void *ccsha384_di()
{
  if (MEMORY[0xFFFFFC010] < 0) {
    return &ccsha384_vng_arm_hw_di;
  }
  else {
    return &ccsha384_vng_arm_di;
  }
}

void *ccsha512_di()
{
  if (MEMORY[0xFFFFFC010] < 0) {
    return &ccsha512_vng_arm_hw_di;
  }
  else {
    return &ccsha512_vng_arm_di;
  }
}

uint64_t ccdrbg_df_derive_keys(uint64_t (**a1)(void), uint64_t a2, uint64_t a3, rsize_t a4, void *a5)
{
  uint64_t v7 = (*a1)();
  if ((_DWORD)v7) {
    cc_clear(a4, a5);
  }
  return v7;
}

uint64_t ccdrbg_df_bc_derive_keys(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, void *a5)
{
  double v32 = a5;
  uint64_t v9 = *(void **)(a1 + 8);
  size_t v10 = (*v9 + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  double v33 = (char *)&v31 - v10;
  bzero((char *)&v31 - v10, v10);
  size_t v11 = (v9[1] + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  BOOL v12 = (char *)&v31 - v11;
  unsigned int v13 = 0;
  if (a2)
  {
    uint64_t v14 = (uint64_t *)(a3 + 8);
    uint64_t v15 = a2;
    do
    {
      uint64_t v16 = *v14;
      v14 += 2;
      v13 += v16;
      --v15;
    }

    while (v15);
  }

  bzero(v12, v11);
  __src[0] = 0LL;
  __src[1] = 0LL;
  unsigned int v43 = bswap32(v13);
  unsigned int v44 = bswap32(a4);
  __int128 v41 = xmmword_2802C0;
  memset(v40, 0, sizeof(v40));
  uint64_t v17 = *(void *)(a1 + 16);
  v39[0] = 0LL;
  v39[1] = 0LL;
  unint64_t v37 = v17 + 16;
  if (v17 == -16)
  {
LABEL_13:
    unsigned int v23 = v33;
    uint64_t inited = cccbc_init_internal((uint64_t)v9);
    uint64_t v25 = v32;
    if (!(_DWORD)inited)
    {
      if (!a4)
      {
LABEL_26:
        uint64_t v29 = 0LL;
        goto LABEL_27;
      }

      BOOL v26 = (void *)((char *)v40 + *(void *)(a1 + 16));
      while (1)
      {
        uint64_t v27 = (uint64_t)v26;
        cc_clear(*(void *)(*(void *)(a1 + 8) + 8LL), v12);
        BOOL v26 = a4 <= 0xF ? v39 : v25;
        uint64_t inited = cccbc_update_internal(*(void *)(a1 + 8), (uint64_t)v23, (uint64_t)v12, 1LL, v27, (uint64_t)v26);
        if ((_DWORD)inited) {
          break;
        }
        if (a4 <= 0xF) {
          memcpy(v25, v26, a4);
        }
        if (a4 >= 0x10) {
          uint64_t v28 = 16LL;
        }
        else {
          uint64_t v28 = a4;
        }
        uint64_t v25 = (void *)((char *)v25 + v28);
        a4 -= v28;
        if (!a4) {
          goto LABEL_26;
        }
      }
    }

    uint64_t v29 = inited;
    goto LABEL_27;
  }

  uint64_t v36 = a2;
  unsigned int v18 = 0;
  unint64_t v19 = 0LL;
  size_t v34 = 16LL - (((_BYTE)v13 + 8) & 0xF);
  double v35 = (size_t *)(a3 + 8);
  while (1)
  {
    cc_clear(*(void *)(*(void *)(a1 + 8) + 8LL), v12);
    LODWORD(__src[0]) = bswap32(v18);
    uint64_t v38 = 0LL;
    uint64_t updated = update_0( *(void *)(a1 + 8),  a1 + 32,  (uint64_t)v12,  (uint64_t)&v40[v19 / 0x10],  &v38,  0x18uLL,  (char *)__src);
    if ((_DWORD)updated) {
      break;
    }
    uint64_t v21 = v35;
    uint64_t v22 = v36;
    if (v36)
    {
      do
      {
        uint64_t updated = update_0( *(void *)(a1 + 8),  a1 + 32,  (uint64_t)v12,  (uint64_t)&v40[v19 / 0x10],  &v38,  *v21,  (char *)*(v21 - 1));
        if ((_DWORD)updated) {
          goto LABEL_28;
        }
        v21 += 2;
      }

      while (--v22);
    }

    uint64_t updated = update_0(*(void *)(a1 + 8), a1 + 32, (uint64_t)v12, (uint64_t)&v40[v19 / 0x10], &v38, v34, (char *)&v41);
    if ((_DWORD)updated) {
      break;
    }
    ++v18;
    v19 += 16LL;
    if (v19 >= v37)
    {
      uint64_t v9 = *(void **)(a1 + 8);
      goto LABEL_13;
    }
  }

uint64_t update_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, size_t __n, char *__src)
{
  uint64_t v7 = __src;
  size_t v8 = __n;
  unint64_t v14 = 16LL - *a5;
  if (*a5) {
    BOOL v15 = __n >= v14;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15)
  {
    memcpy((void *)(a4 + *a5), __src, 16LL - *a5);
    uint64_t result = cccbc_update_internal(a1, a2, a3, 1LL, a4, a4);
    if ((_DWORD)result) {
      return result;
    }
    v8 -= v14;
    v7 += v14;
    *a5 = 0LL;
  }

  if (v8 < 0x10)
  {
LABEL_11:
    if (v8)
    {
      memcpy((void *)(a4 + *a5), v7, v8);
      uint64_t result = 0LL;
      *a5 += v8;
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    while (1)
    {
      uint64_t result = cccbc_update_internal(a1, a2, a3, 1LL, (uint64_t)v7, a4);
      if ((_DWORD)result) {
        break;
      }
      v8 -= 16LL;
      v7 += 16;
      if (v8 <= 0xF) {
        goto LABEL_11;
      }
    }
  }

  return result;
}

uint64_t ccdrbg_df_bc_init_internal(void *a1, void *a2, unint64_t a3)
{
  uint64_t result = 4294967291LL;
  if (a3 <= 0x20 && *a2 <= 0x200uLL && a2[1] == 16LL)
  {
    *a1 = ccdrbg_df_bc_derive_keys;
    a1[1] = a2;
    a1[2] = a3;
    return cccbc_init_internal((uint64_t)a2);
  }

  return result;
}

void *cc_malloc_clear(size_t a1)
{
  unint64_t v2 = malloc(a1);
  unint64_t v3 = v2;
  if (v2) {
    bzero(v2, a1);
  }
  return v3;
}

uint64_t cc_ws_alloc(void *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  uint64_t v4 = *a1 + 8 * v2;
  unint64_t v5 = v2 + a2;
  a1[2] = v5;
  cc_try_abort_if (v5 > v3);
  return v4;
}

void cc_ws_free(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
}

int32x4_t *ccchacha20_update_internal(int32x4_t *result, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  uint64_t v4 = a4;
  unint64_t v5 = a3;
  unint64_t v6 = a2;
  uint64_t v7 = result;
  uint64_t v8 = result[8].i64[0];
  if (v8)
  {
    unint64_t v9 = 64 - v8;
    if (64 - v8 >= a2) {
      unint64_t v9 = a2;
    }
    if (v9)
    {
      uint64_t v10 = (uint64_t)&result[3].i64[1] + v8 + 7;
      unint64_t v11 = v9;
      do
      {
        a4[-1].i8[v11 + 15] = *(_BYTE *)(v10 + v11) ^ a3[-1].i8[v11 + 15];
        --v11;
      }

      while (v11);
      uint64_t v8 = result[8].i64[0];
    }

    unint64_t v5 = (int8x16_t *)((char *)a3 + v9);
    unint64_t v6 = a2 - v9;
    uint64_t v4 = (int8x16_t *)((char *)a4 + v9);
    result[8].i64[0] = ((_WORD)v8 + (_WORD)v9) & 0x1FF;
  }

  if (v6 >= 0x40)
  {
    uint64_t result = _ccchacha20_xor(result, v6 & 0xFFFFFFFFFFFFFFC0LL, v4, v5);
    unint64_t v5 = (int8x16_t *)((char *)v5 + (v6 & 0xFFFFFFFFFFFFFFC0LL));
    uint64_t v4 = (int8x16_t *)((char *)v4 + (v6 & 0xFFFFFFFFFFFFFFC0LL));
    v6 &= 0x3Fu;
  }

  if (v6)
  {
    uint64_t result = _ccchacha20_xor(v7, 0x40uLL, (int8x16_t *)&v7[4], kZero64);
    unint64_t v12 = v6;
    do
    {
      v4[-1].i8[v12 + 15] = v7[3].i8[v12 + 15] ^ v5[-1].i8[v12 + 15];
      --v12;
    }

    while (v12);
    v7[8].i64[0] = v6;
  }

  return result;
}

int32x4_t *_ccchacha20_xor(int32x4_t *result, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  int32x4_t v5 = result[1];
  int32x4_t v4 = result[2];
  int32x4_t v6 = result[3];
  if (a2 >= 0xC0)
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = a2 / 0xC0;
    do
    {
      int32x4_t v9 = vaddq_s32(v6, (int32x4_t)xmmword_27E6A0);
      __int32 v11 = result[1].i32[0];
      __int32 v10 = result[1].i32[1];
      __int32 v12 = result[1].i32[2];
      __int32 v13 = result[1].i32[3];
      __int32 v14 = result[2].i32[0];
      __int32 v15 = result[2].i32[1];
      __int32 v16 = result[2].i32[2];
      __int32 v17 = result[2].i32[3];
      int v18 = 3 * v7 + 2;
      __int32 v19 = result[3].i32[1];
      int v20 = result[3].i32[0] + v18;
      uint64_t v21 = -10LL;
      int v22 = 1634760805;
      int v23 = 857760878;
      int v24 = 2036477234;
      int v25 = 1797285236;
      int32x4_t v26 = (int32x4_t)xmmword_2802F0;
      int32x4_t v27 = v5;
      int32x4_t v28 = v4;
      int32x4_t v29 = v6;
      int32x4_t v30 = (int32x4_t)xmmword_2802F0;
      int32x4_t v31 = v5;
      int32x4_t v32 = v4;
      int32x4_t v33 = v9;
      __int32 v35 = result[3].i32[2];
      __int32 v34 = result[3].i32[3];
      do
      {
        int32x4_t v36 = vaddq_s32(v26, v27);
        int32x4_t v37 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v36, (int8x16_t)v29));
        int32x4_t v38 = vaddq_s32(v28, v37);
        int32x4_t v39 = (int32x4_t)veorq_s8((int8x16_t)v38, (int8x16_t)v27);
        int32x4_t v40 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v39, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v39, 0x14uLL));
        int32x4_t v41 = vaddq_s32(v40, v36);
        int32x4_t v42 = (int32x4_t)veorq_s8((int8x16_t)v41, (int8x16_t)v37);
        int32x4_t v43 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v42, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v42, 0x18uLL));
        int8x16_t v44 = (int8x16_t)vaddq_s32(v43, v38);
        int32x4_t v45 = (int32x4_t)veorq_s8(v44, (int8x16_t)v40);
        int8x16_t v46 = vorrq_s8((int8x16_t)vshlq_n_s32(v45, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v45, 0x19uLL));
        int32x4_t v47 = (int32x4_t)vextq_s8(v46, v46, 4uLL);
        int32x4_t v48 = vaddq_s32(v47, v41);
        int32x4_t v49 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8( (int8x16_t)v48,  vextq_s8((int8x16_t)v43, (int8x16_t)v43, 0xCuLL)));
        int32x4_t v50 = vaddq_s32((int32x4_t)vextq_s8(v44, v44, 8uLL), v49);
        int32x4_t v51 = (int32x4_t)veorq_s8((int8x16_t)v50, (int8x16_t)v47);
        int32x4_t v52 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v51, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v51, 0x14uLL));
        int32x4_t v26 = vaddq_s32(v52, v48);
        int32x4_t v53 = (int32x4_t)veorq_s8((int8x16_t)v26, (int8x16_t)v49);
        int32x4_t v54 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v53, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v53, 0x18uLL));
        int8x16_t v55 = (int8x16_t)vaddq_s32(v54, v50);
        int32x4_t v56 = (int32x4_t)veorq_s8(v55, (int8x16_t)v52);
        int8x16_t v57 = vorrq_s8((int8x16_t)vshlq_n_s32(v56, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v56, 0x19uLL));
        int32x4_t v27 = (int32x4_t)vextq_s8(v57, v57, 0xCuLL);
        int32x4_t v28 = (int32x4_t)vextq_s8(v55, v55, 8uLL);
        int32x4_t v29 = (int32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 4uLL);
        int32x4_t v58 = vaddq_s32(v30, v31);
        int32x4_t v59 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v58, (int8x16_t)v33));
        int32x4_t v60 = vaddq_s32(v32, v59);
        __int32 v61 = v22 + v11;
        int v62 = (v22 + v11) ^ v20;
        HIDWORD(v63) = v62;
        LODWORD(v63) = v62;
        int v64 = (v63 >> 16) + v14;
        int v65 = v64 ^ v11;
        HIDWORD(v63) = v65;
        LODWORD(v63) = v65;
        int32x4_t v66 = (int32x4_t)veorq_s8((int8x16_t)v60, (int8x16_t)v31);
        int v67 = (v63 >> 20) + v61;
        LODWORD(v63) = v67 ^ __ROR4__(v62, 16);
        int v68 = v63;
        HIDWORD(v63) = v63;
        int v69 = (v63 >> 24) + v64;
        LODWORD(v63) = v69 ^ __ROR4__(v65, 20);
        int v70 = v63;
        HIDWORD(v63) = v63;
        int v71 = v63 >> 25;
        __int32 v72 = v23 + v10;
        int v73 = (v23 + v10) ^ v19;
        HIDWORD(v63) = v73;
        LODWORD(v63) = v73;
        int32x4_t v74 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v66, 0xCuLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v66, 0x14uLL));
        int v75 = (v63 >> 16) + v15;
        int v76 = v75 ^ v10;
        HIDWORD(v63) = v76;
        LODWORD(v63) = v76;
        int32x4_t v77 = vaddq_s32(v74, v58);
        int v78 = (v63 >> 20) + v72;
        LODWORD(v63) = v78 ^ __ROR4__(v73, 16);
        int v79 = v63;
        HIDWORD(v63) = v63;
        int32x4_t v80 = (int32x4_t)veorq_s8((int8x16_t)v77, (int8x16_t)v59);
        int v81 = (v63 >> 24) + v75;
        LODWORD(v63) = v81 ^ __ROR4__(v76, 20);
        int v82 = v63;
        HIDWORD(v63) = v63;
        int v83 = v63 >> 25;
        __int32 v84 = v24 + v12;
        int v85 = (v24 + v12) ^ v35;
        HIDWORD(v63) = v85;
        LODWORD(v63) = v85;
        int v86 = (v63 >> 16) + v16;
        int v87 = v86 ^ v12;
        HIDWORD(v63) = v87;
        LODWORD(v63) = v87;
        int32x4_t v88 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v80, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v80, 0x18uLL));
        int v89 = (v63 >> 20) + v84;
        LODWORD(v63) = v89 ^ __ROR4__(v85, 16);
        int v90 = v63;
        HIDWORD(v63) = v63;
        int8x16_t v91 = (int8x16_t)vaddq_s32(v88, v60);
        int v92 = (v63 >> 24) + v86;
        LODWORD(v63) = v92 ^ __ROR4__(v87, 20);
        int v93 = v63;
        HIDWORD(v63) = v63;
        int v94 = v63 >> 25;
        int32x4_t v95 = (int32x4_t)veorq_s8(v91, (int8x16_t)v74);
        __int32 v96 = v25 + v13;
        int v97 = v96 ^ v34;
        HIDWORD(v63) = v97;
        LODWORD(v63) = v97;
        int8x16_t v98 = vorrq_s8((int8x16_t)vshlq_n_s32(v95, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v95, 0x19uLL));
        int v99 = (v63 >> 16) + v17;
        int v100 = v99 ^ v13;
        HIDWORD(v63) = v99 ^ v13;
        LODWORD(v63) = v99 ^ v13;
        int32x4_t v101 = (int32x4_t)vextq_s8(v98, v98, 4uLL);
        int v102 = (v63 >> 20) + v96;
        int32x4_t v104 = vaddq_s32(v101, v77);
        int32x4_t v105 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8( (int8x16_t)v104,  vextq_s8((int8x16_t)v88, (int8x16_t)v88, 0xCuLL)));
        LODWORD(v63) = v102 ^ __ROR4__(v97, 16);
        int v103 = v63;
        HIDWORD(v63) = v63;
        int32x4_t v106 = vaddq_s32((int32x4_t)vextq_s8(v91, v91, 8uLL), v105);
        int32x4_t v107 = (int32x4_t)veorq_s8((int8x16_t)v106, (int8x16_t)v101);
        int v108 = (v63 >> 24) + v99;
        int32x4_t v110 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v107, 0xCuLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v107, 0x14uLL));
        LODWORD(v63) = v108 ^ __ROR4__(v100, 20);
        int v109 = v63;
        HIDWORD(v63) = v63;
        int v111 = v63 >> 25;
        int32x4_t v30 = vaddq_s32(v110, v104);
        int32x4_t v112 = (int32x4_t)veorq_s8((int8x16_t)v30, (int8x16_t)v105);
        int v113 = v83 + v67;
        int32x4_t v115 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v112, 8uLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v112, 0x18uLL));
        int8x16_t v116 = (int8x16_t)vaddq_s32(v115, v106);
        int32x4_t v117 = (int32x4_t)veorq_s8(v116, (int8x16_t)v110);
        LODWORD(v63) = v113 ^ __ROR4__(v103, 24);
        int v114 = v63;
        HIDWORD(v63) = v63;
        int8x16_t v118 = vorrq_s8((int8x16_t)vshlq_n_s32(v117, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v117, 0x19uLL));
        int v119 = (v63 >> 16) + v92;
        int32x4_t v31 = (int32x4_t)vextq_s8(v118, v118, 0xCuLL);
        int32x4_t v32 = (int32x4_t)vextq_s8(v116, v116, 8uLL);
        LODWORD(v63) = v119 ^ __ROR4__(v82, 25);
        int v120 = v63;
        HIDWORD(v63) = v63;
        int v22 = (v63 >> 20) + v113;
        LODWORD(v63) = v22 ^ __ROR4__(v114, 16);
        HIDWORD(v63) = v63;
        __int32 v34 = v63 >> 24;
        __int32 v16 = v34 + v119;
        LODWORD(v63) = v16 ^ __ROR4__(v120, 20);
        HIDWORD(v63) = v63;
        __int32 v10 = v63 >> 25;
        LODWORD(v63) = (v94 + v78) ^ __ROR4__(v68, 24);
        int v121 = v63;
        HIDWORD(v63) = v63;
        int v122 = (v63 >> 16) + v108;
        LODWORD(v63) = v122 ^ __ROR4__(v93, 25);
        int v123 = v63;
        HIDWORD(v63) = v63;
        int v23 = (v63 >> 20) + v94 + v78;
        LODWORD(v63) = v23 ^ __ROR4__(v121, 16);
        HIDWORD(v63) = v63;
        int v20 = v63 >> 24;
        __int32 v17 = v20 + v122;
        LODWORD(v63) = (v20 + v122) ^ __ROR4__(v123, 20);
        HIDWORD(v63) = v63;
        __int32 v12 = v63 >> 25;
        int v124 = v111 + v89;
        LODWORD(v63) = (v111 + v89) ^ __ROR4__(v79, 24);
        int v125 = v63;
        HIDWORD(v63) = v63;
        int v126 = (v63 >> 16) + v69;
        LODWORD(v63) = v126 ^ __ROR4__(v109, 25);
        int v127 = v63;
        HIDWORD(v63) = v63;
        int v24 = (v63 >> 20) + v124;
        LODWORD(v63) = v24 ^ __ROR4__(v125, 16);
        HIDWORD(v63) = v63;
        __int32 v19 = v63 >> 24;
        __int32 v14 = v19 + v126;
        LODWORD(v63) = (v19 + v126) ^ __ROR4__(v127, 20);
        HIDWORD(v63) = v63;
        __int32 v13 = v63 >> 25;
        int v128 = v71 + v102;
        LODWORD(v63) = v128 ^ __ROR4__(v90, 24);
        int v129 = v63;
        HIDWORD(v63) = v63;
        int v130 = (v63 >> 16) + v81;
        LODWORD(v63) = v130 ^ __ROR4__(v70, 25);
        int v131 = v63;
        HIDWORD(v63) = v63;
        int v25 = (v63 >> 20) + v128;
        LODWORD(v63) = v25 ^ __ROR4__(v129, 16);
        HIDWORD(v63) = v63;
        __int32 v35 = v63 >> 24;
        int32x4_t v33 = (int32x4_t)vextq_s8((int8x16_t)v115, (int8x16_t)v115, 4uLL);
        __int32 v15 = v35 + v130;
        LODWORD(v63) = (v35 + v130) ^ __ROR4__(v131, 20);
        HIDWORD(v63) = v63;
        __int32 v11 = v63 >> 25;
        BOOL v132 = __CFADD__(v21++, 1LL);
      }

      while (!v132);
      *a3 = veorq_s8(*a4, (int8x16_t)vaddq_s32(v26, (int32x4_t)xmmword_2802F0));
      a3[1] = veorq_s8(a4[1], (int8x16_t)vaddq_s32(v27, v5));
      a3[2] = veorq_s8(a4[2], (int8x16_t)vaddq_s32(v28, v4));
      a3[3] = veorq_s8(a4[3], (int8x16_t)vaddq_s32(v29, v6));
      a3[4] = veorq_s8(a4[4], (int8x16_t)vaddq_s32(v30, (int32x4_t)xmmword_2802F0));
      a3[5] = veorq_s8(a4[5], (int8x16_t)vaddq_s32(v31, v5));
      a3[6] = veorq_s8(a4[6], (int8x16_t)vaddq_s32(v32, v4));
      a3[7] = veorq_s8(a4[7], (int8x16_t)vaddq_s32(v33, v9));
      a3[8].i32[0] = a4[8].i32[0] ^ (v22 + 1634760805);
      a3[8].i32[1] = a4[8].i32[1] ^ (v23 + 857760878);
      a3[8].i32[2] = a4[8].i32[2] ^ (v24 + 2036477234);
      a3[8].i32[3] = a4[8].i32[3] ^ (v25 + 1797285236);
      a3[9].i32[0] = (result[1].i32[0] + v11) ^ a4[9].i32[0];
      a3[9].i32[1] = (result[1].i32[1] + v10) ^ a4[9].i32[1];
      a3[9].i32[2] = (result[1].i32[2] + v12) ^ a4[9].i32[2];
      a3[9].i32[3] = (result[1].i32[3] + v13) ^ a4[9].i32[3];
      a3[10].i32[0] = (result[2].i32[0] + v14) ^ a4[10].i32[0];
      a3[10].i32[1] = (result[2].i32[1] + v15) ^ a4[10].i32[1];
      a3[10].i32[2] = (result[2].i32[2] + v16) ^ a4[10].i32[2];
      a3[10].i32[3] = (result[2].i32[3] + v17) ^ a4[10].i32[3];
      a3[11].i32[0] = (v20 + v18 + result[3].i32[0]) ^ a4[11].i32[0];
      a3[11].i32[1] = (result[3].i32[1] + v19) ^ a4[11].i32[1];
      a3[11].i32[2] = (result[3].i32[2] + v35) ^ a4[11].i32[2];
      a3[11].i32[3] = (result[3].i32[3] + v34) ^ a4[11].i32[3];
      int32x4_t v6 = vaddq_s32(v6, (int32x4_t)xmmword_27F290);
      a4 += 12;
      a3 += 12;
      ++v7;
    }

    while (v7 != v8);
  }

  if (a2 % 0xC0 >= 0x40)
  {
    unint64_t v134 = (a2 % 0xC0) >> 6;
    unsigned __int128 v133 = (int32x4_t *)&unk_280000;
    do
    {
      uint64_t v135 = -10LL;
      int32x4_t v136 = (int32x4_t)xmmword_2802F0;
      int32x4_t v137 = v5;
      int32x4_t v138 = v4;
      int32x4_t v139 = v6;
      do
      {
        int32x4_t v140 = vaddq_s32(v136, v137);
        int32x4_t v141 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v140, (int8x16_t)v139));
        int32x4_t v142 = vaddq_s32(v138, v141);
        int32x4_t v143 = (int32x4_t)veorq_s8((int8x16_t)v142, (int8x16_t)v137);
        int32x4_t v144 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v143, 0xCuLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v143, 0x14uLL));
        int32x4_t v145 = vaddq_s32(v144, v140);
        int32x4_t v146 = (int32x4_t)veorq_s8((int8x16_t)v145, (int8x16_t)v141);
        int32x4_t v147 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v146, 8uLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v146, 0x18uLL));
        int8x16_t v148 = (int8x16_t)vaddq_s32(v147, v142);
        int32x4_t v149 = (int32x4_t)veorq_s8(v148, (int8x16_t)v144);
        int8x16_t v150 = vorrq_s8((int8x16_t)vshlq_n_s32(v149, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v149, 0x19uLL));
        int32x4_t v151 = (int32x4_t)vextq_s8(v150, v150, 4uLL);
        int32x4_t v152 = vaddq_s32(v151, v145);
        int32x4_t v153 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8( (int8x16_t)v152,  vextq_s8((int8x16_t)v147, (int8x16_t)v147, 0xCuLL)));
        int32x4_t v154 = vaddq_s32((int32x4_t)vextq_s8(v148, v148, 8uLL), v153);
        int32x4_t v155 = (int32x4_t)veorq_s8((int8x16_t)v154, (int8x16_t)v151);
        int32x4_t v156 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v155, 0xCuLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v155, 0x14uLL));
        int32x4_t v136 = vaddq_s32(v156, v152);
        int32x4_t v157 = (int32x4_t)veorq_s8((int8x16_t)v136, (int8x16_t)v153);
        int32x4_t v158 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v157, 8uLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v157, 0x18uLL));
        int8x16_t v159 = (int8x16_t)vaddq_s32(v158, v154);
        int32x4_t v160 = (int32x4_t)veorq_s8(v159, (int8x16_t)v156);
        int8x16_t v161 = vorrq_s8((int8x16_t)vshlq_n_s32(v160, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v160, 0x19uLL));
        int32x4_t v137 = (int32x4_t)vextq_s8(v161, v161, 0xCuLL);
        int32x4_t v138 = (int32x4_t)vextq_s8(v159, v159, 8uLL);
        int32x4_t v139 = (int32x4_t)vextq_s8((int8x16_t)v158, (int8x16_t)v158, 4uLL);
        BOOL v132 = __CFADD__(v135++, 1LL);
      }

      while (!v132);
      *a3 = veorq_s8(*a4, (int8x16_t)vaddq_s32(v136, (int32x4_t)xmmword_2802F0));
      a3[1] = veorq_s8(a4[1], (int8x16_t)vaddq_s32(v137, v5));
      a3[2] = veorq_s8(a4[2], (int8x16_t)vaddq_s32(v138, v4));
      a3[3] = veorq_s8(a4[3], (int8x16_t)vaddq_s32(v139, v6));
      int32x4_t v6 = vaddq_s32(v6, (int32x4_t)xmmword_27E6A0);
      a4 += 4;
      a3 += 4;
      --v134;
    }

    while (v134);
  }

  else
  {
    unsigned __int128 v133 = (int32x4_t *)&unk_280000;
  }

  unint64_t v162 = a2 & 0x3F;
  if ((a2 & 0x3F) != 0)
  {
    int32x4_t v201 = 0u;
    int32x4_t v202 = 0u;
    int32x4_t v199 = 0u;
    int32x4_t v200 = 0u;
    int32x4_t v163 = v133[47];
    uint64_t v164 = -10LL;
    int32x4_t v165 = v5;
    int32x4_t v166 = v4;
    int32x4_t v167 = v6;
    do
    {
      int32x4_t v168 = vaddq_s32(v163, v165);
      int32x4_t v169 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8((int8x16_t)v168, (int8x16_t)v167));
      int32x4_t v170 = vaddq_s32(v166, v169);
      int32x4_t v171 = (int32x4_t)veorq_s8((int8x16_t)v170, (int8x16_t)v165);
      int32x4_t v172 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v171, 0xCuLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v171, 0x14uLL));
      int32x4_t v173 = vaddq_s32(v172, v168);
      int32x4_t v174 = (int32x4_t)veorq_s8((int8x16_t)v173, (int8x16_t)v169);
      int32x4_t v175 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v174, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v174, 0x18uLL));
      int8x16_t v176 = (int8x16_t)vaddq_s32(v175, v170);
      int32x4_t v177 = (int32x4_t)veorq_s8(v176, (int8x16_t)v172);
      int8x16_t v178 = vorrq_s8((int8x16_t)vshlq_n_s32(v177, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v177, 0x19uLL));
      int32x4_t v179 = (int32x4_t)vextq_s8(v178, v178, 4uLL);
      int32x4_t v180 = vaddq_s32(v179, v173);
      int32x4_t v181 = (int32x4_t)vrev32q_s16((int16x8_t)veorq_s8( (int8x16_t)v180,  vextq_s8((int8x16_t)v175, (int8x16_t)v175, 0xCuLL)));
      int32x4_t v182 = vaddq_s32((int32x4_t)vextq_s8(v176, v176, 8uLL), v181);
      int32x4_t v183 = (int32x4_t)veorq_s8((int8x16_t)v182, (int8x16_t)v179);
      int32x4_t v184 = (int32x4_t)vorrq_s8( (int8x16_t)vshlq_n_s32(v183, 0xCuLL),  (int8x16_t)vshrq_n_u32((uint32x4_t)v183, 0x14uLL));
      int32x4_t v163 = vaddq_s32(v184, v180);
      int32x4_t v185 = (int32x4_t)veorq_s8((int8x16_t)v163, (int8x16_t)v181);
      int32x4_t v186 = (int32x4_t)vorrq_s8((int8x16_t)vshlq_n_s32(v185, 8uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v185, 0x18uLL));
      int8x16_t v187 = (int8x16_t)vaddq_s32(v186, v182);
      int32x4_t v188 = (int32x4_t)veorq_s8(v187, (int8x16_t)v184);
      int8x16_t v189 = vorrq_s8((int8x16_t)vshlq_n_s32(v188, 7uLL), (int8x16_t)vshrq_n_u32((uint32x4_t)v188, 0x19uLL));
      int32x4_t v165 = (int32x4_t)vextq_s8(v189, v189, 0xCuLL);
      int32x4_t v166 = (int32x4_t)vextq_s8(v187, v187, 8uLL);
      int32x4_t v167 = (int32x4_t)vextq_s8((int8x16_t)v186, (int8x16_t)v186, 4uLL);
      BOOL v132 = __CFADD__(v164++, 1LL);
    }

    while (!v132);
    if (v162 < 0x10)
    {
      int32x4_t v199 = vaddq_s32(v163, v133[47]);
    }

    else
    {
      *a3 = veorq_s8(*a4, (int8x16_t)vaddq_s32(v163, v133[47]));
      if (v162 < 0x20)
      {
        int32x4_t v200 = vaddq_s32(v165, v5);
      }

      else
      {
        a3[1] = veorq_s8(a4[1], (int8x16_t)vaddq_s32(v165, v5));
        if (v162 < 0x30)
        {
          int32x4_t v201 = vaddq_s32(v166, v4);
        }

        else
        {
          a3[2] = veorq_s8(a4[2], (int8x16_t)vaddq_s32(v166, v4));
          int32x4_t v202 = vaddq_s32(v167, v6);
        }
      }
    }

    unint64_t v190 = a2 & 0x30;
    unint64_t v191 = v162 - v190;
    if (v162 > v190)
    {
      uint64_t v192 = &a3->i8[v190];
      unint64_t v193 = &v199.i8[v190];
      unint64_t v194 = &a4->i8[v190];
      do
      {
        char v196 = *v194++;
        char v195 = v196;
        char v197 = *v193++;
        *v192++ = v197 ^ v195;
        --v191;
      }

      while (v191);
    }
  }

  result[3].i32[0] = v6.i32[0];
  return result;
}

uint64_t ccpoly1305_init_internal(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0LL;
  unsigned int v3 = *(_DWORD *)(a2 + 4);
  unsigned int v4 = *(_DWORD *)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 12);
  int v6 = (*(void *)a2 >> 26) & 0x3FFFF03;
  *(_DWORD *)uint64_t result = *(_DWORD *)a2 & 0x3FFFFFF;
  *(_DWORD *)(result + 4) = v6;
  int v7 = (__PAIR64__(v4, v3) >> 20) & 0x3FFC0FF;
  unint64_t v8 = (__PAIR64__(v5, v4) >> 14) & 0x3F03FFF;
  *(_DWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = v7;
  *(_DWORD *)(result + 12) = v8;
  int v9 = (v5 >> 8) & 0xFFFFF;
  *(_DWORD *)(result + 16) = v9;
  *(_DWORD *)(result + 20) = 5 * v6;
  *(_DWORD *)(result + 24) = 5 * v7;
  *(_DWORD *)(result + 2_Block_object_dispose((const void *)(v11 - 96), 8) = 5 * v8;
  *(_DWORD *)(result + 32) = 5 * v9;
  *(void *)(result + 72) = 0LL;
  *(void *)(result + 44) = 0LL;
  *(void *)(result + 36) = 0LL;
  *(_DWORD *)(result + 52) = 0;
  do
  {
    *(_BYTE *)(result + 80 + v2) = *(_BYTE *)(a2 + 16 + v2);
    ++v2;
  }

  while (v2 != 16);
  return result;
}

unsigned int *ccpoly1305_update_internal(unsigned int *result, unint64_t a2, unsigned int *a3)
{
  unsigned int v3 = a3;
  unint64_t v4 = a2;
  unsigned int v5 = result;
  uint64_t v6 = *((void *)result + 9);
  if (v6)
  {
    unint64_t v7 = 16 - v6;
    if (16 - v6 >= a2) {
      unint64_t v7 = a2;
    }
    if (v7)
    {
      unint64_t v8 = result + 14;
      int v9 = a3;
      unint64_t v10 = v7;
      do
      {
        char v11 = *(_BYTE *)v9;
        int v9 = (unsigned int *)((char *)v9 + 1);
        *((_BYTE *)v8 + *((void *)result + 9)) = v11;
        unint64_t v8 = (unsigned int *)((char *)v8 + 1);
        --v10;
      }

      while (v10);
      uint64_t v6 = *((void *)result + 9);
    }

    uint64_t v12 = v6 + v7;
    *((void *)result + 9) = v12;
    unint64_t v4 = a2 - v7;
    unsigned int v3 = (unsigned int *)((char *)a3 + v7);
    if (v12 == 16)
    {
      uint64_t result = _ccpoly1305_update(result, 0x10uLL, result + 14);
      *((void *)v5 + 9) = 0LL;
    }
  }

  if (v4 >= 0x10)
  {
    uint64_t result = _ccpoly1305_update(v5, v4 & 0xFFFFFFFFFFFFFFF0LL, v3);
    unsigned int v3 = (unsigned int *)((char *)v3 + (v4 & 0xFFFFFFFFFFFFFFF0LL));
    v4 &= 0xFu;
  }

  if (v4)
  {
    for (uint64_t i = 0LL; i != v4; ++i)
      *((_BYTE *)v5 + i + 56) = *((_BYTE *)v3 + i);
    *((void *)v5 + 9) = v4;
  }

  return result;
}

uint64_t ccpoly1305_final_internal(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 72);
  if (v4) {
    _ccpoly1305_update((unsigned int *)a1, v4, (unsigned int *)(a1 + 56));
  }
  unsigned int v5 = *(_DWORD *)(a1 + 36);
  int v6 = v5 & 0x3FFFFFF;
  unsigned int v7 = *(_DWORD *)(a1 + 40) + (v5 >> 26);
  int v8 = v7 & 0x3FFFFFF;
  unsigned int v9 = *(_DWORD *)(a1 + 44) + (v7 >> 26);
  int v10 = v9 & 0x3FFFFFF;
  unsigned int v11 = *(_DWORD *)(a1 + 48) + (v9 >> 26);
  int v12 = v11 & 0x3FFFFFF;
  unsigned int v13 = *(_DWORD *)(a1 + 52) + (v11 >> 26);
  unsigned int v14 = 5 * (v13 >> 26) + v6;
  unsigned int v15 = v8 + ((v14 + 5) >> 26);
  unsigned int v16 = v10 + (v15 >> 26);
  unsigned int v17 = v12 + (v16 >> 26);
  signed int v18 = (v13 | 0xFC000000) + (v17 >> 26);
  uint64_t result = (v18 >> 31) - 1;
  int v20 = v14 & (v18 >> 31) | result & 0x3FFFFFF & (v14 + 5);
  unsigned int v21 = v8 & (v18 >> 31) | result & 0x3FFFFFF & v15;
  *(_DWORD *)(a1 + 36) = v20;
  *(_DWORD *)(a1 + 40) = v21;
  unsigned int v22 = v10 & (v18 >> 31) | result & 0x3FFFFFF & v16;
  unsigned int v23 = v12 & (v18 >> 31) | result & 0x3FFFFFF & v17;
  *(_DWORD *)(a1 + 44) = v22;
  *(_DWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v23;
  int v24 = result & v18 | v13 & (v18 >> 31) & 0x3FFFFFF;
  *(_DWORD *)(a1 + 52) = v24;
  int v25 = v20 | (v21 << 26);
  int v26 = *(_DWORD *)(a1 + 80);
  uint64_t v27 = *(unsigned int *)(a1 + 84);
  uint64_t v28 = (v21 >> 6) | (v22 << 20);
  uint64_t v29 = *(unsigned int *)(a1 + 92);
  unint64_t v30 = ((v22 >> 12) | (v23 << 14)) + (unint64_t)*(unsigned int *)(a1 + 88);
  *(_DWORD *)a2 = v25 + v26;
  unint64_t v31 = v27 + __CFADD__(v25, v26) + v28;
  *(_BYTE *)(a2 + 7) = BYTE3(v31);
  *(_BYTE *)(a2 + 6) = BYTE2(v31);
  *(_WORD *)(a2 + 4) = v31;
  unint64_t v32 = v30 + HIDWORD(v31);
  *(_BYTE *)(a2 + 11) = BYTE3(v32);
  *(_BYTE *)(a2 + 10) = BYTE2(v32);
  *(_WORD *)(a2 + _Block_object_dispose((const void *)(v11 - 96), 8) = v32;
  unint64_t v33 = ((v23 >> 18) | (v24 << 8)) + v29 + HIDWORD(v32);
  *(_BYTE *)(a2 + 15) = BYTE3(v33);
  *(_BYTE *)(a2 + 14) = BYTE2(v33);
  *(_WORD *)(a2 + 12) = v33;
  return result;
}

void *ccchacha20poly1305_info()
{
  return &ccchacha20poly1305_info_default;
}

uint64_t ccchacha20poly1305_init(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  BOOL v6 = timingsafe_enable_if_supported();
  ccchacha20poly1305_init_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v6);
  return 0LL;
}

double ccchacha20poly1305_init_internal(uint64_t a1, _DWORD *a2)
{
  double result = 1.99237483e-62;
  *(_OWORD *)a1 = xmmword_2802F0;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = a2[1];
  *(_DWORD *)(a1 + 24) = a2[2];
  *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v11 - 96), 8) = a2[3];
  *(_DWORD *)(a1 + 32) = a2[4];
  *(_DWORD *)(a1 + 36) = a2[5];
  *(_DWORD *)(a1 + 40) = a2[6];
  unsigned int v3 = a2[7];
  *(void *)(a1 + 232) = 0LL;
  *(void *)(a1 + 240) = 0LL;
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v11 - 96), 8) = 1;
  *(void *)(a1 + 44) = v3;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
  return result;
}

uint64_t ccchacha20poly1305_setnonce(uint64_t a1, int32x4_t *a2, __int32 *a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v5 = ccchacha20poly1305_setnonce_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccchacha20poly1305_setnonce_internal(int32x4_t *a1, __int32 *a2)
{
  if (a1[15].i8[8] != 1) {
    return 1LL;
  }
  memset(v4, 0, sizeof(v4));
  a1[3].i32[1] = *a2;
  a1[3].i32[2] = a2[1];
  a1[3].i32[3] = a2[2];
  _ccchacha20_xor(a1, 0x40uLL, v4, kZero64);
  ccpoly1305_init_internal((uint64_t)&a1[8].i64[1], (uint64_t)v4);
  uint64_t result = 0LL;
  a1[15].i8[8] = 2;
  return result;
}

uint64_t ccchacha20poly1305_aad(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int *a4)
{
  BOOL v9 = timingsafe_enable_if_supported();
  if (*(_BYTE *)(a2 + 248) == 2)
  {
    ccpoly1305_update_internal((unsigned int *)(a2 + 136), a3, a4);
    uint64_t v7 = 0LL;
    *(void *)(a2 + 232) += a3;
  }

  else
  {
    uint64_t v7 = 1LL;
  }

  cc_disable_dit_with_sb((unsigned int *)&v9);
  return v7;
}

uint64_t ccchacha20poly1305_encrypt( uint64_t a1, int32x4_t *a2, unint64_t a3, int8x16_t *a4, int8x16_t *a5)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v9 = ccchacha20poly1305_encrypt_internal(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t ccchacha20poly1305_encrypt_internal( int32x4_t *a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  int v8 = a1[15].u8[8];
  if (v8 != 3)
  {
    if (v8 != 2) {
      return 1LL;
    }
    ccpoly1305_update_internal(&a1[8].u32[2], -a1[14].i32[2] & 0xFLL, (unsigned int *)kZero64);
    a1[15].i8[8] = 3;
  }

  uint64_t v9 = a1[15].i64[0];
  uint64_t result = 1LL;
  if (!__CFADD__(v9, a2) && v9 + a2 <= 0x3FFFFFFFC0LL)
  {
    ccchacha20_update_internal(a1, a2, a3, a4);
    ccpoly1305_update_internal(&a1[8].u32[2], a2, (unsigned int *)a4);
    uint64_t result = 0LL;
    a1[15].i64[0] += a2;
  }

  return result;
}

uint64_t ccchacha20poly1305_decrypt( uint64_t a1, int32x4_t *a2, unint64_t a3, int8x16_t *a4, int8x16_t *a5)
{
  BOOL v11 = timingsafe_enable_if_supported();
  uint64_t v9 = ccchacha20poly1305_decrypt_internal(a2, a3, a4, a5);
  cc_disable_dit_with_sb((unsigned int *)&v11);
  return v9;
}

uint64_t ccchacha20poly1305_decrypt_internal( int32x4_t *a1, unint64_t a2, int8x16_t *a3, int8x16_t *a4)
{
  int v8 = a1[15].u8[8];
  if (v8 != 4)
  {
    if (v8 != 2) {
      return 1LL;
    }
    ccpoly1305_update_internal(&a1[8].u32[2], -a1[14].i32[2] & 0xFLL, (unsigned int *)kZero64);
    a1[15].i8[8] = 4;
  }

  uint64_t v9 = a1[15].i64[0];
  uint64_t result = 1LL;
  if (!__CFADD__(v9, a2) && v9 + a2 <= 0x3FFFFFFFC0LL)
  {
    ccpoly1305_update_internal(&a1[8].u32[2], a2, (unsigned int *)a3);
    ccchacha20_update_internal(a1, a2, a3, a4);
    uint64_t result = 0LL;
    a1[15].i64[0] += a2;
  }

  return result;
}

uint64_t ccchacha20poly1305_finalize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v5 = ccchacha20poly1305_finalize_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccchacha20poly1305_finalize_internal(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 248);
  if (v4 != 3)
  {
    if (v4 != 2) {
      return 1LL;
    }
    ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 232) & 0xFLL, (unsigned int *)kZero64);
    *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v11 - 96), 8) = 3;
  }

  ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 240) & 0xFLL, (unsigned int *)kZero64);
  uint64_t v6 = *(void *)(a1 + 232);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)&v6);
  uint64_t v6 = *(void *)(a1 + 240);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)&v6);
  ccpoly1305_final_internal(a1 + 136, a2);
  uint64_t result = 0LL;
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v11 - 96), 8) = 5;
  return result;
}

uint64_t ccchacha20poly1305_verify(uint64_t a1, uint64_t a2, char *a3)
{
  BOOL v7 = timingsafe_enable_if_supported();
  uint64_t v5 = ccchacha20poly1305_verify_internal(a2, a3);
  cc_disable_dit_with_sb((unsigned int *)&v7);
  return v5;
}

uint64_t ccchacha20poly1305_verify_internal(uint64_t a1, char *a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 248);
  if (v4 != 4)
  {
    if (v4 != 2) {
      return 1LL;
    }
    ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 232) & 0xFLL, (unsigned int *)kZero64);
    *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v11 - 96), 8) = 4;
  }

  v6[0] = 0LL;
  v6[1] = 0LL;
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), -*(_DWORD *)(a1 + 240) & 0xFLL, (unsigned int *)kZero64);
  uint64_t v7 = *(void *)(a1 + 232);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)&v7);
  uint64_t v7 = *(void *)(a1 + 240);
  ccpoly1305_update_internal((unsigned int *)(a1 + 136), 8uLL, (unsigned int *)&v7);
  ccpoly1305_final_internal(a1 + 136, (uint64_t)v6);
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v11 - 96), 8) = 5;
  else {
    return 0LL;
  }
}

unsigned int *_ccpoly1305_update(unsigned int *result, unint64_t a2, unsigned int *a3)
{
  int v4 = result;
  uint64_t v36 = 0LL;
  uint64_t v37 = 0LL;
  if (a2 < 0x10) {
    goto LABEL_5;
  }
  unsigned int v5 = result[9];
  unsigned int v6 = result[10];
  unsigned int v7 = result[11];
  unsigned int v8 = result[12];
  unsigned int v9 = result[13];
LABEL_3:
  uint64_t v10 = *a3;
  uint64_t v11 = a3[1];
  uint64_t v12 = a3[2];
  uint64_t v13 = a3[3];
  a3 += 4;
  a2 -= 16LL;
  unsigned int v14 = v5 + (v10 & 0x3FFFFFF);
  unsigned int v15 = (((v10 | (unint64_t)(v11 << 32)) >> 26) & 0x3FFFFFF) + v6;
  v4[9] = v14;
  v4[10] = v15;
  unsigned int v16 = (((v11 | (unint64_t)(v12 << 32)) >> 20) & 0x3FFFFFF) + v7;
  unsigned int v17 = v8 + (((v12 | (unint64_t)(v13 << 32)) >> 14) & 0x3FFFFFF);
  v4[11] = v16;
  v4[12] = v17;
  unsigned int v18 = v9 + (v13 >> 8) + 0x1000000;
  for (v4[13] = v18; ; unsigned int v18 = v4[13] + (HIDWORD(v37) >> 8))
  {
    unsigned int v19 = v4[1];
    unsigned int v21 = v4[7];
    unsigned int v20 = v4[8];
    unsigned int v22 = v4[6];
    unsigned int v24 = v4[3];
    unsigned int v23 = v4[4];
    unint64_t v25 = *v4 * (unint64_t)v14
        + v20 * (unint64_t)v15
        + v21 * (unint64_t)v16
        + v22 * (unint64_t)v17
        + v4[5] * (unint64_t)v18;
    unsigned int v26 = v4[2];
    unint64_t v27 = *v4 * (unint64_t)v18;
    int v28 = v25 & 0x3FFFFFF;
    unint64_t v29 = *v4 * (unint64_t)v15
        + v20 * (unint64_t)v16
        + v21 * (unint64_t)v17
        + v22 * (unint64_t)v18
        + v19 * (unint64_t)v14
        + (v25 >> 26);
    unsigned int v6 = v29 & 0x3FFFFFF;
    uint64_t result = (unsigned int *)(*v4 * (unint64_t)v16 + v20 * (unint64_t)v17);
    unint64_t v30 = (unint64_t)result
        + v21 * (unint64_t)v18
        + v19 * (unint64_t)v15
        + v26 * (unint64_t)v14
        + (v29 >> 26);
    unsigned int v7 = v30 & 0x3FFFFFF;
    unint64_t v31 = *v4 * (unint64_t)v17
        + v20 * (unint64_t)v18
        + v19 * (unint64_t)v16
        + v26 * (unint64_t)v15
        + v24 * (unint64_t)v14
        + (v30 >> 26);
    unsigned int v8 = v31 & 0x3FFFFFF;
    v4[11] = v30 & 0x3FFFFFF;
    v4[12] = v31 & 0x3FFFFFF;
    unint64_t v32 = v27
        + v19 * (unint64_t)v17
        + v26 * (unint64_t)v16
        + v24 * (unint64_t)v15
        + v23 * (unint64_t)v14
        + (v31 >> 26);
    unsigned int v9 = v32 & 0x3FFFFFF;
    v4[13] = v32 & 0x3FFFFFF;
    unsigned int v5 = 5 * (v32 >> 26) + v28;
    v4[9] = v5;
    v4[10] = v6;
    if (a2 > 0xF) {
      goto LABEL_3;
    }
LABEL_5:
    if (!a2) {
      break;
    }
    for (uint64_t i = 0LL; i != a2; ++i)
      *((_BYTE *)&v36 + i) = *((_BYTE *)a3 + i);
    *((_BYTE *)&v36 + a2) = 1;
    if ((unint64_t)(i - 1) <= 0xD)
    {
      __int32 v34 = (char *)&v36 + i + 1;
      unint64_t v35 = 14 - a2;
      if (a2 > 0xE) {
        unint64_t v35 = 0LL;
      }
      bzero(v34, v35 + 1);
    }

    a2 = 0LL;
    unsigned int v14 = v4[9] + (v36 & 0x3FFFFFF);
    unsigned int v15 = (((v36 | ((unint64_t)HIDWORD(v36) << 32)) >> 26) & 0x3FFFFFF) + v4[10];
    unsigned int v16 = (((HIDWORD(v36) | ((unint64_t)v37 << 32)) >> 20) & 0x3FFFFFF) + v4[11];
    unsigned int v17 = v4[12] + (((v37 | ((unint64_t)HIDWORD(v37) << 32)) >> 14) & 0x3FFFFFF);
  }

  return result;
}

uint64_t ccctr_init_internal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t ccctr_update_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(a2, a3, a4, a5);
}

uint64_t ccoid_size(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1) + 2LL;
}

uint64_t ccec_generate_key_internal_fips_ws( uint64_t a1, uint64_t *a2, uint64_t (**a3)(void, uint64_t, uint64_t *), uint64_t **a4)
{
  uint64_t v8 = *a2;
  *a4 = a2;
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a1, v8);
  uint64_t v11 = cczp_bitlen((uint64_t)a2);
  uint64_t result = (*a3)(a3, ((unint64_t)(v11 + 62) >> 3) & 0x1FFFFFFFFFFFFFF8LL, (uint64_t *)v10);
  if (!(_DWORD)result)
  {
    uint64_t result = ccec_generate_scalar_fips_retry_ws( a1,  a2,  (uint64_t (**)(void, unint64_t, void *))a3,  &a4[3 * **a4 + 2]);
    if (!(_DWORD)result) {
      uint64_t result = ccec_make_pub_from_priv_ws(a1, a2, a3, (uint64_t)&a4[3 * **a4 + 2], 0LL, a4);
    }
  }

  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t ccec_validate_point_and_projectify_ws(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *a2;
  uint64_t v9 = cczp_prime((uint64_t)a2);
  uint64_t v10 = *a2;
  uint64_t v11 = a4 + 8 * *a2;
  uint64_t v12 = cczp_prime((uint64_t)a2);
  uint64_t result = ccec_projectify_ws(a1, (uint64_t)a2);
  if (!(_DWORD)result)
  {
    else {
      return 4294967289LL;
    }
  }

  return result;
}

uint64_t ccec_compact_import_pub_ws( uint64_t a1, unint64_t *a2, uint64_t a3, unsigned __int8 *a4, unint64_t **a5)
{
  uint64_t v8 = *(void *)(a1 + 16);
  *a5 = a2;
  uint64_t v9 = a5 + 2;
  uint64_t result = ccec_import_affine_point_ws(a1, a2, 4, a3, a4, a5 + 2);
  if (!(_DWORD)result)
  {
    ccn_seti(*a2, &v9[2 * **a5], 1LL);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(a1 + 24))(a1, 3 * *a2);
    uint64_t result = ccec_validate_point_and_projectify_ws(a1, (uint64_t *)a2, v11, (uint64_t)(a5 + 2));
  }

  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t ccec_compact_import_pub( unint64_t *a1, uint64_t a2, unsigned __int8 *a3, unint64_t **a4)
{
  uint64_t v8 = cc_malloc_clear(160 * *a1);
  uint64_t v9 = 20 * *a1;
  v12[0] = v8;
  v12[1] = v9;
  v12[2] = 0LL;
  unint64_t v12[3] = cc_ws_alloc;
  uint64_t v13 = cc_ws_free;
  if (!v8) {
    return 4294967283LL;
  }
  uint64_t v10 = ccec_compact_import_pub_ws((uint64_t)v12, a1, a2, a3, a4);
  v13((uint64_t)v12);
  return v10;
}

uint64_t ccn_cmp_asm(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  if (result)
  {
    unint64_t v3 = result;
    uint64_t result = 0LL;
    do
    {
      unint64_t v5 = *a2++;
      unint64_t v4 = v5;
      unint64_t v6 = *a3++;
      BOOL v7 = v4 >= v6;
      if (v4 > v6) {
        uint64_t result = 1LL;
      }
      if (!v7) {
        uint64_t result = -1LL;
      }
    }

    while (v3-- > 1);
  }

  return result;
}

uint64_t cc_disable_dit_with_sb(unsigned int *a1)
{
  return timingsafe_restore_if_supported(*a1);
}

uint64_t compatibilityInitializeAvailabilityCheck()
{
  return _initializeAvailabilityCheck(1LL);
}

uint64_t initializeAvailabilityCheck()
{
  return _initializeAvailabilityCheck(0LL);
}

uint64_t _initializeAvailabilityCheck(uint64_t result)
{
  unint64_t v1 = (void *)qword_3B1C68;
  if (qword_3B1C68) {
    BOOL v2 = (_DWORD)result == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    if (&__availability_version_check)
    {
      qword_3B1C68 = (uint64_t)&__availability_version_check;
      unint64_t v1 = &__availability_version_check;
    }

    if (!v1 || (_DWORD)result != 0)
    {
      uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "kCFAllocatorNull");
      if (result)
      {
        unint64_t v4 = *(unsigned __int8 **)result;
        uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFDataCreateWithBytesNoCopy");
        if (result)
        {
          unint64_t v5 = (uint64_t (*)(void))result;
          unint64_t v6 = (unint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateWithData");
          uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateFromXMLData");
          if (v6 | result)
          {
            BOOL v7 = (uint64_t (*)(void, uint64_t, void, void))result;
            uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringCreateWithCStringNoCopy");
            if (result)
            {
              uint64_t v8 = (uint64_t (*)(void, const char *, uint64_t, unsigned __int8 *))result;
              uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFDictionaryGetValue");
              if (result)
              {
                uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t))result;
                uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFGetTypeID");
                if (result)
                {
                  uint64_t v10 = (uint64_t (*)(uint64_t))result;
                  uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringGetTypeID");
                  if (result)
                  {
                    uint64_t v11 = (uint64_t (*)(void))result;
                    uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringGetCString");
                    int v28 = (unsigned int (*)(uint64_t, char *, uint64_t, uint64_t))result;
                    if (result)
                    {
                      uint64_t result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFRelease");
                      if (result)
                      {
                        uint64_t v12 = (FILE *)result;
                        uint64_t result = (uint64_t)fopen("/System/Library/CoreServices/SystemVersion.plist", "r");
                        if (result)
                        {
                          uint64_t v13 = (FILE *)result;
                          unint64_t v27 = v12;
                          fseek((FILE *)result, 0LL, 2);
                          uint64_t v14 = ftell(v13);
                          if (v14 < 0)
                          {
                            unsigned int v16 = 0LL;
                          }

                          else
                          {
                            size_t v15 = v14;
                            rewind(v13);
                            unsigned int v16 = malloc(v15);
                            if (v16)
                            {
                              unsigned int v26 = v16;
                              if (fread(v16, 1uLL, v15, v13) == v15)
                              {
                                uint64_t v17 = v5(0LL);
                                if (v17)
                                {
                                  uint64_t v18 = v17;
                                  unsigned int v19 = v13;
                                  if (v6) {
                                    uint64_t v20 = ((uint64_t (*)(void, uint64_t, void, void, void))v6)( 0LL,  v17,  0LL,  0LL,  0LL);
                                  }
                                  else {
                                    uint64_t v20 = v7(0LL, v17, 0LL, 0LL);
                                  }
                                  uint64_t v21 = v20;
                                  if (v20)
                                  {
                                    uint64_t v22 = v8(0LL, "ProductVersion", 1536LL, v4);
                                    if (v22)
                                    {
                                      uint64_t v23 = v22;
                                      uint64_t v24 = v9(v21, v22);
                                      ((void (*)(uint64_t))v27)(v23);
                                      if (v24)
                                      {
                                        uint64_t v25 = v10(v24);
                                        if (v25 == v11())
                                        {
                                          if (v28(v24, v29, 32LL, 134217984LL)) {
                                            sscanf(v29, "%d.%d.%d", &_MergedGlobals, &dword_3B1C4C, &dword_3B1C50);
                                          }
                                        }
                                      }
                                    }

                                    ((void (*)(uint64_t))v27)(v21);
                                    unsigned int v19 = v13;
                                  }

                                  ((void (*)(uint64_t))v27)(v18);
                                }

                                else
                                {
                                  unsigned int v19 = v13;
                                }

                                unsigned int v16 = v26;
                              }

                              else
                              {
                                unsigned int v16 = v26;
                                unsigned int v19 = v13;
                              }

                              goto LABEL_41;
                            }
                          }

                          unsigned int v19 = v13;
LABEL_41:
                          free(v16);
                          return fclose(v19);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t getDigestSizeForDigestInfo(uint64_t a1)
{
  return *(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL;
}

uint64_t getCMACContextSize()
{
  uint64_t v0 = *((void *)ccaes_cbc_encrypt_mode() + 1);
  return v0 + *(void *)ccaes_cbc_encrypt_mode() + 80;
}

uint64_t getccec_full_ctx_size(void *a1)
{
  return (32LL * *a1) | 0x10;
}

uint64_t getccec_pub_ctx_size(void *a1)
{
  return 24LL * *a1 + 16;
}

uint64_t ccrng_generate_bridge(uint64_t (**a1)(void))
{
  uint64_t result = (*a1)();
  if ((_DWORD)result) {
    abort();
  }
  return result;
}

BOOL keyIsCompactRepresentable(unsigned __int8 *a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4 = (uint64_t **)((char *)&v10 - *a3);
  BOOL result = ccec_validate_pub(v4);
  if (result)
  {
    unint64_t v7 = *a3;
    __chkstk_darwin(result, v6);
    uint64_t v9 = (unint64_t *)((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    ccn_sub(v7, v9, *v4 + 3, (unint64_t *)&v4[**v4 + 2]);
    return (int)ccn_cmp(v7, v9, (unint64_t *)&v4[**v4 + 2]) >= 0;
  }

  return result;
}

unint64_t groupOrderByteCountForCP(void *a1)
{
  return (unint64_t)(cczp_bitlen((uint64_t)&a1[5 * *a1 + 4]) + 7) >> 3;
}

uint64_t sub_20E7C8()
{
  uint64_t result = sub_21399C(6514035LL, 0xE300000000000000LL);
  qword_3A7C70 = result;
  *(void *)algn_3A7C78 = v1;
  return result;
}

uint64_t sub_20E7F4()
{
  uint64_t v1 = *(void *)(v0 + 64);
  sub_1F83C0(v1, *(void *)(v0 + 72));
  return v1;
}

uint64_t sub_20E824@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (a2 < 1)
  {
    __break(1u);
  }

  else
  {
    uint64_t v5 = v7;
    unint64_t v8 = a2;
    uint64_t v11 = a1;
    uint64_t v14 = a5;
    uint64_t v33 = a4;
    uint64_t v34 = a3;
    uint64_t v9 = *(void *)(v6 + 32);
    uint64_t v10 = *(char *)(v6 + 40);
    uint64_t v12 = *(unsigned __int8 *)(v6 + 41);
    uint64_t v13 = *(char *)(v6 + 42);
    uint64_t v36 = v9;
    uint64_t v15 = qword_3A7C68;
    swift_retain(v9);
    if (v15 == -1)
    {
      if (!(v8 >> 16)) {
        goto LABEL_4;
      }
LABEL_8:
      __break(1u);
      goto LABEL_9;
    }
  }

  swift_once(&qword_3A7C68, sub_20E7C8);
  if (v8 >> 16) {
    goto LABEL_8;
  }
LABEL_4:
  unint64_t v31 = (size_t *)v14;
  uint64_t v32 = v11;
  uint64_t v14 = qword_3A7C70;
  uint64_t v5 = *(void *)algn_3A7C78;
  if (qword_3A7CF0 != -1) {
LABEL_9:
  }
    swift_once(&qword_3A7CF0, sub_2303E8);
  __int128 v35 = xmmword_3A8A38;
  uint64_t v16 = qword_280458[v10];
  sub_1F83C0(xmmword_3A8A38, *((unint64_t *)&xmmword_3A8A38 + 1));
  sub_2308A8(v16, 2LL);
  uint64_t v18 = v17;
  unint64_t v20 = v19;
  Data.append(_:)(v17, v19);
  sub_1F86D4(v18, v20);
  sub_2308A8(v12 + 1, 2LL);
  uint64_t v22 = v21;
  unint64_t v24 = v23;
  Data.append(_:)(v21, v23);
  sub_1F86D4(v22, v24);
  sub_2308A8(qword_280478[v13], 2LL);
  uint64_t v26 = v25;
  unint64_t v28 = v27;
  Data.append(_:)(v25, v27);
  sub_1F86D4(v26, v28);
  __int128 v29 = v35;
  LOBYTE(v35) = v12;
  sub_22C1E4(&v36, v14, v5, v32, v8, v29, *((uint64_t *)&v35 + 1), (unsigned __int8 *)&v35, v31, v34, v33);
  sub_1F86D4(v29, *((unint64_t *)&v29 + 1));
  return swift_release(v9);
}

uint64_t sub_20EA04@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v14 = *(void *)(a5 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v16 = (uint64_t *)((char *)&v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  char v18 = *((_BYTE *)v17 + 2);
  __int16 v35 = *v17;
  char v36 = v18;
  uint64_t v28 = 0LL;
  (*(void (**)(uint64_t *, uint64_t, uint64_t))(v14 + 16))(v16, a1, v19);
  sub_230A4C((char *)&v35, 0LL, &v28, 0LL, 0xF000000000000000LL, v16, a3, a4, v29, a5, a6);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 8))(a1, a5);
  if (!v7)
  {
    uint64_t v21 = v30;
    __int16 v22 = v31;
    char v23 = v32;
    uint64_t v24 = v33;
    unint64_t v25 = v34;
    __int128 v26 = v29[1];
    *(_OWORD *)a7 = v29[0];
    *(_OWORD *)(a7 + 16) = v26;
    *(void *)(a7 + 32) = v21;
    *(_WORD *)(a7 + 40) = v22;
    *(_BYTE *)(a7 + 42) = v23;
    *(void *)(a7 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v24;
    *(void *)(a7 + 56) = v25;
    *(void *)(a7 + 64) = v24;
    *(void *)(a7 + 72) = v25;
    return sub_1F83C0(v24, v25);
  }

  return result;
}

uint64_t sub_20EB34@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>, uint64_t a9)
{
  unint64_t v32 = a6;
  uint64_t v15 = *(void *)(a7 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v17 = (uint64_t *)((char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  char v19 = *((_BYTE *)v18 + 2);
  uint64_t v21 = *v20;
  __int16 v41 = *v18;
  char v42 = v19;
  uint64_t v34 = v21;
  (*(void (**)(uint64_t *, uint64_t, uint64_t))(v15 + 16))(v17, a1, v22);
  uint64_t v23 = v33;
  sub_230A4C((char *)&v41, 1LL, &v34, a5, v32, v17, a3, a4, v35, a7, a9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 8))(a1, a7);
  if (!v23)
  {
    uint64_t v25 = v36;
    __int16 v26 = v37;
    char v27 = v38;
    uint64_t v28 = v39;
    unint64_t v29 = v40;
    __int128 v30 = v35[1];
    *(_OWORD *)a8 = v35[0];
    *(_OWORD *)(a8 + 16) = v30;
    *(void *)(a8 + 32) = v25;
    *(_WORD *)(a8 + 40) = v26;
    *(_BYTE *)(a8 + 42) = v27;
    *(void *)(a8 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v28;
    *(void *)(a8 + 56) = v29;
    *(void *)(a8 + 64) = v28;
    *(void *)(a8 + 72) = v29;
    return sub_1F83C0(v28, v29);
  }

  return result;
}

uint64_t sub_20EC68@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, _OWORD *a8@<X8>)
{
  unint64_t v38 = a4;
  uint64_t v36 = a1;
  uint64_t v37 = a3;
  __int16 v35 = a8;
  uint64_t v12 = *(void *)(a6 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v14 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(v15 + 8),  v16,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v19);
  uint64_t v21 = (char *)&v34 - v20;
  LOWORD(v20) = *(_WORD *)a2;
  char v22 = *(_BYTE *)(a2 + 2);
  uint64_t v23 = v36;
  __int16 v48 = v20;
  char v49 = v22;
  uint64_t v41 = 0LL;
  (*(void (**)(char *, uint64_t, uint64_t))(v18 + 16))(v21, v36, AssociatedTypeWitness);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v40 = a5;
  v24(v14, a5, a6);
  uint64_t v25 = v39;
  sub_230DE4( (char *)&v48,  2u,  &v41,  0LL,  0xF000000000000000LL,  (uint64_t)v21,  v37,  v38,  (size_t *)v42,  (uint64_t)v14,  a6,  a7);
  (*(void (**)(uint64_t, uint64_t))(v12 + 8))(v40, a6);
  if (v25) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(v18 + 8))(v23, AssociatedTypeWitness);
  }
  (*(void (**)(uint64_t, uint64_t))(v18 + 8))(v23, AssociatedTypeWitness);
  uint64_t v27 = v43;
  __int16 v28 = v44;
  char v29 = v45;
  uint64_t v30 = v46;
  unint64_t v31 = v47;
  __int128 v32 = v42[1];
  uint64_t v33 = v35;
  *__int16 v35 = v42[0];
  v33[1] = v32;
  *((void *)v33 + 4) = v27;
  *((_WORD *)v33 + 20) = v28;
  *((_BYTE *)v33 + 42) = v29;
  *((void *)v33 + 6) = v30;
  *((void *)v33 + 7) = v31;
  *((void *)v33 + _Block_object_dispose((const void *)(v11 - 96), 8) = v30;
  *((void *)v33 + 9) = v31;
  return sub_1F83C0(v30, v31);
}

uint64_t sub_20EE3C@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X6>, unint64_t a8@<X7>, _OWORD *a9@<X8>, uint64_t a10, uint64_t a11)
{
  unint64_t v40 = a8;
  uint64_t v38 = a7;
  unint64_t v39 = a4;
  char v42 = a6;
  uint64_t v36 = a1;
  uint64_t v37 = a3;
  __int16 v35 = a9;
  uint64_t v13 = *(void *)(a10 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v15 = (char *)&v34 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a11 + 8),  a10,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v17 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v18);
  uint64_t v20 = (char *)&v34 - v19;
  LOWORD(v19) = *(_WORD *)a2;
  char v21 = *(_BYTE *)(a2 + 2);
  uint64_t v22 = v36;
  uint64_t v23 = *v42;
  __int16 v50 = v19;
  char v51 = v21;
  uint64_t v43 = v23;
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v20, v36, AssociatedTypeWitness);
  uint64_t v24 = *(void (**)(char *, uint64_t *, uint64_t))(v13 + 16);
  char v42 = a5;
  v24(v15, a5, a10);
  uint64_t v25 = v41;
  sub_230DE4((char *)&v50, 3u, &v43, v38, v40, (uint64_t)v20, v37, v39, (size_t *)v44, (uint64_t)v15, a10, a11);
  (*(void (**)(uint64_t *, uint64_t))(v13 + 8))(v42, a10);
  if (v25) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 8))(v22, AssociatedTypeWitness);
  }
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(v22, AssociatedTypeWitness);
  uint64_t v27 = v45;
  __int16 v28 = v46;
  char v29 = v47;
  uint64_t v30 = v48;
  unint64_t v31 = v49;
  __int128 v32 = v44[1];
  uint64_t v33 = v35;
  *__int16 v35 = v44[0];
  v33[1] = v32;
  *((void *)v33 + 4) = v27;
  *((_WORD *)v33 + 20) = v28;
  *((_BYTE *)v33 + 42) = v29;
  *((void *)v33 + 6) = v30;
  *((void *)v33 + 7) = v31;
  *((void *)v33 + _Block_object_dispose((const void *)(v11 - 96), 8) = v30;
  *((void *)v33 + 9) = v31;
  return sub_1F83C0(v30, v31);
}

uint64_t sub_20F018(uint64_t a1, uint64_t a2)
{
  return sub_22EAD4(a1, a2);
}

uint64_t sub_20F02C(uint64_t a1)
{
  __int128 v3 = xmmword_280350;
  sub_1F8404();
  return sub_22EAD4(a1, (uint64_t)&v3);
}

double sub_20F098@<D0>( uint64_t a1@<X0>, __int16 *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  unint64_t v35 = a6;
  unint64_t v33 = a4;
  uint64_t v34 = a5;
  uint64_t v32 = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(a8 + 8),  a7,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness);
  uint64_t v17 = __chkstk_darwin(v15, v16);
  uint64_t v19 = (char *)&v32 - v18;
  uint64_t v20 = *(void *)(a7 - 8);
  __chkstk_darwin(v17, v21);
  uint64_t v23 = (char *)&v32 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v24 = *((_BYTE *)a2 + 2);
  __int16 v43 = *a2;
  char v44 = v24;
  uint64_t v37 = 0LL;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v23, a1, a7);
  (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56LL))( v19,  1LL,  1LL,  AssociatedTypeWitness);
  uint64_t v25 = v36;
  sub_231434( (unsigned __int8 *)&v43,  0,  v34,  v35,  &v37,  0LL,  0xF000000000000000LL,  (size_t)v23,  (size_t *)v38,  v32,  v33,  v19,  a7,  a8);
  (*(void (**)(uint64_t, uint64_t))(v20 + 8))(a1, a7);
  if (!v25)
  {
    uint64_t v27 = v39;
    __int16 v28 = v40;
    char v29 = v41;
    double result = *(double *)v38;
    __int128 v30 = v38[1];
    __int128 v31 = v42;
    *(_OWORD *)a9 = v38[0];
    *(_OWORD *)(a9 + 16) = v30;
    *(void *)(a9 + 32) = v27;
    *(_WORD *)(a9 + 40) = v28;
    *(_BYTE *)(a9 + 42) = v29;
    *(_OWORD *)(a9 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v31;
  }

  return result;
}

double sub_20F24C@<D0>( uint64_t a1@<X0>, __int16 *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t *a7@<X6>, uint64_t a8@<X7>, _OWORD *a9@<X8>, unint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v42 = a8;
  uint64_t v40 = a5;
  unint64_t v41 = a6;
  uint64_t v37 = a3;
  unint64_t v38 = a4;
  uint64_t v36 = a9;
  unint64_t v39 = a10;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(a12 + 8),  a11,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v16 = type metadata accessor for Optional(0LL, AssociatedTypeWitness);
  uint64_t v18 = __chkstk_darwin(v16, v17);
  uint64_t v20 = (char *)&v35 - v19;
  uint64_t v21 = *(void *)(a11 - 8);
  __chkstk_darwin(v18, v22);
  char v24 = (char *)&v35 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v25 = *((_BYTE *)a2 + 2);
  uint64_t v26 = *a7;
  __int16 v50 = *a2;
  char v51 = v25;
  uint64_t v44 = v26;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v24, a1, a11);
  (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56LL))( v20,  1LL,  1LL,  AssociatedTypeWitness);
  uint64_t v27 = v43;
  sub_231434((unsigned __int8 *)&v50, 1u, v40, v41, &v44, v42, v39, (size_t)v24, (size_t *)v45, v37, v38, v20, a11, a12);
  (*(void (**)(uint64_t, uint64_t))(v21 + 8))(a1, a11);
  if (!v27)
  {
    uint64_t v29 = v46;
    __int16 v30 = v47;
    char v31 = v48;
    double result = *(double *)v45;
    __int128 v32 = v45[1];
    __int128 v33 = v49;
    uint64_t v34 = v36;
    _OWORD *v36 = v45[0];
    v34[1] = v32;
    *((void *)v34 + 4) = v29;
    *((_WORD *)v34 + 20) = v30;
    *((_BYTE *)v34 + 42) = v31;
    void v34[3] = v33;
  }

  return result;
}

double sub_20F40C@<D0>( uint64_t a1@<X0>, __int16 *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _OWORD *a9@<X8>, uint64_t a10)
{
  unint64_t v38 = a6;
  unint64_t v36 = a4;
  uint64_t v37 = a5;
  uint64_t v34 = a9;
  uint64_t v35 = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(a10 + 8),  a8,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness);
  uint64_t v17 = __chkstk_darwin(v15, v16);
  uint64_t v19 = (char *)&v34 - v18;
  uint64_t v20 = *(void *)(a8 - 8);
  __chkstk_darwin(v17, v21);
  uint64_t v23 = (char *)&v34 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v24 = *((_BYTE *)a2 + 2);
  __int16 v47 = *a2;
  char v48 = v24;
  uint64_t v40 = a1;
  uint64_t v41 = 0LL;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v23, a1, a8);
  uint64_t v25 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v25 + 16))(v19, a7, AssociatedTypeWitness);
  (*(void (**)(_BYTE *, void, uint64_t, uint64_t))(v25 + 56))(v19, 0LL, 1LL, AssociatedTypeWitness);
  uint64_t v26 = v39;
  sub_231434( (unsigned __int8 *)&v47,  2u,  v37,  v38,  &v41,  0LL,  0xF000000000000000LL,  (size_t)v23,  (size_t *)v42,  v35,  v36,  v19,  a8,  a10);
  (*(void (**)(uint64_t, uint64_t))(v25 + 8))(a7, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v20 + 8))(v40, a8);
  if (!v26)
  {
    uint64_t v28 = v43;
    __int16 v29 = v44;
    char v30 = v45;
    double result = *(double *)v42;
    __int128 v31 = v42[1];
    __int128 v32 = v46;
    __int128 v33 = v34;
    _OWORD *v34 = v42[0];
    v33[1] = v31;
    *((void *)v33 + 4) = v28;
    *((_WORD *)v33 + 20) = v29;
    *((_BYTE *)v33 + 42) = v30;
    void v33[3] = v32;
  }

  return result;
}

double sub_20F60C@<D0>( uint64_t a1@<X0>, __int16 *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t *a8@<X7>, _OWORD *a9@<X8>, uint64_t a10, unint64_t a11, uint64_t a12, uint64_t a13)
{
  unint64_t v47 = a6;
  uint64_t v40 = a9;
  uint64_t v41 = a7;
  unint64_t v45 = a4;
  uint64_t v46 = a5;
  uint64_t v43 = a10;
  uint64_t v44 = a3;
  unint64_t v42 = a11;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(a13 + 8),  a12,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v17 = type metadata accessor for Optional(0LL, AssociatedTypeWitness);
  uint64_t v19 = __chkstk_darwin(v17, v18);
  uint64_t v21 = (char *)&v39 - v20;
  uint64_t v22 = *(void *)(a12 - 8);
  __chkstk_darwin(v19, v23);
  uint64_t v25 = (char *)&v39 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v26 = *((_BYTE *)a2 + 2);
  uint64_t v27 = *a8;
  __int16 v56 = *a2;
  char v57 = v26;
  uint64_t v49 = a1;
  uint64_t v50 = v27;
  uint64_t v28 = a1;
  uint64_t v29 = v41;
  (*(void (**)(char *, uint64_t, uint64_t))(v22 + 16))(v25, v28, a12);
  uint64_t v30 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v30 + 16))(v21, v29, AssociatedTypeWitness);
  (*(void (**)(_BYTE *, void, uint64_t, uint64_t))(v30 + 56))(v21, 0LL, 1LL, AssociatedTypeWitness);
  uint64_t v31 = v48;
  sub_231434((unsigned __int8 *)&v56, 3u, v46, v47, &v50, v43, v42, (size_t)v25, (size_t *)v51, v44, v45, v21, a12, a13);
  (*(void (**)(uint64_t, uint64_t))(v30 + 8))(v29, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v22 + 8))(v49, a12);
  if (!v31)
  {
    uint64_t v33 = v52;
    __int16 v34 = v53;
    char v35 = v54;
    double result = *(double *)v51;
    __int128 v36 = v51[1];
    __int128 v37 = v55;
    unint64_t v38 = v40;
    *uint64_t v40 = v51[0];
    v38[1] = v36;
    *((void *)v38 + 4) = v33;
    *((_WORD *)v38 + 20) = v34;
    *((_BYTE *)v38 + 42) = v35;
    v38[3] = v37;
  }

  return result;
}

uint64_t sub_20F81C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_22ECCC(a1, a2, a3, a4);
}

uint64_t sub_20F830(uint64_t a1, uint64_t a2)
{
  __int128 v5 = xmmword_280350;
  sub_1F8404();
  return sub_22ECCC(a1, (uint64_t)&v5, a2, (uint64_t)&type metadata for Data);
}

ValueMetadata *type metadata accessor for HPKE()
{
  return &type metadata for HPKE;
}

uint64_t _s11KeyScheduleVwCP(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain(v2);
  return v3;
}

uint64_t destroy for HPKE.Sender(void *a1)
{
  unint64_t v2 = a1[3];
  if (v2 >> 60 != 15) {
    sub_1F86D4(a1[2], v2);
  }
  swift_release(a1[4]);
  sub_1F86D4(a1[6], a1[7]);
  return sub_1F86D4(a1[8], a1[9]);
}

uint64_t initializeWithCopy for HPKE.Sender(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  __int128 v5 = (_OWORD *)(a2 + 16);
  unint64_t v6 = *(void *)(a2 + 24);
  swift_retain(v4);
  if (v6 >> 60 == 15)
  {
    *(_OWORD *)(a1 + 16) = *v5;
  }

  else
  {
    uint64_t v7 = *(void *)v5;
    sub_1F83C0(v7, v6);
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v6;
  }

  uint64_t v8 = *(void *)(a2 + 32);
  *(void *)(a1 + 32) = v8;
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  *(_BYTE *)(a1 + 42) = *(_BYTE *)(a2 + 42);
  uint64_t v9 = *(void *)(a2 + 48);
  unint64_t v10 = *(void *)(a2 + 56);
  swift_retain(v8);
  sub_1F83C0(v9, v10);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v9;
  *(void *)(a1 + 56) = v10;
  uint64_t v12 = *(void *)(a2 + 64);
  unint64_t v11 = *(void *)(a2 + 72);
  sub_1F83C0(v12, v11);
  *(void *)(a1 + 64) = v12;
  *(void *)(a1 + 72) = v11;
  return a1;
}

uint64_t assignWithCopy for HPKE.Sender(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
  swift_retain(v5);
  swift_release(v4);
  unint64_t v6 = (uint64_t *)(a2 + 16);
  unint64_t v7 = *(void *)(a2 + 24);
  if (*(void *)(a1 + 24) >> 60 != 15LL)
  {
    if (v7 >> 60 != 15)
    {
      uint64_t v9 = *v6;
      sub_1F83C0(*v6, *(void *)(a2 + 24));
      uint64_t v10 = *(void *)(a1 + 16);
      unint64_t v11 = *(void *)(a1 + 24);
      *(void *)(a1 + 16) = v9;
      *(void *)(a1 + 24) = v7;
      sub_1F86D4(v10, v11);
      goto LABEL_8;
    }

    sub_20FB18(a1 + 16);
    goto LABEL_6;
  }

  if (v7 >> 60 == 15)
  {
LABEL_6:
    *(_OWORD *)(a1 + 16) = *(_OWORD *)v6;
    goto LABEL_8;
  }

  uint64_t v8 = *v6;
  sub_1F83C0(*v6, *(void *)(a2 + 24));
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = v7;
LABEL_8:
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v13 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v12;
  swift_retain(v12);
  swift_release(v13);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 41);
  *(_BYTE *)(a1 + 42) = *(_BYTE *)(a2 + 42);
  uint64_t v14 = *(void *)(a2 + 48);
  unint64_t v15 = *(void *)(a2 + 56);
  sub_1F83C0(v14, v15);
  uint64_t v16 = *(void *)(a1 + 48);
  unint64_t v17 = *(void *)(a1 + 56);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v14;
  *(void *)(a1 + 56) = v15;
  sub_1F86D4(v16, v17);
  uint64_t v19 = *(void *)(a2 + 64);
  unint64_t v18 = *(void *)(a2 + 72);
  sub_1F83C0(v19, v18);
  uint64_t v20 = *(void *)(a1 + 64);
  unint64_t v21 = *(void *)(a1 + 72);
  *(void *)(a1 + 64) = v19;
  *(void *)(a1 + 72) = v18;
  sub_1F86D4(v20, v21);
  return a1;
}

uint64_t sub_20FB18(uint64_t a1)
{
  return a1;
}

__n128 __swift_memcpy80_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(__n128 *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 32) = v3;
  return result;
}

uint64_t assignWithTake for HPKE.Sender(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
  swift_release(v4);
  unint64_t v6 = (void *)(a2 + 16);
  unint64_t v7 = *(void *)(a1 + 24);
  if (v7 >> 60 != 15)
  {
    unint64_t v8 = *(void *)(a2 + 24);
    if (v8 >> 60 != 15)
    {
      uint64_t v9 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = *v6;
      *(void *)(a1 + 24) = v8;
      sub_1F86D4(v9, v7);
      goto LABEL_6;
    }

    sub_20FB18(a1 + 16);
  }

  *(_OWORD *)(a1 + 16) = *(_OWORD *)v6;
LABEL_6:
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_release(v10);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_WORD *)(a1 + 41) = *(_WORD *)(a2 + 41);
  uint64_t v11 = *(void *)(a1 + 48);
  unint64_t v12 = *(void *)(a1 + 56);
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 48);
  sub_1F86D4(v11, v12);
  uint64_t v13 = *(void *)(a1 + 64);
  unint64_t v14 = *(void *)(a1 + 72);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  sub_1F86D4(v13, v14);
  return a1;
}

uint64_t getEnumTagSinglePayload for HPKE.Sender(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 80)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for HPKE.Sender(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 72) = 0LL;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 80) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 32) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 80) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for HPKE.Sender()
{
  return &type metadata for HPKE.Sender;
}

uint64_t _s7ContextVwxx(void *a1)
{
  unint64_t v2 = a1[3];
  if (v2 >> 60 != 15) {
    sub_1F86D4(a1[2], v2);
  }
  swift_release(a1[4]);
  return sub_1F86D4(a1[6], a1[7]);
}

uint64_t _s7ContextVwcp(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  uint64_t v5 = (_OWORD *)(a2 + 16);
  unint64_t v6 = *(void *)(a2 + 24);
  swift_retain(v4);
  if (v6 >> 60 == 15)
  {
    *(_OWORD *)(a1 + 16) = *v5;
  }

  else
  {
    uint64_t v7 = *(void *)v5;
    sub_1F83C0(v7, v6);
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v6;
  }

  uint64_t v8 = *(void *)(a2 + 32);
  *(void *)(a1 + 32) = v8;
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  *(_BYTE *)(a1 + 42) = *(_BYTE *)(a2 + 42);
  uint64_t v10 = *(void *)(a2 + 48);
  unint64_t v9 = *(void *)(a2 + 56);
  swift_retain(v8);
  sub_1F83C0(v10, v9);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v10;
  *(void *)(a1 + 56) = v9;
  return a1;
}

uint64_t _s7ContextVwca(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
  swift_retain(v5);
  swift_release(v4);
  unint64_t v6 = (uint64_t *)(a2 + 16);
  unint64_t v7 = *(void *)(a2 + 24);
  if (*(void *)(a1 + 24) >> 60 != 15LL)
  {
    if (v7 >> 60 != 15)
    {
      uint64_t v9 = *v6;
      sub_1F83C0(*v6, *(void *)(a2 + 24));
      uint64_t v10 = *(void *)(a1 + 16);
      unint64_t v11 = *(void *)(a1 + 24);
      *(void *)(a1 + 16) = v9;
      *(void *)(a1 + 24) = v7;
      sub_1F86D4(v10, v11);
      goto LABEL_8;
    }

    sub_20FB18(a1 + 16);
    goto LABEL_6;
  }

  if (v7 >> 60 == 15)
  {
LABEL_6:
    *(_OWORD *)(a1 + 16) = *(_OWORD *)v6;
    goto LABEL_8;
  }

  uint64_t v8 = *v6;
  sub_1F83C0(*v6, *(void *)(a2 + 24));
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = v7;
LABEL_8:
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v13 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v12;
  swift_retain(v12);
  swift_release(v13);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 41);
  *(_BYTE *)(a1 + 42) = *(_BYTE *)(a2 + 42);
  uint64_t v15 = *(void *)(a2 + 48);
  unint64_t v14 = *(void *)(a2 + 56);
  sub_1F83C0(v15, v14);
  uint64_t v16 = *(void *)(a1 + 48);
  unint64_t v17 = *(void *)(a1 + 56);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v15;
  *(void *)(a1 + 56) = v14;
  sub_1F86D4(v16, v17);
  return a1;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t _s7ContextVwta(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
  swift_release(v4);
  unint64_t v6 = (void *)(a2 + 16);
  unint64_t v7 = *(void *)(a1 + 24);
  if (v7 >> 60 != 15)
  {
    unint64_t v8 = *(void *)(a2 + 24);
    if (v8 >> 60 != 15)
    {
      uint64_t v9 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = *v6;
      *(void *)(a1 + 24) = v8;
      sub_1F86D4(v9, v7);
      goto LABEL_6;
    }

    sub_20FB18(a1 + 16);
  }

  *(_OWORD *)(a1 + 16) = *(_OWORD *)v6;
LABEL_6:
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_release(v10);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_WORD *)(a1 + 41) = *(_WORD *)(a2 + 41);
  uint64_t v11 = *(void *)(a1 + 48);
  unint64_t v12 = *(void *)(a1 + 56);
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 48);
  sub_1F86D4(v11, v12);
  return a1;
}

uint64_t _s7ContextVwet(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 64)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t _s7ContextVwst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 56) = 0LL;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 64) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 32) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 64) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for HPKE.Recipient()
{
  return &type metadata for HPKE.Recipient;
}

void type metadata accessor for ccdigest_ctx(uint64_t a1)
{
}

__n128 __swift_memcpy72_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t sub_210090(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 72)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 48);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

uint64_t sub_2100EC(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(void *)__n128 result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(_BYTE *)(result + 72) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(_BYTE *)(result + 72) = 0;
    }
    if (a2) {
      *(void *)(result + 4_Block_object_dispose((const void *)(v11 - 96), 8) = a2;
    }
  }

  return result;
}

void type metadata accessor for ccdigest_info(uint64_t a1)
{
}

__n128 __swift_memcpy256_8(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  __int128 v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __int128 v5 = a2[4];
  __int128 v6 = a2[5];
  __int128 v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  __int128 v8 = a2[8];
  __int128 v9 = a2[9];
  __int128 v10 = a2[11];
  *(_OWORD *)(a1 + 160) = a2[10];
  *(_OWORD *)(a1 + 176) = v10;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v11 - 96), 8) = v8;
  *(_OWORD *)(a1 + 144) = v9;
  __n128 result = (__n128)a2[12];
  __int128 v12 = a2[13];
  __int128 v13 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 240) = v13;
  *(__n128 *)(a1 + 192) = result;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v11 - 96), 8) = v12;
  return result;
}

uint64_t sub_2101A8(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_2101C8(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 24_Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 16_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 8_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 256) = v3;
  return result;
}

void type metadata accessor for ccchacha20poly1305_ctx(uint64_t a1)
{
}

uint64_t sub_210248(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 80)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 24);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

uint64_t sub_2102A4(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)(result + 72) = 0LL;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(void *)__n128 result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(_BYTE *)(result + 80) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(_BYTE *)(result + 80) = 0;
    }
    if (a2) {
      *(void *)(result + 24) = a2;
    }
  }

  return result;
}

void type metadata accessor for ccmode_gcm(uint64_t a1)
{
}

void type metadata accessor for ccgcm_ctx(uint64_t a1)
{
}

__n128 __swift_memcpy32_8(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for SHA256Digest(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for SHA256Digest(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 32) = v3;
  return result;
}

void type metadata accessor for ccec_cp(uint64_t a1)
{
}

void type metadata accessor for cc_impl(uint64_t a1)
{
}

void type metadata accessor for ccdigest_state(uint64_t a1)
{
}

__n128 __swift_memcpy96_8(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  __int128 v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  return result;
}

uint64_t sub_2103E4(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 96)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_210404(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 8_Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 96) = v3;
  return result;
}

void type metadata accessor for ccpoly1305_ctx(uint64_t a1)
{
}

__n128 __swift_memcpy136_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __int128 v2 = *(_OWORD *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(_OWORD *)(a1 + 16) = v2;
  *(_OWORD *)(a1 + 32) = v3;
  __n128 result = *(__n128 *)(a2 + 80);
  __int128 v6 = *(_OWORD *)(a2 + 96);
  __int128 v7 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v11 - 96), 8) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 96) = v6;
  *(_OWORD *)(a1 + 112) = v7;
  *(__n128 *)(a1 + 80) = result;
  return result;
}

uint64_t sub_210490(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 136)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_2104B0(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 8_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 136) = v3;
  return result;
}

void type metadata accessor for ccchacha20_ctx(uint64_t a1)
{
}

void sub_210524()
{
  uint64_t v1 = *v0;
  if (*((_BYTE *)v0 + 4) == 1) {
    __asm { BR              X9 }
  }

  Hasher._combine(_:)(3uLL);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_2105B0()
{
  uint64_t v1 = *v0;
  int v2 = *((unsigned __int8 *)v0 + 4);
  Hasher.init(_seed:)(v4);
  if (v2 == 1) {
    __asm { BR              X9 }
  }

  Hasher._combine(_:)(3uLL);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_210674()
{
  uint64_t v1 = *v0;
  if (*((_BYTE *)v0 + 4) == 1) {
    __asm { BR              X9 }
  }

  Hasher._combine(_:)(3uLL);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_210700()
{
  uint64_t v1 = *v0;
  int v2 = *((unsigned __int8 *)v0 + 4);
  Hasher.init(_seed:)(v4);
  if (v2 == 1) {
    __asm { BR              X9 }
  }

  Hasher._combine(_:)(3uLL);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL sub_2107BC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void sub_2107D0()
{
}

Swift::Int sub_2107F8()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

Swift::Int sub_21083C()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

uint64_t sub_21087C(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*((_BYTE *)a1 + 4) == 1) {
    return ((uint64_t (*)(void))((char *)&loc_2108AC + 4 * byte_2804B8[v2]))();
  }
  if ((*(_BYTE *)(a2 + 4) & 1) != 0) {
    return 0LL;
  }
  return (_DWORD)v2 == *(_DWORD *)a2;
}

uint64_t sub_2108D8@<X0>(char a1@<W8>)
{
  if (v1 != 1) {
    a1 = 0;
  }
  if ((a1 & 1) == 0) {
    JUMPOUT(0x2108C4LL);
  }
  return 1LL;
}

uint64_t sub_2108EC@<X0>(char a1@<W8>)
{
  if (v1 != 2) {
    a1 = 0;
  }
  if ((a1 & 1) == 0) {
    JUMPOUT(0x2108C4LL);
  }
  return 1LL;
}

uint64_t sub_210900@<X0>(char a1@<W8>)
{
  if (v1 != 3) {
    a1 = 0;
  }
  if ((a1 & 1) == 0) {
    JUMPOUT(0x2108C4LL);
  }
  return 1LL;
}

uint64_t sub_210914@<X0>(char a1@<W8>)
{
  if (v1 != 4) {
    a1 = 0;
  }
  if ((a1 & 1) == 0) {
    JUMPOUT(0x2108C4LL);
  }
  return 1LL;
}

uint64_t sub_210928@<X0>(char a1@<W8>)
{
  if (v1 <= 4) {
    a1 = 0;
  }
  if ((a1 & 1) == 0) {
    JUMPOUT(0x2108C4LL);
  }
  return 1LL;
}

unint64_t sub_210940()
{
  unint64_t result = qword_3A8048;
  if (!qword_3A8048)
  {
    unint64_t result = swift_getWitnessTable(&unk_280508, &type metadata for CryptoKitError);
    atomic_store(result, (unint64_t *)&qword_3A8048);
  }

  return result;
}

unint64_t sub_210988()
{
  unint64_t result = qword_3A8050;
  if (!qword_3A8050)
  {
    unint64_t result = swift_getWitnessTable(&unk_280570, &type metadata for CryptoKitASN1Error);
    atomic_store(result, (unint64_t *)&qword_3A8050);
  }

  return result;
}

uint64_t __swift_memcpy5_4(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(_BYTE *)(result + 4) = *((_BYTE *)a2 + 4);
  *(_DWORD *)unint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for CryptoKitError(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 5)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for CryptoKitError(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_BYTE *)(result + 4) = 0;
    *(_DWORD *)unint64_t result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 5) = v3;
  return result;
}

uint64_t sub_210A2C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_210A4C(uint64_t result, int a2)
{
  if (a2)
  {
    *(_DWORD *)unint64_t result = a2 - 1;
    *(_BYTE *)(result + 4) = 1;
  }

  else
  {
    *(_BYTE *)(result + 4) = 0;
  }

  return result;
}

ValueMetadata *type metadata accessor for CryptoKitError()
{
  return &type metadata for CryptoKitError;
}

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *unint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for CryptoKitASN1Error(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF9) {
    goto LABEL_17;
  }
  if (a2 + 7 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 7) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 7;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }

uint64_t storeEnumTagSinglePayload for CryptoKitASN1Error(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 7 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 7) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xF9) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF8) {
    return ((uint64_t (*)(void))((char *)&loc_210B64 + 4 * byte_2804C3[v4]))();
  }
  *a1 = a2 + 7;
  return ((uint64_t (*)(void))((char *)sub_210B98 + 4 * byte_2804BE[v4]))();
}

uint64_t sub_210B98(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_210BA0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x210BA8LL);
  }
  return result;
}

uint64_t sub_210BB4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x210BBCLL);
  }
  *(_BYTE *)unint64_t result = a2 + 7;
  return result;
}

uint64_t sub_210BC0(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_210BC8(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_210BD4(unsigned __int8 *a1)
{
  return *a1;
}

_BYTE *sub_210BDC(_BYTE *result, char a2)
{
  *unint64_t result = a2;
  return result;
}

ValueMetadata *type metadata accessor for CryptoKitASN1Error()
{
  return &type metadata for CryptoKitASN1Error;
}

uint64_t sub_210BF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = *a4;
  v15[0] = a2;
  v15[1] = a3;
  uint64_t v14 = v9;
  uint64_t v10 = type metadata accessor for HashedAuthenticationCode(0LL, a5, a6, (uint64_t)a4);
  uint64_t WitnessTable = swift_getWitnessTable(&unk_280724, v10);
  unint64_t v12 = sub_210E08();
  return sub_210C98( a1,  (uint64_t)v15,  &v14,  a5,  v10,  (uint64_t)&type metadata for UnsafeRawBufferPointer,  a6,  WitnessTable,  v12) & 1;
}

uint64_t sub_210C98( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v30 = a5;
  uint64_t v31 = a8;
  uint64_t v28 = a6;
  uint64_t v29 = a1;
  uint64_t v27 = a9;
  uint64_t v13 = type metadata accessor for HashedAuthenticationCode(0LL, a4, a7, a4);
  uint64_t v14 = *(void *)(v13 - 8);
  __chkstk_darwin(v13, v15);
  unint64_t v17 = (char *)&v27 - v16;
  uint64_t v19 = type metadata accessor for HMAC(0LL, a4, a7, v18);
  uint64_t v20 = *(void *)(v19 - 8);
  __chkstk_darwin(v19, v21);
  uint64_t v23 = (char *)&v27 - v22;
  uint64_t v32 = *a3;
  swift_retain(v32);
  sub_210E4C(&v32, a4, a7);
  sub_2116A0(a2, v19, v28, v27);
  sub_2117B0(v19, v24, v17);
  uint64_t WitnessTable = swift_getWitnessTable(&unk_280724, v13);
  LOBYTE(a2) = sub_23C734(v29, v17, v30, v13, v31, WitnessTable);
  (*(void (**)(char *, uint64_t))(v14 + 8))(v17, v13);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v23, v19);
  return a2 & 1;
}

uint64_t type metadata accessor for HashedAuthenticationCode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for HashedAuthenticationCode);
}

unint64_t sub_210E08()
{
  unint64_t result = qword_3A8058;
  if (!qword_3A8058)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeRawBufferPointer,  &type metadata for UnsafeRawBufferPointer);
    atomic_store(result, (unint64_t *)&qword_3A8058);
  }

  return result;
}

uint64_t sub_210E4C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  unsigned int v6 = (unint64_t *)(*a1 + 16LL);
  swift_beginAccess(v6, v31, 0LL, 0LL);
  uint64_t v7 = *(void *)(v5 + 16);
  int v8 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 24);
  if (v7 == v8(a2, a3))
  {
    uint64_t v33 = &type metadata for SymmetricKey;
    unint64_t v34 = sub_2122CC();
    v32[0] = v5;
    goto LABEL_18;
  }

  unint64_t v10 = *v6;
  uint64_t v11 = (char *)a2;
  if (v8(a2, a3) >= (uint64_t)v10)
  {
    uint64_t v16 = v8(a2, a3);
    if ((v16 & 0x8000000000000000LL) == 0)
    {
      unint64_t v10 = v16;
      if (v16)
      {
        uint64_t v11 = (char *)static Array._allocateBufferUninitialized(minimumCapacity:)(v16, &type metadata for UInt8);
        *((void *)v11 + 2) = v10;
        bzero(v11 + 32, v10);
      }

      else
      {
        uint64_t v11 = (char *)_swiftEmptyArrayStorage;
        unint64_t v10 = _swiftEmptyArrayStorage[2];
      }

      size_t v13 = *(void *)(v5 + 16);
      if (v10 >= v13)
      {
        if (v10 <= *((void *)v11 + 3) >> 1)
        {
          if (!v13)
          {
LABEL_17:
            swift_release(v5);
            uint64_t v33 = (ValueMetadata *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
            unint64_t v34 = sub_2129F8( (unint64_t *)&qword_3A8068,  &qword_3A8060,  (uint64_t)&protocol conformance descriptor for <A> [A]);
            v32[0] = v11;
            goto LABEL_18;
          }

uint64_t sub_2111CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, a5, a4, &unk_33EC10, &unk_33EC20);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v12);
  size_t v14 = &v18[-v13];
  sub_235F08(a1, a2, a4, a5);
  uint64_t v19 = a3;
  uint64_t v15 = *(void *)(swift_getAssociatedConformanceWitness(a5, a4, AssociatedTypeWitness, &unk_33EC10, &unk_33EC18) + 8);
  uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81E8);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_213958, v18, v16, AssociatedTypeWitness, v15);
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v11 + 8))(v14, AssociatedTypeWitness);
}

uint64_t sub_211300@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, char **a3@<X2>, char **a4@<X8>)
{
  if (result)
  {
    unsigned int v6 = (const void *)result;
    int v8 = *a3;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*a3);
    *a3 = v8;
    if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
      int v8 = sub_2121E4(0LL, *((void *)v8 + 2), 0, v8);
    }
    *a3 = v8;
    memcpy(v8 + 32, v6, a2 - (void)v6);
    unint64_t v10 = *a3;
    a4[3] = (char *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
    a4[4] = (char *)sub_2129F8( (unint64_t *)&qword_3A8068,  &qword_3A8060,  (uint64_t)&protocol conformance descriptor for <A> [A]);
    *a4 = v10;
    return swift_bridgeObjectRetain(v10);
  }

  else
  {
    __break(1u);
  }

  return result;
}

char *sub_2113C8@<X0>(char *result@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  if (!result)
  {
    uint64_t v5 = &_swiftEmptyArrayStorage;
    goto LABEL_10;
  }

  uint64_t v4 = result;
  uint64_t v5 = &_swiftEmptyArrayStorage;
  uint64_t v6 = a2 - result;
  if (a2 == result)
  {
LABEL_10:
    *a3 = v5;
    return result;
  }

  unint64_t result = sub_212670(0LL, v6 & ~(v6 >> 63), 0);
  if (v6 >= 1)
  {
    uint64_t v5 = &_swiftEmptyArrayStorage;
    unint64_t v7 = *((void *)&_swiftEmptyArrayStorage + 2);
    do
    {
      char v9 = *v4++;
      char v8 = v9;
      uint64_t v11 = v5;
      unint64_t v10 = v5[3];
      if (v7 >= v10 >> 1)
      {
        unint64_t result = sub_212670((char *)(v10 > 1), v7 + 1, 1);
        uint64_t v5 = v11;
      }

      _OWORD v5[2] = v7 + 1;
      *((_BYTE *)v5 + v7++ + 32) = v8 ^ 0x36;
      --v6;
    }

    while (v6);
    goto LABEL_10;
  }

  __break(1u);
  return result;
}

char *sub_2114C0@<X0>(char *result@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  if (!result)
  {
    uint64_t v5 = _swiftEmptyArrayStorage;
    goto LABEL_10;
  }

  uint64_t v4 = result;
  uint64_t v5 = _swiftEmptyArrayStorage;
  uint64_t v6 = a2 - result;
  if (a2 == result)
  {
LABEL_10:
    *a3 = v5;
    return result;
  }

  unint64_t result = sub_212670(0LL, v6 & ~(v6 >> 63), 0);
  if (v6 >= 1)
  {
    uint64_t v5 = _swiftEmptyArrayStorage;
    unint64_t v7 = _swiftEmptyArrayStorage[2];
    do
    {
      char v9 = *v4++;
      char v8 = v9;
      uint64_t v11 = v5;
      unint64_t v10 = v5[3];
      if (v7 >= v10 >> 1)
      {
        unint64_t result = sub_212670((char *)(v10 > 1), v7 + 1, 1);
        uint64_t v5 = v11;
      }

      _OWORD v5[2] = v7 + 1;
      *((_BYTE *)v5 + v7++ + 32) = v8 ^ 0x5C;
      --v6;
    }

    while (v6);
    goto LABEL_10;
  }

  __break(1u);
  return result;
}

uint64_t sub_2115B8@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, char *a7@<X8>)
{
  uint64_t v14 = type metadata accessor for HMAC(0LL, a3, a5, a4);
  uint64_t v15 = *(void *)(v14 - 8);
  __chkstk_darwin(v14, v16);
  uint64_t v18 = (char *)&v21 - v17;
  uint64_t v22 = *a2;
  swift_retain(v22);
  sub_210E4C(&v22, a3, a5);
  sub_2116A0(a1, v14, a4, a6);
  sub_2117B0(v14, v19, a7);
  return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, v14);
}

uint64_t sub_2116A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v10);
  uint64_t v12 = &v16[-v11];
  dispatch thunk of DataProtocol.regions.getter(a3, a4);
  uint64_t v13 = *(void *)(a2 + 24);
  uint64_t v17 = *(void *)(a2 + 16);
  uint64_t v18 = a3;
  uint64_t v19 = v13;
  uint64_t v20 = a4;
  uint64_t v21 = v4;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  Sequence.forEach(_:)( sub_212310,  v16,  AssociatedTypeWitness,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL));
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v9 + 8))(v12, AssociatedTypeWitness);
}

uint64_t sub_2117B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v25 = a3;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v26 = *(void *)(v4 - 8);
  uint64_t v5 = __chkstk_darwin(a1, a2);
  unint64_t v7 = (char *)&v25 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v5 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, v8, v4, &unk_33EC10, &unk_33EC20);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = __chkstk_darwin(AssociatedTypeWitness, v11);
  uint64_t v14 = (char *)&v25 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = __chkstk_darwin(v12, v15);
  uint64_t v18 = (char *)&v25 - v17;
  __chkstk_darwin(v16, v19);
  uint64_t v21 = (char *)&v25 - v20;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v4, v8);
  (*(void (**)(char *, uint64_t, uint64_t))(v26 + 16))(v7, v3, v4);
  uint64_t v28 = v4;
  uint64_t v29 = v8;
  uint64_t v30 = v7;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  &unk_33EC10,  &unk_33EC18);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_212330,  v27,  AssociatedTypeWitness,  AssociatedTypeWitness,  *(void *)(AssociatedConformanceWitness + 8));
  (*(void (**)(char *, uint64_t))(v10 + 8))(v21, AssociatedTypeWitness);
  uint64_t v23 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
  v23(v14, v18, AssociatedTypeWitness);
  v23(v25, v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v26 + 8))(v7, v4);
}

uint64_t sub_211988(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v16 = *a3;
  uint64_t v13 = type metadata accessor for HashedAuthenticationCode(0LL, a4, a6, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&unk_280724, v13);
  return sub_210C98(a1, a2, &v16, a4, v13, a5, a6, WitnessTable, a7) & 1;
}

uint64_t sub_211A30( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *a3;
  return sub_210C98(a1, a2, &v10, a4, a5, a6, a7, a8, a9) & 1;
}

uint64_t sub_211A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _OWORD v13[2] = a3;
  v13[3] = a4;
  void v13[4] = a5;
  v13[5] = a6;
  v13[6] = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a6,  a4,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  uint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL),  AssociatedTypeWitness,  &protocol requirements base descriptor for Sequence,  &associated type descriptor for Sequence.Element);
  uint64_t v11 = swift_getAssociatedConformanceWitness( a6,  a4,  v10,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions.Sequence.Element: ContiguousBytes);
  return dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_2138F8,  v13,  (char *)&type metadata for () + 8,  v10,  v11);
}

uint64_t sub_211B5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 40LL))( a1,  a2,  *(void *)(a3 + 16));
}

uint64_t sub_211B88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a4 - 8);
  uint64_t v9 = __chkstk_darwin();
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v12 + 40))(v9);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v11, a3, a4);
  (*(void (**)(uint64_t, uint64_t))(a5 + 48))(a4, a5);
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, a4);
}

uint64_t sub_211C4C(uint64_t a1)
{
  return sub_212778(*(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t sub_211C58(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, v2, v3, &unk_33EC10, &unk_33EC20);
  uint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v6);
  uint64_t v8 = (char *)&v25 - v7;
  uint64_t v28 = 0LL;
  unint64_t v29 = 0xE000000000000000LL;
  _StringGuts.grow(_:)(16LL);
  swift_bridgeObjectRelease(v29);
  uint64_t v28 = 0x7469772043414D48LL;
  unint64_t v29 = 0xEA00000000002068LL;
  v9._countAndFlagsBits = _typeName(_:qualified:)(v3, 0LL);
  object = v9._object;
  String.append(_:)(v9);
  swift_bridgeObjectRelease(object);
  v11._countAndFlagsBits = 8250LL;
  v11._object = (void *)0xE200000000000000LL;
  String.append(_:)(v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, v1, AssociatedTypeWitness);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v2,  v3,  AssociatedTypeWitness,  &unk_33EC10,  &unk_33EC18);
  uint64_t result = Array.init<A>(_:)( v8,  &type metadata for UInt8,  AssociatedTypeWitness,  *(void *)(AssociatedConformanceWitness + 32));
  uint64_t v14 = *(void *)(result + 16);
  if (v14 + 0x4000000000000000LL < 0)
  {
    __break(1u);
    goto LABEL_8;
  }

  size_t v15 = 2 * v14;
  if (2 * v14 < 0)
  {
LABEL_8:
    __break(1u);
    return result;
  }

  uint64_t v16 = result;
  if (v14)
  {
    uint64_t v17 = (void *)static Array._allocateBufferUninitialized(minimumCapacity:)(2 * v14, &type metadata for UInt8);
    void v17[2] = v15;
    bzero(v17 + 4, v15);
  }

  else
  {
    uint64_t v17 = _swiftEmptyArrayStorage;
  }

  uint64_t v26 = 0LL;
  size_t v27 = v17;
  uint64_t v18 = Array<A>.regions.getter(v16);
  sub_2127F4(v16, (uint64_t *)&v27, &v26);
  swift_bridgeObjectRelease(v18);
  uint64_t v19 = (uint64_t)v27;
  uint64_t v20 = v27[2];
  swift_bridgeObjectRetain(v27);
  uint64_t v21 = static String._fromUTF8Repairing(_:)(v19 + 32, v20);
  uint64_t v23 = v22;
  swift_bridgeObjectRelease(v16);
  swift_bridgeObjectRelease_n(v19, 2LL);
  v24._countAndFlagsBits = v21;
  v24._object = v23;
  String.append(_:)(v24);
  swift_bridgeObjectRelease(v23);
  return v28;
}

uint64_t sub_211E74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, v7, v8, &unk_33EC10, &unk_33EC20);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v8,  AssociatedTypeWitness,  &unk_33EC10,  &unk_33EC18);
  return dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( a1,  a2,  a4,  AssociatedTypeWitness,  *(void *)(AssociatedConformanceWitness + 8));
}

uint64_t sub_211F28(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, v3, v4, &unk_33EC10, &unk_33EC20);
  uint64_t v6 = *(void *)(swift_getAssociatedConformanceWitness(v3, v4, AssociatedTypeWitness, &unk_33EC10, &unk_33EC18) + 24);
  return dispatch thunk of Hashable.hash(into:)(a1, AssociatedTypeWitness, v6);
}

Swift::Int sub_211FA8(uint64_t a1)
{
  return Hasher._finalize()();
}

Swift::Int sub_211FF4(uint64_t a1, uint64_t a2)
{
  return Hasher._finalize()();
}

uint64_t sub_212034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_211E74(a1, a2, a4, a3);
}

uint64_t sub_212058@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&unk_2806C8, a1);
  uint64_t v6 = sub_237720(a1, WitnessTable);
  uint64_t v8 = v7;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v2, a1);
  *a2 = v6;
  a2[1] = v8;
  return result;
}

uint64_t sub_2120C4()
{
  return 0LL;
}

uint64_t sub_2120CC()
{
  return 2LL;
}

uint64_t sub_2120D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = j___ss30_copySequenceToContiguousArrayys0dE0Vy7ElementQzGxSTRzlF(v2, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v2, a1);
  return v4;
}

uint64_t sub_212128(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Sequence.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a4, a3);
}

uint64_t sub_212148(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&unk_2806C8, a3);
  return sub_237784(a1, a2, a3, WitnessTable);
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState( 255LL,  (char *)a1 + (int)result,  -(result >> 32),  0LL,  0LL);
    *a1 = result;
  }

  return result;
}

uint64_t type metadata accessor for HMAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for HMAC);
}

char *sub_2121E4(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
    Swift::String v11 = (char *)swift_allocObject(v10, v9 + 32, 7LL);
    size_t v12 = _swift_stdlib_malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * v12 - 64;
  }

  else
  {
    Swift::String v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[v8]) {
      memmove(v13, v14, v8);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    memcpy(v13, v14, v8);
  }

  swift_bridgeObjectRelease(a4);
  return v11;
}

unint64_t sub_2122CC()
{
  unint64_t result = qword_3A8078;
  if (!qword_3A8078)
  {
    unint64_t result = swift_getWitnessTable(&unk_280E60, &type metadata for SymmetricKey);
    atomic_store(result, (unint64_t *)&qword_3A8078);
  }

  return result;
}

uint64_t sub_212310(uint64_t a1)
{
  return sub_211A60(a1, v1[6], v1[2], v1[3], v1[4], v1[5]);
}

uint64_t sub_212330(uint64_t a1, uint64_t a2)
{
  return sub_211B88(a1, a2, v2[4], v2[2], v2[3]);
}

char *sub_21234C(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_212364(a1, a2, a3, a4, &qword_3A81C8);
}

char *sub_212358(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_212364(a1, a2, a3, a4, &qword_3A81D0);
}

char *sub_212364(char *result, int64_t a2, char a3, char *a4, uint64_t *a5)
{
  char v6 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v7 = *((void *)a4 + 3);
    int64_t v8 = v7 >> 1;
    if ((uint64_t)(v7 >> 1) < a2)
    {
      if (v8 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v8 = a2;
  }

  uint64_t v9 = *((void *)a4 + 2);
  if (v8 <= v9) {
    uint64_t v10 = *((void *)a4 + 2);
  }
  else {
    uint64_t v10 = v8;
  }
  if (v10)
  {
    uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(a5);
    size_t v12 = (char *)swift_allocObject(v11, 8 * v10 + 32, 7LL);
    int64_t v13 = _swift_stdlib_malloc_size(v12);
    uint64_t v14 = v13 - 32;
    if (v13 < 32) {
      uint64_t v14 = v13 - 25;
    }
    *((void *)v12 + 2) = v9;
    *((void *)v12 + 3) = 2 * (v14 >> 3);
  }

  else
  {
    size_t v12 = (char *)_swiftEmptyArrayStorage;
  }

  size_t v15 = v12 + 32;
  uint64_t v16 = a4 + 32;
  if ((v6 & 1) != 0)
  {
    if (v12 != a4 || v15 >= &v16[8 * v9]) {
      memmove(v15, v16, 8 * v9);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    memcpy(v15, v16, 8 * v9);
  }

  swift_bridgeObjectRelease(a4);
  return v12;
}

char *sub_212458(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81D8);
    uint64_t v11 = (char *)swift_allocObject(v10, 32 * v9 + 32, 7LL);
    int64_t v12 = _swift_stdlib_malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 1;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 5);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  size_t v15 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[32 * v8]) {
      memmove(v14, v15, 32 * v8);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    swift_arrayInitWithCopy(v14, v15, v8, &type metadata for Substring);
  }

  swift_bridgeObjectRelease(a4);
  return v11;
}

char *sub_212558(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81E0);
    uint64_t v11 = (char *)swift_allocObject(v10, 48 * v9 + 32, 7LL);
    size_t v12 = _swift_stdlib_malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * ((uint64_t)(v12 - 32) / 48);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[48 * v8]) {
      memmove(v13, v14, 48 * v8);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    swift_arrayInitWithCopy(v13, v14, v8, &type metadata for ASN1.ASN1ParserNode);
  }

  swift_bridgeObjectRelease(a4);
  return v11;
}

char *sub_212670(char *a1, int64_t a2, char a3)
{
  unint64_t result = sub_21268C(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

char *sub_21268C(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
    uint64_t v11 = (char *)swift_allocObject(v10, v9 + 32, 7LL);
    size_t v12 = _swift_stdlib_malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * v12 - 64;
  }

  else
  {
    uint64_t v11 = (char *)&_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[v8]) {
      memmove(v13, v14, v8);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    memcpy(v13, v14, v8);
  }

  swift_release(a4);
  return v11;
}

uint64_t sub_212778(uint64_t a1, uint64_t a2)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, a2, a1, &unk_33EC10, &unk_33EC20);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &unk_33EC10,  &unk_33EC18);
  return (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 40))( AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t sub_2127F4(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v16 = *(void *)(result + 16);
  if (v16)
  {
    uint64_t v5 = result;
    unint64_t result = swift_bridgeObjectRetain(result);
    uint64_t v6 = 0LL;
    uint64_t v7 = *a3;
    while (v7 + 0x4000000000000000LL >= 0)
    {
      unsigned int v8 = *(unsigned __int8 *)(v5 + v6 + 32);
      if (v8 <= 0x9F) {
        char v9 = (*(_BYTE *)(v5 + v6 + 32) >> 4) | 0x30;
      }
      else {
        char v9 = (*(_BYTE *)(v5 + v6 + 32) >> 4) + 87;
      }
      uint64_t v10 = *a2;
      unint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
      *a2 = v10;
      if ((result & 1) != 0)
      {
        unint64_t v11 = 2 * v7;
        if (2 * v7 < 0) {
          goto LABEL_19;
        }
      }

      else
      {
        unint64_t result = (uint64_t)sub_237300(v10);
        uint64_t v10 = result;
        unint64_t v11 = 2 * v7;
        if (2 * v7 < 0)
        {
LABEL_19:
          __break(1u);
          return swift_bridgeObjectRelease(v5);
        }
      }

      unint64_t v12 = *(void *)(v10 + 16);
      if (v11 >= v12) {
        goto LABEL_23;
      }
      *(_BYTE *)(v10 + 32 + v11) = v9;
      uint64_t v13 = *a3;
      if (*a3 + 0x4000000000000000LL < 0) {
        goto LABEL_24;
      }
      if (v13 < 0) {
        goto LABEL_25;
      }
      uint64_t v14 = (2 * v13) | 1;
      ++v6;
      if ((v8 & 0xF) <= 9) {
        char v15 = v8 & 0xF | 0x30;
      }
      else {
        char v15 = (v8 & 0xF) + 87;
      }
      *(_BYTE *)(v10 + 32 + v14) = v15;
      *a2 = v10;
      uint64_t v7 = v13 + 1;
      *a3 = v13 + 1;
      if (v16 == v6) {
        return swift_bridgeObjectRelease(v5);
      }
    }

    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
  }

  return result;
}

uint64_t sub_212940(uint64_t a1)
{
  return swift_getWitnessTable(&unk_2806C8, a1);
}

uint64_t sub_212950(void *a1, uint64_t a2)
{
  a1[1] = swift_getWitnessTable(&unk_280724, a2);
  a1[2] = swift_getWitnessTable(&unk_28074C, a2);
  a1[3] = swift_getWitnessTable(&unk_2806E4, a2);
  uint64_t result = swift_getWitnessTable(&unk_280774, a2);
  a1[4] = result;
  return result;
}

uint64_t sub_2129BC(uint64_t a1)
{
  return swift_getWitnessTable(&unk_2807DC, a1);
}

uint64_t sub_2129CC()
{
  return sub_2129F8( (unint64_t *)&qword_3A80B8,  qword_3A80C0,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t sub_2129F8(unint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    uint64_t result = swift_getWitnessTable(a3, v6);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t sub_212A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 24LL);
}

uint64_t sub_212A40(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319LL, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(void *)(result - 8) + 64LL;
    v4[1] = v4[0];
    swift_initStructMetadata(a1, 0LL, 2LL, v4, a1 + 32);
    return 0LL;
  }

  return result;
}

uint64_t *sub_212AAC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = *(_DWORD *)(v6 + 80);
  uint64_t v9 = ~v8;
  uint64_t v10 = v7 + v8;
  unint64_t v11 = ((v7 + v8) & ~v8) + v7;
  if (v8 > 7 || (*(_DWORD *)(v6 + 80) & 0x100000) != 0 || v11 > 0x18)
  {
    uint64_t v14 = *a2;
    *uint64_t v4 = *a2;
    uint64_t v4 = (uint64_t *)(v14 + ((v8 + 16) & v9));
    swift_retain(v14);
  }

  else
  {
    char v15 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v6 + 16);
    v15(a1, a2, *(void *)(a3 + 16));
    v15((uint64_t *)(((unint64_t)v4 + v10) & v9), (uint64_t *)(((unint64_t)a2 + v10) & v9), v5);
  }

  return v4;
}

uint64_t sub_212B60(unint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v6 = *(uint64_t (**)(unint64_t, uint64_t))(v4 + 8);
  v6(a1, v3);
  return v6( (*(void *)(v4 + 64) + a1 + *(unsigned __int8 *)(v4 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  v3);
}

unint64_t sub_212BC8(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 16);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

unint64_t sub_212C34(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 24);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

unint64_t sub_212CA0(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 32);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

unint64_t sub_212D0C(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 40);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

uint64_t sub_212D78(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_18;
  }
  char v8 = 8 * v7;
  if (v7 <= 3)
  {
    unsigned int v10 = ((v6 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      int v9 = *(_DWORD *)(a1 + v7);
      if (!v9) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v10 > 0xFF)
    {
      int v9 = *(unsigned __int16 *)(a1 + v7);
      if (!*(_WORD *)(a1 + v7)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v10 < 2)
    {
LABEL_18:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0LL;
    }
  }

  int v9 = *(unsigned __int8 *)(a1 + v7);
  if (!*(_BYTE *)(a1 + v7)) {
    goto LABEL_18;
  }
LABEL_11:
  int v11 = (v9 - 1) << v8;
  if (!(_DWORD)v7) {
    return v5 + v11 + 1;
  }
  return ((uint64_t (*)(void))((char *)&loc_212E38 + 4 * byte_280690[(v7 - 1)]))();
}

void sub_212E88(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  BOOL v9 = a3 >= v7;
  unsigned int v10 = a3 - v7;
  if (v10 != 0 && v9)
  {
    if (v8 <= 3)
    {
      unsigned int v13 = ((v10 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v13))
      {
        unsigned int v11 = &dword_4;
      }

      else if (v13 >= 0x100)
      {
        unsigned int v11 = 2;
      }

      else
      {
        unsigned int v11 = v13 > 1;
      }
    }

    else
    {
      unsigned int v11 = &dword_0 + 1;
    }
  }

  else
  {
    unsigned int v11 = 0;
  }

  if (v7 < a2)
  {
    unsigned int v12 = ~v7 + a2;
    if (v8 < 4)
    {
      if ((_DWORD)v8)
      {
        int v14 = v12 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if ((_DWORD)v8 == 3)
        {
          *a1 = v14;
          *((_BYTE *)a1 + 2) = BYTE2(v14);
        }

        else if ((_DWORD)v8 == 2)
        {
          *a1 = v14;
        }

        else
        {
          *(_BYTE *)a1 = v14;
        }
      }
    }

    else
    {
      bzero(a1, v8);
      *(_DWORD *)a1 = v12;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

uint64_t sub_213048(uint64_t a1)
{
  uint64_t result = swift_getAssociatedTypeWitness(319LL, *(void *)(a1 + 24), *(void *)(a1 + 16), &unk_33EC10, &unk_33EC20);
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0LL, 1LL, &v4, a1 + 32);
    return 0LL;
  }

  return result;
}

uint64_t *sub_2130C4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a3 + 24),  *(void *)(a3 + 16),  &unk_33EC10,  &unk_33EC20);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  if (v7 <= 7 && *(void *)(v6 + 64) <= 0x18uLL && (*(_DWORD *)(v6 + 80) & 0x100000) == 0)
  {
    (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v6 + 16))(a1, a2, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v10 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v10 + ((v7 + 16) & ~v7));
    swift_retain(v10);
  }

  return a1;
}

uint64_t sub_213158(uint64_t a1, uint64_t a2)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a2 + 24),  *(void *)(a2 + 16),  &unk_33EC10,  &unk_33EC20);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( a1,  AssociatedTypeWitness);
}

uint64_t sub_2131A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a3 + 24),  *(void *)(a3 + 16),  &unk_33EC10,  &unk_33EC20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t sub_2131FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a3 + 24),  *(void *)(a3 + 16),  &unk_33EC10,  &unk_33EC20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 24LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t sub_213254(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a3 + 24),  *(void *)(a3 + 16),  &unk_33EC10,  &unk_33EC20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t sub_2132AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a3 + 24),  *(void *)(a3 + 16),  &unk_33EC10,  &unk_33EC20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t sub_213304(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a3 + 24),  *(void *)(a3 + 16),  &unk_33EC10,  &unk_33EC20);
  if (!a2) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  uint64_t v8 = *(void *)(v6 + 64);
  char v9 = 8 * v8;
  if (v8 <= 3)
  {
    unsigned int v11 = ((a2 - v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)(a1 + v8);
      if (!v10) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v11 > 0xFF)
    {
      int v10 = *(unsigned __int16 *)(a1 + v8);
      if (!*(_WORD *)(a1 + v8)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v11 < 2)
    {
LABEL_18:
      if ((_DWORD)v7) {
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(a1, v7, AssociatedTypeWitness);
      }
      return 0LL;
    }
  }

  int v10 = *(unsigned __int8 *)(a1 + v8);
  if (!*(_BYTE *)(a1 + v8)) {
    goto LABEL_18;
  }
LABEL_11:
  int v12 = (v10 - 1) << v9;
  if ((_DWORD)v8)
  {
    __asm { BR              X11 }
  }

  return (v7 + v12 + 1);
}

void sub_213444(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(void *)(a4 + 24),  *(void *)(a4 + 16),  &unk_33EC10,  &unk_33EC20)
                 - 8);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  size_t v9 = *(void *)(v7 + 64);
  if (a3 <= v8)
  {
    unsigned int v10 = 0;
  }

  else if (v9 <= 3)
  {
    unsigned int v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
    if (HIWORD(v12))
    {
      unsigned int v10 = &dword_4;
    }

    else if (v12 >= 0x100)
    {
      unsigned int v10 = 2;
    }

    else
    {
      unsigned int v10 = v12 > 1;
    }
  }

  else
  {
    unsigned int v10 = &dword_0 + 1;
  }

  if (v8 < a2)
  {
    unsigned int v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if ((_DWORD)v9)
      {
        int v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *(_WORD *)a1 = v13;
          a1[2] = BYTE2(v13);
        }

        else if ((_DWORD)v9 == 2)
        {
          *(_WORD *)a1 = v13;
        }

        else
        {
          *a1 = v13;
        }
      }
    }

    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

uint64_t sub_21361C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = (void *)(a1 + 16);
  swift_retain(a1);
  uint64_t result = swift_beginAccess(v6, v20, 0LL, 0LL);
  uint64_t v21 = a1;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = 32LL;
  while (1)
  {
    if (v9 - 32 == v8) {
      return swift_release(v21);
    }
    uint64_t v10 = v9 - 31;
    if (__OFADD__(v9 - 32, 1LL)) {
      break;
    }
    uint64_t v11 = *a3;
    if (*a3 + 0x4000000000000000LL < 0) {
      goto LABEL_24;
    }
    unsigned int v12 = *(unsigned __int8 *)(v21 + v9);
    if (v12 <= 0x9F) {
      char v13 = (*(_BYTE *)(v21 + v9) >> 4) | 0x30;
    }
    else {
      char v13 = (*(_BYTE *)(v21 + v9) >> 4) + 87;
    }
    uint64_t v14 = *a2;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
    *a2 = v14;
    if ((result & 1) != 0)
    {
      unint64_t v15 = 2 * v11;
      if (2 * v11 < 0) {
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t result = (uint64_t)sub_237300(v14);
      uint64_t v14 = result;
      unint64_t v15 = 2 * v11;
      if (2 * v11 < 0)
      {
LABEL_21:
        __break(1u);
        return swift_release(v21);
      }
    }

    unint64_t v16 = *(void *)(v14 + 16);
    if (v15 >= v16) {
      goto LABEL_25;
    }
    *(_BYTE *)(v14 + 32 + v15) = v13;
    uint64_t v17 = *a3;
    if (*a3 + 0x4000000000000000LL < 0) {
      goto LABEL_26;
    }
    if (v17 < 0) {
      goto LABEL_27;
    }
    uint64_t v18 = (2 * v17) | 1;
    if ((v12 & 0xF) <= 9) {
      char v19 = v12 & 0xF | 0x30;
    }
    else {
      char v19 = (v12 & 0xF) + 87;
    }
    *(_BYTE *)(v14 + 32 + v1_Block_object_dispose((const void *)(v11 - 96), 8) = v19;
    *a2 = v14;
    *a3 = v17 + 1;
    uint64_t v8 = *v6;
    ++v9;
    if (__OFSUB__(*v6, v10)) {
      goto LABEL_28;
    }
  }

  __break(1u);
LABEL_24:
  __break(1u);
LABEL_25:
  __break(1u);
LABEL_26:
  __break(1u);
LABEL_27:
  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

uint64_t sub_2137A4(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5, uint64_t *a6)
{
  unint64_t v6 = (a4 >> 1) - a3;
  if (a4 >> 1 != a3)
  {
    if ((uint64_t)(a4 >> 1) > a3)
    {
      uint64_t v24 = result;
      uint64_t result = swift_unknownObjectRetain(result);
      uint64_t v11 = *a6;
      unsigned int v12 = (unsigned __int8 *)(a2 + a3);
      while (v11 + 0x4000000000000000LL >= 0)
      {
        unsigned int v14 = *v12++;
        char v13 = v14;
        int v15 = (v14 >> 4) + 87;
        int v16 = (v14 >> 4) | 0x30;
        if (v14 <= 0x9F) {
          char v17 = v16;
        }
        else {
          char v17 = v15;
        }
        uint64_t v18 = *a5;
        uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a5);
        *a5 = v18;
        if ((result & 1) != 0)
        {
          unint64_t v19 = 2 * v11;
          if (2 * v11 < 0) {
            goto LABEL_20;
          }
        }

        else
        {
          uint64_t result = (uint64_t)sub_237300(v18);
          uint64_t v18 = result;
          unint64_t v19 = 2 * v11;
          if (2 * v11 < 0)
          {
LABEL_20:
            __break(1u);
            return swift_unknownObjectRelease(v24);
          }
        }

        unint64_t v20 = *(void *)(v18 + 16);
        if (v19 >= v20) {
          goto LABEL_24;
        }
        *(_BYTE *)(v18 + 32 + v19) = v17;
        uint64_t v21 = *a6;
        if (*a6 + 0x4000000000000000LL < 0) {
          goto LABEL_25;
        }
        if (v21 < 0) {
          goto LABEL_26;
        }
        uint64_t v22 = (2 * v21) | 1;
        if ((v13 & 0xFu) <= 9) {
          char v23 = v13 & 0xF | 0x30;
        }
        else {
          char v23 = (v13 & 0xF) + 87;
        }
        *(_BYTE *)(v18 + 32 + v22) = v23;
        *a5 = v18;
        uint64_t v11 = v21 + 1;
        *a6 = v21 + 1;
        if (!--v6) {
          return swift_unknownObjectRelease(v24);
        }
      }

      __break(1u);
LABEL_24:
      __break(1u);
LABEL_25:
      __break(1u);
LABEL_26:
      __break(1u);
    }

    __break(1u);
  }

  return result;
}

uint64_t sub_2138F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for HMAC(0LL, *(void *)(v4 + 16), *(void *)(v4 + 32), a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(v7 + 24) + 40LL))( a1,  a2,  *(void *)(v7 + 16));
}

uint64_t sub_213958@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  return sub_211300(a1, a2, *(char ***)(v3 + 16), a3);
}

uint64_t __swift_instantiateGenericMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6[0] = a2;
  v6[1] = a3;
  void v6[2] = a4;
  return swift_getGenericMetadata(a1, v6, a5);
}

uint64_t sub_21399C(uint64_t a1, unint64_t a2)
{
  *(void *)&__int128 v19 = a1;
  *((void *)&v19 + 1) = a2;
  swift_bridgeObjectRetain(a2);
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81E8);
  if (!swift_dynamicCast(v17, &v19, &type metadata for String.UTF8View, v2, 6LL))
  {
    uint64_t v18 = 0LL;
    memset(v17, 0, sizeof(v17));
    sub_215A50((uint64_t)v17, &qword_3A82D0);
    if ((a2 & 0x1000000000000000LL) != 0) {
      goto LABEL_20;
    }
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      v20[0] = a1;
      v20[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v7 = (char *)v20 + (HIBYTE(a2) & 0xF);
      uint64_t v8 = v20;
    }

    else
    {
      if ((a1 & 0x1000000000000000LL) != 0)
      {
        uint64_t v5 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v5 = _StringObject.sharedUTF8.getter();
      }

      if (v5) {
        uint64_t v7 = (_BYTE *)(v5 + v6);
      }
      else {
        uint64_t v7 = 0LL;
      }
      uint64_t v8 = (_BYTE *)v5;
    }

    uint64_t v9 = sub_2156CC(v8, v7);
    unint64_t v11 = v10;
    if (v10 >> 60 != 15)
    {
      swift_bridgeObjectRelease(a2);
      *(void *)&v17[0] = v9;
      *((void *)&v17[0] + 1) = v11;
      return *(void *)&v17[0];
    }

    if ((a2 & 0x1000000000000000LL) != 0)
    {
LABEL_20:
      Swift::Int v12 = String.UTF8View._foreignCount()();
    }

    else if ((a2 & 0x2000000000000000LL) != 0)
    {
      Swift::Int v12 = HIBYTE(a2) & 0xF;
    }

    else
    {
      Swift::Int v12 = a1 & 0xFFFFFFFFFFFFLL;
    }

    *(void *)&v17[0] = sub_215730(v12);
    *((void *)&v17[0] + 1) = v13;
    __chkstk_darwin(*(void *)&v17[0], v13);
    sub_220728();
    __asm { BR              X12 }
  }

  sub_1F8384(v17, (uint64_t)v20);
  uint64_t v3 = v21;
  uint64_t v4 = v22;
  __swift_project_boxed_opaque_existential_1(v20, v21);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_215350,  0LL,  &type metadata for Data._Representation,  v3,  v4);
  swift_bridgeObjectRelease(a2);
  v17[0] = v19;
  __swift_destroy_boxed_opaque_existential_1Tm(v20);
  return *(void *)&v17[0];
}

uint64_t sub_213EA0(uint64_t a1, uint64_t a2)
{
  v8[3] = &type metadata for UnsafeRawBufferPointer;
  v8[4] = &protocol witness table for UnsafeRawBufferPointer;
  v8[0] = a1;
  v8[1] = a2;
  uint64_t v2 = __swift_project_boxed_opaque_existential_1(v8, (uint64_t)&type metadata for UnsafeRawBufferPointer);
  uint64_t v3 = (_BYTE *)*v2;
  if (*v2 && (uint64_t v4 = (_BYTE *)v2[1], v5 = v4 - v3, v4 != v3))
  {
    if (v5 <= 14)
    {
      uint64_t v6 = sub_23B8E0(v3, v4);
    }

    else if ((unint64_t)v5 >= 0x7FFFFFFF)
    {
      uint64_t v6 = sub_2155D4((uint64_t)v3, (uint64_t)v4);
    }

    else
    {
      uint64_t v6 = sub_21564C((uint64_t)v3, (uint64_t)v4);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v8);
  return v6;
}

uint64_t sub_213F58(__int128 *a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82B8);
  __chkstk_darwin(v2, v3);
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82C0);
  __chkstk_darwin(v4, v5);
  __int128 v23 = *a1;
  __int128 v6 = *a1;
  __int128 v24 = a1[1];
  uint64_t v25 = *((void *)a1 + 4);
  __int128 v7 = a1[1];
  v18[0] = v6;
  v18[1] = v7;
  uint64_t v19 = *((void *)a1 + 4);
  sub_2159A4(a1);
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82C8);
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81E8);
  if (!swift_dynamicCast(v16, v18, v8, v9, 6LL))
  {
    uint64_t v17 = 0LL;
    memset(v16, 0, sizeof(v16));
    sub_215A50((uint64_t)v16, &qword_3A82D0);
    __asm { BR              X13 }
  }

  sub_1F8384(v16, (uint64_t)&v20);
  uint64_t v10 = v21;
  uint64_t v11 = v22;
  __swift_project_boxed_opaque_existential_1(&v20, v21);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_215350,  0LL,  &type metadata for Data._Representation,  v10,  v11);
  uint64_t v12 = *((void *)&v23 + 1);
  unint64_t v13 = v24;
  uint64_t v14 = v25;
  swift_bridgeObjectRelease(v23);
  sub_1F86D4(v12, v13);
  swift_release(v14);
  v18[0] = v16[0];
  __swift_destroy_boxed_opaque_existential_1Tm(&v20);
  return *(void *)&v18[0];
}

void sub_2144FC(uint64_t a1, uint64_t a2)
{
  v3[3] = &type metadata for Data;
  v3[4] = &protocol witness table for Data;
  v3[0] = a1;
  v3[1] = a2;
  uint64_t v2 = (char *)&loc_214560
     + dword_214794[__swift_project_boxed_opaque_existential_1(v3, (uint64_t)&type metadata for Data)[1] >> 62];
  __asm { BR              X10 }

uint64_t sub_214570()
{
  uint64_t v6 = v2;
  __int16 v7 = v3;
  char v8 = BYTE2(v3);
  char v9 = BYTE3(v3);
  char v10 = BYTE4(v3);
  char v11 = BYTE5(v3);
  sub_1F83C0(v1, v0);
  sub_215350(&v6, (_BYTE *)&v6 + BYTE6(v3), &v12);
  sub_1F86D4(v1, v0);
  uint64_t v4 = v12;
  __swift_destroy_boxed_opaque_existential_1Tm(&v13);
  return v4;
}

void sub_2147A4(uint64_t a1, uint64_t a2)
{
  v5[3] = &_s5NonceVN_0;
  v5[4] = sub_215914();
  v5[0] = a1;
  v5[1] = a2;
  uint64_t v4 = (char *)&loc_21480C
     + *((int *)qword_214A40 + (__swift_project_boxed_opaque_existential_1(v5, (uint64_t)&_s5NonceVN_0)[1] >> 62));
  __asm { BR              X10 }

uint64_t sub_21481C()
{
  uint64_t v6 = v2;
  __int16 v7 = v3;
  char v8 = BYTE2(v3);
  char v9 = BYTE3(v3);
  char v10 = BYTE4(v3);
  char v11 = BYTE5(v3);
  sub_1F83C0(v1, v0);
  sub_215350(&v6, (_BYTE *)&v6 + BYTE6(v3), &v12);
  sub_1F86D4(v1, v0);
  uint64_t v4 = v12;
  __swift_destroy_boxed_opaque_existential_1Tm(&v13);
  return v4;
}

uint64_t sub_214A50@<X0>(uint64_t *a1@<X8>)
{
  return sub_214EFC(ccec_cp_256, (uint64_t (*)(uint64_t, void, uint64_t))sub_23B9A0, a1);
}

uint64_t sub_214A64@<X0>(uint64_t *a1@<X8>)
{
  return sub_214FA0(ccec_cp_256, (uint64_t (*)(uint64_t, void, uint64_t))sub_23B9A0, a1);
}

uint64_t sub_214A78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *(void *)(a3 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (*v13)
  {
    unint64_t v14 = sub_215864();
    uint64_t v15 = swift_allocError(&_s6ErrorsON, v14, 0LL, 0LL);
    _BYTE *v16 = 1;
    swift_willThrow(v15);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(a1, a3);
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a1, a3);
    sub_241BB8((uint64_t)v12, a3, a4, &v19);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(a1, a3);
    if (!v5) {
      *a5 = v19;
    }
  }

  return result;
}

uint64_t sub_214B88(_BYTE *a1)
{
  if (*a1)
  {
    unint64_t v2 = sub_215864();
    uint64_t v3 = swift_allocError(&_s6ErrorsON, v2, 0LL, 0LL);
    *uint64_t v4 = 1;
    return swift_willThrow(v3);
  }

  else
  {
    uint64_t v6 = *v1;
    swift_bridgeObjectRetain(v6);
    unint64_t v7 = ccec_export_pub_size((uint64_t *)(v6 + 32));
    uint64_t v8 = static Array._allocateBufferUninitialized(minimumCapacity:)(v7, &type metadata for UInt8);
    *(void *)(v8 + 16) = v7;
    ccec_export_pub((uint64_t *)(v6 + 32), (char *)(v8 + 32));
    *(void *)(v8 + 16) = v7;
    uint64_t v9 = sub_2157CC(v8);
    swift_bridgeObjectRelease(v6);
    swift_bridgeObjectRelease(v8);
    return v9;
  }

uint64_t sub_214C5C@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  char v6 = *a2;
  return sub_214A78(a1, (uint64_t)&v6, a3, a4, a5);
}

uint64_t sub_214C84(_BYTE *a1)
{
  return sub_214B88(a1);
}

uint64_t sub_214C98@<X0>(uint64_t *a1@<X8>)
{
  return sub_214EFC(ccec_cp_384, (uint64_t (*)(uint64_t, void, uint64_t))sub_23B9BC, a1);
}

uint64_t sub_214CAC@<X0>(uint64_t *a1@<X8>)
{
  return sub_214FA0(ccec_cp_384, (uint64_t (*)(uint64_t, void, uint64_t))sub_23B9BC, a1);
}

uint64_t sub_214CC0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *(void *)(a3 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (*v13 == 1)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a1, a3);
    sub_241BFC((uint64_t)v12, a3, a4, &v19);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(a1, a3);
    if (!v5) {
      *a5 = v19;
    }
  }

  else
  {
    unint64_t v15 = sub_215864();
    uint64_t v16 = swift_allocError(&_s6ErrorsON, v15, 0LL, 0LL);
    _BYTE *v17 = 1;
    swift_willThrow(v16);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(a1, a3);
  }

  return result;
}

uint64_t sub_214DD4(_BYTE *a1)
{
  if (*a1 == 1)
  {
    uint64_t v2 = *v1;
    swift_bridgeObjectRetain(v2);
    unint64_t v3 = ccec_export_pub_size((uint64_t *)(v2 + 32));
    uint64_t v4 = static Array._allocateBufferUninitialized(minimumCapacity:)(v3, &type metadata for UInt8);
    *(void *)(v4 + 16) = v3;
    ccec_export_pub((uint64_t *)(v2 + 32), (char *)(v4 + 32));
    *(void *)(v4 + 16) = v3;
    uint64_t v5 = sub_2157CC(v4);
    swift_bridgeObjectRelease(v2);
    swift_bridgeObjectRelease(v4);
    return v5;
  }

  else
  {
    unint64_t v7 = sub_215864();
    uint64_t v8 = swift_allocError(&_s6ErrorsON, v7, 0LL, 0LL);
    *uint64_t v9 = 1;
    return swift_willThrow(v8);
  }

uint64_t sub_214EAC@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  char v6 = *a2;
  return sub_214CC0(a1, (uint64_t)&v6, a3, a4, a5);
}

uint64_t sub_214ED4(_BYTE *a1)
{
  return sub_214DD4(a1);
}

uint64_t sub_214EE8@<X0>(uint64_t *a1@<X8>)
{
  return sub_214EFC((uint64_t (*)(void))ccec_cp_521, (uint64_t (*)(uint64_t, void, uint64_t))sub_23B9D8, a1);
}

uint64_t sub_214EFC@<X0>( uint64_t (*a1)(void)@<X0>, uint64_t (*a2)(uint64_t, void, uint64_t)@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = a1();
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
    v9[0] = v6;
    swift_dynamicCast(&v8, v9, (char *)&type metadata for Any + 8, v10, 7LL);
    uint64_t v7 = getccec_full_ctx_size(v8);
    uint64_t result = a2(v7, 0LL, v7);
    *a3 = result;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t sub_214F8C@<X0>(uint64_t *a1@<X8>)
{
  return sub_214FA0((uint64_t (*)(void))ccec_cp_521, (uint64_t (*)(uint64_t, void, uint64_t))sub_23B9D8, a1);
}

uint64_t sub_214FA0@<X0>( uint64_t (*a1)(void)@<X2>, uint64_t (*a2)(uint64_t, void, uint64_t)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a1();
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
    v9[0] = v6;
    swift_dynamicCast(&v8, v9, (char *)&type metadata for Any + 8, v10, 7LL);
    uint64_t v7 = getccec_full_ctx_size(v8);
    uint64_t result = a2(v7, 0LL, v7);
    *a3 = result;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t sub_215030@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *(void *)(a3 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (*v13 == 2)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a1, a3);
    sub_241C3C((uint64_t)v12, a3, a4, &v19);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(a1, a3);
    if (!v5) {
      *a5 = v19;
    }
  }

  else
  {
    unint64_t v15 = sub_215864();
    uint64_t v16 = swift_allocError(&_s6ErrorsON, v15, 0LL, 0LL);
    _BYTE *v17 = 1;
    swift_willThrow(v16);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(a1, a3);
  }

  return result;
}

uint64_t sub_215144(_BYTE *a1)
{
  if (*a1 == 2)
  {
    uint64_t v2 = *v1;
    swift_bridgeObjectRetain(v2);
    unint64_t v3 = ccec_export_pub_size((uint64_t *)(v2 + 32));
    uint64_t v4 = static Array._allocateBufferUninitialized(minimumCapacity:)(v3, &type metadata for UInt8);
    *(void *)(v4 + 16) = v3;
    ccec_export_pub((uint64_t *)(v2 + 32), (char *)(v4 + 32));
    *(void *)(v4 + 16) = v3;
    uint64_t v5 = sub_2157CC(v4);
    swift_bridgeObjectRelease(v2);
    swift_bridgeObjectRelease(v4);
    return v5;
  }

  else
  {
    unint64_t v7 = sub_215864();
    uint64_t v8 = swift_allocError(&_s6ErrorsON, v7, 0LL, 0LL);
    *uint64_t v9 = 1;
    return swift_willThrow(v8);
  }

uint64_t sub_21521C@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  char v6 = *a2;
  return sub_215030(a1, (uint64_t)&v6, a3, a4, a5);
}

uint64_t sub_215244(_BYTE *a1)
{
  return sub_215144(a1);
}

uint64_t sub_215258(uint64_t result, uint64_t (*a2)(void *, uint64_t *))
{
  if (result < 0)
  {
    __break(1u);
    goto LABEL_16;
  }

  uint64_t v4 = result;
  if (result)
  {
    uint64_t v5 = (void *)static Array._allocateBufferUninitialized(minimumCapacity:)(result, &type metadata for UInt8);
    _OWORD v5[2] = v4;
  }

  else
  {
    uint64_t v5 = &_swiftEmptyArrayStorage;
  }

  char v6 = (char *)(v5 + 4);
  v7[1] = v4;
  uint64_t v8 = 0LL;
  v7[0] = v5 + 4;
  uint64_t result = a2(v7, &v8);
  if (v2)
  {
    if (v8 <= v4)
    {
      if (!v7[0])
      {
LABEL_20:
        __break(1u);
        goto LABEL_21;
      }

      if (v6 == (char *)v7[0])
      {
        _OWORD v5[2] = v8;
        swift_bridgeObjectRelease(v5);
        return (uint64_t)v5;
      }

      goto LABEL_17;
    }

_BYTE *sub_215350@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, void *a3@<X8>)
{
  if (!result) {
    goto LABEL_4;
  }
  uint64_t v4 = a2 - result;
  if (a2 == result)
  {
    uint64_t result = 0LL;
LABEL_4:
    unint64_t v5 = 0xC000000000000000LL;
    goto LABEL_5;
  }

  if (v4 <= 14)
  {
    uint64_t result = (_BYTE *)sub_23B8E0(result, a2);
    unint64_t v5 = v7 & 0xFFFFFFFFFFFFFFLL;
  }

  else if ((unint64_t)v4 >= 0x7FFFFFFF)
  {
    uint64_t result = (_BYTE *)sub_2155D4((uint64_t)result, (uint64_t)a2);
    unint64_t v5 = v8 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t result = (_BYTE *)sub_21564C((uint64_t)result, (uint64_t)a2);
    unint64_t v5 = v6 | 0x4000000000000000LL;
  }

void *sub_2153C4( void *(*a1)(uint64_t *__return_ptr, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t result = a1(&v6, a3, a4 - a3);
    if (v4) {
      return result;
    }
    return (void *)v6;
  }

  uint64_t result = a1(&v6, 0LL, 0LL);
  if (!v4) {
    return (void *)v6;
  }
  return result;
}

uint64_t sub_215428(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    return a1(a3, a4 - a3);
  }
  else {
    return a1(0LL, 0LL);
  }
}

uint64_t sub_215474@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v8 = *a3;
    uint64_t v7 = a3[1];
    swift_bridgeObjectRetain(v7);
    uint64_t result = _StringGuts.copyUTF8(into:)(v5, a2, v8, v7);
    if ((v9 & 1) == 0)
    {
      uint64_t v10 = result;
      uint64_t result = swift_bridgeObjectRelease(v7);
      *a4 = 0LL;
      a4[1] = 0xE000000000000000LL;
      a4[2] = 15LL;
      a4[3] = v10;
      return result;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

uint64_t sub_2154FC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  __int128 v3 = *(_OWORD *)(a3 + 3);
  __int128 v7 = *(_OWORD *)(a3 + 1);
  __int128 v8 = v3;
  _OWORD v5[2] = &v6;
  return sub_215428((uint64_t (*)(uint64_t, uint64_t))sub_215AD4, (uint64_t)v5, a1, a2);
}

void sub_215550(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  __int128 v5 = *(_OWORD *)(a2 + 16);
  v8[0] = *(_OWORD *)a2;
  v8[1] = v5;
  uint64_t v9 = *(void *)(a2 + 32);
  uint64_t v6 = *(int *)(__swift_instantiateConcreteTypeFromMangledName(&qword_3A82B8) + 48);
  sub_2159A4(v8);
  sub_2298C8(a3, a1);
  *(void *)(a3 + v6) = v7;
}

uint64_t sub_2155D4(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v3 = a2 - a1;
  }
  else {
    uint64_t v3 = 0LL;
  }
  uint64_t v4 = type metadata accessor for __DataStorage(0LL);
  swift_allocObject(v4, *(unsigned int *)(v4 + 48), *(unsigned __int16 *)(v4 + 52));
  uint64_t result = __DataStorage.init(bytes:length:)(a1, v3);
  if (v3 < 0)
  {
    __break(1u);
  }

  else
  {
    uint64_t v6 = type metadata accessor for Data.RangeReference(0LL);
    uint64_t result = swift_allocObject(v6, 32LL, 7LL);
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = v3;
  }

  return result;
}

uint64_t sub_21564C(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v3 = a2 - a1;
  }
  else {
    uint64_t v3 = 0LL;
  }
  uint64_t v4 = type metadata accessor for __DataStorage(0LL);
  swift_allocObject(v4, *(unsigned int *)(v4 + 48), *(unsigned __int16 *)(v4 + 52));
  uint64_t result = __DataStorage.init(bytes:length:)(a1, v3);
  if (v3 < (uint64_t)0xFFFFFFFF80000000LL)
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v3 > 0x7FFFFFFF)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }

  if ((v3 & 0x80000000) == 0) {
    return v3 << 32;
  }
LABEL_10:
  __break(1u);
  return result;
}

_BYTE *sub_2156CC(_BYTE *result, _BYTE *a2)
{
  if (result)
  {
    uint64_t v2 = a2 - result;
    if (a2 == result)
    {
      return 0LL;
    }

    else if (v2 <= 14)
    {
      return (_BYTE *)sub_23B8E0(result, a2);
    }

    else if ((unint64_t)v2 >= 0x7FFFFFFF)
    {
      return (_BYTE *)sub_2155D4((uint64_t)result, (uint64_t)a2);
    }

    else
    {
      return (_BYTE *)sub_21564C((uint64_t)result, (uint64_t)a2);
    }
  }

  return result;
}

uint64_t sub_215730(uint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (result <= 14)
    {
      if (result < 0) {
        __break(1u);
      }
      else {
        return 0LL;
      }
    }

    else
    {
      uint64_t v2 = type metadata accessor for __DataStorage(0LL);
      swift_allocObject(v2, *(unsigned int *)(v2 + 48), *(unsigned __int16 *)(v2 + 52));
      __DataStorage.init(length:)(v1);
      if (v1 >= 0x7FFFFFFF)
      {
        uint64_t v3 = type metadata accessor for Data.RangeReference(0LL);
        uint64_t result = swift_allocObject(v3, 32LL, 7LL);
        *(void *)(result + 16) = 0LL;
        *(void *)(result + 24) = v1;
      }

      else
      {
        return v1 << 32;
      }
    }
  }

  return result;
}

uint64_t sub_2157CC(uint64_t a1)
{
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  unint64_t v10 = sub_215958();
  v8[0] = a1;
  uint64_t v2 = __swift_project_boxed_opaque_existential_1(v8, v9);
  uint64_t v3 = (_BYTE *)(*v2 + 32LL);
  uint64_t v4 = &v3[*(void *)(*v2 + 16LL)];
  swift_bridgeObjectRetain(a1);
  sub_215350(v3, v4, &v7);
  uint64_t v5 = v7;
  __swift_destroy_boxed_opaque_existential_1Tm(v8);
  return v5;
}

unint64_t sub_215864()
{
  unint64_t result = qword_3A8200;
  if (!qword_3A8200)
  {
    unint64_t result = swift_getWitnessTable(&unk_2818EC, &_s6ErrorsON);
    atomic_store(result, (unint64_t *)&qword_3A8200);
  }

  return result;
}

unint64_t ccec_export_pub_size(uint64_t *a1)
{
  return ((unint64_t)(cczp_bitlen(*a1) + 7) >> 2) | 1;
}

_UNKNOWN **sub_2158CC()
{
  return &off_3A8220;
}

_UNKNOWN **sub_2158D8()
{
  return &off_3524A0;
}

_UNKNOWN **sub_2158E4()
{
  return &off_3A8258;
}

_UNKNOWN **sub_2158F0()
{
  return &off_3524D0;
}

_UNKNOWN **sub_2158FC()
{
  return &off_3A8290;
}

_UNKNOWN **sub_215908()
{
  return &off_352500;
}

unint64_t sub_215914()
{
  unint64_t result = qword_3A82B0;
  if (!qword_3A82B0)
  {
    unint64_t result = swift_getWitnessTable(&unk_282560, &_s5NonceVN_0);
    atomic_store(result, (unint64_t *)&qword_3A82B0);
  }

  return result;
}

unint64_t sub_215958()
{
  unint64_t result = qword_3A8068;
  if (!qword_3A8068)
  {
    uint64_t v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_3A8060);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v1);
    atomic_store(result, (unint64_t *)&qword_3A8068);
  }

  return result;
}

void *sub_2159A4(void *a1)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = a1[2];
  uint64_t v4 = a1[4];
  swift_bridgeObjectRetain(*a1);
  sub_1F83C0(v2, v3);
  swift_retain(v4);
  return a1;
}

uint64_t sub_2159F0(uint64_t a1, uint64_t a2)
{
  return sub_2154FC(a1, a2, *(uint64_t **)(v2 + 16));
}

uint64_t sub_215A08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82C0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_215A50(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8LL))(a1, v3);
  return a1;
}

unint64_t sub_215A8C()
{
  unint64_t result = qword_3A82E0;
  if (!qword_3A82E0)
  {
    uint64_t v1 = type metadata accessor for Data.Iterator(255LL);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Data.Iterator, v1);
    atomic_store(result, (unint64_t *)&qword_3A82E0);
  }

  return result;
}

void sub_215AD4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void *sub_215AF0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(uint64_t **)(v3 + 16);
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  v13[0] = v7;
  v13[1] = v6;
  v12[2] = v13;
  unint64_t result = sub_2153C4((void *(*)(uint64_t *__return_ptr, uint64_t, uint64_t))sub_215B60, (uint64_t)v12, a1, a2);
  *a3 = result;
  a3[1] = v9;
  a3[2] = v10;
  a3[3] = v11;
  return result;
}

uint64_t sub_215B4C(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_1F86D4(a1, a2);
  }
  return a1;
}

uint64_t sub_215B60@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return sub_215474(a1, a2, *(uint64_t **)(v3 + 16), a3);
}

uint64_t sub_215B7C@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = *v1;
  *a1 = *v1;
  return swift_retain(v2);
}

uint64_t sub_215B88()
{
  uint64_t v1 = *(void *)(v0 + 8);
  sub_1F83C0(v1, *(void *)(v0 + 16));
  return v1;
}

void *sub_215BB8@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = *result;
  a4[1] = a2;
  a4[2] = a3;
  return result;
}

ValueMetadata *type metadata accessor for KEM()
{
  return &type metadata for KEM;
}

uint64_t destroy for KEM.EncapsulationResult(void *a1)
{
  return sub_1F86D4(a1[1], a1[2]);
}

uint64_t *_s16CryptoKit_Static3KEMO19EncapsulationResultVwCP_0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  unint64_t v5 = a2[2];
  swift_retain(v3);
  sub_1F83C0(v4, v5);
  a1[1] = v4;
  a1[2] = v5;
  return a1;
}

uint64_t *assignWithCopy for KEM.EncapsulationResult(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_retain(v4);
  swift_release(v5);
  uint64_t v7 = a2[1];
  unint64_t v6 = a2[2];
  sub_1F83C0(v7, v6);
  uint64_t v8 = a1[1];
  unint64_t v9 = a1[2];
  a1[1] = v7;
  a1[2] = v6;
  sub_1F86D4(v8, v9);
  return a1;
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

void *assignWithTake for KEM.EncapsulationResult(void *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  *a1 = *(void *)a2;
  swift_release(v4);
  uint64_t v5 = a1[1];
  unint64_t v6 = a1[2];
  *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 8);
  sub_1F86D4(v5, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for KEM.EncapsulationResult(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 24)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for KEM.EncapsulationResult(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 24) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for KEM.EncapsulationResult()
{
  return &type metadata for KEM.EncapsulationResult;
}

uint64_t sub_215D9C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t sub_215DB4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t sub_215DCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t sub_215DE4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t sub_215DEC@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v24 = a8;
  uint64_t v22 = a5;
  uint64_t v23 = a7;
  uint64_t v15 = type metadata accessor for Optional(0LL, a6);
  uint64_t v16 = *(void *)(v15 - 8);
  __chkstk_darwin(v15, v17);
  uint64_t v19 = (char *)&v22 - v18;
  uint64_t v26 = *a2;
  __int128 v25 = *a3;
  uint64_t v20 = *(void *)(a6 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))((char *)&v22 - v18, a4, a6);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v20 + 56))(v19, 0LL, 1LL, a6);
  sub_219B74(&v26, a1, (uint64_t *)&v25, (uint64_t)v19, v22, a6, v23, v24, a9);
  return (*(uint64_t (**)(char *, uint64_t))(v16 + 8))(v19, v15);
}

uint64_t sub_215F00@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v15 = *a2;
  __int128 v10 = *a3;
  __int128 v13 = xmmword_280980;
  __int128 v14 = v10;
  unint64_t v11 = sub_1F8404();
  return sub_219B74(&v15, a1, (uint64_t *)&v14, (uint64_t)&v13, a4, (uint64_t)&type metadata for Data, a5, v11, a6);
}

uint64_t sub_215F90(__int128 *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for Optional(0LL, a4);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10, v12);
  __int128 v14 = (char *)&v20 - v13;
  uint64_t v15 = *((void *)a1 + 2);
  uint64_t v22 = *a2;
  __int128 v20 = *a1;
  uint64_t v21 = v15;
  uint64_t v16 = *(void *)(a4 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))(v14, a3, a4);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v16 + 56))(v14, 0LL, 1LL, a4);
  sub_219F88(&v22, (uint64_t *)&v20, (uint64_t)v14, a4, a5);
  uint64_t v18 = v17;
  (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
  return v18;
}

void sub_2160AC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  __asm { BR              X10 }

uint64_t sub_21613C( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__src, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, __int128 a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27)
{
  if (BYTE6(v33) < 0xCuLL)
  {
LABEL_14:
    unint64_t v52 = sub_21719C();
    uint64_t v53 = swift_allocError(&type metadata for CryptoKitError, v52, 0LL, 0LL);
    *(_DWORD *)uint64_t v54 = 1;
    *(_BYTE *)(v54 + 4) = 1;
    swift_willThrow(v53);
    sub_1F86D4(v31, v33);
    swift_unexpectedError(v53, "CryptoKit_Static/AES-GCM.swift", 30LL, 1LL, 138LL);
    __break(1u);
    JUMPOUT(0x2165BCLL);
  }

  uint64_t v61 = v32;
  uint64_t v36 = v35;
  sub_2144FC(v31, v33);
  unint64_t v33 = v37;
  uint64_t v39 = v38;
  sub_1F86D4(v29, v27);
  uint64_t v40 = ccaes_gcm_decrypt_mode();
  if (!v40)
  {
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v41 = (uint64_t)v40;
  v59[0] = v28;
  *(void *)&__int128 v60 = v33;
  *((void *)&v60 + 1) = v39;
  uint64_t v42 = type metadata accessor for CoreCryptoGCMImpl.Context();
  swift_allocObject(v42, 32LL, 7LL);
  uint64_t result = sub_21A6D8(v59, (uint64_t *)&v60, v41);
  if (!v30)
  {
    uint64_t v44 = result;
    if (v34 >> 60 == 15)
    {
      uint64_t v45 = v61;
    }

    else
    {
      uint64_t v46 = v36;
      sub_1F83C0(v36, v34);
      if ((swift_isUniquelyReferenced_nonNull_native(v44) & 1) == 0)
      {
        uint64_t v47 = swift_allocObject(v42, 32LL, 7LL);
        uint64_t v48 = *(void *)(v44 + 24);
        uint64_t v56 = v47;
        *(void *)(v47 + 24) = v48;
        swift_retain(v44);
        uint64_t GCMCtxSize = getGCMCtxSize(v48);
        uint64_t v50 = (void *)swift_slowAlloc(GCMCtxSize, -1LL);
        __int128 v55 = *(const void **)(v44 + 16);
        size_t v51 = getGCMCtxSize(v48);
        if ((v51 & 0x8000000000000000LL) != 0)
        {
          __break(1u);
          JUMPOUT(0x216554LL);
        }

        memmove(v50, v55, v51);
        swift_release(v44);
        *(void *)(v56 + 16) = v50;
        swift_release(v44);
        uint64_t v46 = v36;
      }

      sub_217C28(v46, v34);
      sub_215B4C(v46, v34);
      uint64_t v45 = v61;
    }

    __int128 v60 = xmmword_280350;
    sub_1F83C0(v29, v27);
    sub_216838(v45, v29, v27);
    sub_216AC4(16LL, v57, v58);
    __asm { BR              X10 }
  }

  return result;
}

void sub_2165DC(uint64_t a1, uint64_t *a2)
{
}

uint64_t sub_216608()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_1F83C0(v1, v2);
  sub_216650(16LL, v1, v2);
  return v4;
}

void sub_216650(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x21679CLL);
}

uint64_t sub_2167D0()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  uint64_t v3 = v0[2];
  sub_1F83C0(v1, v2);
  sub_216838(v3, v1, v2);
  sub_216AC4(16LL, v5, v6);
  return v7;
}

void sub_216838(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x216994LL);
}

uint64_t sub_2169C8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result < 0)
  {
    __break(1u);
LABEL_13:
    __break(1u);
    return result;
  }

  uint64_t v5 = a3 - a2;
  if (a2) {
    uint64_t v6 = a3 - a2;
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t result = sub_2184E0(0LL, result, v6, a2, a3);
  if ((v7 & 1) != 0)
  {
    uint64_t result = v5;
    if (!a2) {
      return 0LL;
    }
  }

  else if (!a2)
  {
    uint64_t v5 = 0LL;
  }

  if (v5 < result) {
    goto LABEL_13;
  }
  return result;
}

uint64_t sub_216A54(uint64_t result, uint64_t a2, uint64_t a3, int64_t a4, unint64_t a5)
{
  if (result < 0)
  {
    __break(1u);
    goto LABEL_12;
  }

  int64_t v5 = a5 >> 1;
  uint64_t v6 = (a5 >> 1) - a4;
  if (__OFSUB__(a5 >> 1, a4))
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }

  if (result)
  {
    if ((v6 & 0x8000000000000000LL) == 0)
    {
      int64_t v7 = a5 >> 1;
      if (v6 < result)
      {
LABEL_8:
        if (v7 >= a4)
        {
          if (v5 >= a4) {
            return a2;
          }
          goto LABEL_15;
        }

void sub_216AC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x216C14LL);
}

void sub_216C44()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  uint64_t v3 = v0[2];
  sub_1F83C0(v1, v2);
  sub_216CCC(v3, v1, v2);
  sub_216F34(v4, v5);
}

void sub_216CCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x216E14LL);
}

uint64_t sub_216E48(uint64_t result, uint64_t a2, uint64_t a3, int64_t a4, unint64_t a5)
{
  if (result < 0)
  {
    __break(1u);
    goto LABEL_13;
  }

  int64_t v5 = a5 >> 1;
  uint64_t v6 = (a5 >> 1) - a4;
  if (__OFSUB__(a5 >> 1, a4))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  if (!result || v6 < 0 || (int64_t v7 = a5 >> 1, v6 >= result))
  {
    int64_t v7 = a4 + result;
    if (__OFADD__(a4, result)) {
      goto LABEL_18;
    }
  }

  if (v7 < a4) {
    goto LABEL_14;
  }
  if (v5 < a4)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }

  if (v5 >= v7)
  {
    if ((v7 & 0x8000000000000000LL) == 0) {
      return a2;
    }
    goto LABEL_17;
  }

uint64_t sub_216EC4(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result < 0)
  {
    __break(1u);
  }

  else
  {
    if (a2) {
      uint64_t v3 = a3 - a2;
    }
    else {
      uint64_t v3 = 0LL;
    }
    uint64_t result = sub_218440(0LL, result, v3, a2, a3);
    if ((v4 & 1) != 0) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = result;
    }
    if ((v5 & 0x8000000000000000LL) == 0) {
      return 0LL;
    }
  }

  __break(1u);
  return result;
}

void sub_216F34(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

void sub_216F70()
{
  if (BYTE6(v0) >= 0xCuLL)
  {
    sub_2144FC(v1, v0);
    void *v2 = v6;
    v2[1] = v7;
  }

  else
  {
    unint64_t v3 = sub_21719C();
    uint64_t v4 = swift_allocError(&type metadata for CryptoKitError, v3, 0LL, 0LL);
    *(_DWORD *)uint64_t v5 = 1;
    *(_BYTE *)(v5 + 4) = 1;
    swift_willThrow(v4);
    sub_1F86D4(v1, v0);
  }

uint64_t sub_217020()
{
  if (v0[2] != 12) {
    return 0LL;
  }
  unint64_t v2 = v0;
  uint64_t v1 = *v0;
  sub_1F83C0(v1, v2[1]);
  return v1;
}

uint64_t sub_217068@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = result;
  a3[1] = a2;
  a3[2] = 12LL;
  return result;
}

uint64_t sub_217078@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(v9 + 8) + 8LL) + 8LL);
  if (dispatch thunk of Collection.count.getter(v11, v10) >= 28)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
    uint64_t v16 = Data.init<A>(_:)(v8, a2, *(void *)(v10 + 8));
    uint64_t v18 = v17;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
    *a3 = v16;
    a3[1] = v18;
    a3[2] = 12LL;
  }

  else
  {
    unint64_t v12 = sub_21719C();
    uint64_t v13 = swift_allocError(&type metadata for CryptoKitError, v12, 0LL, 0LL);
    *(_DWORD *)uint64_t v14 = 1;
    *(_BYTE *)(v14 + 4) = 1;
    swift_willThrow(v13);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }

  return result;
}

unint64_t sub_21719C()
{
  unint64_t result = qword_3A82E8;
  if (!qword_3A82E8)
  {
    unint64_t result = swift_getWitnessTable(&unk_2804C8, &type metadata for CryptoKitError);
    atomic_store(result, (unint64_t *)&qword_3A82E8);
  }

  return result;
}

uint64_t sub_2171E0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = *a1;
  unint64_t v11 = a1[1];
  if (dispatch thunk of Collection.count.getter(a5, *(void *)(*(void *)(*(void *)(a7 + 8) + 8LL) + 8LL)) == 16) {
    __asm { BR              X10 }
  }

  sub_1F86D4(v12, v11);
  unint64_t v13 = sub_21719C();
  uint64_t v14 = swift_allocError(&type metadata for CryptoKitError, v13, 0LL, 0LL);
  *(_DWORD *)uint64_t v15 = 1;
  *(_BYTE *)(v15 + 4) = 1;
  swift_willThrow(v14);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a5 - 8) + 8LL))(a3, a5);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8LL))(a2, a4);
}

void sub_217428(uint64_t a1, uint64_t a2)
{
  v3[3] = &type metadata for Data;
  v3[4] = &protocol witness table for Data;
  v3[0] = a1;
  v3[1] = a2;
  unint64_t v2 = (char *)&loc_21748C
     + *((int *)qword_217630
       + (__swift_project_boxed_opaque_existential_1(v3, (uint64_t)&type metadata for Data)[1] >> 62));
  __asm { BR              X10 }

uint64_t sub_21749C()
{
  uint64_t v5 = v2;
  __int16 v6 = v3;
  char v7 = BYTE2(v3);
  char v8 = BYTE3(v3);
  char v9 = BYTE4(v3);
  char v10 = BYTE5(v3);
  sub_1F83C0(v1, v0);
  Data._Representation.append(contentsOf:)(&v5, (char *)&v5 + BYTE6(v3));
  return __swift_destroy_boxed_opaque_existential_1Tm(&v11);
}

uint64_t sub_217640(uint64_t a1, char a2)
{
  uint64_t v13 = a1;
  char v14 = a2;
  uint64_t v11 = a1;
  char v12 = a2;
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8378);
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81E8);
  if (!swift_dynamicCast(v15, &v11, v3, v4, 6LL))
  {
    uint64_t v16 = 0LL;
    memset(v15, 0, sizeof(v15));
    sub_218568((uint64_t)v15);
    __asm { BR              X12 }
  }

  sub_1F8384(v15, (uint64_t)&v17);
  uint64_t v5 = v18;
  uint64_t v6 = v19;
  char v7 = __swift_project_boxed_opaque_existential_1(&v17, v18);
  __chkstk_darwin(v7, v8);
  _OWORD v10[2] = v2;
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_218734, v10, (char *)&type metadata for () + 8, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(&v17);
}

unint64_t sub_2179F0()
{
  unint64_t result = qword_3A82F0;
  if (!qword_3A82F0)
  {
    unint64_t result = swift_getWitnessTable(&unk_2824F8, &_s5NonceVN);
    atomic_store(result, (unint64_t *)&qword_3A82F0);
  }

  return result;
}

unint64_t sub_217A38()
{
  unint64_t result = qword_3A82F8;
  if (!qword_3A82F8)
  {
    unint64_t result = swift_getWitnessTable(&unk_2809AC, &_s3GCMO9SealedBoxVN);
    atomic_store(result, (unint64_t *)&qword_3A82F8);
  }

  return result;
}

ValueMetadata *_s3GCMOMa()
{
  return &_s3GCMON;
}

uint64_t _s3GCMO9SealedBoxVwxx(uint64_t a1)
{
  return sub_1F86D4(*(void *)a1, *(void *)(a1 + 8));
}

uint64_t *_s3GCMO9SealedBoxVwCP_0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  sub_1F83C0(*a2, v5);
  *a1 = v4;
  a1[1] = v5;
  a1[2] = a2[2];
  return a1;
}

uint64_t *_s3GCMO9SealedBoxVwca(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  sub_1F83C0(*a2, v5);
  uint64_t v6 = *a1;
  unint64_t v7 = a1[1];
  *a1 = v4;
  a1[1] = v5;
  sub_1F86D4(v6, v7);
  a1[2] = a2[2];
  return a1;
}

uint64_t *_s3GCMO9SealedBoxVwta(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_1F86D4(v4, v5);
  a1[2] = *(void *)(a2 + 16);
  return a1;
}

uint64_t _s3GCMO9SealedBoxVwet(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xD && *(_BYTE *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 8) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 8) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t _s3GCMO9SealedBoxVwst(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)unint64_t result = a2 - 13;
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  else
  {
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 24) = 0;
    }
    if (a2)
    {
      *(void *)unint64_t result = 0LL;
      *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }

  return result;
}

ValueMetadata *_s3GCMO9SealedBoxVMa()
{
  return &_s3GCMO9SealedBoxVN;
}

void sub_217C28(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t sub_217C80()
{
  uint64_t v11 = v2;
  __int16 v12 = v0;
  char v13 = BYTE2(v0);
  char v14 = BYTE3(v0);
  char v15 = BYTE4(v0);
  char v16 = BYTE5(v0);
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  swift_retain_n(v1, 2LL);
  int v5 = ccgcm_aad(v3, v4, BYTE6(v0), (uint64_t)&v11);
  if (v5)
  {
    int v6 = v5;
    unint64_t v7 = sub_21719C();
    uint64_t v8 = swift_allocError(&type metadata for CryptoKitError, v7, 0LL, 0LL);
    *(_DWORD *)uint64_t v9 = v6;
    *(_BYTE *)(v9 + 4) = 0;
    swift_willThrow(v8);
  }

  sub_1F86D4(v2, v0);
  return swift_release_n(v1, 2LL);
}

void sub_217E94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X12 }

uint64_t sub_217EE0(uint64_t a1, unint64_t a2)
{
  return ((uint64_t (*)(void))((char *)&loc_217F18 + dword_217FDC[a2 >> 62]))();
}

void sub_217F28(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = sub_217640(BYTE6(a2), 0);
  __chkstk_darwin(v2, v3);
  sub_220C4C();
}

uint64_t sub_217FEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return sub_1F86D4(a4, a5);
}

void sub_218088(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t sub_2180E8()
{
  uint64_t v5 = v2;
  __int16 v6 = v3;
  char v7 = BYTE2(v3);
  char v8 = BYTE3(v3);
  char v9 = BYTE4(v3);
  char v10 = BYTE5(v3);
  return sub_21B074((uint64_t)&v5, (uint64_t)&v5 + BYTE6(v3), v1, v0);
}

uint64_t sub_2182E4(uint64_t a1, uint64_t a2)
{
  uint64_t result = __DataStorage._bytes.getter();
  uint64_t v5 = result;
  if (result)
  {
    uint64_t result = __DataStorage._offset.getter();
    if (__OFSUB__(a1, result))
    {
LABEL_13:
      __break(1u);
      return result;
    }

    v5 += a1 - result;
  }

  BOOL v6 = __OFSUB__(a2, a1);
  uint64_t v7 = a2 - a1;
  if (v6)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v8 = __DataStorage._length.getter();
  if (v8 >= v7) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = v8;
  }
  uint64_t v10 = v5 + v9;
  if (v5) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0LL;
  }
  return Data._Representation.append(contentsOf:)(v5, v11);
}

uint64_t sub_218374(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = __DataStorage._bytes.getter();
  uint64_t v8 = result;
  if (result)
  {
    uint64_t result = __DataStorage._offset.getter();
    if (__OFSUB__(a1, result))
    {
LABEL_13:
      __break(1u);
      goto LABEL_14;
    }

    v8 += a1 - result;
  }

  BOOL v9 = __OFSUB__(a2, a1);
  uint64_t v10 = a2 - a1;
  if (v9)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t result = __DataStorage._length.getter();
  if (!v8)
  {
LABEL_14:
    __break(1u);
    return result;
  }

  if (result >= v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = result;
  }
  int v12 = ccgcm_aad(*(void *)(a4 + 24), *(void *)(a4 + 16), v11, v8);
  if (v12)
  {
    int v13 = v12;
    unint64_t v14 = sub_21719C();
    uint64_t v15 = swift_allocError(&type metadata for CryptoKitError, v14, 0LL, 0LL);
    *(_DWORD *)uint64_t v16 = v13;
    *(_BYTE *)(v16 + 4) = 0;
    swift_willThrow(v15);
  }

  return swift_release(a4);
}

uint64_t sub_218440(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = sub_235040(a1, a3, a4, a5);
  if (a2 > 0)
  {
    return 0LL;
  }

  if (v9 <= 0 && v9 > a2) {
    return 0LL;
  }
LABEL_8:
  uint64_t result = a1 + a2;
  if (__OFADD__(a1, a2))
  {
    __break(1u);
LABEL_15:
    __break(1u);
    return result;
  }

  uint64_t v11 = a5 - a4;
  if (!a4) {
    uint64_t v11 = 0LL;
  }
  if (result < 0 || v11 < result) {
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_2184E0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5 - a4;
  if (!a4) {
    uint64_t v5 = 0LL;
  }
  if (result < 0 || v5 < result)
  {
    __break(1u);
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }

  if (a3 < 0 || v5 < a3) {
    goto LABEL_19;
  }
  uint64_t v6 = a3 - result;
  if (a2 > 0)
  {
    return 0LL;
  }

  if (v6 <= 0 && v6 > a2) {
    return 0LL;
  }
LABEL_14:
  BOOL v7 = __OFADD__(result, a2);
  result += a2;
  if (v7)
  {
LABEL_20:
    __break(1u);
LABEL_21:
    __break(1u);
    return result;
  }

  if (result < 0 || v5 < result) {
    goto LABEL_21;
  }
  return result;
}

uint64_t sub_218568(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82D0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

uint64_t sub_2185A8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = __OFADD__(a1, a2);
  uint64_t v5 = a1 + a2;
  if (v4)
  {
    __break(1u);
    JUMPOUT(0x218608LL);
  }

  return ((uint64_t (*)(uint64_t))((char *)&loc_2185C0 + dword_21860C[a4 >> 62]))(v5);
}

uint64_t sub_21861C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return ((uint64_t (*)(void))((char *)&loc_21862C + dword_2186D4[a4 >> 62]))();
}

uint64_t sub_218640@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, int a3@<W8>)
{
  if (BYTE6(a2) < a1 || a1 < 0)
  {
    __break(1u);
    JUMPOUT(0x2186CCLL);
  }

  return ((uint64_t (*)(void))((char *)&loc_21867C + dword_2186E4[a3]))();
}

uint64_t sub_2186F4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = sub_2189A4(a1, a2, *(void *)(v3 + 16), **(void **)(v3 + 32), *(_BYTE *)(*(void *)(v3 + 32) + 8LL));
  if (!v4)
  {
    *(void *)a3 = result;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v11 - 96), 8) = v7;
    *(void *)(a3 + 16) = v8;
    *(void *)(a3 + 24) = v9;
  }

  return result;
}

uint64_t sub_218734(uint64_t a1, uint64_t a2)
{
  return sub_22137C(a1, a2);
}

unint64_t sub_21874C( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a1 < 0)
  {
    __break(1u);
  }

  else
  {
    unint64_t v5 = a5;
    unint64_t v6 = a4;
    unint64_t v7 = a3;
    unint64_t v8 = a2;
    uint64_t v9 = a1;
    uint64_t v10 = (a4 >> 59) & 1;
    if ((a5 & 0x1000000000000000LL) == 0) {
      LOBYTE(v10) = 1;
    }
    unint64_t result = a3;
    if ((a3 & 0xC) != 4LL << v10)
    {
      if ((a5 & 0x1000000000000000LL) == 0) {
        goto LABEL_6;
      }
LABEL_21:
      unint64_t result = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)(result, -v9, v8, v6, v5);
      if ((v16 & 1) != 0) {
        unint64_t result = v8;
      }
      goto LABEL_17;
    }
  }

  unint64_t result = sub_22378C(v7, v6, v5);
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_21;
  }
LABEL_6:
  unint64_t v12 = result >> 16;
  int64_t v13 = (result >> 16) - v9;
  unint64_t v14 = v8 >> 16;
  if (v9)
  {
    if (v12 < v14) {
      goto LABEL_12;
    }
    unint64_t result = v8;
LABEL_17:
    if (v7 >> 14 >= result >> 14) {
      return sub_223804(result, v7, v8, v7, v6, v5);
    }
    __break(1u);
    goto LABEL_25;
  }

  if (v14 >= v12)
  {
    unint64_t result = v8;
  }

unint64_t sub_218878( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a1 < 0)
  {
    __break(1u);
  }

  else
  {
    unint64_t v5 = a5;
    unint64_t v6 = a4;
    unint64_t v7 = a3;
    unint64_t v8 = a2;
    uint64_t v9 = a1;
    uint64_t v10 = (a4 >> 59) & 1;
    if ((a5 & 0x1000000000000000LL) == 0) {
      LOBYTE(v10) = 1;
    }
    unint64_t result = a3;
    if ((a3 & 0xC) != 4LL << v10)
    {
      if ((a5 & 0x1000000000000000LL) == 0) {
        goto LABEL_6;
      }
LABEL_21:
      unint64_t result = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)(result, -v9, v8, v6, v5);
      if ((v17 & 1) != 0) {
        unint64_t v15 = v8;
      }
      else {
        unint64_t v15 = result;
      }
      goto LABEL_17;
    }
  }

  unint64_t result = sub_22378C(v7, v6, v5);
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_21;
  }
LABEL_6:
  unint64_t v12 = result >> 16;
  int64_t v13 = (result >> 16) - v9;
  unint64_t v14 = v8 >> 16;
  if (v9)
  {
    if (v12 < v14) {
      goto LABEL_12;
    }
    unint64_t v15 = v8;
LABEL_17:
    if (v15 >> 14 >= v8 >> 14) {
      return sub_223804(v8, v15, v8, v7, v6, v5);
    }
    __break(1u);
    goto LABEL_25;
  }

  if (v14 >= v12)
  {
    unint64_t v15 = v8;
  }

uint64_t sub_2189A4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (!result) {
    return a4;
  }
  if (!__OFSUB__(a2 - result, a3))
  {
    sub_229B0C((uint64_t)&v5, (_BYTE *)(result + a3), a2 - result - a3, a4, a5);
    return v5;
  }

  __break(1u);
  return result;
}

uint64_t sub_218A18(uint64_t a1, uint64_t a2)
{
  return sub_217FEC(a1, a2, *(void *)(v2 + 16), **(void **)(v2 + 24), *(void *)(*(void *)(v2 + 24) + 8LL));
}

uint64_t sub_218A38()
{
  return 48LL;
}

uint64_t sub_218A40@<X0>(uint64_t *a1@<X8>)
{
  return sub_218A8C(ccec_cp_256, a1);
}

uint64_t sub_218A4C@<X0>(uint64_t *a1@<X8>)
{
  return sub_218BB0(ccec_cp_256, a1);
}

uint64_t sub_218A58()
{
  return 72LL;
}

uint64_t sub_218A60@<X0>(uint64_t *a1@<X8>)
{
  return sub_218A8C(ccec_cp_384, a1);
}

uint64_t sub_218A6C@<X0>(uint64_t *a1@<X8>)
{
  return sub_218BB0(ccec_cp_384, a1);
}

uint64_t sub_218A78()
{
  return 98LL;
}

uint64_t sub_218A80@<X0>(uint64_t *a1@<X8>)
{
  return sub_218A8C((uint64_t (*)(void))ccec_cp_521, a1);
}

uint64_t sub_218A8C@<X0>(uint64_t (*a1)(void)@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = a1();
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
    a2[3] = result;
    *a2 = v4;
  }

  else
  {
    __break(1u);
  }

  return result;
}

unint64_t sub_218AD0()
{
  unint64_t result = qword_3A8380;
  if (!qword_3A8380)
  {
    unint64_t result = swift_getWitnessTable(&unk_2813EC, &type metadata for SHA256);
    atomic_store(result, (unint64_t *)&qword_3A8380);
  }

  return result;
}

unint64_t sub_218B18()
{
  unint64_t result = qword_3A83B0;
  if (!qword_3A83B0)
  {
    unint64_t result = swift_getWitnessTable(&unk_281424, &type metadata for SHA384);
    atomic_store(result, (unint64_t *)&qword_3A83B0);
  }

  return result;
}

unint64_t sub_218B60()
{
  unint64_t result = qword_3A83E0;
  if (!qword_3A83E0)
  {
    unint64_t result = swift_getWitnessTable(&unk_28145C, &type metadata for SHA512);
    atomic_store(result, (unint64_t *)&qword_3A83E0);
  }

  return result;
}

uint64_t sub_218BA4@<X0>(uint64_t *a1@<X8>)
{
  return sub_218BB0((uint64_t (*)(void))ccec_cp_521, a1);
}

uint64_t sub_218BB0@<X0>(uint64_t (*a1)(void)@<X2>, uint64_t *a2@<X8>)
{
  uint64_t result = a1();
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
    a2[3] = result;
    *a2 = v4;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t sub_218BF0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t sub_218BF8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t type metadata accessor for CoreCryptoNISTCurvePrivateKeyImpl( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CoreCryptoNISTCurvePrivateKeyImpl);
}

uint64_t type metadata accessor for CoreCryptoNISTCurvePublicKeyImpl( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CoreCryptoNISTCurvePublicKeyImpl);
}

unint64_t sub_218C18(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void *__return_ptr))(a2 + 24))(v5);
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
  swift_dynamicCast(&v4, v5, (char *)&type metadata for Any + 8, v2, 7LL);
  unint64_t result = groupOrderByteCountForCP(v4);
  if ((result & 0x8000000000000000LL) != 0) {
    __break(1u);
  }
  return result;
}

uint64_t sub_218C78(uint64_t result, uint64_t a2, unint64_t ***a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v6 = *a3;
  if (!*a3)
  {
    __break(1u);
    goto LABEL_7;
  }

  unint64_t v8 = (unsigned __int8 *)result;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a6 + 24))(v14, a4, a6);
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
  unint64_t result = swift_dynamicCast(&v15, v14, (char *)&type metadata for Any + 8, v9, 7LL);
  if (!v8)
  {
LABEL_7:
    __break(1u);
    return result;
  }

  unint64_t result = ccec_x963_import_priv(v15, a2 - (void)v8, v8, v6);
  if ((_DWORD)result)
  {
    int v10 = result;
    unint64_t v11 = sub_21719C();
    uint64_t v12 = swift_allocError(&type metadata for CryptoKitError, v11, 0LL, 0LL);
    *(_DWORD *)uint64_t v13 = v10;
    *(_BYTE *)(v13 + 4) = 0;
    return swift_willThrow(v12);
  }

  return result;
}

uint64_t sub_218D5C(uint64_t result, uint64_t a2, uint64_t ***a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v6 = *a3;
  if (!*a3)
  {
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v11 = result;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a6 + 24))(v22, a4, a6);
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
  unint64_t result = swift_dynamicCast(&v21, v22, (char *)&type metadata for Any + 8, v12, 7LL);
  if (!v11)
  {
LABEL_14:
    __break(1u);
    return result;
  }

  int v13 = ccec_raw_import_priv_only(v21, a2 - v11, v11, v6);
  int v23 = v13;
  if (v13)
  {
    int v14 = v13;
    unint64_t v15 = sub_21719C();
    uint64_t v16 = swift_allocError(&type metadata for CryptoKitError, v15, 0LL, 0LL);
    *(_DWORD *)uint64_t v17 = v14;
    *(_BYTE *)(v17 + 4) = 0;
    return swift_willThrow(v16);
  }

  else
  {
    int64_t v18 = ccec_der_export_priv_size((uint64_t *)v6, 0LL, 0);
    if (v18)
    {
      uint64_t v19 = sub_23BE4C(v18);
    }

    else
    {
      if (qword_3A7D18 != -1) {
        swift_once(&qword_3A7D18, sub_2384DC);
      }
      uint64_t v19 = (uint64_t *)off_3A8E78[0];
      swift_retain(off_3A8E78[0]);
    }

    if ((swift_isUniquelyReferenced_nonNull_native(v19) & 1) == 0)
    {
      size_t v20 = sub_2348C8((uint64_t)v19);
      swift_release(v19);
      uint64_t v19 = (uint64_t *)v20;
    }

    swift_beginAccess(v19 + 2, v22, 0LL, 0LL);
    sub_218F24((uint64_t)(v19 + 4), (uint64_t)v19 + v19[2] + 32, &v23, (unint64_t **)v6, a4, a5, a6);
    return swift_release(v19);
  }

uint64_t sub_218F24( uint64_t result, uint64_t a2, _DWORD *a3, unint64_t **a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!result)
  {
    __break(1u);
    return result;
  }

  uint64_t v11 = (unsigned __int8 *)result;
  uint64_t v12 = a2 - result;
  int v13 = ccec_der_export_priv(a4, 0LL, 0, a2 - result, result);
  *a3 = v13;
  if (v13)
  {
    int v14 = v13;
    unint64_t v15 = sub_21719C();
    uint64_t v16 = swift_allocError(&type metadata for CryptoKitError, v15, 0LL, 0LL);
    *(_DWORD *)uint64_t v17 = v14;
  }

  else
  {
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a7 + 24))(v22, a5, a7);
    uint64_t v18 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
    swift_dynamicCast(&v21, v22, (char *)&type metadata for Any + 8, v18, 7LL);
    unint64_t result = ccec_der_import_priv(v21, v12, v11, (uint64_t **)a4);
    *a3 = result;
    if (!(_DWORD)result) {
      return result;
    }
    int v19 = result;
    unint64_t v20 = sub_21719C();
    uint64_t v16 = swift_allocError(&type metadata for CryptoKitError, v20, 0LL, 0LL);
    *(_DWORD *)uint64_t v17 = v19;
  }

  *(_BYTE *)(v17 + 4) = 0;
  return swift_willThrow(v16);
}

uint64_t sub_219060(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v26 = 0LL;
  uint64_t v20 = a2;
  uint64_t v21 = a3;
  uint64_t v22 = a4;
  uint64_t v23 = a5;
  uint64_t v10 = a1;
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_219B20, v19, (char *)&type metadata for () + 8, a3, a5);
  if (v5
    || ((*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v25, a2, a4),
        uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8),
        swift_dynamicCast(&v24, v25, (char *)&type metadata for Any + 8, v11, 7LL),
        uint64_t v12 = getccec_pub_ctx_size(v24),
        uint64_t v18 = __chkstk_darwin(v12, v13),
        uint64_t v10 = sub_215258(v18, (uint64_t (*)(void *, uint64_t *))sub_219B3C),
        !v26))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  }

  else
  {
    unint64_t v14 = sub_21719C();
    uint64_t v15 = swift_allocError(&type metadata for CryptoKitError, v14, 0LL, 0LL);
    *(_DWORD *)uint64_t v16 = 1;
    *(_BYTE *)(v16 + 4) = 1;
    swift_willThrow(v15);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
    swift_bridgeObjectRelease(v10);
  }

  return v10;
}

unint64_t sub_219210(_BYTE *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t result = sub_218C18(a3, a5);
  if ((uint64_t)(result + 0x4000000000000000LL) < 0)
  {
    __break(1u);
    goto LABEL_11;
  }

  if (!a1 || a2 - a1 != ((2 * result) | 1))
  {
    unint64_t v11 = sub_21719C();
    uint64_t v9 = swift_allocError(&type metadata for CryptoKitError, v11, 0LL, 0LL);
    *(_DWORD *)uint64_t v10 = 1;
    goto LABEL_8;
  }

  if (a2 == a1)
  {
LABEL_11:
    __break(1u);
    return result;
  }

  if (*a1 == 4) {
    return result;
  }
  unint64_t v8 = sub_21719C();
  uint64_t v9 = swift_allocError(&type metadata for CryptoKitError, v8, 0LL, 0LL);
  *(_DWORD *)uint64_t v10 = 5;
LABEL_8:
  *(_BYTE *)(v10 + 4) = 1;
  return swift_willThrow(v9);
}

uint64_t sub_2192F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v20 = a2;
  uint64_t v21 = a3;
  uint64_t v22 = a4;
  uint64_t v23 = a5;
  uint64_t v10 = a1;
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_21989C, v19, (char *)&type metadata for () + 8, a3, a5);
  if (v5
    || (uint64_t v26 = 0LL,
        (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v25, a2, a4),
        uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8),
        swift_dynamicCast(&v24, v25, (char *)&type metadata for Any + 8, v11, 7LL),
        uint64_t v12 = getccec_pub_ctx_size(v24),
        uint64_t v18 = __chkstk_darwin(v12, v13),
        uint64_t v10 = sub_215258(v18, (uint64_t (*)(void *, uint64_t *))sub_2198B8),
        !v26))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  }

  else
  {
    unint64_t v14 = sub_21719C();
    uint64_t v15 = swift_allocError(&type metadata for CryptoKitError, v14, 0LL, 0LL);
    *(_DWORD *)uint64_t v16 = 1;
    *(_BYTE *)(v16 + 4) = 1;
    swift_willThrow(v15);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
    swift_bridgeObjectRelease(v10);
  }

  return v10;
}

unint64_t sub_2194A0(_BYTE *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t result = sub_218C18(a3, a5);
  if (__OFADD__(result, 1LL))
  {
    __break(1u);
    return result;
  }

  uint64_t v8 = a2 - a1;
  if (!a1) {
    uint64_t v8 = 0LL;
  }
  if (v8 != result + 1)
  {
    unint64_t v13 = sub_21719C();
    uint64_t v10 = swift_allocError(&type metadata for CryptoKitError, v13, 0LL, 0LL);
    int v12 = 1;
    goto LABEL_10;
  }

  if (!a1 || a2 == a1 || (*a1 & 0xFE) != 2)
  {
    unint64_t v9 = sub_21719C();
    uint64_t v10 = swift_allocError(&type metadata for CryptoKitError, v9, 0LL, 0LL);
    int v12 = 5;
LABEL_10:
    *(_DWORD *)uint64_t v11 = v12;
    *(_BYTE *)(v11 + 4) = 1;
    return swift_willThrow(v10);
  }

  return result;
}

uint64_t *sub_21957C( uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10 = *result;
  if (*result)
  {
    void v11[2] = a6;
    v11[3] = a7;
    v11[4] = a8;
    v11[5] = a9;
    v11[6] = a5;
    v11[7] = v10;
    v11[8] = a2;
    v11[9] = a3;
    return (uint64_t *)dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( a10,  v11,  (char *)&type metadata for () + 8,  a7,  a9);
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t sub_2195DC( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t (*a11)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  (*(void (**)(void *__return_ptr, uint64_t))(a9 + 24))(v20, a7);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
  uint64_t result = swift_dynamicCast(&v19, v20, (char *)&type metadata for Any + 8, v17, 7LL);
  if (a1)
  {
    uint64_t result = a11(v19, a2 - a1, a1, a4);
    *a3 = (int)result;
    *a5 = a6;
  }

  else
  {
    __break(1u);
  }

  return result;
}

unint64_t sub_2196A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_2196DC(a1, a2, a3, a4, a5, (uint64_t (*)(void *, uint64_t *))sub_2197CC);
}

unint64_t sub_2196C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_2196DC(a1, a2, a3, a4, a5, (uint64_t (*)(void *, uint64_t *))sub_219794);
}

unint64_t sub_2196DC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void *, uint64_t *))
{
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v16, a2, a4);
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
  swift_dynamicCast(&v17, v16, (char *)&type metadata for Any + 8, v12, 7LL);
  void v14[2] = a2;
  v14[3] = a3;
  void v14[4] = a4;
  v14[5] = a5;
  v14[6] = a1;
  unint64_t v15 = getccec_full_ctx_size(v17);
  return sub_23BBF8(v15, a6, (uint64_t)v14);
}

uint64_t sub_219794(uint64_t a1, void *a2)
{
  return sub_2197E8(a1, a2, (uint64_t)sub_2197B0);
}

uint64_t sub_2197B0(uint64_t a1, uint64_t a2)
{
  return sub_219878( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void))sub_218D5C);
}

uint64_t sub_2197CC(uint64_t a1, void *a2)
{
  return sub_2197E8(a1, a2, (uint64_t)sub_21985C);
}

uint64_t sub_2197E8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(v3 + 40);
  uint64_t v7 = *(void *)(v3 + 56);
  void v9[2] = *(void *)(v3 + 16);
  __int128 v10 = *(_OWORD *)(v3 + 24);
  uint64_t v11 = v6;
  uint64_t v12 = a1;
  uint64_t result = dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(a3, v9, (char *)&type metadata for () + 8, v10, v6);
  if (!v4) {
    *a2 = v7;
  }
  return result;
}

uint64_t sub_21985C(uint64_t a1, uint64_t a2)
{
  return sub_219878( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void))sub_218C78);
}

uint64_t sub_219878( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, void, void, void, void, void))
{
  return a3(a1, a2, v3[6], v3[2], v3[3], v3[4], v3[5]);
}

unint64_t sub_21989C(_BYTE *a1, _BYTE *a2)
{
  return sub_2194A0(a1, a2, v2[2], v2[3], v2[4]);
}

uint64_t *sub_2198B8(uint64_t *a1, uint64_t a2)
{
  return sub_219928(a1, a2, (uint64_t)sub_2198D4);
}

uint64_t sub_2198D4(uint64_t a1, uint64_t a2)
{
  return sub_219978(a1, a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))ccec_compressed_x962_import_pub);
}

uint64_t sub_2198F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_2199CC(a1, a2, a3, a4, a5, (uint64_t (*)(void *, uint64_t *))sub_21990C);
}

uint64_t *sub_21990C(uint64_t *a1, uint64_t a2)
{
  return sub_219928(a1, a2, (uint64_t)sub_21995C);
}

uint64_t *sub_219928(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return sub_21957C(a1, a2, v3[6], v3[7], v3[8], v3[2], v3[3], v3[4], v3[5], a3);
}

uint64_t sub_21995C(uint64_t a1, uint64_t a2)
{
  return sub_219978(a1, a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))ccec_compact_import_pub);
}

uint64_t sub_219978(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  return sub_2195DC( a1,  a2,  *(void **)(v3 + 48),  *(void *)(v3 + 56),  *(void **)(v3 + 64),  *(void *)(v3 + 72),  *(void *)(v3 + 16),  *(void *)(v3 + 24),  *(void *)(v3 + 32),  *(void *)(v3 + 40),  a3);
}

uint64_t sub_2199B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_2199CC(a1, a2, a3, a4, a5, (uint64_t (*)(void *, uint64_t *))sub_219AE8);
}

uint64_t sub_2199CC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void *, uint64_t *))
{
  uint64_t v17 = 0LL;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v16, a2, a4);
  uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F8);
  swift_dynamicCast(&v15, v16, (char *)&type metadata for Any + 8, v7, 7LL);
  uint64_t v14 = getccec_pub_ctx_size(v15);
  uint64_t v8 = sub_215258(v14, a6);
  uint64_t v9 = v8;
  if (v17)
  {
    swift_bridgeObjectRelease(v8);
    unint64_t v10 = sub_21719C();
    uint64_t v11 = swift_allocError(&type metadata for CryptoKitError, v10, 0LL, 0LL);
    *(_DWORD *)uint64_t v12 = 1;
    *(_BYTE *)(v12 + 4) = 1;
    swift_willThrow(v11);
  }

  return v9;
}

uint64_t *sub_219AE8(uint64_t *a1, uint64_t a2)
{
  return sub_219928(a1, a2, (uint64_t)sub_219B04);
}

uint64_t sub_219B04(uint64_t a1, uint64_t a2)
{
  return sub_219978(a1, a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))ccec_raw_import_pub);
}

unint64_t sub_219B20(_BYTE *a1, _BYTE *a2)
{
  return sub_219210(a1, a2, v2[2], v2[3], v2[4]);
}

uint64_t *sub_219B3C(uint64_t *a1, uint64_t a2)
{
  return sub_219928(a1, a2, (uint64_t)sub_219B58);
}

uint64_t sub_219B58(uint64_t a1, uint64_t a2)
{
  return sub_219978(a1, a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))ccec_import_pub);
}

uint64_t sub_219B74@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v36 = a8;
  uint64_t v37 = a2;
  uint64_t v38 = a5;
  uint64_t v39 = a7;
  uint64_t v40 = a4;
  v34[1] = a9;
  uint64_t v41 = type metadata accessor for Optional(0LL, a6);
  uint64_t v13 = *(void *)(v41 - 8);
  uint64_t v15 = __chkstk_darwin(v41, v14);
  uint64_t v17 = (char *)v34 - v16;
  uint64_t v42 = *(void *)(a6 - 8);
  __chkstk_darwin(v15, v18);
  uint64_t v35 = (char *)v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = *a1;
  uint64_t v21 = *a3;
  unint64_t v22 = a3[1];
  uint64_t v23 = *a3;
  unint64_t v24 = v22;
  if (v22 >> 60 == 15)
  {
    *(void *)((char *)&v45 + 6) = 0LL;
    *(void *)&__int128 v45 = 0LL;
    BYTE14(v45) = 12;
    LODWORD(v44) = 0;
    __int128 v25 = ccrng(&v44);
    if (!v25)
    {
      __break(1u);
      JUMPOUT(0x219F78LL);
    }

    if ((_DWORD)v44)
    {
      __break(1u);
      JUMPOUT(0x219F5CLL);
    }

    ccrng_generate_bridge((uint64_t (**)(void))v25);
    uint64_t v23 = v45;
    unint64_t v24 = DWORD2(v45) | ((unint64_t)BYTE12(v45) << 32) | ((unint64_t)BYTE13(v45) << 40) | ((unint64_t)BYTE14(v45) << 48);
  }

  swift_retain(v20);
  sub_1F83C0(v23, v24);
  sub_21B5BC(v21, v22);
  uint64_t v26 = ccaes_gcm_encrypt_mode();
  if (!v26) {
    __break(1u);
  }
  uint64_t v27 = (uint64_t)v26;
  uint64_t v43 = v20;
  *(void *)&__int128 v45 = v23;
  *((void *)&v45 + 1) = v24;
  uint64_t v28 = type metadata accessor for CoreCryptoGCMImpl.Context();
  swift_allocObject(v28, 32LL, 7LL);
  uint64_t v29 = sub_21A6D8(&v43, (uint64_t *)&v45, v27);
  if (!v9)
  {
    uint64_t v44 = v29;
    uint64_t v31 = v41;
    (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v17, v40, v41);
    uint64_t v32 = v42;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v42 + 48))(v17, 1LL, a6) == 1)
    {
      (*(void (**)(char *, uint64_t))(v13 + 8))(v17, v31);
    }

    else
    {
      uint64_t v33 = (uint64_t)v35;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v35, v17, a6);
      sub_21A4E0(v33, a6, v36);
      (*(void (**)(uint64_t, uint64_t))(v32 + 8))(v33, a6);
    }

    __asm { BR              X10 }
  }

  return sub_1F86D4(v23, v24);
}

void sub_219F88(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 v16[2] = a5;
  void v16[4] = a3;
  uint64_t v7 = type metadata accessor for Optional(0LL, a4);
  v16[5] = *(void *)(v7 - 8);
  v16[6] = v7;
  uint64_t v9 = __chkstk_darwin(v7, v8);
  __chkstk_darwin(v9, v10);
  v16[1] = (char *)v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *a1;
  uint64_t v13 = *a2;
  unint64_t v14 = a2[1];
  uint64_t v15 = a2[2];
  sub_1F83C0(*a2, v14);
  sub_1F83C0(v13, v14);
  swift_retain(v12);
  sub_216CCC(v15, v13, v14);
  __asm { BR              X10 }

uint64_t sub_21A088()
{
  if (BYTE6(v3) < 0xCuLL)
  {
LABEL_10:
    unint64_t v22 = sub_21719C();
    uint64_t v23 = swift_allocError(&type metadata for CryptoKitError, v22, 0LL, 0LL);
    *(_DWORD *)uint64_t v24 = 1;
    *(_BYTE *)(v24 + 4) = 1;
    swift_willThrow(v23);
    sub_1F86D4(v5, v3);
    swift_unexpectedError(v23, "CryptoKit_Static/AES-GCM.swift", 30LL, 1LL, 138LL);
    __break(1u);
    JUMPOUT(0x21A4C0LL);
  }

  *(void *)(v9 - 16_Block_object_dispose((const void *)(v11 - 96), 8) = v8;
  sub_2144FC(v5, v3);
  uint64_t v5 = v10;
  uint64_t v12 = v11;
  sub_1F86D4(v0, v2);
  uint64_t v13 = ccaes_gcm_decrypt_mode();
  if (!v13)
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v14 = (uint64_t)v13;
  *(void *)(v9 - 112) = v1;
  *(void *)(v9 - 96) = v5;
  *(void *)(v9 - 8_Block_object_dispose((const void *)(v11 - 96), 8) = v12;
  uint64_t v15 = type metadata accessor for CoreCryptoGCMImpl.Context();
  swift_allocObject(v15, 32LL, 7LL);
  uint64_t v16 = *(void *)(v9 - 136);
  uint64_t result = sub_21A6D8((uint64_t *)(v9 - 112), (uint64_t *)(v9 - 96), v14);
  if (!v16)
  {
    *(void *)(v9 - 72) = result;
    uint64_t v18 = *(void *)(v9 - 152);
    uint64_t v19 = *(void *)(v9 - 144);
    (*(void (**)(uint64_t, void, uint64_t))(v18 + 16))(v4, *(void *)(v9 - 160), v19);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(v4, 1LL, v6) == 1)
    {
      (*(void (**)(uint64_t, uint64_t))(v18 + 8))(v4, v19);
    }

    else
    {
      uint64_t v21 = *(void *)(v9 - 184);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(v21, v4, v6);
      sub_21A4E0(v21, v6, *(void *)(v9 - 176));
      (*(void (**)(uint64_t, uint64_t))(v7 + 8))(v21, v6);
    }

    uint64_t v20 = *(void *)(v9 - 168);
    *(_OWORD *)(v9 - 96) = xmmword_280350;
    sub_1F83C0(v0, v2);
    sub_216838(v20, v0, v2);
    sub_216AC4(16LL, *(void *)(v9 - 128), *(void *)(v9 - 120));
    __asm { BR              X10 }
  }

  return result;
}

size_t sub_21A4E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((swift_isUniquelyReferenced_nonNull_native(*v3) & 1) != 0) {
    return sub_21AA90(a1, a2, a3);
  }
  uint64_t v7 = *v3;
  uint64_t v8 = type metadata accessor for CoreCryptoGCMImpl.Context();
  uint64_t v9 = swift_allocObject(v8, 32LL, 7LL);
  uint64_t v10 = *(void *)(v7 + 24);
  *(void *)(v9 + 24) = v10;
  swift_retain(v7);
  uint64_t GCMCtxSize = getGCMCtxSize(v10);
  uint64_t v12 = (void *)swift_slowAlloc(GCMCtxSize, -1LL);
  uint64_t v13 = *(const void **)(v7 + 16);
  size_t result = getGCMCtxSize(v10);
  if ((result & 0x8000000000000000LL) == 0)
  {
    memmove(v12, v13, result);
    swift_release(v7);
    *(void *)(v9 + 16) = v12;
    uint64_t v15 = *v3;
    *unint64_t v3 = v9;
    swift_release(v15);
    return sub_21AA90(a1, a2, a3);
  }

  __break(1u);
  return result;
}

void sub_21A5D0(uint64_t a1, uint64_t a2)
{
  if ((swift_isUniquelyReferenced_nonNull_native(*v2) & 1) != 0) {
    goto LABEL_4;
  }
  uint64_t v5 = *v2;
  uint64_t v6 = type metadata accessor for CoreCryptoGCMImpl.Context();
  uint64_t v7 = swift_allocObject(v6, 32LL, 7LL);
  uint64_t v8 = *(void *)(v5 + 24);
  *(void *)(v7 + 24) = v8;
  swift_retain(v5);
  uint64_t GCMCtxSize = getGCMCtxSize(v8);
  uint64_t v10 = (void *)swift_slowAlloc(GCMCtxSize, -1LL);
  uint64_t v11 = *(const void **)(v5 + 16);
  size_t v12 = getGCMCtxSize(v8);
  if ((v12 & 0x8000000000000000LL) == 0)
  {
    memmove(v10, v11, v12);
    swift_release(v5);
    *(void *)(v7 + 16) = v10;
    uint64_t v13 = *v2;
    uint64_t *v2 = v7;
    swift_release(v13);
LABEL_4:
    sub_21AD0C(a1, a2);
    return;
  }

  __break(1u);
}

uint64_t sub_21A6D8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v6 = *a1;
  uint64_t v8 = *a2;
  unint64_t v7 = a2[1];
  swift_beginAccess(*a1 + 16, v23, 0LL, 0LL);
  unint64_t v9 = *(void *)(v6 + 16);
  if (v9 >> 60)
  {
    __break(1u);
    JUMPOUT(0x21AA60LL);
  }

  uint64_t v10 = 8 * v9;
  if (v10 == 128 || v10 == 192 || v10 == 256)
  {
    uint64_t GCMCtxSize = getGCMCtxSize(a3);
    uint64_t v12 = swift_slowAlloc(GCMCtxSize, -1LL);
    *(void *)(v4 + 16) = v12;
    *(void *)(v4 + 24) = a3;
    int v13 = ccgcm_init(a3, v12, *(void *)(v6 + 16), v6 + 32);
    if (!v13)
    {
      swift_release(v6);
      __asm { BR              X10 }
    }

    int v14 = v13;
    unint64_t v15 = sub_21719C();
    uint64_t v16 = swift_allocError(&type metadata for CryptoKitError, v15, 0LL, 0LL);
    *(_DWORD *)uint64_t v17 = v14;
    *(_BYTE *)(v17 + 4) = 0;
    swift_willThrow(v16);
    sub_1F86D4(v8, v7);
    swift_release(v6);
    swift_release(v4);
  }

  else
  {
    sub_1F86D4(v8, v7);
    swift_release(v6);
    unint64_t v18 = sub_21719C();
    uint64_t v19 = swift_allocError(&type metadata for CryptoKitError, v18, 0LL, 0LL);
    *(_DWORD *)uint64_t v20 = 0;
    *(_BYTE *)(v20 + 4) = 1;
    swift_willThrow(v19);
    uint64_t v21 = type metadata accessor for CoreCryptoGCMImpl.Context();
    swift_deallocPartialClassInstance(v4, v21, 32LL, 7LL);
  }

  return v4;
}

uint64_t sub_21AA90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v8);
  uint64_t v10 = &v13[-v9];
  dispatch thunk of DataProtocol.regions.getter(a2, a3);
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v16 = v3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  Sequence.forEach(_:)( sub_21B588,  v13,  AssociatedTypeWitness,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL));
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v7 + 8))(v10, AssociatedTypeWitness);
}

uint64_t sub_21ABA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  uint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL),  AssociatedTypeWitness,  &protocol requirements base descriptor for Sequence,  &associated type descriptor for Sequence.Element);
  uint64_t v10 = swift_getAssociatedConformanceWitness( a4,  a3,  v9,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions.Sequence.Element: ContiguousBytes);
  return dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_21B5A4,  a2,  (char *)&type metadata for () + 8,  v9,  v10);
}

uint64_t sub_21AC98(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    size_t result = ccgcm_aad(*(void *)(a3 + 24), *(void *)(a3 + 16), a2 - result, result);
    if ((_DWORD)result)
    {
      int v3 = result;
      unint64_t v4 = sub_21719C();
      uint64_t v5 = swift_allocError(&type metadata for CryptoKitError, v4, 0LL, 0LL);
      *(_DWORD *)uint64_t v6 = v3;
      *(_BYTE *)(v6 + 4) = 0;
      return swift_willThrow(v5);
    }
  }

  else
  {
    __break(1u);
  }

  return result;
}

void sub_21AD0C(uint64_t a1, uint64_t a2)
{
  __asm { BR              X12 }

void sub_21AD60()
{
  uint64_t v2 = dispatch thunk of Collection.count.getter(v1, *(void *)(*(void *)(*(void *)(v0 + 8) + 8LL) + 8LL));
  if (v2 < 0)
  {
    __break(1u);
    JUMPOUT(0x21AE08LL);
  }

  uint64_t v3 = sub_217640(v2, 0);
  __chkstk_darwin(v3, v4);
  sub_220C4C();
}

uint64_t sub_21AE20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v25 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a7,  a6,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v14);
  uint64_t v16 = (char *)&v24 - v15;
  uint64_t v17 = sub_2169C8(a3, a1, a2);
  uint64_t v19 = v18 + v17;
  uint64_t v21 = v18 + v20;
  if (!v18)
  {
    uint64_t v21 = 0LL;
    uint64_t v19 = 0LL;
  }

  v31[0] = v19;
  v31[1] = v21;
  dispatch thunk of DataProtocol.regions.getter(a6, a7);
  uint64_t v27 = a6;
  uint64_t v28 = a7;
  uint64_t v29 = v31;
  uint64_t v30 = v25;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  a6,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  Sequence.forEach(_:)( sub_21B554,  v26,  AssociatedTypeWitness,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL));
  return (*(uint64_t (**)(char *, uint64_t))(v13 + 8))(v16, AssociatedTypeWitness);
}

uint64_t sub_21AF7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[2] = a2;
  unint64_t v12[3] = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a5,  a4,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  uint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL),  AssociatedTypeWitness,  &protocol requirements base descriptor for Sequence,  &associated type descriptor for Sequence.Element);
  uint64_t v10 = swift_getAssociatedConformanceWitness( a5,  a4,  v9,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions.Sequence.Element: ContiguousBytes);
  return dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_21B570,  v12,  (char *)&type metadata for () + 8,  v9,  v10);
}

uint64_t sub_21B074(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = a2 - result;
  if (result) {
    uint64_t v6 = a2 - result;
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t v7 = *a3;
  if (!*a3)
  {
    if (v6 <= 0) {
      goto LABEL_6;
    }
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }

  if (a3[1] - v7 < v6) {
    goto LABEL_10;
  }
LABEL_6:
  if (!result)
  {
    __break(1u);
    return result;
  }

  int v8 = ccgcm_update(*(void *)(a4 + 24), *(void *)(a4 + 16), v5, result, v7);
  if (v8)
  {
    int v9 = v8;
    unint64_t v10 = sub_21719C();
    uint64_t v11 = swift_allocError(&type metadata for CryptoKitError, v10, 0LL, 0LL);
    *(_DWORD *)uint64_t v12 = v9;
    *(_BYTE *)(v12 + 4) = 0;
    return swift_willThrow(v11);
  }

uint64_t sub_21B150()
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  int v1 = ccgcm_finalize(*(void *)(v0 + 24), *(void *)(v0 + 16), 16LL, (uint64_t)v8);
  if (v1)
  {
    int v2 = v1;
    unint64_t v3 = sub_21719C();
    uint64_t v4 = swift_allocError(&type metadata for CryptoKitError, v3, 0LL, 0LL);
    *(_DWORD *)uint64_t v5 = v2;
    *(_BYTE *)(v5 + 4) = 0;
    return swift_willThrow(v4);
  }

  else
  {
    void v9[3] = &type metadata for UnsafeRawBufferPointer;
    v9[4] = &protocol witness table for UnsafeRawBufferPointer;
    v9[0] = v8;
    v9[1] = v9;
    uint64_t v7 = __swift_project_boxed_opaque_existential_1(v9, (uint64_t)&type metadata for UnsafeRawBufferPointer);
    Data._Representation.append(contentsOf:)(*v7, v7[1]);
    return __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

void sub_21B240(uint64_t a1, uint64_t a2)
{
  __asm { BR              X9 }

BOOL sub_21B298( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, __int16 a10, char __src, char a12, char a13, char a14, char a15, char a16, char a17, char a18, char a19, char a20, char a21, char a22, char a23, char a24, uint64_t __dst, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37)
{
  if (BYTE6(v40) != 16LL) {
    return 0LL;
  }
  v67[0] = 0LL;
  v67[1] = 0LL;
  uint64_t v41 = *(void *)(v37 + 24);
  uint64_t v42 = ccaes_gcm_decrypt_mode();
  if (!v42)
  {
    __break(1u);
    JUMPOUT(0x21B4B4LL);
  }

  if ((uint64_t *)v41 != v42)
  {
    __break(1u);
    JUMPOUT(0x21B494LL);
  }

  if (v38)
  {
    if (v38 == 1)
    {
      if (v39 >> 32 >= (int)v39)
      {
        uint64_t v43 = sub_1F83C0(v39, v40);
        uint64_t v44 = ((uint64_t (*)(uint64_t))__DataStorage._bytes.getter)(v43);
        if (!v44)
        {
          __DataStorage._length.getter();
LABEL_26:
          sub_1F86D4(v39, v40);
          return ccgcm_finalize(v41, *(void *)(v37 + 16), 16LL, (uint64_t)v67) == 0;
        }

        uint64_t v45 = v44;
        uint64_t v46 = __DataStorage._offset.getter();
        uint64_t v47 = (int)v39 - v46;
        if (!__OFSUB__((int)v39, v46))
        {
          uint64_t v48 = __DataStorage._length.getter();
          else {
            size_t v49 = v48;
          }
          memmove(v67, (const void *)(v45 + v47), v49);
          goto LABEL_26;
        }

        goto LABEL_31;
      }

      __break(1u);
    }

    else
    {
      uint64_t v51 = v40 & 0x3FFFFFFFFFFFFFFFLL;
      uint64_t v52 = *(void *)(v39 + 16);
      uint64_t v53 = *(void *)(v39 + 24);
      swift_retain(v39);
      uint64_t v54 = swift_retain(v40 & 0x3FFFFFFFFFFFFFFFLL);
      __int128 v55 = (char *)((uint64_t (*)(uint64_t))__DataStorage._bytes.getter)(v54);
      if (v55)
      {
        uint64_t v56 = __DataStorage._offset.getter();
        if (__OFSUB__(v52, v56)) {
          goto LABEL_32;
        }
        v55 += v52 - v56;
      }

      BOOL v57 = __OFSUB__(v53, v52);
      int64_t v58 = v53 - v52;
      if (!v57)
      {
        uint64_t v59 = __DataStorage._length.getter();
        if (v55)
        {
          if (v59 >= v58) {
            size_t v60 = v58;
          }
          else {
            size_t v60 = v59;
          }
          memmove(v67, v55, v60);
        }

        swift_release(v51);
        swift_release(v39);
        return ccgcm_finalize(v41, *(void *)(v37 + 16), 16LL, (uint64_t)v67) == 0;
      }
    }

    __break(1u);
LABEL_31:
    __break(1u);
LABEL_32:
    __break(1u);
  }

  uint64_t v61 = v39;
  __int16 v62 = v40;
  char v63 = BYTE2(v40);
  char v64 = BYTE3(v40);
  char v65 = BYTE4(v40);
  char v66 = BYTE5(v40);
  memcpy(v67, &v61, BYTE6(v40));
  return ccgcm_finalize(v41, *(void *)(v37 + 16), 16LL, (uint64_t)v67) == 0;
}

uint64_t sub_21B4C4()
{
  int v1 = *(void **)(v0 + 16);
  rsize_t GCMCtxSize = getGCMCtxSize(*(void *)(v0 + 24));
  memset_s(v1, GCMCtxSize, 0, GCMCtxSize);
  swift_slowDealloc(v1, -1LL, -1LL);
  return swift_deallocClassInstance(v0, 32LL, 7LL);
}

uint64_t type metadata accessor for CoreCryptoGCMImpl.Context()
{
  return objc_opt_self(&OBJC_CLASS____TtCV16CryptoKit_Static17CoreCryptoGCMImplP33_635FF0E9B8BF3D1091F36C068FAE584E7Context);
}

uint64_t sub_21B534(uint64_t a1, uint64_t a2)
{
  return sub_21AE20(a1, a2, v2[4], v2[5], v2[6], v2[2], v2[3]);
}

uint64_t sub_21B554(uint64_t a1)
{
  return sub_21AF7C(a1, v1[4], v1[5], v1[2], v1[3]);
}

uint64_t sub_21B570(uint64_t a1, uint64_t a2)
{
  return sub_21B074(a1, a2, *(uint64_t **)(v2 + 16), *(void *)(v2 + 24));
}

uint64_t sub_21B588(uint64_t a1)
{
  return sub_21ABA4(a1, v1[4], v1[2], v1[3]);
}

uint64_t sub_21B5A4(uint64_t a1, uint64_t a2)
{
  return sub_21AC98(a1, a2, v2);
}

uint64_t sub_21B5BC(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_1F83C0(a1, a2);
  }
  return a1;
}

ValueMetadata *type metadata accessor for CoreCryptoGCMImpl()
{
  return &type metadata for CoreCryptoGCMImpl;
}

ValueMetadata *type metadata accessor for P256()
{
  return &type metadata for P256;
}

ValueMetadata *type metadata accessor for P384()
{
  return &type metadata for P384;
}

ValueMetadata *type metadata accessor for P521()
{
  return &type metadata for P521;
}

uint64_t *sub_21B610( uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a8;
  uint64_t v23 = a7;
  uint64_t v14 = type metadata accessor for Optional(0LL, a6);
  uint64_t v15 = *(void *)(v14 - 8);
  __chkstk_darwin(v14, v16);
  uint64_t v18 = (char *)&v22 - v17;
  uint64_t v26 = *a2;
  __int128 v25 = *a3;
  uint64_t v19 = *(void *)(a6 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))((char *)&v22 - v17, a4, a6);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v19 + 56))(v18, 0LL, 1LL, a6);
  uint64_t v20 = sub_21EF38(&v26, a1, (uint64_t *)&v25, (uint64_t)v18, a5, a6, v23, v24);
  (*(void (**)(char *, uint64_t))(v15 + 8))(v18, v14);
  return v20;
}

uint64_t *sub_21B734(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *a2;
  __int128 v8 = *a3;
  __int128 v11 = xmmword_280980;
  *(_OWORD *)uint64_t v12 = v8;
  unint64_t v9 = sub_1F8404();
  return sub_21EF38(&v13, a1, v12, (uint64_t)&v11, a4, (uint64_t)&type metadata for Data, a5, v9);
}

uint64_t sub_21B7B4(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for Optional(0LL, a5);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10, v12);
  uint64_t v14 = (char *)&v19 - v13;
  uint64_t v20 = *a3;
  uint64_t v15 = *(void *)(a5 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))((char *)&v19 - v13, a4, a5);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(v14, 0LL, 1LL, a5);
  sub_21F25C(&v20, a1, a2, (uint64_t)v14, a5);
  uint64_t v17 = v16;
  (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
  return v17;
}

void sub_21B8C8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  __asm { BR              X10 }

uint64_t sub_21B950(uint64_t a1, unint64_t a2)
{
  if (BYTE6(a2) != 12LL)
  {
    unint64_t v21 = sub_21719C();
    uint64_t v22 = swift_allocError(&type metadata for CryptoKitError, v21, 0LL, 0LL);
    *(_DWORD *)uint64_t v23 = 1;
    *(_BYTE *)(v23 + 4) = 1;
    swift_willThrow(v22);
    sub_1F86D4(v8, a2);
    swift_unexpectedError(v22, "CryptoKit_Static/ChaChaPoly.swift", 33LL, 1LL, 139LL);
    __break(1u);
    JUMPOUT(0x21BE30LL);
  }

  sub_2144FC(v8, a2);
  uint64_t v26 = v3;
  *(void *)&v28[0] = v9;
  *((void *)&v28[0] + 1) = v10;
  uint64_t v11 = type metadata accessor for CoreCryptoChaChaPolyImpl.Context();
  swift_allocObject(v11, 24LL, 7LL);
  uint64_t result = sub_21FA54(&v26, (uint64_t *)v28);
  if (!v2)
  {
    uint64_t v13 = result;
    if (v6 >> 60 != 15)
    {
      sub_1F83C0(v7, v6);
      if (!swift_isUniquelyReferenced_nonNull_native(v13))
      {
        uint64_t v14 = swift_allocObject(v11, 24LL, 7LL);
        swift_retain(v13);
        uint64_t v15 = (void *)swift_slowAlloc(256LL, -1LL);
        *(void *)(v14 + 16) = v15;
        memmove(v15, *(const void **)(v13 + 16), 0x100uLL);
        swift_release_n(v13, 2LL);
        uint64_t v13 = v14;
      }

      sub_21C280(v7, v6);
      sub_215B4C(v7, v6);
    }

    v28[0] = xmmword_280350;
    sub_1F83C0(v5, v4);
    sub_216838(12LL, v5, v4);
    sub_216AC4(16LL, v24, v25);
    uint64_t v16 = v26;
    unint64_t v17 = v27;
    if (!swift_isUniquelyReferenced_nonNull_native(v13))
    {
      uint64_t v18 = swift_allocObject(v11, 24LL, 7LL);
      swift_retain(v13);
      uint64_t v19 = (void *)swift_slowAlloc(256LL, -1LL);
      *(void *)(v18 + 16) = v19;
      memmove(v19, *(const void **)(v13 + 16), 0x100uLL);
      swift_release_n(v13, 2LL);
      uint64_t v13 = v18;
    }

    sub_21C544(v16, v17, (uint64_t)v28);
    sub_1F86D4(v16, v17);
    sub_1F83C0(v5, v4);
    swift_retain(v13);
    sub_216650(16LL, v5, v4);
    __asm { BR              X10 }
  }

  return result;
}

void sub_21BE8C(uint64_t a1, unint64_t a2, uint64_t *a3)
{
}

uint64_t sub_21BEB8(uint64_t a1, unint64_t a2)
{
  return a1;
}

uint64_t sub_21BEE4(uint64_t a1, unint64_t a2)
{
  return v5;
}

uint64_t sub_21BF28(uint64_t a1, unint64_t a2)
{
  return v7;
}

void sub_21BF7C(uint64_t a1, unint64_t a2)
{
}

void sub_21BFFC(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

void sub_21C038()
{
  if (BYTE6(v0) == 12LL)
  {
    sub_2144FC(v1, v0);
    void *v2 = v3;
    v2[1] = v4;
  }

  else
  {
    unint64_t v5 = sub_21719C();
    uint64_t v6 = swift_allocError(&type metadata for CryptoKitError, v5, 0LL, 0LL);
    *(_DWORD *)uint64_t v7 = 1;
    *(_BYTE *)(v7 + 4) = 1;
    swift_willThrow(v6);
    sub_1F86D4(v1, v0);
  }

char *sub_21C0E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v7 + 8) + 8LL) + 8LL);
  if (dispatch thunk of Collection.count.getter(v9, v8) >= 28)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, a1, a2);
    uint64_t v6 = (char *)Data.init<A>(_:)(v6, a2, *(void *)(v8 + 8));
  }

  else
  {
    unint64_t v10 = sub_21719C();
    uint64_t v11 = swift_allocError(&type metadata for CryptoKitError, v10, 0LL, 0LL);
    *(_DWORD *)uint64_t v12 = 1;
    *(_BYTE *)(v12 + 4) = 1;
    swift_willThrow(v11);
  }

  (*(void (**)(uint64_t, uint64_t))(v4 + 8))(a1, a2);
  return v6;
}

uint64_t sub_21C1FC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = sub_21CA68(a1, a2, a3, a4, a5, a6, a7);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a5 - 8) + 8LL))(a3, a5);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8LL))(a2, a4);
  return v11;
}

void sub_21C280(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t sub_21C2D8()
{
  LOWORD(v10) = v2;
  BYTE2(v10) = BYTE2(v2);
  HIBYTE(v10) = BYTE3(v2);
  char v11 = BYTE4(v2);
  char v12 = BYTE5(v2);
  char v13 = BYTE6(v2);
  char v14 = HIBYTE(v2);
  __int16 v15 = v0;
  char v16 = BYTE2(v0);
  char v17 = BYTE3(v0);
  char v18 = BYTE4(v0);
  char v19 = BYTE5(v0);
  uint64_t v3 = qword_3A7C88;
  swift_retain_n(v1, 2LL);
  if (v3 != -1) {
    swift_once(&qword_3A7C88, sub_21F8B8);
  }
  int v4 = ccchacha20poly1305_aad(qword_3AE720, *(void *)(v1 + 16), BYTE6(v0), &v10);
  if (v4)
  {
    int v5 = v4;
    unint64_t v6 = sub_21719C();
    uint64_t v7 = swift_allocError(&type metadata for CryptoKitError, v6, 0LL, 0LL);
    *(_DWORD *)uint64_t v8 = v5;
    *(_BYTE *)(v8 + 4) = 0;
    swift_willThrow(v7);
  }

  sub_1F86D4(v2, v0);
  return swift_release_n(v1, 2LL);
}

void sub_21C544(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X12 }

uint64_t sub_21C594(uint64_t a1, unint64_t a2)
{
  return ((uint64_t (*)(void))((char *)&loc_21C5CC + *((int *)qword_21C690 + (a2 >> 62))))();
}

void sub_21C5DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = sub_217640(BYTE6(a2), 0);
  __chkstk_darwin(v2, v3);
  sub_220C4C();
}

uint64_t sub_21C6A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return sub_1F86D4(a4, a5);
}

void sub_21C74C(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t sub_21C7AC()
{
  uint64_t v6 = v3;
  __int16 v7 = v4;
  char v8 = BYTE2(v4);
  char v9 = BYTE3(v4);
  char v10 = BYTE4(v4);
  char v11 = BYTE5(v4);
  return sub_22048C((uint64_t)&v6, (uint64_t)&v6 + BYTE6(v4), v2, v1, v0);
}

uint64_t sub_21C9B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = __DataStorage._bytes.getter();
  uint64_t v8 = result;
  if (result)
  {
    uint64_t result = __DataStorage._offset.getter();
    if (__OFSUB__(a1, result))
    {
LABEL_13:
      __break(1u);
      return result;
    }

    v8 += a1 - result;
  }

  BOOL v9 = __OFSUB__(a2, a1);
  uint64_t v10 = a2 - a1;
  if (v9)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v11 = __DataStorage._length.getter();
  if (v11 >= v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = v11;
  }
  uint64_t v13 = v8 + v12;
  if (v8) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0LL;
  }
  sub_22003C(v8, v14, a4);
  return swift_release(a4);
}

uint64_t sub_21CA68(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v29 = a4;
  uint64_t v12 = *a1;
  unint64_t v11 = a1[1];
  uint64_t v13 = *(void *)(*(void *)(*(void *)(a7 + 8) + 8LL) + 8LL);
  if (dispatch thunk of Collection.count.getter(a5, v13) == 16)
  {
    sub_2147A4(v12, v11);
    uint64_t v15 = v14;
    unint64_t v17 = v16;
    v28[0] = v14;
    v28[1] = v16;
    unint64_t v18 = sub_21CDE0();
    static RangeReplaceableCollection.+ infix<A>(_:_:)( &v26,  v28,  a2,  &type metadata for Data,  v29,  v18,  *(void *)(*(void *)(*(void *)(*(void *)(a6 + 8) + 8LL) + 8LL) + 8LL));
    sub_1F86D4(v15, v17);
    uint64_t v19 = v26;
    unint64_t v20 = v27;
    v25[0] = v26;
    v25[1] = v27;
    static RangeReplaceableCollection.+ infix<A>(_:_:)( v28,  v25,  a3,  &type metadata for Data,  a5,  v18,  *(void *)(v13 + 8));
    sub_1F86D4(v19, v20);
    return v28[0];
  }

  else
  {
    sub_1F86D4(v12, v11);
    unint64_t v22 = sub_21719C();
    uint64_t v23 = swift_allocError(&type metadata for CryptoKitError, v22, 0LL, 0LL);
    *(_DWORD *)uint64_t v24 = 1;
    *(_BYTE *)(v24 + 4) = 1;
    return swift_willThrow(v23);
  }

unint64_t sub_21CBD0()
{
  unint64_t result = qword_3A85F8;
  if (!qword_3A85F8)
  {
    unint64_t result = swift_getWitnessTable(&unk_282588, &_s5NonceVN_0);
    atomic_store(result, (unint64_t *)&qword_3A85F8);
  }

  return result;
}

unint64_t sub_21CC18()
{
  unint64_t result = qword_3A8600;
  if (!qword_3A8600)
  {
    unint64_t result = swift_getWitnessTable(&unk_280BAC, &type metadata for ChaChaPoly.SealedBox);
    atomic_store(result, (unint64_t *)&qword_3A8600);
  }

  return result;
}

ValueMetadata *type metadata accessor for ChaChaPoly()
{
  return &type metadata for ChaChaPoly;
}

uint64_t *initializeBufferWithCopyOfBuffer for ChaChaPoly.SealedBox(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  sub_1F83C0(*a2, v4);
  *a1 = v3;
  a1[1] = v4;
  return a1;
}

uint64_t *assignWithCopy for ChaChaPoly.SealedBox(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  sub_1F83C0(*a2, v4);
  uint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  *a1 = v3;
  a1[1] = v4;
  sub_1F86D4(v5, v6);
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t *assignWithTake for ChaChaPoly.SealedBox(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  *(_OWORD *)a1 = *a2;
  sub_1F86D4(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for ChaChaPoly.SealedBox(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xD && *(_BYTE *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 8) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 8) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for ChaChaPoly.SealedBox(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(void *)__n128 result = a2 - 13;
    *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 16) = 0;
    }
    if (a2)
    {
      *(void *)__n128 result = 0LL;
      *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for ChaChaPoly.SealedBox()
{
  return &type metadata for ChaChaPoly.SealedBox;
}

unint64_t sub_21CDE0()
{
  unint64_t result = qword_3A8680;
  if (!qword_3A8680)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Data, &type metadata for Data);
    atomic_store(result, (unint64_t *)&qword_3A8680);
  }

  return result;
}

uint64_t sub_21CE24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = __DataStorage._bytes.getter();
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t result = __DataStorage._offset.getter();
    if (__OFSUB__(a1, result)) {
      goto LABEL_10;
    }
    uint64_t v8 = (char *)(v6 + a1 - result);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  uint64_t result = __DataStorage._length.getter();
  if (qword_3A7C88 == -1)
  {
    if (v8) {
      return ccchacha20poly1305_verify(qword_3AE720, *(void *)(a3 + 16), v8) == 0;
    }
  }

  else
  {
    uint64_t result = swift_once(&qword_3A7C88, sub_21F8B8);
    if (v8) {
      return ccchacha20poly1305_verify(qword_3AE720, *(void *)(a3 + 16), v8) == 0;
    }
  }

  __break(1u);
LABEL_10:
  __break(1u);
  return result;
}

uint64_t sub_21CED8(uint64_t a1, uint64_t a2)
{
  return sub_21C6A0(a1, a2, *(void *)(v2 + 16), **(void **)(v2 + 24), *(void *)(*(void *)(v2 + 24) + 8LL));
}

uint64_t sub_21CEFC()
{
  uint64_t result = sub_21399C(5064011LL, 0xE300000000000000LL);
  qword_3A8688 = result;
  unk_3A8690 = v1;
  return result;
}

uint64_t sub_21CF28@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, char *a8@<X7>, size_t *a9@<X8>, char *a10)
{
  uint64_t v16 = *a8;
  char v27 = *a8;
  char v17 = *a10;
  if (qword_3A7C80 != -1) {
    swift_once(&qword_3A7C80, sub_21CEFC);
  }
  uint64_t v32 = qword_3A8688;
  unint64_t v33 = qword_3A8690;
  uint64_t v18 = qword_280C28[v16];
  sub_1F83C0(qword_3A8688, qword_3A8690);
  sub_2308A8(v18, 2LL);
  uint64_t v20 = v19;
  unint64_t v22 = v21;
  Data.append(_:)(v19, v21);
  sub_1F86D4(v20, v22);
  __int128 v31 = xmmword_280350;
  Data.append(_:)(a2, a3);
  Data.append(_:)(a4, a5);
  if (a7 >> 60 != 15)
  {
    sub_1F83C0(a6, a7);
    Data.append(_:)(a6, a7);
    sub_215B4C(a6, a7);
  }

  __int128 v23 = v31;
  uint64_t v24 = v32;
  unint64_t v25 = v33;
  LOBYTE(v31) = v27;
  char v30 = v17;
  sub_1F83C0(v32, v33);
  sub_22CE10(a1, v23, *((uint64_t *)&v23 + 1), v32, v33, (unsigned __int8 *)&v31, &v30, a9);
  sub_1F86D4(v24, v25);
  sub_1F86D4(v23, *((unint64_t *)&v23 + 1));
  return sub_1F86D4(v24, v25);
}

unint64_t sub_21D0C8()
{
  return 0x20001200110010uLL >> (16 * *v0);
}

unint64_t sub_21D0E8()
{
  return 0x20008500610041uLL >> (16 * *v0);
}

uint64_t sub_21D108()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8698);
  return swift_initStaticObject(v0, &unk_3A7D88);
}

uint64_t sub_21D12C@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8698);
  uint64_t result = swift_initStaticObject(v2, &unk_3A7DB8);
  *a1 = result;
  return result;
}

unint64_t sub_21D168()
{
  unint64_t result = qword_3A86A0;
  if (!qword_3A86A0)
  {
    uint64_t v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_3A86A8);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_3A86A0);
  }

  return result;
}

unint64_t sub_21D1B8()
{
  unint64_t result = qword_3A86B0;
  if (!qword_3A86B0)
  {
    unint64_t result = swift_getWitnessTable(&unk_280C54, &_s3KEMON);
    atomic_store(result, (unint64_t *)&qword_3A86B0);
  }

  return result;
}

uint64_t _s3KEMOwet(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

uint64_t _s3KEMOwst(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFC) {
    return ((uint64_t (*)(void))((char *)&loc_21D2D8 + 4 * byte_280C4D[v4]))();
  }
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_21D30C + 4 * byte_280C48[v4]))();
}

uint64_t sub_21D30C(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_21D314(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x21D31CLL);
  }
  return result;
}

uint64_t sub_21D328(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x21D330LL);
  }
  *(_BYTE *)unint64_t result = a2 + 3;
  return result;
}

uint64_t sub_21D334(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_21D33C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *_s3KEMOMa()
{
  return &_s3KEMON;
}

uint64_t sub_21D358()
{
  return 64LL;
}

uint64_t sub_21D360()
{
  return 20LL;
}

uint64_t sub_21D368@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D5A4((uint64_t (*)(void))ccsha1_di, &qword_3A86B8, a1);
}

void *sub_21D37C(char *a1, uint64_t a2)
{
  return sub_21D48C(a1, a2, &qword_3A86B8);
}

void *sub_21D398(char *a1, uint64_t a2)
{
  return sub_21D3BC(a1, a2, &qword_3A87D8);
}

void *sub_21D3A4(char *a1, uint64_t a2)
{
  return sub_21D3BC(a1, a2, &qword_3A87E0);
}

void *sub_21D3B0(char *a1, uint64_t a2)
{
  return sub_21D3BC(a1, a2, &qword_3A87E8);
}

void *sub_21D3BC(char *a1, uint64_t a2, uint64_t *a3)
{
  if ((swift_isUniquelyReferenced_nonNull_native(*v3) & 1) == 0)
  {
    uint64_t v7 = *v3;
    uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(a3);
    uint64_t v9 = swift_allocObject(v8, 32LL, 7LL);
    uint64_t v10 = *(void *)(v7 + 16);
    *(void *)(v9 + 16) = v10;
    swift_retain(v7);
    size_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v10);
    unint64_t result = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
    if ((DigestSizeForDigestInfo & 0x8000000000000000LL) != 0)
    {
      __break(1u);
      return result;
    }

    uint64_t v13 = result;
    memmove(result, *(const void **)(v7 + 24), DigestSizeForDigestInfo);
    swift_release(v7);
    *(void *)(v9 + 24) = v13;
    uint64_t v14 = *v3;
    *int v3 = v9;
    swift_release(v14);
  }

  if (a1) {
    size_t v15 = a2 - (void)a1;
  }
  else {
    size_t v15 = 0LL;
  }
  return (void *)ccdigest_update(*(unint64_t **)(*v3 + 16), *(void **)(*v3 + 24), v15, a1);
}

void *sub_21D48C(char *a1, uint64_t a2, uint64_t *a3)
{
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v8 = *v3;
  if (isUniquelyReferenced_nonNull_native)
  {
    uint64_t v9 = *(unint64_t **)(v8 + 16);
    uint64_t v10 = *(void **)(v8 + 24);
  }

  else
  {
    uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(a3);
    uint64_t v12 = swift_allocObject(v11, 32LL, 7LL);
    uint64_t v9 = *(unint64_t **)(v8 + 16);
    *(void *)(v12 + 16) = v9;
    size_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo((uint64_t)v9);
    unint64_t result = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
    if ((DigestSizeForDigestInfo & 0x8000000000000000LL) != 0)
    {
      __break(1u);
      return result;
    }

    uint64_t v10 = result;
    memmove(result, *(const void **)(v8 + 24), DigestSizeForDigestInfo);
    swift_release(v8);
    *(void *)(v12 + 24) = v10;
    *int v3 = v12;
  }

  if (a1) {
    size_t v15 = a2 - (void)a1;
  }
  else {
    size_t v15 = 0LL;
  }
  return (void *)ccdigest_update(v9, v10, v15, a1);
}

uint64_t sub_21D554@<X0>(void *a1@<X8>)
{
  return sub_21D96C(a1);
}

uint64_t sub_21D574@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D66C((uint64_t (*)(void))ccsha1_di, &qword_3A86B8, a1);
}

uint64_t sub_21D588()
{
  return 16LL;
}

uint64_t sub_21D590@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D5A4((uint64_t (*)(void))ccmd5_di, &qword_3A86C0, a1);
}

uint64_t sub_21D5A4@<X0>(uint64_t (*a1)(void)@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = a1();
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(a2);
    uint64_t v8 = swift_allocObject(v7, 32LL, 7LL);
    uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v6);
    uint64_t v10 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
    uint64_t result = ccdigest_init(v6, v10);
    *(void *)(v8 + 16) = v6;
    *(void *)(v8 + 24) = v10;
    *a3 = v8;
  }

  else
  {
    __break(1u);
  }

  return result;
}

void *sub_21D61C(char *a1, uint64_t a2)
{
  return sub_21D48C(a1, a2, &qword_3A86C0);
}

uint64_t sub_21D638@<X0>(void *a1@<X8>)
{
  return sub_21D8BC(a1);
}

uint64_t sub_21D658@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D66C((uint64_t (*)(void))ccmd5_di, &qword_3A86C0, a1);
}

uint64_t sub_21D66C@<X0>(uint64_t (*a1)(void)@<X2>, uint64_t *a2@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a1();
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(a2);
    uint64_t v8 = swift_allocObject(v7, 32LL, 7LL);
    uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v6);
    uint64_t v10 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
    uint64_t result = ccdigest_init(v6, v10);
    *(void *)(v8 + 16) = v6;
    *(void *)(v8 + 24) = v10;
    *a3 = v8;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t sub_21D6E4@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = static Array._allocateBufferUninitialized(minimumCapacity:)(32LL, &type metadata for UInt8);
  *(void *)(v3 + 16) = 32LL;
  *(_OWORD *)(v3 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  ccdigest_final(*(void *)(v1 + 16));
  if (*(void *)(v3 + 16) == 32LL)
  {
    __int128 v7 = *(_OWORD *)(v3 + 32);
    uint64_t v4 = *(void *)(v3 + 48);
    uint64_t v5 = *(void *)(v3 + 56);
    uint64_t result = swift_bridgeObjectRelease(v3);
    *(_OWORD *)a1 = v7;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v5;
  }

  else
  {
    uint64_t result = swift_bridgeObjectRelease(v3);
    __break(1u);
  }

  return result;
}

uint64_t sub_21D77C@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = static Array._allocateBufferUninitialized(minimumCapacity:)(48LL, &type metadata for UInt8);
  *(void *)(v3 + 16) = 48LL;
  *(_OWORD *)(v3 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  ccdigest_final(*(void *)(v1 + 16));
  if (*(void *)(v3 + 16) == 48LL)
  {
    __int128 v7 = *(_OWORD *)(v3 + 48);
    __int128 v8 = *(_OWORD *)(v3 + 32);
    uint64_t v4 = *(void *)(v3 + 64);
    uint64_t v5 = *(void *)(v3 + 72);
    uint64_t result = swift_bridgeObjectRelease(v3);
    *(_OWORD *)a1 = v8;
    *(_OWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 32) = v4;
    *(void *)(a1 + 40) = v5;
  }

  else
  {
    uint64_t result = swift_bridgeObjectRelease(v3);
    __break(1u);
  }

  return result;
}

uint64_t sub_21D81C@<X0>(_OWORD *a1@<X8>)
{
  uint64_t v3 = static Array._allocateBufferUninitialized(minimumCapacity:)(64LL, &type metadata for UInt8);
  *(void *)(v3 + 16) = 64LL;
  *(_OWORD *)(v3 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  ccdigest_final(*(void *)(v1 + 16));
  sub_23FCBC((__int128 *)(v3 + 32), v3 + 32 + *(void *)(v3 + 16), (uint64_t)v8);
  uint64_t result = swift_bridgeObjectRelease(v3);
  if ((v9 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    __int128 v5 = v8[1];
    __int128 v6 = v8[2];
    __int128 v7 = v8[3];
    *a1 = v8[0];
    a1[1] = v5;
    a1[2] = v6;
    a1[3] = v7;
  }

  return result;
}

uint64_t sub_21D8BC@<X0>(void *a1@<X8>)
{
  uint64_t v3 = (void *)static Array._allocateBufferUninitialized(minimumCapacity:)(16LL, &type metadata for UInt8);
  void v3[2] = 16LL;
  void v3[5] = 0LL;
  v3[4] = 0LL;
  ccdigest_final(*(void *)(v1 + 16));
  if (v3[2] != 16LL)
  {
    swift_bridgeObjectRelease(v3);
    __break(1u);
  }

  uint64_t v4 = v3[4];
  uint64_t v5 = v3[5];
  uint64_t result = swift_bridgeObjectRelease(v3);
  *a1 = v4;
  a1[1] = v5;
  return result;
}

uint64_t sub_21D96C@<X0>(void *a1@<X8>)
{
  uint64_t v3 = static Array._allocateBufferUninitialized(minimumCapacity:)(20LL, &type metadata for UInt8);
  *(void *)(v3 + 16) = 20LL;
  *(void *)(v3 + 40) = 0LL;
  *(_DWORD *)(v3 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0;
  *(void *)(v3 + 32) = 0LL;
  ccdigest_final(*(void *)(v1 + 16));
  if (*(void *)(v3 + 16) == 20LL)
  {
    uint64_t v4 = *(void *)(v3 + 32);
    uint64_t v5 = *(void *)(v3 + 40);
    uint64_t v6 = *(unsigned int *)(v3 + 48);
    uint64_t result = swift_bridgeObjectRelease(v3);
    *a1 = v4;
    a1[1] = v5;
    a1[2] = v6;
  }

  else
  {
    uint64_t result = swift_bridgeObjectRelease(v3);
    __break(1u);
  }

  return result;
}

unint64_t sub_21DA00()
{
  unint64_t result = qword_3A86C8;
  if (!qword_3A86C8)
  {
    unint64_t result = swift_getWitnessTable(&unk_282A08, &_s10SHA1DigestVN);
    atomic_store(result, (unint64_t *)&qword_3A86C8);
  }

  return result;
}

unint64_t sub_21DA44(uint64_t a1)
{
  unint64_t result = sub_21DA68();
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t sub_21DA68()
{
  unint64_t result = qword_3A8708;
  if (!qword_3A8708)
  {
    unint64_t result = swift_getWitnessTable(&unk_280D28, &_s4SHA1VN);
    atomic_store(result, (unint64_t *)&qword_3A8708);
  }

  return result;
}

unint64_t sub_21DAB0()
{
  unint64_t result = qword_3A8710;
  if (!qword_3A8710)
  {
    unint64_t result = swift_getWitnessTable(&unk_282A24, &_s10SHA1DigestVN);
    atomic_store(result, (unint64_t *)&qword_3A8710);
  }

  return result;
}

unint64_t sub_21DAF8()
{
  unint64_t result = qword_3A8750;
  if (!qword_3A8750)
  {
    unint64_t result = swift_getWitnessTable(&unk_282B60, &_s9MD5DigestVN);
    atomic_store(result, (unint64_t *)&qword_3A8750);
  }

  return result;
}

unint64_t sub_21DB3C(uint64_t a1)
{
  unint64_t result = sub_21DB60();
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t sub_21DB60()
{
  unint64_t result = qword_3A8790;
  if (!qword_3A8790)
  {
    unint64_t result = swift_getWitnessTable(&unk_280D60, &_s3MD5VN);
    atomic_store(result, (unint64_t *)&qword_3A8790);
  }

  return result;
}

unint64_t sub_21DBA8()
{
  unint64_t result = qword_3A8798;
  if (!qword_3A8798)
  {
    unint64_t result = swift_getWitnessTable(&unk_282B7C, &_s9MD5DigestVN);
    atomic_store(result, (unint64_t *)&qword_3A8798);
  }

  return result;
}

ValueMetadata *_s4SHA1VMa()
{
  return &_s4SHA1VN;
}

ValueMetadata *_s3MD5VMa()
{
  return &_s3MD5VN;
}

uint64_t ccdigest_final(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 56))();
}

unint64_t sub_21DC14()
{
  return 0xFFFF000300020001LL >> (16 * *v0);
}

void sub_21DC30()
{
  __asm { BR              X10 }

uint64_t sub_21DC5C()
{
  return 32LL;
}

void sub_21DC6C()
{
}

uint64_t sub_21DCB8()
{
  if (*v0 <= 2u) {
    return 12LL;
  }
  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD00000000000002ALL,  0x8000000000305890LL,  "CryptoKit_Static/HPKE-AEAD.swift",  32LL,  2LL);
  __break(1u);
  return result;
}

uint64_t sub_21DD2C()
{
  if (*v0 <= 2u) {
    return 16LL;
  }
  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD000000000000028LL,  0x80000000003058C0LL,  "CryptoKit_Static/HPKE-AEAD.swift",  32LL,  2LL);
  __break(1u);
  return result;
}

void sub_21DDA0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5 = a4 >> 62;
  if (*v4 == 2) {
    __asm { BR              X9 }
  }

  __asm { BR              X9 }

void sub_21E048(uint64_t a1)
{
  if (BYTE6(v2) >= a1)
  {
    Data._Representation.subscript.getter();
    sub_1F86D4(v1, v2);
    JUMPOUT(0x21DF6CLL);
  }

  __break(1u);
  JUMPOUT(0x21E120LL);
}

uint64_t sub_21E184( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  __int128 v8 = v7;
  void v33[3] = a4;
  v33[4] = a7;
  v33[8] = *(void *)(a6 - 8);
  __chkstk_darwin(a1, a2);
  uint64_t v35 = (char *)v33 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v36 = v14;
  uint64_t v34 = *(void *)(*(void *)(v14 + 8) + 8LL);
  uint64_t v15 = *(void *)(v34 + 8);
  *(void *)&__int128 v37 = swift_getAssociatedTypeWitness( 0LL,  v15,  v16,  &protocol requirements base descriptor for Collection,  &associated type descriptor for Collection.SubSequence);
  v33[7] = *(void *)(v37 - 8);
  uint64_t v18 = __chkstk_darwin(v37, v17);
  v33[5] = (char *)v33 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = __chkstk_darwin(v18, v20);
  v33[6] = (char *)v33 - v22;
  uint64_t v24 = __chkstk_darwin(v21, v23);
  __chkstk_darwin(v24, v25);
  v33[2] = *a5;
  unsigned int v26 = *v8;
  uint64_t v27 = dispatch thunk of Collection.count.getter(a6, v15);
  if (v26 >= 3)
  {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD000000000000028LL,  0x80000000003058C0LL,  "CryptoKit_Static/HPKE-AEAD.swift",  32LL,  2LL);
    __break(1u);
    JUMPOUT(0x21E774LL);
  }

  if (v27 >= 16)
  {
    unint64_t v31 = a3 >> 62;
    if (v26 <= 1) {
      __asm { BR              X10 }
    }

    __asm { BR              X10 }
  }

  unint64_t v28 = sub_215864();
  uint64_t v29 = swift_allocError(&_s6ErrorsON, v28, 0LL, 0LL);
  *char v30 = 4;
  swift_willThrow(v29);
  return a1;
}

uint64_t sub_21E794()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A87F0);
  return swift_initStaticObject(v0, &unk_3A7DE8);
}

uint64_t sub_21E7B8@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A87F0);
  uint64_t result = swift_initStaticObject(v2, &unk_3A7E18);
  *a1 = result;
  return result;
}

unint64_t sub_21E7F4()
{
  unint64_t result = qword_3A87F8;
  if (!qword_3A87F8)
  {
    uint64_t v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_3A8800);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_3A87F8);
  }

  return result;
}

unint64_t sub_21E844()
{
  unint64_t result = qword_3A8808;
  if (!qword_3A8808)
  {
    unint64_t result = swift_getWitnessTable(&unk_280D98, &_s4AEADON);
    atomic_store(result, (unint64_t *)&qword_3A8808);
  }

  return result;
}

uint64_t _s4AEADOwst(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFC) {
    return ((uint64_t (*)(void))((char *)&loc_21E8D4 + 4 * byte_280D91[v4]))();
  }
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_21E908 + 4 * byte_280D8C[v4]))();
}

uint64_t sub_21E908(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_21E910(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x21E918LL);
  }
  return result;
}

uint64_t sub_21E924(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x21E92CLL);
  }
  *(_BYTE *)unint64_t result = a2 + 3;
  return result;
}

uint64_t sub_21E930(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_21E938(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *_s4AEADOMa()
{
  return &_s4AEADON;
}

uint64_t sub_21E954(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  return sub_238380(a1, a2, *v2);
}

uint64_t sub_21E970()
{
  return *(void *)v0;
}

void sub_21E978(void *a1@<X8>)
{
  *a1 = 128LL;
}

uint64_t sub_21E984@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  if (result < 1 || (result & 7) != 0) {
    __break(1u);
  }
  else {
    *a2 = result;
  }
  return result;
}

void sub_21E9A0(void *a1@<X8>)
{
  *a1 = 192LL;
}

void sub_21E9AC(void *a1@<X8>)
{
  *a1 = 256LL;
}

uint64_t sub_21E9B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = sub_23C1EC(a1, a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t *sub_21EA04@<X0>(uint64_t *a1@<X0>, uint64_t **a2@<X8>)
{
  uint64_t v3 = *a1;
  if ((unint64_t)(*a1 + 7) > 0xE)
  {
    if (v3 < 0) {
      uint64_t v3 = *a1 + 7;
    }
    uint64_t result = sub_23BE4C(v3 >> 3);
  }

  else
  {
    if (qword_3A7D18 != -1) {
      swift_once(&qword_3A7D18, sub_2384DC);
    }
    uint64_t result = (uint64_t *)swift_retain(off_3A8E78[0]);
  }

  *a2 = result;
  return result;
}

uint64_t sub_21EA7C()
{
  uint64_t v1 = *v0;
  uint64_t result = swift_beginAccess(*v0 + 16, v4, 0LL, 0LL);
  unint64_t v3 = *(void *)(v1 + 16);
  if (!(v3 >> 60)) {
    return 8 * v3;
  }
  __break(1u);
  return result;
}

uint64_t sub_21EAC8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  return sub_21E954(a1, a2);
}

uint64_t sub_21EADC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  swift_beginAccess(*a1 + 16, v5, 0LL, 0LL);
  return sub_21EB54((char *)(v2 + 32), v2 + 32 + *(void *)(v2 + 16), v3) & 1;
}

uint64_t sub_21EB3C(char *a1, uint64_t a2, uint64_t a3)
{
  return sub_21EB54(a1, a2, a3) & 1;
}

uint64_t sub_21EB54(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = a2 - (void)a1;
  if (a1) {
    uint64_t v7 = a2 - (void)a1;
  }
  else {
    uint64_t v7 = 0LL;
  }
  if (v7 != *(void *)(a3 + 16)) {
    return 0LL;
  }
  if (a1) {
    return cc_cmp_safe(result, a1, (char *)(a3 + 32)) == 0;
  }
  __break(1u);
  return result;
}

uint64_t sub_21EBE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return v4 & 1;
}

void sub_21EC2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __asm { BR              X10 }

BOOL sub_21EC8C()
{
  uint64_t v6 = v1;
  __int16 v7 = v3;
  char v8 = BYTE2(v3);
  char v9 = BYTE3(v3);
  char v10 = BYTE4(v3);
  if (v0) {
    uint64_t v4 = v2 - (void)v0;
  }
  else {
    uint64_t v4 = 0LL;
  }
  char v11 = BYTE5(v3);
  if (v4 != BYTE6(v3)) {
    return 0LL;
  }
  if (!v0)
  {
    __break(1u);
    JUMPOUT(0x21EEF0LL);
  }

  return cc_cmp_safe(v2 - (void)v0, v0, (char *)&v6) == 0;
}

ValueMetadata *type metadata accessor for SymmetricKeySize()
{
  return &type metadata for SymmetricKeySize;
}

ValueMetadata *type metadata accessor for SymmetricKey()
{
  return &type metadata for SymmetricKey;
}

uint64_t *sub_21EF38( uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v32 = a8;
  uint64_t v33 = a2;
  uint64_t v34 = a5;
  uint64_t v35 = a7;
  uint64_t v37 = a4;
  uint64_t v38 = type metadata accessor for Optional(0LL, a6);
  uint64_t v36 = *(void *)(v38 - 8);
  uint64_t v13 = __chkstk_darwin(v38, v12);
  uint64_t v15 = (char *)&v31 - v14;
  uint64_t v39 = *(void *)(a6 - 8);
  __chkstk_darwin(v13, v16);
  unint64_t v31 = (char *)&v31 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = *a1;
  uint64_t v19 = *a3;
  uint64_t v21 = *a3;
  unint64_t v22 = a3[1];
  unint64_t v20 = v22;
  if (v22 >> 60 == 15)
  {
    *(void *)((char *)&v42 + 6) = 0LL;
    *(void *)&__int128 v42 = 0LL;
    BYTE14(v42) = 12;
    LODWORD(v41) = 0;
    uint64_t result = ccrng(&v41);
    if (!result)
    {
      __break(1u);
      return result;
    }

    if ((_DWORD)v41) {
      __break(1u);
    }
    ccrng_generate_bridge((uint64_t (**)(void))result);
    uint64_t v21 = v42;
    unint64_t v22 = DWORD2(v42) | ((unint64_t)BYTE12(v42) << 32) | ((unint64_t)BYTE13(v42) << 40) | ((unint64_t)BYTE14(v42) << 48);
  }

  uint64_t v40 = v18;
  *(void *)&__int128 v42 = v21;
  *((void *)&v42 + 1) = v22;
  uint64_t v24 = type metadata accessor for CoreCryptoChaChaPolyImpl.Context();
  swift_allocObject(v24, 24LL, 7LL);
  sub_21B5BC(v19, v20);
  swift_retain(v18);
  sub_1F83C0(v21, v22);
  uint64_t v25 = sub_21FA54(&v40, (uint64_t *)&v42);
  if (v8) {
    return (uint64_t *)sub_1F86D4(v21, v22);
  }
  uint64_t v41 = v25;
  uint64_t v26 = v36;
  uint64_t v27 = v38;
  (*(void (**)(char *, uint64_t, uint64_t))(v36 + 16))(v15, v37, v38);
  uint64_t v28 = v39;
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v39 + 48))(v15, 1LL, a6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v26 + 8))(v15, v27);
  }

  else
  {
    uint64_t v29 = (uint64_t)v31;
    (*(void (**)(char *, char *, uint64_t))(v28 + 32))(v31, v15, a6);
    sub_21F8D4(v29, a6, v32);
    (*(void (**)(uint64_t, uint64_t))(v28 + 8))(v29, a6);
  }

  *(void *)&__int128 v42 = v21;
  *((void *)&v42 + 1) = v22;
  sub_1F83C0(v21, v22);
  sub_21F98C(v33, (uint64_t)&v42);
  uint64_t v30 = v41;
  swift_retain(v41);
  sub_2205A0();
  swift_release(v30);
  sub_1F86D4(v21, v22);
  swift_release(v30);
  return (uint64_t *)v42;
}

void sub_21F25C(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a5);
  uint64_t v10 = __chkstk_darwin(v8, v9);
  __chkstk_darwin(v10, v11);
  swift_retain(*a1);
  sub_1F83C0(a2, a3);
  sub_216CCC(12LL, a2, a3);
  __asm { BR              X10 }

uint64_t sub_21F358()
{
  if (BYTE6(v2) != 12LL)
  {
    unint64_t v22 = sub_21719C();
    uint64_t v23 = swift_allocError(&type metadata for CryptoKitError, v22, 0LL, 0LL);
    *(_DWORD *)uint64_t v24 = 1;
    *(_BYTE *)(v24 + 4) = 1;
    swift_willThrow(v23);
    sub_1F86D4(v5, v2);
    swift_unexpectedError(v23, "CryptoKit_Static/ChaChaPoly.swift", 33LL, 1LL, 139LL);
    __break(1u);
    JUMPOUT(0x21F85CLL);
  }

  sub_2144FC(v5, v2);
  *(void *)(v9 - 12_Block_object_dispose((const void *)(v11 - 96), 8) = v1;
  *(void *)(v9 - 112) = v10;
  *(void *)(v9 - 104) = v11;
  uint64_t v12 = type metadata accessor for CoreCryptoChaChaPolyImpl.Context();
  swift_allocObject(v12, 24LL, 7LL);
  uint64_t v13 = *(void *)(v9 - 160);
  uint64_t result = sub_21FA54((uint64_t *)(v9 - 128), (uint64_t *)(v9 - 112));
  if (!v13)
  {
    *(void *)(v9 - 152) = result;
    (*(void (**)(uint64_t, void, uint64_t))(v0 + 16))(v8, *(void *)(v9 - 168), v6);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v3 + 48))(v8, 1LL, v4) == 1)
    {
      (*(void (**)(uint64_t, uint64_t))(v0 + 8))(v8, v6);
    }

    else
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v3 + 32))(v7, v8, v4);
      sub_21F8D4(v7, v4, *(void *)(v9 - 192));
      (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v7, v4);
    }

    *(_OWORD *)(v9 - 112) = xmmword_280350;
    uint64_t v16 = *(void *)(v9 - 184);
    unint64_t v15 = *(void *)(v9 - 176);
    sub_1F83C0(v16, v15);
    sub_216838(12LL, v16, v15);
    sub_216AC4(16LL, *(void *)(v9 - 144), *(void *)(v9 - 136));
    uint64_t v17 = *(void *)(v9 - 128);
    unint64_t v18 = *(void *)(v9 - 120);
    uint64_t v19 = *(void *)(v9 - 152);
    if (!swift_isUniquelyReferenced_nonNull_native(v19))
    {
      uint64_t v20 = swift_allocObject(v12, 24LL, 7LL);
      swift_retain(v19);
      uint64_t v21 = (void *)swift_slowAlloc(256LL, -1LL);
      *(void *)(v20 + 16) = v21;
      memmove(v21, *(const void **)(v19 + 16), 0x100uLL);
      swift_release(v19);
      *(void *)(v9 - 152) = v20;
      swift_release(v19);
      uint64_t v19 = v20;
    }

    sub_21C544(v17, v18, v9 - 112);
    sub_1F86D4(v17, v18);
    sub_1F83C0(v16, v15);
    swift_retain(v19);
    sub_216650(16LL, v16, v15);
    __asm { BR              X10 }
  }

  return result;
}

void *sub_21F8B8()
{
  uint64_t result = ccchacha20poly1305_info();
  qword_3AE720 = (uint64_t)result;
  return result;
}

uint64_t sub_21F8D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((swift_isUniquelyReferenced_nonNull_native(*v3) & 1) == 0)
  {
    uint64_t v7 = *v3;
    uint64_t v8 = type metadata accessor for CoreCryptoChaChaPolyImpl.Context();
    uint64_t v9 = swift_allocObject(v8, 24LL, 7LL);
    swift_retain(v7);
    uint64_t v10 = (void *)swift_slowAlloc(256LL, -1LL);
    *(void *)(v9 + 16) = v10;
    memmove(v10, *(const void **)(v7 + 16), 0x100uLL);
    swift_release(v7);
    uint64_t v11 = *v3;
    *uint64_t v3 = v9;
    swift_release(v11);
  }

  return sub_21FE34(a1, a2, a3);
}

void sub_21F98C(uint64_t a1, uint64_t a2)
{
  if ((swift_isUniquelyReferenced_nonNull_native(*v2) & 1) == 0)
  {
    uint64_t v5 = *v2;
    uint64_t v6 = type metadata accessor for CoreCryptoChaChaPolyImpl.Context();
    uint64_t v7 = swift_allocObject(v6, 24LL, 7LL);
    swift_retain(v5);
    uint64_t v8 = (void *)swift_slowAlloc(256LL, -1LL);
    *(void *)(v7 + 16) = v8;
    memmove(v8, *(const void **)(v5 + 16), 0x100uLL);
    swift_release(v5);
    uint64_t v9 = *v2;
    uint64_t *v2 = v7;
    swift_release(v9);
  }

  sub_220114(a1, a2);
}

uint64_t sub_21FA54(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  swift_beginAccess(*a1 + 16, v19, 0LL, 0LL);
  unint64_t v7 = *(void *)(v4 + 16);
  if (v7 >> 60)
  {
    __break(1u);
LABEL_10:
    swift_once(&qword_3A7C88, sub_21F8B8);
    goto LABEL_4;
  }

  if (v7 != 32)
  {
    swift_release(v4);
    sub_1F86D4(v5, v6);
    unint64_t v14 = sub_21719C();
    uint64_t v15 = swift_allocError(&type metadata for CryptoKitError, v14, 0LL, 0LL);
    *(_DWORD *)uint64_t v16 = 0;
    *(_BYTE *)(v16 + 4) = 1;
    swift_willThrow(v15);
    uint64_t v17 = type metadata accessor for CoreCryptoChaChaPolyImpl.Context();
    swift_deallocPartialClassInstance(v2, v17, 24LL, 7LL);
    return v2;
  }

  uint64_t v8 = (_OWORD *)swift_slowAlloc(256LL, -1LL);
  *(void *)(v2 + 16) = v8;
  *uint64_t v8 = 0u;
  v8[1] = 0u;
  void v8[2] = 0u;
  void v8[3] = 0u;
  _OWORD v8[4] = 0u;
  void v8[5] = 0u;
  v8[6] = 0u;
  v8[7] = 0u;
  v8[8] = 0u;
  v8[9] = 0u;
  v8[10] = 0u;
  v8[11] = 0u;
  v8[12] = 0u;
  v8[13] = 0u;
  v8[14] = 0u;
  *(_OWORD *)((char *)v8 + 233) = 0u;
  uint64_t v3 = (_DWORD *)(v4 + 32);
  if (qword_3A7C88 != -1) {
    goto LABEL_10;
  }
LABEL_4:
  int v9 = ccchacha20poly1305_init(qword_3AE720, *(void *)(v2 + 16), v3);
  if (!v9)
  {
    swift_release(v4);
    __asm { BR              X10 }
  }

  int v10 = v9;
  unint64_t v11 = sub_21719C();
  uint64_t v12 = swift_allocError(&type metadata for CryptoKitError, v11, 0LL, 0LL);
  *(_DWORD *)uint64_t v13 = v10;
  *(_BYTE *)(v13 + 4) = 0;
  swift_willThrow(v12);
  sub_1F86D4(v5, v6);
  swift_release(v4);
  swift_release(v2);
  return v2;
}

uint64_t sub_21FE34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v8);
  int v10 = &v13[-v9];
  dispatch thunk of DataProtocol.regions.getter(a2, a3);
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v16 = v3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  Sequence.forEach(_:)( sub_221400,  v13,  AssociatedTypeWitness,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL));
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v7 + 8))(v10, AssociatedTypeWitness);
}

uint64_t sub_21FF48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  uint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL),  AssociatedTypeWitness,  &protocol requirements base descriptor for Sequence,  &associated type descriptor for Sequence.Element);
  uint64_t v10 = swift_getAssociatedConformanceWitness( a4,  a3,  v9,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions.Sequence.Element: ContiguousBytes);
  return dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_22141C,  a2,  (char *)&type metadata for () + 8,  v9,  v10);
}

uint64_t sub_22003C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (unsigned int *)result;
  if (qword_3A7C88 == -1)
  {
    if (result) {
      goto LABEL_3;
    }
LABEL_7:
    __break(1u);
    return result;
  }

  uint64_t result = swift_once(&qword_3A7C88, sub_21F8B8);
  if (!v5) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t result = ccchacha20poly1305_aad(qword_3AE720, *(void *)(a3 + 16), a2 - (void)v5, v5);
  if ((_DWORD)result)
  {
    int v6 = result;
    unint64_t v7 = sub_21719C();
    uint64_t v8 = swift_allocError(&type metadata for CryptoKitError, v7, 0LL, 0LL);
    *(_DWORD *)uint64_t v9 = v6;
    *(_BYTE *)(v9 + 4) = 0;
    return swift_willThrow(v8);
  }

  return result;
}

void sub_2200F0(uint64_t a1, uint64_t a2)
{
}

void sub_220114(uint64_t a1, uint64_t a2)
{
  __asm { BR              X12 }

void sub_220170()
{
  uint64_t v2 = dispatch thunk of Collection.count.getter(v1, *(void *)(*(void *)(*(void *)(v0 + 8) + 8LL) + 8LL));
  if (v2 < 0)
  {
    __break(1u);
    JUMPOUT(0x22021CLL);
  }

  uint64_t v3 = sub_217640(v2, 0);
  __chkstk_darwin(v3, v4);
  sub_220C4C();
}

uint64_t sub_220234( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = a5;
  uint64_t v26 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a8,  a7,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v15);
  uint64_t v17 = (char *)&v25 - v16;
  uint64_t v18 = sub_2169C8(a3, a1, a2);
  uint64_t v20 = v19 + v18;
  uint64_t v22 = v19 + v21;
  if (!v19)
  {
    uint64_t v22 = 0LL;
    uint64_t v20 = 0LL;
  }

  v33[0] = v20;
  v33[1] = v22;
  dispatch thunk of DataProtocol.regions.getter(a7, a8);
  uint64_t v28 = a7;
  uint64_t v29 = a8;
  uint64_t v30 = v33;
  uint64_t v31 = v25;
  uint64_t v32 = v26;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a8,  a7,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  Sequence.forEach(_:)( sub_2213C4,  v27,  AssociatedTypeWitness,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL));
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v17, AssociatedTypeWitness);
}

uint64_t sub_220394(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v13[2] = a2;
  v13[3] = a3;
  void v13[4] = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a6,  a5,  &protocol requirements base descriptor for DataProtocol,  &associated type descriptor for DataProtocol.Regions);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a5,  AssociatedTypeWitness,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions: BidirectionalCollection);
  uint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  *(void *)(*(void *)(AssociatedConformanceWitness + 8) + 8LL),  AssociatedTypeWitness,  &protocol requirements base descriptor for Sequence,  &associated type descriptor for Sequence.Element);
  uint64_t v11 = swift_getAssociatedConformanceWitness( a6,  a5,  v10,  &protocol requirements base descriptor for DataProtocol,  &associated conformance descriptor for DataProtocol.DataProtocol.Regions.Sequence.Element: ContiguousBytes);
  return dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( sub_2213E4,  v13,  (char *)&type metadata for () + 8,  v10,  v11);
}

uint64_t sub_22048C( uint64_t result, uint64_t a2, uint64_t *a3, uint64_t (*a4)(uint64_t, void, uint64_t, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v8 = result;
  uint64_t v9 = a2 - result;
  if (result) {
    uint64_t v10 = a2 - result;
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = *a3;
  if (*a3) {
    uint64_t v11 = a3[1] - v11;
  }
  if (v11 < v10)
  {
    __break(1u);
  }

  else if (qword_3A7C88 == -1)
  {
    if (result) {
      goto LABEL_9;
    }
LABEL_16:
    __break(1u);
    return result;
  }

  uint64_t result = swift_once(&qword_3A7C88, sub_21F8B8);
  if (!v8) {
    goto LABEL_16;
  }
LABEL_9:
  int v12 = a4(qword_3AE720, *(void *)(a5 + 16), v9, v8, *a3);
  if (v12)
  {
    int v13 = v12;
    unint64_t v14 = sub_21719C();
    uint64_t v15 = swift_allocError(&type metadata for CryptoKitError, v14, 0LL, 0LL);
    *(_DWORD *)uint64_t v16 = v13;
    *(_BYTE *)(v16 + 4) = 0;
    return swift_willThrow(v15);
  }

  else
  {
    uint64_t result = sub_2169C8(v9, *a3, a3[1]);
    uint64_t v18 = v17 + result;
    uint64_t v20 = v17 + v19;
    if (!v17)
    {
      uint64_t v20 = 0LL;
      uint64_t v18 = 0LL;
    }

    *a3 = v18;
    a3[1] = v20;
  }

  return result;
}

uint64_t sub_2205A0()
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  if (qword_3A7C88 != -1) {
    swift_once(&qword_3A7C88, sub_21F8B8);
  }
  int v1 = ccchacha20poly1305_finalize(qword_3AE720, *(void *)(v0 + 16), (uint64_t)v8);
  if (v1)
  {
    int v2 = v1;
    unint64_t v3 = sub_21719C();
    uint64_t v4 = swift_allocError(&type metadata for CryptoKitError, v3, 0LL, 0LL);
    *(_DWORD *)uint64_t v5 = v2;
    *(_BYTE *)(v5 + 4) = 0;
    return swift_willThrow(v4);
  }

  else
  {
    void v9[3] = &type metadata for UnsafeRawBufferPointer;
    v9[4] = &protocol witness table for UnsafeRawBufferPointer;
    v9[0] = v8;
    v9[1] = v9;
    unint64_t v7 = __swift_project_boxed_opaque_existential_1(v9, (uint64_t)&type metadata for UnsafeRawBufferPointer);
    Data._Representation.append(contentsOf:)(*v7, v7[1]);
    return __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

uint64_t sub_2206BC()
{
  int v1 = *(void **)(v0 + 16);
  memset_s(v1, 0x100uLL, 0, 0x100uLL);
  swift_slowDealloc(v1, -1LL, -1LL);
  return swift_deallocClassInstance(v0, 24LL, 7LL);
}

uint64_t type metadata accessor for CoreCryptoChaChaPolyImpl.Context()
{
  return objc_opt_self(&OBJC_CLASS____TtCV16CryptoKit_Static24CoreCryptoChaChaPolyImplP33_61F2DD69F8AAAEBCABFCD2910DA256947Context);
}

void sub_220728()
{
  __asm { BR              X11 }

void *sub_220788@<X0>(uint64_t a1@<X8>)
{
  void *(*v3)(void **__return_ptr, uint64_t *, char *);
  uint64_t v4;
  void *result;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  uint64_t v8 = v4;
  LOWORD(v9) = a1;
  BYTE2(v9) = BYTE2(a1);
  HIBYTE(v9) = BYTE3(a1);
  uint64_t v10 = BYTE4(a1);
  uint64_t v11 = BYTE5(a1);
  int v12 = BYTE6(a1);
  uint64_t result = v3(&v7, &v8, (char *)&v8 + BYTE6(a1));
  if (!v2) {
    uint64_t result = v7;
  }
  int v6 = v9 | ((unint64_t)v10 << 32) | ((unint64_t)v11 << 40) | ((unint64_t)v12 << 48);
  *int v1 = v8;
  v1[1] = v6;
  return result;
}

void sub_220A18()
{
  __asm { BR              X12 }

uint64_t sub_220A78@<X0>(uint64_t a1@<X8>)
{
  uint64_t v6 = v1;
  LOWORD(v7) = a1;
  BYTE2(v7) = BYTE2(a1);
  HIBYTE(v7) = BYTE3(a1);
  unsigned __int8 v8 = BYTE4(a1);
  unsigned __int8 v9 = BYTE5(a1);
  unsigned __int8 v10 = BYTE6(a1);
  uint64_t result = v2(&v6, (char *)&v6 + BYTE6(a1));
  unint64_t v5 = v7 | ((unint64_t)v8 << 32) | ((unint64_t)v9 << 40) | ((unint64_t)v10 << 48);
  *unint64_t v3 = v6;
  v3[1] = v5;
  return result;
}

void sub_220C4C()
{
  __asm { BR              X12 }

uint64_t sub_220CAC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v6 = v1;
  LOWORD(v7) = a1;
  BYTE2(v7) = BYTE2(a1);
  HIBYTE(v7) = BYTE3(a1);
  unsigned __int8 v8 = BYTE4(a1);
  unsigned __int8 v9 = BYTE5(a1);
  unsigned __int8 v10 = BYTE6(a1);
  uint64_t result = v2(&v6, (char *)&v6 + BYTE6(a1));
  unint64_t v5 = v7 | ((unint64_t)v8 << 32) | ((unint64_t)v9 << 40) | ((unint64_t)v10 << 48);
  *unint64_t v3 = v6;
  v3[1] = v5;
  return result;
}

void sub_220E80()
{
  __asm { BR              X11 }

void *sub_220EE0@<X0>(uint64_t a1@<X8>)
{
  void *(*v3)(void **__return_ptr, uint64_t *, char *);
  uint64_t v4;
  void *result;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  void *v12;
  unsigned int v7 = v4;
  LOWORD(v_Block_object_dispose((const void *)(v11 - 96), 8) = a1;
  BYTE2(v_Block_object_dispose((const void *)(v11 - 96), 8) = BYTE2(a1);
  HIBYTE(v_Block_object_dispose((const void *)(v11 - 96), 8) = BYTE3(a1);
  unsigned __int8 v9 = BYTE4(a1);
  unsigned __int8 v10 = BYTE5(a1);
  uint64_t v11 = BYTE6(a1);
  uint64_t result = v3(&v12, &v7, (char *)&v7 + BYTE6(a1));
  if (!v2) {
    uint64_t result = v12;
  }
  uint64_t v6 = v8 | ((unint64_t)v9 << 32) | ((unint64_t)v10 << 40) | ((unint64_t)v11 << 48);
  *uint64_t v1 = v7;
  v1[1] = v6;
  return result;
}

void sub_221178(void (*a1)(uint64_t, uint64_t))
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  if ((int)v4 < (int)v3)
  {
    __break(1u);
    goto LABEL_9;
  }

  uint64_t v5 = __DataStorage._bytes.getter();
  if (!v5)
  {
LABEL_10:
    __break(1u);
    return;
  }

  uint64_t v6 = v5;
  uint64_t v7 = __DataStorage._offset.getter();
  uint64_t v8 = v3 - v7;
  if (__OFSUB__(v3, v7))
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v9 = v4 - v3;
  uint64_t v10 = __DataStorage._length.getter();
  if (v10 >= v9) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = v10;
  }
  a1(v6 + v8, v6 + v8 + v11);
}

char *sub_221220(uint64_t a1, uint64_t a2, void *(*a3)(uint64_t *__return_ptr, char *, char *))
{
  uint64_t result = (char *)__DataStorage._bytes.getter();
  if (!result) {
    goto LABEL_12;
  }
  uint64_t v8 = result;
  uint64_t result = (char *)__DataStorage._offset.getter();
  uint64_t v9 = a1 - (void)result;
  if (__OFSUB__(a1, result))
  {
    __break(1u);
    goto LABEL_11;
  }

  BOOL v10 = __OFSUB__(a2, a1);
  uint64_t v11 = a2 - a1;
  if (v10)
  {
LABEL_11:
    __break(1u);
LABEL_12:
    __break(1u);
    return result;
  }

  uint64_t v12 = __DataStorage._length.getter();
  if (v12 >= v11) {
    uint64_t v13 = v11;
  }
  else {
    uint64_t v13 = v12;
  }
  uint64_t result = (char *)a3(&v14, &v8[v9], &v8[v9 + v13]);
  if (!v3) {
    return (char *)v14;
  }
  return result;
}

char *sub_2212CC(uint64_t a1, uint64_t a2, void *(*a3)(uint64_t *__return_ptr, char *, char *))
{
  uint64_t result = (char *)__DataStorage._bytes.getter();
  if (!result) {
    goto LABEL_12;
  }
  uint64_t v8 = result;
  uint64_t result = (char *)__DataStorage._offset.getter();
  uint64_t v9 = a1 - (void)result;
  if (__OFSUB__(a1, result))
  {
    __break(1u);
    goto LABEL_11;
  }

  BOOL v10 = __OFSUB__(a2, a1);
  uint64_t v11 = a2 - a1;
  if (v10)
  {
LABEL_11:
    __break(1u);
LABEL_12:
    __break(1u);
    return result;
  }

  uint64_t v12 = __DataStorage._length.getter();
  if (v12 >= v11) {
    uint64_t v13 = v11;
  }
  else {
    uint64_t v13 = v12;
  }
  uint64_t result = (char *)a3(&v14, &v8[v9], &v8[v9 + v13]);
  if (!v3) {
    return (char *)v14;
  }
  return result;
}

uint64_t sub_22137C(uint64_t a1, uint64_t a2)
{
  return Data._Representation.append(contentsOf:)(a1, a2);
}

uint64_t sub_2213A4(uint64_t a1, uint64_t a2)
{
  return sub_220234(a1, a2, v2[4], v2[5], v2[6], v2[7], v2[2], v2[3]);
}

uint64_t sub_2213C4(uint64_t a1)
{
  return sub_220394(a1, v1[4], v1[5], v1[6], v1[2], v1[3]);
}

uint64_t sub_2213E4(uint64_t a1, uint64_t a2)
{
  return sub_22048C( a1,  a2,  *(uint64_t **)(v2 + 16),  *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t))(v2 + 24),  *(void *)(v2 + 32));
}

uint64_t sub_221400(uint64_t a1)
{
  return sub_21FF48(a1, v1[4], v1[2], v1[3]);
}

uint64_t sub_22141C(uint64_t a1, uint64_t a2)
{
  return sub_22003C(a1, a2, v2);
}

uint64_t sub_221434(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = __DataStorage._bytes.getter();
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t result = __DataStorage._offset.getter();
    if (__OFSUB__(a1, result)) {
      goto LABEL_10;
    }
    uint64_t v8 = (__int32 *)(v6 + a1 - result);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  uint64_t result = __DataStorage._length.getter();
  if (qword_3A7C88 == -1)
  {
    if (v8) {
      return ccchacha20poly1305_setnonce(qword_3AE720, *(int32x4_t **)(a3 + 16), v8);
    }
  }

  else
  {
    uint64_t result = swift_once(&qword_3A7C88, sub_21F8B8);
    if (v8) {
      return ccchacha20poly1305_setnonce(qword_3AE720, *(int32x4_t **)(a3 + 16), v8);
    }
  }

  __break(1u);
LABEL_10:
  __break(1u);
  return result;
}

ValueMetadata *type metadata accessor for CoreCryptoChaChaPolyImpl()
{
  return &type metadata for CoreCryptoChaChaPolyImpl;
}

ValueMetadata *type metadata accessor for Insecure()
{
  return &type metadata for Insecure;
}

uint64_t sub_221500()
{
  return *v0 + 1;
}

uint64_t sub_22150C()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A88E8);
  return swift_initStaticObject(v0, &unk_3A7E48);
}

uint64_t sub_221530@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A88E8);
  uint64_t result = swift_initStaticObject(v2, &unk_3A7E78);
  *a1 = result;
  return result;
}

unint64_t sub_22156C()
{
  unint64_t result = qword_3A88F0;
  if (!qword_3A88F0)
  {
    uint64_t v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_3A88F8);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_3A88F0);
  }

  return result;
}

unint64_t sub_2215BC()
{
  unint64_t result = qword_3A8900;
  if (!qword_3A8900)
  {
    unint64_t result = swift_getWitnessTable(&unk_280F28, &_s3KDFON);
    atomic_store(result, (unint64_t *)&qword_3A8900);
  }

  return result;
}

uint64_t _s3KDFOwet(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

uint64_t _s3KDFOwst(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFD) {
    return ((uint64_t (*)(void))((char *)&loc_2216DC + 4 * byte_280F21[v4]))();
  }
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_221710 + 4 * asc_280F1C[v4]))();
}

uint64_t sub_221710(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_221718(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x221720LL);
  }
  return result;
}

uint64_t sub_22172C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x221734LL);
  }
  *(_BYTE *)unint64_t result = a2 + 2;
  return result;
}

uint64_t sub_221738(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_221740(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *_s3KDFOMa()
{
  return &_s3KDFON;
}

uint64_t sub_22175C@<X0>(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  if (v33 == 255) {
    goto LABEL_8;
  }
  v34[0] = v32[0];
  v34[1] = v32[1];
  void v34[2] = v32[2];
  unsigned __int8 v35 = v33;
  uint64_t result = sub_2221C4((unsigned __int8 *)v34, 2u);
  if (v2) {
    return result;
  }
  if (result != 1 || (sub_226854((uint64_t)v25), sub_222AE4((uint64_t)v25, (uint64_t)v28, &qword_3A8920), v29 == 255))
  {
LABEL_8:
    unint64_t v12 = sub_222964();
    uint64_t v13 = swift_allocError(&type metadata for CryptoKitASN1Error, v12, 0LL, 0LL);
    _BYTE *v14 = 3;
    return swift_willThrow(v13);
  }

  else
  {
    v30[0] = v28[0];
    v30[1] = v28[1];
    v30[2] = v28[2];
    unsigned __int8 v31 = v29;
    if (LOBYTE(v28[0]) == 4)
    {
      sub_222B28((uint64_t)v30 + 8, (uint64_t)v36);
      uint64_t result = sub_222B28((uint64_t)v36, (uint64_t)v37);
      if ((v38 & 1) != 0)
      {
        uint64_t v6 = v37[0];
        uint64_t v7 = v37[1];
        uint64_t v8 = v37[2];
        uint64_t v9 = v37[3];
        BOOL v10 = (void *)sub_225E74(a1, 0LL, 2);
        uint64_t v11 = sub_2261B8(a1, 1uLL, 2);
        uint64_t result = sub_222508(v6, v7, v8, v9, v10, v11, v18, v19, (uint64_t *)v26, v20);
        __int128 v21 = v26[5];
        *(_OWORD *)(a2 + 64) = v26[4];
        *(_OWORD *)(a2 + 80) = v21;
        *(void *)(a2 + 96) = v27;
        __int128 v22 = v26[1];
        *(_OWORD *)a2 = v26[0];
        *(_OWORD *)(a2 + 16) = v22;
        __int128 v23 = v26[3];
        *(_OWORD *)(a2 + 32) = v26[2];
        *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v23;
      }

      else
      {
        __break(1u);
      }
    }

    else
    {
      unint64_t v15 = sub_222964();
      uint64_t v16 = swift_allocError(&type metadata for CryptoKitASN1Error, v15, 0LL, 0LL);
      _BYTE *v17 = 1;
      swift_willThrow(v16);
      return sub_222A7C((uint64_t)v25);
    }
  }

  return result;
}

uint64_t sub_22199C@<X0>(void **a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *a1;
  if (qword_3A7CF8 != -1) {
    swift_once(&qword_3A7CF8, sub_232ECC);
  }
  if (sub_233100((void *)qword_3AE7A0, v5))
  {
    if (qword_3A7C90 != -1) {
      swift_once(&qword_3A7C90, sub_224284);
    }
    uint64_t v6 = &qword_3AE728;
LABEL_19:
    uint64_t v7 = *v6;
    *(void *)a3 = *v6;
    __int128 v8 = *(_OWORD *)(v6 + 1);
    *(_OWORD *)(a3 + _Block_object_dispose((const void *)(v11 - 96), 8) = v8;
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(v6 + 3);
    swift_unknownObjectRetain(v8);
    return swift_bridgeObjectRetain(v7);
  }

  if (qword_3A7D00 != -1) {
    swift_once(&qword_3A7D00, sub_232EFC);
  }
  if (sub_233100((void *)qword_3AE7A8, v5))
  {
    if (qword_3A7C98 != -1) {
      swift_once(&qword_3A7C98, sub_2243B0);
    }
    uint64_t v6 = &qword_3AE750;
    goto LABEL_19;
  }

  if (qword_3A7D08 != -1) {
    swift_once(&qword_3A7D08, sub_232F2C);
  }
  if (sub_233100((void *)qword_3AE7B0, v5))
  {
    if (qword_3A7CA0 != -1) {
      swift_once(&qword_3A7CA0, sub_2244DC);
    }
    uint64_t v6 = &qword_3AE778;
    goto LABEL_19;
  }

  unint64_t v10 = sub_222964();
  uint64_t v11 = swift_allocError(&type metadata for CryptoKitASN1Error, v10, 0LL, 0LL);
  _BYTE *v12 = 3;
  uint64_t result = swift_willThrow(v11);
  *a2 = v11;
  return result;
}

uint64_t sub_221B80(char **a1, uint64_t a2)
{
  uint64_t v4 = a1;
  *(void *)&v43[0] = 1LL;
  _OWORD v42[2] = v43;
  sub_22A5B0(2, a1, (uint64_t (*)(char **))sub_22230C, (uint64_t)v42);
  __int128 v5 = *(_OWORD *)(a2 + 56);
  v41[1] = *(_OWORD *)(a2 + 40);
  void v41[2] = v5;
  sub_22A5B0(4, v4, (uint64_t (*)(char **))sub_2224A8, (uint64_t)v41);
  uint64_t v6 = v2;
  sub_222AE4(a2, (uint64_t)v45, &qword_3A8908);
  sub_222AE4((uint64_t)v45, (uint64_t)v46, &qword_3A8908);
  uint64_t v7 = (void *)v46[0];
  if (v46[0])
  {
    char v38 = v4;
    uint64_t v8 = v46[1];
    uint64_t v49 = v46[2];
    unint64_t v39 = v46[4];
    uint64_t v40 = v46[3];
    v48[0] = v46[0];
    sub_2228B4(v45);
    sub_222914(v48);
    uint64_t v9 = qword_3A7C90;
    swift_unknownObjectRetain(v8);
    if (v9 != -1) {
      swift_once(&qword_3A7C90, sub_224284);
    }
    uint64_t v10 = unk_3AE730;
    uint64_t v12 = *((void *)&xmmword_3AE738 + 1);
    uint64_t v11 = xmmword_3AE738;
    unint64_t v13 = qword_3AE748;
    if (sub_233100((void *)qword_3AE728, v7))
    {
      if (v10)
      {
        if (v8)
        {
          char v14 = sub_229C74(v11, v12, v13, v49, v40, v39);
          sub_22293C(v48);
          swift_unknownObjectRelease(v8);
          if ((v14 & 1) != 0) {
            goto LABEL_31;
          }
LABEL_11:
          sub_222914(v48);
          uint64_t v15 = qword_3A7C98;
          swift_unknownObjectRetain(v8);
          if (v15 != -1) {
            swift_once(&qword_3A7C98, sub_2243B0);
          }
          uint64_t v16 = *(void *)algn_3AE758;
          uint64_t v18 = *((void *)&xmmword_3AE760 + 1);
          uint64_t v17 = xmmword_3AE760;
          unint64_t v19 = qword_3AE770;
          if (sub_233100((void *)qword_3AE750, v7))
          {
            if (v16)
            {
              if (v8)
              {
                char v20 = sub_229C74(v17, v18, v19, v49, v40, v39);
                sub_22293C(v48);
                swift_unknownObjectRelease(v8);
                if ((v20 & 1) != 0) {
                  goto LABEL_35;
                }
LABEL_20:
                sub_222914(v48);
                uint64_t v21 = qword_3A7CA0;
                swift_unknownObjectRetain(v8);
                if (v21 != -1) {
                  swift_once(&qword_3A7CA0, sub_2244DC);
                }
                uint64_t v22 = unk_3AE780;
                uint64_t v24 = *((void *)&xmmword_3AE788 + 1);
                uint64_t v23 = xmmword_3AE788;
                unint64_t v25 = qword_3AE798;
                if (sub_233100((void *)qword_3AE778, v7))
                {
                  if (v22)
                  {
                    if (v8)
                    {
                      char v26 = sub_229C74(v23, v24, v25, v49, v40, v39);
                      sub_22293C(v48);
                      swift_unknownObjectRelease(v8);
                      if ((v26 & 1) != 0) {
                        goto LABEL_39;
                      }
LABEL_29:
                      unint64_t v27 = sub_222964();
                      uint64_t v28 = swift_allocError(&type metadata for CryptoKitASN1Error, v27, 0LL, 0LL);
                      *unsigned __int8 v29 = 3;
                      swift_willThrow(v28);
                      sub_22293C(v48);
                      return swift_unknownObjectRelease(v8);
                    }
                  }

                  else if (!v8)
                  {
                    sub_22293C(v48);
LABEL_39:
                    if (qword_3A7D08 != -1) {
                      swift_once(&qword_3A7D08, sub_232F2C);
                    }
                    unsigned __int8 v31 = &qword_3AE7B0;
                    goto LABEL_42;
                  }
                }

                sub_22293C(v48);
                swift_unknownObjectRelease(v8);
                goto LABEL_29;
              }
            }

            else if (!v8)
            {
              sub_22293C(v48);
LABEL_35:
              if (qword_3A7D00 != -1) {
                swift_once(&qword_3A7D00, sub_232EFC);
              }
              unsigned __int8 v31 = &qword_3AE7A8;
LABEL_42:
              uint64_t v4 = v38;
              goto LABEL_43;
            }
          }

          sub_22293C(v48);
          swift_unknownObjectRelease(v8);
          goto LABEL_20;
        }
      }

      else if (!v8)
      {
        sub_22293C(v48);
LABEL_31:
        uint64_t v4 = v38;
        if (qword_3A7CF8 != -1) {
          swift_once(&qword_3A7CF8, sub_232ECC);
        }
        unsigned __int8 v31 = &qword_3AE7A0;
LABEL_43:
        uint64_t v32 = *v31;
        uint64_t v33 = swift_bridgeObjectRetain(*v31);
        *(void *)&v43[0] = v32;
        __chkstk_darwin(v33, v34);
        uint64_t v37 = v43;
        sub_22A5B0(160, v4, sub_2229A8, (uint64_t)v36);
        sub_22293C(v48);
        swift_bridgeObjectRelease(v32);
        uint64_t result = swift_unknownObjectRelease(v8);
        if (v6) {
          return result;
        }
        goto LABEL_44;
      }
    }

    sub_22293C(v48);
    swift_unknownObjectRelease(v8);
    goto LABEL_11;
  }

uint64_t sub_222060(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v5 = a4 >> 1;
  uint64_t v6 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }

  uint64_t v7 = result;
  if (v6 > 8)
  {
    unint64_t v8 = sub_222964();
    uint64_t v9 = swift_allocError(&type metadata for CryptoKitASN1Error, v8, 0LL, 0LL);
    *uint64_t v10 = 3;
    swift_willThrow(v9);
    swift_unknownObjectRelease(v7);
    return v4;
  }

  if ((unint64_t)(v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    uint64_t result = sub_2421AC(0LL, 8 * v6, 8LL);
    uint64_t v13 = *(void *)(result + 16);
    if (!v13)
    {
      swift_bridgeObjectRelease(result);
      swift_unknownObjectRelease(v7);
      return 0LL;
    }

    uint64_t v14 = 0LL;
    uint64_t v4 = 0LL;
    if (a3 <= v5) {
      uint64_t v15 = v5;
    }
    else {
      uint64_t v15 = a3;
    }
    unint64_t v16 = v15 - a3;
    while (v16 > v13 - 1)
    {
      unint64_t v18 = *(void *)(result + 8 * v14 + 32);
      if (v18 - 65 < 0xFFFFFFFFFFFFFF7FLL)
      {
        unint64_t v17 = 0LL;
      }

      else
      {
        unint64_t v19 = *(unsigned __int8 *)(a2 + a3 + v14);
        if ((v18 & 0x8000000000000000LL) != 0)
        {
          unint64_t v21 = v19 >> -(char)v18;
          if (v18 <= 0xFFFFFFFFFFFFFFC0LL) {
            unint64_t v17 = 0LL;
          }
          else {
            unint64_t v17 = v21;
          }
        }

        else
        {
          uint64_t v20 = v19 << v18;
          if (v18 >= 0x40) {
            unint64_t v17 = 0LL;
          }
          else {
            unint64_t v17 = v20;
          }
        }
      }

      ++v14;
      v4 |= v17;
      if (v13 == v14)
      {
        swift_bridgeObjectRelease(result);
        swift_unknownObjectRelease(v7);
        return v4;
      }
    }

    __break(1u);
    goto LABEL_25;
  }

uint64_t sub_2221C4(unsigned __int8 *a1, unsigned __int8 a2)
{
  if (*a1 != a2)
  {
    unint64_t v7 = sub_222964();
    uint64_t v8 = swift_allocError(&type metadata for CryptoKitASN1Error, v7, 0LL, 0LL);
    char v10 = 1;
LABEL_16:
    *uint64_t v9 = v10;
    swift_willThrow(v8);
    sub_222A18((uint64_t)a1);
    return v2;
  }

  sub_222B28((uint64_t)(a1 + 8), (uint64_t)v12);
  uint64_t result = sub_222B28((uint64_t)v12, (uint64_t)&v13);
  if ((v17 & 1) != 0)
  {
    int64_t v5 = v16 >> 1;
    if (__OFSUB__(v16 >> 1, v15))
    {
      __break(1u);
    }

    else
    {
      uint64_t result = v13;
      if (v15 == v5)
      {
LABEL_12:
        unint64_t v2 = sub_222324(v13, v14, v15, v16);
        sub_222A18((uint64_t)a1);
        return v2;
      }

      if (v15 < v5)
      {
        if (v15 + 1 == v5) {
          goto LABEL_12;
        }
        if (v15 + 1 < v5)
        {
          int v6 = *(char *)(v14 + v15 + 1);
          if (*(_BYTE *)(v14 + v15))
          {
            goto LABEL_15;
          }

          if ((v6 & 0x80000000) == 0)
          {
LABEL_15:
            unint64_t v11 = sub_222964();
            uint64_t v8 = swift_allocError(&type metadata for CryptoKitASN1Error, v11, 0LL, 0LL);
            char v10 = 4;
            goto LABEL_16;
          }

          goto LABEL_12;
        }

        goto LABEL_20;
      }
    }

    __break(1u);
LABEL_20:
    __break(1u);
  }

  __break(1u);
  return result;
}

char *sub_22230C(char **a1)
{
  return sub_2257FC(a1, *(unint64_t **)(v1 + 16));
}

unint64_t sub_222324(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = swift_unknownObjectRetain(a1);
  unint64_t result = sub_222060(v8, a2, a3, a4);
  if (!v4 && a4 >> 1 != a3)
  {
    if ((uint64_t)(a4 >> 1) <= a3)
    {
      __break(1u);
      return result;
    }

    if (*(char *)(a2 + a3) < 0)
    {
      unint64_t v10 = __clz(result);
      if (v10)
      {
        unint64_t v11 = 64 - v10;
        uint64_t v12 = 56LL;
        if (64 - v10 > 0x38) {
          uint64_t v12 = 64 - v10;
        }
        unint64_t v13 = (v10 + v12 - 57) >> 3;
        uint64_t v14 = (v13 + 2) & 0x3FFFFFFFFFFFFFFELL;
        uint64x2_t v15 = (uint64x2_t)vdupq_n_s64(v13);
        int64x2_t v16 = vdupq_n_s64(v11);
        int8x16_t v17 = (int8x16_t)result;
        v18.i64[0] = 255LL;
        v18.i64[1] = 255LL;
        int8x16_t v19 = vorrq_s8( (int8x16_t)vshlq_u64(v18, (uint64x2_t)vaddq_s64(v16, (int64x2_t)xmmword_280FE0)),  (int8x16_t)result);
        if (v14 == 2)
        {
          unint64_t v20 = 0LL;
LABEL_19:
          int8x16_t v25 = vbslq_s8( (int8x16_t)vcgtq_u64( (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v20), (int8x16_t)xmmword_281030),  v15),  v17,  v19);
          return (unint64_t)vorr_s8(*(int8x8_t *)v25.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
        }

        int8x16_t v21 = vorrq_s8((int8x16_t)vshlq_u64(v18, (uint64x2_t)vaddq_s64(v16, (int64x2_t)xmmword_280FF0)), v19);
        if (v14 == 4)
        {
          unint64_t v20 = 2LL;
LABEL_16:
          int8x16_t v17 = v19;
          int8x16_t v19 = v21;
          goto LABEL_19;
        }

        v22.i64[0] = 255LL;
        v22.i64[1] = 255LL;
        int8x16_t v19 = vorrq_s8((int8x16_t)vshlq_u64(v22, (uint64x2_t)vaddq_s64(v16, (int64x2_t)xmmword_281000)), v21);
        if (v14 == 6)
        {
          unint64_t v20 = 4LL;
        }

        else
        {
          int8x16_t v21 = vorrq_s8((int8x16_t)vshlq_u64(v22, (uint64x2_t)vaddq_s64(v16, (int64x2_t)xmmword_281010)), v19);
          if (v14 == 8)
          {
            unint64_t v20 = 6LL;
            goto LABEL_16;
          }

          uint64x2_t v23 = (uint64x2_t)vaddq_s64(v16, (int64x2_t)xmmword_281020);
          v24.i64[0] = 255LL;
          v24.i64[1] = 255LL;
          int8x16_t v19 = vorrq_s8((int8x16_t)vshlq_u64(v24, v23), v21);
          unint64_t v20 = 8LL;
        }

        int8x16_t v17 = v21;
        goto LABEL_19;
      }
    }
  }

  return result;
}

uint64_t sub_2224A8(uint64_t a1)
{
  return sub_232584(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 32), *(void *)(v1 + 40));
}

uint64_t sub_2224C4(char **a1)
{
  unint64_t v2 = *(_OWORD **)(v1 + 16);
  v4[1] = *v2;
  void v4[2] = v2[1];
  return sub_22A5B0(3, a1, sub_2229FC, (uint64_t)v4);
}

uint64_t sub_222508@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t *a9@<X8>, uint64_t a10)
{
  uint64_t v14 = a5;
  if (a5)
  {
    unsigned __int8 v31 = a5;
    swift_unknownObjectRetain(a6);
    swift_unknownObjectRetain(a1);
    sub_22199C(&v31, &v29, (uint64_t)v30);
    if (v10)
    {
      swift_bridgeObjectRelease(v14);
      swift_unknownObjectRelease(a1);
      swift_unknownObjectRelease(a6);
      sub_222A50(0LL, 0LL);
      swift_unknownObjectRelease(a6);
      return swift_unknownObjectRelease(a1);
    }

    uint64_t v24 = a3;
    uint64_t v25 = a4;
    uint64_t v26 = a7;
    uint64_t v27 = a8;
    swift_bridgeObjectRelease(v14);
    uint64_t v23 = v30[0];
    uint64_t v22 = v30[1];
    uint64_t v21 = v30[2];
    uint64_t v20 = v30[3];
    uint64_t v14 = (void *)v30[4];
  }

  else
  {
    uint64_t v24 = a3;
    uint64_t v25 = a4;
    uint64_t v26 = a7;
    uint64_t v27 = a8;
    swift_unknownObjectRetain(a6);
    swift_unknownObjectRetain(a1);
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    uint64_t v23 = 0LL;
  }

  sub_2228E4(v23, v22);
  sub_2228E4(v23, v22);
  sub_222A50(v23, v22);
  sub_222A50(v23, v22);
  swift_unknownObjectRelease(a6);
  uint64_t result = swift_unknownObjectRelease(a1);
  *a9 = v23;
  a9[1] = v22;
  a9[2] = v21;
  a9[3] = v20;
  a9[4] = (uint64_t)v14;
  a9[5] = a1;
  a9[6] = a2;
  a9[7] = v24;
  a9[8] = v25;
  a9[9] = a6;
  a9[10] = v26;
  a9[11] = v27;
  a9[12] = a10;
  return result;
}

uint64_t sub_2226E4@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 a2@<W1>, uint64_t a3@<X8>)
{
  if (*a1 != a2 || (a1[48] & 1) != 0)
  {
    unint64_t v6 = sub_222964();
    uint64_t v7 = swift_allocError(&type metadata for CryptoKitASN1Error, v6, 0LL, 0LL);
    *uint64_t v8 = 1;
    swift_willThrow(v7);
LABEL_4:
    sub_222A18((uint64_t)a1);
    return sub_222A50(0LL, 0LL);
  }

  uint64_t v10 = *((void *)a1 + 5);
  __int128 v11 = *(_OWORD *)(a1 + 24);
  v29[0] = *(_OWORD *)(a1 + 8);
  v29[1] = v11;
  uint64_t v30 = v10;
  swift_unknownObjectRetain_n(*(void *)&v29[0], 2LL);
  sub_22175C(v29, (uint64_t)v23);
  if (v3)
  {
    swift_unknownObjectRelease(*(void *)&v29[0]);
    sub_222A18((uint64_t)a1);
    goto LABEL_4;
  }

  sub_226854((uint64_t)v31);
  sub_222A7C((uint64_t)v31);
  sub_222AE4((uint64_t)v31, (uint64_t)v32, &qword_3A8920);
  if (v32[48] != 255)
  {
    unint64_t v12 = sub_222964();
    uint64_t v13 = swift_allocError(&type metadata for CryptoKitASN1Error, v12, 0LL, 0LL);
    _BYTE *v14 = 3;
    swift_willThrow(v13);
    sub_222A18((uint64_t)a1);
    uint64_t v15 = v25;
    uint64_t v16 = v27;
    sub_222A50(*(uint64_t *)&v23[0], *((uint64_t *)&v23[0] + 1));
    swift_unknownObjectRelease(v15);
    swift_unknownObjectRelease(v16);
    swift_unknownObjectRelease(*(void *)&v29[0]);
    goto LABEL_4;
  }

  swift_unknownObjectRelease(*(void *)&v29[0]);
  sub_222A18((uint64_t)a1);
  uint64_t result = sub_222A18((uint64_t)a1);
  uint64_t v17 = v24;
  __int128 v18 = v25;
  __int128 v19 = v23[1];
  __int128 v20 = v26;
  __int128 v21 = v27;
  __int128 v22 = v28;
  *(_OWORD *)a3 = v23[0];
  *(_OWORD *)(a3 + 16) = v19;
  *(void *)(a3 + 32) = v17;
  *(_OWORD *)(a3 + 40) = v18;
  *(_OWORD *)(a3 + 56) = v20;
  *(_OWORD *)(a3 + 72) = v21;
  *(_OWORD *)(a3 + 8_Block_object_dispose((const void *)(v11 - 96), 8) = v22;
  return result;
}

uint64_t *sub_2228B4(uint64_t *a1)
{
  return a1;
}

uint64_t sub_2228E4(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    swift_unknownObjectRetain(a2);
    return swift_bridgeObjectRetain(v2);
  }

  return result;
}

void *sub_222914(void *a1)
{
  return a1;
}

void *sub_22293C(void *a1)
{
  return a1;
}

unint64_t sub_222964()
{
  unint64_t result = qword_3A8918;
  if (!qword_3A8918)
  {
    unint64_t result = swift_getWitnessTable(&unk_280598, &type metadata for CryptoKitASN1Error);
    atomic_store(result, (unint64_t *)&qword_3A8918);
  }

  return result;
}

uint64_t sub_2229A8(char **a1)
{
  void v3[2] = **(void **)(v1 + 16);
  return sub_22A5B0(6, a1, (uint64_t (*)(char **))sub_2229E4, (uint64_t)v3);
}

uint64_t sub_2229E4(uint64_t a1)
{
  return sub_232C70(a1, *(void **)(v1 + 16));
}

uint64_t sub_2229FC(char **a1)
{
  return sub_231AC8(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 32), *(void *)(v1 + 40));
}

uint64_t sub_222A18(uint64_t a1)
{
  return a1;
}

uint64_t sub_222A50(uint64_t result, uint64_t a2)
{
  if (result)
  {
    swift_bridgeObjectRelease(result);
    return swift_unknownObjectRelease(a2);
  }

  return result;
}

uint64_t sub_222A7C(uint64_t a1)
{
  return a1;
}

uint64_t sub_222AB4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  if (a7 != 255) {
    return j__swift_unknownObjectRelease(a2, a3, a4, a5, a6, a7 & 1);
  }
  return result;
}

uint64_t sub_222AE4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32LL))(a2, a1, v5);
  return a2;
}

uint64_t sub_222B28(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_222B64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (result < 0)
  {
    __break(1u);
    goto LABEL_16;
  }

  int64_t v5 = a5 >> 1;
  unint64_t v6 = (a5 >> 1) - a4;
  if (__OFSUB__(a5 >> 1, a4))
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }

  uint64_t v7 = v6 - result;
  if (__OFSUB__(v6, result))
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

  if (v7 < 1)
  {
    uint64_t v7 = 0LL;
  }

  else if ((v6 & 0x8000000000000000LL) == 0)
  {
    int64_t v8 = a5 >> 1;
    if (v6 < v7)
    {
LABEL_10:
      if (v8 >= a4)
      {
        if (v5 >= a4)
        {
          if (v5 >= v8)
          {
            if ((v8 & 0x8000000000000000LL) == 0) {
              return a2;
            }
            goto LABEL_21;
          }

unint64_t sub_222BF8( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v_Block_object_dispose((const void *)(v11 - 96), 8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((result & 0xC) == 4LL << v8)
  {
    uint64_t result = sub_22378C(result, a3, a4);
    unint64_t v7 = result;
  }

  if ((a2 & 0xC) == v9)
  {
    uint64_t result = sub_22378C(a2, a3, a4);
    a2 = result;
    if ((a4 & 0x1000000000000000LL) == 0) {
      return (a2 >> 16) - (v7 >> 16);
    }
  }

  else if ((a4 & 0x1000000000000000LL) == 0)
  {
    return (a2 >> 16) - (v7 >> 16);
  }

  unint64_t v10 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    unint64_t v10 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v10 < v7 >> 16)
  {
    __break(1u);
  }

  else if (v10 >= a2 >> 16)
  {
    return String.UTF8View._foreignDistance(from:to:)(v7, a2, a3, a4);
  }

  __break(1u);
  return result;
}

uint64_t sub_222CE4(uint64_t a1, void *a2)
{
  Swift::String v7 = Data.base64EncodedString(options:)(0LL);
  object = v7._object;
  unint64_t countAndFlagsBits = ((unint64_t)v7._object >> 56) & 0xF;
  uint64_t v10 = 7LL;
  unint64_t v11 = String.subscript.getter(15LL, v10 | (countAndFlagsBits << 16), v7._countAndFlagsBits, v7._object);
  unint64_t v13 = v12;
  unint64_t v15 = v14;
  unint64_t v17 = v16;
  swift_bridgeObjectRelease(v7._object);
  unint64_t v18 = sub_222BF8(v11, v13, v15, v17);
  uint64_t v20 = v18 + 64;
  if (__OFADD__(v18, 64LL)) {
    goto LABEL_27;
  }
  uint64_t v61 = v15;
  if (v20 < 0) {
    uint64_t v20 = v18 + 127;
  }
  uint64_t v21 = v20 >> 6;
  if (v21 <= -2) {
    uint64_t v21 = -2LL;
  }
  __int128 v22 = sub_212458(0LL, v21 + 2, 0, (char *)_swiftEmptyArrayStorage);
  _StringGuts.grow(_:)(18LL);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRetain(a2);
  v59._unint64_t countAndFlagsBits = a1;
  v23._unint64_t countAndFlagsBits = a1;
  v23._object = a2;
  String.append(_:)(v23);
  swift_bridgeObjectRelease(a2);
  v24._unint64_t countAndFlagsBits = 0x2D2D2D2D2DLL;
  v24._object = (void *)0xE500000000000000LL;
  String.append(_:)(v24);
  unint64_t v15 = Substring.init(_:)(0x4745422D2D2D2D2DLL, 0xEB00000000204E49LL);
  uint64_t v4 = v25;
  a1 = v26;
  uint64_t v3 = v27;
  __int128 v19 = v22;
  unint64_t v2 = *((void *)v22 + 2);
  uint64_t v20 = *((void *)v22 + 3);
  object = (void *)(v2 + 1);
  v59._object = a2;
  while (1)
  {
    *((void *)v19 + 2) = object;
    __int128 v28 = v19;
    uint64_t v29 = &v19[32 * v2];
    *((void *)v29 + 4) = v15;
    *((void *)v29 + 5) = v4;
    *((void *)v29 + 6) = a1;
    *((void *)v29 + 7) = v3;
    swift_bridgeObjectRetain(v17);
    a1 = v61;
    uint64_t v30 = Substring.distance(from:to:)(v11, v13, v11, v13, v61, v17);
    swift_bridgeObjectRelease(v17);
    if (v30 < 1) {
      break;
    }
    while (1)
    {
      swift_bridgeObjectRetain(v17);
      object = (void *)Substring.index(_:offsetBy:limitedBy:)(v11, 64LL, v13, v11, v13, a1, v17);
      char v32 = v31;
      swift_bridgeObjectRelease(v17);
      unint64_t v15 = (v32 & 1) != 0 ? v13 : (unint64_t)object;
      unint64_t v2 = v15 >> 14;
      if (v15 >> 14 < v11 >> 14) {
        break;
      }
      swift_bridgeObjectRetain(v17);
      uint64_t v61 = a1;
      uint64_t v3 = Substring.subscript.getter(v11, v15, v11, v13, a1, v17);
      uint64_t v4 = v33;
      a1 = v34;
      uint64_t v60 = v35;
      swift_bridgeObjectRelease(v17);
      __int128 v19 = v28;
      unint64_t v36 = *((void *)v28 + 2);
      unint64_t v37 = *((void *)v19 + 3);
      object = (void *)(v36 + 1);
      if (v36 >= v37 >> 1) {
        __int128 v19 = sub_212458((char *)(v37 > 1), v36 + 1, 1, v19);
      }
      *((void *)v19 + 2) = object;
      uint64_t v20 = (uint64_t)&v19[32 * v36];
      *(void *)(v20 + 32) = v3;
      *(void *)(v20 + 40) = v4;
      *(void *)(v20 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = a1;
      *(void *)(v20 + 56) = v60;
      if (v2 > v13 >> 14) {
        goto LABEL_26;
      }
      __int128 v28 = v19;
      swift_bridgeObjectRetain(v17);
      unint64_t v11 = Substring.subscript.getter(v15, v13, v11, v13, v61, v17);
      unint64_t v13 = v38;
      a1 = v39;
      uint64_t v3 = v40;
      swift_bridgeObjectRelease_n(v17, 2LL);
      swift_bridgeObjectRetain(v3);
      uint64_t v41 = Substring.distance(from:to:)(v11, v13, v11, v13, a1, v3);
      swift_bridgeObjectRelease(v3);
      unint64_t v17 = v3;
      if (v41 <= 0) {
        goto LABEL_22;
      }
    }

    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __int128 v19 = sub_212458((char *)((unint64_t)v20 > 1), (int64_t)object, 1, v19);
  }

  uint64_t v3 = v17;
LABEL_22:
  _StringGuts.grow(_:)(16LL);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRetain(v59._object);
  String.append(_:)(v59);
  swift_bridgeObjectRelease(v59._object);
  v42._unint64_t countAndFlagsBits = 0x2D2D2D2D2DLL;
  v42._object = (void *)0xE500000000000000LL;
  String.append(_:)(v42);
  uint64_t v43 = Substring.init(_:)(0x444E452D2D2D2D2DLL, 0xE900000000000020LL);
  uint64_t v45 = v44;
  uint64_t v47 = v46;
  uint64_t v49 = v48;
  unint64_t v51 = *((void *)v28 + 2);
  unint64_t v50 = *((void *)v28 + 3);
  if (v51 >= v50 >> 1) {
    __int128 v28 = sub_212458((char *)(v50 > 1), v51 + 1, 1, v28);
  }
  *((void *)v28 + 2) = v51 + 1;
  uint64_t v52 = &v28[32 * v51];
  *((void *)v52 + 4) = v43;
  *((void *)v52 + 5) = v45;
  *((void *)v52 + 6) = v47;
  *((void *)v52 + 7) = v49;
  uint64_t v53 = v28;
  uint64_t v54 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8928);
  uint64_t v55 = sub_2129F8(&qword_3A8930, &qword_3A8928, (uint64_t)&protocol conformance descriptor for [A]);
  unint64_t v56 = sub_223748();
  uint64_t v57 = Sequence<>.joined(separator:)(10LL, 0xE100000000000000LL, v54, v55, v56);
  swift_bridgeObjectRelease(v3);
  swift_bridgeObjectRelease(v53);
  return v57;
}

unint64_t sub_2231B4( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8)
{
  if (a6 >> 14 < a5 >> 14)
  {
    __break(1u);
LABEL_24:
    unint64_t result = String.UTF8View._foreignCount()();
    uint64_t v20 = result;
    if ((v8 & 0x1000000000000000LL) == 0) {
      goto LABEL_7;
    }
LABEL_25:
    unint64_t result = String.UTF8View._foreignCount()();
    uint64_t v21 = result;
    if ((v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_11;
    }
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
    return result;
  }

  unint64_t v8 = a4;
  unint64_t v10 = a3;
  unint64_t v9 = a2;
  unint64_t v11 = a1;
  unint64_t result = sub_223804(a5, a6, a5, a6, a7, a8);
  unint64_t v13 = result;
  unint64_t v14 = v17;
  unint64_t v15 = v18;
  uint64_t v12 = v19;
  if ((v9 & 0x1000000000000000LL) != 0) {
    goto LABEL_24;
  }
  if ((v9 & 0x2000000000000000LL) != 0) {
    uint64_t v20 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v20 = v11 & 0xFFFFFFFFFFFFLL;
  }
  if ((v8 & 0x1000000000000000LL) != 0) {
    goto LABEL_25;
  }
LABEL_7:
  if ((v8 & 0x2000000000000000LL) != 0) {
    uint64_t v21 = HIBYTE(v8) & 0xF;
  }
  else {
    uint64_t v21 = v10 & 0xFFFFFFFFFFFFLL;
  }
  if (v20 < 0) {
    goto LABEL_26;
  }
LABEL_11:
  swift_bridgeObjectRetain(v12);
  unint64_t result = Substring.UTF8View.index(_:offsetBy:limitedBy:)(v13, v20, v14, v13, v14, v15, v12);
  if ((v22 & 1) != 0) {
    unint64_t v23 = v14;
  }
  else {
    unint64_t v23 = result;
  }
  if (v23 >> 14 < v13 >> 14) {
    goto LABEL_27;
  }
  unint64_t v58 = v11;
  uint64_t v24 = sub_223804(v13, v23, v13, v14, v15, v12);
  uint64_t v56 = v25;
  unint64_t v57 = v24;
  unint64_t v55 = v26;
  unint64_t v28 = v27;
  swift_bridgeObjectRetain(v12);
  swift_bridgeObjectRetain(v28);
  unint64_t result = Substring.UTF8View.index(_:offsetBy:limitedBy:)(v13, v20, v14, v13, v14, v15, v12);
  if ((v29 & 1) != 0) {
    unint64_t result = v14;
  }
  if (v14 >> 14 < result >> 14) {
    goto LABEL_28;
  }
  unint64_t v54 = v10;
  unint64_t v30 = sub_223804(result, v14, v13, v14, v15, v12);
  unint64_t v32 = v31;
  unint64_t v34 = v33;
  unint64_t v36 = v35;
  swift_bridgeObjectRetain(v35);
  swift_bridgeObjectRelease_n(v12, 2LL);
  unint64_t v37 = sub_21874C(v21, v30, v32, v34, v36);
  uint64_t v52 = v38;
  unint64_t v53 = v37;
  unint64_t v51 = v39;
  unint64_t v41 = v40;
  unint64_t v42 = sub_218878(v21, v30, v32, v34, v36);
  uint64_t v44 = v43;
  uint64_t v46 = v45;
  uint64_t v48 = v47;
  swift_bridgeObjectRetain(v41);
  swift_bridgeObjectRetain_n(v48, 2LL);
  swift_bridgeObjectRelease(v36);
  swift_bridgeObjectRetain(v9);
  LOBYTE(v32) = sub_2234A8(v58, v9, v57, v56, v55, v28);
  swift_bridgeObjectRelease(v9);
  if ((v32 & 1) != 0
    && (swift_bridgeObjectRetain(v8),
        char v49 = sub_2234A8(v54, v8, v53, v52, v51, v41),
        swift_bridgeObjectRelease(v8),
        (v49 & 1) != 0))
  {
    uint64_t v50 = String.init(_:)(v42, v44, v46, v48);
    swift_bridgeObjectRelease(v28);
    swift_bridgeObjectRelease(v41);
  }

  else
  {
    swift_bridgeObjectRelease(v41);
    swift_bridgeObjectRelease(v48);
    swift_bridgeObjectRelease(v28);
    uint64_t v50 = 0LL;
  }

  swift_bridgeObjectRelease(v48);
  return v50;
}

unint64_t sub_2234A8( unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v9 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((a6 & 0x2000000000000000LL) != 0) {
    uint64_t v10 = HIBYTE(a6) & 0xF;
  }
  else {
    uint64_t v10 = a5 & 0xFFFFFFFFFFFFLL;
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v11 = HIBYTE(a2) & 0xF;
  }
  else {
    unint64_t v11 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v12 = 4LL << v9;
  uint64_t v30 = 4 * v11;
  uint64_t v13 = (a1 >> 59) & 1;
  if ((a2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v13) = 1;
  }
  uint64_t v14 = 4LL << v13;
  uint64_t v25 = a2 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v26 = v12;
  unint64_t v23 = v10;
  uint64_t v24 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
  swift_bridgeObjectRetain(a6);
  swift_bridgeObjectRetain(a2);
  unint64_t v15 = 15LL;
  unint64_t v27 = a3;
  while (1)
  {
    unint64_t v16 = a3 ^ a4;
    if ((a3 ^ a4) < 0x4000)
    {
      if (v30 != v15 >> 14)
      {
        char v17 = 0;
        goto LABEL_19;
      }

      uint64_t v22 = 1LL;
LABEL_43:
      swift_bridgeObjectRelease(a6);
      swift_bridgeObjectRelease(a2);
      return v22;
    }

    unint64_t result = Substring.UTF8View.subscript.getter(a3, v27, a4, a5, a6);
    char v17 = result;
    if ((a3 & 0xC) == v26)
    {
      unint64_t result = sub_22378C(a3, a5, a6);
      a3 = result;
      if ((a6 & 0x1000000000000000LL) == 0)
      {
LABEL_17:
        a3 = (a3 & 0xFFFFFFFFFFFF0000LL) + 65540;
        goto LABEL_18;
      }
    }

    else if ((a6 & 0x1000000000000000LL) == 0)
    {
      goto LABEL_17;
    }

    if (v23 <= a3 >> 16) {
      goto LABEL_46;
    }
    a3 = String.UTF8View._foreignIndex(after:)(a3, a5, a6);
LABEL_18:
    if (v30 == v15 >> 14)
    {
      uint64_t v22 = 0LL;
      goto LABEL_43;
    }

unint64_t sub_223748()
{
  unint64_t result = qword_3A8938;
  if (!qword_3A8938)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring);
    atomic_store(result, (unint64_t *)&qword_3A8938);
  }

  return result;
}

uint64_t sub_22378C(unint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = a1;
  unint64_t v6 = a1 >> 16;
  uint64_t v7 = (unsigned __int16)a1 >> 14;
  if ((a3 & 0x1000000000000000LL) == 0 || (a2 & 0x800000000000000LL) != 0)
  {
    uint64_t v13 = String.UTF16View.index(_:offsetBy:)(15LL, v6, a2);
    uint64_t v14 = v13 + (v7 << 16);
    unint64_t v15 = v13 & 0xFFFFFFFFFFFFFFFCLL | v5 & 3;
    unint64_t v16 = v14 & 0xFFFFFFFFFFFF0000LL;
    if (!v7) {
      unint64_t v16 = v15;
    }
    return v16 | 4;
  }

  else
  {
    uint64_t v8 = String.UTF8View._foreignIndex(_:offsetBy:)(15LL, v6);
    uint64_t v9 = v8 + (v7 << 16);
    unint64_t v10 = v8 & 0xFFFFFFFFFFFFFFFCLL | v5 & 3;
    unint64_t v11 = v9 & 0xFFFFFFFFFFFF0000LL;
    if (!v7) {
      unint64_t v11 = v10;
    }
    return v11 | 8;
  }

uint64_t sub_223804( uint64_t result, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  unint64_t v10 = a2;
  unint64_t v11 = result;
  uint64_t v12 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v12) = 1;
  }
  uint64_t v13 = 4LL << v12;
  if ((a2 & 0xC) == 4LL << v12)
  {
    unint64_t result = sub_22378C(a2, a5, a6);
    unint64_t v10 = result;
  }

  if ((v11 & 0xC) == v13)
  {
    unint64_t result = sub_22378C(v11, a5, a6);
    unint64_t v11 = result;
  }

  if (v10 >> 14 <= a4 >> 14 && v11 >> 14 >= a3 >> 14 && v10 >> 14 >= v11 >> 14) {
    return v11;
  }
  __break(1u);
  return result;
}

uint64_t sub_2238E0(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v4)
  {
    swift_bridgeObjectRelease(a2);
    uint64_t v8 = (char *)_swiftEmptyArrayStorage;
    unint64_t v2 = _swiftEmptyArrayStorage[2];
    if (!v2) {
      goto LABEL_49;
    }
    goto LABEL_36;
  }

  uint64_t v5 = a1;
  uint64_t v6 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v6 = 11LL;
  }
  uint64_t v86 = v6 | (v4 << 16);
  unint64_t v7 = 4 * v4;
  uint64_t v8 = (char *)_swiftEmptyArrayStorage;
  unint64_t v9 = 15LL;
  unint64_t v10 = 15LL;
  unint64_t v11 = 15LL;
  unint64_t v93 = 4 * v4;
  do
  {
    while (1)
    {
      uint64_t v13 = String.subscript.getter(v9, v5, a2);
      unint64_t v15 = v14;
      if ((v14 & 0x2000000000000000LL) != 0) {
        uint64_t v16 = HIBYTE(v14) & 0xF;
      }
      else {
        uint64_t v16 = v13 & 0xFFFFFFFFFFFFLL;
      }
      if (!v16)
      {
        __break(1u);
LABEL_86:
        __break(1u);
LABEL_87:
        __break(1u);
        goto LABEL_88;
      }

      if ((v14 & 0x1000000000000000LL) != 0)
      {
        uint64_t v18 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)(0LL, v13, v14);
      }

      else
      {
        if ((v14 & 0x2000000000000000LL) != 0)
        {
          uint64_t v89 = v13;
          uint64_t v90 = v14 & 0xFFFFFFFFFFFFFFLL;
          char v17 = &v89;
        }

        else
        {
          char v17 = (uint64_t *)((v13 & 0x1000000000000000LL) != 0
                          ? (v14 & 0xFFFFFFFFFFFFFFFLL) + 32
                          : _StringObject.sharedUTF8.getter(v13, v14));
        }

        uint64_t v18 = _decodeScalar(_:startingAt:)(v17);
      }

      unint64_t v2 = v18;
      swift_bridgeObjectRelease(v15);
      if (v10 >> 14 != v9 >> 14)
      {
        if (v9 >> 14 < v10 >> 14) {
          goto LABEL_86;
        }
        uint64_t v19 = String.subscript.getter(v10, v9, v5, a2);
        uint64_t v21 = v20;
        uint64_t v23 = v22;
        unint64_t v2 = v24;
        if ((swift_isUniquelyReferenced_nonNull_native(v8) & 1) == 0) {
          uint64_t v8 = sub_212458(0LL, *((void *)v8 + 2) + 1LL, 1, v8);
        }
        unint64_t v26 = *((void *)v8 + 2);
        unint64_t v25 = *((void *)v8 + 3);
        unint64_t v27 = v8;
        if (v26 >= v25 >> 1) {
          unint64_t v27 = sub_212458((char *)(v25 > 1), v26 + 1, 1, v8);
        }
        *((void *)v27 + 2) = v26 + 1;
        uint64_t v8 = v27;
        uint64_t v12 = &v27[32 * v26];
        *((void *)v12 + 4) = v19;
        *((void *)v12 + 5) = v21;
        *((void *)v12 + 6) = v23;
        *((void *)v12 + 7) = v2;
        unint64_t v7 = v93;
      }

      unint64_t v9 = String.index(after:)(v9, v5, a2);
      unint64_t v10 = v9;
      unint64_t v11 = v9;
      if (v7 == v9 >> 14) {
        goto LABEL_32;
      }
    }

    unint64_t v9 = String.index(after:)(v9, v5, a2);
  }

  while (v7 != v9 >> 14);
LABEL_32:
  if (v7 != v10 >> 14)
  {
    if (v7 >= v11 >> 14)
    {
      uint64_t v5 = String.subscript.getter(v11, v86, v5, a2);
      unint64_t v2 = v47;
      unint64_t v9 = v48;
      unint64_t v10 = v49;
      swift_bridgeObjectRelease(a2);
      if ((swift_isUniquelyReferenced_nonNull_native(v8) & 1) != 0)
      {
LABEL_46:
        unint64_t v51 = *((void *)v8 + 2);
        unint64_t v50 = *((void *)v8 + 3);
        uint64_t v52 = v8;
        if (v51 >= v50 >> 1) {
          uint64_t v52 = sub_212458((char *)(v50 > 1), v51 + 1, 1, v8);
        }
        *((void *)v52 + 2) = v51 + 1;
        uint64_t v8 = v52;
        unint64_t v53 = &v52[32 * v51];
        *((void *)v53 + 4) = v5;
        *((void *)v53 + 5) = v2;
        *((void *)v53 + 6) = v9;
        *((void *)v53 + 7) = v10;
        unint64_t v2 = *((void *)v52 + 2);
        if (v2) {
          goto LABEL_36;
        }
LABEL_49:
        unint64_t v54 = sub_222964();
        uint64_t v55 = swift_allocError(&type metadata for CryptoKitASN1Error, v54, 0LL, 0LL);
        uint64_t v34 = (uint64_t)v8;
        goto LABEL_54;
      }

LABEL_72:
      ++v66;
      v8 += 32;
    }

    while (v5 != v66);
  }

  unint64_t v9 = v88;
  swift_unknownObjectRetain_n(v88, 2LL);
  uint64_t result = swift_unknownObjectRelease(v64);
  if (v85 == v84)
  {
LABEL_91:
    __break(1u);
LABEL_92:
    __break(1u);
LABEL_93:
    __break(1u);
LABEL_94:
    __break(1u);
    return result;
  }

  if (v84 <= v85) {
    goto LABEL_92;
  }
  if ((uint64_t)sub_222BF8( *(void *)(v83 + 32 * v84 - 32),  *(void *)(v83 + 32 * v84 - 24),  *(void *)(v83 + 32 * v84 - 16),  *(void *)(v83 + 32 * v84 - 8)) > 64)
  {
    swift_unknownObjectRelease(v88);
    goto LABEL_82;
  }

  uint64_t v89 = v88;
  uint64_t v90 = v83;
  uint64_t v91 = v85;
  unint64_t v92 = v82;
  uint64_t v71 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8940);
  uint64_t v72 = sub_2129F8(&qword_3A8948, &qword_3A8940, (uint64_t)&protocol conformance descriptor for ArraySlice<A>);
  unint64_t v73 = sub_223748();
  uint64_t v74 = Sequence<>.joined(separator:)(0LL, 0xE000000000000000LL, v71, v72, v73);
  uint64_t v76 = v75;
  swift_unknownObjectRelease(v88);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  Data.init(base64Encoded:options:)(v74, v76, 0LL);
  unint64_t v78 = v77;
  swift_bridgeObjectRelease(v76);
  if (v78 >> 60 == 15) {
    goto LABEL_82;
  }
  swift_unknownObjectRelease(v88);
  return v93;
}

void sub_2240C8()
{
  uint64_t v1 = *v0;
  Swift::UInt v2 = *(void *)(*v0 + 16LL);
  Hasher._combine(_:)(v2);
  if (v2)
  {
    uint64_t v3 = (Swift::UInt *)(v1 + 32);
    do
    {
      Swift::UInt v4 = *v3++;
      Hasher._combine(_:)(v4);
      --v2;
    }

    while (v2);
  }

  if (!v0[1])
  {
    Hasher._combine(_:)(0);
    return;
  }

  uint64_t v5 = v0[3];
  unint64_t v6 = v0[4];
  uint64_t v7 = v0[2];
  Hasher._combine(_:)(1u);
  unint64_t v8 = v6 >> 1;
  if (__OFSUB__(v6 >> 1, v5))
  {
    __break(1u);
    goto LABEL_14;
  }

  Hasher._combine(_:)((v6 >> 1) - v5);
  BOOL v9 = __OFSUB__(v8, v5);
  uint64_t v10 = v8 - v5;
  if (!v10) {
    return;
  }
  if ((v10 < 0) ^ v9 | (v10 == 0))
  {
LABEL_14:
    __break(1u);
    return;
  }

  unint64_t v11 = (Swift::UInt8 *)(v7 + v5);
  do
  {
    Swift::UInt8 v12 = *v11++;
    Hasher._combine(_:)(v12);
    --v10;
  }

  while (v10);
}

Swift::Int sub_22417C()
{
  return Hasher._finalize()();
}

Swift::Int sub_2241BC()
{
  return Hasher._finalize()();
}

uint64_t sub_2241F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 24);
  unint64_t v9 = *(void *)(a2 + 32);
  if (sub_233100(*(void **)a1, *(void **)a2))
  {
    if (v2)
    {
      if (v6 && (sub_229C74(v3, v4, v5, v7, v8, v9) & 1) != 0) {
        return 1LL;
      }
    }

    else if (!v6)
    {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t sub_224284()
{
  if (qword_3A7D10 != -1) {
    swift_once(&qword_3A7D10, sub_232F5C);
  }
  uint64_t v0 = qword_3AE7B8;
  uint64_t v1 = qword_3A7CF8;
  swift_bridgeObjectRetain(qword_3AE7B8);
  if (v1 != -1) {
    swift_once(&qword_3A7CF8, sub_232ECC);
  }
  uint64_t v2 = qword_3AE7A0;
  swift_bridgeObjectRetain(qword_3AE7A0);
  uint64_t v8 = sub_2121E4(0LL, 1024LL, 0, (char *)_swiftEmptyArrayStorage);
  __chkstk_darwin(v8, v3);
  void v7[2] = v2;
  sub_22A5B0(6, &v8, (uint64_t (*)(char **))sub_224AEC, (uint64_t)v7);
  uint64_t v4 = v8;
  uint64_t v5 = *((void *)v8 + 2);
  uint64_t result = swift_bridgeObjectRelease(v2);
  qword_3AE728 = v0;
  unk_3AE730 = v4;
  xmmword_3AE738 = (unint64_t)(v4 + 32);
  qword_3AE748 = (2 * v5) | 1;
  return result;
}

uint64_t sub_2243B0()
{
  if (qword_3A7D10 != -1) {
    swift_once(&qword_3A7D10, sub_232F5C);
  }
  uint64_t v0 = qword_3AE7B8;
  uint64_t v1 = qword_3A7D00;
  swift_bridgeObjectRetain(qword_3AE7B8);
  if (v1 != -1) {
    swift_once(&qword_3A7D00, sub_232EFC);
  }
  uint64_t v2 = qword_3AE7A8;
  swift_bridgeObjectRetain(qword_3AE7A8);
  uint64_t v8 = sub_2121E4(0LL, 1024LL, 0, (char *)_swiftEmptyArrayStorage);
  __chkstk_darwin(v8, v3);
  void v7[2] = v2;
  sub_22A5B0(6, &v8, (uint64_t (*)(char **))sub_224AEC, (uint64_t)v7);
  uint64_t v4 = v8;
  uint64_t v5 = *((void *)v8 + 2);
  uint64_t result = swift_bridgeObjectRelease(v2);
  qword_3AE750 = v0;
  *(void *)algn_3AE758 = v4;
  xmmword_3AE760 = (unint64_t)(v4 + 32);
  qword_3AE770 = (2 * v5) | 1;
  return result;
}

uint64_t sub_2244DC()
{
  if (qword_3A7D10 != -1) {
    swift_once(&qword_3A7D10, sub_232F5C);
  }
  uint64_t v0 = qword_3AE7B8;
  uint64_t v1 = qword_3A7D08;
  swift_bridgeObjectRetain(qword_3AE7B8);
  if (v1 != -1) {
    swift_once(&qword_3A7D08, sub_232F2C);
  }
  uint64_t v2 = qword_3AE7B0;
  swift_bridgeObjectRetain(qword_3AE7B0);
  uint64_t v8 = sub_2121E4(0LL, 1024LL, 0, (char *)_swiftEmptyArrayStorage);
  __chkstk_darwin(v8, v3);
  void v7[2] = v2;
  sub_22A5B0(6, &v8, (uint64_t (*)(char **))sub_2229E4, (uint64_t)v7);
  uint64_t v4 = v8;
  uint64_t v5 = *((void *)v8 + 2);
  uint64_t result = swift_bridgeObjectRelease(v2);
  qword_3AE778 = v0;
  unk_3AE780 = v4;
  xmmword_3AE788 = (unint64_t)(v4 + 32);
  qword_3AE798 = (2 * v5) | 1;
  return result;
}

uint64_t sub_224608@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 a2@<W1>, char **a3@<X8>)
{
  if (*a1 != a2 || (a1[48] & 1) != 0)
  {
    unint64_t v6 = sub_222964();
    uint64_t v7 = swift_allocError(&type metadata for CryptoKitASN1Error, v6, 0LL, 0LL);
    *uint64_t v8 = 1;
    swift_willThrow(v7);
    return sub_222A18((uint64_t)a1);
  }

  __int128 v29 = *(_OWORD *)(a1 + 8);
  swift_unknownObjectRetain_n(v29, 2LL);
  sub_224B00(0x30u, &v30);
  if (v3)
  {
LABEL_9:
    swift_unknownObjectRelease(v29);
    sub_222A18((uint64_t)a1);
    return sub_222A18((uint64_t)a1);
  }

  unint64_t v9 = v30;
  uint64_t v41 = (char *)v31[0];
  uint64_t v10 = (char *)v31[1];
  unint64_t v11 = (char *)v31[2];
  Swift::UInt8 v12 = (char *)v31[3];
  sub_226854((uint64_t)v32);
  sub_222AE4((uint64_t)v32, (uint64_t)v35, &qword_3A8920);
  if (v36 == 255)
  {
    unint64_t v21 = sub_222964();
    uint64_t v22 = swift_allocError(&type metadata for CryptoKitASN1Error, v21, 0LL, 0LL);
    _BYTE *v23 = 3;
    swift_willThrow(v22);
    uint64_t v40 = v30;
    sub_22293C(&v40);
    sub_222AE4((uint64_t)v31, (uint64_t)v39, &qword_3A8950);
    sub_22489C(v39);
    goto LABEL_9;
  }

  v37[0] = v35[0];
  v37[1] = v35[1];
  v37[2] = v35[2];
  unsigned __int8 v38 = v36;
  uint64_t v13 = sub_231D50((unsigned __int8 *)v37, 3u);
  unint64_t v26 = v15;
  unint64_t v27 = v14;
  unint64_t v28 = v16;
  uint64_t v17 = v13;
  sub_226854((uint64_t)v33);
  sub_222A7C((uint64_t)v33);
  sub_222AE4((uint64_t)v33, (uint64_t)v34, &qword_3A8920);
  if (v34[48] != 255)
  {
    unint64_t v18 = sub_222964();
    uint64_t v19 = swift_allocError(&type metadata for CryptoKitASN1Error, v18, 0LL, 0LL);
    *uint64_t v20 = 3;
    swift_willThrow(v19);
    sub_222A18((uint64_t)a1);
    swift_unknownObjectRelease(v17);
    swift_bridgeObjectRelease(v9);
    swift_unknownObjectRelease(v41);
    swift_unknownObjectRelease(v29);
    return sub_222A18((uint64_t)a1);
  }

  swift_unknownObjectRelease(v29);
  sub_222A18((uint64_t)a1);
  uint64_t result = sub_222A18((uint64_t)a1);
  unint64_t v25 = v41;
  *a3 = v9;
  a3[1] = v25;
  a3[2] = v10;
  a3[3] = v11;
  a3[4] = v12;
  a3[5] = (char *)v17;
  a3[6] = v28;
  a3[7] = v27;
  a3[8] = v26;
  return result;
}

void *sub_22489C(void *a1)
{
  return a1;
}

uint64_t _s26RFC5480AlgorithmIdentifierVwxx(void *a1)
{
  return swift_unknownObjectRelease(a1[1]);
}

uint64_t _s26RFC5480AlgorithmIdentifierVwcp(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)a2 + 1);
  *(void *)(a1 + 32) = a2[4];
  swift_bridgeObjectRetain(v3);
  swift_unknownObjectRetain(v4);
  return a1;
}

uint64_t *_s26RFC5480AlgorithmIdentifierVwca(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  uint64_t v6 = a2[1];
  uint64_t v7 = a1[1];
  a1[1] = v6;
  swift_unknownObjectRetain(v6);
  swift_unknownObjectRelease(v7);
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  return a1;
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t _s26RFC5480AlgorithmIdentifierVwta(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  swift_unknownObjectRelease(v4);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  return a1;
}

uint64_t _s26RFC5480AlgorithmIdentifierVwet(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t _s26RFC5480AlgorithmIdentifierVwst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 40) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *_s26RFC5480AlgorithmIdentifierVMa()
{
  return &_s26RFC5480AlgorithmIdentifierVN;
}

unint64_t sub_224AA8()
{
  unint64_t result = qword_3A8958;
  if (!qword_3A8958)
  {
    unint64_t result = swift_getWitnessTable(&unk_28105C, &_s26RFC5480AlgorithmIdentifierVN);
    atomic_store(result, (unint64_t *)&qword_3A8958);
  }

  return result;
}

uint64_t sub_224AEC(uint64_t a1)
{
  return sub_2229E4(a1);
}

uint64_t sub_224B00@<X0>(unsigned __int8 a1@<W1>, char **a2@<X8>)
{
  if (v48 == 255)
  {
    unint64_t v8 = sub_222964();
    uint64_t v9 = swift_allocError(&type metadata for CryptoKitASN1Error, v8, 0LL, 0LL);
    *uint64_t v10 = 3;
    return swift_willThrow(v9);
  }

  v49[0] = v47[0];
  v49[1] = v47[1];
  v49[2] = v47[2];
  unsigned __int8 v50 = v48;
  if (LOBYTE(v47[0]) != a1
    || (sub_222B28((uint64_t)v49 + 8, (uint64_t)v51), sub_222B28((uint64_t)v51, (uint64_t)v59), (v61 & 1) != 0))
  {
    unint64_t v5 = sub_222964();
    uint64_t v6 = swift_allocError(&type metadata for CryptoKitASN1Error, v5, 0LL, 0LL);
    _BYTE *v7 = 1;
    swift_willThrow(v6);
    return sub_225B80( (uint64_t)v36,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  }

  __int128 v33 = v59[0];
  __int128 v34 = v59[1];
  uint64_t v35 = v60;
  sub_226854((uint64_t)v37);
  sub_222AE4((uint64_t)v37, (uint64_t)v43, &qword_3A8920);
  if (v44 == 255)
  {
    unint64_t v26 = sub_222964();
    swift_allocError(&type metadata for CryptoKitASN1Error, v26, 0LL, 0LL);
    _BYTE *v27 = 3;
    sub_225B80((uint64_t)v36, (void (*)(void, void, void, void, void, void, void))sub_225BBC);
    uint64_t v28 = sub_225B80( (uint64_t)v36,  (void (*)(void, void, void, void, void, void, void))sub_225BBC);
    swift_willThrow(v28);
    goto LABEL_11;
  }

  v45[0] = v43[0];
  v45[1] = v43[1];
  _OWORD v45[2] = v43[2];
  unsigned __int8 v46 = v44;
  sub_225B80((uint64_t)v36, (void (*)(void, void, void, void, void, void, void))sub_225BBC);
  sub_225B80((uint64_t)v36, (void (*)(void, void, void, void, void, void, void))sub_225BBC);
  unint64_t v14 = sub_23316C((char *)v45, 6, v12, v13);
  if (v2)
  {
LABEL_11:
    swift_unknownObjectRelease(v33);
    sub_225B80((uint64_t)v36, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
    return sub_225B80( (uint64_t)v36,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  }

  uint64_t v62 = v14;
  sub_226854((uint64_t)v38);
  char v15 = v38[0];
  uint64_t v16 = v38[1];
  uint64_t v17 = v38[2];
  uint64_t v18 = v38[3];
  uint64_t v19 = v38[4];
  uint64_t v20 = v38[5];
  char v21 = v39;
  sub_222AE4((uint64_t)v38, (uint64_t)v42, &qword_3A8920);
  if (v42[48] == 255)
  {
    uint64_t v22 = 0LL;
    uint64_t v23 = 0LL;
    uint64_t v25 = 0LL;
  }

  else
  {
    v52[0] = v15;
    uint64_t v53 = v16;
    uint64_t v54 = v17;
    uint64_t v55 = v18;
    uint64_t v56 = v19;
    uint64_t v57 = v20;
    char v58 = v21 & 1;
    unint64_t v32 = sub_2121E4(0LL, 1024LL, 0, (char *)_swiftEmptyArrayStorage);
    sub_225B80((uint64_t)v38, (void (*)(void, void, void, void, void, void, void))sub_225BBC);
    sub_22A5C4(v15, &v32, (uint64_t)v52);
    sub_225B80((uint64_t)v38, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
    uint64_t v22 = v32;
    uint64_t v23 = v32 + 32;
    uint64_t v24 = *((void *)v32 + 2);
    sub_225B80((uint64_t)v38, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
    uint64_t v25 = (2 * v24) | 1;
  }

  sub_226854((uint64_t)v40);
  sub_225B80((uint64_t)v40, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  sub_222AE4((uint64_t)v40, (uint64_t)v41, &qword_3A8920);
  if (v41[48] != 255)
  {
    unint64_t v29 = sub_222964();
    uint64_t v30 = swift_allocError(&type metadata for CryptoKitASN1Error, v29, 0LL, 0LL);
    _BYTE *v31 = 3;
    swift_willThrow(v30);
    sub_225B80((uint64_t)v36, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
    swift_bridgeObjectRelease(v62);
    swift_unknownObjectRelease(v22);
    swift_unknownObjectRelease(v33);
    return sub_225B80( (uint64_t)v36,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  }

  swift_unknownObjectRelease(v33);
  sub_225B80((uint64_t)v36, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  uint64_t result = sub_225B80( (uint64_t)v36,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  *a2 = v62;
  a2[1] = v22;
  a2[2] = v23;
  a2[3] = 0LL;
  a2[4] = (char *)v25;
  return result;
}

void *sub_224F18@<X0>(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  if (v60 != 255)
  {
    v61[0] = v59[0];
    v61[1] = v59[1];
    v61[2] = v59[2];
    unsigned __int8 v62 = v60;
    uint64_t result = (void *)sub_2221C4((unsigned __int8 *)v61, 2u);
    if (v2) {
      return result;
    }
    if (!result)
    {
      sub_224B00(0x30u, &v43);
      uint64_t v9 = v43;
      uint64_t v10 = v44;
      uint64_t v11 = v45;
      uint64_t v12 = v46;
      unint64_t v70 = v47;
      sub_226854((uint64_t)v48);
      sub_222AE4((uint64_t)v48, (uint64_t)v55, &qword_3A8920);
      if (v56 == 255)
      {
        unint64_t v17 = sub_222964();
        uint64_t v18 = swift_allocError(&type metadata for CryptoKitASN1Error, v17, 0LL, 0LL);
        _BYTE *v19 = 3;
        swift_willThrow(v18);
      }

      else
      {
        v57[0] = v55[0];
        v57[1] = v55[1];
        v57[2] = v55[2];
        unsigned __int8 v58 = v56;
        if (LOBYTE(v55[0]) == 4)
        {
          uint64_t v38 = v12;
          uint64_t v39 = v11;
          uint64_t v40 = v10;
          uint64_t v41 = v9;
          sub_222B28((uint64_t)v57 + 8, (uint64_t)v63);
          uint64_t result = (void *)sub_222B28((uint64_t)v63, (uint64_t)v68);
          if ((v69 & 1) == 0)
          {
            __break(1u);
            return result;
          }

          uint64_t v13 = v68[0];
          uint64_t v14 = v68[1];
          uint64_t v15 = v68[2];
          unint64_t v16 = v68[3];
          sub_226554(a1, 0LL, 2);
          sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_225BBC);
          sub_22AC40(v13, v14, v15, v16, (uint64_t)v49);
          sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
          sub_225BF0( (uint64_t)v49,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRetain);
          sub_2226E4(v49, 0x30u, (uint64_t)v50);
          uint64_t v24 = v50[0];
          uint64_t v25 = v50[1];
          unint64_t v26 = v50[2];
          unint64_t v27 = v50[3];
          uint64_t v28 = v50[4];
          __int128 v36 = v52;
          __int128 v37 = v51;
          __int128 v34 = v54;
          __int128 v35 = v53;
          if (!v50[0])
          {
            sub_225BF0( (uint64_t)v49,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
            uint64_t result = (void *)sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
LABEL_27:
            unint64_t v33 = v70;
            *(void *)a2 = v41;
            *(void *)(a2 + _Block_object_dispose((const void *)(v11 - 96), 8) = v40;
            *(void *)(a2 + 16) = v39;
            *(void *)(a2 + 24) = v38;
            *(void *)(a2 + 32) = v33;
            *(void *)(a2 + 40) = v24;
            *(void *)(a2 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v25;
            *(void *)(a2 + 56) = v26;
            *(void *)(a2 + 64) = v27;
            *(void *)(a2 + 72) = v28;
            *(_OWORD *)(a2 + 80) = v37;
            *(_OWORD *)(a2 + 96) = v36;
            *(_OWORD *)(a2 + 112) = v35;
            *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v11 - 96), 8) = v34;
            return result;
          }

          unint64_t v65 = v43;
          if (sub_233100(v50[0], v43))
          {
            if (v25)
            {
              if (v44)
              {
                char v29 = sub_229C74((uint64_t)v26, (uint64_t)v27, (unint64_t)v28, v45, v46, v47);
                swift_unknownObjectRetain(v25);
                swift_bridgeObjectRetain(v24);
                if ((v29 & 1) != 0)
                {
                  sub_225BF0( (uint64_t)v49,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
                  sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
                  swift_unknownObjectRelease(v25);
LABEL_26:
                  uint64_t result = (void *)swift_bridgeObjectRelease(v24);
                  goto LABEL_27;
                }

                goto LABEL_24;
              }
            }

            else if (!v44)
            {
              swift_bridgeObjectRetain(v24);
              sub_225BF0( (uint64_t)v49,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
              sub_225B80( (uint64_t)v48,  (void (*)(void, void, void, void, void, void, void))sub_222AB4);
              goto LABEL_26;
            }

            swift_bridgeObjectRetain(v24);
            swift_unknownObjectRetain(v25);
          }

          else
          {
            swift_unknownObjectRetain(v25);
            swift_bridgeObjectRetain(v24);
          }

uint64_t sub_2254AC(char **a1, uint64_t a2)
{
  unint64_t v17 = &v18;
  uint64_t v18 = 0LL;
  sub_22A5B0(2, a1, (uint64_t (*)(char **))sub_225814, (uint64_t)v16);
  __int128 v5 = *(_OWORD *)(a2 + 16);
  v21[0] = *(_OWORD *)a2;
  v21[1] = v5;
  uint64_t v22 = *(void *)(a2 + 32);
  uint64_t v24 = *(void *)&v21[0];
  sub_222AE4((uint64_t)v21 + 8, (uint64_t)v23, &qword_3A8950);
  sub_222914(&v24);
  sub_225830(v23);
  uint64_t result = sub_2276DC(48LL, a1, (char *)v21);
  if (!v2)
  {
    uint64_t v18 = sub_2121E4(0LL, 1024LL, 0, (char *)_swiftEmptyArrayStorage);
    __int128 v7 = *(_OWORD *)(a2 + 88);
    __int128 v8 = *(_OWORD *)(a2 + 120);
    void v19[4] = *(_OWORD *)(a2 + 104);
    v19[5] = v8;
    uint64_t v20 = *(void *)(a2 + 136);
    __int128 v9 = *(_OWORD *)(a2 + 56);
    v19[0] = *(_OWORD *)(a2 + 40);
    v19[1] = v9;
    void v19[2] = *(_OWORD *)(a2 + 72);
    v19[3] = v7;
    sub_225A54((uint64_t *)v19);
    sub_22ADD8(48, &v18, (char *)v19);
    uint64_t v10 = sub_225AA4((uint64_t *)v19);
    uint64_t v11 = v18;
    __chkstk_darwin(v10, v12);
    __int128 v15[2] = v11;
    v15[3] = v13;
    _OWORD v15[4] = 0LL;
    v15[5] = v14;
    sub_22A5B0(4, a1, (uint64_t (*)(char **))sub_2224A8, (uint64_t)v15);
    return swift_bridgeObjectRelease(v11);
  }

  return result;
}

char *sub_225640(char **a1, unint64_t a2)
{
  if (a2)
  {
    __int128 v3 = (char *)sub_2256F8(a2);
    return sub_232298(v3, v4, v5);
  }

  else
  {
    __int128 v7 = *a1;
    uint64_t result = (char *)swift_isUniquelyReferenced_nonNull_native(*a1);
    if ((result & 1) == 0)
    {
      uint64_t result = sub_2121E4(0LL, *((void *)v7 + 2) + 1LL, 1, v7);
      __int128 v7 = result;
    }

    unint64_t v9 = *((void *)v7 + 2);
    unint64_t v8 = *((void *)v7 + 3);
    if (v9 >= v8 >> 1)
    {
      uint64_t result = sub_2121E4((char *)(v8 > 1), v9 + 1, 1, v7);
      __int128 v7 = result;
    }

    *((void *)v7 + 2) = v9 + 1;
    v7[v9 + 32] = 0;
    *a1 = v7;
  }

  return result;
}

unint64_t sub_2256F8(unint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  unint64_t v2 = 71 - __clz(a1);
  uint64_t v3 = v2 >> 3;
  unint64_t result = sub_232834(v2 >> 3, v2 >> 3, 0LL, a1, v2);
  if (v3 >= 1) {
    uint64_t v6 = 1LL;
  }
  else {
    uint64_t v6 = v3;
  }
  uint64_t v7 = 8 * v3;
  char v8 = 16 - 8 * v3;
  unint64_t v9 = v3;
  while (1)
  {
    if (v9 < 2) {
      return v6;
    }
    unint64_t v15 = v9;
    uint64_t v10 = v7 - 8;
    if (v7 - 8 < 0) {
      unint64_t v11 = a1 << ((v8 - 8) & 0x38);
    }
    else {
      unint64_t v11 = a1 >> (v10 & 0x38);
    }
    unint64_t v9 = v15 - 1;
    if (v15 - 1 > v3) {
      break;
    }
    BOOL v12 = v7 < 16;
    unint64_t v13 = a1 >> ((v7 + 48) & 0x38);
    if (v12) {
      unint64_t v13 = a1 << (v8 & 0x38);
    }
    char v14 = result ^ v13;
    v8 += 8;
    uint64_t v7 = v10;
    if (v14 < 0) {
      return v15;
    }
  }

  __break(1u);
  return result;
}

char *sub_2257FC(char **a1, unint64_t *a2)
{
  return sub_225640(a1, *a2);
}

char *sub_225814(char **a1)
{
  return sub_225640(a1, **(void **)(v1 + 16));
}

void *sub_225830(void *a1)
{
  return a1;
}

uint64_t sub_225858@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 a2@<W1>, _OWORD *a3@<X8>)
{
  if (*a1 != a2 || (a1[48] & 1) != 0)
  {
    unint64_t v6 = sub_222964();
    uint64_t v7 = swift_allocError(&type metadata for CryptoKitASN1Error, v6, 0LL, 0LL);
    *char v8 = 1;
    swift_willThrow(v7);
    uint64_t v9 = (uint64_t)a1;
    return sub_225BF0( v9,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
  }

  uint64_t v10 = *((void *)a1 + 5);
  __int128 v11 = *(_OWORD *)(a1 + 24);
  v30[0] = *(_OWORD *)(a1 + 8);
  v30[1] = v11;
  uint64_t v31 = v10;
  swift_unknownObjectRetain_n(*(void *)&v30[0], 2LL);
  sub_224F18(v30, (uint64_t)&v21);
  if (v3)
  {
    swift_unknownObjectRelease(*(void *)&v30[0]);
    sub_225BF0( (uint64_t)a1,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
LABEL_8:
    uint64_t v9 = (uint64_t)a1;
    return sub_225BF0( v9,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
  }

  sub_226854((uint64_t)v32);
  sub_225B80((uint64_t)v32, (void (*)(void, void, void, void, void, void, void))sub_222AB4);
  sub_222AE4((uint64_t)v32, (uint64_t)v33, &qword_3A8920);
  if (v33[48] != 255)
  {
    unint64_t v12 = sub_222964();
    uint64_t v13 = swift_allocError(&type metadata for CryptoKitASN1Error, v12, 0LL, 0LL);
    _BYTE *v14 = 3;
    swift_willThrow(v13);
    sub_225BF0( (uint64_t)a1,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
    v20[6] = v27;
    v20[7] = v28;
    v20[8] = v29;
    v20[2] = v23;
    void v20[3] = v24;
    void v20[4] = v25;
    v20[5] = v26;
    v20[0] = v21;
    v20[1] = v22;
    sub_225AF4(v20);
    swift_unknownObjectRelease(*(void *)&v30[0]);
    goto LABEL_8;
  }

  swift_unknownObjectRelease(*(void *)&v30[0]);
  sub_225BF0( (uint64_t)a1,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
  uint64_t result = sub_225BF0( (uint64_t)a1,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
  __int128 v16 = v28;
  a3[6] = v27;
  a3[7] = v16;
  a3[8] = v29;
  __int128 v17 = v24;
  a3[2] = v23;
  a3[3] = v17;
  __int128 v18 = v26;
  a3[4] = v25;
  a3[5] = v18;
  __int128 v19 = v22;
  *a3 = v21;
  a3[1] = v19;
  return result;
}

uint64_t *sub_225A54(uint64_t *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[9];
  sub_2228E4(*a1, a1[1]);
  swift_unknownObjectRetain(v3);
  swift_unknownObjectRetain(v2);
  return a1;
}

uint64_t *sub_225AA4(uint64_t *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[9];
  sub_222A50(*a1, a1[1]);
  swift_unknownObjectRelease(v2);
  swift_unknownObjectRelease(v3);
  return a1;
}

void *sub_225AF4(void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a1[10];
  uint64_t v6 = a1[14];
  swift_bridgeObjectRelease(*a1);
  swift_unknownObjectRelease(v2);
  sub_222A50(v3, v4);
  swift_unknownObjectRelease(v5);
  swift_unknownObjectRelease(v6);
  return a1;
}

uint64_t sub_225B80( uint64_t a1, void (*a2)(void, void, void, void, void, void, void))
{
  return a1;
}

void sub_225BBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  if (a7 != 255) {
    j__swift_unknownObjectRetain(a2);
  }
}

uint64_t sub_225BF0(uint64_t a1, void (*a2)(void, void, void, void, void, void))
{
  return a1;
}

unint64_t sub_225C2C()
{
  unint64_t result = qword_3A8960;
  if (!qword_3A8960)
  {
    unint64_t result = swift_getWitnessTable(&unk_2811B0, &type metadata for ASN1.ASN1NodeCollection.Iterator);
    atomic_store(result, (unint64_t *)&qword_3A8960);
  }

  return result;
}

void sub_225C70(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

void *sub_225CC4()
{
  uint64_t v3 = v0;
  __int16 v4 = v1;
  char v5 = BYTE2(v1);
  char v6 = BYTE3(v1);
  char v7 = BYTE4(v1);
  char v8 = BYTE5(v1);
  return sub_23B5A4(&v3, BYTE6(v1));
}

uint64_t sub_225E74(__int128 *a1, unint64_t a2, char a3)
{
  __int128 v6 = *a1;
  __int128 v7 = *a1;
  sub_226854((uint64_t)v8);
  sub_222AE4((uint64_t)v8, (uint64_t)v9, &qword_3A8920);
  if (v10 != 255)
  {
    __int128 v11 = v9[0];
    __int128 v12 = v9[1];
    __int128 v13 = v9[2];
    unsigned __int8 v14 = v10;
    if (a2 <= 0x1E) {
      __asm { BR              X12 }
    }

    __break(1u);
    JUMPOUT(0x2261A0LL);
  }

  swift_unknownObjectRetain(v6);
  swift_unknownObjectRelease(v7);
  return 0LL;
}

uint64_t sub_2261B8(__int128 *a1, unint64_t a2, char a3)
{
  __int128 v6 = *a1;
  __int128 v7 = *a1;
  sub_226854((uint64_t)v8);
  sub_222AE4((uint64_t)v8, (uint64_t)v9, &qword_3A8920);
  if (v10 != 255)
  {
    __int128 v11 = v9[0];
    __int128 v12 = v9[1];
    __int128 v13 = v9[2];
    unsigned __int8 v14 = v10;
    if (a2 <= 0x1E) {
      __asm { BR              X12 }
    }

    __break(1u);
    JUMPOUT(0x22653CLL);
  }

  swift_unknownObjectRetain(v6);
  swift_unknownObjectRelease(v7);
  return 0LL;
}

uint64_t sub_226554(__int128 *a1, unint64_t a2, char a3)
{
  __int128 v6 = *a1;
  __int128 v7 = *a1;
  sub_226854((uint64_t)v8);
  sub_222AE4((uint64_t)v8, (uint64_t)v9, &qword_3A8920);
  if (v10 != 255)
  {
    __int128 v11 = v9[0];
    __int128 v12 = v9[1];
    __int128 v13 = v9[2];
    unsigned __int8 v14 = v10;
    if (a2 <= 0x1E) {
      __asm { BR              X12 }
    }

    __break(1u);
    JUMPOUT(0x22683CLL);
  }

  swift_unknownObjectRetain(v6);
  swift_unknownObjectRelease(v7);
  return 1LL;
}

void sub_226854(uint64_t a1@<X8>)
{
  int64_t v3 = v1[2];
  unint64_t v4 = v1[3];
  if (v3 == v4 >> 1)
  {
    unsigned int v5 = 0;
    uint64_t v6 = 0LL;
    __int128 v7 = 0uLL;
    char v8 = -1;
    __int128 v9 = 0uLL;
LABEL_9:
    *(void *)a1 = v5;
    *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v7;
    *(_OWORD *)(a1 + 24) = v9;
    *(void *)(a1 + 40) = v6;
    *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v8;
    return;
  }

  if (v3 >= (uint64_t)(v4 >> 1))
  {
    __break(1u);
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  uint64_t v10 = *v1;
  uint64_t v11 = v1[1];
  __int128 v12 = (unsigned __int8 *)(v11 + 48 * v3);
  unsigned int v5 = *v12;
  uint64_t v13 = *((void *)v12 + 1);
  __int128 v14 = *((_OWORD *)v12 + 1);
  __int128 v15 = *((_OWORD *)v12 + 2);
  int64_t v16 = v3 + 1;
  v1[2] = v3 + 1;
  if ((v5 & 0x20) != 0)
  {
    sub_22ABC0(v10, v11, v3 + 1, v4, v13);
    uint64_t v21 = v20;
    uint64_t v22 = (v19 >> 1) - v18;
    if (!__OFSUB__(v19 >> 1, v18))
    {
      uint64_t v23 = v18;
      unint64_t v24 = v19;
      uint64_t v33 = v17;
      uint64_t v25 = v11;
      uint64_t v26 = v21;
      *uint64_t v1 = sub_216834(v22, v10, v25, v16, v4);
      v1[1] = v27;
      v1[2] = v28;
      v1[3] = v29;
      sub_229BE4(v26, v33, v23, v24, v13, v35);
      __int128 v31 = v35[1];
      __int128 v34 = v35[0];
      uint64_t v6 = v36;
      swift_unknownObjectRetain(v10);
      __int128 v9 = v31;
      __int128 v7 = v34;
      char v8 = 0;
      goto LABEL_9;
    }

    goto LABEL_11;
  }

  __int128 v30 = v15;
  __int128 v32 = v14;
  if ((void)v14)
  {
    swift_unknownObjectRetain(v14);
    uint64_t v6 = 0LL;
    char v8 = 1;
    __int128 v9 = v30;
    __int128 v7 = v32;
    goto LABEL_9;
  }

void sub_2269C4()
{
  if (!*(void *)(v0 + 16))
  {
    Hasher._combine(_:)(0);
    goto LABEL_9;
  }

  uint64_t v1 = *(void *)(v0 + 32);
  unint64_t v2 = *(void *)(v0 + 40);
  uint64_t v3 = *(void *)(v0 + 24);
  Hasher._combine(_:)(1u);
  unint64_t v4 = v2 >> 1;
  if (__OFSUB__(v2 >> 1, v1))
  {
    __break(1u);
    goto LABEL_11;
  }

  Hasher._combine(_:)((v2 >> 1) - v1);
  BOOL v5 = __OFSUB__(v4, v1);
  uint64_t v6 = v4 - v1;
  if (!v6)
  {
LABEL_9:
    Hasher._finalize()();
    return;
  }

  if (!((v6 < 0) ^ v5 | (v6 == 0)))
  {
    __int128 v7 = (Swift::UInt8 *)(v3 + v1);
    do
    {
      Swift::UInt8 v8 = *v7++;
      Hasher._combine(_:)(v8);
      --v6;
    }

    while (v6);
    goto LABEL_9;
  }

void sub_226A90()
{
}

void sub_226AC8()
{
  Swift::UInt v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  uint64_t v3 = *(void *)(v0 + 24);
  uint64_t v4 = *(void *)(v0 + 32);
  unint64_t v5 = *(void *)(v0 + 40);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v1);
  if (!v2)
  {
    Hasher._combine(_:)(0);
    return;
  }

  Hasher._combine(_:)(1u);
  unint64_t v6 = v5 >> 1;
  if (__OFSUB__(v5 >> 1, v4))
  {
    __break(1u);
    goto LABEL_11;
  }

  Hasher._combine(_:)((v5 >> 1) - v4);
  BOOL v7 = __OFSUB__(v6, v4);
  uint64_t v8 = v6 - v4;
  if (!v8) {
    return;
  }
  if ((v8 < 0) ^ v7 | (v8 == 0))
  {
LABEL_11:
    __break(1u);
    return;
  }

  __int128 v9 = (Swift::UInt8 *)(v3 + v4);
  do
  {
    Swift::UInt8 v10 = *v9++;
    Hasher._combine(_:)(v10);
    --v8;
  }

  while (v8);
}

void sub_226B64()
{
  Swift::UInt v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  uint64_t v3 = *(void *)(v0 + 24);
  uint64_t v4 = *(void *)(v0 + 32);
  unint64_t v5 = *(void *)(v0 + 40);
  Swift::UInt8 v6 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v12);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v1);
  if (!v2)
  {
    Hasher._combine(_:)(0);
    goto LABEL_9;
  }

  Hasher._combine(_:)(1u);
  unint64_t v7 = v5 >> 1;
  if (__OFSUB__(v5 >> 1, v4))
  {
    __break(1u);
    goto LABEL_11;
  }

  Hasher._combine(_:)((v5 >> 1) - v4);
  BOOL v8 = __OFSUB__(v7, v4);
  uint64_t v9 = v7 - v4;
  if (!v9)
  {
LABEL_9:
    Hasher._finalize()();
    return;
  }

  if (!((v9 < 0) ^ v8 | (v9 == 0)))
  {
    Swift::UInt8 v10 = (Swift::UInt8 *)(v3 + v4);
    do
    {
      Swift::UInt8 v11 = *v10++;
      Hasher._combine(_:)(v11);
      --v9;
    }

    while (v9);
    goto LABEL_9;
  }

BOOL sub_226C30(_OWORD *a1, __int128 *a2)
{
  __int128 v2 = a1[1];
  v7[0] = *a1;
  v7[1] = v2;
  __int128 v3 = *a2;
  __int128 v4 = a2[1];
  void v7[2] = a1[2];
  v8[0] = v3;
  __int128 v5 = a2[2];
  v8[1] = v4;
  void v8[2] = v5;
  return sub_229D48(v7, v8);
}

uint64_t sub_226C74()
{
  v13[0] = 0LL;
  v13[1] = 0xE000000000000000LL;
  _StringGuts.grow(_:)(61LL);
  v1._object = (void *)0x8000000000305960LL;
  v1._unint64_t countAndFlagsBits = 0xD000000000000020LL;
  String.append(_:)(v1);
  v2._unint64_t countAndFlagsBits = sub_231F8C();
  object = v2._object;
  String.append(_:)(v2);
  swift_bridgeObjectRelease(object);
  v4._unint64_t countAndFlagsBits = 0x3A6874706564202CLL;
  v4._object = (void *)0xE900000000000020LL;
  String.append(_:)(v4);
  v13[0] = *(void *)(v0 + 8);
  v5._unint64_t countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter( &type metadata for Int,  &protocol witness table for Int);
  Swift::UInt8 v6 = v5._object;
  String.append(_:)(v5);
  swift_bridgeObjectRelease(v6);
  v7._unint64_t countAndFlagsBits = 0x794261746164202CLL;
  v7._object = (void *)0xED0000203A736574LL;
  String.append(_:)(v7);
  sub_222AE4(v0 + 16, (uint64_t)v12, &qword_3A8978);
  uint64_t result = sub_222AE4((uint64_t)v12, (uint64_t)v13, &qword_3A8978);
  if (v13[0] && __OFSUB__(v13[3] >> 1, v13[2]))
  {
    __break(1u);
  }

  else
  {
    v9._unint64_t countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter( &type metadata for Int,  &protocol witness table for Int);
    Swift::UInt8 v10 = v9._object;
    String.append(_:)(v9);
    swift_bridgeObjectRelease(v10);
    v11._unint64_t countAndFlagsBits = 41LL;
    v11._object = (void *)0xE100000000000000LL;
    String.append(_:)(v11);
    return 0LL;
  }

  return result;
}

uint64_t sub_226DFC()
{
  return sub_226C74();
}

char *sub_226E34(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v12 = a4;
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v11 = a3;
  swift_unknownObjectRetain(a1);
  uint64_t v13 = sub_212558(0LL, 16LL, 0, (char *)_swiftEmptyArrayStorage);
  sub_226F28((char *)v10, 1LL, &v13);
  uint64_t result = (char *)v10[0];
  if (v5) {
    goto LABEL_6;
  }
  if (!__OFSUB__(v12 >> 1, v11))
  {
    if (v12 >> 1 == v11)
    {
      Swift::String v4 = v13;
      swift_unknownObjectRelease(v10[0]);
      return v4;
    }

    unint64_t v7 = sub_222964();
    uint64_t v8 = swift_allocError(&type metadata for CryptoKitASN1Error, v7, 0LL, 0LL);
    *Swift::String v9 = 3;
    swift_willThrow(v8);
    uint64_t result = (char *)v10[0];
LABEL_6:
    swift_unknownObjectRelease(result);
    swift_bridgeObjectRelease(v13);
    return v4;
  }

  __break(1u);
  return result;
}

void sub_226F28(char *a1, uint64_t a2, char **a3)
{
  if (a2 > 10) {
    goto LABEL_2;
  }
  __int16 v11 = sub_227274();
  if ((v11 & 0x100) != 0) {
    goto LABEL_16;
  }
  char v12 = v11;
  if ((~v11 & 0x1F) == 0)
  {
    unint64_t v13 = sub_222964();
    uint64_t v5 = swift_allocError(&type metadata for CryptoKitASN1Error, v13, 0LL, 0LL);
    _BYTE *v14 = 0;
LABEL_18:
    swift_willThrow(v5);
    return;
  }

  sub_2272BC();
  if (v3) {
    return;
  }
  if ((v16 & 1) != 0)
  {
LABEL_16:
    unint64_t v32 = sub_222964();
    uint64_t v5 = swift_allocError(&type metadata for CryptoKitASN1Error, v32, 0LL, 0LL);
    char v7 = 5;
    goto LABEL_17;
  }

  uint64_t v17 = v15;
  if (v15 < 0)
  {
LABEL_2:
    unint64_t v4 = sub_222964();
    uint64_t v5 = swift_allocError(&type metadata for CryptoKitASN1Error, v4, 0LL, 0LL);
    char v7 = 3;
LABEL_17:
    *Swift::UInt8 v6 = v7;
    goto LABEL_18;
  }

  uint64_t v18 = *(void *)a1;
  unint64_t v47 = *((void *)a1 + 1);
  unint64_t v42 = *((void *)a1 + 3);
  int64_t v43 = *((void *)a1 + 2);
  uint64_t v19 = sub_216E48(v15, v18, v47, v43, v42);
  uint64_t v21 = v20;
  unint64_t v23 = v22;
  uint64_t v39 = v24;
  unint64_t v40 = v19;
  v44[0] = v19;
  v44[1] = v24;
  uint64_t v45 = v20;
  unint64_t v46 = v22;
  uint64_t v41 = v18;
  *(void *)a1 = sub_216834(v17, v18, v47, v43, v42);
  *((void *)a1 + 1) = v25;
  *((void *)a1 + 2) = v26;
  *((void *)a1 + 3) = v27;
  unint64_t v47 = v23;
  if (__OFSUB__(v23 >> 1, v21)) {
    goto LABEL_32;
  }
  if ((v23 >> 1) - v21 == v17)
  {
    uint64_t v18 = v21;
    a1 = *a3;
    swift_unknownObjectRetain(v41);
    if ((v12 & 0x20) == 0)
    {
      unint64_t v23 = v40;
      swift_unknownObjectRetain(v40);
      if ((swift_isUniquelyReferenced_nonNull_native(a1) & 1) != 0)
      {
LABEL_13:
        uint64_t v28 = v39;
        unint64_t v30 = *((void *)a1 + 2);
        unint64_t v29 = *((void *)a1 + 3);
        if (v30 >= v29 >> 1)
        {
          uint64_t v38 = sub_212558((char *)(v29 > 1), v30 + 1, 1, a1);
          uint64_t v28 = v39;
          a1 = v38;
        }

        *((void *)a1 + 2) = v30 + 1;
        __int128 v31 = &a1[48 * v30];
        v31[32] = v12;
        *((void *)v31 + 5) = a2;
        *((void *)v31 + 6) = v23;
        *((void *)v31 + 7) = v28;
        *((void *)v31 + _Block_object_dispose((const void *)(v11 - 96), 8) = v18;
        *((void *)v31 + 9) = v47;
        swift_unknownObjectRelease(v23);
        *a3 = a1;
        return;
      }

uint64_t sub_227274()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = v0[3] >> 1;
  if (v1 == v2)
  {
    int v3 = 0;
  }

  else
  {
    if (v1 >= v2)
    {
      __break(1u);
      return result;
    }

    int v3 = *(unsigned __int8 *)(v0[1] + v1);
    v0[2] = v1 + 1;
  }

  return v3 | ((v1 == v2) << 8);
}

void sub_2272BC()
{
  uint64_t v2 = v0[2];
  unint64_t v3 = v0[3];
  int64_t v4 = v3 >> 1;
  if (v2 == v3 >> 1) {
    return;
  }
  if (v2 >= v4)
  {
    __break(1u);
    goto LABEL_16;
  }

  uint64_t v5 = *v0;
  uint64_t v6 = v0[1];
  int v7 = *(unsigned __int8 *)(v6 + v2);
  int64_t v8 = v2 + 1;
  v0[2] = v2 + 1;
  if (v7 == 128)
  {
    unint64_t v9 = sub_222964();
    uint64_t v10 = swift_allocError(&type metadata for CryptoKitASN1Error, v9, 0LL, 0LL);
    *__int16 v11 = 6;
    swift_willThrow(v10);
    return;
  }

  if ((v7 & 0x80) != 0)
  {
    BOOL v12 = __OFSUB__(v4, v8);
    int64_t v13 = v4 - v8;
    if (!v12)
    {
      unint64_t v14 = v7 & 0x7F;
      if (v13 >= (uint64_t)v14)
      {
        uint64_t v15 = sub_216E48(v7 & 0x7F, v5, v6, v2 + 1, v3);
        uint64_t v29 = v16;
        uint64_t v18 = v17;
        unint64_t v28 = v19;
        *uint64_t v0 = sub_216834(v14, v5, v6, v8, v3);
        v0[1] = v20;
        v0[2] = v21;
        v0[3] = v22;
        swift_unknownObjectRetain(v5);
        uint64_t v23 = swift_unknownObjectRetain(v15);
        unint64_t v24 = sub_222060(v23, v29, v18, v28);
        if (!v1 && (v24 <= 0x7F || v14 > (71 - __clz(v24)) >> 3))
        {
          unint64_t v25 = sub_222964();
          uint64_t v26 = swift_allocError(&type metadata for CryptoKitASN1Error, v25, 0LL, 0LL);
          _BYTE *v27 = 6;
          swift_willThrow(v26);
        }

        swift_unknownObjectRelease(v15);
      }

      return;
    }

Swift::Int sub_22747C()
{
  uint64_t v1 = v0[1];
  uint64_t v2 = v0[2];
  unint64_t v3 = v0[3];
  Hasher.init(_seed:)(v5);
  sub_22A4AC((uint64_t)v5, v1, v2, v3);
  return Hasher._finalize()();
}

void sub_2274D4(uint64_t a1)
{
}

Swift::Int sub_2274E0()
{
  uint64_t v1 = v0[1];
  uint64_t v2 = v0[2];
  unint64_t v3 = v0[3];
  Hasher.init(_seed:)(v5);
  sub_22A4AC((uint64_t)v5, v1, v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_227534(uint64_t a1, uint64_t a2)
{
  return sub_229E10( *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)(a2 + 8),  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t sub_227550@<X0>(uint64_t a1@<X8>)
{
  return sub_222AE4((uint64_t)v3, a1, &qword_3A8920);
}

__n128 sub_227590@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 32);
  __n128 result = *(__n128 *)v1;
  __int128 v4 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = v2;
  return result;
}

uint64_t sub_2275A4()
{
  uint64_t v1 = *(void *)v0;
  uint64_t v2 = sub_22A0C0(*(void *)v0, *(void *)(v0 + 8), *(void *)(v0 + 16), *(void *)(v0 + 24));
  swift_unknownObjectRelease(v1);
  return v2;
}

uint64_t sub_2275DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_22931C(a1, a2, a3);
}

unint64_t sub_227618()
{
  unint64_t result = qword_3A8968;
  if (!qword_3A8968)
  {
    unint64_t result = swift_getWitnessTable(&unk_2811E0, &type metadata for ASN1.ASN1ParseResult);
    atomic_store(result, (unint64_t *)&qword_3A8968);
  }

  return result;
}

unint64_t sub_227660()
{
  unint64_t result = qword_3A8970;
  if (!qword_3A8970)
  {
    unint64_t result = swift_getWitnessTable(&unk_281270, &type metadata for ASN1.ASN1ParserNode);
    atomic_store(result, (unint64_t *)&qword_3A8970);
  }

  return result;
}

uint64_t sub_2276A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_225BF0( a3,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
}

uint64_t sub_2276DC(uint64_t a1, char **a2, char *a3)
{
  unint64_t v5 = v3;
  unint64_t v9 = *a2;
  int isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native(*a2);
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    int isUniquelyReferenced_nonNull_native = sub_2121E4(0LL, *((void *)v9 + 2) + 1LL, 1, v9);
    unint64_t v9 = isUniquelyReferenced_nonNull_native;
  }

  unint64_t v13 = *((void *)v9 + 2);
  unint64_t v12 = *((void *)v9 + 3);
  int64_t v14 = v12 >> 1;
  uint64_t v15 = v13 + 1;
  if (v12 >> 1 <= v13)
  {
    int isUniquelyReferenced_nonNull_native = sub_2121E4((char *)(v12 > 1), v13 + 1, 1, v9);
    unint64_t v9 = isUniquelyReferenced_nonNull_native;
    unint64_t v12 = *((void *)isUniquelyReferenced_nonNull_native + 3);
    int64_t v14 = v12 >> 1;
  }

  *((void *)v9 + 2) = v15;
  v9[v13 + 32] = a1;
  unint64_t v16 = v13 + 2;
  if (v14 < (uint64_t)v16)
  {
    int isUniquelyReferenced_nonNull_native = sub_2121E4((char *)(v12 > 1), v16, 1, v9);
    unint64_t v9 = isUniquelyReferenced_nonNull_native;
  }

  *((void *)v9 + 2) = v16;
  v9[v15 + 32] = 0;
  *a2 = v9;
  unint64_t v17 = v16 - 1;
  if (__OFSUB__(v16, 1LL))
  {
    __break(1u);
    goto LABEL_38;
  }

  unint64_t v9 = *(char **)a3;
  __chkstk_darwin(isUniquelyReferenced_nonNull_native, v11);
  void v24[2] = v9;
  sub_22A8C0(6, a2, (uint64_t (*)(char **))sub_2229E4, (uint64_t)v24);
  a1 = *((void *)a3 + 1);
  if (a1)
  {
    uint64_t v15 = *((void *)a3 + 3);
    unint64_t v18 = *((void *)a3 + 4);
    uint64_t v19 = *((void *)a3 + 2);
    uint64_t v20 = swift_unknownObjectRetain(a1);
    sub_2329B0(v20, v19, v15, v18);
    swift_unknownObjectRelease(a1);
  }

  a3 = *a2;
  unint64_t v21 = *((void *)*a2 + 2);
  unint64_t v4 = v21 - v16;
  if ((uint64_t)(v21 - v16) >= 128)
  {
    if (v21 >= v16)
    {
      v24[5] = v5;
      unint64_t v5 = 71 - __clz(v4);
      uint64_t v15 = v5 >> 3;
      sub_227D0C(v5 >> 3, v16, v21);
      a3 = *a2;
      if ((swift_isUniquelyReferenced_nonNull_native(*a2) & 1) != 0)
      {
LABEL_13:
        if (v17 < *((void *)a3 + 2))
        {
          uint64_t v22 = a3 + 32;
          a3[v17 + 32] = (v5 >> 3) | 0x80;
          *a2 = a3;
          if (v16 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16] = v4 >> (8 * ((v15 - 1) & 7));
          if (v15 == 1) {
            goto LABEL_34;
          }
          if (v16 + 1 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16 + 1] = v4 >> (8 * ((v15 - 2) & 7));
          if (v15 == 2) {
            goto LABEL_34;
          }
          if (v16 + 2 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16 + 2] = v4 >> (8 * ((v15 - 3) & 7));
          if (v15 == 3) {
            goto LABEL_34;
          }
          if (v16 + 3 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16 + 3] = v4 >> (8 * ((v15 - 4) & 7));
          if (v15 == 4) {
            goto LABEL_34;
          }
          if (v16 + 4 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16 + 4] = v4 >> (8 * ((v15 - 5) & 7));
          if (v15 == 5) {
            goto LABEL_34;
          }
          if (v16 + 5 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16 + 5] = v4 >> (8 * ((v15 - 6) & 7));
          if (v15 == 6) {
            goto LABEL_34;
          }
          if (v16 + 6 >= *((void *)a3 + 2)) {
            goto LABEL_35;
          }
          v22[v16 + 6] = v4 >> (8 * ((v15 - 7) & 7));
          if (v15 == 7) {
            goto LABEL_34;
          }
          if (v16 + 7 >= *((void *)a3 + 2))
          {
LABEL_35:
            __break(1u);
            goto LABEL_34;
          }

          v22[v16 + 7] = v4 >> (v5 & 0x38);
LABEL_34:
          swift_bridgeObjectRelease(v9);
          uint64_t result = swift_unknownObjectRelease(a1);
          *a2 = a3;
          return result;
        }

        __break(1u);
        goto LABEL_41;
      }

uint64_t sub_227A64(uint64_t result, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(void *)(a2 + 32);
  if ((*(_BYTE *)(a2 + 48) & 1) != 0)
  {
    sub_225BF0(a2, (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRetain);
    sub_2329B0(v4, v5, v6, v7);
    return sub_225BF0( v2,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
  }

  else
  {
    uint64_t v8 = v7 >> 1;
    if (v6 != v7 >> 1)
    {
      sub_225BF0(a2, (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRetain);
      unint64_t v9 = v7 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v37 = v4;
      uint64_t result = swift_unknownObjectRetain(v4);
      unint64_t v26 = v7 & 0xFFFFFFFFFFFFFFFELL;
      while (v6 < (uint64_t)(v7 >> 1))
      {
        if (v8 <= v6) {
          goto LABEL_38;
        }
        if (v7 >> 1 < v8) {
          goto LABEL_39;
        }
        unint64_t v12 = (unsigned __int8 *)(v5 + 48 * v6);
        uint64_t v13 = *v12;
        uint64_t v14 = v6 + 1;
        unint64_t v15 = v7 & 1;
        if ((v13 & 0x20) != 0)
        {
          uint64_t v16 = *((void *)v12 + 1);
          if (v14 == v8)
          {
            uint64_t v17 = v8;
          }

          else
          {
            unint64_t v18 = (uint64_t *)(v5 + 56 + 48 * v6);
            uint64_t v17 = v6 + 1;
            do
            {
              if (v17 >= v8)
              {
                __break(1u);
LABEL_36:
                __break(1u);
                goto LABEL_37;
              }

              if (v16 >= *v18) {
                goto LABEL_20;
              }
              uint64_t v19 = v17 + 1;
              if (__OFADD__(v17, 1LL)) {
                goto LABEL_36;
              }
              ++v17;
              v18 += 6;
            }

            while (v19 != v8);
            uint64_t v17 = v8;
LABEL_20:
            if (v17 <= v6) {
              goto LABEL_40;
            }
            if (v17 < 0) {
              goto LABEL_41;
            }
          }

          uint64_t v20 = v17 - v14;
          if (__OFSUB__(v17, v14)) {
            goto LABEL_42;
          }
          if (v20 < 0) {
            goto LABEL_43;
          }
          uint64_t v21 = v8 - v14;
          if (__OFSUB__(v8, v14)) {
            goto LABEL_44;
          }
          uint64_t v22 = v3;
          if (!v20 || v21 < 0 || (uint64_t v23 = v8, v21 >= v20))
          {
            uint64_t v23 = v17;
            if (__OFADD__(v14, v20)) {
              goto LABEL_47;
            }
            if (v8 < v17) {
              goto LABEL_45;
            }
          }

          if (v23 <= v6) {
            goto LABEL_46;
          }
          uint64_t v24 = v37;
          sub_229BE4(v37, v5, v14, v15 | (2 * v17), v16, v30);
          __int128 v27 = v30[1];
          __int128 v29 = v30[0];
          uint64_t v10 = v31;
          swift_unknownObjectRetain(v24);
          __int128 v11 = v29;
          uint64_t v14 = v23;
          uint64_t v3 = v22;
          unint64_t v9 = v26;
        }

        else
        {
          __int128 v28 = *((_OWORD *)v12 + 1);
          uint64_t result = *((void *)v12 + 2);
          if (!(void)v28) {
            goto LABEL_48;
          }
          __int128 v27 = *((_OWORD *)v12 + 2);
          swift_unknownObjectRetain(result);
          uint64_t v10 = 0LL;
          __int128 v11 = v28;
        }

        v32[0] = v13;
        unint64_t v7 = v15 | v9;
        __int128 v33 = v11;
        __int128 v34 = v27;
        uint64_t v35 = v10;
        BOOL v36 = (v13 & 0x20) == 0;
        uint64_t result = sub_2276A4(v13, v3, (uint64_t)v32);
        uint64_t v6 = v14;
        if (v14 == v8)
        {
          swift_unknownObjectRelease(v37);
          uint64_t v2 = a2;
          return sub_225BF0( v2,  (void (*)(void, void, void, void, void, void))j__swift_unknownObjectRelease);
        }
      }

uint64_t sub_227D0C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result < 1) {
    goto LABEL_28;
  }
  uint64_t v6 = a3;
  uint64_t v7 = *v4;
  uint64_t v8 = *(void *)(*v4 + 16);
  uint64_t v9 = v8 - a3;
  if (__OFSUB__(v8, a3)) {
    goto LABEL_29;
  }
  uint64_t v3 = a2;
  uint64_t v5 = result;
  if (v9 >= result) {
    goto LABEL_13;
  }
  uint64_t v10 = result - v9;
  if (__OFSUB__(result, v9))
  {
    __break(1u);
    goto LABEL_32;
  }

  if (v10 < 0)
  {
LABEL_32:
    __break(1u);
LABEL_33:
    uint64_t result = (uint64_t)sub_2121E4(0LL, v8 + 1, 1, (char *)v7);
    uint64_t v7 = result;
LABEL_8:
    unint64_t v11 = *(void *)(v7 + 16);
    do
    {
      unint64_t v12 = *(void *)(v7 + 24);
      if (v11 >= v12 >> 1)
      {
        uint64_t result = (uint64_t)sub_2121E4((char *)(v12 > 1), v11 + 1, 1, (char *)v7);
        uint64_t v7 = result;
      }

      *(void *)(v7 + 16) = v11 + 1;
      *(_BYTE *)(v7 + v11++ + 32) = 0;
      --v10;
    }

    while (v10);
    *uint64_t v4 = v7;
    goto LABEL_13;
  }

  if (v10)
  {
    uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v4);
    if ((result & 1) != 0) {
      goto LABEL_8;
    }
    goto LABEL_33;
  }

uint64_t sub_227E90(uint64_t a1, uint64_t a2)
{
  return sub_228350(a1, a2, (uint64_t (*)(void))sub_23E9A0);
}

void *sub_227E9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v27[0] = a1;
  v27[1] = a2;
  v27[2] = a3;
  void v27[3] = a4;
  size_t v4 = sub_23EEF8((size_t)v27, (unint64_t)&v28);
  uint64_t v5 = *(void *)(v4 + 16);
  uint64_t v6 = _swiftEmptyArrayStorage;
  size_t v26 = v4;
  size_t v7 = 0LL;
  if (v5)
  {
    uint64_t v8 = &_swiftEmptyArrayStorage[4];
    uint64_t v9 = (char *)(v4 + 32);
    while (1)
    {
      char v11 = *v9++;
      char v10 = v11;
      if (!v7)
      {
        unint64_t v12 = v6[3];
        int64_t v13 = v12 & 0xFFFFFFFFFFFFFFFELL;
        if (v13 <= 1) {
          uint64_t v14 = 1LL;
        }
        else {
          uint64_t v14 = v13;
        }
        uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
        uint64_t v16 = (void *)swift_allocObject(v15, v14 + 32, 7LL);
        size_t v17 = 2 * _swift_stdlib_malloc_size(v16) - 64;
        __int128 v16[2] = v14;
        _OWORD v16[3] = v17;
        unint64_t v18 = (unint64_t)(v16 + 4);
        size_t v19 = v6[3] >> 1;
        if (v6[2])
        {
          void v6[2] = 0LL;
        }

        uint64_t v8 = (_BYTE *)(v18 + v19);
        size_t v7 = (v17 >> 1) - v19;
        swift_release(v6);
        uint64_t v6 = v16;
      }

      BOOL v21 = __OFSUB__(v7--, 1LL);
      if (v21) {
        break;
      }
      *v8++ = v10;
      if (!--v5) {
        goto LABEL_19;
      }
    }

    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
  }

void *sub_228028(_OWORD *a1)
{
  __int128 v1 = a1[1];
  v25[0] = *a1;
  v25[1] = v1;
  void v25[2] = a1[2];
  size_t v2 = sub_23EEF8((size_t)v25, (unint64_t)&v26);
  uint64_t v3 = *(void *)(v2 + 16);
  size_t v4 = _swiftEmptyArrayStorage;
  size_t v24 = v2;
  size_t v5 = 0LL;
  if (v3)
  {
    uint64_t v6 = &_swiftEmptyArrayStorage[4];
    size_t v7 = (char *)(v2 + 32);
    while (1)
    {
      char v9 = *v7++;
      char v8 = v9;
      if (!v5)
      {
        unint64_t v10 = v4[3];
        int64_t v11 = v10 & 0xFFFFFFFFFFFFFFFELL;
        if (v11 <= 1) {
          uint64_t v12 = 1LL;
        }
        else {
          uint64_t v12 = v11;
        }
        uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
        uint64_t v14 = (void *)swift_allocObject(v13, v12 + 32, 7LL);
        size_t v15 = 2 * _swift_stdlib_malloc_size(v14) - 64;
        void v14[2] = v12;
        v14[3] = v15;
        unint64_t v16 = (unint64_t)(v14 + 4);
        size_t v17 = v4[3] >> 1;
        if (v4[2])
        {
          void v4[2] = 0LL;
        }

        uint64_t v6 = (_BYTE *)(v16 + v17);
        size_t v5 = (v15 >> 1) - v17;
        swift_release(v4);
        size_t v4 = v14;
      }

      BOOL v19 = __OFSUB__(v5--, 1LL);
      if (v19) {
        break;
      }
      *v6++ = v8;
      if (!--v3) {
        goto LABEL_19;
      }
    }

    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
  }

void *sub_2281BC(_OWORD *a1)
{
  __int128 v1 = a1[1];
  v26[0] = *a1;
  v26[1] = v1;
  __int128 v2 = a1[3];
  v26[2] = a1[2];
  v26[3] = v2;
  size_t v3 = sub_23EEF8((size_t)v26, (unint64_t)&v27);
  uint64_t v4 = *(void *)(v3 + 16);
  size_t v5 = _swiftEmptyArrayStorage;
  size_t v25 = v3;
  size_t v6 = 0LL;
  if (v4)
  {
    size_t v7 = &_swiftEmptyArrayStorage[4];
    char v8 = (char *)(v3 + 32);
    while (1)
    {
      char v10 = *v8++;
      char v9 = v10;
      if (!v6)
      {
        unint64_t v11 = v5[3];
        int64_t v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
        if (v12 <= 1) {
          uint64_t v13 = 1LL;
        }
        else {
          uint64_t v13 = v12;
        }
        uint64_t v14 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
        size_t v15 = (void *)swift_allocObject(v14, v13 + 32, 7LL);
        size_t v16 = 2 * _swift_stdlib_malloc_size(v15) - 64;
        __int128 v15[2] = v13;
        v15[3] = v16;
        unint64_t v17 = (unint64_t)(v15 + 4);
        size_t v18 = v5[3] >> 1;
        if (v5[2])
        {
          _OWORD v5[2] = 0LL;
        }

        size_t v7 = (_BYTE *)(v17 + v18);
        size_t v6 = (v16 >> 1) - v18;
        swift_release(v5);
        size_t v5 = v15;
      }

      BOOL v20 = __OFSUB__(v6--, 1LL);
      if (v20) {
        break;
      }
      *v7++ = v9;
      if (!--v4) {
        goto LABEL_19;
      }
    }

    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
  }

uint64_t sub_228350(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t result = a3();
  uint64_t v5 = *(void *)(result + 16);
  size_t v6 = _swiftEmptyArrayStorage;
  uint64_t v7 = v5 - v4;
  uint64_t v26 = result;
  if (v5 != v4)
  {
    if (v5 > v4)
    {
      if (v4 < 0)
      {
LABEL_30:
        __break(1u);
        goto LABEL_31;
      }

      if (!v5)
      {
LABEL_31:
        __break(1u);
        goto LABEL_32;
      }

      size_t v8 = 0LL;
      char v9 = (char *)(v4 + result + 32);
      char v10 = &_swiftEmptyArrayStorage[4];
      while (1)
      {
        char v12 = *v9++;
        char v11 = v12;
        if (!v8)
        {
          unint64_t v13 = v6[3];
          int64_t v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
          if (v14 <= 1) {
            uint64_t v15 = 1LL;
          }
          else {
            uint64_t v15 = v14;
          }
          uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
          unint64_t v17 = (void *)swift_allocObject(v16, v15 + 32, 7LL);
          size_t v18 = 2 * _swift_stdlib_malloc_size(v17) - 64;
          __int128 v17[2] = v15;
          v17[3] = v18;
          unint64_t v19 = (unint64_t)(v17 + 4);
          size_t v20 = v6[3] >> 1;
          if (v6[2])
          {
            void v6[2] = 0LL;
          }

          char v10 = (_BYTE *)(v19 + v20);
          size_t v8 = (v18 >> 1) - v20;
          uint64_t result = swift_release(v6);
          size_t v6 = v17;
        }

        BOOL v22 = __OFSUB__(v8--, 1LL);
        if (v22) {
          break;
        }
        *v10++ = v11;
        if (!--v7) {
          goto LABEL_23;
        }
      }

      __break(1u);
LABEL_28:
      __break(1u);
    }

    __break(1u);
    goto LABEL_30;
  }

  size_t v8 = 0LL;
LABEL_23:
  uint64_t result = swift_bridgeObjectRelease(v26);
  unint64_t v23 = v6[3];
  if (v23 < 2) {
    return (uint64_t)v6;
  }
  unint64_t v24 = v23 >> 1;
  BOOL v22 = __OFSUB__(v24, v8);
  unint64_t v25 = v24 - v8;
  if (!v22)
  {
    void v6[2] = v25;
    return (uint64_t)v6;
  }

uint64_t sub_2284CC(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t result = sub_1F86D4(a1, a2);
  uint64_t v9 = *(void *)(v5 + 16);
  char v10 = _swiftEmptyArrayStorage;
  uint64_t v11 = v9 - v7;
  uint64_t v30 = v5;
  if (v9 != v7)
  {
    if (v9 > v7)
    {
      if (v7 < 0)
      {
LABEL_30:
        __break(1u);
        goto LABEL_31;
      }

      if (!v9)
      {
LABEL_31:
        __break(1u);
        goto LABEL_32;
      }

      size_t v12 = 0LL;
      unint64_t v13 = (char *)(v7 + v5 + 32);
      int64_t v14 = &_swiftEmptyArrayStorage[4];
      while (1)
      {
        char v16 = *v13++;
        char v15 = v16;
        if (!v12)
        {
          unint64_t v17 = v10[3];
          int64_t v18 = v17 & 0xFFFFFFFFFFFFFFFELL;
          if (v18 <= 1) {
            uint64_t v19 = 1LL;
          }
          else {
            uint64_t v19 = v18;
          }
          uint64_t v20 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
          unint64_t v21 = (void *)swift_allocObject(v20, v19 + 32, 7LL);
          size_t v22 = 2 * _swift_stdlib_malloc_size(v21) - 64;
          _OWORD v21[2] = v19;
          v21[3] = v22;
          unint64_t v23 = (unint64_t)(v21 + 4);
          size_t v24 = v10[3] >> 1;
          if (v10[2])
          {
            void v10[2] = 0LL;
          }

          int64_t v14 = (_BYTE *)(v23 + v24);
          size_t v12 = (v22 >> 1) - v24;
          uint64_t result = swift_release(v10);
          char v10 = v21;
        }

        BOOL v26 = __OFSUB__(v12--, 1LL);
        if (v26) {
          break;
        }
        *v14++ = v15;
        if (!--v11) {
          goto LABEL_23;
        }
      }

      __break(1u);
LABEL_28:
      __break(1u);
    }

    __break(1u);
    goto LABEL_30;
  }

  size_t v12 = 0LL;
LABEL_23:
  uint64_t result = swift_bridgeObjectRelease(v30);
  unint64_t v27 = v10[3];
  if (v27 < 2) {
    return (uint64_t)v10;
  }
  unint64_t v28 = v27 >> 1;
  BOOL v26 = __OFSUB__(v28, v12);
  unint64_t v29 = v28 - v12;
  if (!v26)
  {
    void v10[2] = v29;
    return (uint64_t)v10;
  }

void *sub_228668(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v26[0] = a1;
  v26[1] = a2;
  uint64_t v27 = a3;
  size_t v3 = sub_23EEF8((size_t)v26, (unint64_t)&v27 + 4);
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = _swiftEmptyArrayStorage;
  size_t v25 = v3;
  size_t v6 = 0LL;
  if (v4)
  {
    uint64_t v7 = &_swiftEmptyArrayStorage[4];
    size_t v8 = (char *)(v3 + 32);
    while (1)
    {
      char v10 = *v8++;
      char v9 = v10;
      if (!v6)
      {
        unint64_t v11 = v5[3];
        int64_t v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
        if (v12 <= 1) {
          uint64_t v13 = 1LL;
        }
        else {
          uint64_t v13 = v12;
        }
        uint64_t v14 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
        char v15 = (void *)swift_allocObject(v14, v13 + 32, 7LL);
        size_t v16 = 2 * _swift_stdlib_malloc_size(v15) - 64;
        __int128 v15[2] = v13;
        v15[3] = v16;
        unint64_t v17 = (unint64_t)(v15 + 4);
        size_t v18 = v5[3] >> 1;
        if (v5[2])
        {
          _OWORD v5[2] = 0LL;
        }

        uint64_t v7 = (_BYTE *)(v17 + v18);
        size_t v6 = (v16 >> 1) - v18;
        swift_release(v5);
        uint64_t v5 = v15;
      }

      BOOL v20 = __OFSUB__(v6--, 1LL);
      if (v20) {
        break;
      }
      *v7++ = v9;
      if (!--v4) {
        goto LABEL_19;
      }
    }

    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
  }

void *sub_2287F4(uint64_t a1, uint64_t a2)
{
  v25[0] = a1;
  v25[1] = a2;
  size_t v2 = sub_23EEF8((size_t)v25, (unint64_t)&v26);
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = _swiftEmptyArrayStorage;
  size_t v24 = v2;
  size_t v5 = 0LL;
  if (v3)
  {
    size_t v6 = &_swiftEmptyArrayStorage[4];
    uint64_t v7 = (char *)(v2 + 32);
    while (1)
    {
      char v9 = *v7++;
      char v8 = v9;
      if (!v5)
      {
        unint64_t v10 = v4[3];
        int64_t v11 = v10 & 0xFFFFFFFFFFFFFFFELL;
        if (v11 <= 1) {
          uint64_t v12 = 1LL;
        }
        else {
          uint64_t v12 = v11;
        }
        uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81F0);
        uint64_t v14 = (void *)swift_allocObject(v13, v12 + 32, 7LL);
        size_t v15 = 2 * _swift_stdlib_malloc_size(v14) - 64;
        void v14[2] = v12;
        v14[3] = v15;
        unint64_t v16 = (unint64_t)(v14 + 4);
        size_t v17 = v4[3] >> 1;
        if (v4[2])
        {
          void v4[2] = 0LL;
        }

        size_t v6 = (_BYTE *)(v16 + v17);
        size_t v5 = (v15 >> 1) - v17;
        swift_release(v4);
        uint64_t v4 = v14;
      }

      BOOL v19 = __OFSUB__(v5--, 1LL);
      if (v19) {
        break;
      }
      *v6++ = v8;
      if (!--v3) {
        goto LABEL_19;
      }
    }

    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
  }

int64_t sub_22897C(int64_t result, int64_t a2, uint64_t a3)
{
  int64_t v5 = result;
  uint64_t v6 = 0LL;
  uint64_t v7 = 32LL;
  int64_t v8 = result;
  while (1)
  {
    BOOL v9 = v8 <= a2;
    if (a3 > 0) {
      BOOL v9 = v8 >= a2;
    }
    if (v9) {
      break;
    }
    BOOL v10 = __OFADD__(v8, a3);
    v8 += a3;
    if (v10) {
      int64_t v8 = (v8 >> 63) ^ 0x8000000000000000LL;
    }
    v7 += 8LL;
    BOOL v10 = __OFADD__(v6++, 1LL);
    if (v10)
    {
      __break(1u);
      break;
    }
  }

  if (v6 > 0)
  {
    uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81C8);
    uint64_t v12 = (int64_t *)swift_allocObject(v11, v7, 7LL);
    uint64_t result = _swift_stdlib_malloc_size(v12);
    uint64_t v13 = result - 32;
    if (result < 32) {
      uint64_t v13 = result - 25;
    }
    uint64_t v14 = v13 >> 3;
    v12[2] = v6;
    uint64_t v12[3] = 2 * v14;
    size_t v15 = v12 + 4;
    uint64_t v16 = v14 & 0x7FFFFFFFFFFFFFFFLL;
LABEL_15:
    v16 -= v6;
    while (1)
    {
      BOOL v17 = v5 <= a2;
      if (a3 > 0) {
        BOOL v17 = v5 >= a2;
      }
      if (v17) {
        break;
      }
      if (__OFADD__(v5, a3)) {
        int64_t v18 = ((v5 + a3) >> 63) ^ 0x8000000000000000LL;
      }
      else {
        int64_t v18 = v5 + a3;
      }
      *v15++ = v5;
      int64_t v5 = v18;
      if (!--v6) {
        goto LABEL_23;
      }
    }

    __break(1u);
LABEL_57:
    __break(1u);
LABEL_58:
    __break(1u);
    goto LABEL_59;
  }

  uint64_t v12 = _swiftEmptyArrayStorage;
  size_t v15 = &_swiftEmptyArrayStorage[4];
  uint64_t v16 = _swiftEmptyArrayStorage[3] >> 1;
  if (v6) {
    goto LABEL_15;
  }
  int64_t v18 = result;
LABEL_23:
  BOOL v19 = v18 <= a2;
  if (a3 > 0) {
    BOOL v19 = v18 >= a2;
  }
  if (!v19)
  {
    uint64_t v20 = (a3 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      int64_t v21 = v18 + a3;
      if (__OFADD__(v18, a3))
      {
        int64_t v21 = v20;
        if (!v16) {
          goto LABEL_32;
        }
        int64_t v21 = v20;
      }

      else if (!v16)
      {
LABEL_32:
        unint64_t v22 = v12[3];
        int64_t v23 = v22 & 0xFFFFFFFFFFFFFFFELL;
        if (v23 <= 1) {
          uint64_t v24 = 1LL;
        }
        else {
          uint64_t v24 = v23;
        }
        uint64_t v25 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A81C8);
        uint64_t v26 = (int64_t *)swift_allocObject(v25, 8 * v24 + 32, 7LL);
        int64_t v27 = _swift_stdlib_malloc_size(v26);
        uint64_t v28 = v27 - 32;
        if (v27 < 32) {
          uint64_t v28 = v27 - 25;
        }
        uint64_t v29 = v28 >> 3;
        void v26[2] = v24;
        v26[3] = 2 * (v28 >> 3);
        unint64_t v30 = (unint64_t)(v26 + 4);
        unint64_t v31 = (unint64_t)v12[3] >> 1;
        if (v12[2])
        {
          v12[2] = 0LL;
        }

        size_t v15 = (int64_t *)(v30 + 8 * v31);
        uint64_t v16 = (v29 & 0x7FFFFFFFFFFFFFFFLL) - v31;
        uint64_t result = swift_release(v12);
        uint64_t v12 = v26;
        uint64_t v20 = (a3 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
      }

      BOOL v10 = __OFSUB__(v16--, 1LL);
      if (v10) {
        goto LABEL_57;
      }
      *v15++ = v18;
      BOOL v33 = v21 <= a2;
      if (a3 > 0) {
        BOOL v33 = v21 >= a2;
      }
      int64_t v18 = v21;
    }

    while (!v33);
  }

  unint64_t v34 = v12[3];
  if (v34 < 2) {
    return (int64_t)v12;
  }
  unint64_t v35 = v34 >> 1;
  BOOL v10 = __OFSUB__(v35, v16);
  unint64_t v36 = v35 - v16;
  if (!v10)
  {
    v12[2] = v36;
    return (int64_t)v12;
  }

uint64_t sub_228BFC(uint64_t *a1, _BYTE *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return sub_22902C(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t *, _BYTE *))sub_23E9A0);
}

size_t sub_228C08(size_t *a1, _BYTE *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v23[0] = a4;
  v23[1] = a5;
  _OWORD v23[2] = a6;
  v23[3] = a7;
  size_t v10 = sub_23EEF8((size_t)v23, (unint64_t)&v24);
  if (a2)
  {
    if (a3)
    {
      if ((a3 & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
      size_t v11 = *(void *)(v10 + 16);
      if (v11)
      {
        *a2 = *(_BYTE *)(v10 + 32);
        unint64_t v12 = a3 - 1;
        if (a3 != 1)
        {
          if (v11 - 1 < v12) {
            unint64_t v12 = v11 - 1;
          }
          if (v12 >= a3 - 2) {
            unint64_t v12 = a3 - 2;
          }
          unint64_t v13 = v12 + 1;
          if (v13 <= 0x10 || ((unint64_t)&a2[-v10] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
          {
            uint64_t v14 = 1LL;
            size_t v15 = a2;
          }

          else
          {
            uint64_t v16 = v13 & 0xF;
            if ((v13 & 0xF) == 0) {
              uint64_t v16 = 16LL;
            }
            unint64_t v17 = v13 - v16;
            uint64_t v14 = v13 - v16 + 1;
            size_t v15 = &a2[v17];
            int64_t v18 = a2 + 1;
            BOOL v19 = (__int128 *)(v10 + 33);
            do
            {
              __int128 v20 = *v19++;
              *v18++ = v20;
              v17 -= 16LL;
            }

            while (v17);
          }

          int64_t v21 = v15 + 1;
          while (a3 != v14)
          {
            if (v11 == v14) {
              goto LABEL_23;
            }
            *v21++ = *(_BYTE *)(v10 + 32 + v14);
            if (a3 == ++v14) {
              goto LABEL_24;
            }
          }

          __break(1u);
LABEL_26:
          __break(1u);
        }
      }

      else
      {
LABEL_23:
        a3 = v11;
      }
    }
  }

  else
  {
    a3 = 0LL;
  }

size_t sub_228D64(size_t *a1, _BYTE *a2, size_t a3)
{
  __int128 v7 = v3[1];
  v21[0] = *v3;
  v21[1] = v7;
  _OWORD v21[2] = v3[2];
  size_t v8 = sub_23EEF8((size_t)v21, (unint64_t)&v22);
  if (a2)
  {
    if (a3)
    {
      if ((a3 & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
      size_t v9 = *(void *)(v8 + 16);
      if (v9)
      {
        *a2 = *(_BYTE *)(v8 + 32);
        unint64_t v10 = a3 - 1;
        if (a3 != 1)
        {
          if (v9 - 1 < v10) {
            unint64_t v10 = v9 - 1;
          }
          if (v10 >= a3 - 2) {
            unint64_t v10 = a3 - 2;
          }
          unint64_t v11 = v10 + 1;
          if (v11 <= 0x10 || ((unint64_t)&a2[-v8] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
          {
            uint64_t v12 = 1LL;
            unint64_t v13 = a2;
          }

          else
          {
            uint64_t v14 = v11 & 0xF;
            if ((v11 & 0xF) == 0) {
              uint64_t v14 = 16LL;
            }
            unint64_t v15 = v11 - v14;
            uint64_t v12 = v11 - v14 + 1;
            unint64_t v13 = &a2[v15];
            uint64_t v16 = a2 + 1;
            unint64_t v17 = (__int128 *)(v8 + 33);
            do
            {
              __int128 v18 = *v17++;
              *v16++ = v18;
              v15 -= 16LL;
            }

            while (v15);
          }

          BOOL v19 = v13 + 1;
          while (a3 != v12)
          {
            if (v9 == v12) {
              goto LABEL_23;
            }
            *v19++ = *(_BYTE *)(v8 + 32 + v12);
            if (a3 == ++v12) {
              goto LABEL_24;
            }
          }

          __break(1u);
LABEL_26:
          __break(1u);
        }
      }

      else
      {
LABEL_23:
        a3 = v9;
      }
    }
  }

  else
  {
    a3 = 0LL;
  }

size_t sub_228EC8(size_t *a1, _BYTE *a2, size_t a3)
{
  __int128 v7 = v3[1];
  v22[0] = *v3;
  v22[1] = v7;
  __int128 v8 = v3[3];
  v22[2] = v3[2];
  v22[3] = v8;
  size_t v9 = sub_23EEF8((size_t)v22, (unint64_t)&v23);
  if (a2)
  {
    if (a3)
    {
      if ((a3 & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
      size_t v10 = *(void *)(v9 + 16);
      if (v10)
      {
        *a2 = *(_BYTE *)(v9 + 32);
        unint64_t v11 = a3 - 1;
        if (a3 != 1)
        {
          if (v10 - 1 < v11) {
            unint64_t v11 = v10 - 1;
          }
          if (v11 >= a3 - 2) {
            unint64_t v11 = a3 - 2;
          }
          unint64_t v12 = v11 + 1;
          if (v12 <= 0x10 || ((unint64_t)&a2[-v9] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
          {
            uint64_t v13 = 1LL;
            uint64_t v14 = a2;
          }

          else
          {
            uint64_t v15 = v12 & 0xF;
            if ((v12 & 0xF) == 0) {
              uint64_t v15 = 16LL;
            }
            unint64_t v16 = v12 - v15;
            uint64_t v13 = v12 - v15 + 1;
            uint64_t v14 = &a2[v16];
            unint64_t v17 = a2 + 1;
            __int128 v18 = (__int128 *)(v9 + 33);
            do
            {
              __int128 v19 = *v18++;
              *v17++ = v19;
              v16 -= 16LL;
            }

            while (v16);
          }

          __int128 v20 = v14 + 1;
          while (a3 != v13)
          {
            if (v10 == v13) {
              goto LABEL_23;
            }
            *v20++ = *(_BYTE *)(v9 + 32 + v13);
            if (a3 == ++v13) {
              goto LABEL_24;
            }
          }

          __break(1u);
LABEL_26:
          __break(1u);
        }
      }

      else
      {
LABEL_23:
        a3 = v10;
      }
    }
  }

  else
  {
    a3 = 0LL;
  }

uint64_t sub_22902C( uint64_t *a1, _BYTE *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(uint64_t *, _BYTE *))
{
  uint64_t v11 = a6(a1, a2);
  unint64_t v13 = v12;
  uint64_t result = sub_1F86D4(a4, a5);
  if (!a2) {
    goto LABEL_5;
  }
  if (!a3)
  {
LABEL_6:
    *a1 = v11;
    a1[1] = v13;
    return a3;
  }

  if (a3 < 0) {
    goto LABEL_28;
  }
  unint64_t v15 = *(void *)(v11 + 16);
  if (v13 == v15)
  {
LABEL_5:
    a3 = 0LL;
    goto LABEL_6;
  }

  if (v13 < v15)
  {
    unint64_t v16 = v13 + 1;
    *a2 = *(_BYTE *)(v11 + 32 + v13);
    unint64_t v17 = a3 - 1;
    if (a3 == 1)
    {
      ++v13;
      goto LABEL_6;
    }

    unint64_t v18 = a3 - 2;
    if (a3 - 2 >= v15 + ~v13) {
      unint64_t v18 = v15 + ~v13;
    }
    if (v18 < v17) {
      unint64_t v17 = v18;
    }
    unint64_t v19 = v17 + 1;
    if (v19 <= 0x10 || ((unint64_t)&a2[-v13 - v11] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
    {
      uint64_t v20 = 1LL;
      int64_t v21 = a2;
    }

    else
    {
      uint64_t v22 = v19 & 0xF;
      if ((v19 & 0xF) == 0) {
        uint64_t v22 = 16LL;
      }
      unint64_t v23 = v19 - v22;
      uint64_t v20 = v19 - v22 + 1;
      v16 += v23;
      int64_t v21 = &a2[v23];
      uint64_t v24 = a2 + 1;
      uint64_t v25 = (__int128 *)(v13 + v11 + 33);
      do
      {
        __int128 v26 = *v25++;
        *v24++ = v26;
        v23 -= 16LL;
      }

      while (v23);
    }

    int64_t v27 = v21 + 1;
    while (a3 != v20)
    {
      if (v15 == v16)
      {
        unint64_t v13 = v15;
        a3 = v20;
        goto LABEL_6;
      }

      ++v20;
      unint64_t v13 = v16 + 1;
      *v27++ = *(_BYTE *)(v11 + 32 + v16++);
      if (a3 == v20) {
        goto LABEL_6;
      }
    }

    __break(1u);
LABEL_28:
    __break(1u);
  }

  __break(1u);
  return result;
}

uint64_t sub_2291A8(void *a1, _BYTE *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v11 = v10;
  unint64_t v13 = v12;
  uint64_t result = sub_1F86D4(a4, a5);
  if (!a2) {
    goto LABEL_5;
  }
  if (!a3)
  {
LABEL_6:
    *a1 = v11;
    a1[1] = v13;
    return a3;
  }

  if (a3 < 0) {
    goto LABEL_28;
  }
  unint64_t v15 = *(void *)(v11 + 16);
  if (v13 == v15)
  {
LABEL_5:
    a3 = 0LL;
    goto LABEL_6;
  }

  if (v13 < v15)
  {
    unint64_t v16 = v13 + 1;
    *a2 = *(_BYTE *)(v11 + 32 + v13);
    unint64_t v17 = a3 - 1;
    if (a3 == 1)
    {
      ++v13;
      goto LABEL_6;
    }

    unint64_t v18 = a3 - 2;
    if (a3 - 2 >= v15 + ~v13) {
      unint64_t v18 = v15 + ~v13;
    }
    if (v18 < v17) {
      unint64_t v17 = v18;
    }
    unint64_t v19 = v17 + 1;
    if (v19 <= 0x10 || ((unint64_t)&a2[-v13 - v11] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
    {
      uint64_t v20 = 1LL;
      int64_t v21 = a2;
    }

    else
    {
      uint64_t v22 = v19 & 0xF;
      if ((v19 & 0xF) == 0) {
        uint64_t v22 = 16LL;
      }
      unint64_t v23 = v19 - v22;
      uint64_t v20 = v19 - v22 + 1;
      v16 += v23;
      int64_t v21 = &a2[v23];
      uint64_t v24 = a2 + 1;
      uint64_t v25 = (__int128 *)(v13 + v11 + 33);
      do
      {
        __int128 v26 = *v25++;
        *v24++ = v26;
        v23 -= 16LL;
      }

      while (v23);
    }

    int64_t v27 = v21 + 1;
    while (a3 != v20)
    {
      if (v15 == v16)
      {
        unint64_t v13 = v15;
        a3 = v20;
        goto LABEL_6;
      }

      ++v20;
      unint64_t v13 = v16 + 1;
      *v27++ = *(_BYTE *)(v11 + 32 + v16++);
      if (a3 == v20) {
        goto LABEL_6;
      }
    }

    __break(1u);
LABEL_28:
    __break(1u);
  }

  __break(1u);
  return result;
}

uint64_t sub_22931C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  int64_t v6 = v3[2];
  __int128 v30 = *(_OWORD *)(v3 + 3);
  if (!a2) {
    goto LABEL_5;
  }
  uint64_t v7 = a3;
  if (!a3)
  {
LABEL_6:
    *(void *)uint64_t result = v4;
    *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
    *(void *)(result + 16) = v6;
    *(_OWORD *)(result + 24) = v30;
    return v7;
  }

  if (a3 < 0) {
    goto LABEL_68;
  }
  int64_t v8 = (unint64_t)v30 >> 1;
  if (v6 == (unint64_t)v30 >> 1)
  {
LABEL_5:
    uint64_t v7 = 0LL;
    goto LABEL_6;
  }

  uint64_t v29 = v4;
  uint64_t v26 = result;
  if (v6 >= (uint64_t)((unint64_t)v30 >> 1))
  {
LABEL_48:
    __break(1u);
LABEL_49:
    uint64_t result = v26;
    uint64_t v4 = v29;
    uint64_t v5 = v31;
    goto LABEL_6;
  }

  uint64_t v9 = a2;
  uint64_t v27 = v5 + 104;
  uint64_t v10 = 1LL;
  uint64_t v31 = v5;
  while (1)
  {
    if (v8 <= v6) {
      goto LABEL_53;
    }
    uint64_t v11 = (char *)(v5 + 48 * v6);
    char v12 = *v11;
    int64_t v13 = v6 + 1;
    if ((*v11 & 0x20) == 0)
    {
      uint64_t result = *((void *)v11 + 2);
      if (!result) {
        goto LABEL_70;
      }
      uint64_t v5 = *((void *)v11 + 3);
      int64_t v14 = *((void *)v11 + 4);
      uint64_t v15 = *((void *)v11 + 5);
      uint64_t result = swift_unknownObjectRetain(result);
      uint64_t v16 = 0LL;
      int64_t v6 = v13;
      goto LABEL_45;
    }

    uint64_t v16 = *((void *)v11 + 1);
    int64_t v17 = (unint64_t)v30 >> 1;
    if (v13 != v8) {
      break;
    }
LABEL_25:
    int64_t v20 = v17 - v13;
    if (__OFSUB__(v17, v13)) {
      goto LABEL_58;
    }
    if (v20 < 0) {
      goto LABEL_59;
    }
    int64_t v21 = v8 - v13;
    if (__OFSUB__(v8, v13)) {
      goto LABEL_60;
    }
    if (!v20 || v21 < 0 || (int64_t v22 = (unint64_t)v30 >> 1, v21 >= v20))
    {
      int64_t v22 = v17;
      if (__OFADD__(v13, v20)) {
        goto LABEL_63;
      }
      if (v8 < v17) {
        goto LABEL_61;
      }
    }

    if (v22 <= v6) {
      goto LABEL_62;
    }
    if (v13 != v17)
    {
      if (v13 >= v17) {
        goto LABEL_65;
      }
      uint64_t v23 = *(void *)(v5 + 48 * v13 + 8);
      if (v16 >= v23) {
        goto LABEL_66;
      }
      int64_t v24 = v6 + 2;
      if (v6 + 2 != v17)
      {
        if (v6 + 2 >= v17) {
          goto LABEL_69;
        }
        uint64_t v25 = (void *)(v27 + 48 * v6);
        while (v24 > v6)
        {
          if (v16 >= *v25) {
            goto LABEL_52;
          }
          ++v24;
          v25 += 6;
          if (v17 == v24) {
            goto LABEL_43;
          }
        }

        __break(1u);
LABEL_52:
        __break(1u);
LABEL_53:
        __break(1u);
        goto LABEL_54;
      }

size_t sub_229614(size_t *a1, _BYTE *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v22[0] = a4;
  v22[1] = a5;
  uint64_t v23 = a6;
  size_t v9 = sub_23EEF8((size_t)v22, (unint64_t)&v23 + 4);
  if (a2)
  {
    if (a3)
    {
      if ((a3 & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
      size_t v10 = *(void *)(v9 + 16);
      if (v10)
      {
        *a2 = *(_BYTE *)(v9 + 32);
        unint64_t v11 = a3 - 1;
        if (a3 != 1)
        {
          if (v10 - 1 < v11) {
            unint64_t v11 = v10 - 1;
          }
          if (v11 >= a3 - 2) {
            unint64_t v11 = a3 - 2;
          }
          unint64_t v12 = v11 + 1;
          if (v12 <= 0x10 || ((unint64_t)&a2[-v9] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
          {
            uint64_t v13 = 1LL;
            int64_t v14 = a2;
          }

          else
          {
            uint64_t v15 = v12 & 0xF;
            if ((v12 & 0xF) == 0) {
              uint64_t v15 = 16LL;
            }
            unint64_t v16 = v12 - v15;
            uint64_t v13 = v12 - v15 + 1;
            int64_t v14 = &a2[v16];
            int64_t v17 = a2 + 1;
            unint64_t v18 = (__int128 *)(v9 + 33);
            do
            {
              __int128 v19 = *v18++;
              *v17++ = v19;
              v16 -= 16LL;
            }

            while (v16);
          }

          int64_t v20 = v14 + 1;
          while (a3 != v13)
          {
            if (v10 == v13) {
              goto LABEL_23;
            }
            *v20++ = *(_BYTE *)(v9 + 32 + v13);
            if (a3 == ++v13) {
              goto LABEL_24;
            }
          }

          __break(1u);
LABEL_26:
          __break(1u);
        }
      }

      else
      {
LABEL_23:
        a3 = v10;
      }
    }
  }

  else
  {
    a3 = 0LL;
  }

size_t sub_229770(size_t *a1, _BYTE *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  v21[0] = a4;
  v21[1] = a5;
  size_t v8 = sub_23EEF8((size_t)v21, (unint64_t)&v22);
  if (a2)
  {
    if (a3)
    {
      if ((a3 & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
      size_t v9 = *(void *)(v8 + 16);
      if (v9)
      {
        *a2 = *(_BYTE *)(v8 + 32);
        unint64_t v10 = a3 - 1;
        if (a3 != 1)
        {
          if (v9 - 1 < v10) {
            unint64_t v10 = v9 - 1;
          }
          if (v10 >= a3 - 2) {
            unint64_t v10 = a3 - 2;
          }
          unint64_t v11 = v10 + 1;
          if (v11 <= 0x10 || ((unint64_t)&a2[-v8] & 0xFFFFFFFFFFFFFFF0LL) == 0x20)
          {
            uint64_t v12 = 1LL;
            uint64_t v13 = a2;
          }

          else
          {
            uint64_t v14 = v11 & 0xF;
            if ((v11 & 0xF) == 0) {
              uint64_t v14 = 16LL;
            }
            unint64_t v15 = v11 - v14;
            uint64_t v12 = v11 - v14 + 1;
            uint64_t v13 = &a2[v15];
            unint64_t v16 = a2 + 1;
            int64_t v17 = (__int128 *)(v8 + 33);
            do
            {
              __int128 v18 = *v17++;
              *v16++ = v18;
              v15 -= 16LL;
            }

            while (v15);
          }

          __int128 v19 = v13 + 1;
          while (a3 != v12)
          {
            if (v9 == v12) {
              goto LABEL_23;
            }
            *v19++ = *(_BYTE *)(v8 + 32 + v12);
            if (a3 == ++v12) {
              goto LABEL_24;
            }
          }

          __break(1u);
LABEL_26:
          __break(1u);
        }
      }

      else
      {
LABEL_23:
        a3 = v9;
      }
    }
  }

  else
  {
    a3 = 0LL;
  }

void sub_2298C8(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a2;
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82C0);
  __chkstk_darwin(v3, v4);
  int64_t v6 = (uint64_t *)((char *)&v8 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v7 = v2[2];
  uint64_t v9 = *v2;
  *int64_t v6 = v9;
  v6[1] = 0LL;
  __asm { BR              X10 }

uint64_t sub_229960()
{
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82D8);
  ((void (*)(uint64_t, unint64_t, void))Data.Iterator.init(_:at:))(v4, v6, (int)v4);
  sub_1F86D4(v4, v6);
  uint64_t v9 = *(int *)(v8 + 56);
  *(_BYTE *)(v1 + v9) = 0;
  unint64_t v11 = *(void (**)(uint64_t))(v0 + 24);
  uint64_t v10 = *(void (**)(uint64_t))(v0 + 32);
  uint64_t v12 = (void (**)(uint64_t))(v1 + *(int *)(v5 + 44));
  int64_t *v12 = v11;
  v12[1] = v10;
  if (*(void *)(v7 - 96))
  {
    if (v3)
    {
      if (v3 < 0)
      {
        __break(1u);
        JUMPOUT(0x229AFCLL);
      }

      uint64_t v13 = *(void *)(v7 - 104);
      if (*(void *)(v13 + 16))
      {
        *(void *)(v7 - 136) = v9;
        *(void *)(v7 - 12_Block_object_dispose((const void *)(v11 - 96), 8) = v2;
        *(void *)(v7 - 112) = v13 + 32;
        *(void *)(v7 - 120) = type metadata accessor for Data.Iterator(0LL);
        unint64_t v14 = sub_215A8C();
        uint64_t v15 = v3;
        uint64_t v3 = 0LL;
        *(void *)(v7 - 144) = v15;
        uint64_t v2 = v15 - 1;
        while (1)
        {
          char v16 = *(_BYTE *)(*(void *)(v7 - 112) + v3);
          unint64_t v17 = v3 + 1;
          ((void (*)(void, unint64_t))dispatch thunk of IteratorProtocol.next())( *(void *)(v7 - 120),  v14);
          if ((*(_BYTE *)(v7 - 81) & 1) != 0)
          {
            *(void *)(v1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v17;
            goto LABEL_16;
          }

          char v18 = *(_BYTE *)(v7 - 82);
          *(_BYTE *)(v7 - 84) = v16;
          *(_BYTE *)(v7 - 83) = v18;
          v11(v7 - 84);
          *(_BYTE *)(*(void *)(v7 - 96) + v3) = *(_BYTE *)(v7 - 85);
          if (v2 == v3)
          {
            uint64_t v3 = *(void *)(v7 - 144);
            *(void *)(v1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v3;
            uint64_t v2 = *(void *)(v7 - 128);
            goto LABEL_18;
          }

          unint64_t v19 = *(void *)(*(void *)(v7 - 104) + 16LL);
          if (v17 == v19) {
            break;
          }
          ++v3;
          if (v17 >= v19)
          {
            __break(1u);
            goto LABEL_11;
          }
        }

        *(void *)(v1 + _Block_object_dispose((const void *)(v11 - 96), 8) = ++v3;
LABEL_16:
        uint64_t v9 = *(void *)(v7 - 136);
        uint64_t v2 = *(void *)(v7 - 128);
      }

      else
      {
        uint64_t v3 = 0LL;
      }

      *(_BYTE *)(v1 + v9) = 1;
    }
  }

  else
  {
LABEL_11:
    uint64_t v3 = 0LL;
  }

uint64_t sub_229B0C(uint64_t result, _BYTE *a2, uint64_t a3, uint64_t a4, char a5)
{
  if (!a2)
  {
    uint64_t v5 = 0LL;
    goto LABEL_23;
  }

  if (!a3)
  {
LABEL_22:
    uint64_t v5 = a3;
    goto LABEL_23;
  }

  if (a3 < 0)
  {
LABEL_26:
    __break(1u);
    goto LABEL_27;
  }

  uint64_t v5 = a4;
  if (!a4)
  {
LABEL_23:
    *(void *)uint64_t result = a4;
    *(_BYTE *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = a5;
    *(void *)(result + 16) = v5;
    return v5;
  }

  unint64_t v6 = a4 - 1;
  if (a4 >= 1)
  {
    *a2 = a5;
    if (a3 != 1)
    {
      if (a3 - 2 < v6) {
        unint64_t v6 = a3 - 2;
      }
      if (v6 >= a3 - 1) {
        unint64_t v6 = a3 - 1;
      }
      unint64_t v7 = v6 + 1;
      if (v7 > 0x10)
      {
        uint64_t v10 = v7 & 0xF;
        if ((v7 & 0xF) == 0) {
          uint64_t v10 = 16LL;
        }
        unint64_t v11 = v7 - v10;
        uint64_t v8 = v7 - v10 + 1;
        uint64_t v9 = &a2[v11];
        int8x16_t v12 = vdupq_n_s8(a5);
        uint64_t v13 = (int8x16_t *)(a2 + 1);
        do
        {
          *v13++ = v12;
          v11 -= 16LL;
        }

        while (v11);
      }

      else
      {
        uint64_t v8 = 1LL;
        uint64_t v9 = a2;
      }

      unint64_t v14 = v9 + 1;
      while (a3 != v8)
      {
        if (a4 == v8)
        {
          uint64_t v5 = a4;
          goto LABEL_23;
        }

        ++v8;
        *v14++ = a5;
        if (a3 == v8) {
          goto LABEL_22;
        }
      }

      __break(1u);
      goto LABEL_26;
    }

    goto LABEL_22;
  }

uint64_t sub_229BE4@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  int64_t v6 = a4 >> 1;
  if (a4 >> 1 == a3) {
    goto LABEL_10;
  }
  if ((uint64_t)(a4 >> 1) <= a3)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v7 = *(void *)(a2 + 48 * a3 + 8);
  if (v7 <= a5)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  uint64_t v8 = a3 + 1;
  if (a3 + 1 != v6)
  {
    uint64_t v9 = (void *)(a2 + 48 * a3 + 56);
    while (v8 < v6)
    {
      if (*v9 <= a5) {
        goto LABEL_12;
      }
      ++v8;
      v9 += 6;
      if (v6 == v8) {
        goto LABEL_9;
      }
    }

    __break(1u);
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }

uint64_t sub_229C74( uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  int64_t v6 = a3 >> 1;
  uint64_t v7 = (a3 >> 1) - a2;
  if (!__OFSUB__(a3 >> 1, a2))
  {
    int64_t v8 = a6 >> 1;
    if (__OFSUB__(a6 >> 1, a5)) {
      goto LABEL_20;
    }
    if (v7 != (a6 >> 1) - a5) {
      return 0LL;
    }
    if (!v7 || result + a2 == a4 + a5 || v6 == a2) {
      return 1LL;
    }
    if (v6 <= a2) {
      goto LABEL_22;
    }
    uint64_t v9 = a2 + 1;
    int v10 = *(unsigned __int8 *)(result + a2);
    if (v6 == a2) {
      return 1LL;
    }
    uint64_t v11 = a5;
    if (v8 == a5) {
      return 0LL;
    }
    while (v11 >= a5 && v11 < v8)
    {
      if (v6 == v9) {
        return 1LL;
      }
      if (v9 >= v6) {
        goto LABEL_21;
      }
      int v10 = *(unsigned __int8 *)(result + v9++);
      if (v8 == ++v11) {
        return 0LL;
      }
    }

    __break(1u);
  }

  __break(1u);
LABEL_20:
  __break(1u);
LABEL_21:
  __break(1u);
LABEL_22:
  __break(1u);
  return result;
}

BOOL sub_229D48(void *a1, void *a2)
{
  uint64_t v3 = a1[2];
  uint64_t v4 = a2[2];
  if (v3)
  {
    if (v4) {
      return (sub_229C74(a1[3], a1[4], a1[5], a2[3], a2[4], a2[5]) & 1) != 0;
    }
LABEL_8:
    sub_229DE8((uint64_t)a1);
    sub_229DE8((uint64_t)a2);
    swift_unknownObjectRelease(v3);
    swift_unknownObjectRelease(v4);
    return 0LL;
  }

  if (v4) {
    goto LABEL_8;
  }
  return 1LL;
}

uint64_t sub_229DE8(uint64_t a1)
{
  return a1;
}

uint64_t sub_229E10( uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  int64_t v6 = a3 >> 1;
  uint64_t v7 = (a3 >> 1) - a2;
  if (__OFSUB__(a3 >> 1, a2))
  {
    __break(1u);
LABEL_34:
    __break(1u);
LABEL_35:
    __break(1u);
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }

  uint64_t v8 = a5;
  int64_t v9 = a6 >> 1;
  if (__OFSUB__(a6 >> 1, a5)) {
    goto LABEL_34;
  }
  if (v7 != (a6 >> 1) - a5)
  {
    char v13 = 0;
    return v13 & 1;
  }

  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v11 = result;
  int8x16_t v12 = (unsigned __int8 *)(result + 48 * a2);
  if (v6 <= a2)
  {
LABEL_37:
    __break(1u);
    return result;
  }

  uint64_t v14 = *v12;
  uint64_t v15 = (void *)(result + 48 * a2);
  uint64_t v17 = v15[4];
  unint64_t v16 = v15[5];
  uint64_t v18 = v15[2];
  uint64_t v35 = a2 + 1;
  uint64_t v37 = v15[3];
  uint64_t v38 = v15[1];
  uint64_t result = swift_unknownObjectRetain(v18);
  uint64_t v19 = v35;
  if (v18 == 1)
  {
LABEL_11:
    char v13 = 1;
    return v13 & 1;
  }

  uint64_t v20 = 0LL;
  uint64_t v36 = a4 + 48 * v8;
  uint64_t v32 = v11 + 48 * v19;
  uint64_t v33 = v9;
  uint64_t v21 = v8;
  while (1)
  {
    if (v9 == v21)
    {
      sub_22A59C(v14, v38, v18);
      uint64_t v29 = 0LL;
      uint64_t v30 = 0LL;
      uint64_t v31 = 1LL;
      goto LABEL_31;
    }

    if (v21 < v8 || v21 >= v9) {
      goto LABEL_35;
    }
    uint64_t v22 = (void *)(v36 + v20);
    if (*(unsigned __int8 *)(v36 + v20) != v14 || v38 != v22[1])
    {
      uint64_t v29 = v14;
      uint64_t v30 = v38;
      uint64_t v31 = v18;
LABEL_31:
      sub_22A59C(v29, v30, v31);
      char v13 = 0;
      return v13 & 1;
    }

    uint64_t v23 = v22[2];
    if (!v18) {
      break;
    }
    if (!v23) {
      goto LABEL_32;
    }
    uint64_t v34 = v18;
    uint64_t v24 = v20;
    char v13 = sub_229C74(v37, v17, v16, v22[3], v22[4], v22[5]);
    uint64_t result = sub_22A59C(v14, v38, v34);
    if ((v13 & 1) == 0 || v6 == v19) {
      return v13 & 1;
    }
LABEL_26:
    if (v19 >= v6) {
      goto LABEL_36;
    }
    uint64_t v25 = v6;
    uint64_t v26 = v8;
    uint64_t v27 = v24 + 48;
    ++v19;
    ++v21;
    uint64_t v28 = v32 + v24;
    uint64_t v14 = *(unsigned __int8 *)(v32 + v24);
    uint64_t v17 = *(void *)(v32 + v24 + 32);
    unint64_t v16 = *(void *)(v32 + v24 + 40);
    uint64_t v18 = *(void *)(v32 + v24 + 16);
    uint64_t v37 = *(void *)(v28 + 24);
    uint64_t v38 = *(void *)(v28 + 8);
    uint64_t result = swift_unknownObjectRetain(v18);
    char v13 = 1;
    uint64_t v20 = v27;
    uint64_t v8 = v26;
    int64_t v6 = v25;
    int64_t v9 = v33;
    if (v18 == 1) {
      return v13 & 1;
    }
  }

  if (!v23)
  {
    uint64_t v24 = v20;
    uint64_t result = sub_22A59C(v14, v38, 0LL);
    if (v6 == v19) {
      goto LABEL_11;
    }
    goto LABEL_26;
  }

uint64_t sub_22A0C0(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v5 = a4 >> 1;
  int64_t v6 = _swiftEmptyArrayStorage;
  if (a4 >> 1 != a3)
  {
    char v7 = a4;
    uint64_t v8 = a3;
    uint64_t v10 = result;
    uint64_t result = swift_unknownObjectRetain(result);
    if (v5 <= v8)
    {
LABEL_60:
      __break(1u);
LABEL_61:
      uint64_t result = swift_unknownObjectRelease(v10);
      goto LABEL_62;
    }

    uint64_t v4 = 0LL;
    uint64_t v45 = v7 & 1;
    uint64_t v46 = v5;
    uint64_t v43 = a2 + 104;
    uint64_t v44 = v10;
    uint64_t v11 = &_swiftEmptyArrayStorage[4];
    uint64_t v47 = a2;
    while (1)
    {
      if (v5 <= v8) {
        goto LABEL_68;
      }
      int8x16_t v12 = (char *)(a2 + 48 * v8);
      uint64_t v13 = v8 + 1;
      char v50 = *v12;
      if ((*v12 & 0x20) != 0) {
        break;
      }
      uint64_t v14 = *((void *)v12 + 2);
      if (!v14) {
        goto LABEL_87;
      }
      uint64_t v15 = *((void *)v12 + 4);
      uint64_t v48 = *((void *)v12 + 3);
      uint64_t v16 = *((void *)v12 + 5);
      uint64_t result = swift_unknownObjectRetain(v14);
      uint64_t v17 = 0LL;
      uint64_t v18 = v13;
      uint64_t v13 = v15;
      if (!v4) {
        goto LABEL_43;
      }
      uint64_t v49 = v16;
      uint64_t v8 = v18;
      uint64_t v13 = v15;
LABEL_56:
      a2 = v47;
      uint64_t v27 = v48;
LABEL_57:
      BOOL v39 = __OFSUB__(v4--, 1LL);
      if (v39) {
        goto LABEL_70;
      }
      *(_BYTE *)uint64_t v11 = v50;
      v11[1] = v14;
      void v11[2] = v27;
      v11[3] = v13;
      v11[4] = v49;
      v11[5] = v17;
      *((_BYTE *)v11 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = (v50 & 0x20) == 0;
      int64_t v5 = v46;
      if (v8 == v46) {
        goto LABEL_61;
      }
      v11 += 7;
      if (v8 >= v46) {
        goto LABEL_60;
      }
    }

    uint64_t v17 = *((void *)v12 + 1);
    uint64_t v19 = v5;
    if (v13 != v5)
    {
      if (v13 >= v5) {
        goto LABEL_81;
      }
      uint64_t v19 = v8 + 1;
      if (v17 < *(void *)(a2 + 48 * v13 + 8))
      {
        uint64_t v19 = v5;
        if (v8 + 2 != v5)
        {
          uint64_t v20 = (void *)(v43 + 48 * v8);
          uint64_t v19 = v8 + 2;
          while (v19 < v5)
          {
            if (v17 >= *v20) {
              goto LABEL_20;
            }
            uint64_t v21 = v19 + 1;
            if (__OFADD__(v19, 1LL)) {
              goto LABEL_71;
            }
            ++v19;
            v20 += 6;
            if (v21 == v5)
            {
              uint64_t v19 = v5;
              goto LABEL_20;
            }
          }

void sub_22A4AC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v4 = a4 >> 1;
  if (__OFSUB__(a4 >> 1, a3))
  {
LABEL_18:
    __break(1u);
    return;
  }

  uint64_t v5 = a3;
  Hasher._combine(_:)((a4 >> 1) - a3);
  if (v4 != v5)
  {
    while (v5 < v4)
    {
      uint64_t v7 = a2 + 48 * v5;
      uint64_t v8 = *(void *)(v7 + 24);
      uint64_t v9 = *(void *)(v7 + 32);
      unint64_t v10 = *(void *)(v7 + 40);
      Swift::UInt v11 = *(void *)(v7 + 8);
      uint64_t v12 = *(void *)(v7 + 16);
      Hasher._combine(_:)(*(_BYTE *)v7);
      Hasher._combine(_:)(v11);
      if (v12)
      {
        Hasher._combine(_:)(1u);
        unint64_t v13 = v10 >> 1;
        if (__OFSUB__(v10 >> 1, v9)) {
          goto LABEL_16;
        }
        Hasher._combine(_:)((v10 >> 1) - v9);
        BOOL v14 = __OFSUB__(v13, v9);
        uint64_t v15 = v13 - v9;
        if (v15)
        {
          if ((v15 < 0) ^ v14 | (v15 == 0)) {
            goto LABEL_17;
          }
          uint64_t v16 = (Swift::UInt8 *)(v8 + v9);
          do
          {
            Swift::UInt8 v17 = *v16++;
            Hasher._combine(_:)(v17);
            --v15;
          }

          while (v15);
        }
      }

      else
      {
        Hasher._combine(_:)(0);
      }

      if (++v5 == v4) {
        return;
      }
    }

    __break(1u);
LABEL_16:
    __break(1u);
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

uint64_t sub_22A59C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 1) {
    return swift_unknownObjectRelease(a3);
  }
  return result;
}

uint64_t sub_22A5B0(char a1, char **a2, uint64_t (*a3)(char **), uint64_t a4)
{
  return sub_22A8C0(a1, a2, a3, a4);
}

uint64_t sub_22A5C4(char a1, char **a2, uint64_t a3)
{
  LOBYTE(v7) = a1;
  uint64_t v8 = *a2;
  if ((swift_isUniquelyReferenced_nonNull_native(*a2) & 1) == 0) {
    goto LABEL_35;
  }
  while (1)
  {
    unint64_t v10 = *((void *)v8 + 2);
    unint64_t v9 = *((void *)v8 + 3);
    int64_t v11 = v9 >> 1;
    unint64_t v12 = v10 + 1;
    if (v9 >> 1 <= v10)
    {
      uint64_t v8 = sub_2121E4((char *)(v9 > 1), v10 + 1, 1, v8);
      unint64_t v9 = *((void *)v8 + 3);
      int64_t v11 = v9 >> 1;
    }

    *((void *)v8 + 2) = v12;
    v8[v10 + 32] = v7;
    unint64_t v7 = v10 + 2;
    *((void *)v8 + 2) = v7;
    v8[v12 + 32] = 0;
    *a2 = v8;
    unint64_t v13 = v10 + 1;
    if (__OFSUB__(v7, 1LL))
    {
      __break(1u);
      goto LABEL_37;
    }

    uint64_t result = sub_227A64((uint64_t)a2, a3);
    if (v3) {
      return result;
    }
    a3 = (uint64_t)*a2;
    unint64_t v15 = *((void *)*a2 + 2);
    unint64_t v10 = v15 - v7;
    if (v15 >= v7)
    {
      unint64_t v4 = 71 - __clz(v10);
      uint64_t v8 = (char *)(v4 >> 3);
      sub_227D0C(v4 >> 3, v7, v15);
      a3 = (uint64_t)*a2;
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
      if ((result & 1) != 0) {
        goto LABEL_11;
      }
      goto LABEL_38;
    }

uint64_t sub_22A8C0(char a1, char **a2, uint64_t (*a3)(char **), uint64_t a4)
{
  LOBYTE(v_Block_object_dispose((const void *)(v11 - 96), 8) = a1;
  unint64_t v9 = *a2;
  if ((swift_isUniquelyReferenced_nonNull_native(*a2) & 1) == 0) {
    goto LABEL_35;
  }
  while (1)
  {
    unint64_t v11 = *((void *)v9 + 2);
    unint64_t v10 = *((void *)v9 + 3);
    int64_t v12 = v10 >> 1;
    unint64_t v13 = v11 + 1;
    if (v10 >> 1 <= v11)
    {
      unint64_t v9 = sub_2121E4((char *)(v10 > 1), v11 + 1, 1, v9);
      unint64_t v10 = *((void *)v9 + 3);
      int64_t v12 = v10 >> 1;
    }

    *((void *)v9 + 2) = v13;
    v9[v11 + 32] = v8;
    unint64_t v8 = v11 + 2;
    *((void *)v9 + 2) = v8;
    v9[v13 + 32] = 0;
    *a2 = v9;
    unint64_t v9 = (char *)(v11 + 1);
    if (__OFSUB__(v8, 1LL))
    {
      __break(1u);
      goto LABEL_37;
    }

    uint64_t result = a3(a2);
    if (v4) {
      return result;
    }
    a4 = (uint64_t)*a2;
    unint64_t v15 = *((void *)*a2 + 2);
    unint64_t v13 = v15 - v8;
    if (v15 >= v8)
    {
      unint64_t v11 = 71 - __clz(v13);
      a3 = (uint64_t (*)(char **))(v11 >> 3);
      sub_227D0C(v11 >> 3, v8, v15);
      a4 = (uint64_t)*a2;
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
      if ((result & 1) != 0) {
        goto LABEL_11;
      }
      goto LABEL_38;
    }

void sub_22ABC0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int64_t v5 = a4 >> 1;
  int64_t v6 = a3;
  if (a4 >> 1 != a3)
  {
    unint64_t v7 = (void *)(a2 + 48 * a3 + 8);
    int64_t v6 = a3;
    while (1)
    {
      if (v6 >= v5)
      {
        __break(1u);
        goto LABEL_13;
      }

      if (*v7 <= a5) {
        break;
      }
      ++v6;
      v7 += 6;
      if (v5 == v6)
      {
        int64_t v6 = a4 >> 1;
        break;
      }
    }

    if (v6 >= a3) {
      goto LABEL_8;
    }
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

char *sub_22AC40@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result = sub_226E34(a1, a2, a3, a4);
  if (!v5)
  {
    unint64_t v11 = v10;
    unint64_t v12 = v10 >> 1;
    if (v9 == v10 >> 1)
    {
      __break(1u);
    }

    else if (v9 < (uint64_t)(v10 >> 1))
    {
      uint64_t v13 = (uint64_t)result;
      uint64_t v14 = v8;
      uint64_t v15 = v8 + 48 * v9;
      char v16 = *(_BYTE *)v15;
      int64_t v17 = v9 + 1;
      if ((*(_BYTE *)v15 & 0x20) != 0)
      {
        uint64_t v32 = *(void *)(v15 + 8);
        sub_22ABC0((uint64_t)result, v8, v9 + 1, v10, v32);
        uint64_t v30 = v21;
        uint64_t v35 = v22;
        uint64_t result = (char *)((v20 >> 1) - v19);
        if (__OFSUB__(v20 >> 1, v19))
        {
LABEL_17:
          __break(1u);
          goto LABEL_18;
        }

        uint64_t v23 = v19;
        unint64_t v24 = v20;
        uint64_t v25 = sub_216834((uint64_t)result, v13, v14, v17, v11);
        int64_t v17 = v26;
        unint64_t v28 = v27;
        sub_229BE4(v30, v35, v23, v24, v32, v33);
        __int128 v29 = v33[1];
        __int128 v31 = v33[0];
        uint64_t v18 = v34;
        swift_unknownObjectRetain(v13);
        uint64_t result = (char *)swift_unknownObjectRelease(v25);
        unint64_t v12 = v28 >> 1;
      }

      else
      {
        __int128 v31 = *(_OWORD *)(v15 + 16);
        uint64_t result = *(char **)(v15 + 16);
        if (!(void)v31)
        {
LABEL_18:
          __break(1u);
          return result;
        }

        __int128 v29 = *(_OWORD *)(v15 + 32);
        swift_unknownObjectRetain(result);
        uint64_t result = (char *)swift_unknownObjectRelease(v13);
        uint64_t v18 = 0LL;
      }

      if (!__OFSUB__(v12, v17))
      {
        if (v12 == v17)
        {
          *(_BYTE *)a5 = v16;
          *(_OWORD *)(a5 + _Block_object_dispose((const void *)(v11 - 96), 8) = v31;
          *(_OWORD *)(a5 + 24) = v29;
          *(void *)(a5 + 40) = v18;
          *(_BYTE *)(a5 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = (v16 & 0x20) == 0;
          return result;
        }

        goto LABEL_16;
      }

uint64_t sub_22ADD8(char a1, char **a2, char *a3)
{
  LOBYTE(v7) = a1;
  uint64_t v8 = *a2;
  if ((swift_isUniquelyReferenced_nonNull_native(*a2) & 1) == 0) {
    goto LABEL_35;
  }
  while (1)
  {
    unint64_t v10 = *((void *)v8 + 2);
    unint64_t v9 = *((void *)v8 + 3);
    int64_t v11 = v9 >> 1;
    unint64_t v12 = v10 + 1;
    if (v9 >> 1 <= v10)
    {
      uint64_t v8 = sub_2121E4((char *)(v9 > 1), v10 + 1, 1, v8);
      unint64_t v9 = *((void *)v8 + 3);
      int64_t v11 = v9 >> 1;
    }

    *((void *)v8 + 2) = v12;
    v8[v10 + 32] = v7;
    unint64_t v7 = v10 + 2;
    *((void *)v8 + 2) = v7;
    v8[v12 + 32] = 0;
    *a2 = v8;
    unint64_t v13 = v10 + 1;
    if (__OFSUB__(v7, 1LL))
    {
      __break(1u);
      goto LABEL_37;
    }

    uint64_t result = sub_221B80(a2, (uint64_t)a3);
    if (v3) {
      return result;
    }
    a3 = *a2;
    unint64_t v15 = *((void *)*a2 + 2);
    unint64_t v10 = v15 - v7;
    if (v15 >= v7)
    {
      unint64_t v4 = 71 - __clz(v10);
      uint64_t v8 = (char *)(v4 >> 3);
      sub_227D0C(v4 >> 3, v7, v15);
      a3 = *a2;
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
      if ((result & 1) != 0) {
        goto LABEL_11;
      }
      goto LABEL_38;
    }

uint64_t sub_22B0D4(char a1, char **a2, char *a3)
{
  LOBYTE(v7) = a1;
  uint64_t v8 = *a2;
  if ((swift_isUniquelyReferenced_nonNull_native(*a2) & 1) == 0) {
    goto LABEL_35;
  }
  while (1)
  {
    unint64_t v10 = *((void *)v8 + 2);
    unint64_t v9 = *((void *)v8 + 3);
    int64_t v11 = v9 >> 1;
    unint64_t v12 = v10 + 1;
    if (v9 >> 1 <= v10)
    {
      uint64_t v8 = sub_2121E4((char *)(v9 > 1), v10 + 1, 1, v8);
      unint64_t v9 = *((void *)v8 + 3);
      int64_t v11 = v9 >> 1;
    }

    *((void *)v8 + 2) = v12;
    v8[v10 + 32] = v7;
    unint64_t v7 = v10 + 2;
    *((void *)v8 + 2) = v7;
    v8[v12 + 32] = 0;
    *a2 = v8;
    unint64_t v13 = v10 + 1;
    if (__OFSUB__(v7, 1LL))
    {
      __break(1u);
      goto LABEL_37;
    }

    __int128 v14 = *((_OWORD *)a3 + 1);
    v22[0] = *(_OWORD *)a3;
    v22[1] = v14;
    uint64_t v23 = *((void *)a3 + 4);
    uint64_t v25 = *(void *)&v22[0];
    sub_222AE4((uint64_t)v22 + 8, (uint64_t)v24, &qword_3A8950);
    sub_222914(&v25);
    sub_225830(v24);
    uint64_t result = sub_2276DC(48LL, a2, (char *)v22);
    if (v3) {
      return result;
    }
    uint64_t v8 = (char *)v22;
    *(double *)&__int128 v17 = __chkstk_darwin(result, v16);
    v21[1] = v18;
    void v21[2] = v17;
    sub_22A8C0(3, a2, sub_2229FC, (uint64_t)v21);
    a3 = *a2;
    unint64_t v19 = *((void *)*a2 + 2);
    unint64_t v10 = v19 - v7;
    if (v19 >= v7)
    {
      unint64_t v4 = 71 - __clz(v10);
      uint64_t v8 = (char *)(v4 >> 3);
      sub_227D0C(v4 >> 3, v7, v19);
      a3 = *a2;
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
      if ((result & 1) != 0) {
        goto LABEL_11;
      }
      goto LABEL_38;
    }

uint64_t sub_22B468(char a1, char **a2, char *a3)
{
  LOBYTE(v7) = a1;
  uint64_t v8 = *a2;
  if ((swift_isUniquelyReferenced_nonNull_native(*a2) & 1) == 0) {
    goto LABEL_35;
  }
  while (1)
  {
    unint64_t v10 = *((void *)v8 + 2);
    unint64_t v9 = *((void *)v8 + 3);
    int64_t v11 = v9 >> 1;
    unint64_t v12 = v10 + 1;
    if (v9 >> 1 <= v10)
    {
      uint64_t v8 = sub_2121E4((char *)(v9 > 1), v10 + 1, 1, v8);
      unint64_t v9 = *((void *)v8 + 3);
      int64_t v11 = v9 >> 1;
    }

    *((void *)v8 + 2) = v12;
    v8[v10 + 32] = v7;
    unint64_t v7 = v10 + 2;
    *((void *)v8 + 2) = v7;
    v8[v12 + 32] = 0;
    *a2 = v8;
    unint64_t v13 = v10 + 1;
    if (__OFSUB__(v7, 1LL))
    {
      __break(1u);
      goto LABEL_37;
    }

    uint64_t result = sub_2254AC(a2, (uint64_t)a3);
    if (v3) {
      return result;
    }
    a3 = *a2;
    unint64_t v15 = *((void *)*a2 + 2);
    unint64_t v10 = v15 - v7;
    if (v15 >= v7)
    {
      unint64_t v4 = 71 - __clz(v10);
      uint64_t v8 = (char *)(v4 >> 3);
      sub_227D0C(v4 >> 3, v7, v15);
      a3 = *a2;
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(*a2);
      if ((result & 1) != 0) {
        goto LABEL_11;
      }
      goto LABEL_38;
    }

uint64_t destroy for ASN1.ASN1Node.Content(uint64_t a1)
{
  return j__swift_unknownObjectRelease( *(void *)a1,  *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t initializeWithCopy for ASN1.ASN1Node.Content(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = a2[3];
  uint64_t v7 = a2[4];
  char v8 = *((_BYTE *)a2 + 40);
  j__swift_unknownObjectRetain(*a2);
  *(void *)a1 = v3;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  *(void *)(a1 + 32) = v7;
  *(_BYTE *)(a1 + 40) = v8;
  return a1;
}

uint64_t *assignWithCopy for ASN1.ASN1Node.Content(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = a2[3];
  uint64_t v7 = a2[4];
  char v8 = *((_BYTE *)a2 + 40);
  j__swift_unknownObjectRetain(*a2);
  uint64_t v9 = *a1;
  uint64_t v10 = a1[1];
  uint64_t v11 = a1[2];
  uint64_t v12 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v14 = *((unsigned __int8 *)a1 + 40);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  *((_BYTE *)a1 + 40) = v8;
  j__swift_unknownObjectRelease(v9, v10, v11, v12, v13, v14);
  return a1;
}

__n128 __swift_memcpy41_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t *assignWithTake for ASN1.ASN1Node.Content(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32);
  char v4 = *(_BYTE *)(a2 + 40);
  uint64_t v5 = *a1;
  uint64_t v7 = a1[1];
  uint64_t v6 = a1[2];
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  uint64_t v10 = *((unsigned __int8 *)a1 + 40);
  __int128 v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *((_OWORD *)a1 + 1) = v11;
  a1[4] = v3;
  *((_BYTE *)a1 + 40) = v4;
  j__swift_unknownObjectRelease(v5, v7, v6, v8, v9, v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for ASN1.ASN1Node.Content(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 41)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1.ASN1Node.Content( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_BYTE *)(result + 40) = 0;
    *(void *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 41) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 41) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 40) = -(char)a2;
    }
  }

  return result;
}

uint64_t sub_22B974(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 40);
}

uint64_t sub_22B97C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 40) = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for ASN1.ASN1Node.Content()
{
  return &type metadata for ASN1.ASN1Node.Content;
}

uint64_t destroy for ASN1.ASN1ParserNode(uint64_t a1)
{
  return swift_unknownObjectRelease(*(void *)(a1 + 16));
}

uint64_t initializeWithCopy for ASN1.ASN1ParserNode(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for ASN1.ASN1ParserNode(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v4;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  return a1;
}

__n128 __swift_memcpy48_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for ASN1.ASN1ParserNode(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = *(void *)(a2 + 8);
  swift_unknownObjectRelease(*(void *)(a1 + 16));
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v4;
  return a1;
}

uint64_t getEnumTagSinglePayload for ASN1.ASN1ParserNode(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 48)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1.ASN1ParserNode(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)(result + 40) = 0LL;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(void *)__n128 result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0;
    }
    if (a2) {
      *(void *)(result + 16) = a2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for ASN1.ASN1ParserNode()
{
  return &type metadata for ASN1.ASN1ParserNode;
}

uint64_t _s7ASN1AnyVwxx(void *a1)
{
  return swift_unknownObjectRelease(*a1);
}

uint64_t _s7ASN1AnyVwcp(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)a1 = *a2;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 1);
  *(void *)(a1 + 24) = a2[3];
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t *_s7ASN1AnyVwca(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  return a1;
}

uint64_t _s7ASN1AnyVwta(uint64_t a1, _OWORD *a2)
{
  __int128 v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t _s7ASN1AnyVwet(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t _s7ASN1AnyVwst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for ASN1.ASN1ParseResult()
{
  return &type metadata for ASN1.ASN1ParseResult;
}

ValueMetadata *type metadata accessor for ASN1.ASN1NodeCollection()
{
  return &type metadata for ASN1.ASN1NodeCollection;
}

ValueMetadata *type metadata accessor for ASN1()
{
  return &type metadata for ASN1;
}

uint64_t destroy for ASN1.ASN1Node(uint64_t a1)
{
  return j__swift_unknownObjectRelease( *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 48));
}

uint64_t initializeWithCopy for ASN1.ASN1Node(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *(void *)(a2 + 40);
  char v8 = *(_BYTE *)(a2 + 48);
  j__swift_unknownObjectRetain(v3);
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v3;
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v7;
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v8;
  return a1;
}

uint64_t assignWithCopy for ASN1.ASN1Node(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *(void *)(a2 + 40);
  char v8 = *(_BYTE *)(a2 + 48);
  j__swift_unknownObjectRetain(v3);
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 40);
  uint64_t v14 = *(unsigned __int8 *)(a1 + 48);
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v3;
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v7;
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v8;
  j__swift_unknownObjectRelease(v9, v10, v11, v12, v13, v14);
  return a1;
}

__n128 __swift_memcpy49_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = *(_BYTE *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for ASN1.ASN1Node(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 40);
  char v4 = *(_BYTE *)(a2 + 48);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 48);
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = v3;
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  j__swift_unknownObjectRelease(v5, v7, v6, v8, v9, v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for ASN1.ASN1Node(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 49)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1.ASN1Node(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)(result + 40) = 0LL;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0;
    *(void *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 49) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 49) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v11 - 96), 8) = -(char)a2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for ASN1.ASN1Node()
{
  return &type metadata for ASN1.ASN1Node;
}

uint64_t _s16CryptoKit_Static4ASN1O18ASN1NodeCollectionVwcp_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)a1 = *a2;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 3);
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t *_s16CryptoKit_Static4ASN1O18ASN1NodeCollectionVwca_0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  return a1;
}

uint64_t _s16CryptoKit_Static4ASN1O18ASN1NodeCollectionVwta_0(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

ValueMetadata *type metadata accessor for ASN1.ASN1NodeCollection.Iterator()
{
  return &type metadata for ASN1.ASN1NodeCollection.Iterator;
}

uint64_t sub_22C050@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned __int16 a6@<W5>, uint64_t a7@<X6>, uint64_t a8@<X7>, size_t *a9@<X8>, char a10)
{
  uint64_t v17 = a6;
  sub_2308A8(a6, 2LL);
  uint64_t v27 = v18;
  unint64_t v28 = v19;
  if (qword_3A7CA8 != -1) {
    swift_once(&qword_3A7CA8, sub_22E778);
  }
  Data.append(_:)(qword_3A8988, unk_3A8990);
  Data.append(_:)(a7, a8);
  Data.append(_:)(a2, a3);
  sub_217428(a4, a5);
  uint64_t v21 = v27;
  unint64_t v20 = v28;
  if (a10)
  {
    sub_1F83C0(v27, v28);
    if (a10 == 1) {
      sub_22DAA8(a1, v28, v17, &v26);
    }
    else {
      sub_22E098(a1, v28, v17, &v26);
    }
  }

  else
  {
    sub_1F83C0(v27, v28);
    sub_22D4EC(a1, v28, v17, &v26);
  }

  uint64_t v22 = v26;
  size_t v23 = sub_2348C8(v26);
  swift_release(v22);
  sub_1F86D4(v21, v20);
  uint64_t result = sub_1F86D4(v21, v20);
  *a9 = v23;
  return result;
}

uint64_t sub_22C1E4@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned __int16 a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X6>, unsigned __int8 *a8@<X7>, size_t *a9@<X8>, uint64_t a10, uint64_t a11)
{
  uint64_t v25 = *a1;
  int v16 = *a8;
  uint64_t v17 = a5;
  sub_2308A8(a5, 2LL);
  uint64_t v28 = v18;
  unint64_t v29 = v19;
  if (qword_3A7CA8 != -1) {
    swift_once(&qword_3A7CA8, sub_22E778);
  }
  Data.append(_:)(xmmword_3A8988, *((void *)&xmmword_3A8988 + 1));
  Data.append(_:)(a6, a7);
  Data.append(_:)(a2, a3);
  Data.append<A>(contentsOf:)(a4, a10, *(void *)(*(void *)(*(void *)(*(void *)(a11 + 8) + 8LL) + 8LL) + 8LL));
  uint64_t v21 = v28;
  unint64_t v20 = v29;
  if (v16)
  {
    sub_1F83C0(v28, v29);
    if (v16 == 1) {
      sub_22DAA8(v25, v29, v17, &v27);
    }
    else {
      sub_22E098(v25, v29, v17, &v27);
    }
  }

  else
  {
    sub_1F83C0(v28, v29);
    sub_22D4EC(v25, v29, v17, &v27);
  }

  uint64_t v22 = v27;
  size_t v23 = sub_2348C8(v27);
  swift_release(v22);
  sub_1F86D4(v21, v20);
  uint64_t result = sub_1F86D4(v21, v20);
  *a9 = v23;
  return result;
}

uint64_t sub_22C388@<X0>( uint64_t a1@<X0>, uint64_t (*a2)(void)@<X1>, uint64_t *a3@<X2>, void (*a4)(uint64_t, uint64_t)@<X3>, char *a5@<X4>, _OWORD *a6@<X8>)
{
  unint64_t v12 = *(void *)(a1 + 16);
  if (v12 == 128)
  {
    unint64_t v40 = &type metadata for SymmetricKey;
    unint64_t v41 = sub_2122CC();
    v39[0] = a1;
    goto LABEL_11;
  }

  if (v12 > 0x80)
  {
    uint64_t v13 = static Array._allocateBufferUninitialized(minimumCapacity:)(128LL, &type metadata for UInt8);
    *(void *)(v13 + 16) = 128LL;
    *(_OWORD *)(v13 + 32) = 0u;
    *(_OWORD *)(v13 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(v13 + 64) = 0u;
    *(_OWORD *)(v13 + 80) = 0u;
    *(_OWORD *)(v13 + 96) = 0u;
    *(_OWORD *)(v13 + 112) = 0u;
    *(_OWORD *)(v13 + 12_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(v13 + 144) = 0u;
    uint64_t v37 = v13;
    ((void (*)(__int128 *__return_ptr, uint64_t, uint64_t, uint64_t *))a5)( v36,  a1 + 32,  a1 + 32 + *(void *)(a1 + 16),  &v37);
    swift_release(a1);
    sub_1F8384(v36, (uint64_t)v39);
    swift_bridgeObjectRelease(v37);
    goto LABEL_11;
  }

  uint64_t v14 = static Array._allocateBufferUninitialized(minimumCapacity:)(128LL, &type metadata for UInt8);
  *(void *)(v14 + 16) = 128LL;
  *(_OWORD *)(v14 + 32) = 0u;
  *(_OWORD *)(v14 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
  *(_OWORD *)(v14 + 64) = 0u;
  *(_OWORD *)(v14 + 80) = 0u;
  *(_OWORD *)(v14 + 96) = 0u;
  *(_OWORD *)(v14 + 112) = 0u;
  *(_OWORD *)(v14 + 12_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
  *(_OWORD *)(v14 + 144) = 0u;
  size_t v15 = *(void *)(a1 + 16);
  if (v15 > 0x80)
  {
    __break(1u);
LABEL_15:
    a5 = sub_2121E4((_BYTE *)&dword_0 + 1, 128LL, 1, a5);
    if (!v15) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  a5 = (char *)v14;
  if (*(void *)(v14 + 24) <= 0xFFuLL) {
    goto LABEL_15;
  }
  if (v15) {
LABEL_9:
  }
    memcpy(a5 + 32, (const void *)(a1 + 32), v15);
LABEL_10:
  swift_release(a1);
  unint64_t v40 = (ValueMetadata *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  unint64_t v41 = sub_215958();
  v39[0] = a5;
LABEL_11:
  uint64_t result = a2();
  if (result)
  {
    uint64_t v17 = result;
    uint64_t v18 = __swift_instantiateConcreteTypeFromMangledName(a3);
    uint64_t v19 = swift_allocObject(v18, 32LL, 7LL);
    uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v17);
    uint64_t v21 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
    ccdigest_init(v17, v21);
    *(void *)(v19 + 16) = v17;
    *(void *)(v19 + 24) = v21;
    *((void *)&v36[0] + 1) = v19;
    uint64_t v22 = v40;
    unint64_t v23 = v41;
    __swift_project_boxed_opaque_existential_1(v39, (uint64_t)v40);
    uint64_t v24 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
    dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_2113C8, 0LL, v24, v22, v23);
    uint64_t v25 = v37;
    uint64_t v26 = Array<A>.regions.getter(v37);
    a4(v26 + 32, v26 + 32 + *(void *)(v26 + 16));
    swift_bridgeObjectRelease(v25);
    uint64_t v27 = swift_bridgeObjectRelease(v26);
    uint64_t result = ((uint64_t (*)(uint64_t))a2)(v27);
    if (result)
    {
      uint64_t v28 = result;
      uint64_t v29 = swift_allocObject(v18, 32LL, 7LL);
      uint64_t v30 = getDigestSizeForDigestInfo(v28);
      __int128 v31 = (void *)swift_slowAlloc(v30, -1LL);
      ccdigest_init(v28, v31);
      *(void *)(v29 + 16) = v28;
      *(void *)(v29 + 24) = v31;
      *(void *)&v36[0] = v29;
      uint64_t v32 = v40;
      unint64_t v33 = v41;
      __swift_project_boxed_opaque_existential_1(v39, (uint64_t)v40);
      dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_2114C0, 0LL, v24, v32, v33);
      uint64_t v34 = v37;
      uint64_t v35 = Array<A>.regions.getter(v37);
      a4(v35 + 32, v35 + 32 + *(void *)(v35 + 16));
      swift_bridgeObjectRelease(v35);
      __swift_destroy_boxed_opaque_existential_1Tm(v39);
      uint64_t result = swift_bridgeObjectRelease(v34);
      *a6 = v36[0];
      return result;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

void *sub_22C6B8@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 == 64)
  {
    uint64_t v32 = &type metadata for SymmetricKey;
    unint64_t v33 = sub_2122CC();
    v31[0] = a1;
    goto LABEL_11;
  }

  if (v5 > 0x40)
  {
    uint64_t v6 = static Array._allocateBufferUninitialized(minimumCapacity:)(64LL, &type metadata for UInt8);
    *(void *)(v6 + 16) = 64LL;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 80) = 0u;
    uint64_t v29 = (char *)v6;
    sub_22CCB4((char *)(a1 + 32), a1 + 32 + *(void *)(a1 + 16), &v29, (char **)v28);
    swift_release(a1);
    sub_1F8384(v28, (uint64_t)v31);
    swift_bridgeObjectRelease(v29);
    goto LABEL_11;
  }

  uint64_t v7 = static Array._allocateBufferUninitialized(minimumCapacity:)(64LL, &type metadata for UInt8);
  *(void *)(v7 + 16) = 64LL;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
  *(_OWORD *)(v7 + 64) = 0u;
  *(_OWORD *)(v7 + 80) = 0u;
  size_t v8 = *(void *)(a1 + 16);
  if (v8 > 0x40)
  {
    __break(1u);
LABEL_15:
    uint64_t v2 = sub_2121E4((_BYTE *)&dword_0 + 1, 64LL, 1, v2);
    if (!v8) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  uint64_t v2 = (char *)v7;
  if (*(void *)(v7 + 24) <= 0x7FuLL) {
    goto LABEL_15;
  }
  if (v8) {
LABEL_9:
  }
    memcpy(v2 + 32, (const void *)(a1 + 32), v8);
LABEL_10:
  swift_release(a1);
  uint64_t v32 = (ValueMetadata *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  unint64_t v33 = sub_215958();
  v31[0] = v2;
LABEL_11:
  uint64_t result = ccsha256_di();
  if (result)
  {
    uint64_t v10 = (uint64_t)result;
    uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A87E8);
    uint64_t v12 = swift_allocObject(v11, 32LL, 7LL);
    uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v10);
    uint64_t v14 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
    ccdigest_init(v10, v14);
    *(void *)(v12 + 16) = v10;
    *(void *)(v12 + 24) = v14;
    *((void *)&v28[0] + 1) = v12;
    size_t v15 = v32;
    unint64_t v16 = v33;
    __swift_project_boxed_opaque_existential_1(v31, (uint64_t)v32);
    uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
    dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_2113C8, 0LL, v17, v15, v16);
    uint64_t v18 = v29;
    uint64_t v19 = Array<A>.regions.getter(v29);
    sub_21D3B0((char *)(v19 + 32), v19 + 32 + *(void *)(v19 + 16));
    swift_bridgeObjectRelease(v18);
    swift_bridgeObjectRelease(v19);
    uint64_t result = ccsha256_di();
    if (result)
    {
      uint64_t v20 = (uint64_t)result;
      uint64_t v21 = swift_allocObject(v11, 32LL, 7LL);
      uint64_t v22 = getDigestSizeForDigestInfo(v20);
      unint64_t v23 = (void *)swift_slowAlloc(v22, -1LL);
      ccdigest_init(v20, v23);
      *(void *)(v21 + 16) = v20;
      *(void *)(v21 + 24) = v23;
      *(void *)&v28[0] = v21;
      uint64_t v24 = v32;
      unint64_t v25 = v33;
      __swift_project_boxed_opaque_existential_1(v31, (uint64_t)v32);
      dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_2114C0, 0LL, v17, v24, v25);
      uint64_t v26 = v29;
      uint64_t v27 = Array<A>.regions.getter(v29);
      sub_21D3B0((char *)(v27 + 32), v27 + 32 + *(void *)(v27 + 16));
      swift_bridgeObjectRelease(v27);
      __swift_destroy_boxed_opaque_existential_1Tm(v31);
      uint64_t result = (void *)swift_bridgeObjectRelease(v26);
      *a2 = v28[0];
      return result;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

uint64_t sub_22C9CC@<X0>(char *a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, char **a4@<X8>)
{
  uint64_t v7 = ccsha512_di();
  if (!v7) {
    __break(1u);
  }
  uint64_t v8 = (uint64_t)v7;
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A87D8);
  uint64_t v10 = swift_allocObject(v9, 32LL, 7LL);
  uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v8);
  uint64_t v12 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
  ccdigest_init(v8, v12);
  *(void *)(v10 + 16) = v8;
  *(void *)(v10 + 24) = v12;
  sub_21D398(a1, a2);
  sub_21D81C(&v25);
  swift_release(v10);
  __int128 v13 = v25;
  uint64_t v14 = v26;
  uint64_t v15 = v27;
  uint64_t v17 = v28;
  uint64_t v16 = v29;
  uint64_t v18 = v30;
  uint64_t v23 = v31;
  uint64_t v19 = *a3;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*a3);
  *a3 = v19;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    uint64_t v19 = sub_2121E4(0LL, *((void *)v19 + 2), 0, v19);
  }
  *a3 = v19;
  *((_OWORD *)v19 + 2) = v13;
  *((void *)v19 + 6) = v14;
  *((void *)v19 + 7) = v15;
  *((void *)v19 + _Block_object_dispose((const void *)(v11 - 96), 8) = v17;
  *((void *)v19 + 9) = v16;
  *((void *)v19 + 10) = v18;
  *((void *)v19 + 11) = v23;
  uint64_t v21 = *a3;
  a4[3] = (char *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  a4[4] = (char *)sub_215958();
  *a4 = v21;
  return swift_bridgeObjectRetain(v21);
}

uint64_t sub_22CB48@<X0>(char *a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, char **a4@<X8>)
{
  uint64_t v8 = ccsha384_di();
  if (!v8) {
    __break(1u);
  }
  uint64_t v9 = (uint64_t)v8;
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A87E0);
  uint64_t v11 = swift_allocObject(v10, 32LL, 7LL);
  uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v9);
  __int128 v13 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
  ccdigest_init(v9, v13);
  *(void *)(v11 + 16) = v9;
  *(void *)(v11 + 24) = v13;
  sub_21D3A4(a1, a2);
  sub_21D77C((uint64_t)v24);
  swift_release(v11);
  uint64_t v14 = v24[0];
  uint64_t v15 = v24[1];
  uint64_t v16 = v24[2];
  uint64_t v17 = v24[3];
  uint64_t v19 = v24[4];
  uint64_t v18 = v24[5];
  uint64_t v20 = *a3;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*a3);
  *a3 = v20;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    uint64_t v20 = sub_2121E4(0LL, *((void *)v20 + 2), 0, v20);
  }
  *a3 = v20;
  *((void *)v20 + 4) = v14;
  *((void *)v20 + 5) = v15;
  *((void *)v20 + 6) = v16;
  *((void *)v20 + 7) = v17;
  *((void *)v20 + _Block_object_dispose((const void *)(v11 - 96), 8) = v19;
  *((void *)v20 + 9) = v18;
  uint64_t v22 = *a3;
  a4[3] = (char *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  a4[4] = (char *)sub_215958();
  *a4 = v22;
  return swift_bridgeObjectRetain(v22);
}

uint64_t sub_22CCB4@<X0>(char *a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, char **a4@<X8>)
{
  uint64_t v8 = ccsha256_di();
  if (!v8) {
    __break(1u);
  }
  uint64_t v9 = (uint64_t)v8;
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A87E8);
  uint64_t v11 = swift_allocObject(v10, 32LL, 7LL);
  uint64_t DigestSizeForDigestInfo = getDigestSizeForDigestInfo(v9);
  __int128 v13 = (void *)swift_slowAlloc(DigestSizeForDigestInfo, -1LL);
  ccdigest_init(v9, v13);
  *(void *)(v11 + 16) = v9;
  *(void *)(v11 + 24) = v13;
  sub_21D3B0(a1, a2);
  sub_21D6E4((uint64_t)v22);
  swift_release(v11);
  uint64_t v14 = v22[0];
  uint64_t v15 = v22[1];
  uint64_t v16 = v22[2];
  uint64_t v17 = v22[3];
  uint64_t v18 = *a3;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*a3);
  *a3 = v18;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    uint64_t v18 = sub_2121E4(0LL, *((void *)v18 + 2), 0, v18);
  }
  *a3 = v18;
  *((void *)v18 + 4) = v14;
  *((void *)v18 + 5) = v15;
  *((void *)v18 + 6) = v16;
  *((void *)v18 + 7) = v17;
  uint64_t v20 = *a3;
  a4[3] = (char *)__swift_instantiateConcreteTypeFromMangledName(&qword_3A8060);
  a4[4] = (char *)sub_215958();
  *a4 = v20;
  return swift_bridgeObjectRetain(v20);
}

uint64_t sub_22CE10@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned __int8 *a6@<X5>, char *a7@<X6>, size_t *a8@<X8>)
{
  int v14 = *a6;
  char v15 = *a7;
  if (qword_3A7CB0 != -1) {
    swift_once(&qword_3A7CB0, sub_22E7AC);
  }
  uint64_t v16 = qword_3A8998;
  uint64_t v17 = unk_3A89A0;
  sub_22E7E0(a1, (uint64_t)v25);
  if (qword_3A7CA8 != -1) {
    swift_once(&qword_3A7CA8, sub_22E778);
  }
  __int128 v24 = xmmword_3A8988;
  sub_1F83C0(xmmword_3A8988, *((unint64_t *)&xmmword_3A8988 + 1));
  Data.append(_:)(a4, a5);
  Data.append(_:)(v16, v17);
  sub_22E6A0((uint64_t)v25);
  sub_1F83C0(v24, *((unint64_t *)&v24 + 1));
  sub_234B20(v24, *((uint64_t *)&v24 + 1));
  uint64_t v19 = v18;
  sub_1F86D4(v24, *((unint64_t *)&v24 + 1));
  sub_22CFFC(0LL, 0xC000000000000000LL, v19, v15, &v26);
  swift_release(v19);
  sub_1F86D4(v24, *((unint64_t *)&v24 + 1));
  sub_218568((uint64_t)v25);
  uint64_t v20 = v26;
  if (qword_3A7CB8 != -1) {
    swift_once(&qword_3A7CB8, sub_22E824);
  }
  if (v14 == 2) {
    __int16 v21 = 64;
  }
  else {
    __int16 v21 = 32;
  }
  if (v14 == 1) {
    unsigned __int16 v22 = 48;
  }
  else {
    unsigned __int16 v22 = v21;
  }
  sub_22C050(v20, qword_3A89A8, unk_3A89B0, a2, a3, v22, a4, a5, a8, v15);
  return swift_release(v20);
}

int64_t sub_22CFFC@<X0>( int64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t *a5@<X8>)
{
  unint64_t v6 = a2;
  uint64_t v7 = result;
  if (!a4)
  {
LABEL_5:
    sub_1F83C0(result, a2);
    sub_234B20(v7, v6);
    uint64_t v22 = v21;
    swift_beginAccess(a3 + 16, v68, 0LL, 0LL);
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v24 = a3 + 32;
    uint64_t v25 = v24 + v23;
    uint64_t v26 = swift_retain(v22);
    sub_22C6B8(v26, &v63);
    uint64_t v27 = (char *)UnsafeRawBufferPointer.regions.getter(v24, v25);
    sub_21D3B0(v27, v28);
    __int128 v29 = v63;
    sub_21D6E4((uint64_t)&v64);
    uint64_t v62 = v29;
    __int128 v52 = v64;
    __int128 v53 = v65;
    swift_retain(v29);
    sub_21D3B0((char *)&v52, (uint64_t)&v54);
    uint64_t v30 = v62;
    swift_retain(v62);
    sub_21D6E4((uint64_t)&v57);
    swift_release(*((void *)&v29 + 1));
    swift_release(v29);
    swift_release_n(v30, 2LL);
    __int128 v50 = v57;
    __int128 v31 = v58;
    swift_release(v22);
    sub_1F86D4(v7, v6);
    uint64_t v32 = type metadata accessor for SecureBytes.Backing(0LL);
    a3 = swift_allocObject(v32, 64LL, 7LL);
    *(_OWORD *)(a3 + 16) = xmmword_281340;
    unint64_t v6 = a3 + 16;
    _swift_stdlib_malloc_size((const void *)a3);
    *(_OWORD *)(a3 + 32) = v50;
    *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v31;
    swift_beginAccess(a3 + 16, &v64, 1LL, 0LL);
    *(void *)(a3 + 16) = 32LL;
    uint64_t result = _swift_stdlib_malloc_size((const void *)a3);
    if (result >= 64) {
      goto LABEL_8;
    }
    __break(1u);
    goto LABEL_7;
  }

  if (a4 == 1)
  {
    sub_1F83C0(result, a2);
    sub_234B20(v7, v6);
    uint64_t v10 = v9;
    swift_beginAccess(a3 + 16, v68, 0LL, 0LL);
    uint64_t v11 = *(void *)(a3 + 16);
    uint64_t v12 = a3 + 32;
    uint64_t v13 = v12 + v11;
    uint64_t v14 = swift_retain(v10);
    sub_22C388( v14,  (uint64_t (*)(void))ccsha384_di,  &qword_3A87E0,  (void (*)(uint64_t, uint64_t))sub_21D3A4,  (char *)sub_22CB48,  &v63);
    char v15 = (char *)UnsafeRawBufferPointer.regions.getter(v12, v13);
    sub_21D3A4(v15, v16);
    __int128 v17 = v63;
    sub_21D77C((uint64_t)&v64);
    uint64_t v62 = v17;
    __int128 v52 = v64;
    __int128 v53 = v65;
    __int128 v54 = v66;
    swift_retain(v17);
    sub_21D3A4((char *)&v52, (uint64_t)&v55);
    uint64_t v18 = v62;
    swift_retain(v62);
    sub_21D77C((uint64_t)&v57);
    swift_release(*((void *)&v17 + 1));
    swift_release(v17);
    swift_release_n(v18, 2LL);
    __int128 v47 = v58;
    __int128 v49 = v57;
    __int128 v19 = v59;
    swift_release(v10);
    sub_1F86D4(v7, v6);
    uint64_t v20 = type metadata accessor for SecureBytes.Backing(0LL);
    a3 = swift_allocObject(v20, 96LL, 7LL);
    *(_OWORD *)(a3 + 16) = xmmword_281330;
    unint64_t v6 = a3 + 16;
    _swift_stdlib_malloc_size((const void *)a3);
    *(_OWORD *)(a3 + 32) = v49;
    *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v11 - 96), 8) = v47;
    *(_OWORD *)(a3 + 64) = v19;
    swift_beginAccess(a3 + 16, &v64, 1LL, 0LL);
    *(void *)(a3 + 16) = 48LL;
    uint64_t result = _swift_stdlib_malloc_size((const void *)a3);
    if (result >= 80) {
      goto LABEL_8;
    }
    __break(1u);
    goto LABEL_5;
  }

uint64_t sub_22D4EC@<X0>(uint64_t a1@<X0>, unint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  double v8 = ceil((double)a3 * 0.03125);
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0)
  {
    __break(1u);
    goto LABEL_22;
  }

  if (v8 <= -1.0)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  if (v8 < 256.0)
  {
    uint64_t v5 = a3;
    uint64_t v4 = a1;
    int v6 = (int)v8;
    if (qword_3A7D18 == -1) {
      goto LABEL_5;
    }
    goto LABEL_24;
  }

uint64_t sub_22DAA8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  double v8 = ceil((double)a3 / 48.0);
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0)
  {
    __break(1u);
    goto LABEL_22;
  }

  if (v8 <= -1.0)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  if (v8 < 256.0)
  {
    uint64_t v5 = a3;
    uint64_t v4 = a1;
    int v6 = (int)v8;
    if (qword_3A7D18 == -1) {
      goto LABEL_5;
    }
    goto LABEL_24;
  }

uint64_t sub_22E098@<X0>(uint64_t a1@<X0>, unint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  double v8 = ceil((double)a3 * 0.015625);
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0)
  {
    __break(1u);
    goto LABEL_22;
  }

  if (v8 <= -1.0)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  if (v8 < 256.0)
  {
    uint64_t v5 = a3;
    uint64_t v4 = a1;
    int v6 = (int)v8;
    if (qword_3A7D18 == -1) {
      goto LABEL_5;
    }
    goto LABEL_24;
  }

BOOL sub_22E6A0(uint64_t a1)
{
  uint64_t v1 = v12;
  if (v12)
  {
    sub_1F8384(&v11, (uint64_t)v10);
    sub_22E7E0((uint64_t)v10, (uint64_t)v7);
    uint64_t v2 = v8;
    uint64_t v3 = v9;
    __swift_mutable_project_boxed_opaque_existential_1((uint64_t)v7, v8);
    dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_22E864, 0LL, &type metadata for Data, v2, v3);
    uint64_t v4 = v13;
    unint64_t v5 = v14;
    __swift_destroy_boxed_opaque_existential_1Tm(v7);
    Data.append(_:)(v4, v5);
    sub_1F86D4(v4, v5);
    __swift_destroy_boxed_opaque_existential_1Tm(v10);
  }

  return v1 == 0;
}

uint64_t sub_22E778()
{
  uint64_t result = sub_21399C(0x31762D454B5048LL, 0xE700000000000000LL);
  qword_3A8988 = result;
  unk_3A8990 = v1;
  return result;
}

uint64_t sub_22E7AC()
{
  uint64_t result = sub_21399C(0x6B72705F656165LL, 0xE700000000000000LL);
  qword_3A8998 = result;
  unk_3A89A0 = v1;
  return result;
}

uint64_t sub_22E7E0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t sub_22E824()
{
  uint64_t result = sub_21399C(0x735F646572616873LL, 0xED00007465726365LL);
  qword_3A89A8 = result;
  unk_3A89B0 = v1;
  return result;
}

uint64_t sub_22E864@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  v14[3] = &type metadata for UnsafeRawBufferPointer;
  void v14[4] = &protocol witness table for UnsafeRawBufferPointer;
  v14[0] = a1;
  v14[1] = a2;
  uint64_t v4 = __swift_project_boxed_opaque_existential_1(v14, (uint64_t)&type metadata for UnsafeRawBufferPointer);
  unint64_t v5 = (_BYTE *)*v4;
  if (*v4 && (int v6 = (_BYTE *)v4[1], v7 = v6 - v5, v6 != v5))
  {
    if (v7 <= 14)
    {
      uint64_t v8 = sub_23B8E0(v5, v6);
      unint64_t v9 = v12 & 0xFFFFFFFFFFFFFFLL;
    }

    else if ((unint64_t)v7 >= 0x7FFFFFFF)
    {
      uint64_t v8 = sub_2155D4((uint64_t)v5, (uint64_t)v6);
      unint64_t v9 = v13 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v8 = sub_21564C((uint64_t)v5, (uint64_t)v6);
      unint64_t v9 = v11 | 0x4000000000000000LL;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    unint64_t v9 = 0xC000000000000000LL;
  }

  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v14);
  *a3 = v8;
  a3[1] = v9;
  return result;
}

unint64_t sub_22E92C()
{
  unint64_t result = qword_3A89C0;
  if (!qword_3A89C0)
  {
    unint64_t result = swift_getWitnessTable(&unk_282278, &type metadata for SecureBytes);
    atomic_store(result, (unint64_t *)&qword_3A89C0);
  }

  return result;
}

uint64_t sub_22E970( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t result = __DataStorage._bytes.getter();
  uint64_t v9 = result;
  if (result)
  {
    uint64_t result = __DataStorage._offset.getter();
    if (__OFSUB__(a1, result))
    {
LABEL_13:
      __break(1u);
      return result;
    }

    v9 += a1 - result;
  }

  BOOL v10 = __OFSUB__(a2, a1);
  uint64_t v11 = a2 - a1;
  if (v10)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v12 = __DataStorage._length.getter();
  if (v12 >= v11) {
    uint64_t v13 = v11;
  }
  else {
    uint64_t v13 = v12;
  }
  uint64_t v14 = v9 + v13;
  if (v9) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0LL;
  }
  return a5(v9, v15);
}

uint64_t sub_22EA0C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A82D0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t __swift_mutable_project_boxed_opaque_existential_1(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) & 0x20000) != 0)
  {
    swift_makeBoxUnique();
    return v2;
  }

  return result;
}

uint64_t sub_22EA7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return v4;
}

uint64_t sub_22EAD4(uint64_t a1, uint64_t a2)
{
  unsigned int v5 = *((unsigned __int8 *)v2 + 42);
  if (v5 == 3)
  {
    unint64_t v6 = sub_215864();
    uint64_t v7 = swift_allocError(&_s6ErrorsON, v6, 0LL, 0LL);
    *uint64_t v8 = 2;
    swift_willThrow(v7);
    return v4;
  }

  uint64_t v22 = *v2;
  __int128 v23 = *(_OWORD *)(v2 + 1);
  sub_22FD1C();
  if ((void)v23)
  {
    uint64_t v13 = v11;
    unint64_t v14 = v12;
    swift_retain(v23);
    sub_21DDA0(a1, a2, v13, v14);
    uint64_t v4 = v15;
    unint64_t v17 = v16;
    swift_release(v23);
    sub_1F86D4(v13, v14);
    if (v3) {
      return v4;
    }
    if (v5 < 3)
    {
      if (v22 == -1)
      {
        unint64_t v19 = sub_215864();
        uint64_t v20 = swift_allocError(&_s6ErrorsON, v19, 0LL, 0LL);
        _BYTE *v21 = 6;
        swift_willThrow(v20);
        sub_1F86D4(v4, v17);
      }

      else
      {
        uint64_t *v2 = v22 + 1;
      }

      return v4;
    }
  }

  else
  {
    __break(1u);
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD00000000000002ALL,  0x8000000000305890LL,  "CryptoKit_Static/HPKE-AEAD.swift",  32LL,  2LL);
  __break(1u);
  return result;
}

uint64_t sub_22ECCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = *((unsigned __int8 *)v4 + 42);
  if (v7 == 3)
  {
    unint64_t v8 = sub_215864();
    uint64_t v9 = swift_allocError(&_s6ErrorsON, v8, 0LL, 0LL);
    *BOOL v10 = 2;
    swift_willThrow(v9);
    return v6;
  }

  char v36 = *((_BYTE *)v4 + 42);
  uint64_t v13 = v4[3];
  uint64_t v14 = v4[4];
  __int16 v15 = *((_WORD *)v4 + 20);
  uint64_t v27 = *v4;
  uint64_t v30 = *v4;
  __int128 v31 = *(_OWORD *)(v4 + 1);
  uint64_t v32 = v13;
  uint64_t v33 = v14;
  __int16 v34 = v15;
  char v35 = v7;
  sub_22FD1C();
  uint64_t v18 = v31;
  if ((void)v31)
  {
    uint64_t v19 = v16;
    unint64_t v20 = v17;
    uint64_t v30 = v31;
    swift_retain(v31);
    uint64_t v6 = sub_21E184(a1, v19, v20, a2, &v30, a3, a4);
    unint64_t v22 = v21;
    swift_release(v18);
    sub_1F86D4(v19, v20);
    if (v5) {
      return v6;
    }
    if (v7 < 3)
    {
      if (v27 == -1)
      {
        unint64_t v24 = sub_215864();
        uint64_t v25 = swift_allocError(&_s6ErrorsON, v24, 0LL, 0LL);
        *char v26 = 6;
        swift_willThrow(v25);
        sub_1F86D4(v6, v22);
      }

      else
      {
        *uint64_t v4 = v27 + 1;
      }

      return v6;
    }
  }

  else
  {
    __break(1u);
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD00000000000002ALL,  0x8000000000305890LL,  "CryptoKit_Static/HPKE-AEAD.swift",  32LL,  2LL);
  __break(1u);
  return result;
}

uint64_t sub_22EEC4()
{
  uint64_t result = sub_21399C(0x685F64695F6B7370LL, 0xEB00000000687361LL);
  qword_3A89C8 = result;
  unk_3A89D0 = v1;
  return result;
}

uint64_t sub_22EF00()
{
  uint64_t result = sub_21399C(0x7361685F6F666E69LL, 0xE900000000000068LL);
  qword_3A89D8 = result;
  unk_3A89E0 = v1;
  return result;
}

uint64_t sub_22EF38()
{
  uint64_t result = sub_21399C(0x746572636573LL, 0xE600000000000000LL);
  qword_3A89E8 = result;
  unk_3A89F0 = v1;
  return result;
}

uint64_t sub_22EF68()
{
  uint64_t result = sub_21399C(7955819LL, 0xE300000000000000LL);
  qword_3A89F8 = result;
  unk_3A8A00 = v1;
  return result;
}

uint64_t sub_22EF94()
{
  uint64_t result = sub_21399C(0x6E6F6E5F65736162LL, 0xEA00000000006563LL);
  qword_3A8A08 = result;
  unk_3A8A10 = v1;
  return result;
}

uint64_t sub_22EFCC()
{
  uint64_t result = sub_21399C(7370853LL, 0xE300000000000000LL);
  qword_3A8A18 = result;
  unk_3A8A20 = v1;
  return result;
}

uint64_t sub_22EFF8@<X0>( uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, char *a8@<X7>, uint64_t a9@<X8>)
{
  char v14 = a1;
  uint64_t v15 = *a5;
  uint64_t v16 = *a8;
  uint64_t v17 = a8[1];
  uint64_t v18 = a8[2];
  *(void *)&v181[0] = *a5;
  sub_22FEC8(a1, v181, a6, a7);
  if (v9)
  {
    sub_215B4C(a6, a7);
    sub_1F86D4(a3, a4);
    __swift_destroy_boxed_opaque_existential_1Tm(a2);
    swift_release(v15);
    return sub_215B4C(0LL, 0xF000000000000000LL);
  }

  else
  {
    uint64_t v171 = v17;
    char v159 = v14;
    unint64_t v167 = a4;
    uint64_t v166 = a3;
    if (qword_3A7CC0 != -1) {
      swift_once(&qword_3A7CC0, sub_22EEC4);
    }
    uint64_t v20 = qword_3A89C8;
    uint64_t v21 = unk_3A89D0;
    if (a7 >> 60 == 15)
    {
      uint64_t v22 = 0LL;
      memset((char *)v181 + 8, 0, 32);
    }

    else
    {
      *((void *)&v181[1] + 1) = &type metadata for SymmetricKey;
      *(void *)&v181[2] = sub_2122CC();
      sub_1F83C0(a6, a7);
      sub_234B20(a6, a7);
      uint64_t v22 = v23;
      sub_215B4C(a6, a7);
    }

    uint64_t v24 = v16;
    uint64_t v161 = a6;
    unint64_t v162 = a7;
    *(void *)&v181[0] = v22;
    if (qword_3A7CF0 != -1)
    {
      swift_once(&qword_3A7CF0, sub_2303E8);
      uint64_t v24 = v16;
    }

    uint64_t v155 = v15;
    __int128 v180 = xmmword_3A8A38;
    uint64_t v25 = qword_281360[v24];
    sub_1F83C0(xmmword_3A8A38, *((unint64_t *)&xmmword_3A8A38 + 1));
    uint64_t v170 = v25;
    sub_2308A8(v25, 2LL);
    uint64_t v27 = v26;
    unint64_t v29 = v28;
    Data.append(_:)(v26, v28);
    sub_1F86D4(v27, v29);
    uint64_t v172 = v171 + 1;
    sub_2308A8(v171 + 1, 2LL);
    uint64_t v31 = v30;
    unint64_t v33 = v32;
    Data.append(_:)(v30, v32);
    sub_1F86D4(v31, v33);
    uint64_t v173 = qword_281380[v18];
    sub_2308A8(v173, 2LL);
    uint64_t v35 = v34;
    unint64_t v37 = v36;
    Data.append(_:)(v34, v36);
    sub_1F86D4(v35, v37);
    __int128 v38 = v180;
    if (qword_3A7CA8 != -1) {
      swift_once(&qword_3A7CA8, sub_22E778);
    }
    __int128 v180 = xmmword_3A8988;
    sub_1F83C0(xmmword_3A8988, *((unint64_t *)&xmmword_3A8988 + 1));
    Data.append(_:)(v38, *((void *)&v38 + 1));
    Data.append(_:)(v20, v21);
    sub_22E6A0((uint64_t)v181);
    __int128 v39 = v180;
    sub_1F83C0(v180, *((unint64_t *)&v180 + 1));
    sub_234B20(v180, *((uint64_t *)&v180 + 1));
    uint64_t v41 = v40;
    sub_1F86D4(v180, *((unint64_t *)&v180 + 1));
    sub_22CFFC(0LL, 0xC000000000000000LL, v41, v171, (uint64_t *)&v179);
    swift_release(v41);
    sub_1F86D4(v39, *((unint64_t *)&v39 + 1));
    uint64_t v42 = v179;
    swift_beginAccess(v179 + 16, &v180, 0LL, 0LL);
    uint64_t v43 = v42 + 32 + *(void *)(v42 + 16);
    swift_retain(v42);
    uint64_t v44 = sub_213EA0(v42 + 32, v43);
    unint64_t v164 = v45;
    uint64_t v165 = v44;
    swift_release_n(v42, 2LL);
    sub_1F86D4(v38, *((unint64_t *)&v38 + 1));
    sub_218568((uint64_t)v181);
    if (qword_3A7CC8 != -1) {
      swift_once(&qword_3A7CC8, sub_22EF00);
    }
    uint64_t v46 = qword_3A89D8;
    uint64_t v47 = unk_3A89E0;
    *((void *)&v181[1] + 1) = &type metadata for SymmetricKey;
    unint64_t v150 = sub_2122CC();
    *(void *)&v181[2] = v150;
    sub_1F83C0(v166, v167);
    sub_234B20(v166, v167);
    uint64_t v49 = v48;
    sub_1F86D4(v166, v167);
    *(void *)&v181[0] = v49;
    __int128 v179 = xmmword_3A8A38;
    sub_1F83C0(xmmword_3A8A38, *((unint64_t *)&xmmword_3A8A38 + 1));
    sub_2308A8(v170, 2LL);
    uint64_t v51 = v50;
    unint64_t v53 = v52;
    Data.append(_:)(v50, v52);
    sub_1F86D4(v51, v53);
    sub_2308A8(v172, 2LL);
    uint64_t v55 = v54;
    unint64_t v57 = v56;
    Data.append(_:)(v54, v56);
    sub_1F86D4(v55, v57);
    sub_2308A8(v173, 2LL);
    uint64_t v59 = v58;
    unint64_t v61 = v60;
    Data.append(_:)(v58, v60);
    sub_1F86D4(v59, v61);
    __int128 v62 = v179;
    __int128 v179 = xmmword_3A8988;
    sub_1F83C0(xmmword_3A8988, *((unint64_t *)&xmmword_3A8988 + 1));
    Data.append(_:)(v62, *((void *)&v62 + 1));
    Data.append(_:)(v46, v47);
    sub_22E6A0((uint64_t)v181);
    __int128 v63 = v179;
    sub_1F83C0(v179, *((unint64_t *)&v179 + 1));
    sub_234B20(v63, *((uint64_t *)&v63 + 1));
    uint64_t v65 = v64;
    sub_1F86D4(v63, *((unint64_t *)&v63 + 1));
    sub_22CFFC(0LL, 0xC000000000000000LL, v65, v171, (uint64_t *)&v178);
    swift_release(v65);
    sub_1F86D4(v63, *((unint64_t *)&v63 + 1));
    uint64_t v66 = v178;
    swift_beginAccess(v178 + 16, &v179, 0LL, 0LL);
    uint64_t v67 = v66 + 32 + *(void *)(v66 + 16);
    swift_retain(v66);
    uint64_t v68 = sub_213EA0(v66 + 32, v67);
    unint64_t v70 = v69;
    swift_release_n(v66, 2LL);
    sub_1F86D4(v62, *((unint64_t *)&v62 + 1));
    sub_218568((uint64_t)v181);
    __int128 v178 = xmmword_280350;
    uint64_t v71 = __swift_instantiateConcreteTypeFromMangledName(&qword_3A8A28);
    *((void *)&v181[1] + 1) = v71;
    *(void *)&v181[2] = sub_230004();
    LOBYTE(v181[0]) = v159;
    LOBYTE(v177) = *(_BYTE *)__swift_project_boxed_opaque_existential_1(v181, v71);
    Data._Representation.replaceSubrange(_:with:count:)(0LL, 0LL, &v177, 1LL);
    __swift_destroy_boxed_opaque_existential_1Tm(v181);
    Data.append(_:)(v165, v164);
    unint64_t v158 = v70;
    uint64_t v160 = v68;
    Data.append(_:)(v68, v70);
    sub_22E7E0((uint64_t)a2, (uint64_t)v181);
    __int128 v72 = *(_OWORD *)((char *)&v181[1] + 8);
    uint64_t v73 = __swift_mutable_project_boxed_opaque_existential_1((uint64_t)v181, *((uint64_t *)&v181[1] + 1));
    uint64_t v74 = sub_22EA7C(v73, v72, *((uint64_t *)&v72 + 1));
    unint64_t v76 = v75;
    __swift_destroy_boxed_opaque_existential_1Tm(v181);
    if (qword_3A7CD0 != -1) {
      swift_once(&qword_3A7CD0, sub_22EF38);
    }
    char v174 = v18;
    uint64_t v77 = qword_3A89E8;
    uint64_t v78 = unk_3A89F0;
    if (v155)
    {
      *((void *)&v181[1] + 1) = &type metadata for SymmetricKey;
      *(void *)&v181[2] = v150;
      *(void *)&v181[0] = sub_2348C8(v155);
      swift_release(v155);
    }

    else
    {
      memset(v181, 0, 40);
    }

    char v163 = v16;
    __int128 v177 = xmmword_3A8A38;
    sub_1F83C0(xmmword_3A8A38, *((unint64_t *)&xmmword_3A8A38 + 1));
    sub_2308A8(v170, 2LL);
    uint64_t v80 = v79;
    unint64_t v82 = v81;
    Data.append(_:)(v79, v81);
    sub_1F86D4(v80, v82);
    sub_2308A8(v172, 2LL);
    uint64_t v84 = v83;
    unint64_t v86 = v85;
    Data.append(_:)(v83, v85);
    sub_1F86D4(v84, v86);
    sub_2308A8(v173, 2LL);
    uint64_t v88 = v87;
    unint64_t v90 = v89;
    Data.append(_:)(v87, v89);
    sub_1F86D4(v88, v90);
    __int128 v91 = v177;
    __int128 v177 = xmmword_3A8988;
    sub_1F83C0(xmmword_3A8988, *((unint64_t *)&xmmword_3A8988 + 1));
    Data.append(_:)(v91, *((void *)&v91 + 1));
    Data.append(_:)(v77, v78);
    sub_22E6A0((uint64_t)v181);
    __int128 v92 = v177;
    sub_1F83C0(v74, v76);
    sub_1F83C0(v92, *((unint64_t *)&v92 + 1));
    sub_234B20(v92, *((uint64_t *)&v92 + 1));
    uint64_t v94 = v93;
    sub_1F86D4(v92, *((unint64_t *)&v92 + 1));
    __int16 v95 = v171;
    sub_22CFFC(v74, v76, v94, v171, &v176);
    swift_release(v94);
    sub_1F86D4(v74, v76);
    sub_1F86D4(v92, *((unint64_t *)&v92 + 1));
    sub_1F86D4(v91, *((unint64_t *)&v91 + 1));
    sub_1F86D4(v74, v76);
    sub_218568((uint64_t)v181);
    uint64_t v168 = v176;
    if (v18 == 3)
    {
      uint64_t v152 = 0LL;
      uint64_t v156 = 0LL;
      unint64_t v151 = 0xF000000000000000LL;
    }

    else
    {
      if (qword_3A7CD8 != -1) {
        swift_once(&qword_3A7CD8, sub_22EF68);
      }
      uint64_t v153 = unk_3A8A00;
      uint64_t v157 = qword_3A89F8;
      __int128 v96 = v178;
      __int128 v97 = xmmword_3A8A38;
      v181[0] = xmmword_3A8A38;
      sub_1F83C0(v178, *((unint64_t *)&v178 + 1));
      sub_1F83C0(v97, *((unint64_t *)&v97 + 1));
      sub_2308A8(v170, 2LL);
      uint64_t v99 = v98;
      unint64_t v101 = v100;
      Data.append(_:)(v98, v100);
      sub_1F86D4(v99, v101);
      sub_2308A8(v172, 2LL);
      uint64_t v103 = v102;
      unint64_t v105 = v104;
      Data.append(_:)(v102, v104);
      sub_1F86D4(v103, v105);
      sub_2308A8(v173, 2LL);
      uint64_t v107 = v106;
      unint64_t v109 = v108;
      Data.append(_:)(v106, v108);
      sub_1F86D4(v107, v109);
      __int128 v110 = v181[0];
      sub_22C050( v168,  v157,  v153,  v96,  *((uint64_t *)&v96 + 1),  0x2000200010uLL >> (16 * v18),  *(uint64_t *)&v181[0],  *((uint64_t *)&v181[0] + 1),  (size_t *)v181,  v171);
      sub_1F86D4(v110, *((unint64_t *)&v110 + 1));
      sub_1F86D4(v96, *((unint64_t *)&v96 + 1));
      uint64_t v156 = *(void *)&v181[0];
      if (qword_3A7CE0 != -1) {
        swift_once(&qword_3A7CE0, sub_22EF94);
      }
      uint64_t v111 = qword_3A8A08;
      uint64_t v154 = unk_3A8A10;
      __int128 v112 = xmmword_3A8A38;
      v181[0] = xmmword_3A8A38;
      sub_1F83C0(v96, *((unint64_t *)&v96 + 1));
      sub_1F83C0(v112, *((unint64_t *)&v112 + 1));
      sub_2308A8(v170, 2LL);
      uint64_t v114 = v113;
      unint64_t v116 = v115;
      Data.append(_:)(v113, v115);
      sub_1F86D4(v114, v116);
      sub_2308A8(v172, 2LL);
      uint64_t v118 = v117;
      unint64_t v120 = v119;
      Data.append(_:)(v117, v119);
      sub_1F86D4(v118, v120);
      sub_2308A8(v173, 2LL);
      uint64_t v122 = v121;
      unint64_t v124 = v123;
      Data.append(_:)(v121, v123);
      sub_1F86D4(v122, v124);
      __int128 v125 = v181[0];
      __int16 v95 = v171;
      sub_22C050( v168,  v111,  v154,  v96,  *((uint64_t *)&v96 + 1),  0xCu,  *(uint64_t *)&v181[0],  *((uint64_t *)&v181[0] + 1),  (size_t *)&v177,  v171);
      uint64_t v126 = v177;
      swift_beginAccess(v177 + 16, v181, 0LL, 0LL);
      uint64_t v127 = v126 + 32 + *(void *)(v126 + 16);
      swift_retain(v126);
      uint64_t v128 = sub_213EA0(v126 + 32, v127);
      unint64_t v151 = v129;
      uint64_t v152 = v128;
      swift_release_n(v126, 2LL);
      sub_1F86D4(v125, *((unint64_t *)&v125 + 1));
      sub_1F86D4(v96, *((unint64_t *)&v96 + 1));
      sub_215B4C(0LL, 0xF000000000000000LL);
    }

    if (qword_3A7CE8 != -1) {
      swift_once(&qword_3A7CE8, sub_22EFCC);
    }
    uint64_t v131 = qword_3A8A18;
    uint64_t v130 = unk_3A8A20;
    __int128 v132 = v178;
    unsigned __int16 v133 = 16 * v95 + 32;
    __int128 v134 = xmmword_3A8A38;
    __int128 v177 = xmmword_3A8A38;
    sub_1F83C0(v178, *((unint64_t *)&v178 + 1));
    sub_1F83C0(v134, *((unint64_t *)&v134 + 1));
    sub_2308A8(v170, 2LL);
    uint64_t v136 = v135;
    char v137 = v95;
    unint64_t v139 = v138;
    Data.append(_:)(v135, v138);
    sub_1F86D4(v136, v139);
    sub_2308A8(v172, 2LL);
    uint64_t v141 = v140;
    unint64_t v143 = v142;
    Data.append(_:)(v140, v142);
    sub_1F86D4(v141, v143);
    sub_2308A8(v173, 2LL);
    uint64_t v145 = v144;
    unint64_t v147 = v146;
    Data.append(_:)(v144, v146);
    sub_1F86D4(v145, v147);
    __int128 v148 = v177;
    sub_22C050( v168,  v131,  v130,  v132,  *((uint64_t *)&v132 + 1),  v133,  v177,  *((uint64_t *)&v177 + 1),  (size_t *)&v177,  v137);
    sub_1F86D4(v148, *((unint64_t *)&v148 + 1));
    sub_1F86D4(v160, v158);
    sub_1F86D4(v165, v164);
    sub_215B4C(v161, v162);
    sub_1F86D4(v166, v167);
    __swift_destroy_boxed_opaque_existential_1Tm(a2);
    sub_1F86D4(v132, *((unint64_t *)&v132 + 1));
    sub_1F86D4(v132, *((unint64_t *)&v132 + 1));
    swift_release(v168);
    uint64_t v149 = v177;
    *(void *)a9 = 0LL;
    *(void *)(a9 + _Block_object_dispose((const void *)(v11 - 96), 8) = v156;
    *(void *)(a9 + 16) = v152;
    *(void *)(a9 + 24) = v151;
    *(void *)(a9 + 32) = v149;
    *(_BYTE *)(a9 + 40) = v163;
    *(_BYTE *)(a9 + 41) = v137;
    *(_BYTE *)(a9 + 42) = v174;
    swift_retain(v156);
    sub_21B5BC(v152, v151);
    swift_retain(v149);
    swift_release(v156);
    sub_215B4C(v152, v151);
    return swift_release(v149);
  }

void sub_22FD1C()
{
  if (*(unsigned __int8 *)(v0 + 42) < 3u)
  {
    unint64_t v1 = *(void *)v0;
    unint64_t v2 = *(void *)(v0 + 24);
    uint64_t v3 = static Array._allocateBufferUninitialized(minimumCapacity:)(4LL, &type metadata for UInt8);
    *(void *)(v3 + 16) = 4LL;
    *(_DWORD *)(v3 + 32) = 0;
    unint64_t v4 = bswap64(v1);
    uint64_t v5 = v3;
    sub_232094((char *)&v4, (char *)&v5);
    if (v2 >> 60 != 15) {
      __asm { BR              X10 }
    }

    __break(1u);
    JUMPOUT(0x22FE54LL);
  }

  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0xD00000000000002ALL,  0x8000000000305890LL,  "CryptoKit_Static/HPKE-AEAD.swift",  32LL,  2LL);
  __break(1u);
  JUMPOUT(0x22FEA4LL);
}

_BYTE *sub_22FEB4@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = result[1] ^ *result;
  return result;
}

uint64_t sub_22FEC8(uint64_t result, void *a2, uint64_t a3, unint64_t a4)
{
  if ((a4 >> 60 == 15) == (*a2 != 0LL))
  {
    char v6 = 3;
LABEL_12:
    unint64_t v7 = sub_215864();
    uint64_t v8 = swift_allocError(&_s6ErrorsON, v7, 0LL, 0LL);
    *uint64_t v9 = v6;
    return swift_willThrow(v8);
  }

  if (*a2)
  {
    if (qword_3A7D38)
    {
      if (qword_3A7D38 != 1)
      {
        uint64_t v4 = &stru_20.segname[1];
        while (1)
        {
          uint64_t v5 = v4 - 39;
          if (__OFADD__(v4 - 40, 1LL)) {
            break;
          }
          ++v4;
          if (v5 == qword_3A7D38) {
            goto LABEL_10;
          }
        }

        __break(1u);
LABEL_24:
        __break(1u);
        return result;
      }
    }

unint64_t sub_230004()
{
  unint64_t result = qword_3A8A30;
  if (!qword_3A8A30)
  {
    uint64_t v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_3A8A28);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionOfOne<A>, v1);
    atomic_store(result, (unint64_t *)&qword_3A8A30);
  }

  return result;
}

uint64_t _s11KeyScheduleVwxx(void *a1)
{
  unint64_t v2 = a1[3];
  if (v2 >> 60 != 15) {
    sub_1F86D4(a1[2], v2);
  }
  return swift_release(a1[4]);
}

uint64_t _s11KeyScheduleVwcp(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v4;
  uint64_t v5 = (_OWORD *)(a2 + 16);
  unint64_t v6 = *(void *)(a2 + 24);
  swift_retain(v4);
  if (v6 >> 60 == 15)
  {
    *(_OWORD *)(a1 + 16) = *v5;
  }

  else
  {
    uint64_t v7 = *(void *)v5;
    sub_1F83C0(v7, v6);
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v6;
  }

  uint64_t v8 = *(void *)(a2 + 32);
  *(void *)(a1 + 32) = v8;
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  *(_BYTE *)(a1 + 42) = *(_BYTE *)(a2 + 42);
  swift_retain(v8);
  return a1;
}

uint64_t _s11KeyScheduleVwca(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
  swift_retain(v5);
  swift_release(v4);
  unint64_t v6 = (uint64_t *)(a2 + 16);
  unint64_t v7 = *(void *)(a2 + 24);
  if (*(void *)(a1 + 24) >> 60 != 15LL)
  {
    if (v7 >> 60 != 15)
    {
      uint64_t v9 = *v6;
      sub_1F83C0(*v6, *(void *)(a2 + 24));
      uint64_t v10 = *(void *)(a1 + 16);
      unint64_t v11 = *(void *)(a1 + 24);
      *(void *)(a1 + 16) = v9;
      *(void *)(a1 + 24) = v7;
      sub_1F86D4(v10, v11);
      goto LABEL_8;
    }

    sub_20FB18(a1 + 16);
    goto LABEL_6;
  }

  if (v7 >> 60 == 15)
  {
LABEL_6:
    *(_OWORD *)(a1 + 16) = *(_OWORD *)v6;
    goto LABEL_8;
  }

  uint64_t v8 = *v6;
  sub_1F83C0(*v6, *(void *)(a2 + 24));
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = v7;
LABEL_8:
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v13 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v12;
  swift_retain(v12);
  swift_release(v13);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 41);
  *(_BYTE *)(a1 + 42) = *(_BYTE *)(a2 + 42);
  return a1;
}

__n128 __swift_memcpy43_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 27) = *(_OWORD *)(a2 + 27);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t _s11KeyScheduleVwta(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 96), 8) = v5;
  swift_release(v4);
  unint64_t v6 = (void *)(a2 + 16);
  unint64_t v7 = *(void *)(a1 + 24);
  if (v7 >> 60 != 15)
  {
    unint64_t v8 = *(void *)(a2 + 24);
    if (v8 >> 60 != 15)
    {
      uint64_t v9 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = *v6;
      *(void *)(a1 + 24) = v8;
      sub_1F86D4(v9, v7);
      goto LABEL_6;
    }

    sub_20FB18(a1 + 16);
  }

  *(_OWORD *)(a1 + 16) = *(_OWORD *)v6;
LABEL_6:
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_release(v10);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_WORD *)(a1 + 41) = *(_WORD *)(a2 + 41);
  return a1;
}

uint64_t _s11KeyScheduleVwet(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 43)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t _s11KeyScheduleVwst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + _Block_object_dispose((const void *)(v11 - 96), 8) = 0u;
    *(_BYTE *)(result + 42) = 0;
    *(_WORD *)(result + 40) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 43) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 32) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 43) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *_s11KeyScheduleVMa()
{
  return &_s11KeyScheduleVN;
}

_BYTE *sub_230380@<X0>(_BYTE *result@<X0>, char *a2@<X1>, char *a3@<X2>, _BYTE *a4@<X8>)
{
  char v4 = *a2;
  char v5 = *a3;
  *a4 = *result;
  a4[1] = v4;
  a4[2] = v5;
  return result;
}

void sub_23039C(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 0;
  *(_BYTE *)(a1 + 2) = 1;
}

void sub_2303AC(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 257;
  *(_BYTE *)(a1 + 2) = 1;
}

void sub_2303C0(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 514;
  *(_BYTE *)(a1 + 2) = 1;
}

void sub_2303D4(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 3;
  *(_BYTE *)(a1 + 2) = 2;
}

uint64_t sub_2303E8()
{
  uint64_t result = sub_21399C(1162563656LL, 0xE400000000000000LL);
  qword_3A8A38 = result;
  unk_3A8A40 = v1;
  return result;
}

void sub_230414(_BYTE *a1@<X8>)
{
  *a1 = *v1;
}

void sub_230420(_BYTE *a1@<X8>)
{
  *a1 = *(_BYTE *)(v1 + 1);
}

void sub_23042C(_BYTE *a1@<X8>)
{
  *a1 = *(_BYTE *)(v1 + 2);
}

uint64_t __swift_memcpy3_1(uint64_t result, __int16 *a2)
{
  __int16 v2 = *a2;
  *(_BYTE *)(result + 2) = *((_BYTE *)a2 + 2);
  *(_WORD *)uint64_t result = v2;
  return result;
}

uint64_t _s11CiphersuiteVwet(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFE)
  {
    if ((a2 + 33554178) >> 24)
    {
      int v2 = a1[3];
      if (a1[3]) {
        return (*(unsigned __int16 *)a1 | (a1[2] << 16) | (v2 << 24)) - 16776962;
      }
    }

    else
    {
      int v2 = *(unsigned __int16 *)(a1 + 3);
      if (*(_WORD *)(a1 + 3)) {
        return (*(unsigned __int16 *)a1 | (a1[2] << 16) | (v2 << 24)) - 16776962;
      }
    }
  }

  unsigned int v4 = a1[1];
  BOOL v5 = v4 >= 3;
  int v6 = v4 - 3;
  if (!v5) {
    int v6 = -1;
  }
  return (v6 + 1);
}

uint64_t _s11CiphersuiteVwst(uint64_t result, unsigned int a2, unsigned int a3)
{
  if ((a3 + 33554178) >> 24) {
    int v3 = 1;
  }
  else {
    int v3 = 2;
  }
  if (a3 <= 0xFD) {
    int v3 = 0;
  }
  if (a2 > 0xFD)
  {
    *(_WORD *)uint64_t result = a2 - 254;
    *(_BYTE *)(result + 2) = (a2 - 254) >> 16;
    if (v3)
    {
      unsigned int v4 = ((a2 - 254) >> 24) + 1;
      if (v3 == 2) {
        *(_WORD *)(result + 3) = v4;
      }
      else {
        *(_BYTE *)(result + 3) = v4;
      }
    }
  }

  else
  {
    if (!v3) {
      goto LABEL_10;
    }
    if (v3 == 2)
    {
      *(_WORD *)(result + 3) = 0;
LABEL_10:
      if (!a2) {
        return result;
      }
LABEL_16:
      *(_BYTE *)(result + 1) = a2 + 2;
      return result;
    }

    *(_BYTE *)(result + 3) = 0;
    if (a2) {
      goto LABEL_16;
    }
  }

  return result;
}

ValueMetadata *_s11CiphersuiteVMa()
{
  return &_s11CiphersuiteVN;
}

ValueMetadata *type metadata accessor for AES()
{
  return &type metadata for AES;
}

uint64_t sub_230568()
{
  return 32LL;
}

uint64_t sub_230570@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D5A4((uint64_t (*)(void))ccsha256_di, &qword_3A87E8, a1);
}

uint64_t sub_230588@<X0>(uint64_t a1@<X8>)
{
  return sub_21D6E4(a1);
}

uint64_t sub_2305A8@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D66C((uint64_t (*)(void))ccsha256_di, &qword_3A87E8, a1);
}

uint64_t sub_2305BC()
{
  return 128LL;
}

uint64_t sub_2305C4@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D5A4((uint64_t (*)(void))ccsha384_di, &qword_3A87E0, a1);
}

uint64_t sub_2305DC@<X0>(uint64_t a1@<X8>)
{
  return sub_21D77C(a1);
}

uint64_t sub_2305FC@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D66C((uint64_t (*)(void))ccsha384_di, &qword_3A87E0, a1);
}

uint64_t sub_230610@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D5A4((uint64_t (*)(void))ccsha512_di, &qword_3A87D8, a1);
}

uint64_t sub_230628@<X0>(_OWORD *a1@<X8>)
{
  return sub_21D81C(a1);
}

uint64_t sub_230648@<X0>(uint64_t *a1@<X8>)
{
  return sub_21D66C((uint64_t (*)(void))ccsha512_di, &qword_3A87D8, a1);
}

unint64_t sub_230660()
{
  unint64_t result = qword_3A8A48;
  if (!qword_3A8A48)
  {
    unint64_t result = swift_getWitnessTable("I\r", &type metadata for SHA256Digest);
    atomic_store(result, (unint64_t *)&qword_3A8A48);
  }

  return result;
}

unint64_t sub_2306A4(uint64_t a1)
{
  unint64_t result = sub_218AD0();
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t sub_2306CC()
{
  unint64_t result = qword_3A8A88;
  if (!qword_3A8A88)
  {
    unint64_t result = swift_getWitnessTable(&unk_28261C, &type metadata for SHA256Digest);
    atomic_store(result, (unint64_t *)&qword_3A8A88);
  }

  return result;
}

unint64_t sub_230714()
{
  unint64_t result = qword_3A8AC8;
  if (!qword_3A8AC8)
  {
    unint64_t result = swift_getWitnessTable(&unk_282758, &type metadata for SHA384Digest);
    atomic_store(result, (unint64_t *)&qword_3A8AC8);
  }

  return result;
}

unint64_t sub_230758(uint64_t a1)
{
  unint64_t result = sub_218B18();
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t sub_230780()
{
  unint64_t result = qword_3A8B08;
  if (!qword_3A8B08)
  {
    unint64_t result = swift_getWitnessTable(&unk_282774, &type metadata for SHA384Digest);
    atomic_store(result, (unint64_t *)&qword_3A8B08);
  }

  return result;
}

unint64_t sub_2307C8()
{
  unint64_t result = qword_3A8B48;
  if (!qword_3A8B48)
  {
    unint64_t result = swift_getWitnessTable(&unk_2828B0, &type metadata for SHA512Digest);
    atomic_store(result, (unint64_t *)&qword_3A8B48);
  }

  return result;
}

unint64_t sub_23080C(uint64_t a1)
{
  unint64_t result = sub_218B60();
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t sub_230834()
{
  unint64_t result = qword_3A8B88;
  if (!qword_3A8B88)
  {
    unint64_t result = swift_getWitnessTable(&unk_2828CC, &type metadata for SHA512Digest);
    atomic_store(result, (unint64_t *)&qword_3A8B88);
  }

  return result;
}

ValueMetadata *type metadata accessor for SHA256()
{
  return &type metadata for SHA256;
}

ValueMetadata *type metadata accessor for SHA384()
{
  return &type metadata for SHA384;
}

ValueMetadata *type metadata accessor for SHA512()
{
  return &type metadata for SHA512;
}

void sub_2308A8(uint64_t a1, uint64_t a2)
{
  if (a1 < 0 || (uint64_t v3 = a2 - 1, a2 < 1))
  {
LABEL_36:
    __break(1u);
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }

  if (a1 <= 1) {
    uint64_t v5 = 1LL;
  }
  else {
    uint64_t v5 = a1;
  }
  BOOL v6 = __OFADD__(v5, 1LL);
  uint64_t v7 = v5 + 1;
  if (v6) {
    goto LABEL_37;
  }
  double v8 = ceil(log2((double)v7) * 0.125);
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0)
  {
LABEL_38:
    __break(1u);
    goto LABEL_39;
  }

  if (v8 <= -9.22337204e18)
  {
LABEL_39:
    __break(1u);
    goto LABEL_40;
  }

  if (v8 >= 9.22337204e18)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  uint64_t v9 = (uint64_t)v8;
  if ((uint64_t)v8 > a2)
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }

  v22[0] = sub_215730(a2);
  v22[1] = v10;
  sub_23EC90((uint64_t)v22);
  if (__OFSUB__(a2, v9))
  {
LABEL_42:
    __break(1u);
    goto LABEL_43;
  }

  if (a2 - v9 < a2)
  {
    uint64_t v11 = -v9;
    while (1)
    {
      uint64_t v12 = a2 + v11;
      uint64_t v13 = v3 - (a2 + v11);
      if (__OFSUB__(v3, a2 + v11)) {
        break;
      }
      uint64_t v14 = 8 * v13;
      unint64_t v15 = v14 - 65;
      unint64_t v16 = (unint64_t)a1 >> (v14 & 0x38);
      uint64_t v17 = a1 << (-(char)v14 & 0x38);
      if (v14 < 0) {
        unint64_t v18 = v17;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v15 >= 0xFFFFFFFFFFFFFF7FLL) {
        unint64_t v19 = v18;
      }
      else {
        unint64_t v19 = 0LL;
      }
      BOOL v21 = __CFADD__(v11++, 1LL);
      Data._Representation.subscript.setter(v19, v12);
      if (v21) {
        return;
      }
      if (__OFADD__(v12, 1LL))
      {
        __break(1u);
        return;
      }
    }

    __break(1u);
LABEL_35:
    __break(1u);
    goto LABEL_36;
  }

ValueMetadata *_s7ContextVMa()
{
  return &_s7ContextVN;
}

uint64_t sub_230A4C@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X6>, unint64_t a8@<X7>, void *a9@<X8>, uint64_t a10, uint64_t a11)
{
  uint64_t v59 = a3;
  uint64_t v55 = a7;
  unint64_t v56 = a8;
  uint64_t v57 = a4;
  unint64_t v58 = a5;
  unsigned int v54 = a2;
  uint64_t v51 = a9;
  uint64_t v13 = *(void *)(a10 - 8);
  __chkstk_darwin(a1, a2);
  unint64_t v15 = (char *)&v47 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = _s5DHKEMO9PublicKeyVMa(0LL, a10, a11, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  __chkstk_darwin(v17, v19);
  BOOL v21 = (char *)&v47 - v20;
  char v22 = *a1;
  int v23 = a1[1];
  int v52 = a1[2];
  int v53 = v23;
  uint64_t v24 = *v59;
  uint64_t v25 = *(void (**)(char *, uint64_t *, uint64_t))(v13 + 16);
  uint64_t v59 = a6;
  uint64_t v26 = a6;
  char v27 = v22;
  v25(v15, v26, a10);
  LOBYTE(v63) = v27;
  uint64_t v28 = v60;
  sub_23C778((uint64_t)v15, (char *)&v63, a10, a11, v21);
  if (v28)
  {
    swift_release(v24);
    sub_1F86D4(v55, v56);
    sub_215B4C(v57, v58);
    return (*(uint64_t (**)(uint64_t *, uint64_t))(v13 + 8))(v59, a10);
  }

  else
  {
    char v30 = v27;
    uint64_t v31 = v24;
    uint64_t v32 = v55;
    uint64_t v50 = a10;
    uint64_t v60 = v18;
    unint64_t v33 = v59;
    sub_23C82C(v17, v29, &v63);
    uint64_t v48 = v21;
    uint64_t v49 = v17;
    uint64_t v35 = v63;
    uint64_t v36 = v64;
    unint64_t v37 = v65;
    v62[3] = &type metadata for SymmetricKey;
    v62[4] = sub_2122CC();
    v62[0] = v35;
    uint64_t v70 = v31;
    uint64_t v38 = v36;
    v61[0] = v30;
    v61[1] = v53;
    v61[2] = v52;
    sub_1F83C0(v36, v37);
    sub_1F83C0(v36, v37);
    swift_retain(v35);
    sub_22EFF8(v54, v62, v32, v56, &v70, v57, v58, v61, (uint64_t)&v63);
    __int128 v39 = v33;
    uint64_t v40 = v60;
    uint64_t v41 = v50;
    swift_release(v35);
    sub_1F86D4(v38, v37);
    (*(void (**)(uint64_t *, uint64_t))(v13 + 8))(v39, v41);
    (*(void (**)(_BYTE *, uint64_t))(v40 + 8))(v48, v49);
    uint64_t v42 = v64;
    uint64_t v60 = v63;
    uint64_t v43 = v65;
    unint64_t v44 = v66;
    uint64_t v45 = v67;
    LODWORD(v59) = v68;
    LOBYTE(v32) = v69;
    swift_retain(v64);
    sub_21B5BC(v43, v44);
    swift_retain(v45);
    sub_1F83C0(v38, v37);
    sub_1F86D4(v38, v37);
    uint64_t v46 = v51;
    void *v51 = v60;
    v46[1] = v42;
    _OWORD v46[2] = v43;
    v46[3] = v44;
    v46[4] = v45;
    *((_WORD *)v46 + 20) = (_WORD)v59;
    *((_BYTE *)v46 + 42) = v32;
    v46[6] = v38;
    v46[7] = v37;
    swift_release(v42);
    sub_215B4C(v43, v44);
    swift_release(v45);
    return sub_1F86D4(v38, v37);
  }

uint64_t sub_230DE4@<X0>( char *a1@<X0>, unsigned int a2@<W1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, unint64_t a8@<X7>, size_t *a9@<X8>, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v70 = a8;
  uint64_t v69 = a7;
  uint64_t v75 = a6;
  unint64_t v76 = a3;
  uint64_t v71 = a4;
  unint64_t v72 = a5;
  unsigned int v63 = a2;
  uint64_t v60 = a9;
  uint64_t v78 = a10;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(void *)(a12 + 8),  a11,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v74 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness, v14);
  unint64_t v67 = (unint64_t)&v57 - v15;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a12,  a11,  AssociatedTypeWitness,  &unk_33EF98,  &unk_33EFA8);
  uint64_t v73 = AssociatedTypeWitness;
  uint64_t v66 = AssociatedConformanceWitness;
  uint64_t v65 = _s5DHKEMO9PublicKeyVMa(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v17);
  uint64_t v64 = *(void *)(v65 - 8);
  uint64_t v19 = __chkstk_darwin(v65, v18);
  unsigned __int16 v68 = (char *)&v57 - v20;
  uint64_t v21 = *(void *)(a11 - 8);
  __chkstk_darwin(v19, v22);
  uint64_t v24 = (char *)&v57 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = _s5DHKEMO10PrivateKeyVMa(0LL, a11, a12, v25);
  uint64_t v27 = *(void *)(v26 - 8);
  __chkstk_darwin(v26, v28);
  char v30 = (uint64_t *)((char *)&v57 - v29);
  char v31 = *a1;
  int v62 = a1[1];
  int v61 = a1[2];
  uint64_t v32 = *v76;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v24, v78, a11);
  LOBYTE(v81) = v31;
  uint64_t v33 = v77;
  sub_23CB50((uint64_t)v24, (char *)&v81, a11, a12, (uint64_t)v30);
  if (v33)
  {
    swift_release(v32);
    sub_1F86D4(v69, v70);
    sub_215B4C(v71, v72);
    (*(void (**)(uint64_t, uint64_t))(v21 + 8))(v78, a11);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v74 + 8))(v75, v73);
  }

  else
  {
    uint64_t v57 = v32;
    uint64_t v58 = v21;
    unint64_t v76 = v30;
    uint64_t v59 = v27;
    uint64_t v77 = v26;
    uint64_t v35 = v74;
    uint64_t v36 = v75;
    uint64_t v37 = v67;
    uint64_t v38 = v73;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v74 + 16))(v67, v75, v73);
    LOBYTE(v81) = v31;
    __int128 v39 = v68;
    sub_23C778(v37, (char *)&v81, v38, v66, v68);
    uint64_t v40 = sub_23CCC8(&v81, (uint64_t)v39, v77);
    size_t v41 = v81;
    unint64_t v43 = v42;
    uint64_t v44 = (uint64_t)v40;
    swift_retain(v81);
    sub_1F83C0(v44, v43);
    swift_release(v41);
    v80[3] = &type metadata for SymmetricKey;
    v80[4] = sub_2122CC();
    v80[0] = v41;
    uint64_t v88 = v57;
    v79[0] = v31;
    v79[1] = v62;
    v79[2] = v61;
    swift_retain(v41);
    uint64_t v45 = v44;
    unint64_t v67 = v43;
    sub_1F83C0(v44, v43);
    sub_22EFF8(v63, v80, v69, v70, &v88, v71, v72, v79, (uint64_t)&v81);
    uint64_t v46 = v78;
    uint64_t v47 = v59;
    swift_release(v41);
    uint64_t v48 = v45;
    uint64_t v49 = v45;
    unint64_t v50 = v67;
    sub_1F86D4(v49, v67);
    (*(void (**)(uint64_t, uint64_t))(v58 + 8))(v46, a11);
    (*(void (**)(uint64_t, uint64_t))(v35 + 8))(v36, v38);
    (*(void (**)(_BYTE *, uint64_t))(v64 + 8))(v68, v65);
    (*(void (**)(uint64_t *, uint64_t))(v47 + 8))(v76, v77);
    size_t v51 = v81;
    size_t v52 = v82;
    uint64_t v53 = v83;
    unint64_t v54 = v84;
    size_t v55 = v85;
    LODWORD(v7_Block_object_dispose((const void *)(v11 - 96), 8) = v86;
    LOBYTE(v36) = v87;
    swift_retain(v82);
    sub_21B5BC(v53, v54);
    swift_retain(v55);
    sub_1F83C0(v48, v50);
    sub_1F86D4(v48, v50);
    unint64_t v56 = v60;
    *uint64_t v60 = v51;
    v56[1] = v52;
    v56[2] = v53;
    v56[3] = v54;
    v56[4] = v55;
    *((_WORD *)v56 + 20) = v78;
    *((_BYTE *)v56 + 42) = v36;
    v56[6] = v48;
    v56[7] = v50;
    swift_release(v52);
    sub_215B4C(v53, v54);
    swift_release(v55);
    return sub_1F86D4(v48, v50);
  }

uint64_t sub_231434@<X0>( unsigned __int8 *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, size_t a8@<X7>, size_t *a9@<X8>, uint64_t a10, unint64_t a11, _BYTE *a12, uint64_t a13, uint64_t a14)
{
  size_t v87 = a8;
  unint64_t v79 = a7;
  uint64_t v78 = a6;
  unint64_t v82 = a4;
  uint64_t v83 = a5;
  uint64_t v81 = a3;
  unsigned int v71 = a2;
  unsigned __int16 v68 = a9;
  unsigned __int16 v86 = a12;
  unint64_t v77 = a11;
  uint64_t v76 = a10;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(a14 + 8),  a13,  &protocol descriptor for DiffieHellmanKeyAgreement.NumRequirements,  &unk_33EA28);
  uint64_t v85 = type metadata accessor for Optional(0LL, AssociatedTypeWitness);
  uint64_t v80 = *(void *)(v85 - 8);
  uint64_t v17 = __chkstk_darwin(v85, v16);
  uint64_t v73 = &v62[-v18];
  uint64_t v75 = AssociatedTypeWitness;
  uint64_t v74 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v20 = __chkstk_darwin(v17, v19);
  unint64_t v72 = &v62[-v21];
  uint64_t v22 = *(void *)(a13 - 8);
  __chkstk_darwin(v20, v23);
  uint64_t v25 = &v62[-((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v27 = _s5DHKEMO10PrivateKeyVMa(0LL, a13, a14, v26);
  uint64_t v28 = *(void *)(v27 - 8);
  __chkstk_darwin(v27, v29);
  char v31 = (uint64_t *)&v62[-v30];
  int v32 = *a1;
  int v70 = a1[1];
  int v69 = a1[2];
  uint64_t v33 = *v83;
  (*(void (**)(_BYTE *, size_t, uint64_t))(v22 + 16))(v25, v87, a13);
  LOBYTE(v90) = v32;
  uint64_t v34 = v84;
  sub_23CB50((uint64_t)v25, (char *)&v90, a13, a14, (uint64_t)v31);
  if (v34)
  {
    swift_release(v33);
    sub_1F86D4(v76, v77);
    sub_215B4C(v78, v79);
    sub_1F86D4(v81, v82);
    (*(void (**)(_BYTE *, uint64_t))(v80 + 8))(v86, v85);
    return (*(uint64_t (**)(size_t, uint64_t))(v22 + 8))(v87, a13);
  }

  uint64_t v67 = 0LL;
  int v63 = v32;
  uint64_t v36 = v72;
  uint64_t v83 = v31;
  uint64_t v65 = a13;
  uint64_t v66 = v28;
  uint64_t v84 = v27;
  uint64_t v64 = v22;
  uint64_t v38 = v81;
  unint64_t v37 = v82;
  uint64_t v39 = v80;
  uint64_t v40 = v73;
  uint64_t v42 = v85;
  size_t v41 = v86;
  (*(void (**)(_BYTE *, _BYTE *, uint64_t))(v80 + 16))(v73, v86, v85);
  if ((*(unsigned int (**)(_BYTE *, uint64_t, uint64_t))(v74 + 48))(v40, 1LL, v75) == 1)
  {
    unint64_t v43 = *(void (**)(_BYTE *, uint64_t))(v39 + 8);
    v43(v40, v42);
    uint64_t v44 = v38;
    uint64_t v45 = v38;
    uint64_t v46 = v39;
    uint64_t v47 = v83;
    uint64_t v48 = v84;
    uint64_t v49 = v67;
    sub_23DC08(v45, v37, v84, &v90);
    if (v49)
    {
      swift_release(v33);
      sub_1F86D4(v76, v77);
      sub_215B4C(v78, v79);
      sub_1F86D4(v44, v37);
      v43(v86, v42);
      (*(void (**)(size_t, uint64_t))(v64 + 8))(v87, v65);
      return (*(uint64_t (**)(uint64_t *, uint64_t))(v66 + 8))(v47, v48);
    }

    size_t v54 = v90;
  }

  else
  {
    unint64_t v50 = v36;
    (*(void (**)(char *, _BYTE *, uint64_t))(v74 + 32))(v36, v40, v75);
    uint64_t v44 = v38;
    uint64_t v51 = v38;
    uint64_t v47 = v83;
    uint64_t v52 = v84;
    uint64_t v53 = v67;
    sub_23D508(v51, v37, v50, v84, &v90);
    if (v53)
    {
      swift_release(v33);
      sub_1F86D4(v76, v77);
      sub_215B4C(v78, v79);
      sub_1F86D4(v44, v37);
      (*(void (**)(_BYTE *, uint64_t))(v39 + 8))(v41, v85);
      (*(void (**)(size_t, uint64_t))(v64 + 8))(v87, v65);
      (*(void (**)(char *, uint64_t))(v74 + 8))(v50, v75);
      return (*(uint64_t (**)(uint64_t *, uint64_t))(v66 + 8))(v47, v52);
    }

    uint64_t v46 = v39;
    (*(void (**)(char *, uint64_t))(v74 + 8))(v50, v75);
    size_t v54 = v90;
    uint64_t v42 = v85;
  }

  uint64_t v55 = v64;
  v89[3] = &type metadata for SymmetricKey;
  v89[4] = sub_2122CC();
  v89[0] = v54;
  uint64_t v97 = v33;
  v88[0] = v63;
  v88[1] = v70;
  v88[2] = v69;
  sub_1F83C0(v44, v37);
  swift_retain(v54);
  sub_22EFF8(v71, v89, v76, v77, &v97, v78, v79, v88, (uint64_t)&v90);
  swift_release(v54);
  (*(void (**)(_BYTE *, uint64_t))(v46 + 8))(v86, v42);
  (*(void (**)(size_t, uint64_t))(v55 + 8))(v87, v65);
  (*(void (**)(uint64_t *, uint64_t))(v66 + 8))(v47, v84);
  size_t v56 = v91;
  size_t v87 = v90;
  uint64_t v57 = v92;
  unint64_t v58 = v93;
  size_t v59 = v94;
  __int16 v60 = v95;
  LOBYTE(v55) = v96;
  swift_retain(v91);
  sub_21B5BC(v57, v58);
  swift_retain(v59);
  sub_1F83C0(v44, v37);
  sub_1F86D4(v44, v37);
  int v61 = v68;
  *unsigned __int16 v68 = v87;
  v61[1] = v56;
  v61[2] = v57;
  char v61[3] = v58;
  v61[4] = v59;
  *((_WORD *)v61 + 20) = v60;
  *((_BYTE *)v61 + 42) = v55;
  v61[6] = v44;
  v61[7] = v37;
  swift_release(v56);
  sub_215B4C(v57, v58);
  swift_release(v59);
  return sub_1F86D4(v44, v37);
}

uint64_t sub_231AC8(char **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v10 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native(*a1) & 1) == 0) {
    uint64_t v10 = sub_2121E4(0LL, *((void *)v10 + 2) + 1LL, 1, v10);
  }
  unint64_t v12 = *((void *)v10 + 2);
  unint64_t v11 = *((void *)v10 + 3);
  if (v12 >= v11 >> 1) {
    uint64_t v10 = sub_2121E4((char *)(v11 > 1), v12 + 1, 1, v10);
  }
  *((void *)v10 + 2) = v12 + 1;
  v10[v12 + 32] = 0;
  *a1 = v10;
  uint64_t v13 = swift_unknownObjectRetain(a2);
  sub_2329B0(v13, a3, a4, a5);
  return swift_unknownObjectRelease(a2);
}

void sub_231BB0()
{
}

void sub_231BBC(uint64_t a1)
{
}

void sub_231BC8()
{
  uint64_t v1 = v0[1];
  uint64_t v2 = v0[2];
  unint64_t v3 = v0[3];
  Hasher.init(_seed:)(v9);
  unint64_t v4 = v3 >> 1;
  if (__OFSUB__(v4, v2))
  {
    __break(1u);
  }

  else
  {
    Hasher._combine(_:)(v4 - v2);
    BOOL v5 = __OFSUB__(v4, v2);
    uint64_t v6 = v4 - v2;
    if (!v6)
    {
LABEL_6:
      Hasher._finalize()();
      return;
    }

    if (!((v6 < 0) ^ v5 | (v6 == 0)))
    {
      uint64_t v7 = (Swift::UInt8 *)(v1 + v2);
      do
      {
        Swift::UInt8 v8 = *v7++;
        Hasher._combine(_:)(v8);
        --v6;
      }

      while (v6);
      goto LABEL_6;
    }
  }

  __break(1u);
}

uint64_t sub_231C48(uint64_t a1, uint64_t a2)
{
  return sub_229C74( *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)(a2 + 8),  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t sub_231C64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return ArraySlice.withUnsafeBytes<A>(_:)(a1, a2, a3, a4, a5, a6, &type metadata for UInt8, a7);
}

uint64_t sub_231C84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_231C64(a1, a2, *v3, v3[1], v3[2], v3[3], a3);
}

unint64_t sub_231CA8()
{
  unint64_t result = qword_3A8BC8;
  if (!qword_3A8BC8)
  {
    unint64_t result = swift_getWitnessTable(&unk_2814C8, &_s13ASN1BitStringVN);
    atomic_store(result, (unint64_t *)&qword_3A8BC8);
  }

  return result;
}

void sub_231CEC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4 >> 1;
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
    goto LABEL_8;
  }

  Hasher._combine(_:)((a4 >> 1) - a3);
  BOOL v7 = __OFSUB__(v4, a3);
  uint64_t v8 = v4 - a3;
  if (!v8) {
    return;
  }
  if ((v8 < 0) ^ v7 | (v8 == 0))
  {
LABEL_8:
    __break(1u);
    return;
  }

  uint64_t v9 = (Swift::UInt8 *)(a2 + a3);
  do
  {
    Swift::UInt8 v10 = *v9++;
    Hasher._combine(_:)(v10);
    --v8;
  }

  while (v8);
}

uint64_t sub_231D50(unsigned __int8 *a1, unsigned __int8 a2)
{
  if (*a1 != a2)
  {
    unint64_t v8 = sub_222964();
    uint64_t v5 = swift_allocError(&type metadata for CryptoKitASN1Error, v8, 0LL, 0LL);
    char v7 = 1;
    goto LABEL_9;
  }

  sub_222B28((uint64_t)(a1 + 8), (uint64_t)v9);
  uint64_t result = sub_222B28((uint64_t)v9, (uint64_t)v10);
  if ((v13 & 1) != 0)
  {
    if (v11 != v12 >> 1)
    {
      if (v11 >= (uint64_t)(v12 >> 1))
      {
        __break(1u);
LABEL_12:
        __break(1u);
        goto LABEL_13;
      }

      if (!*(_BYTE *)(v10[1] + v11))
      {
        if (!__OFSUB__(v12 >> 1, v11)) {
          return v10[0];
        }
        goto LABEL_12;
      }
    }

    unint64_t v4 = sub_222964();
    uint64_t v5 = swift_allocError(&type metadata for CryptoKitASN1Error, v4, 0LL, 0LL);
    char v7 = 3;
LABEL_9:
    *uint64_t v6 = v7;
    swift_willThrow(v5);
    return sub_222A18((uint64_t)a1);
  }

void sub_231E48(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = a3 >> 1;
  if (__OFSUB__(a3 >> 1, a2))
  {
    __break(1u);
  }

  else
  {
    Hasher._combine(_:)((a3 >> 1) - a2);
    BOOL v7 = __OFSUB__(v6, a2);
    uint64_t v8 = v6 - a2;
    if (!v8)
    {
LABEL_6:
      Hasher._finalize()();
      return;
    }

    if (!((v8 < 0) ^ v7 | (v8 == 0)))
    {
      uint64_t v9 = (Swift::UInt8 *)(a1 + a2);
      do
      {
        Swift::UInt8 v10 = *v9++;
        Hasher._combine(_:)(v10);
        --v8;
      }

      while (v8);
      goto LABEL_6;
    }
  }

  __break(1u);
}