_BYTE *icu::CollationTailoring::makeBaseVersion(_BYTE *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  *a2 = 9;
  a2[1] = this[1] + 8 * *this;
  a2[2] = this[2] << 6;
  a2[3] = 0;
  return this;
}

_BYTE *icu::CollationTailoring::setVersion( _BYTE *this, const unsigned __int8 *a2, const unsigned __int8 *a3)
{
  this[328] = 9;
  this[329] = a2[1];
  this[330] = a2[2] & 0xC0 | (*a3 + (*a3 >> 6)) & 0x3F;
  this[331] = ((a3[1] >> 5) | (8 * a3[1])) + a3[2] + 16 * a3[3] + (a3[3] >> 4);
  return this;
}

uint64_t icu::CollationTailoring::getUCAVersion(icu::CollationTailoring *this)
{
  return (*((unsigned __int8 *)this + 330) >> 6) | (16 * *((unsigned __int8 *)this + 329));
}

void icu::CollationCacheEntry::~CollationCacheEntry(icu::CollationCacheEntry *this)
{
  *(void *)this = off_189720068;
  v2 = (void *)*((void *)this + 31);
  if (v2)
  {
    icu::SharedObject::removeRef(v2);
    *((void *)this + 31) = 0LL;
  }

  icu::Locale::~Locale((icu::CollationCacheEntry *)((char *)this + 24));
  icu::SharedObject::~SharedObject(this);
}

{
  void *v1;
  icu::CollationCacheEntry::~CollationCacheEntry(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::CollationWeights::CollationWeights(uint64_t this)
{
  *(_DWORD *)(this + 156) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(void *)(this + 8) = 0LL;
  *(void *)(this + 16) = 0LL;
  uint64_t v1 = 24LL;
  *(void *)this = 0LL;
  do
  {
    *(_DWORD *)(this + v1) = 0;
    v1 += 4LL;
  }

  while (v1 != 44);
  return this;
}

double icu::CollationWeights::CollationWeights(icu::CollationWeights *this)
{
  *((_DWORD *)this + 39) = 0;
  *((_DWORD *)this + 40) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  return result;
}

double icu::CollationWeights::initForPrimary(icu::CollationWeights *this, int a2)
{
  *(_DWORD *)this = 1;
  if (a2) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  *((_DWORD *)this + 2) = 3;
  *((_DWORD *)this + 3) = v2;
  if (a2) {
    int v3 = 254;
  }
  else {
    int v3 = 255;
  }
  *((_DWORD *)this + 7) = 255;
  *((_DWORD *)this + 8) = v3;
  *((void *)this + 2) = 0x200000002LL;
  *(void *)&double result = 0xFF000000FFLL;
  *(void *)((char *)this + 36) = 0xFF000000FFLL;
  return result;
}

double icu::CollationWeights::initForSecondary(icu::CollationWeights *this)
{
  *(_DWORD *)this = 3;
  *(_OWORD *)((char *)this + 8) = xmmword_180A348C0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 28) = xmmword_180A348D0;
  return result;
}

double icu::CollationWeights::initForTertiary(icu::CollationWeights *this)
{
  *(_DWORD *)this = 3;
  *(_OWORD *)((char *)this + 8) = xmmword_180A348C0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 28) = xmmword_180A348E0;
  return result;
}

uint64_t icu::CollationWeights::incWeight(icu::CollationWeights *this, unsigned int a2, uint64_t a3)
{
  char v3 = 8 * a3;
  unsigned int v4 = (a2 >> (-8 * a3));
  if (v4 >= *((_DWORD *)this + (int)a3 + 6))
  {
    a3 = (int)a3;
    char v6 = 40 - v3;
    v7 = (unsigned int *)((char *)this + 4 * (int)a3 + 20);
    do
    {
      unsigned int v8 = 0xFFFFFFFF >> v3;
      if (a3 >= 4) {
        unsigned int v8 = 0;
      }
      a2 = (*(v7 - 4) << (v6 - 8)) | (v8 | (-256 << (v6 - 8))) & a2;
      --a3;
      unsigned int v4 = (a2 >> v6);
      unsigned int v9 = *v7--;
      v6 += 8;
      v3 -= 8;
    }

    while (v4 >= v9);
    char v5 = v6 - 8;
  }

  else
  {
    char v5 = 32 - 8 * a3;
  }

  unsigned int v10 = v4 + 1;
  unsigned int v11 = 0xFFFFFFFF >> v3;
  return (v10 << v5) | (v11 | (-256 << v5)) & a2;
}

uint64_t icu::CollationWeights::incWeightByOffset( icu::CollationWeights *this, unsigned int a2, uint64_t a3, int a4)
{
  char v4 = 8 * a3;
  unsigned int v5 = a4 + (a2 >> (-8 * a3));
  unsigned int v6 = *((_DWORD *)this + (int)a3 + 6);
  if (v5 <= v6)
  {
    char v16 = 32 - 8 * a3;
  }

  else
  {
    a3 = (int)a3;
    char v7 = 40 - v4;
    unsigned int v8 = (unsigned int *)((char *)this + 4 * (int)a3 + 20);
    do
    {
      int v9 = *(v8 - 4);
      int v10 = v5 - v9;
      int v11 = v6 - v9 + 1;
      int v12 = v10 / v11;
      int v13 = v10 % v11 + v9;
      unsigned int v14 = 0xFFFFFFFF >> v4;
      if (a3 >= 4) {
        unsigned int v14 = 0;
      }
      a2 = (v13 << (v7 - 8)) | (v14 | (-256 << (v7 - 8))) & a2;
      --a3;
      unsigned int v5 = v12 + (a2 >> v7);
      unsigned int v15 = *v8--;
      unsigned int v6 = v15;
      v7 += 8;
      v4 -= 8;
    }

    while (v5 > v15);
    char v16 = v7 - 8;
  }

  unsigned int v17 = 0xFFFFFFFF >> v4;
  return (v5 << v16) | (v17 | (-256 << v16)) & a2;
}

uint64_t icu::CollationWeights::lengthenRange(uint64_t result, int *a2)
{
  int v2 = a2[3];
  uint64_t v3 = a2[2] + 1LL;
  uint64_t v4 = result + 4 * v3;
  int v5 = -256 << (-8 * v3);
  int v6 = a2[1];
  *a2 = v5 & *a2 | (*(_DWORD *)(v4 + 4) << (-8 * v3));
  a2[1] = (*(_DWORD *)(v4 + 24) << (-8 * v3)) | v5 & v6;
  int v7 = v2 + v2 * (*(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 4));
  a2[2] = v3;
  a2[3] = v7;
  return result;
}

BOOL icu::CollationWeights::getWeightRanges(icu::CollationWeights *this, unsigned int a2, unsigned int a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if ((_BYTE)a2) {
    LODWORD(v3) = 4;
  }
  else {
    LODWORD(v3) = 3;
  }
  if (!(_WORD)a2) {
    LODWORD(v3) = 2;
  }
  if ((a2 & 0xFFFFFF) != 0) {
    uint64_t v3 = v3;
  }
  else {
    uint64_t v3 = 1LL;
  }
  if ((_BYTE)a3) {
    LODWORD(v4) = 4;
  }
  else {
    LODWORD(v4) = 3;
  }
  if (!(_WORD)a3) {
    LODWORD(v4) = 2;
  }
  if ((a3 & 0xFFFFFF) != 0) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 1LL;
  }
  if (a2 >= a3) {
    return 0LL;
  }
  if (v3 >= v4 || (BOOL result = 0LL, ((-1 << (-8 * v3)) & a3) != a2))
  {
    memset(v44, 0, sizeof(v44));
    __int128 v45 = 0u;
    memset(v42, 0, sizeof(v42));
    int v7 = *(_DWORD *)this;
    __int128 v43 = 0u;
    if ((int)v3 > v7)
    {
      char v8 = 40 - 8 * v3;
      int v9 = (_DWORD *)((unint64_t)&v44[v3] | 8);
      do
      {
        char v10 = v8 - 8;
        unsigned int v11 = *((_DWORD *)this + v3 + 6);
        if (v11 > (a2 >> (v8 - 8)))
        {
          *(v9 - 2) = a2 + (1LL << v10);
          *(v9 - 1) = (v11 << v10) | (-256 << v10) & a2;
          *int v9 = v3;
          v9[1] = v11 - (a2 >> (v8 - 8));
        }

        --v3;
        a2 &= -1 << v8;
        v8 += 8;
        v9 -= 4;
      }

      while (v3 > v7);
    }

    char v12 = 32 - 8 * v7;
    unsigned int v13 = a2 + (1LL << v12);
    if (HIBYTE(a2) == 255) {
      unsigned int v13 = -1;
    }
    if ((int)v4 > v7)
    {
      char v14 = 40 - 8 * v4;
      unsigned int v15 = (_DWORD *)((unint64_t)&v42[v4] | 8);
      do
      {
        char v16 = v14 - 8;
        unsigned int v17 = (a3 >> (v14 - 8));
        unsigned int v18 = *((_DWORD *)this + v4 + 1);
        BOOL v19 = v17 >= v18;
        unsigned int v20 = v17 - v18;
        if (v20 != 0 && v19)
        {
          *(v15 - 2) = (v18 << v16) | (-256 << v16) & a3;
          *(v15 - 1) = a3 + (-1LL << v16);
          *unsigned int v15 = v4;
          v15[1] = v20;
        }

        --v4;
        a3 &= -1 << v14;
        v14 += 8;
        v15 -= 4;
      }

      while (v4 > v7);
    }

    unsigned int v21 = a3 + (-1LL << v12);
    if (v21 >= v13)
    {
      unsigned int v30 = (v21 - v13) >> v12;
      *((_DWORD *)this + 40) = 0;
      v31 = (int *)((char *)this + 160);
      if ((v30 & 0x80000000) != 0)
      {
        int v32 = 0;
      }

      else
      {
        *((_DWORD *)this + 11) = v13;
        *((_DWORD *)this + 12) = v21;
        *((_DWORD *)this + 13) = v7;
        *((_DWORD *)this + 14) = v30 + 1;
        int v32 = 1;
        *((_DWORD *)this + 40) = 1;
      }
    }

    else
    {
      if (v7 <= 3)
      {
        char v22 = 0;
        v23 = (int *)&v45 + 3;
        v24 = (int *)&v43 + 3;
        uint64_t v25 = 4LL;
        while (1)
        {
          int v26 = *v23;
          if (*v23 >= 1)
          {
            int v27 = *v24;
            if (*v24 >= 1)
            {
              unsigned int v28 = *(v23 - 2);
              unsigned int v29 = *(v24 - 3);
              if (v28 > v29)
              {
                unsigned int v33 = *(v24 - 2);
                *(v23 - 2) = v33;
                int v34 = (v33 >> v22) - (*(v23 - 3) >> v22) + 1;
                goto LABEL_49;
              }
            }
          }

          --v25;
          v22 += 8;
          v23 -= 4;
          v24 -= 4;
          if (v25 <= v7) {
            goto LABEL_52;
          }
        }

        *(v23 - 2) = *(v24 - 2);
        int v34 = v27 + v26;
LABEL_49:
        int *v23 = v34;
        int *v24 = 0;
        if ((int)v25 - 1 > v7)
        {
          uint64_t v35 = (int)v25 - 1LL;
          v36 = (_DWORD *)&v42[(int)v25 - 1] + 3;
          v37 = (_DWORD *)&v44[(int)v25 - 1] + 3;
          do
          {
            _DWORD *v36 = 0;
            v36 -= 4;
            _DWORD *v37 = 0;
            v37 -= 4;
            --v35;
          }

          while (v35 > v7);
        }
      }

uint64_t icu::CollationWeights::allocWeightsInShortRanges(icu::CollationWeights *this, int a2, int a3)
{
  uint64_t v3 = *((unsigned int *)this + 40);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0LL;
    int v5 = (_DWORD *)((char *)this + 56);
    do
    {
      int v6 = *(v5 - 1);
      if (v6 > a3 + 1) {
        break;
      }
      int v7 = a2 - *v5;
      if (a2 <= *v5)
      {
        if (v6 > a3) {
          *int v5 = a2;
        }
        *((_DWORD *)this + 40) = v4 + 1;
        if ((_DWORD)v4)
        {
          int v9 = 0;
          uprv_sortArray( (uint64_t)this + 44,  v4 + 1,  16,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_1808BAF20,  0LL,  0,  &v9);
        }

        return 1LL;
      }

      v5 += 4;
      ++v4;
      a2 = v7;
    }

    while (v3 != v4);
  }

  return 0LL;
}

uint64_t sub_1808BAF20(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (*a2 < *a3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 > *a3;
  }
}

uint64_t icu::CollationWeights::allocWeightsInMinLengthRanges( icu::CollationWeights *this, int a2, uint64_t a3)
{
  uint64_t v5 = *((unsigned int *)this + 40);
  if ((int)v5 < 1)
  {
    int v7 = 0;
    LODWORD(v6) = 0;
  }

  else
  {
    uint64_t v6 = 0LL;
    int v7 = 0;
    char v8 = (int *)((char *)this + 56);
    while (*(v8 - 1) == (_DWORD)a3)
    {
      int v9 = *v8;
      v8 += 4;
      v7 += v9;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *((_DWORD *)this + 40);
        break;
      }
    }
  }

  int v10 = *((_DWORD *)this + (int)a3 + 7) - *((_DWORD *)this + (int)a3 + 2) + 1;
  if (v10 * v7 < a2) {
    return 0LL;
  }
  unsigned int v13 = *((_DWORD *)this + 11);
  unsigned int v14 = *((_DWORD *)this + 12);
  char v12 = (int *)((char *)this + 44);
  if (v6 >= 2)
  {
    uint64_t v15 = v6;
    char v16 = (unsigned int *)((char *)this + 64);
    uint64_t v17 = v15 - 1;
    do
    {
      if (*(v16 - 1) < v13) {
        unsigned int v13 = *(v16 - 1);
      }
      unsigned int v19 = *v16;
      v16 += 4;
      unsigned int v18 = v19;
      if (v19 > v14) {
        unsigned int v14 = v18;
      }
      --v17;
    }

    while (v17);
  }

  int v20 = (a2 - v7) / (*((_DWORD *)this + (int)a3 + 7) - *((_DWORD *)this + (int)a3 + 2));
  int v21 = v7 - v20 + v20 * v10;
  if (v20) {
    BOOL v22 = v21 < a2;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22) {
    int v23 = v20 + 1;
  }
  else {
    int v23 = (a2 - v7) / (*((_DWORD *)this + (int)a3 + 7) - *((_DWORD *)this + (int)a3 + 2));
  }
  if (v22) {
    int v24 = v7 - v20 - 1;
  }
  else {
    int v24 = v7 - v20;
  }
  *char v12 = v13;
  if (v24)
  {
    unsigned int v25 = icu::CollationWeights::incWeightByOffset(this, v13, a3, v24 - 1);
    *((_DWORD *)this + 12) = v25;
    *((_DWORD *)this + 14) = v24;
    *((_DWORD *)this + 15) = icu::CollationWeights::incWeight(this, v25, a3);
    *((_DWORD *)this + 16) = v14;
    char v12 = (int *)((char *)this + 60);
    *((_DWORD *)this + 17) = a3;
    *((_DWORD *)this + 18) = v23;
    int v26 = 2;
  }

  else
  {
    *((_DWORD *)this + 12) = v14;
    *((_DWORD *)this + 14) = v7;
    int v26 = 1;
  }

  icu::CollationWeights::lengthenRange((uint64_t)this, v12);
  *((_DWORD *)this + 40) = v26;
  return 1LL;
}

BOOL icu::CollationWeights::allocWeights( icu::CollationWeights *this, unsigned int a2, unsigned int a3, int a4)
{
  BOOL result = icu::CollationWeights::getWeightRanges(this, a2, a3);
  if (result)
  {
    uint64_t v7 = *((unsigned int *)this + 13);
    if (icu::CollationWeights::allocWeightsInShortRanges(this, a4, *((_DWORD *)this + 13)))
    {
LABEL_3:
      *((_DWORD *)this + 39) = 0;
      return 1LL;
    }

    else
    {
      while ((_DWORD)v7 != 4)
      {
        if (!icu::CollationWeights::allocWeightsInMinLengthRanges(this, a4, v7))
        {
          if (*((int *)this + 40) >= 1)
          {
            uint64_t v8 = 0LL;
            int v9 = (int *)((char *)this + 44);
            do
            {
              if (v9[2] != (_DWORD)v7) {
                break;
              }
              icu::CollationWeights::lengthenRange((uint64_t)this, v9);
              ++v8;
              v9 += 4;
            }

            while (v8 < *((int *)this + 40));
          }

          uint64_t v7 = *((unsigned int *)this + 13);
        }

        goto LABEL_3;
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t icu::CollationWeights::nextWeight(icu::CollationWeights *this)
{
  uint64_t v1 = *((int *)this + 39);
  int v2 = (char *)this + 16 * v1;
  unsigned int v5 = *((_DWORD *)v2 + 11);
  uint64_t v4 = v2 + 44;
  uint64_t v3 = v5;
  int v6 = v4[3] - 1;
  v4[3] = v6;
  if (v6) {
    *uint64_t v4 = icu::CollationWeights::incWeight(this, v3, *((unsigned int *)this + 4 * v1 + 13));
  }
  else {
    *((_DWORD *)this + 39) = v1 + 1;
  }
  return v3;
}

void *icu::CompactDecimalFormat::getStaticClassID(icu::CompactDecimalFormat *this)
{
  return &unk_18C5352B0;
}

void *icu::CompactDecimalFormat::getDynamicClassID(icu::CompactDecimalFormat *this)
{
  return &unk_18C5352B0;
}

icu::DecimalFormat *icu::CompactDecimalFormat::createInstance@<X0>( const icu::Locale *a1@<X0>, unint64_t a2@<X1>, UErrorCode *a3@<X2>, uint64_t *a4@<X8>)
{
  int v5 = a2;
  BOOL result = (icu::DecimalFormat *)icu::UMemory::operator new(a4, (icu::UMemory *)0x170, a2);
  if (result) {
    return icu::CompactDecimalFormat::CompactDecimalFormat(result, a1, v5, a3, v8);
  }
  return result;
}

icu::DecimalFormat *icu::CompactDecimalFormat::CompactDecimalFormat@<X0>( icu::DecimalFormat *a1@<X0>, const icu::Locale *a2@<X1>, int a3@<W2>, UErrorCode *a4@<X3>, uint64_t *a5@<X8>)
{
  int v9 = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(a5, (icu::UMemory *)0xB48, (unint64_t)a2);
  int v10 = v9;
  if (v9) {
    icu::DecimalFormatSymbols::DecimalFormatSymbols(v9, a2, a4);
  }
  icu::DecimalFormat::DecimalFormat(a1, v10, a4);
  *(void *)a1 = off_1897200C0;
  if (*(int *)a4 <= 0)
  {
    uint64_t v11 = *((void *)a1 + 45);
    *(_DWORD *)(v11 + 12) = a3;
    *(_BYTE *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 84) = -2;
    *(_DWORD *)(v11 + 116) = 2;
    icu::DecimalFormat::touch(a1, a4);
  }

  return a1;
}

icu::DecimalFormat *icu::CompactDecimalFormat::CompactDecimalFormat( icu::CompactDecimalFormat *this, uint64_t **a2)
{
  BOOL result = icu::DecimalFormat::DecimalFormat(this, a2);
  *(void *)BOOL result = off_1897200C0;
  return result;
}

{
  icu::DecimalFormat *result;
  BOOL result = icu::DecimalFormat::DecimalFormat(this, a2);
  *(void *)BOOL result = off_1897200C0;
  return result;
}

void icu::CompactDecimalFormat::~CompactDecimalFormat(icu::CompactDecimalFormat *this)
{
}

icu::DecimalFormat *icu::CompactDecimalFormat::operator=(icu::DecimalFormat *a1, icu::DecimalFormat *a2)
{
  icu::DecimalFormat::operator=(a1, a2);
  return a1;
}

icu::DecimalFormat *icu::CompactDecimalFormat::clone@<X0>( uint64_t **this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL result = (icu::DecimalFormat *)icu::UMemory::operator new(a3, (icu::UMemory *)0x170, a2);
  if (result)
  {
    BOOL result = icu::DecimalFormat::DecimalFormat(result, this);
    *(void *)BOOL result = off_1897200C0;
  }

  return result;
}

void icu::CompactDecimalFormat::parse(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *a4 = 16;
}

uint64_t icu::CompactDecimalFormat::parseCurrency( icu::CompactDecimalFormat *this, const icu::UnicodeString *a2, icu::ParsePosition *a3)
{
  return 0LL;
}

void *icu::CopticCalendar::getStaticClassID(icu::CopticCalendar *this)
{
  return &unk_18C5352B4;
}

void *sub_1808BB3DC()
{
  return &unk_18C5352B4;
}

icu::CECalendar *sub_1808BB3E8(icu::CECalendar *a1, char **a2, UErrorCode *a3)
{
  BOOL result = icu::CECalendar::CECalendar(a1, a2, a3);
  *(void *)BOOL result = &off_189720348;
  return result;
}

void sub_1808BB40C(icu::CECalendar *a1)
{
}

icu::CECalendar *sub_1808BB420@<X0>( const icu::CECalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL result = (icu::CECalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    BOOL result = (icu::CECalendar *)icu::CECalendar::CECalendar(result, a1);
    *(void *)BOOL result = &off_189720348;
  }

  return result;
}

const char *sub_1808BB45C()
{
  return "coptic";
}

uint64_t sub_1808BB468(_DWORD *a1)
{
  if (icu::Calendar::newerField((uint64_t)a1, 0x13u, 1u) == 19)
  {
    return 1LL;
  }

  if ((int)a1[33] < 1 || a1[3])
  {
    return 1LL;
  }

  else {
    return (1 - a1[4]);
  }
}

double sub_1808BB4FC(uint64_t a1, icu::CECalendar *a2)
{
  *(void *)unsigned int v14 = 0LL;
  int v13 = 0;
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 440LL))(a1);
  icu::CECalendar::jdToCE(a2, v4, &v14[1], v14, &v13, v5);
  int v6 = v14[1];
  int v7 = 1 - v14[1];
  BOOL v8 = v14[1] <= 0;
  *(_DWORD *)(a1 + 88) = v14[1];
  int v9 = !v8;
  if (v8) {
    int v6 = v7;
  }
  *(_DWORD *)(a1 + 208) = 1;
  *(_BYTE *)(a1 + 127) = 1;
  *(_BYTE *)(a1 + 108) = 1;
  *(_DWORD *)(a1 + 12) = v9;
  *(_DWORD *)(a1 + 16) = v6;
  *(void *)&double result = 0x100000001LL;
  *(void *)(a1 + 132) = 0x100000001LL;
  *(_WORD *)(a1 + 109) = 257;
  int v12 = v13;
  int v11 = v14[0];
  *(_DWORD *)(a1 + 20) = v14[0];
  *(_DWORD *)(a1 + 140) = 1;
  *(_DWORD *)(a1 + 104) = v11;
  *(_DWORD *)(a1 + 224) = 1;
  *(_BYTE *)(a1 + 131) = 1;
  *(_BYTE *)(a1 + 113) = 1;
  *(_DWORD *)(a1 + 32) = v12;
  *(_DWORD *)(a1 + 36) = v12 + 30 * v11;
  *(void *)(a1 + 152) = 0x100000001LL;
  *(_BYTE *)(a1 + 114) = 1;
  return result;
}

uint64_t sub_1808BB5BC(_BYTE *a1, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(a1, 0x13u, a2) + 284;
  else {
    return 0LL;
  }
}

_BYTE *sub_1808BB5F4(_BYTE *a1, int a2)
{
  return icu::Calendar::set(a1, 0x13u, a2 - 284);
}

double sub_1808BB600()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_18C4493D0);
  if (v0 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C4493D0))
  {
    sub_1808BB64C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C4493D0);
  }

  return *(double *)&qword_18C4483B8;
}

void sub_1808BB64C()
{
  v4[78] = *MEMORY[0x1895F89C0];
  UErrorCode v2 = U_ZERO_ERROR;
  bzero(v4, 0x270uLL);
  icu::Locale::Locale((icu::Locale *)v3, "@calendar=coptic", 0LL, 0LL, 0LL);
  icu::CECalendar::CECalendar((icu::CECalendar *)v4, v3, &v2);
  v4[0] = &off_189720348;
  icu::Locale::~Locale((icu::Locale *)v3);
  if (v2 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v4, v1, &v2);
    icu::Calendar::add(v4, 1u, -80, &v2);
    qword_18C4483B8 = icu::Calendar::getTimeInMillis((icu::Calendar *)v4, &v2);
    dword_18C4483C0 = icu::Calendar::get(v4, 1u, &v2);
  }

  icu::CECalendar::~CECalendar((icu::CECalendar *)v4);
}

uint64_t sub_1808BB750()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_18C4493D0);
  if (v0 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C4493D0))
  {
    sub_1808BB64C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C4493D0);
  }

  return dword_18C4483C0;
}

uint64_t sub_1808BB79C()
{
  return 1824665LL;
}

void *icu::CompoundTransliterator::getStaticClassID(icu::CompoundTransliterator *this)
{
  return &unk_18C5352B8;
}

void *icu::CompoundTransliterator::getDynamicClassID(icu::CompoundTransliterator *this)
{
  return &unk_18C5352B8;
}

icu::CompoundTransliterator *icu::CompoundTransliterator::CompoundTransliterator( icu::CompoundTransliterator *this, icu::Transliterator *const *a2, int a3, icu::UnicodeFilter *a4)
{
  v10[8] = *(UChar **)MEMORY[0x1895F89C0];
  *(void *)this = off_189720530;
  icu::CompoundTransliterator::joinIDs(a2, a3, (uint64_t)v10);
  icu::Transliterator::Transliterator(this, v10, a4);
  icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v10);
  *(void *)this = off_189720530;
  *((void *)this + 11) = 0LL;
  *((void *)this + 12) = 0LL;
  icu::CompoundTransliterator::setTransliterators(this, a2, a3);
  return this;
}

void icu::CompoundTransliterator::joinIDs(icu::Transliterator *const *a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  if (a2 >= 1)
  {
    unint64_t v6 = 0LL;
    uint64_t v7 = 8LL * a2;
    do
    {
      if (v6)
      {
        __int16 v13 = 59;
        icu::UnicodeString::doAppend(a3, (uint64_t)&v13, 0, 1LL);
      }

      uint64_t v8 = (*(uint64_t (**)(icu::Transliterator *const))(*(void *)a1[v6 / 8] + 104LL))(a1[v6 / 8]);
      unsigned int v9 = *(unsigned __int16 *)(v8 + 8);
      int v10 = (__int16)v9;
      unsigned int v11 = v9 >> 5;
      if (v10 >= 0) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = *(unsigned int *)(v8 + 12);
      }
      icu::UnicodeString::doAppend(a3, (const icu::UnicodeString *)v8, 0, v12);
      v6 += 8LL;
    }

    while (v7 != v6);
  }

void icu::CompoundTransliterator::setTransliterators( icu::CompoundTransliterator *this, icu::Transliterator *const *a2, int a3)
{
  unint64_t v6 = (icu::Transliterator **)uprv_malloc(8LL * a3);
  if (v6)
  {
    uint64_t v7 = v6;
    if (a3 < 1) {
      goto LABEL_11;
    }
    uint64_t v8 = 0LL;
    while (1)
    {
      uint64_t v9 = (*(uint64_t (**)(icu::Transliterator *const))(*(void *)a2[v8] + 24LL))(a2[v8]);
      v7[v8] = (icu::Transliterator *)v9;
      if (!v9) {
        break;
      }
      if (a3 == ++v8) {
        goto LABEL_11;
      }
    }

    if (v8)
    {
      uint64_t v10 = v8 + 1;
      do
      {
        uprv_free(v7[(v10 - 2)]);
        v7[(v10-- - 2)] = 0LL;
      }

      while (v10 > 1);
    }

    else
    {
LABEL_11:
      icu::CompoundTransliterator::adoptTransliterators(this, v7, a3);
    }
  }

icu::Transliterator *icu::CompoundTransliterator::CompoundTransliterator( icu::Transliterator *a1, UChar **a2, int a3, icu::UnicodeFilter *a4, uint64_t a5, UErrorCode *a6)
{
  uint64_t v10 = icu::Transliterator::Transliterator(a1, a2, a4);
  *(void *)uint64_t v10 = off_189720530;
  *((void *)v10 + 11) = 0LL;
  *((_DWORD *)v10 + 25) = 0;
  icu::CompoundTransliterator::init(v10, (uint64_t)a2, a3, 1, a6);
  return a1;
}

{
  icu::Transliterator *v10;
  uint64_t v10 = icu::Transliterator::Transliterator(a1, a2, a4);
  *(void *)uint64_t v10 = off_189720530;
  *((void *)v10 + 11) = 0LL;
  *((_DWORD *)v10 + 25) = 0;
  icu::CompoundTransliterator::init(v10, (uint64_t)a2, a3, 1, a6);
  return a1;
}

void icu::CompoundTransliterator::init(icu::Transliterator *a1, uint64_t a2, int a3, int a4, UErrorCode *a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v14 = 0LL;
    memset(v13, 0, sizeof(v13));
    icu::UVector::UVector((icu::UVector *)v13, a5);
    uint64_t v12 = 0LL;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    uint64_t v19 = 0LL;
    __int128 v18 = 0u;
    uint64_t v15 = off_18971B688;
    LOWORD(v16) = 2;
    if (sub_18099FA08(a2, a3, (uint64_t)&v15, (icu::UVector *)v13, &v12))
    {
      sub_18099FD3C((icu::UVector *)v13, a5);
      icu::CompoundTransliterator::init(a1, (int *)v13, a3, a4, (int *)a5);
      if (v12) {
        icu::Transliterator::adoptFilter(a1, v12);
      }
    }

    else
    {
      uint64_t v10 = 65569LL;
      *a5 = U_INVALID_ID;
      if (v12)
      {
        unsigned int v11 = icu::UnicodeSet::~UnicodeSet((void *)0x10021, v12);
        icu::UMemory::operator delete(v11);
      }
    }

    icu::UnicodeString::~UnicodeString((void *)v10, (icu::UnicodeString *)&v15);
    icu::UVector::~UVector((icu::UVector *)v13);
  }

icu::CompoundTransliterator *icu::CompoundTransliterator::CompoundTransliterator( icu::CompoundTransliterator *this, UChar **a2, UParseError *a3, UErrorCode *a4)
{
  uint64_t v7 = icu::Transliterator::Transliterator(this, a2, 0LL);
  *(void *)uint64_t v7 = off_189720530;
  *((void *)v7 + 11) = 0LL;
  *((_DWORD *)v7 + 25) = 0;
  icu::CompoundTransliterator::init(v7, (uint64_t)a2, 0, 1, a4);
  return this;
}

{
  icu::Transliterator *v7;
  uint64_t v7 = icu::Transliterator::Transliterator(this, a2, 0LL);
  *(void *)uint64_t v7 = off_189720530;
  *((void *)v7 + 11) = 0LL;
  *((_DWORD *)v7 + 25) = 0;
  icu::CompoundTransliterator::init(v7, (uint64_t)a2, 0, 1, a4);
  return this;
}

icu::CompoundTransliterator *icu::CompoundTransliterator::CompoundTransliterator( icu::CompoundTransliterator *this, UChar **a2, icu::UVector *a3, icu::UnicodeFilter *a4, int a5, UParseError *a6, UErrorCode *a7)
{
  unsigned int v11 = icu::Transliterator::Transliterator(this, a2, a4);
  *(void *)unsigned int v11 = off_189720530;
  *((void *)v11 + 11) = 0LL;
  *((_DWORD *)v11 + 25) = a5;
  icu::CompoundTransliterator::init(v11, (int *)a3, 0, 0, (int *)a7);
  return this;
}

{
  icu::Transliterator *v11;
  unsigned int v11 = icu::Transliterator::Transliterator(this, a2, a4);
  *(void *)unsigned int v11 = off_189720530;
  *((void *)v11 + 11) = 0LL;
  *((_DWORD *)v11 + 25) = a5;
  icu::CompoundTransliterator::init(v11, (int *)a3, 0, 0, (int *)a7);
  return this;
}

_DWORD *icu::CompoundTransliterator::init(_DWORD *result, int *a2, int a3, int a4, int *a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (*a5 <= 0)
  {
    uint64_t v9 = result;
    uint64_t v10 = a2[2];
    result[24] = v10;
    double result = uprv_malloc(8 * v10);
    *((void *)v9 + 11) = result;
    if (result)
    {
      if (*a5 <= 0)
      {
        LODWORD(v11) = v9[24];
        if ((int)v11 >= 1)
        {
          uint64_t v12 = 0LL;
          int v13 = -1;
          do
          {
            unsigned int v14 = v11 + v13;
            if (a3) {
              unsigned int v15 = v14;
            }
            else {
              unsigned int v15 = v12;
            }
            *(void *)(*((void *)v9 + 11) + 8 * v12++) = icu::UVector::elementAt((icu::UVector *)a2, v15);
            uint64_t v11 = (int)v9[24];
            --v13;
          }

          while (v12 < v11);
        }

        if (a3 == 1 && a4)
        {
          __int128 v28 = 0u;
          uint64_t v31 = 0LL;
          __int128 v30 = 0u;
          __int128 v29 = 0u;
          int v27 = (UChar *)off_18971B688;
          LOWORD(v28) = 2;
          if ((int)v11 >= 1)
          {
            uint64_t v16 = 0LL;
            do
            {
              if (v16)
              {
                __int16 v26 = 59;
                icu::UnicodeString::doAppend((uint64_t)&v27, (uint64_t)&v26, 0, 1LL);
              }

              uint64_t v17 = *(void *)(*((void *)v9 + 11) + 8 * v16);
              uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 104LL))(v17);
              unsigned int v19 = *(unsigned __int16 *)(v18 + 8);
              int v20 = (__int16)v19;
              unsigned int v21 = v19 >> 5;
              if (v20 >= 0) {
                uint64_t v22 = v21;
              }
              else {
                uint64_t v22 = *(unsigned int *)(v18 + 12);
              }
              icu::UnicodeString::doAppend((uint64_t)&v27, (const icu::UnicodeString *)v18, 0, v22);
              ++v16;
            }

            while (v16 < (int)v9[24]);
          }

          icu::UnicodeString::operator=((UChar **)v9 + 1, &v27);
          __int16 v26 = 0;
          icu::UnicodeString::doAppend((uint64_t)(v9 + 2), (uint64_t)&v26, 0, 1LL);
          int v23 = (void *)*((unsigned __int16 *)v9 + 8);
          else {
            unsigned int v24 = v23 >> 5;
          }
          int v25 = v24 - 1;
          if ((v23 & 1) != 0 && v24 == 1)
          {
            icu::UnicodeString::unBogus((uint64_t)(v9 + 2));
          }

          else if (v24 > v25)
          {
            if (v25 > 1023)
            {
              int v23 = (void *)(v23 | 0xFFE0);
              *((_WORD *)v9 + 8) = (_WORD)v23;
              v9[5] = v25;
            }

            else
            {
              int v23 = (void *)(v23 & 0x1F | (32 * v25));
              *((_WORD *)v9 + 8) = (_WORD)v23;
            }
          }

          icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)&v27);
        }

        return (_DWORD *)icu::CompoundTransliterator::computeMaximumContextLength((icu::CompoundTransliterator *)v9);
      }
    }

    else
    {
      *a5 = 7;
    }
  }

  return result;
}

icu::CompoundTransliterator *icu::CompoundTransliterator::CompoundTransliterator( icu::CompoundTransliterator *this, icu::UVector *a2, UParseError *a3, UErrorCode *a4)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v9 = (UChar *)off_18971B688;
  __int16 v10 = 2;
  icu::Transliterator::Transliterator(this, &v9, 0LL);
  icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v9);
  *(void *)this = off_189720530;
  *((void *)this + 11) = 0LL;
  *((_DWORD *)this + 25) = 0;
  icu::CompoundTransliterator::init(this, (int *)a2, 0, 0, (int *)a4);
  return this;
}

icu::CompoundTransliterator *icu::CompoundTransliterator::CompoundTransliterator( icu::CompoundTransliterator *this, icu::UVector *a2, int a3, UParseError *a4, UErrorCode *a5)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v11 = (UChar *)off_18971B688;
  __int16 v12 = 2;
  icu::Transliterator::Transliterator(this, &v11, 0LL);
  icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)&v11);
  *(void *)this = off_189720530;
  *((void *)this + 11) = 0LL;
  *((_DWORD *)this + 25) = a3;
  icu::CompoundTransliterator::init(this, (int *)a2, 0, 0, (int *)a5);
  return this;
}

uint64_t icu::CompoundTransliterator::computeMaximumContextLength(icu::CompoundTransliterator *this)
{
  uint64_t v1 = *((unsigned int *)this + 24);
  if ((int)v1 < 1)
  {
    int v2 = 0;
  }

  else
  {
    int v2 = 0;
    unsigned int v3 = (uint64_t *)*((void *)this + 11);
    do
    {
      uint64_t v4 = *v3++;
      int v5 = *(_DWORD *)(v4 + 80);
      if (v5 > v2) {
        int v2 = v5;
      }
      --v1;
    }

    while (v1);
  }

  return icu::Transliterator::setMaximumContextLength((uint64_t)this, v2);
}

uint64_t icu::CompoundTransliterator::CompoundTransliterator(icu::CompoundTransliterator *this, UChar **a2)
{
  unsigned int v3 = icu::Transliterator::Transliterator(this, a2);
  *(void *)unsigned int v3 = off_189720530;
  *((void *)v3 + 11) = 0LL;
  *((void *)v3 + 12) = 0xFFFFFFFF00000000LL;
  return icu::CompoundTransliterator::operator=((uint64_t)v3, (uint64_t)a2);
}

{
  icu::Transliterator *v3;
  unsigned int v3 = icu::Transliterator::Transliterator(this, a2);
  *(void *)unsigned int v3 = off_189720530;
  *((void *)v3 + 11) = 0LL;
  *((void *)v3 + 12) = 0xFFFFFFFF00000000LL;
  return icu::CompoundTransliterator::operator=((uint64_t)v3, (uint64_t)a2);
}

uint64_t icu::CompoundTransliterator::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    icu::Transliterator::operator=(a1, a2);
    int v4 = *(_DWORD *)(a1 + 96);
    if (*(void *)(a1 + 88)) {
      BOOL v5 = v4 < 1;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      uint64_t v6 = 0LL;
      do
      {
        uint64_t v7 = *(void *)(a1 + 88);
        uint64_t v8 = *(void *)(v7 + 8 * v6);
        if (v8)
        {
          (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
          uint64_t v7 = *(void *)(a1 + 88);
          int v4 = *(_DWORD *)(a1 + 96);
        }

        *(void *)(v7 + 8 * v6++) = 0LL;
      }

      while (v6 < v4);
    }

    int v9 = *(_DWORD *)(a2 + 96);
    __int16 v10 = *(void **)(a1 + 88);
    if (v9 > v4)
    {
      if (v10)
      {
        uprv_free(v10);
        int v9 = *(_DWORD *)(a2 + 96);
      }

      __int16 v10 = uprv_malloc(8LL * v9);
      *(void *)(a1 + 88) = v10;
      int v9 = *(_DWORD *)(a2 + 96);
    }

    *(_DWORD *)(a1 + 96) = v9;
    if (v10 && v9 >= 1)
    {
      uint64_t v11 = 0LL;
      while (1)
      {
        uint64_t v12 = *(void *)(*(void *)(a2 + 88) + 8 * v11);
        *(void *)(*(void *)(a1 + 88) + 8 * v11) = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 24LL))(v12);
        if (!*(void *)(*(void *)(a1 + 88) + 8 * v11)) {
          break;
        }
      }

      if (v11)
      {
        uint64_t v13 = v11 + 1;
        do
        {
          uprv_free(*(void **)(*(void *)(a1 + 88) + 8LL * (v13 - 2)));
          *(void *)(*(void *)(a1 + 88) + 8LL * (v13-- - 2)) = 0LL;
        }

        while (v13 > 1);
      }
    }

void icu::CompoundTransliterator::~CompoundTransliterator(icu::CompoundTransliterator *this)
{
  *(void *)this = off_189720530;
  icu::CompoundTransliterator::freeTransliterators(this);
  icu::Transliterator::~Transliterator(this);
}

{
  *(void *)this = off_189720530;
  icu::CompoundTransliterator::freeTransliterators(this);
  icu::Transliterator::~Transliterator(this);
}

{
  void *v2;
  *(void *)this = off_189720530;
  icu::CompoundTransliterator::freeTransliterators(this);
  icu::Transliterator::~Transliterator(this);
  icu::UMemory::operator delete(v2);
}

void icu::CompoundTransliterator::freeTransliterators(icu::CompoundTransliterator *this)
{
  int v2 = (void *)*((void *)this + 11);
  if (v2)
  {
    int v3 = *((_DWORD *)this + 24);
    if (v3 >= 1)
    {
      for (uint64_t i = 0LL; i < v3; ++i)
      {
        uint64_t v5 = *(void *)(*((void *)this + 11) + 8 * i);
        if (v5)
        {
          (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
          int v3 = *((_DWORD *)this + 24);
        }
      }

      int v2 = (void *)*((void *)this + 11);
    }

    uprv_free(v2);
  }

  *((void *)this + 11) = 0LL;
  *((_DWORD *)this + 24) = 0;
}

icu::Transliterator *icu::CompoundTransliterator::clone@<X0>( UChar **this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  double result = (icu::Transliterator *)icu::UMemory::operator new(a3, (icu::UMemory *)0x68, a2);
  if (result)
  {
    uint64_t v5 = icu::Transliterator::Transliterator(result, this);
    *(void *)uint64_t v5 = off_189720530;
    *((void *)v5 + 11) = 0LL;
    *((void *)v5 + 12) = 0xFFFFFFFF00000000LL;
    return (icu::Transliterator *)icu::CompoundTransliterator::operator=((uint64_t)v5, (uint64_t)this);
  }

  return result;
}

uint64_t icu::CompoundTransliterator::getCount(icu::CompoundTransliterator *this)
{
  return *((unsigned int *)this + 24);
}

uint64_t icu::CompoundTransliterator::getTransliterator(icu::CompoundTransliterator *this, int a2)
{
  return *(void *)(*((void *)this + 11) + 8LL * a2);
}

void *icu::CompoundTransliterator::adoptTransliterators( icu::CompoundTransliterator *this, icu::Transliterator **a2, int a3)
{
  v11[8] = *(UChar **)MEMORY[0x1895F89C0];
  icu::CompoundTransliterator::freeTransliterators(this);
  *((void *)this + 11) = a2;
  *((_DWORD *)this + 24) = a3;
  icu::CompoundTransliterator::computeMaximumContextLength(this);
  icu::CompoundTransliterator::joinIDs( *((icu::Transliterator *const **)this + 11),  *((_DWORD *)this + 24),  (uint64_t)v11);
  icu::UnicodeString::operator=((UChar **)this + 1, v11);
  __int16 v10 = 0;
  icu::UnicodeString::doAppend((uint64_t)this + 8, (uint64_t)&v10, 0, 1LL);
  uint64_t v6 = (void *)*((unsigned __int16 *)this + 8);
  else {
    unsigned int v7 = v6 >> 5;
  }
  int v8 = v7 - 1;
  if ((v6 & 1) != 0 && v7 == 1)
  {
    icu::UnicodeString::unBogus((uint64_t)this + 8);
  }

  else if (v7 > v8)
  {
    if (v8 > 1023)
    {
      uint64_t v6 = (void *)(v6 | 0xFFE0);
      *((_WORD *)this + 8) = (_WORD)v6;
      *((_DWORD *)this + 5) = v8;
    }

    else
    {
      uint64_t v6 = (void *)(v6 & 0x1F | (32 * v8));
      *((_WORD *)this + 8) = (_WORD)v6;
    }
  }

  return icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)v11);
}

icu::UnicodeString *icu::CompoundTransliterator::toRules( icu::CompoundTransliterator *this, icu::UnicodeString *a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  unsigned int v6 = *((unsigned __int16 *)a2 + 4);
  if ((v6 & 1) != 0)
  {
    icu::UnicodeString::unBogus((uint64_t)a2);
  }

  else
  {
    if ((v6 & 0x8000u) == 0) {
      unsigned int v7 = v6 >> 5;
    }
    else {
      unsigned int v7 = *((_DWORD *)a2 + 3);
    }
    if (v7) {
      *((_WORD *)a2 + 4) &= 0x1Fu;
    }
  }

  if (*((int *)this + 25) >= 1 && icu::Transliterator::getFilter(this))
  {
    __int128 v40 = 0u;
    uint64_t v43 = 0LL;
    __int128 v42 = 0u;
    __int128 v41 = 0u;
    uint64_t v39 = off_18971B688;
    LOWORD(v40) = 2;
    uint64_t v8 = icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)L"::", 0, 2LL);
    uint64_t Filter = icu::Transliterator::getFilter(this);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), uint64_t))(*(void *)(Filter + 8) + 24LL))( Filter + 8,  &v39,  a3);
    unsigned int v11 = *(unsigned __int16 *)(v10 + 8);
    int v12 = (__int16)v11;
    unsigned int v13 = v11 >> 5;
    if (v12 >= 0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = *(unsigned int *)(v10 + 12);
    }
    uint64_t v15 = icu::UnicodeString::doAppend(v8, (const icu::UnicodeString *)v10, 0, v14);
    v38[0] = 59;
    icu::UnicodeString::doAppend(v15, (uint64_t)v38, 0, 1LL);
    uint64_t v35 = L"::";
    icu::UnicodeString::~UnicodeString(&v35, (icu::UnicodeString *)&v39);
  }

  if (*((int *)this + 24) >= 1)
  {
    uint64_t v16 = 0LL;
    do
    {
      uint64_t v43 = 0LL;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v40 = 0u;
      uint64_t v39 = off_18971B688;
      LOWORD(v40) = 2;
      uint64_t v17 = *(void *)(*((void *)this + 11) + 8 * v16);
      uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 104LL))(v17);
      BOOL v19 = icu::UnicodeString::doEqualsSubstring(v18, 0, 5, (uint64_t)L"%Pass", 0, 5);
      uint64_t v20 = **(void **)(*((void *)this + 11) + 8 * v16);
      if (v19)
      {
        (*(void (**)(void))(v20 + 112))();
        if (v16)
        {
          if (*((int *)this + 25) >= 2)
          {
            uint64_t v21 = *(void *)(*((void *)this + 11) + 8LL * (v16 - 1));
            uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 104LL))(v21);
            if (icu::UnicodeString::doEqualsSubstring(v22, 0, 5, (uint64_t)L"%Pass", 0, 5))
            {
              v36 = ":";
              icu::UnicodeString::UnicodeString(v37, 1LL, &v36);
              icu::operator+((uint64_t)v37, (uint64_t)&v39, (uint64_t)v38);
              icu::UnicodeString::operator=((icu::UnicodeString *)&v39, (icu::UnicodeString *)v38);
              icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)v38);
              icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)v37);
            }
          }
        }
      }

      else
      {
        uint64_t v25 = (*(uint64_t (**)(void))(v20 + 104))();
        unsigned int v26 = *(unsigned __int16 *)(v25 + 8);
        int v27 = (__int16)v26;
        int32_t v28 = v26 >> 5;
        if (v27 >= 0) {
          int32_t v29 = v28;
        }
        else {
          int32_t v29 = *(_DWORD *)(v25 + 12);
        }
        int v30 = icu::UnicodeString::doIndexOf(v25, 0x3Bu, 0, v29);
        uint64_t v31 = *(icu::Transliterator **)(*((void *)this + 11) + 8 * v16);
        if (v30 < 0) {
          icu::Transliterator::toRules(v31, (icu::UnicodeString *)&v39, a3);
        }
        else {
          (*(void (**)(icu::Transliterator *, void (***)(icu::UnicodeString *__hidden), uint64_t))(*(void *)v31 + 112LL))( v31,  &v39,  a3);
        }
      }

      sub_1808BC928((uint64_t)a2, 10);
      if ((v40 & 0x8000u) == 0LL) {
        uint64_t v32 = (unsigned __int16)v40 >> 5;
      }
      else {
        uint64_t v32 = DWORD1(v40);
      }
      icu::UnicodeString::doAppend((uint64_t)a2, (const icu::UnicodeString *)&v39, 0, v32);
      sub_1808BC928((uint64_t)a2, 59);
      icu::UnicodeString::~UnicodeString(v33, (icu::UnicodeString *)&v39);
      ++v16;
    }

    while (v16 < *((int *)this + 24));
  }

  return a2;
}

uint64_t sub_1808BC928(uint64_t result, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(result + 8);
  if (*(__int16 *)(result + 8) < 0)
  {
    unsigned int v3 = *(_DWORD *)(result + 12);
    if (!v3) {
      return result;
    }
  }

  else
  {
    if (v2 < 0x20) {
      return result;
    }
    unsigned int v3 = v2 >> 5;
  }

  signed int v4 = v3 - 1;
  if ((v2 & 2) != 0) {
    uint64_t v5 = result + 10;
  }
  else {
    uint64_t v5 = *(void *)(result + 24);
  }
  if (*(unsigned __int16 *)(v5 + 2LL * v4) != a2)
  {
    __int16 v6 = a2;
    return icu::UnicodeString::doAppend(result, (uint64_t)&v6, 0, 1LL);
  }

  return result;
}

void *icu::CompoundTransliterator::handleGetSourceSet( icu::CompoundTransliterator *this, icu::UnicodeSet *a2)
{
  uint64_t v9 = 0LL;
  memset(v8, 0, sizeof(v8));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v8);
  icu::UnicodeSet::clear(a2);
  uint64_t v4 = *((unsigned int *)this + 24);
  if ((int)v4 >= 1)
  {
    for (uint64_t i = 0LL; i < v4; ++i)
    {
      SourceSet = icu::Transliterator::getSourceSet( *(const icu::UnicodeSet ***)(*((void *)this + 11) + 8 * i),  (icu::UVector **)v8);
      icu::UnicodeSet::addAll((icu::UVector **)a2, (const icu::UnicodeSet *)SourceSet);
      if (!icu::UnicodeSet::isEmpty(a2)) {
        break;
      }
      uint64_t v4 = *((int *)this + 24);
    }
  }

  return icu::UnicodeSet::~UnicodeSet((void *)v4, (icu::UnicodeSet *)v8);
}

icu::UnicodeSet *icu::CompoundTransliterator::getTargetSet( icu::CompoundTransliterator *this, icu::UnicodeSet *a2)
{
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v9);
  icu::UnicodeSet::clear(a2);
  uint64_t v4 = *((unsigned int *)this + 24);
  if ((int)v4 >= 1)
  {
    for (uint64_t i = 0LL; i < v4; ++i)
    {
      uint64_t v6 = *(void *)(*((void *)this + 11) + 8 * i);
      unsigned int v7 = (const icu::UnicodeSet *)(*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)v6 + 128LL))(v6, v9);
      icu::UnicodeSet::addAll((icu::UVector **)a2, v7);
      uint64_t v4 = *((int *)this + 24);
    }
  }

  icu::UnicodeSet::~UnicodeSet((void *)v4, (icu::UnicodeSet *)v9);
  return a2;
}

uint64_t icu::CompoundTransliterator::handleTransliterate(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(_DWORD *)(a3 + 12);
  if (*(int *)(result + 96) <= 0)
  {
    *(_DWORD *)(a3 + 8) = v5;
  }

  else
  {
    uint64_t v8 = result;
    uint64_t v9 = 0LL;
    int v10 = 0;
    int v11 = *(_DWORD *)(a3 + 8);
    int v12 = *(_DWORD *)(a3 + 12);
    do
    {
      *(_DWORD *)(a3 + 8) = v11;
      if (v11 == v12) {
        break;
      }
      uint64_t v13 = *(void *)(*(void *)(v8 + 88) + 8 * v9);
      double result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 88LL))(v13, a2, a3, a4);
      if ((_DWORD)a4)
      {
        int v14 = *(_DWORD *)(a3 + 8);
        int v15 = *(_DWORD *)(a3 + 12);
        *(_DWORD *)(a3 + 12) = v14;
      }

      else
      {
        int v14 = *(_DWORD *)(a3 + 12);
        if (*(_DWORD *)(a3 + 8) != v14) {
          *(_DWORD *)(a3 + 8) = v14;
        }
        int v15 = v14;
      }

      int v10 = v10 - v12 + v15;
      ++v9;
      int v12 = v14;
    }

    while (v9 < *(int *)(v8 + 96));
    *(_DWORD *)(a3 + 12) = v10 + v5;
  }

  return result;
}

void sub_1808BCBDC(int *a1)
{
  uint64_t v134 = *MEMORY[0x1895F89C0];
  if (*a1 <= 0)
  {
    unsigned int v2 = atomic_load(&dword_18C5352D0);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_18C5352D0))
    {
      if (dword_18C5352D4 >= 1) {
        *a1 = dword_18C5352D4;
      }
    }

    else
    {
      sub_1809B36C0(0x1Du, (uint64_t)sub_1808BDA40);
      unsigned int v7 = icu::UMemory::operator new(v4, (icu::UMemory *)0x10, v3);
      if (v7)
      {
        uint64_t v8 = icu::UMemory::operator new((uint64_t *)v6, (icu::UMemory *)8, v5);
        if (v8) {
          *uint64_t v8 = (uint64_t)&unk_189721FD8;
        }
        uint64_t *v7 = (uint64_t)v8;
        uint64_t v6 = 1LL;
        *((_BYTE *)v7 + 8) = 1;
      }

      v121[0] = v7;
      int v11 = icu::UMemory::operator new((uint64_t *)v6, (icu::UMemory *)0x10, v5);
      if (v11)
      {
        int v12 = icu::UMemory::operator new((uint64_t *)v10, (icu::UMemory *)8, v9);
        if (v12) {
          *int v12 = (uint64_t)&unk_189721E70;
        }
        *int v11 = (uint64_t)v12;
        uint64_t v10 = 1LL;
        *((_BYTE *)v11 + 8) = 1;
      }

      v121[1] = v11;
      int v15 = icu::UMemory::operator new((uint64_t *)v10, (icu::UMemory *)0x10, v9);
      if (v15)
      {
        uint64_t v16 = icu::UMemory::operator new((uint64_t *)v14, (icu::UMemory *)8, v13);
        if (v16) {
          *uint64_t v16 = (uint64_t)&unk_189721EC0;
        }
        *int v15 = (uint64_t)v16;
        uint64_t v14 = 1LL;
        *((_BYTE *)v15 + 8) = 1;
      }

      v133 = 0LL;
      __int128 v132 = 0u;
      __int128 v131 = 0u;
      __int128 v130 = 0u;
      __int128 v129 = 0u;
      __int128 v128 = 0u;
      __int128 v126 = 0u;
      __int128 v127 = 0u;
      __int128 v124 = 0u;
      __int128 v125 = 0u;
      __int128 v122 = 0u;
      __int128 v123 = 0u;
      v121[2] = v15;
      BOOL v19 = icu::UMemory::operator new((uint64_t *)v14, (icu::UMemory *)0x10, v13);
      if (v19)
      {
        uint64_t v20 = icu::UMemory::operator new((uint64_t *)v18, (icu::UMemory *)8, v17);
        if (v20) {
          *uint64_t v20 = (uint64_t)&unk_189721F28;
        }
        *BOOL v19 = (uint64_t)v20;
        uint64_t v18 = 1LL;
        *((_BYTE *)v19 + 8) = 1;
      }

      v121[3] = v19;
      int v23 = icu::UMemory::operator new((uint64_t *)v18, (icu::UMemory *)0x10, v17);
      if (v23)
      {
        unsigned int v24 = icu::UMemory::operator new((uint64_t *)v22, (icu::UMemory *)8, v21);
        if (v24) {
          uint64_t *v24 = (uint64_t)&unk_189721F80;
        }
        uint64_t *v23 = (uint64_t)v24;
        uint64_t v22 = 1LL;
        *((_BYTE *)v23 + 8) = 1;
      }

      v121[4] = v23;
      int v27 = icu::UMemory::operator new((uint64_t *)v22, (icu::UMemory *)0x10, v21);
      if (v27)
      {
        int32_t v28 = icu::UMemory::operator new((uint64_t *)v26, (icu::UMemory *)8, v25);
        if (v28)
        {
          *int32_t v28 = 0LL;
          int32_t v28 = sub_1808BEE24(v28);
          *int32_t v28 = (uint64_t)&unk_189721888;
        }

        *int v27 = (uint64_t)v28;
        uint64_t v26 = 1LL;
        *((_BYTE *)v27 + 8) = 1;
      }

      *(void *)&__int128 v122 = v27;
      uint64_t v31 = icu::UMemory::operator new((uint64_t *)v26, (icu::UMemory *)0x10, v25);
      if (v31)
      {
        uint64_t v32 = icu::UMemory::operator new((uint64_t *)v30, (icu::UMemory *)8, v29);
        if (v32)
        {
          *uint64_t v32 = 0LL;
          uint64_t v32 = sub_1808BEE24(v32);
          *uint64_t v32 = (uint64_t)&unk_1897218E0;
        }

        uint64_t *v31 = (uint64_t)v32;
        uint64_t v30 = 1LL;
        *((_BYTE *)v31 + 8) = 1;
      }

      *((void *)&v122 + 1) = v31;
      uint64_t v35 = icu::UMemory::operator new((uint64_t *)v30, (icu::UMemory *)0x10, v29);
      if (v35)
      {
        v36 = icu::UMemory::operator new((uint64_t *)v34, (icu::UMemory *)8, v33);
        if (v36)
        {
          uint64_t *v36 = 0LL;
          v36 = sub_1808BEE24(v36);
          uint64_t *v36 = (uint64_t)&unk_189721950;
        }

        *uint64_t v35 = (uint64_t)v36;
        uint64_t v34 = 1LL;
        *((_BYTE *)v35 + 8) = 1;
      }

      *(void *)&__int128 v123 = v35;
      uint64_t v39 = icu::UMemory::operator new((uint64_t *)v34, (icu::UMemory *)0x10, v33);
      if (v39)
      {
        __int128 v40 = icu::UMemory::operator new((uint64_t *)v38, (icu::UMemory *)8, v37);
        if (v40)
        {
          uint64_t *v40 = 0LL;
          __int128 v40 = sub_1808BEE24(v40);
          uint64_t *v40 = (uint64_t)&unk_1897219C0;
        }

        *uint64_t v39 = (uint64_t)v40;
        uint64_t v38 = 1LL;
        *((_BYTE *)v39 + 8) = 1;
      }

      *((void *)&v123 + 1) = v39;
      uint64_t v43 = icu::UMemory::operator new((uint64_t *)v38, (icu::UMemory *)0x10, v37);
      if (v43)
      {
        uint64_t v44 = icu::UMemory::operator new((uint64_t *)v42, (icu::UMemory *)8, v41);
        if (v44)
        {
          *uint64_t v44 = 0LL;
          uint64_t v44 = sub_1808BEE24(v44);
          *uint64_t v44 = (uint64_t)&unk_189721A30;
        }

        *uint64_t v43 = (uint64_t)v44;
        uint64_t v42 = 1LL;
        *((_BYTE *)v43 + 8) = 1;
      }

      *(void *)&__int128 v124 = v43;
      v47 = icu::UMemory::operator new((uint64_t *)v42, (icu::UMemory *)0x10, v41);
      if (v47)
      {
        v48 = icu::UMemory::operator new((uint64_t *)v46, (icu::UMemory *)8, v45);
        if (v48)
        {
          uint64_t *v48 = 0LL;
          v48 = sub_1808BEE24(v48);
          uint64_t *v48 = (uint64_t)&unk_189721AA0;
        }

        uint64_t *v47 = (uint64_t)v48;
        uint64_t v46 = 1LL;
        *((_BYTE *)v47 + 8) = 1;
      }

      *((void *)&v124 + 1) = v47;
      v51 = icu::UMemory::operator new((uint64_t *)v46, (icu::UMemory *)0x10, v45);
      if (v51)
      {
        v52 = icu::UMemory::operator new((uint64_t *)v50, (icu::UMemory *)8, v49);
        if (v52)
        {
          uint64_t *v52 = 0LL;
          v52 = sub_1808BEE24(v52);
          uint64_t *v52 = (uint64_t)&unk_189721AF8;
        }

        uint64_t *v51 = (uint64_t)v52;
        uint64_t v50 = 1LL;
        *((_BYTE *)v51 + 8) = 1;
      }

      *(void *)&__int128 v125 = v51;
      v55 = icu::UMemory::operator new((uint64_t *)v50, (icu::UMemory *)0x10, v49);
      if (v55)
      {
        v56 = icu::UMemory::operator new((uint64_t *)v54, (icu::UMemory *)8, v53);
        if (v56)
        {
          uint64_t *v56 = 0LL;
          v56 = sub_1808BEE24(v56);
          uint64_t *v56 = (uint64_t)&unk_189721C18;
        }

        uint64_t *v55 = (uint64_t)v56;
        uint64_t v54 = 1LL;
        *((_BYTE *)v55 + 8) = 1;
      }

      *((void *)&v125 + 1) = v55;
      v59 = icu::UMemory::operator new((uint64_t *)v54, (icu::UMemory *)0x10, v53);
      if (v59)
      {
        v60 = icu::UMemory::operator new((uint64_t *)v58, (icu::UMemory *)8, v57);
        if (v60)
        {
          uint64_t *v60 = 0LL;
          v60 = sub_1808BEE24(v60);
          uint64_t *v60 = (uint64_t)&unk_189721BC0;
        }

        uint64_t *v59 = (uint64_t)v60;
        uint64_t v58 = 1LL;
        *((_BYTE *)v59 + 8) = 1;
      }

      *(void *)&__int128 v126 = v59;
      v63 = icu::UMemory::operator new((uint64_t *)v58, (icu::UMemory *)0x10, v57);
      if (v63)
      {
        v64 = icu::UMemory::operator new((uint64_t *)v62, (icu::UMemory *)8, v61);
        if (v64)
        {
          uint64_t *v64 = 0LL;
          v64 = sub_1808BEE24(v64);
          uint64_t *v64 = (uint64_t)&unk_189721C70;
        }

        uint64_t *v63 = (uint64_t)v64;
        uint64_t v62 = 1LL;
        *((_BYTE *)v63 + 8) = 1;
      }

      *((void *)&v126 + 1) = v63;
      v67 = icu::UMemory::operator new((uint64_t *)v62, (icu::UMemory *)0x10, v61);
      if (v67)
      {
        v68 = icu::UMemory::operator new((uint64_t *)v66, (icu::UMemory *)8, v65);
        if (v68)
        {
          uint64_t *v68 = 0LL;
          v68 = sub_1808BEE24(v68);
          uint64_t *v68 = (uint64_t)&unk_189721B68;
        }

        uint64_t *v67 = (uint64_t)v68;
        uint64_t v66 = 1LL;
        *((_BYTE *)v67 + 8) = 1;
      }

      *(void *)&__int128 v127 = v67;
      v71 = icu::UMemory::operator new((uint64_t *)v66, (icu::UMemory *)0x10, v65);
      if (v71)
      {
        v72 = icu::UMemory::operator new((uint64_t *)v70, (icu::UMemory *)8, v69);
        if (v72) {
          uint64_t *v72 = (uint64_t)&unk_189720760;
        }
        uint64_t *v71 = (uint64_t)v72;
        uint64_t v70 = 1LL;
        *((_BYTE *)v71 + 8) = 1;
      }

      *((void *)&v127 + 1) = v71;
      v75 = icu::UMemory::operator new((uint64_t *)v70, (icu::UMemory *)0x10, v69);
      if (v75)
      {
        v76 = icu::UMemory::operator new((uint64_t *)v74, (icu::UMemory *)8, v73);
        if (v76) {
          uint64_t *v76 = (uint64_t)&unk_1897208D8;
        }
        uint64_t *v75 = (uint64_t)v76;
        uint64_t v74 = 1LL;
        *((_BYTE *)v75 + 8) = 1;
      }

      *(void *)&__int128 v128 = v75;
      v79 = icu::UMemory::operator new((uint64_t *)v74, (icu::UMemory *)0x10, v73);
      if (v79)
      {
        v80 = icu::UMemory::operator new((uint64_t *)v78, (icu::UMemory *)8, v77);
        if (v80) {
          uint64_t *v80 = (uint64_t)&unk_1897207D0;
        }
        uint64_t *v79 = (uint64_t)v80;
        uint64_t v78 = 1LL;
        *((_BYTE *)v79 + 8) = 1;
      }

      *((void *)&v128 + 1) = v79;
      v83 = icu::UMemory::operator new((uint64_t *)v78, (icu::UMemory *)0x10, v77);
      if (v83)
      {
        v84 = icu::UMemory::operator new((uint64_t *)v82, (icu::UMemory *)8, v81);
        if (v84) {
          uint64_t *v84 = (uint64_t)&unk_189720828;
        }
        uint64_t *v83 = (uint64_t)v84;
        uint64_t v82 = 1LL;
        *((_BYTE *)v83 + 8) = 1;
      }

      *(void *)&__int128 v129 = v83;
      v87 = icu::UMemory::operator new((uint64_t *)v82, (icu::UMemory *)0x10, v81);
      if (v87)
      {
        v88 = icu::UMemory::operator new((uint64_t *)v86, (icu::UMemory *)8, v85);
        if (v88) {
          uint64_t *v88 = (uint64_t)&unk_189720880;
        }
        uint64_t *v87 = (uint64_t)v88;
        uint64_t v86 = 1LL;
        *((_BYTE *)v87 + 8) = 1;
      }

      *((void *)&v129 + 1) = v87;
      v91 = icu::UMemory::operator new((uint64_t *)v86, (icu::UMemory *)0x10, v85);
      if (v91)
      {
        v92 = icu::UMemory::operator new((uint64_t *)v90, (icu::UMemory *)8, v89);
        if (v92) {
          uint64_t *v92 = (uint64_t)&unk_189720628;
        }
        uint64_t *v91 = (uint64_t)v92;
        uint64_t v90 = 1LL;
        *((_BYTE *)v91 + 8) = 1;
      }

      *(void *)&__int128 v130 = v91;
      v95 = icu::UMemory::operator new((uint64_t *)v90, (icu::UMemory *)0x10, v89);
      if (v95)
      {
        v96 = icu::UMemory::operator new((uint64_t *)v94, (icu::UMemory *)8, v93);
        if (v96) {
          uint64_t *v96 = (uint64_t)&unk_189720690;
        }
        uint64_t *v95 = (uint64_t)v96;
        uint64_t v94 = 1LL;
        *((_BYTE *)v95 + 8) = 1;
      }

      *((void *)&v130 + 1) = v95;
      v99 = icu::UMemory::operator new((uint64_t *)v94, (icu::UMemory *)0x10, v93);
      if (v99)
      {
        v100 = icu::UMemory::operator new((uint64_t *)v98, (icu::UMemory *)8, v97);
        if (v100) {
          uint64_t *v100 = (uint64_t)&unk_1897206E0;
        }
        uint64_t *v99 = (uint64_t)v100;
        uint64_t v98 = 1LL;
        *((_BYTE *)v99 + 8) = 1;
      }

      *(void *)&__int128 v131 = v99;
      v103 = icu::UMemory::operator new((uint64_t *)v98, (icu::UMemory *)0x10, v97);
      if (v103)
      {
        v104 = icu::UMemory::operator new(v102, (icu::UMemory *)8, v101);
        if (v104)
        {
          uint64_t *v104 = 0LL;
          v104 = sub_1808BEE24(v104);
          v102 = (uint64_t *)&unk_189721CE0;
          uint64_t *v104 = (uint64_t)&unk_189721CE0;
        }

        uint64_t *v103 = (uint64_t)v104;
        *((_BYTE *)v103 + 8) = 0;
      }

      *((void *)&v131 + 1) = v103;
      v107 = icu::UMemory::operator new(v102, (icu::UMemory *)0x10, v101);
      if (v107)
      {
        v108 = icu::UMemory::operator new(v106, (icu::UMemory *)8, v105);
        if (v108)
        {
          uint64_t *v108 = 0LL;
          v108 = sub_1808BEE24(v108);
          v106 = (uint64_t *)&unk_189721D38;
          uint64_t *v108 = (uint64_t)&unk_189721D38;
        }

        uint64_t *v107 = (uint64_t)v108;
        *((_BYTE *)v107 + 8) = 0;
      }

      *(void *)&__int128 v132 = v107;
      v111 = icu::UMemory::operator new(v106, (icu::UMemory *)0x10, v105);
      if (v111)
      {
        v112 = icu::UMemory::operator new(v110, (icu::UMemory *)8, v109);
        if (v112)
        {
          uint64_t *v112 = 0LL;
          v112 = sub_1808BEE24(v112);
          v110 = (uint64_t *)&unk_189721DA8;
          uint64_t *v112 = (uint64_t)&unk_189721DA8;
        }

        uint64_t *v111 = (uint64_t)v112;
        *((_BYTE *)v111 + 8) = 0;
      }

      *((void *)&v132 + 1) = v111;
      v115 = icu::UMemory::operator new(v110, (icu::UMemory *)0x10, v109);
      if (v115)
      {
        v116 = icu::UMemory::operator new(v114, (icu::UMemory *)8, v113);
        if (v116)
        {
          uint64_t *v116 = 0LL;
          v116 = sub_1808BEE24(v116);
          uint64_t *v116 = (uint64_t)&unk_189721E00;
        }

        uint64_t *v115 = (uint64_t)v116;
        *((_BYTE *)v115 + 8) = 0;
      }

      v133 = v115;
      v117 = (char *)uprv_malloc(0xE0uLL);
      qword_18C5352C8 = (uint64_t)v117;
      if (v117)
      {
        uint64_t v118 = 0LL;
        byte_18C5352C0 = 1;
        do
        {
          int64x2_t v119 = *(int64x2_t *)&v121[v118];
          *(int64x2_t *)&v117[v118 * 8] = v119;
          *(int32x2_t *)v119.i8 = vmovn_s64(vceqzq_s64(v119));
          v118 += 2LL;
        }

        while (v118 != 28);
        int v120 = *a1;
      }

      else
      {
        int v120 = 7;
        *a1 = 7;
      }

      dword_18C5352D4 = v120;
      icu::umtx_initImplPostInit(&dword_18C5352D0);
    }
  }

uint64_t **sub_1808BD45C@<X0>(uint64_t **a1@<X0>, int *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v5 = icu::UMemory::operator new(a3, (icu::UMemory *)0x38, (unint64_t)a2);
  if (v5) {
    unint64_t v5 = (uint64_t *)sub_1808FC22C(v5, a2);
  }
  *a1 = v5;
  a1[1] = 0LL;
  uint64_t v6 = a1 + 1;
  a1[3] = 0LL;
  *(uint64_t **)((char *)a1 + 14) = 0LL;
  if (*a2 <= 0)
  {
    sub_1808BCBDC(a2);
    if (*a2 <= 0)
    {
      if (byte_18C5352C0) {
        size_t v7 = 224LL;
      }
      else {
        size_t v7 = 0LL;
      }
      uint64_t v8 = uprv_malloc(v7);
      *uint64_t v6 = v8;
      if (!v8)
      {
LABEL_20:
        *a2 = 7;
        return a1;
      }

      uint64_t v10 = (uint64_t *)byte_18C5352C0;
      if (byte_18C5352C0 == 1)
      {
        for (unint64_t i = 0LL; ; ++i)
        {
          int v12 = icu::UMemory::operator new(v10, (icu::UMemory *)0x20, v9);
          if (v12) {
            int v12 = (uint64_t *)sub_1808BDD4C((uint64_t)v12);
          }
          *(void *)(*v6 + 8 * i) = v12;
          if (!*(void *)(*v6 + 8 * i)) {
            break;
          }
          uint64_t v10 = (uint64_t *)byte_18C5352C0;
          if (byte_18C5352C0 != 1 || i > 0x1A) {
            return a1;
          }
        }

        goto LABEL_20;
      }
    }
  }

  return a1;
}

uint64_t sub_1808BD550(uint64_t a1)
{
  if (*(void *)a1)
  {
    unsigned int v2 = (void *)sub_1808FC268();
    icu::UMemory::operator delete(v2);
  }

  if (byte_18C5352C0 == 1)
  {
    unint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *(void **)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        icu::UMemory::operator delete(v4);
        if (!byte_18C5352C0) {
          break;
        }
      }
    }

    while (v3++ < 0x1B);
  }

  uprv_free(*(void **)(a1 + 8));
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6) {
    uprv_free(v6);
  }
  return a1;
}

size_t sub_1808BD5E8(uint64_t a1, char *a2, int a3)
{
  size_t result = sub_1808FC26C(*(void *)a1, a2, a3);
  *(_BYTE *)(a1 + 21) = 1;
  return result;
}

uint64_t sub_1808BD614(uint64_t a1, char a2)
{
  uint64_t v2 = *(char *)(a1 + 20);
  *(_BYTE *)(a1 + 20) = a2;
  *(_BYTE *)(a1 + 21) = 1;
  return v2;
}

uint64_t sub_1808BD62C(uint64_t a1)
{
  return *(char *)(a1 + 20);
}

char *sub_1808BD634(char **a1, char *a2, int a3)
{
  return sub_1808FC2AC(*a1, a2, a3);
}

uint64_t sub_1808BD63C(uint64_t a1, int *a2)
{
  int v4 = 0;
  sub_1808BD68C((void *)a1, &v4, a2);
  if (v4 < 1) {
    return 0LL;
  }
  else {
    return **(void **)(a1 + 8);
  }
}

uint64_t sub_1808BD68C(void *a1, _DWORD *a2, int *a3)
{
  if (sub_1808FC314(*a1))
  {
    if (*((_BYTE *)a1 + 21))
    {
      sub_1808FC324((unsigned __int8 **)*a1, *((char *)a1 + 20));
      *((_DWORD *)a1 + 4) = 0;
      if (byte_18C5352C0 == 1)
      {
        unint64_t v6 = 0LL;
        do
        {
          if ((*(unsigned int (**)(void, void, void))(***(void ***)(qword_18C5352C8 + 8 * v6) + 16LL))( **(void **)(qword_18C5352C8 + 8 * v6),  *a1,  *(void *)(a1[1] + 8LL * *((int *)a1 + 4))))
          {
            ++*((_DWORD *)a1 + 4);
          }
        }

        while (byte_18C5352C0 == 1 && v6++ < 0x1B);
        uint64_t v8 = *((unsigned int *)a1 + 4);
      }

      *((_BYTE *)a1 + 21) = 0;
    }

    int v9 = *((_DWORD *)a1 + 4);
    *a2 = v9;
    if (v9) {
      return a1[1];
    }
    uint64_t result = 0LL;
    int v11 = 10;
  }

  else
  {
    uint64_t result = 0LL;
    int v11 = 2;
  }

  *a3 = v11;
  return result;
}

uint64_t sub_1808BD7A0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v4 = sub_1808BDDD8(*a3);
  return v4 - sub_1808BDDD8(*a2);
}

void *ucsdet_setDetectableCharset_0(void *result, const char *a2, unsigned __int8 a3, int *a4)
{
  if (*a4 > 0) {
    return result;
  }
  if (byte_18C5352C0 != 1)
  {
LABEL_10:
    int v12 = 1;
    goto LABEL_11;
  }

  size_t v7 = result;
  unint64_t v8 = 0LL;
  while (1)
  {
    uint64_t v9 = *(void *)(qword_18C5352C8 + 8 * v8);
    uint64_t v10 = (const char *)(***(uint64_t (****)(void))v9)(*(void *)v9);
    uint64_t result = (void *)strcmp(v10, a2);
    if (!(_DWORD)result) {
      break;
    }
    BOOL v11 = byte_18C5352C0 != 1 || v8++ >= 0x1B;
    if (v11) {
      goto LABEL_10;
    }
  }

  uint64_t result = (void *)v7[3];
  if (!result && *(unsigned __int8 *)(v9 + 8) != a3)
  {
    if (byte_18C5352C0) {
      size_t v13 = 28LL;
    }
    else {
      size_t v13 = 0LL;
    }
    uint64_t result = uprv_malloc(v13);
    v7[3] = result;
    if (result)
    {
      if (byte_18C5352C0 != 1)
      {
LABEL_25:
        *((_BYTE *)result + v8) = a3;
        return result;
      }

      unint64_t v14 = 0LL;
      uint64_t v15 = qword_18C5352C8;
      do
      {
        *(_BYTE *)(v7[3] + v14) = *(_BYTE *)(*(void *)(v15 + 8 * v14) + 8LL);
        BOOL v11 = v14++ >= 0x1B;
      }

      while (!v11);
      uint64_t result = (void *)v7[3];
      goto LABEL_24;
    }

    int v12 = 7;
LABEL_11:
    *a4 = v12;
    return result;
  }

void *sub_1808BD8F4(int *a1)
{
  if (*a1 <= 0)
  {
    int v4 = uprv_malloc(0x38uLL);
    uint64_t v2 = v4;
    if (!v4)
    {
      *a1 = 7;
      return v2;
    }

    *(_OWORD *)int v4 = xmmword_1897205E0;
    *((_OWORD *)v4 + 1) = *(_OWORD *)&off_1897205F0;
    *((_OWORD *)v4 + 2) = xmmword_189720600;
    v4[6] = sub_1808BDD40;
    unint64_t v5 = uprv_malloc(0x10uLL);
    v2[1] = v5;
    if (v5)
    {
      *unint64_t v5 = 0LL;
      v5[1] = 0LL;
      *((_BYTE *)v5 + 4) = 1;
      return v2;
    }

    *a1 = 7;
    uprv_free(v2);
  }

  return 0LL;
}

void *ucsdet_getDetectableCharsets_0(uint64_t a1, int *a2)
{
  if (*a2 <= 0)
  {
    unint64_t v6 = uprv_malloc(0x38uLL);
    uint64_t v2 = v6;
    if (!v6)
    {
      *a2 = 7;
      return v2;
    }

    *(_OWORD *)unint64_t v6 = xmmword_1897205E0;
    *((_OWORD *)v6 + 1) = *(_OWORD *)&off_1897205F0;
    *((_OWORD *)v6 + 2) = xmmword_189720600;
    v6[6] = sub_1808BDD40;
    size_t v7 = uprv_malloc(0x10uLL);
    v2[1] = v7;
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 24);
      void *v7 = 0LL;
      v7[1] = v8;
      return v2;
    }

    *a2 = 7;
    uprv_free(v2);
  }

  return 0LL;
}

uint64_t sub_1808BDA40()
{
  unsigned int v0 = (void *)qword_18C5352C8;
  if (qword_18C5352C8)
  {
    if (byte_18C5352C0 == 1)
    {
      unint64_t v1 = 0LL;
      do
      {
        uint64_t v2 = (void *)v0[v1];
        if (v2)
        {
          if (*v2) {
            (*(void (**)(void))(*(void *)*v2 + 32LL))(*v2);
          }
          icu::UMemory::operator delete(v2);
          unsigned int v0 = (void *)qword_18C5352C8;
          int v3 = byte_18C5352C0;
        }

        else
        {
          int v3 = 1;
        }

        v0[v1] = 0LL;
        if (!v3) {
          break;
        }
      }

      while (v1++ < 0x1B);
    }

    uprv_free(v0);
    qword_18C5352C8 = 0LL;
    byte_18C5352C0 = 0;
  }

  atomic_store(0, &dword_18C5352D0);
  return 1LL;
}

void sub_1808BDAE8(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    uprv_free(v2);
  }
  uprv_free(a1);
}

uint64_t sub_1808BDB14(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(_BYTE *)(v1 + 4))
  {
    if (byte_18C5352C0) {
      return 28LL;
    }
    else {
      return 0LL;
    }
  }

  uint64_t v3 = *(void *)(v1 + 8);
  if (v3)
  {
    if (byte_18C5352C0)
    {
      unint64_t v4 = 0LL;
      LODWORD(result) = 0;
      do
      {
        if (*(_BYTE *)(v3 + v4)) {
          uint64_t result = (result + 1);
        }
        else {
          uint64_t result = result;
        }
        BOOL v5 = v4++ >= 0x1B;
      }

      while (!v5);
      return result;
    }

    return 0LL;
  }

  if (!byte_18C5352C0) {
    return 0LL;
  }
  unint64_t v6 = 0LL;
  LODWORD(result) = 0;
  do
  {
    if (*(_BYTE *)(*(void *)(qword_18C5352C8 + 8 * v6) + 8LL)) {
      uint64_t result = (result + 1);
    }
    else {
      uint64_t result = result;
    }
    BOOL v5 = v6++ >= 0x1B;
  }

  while (!v5);
  return result;
}

const char *sub_1808BDBB4(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)v3;
  char v5 = byte_18C5352C0;
  if (byte_18C5352C0) {
    int v6 = 28;
  }
  else {
    int v6 = 0;
  }
  if (v4 < v6)
  {
    if (*(_BYTE *)(v3 + 4))
    {
      uint64_t v8 = **(uint64_t (*****)(void))(qword_18C5352C8 + 8LL * v4);
      uint64_t v9 = (const char *)(**v8)(v8);
      ++**(_DWORD **)(a1 + 8);
      goto LABEL_27;
    }

    uint64_t v10 = *(void *)(v3 + 8);
    if (v10)
    {
      while (1)
      {
        int v11 = (v5 & 1) != 0 ? 28 : 0;
        if (v4 >= v11) {
          break;
        }
        if (*(_BYTE *)(v10 + v4))
        {
          int v12 = **(uint64_t (*****)(void))(qword_18C5352C8 + 8LL * v4);
          uint64_t v9 = (const char *)(**v12)(v12);
          char v5 = byte_18C5352C0;
          uint64_t v3 = *(void *)(a1 + 8);
          int v4 = *(_DWORD *)v3;
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        *(_DWORD *)uint64_t v3 = ++v4;
        if (v9) {
          goto LABEL_27;
        }
      }
    }

    else
    {
      while (1)
      {
        int v13 = (v5 & 1) != 0 ? 28 : 0;
        if (v4 >= v13) {
          break;
        }
        uint64_t v14 = *(void *)(qword_18C5352C8 + 8LL * v4);
        if (*(_BYTE *)(v14 + 8))
        {
          uint64_t v9 = (const char *)(***(uint64_t (****)(void))v14)(*(void *)v14);
          char v5 = byte_18C5352C0;
          uint64_t v3 = *(void *)(a1 + 8);
          int v4 = *(_DWORD *)v3;
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        *(_DWORD *)uint64_t v3 = ++v4;
        if (v9) {
          goto LABEL_27;
        }
      }
    }
  }

  uint64_t v9 = 0LL;
LABEL_27:
  if (a2)
  {
    if (v9) {
      int v15 = strlen(v9);
    }
    else {
      int v15 = 0;
    }
    *a2 = v15;
  }

  return v9;
}

uint64_t sub_1808BDD40(uint64_t result)
{
  **(_DWORD **)(result + 8) = 0;
  return result;
}

uint64_t sub_1808BDD4C(uint64_t result)
{
  *(void *)uint64_t result = 0LL;
  *(_DWORD *)(result + 8) = 0;
  *(void *)(result + 16) = 0LL;
  *(void *)(result + 24) = 0LL;
  return result;
}

uint64_t sub_1808BDD5C(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t result = a2;
  *(_DWORD *)(result + 8) = a4;
  *(void *)(result + 16) = a5;
  *(void *)(result + 24) = a6;
  if (a3)
  {
    uint64_t v7 = result;
    if (a5)
    {
      if (a6) {
        return result;
      }
LABEL_6:
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 8LL))(a3);
      *(void *)(v7 + 24) = result;
      return result;
    }

    uint64_t result = (**(uint64_t (***)(uint64_t))a3)(a3);
    *(void *)(v7 + 16) = result;
    if (!*(void *)(v7 + 24)) {
      goto LABEL_6;
    }
  }

  return result;
}

uint64_t sub_1808BDDC8(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1808BDDD0(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_1808BDDD8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_1808BDDE0(unsigned __int8 **a1, unint64_t a2, int a3, UErrorCode *a4)
{
  uint64_t v8 = ucnv_open(a1[2], a4);
  uint64_t v9 = ucnv_toUChars((uint64_t)v8, a2, a3, *((const char **)*a1 + 5), *((_DWORD *)*a1 + 12), (int *)a4);
  ucnv_close(v8);
  return v9;
}

uint64_t sub_1808BDE54(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3 < 1) {
    return 0LL;
  }
  int v6 = 0;
  int v7 = 0;
  uint64_t v23 = a2 + 1;
  uint64_t v24 = 0LL;
  uint64_t v22 = (unsigned __int8 *)(a4 + 1);
  uint64_t v25 = a5;
  do
  {
    int v8 = *(unsigned __int8 *)(a2 + v7);
    if (v8 == 27)
    {
      uint64_t v9 = a5;
      if ((int)a5 >= 1)
      {
        uint64_t v10 = 0LL;
        int v11 = v22;
        do
        {
          uint64_t v12 = a4;
          int v13 = strlen((const char *)(a4 + 5 * v10));
          if (a3 - v7 >= v13)
          {
            if (v13 < 2)
            {
LABEL_13:
              ++HIDWORD(v24);
              int v7 = v7 + v13 - 1;
              a5 = v9;
              a4 = v12;
              goto LABEL_17;
            }

            uint64_t v14 = v13 - 1LL;
            int v15 = v11;
            uint64_t v16 = (unsigned __int8 *)(v23 + v7);
            while (1)
            {
              int v18 = *v15++;
              int v17 = v18;
              int v19 = *v16++;
              if (v17 != v19) {
                break;
              }
              if (!--v14) {
                goto LABEL_13;
              }
            }
          }

          ++v10;
          v11 += 5;
          a4 = v12;
        }

        while (v10 != v25);
      }

      LODWORD(v24) = v24 + 1;
      a5 = v9;
    }

    if ((v8 & 0xFE) == 0xE) {
      ++v6;
    }
LABEL_17:
    ++v7;
  }

  while (v7 < a3);
  if (!HIDWORD(v24)) {
    return 0LL;
  }
  if (v6 + HIDWORD(v24) >= 5) {
    int v20 = 0;
  }
  else {
    int v20 = -10 * (5 - (v6 + HIDWORD(v24)));
  }
  return (100 * (HIDWORD(v24) - (int)v24) / ((int)v24 + HIDWORD(v24)) + v20) & ~((100
                                                                                              * (HIDWORD(v24) - (int)v24)
}

void sub_1808BDFF4(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BE008()
{
  return "ISO-2022-JP";
}

BOOL sub_1808BE014(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BDE54(a1, *(void *)a2, *(_DWORD *)(a2 + 8), (uint64_t)"\x1B$(C", 12LL);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BE084(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BE098()
{
  return "ISO-2022-KR";
}

BOOL sub_1808BE0A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BDE54(a1, *(void *)a2, *(_DWORD *)(a2 + 8), (uint64_t)"\x1B$)C", 1LL);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BE114(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BE128()
{
  return "ISO-2022-CN";
}

BOOL sub_1808BE134(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BDE54(a1, *(void *)a2, *(_DWORD *)(a2 + 8), (uint64_t)"\x1B$)A", 11LL);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

const char *sub_1808BE1A0()
{
  return "";
}

uint64_t sub_1808BE1AC(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned __int8 *a5)
{
  int v10 = 0;
  unsigned int v11 = 0;
  int v12 = 0;
  int v39 = 0;
  int v13 = 0;
  unint64_t v40 = 0xFFFFFFFF00000000LL;
  uint64_t v41 = 0LL;
  int v14 = a4 - 1;
  while ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t))(*(void *)a1 + 40LL))(a1, &v40, a2))
  {
    if (BYTE4(v41))
    {
      ++v10;
    }

    else if (v40 >= 0x100)
    {
      if (a3 && a4 >= 1)
      {
        int v15 = 0;
        int v16 = v14;
        int v17 = v14;
        while (1)
        {
          int v18 = v16 >= 0 ? v16 : v16 + 1;
          int v19 = v18 >> 1;
          unsigned int v20 = *(unsigned __int16 *)(a3 + 2LL * v19);
          else {
            int v15 = v19 + 1;
          }
          int v16 = v15 + v17;
          if (v15 > v17) {
            goto LABEL_21;
          }
        }

        int v21 = v39;
        if (v16 > -2) {
          int v21 = v39 + 1;
        }
        int v39 = v21;
      }

void sub_1808BE440(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_1808BE454(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(int *)(a2 + 8);
  *(_DWORD *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 12) = 0;
  int v4 = *(_DWORD *)(a3 + 48);
  if ((int)v3 >= v4)
  {
    uint64_t result = 0LL;
    *(_BYTE *)(a2 + 13) = 1;
    *(_DWORD *)a2 = -1;
  }

  else
  {
    uint64_t v5 = *(void *)(a3 + 40);
    uint64_t v6 = v3 + 1;
    *(_DWORD *)(a2 + 8) = v3 + 1;
    int v7 = *(char *)(v5 + v3);
    int v8 = *(unsigned __int8 *)(v5 + v3);
    *(_DWORD *)a2 = v8;
    uint64_t result = 1LL;
    if (v7 < 0 && (v8 - 161) >= 0x3F)
    {
      if ((int)v6 >= v4)
      {
        *(_BYTE *)(a2 + 13) = 1;
        int v10 = -1;
      }

      else
      {
        *(_DWORD *)(a2 + 8) = v3 + 2;
        int v10 = *(unsigned __int8 *)(v5 + v6);
        *(_DWORD *)a2 = v10 | (v8 << 8);
      }
    }
  }

  return result;
}

BOOL sub_1808BE4FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BE1AC(a1, a2, (uint64_t)&unk_180A34A60, 57, byte_180A34EA7);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

const char *sub_1808BE568()
{
  return "Shift_JIS";
}

const char *sub_1808BE574()
{
  return "ja";
}

uint64_t sub_1808BE580(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(int *)(a2 + 8);
  *(_DWORD *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 12) = 0;
  int v4 = *(_DWORD *)(a3 + 48);
  if ((int)v3 >= v4)
  {
    uint64_t result = 0LL;
    *(_BYTE *)(a2 + 13) = 1;
    *(_DWORD *)a2 = -1;
    return result;
  }

  uint64_t v5 = *(void *)(a3 + 40);
  uint64_t v6 = v3 + 1;
  *(_DWORD *)(a2 + 8) = v3 + 1;
  unsigned int v7 = *(unsigned __int8 *)(v5 + v3);
  *(_DWORD *)a2 = v7;
  if (v7 < 0x8E) {
    return 1LL;
  }
  if ((int)v6 >= v4)
  {
    *(_BYTE *)(a2 + 13) = 1;
    if (v7 - 161 < 0x5E)
    {
LABEL_20:
      uint64_t result = 1LL;
LABEL_21:
      *(_BYTE *)(a2 + 12) = 1;
      return result;
    }

    int v10 = -1;
    int v11 = v7;
  }

  else
  {
    int v9 = v3 + 2;
    *(_DWORD *)(a2 + 8) = v3 + 2;
    int v10 = *(unsigned __int8 *)(v5 + v6);
    int v11 = v10 | (v7 << 8);
    *(_DWORD *)a2 = v11;
    if (v7 - 161 < 0x5E)
    {
      goto LABEL_20;
    }

    LODWORD(v6) = v9;
  }

  if (v7 == 143)
  {
    if ((int)v6 >= v4)
    {
      *(_BYTE *)(a2 + 13) = 1;
      *(_DWORD *)a2 = -1;
    }

    else
    {
      *(_DWORD *)(a2 + 8) = v6 + 1;
      unsigned int v12 = *(unsigned __int8 *)(v5 + (int)v6);
      *(_DWORD *)a2 = v12 | (v11 << 8);
      if (v12 > 0xA0) {
        return 1LL;
      }
    }

    goto LABEL_20;
  }

  if (v7 != 142) {
    return 1LL;
  }
  uint64_t result = 1LL;
  if (v10 <= 160) {
    goto LABEL_21;
  }
  return result;
}

void sub_1808BE694(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BE6A8()
{
  return "EUC-JP";
}

const char *sub_1808BE6B4()
{
  return "ja";
}

BOOL sub_1808BE6C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BE1AC(a1, a2, (uint64_t)&unk_180A34AD2, 100, byte_180A34ED7);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BE730(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BE744()
{
  return "EUC-KR";
}

const char *sub_1808BE750()
{
  return "ko";
}

BOOL sub_1808BE75C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BE1AC(a1, a2, (uint64_t)&unk_180A34B9A, 100, byte_180A34F07);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BE7CC(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_1808BE7E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(int *)(a2 + 8);
  *(_DWORD *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 12) = 0;
  int v4 = *(_DWORD *)(a3 + 48);
  if ((int)v3 >= v4)
  {
    uint64_t result = 0LL;
    *(_BYTE *)(a2 + 13) = 1;
    *(_DWORD *)a2 = -1;
  }

  else
  {
    uint64_t v5 = *(void *)(a3 + 40);
    uint64_t v6 = v3 + 1;
    *(_DWORD *)(a2 + 8) = v3 + 1;
    int v7 = *(char *)(v5 + v3);
    int v8 = *(unsigned __int8 *)(v5 + v3);
    *(_DWORD *)a2 = v8;
    if (v7 > -2) {
      return 1LL;
    }
    if ((int)v6 >= v4)
    {
      *(_BYTE *)(a2 + 13) = 1;
    }

    else
    {
      *(_DWORD *)(a2 + 8) = v3 + 2;
      unsigned int v10 = *(unsigned __int8 *)(v5 + v6);
      *(_DWORD *)a2 = v10 | (v8 << 8);
      if (v10 >= 0x40 && (v10 & 0x7F) != 0x7F) {
        return 1LL;
      }
    }

    uint64_t result = 1LL;
    *(_BYTE *)(a2 + 12) = 1;
  }

  return result;
}

const char *sub_1808BE880()
{
  return "Big5";
}

const char *sub_1808BE88C()
{
  return "zh";
}

BOOL sub_1808BE898(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BE1AC(a1, a2, (uint64_t)&unk_180A34C62, 96, byte_180A34F47);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BE908(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_1808BE91C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(int *)(a2 + 8);
  *(_DWORD *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 12) = 0;
  int v4 = *(_DWORD *)(a3 + 48);
  if ((int)v3 >= v4)
  {
    uint64_t result = 0LL;
    *(_BYTE *)(a2 + 13) = 1;
    int v9 = -1;
LABEL_5:
    *(_DWORD *)a2 = v9;
    return result;
  }

  uint64_t v5 = *(void *)(a3 + 40);
  uint64_t v6 = v3 + 1;
  *(_DWORD *)(a2 + 8) = v3 + 1;
  unsigned int v7 = *(unsigned __int8 *)(v5 + v3);
  *(_DWORD *)a2 = v7;
  if (v7 < 0x81) {
    return 1LL;
  }
  if ((int)v6 >= v4)
  {
    *(_BYTE *)(a2 + 13) = 1;
    int v11 = -1;
    int v12 = v7;
  }

  else
  {
    int v10 = v3 + 2;
    *(_DWORD *)(a2 + 8) = v3 + 2;
    int v11 = *(unsigned __int8 *)(v5 + v6);
    int v12 = v11 | (v7 << 8);
    *(_DWORD *)a2 = v12;
    LODWORD(v6) = v10;
  }

  uint64_t result = 1LL;
  if (v7 != 255 && (v11 - 64) >= 0xBF)
  {
    if ((v11 - 48) <= 9)
    {
      if ((int)v6 >= v4)
      {
LABEL_17:
        *(_BYTE *)(a2 + 13) = 1;
        goto LABEL_18;
      }

      uint64_t v13 = (int)v6 + 1LL;
      *(_DWORD *)(a2 + 8) = v13;
      int v14 = *(unsigned __int8 *)(v5 + (int)v6);
      if ((v14 - 129) <= 0x7D)
      {
        if ((int)v13 < v4)
        {
          *(_DWORD *)(a2 + 8) = v6 + 2;
          int v15 = *(unsigned __int8 *)(v5 + v13);
          if ((v15 - 48) <= 9)
          {
            int v9 = (v12 << 16) | (v14 << 8) | v15;
            goto LABEL_5;
          }

          goto LABEL_18;
        }

        goto LABEL_17;
      }
    }

const char *sub_1808BEA30()
{
  return "GB18030";
}

const char *sub_1808BEA3C()
{
  return "zh";
}

BOOL sub_1808BEA48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1808BE1AC(a1, a2, (uint64_t)&unk_180A34D22, 100, byte_180A34F87);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

uint64_t sub_1808BEABC(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v3 = 32 * (*(_DWORD *)(a2 + 128) <= a3);
  if (*(_DWORD *)(a2 + 4LL * (v3 | 0x10)) <= a3) {
    unsigned int v3 = (32 * (*(_DWORD *)(a2 + 128) <= a3)) | 0x10;
  }
  if (*(_DWORD *)(a2 + 4LL * (v3 | 8)) <= a3) {
    v3 |= 8u;
  }
  if (*(_DWORD *)(a2 + 4LL * (v3 | 4)) <= a3) {
    v3 |= 4u;
  }
  if (*(_DWORD *)(a2 + 4LL * (v3 + 2)) <= a3) {
    v3 += 2;
  }
  if (*(_DWORD *)(a2 + 4LL * (v3 + 1)) <= a3) {
    ++v3;
  }
  int v4 = v3 - (*(_DWORD *)(a2 + 4LL * v3) > a3);
  if (v4 < 0) {
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1808BEB4C(uint64_t a1, int a2)
{
  uint64_t result = sub_1808BEABC(a1, *(void *)(a1 + 16), a2);
  if ((result & 0x80000000) == 0) {
    ++*(_DWORD *)(a1 + 28);
  }
  return result;
}

uint64_t sub_1808BEB90(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(int *)(a1 + 32);
  uint64_t v3 = *a2;
  *(_DWORD *)(a1 + 32) = v2 + 1;
  return *(unsigned __int8 *)(v3 + v2);
}

uint64_t sub_1808BEBBC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  if ((result & 0x80000000) == 0)
  {
    char v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = *(unsigned __int8 *)(v6 + result);
      if (*(_BYTE *)(v6 + result))
      {
        BOOL v8 = v7 == 32;
        if (((v7 == 32) & v5) != 0)
        {
          char v5 = 1;
        }

        else
        {
          unsigned int v9 = v7 & 0xFF0000FF | ((unsigned __int16)*(_DWORD *)(a1 + 8) << 8);
          *(_DWORD *)(a1 + 8) = v9;
          sub_1808BEB4C(a1, v9);
          char v5 = v8;
        }
      }

      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16LL))(a1, a2);
    }

    while ((result & 0x80000000) == 0);
  }

  return result;
}

uint64_t sub_1808BEC4C(_DWORD *a1)
{
  int v2 = ((unsigned __int16)a1[2] << 8) | 0x20;
  a1[2] = v2;
  sub_1808BEB4C((uint64_t)a1, v2);
  double v3 = (double)(int)a1[7] / (double)(int)a1[6];
  if (v3 <= 0.33) {
    return (int)(v3 * 300.0);
  }
  else {
    return 98LL;
  }
}

uint64_t sub_1808BECC8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(int *)(a1 + 32);
  if ((int)v2 < *((_DWORD *)a2 + 2))
  {
    uint64_t v3 = *a2;
    if (*(_BYTE *)(*a2 + v2))
    {
      int v4 = *(_BYTE *)(*a2 + v2) & 0xFE;
      switch(v4)
      {
        case 178:
          int v5 = 71;
          break;
        case 184:
          int v5 = 86;
          break;
        case 180:
          int v5 = 73;
          break;
        default:
          *(_DWORD *)(a1 + 48) = 0;
          uint64_t v6 = byte_180A34FC8[*(unsigned __int8 *)(v3 + v2)];
          goto LABEL_12;
      }

      *(_DWORD *)(a1 + 48) = v5;
      uint64_t v6 = 177LL;
LABEL_12:
      *(_DWORD *)(a1 + 32) = v2 + 1;
      return v6;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_1808BED4C(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  if ((result & 0x80000000) == 0)
  {
    char v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = *(unsigned __int8 *)(v6 + result);
      if (*(_BYTE *)(v6 + result))
      {
        BOOL v8 = v7 == 32;
        if (((v7 == 32) & v5) != 0)
        {
          char v5 = 1;
        }

        else
        {
          unsigned int v9 = v7 & 0xFF0000FF | ((unsigned __int16)*(_DWORD *)(a1 + 8) << 8);
          *(_DWORD *)(a1 + 8) = v9;
          sub_1808BEB4C(a1, v9);
          char v5 = v8;
        }
      }

      if (*(_DWORD *)(a1 + 48))
      {
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v11 = *(_DWORD *)(a1 + 48);
        int v12 = *(unsigned __int8 *)(v10 + v11);
        if (*(_BYTE *)(v10 + v11))
        {
          BOOL v13 = v12 == 32;
          if (((v12 == 32) & v5) != 0)
          {
            char v5 = 1;
          }

          else
          {
            unsigned int v14 = v12 & 0xFF0000FF | ((unsigned __int16)*(_DWORD *)(a1 + 8) << 8);
            *(_DWORD *)(a1 + 8) = v14;
            sub_1808BEB4C(a1, v14);
            char v5 = v13;
          }
        }
      }

      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16LL))(a1, a2);
    }

    while ((result & 0x80000000) == 0);
  }

  return result;
}

void *sub_1808BEE24(void *result)
{
  *uint64_t result = &unk_189720990;
  return result;
}

uint64_t sub_1808BEE3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v6 = 0u;
  v5[1] = 0LL;
  v5[0] = &off_189720930;
  v5[2] = a3;
  uint64_t v7 = a4;
  DWORD2(v6) = 0;
  LODWORD(v6) = 0;
  return sub_1808BEC4C(v5);
}

void sub_1808BEE88(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

BOOL sub_1808BEE9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  if (*(_BYTE *)(a2 + 24)) {
    uint64_t v7 = "windows-1252";
  }
  else {
    uint64_t v7 = "ISO-8859-1";
  }
  int v8 = -1;
  do
  {
    uint64_t v9 = *(void *)((char *)&unk_1897209C0 + v6 + 256);
    int v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40LL))(a1, a2);
    if (v10 > v8)
    {
      int v11 = v10;
      sub_1808BDD5C(a3, a2, a1, v10, (uint64_t)v7, v9);
      int v8 = v11;
    }

    v6 += 264LL;
  }

  while (v6 != 2640);
  if (v8 <= 9 && *(_BYTE *)(a2 + 25))
  {
    int v8 = 15;
    sub_1808BDD5C(a3, a2, a1, 15, (uint64_t)v7, 0LL);
  }

  return v8 > 0;
}

const char *sub_1808BEFA4()
{
  return "ISO-8859-1";
}

void sub_1808BEFB4(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

BOOL sub_1808BEFC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  if (*(_BYTE *)(a2 + 24)) {
    uint64_t v7 = "windows-1250";
  }
  else {
    uint64_t v7 = "ISO-8859-2";
  }
  int v8 = -1;
  do
  {
    uint64_t v9 = *(void *)((char *)&unk_189721410 + v6 + 256);
    int v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40LL))(a1, a2);
    if (v10 > v8)
    {
      int v11 = v10;
      sub_1808BDD5C(a3, a2, a1, v10, (uint64_t)v7, v9);
      int v8 = v11;
    }

    v6 += 264LL;
  }

  while (v6 != 1056);
  return v8 > 0;
}

const char *sub_1808BF0A0()
{
  return "ISO-8859-2";
}

const char *sub_1808BF0AC()
{
  return "ISO-8859-5";
}

void sub_1808BF0BC(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF0D0()
{
  return "ru";
}

BOOL sub_1808BF0DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A352C8,  "                                       ");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

const char *sub_1808BF14C()
{
  return "ISO-8859-6";
}

void sub_1808BF15C(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF170()
{
  return "ar";
}

BOOL sub_1808BF17C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A354C8,  "                                       ");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

const char *sub_1808BF1EC()
{
  return "ISO-8859-7";
}

void sub_1808BF1FC(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF210()
{
  return "el";
}

BOOL sub_1808BF21C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a2 + 24)) {
    int v6 = "windows-1253";
  }
  else {
    int v6 = "ISO-8859-7";
  }
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
  sub_1808BDD5C(a3, a2, a1, v7, (uint64_t)v6, (uint64_t)"el");
  return v7 > 0;
}

const char *sub_1808BF2B4()
{
  return "ISO-8859-8";
}

void sub_1808BF2C4(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF2D8()
{
  return "ISO-8859-8-I";
}

const char *sub_1808BF2E4()
{
  return "he";
}

BOOL sub_1808BF2F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a2 + 24)) {
    int v6 = "windows-1255";
  }
  else {
    int v6 = "ISO-8859-8-I";
  }
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
  sub_1808BDD5C(a3, a2, a1, v7, (uint64_t)v6, (uint64_t)"he");
  return v7 > 0;
}

void sub_1808BF38C(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF3A0()
{
  return "he";
}

BOOL sub_1808BF3AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a2 + 24)) {
    int v6 = "windows-1255";
  }
  else {
    int v6 = "ISO-8859-8";
  }
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
  sub_1808BDD5C(a3, a2, a1, v7, (uint64_t)v6, (uint64_t)"he");
  return v7 > 0;
}

const char *sub_1808BF444()
{
  return "ISO-8859-9";
}

void sub_1808BF454(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF468()
{
  return "tr";
}

BOOL sub_1808BF474(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a2 + 24)) {
    int v6 = "windows-1254";
  }
  else {
    int v6 = "ISO-8859-9";
  }
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
  sub_1808BDD5C(a3, a2, a1, v7, (uint64_t)v6, (uint64_t)"tr");
  return v7 > 0;
}

void sub_1808BF510(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF524()
{
  return "windows-1256";
}

const char *sub_1808BF530()
{
  return "ar";
}

BOOL sub_1808BF53C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A35DC8,  "                                       ");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BF5B0(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF5C4()
{
  return "windows-1251";
}

const char *sub_1808BF5D0()
{
  return "ru";
}

BOOL sub_1808BF5DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A35FC8,  "                                       ");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BF650(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF664()
{
  return "KOI8-R";
}

const char *sub_1808BF670()
{
  return "ru";
}

BOOL sub_1808BF67C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A361C8,  "                                       ");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

const char *sub_1808BF6EC()
{
  return "he";
}

void sub_1808BF6FC(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF710()
{
  return "IBM424_rtl";
}

BOOL sub_1808BF71C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A363C8,  "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ABCDEFGHI@@@@@@@QRSTUVWXY@@@@@@@@bcdefghi@@@@@@@q@@@@@@@@@@@");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BF790(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF7A4()
{
  return "IBM424_ltr";
}

BOOL sub_1808BF7B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, const char *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A365C8,  "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ABCDEFGHI@@@@@@@QRSTUVWXY@@@@@@@@bcdefghi@@@@@@@q@@@@@@@@@@@");
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

const char *sub_1808BF820()
{
  return "ar";
}

uint64_t sub_1808BF82C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v5[1] = 0LL;
  __int128 v6 = 0u;
  v5[2] = a3;
  __int128 v7 = a4;
  LODWORD(v6) = 0;
  v5[0] = &off_189720960;
  return sub_1808BEC4C(v5);
}

void sub_1808BF874(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF888()
{
  return "IBM420_rtl";
}

BOOL sub_1808BF894(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A366C8,  &unk_180A367C8);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BF908(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF91C()
{
  return "IBM420_ltr";
}

BOOL sub_1808BF928(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void *))(*(void *)a1 + 40LL))( a1,  a2,  &unk_180A368C8,  &unk_180A367C8);
  sub_1808BDD5C(a3, a2, a1, v6, 0LL, 0LL);
  return v6 > 0;
}

void sub_1808BF99C(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BF9B0()
{
  return "UTF-16BE";
}

BOOL sub_1808BF9BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a2 + 48);
  if (v3 >= 30) {
    int v3 = 30;
  }
  if (v3 < 2)
  {
    unsigned int v5 = 10;
  }

  else
  {
    uint64_t v4 = 0LL;
    unsigned int v5 = 10;
    while (1)
    {
      unsigned int v6 = __rev16(*(unsigned __int16 *)(*(void *)(a2 + 40) + v4));
      if (!v4 && v6 == 65279) {
        break;
      }
      BOOL v7 = v6 - 32 < 0xE0 || v6 == 10;
      unsigned int v8 = v5 + 10;
      if (!v7) {
        unsigned int v8 = v5;
      }
      int v9 = v5 - 10;
      if (v6) {
        int v9 = v8;
      }
      if (v9 >= 100) {
        int v9 = 100;
      }
      unsigned int v5 = v9 & ~(v9 >> 31);
      if (v5)
      {
        v4 += 2LL;
      }

      goto LABEL_25;
    }

    unsigned int v5 = 100;
  }

void sub_1808BFA9C(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BFAB0()
{
  return "UTF-16LE";
}

BOOL sub_1808BFABC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a2 + 48);
  if (v5 >= 30) {
    int v6 = 30;
  }
  else {
    int v6 = *(_DWORD *)(a2 + 48);
  }
  if (v6 < 2)
  {
    unsigned int v9 = 10;
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = *(void *)(a2 + 40);
    unsigned int v9 = 10;
    while (1)
    {
      int v10 = *(unsigned __int16 *)(v8 + v7);
      if (!v7 && v10 == 65279) {
        break;
      }
      BOOL v11 = (v10 - 32) < 0xE0 || v10 == 10;
      unsigned int v12 = v9 + 10;
      if (!v11) {
        unsigned int v12 = v9;
      }
      int v13 = v9 - 10;
      if (*(_WORD *)(v8 + v7)) {
        int v13 = v12;
      }
      if (v13 >= 100) {
        int v13 = 100;
      }
      unsigned int v9 = v13 & ~(v13 >> 31);
      if (v9)
      {
        v7 += 2LL;
      }

      goto LABEL_25;
    }

    if (v5 < 4)
    {
      unsigned int v9 = 100;
    }

    else
    {
      unsigned int v9 = 100;
      if (!*(_BYTE *)(v8 + 2))
      {
        if (*(_BYTE *)(v8 + 3)) {
          unsigned int v9 = 100;
        }
        else {
          unsigned int v9 = 0;
        }
      }
    }
  }

uint64_t sub_1808BFBB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a2 + 48);
  int v7 = v6 + 3;
  if (v6 >= 0) {
    int v7 = *(_DWORD *)(a2 + 48);
  }
  if (v6 < 4)
  {
    char v18 = 0;
    int v17 = 0;
  }

  else
  {
    uint64_t v8 = *(void *)(a2 + 40);
    signed int v9 = v7 & 0xFFFFFFFC;
    int v10 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 40LL))(a1, v8, 0LL);
    uint64_t v11 = 0LL;
    int v12 = 0;
    unsigned int v13 = 0;
    do
    {
      unsigned int v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40LL))(a1, v8, v11);
      BOOL v15 = v14 >= 0x10FFFF || v14 >> 11 == 27;
      int v16 = !v15;
      if (!v15) {
        ++v13;
      }
      v12 += v16 ^ 1;
      uint64_t v11 = (v11 + 4);
    }

    while ((int)v11 < v9);
    if (v10 == 65279 && !v12) {
      goto LABEL_16;
    }
    if (v10 == 65279 && v13 > 10 * v12)
    {
      int v17 = 80;
      goto LABEL_21;
    }

    if (v13 >= 4 && v12 == 0)
    {
LABEL_16:
      int v17 = 100;
LABEL_21:
      char v18 = 1;
      goto LABEL_22;
    }

    if (v13) {
      BOOL v21 = v12 == 0;
    }
    else {
      BOOL v21 = 0;
    }
    char v22 = v21;
    char v18 = v22 | (v13 > 10 * v12);
    if (v13 <= 10 * v12) {
      int v23 = 0;
    }
    else {
      int v23 = 25;
    }
    if ((v22 & 1) != 0) {
      int v17 = 80;
    }
    else {
      int v17 = v23;
    }
  }

void sub_1808BFD24(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BFD38()
{
  return "UTF-32BE";
}

uint64_t sub_1808BFD44(uint64_t a1, uint64_t a2, int a3)
{
  return bswap32(*(_DWORD *)(a2 + a3));
}

void sub_1808BFD54(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BFD68()
{
  return "UTF-32LE";
}

uint64_t sub_1808BFD74(uint64_t a1, uint64_t a2, int a3)
{
  return *(unsigned int *)(a2 + a3);
}

void sub_1808BFD80(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

const char *sub_1808BFD94()
{
  return "UTF-8";
}

BOOL sub_1808BFDA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 **)(a2 + 40);
  uint64_t v4 = *(unsigned int *)(a2 + 48);
  if ((int)v4 < 3)
  {
    if ((int)v4 < 1)
    {
      BOOL v14 = 1;
      goto LABEL_40;
    }

    goto LABEL_6;
  }

  if (*v3 != 239 || v3[1] != 187)
  {
LABEL_6:
    BOOL v5 = 0;
    goto LABEL_7;
  }

  BOOL v5 = v3[2] == 191;
LABEL_7:
  LODWORD(v6) = 0;
  int v7 = 0;
  int v8 = 0;
  do
  {
    int v9 = (char)v3[(int)v6];
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_21;
    }
    if ((v9 & 0xE0) == 0xC0)
    {
      int v10 = 1;
    }

    else if ((v9 & 0xF0) == 0xE0)
    {
      int v10 = 2;
    }

    else
    {
      if ((v9 & 0xF8) != 0xF0)
      {
LABEL_20:
        ++v7;
        goto LABEL_21;
      }

      int v10 = 3;
    }

    int v11 = v6 + v10;
    uint64_t v6 = (int)v6 + 1LL;
    while (v6 < v4)
    {
      if ((v3[v6] & 0xC0) != 0x80) {
        goto LABEL_20;
      }
      ++v6;
      if (!--v10)
      {
        ++v8;
        LODWORD(v6) = v11;
        break;
      }
    }

icu::Measure *icu::CurrencyAmount::CurrencyAmount@<X0>( icu::Measure *a1@<X0>, const icu::Formattable *a2@<X1>, uint64_t *a3@<X2>, UErrorCode *a4@<X3>, uint64_t *a5@<X8>)
{
  int v9 = icu::UMemory::operator new(a5, (icu::UMemory *)0x20, (unint64_t)a2);
  if (v9)
  {
    int v10 = (icu::MeasureUnit *)v9;
    uint64_t v12 = *a3;
    icu::CurrencyUnit::CurrencyUnit(v9, &v12, a4);
    icu::Measure::Measure(a1, a2, v10, a4);
  }

  else
  {
    icu::Measure::Measure(a1, a2, 0LL, a4);
  }

  *(void *)a1 = off_189722028;
  return a1;
}

icu::Measure *icu::CurrencyAmount::CurrencyAmount(icu::Measure *a1, uint64_t *a2, UErrorCode *a3, double a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  icu::Formattable::Formattable((icu::Formattable *)v13, a4);
  int v9 = icu::UMemory::operator new(v8, (icu::UMemory *)0x20, v7);
  if (v9)
  {
    int v10 = (icu::MeasureUnit *)v9;
    uint64_t v12 = *a2;
    icu::CurrencyUnit::CurrencyUnit(v9, &v12, a3);
    icu::Measure::Measure(a1, (const icu::Formattable *)v13, v10, a3);
  }

  else
  {
    icu::Measure::Measure(a1, (const icu::Formattable *)v13, 0LL, a3);
  }

  icu::Formattable::~Formattable((icu::Formattable *)v13);
  *(void *)a1 = off_189722028;
  return a1;
}

void *icu::CurrencyAmount::CurrencyAmount(icu::CurrencyAmount *this, const icu::CurrencyAmount *a2)
{
  uint64_t result = (void *)icu::Measure::Measure(this, a2);
  *uint64_t result = off_189722028;
  return result;
}

{
  void *result;
  uint64_t result = (void *)icu::Measure::Measure(this, a2);
  *uint64_t result = off_189722028;
  return result;
}

uint64_t icu::CurrencyAmount::operator=(uint64_t a1, uint64_t a2)
{
  icu::Measure::operator=(a1, a2);
  return a1;
}

icu::Measure *icu::CurrencyAmount::clone@<X0>( icu::CurrencyAmount *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::Measure *)icu::UMemory::operator new(a3, (icu::UMemory *)0x80, a2);
  if (result)
  {
    uint64_t result = (icu::Measure *)icu::Measure::Measure(result, this);
    *(void *)uint64_t result = off_189722028;
  }

  return result;
}

void icu::CurrencyAmount::~CurrencyAmount(icu::CurrencyAmount *this)
{
}

uint64_t icu::CurrencyAmount::getCurrency(icu::CurrencyAmount *this)
{
  return *((void *)this + 15);
}

void *icu::CurrencyAmount::getStaticClassID(icu::CurrencyAmount *this)
{
  return &unk_18C5352D8;
}

void *icu::CurrencyAmount::getDynamicClassID(icu::CurrencyAmount *this)
{
  return &unk_18C5352D8;
}

void *sub_1808C0198(uint64_t a1, const char **a2, UErrorCode *a3)
{
  uint64_t result = (void *)icu::MeasureFormat::MeasureFormat(a1, a2, 0, a3);
  *uint64_t result = &off_189722070;
  return result;
}

void sub_1808C01C4(icu::MeasureFormat *a1)
{
}

icu::MeasureFormat *sub_1808C01D8@<X0>( const icu::MeasureFormat *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::MeasureFormat *)icu::UMemory::operator new(a3, (icu::UMemory *)0x178, a2);
  if (result)
  {
    uint64_t result = icu::MeasureFormat::MeasureFormat(result, a1);
    *(void *)uint64_t result = &off_189722070;
  }

  return result;
}

uint64_t sub_1808C0214(icu::MeasureFormat *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t CurrencyFormatInternal = icu::MeasureFormat::getCurrencyFormatInternal(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)CurrencyFormatInternal
                                                                                + 40LL))( CurrencyFormatInternal,  a2,  a3,  a4,  a5);
}

icu::UObject *sub_1808C0260(icu::MeasureFormat *a1, uint64_t a2, icu::Formattable *a3, uint64_t a4)
{
  uint64_t CurrencyFormatInternal = icu::MeasureFormat::getCurrencyFormatInternal(a1);
  uint64_t result = (icu::UObject *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)CurrencyFormatInternal
                                                                                + 176LL))( CurrencyFormatInternal,  a2,  a4);
  if (result) {
    return (icu::UObject *)icu::Formattable::adoptObject(a3, result);
  }
  return result;
}

void *sub_1808C02C0()
{
  return &unk_18C5352D9;
}

void *icu::CurrencyPluralInfo::getStaticClassID(icu::CurrencyPluralInfo *this)
{
  return &unk_18C5352DA;
}

void *icu::CurrencyPluralInfo::getDynamicClassID(icu::CurrencyPluralInfo *this)
{
  return &unk_18C5352DA;
}

icu::CurrencyPluralInfo *icu::CurrencyPluralInfo::CurrencyPluralInfo( icu::CurrencyPluralInfo *this, UErrorCode *a2)
{
  *(void *)this = off_1897220D8;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 8) = 0;
  Default = icu::Locale::getDefault(this);
  icu::CurrencyPluralInfo::initialize(this, (const icu::Locale *)Default, a2);
  return this;
}

{
  uint64_t *Default;
  *(void *)this = off_1897220D8;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 8) = 0;
  Default = icu::Locale::getDefault(this);
  icu::CurrencyPluralInfo::initialize(this, (const icu::Locale *)Default, a2);
  return this;
}

void icu::CurrencyPluralInfo::initialize( icu::CurrencyPluralInfo *this, const icu::Locale *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v6 = *((void *)this + 3);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    *((void *)this + 3) = 0LL;
    uint64_t v7 = *((void *)this + 2);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    *((void *)this + 2) = 0LL;
    int v8 = icu::Locale::clone(a2, (unint64_t)a2);
    *((void *)this + 3) = v8;
    if (v8 && (*((_BYTE *)a2 + 216) || !*((_BYTE *)v8 + 216)))
    {
      *((void *)this + 2) = icu::PluralRules::forLocale(a2, (const icu::Locale *)a3, v9);
      icu::CurrencyPluralInfo::setupCurrencyPluralPattern(this, (char **)a2, a3);
    }

    else
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

icu::CurrencyPluralInfo *icu::CurrencyPluralInfo::CurrencyPluralInfo( icu::CurrencyPluralInfo *this, const icu::Locale *a2, UErrorCode *a3)
{
  *(void *)this = off_1897220D8;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 8) = 0;
  icu::CurrencyPluralInfo::initialize(this, a2, a3);
  return this;
}

{
  *(void *)this = off_1897220D8;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 8) = 0;
  icu::CurrencyPluralInfo::initialize(this, a2, a3);
  return this;
}

uint64_t icu::CurrencyPluralInfo::CurrencyPluralInfo(uint64_t this, uint64_t a2)
{
  *(void *)this = off_1897220D8;
  *(void *)(this + 8) = 0LL;
  *(void *)(this + 16) = 0LL;
  *(void *)(this + 24) = 0LL;
  *(_DWORD *)(this + 32) = 0;
  return icu::CurrencyPluralInfo::operator=(this, a2);
}

{
  *(void *)this = off_1897220D8;
  *(void *)(this + 8) = 0LL;
  *(void *)(this + 16) = 0LL;
  *(void *)(this + 24) = 0LL;
  *(_DWORD *)(this + 32) = 0;
  return icu::CurrencyPluralInfo::operator=(this, a2);
}

uint64_t icu::CurrencyPluralInfo::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 32) = v4;
    BOOL v5 = (_DWORD *)(a1 + 32);
    if (v4 <= 0)
    {
      icu::CurrencyPluralInfo::deleteHash(a1, *(uint64_t ***)(a1 + 8));
      inited = (uint64_t *)icu::CurrencyPluralInfo::initHash(v6, (UErrorCode *)(a1 + 32));
      *(void *)(a1 + 8) = inited;
      icu::CurrencyPluralInfo::copyHash((uint64_t)inited, *(uint64_t ***)(a2 + 8), inited, (int *)(a1 + 32));
      int v9 = (uint64_t *)*(unsigned int *)(a1 + 32);
      if ((int)v9 <= 0)
      {
        uint64_t v10 = *(void *)(a1 + 16);
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
        }
        *(void *)(a1 + 16) = 0LL;
        uint64_t v11 = *(void *)(a1 + 24);
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
        }
        *(void *)(a1 + 24) = 0LL;
        uint64_t v12 = *(icu::PluralRules **)(a2 + 16);
        if (v12 && (int v13 = icu::PluralRules::clone(v12, v9), (*(void *)(a1 + 16) = v13) == 0LL)
          || (uint64_t v14 = *(icu::Locale **)(a2 + 24)) != 0LL
          && ((BOOL v15 = icu::Locale::clone(v14, v8), (*(void *)(a1 + 24) = v15) == 0LL)
           || !*(_BYTE *)(*(void *)(a2 + 24) + 216LL) && *((_BYTE *)v15 + 216)))
        {
          *BOOL v5 = 7;
        }
      }
    }
  }

  return a1;
}

void icu::CurrencyPluralInfo::deleteHash(uint64_t a1, uint64_t **a2)
{
  if (a2)
  {
    int v5 = -1;
    while (1)
    {
      uint64_t v3 = uhash_nextElement(*a2, &v5);
      if (!v3) {
        break;
      }
      uint64_t v4 = *(void *)(v3 + 8);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      }
    }

    if (*a2) {
      uhash_close(*a2);
    }
    icu::UMemory::operator delete(a2);
  }

int32x2_t *icu::CurrencyPluralInfo::initHash(icu::CurrencyPluralInfo *this, UErrorCode *a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v2 <= 0)
  {
    int v5 = (int32x2_t *)icu::UMemory::operator new(v2, (icu::UMemory *)0x58, (unint64_t)a2);
    uint64_t v3 = v5;
    if (!v5)
    {
      int v9 = 0LL;
      if (*(int *)a2 <= 0)
      {
        uint64_t v3 = 0LL;
        *a2 = U_MEMORY_ALLOCATION_ERROR;
      }

      goto LABEL_12;
    }

    *int v5 = 0LL;
    if (*(int *)a2 <= 0
      && (uint64_t v6 = v5 + 1,
          uhash_init( v5 + 1,  (uint64_t)uhash_hashCaselessUnicodeString,  (uint64_t)uhash_compareCaselessUnicodeString,  0LL,  (int *)a2),  *(int *)a2 <= 0))
    {
      *uint64_t v3 = (int32x2_t)v6;
      uhash_setKeyDeleter((uint64_t)&v3[1], (uint64_t)uprv_deleteUObject);
      int v7 = *a2;
      int v9 = v3;
      if (v7 <= 0)
      {
        uhash_setValueComparator((uint64_t)*v3, (uint64_t)sub_1808C13E0);
        int v9 = 0LL;
        goto LABEL_12;
      }
    }

    else
    {
      int v9 = v3;
    }

    uint64_t v3 = 0LL;
LABEL_12:
    sub_1808C144C((_BYTE ***)&v9);
    return v3;
  }

  return 0LL;
}

void icu::CurrencyPluralInfo::copyHash(uint64_t a1, uint64_t **a2, uint64_t *a3, int *a4)
{
  v21[8] = *(UChar **)MEMORY[0x1895F89C0];
  if (*a4 <= 0)
  {
    int v20 = -1;
    if (a2)
    {
      do
      {
        uint64_t v7 = uhash_nextElement(*a2, &v20);
        if (!v7) {
          break;
        }
        uint64_t v11 = *(UChar ***)(v7 + 8);
        uint64_t v10 = *(UChar ***)(v7 + 16);
        uint64_t v12 = (icu::UnicodeString *)icu::UMemory::operator new(v9, (icu::UMemory *)0x40, v8);
        if (!v12)
        {
          if (*a4 <= 0) {
            *a4 = 7;
          }
          return;
        }

        uint64_t v13 = (uint64_t)v12;
        icu::UnicodeString::UnicodeString(v12, v11);
        if (*a4 > 0)
        {
          (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
          return;
        }

        icu::UnicodeString::UnicodeString((icu::UnicodeString *)v21, v10);
        uint64_t v14 = *a3;
        int v17 = (icu::UnicodeString *)icu::UMemory::operator new(v16, (icu::UMemory *)0x40, v15);
        uint64_t v18 = (uint64_t)v17;
        if (v17) {
          icu::UnicodeString::UnicodeString(v17, v21);
        }
        uhash_put(v14, v18, v13, a4);
        icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v21);
      }

      while (*a4 < 1);
    }
  }

void icu::CurrencyPluralInfo::~CurrencyPluralInfo(uint64_t ***this)
{
  *this = (uint64_t **)off_1897220D8;
  icu::CurrencyPluralInfo::deleteHash((uint64_t)this, this[1]);
  this[1] = 0LL;
  uint64_t v2 = this[2];
  if (v2) {
    ((void (*)(uint64_t **))(*v2)[1])(v2);
  }
  uint64_t v3 = this[3];
  if (v3) {
    ((void (*)(uint64_t **))(*v3)[1])(v3);
  }
  this[2] = 0LL;
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  void *v1;
  icu::CurrencyPluralInfo::~CurrencyPluralInfo(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::CurrencyPluralInfo::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 24LL))( *(void *)(a1 + 16),  *(void *)(a2 + 16));
  if ((_DWORD)result)
  {
    uint64_t result = icu::Locale::operator==(*(void *)(a1 + 24), *(void *)(a2 + 24));
    if ((_DWORD)result) {
      return uhash_equals(**(void **)(a1 + 8), **(void **)(a2 + 8)) != 0;
    }
  }

  return result;
}

uint64_t *icu::CurrencyPluralInfo::clone@<X0>( icu::CurrencyPluralInfo *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x28, a2);
  if (result)
  {
    *uint64_t result = (uint64_t)off_1897220D8;
    result[1] = 0LL;
    result[2] = 0LL;
    result[3] = 0LL;
    *((_DWORD *)result + 8) = 0;
    uint64_t result = (uint64_t *)icu::CurrencyPluralInfo::operator=((uint64_t)result, (uint64_t)this);
    if (*((int *)result + 8) >= 1)
    {
      (*(void (**)(uint64_t *))(*result + 8))(result);
      return 0LL;
    }
  }

  return result;
}

uint64_t icu::CurrencyPluralInfo::getPluralRules(icu::CurrencyPluralInfo *this)
{
  return *((void *)this + 2);
}

UChar **icu::CurrencyPluralInfo::getCurrencyPluralPattern( icu::CurrencyPluralInfo *this, const icu::UnicodeString *a2, UChar **a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (UChar **)uhash_get(**((void **)this + 1), (uint64_t)a2);
  if (v6) {
    goto LABEL_2;
  }
  unsigned int v7 = *((unsigned __int16 *)a2 + 4);
  int v8 = (__int16)v7;
  unsigned int v9 = v7 >> 5;
  int32_t v10 = v8 >= 0 ? v9 : *((_DWORD *)a2 + 3);
  if (icu::UnicodeString::doCompare((uint64_t)a2, 0, v10, (uint64_t)L"other", 0, 5)
    && (uint64_t v11 = (uint64_t *)*((void *)this + 1),
        unint64_t v15 = L"other",
        icu::UnicodeString::UnicodeString(v16, 1LL, &v15),
        uint64_t v6 = (UChar **)uhash_get(*v11, (uint64_t)v16),
        icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v16),
        v6))
  {
LABEL_2:
    icu::UnicodeString::operator=(a3, v6);
  }

  else
  {
    icu::UnicodeString::UnicodeString((uint64_t)v16, (uint64_t)a0_1);
    icu::UnicodeString::operator=((icu::UnicodeString *)a3, (icu::UnicodeString *)v16);
    icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v16);
  }

  return a3;
}

uint64_t icu::CurrencyPluralInfo::getLocale(icu::CurrencyPluralInfo *this)
{
  return *((void *)this + 3);
}

uint64_t *icu::CurrencyPluralInfo::setPluralRules( uint64_t *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v5 = this;
    uint64_t v6 = this[2];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    this = icu::PluralRules::createRules(a2, (const icu::UnicodeString *)a3, a3);
    v5[2] = (uint64_t)this;
  }

  return this;
}

uint64_t **icu::CurrencyPluralInfo::setCurrencyPluralPattern( uint64_t **this, UChar **a2, UChar **a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    unsigned int v7 = this;
    uint64_t v8 = uhash_get(*this[1], (uint64_t)a2);
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    this = (uint64_t **)icu::UMemory::operator new(v10, (icu::UMemory *)0x40, v9);
    if (this)
    {
      uint64_t v11 = (uint64_t)this;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)this, a3);
      if (*(int *)a4 <= 0)
      {
        uint64_t v13 = v7[1];
        uint64_t v14 = *v13;
        unint64_t v15 = (icu::UnicodeString *)icu::UMemory::operator new(v13, (icu::UMemory *)0x40, v12);
        uint64_t v16 = (uint64_t)v15;
        if (v15) {
          icu::UnicodeString::UnicodeString(v15, a2);
        }
        return (uint64_t **)uhash_put(v14, v16, v11, (int *)a4);
      }

      else
      {
        return (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
      }
    }

    else if (*(int *)a4 <= 0)
    {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

void icu::CurrencyPluralInfo::setupCurrencyPluralPattern( icu::CurrencyPluralInfo *this, char **a2, UErrorCode *a3)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    icu::CurrencyPluralInfo::deleteHash((uint64_t)this, *((uint64_t ***)this + 1));
    *((void *)this + 1) = icu::CurrencyPluralInfo::initHash(v6, a3);
    if (*(int *)a3 <= 0)
    {
      Instance = icu::NumberingSystem::createInstance((icu::NumberingSystem *)a2, a3, v7);
      UErrorCode v9 = *a3;
      if (!Instance && v9 <= U_ZERO_ERROR)
      {
        *a3 = U_MEMORY_ALLOCATION_ERROR;
        return;
      }

      if (v9 > U_ZERO_ERROR) {
        goto LABEL_86;
      }
      UErrorCode v78 = U_ZERO_ERROR;
      uint64_t v10 = ures_open(0LL, a2[5], (int *)&v78);
      uint64_t v11 = ures_getByKeyWithFallback(v10, "NumberElements", 0LL, &v78);
      Name = (char *)icu::NumberingSystem::getName(Instance);
      ures_getByKeyWithFallback(v11, Name, v10, &v78);
      ures_getByKeyWithFallback(v10, "patterns", v10, &v78);
      unsigned int v77 = 0;
      StringByKeyWithFallback = ures_getStringByKeyWithFallback(v10, "decimalFormat", (int *)&v77, &v78);
      UErrorCode v14 = v78;
      if (v78 == U_MISSING_RESOURCE_ERROR)
      {
        unint64_t v15 = StringByKeyWithFallback;
        uint64_t v16 = (const char *)icu::NumberingSystem::getName(Instance);
        int v17 = strcmp(v16, "latn");
        StringByKeyWithFallback = v15;
        if (v17)
        {
          UErrorCode v78 = U_ZERO_ERROR;
          ures_getByKeyWithFallback(v11, "latn", v10, &v78);
          ures_getByKeyWithFallback(v10, "patterns", v10, &v78);
          StringByKeyWithFallback = ures_getStringByKeyWithFallback(v10, "decimalFormat", (int *)&v77, &v78);
        }

        UErrorCode v14 = v78;
      }

      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
      uint64_t v20 = v77;
      if (v14 > U_ZERO_ERROR || (int)v77 < 1)
      {
        int v22 = 0;
      }

      else
      {
        unsigned int v21 = 0;
        int v22 = 0;
        LODWORD(v18) = 0;
        uint64_t v19 = 0LL;
        int v23 = StringByKeyWithFallback + 1;
        uint64_t v24 = v77;
        do
        {
          int v25 = *(v23 - 1);
          if (v25 == 59) {
            uint64_t v20 = v21;
          }
          else {
            uint64_t v20 = v20;
          }
          if (v25 == 59)
          {
            uint64_t v19 = (uint64_t)v23;
            uint64_t v18 = (v24 - 1);
          }

          else
          {
            uint64_t v18 = v18;
          }

          if (v25 == 59) {
            int v22 = 1;
          }
          ++v21;
          ++v23;
          --v24;
        }

        while (v24);
      }

      if (v14 >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        if (v14 == U_MEMORY_ALLOCATION_ERROR) {
          *a3 = U_MEMORY_ALLOCATION_ERROR;
        }
LABEL_82:
        if (v11) {
          ures_close(v11);
        }
        if (v10) {
          ures_close(v10);
        }
LABEL_86:
        if (Instance) {
          (*(void (**)(icu::NumberingSystem *))(*(void *)Instance + 8LL))(Instance);
        }
        return;
      }

      uint64_t v64 = (uint64_t)StringByKeyWithFallback;
      uint64_t v26 = ures_open("icudt74l-curr", a2[5], (int *)&v78);
      uint64_t v65 = ures_getByKeyWithFallback(v26, "CurrencyUnitPatterns", 0LL, &v78);
      uint64_t Keywords = icu::PluralRules::getKeywords(*((icu::PluralRules **)this + 2), &v78);
      UErrorCode v28 = v78;
      uint64_t v66 = Keywords;
      if (Keywords || v78 > U_ZERO_ERROR)
      {
        if (v78 <= U_ZERO_ERROR)
        {
          uint64_t v62 = v26;
          uint64_t v29 = (*(uint64_t (**)(uint64_t, void, UErrorCode *))(*(void *)Keywords + 40LL))( Keywords,  0LL,  &v78);
          if (v29)
          {
            int v30 = (char *)v29;
            uint64_t v63 = v11;
            while (1)
            {
              UErrorCode v28 = v78;
              if (v78 > U_ZERO_ERROR) {
                break;
              }
              uint64_t v76 = 0LL;
              uint64_t v31 = ures_getStringByKeyWithFallback(v65, v30, (int *)&v76 + 1, (UErrorCode *)&v76);
              UErrorCode v33 = (int)v76;
              if ((_DWORD)v76 == 7 || v31 == 0LL) {
                goto LABEL_71;
              }
              if ((int)v76 <= 0 && SHIDWORD(v76) >= 1)
              {
                uint64_t v36 = (uint64_t)v31;
                double v37 = icu::UMemory::operator new((uint64_t *)v76, (icu::UMemory *)0x40, v32);
                if (!v37)
                {
                  UErrorCode v33 = U_MEMORY_ALLOCATION_ERROR;
LABEL_71:
                  uint64_t v11 = v63;
                  UErrorCode v78 = v33;
                  goto LABEL_72;
                }

                v67 = (icu::UnicodeString *)v37;
                icu::UnicodeString::UnicodeString((uint64_t)v37, v36, HIDWORD(v76));
                v75 = "{";
                icu::UnicodeString::UnicodeString(v83, 1LL, &v75);
                icu::UnicodeString::UnicodeString((uint64_t)&v80, v64, v20);
                else {
                  int32_t v38 = *((unsigned __int16 *)v67 + 4) >> 5;
                }
                if ((SWORD4(v83[0]) & 0x8000u) == 0) {
                  uint64_t v39 = WORD4(v83[0]) >> 5;
                }
                else {
                  uint64_t v39 = HIDWORD(v83[0]);
                }
                int v40 = v81 >> 5;
                if ((v81 & 0x8000u) != 0) {
                  int v40 = v82;
                }
                icu::UnicodeString::findAndReplace( v67,  0,  v38,  (const icu::UnicodeString *)v83,  0,  v39,  (const icu::UnicodeString *)&v80,  0,  v40);
                icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)&v80);
                uint64_t v43 = icu::UnicodeString::~UnicodeString(v42, (icu::UnicodeString *)v83);
                v69[1] = v75;
                uint64_t v74 = "{";
                icu::UnicodeString::UnicodeString(v43, 1LL, &v74);
                unint64_t v73 = &unk_180A36E2A;
                icu::UnicodeString::UnicodeString(&v80, 1LL, &v73);
                else {
                  int32_t v44 = *((unsigned __int16 *)v67 + 4) >> 5;
                }
                if ((SWORD4(v83[0]) & 0x8000u) == 0) {
                  uint64_t v45 = WORD4(v83[0]) >> 5;
                }
                else {
                  uint64_t v45 = HIDWORD(v83[0]);
                }
                int v46 = v81 >> 5;
                if ((v81 & 0x8000u) != 0) {
                  int v46 = v82;
                }
                icu::UnicodeString::findAndReplace( v67,  0,  v44,  (const icu::UnicodeString *)v83,  0,  v45,  (const icu::UnicodeString *)&v80,  0,  v46);
                icu::UnicodeString::~UnicodeString(v47, (icu::UnicodeString *)&v80);
                v69[0] = v73;
                v48 = icu::UnicodeString::~UnicodeString(v69, (icu::UnicodeString *)v83);
                v68[2] = v74;
                if (v22)
                {
                  memset(v83, 0, sizeof(v83));
                  icu::UnicodeString::UnicodeString((uint64_t)v48, v36, HIDWORD(v76));
                  v72 = "{";
                  icu::UnicodeString::UnicodeString(&v80, 1LL, &v72);
                  icu::UnicodeString::UnicodeString((uint64_t)v79, v19, v18);
                  sub_1808C1364((uint64_t)v83, (icu::UnicodeString *)&v80, (icu::UnicodeString *)v79);
                  icu::UnicodeString::~UnicodeString(v49, (icu::UnicodeString *)v79);
                  v51 = icu::UnicodeString::~UnicodeString(v50, (icu::UnicodeString *)&v80);
                  v68[1] = v72;
                  v71 = "{";
                  icu::UnicodeString::UnicodeString(v51, 1LL, &v71);
                  uint64_t v70 = &unk_180A36E2A;
                  icu::UnicodeString::UnicodeString(v79, 1LL, &v70);
                  sub_1808C1364((uint64_t)v83, (icu::UnicodeString *)&v80, (icu::UnicodeString *)v79);
                  icu::UnicodeString::~UnicodeString(v52, (icu::UnicodeString *)v79);
                  v68[0] = v70;
                  icu::UnicodeString::~UnicodeString(v68, (icu::UnicodeString *)&v80);
                  __int16 v80 = 59;
                  icu::UnicodeString::doAppend((uint64_t)v67, (uint64_t)&v80, 0, 1LL);
                  if ((SWORD4(v83[0]) & 0x8000u) == 0) {
                    uint64_t v53 = WORD4(v83[0]) >> 5;
                  }
                  else {
                    uint64_t v53 = HIDWORD(v83[0]);
                  }
                  icu::UnicodeString::doAppend((uint64_t)v67, (const icu::UnicodeString *)v83, 0, v53);
                  v48 = icu::UnicodeString::~UnicodeString(v54, (icu::UnicodeString *)v83);
                }

                v55 = (uint64_t *)*((void *)this + 1);
                icu::UnicodeString::UnicodeString(v48, v30, 0xFFFFFFFFLL, 0LL);
                uint64_t v56 = *v55;
                v59 = (icu::UnicodeString *)icu::UMemory::operator new(v58, (icu::UMemory *)0x40, v57);
                uint64_t v60 = (uint64_t)v59;
                if (v59) {
                  icu::UnicodeString::UnicodeString(v59, (UChar **)v83);
                }
                uhash_put(v56, v60, (uint64_t)v67, (int *)a3);
                icu::UnicodeString::~UnicodeString(v61, (icu::UnicodeString *)v83);
              }

              int v30 = (char *)(*(uint64_t (**)(uint64_t, void, UErrorCode *))(*(void *)v66 + 40LL))( v66,  0LL,  &v78);
              uint64_t v11 = v63;
              if (!v30) {
                goto LABEL_72;
              }
            }
          }

          else
          {
LABEL_72:
            UErrorCode v28 = v78;
          }

          uint64_t v26 = v62;
        }

        if (v28 != U_MEMORY_ALLOCATION_ERROR) {
          goto LABEL_76;
        }
      }

      else
      {
        UErrorCode v78 = U_MEMORY_ALLOCATION_ERROR;
      }

      *a3 = U_MEMORY_ALLOCATION_ERROR;
LABEL_76:
      if (v66) {
        (*(void (**)(uint64_t))(*(void *)v66 + 8LL))(v66);
      }
      if (v65) {
        ures_close(v65);
      }
      if (v26) {
        ures_close(v26);
      }
      goto LABEL_82;
    }
  }

icu::UnicodeString *sub_1808C1364(uint64_t a1, icu::UnicodeString *a2, icu::UnicodeString *a3)
{
  else {
    int32_t v4 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }
  unsigned int v5 = *((unsigned __int16 *)a2 + 4);
  int v6 = (__int16)v5;
  unsigned int v7 = v5 >> 5;
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = *((unsigned int *)a2 + 3);
  }
  unsigned int v9 = *((unsigned __int16 *)a3 + 4);
  int v10 = (__int16)v9;
  int v11 = v9 >> 5;
  if (v10 < 0) {
    int v11 = *((_DWORD *)a3 + 3);
  }
  return icu::UnicodeString::findAndReplace((icu::UnicodeString *)a1, 0, v4, a2, 0, v8, a3, 0, v11);
}

BOOL sub_1808C13E0(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if ((v2 & 1) != 0) {
    return *(_WORD *)(a2 + 8) & 1;
  }
  if ((v2 & 0x8000) != 0) {
    int v3 = *(_DWORD *)(a1 + 12);
  }
  else {
    int v3 = v2 >> 5;
  }
  uint64_t v4 = 0LL;
  unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
  if ((v5 & 0x8000u) == 0) {
    unsigned int v6 = v5 >> 5;
  }
  else {
    unsigned int v6 = *(_DWORD *)(a2 + 12);
  }
  if ((v5 & 1) == 0 && v3 == v6) {
    return icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v3);
  }
  return v4;
}

_BYTE ***sub_1808C144C(_BYTE ***a1)
{
  unsigned int v2 = *a1;
  if (*a1)
  {
    if (*v2) {
      uhash_close(*v2);
    }
    icu::UMemory::operator delete(v2);
  }

  return a1;
}

uint64_t icu::CurrencyUnit::CurrencyUnit(uint64_t a1, _WORD **a2, int *a3)
{
  *(void *)icu::MeasureUnit::MeasureUnit(a1) = off_189722118;
  if (*a3 > 0) {
    goto LABEL_2;
  }
  unsigned int v7 = *a2;
  if (!*a2 || !*v7) {
    goto LABEL_2;
  }
  if (!v7[1] || !v7[2])
  {
    int v9 = 1;
LABEL_14:
    *a3 = v9;
LABEL_2:
    *(void *)(a1 + 20) = 0x5800580058LL;
    goto LABEL_3;
  }

  if (!uprv_isInvariantUString(v7, 3))
  {
    int v9 = 26;
    goto LABEL_14;
  }

  for (uint64_t i = 0LL; i != 3; ++i)
    *(_WORD *)(a1 + 20 + i * 2) = u_asciiToUpper((unsigned __int16)(*a2)[i]);
  *(_WORD *)(a1 + 26) = 0;
LABEL_3:
  *(_DWORD *)__s = 0;
  u_UCharsToChars((const UChar *)(a1 + 20), __s, 4);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v10, __s);
  icu::MeasureUnit::initCurrency(a1, v10, v11);
  return a1;
}

uint64_t icu::CurrencyUnit::CurrencyUnit(uint64_t a1, char *a2, int a3, int *a4)
{
  *(void *)icu::MeasureUnit::MeasureUnit(a1) = off_189722118;
  int v14 = 0;
  if (a3 != 3 || memchr(a2, 0, 3uLL))
  {
    int v8 = 1;
LABEL_4:
    *a4 = v8;
    int v9 = "XXX";
    goto LABEL_5;
  }

  if (!uprv_isInvariantString((unsigned __int8 *)a2, 3))
  {
    int v8 = 26;
    goto LABEL_4;
  }

  for (uint64_t i = 0LL; i != 3; ++i)
    *((_BYTE *)&v14 + i) = uprv_toupper(a2[i]);
  HIBYTE(v14) = 0;
  int v9 = (const char *)&v14;
LABEL_5:
  u_charsToUChars(v9, (UChar *)(a1 + 20), 4);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v12, v9);
  icu::MeasureUnit::initCurrency(a1, v12, v13);
  return a1;
}

icu::CurrencyUnit *icu::CurrencyUnit::CurrencyUnit(icu::CurrencyUnit *this, const UChar *a2)
{
  uint64_t v4 = icu::MeasureUnit::MeasureUnit((uint64_t)this, (unint64_t)a2);
  *(void *)uint64_t v4 = off_189722118;
  u_strcpy((UChar *)(v4 + 20), a2 + 10);
  return this;
}

{
  uint64_t v4;
  uint64_t v4 = icu::MeasureUnit::MeasureUnit((uint64_t)this, (unint64_t)a2);
  *(void *)uint64_t v4 = off_189722118;
  u_strcpy((UChar *)(v4 + 20), a2 + 10);
  return this;
}

icu::CurrencyUnit *icu::CurrencyUnit::CurrencyUnit( icu::CurrencyUnit *this, const icu::MeasureUnit *a2, UErrorCode *a3)
{
  unsigned int v5 = (icu::MeasureUnit *)icu::MeasureUnit::MeasureUnit((uint64_t)this, (unint64_t)a2);
  *(void *)unsigned int v5 = off_189722118;
  unsigned int v6 = (UChar *)((char *)v5 + 20);
  Type = icu::MeasureUnit::getType(v5);
  if (!strcmp("currency", Type))
  {
    Subtype = icu::MeasureUnit::getSubtype(this);
    u_charsToUChars(Subtype, v6, 4);
    *((_WORD *)this + 13) = 0;
  }

  else
  {
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    *unsigned int v6 = 0;
  }

  return this;
}

icu::CurrencyUnit *icu::CurrencyUnit::CurrencyUnit(icu::CurrencyUnit *this)
{
  uint64_t v2 = icu::MeasureUnit::MeasureUnit((uint64_t)this);
  *(void *)uint64_t v2 = off_189722118;
  int v3 = (const UChar *)(v2 + 20);
  u_strcpy((UChar *)(v2 + 20), (const UChar *)"X");
  *(_DWORD *)__s = 0;
  u_UCharsToChars(v3, __s, 4);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v5, __s);
  icu::MeasureUnit::initCurrency((uint64_t)this, v5, v6);
  return this;
}

uint64_t icu::CurrencyUnit::operator=(uint64_t a1, unint64_t a2)
{
  if (a1 != a2)
  {
    icu::MeasureUnit::operator=(a1, a2);
    u_strcpy((UChar *)(a1 + 20), (const UChar *)(a2 + 20));
  }

  return a1;
}

uint64_t *icu::CurrencyUnit::clone@<X0>(const UChar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x20, a2);
  unsigned int v5 = v4;
  if (v4)
  {
    uint64_t v6 = icu::MeasureUnit::MeasureUnit((uint64_t)v4, (unint64_t)this);
    *(void *)uint64_t v6 = off_189722118;
    u_strcpy((UChar *)(v6 + 20), this + 10);
  }

  return v5;
}

void icu::CurrencyUnit::~CurrencyUnit(icu::CurrencyUnit *this)
{
}

void *icu::CurrencyUnit::getStaticClassID(icu::CurrencyUnit *this)
{
  return &unk_18C5352DB;
}

void *icu::CurrencyUnit::getDynamicClassID(icu::CurrencyUnit *this)
{
  return &unk_18C5352DB;
}

uint64_t sub_1808C18B0(uint64_t a1, UErrorCode *a2)
{
  v28[1] = *(double *)MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    unsigned int v3 = atomic_load(&dword_18C5352EC);
    if (v3 != 2 && icu::umtx_initImplPreInit(&dword_18C5352EC))
    {
      v28[0] = -2.302128e12;
      unint64_t v27 = 0xC280854EA3000000LL;
      unint64_t v26 = 0xC27A9DE23F800000LL;
      uint64_t v6 = (icu::InitialTimeZoneRule *)icu::UMemory::operator new( (uint64_t *)0xC27A9DE23F800000LL,  (icu::UMemory *)0x50,  v4);
      if (v6)
      {
        icu::UnicodeString::UnicodeString((uint64_t)v25, (uint64_t)"G");
        icu::InitialTimeZoneRule::InitialTimeZoneRule(v6, v25, 28800000, 0);
        icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v25);
      }

      else
      {
        uint64_t v8 = *(unsigned int *)a2;
        if ((int)v8 <= 0)
        {
          uint64_t v8 = 7LL;
          *a2 = U_MEMORY_ALLOCATION_ERROR;
        }
      }

      int v10 = (icu::TimeZoneRule *)icu::UMemory::operator new((uint64_t *)v8, (icu::UMemory *)0x160, v5);
      if (v10)
      {
        icu::UnicodeString::UnicodeString((uint64_t)v25, (uint64_t)"K");
        icu::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule((uint64_t)v10, v25, 25200000, 0, v28, 1LL, 1);
        icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v25);
      }

      else
      {
        uint64_t v12 = *(unsigned int *)a2;
        if ((int)v12 <= 0)
        {
          uint64_t v12 = 7LL;
          *a2 = U_MEMORY_ALLOCATION_ERROR;
        }
      }

      int v14 = (icu::TimeZoneRule *)icu::UMemory::operator new((uint64_t *)v12, (icu::UMemory *)0x160, v9);
      if (v14)
      {
        icu::UnicodeString::UnicodeString((uint64_t)v25, (uint64_t)"K");
        icu::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule((uint64_t)v14, v25, 28800000, 0, (const double *)&v27, 1LL, 1);
        icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v25);
      }

      else
      {
        uint64_t v16 = *(unsigned int *)a2;
        if ((int)v16 <= 0)
        {
          uint64_t v16 = 7LL;
          *a2 = U_MEMORY_ALLOCATION_ERROR;
        }
      }

      uint64_t v18 = (icu::TimeZoneRule *)icu::UMemory::operator new((uint64_t *)v16, (icu::UMemory *)0x160, v13);
      if (v18)
      {
        icu::UnicodeString::UnicodeString((uint64_t)v25, (uint64_t)L"Korean 1912-");
        icu::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule((uint64_t)v18, v25, 32400000, 0, (const double *)&v26, 1LL, 1);
        icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v25);
      }

      else
      {
        uint64_t v20 = *(unsigned int *)a2;
        if ((int)v20 <= 0)
        {
          uint64_t v20 = 7LL;
          *a2 = U_MEMORY_ALLOCATION_ERROR;
        }
      }

      unsigned int v21 = icu::UMemory::operator new((uint64_t *)v20, (icu::UMemory *)0x70, v17);
      if (v21)
      {
        int v22 = (icu::RuleBasedTimeZone *)v21;
        icu::UnicodeString::UnicodeString((uint64_t)v25, (uint64_t)"K");
        icu::RuleBasedTimeZone::RuleBasedTimeZone(v22, v25, v6);
        icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)v25);
        if (*(int *)a2 <= 0)
        {
          icu::RuleBasedTimeZone::addTransitionRule((uint64_t *)v22, v10, a2);
          icu::RuleBasedTimeZone::addTransitionRule((uint64_t *)v22, v14, a2);
          icu::RuleBasedTimeZone::addTransitionRule((uint64_t *)v22, v18, a2);
          icu::RuleBasedTimeZone::complete((uint64_t)v22, a2);
          if (*(int *)a2 <= 0)
          {
            qword_18C5352E0 = (uint64_t)v22;
            sub_1809B36C0(0xCu, (uint64_t)sub_1808C1D84);
LABEL_37:
            dword_18C5352F0 = *a2;
            icu::umtx_initImplPostInit(&dword_18C5352EC);
            return qword_18C5352E0;
          }

          sub_1809B36C0(0xCu, (uint64_t)sub_1808C1D84);
          uint64_t v18 = 0LL;
          int v14 = 0LL;
          int v10 = 0LL;
        }

        (*(void (**)(icu::RuleBasedTimeZone *))(*(void *)v22 + 8LL))(v22);
        uint64_t v6 = 0LL;
      }

      else if (*(int *)a2 <= 0)
      {
        *a2 = U_MEMORY_ALLOCATION_ERROR;
      }

      if (v18) {
        (*(void (**)(icu::TimeZoneRule *))(*(void *)v18 + 8LL))(v18);
      }
      if (v14) {
        (*(void (**)(icu::TimeZoneRule *))(*(void *)v14 + 8LL))(v14);
      }
      if (v10) {
        (*(void (**)(icu::TimeZoneRule *))(*(void *)v10 + 8LL))(v10);
      }
      if (v6) {
        (*(void (**)(icu::InitialTimeZoneRule *))(*(void *)v6 + 8LL))(v6);
      }
      goto LABEL_37;
    }

    if (dword_18C5352F0 >= 1) {
      *a2 = dword_18C5352F0;
    }
  }

  return qword_18C5352E0;
}

icu::ChineseCalendar *sub_1808C1C6C(icu::ChineseCalendar *a1, char **a2, UErrorCode *a3)
{
  *(void *)a1 = &off_189722168;
  uint64_t v6 = (const icu::TimeZone *)sub_1808C18B0((uint64_t)a1, a3);
  uint64_t result = icu::ChineseCalendar::ChineseCalendar(a1, a2, -2332, v6, a3);
  *(void *)a1 = &off_189722168;
  return result;
}

void sub_1808C1CCC(icu::ChineseCalendar *a1)
{
}

icu::ChineseCalendar *sub_1808C1CE0@<X0>( const icu::ChineseCalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::ChineseCalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x278, a2);
  if (result)
  {
    uint64_t result = (icu::ChineseCalendar *)icu::ChineseCalendar::ChineseCalendar(result, a1);
    *(void *)uint64_t result = &off_189722168;
  }

  return result;
}

const char *sub_1808C1D1C()
{
  return "dangi";
}

uint64_t sub_1808C1D28(_BYTE *a1, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(a1, 0x13u, a2) - 2333;
  else {
    return 0LL;
  }
}

_BYTE *sub_1808C1D60(_BYTE *a1, int a2)
{
  return icu::Calendar::set(a1, 0x13u, a2 + 2333);
}

void *icu::DangiCalendar::getStaticClassID(icu::DangiCalendar *this)
{
  return &unk_18C5352E8;
}

void *sub_1808C1D78()
{
  return &unk_18C5352E8;
}

uint64_t sub_1808C1D84()
{
  if (qword_18C5352E0)
  {
    (*(void (**)(uint64_t))(*(void *)qword_18C5352E0 + 8LL))(qword_18C5352E0);
    qword_18C5352E0 = 0LL;
  }

  atomic_store(0, &dword_18C5352EC);
  return 1LL;
}

void sub_1808C1DC8(uint64_t a1)
{
  *(void *)a1 = off_189722390;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 24));
  icu::SharedObject::~SharedObject((icu::SharedObject *)a1);
}

void sub_1808C1DF8(uint64_t a1)
{
  *(void *)a1 = off_189722390;
  icu::UnicodeString::~UnicodeString(off_189722390, (icu::UnicodeString *)(a1 + 24));
  icu::SharedObject::~SharedObject((icu::SharedObject *)a1);
  icu::UMemory::operator delete(v2);
}

uint64_t sub_1808C1E2C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 16;
  return 0LL;
}

void sub_1808C1E3C(uint64_t a1)
{
  *(void *)a1 = off_1897223B8;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 240));
  *(void *)a1 = off_189722578;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
}

void sub_1808C1E84(uint64_t a1)
{
}

void *icu::DateFormat::DateFormat(icu::DateFormat *this)
{
  uint64_t result = (void *)icu::Format::Format((uint64_t)this);
  *uint64_t result = off_189722408;
  result[41] = 0LL;
  result[42] = 0LL;
  result[43] = 0x10000000000LL;
  return result;
}

void *icu::DateFormat::DateFormat(icu::DateFormat *this, const icu::DateFormat *a2)
{
  unsigned int v3 = (void *)icu::Format::Format((uint64_t)this, (uint64_t)a2);
  *unsigned int v3 = off_189722408;
  v3[41] = 0LL;
  v3[42] = 0LL;
  v3[43] = 0x10000000000LL;
  return icu::DateFormat::operator=(v3, a2);
}

void *icu::DateFormat::operator=(void *a1, void *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = a1[41];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t v5 = a1[42];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    uint64_t v6 = a2[41];
    if (v6) {
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
    }
    a1[41] = v6;
    uint64_t v7 = a2[42];
    if (v7) {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32LL))(v7);
    }
    a1[42] = v7;
    a1[43] = a2[43];
  }

  return a1;
}

void icu::DateFormat::~DateFormat(icu::DateFormat *this)
{
  *(void *)this = off_189722408;
  uint64_t v2 = *((void *)this + 41);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *((void *)this + 42);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  icu::Format::~Format(this);
}

uint64_t icu::DateFormat::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t result = icu::Format::operator==((void *)a1, (void *)a2);
  if ((_DWORD)result)
  {
    uint64_t result = *(void *)(a1 + 328);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 40LL))(result, *(void *)(a2 + 328));
      if ((_DWORD)result)
      {
        uint64_t result = *(void *)(a1 + 336);
        if (result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 24LL))( result,  *(void *)(a2 + 336));
          if ((_DWORD)result) {
            return *(_DWORD *)(a1 + 348) == *(_DWORD *)(a2 + 348);
          }
        }
      }
    }
  }

  return result;
}

icu::UnicodeString *icu::DateFormat::format( icu::DateFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    unsigned int Type = icu::Formattable::getType(a2);
    if (Type == 2)
    {
      double v11 = (double)*((int *)a2 + 2);
    }

    else
    {
      if (Type > 1)
      {
        *a5 = U_ILLEGAL_ARGUMENT_ERROR;
        return a3;
      }

      double v11 = *((double *)a2 + 1);
    }

    icu::DateFormat::format(this, (uint64_t)a3, (uint64_t)a4, v11);
  }

  return a3;
}

uint64_t icu::DateFormat::format(void *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v6 = a1[41];
  if (v6)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
    if (v9)
    {
      uint64_t v10 = v9;
      UErrorCode v12 = U_ZERO_ERROR;
      icu::Calendar::setTimeInMillis(v9, a4, &v12);
      if (v12 <= U_ZERO_ERROR) {
        (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a1 + 64LL))(a1, v10, a2, a3);
      }
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  return a2;
}

icu::UnicodeString *icu::DateFormat::format( icu::DateFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPositionIterator *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    unsigned int Type = icu::Formattable::getType(a2);
    if (Type == 2)
    {
      double v11 = (double)*((int *)a2 + 2);
    }

    else
    {
      if (Type > 1)
      {
        *a5 = U_ILLEGAL_ARGUMENT_ERROR;
        return a3;
      }

      double v11 = *((double *)a2 + 1);
    }

    icu::DateFormat::format(this, (uint64_t)a3, (uint64_t)a4, a5, v11);
  }

  return a3;
}

uint64_t icu::DateFormat::format(void *a1, uint64_t a2, uint64_t a3, UErrorCode *a4, double a5)
{
  uint64_t v7 = a1[41];
  if (v7)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24LL))(v7);
    if (v11)
    {
      uint64_t v12 = v11;
      icu::Calendar::setTimeInMillis(v11, a5, a4);
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
  }

  return a2;
}

uint64_t icu::DateFormat::format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t result = a3;
  if (*a5 <= 0) {
    *a5 = 16;
  }
  return result;
}

icu::UnicodeString *icu::DateFormat::format(icu::DateFormat *this, double a2, icu::UnicodeString *a3)
{
  v5[2] = 0LL;
  v5[0] = off_189723AC8;
  v5[1] = 0xFFFFFFFFLL;
  icu::DateFormat::format(this, (uint64_t)a3, (uint64_t)v5, a2);
  icu::FieldPosition::~FieldPosition((icu::FieldPosition *)v5);
  return a3;
}

double icu::DateFormat::parse(icu::DateFormat *this, const icu::UnicodeString *a2, icu::ParsePosition *a3)
{
  uint64_t v4 = *((void *)this + 41);
  double v5 = 0.0;
  if (v4)
  {
    uint64_t v8 = (icu::Calendar *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      int v10 = *((_DWORD *)a3 + 2);
      icu::Calendar::clear(v8);
      (*(void (**)(icu::DateFormat *, const icu::UnicodeString *, icu::Calendar *, icu::ParsePosition *))(*(void *)this + 88LL))( this,  a2,  v9,  a3);
      if (*((_DWORD *)a3 + 2) != v10)
      {
        UErrorCode v13 = U_ZERO_ERROR;
        v11.n128_f64[0] = icu::Calendar::getTimeInMillis(v9, &v13);
        if (v13 < U_ILLEGAL_ARGUMENT_ERROR)
        {
          double v5 = v11.n128_f64[0];
        }

        else
        {
          *((_DWORD *)a3 + 2) = v10;
          *((_DWORD *)a3 + 3) = v10;
        }
      }

      (*(void (**)(icu::Calendar *, __n128))(*(void *)v9 + 8LL))(v9, v11);
    }
  }

  return v5;
}

double icu::DateFormat::parse(icu::DateFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  double v3 = 0.0;
  if (*(int *)a3 <= 0)
  {
    uint64_t v6 = off_18970F400;
    unint64_t v7 = 0xFFFFFFFF00000000LL;
    double v3 = icu::DateFormat::parse(this, a2, (icu::ParsePosition *)&v6);
    if (!(_DWORD)v7) {
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v6);
  }

  return v3;
}

uint64_t icu::DateFormat::parseObject( icu::DateFormat *this, const icu::UnicodeString *a2, icu::Formattable *a3, icu::ParsePosition *a4)
{
  double v5 = icu::DateFormat::parse(this, a2, a4);
  return icu::Formattable::setDate(a3, v5);
}

icu::SimpleDateFormat *icu::DateFormat::createTimeInstance(uint64_t a1, const icu::Locale *a2)
{
  return icu::DateFormat::create(a1, 0xFFFFFFFFuLL, a2);
}

icu::SimpleDateFormat *icu::DateFormat::createDateTimeInstance(int a1, uint64_t a2, const icu::Locale *a3)
{
  if (a1 == -1) {
    unint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    unint64_t v4 = (a1 + 4);
  }
  return icu::DateFormat::create(a2, v4, a3);
}

icu::SimpleDateFormat *icu::DateFormat::createDateInstance(int a1, const icu::Locale *a2)
{
  if (a1 == -1) {
    unint64_t v3 = 0xFFFFFFFFLL;
  }
  else {
    unint64_t v3 = (a1 + 4);
  }
  return icu::DateFormat::create(0xFFFFFFFFLL, v3, a2);
}

icu::SimpleDateFormat *icu::DateFormat::create(uint64_t a1, unint64_t a2, const icu::Locale *a3)
{
  UErrorCode v9 = U_ZERO_ERROR;
  if ((_DWORD)a2 != -1 && (((_DWORD)a2 - 4) & 0x80) != 0)
  {
    uint64_t result = (icu::SimpleDateFormat *)icu::UMemory::operator new((icu::UMemory *)0x2F8, a2);
    if (!result) {
      return result;
    }
    uint64_t result = (icu::SimpleDateFormat *)sub_180970BF4(result, a1, (a2 - 4), a3, &v9);
    if (v9 < U_ILLEGAL_ARGUMENT_ERROR) {
      return result;
    }
    (*(void (**)(icu::SimpleDateFormat *))(*(void *)result + 8LL))(result);
    UErrorCode v9 = U_ZERO_ERROR;
  }

  uint64_t v7 = icu::UMemory::operator new((icu::UMemory *)0x340, a2);
  if (v7)
  {
    uint64_t result = (icu::SimpleDateFormat *)icu::SimpleDateFormat::SimpleDateFormat(v7, a1, a2, a3, &v9);
    if (v9 <= U_ZERO_ERROR) {
      return result;
    }
    (*(void (**)(icu::SimpleDateFormat *))(*(void *)result + 8LL))(result);
  }

  else if (v9 <= U_ZERO_ERROR)
  {
    return 0LL;
  }

  UErrorCode v9 = U_ZERO_ERROR;
  uint64_t result = (icu::SimpleDateFormat *)icu::UMemory::operator new((icu::UMemory *)0x340, v8);
  if (result)
  {
    uint64_t result = (icu::SimpleDateFormat *)icu::SimpleDateFormat::SimpleDateFormat(result, a3, &v9);
    if (v9 >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      (*(void (**)(icu::SimpleDateFormat *))(*(void *)result + 8LL))(result);
      return 0LL;
    }
  }

  return result;
}

icu::SimpleDateFormat *icu::DateFormat::createInstance(icu::DateFormat *this)
{
  Default = icu::Locale::getDefault(this);
  return icu::DateFormat::create(3LL, 7uLL, (const icu::Locale *)Default);
}

void icu::DateFormat::getBestPattern( icu::DateFormat *this@<X0>, UErrorCode *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  v12[38] = *MEMORY[0x1895F89C0];
  uint64_t Instance = icu::UnifiedCache::getInstance(a3, a2);
  if (*(int *)a3 < 1)
  {
    int v10 = (icu::SharedObject **)Instance;
    memset(&v12[1], 0, 296);
    icu::Locale::Locale((icu::Locale *)&v12[2], (uint64_t)this);
    v12[0] = off_1897223B8;
    icu::DateTimePatternGenerator::staticGetSkeleton((icu::DateTimePatternGenerator *)a2, (uint64_t)&v12[30]);
    __n128 v11 = 0LL;
    sub_18089E200(v10, (const icu::CacheKeyBase *)v12, 0LL, &v11, a3);
    if (*(int *)a3 < 1)
    {
      *(_OWORD *)(a4 + 32) = 0u;
      *(_OWORD *)(a4 + 48) = 0u;
      *(_OWORD *)a4 = 0u;
      *(_OWORD *)(a4 + 16) = 0u;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)a4, (UChar **)v11 + 3);
      icu::SharedObject::removeRef(v11);
    }

    else
    {
      *(void *)a4 = off_18971B688;
      *(_WORD *)(a4 + 8) = 2;
    }

    sub_1808C1E3C((uint64_t)v12);
  }

  else
  {
    *(void *)a4 = off_18971B688;
    *(_WORD *)(a4 + 8) = 2;
  }

icu::SimpleDateFormat *icu::DateFormat::createInstanceForSkeleton( icu::DateFormat *this, UErrorCode *a2, const icu::UnicodeString *a3, UErrorCode *a4, UErrorCode *a5)
{
  double v5 = this;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 > 0)
  {
    uint64_t v6 = 0LL;
    if (!this) {
      return v6;
    }
LABEL_9:
    (*(void (**)(icu::DateFormat *, UErrorCode *, const icu::UnicodeString *))(*(void *)v5 + 8LL))( v5,  a2,  a3);
    return v6;
  }

  if (!this)
  {
    uint64_t v6 = 0LL;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return v6;
  }

  memset(v13, 0, sizeof(v13));
  icu::Locale::Locale((icu::Locale *)v13, (uint64_t)a3);
  UErrorCode v9 = (char *)(*(uint64_t (**)(icu::DateFormat *))(*(void *)v5 + 184LL))(v5);
  icu::Locale::setKeywordValue((const char **)v13, "calendar", v9, a4);
  if (*(int *)a4 <= 0
    && (InstanceForSkeleton = icu::DateFormat::createInstanceForSkeleton(a2, (const icu::UnicodeString *)v13, a4, v10),
        *(int *)a4 <= 0))
  {
    uint64_t v6 = InstanceForSkeleton;
    (*(void (**)(icu::SimpleDateFormat *, icu::DateFormat *))(*(void *)InstanceForSkeleton + 136LL))( InstanceForSkeleton,  v5);
    double v5 = 0LL;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  icu::Locale::~Locale((icu::Locale *)v13);
  if (v5) {
    goto LABEL_9;
  }
  return v6;
}

icu::SimpleDateFormat *icu::DateFormat::createInstanceForSkeleton( UErrorCode *this, const icu::UnicodeString *a2, UErrorCode *a3, UErrorCode *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  unint64_t v4 = (uint64_t *)*(unsigned int *)a3;
  if ((int)v4 <= 0)
  {
    int v10 = icu::UMemory::operator new(v4, (icu::UMemory *)0x340, (unint64_t)a2);
    if (v10)
    {
      double v5 = (icu::SimpleDateFormat *)v10;
      icu::DateFormat::getBestPattern(a2, this, a3, (uint64_t)v12);
      icu::SimpleDateFormat::SimpleDateFormat(v5, (const icu::UnicodeString *)v12, a2, a3);
      icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v12);
      (*(void (**)(icu::SimpleDateFormat *))(*(void *)v5 + 8LL))(v5);
    }

    else if (*(int *)a3 <= 0)
    {
      double v5 = 0LL;
      *a3 = U_MEMORY_ALLOCATION_ERROR;
      return v5;
    }
  }

  return 0LL;
}

icu::SimpleDateFormat *icu::DateFormat::createInstanceForSkeleton( icu::DateFormat *this, UErrorCode *a2, UErrorCode *a3)
{
  Default = icu::Locale::getDefault(this);
  return icu::DateFormat::createInstanceForSkeleton((UErrorCode *)this, (const icu::UnicodeString *)Default, a2, v6);
}

uint64_t icu::DateFormat::adoptCalendar(icu::DateFormat *this, icu::Calendar *a2)
{
  uint64_t result = *((void *)this + 41);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  *((void *)this + 41) = a2;
  return result;
}

uint64_t icu::DateFormat::setCalendar(icu::DateFormat *this, const icu::Calendar *a2)
{
  uint64_t v4 = *((void *)this + 41);
  if (!v4
    || (uint64_t result = (*(uint64_t (**)(uint64_t, const icu::Calendar *))(*(void *)v4 + 40LL))(v4, a2),
        !(_DWORD)result))
  {
    uint64_t result = (*(uint64_t (**)(const icu::Calendar *))(*(void *)a2 + 24LL))(a2);
    if (result) {
      return (*(uint64_t (**)(icu::DateFormat *, uint64_t))(*(void *)this + 136LL))(this, result);
    }
  }

  return result;
}

uint64_t icu::DateFormat::getCalendar(icu::DateFormat *this)
{
  return *((void *)this + 41);
}

uint64_t icu::DateFormat::adoptNumberFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 336);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  *(void *)(a1 + 336) = a2;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 184LL))(a2, 1LL);
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 208LL))(a2, 0LL);
}

uint64_t icu::DateFormat::setNumberFormat(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 160LL))(a1, result);
  }
  return result;
}

uint64_t icu::DateFormat::getNumberFormat(icu::DateFormat *this)
{
  return *((void *)this + 42);
}

void *icu::DateFormat::adoptTimeZone(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 328);
  if (result) {
    return icu::Calendar::adoptTimeZone(result, a2);
  }
  return result;
}

uint64_t icu::DateFormat::setTimeZone(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 328);
  if (result) {
    return icu::Calendar::setTimeZone(result, a2);
  }
  return result;
}

uint64_t icu::DateFormat::getTimeZone(icu::DateFormat *this)
{
  uint64_t v1 = (icu::Calendar *)*((void *)this + 41);
  if (v1) {
    return icu::Calendar::getTimeZone(v1);
  }
  else {
    return icu::TimeZone::createDefault(0LL);
  }
}

uint64_t icu::DateFormat::setLenient(icu::DateFormat *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 41);
  if (v4) {
    icu::Calendar::setLenient(v4, a2);
  }
  int v6 = 0;
  (*(void (**)(icu::DateFormat *, void, uint64_t, int *))(*(void *)this + 216LL))(this, 0LL, a2, &v6);
  return (*(uint64_t (**)(icu::DateFormat *, uint64_t, uint64_t, int *))(*(void *)this + 216LL))( this,  1LL,  a2,  &v6);
}

uint64_t icu::DateFormat::isLenient(icu::DateFormat *this)
{
  uint64_t v2 = (icu::Calendar *)*((void *)this + 41);
  if (v2)
  {
    uint64_t result = icu::Calendar::isLenient(v2);
    int v4 = 0;
    if (!(_DWORD)result) {
      return result;
    }
  }

  else
  {
    int v4 = 0;
  }

  uint64_t result = (*(uint64_t (**)(icu::DateFormat *, void, int *))(*(void *)this + 224LL))(this, 0LL, &v4);
  if ((_DWORD)result) {
    return (*(unsigned int (**)(icu::DateFormat *, uint64_t, int *))(*(void *)this + 224LL))(this, 1LL, &v4) != 0;
  }
  return result;
}

uint64_t icu::DateFormat::setCalendarLenient(icu::DateFormat *this, char a2)
{
  uint64_t result = *((void *)this + 41);
  if (result) {
    return icu::Calendar::setLenient(result, a2);
  }
  return result;
}

icu::Calendar *icu::DateFormat::isCalendarLenient(icu::DateFormat *this)
{
  uint64_t result = (icu::Calendar *)*((void *)this + 41);
  if (result) {
    return (icu::Calendar *)icu::Calendar::isLenient(result);
  }
  return result;
}

uint64_t icu::DateFormat::setContext(uint64_t result, int a2, int *a3)
{
  if (*a3 <= 0)
  {
    if ((a2 & 0xFFFFFF00) == 0x100) {
      *(_DWORD *)(result + 348) = a2;
    }
    else {
      *a3 = 1;
    }
  }

  return result;
}

uint64_t icu::DateFormat::getContext(uint64_t a1, int a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if (a2 == 1) {
    return *(unsigned int *)(a1 + 348);
  }
  uint64_t result = 0LL;
  *a3 = 1;
  return result;
}

uint64_t icu::DateFormat::setBooleanAttribute(uint64_t result, char a2, unsigned int a3, _DWORD *a4)
{
  if (a3 < 2)
  {
    if (a3) {
      int v4 = 1 << a2;
    }
    else {
      int v4 = 0;
    }
    *(_DWORD *)(result + 344) = *(_DWORD *)(result + 344) & ~(1 << a2) | v4;
  }

  else
  {
    *a4 = 1;
  }

  return result;
}

uint64_t icu::DateFormat::getBooleanAttribute(uint64_t a1, char a2)
{
  return (*(_DWORD *)(a1 + 344) >> a2) & 1;
}

uint64_t sub_1808C2D78(uint64_t a1)
{
  int v2 = sub_1808C307C(a1);
  return icu::UnicodeString::doHashCode((icu::UnicodeString *)(a1 + 240)) + 37 * v2;
}

uint64_t *sub_1808C2DB4@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x130, a2);
  double v5 = v4;
  if (v4)
  {
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a1 + 8);
    *((_BYTE *)v4 + 12) = 0;
    *int v4 = (uint64_t)off_189722578;
    icu::Locale::Locale((icu::Locale *)(v4 + 2), a1 + 16);
    *double v5 = (uint64_t)off_1897223B8;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v5 + 30), (UChar **)(a1 + 240));
  }

  return v5;
}

uint64_t *sub_1808C2E20(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  v12[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t Instance = icu::DateTimePatternGenerator::createInstance((const char **)(a1 + 16), a3, 0LL);
  uint64_t v7 = (uint64_t *)*(unsigned int *)a3;
  int v10 = icu::UMemory::operator new(v7, (icu::UMemory *)0x58, v5);
  if (v10)
  {
    unint64_t v8 = v10;
    icu::DateTimePatternGenerator::getBestPattern( Instance,  (const icu::UnicodeString *)(a1 + 240),  a3,  (icu::UnicodeString *)v12);
    v8[1] = 0LL;
    v8[2] = 0LL;
    *unint64_t v8 = (uint64_t)off_189722390;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v8 + 3), v12);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v12);
    if (*(int *)a3 > 0)
    {
      (*(void (**)(uint64_t *))(*v8 + 8))(v8);
LABEL_2:
      unint64_t v8 = 0LL;
      goto LABEL_3;
    }

    icu::SharedObject::addRef((uint64_t)v8);
  }

  else
  {
    unint64_t v8 = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

char *sub_1808C2F48(uint64_t a1, char *__dst, int a3)
{
  uint64_t result = strncpy(__dst, *(const char **)(a1 + 56), a3);
  __dst[a3 - 1] = 0;
  return result;
}

BOOL sub_1808C2F80(uint64_t a1, uint64_t a2)
{
  BOOL result = sub_18089E3E8((void *)a1, (void *)a2);
  if (result)
  {
    BOOL result = icu::Locale::operator==(a1 + 16, a2 + 16);
    if (result)
    {
      unsigned int v5 = *(unsigned __int16 *)(a1 + 248);
      if ((v5 & 1) != 0)
      {
        return *(_WORD *)(a2 + 248) & 1;
      }

      else
      {
        if ((v5 & 0x8000) != 0) {
          int v6 = *(_DWORD *)(a1 + 252);
        }
        else {
          int v6 = v5 >> 5;
        }
        BOOL result = 0LL;
        unsigned int v7 = *(unsigned __int16 *)(a2 + 248);
        if ((v7 & 0x8000u) == 0) {
          unsigned int v8 = v7 >> 5;
        }
        else {
          unsigned int v8 = *(_DWORD *)(a2 + 252);
        }
        if ((v7 & 1) == 0 && v6 == v8) {
          return icu::UnicodeString::doEquals( (icu::UnicodeString *)(a1 + 240),  (const icu::UnicodeString *)(a2 + 240),  v6);
        }
      }
    }
  }

  return result;
}

void sub_1808C3018(uint64_t a1)
{
  *(void *)a1 = off_189722578;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
}

void sub_1808C3048(uint64_t a1)
{
  *(void *)a1 = off_189722578;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
  icu::UMemory::operator delete(v2);
}

uint64_t sub_1808C307C(uint64_t a1)
{
  int v2 = strlen((const char *)((unint64_t)"N3icu18DateFmtBestPatternE" & 0x7FFFFFFFFFFFFFFFLL));
  unsigned int v3 = ustr_hashCharsN( (unsigned __int8 *)((unint64_t)"N3icu18DateFmtBestPatternE" & 0x7FFFFFFFFFFFFFFFLL),  v2);
  return icu::Locale::hashCode((icu::Locale *)(a1 + 16)) + 37 * v3;
}

uint64_t *sub_1808C30D4@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0xF0, a2);
  unsigned int v5 = v4;
  if (v4)
  {
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a1 + 8);
    *((_BYTE *)v4 + 12) = 0;
    *int v4 = (uint64_t)off_189722578;
    icu::Locale::Locale((icu::Locale *)(v4 + 2), a1 + 16);
  }

  return v5;
}

BOOL sub_1808C3128(void *a1, void *a2)
{
  BOOL result = sub_18089E3E8(a1, a2);
  if (result) {
    return icu::Locale::operator==((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  }
  return result;
}

void sub_1808C3168(icu::ResourceSink *a1)
{
}

void sub_1808C3180(icu::ResourceSink *a1)
{
}

uint64_t sub_1808C3194()
{
  unsigned int v0 = (_BYTE **)qword_18C5352F8;
  uint64_t v1 = *(void **)(qword_18C5352F8 + 8);
  if (v1)
  {
    icu::UMemory::operator delete[](v1);
    unsigned int v0 = (_BYTE **)qword_18C5352F8;
  }

  uhash_close(*v0);
  if (qword_18C5352F8) {
    icu::UMemory::operator delete((void *)qword_18C5352F8);
  }
  qword_18C5352F8 = 0LL;
  return 1LL;
}

void sub_1808C31E0(int *a1, unint64_t a2)
{
  int v2 = (uint64_t *)*a1;
  if ((int)v2 <= 0)
  {
    int v4 = icu::UMemory::operator new(v2, (icu::UMemory *)0x18, a2);
    if (v4)
    {
      *int v4 = 0LL;
      v4[1] = 0LL;
      *((_DWORD *)v4 + 4) = 0;
    }

    qword_18C5352F8 = (uint64_t)v4;
    *int v4 = (uint64_t)uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0LL, a1);
    uint64_t v5 = ures_openDirect(0LL, (uint64_t)"dayPeriods", (uint64_t)a1);
    unint64_t v15 = &off_189722610;
    ures_getAllItemsWithFallback(v5, "rules", (uint64_t)&v15, a1);
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    int v6 = &off_1897225C8;
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    ures_getAllItemsWithFallback(v5, "", (uint64_t)&v6, a1);
    sub_1809B36C0(0x18u, (uint64_t)sub_1808C3194);
    icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v6);
    icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v15);
    if (v5) {
      ures_close(v5);
    }
  }

uint64_t sub_1808C32FC(icu::Locale *a1, int *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (*a2 > 0) {
    return 0LL;
  }
  unsigned int v5 = atomic_load(&dword_18C4493D8);
  if (v5 == 2 || !icu::umtx_initImplPreInit(&dword_18C4493D8))
  {
    int v7 = dword_18C4493DC;
    if (dword_18C4493DC >= 1)
    {
      uint64_t result = 0LL;
LABEL_8:
      *a2 = v7;
      return result;
    }
  }

  else
  {
    sub_1808C31E0(a2, v6);
    dword_18C4493DC = *a2;
    icu::umtx_initImplPostInit(&dword_18C4493D8);
  }

  if (*a2 > 0) {
    return 0LL;
  }
  BaseName = (const char *)icu::Locale::getBaseName(a1);
  __int128 v22 = 0u;
  memset(v23, 0, sizeof(v23));
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  *(_OWORD *)__dst = 0u;
  if (strlen(BaseName) > 0x9C)
  {
    uint64_t result = 0LL;
    int v7 = 15;
    goto LABEL_8;
  }

  strcpy(__dst, BaseName);
  if (!__dst[0]) {
    strcpy(__dst, "root");
  }
  while (1)
  {
    int v9 = uhash_geti(*(void *)qword_18C5352F8, (uint64_t)__dst);
    if (v9) {
      break;
    }
    int v14 = 0;
    memset(&v12[1], 0, 48);
    v11[1] = 0LL;
    v12[0] = (char *)&v12[1] + 5;
    LODWORD(v12[1]) = 40;
    int v13 = 0;
    v11[0] = 0LL;
    icu::CharStringByteSink::CharStringByteSink(v11, (uint64_t)v12);
    ulocimp_getParent(__dst, (uint64_t)v11, a2);
    int v10 = v13;
    if (v13) {
      icu::CharString::extract(v12, __dst, 157, (UErrorCode *)a2);
    }
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v11);
    if (BYTE4(v12[1])) {
      uprv_free(v12[0]);
    }
    uint64_t result = 0LL;
    if (!v10 || !__dst[0]) {
      return result;
    }
  }

  if (v9 < 1) {
    return 0LL;
  }
  else {
    return *(void *)(qword_18C5352F8 + 8) + 100LL * v9;
  }
}

double sub_1808C351C(uint64_t a1, uint64_t a2, int *a3)
{
  double v3 = -1.0;
  if (*a3 <= 0)
  {
    int v7 = sub_1808C35BC(a1, a2, a3);
    int v8 = sub_1808C365C(a1, a2, a3);
    if (*a3 <= 0)
    {
      double v3 = (double)(v8 + v7) * 0.5;
      if (v7 > v8)
      {
        double v3 = v3 + 12.0;
        if (v3 >= 24.0) {
          return v3 + -24.0;
        }
      }
    }
  }

  return v3;
}

uint64_t sub_1808C35BC(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return 0xFFFFFFFFLL;
  }
  if (!(_DWORD)a2) {
    return a2;
  }
  if ((_DWORD)a2 == 1) {
    return 12LL;
  }
  if (*(_DWORD *)(a1 + 4) == (_DWORD)a2 && *(_DWORD *)(a1 + 96) == (_DWORD)a2)
  {
    uint64_t result = 23LL;
    while (1)
    {
      unsigned int v5 = result - 1;
      uint64_t result = (result - 1);
      if (v5 <= 1) {
        goto LABEL_17;
      }
    }
  }

  else
  {
    uint64_t result = 0LL;
    uint64_t v6 = a1 + 4;
    while (*(_DWORD *)(v6 + 4 * result) != (_DWORD)a2)
    {
      if (++result == 24)
      {
LABEL_17:
        *a3 = 1;
        return 0xFFFFFFFFLL;
      }
    }
  }

  return result;
}

uint64_t sub_1808C365C(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)a2)
  {
    if ((_DWORD)a2 == 1)
    {
      return 12LL;
    }

    else if (*(_DWORD *)(a1 + 4) == (_DWORD)a2 && *(_DWORD *)(a1 + 96) == (_DWORD)a2)
    {
      uint64_t v4 = 2LL;
      while (*(_DWORD *)(a1 + 4 * v4) == (_DWORD)a2)
      {
        if (++v4 == 24) {
          goto LABEL_16;
        }
      }

      return (v4 - 1);
    }

    else
    {
      uint64_t v5 = 24LL;
      while (*(_DWORD *)(a1 + 4LL * (v5 - 1) + 4) != (_DWORD)a2)
      {
        uint64_t v5 = (v5 - 1);
        if (!(_DWORD)v5)
        {
LABEL_16:
          *a3 = 1;
          return 0xFFFFFFFFLL;
        }
      }

      return v5;
    }
  }

  return a2;
}

uint64_t sub_1808C36FC(const char *a1)
{
  uint64_t result = strcmp(a1, "midnight");
  if ((_DWORD)result)
  {
    if (!strcmp(a1, "noon"))
    {
      return 1LL;
    }

    else if (!strcmp(a1, "morning1"))
    {
      return 2LL;
    }

    else if (!strcmp(a1, "afternoon1"))
    {
      return 3LL;
    }

    else if (!strcmp(a1, "evening1"))
    {
      return 4LL;
    }

    else if (!strcmp(a1, "night1"))
    {
      return 5LL;
    }

    else if (!strcmp(a1, "morning2"))
    {
      return 6LL;
    }

    else if (!strcmp(a1, "afternoon2"))
    {
      return 7LL;
    }

    else if (!strcmp(a1, "evening2"))
    {
      return 8LL;
    }

    else if (!strcmp(a1, "night2"))
    {
      return 9LL;
    }

    else if (!strcmp(a1, "am"))
    {
      return 10LL;
    }

    else if (!strcmp(a1, "pm"))
    {
      return 11LL;
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

void *sub_1808C385C(void *a1, char *a2, icu::ResourceValue *a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v25 = 0LL;
  __s1 = a2;
  memset(v24, 0, sizeof(v24));
  uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))( v24,  a3,  a5);
  if (*(int *)a5 <= 0)
  {
    uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v24, 0, (const char **)&__s1, a3);
    if ((_DWORD)result)
    {
      int v9 = 0;
      do
      {
        int v10 = __s1;
        if (!strcmp(__s1, "locales"))
        {
          uint64_t v23 = 0LL;
          memset(v22, 0, sizeof(v22));
          uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))( v22,  a3,  a5);
          int KeyAndValue = icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v22, 0, (const char **)&__s1, a3);
          __int128 v17 = 0uLL;
          if (KeyAndValue)
          {
            unsigned int v18 = 1;
            do
            {
              __int128 v31 = v17;
              __int128 v32 = v17;
              __int128 v30 = v17;
              __int128 v29 = v17;
              int v28 = 0;
              uint64_t v27 = (*(uint64_t (**)(icu::ResourceValue *, int *, UErrorCode *))(*(void *)a3 + 32LL))( a3,  &v28,  a5);
              icu::UnicodeString::UnicodeString(&v29, 1LL, &v27);
              unsigned int v19 = sub_1808C3BF0((icu::UnicodeString *)&v29, a5);
              uhash_puti(*(void *)qword_18C5352F8, (uint64_t)__s1, v19, (int *)a5);
              icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v29);
              int v21 = icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v22, v18, (const char **)&__s1, a3);
              __int128 v17 = 0uLL;
              ++v18;
            }

            while (v21);
          }
        }

        else if (!strcmp(v10, "rules"))
        {
          unint64_t v12 = *(int *)(qword_18C5352F8 + 16) + 1LL;
          if (is_mul_ok(v12, 0x64uLL)) {
            uint64_t v13 = 100 * v12;
          }
          else {
            uint64_t v13 = -1LL;
          }
          uint64_t result = (void *)icu::UMemory::operator new[]((icu::UMemory *)v13, v11);
          if (!result)
          {
            *(void *)(qword_18C5352F8 + 8) = 0LL;
            *a5 = U_MEMORY_ALLOCATION_ERROR;
            return result;
          }

          *(void *)&__int128 v14 = -1LL;
          *((void *)&v14 + 1) = -1LL;
          if ((_DWORD)v12)
          {
            unint64_t v15 = result;
            do
            {
              *(_WORD *)unint64_t v15 = 0;
              *(_OWORD *)((char *)v15 + 4) = v14;
              *(_OWORD *)((char *)v15 + 20) = v14;
              *(_OWORD *)((char *)v15 + 36) = v14;
              *(_OWORD *)((char *)v15 + 52) = v14;
              *(_OWORD *)((char *)v15 + 68) = v14;
              *(_OWORD *)((char *)v15 + 84) = v14;
              unint64_t v15 = (void *)((char *)v15 + 100);
            }

            while (v15 != (void *)((char *)result + 100 * v12));
          }

          *(void *)(qword_18C5352F8 + 8) = result;
          *(void *)&__int128 v31 = 0LL;
          __int128 v30 = 0u;
          __int128 v29 = 0u;
          (*(void (**)(__int128 *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))( &v29,  a3,  a5);
          uint64_t result = sub_1808C3C9C(a1, (icu::ResourceTable *)&v29, __s1, a3, (int *)a5);
        }

        uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v24, ++v9, (const char **)&__s1, a3);
      }

      while ((_DWORD)result);
    }
  }

  return result;
}

void *sub_1808C3B34(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  uint64_t v11 = 0LL;
  unint64_t v12 = a2;
  memset(v10, 0, sizeof(v10));
  uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v10,  a3,  a5);
  if (*a5 <= 0)
  {
    uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v10, 0, (const char **)&v12, a3);
    if ((_DWORD)result)
    {
      unsigned int v8 = 1;
      do
      {
        int v9 = sub_1808C4040((uint64_t)v12, a5);
        if (v9 > *(_DWORD *)(qword_18C5352F8 + 16)) {
          *(_DWORD *)(qword_18C5352F8 + 16) = v9;
        }
        uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v10, v8++, (const char **)&v12, a3);
      }

      while ((_DWORD)result);
    }
  }

  return result;
}

uint64_t sub_1808C3BF0(icu::UnicodeString *a1, UErrorCode *a2)
{
  v5[8] = *(void **)MEMORY[0x1895F89C0];
  memset(&v5[1], 0, 56);
  v5[0] = (char *)&v5[1] + 5;
  LODWORD(v5[1]) = 40;
  icu::CharString::appendInvariantChars((icu::CharString *)v5, a1, a2);
  uint64_t v3 = sub_1808C4040((uint64_t)v5[0], (int *)a2);
  if (BYTE4(v5[1])) {
    uprv_free(v5[0]);
  }
  return v3;
}

void *sub_1808C3C9C(void *result, icu::ResourceTable *this, char *a3, icu::ResourceValue *a4, int *a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  __int128 v32 = a3;
  if (*a5 > 0) {
    return result;
  }
  uint64_t v8 = (uint64_t)result;
  uint64_t result = (void *)icu::ResourceTable::getKeyAndValue(this, 0, (const char **)&v32, a4);
  if (!(_DWORD)result) {
    return result;
  }
  int v9 = 0;
  while (1)
  {
    *(_DWORD *)(v8 + 108) = sub_1808C4040((uint64_t)v32, a5);
    uint64_t v31 = 0LL;
    memset(v30, 0, sizeof(v30));
    uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a4 + 88LL))( v30,  a4,  a5);
    if (*a5 > 0) {
      return result;
    }
    int v25 = v9;
    uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, 0, (const char **)&v32, a4);
    if ((_DWORD)result) {
      break;
    }
LABEL_22:
    uint64_t v20 = *(void *)(qword_18C5352F8 + 8);
    int v21 = *(_DWORD *)(v8 + 108);
    if (*(_DWORD *)(v20 + 100LL * v21 + 4) == -1)
    {
LABEL_29:
      *a5 = 3;
      return result;
    }

    uint64_t v22 = v20 + 100LL * v21;
    uint64_t v23 = 2LL;
    while (v23 != 25)
    {
      int v24 = *(_DWORD *)(v22 + 4 * v23++);
      if (v24 == -1)
      {
        break;
      }
    }

    int v9 = v25 + 1;
    uint64_t result = (void *)icu::ResourceTable::getKeyAndValue(this, v25 + 1, (const char **)&v32, a4);
    if (!(_DWORD)result) {
      return result;
    }
  }

  unsigned int v10 = 0;
  while (1)
  {
    uint64_t result = (void *)sub_1808C36FC(v32);
    *(_DWORD *)(v8 + 112) = (_DWORD)result;
    if ((_DWORD)result == -1) {
      goto LABEL_29;
    }
    uint64_t v29 = 0LL;
    memset(v28, 0, sizeof(v28));
    uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a4 + 88LL))( v28,  a4,  a5);
    if (*a5 > 0) {
      return result;
    }
LABEL_21:
    sub_1808C41CC(v8, a5);
    *(_DWORD *)(v8 + 104) = 0;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 88) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    ++v10;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, v10, (const char **)&v32, a4);
    if (!(_DWORD)result) {
      goto LABEL_22;
    }
  }

  int v11 = 0;
  while (1)
  {
    int v12 = (*(uint64_t (**)(icu::ResourceValue *))(*(void *)a4 + 24LL))(a4);
    int v13 = sub_1808C40CC(v32);
    int v14 = v13;
    if (!v12)
    {
      LODWORD(v33) = 0;
      v26[0] = (*(uint64_t (**)(icu::ResourceValue *, uint64_t *, int *))(*(void *)a4 + 32LL))(a4, &v33, a5);
      icu::UnicodeString::UnicodeString(v35, 1LL, v26);
      sub_1808C414C(v8, v14, (uint64_t)v35, a5);
      uint64_t result = icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v35);
      if (*a5 >= 1) {
        return result;
      }
      goto LABEL_20;
    }

    *(_DWORD *)(v8 + 116) = v13;
    v26[0] = 0LL;
    v26[1] = 0LL;
    uint64_t v27 = 0LL;
    uint64_t result = (*(void *(**)(void *__return_ptr, icu::ResourceValue *, int *))(*(void *)a4 + 80LL))( v26,  a4,  a5);
    if (*a5 > 0) {
      return result;
    }
    int v15 = v27;
LABEL_20:
  }

  unsigned int v16 = 0;
  while (1)
  {
    icu::ResourceArray::getValue((icu::ResourceArray *)v26, v16, a4);
    int v17 = *(_DWORD *)(v8 + 116);
    int v34 = 0;
    uint64_t v33 = (*(uint64_t (**)(icu::ResourceValue *, int *, int *))(*(void *)a4 + 32LL))(a4, &v34, a5);
    icu::UnicodeString::UnicodeString(v35, 1LL, &v33);
    sub_1808C414C(v8, v17, (uint64_t)v35, a5);
    uint64_t result = icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v35);
    if (*a5 >= 1) {
      return result;
    }
    if (v15 == ++v16) {
      goto LABEL_20;
    }
  }

uint64_t sub_1808C4040(uint64_t a1, int *a2)
{
  if (*a2 <= 0)
  {
    if (!strncmp((const char *)a1, "set", 3uLL))
    {
      int v5 = *(unsigned __int8 *)(a1 + 3);
      if (*(_BYTE *)(a1 + 3))
      {
        LODWORD(result) = 0;
        uint64_t v6 = (unsigned __int8 *)(a1 + 4);
        while ((v5 - 48) <= 9)
        {
          uint64_t result = (v5 + 10 * result - 48);
          int v7 = *v6++;
          int v5 = v7;
          if (!v7)
          {
            if ((_DWORD)result) {
              return result;
            }
            break;
          }
        }
      }
    }

    *a2 = 3;
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_1808C40CC(const char *a1)
{
  if (!strcmp(a1, "from")) {
    return 2LL;
  }
  uint64_t result = strcmp(a1, "before");
  if ((_DWORD)result)
  {
    if (!strcmp(a1, "after"))
    {
      return 1LL;
    }

    else if (!strcmp(a1, "at"))
    {
      return 3LL;
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t sub_1808C414C(uint64_t result, int a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0)
  {
    char v5 = a2;
    if (a2 == -1)
    {
      *a4 = 3;
    }

    else
    {
      uint64_t v6 = result;
      uint64_t result = sub_1808C42AC(a3, a4);
      if (*a4 <= 0) {
        *(_DWORD *)(v6 + 4LL * (int)result + 8) |= 1 << v5;
      }
    }
  }

  return result;
}

uint64_t sub_1808C41CC(uint64_t result, _DWORD *a2)
{
  unsigned int v2 = 0;
  uint64_t v3 = *(void *)(qword_18C5352F8 + 8);
  int v4 = *(_DWORD *)(result + 108);
  char v5 = (_BYTE *)(v3 + 100LL * v4);
  while (1)
  {
    int v6 = *(_DWORD *)(result + 4LL * v2 + 8);
    if ((v6 & 8) != 0)
    {
      if (v2 == 12)
      {
        if (*(_DWORD *)(result + 112) != 1) {
          goto LABEL_24;
        }
        v5[1] = 1;
      }

      else
      {
        if (v2 || *(_DWORD *)(result + 112)) {
          goto LABEL_24;
        }
        *char v5 = 1;
      }
    }

    if ((v6 & 6) != 0) {
      break;
    }
LABEL_16:
    if (v2 > 0x17) {
      return result;
    }
LABEL_23:
    ++v2;
  }

  signed int v7 = v2;
  while (++v7 != v2)
  {
    if (v7 == 25) {
      signed int v7 = 0;
    }
    if ((*(_DWORD *)(result + 4LL * v7 + 8) & 1) != 0)
    {
      if (v2 == v7) {
        goto LABEL_16;
      }
      int v8 = *(_DWORD *)(result + 112);
      signed int v9 = v2;
      do
      {
        if (v9 == 24) {
          signed int v9 = 0;
        }
        *(_DWORD *)(v3 + 100LL * v4 + 4LL * v9++ + 4) = v8;
      }

      while (v9 != v7);
      if (v2 >= 0x18) {
        return result;
      }
      goto LABEL_23;
    }
  }

uint64_t sub_1808C42AC(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  unsigned int v3 = *(unsigned __int16 *)(a1 + 8);
  else {
    unsigned int v4 = v3 >> 5;
  }
  if (v4 - 6 < 0xFFFFFFFE) {
    goto LABEL_17;
  }
  unsigned int v5 = v4 - 3;
  int v6 = (unsigned __int16 *)(a1 + 10);
  if ((v3 & 2) == 0) {
    int v6 = *(unsigned __int16 **)(a1 + 24);
  }
  if (v6[v5] != 58) {
    goto LABEL_17;
  }
  int v7 = (__int16)v3;
  unsigned int v8 = v4 - 2;
  unsigned int v9 = v3 >> 5;
  if (v7 < 0) {
    unsigned int v9 = *(_DWORD *)(a1 + 12);
  }
  if (v9 <= v8
    || v6[v8] != 48
    || (unsigned int v10 = v4 - 1, v9 <= v10)
    || v6[v10] != 48
    || (int v11 = *v6, (v11 - 58) < 0xFFFFFFF6)
    || (uint64_t result = (v11 - 48), v5 == 2)
    && (v9 < 2
     || (int v12 = v6[1], (v12 - 58) < 0xFFFFFFF6)
     || (uint64_t result = (v12 + 10 * result - 48), (int)result >= 25)))
  {
LABEL_17:
    uint64_t result = 0LL;
    *a2 = 3;
  }

  return result;
}

void *icu::DecimalFormatSymbols::getStaticClassID(icu::DecimalFormatSymbols *this)
{
  return &unk_18C535300;
}

void *icu::DecimalFormatSymbols::getDynamicClassID(icu::DecimalFormatSymbols *this)
{
  return &unk_18C535300;
}

icu::DecimalFormatSymbols *icu::DecimalFormatSymbols::DecimalFormatSymbols( icu::DecimalFormatSymbols *this, UErrorCode *a2)
{
  *(void *)this = off_189722658;
  uint64_t v4 = 8LL;
  do
  {
    unsigned int v5 = (char *)this + v4;
    *(void *)unsigned int v5 = off_18971B688;
    *((_WORD *)v5 + 4) = 2;
    v4 += 64LL;
  }

  while (v5 + 64 != (char *)this + 1864);
  *((void *)this + 233) = off_18971B688;
  *((_WORD *)this + 936) = 2;
  icu::Locale::Locale((icu::DecimalFormatSymbols *)((char *)this + 1936));
  *((void *)this + 310) = 0LL;
  uint64_t v6 = 2488LL;
  do
  {
    int v7 = (char *)this + v6;
    *(void *)int v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    v6 += 64LL;
  }

  while (v7 + 64 != (char *)this + 2680);
  uint64_t v8 = 2680LL;
  do
  {
    unsigned int v9 = (char *)this + v8;
    *(void *)unsigned int v9 = off_18971B688;
    *((_WORD *)v9 + 4) = 2;
    v8 += 64LL;
  }

  while (v9 + 64 != (char *)this + 2872);
  *((_BYTE *)this + 2882) = 0;
  *(void *)((char *)this + 2874) = 0LL;
  icu::DecimalFormatSymbols::initialize(this, (char **)this + 242, a2, 1, 0LL, 0);
  return this;
}

void icu::DecimalFormatSymbols::initialize( icu::DecimalFormatSymbols *this, char **a2, UErrorCode *a3, int a4, const icu::NumberingSystem *a5, char a6)
{
  v79[9] = *(UChar **)MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    *((_BYTE *)this + 2160) = 0;
    *((_BYTE *)this + 2317) = 0;
    icu::DecimalFormatSymbols::initialize(this);
    if (a5)
    {
      uint64_t Instance = 0LL;
    }

    else
    {
      uint64_t Instance = icu::NumberingSystem::createInstance((icu::NumberingSystem *)a2, a3, v12);
      a5 = Instance;
    }

    if (*(int *)a3 <= 0
      && icu::NumberingSystem::getRadix(a5) == 10
      && !icu::NumberingSystem::isAlgorithmic(a5))
    {
      char v55 = a6;
      Name = (const char *)icu::NumberingSystem::getName(a5);
      memset(v79, 0, 64);
      (*(void (**)(UChar **__return_ptr, const icu::NumberingSystem *))(*(void *)a5 + 24LL))(v79, a5);
      unsigned int v48 = icu::UnicodeString::char32At(v47, (icu::UnicodeString *)v79, 0);
      icu::UnicodeString::unBogus((uint64_t)this + 264);
      else {
        uint64_t v49 = *((unsigned __int16 *)this + 136) >> 5;
      }
      icu::UnicodeString::replace((icu::DecimalFormatSymbols *)((char *)this + 264), 0LL, v49, v48);
      uint64_t v50 = 0LL;
      int v51 = 0;
      do
      {
        if (v48 < 0x10000) {
          uint64_t v52 = 1LL;
        }
        else {
          uint64_t v52 = 2LL;
        }
        v51 += v52;
        unsigned int v48 = icu::UnicodeString::char32At((uint64_t *)v52, (icu::UnicodeString *)v79, v51);
        icu::UnicodeString::unBogus((uint64_t)this + v50 + 1160);
        else {
          uint64_t v53 = *(unsigned __int16 *)((char *)this + v50 + 1168) >> 5;
        }
        icu::UnicodeString::replace((icu::DecimalFormatSymbols *)((char *)this + v50 + 1160), 0LL, v53, v48);
        v50 += 64LL;
      }

      while (v50 != 576);
      icu::UnicodeString::~UnicodeString(v54, (icu::UnicodeString *)v79);
      if ((v55 & 1) != 0)
      {
LABEL_18:
        if (Instance) {
          (*(void (**)(icu::NumberingSystem *))(*(void *)Instance + 8LL))(Instance);
        }
        return;
      }
    }

    else
    {
      Name = "latn";
    }

    strcpy((char *)this + 2874, Name);
    int v15 = a2[5];
    uint64_t v16 = ures_open(0LL, v15, (int *)a3);
    uint64_t v17 = ures_getByKeyWithFallback(v16, "NumberElements", 0LL, a3);
    uint64_t v18 = ures_openWithCountryFallback(0LL, v15, 0LL, (int *)a3);
    if (*(int *)a3 < 1)
    {
      unint64_t v57 = Instance;
      v68[0] = (char *)this + 2317;
      v68[1] = (char *)this + 2160;
      LocaleByunsigned int Type = (const char *)ures_getLocaleByType(v17, 1, (int *)a3);
      uint64_t v56 = v17;
      uint64_t v20 = (const char *)ures_getLocaleByType(v17, 0, (int *)a3);
      icu::LocaleBased::setLocaleIDs((char *)v68, LocaleByType, v20);
      v75 = &off_189722698;
      uint64_t v76 = this;
      __int128 v78 = 0uLL;
      __int128 v77 = 0uLL;
      if (v18) {
        uint64_t v21 = v18;
      }
      else {
        uint64_t v21 = v16;
      }
      *(void *)((char *)&v78 + 5) = 0LL;
      if (v21)
      {
        do
        {
          if (strcmp(Name, "latn"))
          {
            memset(&v79[1], 0, 56);
            v79[0] = (UChar *)((char *)&v79[1] + 5);
            LODWORD(v79[1]) = 40;
            icu::StringPiece::StringPiece((icu::StringPiece *)&v66, "NumberElements");
            uint64_t v22 = icu::CharString::append((icu::CharString *)v79, v66, v67, a3);
            uint64_t v23 = icu::CharString::append(v22, 47, a3);
            icu::StringPiece::StringPiece((icu::StringPiece *)&v64, Name);
            int v24 = icu::CharString::append(v23, v64, v65, a3);
            int v25 = icu::CharString::append(v24, 47, a3);
            icu::StringPiece::StringPiece((icu::StringPiece *)&v62, "symbols");
            icu::CharString::append(v25, v62, v63, a3);
            ures_getAllItemsWithFallback(v21, (char *)v79[0], (uint64_t)&v75, (int *)a3);
            if (*a3 == U_MISSING_RESOURCE_ERROR)
            {
              *a3 = U_ZERO_ERROR;
            }

            else if (*(int *)a3 > 0)
            {
              if (BYTE4(v79[1])) {
                uprv_free(v79[0]);
              }
              goto LABEL_69;
            }

            if (BYTE4(v79[1])) {
              uprv_free(v79[0]);
            }
          }

          if ((_BYTE)v77)
          {
            uint64_t v26 = 0LL;
            while (v26 != 28)
            {
              if (!*((unsigned __int8 *)&v77 + ++v26))
              {
                goto LABEL_36;
              }
            }
          }

          else
          {
LABEL_36:
            ures_getAllItemsWithFallback(v21, "NumberElements/latn/symbols", (uint64_t)&v75, (int *)a3);
          }

          if (v21 == v18)
          {
            BYTE3(v77) = 0;
            BYTE11(v77) = 0;
            HIWORD(v77) = 0;
            *(_DWORD *)((char *)&v77 + 6) = 0;
          }

          if (v21 == v16) {
            break;
          }
          uint64_t v21 = v16;
        }

        while (v16);
        if (BYTE10(v77)) {
          goto LABEL_43;
        }
      }

      icu::UnicodeString::operator=((UChar **)v76 + 81, (UChar **)this + 1);
LABEL_43:
      if (!BYTE1(v78)) {
        icu::UnicodeString::operator=((UChar **)v76 + 137, (UChar **)this + 9);
      }
      uint64_t v28 = 0LL;
      uint64_t v29 = (char *)this + 1096;
      int v30 = -1;
      while (1)
      {
        uint64_t v31 = v28 ? (icu::UnicodeString *)v29 : (icu::DecimalFormatSymbols *)((char *)this + 264);
        unsigned int v33 = icu::UnicodeString::char32At(v32, v31, 0);
        if (v28)
        {
          if ((_DWORD)v28 + v30 != v33) {
            break;
          }
        }

        else
        {
          int v30 = v33;
        }

        ++v28;
        v29 += 64;
        if (v28 == 10) {
          goto LABEL_57;
        }
      }

      int v30 = -1;
LABEL_57:
      *((_DWORD *)this + 482) = v30;
      int v61 = 0;
      uint64_t v73 = 0LL;
      uint64_t v74 = 0LL;
      __int128 v70 = 0u;
      __int128 v71 = 0u;
      __int128 v72 = 0u;
      unint64_t v69 = off_18971B688;
      LOWORD(v70) = 2;
      int v34 = ucurr_forLocale(v15, (UChar *)&v74, 4LL, &v61);
      if (v61 <= 0 && v34 == 3) {
        icu::DecimalFormatSymbols::setCurrency((char **)this, (const UChar *)&v74, (int *)a3);
      }
      uint64_t v35 = ures_open("icudt74l-curr", v15, (int *)a3);
      v59 = this;
      uint64_t v60 = 0LL;
      uint64_t v58 = &off_1897227C8;
      ures_getAllItemsWithFallback(v35, "currencySpacing", (uint64_t)&v58, (int *)a3);
      if (!(_BYTE)v60 || !BYTE1(v60))
      {
        uint64_t v36 = off_189722800;
        for (uint64_t i = 2680LL; i != 2872; i += 64LL)
        {
          int32_t v38 = v59;
          uint64_t v39 = (uint64_t)*v36++;
          icu::UnicodeString::UnicodeString(v79, v39, 0xFFFFFFFFLL, 0LL);
          icu::UnicodeString::operator=((UChar **)((char *)v38 + i), v79);
          icu::UnicodeString::~UnicodeString(v40, (icu::UnicodeString *)v79);
        }

        uint64_t v41 = off_189722800;
        for (uint64_t j = 2488LL; j != 2680; j += 64LL)
        {
          uint64_t v43 = v59;
          uint64_t v44 = (uint64_t)*v41++;
          icu::UnicodeString::UnicodeString(v79, v44, 0xFFFFFFFFLL, 0LL);
          icu::UnicodeString::operator=((UChar **)((char *)v43 + j), v79);
          icu::UnicodeString::~UnicodeString(v45, (icu::UnicodeString *)v79);
        }
      }

      icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v58);
      if (v35) {
        ures_close(v35);
      }
      icu::UnicodeString::~UnicodeString(v46, (icu::UnicodeString *)&v69);
LABEL_69:
      icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v75);
      uint64_t v17 = v56;
      uint64_t Instance = v57;
      if (!v18) {
        goto LABEL_14;
      }
    }

    else
    {
      if (a4)
      {
        *a3 = U_USING_DEFAULT_WARNING;
        icu::DecimalFormatSymbols::initialize(this);
      }

      if (!v18) {
        goto LABEL_14;
      }
    }

    ures_close(v18);
LABEL_14:
    if (v17) {
      ures_close(v17);
    }
    if (v16) {
      ures_close(v16);
    }
    goto LABEL_18;
  }

icu::DecimalFormatSymbols *icu::DecimalFormatSymbols::DecimalFormatSymbols( icu::DecimalFormatSymbols *this, const icu::Locale *a2, UErrorCode *a3)
{
  *(void *)this = off_189722658;
  uint64_t v5 = 8LL;
  do
  {
    uint64_t v6 = (char *)this + v5;
    *(void *)uint64_t v6 = off_18971B688;
    *((_WORD *)v6 + 4) = 2;
    v5 += 64LL;
  }

  while (v6 + 64 != (char *)this + 1864);
  *((void *)this + 233) = off_18971B688;
  *((_WORD *)this + 936) = 2;
  icu::Locale::Locale((icu::DecimalFormatSymbols *)((char *)this + 1936), (uint64_t)a2);
  *((void *)this + 310) = 0LL;
  uint64_t v7 = 2488LL;
  do
  {
    uint64_t v8 = (char *)this + v7;
    *(void *)uint64_t v8 = off_18971B688;
    *((_WORD *)v8 + 4) = 2;
    v7 += 64LL;
  }

  while (v8 + 64 != (char *)this + 2680);
  uint64_t v9 = 2680LL;
  do
  {
    unsigned int v10 = (char *)this + v9;
    *(void *)unsigned int v10 = off_18971B688;
    *((_WORD *)v10 + 4) = 2;
    v9 += 64LL;
  }

  while (v10 + 64 != (char *)this + 2872);
  *((_BYTE *)this + 2882) = 0;
  *(void *)((char *)this + 2874) = 0LL;
  icu::DecimalFormatSymbols::initialize(this, (char **)this + 242, a3, 0, 0LL, 0);
  return this;
}

icu::DecimalFormatSymbols *icu::DecimalFormatSymbols::DecimalFormatSymbols( icu::DecimalFormatSymbols *this, const icu::Locale *a2, const icu::NumberingSystem *a3, UErrorCode *a4)
{
  *(void *)this = off_189722658;
  uint64_t v7 = 8LL;
  do
  {
    uint64_t v8 = (char *)this + v7;
    *(void *)uint64_t v8 = off_18971B688;
    *((_WORD *)v8 + 4) = 2;
    v7 += 64LL;
  }

  while (v8 + 64 != (char *)this + 1864);
  *((void *)this + 233) = off_18971B688;
  *((_WORD *)this + 936) = 2;
  icu::Locale::Locale((icu::DecimalFormatSymbols *)((char *)this + 1936), (uint64_t)a2);
  *((void *)this + 310) = 0LL;
  uint64_t v9 = 2488LL;
  do
  {
    unsigned int v10 = (char *)this + v9;
    *(void *)unsigned int v10 = off_18971B688;
    *((_WORD *)v10 + 4) = 2;
    v9 += 64LL;
  }

  while (v10 + 64 != (char *)this + 2680);
  uint64_t v11 = 2680LL;
  do
  {
    int v12 = (char *)this + v11;
    *(void *)int v12 = off_18971B688;
    *((_WORD *)v12 + 4) = 2;
    v11 += 64LL;
  }

  while (v12 + 64 != (char *)this + 2872);
  *((_BYTE *)this + 2882) = 0;
  *(void *)((char *)this + 2874) = 0LL;
  icu::DecimalFormatSymbols::initialize(this, (char **)this + 242, a4, 0, a3, 0);
  return this;
}

icu::DecimalFormatSymbols *icu::DecimalFormatSymbols::DecimalFormatSymbols( icu::DecimalFormatSymbols *this, const icu::Locale *a2, const icu::NumberingSystem *a3, char a4, UErrorCode *a5)
{
  *(void *)this = off_189722658;
  uint64_t v9 = 8LL;
  do
  {
    unsigned int v10 = (char *)this + v9;
    *(void *)unsigned int v10 = off_18971B688;
    *((_WORD *)v10 + 4) = 2;
    v9 += 64LL;
  }

  while (v10 + 64 != (char *)this + 1864);
  *((void *)this + 233) = off_18971B688;
  *((_WORD *)this + 936) = 2;
  icu::Locale::Locale((icu::DecimalFormatSymbols *)((char *)this + 1936), (uint64_t)a2);
  *((void *)this + 310) = 0LL;
  uint64_t v11 = 2488LL;
  do
  {
    int v12 = (char *)this + v11;
    *(void *)int v12 = off_18971B688;
    *((_WORD *)v12 + 4) = 2;
    v11 += 64LL;
  }

  while (v12 + 64 != (char *)this + 2680);
  uint64_t v13 = 2680LL;
  do
  {
    int v14 = (char *)this + v13;
    *(void *)int v14 = off_18971B688;
    *((_WORD *)v14 + 4) = 2;
    v13 += 64LL;
  }

  while (v14 + 64 != (char *)this + 2872);
  *((_BYTE *)this + 2882) = 0;
  *(void *)((char *)this + 2874) = 0LL;
  icu::DecimalFormatSymbols::initialize(this, (char **)this + 242, a5, 0, a3, a4);
  return this;
}

icu::DecimalFormatSymbols *icu::DecimalFormatSymbols::DecimalFormatSymbols(icu::DecimalFormatSymbols *this)
{
  *(void *)this = off_189722658;
  uint64_t v2 = 8LL;
  do
  {
    unsigned int v3 = (char *)this + v2;
    *(void *)unsigned int v3 = off_18971B688;
    *((_WORD *)v3 + 4) = 2;
    v2 += 64LL;
  }

  while (v3 + 64 != (char *)this + 1864);
  *((void *)this + 233) = off_18971B688;
  *((_WORD *)this + 936) = 2;
  uint64_t Root = icu::Locale::getRoot(this);
  icu::Locale::Locale((icu::DecimalFormatSymbols *)((char *)this + 1936), Root);
  *((void *)this + 310) = 0LL;
  uint64_t v5 = 2488LL;
  do
  {
    uint64_t v6 = (char *)this + v5;
    *(void *)uint64_t v6 = off_18971B688;
    *((_WORD *)v6 + 4) = 2;
    v5 += 64LL;
  }

  while (v6 + 64 != (char *)this + 2680);
  uint64_t v7 = 2680LL;
  do
  {
    uint64_t v8 = (char *)this + v7;
    *(void *)uint64_t v8 = off_18971B688;
    *((_WORD *)v8 + 4) = 2;
    v7 += 64LL;
  }

  while (v8 + 64 != (char *)this + 2872);
  *((_BYTE *)this + 2882) = 0;
  *(void *)((char *)this + 2874) = 0LL;
  *((_BYTE *)this + 2160) = 0;
  *((_BYTE *)this + 2317) = 0;
  icu::DecimalFormatSymbols::initialize(this);
  return this;
}

uint64_t icu::DecimalFormatSymbols::initialize(icu::DecimalFormatSymbols *this)
{
  uint64_t v2 = (char *)this + 8;
  __int16 v59 = 46;
  unsigned int v3 = *((unsigned __int16 *)this + 8);
  if ((v3 & 0x8000) != 0) {
    uint64_t v4 = *((unsigned int *)this + 5);
  }
  else {
    uint64_t v4 = v3 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)v2, 0LL, v4, (uint64_t)&v59, 0, 1LL);
  if ((*((_WORD *)this + 40) & 1) != 0) {
    __int16 v5 = 2;
  }
  else {
    __int16 v5 = *((_WORD *)this + 40) & 0x1F;
  }
  *((_WORD *)this + 40) = v5;
  __int16 v59 = 59;
  unsigned int v6 = *((unsigned __int16 *)this + 72);
  if ((v6 & 0x8000) != 0) {
    uint64_t v7 = *((unsigned int *)this + 37);
  }
  else {
    uint64_t v7 = v6 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 136, 0LL, v7, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 37;
  unsigned int v8 = *((unsigned __int16 *)this + 104);
  if ((v8 & 0x8000) != 0) {
    uint64_t v9 = *((unsigned int *)this + 53);
  }
  else {
    uint64_t v9 = v8 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 200, 0LL, v9, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 48;
  unsigned int v10 = *((unsigned __int16 *)this + 136);
  if ((v10 & 0x8000) != 0) {
    uint64_t v11 = *((unsigned int *)this + 69);
  }
  else {
    uint64_t v11 = v10 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 264, 0LL, v11, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 49;
  unsigned int v12 = *((unsigned __int16 *)this + 584);
  if ((v12 & 0x8000) != 0) {
    uint64_t v13 = *((unsigned int *)this + 293);
  }
  else {
    uint64_t v13 = v12 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1160, 0LL, v13, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 50;
  unsigned int v14 = *((unsigned __int16 *)this + 616);
  if ((v14 & 0x8000) != 0) {
    uint64_t v15 = *((unsigned int *)this + 309);
  }
  else {
    uint64_t v15 = v14 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1224, 0LL, v15, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 51;
  unsigned int v16 = *((unsigned __int16 *)this + 648);
  if ((v16 & 0x8000) != 0) {
    uint64_t v17 = *((unsigned int *)this + 325);
  }
  else {
    uint64_t v17 = v16 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1288, 0LL, v17, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 52;
  unsigned int v18 = *((unsigned __int16 *)this + 680);
  if ((v18 & 0x8000) != 0) {
    uint64_t v19 = *((unsigned int *)this + 341);
  }
  else {
    uint64_t v19 = v18 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1352, 0LL, v19, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 53;
  unsigned int v20 = *((unsigned __int16 *)this + 712);
  if ((v20 & 0x8000) != 0) {
    uint64_t v21 = *((unsigned int *)this + 357);
  }
  else {
    uint64_t v21 = v20 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1416, 0LL, v21, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 54;
  unsigned int v22 = *((unsigned __int16 *)this + 744);
  if ((v22 & 0x8000) != 0) {
    uint64_t v23 = *((unsigned int *)this + 373);
  }
  else {
    uint64_t v23 = v22 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1480, 0LL, v23, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 55;
  unsigned int v24 = *((unsigned __int16 *)this + 776);
  if ((v24 & 0x8000) != 0) {
    uint64_t v25 = *((unsigned int *)this + 389);
  }
  else {
    uint64_t v25 = v24 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1544, 0LL, v25, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 56;
  unsigned int v26 = *((unsigned __int16 *)this + 808);
  if ((v26 & 0x8000) != 0) {
    uint64_t v27 = *((unsigned int *)this + 405);
  }
  else {
    uint64_t v27 = v26 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1608, 0LL, v27, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 57;
  unsigned int v28 = *((unsigned __int16 *)this + 840);
  if ((v28 & 0x8000) != 0) {
    uint64_t v29 = *((unsigned int *)this + 421);
  }
  else {
    uint64_t v29 = v28 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1672, 0LL, v29, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 35;
  unsigned int v30 = *((unsigned __int16 *)this + 168);
  if ((v30 & 0x8000) != 0) {
    uint64_t v31 = *((unsigned int *)this + 85);
  }
  else {
    uint64_t v31 = v30 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 328, 0LL, v31, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 43;
  unsigned int v32 = *((unsigned __int16 *)this + 232);
  if ((v32 & 0x8000) != 0) {
    uint64_t v33 = *((unsigned int *)this + 117);
  }
  else {
    uint64_t v33 = v32 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 456, 0LL, v33, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 45;
  unsigned int v34 = *((unsigned __int16 *)this + 200);
  if ((v34 & 0x8000) != 0) {
    uint64_t v35 = *((unsigned int *)this + 101);
  }
  else {
    uint64_t v35 = v34 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 392, 0LL, v35, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 164;
  unsigned int v36 = *((unsigned __int16 *)this + 264);
  if ((v36 & 0x8000) != 0) {
    uint64_t v37 = *((unsigned int *)this + 133);
  }
  else {
    uint64_t v37 = v36 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 520, 0LL, v37, (uint64_t)&v59, 0, 1LL);
  uint64_t v58 = (const UChar *)&unk_180A36FB4;
  icu::UnicodeString::setTo((icu::DecimalFormatSymbols *)((char *)this + 584), 1, &v58, 2);
  __int16 v59 = 46;
  unsigned int v38 = *((unsigned __int16 *)this + 328);
  if ((v38 & 0x8000) != 0) {
    uint64_t v39 = *((unsigned int *)this + 165);
  }
  else {
    uint64_t v39 = v38 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 648, 0LL, v39, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 69;
  unsigned int v40 = *((unsigned __int16 *)this + 360);
  if ((v40 & 0x8000) != 0) {
    uint64_t v41 = *((unsigned int *)this + 181);
  }
  else {
    uint64_t v41 = v40 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 712, 0LL, v41, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 8240;
  unsigned int v42 = *((unsigned __int16 *)this + 392);
  if ((v42 & 0x8000) != 0) {
    uint64_t v43 = *((unsigned int *)this + 197);
  }
  else {
    uint64_t v43 = v42 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 776, 0LL, v43, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 42;
  unsigned int v44 = *((unsigned __int16 *)this + 424);
  if ((v44 & 0x8000) != 0) {
    uint64_t v45 = *((unsigned int *)this + 213);
  }
  else {
    uint64_t v45 = v44 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 840, 0LL, v45, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 8734;
  unsigned int v46 = *((unsigned __int16 *)this + 456);
  if ((v46 & 0x8000) != 0) {
    uint64_t v47 = *((unsigned int *)this + 229);
  }
  else {
    uint64_t v47 = v46 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 904, 0LL, v47, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = -3;
  unsigned int v48 = *((unsigned __int16 *)this + 488);
  if ((v48 & 0x8000) != 0) {
    uint64_t v49 = *((unsigned int *)this + 245);
  }
  else {
    uint64_t v49 = v48 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 968, 0LL, v49, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 64;
  unsigned int v50 = *((unsigned __int16 *)this + 520);
  if ((v50 & 0x8000) != 0) {
    uint64_t v51 = *((unsigned int *)this + 261);
  }
  else {
    uint64_t v51 = v50 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1032, 0LL, v51, (uint64_t)&v59, 0, 1LL);
  if ((*((_WORD *)this + 552) & 1) != 0) {
    __int16 v52 = 2;
  }
  else {
    __int16 v52 = *((_WORD *)this + 552) & 0x1F;
  }
  *((_WORD *)this + 552) = v52;
  __int16 v59 = 215;
  unsigned int v53 = *((unsigned __int16 *)this + 872);
  if ((v53 & 0x8000) != 0) {
    uint64_t v54 = *((unsigned int *)this + 437);
  }
  else {
    uint64_t v54 = v53 >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 1736, 0LL, v54, (uint64_t)&v59, 0, 1LL);
  __int16 v59 = 126;
  unsigned int v55 = *((unsigned __int16 *)this + 904);
  if ((v55 & 0x8000) != 0) {
    uint64_t v56 = *((unsigned int *)this + 453);
  }
  else {
    uint64_t v56 = v55 >> 5;
  }
  uint64_t result = icu::UnicodeString::doReplace((uint64_t)this + 1800, 0LL, v56, (uint64_t)&v59, 0, 1LL);
  *((_WORD *)this + 1436) = 0;
  *((_DWORD *)this + 482) = 48;
  *((void *)this + 310) = 0LL;
  *((_BYTE *)this + 2874) = 0;
  return result;
}

icu::DecimalFormatSymbols *icu::DecimalFormatSymbols::createWithLastResortData( icu::DecimalFormatSymbols *this, UErrorCode *a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)this;
  uint64_t result = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(v2, (icu::UMemory *)0xB48, (unint64_t)a2);
  if (result) {
    return icu::DecimalFormatSymbols::DecimalFormatSymbols(result);
  }
  *(_DWORD *)this = 7;
  return result;
}

void icu::DecimalFormatSymbols::~DecimalFormatSymbols(icu::DecimalFormatSymbols *this)
{
  *(void *)this = off_189722658;
  for (uint64_t i = 2808LL; i != 2616; i -= 64LL)
    icu::UnicodeString::~UnicodeString((icu::DecimalFormatSymbols *)((char *)this + i));
  do
  {
    icu::UnicodeString::~UnicodeString((icu::DecimalFormatSymbols *)((char *)this + i));
    i -= 64LL;
  }

  while (i != 2424);
  icu::Locale::~Locale((icu::DecimalFormatSymbols *)((char *)this + 1936));
  icu::UnicodeString::~UnicodeString((icu::DecimalFormatSymbols *)((char *)this + 1864));
  for (uint64_t j = 1800LL; j != -56; j -= 64LL)
    icu::UnicodeString::~UnicodeString((icu::DecimalFormatSymbols *)((char *)this + j));
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::DecimalFormatSymbols::~DecimalFormatSymbols(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::DecimalFormatSymbols::DecimalFormatSymbols( icu::DecimalFormatSymbols *this, const icu::DecimalFormatSymbols *a2)
{
  *(void *)this = off_189722658;
  uint64_t v4 = 8LL;
  do
  {
    __int16 v5 = (char *)this + v4;
    *(void *)__int16 v5 = off_18971B688;
    *((_WORD *)v5 + 4) = 2;
    v4 += 64LL;
  }

  while (v5 + 64 != (char *)this + 1864);
  *((void *)this + 233) = off_18971B688;
  *((_WORD *)this + 936) = 2;
  icu::Locale::Locale((icu::DecimalFormatSymbols *)((char *)this + 1936));
  *((void *)this + 310) = 0LL;
  uint64_t v6 = 2488LL;
  do
  {
    uint64_t v7 = (char *)this + v6;
    *(void *)uint64_t v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    v6 += 64LL;
  }

  while (v7 + 64 != (char *)this + 2680);
  uint64_t v8 = 2680LL;
  do
  {
    uint64_t v9 = (char *)this + v8;
    *(void *)uint64_t v9 = off_18971B688;
    *((_WORD *)v9 + 4) = 2;
    v8 += 64LL;
  }

  while (v9 + 64 != (char *)this + 2872);
  *((_BYTE *)this + 2882) = 0;
  *(void *)((char *)this + 2874) = 0LL;
  return icu::DecimalFormatSymbols::operator=((uint64_t)this, (uint64_t)a2);
}

uint64_t icu::DecimalFormatSymbols::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    for (uint64_t i = 8LL; i != 1864; i += 64LL)
      icu::UnicodeString::fastCopyFrom((UChar **)(a1 + i), (UChar **)(a2 + i));
    uint64_t v5 = -192LL;
    do
    {
      icu::UnicodeString::fastCopyFrom((UChar **)(a1 + v5 + 2680), (UChar **)(a2 + v5 + 2680));
      icu::UnicodeString::fastCopyFrom((UChar **)(a1 + v5 + 2872), (UChar **)(a2 + v5 + 2872));
      v5 += 64LL;
    }

    while (v5);
    icu::Locale::operator=((icu::Locale *)(a1 + 1936), a2 + 1936);
    strcpy((char *)(a1 + 2317), (const char *)(a2 + 2317));
    strcpy((char *)(a1 + 2160), (const char *)(a2 + 2160));
    *(_WORD *)(a1 + 2872) = *(_WORD *)(a2 + 2872);
    *(_DWORD *)(a1 + 1928) = *(_DWORD *)(a2 + 1928);
    *(void *)(a1 + 2480) = *(void *)(a2 + 2480);
    strcpy((char *)(a1 + 2874), (const char *)(a2 + 2874));
  }

  return a1;
}

uint64_t icu::DecimalFormatSymbols::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (*(unsigned __int8 *)(a1 + 2872) != *(unsigned __int8 *)(a2 + 2872)
    || *(unsigned __int8 *)(a1 + 2873) != *(unsigned __int8 *)(a2 + 2873))
  {
    return 0LL;
  }

  for (uint64_t i = 0LL; i != 1856; i += 64LL)
  {
    uint64_t v5 = a2 + i;
    unsigned int v6 = *(unsigned __int16 *)(a1 + i + 16);
    if ((v6 & 1) != 0)
    {
      if ((*(_WORD *)(v5 + 16) & 1) == 0) {
        return 0LL;
      }
    }

    else
    {
      if ((v6 & 0x8000) != 0) {
        int v7 = *(_DWORD *)(a1 + i + 20);
      }
      else {
        int v7 = v6 >> 5;
      }
      uint64_t result = 0LL;
      unsigned int v9 = *(unsigned __int16 *)(a2 + i + 16);
      unsigned int v10 = *(_DWORD *)(a2 + i + 20);
      if ((v9 & 0x8000u) == 0) {
        unsigned int v10 = v9 >> 5;
      }
      if ((v9 & 1) != 0) {
        return result;
      }
      if (v7 != v10) {
        return result;
      }
      uint64_t result = icu::UnicodeString::doEquals( (icu::UnicodeString *)(a1 + i + 8),  (const icu::UnicodeString *)(v5 + 8),  v7);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  for (uint64_t j = 0LL; j != 192; j += 64LL)
  {
    uint64_t v12 = a2 + j;
    unsigned int v13 = *(unsigned __int16 *)(a1 + j + 2496);
    if ((v13 & 1) != 0)
    {
      if ((*(_WORD *)(v12 + 2496) & 1) == 0) {
        return 0LL;
      }
    }

    else
    {
      if ((v13 & 0x8000) != 0) {
        int v14 = *(_DWORD *)(a1 + j + 2500);
      }
      else {
        int v14 = v13 >> 5;
      }
      uint64_t result = 0LL;
      unsigned int v15 = *(unsigned __int16 *)(a2 + j + 2496);
      unsigned int v16 = *(_DWORD *)(a2 + j + 2500);
      if ((v15 & 0x8000u) == 0) {
        unsigned int v16 = v15 >> 5;
      }
      if ((v15 & 1) != 0) {
        return result;
      }
      if (v14 != v16) {
        return result;
      }
      uint64_t result = icu::UnicodeString::doEquals( (icu::UnicodeString *)(a1 + j + 2488),  (const icu::UnicodeString *)(v12 + 2488),  v14);
      if (!(_DWORD)result) {
        return result;
      }
    }

    uint64_t v17 = a2 + j;
    unsigned int v18 = *(unsigned __int16 *)(a1 + j + 2688);
    if ((v18 & 1) != 0)
    {
      if ((*(_WORD *)(v17 + 2688) & 1) == 0) {
        return 0LL;
      }
    }

    else
    {
      if ((v18 & 0x8000) != 0) {
        int v19 = *(_DWORD *)(a1 + j + 2692);
      }
      else {
        int v19 = v18 >> 5;
      }
      uint64_t result = 0LL;
      unsigned int v20 = *(unsigned __int16 *)(a2 + j + 2688);
      unsigned int v21 = *(_DWORD *)(a2 + j + 2692);
      if ((v20 & 0x8000u) == 0) {
        unsigned int v21 = v20 >> 5;
      }
      if ((v20 & 1) != 0) {
        return result;
      }
      if (v19 != v21) {
        return result;
      }
      uint64_t result = icu::UnicodeString::doEquals( (icu::UnicodeString *)(a1 + j + 2680),  (const icu::UnicodeString *)(v17 + 2680),  v19);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  uint64_t result = icu::Locale::operator==(a1 + 1936, a2 + 1936);
  if ((_DWORD)result)
  {
    return 0LL;
  }

  return result;
}

char **icu::DecimalFormatSymbols::setCurrency(char **result, const UChar *a2, int *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v5 = result;
    __int128 v30 = 0u;
    uint64_t v33 = 0LL;
    __int128 v32 = 0u;
    __int128 v31 = 0u;
    uint64_t v29 = (UChar *)off_18971B688;
    LOWORD(v30) = 2;
    uprv_getStaticCurrencyName(a2, result[247], (uint64_t)&v29, a3);
    if (*a3 <= 0)
    {
      icu::UnicodeString::unBogus((uint64_t)(v5 + 73));
      else {
        uint64_t v6 = *((unsigned __int16 *)v5 + 296) >> 5;
      }
      icu::UnicodeString::doReplace((uint64_t)(v5 + 73), 0LL, v6, (uint64_t)a2, 0, 3LL);
      icu::UnicodeString::operator=((UChar **)v5 + 65, &v29);
    }

    *(_DWORD *)unsigned int v16 = 0;
    u_UCharsToChars(a2, v16, 3);
    int v15 = 0;
    uint64_t v7 = ures_open("icudt74l-curr", v5[247], &v15);
    uint64_t v8 = ures_getByKeyWithFallback(v7, "Currencies", 0LL, (UErrorCode *)&v15);
    ures_getByKeyWithFallback(v8, v16, v8, (UErrorCode *)&v15);
    unint64_t v9 = v15;
    if (v15 <= 0 && (int)ures_getSize(v8) >= 3)
    {
      ures_getByIndex(v8, 2, v8, &v15);
      int v14 = 0;
      v5[310] = (char *)ures_getStringByIndex(v8, 0, &v14, &v15);
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      uint64_t v28 = 0LL;
      unsigned int v24 = (UChar *)off_18971B688;
      LOWORD(v25) = 2;
      LODWORD(v17) = 0;
      StringByIndex = (UChar *)ures_getStringByIndex(v8, 1, (int *)&v17, &v15);
      if (v15 <= 0)
      {
        int v19 = StringByIndex;
        icu::UnicodeString::setTo((icu::UnicodeString *)&v24, 1, (const UChar **)&v19, (int)v17);
      }

      else
      {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)&v24);
      }

      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      uint64_t v23 = 0LL;
      int v19 = (UChar *)off_18971B688;
      LOWORD(v20) = 2;
      int v18 = 0;
      uint64_t v11 = ures_getStringByIndex(v8, 2, &v18, &v15);
      if (v15 <= 0)
      {
        uint64_t v17 = v11;
        icu::UnicodeString::setTo((icu::UnicodeString *)&v19, 1, &v17, v18);
      }

      else
      {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)&v19);
      }

      unint64_t v12 = v15;
      if (v15 <= 0)
      {
        icu::UnicodeString::operator=((UChar **)v5 + 137, &v19);
        icu::UnicodeString::operator=((UChar **)v5 + 81, &v24);
      }

      icu::UnicodeString::~UnicodeString((void *)v12, (icu::UnicodeString *)&v19);
      icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)&v24);
    }

    if (v8) {
      ures_close(v8);
    }
    if (v7) {
      ures_close(v7);
    }
    return (char **)icu::UnicodeString::~UnicodeString((void *)v9, (icu::UnicodeString *)&v29);
  }

  return result;
}

uint64_t icu::DecimalFormatSymbols::getLocale@<X0>( uint64_t a1@<X0>, int a2@<W1>, int *a3@<X2>, icu::Locale *a4@<X8>)
{
  v5[0] = (const char *)(a1 + 2317);
  v5[1] = (const char *)(a1 + 2160);
  return icu::LocaleBased::getLocale(v5, a2, a3, a4);
}

uint64_t icu::DecimalFormatSymbols::getPatternForCurrencySpacing(uint64_t a1, int a2, int a3, int *a4)
{
  uint64_t v4 = a1 + ((uint64_t)a2 << 6);
  uint64_t v5 = v4 + 2680;
  uint64_t v6 = v4 + 2488;
  if (!a3) {
    uint64_t v6 = v5;
  }
  if (*a4 >= 1) {
    return a1 + 1864;
  }
  else {
    return v6;
  }
}

icu::UnicodeString *icu::DecimalFormatSymbols::setPatternForCurrencySpacing( uint64_t a1, int a2, int a3, UChar **a4)
{
  uint64_t v4 = a1 + ((uint64_t)a2 << 6);
  uint64_t v5 = (UChar **)(v4 + 2680);
  uint64_t v6 = (UChar **)(v4 + 2488);
  if (a3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v5;
  }
  return icu::UnicodeString::operator=(v7, a4);
}

void sub_1808C5DE8(icu::ResourceSink *a1)
{
}

void *sub_1808C5DFC(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  v20[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t v16 = 0LL;
  __s1 = a2;
  memset(v15, 0, sizeof(v15));
  uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v15,  a3,  a5);
  if (*a5 <= 0)
  {
    uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v15, 0, (const char **)&__s1, a3);
    if ((_DWORD)result)
    {
      int v9 = 0;
      uint64_t v10 = a1 + 16;
      while (2)
      {
        uint64_t v11 = 0LL;
        unint64_t v12 = __s1;
        while (((0x7FD2334uLL >> v11) & 1) != 0 || strcmp(v12, off_1897226D0[v11]))
        {
          if (++v11 == 29) {
            goto LABEL_11;
          }
        }

        if (!*(_BYTE *)(v10 + v11))
        {
          *(_BYTE *)(v10 + v11) = 1;
          unsigned int v13 = *(icu::UnicodeString **)(a1 + 8);
          int v19 = 0;
          uint64_t v18 = (*(uint64_t (**)(icu::ResourceValue *, int *, int *))(*(void *)a3 + 32LL))(a3, &v19, a5);
          icu::UnicodeString::UnicodeString(v20, 1LL, &v18);
          sub_1808C5F9C(v13, v11, v20, 1);
          uint64_t result = icu::UnicodeString::~UnicodeString(v14, (icu::UnicodeString *)v20);
          if (*a5 >= 1) {
            return result;
          }
        }

icu::UnicodeString *sub_1808C5F9C(icu::UnicodeString *result, unsigned int a2, UChar **a3, int a4)
{
  uint64_t v6 = result;
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a2 == 9)
  {
    *((_BYTE *)result + 2873) = 1;
    return icu::UnicodeString::operator=((UChar **)result + 8 * (unint64_t)a2 + 1, a3);
  }

  if (a2 == 8)
  {
    *((_BYTE *)result + 2872) = 1;
    return icu::UnicodeString::operator=((UChar **)result + 8 * (unint64_t)a2 + 1, a3);
  }

  if ((int)a2 <= 28)
  {
    uint64_t result = icu::UnicodeString::operator=((UChar **)result + 8 * (unint64_t)a2 + 1, a3);
    if (a2 == 4)
    {
      uint64_t result = (icu::UnicodeString *)icu::UnicodeString::char32At(v8, (icu::UnicodeString *)a3, 0);
      if (a4)
      {
        int v9 = (int)result;
        uint64_t result = (icu::UnicodeString *)u_charDigitValue((UChar32)result);
        if (!(_DWORD)result)
        {
          uint64_t result = (icu::UnicodeString *)icu::UnicodeString::countChar32((icu::UnicodeString *)a3, 0, 0x7FFFFFFF);
          if ((_DWORD)result == 1)
          {
            uint64_t v10 = 0LL;
            *((_DWORD *)v6 + 482) = v9;
            uint64_t v11 = (icu::UnicodeString *)((char *)v6 + 1160);
            int v12 = v9 + 1;
            do
            {
              icu::UnicodeString::UnicodeString((uint64_t)v14, v12 + v10);
              icu::UnicodeString::operator=(v11, (icu::UnicodeString *)v14);
              uint64_t result = (icu::UnicodeString *)icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v14);
              uint64_t v11 = (icu::UnicodeString *)((char *)v11 + 64);
              ++v10;
            }

            while (v10 != 9);
            return result;
          }
        }
      }
    }

    else if (a2 - 18 > 8)
    {
      return result;
    }

    *((_DWORD *)v6 + 482) = -1;
  }

  return result;
}

void sub_1808C6110(icu::ResourceSink *a1)
{
}

uint64_t sub_1808C6124(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  v31[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t v27 = 0LL;
  __s1 = a2;
  memset(v26, 0, sizeof(v26));
  (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))(v26, a3, a5);
  uint64_t result = icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v26, 0, (const char **)&__s1, a3);
  if ((_DWORD)result)
  {
    int v9 = 0;
    do
    {
      uint64_t v10 = __s1;
      int v11 = strcmp(__s1, "beforeCurrency");
      if (v11)
      {
        if (strcmp(v10, "afterCurrency")) {
          goto LABEL_26;
        }
        *(_BYTE *)(a1 + 17) = 1;
      }

      else
      {
        *(_BYTE *)(a1 + 16) = 1;
      }

      uint64_t v25 = 0LL;
      memset(v24, 0, sizeof(v24));
      (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))(v24, a3, a5);
      if (icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v24, 0, (const char **)&__s1, a3))
      {
        unsigned int v12 = 1;
        while (1)
        {
          unsigned int v13 = __s1;
          if (!strcmp(__s1, "currencyMatch")) {
            break;
          }
          if (!strcmp(v13, "surroundingMatch"))
          {
            uint64_t v14 = 1LL;
LABEL_15:
            uint64_t v15 = *(void *)(a1 + 8);
            if (*a5 < 1)
            {
              uint64_t v17 = v15 + (v14 << 6);
              if (v11) {
                uint64_t v16 = v17 + 2680;
              }
              else {
                uint64_t v16 = v17 + 2488;
              }
            }

            else
            {
              uint64_t v16 = v15 + 1864;
            }

            if (*(unsigned __int16 *)(v16 + 8) <= 0x1Fu)
            {
              int v30 = 0;
              uint64_t v29 = (*(uint64_t (**)(icu::ResourceValue *, int *, int *))(*(void *)a3 + 32LL))(a3, &v30, a5);
              icu::UnicodeString::UnicodeString(v31, 1LL, &v29);
              uint64_t v18 = v15 + (v14 << 6);
              int v19 = (UChar **)(v18 + 2680);
              __int128 v20 = (UChar **)(v18 + 2488);
              if (v11) {
                __int128 v21 = v19;
              }
              else {
                __int128 v21 = v20;
              }
              icu::UnicodeString::operator=(v21, v31);
              icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v31);
            }

            goto LABEL_25;
          }

          if (!strcmp(v13, "insertBetween"))
          {
            uint64_t v14 = 2LL;
            goto LABEL_15;
          }

uint64_t uprv_decContextClearStatus(uint64_t result, int a2)
{
  *(_DWORD *)(result + 20) &= ~a2;
  return result;
}

uint64_t uprv_decContextDefault(uint64_t result, int a2)
{
  *(_OWORD *)uint64_t result = xmmword_180A37080;
  *(void *)(result + 16) = 8927LL;
  *(_BYTE *)(result + 24) = 0;
  HIDWORD(v2) = a2;
  LODWORD(v2) = a2;
  switch((v2 >> 5))
  {
    case 0u:
      return result;
    case 1u:
      __int128 v3 = xmmword_180A370B0;
      goto LABEL_6;
    case 2u:
      __int128 v3 = xmmword_180A370A0;
      goto LABEL_6;
    case 4u:
      __int128 v3 = xmmword_180A37090;
LABEL_6:
      *(_OWORD *)uint64_t result = v3;
      *(_DWORD *)(result + 16) = 0;
      *(_BYTE *)(result + 24) = 1;
      break;
    default:
      *(_DWORD *)(result + 20) = 128;
      break;
  }

  return result;
}

uint64_t uprv_decContextSetStatus(uint64_t result, int a2)
{
  *(_DWORD *)(result + 20) |= a2;
  return result;
}

uint64_t uprv_decContextGetRounding(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t uprv_decContextGetStatus(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t uprv_decContextRestoreStatus(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(result + 20) = *(_DWORD *)(result + 20) & ~a3 | a3 & a2;
  return result;
}

uint64_t uprv_decContextSaveStatus(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 20) & a2;
}

uint64_t uprv_decContextSetRounding(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t uprv_decContextSetStatusFromString(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "Conversion syntax"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 1;
LABEL_30:
    *(_DWORD *)(a1 + 20) = v4;
    return a1;
  }

  if (!strcmp(__s1, "Division by zero"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 2;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Division impossible"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 4;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Division undefined"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 8;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Inexact"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x20;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Insufficient storage"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x10;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Invalid context"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x40;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Invalid operation"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x80;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Overflow"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x200;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Clamped"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x400;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Rounded"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x800;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Subnormal"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x1000;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Underflow"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x2000;
    goto LABEL_30;
  }

  if (strcmp(__s1, "No status")) {
    return 0LL;
  }
  return a1;
}

uint64_t uprv_decContextSetStatusFromStringQuiet(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "Conversion syntax"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 1;
LABEL_30:
    *(_DWORD *)(a1 + 20) = v4;
    return a1;
  }

  if (!strcmp(__s1, "Division by zero"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 2;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Division impossible"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 4;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Division undefined"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 8;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Inexact"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x20;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Insufficient storage"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x10;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Invalid context"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x40;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Invalid operation"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x80;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Overflow"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x200;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Clamped"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x400;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Rounded"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x800;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Subnormal"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x1000;
    goto LABEL_30;
  }

  if (!strcmp(__s1, "Underflow"))
  {
    int v4 = *(_DWORD *)(a1 + 20) | 0x2000;
    goto LABEL_30;
  }

  if (strcmp(__s1, "No status")) {
    return 0LL;
  }
  return a1;
}

uint64_t uprv_decContextSetStatusQuiet(uint64_t result, int a2)
{
  *(_DWORD *)(result + 20) |= a2;
  return result;
}

const char *uprv_decContextStatusToString(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if (v1 > 63)
  {
    if (v1 <= 1023)
    {
      switch(v1)
      {
        case 64:
          return "Invalid context";
        case 128:
          return "Invalid operation";
        case 512:
          return "Overflow";
      }
    }

    else if (v1 > 4095)
    {
      if (v1 == 4096) {
        return "Subnormal";
      }
      if (v1 == 0x2000) {
        return "Underflow";
      }
    }

    else
    {
      if (v1 == 1024) {
        return "Clamped";
      }
      if (v1 == 2048) {
        return "Rounded";
      }
    }

    return "Multiple status";
  }

  switch(v1)
  {
    case 0:
      return "No status";
    case 1:
      return "Conversion syntax";
    case 2:
      return "Division by zero";
    case 3:
    case 5:
    case 6:
    case 7:
      return "Multiple status";
    case 4:
      return "Division impossible";
    case 8:
      return "Division undefined";
    default:
      if (v1 == 16)
      {
        uint64_t result = "Insufficient storage";
      }

      else
      {
        if (v1 != 32) {
          return "Multiple status";
        }
        uint64_t result = "Inexact";
      }

      break;
  }

  return result;
}

BOOL uprv_decContextTestSavedStatus(int a1, int a2)
{
  return (a2 & a1) != 0;
}

BOOL uprv_decContextTestStatus(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 20) & a2) != 0;
}

uint64_t uprv_decContextZeroStatus(uint64_t result)
{
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t uprv_decNumberFromInt32(uint64_t a1, signed int a2)
{
  signed int v2 = a2;
  if (a2 < 0) {
    a2 = -a2;
  }
  uint64_t result = uprv_decNumberFromUInt32(a1, a2);
  if (v2 < 0) {
    *(_BYTE *)(result + 8) = 0x80;
  }
  return result;
}

uint64_t uprv_decNumberFromUInt32(uint64_t result, unsigned int a2)
{
  *(_WORD *)(result + 8) = 0;
  *(void *)uint64_t result = 1LL;
  if (a2)
  {
    uint64_t v2 = 0LL;
    unint64_t v3 = result + 9;
    do
    {
      *(_BYTE *)(result + v2++ + 9) = a2 % 0xA;
      BOOL v4 = a2 > 9;
      a2 /= 0xAu;
    }

    while (v4);
    if ((int)v2 > 0)
    {
      uint64_t v5 = (_BYTE *)(v3 + (v2 - 1));
      do
      {
        if (*v5) {
          BOOL v6 = 1;
        }
        else {
          BOOL v6 = (_DWORD)v2 == 1;
        }
        if (v6) {
          break;
        }
        LODWORD(v2) = v2 - 1;
        --v5;
      }

      while ((unint64_t)v5 >= v3);
    }

    *(_DWORD *)uint64_t result = v2;
  }

  return result;
}

double uprv_decNumberZero(uint64_t a1)
{
  *(_WORD *)(a1 + 8) = 0;
  *(void *)&double result = 1LL;
  *(void *)a1 = 1LL;
  return result;
}

uint64_t uprv_decNumberToInt32(unsigned int *a1, uint64_t a2)
{
  if ((a1[2] & 0x70) != 0) {
    goto LABEL_4;
  }
  uint64_t v2 = *a1;
  unsigned int v4 = *((unsigned __int8 *)a1 + 9);
  if ((int)v2 < 2)
  {
    unsigned int v5 = 0;
  }

  else
  {
    unsigned int v5 = 0;
    BOOL v6 = (unsigned __int8 *)a1 + 10;
    uint64_t v7 = v2 - 1;
    uint64_t v8 = dword_180A37120;
    do
    {
      int v10 = *v6++;
      int v9 = v10;
      int v11 = *v8++;
      v5 += v11 * v9;
      --v7;
    }

    while (v7);
    if (v5 > 0xCCCCCCC)
    {
LABEL_4:
      uprv_decContextSetStatus(a2, 128);
      return 0LL;
    }

    if (v5 == 214748364 && v4 >= 8)
    {
      if ((a1[2] & 0x80) != 0 && v4 == 8) {
        return 0x80000000LL;
      }
      goto LABEL_4;
    }
  }

  unsigned int v13 = v4 + 10 * v5;
  else {
    return -v13;
  }
}

uint64_t uprv_decNumberToUInt32(unsigned int *a1, uint64_t a2)
{
  if ((a1[2] & 0x70) != 0) {
    goto LABEL_4;
  }
  uint64_t v2 = *a1;
  unsigned int v4 = *((unsigned __int8 *)a1 + 9);
  if ((a1[2] & 0x80) == 0)
  {
    if ((int)v2 >= 2)
    {
      unsigned int v5 = 0;
      BOOL v6 = (unsigned __int8 *)a1 + 10;
      uint64_t v7 = v2 - 1;
      uint64_t v8 = dword_180A37120;
      do
      {
        int v10 = *v6++;
        int v9 = v10;
        int v11 = *v8++;
        v5 += v11 * v9;
        --v7;
      }

      while (v7);
      if (v5 > 0x19999999) {
        goto LABEL_4;
      }
      if (v5 == 429496729 && v4 > 5) {
        goto LABEL_4;
      }
      return v4 + 10 * v5;
    }

_BYTE *uprv_decNumberToString(unint64_t a1, _BYTE *a2)
{
  return a2;
}

unint64_t sub_1808C6BF8(unint64_t result, _BYTE *a2, int a3)
{
  unint64_t v3 = a2;
  unsigned int v4 = *(_DWORD *)result;
  int v5 = *(_DWORD *)(result + 4);
  int v6 = *(char *)(result + 8);
  if (v6 < 0)
  {
    *a2 = 45;
    unint64_t v3 = a2 + 1;
    LOBYTE(v6) = *(_BYTE *)(result + 8);
  }

  if ((v6 & 0x70) == 0)
  {
    int v7 = *(_DWORD *)result;
    goto LABEL_14;
  }

  if ((v6 & 0x40) != 0)
  {
    *(_DWORD *)unint64_t v3 = 6712905;
    strcpy(v3 + 3, "inity");
    return result;
  }

  if ((v6 & 0x10) != 0) {
    *v3++ = 115;
  }
  *(_DWORD *)unint64_t v3 = 5136718;
  if (!v5)
  {
    v3 += 3;
    int v7 = *(_DWORD *)result;
    if (*(_BYTE *)(result + 9) || v7 != 1)
    {
LABEL_14:
      uint64_t v8 = (unsigned __int8 *)(result + 9);
      int v9 = (unsigned __int8 *)(result + 9 + v4 - 1);
      int v10 = v7;
      if (v7 <= 49) {
        int v10 = byte_180A37148[v7];
      }
      unsigned int v11 = v7 - v10;
      if (!v5)
      {
        for (; v9 >= v8; --v9)
        {
          if ((v11 & 0x80000000) == 0)
          {
            unsigned int v31 = *v9;
            uint64_t v32 = v11;
            do
            {
              int v33 = 48;
              *unint64_t v3 = 48;
              int v34 = dword_180A37120[v32];
              if (v31 <= 2 * v34)
              {
                unsigned int v39 = 2 * v34;
              }

              else
              {
                unsigned int v35 = 8 * v34;
                if (v31 < 8 * v34) {
                  int v33 = 48;
                }
                else {
                  int v33 = 56;
                }
                if (v31 < 8 * v34) {
                  int v36 = 0;
                }
                else {
                  int v36 = 8 * v34;
                }
                unsigned int v37 = v31 - v36;
                double result = 4 * (v34 & 0x1FFFFFFFu);
                if (v37 < v35 >> 1)
                {
                  int v38 = 0;
                }

                else
                {
                  v33 |= 4u;
                  int v38 = 4 * (v34 & 0x1FFFFFFF);
                }

                unsigned int v31 = v37 - v38;
                unsigned int v39 = v35 >> 2;
              }

              if (v31 < v39) {
                unsigned int v40 = 0;
              }
              else {
                unsigned int v40 = v39;
              }
              unsigned int v41 = v31 - v40;
              unsigned int v42 = v39 >> 1;
              if (v41 < v39 >> 1) {
                unsigned int v43 = 0;
              }
              else {
                unsigned int v43 = v39 >> 1;
              }
              if (v31 >= v39 || v41 >= v42)
              {
                double result = (v33 + 2);
                if (v31 < v39) {
                  char v45 = v33;
                }
                else {
                  char v45 = v33 + 2;
                }
                if (v41 >= v42) {
                  ++v45;
                }
                *unint64_t v3 = v45;
              }

              unsigned int v31 = v41 - v43;
              ++v3;
            }

            while (v32-- > 0);
          }

          unsigned int v11 = 0;
        }

        *unint64_t v3 = 0;
        return result;
      }

      int v12 = v7 + v5;
      if (v5 <= 0 && v12 > -6)
      {
        unsigned int v13 = 0;
        int v14 = v7 + v5;
        goto LABEL_20;
      }

      unsigned int v13 = v12 - 1;
      int v14 = 1;
      if (a3 && v12 != 1)
      {
        unsigned int v47 = ((1 - v12) % 3u) ^ 3;
        if (!((1 - v12) % 3u)) {
          unsigned int v47 = 0;
        }
        if (v12 > 0) {
          unsigned int v47 = v13 % 3;
        }
        v13 -= v47;
        if (v7 != 1 || *v8 || (*(_BYTE *)(result + 8) & 0x70) != 0)
        {
          int v14 = v47 + 1;
        }

        else
        {
          if (v47)
          {
            v13 += 3;
            int v14 = v47 - 2;
LABEL_20:
            unsigned int v15 = *v9;
            if (v14 < 1)
            {
              *(_WORD *)unint64_t v3 = 11824;
              uint64_t v16 = v3 + 2;
              if (v14 < 0)
              {
                uint64_t v17 = ~v14;
                double result = (unint64_t)memset(v3 + 2, 48, v17 + 1);
                uint64_t v16 = &v3[v17 + 3];
              }

              if ((v11 & 0x80000000) == 0) {
                goto LABEL_26;
              }
              while (v9 != v8)
              {
                unsigned int v11 = 0;
                unsigned int v18 = *--v9;
                unsigned int v15 = v18;
                do
                {
LABEL_26:
                  char v19 = 48;
                  *uint64_t v16 = 48;
                  int v20 = dword_180A37120[v11];
                  if (v15 <= 2 * v20)
                  {
                    unsigned int v25 = 2 * v20;
                  }

                  else
                  {
                    unsigned int v21 = 8 * v20;
                    if (v15 < 8 * v20) {
                      char v19 = 48;
                    }
                    else {
                      char v19 = 56;
                    }
                    if (v15 < 8 * v20) {
                      int v22 = 0;
                    }
                    else {
                      int v22 = 8 * v20;
                    }
                    unsigned int v23 = v15 - v22;
                    if (v23 < v21 >> 1)
                    {
                      int v24 = 0;
                    }

                    else
                    {
                      v19 |= 4u;
                      int v24 = 4 * (v20 & 0x1FFFFFFF);
                    }

                    if (v15 >= 8 * v20 || v23 >= 4 * (v20 & 0x1FFFFFFFu)) {
                      *uint64_t v16 = v19;
                    }
                    unsigned int v15 = v23 - v24;
                    unsigned int v25 = v21 >> 2;
                  }

                  if (v15 < v25) {
                    unsigned int v26 = 0;
                  }
                  else {
                    unsigned int v26 = v25;
                  }
                  unsigned int v27 = v15 - v26;
                  unsigned int v28 = v25 >> 1;
                  if (v27 < v25 >> 1) {
                    unsigned int v29 = 0;
                  }
                  else {
                    unsigned int v29 = v25 >> 1;
                  }
                  if (v15 >= v25 || v27 >= v28)
                  {
                    if (v15 >= v25) {
                      v19 += 2;
                    }
                    if (v27 >= v28) {
                      ++v19;
                    }
                    *uint64_t v16 = v19;
                  }

                  unsigned int v15 = v27 - v29;
                  ++v16;
                  --v11;
                }

                while ((v11 & 0x80000000) == 0);
              }

              goto LABEL_187;
            }

            goto LABEL_110;
          }

          int v14 = 1;
        }
      }

      unsigned int v15 = *v9;
LABEL_110:
      uint64_t v48 = 0LL;
      uint64_t v49 = 1LL;
      while (1)
      {
        if ((v11 & 0x80000000) != 0)
        {
          if (v9 == v8)
          {
            uint64_t v16 = &v3[v48];
            if (v14 >= *(_DWORD *)result)
            {
              size_t v76 = v14 - v48;
              double result = (unint64_t)memset(v16, 48, v76);
              v16 += v76;
              goto LABEL_187;
            }

            int v9 = (unsigned __int8 *)(result + 9);
LABEL_150:
            *v16++ = 46;
            if ((v11 & 0x80000000) == 0) {
              goto LABEL_153;
            }
            while (v9 != v8)
            {
              unsigned int v11 = 0;
              unsigned int v63 = *--v9;
              unsigned int v15 = v63;
              do
              {
LABEL_153:
                char v64 = 48;
                *uint64_t v16 = 48;
                int v65 = dword_180A37120[v11];
                if (v15 <= 2 * v65)
                {
                  unsigned int v70 = 2 * v65;
                }

                else
                {
                  unsigned int v66 = 8 * v65;
                  if (v15 < 8 * v65) {
                    char v64 = 48;
                  }
                  else {
                    char v64 = 56;
                  }
                  if (v15 < 8 * v65) {
                    int v67 = 0;
                  }
                  else {
                    int v67 = 8 * v65;
                  }
                  unsigned int v68 = v15 - v67;
                  if (v68 < v66 >> 1)
                  {
                    int v69 = 0;
                  }

                  else
                  {
                    v64 |= 4u;
                    int v69 = 4 * (v65 & 0x1FFFFFFF);
                  }

                  if (v15 >= 8 * v65 || v68 >= 4 * (v65 & 0x1FFFFFFFu)) {
                    *uint64_t v16 = v64;
                  }
                  unsigned int v15 = v68 - v69;
                  unsigned int v70 = v66 >> 2;
                }

                if (v15 < v70) {
                  unsigned int v71 = 0;
                }
                else {
                  unsigned int v71 = v70;
                }
                unsigned int v72 = v15 - v71;
                unsigned int v73 = v70 >> 1;
                if (v72 < v70 >> 1) {
                  unsigned int v74 = 0;
                }
                else {
                  unsigned int v74 = v70 >> 1;
                }
                if (v15 >= v70 || v72 >= v73)
                {
                  if (v15 >= v70) {
                    v64 += 2;
                  }
                  if (v72 >= v73) {
                    ++v64;
                  }
                  *uint64_t v16 = v64;
                }

                unsigned int v15 = v72 - v74;
                --v11;
                ++v16;
              }

              while ((v11 & 0x80000000) == 0);
            }

_BYTE *uprv_decNumberToEngString(unint64_t a1, _BYTE *a2)
{
  return a2;
}

uint64_t uprv_decNumberFromString(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5 = 0LL;
  char v6 = 0;
  int v7 = 0u;
  uint64_t v8 = 0LL;
  int v9 = 0LL;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  int v48 = 0;
  uint64_t j = a2;
  while (1)
  {
    unsigned int v11 = &a2[v5];
    int v12 = a2[v5];
    if ((v12 - 48) <= 9)
    {
      ++v7;
      goto LABEL_17;
    }

    if (v12 != 46 || v8 != 0LL) {
      break;
    }
    if (v11 == j) {
      ++j;
    }
    uint64_t v8 = &a2[v5];
LABEL_16:
    unsigned int v11 = v9;
LABEL_17:
    ++v5;
    int v9 = v11;
  }

  if (!v5)
  {
    if (v12 == 43)
    {
      ++j;
    }

    else
    {
      if (v12 != 45) {
        goto LABEL_19;
      }
      ++j;
      char v6 = 0x80;
    }

    goto LABEL_16;
  }

  a2 += v5;
LABEL_19:
  memset(v50, 0, 45);
  int v49 = 0;
  if (v9)
  {
    if (!v12)
    {
      int v28 = 0;
      goto LABEL_56;
    }

    int v14 = 1;
    int v48 = 1;
    if ((v12 | 0x20) != 0x65) {
      goto LABEL_98;
    }
    uint64_t v16 = a2 + 1;
    int v15 = a2[1];
    BOOL v17 = v15 == 45 || v15 == 43;
    uint64_t v18 = 1LL;
    if (v17)
    {
      uint64_t v18 = 2LL;
      uint64_t v16 = a2 + 2;
    }

    int v19 = a2[v18];
    if (v19)
    {
      int v20 = v16 + 1;
      do
      {
        char v21 = v19;
        int v22 = v20;
        if (v19 != 48) {
          break;
        }
        ++v20;
        int v19 = *v22;
      }

      while (*v22);
      int v23 = *(v22 - 1);
      if ((v23 - 58) >= 0xFFFFFFF6)
      {
        int v25 = 0;
        uint64_t v29 = 0LL;
        do
        {
          int v25 = v23 + 10 * v25 - 48;
          unint64_t v24 = v29 + 1;
          int v23 = v22[v29++];
        }

        while ((v23 - 58) > 0xFFFFFFF5);
      }

      else
      {
        unint64_t v24 = 0LL;
        int v25 = 0;
      }

      if (!v23)
      {
        if (v24 == 10 && v21 <= 49) {
          int v31 = v25;
        }
        else {
          int v31 = 1999999998;
        }
        if (v24 < 0xA) {
          int v31 = v25;
        }
        if (v15 == 45) {
          int v28 = -v31;
        }
        else {
          int v28 = v31;
        }
LABEL_55:
        int v48 = 0;
LABEL_56:
        if (*j == 48 && j < v9)
        {
          int64_t v32 = v9 - j;
          do
          {
            int v33 = *j;
            if (v33 != 46)
            {
              if (v33 != 48) {
                goto LABEL_64;
              }
              --v7;
            }

            ++j;
            --v32;
          }

          while (v32);
          uint64_t j = v9;
        }

_BYTE *sub_1808C77A4(_BYTE *result, int *a2, char *a3, int a4, int *a5, int *a6)
{
  int v6 = *a2;
  int v7 = a4 - *a2;
  if (v7 >= 1)
  {
    *((_DWORD *)result + 1) += v7;
    *a6 |= 0x800u;
    int v8 = *a5;
    if (*a5 <= 1)
    {
      if (v6 < 0)
      {
        if (v8 <= 0)
        {
          if (a4 < 1)
          {
LABEL_51:
            if (!v8) {
              goto LABEL_34;
            }
          }

          else
          {
            int v35 = a4 + 1;
            while (!*a3)
            {
              ++a3;
              if (--v35 <= 1) {
                goto LABEL_51;
              }
            }

            *a5 = 1;
          }
        }

void sub_1808C7A24(unsigned int *a1, uint64_t a2, int *a3, int *a4)
{
  int v8 = *(_DWORD *)(a2 + 8);
  signed int v9 = a1[1];
  signed int v10 = v8 - *a1;
  if (v9 <= v10 + 1)
  {
    int v20 = 0;
    if (v9 > v10)
    {
      BYTE1(v20) = 1;
      v19[0] = 1;
      v19[1] = v8;
      int v17 = sub_1808CBAB4((uint64_t)a1, (uint64_t)v19, 1);
      if (v17 == 0x80000000)
      {
        int v18 = *a4 | 0x10;
LABEL_17:
        *a4 = v18;
        return;
      }

      int v11 = *a3;
      if (v17 || (v11 & 0x80000000) == 0) {
        goto LABEL_3;
      }
      sub_1808CE50C((uint64_t)a1, (_DWORD *)a2, v11, a4);
    }

    sub_1808CE910(a1, a2, a3, a4);
    return;
  }

  int v11 = *a3;
LABEL_3:
  if (v11) {
    sub_1808CE50C((uint64_t)a1, (_DWORD *)a2, v11, a4);
  }
  int v12 = a1[1];
  int v13 = *(_DWORD *)(a2 + 4);
  int v14 = v13 - *(_DWORD *)a2 + 1;
  int v15 = v12 - v14;
  if (v12 > v14)
  {
    uint64_t v16 = *a1;
    if (v12 > v13 - (int)v16 + 1)
    {
      sub_1808CE830(a1, a2, a4);
      return;
    }

    if (*(_BYTE *)(a2 + 24))
    {
      if ((_DWORD)v16 != 1 || *((_BYTE *)a1 + 9) || (a1[2] & 0x70) != 0)
      {
        *a1 = sub_1808CC550((_BYTE *)a1 + 9, v16, v12 - v14);
        int v12 = a1[1];
      }

      a1[1] = v12 - v15;
      int v18 = *a4 | 0x400;
      goto LABEL_17;
    }
  }

uint64_t sub_1808C7B8C(uint64_t a1, int a2, uint64_t a3)
{
  if ((a2 & 0xDD) != 0)
  {
    if ((a2 & 0x40000000) != 0)
    {
      a2 &= ~0x40000000u;
    }

    else
    {
      *(void *)a1 = 1LL;
      *(_WORD *)(a1 + 8) = 32;
    }
  }

  return uprv_decContextSetStatus(a3, a2);
}

int *uprv_decNumberAbs(int *a1, uint64_t a2, int *a3)
{
  v8[2] = 0;
  int v5 = *(_DWORD *)(a2 + 4);
  int v7 = 0;
  v8[0] = 1;
  v8[1] = v5;
  sub_1808C7C34(a1, v8, a2, a3, *(_BYTE *)(a2 + 8) & 0x80, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, (uint64_t)a3);
  }
  return a1;
}

int *sub_1808C7C34(int *a1, int *a2, uint64_t a3, int *a4, char a5, int *a6)
{
  int v8 = (int *)a3;
  signed int v9 = a2;
  uint64_t v71 = *MEMORY[0x1895F89C0];
  unsigned __int8 v11 = *((_BYTE *)a2 + 8);
  unsigned __int8 v12 = *(_BYTE *)(a3 + 8);
  unsigned __int8 v13 = v12 ^ a5;
  char v14 = v12 ^ a5 ^ v11;
  if (((v12 | v11) & 0x70) != 0)
  {
    if (((v12 | v11) & 0x30) != 0)
    {
      sub_1808CB138((uint64_t)a1, (uint64_t)a2, a3, a4, a6);
      return a1;
    }

    if ((a2[2] & 0x40) == 0
      || (unsigned __int8 v13 = *((_BYTE *)a2 + 8), (*(_BYTE *)(a3 + 8) & 0x40) == 0)
      || (((v12 ^ a5) ^ v11) & 0x80) == 0)
    {
      *(void *)a1 = 1LL;
      *((_WORD *)a1 + 4) = v13 & 0x80 | 0x40;
      return a1;
    }

    int v37 = *a6 | 0x80;
LABEL_111:
    *a6 = v37;
    return a1;
  }

  int v16 = *a4;
  int v69 = 0;
  memset(v70, 0, 92);
  int v17 = *((unsigned __int8 *)a2 + 9);
  if (!*((_BYTE *)a2 + 9) && (v11 & 0x70) == 0 && *a2 == 1)
  {
    char v31 = v13 ^ v11;
    int v32 = a2[1];
    int v69 = 0;
    *((_BYTE *)a1 + 8) = v12;
    a1[1] = *(_DWORD *)(a3 + 4);
    sub_1808C77A4(a1, a4, (char *)(a3 + 9), *(_DWORD *)a3, &v69, a6);
    char v33 = *((_BYTE *)a1 + 8) ^ a5;
    *((_BYTE *)a1 + 8) = v33;
    int v34 = v32 - a1[1];
    int v35 = (char *)a1 + 9;
    if (!*((_BYTE *)a1 + 9) && *a1 == 1 && (v33 & 0x70) == 0)
    {
      if (v34 < 0) {
        a1[1] = v32;
      }
      if ((v31 & 0x80) == 0) {
        goto LABEL_42;
      }
      if (a4[3] != 6)
      {
        *((_BYTE *)a1 + 8) = 0;
        goto LABEL_42;
      }

      char v30 = 0x80;
      goto LABEL_23;
    }

    if ((v34 & 0x80000000) == 0) {
      goto LABEL_42;
    }
    uint64_t v36 = *a1;
    if ((int)v36 - v34 > *a4)
    {
      int v34 = v36 - *a4;
      *a6 |= 0x800u;
      uint64_t v36 = *a1;
    }

int *uprv_decNumberAdd(int *a1, int *a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C7C34(a1, a2, a3, a4, 0, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberAnd(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (*(_DWORD *)(a2 + 4)
    || *(unsigned __int8 *)(a2 + 8) > 0xFu
    || *(_DWORD *)(a3 + 4)
    || *(unsigned __int8 *)(a3 + 8) >= 0x10u)
  {
LABEL_31:
    *(void *)a1 = 1LL;
    *(_WORD *)(a1 + 8) = 32;
    uprv_decContextSetStatus((uint64_t)a4, 128);
    return a1;
  }

  unsigned int v5 = *(_DWORD *)a2;
  unsigned int v6 = *(_DWORD *)a3;
  unint64_t v7 = a1 + 9;
  unsigned int v8 = *a4;
  unint64_t v9 = v7 + v8 - 1;
  int v10 = a1 + 9;
  if (v7 <= v9)
  {
    unint64_t v11 = a2 + 9 + v5 - 1;
    unint64_t v12 = a3 + 9 + v6 - 1;
    uint64_t v13 = 9LL;
    do
    {
      unsigned int v14 = a2 + v13 <= v11 ? *(unsigned __int8 *)(a2 + v13) : 0;
      unsigned int v15 = a3 + v13 <= v12 ? *(unsigned __int8 *)(a3 + v13) : 0;
      *(_BYTE *)(a1 + v13) = 0;
      if (v15 | v14)
      {
        *(_BYTE *)(a1 + v13) = v14 & v15 & 1;
      }

      int v10 = a1 + ++v13;
    }

    while (a1 + v13 <= v9);
  }

  int v16 = v10 - v7;
  if (v10 - (int)v7 >= 1)
  {
    int v17 = (_BYTE *)(v7 + (v16 - 1));
    int v18 = v10 - a1 - 10;
    do
    {
      if (*v17) {
        BOOL v19 = 1;
      }
      else {
        BOOL v19 = v18 == 0;
      }
      if (v19) {
        break;
      }
      --v17;
      --v18;
    }

    while ((unint64_t)v17 >= v7);
    int v16 = v18 + 1;
  }

  *(_DWORD *)a1 = v16;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  return a1;
}

uint64_t uprv_decNumberCompare(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 1, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t sub_1808C8568(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int a5, int *a6)
{
  unsigned __int8 v12 = *(_BYTE *)(a2 + 8);
  if (a5 == 4)
  {
    unsigned __int8 v13 = *(_BYTE *)(a3 + 8);
    if ((*(_BYTE *)(a2 + 8) & 0x80) != 0)
    {
      if ((*(_BYTE *)(a3 + 8) & 0x80) == 0)
      {
        int v14 = -1;
LABEL_63:
        *(_BYTE *)(a1 + 8) = 0;
        int v20 = (_BYTE *)(a1 + 8);
        *(void *)a1 = 1LL;
        int v21 = (_BYTE *)(a1 + 9);
LABEL_64:
        *int v21 = 1;
        if (v14 < 0) {
          *int v20 = 0x80;
        }
        return a1;
      }
    }

    else if ((*(_BYTE *)(a3 + 8) & 0x80) != 0)
    {
      int v14 = 1;
      goto LABEL_63;
    }
  }

  else
  {
    unsigned __int8 v13 = *(_BYTE *)(a3 + 8);
  }

  if (((v13 | v12) & 0x30) == 0)
  {
    int v14 = sub_1808CBAB4(a2, a3, (a5 - 7) < 2);
    if (v14 == 0x80000000)
    {
      *a6 |= 0x10u;
      return a1;
    }

    goto LABEL_39;
  }

  if (a5 == 1)
  {
LABEL_10:
    sub_1808CB138(a1, a2, a3, a4, a6);
    return a1;
  }

  if (a5 == 6)
  {
    *a6 |= 0x40000080u;
    goto LABEL_10;
  }

  if (a5 != 4)
  {
    if (((v13 | v12) & 0x10) == 0 && ((*(_BYTE *)(a2 + 8) & 0x30) == 0 || (v13 & 0x30) == 0))
    {
      if ((*(_BYTE *)(a2 + 8) & 0x20) != 0) {
        int v14 = -1;
      }
      else {
        int v14 = 1;
      }
      int v36 = 0;
LABEL_72:
      if (v14 <= 0) {
        uint64_t v28 = a3;
      }
      else {
        uint64_t v28 = a2;
      }
      *(_BYTE *)(a1 + 8) = *(_BYTE *)(v28 + 8);
      int v29 = *(_DWORD *)v28;
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v28 + 4);
      sub_1808C77A4((_BYTE *)a1, a4, (char *)(v28 + 9), v29, &v36, a6);
      sub_1808C7A24((unsigned int *)a1, (uint64_t)a4, &v36, a6);
      return a1;
    }

    goto LABEL_10;
  }

  if ((*(_BYTE *)(a2 + 8) & 0x30) == 0)
  {
LABEL_20:
    int v15 = -1;
    goto LABEL_36;
  }

  if ((v13 & 0x30) != 0)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x10) != 0 && (v13 & 0x20) != 0) {
      goto LABEL_20;
    }
    if ((*(_BYTE *)(a2 + 8) & 0x20) == 0 || (v13 & 0x10) == 0)
    {
      unsigned int v16 = *(_DWORD *)a2;
      unsigned int v17 = *(_DWORD *)a3;
      if (v16 <= v17)
      {
        if (v16 >= v17)
        {
          uint64_t v31 = v16 + 8LL;
          int v32 = (unsigned __int8 *)(a2 + v31);
          char v33 = (unsigned __int8 *)(a3 + v31);
          int v15 = -1;
          while ((unint64_t)v32 >= a2 + 9)
          {
            unsigned int v34 = *v32;
            unsigned int v35 = *v33;
            if (v34 > v35) {
              goto LABEL_35;
            }
            --v32;
            --v33;
            if (v34 < v35) {
              goto LABEL_36;
            }
          }

          int v15 = 0;
          goto LABEL_36;
        }

        goto LABEL_20;
      }
    }
  }

uint64_t uprv_decNumberCompareSignal(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 6, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberCompareTotal(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 4, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberCompareTotalMag(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  unsigned int v6 = (unsigned int *)a2;
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v18 = 0;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  if ((*(char *)(a2 + 8) & 0x80000000) == 0)
  {
    unsigned int v8 = 0LL;
    goto LABEL_10;
  }

  int v9 = *(_DWORD *)a2;
  if ((unint64_t)(v9 - 38LL) <= 0xB)
  {
    int v9 = byte_180A37148[v9];
LABEL_6:
    int v10 = uprv_malloc((v9 + 11));
    unsigned int v8 = v10;
    if (!v10)
    {
      int v11 = 16;
LABEL_25:
      sub_1808C7B8C(a1, v11, (uint64_t)a4);
      return a1;
    }

    goto LABEL_9;
  }

  unsigned int v8 = 0LL;
  int v10 = v20;
LABEL_9:
  uint64_t v12 = uprv_decNumberCopy((uint64_t)v10, v6);
  *(_BYTE *)(v12 + 8) &= ~0x80u;
  unsigned int v6 = (unsigned int *)v12;
LABEL_10:
  if ((*(char *)(a3 + 8) & 0x80000000) == 0)
  {
    unsigned __int8 v13 = 0LL;
    goto LABEL_20;
  }

  int v14 = *(_DWORD *)a3;
  if (*(int *)a3 <= 49)
  {
    if ((unint64_t)(v14 - 38LL) > 0xB)
    {
      unsigned __int8 v13 = 0LL;
      int v15 = v19;
      goto LABEL_19;
    }

    int v14 = byte_180A37148[v14];
  }

  int v15 = uprv_malloc((v14 + 11));
  unsigned __int8 v13 = v15;
  if (v15)
  {
LABEL_19:
    uint64_t v16 = uprv_decNumberCopy((uint64_t)v15, (unsigned int *)a3);
    *(_BYTE *)(v16 + 8) &= ~0x80u;
    a3 = v16;
LABEL_20:
    sub_1808C8568(a1, (uint64_t)v6, a3, a4, 4, &v18);
    if (!v8) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  int v18 = 16;
  if (v8) {
LABEL_21:
  }
    uprv_free(v8);
LABEL_22:
  if (v13) {
    uprv_free(v13);
  }
  int v11 = v18;
  if (v18) {
    goto LABEL_25;
  }
  return a1;
}

uint64_t uprv_decNumberCopy(uint64_t result, unsigned int *a2)
{
  if ((unsigned int *)result != a2)
  {
    *(_BYTE *)(result + 8) = *((_BYTE *)a2 + 8);
    *(void *)double result = *(void *)a2;
    *(_BYTE *)(result + 9) = *((_BYTE *)a2 + 9);
    uint64_t v2 = *a2;
    if ((int)v2 >= 2)
    {
      unint64_t v3 = (char *)a2 + 10;
      if ((char *)a2 + 10 < (char *)a2 + v2 + 9)
      {
        unsigned int v4 = (_BYTE *)(result + 10);
        uint64_t v5 = v2 - 1LL;
        do
        {
          char v6 = *v3++;
          *v4++ = v6;
          --v5;
        }

        while (v5);
      }
    }
  }

  return result;
}

uint64_t uprv_decNumberDivide(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8BD0(a1, a2, a3, a4, 128, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t sub_1808C8BD0(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int a5, int *a6)
{
  uint64_t v9 = a1;
  uint64_t v140 = *MEMORY[0x1895F89C0];
  memset(v139, 0, 47);
  memset(v138, 0, 73);
  int v137 = 0;
  unsigned __int8 v10 = *(_BYTE *)(a2 + 8);
  unsigned __int8 v11 = *(_BYTE *)(a3 + 8);
  char v12 = (v11 ^ v10) & 0x80;
  if (((v11 | v10) & 0x70) != 0)
  {
    if (((v11 | v10) & 0x30) != 0)
    {
      sub_1808CB138(a1, a2, a3, a4, a6);
      return v9;
    }

    if ((*(_BYTE *)(a2 + 8) & 0x40) == 0)
    {
      if ((a5 & 0x50) == 0)
      {
        *(void *)a1 = 1LL;
        *(_BYTE *)(a1 + 9) = 0;
        *(_BYTE *)(a1 + 8) = v12;
        if ((a5 & 0x80) != 0)
        {
          *(_DWORD *)(a1 + 4) = a4[2] - *a4 + 1;
          *a6 |= 0x400u;
        }

        goto LABEL_87;
      }

      *(_BYTE *)(a1 + 8) = v10;
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      char v24 = (char *)(a2 + 9);
      int v16 = *(_DWORD *)a2;
      int v25 = a4;
LABEL_18:
      sub_1808C77A4((_BYTE *)a1, v25, v24, v16, &v137, a6);
LABEL_87:
      BOOL v58 = (unsigned int *)v9;
LABEL_88:
      sub_1808C7A24(v58, (uint64_t)a4, &v137, a6);
      return v9;
    }

    if (!(a5 & 0x50 | v11 & 0x40))
    {
      *(void *)a1 = 1LL;
      *(_BYTE *)(a1 + 9) = 0;
      goto LABEL_26;
    }

    int v26 = *a6;
LABEL_63:
    int v48 = v26 | 0x80;
LABEL_164:
    *a6 = v48;
    return v9;
  }

  int v13 = *a4;
  int v14 = (unsigned __int8 *)(a3 + 9);
  if (!*(_BYTE *)(a3 + 9) && (*(_BYTE *)(a3 + 8) & 0x70) == 0 && *(_DWORD *)a3 == 1)
  {
    if (!*(_BYTE *)(a2 + 9) && (*(_BYTE *)(a2 + 8) & 0x70) == 0 && *(_DWORD *)a2 == 1)
    {
      *(_WORD *)(a1 + 8) = 0;
      *(void *)a1 = 1LL;
      int v48 = *a6 | 8;
      goto LABEL_164;
    }

    *(_WORD *)(a1 + 8) = 0;
    *(void *)a1 = 1LL;
    int v26 = *a6;
    if ((a5 & 0x50) == 0)
    {
      *a6 = v26 | 2;
LABEL_26:
      *(_BYTE *)(a1 + 8) = v12 | 0x40;
      return v9;
    }

    goto LABEL_63;
  }

  unint64_t v15 = a2 + 9;
  int v16 = *(_DWORD *)a2;
  if (!*(_BYTE *)(a2 + 9) && (*(_BYTE *)(a2 + 8) & 0x70) == 0 && v16 == 1)
  {
    if ((a5 & 0x80) != 0)
    {
      int v91 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a3 + 4);
      BOOL v58 = (unsigned int *)uprv_decNumberCopy(a1, (unsigned int *)a2);
      *(_BYTE *)(v9 + 8) = v12;
      *(_DWORD *)(v9 + 4) = v91;
      goto LABEL_88;
    }

    if ((a5 & 0x20) == 0)
    {
      int v27 = *(_DWORD *)(a3 + 4);
      uprv_decNumberCopy(a1, (unsigned int *)a2);
      if (v27 < *(_DWORD *)(v9 + 4)) {
        *(_DWORD *)(v9 + 4) = v27;
      }
      return v9;
    }

uint64_t uprv_decNumberDivideInteger(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8BD0(a1, a2, a3, a4, 32, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberExp(uint64_t a1, uint64_t a2, int *a3)
{
  int v7 = 0;
  if (!sub_1808C986C(a2, a3, &v7)) {
    sub_1808C9920(a1, a2, (uint64_t)a3, &v7);
  }
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a3);
  }
  return a1;
}

BOOL sub_1808C986C(uint64_t a1, int *a2, int *a3)
{
  int v3 = *a3;
  if (*a2 > 999999 || a2[1] > 999999 || a2[2] < -999999)
  {
    int v4 = 64;
    goto LABEL_5;
  }

  int v7 = *(_DWORD *)a1;
  if (*(int *)a1 > 999999)
  {
LABEL_8:
    int v4 = 128;
    goto LABEL_5;
  }

  if ((v7 - 1000001 + *(_DWORD *)(a1 + 4)) > 0xFFD23942)
  {
    int v5 = *a3;
    return v5 != v3;
  }

  int v4 = 128;
  if (v7 == 1 && !*(_BYTE *)(a1 + 9))
  {
    int v5 = *a3;
    if ((*(_BYTE *)(a1 + 8) & 0x70) == 0) {
      return v5 != v3;
    }
    goto LABEL_8;
  }

uint64_t sub_1808C9920(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v6 = a2;
  uint64_t v62 = *MEMORY[0x1895F89C0];
  int v51 = 0;
  char v8 = *(_BYTE *)(a2 + 8);
  if ((v8 & 0x70) != 0)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x40) == 0)
    {
      sub_1808CB138(a1, a2, 0LL, (int *)a3, a4);
      return a1;
    }

    if ((*(_BYTE *)(a2 + 8) & 0x80) == 0)
    {
      uprv_decNumberCopy(a1, (unsigned int *)a2);
      return a1;
    }

    *(_WORD *)(a1 + 8) = 0;
LABEL_18:
    *(void *)a1 = 1LL;
    return a1;
  }

  if (!*(_BYTE *)(a2 + 9) && *(_DWORD *)a2 == 1)
  {
    *(_WORD *)(a1 + 8) = 256;
    goto LABEL_18;
  }

  __int128 v47 = 0uLL;
  int v49 = 0;
  uint64_t v48 = 0LL;
  memset(v46, 0, 28);
  memset(v60, 0, sizeof(v60));
  int v61 = 0;
  memset(v59, 0, sizeof(v59));
  int v58 = 0;
  memset(v57, 0, sizeof(v57));
  uint64_t v54 = 0LL;
  uint64_t v55 = 0LL;
  int v56 = 0;
  uint64_t v53 = 1024LL;
  uint64_t v43 = 0LL;
  int v44 = 0;
  BOOL v9 = v8 < 0;
  int v10 = -*(_DWORD *)a3;
  if (v9) {
    int v10 = ~*(_DWORD *)a3;
  }
  LODWORD(v52) = 1;
  HIDWORD(v52) = v10;
  int v11 = sub_1808CBAB4((uint64_t)&v52, a2, 1);
  if (v11 == 0x80000000) {
    goto LABEL_13;
  }
  if ((v11 & 0x80000000) == 0)
  {
    int v13 = *(_DWORD *)a3;
    *(_WORD *)(a1 + 8) = 256;
    *(void *)a1 = 1LL;
    *(_DWORD *)a1 = sub_1808CC550((_BYTE *)(a1 + 9), 1LL, v13 - 1);
    *(_DWORD *)(a1 + 4) = 1 - v13;
    int v12 = *a4 | 0x820;
    goto LABEL_16;
  }

  int v50 = 0;
  memset(v45, 0, 28);
  uprv_decContextDefault((uint64_t)&v47, 64);
  *(void *)((char *)&v47 + 4) = *(void *)(a3 + 4);
  LOBYTE(v49) = 0;
  int v15 = *(_DWORD *)v6;
  int v16 = *(_DWORD *)(v6 + 4);
  int v17 = *(_DWORD *)v6 + v16;
  if (v17 >= 9)
  {
    WORD4(v57[0]) = 512;
    *(void *)&v57[0] = 1LL;
    uint64_t v41 = 0LL;
    uint64_t v42 = 0LL;
    int v18 = 0LL;
    char v24 = v59;
    int v25 = v57;
    LODWORD(v26) = 9;
    int v27 = 8;
    goto LABEL_58;
  }

  int v19 = 0LL;
  int v20 = v15 > 8;
  if (8 - v17 < v20) {
    int v20 = 8 - v17;
  }
  int v21 = v20 + v17;
  if (v20 + v17 >= 0)
  {
    int v22 = -v15 - v20;
    if (v16 != v22)
    {
      if (v15 <= 49) {
        int v15 = byte_180A37148[v15];
      }
      if (v15 < 0x4A)
      {
        int v19 = 0LL;
        char v23 = v60;
      }

      else
      {
        char v23 = uprv_malloc((v15 + 11));
        int v19 = v23;
        if (!v23)
        {
LABEL_13:
          int v12 = *a4 | 0x10;
LABEL_16:
          *a4 = v12;
          return a1;
        }
      }

      int v28 = (int *)uprv_decNumberCopy((uint64_t)v23, (unsigned int *)v6);
      v28[1] = v22;
      int v15 = *v28;
      uint64_t v6 = (uint64_t)v28;
    }
  }

  int v27 = v21 & ~(v21 >> 31);
  if (v15 <= *(_DWORD *)a3) {
    int v15 = *(_DWORD *)a3;
  }
  int v29 = v15 + v27;
  uint64_t v26 = v15 + v27 + 2LL;
  int v30 = 2 * v26;
  if (v29 <= 22) {
    int v30 = byte_180A37148[2 * v26];
  }
  size_t v31 = (v30 + 11);
  if (v31 < 0xB5)
  {
    uint64_t v42 = 0LL;
    int v25 = v57;
LABEL_44:
    uint64_t v33 = v29 + 4LL;
    if (v29 <= 45) {
      LODWORD(v33) = byte_180A37148[v33];
    }
    uint64_t v41 = v19;
    if (v33 < 0x56)
    {
      int v18 = 0LL;
      char v24 = v59;
    }

    else
    {
      int v18 = uprv_malloc((v33 + 11));
      char v24 = v18;
      if (!v18)
      {
        *a4 |= 0x10u;
        int v19 = v41;
LABEL_82:
        uint64_t v32 = v42;
        goto LABEL_83;
      }
    }

    uprv_decNumberCopy((uint64_t)v24, (unsigned int *)v6);
    *((_WORD *)v25 + 4) = 256;
    *(void *)int v25 = 1LL;
    LOWORD(v53) = 512;
    uint64_t v52 = 1LL;
    LOWORD(v44) = 256;
    uint64_t v43 = 1LL;
    uprv_decContextDefault((uint64_t)v46, 64);
    v45[0] = v46[0];
    *(_OWORD *)((char *)v45 + 12) = *(_OWORD *)((char *)v46 + 12);
    LODWORD(v47) = 2 * v26;
    LODWORD(v46[0]) = v26;
    DWORD2(v46[0]) = -999999999;
    while (1)
    {
      sub_1808C7C34((int *)v25, (int *)v25, (uint64_t)v24, (int *)&v47, 0, a4);
      uint64_t v34 = sub_1808CA160((uint64_t)v24, (uint64_t)v24, v6, (int *)v46, &v51);
      sub_1808C8BD0(v34, (uint64_t)v24, (uint64_t)&v52, (int *)v46, 128, &v51);
      if (*(_DWORD *)v25 >= (int)v26
        && *((_DWORD *)v25 + 1) + *(_DWORD *)v25 > *(_DWORD *)v24 + (int)v26 + *((_DWORD *)v24 + 1))
      {
        break;
      }

      sub_1808C7C34((int *)&v52, (int *)&v52, (uint64_t)&v43, (int *)v45, 0, &v51);
    }

    if (v21 >= 1)
    {
LABEL_58:
      int v36 = 0;
      int v37 = dword_180A37120[v27];
      LODWORD(v47) = v26 + 2;
      *((_WORD *)v24 + 4) = 256;
      *(void *)char v24 = 1LL;
      for (int i = 30; ; --i)
      {
        if ((*a4 & 0x2200) != 0
          && ((*a4 & 0x200) != 0 || !*((_BYTE *)v24 + 9) && *(_DWORD *)v24 == 1 && (*((_BYTE *)v24 + 8) & 0x70) == 0))
        {
LABEL_72:
          int v25 = v24;
          goto LABEL_73;
        }

        v37 *= 2;
        if (v37 < 0) {
          break;
        }
        if (!i) {
          goto LABEL_72;
        }
        if (v36) {
          goto LABEL_70;
        }
LABEL_71:
        ;
      }

      sub_1808CA160((uint64_t)v24, (uint64_t)v24, (uint64_t)v25, (int *)&v47, a4);
      if (!i) {
        goto LABEL_72;
      }
      int v36 = 1;
LABEL_70:
      sub_1808CA160((uint64_t)v24, (uint64_t)v24, (uint64_t)v24, (int *)&v47, a4);
      goto LABEL_71;
    }

uint64_t uprv_decNumberFMA(uint64_t a1, int *a2, int *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v18 = 0;
  int v20 = 0;
  memset(v19, 0, sizeof(v19));
  int v16 = 0;
  uint64_t v15 = 0LL;
  if (((a2[2] & 0x70) != 0 || !sub_1808C986C((uint64_t)a2, (int *)a5, &v18))
    && ((a3[2] & 0x70) != 0 || !sub_1808C986C((uint64_t)a3, (int *)a5, &v18))
    && ((a4[1] & 0x70) != 0 || !sub_1808C986C((uint64_t)a4, (int *)a5, &v18)))
  {
    *(_OWORD *)int v17 = *(_OWORD *)a5;
    *(_OWORD *)&v17[12] = *(_OWORD *)(a5 + 12);
    uint64_t v10 = *a3 + (uint64_t)*a2;
    *(_DWORD *)int v17 = v10;
    *(void *)&v17[4] = 0xC46536013B9AC9FFLL;
    if (v10 < 0x4A)
    {
      int v11 = 0LL;
      int v12 = (int *)v19;
    }

    else
    {
      int v11 = (int *)uprv_malloc((v10 + 11));
      int v12 = v11;
      if (!v11)
      {
        int v13 = v18 | 0x10;
LABEL_24:
        sub_1808C7B8C(a1, v13, a5);
        return a1;
      }
    }

    sub_1808CA160((uint64_t)v12, (uint64_t)a2, (uint64_t)a3, (int *)v17, &v18);
    if ((v18 & 0x80) != 0)
    {
      if ((v18 & 0x40000000) == 0)
      {
        *(void *)a1 = 1LL;
        *(_WORD *)(a1 + 8) = 32;
        if (!v11) {
          goto LABEL_23;
        }
LABEL_22:
        uprv_free(v11);
        goto LABEL_23;
      }

      LOWORD(v16) = 0;
      uint64_t v15 = 1LL;
      a4 = &v15;
    }

    sub_1808C7C34((int *)a1, v12, (uint64_t)a4, (int *)a5, 0, &v18);
    if (!v11) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

uint64_t sub_1808CA160(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5)
{
  uint64_t v6 = a4;
  uint64_t v118 = *MEMORY[0x1895F89C0];
  int v111 = 0;
  unsigned __int8 v8 = *(_BYTE *)(a2 + 8);
  unsigned __int8 v9 = *(_BYTE *)(a3 + 8);
  char v10 = (v9 ^ v8) & 0x80;
  if (((v9 | v8) & 0x70) != 0)
  {
    if (((v9 | v8) & 0x30) != 0)
    {
      sub_1808CB138(a1, a2, a3, a4, a5);
      return a1;
    }

    if (((*(_BYTE *)(a2 + 8) & 0x40) != 0
       || *(_BYTE *)(a2 + 9)
       || (*(_BYTE *)(a2 + 8) & 0x70) != 0
       || *(_DWORD *)a2 != 1)
      && ((*(_BYTE *)(a3 + 8) & 0x40) != 0
       || *(_BYTE *)(a3 + 9)
       || (*(_BYTE *)(a3 + 8) & 0x70) != 0
       || *(_DWORD *)a3 != 1))
    {
      *(void *)a1 = 1LL;
      *(_BYTE *)(a1 + 9) = 0;
      *(_BYTE *)(a1 + 8) = v10 | 0x40;
      return a1;
    }

    int v92 = *a5 | 0x80;
LABEL_108:
    *a5 = v92;
    return a1;
  }

  memset(v117, 0, 145);
  memset(v115, 0, sizeof(v115));
  uint64_t v116 = 0LL;
  memset(v113, 0, sizeof(v113));
  uint64_t v114 = 0LL;
  memset(v112, 0, 128);
  int v11 = *(_DWORD *)a2;
  int v12 = *(_DWORD *)a3;
  if (*(_DWORD *)a2 >= *(_DWORD *)a3) {
    int v13 = *(_DWORD *)a3;
  }
  else {
    int v13 = *(_DWORD *)a2;
  }
  if (v11 <= v12) {
    int v14 = *(_DWORD *)a3;
  }
  else {
    int v14 = *(_DWORD *)a2;
  }
  if (v11 > v12) {
    uint64_t v15 = (_DWORD *)a3;
  }
  else {
    uint64_t v15 = (_DWORD *)a2;
  }
  if (v11 > v12) {
    int v16 = (int *)a2;
  }
  else {
    int v16 = (int *)a3;
  }
  memset(&v112[8], 0, 32);
  if (v13 >= 3)
  {
    unint64_t v109 = v15;
    int v17 = (v14 + 8) / 9;
    unsigned int v18 = (v13 + 8) / 9u;
    int v19 = v16;
    if (v14 < 91)
    {
      int v103 = 0LL;
      int v20 = (unsigned int *)v115;
    }

    else
    {
      int v20 = (unsigned int *)uprv_malloc((4 * v17));
      int v103 = v20;
    }

    char v107 = v6;
    int v27 = v17 + v18;
    if (v13 < 0x5B)
    {
      int v102 = 0LL;
      int v28 = v113;
    }

    else
    {
      int v28 = (char *)uprv_malloc(4 * v18);
      int v102 = v28;
    }

    if (v27 >= -7) {
      int v31 = v27 + 7;
    }
    else {
      int v31 = v27 + 14;
    }
    size_t v32 = (8 * (v27 + (v31 >> 3)));
    if ((int)v32 < 161)
    {
      uint64_t v33 = 0LL;
      int v25 = (char *)v112;
    }

    else
    {
      uint64_t v33 = (char *)uprv_malloc(v32);
      int v25 = v33;
    }

    int v16 = v19;
    if (!v20 || !v28 || !v25)
    {
      *a5 |= 0x10u;
      int v79 = v102;
      unsigned int v78 = v103;
      if (!v33) {
        goto LABEL_126;
      }
      goto LABEL_125;
    }

    int v34 = v31 >> 3;
    int v35 = *v19;
    int v36 = v20;
    if (*v19 >= 1)
    {
      int v37 = (unsigned __int8 *)v19 + 9;
      int v36 = v20;
      do
      {
        unsigned int v38 = 0;
        unsigned int *v36 = 0;
        int v39 = v35 - 1;
        uint64_t v40 = (v39 + 1);
        uint64_t v41 = dword_180A37120;
        do
        {
          int v43 = *v37++;
          int v42 = v43;
          int v44 = *v41++;
          v38 += v44 * v42;
          unsigned int *v36 = v38;
          --v35;
          --v40;
        }

        while (v40);
        ++v36;
      }

      while (v35 + 1 > 1);
    }

    char v105 = v10;
    unsigned int v45 = &v25[8 * v34];
    int v46 = *v109;
    __int128 v47 = v28;
    if (*v109 >= 1)
    {
      uint64_t v48 = (unsigned __int8 *)v109 + 9;
      __int128 v47 = v28;
      do
      {
        int v49 = 0;
        *(_DWORD *)__int128 v47 = 0;
        int v50 = v46 - 1;
        uint64_t v51 = (v50 + 1);
        uint64_t v52 = dword_180A37120;
        do
        {
          int v54 = *v48++;
          int v53 = v54;
          int v55 = *v52++;
          v49 += v55 * v53;
          *(_DWORD *)__int128 v47 = v49;
          --v46;
          --v51;
        }

        while (v51);
        v47 += 4;
      }

      while (v46 + 1 > 1);
    }

    v106 = v33;
    int v56 = v47 - 4;
    if (v27 >= 1)
    {
      size_t v57 = &v25[8 * v34];
      int v58 = &v57[8 * v27];
      unsigned int v59 = v57 + 8;
      if (v58 > v59) {
        unsigned int v59 = v58;
      }
      bzero(v45, ((unint64_t)&v59[~(unint64_t)v25 + -8 * v34] & 0xFFFFFFFFFFFFFFF8LL) + 8);
      int v16 = v19;
    }

    int v60 = (unint64_t *)&v45[8 * v27];
    if (v28 <= v56)
    {
      int v61 = v36 - 1;
      int v62 = 18;
      int v63 = v28;
      do
      {
        if (v20 <= v61)
        {
          char v64 = &v45[2 * (v63 - v28)];
          unsigned int v65 = *(_DWORD *)v63;
          int v66 = v20;
          do
          {
            unsigned int v67 = *v66++;
            *(void *)v64 += v65 * (unint64_t)v67;
            v64 += 8;
          }

          while (v66 <= v61);
        }

        BOOL v68 = __OFSUB__(v62--, 1);
        if ((v62 < 0) ^ v68 | (v62 == 0)) {
          char v69 = 0;
        }
        else {
          char v69 = 1;
        }
        int v70 = v69 & (v63 != v56);
        if (!v70) {
          int v62 = 18;
        }
        if ((v70 & 1) == 0 && v27 >= 1)
        {
          unsigned int v71 = (unint64_t *)v45;
          do
          {
            unint64_t v72 = *v71;
            if (*v71 >= 0x3B9ACA00)
            {
              unint64_t v73 = v72 / 0x3B9ACA00;
              if (v72 >= 0xDE0B6B3A7640000LL)
              {
                unint64_t v74 = v72 / 0xDE0B6B3A7640000LL;
                v71[2] += v72 / 0xDE0B6B3A7640000LL;
                v72 %= 0xDE0B6B3A7640000uLL;
                LODWORD(v73) = v73 - 1000000000 * v74;
              }

              uint64_t v75 = v73;
              unint64_t v76 = v71[1] + v73;
              unint64_t *v71 = v72 - 1000000000 * v75;
              v71[1] = v76;
            }

            ++v71;
          }

          while (v71 < v60);
          int v62 = 18;
        }

        v63 += 4;
      }

      while (v63 <= v56);
    }

    if (v27 < 1)
    {
      int v84 = (int)v25;
      uint64_t v15 = v109;
      uint64_t v6 = v107;
      int v79 = v102;
      unsigned int v78 = v103;
    }

    else
    {
      int v77 = v25;
      uint64_t v15 = v109;
      uint64_t v6 = v107;
      int v79 = v102;
      unsigned int v78 = v103;
      do
      {
        uint64_t v80 = 0LL;
        unsigned int v81 = *(_DWORD *)v45;
        do
        {
          char v82 = v81;
          v81 /= 0xAu;
          v77[v80++] = v82 - 10 * v81;
        }

        while ((_DWORD)v80 != 8);
        BOOL v83 = &v77[v80];
        char *v83 = v81;
        int v77 = v83 + 1;
        v45 += 8;
      }

      while (v45 < (char *)v60);
      int v84 = (_DWORD)v83 + 1;
    }

    int v89 = v84 - (_DWORD)v25;
    char v91 = v105;
LABEL_111:
    *(_BYTE *)(a1 + 8) = v91;
    if (v89 < 1) {
      goto LABEL_118;
    }
    goto LABEL_112;
  }

  int v21 = v14;
  if (v14 <= 49) {
    int v21 = byte_180A37148[v14];
  }
  size_t v22 = v21 + byte_180A37148[v13];
  if (v22 < 0x92)
  {
    uint64_t v26 = 0LL;
    int v25 = v117;
  }

  else
  {
    char v23 = v16;
    char v24 = (char *)uprv_malloc(v22);
    if (!v24)
    {
      int v92 = *a5 | 0x10;
      goto LABEL_108;
    }

    int v25 = v24;
    int v16 = v23;
    int v14 = *v23;
    uint64_t v26 = v24;
  }

  *int v25 = 0;
  if (v14 <= 49) {
    int v14 = byte_180A37148[v14];
  }
  int v30 = (char *)v15 + 9;
  unsigned int v29 = *v15;
  v106 = v26;
  if ((int)*v15 > 49)
  {
    v108 = v6;
    int v110 = v15;
    char v104 = v10;
LABEL_95:
    int v85 = 0;
    uint64_t v86 = 0LL;
    char v87 = v16;
    int v88 = (unsigned __int8 *)v16 + 9;
    int v89 = 1;
    BOOL v90 = &v30[v29];
    do
    {
      if (v30[v86]) {
        int v89 = v86 + sub_1808CE154(&v25[v86], v89 + v85, v88, v14, 0, &v25[v86], v30[v86]);
      }
      else {
        v25[v89++] = 0;
      }
      ++v86;
      --v85;
    }

    while (&v30[v86] < v90);
    unsigned int v78 = 0LL;
    int v79 = 0LL;
    char v91 = v104;
    uint64_t v6 = v108;
    uint64_t v15 = v110;
    int v16 = v87;
    goto LABEL_111;
  }

  if (v29)
  {
    v108 = v6;
    int v110 = v15;
    char v104 = v10;
    unsigned int v29 = byte_180A37148[v29];
    goto LABEL_95;
  }

  int v79 = 0LL;
  unsigned int v78 = 0LL;
  *(_BYTE *)(a1 + 8) = v10;
  int v89 = 1;
LABEL_112:
  unint64_t v93 = &v25[v89 - 1];
  do
  {
    if (*v93) {
      BOOL v94 = 1;
    }
    else {
      BOOL v94 = v89 == 1;
    }
    if (v94) {
      break;
    }
    --v89;
    --v93;
  }

  while (v93 >= v25);
LABEL_118:
  *(_DWORD *)a1 = v89;
  int v95 = v16[1];
  int v96 = v15[1];
  int v97 = v96 + v95;
  int v98 = v95 & v96;
  if (v97 > 0 && v98 < 0) {
    int v100 = -1999999998;
  }
  else {
    int v100 = v97;
  }
  *(_DWORD *)(a1 + 4) = v100;
  sub_1808C77A4((_BYTE *)a1, v6, v25, v89, &v111, a5);
  sub_1808C7A24((unsigned int *)a1, (uint64_t)v6, &v111, a5);
  uint64_t v33 = v106;
  if (!v106) {
    goto LABEL_126;
  }
LABEL_125:
  uprv_free(v33);
LABEL_126:
  if (v79) {
    uprv_free(v79);
  }
  if (v78) {
    uprv_free(v78);
  }
  return a1;
}

uint64_t uprv_decNumberInvert(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (*(_DWORD *)(a2 + 4) || *(unsigned __int8 *)(a2 + 8) >= 0x10u)
  {
LABEL_25:
    *(void *)a1 = 1LL;
    *(_WORD *)(a1 + 8) = 32;
    uprv_decContextSetStatus((uint64_t)a3, 128);
  }

  else
  {
    unsigned int v4 = *(_DWORD *)a2;
    unint64_t v5 = a1 + 9;
    unsigned int v6 = *a3;
    unint64_t v7 = v5 + v6 - 1;
    int v8 = a1 + 9;
    if (v5 <= v7)
    {
      unint64_t v9 = a2 + 9 + v4 - 1;
      uint64_t v10 = 9LL;
      do
      {
        if (a2 + v10 <= v9)
        {
          unsigned int v11 = *(unsigned __int8 *)(a2 + v10);
          if ((v11 & 1) != 0)
          {
            char v12 = 0;
            goto LABEL_14;
          }
        }

        else
        {
          unsigned int v11 = 0;
        }

        char v12 = 1;
LABEL_14:
        *(_BYTE *)(a1 + v10) = v12;
        int v8 = a1 + ++v10;
      }

      while (a1 + v10 <= v7);
    }

    int v13 = v8 - v5;
    if (v8 - (int)v5 >= 1)
    {
      int v14 = (_BYTE *)(v5 + (v13 - 1));
      int v15 = v8 - a1 - 10;
      do
      {
        if (*v14) {
          BOOL v16 = 1;
        }
        else {
          BOOL v16 = v15 == 0;
        }
        if (v16) {
          break;
        }
        --v14;
        --v15;
      }

      while ((unint64_t)v14 >= v5);
      int v13 = v15 + 1;
    }

    *(_DWORD *)a1 = v13;
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + 8) = 0;
  }

  return a1;
}

uint64_t uprv_decNumberLn(uint64_t a1, uint64_t a2, int *a3)
{
  int v7 = 0;
  if (!sub_1808C986C(a2, a3, &v7)) {
    sub_1808CAA40(a1, a2, (uint64_t)a3, &v7);
  }
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a3);
  }
  return a1;
}

uint64_t sub_1808CAA40(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  int v46 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x70) != 0)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x40) == 0)
    {
      sub_1808CB138(a1, a2, 0LL, (int *)a3, a4);
      return a1;
    }

    if ((*(_BYTE *)(a2 + 8) & 0x80) == 0)
    {
      uprv_decNumberCopy(a1, (unsigned int *)a2);
      return a1;
    }

    goto LABEL_16;
  }

  int v8 = *(unsigned __int8 *)(a2 + 9);
  if (!*(_BYTE *)(a2 + 9) && *(_DWORD *)a2 == 1)
  {
    *(void *)a1 = 1LL;
    *(_WORD *)(a1 + 8) = 192;
    return a1;
  }

  if ((*(_BYTE *)(a2 + 8) & 0x80) != 0)
  {
LABEL_16:
    int v11 = *a4 | 0x80;
LABEL_17:
    *a4 = v11;
    return a1;
  }

  memset(v48, 0, 60);
  memset(v47, 0, sizeof(v47));
  uint64_t v43 = 0LL;
  int v44 = 0;
  uint64_t v41 = 0LL;
  int v42 = 0;
  memset(v40, 0, 28);
  int v9 = *(_DWORD *)a3;
  if (!*(_DWORD *)(a2 + 4) && v9 <= 40)
  {
    if (v8)
    {
      if (v8 == 2 && *(_DWORD *)a2 == 1)
      {
        v40[0] = *(_OWORD *)a3;
        *(_OWORD *)((char *)v40 + 12) = *(_OWORD *)(a3 + 12);
        HIDWORD(v40[0]) = 3;
        uint64_t v10 = "0.6931471805599453094172321214581765680755";
LABEL_21:
        uprv_decNumberFromString(a1, (unsigned __int8 *)v10, (uint64_t)v40);
        int v11 = *a4 | 0x820;
        goto LABEL_17;
      }
    }

    else if (*(_BYTE *)(a2 + 10) == 1 && *(_DWORD *)a2 == 2)
    {
      v40[0] = *(_OWORD *)a3;
      *(_OWORD *)((char *)v40 + 12) = *(_OWORD *)(a3 + 12);
      HIDWORD(v40[0]) = 3;
      uint64_t v10 = "2.302585092994045684017991454684364207601";
      goto LABEL_21;
    }
  }

  unsigned int v12 = *(_DWORD *)a2;
  if (v9 <= *(_DWORD *)a2) {
    int v9 = *(_DWORD *)a2;
  }
  if (v9 <= 7) {
    int v9 = 7;
  }
  int v13 = v9 + 2;
  if (v9 + 2 <= 16) {
    unsigned int v14 = 16;
  }
  else {
    unsigned int v14 = v9 + 2;
  }
  if (v14 >= 0x32)
  {
    int v15 = uprv_malloc(v14 + 11);
    if (!v15)
    {
      int v11 = *a4 | 0x10;
      goto LABEL_17;
    }

    unsigned int v12 = *(_DWORD *)a2;
    BOOL v16 = v15;
  }

  else
  {
    int v15 = 0LL;
    BOOL v16 = v48;
  }

  int v17 = v12 + v13;
  if (v17 <= 16) {
    int v17 = 16;
  }
  unsigned int v38 = v15;
  memset(v39, 0, 28);
  BOOL v45 = 0;
  if (v17 < 0x56)
  {
    unsigned int v18 = 0LL;
    int v19 = v47;
  }

  else
  {
    unsigned int v18 = uprv_malloc((v17 + 11));
    int v19 = v18;
    if (!v18)
    {
      *a4 |= 0x10u;
      int v20 = v38;
      goto LABEL_82;
    }
  }

  uprv_decContextDefault((uint64_t)v40, 64);
  int v21 = *(_DWORD *)a2 + *(_DWORD *)(a2 + 4);
  if (v21 >= 0) {
    unsigned int v22 = *(_DWORD *)a2 + *(_DWORD *)(a2 + 4);
  }
  else {
    unsigned int v22 = -v21;
  }
  uprv_decNumberFromUInt32((uint64_t)v16, v22);
  if (v21 < 0) {
    *((_BYTE *)v16 + 8) = 0x80;
  }
  uprv_decNumberFromUInt32((uint64_t)v19, 0x232279u);
  *((_DWORD *)v19 + 1) = -6;
  sub_1808CA160((uint64_t)v16, (uint64_t)v16, (uint64_t)v19, (int *)v40, &v46);
  BOOL v45 = 0;
  LODWORD(v40[0]) = 2;
  HIDWORD(v40[0]) = 5;
  *((_BYTE *)v19 + 8) = *(_BYTE *)(a2 + 8);
  int v23 = *(_DWORD *)a2;
  *((_DWORD *)v19 + 1) = *(_DWORD *)(a2 + 4);
  sub_1808C77A4(v19, (int *)v40, (char *)(a2 + 9), v23, (int *)&v45, &v46);
  *((_DWORD *)v19 + 1) = 0;
  int v24 = sub_1808CC6A4((int *)v19);
  int v25 = 10 * v24;
  if (v24 >= 10) {
    int v25 = v24;
  }
  unsigned int v26 = word_180A37190[v25 - 10];
  uprv_decNumberFromUInt32((uint64_t)v19, v26 >> 2);
  *((_DWORD *)v19 + 1) = -3 - (v26 & 3);
  *((_BYTE *)v19 + 8) = 0x80;
  LODWORD(v40[0]) = 16;
  HIDWORD(v40[0]) = 3;
  sub_1808C7C34((int *)v16, (int *)v16, (uint64_t)v19, (int *)v40, 0, &v46);
  LOWORD(v44) = 256;
  uint64_t v43 = 1LL;
  *(void *)((char *)v40 + 4) = *(void *)(a3 + 4);
  BYTE8(v40[1]) = 0;
  LODWORD(v39[0]) = v40[0];
  *(_OWORD *)((char *)v39 + 12) = *(_OWORD *)((char *)v40 + 12);
  *(void *)((char *)v39 + 4) = 0xFFE17B82001E847ELL;
  int v27 = 9;
  LODWORD(v40[0]) = 9;
  LODWORD(v39[0]) = *(_DWORD *)a2 + 9;
  int v28 = (char *)v16 + 9;
  while (1)
  {
    *((_BYTE *)v16 + 8) ^= 0x80u;
    uint64_t v29 = sub_1808C9920((uint64_t)v19, (uint64_t)v16, (uint64_t)v39, &v46);
    *((_BYTE *)v16 + 8) ^= 0x80u;
    int v30 = (int *)sub_1808CA160(v29, (uint64_t)v19, a2, (int *)v39, &v46);
    sub_1808C7C34(v30, (int *)v19, (uint64_t)&v43, (int *)v39, 128, &v46);
    int v31 = *(_DWORD *)v19;
    BOOL v32 = !*((_BYTE *)v19 + 9) && v31 == 1;
    BOOL v33 = v32;
    if (v32 && (*((_BYTE *)v19 + 8) & 0x70) == 0)
    {
      int v34 = *(_DWORD *)v16;
    }

    else
    {
      int v34 = *(_DWORD *)v16;
      if (*((_DWORD *)v16 + 1) + *(_DWORD *)v16 <= *((_DWORD *)v19 + 1) + v31 + *(_DWORD *)a3) {
        goto LABEL_68;
      }
    }

    if (v34 == v13) {
      goto LABEL_77;
    }
    if (v34 == 1 && !*v28 && (*((_BYTE *)v16 + 8) & 0x70) == 0) {
      break;
    }
    if (v33 && (*((_BYTE *)v19 + 8) & 0x70) == 0) {
      *((_DWORD *)v19 + 1) = *((_DWORD *)v16 + 1) - v13;
    }
LABEL_68:
    sub_1808C7C34((int *)v16, (int *)v16, (uint64_t)v19, (int *)v40, 0, &v46);
    if (v27 != v13)
    {
      if (2 * v27 >= v13) {
        int v27 = v13;
      }
      else {
        v27 *= 2;
      }
      LODWORD(v40[0]) = v27;
      LODWORD(v39[0]) = *(_DWORD *)a2 + v27;
    }
  }

  sub_1808C8568((uint64_t)&v41, a2, (uint64_t)&v43, (int *)v40, 1, &v46);
  if (BYTE1(v42)) {
    *a4 |= 0x820u;
  }
  else {
    *((_DWORD *)v16 + 1) = 0;
  }
LABEL_77:
  BOOL v45 = 1;
  if (*v28)
  {
    char v35 = *((_BYTE *)v16 + 8);
    int v36 = *(_DWORD *)v16;
    int v20 = v38;
  }

  else
  {
    int v36 = *(_DWORD *)v16;
    char v35 = *((_BYTE *)v16 + 8);
    int v20 = v38;
    if (*(_DWORD *)v16 == 1)
    {
      BOOL v45 = (v35 & 0x70) != 0;
      int v36 = 1;
    }
  }

  LODWORD(v40[0]) = *(_DWORD *)a3;
  *(_BYTE *)(a1 + 8) = v35;
  *(_DWORD *)(a1 + 4) = *((_DWORD *)v16 + 1);
  sub_1808C77A4((_BYTE *)a1, (int *)v40, (char *)v16 + 9, v36, (int *)&v45, a4);
  sub_1808C7A24((unsigned int *)a1, a3, (int *)&v45, a4);
LABEL_82:
  if (v20) {
    uprv_free(v20);
  }
  if (v18) {
    uprv_free(v18);
  }
  return a1;
}

uint64_t uprv_decNumberLogB(uint64_t a1, uint64_t a2, int *a3)
{
  int v13 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x30) != 0)
  {
    sub_1808CB138(a1, a2, 0LL, a3, &v13);
    int v5 = v13;
    if (v13)
    {
LABEL_3:
      sub_1808C7B8C(a1, v5, (uint64_t)a3);
      return a1;
    }

    return a1;
  }

  if ((*(_BYTE *)(a2 + 8) & 0x40) != 0)
  {
    uprv_decNumberCopy(a1, (unsigned int *)a2);
    char v11 = *(_BYTE *)(a1 + 8) & 0x7F;
    goto LABEL_18;
  }

  unsigned int v6 = *(_DWORD *)a2;
  if (*(_BYTE *)(a2 + 9)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = (*(_BYTE *)(a2 + 8) & 0x70) == 0;
  }
  if (v7 && v6 == 1)
  {
    *(void *)a1 = 1LL;
    *(_WORD *)(a1 + 8) = 192;
    int v5 = 2;
    goto LABEL_3;
  }

  int v9 = v6 + *(_DWORD *)(a2 + 4);
  if (v9 - 1 < 0) {
    unsigned int v10 = 1 - v9;
  }
  else {
    unsigned int v10 = v9 - 1;
  }
  uprv_decNumberFromUInt32(a1, v10);
  if (v9 <= 0)
  {
    char v11 = 0x80;
LABEL_18:
    *(_BYTE *)(a1 + 8) = v11;
  }

  return a1;
}

uint64_t sub_1808CB138(uint64_t result, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5)
{
  if ((*(_BYTE *)(a2 + 8) & 0x10) != 0)
  {
    *a5 |= 0x40000080u;
  }

  else if (a3)
  {
    if ((*(_BYTE *)(a3 + 8) & 0x10) != 0)
    {
      *a5 |= 0x40000080u;
      a2 = a3;
    }

    else if ((*(_BYTE *)(a2 + 8) & 0x20) == 0)
    {
      a2 = a3;
    }
  }

  int v5 = *a4;
  if (*(_DWORD *)a2 <= *a4)
  {
    double result = uprv_decNumberCopy(result, (unsigned int *)a2);
    goto LABEL_20;
  }

  *(_BYTE *)(result + 8) = *(_BYTE *)(a2 + 8);
  if (v5 > 49) {
    goto LABEL_13;
  }
  if (v5)
  {
    int v5 = byte_180A37148[v5];
LABEL_13:
    unint64_t v6 = result + 9 + v5;
    uint64_t v7 = 9LL;
    do
    {
      *(_BYTE *)(result + v7) = *(_BYTE *)(a2 + v7);
      ++v7;
    }

    while (result + v7 < v6);
    int v5 = *a4;
    if (*a4 >= 50)
    {
      *(_DWORD *)double result = v5;
      goto LABEL_20;
    }
  }

  int v8 = byte_180A37148[v5];
  *(_DWORD *)double result = v8;
  if (v8 > v5) {
    double result = (uint64_t)sub_1808CD480((int *)result, v8 - v5);
  }
LABEL_20:
  *(_BYTE *)(result + 8) = *(_BYTE *)(result + 8) & 0xCF | 0x20;
  *(_DWORD *)(result + 4) = 0;
  return result;
}

uint64_t uprv_decNumberCopyAbs(uint64_t a1, unsigned int *a2)
{
  uint64_t result = uprv_decNumberCopy(a1, a2);
  *(_BYTE *)(result + 8) &= ~0x80u;
  return result;
}

uint64_t uprv_decNumberLog10(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v26 = 0LL;
  uint64_t v27 = 0LL;
  memset(v30, 0, 60);
  memset(v29, 0, 60);
  v28[0] = 0LL;
  v28[1] = 0LL;
  __int128 v23 = 0uLL;
  int v25 = 0;
  uint64_t v24 = 0LL;
  uprv_decContextDefault((uint64_t)&v23, 64);
  unsigned int v6 = *(unsigned __int8 *)(a2 + 8);
  int v7 = *(_DWORD *)a2;
  if (v6 > 0xF)
  {
    int v8 = *(_DWORD *)a2;
  }

  else
  {
    int v8 = 1;
    if (*(_BYTE *)(a2 + 9) || v7 != 1)
    {
      uint64_t v22 = 0LL;
      LODWORD(v23) = 1;
      LOBYTE(v28[0]) = v6;
      HIDWORD(v27) = *(_DWORD *)(a2 + 4);
      sub_1808C77A4(&v27, (int *)&v23, (char *)(a2 + 9), v7, (int *)&v22 + 1, (int *)&v22);
      if ((v22 & 0x20) == 0 && BYTE1(v28[0]) == 1)
      {
        int v9 = HIDWORD(v27);
        if (v27 >= 0) {
          unsigned int v10 = HIDWORD(v27);
        }
        else {
          unsigned int v10 = -HIDWORD(v27);
        }
        uprv_decNumberFromUInt32((uint64_t)&v27, v10);
        if (v9 < 0)
        {
          char v11 = 0x80;
          LOBYTE(v28[0]) = 0x80;
        }

        else
        {
          char v11 = v28[0];
        }

        HIDWORD(v22) = 0;
        *(_BYTE *)(a1 + 8) = v11;
        int v20 = v27;
        *(_DWORD *)(a1 + 4) = HIDWORD(v27);
        sub_1808C77A4((_BYTE *)a1, a3, (char *)v28 + 1, v20, (int *)&v22 + 1, (int *)&v26 + 1);
        sub_1808C7A24((unsigned int *)a1, (uint64_t)a3, (int *)&v22 + 1, (int *)&v26 + 1);
        goto LABEL_38;
      }

      int v8 = *(_DWORD *)a2;
    }
  }

  if (v8 + 6 <= *a3) {
    int v12 = *a3;
  }
  else {
    int v12 = v8 + 6;
  }
  if (v12 >= 47)
  {
    int v13 = (unsigned int *)uprv_malloc((v12 + 14));
    unsigned int v14 = v13;
    if (!v13)
    {
      int v17 = HIDWORD(v26) | 0x10;
LABEL_39:
      sub_1808C7B8C(a1, v17, (uint64_t)a3);
      return a1;
    }
  }

  else
  {
    int v13 = 0LL;
    unsigned int v14 = (unsigned int *)v30;
  }

  LODWORD(v23) = v12 + 3;
  *(void *)((char *)&v23 + 4) = 0xFFF0BDC1000F423FLL;
  LOBYTE(v25) = 0;
  sub_1808CAA40((uint64_t)v14, a2, (uint64_t)&v23, (int *)&v26 + 1);
  int v15 = HIDWORD(v26);
  if ((v26 & 0xDD00000000LL) != 0 && (v26 & 0x4000000000000000LL) == 0) {
    goto LABEL_24;
  }
  if ((v14[2] & 0x70) != 0 || !*((_BYTE *)v14 + 9) && *v14 == 1)
  {
    uprv_decNumberCopy(a1, v14);
LABEL_24:
    BOOL v16 = 0LL;
    goto LABEL_25;
  }

  int v18 = *a3;
  if (*a3 >= 47)
  {
    BOOL v16 = uprv_malloc((v18 + 14));
    int v19 = v16;
    if (!v16)
    {
      HIDWORD(v26) = v15 | 0x10;
      goto LABEL_25;
    }
  }

  else
  {
    BOOL v16 = 0LL;
    int v19 = v29;
  }

  LOWORD(v28[0]) = 0;
  BYTE2(v28[0]) = 1;
  uint64_t v27 = 2LL;
  LODWORD(v23) = v18 + 3;
  sub_1808CAA40((uint64_t)v19, (uint64_t)&v27, (uint64_t)&v23, (int *)&v26);
  LODWORD(v23) = *a3;
  sub_1808C8BD0(a1, (uint64_t)v14, (uint64_t)v19, (int *)&v23, 128, (int *)&v26 + 1);
LABEL_25:
  if (v13) {
    uprv_free(v13);
  }
  if (v16) {
    uprv_free(v16);
  }
LABEL_38:
  int v17 = HIDWORD(v26);
  if (HIDWORD(v26)) {
    goto LABEL_39;
  }
  return a1;
}

uint64_t uprv_decNumberMax(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 2, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberMaxMag(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 7, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberMin(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 3, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberMinMag(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8568(a1, a2, a3, a4, 8, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

int *uprv_decNumberMinus(int *a1, uint64_t a2, int *a3)
{
  v8[2] = 0;
  int v5 = *(_DWORD *)(a2 + 4);
  int v7 = 0;
  v8[0] = 1;
  v8[1] = v5;
  sub_1808C7C34(a1, v8, a2, a3, 128, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, (uint64_t)a3);
  }
  return a1;
}

int *uprv_decNumberNextMinus(int *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)int v7 = *(_OWORD *)a3;
  *(_OWORD *)&v7[3] = *(_OWORD *)(a3 + 12);
  int v6 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0xC0) == 0x40)
  {
    sub_1808CB7E0((uint64_t)a1, (int *)a3);
  }

  else
  {
    int v9 = 256;
    unint64_t v8 = 0xC465360000000001LL;
    v7[3] = 6;
    sub_1808C7C34(a1, (int *)a2, (uint64_t)&v8, v7, 128, &v6);
    if ((v6 & 0x40000080) != 0) {
      sub_1808C7B8C((uint64_t)a1, v6 & 0x40000080, a3);
    }
  }

  return a1;
}

_BYTE *sub_1808CB7E0(uint64_t a1, int *a2)
{
  int v4 = *a2;
  *(_DWORD *)a1 = *a2;
  uint64_t result = (_BYTE *)(a1 + 9);
  uint64_t v6 = (v4 - 2);
  if (v4 >= 2)
  {
    memset(result, 9, (v4 - 1));
    uint64_t result = (_BYTE *)(v6 + a1 + 10);
    int v4 = 1;
  }

  *uint64_t result = dword_180A37120[v4] - 1;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = a2[1] - *a2 + 1;
  return result;
}

uint64_t uprv_decNumberNextPlus(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)int v7 = *(_OWORD *)a3;
  *(_OWORD *)&v7[3] = *(_OWORD *)(a3 + 12);
  int v6 = 0;
  if (*(unsigned __int8 *)(a2 + 8) < 0xC0u)
  {
    int v9 = 256;
    unint64_t v8 = 0xC465360000000001LL;
    v7[3] = 0;
    sub_1808C7C34((int *)a1, (int *)a2, (uint64_t)&v8, v7, 0, &v6);
    if ((v6 & 0x40000080) != 0) {
      sub_1808C7B8C(a1, v6 & 0x40000080, a3);
    }
  }

  else
  {
    sub_1808CB7E0(a1, (int *)a3);
    *(_BYTE *)(a1 + 8) = 0x80;
  }

  return a1;
}

uint64_t uprv_decNumberNextToward(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v19 = 0;
  unint64_t v18 = 0LL;
  *(_OWORD *)int v17 = *(_OWORD *)a4;
  *(_OWORD *)&v17[3] = *(_OWORD *)(a4 + 12);
  int v16 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x30) != 0 || (*(_BYTE *)(a3 + 8) & 0x30) != 0)
  {
    sub_1808CB138(a1, a2, a3, (int *)a4, &v16);
  }

  else
  {
    int v10 = sub_1808CBAB4(a2, a3, 0);
    if (v10 == 0x80000000)
    {
      int v8 = 16;
      goto LABEL_5;
    }

    if (v10)
    {
      unsigned int v12 = *(unsigned __int8 *)(a2 + 8);
      if (v10 < 0)
      {
        if (v12 >= 0xC0)
        {
          sub_1808CB7E0(a1, (int *)a4);
          *(_BYTE *)(a1 + 8) = 0x80;
          return a1;
        }

        int v14 = 0;
        char v13 = 0;
      }

      else
      {
        if ((v12 & 0xC0) == 0x40)
        {
          sub_1808CB7E0(a1, (int *)a4);
          return a1;
        }

        char v13 = 0x80;
        int v14 = 6;
      }

      v17[3] = v14;
      LOWORD(v19) = 256;
      unint64_t v18 = 0xC465360000000001LL;
      sub_1808C7C34((int *)a1, (int *)a2, (uint64_t)&v18, v17, v13, &v16);
      if ((*(_BYTE *)(a1 + 8) & 0x70) == 0)
      {
        int v15 = *(_DWORD *)a1;
        if ((*(_BYTE *)(a1 + 9) || v15 != 1) && *(_DWORD *)(a1 + 4) + v15 > *(_DWORD *)(a4 + 8)) {
          return a1;
        }
      }
    }

    else
    {
      char v11 = *(_BYTE *)(a3 + 8);
      uprv_decNumberCopy(a1, (unsigned int *)a2);
      *(_BYTE *)(a1 + 8) = v11 & 0x80 | *(_BYTE *)(a1 + 8) & 0x7F;
    }
  }

  int v8 = v16;
  if (v16) {
LABEL_5:
  }
    sub_1808C7B8C(a1, v8, a4);
  return a1;
}

uint64_t sub_1808CBAB4(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_BYTE *)(a1 + 9) && *(_DWORD *)a1 == 1)
  {
    BOOL v3 = (*(_BYTE *)(a1 + 8) & 0x70) == 0;
    BOOL v4 = (*(_BYTE *)(a1 + 8) & 0x70) != 0;
    if (!a3) {
      goto LABEL_4;
    }
LABEL_7:
    if (*(_BYTE *)(a2 + 9) || *(_DWORD *)a2 != 1)
    {
      if (v3) {
        return 0xFFFFFFFFLL;
      }
      int v6 = *(unsigned __int8 *)(a2 + 8);
    }

    else
    {
      int v6 = *(unsigned __int8 *)(a2 + 8);
      char v7 = (v6 & 0x70) == 0 || v3;
      if ((v6 & 0x70) != 0) {
        uint64_t v8 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v8 = v4;
      }
      if ((v7 & 1) != 0) {
        return v8;
      }
    }

    int v5 = 1;
    goto LABEL_35;
  }

  BOOL v3 = 0;
  BOOL v4 = 1;
  if (a3) {
    goto LABEL_7;
  }
LABEL_4:
  if (v3) {
    int v5 = 0;
  }
  else {
    int v5 = (*(char *)(a1 + 8) >> 31) | 1;
  }
  if (*(_BYTE *)(a2 + 9) || *(_DWORD *)a2 != 1 || (int v6 = *(unsigned __int8 *)(a2 + 8), (v6 & 0x70) != 0))
  {
    int v6 = *(unsigned __int8 *)(a2 + 8);
    int v9 = ((char)v6 >> 7) | 1;
  }

  else
  {
    int v9 = 0;
  }

  BOOL v10 = v5 < v9;
  if (v5 > v9) {
    return 1LL;
  }
  char v11 = v5 < v9 || v3;
  if (v10) {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v8 = 0LL;
  }
  if ((v11 & 1) == 0)
  {
LABEL_35:
    int v12 = *(unsigned __int8 *)(a1 + 8);
    if (((v6 | v12) & 0x40) != 0)
    {
      if ((v12 & 0x40) != 0) {
        LODWORD(v8) = 0;
      }
      else {
        LODWORD(v8) = -v5;
      }
      if ((v6 & 0x40) != 0) {
        return v8;
      }
      else {
        return v5;
      }
    }

    else
    {
      int v13 = *(_DWORD *)(a1 + 4);
      int v14 = *(_DWORD *)(a2 + 4);
      BOOL v15 = v13 <= v14;
      if (v13 <= v14) {
        uint64_t v16 = a2;
      }
      else {
        uint64_t v16 = a1;
      }
      if (v15) {
        uint64_t v17 = a1;
      }
      else {
        uint64_t v17 = a2;
      }
      if (v15) {
        int v18 = v5;
      }
      else {
        int v18 = -v5;
      }
      int v19 = *(_DWORD *)v17;
      int v20 = *(_DWORD *)v16;
      int v21 = sub_1808CE348( (char *)(v17 + 9),  v19,  (unsigned __int8 *)(v16 + 9),  v20,  *(_DWORD *)(v16 + 4) - *(_DWORD *)(v17 + 4));
      LODWORD(v8) = v21 * v18;
      if (v21 == 0x80000000) {
        return 0x80000000LL;
      }
      else {
        return v8;
      }
    }
  }

  return v8;
}

uint64_t uprv_decNumberCopySign(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  char v3 = *(_BYTE *)(a3 + 8);
  uint64_t result = uprv_decNumberCopy(a1, a2);
  *(_BYTE *)(result + 8) = v3 & 0x80 | *(_BYTE *)(result + 8) & 0x7F;
  return result;
}

BOOL uprv_decNumberIsNormal(int *a1, uint64_t a2)
{
  if ((a1[2] & 0x70) != 0) {
    return 0LL;
  }
  int v2 = *a1;
  return (*((_BYTE *)a1 + 9) || v2 != 1) && v2 + a1[1] > *(_DWORD *)(a2 + 8);
}

uint64_t uprv_decNumberOr(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (*(_DWORD *)(a2 + 4)
    || *(unsigned __int8 *)(a2 + 8) > 0xFu
    || *(_DWORD *)(a3 + 4)
    || *(unsigned __int8 *)(a3 + 8) >= 0x10u)
  {
LABEL_33:
    *(void *)a1 = 1LL;
    *(_WORD *)(a1 + 8) = 32;
    uprv_decContextSetStatus((uint64_t)a4, 128);
    return a1;
  }

  unsigned int v5 = *(_DWORD *)a2;
  unsigned int v6 = *(_DWORD *)a3;
  unint64_t v7 = a1 + 9;
  unsigned int v8 = *a4;
  unint64_t v9 = v7 + v8 - 1;
  int v10 = a1 + 9;
  if (v7 <= v9)
  {
    unint64_t v11 = a2 + 9 + v5 - 1;
    unint64_t v12 = a3 + 9 + v6 - 1;
    uint64_t v13 = 9LL;
    do
    {
      unsigned int v14 = a2 + v13 <= v11 ? *(unsigned __int8 *)(a2 + v13) : 0;
      unsigned int v15 = a3 + v13 <= v12 ? *(unsigned __int8 *)(a3 + v13) : 0;
      *(_BYTE *)(a1 + v13) = 0;
      if (v15 | v14)
      {
      }

      int v10 = a1 + ++v13;
    }

    while (a1 + v13 <= v9);
  }

  int v16 = v10 - v7;
  if (v10 - (int)v7 >= 1)
  {
    uint64_t v17 = (_BYTE *)(v7 + (v16 - 1));
    int v18 = v10 - a1 - 10;
    do
    {
      if (*v17) {
        BOOL v19 = 1;
      }
      else {
        BOOL v19 = v18 == 0;
      }
      if (v19) {
        break;
      }
      --v17;
      --v18;
    }

    while ((unint64_t)v17 >= v7);
    int v16 = v18 + 1;
  }

  *(_DWORD *)a1 = v16;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  return a1;
}

int *uprv_decNumberPlus(int *a1, uint64_t a2, int *a3)
{
  v8[2] = 0;
  int v5 = *(_DWORD *)(a2 + 4);
  int v7 = 0;
  v8[0] = 1;
  v8[1] = v5;
  sub_1808C7C34(a1, v8, a2, a3, 0, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, (uint64_t)a3);
  }
  return a1;
}

uint64_t uprv_decNumberMultiply(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808CA160(a1, a2, a3, a4, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberPower(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = (_OWORD *)a2;
  uint64_t v42 = *MEMORY[0x1895F89C0];
  int v8 = *(_DWORD *)a4;
  uint64_t v39 = 0LL;
  memset(v38, 0, 28);
  int v37 = 0;
  uint64_t v36 = 0LL;
  memset(v41, 0, 60);
  memset(v40, 0, 60);
  unsigned __int8 v9 = *(_BYTE *)(a2 + 8);
  unsigned __int8 v10 = *(_BYTE *)(a3 + 8);
  if (((v10 | v9) & 0x70) != 0)
  {
    if (((v10 | v9) & 0x30) != 0)
    {
      sub_1808CB138(a1, a2, a3, (int *)a4, &v39);
      goto LABEL_66;
    }

    if ((*(_BYTE *)(a3 + 8) & 0x40) != 0)
    {
      if ((*(_BYTE *)(a2 + 8) & 0x80) != 0)
      {
        if (*(_BYTE *)(a2 + 9)) {
          goto LABEL_46;
        }
        int v18 = 128;
        if ((v9 & 0x70) != 0 || *(_DWORD *)v6 != 1) {
          goto LABEL_67;
        }
      }

      LOWORD(v37) = 256;
      uint64_t v36 = 1LL;
      uprv_decNumberCompare((uint64_t)v41, (uint64_t)v6, (uint64_t)&v36, (int *)a4);
      *(_WORD *)(a1 + 8) = 0;
      *(void *)a1 = 1LL;
      if (SBYTE8(v41[0]) < 0)
      {
        if ((v10 & 0x80) == 0) {
          goto LABEL_66;
        }
      }

      else
      {
        if (!BYTE9(v41[0]))
        {
          int v23 = *(_DWORD *)a4;
          *(_BYTE *)(a1 + 9) = 1;
          *(_DWORD *)a1 = sub_1808CC550((_BYTE *)(a1 + 9), 1LL, v23 - 1);
          *(_DWORD *)(a1 + 4) = 1 - v23;
          int v18 = 2080;
          goto LABEL_67;
        }

        if ((v10 & 0x80) != 0) {
          goto LABEL_66;
        }
      }

      char v17 = 64;
LABEL_23:
      *(_BYTE *)(a1 + 8) = v17;
      goto LABEL_66;
    }
  }

  int v11 = sub_1808CC6A4((int *)a3);
  int v12 = v11;
  else {
    char v13 = 0;
  }
  if ((v9 & 0x40) != 0)
  {
    *(_WORD *)(a1 + 8) = 0;
    *(void *)a1 = 1LL;
    if (!v11)
    {
      *(_BYTE *)(a1 + 9) = 1;
      goto LABEL_66;
    }

    if (v11 != 0x80000000 || (*((char *)v6 + 8) & 0x80000000) == 0)
    {
      char v17 = v13 | 0x40;
      if ((v10 & 0x80u) != 0) {
        char v17 = v13;
      }
      goto LABEL_23;
    }

    goto LABEL_46;
  }

  if (!*((_BYTE *)v6 + 9) && (v9 & 0x70) == 0 && *(_DWORD *)v6 == 1)
  {
    if (v11)
    {
      char v17 = v13 | 0x40;
      *(void *)a1 = 1LL;
      if ((v10 & 0x80u) == 0) {
        char v17 = v13;
      }
      *(_BYTE *)(a1 + 9) = 0;
      goto LABEL_23;
    }

uint64_t sub_1808CC550(_BYTE *a1, uint64_t a2, int a3)
{
  if (!a3) {
    return a2;
  }
  uint64_t result = (a3 + a2);
  if ((int)result > 1)
  {
    int v5 = &a1[a2 - 1];
    unsigned int v6 = a3;
    if (a3 <= 49) {
      unsigned int v6 = byte_180A37148[a3];
    }
    uint64_t v7 = v6;
    int v8 = &v5[v6];
    unsigned int v9 = a3 - v6;
    unsigned int v10 = v9 + 1;
    if (v9)
    {
      int v12 = result;
      if (v5 < a1) {
        goto LABEL_22;
      }
      char v11 = 0;
      uint64_t v13 = 1LL - (int)v10;
      uint64_t v14 = (int)v10;
      unint64_t v15 = (unint64_t)&a1[v12 - 1];
      int v16 = dword_180A3717C[v13];
      int v17 = dword_180A37120[v13];
      int v18 = dword_180A37120[v14];
      do
      {
        unsigned int v19 = *v5;
        unsigned int v20 = ((v19 >> v13) * v16) >> 17;
        char v11 = v18 * (v19 - v20 * v17);
        --v5;
      }

      while (v5 >= a1);
    }

    else
    {
      if (v5 < a1) {
        goto LABEL_22;
      }
      do
      {
        v5[v7] = *v5;
        --v5;
      }

      while (v5 >= a1);
      char v11 = 0;
    }

    int v8 = &v5[v7];
    while (v8 >= a1)
    {
      *v8-- = v11;
LABEL_22:
      char v11 = 0;
    }
  }

  else
  {
    *a1 *= dword_180A37120[a3];
  }

  return result;
}

uint64_t sub_1808CC6A4(int *a1)
{
  int v1 = *a1;
  char v2 = *((_BYTE *)a1 + 8);
  char v3 = (char *)a1 + 9;
  if (*((_BYTE *)a1 + 9)) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v1 == 1;
  }
  if (v4 && (v2 & 0x70) == 0) {
    return 0LL;
  }
  int v6 = a1[1];
  if (v6 < 0)
  {
    if (-v6 < 1) {
      int v10 = -v6;
    }
    else {
      int v10 = 1;
    }
    int v11 = 1 - v6;
    do
    {
      if (*v3) {
        return 0x80000000LL;
      }
      ++v3;
      --v11;
    }

    while (v11 > 1);
    if (v10 == 1) {
      goto LABEL_21;
    }
    unsigned int v12 = *v3++;
    if ((((v12 >> (v10 - 1)) * dword_180A3717C[v10 - 1]) >> 17) * dword_180A37120[v10 - 1] != v12) {
      return 0x80000000LL;
    }
    int v7 = 2 - v10;
    if (2 != v10) {
      goto LABEL_10;
    }
    goto LABEL_21;
  }

  int v7 = a1[1];
  if (!v6)
  {
LABEL_21:
    int v13 = *v3++;
    int v8 = v13;
    int v7 = 1;
    goto LABEL_22;
  }

unsigned int *uprv_decNumberQuantize(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = 0;
  sub_1808CC880(a1, a2, a3, a4, 1, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, a4);
  }
  return a1;
}

unsigned int *sub_1808CC880(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  int v10 = *(_DWORD *)a4;
  int v28 = 0;
  int v11 = *(unsigned __int8 *)(a2 + 8);
  int v12 = *(unsigned __int8 *)(a3 + 8);
  if (((v12 | v11) & 0x70) == 0)
  {
    int v13 = *(_DWORD *)(a4 + 8) - v10 + 1;
    if (a5) {
      int v14 = *(_DWORD *)(a3 + 4);
    }
    else {
      int v14 = sub_1808CC6A4((int *)a3);
    }
    BOOL v16 = v14 + 0x80000000 <= 3 && v14 != -2147483647 || v14 < v13;
    if (!v16 && v14 <= *(_DWORD *)(a4 + 4))
    {
      int v20 = *(_DWORD *)a2;
      if (!*(_BYTE *)(a2 + 9) && (v11 & 0x70) == 0 && v20 == 1)
      {
        uprv_decNumberCopy((uint64_t)a1, (unsigned int *)a2);
        goto LABEL_36;
      }

      unsigned int v21 = *(_DWORD *)(a2 + 4);
      int v22 = v14 - v21;
      if ((int)(v20 - (v14 - v21)) <= v10)
      {
        if (v22 >= 1)
        {
          *(_OWORD *)uint64_t v27 = *(_OWORD *)a4;
          *(_OWORD *)&v27[12] = *(_OWORD *)(a4 + 12);
          *(_DWORD *)uint64_t v27 = v20 - (v14 - v21);
          *((_BYTE *)a1 + 8) = v11;
          a1[1] = v21;
          sub_1808C77A4(a1, (int *)v27, (char *)(a2 + 9), v20, &v28, a6);
          sub_1808CE50C((uint64_t)a1, v27, v28, a6);
          int v28 = 0;
          int v23 = a1[1];
          if (v23 > v14)
          {
            uint64_t v24 = *a1;
            if ((_DWORD)v24 == v10)
            {
              unsigned int v17 = *a6 & 0xFFFFF75F;
              goto LABEL_18;
            }

            unsigned int v25 = sub_1808CC550((_BYTE *)a1 + 9, v24, 1);
            int v23 = a1[1] - 1;
            *a1 = v25;
            a1[1] = v23;
          }

          int v14 = v23;
          goto LABEL_37;
        }

        uprv_decNumberCopy((uint64_t)a1, (unsigned int *)a2);
        if ((v22 & 0x80000000) == 0)
        {
          int v14 = a1[1];
          goto LABEL_37;
        }

        unsigned int v26 = sub_1808CC550((_BYTE *)a1 + 9, *a1, -v22);
        int v14 = a1[1] + v22;
        *a1 = v26;
LABEL_36:
        a1[1] = v14;
LABEL_37:
        if (v14 <= (int)(*(_DWORD *)(a4 + 4) - *a1 + 1))
        {
          sub_1808C7A24(a1, a4, &v28, a6);
          unsigned int v18 = *a6 & 0xFFFFDFFF;
          goto LABEL_19;
        }
      }
    }

uint64_t uprv_decNumberReduce(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v8 = 0LL;
  if ((*(_BYTE *)(a2 + 8) & 0x30) != 0)
  {
    sub_1808CB138(a1, a2, 0LL, a3, (_DWORD *)&v8 + 1);
  }

  else
  {
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
    int v5 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    sub_1808C77A4((_BYTE *)a1, a3, (char *)(a2 + 9), v5, (int *)&v8, (int *)&v8 + 1);
    sub_1808C7A24((unsigned int *)a1, (uint64_t)a3, (int *)&v8, (int *)&v8 + 1);
    sub_1808CCB7C((unsigned int *)a1, (uint64_t)a3, 1, 0, &v7);
  }

  if (HIDWORD(v8)) {
    sub_1808C7B8C(a1, SHIDWORD(v8), (uint64_t)a3);
  }
  return a1;
}

unsigned int *sub_1808CCB7C(unsigned int *a1, uint64_t a2, int a3, int a4, int *a5)
{
  *a5 = 0;
  if ((a1[2] & 0x70) == 0)
  {
    int v6 = (char *)a1 + 9;
    if ((*((_BYTE *)a1 + 9) & 1) == 0)
    {
      uint64_t v8 = *a1;
      if (*((_BYTE *)a1 + 9)) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = (_DWORD)v8 == 1;
      }
      if (v9)
      {
        a1[1] = 0;
      }

      else if ((int)v8 >= 2)
      {
        uint64_t v11 = 0LL;
        int v12 = v8 - 1;
        int v13 = a1[1];
        while (!(-10 * ((26215 * (*((unsigned __int8 *)a1 + v11 + 9) >> 1)) >> 17)
                + *((unsigned __int8 *)a1 + v11 + 9)))
        {
          if (!a3 && v13 <= 0)
          {
            if (!v13) {
              break;
            }
            ++v13;
          }

          if (v12 == (_DWORD)++v11) {
            goto LABEL_19;
          }
        }

        int v12 = v11;
LABEL_19:
        if (v12)
        {
          if (a4 || !*(_BYTE *)(a2 + 24)) {
            goto LABEL_25;
          }
          int v15 = *(_DWORD *)(a2 + 4) - (a1[1] + *(_DWORD *)a2);
          if (v12 >= v15 + 1) {
            int v12 = v15 + 1;
          }
          if (v15 + 1 >= 1)
          {
LABEL_25:
            sub_1808CD06C(v6, v8, v12);
            unsigned int v16 = a1[1] + v12;
            *a1 -= v12;
            a1[1] = v16;
            *a5 = v12;
          }
        }
      }
    }
  }

  return a1;
}

unsigned int *uprv_decNumberRescale(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = 0;
  sub_1808CC880(a1, a2, a3, a4, 0, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, a4);
  }
  return a1;
}

uint64_t uprv_decNumberRemainder(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8BD0(a1, a2, a3, a4, 64, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberRemainderNear(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C8BD0(a1, a2, a3, a4, 16, &v7);
  if (v7) {
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
  }
  return a1;
}

uint64_t uprv_decNumberRotate(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v39 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x30) != 0 || (*(_BYTE *)(a3 + 8) & 0x30) != 0)
  {
    sub_1808CB138(a1, a2, a3, a4, &v39);
    int v7 = v39;
    if (!v39) {
      return a1;
    }
    goto LABEL_10;
  }

  if ((*(_BYTE *)(a3 + 8) & 0x40) != 0
    || *(_DWORD *)(a3 + 4)
    || (int v8 = sub_1808CC6A4((int *)a3), v9 = v8, v8 + 0x80000000 <= 3) && v8 != -2147483647
    || (v8 >= 0 ? (int v11 = v8) : (int v11 = -v8), v11 > *a4))
  {
    int v7 = 128;
LABEL_10:
    sub_1808C7B8C(a1, v7, (uint64_t)a4);
    return a1;
  }

  uprv_decNumberCopy(a1, (unsigned int *)a2);
  if (v9 < 0) {
    v9 += *a4;
  }
  if (v9)
  {
    int v12 = *a4;
    if (v9 != *a4 && (*(_BYTE *)(a1 + 8) & 0x40) == 0)
    {
      int v14 = (unsigned __int8 *)(a1 + 9);
      unsigned int v13 = *(_DWORD *)a1;
      int v15 = &v14[v13];
      unsigned int v16 = *a4;
      if (v12 <= 49) {
        unsigned int v16 = byte_180A37148[v12];
      }
      unsigned int v17 = &v14[v16 - 1];
      if (v15 <= v17)
      {
        uint64_t v18 = a1 + v13;
        unint64_t v19 = a1 + v16 + 9;
        if (v18 + 10 > v19) {
          unint64_t v19 = v18 + 10;
        }
        bzero(v15, v19 - v18 - 9);
        int v12 = *a4;
      }

      *(_DWORD *)a1 = v12;
      int v20 = v12;
      if (v12 <= 49) {
        int v20 = byte_180A37148[v12];
      }
      uint64_t v21 = (v12 - v9);
      if (v12 != v9)
      {
        int v22 = v12 - v20;
        int v23 = v22 + 1;
        if (v22)
        {
          unsigned int v24 = *v14 % dword_180A37120[-v22];
          sub_1808CD06C((_BYTE *)(a1 + 9), v21, -v22);
          *v17 += dword_180A37120[v23] * v24;
        }

        unsigned int v25 = &v14[v21];
        if (v25 < v17)
        {
          unint64_t v26 = v21 + a1 + 10;
          uint64_t v27 = v17;
          do
          {
            unsigned __int8 v28 = *(_BYTE *)(v26 - 1);
            *(_BYTE *)(v26 - 1) = *v27;
            *v27-- = v28;
            BOOL v29 = v26++ >= (unint64_t)v27;
          }

          while (!v29);
        }

        int v30 = v25 - 1;
        if (v14 < v30)
        {
          unint64_t v31 = a1 + 10;
          do
          {
            unsigned __int8 v32 = *(_BYTE *)(v31 - 1);
            *(_BYTE *)(v31 - 1) = *v30;
            *v30-- = v32;
            BOOL v29 = v31++ >= (unint64_t)v30;
          }

          while (!v29);
        }

        if (v14 < v17)
        {
          unint64_t v33 = a1 + 10;
          int v34 = v17;
          do
          {
            unsigned __int8 v35 = *(_BYTE *)(v33 - 1);
            *(_BYTE *)(v33 - 1) = *v34;
            *v34-- = v35;
            BOOL v29 = v33++ >= (unint64_t)v34;
          }

          while (!v29);
        }
      }

      int v36 = (_DWORD)v17 - (_DWORD)v14 + 1;
      if (((_DWORD)v17 - (_DWORD)v14) <= 0x7FFFFFFE)
      {
        int v37 = &v14[(_DWORD)v17 - (_DWORD)v14];
        do
        {
          if (*v37) {
            BOOL v38 = 1;
          }
          else {
            BOOL v38 = v36 == 1;
          }
          if (v38) {
            break;
          }
          --v36;
          --v37;
        }

        while (v37 >= v14);
      }

      *(_DWORD *)a1 = v36;
    }
  }

  return a1;
}

uint64_t sub_1808CD06C(_BYTE *a1, uint64_t a2, int a3)
{
  if (!a3) {
    return a2;
  }
  if (a3 == (_DWORD)a2)
  {
    *a1 = 0;
    return 1LL;
  }

  if (a3 > 49)
  {
    LODWORD(v3) = a3;
  }

  else
  {
    uint64_t v3 = byte_180A37148[a3];
    uint64_t v4 = a3 - (v3 - 1);
    if ((_DWORD)v4 != 1)
    {
      uint64_t v5 = byte_180A37148[v3 - 1];
      int v6 = dword_180A3717C[v4];
      unsigned int v7 = ((a1[v5] >> v4) * v6) >> 17;
      uint64_t v8 = v3 - a3;
      *a1 = v7;
      int v9 = a2 - a3 - (1 - v4);
      LODWORD(v10) = (_DWORD)a1;
      if (v9 >= 1)
      {
        int v11 = dword_180A37120[v4];
        int v12 = dword_180A37120[v8];
        int v13 = ~a3 + a2;
        uint64_t v14 = v5 + 1;
        int v10 = a1;
        do
        {
          unsigned int v15 = v10[v14];
          unsigned int v16 = ((v15 >> v4) * v6) >> 17;
          *int v10 = v7 + (v15 - v16 * v11) * v12;
          BOOL v17 = __OFSUB__(v13--, 1);
          if (v13 < 0 != v17) {
            break;
          }
          *++int v10 = v16;
          int v9 = v9 - v4 - v8;
          unsigned int v7 = ((v15 >> v4) * v6) >> 17;
        }

        while (v9 > 0);
      }

      return ((_DWORD)v10 - (_DWORD)a1 + 1);
    }
  }

  LODWORD(v18) = (_DWORD)a1;
  if (v3 < (uint64_t)(int)a2)
  {
    uint64_t v18 = a1;
    do
    {
      *uint64_t v18 = v18[v3];
      ++v18;
    }

    while (&v18[v3] < &a1[(int)a2]);
  }

  return ((_DWORD)v18 - (_DWORD)a1);
}

double uprv_decNumberSameQuantum(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v3 = *(_BYTE *)(a2 + 8);
  unsigned int v4 = *(unsigned __int8 *)(a3 + 8);
  if (((v4 | v3) & 0x70) != 0)
  {
    int v5 = v3 & 0x30;
    int v6 = v4 & 0x30;
    int v7 = (v4 >> 6) & 1;
    if ((*(_BYTE *)(a2 + 8) & 0x40) != 0) {
      BOOL v8 = v7;
    }
    else {
      BOOL v8 = 0;
    }
    if (v5) {
      BOOL v9 = v6 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9) {
      BOOL v8 = 1;
    }
  }

  else
  {
    BOOL v8 = *(_DWORD *)(a2 + 4) == *(_DWORD *)(a3 + 4);
  }

  *(_BYTE *)(a1 + 8) = 0;
  *(void *)&double result = 1LL;
  *(void *)a1 = 1LL;
  *(_BYTE *)(a1 + 9) = v8;
  return result;
}

uint64_t uprv_decNumberScaleB(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v13 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x30) != 0 || (*(_BYTE *)(a3 + 8) & 0x30) != 0)
  {
    sub_1808CB138(a1, a2, a3, a4, &v13);
    goto LABEL_4;
  }

  if ((*(_BYTE *)(a3 + 8) & 0x40) == 0 && !*(_DWORD *)(a3 + 4))
  {
    int v8 = sub_1808CC6A4((int *)a3);
    int v9 = v8;
    if (v8 + 0x80000000 > 3 || v8 == -2147483647)
    {
      int v11 = v8 >= 0 ? v8 : -v8;
      if (v11 <= 2 * (a4[1] + *a4))
      {
        uprv_decNumberCopy(a1, (unsigned int *)a2);
        if ((*(_BYTE *)(a1 + 8) & 0x40) == 0)
        {
          *(_DWORD *)(a1 + 4) += v9;
          int v12 = 0;
          sub_1808C7A24((unsigned int *)a1, (uint64_t)a4, &v12, &v13);
        }

unsigned int *uprv_decNumberShift(unsigned int *a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v18 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x30) != 0 || (*(_BYTE *)(a3 + 8) & 0x30) != 0)
  {
    sub_1808CB138((uint64_t)a1, a2, a3, a4, &v18);
    int v7 = v18;
    if (!v18) {
      return a1;
    }
    goto LABEL_10;
  }

  if ((*(_BYTE *)(a3 + 8) & 0x40) != 0
    || *(_DWORD *)(a3 + 4)
    || (int v8 = sub_1808CC6A4((int *)a3), v9 = v8, v8 + 0x80000000 <= 3) && v8 != -2147483647
    || (v8 >= 0 ? (int v11 = v8) : (int v11 = -v8), v11 > *a4))
  {
    int v7 = 128;
LABEL_10:
    sub_1808C7B8C((uint64_t)a1, v7, (uint64_t)a4);
    return a1;
  }

  uprv_decNumberCopy((uint64_t)a1, (unsigned int *)a2);
  if (v9 && (a1[2] & 0x40) == 0)
  {
    if (v9 < 1)
    {
      uint64_t v16 = *a1;
      if ((int)v16 > -v9)
      {
        sub_1808CD06C((_BYTE *)a1 + 9, v16, -v9);
        int v17 = *a1 + v9;
        goto LABEL_30;
      }
    }

    else
    {
      int v12 = *a4;
      if (v9 != *a4)
      {
        uint64_t v13 = *a1;
        BOOL v14 = __OFSUB__(v13 + v9, v12);
        int v15 = v13 + v9 - v12;
        if (!((v15 < 0) ^ v14 | (v15 == 0)))
        {
          sub_1808CD480((int *)a1, v15);
          uint64_t v13 = *a1;
        }

        return a1;
      }
    }

    *((_BYTE *)a1 + 9) = 0;
    int v17 = 1;
LABEL_30:
    *a1 = v17;
  }

  return a1;
}

int *sub_1808CD480(int *result, int a2)
{
  char v2 = (char *)result + 9;
  uint64_t v3 = *result;
  if ((int)v3 <= a2)
  {
    _BYTE *v2 = 0;
    int v7 = 1;
  }

  else
  {
    uint64_t v4 = v3 - a2;
    int v5 = v4;
    int v6 = v4 - v5 + 1;
    if (v6 != 1) {
      v2[v5 - 1] = v2[v5 - 1] % dword_180A37120[v6];
    }
    int v7 = v5;
    if ((v5 - 1) <= 0x7FFFFFFE)
    {
      int v8 = &v2[v5 - 1];
      do
      {
        if (*v8) {
          BOOL v9 = 1;
        }
        else {
          BOOL v9 = v7 == 1;
        }
        if (v9) {
          break;
        }
        --v7;
        --v8;
      }

      while (v8 >= v2);
    }
  }

  *double result = v7;
  return result;
}

uint64_t uprv_decNumberSquareRoot(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  __int128 v72 = 0uLL;
  int v74 = 0;
  uint64_t v73 = 0LL;
  int v70 = 0;
  uint64_t v68 = 0LL;
  uint64_t v69 = 0LL;
  int v67 = 0;
  memset(v80, 0, 48);
  memset(v79, 0, 60);
  memset(v78, 0, 60);
  unint64_t v75 = 0LL;
  uint64_t v76 = 0LL;
  uint64_t v77 = 0LL;
  if ((*(_BYTE *)(a2 + 8) & 0x70) != 0)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x40) == 0)
    {
      sub_1808CB138(a1, a2, 0LL, (int *)a3, &v68);
      goto LABEL_71;
    }

    if ((*(_BYTE *)(a2 + 8) & 0x80) == 0)
    {
      uprv_decNumberCopy(a1, (unsigned int *)a2);
      goto LABEL_71;
    }

    goto LABEL_21;
  }

  int v6 = *(int *)(a2 + 4) >> 1;
  if (!*(_BYTE *)(a2 + 9) && *(_DWORD *)a2 == 1)
  {
    int v7 = (unsigned int *)uprv_decNumberCopy(a1, (unsigned int *)a2);
    *(_DWORD *)(a1 + 4) = v6;
    sub_1808C7A24(v7, a3, (int *)&v68 + 1, (int *)&v68);
    goto LABEL_71;
  }

  if ((*(_BYTE *)(a2 + 8) & 0x80) != 0)
  {
LABEL_21:
    int v14 = 128;
    goto LABEL_72;
  }

  int v8 = *(_DWORD *)a2;
  if (*(_DWORD *)a3 + 1 > *(_DWORD *)a2) {
    int v9 = *(_DWORD *)a3 + 1;
  }
  else {
    int v9 = *(_DWORD *)a2;
  }
  if (v9 <= 7) {
    uint64_t v10 = 7LL;
  }
  else {
    uint64_t v10 = v9;
  }
  if (v8 <= 49) {
    int v8 = byte_180A37148[v8];
  }
  size_t v11 = (v8 + 11);
  if ((int)v11 < 49)
  {
    int v12 = 0LL;
    uint64_t v13 = v80;
  }

  else
  {
    int v12 = uprv_malloc(v11);
    uint64_t v13 = v12;
    if (!v12)
    {
      int v14 = 16;
LABEL_72:
      sub_1808C7B8C(a1, v14, a3);
      return a1;
    }
  }

  uint64_t v15 = v10 + 2;
  int v16 = v10 + 2;
  memset(v71, 0, 28);
  int v65 = 0;
  int v66 = 0;
  size_t v17 = (v16 + 11);
  if ((int)v17 < 61)
  {
    int v60 = v6;
    int v61 = 0LL;
    int v62 = 0LL;
    uint64_t v21 = (int *)v78;
    int v18 = (unsigned int *)v79;
    goto LABEL_30;
  }

  int v18 = (unsigned int *)uprv_malloc((v16 + 11));
  unint64_t v19 = uprv_malloc(v17);
  int v20 = v19;
  if (v18 && v19)
  {
    int v60 = v6;
    int v61 = v19;
    int v62 = v18;
    uint64_t v21 = (int *)v19;
LABEL_30:
    uprv_decNumberCopy((uint64_t)v13, (unsigned int *)a2);
    int v22 = *v13 + v13[1];
    v13[1] = -*v13;
    uprv_decContextDefault((uint64_t)&v72, 64);
    *(void *)((char *)&v72 + 4) = 0xC46536013B9AC9FFLL;
    LODWORD(v72) = v10;
    LOBYTE(v76) = 0;
    LODWORD(v75) = 3;
    *((_BYTE *)v18 + 8) = 0;
    *int v18 = 3;
    if ((v22 & 1) != 0)
    {
      ++v22;
      char v23 = 2;
      char v24 = 5;
      --v13[1];
      char v25 = 8;
      char v26 = 1;
      int v28 = -2;
      int v27 = -4;
    }

    else
    {
      char v23 = 8;
      char v24 = 1;
      char v25 = 2;
      char v26 = 5;
      int v27 = -3;
      int v28 = -3;
    }

    HIDWORD(v75) = v27;
    v18[1] = v28;
    BYTE1(v76) = 9;
    BYTE2(v76) = v26;
    BYTE3(v76) = v25;
    *((_BYTE *)v18 + 9) = 9;
    int v63 = (char *)v18 + 9;
    *((_BYTE *)v18 + 10) = v24;
    *((_BYTE *)v18 + 11) = v23;
    BOOL v29 = (int *)sub_1808CA160((uint64_t)v18, (uint64_t)v18, (uint64_t)v13, (int *)&v72, &v67);
    sub_1808C7C34(v29, (int *)v18, (uint64_t)&v75, (int *)&v72, 0, &v67);
    LOWORD(v70) = 0;
    uint64_t v69 = 1LL;
    LOWORD(v76) = 1280;
    unint64_t v75 = 0xFFFFFFFF00000001LL;
    int v30 = 3;
    do
    {
      int v31 = 2 * v30 - 2;
      LODWORD(v72) = v31;
      unsigned __int8 v32 = (int *)sub_1808C8BD0((uint64_t)v21, (uint64_t)v13, (uint64_t)v18, (int *)&v72, 128, &v67);
      sub_1808C7C34(v32, v21, (uint64_t)v18, (int *)&v72, 0, &v67);
      sub_1808CA160((uint64_t)v18, (uint64_t)v21, (uint64_t)&v75, (int *)&v72, &v67);
      int v30 = v72;
    }

    while ((int)v72 < (int)v15);
    v71[0] = *(_OWORD *)a3;
    *(_OWORD *)((char *)v71 + 12) = *(_OWORD *)(a3 + 12);
    HIDWORD(v71[0]) = 3;
    int v34 = v22;
    int v33 = v22 + (v22 < 0);
    int v35 = *v18;
    int v36 = v18[1] + v34 / 2;
    int v66 = 0;
    HIDWORD(v68) = 0;
    v18[1] = v36;
    sub_1808C77A4(v18, (int *)v71, v63, v35, (int *)&v68 + 1, &v66);
    sub_1808C7A24(v18, (uint64_t)v71, (int *)&v68 + 1, &v66);
    int v37 = v66;
    if ((v66 & 0x200) != 0)
    {
      LODWORD(v68) = v66;
      uprv_decNumberCopy(a1, v18);
      int v20 = v61;
LABEL_64:
      int v18 = v62;
      goto LABEL_65;
    }

    unsigned int v59 = v12;
    unsigned int v38 = v33 >> 1;
    unsigned int v58 = v66 & 0xFFFFF7DF;
    LODWORD(v68) = v66 & 0xFFFFF7DF;
    int v39 = *v18;
    v18[1] -= v33 >> 1;
    LODWORD(v72) = v72 - 1;
    HIDWORD(v75) = ~v39;
    char v40 = 0x80;
    uint64_t v41 = sub_1808C7C34(v21, (int *)v18, (uint64_t)&v75, (int *)&v72, 128, &v67);
    HIDWORD(v72) = 1;
    uint64_t v42 = sub_1808CA160((uint64_t)v41, (uint64_t)v21, (uint64_t)v21, (int *)&v72, &v67);
    sub_1808C8568(v42, (uint64_t)v13, (uint64_t)v21, (int *)&v72, 1, &v67);
    if (((char)v21[2] & 0x80000000) == 0)
    {
      uint64_t v43 = sub_1808C7C34(v21, (int *)v18, (uint64_t)&v75, (int *)&v72, 0, &v67);
      HIDWORD(v72) = 5;
      uint64_t v44 = sub_1808CA160((uint64_t)v43, (uint64_t)v21, (uint64_t)v21, (int *)&v72, &v67);
      sub_1808C8568(v44, (uint64_t)v21, (uint64_t)v13, (int *)&v72, 1, &v67);
      char v40 = 0;
    }

    ++HIDWORD(v75);
    BYTE1(v76) = 1;
    BOOL v45 = sub_1808C7C34((int *)v18, (int *)v18, (uint64_t)&v75, (int *)&v72, v40, &v67);
    *(int32x2_t *)((char *)v71 + 4) = vsub_s32(*(int32x2_t *)((char *)v71 + 4), vdup_n_s32(v38));
    sub_1808C7C34(v45, (int *)&v69, (uint64_t)v18, (int *)v71, 0, &v67);
LABEL_42:
    v18[1] += v38;
    int v46 = (unsigned int *)uprv_decNumberCopy((uint64_t)v21, v18);
    sub_1808CCB7C(v46, a3, 1, 1, &v65);
    if (2 * *v21 - 1 <= (int)v10)
    {
      int v64 = 0;
      sub_1808CA160((uint64_t)v21, (uint64_t)v21, (uint64_t)v21, (int *)&v72, &v64);
      int v20 = v61;
      if ((v64 & 0x200) != 0)
      {
        unsigned int v47 = v37 | 0x820;
        LODWORD(v68) = v37 | 0x820;
        int v12 = v59;
      }

      else
      {
        sub_1808C8568((uint64_t)&v75, (uint64_t)v21, a2, (int *)&v72, 1, &v64);
        int v12 = v59;
        if (BYTE1(v76) || (_DWORD)v75 != 1 || (v76 & 0x70) != 0)
        {
          unsigned int v47 = v37 | 0x820;
        }

        else
        {
          unsigned int v53 = v18[1];
          int v54 = v60 - v53;
          if ((int)(v60 - v53) >= 0)
          {
            int v55 = *(_DWORD *)(a3 + 4) - (v53 + *(_DWORD *)a3) + 1;
            unsigned int v47 = v58;
            if (v54 > v55 && *(_BYTE *)(a3 + 24))
            {
              unsigned int v47 = v58 | 0x400;
              LODWORD(v68) = v58 | 0x400;
              int v54 = v55;
            }

            if (v65 < v54)
            {
              v47 |= 0x400u;
              LODWORD(v68) = v47;
              int v54 = v65;
            }

            if (v54 >= 1)
            {
              uint64_t v56 = *v18;
              sub_1808CD06C(v63, v56, v54);
              unsigned int v57 = v18[1] + v54;
              *v18 -= v54;
              v18[1] = v57;
              unsigned int v47 = v68;
            }

            goto LABEL_53;
          }

          unsigned int v47 = v58 | 0x800;
        }

        LODWORD(v68) = v47;
      }
    }

    else
    {
      unsigned int v47 = v37 | 0x820;
      LODWORD(v68) = v37 | 0x820;
      int v12 = v59;
      int v20 = v61;
    }

int *uprv_decNumberSubtract(int *a1, int *a2, uint64_t a3, int *a4)
{
  int v7 = 0;
  sub_1808C7C34(a1, a2, a3, a4, 128, &v7);
  if (v7) {
    sub_1808C7B8C((uint64_t)a1, v7, (uint64_t)a4);
  }
  return a1;
}

unsigned int *uprv_decNumberToIntegralExact(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  int v10 = 0;
  uint64_t v9 = 0LL;
  memset(v8, 0, 28);
  int v7 = 0;
  if ((*(_BYTE *)(a2 + 8) & 0x70) != 0)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x40) == 0)
    {
      sub_1808CB138((uint64_t)a1, a2, 0LL, (int *)a3, &v7);
      int v5 = v7;
      if (!v7) {
        return a1;
      }
      goto LABEL_8;
    }

    goto LABEL_6;
  }

  if ((*(_DWORD *)(a2 + 4) & 0x80000000) == 0)
  {
LABEL_6:
    uprv_decNumberCopy((uint64_t)a1, (unsigned int *)a2);
    return a1;
  }

  v8[0] = *(_OWORD *)a3;
  *(_OWORD *)((char *)v8 + 12) = *(_OWORD *)(a3 + 12);
  LODWORD(v8[0]) = *(_DWORD *)a2;
  LODWORD(v8[1]) = 0;
  LOWORD(v10) = 0;
  uint64_t v9 = 1LL;
  uprv_decNumberQuantize(a1, a2, (uint64_t)&v9, (uint64_t)v8);
  int v5 = DWORD1(v8[1]);
  if (DWORD1(v8[1])) {
LABEL_8:
  }
    sub_1808C7B8C((uint64_t)a1, v5, a3);
  return a1;
}

unsigned int *uprv_decNumberToIntegralValue(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)&v5[12] = *(_OWORD *)(a3 + 12);
  *(_OWORD *)int v5 = *(_OWORD *)a3;
  *(_DWORD *)&v5[16] = 0;
  double result = uprv_decNumberToIntegralExact(a1, a2, (uint64_t)v5);
  *(_DWORD *)(a3 + 20) |= v5[20] & 0x80;
  return result;
}

uint64_t uprv_decNumberXor(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (*(_DWORD *)(a2 + 4)
    || *(unsigned __int8 *)(a2 + 8) > 0xFu
    || *(_DWORD *)(a3 + 4)
    || *(unsigned __int8 *)(a3 + 8) >= 0x10u)
  {
LABEL_33:
    *(void *)a1 = 1LL;
    *(_WORD *)(a1 + 8) = 32;
    uprv_decContextSetStatus((uint64_t)a4, 128);
    return a1;
  }

  unsigned int v5 = *(_DWORD *)a2;
  unsigned int v6 = *(_DWORD *)a3;
  unint64_t v7 = a1 + 9;
  unsigned int v8 = *a4;
  unint64_t v9 = v7 + v8 - 1;
  int v10 = a1 + 9;
  if (v7 <= v9)
  {
    unint64_t v11 = a2 + 9 + v5 - 1;
    unint64_t v12 = a3 + 9 + v6 - 1;
    uint64_t v13 = 9LL;
    do
    {
      unsigned int v14 = a2 + v13 <= v11 ? *(unsigned __int8 *)(a2 + v13) : 0;
      unsigned int v15 = a3 + v13 <= v12 ? *(unsigned __int8 *)(a3 + v13) : 0;
      *(_BYTE *)(a1 + v13) = 0;
      if (v15 | v14)
      {
        if (((v15 ^ v14) & 1) != 0) {
          *(_BYTE *)(a1 + v13) = 1;
        }
      }

      int v10 = a1 + ++v13;
    }

    while (a1 + v13 <= v9);
  }

  int v16 = v10 - v7;
  if (v10 - (int)v7 >= 1)
  {
    size_t v17 = (_BYTE *)(v7 + (v16 - 1));
    int v18 = v10 - a1 - 10;
    do
    {
      if (*v17) {
        BOOL v19 = 1;
      }
      else {
        BOOL v19 = v18 == 0;
      }
      if (v19) {
        break;
      }
      --v17;
      --v18;
    }

    while ((unint64_t)v17 >= v7);
    int v16 = v18 + 1;
  }

  *(_DWORD *)a1 = v16;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  return a1;
}

const char *uprv_decNumberClassToString(unsigned int a1)
{
  if (a1 > 9) {
    return "Invalid";
  }
  else {
    return off_189722818[a1];
  }
}

uint64_t uprv_decNumberCopyNegate(uint64_t a1, unsigned int *a2)
{
  uint64_t result = uprv_decNumberCopy(a1, a2);
  *(_BYTE *)(result + 8) ^= 0x80u;
  return result;
}

unint64_t uprv_decNumberGetBCD(int *a1, unint64_t a2)
{
  char v2 = (_BYTE *)(a2 + *a1 - 1);
  if ((unint64_t)v2 >= a2)
  {
    uint64_t v3 = (char *)a1 + 9;
    do
    {
      char v4 = *v3++;
      *v2-- = v4;
    }

    while ((unint64_t)v2 >= a2);
  }

  return a2;
}

unsigned int *uprv_decNumberSetBCD(unsigned int *result, char *a2, unsigned int a3)
{
  unsigned int v3 = *result;
  if (a3)
  {
    char v4 = &a2[a3];
    unsigned int v5 = (char *)result + v3 + 8;
    do
    {
      char v6 = *a2++;
      *v5-- = v6;
    }

    while (a2 < v4);
  }

  *uint64_t result = a3;
  return result;
}

BOOL uprv_decNumberIsSubnormal(int *a1, uint64_t a2)
{
  if ((a1[2] & 0x70) != 0) {
    return 0LL;
  }
  int v2 = *a1;
  return (*((_BYTE *)a1 + 9) || v2 != 1) && v2 + a1[1] <= *(_DWORD *)(a2 + 8);
}

unsigned int *uprv_decNumberTrim(unsigned int *a1)
{
  int v4 = 0;
  uprv_decContextDefault((uint64_t)v3, 0);
  return sub_1808CCB7C(a1, (uint64_t)v3, 0, 1, &v5);
}

const char *uprv_decNumberVersion()
{
  return "decNumber 3.61";
}

uint64_t sub_1808CE154(char *a1, int a2, unsigned __int8 *a3, int a4, int a5, char *a6, int a7)
{
  unint64_t v7 = (unint64_t)&a6[a2];
  unsigned int v8 = &a6[a4];
  if (!a5) {
    goto LABEL_12;
  }
  v8 += a5;
  unint64_t v9 = &a6[a5];
  if (a5 <= a2 && a1 == a6)
  {
    int v10 = &a6[a5];
    goto LABEL_13;
  }

  if (a5 >= 1)
  {
    int v10 = a1;
    unint64_t v11 = a6;
    do
    {
      if (v10 >= &a1[a2]) {
        char v12 = 0;
      }
      else {
        char v12 = *v10;
      }
      *v11++ = v12;
      ++v10;
    }

    while (v11 < v9);
    unint64_t v9 = v11;
  }

  else
  {
LABEL_12:
    unint64_t v9 = a6;
    int v10 = a1;
  }

uint64_t sub_1808CE348(char *a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a5)
  {
    if (a5 > 49) {
      int v10 = a5 + a4;
    }
    else {
      int v10 = byte_180A37148[a5] + a4;
    }
    if (v10 < a2) {
      return 1LL;
    }
    if (a2 + 1 < v10) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v17 = v10 + 2;
    if (v17 < 0x4A)
    {
      char v19 = 0LL;
      unsigned int v18 = (char *)v24;
    }

    else
    {
      unsigned int v18 = (char *)uprv_malloc((int)v17);
      char v19 = v18;
      if (!v18) {
        return 0x80000000LL;
      }
    }

    memset(v24, 0, 73);
    uint64_t v16 = 0xFFFFFFFFLL;
    unsigned int v20 = sub_1808CE154(a1, a2, a3, a4, a5, v18, -1);
    if ((v20 & 0x80000000) == 0)
    {
      unint64_t v21 = (unint64_t)&v18[v20 - 1];
      if ((unint64_t)v18 < v21)
      {
        uint64_t v22 = v20 - 1LL;
        while (!*v18)
        {
          ++v18;
          if (!--v22)
          {
            unsigned int v18 = (char *)v21;
            break;
          }
        }
      }

      uint64_t v16 = *v18 != 0;
    }

    if (v19) {
      uprv_free(v19);
    }
  }

  else
  {
    if (a2 > a4) {
      return 1LL;
    }
    if (a2 < a4) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = a2 - 1LL;
    char v12 = (unsigned __int8 *)&a1[v11];
    unint64_t v13 = &a3[v11];
    while (v12 >= (unsigned __int8 *)a1)
    {
      unsigned int v14 = *v12;
      unsigned int v15 = *v13;
      if (v14 > v15) {
        return 1LL;
      }
      --v12;
      --v13;
      if (v14 < v15) {
        return 0xFFFFFFFFLL;
      }
    }

    return 0LL;
  }

  return v16;
}

void sub_1808CE50C(uint64_t a1, _DWORD *a2, int a3, int *a4)
{
  if (!a3) {
    return;
  }
  switch(a2[3])
  {
    case 0:
      goto LABEL_4;
    case 1:
      goto LABEL_4;
    case 2:
      if (a3 <= 4) {
        return;
      }
      goto LABEL_39;
    case 3:
      if (a3 <= 5 && (a3 != 5 || (*(_BYTE *)(a1 + 9) & 1) == 0)) {
        return;
      }
      goto LABEL_39;
    case 4:
      if (a3 <= 5) {
        return;
      }
      goto LABEL_39;
    case 5:
      goto LABEL_17;
    case 6:
      if (*(char *)(a1 + 8) < 0)
      {
LABEL_4:
        if (a3 <= 0) {
          return;
        }
LABEL_39:
        int v9 = *(_DWORD *)a1;
        if (*(_DWORD *)a1 >= 2u)
        {
          char v19 = (_BYTE *)((v9 - 2) + a1 + 10);
          unsigned int v21 = *(_DWORD *)a1;
          uint64_t v22 = (_BYTE *)(a1 + 9);
          do
          {
            if (*v22 != 9) {
              goto LABEL_53;
            }
            --v21;
            ++v22;
          }

          while (v21 >= 2);
          int v20 = 1;
        }

        else
        {
          char v19 = (_BYTE *)(a1 + 9);
          int v20 = *(_DWORD *)a1;
        }

        if (dword_180A37120[v20] - 1 == *v19)
        {
          *char v19 = dword_180A37120[v20 - 1];
          if ((unint64_t)(v19 - 1) >= a1 + 9)
          {
            uint64_t v23 = (uint64_t)(v19 - 2);
            bzero((void *)(v23 + 1), (size_t)&v19[~v23]);
            int v9 = *(_DWORD *)a1;
          }

          int v24 = *(_DWORD *)(a1 + 4) + 1;
          *(_DWORD *)(a1 + 4) = v24;
          if (v9 + v24 > a2[1] + 1) {
            sub_1808CE830((_BYTE *)a1, (uint64_t)a2, a4);
          }
          return;
        }

_BYTE *sub_1808CE830(_BYTE *result, uint64_t a2, _DWORD *a3)
{
  int v4 = result;
  char v5 = result[8];
  if (result[9] || (*(_DWORD *)result == 1 ? (BOOL v6 = (v5 & 0x70) == 0) : (BOOL v6 = 0), !v6))
  {
    char v7 = v5 & 0x80;
    *((_WORD *)result + 4) = 0;
    *(void *)uint64_t result = 1LL;
    switch(*(_DWORD *)(a2 + 12))
    {
      case 0:
        if (v5 < 0) {
          goto LABEL_7;
        }
        goto LABEL_15;
      case 5:
      case 7:
        goto LABEL_7;
      case 6:
        if (v5 < 0) {
          goto LABEL_15;
        }
LABEL_7:
        uint64_t result = sub_1808CB7E0((uint64_t)result, (int *)a2);
        break;
      default:
LABEL_15:
        v7 |= 0x40u;
        break;
    }

    v4[8] = v7;
    int v9 = 2592;
    goto LABEL_17;
  }

  int v8 = *(_DWORD *)(a2 + 4);
  if (*(_BYTE *)(a2 + 24)) {
    int v8 = v8 - *(_DWORD *)a2 + 1;
  }
  if (*((_DWORD *)result + 1) > v8)
  {
    *((_DWORD *)result + 1) = v8;
    int v9 = 1024;
LABEL_17:
    *a3 |= v9;
  }

  return result;
}

void sub_1808CE910(unsigned int *a1, uint64_t a2, int *a3, int *a4)
{
  int v7 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2 + 1;
  int v8 = (char *)a1 + 9;
  if (!*((_BYTE *)a1 + 9) && *a1 == 1 && (a1[2] & 0x70) == 0)
  {
    a1[1] = v7;
    goto LABEL_17;
  }

  int v9 = *a4;
  *a4 |= 0x1000u;
  unsigned int v10 = a1[1];
  BOOL v11 = __OFSUB__(v7, v10);
  int v12 = v7 - v10;
  if ((v12 < 0) ^ v11 | (v12 == 0))
  {
    if ((v9 & 0x20) == 0) {
      return;
    }
    int v16 = v9 | 0x3000;
    goto LABEL_18;
  }

  *(_OWORD *)int v17 = *(_OWORD *)a2;
  *(_OWORD *)&v17[3] = *(_OWORD *)(a2 + 12);
  int v13 = *a1;
  v17[0] = *a1 - v12;
  v17[2] -= v12;
  sub_1808C77A4(a1, v17, (char *)a1 + 9, v13, a3, a4);
  sub_1808CE50C((uint64_t)a1, v17, *a3, a4);
  if ((*a4 & 0x20) != 0) {
    *a4 |= 0x2000u;
  }
  if ((int)a1[1] > v7)
  {
    unsigned int v14 = sub_1808CC550(v8, *a1, 1);
    int v15 = a1[1] - 1;
    *a1 = v14;
    a1[1] = v15;
  }

  if (!*v8 && *a1 == 1 && (a1[2] & 0x70) == 0)
  {
LABEL_17:
    int v16 = *a4 | 0x400;
LABEL_18:
    *a4 = v16;
  }

void *icu::DecimalFormat::getStaticClassID(icu::DecimalFormat *this)
{
  return &unk_18C535301;
}

void *icu::DecimalFormat::getDynamicClassID(icu::DecimalFormat *this)
{
  return &unk_18C535301;
}

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat(icu::DecimalFormat *this, UErrorCode *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v4 = icu::DecimalFormat::DecimalFormat(this, 0LL, a2);
  if (*(int *)a2 <= 0)
  {
    char v5 = (const char *)icu::Locale::getDefault(v4)[5];
    uint64_t Instance = icu::NumberingSystem::createInstance((icu::NumberingSystem *)a2, v6);
    memset(v13, 0, sizeof(v13));
    icu::Locale::Locale((icu::Locale *)v12, v5, 0LL, 0LL, 0LL);
    Name = (const char *)icu::NumberingSystem::getName(Instance);
    int v9 = sub_18093F458((uint64_t)v12, Name, 0, (int *)a2);
    icu::UnicodeString::UnicodeString((uint64_t)v13, (uint64_t)v9);
    icu::Locale::~Locale((icu::Locale *)v12);
    icu::DecimalFormat::touch(this, a2);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
    if (Instance) {
      (*(void (**)(icu::NumberingSystem *))(*(void *)Instance + 8LL))(Instance);
    }
  }

  return this;
}

{
  icu::Locale *v4;
  const char *v5;
  UErrorCode *v6;
  icu::NumberingSystem *Instance;
  const char *Name;
  const UChar *v9;
  void *v10;
  _BYTE v12[224];
  _OWORD v13[4];
  uint64_t v14;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v4 = icu::DecimalFormat::DecimalFormat(this, 0LL, a2);
  if (*(int *)a2 <= 0)
  {
    char v5 = (const char *)icu::Locale::getDefault(v4)[5];
    uint64_t Instance = icu::NumberingSystem::createInstance((icu::NumberingSystem *)a2, v6);
    memset(v13, 0, sizeof(v13));
    icu::Locale::Locale((icu::Locale *)v12, v5, 0LL, 0LL, 0LL);
    Name = (const char *)icu::NumberingSystem::getName(Instance);
    int v9 = sub_18093F458((uint64_t)v12, Name, 0, (int *)a2);
    icu::UnicodeString::UnicodeString((uint64_t)v13, (uint64_t)v9);
    icu::Locale::~Locale((icu::Locale *)v12);
    icu::DecimalFormat::touch(this, a2);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
    if (Instance) {
      (*(void (**)(icu::NumberingSystem *))(*(void *)Instance + 8LL))(Instance);
    }
  }

  return this;
}

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat( icu::DecimalFormat *this, const icu::DecimalFormatSymbols *a2, UErrorCode *a3)
{
  v7.n128_f64[0] = icu::NumberFormat::NumberFormat(this);
  *int v8 = off_189722878;
  v8[45] = 0LL;
  int v9 = (uint64_t *)*(unsigned int *)a3;
  if ((int)v9 <= 0)
  {
    unsigned int v10 = icu::UMemory::operator new(v9, (icu::UMemory *)0x11C0, v6);
    if (!v10)
    {
      *((void *)this + 45) = 0LL;
      *a3 = U_MEMORY_ALLOCATION_ERROR;
      if (!a2) {
        return this;
      }
      goto LABEL_3;
    }

    uint64_t v11 = sub_1808D3D40((uint64_t)v10);
    *((void *)this + 45) = v11;
    uint64_t v14 = v11 + 768;
    if (!a2)
    {
      int v15 = (const icu::DecimalFormatSymbols *)icu::UMemory::operator new(v13, (icu::UMemory *)0xB48, v12);
      a2 = v15;
      if (v15) {
        icu::DecimalFormatSymbols::DecimalFormatSymbols(v15, a3);
      }
    }

    sub_1807C9194(v14, (uint64_t)a2, (int *)a3);
    if (*(int *)a3 >= 1)
    {
      int v16 = (void *)*((void *)this + 45);
      if (v16)
      {
        sub_1808D42E8(v16 + 471);
        uint64_t v17 = v16[470];
        if (v17) {
          (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
        }
        sub_1808D3EFC(v16 + 162);
        icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v16 + 97));
        uint64_t v18 = v16[96];
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }
        sub_1808D42E8(v16 + 1);
        icu::UMemory::operator delete(v16);
      }

      *((void *)this + 45) = 0LL;
    }
  }

  else if (a2)
  {
LABEL_3:
    (*(void (**)(const icu::DecimalFormatSymbols *, __n128))(*(void *)a2 + 8LL))(a2, v7);
  }

  return this;
}

uint64_t icu::DecimalFormat::setPropertiesFromPattern( uint64_t this, const icu::UnicodeString *a2, int a3, UErrorCode *a4)
{
  return this;
}

void icu::DecimalFormat::touch(icu::DecimalFormat *this, UErrorCode *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    if (*((void *)this + 45))
    {
      int v4 = (const icu::DecimalFormatSymbols *)(*(uint64_t (**)(icu::DecimalFormat *))(*(void *)this + 320LL))(this);
      memset(v24, 0, sizeof(v24));
      icu::Locale::Locale((icu::Locale *)v24, (uint64_t)v4 + 1936);
      sub_18092FE6C( *((void *)this + 45) + 8LL,  v4,  *((void *)this + 45) + 1288LL,  *((void *)this + 45) + 3768LL,  (const icu::UnicodeString *)a2,  (uint64_t)v14);
      icu::number::UnlocalizedNumberFormatter::locale((uint64_t)v14, (uint64_t)v24, (uint64_t)&v22);
      icu::number::LocalizedNumberFormatter::operator=(*((void *)this + 45) + 776LL, (uint64_t)&v22);
      icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)&v22);
      icu::Locale::~Locale((icu::Locale *)&v21);
      icu::number::impl::StringProp::~StringProp(&v20);
      icu::number::impl::StringProp::~StringProp(&v19);
      icu::number::Scale::~Scale((icu::number::Scale *)&v18);
      icu::number::impl::SymbolsWrapper::~SymbolsWrapper((icu::number::impl::SymbolsWrapper *)&v17);
      icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)&v16);
      icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)&v15);
      uint64_t v5 = *((void *)this + 45);
      uint64_t v6 = *(void *)(v5 + 768);
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
      *(void *)(v5 + 768) = 0LL;
      icu::DecimalFormat::setupFastFormat(this);
      __n128 v7 = (unint64_t *)(*((void *)this + 45) + 1272LL);
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(0LL, v7));
      if (v8) {
        (*(void (**)(unint64_t))(*(void *)v8 + 8LL))(v8);
      }
      int v9 = (unint64_t *)(*((void *)this + 45) + 1280LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(0LL, v9));
      if (v10) {
        (*(void (**)(unint64_t))(*(void *)v10 + 8LL))(v10);
      }
      __int128 v22 = 0u;
      v23[0] = 0u;
      uint64_t v11 = *((void *)this + 45);
      if (*(_BYTE *)(v11 + 3776)) {
        *a2 = U_UNDEFINED_VARIABLE;
      }
      icu::CurrencyUnit::CurrencyUnit((icu::CurrencyUnit *)&v22, (const UChar *)(v11 + 3784));
      unint64_t v12 = (const UChar *)&unk_180A479F2;
      if (*(int *)a2 <= 0)
      {
        unint64_t v12 = (const UChar *)v23 + 2;
        Currency = (const UChar *)icu::NumberFormat::getCurrency(this);
        if (!u_strcmp((const UChar *)v23 + 2, (const UChar *)L"XXX"))
        {
          if (u_strcmp(Currency, (const UChar *)L"XXX")) {
            unint64_t v12 = (const UChar *)&unk_180A479F2;
          }
        }
      }

      icu::NumberFormat::setCurrency((UChar *)this, v12, (int *)a2);
      icu::NumberFormat::setMaximumIntegerDigits(this, *(unsigned int *)(*((void *)this + 45) + 3860LL));
      icu::NumberFormat::setMinimumIntegerDigits(this, *(unsigned int *)(*((void *)this + 45) + 3880LL));
      icu::NumberFormat::setMaximumFractionDigits(this, *(unsigned int *)(*((void *)this + 45) + 3856LL));
      icu::NumberFormat::setMinimumFractionDigits(this, *(unsigned int *)(*((void *)this + 45) + 3872LL));
      icu::NumberFormat::setGroupingUsed((uint64_t)this, *(_BYTE *)(*((void *)this + 45) + 88LL));
      icu::CurrencyUnit::~CurrencyUnit((icu::CurrencyUnit *)&v22);
      icu::Locale::~Locale((icu::Locale *)v24);
    }

    else
    {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat( icu::DecimalFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    icu::number::impl::PatternParser::parseToExistingProperties(a2, *((void *)this + 45) + 8LL);
    icu::DecimalFormat::touch(this, a3);
  }

  return this;
}

{
  icu::DecimalFormat::DecimalFormat(this, 0LL, a3);
  if (*(int *)a3 <= 0)
  {
    icu::number::impl::PatternParser::parseToExistingProperties(a2, *((void *)this + 45) + 8LL);
    icu::DecimalFormat::touch(this, a3);
  }

  return this;
}

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat( icu::DecimalFormat *this, const icu::UnicodeString *a2, icu::DecimalFormatSymbols *a3, UErrorCode *a4)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(this, a3, a4);
  if (*(int *)a4 <= 0)
  {
    icu::Locale::Locale((icu::Locale *)v9, (uint64_t)a3 + 1936);
    icu::DecimalFormat::setPropertiesFromPattern((uint64_t)this, a2, 1, (const icu::Locale *)v9, a4);
    icu::Locale::~Locale((icu::Locale *)v9);
    icu::DecimalFormat::touch(this, a4);
  }

  return this;
}

{
  _BYTE v9[224];
  uint64_t v10;
  uint64_t v10 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(this, a3, a4);
  if (*(int *)a4 <= 0)
  {
    icu::Locale::Locale((icu::Locale *)v9, (uint64_t)a3 + 1936);
    icu::DecimalFormat::setPropertiesFromPattern((uint64_t)this, a2, 1, (const icu::Locale *)v9, a4);
    icu::Locale::~Locale((icu::Locale *)v9);
    icu::DecimalFormat::touch(this, a4);
  }

  return this;
}

uint64_t icu::DecimalFormat::setPropertiesFromPattern( uint64_t this, const icu::UnicodeString *a2, int a3, const icu::Locale *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    uint64_t v7 = this;
    this = icu::number::impl::PatternParser::parseToExistingProperties(a2, *(void *)(this + 360) + 8LL);
    if (*(int *)a5 <= 0)
    {
      this = sub_18093F7A4((uint64_t)a4);
      *(_DWORD *)(*(void *)(v7 + 360) + 116LL) = this;
    }
  }

  return this;
}

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat( icu::DecimalFormat *a1, const icu::UnicodeString *a2, icu::DecimalFormatSymbols *a3, unsigned int a4, UErrorCode *a5)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(a1, a3, a5);
  if (*(int *)a5 <= 0)
  {
    if (a4 > 0x10 || ((1 << a4) & 0x13C04) == 0)
    {
      icu::Locale::Locale((icu::Locale *)v17, (uint64_t)a3 + 1936);
      icu::DecimalFormat::setPropertiesFromPattern((uint64_t)a1, a2, 1, (const icu::Locale *)v17, a5);
      icu::Locale::~Locale((icu::Locale *)v17);
      goto LABEL_14;
    }

    icu::Locale::Locale((icu::Locale *)v17, (uint64_t)a3 + 1936);
    icu::DecimalFormat::setPropertiesFromPattern((uint64_t)a1, a2, 2, (const icu::Locale *)v17, a5);
    icu::Locale::~Locale((icu::Locale *)v17);
    if (a4 != 11)
    {
LABEL_14:
      icu::DecimalFormat::touch(a1, a5);
      return a1;
    }

    unint64_t v12 = icu::UMemory::operator new(v11, (icu::UMemory *)0x28, v10);
    if (v12)
    {
      int v13 = (icu::CurrencyPluralInfo *)v12;
      icu::Locale::Locale((icu::Locale *)v17, *(void *)(*((void *)a1 + 45) + 768LL) + 1936LL);
      icu::CurrencyPluralInfo::CurrencyPluralInfo(v13, (const icu::Locale *)v17, a5);
      icu::Locale::~Locale((icu::Locale *)v17);
      if (*(int *)a5 > 0)
      {
        (*(void (**)(icu::CurrencyPluralInfo *))(*(void *)v13 + 8LL))(v13);
        return a1;
      }

      uint64_t v14 = *((void *)a1 + 45);
      uint64_t v15 = *(void *)(v14 + 56);
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
      }
      *(void *)(v14 + 56) = v13;
      goto LABEL_14;
    }
  }

  return a1;
}

{
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  icu::CurrencyPluralInfo *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v17[224];
  uint64_t v18;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(a1, a3, a5);
  if (*(int *)a5 <= 0)
  {
    if (a4 > 0x10 || ((1 << a4) & 0x13C04) == 0)
    {
      icu::Locale::Locale((icu::Locale *)v17, (uint64_t)a3 + 1936);
      icu::DecimalFormat::setPropertiesFromPattern((uint64_t)a1, a2, 1, (const icu::Locale *)v17, a5);
      icu::Locale::~Locale((icu::Locale *)v17);
      goto LABEL_14;
    }

    icu::Locale::Locale((icu::Locale *)v17, (uint64_t)a3 + 1936);
    icu::DecimalFormat::setPropertiesFromPattern((uint64_t)a1, a2, 2, (const icu::Locale *)v17, a5);
    icu::Locale::~Locale((icu::Locale *)v17);
    if (a4 != 11)
    {
LABEL_14:
      icu::DecimalFormat::touch(a1, a5);
      return a1;
    }

    unint64_t v12 = icu::UMemory::operator new(v11, (icu::UMemory *)0x28, v10);
    if (v12)
    {
      int v13 = (icu::CurrencyPluralInfo *)v12;
      icu::Locale::Locale((icu::Locale *)v17, *(void *)(*((void *)a1 + 45) + 768LL) + 1936LL);
      icu::CurrencyPluralInfo::CurrencyPluralInfo(v13, (const icu::Locale *)v17, a5);
      icu::Locale::~Locale((icu::Locale *)v17);
      if (*(int *)a5 > 0)
      {
        (*(void (**)(icu::CurrencyPluralInfo *))(*(void *)v13 + 8LL))(v13);
        return a1;
      }

      uint64_t v14 = *((void *)a1 + 45);
      uint64_t v15 = *(void *)(v14 + 56);
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
      }
      *(void *)(v14 + 56) = v13;
      goto LABEL_14;
    }
  }

  return a1;
}

uint64_t icu::DecimalFormat::setParseAllInput(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 360);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 480) != a2) {
      *(_DWORD *)(v2 + 480) = a2;
    }
  }

  return result;
}

icu::DecimalFormat *icu::DecimalFormat::setAttribute( icu::DecimalFormat *this, int a2, uint64_t a3, UErrorCode *a4)
{
  int v4 = this;
  if (*(int *)a4 <= 0)
  {
    uint64_t v6 = *((void *)this + 45);
    if (v6)
    {
      switch(a2)
      {
        case 0:
          (*(void (**)(icu::DecimalFormat *, BOOL))(*(void *)this + 184LL))(this, (_DWORD)a3 != 0);
          return v4;
        case 1:
          (*(void (**)(icu::DecimalFormat *, BOOL))(*(void *)this + 208LL))(this, (_DWORD)a3 != 0);
          return v4;
        case 2:
          (*(void (**)(icu::DecimalFormat *, BOOL))(*(void *)this + 536LL))(this, (_DWORD)a3 != 0);
          return v4;
        case 3:
          goto LABEL_18;
        case 4:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 224LL);
          goto LABEL_28;
        case 5:
          (*(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 224LL))(this, a3);
LABEL_18:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)v4 + 216LL);
          goto LABEL_28;
        case 6:
          goto LABEL_21;
        case 7:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 240LL);
          goto LABEL_28;
        case 8:
          (*(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 240LL))(this, a3);
LABEL_21:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)v4 + 232LL);
          goto LABEL_28;
        case 9:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 400LL);
          goto LABEL_28;
        case 10:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 520LL);
          goto LABEL_28;
        case 11:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 280LL);
          goto LABEL_28;
        case 12:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
LABEL_10:
          int v8 = 16;
          goto LABEL_7;
        case 13:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 432LL);
          goto LABEL_28;
        case 14:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 464LL);
          goto LABEL_28;
        case 15:
          int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 528LL);
LABEL_28:
          this = v4;
          uint64_t v10 = a3;
LABEL_39:
          v9(this, v10);
          break;
        case 16:
          icu::DecimalFormat::setSignificantDigitsUsed(this, a3 != 0);
          break;
        case 17:
          icu::DecimalFormat::setMinimumSignificantDigits(this, a3);
          break;
        case 18:
          icu::DecimalFormat::setMaximumSignificantDigits(this, a3);
          break;
        case 19:
          (*(void (**)(icu::DecimalFormat *, BOOL))(*(void *)this + 192LL))(this, (_DWORD)a3 != 0);
          break;
        case 20:
          if (*(_DWORD *)(v6 + 480) != (_DWORD)a3) {
            *(_DWORD *)(v6 + 480) = a3;
          }
          break;
        case 21:
          icu::DecimalFormat::setMultiplierScale(this, a3);
          break;
        case 22:
          icu::DecimalFormat::setMinimumGroupingDigits(this, a3);
          break;
        case 23:
          icu::DecimalFormat::setCurrencyUsage(this, a3, a4);
          break;
        case 48:
          int v11 = a3 != 0;
          if (*(unsigned __int8 *)(v6 + 765) != v11)
          {
            *(_BYTE *)(v6 + 765) = v11;
            UErrorCode v12 = U_ZERO_ERROR;
            icu::DecimalFormat::touch(this, &v12);
          }

          break;
        default:
          switch(a2)
          {
            case 4096:
              icu::DecimalFormat::setFormatFailIfMoreThanMaxDigits(this, a3);
              break;
            case 4097:
              icu::DecimalFormat::setParseNoExponent(this, a3);
              break;
            case 4098:
              int v9 = *(void (**)(icu::DecimalFormat *, uint64_t))(*(void *)this + 544LL);
              uint64_t v10 = (char)a3;
              goto LABEL_39;
            case 4099:
              icu::DecimalFormat::setParseCaseSensitive(this, a3);
              break;
            case 4100:
              icu::DecimalFormat::setSignAlwaysShown(this, a3);
              break;
            default:
              goto LABEL_10;
          }

          break;
      }
    }

    else
    {
      int v8 = 7;
LABEL_7:
      *a4 = v8;
    }
  }

  return v4;
}

void icu::DecimalFormat::setSignificantDigitsUsed(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    int v3 = *(_DWORD *)(v2 + 124);
    if (a2)
    {
      if (v3 == -1 && *(_DWORD *)(v2 + 104) == -1)
      {
        int v4 = 1;
        int v5 = 6;
LABEL_9:
        *(_DWORD *)(v2 + 124) = v4;
        *(_DWORD *)(v2 + 104) = v5;
        UErrorCode v6 = U_ZERO_ERROR;
        icu::DecimalFormat::touch(this, &v6);
      }
    }

    else if (v3 != -1 || *(_DWORD *)(v2 + 104) != -1)
    {
      int v5 = -1;
      int v4 = -1;
      goto LABEL_9;
    }
  }

void icu::DecimalFormat::setMaximumSignificantDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(_DWORD *)(v2 + 104) != a2)
  {
    int v3 = *(_DWORD *)(v2 + 124);
    if ((v3 & 0x80000000) == 0 && v3 > a2) {
      *(_DWORD *)(v2 + 124) = a2;
    }
    *(_DWORD *)(v2 + 104) = a2;
    UErrorCode v4 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v4);
  }

void icu::DecimalFormat::setMinimumSignificantDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(_DWORD *)(v2 + 124) != a2)
  {
    int v3 = *(_DWORD *)(v2 + 104);
    if ((v3 & 0x80000000) == 0 && v3 < a2) {
      *(_DWORD *)(v2 + 104) = a2;
    }
    *(_DWORD *)(v2 + 124) = a2;
    UErrorCode v4 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v4);
  }

void icu::DecimalFormat::setMultiplierScale(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 132) != a2)
    {
      *(_DWORD *)(v2 + 132) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setParseNoExponent(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 476) != a2)
    {
      *(_BYTE *)(v2 + 476) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setCurrencyUsage(icu::DecimalFormat *a1, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v3 = *((void *)a1 + 45);
    if (v3)
    {
      if (*(_BYTE *)(v3 + 64) || *(_DWORD *)(v3 + 68) != a2)
      {
        *(_DWORD *)(v3 + 68) = a2;
        *(_BYTE *)(v3 + 64) = 0;
        icu::DecimalFormat::touch(a1, a3);
      }
    }

    else
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

void icu::DecimalFormat::setMinimumGroupingDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 116) != a2)
    {
      *(_DWORD *)(v2 + 116) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setParseCaseSensitive(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 464) != a2)
    {
      *(_BYTE *)(v2 + 464) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setSignAlwaysShown(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 764) != a2)
    {
      *(_BYTE *)(v2 + 764) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setFormatFailIfMoreThanMaxDigits(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 76) != a2)
    {
      *(_BYTE *)(v2 + 76) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::touchNoError(icu::DecimalFormat *this)
{
  UErrorCode v1 = U_ZERO_ERROR;
  icu::DecimalFormat::touch(this, &v1);
}

uint64_t icu::DecimalFormat::getAttribute(uint64_t a1, int a2, int *a3)
{
  if (*a3 > 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 360);
  if (!v4)
  {
    int v5 = 7;
LABEL_8:
    *a3 = v5;
    return 0xFFFFFFFFLL;
  }

  switch(a2)
  {
    case 0:
      return *(char *)(a1 + 340);
    case 1:
      return icu::NumberFormat::isGroupingUsed((icu::NumberFormat *)a1);
    case 2:
      return *(unsigned __int8 *)(v4 + 73);
    case 3:
      return icu::NumberFormat::getMaximumIntegerDigits((icu::NumberFormat *)a1);
    case 4:
    case 5:
      return icu::NumberFormat::getMinimumIntegerDigits((icu::NumberFormat *)a1);
    case 6:
      return icu::NumberFormat::getMaximumFractionDigits((icu::NumberFormat *)a1);
    case 7:
    case 8:
      return icu::NumberFormat::getMinimumFractionDigits((icu::NumberFormat *)a1);
    case 9:
      return icu::DecimalFormat::getMultiplier((icu::DecimalFormat *)a1);
    case 10:
      int v6 = *(_DWORD *)(v4 + 84);
      goto LABEL_25;
    case 11:
      uint64_t v7 = *(uint64_t (**)(void))(*(void *)a1 + 272LL);
      goto LABEL_23;
    case 12:
    case 20:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
LABEL_12:
      int v5 = 16;
      goto LABEL_8;
    case 13:
      uint64_t v7 = *(uint64_t (**)(void))(*(void *)a1 + 424LL);
      goto LABEL_23;
    case 14:
      uint64_t v7 = *(uint64_t (**)(void))(*(void *)a1 + 456LL);
LABEL_23:
      uint64_t result = v7();
      break;
    case 15:
      int v6 = *(_DWORD *)(v4 + 760);
LABEL_25:
      uint64_t result = v6 & ~(v6 >> 31);
      break;
    case 16:
      uint64_t result = *(_DWORD *)(v4 + 124) != -1 || *(_DWORD *)(v4 + 104) != -1;
      break;
    case 17:
      uint64_t result = *(unsigned int *)(v4 + 3884);
      break;
    case 18:
      uint64_t result = *(unsigned int *)(v4 + 3864);
      break;
    case 19:
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200LL))(a1);
      break;
    case 21:
      uint64_t result = *(unsigned int *)(v4 + 132);
      break;
    case 22:
      uint64_t result = *(unsigned int *)(v4 + 116);
      break;
    case 23:
      if (*(_BYTE *)(v4 + 64)) {
        uint64_t result = 0LL;
      }
      else {
        uint64_t result = *(unsigned int *)(v4 + 68);
      }
      break;
    case 48:
      uint64_t result = *(unsigned __int8 *)(v4 + 765);
      break;
    default:
      switch(a2)
      {
        case 4096:
          uint64_t result = *(unsigned __int8 *)(v4 + 76);
          break;
        case 4097:
          uint64_t result = *(unsigned __int8 *)(v4 + 476);
          break;
        case 4098:
          uint64_t result = *(unsigned __int8 *)(v4 + 72);
          break;
        case 4099:
          uint64_t result = *(unsigned __int8 *)(v4 + 464);
          break;
        case 4100:
          uint64_t result = *(unsigned __int8 *)(v4 + 764);
          break;
        default:
          goto LABEL_12;
      }

      break;
  }

  return result;
}

uint64_t icu::DecimalFormat::isDecimalSeparatorAlwaysShown(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 73);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 65;
  }
  return *v2;
}

BOOL icu::DecimalFormat::areSignificantDigitsUsed(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    Default = (_DWORD *)(v1 + 8);
  }
  else {
    Default = icu::number::impl::DecimalFormatProperties::getDefault(this);
  }
  return Default[29] != -1 || Default[24] != -1;
}

uint64_t icu::DecimalFormat::getMaximumSignificantDigits(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (unsigned int *)(v1 + 3864);
  }
  else {
    uint64_t v2 = (unsigned int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 96);
  }
  return *v2;
}

uint64_t icu::DecimalFormat::getMinimumSignificantDigits(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (unsigned int *)(v1 + 3884);
  }
  else {
    uint64_t v2 = (unsigned int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 116);
  }
  return *v2;
}

uint64_t icu::DecimalFormat::getMultiplier(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    Default = (unsigned int *)(v1 + 8);
  }
  else {
    Default = (unsigned int *)icu::number::impl::DecimalFormatProperties::getDefault(this);
  }
  uint64_t v3 = Default[30];
  if ((_DWORD)v3 == 1)
  {
    int v4 = Default[21];
    if (v4) {
      return (int)uprv_pow10(v4);
    }
    else {
      return 1LL;
    }
  }

  return v3;
}

uint64_t icu::DecimalFormat::getMultiplierScale(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (unsigned int *)(v1 + 132);
  }
  else {
    uint64_t v2 = (unsigned int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 124);
  }
  return *v2;
}

uint64_t icu::DecimalFormat::getGroupingSize(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (int *)(v1 + 84);
  }
  else {
    uint64_t v2 = (int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 76);
  }
  return *v2 & ~(*v2 >> 31);
}

uint64_t icu::DecimalFormat::getSecondaryGroupingSize(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (int *)(v1 + 760);
  }
  else {
    uint64_t v2 = (int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 752);
  }
  return *v2 & ~(*v2 >> 31);
}

uint64_t icu::DecimalFormat::isParseNoExponent(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 476);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 468;
  }
  return *v2;
}

uint64_t icu::DecimalFormat::isDecimalPatternMatchRequired(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 72);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 64;
  }
  return *v2;
}

uint64_t icu::DecimalFormat::getCurrencyUsage(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1 && !*(_BYTE *)(v1 + 64)) {
    return *(unsigned int *)(v1 + 68);
  }
  else {
    return 0LL;
  }
}

uint64_t icu::DecimalFormat::getMinimumGroupingDigits(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (unsigned int *)(v1 + 116);
  }
  else {
    uint64_t v2 = (unsigned int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 108);
  }
  return *v2;
}

uint64_t icu::DecimalFormat::isParseCaseSensitive(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 464);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 456;
  }
  return *v2;
}

uint64_t icu::DecimalFormat::isSignAlwaysShown(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 764);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 756;
  }
  return *v2;
}

uint64_t icu::DecimalFormat::isFormatFailIfMoreThanMaxDigits(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 76);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 68;
  }
  return *v2;
}

void icu::DecimalFormat::setGroupingUsed(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(unsigned __int8 *)(v2 + 88) != a2)
  {
    icu::NumberFormat::setGroupingUsed((uint64_t)this, a2);
    uint64_t v5 = *((void *)this + 45);
    *(_BYTE *)(v5 + 88) = a2 != 0;
    UErrorCode v6 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v6);
  }

void icu::DecimalFormat::setParseIntegerOnly(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 465) != a2)
    {
      icu::NumberFormat::setParseIntegerOnly((uint64_t)this, a2);
      *(_BYTE *)(*((void *)this + 45) + 465LL) = a2 != 0;
      UErrorCode v5 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v5);
    }
  }

void icu::DecimalFormat::setLenient(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    int v4 = a2 == 0;
    if (*(_BYTE *)(v2 + 468) || *(_DWORD *)(v2 + 472) != v4)
    {
      icu::NumberFormat::setLenient((uint64_t)this, a2);
      uint64_t v5 = *((void *)this + 45);
      *(_DWORD *)(v5 + 472) = v4;
      *(_BYTE *)(v5 + 468) = 0;
      UErrorCode v6 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v6);
    }
  }

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat( icu::DecimalFormat *this, const icu::UnicodeString *a2, icu::DecimalFormatSymbols *a3, UParseError *a4, UErrorCode *a5)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(this, a3, a5);
  if (*(int *)a5 <= 0)
  {
    icu::Locale::Locale((icu::Locale *)v10, (uint64_t)a3 + 1936);
    icu::DecimalFormat::setPropertiesFromPattern((uint64_t)this, a2, 1, (const icu::Locale *)v10, a5);
    icu::Locale::~Locale((icu::Locale *)v10);
    icu::DecimalFormat::touch(this, a5);
  }

  return this;
}

{
  void *v9;
  _BYTE v11[224];
  uint64_t v12;
  UErrorCode v12 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(this, a3, a5);
  if (*(int *)a5 <= 0)
  {
    icu::Locale::Locale((icu::Locale *)v11, (uint64_t)a3 + 1936);
    icu::DecimalFormat::setPropertiesFromPattern((uint64_t)this, a2, 1, (const icu::Locale *)v11, a5);
    icu::Locale::~Locale(v9, (icu::Locale *)v11);
    icu::DecimalFormat::touch(this, a5);
  }

  return this;
}

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat( icu::DecimalFormat *this, const icu::UnicodeString *a2, const icu::DecimalFormatSymbols *a3, UErrorCode *a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(this, 0LL, a4);
  int v9 = (uint64_t *)*(unsigned int *)a4;
  uint64_t v10 = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(v9, (icu::UMemory *)0xB48, v8);
  uint64_t v11 = v10;
  if (v10)
  {
    icu::DecimalFormatSymbols::DecimalFormatSymbols(v10, a3);
    if (*(int *)a4 < 1)
    {
      uint64_t v12 = *((void *)this + 45);
      uint64_t v13 = *(void *)(v12 + 768);
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      }
      *(void *)(v12 + 768) = v11;
      icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a3 + 1936);
      icu::DecimalFormat::setPropertiesFromPattern((uint64_t)this, a2, 1, (const icu::Locale *)v18, a4);
      icu::Locale::~Locale((icu::Locale *)v18);
      icu::DecimalFormat::touch(this, a4);
      return this;
    }
  }

  else if (*(int *)a4 <= 0)
  {
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }

  uint64_t v14 = (void *)*((void *)this + 45);
  if (v14)
  {
    sub_1808D42E8(v14 + 471);
    uint64_t v15 = v14[470];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    sub_1808D3EFC(v14 + 162);
    icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v14 + 97));
    uint64_t v16 = v14[96];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    sub_1808D42E8(v14 + 1);
    icu::UMemory::operator delete(v14);
  }

  *((void *)this + 45) = 0LL;
  *a4 = U_MEMORY_ALLOCATION_ERROR;
  if (v11) {
    (*(void (**)(icu::DecimalFormatSymbols *))(*(void *)v11 + 8LL))(v11);
  }
  return this;
}

{
  unint64_t v8;
  uint64_t *v9;
  icu::DecimalFormatSymbols *v10;
  icu::DecimalFormatSymbols *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v18[224];
  uint64_t v19;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  icu::DecimalFormat::DecimalFormat(this, 0LL, a4);
  int v9 = (uint64_t *)*(unsigned int *)a4;
  uint64_t v10 = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(v9, (icu::UMemory *)0xB48, v8);
  uint64_t v11 = v10;
  if (v10)
  {
    icu::DecimalFormatSymbols::DecimalFormatSymbols(v10, a3);
    if (*(int *)a4 < 1)
    {
      uint64_t v12 = *((void *)this + 45);
      uint64_t v13 = *(void *)(v12 + 768);
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      }
      *(void *)(v12 + 768) = v11;
      icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a3 + 1936);
      icu::DecimalFormat::setPropertiesFromPattern((uint64_t)this, a2, 1, (const icu::Locale *)v18, a4);
      icu::Locale::~Locale((icu::Locale *)v18);
      icu::DecimalFormat::touch(this, a4);
      return this;
    }
  }

  else if (*(int *)a4 <= 0)
  {
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }

  uint64_t v14 = (void *)*((void *)this + 45);
  if (v14)
  {
    sub_1808D42E8(v14 + 471);
    uint64_t v15 = v14[470];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    sub_1808D3EFC(v14 + 162);
    icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v14 + 97));
    uint64_t v16 = v14[96];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    sub_1808D42E8(v14 + 1);
    icu::UMemory::operator delete(v14);
  }

  *((void *)this + 45) = 0LL;
  *a4 = U_MEMORY_ALLOCATION_ERROR;
  if (v11) {
    (*(void (**)(icu::DecimalFormatSymbols *))(*(void *)v11 + 8LL))(v11);
  }
  return this;
}

icu::DecimalFormat *icu::DecimalFormat::DecimalFormat(icu::DecimalFormat *this, uint64_t **a2)
{
  int v4 = (void *)icu::NumberFormat::NumberFormat(this, (const icu::NumberFormat *)a2);
  *int v4 = off_189722878;
  v4[45] = 0LL;
  UErrorCode v6 = a2[45];
  if (v6)
  {
    uint64_t v7 = icu::UMemory::operator new(v6, (icu::UMemory *)0x11C0, v5);
    if (v7)
    {
      unint64_t v8 = v7;
      *((void *)this + 45) = sub_1808D3FBC((uint64_t)v7, (uint64_t)(a2[45] + 1));
      UErrorCode v18 = U_ZERO_ERROR;
      uint64_t v11 = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(v10, (icu::UMemory *)0xB48, v9);
      if (v11)
      {
        uint64_t v12 = (const icu::DecimalFormatSymbols *)((uint64_t (*)(uint64_t **))(*a2)[40])(a2);
        icu::DecimalFormatSymbols::DecimalFormatSymbols(v11, v12);
      }

      uint64_t v13 = v8[96];
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      }
      v8[96] = (uint64_t)v11;
      if (v11)
      {
        icu::DecimalFormat::touch(this, &v18);
        return this;
      }

      uint64_t v14 = (void *)*((void *)this + 45);
      if (v14)
      {
        sub_1808D42E8(v14 + 471);
        uint64_t v15 = v14[470];
        if (v15) {
          (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
        }
        sub_1808D3EFC(v14 + 162);
        icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v14 + 97));
        uint64_t v16 = v14[96];
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
        }
        sub_1808D42E8(v14 + 1);
        icu::UMemory::operator delete(v14);
      }
    }

    *((void *)this + 45) = 0LL;
  }

  return this;
}

icu::DecimalFormat *icu::DecimalFormat::operator=(icu::DecimalFormat *a1, icu::DecimalFormat *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *((void *)a1 + 45);
    if (v3)
    {
      uint64_t v5 = *((void *)a2 + 45);
      if (v5)
      {
        sub_1808D0988(v3 + 8, (unsigned __int8 *)(v5 + 8));
        icu::number::impl::DecimalFormatProperties::clear((icu::number::impl::DecimalFormatProperties *)(*((void *)a1 + 45) + 3768LL));
        UErrorCode v17 = U_ZERO_ERROR;
        unint64_t v8 = icu::UMemory::operator new(v7, (icu::UMemory *)0xB48, v6);
        if (v8)
        {
          unint64_t v9 = (icu::DecimalFormatSymbols *)v8;
          uint64_t v10 = (const icu::DecimalFormatSymbols *)(*(uint64_t (**)(icu::DecimalFormat *))(*(void *)a2 + 320LL))(a2);
          icu::DecimalFormatSymbols::DecimalFormatSymbols(v9, v10);
          uint64_t v11 = *((void *)a1 + 45);
          uint64_t v12 = *(void *)(v11 + 768);
          if (v12) {
            (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
          }
          *(void *)(v11 + 768) = v9;
          icu::DecimalFormat::touch(a1, &v17);
        }

        else
        {
          uint64_t v13 = (void *)*((void *)a1 + 45);
          if (v13)
          {
            sub_1808D42E8(v13 + 471);
            uint64_t v14 = v13[470];
            if (v14) {
              (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
            }
            sub_1808D3EFC(v13 + 162);
            icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v13 + 97));
            uint64_t v15 = v13[96];
            if (v15) {
              (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
            }
            sub_1808D42E8(v13 + 1);
            icu::UMemory::operator delete(v13);
          }

          *((void *)a1 + 45) = 0LL;
        }
      }
    }
  }

  return a1;
}

uint64_t sub_1808D0988(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  *(_BYTE *)a1 = v4;
  if (!v4) {
    *(_DWORD *)(a1 + 4) = *((_DWORD *)a2 + 1);
  }
  int v5 = a2[8];
  *(_BYTE *)(a1 + 8) = v5;
  if (!v5) {
    icu::CurrencyUnit::operator=(a1 + 16, (unint64_t)(a2 + 16));
  }
  sub_1808D41B8((uint64_t **)(a1 + 48), (uint64_t **)a2 + 6);
  int v6 = a2[56];
  *(_BYTE *)(a1 + 56) = v6;
  if (!v6) {
    *(_DWORD *)(a1 + 60) = *((_DWORD *)a2 + 15);
  }
  __int128 v7 = *((_OWORD *)a2 + 4);
  __int128 v8 = *((_OWORD *)a2 + 5);
  __int128 v9 = *((_OWORD *)a2 + 7);
  *(_OWORD *)(a1 + 96) = *((_OWORD *)a2 + 6);
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 80) = v8;
  icu::UnicodeString::operator=((UChar **)(a1 + 128), (UChar **)a2 + 16);
  icu::UnicodeString::operator=((UChar **)(a1 + 192), (UChar **)a2 + 24);
  icu::UnicodeString::operator=((UChar **)(a1 + 256), (UChar **)a2 + 32);
  icu::UnicodeString::operator=((UChar **)(a1 + 320), (UChar **)a2 + 40);
  int v10 = a2[384];
  *(_BYTE *)(a1 + 384) = v10;
  if (!v10) {
    *(_DWORD *)(a1 + 388) = *((_DWORD *)a2 + 97);
  }
  icu::UnicodeString::operator=((UChar **)(a1 + 392), (UChar **)a2 + 49);
  *(_WORD *)(a1 + 456) = *((_WORD *)a2 + 228);
  int v11 = a2[460];
  *(_BYTE *)(a1 + 460) = v11;
  if (!v11) {
    *(_DWORD *)(a1 + 464) = *((_DWORD *)a2 + 116);
  }
  *(void *)(a1 + 468) = *(void *)(a2 + 468);
  icu::UnicodeString::operator=((UChar **)(a1 + 480), (UChar **)a2 + 60);
  icu::UnicodeString::operator=((UChar **)(a1 + 544), (UChar **)a2 + 68);
  icu::UnicodeString::operator=((UChar **)(a1 + 608), (UChar **)a2 + 76);
  icu::UnicodeString::operator=((UChar **)(a1 + 672), (UChar **)a2 + 84);
  *(void *)(a1 + 736) = *((void *)a2 + 92);
  int v12 = a2[744];
  *(_BYTE *)(a1 + 744) = v12;
  if (!v12) {
    *(_DWORD *)(a1 + 748) = *((_DWORD *)a2 + 187);
  }
  int v13 = *((_DWORD *)a2 + 188);
  *(_WORD *)(a1 + 756) = *((_WORD *)a2 + 378);
  *(_DWORD *)(a1 + 752) = v13;
  return a1;
}

void icu::DecimalFormat::~DecimalFormat(icu::DecimalFormat *this)
{
  *(void *)this = off_189722878;
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 1272);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(0LL, v3));
    if (v4) {
      (*(void (**)(unint64_t))(*(void *)v4 + 8LL))(v4);
    }
    int v5 = (unint64_t *)(*((void *)this + 45) + 1280LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(0LL, v5));
    if (v6) {
      (*(void (**)(unint64_t))(*(void *)v6 + 8LL))(v6);
    }
    __int128 v7 = (void *)*((void *)this + 45);
    if (v7)
    {
      sub_1808D42E8(v7 + 471);
      uint64_t v8 = v7[470];
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
      }
      sub_1808D3EFC(v7 + 162);
      icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v7 + 97));
      uint64_t v9 = v7[96];
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
      }
      sub_1808D42E8(v7 + 1);
      icu::UMemory::operator delete(v7);
    }
  }

  icu::NumberFormat::~NumberFormat(this);
}

{
  void *v1;
  icu::DecimalFormat::~DecimalFormat(this);
  icu::UMemory::operator delete(v1);
}

icu::DecimalFormat *icu::DecimalFormat::clone(icu::DecimalFormat *this, unint64_t a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 45);
  if (!v2) {
    return 0LL;
  }
  uint64_t result = (icu::DecimalFormat *)icu::UMemory::operator new(v2, (icu::UMemory *)0x170, a2);
  if (result)
  {
    uint64_t result = icu::DecimalFormat::DecimalFormat(result, (uint64_t **)this);
    if (!*((void *)result + 45))
    {
      (*(void (**)(icu::DecimalFormat *))(*(void *)result + 8LL))(result);
      return 0LL;
    }
  }

  return result;
}

uint64_t icu::DecimalFormat::operator==(void *a1, void *lpsrc)
{
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = a1[45];
  if (!v4) {
    return 0LL;
  }
  int v5 = v3;
  uint64_t v6 = v3[45];
  if (!v6
    || !icu::number::impl::DecimalFormatProperties::_equals( (icu::number::impl::DecimalFormatProperties *)(v4 + 8),  (const icu::number::impl::DecimalFormatProperties *)(v6 + 8),  0))
  {
    return 0LL;
  }

  uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 320LL))(a1);
  uint64_t v8 = (*(uint64_t (**)(void *))(*v5 + 320LL))(v5);
  return icu::DecimalFormatSymbols::operator==(v7, v8);
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, double a2, icu::UnicodeString *a3, icu::FieldPosition *a4)
{
  v17[13] = *(void **)MEMORY[0x1895F89C0];
  if (*((void *)this + 45))
  {
    if (*((_DWORD *)a4 + 2) != -1 || (icu::DecimalFormat::fastFormatDouble(this, a2, a3) & 1) == 0)
    {
      UErrorCode v15 = U_ZERO_ERROR;
      memset(v17, 0, 104);
      memset(v16, 0, sizeof(v16));
      sub_1808D4228((uint64_t)v16);
      icu::number::impl::DecimalQuantity::setToDouble(v17, a2);
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v16,  &v15);
      unsigned int v9 = *((unsigned __int16 *)a3 + 4);
      int v10 = (__int16)v9;
      unsigned int v11 = v9 >> 5;
      if (v10 >= 0) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = *((unsigned int *)a3 + 3);
      }
      icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)v16,  a4,  (icu::FieldPosition *)v12,  &v15,  v8);
      v14[0] = &unk_18971B6F0;
      v14[1] = a3;
      icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v16,  (icu::Appendable *)v14,  &v15);
      icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v14);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v16);
    }
  }

  else
  {
    icu::UnicodeString::setToBogus(a3);
  }

  return a3;
}

uint64_t icu::DecimalFormat::fastFormatDouble(icu::DecimalFormat *this, double a2, icu::UnicodeString *a3)
{
  if (!*(_BYTE *)(*((void *)this + 45) + 4528LL)) {
    return 0LL;
  }
  double v6 = uprv_trunc(a2);
  BOOL v7 = a2 <= 2147483650.0 && a2 > -2147483650.0;
  if (!v7 || v6 != a2) {
    return 0LL;
  }
  icu::DecimalFormat::doFastFormatInt32(this, (int)a2, *(void *)&a2 >> 63, a3);
  return 1LL;
}

icu::FormattedValueStringBuilderImpl *icu::DecimalFormat::fieldPositionHelper( icu::FormattedValueStringBuilderImpl *this, const icu::number::impl::UFormattedNumberData *a2, icu::FieldPosition *a3, UErrorCode *a4, UErrorCode *a5)
{
  if (*(int *)a4 <= 0)
  {
    int v5 = (int)a3;
    *((_DWORD *)a2 + 3) = 0;
    *((_DWORD *)a2 + 4) = 0;
    this = (icu::FormattedValueStringBuilderImpl *)icu::FormattedValueStringBuilderImpl::nextFieldPosition(this, a2, a4);
    if (v5)
    {
      if ((_DWORD)this)
      {
        memset(v7, 0, sizeof(v7));
        sub_1808F70B8((uint64_t)v7, (uint64_t)a2);
        sub_1808F711C((uint64_t)v7, v5);
        return (icu::FormattedValueStringBuilderImpl *)nullsub_32(v7);
      }
    }
  }

  return this;
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, double a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 45))
    {
      if (*((_DWORD *)a4 + 2) != -1 || (icu::DecimalFormat::fastFormatDouble(this, a2, a3) & 1) == 0)
      {
        uint64_t v19 = 0LL;
        memset(v18, 0, sizeof(v18));
        memset(v17, 0, sizeof(v17));
        sub_1808D4228((uint64_t)v17);
        icu::number::impl::DecimalQuantity::setToDouble((void **)v18, a2);
        icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v17,  a5);
        unsigned int v11 = *((unsigned __int16 *)a3 + 4);
        int v12 = (__int16)v11;
        unsigned int v13 = v11 >> 5;
        if (v12 >= 0) {
          unint64_t v14 = v13;
        }
        else {
          unint64_t v14 = *((unsigned int *)a3 + 3);
        }
        icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)v17,  a4,  (icu::FieldPosition *)v14,  a5,  v10);
        v16[0] = &unk_18971B6F0;
        v16[1] = a3;
        icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v17,  (icu::Appendable *)v16,  a5);
        icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v16);
        icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v17);
      }
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus(a3);
    }
  }

  return a3;
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, double a2, icu::UnicodeString *a3, icu::FieldPositionIterator *a4, UErrorCode *a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 45))
    {
      if (a4 || (icu::DecimalFormat::fastFormatDouble(this, a2, a3) & 1) == 0)
      {
        uint64_t v19 = 0LL;
        memset(v18, 0, sizeof(v18));
        memset(v17, 0, sizeof(v17));
        sub_1808D4228((uint64_t)v17);
        icu::number::impl::DecimalQuantity::setToDouble((void **)v18, a2);
        icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v17,  a5);
        unsigned int v11 = *((unsigned __int16 *)a3 + 4);
        int v12 = (__int16)v11;
        unsigned int v13 = v11 >> 5;
        if (v12 >= 0) {
          unint64_t v14 = v13;
        }
        else {
          unint64_t v14 = *((unsigned int *)a3 + 3);
        }
        icu::DecimalFormat::fieldPositionIteratorHelper( (icu::DecimalFormat *)v17,  a4,  (icu::FieldPositionIterator *)v14,  a5,  v10);
        v16[0] = &unk_18971B6F0;
        v16[1] = a3;
        icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v17,  (icu::Appendable *)v16,  a5);
        icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v16);
        icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v17);
      }
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus(a3);
    }
  }

  return a3;
}

void icu::DecimalFormat::fieldPositionIteratorHelper( icu::DecimalFormat *this, const icu::number::impl::UFormattedNumberData *a2, icu::FieldPositionIterator *a3, UErrorCode *a4, UErrorCode *a5)
{
  if (a2)
  {
    if (*(int *)a4 <= 0)
    {
      int v6 = (int)a3;
      uint64_t v9 = 0LL;
      memset(v8, 0, sizeof(v8));
      icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler((icu::FieldPositionIteratorHandler *)v8, a2, a4);
      icu::FieldPositionHandler::setShift((uint64_t)v8, v6);
      icu::FormattedValueStringBuilderImpl::getAllFieldPositions(this, (icu::FieldPositionIteratorHandler *)v8, a4);
      icu::FieldPositionIteratorHandler::~FieldPositionIteratorHandler((icu::FieldPositionIteratorHandler *)v8);
    }
  }

uint64_t icu::DecimalFormat::format(uint64_t a1, int a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 112LL))(a1, a2);
}

{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 120LL))(a1, a2);
}

{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 128LL))(a1, a2);
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, unint64_t a2, icu::UnicodeString *a3, icu::FieldPosition *a4)
{
  v18[13] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v5 = *((void *)this + 45);
  if (v5)
  {
    if (*((_DWORD *)a4 + 2) == -1 && a2 + 0x7FFFFFFF <= 0xFFFFFFFE && *(_BYTE *)(v5 + 4528))
    {
      icu::DecimalFormat::doFastFormatInt32(this, a2, a2 >> 63, a3);
    }

    else
    {
      UErrorCode v16 = U_ZERO_ERROR;
      memset(v18, 0, 104);
      memset(v17, 0, sizeof(v17));
      sub_1808D4228((uint64_t)v17);
      icu::number::impl::DecimalQuantity::setToLong(v18, a2);
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v17,  &v16);
      unsigned int v10 = *((unsigned __int16 *)a3 + 4);
      int v11 = (__int16)v10;
      unsigned int v12 = v10 >> 5;
      if (v11 >= 0) {
        unint64_t v13 = v12;
      }
      else {
        unint64_t v13 = *((unsigned int *)a3 + 3);
      }
      icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)v17,  a4,  (icu::FieldPosition *)v13,  &v16,  v9);
      v15[0] = &unk_18971B6F0;
      v15[1] = a3;
      icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v17,  (icu::Appendable *)v15,  &v16);
      icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v15);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v17);
    }
  }

  else
  {
    icu::UnicodeString::setToBogus(a3);
  }

  return a3;
}

uint64_t icu::DecimalFormat::fastFormatInt64( icu::DecimalFormat *this, unint64_t a2, icu::UnicodeString *a3)
{
  BOOL v3 = a2 + 0x7FFFFFFF >= 0xFFFFFFFF || *(_BYTE *)(*((void *)this + 45) + 4528LL) == 0;
  uint64_t v4 = !v3;
  if (!v3) {
    icu::DecimalFormat::doFastFormatInt32(this, a2, a2 >> 63, a3);
  }
  return v4;
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, unint64_t a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = *((void *)this + 45);
    if (v8)
    {
      if (*((_DWORD *)a4 + 2) == -1 && a2 + 0x7FFFFFFF <= 0xFFFFFFFE && *(_BYTE *)(v8 + 4528))
      {
        icu::DecimalFormat::doFastFormatInt32(this, a2, a2 >> 63, a3);
      }

      else
      {
        uint64_t v20 = 0LL;
        memset(v19, 0, sizeof(v19));
        memset(v18, 0, sizeof(v18));
        sub_1808D4228((uint64_t)v18);
        icu::number::impl::DecimalQuantity::setToLong((void **)v19, a2);
        icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v18,  a5);
        unsigned int v12 = *((unsigned __int16 *)a3 + 4);
        int v13 = (__int16)v12;
        unsigned int v14 = v12 >> 5;
        if (v13 >= 0) {
          unint64_t v15 = v14;
        }
        else {
          unint64_t v15 = *((unsigned int *)a3 + 3);
        }
        icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)v18,  a4,  (icu::FieldPosition *)v15,  a5,  v11);
        v17[0] = &unk_18971B6F0;
        v17[1] = a3;
        icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v18,  (icu::Appendable *)v17,  a5);
        icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v17);
        icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v18);
      }
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus(a3);
    }
  }

  return a3;
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, unint64_t a2, icu::UnicodeString *a3, icu::FieldPositionIterator *a4, UErrorCode *a5)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = *((void *)this + 45);
    if (v8)
    {
      if (a4 || a2 + 0x7FFFFFFF > 0xFFFFFFFE || !*(_BYTE *)(v8 + 4528))
      {
        uint64_t v20 = 0LL;
        memset(v19, 0, sizeof(v19));
        memset(v18, 0, sizeof(v18));
        sub_1808D4228((uint64_t)v18);
        icu::number::impl::DecimalQuantity::setToLong((void **)v19, a2);
        icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v18,  a5);
        unsigned int v12 = *((unsigned __int16 *)a3 + 4);
        int v13 = (__int16)v12;
        unsigned int v14 = v12 >> 5;
        if (v13 >= 0) {
          unint64_t v15 = v14;
        }
        else {
          unint64_t v15 = *((unsigned int *)a3 + 3);
        }
        icu::DecimalFormat::fieldPositionIteratorHelper( (icu::DecimalFormat *)v18,  a4,  (icu::FieldPositionIterator *)v15,  a5,  v11);
        v17[0] = &unk_18971B6F0;
        v17[1] = a3;
        icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v18,  (icu::Appendable *)v17,  a5);
        icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v17);
        icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v18);
      }

      else
      {
        icu::DecimalFormat::doFastFormatInt32(this, a2, a2 >> 63, a3);
      }
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus(a3);
    }
  }

  return a3;
}

uint64_t icu::DecimalFormat::format( uint64_t a1, const char *a2, int a3, uint64_t a4, const icu::number::impl::UFormattedNumberData *a5, UErrorCode *a6)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    if (*(void *)(a1 + 360))
    {
      uint64_t v21 = 0LL;
      memset(v20, 0, sizeof(v20));
      memset(v19, 0, sizeof(v19));
      sub_1808D4228((uint64_t)v19);
      icu::number::impl::DecimalQuantity::setToDecNumber((uint64_t)v20, a2, a3, a6);
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*(void *)(a1 + 360) + 776LL),  (icu::number::impl::UFormattedNumberData *)v19,  a6);
      unsigned int v13 = *(unsigned __int16 *)(a4 + 8);
      int v14 = (__int16)v13;
      unsigned int v15 = v13 >> 5;
      if (v14 >= 0) {
        unint64_t v16 = v15;
      }
      else {
        unint64_t v16 = *(unsigned int *)(a4 + 12);
      }
      icu::DecimalFormat::fieldPositionIteratorHelper( (icu::DecimalFormat *)v19,  a5,  (icu::FieldPositionIterator *)v16,  a6,  v12);
      v18[0] = &unk_18971B6F0;
      v18[1] = a4;
      icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v19,  (icu::Appendable *)v18,  a6);
      icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v18);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v19);
    }

    else
    {
      *a6 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus((icu::UnicodeString *)a4);
    }
  }

  return a4;
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, const icu::number::impl::DecimalQuantity *a2, icu::UnicodeString *a3, icu::FieldPositionIterator *a4, UErrorCode *a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 45))
    {
      uint64_t v19 = 0LL;
      memset(v18, 0, sizeof(v18));
      memset(v17, 0, sizeof(v17));
      sub_1808D4228((uint64_t)v17);
      icu::number::impl::DecimalQuantity::operator=((icu::number::impl::DecimalQuantity *)v18, (uint64_t)a2);
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v17,  a5);
      unsigned int v11 = *((unsigned __int16 *)a3 + 4);
      int v12 = (__int16)v11;
      unsigned int v13 = v11 >> 5;
      if (v12 >= 0) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = *((unsigned int *)a3 + 3);
      }
      icu::DecimalFormat::fieldPositionIteratorHelper( (icu::DecimalFormat *)v17,  a4,  (icu::FieldPositionIterator *)v14,  a5,  v10);
      v16[0] = &unk_18971B6F0;
      v16[1] = a3;
      icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v17,  (icu::Appendable *)v16,  a5);
      icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v16);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v17);
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus(a3);
    }
  }

  return a3;
}

icu::UnicodeString *icu::DecimalFormat::format( icu::DecimalFormat *this, const icu::number::impl::DecimalQuantity *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 45))
    {
      uint64_t v19 = 0LL;
      memset(v18, 0, sizeof(v18));
      memset(v17, 0, sizeof(v17));
      sub_1808D4228((uint64_t)v17);
      icu::number::impl::DecimalQuantity::operator=((icu::number::impl::DecimalQuantity *)v18, (uint64_t)a2);
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v17,  a5);
      unsigned int v11 = *((unsigned __int16 *)a3 + 4);
      int v12 = (__int16)v11;
      unsigned int v13 = v11 >> 5;
      if (v12 >= 0) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = *((unsigned int *)a3 + 3);
      }
      icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)v17,  a4,  (icu::FieldPosition *)v14,  a5,  v10);
      v16[0] = &unk_18971B6F0;
      v16[1] = a3;
      icu::FormattedValueStringBuilderImpl::appendTo( (icu::FormattedValueStringBuilderImpl *)v17,  (icu::Appendable *)v16,  a5);
      icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v16);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v17);
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
      icu::UnicodeString::setToBogus(a3);
    }
  }

  return a3;
}

void icu::DecimalFormat::parse( icu::DecimalFormat *this, const icu::UnicodeString *a2, icu::Formattable *a3, icu::ParsePosition *a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!*((void *)this + 45)) {
    return;
  }
  int v6 = *((_DWORD *)a4 + 2);
  unsigned int v7 = *((unsigned __int16 *)a2 + 4);
  if (v6 < 0)
  {
    unsigned int v9 = *((_DWORD *)a2 + 3);
    unsigned int v8 = v7 >> 5;
  }

  else
  {
    unsigned int v8 = v7 >> 5;
    unsigned int v9 = *((_DWORD *)a2 + 3);
    if ((v7 & 0x8000u) == 0) {
      signed int v10 = v7 >> 5;
    }
    else {
      signed int v10 = *((_DWORD *)a2 + 3);
    }
    if (v6 < v10)
    {
      uint64_t v20 = qword_18970B7E0;
      uint64_t v21 = 0LL;
      uint64_t v26 = 0LL;
      memset(v25, 0, sizeof(v25));
      memset(v24, 0, sizeof(v24));
      __int128 v23 = 0u;
      memset(v22, 0, sizeof(v22));
      icu::numparse::impl::ParsedNumber::ParsedNumber((icu::numparse::impl::ParsedNumber *)v22);
      int v13 = *((_DWORD *)a4 + 2);
      unint64_t Parser = icu::DecimalFormat::getParser(this, (UErrorCode *)&v21);
      unint64_t v15 = v21;
      if ((int)v21 <= 0)
      {
        unint64_t v16 = (icu::numparse::impl::NumberParserImpl *)Parser;
        icu::numparse::impl::NumberParserImpl::parse( Parser,  a2,  v13,  1,  (icu::numparse::impl::ParsedNumber *)v22,  (UErrorCode *)&v21);
        unint64_t v15 = v21;
        if ((int)v21 <= 0)
        {
          if (icu::numparse::impl::ParsedNumber::success((icu::numparse::impl::ParsedNumber *)v22))
          {
            *((_DWORD *)a4 + 2) = DWORD2(v23);
            char ParseFlags = icu::numparse::impl::NumberParserImpl::getParseFlags(v16);
            icu::numparse::impl::ParsedNumber::populateFormattable( (icu::numparse::impl::ParsedNumber *)v22,  a3,  ParseFlags);
          }

          else
          {
            unint64_t v15 = (DWORD2(v23) + v13);
            *((_DWORD *)a4 + 3) = v15;
          }
        }
      }

      icu::UnicodeString::~UnicodeString((void *)v15, (icu::UnicodeString *)v25);
      icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v24);
      icu::number::impl::DecimalQuantity::~DecimalQuantity((void **)v22);
      icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v20);
      return;
    }
  }

  if ((v7 & 0x8000u) == 0) {
    unsigned int v18 = v8;
  }
  else {
    unsigned int v18 = v9;
  }
  if (v6 == v18) {
    *((_DWORD *)a4 + 3) = v6;
  }
}

unint64_t icu::DecimalFormat::getParser(icu::DecimalFormat *this, UErrorCode *a2)
{
  unint64_t result = atomic_load((unint64_t *)(*((void *)this + 45) + 1272LL));
  if (!result)
  {
    uint64_t v5 = (icu::numparse::impl::NumberParserImpl *)(*((void *)this + 45) + 8LL);
    int v6 = (const icu::number::impl::DecimalFormatProperties *)(*(uint64_t (**)(icu::DecimalFormat *))(*(void *)this + 320LL))(this);
    unint64_t result = icu::numparse::impl::NumberParserImpl::createParserFromProperties(v5, v6, 0LL, (BOOL)a2, v7);
    if (result)
    {
      unsigned int v8 = (unint64_t *)(*((void *)this + 45) + 1272LL);
      while (1)
      {
        unint64_t v9 = __ldaxr(v8);
        if (v9) {
          break;
        }
        if (!__stlxr(result, v8))
        {
          char v10 = 1;
          goto LABEL_13;
        }
      }

      char v10 = 0;
      __clrex();
LABEL_13:
      if ((v10 & 1) == 0)
      {
        (*(void (**)(unint64_t))(*(void *)result + 8LL))(result);
        return v9;
      }
    }

    else
    {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return result;
}

uint64_t *icu::DecimalFormat::parseCurrency( icu::DecimalFormat *this, const icu::UnicodeString *a2, icu::ParsePosition *a3)
{
  v29[1] = *MEMORY[0x1895F89C0];
  if (*((void *)this + 45))
  {
    int v4 = *((_DWORD *)a3 + 2);
    if ((v4 & 0x80000000) == 0)
    {
      unsigned int v6 = *((unsigned __int16 *)a2 + 4);
      int v7 = (__int16)v6;
      signed int v8 = v6 >> 5;
      if (v7 < 0) {
        signed int v8 = *((_DWORD *)a2 + 3);
      }
      if (v4 < v8)
      {
        uint64_t v22 = qword_18970B7E0;
        uint64_t v23 = 0LL;
        v29[0] = 0LL;
        memset(v28, 0, sizeof(v28));
        memset(v27, 0, sizeof(v27));
        __int128 v26 = 0u;
        memset(v25, 0, sizeof(v25));
        icu::numparse::impl::ParsedNumber::ParsedNumber((icu::numparse::impl::ParsedNumber *)v25);
        int v10 = *((_DWORD *)a3 + 2);
        Currencyunint64_t Parser = icu::DecimalFormat::getCurrencyParser(this, (UErrorCode *)&v23);
        int v12 = 0LL;
        unint64_t v13 = v23;
        if ((int)v23 > 0)
        {
LABEL_19:
          icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)v28);
          icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v27);
          icu::number::impl::DecimalQuantity::~DecimalQuantity((void **)v25);
          icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v22);
          return v12;
        }

        unint64_t v14 = (icu::numparse::impl::NumberParserImpl *)CurrencyParser;
        icu::numparse::impl::NumberParserImpl::parse( CurrencyParser,  a2,  v10,  1,  (icu::numparse::impl::ParsedNumber *)v25,  (UErrorCode *)&v23);
        unint64_t v13 = v23;
        if ((int)v23 > 0)
        {
          int v12 = 0LL;
          goto LABEL_19;
        }

        if (!icu::numparse::impl::ParsedNumber::success((icu::numparse::impl::ParsedNumber *)v25))
        {
          int v12 = 0LL;
          unint64_t v13 = (DWORD2(v26) + v10);
          *((_DWORD *)a3 + 3) = v13;
          goto LABEL_19;
        }

        *((_DWORD *)a3 + 2) = DWORD2(v26);
        memset(v24, 0, sizeof(v24));
        icu::Formattable::Formattable((icu::Formattable *)v24);
        char ParseFlags = icu::numparse::impl::NumberParserImpl::getParseFlags(v14);
        icu::numparse::impl::ParsedNumber::populateFormattable( (icu::numparse::impl::ParsedNumber *)v25,  (icu::Formattable *)v24,  ParseFlags);
        uint64_t v19 = icu::UMemory::operator new(v18, (icu::UMemory *)0x80, v17);
        if (v19)
        {
          int v12 = v19;
          uint64_t v21 = v29;
          icu::CurrencyAmount::CurrencyAmount(v19, v24, &v21, &v23);
          if ((int)v23 < 1)
          {
LABEL_18:
            icu::Formattable::~Formattable((icu::Formattable *)v24);
            goto LABEL_19;
          }

          (*(void (**)(uint64_t *))(*v12 + 8))(v12);
        }

        else if ((int)v23 <= 0)
        {
          int v12 = 0LL;
          LODWORD(v23) = 7;
          goto LABEL_18;
        }

        int v12 = 0LL;
        goto LABEL_18;
      }
    }
  }

  return 0LL;
}

unint64_t icu::DecimalFormat::getCurrencyParser(icu::DecimalFormat *this, UErrorCode *a2)
{
  unint64_t result = atomic_load((unint64_t *)(*((void *)this + 45) + 1280LL));
  if (!result)
  {
    uint64_t v5 = (icu::numparse::impl::NumberParserImpl *)(*((void *)this + 45) + 8LL);
    unsigned int v6 = (const icu::number::impl::DecimalFormatProperties *)(*(uint64_t (**)(icu::DecimalFormat *))(*(void *)this + 320LL))(this);
    unint64_t result = icu::numparse::impl::NumberParserImpl::createParserFromProperties( v5,  v6,  (const icu::DecimalFormatSymbols *)1,  (BOOL)a2,  v7);
    if (result)
    {
      signed int v8 = (unint64_t *)(*((void *)this + 45) + 1280LL);
      while (1)
      {
        unint64_t v9 = __ldaxr(v8);
        if (v9) {
          break;
        }
        if (!__stlxr(result, v8)) {
          return result;
        }
      }

      __clrex();
      (*(void (**)(unint64_t))(*(void *)result + 8LL))(result);
      return v9;
    }

    else
    {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      int v10 = (unint64_t *)(*((void *)this + 45) + 1280LL);
      while (1)
      {
        unint64_t v11 = __ldaxr(v10);
        if (v11) {
          break;
        }
        if (!__stlxr(0LL, v10))
        {
          char v12 = 1;
          goto LABEL_15;
        }
      }

      char v12 = 0;
      __clrex();
LABEL_15:
      if ((v12 & 1) != 0) {
        return 0LL;
      }
      else {
        return v11;
      }
    }
  }

  return result;
}

uint64_t icu::DecimalFormat::getDecimalFormatSymbols(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (!v1) {
    return 0LL;
  }
  uint64_t result = *(void *)(v1 + 768);
  if (!result) {
    return icu::number::LocalizedNumberFormatter::getDecimalFormatSymbols((icu::number::LocalizedNumberFormatter *)(v1 + 776));
  }
  return result;
}

void icu::DecimalFormat::adoptDecimalFormatSymbols(icu::DecimalFormat *this, icu::DecimalFormatSymbols *a2)
{
  if (a2)
  {
    uint64_t v4 = *((void *)this + 45);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 768);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      }
      *(void *)(v4 + 768) = a2;
      UErrorCode v6 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v6);
    }

    else
    {
      (*(void (**)(icu::DecimalFormatSymbols *))(*(void *)a2 + 8LL))(a2);
    }
  }

void icu::DecimalFormat::setDecimalFormatSymbols( icu::DecimalFormat *this, const icu::DecimalFormatSymbols *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 45);
  if (v2)
  {
    uint64_t v5 = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(v2, (icu::UMemory *)0xB48, (unint64_t)a2);
    if (v5)
    {
      UErrorCode v6 = v5;
      icu::DecimalFormatSymbols::DecimalFormatSymbols(v5, a2);
      uint64_t v7 = *((void *)this + 45);
      uint64_t v8 = *(void *)(v7 + 768);
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
      }
      *(void *)(v7 + 768) = v6;
      UErrorCode v12 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v12);
    }

    else
    {
      unint64_t v9 = (void *)*((void *)this + 45);
      if (v9)
      {
        sub_1808D42E8(v9 + 471);
        uint64_t v10 = v9[470];
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
        }
        sub_1808D3EFC(v9 + 162);
        icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(v9 + 97));
        uint64_t v11 = v9[96];
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
        }
        sub_1808D42E8(v9 + 1);
        icu::UMemory::operator delete(v9);
      }

      *((void *)this + 45) = 0LL;
    }
  }

uint64_t icu::DecimalFormat::getCurrencyPluralInfo(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    return *(void *)(v1 + 56);
  }
  else {
    return 0LL;
  }
}

void icu::DecimalFormat::adoptCurrencyPluralInfo(icu::DecimalFormat *this, icu::CurrencyPluralInfo *a2)
{
  uint64_t v3 = *((void *)this + 45);
  if (v3)
  {
    uint64_t v5 = *(void *)(v3 + 56);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    *(void *)(v3 + 56) = a2;
    UErrorCode v6 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v6);
  }

  else if (a2)
  {
    (*(void (**)(icu::CurrencyPluralInfo *))(*(void *)a2 + 8LL))(a2);
  }

void icu::DecimalFormat::setCurrencyPluralInfo( icu::DecimalFormat *this@<X0>, const icu::CurrencyPluralInfo *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *((void *)this + 45);
  if (v3)
  {
    uint64_t v5 = *(void *)(v3 + 56);
    if (v5)
    {
      icu::CurrencyPluralInfo::operator=(v5, (uint64_t)a2);
    }

    else
    {
      UErrorCode v6 = icu::CurrencyPluralInfo::clone(a2, (unint64_t)a2, a3);
      uint64_t v7 = *(void *)(v3 + 56);
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
      }
      *(void *)(v3 + 56) = v6;
    }

    UErrorCode v8 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v8);
  }

icu::UnicodeString *icu::DecimalFormat::getPositivePrefix(icu::DecimalFormat *this, icu::UnicodeString *a2)
{
  uint64_t v3 = *((void *)this + 45);
  if (!v3
    || (UErrorCode v5 = U_ZERO_ERROR,
        icu::number::LocalizedNumberFormatter::getAffixImpl( (icu::number::LocalizedNumberFormatter *)(v3 + 776),  1,  0,  a2,  &v5),  v5 >= U_ILLEGAL_ARGUMENT_ERROR))
  {
    icu::UnicodeString::setToBogus(a2);
  }

  return a2;
}

void icu::DecimalFormat::setPositivePrefix(icu::DecimalFormat *this, const icu::UnicodeString *a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    unsigned int v5 = *((unsigned __int16 *)a2 + 4);
    if ((v5 & 1) != 0)
    {
      if ((*(_WORD *)(v2 + 496) & 1) != 0) {
        return;
      }
    }

    else
    {
      int v6 = (__int16)v5;
      int v7 = v5 >> 5;
      if (v6 >= 0) {
        int v8 = v7;
      }
      else {
        int v8 = *((_DWORD *)a2 + 3);
      }
      unsigned int v9 = *(unsigned __int16 *)(v2 + 496);
      if ((v9 & 0x8000u) == 0) {
        unsigned int v10 = v9 >> 5;
      }
      else {
        unsigned int v10 = *(_DWORD *)(v2 + 500);
      }
      if ((v9 & 1) == 0 && v8 == v10)
      {
        if (icu::UnicodeString::doEquals(a2, (const icu::UnicodeString *)(v2 + 488), v8)) {
          return;
        }
        uint64_t v2 = *((void *)this + 45);
      }
    }

    icu::UnicodeString::operator=((UChar **)(v2 + 488), (UChar **)a2);
    UErrorCode v11 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v11);
  }

icu::UnicodeString *icu::DecimalFormat::getNegativePrefix(icu::DecimalFormat *this, icu::UnicodeString *a2)
{
  uint64_t v3 = *((void *)this + 45);
  if (!v3
    || (UErrorCode v5 = U_ZERO_ERROR,
        icu::number::LocalizedNumberFormatter::getAffixImpl( (icu::number::LocalizedNumberFormatter *)(v3 + 776),  1,  1,  a2,  &v5),  v5 >= U_ILLEGAL_ARGUMENT_ERROR))
  {
    icu::UnicodeString::setToBogus(a2);
  }

  return a2;
}

void icu::DecimalFormat::setNegativePrefix(icu::DecimalFormat *this, const icu::UnicodeString *a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    unsigned int v5 = *((unsigned __int16 *)a2 + 4);
    if ((v5 & 1) != 0)
    {
      if ((*(_WORD *)(v2 + 144) & 1) != 0) {
        return;
      }
    }

    else
    {
      int v6 = (__int16)v5;
      int v7 = v5 >> 5;
      if (v6 >= 0) {
        int v8 = v7;
      }
      else {
        int v8 = *((_DWORD *)a2 + 3);
      }
      unsigned int v9 = *(unsigned __int16 *)(v2 + 144);
      if ((v9 & 0x8000u) == 0) {
        unsigned int v10 = v9 >> 5;
      }
      else {
        unsigned int v10 = *(_DWORD *)(v2 + 148);
      }
      if ((v9 & 1) == 0 && v8 == v10)
      {
        if (icu::UnicodeString::doEquals(a2, (const icu::UnicodeString *)(v2 + 136), v8)) {
          return;
        }
        uint64_t v2 = *((void *)this + 45);
      }
    }

    icu::UnicodeString::operator=((UChar **)(v2 + 136), (UChar **)a2);
    UErrorCode v11 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v11);
  }

icu::UnicodeString *icu::DecimalFormat::getPositiveSuffix(icu::DecimalFormat *this, icu::UnicodeString *a2)
{
  uint64_t v3 = *((void *)this + 45);
  if (!v3
    || (UErrorCode v5 = U_ZERO_ERROR,
        icu::number::LocalizedNumberFormatter::getAffixImpl( (icu::number::LocalizedNumberFormatter *)(v3 + 776),  0,  0,  a2,  &v5),  v5 >= U_ILLEGAL_ARGUMENT_ERROR))
  {
    icu::UnicodeString::setToBogus(a2);
  }

  return a2;
}

void icu::DecimalFormat::setPositiveSuffix(icu::DecimalFormat *this, const icu::UnicodeString *a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    unsigned int v5 = *((unsigned __int16 *)a2 + 4);
    if ((v5 & 1) != 0)
    {
      if ((*(_WORD *)(v2 + 624) & 1) != 0) {
        return;
      }
    }

    else
    {
      int v6 = (__int16)v5;
      int v7 = v5 >> 5;
      if (v6 >= 0) {
        int v8 = v7;
      }
      else {
        int v8 = *((_DWORD *)a2 + 3);
      }
      unsigned int v9 = *(unsigned __int16 *)(v2 + 624);
      if ((v9 & 0x8000u) == 0) {
        unsigned int v10 = v9 >> 5;
      }
      else {
        unsigned int v10 = *(_DWORD *)(v2 + 628);
      }
      if ((v9 & 1) == 0 && v8 == v10)
      {
        if (icu::UnicodeString::doEquals(a2, (const icu::UnicodeString *)(v2 + 616), v8)) {
          return;
        }
        uint64_t v2 = *((void *)this + 45);
      }
    }

    icu::UnicodeString::operator=((UChar **)(v2 + 616), (UChar **)a2);
    UErrorCode v11 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v11);
  }

icu::UnicodeString *icu::DecimalFormat::getNegativeSuffix(icu::DecimalFormat *this, icu::UnicodeString *a2)
{
  uint64_t v3 = *((void *)this + 45);
  if (!v3
    || (UErrorCode v5 = U_ZERO_ERROR,
        icu::number::LocalizedNumberFormatter::getAffixImpl( (icu::number::LocalizedNumberFormatter *)(v3 + 776),  0,  1,  a2,  &v5),  v5 >= U_ILLEGAL_ARGUMENT_ERROR))
  {
    icu::UnicodeString::setToBogus(a2);
  }

  return a2;
}

void icu::DecimalFormat::setNegativeSuffix(icu::DecimalFormat *this, const icu::UnicodeString *a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    unsigned int v5 = *((unsigned __int16 *)a2 + 4);
    if ((v5 & 1) != 0)
    {
      if ((*(_WORD *)(v2 + 272) & 1) != 0) {
        return;
      }
    }

    else
    {
      int v6 = (__int16)v5;
      int v7 = v5 >> 5;
      if (v6 >= 0) {
        int v8 = v7;
      }
      else {
        int v8 = *((_DWORD *)a2 + 3);
      }
      unsigned int v9 = *(unsigned __int16 *)(v2 + 272);
      if ((v9 & 0x8000u) == 0) {
        unsigned int v10 = v9 >> 5;
      }
      else {
        unsigned int v10 = *(_DWORD *)(v2 + 276);
      }
      if ((v9 & 1) == 0 && v8 == v10)
      {
        if (icu::UnicodeString::doEquals(a2, (const icu::UnicodeString *)(v2 + 264), v8)) {
          return;
        }
        uint64_t v2 = *((void *)this + 45);
      }
    }

    icu::UnicodeString::operator=((UChar **)(v2 + 264), (UChar **)a2);
    UErrorCode v11 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v11);
  }

void icu::DecimalFormat::setMultiplier(icu::DecimalFormat *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    int v3 = 0;
    if (a2 <= 1) {
      int v4 = 1;
    }
    else {
      int v4 = a2;
    }
    int v5 = v4;
    while (v5 != 1)
    {
      ++v3;
      BOOL v6 = 10 * (v5 / 10) == v5;
      v5 /= 10;
      if (!v6)
      {
        int v3 = 0;
        goto LABEL_10;
      }
    }

    int v4 = 1;
LABEL_10:
    *(_DWORD *)(v2 + 92) = v3;
    *(_DWORD *)(v2 + 128) = v4;
    UErrorCode v7 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v7);
  }

double icu::DecimalFormat::getRoundingIncrement(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 4504);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 736;
  }
  return *(double *)v2;
}

void icu::DecimalFormat::setRoundingIncrement(icu::DecimalFormat *this, double a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(double *)(v2 + 744) != a2)
    {
      *(double *)(v2 + 744) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

uint64_t icu::DecimalFormat::getRoundingMode(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (unsigned int *)(v1 + 4516);
  }
  else {
    uint64_t v2 = (unsigned int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 748);
  }
  return *v2;
}

void icu::DecimalFormat::setRoundingMode(icu::NumberFormat *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    int v3 = a2;
    if (*(_BYTE *)(v2 + 752) || *(_DWORD *)(v2 + 756) != (_DWORD)a2)
    {
      icu::NumberFormat::setMaximumIntegerDigits(this, a2);
      uint64_t v5 = *((void *)this + 45);
      *(_DWORD *)(v5 + 756) = v3;
      *(_BYTE *)(v5 + 752) = 0;
      UErrorCode v6 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v6);
    }
  }

uint64_t icu::DecimalFormat::getFormatWidth(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (unsigned int *)(v1 + 80);
  }
  else {
    uint64_t v2 = (unsigned int *)((char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 72);
  }
  return *v2;
}

void icu::DecimalFormat::setFormatWidth(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 80) != a2)
    {
      *(_DWORD *)(v2 + 80) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

icu::UnicodeString *icu::DecimalFormat::getPadCharacterString@<X0>( icu::DecimalFormat *this@<X0>, icu::UnicodeString *a2@<X8>)
{
  uint64_t v4 = *((void *)this + 45);
  if (v4 && (*(_WORD *)(v4 + 408) & 1) == 0) {
    return icu::UnicodeString::UnicodeString(a2, (UChar **)(v4 + 400));
  }
  UErrorCode v6 = " ";
  return (icu::UnicodeString *)icu::UnicodeString::UnicodeString(a2, 1LL, &v6);
}

void icu::DecimalFormat::setPadCharacter(icu::DecimalFormat *this, const icu::UnicodeString *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    unsigned int v5 = *((unsigned __int16 *)a2 + 4);
    if ((v5 & 1) != 0)
    {
      if ((*(_WORD *)(v2 + 408) & 1) != 0) {
        return;
      }
    }

    else
    {
      if ((v5 & 0x8000u) == 0) {
        int v6 = v5 >> 5;
      }
      else {
        int v6 = *((_DWORD *)a2 + 3);
      }
      unsigned int v7 = *(unsigned __int16 *)(v2 + 408);
      if ((v7 & 0x8000u) == 0) {
        unsigned int v8 = v7 >> 5;
      }
      else {
        unsigned int v8 = *(_DWORD *)(v2 + 412);
      }
      if ((v7 & 1) == 0 && v6 == v8)
      {
        if (icu::UnicodeString::doEquals(a2, (const icu::UnicodeString *)(v2 + 400), v6)) {
          return;
        }
        unsigned int v5 = *((unsigned __int16 *)a2 + 4);
      }
    }

    int v9 = (__int16)v5;
    LODWORD(v10) = v5 >> 5;
    if (v9 >= 0) {
      unint64_t v10 = v10;
    }
    else {
      unint64_t v10 = *((unsigned int *)a2 + 3);
    }
    if ((int)v10 < 1)
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)(*((void *)this + 45) + 400LL));
    }

    else
    {
      unsigned int v11 = icu::UnicodeString::char32At((uint64_t *)v10, a2, 0);
      icu::UnicodeString::UnicodeString((uint64_t)v13, v11);
      icu::UnicodeString::operator=((icu::UnicodeString *)(*((void *)this + 45) + 400LL), (icu::UnicodeString *)v13);
      icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v13);
    }

    v13[0] = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, v13);
  }

uint64_t icu::DecimalFormat::getPadPosition(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1 && !*(_BYTE *)(v1 + 392)) {
    return *(unsigned int *)(v1 + 396);
  }
  else {
    return 0LL;
  }
}

void icu::DecimalFormat::setPadPosition(icu::DecimalFormat *a1, int a2)
{
  uint64_t v2 = *((void *)a1 + 45);
  if (v2 && (*(_BYTE *)(v2 + 392) || *(_DWORD *)(v2 + 396) != a2))
  {
    *(_DWORD *)(v2 + 396) = a2;
    *(_BYTE *)(v2 + 392) = 0;
    UErrorCode v3 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(a1, &v3);
  }

BOOL icu::DecimalFormat::isScientificNotation(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (_DWORD *)(v1 + 108);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 100;
  }
  return *v2 != -1;
}

void icu::DecimalFormat::setScientificNotation(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (a2) {
      int v3 = 1;
    }
    else {
      int v3 = -1;
    }
    if (*(_DWORD *)(v2 + 108) != v3)
    {
      *(_DWORD *)(v2 + 108) = v3;
      UErrorCode v4 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v4);
    }
  }

uint64_t icu::DecimalFormat::getMinimumExponentDigits(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 108);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 100;
  }
  return *v2;
}

void icu::DecimalFormat::setMinimumExponentDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 108) != a2)
    {
      *(_DWORD *)(v2 + 108) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

uint64_t icu::DecimalFormat::isExponentSignAlwaysShown(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    uint64_t v2 = (char *)(v1 + 74);
  }
  else {
    uint64_t v2 = (char *)icu::number::impl::DecimalFormatProperties::getDefault(this) + 66;
  }
  return *v2;
}

void icu::DecimalFormat::setExponentSignAlwaysShown(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 74) != a2)
    {
      *(_BYTE *)(v2 + 74) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setGroupingSize(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 84) != a2)
    {
      *(_DWORD *)(v2 + 84) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setSecondaryGroupingSize(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 760) != a2)
    {
      *(_DWORD *)(v2 + 760) = a2;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setDecimalSeparatorAlwaysShown(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 73) != a2)
    {
      *(_BYTE *)(v2 + 73) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

void icu::DecimalFormat::setDecimalPatternMatchRequired(icu::DecimalFormat *this, unsigned __int8 a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    if (*(unsigned __int8 *)(v2 + 72) != a2)
    {
      *(_BYTE *)(v2 + 72) = a2 != 0;
      UErrorCode v3 = U_ZERO_ERROR;
      icu::DecimalFormat::touch(this, &v3);
    }
  }

icu::UnicodeString *icu::DecimalFormat::toPattern(icu::DecimalFormat *this, icu::UnicodeString *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *((void *)this + 45);
  if (v3)
  {
    uint64_t v20 = qword_18970B7E0;
    uint64_t v21 = 0LL;
    bzero(v24, 0x2F0uLL);
    uint64_t v6 = *(void *)(v3 + 8);
    uint64_t v5 = v3 + 8;
    uint64_t v23 = v6;
    v24[0] = *(_BYTE *)(v5 + 8);
    icu::CurrencyUnit::CurrencyUnit((icu::CurrencyUnit *)&v25, (const UChar *)(v5 + 16));
    sub_1808D427C(&v26, (uint64_t **)(v5 + 48));
    __int128 v7 = *(_OWORD *)(v5 + 72);
    __int128 v8 = *(_OWORD *)(v5 + 88);
    __int128 v9 = *(_OWORD *)(v5 + 104);
    uint64_t v31 = *(void *)(v5 + 120);
    __int128 v27 = *(_OWORD *)(v5 + 56);
    __int128 v30 = v9;
    __int128 v29 = v8;
    __int128 v28 = v7;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v32, (UChar **)(v5 + 128));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v33, (UChar **)(v5 + 192));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v34, (UChar **)(v5 + 256));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v35, (UChar **)(v5 + 320));
    v35[8] = *(void *)(v5 + 384);
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v36, (UChar **)(v5 + 392));
    int v10 = *(_DWORD *)(v5 + 472);
    v36[4] = *(_OWORD *)(v5 + 456);
    int v37 = v10;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v38, (UChar **)(v5 + 480));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v39, (UChar **)(v5 + 544));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v40, (UChar **)(v5 + 608));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v41, (UChar **)(v5 + 672));
    __int128 v12 = *(_OWORD *)(v5 + 736);
    *(void *)&v42[14] = *(void *)(v5 + 750);
    *(_OWORD *)uint64_t v42 = v12;
    if (!v24[0]
      || v26
      || !(_BYTE)v27
      || BYTE11(v27)
      || (icu::number::impl::AffixUtils::hasCurrencySymbols( (icu::number::impl::AffixUtils *)v39,  (const icu::UnicodeString *)&v21,  v11) & 1) != 0 || (icu::number::impl::AffixUtils::hasCurrencySymbols( (icu::number::impl::AffixUtils *)v41,  (const icu::UnicodeString *)&v21,  v13) & 1) != 0 || (icu::number::impl::AffixUtils::hasCurrencySymbols( (icu::number::impl::AffixUtils *)v33,  (const icu::UnicodeString *)&v21,  v14) & 1) != 0 || icu::number::impl::AffixUtils::hasCurrencySymbols( (icu::number::impl::AffixUtils *)v35,  (const icu::UnicodeString *)&v21,  v15))
    {
      uint64_t v16 = *((void *)this + 45);
      int v17 = *(_DWORD *)(v16 + 3856);
      LODWORD(v30) = *(_DWORD *)(v16 + 3872);
      LODWORD(v29) = v17;
      *(void *)uint64_t v42 = *(void *)(v16 + 4504);
    }

    icu::number::impl::PatternStringUtils::propertiesToPatternString( (icu::number::impl::PatternStringUtils *)&v23,  (const icu::number::impl::DecimalFormatProperties *)&v21,  (uint64_t)v22);
    icu::UnicodeString::operator=(a2, (icu::UnicodeString *)v22);
    icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v22);
    sub_1808D42E8(&v23);
    icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v20);
  }

  else
  {
    icu::UnicodeString::setToBogus(a2);
  }

  return a2;
}

UChar **icu::DecimalFormat::toLocalizedPattern(icu::DecimalFormat *this, UChar **a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 45))
  {
    __int128 v8 = qword_18970B7E0;
    uint64_t v9 = 0LL;
    UErrorCode v4 = (UChar **)(*(uint64_t (**)(icu::DecimalFormat *, UChar **))(*(void *)this + 552LL))(this, a2);
    icu::UnicodeString::operator=(a2, v4);
    uint64_t v5 = (UChar **)(*(uint64_t (**)(icu::DecimalFormat *))(*(void *)this + 320LL))(this);
    icu::number::impl::PatternStringUtils::convertLocalized( (icu::number::impl::PatternStringUtils *)a2,  v5,  (const icu::DecimalFormatSymbols *)1,  &v9,  (uint64_t)v10);
    icu::UnicodeString::operator=((icu::UnicodeString *)a2, (icu::UnicodeString *)v10);
    icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)v10);
    icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v8);
  }

  else
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a2);
  }

  return a2;
}

uint64_t icu::DecimalFormat::applyPattern( icu::DecimalFormat *this, const icu::UnicodeString *a2, UParseError *a3, UErrorCode *a4)
{
  return (*(uint64_t (**)(icu::DecimalFormat *, const icu::UnicodeString *, UErrorCode *))(*(void *)this + 576LL))( this,  a2,  a4);
}

void icu::DecimalFormat::applyPattern( icu::DecimalFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v5 = *((void *)this + 45);
    if (v5)
    {
      icu::number::impl::PatternParser::parseToExistingProperties(a2, v5 + 8);
      icu::DecimalFormat::touch(this, a3);
    }

    else
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

uint64_t icu::DecimalFormat::applyLocalizedPattern( icu::DecimalFormat *this, const icu::UnicodeString *a2, UParseError *a3, UErrorCode *a4)
{
  return (*(uint64_t (**)(icu::DecimalFormat *, const icu::UnicodeString *, UErrorCode *))(*(void *)this + 592LL))( this,  a2,  a4);
}

void *icu::DecimalFormat::applyLocalizedPattern( void *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    UErrorCode v4 = this;
    if (this[45])
    {
      memset(v8, 0, sizeof(v8));
      uint64_t v6 = (UChar **)(*(uint64_t (**)(void *))(*this + 320LL))(this);
      icu::number::impl::PatternStringUtils::convertLocalized(a2, v6, 0LL, a3, (uint64_t)v8);
      (*(void (**)(void *, _OWORD *, UErrorCode *))(*v4 + 576LL))(v4, v8, a3);
      return icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v8);
    }

    else
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

void icu::DecimalFormat::setMaximumIntegerDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(_DWORD *)(v2 + 100) != a2)
  {
    int v3 = *(_DWORD *)(v2 + 120);
    if ((v3 & 0x80000000) == 0 && v3 > a2) {
      *(_DWORD *)(v2 + 120) = a2;
    }
    *(_DWORD *)(v2 + 100) = a2;
    UErrorCode v4 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v4);
  }

void icu::DecimalFormat::setMinimumIntegerDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(_DWORD *)(v2 + 120) != a2)
  {
    int v3 = *(_DWORD *)(v2 + 100);
    if ((v3 & 0x80000000) == 0 && v3 < a2) {
      *(_DWORD *)(v2 + 100) = a2;
    }
    *(_DWORD *)(v2 + 120) = a2;
    UErrorCode v4 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v4);
  }

void icu::DecimalFormat::setMaximumFractionDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(_DWORD *)(v2 + 96) != a2)
  {
    if (a2 >= 340) {
      int v3 = 340;
    }
    else {
      int v3 = a2;
    }
    int v4 = *(_DWORD *)(v2 + 112);
    if ((v4 & 0x80000000) == 0 && v4 > v3) {
      *(_DWORD *)(v2 + 112) = v3;
    }
    *(_DWORD *)(v2 + 96) = v3;
    UErrorCode v5 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v5);
  }

void icu::DecimalFormat::setMinimumFractionDigits(icu::DecimalFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2 && *(_DWORD *)(v2 + 112) != a2)
  {
    int v3 = *(_DWORD *)(v2 + 96);
    if ((v3 & 0x80000000) == 0 && v3 < a2) {
      *(_DWORD *)(v2 + 96) = a2;
    }
    *(_DWORD *)(v2 + 112) = a2;
    UErrorCode v4 = U_ZERO_ERROR;
    icu::DecimalFormat::touch(this, &v4);
  }

void icu::DecimalFormat::setDateSettings(icu::DecimalFormat *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1)
  {
    int v3 = *(unsigned __int8 *)(v1 + 88);
    if (*(_BYTE *)(v1 + 88))
    {
      icu::NumberFormat::setGroupingUsed((uint64_t)this, 0);
      uint64_t v1 = *((void *)this + 45);
      *(_BYTE *)(v1 + 88) = 0;
      int v3 = 1;
    }

    if (*(_BYTE *)(v1 + 73))
    {
      *(_BYTE *)(v1 + 73) = 0;
      int v3 = 1;
    }

    if (*(_BYTE *)(v1 + 465))
    {
      int v5 = *(_DWORD *)(v1 + 112);
      uint64_t v4 = v1 + 112;
      if (!v5)
      {
        if (!v3) {
          return;
        }
LABEL_12:
        UErrorCode v8 = U_ZERO_ERROR;
        icu::DecimalFormat::touch(this, &v8);
        return;
      }
    }

    else
    {
      icu::NumberFormat::setParseIntegerOnly((uint64_t)this, 1);
      uint64_t v6 = *((void *)this + 45);
      int v7 = *(_DWORD *)(v6 + 112);
      uint64_t v4 = v6 + 112;
      *(_BYTE *)(v4 + 353) = 1;
      if (!v7) {
        goto LABEL_12;
      }
    }

    *(_DWORD *)uint64_t v4 = 0;
    goto LABEL_12;
  }

void icu::DecimalFormat::setCurrency(UChar *a1, const UChar *a2, int *a3)
{
  v20[1] = *MEMORY[0x1895F89C0];
  if (*a3 <= 0)
  {
    if (*((void *)a1 + 45))
    {
      int v5 = a2;
      v20[0] = 0LL;
      if (!a2 || !*a2)
      {
        v15[0] = 0;
        uint64_t v6 = (*(uint64_t (**)(UChar *))(*(void *)a1 + 320LL))(a1);
        icu::Locale::Locale((icu::Locale *)&v17, v6 + 1936);
        int v7 = ucurr_forLocale(v19, (UChar *)v20, 4LL, v15);
        icu::Locale::~Locale((icu::Locale *)&v17);
        if (v15[0] <= 0 && v7 == 3)
        {
          HIWORD(v20[0]) = 0;
          int v5 = (const UChar *)v20;
        }
      }

      __int128 v17 = 0u;
      __int128 v18 = 0u;
      uint64_t v16 = v5;
      icu::CurrencyUnit::CurrencyUnit(&v17, &v16, a3);
      if (*a3 <= 0)
      {
        uint64_t v8 = *((void *)a1 + 45);
        if (*(_BYTE *)(v8 + 16)
          || (icu::CurrencyUnit::CurrencyUnit((icu::CurrencyUnit *)v15, (const UChar *)(v8 + 24)),
              char v9 = icu::MeasureUnit::operator==((uint64_t)v15, (uint64_t)&v17),
              icu::CurrencyUnit::~CurrencyUnit((icu::CurrencyUnit *)v15),
              (v9 & 1) == 0))
        {
          icu::NumberFormat::setCurrency(a1, v5, a3);
          uint64_t v10 = *((void *)a1 + 45);
          icu::CurrencyUnit::operator=(v10 + 24, (unint64_t)&v17);
          *(_BYTE *)(v10 + 16) = 0;
          unint64_t v13 = (icu::DecimalFormatSymbols *)icu::UMemory::operator new(v12, (icu::UMemory *)0xB48, v11);
          if (v13)
          {
            uint64_t v14 = (const icu::DecimalFormatSymbols *)(*(uint64_t (**)(UChar *))(*(void *)a1 + 320LL))(a1);
            icu::DecimalFormatSymbols::DecimalFormatSymbols(v13, v14);
          }

          else if (*a3 <= 0)
          {
            *a3 = 7;
          }

          icu::DecimalFormatSymbols::setCurrency((char **)v13, (const UChar *)&v18 + 2, a3);
          sub_1807C9194(*((void *)a1 + 45) + 768LL, (uint64_t)v13, a3);
          icu::DecimalFormat::touch((icu::DecimalFormat *)a1, (UErrorCode *)a3);
        }
      }

      icu::CurrencyUnit::~CurrencyUnit((icu::CurrencyUnit *)&v17);
    }

    else
    {
      *a3 = 7;
    }
  }

void icu::DecimalFormat::setCurrency(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = &unk_18970B7E0;
  uint64_t v3 = 0LL;
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 248LL))(a1, a2, &v3);
  icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v2);
}

void icu::DecimalFormat::formatToDecimalQuantity( icu::DecimalFormat *this, double a2, icu::number::impl::DecimalQuantity *a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    uint64_t v5 = *((void *)this + 45);
    if (v5)
    {
      icu::number::LocalizedNumberFormatter::formatDouble((uint64_t *)(v5 + 776), a2, a4, (uint64_t)v7);
      icu::number::FormattedNumber::getDecimalQuantity((icu::number::impl::DecimalQuantity *)v7, a3, a4);
      icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)v7);
    }

    else
    {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

void icu::DecimalFormat::formatToDecimalQuantity( icu::DecimalFormat *this, const icu::Formattable *a2, icu::number::impl::DecimalQuantity *a3, UErrorCode *a4)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 <= 0)
  {
    if (*((void *)this + 45))
    {
      uint64_t v10 = 0LL;
      memset(v9, 0, sizeof(v9));
      memset(v8, 0, sizeof(v8));
      sub_1808D4228((uint64_t)v8);
      icu::Formattable::populateDecimalQuantity(a2, (icu::number::impl::DecimalQuantity *)v9, a4);
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(*((void *)this + 45) + 776LL),  (icu::number::impl::UFormattedNumberData *)v8,  a4);
      icu::number::impl::DecimalQuantity::operator=(a3, (uint64_t)v9);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v8);
    }

    else
    {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

uint64_t icu::DecimalFormat::toNumberFormatter(icu::DecimalFormat *this, UErrorCode *a2)
{
  uint64_t v3 = *((void *)this + 45);
  if (v3) {
    return v3 + 776;
  }
  uint64_t result = 0LL;
  *a2 = U_MEMORY_ALLOCATION_ERROR;
  return result;
}

uint64_t icu::DecimalFormat::setupFastFormat(icu::DecimalFormat *this)
{
  uint64_t result = icu::number::impl::DecimalFormatProperties::equalsDefaultExceptFastFormat((icu::number::impl::DecimalFormatProperties *)(*((void *)this + 45) + 8LL));
  uint64_t v3 = *((void *)this + 45);
  if ((result & 1) == 0) {
    goto LABEL_28;
  }
  __int16 v4 = *(_WORD *)(v3 + 208);
  if ((v4 & 1) != 0)
  {
    BOOL v5 = 1;
  }

  else
  {
    if ((*(_WORD *)(v3 + 208) & 0x8000) != 0)
    {
      if (*(_DWORD *)(v3 + 212) != 1)
      {
LABEL_28:
        *(_BYTE *)(v3 + 4528) = 0;
        return result;
      }
    }

    else if ((v4 & 0xFFE0) != 0x20)
    {
      goto LABEL_28;
    }

    if ((v4 & 2) != 0) {
      uint64_t v6 = (unsigned __int16 *)(v3 + 210);
    }
    else {
      uint64_t v6 = *(unsigned __int16 **)(v3 + 224);
    }
    BOOL v5 = *v6 == 45;
  }

  BOOL v8 = *(unsigned __int16 *)(v3 + 560) > 0x1Fu || *(unsigned __int16 *)(v3 + 688) > 0x1Fu || !v5;
  uint64_t result = (*(uint64_t (**)(icu::DecimalFormat *))(*(void *)this + 320LL))(this);
  uint64_t v9 = *((void *)this + 45);
  uint64_t v10 = (_BYTE *)(v9 + 4528);
  int v11 = *(unsigned __int8 *)(v9 + 88);
  int v12 = *(_DWORD *)(v9 + 84);
  if ((!*(_BYTE *)(v9 + 88)
     || (v12 >= 1 ? (BOOL v13 = v12 == 3) : (BOOL v13 = 1),
         v13
      && (*(__int16 *)(result + 80) < 0
        ? (int v14 = *(_DWORD *)(result + 84))
        : (int v14 = *(unsigned __int16 *)(result + 80) >> 5),
          v14 == 1)))
    && (int v15 = *(_DWORD *)(v9 + 3880), v15 < 11)
    && *(int *)(v9 + 3872) < 1
    && (*(__int16 *)(result + 400) < 0
      ? (int v16 = *(_DWORD *)(result + 404))
      : (int v16 = *(unsigned __int16 *)(result + 400) >> 5),
        v16 == 1 && (unsigned int v17 = *(_DWORD *)(result + 1928), v17 < 0x10000)))
  {
    __int16 v18 = 0;
    unsigned int v19 = *(_DWORD *)(v9 + 3860);
    *uint64_t v10 = 1;
    *(_WORD *)(v9 + 4530) = v17;
    if (v11 && v12 == 3)
    {
      unsigned int v20 = *(unsigned __int16 *)(result + 80);
      else {
        unsigned int v21 = v20 >> 5;
      }
      if (v21)
      {
        if ((v20 & 2) != 0) {
          uint64_t v22 = (__int16 *)(result + 82);
        }
        else {
          uint64_t v22 = *(__int16 **)(result + 96);
        }
        __int16 v18 = *v22;
      }

      else
      {
        __int16 v18 = -1;
      }
    }

    *(_WORD *)(v9 + 4532) = v18;
    unsigned int v23 = *(unsigned __int16 *)(result + 400);
    else {
      unsigned int v24 = v23 >> 5;
    }
    if (v24)
    {
      if ((v23 & 2) != 0) {
        uint64_t v25 = (__int16 *)(result + 402);
      }
      else {
        uint64_t v25 = *(__int16 **)(result + 416);
      }
      __int16 v26 = *v25;
    }

    else
    {
      __int16 v26 = -1;
    }

    *(_WORD *)(v9 + 4534) = v26;
    *(_BYTE *)(v9 + 4536) = v15 & ~(v15 >> 31);
    if (v19 >= 0x7F) {
      char v27 = 127;
    }
    else {
      char v27 = v19;
    }
    v10[9] = v27;
  }

  else
  {
    *uint64_t v10 = 0;
  }

  return result;
}

uint64_t icu::DecimalFormat::doFastFormatInt32( icu::DecimalFormat *this, int quot, int a3, icu::UnicodeString *a4)
{
  *(void *)&_OWORD v19[6] = *MEMORY[0x1895F89C0];
  if (a3)
  {
    LOWORD(v17[0]) = *(_WORD *)(*((void *)this + 45) + 4534LL);
    icu::UnicodeString::doAppend((uint64_t)a4, (uint64_t)v17, 0, 1LL);
    quot = -quot;
  }

  memset(v17, 0, sizeof(v17));
  __int16 v18 = 0;
  int v7 = v19;
  uint64_t v8 = *((void *)this + 45);
  int v9 = *(char *)(v8 + 4536);
  if (v9 <= 1) {
    LOBYTE(v9) = 1;
  }
  int v10 = *(char *)(v8 + 4537);
  if (v10 >= 1)
  {
    LOBYTE(v11) = 0;
    char v12 = 0;
    unsigned int v13 = v9;
    do
    {
      if (v12 == 3)
      {
        if (*(_WORD *)(v8 + 4532))
        {
          *((_WORD *)v7 - 1) = *(_WORD *)(v8 + 4532);
          v7 -= 2;
          char v12 = 1;
        }

        else
        {
          char v12 = 4;
        }
      }

      else
      {
        ++v12;
      }

      div_t v15 = div(quot, 10);
      quot = v15.quot;
      *((_WORD *)v7 - 1) = *(_WORD *)(v8 + 4530) + LOWORD(v15.rem);
      v7 -= 2;
      int v11 = (char)(v11 + 1);
    }

    while (v11 < v10);
  }

  return icu::UnicodeString::doAppend( (uint64_t)a4,  (uint64_t)v7,  0,  13 - ((unint64_t)(v7 - (_BYTE *)v17) >> 1));
}

uint64_t sub_1808D3D40(uint64_t a1)
{
  *(void *)(a1 + 768) = 0LL;
  sub_1808D3E38(a1 + 776);
  *(void *)(a1 + 1280) = 0LL;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(void *)(a1 + 1296) = off_189727980;
  *(void *)(a1 + 1304) = off_18971B688;
  *(_WORD *)(a1 + 1312) = 2;
  *(void *)(a1 + 1368) = off_18971B688;
  *(_WORD *)(a1 + 1376) = 2;
  *(void *)(a1 + 1432) = off_18971B688;
  *(_WORD *)(a1 + 1440) = 2;
  *(void *)(a1 + 1496) = off_18971B688;
  *(_WORD *)(a1 + 1504) = 2;
  *(void *)(a1 + 1568) = off_189727A28;
  uint64_t v2 = 1576LL;
  *(_BYTE *)(a1 + 1562) = 1;
  do
  {
    uint64_t v3 = a1 + v2;
    *(void *)uint64_t v3 = off_189727980;
    *(void *)(v3 + 8) = off_18971B688;
    *(_WORD *)(v3 + 16) = 2;
    *(void *)(v3 + 72) = off_18971B688;
    *(_WORD *)(v3 + 80) = 2;
    *(void *)(v3 + 136) = off_18971B688;
    *(_WORD *)(v3 + 144) = 2;
    *(void *)(v3 + 200) = off_18971B688;
    *(_WORD *)(v3 + 208) = 2;
    v2 += 272LL;
    *(_BYTE *)(v3 + 266) = 1;
  }

  while (v3 + 272 != a1 + 3752);
  *(_BYTE *)(a1 + 3752) = 1;
  *(void *)(a1 + 3760) = 0LL;
  icu::number::impl::DecimalFormatProperties::DecimalFormatProperties((icu::number::impl::DecimalFormatProperties *)(a1 + 3768));
  *(_BYTE *)(a1 + 4528) = 0;
  return a1;
}

uint64_t sub_1808D3E38(uint64_t a1)
{
  *(_DWORD *)(a1 + 4) = 2;
  *(void *)(a1 + 8) = 0LL;
  icu::MeasureUnit::MeasureUnit(a1 + 16);
  icu::MeasureUnit::MeasureUnit(a1 + 40);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 4;
  *(_WORD *)(a1 + 100) = -3;
  *(_DWORD *)(a1 + 112) = -2;
  *(_BYTE *)(a1 + 132) = 0;
  *(_WORD *)(a1 + 124) = -1;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 152) = 0x900000007LL;
  *(_BYTE *)(a1 + 160) = 0;
  *(void *)(a1 + 164) = 2LL;
  *(void *)(a1 + 176) = 0LL;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0LL;
  *(_WORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(void *)(a1 + 208) = 0LL;
  *(_WORD *)(a1 + 216) = 0;
  *(void *)(a1 + 228) = 0LL;
  *(void *)(a1 + 220) = 0LL;
  *(void *)(a1 + 236) = 0x300000000LL;
  *(_WORD *)(a1 + 244) = 0;
  icu::Locale::Locale((icu::Locale *)(a1 + 248));
  return a1;
}

void sub_1808D3EFC(void *a1)
{
  uint64_t v2 = (icu::number::impl::AffixPatternProvider *)(a1 + 34);
  a1[34] = off_189727A28;
  uint64_t v3 = 272LL;
  do
  {
    a1[v3 + 1] = off_189727980;
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&a1[v3 + 26]);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&a1[v3 + 18]);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&a1[v3 + 10]);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&a1[v3 + 2]);
    icu::number::impl::AffixPatternProvider::~AffixPatternProvider((icu::number::impl::AffixPatternProvider *)&a1[v3 + 1]);
    v3 -= 34LL;
  }

  while (v3 * 8);
  icu::number::impl::AffixPatternProvider::~AffixPatternProvider(v2);
  *a1 = off_189727980;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 25));
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 17));
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 9));
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 1));
  icu::number::impl::AffixPatternProvider::~AffixPatternProvider((icu::number::impl::AffixPatternProvider *)a1);
}

uint64_t sub_1808D3FBC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)a2;
  uint64_t v4 = a1 + 8;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 8);
  icu::CurrencyUnit::CurrencyUnit((icu::CurrencyUnit *)(a1 + 24), (const UChar *)(a2 + 16));
  sub_1808D427C((uint64_t **)(v4 + 48), (uint64_t **)(a2 + 48));
  *(_OWORD *)(v4 + 56) = *(_OWORD *)(a2 + 56);
  __int128 v5 = *(_OWORD *)(a2 + 72);
  __int128 v6 = *(_OWORD *)(a2 + 88);
  __int128 v7 = *(_OWORD *)(a2 + 104);
  *(void *)(v4 + 120) = *(void *)(a2 + 120);
  *(_OWORD *)(v4 + 104) = v7;
  *(_OWORD *)(v4 + 88) = v6;
  *(_OWORD *)(v4 + 72) = v5;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 128), (UChar **)(a2 + 128));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 192), (UChar **)(a2 + 192));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 256), (UChar **)(a2 + 256));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 320), (UChar **)(a2 + 320));
  *(void *)(v4 + 384) = *(void *)(a2 + 384);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 392), (UChar **)(a2 + 392));
  __int128 v8 = *(_OWORD *)(a2 + 456);
  *(_DWORD *)(v4 + 472) = *(_DWORD *)(a2 + 472);
  *(_OWORD *)(v4 + 456) = v8;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 480), (UChar **)(a2 + 480));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 544), (UChar **)(a2 + 544));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 608), (UChar **)(a2 + 608));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 672), (UChar **)(a2 + 672));
  __int128 v9 = *(_OWORD *)(a2 + 736);
  *(void *)(v4 + 750) = *(void *)(a2 + 750);
  *(_OWORD *)(v4 + 736) = v9;
  *(void *)(v4 + 760) = 0LL;
  sub_1808D3E38(v4 + 768);
  *(void *)(v4 + 1272) = 0LL;
  *(_OWORD *)(v4 + 1256) = 0u;
  *(_OWORD *)(v4 + 1240) = 0u;
  *(void *)(v4 + 1288) = off_189727980;
  *(void *)(v4 + 1296) = off_18971B688;
  *(_WORD *)(v4 + 1304) = 2;
  *(void *)(v4 + 1360) = off_18971B688;
  *(_WORD *)(v4 + 1368) = 2;
  *(void *)(v4 + 1424) = off_18971B688;
  *(_WORD *)(v4 + 1432) = 2;
  *(void *)(v4 + 1488) = off_18971B688;
  *(_WORD *)(v4 + 1496) = 2;
  *(void *)(v4 + 1560) = off_189727A28;
  *(_BYTE *)(v4 + 1554) = 1;
  uint64_t v10 = 1576LL;
  do
  {
    uint64_t v11 = a1 + v10;
    *(void *)uint64_t v11 = off_189727980;
    *(void *)(v11 + 8) = off_18971B688;
    *(_WORD *)(v11 + 16) = 2;
    *(void *)(v11 + 72) = off_18971B688;
    *(_WORD *)(v11 + 80) = 2;
    *(void *)(v11 + 136) = off_18971B688;
    *(_WORD *)(v11 + 144) = 2;
    *(void *)(v11 + 200) = off_18971B688;
    *(_WORD *)(v11 + 208) = 2;
    v10 += 272LL;
    *(_BYTE *)(v11 + 266) = 1;
  }

  while (v11 + 272 != v4 + 3744);
  *(_BYTE *)(a1 + 3752) = 1;
  *(void *)(a1 + 3760) = 0LL;
  icu::number::impl::DecimalFormatProperties::DecimalFormatProperties((icu::number::impl::DecimalFormatProperties *)(a1 + 3768));
  *(_BYTE *)(a1 + 4528) = 0;
  return a1;
}

uint64_t **sub_1808D41B8(uint64_t **a1, uint64_t **a2)
{
  if (a1 != a2 && *a2)
  {
    uint64_t v4 = icu::UMemory::operator new(*a2, (icu::UMemory *)0x28, (unint64_t)a2);
    __int128 v5 = v4;
    if (v4) {
      icu::CurrencyPluralInfo::CurrencyPluralInfo((uint64_t)v4, (uint64_t)*a2);
    }
    if (*a1) {
      (*(void (**)(uint64_t *))(**a1 + 8))(*a1);
    }
    *a1 = v5;
  }

  return a1;
}

uint64_t sub_1808D4228(uint64_t a1)
{
  uint64_t v2 = (void *)icu::FormattedValueStringBuilderImpl::FormattedValueStringBuilderImpl(a1, 0);
  void *v2 = off_189727E90;
  icu::number::impl::DecimalQuantity::DecimalQuantity((icu::number::impl::DecimalQuantity *)(v2 + 38));
  icu::MeasureUnit::MeasureUnit(a1 + 376);
  *(void *)(a1 + 400) = "";
  return a1;
}

uint64_t **sub_1808D427C(uint64_t **a1, uint64_t **a2)
{
  *a1 = 0LL;
  if (*a2)
  {
    uint64_t v4 = icu::UMemory::operator new(*a2, (icu::UMemory *)0x28, (unint64_t)a2);
    __int128 v5 = v4;
    if (v4) {
      icu::CurrencyPluralInfo::CurrencyPluralInfo((uint64_t)v4, (uint64_t)*a2);
    }
    if (*a1) {
      (*(void (**)(uint64_t *))(**a1 + 8))(*a1);
    }
    *a1 = v5;
  }

  return a1;
}

void *sub_1808D42E8(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::CurrencyUnit::~CurrencyUnit((icu::CurrencyUnit *)(a1 + 2));
  return a1;
}

void icu::DisplayOptions::builder(uint64_t a1@<X8>)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
}

uint64_t icu::DisplayOptions::Builder::Builder(uint64_t this)
{
  *(void *)this = 0LL;
  *(void *)(this + 8) = 0LL;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 16) = 0LL;
  return this;
}

{
  *(void *)this = 0LL;
  *(void *)(this + 8) = 0LL;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 16) = 0LL;
  return this;
}

double icu::DisplayOptions::copyToBuilder@<D0>(icu::DisplayOptions *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = *(_OWORD *)this;
  double result = *((double *)this + 2);
  *(double *)(a2 + 16) = result;
  *(_DWORD *)(a2 + 24) = *((_DWORD *)this + 6);
  return result;
}

double icu::DisplayOptions::Builder::Builder( icu::DisplayOptions::Builder *this, const icu::DisplayOptions *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  double result = *((double *)a2 + 2);
  *((double *)this + 2) = result;
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  return result;
}

{
  double result;
  *(_OWORD *)this = *(_OWORD *)a2;
  double result = *((double *)a2 + 2);
  *((double *)this + 2) = result;
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  return result;
}

double icu::DisplayOptions::DisplayOptions( icu::DisplayOptions *this, const icu::DisplayOptions::Builder *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  double result = *((double *)a2 + 2);
  *((double *)this + 2) = result;
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  return result;
}

{
  double result;
  *(_OWORD *)this = *(_OWORD *)a2;
  double result = *((double *)a2 + 2);
  *((double *)this + 2) = result;
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  return result;
}

const char *udispopt_getGrammaticalCaseIdentifier(unsigned int a1)
{
  if (a1 > 0xE) {
    return "undefined";
  }
  else {
    return off_189722AF0[a1];
  }
}

uint64_t udispopt_fromGrammaticalCaseIdentifier(char *__s1)
{
  uint64_t v2 = 0LL;
  while (strcmp(__s1, off_189722AF0[v2]))
  {
    if (++v2 == 15) {
      return 0LL;
    }
  }

  return v2;
}

const char *udispopt_getPluralCategoryIdentifier(unsigned int a1)
{
  if (a1 > 6) {
    return "undefined";
  }
  else {
    return off_189722B68[a1];
  }
}

uint64_t udispopt_fromPluralCategoryIdentifier(char *__s1)
{
  uint64_t v2 = 0LL;
  while (strcmp(__s1, off_189722B68[v2]))
  {
    if (++v2 == 7) {
      return 0LL;
    }
  }

  return v2;
}

const char *udispopt_getNounClassIdentifier(unsigned int a1)
{
  if (a1 > 8) {
    return "undefined";
  }
  else {
    return off_189722BA0[a1];
  }
}

uint64_t udispopt_fromNounClassIdentifier(char *__s1)
{
  uint64_t v2 = 0LL;
  while (strcmp(__s1, off_189722BA0[v2]))
  {
    if (++v2 == 9) {
      return 0LL;
    }
  }

  return v2;
}

uint64_t sub_1808D4590(uint64_t result, int a2, _BYTE *a3, uint64_t a4, int *a5, int *a6, double a7)
{
  unsigned int v12 = result;
  float v13 = a7;
  int v14 = ((*(void *)&a7 >> 52) & 0x7FF) - 1075;
  uint64_t v15 = *(void *)&a7 & 0xFFFFFFFFFFFFFLL;
  if ((*(void *)&a7 & 0x7FF0000000000000LL) != 0) {
    uint64_t v15 = *(void *)&a7 & 0xFFFFFFFFFFFFFLL | 0x10000000000000LL;
  }
  else {
    int v14 = -1074;
  }
  BOOL v16 = (*(void *)&a7 & 0x7FE0000000000000LL) != 0 && (*(void *)&a7 & 0xFFFFFFFFFFFFFLL) == 0;
  int v17 = (LODWORD(v13) >> 23) - 150;
  LODWORD(v18) = LODWORD(v13) & 0x7FFFFF;
  if ((LODWORD(v13) & 0x7F800000) != 0) {
    unint64_t v18 = LODWORD(v13) & 0x7FFFFF | 0x800000u;
  }
  else {
    unint64_t v18 = v18;
  }
  if ((LODWORD(v13) & 0x7F800000) == 0) {
    int v17 = -149;
  }
  BOOL v19 = (LODWORD(v13) & 0x7F000000) != 0 && (LODWORD(v13) & 0x7FFFFF) == 0;
  if ((_DWORD)result == 1) {
    BOOL v20 = v19;
  }
  else {
    BOOL v20 = v16;
  }
  if ((_DWORD)result == 1) {
    int v21 = v17;
  }
  else {
    int v21 = v14;
  }
  if ((_DWORD)result == 1) {
    unint64_t v22 = v18;
  }
  else {
    unint64_t v22 = v15;
  }
  int v23 = v21 - __clz(v22 & 0xFFFFFFFFFFFFFLL) + 11;
  if ((v22 & 0x10000000000000LL) != 0) {
    int v23 = v21;
  }
  int v24 = vcvtpd_s64_f64((double)(v23 + 52) * 0.301029996 + -1.0e-10);
  if ((_DWORD)result == 2 && ~v24 > a2)
  {
    *a3 = 0;
    *a5 = 0;
    *a6 = -a2;
    return result;
  }

  bzero(v47, 0x204uLL);
  bzero(v46, 0x204uLL);
  bzero(v45, 0x204uLL);
  bzero(v44, 0x204uLL);
  if (v21 < 0)
  {
    if (v24 < 0)
    {
      uint64_t v43 = a4;
      sub_1808D5548((__int16 *)v47, 0xAu, -v24);
      if (v12 > 1)
      {
        sub_1808D5330(v47, v22);
        sub_1808D4C20(v46, 1);
        int v25 = -v21;
      }

      else
      {
        sub_1808D4C68(v44, (__int16 *)v47);
        sub_1808D4C68(v45, (__int16 *)v47);
        sub_1808D5330(v47, v22);
        int v25 = 1;
        sub_1808D4C20(v46, 1);
        sub_1808D51D8(v46, -v21);
        sub_1808D51D8(v47, 1);
      }

      sub_1808D51D8(v46, v25);
      a4 = v43;
    }

    else
    {
      sub_1808D4C38(v47, v22);
      sub_1808D5548(v46, 0xAu, v24);
      sub_1808D51D8(v46, -v21);
      if (v12 > 1) {
        goto LABEL_43;
      }
      sub_1808D51D8(v46, 1);
      sub_1808D51D8(v47, 1);
      sub_1808D4C20(v44, 1);
      sub_1808D4C20(v45, 1);
    }
  }

  else
  {
    sub_1808D4C38(v47, v22);
    sub_1808D51D8(v47, v21);
    sub_1808D5548(v46, 0xAu, v24);
    if (v12 > 1) {
      goto LABEL_43;
    }
    sub_1808D51D8(v46, 1);
    sub_1808D51D8(v47, 1);
    sub_1808D4C20(v44, 1);
    sub_1808D51D8(v44, v21);
    sub_1808D4C20(v45, 1);
    sub_1808D51D8(v45, v21);
  }

  char v26 = !v20;
  if (v12 > 1) {
    char v26 = 1;
  }
  if ((v26 & 1) == 0)
  {
    sub_1808D51D8(v46, 1);
    sub_1808D51D8(v47, 1);
    sub_1808D51D8(v44, 1);
  }

uint64_t sub_1808D4AD0(int a1, _DWORD *a2, unsigned __int16 *a3, __int16 *a4, _BYTE *a5, uint64_t a6, int *a7)
{
  uint64_t v13 = (a1 - 1);
  uint64_t v14 = (a1 - 2);
  if (a1 < 2)
  {
    char v23 = sub_1808D56D0(a3, a4);
    uint64_t result = sub_1808D5A3C((__int16 *)a3, (__int16 *)a3, a4);
    a5[(int)v13] = v23 + ((int)result >= 0) + 48;
  }

  else
  {
    uint64_t v15 = (a1 - 1);
    BOOL v16 = a5;
    do
    {
      *v16++ = sub_1808D56D0(a3, a4) + 48;
      sub_1808D5298((__int16 *)a3, 0xAu);
      --v15;
    }

    while (v15);
    uint64_t v17 = sub_1808D56D0(a3, a4);
    uint64_t result = sub_1808D5A3C((__int16 *)a3, (__int16 *)a3, a4);
    a5[(int)v13] = v17 + ((int)result >= 0) + 48;
    BOOL v19 = &a5[v13];
    char v20 = a5[v13];
    int v21 = &a5[v14];
    int v22 = a1;
    do
    {
      if (v20 != 58) {
        break;
      }
      *v19-- = 48;
      char v20 = *v21 + 1;
      *v21-- = v20;
      --v22;
    }

    while (v22 > 1);
  }

  if (*a5 == 58)
  {
    *a5 = 49;
    ++*a2;
  }

  *a7 = a1;
  return result;
}

_DWORD *sub_1808D4C20(_DWORD *result, int a2)
{
  *uint64_t result = 0;
  if (a2)
  {
    result[1] = a2;
    *(_WORD *)uint64_t result = 1;
  }

  return result;
}

_DWORD *sub_1808D4C38(_DWORD *result, unint64_t a2)
{
  *uint64_t result = 0;
  if (a2)
  {
    __int16 v2 = 0;
    uint64_t v3 = 1LL;
    do
    {
      result[v3] = a2 & 0xFFFFFFF;
      a2 >>= 28;
      ++v2;
      ++v3;
    }

    while (a2);
    *(_WORD *)uint64_t result = v2;
  }

  return result;
}

_WORD *sub_1808D4C68(_WORD *result, __int16 *a2)
{
  result[1] = a2[1];
  int v2 = *a2;
  if (v2 >= 1)
  {
    uint64_t v3 = (unsigned __int16)*a2;
    uint64_t v4 = result + 2;
    __int128 v5 = (int *)(a2 + 2);
    do
    {
      int v6 = *v5++;
      *v4++ = v6;
      --v3;
    }

    while (v3);
  }

  *uint64_t result = v2;
  return result;
}

void sub_1808D4CA0(unsigned __int16 *a1, uint64_t a2, int a3)
{
  int v3 = a3;
  *(_DWORD *)a1 = 0;
  if (a3 < 19)
  {
    unsigned int v6 = 0;
    int v10 = a3;
  }

  else
  {
    unsigned int v6 = 0;
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = 0LL;
      unint64_t v9 = 0LL;
      do
        unint64_t v9 = *(char *)(v7 + v8++) + 10 * v9 - 48;
      while (v8 != 19);
      v6 += 19;
      int v10 = v3 - 19;
      sub_1808D4DE4(a1, 19);
      sub_1808D4EB4(a1, v9);
      v7 += 19LL;
      BOOL v11 = v3 <= 37;
      v3 -= 19;
    }

    while (!v11);
  }

  if (v10 < 1)
  {
    unint64_t v12 = 0LL;
  }

  else
  {
    unint64_t v12 = 0LL;
    uint64_t v13 = v6;
    do
      unint64_t v12 = *(char *)(a2 + v13++) + 10 * v12 - 48;
    while (v13 < (int)(v10 + v6));
  }

  sub_1808D4DE4(a1, v10);
  sub_1808D4EB4(a1, v12);
  int v14 = (__int16)*a1;
  if (v14 < 1)
  {
    if (!*a1) {
LABEL_19:
    }
      a1[1] = 0;
  }

  else
  {
    while (!*(_DWORD *)&a1[2 * (unsigned __int16)v14])
    {
      int v15 = (__int16)v14;
      LOWORD(v14) = v14 - 1;
      *a1 = v14;
      if (v15 <= 1) {
        goto LABEL_19;
      }
    }
  }

unsigned __int16 *sub_1808D4DE4(unsigned __int16 *result, int a2)
{
  if (a2)
  {
    int v2 = result;
    if (*result)
    {
      int v4 = a2;
      if (a2 >= 27)
      {
        unsigned int v5 = a2;
        do
        {
          sub_1808D5330(v2, 0x6765C793FA10079DuLL);
          int v4 = v5 - 27;
          BOOL v6 = v5 > 0x35;
          v5 -= 27;
        }

        while (v6);
      }

      if (v4 < 13)
      {
        int v7 = v4;
      }

      else
      {
        do
        {
          sub_1808D5298((__int16 *)v2, 0x48C27395u);
          int v7 = v4 - 13;
          BOOL v6 = v4 > 0x19;
          v4 -= 13;
        }

        while (v6);
      }

      BOOL v8 = __OFSUB__(v7, 1);
      int v9 = v7 - 1;
      if (v9 < 0 == v8) {
        sub_1808D5298((__int16 *)v2, dword_180A372F0[v9]);
      }
      return sub_1808D51D8(v2, a2);
    }
  }

  return result;
}

void sub_1808D4EB4(unsigned __int16 *a1, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = a2;
    bzero(v5, 0x204uLL);
    uint64_t v4 = 0LL;
    do
    {
      *(_DWORD *)&v5[2 * v4 + 2] = v2 & 0xFFFFFFF;
      v2 >>= 28;
      ++v4;
    }

    while (v2);
    v5[0] = v4;
    sub_1808D4F24(a1, v5);
  }

void sub_1808D4F24(unsigned __int16 *a1, __int16 *a2)
{
  int v4 = (__int16)*a1;
  int v5 = (__int16)a1[1];
  int v6 = v5 + v4;
  uint64_t v7 = *a2;
  int v8 = a2[1];
  if (v6 - v5 >= 128) {
    abort();
  }
  int v9 = v8 - v5;
  if (v8 - v5 > v4) {
    bzero(&a1[2 * (__int16)*a1 + 2], 4LL * (~v5 + v8 - (__int16)*a1) + 4);
  }
  if ((int)v7 >= 1)
  {
    unsigned int v10 = 0;
    BOOL v11 = (__int16 *)(a1 + 2);
    uint64_t v12 = v9;
    uint64_t v13 = (int *)(a2 + 2);
    do
    {
      if (v12 >= v4) {
        int v14 = 0;
      }
      else {
        int v14 = *(_DWORD *)&v11[2 * v12];
      }
      int v15 = *v13++;
      unsigned int v16 = v14 + v10 + v15;
      *(_DWORD *)&v11[2 * v12] = v16 & 0xFFFFFFF;
      unsigned int v10 = v16 >> 28;
      ++v12;
      --v7;
    }

    while (v7);
    if (v10)
    {
      uint64_t v17 = (__int16 *)(a1 + 2);
      do
      {
        if (v12 >= v4) {
          int v18 = 0;
        }
        else {
          int v18 = *(_DWORD *)&v17[2 * v12];
        }
        unsigned int v19 = v18 + v10;
        *(_DWORD *)&v17[2 * v12] = v19 & 0xFFFFFFF;
        unsigned int v10 = v19 >> 28;
        ++v12;
      }

      while (v10);
    }

    int v9 = v12;
  }

  if (v9 <= v4) {
    unsigned __int16 v20 = v4;
  }
  else {
    unsigned __int16 v20 = v9;
  }
  *a1 = v20;
}

void sub_1808D5050(unsigned __int16 *a1, uint64_t a2)
{
  int v2 = (__int16)a1[1];
  int v3 = *(__int16 *)(a2 + 2);
  int v4 = v2 - v3;
  if (v2 > v3)
  {
    int v6 = (__int16)*a1;
    if (v4 + v6 > 128) {
      abort();
    }
    int v7 = *a1;
    if ((__int16)v6 >= 1)
    {
      uint64_t v8 = 2LL * (v2 + v7 - v3);
      unint64_t v9 = *a1;
      do
      {
        *(_DWORD *)&a1[v8] = *(_DWORD *)&a1[2 * v9];
        v8 -= 2LL;
      }

      while (v9-- > 1);
    }

    if (v4 >= 1) {
      bzero(a1 + 2, 4LL * (~v3 + v2) + 4);
    }
    *a1 = v7 + v4;
    a1[1] = v2 - v4;
  }

void sub_1808D50FC(unsigned __int16 *a1, __int16 *a2)
{
  uint64_t v4 = *a2;
  if (v4 >= 1)
  {
    int v5 = 0;
    int v6 = a2[1];
    int v7 = (__int16)a1[1];
    uint64_t v8 = v4;
    unint64_t v9 = (int *)&a1[2 * (v6 - v7) + 2];
    unsigned int v10 = (int *)(a2 + 2);
    do
    {
      int v11 = *v10++;
      int v12 = *v9 + v5 - v11;
      *v9++ = v12 & 0xFFFFFFF;
      int v5 = v12 >> 31;
      --v8;
    }

    while (v8);
    if (v12 < 0)
    {
      int v13 = v4 + v6 - v7;
      do
      {
        int v14 = (__int16 *)&a1[2 * v13++];
        int v15 = *((_DWORD *)v14 + 1) - 1;
        *((_DWORD *)v14 + 1) = v15 & 0xFFFFFFF;
      }

      while (v15 < 0);
    }
  }

  int v16 = (__int16)*a1;
  if (v16 < 1)
  {
    if (!*a1) {
LABEL_12:
    }
      a1[1] = 0;
  }

  else
  {
    while (!*(_DWORD *)&a1[2 * (unsigned __int16)v16])
    {
      int v17 = (__int16)v16;
      LOWORD(v16) = v16 - 1;
      *a1 = v16;
      if (v17 <= 1) {
        goto LABEL_12;
      }
    }
  }

_WORD *sub_1808D51D8(_WORD *result, int a2)
{
  int v2 = (__int16)*result;
  if (*result)
  {
    result[1] += a2 / 28;
    if (v2 >= 128) {
      abort();
    }
    return sub_1808D5234(result, a2 % 28);
  }

  return result;
}

_WORD *sub_1808D5234(_WORD *result, char a2)
{
  if ((__int16)*result >= 1)
  {
    uint64_t v2 = 0LL;
    unsigned int v3 = 0;
    uint64_t v4 = (unsigned __int16)*result;
    do
    {
      unsigned int v5 = *(_DWORD *)&result[v2 + 2];
      unsigned int v6 = (v5 << a2) + v3;
      unsigned int v3 = v5 >> (28 - a2);
      *(_DWORD *)&result[v2 + 2] = v6 & 0xFFFFFFF;
      v2 += 2LL;
    }

    while (2 * v4 != v2);
    if (v3)
    {
      *(_DWORD *)&result[2 * (__int16)v4 + 2] = v3;
      *uint64_t result = v4 + 1;
    }
  }

  return result;
}

__int16 *sub_1808D5298(__int16 *result, unsigned int a2)
{
  if (a2 != 1)
  {
    if (a2)
    {
      int v2 = *result;
      if (v2 >= 1)
      {
        uint64_t v3 = 0LL;
        unint64_t v4 = 0LL;
        do
        {
          unint64_t v5 = v4 + *(unsigned int *)&result[v3 + 2] * (unint64_t)a2;
          *(_DWORD *)&result[v3 + 2] = v5 & 0xFFFFFFF;
          unint64_t v4 = v5 >> 28;
          v3 += 2LL;
        }

        while (2LL * (unsigned __int16)v2 != v3);
        for (; v4; v4 >>= 28)
        {
          *(_DWORD *)&result[2 * (__int16)v2 + 2] = v4 & 0xFFFFFFF;
          LOWORD(v2) = v2 + 1;
          *uint64_t result = v2;
        }
      }
    }

    else
    {
      *(_DWORD *)uint64_t result = 0;
    }
  }

  return result;
}

unsigned __int16 *sub_1808D5330(unsigned __int16 *result, unint64_t a2)
{
  if (a2 != 1)
  {
    if (a2)
    {
      uint64_t v2 = *result;
      unsigned __int16 v3 = *result;
      if (*result) {
        BOOL v4 = (__int16)v2 < 1;
      }
      else {
        BOOL v4 = 1;
      }
      if (!v4)
      {
        unint64_t v5 = 0LL;
        unint64_t v6 = 0LL;
        uint64_t v7 = 4 * v2;
        do
        {
          uint64_t v8 = *(unsigned int *)&result[v5 / 2 + 2];
          unint64_t v9 = (v6 & 0xFFFFFFF) + a2 * (unint64_t)v8;
          *(_DWORD *)&result[v5 / 2 + 2] = v9 & 0xFFFFFFF;
          unint64_t v6 = ((a2 >> 28) & 0xFFFFFFFF0LL) * v8 + (v6 >> 28) + (v9 >> 28);
          v5 += 4LL;
        }

        while (v7 != v5);
        for (; v6; v6 >>= 28)
        {
          *(_DWORD *)&result[2 * (__int16)v3++ + 2] = v6 & 0xFFFFFFF;
          *uint64_t result = v3;
        }
      }
    }

    else
    {
      *(_DWORD *)uint64_t result = 0;
    }
  }

  return result;
}

__int16 *sub_1808D53E0(__int16 *result)
{
  uint64_t v1 = *result;
  uint64_t v2 = *result;
  uint64_t v3 = 2 * v2;
  if ((int)v1 < 1)
  {
    unint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v4 = (unsigned __int16)*result;
    unint64_t v5 = result + 2;
    uint64_t v6 = *result;
    do
    {
      v5[v4] = *v5;
      ++v5;
      --v6;
    }

    while (v6);
    unint64_t v7 = 0LL;
    uint64_t v8 = 4LL;
    unint64_t v9 = &result[2 * v4];
    do
    {
      uint64_t v10 = 2LL;
      uint64_t v11 = v8;
      do
      {
        v7 += *(unsigned int *)&v9[v10] * (unint64_t)*(unsigned int *)((char *)v9 + v11);
        v10 += 2LL;
        v11 -= 4LL;
      }

      while (v11);
      *(_DWORD *)&result[2 * v6 + 2] = v7 & 0xFFFFFFF;
      v7 >>= 28;
      ++v6;
      v8 += 4LL;
    }

    while (v6 != v1);
  }

  if ((int)v3 > (int)v1)
  {
    uint64_t v12 = (uint64_t)&result[2 * (int)v1 + 4];
    uint64_t v13 = 1LL;
    do
    {
      if (v2 < 2LL * (int)v1 - 1)
      {
        uint64_t v14 = v1;
        int v15 = (unsigned int *)v12;
        int v16 = &result[4 * (int)v1];
        do
        {
          unsigned int v18 = *(_DWORD *)v16;
          v16 -= 2;
          unsigned int v17 = v18;
          unsigned int v19 = *v15++;
          v7 += v19 * (unint64_t)v17;
          --v14;
        }

        while (v13 != v14);
      }

      *(_DWORD *)&result[2 * v2 + 2] = v7 & 0xFFFFFFF;
      v7 >>= 28;
      ++v2;
      ++v13;
      v12 += 4LL;
    }

    while (v2 != v3);
  }

  *uint64_t result = v3;
  result[1] *= 2;
  if ((__int16)v3 < 1)
  {
    if (!(2 * (_WORD)v1)) {
LABEL_22:
    }
      result[1] = 0;
  }

  else
  {
    while (!*(_DWORD *)&result[2 * (unsigned __int16)v3])
    {
      int v20 = (__int16)v3;
      LOWORD(v3) = v3 - 1;
      *uint64_t result = v3;
      if (v20 <= 1) {
        goto LABEL_22;
      }
    }
  }

  return result;
}

__int16 *sub_1808D5548(__int16 *result, unsigned int a2, int a3)
{
  uint64_t v3 = result;
  if (a3)
  {
    unsigned int v5 = a2;
    *(_DWORD *)uint64_t result = 0;
    int v6 = 0;
    if ((a2 & 1) == 0)
    {
      do
      {
        unsigned int v7 = v5 >> 1;
        unsigned int v5 = (unsigned __int16)v5 >> 1;
        ++v6;
      }

      while ((v7 & 1) == 0);
    }

    int v8 = 0;
    char v9 = 64;
    unsigned int v10 = v5;
    do
    {
      --v9;
      v8 += a3;
      BOOL v11 = v10 > 1;
      v10 >>= 1;
    }

    while (v11);
    if (v8 > 3555) {
      abort();
    }
    int v12 = 1;
    do
    {
      int v13 = v12;
      v12 *= 2;
    }

    while (v13 <= a3);
    int v14 = v13 >> 2;
    if (v13 >= 4)
    {
      int v15 = 0;
      uint64_t v17 = -1LL << v9;
      unint64_t v16 = v5;
      do
      {
        unsigned int v18 = v14;
        v16 *= v16;
        if ((v16 & v17) != 0) {
          uint64_t v19 = 1LL;
        }
        else {
          uint64_t v19 = v5;
        }
        uint64_t v20 = v19 * v16;
        int v21 = ((v16 & v17) != 0) | v15;
        if ((v14 & a3) != 0)
        {
          unint64_t v16 = v20;
          int v15 = v21;
        }

        v14 >>= 1;
      }

      while (v18 >= 2 && !HIDWORD(v16));
    }

    else
    {
      LOBYTE(v15) = 0;
      unint64_t v16 = v5;
    }

    if (v16)
    {
      uint64_t v22 = 0LL;
      do
      {
        *(_DWORD *)&result[2 * v22 + 2] = v16 & 0xFFFFFFF;
        v16 >>= 28;
        ++v22;
      }

      while (v16);
      *uint64_t result = v22;
    }

    if ((v15 & 1) != 0) {
      sub_1808D5298(result, v5);
    }
    if (v14)
    {
      do
      {
        sub_1808D53E0(v3);
        if ((v14 & a3) != 0) {
          sub_1808D5298(v3, v5);
        }
        BOOL v11 = v14 > 1;
        v14 >>= 1;
      }

      while (v11);
    }

    return sub_1808D51D8(v3, v6 * a3);
  }

  else
  {
    *(void *)uint64_t result = 0x100000001LL;
  }

  return result;
}

uint64_t sub_1808D56D0(unsigned __int16 *a1, __int16 *a2)
{
  if ((__int16)a1[1] + (__int16)*a1 >= a2[1] + *a2)
  {
    sub_1808D5050(a1, (uint64_t)a2);
    int v6 = (__int16)*a1;
    int v7 = *a2;
    if ((__int16)a1[1] + v6 <= a2[1] + v7)
    {
      int v2 = 0;
    }

    else
    {
      int v2 = 0;
      do
      {
        int v8 = *(_DWORD *)&a1[2 * v6];
        v2 += v8;
        sub_1808D5860(a1, a2, v8);
        int v6 = (__int16)*a1;
        int v7 = *a2;
      }

      while ((__int16)a1[1] + v6 > a2[1] + v7);
    }

    int v9 = (unsigned __int16)v6;
    unsigned int v10 = (unsigned int *)&a1[2 * v6];
    unsigned int v11 = *v10;
    unsigned int v12 = *(_DWORD *)&a2[2 * v7];
    if ((unsigned __int16)v7 == 1)
    {
      *unsigned int v10 = v11 % v12;
      v2 += v11 / v12;
      if ((__int16)v9 < 1)
      {
        if (!v9) {
LABEL_19:
        }
          a1[1] = 0;
      }

      else
      {
        while (!*(_DWORD *)&a1[2 * (unsigned __int16)v9])
        {
          int v13 = (__int16)v9;
          LOWORD(v9) = v9 - 1;
          *a1 = v9;
          if (v13 <= 1) {
            goto LABEL_19;
          }
        }
      }
    }

    else
    {
      unsigned int v14 = v11 / (v12 + 1);
      LOWORD(v2) = v2 + v14;
      sub_1808D5860(a1, a2, v14);
      if (v12 + v12 * v14 <= v11 && (int)sub_1808D5994((uint64_t)a2, (__int16 *)a1) <= 0)
      {
        do
        {
          sub_1808D50FC(a1, a2);
          LOWORD(v2) = v2 + 1;
        }

        while ((int)sub_1808D5994((uint64_t)a2, (__int16 *)a1) < 1);
      }
    }
  }

  else
  {
    LOWORD(v2) = 0;
  }

  return (unsigned __int16)v2;
}

void sub_1808D5860(unsigned __int16 *a1, __int16 *a2, int a3)
{
  int v3 = a3;
  if (a3 > 2)
  {
    int v6 = a2[1] - (__int16)a1[1];
    int v7 = *a2;
    if (v7 < 1)
    {
      unsigned int v8 = 0;
    }

    else
    {
      unsigned int v8 = 0;
      int v9 = (int *)&a1[2 * v6 + 2];
      unsigned int v10 = (unsigned int *)(a2 + 2);
      uint64_t v11 = *a2;
      do
      {
        unsigned int v12 = *v10++;
        unint64_t v13 = v12 * (unint64_t)a3 + v8;
        unsigned int v14 = *v9 - (v13 & 0xFFFFFFF);
        *v9++ = v14 & 0xFFFFFFF;
        unsigned int v8 = (v13 >> 28) + (v14 >> 31);
        --v11;
      }

      while (v11);
    }

    LODWORD(v15) = v6 + v7;
    uint64_t v16 = (__int16)*a1;
    if ((int)v15 >= (int)v16)
    {
LABEL_14:
      if ((int)v16 < 1)
      {
        if (!(_DWORD)v16) {
LABEL_19:
        }
          a1[1] = 0;
      }

      else
      {
        while (!*(_DWORD *)&a1[2 * (unsigned __int16)v16])
        {
          int v19 = (__int16)v16;
          LOWORD(v16) = v16 - 1;
          *a1 = v16;
          if (v19 <= 1) {
            goto LABEL_19;
          }
        }
      }
    }

    else
    {
      uint64_t v15 = (int)v15;
      uint64_t v17 = (__int16 *)(a1 + 2);
      while (v8)
      {
        unsigned int v18 = *(_DWORD *)&v17[2 * v15] - v8;
        *(_DWORD *)&v17[2 * v15] = v18 & 0xFFFFFFF;
        unsigned int v8 = v18 >> 31;
        if (++v15 >= v16) {
          goto LABEL_14;
        }
      }
    }
  }

  else if (a3 >= 1)
  {
    do
    {
      sub_1808D50FC(a1, a2);
      --v3;
    }

    while (v3);
  }

uint64_t sub_1808D5994(uint64_t result, __int16 *a2)
{
  uint64_t v2 = *(__int16 *)result;
  uint64_t v3 = *(__int16 *)(result + 2);
  uint64_t v4 = v3 + v2;
  uint64_t v5 = a2[1];
  uint64_t v6 = v5 + *a2;
  else {
    int v7 = a2[1];
  }
  uint64_t v8 = v2 + v3;
  int v9 = (unsigned int *)(result + 4 * v2);
  while (v8 > v7)
  {
    unsigned int v10 = 0;
    if (v8 > v3 && v8 <= v4) {
      unsigned int v10 = *v9;
    }
    unsigned int v11 = 0;
    if (v8 > v5 && v8 <= v6) {
      unsigned int v11 = *(_DWORD *)&a2[2 * v8 + -2 * v5];
    }
    --v9;
    --v8;
    BOOL v12 = v10 >= v11;
    BOOL v13 = v10 == v11;
    if (v10 > v11) {
      unsigned int v14 = 1;
    }
    else {
      unsigned int v14 = result;
    }
    if (v12) {
      uint64_t result = v14;
    }
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
    if (!v13) {
      return result;
    }
  }

  return 0LL;
}

uint64_t sub_1808D5A3C(__int16 *a1, __int16 *a2, __int16 *a3)
{
  __int16 v3 = *a1;
  __int16 v4 = a1[1];
  do
  {
    uint64_t v5 = a2;
    a2 = a1;
    int v6 = v4;
    int v7 = v4 + v3;
    __int16 v3 = *v5;
    int v8 = v5[1];
    __int16 v4 = v5[1];
    int v9 = v8 + *v5;
    a1 = v5;
  }

  while (v7 < v9);
  uint64_t v10 = *a3;
  uint64_t v11 = a3[1];
  uint64_t v12 = v11 + v10;
  __int16 v14 = a2[1];
  if (v8 < v6) {
    __int16 v14 = v5[1];
  }
  else {
    LODWORD(v15) = a3[1];
  }
  if ((int)v12 > (int)v15)
  {
    unsigned int v16 = 0;
    uint64_t v17 = v6;
    uint64_t v18 = v10 + v11;
    uint64_t v15 = (__int16)v15;
    int v19 = &a3[2 * v10];
    uint64_t v20 = &v5[-2 * v5[1]];
    int v21 = &a2[-2 * v6];
    while (1)
    {
      int v22 = 0;
      if (v18 > v17 && v18 <= v7) {
        int v22 = *(_DWORD *)&v21[2 * v18];
      }
      int v23 = 0;
      if (v18 > v8 && v18 <= v9) {
        int v23 = *(_DWORD *)&v20[2 * v18];
      }
      int v24 = 0;
      if (v18 > v11 && v18 <= v12) {
        int v24 = *(_DWORD *)v19;
      }
      unsigned int v25 = v23 + v22;
      unsigned int v26 = v24 + v16;
      unsigned int v27 = v24 + v16 - v25;
      if (v26 < v25) {
        break;
      }
      if (v27 > 1) {
        return 0xFFFFFFFFLL;
      }
      --v18;
      unsigned int v16 = v27 << 28;
      v19 -= 2;
      if (v18 <= v15)
      {
        if (v26 == v25) {
          return 0LL;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
    }

    return 1LL;
  }

  return 0LL;
}

uint64_t sub_1808D5B84(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  signed int v4 = vcvtpd_s64_f64((double)((int)result + 63) * 0.301029996);
  int v6 = v4 + 347;
  BOOL v5 = v4 < -347;
  int v7 = v4 + 354;
  if (!v5) {
    int v7 = v6;
  }
  int v8 = (char *)&unk_180A37320 + 16 * (v7 >> 3);
  uint64_t v9 = *((void *)v8 + 2);
  int v10 = *((__int16 *)v8 + 12);
  *a4 = *((__int16 *)v8 + 13);
  *(void *)a3 = v9;
  *(_DWORD *)(a3 + 8) = v10;
  return result;
}

uint64_t sub_1808D5BD4(uint64_t result, uint64_t a2, _DWORD *a3)
{
  int v3 = result + 348;
  signed int v4 = (char *)&unk_180A37320 + 16 * (v3 >> 3);
  uint64_t v5 = *(void *)v4;
  int v6 = *((__int16 *)v4 + 4);
  LODWORD(v4) = *((__int16 *)v4 + 5);
  *(void *)a2 = v5;
  *(_DWORD *)(a2 + 8) = v6;
  *a3 = (_DWORD)v4;
  return result;
}

uint64_t icu::double_conversion::DoubleToStringConverter::DoubleToAscii( uint64_t result, int a2, _BYTE *a3, unsigned int a4, BOOL *a5, int *a6, int *a7, double a8)
{
  if (a8 >= 0.0) {
    double v12 = a8;
  }
  else {
    double v12 = -a8;
  }
  *a5 = a8 < 0.0;
  if ((_DWORD)result != 3 || a2)
  {
    if (v12 == 0.0)
    {
      *(_WORD *)a3 = 48;
      *a6 = 1;
      *a7 = 1;
    }

    else
    {
      if ((_DWORD)result) {
        abort();
      }
      uint64_t v13 = a4;
      uint64_t result = sub_1808D5CF0(0, 0, (uint64_t)a3, a4, a6, a7, v12);
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1808D4590(0LL, a2, a3, v13, a6, a7, v12);
        a3[*a6] = 0;
      }
    }
  }

  else
  {
    *a3 = 0;
    *a6 = 0;
  }

  return result;
}

BOOL sub_1808D5CF0(unsigned int a1, int a2, uint64_t a3, uint64_t a4, int *a5, _DWORD *a6, double a7)
{
  if (a1 >= 2)
  {
    if (a1 != 2) {
      abort();
    }
    double v60 = a7;
    uint64_t v18 = sub_1808D620C(&v60);
    int v20 = v19;
    double v60 = 0.0;
    uint64_t v61 = 0LL;
    LODWORD(v59[0]) = 0;
    sub_1808D5B84((-124 - v19), (-96 - v19), (uint64_t)&v60, v59);
    unint64_t v21 = ((LODWORD(v60) * (unint64_t)HIDWORD(v18)) >> 32)
        + HIDWORD(v60) * (unint64_t)HIDWORD(v18)
        + ((HIDWORD(v60) * (unint64_t)v18) >> 32)
        + ((((LODWORD(v60) * (unint64_t)v18) >> 32)
          + (LODWORD(v60) * HIDWORD(v18))
    char v22 = -64 - (v20 + v61);
    int v23 = -(v20 + v61);
    unint64_t v24 = v21 >> -(char)(v20 + v61);
    int v25 = 1233 * (v20 + v61 + 64) + 80145;
    int v26 = v25 >> 12;
    uint64_t v27 = ((uint64_t)v25 >> 12) + 1;
    unsigned int v28 = dword_180A37890[(int)v27];
    unint64_t v29 = 1LL << v23;
    uint64_t v30 = (1LL << v23) - 1;
    unint64_t v31 = v21 & v30;
    LODWORD(v57) = v27;
    *a5 = 0;
    if ((int)v27 < 1)
    {
      int v32 = 0;
      if (a2)
      {
LABEL_30:
        if (a2 < 1 || v31 < 2) {
          return 0LL;
        }
        unint64_t v52 = 1LL;
        do
        {
          unsigned int v53 = a2;
          v52 *= 10LL;
          *(_BYTE *)(a3 + v32) = ((10 * v31) >> v22) + 48;
          int v32 = *a5 + 1;
          *a5 = v32;
          --a2;
          unint64_t v31 = v30 & (10 * v31);
          LODWORD(v27) = v27 - 1;
        }

        while (v53 >= 2 && v31 > v52);
        LODWORD(v57) = v27;
        if (a2) {
          return 0LL;
        }
        int v54 = (_BYTE *)a3;
        uint64_t v55 = a4;
LABEL_39:
        if ((sub_1808D6460(v54, v55, v32, v31, v29, v52, &v57) & 1) != 0)
        {
          int v51 = LODWORD(v57) - LODWORD(v59[0]);
          goto LABEL_41;
        }

        return 0LL;
      }
    }

    else
    {
      int v32 = 0;
      while (1)
      {
        *(_BYTE *)(a3 + v32) = v24 / v28 + 48;
        int v32 = *a5 + 1;
        *a5 = v32;
        LODWORD(v24) = v24 % v28;
        LODWORD(v27) = v27 - 1;
        if (!--a2) {
          break;
        }
        v28 /= 0xAu;
        if ((v27 + 1) <= 1)
        {
          LODWORD(v57) = v27;
          goto LABEL_30;
        }
      }

      LODWORD(v57) = v27;
    }

    v31 += (unint64_t)v24 << v22;
    unint64_t v29 = (unint64_t)v28 << v22;
    int v54 = (_BYTE *)a3;
    uint64_t v55 = a4;
    unint64_t v52 = 1LL;
    goto LABEL_39;
  }

  double v60 = a7;
  uint64_t v13 = sub_1808D620C(&v60);
  int v15 = v14;
  double v60 = 0.0;
  uint64_t v61 = 0LL;
  v59[0] = 0LL;
  v59[1] = 0LL;
  if (a1)
  {
    float v16 = a7;
    *(float *)&double v57 = v16;
    sub_1808D62F0((int *)&v57, (uint64_t)&v60, (uint64_t)v59);
  }

  else
  {
    double v57 = a7;
    sub_1808D6250(&v57, (uint64_t)&v60, (uint64_t)v59);
  }

  double v57 = 0.0;
  uint64_t v58 = 0LL;
  int v56 = 0;
  sub_1808D5B84((-124 - v15), (-96 - v15), (uint64_t)&v57, &v56);
  unint64_t v33 = ((LODWORD(v57) * (unint64_t)HIDWORD(v13)) >> 32)
      + HIDWORD(v57) * (unint64_t)HIDWORD(v13)
      + ((HIDWORD(v57) * (unint64_t)v13) >> 32)
      + ((((LODWORD(v57) * (unint64_t)v13) >> 32)
        + (LODWORD(v57) * HIDWORD(v13))
  unint64_t v34 = ((HIDWORD(v59[0]) * (unint64_t)LODWORD(v57)) >> 32)
      + HIDWORD(v59[0]) * (unint64_t)HIDWORD(v57)
      + ((LODWORD(v59[0]) * (unint64_t)HIDWORD(v57)) >> 32)
      + ((((LODWORD(v59[0]) * (unint64_t)LODWORD(v57)) >> 32)
        + (HIDWORD(v59[0]) * LODWORD(v57))
  unint64_t v35 = v34 + 1;
  unint64_t v36 = v34
      - (((HIDWORD(v60) * (unint64_t)LODWORD(v57)) >> 32)
       + HIDWORD(v60) * (unint64_t)HIDWORD(v57)
       + ((LODWORD(v60) * (unint64_t)HIDWORD(v57)) >> 32)
       + ((((LODWORD(v60) * (unint64_t)LODWORD(v57)) >> 32)
         + (HIDWORD(v60) * LODWORD(v57))
         + (LODWORD(v60) * HIDWORD(v57))
         + 0x80000000) >> 32))
      + 2;
  char v37 = -64 - (v15 + v58);
  unint64_t v38 = 1LL << -(char)(v15 + v58);
  unint64_t v39 = v35 >> -(char)(v15 + v58);
  unint64_t v40 = v35 & (v38 - 1);
  int v41 = 1233 * (v15 + v58 + 64) + 80145;
  int v42 = v41 >> 12;
  uint64_t v43 = ((uint64_t)v41 >> 12) + 1;
  else {
    int v44 = v42;
  }
  unsigned int v45 = dword_180A37890[v44];
  *a5 = 0;
  if (v44 >= 1)
  {
    int v46 = 0;
    int v47 = v44 + 1;
    while (1)
    {
      *(_BYTE *)(a3 + v46) = v39 / v45 + 48;
      int v46 = *a5 + 1;
      *a5 = v46;
      unint64_t v39 = v39 % v45;
      if ((v39 << v37) + v40 < v36) {
        break;
      }
      v45 /= 0xAu;
      if (--v47 <= 1)
      {
        int v44 = 0;
        goto LABEL_23;
      }
    }

    if (sub_1808D6390(a3, a4, v46, v35 - v33, v36, (v39 << v37) + v40, (unint64_t)v45 << v37, 1LL))
    {
      int v51 = v47 - v56 - 2;
      goto LABEL_41;
    }

    return 0LL;
  }

  int v46 = 0;
LABEL_23:
  uint64_t v48 = 1LL;
  do
  {
    v48 *= 10LL;
    uint64_t v49 = 5 * v36;
    v36 *= 10LL;
    *(_BYTE *)(a3 + v46) = ((10 * v40) >> v37) + 48;
    int v46 = *a5 + 1;
    *a5 = v46;
    unint64_t v40 = (v38 - 1) & (10 * v40);
    --v44;
  }

  while (v40 >= 2 * v49);
  BOOL result = sub_1808D6390(a3, a4, v46, v48 * (v35 - v33), v36, v40, v38, v48);
  if (result)
  {
    int v51 = v44 - v56;
LABEL_41:
    *a6 = *a5 + v51;
    *(_BYTE *)(a3 + *a5) = 0;
    return 1LL;
  }

  return result;
}

uint64_t sub_1808D620C(void *a1)
{
  uint64_t v1 = (*a1 & 0xFFFFFFFFFFFFFLL) << (__clz(*a1 & 0xFFFFFFFFFFFFFLL) - 11);
  if ((*a1 & 0x7FF0000000000000LL) != 0) {
    uint64_t v2 = *a1 | 0x10000000000000LL;
  }
  else {
    uint64_t v2 = v1;
  }
  return v2 << 11;
}

void *sub_1808D6250(void *result, uint64_t a2, uint64_t a3)
{
  if ((*result & 0x7FF0000000000000LL) != 0) {
    uint64_t v3 = *result & 0xFFFFFFFFFFFFFLL | 0x10000000000000LL;
  }
  else {
    uint64_t v3 = *result & 0xFFFFFFFFFFFFFLL;
  }
  uint64_t v4 = 2 * v3;
  unint64_t v5 = (2 * (v3 & 0x1FFFFFFFFFFFFFLL)) | 1;
  if ((*result & 0x7FF0000000000000LL) != 0) {
    int v6 = ((*result >> 52) & 0x7FF) - 1075;
  }
  else {
    int v6 = -1074;
  }
  char v7 = v6 - 1;
  int v8 = v6 - 1;
  do
  {
    unint64_t v9 = v5 >> 44;
    v5 <<= 10;
    v8 -= 10;
  }

  while (!v9);
  for (; (v5 & 0x8000000000000000LL) == 0; --v8)
    v5 *= 2LL;
  BOOL v10 = (*result & 0xFFFFFFFFFFFFFLL) == 0;
  BOOL v11 = (*result & 0x7FE0000000000000LL) != 0;
  uint64_t v12 = 4 * v3;
  char v13 = v6 - 2;
  BOOL v14 = !v10 || !v11;
  if (v10 && v11) {
    char v15 = v13;
  }
  else {
    char v15 = v7;
  }
  if (v14) {
    uint64_t v16 = v4;
  }
  else {
    uint64_t v16 = v12;
  }
  *(void *)a3 = v5;
  *(_DWORD *)(a3 + 8) = v8;
  *(void *)a2 = (v16 - 1) << (v15 - v8);
  *(_DWORD *)(a2 + 8) = v8;
  return result;
}

int *sub_1808D62F0(int *result, uint64_t a2, uint64_t a3)
{
  int v3 = *result;
  unsigned int v4 = *result & 0x7FFFFF;
  LODWORD(v5) = v4 | 0x800000;
  if ((*result & 0x7F800000) != 0) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((v3 & 0x7F800000) != 0) {
    int v6 = (*result >> 23) - 150;
  }
  else {
    int v6 = -149;
  }
  uint64_t v7 = 2LL * v5;
  unint64_t v8 = (2 * (v5 & 0xFFFFFF)) | 1;
  char v9 = v6 - 1;
  int v10 = v6 - 1;
  do
  {
    unint64_t v11 = v8 >> 44;
    v8 <<= 10;
    v10 -= 10;
  }

  while (!v11);
  for (; (v8 & 0x8000000000000000LL) == 0; --v10)
    v8 *= 2LL;
  BOOL v12 = v4 == 0;
  BOOL v13 = (v3 & 0x7F000000) != 0;
  uint64_t v14 = 4 * v5;
  char v15 = v6 - 2;
  BOOL v16 = !v12 || !v13;
  if (v12 && v13) {
    char v17 = v15;
  }
  else {
    char v17 = v9;
  }
  if (v16) {
    uint64_t v18 = v7;
  }
  else {
    uint64_t v18 = v14;
  }
  *(void *)a3 = v8;
  *(_DWORD *)(a3 + 8) = v10;
  *(void *)a2 = (v18 - 1) << (v17 - v10);
  *(_DWORD *)(a2 + 8) = v10;
  return result;
}

BOOL sub_1808D6390( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8)
{
  unint64_t v8 = a4 - a8;
  unint64_t v9 = a8 + a4;
  BOOL v10 = a5 - a6 < a7;
  if (a4 - a8 > a6 && a5 - a6 >= a7)
  {
    uint64_t v11 = -(uint64_t)a6;
    uint64_t v12 = a5 - a7;
    while (1)
    {
      unint64_t v13 = a6 + a7;
      if (a6 + a7 >= v8 && v8 + v11 < a8 - a4 + a7 + a6) {
        break;
      }
      --*(_BYTE *)(a1 + a3 - 1LL);
      unint64_t v14 = v12 + v11;
      BOOL v10 = v12 + v11 < a7;
      if (v13 < v8)
      {
        v11 -= a7;
        a6 += a7;
        if (v14 >= a7) {
          continue;
        }
      }

      goto LABEL_11;
    }

    BOOL v10 = 0;
  }

  unint64_t v13 = a6;
LABEL_11:
  unint64_t v15 = v9 - v13;
  if (v9 > v13 && !v10)
  {
    BOOL v16 = v13 + a7 >= v9;
    unint64_t v17 = v13 + a7 - v9;
    if (!v16 || v15 > v17) {
      return 0LL;
    }
  }

  return v13 >= 2 * a8 && v13 <= a5 - 4 * a8;
}

uint64_t sub_1808D6460( _BYTE *a1, uint64_t a2, int a3, unint64_t a4, unint64_t a5, unint64_t a6, _DWORD *a7)
{
  uint64_t v7 = 0LL;
  if (a5 > a6 && a5 - a6 > a6)
  {
    if (a5 - a4 <= a4 || a5 - 2 * a4 < 2 * a6)
    {
      if (a4 <= a6 || a5 - (a4 - a6) > a4 - a6) {
        return 0LL;
      }
      uint64_t v8 = a3 - 1LL;
      ++a1[v8];
      if (a3 >= 2)
      {
        unint64_t v9 = &a1[v8];
        char v10 = *v9;
        uint64_t v11 = &a1[a3 - 2];
        do
        {
          if (v10 != 58) {
            break;
          }
          *v9-- = 48;
          char v10 = *v11 + 1;
          *v11-- = v10;
          --a3;
        }

        while (a3 > 1);
      }

      if (*a1 == 58)
      {
        *a1 = 49;
        ++*a7;
      }
    }

    return 1LL;
  }

  return v7;
}

double sub_1808D6528(double *a1, unsigned __int8 *a2, int a3, _DWORD *a4)
{
  return sub_1808D6534(a1, a2, a3, 1, a4);
}

double sub_1808D6534(double *a1, unsigned __int8 *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  int v6 = (char *)&a2[a3];
  uint64_t v77 = v6;
  *(void *)unsigned int v78 = a2;
  *a5 = 0;
  if (!a3) {
    return a1[1];
  }
  unsigned int v10 = *(_DWORD *)a1;
  int v11 = (*(_DWORD *)a1 >> 4) & 1;
  uint64_t v12 = a2;
  if ((*(_DWORD *)a1 & 8) == 0)
  {
    uint64_t v12 = a2;
    if (!v11)
    {
      int v13 = *a2;
      uint64_t v12 = a2;
      goto LABEL_5;
    }
  }

LABEL_201:
    abort();
  }

  if ((v10 & 0x40) != 0) {
    goto LABEL_201;
  }
  int v21 = *v12;
  if (*v20 == v21)
  {
    char v22 = *(char **)v78;
    if (((v11 | ((v10 & 4) >> 2)) & 1) != 0)
    {
      if ((v10 & 4) != 0 || *(char **)v78 == v6)
      {
        LODWORD(v6) = *(_DWORD *)v78;
      }

      else
      {
        do
        {
          uint64_t v23 = 0LL;
          while (byte_180A378BC[v23] != *v22)
          {
            if (++v23 == 6) {
              return a1[2];
            }
          }

          ++v22;
        }

        while (v22 != v6);
        LODWORD(v6) = (_DWORD)a2 + v14;
      }
    }

    else if (*(char **)v78 != v6)
    {
      return a1[2];
    }

    *a5 = (_DWORD)v6 - (_DWORD)a2;
    BOOL v43 = !v15;
    double result = INFINITY;
    unint64_t v44 = 0xFFF0000000000000LL;
LABEL_116:
    double v45 = *(double *)&v44;
    goto LABEL_197;
  }

  unint64_t v24 = (unsigned __int8 *)*((void *)a1 + 4);
  if (v24)
  {
LABEL_46:
    if (*v24 == v21)
    {
      int v25 = *(char **)v78;
      if (((v11 | ((v10 & 4) >> 2)) & 1) != 0)
      {
        if ((v10 & 4) != 0 || *(char **)v78 == v6)
        {
          LODWORD(v6) = *(_DWORD *)v78;
        }

        else
        {
          do
          {
            uint64_t v26 = 0LL;
            while (byte_180A378BC[v26] != *v25)
            {
              if (++v26 == 6) {
                return a1[2];
              }
            }

            ++v25;
          }

          while (v25 != v6);
          LODWORD(v6) = (_DWORD)a2 + v14;
        }
      }

      else if (*(char **)v78 != v6)
      {
        return a1[2];
      }

      *a5 = (_DWORD)v6 - (_DWORD)a2;
      BOOL v43 = !v15;
      double result = NAN;
      unint64_t v44 = 0xFFF8000000000000LL;
      goto LABEL_116;
    }
  }

        if (v12 >= v15)
        {
          icu::number::impl::DecimalQuantity::setBcdToZero((void **)a1);
          *(_DWORD *)(a1 + 12) = a2;
        }

        else
        {
          icu::number::impl::DecimalQuantity::shiftRight(a1, v12);
        }

        if (!a4) {
          goto LABEL_227;
        }
        else {
          int v46 = 0;
        }
        if (v46 == 1)
        {
          if (*(_BYTE *)(a1 + 64))
          {
            icu::number::impl::DecimalQuantity::ensureCapacity((icu::number::impl::DecimalQuantity *)a1, 1);
            **(_BYTE **)(a1 + 48) = 0;
          }

          else
          {
            *(void *)(a1 + 48) &= 0xFFFFFFFFFFFFFFF0LL;
          }
        }

        else
        {
          else {
            int v47 = v41;
          }
          if ((v47 & 1) != 0)
          {
            if (*(_BYTE *)(a1 + 64))
            {
              icu::number::impl::DecimalQuantity::ensureCapacity((icu::number::impl::DecimalQuantity *)a1, 1);
              **(_BYTE **)(a1 + 48) = 5;
            }

            else
            {
              *(void *)(a1 + 48) = *(void *)(a1 + 48) & 0xFFFFFFFFFFFFFFF0LL | 5;
            }

            if (!*(_DWORD *)(a1 + 16)) {
              *(_DWORD *)(a1 + 16) = 1;
            }
            return;
          }

          if (*(_BYTE *)(a1 + 64))
          {
            icu::number::impl::DecimalQuantity::ensureCapacity((icu::number::impl::DecimalQuantity *)a1, 1);
            LODWORD(v13) = 9;
            **(_BYTE **)(a1 + 48) = 9;
          }

          else
          {
            *(void *)(a1 + 48) = *(void *)(a1 + 48) & 0xFFFFFFFFFFFFFFF0LL | 9;
            LODWORD(v13) = 9;
          }

LABEL_133:
    *a5 = (_DWORD)v49 - (_DWORD)a2;
  }

  return result;
}

double sub_1808D6E78(double *a1, unsigned __int16 *a2, int a3, _DWORD *a4)
{
  return sub_1808D6E84(a1, a2, a3, 1, a4);
}

double sub_1808D6E84(double *a1, unsigned __int16 *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  int v6 = &a2[a3];
  int v64 = v6;
  *(void *)uint64_t v65 = a2;
  *a5 = 0;
  if (!a3) {
    return a1[1];
  }
  unsigned int v10 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 0x18) != 0)
  {
    int v11 = a2;
    while (1)
    {
      unsigned int v12 = *v11;
      if (v12 >= 0x80) {
        break;
      }
      uint64_t v13 = 0LL;
      while (byte_180A378BC[v13] != v12)
      {
        if (++v13 == 6) {
          goto LABEL_16;
        }
      }

LABEL_176:
        int v62 = v66;
        double v15 = sub_1808D7F34(&v62, &v66[v23], v59, *((unsigned __int16 *)a1 + 20), (v10 & 4) != 0, v58, &v63, a1[2]);
        _DWORD *v60 = (*(void *)v65 - (void)a2) >> 1;
        return v15;
      }

      if (v25 > 771)
      {
        ++v24;
        v61 |= v27 != 48;
        if ((v22 & 1) != 0)
        {
LABEL_63:
          int v22 = *v26 < 0x38u;
          goto LABEL_64;
        }
      }

      else
      {
        v66[v23++] = v27;
        ++v25;
        if ((v22 & 1) != 0) {
          goto LABEL_63;
        }
      }

      int v22 = 0;
LABEL_64:
      if ((sub_1808D843C((unsigned __int16 **)v65, *((unsigned __int16 *)a1 + 20), 10, &v64) & 1) != 0)
      {
        int v28 = 0;
        goto LABEL_66;
      }
    }
  }

  int v34 = *((unsigned __int16 *)a1 + 20);
  if (sub_1808D843C((unsigned __int16 **)v65, v34, 10, &v64))
  {
LABEL_74:
    *a5 = (*(void *)v65 - (void)a2) >> 1;
    BOOL v35 = !v16;
LABEL_75:
    if (v35) {
      return 0.0;
    }
    else {
      return -0.0;
    }
  }

  if ((v10 & 0x81) == 0 || (uint64_t v36 = *(void *)v65, ((unsigned __int16)**(_WORD **)v65 | 0x20) != 0x78))
  {
    while (**(_WORD **)v65 == 48)
    {
    }

    int v58 = a4;
    int v59 = v16;
    int v60 = a5;
    int v22 = (v10 >> 1) & 1;
    goto LABEL_57;
  }

  char v37 = (unsigned __int16 *)(*(void *)v65 + 2LL);
  *(void *)v65 += 2LL;
  if ((v10 & 0x80) != 0 && (sub_1808D850C((unsigned __int16 *)(v36 + 2), v6, v34, (v10 & 4) != 0) & 1) != 0)
  {
    int v38 = 1;
  }

  else
  {
    unsigned int v48 = *v37;
    if (v48 - 48 >= 0xA || v48 >= 0x40)
    {
      unsigned int v50 = v48 - 65;
      if (v50 >= 0x26 || ((0x3F0000003FuLL >> v50) & 1) == 0) {
        return a1[2];
      }
    }

    int v38 = 0;
  }

  v66[0] = 0;
  double v15 = sub_1808D8708( (unsigned __int16 **)v65,  v6,  v16,  *((unsigned __int16 *)a1 + 20),  v38,  (v10 & 4) != 0,  a4,  v66,  a1[2]);
  if (!v66[0])
  {
    if ((v10 & 0x10) != 0) {
      sub_1808D8338((unsigned __int16 **)v65, v6);
    }
    *a5 = (*(void *)v65 - (void)a2) >> 1;
  }

  return v15;
}

              char v105 = 0LL;
              goto LABEL_177;
            }

            int v115 = *(void *)(v102 + 120);
            uint64_t v116 = *(_DWORD *)(v102 + 128);
            double v46 = v168;
            if (v82)
            {
              uint64_t v117 = (icu::UnicodeString *)(*(void *)(v102 + 472) + 256LL);
LABEL_183:
              sub_18098A598((icu::UnicodeString *)a2, v34, v115, v116, v117, a10);
              int v32 = 2;
              goto LABEL_191;
            }

            break;
          case 4:
            v106 = *(void *)(v14 + 768);
            if (PatternCharIndex == 2)
            {
              int v103 = *(void *)(v106 + 56);
              char v104 = *(_DWORD *)(v106 + 64);
              double v46 = v168;
              if (v82)
              {
                char v105 = *(icu::UnicodeString **)(v106 + 472);
                goto LABEL_177;
              }

              goto LABEL_176;
            }

            int v115 = *(void *)(v106 + 104);
            uint64_t v116 = *(_DWORD *)(v106 + 112);
            double v46 = v168;
            if (v82)
            {
              uint64_t v117 = (icu::UnicodeString *)(*(void *)(v106 + 472) + 192LL);
              goto LABEL_183;
            }

            break;
          case 5:
            BOOL v83 = *(void *)(v14 + 768);
            if (PatternCharIndex == 2)
            {
              int v84 = *(void *)(v83 + 88);
              int v85 = *(_DWORD *)(v83 + 96);
              double v46 = v168;
              if (v82)
              {
                uint64_t v86 = (icu::UnicodeString *)(*(void *)(v83 + 472) + 128LL);
LABEL_181:
                sub_18098A598((icu::UnicodeString *)a2, v34, v84, v85, v86, a10);
                int v32 = 3;
                goto LABEL_191;
              }
            }

            else
            {
              int v84 = *(void *)(v83 + 136);
              int v85 = *(_DWORD *)(v83 + 144);
              double v46 = v168;
              if (v82)
              {
                uint64_t v86 = (icu::UnicodeString *)(*(void *)(v83 + 472) + 320LL);
                goto LABEL_181;
              }
            }

            uint64_t v86 = 0LL;
            goto LABEL_181;
          default:
            memset((char *)v172 + 8, 0, 56);
            *(void *)&v172[0] = off_18971B688;
            WORD4(v172[0]) = 2;
            icu::SimpleDateFormat::zeroPaddingNumber( (icu::SimpleDateFormat *)v14,  lpsrc,  (icu::UnicodeString *)v172,  v34 + 1,  a4,  10LL);
            if (v82) {
              char v107 = (icu::UnicodeString *)(*(void *)(*(void *)(v14 + 768) + 472LL) + 384LL);
            }
            else {
              char v107 = 0LL;
            }
            double v46 = v168;
            sub_18098A598((icu::UnicodeString *)a2, 0, (uint64_t)v172, 1, v107, a10);
            icu::UnicodeString::~UnicodeString(v118, (icu::UnicodeString *)v172);
            goto LABEL_190;
        }

        uint64_t v117 = 0LL;
        goto LABEL_183;
      case 4u:
        int v38 = v166;
        if (v166) {
          goto LABEL_67;
        }
        BOOL v41 = (*(uint64_t (**)(icu::Calendar *, uint64_t))(*(void *)a9 + 128LL))(a9, 11LL);
        goto LABEL_45;
      case 8u:
        else {
          double v42 = a4;
        }
        if ((_DWORD)a4 == 1)
        {
          float v45 = 100;
          double v46 = v168;
          unint64_t v43 = v166;
          uint64_t v44 = lpsrc;
        }

        else
        {
          unint64_t v43 = v166;
          uint64_t v44 = lpsrc;
          if ((_DWORD)a4 != 2)
          {
            icu::SimpleDateFormat::zeroPaddingNumber( (icu::SimpleDateFormat *)v14,  lpsrc,  (icu::UnicodeString *)a2,  v166,  v42,  10LL);
            double v46 = v168;
            if ((int)a4 >= 4)
            {
              unint64_t v109 = (icu::SimpleDateFormat *)v14;
              uint64_t v44 = lpsrc;
              int v110 = (icu::UnicodeString *)a2;
              v108 = 0LL;
              double v42 = (a4 - 3);
LABEL_161:
              icu::SimpleDateFormat::zeroPaddingNumber(v109, v44, v110, v108, v42, 10LL);
            }

uint64_t sub_1808D76CC(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, char a4)
{
  if ((a4 & 1) != 0)
  {
    int v4 = *(unsigned __int8 *)(a3 + 1);
    uint64_t v5 = *a1 + 1;
    *a1 = v5;
    if (v4)
    {
      return 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  else
  {
    uint64_t v7 = (unsigned __int8 *)(*a1 + 1);
    uint64_t v8 = (_BYTE *)(a3 + 1);
    do
    {
      BOOL v9 = *v8 == 0;
      BOOL v6 = *v8 == 0;
      *a1 = (uint64_t)v7;
      BOOL v9 = v9 || v7 == a2;
      if (v9) {
        break;
      }
      int v11 = *v7++;
      int v10 = v11;
      int v12 = *v8++;
    }

    while (v10 == v12);
  }

  return v6;
}

uint64_t sub_1808D7748(char **a1, int a2, int a3, char **a4)
{
  BOOL v6 = *a1;
  if (!a2)
  {
    *a1 = v6 + 1;
    return v6 + 1 == *a4;
  }

  BOOL v9 = v6 + 1;
  LODWORD(result) = sub_1808D7A5C(*v6, a3);
  int v11 = result;
  *a1 = v6 + 1;
  int v12 = *a4;
  if (v6 + 1 == *a4) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = result;
  }
  if (v11) {
    BOOL v13 = v9 == v12;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    uint64_t v14 = v6 + 2;
    if (v14 == v12) {
      return 0LL;
    }
    if (*v9 == a2 && sub_1808D7A5C(*v14, a3))
    {
      *a1 = v14;
      int v12 = *a4;
      BOOL v9 = v14;
    }

    return v9 == v12;
  }

  return result;
}

uint64_t sub_1808D7818(char *a1, char *a2, int a3, char a4)
{
  char v7 = 0;
  int v21 = a1;
  int v22 = a2;
  while (1)
  {
    int v8 = *v21;
    if ((v8 - 48) >= 0xA || v8 >= 64)
    {
    }

    char v7 = 1;
    if ((sub_1808D7748(&v21, a3, 16, &v22) & 1) != 0) {
      return 0LL;
    }
  }

  if (*v21 == 46)
  {
    if ((sub_1808D7748(&v21, a3, 16, &v22) & 1) != 0) {
      return 0LL;
    }
    while (1)
    {
      int v8 = *v21;
      BOOL v11 = v8 >= 64 || (v8 - 48) >= 0xA;
      BOOL v12 = !v11;
      char v13 = sub_1808D7748(&v21, a3, 16, &v22);
      uint64_t result = 0LL;
      char v7 = 1;
      if ((v13 & 1) != 0) {
        return result;
      }
    }
  }

uint64_t sub_1808D7A5C(int a1, int a2)
{
  BOOL v3 = a2 + 55 > a1;
  if (a2 < 11) {
    BOOL v3 = 0;
  }
  return a1 >= 65 && v3;
}

double sub_1808D7AB8(char **a1, char *a2, int a3, int a4, int a5, char a6, int a7, _BYTE *a8, double a9)
{
  unsigned int v53 = a2;
  *a8 = 1;
  while (1)
  {
    uint64_t v18 = *a1;
    int v19 = **a1;
    if (v19 != 48) {
      break;
    }
    if (sub_1808D7748(a1, a4, 16, &v53))
    {
      *a8 = 0;
      if (a3) {
        return -0.0;
      }
      else {
        return 0.0;
      }
    }
  }

  char v52 = a6;
  int v20 = 0;
  int64_t v21 = 0LL;
  char v22 = 0;
  if (a7) {
    char v23 = 53;
  }
  else {
    char v23 = 24;
  }
  while (1)
  {
    unsigned int v24 = (char)v19 - 48;
    if (v24 < 0xA) {
      goto LABEL_15;
    }
    if (((char)v19 - 97) <= 5)
    {
      unsigned int v24 = (char)v19 - 87;
      goto LABEL_15;
    }

    unsigned int v24 = (char)v19 - 55;
LABEL_15:
    if ((v22 & 1) != 0) {
      v20 -= 4;
    }
    int64_t v21 = 16 * v21 + v24;
    uint64_t v25 = v21 >> v23;
    if ((v21 >> v23))
    {
      int v50 = a3;
      int v26 = 1;
      if ((int)v25 >= 2)
      {
        do
        {
          ++v26;
          BOOL v31 = v25 > 3;
          LODWORD(v25) = v25 >> 1;
        }

        while (v31);
      }

      unsigned int v51 = a2;
      int v27 = v26 + v20;
      if ((sub_1808D7748(a1, a4, 16, &v53) & 1) != 0)
      {
        char v28 = 1;
LABEL_43:
        if ((a5 & 1) == 0 && (v52 & 1) == 0)
        {
          for (uint64_t i = *a1; i != v51; *a1 = i)
          {
            uint64_t v34 = 0LL;
            while (byte_180A378BC[v34] != *i)
            {
              if (++v34 == 6) {
                return a9;
              }
            }

            ++i;
          }
        }

        int v35 = v21 & ~(-1 << v26);
        int v36 = 1 << (v26 - 1);
        uint64_t v37 = (v21 >> v26) + ((v21 >> v26) & 1u | ((v28 & 1) == 0));
        if (v35 != v36) {
          uint64_t v37 = v21 >> v26;
        }
        if (v35 > v36) {
          uint64_t v38 = (v21 >> v26) + 1;
        }
        else {
          uint64_t v38 = v37;
        }
        int v20 = v27 + (((unint64_t)v38 >> v23) & 1);
        int64_t v21 = v38 >> (((unint64_t)v38 >> v23) & 1);
        a3 = v50;
        goto LABEL_57;
      }

      char v28 = 1;
      while (2)
      {
        int v29 = *a1;
        if (a5)
        {
          int v30 = *v29;
          if (v30 == 46)
          {
            sub_1808D7748(a1, a4, 16, &v53);
            int v29 = *a1;
            char v22 = 1;
            goto LABEL_31;
          }
        }

        else
        {
LABEL_31:
          int v30 = *v29;
        }

        BOOL v31 = ((char)v30 - 48) < 0xA && (char)v30 < 64;
        v28 &= v30 == 48;
        if ((v22 & 1) == 0) {
          v27 += 4;
        }
        continue;
      }
    }

    if ((sub_1808D7748(a1, a4, 16, &v53) & 1) != 0) {
      goto LABEL_57;
    }
LABEL_19:
    uint64_t v18 = *a1;
    LOBYTE(v19) = **a1;
  }

  if (!a5) {
    goto LABEL_91;
  }
  if ((char)v19 == 46)
  {
    sub_1808D7748(a1, a4, 16, &v53);
    char v22 = 1;
    goto LABEL_19;
  }

  if (v19 != 80 && v19 != 112)
  {
LABEL_91:
    if (v18 != a2 && (v52 & 1) == 0)
    {
      do
      {
        uint64_t v49 = 0LL;
        while (byte_180A378BC[v49] != *v18)
        {
          if (++v49 == 6) {
            return a9;
          }
        }

        *a1 = ++v18;
      }

      while (v18 != a2);
    }

double sub_1808D7F34(char **a1, char *a2, int a3, int a4, char a5, int a6, _BYTE *a7, double a8)
{
  int v39 = a2;
  *a7 = 1;
  while (**a1 == 48)
  {
    if (sub_1808D8294(a1, a4, &v39))
    {
      *a7 = 0;
      if (a3) {
        return -0.0;
      }
      else {
        return 0.0;
      }
    }
  }

  int64_t v16 = 0LL;
  if (a6) {
    char v17 = 53;
  }
  else {
    char v17 = 24;
  }
  while (1)
  {
    uint64_t v18 = *a1;
    int v19 = **a1;
    if (v19 > 55 || (v19 - 48) >= 0xA)
    {
      if (v18 != a2 && (a5 & 1) == 0)
      {
        do
        {
          uint64_t v22 = 0LL;
          while (byte_180A378BC[v22] != *v18)
          {
            if (++v22 == 6) {
              return a8;
            }
          }

          *a1 = ++v18;
        }

        while (v18 != a2);
      }

unint64_t sub_1808D81FC(unint64_t a1, int a2)
{
  if (a1 >> 53)
  {
    do
    {
      unint64_t v2 = a1 >> 1;
      ++a2;
      unint64_t v3 = a1 >> 54;
      a1 >>= 1;
    }

    while (v3);
  }

  else
  {
    unint64_t v2 = a1;
  }

  if (a2 > 971) {
    return 0x7FF0000000000000LL;
  }
  if (a2 < -1074) {
    return 0LL;
  }
  BOOL v5 = (v2 & 0x10000000000000LL) == 0;
  if (a2 != -1074 && (v2 & 0x10000000000000LL) == 0)
  {
    do
    {
      int v6 = a2;
      uint64_t v8 = v2 & 0x8000000000000LL;
      BOOL v7 = (v2 & 0x8000000000000LL) == 0;
      v2 *= 2LL;
      --a2;
      BOOL v5 = v7;
    }

    while (v6 >= -1072 && !v8);
  }

  if (a2 == -1074 && v5) {
    unint64_t v9 = 0LL;
  }
  else {
    unint64_t v9 = (unint64_t)(a2 + 1075) << 52;
  }
  return v9 & 0xFFF0000000000000LL | v2 & 0xFFFFFFFFFFFFFLL;
}

BOOL sub_1808D8294(char **a1, int a2, char **a3)
{
  unint64_t v3 = *a1;
  if (!a2)
  {
    *a1 = v3 + 1;
    return v3 + 1 == *a3;
  }

  BOOL v5 = v3 + 1;
  int v4 = *v3;
  BOOL v7 = v4 > 55 || (v4 - 58) < 0xFFFFFFF6;
  *a1 = v5;
  uint64_t v8 = *a3;
  LODWORD(v9) = !v7;
  if (v5 == *a3) {
    uint64_t v9 = 1LL;
  }
  else {
    uint64_t v9 = v9;
  }
  if (!v7 && v5 != v8)
  {
    int v10 = v3 + 2;
    if (v3 + 2 == v8) {
      return 0LL;
    }
    if (*v5 == a2)
    {
      int v11 = *v10;
      if (v11 <= 55 && (v11 - 48) <= 9)
      {
        *a1 = v10;
        uint64_t v8 = *a3;
        BOOL v5 = v10;
      }
    }

    return v5 == v8;
  }

  return v9;
}

uint64_t sub_1808D8338(unsigned __int16 **a1, unsigned __int16 *a2)
{
  for (int i = *a1; i != a2; *a1 = i)
  {
    unsigned int v3 = *i;
    if (v3 >= 0x80)
    {
      uint64_t v5 = 0LL;
      while ((unsigned __int16)word_180A378C2[v5] != v3)
      {
        if (++v5 == 20) {
          return 1LL;
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
      while (byte_180A378BC[v4] != v3)
      {
        if (++v4 == 6) {
          return 1LL;
        }
      }
    }

    ++i;
  }

  return 0LL;
}

uint64_t sub_1808D83C0(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, char a4)
{
  if ((a4 & 1) != 0)
  {
    int v4 = *(unsigned __int8 *)(a3 + 1);
    uint64_t v5 = *a1 + 2;
    *a1 = v5;
    if (v4)
    {
      return 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  else
  {
    BOOL v7 = (unsigned __int8 *)(*a1 + 2);
    uint64_t v8 = (_BYTE *)(a3 + 1);
    do
    {
      BOOL v9 = *v8 == 0;
      BOOL v6 = *v8 == 0;
      *a1 = (uint64_t)v7;
      BOOL v9 = v9 || v7 == a2;
      if (v9) {
        break;
      }
      int v11 = *v7;
      v7 += 2;
      int v10 = v11;
      int v12 = *v8++;
    }

    while (v12 == v10);
  }

  return v6;
}

uint64_t sub_1808D843C(unsigned __int16 **a1, int a2, int a3, unsigned __int16 **a4)
{
  BOOL v6 = *a1;
  if (!a2)
  {
    *a1 = v6 + 1;
    return v6 + 1 == *a4;
  }

  BOOL v9 = v6 + 1;
  LODWORD(result) = sub_1808D7A5C(*v6, a3);
  int v11 = result;
  *a1 = v6 + 1;
  int v12 = *a4;
  if (v6 + 1 == *a4) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = result;
  }
  if (v11) {
    BOOL v13 = v9 == v12;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    int v14 = v6 + 2;
    if (v14 == v12) {
      return 0LL;
    }
    if (*v9 == a2 && sub_1808D7A5C(*v14, a3))
    {
      *a1 = v14;
      int v12 = *a4;
      BOOL v9 = v14;
    }

    return v9 == v12;
  }

  return result;
}

uint64_t sub_1808D850C(unsigned __int16 *a1, unsigned __int16 *a2, int a3, char a4)
{
  char v7 = 0;
  int v19 = a1;
  int v20 = a2;
  while (1)
  {
    unsigned int v8 = *v19;
    if (v8 - 48 >= 0xA || v8 >= 0x40)
    {
      if (v8 - 46 > 0x38) {
        goto LABEL_25;
      }
    }

    char v7 = 1;
    if ((sub_1808D843C(&v19, a3, 16, &v20) & 1) != 0) {
      return 0LL;
    }
  }

  if (v8 == 46)
  {
    if ((sub_1808D843C(&v19, a3, 16, &v20) & 1) != 0) {
      return 0LL;
    }
    while (1)
    {
      unsigned int v8 = *v19;
      BOOL v11 = v8 >= 0x40 || v8 - 48 >= 0xA;
      BOOL v12 = !v11;
      if (v8 - 97 >= 6 && !v12 && (v8 <= 0x40 || v8 > 0x46)) {
        break;
      }
      char v13 = sub_1808D843C(&v19, a3, 16, &v20);
      uint64_t result = 0LL;
      char v7 = 1;
      if ((v13 & 1) != 0) {
        return result;
      }
    }
  }

double sub_1808D8708( unsigned __int16 **a1, unsigned __int16 *a2, int a3, int a4, int a5, char a6, int a7, _BYTE *a8, double a9)
{
  int v58 = a2;
  *a8 = 1;
  while (1)
  {
    char v18 = *a1;
    int v19 = **a1;
    if (v19 != 48) {
      break;
    }
    if (sub_1808D843C(a1, a4, 16, &v58))
    {
      *a8 = 0;
      if (a3) {
        return -0.0;
      }
      else {
        return 0.0;
      }
    }
  }

  char v57 = a6;
  int v20 = 0;
  int64_t v21 = 0LL;
  char v22 = 0;
  if (a7) {
    char v23 = 53;
  }
  else {
    char v23 = 24;
  }
  while (1)
  {
    unsigned int v24 = v19 - 48;
    if ((v19 - 97) <= 5)
    {
      unsigned int v24 = v19 - 87;
      goto LABEL_15;
    }

    unsigned int v24 = v19 - 55;
LABEL_15:
    if ((v22 & 1) != 0) {
      v20 -= 4;
    }
    int64_t v21 = 16 * v21 + v24;
    uint64_t v25 = v21 >> v23;
    if ((v21 >> v23))
    {
      int v55 = a3;
      int v26 = 1;
      if ((int)v25 >= 2)
      {
        do
        {
          ++v26;
          BOOL v27 = v25 > 3;
          LODWORD(v25) = v25 >> 1;
        }

        while (v27);
      }

      int v56 = a2;
      int v28 = v26 + v20;
      if ((sub_1808D843C(a1, a4, 16, &v58) & 1) != 0)
      {
        char v29 = 1;
LABEL_44:
        if ((a5 & 1) == 0 && (v57 & 1) == 0)
        {
          for (int i = *a1; i != v56; *a1 = i)
          {
            unsigned int v35 = *i;
            if (v35 >= 0x80)
            {
              uint64_t v37 = 0LL;
              while ((unsigned __int16)word_180A378C2[v37] != v35)
              {
                if (++v37 == 20) {
                  return a9;
                }
              }
            }

            else
            {
              uint64_t v36 = 0LL;
              while (byte_180A378BC[v36] != v35)
              {
                if (++v36 == 6) {
                  return a9;
                }
              }
            }

            ++i;
          }
        }

        int v38 = v21 & ~(-1 << v26);
        int v39 = 1 << (v26 - 1);
        uint64_t v40 = (v21 >> v26) + ((v21 >> v26) & 1u | ((v29 & 1) == 0));
        if (v38 != v39) {
          uint64_t v40 = v21 >> v26;
        }
        if (v38 > v39) {
          uint64_t v41 = (v21 >> v26) + 1;
        }
        else {
          uint64_t v41 = v40;
        }
        int v20 = v28 + (((unint64_t)v41 >> v23) & 1);
        int64_t v21 = v41 >> (((unint64_t)v41 >> v23) & 1);
        a3 = v55;
        goto LABEL_63;
      }

      char v29 = 1;
      while (2)
      {
        uint64_t v30 = *a1;
        if (a5)
        {
          unsigned int v31 = *v30;
          if (v31 == 46)
          {
            sub_1808D843C(a1, a4, 16, &v58);
            uint64_t v30 = *a1;
            char v22 = 1;
            goto LABEL_31;
          }
        }

        else
        {
LABEL_31:
          unsigned int v31 = *v30;
        }

        if ((v31 - 48 >= 0xA || v31 >= 0x40)
          && (v31 - 65 > 0x25 || ((1LL << (v31 - 65)) & 0x3F0000003FLL) == 0))
        {
          goto LABEL_44;
        }

        v29 &= v31 == 48;
        if ((v22 & 1) == 0) {
          v28 += 4;
        }
        continue;
      }
    }

    if ((sub_1808D843C(a1, a4, 16, &v58) & 1) != 0) {
      goto LABEL_63;
    }
LABEL_19:
    char v18 = *a1;
    int v19 = **a1;
  }

  if (!a5) {
    goto LABEL_97;
  }
  if (v19 == 46)
  {
    sub_1808D843C(a1, a4, 16, &v58);
    char v22 = 1;
    goto LABEL_19;
  }

  if (v19 != 80 && v19 != 112)
  {
LABEL_97:
    if (v18 != a2 && (v57 & 1) == 0)
    {
      do
      {
        unsigned int v52 = *v18;
        if (v52 >= 0x80)
        {
          uint64_t v54 = 0LL;
          while ((unsigned __int16)word_180A378C2[v54] != v52)
          {
            if (++v54 == 20) {
              return a9;
            }
          }
        }

        else
        {
          uint64_t v53 = 0LL;
          while (byte_180A378BC[v53] != v52)
          {
            if (++v53 == 6) {
              return a9;
            }
          }
        }

        *a1 = ++v18;
      }

      while (v18 != a2);
    }

double sub_1808D8BD8(uint64_t a1, int a2, uint64_t a3)
{
  int v3 = a3;
  double v14 = 0.0;
  BOOL v6 = sub_1808D8CAC(a1, a2, a3, &v14);
  double v7 = v14;
  if (!v6)
  {
    uint64_t v8 = 2 * (*(void *)&v14 & 0xFFFFFFFFFFFFFLL);
    if ((*(void *)&v14 & 0x7FF0000000000000LL) != 0)
    {
      uint64_t v8 = (2 * (*(void *)&v14 & 0xFFFFFFFFFFFFFLL)) | 0x20000000000000LL;
      int v9 = ((*(void *)&v14 >> 52) & 0x7FF) - 1076;
    }

    else
    {
      int v9 = -1075;
    }

    int v10 = sub_1808D911C(a1, a2, v3, v8 | 1, v9);
    if ((v10 & 0x80000000) == 0 && (v10 || (LOBYTE(v7) & 1) != 0))
    {
      *(void *)&double v11 = *(void *)&v7 + 1LL;
      *(void *)&double v12 = *(void *)&v7 - 1LL;
      if ((*(void *)&v7 & 0x7FFFFFFFFFFFFFFFLL) == 0) {
        double v12 = 0.0;
      }
      if (v7 < 0.0) {
        double v11 = v12;
      }
      if (v7 == INFINITY) {
        return INFINITY;
      }
      else {
        return v11;
      }
    }
  }

  return v7;
}

BOOL sub_1808D8CAC(uint64_t a1, int a2, uint64_t a3, double *a4)
{
  if (!a2) {
    goto LABEL_42;
  }
  uint64_t v6 = a3;
  int v7 = a2 + a3;
  if (a2 + (int)a3 >= 310)
  {
    *a4 = INFINITY;
    return 1LL;
  }

  if (v7 <= -324) {
    goto LABEL_42;
  }
  if (a2 >= 16) {
    goto LABEL_28;
  }
  if (a3 >= 0xFFFFFFEA)
  {
    if (a2 < 1)
    {
      double v10 = 0.0;
    }

    else
    {
      uint64_t v8 = 0LL;
      unint64_t v9 = 0LL;
      do
      {
        unint64_t v9 = *(char *)(a1 + v8) + 10 * v9 - 48;
        if (v8 + 1 >= a2) {
          break;
        }
        ++v8;
      }

      while (v9 < 0x1999999999999999LL);
      double v10 = (double)v9;
    }

    double v18 = v10 / dbl_180A37900[-(int)a3];
    goto LABEL_81;
  }

  if (a3 <= 0x16)
  {
    if (a2 < 1)
    {
      double v13 = 0.0;
    }

    else
    {
      uint64_t v11 = 0LL;
      unint64_t v12 = 0LL;
      do
      {
        unint64_t v12 = *(char *)(a1 + v11) + 10 * v12 - 48;
        if (v11 + 1 >= a2) {
          break;
        }
        ++v11;
      }

      while (v12 < 0x1999999999999999LL);
      double v13 = (double)v12;
    }

    double v46 = dbl_180A37900[a3];
LABEL_80:
    double v18 = v13 * v46;
LABEL_81:
    *a4 = v18;
    return 1LL;
  }

  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v14 = 15LL - a2;
    if ((int)a3 - (int)v14 <= 22)
    {
      if (a2 < 1)
      {
        double v17 = 0.0;
      }

      else
      {
        uint64_t v15 = 0LL;
        unint64_t v16 = 0LL;
        do
        {
          unint64_t v16 = *(char *)(a1 + v15) + 10 * v16 - 48;
          if (v15 + 1 >= a2) {
            break;
          }
          ++v15;
        }

        while (v16 < 0x1999999999999999LL);
        double v17 = (double)v16;
      }

      double v13 = v17 * dbl_180A37900[v14];
      double v46 = dbl_180A37900[(int)a3 - (int)v14];
      goto LABEL_80;
    }
  }

  if (a2 < 1)
  {
    LODWORD(v19) = 0;
    unint64_t v20 = 0LL;
  }

  else
  {
LABEL_28:
    uint64_t v19 = 0LL;
    unint64_t v20 = 0LL;
    do
    {
      uint64_t v21 = *(char *)(a1 + v19++);
      unint64_t v20 = v21 + 10 * v20 - 48;
    }

    while (v19 < a2 && v20 < 0x1999999999999999LL);
  }

  if ((_DWORD)v19 == a2)
  {
    uint64_t v22 = 0LL;
  }

  else
  {
    uint64_t v6 = (v7 - v19);
    uint64_t v22 = 4LL;
  }

  int v23 = 0;
  if (!(v20 >> 54))
  {
    unint64_t v24 = v20;
    do
    {
      unint64_t v20 = v24 << 10;
      v23 -= 10;
      unint64_t v25 = v24 >> 44;
      v24 <<= 10;
    }

    while (!v25);
  }

  for (; (v20 & 0x8000000000000000LL) == 0; --v23)
    v20 *= 2LL;
  if ((int)v6 <= -349)
  {
LABEL_42:
    *a4 = 0.0;
    return 1LL;
  }

  uint64_t v27 = v22 << -(char)v23;
  uint64_t v48 = 0LL;
  uint64_t v49 = 0LL;
  int v47 = 0;
  sub_1808D5BD4(v6, (uint64_t)&v48, &v47);
  int v28 = v6 - v47;
  if ((_DWORD)v6 != v47)
  {
    int v29 = v28 - 1;
    v23 += dword_180A379B8[v29];
    unint64_t v20 = qword_180A379D8[v29] * HIDWORD(v20)
    if (19 - a2 < v28) {
      v27 += 4LL;
    }
  }

  unint64_t v30 = ((v48 * (unint64_t)HIDWORD(v20)) >> 32)
      + HIDWORD(v48) * (unint64_t)HIDWORD(v20)
      + ((HIDWORD(v48) * (unint64_t)v20) >> 32)
      + ((((v48 * (unint64_t)v20) >> 32)
        + (v48 * HIDWORD(v20))
  if (v27) {
    uint64_t v31 = 9LL;
  }
  else {
    uint64_t v31 = 8LL;
  }
  if (v30 >> 54)
  {
    int v32 = v23 + v49 + 64;
    unint64_t v33 = ((v48 * (unint64_t)HIDWORD(v20)) >> 32)
        + HIDWORD(v48) * (unint64_t)HIDWORD(v20)
        + ((HIDWORD(v48) * (unint64_t)v20) >> 32)
        + ((((v48 * (unint64_t)v20) >> 32)
          + (v48 * HIDWORD(v20))
  }

  else
  {
    int v32 = v23 + v49 + 64;
    do
    {
      unint64_t v33 = v30 << 10;
      v32 -= 10;
      unint64_t v34 = v30 >> 44;
      v30 <<= 10;
    }

    while (!v34);
  }

  for (uint64_t i = v31 + v27; (v33 & 0x8000000000000000LL) == 0; --v32)
    v33 *= 2LL;
  unint64_t v36 = i << (v23 + v49 + 64 - v32);
  int v37 = v32 + 1138;
  if (v32 < -1137) {
    int v37 = 0;
  }
  if (v32 > -1086) {
    int v37 = 53;
  }
  uint64_t v38 = (v36 >> (4 - v37)) + 9;
  BOOL v39 = v37 <= 3;
  if (v37 > 3)
  {
    int v40 = 64 - v37;
  }

  else
  {
    v32 += 4 - v37;
    v33 >>= 4 - v37;
    int v40 = 60;
  }

  if (v39) {
    uint64_t v41 = v38;
  }
  else {
    uint64_t v41 = v36;
  }
  uint64_t v42 = v33 & ~(-1LL << v40);
  uint64_t v43 = 8LL << (v40 - 1);
  else {
    unint64_t v44 = (v33 >> v40) + 1;
  }
  double v45 = COERCE_DOUBLE(sub_1808D81FC(v44, v40 + v32));
  *a4 = v45;
  BOOL result = 1LL;
  return result;
}

uint64_t sub_1808D911C(uint64_t a1, int a2, int a3, unint64_t a4, int a5)
{
  if (a3 < 0)
  {
    int v11 = -a3;
    double v10 = (unsigned __int16 *)v15;
  }

  else
  {
    double v10 = v16;
    int v11 = a3;
  }

  sub_1808D4DE4(v10, v11);
  if (a5 < 1)
  {
    int v13 = -a5;
    unint64_t v12 = v16;
  }

  else
  {
    unint64_t v12 = (unsigned __int16 *)v15;
    int v13 = a5;
  }

  sub_1808D51D8(v12, v13);
  return sub_1808D5994((uint64_t)v16, v15);
}

uint64_t sub_1808D91DC(uint64_t a1, int a2, uint64_t a3)
{
  int v3 = a3;
  double v22 = 0.0;
  uint64_t result = sub_1808D8CAC(a1, a2, a3, &v22);
  if (v22 >= 3.40282347e38)
  {
    if (v22 >= 3.40282357e38) {
      int v8 = 2139095040;
    }
    else {
      int v8 = 2139095039;
    }
    float v7 = *(float *)&v8;
  }

  else
  {
    float v7 = v22;
  }

  if (v22 == v7) {
    return result;
  }
  if (v22 == INFINITY)
  {
    uint64_t v9 = -1LL;
    double v10 = INFINITY;
    goto LABEL_19;
  }

  if ((*(void *)&v22 & 0x8000000000000000LL) == 0)
  {
    *(void *)&double v10 = *(void *)&v22 + 1LL;
    if (v22 != 0.0)
    {
      uint64_t v9 = -1LL;
      goto LABEL_19;
    }

    double v11 = -0.0;
LABEL_20:
    float v12 = v11;
    goto LABEL_25;
  }

  if ((*(void *)&v22 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    *(void *)&double v10 = *(void *)&v22 - 1LL;
    if (v22 == -INFINITY)
    {
      double v11 = -INFINITY;
      goto LABEL_20;
    }
  }

  else
  {
    double v10 = 0.0;
  }

  uint64_t v9 = 1LL;
LABEL_19:
  *(void *)&double v11 = v9 + *(void *)&v22;
  if (COERCE_DOUBLE(v9 + *(void *)&v22) < 3.40282347e38) {
    goto LABEL_20;
  }
  if (v11 >= 3.40282357e38) {
    int v13 = 2139095040;
  }
  else {
    int v13 = 2139095039;
  }
  float v12 = *(float *)&v13;
LABEL_25:
  if (v10 < 3.40282347e38)
  {
    float v14 = v10;
    if ((result & 1) != 0) {
      goto LABEL_44;
    }
LABEL_32:
    if (v10 == INFINITY) {
      goto LABEL_33;
    }
    if ((*(void *)&v10 & 0x8000000000000000LL) != 0)
    {
      if ((*(void *)&v10 & 0x7FFFFFFFFFFFFFFFLL) == 0)
      {
        double v18 = 0.0;
        goto LABEL_43;
      }

      uint64_t v17 = -1LL;
    }

    else
    {
      uint64_t v17 = 1LL;
    }

    *(void *)&double v18 = v17 + *(void *)&v10;
    if (v18 >= 3.40282347e38)
    {
      if (v18 < 3.40282357e38)
      {
        int v16 = 2139095039;
        goto LABEL_34;
      }

void icu::SharedDateFormatSymbols::~SharedDateFormatSymbols(icu::SharedDateFormatSymbols *this)
{
  *(void *)this = off_189722BF8;
  icu::DateFormatSymbols::~DateFormatSymbols((icu::SharedDateFormatSymbols *)((char *)this + 24));
  icu::SharedObject::~SharedObject(this);
}

{
  *(void *)this = off_189722BF8;
  icu::DateFormatSymbols::~DateFormatSymbols((icu::SharedDateFormatSymbols *)((char *)this + 24));
  icu::SharedObject::~SharedObject(this);
}

{
  void *v2;
  *(void *)this = off_189722BF8;
  icu::DateFormatSymbols::~DateFormatSymbols((icu::SharedDateFormatSymbols *)((char *)this + 24));
  icu::SharedObject::~SharedObject(this);
  icu::UMemory::operator delete(v2);
}

uint64_t icu::LocaleCacheKey<icu::SharedDateFormatSymbols>::createObject( uint64_t a1, int a2, UErrorCode *a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (icu::UnicodeString **)(a1 + 16);
  memset(v12, 0, sizeof(v12));
  icu::Calendar::getCalendarTypeFromLocale((icu::Calendar *)(a1 + 16), (const icu::Locale *)v12, (char *)0x100, a3, a5);
  int v8 = (uint64_t *)*(unsigned int *)a3;
  if ((int)v8 <= 0)
  {
    double v11 = icu::UMemory::operator new(v8, (icu::UMemory *)0x510, v7);
    uint64_t v9 = (uint64_t)v11;
    if (!v11)
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
      return v9;
    }

    sub_1808DFB74((uint64_t)v11, v6, (const char *)v12, a3);
    if (*(int *)a3 < 1)
    {
      icu::SharedObject::addRef(v9);
      return v9;
    }

    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }

  return 0LL;
}

void *icu::DateFormatSymbols::getStaticClassID(icu::DateFormatSymbols *this)
{
  return &unk_18C535308;
}

void *icu::DateFormatSymbols::getDynamicClassID(icu::DateFormatSymbols *this)
{
  return &unk_18C535308;
}

uint64_t *icu::DateFormatSymbols::createForLocale( icu::DateFormatSymbols *this, UErrorCode *a2, UErrorCode *a3)
{
  uint64_t v9 = 0LL;
  sub_1808D96A0((uint64_t)this, (UErrorCode *)&v9, a2);
  uint64_t v5 = 0LL;
  uint64_t v6 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v6 <= 0)
  {
    uint64_t v5 = icu::UMemory::operator new(v6, (icu::UMemory *)0x4F8, v4);
    if (v5)
    {
      unint64_t v7 = (icu::SharedObject *)((char *)v9 + 24);
      *uint64_t v5 = (uint64_t)off_189722C20;
      v5[39] = (uint64_t)off_18971B688;
      *((_WORD *)v5 + 160) = 2;
      icu::Locale::Locale((icu::Locale *)(v5 + 68));
      v5[96] = (uint64_t)off_18971B688;
      *((_WORD *)v5 + 388) = 2;
      icu::DateFormatSymbols::copyData((icu::DateFormatSymbols *)v5, v7);
      icu::SharedObject::removeRef(v9);
    }

    else
    {
      icu::SharedObject::removeRef(v9);
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return v5;
}

void sub_1808D96A0(uint64_t a1, UErrorCode *a2, UErrorCode *this)
{
  v11[28] = *MEMORY[0x1895F89C0];
  uint64_t Instance = icu::UnifiedCache::getInstance(this, a2);
  if (*(int *)this <= 0)
  {
    unint64_t v7 = (icu::SharedObject **)Instance;
    int v9 = 0;
    char v10 = 0;
    int v8 = off_189722DF0;
    icu::Locale::Locale((icu::Locale *)v11, a1);
    sub_18089E200(v7, (const icu::CacheKeyBase *)&v8, 0LL, (icu::SharedObject **)a2, this);
    int v8 = off_189722DF0;
    icu::Locale::~Locale((icu::Locale *)v11);
    icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)&v8);
  }

icu::DateFormatSymbols *icu::DateFormatSymbols::DateFormatSymbols( icu::DateFormatSymbols *this, const icu::DateFormatSymbols *a2)
{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  icu::DateFormatSymbols::copyData(this, a2);
  return this;
}

{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  icu::DateFormatSymbols::copyData(this, a2);
  return this;
}

icu::DateFormatSymbols *icu::DateFormatSymbols::DateFormatSymbols( icu::DateFormatSymbols *this, icu::UnicodeString **a2, UErrorCode *a3)
{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  icu::DateFormatSymbols::initializeData(this, a2, 0LL, a3, 0);
  return this;
}

{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  icu::DateFormatSymbols::initializeData(this, a2, 0LL, a3, 0);
  return this;
}

void icu::DateFormatSymbols::initializeData( icu::DateFormatSymbols *this, icu::UnicodeString **a2, const char *a3, UErrorCode *a4, int a5)
{
  uint64_t v253 = *MEMORY[0x1895F89C0];
  int v219 = 0;
  *((void *)this + 1) = 0LL;
  uint64_t v6 = (char *)this + 8;
  *((_DWORD *)this + 4) = 0;
  v197 = (unsigned int *)((char *)this + 16);
  *((void *)this + 3) = 0LL;
  v186 = (uint64_t *)((char *)this + 24);
  *((_DWORD *)this + 8) = 0;
  v185 = (icu::UnicodeString **)((char *)this + 32);
  *((void *)this + 5) = 0LL;
  v188 = (uint64_t *)((char *)this + 40);
  *((_DWORD *)this + 12) = 0;
  v187 = (icu::UnicodeString **)((char *)this + 48);
  *((void *)this + 7) = 0LL;
  v199 = (uint64_t *)((char *)this + 56);
  *((_DWORD *)this + 16) = 0;
  v198 = (unsigned int *)((char *)this + 64);
  *((void *)this + 9) = 0LL;
  v204 = (uint64_t *)((char *)this + 72);
  *((_DWORD *)this + 20) = 0;
  v205 = (unsigned int *)((char *)this + 80);
  *((void *)this + 11) = 0LL;
  v189 = (uint64_t *)((char *)this + 88);
  *((_DWORD *)this + 24) = 0;
  v206 = (icu::UnicodeString **)((char *)this + 96);
  *((void *)this + 13) = 0LL;
  v191 = (uint64_t *)((char *)this + 104);
  *((_DWORD *)this + 28) = 0;
  v190 = (icu::UnicodeString **)((char *)this + 112);
  *((void *)this + 15) = 0LL;
  v193 = (uint64_t *)((char *)this + 120);
  *((_DWORD *)this + 32) = 0;
  v192 = (icu::UnicodeString **)((char *)this + 128);
  *((void *)this + 17) = 0LL;
  v195 = (uint64_t *)((char *)this + 136);
  *((_DWORD *)this + 36) = 0;
  v194 = (unsigned int *)((char *)this + 144);
  *((void *)this + 19) = 0LL;
  v201 = (uint64_t *)((char *)this + 152);
  *((_DWORD *)this + 40) = 0;
  v200 = (unsigned int *)((char *)this + 160);
  *((void *)this + 21) = 0LL;
  v207 = (uint64_t *)((char *)this + 168);
  *((_DWORD *)this + 44) = 0;
  v202 = (unsigned int *)((char *)this + 176);
  *((void *)this + 23) = 0LL;
  v196 = (uint64_t *)((char *)this + 184);
  *((_DWORD *)this + 48) = 0;
  v203 = (icu::UnicodeString **)((char *)this + 192);
  *((void *)this + 25) = 0LL;
  unint64_t v7 = (uint64_t *)((char *)this + 200);
  *((_DWORD *)this + 52) = 0;
  int v8 = (icu::UnicodeString **)((char *)this + 208);
  *((void *)this + 27) = 0LL;
  int v9 = (uint64_t *)((char *)this + 216);
  *((_DWORD *)this + 56) = 0;
  char v10 = (icu::UnicodeString **)((char *)this + 224);
  *((void *)this + 29) = 0LL;
  double v11 = (uint64_t *)((char *)this + 232);
  *((_DWORD *)this + 60) = 0;
  float v12 = (icu::UnicodeString **)((char *)this + 240);
  *((void *)this + 31) = 0LL;
  uint64_t v13 = (uint64_t *)((char *)this + 248);
  *((_DWORD *)this + 64) = 0;
  float v14 = (icu::UnicodeString **)((char *)this + 256);
  *((void *)this + 33) = 0LL;
  *((_DWORD *)this + 68) = 0;
  *((void *)this + 35) = 0LL;
  *((_DWORD *)this + 72) = 0;
  *((void *)this + 37) = 0LL;
  *((_DWORD *)this + 76) = 0;
  v181 = (icu::DateFormatSymbols *)((char *)this + 312);
  icu::UnicodeString::setToBogus((icu::DateFormatSymbols *)((char *)this + 312));
  *((void *)v6 + 46) = 0LL;
  *((_DWORD *)v6 + 94) = 0;
  *((void *)v6 + 48) = 0LL;
  *((_DWORD *)v6 + 98) = 0;
  *((void *)v6 + 50) = 0LL;
  *((_DWORD *)v6 + 102) = 0;
  *((void *)v6 + 52) = 0LL;
  *((_DWORD *)v6 + 106) = 0;
  *((void *)v6 + 54) = 0LL;
  *((_DWORD *)v6 + 110) = 0;
  *((void *)v6 + 56) = 0LL;
  *((_DWORD *)v6 + 114) = 0;
  *((void *)v6 + 58) = 0LL;
  *((_DWORD *)v6 + 118) = 0;
  *((void *)v6 + 60) = 0LL;
  *((_DWORD *)v6 + 122) = 0;
  *((void *)v6 + 62) = 0LL;
  *((_DWORD *)v6 + 126) = 0;
  *((void *)v6 + 107) = 0LL;
  *((_DWORD *)v6 + 216) = 0;
  *((void *)v6 + 109) = 0LL;
  *((_DWORD *)v6 + 220) = 0;
  *((void *)v6 + 111) = 0LL;
  *((_DWORD *)v6 + 224) = 0;
  *((void *)v6 + 113) = 0LL;
  *((_DWORD *)v6 + 228) = 0;
  *((void *)v6 + 115) = 0LL;
  *((_DWORD *)v6 + 232) = 0;
  *((void *)v6 + 117) = 0LL;
  *((_DWORD *)v6 + 236) = 0;
  *((_DWORD *)v6 + 212) = 0;
  *((void *)v6 + 105) = 0LL;
  *(_OWORD *)(v6 + 824) = 0u;
  *((void *)v6 + 66) = 0LL;
  *((_OWORD *)v6 + 32) = 0u;
  icu::Locale::operator=((icu::Locale *)(v6 + 536), (uint64_t)a2);
  if (*(int *)a4 <= 0)
  {
    v177 = a2;
    v179 = (uint64_t *)v6;
    v169 = v8;
    v170 = v10;
    v171 = v11;
    v172 = v7;
    bzero(v235, 0x248uLL);
    v233 = off_189722D58;
    v234 = 0LL;
    int v15 = a4;
    uhash_init(v235, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0LL, (int *)a4);
    v175 = v14;
    v176 = v13;
    v173 = v9;
    v174 = v12;
    if (*(int *)a4 < 1)
    {
      v234 = v235;
      uhash_setKeyDeleter((uint64_t)v235, (uint64_t)uprv_deleteUObject);
      int v17 = *a4;
      v236 = 0LL;
      int v16 = (icu::Locale *)a2;
      if (v17 <= 0
        && (uhash_init(v237, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0LL, (int *)a4),
            *(int *)a4 < 1))
      {
        v236 = v237;
        uhash_setKeyDeleter((uint64_t)v237, (uint64_t)uprv_deleteUObject);
        int v83 = *a4;
        v238 = 0LL;
        if (v83 <= 0)
        {
          uhash_init(v239, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0LL, (int *)a4);
          if (*(int *)a4 <= 0)
          {
            v238 = v239;
            uhash_setKeyDeleter((uint64_t)v239, (uint64_t)uprv_deleteUObject);
          }
        }
      }

      else
      {
        v238 = 0LL;
      }
    }

    else
    {
      v236 = 0LL;
      v238 = 0LL;
      int v16 = (icu::Locale *)a2;
    }

    int v240 = 0;
    v241 = &v244;
    int v242 = 8;
    char v243 = 0;
    icu::UVector::UVector((uint64_t)v245, (uint64_t)uprv_deleteUObject, (uint64_t)uhash_compareUnicodeString, (int *)a4);
    v246 = (UChar *)off_18971B688;
    __int16 v247 = 2;
    v248 = (UChar *)off_18971B688;
    __int16 v249 = 2;
    uint64_t v250 = 0LL;
    v251 = off_18971B688;
    __int16 v252 = 2;
    BaseName = (char *)icu::Locale::getBaseName(v16);
    uint64_t v19 = ures_open(0LL, BaseName, (int *)a4);
    uint64_t v20 = ures_getByKey(v19, "calendar", 0LL, (int *)a4);
    uint64_t v21 = v20;
    memset(v232, 0, sizeof(v232));
    double v22 = "gregorian";
    uint64_t v156 = v19;
    if (a3 && *a3) {
      double v22 = a3;
    }
    icu::UnicodeString::UnicodeString(v232, v22, 0xFFFFFFFFLL, 0LL);
    if (((uint64_t)v232[1] & 1) == 0)
    {
      while (1)
      {
        __int128 v229 = 0u;
        __int128 v230 = 0u;
        __int128 v228 = 0u;
        v227 = (char *)&v228 + 5;
        LODWORD(v228) = 40;
        uint64_t v231 = 0LL;
        icu::CharString::appendInvariantChars((icu::CharString *)&v227, (const icu::UnicodeString *)v232, v15);
        UErrorCode v24 = *v15;
        if (*(int *)v15 <= 0)
        {
          uint64_t v27 = v227;
          uint64_t v28 = ures_getByKeyWithFallback(v21, v227, 0LL, v15);
          uint64_t v29 = v28;
          if (*v15 == U_MISSING_RESOURCE_ERROR)
          {
            ures_close(v28);
            if (!strcmp(v27, "gregorian"))
            {
              int v25 = 1;
              int v15 = a4;
            }

            else
            {
              v218 = (const UChar *)aGregorian_2;
              icu::UnicodeString::setTo((icu::UnicodeString *)v232, 0, &v218, 9);
              if (v250) {
                (*(void (**)(uint64_t))(*(void *)v250 + 8LL))(v250);
              }
              uint64_t v250 = 0LL;
              int v15 = a4;
              *a4 = v24;
              int v25 = 2;
            }
          }

          else
          {
            icu::UnicodeString::operator=(&v246, v232);
            icu::UnicodeString::setToBogus((icu::UnicodeString *)&v248);
            icu::UVector::removeAllElements((uint64_t)v245);
            ures_getAllItemsWithFallback(v29, "", (uint64_t)&v233, (int *)v15);
            ures_close(v29);
            if (*(int *)v15 > 0 || !strcmp(v27, "gregorian"))
            {
              int v25 = 3;
            }

            else
            {
              icu::UnicodeString::operator=(v232, &v248);
              if (((uint64_t)v232[1] & 1) != 0)
              {
                v217 = (const UChar *)aGregorian_2;
                icu::UnicodeString::setTo((icu::UnicodeString *)v232, 0, &v217, 9);
                if (v250) {
                  (*(void (**)(uint64_t))(*(void *)v250 + 8LL))(v250);
                }
                int v25 = 0;
                uint64_t v250 = 0LL;
              }

              else
              {
                int v25 = 0;
              }
            }
          }
        }

        else
        {
          int v25 = 1;
        }

        int v26 = (void *)BYTE4(v228);
        if (BYTE4(v228)) {
          uprv_free(v227);
        }
        if (v25 && v25 != 2) {
          break;
        }
      }

      if (v25 != 3)
      {
LABEL_180:
        icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v232);
LABEL_181:
        sub_1808DFAD8((uint64_t *)&v233);
        return;
      }
    }

icu::DateFormatSymbols *icu::DateFormatSymbols::DateFormatSymbols( icu::DateFormatSymbols *this, UErrorCode *a2)
{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  unint64_t v4 = (icu::Locale *)icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  Default = icu::Locale::getDefault(v4);
  icu::DateFormatSymbols::initializeData(this, (icu::UnicodeString **)Default, 0LL, a2, 1);
  return this;
}

icu::DateFormatSymbols *icu::DateFormatSymbols::DateFormatSymbols( icu::DateFormatSymbols *this, icu::UnicodeString **a2, const char *a3, UErrorCode *a4)
{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  icu::DateFormatSymbols::initializeData(this, a2, a3, a4, 0);
  return this;
}

{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  icu::DateFormatSymbols::initializeData(this, a2, a3, a4, 0);
  return this;
}

icu::DateFormatSymbols *icu::DateFormatSymbols::DateFormatSymbols( icu::DateFormatSymbols *this, const char *a2, UErrorCode *a3)
{
  *(void *)this = off_189722C20;
  *((void *)this + 39) = off_18971B688;
  *((_WORD *)this + 160) = 2;
  uint64_t v6 = (icu::Locale *)icu::Locale::Locale((icu::DateFormatSymbols *)((char *)this + 544));
  *((void *)this + 96) = off_18971B688;
  *((_WORD *)this + 388) = 2;
  Default = icu::Locale::getDefault(v6);
  icu::DateFormatSymbols::initializeData(this, (icu::UnicodeString **)Default, a2, a3, 1);
  return this;
}

__n128 icu::DateFormatSymbols::copyData(icu::DateFormatSymbols *this, const icu::DateFormatSymbols *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  int v12 = 0;
  v11[0] = (char *)this + 956;
  v11[1] = (char *)this + 1113;
  unint64_t v4 = (char *)a2 + 956;
  uint64_t v5 = (char *)a2 + 1113;
  v14[0] = (char *)a2 + 956;
  v14[1] = (char *)a2 + 1113;
  icu::LocaleBased::getLocale(v14, 1, &v12, (icu::Locale *)v15);
  v13[0] = v4;
  v13[1] = v5;
  icu::LocaleBased::getLocale(v13, 0, &v12, (icu::Locale *)v14);
  icu::LocaleBased::setLocaleIDs(v11, (uint64_t)v15, (uint64_t)v14);
  icu::Locale::~Locale((icu::Locale *)v14);
  icu::Locale::~Locale((icu::Locale *)v15);
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 8),  (icu::UnicodeString **)this + 2,  *((int **)a2 + 1),  (const icu::UnicodeString *)*((unsigned int *)a2 + 4));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 24),  (icu::UnicodeString **)this + 4,  *((int **)a2 + 3),  (const icu::UnicodeString *)*((unsigned int *)a2 + 8));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 40),  (icu::UnicodeString **)this + 6,  *((int **)a2 + 5),  (const icu::UnicodeString *)*((unsigned int *)a2 + 12));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 56),  (icu::UnicodeString **)this + 8,  *((int **)a2 + 7),  (const icu::UnicodeString *)*((unsigned int *)a2 + 16));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 72),  (icu::UnicodeString **)this + 10,  *((int **)a2 + 9),  (const icu::UnicodeString *)*((unsigned int *)a2 + 20));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 88),  (icu::UnicodeString **)this + 12,  *((int **)a2 + 11),  (const icu::UnicodeString *)*((unsigned int *)a2 + 24));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 104),  (icu::UnicodeString **)this + 14,  *((int **)a2 + 13),  (const icu::UnicodeString *)*((unsigned int *)a2 + 28));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 120),  (icu::UnicodeString **)this + 16,  *((int **)a2 + 15),  (const icu::UnicodeString *)*((unsigned int *)a2 + 32));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 136),  (icu::UnicodeString **)this + 18,  *((int **)a2 + 17),  (const icu::UnicodeString *)*((unsigned int *)a2 + 36));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 152),  (icu::UnicodeString **)this + 20,  *((int **)a2 + 19),  (const icu::UnicodeString *)*((unsigned int *)a2 + 40));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 168),  (icu::UnicodeString **)this + 22,  *((int **)a2 + 21),  (const icu::UnicodeString *)*((unsigned int *)a2 + 44));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 184),  (icu::UnicodeString **)this + 24,  *((int **)a2 + 23),  (const icu::UnicodeString *)*((unsigned int *)a2 + 48));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 200),  (icu::UnicodeString **)this + 26,  *((int **)a2 + 25),  (const icu::UnicodeString *)*((unsigned int *)a2 + 52));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 216),  (icu::UnicodeString **)this + 28,  *((int **)a2 + 27),  (const icu::UnicodeString *)*((unsigned int *)a2 + 56));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 232),  (icu::UnicodeString **)this + 30,  *((int **)a2 + 29),  (const icu::UnicodeString *)*((unsigned int *)a2 + 60));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 248),  (icu::UnicodeString **)this + 32,  *((int **)a2 + 31),  (const icu::UnicodeString *)*((unsigned int *)a2 + 64));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 264),  (icu::UnicodeString **)this + 34,  *((int **)a2 + 33),  (const icu::UnicodeString *)*((unsigned int *)a2 + 68));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 280),  (icu::UnicodeString **)this + 36,  *((int **)a2 + 35),  (const icu::UnicodeString *)*((unsigned int *)a2 + 72));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 296),  (icu::UnicodeString **)this + 38,  *((int **)a2 + 37),  (const icu::UnicodeString *)*((unsigned int *)a2 + 76));
  icu::UnicodeString::fastCopyFrom((UChar **)this + 39, (UChar **)a2 + 39);
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 376),  (icu::UnicodeString **)this + 48,  *((int **)a2 + 47),  (const icu::UnicodeString *)*((unsigned int *)a2 + 96));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 392),  (icu::UnicodeString **)this + 50,  *((int **)a2 + 49),  (const icu::UnicodeString *)*((unsigned int *)a2 + 100));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 408),  (icu::UnicodeString **)this + 52,  *((int **)a2 + 51),  (const icu::UnicodeString *)*((unsigned int *)a2 + 104));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 424),  (icu::UnicodeString **)this + 54,  *((int **)a2 + 53),  (const icu::UnicodeString *)*((unsigned int *)a2 + 108));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 440),  (icu::UnicodeString **)this + 56,  *((int **)a2 + 55),  (const icu::UnicodeString *)*((unsigned int *)a2 + 112));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 456),  (icu::UnicodeString **)this + 58,  *((int **)a2 + 57),  (const icu::UnicodeString *)*((unsigned int *)a2 + 116));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 880),  (icu::UnicodeString **)this + 111,  *((int **)a2 + 110),  (const icu::UnicodeString *)*((unsigned int *)a2 + 222));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 896),  (icu::UnicodeString **)this + 113,  *((int **)a2 + 112),  (const icu::UnicodeString *)*((unsigned int *)a2 + 226));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 864),  (icu::UnicodeString **)this + 109,  *((int **)a2 + 108),  (const icu::UnicodeString *)*((unsigned int *)a2 + 218));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 928),  (icu::UnicodeString **)this + 117,  *((int **)a2 + 116),  (const icu::UnicodeString *)*((unsigned int *)a2 + 234));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 944),  (icu::UnicodeString **)this + 119,  *((int **)a2 + 118),  (const icu::UnicodeString *)*((unsigned int *)a2 + 238));
  icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 912),  (icu::UnicodeString **)this + 115,  *((int **)a2 + 114),  (const icu::UnicodeString *)*((unsigned int *)a2 + 230));
  uint64_t v6 = (int *)*((void *)a2 + 59);
  if (v6)
  {
    icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 472),  (icu::UnicodeString **)this + 60,  v6,  (const icu::UnicodeString *)*((unsigned int *)a2 + 120));
  }

  else
  {
    *((void *)this + 59) = 0LL;
    *((_DWORD *)this + 120) = 0;
  }

  unint64_t v7 = (int *)*((void *)a2 + 61);
  if (v7)
  {
    icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 488),  (icu::UnicodeString **)this + 62,  v7,  (const icu::UnicodeString *)*((unsigned int *)a2 + 124));
  }

  else
  {
    *((void *)this + 61) = 0LL;
    *((_DWORD *)this + 124) = 0;
  }

  int v8 = (int *)*((void *)a2 + 63);
  if (v8)
  {
    icu::DateFormatSymbols::assignArray( (icu::DateFormatSymbols *)((char *)this + 504),  (icu::UnicodeString **)this + 64,  v8,  (const icu::UnicodeString *)*((unsigned int *)a2 + 128));
  }

  else
  {
    *((void *)this + 63) = 0LL;
    *((_DWORD *)this + 128) = 0;
  }

  int v9 = (const icu::UnicodeString *const *)*((void *)a2 + 65);
  if (v9)
  {
    *((void *)this + 67) = *((void *)a2 + 67);
    icu::DateFormatSymbols::createZoneStrings(this, v9);
  }

  else
  {
    *((void *)this + 65) = 0LL;
    *((void *)this + 67) = 0LL;
  }

  icu::Locale::operator=((icu::DateFormatSymbols *)((char *)this + 544), (uint64_t)a2 + 544);
  *((void *)this + 66) = 0LL;
  icu::UnicodeString::fastCopyFrom((UChar **)this + 96, (UChar **)a2 + 96);
  __n128 result = *(__n128 *)((char *)a2 + 844);
  *((_OWORD *)this + 52) = *((_OWORD *)a2 + 52);
  *(__n128 *)((char *)this + 844) = result;
  return result;
}

icu::UnicodeString *icu::DateFormatSymbols::assignArray( icu::UnicodeString *this, icu::UnicodeString **a2, int *a3, const icu::UnicodeString *a4)
{
  unint64_t v4 = this;
  if (!a3)
  {
    *(_DWORD *)a2 = 0;
LABEL_16:
    *(void *)unint64_t v4 = 0LL;
    return this;
  }

  int v5 = (int)a4;
  *(_DWORD *)a2 = (_DWORD)a4;
  else {
    int v7 = (int)a4;
  }
  uint64_t v8 = v7;
  if (v7 < 0) {
    uint64_t v9 = -1LL;
  }
  else {
    uint64_t v9 = ((uint64_t)v7 << 6) | 0x10;
  }
  this = (icu::UnicodeString *)icu::UMemory::operator new[]((icu::UMemory *)v9, (unint64_t)a2);
  if (!this) {
    goto LABEL_16;
  }
  *(void *)this = 64LL;
  *((void *)this + 1) = v8;
  char v10 = (_WORD *)((char *)this + 16);
  do
  {
    *(void *)char v10 = off_18971B688;
    v10[4] = 2;
    v10 += 32;
  }

  while (v10 != (_WORD *)((char *)this + 64 * v8 + 16));
  *(void *)unint64_t v4 = (char *)this + 16;
  if (v5 >= 1)
  {
    unint64_t v11 = 0LL;
    unint64_t v12 = (unint64_t)v5 << 6;
    do
    {
      this = icu::UnicodeString::fastCopyFrom((UChar **)(*(void *)v4 + v11), (UChar **)&a3[v11 / 4]);
      v11 += 64LL;
    }

    while (v12 != v11);
  }

  return this;
}

void icu::DateFormatSymbols::createZoneStrings( icu::DateFormatSymbols *this, const icu::UnicodeString *const *a2)
{
  unint64_t v4 = uprv_malloc(8LL * *((int *)this + 134));
  *((void *)this + 65) = v4;
  if (v4 && *((int *)this + 134) >= 1)
  {
    uint64_t v6 = 0LL;
    LODWORD(v7) = *((_DWORD *)this + 135);
    while (1)
    {
      uint64_t v8 = (int)v7;
      uint64_t v9 = (icu::UMemory *)((int)v7 < 0 ? -1LL : ((uint64_t)(int)v7 << 6) | 0x10);
      char v10 = (void *)icu::UMemory::operator new[](v9, v5);
      if (v10)
      {
        *char v10 = 64LL;
        v10[1] = v8;
        unint64_t v11 = v10 + 2;
        unint64_t v12 = v10 + 2;
        do
        {
          *unint64_t v12 = off_18971B688;
          *((_WORD *)v12 + 4) = 2;
          v12 += 8;
        }

        while (v12 != &v10[8 * v8 + 2]);
      }

      else
      {
        unint64_t v11 = 0LL;
      }

      *(void *)(*((void *)this + 65) + 8 * v6) = v11;
      if (!*(void *)(*((void *)this + 65) + 8 * v6)) {
        break;
      }
      LODWORD(v7) = *((_DWORD *)this + 135);
      if ((int)v7 >= 1)
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
        do
        {
          icu::UnicodeString::fastCopyFrom( (UChar **)(*(void *)(*((void *)this + 65) + 8 * v6) + v13),  (UChar **)((char *)a2[v6] + v13));
          ++v14;
          uint64_t v7 = *((int *)this + 135);
          v13 += 64LL;
        }

        while (v14 < v7);
      }
    }

    do
    {
      uint64_t v15 = *(void *)(*((void *)this + 65) + 8 * v6);
      if (v15)
      {
        uint64_t v16 = *(void **)(v15 - 8);
        if (v16)
        {
          uint64_t v17 = (void)v16 << 6;
          do
          {
            icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)(v15 - 64 + v17));
            v17 -= 64LL;
          }

          while (v17);
        }

        icu::UMemory::operator delete[]((void *)(v15 - 16));
      }
    }

    while (v6-- > 0);
    uprv_free(*((void **)this + 65));
    *((void *)this + 65) = 0LL;
  }

uint64_t icu::DateFormatSymbols::getLocale@<X0>( uint64_t a1@<X0>, int a2@<W1>, int *a3@<X2>, icu::Locale *a4@<X8>)
{
  v5[0] = (const char *)(a1 + 956);
  v5[1] = (const char *)(a1 + 1113);
  return icu::LocaleBased::getLocale(v5, a2, a3, a4);
}

icu::DateFormatSymbols *icu::DateFormatSymbols::operator=( icu::DateFormatSymbols *this, const icu::DateFormatSymbols *a2)
{
  if (this != a2)
  {
    icu::DateFormatSymbols::dispose(this);
    icu::DateFormatSymbols::copyData(this, a2);
  }

  return this;
}

void icu::DateFormatSymbols::dispose(icu::DateFormatSymbols *this)
{
  unint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    int v3 = (char *)(v2 - 2);
    uint64_t v4 = *(v2 - 1);
    if (v4)
    {
      uint64_t v5 = v4 << 6;
      uint64_t v6 = (char *)(v2 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)&v6[v5]);
        v5 -= 64LL;
      }

      while (v5);
    }

    icu::UMemory::operator delete[](v3);
  }

  uint64_t v7 = (void *)*((void *)this + 3);
  if (v7)
  {
    uint64_t v8 = (char *)(v7 - 2);
    uint64_t v9 = *(v7 - 1);
    if (v9)
    {
      uint64_t v10 = v9 << 6;
      unint64_t v11 = (char *)(v7 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v11[v10]);
        v10 -= 64LL;
      }

      while (v10);
    }

    icu::UMemory::operator delete[](v8);
  }

  unint64_t v12 = (void *)*((void *)this + 5);
  if (v12)
  {
    uint64_t v13 = (char *)(v12 - 2);
    uint64_t v14 = *(v12 - 1);
    if (v14)
    {
      uint64_t v15 = v14 << 6;
      uint64_t v16 = (char *)(v12 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v16[v15]);
        v15 -= 64LL;
      }

      while (v15);
    }

    icu::UMemory::operator delete[](v13);
  }

  uint64_t v17 = (void *)*((void *)this + 7);
  if (v17)
  {
    double v18 = (char *)(v17 - 2);
    uint64_t v19 = *(v17 - 1);
    if (v19)
    {
      uint64_t v20 = v19 << 6;
      uint64_t v21 = (char *)(v17 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v21[v20]);
        v20 -= 64LL;
      }

      while (v20);
    }

    icu::UMemory::operator delete[](v18);
  }

  double v22 = (void *)*((void *)this + 9);
  if (v22)
  {
    unint64_t v23 = (char *)(v22 - 2);
    uint64_t v24 = *(v22 - 1);
    if (v24)
    {
      uint64_t v25 = v24 << 6;
      int v26 = (char *)(v22 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)&v26[v25]);
        v25 -= 64LL;
      }

      while (v25);
    }

    icu::UMemory::operator delete[](v23);
  }

  uint64_t v27 = (void *)*((void *)this + 11);
  if (v27)
  {
    uint64_t v28 = (char *)(v27 - 2);
    uint64_t v29 = *(v27 - 1);
    if (v29)
    {
      uint64_t v30 = v29 << 6;
      uint64_t v31 = (char *)(v27 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)&v31[v30]);
        v30 -= 64LL;
      }

      while (v30);
    }

    icu::UMemory::operator delete[](v28);
  }

  int v32 = (void *)*((void *)this + 13);
  if (v32)
  {
    unint64_t v33 = (char *)(v32 - 2);
    uint64_t v34 = *(v32 - 1);
    if (v34)
    {
      uint64_t v35 = v34 << 6;
      unint64_t v36 = (char *)(v32 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v32, (icu::UnicodeString *)&v36[v35]);
        v35 -= 64LL;
      }

      while (v35);
    }

    icu::UMemory::operator delete[](v33);
  }

  int v37 = (void *)*((void *)this + 15);
  if (v37)
  {
    uint64_t v38 = (char *)(v37 - 2);
    uint64_t v39 = *(v37 - 1);
    if (v39)
    {
      uint64_t v40 = v39 << 6;
      uint64_t v41 = (char *)(v37 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v37, (icu::UnicodeString *)&v41[v40]);
        v40 -= 64LL;
      }

      while (v40);
    }

    icu::UMemory::operator delete[](v38);
  }

  uint64_t v42 = (void *)*((void *)this + 17);
  if (v42)
  {
    uint64_t v43 = (char *)(v42 - 2);
    uint64_t v44 = *(v42 - 1);
    if (v44)
    {
      uint64_t v45 = v44 << 6;
      double v46 = (char *)(v42 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v42, (icu::UnicodeString *)&v46[v45]);
        v45 -= 64LL;
      }

      while (v45);
    }

    icu::UMemory::operator delete[](v43);
  }

  int v47 = (void *)*((void *)this + 19);
  if (v47)
  {
    uint64_t v48 = (char *)(v47 - 2);
    uint64_t v49 = *(v47 - 1);
    if (v49)
    {
      uint64_t v50 = v49 << 6;
      unsigned int v51 = (char *)(v47 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v47, (icu::UnicodeString *)&v51[v50]);
        v50 -= 64LL;
      }

      while (v50);
    }

    icu::UMemory::operator delete[](v48);
  }

  unsigned int v52 = (void *)*((void *)this + 21);
  if (v52)
  {
    uint64_t v53 = (char *)(v52 - 2);
    uint64_t v54 = *(v52 - 1);
    if (v54)
    {
      uint64_t v55 = v54 << 6;
      int v56 = (char *)(v52 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v52, (icu::UnicodeString *)&v56[v55]);
        v55 -= 64LL;
      }

      while (v55);
    }

    icu::UMemory::operator delete[](v53);
  }

  char v57 = (void *)*((void *)this + 23);
  if (v57)
  {
    int v58 = (char *)(v57 - 2);
    uint64_t v59 = *(v57 - 1);
    if (v59)
    {
      uint64_t v60 = v59 << 6;
      uint64_t v61 = (char *)(v57 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v57, (icu::UnicodeString *)&v61[v60]);
        v60 -= 64LL;
      }

      while (v60);
    }

    icu::UMemory::operator delete[](v58);
  }

  int v62 = (void *)*((void *)this + 25);
  if (v62)
  {
    uint64_t v63 = (char *)(v62 - 2);
    uint64_t v64 = *(v62 - 1);
    if (v64)
    {
      uint64_t v65 = v64 << 6;
      float v66 = (char *)(v62 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v62, (icu::UnicodeString *)&v66[v65]);
        v65 -= 64LL;
      }

      while (v65);
    }

    icu::UMemory::operator delete[](v63);
  }

  uint64_t v67 = (void *)*((void *)this + 27);
  if (v67)
  {
    uint64_t v68 = (char *)(v67 - 2);
    uint64_t v69 = *(v67 - 1);
    if (v69)
    {
      uint64_t v70 = v69 << 6;
      int v71 = (char *)(v67 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v67, (icu::UnicodeString *)&v71[v70]);
        v70 -= 64LL;
      }

      while (v70);
    }

    icu::UMemory::operator delete[](v68);
  }

  __int128 v72 = (void *)*((void *)this + 29);
  if (v72)
  {
    int v73 = (char *)(v72 - 2);
    uint64_t v74 = *(v72 - 1);
    if (v74)
    {
      uint64_t v75 = v74 << 6;
      char v76 = (char *)(v72 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v72, (icu::UnicodeString *)&v76[v75]);
        v75 -= 64LL;
      }

      while (v75);
    }

    icu::UMemory::operator delete[](v73);
  }

  uint64_t v77 = (void *)*((void *)this + 31);
  if (v77)
  {
    uint64_t v78 = (char *)(v77 - 2);
    uint64_t v79 = *(v77 - 1);
    if (v79)
    {
      uint64_t v80 = v79 << 6;
      uint64_t v81 = (char *)(v77 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v77, (icu::UnicodeString *)&v81[v80]);
        v80 -= 64LL;
      }

      while (v80);
    }

    icu::UMemory::operator delete[](v78);
  }

  char v82 = (void *)*((void *)this + 33);
  if (v82)
  {
    int v83 = (char *)(v82 - 2);
    uint64_t v84 = *(v82 - 1);
    if (v84)
    {
      uint64_t v85 = v84 << 6;
      uint64_t v86 = (char *)(v82 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v82, (icu::UnicodeString *)&v86[v85]);
        v85 -= 64LL;
      }

      while (v85);
    }

    icu::UMemory::operator delete[](v83);
  }

  char v87 = (void *)*((void *)this + 35);
  if (v87)
  {
    int v88 = (char *)(v87 - 2);
    uint64_t v89 = *(v87 - 1);
    if (v89)
    {
      uint64_t v90 = v89 << 6;
      char v91 = (char *)(v87 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v87, (icu::UnicodeString *)&v91[v90]);
        v90 -= 64LL;
      }

      while (v90);
    }

    icu::UMemory::operator delete[](v88);
  }

  uint64_t v92 = (void *)*((void *)this + 37);
  if (v92)
  {
    unint64_t v93 = (char *)(v92 - 2);
    uint64_t v94 = *(v92 - 1);
    if (v94)
    {
      uint64_t v95 = v94 << 6;
      int v96 = (char *)(v92 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v92, (icu::UnicodeString *)&v96[v95]);
        v95 -= 64LL;
      }

      while (v95);
    }

    icu::UMemory::operator delete[](v93);
  }

  int v97 = (void *)*((void *)this + 47);
  if (v97)
  {
    int v98 = (char *)(v97 - 2);
    uint64_t v99 = *(v97 - 1);
    if (v99)
    {
      uint64_t v100 = v99 << 6;
      uint64_t v101 = (char *)(v97 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v97, (icu::UnicodeString *)&v101[v100]);
        v100 -= 64LL;
      }

      while (v100);
    }

    icu::UMemory::operator delete[](v98);
  }

  uint64_t v102 = (void *)*((void *)this + 49);
  if (v102)
  {
    uint64_t v103 = (char *)(v102 - 2);
    uint64_t v104 = *(v102 - 1);
    if (v104)
    {
      uint64_t v105 = v104 << 6;
      v106 = (char *)(v102 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v102, (icu::UnicodeString *)&v106[v105]);
        v105 -= 64LL;
      }

      while (v105);
    }

    icu::UMemory::operator delete[](v103);
  }

  char v107 = (void *)*((void *)this + 51);
  if (v107)
  {
    v108 = (char *)(v107 - 2);
    uint64_t v109 = *(v107 - 1);
    if (v109)
    {
      uint64_t v110 = v109 << 6;
      UErrorCode v111 = (char *)(v107 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v107, (icu::UnicodeString *)&v111[v110]);
        v110 -= 64LL;
      }

      while (v110);
    }

    icu::UMemory::operator delete[](v108);
  }

  int v112 = (void *)*((void *)this + 53);
  if (v112)
  {
    unint64_t v113 = (char *)(v112 - 2);
    uint64_t v114 = *(v112 - 1);
    if (v114)
    {
      uint64_t v115 = v114 << 6;
      uint64_t v116 = (char *)(v112 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v112, (icu::UnicodeString *)&v116[v115]);
        v115 -= 64LL;
      }

      while (v115);
    }

    icu::UMemory::operator delete[](v113);
  }

  int v117 = (void *)*((void *)this + 55);
  if (v117)
  {
    uint64_t v118 = (char *)(v117 - 2);
    uint64_t v119 = *(v117 - 1);
    if (v119)
    {
      uint64_t v120 = v119 << 6;
      v121 = (char *)(v117 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v117, (icu::UnicodeString *)&v121[v120]);
        v120 -= 64LL;
      }

      while (v120);
    }

    icu::UMemory::operator delete[](v118);
  }

  __int128 v122 = (void *)*((void *)this + 57);
  if (v122)
  {
    __int128 v123 = (char *)(v122 - 2);
    uint64_t v124 = *(v122 - 1);
    if (v124)
    {
      uint64_t v125 = v124 << 6;
      char v126 = (char *)(v122 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v122, (icu::UnicodeString *)&v126[v125]);
        v125 -= 64LL;
      }

      while (v125);
    }

    icu::UMemory::operator delete[](v123);
  }

  int v127 = (void *)*((void *)this + 59);
  if (v127)
  {
    size_t v128 = (char *)(v127 - 2);
    uint64_t v129 = *(v127 - 1);
    if (v129)
    {
      uint64_t v130 = v129 << 6;
      __int128 v131 = (char *)(v127 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v127, (icu::UnicodeString *)&v131[v130]);
        v130 -= 64LL;
      }

      while (v130);
    }

    icu::UMemory::operator delete[](v128);
  }

  int v132 = (void *)*((void *)this + 61);
  if (v132)
  {
    int v133 = (char *)(v132 - 2);
    uint64_t v134 = *(v132 - 1);
    if (v134)
    {
      uint64_t v135 = v134 << 6;
      int v136 = (char *)(v132 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v132, (icu::UnicodeString *)&v136[v135]);
        v135 -= 64LL;
      }

      while (v135);
    }

    icu::UMemory::operator delete[](v133);
  }

  int v137 = (void *)*((void *)this + 63);
  if (v137)
  {
    v138 = (char *)(v137 - 2);
    uint64_t v139 = *(v137 - 1);
    if (v139)
    {
      uint64_t v140 = v139 << 6;
      v141 = (char *)(v137 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v137, (icu::UnicodeString *)&v141[v140]);
        v140 -= 64LL;
      }

      while (v140);
    }

    icu::UMemory::operator delete[](v138);
  }

  v142 = (void *)*((void *)this + 108);
  if (v142)
  {
    v143 = (char *)(v142 - 2);
    uint64_t v144 = *(v142 - 1);
    if (v144)
    {
      uint64_t v145 = v144 << 6;
      v146 = (char *)(v142 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v142, (icu::UnicodeString *)&v146[v145]);
        v145 -= 64LL;
      }

      while (v145);
    }

    icu::UMemory::operator delete[](v143);
  }

  int v147 = (void *)*((void *)this + 110);
  if (v147)
  {
    v148 = (char *)(v147 - 2);
    uint64_t v149 = *(v147 - 1);
    if (v149)
    {
      uint64_t v150 = v149 << 6;
      v151 = (char *)(v147 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v147, (icu::UnicodeString *)&v151[v150]);
        v150 -= 64LL;
      }

      while (v150);
    }

    icu::UMemory::operator delete[](v148);
  }

  int v152 = (void *)*((void *)this + 112);
  if (v152)
  {
    v153 = (char *)(v152 - 2);
    uint64_t v154 = *(v152 - 1);
    if (v154)
    {
      uint64_t v155 = v154 << 6;
      uint64_t v156 = (char *)(v152 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v152, (icu::UnicodeString *)&v156[v155]);
        v155 -= 64LL;
      }

      while (v155);
    }

    icu::UMemory::operator delete[](v153);
  }

  v157 = (void *)*((void *)this + 114);
  if (v157)
  {
    v158 = (char *)(v157 - 2);
    uint64_t v159 = *(v157 - 1);
    if (v159)
    {
      uint64_t v160 = v159 << 6;
      v161 = (char *)(v157 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v157, (icu::UnicodeString *)&v161[v160]);
        v160 -= 64LL;
      }

      while (v160);
    }

    icu::UMemory::operator delete[](v158);
  }

  v162 = (void *)*((void *)this + 116);
  if (v162)
  {
    v163 = (char *)(v162 - 2);
    uint64_t v164 = *(v162 - 1);
    if (v164)
    {
      uint64_t v165 = v164 << 6;
      v166 = (char *)(v162 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v162, (icu::UnicodeString *)&v166[v165]);
        v165 -= 64LL;
      }

      while (v165);
    }

    icu::UMemory::operator delete[](v163);
  }

  v167 = (void *)*((void *)this + 118);
  if (v167)
  {
    v168 = (char *)(v167 - 2);
    uint64_t v169 = *(v167 - 1);
    if (v169)
    {
      uint64_t v170 = v169 << 6;
      v171 = (char *)(v167 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v167, (icu::UnicodeString *)&v171[v170]);
        v170 -= 64LL;
      }

      while (v170);
    }

    icu::UMemory::operator delete[](v168);
  }

  icu::DateFormatSymbols::disposeZoneStrings(this);
}

void icu::DateFormatSymbols::~DateFormatSymbols(icu::DateFormatSymbols *this)
{
}

{
  void *v1;
  icu::DateFormatSymbols::~DateFormatSymbols(this);
  icu::UMemory::operator delete(v1);
}

void icu::DateFormatSymbols::disposeZoneStrings(icu::DateFormatSymbols *this)
{
  unint64_t v2 = (void **)((char *)this + 520);
  int v3 = (void *)*((void *)this + 65);
  if (v3)
  {
    int v4 = *((_DWORD *)this + 134);
    if (v4 >= 1)
    {
      for (uint64_t i = 0LL; i < v4; ++i)
      {
        uint64_t v6 = *((void *)*v2 + i);
        if (v6)
        {
          uint64_t v7 = *(void **)(v6 - 8);
          if (v7)
          {
            uint64_t v8 = (void)v7 << 6;
            do
            {
              icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)(v6 - 64 + v8));
              v8 -= 64LL;
            }

            while (v8);
          }

          icu::UMemory::operator delete[]((void *)(v6 - 16));
          int v4 = *((_DWORD *)this + 134);
        }
      }

      int v3 = *v2;
    }

    uprv_free(v3);
  }

  uint64_t v9 = (void *)*((void *)this + 66);
  if (v9)
  {
    int v10 = *((_DWORD *)this + 134);
    if (v10 >= 1)
    {
      for (uint64_t j = 0LL; j < v10; ++j)
      {
        uint64_t v12 = *(void *)(*((void *)this + 66) + 8 * j);
        if (v12)
        {
          uint64_t v13 = *(void **)(v12 - 8);
          if (v13)
          {
            uint64_t v14 = (void)v13 << 6;
            do
            {
              icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)(v12 - 64 + v14));
              v14 -= 64LL;
            }

            while (v14);
          }

          icu::UMemory::operator delete[]((void *)(v12 - 16));
          int v10 = *((_DWORD *)this + 134);
        }
      }

      uint64_t v9 = (void *)*((void *)this + 66);
    }

    uprv_free(v9);
  }

  void *v2 = 0LL;
  v2[1] = 0LL;
  v2[2] = 0LL;
}

BOOL icu::DateFormatSymbols::arrayCompare( icu::DateFormatSymbols *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  BOOL result = 1LL;
  if (this != a2)
  {
    int v5 = (int)a3;
    if ((int)a3 >= 1)
    {
      uint64_t v6 = a2;
      unint64_t v7 = (unint64_t)a3 << 6;
      do
      {
        uint64_t v8 = (char *)v6 + v7;
        unsigned int v9 = *(unsigned __int16 *)((char *)this + v7 - 56);
        if ((v9 & 1) != 0)
        {
          if ((*((_WORD *)v8 - 28) & 1) == 0) {
            return 0LL;
          }
        }

        else
        {
          if ((v9 & 0x8000) != 0) {
            int v10 = *(_DWORD *)((char *)this + v7 - 52);
          }
          else {
            int v10 = v9 >> 5;
          }
          BOOL result = 0LL;
          unsigned int v11 = *(unsigned __int16 *)((char *)v6 + v7 - 56);
          unsigned int v12 = *(_DWORD *)((char *)v6 + v7 - 52);
          if ((v11 & 0x8000u) == 0) {
            unsigned int v12 = v11 >> 5;
          }
          if ((v11 & 1) != 0) {
            return result;
          }
          if (v10 != v12) {
            return result;
          }
          BOOL result = icu::UnicodeString::doEquals( (icu::DateFormatSymbols *)((char *)this + v7 - 64),  (const icu::UnicodeString *)(v8 - 64),  v10);
          if (!result) {
            return result;
          }
        }

        uint64_t v6 = (const icu::UnicodeString *)((char *)v6 - 64);
        this = (icu::DateFormatSymbols *)((char *)this - 64);
        BOOL v13 = __OFSUB__(v5--, 1);
      }

      while (!((v5 < 0) ^ v13 | (v5 == 0)));
      return 1LL;
    }
  }

  return result;
}

BOOL icu::DateFormatSymbols::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  unint64_t v2 = (const icu::UnicodeString *)*(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 != *(_DWORD *)(a2 + 16)
    || *(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32)
    || *(_DWORD *)(a1 + 48) != *(_DWORD *)(a2 + 48)
    || *(_DWORD *)(a1 + 64) != *(_DWORD *)(a2 + 64)
    || *(_DWORD *)(a1 + 80) != *(_DWORD *)(a2 + 80)
    || *(_DWORD *)(a1 + 96) != *(_DWORD *)(a2 + 96)
    || *(_DWORD *)(a1 + 112) != *(_DWORD *)(a2 + 112)
    || *(_DWORD *)(a1 + 128) != *(_DWORD *)(a2 + 128)
    || *(_DWORD *)(a1 + 144) != *(_DWORD *)(a2 + 144)
    || *(_DWORD *)(a1 + 160) != *(_DWORD *)(a2 + 160)
    || *(_DWORD *)(a1 + 176) != *(_DWORD *)(a2 + 176)
    || *(_DWORD *)(a1 + 192) != *(_DWORD *)(a2 + 192)
    || *(_DWORD *)(a1 + 208) != *(_DWORD *)(a2 + 208)
    || *(_DWORD *)(a1 + 224) != *(_DWORD *)(a2 + 224)
    || *(_DWORD *)(a1 + 240) != *(_DWORD *)(a2 + 240)
    || *(_DWORD *)(a1 + 256) != *(_DWORD *)(a2 + 256)
    || *(_DWORD *)(a1 + 272) != *(_DWORD *)(a2 + 272)
    || *(_DWORD *)(a1 + 288) != *(_DWORD *)(a2 + 288)
    || *(_DWORD *)(a1 + 304) != *(_DWORD *)(a2 + 304)
    || *(_DWORD *)(a1 + 384) != *(_DWORD *)(a2 + 384)
    || *(_DWORD *)(a1 + 400) != *(_DWORD *)(a2 + 400)
    || *(_DWORD *)(a1 + 416) != *(_DWORD *)(a2 + 416)
    || *(_DWORD *)(a1 + 432) != *(_DWORD *)(a2 + 432)
    || *(_DWORD *)(a1 + 448) != *(_DWORD *)(a2 + 448)
    || *(_DWORD *)(a1 + 464) != *(_DWORD *)(a2 + 464)
    || *(_DWORD *)(a1 + 480) != *(_DWORD *)(a2 + 480)
    || *(_DWORD *)(a1 + 496) != *(_DWORD *)(a2 + 496)
    || *(_DWORD *)(a1 + 512) != *(_DWORD *)(a2 + 512)
    || *(_DWORD *)(a1 + 872) != *(_DWORD *)(a2 + 872)
    || *(_DWORD *)(a1 + 888) != *(_DWORD *)(a2 + 888)
    || *(_DWORD *)(a1 + 904) != *(_DWORD *)(a2 + 904)
    || *(_DWORD *)(a1 + 920) != *(_DWORD *)(a2 + 920)
    || *(_DWORD *)(a1 + 936) != *(_DWORD *)(a2 + 936)
    || *(_DWORD *)(a1 + 952) != *(_DWORD *)(a2 + 952))
  {
    return 0LL;
  }

  BOOL v3 = *(void *)(a1 + 832) == *(void *)(a2 + 832) && *(void *)(a1 + 840) == *(void *)(a2 + 840);
  BOOL v4 = v3 && *(void *)(a1 + 848) == *(void *)(a2 + 848);
  BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 8),  *(const icu::UnicodeString **)(a2 + 8),  v2);
  if (result)
  {
    BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 24),  *(const icu::UnicodeString **)(a2 + 24),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 32));
    if (result)
    {
      BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 40),  *(const icu::UnicodeString **)(a2 + 40),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 48));
      if (result)
      {
        BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 56),  *(const icu::UnicodeString **)(a2 + 56),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 64));
        if (result)
        {
          BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 72),  *(const icu::UnicodeString **)(a2 + 72),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 80));
          if (result)
          {
            BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 88),  *(const icu::UnicodeString **)(a2 + 88),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 96));
            if (result)
            {
              BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 104),  *(const icu::UnicodeString **)(a2 + 104),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 112));
              if (result)
              {
                BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 120),  *(const icu::UnicodeString **)(a2 + 120),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 128));
                if (result)
                {
                  BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 136),  *(const icu::UnicodeString **)(a2 + 136),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 144));
                  if (result)
                  {
                    BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 152),  *(const icu::UnicodeString **)(a2 + 152),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 160));
                    if (result)
                    {
                      BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 168),  *(const icu::UnicodeString **)(a2 + 168),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 176));
                      if (result)
                      {
                        BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 184),  *(const icu::UnicodeString **)(a2 + 184),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 192));
                        if (result)
                        {
                          BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 200),  *(const icu::UnicodeString **)(a2 + 200),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 208));
                          if (result)
                          {
                            BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 216),  *(const icu::UnicodeString **)(a2 + 216),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 224));
                            if (result)
                            {
                              BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 232),  *(const icu::UnicodeString **)(a2 + 232),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 240));
                              if (result)
                              {
                                BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 248),  *(const icu::UnicodeString **)(a2 + 248),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 256));
                                if (result)
                                {
                                  BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 264),  *(const icu::UnicodeString **)(a2 + 264),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 272));
                                  if (result)
                                  {
                                    BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 280),  *(const icu::UnicodeString **)(a2 + 280),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 288));
                                    if (result)
                                    {
                                      BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 296),  *(const icu::UnicodeString **)(a2 + 296),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 304));
                                      if (result)
                                      {
                                        BOOL result = sub_1807FF934(a1 + 312, a2 + 312);
                                        if (result)
                                        {
                                          BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 376),  *(const icu::UnicodeString **)(a2 + 376),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 384));
                                          if (result)
                                          {
                                            BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 392),  *(const icu::UnicodeString **)(a2 + 392),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 400));
                                            if (result)
                                            {
                                              BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 408),  *(const icu::UnicodeString **)(a2 + 408),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 416));
                                              if (result)
                                              {
                                                BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 424),  *(const icu::UnicodeString **)(a2 + 424),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 432));
                                                if (result)
                                                {
                                                  BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 440),  *(const icu::UnicodeString **)(a2 + 440),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 448));
                                                  if (result)
                                                  {
                                                    BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 456),  *(const icu::UnicodeString **)(a2 + 456),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 464));
                                                    if (result)
                                                    {
                                                      BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 472),  *(const icu::UnicodeString **)(a2 + 472),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 480));
                                                      if (result)
                                                      {
                                                        BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 488),  *(const icu::UnicodeString **)(a2 + 488),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 496));
                                                        if (result)
                                                        {
                                                          BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 504),  *(const icu::UnicodeString **)(a2 + 504),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 512));
                                                          if (result)
                                                          {
                                                            BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 864),  *(const icu::UnicodeString **)(a2 + 864),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 872));
                                                            if (result)
                                                            {
                                                              BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 880),  *(const icu::UnicodeString **)(a2 + 880),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 888));
                                                              if (result)
                                                              {
                                                                BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 896),  *(const icu::UnicodeString **)(a2 + 896),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 904));
                                                                if (result)
                                                                {
                                                                  BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 912),  *(const icu::UnicodeString **)(a2 + 912),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 920));
                                                                  if (result)
                                                                  {
                                                                    BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 928),  *(const icu::UnicodeString **)(a2 + 928),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 936));
                                                                    if (result)
                                                                    {
                                                                      BOOL result = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(a1 + 944),  *(const icu::UnicodeString **)(a2 + 944),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 936));
                                                                      if (result)
                                                                      {
                                                                        uint64_t v7 = *(void *)(a1 + 520);
                                                                        uint64_t v8 = *(void *)(a2 + 520);
                                                                        if (!(v7 | v8)) {
                                                                          return icu::Locale::operator==( a1 + 544,  a2 + 544);
                                                                        }
                                                                        if (!v7) {
                                                                          return 0LL;
                                                                        }
                                                                        if (!v8) {
                                                                          return 0LL;
                                                                        }
                                                                        int v9 = *(_DWORD *)(a1 + 536);
                                                                        if (v9 != *(_DWORD *)(a2 + 536)
                                                                          || *(_DWORD *)(a1 + 540) != *(_DWORD *)(a2 + 540))
                                                                        {
                                                                          return 0LL;
                                                                        }

                                                                        if (v9 < 1) {
                                                                          return 1LL;
                                                                        }
                                                                        uint64_t v10 = 0LL;
                                                                        do
                                                                        {
                                                                          BOOL v11 = icu::DateFormatSymbols::arrayCompare( *(icu::DateFormatSymbols **)(*(void *)(a1 + 520) + 8 * v10),  *(const icu::UnicodeString **)(*(void *)(a2 + 520) + 8 * v10),  (const icu::UnicodeString *)*(unsigned int *)(a1 + 540));
                                                                          BOOL result = v11;
                                                                        }

                                                                        while (++v10 < *(int *)(a1 + 536) && v11);
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t icu::DateFormatSymbols::getEras(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 4);
  return *((void *)this + 1);
}

uint64_t icu::DateFormatSymbols::getEraNames(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 8);
  return *((void *)this + 3);
}

uint64_t icu::DateFormatSymbols::getNarrowEras(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 12);
  return *((void *)this + 5);
}

uint64_t icu::DateFormatSymbols::getMonths(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 16);
  return *((void *)this + 7);
}

uint64_t icu::DateFormatSymbols::getShortMonths(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 20);
  return *((void *)this + 9);
}

uint64_t icu::DateFormatSymbols::getMonths(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  if (a3 == 1)
  {
    switch(a4)
    {
      case 0:
      case 3:
        *a2 = a1[32];
        BOOL v4 = a1 + 30;
        break;
      case 1:
        *a2 = a1[28];
        BOOL v4 = a1 + 26;
        break;
      case 2:
        *a2 = a1[36];
        BOOL v4 = a1 + 34;
        break;
      default:
        return 0LL;
    }

    return *(void *)v4;
  }

  else
  {
    if (!a3)
    {
      switch(a4)
      {
        case 0:
        case 3:
          *a2 = a1[20];
          BOOL v4 = a1 + 18;
          return *(void *)v4;
        case 1:
          *a2 = a1[16];
          BOOL v4 = a1 + 14;
          return *(void *)v4;
        case 2:
          *a2 = a1[24];
          BOOL v4 = a1 + 22;
          return *(void *)v4;
        default:
          return 0LL;
      }
    }

    return 0LL;
  }

uint64_t icu::DateFormatSymbols::getWeekdays(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 40);
  return *((void *)this + 19);
}

uint64_t icu::DateFormatSymbols::getShortWeekdays(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 44);
  return *((void *)this + 21);
}

uint64_t icu::DateFormatSymbols::getWeekdays(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  if (a3 == 1)
  {
    switch(a4)
    {
      case 0:
        *a2 = a1[60];
        BOOL v4 = a1 + 58;
        break;
      case 1:
        *a2 = a1[56];
        BOOL v4 = a1 + 54;
        break;
      case 2:
        *a2 = a1[68];
        BOOL v4 = a1 + 66;
        break;
      case 3:
        *a2 = a1[64];
        BOOL v4 = a1 + 62;
        break;
      default:
        return 0LL;
    }

    return *(void *)v4;
  }

  else
  {
    if (!a3)
    {
      switch(a4)
      {
        case 0:
          *a2 = a1[44];
          BOOL v4 = a1 + 42;
          return *(void *)v4;
        case 1:
          *a2 = a1[40];
          BOOL v4 = a1 + 38;
          return *(void *)v4;
        case 2:
          *a2 = a1[52];
          BOOL v4 = a1 + 50;
          return *(void *)v4;
        case 3:
          *a2 = a1[48];
          BOOL v4 = a1 + 46;
          return *(void *)v4;
        default:
          return 0LL;
      }
    }

    return 0LL;
  }

uint64_t icu::DateFormatSymbols::getQuarters(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  if (a3 == 1)
  {
    switch(a4)
    {
      case 0:
      case 3:
        *a2 = a1[112];
        BOOL v4 = a1 + 110;
        break;
      case 1:
        *a2 = a1[108];
        BOOL v4 = a1 + 106;
        break;
      case 2:
        *a2 = a1[116];
        BOOL v4 = a1 + 114;
        break;
      default:
        return 0LL;
    }

    return *(void *)v4;
  }

  else
  {
    if (!a3)
    {
      switch(a4)
      {
        case 0:
        case 3:
          *a2 = a1[100];
          BOOL v4 = a1 + 98;
          return *(void *)v4;
        case 1:
          *a2 = a1[96];
          BOOL v4 = a1 + 94;
          return *(void *)v4;
        case 2:
          *a2 = a1[104];
          BOOL v4 = a1 + 102;
          return *(void *)v4;
        default:
          return 0LL;
      }
    }

    return 0LL;
  }

icu::UnicodeString *icu::DateFormatSymbols::getTimeSeparatorString(UChar **this, UChar **a2)
{
  return icu::UnicodeString::fastCopyFrom(a2, this + 39);
}

uint64_t icu::DateFormatSymbols::getAmPmStrings(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 72);
  return *((void *)this + 35);
}

uint64_t icu::DateFormatSymbols::getLeapMonthPatterns(icu::DateFormatSymbols *this, int *a2)
{
  *a2 = *((_DWORD *)this + 120);
  return *((void *)this + 59);
}

uint64_t icu::DateFormatSymbols::getYearNames(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 496);
  return *(void *)(a1 + 488);
}

uint64_t icu::DateFormatSymbols::setYearNames(uint64_t result, unint64_t a2, int a3, int a4, int a5)
{
  if (!(a5 | a4))
  {
    uint64_t v6 = (UChar **)a2;
    uint64_t v7 = result;
    uint64_t v8 = *(void **)(result + 488);
    if (v8)
    {
      int v9 = (char *)(v8 - 2);
      uint64_t v10 = *(v8 - 1);
      if (v10)
      {
        uint64_t v11 = v10 << 6;
        unsigned int v12 = (char *)(v8 - 8);
        do
        {
          icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v12[v11]);
          v11 -= 64LL;
        }

        while (v11);
      }

      icu::UMemory::operator delete[](v9);
    }

    else {
      int v13 = a3;
    }
    uint64_t v14 = v13;
    if (v13 < 0) {
      uint64_t v15 = -1LL;
    }
    else {
      uint64_t v15 = ((uint64_t)v13 << 6) | 0x10;
    }
    BOOL result = icu::UMemory::operator new[]((icu::UMemory *)v15, a2);
    if (result)
    {
      *(void *)BOOL result = 64LL;
      *(void *)(result + 8) = v14;
      result += 16LL;
      uint64_t v16 = result;
      do
      {
        *(void *)uint64_t v16 = off_18971B688;
        *(_WORD *)(v16 + 8) = 2;
        v16 += 64LL;
      }

      while (v16 != result + (v14 << 6));
    }

    *(void *)(v7 + 488) = result;
    if (a3 >= 1)
    {
      unsigned int v17 = a3 + 1;
      do
      {
        uint64_t v18 = result + 64;
        icu::UnicodeString::operator=((UChar **)result, v6);
        --v17;
        BOOL result = v18;
        v6 += 8;
      }

      while (v17 > 1);
    }

    *(_DWORD *)(v7 + 496) = a3;
  }

  return result;
}

uint64_t icu::DateFormatSymbols::getZodiacNames(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 512);
  return *(void *)(a1 + 504);
}

uint64_t icu::DateFormatSymbols::setZodiacNames(uint64_t result, unint64_t a2, int a3, int a4, int a5)
{
  if (!(a5 | a4))
  {
    uint64_t v6 = (UChar **)a2;
    uint64_t v7 = result;
    uint64_t v8 = *(void **)(result + 504);
    if (v8)
    {
      int v9 = (char *)(v8 - 2);
      uint64_t v10 = *(v8 - 1);
      if (v10)
      {
        uint64_t v11 = v10 << 6;
        unsigned int v12 = (char *)(v8 - 8);
        do
        {
          icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v12[v11]);
          v11 -= 64LL;
        }

        while (v11);
      }

      icu::UMemory::operator delete[](v9);
    }

    else {
      int v13 = a3;
    }
    uint64_t v14 = v13;
    if (v13 < 0) {
      uint64_t v15 = -1LL;
    }
    else {
      uint64_t v15 = ((uint64_t)v13 << 6) | 0x10;
    }
    BOOL result = icu::UMemory::operator new[]((icu::UMemory *)v15, a2);
    if (result)
    {
      *(void *)BOOL result = 64LL;
      *(void *)(result + 8) = v14;
      result += 16LL;
      uint64_t v16 = result;
      do
      {
        *(void *)uint64_t v16 = off_18971B688;
        *(_WORD *)(v16 + 8) = 2;
        v16 += 64LL;
      }

      while (v16 != result + (v14 << 6));
    }

    *(void *)(v7 + 504) = result;
    if (a3 >= 1)
    {
      unsigned int v17 = a3 + 1;
      do
      {
        uint64_t v18 = result + 64;
        icu::UnicodeString::operator=((UChar **)result, v6);
        --v17;
        BOOL result = v18;
        v6 += 8;
      }

      while (v17 > 1);
    }

    *(_DWORD *)(v7 + 512) = a3;
  }

  return result;
}

uint64_t icu::DateFormatSymbols::setEras(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 1);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 1) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 4) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setEraNames(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 3);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 3) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 8) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setNarrowEras(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 5);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 5) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 12) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setMonths(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 7);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 7) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 16) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setShortMonths(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 9);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 9) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 20) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setMonths(uint64_t result, unint64_t a2, int a3, int a4, int a5)
{
  uint64_t v6 = (UChar **)a2;
  uint64_t v7 = (int *)result;
  if (a4 == 1)
  {
    if (a5)
    {
      if (a5 == 2)
      {
        uint64_t v64 = *(void **)(result + 136);
        if (v64)
        {
          uint64_t v65 = (char *)(v64 - 2);
          uint64_t v66 = *(v64 - 1);
          if (v66)
          {
            uint64_t v67 = v66 << 6;
            uint64_t v68 = (char *)(v64 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v64, (icu::UnicodeString *)&v68[v67]);
              v67 -= 64LL;
            }

            while (v67);
          }

          icu::UMemory::operator delete[](v65);
        }

        else {
          int v69 = a3;
        }
        uint64_t v70 = v69;
        if (v69 < 0) {
          uint64_t v71 = -1LL;
        }
        else {
          uint64_t v71 = ((uint64_t)v69 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v71, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v70;
          result += 16LL;
          uint64_t v72 = result;
          do
          {
            *(void *)uint64_t v72 = off_18971B688;
            *(_WORD *)(v72 + 8) = 2;
            v72 += 64LL;
          }

          while (v72 != result + (v70 << 6));
        }

        *((void *)v7 + 17) = result;
        if (a3 >= 1)
        {
          unsigned int v73 = a3 + 1;
          do
          {
            uint64_t v74 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v73;
            uint64_t result = v74;
            v6 += 8;
          }

          while (v73 > 1);
        }

        uint64_t v19 = v7 + 36;
      }

      else
      {
        if (a5 != 1) {
          return result;
        }
        uint64_t v20 = *(void **)(result + 104);
        if (v20)
        {
          uint64_t v21 = (char *)(v20 - 2);
          uint64_t v22 = *(v20 - 1);
          if (v22)
          {
            uint64_t v23 = v22 << 6;
            uint64_t v24 = (char *)(v20 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v24[v23]);
              v23 -= 64LL;
            }

            while (v23);
          }

          icu::UMemory::operator delete[](v21);
        }

        else {
          int v25 = a3;
        }
        uint64_t v26 = v25;
        if (v25 < 0) {
          uint64_t v27 = -1LL;
        }
        else {
          uint64_t v27 = ((uint64_t)v25 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v27, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v26;
          result += 16LL;
          uint64_t v28 = result;
          do
          {
            *(void *)uint64_t v28 = off_18971B688;
            *(_WORD *)(v28 + 8) = 2;
            v28 += 64LL;
          }

          while (v28 != result + (v26 << 6));
        }

        *((void *)v7 + 13) = result;
        if (a3 >= 1)
        {
          unsigned int v29 = a3 + 1;
          do
          {
            uint64_t v30 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v29;
            uint64_t result = v30;
            v6 += 8;
          }

          while (v29 > 1);
        }

        uint64_t v19 = v7 + 28;
      }
    }

    else
    {
      uint64_t v53 = *(void **)(result + 120);
      if (v53)
      {
        uint64_t v54 = (char *)(v53 - 2);
        uint64_t v55 = *(v53 - 1);
        if (v55)
        {
          uint64_t v56 = v55 << 6;
          char v57 = (char *)(v53 - 8);
          do
          {
            icu::UnicodeString::~UnicodeString(v53, (icu::UnicodeString *)&v57[v56]);
            v56 -= 64LL;
          }

          while (v56);
        }

        icu::UMemory::operator delete[](v54);
      }

      else {
        int v58 = a3;
      }
      uint64_t v59 = v58;
      if (v58 < 0) {
        uint64_t v60 = -1LL;
      }
      else {
        uint64_t v60 = ((uint64_t)v58 << 6) | 0x10;
      }
      uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v60, a2);
      if (result)
      {
        *(void *)uint64_t result = 64LL;
        *(void *)(result + 8) = v59;
        result += 16LL;
        uint64_t v61 = result;
        do
        {
          *(void *)uint64_t v61 = off_18971B688;
          *(_WORD *)(v61 + 8) = 2;
          v61 += 64LL;
        }

        while (v61 != result + (v59 << 6));
      }

      *((void *)v7 + 15) = result;
      if (a3 >= 1)
      {
        unsigned int v62 = a3 + 1;
        do
        {
          uint64_t v63 = result + 64;
          icu::UnicodeString::operator=((UChar **)result, v6);
          --v62;
          uint64_t result = v63;
          v6 += 8;
        }

        while (v62 > 1);
      }

      uint64_t v19 = v7 + 32;
    }
  }

  else
  {
    if (a4) {
      return result;
    }
    if (a5)
    {
      if (a5 == 2)
      {
        uint64_t v42 = *(void **)(result + 88);
        if (v42)
        {
          uint64_t v43 = (char *)(v42 - 2);
          uint64_t v44 = *(v42 - 1);
          if (v44)
          {
            uint64_t v45 = v44 << 6;
            double v46 = (char *)(v42 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v42, (icu::UnicodeString *)&v46[v45]);
              v45 -= 64LL;
            }

            while (v45);
          }

          icu::UMemory::operator delete[](v43);
        }

        else {
          int v47 = a3;
        }
        uint64_t v48 = v47;
        if (v47 < 0) {
          uint64_t v49 = -1LL;
        }
        else {
          uint64_t v49 = ((uint64_t)v47 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v49, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v48;
          result += 16LL;
          uint64_t v50 = result;
          do
          {
            *(void *)uint64_t v50 = off_18971B688;
            *(_WORD *)(v50 + 8) = 2;
            v50 += 64LL;
          }

          while (v50 != result + (v48 << 6));
        }

        *((void *)v7 + 11) = result;
        if (a3 >= 1)
        {
          unsigned int v51 = a3 + 1;
          do
          {
            uint64_t v52 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v51;
            uint64_t result = v52;
            v6 += 8;
          }

          while (v51 > 1);
        }

        uint64_t v19 = v7 + 24;
      }

      else
      {
        if (a5 != 1) {
          return result;
        }
        uint64_t v8 = *(void **)(result + 56);
        if (v8)
        {
          uint64_t v9 = (char *)(v8 - 2);
          uint64_t v10 = *(v8 - 1);
          if (v10)
          {
            uint64_t v11 = v10 << 6;
            uint64_t v12 = (char *)(v8 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v12[v11]);
              v11 -= 64LL;
            }

            while (v11);
          }

          icu::UMemory::operator delete[](v9);
        }

        else {
          int v13 = a3;
        }
        uint64_t v14 = v13;
        if (v13 < 0) {
          uint64_t v15 = -1LL;
        }
        else {
          uint64_t v15 = ((uint64_t)v13 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v15, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v14;
          result += 16LL;
          uint64_t v16 = result;
          do
          {
            *(void *)uint64_t v16 = off_18971B688;
            *(_WORD *)(v16 + 8) = 2;
            v16 += 64LL;
          }

          while (v16 != result + (v14 << 6));
        }

        *((void *)v7 + 7) = result;
        if (a3 >= 1)
        {
          unsigned int v17 = a3 + 1;
          do
          {
            uint64_t v18 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v17;
            uint64_t result = v18;
            v6 += 8;
          }

          while (v17 > 1);
        }

        uint64_t v19 = v7 + 16;
      }
    }

    else
    {
      uint64_t v31 = *(void **)(result + 72);
      if (v31)
      {
        int v32 = (char *)(v31 - 2);
        uint64_t v33 = *(v31 - 1);
        if (v33)
        {
          uint64_t v34 = v33 << 6;
          uint64_t v35 = (char *)(v31 - 8);
          do
          {
            icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)&v35[v34]);
            v34 -= 64LL;
          }

          while (v34);
        }

        icu::UMemory::operator delete[](v32);
      }

      else {
        int v36 = a3;
      }
      uint64_t v37 = v36;
      if (v36 < 0) {
        uint64_t v38 = -1LL;
      }
      else {
        uint64_t v38 = ((uint64_t)v36 << 6) | 0x10;
      }
      uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v38, a2);
      if (result)
      {
        *(void *)uint64_t result = 64LL;
        *(void *)(result + 8) = v37;
        result += 16LL;
        uint64_t v39 = result;
        do
        {
          *(void *)uint64_t v39 = off_18971B688;
          *(_WORD *)(v39 + 8) = 2;
          v39 += 64LL;
        }

        while (v39 != result + (v37 << 6));
      }

      *((void *)v7 + 9) = result;
      if (a3 >= 1)
      {
        unsigned int v40 = a3 + 1;
        do
        {
          uint64_t v41 = result + 64;
          icu::UnicodeString::operator=((UChar **)result, v6);
          --v40;
          uint64_t result = v41;
          v6 += 8;
        }

        while (v40 > 1);
      }

      uint64_t v19 = v7 + 20;
    }
  }

  *uint64_t v19 = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setWeekdays(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 19);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 19) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 40) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setShortWeekdays(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 21);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 21) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 44) = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setWeekdays(uint64_t result, unint64_t a2, int a3, int a4, int a5)
{
  uint64_t v6 = (UChar **)a2;
  uint64_t v7 = (int *)result;
  if (a4 == 1)
  {
    switch(a5)
    {
      case 0:
        uint64_t v20 = *(void **)(result + 232);
        if (v20)
        {
          uint64_t v21 = (char *)(v20 - 2);
          uint64_t v22 = *(v20 - 1);
          if (v22)
          {
            uint64_t v23 = v22 << 6;
            uint64_t v24 = (char *)(v20 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v24[v23]);
              v23 -= 64LL;
            }

            while (v23);
          }

          icu::UMemory::operator delete[](v21);
        }

        else {
          int v25 = a3;
        }
        uint64_t v26 = v25;
        if (v25 < 0) {
          uint64_t v27 = -1LL;
        }
        else {
          uint64_t v27 = ((uint64_t)v25 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v27, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v26;
          result += 16LL;
          uint64_t v28 = result;
          do
          {
            *(void *)uint64_t v28 = off_18971B688;
            *(_WORD *)(v28 + 8) = 2;
            v28 += 64LL;
          }

          while (v28 != result + (v26 << 6));
        }

        *((void *)v7 + 29) = result;
        if (a3 >= 1)
        {
          unsigned int v29 = a3 + 1;
          do
          {
            uint64_t v30 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v29;
            uint64_t result = v30;
            v6 += 8;
          }

          while (v29 > 1);
        }

        uint64_t v19 = v7 + 60;
        goto LABEL_149;
      case 1:
        uint64_t v64 = *(void **)(result + 216);
        if (v64)
        {
          uint64_t v65 = (char *)(v64 - 2);
          uint64_t v66 = *(v64 - 1);
          if (v66)
          {
            uint64_t v67 = v66 << 6;
            uint64_t v68 = (char *)(v64 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v64, (icu::UnicodeString *)&v68[v67]);
              v67 -= 64LL;
            }

            while (v67);
          }

          icu::UMemory::operator delete[](v65);
        }

        else {
          int v69 = a3;
        }
        uint64_t v70 = v69;
        if (v69 < 0) {
          uint64_t v71 = -1LL;
        }
        else {
          uint64_t v71 = ((uint64_t)v69 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v71, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v70;
          result += 16LL;
          uint64_t v72 = result;
          do
          {
            *(void *)uint64_t v72 = off_18971B688;
            *(_WORD *)(v72 + 8) = 2;
            v72 += 64LL;
          }

          while (v72 != result + (v70 << 6));
        }

        *((void *)v7 + 27) = result;
        if (a3 >= 1)
        {
          unsigned int v73 = a3 + 1;
          do
          {
            uint64_t v74 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v73;
            uint64_t result = v74;
            v6 += 8;
          }

          while (v73 > 1);
        }

        uint64_t v19 = v7 + 56;
        goto LABEL_149;
      case 2:
        uint64_t v75 = *(void **)(result + 264);
        if (v75)
        {
          char v76 = (char *)(v75 - 2);
          uint64_t v77 = *(v75 - 1);
          if (v77)
          {
            uint64_t v78 = v77 << 6;
            uint64_t v79 = (char *)(v75 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v75, (icu::UnicodeString *)&v79[v78]);
              v78 -= 64LL;
            }

            while (v78);
          }

          icu::UMemory::operator delete[](v76);
        }

        else {
          int v80 = a3;
        }
        uint64_t v81 = v80;
        if (v80 < 0) {
          uint64_t v82 = -1LL;
        }
        else {
          uint64_t v82 = ((uint64_t)v80 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v82, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v81;
          result += 16LL;
          uint64_t v83 = result;
          do
          {
            *(void *)uint64_t v83 = off_18971B688;
            *(_WORD *)(v83 + 8) = 2;
            v83 += 64LL;
          }

          while (v83 != result + (v81 << 6));
        }

        *((void *)v7 + 33) = result;
        if (a3 >= 1)
        {
          unsigned int v84 = a3 + 1;
          do
          {
            uint64_t v85 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v84;
            uint64_t result = v85;
            v6 += 8;
          }

          while (v84 > 1);
        }

        uint64_t v19 = v7 + 68;
        goto LABEL_149;
      case 3:
        uint64_t v86 = *(void **)(result + 248);
        if (v86)
        {
          char v87 = (char *)(v86 - 2);
          uint64_t v88 = *(v86 - 1);
          if (v88)
          {
            uint64_t v89 = v88 << 6;
            uint64_t v90 = (char *)(v86 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v86, (icu::UnicodeString *)&v90[v89]);
              v89 -= 64LL;
            }

            while (v89);
          }

          icu::UMemory::operator delete[](v87);
        }

        else {
          int v91 = a3;
        }
        uint64_t v92 = v91;
        if (v91 < 0) {
          uint64_t v93 = -1LL;
        }
        else {
          uint64_t v93 = ((uint64_t)v91 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v93, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v92;
          result += 16LL;
          uint64_t v94 = result;
          do
          {
            *(void *)uint64_t v94 = off_18971B688;
            *(_WORD *)(v94 + 8) = 2;
            v94 += 64LL;
          }

          while (v94 != result + (v92 << 6));
        }

        *((void *)v7 + 31) = result;
        if (a3 >= 1)
        {
          unsigned int v95 = a3 + 1;
          do
          {
            uint64_t v96 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v95;
            uint64_t result = v96;
            v6 += 8;
          }

          while (v95 > 1);
        }

        uint64_t v19 = v7 + 64;
LABEL_149:
        *uint64_t v19 = a3;
        break;
      default:
        return result;
    }
  }

  else if (!a4)
  {
    switch(a5)
    {
      case 0:
        uint64_t v8 = *(void **)(result + 168);
        if (v8)
        {
          uint64_t v9 = (char *)(v8 - 2);
          uint64_t v10 = *(v8 - 1);
          if (v10)
          {
            uint64_t v11 = v10 << 6;
            uint64_t v12 = (char *)(v8 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v12[v11]);
              v11 -= 64LL;
            }

            while (v11);
          }

          icu::UMemory::operator delete[](v9);
        }

        else {
          int v13 = a3;
        }
        uint64_t v14 = v13;
        if (v13 < 0) {
          uint64_t v15 = -1LL;
        }
        else {
          uint64_t v15 = ((uint64_t)v13 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v15, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v14;
          result += 16LL;
          uint64_t v16 = result;
          do
          {
            *(void *)uint64_t v16 = off_18971B688;
            *(_WORD *)(v16 + 8) = 2;
            v16 += 64LL;
          }

          while (v16 != result + (v14 << 6));
        }

        *((void *)v7 + 21) = result;
        if (a3 >= 1)
        {
          unsigned int v17 = a3 + 1;
          do
          {
            uint64_t v18 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v17;
            uint64_t result = v18;
            v6 += 8;
          }

          while (v17 > 1);
        }

        uint64_t v19 = v7 + 44;
        goto LABEL_149;
      case 1:
        uint64_t v31 = *(void **)(result + 152);
        if (v31)
        {
          int v32 = (char *)(v31 - 2);
          uint64_t v33 = *(v31 - 1);
          if (v33)
          {
            uint64_t v34 = v33 << 6;
            uint64_t v35 = (char *)(v31 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)&v35[v34]);
              v34 -= 64LL;
            }

            while (v34);
          }

          icu::UMemory::operator delete[](v32);
        }

        else {
          int v36 = a3;
        }
        uint64_t v37 = v36;
        if (v36 < 0) {
          uint64_t v38 = -1LL;
        }
        else {
          uint64_t v38 = ((uint64_t)v36 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v38, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v37;
          result += 16LL;
          uint64_t v39 = result;
          do
          {
            *(void *)uint64_t v39 = off_18971B688;
            *(_WORD *)(v39 + 8) = 2;
            v39 += 64LL;
          }

          while (v39 != result + (v37 << 6));
        }

        *((void *)v7 + 19) = result;
        if (a3 >= 1)
        {
          unsigned int v40 = a3 + 1;
          do
          {
            uint64_t v41 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v40;
            uint64_t result = v41;
            v6 += 8;
          }

          while (v40 > 1);
        }

        uint64_t v19 = v7 + 40;
        goto LABEL_149;
      case 2:
        uint64_t v42 = *(void **)(result + 200);
        if (v42)
        {
          uint64_t v43 = (char *)(v42 - 2);
          uint64_t v44 = *(v42 - 1);
          if (v44)
          {
            uint64_t v45 = v44 << 6;
            double v46 = (char *)(v42 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v42, (icu::UnicodeString *)&v46[v45]);
              v45 -= 64LL;
            }

            while (v45);
          }

          icu::UMemory::operator delete[](v43);
        }

        else {
          int v47 = a3;
        }
        uint64_t v48 = v47;
        if (v47 < 0) {
          uint64_t v49 = -1LL;
        }
        else {
          uint64_t v49 = ((uint64_t)v47 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v49, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v48;
          result += 16LL;
          uint64_t v50 = result;
          do
          {
            *(void *)uint64_t v50 = off_18971B688;
            *(_WORD *)(v50 + 8) = 2;
            v50 += 64LL;
          }

          while (v50 != result + (v48 << 6));
        }

        *((void *)v7 + 25) = result;
        if (a3 >= 1)
        {
          unsigned int v51 = a3 + 1;
          do
          {
            uint64_t v52 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v51;
            uint64_t result = v52;
            v6 += 8;
          }

          while (v51 > 1);
        }

        uint64_t v19 = v7 + 52;
        goto LABEL_149;
      case 3:
        uint64_t v53 = *(void **)(result + 184);
        if (v53)
        {
          uint64_t v54 = (char *)(v53 - 2);
          uint64_t v55 = *(v53 - 1);
          if (v55)
          {
            uint64_t v56 = v55 << 6;
            char v57 = (char *)(v53 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v53, (icu::UnicodeString *)&v57[v56]);
              v56 -= 64LL;
            }

            while (v56);
          }

          icu::UMemory::operator delete[](v54);
        }

        else {
          int v58 = a3;
        }
        uint64_t v59 = v58;
        if (v58 < 0) {
          uint64_t v60 = -1LL;
        }
        else {
          uint64_t v60 = ((uint64_t)v58 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v60, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v59;
          result += 16LL;
          uint64_t v61 = result;
          do
          {
            *(void *)uint64_t v61 = off_18971B688;
            *(_WORD *)(v61 + 8) = 2;
            v61 += 64LL;
          }

          while (v61 != result + (v59 << 6));
        }

        *((void *)v7 + 23) = result;
        if (a3 >= 1)
        {
          unsigned int v62 = a3 + 1;
          do
          {
            uint64_t v63 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v62;
            uint64_t result = v63;
            v6 += 8;
          }

          while (v62 > 1);
        }

        uint64_t v19 = v7 + 48;
        goto LABEL_149;
      default:
        return result;
    }
  }

  return result;
}

uint64_t icu::DateFormatSymbols::setQuarters(uint64_t result, unint64_t a2, int a3, int a4, int a5)
{
  uint64_t v6 = (UChar **)a2;
  uint64_t v7 = (int *)result;
  if (a4 == 1)
  {
    if (a5)
    {
      if (a5 == 2)
      {
        uint64_t v64 = *(void **)(result + 456);
        if (v64)
        {
          uint64_t v65 = (char *)(v64 - 2);
          uint64_t v66 = *(v64 - 1);
          if (v66)
          {
            uint64_t v67 = v66 << 6;
            uint64_t v68 = (char *)(v64 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v64, (icu::UnicodeString *)&v68[v67]);
              v67 -= 64LL;
            }

            while (v67);
          }

          icu::UMemory::operator delete[](v65);
        }

        else {
          int v69 = a3;
        }
        uint64_t v70 = v69;
        if (v69 < 0) {
          uint64_t v71 = -1LL;
        }
        else {
          uint64_t v71 = ((uint64_t)v69 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v71, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v70;
          result += 16LL;
          uint64_t v72 = result;
          do
          {
            *(void *)uint64_t v72 = off_18971B688;
            *(_WORD *)(v72 + 8) = 2;
            v72 += 64LL;
          }

          while (v72 != result + (v70 << 6));
        }

        *((void *)v7 + 57) = result;
        if (a3 >= 1)
        {
          unsigned int v73 = a3 + 1;
          do
          {
            uint64_t v74 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v73;
            uint64_t result = v74;
            v6 += 8;
          }

          while (v73 > 1);
        }

        uint64_t v19 = v7 + 116;
      }

      else
      {
        if (a5 != 1) {
          return result;
        }
        uint64_t v20 = *(void **)(result + 424);
        if (v20)
        {
          uint64_t v21 = (char *)(v20 - 2);
          uint64_t v22 = *(v20 - 1);
          if (v22)
          {
            uint64_t v23 = v22 << 6;
            uint64_t v24 = (char *)(v20 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v24[v23]);
              v23 -= 64LL;
            }

            while (v23);
          }

          icu::UMemory::operator delete[](v21);
        }

        else {
          int v25 = a3;
        }
        uint64_t v26 = v25;
        if (v25 < 0) {
          uint64_t v27 = -1LL;
        }
        else {
          uint64_t v27 = ((uint64_t)v25 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v27, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v26;
          result += 16LL;
          uint64_t v28 = result;
          do
          {
            *(void *)uint64_t v28 = off_18971B688;
            *(_WORD *)(v28 + 8) = 2;
            v28 += 64LL;
          }

          while (v28 != result + (v26 << 6));
        }

        *((void *)v7 + 53) = result;
        if (a3 >= 1)
        {
          unsigned int v29 = a3 + 1;
          do
          {
            uint64_t v30 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v29;
            uint64_t result = v30;
            v6 += 8;
          }

          while (v29 > 1);
        }

        uint64_t v19 = v7 + 108;
      }
    }

    else
    {
      uint64_t v53 = *(void **)(result + 440);
      if (v53)
      {
        uint64_t v54 = (char *)(v53 - 2);
        uint64_t v55 = *(v53 - 1);
        if (v55)
        {
          uint64_t v56 = v55 << 6;
          char v57 = (char *)(v53 - 8);
          do
          {
            icu::UnicodeString::~UnicodeString(v53, (icu::UnicodeString *)&v57[v56]);
            v56 -= 64LL;
          }

          while (v56);
        }

        icu::UMemory::operator delete[](v54);
      }

      else {
        int v58 = a3;
      }
      uint64_t v59 = v58;
      if (v58 < 0) {
        uint64_t v60 = -1LL;
      }
      else {
        uint64_t v60 = ((uint64_t)v58 << 6) | 0x10;
      }
      uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v60, a2);
      if (result)
      {
        *(void *)uint64_t result = 64LL;
        *(void *)(result + 8) = v59;
        result += 16LL;
        uint64_t v61 = result;
        do
        {
          *(void *)uint64_t v61 = off_18971B688;
          *(_WORD *)(v61 + 8) = 2;
          v61 += 64LL;
        }

        while (v61 != result + (v59 << 6));
      }

      *((void *)v7 + 55) = result;
      if (a3 >= 1)
      {
        unsigned int v62 = a3 + 1;
        do
        {
          uint64_t v63 = result + 64;
          icu::UnicodeString::operator=((UChar **)result, v6);
          --v62;
          uint64_t result = v63;
          v6 += 8;
        }

        while (v62 > 1);
      }

      uint64_t v19 = v7 + 112;
    }
  }

  else
  {
    if (a4) {
      return result;
    }
    if (a5)
    {
      if (a5 == 2)
      {
        uint64_t v42 = *(void **)(result + 408);
        if (v42)
        {
          uint64_t v43 = (char *)(v42 - 2);
          uint64_t v44 = *(v42 - 1);
          if (v44)
          {
            uint64_t v45 = v44 << 6;
            double v46 = (char *)(v42 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v42, (icu::UnicodeString *)&v46[v45]);
              v45 -= 64LL;
            }

            while (v45);
          }

          icu::UMemory::operator delete[](v43);
        }

        else {
          int v47 = a3;
        }
        uint64_t v48 = v47;
        if (v47 < 0) {
          uint64_t v49 = -1LL;
        }
        else {
          uint64_t v49 = ((uint64_t)v47 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v49, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v48;
          result += 16LL;
          uint64_t v50 = result;
          do
          {
            *(void *)uint64_t v50 = off_18971B688;
            *(_WORD *)(v50 + 8) = 2;
            v50 += 64LL;
          }

          while (v50 != result + (v48 << 6));
        }

        *((void *)v7 + 51) = result;
        if (a3 >= 1)
        {
          unsigned int v51 = a3 + 1;
          do
          {
            uint64_t v52 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v51;
            uint64_t result = v52;
            v6 += 8;
          }

          while (v51 > 1);
        }

        uint64_t v19 = v7 + 104;
      }

      else
      {
        if (a5 != 1) {
          return result;
        }
        uint64_t v8 = *(void **)(result + 376);
        if (v8)
        {
          uint64_t v9 = (char *)(v8 - 2);
          uint64_t v10 = *(v8 - 1);
          if (v10)
          {
            uint64_t v11 = v10 << 6;
            uint64_t v12 = (char *)(v8 - 8);
            do
            {
              icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v12[v11]);
              v11 -= 64LL;
            }

            while (v11);
          }

          icu::UMemory::operator delete[](v9);
        }

        else {
          int v13 = a3;
        }
        uint64_t v14 = v13;
        if (v13 < 0) {
          uint64_t v15 = -1LL;
        }
        else {
          uint64_t v15 = ((uint64_t)v13 << 6) | 0x10;
        }
        uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v15, a2);
        if (result)
        {
          *(void *)uint64_t result = 64LL;
          *(void *)(result + 8) = v14;
          result += 16LL;
          uint64_t v16 = result;
          do
          {
            *(void *)uint64_t v16 = off_18971B688;
            *(_WORD *)(v16 + 8) = 2;
            v16 += 64LL;
          }

          while (v16 != result + (v14 << 6));
        }

        *((void *)v7 + 47) = result;
        if (a3 >= 1)
        {
          unsigned int v17 = a3 + 1;
          do
          {
            uint64_t v18 = result + 64;
            icu::UnicodeString::operator=((UChar **)result, v6);
            --v17;
            uint64_t result = v18;
            v6 += 8;
          }

          while (v17 > 1);
        }

        uint64_t v19 = v7 + 96;
      }
    }

    else
    {
      uint64_t v31 = *(void **)(result + 392);
      if (v31)
      {
        int v32 = (char *)(v31 - 2);
        uint64_t v33 = *(v31 - 1);
        if (v33)
        {
          uint64_t v34 = v33 << 6;
          uint64_t v35 = (char *)(v31 - 8);
          do
          {
            icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)&v35[v34]);
            v34 -= 64LL;
          }

          while (v34);
        }

        icu::UMemory::operator delete[](v32);
      }

      else {
        int v36 = a3;
      }
      uint64_t v37 = v36;
      if (v36 < 0) {
        uint64_t v38 = -1LL;
      }
      else {
        uint64_t v38 = ((uint64_t)v36 << 6) | 0x10;
      }
      uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v38, a2);
      if (result)
      {
        *(void *)uint64_t result = 64LL;
        *(void *)(result + 8) = v37;
        result += 16LL;
        uint64_t v39 = result;
        do
        {
          *(void *)uint64_t v39 = off_18971B688;
          *(_WORD *)(v39 + 8) = 2;
          v39 += 64LL;
        }

        while (v39 != result + (v37 << 6));
      }

      *((void *)v7 + 49) = result;
      if (a3 >= 1)
      {
        unsigned int v40 = a3 + 1;
        do
        {
          uint64_t v41 = result + 64;
          icu::UnicodeString::operator=((UChar **)result, v6);
          --v40;
          uint64_t result = v41;
          v6 += 8;
        }

        while (v40 > 1);
      }

      uint64_t v19 = v7 + 100;
    }
  }

  *uint64_t v19 = a3;
  return result;
}

uint64_t icu::DateFormatSymbols::setAmPmStrings(icu::DateFormatSymbols *this, UChar **a2, int a3)
{
  BOOL v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 35);
  if (v6)
  {
    uint64_t v7 = (char *)(v6 - 2);
    uint64_t v8 = *(v6 - 1);
    if (v8)
    {
      uint64_t v9 = v8 << 6;
      uint64_t v10 = (char *)(v6 - 8);
      do
      {
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v10[v9]);
        v9 -= 64LL;
      }

      while (v9);
    }

    icu::UMemory::operator delete[](v7);
  }

  else {
    int v11 = a3;
  }
  uint64_t v12 = v11;
  if (v11 < 0) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = ((uint64_t)v11 << 6) | 0x10;
  }
  uint64_t result = icu::UMemory::operator new[]((icu::UMemory *)v13, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = 64LL;
    *(void *)(result + 8) = v12;
    result += 16LL;
    uint64_t v15 = result;
    do
    {
      *(void *)uint64_t v15 = off_18971B688;
      *(_WORD *)(v15 + 8) = 2;
      v15 += 64LL;
    }

    while (v15 != result + (v12 << 6));
  }

  *((void *)this + 35) = result;
  if (a3 >= 1)
  {
    unsigned int v16 = a3 + 1;
    do
    {
      uint64_t v17 = result + 64;
      icu::UnicodeString::operator=((UChar **)result, v4);
      --v16;
      uint64_t result = v17;
      v4 += 8;
    }

    while (v16 > 1);
  }

  *((_DWORD *)this + 72) = a3;
  return result;
}

icu::UnicodeString *icu::DateFormatSymbols::setTimeSeparatorString(UChar **this, UChar **a2)
{
  return icu::UnicodeString::operator=(this + 39, a2);
}

uint64_t icu::DateFormatSymbols::getZoneStrings(icu::DateFormatSymbols *this, int *a2, int *a3)
{
  uint64_t v6 = *((void *)this + 65);
  if (!v6)
  {
    uint64_t v6 = *((void *)this + 66);
    if (!v6)
    {
      icu::DateFormatSymbols::initZoneStringsArray((uint64_t)this);
      uint64_t v6 = *((void *)this + 66);
    }
  }

  *a2 = *((_DWORD *)this + 134);
  *a3 = *((_DWORD *)this + 135);
  umtx_unlock((std::mutex **)&unk_18C535310);
  return v6;
}

uint64_t icu::DateFormatSymbols::initZoneStringsArray(uint64_t this)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!*(void *)(this + 520))
  {
    uint64_t v1 = this;
    if (!*(void *)(this + 528))
    {
      int v29 = 0;
      uint64_t v2 = icu::TimeZone::createTimeZoneIDEnumeration(0LL, 0LL, 0LL, &v29);
      int v3 = (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 32LL))(v2, &v29);
      int v4 = v3;
      int v5 = 0LL;
      if (v29 <= 0)
      {
        size_t v6 = 8 * v3;
        uint64_t v7 = uprv_malloc(v6);
        int v5 = v7;
        if (v7)
        {
          bzero(v7, v6);
          uint64_t Instance = icu::TimeZoneNames::createInstance((icu::TimeZoneNames *)(v1 + 544), (const icu::Locale *)&v29, v8);
          uint64_t v10 = (icu::Calendar *)(*(uint64_t (**)(void *, int *))(*Instance + 104LL))(Instance, &v29);
          if (v29 > 0) {
            goto LABEL_23;
          }
          icu::Calendar::getNow(v10);
          double v12 = v11;
          __int128 v31 = 0u;
          __int128 v32 = 0u;
          uint64_t v34 = 0LL;
          __int128 v33 = 0u;
          uint64_t v30 = off_18971B688;
          LOWORD(v31) = 2;
          uint64_t v13 = (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 56LL))(v2, &v29);
          uint64_t v15 = v29;
          if (v13) {
            BOOL v16 = v29 <= 0;
          }
          else {
            BOOL v16 = 0;
          }
          if (v16)
          {
            uint64_t v17 = (UChar **)v13;
            uint64_t v18 = 0LL;
            while (1)
            {
              uint64_t v19 = (_OWORD *)icu::UMemory::operator new[]((icu::UMemory *)0x150, v14);
              if (!v19) {
                break;
              }
              uint64_t v20 = v19;
              *uint64_t v19 = xmmword_180A37A20;
              uint64_t v21 = (UChar **)(v19 + 1);
              uint64_t v22 = (UChar **)(v20 + 21);
              uint64_t v23 = v21;
              do
              {
                char *v23 = (UChar *)off_18971B688;
                *((_WORD *)v23 + 4) = 2;
                v23 += 8;
              }

              while (v23 != v22);
              v5[v18] = v21;
              icu::UnicodeString::copyFrom(v21, v17, 0);
              (*(void (**)(void *, UChar **, void *, uint64_t, uint64_t, int *, double))(*Instance + 112LL))( Instance,  v17,  &unk_180A37A64,  4LL,  v5[v18++] + 64LL,  &v29,  v12);
              uint64_t v17 = (UChar **)(*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 56LL))(v2, &v29);
              uint64_t v15 = v29;
              if (v17) {
                BOOL v24 = v29 < 1;
              }
              else {
                BOOL v24 = 0;
              }
              if (!v24) {
                goto LABEL_22;
              }
            }

            v5[v18] = 0LL;
            uint64_t v15 = 7LL;
            int v29 = 7;
          }

void icu::DateFormatSymbols::setZoneStrings( icu::DateFormatSymbols *this, const icu::UnicodeString *const *a2, int a3, int a4)
{
  *((_DWORD *)this + 134) = a3;
  *((_DWORD *)this + 135) = a4;
  icu::DateFormatSymbols::createZoneStrings(this, a2);
}

const __int16 *icu::DateFormatSymbols::getPatternUChars(icu::DateFormatSymbols *this)
{
  return L"GyMdkHmsSEDFwWahKzYeugAZvcLQqVUOXxrbB";
}

uint64_t icu::DateFormatSymbols::getPatternCharIndex(UChar c)
{
  uint64_t v1 = u_strchr((const UChar *)L"GyMdkHmsSEDFwWahKzYeugAZvcLQqVUOXxrbB", c);
  if (v1) {
    return ((unint64_t)((char *)v1 - (char *)L"GyMdkHmsSEDFwWahKzYeugAZvcLQqVUOXxrbB") >> 1);
  }
  else {
    return 38LL;
  }
}

uint64_t icu::DateFormatSymbols::isNumericField(int a1, int a2)
{
  BOOL v3 = ((1LL << a1) & 0x1E080004) != 0 && a2 < 3;
  unsigned int v4 = ((1LL << a1) & 0x40075BDFALL) != 0 || v3;
  if (a1 == 38) {
    return 0LL;
  }
  else {
    return v4;
  }
}

BOOL icu::DateFormatSymbols::isNumericPatternChar(UChar c, int a2)
{
  BOOL v3 = u_strchr((const UChar *)L"GyMdkHmsSEDFwWahKzYeugAZvcLQqVUOXxrbB", c);
  BOOL result = 0LL;
  if (v3)
  {
    unint64_t v5 = (char *)v3 - (char *)L"GyMdkHmsSEDFwWahKzYeugAZvcLQqVUOXxrbB";
    if ((v5 & 0x1FFFFFFFELL) != 0x4C)
    {
      BOOL result = 1LL;
      uint64_t v6 = 1LL << (v5 >> 1);
      if ((v6 & 0x40075BDFALL) == 0) {
        return (v6 & 0x1E080004) != 0 && a2 < 3;
      }
    }
  }

  return result;
}

icu::UnicodeString *icu::DateFormatSymbols::getLocalPatternChars(UChar **this, UChar **a2)
{
  return icu::UnicodeString::fastCopyFrom(a2, this + 96);
}

icu::UnicodeString *icu::DateFormatSymbols::setLocalPatternChars(UChar **this, UChar **a2)
{
  return icu::UnicodeString::operator=(this + 96, a2);
}

char *sub_1808DF378(char *result, unsigned int a2, uint64_t a3, void *a4, int *a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  unint64_t v5 = &result[64 * (unint64_t)a2];
  if ((*((_WORD *)v5 + 4) & 1) != 0) {
    __int16 v6 = 2;
  }
  else {
    __int16 v6 = *((_WORD *)v5 + 4) & 0x1F;
  }
  *((_WORD *)v5 + 4) = v6;
  if (*a5 <= 0)
  {
    memset(v16, 0, sizeof(v16));
    icu::UnicodeString::UnicodeString(v16, *a4, 0xFFFFFFFFLL, 0LL);
    uint64_t v9 = uhash_get(*(void *)(a3 + 184), (uint64_t)v16);
    if (v9)
    {
      uint64_t v10 = (uint64_t *)v9;
      memset(v15, 0, sizeof(v15));
      unint64_t v14 = &aLocaleCalendar[81];
      icu::UnicodeString::UnicodeString(v15, 0LL, &v14);
      double v11 = (UChar **)uhash_get(*v10, (uint64_t)v15);
      if (v11) {
        icu::UnicodeString::fastCopyFrom((UChar **)v5, v11);
      }
      else {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)v5);
      }
      icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v15);
    }

    else
    {
      uint64_t v13 = 2LL;
      *a5 = 2;
    }

    return (char *)icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)v16);
  }

  return result;
}

icu::CharString *sub_1808DF4B0( icu::CharString *a1, const char *a2, const char *a3, const char *a4, UErrorCode *a5)
{
  uint64_t v7 = sub_1808DF7F0(a1, a2, a3, a5);
  uint64_t v8 = icu::CharString::append(v7, 47, a5);
  return icu::CharString::append(v8, a4, -1, a5);
}

uint64_t *sub_1808DF4F0(uint64_t *result, _DWORD *a2, uint64_t a3, void *a4, int *a5)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (*a5 <= 0)
  {
    uint64_t v8 = result;
    memset(v12, 0, sizeof(v12));
    icu::UnicodeString::UnicodeString(v12, *a4, 0xFFFFFFFFLL, 0LL);
    uint64_t v9 = uhash_get(*(void *)(a3 + 8), (uint64_t)v12);
    if (v9)
    {
      uint64_t v10 = v9;
      *a2 = uhash_geti(*(void *)(a3 + 96), (uint64_t)v12);
      *uint64_t v8 = v10;
      uhash_remove(*(void *)(a3 + 8), v12);
    }

    else
    {
      *a2 = 0;
      uint64_t v11 = 2LL;
      *a5 = 2;
    }

    return (uint64_t *)icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)v12);
  }

  return result;
}

icu::CharString *sub_1808DF5D4(icu::CharString *a1, const char *a2, UErrorCode *a3)
{
  unsigned int v4 = sub_1808DF4B0(a1, "cyclicNameSets", a2, "format", a3);
  unint64_t v5 = icu::CharString::append(v4, 47, a3);
  return icu::CharString::append(v5, "abbreviated", -1, a3);
}

_OWORD *sub_1808DF628(uint64_t a1, void *a2, _DWORD *a3, int *a4)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (*a4 > 0) {
    return 0LL;
  }
  memset(v21, 0, sizeof(v21));
  icu::UnicodeString::UnicodeString(v21, *a2, 0xFFFFFFFFLL, 0LL);
  uint64_t v8 = (uint64_t *)uhash_get(*(void *)(a1 + 184), (uint64_t)v21);
  *a3 = 10;
  uint64_t v10 = (_OWORD *)icu::UMemory::operator new[]((icu::UMemory *)0x290, v9);
  if (v10)
  {
    *uint64_t v10 = xmmword_180A37A30;
    unsigned int v4 = v10 + 1;
    uint64_t v11 = v10 + 1;
    do
    {
      *(void *)uint64_t v11 = off_18971B688;
      *((_WORD *)v11 + 4) = 2;
      v11 += 4;
    }

    while (v11 != v10 + 41);
    uint64_t v12 = *a3;
    if (v8)
    {
      if ((int)v12 >= 1)
      {
        uint64_t v13 = 0LL;
        unint64_t v14 = (UChar **)(v10 + 1);
        do
        {
          memset(v20, 0, sizeof(v20));
          icu::UnicodeString::UnicodeString(v20, off_189722D90[v13], 0xFFFFFFFFLL, 0LL);
          uint64_t v15 = (UChar **)uhash_get(*v8, (uint64_t)v20);
          if (v15) {
            icu::UnicodeString::fastCopyFrom(v14, v15);
          }
          else {
            icu::UnicodeString::setToBogus((icu::UnicodeString *)v14);
          }
          icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v20);
          ++v13;
          uint64_t v12 = (int)*a3;
          v14 += 8;
        }

        while (v13 < v12);
      }
    }

    else if ((int)v12 >= 1)
    {
      uint64_t v17 = 0LL;
      uint64_t v18 = (icu::UnicodeString *)(v10 + 1);
      do
      {
        icu::UnicodeString::setToBogus(v18);
        ++v17;
        uint64_t v12 = (int)*a3;
        uint64_t v18 = (icu::UnicodeString *)((char *)v18 + 64);
      }

      while (v17 < v12);
    }
  }

  else
  {
    unsigned int v4 = 0LL;
    uint64_t v12 = 7LL;
    *a4 = 7;
  }

  icu::UnicodeString::~UnicodeString((void *)v12, (icu::UnicodeString *)v21);
  return v4;
}

icu::CharString *sub_1808DF7F0(icu::CharString *a1, const char *a2, const char *a3, UErrorCode *a4)
{
  *((_DWORD *)a1 + 14) = 0;
  **(_BYTE **)a1 = 0;
  __int16 v6 = icu::CharString::append(a1, a2, -1, a4);
  uint64_t v7 = icu::CharString::append(v6, 47, a4);
  return icu::CharString::append(v7, a3, -1, a4);
}

uint64_t *sub_1808DF83C(uint64_t *result, _DWORD *a2, uint64_t a3, void *a4, int *a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*a5 <= 0)
  {
    uint64_t v8 = result;
    memset(v19, 0, sizeof(v19));
    icu::UnicodeString::UnicodeString(v19, *a4, 0xFFFFFFFFLL, 0LL);
    uint64_t v9 = uhash_get(*(void *)(a3 + 8), (uint64_t)v19);
    if (v9)
    {
      uint64_t v10 = (UChar **)v9;
      int v12 = uhash_geti(*(void *)(a3 + 96), (uint64_t)v19);
      signed int v13 = v12 + 1;
      *a2 = v12 + 1;
      if (v12 < -1) {
        uint64_t v14 = -1LL;
      }
      else {
        uint64_t v14 = ((uint64_t)v13 << 6) | 0x10;
      }
      uint64_t v15 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v14, v11);
      if (v15)
      {
        *uint64_t v15 = 64LL;
        v15[1] = v13;
        uint64_t v16 = (uint64_t)(v15 + 2);
        if (v12 == -1)
        {
          *uint64_t v8 = v16;
        }

        else
        {
          uint64_t v17 = v15 + 2;
          do
          {
            *uint64_t v17 = off_18971B688;
            *((_WORD *)v17 + 4) = 2;
            v17 += 8;
          }

          while (v17 != (void *)(v16 + ((uint64_t)v13 << 6)));
          *uint64_t v8 = v16;
          if (v12 >= 1)
          {
            uint64_t v18 = (UChar **)(v15 + 10);
            do
            {
              icu::UnicodeString::operator=(v18, v10);
              --v13;
              v18 += 8;
              v10 += 8;
            }

            while (v13 > 1);
          }
        }

        return (uint64_t *)icu::UnicodeString::~UnicodeString((void *)v16, (icu::UnicodeString *)v19);
      }

      *uint64_t v8 = 0LL;
      uint64_t v16 = 7LL;
    }

    else
    {
      *a2 = 0;
      uint64_t v16 = 2LL;
    }

    *a5 = v16;
    return (uint64_t *)icu::UnicodeString::~UnicodeString((void *)v16, (icu::UnicodeString *)v19);
  }

  return result;
}

icu::UnicodeString *sub_1808DF9B8( icu::UnicodeString *result, unsigned int *a2, const UChar *a3, unsigned int a4, int a5, int *a6)
{
  if (*a6 <= 0)
  {
    uint64_t v10 = result;
    *a2 = a4;
    if (a4 <= 1) {
      uint64_t v11 = 1LL;
    }
    else {
      uint64_t v11 = a4;
    }
    BOOL result = (icu::UnicodeString *)icu::UMemory::operator new[]( (icu::UMemory *)((v11 << 6) | 0x10),  (unint64_t)a2);
    if (result)
    {
      *(void *)BOOL result = 64LL;
      *((void *)result + 1) = v11;
      int v12 = (_WORD *)((char *)result + 16);
      do
      {
        *(void *)int v12 = off_18971B688;
        _OWORD v12[4] = 2;
        v12 += 32;
      }

      while (v12 != (_WORD *)((char *)result + 64 * v11 + 16));
      *(void *)uint64_t v10 = (char *)result + 16;
      if ((int)*a2 >= 1)
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
        uint64_t v15 = 2LL * a5;
        do
        {
          uint64_t v16 = (icu::UnicodeString *)(*(void *)v10 + v13);
          uint64_t v17 = a3;
          BOOL result = icu::UnicodeString::setTo(v16, 1, &v17, -1);
          ++v14;
          a3 = (const UChar *)((char *)a3 + v15);
          v13 += 64LL;
        }

        while (v14 < (int)*a2);
      }
    }

    else
    {
      *(void *)uint64_t v10 = 0LL;
      *a2 = 0;
      *a6 = 7;
    }
  }

  return result;
}

void sub_1808DFAD8(uint64_t *a1)
{
  *a1 = (uint64_t)off_189722D58;
  uhash_setValueDeleter(a1[1], (uint64_t)sub_1808E1058);
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)(a1 + 67));
  uint64_t v4 = a1[66];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  icu::UnicodeString::~UnicodeString(v3, (icu::UnicodeString *)(a1 + 58));
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)(a1 + 50));
  icu::UVector::~UVector((icu::UVector *)(a1 + 45));
  sub_1808E10A8((uint64_t)(a1 + 34));
  __int16 v6 = (_BYTE *)a1[23];
  if (v6) {
    uhash_close(v6);
  }
  uint64_t v7 = (_BYTE *)a1[12];
  if (v7) {
    uhash_close(v7);
  }
  uint64_t v8 = (_BYTE *)a1[1];
  if (v8) {
    uhash_close(v8);
  }
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)a1);
}

uint64_t sub_1808DFB74(uint64_t a1, icu::UnicodeString **a2, const char *a3, UErrorCode *a4)
{
  *(void *)(a1 + 24) = off_189722C20;
  uint64_t v8 = (icu::DateFormatSymbols *)(a1 + 24);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_189722BF8;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 336) = off_18971B688;
  *(_WORD *)(a1 + 344) = 2;
  icu::Locale::Locale((icu::Locale *)(a1 + 568));
  *(void *)(a1 + 792) = off_18971B688;
  *(_WORD *)(a1 + 800) = 2;
  icu::DateFormatSymbols::initializeData(v8, a2, a3, a4, 0);
  return a1;
}

void sub_1808DFC18(uint64_t *a1)
{
}

void *sub_1808DFC2C(void *result, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  __s1 = a2;
  if (*a5 > 0) {
    return result;
  }
  unint64_t v5 = a5;
  uint64_t v7 = (uint64_t)result;
  uint64_t v85 = 0LL;
  memset(v84, 0, sizeof(v84));
  BOOL result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v84,  a3,  a5);
  if (*v5 > 0) {
    return result;
  }
  BOOL result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v84, 0, (const char **)&__s1, a3);
  uint64_t v77 = v5;
  int v80 = (uint64_t *)v7;
  if (!(_DWORD)result)
  {
    uint64_t v9 = 0LL;
LABEL_65:
    char v76 = v9;
    uint64_t v41 = (icu::UVector *)(v7 + 360);
    int v42 = *(_DWORD *)(v7 + 368);
LABEL_66:
    if (v42 < 1)
    {
LABEL_101:
      if (v76)
      {
        BOOL result = *(void **)(v7 + 528);
        if (result) {
          BOOL result = (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
        }
        *(void *)(v7 + 528) = v76;
      }

      return result;
    }

    signed int v43 = 0;
    int v44 = 0;
    while (1)
    {
      uint64_t v45 = icu::UVector::elementAt(v41, v43);
      uint64_t v46 = uhash_get(*(void *)(v7 + 8), v45);
      if (v46) {
        break;
      }
      BOOL result = (void *)uhash_get(*(void *)(v7 + 184), v45);
      if (result)
      {
        uint64_t v60 = (uint64_t)result;
        int v48 = v43 + 1;
        uint64_t v61 = (UChar **)icu::UVector::elementAt(v41, v43 + 1);
        BOOL result = (void *)uhash_get(*(void *)(v7 + 184), (uint64_t)v61);
        if (!result)
        {
          uint64_t v64 = *(void *)(v7 + 184);
          uint64_t v65 = (icu::UnicodeString *)icu::UMemory::operator new(v63, (icu::UMemory *)0x40, v62);
          uint64_t v66 = v65;
          if (v65) {
            icu::UnicodeString::UnicodeString(v65, v61);
          }
          uint64_t v67 = (uint64_t)v66;
          unint64_t v5 = v77;
          BOOL result = (void *)uhash_put(v64, v67, v60, v77);
          uint64_t v7 = (uint64_t)v80;
        }

        if (*v5 > 0) {
          goto LABEL_108;
        }
LABEL_97:
        icu::UVector::removeElementAt((uint64_t (**)(void))v41, v48);
        BOOL result = (void *)icu::UVector::removeElementAt((uint64_t (**)(void))v41, v43);
        int v44 = 1;
        goto LABEL_98;
      }

      v43 += 2;
LABEL_98:
      int v42 = *(_DWORD *)(v7 + 368);
      if (v43 >= v42)
      {
        if (v44 && v42) {
          goto LABEL_66;
        }
        goto LABEL_101;
      }
    }

    int v47 = (UChar **)v46;
    int v48 = v43 + 1;
    uint64_t v49 = icu::UVector::elementAt(v41, v43 + 1);
    BOOL result = (void *)uhash_get(*(void *)(v7 + 8), v49);
    if (!result)
    {
      int v50 = uhash_geti(*(void *)(v7 + 96), v45);
      *(void *)&v87[0] = 0LL;
      uint64_t v52 = v50;
      if (v50 < 0) {
        uint64_t v53 = -1LL;
      }
      else {
        uint64_t v53 = ((uint64_t)v50 << 6) | 0x10;
      }
      uint64_t v54 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v53, v51);
      if (!v54)
      {
        *(void *)&v87[0] = 0LL;
        if (*v5 <= 0) {
          *unint64_t v5 = 7;
        }
LABEL_107:
        BOOL result = sub_1807CCEEC((uint64_t *)v87);
LABEL_108:
        uint64_t v9 = v76;
        if (!v76) {
          return result;
        }
        return (void *)(*(uint64_t (**)(uint64_t *))(*v9 + 8))(v9);
      }

      uint64_t v79 = (UChar **)v49;
      *uint64_t v54 = 64LL;
      v54[1] = v52;
      uint64_t v56 = (UChar **)(v54 + 2);
      if ((_DWORD)v52)
      {
        char v57 = (UChar **)(v54 + 2);
        do
        {
          *char v57 = (UChar *)off_18971B688;
          *((_WORD *)v57 + 4) = 2;
          v57 += 8;
        }

        while (v57 != &v56[8 * v52]);
        *(void *)&v87[0] = v54 + 2;
        int v58 = (uint64_t *)*v5;
        if ((int)v52 >= 1)
        {
          unsigned int v59 = v52 + 1;
          do
          {
            icu::UnicodeString::operator=(v56, v47);
            --v59;
            v56 += 8;
            v47 += 8;
          }

          while (v59 > 1);
          uint64_t v56 = *(UChar ***)&v87[0];
          unint64_t v5 = v77;
          uint64_t v7 = (uint64_t)v80;
        }
      }

      else
      {
        *(void *)&v87[0] = v54 + 2;
        int v58 = (uint64_t *)*v5;
      }

      *(void *)&v87[0] = 0LL;
      uint64_t v68 = *(void *)(v7 + 8);
      int v69 = (icu::UnicodeString *)icu::UMemory::operator new(v58, (icu::UMemory *)0x40, v55);
      uint64_t v70 = (uint64_t)v69;
      if (v69) {
        icu::UnicodeString::UnicodeString(v69, v79);
      }
      uhash_put(v68, v70, (uint64_t)v56, v5);
      uint64_t v71 = v80[12];
      unsigned int v73 = (icu::UnicodeString *)icu::UMemory::operator new(v80, (icu::UMemory *)0x40, v72);
      uint64_t v74 = v73;
      if (v73) {
        icu::UnicodeString::UnicodeString(v73, v79);
      }
      uint64_t v75 = (uint64_t)v74;
      unint64_t v5 = v77;
      uhash_puti(v71, v75, v52, v77);
      BOOL result = sub_1807CCEEC((uint64_t *)v87);
      uint64_t v7 = (uint64_t)v80;
    }

    if (*v5 >= 1) {
      goto LABEL_108;
    }
    goto LABEL_97;
  }

  int v8 = 0;
  uint64_t v9 = 0LL;
  uint64_t v10 = (UChar **)(v7 + 536);
  uint64_t v11 = (icu::UVector *)(v7 + 360);
  while (1)
  {
    memset(v87, 0, sizeof(v87));
    icu::UnicodeString::UnicodeString(v87, __s1, 0xFFFFFFFFLL, 0LL);
    int v12 = sub_1808E0444(v7, (uint64_t)v87, (uint64_t)a3, v5);
    uint64_t v14 = *v5;
    if (v12)
    {
      if (v12 != 2)
      {
        if (v12 == 1)
        {
          if (!v9)
          {
            uint64_t v15 = icu::UMemory::operator new((uint64_t *)v14, (icu::UMemory *)0x28, v13);
            if (!v15)
            {
              uint64_t v14 = *v5;
              uint64_t v9 = 0LL;
              if ((int)v14 <= 0)
              {
                uint64_t v14 = 7LL;
                *unint64_t v5 = 7;
              }

              break;
            }

            uint64_t v9 = v15;
            icu::UVector::UVector((uint64_t)v15, (uint64_t)uprv_deleteUObject, (uint64_t)uhash_compareUnicodeString, v5);
            uint64_t v14 = *v5;
            if ((int)v14 > 0)
            {
              (*(void (**)(uint64_t *))(*v9 + 8))(v9);
              uint64_t v9 = 0LL;
              uint64_t v14 = *v5;
            }
          }

          uint64_t v16 = icu::UnicodeString::clone(v10, v13, (uint64_t *)v14);
          if (!v16 && *v5 <= 0) {
            *unint64_t v5 = 7;
          }
          uint64_t v17 = (icu::UVector *)v9;
          goto LABEL_17;
        }

        uint64_t v21 = *(icu::UVector **)(v7 + 528);
        if (!v21
          || !*((_DWORD *)v21 + 2)
          || (icu::UVector::indexOf(v21, (uint64_t)v87, 0LL) & 0x80000000) == 0
          || !strcmp(__s1, "AmPmMarkersAbbr"))
        {
          uint64_t v22 = __s1;
          if (!strcmp(__s1, "AmPmMarkers") || !strcmp(v22, "AmPmMarkersAbbr") || !strcmp(v22, "AmPmMarkersNarrow"))
          {
            uint64_t v7 = (uint64_t)v80;
            if (!uhash_get(v80[1], (uint64_t)v87))
            {
              v82[0] = 0LL;
              v82[1] = 0LL;
              uint64_t v83 = 0LL;
              (*(void (**)(void *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 80LL))( v82,  a3,  v5);
              uint64_t v24 = (int)v83;
              uint64_t v81 = 0LL;
              int v25 = (icu::UMemory *)((int)v83 < 0 ? -1LL : ((uint64_t)(int)v83 << 6) | 0x10);
              uint64_t v26 = (void *)icu::UMemory::operator new[](v25, v23);
              uint64_t v78 = v11;
              if (v26)
              {
                *uint64_t v26 = 64LL;
                v26[1] = v24;
                uint64_t v27 = v26 + 2;
                if ((_DWORD)v24)
                {
                  uint64_t v28 = v26 + 2;
                  do
                  {
                    *uint64_t v28 = off_18971B688;
                    *((_WORD *)v28 + 4) = 2;
                    v28 += 8;
                  }

                  while (v28 != &v27[8 * v24]);
                }

                uint64_t v81 = v26 + 2;
              }

              else
              {
                uint64_t v27 = 0LL;
                uint64_t v81 = 0LL;
                if (*v5 <= 0)
                {
                  uint64_t v27 = 0LL;
                  *unint64_t v5 = 7;
                }
              }

              (*(void (**)(icu::ResourceValue *, void *, uint64_t, int *))(*(void *)a3 + 104LL))( a3,  v27,  v24,  v5);
              uint64_t v30 = (uint64_t)v81;
              uint64_t v81 = 0LL;
              uint64_t v31 = v80[1];
              __int128 v33 = (icu::UnicodeString *)icu::UMemory::operator new(v80, (icu::UMemory *)0x40, v32);
              uint64_t v34 = v33;
              if (v33) {
                icu::UnicodeString::UnicodeString(v33, (UChar **)v87);
              }
              uint64_t v35 = (uint64_t)v34;
              unint64_t v5 = v77;
              uhash_put(v31, v35, v30, v77);
              uint64_t v36 = v80[12];
              uint64_t v38 = (icu::UnicodeString *)icu::UMemory::operator new(v80, (icu::UMemory *)0x40, v37);
              uint64_t v39 = (uint64_t)v38;
              if (v38) {
                icu::UnicodeString::UnicodeString(v38, (UChar **)v87);
              }
              uhash_puti(v36, v39, v24, v77);
              int v40 = *v77;
              sub_1807CCEEC((uint64_t *)&v81);
              uint64_t v11 = v78;
              uint64_t v7 = (uint64_t)v80;
              if (v40 >= 1) {
                break;
              }
            }
          }

          else if (!strcmp(v22, "eras") {
                 || !strcmp(v22, "dayNames")
          }
                 || !strcmp(v22, "monthNames")
                 || !strcmp(v22, "quarters")
                 || !strcmp(v22, "dayPeriod")
                 || !strcmp(v22, "monthPatterns")
                 || !strcmp(v22, "cyclicNameSets"))
          {
            int v29 = v22;
            uint64_t v7 = (uint64_t)v80;
            sub_1808E074C(v80, (uint64_t)v87, v29, a3, v5);
          }

          else
          {
            uint64_t v7 = (uint64_t)v80;
          }
        }
      }
    }

    else if (!uhash_get(*(void *)(v7 + 8), (uint64_t)v10) && !uhash_get(*(void *)(v7 + 184), (uint64_t)v10))
    {
      uint64_t v19 = icu::UnicodeString::clone(v10, v18, (uint64_t *)v14);
      if (!v19 && *v5 <= 0) {
        *unint64_t v5 = 7;
      }
      icu::UVector::adoptElement(v11, v19, (UErrorCode *)v5);
      uint64_t v14 = *v5;
      uint64_t v16 = icu::UnicodeString::clone((UChar **)v87, v20, (uint64_t *)v14);
      if (!v16 && *v5 <= 0) {
        *unint64_t v5 = 7;
      }
      uint64_t v17 = v11;
LABEL_17:
      icu::UVector::adoptElement(v17, v16, (UErrorCode *)v5);
      uint64_t v14 = *v5;
    }

    icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)v87);
    BOOL result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v84, ++v8, (const char **)&__s1, a3);
    if (!(_DWORD)result) {
      goto LABEL_65;
    }
  }

  BOOL result = icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)v87);
  if (v9) {
    return (void *)(*(uint64_t (**)(uint64_t *))(*v9 + 8))(v9);
  }
  return result;
}

uint64_t sub_1808E0444(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (*a4 <= 0 && (*(unsigned int (**)(uint64_t))(*(void *)a3 + 24LL))(a3) == 3)
  {
    unsigned int v23 = 0;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, unsigned int *, int *))(*(void *)a3 + 40LL))(a3, &v23, a4);
    if (*a4 <= 0)
    {
      memset(v25, 0, sizeof(v25));
      icu::UnicodeString::UnicodeString((uint64_t)v25, v8, v23);
      int v11 = WORD4(v25[0]) >> 5;
      if (SWORD4(v25[0]) < 0) {
        int v11 = HIDWORD(v25[0]);
      }
      v21[1] = aLocaleCalendar;
      if (v11 < 18) {
        goto LABEL_31;
      }
      if (SWORD4(v25[0]) < 0)
      {
        unsigned int v12 = HIDWORD(v25[0]);
        int v13 = SHIDWORD(v25[0]) >= 17 ? 17 : HIDWORD(v25[0]);
      }

      else
      {
        unsigned int v12 = WORD4(v25[0]) >> 5;
        int v13 = v12 >= 0x11 ? 17 : WORD4(v25[0]) >> 5;
      }

      int v14 = icu::UnicodeString::doIndexOf((uint64_t)v25, 0x2Fu, v13, v12 - v13);
      if (v14 < 18) {
        goto LABEL_31;
      }
      int v15 = v14;
      memset(v24, 0, sizeof(v24));
      icu::UnicodeString::tempSubString((icu::UnicodeString *)v25, 17, v14 - 17, (icu::UnicodeString *)v24);
      if ((SWORD4(v25[0]) & 0x8000u) == 0) {
        uint64_t v16 = WORD4(v25[0]) >> 5;
      }
      else {
        uint64_t v16 = HIDWORD(v25[0]);
      }
      sub_1808E0E9C(a1 + 536, (const icu::UnicodeString *)v25, v15 + 1, v16);
      if (sub_1807FF934(a1 + 400, (uint64_t)v24) && (sub_18086B6D8(a2, a1 + 536) & 1) != 0)
      {
        uint64_t v9 = 0LL;
LABEL_36:
        icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v24);
        goto LABEL_32;
      }

      if (sub_18086B6D8(a1 + 400, (uint64_t)v24) && sub_1807FF934(a2, a1 + 536))
      {
        uint64_t v22 = aGregorian_2;
        int v18 = sub_1807C3C7C((uint64_t)v24, (uint64_t *)&v22, 9);
        v21[0] = v22;
        uint64_t v17 = v21;
        if (!v18)
        {
          uint64_t v9 = 2LL;
          goto LABEL_36;
        }

        uint64_t v19 = (UChar **)(a1 + 464);
        if ((*(_WORD *)(a1 + 472) & 1) != 0)
        {
          icu::UnicodeString::operator=(v19, (UChar **)v24);
        }

        else if (!sub_1807FF934((uint64_t)v19, (uint64_t)v24))
        {
          goto LABEL_30;
        }

        uint64_t v9 = 1LL;
        goto LABEL_36;
      }

uint64_t sub_1808E06E8@<X0>( uint64_t *a1@<X0>, UChar **a2@<X1>, unsigned int a3@<W2>, int *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v8 = *a1;
  uint64_t v9 = (icu::UnicodeString *)icu::UMemory::operator new(a5, (icu::UMemory *)0x40, (unint64_t)a2);
  uint64_t v10 = (uint64_t)v9;
  if (v9) {
    icu::UnicodeString::UnicodeString(v9, a2);
  }
  return uhash_puti(v8, v10, a3, a4);
}

void *sub_1808E074C(void *result, uint64_t a2, char *a3, icu::ResourceValue *a4, int *a5)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  uint64_t v74 = a3;
  if (*a5 > 0) {
    return result;
  }
  uint64_t v8 = (uint64_t)result;
  uint64_t v73 = 0LL;
  memset(v72, 0, sizeof(v72));
  BOOL result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a4 + 88LL))( v72,  a4,  a5);
  if (*a5 > 0) {
    return result;
  }
  BOOL result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v72, 0, (const char **)&v74, a4);
  if (!(_DWORD)result) {
    return result;
  }
  int v9 = 0;
  uint64_t v10 = 0LL;
  uint64_t v65 = (icu::UVector *)(v8 + 360);
  uint64_t v66 = (uint64_t *)(v8 + 8);
  while (1)
  {
    memset(v75, 0, sizeof(v75));
    icu::UnicodeString::UnicodeString(v75, v74, 0xFFFFFFFFLL, 0LL);
    int v11 = WORD4(v75[0]) >> 5;
    if (SWORD4(v75[0]) < 0) {
      int v11 = HIDWORD(v75[0]);
    }
    BOOL v12 = icu::UnicodeString::doEqualsSubstring((uint64_t)v75, v11 - 8, 8, (uint64_t)&aLocaleCalendar[17], 0, 8);
    v67[2] = &aLocaleCalendar[17];
    if (v12) {
      goto LABEL_67;
    }
    if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a4 + 24LL))(a4))
    {
      unsigned int v14 = *(unsigned __int16 *)(a2 + 8);
      int v15 = (__int16)v14;
      int v16 = v14 >> 5;
      if (v15 >= 0) {
        int v17 = v16;
      }
      else {
        int v17 = *(_DWORD *)(a2 + 12);
      }
      LOWORD(v69[0]) = 47;
      uint64_t v18 = icu::UnicodeString::doAppend(a2, (uint64_t)v69, 0, 1LL);
      if ((SWORD4(v75[0]) & 0x8000u) == 0) {
        uint64_t v19 = WORD4(v75[0]) >> 5;
      }
      else {
        uint64_t v19 = HIDWORD(v75[0]);
      }
      icu::UnicodeString::doAppend(v18, (const icu::UnicodeString *)v75, 0, v19);
      BOOL v20 = icu::UnicodeString::doEqualsSubstring(a2, 0, 14, (uint64_t)&aLocaleCalendar[25], 0, 14);
      v67[1] = &aLocaleCalendar[25];
      if (v20)
      {
        unsigned int v21 = *(unsigned __int16 *)(a2 + 8);
        int v22 = (__int16)v21;
        unsigned int v23 = v21 >> 5;
        if (v22 < 0) {
          unsigned int v23 = *(_DWORD *)(a2 + 12);
        }
        if (v23 == 14)
        {
          int v24 = 14;
        }

        else if (icu::UnicodeString::doCompare(a2, 14, 8, (uint64_t)&aLocaleCalendar[39], 0, 8))
        {
          if (icu::UnicodeString::doCompare(a2, 14, 6, (uint64_t)&aLocaleCalendar[47], 0, 6))
          {
            int v24 = 23;
          }

          else
          {
            int v24 = 20;
          }
        }

        else
        {
          int v24 = 22;
        }

        unsigned int v42 = *(unsigned __int16 *)(a2 + 8);
        int v43 = (__int16)v42;
        unsigned int v44 = v42 >> 5;
        unsigned int v45 = *(_DWORD *)(a2 + 12);
        int v46 = v43 >= 0 ? v44 : *(_DWORD *)(a2 + 12);
        if (v24 == v46)
        {
          int v47 = 0;
        }

        else
        {
          int v43 = *(unsigned __int16 *)(a2 + 8);
          unsigned int v45 = *(_DWORD *)(a2 + 12);
          unsigned int v44 = v43 >> 5;
          int v47 = 7;
        }

        int v48 = v47 + v24;
        int v49 = (v43 & 0x8000u) == 0 ? v44 : v45;
        if (v48 != v49
          && icu::UnicodeString::doCompare(a2, v48, 12, (uint64_t)&aLocaleCalendar[69], 0, 12))
        {
          goto LABEL_56;
        }
      }

      if (uhash_get(*v66, a2) || uhash_get(*(void *)(v8 + 184), a2))
      {
LABEL_56:
        unsigned int v50 = *(unsigned __int16 *)(a2 + 8);
        if (v17 || (v50 & 1) == 0)
        {
          if ((v50 & 0x8000u) == 0) {
            unsigned int v51 = v50 >> 5;
          }
          else {
            unsigned int v51 = *(_DWORD *)(a2 + 12);
          }
          if (v51 > v17)
          {
            if (v17 > 1023)
            {
              *(_WORD *)(a2 + 8) = v50 | 0xFFE0;
              *(_DWORD *)(a2 + 12) = v17;
            }

            else
            {
              *(_WORD *)(a2 + 8) = *(_WORD *)(a2 + 8) & 0x1F | (32 * v17);
            }
          }
        }

        else
        {
          icu::UnicodeString::unBogus(a2);
        }

        icu::UnicodeString::doReplace(a2, 0LL, 0LL, 0LL, 0, 0LL);
        goto LABEL_67;
      }

      int v52 = sub_1808E0444(v8, a2, (uint64_t)a4, a5);
      uint64_t v13 = *a5;
      if (v52)
      {
        if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a4 + 24LL))(a4) == 8)
        {
          v69[0] = 0LL;
          v69[1] = 0LL;
          uint64_t v70 = 0LL;
          (*(void (**)(void *__return_ptr, icu::ResourceValue *, int *))(*(void *)a4 + 80LL))( v69,  a4,  a5);
          uint64_t v55 = (int)v70;
          uint64_t v68 = 0LL;
          else {
            uint64_t v56 = ((uint64_t)(int)v70 << 6) | 0x10;
          }
          char v57 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v56, v54);
          if (v57)
          {
            *char v57 = 64LL;
            v57[1] = v55;
            int v58 = v57 + 2;
            if ((_DWORD)v55)
            {
              unsigned int v59 = v57 + 2;
              do
              {
                void *v59 = off_18971B688;
                *((_WORD *)v59 + 4) = 2;
                v59 += 8;
              }

              while (v59 != &v58[8 * v55]);
            }

            uint64_t v68 = v57 + 2;
          }

          else
          {
            int v58 = 0LL;
            uint64_t v68 = 0LL;
            if (*a5 <= 0)
            {
              int v58 = 0LL;
              *a5 = 7;
            }
          }

          (*(void (**)(icu::ResourceValue *, void *, uint64_t, int *))(*(void *)a4 + 104LL))( a4,  v58,  v55,  a5);
          uint64_t v62 = (uint64_t)v68;
          uint64_t v68 = 0LL;
          sub_1807C33C4(v66, (UChar **)a2, v62, a5);
          sub_1808E06E8((uint64_t *)(v8 + 96), (UChar **)a2, v55, a5, v63);
          int v64 = *a5;
          sub_1807CCEEC((uint64_t *)&v68);
          if (v64 >= 1) {
            return icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)v75);
          }
          goto LABEL_95;
        }

        if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a4 + 24LL))(a4) != 2)
        {
LABEL_95:
          sub_1807D7CF0((icu::UnicodeString *)a2, 0LL, v17);
          goto LABEL_67;
        }

        sub_1808E074C(v8, a2, v74, a4, a5);
      }

      else
      {
        uint64_t v60 = icu::UnicodeString::clone((UChar **)(v8 + 536), v53, (uint64_t *)v13);
        if (!v60 && *a5 <= 0) {
          *a5 = 7;
        }
        icu::UVector::adoptElement(v65, v60, (UErrorCode *)a5);
        uint64_t v13 = *a5;
        uint64_t v61 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 56LL))(a2);
        if (!v61 && *a5 <= 0) {
          *a5 = 7;
        }
        icu::UVector::adoptElement(v65, v61, (UErrorCode *)a5);
      }

      uint64_t v13 = *a5;
      goto LABEL_95;
    }

    if (!v9) {
      break;
    }
LABEL_27:
    LODWORD(v69[0]) = 0;
    uint64_t v31 = (*(uint64_t (**)(icu::ResourceValue *, void *, int *))(*(void *)a4 + 32LL))(a4, v69, a5);
    uint64_t v13 = *a5;
    uint64_t v33 = v31;
    uint64_t v34 = icu::UMemory::operator new((uint64_t *)v13, (icu::UMemory *)0x40, v32);
    uint64_t v36 = (uint64_t)v34;
    if (v34)
    {
      uint64_t v71 = v33;
      icu::UnicodeString::UnicodeString(v34, 1LL, &v71);
      v67[0] = v71;
      uint64_t v37 = (uint64_t)v67;
    }

    else
    {
      uint64_t v37 = *a5;
      if ((int)v37 <= 0)
      {
        uint64_t v37 = 7LL;
        *a5 = 7;
      }
    }

    uint64_t v38 = v10;
    uint64_t v39 = *v10;
    int v40 = (icu::UnicodeString *)icu::UMemory::operator new((uint64_t *)v37, (icu::UMemory *)0x40, v35);
    uint64_t v41 = (uint64_t)v40;
    if (v40) {
      icu::UnicodeString::UnicodeString(v40, (UChar **)v75);
    }
    uhash_put(v39, v41, v36, a5);
    uint64_t v13 = *a5;
    uint64_t v10 = v38;
LABEL_67:
    icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)v75);
    BOOL result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v72, ++v9, (const char **)&v74, a4);
    if (!(_DWORD)result) {
      return result;
    }
  }

  LOBYTE(v69[0]) = 0;
  int v25 = sub_1808E0EFC((unsigned int *)(v8 + 272), (unsigned __int8 *)v69, a5);
  if (v25)
  {
    uint64_t v10 = (uint64_t *)v25;
    uint64_t v28 = *(void *)(v8 + 184);
    int v29 = (icu::UnicodeString *)icu::UMemory::operator new(v27, (icu::UMemory *)0x40, v26);
    uint64_t v30 = (uint64_t)v29;
    if (v29) {
      icu::UnicodeString::UnicodeString(v29, (UChar **)a2);
    }
    uhash_put(v28, v30, (uint64_t)v10, a5);
    uint64_t v13 = *a5;
    uhash_setValueDeleter(*v10, (uint64_t)uprv_deleteUObject);
    goto LABEL_27;
  }

  uint64_t v13 = 7LL;
  *a5 = 7;
  return icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)v75);
}

uint64_t sub_1808E0E9C(uint64_t a1, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  else {
    uint64_t v8 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }
  return icu::UnicodeString::doReplace((icu::UnicodeString *)a1, 0LL, v8, a2, a3, a4);
}

int32x2_t *sub_1808E0EFC(unsigned int *a1, unsigned __int8 *a2, int *a3)
{
  int v6 = a1[4];
  uint64_t v7 = *a1;
  if ((_DWORD)v7 != v6)
  {
LABEL_16:
    BOOL v12 = (int32x2_t *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x58, (unint64_t)a2);
    uint64_t v10 = v12;
    if (v12)
    {
      int v13 = *a2;
      *BOOL v12 = 0LL;
      if (*a3 <= 0)
      {
        if (v13) {
          unsigned int v14 = uhash_compareCaselessUnicodeString;
        }
        else {
          unsigned int v14 = uhash_compareUnicodeString;
        }
        if (v13) {
          int v15 = uhash_hashCaselessUnicodeString;
        }
        else {
          int v15 = uhash_hashUnicodeString;
        }
        int v16 = v12 + 1;
        uhash_init(v12 + 1, (uint64_t)v15, (uint64_t)v14, 0LL, a3);
        if (*a3 <= 0)
        {
          *uint64_t v10 = (int32x2_t)v16;
          uhash_setKeyDeleter((uint64_t)&v10[1], (uint64_t)uprv_deleteUObject);
        }
      }
    }

    uint64_t v17 = (int)*a1;
    *a1 = v17 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v17) = v10;
    return v10;
  }

  if (v6 == 8) {
    int v8 = 32;
  }
  else {
    int v8 = 2 * v6;
  }
  if (v8 < 1) {
    return 0LL;
  }
  int v9 = (int32x2_t *)uprv_malloc(8LL * v8);
  uint64_t v10 = v9;
  if (v9)
  {
    if (v6 >= 1)
    {
      int v11 = a1[4];
      if (v11 >= v6) {
        int v11 = v6;
      }
      if (v11 >= v8) {
        int v11 = v8;
      }
      memcpy(v9, *((const void **)a1 + 1), 8LL * v11);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v10;
    a1[4] = v8;
    uint64_t v7 = 1LL;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v10;
}

void sub_1808E1058(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = (void *)(a1 - 16);
    uint64_t v2 = *(void **)(a1 - 8);
    if (v2)
    {
      uint64_t v3 = (void)v2 << 6;
      uint64_t v4 = a1 - 64;
      do
      {
        icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)(v4 + v3));
        v3 -= 64LL;
      }

      while (v3);
    }

    icu::UMemory::operator delete[](v1);
  }

uint64_t sub_1808E10A8(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *(_BYTE ***)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        if (*v4) {
          uhash_close(*v4);
        }
        icu::UMemory::operator delete(v4);
        int v2 = *(_DWORD *)a1;
      }

      ++v3;
    }

    while (v3 < v2);
  }

  if (*(_BYTE *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1808E1120(uint64_t a1)
{
  *(void *)a1 = off_189722DF0;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
}

void sub_1808E1150(uint64_t a1)
{
  *(void *)a1 = off_189722DF0;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
  icu::UMemory::operator delete(v2);
}

uint64_t sub_1808E1184(uint64_t a1)
{
  int v2 = strlen((const char *)((unint64_t)"N3icu23SharedDateFormatSymbolsE" & 0x7FFFFFFFFFFFFFFFLL));
  unsigned int v3 = ustr_hashCharsN( (unsigned __int8 *)((unint64_t)"N3icu23SharedDateFormatSymbolsE" & 0x7FFFFFFFFFFFFFFFLL),  v2);
  return icu::Locale::hashCode((icu::Locale *)(a1 + 16)) + 37 * v3;
}

uint64_t *sub_1808E11DC@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0xF0, a2);
  unint64_t v5 = v4;
  if (v4)
  {
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a1 + 8);
    *((_BYTE *)v4 + 12) = 0;
    *uint64_t v4 = (uint64_t)off_189722DF0;
    icu::Locale::Locale((icu::Locale *)(v4 + 2), a1 + 16);
  }

  return v5;
}

char *sub_1808E1230(uint64_t a1, char *__dst, int a3)
{
  BOOL result = strncpy(__dst, *(const char **)(a1 + 56), a3);
  __dst[a3 - 1] = 0;
  return result;
}

BOOL sub_1808E1268(void *a1, void *a2)
{
  BOOL result = sub_18089E3E8(a1, a2);
  if (result) {
    return icu::Locale::operator==((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  }
  return result;
}

void sub_1808E12A8(void **a1)
{
}

uint64_t icu::FormattedDateInterval::FormattedDateInterval(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)BOOL result = off_189722E70;
  *(void *)(result + 8) = v2;
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 27;
  return result;
}

{
  uint64_t v2;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)BOOL result = off_189722E70;
  *(void *)(result + 8) = v2;
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 27;
  return result;
}

void icu::FormattedDateInterval::~FormattedDateInterval(icu::FormattedDateInterval *this)
{
  *(void *)this = off_189722E70;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 1) = 0LL;
  icu::FormattedValue::~FormattedValue(this);
}

{
  uint64_t v2;
  *(void *)this = off_189722E70;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 1) = 0LL;
  icu::FormattedValue::~FormattedValue(this);
}

{
  uint64_t v2;
  void *v3;
  *(void *)this = off_189722E70;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 1) = 0LL;
  icu::FormattedValue::~FormattedValue(this);
  icu::UMemory::operator delete(v3);
}

uint64_t icu::FormattedDateInterval::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 27;
  return a1;
}

void icu::FormattedDateInterval::toString( icu::FormattedDateInterval *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(int *)a2 >= 1)
  {
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)(a3 + 56) = 0LL;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
LABEL_3:
    *(void *)a3 = off_18971B688;
    *(_WORD *)(a3 + 8) = 2;
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
    return;
  }

  uint64_t v3 = *((void *)this + 1);
  if (!v3)
  {
    *a2 = *((UErrorCode *)this + 4);
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(void *)(a3 + 56) = 0LL;
    goto LABEL_3;
  }

  (*(void (**)(void))(*(void *)v3 + 16LL))(*((void *)this + 1));
}

void icu::FormattedDateInterval::toTempString( icu::FormattedDateInterval *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(int *)a2 >= 1)
  {
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)(a3 + 56) = 0LL;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
LABEL_3:
    *(void *)a3 = off_18971B688;
    *(_WORD *)(a3 + 8) = 2;
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
    return;
  }

  uint64_t v3 = *((void *)this + 1);
  if (!v3)
  {
    *a2 = *((UErrorCode *)this + 4);
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(void *)(a3 + 56) = 0LL;
    goto LABEL_3;
  }

  (*(void (**)(void))(*(void *)v3 + 24LL))(*((void *)this + 1));
}

icu::Appendable *icu::FormattedDateInterval::appendTo( icu::FormattedDateInterval *this, icu::Appendable *a2, UErrorCode *a3)
{
  uint64_t v4 = *((void *)this + 1);
  if (!v4)
  {
    *a3 = *((UErrorCode *)this + 4);
    return a2;
  }

  return (icu::Appendable *)(*(uint64_t (**)(void, icu::Appendable *))(*(void *)v4 + 32LL))( *((void *)this + 1),  a2);
}

uint64_t icu::FormattedDateInterval::nextPosition(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4)
  {
    *a3 = *(_DWORD *)(a1 + 16);
    return 0LL;
  }

  return (*(uint64_t (**)(void))(*(void *)v4 + 40LL))(*(void *)(a1 + 8));
}

void *icu::DateIntervalFormat::getStaticClassID(icu::DateIntervalFormat *this)
{
  return &unk_18C535360;
}

void *icu::DateIntervalFormat::getDynamicClassID(icu::DateIntervalFormat *this)
{
  return &unk_18C535360;
}

icu::DateIntervalFormat *icu::DateIntervalFormat::createInstance( icu::DateIntervalFormat *this, UErrorCode *a2, UErrorCode *a3)
{
  Default = icu::Locale::getDefault(this);
  return icu::DateIntervalFormat::createInstance((UErrorCode *)this, (const icu::UnicodeString *)Default, a2, v6);
}

icu::DateIntervalFormat *icu::DateIntervalFormat::createInstance@<X0>( UErrorCode *this@<X0>, const icu::UnicodeString *a2@<X1>, UErrorCode *a3@<X2>, uint64_t *a4@<X8>)
{
  BOOL result = (icu::DateIntervalFormat *)icu::UMemory::operator new(a4, (icu::UMemory *)0x58, (unint64_t)a2);
  if (result)
  {
    int v9 = result;
    icu::DateIntervalInfo::DateIntervalInfo(result, a2, a3);
    return icu::DateIntervalFormat::create(a2, v9, this, a3, v10);
  }

  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return result;
}

icu::DateIntervalFormat *icu::DateIntervalFormat::create@<X0>( icu::DateIntervalFormat *this@<X0>, const icu::Locale *a2@<X1>, UErrorCode *a3@<X2>, UErrorCode *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10 = (icu::DateIntervalFormat *)icu::UMemory::operator new(a5, (icu::UMemory *)0x770, (unint64_t)a2);
  if (v10)
  {
    BOOL result = icu::DateIntervalFormat::DateIntervalFormat(v10, this, a2, a3, a4);
    (*(void (**)(icu::DateIntervalFormat *))(*(void *)result + 8LL))(result);
  }

  else
  {
    *a4 = U_MEMORY_ALLOCATION_ERROR;
    if (a2)
    {
      icu::DateIntervalInfo::~DateIntervalInfo(a2);
      icu::UMemory::operator delete(v12);
    }
  }

  return 0LL;
}

icu::DateIntervalFormat *icu::DateIntervalFormat::createInstance( icu::DateIntervalFormat *this, const icu::UnicodeString *a2, UErrorCode *a3, UErrorCode *a4)
{
  Default = icu::Locale::getDefault(this);
  uint64_t v10 = icu::DateIntervalInfo::clone(a2, v8, v9);
  return icu::DateIntervalFormat::create( (icu::DateIntervalFormat *)Default,  (const icu::Locale *)v10,  (UErrorCode *)this,  a3,  v11);
}

icu::DateIntervalFormat *icu::DateIntervalFormat::createInstance@<X0>( UErrorCode *this@<X0>, const icu::UnicodeString *a2@<X1>, const icu::Locale *a3@<X2>, UErrorCode *a4@<X3>, uint64_t *a5@<X8>)
{
  int v9 = icu::DateIntervalInfo::clone(a3, (unint64_t)a2, a5);
  return icu::DateIntervalFormat::create(a2, (const icu::Locale *)v9, this, a4, v10);
}

icu::DateIntervalFormat *icu::DateIntervalFormat::DateIntervalFormat(icu::DateIntervalFormat *this)
{
  uint64_t v2 = icu::Format::Format((uint64_t)this);
  *(void *)uint64_t v2 = off_189722EB0;
  uint64_t v3 = (icu::Locale *)(v2 + 360);
  *(_OWORD *)(v2 + 328) = 0u;
  *(_OWORD *)(v2 + 344) = 0u;
  uint64_t Root = icu::Locale::getRoot((icu::Locale *)v2);
  icu::Locale::Locale(v3, Root);
  *((void *)this + 73) = off_18971B688;
  *((_WORD *)this + 296) = 2;
  unint64_t v5 = (char *)this + 1872;
  uint64_t v6 = 648LL;
  do
  {
    uint64_t v7 = (char *)this + v6;
    *(void *)uint64_t v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    *((void *)v7 + 8) = off_18971B688;
    *((_WORD *)v7 + 36) = 2;
    v6 += 136LL;
  }

  while (v7 + 136 != v5);
  *(void *)unint64_t v5 = 0LL;
  *((void *)this + 235) = 0LL;
  *((_DWORD *)this + 474) = 0;
  *((void *)this + 236) = 0LL;
  *((_DWORD *)this + 475) = 256;
  return this;
}

uint64_t icu::DateIntervalFormat::DateIntervalFormat( icu::DateIntervalFormat *this, const icu::DateIntervalFormat *a2)
{
  uint64_t v4 = icu::Format::Format((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v4 = off_189722EB0;
  *(_OWORD *)(v4 + 328) = 0u;
  *(_OWORD *)(v4 + 344) = 0u;
  icu::Locale::Locale((icu::Locale *)(v4 + 360), (uint64_t)a2 + 360);
  *((void *)this + 73) = off_18971B688;
  *((_WORD *)this + 296) = 2;
  unint64_t v5 = (char *)this + 1872;
  uint64_t v6 = 648LL;
  do
  {
    uint64_t v7 = (char *)this + v6;
    *(void *)uint64_t v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    *((void *)v7 + 8) = off_18971B688;
    *((_WORD *)v7 + 36) = 2;
    v6 += 136LL;
  }

  while (v7 + 136 != v5);
  *(void *)unint64_t v5 = 0LL;
  *((void *)this + 235) = 0LL;
  *((_DWORD *)this + 474) = 0;
  *((void *)this + 236) = 0LL;
  *((_DWORD *)this + 475) = 256;
  return icu::DateIntervalFormat::operator=((uint64_t)this, (uint64_t)a2);
}

uint64_t icu::DateIntervalFormat::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)(a1 + 336);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    unint64_t v5 = *(icu::DateIntervalInfo **)(a1 + 328);
    if (v5)
    {
      icu::DateIntervalInfo::~DateIntervalInfo(v5);
      icu::UMemory::operator delete(v6);
    }

    uint64_t v7 = *(void *)(a1 + 344);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 352);
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    uint64_t v9 = *(void *)(a1 + 1872);
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
    uint64_t v10 = *(void *)(a1 + 1880);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
    uint64_t v11 = *(void *)(a1 + 1888);
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
    umtx_lock((icu::UMutex *)&unk_18C535368);
    uint64_t v12 = *(void *)(a2 + 336);
    if (v12) {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 32LL))(v12);
    }
    *(void *)(a1 + 336) = v12;
    uint64_t v13 = *(void *)(a2 + 344);
    if (v13) {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 24LL))(v13);
    }
    *(void *)(a1 + 344) = v13;
    uint64_t v14 = *(void *)(a2 + 352);
    if (v14) {
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 24LL))(v14);
    }
    *(void *)(a1 + 352) = v14;
    umtx_unlock((std::mutex **)&unk_18C535368);
    uint64_t v17 = *(uint64_t **)(a2 + 328);
    if (v17) {
      uint64_t v17 = icu::DateIntervalInfo::clone((icu::DateIntervalInfo *)v17, v15, v16);
    }
    *(void *)(a1 + 328) = v17;
    icu::UnicodeString::operator=((UChar **)(a1 + 584), (UChar **)(a2 + 584));
    for (uint64_t i = 0LL; i != 1224; i += 136LL)
    {
      icu::UnicodeString::operator=((UChar **)(a1 + i + 648), (UChar **)(a2 + i + 648));
      icu::UnicodeString::operator=((UChar **)(a1 + i + 712), (UChar **)(a2 + i + 712));
      *(_BYTE *)(a1 + i + 776) = *(_BYTE *)(a2 + i + 776);
    }

    icu::Locale::operator=((icu::Locale *)(a1 + 360), a2 + 360);
    uint64_t v19 = *(void *)(a2 + 1872);
    if (v19) {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 56LL))(v19);
    }
    *(void *)(a1 + 1872) = v19;
    uint64_t v20 = *(void *)(a2 + 1880);
    if (v20) {
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 56LL))(v20);
    }
    *(void *)(a1 + 1880) = v20;
    uint64_t v21 = *(void *)(a2 + 1888);
    if (v21) {
      uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 56LL))(v21);
    }
    *(void *)(a1 + 1888) = v21;
    *(void *)(a1 + 1896) = *(void *)(a2 + 1896);
  }

  return a1;
}

void icu::DateIntervalFormat::~DateIntervalFormat(icu::DateIntervalFormat *this)
{
  *(void *)this = off_189722EB0;
  uint64_t v2 = (icu::DateIntervalInfo *)*((void *)this + 41);
  if (v2)
  {
    icu::DateIntervalInfo::~DateIntervalInfo(v2);
    icu::UMemory::operator delete(v3);
  }

  uint64_t v4 = *((void *)this + 42);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *((void *)this + 43);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *((void *)this + 44);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *((void *)this + 234);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *((void *)this + 235);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *((void *)this + 236);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  uint64_t v10 = 1224LL;
  do
  {
    icu::UnicodeString::~UnicodeString((char *)this + v10, (icu::DateIntervalFormat *)((char *)this + v10 + 576));
    icu::UnicodeString::~UnicodeString(v11, (icu::DateIntervalFormat *)((char *)this + v10 + 512));
    v10 -= 136LL;
  }

  while (v10);
  icu::UnicodeString::~UnicodeString(v12, (icu::DateIntervalFormat *)((char *)this + 584));
  icu::Locale::~Locale((icu::DateIntervalFormat *)((char *)this + 360));
  icu::Format::~Format(this);
}

{
  void *v1;
  icu::DateIntervalFormat::~DateIntervalFormat(this);
  icu::UMemory::operator delete(v1);
}

icu::DateIntervalFormat *icu::DateIntervalFormat::clone@<X0>( icu::DateIntervalFormat *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL result = (icu::DateIntervalFormat *)icu::UMemory::operator new(a3, (icu::UMemory *)0x770, a2);
  if (result) {
    return (icu::DateIntervalFormat *)icu::DateIntervalFormat::DateIntervalFormat(result, this);
  }
  return result;
}

uint64_t icu::DateIntervalFormat::operator==(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    __cxa_bad_typeid();
  }
  uint64_t result = sub_1807F874C(*(void *)(*(void *)a1 - 8LL), *(void *)(*(void *)a2 - 8LL));
  if (!(_DWORD)result) {
    return result;
  }
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t result = icu::Format::operator==((void *)a1, (void *)a2);
  if (!(_DWORD)result) {
    return result;
  }
  uint64_t v5 = *(void *)(a1 + 328);
  uint64_t v6 = *(void *)(a2 + 328);
  if (v5 == v6)
  {
    if (!v5) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t result = 0LL;
    if (!v5 || !v6) {
      return result;
    }
  }

  uint64_t result = icu::DateIntervalInfo::operator==(*(void *)(a1 + 328), v6);
  if (!(_DWORD)result) {
    return result;
  }
LABEL_12:
  umtx_lock((icu::UMutex *)&unk_18C535368);
  uint64_t v7 = *(void *)(a1 + 336);
  uint64_t v8 = *(void *)(a2 + 336);
  if (v7 != v8)
  {
    if (!v7 || !v8) {
      goto LABEL_21;
    }
LABEL_17:
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v7 + 24LL))(v7))
    {
LABEL_21:
      umtx_unlock((std::mutex **)&unk_18C535368);
      return 0LL;
    }

    goto LABEL_18;
  }

  if (v7) {
    goto LABEL_17;
  }
LABEL_18:
  umtx_unlock((std::mutex **)&unk_18C535368);
  unsigned int v9 = *(unsigned __int16 *)(a1 + 592);
  if ((v9 & 1) != 0)
  {
    if ((*(_WORD *)(a2 + 592) & 1) == 0) {
      return 0LL;
    }
LABEL_33:
    uint64_t v13 = *(void *)(a1 + 1872);
    uint64_t v14 = *(void *)(a2 + 1872);
    if (v13 == v14)
    {
      if (!v13) {
        goto LABEL_39;
      }
    }

    else
    {
      uint64_t result = 0LL;
      if (!v13 || !v14) {
        return result;
      }
    }

    if ((sub_18086B6D8(*(void *)(a1 + 1872), v14) & 1) != 0) {
      return 0LL;
    }
LABEL_39:
    uint64_t v15 = *(void *)(a1 + 1880);
    uint64_t v16 = *(void *)(a2 + 1880);
    if (v15 == v16)
    {
      if (!v15) {
        goto LABEL_45;
      }
    }

    else
    {
      uint64_t result = 0LL;
      if (!v15 || !v16) {
        return result;
      }
    }

    if ((sub_18086B6D8(*(void *)(a1 + 1880), v16) & 1) != 0) {
      return 0LL;
    }
LABEL_45:
    uint64_t v17 = *(void *)(a1 + 1888);
    uint64_t v18 = *(void *)(a2 + 1888);
    if (v17 == v18)
    {
      if (!v17)
      {
LABEL_51:
        uint64_t result = icu::Locale::operator==(a1 + 360, a2 + 360);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v19 = 0LL;
        while ((sub_18086B6D8(a1 + v19 + 648, a2 + v19 + 648) & 1) == 0
             && (sub_18086B6D8(a1 + v19 + 712, a2 + v19 + 712) & 1) == 0
             && *(unsigned __int8 *)(a1 + v19 + 776) == *(unsigned __int8 *)(a2 + v19 + 776))
        {
          v19 += 136LL;
          if (v19 == 1224)
          {
            if (*(_DWORD *)(a1 + 1896) != *(_DWORD *)(a2 + 1896)) {
              return 0LL;
            }
            return *(_DWORD *)(a1 + 1900) == *(_DWORD *)(a2 + 1900);
          }
        }

        return 0LL;
      }
    }

    else
    {
      uint64_t result = 0LL;
      if (!v17 || !v18) {
        return result;
      }
    }

    if ((sub_18086B6D8(*(void *)(a1 + 1888), v18) & 1) != 0) {
      return 0LL;
    }
    goto LABEL_51;
  }

  if ((v9 & 0x8000) != 0) {
    int v10 = *(_DWORD *)(a1 + 596);
  }
  else {
    int v10 = v9 >> 5;
  }
  uint64_t result = 0LL;
  unsigned int v11 = *(unsigned __int16 *)(a2 + 592);
  if ((v11 & 0x8000u) == 0) {
    unsigned int v12 = v11 >> 5;
  }
  else {
    unsigned int v12 = *(_DWORD *)(a2 + 596);
  }
  if ((v11 & 1) == 0 && v10 == v12)
  {
    uint64_t result = icu::UnicodeString::doEquals((icu::UnicodeString *)(a1 + 584), (const icu::UnicodeString *)(a2 + 584), v10);
    if ((_DWORD)result) {
      goto LABEL_33;
    }
  }

  return result;
}

icu::UnicodeString *icu::DateIntervalFormat::format( icu::DateIntervalFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    if (icu::Formattable::getType(a2) == 6)
    {
      Object = (const void *)icu::Formattable::getObject(a2);
      if (Object)
      {
        if (v11) {
          return icu::DateIntervalFormat::format(this, v11, a3, a4, a5);
        }
      }
    }

    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return a3;
}

icu::UnicodeString *icu::DateIntervalFormat::format( icu::DateIntervalFormat *this, const icu::DateInterval *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 42) && *((void *)this + 41))
    {
      memset(v11, 0, sizeof(v11));
      sub_1808F70B8((uint64_t)v11, (uint64_t)a4);
      sub_1808F7164((uint64_t)v11, 1);
      umtx_lock((icu::UMutex *)&unk_18C535368);
      a3 = icu::DateIntervalFormat::formatIntervalImpl(this, a2, a3, (BOOL *)&v10, (icu::FieldPositionHandler *)v11, a5);
      umtx_unlock((std::mutex **)&unk_18C535368);
      nullsub_32(v11);
    }

    else
    {
      *a5 = U_INVALID_STATE_ERROR;
    }
  }

  return a3;
}

icu::UnicodeString *icu::DateIntervalFormat::formatIntervalImpl( icu::DateIntervalFormat *this, const icu::DateInterval *a2, icu::UnicodeString *a3, BOOL *a4, icu::FieldPositionHandler *a5, UErrorCode *a6)
{
  if (*(int *)a6 <= 0)
  {
    uint64_t v9 = *((void *)this + 43);
    if (v9 && *((void *)this + 44))
    {
      icu::Calendar::setTimeInMillis(v9, *((double *)a2 + 1), a6);
      icu::Calendar::setTimeInMillis(*((void *)this + 44), *((double *)a2 + 2), a6);
      return icu::DateIntervalFormat::formatImpl( this,  *((icu::Calendar **)this + 43),  *((icu::Calendar **)this + 44),  a3,  a4,  a5,  a6);
    }

    *a6 = U_INVALID_STATE_ERROR;
  }

  return a3;
}

uint64_t *icu::DateIntervalFormat::formatToValue@<X0>( uint64_t *this@<X0>, const icu::DateInterval *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v5 = (uint64_t *)*(unsigned int *)a3;
  if ((int)v5 >= 1)
  {
    *(void *)a4 = off_189722E70;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = (_DWORD)v5;
    return this;
  }

  uint64_t v8 = (icu::DateIntervalFormat *)this;
  this = icu::UMemory::operator new(v5, (icu::UMemory *)0x68, (unint64_t)a2);
  uint64_t v9 = this;
  if (!this)
  {
    UErrorCode v10 = *a3;
    if (*(int *)a3 <= 0)
    {
      UErrorCode v10 = U_MEMORY_ALLOCATION_ERROR;
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }

icu::UnicodeString *icu::DateIntervalFormat::format( icu::DateIntervalFormat *this, icu::Calendar *a2, icu::Calendar *a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  unsigned int v11 = icu::DateIntervalFormat::formatImpl(this, a2, a3, a4, (BOOL *)&v13, (icu::FieldPositionHandler *)v14, a6);
  umtx_unlock((std::mutex **)&unk_18C535368);
  nullsub_32(v14);
  return v11;
}

icu::UnicodeString *icu::DateIntervalFormat::formatImpl( icu::DateIntervalFormat *this, icu::Calendar *a2, icu::Calendar *a3, icu::UnicodeString *a4, BOOL *a5, icu::FieldPositionHandler *a6, UErrorCode *a7)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  if (*(int *)a7 <= 0)
  {
    signed __int8 v13 = a2;
    *a5 = -1;
    if (!(*(unsigned int (**)(icu::Calendar *, icu::Calendar *))(*(void *)a2 + 40LL))(a2, a3))
    {
      *a7 = U_ILLEGAL_ARGUMENT_ERROR;
      return a4;
    }

    int v15 = icu::Calendar::get(v13, 0, a7);
    unsigned int v16 = 0;
    if (v15 != icu::Calendar::get(a3, 0, a7))
    {
LABEL_81:
      int v61 = 0;
      (*(void (**)(void, void, int *))(**((void **)this + 42) + 200LL))( *((void *)this + 42),  *((unsigned int *)this + 475),  &v61);
      int v51 = 1;
      if (((1 << v16) & 0x7600) == 0)
      {
        if (v16 == 24) {
          return icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), v13, a4, a6, a7);
        }
        int v51 = 0;
      }

      int v52 = icu::DateIntervalInfo::calendarFieldToIntervalIndex(v16, (int *)a7);
      unint64_t v53 = (char *)this + 136 * v52;
      if (*((unsigned __int16 *)v53 + 328) > 0x1Fu)
      {
        unint64_t v54 = v53 + 648;
        uint64_t v55 = a6;
        uint64_t v56 = (char *)this + 136 * v52;
        int v60 = v56[776];
        if (v56[776]) {
          char v57 = a3;
        }
        else {
          char v57 = v13;
        }
        *a5 = v60 != 0;
        int v58 = v55;
        __int128 v63 = 0u;
        __int128 v64 = 0u;
        uint64_t v66 = 0LL;
        __int128 v65 = 0u;
        uint64_t v62 = off_18971B688;
        LOWORD(v63) = 2;
        (*(void (**)(void, void (***)(icu::UnicodeString *__hidden)))(**((void **)this + 42)
                                                                                            + 240LL))( *((void *)this + 42),  &v62);
        (*(void (**)(void, char *))(**((void **)this + 42) + 256LL))(*((void *)this + 42), v54);
        icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), v57, a4, v58, a7);
        if (*((unsigned __int16 *)v56 + 360) >= 0x20u)
        {
          if (!v60) {
            signed __int8 v13 = a3;
          }
          (*(void (**)(void, char *))(**((void **)this + 42) + 256LL))( *((void *)this + 42),  (char *)this + 136 * v52 + 712);
          int v61 = 0;
          (*(void (**)(void, uint64_t, int *))(**((void **)this + 42) + 200LL))( *((void *)this + 42),  256LL,  &v61);
          icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), v13, a4, v58, a7);
        }

        goto LABEL_93;
      }

      if (*((unsigned __int16 *)this + 68 * v52 + 360) > 0x1Fu)
      {
        __int128 v63 = 0u;
        __int128 v64 = 0u;
        uint64_t v66 = 0LL;
        __int128 v65 = 0u;
        uint64_t v62 = off_18971B688;
        LOWORD(v63) = 2;
        (*(void (**)(void, void (***)(icu::UnicodeString *__hidden)))(**((void **)this + 42)
                                                                                            + 240LL))( *((void *)this + 42),  &v62);
        (*(void (**)(void, char *))(**((void **)this + 42) + 256LL))( *((void *)this + 42),  (char *)this + 136 * v52 + 712);
        icu::DateIntervalFormat::fallbackFormat(this, v13, a3, v51, a4, (signed __int8 *)a5, a6, a7);
        icu::UnicodeString::operator=((UChar **)a4, (UChar **)a4);
LABEL_93:
        (*(void (**)(void, void (***)(icu::UnicodeString *__hidden)))(**((void **)this + 42)
                                                                                            + 256LL))( *((void *)this + 42),  &v62);
        icu::UnicodeString::~UnicodeString(v59, (icu::UnicodeString *)&v62);
        return a4;
      }

      if (!icu::SimpleDateFormat::isFieldUnitIgnored(*((void *)this + 42), v16))
      {
        icu::DateIntervalFormat::fallbackFormat(this, v13, a3, v51, a4, (signed __int8 *)a5, a6, a7);
        return a4;
      }

      return icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), v13, a4, a6, a7);
    }

    int v17 = icu::Calendar::get(v13, 1u, a7);
    if (v17 != icu::Calendar::get(a3, 1u, a7))
    {
      if (*((_DWORD *)this + 474) != 1
        || (*((__int16 *)this + 296) < 0
          ? (int32_t v25 = *((_DWORD *)this + 149))
          : (int32_t v25 = *((unsigned __int16 *)this + 296) >> 5),
            (icu::UnicodeString::doIndexOf((uint64_t)this + 584, 0x64u, 0, v25) & 0x80000000) != 0
         || (*((__int16 *)this + 296) < 0
           ? (int32_t v29 = *((_DWORD *)this + 149))
           : (int32_t v29 = *((unsigned __int16 *)this + 296) >> 5),
             (icu::UnicodeString::doIndexOf((uint64_t)this + 584, 0x79u, 0, v29) & 0x80000000) == 0)))
      {
        unsigned int v16 = 1;
        goto LABEL_81;
      }

      double TimeInMillis = icu::Calendar::getTimeInMillis(v13, a7);
      double v31 = icu::Calendar::getTimeInMillis(a3, a7);
      int v32 = icu::Calendar::get(v13, 5u, a7);
      int v33 = icu::Calendar::get(a3, 5u, a7);
      unsigned int v16 = 1;
      (*(void (**)(icu::Calendar *, uint64_t, uint64_t, UErrorCode *))(*(void *)v13 + 56LL))( v13,  2LL,  1LL,  a7);
      if (TimeInMillis < v31)
      {
        double v34 = icu::Calendar::getTimeInMillis(v13, a7);
        if (v32 <= v33 || v34 <= v31) {
          unsigned int v16 = 1;
        }
        else {
          unsigned int v16 = 5;
        }
      }

      goto LABEL_80;
    }

    int v18 = icu::Calendar::get(v13, 2u, a7);
    if (v18 == icu::Calendar::get(a3, 2u, a7))
    {
      int v19 = icu::Calendar::get(v13, 5u, a7);
      if (v19 == icu::Calendar::get(a3, 5u, a7))
      {
        unsigned int v16 = 9;
        int v20 = icu::Calendar::get(v13, 9u, a7);
        if (v20 == icu::Calendar::get(a3, 9u, a7))
        {
          unsigned int v16 = 10;
          int v21 = icu::Calendar::get(v13, 0xAu, a7);
          if (v21 == icu::Calendar::get(a3, 0xAu, a7))
          {
            unsigned int v16 = 12;
            int v22 = icu::Calendar::get(v13, 0xCu, a7);
            if (v22 == icu::Calendar::get(a3, 0xCu, a7))
            {
              unsigned int v16 = 13;
              int v23 = icu::Calendar::get(v13, 0xDu, a7);
              if (v23 == icu::Calendar::get(a3, 0xDu, a7))
              {
                int v24 = icu::Calendar::get(v13, 0xEu, a7);
                else {
                  unsigned int v16 = 14;
                }
              }
            }
          }
        }

        goto LABEL_81;
      }

      if (*((_DWORD *)this + 474) != 2
        || (*((__int16 *)this + 296) < 0
          ? (int32_t v28 = *((_DWORD *)this + 149))
          : (int32_t v28 = *((unsigned __int16 *)this + 296) >> 5),
            (icu::UnicodeString::doIndexOf((uint64_t)this + 584, 0x48u, 0, v28) & 0x80000000) != 0
         && (*((__int16 *)this + 296) < 0
           ? (int32_t v44 = *((_DWORD *)this + 149))
           : (int32_t v44 = *((unsigned __int16 *)this + 296) >> 5),
             (icu::UnicodeString::doIndexOf((uint64_t)this + 584, 0x68u, 0, v44) & 0x80000000) != 0
          && (*((__int16 *)this + 296) < 0
            ? (int32_t v46 = *((_DWORD *)this + 149))
            : (int32_t v46 = *((unsigned __int16 *)this + 296) >> 5),
              (icu::UnicodeString::doIndexOf((uint64_t)this + 584, 0x6Au, 0, v46) & 0x80000000) != 0))))
      {
        unsigned int v16 = 5;
        goto LABEL_81;
      }

      double TimeInMillis = icu::Calendar::getTimeInMillis(v13, a7);
      double v47 = icu::Calendar::getTimeInMillis(a3, a7);
      int v48 = icu::Calendar::get(v13, 0xAu, a7);
      int v49 = icu::Calendar::get(a3, 0xAu, a7);
      (*(void (**)(icu::Calendar *, uint64_t, uint64_t, UErrorCode *))(*(void *)v13 + 56LL))( v13,  11LL,  12LL,  a7);
      unsigned int v16 = 5;
    }

    else
    {
      int v26 = *((_DWORD *)this + 474);
      if (v26 == 1)
      {
        else {
          int32_t v27 = *((unsigned __int16 *)this + 296) >> 5;
        }
        if ((icu::UnicodeString::doIndexOf((uint64_t)this + 584, 0x64u, 0, v27) & 0x80000000) == 0)
        {
          double TimeInMillis = icu::Calendar::getTimeInMillis(v13, a7);
          double v36 = icu::Calendar::getTimeInMillis(a3, a7);
          int v37 = icu::Calendar::get(v13, 5u, a7);
          int v38 = icu::Calendar::get(a3, 5u, a7);
          unsigned int v16 = 2;
          (*(void (**)(icu::Calendar *, uint64_t, uint64_t, UErrorCode *))(*(void *)v13 + 56LL))( v13,  2LL,  1LL,  a7);
          if (TimeInMillis < v36)
          {
            double v39 = icu::Calendar::getTimeInMillis(v13, a7);
            BOOL v40 = v37 <= v38 || v39 <= v36;
            int v41 = 5;
LABEL_78:
            if (!v40) {
              unsigned int v16 = v41;
            }
          }

uint64_t *icu::DateIntervalFormat::formatToValue@<X0>( uint64_t *this@<X0>, icu::Calendar *a2@<X1>, icu::Calendar *a3@<X2>, UErrorCode *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (uint64_t *)*(unsigned int *)a4;
  if ((int)v6 >= 1)
  {
    *(void *)a5 = off_189722E70;
    *(void *)(a5 + 8) = 0LL;
    *(_DWORD *)(a5 + 16) = (_DWORD)v6;
    return this;
  }

  UErrorCode v10 = (icu::DateIntervalFormat *)this;
  this = icu::UMemory::operator new(v6, (icu::UMemory *)0x68, (unint64_t)a2);
  unsigned int v11 = this;
  if (!this)
  {
    UErrorCode v12 = *a4;
    if (*(int *)a4 <= 0)
    {
      UErrorCode v12 = U_MEMORY_ALLOCATION_ERROR;
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }

icu::UnicodeString *icu::DateIntervalFormat::fallbackFormat( icu::DateIntervalFormat *this, icu::Calendar *a2, icu::Calendar *a3, int a4, icu::UnicodeString *a5, signed __int8 *a6, icu::FieldPositionHandler *a7, UErrorCode *a8)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (*(int *)a8 <= 0)
  {
    if (a4 && *((void *)this + 234) && *((void *)this + 235))
    {
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      uint64_t v45 = 0LL;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      int v15 = (const icu::UnicodeString *)*((void *)this + 236);
      *((void *)&v41 + sub_1808F7164((uint64_t)v14, 1) = off_18971B688;
      LOWORD(v42) = 2;
      icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)&v41, v15, 2, 2, 1, a8);
      if (*(int *)a8 <= 0)
      {
        uint64_t __b = 0LL;
        memset(v39, 0, 64);
        sub_1808E5E78(&__b, (uint64_t)&v41, 2, (uint64_t)v39);
        __int128 v35 = 0u;
        uint64_t v38 = 0LL;
        __int128 v37 = 0u;
        __int128 v36 = 0u;
        double v34 = off_18971B688;
        LOWORD(v35) = 2;
        (*(void (**)(void, void (***)(icu::UnicodeString *__hidden)))(**((void **)this + 42)
                                                                                            + 240LL))( *((void *)this + 42),  &v34);
        int v30 = 0;
        if ((int)__b >= SHIDWORD(__b))
        {
          icu::UnicodeString::tempSubString((icu::UnicodeString *)v39, 0, SHIDWORD(__b), (icu::UnicodeString *)v31);
          if ((v32 & 0x8000u) == 0) {
            uint64_t v21 = v32 >> 5;
          }
          else {
            uint64_t v21 = v33;
          }
          icu::UnicodeString::doAppend((uint64_t)a5, (const icu::UnicodeString *)v31, 0, v21);
          icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v31);
          (*(void (**)(void, void))(**((void **)this + 42) + 256LL))( *((void *)this + 42),  *((void *)this + 234));
          icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), a2, a5, a7, a8);
          icu::UnicodeString::tempSubString( (icu::UnicodeString *)v39,  SHIDWORD(__b),  __b - HIDWORD(__b),  (icu::UnicodeString *)v31);
          if ((v32 & 0x8000u) == 0) {
            uint64_t v23 = v32 >> 5;
          }
          else {
            uint64_t v23 = v33;
          }
          icu::UnicodeString::doAppend((uint64_t)a5, (const icu::UnicodeString *)v31, 0, v23);
          icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)v31);
          (*(void (**)(void, void))(**((void **)this + 42) + 256LL))( *((void *)this + 42),  *((void *)this + 235));
          (*(void (**)(void, uint64_t, int *))(**((void **)this + 42) + 200LL))( *((void *)this + 42),  256LL,  &v30);
          icu::DateIntervalFormat::fallbackFormatRange(this, a2, a3, a5, a6, a7, a8);
          int v20 = __b;
        }

        else
        {
          icu::UnicodeString::tempSubString((icu::UnicodeString *)v39, 0, __b, (icu::UnicodeString *)v31);
          if ((v32 & 0x8000u) == 0) {
            uint64_t v16 = v32 >> 5;
          }
          else {
            uint64_t v16 = v33;
          }
          icu::UnicodeString::doAppend((uint64_t)a5, (const icu::UnicodeString *)v31, 0, v16);
          icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v31);
          (*(void (**)(void, void))(**((void **)this + 42) + 256LL))( *((void *)this + 42),  *((void *)this + 235));
          icu::DateIntervalFormat::fallbackFormatRange(this, a2, a3, a5, a6, a7, a8);
          icu::UnicodeString::tempSubString( (icu::UnicodeString *)v39,  __b,  HIDWORD(__b) - __b,  (icu::UnicodeString *)v31);
          if ((v32 & 0x8000u) == 0) {
            uint64_t v18 = v32 >> 5;
          }
          else {
            uint64_t v18 = v33;
          }
          icu::UnicodeString::doAppend((uint64_t)a5, (const icu::UnicodeString *)v31, 0, v18);
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v31);
          (*(void (**)(void, void))(**((void **)this + 42) + 256LL))( *((void *)this + 42),  *((void *)this + 234));
          (*(void (**)(void, uint64_t, int *))(**((void **)this + 42) + 200LL))( *((void *)this + 42),  256LL,  &v30);
          icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), a2, a5, a7, a8);
          int v20 = HIDWORD(__b);
        }

        icu::UnicodeString::tempSubString((icu::UnicodeString *)v39, v20, v20 ^ 0x7FFFFFFF, (icu::UnicodeString *)v31);
        if ((v32 & 0x8000u) == 0) {
          uint64_t v25 = v32 >> 5;
        }
        else {
          uint64_t v25 = v33;
        }
        icu::UnicodeString::doAppend((uint64_t)a5, (const icu::UnicodeString *)v31, 0, v25);
        icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v31);
        (*(void (**)(void, void (***)(icu::UnicodeString *__hidden)))(**((void **)this + 42)
                                                                                            + 256LL))( *((void *)this + 42),  &v34);
        icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)&v34);
        icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)v39);
      }

      icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)&v41);
    }

    else
    {
      icu::DateIntervalFormat::fallbackFormatRange(this, a2, a3, a5, a6, a7, a8);
    }
  }

  return a5;
}

uint64_t icu::DateIntervalFormat::getDateIntervalInfo(icu::DateIntervalFormat *this)
{
  return *((void *)this + 41);
}

icu::SimpleDateFormat **icu::DateIntervalFormat::setDateIntervalInfo@<X0>( icu::DateIntervalFormat *this@<X0>, const icu::DateIntervalInfo *a2@<X1>, UErrorCode *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = (icu::DateIntervalInfo *)*((void *)this + 41);
  if (v7)
  {
    icu::DateIntervalInfo::~DateIntervalInfo(v7);
    icu::UMemory::operator delete(v8);
  }

  uint64_t v9 = icu::UMemory::operator new(a4, (icu::UMemory *)0x58, (unint64_t)a2);
  if (v9) {
    uint64_t v9 = (uint64_t *)icu::DateIntervalInfo::DateIntervalInfo((uint64_t)v9, (uint64_t)a2);
  }
  else {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
  *((void *)this + 4sub_1808F7164((uint64_t)v14, 1) = v9;
  uint64_t v10 = *((void *)this + 234);
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  *((void *)this + 234) = 0LL;
  uint64_t v11 = *((void *)this + 235);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
  }
  *((void *)this + 235) = 0LL;
  uint64_t result = (icu::SimpleDateFormat **)*((void *)this + 236);
  if (result) {
    uint64_t result = (icu::SimpleDateFormat **)(*((uint64_t (**)(icu::SimpleDateFormat **))*result + 1))(result);
  }
  *((void *)this + 236) = 0LL;
  if (*((void *)this + 42)) {
    return icu::DateIntervalFormat::initializePattern((icu::SimpleDateFormat **)this, a3);
  }
  return result;
}

icu::SimpleDateFormat **icu::DateIntervalFormat::initializePattern( icu::SimpleDateFormat **this, UErrorCode *a2)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    uint64_t v3 = (uint64_t)this;
    SmpFmtLocale = (icu::Locale *)icu::SimpleDateFormat::getSmpFmtLocale(this[42]);
    __int128 v58 = 0u;
    uint64_t v61 = 0LL;
    __int128 v60 = 0u;
    __int128 v59 = 0u;
    char v57 = off_18971B688;
    LOWORD(v58) = 2;
    (*(void (**)(void, void (***)(icu::UnicodeString *__hidden)))(**(void **)(v3 + 336) + 240LL))( *(void *)(v3 + 336),  &v57);
    icu::DateTimePatternGenerator::staticGetSkeleton((icu::DateTimePatternGenerator *)&v57, (uint64_t)&v52);
    icu::UnicodeString::operator=((icu::UnicodeString *)(v3 + 584), (icu::UnicodeString *)&v52);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)&v52);
    int v6 = *a2;
    this = (icu::SimpleDateFormat **)icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v57);
    if (v6 <= 0)
    {
LABEL_4:
      for (uint64_t i = 776LL; i != 2000; i += 136LL)
        *(_BYTE *)(v3 + i) = icu::DateIntervalInfo::getDefaultOrder(*(icu::DateIntervalInfo **)(v3 + 328));
      __int128 v58 = 0u;
      uint64_t v61 = 0LL;
      __int128 v60 = 0u;
      __int128 v59 = 0u;
      uint64_t v56 = 0LL;
      char v57 = off_18971B688;
      LOWORD(v58) = 2;
      __int128 v53 = 0u;
      __int128 v55 = 0u;
      __int128 v54 = 0u;
      int v52 = off_18971B688;
      LOWORD(v53) = 2;
      __int128 v48 = 0u;
      uint64_t v51 = 0LL;
      __int128 v50 = 0u;
      __int128 v49 = 0u;
      uint64_t v46 = 0LL;
      double v47 = off_18971B688;
      LOWORD(v48) = 2;
      __int128 v43 = 0u;
      __int128 v45 = 0u;
      __int128 v44 = 0u;
      __int128 v42 = off_18971B688;
      LOWORD(v43) = 2;
      memset(v41, 0, sizeof(v41));
      icu::DateIntervalFormat::normalizeHourMetacharacters( (icu::DateIntervalFormat *)v3,  (UChar **)(v3 + 584),  (uint64_t)v41);
      icu::DateIntervalFormat::getDateTimeSkeleton( (uint64_t)v41,  (const icu::UnicodeString *)&v57,  (icu::UnicodeString *)&v42,  (icu::UnicodeString *)&v52,  (icu::UnicodeString *)&v47,  v9);
      int v10 = (unsigned __int16)v53 >> 5;
      if ((v53 & 0x8000u) != 0LL) {
        int v10 = DWORD1(v53);
      }
      if (v10 >= 1)
      {
        int v11 = (unsigned __int16)v58 >> 5;
        if ((v58 & 0x8000u) != 0LL) {
          int v11 = DWORD1(v58);
        }
        if (v11 >= 1)
        {
          BaseName = (char *)icu::Locale::getBaseName(SmpFmtLocale);
          uint64_t v13 = ures_open(0LL, BaseName, (int *)a2);
          ures_getByKey(v13, "calendar", v13, (int *)a2);
          ures_getByKeyWithFallback(v13, "gregorian", v13, a2);
          ures_getByKeyWithFallback(v13, "DateTimePatterns", v13, a2);
          LODWORD(v37) = 0;
          StringByIndex = ures_getStringByIndex(v13, 8, (int *)&v37, (int *)a2);
          if (*(int *)a2 <= 0 && (int)v37 >= 3)
          {
            uint64_t v16 = (uint64_t)StringByIndex;
            int v17 = icu::UMemory::operator new((uint64_t *)v37, (icu::UMemory *)0x40, v15);
            if (!v17)
            {
              *(void *)(v3 + 1888) = 0LL;
              uint64_t v19 = 7LL;
              *a2 = U_MEMORY_ALLOCATION_ERROR;
              if (v13) {
                ures_close(v13);
              }
              goto LABEL_57;
            }

            *(void *)(v3 + 1888) = icu::UnicodeString::UnicodeString((uint64_t)v17, v16, v37);
          }

          if (v13) {
            ures_close(v13);
          }
        }
      }

      int v18 = icu::DateIntervalFormat::setSeparateDateTimePtn( (uint64_t ****)v3,  (UErrorCode *)&v42,  (const icu::UnicodeString *)&v47);
      LODWORD(v19) = (unsigned __int16)v53 >> 5;
      if ((v53 & 0x8000u) == 0LL) {
        uint64_t v19 = v19;
      }
      else {
        uint64_t v19 = DWORD1(v53);
      }
      if (v18)
      {
        if (!(_DWORD)v19)
        {
LABEL_57:
          icu::UnicodeString::~UnicodeString((void *)v19, (icu::UnicodeString *)v41);
          icu::UnicodeString::~UnicodeString(v32, (icu::UnicodeString *)&v42);
          icu::UnicodeString::~UnicodeString(v33, (icu::UnicodeString *)&v47);
          icu::UnicodeString::~UnicodeString(v34, (icu::UnicodeString *)&v52);
          return (icu::SimpleDateFormat **)icu::UnicodeString::~UnicodeString(v35, (icu::UnicodeString *)&v57);
        }

        int v20 = (unsigned __int16)v58 >> 5;
        if ((v58 & 0x8000u) != 0LL) {
          int v20 = DWORD1(v58);
        }
        if (v20)
        {
          __int128 v39 = 0u;
          __int128 v40 = 0u;
          __int128 v37 = 0u;
          __int128 v38 = 0u;
          icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v37, (UChar **)(v3 + 584));
          if ((v58 & 0x8000u) == 0LL) {
            int32_t v21 = (unsigned __int16)v58 >> 5;
          }
          else {
            int32_t v21 = DWORD1(v58);
          }
          if (icu::UnicodeString::doIndexOf((uint64_t)&v57, 0x64u, 0, v21) == -1)
          {
            LOWORD(v36[0]) = 100;
            icu::UnicodeString::doReplace((uint64_t)&v37, 0LL, 0LL, (uint64_t)v36, 0, 1LL);
            icu::DateIntervalFormat::setFallbackPattern((char *)v3, 5u, (UErrorCode *)&v37, a2);
          }

          if ((v58 & 0x8000u) == 0LL) {
            int32_t v22 = (unsigned __int16)v58 >> 5;
          }
          else {
            int32_t v22 = DWORD1(v58);
          }
          if (icu::UnicodeString::doIndexOf((uint64_t)&v57, 0x4Du, 0, v22) == -1)
          {
            LOWORD(v36[0]) = 77;
            icu::UnicodeString::doReplace((uint64_t)&v37, 0LL, 0LL, (uint64_t)v36, 0, 1LL);
            icu::DateIntervalFormat::setFallbackPattern((char *)v3, 2u, (UErrorCode *)&v37, a2);
          }

          if ((v58 & 0x8000u) == 0LL) {
            int32_t v23 = (unsigned __int16)v58 >> 5;
          }
          else {
            int32_t v23 = DWORD1(v58);
          }
          if (icu::UnicodeString::doIndexOf((uint64_t)&v57, 0x79u, 0, v23) == -1)
          {
            LOWORD(v36[0]) = 121;
            icu::UnicodeString::doReplace((uint64_t)&v37, 0LL, 0LL, (uint64_t)v36, 0, 1LL);
            icu::DateIntervalFormat::setFallbackPattern((char *)v3, 1u, (UErrorCode *)&v37, a2);
          }

          if ((v58 & 0x8000u) == 0LL) {
            int32_t v24 = (unsigned __int16)v58 >> 5;
          }
          else {
            int32_t v24 = DWORD1(v58);
          }
          if (icu::UnicodeString::doIndexOf((uint64_t)&v57, 0x47u, 0, v24) == -1)
          {
            LOWORD(v36[0]) = 71;
            icu::UnicodeString::doReplace((uint64_t)&v37, 0LL, 0LL, (uint64_t)v36, 0, 1LL);
            icu::DateIntervalFormat::setFallbackPattern((char *)v3, 0, (UErrorCode *)&v37, a2);
          }

          uint64_t v25 = *(void **)(v3 + 1888);
          if (v25)
          {
            memset(v36, 0, sizeof(v36));
            icu::DateFormat::getBestPattern(SmpFmtLocale, (UErrorCode *)&v57, a2, (uint64_t)v36);
            icu::DateIntervalFormat::concatSingleDate2TimeInterval( v3,  *(const icu::UnicodeString **)(v3 + 1888),  (const icu::UnicodeString *)v36,  9u,  (int *)a2);
            icu::DateIntervalFormat::concatSingleDate2TimeInterval( v3,  *(const icu::UnicodeString **)(v3 + 1888),  (const icu::UnicodeString *)v36,  0xAu,  (int *)a2);
            icu::DateIntervalFormat::concatSingleDate2TimeInterval( v3,  *(const icu::UnicodeString **)(v3 + 1888),  (const icu::UnicodeString *)v36,  0xCu,  (int *)a2);
            icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v36);
          }

uint64_t icu::DateIntervalFormat::getDateFormat(icu::DateIntervalFormat *this)
{
  return *((void *)this + 42);
}

uint64_t icu::DateIntervalFormat::adoptTimeZone(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[42];
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 184LL))(v4, a2);
  }
  uint64_t v5 = a1[43];
  if (v5) {
    icu::Calendar::setTimeZone(v5, a2);
  }
  uint64_t result = a1[44];
  if (result) {
    return icu::Calendar::setTimeZone(result, a2);
  }
  return result;
}

uint64_t icu::DateIntervalFormat::setTimeZone(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[42];
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 192LL))(v4, a2);
  }
  uint64_t v5 = a1[43];
  if (v5) {
    icu::Calendar::setTimeZone(v5, a2);
  }
  uint64_t result = a1[44];
  if (result) {
    return icu::Calendar::setTimeZone(result, a2);
  }
  return result;
}

uint64_t icu::DateIntervalFormat::getTimeZone(icu::DateIntervalFormat *this)
{
  if (!*((void *)this + 42)) {
    return icu::TimeZone::createDefault(this);
  }
  umtx_lock((icu::UMutex *)&unk_18C535368);
  uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 42) + 176LL))(*((void *)this + 42));
  umtx_unlock((std::mutex **)&unk_18C535368);
  return v2;
}

uint64_t icu::DateIntervalFormat::setAttribute(uint64_t result, int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a2) {
      *a4 = 1;
    }
    else {
      *(_DWORD *)(result + 1896) = a3;
    }
  }

  return result;
}

uint64_t icu::DateIntervalFormat::setContext(uint64_t result, int a2, int *a3)
{
  if (*a3 <= 0)
  {
    if ((a2 & 0xFFFFFF00) == 0x100) {
      *(_DWORD *)(result + 1900) = a2;
    }
    else {
      *a3 = 1;
    }
  }

  return result;
}

uint64_t icu::DateIntervalFormat::getContext(uint64_t a1, int a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if (a2 == 1) {
    return *(unsigned int *)(a1 + 1900);
  }
  uint64_t result = 0LL;
  *a3 = 1;
  return result;
}

icu::DateIntervalFormat *icu::DateIntervalFormat::DateIntervalFormat( icu::DateIntervalFormat *this, const icu::Locale *a2, icu::DateIntervalInfo *a3, UErrorCode *a4, UErrorCode *a5)
{
  uint64_t v10 = icu::Format::Format((uint64_t)this);
  *(void *)uint64_t v10 = off_189722EB0;
  *(_OWORD *)(v10 + 328) = 0u;
  *(_OWORD *)(v10 + 344) = 0u;
  icu::Locale::Locale((icu::Locale *)(v10 + 360), (uint64_t)a2);
  *((void *)this + 73) = off_18971B688;
  *((_WORD *)this + 296) = 2;
  UErrorCode v12 = (char *)this + 1872;
  uint64_t v13 = 648LL;
  do
  {
    UErrorCode v14 = (char *)this + v13;
    *(void *)UErrorCode v14 = off_18971B688;
    *((_WORD *)v14 + 4) = 2;
    *((void *)v14 + 8) = off_18971B688;
    *((_WORD *)v14 + 36) = 2;
    v13 += 136LL;
  }

  while (v14 + 136 != v12);
  *(void *)UErrorCode v12 = 0LL;
  *((void *)this + 235) = 0LL;
  *((_DWORD *)this + 474) = 0;
  *((void *)this + 236) = 0LL;
  *((_DWORD *)this + 475) = 256;
  InstanceForSkeleton = icu::DateFormat::createInstanceForSkeleton(a4, a2, a5, v11);
  uint64_t v16 = InstanceForSkeleton;
  UErrorCode v17 = *a5;
  if (!InstanceForSkeleton && v17 <= U_ZERO_ERROR)
  {
    *a5 = U_MEMORY_ALLOCATION_ERROR;
LABEL_12:
    if (a3)
    {
      icu::DateIntervalInfo::~DateIntervalInfo(a3);
      icu::UMemory::operator delete(v18);
    }

    return this;
  }

  if (v17 > U_ZERO_ERROR)
  {
    if (InstanceForSkeleton) {
      (*(void (**)(icu::SimpleDateFormat *))(*(void *)InstanceForSkeleton + 8LL))(InstanceForSkeleton);
    }
    goto LABEL_12;
  }

  icu::UnicodeString::operator=((UChar **)this + 73, (UChar **)a4);
  *((void *)this + 4sub_1808F7164((uint64_t)v14, 1) = a3;
  *((void *)this + 42) = v16;
  if ((*(uint64_t (**)(icu::SimpleDateFormat *))(*(void *)v16 + 128LL))(v16))
  {
    uint64_t v19 = (*(uint64_t (**)(void))(**((void **)this + 42) + 128LL))(*((void *)this + 42));
    *((void *)this + 43) = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 24LL))(v19);
    uint64_t v20 = (*(uint64_t (**)(void))(**((void **)this + 42) + 128LL))(*((void *)this + 42));
    *((void *)this + 44) = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 24LL))(v20);
  }

  icu::DateIntervalFormat::initializePattern((icu::SimpleDateFormat **)this, a5);
  return this;
}

void *icu::DateIntervalFormat::normalizeHourMetacharacters@<X0>( icu::DateIntervalFormat *this@<X0>, UChar **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)a3, a2);
  unint64_t v5 = 0LL;
  __int16 v6 = 0;
  __int16 v7 = 0;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  unint64_t v12 = *(unsigned __int16 *)(a3 + 8);
  uint64_t v13 = a3 + 10;
  if ((v12 & 2) == 0) {
    uint64_t v13 = *(void *)(a3 + 24);
  }
  if ((v12 & 0x8000) != 0) {
    goto LABEL_6;
  }
LABEL_4:
  uint64_t result = (void *)(v12 >> 5);
  if (v5 < v12 >> 5)
  {
    do
    {
      int v15 = *(unsigned __int16 *)(v13 + 2 * v5);
      char v16 = v15 - 66;
      if (((1LL << v16) & 0x34000000342LL) != 0)
      {
        if (v6)
        {
          uint64_t v8 = v8;
        }

        else
        {
          __int16 v6 = *(_WORD *)(v13 + 2 * v5);
          uint64_t v8 = v5;
        }

        uint64_t v9 = (v9 + 1);
        goto LABEL_21;
      }

      if (((1LL << v16) & 0x180000001LL) != 0)
      {
        if (v7)
        {
          uint64_t v10 = v10;
        }

        else
        {
          __int16 v7 = *(_WORD *)(v13 + 2 * v5);
          uint64_t v10 = v5;
        }

        uint64_t v11 = (v11 + 1);
      }

      else
      {
LABEL_20:
        if (v6 && v7) {
          goto LABEL_24;
        }
      }

uint64_t icu::DateIntervalFormat::getDateTimeSkeleton( uint64_t this, const icu::UnicodeString *a2, icu::UnicodeString *a3, icu::UnicodeString *a4, icu::UnicodeString *a5, icu::UnicodeString *a6)
{
  uint64_t v26 = 0LL;
  uint64_t v9 = this;
  unint64_t v10 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  int v11 = 0;
  int v12 = 0;
  uint64_t v13 = this + 10;
  while (1)
  {
    int v14 = *(__int16 *)(v9 + 8);
    if (v14 < 0) {
      break;
    }
    unint64_t v15 = (unint64_t)*(unsigned __int16 *)(v9 + 8) >> 5;
LABEL_7:
    if (v15 > v10)
    {
      if ((v14 & 2) != 0) {
        uint64_t v16 = v13;
      }
      else {
        uint64_t v16 = *(void *)(v9 + 24);
      }
      int v17 = *(unsigned __int16 *)(v16 + 2 * v10);
      switch(*(_WORD *)(v16 + 2 * v10))
      {
        case 'A':
        case 'B':
        case 'S':
        case 'V':
        case 'Z':
        case 'a':
        case 'b':
        case 'j':
        case 's':
          __int16 v28 = *(_WORD *)(v16 + 2 * v10);
          icu::UnicodeString::doAppend((uint64_t)a4, (uint64_t)&v28, 0, 1LL);
          __int16 v28 = v17;
          uint64_t v18 = a5;
          goto LABEL_14;
        case 'D':
        case 'F':
        case 'G':
        case 'L':
        case 'Q':
        case 'U':
        case 'W':
        case 'Y':
        case 'c':
        case 'e':
        case 'g':
        case 'l':
        case 'q':
        case 'r':
        case 'u':
        case 'w':
          __int16 v28 = *(_WORD *)(v16 + 2 * v10);
          icu::UnicodeString::doAppend((uint64_t)a3, (uint64_t)&v28, 0, 1LL);
          __int16 v28 = v17;
          uint64_t v18 = a2;
          goto LABEL_14;
        case 'E':
          __int16 v28 = 69;
          this = icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v28, 0, 1LL);
          ++HIDWORD(v24);
          break;
        case 'H':
        case 'K':
        case 'h':
        case 'k':
          __int16 v28 = *(_WORD *)(v16 + 2 * v10);
          this = icu::UnicodeString::doAppend((uint64_t)a4, (uint64_t)&v28, 0, 1LL);
          if (!v12) {
            int v12 = v17;
          }
          break;
        case 'M':
          __int16 v28 = 77;
          this = icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v28, 0, 1LL);
          LODWORD(v24) = v24 + 1;
          break;
        case 'd':
          __int16 v28 = 100;
          this = icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v28, 0, 1LL);
          LODWORD(v25) = v25 + 1;
          break;
        case 'm':
          __int16 v28 = 109;
          this = icu::UnicodeString::doAppend((uint64_t)a4, (uint64_t)&v28, 0, 1LL);
          ++HIDWORD(v25);
          break;
        case 'v':
          ++HIDWORD(v26);
          __int16 v19 = 118;
          goto LABEL_26;
        case 'y':
          __int16 v28 = 121;
          this = icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v28, 0, 1LL);
          ++v11;
          break;
        case 'z':
          LODWORD(v26) = v26 + 1;
          __int16 v19 = 122;
LABEL_26:
          __int16 v28 = v19;
          uint64_t v18 = a4;
LABEL_14:
          this = icu::UnicodeString::doAppend((uint64_t)v18, (uint64_t)&v28, 0, 1LL);
          break;
        default:
          break;
      }
    }

    ++v10;
  }

  if ((uint64_t)v10 < *(int *)(v9 + 12))
  {
    unint64_t v15 = *(unsigned int *)(v9 + 12);
    goto LABEL_7;
  }

uint64_t icu::DateIntervalFormat::setSeparateDateTimePtn( uint64_t ****this, UErrorCode *a2, const icu::UnicodeString *a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  unsigned int v6 = *((unsigned __int16 *)a3 + 4);
  int v7 = (__int16)v6;
  unsigned int v8 = v6 >> 5;
  if (v7 < 0) {
    unsigned int v8 = *((_DWORD *)a3 + 3);
  }
  if (v8) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = (const icu::UnicodeString *)a2;
  }
  signed __int8 v30 = 0;
  uint64_t BestSkeleton = icu::DateIntervalInfo::getBestSkeleton(this[41], v9, (unsigned __int8 *)&v30);
  if (!BestSkeleton) {
    return 0LL;
  }
  int v12 = (UChar **)BestSkeleton;
  UErrorCode v29 = U_ZERO_ERROR;
  unsigned int v13 = *((unsigned __int16 *)a2 + 4);
  int v14 = (__int16)v13;
  LODWORD(v15) = v13 >> 5;
  if (v14 >= 0) {
    unint64_t v15 = v15;
  }
  else {
    unint64_t v15 = *((unsigned int *)a2 + 3);
  }
  if ((_DWORD)v15)
  {
    uint64_t v16 = icu::UMemory::operator new((uint64_t *)v15, (icu::UMemory *)0x40, v11);
    if (v16) {
      icu::DateFormat::getBestPattern((icu::DateFormat *)(this + 45), a2, &v29, (uint64_t)v16);
    }
    this[234] = (uint64_t ***)v16;
  }

  unsigned int v17 = *((unsigned __int16 *)a3 + 4);
  int v18 = (__int16)v17;
  LODWORD(v19) = v17 >> 5;
  if (v18 >= 0) {
    unint64_t v19 = v19;
  }
  else {
    unint64_t v19 = *((unsigned int *)a3 + 3);
  }
  if ((_DWORD)v19)
  {
    UErrorCode v29 = U_ZERO_ERROR;
    int v20 = icu::UMemory::operator new((uint64_t *)v19, (icu::UMemory *)0x40, v11);
    if (v20) {
      icu::DateFormat::getBestPattern((icu::DateFormat *)(this + 45), (UErrorCode *)a3, &v29, (uint64_t)v20);
    }
    this[235] = (uint64_t ***)v20;
  }

  unsigned int v21 = *((unsigned __int16 *)a3 + 4);
  int v22 = (__int16)v21;
  unsigned int v23 = v21 >> 5;
  if (v22 < 0) {
    unsigned int v23 = *((_DWORD *)a3 + 3);
  }
  if (v23)
  {
    icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  0xCu,  v9,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  0LL,  0LL);
    icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  0xAu,  v9,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  0LL,  0LL);
    icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  9u,  v9,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  0LL,  0LL);
    return 1LL;
  }

  else
  {
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    uint64_t v40 = 0LL;
    __int128 v39 = 0u;
    uint64_t v35 = 0LL;
    int32_t v36 = off_18971B688;
    LOWORD(v37) = 2;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    int32_t v31 = (UChar *)off_18971B688;
    LOWORD(v32) = 2;
    uint64_t v26 = (icu::DateIntervalFormat *)&v36;
    icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  5u,  v9,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  (uint64_t)&v36,  &v31);
    if (icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  2u,  v9,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  (uint64_t)&v36,  &v31)) {
      int v12 = &v31;
    }
    else {
      uint64_t v26 = v9;
    }
    uint64_t v24 = 1LL;
    icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  1u,  v26,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  (uint64_t)&v36,  &v31);
    icu::DateIntervalFormat::setIntervalPattern( (uint64_t)this,  0,  v26,  (uint64_t)v12,  (const icu::UnicodeString *)v30,  (uint64_t)&v36,  &v31);
    icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)&v31);
    icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v36);
  }

  return v24;
}

uint64_t icu::DateIntervalFormat::setPatternInfo( uint64_t a1, unsigned int a2, UChar **a3, UChar **a4, char a5)
{
  int v11 = 0;
  uint64_t result = icu::DateIntervalInfo::calendarFieldToIntervalIndex(a2, &v11);
  if (v11 <= 0)
  {
    int v10 = result;
    if (a3) {
      uint64_t result = (uint64_t)icu::UnicodeString::operator=((UChar **)(a1 + 136LL * (int)result + 648), a3);
    }
    if (a4) {
      uint64_t result = (uint64_t)icu::UnicodeString::operator=((UChar **)(a1 + 136LL * v10 + 712), a4);
    }
    *(_BYTE *)(a1 + 136LL * v10 + 776) = a5;
  }

  return result;
}

BOOL icu::DateIntervalFormat::fieldExistsInSkeleton(int a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  int v3 = (__int16)v2;
  int32_t v4 = v2 >> 5;
  if (v3 >= 0) {
    int32_t v5 = v4;
  }
  else {
    int32_t v5 = *(_DWORD *)(a2 + 12);
  }
  return icu::UnicodeString::doIndexOf( a2,  icu::DateIntervalFormat::fgCalendarFieldToPatternLetter[a1],  0,  v5) != -1;
}

char *icu::DateIntervalFormat::setFallbackPattern( char *result, unsigned int a2, UErrorCode *a3, UErrorCode *a4)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 <= 0)
  {
    uint64_t v6 = (uint64_t)result;
    memset(v9, 0, sizeof(v9));
    icu::DateFormat::getBestPattern((icu::DateFormat *)(result + 360), a3, a4, (uint64_t)v9);
    int v7 = (void *)*(unsigned int *)a4;
    if ((int)v7 <= 0)
    {
      char DefaultOrder = icu::DateIntervalInfo::getDefaultOrder(*(icu::DateIntervalInfo **)(v6 + 328));
      icu::DateIntervalFormat::setPatternInfo(v6, a2, 0LL, (UChar **)v9, DefaultOrder);
    }

    return (char *)icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v9);
  }

  return result;
}

void *icu::DateIntervalFormat::concatSingleDate2TimeInterval( uint64_t a1, const icu::UnicodeString *a2, const icu::UnicodeString *a3, unsigned int a4, int *a5)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t result = (void *)icu::DateIntervalInfo::calendarFieldToIntervalIndex(a4, a5);
  if (*a5 <= 0)
  {
    uint64_t v11 = a1 + 136LL * (int)result;
    if (*(unsigned __int16 *)(v11 + 656) >= 0x20u)
    {
      int v12 = (int)result;
      memset(v30, 0, 64);
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)v30, (UChar **)(v11 + 648));
      uint64_t v13 = a1 + 136LL * v12;
      int v14 = (const icu::UnicodeString *)(v13 + 712);
      unsigned int v15 = *(unsigned __int16 *)(v13 + 720);
      int v16 = (__int16)v15;
      unsigned int v17 = v15 >> 5;
      unsigned int v18 = *(_DWORD *)(v13 + 724);
      if (v16 >= 0) {
        uint64_t v19 = v17;
      }
      else {
        uint64_t v19 = v18;
      }
      icu::UnicodeString::doAppend((uint64_t)v30, v14, 0, v19);
      __int128 v26 = 0u;
      uint64_t v29 = 0LL;
      __int128 v28 = 0u;
      __int128 v27 = 0u;
      uint64_t v25 = off_18971B688;
      LOWORD(v26) = 2;
      unsigned int v23 = off_18971B688;
      __int16 v24 = 2;
      icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)v22, a2, 2, 2, 0, (UErrorCode *)a5);
      icu::SimpleFormatter::format( (icu::SimpleFormatter *)v22,  (const icu::UnicodeString *)v30,  a3,  (icu::UnicodeString *)&v25,  (UErrorCode *)a5);
      icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v22);
      unint64_t v20 = *a5;
      icu::UnicodeString::~UnicodeString((void *)v20, (icu::UnicodeString *)&v25);
      return icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)v30);
    }
  }

  return result;
}

uint64_t icu::DateIntervalFormat::setIntervalPattern( uint64_t a1, unsigned int a2, icu::DateIntervalFormat *a3, uint64_t a4, const icu::UnicodeString *a5, uint64_t a6, UChar **a7)
{
  uint64_t v10 = (const icu::UnicodeString *)a4;
  uint64_t v43 = *MEMORY[0x1895F89C0];
  signed __int8 v32 = (char)a5;
  int v31 = 0;
  __int128 v39 = 0u;
  uint64_t v42 = 0LL;
  __int128 v41 = 0u;
  __int128 v40 = 0u;
  __int128 v38 = (UChar *)off_18971B688;
  LOWORD(v39) = 2;
  icu::DateIntervalInfo::getIntervalPattern(*(void *)(a1 + 328), a4, a2, &v38, &v31);
  if (a2 == 9)
  {
    icu::DateIntervalInfo::getIntervalPattern(*(void *)(a1 + 328), (uint64_t)v10, 0xAu, &v38, &v31);
    unint64_t v15 = (unsigned __int16)v39;
    if ((unsigned __int16)v39 >= 0x20u)
    {
      else {
        int32_t v16 = *(unsigned __int16 *)(a1 + 592) >> 5;
      }
      int v26 = icu::UnicodeString::doIndexOf(a1 + 584, 0x4Au, 0, v16);
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      uint64_t v37 = 0LL;
      __int128 v36 = 0u;
      __int128 v33 = off_18971B688;
      LOWORD(v34) = 2;
      icu::DateIntervalFormat::adjustFieldWidth(a3, v10, &v38, a5, v26 != -1, (uint64_t)&v33, v27);
      char DefaultOrder = icu::DateIntervalInfo::getDefaultOrder(*(icu::DateIntervalInfo **)(a1 + 328));
      icu::DateIntervalFormat::setIntervalPattern(a1, 9u, (uint64_t)&v33, DefaultOrder);
      icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v33);
    }

    goto LABEL_28;
  }

  if (!a6) {
    goto LABEL_23;
  }
  __int16 v23 = icu::DateIntervalFormat::fgCalendarFieldToPatternLetter[a2];
  icu::UnicodeString::operator=((UChar **)a6, (UChar **)a3);
  icu::UnicodeString::operator=(a7, (UChar **)v10);
  LOWORD(v33) = v23;
  icu::UnicodeString::doReplace(a6, 0LL, 0LL, (uint64_t)&v33, 0, 1LL);
  LOWORD(v33) = v23;
  icu::UnicodeString::doReplace((uint64_t)a7, 0LL, 0LL, (uint64_t)&v33, 0, 1LL);
  icu::DateIntervalInfo::getIntervalPattern(*(void *)(a1 + 328), (uint64_t)a7, a2, &v38, &v31);
  unint64_t v15 = (unsigned __int16)v39;
  if ((unsigned __int16)v39 <= 0x1Fu && !(_DWORD)a5)
  {
    uint64_t BestSkeleton = icu::DateIntervalInfo::getBestSkeleton( *(uint64_t ****)(a1 + 328),  (const icu::UnicodeString *)a7,  (unsigned __int8 *)&v32);
    if (BestSkeleton && v32 != 255)
    {
      uint64_t v25 = (const icu::UnicodeString *)BestSkeleton;
      icu::DateIntervalInfo::getIntervalPattern(*(void *)(a1 + 328), BestSkeleton, a2, &v38, &v31);
      uint64_t v10 = v25;
    }

void *icu::DateIntervalFormat::setIntervalPattern(uint64_t a1, unsigned int a2, uint64_t a3)
{
  char DefaultOrder = icu::DateIntervalInfo::getDefaultOrder(*(icu::DateIntervalInfo **)(a1 + 328));
  return icu::DateIntervalFormat::setIntervalPattern(a1, a2, a3, DefaultOrder);
}

void *icu::DateIntervalFormat::setIntervalPattern(uint64_t a1, unsigned int a2, uint64_t a3, char a4)
{
  int32_t v5 = (void (***)(icu::UnicodeString *__hidden))a3;
  uint64_t v37 = *MEMORY[0x1895F89C0];
  __int128 v33 = 0u;
  uint64_t v36 = 0LL;
  __int128 v35 = 0u;
  __int128 v34 = 0u;
  signed __int8 v32 = off_18971B688;
  LOWORD(v33) = 2;
  int v8 = 12;
  if (icu::UnicodeString::doEqualsSubstring(a3, 0, 12, (uint64_t)"l", 0, 12))
  {
    a4 = 1;
    int v9 = -12;
  }

  else
  {
    int v8 = 14;
    a4 = 0;
    int v9 = -14;
  }

  unsigned int v11 = *((unsigned __int16 *)v5 + 4);
  int v12 = (__int16)v11;
  unsigned int v13 = v11 >> 5;
  if (v12 < 0) {
    unsigned int v13 = *((_DWORD *)v5 + 3);
  }
  icu::UnicodeString::doReplace((icu::UnicodeString *)&v32, 0LL, 0LL, (const icu::UnicodeString *)v5, v8, v13 + v9);
  int32_t v5 = &v32;
LABEL_8:
  uint64_t v14 = icu::DateIntervalFormat::splitPatternInto2Part((icu::DateIntervalFormat *)v5, v10);
  int v15 = v14;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  uint64_t v31 = 0LL;
  __int128 v30 = 0u;
  uint64_t v26 = 0LL;
  __int128 v27 = (UChar *)off_18971B688;
  LOWORD(v28) = 2;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  uint64_t v22 = (UChar *)off_18971B688;
  LOWORD(v23) = 2;
  icu::UnicodeString::doReplace((icu::UnicodeString *)&v27, 0LL, 0LL, (const icu::UnicodeString *)v5, 0, v14);
  unsigned int v16 = *((unsigned __int16 *)v5 + 4);
  if ((v16 & 0x8000) != 0)
  {
    int v17 = *((_DWORD *)v5 + 3);
    if (v15 < v17) {
      goto LABEL_12;
    }
  }

  else if (v15 < (int)(v16 >> 5))
  {
    int v17 = v16 >> 5;
LABEL_12:
    icu::UnicodeString::doReplace( (icu::UnicodeString *)&v22,  0LL,  0LL,  (const icu::UnicodeString *)v5,  v15,  (v17 - v15));
  }

  icu::DateIntervalFormat::setPatternInfo(a1, a2, &v27, &v22, a4);
  icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v22);
  icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)&v27);
  return icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v32);
}

uint64_t icu::DateIntervalFormat::splitPatternInto2Part( icu::DateIntervalFormat *this, const icu::UnicodeString *a2)
{
  unsigned int v2 = 0;
  int v3 = 0;
  unsigned int v4 = 0;
  BOOL v5 = 0;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  memset(v17, 0, 58);
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  int v7 = v6 >> 5;
  int v8 = *((_DWORD *)this + 3);
  int v9 = (char *)this + 10;
  if ((v6 & 2) == 0) {
    int v9 = (char *)*((void *)this + 3);
  }
  if ((v6 & 0x8000) != 0) {
    goto LABEL_6;
  }
LABEL_4:
  unsigned int v10 = v6 >> 5;
  if ((int)v4 < v7)
  {
    while (1)
    {
      if (v10 <= v4) {
        int v11 = 0xFFFF;
      }
      else {
        int v11 = *(unsigned __int16 *)&v9[2 * v4];
      }
      if (v11 != v2 && v3 >= 1)
      {
        uint64_t v12 = v2 - 65LL;
        if (*((_BYTE *)v17 + v12)) {
          return v4 - v3;
        }
        int v3 = 0;
        *((_BYTE *)v17 + v12) = 1;
      }

      if (v11 == 39) {
        break;
      }
      if ((v11 & 0xFFFFFFDF) - 65 < 0x1A)
      {
        int v15 = v3 + 1;
      }

      else
      {
        int v11 = v2;
        int v15 = v3;
      }

      if (!v5)
      {
        unsigned int v2 = v11;
        int v3 = v15;
      }

      BOOL v5 = v5;
LABEL_29:
      ++v4;
      if ((v6 & 0x8000) == 0) {
        goto LABEL_4;
      }
LABEL_6:
      unsigned int v10 = v8;
    }

    uint64_t v13 = (int)v4 + 1LL;
    if ((v6 & 0x8000) != 0)
    {
      unsigned int v14 = v8;
      if ((int)v13 >= v8)
      {
LABEL_28:
        BOOL v5 = !v5;
        goto LABEL_29;
      }
    }

    else
    {
      unsigned int v14 = v6 >> 5;
    }

    if (v14 > v13 && *(_WORD *)&v9[2 * v13] == 39)
    {
      ++v4;
      goto LABEL_29;
    }

    goto LABEL_28;
  }

uint64_t icu::DateIntervalFormat::adjustFieldWidth( icu::DateIntervalFormat *this, const icu::UnicodeString *a2, UChar **a3, const icu::UnicodeString *a4, int a5, uint64_t a6, icu::UnicodeString *a7)
{
  int v9 = (int)a4;
  uint64_t v118 = *MEMORY[0x1895F89C0];
  icu::UnicodeString::operator=((UChar **)a6, a3);
  uint64_t v117 = 0LL;
  memset(v116, 0, sizeof(v116));
  uint64_t v115 = 0LL;
  __int128 v113 = 0u;
  __int128 v114 = 0u;
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  memset(v108, 0, sizeof(v108));
  icu::DateIntervalInfo::parseSkeleton((uint64_t)this, (const icu::UnicodeString *)v116, v12);
  icu::DateIntervalInfo::parseSkeleton((uint64_t)a2, (const icu::UnicodeString *)v108, v13);
  if (a5)
  {
    icu::UnicodeString::UnicodeString((uint64_t)v107, (uint64_t)&unk_180A47F94, 0xFFFFFFFFLL);
    uint64_t v105 = off_18971B688;
    __int16 v106 = 2;
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v14);
    icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v107);
    icu::UnicodeString::UnicodeString((uint64_t)v107, (uint64_t)&unk_180A47F9A, 0xFFFFFFFFLL);
    uint64_t v105 = off_18971B688;
    __int16 v106 = 2;
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v17);
    icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v107);
    icu::UnicodeString::UnicodeString((uint64_t)v107, (uint64_t)&unk_180A47FA0, 0xFFFFFFFFLL);
    uint64_t v105 = off_18971B688;
    __int16 v106 = 2;
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v20);
    icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v107);
    icu::UnicodeString::UnicodeString((uint64_t)v107, (uint64_t)&unk_180A47FA6, 0xFFFFFFFFLL);
    uint64_t v105 = off_18971B688;
    __int16 v106 = 2;
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v23);
    icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v25, (icu::UnicodeString *)v107);
    icu::UnicodeString::UnicodeString((uint64_t)v107, 97);
    uint64_t v105 = off_18971B688;
    __int16 v106 = 2;
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v26);
    icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)v107);
    icu::UnicodeString::UnicodeString((uint64_t)v107, (uint64_t)L"  ");
    icu::UnicodeString::UnicodeString((uint64_t)&v105, (uint64_t)" ");
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v29);
    icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)v107);
    icu::UnicodeString::UnicodeString((uint64_t)v107, (uint64_t)" ");
    icu::UnicodeString::UnicodeString((uint64_t)&v105, (uint64_t)"\t ");
    icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v32);
    icu::UnicodeString::~UnicodeString(v33, (icu::UnicodeString *)&v105);
    icu::UnicodeString::~UnicodeString(v34, (icu::UnicodeString *)v107);
    icu::UnicodeString::trim((icu::UnicodeString *)a6);
  }

  if (v9 == 2)
  {
    unsigned int v35 = *((unsigned __int16 *)this + 4);
    int v36 = (__int16)v35;
    int32_t v37 = v35 >> 5;
    if (v36 >= 0) {
      int32_t v38 = v37;
    }
    else {
      int32_t v38 = *((_DWORD *)this + 3);
    }
    if (icu::UnicodeString::doIndexOf((uint64_t)this, 0x7Au, 0, v38) != -1)
    {
      icu::UnicodeString::UnicodeString((uint64_t)v107, 118);
      icu::UnicodeString::UnicodeString((uint64_t)&v105, 122);
      icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v39);
      icu::UnicodeString::~UnicodeString(v40, (icu::UnicodeString *)&v105);
      icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)v107);
    }

    unsigned int v42 = *((unsigned __int16 *)this + 4);
    int v43 = (__int16)v42;
    int32_t v44 = v42 >> 5;
    if (v43 >= 0) {
      int32_t v45 = v44;
    }
    else {
      int32_t v45 = *((_DWORD *)this + 3);
    }
    if (icu::UnicodeString::doIndexOf((uint64_t)this, 0x4Bu, 0, v45) != -1)
    {
      icu::UnicodeString::UnicodeString((uint64_t)v107, 104);
      icu::UnicodeString::UnicodeString((uint64_t)&v105, 75);
      icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v46);
      icu::UnicodeString::~UnicodeString(v47, (icu::UnicodeString *)&v105);
      icu::UnicodeString::~UnicodeString(v48, (icu::UnicodeString *)v107);
    }

    unsigned int v49 = *((unsigned __int16 *)this + 4);
    int v50 = (__int16)v49;
    int32_t v51 = v49 >> 5;
    if (v50 >= 0) {
      int32_t v52 = v51;
    }
    else {
      int32_t v52 = *((_DWORD *)this + 3);
    }
    if (icu::UnicodeString::doIndexOf((uint64_t)this, 0x6Bu, 0, v52) != -1)
    {
      icu::UnicodeString::UnicodeString((uint64_t)v107, 72);
      icu::UnicodeString::UnicodeString((uint64_t)&v105, 107);
      icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v53);
      icu::UnicodeString::~UnicodeString(v54, (icu::UnicodeString *)&v105);
      icu::UnicodeString::~UnicodeString(v55, (icu::UnicodeString *)v107);
    }

    unsigned int v56 = *((unsigned __int16 *)this + 4);
    int v57 = (__int16)v56;
    int32_t v58 = v56 >> 5;
    if (v57 >= 0) {
      int32_t v59 = v58;
    }
    else {
      int32_t v59 = *((_DWORD *)this + 3);
    }
    if (icu::UnicodeString::doIndexOf((uint64_t)this, 0x62u, 0, v59) != -1)
    {
      icu::UnicodeString::UnicodeString((uint64_t)v107, 97);
      icu::UnicodeString::UnicodeString((uint64_t)&v105, 98);
      icu::DateIntervalFormat::findReplaceInPattern( (icu::DateIntervalFormat *)a6,  (icu::UnicodeString *)v107,  (const icu::UnicodeString *)&v105,  v60);
      icu::UnicodeString::~UnicodeString(v61, (icu::UnicodeString *)&v105);
      icu::UnicodeString::~UnicodeString(v62, (icu::UnicodeString *)v107);
    }
  }

  unsigned int v63 = *(unsigned __int16 *)(a6 + 8);
  int v64 = (__int16)v63;
  int32_t v65 = v63 >> 5;
  if (v64 >= 0) {
    int32_t v66 = v65;
  }
  else {
    int32_t v66 = *(_DWORD *)(a6 + 12);
  }
  unsigned int v67 = *(unsigned __int16 *)(a6 + 8);
  int v68 = (__int16)v67;
  int32_t v69 = v67 >> 5;
  if (v68 >= 0) {
    int32_t v70 = v69;
  }
  else {
    int32_t v70 = *(_DWORD *)(a6 + 12);
  }
  uint64_t result = icu::UnicodeString::doIndexOf(a6, 0x62u, 0, v70);
  if ((_DWORD)result != -1 && !DWORD1(v109)) {
    DWORD1(v109) = 1;
  }
  unsigned int v72 = *(unsigned __int16 *)(a6 + 8);
  int v73 = (__int16)v72;
  int v74 = v72 >> 5;
  if (v73 >= 0) {
    int v75 = v74;
  }
  else {
    int v75 = *(_DWORD *)(a6 + 12);
  }
  if (v75 >= 1)
  {
    BOOL v76 = 0;
    unsigned int v77 = 0;
    uint64_t v78 = 0LL;
    int v79 = 0;
    while (1)
    {
      unsigned int v80 = *(unsigned __int16 *)(a6 + 8);
      if ((v80 & 0x8000u) == 0) {
        unsigned int v81 = v80 >> 5;
      }
      else {
        unsigned int v81 = *(_DWORD *)(a6 + 12);
      }
      if (v81 <= v78)
      {
        int v83 = 0xFFFF;
      }

      else
      {
        if ((v80 & 2) != 0) {
          uint64_t v82 = a6 + 10;
        }
        else {
          uint64_t v82 = *(void *)(a6 + 24);
        }
        int v83 = *(unsigned __int16 *)(v82 + 2LL * (int)v78);
      }

      if (v83 != v77 && v79 >= 1)
      {
        if (v77 == 76) {
          unsigned int v84 = 77;
        }
        else {
          unsigned int v84 = v77;
        }
        uint64_t v85 = 4LL * v84 - 260;
        int v86 = *(_DWORD *)((char *)v108 + v85);
        int v87 = *(_DWORD *)((char *)v116 + v85);
        if (v86 != v79 || v87 <= v86)
        {
          int v79 = 0;
        }

        else
        {
          int v89 = v87 - v79;
          if (v87 - v79 >= 1)
          {
            int v90 = v87 - v79;
            do
            {
              v107[0] = v77;
              uint64_t result = icu::UnicodeString::doReplace(a6, v78, 0LL, (uint64_t)v107, 0, 1LL);
              --v90;
            }

            while (v90);
          }

          int v79 = 0;
          LODWORD(v78) = v89 + v78;
          v75 += v89;
        }
      }

      if (v83 != 39)
      {
        unsigned int v94 = (v83 & 0xFFFFFFDF) - 65;
        BOOL v95 = v94 >= 0x1A;
        if (v94 >= 0x1A) {
          int v96 = v79;
        }
        else {
          int v96 = v79 + 1;
        }
        if (v95) {
          int v97 = v77;
        }
        else {
          int v97 = v83;
        }
        if (!v76)
        {
          int v79 = v96;
          unsigned int v77 = v97;
        }

        BOOL v76 = v76;
        goto LABEL_86;
      }

      int v91 = v78 + 1;
      unsigned int v92 = *(unsigned __int16 *)(a6 + 8);
      if (*(__int16 *)(a6 + 8) < 0)
      {
        unsigned int v93 = *(_DWORD *)(a6 + 12);
      }

      else
      {
        unsigned int v93 = v92 >> 5;
      }

      if (v93 <= v91
        || ((v92 & 2) != 0 ? (uint64_t v98 = a6 + 10) : (uint64_t v98 = *(void *)(a6 + 24)), *(_WORD *)(v98 + 2LL * v91) != 39))
      {
LABEL_85:
        BOOL v76 = !v76;
        goto LABEL_86;
      }

      LODWORD(v78) = v78 + 1;
LABEL_86:
      uint64_t v78 = (v78 + 1);
      if ((int)v78 >= v75)
      {
        if (v79 >= 1)
        {
          if (v77 == 76) {
            unsigned int v99 = 77;
          }
          else {
            unsigned int v99 = v77;
          }
          uint64_t v100 = 4LL * v99 - 260;
          int v101 = *(_DWORD *)((char *)v108 + v100);
          int v102 = *(_DWORD *)((char *)v116 + v100);
          if (v101 == v79 && v102 > v101)
          {
            int v104 = v102 - v79;
            if (v102 - v79 >= 1)
            {
              do
              {
                v107[0] = v77;
                uint64_t result = icu::UnicodeString::doAppend(a6, (uint64_t)v107, 0, 1LL);
                --v104;
              }

              while (v104);
            }
          }
        }

        return result;
      }
    }
  }

  return result;
}

void *icu::DateIntervalFormat::fallbackFormatRange( icu::DateIntervalFormat *this, icu::Calendar *a2, icu::Calendar *a3, icu::UnicodeString *a4, signed __int8 *a5, icu::FieldPositionHandler *a6, UErrorCode *a7)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  __int128 v42 = 0u;
  uint64_t v45 = 0LL;
  __int128 v44 = 0u;
  __int128 v43 = 0u;
  __int128 v41 = (UChar *)off_18971B688;
  LOWORD(v42) = 2;
  icu::DateIntervalInfo::getFallbackIntervalPattern(*((UChar ***)this + 41), &v41);
  v36[0] = 0LL;
  __int128 v37 = 0u;
  uint64_t v40 = 0LL;
  __int128 v39 = 0u;
  __int128 v38 = 0u;
  v36[1] = off_18971B688;
  LOWORD(v37) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v36,  (const icu::UnicodeString *)&v41,  2,  2,  0,  a7);
  if (*(int *)a7 <= 0)
  {
    uint64_t __b = 0LL;
    memset(v34, 0, sizeof(v34));
    sub_1808E5E78(&__b, (uint64_t)v36, 2, (uint64_t)v34);
    int v30 = 0;
    int32_t v14 = __b;
    int32_t v15 = HIDWORD(__b);
    if ((int)__b >= SHIDWORD(__b))
    {
      *a5 = 1;
      icu::UnicodeString::tempSubString((icu::UnicodeString *)v34, 0, v15, (icu::UnicodeString *)v31);
      if ((v32 & 0x8000u) == 0) {
        uint64_t v21 = v32 >> 5;
      }
      else {
        uint64_t v21 = v33;
      }
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)v31, 0, v21);
      icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v31);
      icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), a3, a4, a6, a7);
      icu::UnicodeString::tempSubString( (icu::UnicodeString *)v34,  SHIDWORD(__b),  __b - HIDWORD(__b),  (icu::UnicodeString *)v31);
      if ((v32 & 0x8000u) == 0) {
        uint64_t v23 = v32 >> 5;
      }
      else {
        uint64_t v23 = v33;
      }
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)v31, 0, v23);
      icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)v31);
      (*(void (**)(void, uint64_t, int *))(**((void **)this + 42) + 200LL))( *((void *)this + 42),  256LL,  &v30);
      icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), a2, a4, a6, a7);
      int v20 = __b;
    }

    else
    {
      *a5 = 0;
      icu::UnicodeString::tempSubString((icu::UnicodeString *)v34, 0, v14, (icu::UnicodeString *)v31);
      if ((v32 & 0x8000u) == 0) {
        uint64_t v16 = v32 >> 5;
      }
      else {
        uint64_t v16 = v33;
      }
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)v31, 0, v16);
      icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v31);
      icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), a2, a4, a6, a7);
      icu::UnicodeString::tempSubString((icu::UnicodeString *)v34, __b, HIDWORD(__b) - __b, (icu::UnicodeString *)v31);
      if ((v32 & 0x8000u) == 0) {
        uint64_t v18 = v32 >> 5;
      }
      else {
        uint64_t v18 = v33;
      }
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)v31, 0, v18);
      icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v31);
      (*(void (**)(void, uint64_t, int *))(**((void **)this + 42) + 200LL))( *((void *)this + 42),  256LL,  &v30);
      icu::SimpleDateFormat::_format(*((icu::SimpleDateFormat **)this + 42), a3, a4, a6, a7);
      int v20 = HIDWORD(__b);
    }

    icu::UnicodeString::tempSubString((icu::UnicodeString *)v34, v20, v20 ^ 0x7FFFFFFF, (icu::UnicodeString *)v31);
    if ((v32 & 0x8000u) == 0) {
      uint64_t v25 = v32 >> 5;
    }
    else {
      uint64_t v25 = v33;
    }
    icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)v31, 0, v25);
    icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v31);
    icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)v34);
  }

  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v36);
  return icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v41);
}

uint64_t sub_1808E5E78@<X0>(void *__b@<X1>, uint64_t a2@<X0>, int a3@<W2>, uint64_t a4@<X8>)
{
  unsigned int v6 = *(unsigned __int16 *)(a2 + 16);
  if ((v6 & 0x11) == 0)
  {
    if ((v6 & 2) != 0)
    {
      int v7 = (unsigned __int16 *)(a2 + 18);
      if ((v6 & 0x8000) == 0) {
        goto LABEL_6;
      }
    }

    else
    {
      int v7 = *(unsigned __int16 **)(a2 + 32);
      if ((v6 & 0x8000) == 0) {
        goto LABEL_6;
      }
    }

icu::UnicodeString *icu::DateIntervalFormat::findReplaceInPattern( icu::DateIntervalFormat *this, icu::UnicodeString *a2, const icu::UnicodeString *a3, const icu::UnicodeString *a4)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  int v8 = (__int16)v7;
  int32_t v9 = v7 >> 5;
  if (v8 >= 0) {
    int32_t v10 = v9;
  }
  else {
    int32_t v10 = *((_DWORD *)this + 3);
  }
  uint64_t v11 = icu::UnicodeString::doIndexOf((uint64_t)this, 0x27u, 0, v10);
  if ((_DWORD)v11 == -1)
  {
    unsigned int v44 = *((unsigned __int16 *)this + 4);
    int v45 = (__int16)v44;
    int32_t v46 = v44 >> 5;
    if (v45 >= 0) {
      int32_t v47 = v46;
    }
    else {
      int32_t v47 = *((_DWORD *)this + 3);
    }
    unsigned int v48 = *((unsigned __int16 *)a2 + 4);
    int v49 = (__int16)v48;
    unsigned int v50 = v48 >> 5;
    if (v49 >= 0) {
      uint64_t v51 = v50;
    }
    else {
      uint64_t v51 = *((unsigned int *)a2 + 3);
    }
    unsigned int v52 = *((unsigned __int16 *)a3 + 4);
    int v53 = (__int16)v52;
    int v54 = v52 >> 5;
    if (v53 < 0) {
      int v54 = *((_DWORD *)a3 + 3);
    }
    return icu::UnicodeString::findAndReplace(this, 0, v47, a2, 0, v51, a3, 0, v54);
  }

  else
  {
    uint64_t v12 = v11;
    __int128 v59 = 0u;
    uint64_t v62 = 0LL;
    __int128 v61 = 0u;
    __int128 v60 = 0u;
    int32_t v58 = (UChar *)off_18971B688;
    LOWORD(v59) = 2;
    memset(v57, 0, sizeof(v57));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v57, (UChar **)this);
    while ((v12 & 0x80000000) == 0)
    {
      int v13 = v12 + 1;
      if (SWORD4(v57[0]) < 0)
      {
        unsigned int v14 = HIDWORD(v57[0]);
        if (SHIDWORD(v57[0]) >= v13) {
          int v15 = v12 + 1;
        }
        else {
          int v15 = HIDWORD(v57[0]);
        }
      }

      else
      {
        unsigned int v14 = WORD4(v57[0]) >> 5;
        if (v14 >= v13) {
          int v15 = v12 + 1;
        }
        else {
          int v15 = WORD4(v57[0]) >> 5;
        }
      }

      int v16 = icu::UnicodeString::doIndexOf((uint64_t)v57, 0x27u, v15, v14 - v15);
      if (v16 == -1)
      {
        int v17 = WORD4(v57[0]) >> 5;
        if (SWORD4(v57[0]) < 0) {
          int v17 = HIDWORD(v57[0]);
        }
        int v16 = v17 - 1;
      }

      memset(v56, 0, sizeof(v56));
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)v56, (const icu::UnicodeString *)v57, 0, v12);
      memset(v55, 0, sizeof(v55));
      icu::UnicodeString::UnicodeString( (icu::UnicodeString *)v55,  (const icu::UnicodeString *)v57,  v12,  (v16 - v12 + 1));
      if ((SWORD4(v56[0]) & 0x8000u) == 0) {
        int32_t v18 = WORD4(v56[0]) >> 5;
      }
      else {
        int32_t v18 = HIDWORD(v56[0]);
      }
      unsigned int v19 = *((unsigned __int16 *)a2 + 4);
      int v20 = (__int16)v19;
      unsigned int v21 = v19 >> 5;
      if (v20 >= 0) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = *((unsigned int *)a2 + 3);
      }
      unsigned int v23 = *((unsigned __int16 *)a3 + 4);
      int v24 = (__int16)v23;
      int v25 = v23 >> 5;
      if (v24 < 0) {
        int v25 = *((_DWORD *)a3 + 3);
      }
      icu::UnicodeString::findAndReplace((icu::UnicodeString *)v56, 0, v18, a2, 0, v22, a3, 0, v25);
      if ((SWORD4(v56[0]) & 0x8000u) == 0) {
        uint64_t v26 = WORD4(v56[0]) >> 5;
      }
      else {
        uint64_t v26 = HIDWORD(v56[0]);
      }
      icu::UnicodeString::doAppend((uint64_t)&v58, (const icu::UnicodeString *)v56, 0, v26);
      if ((SWORD4(v55[0]) & 0x8000u) == 0) {
        uint64_t v27 = WORD4(v55[0]) >> 5;
      }
      else {
        uint64_t v27 = HIDWORD(v55[0]);
      }
      icu::UnicodeString::doAppend((uint64_t)&v58, (const icu::UnicodeString *)v55, 0, v27);
      if (v16 == 2147483646)
      {
        if ((BYTE8(v57[0]) & 1) != 0) {
          unsigned int v28 = 2;
        }
        else {
          unsigned int v28 = BYTE8(v57[0]) & 0x1F;
        }
        WORD4(v57[0]) = v28;
      }

      else
      {
        icu::UnicodeString::doReplace((uint64_t)v57, 0LL, (v16 + 1), 0LL, 0, 0LL);
        unsigned int v28 = WORD4(v57[0]);
        if ((WORD4(v57[0]) & 0x8000) != 0)
        {
          int32_t v29 = HIDWORD(v57[0]);
          goto LABEL_38;
        }
      }

      int32_t v29 = v28 >> 5;
LABEL_38:
      uint64_t v12 = icu::UnicodeString::doIndexOf((uint64_t)v57, 0x27u, 0, v29);
      icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)v55);
      icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)v56);
    }

    if ((SWORD4(v57[0]) & 0x8000u) == 0) {
      int32_t v32 = WORD4(v57[0]) >> 5;
    }
    else {
      int32_t v32 = HIDWORD(v57[0]);
    }
    unsigned int v33 = *((unsigned __int16 *)a2 + 4);
    int v34 = (__int16)v33;
    unsigned int v35 = v33 >> 5;
    if (v34 >= 0) {
      uint64_t v36 = v35;
    }
    else {
      uint64_t v36 = *((unsigned int *)a2 + 3);
    }
    unsigned int v37 = *((unsigned __int16 *)a3 + 4);
    int v38 = (__int16)v37;
    int v39 = v37 >> 5;
    if (v38 < 0) {
      int v39 = *((_DWORD *)a3 + 3);
    }
    icu::UnicodeString::findAndReplace((icu::UnicodeString *)v57, 0, v32, a2, 0, v36, a3, 0, v39);
    if ((SWORD4(v57[0]) & 0x8000u) == 0) {
      uint64_t v40 = WORD4(v57[0]) >> 5;
    }
    else {
      uint64_t v40 = HIDWORD(v57[0]);
    }
    icu::UnicodeString::doAppend((uint64_t)&v58, (const icu::UnicodeString *)v57, 0, v40);
    icu::UnicodeString::operator=((UChar **)this, &v58);
    icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)v57);
    return (icu::UnicodeString *)icu::UnicodeString::~UnicodeString(v42, (icu::UnicodeString *)&v58);
  }

void *icu::DateIntervalInfo::getStaticClassID(icu::DateIntervalInfo *this)
{
  return &unk_18C5353B8;
}

void *icu::DateIntervalInfo::getDynamicClassID(icu::DateIntervalInfo *this)
{
  return &unk_18C5353B8;
}

icu::DateIntervalInfo *icu::DateIntervalInfo::DateIntervalInfo(icu::DateIntervalInfo *this, UErrorCode *a2)
{
  *(void *)this = off_189722FD8;
  unsigned int v4 = (icu::DateIntervalInfo *)icu::UnicodeString::UnicodeString((uint64_t)this + 8, (uint64_t)L"{0}  {1}");
  *((_BYTE *)this + 72) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 10) = icu::DateIntervalInfo::initHash(v4, a2);
  return this;
}

{
  icu::DateIntervalInfo *v4;
  *(void *)this = off_189722FD8;
  unsigned int v4 = (icu::DateIntervalInfo *)icu::UnicodeString::UnicodeString((uint64_t)this + 8, (uint64_t)L"{0}  {1}");
  *((_BYTE *)this + 72) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 10) = icu::DateIntervalInfo::initHash(v4, a2);
  return this;
}

uint64_t *icu::DateIntervalInfo::initHash(icu::DateIntervalInfo *this, UErrorCode *a2)
{
  unsigned int v2 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v2 <= 0)
  {
    unsigned int v4 = (int32x2_t *)icu::UMemory::operator new(v2, (icu::UMemory *)0x58, (unint64_t)a2);
    BOOL v5 = (uint64_t *)v4;
    if (!v4)
    {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      return v5;
    }

    *unsigned int v4 = 0LL;
    if (*(int *)a2 <= 0)
    {
      unsigned int v6 = v4 + 1;
      uhash_init(v4 + 1, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0LL, (int *)a2);
      if (*(int *)a2 <= 0)
      {
        *BOOL v5 = (uint64_t)v6;
        uhash_setKeyDeleter((uint64_t)(v5 + 1), (uint64_t)uprv_deleteUObject);
        if (*(int *)a2 < 1)
        {
          uhash_setValueComparator(*v5, (uint64_t)sub_1808E786C);
          return v5;
        }
      }

      if (*v5) {
        uhash_close((_BYTE *)*v5);
      }
    }

    icu::UMemory::operator delete(v5);
  }

  return 0LL;
}

icu::DateIntervalInfo *icu::DateIntervalInfo::DateIntervalInfo( icu::DateIntervalInfo *this, const icu::Locale *a2, UErrorCode *a3)
{
  *(void *)this = off_189722FD8;
  icu::UnicodeString::UnicodeString((uint64_t)this + 8, (uint64_t)L"{0}  {1}");
  *((_BYTE *)this + 72) = 0;
  *((void *)this + 10) = 0LL;
  icu::DateIntervalInfo::initializeData(this, a2, a3);
  return this;
}

{
  *(void *)this = off_189722FD8;
  icu::UnicodeString::UnicodeString((uint64_t)this + 8, (uint64_t)L"{0}  {1}");
  *((_BYTE *)this + 72) = 0;
  *((void *)this + 10) = 0LL;
  icu::DateIntervalInfo::initializeData(this, a2, a3);
  return this;
}

void icu::DateIntervalInfo::initializeData( icu::DateIntervalInfo *this, const icu::Locale *a2, UErrorCode *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  *((void *)this + 10) = icu::DateIntervalInfo::initHash(this, a3);
  if (*(int *)a3 <= 0)
  {
    unsigned int v6 = (char *)*((void *)a2 + 5);
    __int16 v45 = 0;
    memset(v44, 0, sizeof(v44));
    ures_getFunctionalEquivalent( (uint64_t)v44,  258LL,  0LL,  (uint64_t)"calendar",  (uint64_t)"calendar",  (uint64_t)v6,  0LL,  0LL,  (int *)a3);
    HIBYTE(v45) = 0;
    memset(&v43[1], 0, 56);
    v43[0] = (char *)&v43[1] + 5;
    LODWORD(v43[1]) = 40;
    __int128 v37 = 0uLL;
    icu::CharStringByteSink::CharStringByteSink(&v37, (uint64_t)v43);
    ulocimp_getKeywordValue(v44, "calendar", (uint64_t)&v37, (int *)a3);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v37);
    else {
      unsigned int v7 = "gregorian";
    }
    *a3 = U_ZERO_ERROR;
    BOOL v33 = 0;
    uint64_t v8 = ures_open(0LL, v6, (int *)a3);
    uint64_t v9 = ures_openWithCountryFallback(0LL, v6, &v33, (int *)a3);
    if (*(int *)a3 <= 0)
    {
      uint64_t v10 = v9;
      uint64_t v11 = ures_getByKeyWithFallback(v8, "calendar", 0LL, a3);
      uint64_t v12 = ures_getByKeyWithFallback(v10, "calendar", 0LL, a3);
      if (*(int *)a3 <= 0)
      {
        uint64_t v27 = v10;
        uint64_t v28 = v8;
        int v32 = 0;
        uint64_t v13 = ures_getByKeyWithFallback(v11, v7, 0LL, a3);
        uint64_t v14 = ures_getByKeyWithFallback(v13, "intervalFormats", 0LL, a3);
        uint64_t v15 = v14;
        if (*(int *)a3 <= 0)
        {
          StringByKeyWithFallback = ures_getStringByKeyWithFallback(v14, "fallback", &v32, a3);
          if (*(int *)a3 <= 0)
          {
            if (StringByKeyWithFallback)
            {
              __int128 v39 = 0u;
              __int128 v40 = 0u;
              __int128 v37 = 0u;
              __int128 v38 = 0u;
              uint64_t v31 = StringByKeyWithFallback;
              icu::UnicodeString::UnicodeString(&v37, 1LL, &v31);
              icu::DateIntervalInfo::setFallbackIntervalPattern(this, (const icu::UnicodeString *)&v37, a3);
              icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v37);
            }
          }
        }

        ures_close(v15);
        ures_close(v13);
        if (v33) {
          uint64_t v18 = v12;
        }
        else {
          uint64_t v18 = v11;
        }
        while (v18)
        {
          uint64_t v42 = 0LL;
          __int128 v40 = 0u;
          __int128 v41 = 0u;
          __int128 v38 = 0u;
          __int128 v39 = 0u;
          __int128 v37 = 0u;
          BOOL v19 = icu::Locale::isRightToLeft(a2) == 0;
          *(void *)&__int128 v37 = off_189723010;
          *((void *)&v37 + sub_1808F7164((uint64_t)v14, 1) = this;
          icu::UnicodeString::UnicodeString(&v38, v7, 0xFFFFFFFFLL, 0LL);
          LOBYTE(v42) = v18 != v11;
          BYTE1(v42) = v19;
          uint64_t v30 = 0LL;
          memset(v29, 0, sizeof(v29));
          uint64_t v20 = *(unsigned int *)a3;
          if ((int)v20 < 1)
          {
            uhash_init( (int32x2_t *)v29 + 1,  (uint64_t)uhash_hashUnicodeString,  (uint64_t)uhash_compareUnicodeString,  0LL,  (int *)a3);
            uint64_t v20 = *(unsigned int *)a3;
            if ((int)v20 <= 0)
            {
              *(void *)&v29[0] = (char *)v29 + 8;
              uhash_setKeyDeleter((uint64_t)v29 + 8, (uint64_t)uprv_deleteUObject);
              uint64_t v20 = *(unsigned int *)a3;
              if ((int)v20 <= 0)
              {
                while (1)
                {
                  uint64_t v20 = WORD4(v38);
                  if ((BYTE8(v38) & 1) != 0) {
                    break;
                  }
                  if (uhash_geti((uint64_t)v29 + 8, (uint64_t)&v38) == 1)
                  {
                    uint64_t v20 = 3LL;
                    *a3 = U_INVALID_FORMAT_ERROR;
                    break;
                  }

                  unsigned int v23 = (icu::UnicodeString *)icu::UMemory::operator new(v22, (icu::UMemory *)0x40, v21);
                  uint64_t v24 = (uint64_t)v23;
                  if (v23) {
                    icu::UnicodeString::UnicodeString(v23, (UChar **)&v38);
                  }
                  uhash_puti((uint64_t)v29 + 8, v24, 1u, (int *)a3);
                  uint64_t v20 = *(unsigned int *)a3;
                  if ((int)v20 <= 0)
                  {
                    int v36 = 0;
                    memset(&v34[1], 0, 48);
                    v34[0] = (char *)&v34[1] + 5;
                    LODWORD(v34[1]) = 40;
                    int v35 = 0;
                    icu::CharString::appendInvariantChars((icu::CharString *)v34, (const icu::UnicodeString *)&v38, a3);
                    UErrorCode v25 = *a3;
                    if (*(int *)a3 <= 0)
                    {
                      uint64_t v26 = (char *)v34[0];
                      icu::UnicodeString::setToBogus((icu::UnicodeString *)&v38);
                      ures_getAllItemsWithFallback(v18, v26, (uint64_t)&v37, (int *)a3);
                    }

                    uint64_t v20 = BYTE4(v34[1]);
                    if (BYTE4(v34[1])) {
                      uprv_free(v34[0]);
                    }
                    if (v25 < U_ILLEGAL_ARGUMENT_ERROR) {
                      continue;
                    }
                  }

                  break;
                }
              }
            }

            if (v18 == v11) {
              uint64_t v18 = 0LL;
            }
            else {
              uint64_t v18 = v11;
            }
            if (*(void *)&v29[0]) {
              uhash_close(*(_BYTE **)&v29[0]);
            }
          }

          else if (v18 == v11)
          {
            uint64_t v18 = 0LL;
          }

          else
          {
            uint64_t v18 = v11;
          }

          *(void *)&__int128 v37 = off_189723010;
          icu::UnicodeString::~UnicodeString((void *)v20, (icu::UnicodeString *)&v38);
          icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v37);
        }

        uint64_t v10 = v27;
        uint64_t v8 = v28;
      }

      ures_close(v11);
      ures_close(v8);
      ures_close(v12);
      ures_close(v10);
    }

    if (BYTE4(v43[1])) {
      uprv_free(v43[0]);
    }
  }

icu::UnicodeString *icu::DateIntervalInfo::setIntervalPattern( uint64_t a1, UChar **a2, unsigned int a3, UChar **a4, int *a5)
{
  if (a3 == 11)
  {
    icu::DateIntervalInfo::setIntervalPatternInternally(a1, a2, 9u, a4, a5);
    a3 = 10;
  }

  else if ((a3 & 0xFFFFFFFD) == 5)
  {
    a3 = 5;
  }

  return icu::DateIntervalInfo::setIntervalPatternInternally(a1, a2, a3, a4, a5);
}

icu::UnicodeString *icu::DateIntervalInfo::setIntervalPatternInternally( uint64_t a1, UChar **a2, unsigned int a3, UChar **a4, int *a5)
{
  uint64_t result = (icu::UnicodeString *)icu::DateIntervalInfo::calendarFieldToIntervalIndex(a3, a5);
  if (*a5 <= 0)
  {
    unsigned int v10 = result;
    uint64_t v11 = uhash_get(**(void **)(a1 + 80), (uint64_t)a2);
    if (v11)
    {
      return icu::UnicodeString::operator=((UChar **)(v11 + ((unint64_t)v10 << 6)), a4);
    }

    else
    {
      uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new[]((icu::UMemory *)0x250, v12);
      if (result)
      {
        *(_OWORD *)uint64_t result = xmmword_180A37F60;
        uint64_t v13 = (uint64_t)result + 16;
        uint64_t v14 = (_WORD *)((char *)result + 16);
        do
        {
          *(void *)uint64_t v14 = off_18971B688;
          v14[4] = 2;
          v14 += 32;
        }

        while (v14 != (_WORD *)((char *)result + 592));
        icu::UnicodeString::operator=((UChar **)(v13 + ((unint64_t)v10 << 6)), a4);
        uint64_t v15 = *(uint64_t **)(a1 + 80);
        uint64_t v16 = *v15;
        uint64_t v18 = (icu::UnicodeString *)icu::UMemory::operator new(v15, (icu::UMemory *)0x40, v17);
        uint64_t v19 = (uint64_t)v18;
        if (v18) {
          icu::UnicodeString::UnicodeString(v18, a2);
        }
        return (icu::UnicodeString *)uhash_put(v16, v19, v13, a5);
      }

      else
      {
        *a5 = 7;
      }
    }
  }

  return result;
}

icu::UnicodeString *icu::DateIntervalInfo::setFallbackIntervalPattern( icu::UnicodeString *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v5 = (uint64_t)this;
    if (*((__int16 *)a2 + 4) < 0)
    {
      int v7 = *((_DWORD *)a2 + 3);
      int v6 = v7 & (v7 >> 31);
    }

    else
    {
      int v6 = 0;
      int v7 = *((unsigned __int16 *)a2 + 4) >> 5;
    }

    int v8 = icu::UnicodeString::indexOf((uint64_t)a2, (uint64_t)a01_5, 0, 3, v6, v7 - v6);
    unsigned int v9 = *((unsigned __int16 *)a2 + 4);
    if ((v9 & 0x8000) != 0)
    {
      int v11 = *((_DWORD *)a2 + 3);
      int v10 = v11 & (v11 >> 31);
    }

    else
    {
      int v10 = 0;
      int v11 = v9 >> 5;
    }

    this = (icu::UnicodeString *)icu::UnicodeString::indexOf((uint64_t)a2, (uint64_t)&a01_5[3], 0, 3, v10, v11 - v10);
    if (v8 == -1 || (_DWORD)this == -1)
    {
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      return icu::UnicodeString::operator=((UChar **)(v5 + 8), (UChar **)a2);
    }
  }

  return this;
}

uint64_t icu::DateIntervalInfo::DateIntervalInfo(uint64_t this, uint64_t a2)
{
  *(void *)this = off_189722FD8;
  *(void *)(this + 8) = off_18971B688;
  *(_WORD *)(this + 16) = 2;
  *(void *)(this + 80) = 0LL;
  return icu::DateIntervalInfo::operator=(this, a2);
}

{
  *(void *)this = off_189722FD8;
  *(void *)(this + 8) = off_18971B688;
  *(_WORD *)(this + 16) = 2;
  *(void *)(this + 80) = 0LL;
  return icu::DateIntervalInfo::operator=(this, a2);
}

uint64_t icu::DateIntervalInfo::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    UErrorCode v7 = U_ZERO_ERROR;
    icu::DateIntervalInfo::deleteHash(a1, *(uint64_t ***)(a1 + 80));
    inited = icu::DateIntervalInfo::initHash(v4, &v7);
    *(void *)(a1 + 80) = inited;
    icu::DateIntervalInfo::copyHash((uint64_t)inited, *(uint64_t ***)(a2 + 80), inited, (int *)&v7);
    if (v7 <= U_ZERO_ERROR)
    {
      icu::UnicodeString::operator=((UChar **)(a1 + 8), (UChar **)(a2 + 8));
      *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
    }
  }

  return a1;
}

void icu::DateIntervalInfo::deleteHash(uint64_t a1, uint64_t **a2)
{
  if (a2)
  {
    int v9 = -1;
    while (1)
    {
      uint64_t v4 = uhash_nextElement(*a2, &v9);
      if (!v4) {
        break;
      }
      uint64_t v5 = *(void *)(v4 + 8);
      if (v5)
      {
        int v6 = *(void **)(v5 - 8);
        if (v6)
        {
          uint64_t v7 = (void)v6 << 6;
          do
          {
            icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)(v5 - 64 + v7));
            v7 -= 64LL;
          }

          while (v7);
        }

        icu::UMemory::operator delete[]((void *)(v5 - 16));
      }
    }

    int v8 = *(_BYTE ***)(a1 + 80);
    if (v8)
    {
      if (*v8) {
        uhash_close(*v8);
      }
      icu::UMemory::operator delete(v8);
    }
  }

void icu::DateIntervalInfo::copyHash(uint64_t a1, uint64_t **a2, uint64_t *a3, int *a4)
{
  _BYTE v22[8] = *(UChar **)MEMORY[0x1895F89C0];
  if (*a4 <= 0)
  {
    int v21 = -1;
    if (a2)
    {
      do
      {
        uint64_t v7 = uhash_nextElement(*a2, &v21);
        if (!v7) {
          break;
        }
        uint64_t v10 = *(void *)(v7 + 8);
        int v9 = *(UChar ***)(v7 + 16);
        int v11 = (_OWORD *)icu::UMemory::operator new[]((icu::UMemory *)0x250, v8);
        if (!v11)
        {
          *a4 = 7;
          return;
        }

        *int v11 = xmmword_180A37F60;
        uint64_t v12 = (uint64_t)(v11 + 1);
        uint64_t v13 = v11 + 1;
        do
        {
          *(void *)uint64_t v13 = off_18971B688;
          *((_WORD *)v13 + 4) = 2;
          v13 += 4;
        }

        while (v13 != v11 + 37);
        for (uint64_t i = 0LL; i != 576; i += 64LL)
          icu::UnicodeString::operator=((UChar **)(v12 + i), (UChar **)(v10 + i));
        icu::UnicodeString::UnicodeString((icu::UnicodeString *)v22, v9);
        uint64_t v15 = *a3;
        uint64_t v18 = (icu::UnicodeString *)icu::UMemory::operator new(v17, (icu::UMemory *)0x40, v16);
        uint64_t v19 = (uint64_t)v18;
        if (v18) {
          icu::UnicodeString::UnicodeString(v18, v22);
        }
        uhash_put(v15, v19, v12, a4);
        icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v22);
      }

      while (*a4 < 1);
    }
  }

uint64_t *icu::DateIntervalInfo::clone@<X0>( icu::DateIntervalInfo *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x58, a2);
  if (result)
  {
    *uint64_t result = (uint64_t)off_189722FD8;
    result[1] = (uint64_t)off_18971B688;
    *((_WORD *)result + 8) = 2;
    result[10] = 0LL;
    return (uint64_t *)icu::DateIntervalInfo::operator=((uint64_t)result, (uint64_t)this);
  }

  return result;
}

void icu::DateIntervalInfo::~DateIntervalInfo(uint64_t ***this)
{
  this[10] = 0LL;
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)(this + 1));
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  void *v1;
  icu::DateIntervalInfo::~DateIntervalInfo(this);
  icu::UMemory::operator delete(v1);
}

BOOL icu::DateIntervalInfo::operator==(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 16);
  if ((v4 & 1) != 0)
  {
    if ((*(_WORD *)(a2 + 16) & 1) == 0) {
      return 0LL;
    }
LABEL_13:
    return 0LL;
  }

  if ((v4 & 0x8000) != 0) {
    int v5 = *(_DWORD *)(a1 + 20);
  }
  else {
    int v5 = v4 >> 5;
  }
  BOOL result = 0LL;
  unsigned int v7 = *(unsigned __int16 *)(a2 + 16);
  if ((v7 & 0x8000u) == 0) {
    unsigned int v8 = v7 >> 5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a2 + 20);
  }
  if ((v7 & 1) == 0 && v5 == v8)
  {
    BOOL result = icu::UnicodeString::doEquals((icu::UnicodeString *)(a1 + 8), (const icu::UnicodeString *)(a2 + 8), v5);
    if (result) {
      goto LABEL_13;
    }
  }

  return result;
}

UChar **icu::DateIntervalInfo::getIntervalPattern( uint64_t a1, uint64_t a2, unsigned int a3, UChar **a4, int *a5)
{
  if (*a5 <= 0)
  {
    uint64_t v9 = uhash_get(**(void **)(a1 + 80), a2);
    if (v9)
    {
      uint64_t v10 = v9;
      unsigned int v11 = icu::DateIntervalInfo::calendarFieldToIntervalIndex(a3, a5);
      if (*a5 <= 0)
      {
        unint64_t v12 = v10 + ((unint64_t)v11 << 6);
      }
    }
  }

  return a4;
}

uint64_t icu::DateIntervalInfo::calendarFieldToIntervalIndex(unsigned int a1, int *a2)
{
  if (*a2 > 0) {
    return 9LL;
  }
  if (a1 >= 0xF || ((0x7EA7u >> a1) & 1) == 0)
  {
    *a2 = 1;
    return 9LL;
  }

  return dword_180A38044[a1];
}

uint64_t icu::DateIntervalInfo::getDefaultOrder(icu::DateIntervalInfo *this)
{
  return *((char *)this + 72);
}

UChar **icu::DateIntervalInfo::getFallbackIntervalPattern(UChar **this, UChar **a2)
{
  icu::UnicodeString::operator=(a2, this + 1);
  return a2;
}

void sub_1808E71BC(uint64_t a1)
{
  *(void *)a1 = off_189723010;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 16));
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)a1);
}

void sub_1808E71EC(uint64_t a1)
{
  *(void *)a1 = off_189723010;
  icu::UnicodeString::~UnicodeString(off_189723010, (icu::UnicodeString *)(a1 + 16));
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)a1);
  icu::UMemory::operator delete(v2);
}

uint64_t icu::DateIntervalInfo::parseSkeleton(uint64_t this, const icu::UnicodeString *a2, int *a3)
{
  for (unint64_t i = 0LL; ; ++i)
  {
    int v4 = *(__int16 *)(this + 8);
    if (v4 < 0) {
      break;
    }
    unint64_t v5 = (unint64_t)*(unsigned __int16 *)(this + 8) >> 5;
LABEL_7:
    if (v5 <= i)
    {
      LOBYTE(v7) = -1;
    }

    else
    {
      if ((v4 & 2) != 0) {
        uint64_t v6 = this + 10;
      }
      else {
        uint64_t v6 = *(void *)(this + 24);
      }
      __int16 v7 = *(_WORD *)(v6 + 2 * i);
    }

    ++*((_DWORD *)a2 + (char)v7 - 65);
  }

  if ((uint64_t)i < *(int *)(this + 12))
  {
    unint64_t v5 = *(unsigned int *)(this + 12);
    goto LABEL_7;
  }

  return this;
}

BOOL icu::DateIntervalInfo::stringNumeric(icu::DateIntervalInfo *this, int a2, int a3)
{
  return a3 == 77 && ((int)this <= 2 && a2 > 2 || (int)this >= 3 && a2 < 3);
}

uint64_t icu::DateIntervalInfo::getBestSkeleton( uint64_t ***this, const icu::UnicodeString *a2, unsigned __int8 *a3)
{
  int v4 = (UChar **)a2;
  uint64_t v77 = *MEMORY[0x1895F89C0];
  uint64_t v76 = 0LL;
  memset(v75, 0, sizeof(v75));
  __int128 v69 = 0u;
  uint64_t v72 = 0LL;
  __int128 v71 = 0u;
  __int128 v70 = 0u;
  int v68 = (UChar *)off_18971B688;
  unsigned int v6 = *((unsigned __int16 *)a2 + 4);
  int v7 = (__int16)v6;
  int32_t v8 = v6 >> 5;
  if (v7 >= 0) {
    int32_t v9 = v8;
  }
  else {
    int32_t v9 = *((_DWORD *)a2 + 3);
  }
  LOWORD(v69) = 2;
  unsigned int v10 = *((unsigned __int16 *)v4 + 4);
  int v11 = (__int16)v10;
  unsigned int v12 = v10 >> 5;
  int32_t v13 = v11 >= 0 ? v12 : *((_DWORD *)v4 + 3);
  unsigned int v14 = *((unsigned __int16 *)v4 + 4);
  int v15 = (__int16)v14;
  unsigned int v16 = v14 >> 5;
  int32_t v17 = v15 >= 0 ? v16 : *((_DWORD *)v4 + 3);
  unsigned int v18 = *((unsigned __int16 *)v4 + 4);
  int v19 = (__int16)v18;
  unsigned int v20 = v18 >> 5;
  int32_t v21 = v19 >= 0 ? v20 : *((_DWORD *)v4 + 3);
  if (icu::UnicodeString::doIndexOf((uint64_t)v4, 0x61u, 0, v21) == -1
    && ((unsigned int v22 = *((unsigned __int16 *)v4 + 4), v23 = (__int16)v22, v24 = v22 >> 5, v23 >= 0)
      ? (int32_t v25 = v24)
      : (int32_t v25 = *((_DWORD *)v4 + 3)),
        icu::UnicodeString::doIndexOf((uint64_t)v4, 0x62u, 0, v25) == -1))
  {
    unsigned int v50 = 1;
  }

  else
  {
LABEL_21:
    icu::UnicodeString::operator=(&v68, v4);
    icu::UnicodeString::UnicodeString((uint64_t)v73, 122);
    icu::UnicodeString::UnicodeString((uint64_t)&v65, 118);
    if ((v69 & 0x8000u) == 0LL) {
      int32_t v27 = (unsigned __int16)v69 >> 5;
    }
    else {
      int32_t v27 = DWORD1(v69);
    }
    if ((SWORD4(v73[0]) & 0x8000u) == 0) {
      uint64_t v28 = WORD4(v73[0]) >> 5;
    }
    else {
      uint64_t v28 = HIDWORD(v73[0]);
    }
    int v29 = v66 >> 5;
    if ((v66 & 0x8000u) != 0) {
      int v29 = v67;
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)&v68,  0,  v27,  (const icu::UnicodeString *)v73,  0,  v28,  (const icu::UnicodeString *)&v65,  0,  v29);
    icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)&v65);
    icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)v73);
    icu::UnicodeString::UnicodeString((uint64_t)v73, 107);
    icu::UnicodeString::UnicodeString((uint64_t)&v65, 72);
    if ((v69 & 0x8000u) == 0LL) {
      int32_t v32 = (unsigned __int16)v69 >> 5;
    }
    else {
      int32_t v32 = DWORD1(v69);
    }
    if ((SWORD4(v73[0]) & 0x8000u) == 0) {
      uint64_t v33 = WORD4(v73[0]) >> 5;
    }
    else {
      uint64_t v33 = HIDWORD(v73[0]);
    }
    int v34 = v66 >> 5;
    if ((v66 & 0x8000u) != 0) {
      int v34 = v67;
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)&v68,  0,  v32,  (const icu::UnicodeString *)v73,  0,  v33,  (const icu::UnicodeString *)&v65,  0,  v34);
    icu::UnicodeString::~UnicodeString(v35, (icu::UnicodeString *)&v65);
    icu::UnicodeString::~UnicodeString(v36, (icu::UnicodeString *)v73);
    icu::UnicodeString::UnicodeString((uint64_t)v73, 75);
    icu::UnicodeString::UnicodeString((uint64_t)&v65, 104);
    if ((v69 & 0x8000u) == 0LL) {
      int32_t v37 = (unsigned __int16)v69 >> 5;
    }
    else {
      int32_t v37 = DWORD1(v69);
    }
    if ((SWORD4(v73[0]) & 0x8000u) == 0) {
      uint64_t v38 = WORD4(v73[0]) >> 5;
    }
    else {
      uint64_t v38 = HIDWORD(v73[0]);
    }
    int v39 = v66 >> 5;
    if ((v66 & 0x8000u) != 0) {
      int v39 = v67;
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)&v68,  0,  v37,  (const icu::UnicodeString *)v73,  0,  v38,  (const icu::UnicodeString *)&v65,  0,  v39);
    icu::UnicodeString::~UnicodeString(v40, (icu::UnicodeString *)&v65);
    icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)v73);
    icu::UnicodeString::UnicodeString((uint64_t)v73, 97);
    int32_t v65 = off_18971B688;
    unsigned __int16 v66 = 2;
    if ((v69 & 0x8000u) == 0LL) {
      int32_t v42 = (unsigned __int16)v69 >> 5;
    }
    else {
      int32_t v42 = DWORD1(v69);
    }
    if ((SWORD4(v73[0]) & 0x8000u) == 0) {
      uint64_t v43 = WORD4(v73[0]) >> 5;
    }
    else {
      uint64_t v43 = HIDWORD(v73[0]);
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)&v68,  0,  v42,  (const icu::UnicodeString *)v73,  0,  v43,  (const icu::UnicodeString *)&v65,  0,  0);
    icu::UnicodeString::~UnicodeString(v44, (icu::UnicodeString *)&v65);
    icu::UnicodeString::~UnicodeString(v45, (icu::UnicodeString *)v73);
    icu::UnicodeString::UnicodeString((uint64_t)v73, 98);
    int32_t v65 = off_18971B688;
    unsigned __int16 v66 = 2;
    if ((v69 & 0x8000u) == 0LL) {
      int32_t v46 = (unsigned __int16)v69 >> 5;
    }
    else {
      int32_t v46 = DWORD1(v69);
    }
    if ((SWORD4(v73[0]) & 0x8000u) == 0) {
      uint64_t v47 = WORD4(v73[0]) >> 5;
    }
    else {
      uint64_t v47 = HIDWORD(v73[0]);
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)&v68,  0,  v46,  (const icu::UnicodeString *)v73,  0,  v47,  (const icu::UnicodeString *)&v65,  0,  0);
    icu::UnicodeString::~UnicodeString(v48, (icu::UnicodeString *)&v65);
    icu::UnicodeString::~UnicodeString(v49, (icu::UnicodeString *)v73);
    unsigned int v50 = 0;
    int v4 = &v68;
  }

  icu::DateIntervalInfo::parseSkeleton((uint64_t)v4, (const icu::UnicodeString *)v75, v26);
  uint64_t v51 = 0LL;
  *a3 = 0;
  LODWORD(v65) = -1;
  int v52 = 56632;
  while (1)
  {
    uint64_t Element = uhash_nextElement(*this[10], (int *)&v65);
    if (!Element) {
      break;
    }
    uint64_t v55 = *(void *)(Element + 16);
    memset(v73, 0, sizeof(v73));
    uint64_t v74 = 0LL;
    icu::DateIntervalInfo::parseSkeleton(v55, (const icu::UnicodeString *)v73, v54);
    uint64_t v56 = 0LL;
    int v57 = 0;
    signed __int8 v58 = 1;
    do
    {
      int v59 = *(_DWORD *)((char *)v75 + v56);
      int v60 = *(_DWORD *)((char *)v73 + v56);
      int v61 = v59 - v60;
      if (v59 != v60)
      {
        if (v59 && v60)
        {
          if (v56 != 48 || (v59 <= 2 ? (BOOL v62 = v60 <= 2) : (BOOL v62 = 1), v62 && (v59 < 3 || v60 > 2)))
          {
            if (v61 < 0) {
              int v61 = v60 - v59;
            }
            v57 += v61;
          }

          else
          {
            v57 += 256;
          }
        }

        else
        {
          v57 += 4096;
          signed __int8 v58 = -1;
        }
      }

      v56 += 4LL;
    }

    while (v56 != 232);
    if (v57 >= v52)
    {
      if (!v57) {
        goto LABEL_81;
      }
    }

    else
    {
      int v52 = v57;
      uint64_t v51 = v55;
LABEL_81:
      if (!v57) {
        signed __int8 v58 = 0;
      }
      *a3 = v58;
      if (!v57) {
        break;
      }
    }
  }

  if (*a3 == 255) {
    uint64_t v63 = 1LL;
  }
  else {
    uint64_t v63 = v50;
  }
  if ((v63 & 1) == 0)
  {
    uint64_t v63 = 2LL;
    *a3 = 2;
  }

  icu::UnicodeString::~UnicodeString((void *)v63, (icu::UnicodeString *)&v68);
  return v51;
}

uint64_t sub_1808E786C(icu::UnicodeString *this, icu::UnicodeString *a2)
{
  unint64_t v4 = 0LL;
  while (1)
  {
    unsigned int v5 = *((unsigned __int16 *)this + 4);
    if ((v5 & 1) != 0)
    {
      uint64_t result = *((_WORD *)a2 + 4) & 1;
      goto LABEL_13;
    }

    int v6 = (v5 & 0x8000) != 0 ? *((_DWORD *)this + 3) : v5 >> 5;
    uint64_t result = 0LL;
    unsigned int v8 = *((unsigned __int16 *)a2 + 4);
    unsigned int v9 = (v8 & 0x8000u) == 0 ? v8 >> 5 : *((_DWORD *)a2 + 3);
    if ((v8 & 1) != 0 || v6 != v9) {
      return result;
    }
    uint64_t result = icu::UnicodeString::doEquals(this, a2, v6);
LABEL_13:
    if (v4 <= 7)
    {
      ++v4;
      a2 = (icu::UnicodeString *)((char *)a2 + 64);
      this = (icu::UnicodeString *)((char *)this + 64);
      if ((result & 1) != 0) {
        continue;
      }
    }

    return result;
  }

void *sub_1808E7910(void *result, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  __s1 = a2;
  if (*a5 > 0) {
    return result;
  }
  uint64_t v7 = (uint64_t)result;
  uint64_t v13 = 0LL;
  memset(v12, 0, sizeof(v12));
  uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v12,  a3,  a5);
  if (*a5 > 0) {
    return result;
  }
  uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v12, 0, (const char **)&__s1, a3);
  if (!(_DWORD)result) {
    return result;
  }
  unsigned int v8 = 1;
  while (1)
  {
    if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24LL))(a3) == 2)
    {
      uint64_t v18 = 0LL;
      memset(v17, 0, sizeof(v17));
      uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v17,  a3,  a5);
      if (*a5 <= 0)
      {
        uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v17, 0, (const char **)&__s1, a3);
        if ((_DWORD)result)
        {
          unsigned int v11 = 1;
          do
          {
            if (sub_1808E7C9C(v7, __s1))
            {
              if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24LL))(a3) == 2)
              {
                uint64_t result = sub_1808E7D2C((void *)v7, __s1, a3, a5);
                if (*a5 > 0) {
                  break;
                }
              }
            }

            uint64_t result = (void *)icu::ResourceTable::getKeyAndValue( (icu::ResourceTable *)v17,  v11++,  (const char **)&__s1,  a3);
          }

          while ((_DWORD)result);
        }
      }

      return result;
    }

uint64_t sub_1808E7B88(uint64_t result, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
  {
    uint64_t v5 = result;
    uint64_t result = icu::UnicodeString::doEqualsSubstring(result, 0, 17, (uint64_t)L"/LOCALE/calendar//intervalFormats", 0, 17);
    if (!(_DWORD)result) {
      goto LABEL_9;
    }
    unsigned int v6 = *(unsigned __int16 *)(v5 + 8);
    int v7 = (__int16)v6;
    unsigned int v8 = v6 >> 5;
    if (v7 < 0) {
      unsigned int v8 = *(_DWORD *)(v5 + 12);
    }
    uint64_t result = icu::UnicodeString::doEqualsSubstring(v5, v8 - 16, 16, (uint64_t)L"/intervalFormats", 0, 16);
    if ((_DWORD)result)
    {
      unsigned int v9 = *(unsigned __int16 *)(v5 + 8);
      int v10 = (__int16)v9;
      unsigned int v11 = v9 >> 5;
      if (v10 < 0) {
        unsigned int v11 = *(_DWORD *)(v5 + 12);
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v5 + 24LL))( v5,  17LL,  v11 - 16,  a2);
    }

    else
    {
LABEL_9:
      *a3 = 3;
    }
  }

  return result;
}

uint64_t sub_1808E7C9C(uint64_t a1, _BYTE *a2)
{
  if (!*(_BYTE *)(a1 + 80)) {
    return 1LL;
  }
  char v2 = *a2;
  if (!*a2) {
    return 0LL;
  }
  int v3 = 0;
  int v4 = 0;
  int v5 = 0;
  unsigned int v6 = a2 + 1;
  do
  {
    if (v2 == 121) {
      int v7 = v5 + 1;
    }
    else {
      int v7 = v5;
    }
    if (v2 == 100) {
      int v8 = v5;
    }
    else {
      int v8 = v7;
    }
    if (v2 == 100) {
      int v9 = v3 + 1;
    }
    else {
      int v9 = v3;
    }
    if (v2 == 77) {
      ++v4;
    }
    else {
      int v5 = v8;
    }
    if (v2 != 77) {
      int v3 = v9;
    }
    int v10 = *v6++;
    char v2 = v10;
  }

  while (v10);
  if (v4 > 2) {
    return 0LL;
  }
  if ((v5 < 1 || v4 <= 0) && (v4 < 1 ? (BOOL v11 = v5 < 1) : (BOOL v11 = 0), v11 || v3 <= 0)) {
    return 0LL;
  }
  else {
    return 1LL;
  }
}

void *sub_1808E7D2C(void *result, char *a2, icu::ResourceValue *a3, int *a4)
{
  unsigned int v12 = a2;
  if (*a4 <= 0)
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t v11 = 0LL;
    memset(v10, 0, sizeof(v10));
    uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v10,  a3,  a4);
    if (*a4 <= 0)
    {
      uint64_t result = (void *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v10, 0, (const char **)&v12, a3);
      if ((_DWORD)result)
      {
        unsigned int v8 = 1;
        do
        {
          if (!(*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24LL))(a3))
          {
            signed int v9 = sub_1808E7E30(v7, (unsigned __int8 *)v12);
            if (v9 <= 23)
            {
              uint64_t result = sub_1808E7ECC(v7, (uint64_t)a2, v9, (uint64_t)a3, a4);
              if (*a4 > 0) {
                break;
              }
            }
          }

          uint64_t result = (void *)icu::ResourceTable::getKeyAndValue( (icu::ResourceTable *)v10,  v8++,  (const char **)&v12,  a3);
        }

        while ((_DWORD)result);
      }
    }
  }

  return result;
}

uint64_t sub_1808E7E30(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (!*a2 || a2[1]) {
    return 24LL;
  }
  if (*a2 <= 0x60u)
  {
    if (v2 != 66)
    {
      if (v2 == 71) {
        return 0LL;
      }
      if (v2 == 77) {
        return 2LL;
      }
      goto LABEL_16;
    }

    return 9LL;
  }

  switch(v2)
  {
    case 'a':
      return 9LL;
    case 'd':
      return 5LL;
    case 'y':
      return 1LL;
  }

void *sub_1808E7ECC(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int *a5)
{
  v25[9] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t result = (void *)icu::DateIntervalInfo::calendarFieldToIntervalIndex(a3, a5);
  if (*a5 <= 0)
  {
    unsigned int v11 = result;
    memset(v25, 0, 64);
    icu::UnicodeString::UnicodeString(v25, a2, 0xFFFFFFFFLL, 0LL);
    uint64_t v12 = uhash_get(**(void **)(*(void *)(a1 + 8) + 80LL), (uint64_t)v25);
    if (!v12
      || (uint64_t v13 = (void *)*(unsigned __int16 *)(v12 + ((unint64_t)v11 << 6) + 8), v13 <= 0x1F))
    {
      memset(v24, 0, sizeof(v24));
      LODWORD(v19) = 0;
      uint64_t v21 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), int *))(*(void *)a4 + 32LL))( a4,  &v19,  a5);
      icu::UnicodeString::UnicodeString(v24, 1LL, &v21);
      if (*(_BYTE *)(a1 + 81))
      {
        icu::UnicodeString::UnicodeString((uint64_t)&v21, 8207);
        uint64_t v19 = off_18971B688;
        __int16 v20 = 2;
        if (SLOWORD(v24[1]) >= 0) {
          int32_t v14 = LOWORD(v24[1]) >> 5;
        }
        else {
          int32_t v14 = HIDWORD(v24[1]);
        }
        if ((v22 & 0x8000u) == 0) {
          uint64_t v15 = v22 >> 5;
        }
        else {
          uint64_t v15 = v23;
        }
        icu::UnicodeString::findAndReplace( (icu::UnicodeString *)v24,  0,  v14,  (const icu::UnicodeString *)&v21,  0,  v15,  (const icu::UnicodeString *)&v19,  0,  0);
        icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)&v19);
        icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v21);
      }

      icu::DateIntervalInfo::setIntervalPatternInternally(*(void *)(a1 + 8), v25, a3, v24, a5);
      icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v24);
    }

    return icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v25);
  }

  return result;
}

void *icu::DateTimePatternGenerator::getStaticClassID(icu::DateTimePatternGenerator *this)
{
  return &unk_18C5353C0;
}

void *icu::DateTimePatternGenerator::getDynamicClassID(icu::DateTimePatternGenerator *this)
{
  return &unk_18C5353C0;
}

void *sub_1808E80C8()
{
  return &unk_18C5353C1;
}

void *sub_1808E80D4()
{
  return &unk_18C5353C2;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::createInstance( icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  Default = icu::Locale::getDefault(this);
  return icu::DateTimePatternGenerator::createInstance((const char **)Default, (UErrorCode *)this, 0LL);
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::createInstance( const char **this, UErrorCode *a2, UErrorCode *a3)
{
  int v3 = (uint64_t *)*(unsigned int *)a2;
  int v5 = (int)a3;
  unsigned int v8 = (icu::DateTimePatternGenerator *)icu::UMemory::operator new(v3, (icu::UMemory *)0x12C0, (unint64_t)a2);
  if (!v8)
  {
    if (*(int *)a2 <= 0)
    {
      uint64_t result = 0LL;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      return result;
    }

    return 0LL;
  }

  uint64_t result = icu::DateTimePatternGenerator::DateTimePatternGenerator(v8, this, a2, v5);
  if (*(int *)a2 >= 1)
  {
    (*(void (**)(icu::DateTimePatternGenerator *))(*(void *)result + 8LL))(result);
    return 0LL;
  }

  return result;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::createInstanceNoStdPat( const char **this, UErrorCode *a2, UErrorCode *a3)
{
  int v3 = (uint64_t *)*(unsigned int *)a2;
  uint64_t v7 = (icu::DateTimePatternGenerator *)icu::UMemory::operator new(v3, (icu::UMemory *)0x12C0, (unint64_t)a2);
  if (!v7)
  {
    if (*(int *)a2 <= 0)
    {
      uint64_t result = 0LL;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      return result;
    }

    return 0LL;
  }

  uint64_t result = icu::DateTimePatternGenerator::DateTimePatternGenerator(v7, this, a2, 1);
  if (*(int *)a2 >= 1)
  {
    (*(void (**)(icu::DateTimePatternGenerator *))(*(void *)result + 8LL))(result);
    return 0LL;
  }

  return result;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::createEmptyInstance( UErrorCode *this, UErrorCode *a2)
{
  int v2 = (uint64_t *)*(unsigned int *)this;
  int v5 = (icu::DateTimePatternGenerator *)icu::UMemory::operator new(v2, (icu::UMemory *)0x12C0, (unint64_t)a2);
  if (!v5)
  {
    if (*(int *)this <= 0)
    {
      uint64_t result = 0LL;
      *this = U_MEMORY_ALLOCATION_ERROR;
      return result;
    }

    return 0LL;
  }

  uint64_t result = icu::DateTimePatternGenerator::DateTimePatternGenerator(v5, this);
  if (*(int *)this >= 1)
  {
    (*(void (**)(icu::DateTimePatternGenerator *))(*(void *)result + 8LL))(result);
    return 0LL;
  }

  return result;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::DateTimePatternGenerator( icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  *(void *)this = off_189723070;
  icu::Locale::Locale((icu::DateTimePatternGenerator *)((char *)this + 8));
  uint64_t v5 = 264LL;
  do
  {
    unsigned int v6 = (char *)this + v5;
    *(void *)unsigned int v6 = off_18971B688;
    *((_WORD *)v6 + 4) = 2;
    v5 += 64LL;
  }

  while (v6 + 64 != (char *)this + 1288);
  uint64_t v7 = 1288LL;
  do
  {
    unsigned int v8 = (char *)this + v7;
    *(void *)unsigned int v8 = off_18971B688;
    *((_WORD *)v8 + 4) = 2;
    v7 += 64LL;
  }

  while (v8 + 64 != (char *)this + 4360);
  uint64_t v9 = 4360LL;
  do
  {
    int v10 = (char *)this + v9;
    *(void *)int v10 = off_18971B688;
    *((_WORD *)v10 + 4) = 2;
    v9 += 64LL;
  }

  while (v10 + 64 != (char *)this + 4616);
  *((void *)this + 577) = off_18971B688;
  *((_WORD *)this + 2312) = 2;
  *(_OWORD *)((char *)this + 4680) = 0u;
  *((void *)this + 587) = off_18971B688;
  *((_WORD *)this + 2352) = 2;
  *((_WORD *)this + 2380) = 0;
  *((_DWORD *)this + 1198) = 0;
  unsigned int v11 = icu::UMemory::operator new((uint64_t *)0x1248, (icu::UMemory *)0xC90, v4);
  if (v11)
  {
    *unsigned int v11 = (uint64_t)off_189723220;
    int32_t v14 = v11 + 1;
    uint64_t v13 = v11 + 401;
    do
    {
      *int32_t v14 = (uint64_t)off_18971B688;
      *((_WORD *)v14 + 4) = 2;
      v14 += 8;
    }

    while (v14 != v13);
    *uint64_t v13 = 0LL;
  }

  *((void *)this + 29) = v11;
  uint64_t v15 = icu::UMemory::operator new(v13, (icu::UMemory *)0x98, v12);
  if (v15)
  {
    int32_t v17 = (uint64_t *)&off_189723200;
    *uint64_t v15 = (uint64_t)&off_189723200;
    v15[1] = (uint64_t)&off_189723268;
    *((_OWORD *)v15 + 5) = 0u;
    *((_OWORD *)v15 + 6) = 0u;
    *((_OWORD *)v15 + 7) = 0u;
    *((_OWORD *)v15 + 8) = 0u;
    *((_BYTE *)v15 + 144) = 0;
  }

  *((void *)this + 30) = v15;
  uint64_t v18 = icu::UMemory::operator new(v17, (icu::UMemory *)0x10, v16);
  if (v18)
  {
    __int16 v20 = (uint64_t *)&off_189723378;
    *uint64_t v18 = (uint64_t)&off_189723378;
  }

  *((void *)this + 3sub_1808F7164((uint64_t)v14, 1) = v18;
  uint64_t v21 = icu::UMemory::operator new(v20, (icu::UMemory *)0x1B0, v19);
  if (v21)
  {
    *uint64_t v21 = (uint64_t)&off_1897231E0;
    *(_OWORD *)(v21 + 3) = 0u;
    *(_OWORD *)(v21 + 5) = 0u;
    *(_OWORD *)(v21 + 7) = 0u;
    *(_OWORD *)(v21 + 9) = 0u;
    *(_OWORD *)(v21 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 13) = 0u;
    *(_OWORD *)(v21 + 15) = 0u;
    *(_OWORD *)(v21 + 17) = 0u;
    *(_OWORD *)(v21 + 19) = 0u;
    *(_OWORD *)(v21 + 2sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 23) = 0u;
    *(_OWORD *)(v21 + 25) = 0u;
    *(_OWORD *)(v21 + 27) = 0u;
    *(_OWORD *)(v21 + 29) = 0u;
    *(_OWORD *)(v21 + 3sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 33) = 0u;
    *(_OWORD *)(v21 + 35) = 0u;
    *(_OWORD *)(v21 + 37) = 0u;
    *(_OWORD *)(v21 + 39) = 0u;
    *(_OWORD *)(v21 + 4sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 43) = 0u;
    *(_OWORD *)(v21 + 45) = 0u;
    *(_OWORD *)(v21 + 47) = 0u;
    *(_OWORD *)(v21 + 49) = 0u;
    *(_OWORD *)(v21 + 5sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_BYTE *)v21 + 424) = 1;
  }

  *((void *)this + 32) = v21;
  if (!*((void *)this + 29) || !*((void *)this + 30) || !v21 || !*((void *)this + 31))
  {
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    *((_DWORD *)this + 1198) = 7;
  }

  return this;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::DateTimePatternGenerator( icu::DateTimePatternGenerator *this, const char **a2, UErrorCode *a3, int a4)
{
  *(void *)this = off_189723070;
  icu::Locale::Locale((icu::DateTimePatternGenerator *)((char *)this + 8), (uint64_t)a2);
  uint64_t v9 = 264LL;
  do
  {
    int v10 = (char *)this + v9;
    *(void *)int v10 = off_18971B688;
    *((_WORD *)v10 + 4) = 2;
    v9 += 64LL;
  }

  while (v10 + 64 != (char *)this + 1288);
  uint64_t v11 = 1288LL;
  do
  {
    unint64_t v12 = (char *)this + v11;
    *(void *)unint64_t v12 = off_18971B688;
    *((_WORD *)v12 + 4) = 2;
    v11 += 64LL;
  }

  while (v12 + 64 != (char *)this + 4360);
  uint64_t v13 = 4360LL;
  do
  {
    int32_t v14 = (char *)this + v13;
    *(void *)int32_t v14 = off_18971B688;
    *((_WORD *)v14 + 4) = 2;
    v13 += 64LL;
  }

  while (v14 + 64 != (char *)this + 4616);
  *((void *)this + 577) = off_18971B688;
  *((_WORD *)this + 2312) = 2;
  *(_OWORD *)((char *)this + 4680) = 0u;
  *((void *)this + 587) = off_18971B688;
  *((_WORD *)this + 2352) = 2;
  *((_WORD *)this + 2380) = 0;
  *((_DWORD *)this + 1198) = 0;
  uint64_t v15 = icu::UMemory::operator new((uint64_t *)0x1248, (icu::UMemory *)0xC90, v8);
  if (v15)
  {
    *uint64_t v15 = (uint64_t)off_189723220;
    uint64_t v18 = v15 + 1;
    int32_t v17 = v15 + 401;
    do
    {
      *uint64_t v18 = (uint64_t)off_18971B688;
      *((_WORD *)v18 + 4) = 2;
      v18 += 8;
    }

    while (v18 != v17);
    *int32_t v17 = 0LL;
  }

  *((void *)this + 29) = v15;
  unint64_t v19 = icu::UMemory::operator new(v17, (icu::UMemory *)0x98, v16);
  if (v19)
  {
    uint64_t v21 = (uint64_t *)&off_189723200;
    *unint64_t v19 = (uint64_t)&off_189723200;
    v19[1] = (uint64_t)&off_189723268;
    *((_OWORD *)v19 + 5) = 0u;
    *((_OWORD *)v19 + 6) = 0u;
    *((_OWORD *)v19 + 7) = 0u;
    *((_OWORD *)v19 + 8) = 0u;
    *((_BYTE *)v19 + 144) = 0;
  }

  *((void *)this + 30) = v19;
  unsigned __int16 v22 = icu::UMemory::operator new(v21, (icu::UMemory *)0x10, v20);
  if (v22)
  {
    int32_t v24 = (uint64_t *)&off_189723378;
    *unsigned __int16 v22 = (uint64_t)&off_189723378;
  }

  *((void *)this + 3sub_1808F7164((uint64_t)v14, 1) = v22;
  int32_t v25 = icu::UMemory::operator new(v24, (icu::UMemory *)0x1B0, v23);
  if (v25)
  {
    *int32_t v25 = (uint64_t)&off_1897231E0;
    *(_OWORD *)(v25 + 3) = 0u;
    *(_OWORD *)(v25 + 5) = 0u;
    *(_OWORD *)(v25 + 7) = 0u;
    *(_OWORD *)(v25 + 9) = 0u;
    *(_OWORD *)(v25 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v25 + 13) = 0u;
    *(_OWORD *)(v25 + 15) = 0u;
    *(_OWORD *)(v25 + 17) = 0u;
    *(_OWORD *)(v25 + 19) = 0u;
    *(_OWORD *)(v25 + 2sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v25 + 23) = 0u;
    *(_OWORD *)(v25 + 25) = 0u;
    *(_OWORD *)(v25 + 27) = 0u;
    *(_OWORD *)(v25 + 29) = 0u;
    *(_OWORD *)(v25 + 3sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v25 + sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v25 + 33) = 0u;
    *(_OWORD *)(v25 + 35) = 0u;
    *(_OWORD *)(v25 + 37) = 0u;
    *(_OWORD *)(v25 + 39) = 0u;
    *(_OWORD *)(v25 + 4sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v25 + 43) = 0u;
    *(_OWORD *)(v25 + 45) = 0u;
    *(_OWORD *)(v25 + 47) = 0u;
    *(_OWORD *)(v25 + 49) = 0u;
    *(_OWORD *)(v25 + 5sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_BYTE *)v25 + 424) = 1;
  }

  *((void *)this + 32) = v25;
  if (*((void *)this + 29) && *((void *)this + 30) && v25 && *((void *)this + 31))
  {
    icu::DateTimePatternGenerator::initData(this, a2, a3, a4);
  }

  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
    *((_DWORD *)this + 1198) = 7;
  }

  return this;
}

void icu::DateTimePatternGenerator::initData( icu::DateTimePatternGenerator *this, const char **a2, UErrorCode *a3, int a4)
{
  *(_OWORD *)((char *)this + 4680) = 0u;
  icu::DateTimePatternGenerator::addCanonicalItems((unsigned int *)this, a3);
  if (!a4) {
    icu::DateTimePatternGenerator::addICUPatterns(this, a2, a3);
  }
  icu::DateTimePatternGenerator::addCLDRData((_BYTE ***)this, (char **)a2, a3);
  icu::DateTimePatternGenerator::setDateTimeFromCalendar(this, (const icu::Locale *)a2, a3);
  icu::DateTimePatternGenerator::setDecimalSymbols(this, (const icu::Locale *)a2, a3);
  if (*(int *)a3 <= 0)
  {
    unsigned int v8 = atomic_load(&dword_18C4493E8);
    if (v8 == 2 || !icu::umtx_initImplPreInit(&dword_18C4493E8))
    {
      if (dword_18C4493EC >= 1) {
        *a3 = dword_18C4493EC;
      }
    }

    else
    {
      icu::DateTimePatternGenerator::loadAllowedHourFormatsData((icu::DateTimePatternGenerator *)a3, v9);
      dword_18C4493EC = *a3;
      icu::umtx_initImplPostInit(&dword_18C4493E8);
    }
  }

  icu::DateTimePatternGenerator::getAllowedHourFormats(this, (char **)a2, a3);
  *((UErrorCode *)this + 1198) = *a3;
}

uint64_t icu::DateTimePatternGenerator::DateTimePatternGenerator( icu::DateTimePatternGenerator *this, const icu::DateTimePatternGenerator *a2)
{
  *(void *)this = off_189723070;
  icu::Locale::Locale((icu::DateTimePatternGenerator *)((char *)this + 8));
  uint64_t v5 = 264LL;
  do
  {
    unsigned int v6 = (char *)this + v5;
    *(void *)unsigned int v6 = off_18971B688;
    *((_WORD *)v6 + 4) = 2;
    v5 += 64LL;
  }

  while (v6 + 64 != (char *)this + 1288);
  uint64_t v7 = 1288LL;
  do
  {
    unsigned int v8 = (char *)this + v7;
    *(void *)unsigned int v8 = off_18971B688;
    *((_WORD *)v8 + 4) = 2;
    v7 += 64LL;
  }

  while (v8 + 64 != (char *)this + 4360);
  uint64_t v9 = 4360LL;
  do
  {
    int v10 = (char *)this + v9;
    *(void *)int v10 = off_18971B688;
    *((_WORD *)v10 + 4) = 2;
    v9 += 64LL;
  }

  while (v10 + 64 != (char *)this + 4616);
  *((void *)this + 577) = off_18971B688;
  *((_WORD *)this + 2312) = 2;
  *(_OWORD *)((char *)this + 4680) = 0u;
  *((void *)this + 587) = off_18971B688;
  *((_WORD *)this + 2352) = 2;
  *((_WORD *)this + 2380) = 0;
  *((_DWORD *)this + 1198) = 0;
  uint64_t v11 = icu::UMemory::operator new((uint64_t *)0x1248, (icu::UMemory *)0xC90, v4);
  if (v11)
  {
    *uint64_t v11 = (uint64_t)off_189723220;
    int32_t v14 = v11 + 1;
    uint64_t v13 = v11 + 401;
    do
    {
      *int32_t v14 = (uint64_t)off_18971B688;
      *((_WORD *)v14 + 4) = 2;
      v14 += 8;
    }

    while (v14 != v13);
    *uint64_t v13 = 0LL;
  }

  *((void *)this + 29) = v11;
  uint64_t v15 = icu::UMemory::operator new(v13, (icu::UMemory *)0x98, v12);
  if (v15)
  {
    int32_t v17 = (uint64_t *)&off_189723200;
    *uint64_t v15 = (uint64_t)&off_189723200;
    v15[1] = (uint64_t)&off_189723268;
    *((_OWORD *)v15 + 5) = 0u;
    *((_OWORD *)v15 + 6) = 0u;
    *((_OWORD *)v15 + 7) = 0u;
    *((_OWORD *)v15 + 8) = 0u;
    *((_BYTE *)v15 + 144) = 0;
  }

  *((void *)this + 30) = v15;
  uint64_t v18 = icu::UMemory::operator new(v17, (icu::UMemory *)0x10, v16);
  if (v18)
  {
    unint64_t v20 = (uint64_t *)&off_189723378;
    *uint64_t v18 = (uint64_t)&off_189723378;
  }

  *((void *)this + 3sub_1808F7164((uint64_t)v14, 1) = v18;
  uint64_t v21 = icu::UMemory::operator new(v20, (icu::UMemory *)0x1B0, v19);
  if (v21)
  {
    *uint64_t v21 = (uint64_t)&off_1897231E0;
    *(_OWORD *)(v21 + 3) = 0u;
    *(_OWORD *)(v21 + 5) = 0u;
    *(_OWORD *)(v21 + 7) = 0u;
    *(_OWORD *)(v21 + 9) = 0u;
    *(_OWORD *)(v21 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 13) = 0u;
    *(_OWORD *)(v21 + 15) = 0u;
    *(_OWORD *)(v21 + 17) = 0u;
    *(_OWORD *)(v21 + 19) = 0u;
    *(_OWORD *)(v21 + 2sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 23) = 0u;
    *(_OWORD *)(v21 + 25) = 0u;
    *(_OWORD *)(v21 + 27) = 0u;
    *(_OWORD *)(v21 + 29) = 0u;
    *(_OWORD *)(v21 + 3sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 33) = 0u;
    *(_OWORD *)(v21 + 35) = 0u;
    *(_OWORD *)(v21 + 37) = 0u;
    *(_OWORD *)(v21 + 39) = 0u;
    *(_OWORD *)(v21 + 4sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v21 + 43) = 0u;
    *(_OWORD *)(v21 + 45) = 0u;
    *(_OWORD *)(v21 + 47) = 0u;
    *(_OWORD *)(v21 + 49) = 0u;
    *(_OWORD *)(v21 + 5sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_BYTE *)v21 + 424) = 1;
  }

  *((void *)this + 32) = v21;
  if (!*((void *)this + 29) || !*((void *)this + 30) || !v21 || !*((void *)this + 31)) {
    *((_DWORD *)this + 1198) = 7;
  }
  return icu::DateTimePatternGenerator::operator=((uint64_t)this, (uint64_t)a2);
}

uint64_t icu::DateTimePatternGenerator::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    *(_DWORD *)(a1 + 4792) = *(_DWORD *)(a2 + 4792);
    icu::Locale::operator=((icu::Locale *)(a1 + 8), a2 + 8);
    *(_WORD *)(a1 + 4760) = *(_WORD *)(a2 + 4760);
    for (uint64_t i = 1191LL; i != 1198; ++i)
      *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(a2 + 4 * i);
    uint64_t v5 = *(void *)(a2 + 232);
    uint64_t v6 = *(void *)(a1 + 232);
    for (uint64_t j = 8LL; j != 3208; j += 64LL)
      icu::UnicodeString::operator=((UChar **)(v6 + j), (UChar **)(v5 + j));
    uint64_t v8 = 0LL;
    *(void *)(v6 + 3208) = *(void *)(v5 + 3208);
    uint64_t v9 = *(void *)(a1 + 240);
    uint64_t v10 = *(void *)(a2 + 240);
    __int128 v11 = *(_OWORD *)(v10 + 16);
    __int128 v12 = *(_OWORD *)(v10 + 32);
    __int128 v13 = *(_OWORD *)(v10 + 64);
    *(_OWORD *)(v9 + 48) = *(_OWORD *)(v10 + 48);
    *(_OWORD *)(v9 + 64) = v13;
    *(_OWORD *)(v9 + 16) = v11;
    *(_OWORD *)(v9 + 32) = v12;
    *(_OWORD *)(v9 + 80) = *(_OWORD *)(v10 + 80);
    *(_OWORD *)(v9 + 96) = *(_OWORD *)(v10 + 96);
    *(_OWORD *)(v9 + 112) = *(_OWORD *)(v10 + 112);
    *(_OWORD *)(v9 + 128) = *(_OWORD *)(v10 + 128);
    *(_BYTE *)(v9 + 144) = *(_BYTE *)(v10 + 144);
    *(void *)(*(void *)(a1 + 248) + 8LL) = *(void *)(*(void *)(a2 + 248) + 8LL);
    do
    {
      icu::UnicodeString::operator=((UChar **)(a1 + 4360 + v8), (UChar **)(a2 + 4360 + v8));
      v8 += 64LL;
    }

    while (v8 != 256);
    icu::UnicodeString::operator=((UChar **)(a1 + 4616), (UChar **)(a2 + 4616));
    for (uint64_t k = 0LL; k != 256; k += 64LL)
      icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)(a1 + 4360 + k));
    icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)(a1 + 4616));
    uint64_t v16 = *(void *)(a1 + 4680);
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    int32_t v17 = *(uint64_t **)(a2 + 4680);
    if (v17)
    {
      uint64_t v18 = icu::UMemory::operator new(v17, (icu::UMemory *)0x98, v15);
      if (!v18)
      {
        *(void *)(a1 + 4680) = 0LL;
        *(_DWORD *)(a1 + 4792) = 7;
        return a1;
      }

      uint64_t v19 = *(void *)(a2 + 4680);
      *uint64_t v18 = (uint64_t)&off_189723200;
      v18[1] = (uint64_t)&off_189723268;
      *((_OWORD *)v18 + 5) = 0u;
      *((_OWORD *)v18 + 6) = 0u;
      *((_OWORD *)v18 + 7) = 0u;
      *((_OWORD *)v18 + 8) = 0u;
      *((_BYTE *)v18 + 144) = 0;
      __int128 v20 = *(_OWORD *)(v19 + 16);
      __int128 v21 = *(_OWORD *)(v19 + 32);
      __int128 v22 = *(_OWORD *)(v19 + 64);
      *((_OWORD *)v18 + 3) = *(_OWORD *)(v19 + 48);
      *((_OWORD *)v18 + 4) = v22;
      *((_OWORD *)v18 + sub_1808F7164((uint64_t)v14, 1) = v20;
      *((_OWORD *)v18 + 2) = v21;
      *((_OWORD *)v18 + 5) = *(_OWORD *)(v19 + 80);
      *((_OWORD *)v18 + 6) = *(_OWORD *)(v19 + 96);
      *((_OWORD *)v18 + 7) = *(_OWORD *)(v19 + 112);
      *((_OWORD *)v18 + 8) = *(_OWORD *)(v19 + 128);
      *((_BYTE *)v18 + 144) = *(_BYTE *)(v19 + 144);
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    uint64_t v23 = 0LL;
    *(void *)(a1 + 4680) = v18;
    uint64_t v24 = a2 + 1288;
    uint64_t v25 = a1 + 1288;
    do
    {
      icu::UnicodeString::operator=((UChar **)(a1 + (v23 << 6) + 264), (UChar **)(a2 + (v23 << 6) + 264));
      icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)(a1 + (v23 << 6) + 264));
      for (uint64_t m = 0LL; m != 192; m += 64LL)
      {
        icu::UnicodeString::operator=((UChar **)(v25 + m), (UChar **)(v24 + m));
        icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)(v25 + m));
      }

      ++v23;
      v24 += 192LL;
      v25 += 192LL;
    }

    while (v23 != 16);
    sub_1808E8CE8(*(uint64_t **)(a1 + 256), *(void *)(a2 + 256), (int *)(a1 + 4792));
    icu::DateTimePatternGenerator::copyHashtable(a1, *(uint64_t ***)(a2 + 4688), (UErrorCode *)(a1 + 4792));
  }

  return a1;
}

uint64_t *sub_1808E8CE8(uint64_t *result, unint64_t a2, int *a3)
{
  uint64_t v19 = result;
  if (*a3 <= 0)
  {
    uint64_t v5 = 0LL;
    *((_BYTE *)result + 424) = *(_BYTE *)(a2 + 424);
    while (1)
    {
      uint64_t v6 = *(void *)(a2 + 8 * v5 + 8);
      if (v6) {
        break;
      }
LABEL_16:
      if (++v5 == 52) {
        return result;
      }
    }

    uint64_t v7 = 0LL;
    uint64_t v8 = &v19[v5];
    uint64_t v9 = (uint64_t **)(v8 + 1);
    while (1)
    {
      uint64_t v10 = v7;
      uint64_t result = icu::UMemory::operator new(v8, (icu::UMemory *)0xA0, a2);
      if (!result) {
        break;
      }
      uint64_t v7 = result;
      *uint64_t result = (uint64_t)off_189723288;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)(result + 1), (UChar **)(v6 + 8));
      v7[9] = 0LL;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v7 + 10), (UChar **)(v6 + 80));
      v7[19] = 0LL;
      __int128 v12 = (uint64_t *)*a3;
      __int128 v13 = icu::UMemory::operator new(v12, (icu::UMemory *)0x90, v11);
      if (v13)
      {
        uint64_t v14 = *(void *)(v6 + 72);
        *__int128 v13 = (uint64_t)&off_189723268;
        *(_OWORD *)(v13 + 9) = 0u;
        *(_OWORD *)(v13 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
        *(_OWORD *)(v13 + 13) = 0u;
        *(_OWORD *)(v13 + 15) = 0u;
        __int128 v15 = *(_OWORD *)(v14 + 8);
        __int128 v16 = *(_OWORD *)(v14 + 24);
        __int128 v17 = *(_OWORD *)(v14 + 40);
        *(_OWORD *)(v13 + 7) = *(_OWORD *)(v14 + 56);
        *(_OWORD *)(v13 + 5) = v17;
        *(_OWORD *)(v13 + 3) = v16;
        *(_OWORD *)(v13 + sub_1808F7164((uint64_t)v14, 1) = v15;
        *(_OWORD *)(v13 + 9) = *(_OWORD *)(v14 + 72);
        *(_OWORD *)(v13 + 1sub_1808F7164((uint64_t)v14, 1) = *(_OWORD *)(v14 + 88);
        *(_OWORD *)(v13 + 13) = *(_OWORD *)(v14 + 104);
        *(_OWORD *)(v13 + 15) = *(_OWORD *)(v14 + 120);
        *((_BYTE *)v13 + 136) = *(_BYTE *)(v14 + 136);
      }

      uint64_t result = (uint64_t *)sub_1807C9194((uint64_t)(v7 + 9), (uint64_t)v13, a3);
      if (*a3 > 0) {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7);
      }
      *((_BYTE *)v7 + 144) = *(_BYTE *)(v6 + 144);
      uint64_t v8 = *v9;
      uint64_t v18 = v9;
      if (*v9)
      {
        if (!v10) {
          abort();
        }
        uint64_t result = (uint64_t *)v10[19];
        uint64_t v18 = (uint64_t **)(v10 + 19);
        if (result) {
          uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 8))(result);
        }
      }

      *uint64_t v18 = v7;
      uint64_t v6 = *(void *)(v6 + 152);
      if (!v6) {
        goto LABEL_16;
      }
    }

    if (*a3 <= 0) {
      *a3 = 7;
    }
  }

  return result;
}

uint64_t icu::DateTimePatternGenerator::copyHashtable(uint64_t this, uint64_t **a2, UErrorCode *a3)
{
  if (a2 && *(int *)a3 <= 0)
  {
    uint64_t v5 = this;
    uint64_t v6 = *(_BYTE ***)(this + 4688);
    if (v6)
    {
      if (*v6) {
        uhash_close(*v6);
      }
      icu::UMemory::operator delete(v6);
      *(void *)(v5 + 4688) = 0LL;
    }

    this = (uint64_t)icu::DateTimePatternGenerator::initHashtable((_BYTE ***)v5, a3);
    if (*(int *)a3 <= 0)
    {
      int v13 = -1;
      do
      {
        this = uhash_nextElement(*a2, &v13);
        if (!this) {
          break;
        }
        uint64_t v8 = *(UChar ***)(this + 16);
        uint64_t v9 = *(uint64_t **)(v5 + 4688);
        uint64_t v10 = *v9;
        unint64_t v11 = (icu::UnicodeString *)icu::UMemory::operator new(v9, (icu::UMemory *)0x40, v7);
        uint64_t v12 = (uint64_t)v11;
        if (v11) {
          icu::UnicodeString::UnicodeString(v11, v8);
        }
        this = uhash_puti(v10, v12, 1u, (int *)a3);
      }

      while (*(int *)a3 < 1);
    }
  }

  return this;
}

BOOL icu::DateTimePatternGenerator::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (!icu::Locale::operator==(a1 + 8, a2 + 8)
    || !sub_1808E9234(*(void *)(a1 + 256), *(void *)(a2 + 256)))
  {
    return 0;
  }

  unsigned int v4 = *(unsigned __int16 *)(a1 + 4624);
  if ((v4 & 1) != 0)
  {
    if ((*(_WORD *)(a2 + 4624) & 1) != 0) {
      goto LABEL_17;
    }
    return 0;
  }

  if ((v4 & 0x8000) != 0) {
    int v5 = *(_DWORD *)(a1 + 4628);
  }
  else {
    int v5 = v4 >> 5;
  }
  BOOL v6 = 0;
  unsigned int v7 = *(unsigned __int16 *)(a2 + 4624);
  if ((v7 & 0x8000u) == 0) {
    unsigned int v8 = v7 >> 5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a2 + 4628);
  }
  if ((v7 & 1) != 0 || v5 != v8) {
    return v6;
  }
  if (!icu::UnicodeString::doEquals((icu::UnicodeString *)(a1 + 4616), (const icu::UnicodeString *)(a2 + 4616), v5)) {
    return 0;
  }
LABEL_17:
  for (uint64_t i = 0LL; i != 256; i += 64LL)
  {
    unsigned int v10 = *(unsigned __int16 *)(a1 + i + 4368);
    if ((v10 & 1) != 0)
    {
      if ((*(_WORD *)(a2 + i + 4368) & 1) == 0) {
        return 0;
      }
    }

    else
    {
      if ((v10 & 0x8000) != 0) {
        int v11 = *(_DWORD *)(a1 + i + 4372);
      }
      else {
        int v11 = v10 >> 5;
      }
      BOOL v6 = 0;
      unsigned int v12 = *(unsigned __int16 *)(a2 + i + 4368);
      unsigned int v13 = *(_DWORD *)(a2 + i + 4372);
      if ((v12 & 0x8000u) == 0) {
        unsigned int v13 = v12 >> 5;
      }
      if ((v12 & 1) != 0 || v11 != v13) {
        return v6;
      }
      if (!icu::UnicodeString::doEquals( (icu::UnicodeString *)(a1 + 4360 + i),  (const icu::UnicodeString *)(a2 + 4360 + i),  v11)) {
        return 0;
      }
    }
  }

  unint64_t v14 = 0LL;
  BOOL v6 = 0;
  uint64_t v15 = a2;
  uint64_t v16 = a1;
  do
  {
    uint64_t v17 = a1 + (v14 << 6);
    uint64_t v18 = a2 + (v14 << 6);
    unsigned int v19 = *(unsigned __int16 *)(v17 + 272);
    if ((v19 & 1) != 0)
    {
      if ((*(_WORD *)(v18 + 272) & 1) == 0) {
        return v6;
      }
    }

    else
    {
      if ((v19 & 0x8000) != 0) {
        int v20 = *(_DWORD *)(a1 + (v14 << 6) + 276);
      }
      else {
        int v20 = v19 >> 5;
      }
      uint64_t v21 = a2 + (v14 << 6);
      unsigned int v22 = *(unsigned __int16 *)(v21 + 272);
      unsigned int v23 = *(_DWORD *)(v21 + 276);
      if ((v22 & 0x8000u) == 0) {
        unsigned int v23 = v22 >> 5;
      }
      if ((v22 & 1) != 0
        || v20 != v23
        || !icu::UnicodeString::doEquals( (icu::UnicodeString *)(v17 + 264),  (const icu::UnicodeString *)(v18 + 264),  v20))
      {
        return v6;
      }
    }

    for (uint64_t j = 0LL; j != 192; j += 64LL)
    {
      uint64_t v25 = v15 + j;
      unsigned int v26 = *(unsigned __int16 *)(v16 + j + 1296);
      if ((v26 & 1) != 0)
      {
        if ((*(_WORD *)(v25 + 1296) & 1) == 0) {
          return v6;
        }
      }

      else
      {
        if ((v26 & 0x8000) != 0) {
          int v27 = *(_DWORD *)(v16 + j + 1300);
        }
        else {
          int v27 = v26 >> 5;
        }
        unsigned int v28 = *(unsigned __int16 *)(v15 + j + 1296);
        unsigned int v29 = *(_DWORD *)(v15 + j + 1300);
        if ((v28 & 0x8000u) == 0) {
          unsigned int v29 = v28 >> 5;
        }
        if ((v28 & 1) != 0
          || v27 != v29
          || !icu::UnicodeString::doEquals( (icu::UnicodeString *)(v16 + j + 1288),  (const icu::UnicodeString *)(v25 + 1288),  v27))
        {
          return v6;
        }
      }
    }

    BOOL v6 = v14 > 0xE;
    v16 += 192LL;
    v15 += 192LL;
    ++v14;
  }

  while (v14 != 16);
  return v6;
}

uint64_t sub_1808E9234(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  unint64_t v4 = 0LL;
  BOOL v5 = 0;
  while (1)
  {
    uint64_t v6 = *(void *)(a1 + 8 * v4 + 8);
    uint64_t v7 = *(void *)(a2 + 8 * v4 + 8);
    if (v6 != v7) {
      break;
    }
LABEL_38:
    BOOL v5 = v4++ > 0x32;
    if (v4 == 52) {
      return v5;
    }
  }

  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    while (v7 && v6)
    {
      unsigned int v9 = *(unsigned __int16 *)(v6 + 16);
      if ((v9 & 1) != 0)
      {
        if ((*(_WORD *)(v7 + 16) & 1) == 0) {
          return v5;
        }
      }

      else
      {
        if ((v9 & 0x8000) != 0) {
          int v10 = *(_DWORD *)(v6 + 20);
        }
        else {
          int v10 = v9 >> 5;
        }
        unsigned int v11 = *(unsigned __int16 *)(v7 + 16);
        if ((v11 & 0x8000u) == 0) {
          unsigned int v12 = v11 >> 5;
        }
        else {
          unsigned int v12 = *(_DWORD *)(v7 + 20);
        }
        if ((v11 & 1) != 0
          || v10 != v12
          || !icu::UnicodeString::doEquals((icu::UnicodeString *)(v6 + 8), (const icu::UnicodeString *)(v7 + 8), v10))
        {
          return v5;
        }
      }

      unsigned int v13 = *(unsigned __int16 *)(v6 + 88);
      if ((v13 & 1) != 0)
      {
        if ((*(_WORD *)(v7 + 88) & 1) == 0) {
          return v5;
        }
      }

      else
      {
        if ((v13 & 0x8000) != 0) {
          int v14 = *(_DWORD *)(v6 + 92);
        }
        else {
          int v14 = v13 >> 5;
        }
        unsigned int v15 = *(unsigned __int16 *)(v7 + 88);
        if ((v15 & 0x8000u) == 0) {
          unsigned int v16 = v15 >> 5;
        }
        else {
          unsigned int v16 = *(_DWORD *)(v7 + 92);
        }
        if ((v15 & 1) != 0
          || v14 != v16
          || !icu::UnicodeString::doEquals((icu::UnicodeString *)(v6 + 80), (const icu::UnicodeString *)(v7 + 80), v14))
        {
          return v5;
        }
      }

      uint64_t v17 = *(void **)(v6 + 72);
      uint64_t v18 = *(void **)(v7 + 72);
      if (v17 != v18 && !sub_1808EEF38(v17, v18)) {
        return v5;
      }
      uint64_t v6 = *(void *)(v6 + 152);
      uint64_t v7 = *(void *)(v7 + 152);
      if (!(v7 | v6) || v6 == v7) {
        goto LABEL_38;
      }
    }
  }

  return v5;
}

BOOL icu::DateTimePatternGenerator::operator!=(uint64_t a1, uint64_t a2)
{
  return !icu::DateTimePatternGenerator::operator==(a1, a2);
}

void icu::DateTimePatternGenerator::~DateTimePatternGenerator(icu::DateTimePatternGenerator *this)
{
  *(void *)this = off_189723070;
  int v2 = (_BYTE **)*((void *)this + 586);
  if (v2)
  {
    if (*v2) {
      uhash_close(*v2);
    }
    icu::UMemory::operator delete(v2);
  }

  uint64_t v3 = *((void *)this + 29);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *((void *)this + 30);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *((void *)this + 31);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *((void *)this + 32);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *((void *)this + 585);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  icu::UnicodeString::~UnicodeString((void *)0x1258, (icu::DateTimePatternGenerator *)((char *)this + 4696));
  icu::UnicodeString::~UnicodeString((void *)0x1208, (icu::DateTimePatternGenerator *)((char *)this + 4616));
  uint64_t v8 = 0LL;
  uint64_t v9 = 4552LL;
  do
  {
    icu::UnicodeString::~UnicodeString((void *)v9, (icu::DateTimePatternGenerator *)((char *)this + v8 + 4552));
    v8 -= 64LL;
  }

  while (v8 != -256);
  for (uint64_t i = 4296LL; i != 1224; i -= 64LL)
    icu::UnicodeString::~UnicodeString((void *)v9, (icu::DateTimePatternGenerator *)((char *)this + i));
  do
  {
    icu::UnicodeString::~UnicodeString((void *)v9, (icu::DateTimePatternGenerator *)((char *)this + i));
    i -= 64LL;
  }

  while (i != 200);
  icu::Locale::~Locale((icu::DateTimePatternGenerator *)((char *)this + 8));
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::DateTimePatternGenerator::~DateTimePatternGenerator(this);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_1808E94F8()
{
  return 1LL;
}

unsigned int *icu::DateTimePatternGenerator::addCanonicalItems(unsigned int *this, UErrorCode *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    uint64_t v3 = this;
    uint64_t v4 = 0LL;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    uint64_t v13 = 0LL;
    __int128 v12 = 0u;
    uint64_t v9 = (UChar *)off_18971B688;
    LOWORD(v10) = 2;
    do
    {
      icu::UnicodeString::UnicodeString((uint64_t)v8, aGyqmwwedfdahms[v4]);
      uint64_t v5 = (void *)v3[1198];
      else {
        *a2 = (int)v5;
      }
      icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
      uint64_t v6 = (void *)*(unsigned int *)a2;
    }

    while ((int)v6 <= 0 && v4++ != 15);
    return (unsigned int *)icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v9);
  }

  return this;
}

void icu::DateTimePatternGenerator::addICUPatterns( icu::DateTimePatternGenerator *this, const char **a2, UErrorCode *a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  int v27 = 0;
  __int128 v50 = 0u;
  memset(v51, 0, sizeof(v51));
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 __dst = 0u;
  if (!ulocimp_setRegionToSupplementalRegion((char *)a2[5], (char *)&__dst, 157))
  {
    strncpy((char *)&__dst, a2[5], 0x9DuLL);
    v51[28] = 0;
  }

  uint64_t v6 = ures_open(0LL, (char *)&__dst, (int *)a3);
  memset(&v41[1], 0, 48);
  v42[1] = 0;
  v41[0] = (char *)&v41[1] + 5;
  LODWORD(v41[1]) = 40;
  v42[0] = 0;
  uint64_t v7 = (icu::DateTimePatternGenerator *)icu::Locale::Locale((icu::Locale *)v40, (const char *)&__dst, 0LL, 0LL, 0LL);
  icu::DateTimePatternGenerator::getCalendarTypeToUse(v7, v40, (icu::CharString *)v41, a3);
  icu::Locale::~Locale((icu::Locale *)v40);
  if ((void)__dst == 0x52545F504A5F616ALL
    && *((void *)&__dst + 1) == 0x414E4F4954494441LL
    && (unsigned __int16)v44 == 76)
  {
    v42[0] = 0;
    *v41[0] = 0;
    icu::StringPiece::StringPiece((icu::StringPiece *)&v25, "gregorian");
    icu::CharString::append((icu::CharString *)v41, v25, v26, a3);
  }

  memset(&v40[1], 0, 56);
  v40[0] = (char *)&v40[1] + 5;
  LODWORD(v40[1]) = 40;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v23, "calendar");
  __int128 v10 = icu::CharString::append((icu::CharString *)v40, v23, v24, a3);
  __int128 v11 = icu::CharString::append(v10, 47, a3);
  __int128 v12 = icu::CharString::append(v11, v41[0], v42[0], a3);
  uint64_t v13 = icu::CharString::append(v12, 47, a3);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v21, "DateTimePatterns");
  icu::CharString::append(v13, v21, v22, a3);
  uint64_t v14 = ures_getByKeyWithFallback(v6, (char *)v40[0], 0LL, a3);
  if ((int)ures_getSize(v14) < 8 || ures_getType(v14) != 8)
  {
    *a3 = U_INVALID_FORMAT_ERROR;
    goto LABEL_31;
  }

  signed int v15 = 0;
  while (1)
  {
    unsigned int v16 = ures_getByIndex(v14, v15, 0LL, (int *)a3);
    uint64_t v39 = 0LL;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v36 = 0u;
    int v35 = (UChar *)off_18971B688;
    LOWORD(v36) = 2;
    uint64_t v34 = 0LL;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v31 = 0u;
    uint64_t v30 = (UChar *)off_18971B688;
    LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 2;
    int v29 = 0;
    String = ures_getString((uint64_t)v16, &v29, (int *)a3);
    if (*(int *)a3 > 0)
    {
LABEL_22:
      icu::UnicodeString::setToBogus((icu::UnicodeString *)&v30);
      goto LABEL_23;
    }

_BYTE ***icu::DateTimePatternGenerator::addCLDRData(_BYTE ***this, char **a2, UErrorCode *a3)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    uint64_t v5 = this;
    __int128 v61 = 0u;
    uint64_t v64 = 0LL;
    __int128 v63 = 0u;
    __int128 v62 = 0u;
    uint64_t v59 = 0LL;
    int v60 = off_18971B688;
    LOWORD(v6sub_1808F7164((uint64_t)v14, 1) = 2;
    __int128 v56 = 0u;
    __int128 v58 = 0u;
    __int128 v57 = 0u;
    uint64_t v55 = off_18971B688;
    LOWORD(v56) = 2;
    __int128 v51 = 0u;
    uint64_t v54 = 0LL;
    __int128 v53 = 0u;
    __int128 v52 = 0u;
    __int128 v50 = off_18971B688;
    LOWORD(v5sub_1808F7164((uint64_t)v14, 1) = 2;
    memset(&v48[1], 0, 48);
    v48[0] = (char *)&v48[1] + 5;
    LODWORD(v48[1]) = 40;
    uint64_t v49 = 0LL;
    BOOL v35 = 0;
    uint64_t v6 = ures_open(0LL, a2[5], (int *)a3);
    uint64_t v7 = ures_openWithCountryFallback(0LL, a2[5], &v35, (int *)a3);
    if (*(int *)a3 <= 0)
    {
      char v47 = 0;
      *(void *)__int128 v46 = 0LL;
      UErrorCode v34 = U_ZERO_ERROR;
      uint64_t KeywordValue = icu::Locale::getKeywordValue(a2, "numbers", v46, 9, &v34);
      if (v35 && v34 <= U_ZERO_ERROR && !(_DWORD)KeywordValue)
      {
        LODWORD(v36) = 0;
        LODWORD(v44[0]) = -1;
        StringByKeyWithFallbacuint64_t k = ures_getStringByKeyWithFallback( v6,  "NumberElements/default",  (int *)v44,  (UErrorCode *)&v36);
        uint64_t KeywordValue = (uint64_t)ures_getStringByKeyWithFallback( v7,  "NumberElements/default",  (int *)v44,  (UErrorCode *)&v36);
        if ((int)v36 > 0
          || (uint64_t KeywordValue = u_strcmp(StringByKeyWithFallback, (const UChar *)KeywordValue), (_DWORD)KeywordValue))
        {
          BOOL v35 = 0;
        }
      }

      memset(&v44[1], 0, 48);
      v45[1] = 0;
      v44[0] = (char *)&v44[1] + 5;
      LODWORD(v44[1]) = 40;
      v45[0] = 0;
      icu::DateTimePatternGenerator::getCalendarTypeToUse( (icu::DateTimePatternGenerator *)KeywordValue,  (const char **)a2,  (icu::CharString *)v44,  a3);
      if (*(int *)a3 <= 0)
      {
        int v33 = 0;
        v32[0] = &off_1897233C8;
        v32[1] = v5;
        LODWORD(v49) = 0;
        *(_BYTE *)v48[0] = 0;
        icu::StringPiece::StringPiece((icu::StringPiece *)&v30, "calendar");
        __int128 v10 = icu::CharString::append((icu::CharString *)v48, v30, v31, a3);
        __int128 v11 = icu::CharString::append(v10, 47, a3);
        __int128 v12 = icu::CharString::append(v11, v44[0], v45[0], a3);
        uint64_t v13 = icu::CharString::append(v12, 47, a3);
        icu::StringPiece::StringPiece((icu::StringPiece *)&v28, "appendItems");
        icu::CharString::append(v13, v28, v29, a3);
        if (*(int *)a3 <= 0)
        {
          ures_getAllChildrenWithFallback(v6, (char *)v48[0], (uint64_t)v32, &v33);
          sub_1808EBEB8((uint64_t)v32);
          int v33 = 0;
          v27[0] = &off_189723410;
          v27[1] = v5;
          ures_getAllChildrenWithFallback(v6, "fields", (uint64_t)v27, &v33);
          sub_1808EBF8C(v27);
          int v33 = 0;
          icu::DateTimePatternGenerator::initHashtable(v5, a3);
          if (*(int *)a3 <= 0)
          {
            LODWORD(v49) = 0;
            *(_BYTE *)v48[0] = 0;
            icu::StringPiece::StringPiece((icu::StringPiece *)&v25, "calendar");
            uint64_t v14 = icu::CharString::append((icu::CharString *)v48, v25, v26, a3);
            signed int v15 = icu::CharString::append(v14, 47, a3);
            unsigned int v16 = icu::CharString::append(v15, v44[0], v45[0], a3);
            uint64_t v17 = icu::CharString::append(v16, 47, a3);
            icu::StringPiece::StringPiece((icu::StringPiece *)&v23, "availableFormats");
            icu::CharString::append(v17, v23, v24, a3);
            if (*(int *)a3 <= 0)
            {
              if (v35)
              {
                uint64_t v38 = 1LL;
                __int128 v40 = 0u;
                uint64_t v43 = 0LL;
                __int128 v41 = 0u;
                __int128 v42 = 0u;
                __int128 v36 = off_189723098;
                __int128 v37 = v5;
                uint64_t v39 = off_18971B688;
                LOWORD(v40) = 2;
                ures_getAllChildrenWithFallback(v7, (char *)v48[0], (uint64_t)&v36, &v33);
                __int128 v36 = off_189723098;
                icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v39);
                icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v36);
              }

              uint64_t v38 = 0LL;
              __int128 v40 = 0u;
              uint64_t v43 = 0LL;
              __int128 v41 = 0u;
              __int128 v42 = 0u;
              __int128 v36 = off_189723098;
              __int128 v37 = v5;
              uint64_t v39 = off_18971B688;
              LOWORD(v40) = 2;
              ures_getAllChildrenWithFallback(v6, (char *)v48[0], (uint64_t)&v36, &v33);
              __int128 v36 = off_189723098;
              icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)&v39);
              icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v36);
            }
          }

          icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v27);
        }

        icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v32);
      }

      if (BYTE4(v44[1])) {
        uprv_free(v44[0]);
      }
    }

    if (v7) {
      ures_close(v7);
    }
    if (v6) {
      ures_close(v6);
    }
    int v20 = (void *)BYTE4(v48[1]);
    if (BYTE4(v48[1])) {
      uprv_free(v48[0]);
    }
    icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v50);
    icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)&v55);
    return (_BYTE ***)icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)&v60);
  }

  return this;
}

void icu::DateTimePatternGenerator::setDateTimeFromCalendar( icu::DateTimePatternGenerator *this, const icu::Locale *a2, UErrorCode *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    int v26 = 0;
    BaseName = (char *)icu::Locale::getBaseName(a2);
    uint64_t v7 = ures_open(0LL, BaseName, (int *)a3);
    uint64_t v8 = v7;
    if (*(int *)a3 > 0 || (ures_getByKey(v7, "calendar", v7, (int *)a3), *(int *)a3 > 0))
    {
LABEL_51:
      if (v8) {
        ures_close(v8);
      }
      return;
    }

    char v29 = 0;
    memset(v28, 0, sizeof(v28));
    icu::Calendar::getCalendarTypeFromLocale(a2, (const icu::Locale *)v28, (char *)0x20, a3, v9);
    char v29 = 0;
    if (*(int *)a3 > 0 || !LOBYTE(v28[0]))
    {
      *a3 = U_ZERO_ERROR;
      strcpy((char *)v28, "gregorian");
    }

    BOOL v10 = *(void *)&v28[0] == 0x6169726F67657267LL && WORD4(v28[0]) == 110;
    int v11 = !v10;
    if (v10)
    {
      *a3 = U_ZERO_ERROR;
      uint64_t v15 = ures_getByKeyWithFallback(v8, "gregorian", 0LL, a3);
      uint64_t v16 = ures_getByKeyWithFallback(v15, "DateTimePatterns%atTime", 0LL, a3);
    }

    else
    {
      uint64_t v12 = ures_getByKeyWithFallback(v8, (char *)v28, 0LL, a3);
      uint64_t v13 = ures_getByKeyWithFallback(v12, "DateTimePatterns%atTime", 0LL, a3);
      if (v13)
      {
        int v14 = *a3;
        if (*a3 != U_MISSING_RESOURCE_ERROR)
        {
LABEL_22:
          if (v14 <= 0)
          {
            if ((int)ures_getSize(v13) < 4)
            {
              uint64_t v17 = v12;
              goto LABEL_46;
            }

            int v14 = *a3;
          }

          if (v14 != 2)
          {
            int v20 = 0;
            goto LABEL_34;
          }

          *a3 = U_ZERO_ERROR;
          if (v11)
          {
            uint64_t v17 = ures_getByKeyWithFallback(v8, (char *)v28, 0LL, a3);
            if (v12) {
              ures_close(v12);
            }
            uint64_t v13 = ures_getByKeyWithFallback(v17, "DateTimePatterns", 0LL, a3);
            BOOL v18 = v13 == 0;
            if (v13)
            {
              int v19 = *a3;
              if (*a3 != U_MISSING_RESOURCE_ERROR) {
                goto LABEL_44;
              }
            }
          }

          else
          {
            uint64_t v13 = 0LL;
            BOOL v18 = 1;
            uint64_t v17 = v12;
          }

          *a3 = U_ZERO_ERROR;
          uint64_t v23 = ures_getByKeyWithFallback(v8, "gregorian", 0LL, a3);
          if (v17) {
            ures_close(v17);
          }
          uint64_t v24 = ures_getByKeyWithFallback(v23, "DateTimePatterns", 0LL, a3);
          if (!v18) {
            ures_close(v13);
          }
          int v19 = *a3;
          uint64_t v17 = v23;
          uint64_t v13 = v24;
LABEL_44:
          if (v19 > 0)
          {
LABEL_47:
            if (v13) {
              ures_close(v13);
            }
            if (v17) {
              ures_close(v17);
            }
            goto LABEL_51;
          }

          if ((int)ures_getSize(v13) < 13)
          {
LABEL_46:
            *a3 = U_INVALID_FORMAT_ERROR;
            goto LABEL_47;
          }

          int v14 = *a3;
          int v20 = 9;
          uint64_t v12 = v17;
LABEL_34:
          if (v14 <= 0)
          {
            for (unsigned int i = 0; i != 4; ++i)
            {
              StringByIndex = ures_getStringByIndex(v13, v20 + i, &v26, (int *)a3);
              icu::UnicodeString::UnicodeString(v27, 1LL, &StringByIndex);
              icu::DateTimePatternGenerator::setDateTimeFormat((uint64_t)this, i, v27, (int *)a3);
              icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v27);
            }
          }

          uint64_t v17 = v12;
          goto LABEL_47;
        }
      }

      *a3 = U_ZERO_ERROR;
      uint64_t v15 = ures_getByKeyWithFallback(v8, "gregorian", 0LL, a3);
      if (v12) {
        ures_close(v12);
      }
      uint64_t v16 = ures_getByKeyWithFallback(v15, "DateTimePatterns%atTime", 0LL, a3);
      if (v13) {
        ures_close(v13);
      }
    }

    int v14 = *a3;
    uint64_t v12 = v15;
    uint64_t v13 = v16;
    goto LABEL_22;
  }

void icu::DateTimePatternGenerator::setDecimalSymbols( icu::DateTimePatternGenerator *this, const icu::Locale *a2, UErrorCode *a3)
{
  v10[360] = *(UChar **)MEMORY[0x1895F89C0];
  bzero(v9, 0xB48uLL);
  icu::DecimalFormatSymbols::DecimalFormatSymbols((icu::DecimalFormatSymbols *)v9, a2, a3);
  if (*(int *)a3 <= 0)
  {
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v8, v10);
    uint64_t v6 = (icu::DateTimePatternGenerator *)((char *)this + 4616);
    icu::UnicodeString::operator=(v6, (icu::UnicodeString *)v8);
    icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v8);
    icu::UnicodeString::getTerminatedBuffer(v6);
  }

  icu::DecimalFormatSymbols::~DecimalFormatSymbols((icu::DecimalFormatSymbols *)v9);
}

void icu::DateTimePatternGenerator::loadAllowedHourFormatsData( icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  if (*(int *)this <= 0)
  {
    uint64_t v3 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0LL, (int *)this);
    qword_18C4493E0 = (uint64_t)v3;
    if (*(int *)this <= 0)
    {
      uhash_setValueDeleter((uint64_t)v3, (uint64_t)j__uprv_free_1);
      sub_1809B36C0(0x17u, (uint64_t)sub_1808E94F8);
      uint64_t v4 = ures_openDirect(0LL, (uint64_t)"supplementalData", (uint64_t)this);
      uint64_t v5 = v4;
      if (*(int *)this <= 0)
      {
        uint64_t v6 = &off_189723530;
        ures_getAllItemsWithFallback(v4, "timeData", (uint64_t)&v6, (int *)this);
        icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v6);
      }

      if (v5) {
        ures_close(v5);
      }
    }
  }

void icu::DateTimePatternGenerator::getAllowedHourFormats( icu::DateTimePatternGenerator *this, char **a2, UErrorCode *a3)
{
  v26[1] = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    v26[0] = 0LL;
    ulocimp_getRegionForSupplementalData(a2[5], 0, (char *)v26, 8, (int *)a3);
    uint64_t v6 = a2[5];
    if (!*v6 || !strcmp(a2[5], "root") || !strcmp(v6, "und"))
    {
      uint64_t v7 = "und";
      uint64_t v8 = "001";
    }

    else
    {
      uint64_t v7 = (char *)(a2 + 1);
      uint64_t v8 = (const char *)v26;
    }

    memset(v25, 0, sizeof(v25));
    icu::Locale::Locale((icu::Locale *)v25);
    if (!*v7 || (int v9 = *(unsigned __int8 *)v8, !*v8))
    {
      icu::Locale::operator=((icu::Locale *)v25, (uint64_t)a2);
      v24[0] = U_ZERO_ERROR;
      icu::Locale::addLikelySubtags((icu::Locale *)v25, v24);
      BOOL v10 = (char *)v25 + 8;
      if (v24[0] > U_ZERO_ERROR) {
        BOOL v10 = v7;
      }
      else {
        uint64_t v8 = (char *)&v25[1] + 10;
      }
      int v9 = *(unsigned __int8 *)v8;
      if (*v10) {
        uint64_t v7 = v10;
      }
      else {
        uint64_t v7 = "und";
      }
    }

    if (v9) {
      int v11 = (char *)v8;
    }
    else {
      int v11 = "001";
    }
    uint64_t v12 = (unsigned int *)sub_1808EA88C(v7, v11, a3);
    *(void *)uint64_t v24 = 0LL;
    int KeywordValue = icu::Locale::getKeywordValue(a2, "hours", (char *)v24, 8, a3);
    int v15 = 0;
    *((_WORD *)this + 2380) = 0;
    if (*(int *)a3 <= 0 && KeywordValue >= 1)
    {
      int v15 = 0;
      if (v24[0] > 3355239)
      {
        if (v24[0] == 3420776)
        {
          int v15 = 107;
        }

        else
        {
          if (v24[0] != 3355240) {
            goto LABEL_30;
          }
          int v15 = 72;
        }
      }

      else if (v24[0] == 3223912)
      {
        int v15 = 75;
      }

      else
      {
        if (v24[0] != 3289448) {
          goto LABEL_30;
        }
        int v15 = 104;
      }

      *((_WORD *)this + 2380) = v15;
    }

uint64_t sub_1808EA88C(char *__s, const char *a2, UErrorCode *a3)
{
  v11[8] = *(void **)MEMORY[0x1895F89C0];
  memset(&v11[1], 0, 56);
  v11[0] = (char *)&v11[1] + 5;
  LODWORD(v11[1]) = 40;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v9, __s);
  icu::CharString::append((icu::CharString *)v11, v9, v10, a3);
  icu::CharString::append((icu::CharString *)v11, 95, a3);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v7, a2);
  icu::CharString::append((icu::CharString *)v11, v7, v8, a3);
  uint64_t v5 = uhash_get(qword_18C4493E0, (uint64_t)v11[0]);
  if (!v5) {
    uint64_t v5 = uhash_get(qword_18C4493E0, (uint64_t)a2);
  }
  if (BYTE4(v11[1])) {
    uprv_free(v11[0]);
  }
  return v5;
}

uint64_t icu::DateTimePatternGenerator::getDefaultHourCycle( icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  unsigned int v3 = *((unsigned __int16 *)this + 2380);
  if (v3 > 0x4A)
  {
    switch(v3)
    {
      case 'K':
        return 0LL;
      case 'h':
        return 1LL;
      case 'k':
        return 3LL;
    }

void *icu::DateTimePatternGenerator::getSkeleton@<X0>(const icu::UnicodeString *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  bzero(&v12, 0xC80uLL);
  v11[0] = off_189723220;
  uint64_t v6 = 1LL;
  do
  {
    uint64_t v7 = &v11[v6];
    void *v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    v6 += 8LL;
  }

  while (v7 + 8 != &v13);
  uint64_t v13 = 0LL;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  uint64_t v23 = 0LL;
  int v14 = &off_189723268;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  sub_1808EAB48((uint64_t)v24, a1, v11, (uint64_t)&v14);
  sub_1808EAE54((uint64_t)&v14, a2);
  v11[0] = off_189723220;
  for (uint64_t i = 393LL; i != -7; i -= 8LL)
    uint64_t result = icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v11[i]);
  return result;
}

__n128 sub_1808EAB48(uint64_t a1, const icu::UnicodeString *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a4 + 8) = 0u;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 56) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 72) = 0u;
  int v31 = (_OWORD *)(a4 + 72);
  *(_OWORD *)(a4 + 104) = 0u;
  __int128 v32 = (_OWORD *)(a4 + 104);
  *(_OWORD *)(a4 + 88) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  char v29 = (__int128 *)(a4 + 8);
  *(_BYTE *)(a4 + 136) = 0;
  sub_1808EBA0C(a3, a2);
  int v33 = 0;
  if ((int)a3[802] >= 1)
  {
    int v6 = 0;
    do
    {
      uint64_t v7 = &a3[16 * (uint64_t)v6];
      unsigned int v10 = v7[5];
      int v9 = v7 + 5;
      unsigned int v8 = v10;
      unsigned int v11 = *((unsigned __int16 *)v9 - 2);
      if ((v11 & 0x8000u) == 0) {
        unsigned int v12 = v11 >> 5;
      }
      else {
        unsigned int v12 = v8;
      }
      if (!v12) {
        goto LABEL_11;
      }
      uint64_t v13 = *(_WORD **)&a3[16 * (uint64_t)v6 + 8];
      if ((v11 & 2) != 0) {
        uint64_t v13 = (_WORD *)v9 - 1;
      }
      if (*v13 == 39)
      {
        uint64_t v38 = 0LL;
        __int128 v36 = 0u;
        __int128 v37 = 0u;
        __int128 v35 = 0u;
        UErrorCode v34 = off_18971B688;
        LOWORD(v35) = 2;
        sub_1808EBAE4((uint64_t)a3, (icu::UnicodeString *)&v34, &v33);
        icu::UnicodeString::~UnicodeString(v14, (icu::UnicodeString *)&v34);
        int v6 = v33;
      }

      else
      {
LABEL_11:
        int v15 = sub_1808EF0D0((uint64_t)(v9 - 3), 1);
        if ((v15 & 0x80000000) == 0)
        {
          if (v12)
          {
            __int128 v16 = (char *)v9 - 2;
            if ((v11 & 2) == 0) {
              __int128 v16 = *(char **)&a3[16 * (uint64_t)v6 + 8];
            }
            char v17 = *v16;
          }

          else
          {
            char v17 = -1;
          }

          __int128 v18 = &aG_1[8 * v15];
          uint64_t v19 = *((int *)v18 + 1);
          *((_BYTE *)v31 + v19) = v17;
          uint64_t v20 = a4 + v19;
          *(_BYTE *)(v20 + 88) = v12;
          char v21 = *((_BYTE *)v18 + 10);
          *((_BYTE *)v32 + v19) = *(_BYTE *)v18;
          *(_BYTE *)(v20 + 120) = v21;
          int v22 = (__int16)v18[4];
          if (v22 >= 1)
          {
            else {
              int v23 = *((unsigned __int16 *)v9 - 2) >> 5;
            }
            LOWORD(v22) = v22 + v23;
          }

          *(_DWORD *)(a4 + 4 * v19 + 8) = (__int16)v22;
        }
      }

      int v33 = ++v6;
    }

    while (v6 < a3[802]);
  }

  if (*(_BYTE *)(a4 + 100) && *(_BYTE *)(a4 + 102) && !*(_BYTE *)(a4 + 101))
  {
    *(_BYTE *)(a4 + 85) = 115;
    *(_BYTE *)(a4 + 10sub_1808F7164((uint64_t)v14, 1) = 1;
    *(_BYTE *)(a4 + 117) = 115;
    *(_BYTE *)(a4 + 133) = 1;
    *(_DWORD *)(a4 + 60) = 257;
  }

  if (*(_BYTE *)(a4 + 99))
  {
    int v24 = *(char *)(a4 + 83);
    if (v24 == 104 || (unsigned __int16)v24 == 75)
    {
      if (!*(_BYTE *)(a4 + 98))
      {
        *(_BYTE *)(a4 + 82) = 97;
        *(_BYTE *)(a4 + 98) = 1;
        *(_BYTE *)(a4 + 114) = 97;
        *(_BYTE *)(a4 + 130) = 1;
        *(_DWORD *)(a4 + 48) = -259;
        *(_BYTE *)(a4 + 136) = 1;
      }
    }

    else
    {
      *(_BYTE *)(a4 + 82) = 0;
      *(_BYTE *)(a4 + 98) = 0;
      *(_BYTE *)(a4 + 114) = 0;
      *(_BYTE *)(a4 + 130) = 0;
      *(_DWORD *)(a4 + 48) = 0;
    }
  }

  __int128 v25 = *v29;
  __int128 v26 = v29[1];
  __int128 v27 = v29[3];
  *(_OWORD *)(a1 + 48) = v29[2];
  *(_OWORD *)(a1 + 64) = v27;
  *(_OWORD *)(a1 + 16) = v25;
  *(_OWORD *)(a1 + 32) = v26;
  *(_OWORD *)(a1 + 80) = *v31;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a4 + 88);
  *(_OWORD *)(a1 + 112) = *v32;
  __n128 result = *(__n128 *)(a4 + 120);
  *(__n128 *)(a1 + 128) = result;
  *(_BYTE *)(a1 + 144) = *(_BYTE *)(a4 + 136);
  return result;
}

uint64_t sub_1808EAE54@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = 0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  uint64_t v5 = a1 + 72;
  do
    sub_1808EE348(v5, v4++, a2);
  while (v4 != 16);
  uint64_t result = (uint64_t)icu::UnicodeString::operator=((UChar **)a2, (UChar **)a2);
  if (*(_BYTE *)(a1 + 136))
  {
    unsigned int v7 = *(unsigned __int16 *)(a2 + 8);
    int v8 = (__int16)v7;
    int32_t v9 = v7 >> 5;
    if (v8 >= 0) {
      int32_t v10 = v9;
    }
    else {
      int32_t v10 = *(_DWORD *)(a2 + 12);
    }
    uint64_t result = icu::UnicodeString::doIndexOf(a2, 0x61u, 0, v10);
    if ((result & 0x80000000) == 0) {
      return icu::UnicodeString::doReplace(a2, result, 1LL, 0LL, 0, 0LL);
    }
  }

  return result;
}

void *sub_1808EAF3C(void *a1)
{
  *a1 = off_189723220;
  for (uint64_t i = 393LL; i != -7; i -= 8LL)
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&a1[i]);
  return a1;
}

void *icu::DateTimePatternGenerator::staticGetSkeleton@<X0>( icu::DateTimePatternGenerator *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  bzero(&v12, 0xC80uLL);
  v11[0] = off_189723220;
  uint64_t v6 = 1LL;
  do
  {
    unsigned int v7 = &v11[v6];
    void *v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    v6 += 8LL;
  }

  while (v7 + 8 != &v13);
  uint64_t v13 = 0LL;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  uint64_t v23 = 0LL;
  int v14 = &off_189723268;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  sub_1808EAB48((uint64_t)v24, this, v11, (uint64_t)&v14);
  sub_1808EAE54((uint64_t)&v14, a2);
  v11[0] = off_189723220;
  for (uint64_t i = 393LL; i != -7; i -= 8LL)
    uint64_t result = icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v11[i]);
  return result;
}

void *icu::DateTimePatternGenerator::getBaseSkeleton@<X0>( const icu::UnicodeString *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  bzero(&v12, 0xC80uLL);
  v11[0] = off_189723220;
  uint64_t v6 = 1LL;
  do
  {
    unsigned int v7 = &v11[v6];
    void *v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    v6 += 8LL;
  }

  while (v7 + 8 != &v13);
  uint64_t v13 = 0LL;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  uint64_t v23 = 0LL;
  int v14 = &off_189723268;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  sub_1808EAB48((uint64_t)v24, a1, v11, (uint64_t)&v14);
  sub_1808EB1E8((uint64_t)&v14, a2);
  v11[0] = off_189723220;
  for (uint64_t i = 393LL; i != -7; i -= 8LL)
    uint64_t result = icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v11[i]);
  return result;
}

uint64_t sub_1808EB1E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = 0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  uint64_t v5 = a1 + 104;
  do
    sub_1808EE348(v5, v4++, a2);
  while (v4 != 16);
  uint64_t result = (uint64_t)icu::UnicodeString::operator=((UChar **)a2, (UChar **)a2);
  if (*(_BYTE *)(a1 + 136))
  {
    unsigned int v7 = *(unsigned __int16 *)(a2 + 8);
    int v8 = (__int16)v7;
    int32_t v9 = v7 >> 5;
    if (v8 >= 0) {
      int32_t v10 = v9;
    }
    else {
      int32_t v10 = *(_DWORD *)(a2 + 12);
    }
    uint64_t result = icu::UnicodeString::doIndexOf(a2, 0x61u, 0, v10);
    if ((result & 0x80000000) == 0) {
      return icu::UnicodeString::doReplace(a2, result, 1LL, 0LL, 0, 0LL);
    }
  }

  return result;
}

void *icu::DateTimePatternGenerator::staticGetBaseSkeleton@<X0>( icu::DateTimePatternGenerator *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  bzero(&v12, 0xC80uLL);
  v11[0] = off_189723220;
  uint64_t v6 = 1LL;
  do
  {
    unsigned int v7 = &v11[v6];
    void *v7 = off_18971B688;
    *((_WORD *)v7 + 4) = 2;
    v6 += 8LL;
  }

  while (v7 + 8 != &v13);
  uint64_t v13 = 0LL;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  uint64_t v23 = 0LL;
  int v14 = &off_189723268;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  sub_1808EAB48((uint64_t)v24, this, v11, (uint64_t)&v14);
  sub_1808EB1E8((uint64_t)&v14, a2);
  v11[0] = off_189723220;
  for (uint64_t i = 393LL; i != -7; i -= 8LL)
    uint64_t result = icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v11[i]);
  return result;
}

void icu::DateTimePatternGenerator::getCalendarTypeToUse( icu::DateTimePatternGenerator *this, const char **a2, icu::CharString *a3, UErrorCode *a4)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  *((_DWORD *)a3 + 14) = 0;
  **(_BYTE **)a3 = 0;
  icu::CharString::append(a3, "gregorian", -1, a4);
  if (*(int *)a4 <= 0)
  {
    if (!strcmp(a2[5], "ja_JP_TRADITIONAL"))
    {
      *((_DWORD *)a3 + 14) = 0;
      **(_BYTE **)a3 = 0;
      icu::CharString::append(a3, "japanese", -1, a4);
    }

    else
    {
      __int16 v9 = 0;
      memset(v8, 0, sizeof(v8));
      icu::Calendar::getCalendarTypeFromLocale((icu::Calendar *)a2, (const icu::Locale *)v8, (char *)0x32, a4, v7);
      if (*(int *)a4 <= 0)
      {
        *((_DWORD *)a3 + 14) = 0;
        **(_BYTE **)a3 = 0;
        icu::CharString::append(a3, (const char *)v8, -1, a4);
      }
    }
  }

uint64_t icu::DateTimePatternGenerator::addPatternWithSkeleton( icu::DateTimePatternGenerator *this, UChar **a2, UChar **a3, int a4, UChar **a5, UErrorCode *a6)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  UErrorCode v7 = *((_DWORD *)this + 1198);
  if (v7 < U_ILLEGAL_ARGUMENT_ERROR)
  {
    uint64_t v12 = a2;
    __int128 v43 = 0u;
    uint64_t v46 = 0LL;
    __int128 v45 = 0u;
    __int128 v44 = 0u;
    __int128 v42 = off_18971B688;
    LOWORD(v43) = 2;
    __int128 v36 = 0u;
    __int128 v35 = 0u;
    __int128 v34 = 0u;
    __int128 v33 = 0u;
    uint64_t v41 = 0LL;
    uint64_t v31 = 0LL;
    __int128 v32 = &off_189723268;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    v22[0] = &off_189723200;
    v22[1] = &off_189723268;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    if (a3) {
      a2 = a3;
    }
    sub_1808EAB48((uint64_t)v22, (const icu::UnicodeString *)a2, *((_DWORD **)this + 29), (uint64_t)&v32);
    sub_1808EDA38((uint64_t)v22, (uint64_t)&v42);
    char v21 = 0;
    int v14 = (UChar **)sub_1808EDA98(*((void *)this + 32), (uint64_t)&v42, &v21);
    if (!v14 || (!a4 ? (BOOL v15 = a3 == 0LL) : (BOOL v15 = 1), v15 && v21))
    {
      LODWORD(v8) = 0;
    }

    else
    {
      icu::UnicodeString::operator=(a5, v14);
      uint64_t v8 = 1LL;
      if (!a4)
      {
LABEL_23:
        icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)&v42);
        return v8;
      }
    }

    __int128 v20 = 0LL;
    __int128 v17 = (UChar **)*((void *)this + 32);
    __int128 v18 = (UChar **)sub_1808EDBAC((uint64_t)v17, &v32, &v20);
    if (v18)
    {
      icu::UnicodeString::operator=(a5, v18);
      if (!a4 || a3 && (__int128 v16 = v20) != 0LL)
      {
        uint64_t v8 = 2LL;
        goto LABEL_23;
      }

      __int128 v17 = (UChar **)*((void *)this + 32);
      LODWORD(v8) = 2;
    }

    sub_1808EDC94(v17, (unint64_t)&v42, (uint64_t)&v32, v12, a3 != 0LL, (int *)a6);
    __int128 v16 = (void *)*(unsigned int *)a6;
    else {
      uint64_t v8 = v8;
    }
    goto LABEL_23;
  }

  uint64_t v8 = 0LL;
  *a6 = v7;
  return v8;
}

void *icu::DateTimePatternGenerator::hackTimes( icu::DateTimePatternGenerator *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  __int128 v34 = 0u;
  uint64_t v37 = 0LL;
  __int128 v36 = 0u;
  __int128 v35 = 0u;
  __int128 v33 = (UChar *)off_18971B688;
  LOWORD(v34) = 2;
  sub_1808EBA0C(*((_DWORD **)this + 29), a2);
  __int128 v29 = 0u;
  uint64_t v32 = 0LL;
  __int128 v31 = 0u;
  __int128 v30 = 0u;
  __int128 v28 = (UChar *)off_18971B688;
  LOWORD(v29) = 2;
  int v18 = 0;
  int v4 = (int *)*((void *)this + 29);
  if (v4[802] < 1) {
    goto LABEL_32;
  }
  int v5 = 0;
  int v6 = 0;
  while (1)
  {
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v24, (UChar **)&v4[16 * (uint64_t)v6 + 2]);
    char v7 = BYTE8(v24);
    uint64_t v8 = (SWORD4(v24) & 0x8000u) == 0 ? WORD4(v24) >> 5 : HIDWORD(v24);
    if (!(_DWORD)v8) {
      break;
    }
    __int16 v9 = (unsigned __int16 *)*((void *)&v25 + 1);
    if ((BYTE8(v24) & 2) != 0) {
      __int16 v9 = (unsigned __int16 *)&v24 + 5;
    }
    uint64_t v10 = *v9;
    if ((_DWORD)v10 != 39) {
      break;
    }
    if (v5)
    {
      uint64_t v23 = 0LL;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v20 = 0u;
      __int128 v19 = off_18971B688;
      LOWORD(v20) = 2;
      sub_1808EBAE4(*((void *)this + 29), (icu::UnicodeString *)&v19, &v18);
      if ((v20 & 0x8000u) == 0LL) {
        uint64_t v11 = (unsigned __int16)v20 >> 5;
      }
      else {
        uint64_t v11 = DWORD1(v20);
      }
      icu::UnicodeString::doAppend((uint64_t)&v28, (const icu::UnicodeString *)&v19, 0, v11);
      icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v19);
      goto LABEL_25;
    }

void *sub_1808EBA0C(_DWORD *a1, const icu::UnicodeString *a2)
{
  uint64_t v4 = 0LL;
  uint64_t v10 = *MEMORY[0x1895F89C0];
  int v8 = 0;
  a1[802] = 0;
  do
  {
    uint64_t result = (void *)(*(uint64_t (**)(_DWORD *, const icu::UnicodeString *, uint64_t, int *))(*(void *)a1 + 16LL))( a1,  a2,  v4,  &v8);
    if ((_DWORD)result != 1) {
      break;
    }
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v9, a2, v4, v8);
    uint64_t v6 = (int)a1[802];
    a1[802] = v6 + 1;
    icu::UnicodeString::operator=((icu::UnicodeString *)&a1[16 * v6 + 2], (icu::UnicodeString *)v9);
    uint64_t result = icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v9);
    uint64_t v4 = (v8 + v4);
  }

  while ((int)a1[802] < 50);
  return result;
}

uint64_t sub_1808EBAE4(uint64_t result, icu::UnicodeString *this, int *a3)
{
  uint64_t v5 = result;
  int v6 = *a3;
  if ((*((_WORD *)this + 4) & 1) != 0) {
    __int16 v7 = 2;
  }
  else {
    __int16 v7 = *((_WORD *)this + 4) & 0x1F;
  }
  *((_WORD *)this + 4) = v7;
  uint64_t v8 = result + ((uint64_t)v6 << 6);
  unsigned int v9 = *(unsigned __int16 *)(v8 + 16);
  if (*(__int16 *)(v8 + 16) < 0)
  {
    if (!*(_DWORD *)(v8 + 20)) {
      goto LABEL_16;
    }
  }

  else if (!(v9 >> 5))
  {
    goto LABEL_16;
  }

  uint64_t v10 = (const icu::UnicodeString *)(v8 + 8);
  if ((v9 & 2) != 0) {
    uint64_t v11 = (_WORD *)(v8 + 18);
  }
  else {
    uint64_t v11 = *(_WORD **)(result + ((uint64_t)v6 << 6) + 32);
  }
  if (*v11 == 39)
  {
    int v12 = (__int16)v9;
    unsigned int v13 = v9 >> 5;
    if (v12 >= 0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = *(unsigned int *)(result + ((uint64_t)v6 << 6) + 20);
    }
    uint64_t result = icu::UnicodeString::doAppend((uint64_t)this, v10, 0, v14);
    ++v6;
  }

uint64_t sub_1808EBD0C(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0LL;
  unint64_t v3 = *(unsigned __int16 *)(a2 + 8);
  uint64_t v4 = a2 + 10;
  if ((v3 & 2) == 0) {
    uint64_t v4 = *(void *)(a2 + 24);
  }
  uint64_t v5 = (unsigned __int16 *)(a1 + 16);
  if ((v3 & 0x8000) != 0) {
    goto LABEL_6;
  }
LABEL_4:
  unint64_t v6 = v3 >> 5;
  if (v2 >= v3 >> 5) {
    return 1LL;
  }
  while (1)
  {
    if (v6 <= v2
      || ((v7 = *(unsigned __int16 *)(v4 + 2 * v2) - 32, BOOL v8 = v7 > 0x3C, v9 = (1LL << v7) & 0x1000000004003085LL, !v8)
        ? (BOOL v10 = v9 == 0)
        : (BOOL v10 = 1),
          v10))
    {
      unsigned int v11 = *v5;
      if ((__int16)*v5 < 0)
      {
        uint64_t result = *((unsigned int *)v5 + 1);
        if (!(_DWORD)result) {
          return result;
        }
      }

      else
      {
        uint64_t result = v11 >> 5;
        if (!(_DWORD)result) {
          return result;
        }
      }

      unsigned int v13 = (v11 & 2) != 0 ? v5 + 1 : (unsigned __int16 *)*((void *)v5 + 2);
      if (*v13 != 46) {
        return 0LL;
      }
    }

    ++v2;
    v5 += 32;
    if ((v3 & 0x8000) == 0) {
      goto LABEL_4;
    }
LABEL_6:
    unint64_t v6 = *(unsigned int *)(a2 + 12);
  }

uint64_t icu::DateTimePatternGenerator::addPattern( icu::DateTimePatternGenerator *this, UChar **a2, int a3, UChar **a4, UErrorCode *a5)
{
  UErrorCode v5 = *((_DWORD *)this + 1198);
  if (v5 < U_ILLEGAL_ARGUMENT_ERROR) {
    return icu::DateTimePatternGenerator::addPatternWithSkeleton(this, a2, 0LL, a3, a4, a5);
  }
  *a5 = v5;
  return 0LL;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::consumeShortTimePattern( icu::DateTimePatternGenerator *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  return this;
}

void sub_1808EBE28(icu::ResourceSink *a1)
{
}

void sub_1808EBE40(icu::ResourceSink *a1)
{
}

void sub_1808EBE54(uint64_t a1)
{
  *(void *)a1 = off_189723098;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 24));
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)a1);
}

void sub_1808EBE84(uint64_t a1)
{
  *(void *)a1 = off_189723098;
  icu::UnicodeString::~UnicodeString(off_189723098, (icu::UnicodeString *)(a1 + 24));
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)a1);
  icu::UMemory::operator delete(v2);
}

void *sub_1808EBEB8(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  unint64_t v6 = "{";
  icu::UnicodeString::UnicodeString(v7, 1LL, &v6);
  for (uint64_t i = 272LL; i != 1296; i += 64LL)
  {
    unint64_t v3 = *(char **)(a1 + 8);
    if (*(unsigned __int16 *)&v3[i] <= 0x1Fu)
    {
      uint64_t v4 = (UChar **)&v3[i - 8];
      icu::UnicodeString::operator=(v4, (UChar **)v7);
      icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v4);
    }
  }

  return icu::UnicodeString::~UnicodeString(v3, (icu::UnicodeString *)v7);
}

void *sub_1808EBF8C(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = 0LL;
  unint64_t v3 = 0LL;
  uint64_t v15 = *MEMORY[0x1895F89C0];
  do
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = v4 + 192 * v3;
    if (*(unsigned __int16 *)(v5 + 1296) < 0x20u)
    {
      v14[0] = 70;
      else {
        uint64_t v6 = *(unsigned __int16 *)(v5 + 1296) >> 5;
      }
      unsigned int v7 = (icu::UnicodeString *)(v5 + 1288);
      icu::UnicodeString::doReplace(v5 + 1288, 0LL, v6, (uint64_t)v14, 0, 1LL);
      if (v3 > 9)
      {
        v14[0] = 49;
        icu::UnicodeString::doAppend((uint64_t)v7, (uint64_t)v14, 0, 1LL);
        __int16 v8 = v3 + 38;
      }

      else
      {
        __int16 v8 = v3 + 48;
      }

      v14[0] = v8;
      icu::UnicodeString::doAppend((uint64_t)v7, (uint64_t)v14, 0, 1LL);
      uint64_t result = (void *)icu::UnicodeString::getTerminatedBuffer(v7);
    }

    for (uint64_t i = 0LL; i != 128; i += 64LL)
    {
      uint64_t v10 = v1[1];
      if (*(unsigned __int16 *)(v10 + v2 + i + 1360) <= 0x1Fu)
      {
        uint64_t v11 = v10 + v2 + i;
        int v12 = (icu::UnicodeString *)(v11 + 1352);
        icu::UnicodeString::UnicodeString((icu::UnicodeString *)v14, (UChar **)(v11 + 1288));
        icu::UnicodeString::operator=(v12, (icu::UnicodeString *)v14);
        uint64_t result = icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v14);
      }
    }

    ++v3;
    v2 += 192LL;
  }

  while (v3 != 16);
  return result;
}

_BYTE ***icu::DateTimePatternGenerator::initHashtable(_BYTE ***this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    uint64_t v2 = this;
    if (!this[586])
    {
      uint64_t v4 = (int32x2_t *)icu::UMemory::operator new(0LL, (icu::UMemory *)0x58, (unint64_t)a2);
      if (v4)
      {
        uint64_t v5 = v4;
        *uint64_t v4 = 0LL;
        if (*(int *)a2 <= 0
          && (uint64_t v6 = v4 + 1,
              uhash_init(v4 + 1, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0LL, (int *)a2),
              *(int *)a2 <= 0))
        {
          *uint64_t v5 = (int32x2_t)v6;
          uhash_setKeyDeleter((uint64_t)&v5[1], (uint64_t)uprv_deleteUObject);
          int v7 = *a2;
          __int16 v8 = v5;
          if (v7 <= 0)
          {
            __int16 v8 = 0LL;
            v2[586] = (_BYTE **)v5;
          }
        }

        else
        {
          __int16 v8 = v5;
        }
      }

      else
      {
        __int16 v8 = 0LL;
      }

      return sub_1808C144C((_BYTE ***)&v8);
    }
  }

  return this;
}

uint64_t icu::DateTimePatternGenerator::setAppendItemFormat(uint64_t a1, unsigned int a2, UChar **a3)
{
  unint64_t v3 = (UChar **)(a1 + ((unint64_t)a2 << 6) + 264);
  icu::UnicodeString::operator=(v3, a3);
  return icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v3);
}

unint64_t icu::DateTimePatternGenerator::getAppendItemFormat(uint64_t a1, unsigned int a2)
{
  return a1 + ((unint64_t)a2 << 6) + 264;
}

uint64_t icu::DateTimePatternGenerator::setAppendItemName(uint64_t a1, unsigned int a2, UChar **a3)
{
  unint64_t v3 = (UChar **)(a1 + 192LL * a2 + 1288);
  icu::UnicodeString::operator=(v3, a3);
  return icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v3);
}

uint64_t icu::DateTimePatternGenerator::setFieldDisplayName( uint64_t a1, unsigned int a2, unsigned int a3, UChar **a4)
{
  uint64_t v4 = (UChar **)(a1 + 192LL * a2 + ((unint64_t)a3 << 6) + 1288);
  icu::UnicodeString::operator=(v4, a4);
  return icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v4);
}

uint64_t icu::DateTimePatternGenerator::getAppendItemName(uint64_t a1, unsigned int a2)
{
  return a1 + 192LL * a2 + 1288;
}

icu::UnicodeString *icu::DateTimePatternGenerator::getFieldDisplayName@<X0>( uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, icu::UnicodeString *a4@<X8>)
{
  return icu::UnicodeString::UnicodeString(a4, (UChar **)(a1 + 192LL * a2 + ((unint64_t)a3 << 6) + 1288));
}

unint64_t icu::DateTimePatternGenerator::getMutableFieldDisplayName( uint64_t a1, unsigned int a2, unsigned int a3)
{
  return a1 + 192LL * a2 + ((unint64_t)a3 << 6) + 1288;
}

uint64_t icu::DateTimePatternGenerator::getAppendName(uint64_t a1, unsigned int a2, uint64_t a3)
{
  __int16 v18 = 39;
  unsigned int v6 = *(unsigned __int16 *)(a3 + 8);
  int v7 = (__int16)v6;
  unsigned int v8 = v6 >> 5;
  if (v7 >= 0) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = *(unsigned int *)(a3 + 12);
  }
  icu::UnicodeString::doReplace(a3, 0LL, v9, (uint64_t)&v18, 0, 1LL);
  uint64_t v10 = a1 + 192LL * a2;
  uint64_t v11 = (const icu::UnicodeString *)(v10 + 1288);
  unsigned int v12 = *(unsigned __int16 *)(v10 + 1296);
  int v13 = (__int16)v12;
  unsigned int v14 = v12 >> 5;
  unsigned int v15 = *(_DWORD *)(v10 + 1300);
  if (v13 >= 0) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v15;
  }
  icu::UnicodeString::doAppend(a3, v11, 0, v16);
  __int16 v19 = 39;
  return icu::UnicodeString::doAppend(a3, (uint64_t)&v19, 0, 1LL);
}

void *icu::DateTimePatternGenerator::getBestPattern@<X0>( icu::DateTimePatternGenerator *this@<X0>, const icu::UnicodeString *a2@<X1>, UErrorCode *a3@<X2>, icu::UnicodeString *a4@<X8>)
{
  return icu::DateTimePatternGenerator::getBestPattern(this, (uint64_t)a2, 0, (int *)a3, a4);
}

void *icu::DateTimePatternGenerator::getBestPattern@<X0>( void *result@<X0>, uint64_t a2@<X1>, int a3@<W2>, int *a4@<X3>, icu::UnicodeString *a5@<X8>)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  if (*a4 >= 1) {
    goto LABEL_4;
  }
  int v7 = result;
  int v8 = *((_DWORD *)result + 1198);
  if (v8 < 1)
  {
    __int128 v54 = 0u;
    uint64_t v57 = 0LL;
    __int128 v56 = 0u;
    __int128 v55 = 0u;
    uint64_t v52 = 0LL;
    __int128 v53 = (UChar *)off_18971B688;
    LOWORD(v54) = 2;
    __int128 v49 = 0u;
    __int128 v51 = 0u;
    __int128 v50 = 0u;
    __int128 v48 = off_18971B688;
    LOWORD(v49) = 2;
    int v44 = 0;
    memset(v47, 0, sizeof(v47));
    icu::DateTimePatternGenerator::mapSkeletonMetacharacters( (uint64_t)result,  a2,  &v44,  a3,  a4,  (icu::UnicodeString *)v47);
    uint64_t v10 = *a4;
    if ((int)v10 >= 1)
    {
      *(void *)a5 = off_18971B688;
      *((_WORD *)a5 + 4) = 2;
LABEL_48:
      icu::UnicodeString::~UnicodeString((void *)v10, (icu::UnicodeString *)v47);
      icu::UnicodeString::~UnicodeString(v40, (icu::UnicodeString *)&v48);
      return icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)&v53);
    }

    LOWORD(v49) = 2;
    unsigned int v12 = (_DWORD *)v7[29];
    uint64_t v11 = v7[30];
    __int128 v62 = 0u;
    __int128 v61 = 0u;
    __int128 v60 = 0u;
    __int128 v59 = 0u;
    uint64_t v67 = 0LL;
    __int128 v58 = &off_189723268;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    sub_1808EAB48(v11, (const icu::UnicodeString *)v47, v12, (uint64_t)&v58);
    uint64_t v43 = 0LL;
    uint64_t BestRaw = icu::DateTimePatternGenerator::getBestRaw((uint64_t)v7, v7[30], -1, v7[31], a4, &v43);
    unsigned int v14 = (const icu::UnicodeString *)BestRaw;
    unsigned int v15 = *(unsigned __int16 *)(BestRaw + 8);
    if ((v15 & 0x8000) != 0) {
      int32_t v16 = *(_DWORD *)(BestRaw + 12);
    }
    else {
      int32_t v16 = v15 >> 5;
    }
    if (*a4 >= 1)
    {
      *(void *)a5 = off_18971B688;
      uint64_t v10 = 2LL;
      *((_WORD *)a5 + 4) = 2;
      goto LABEL_48;
    }

    uint64_t v17 = v7[31];
    if (!*(_DWORD *)(v17 + 8) && !*(_DWORD *)(v17 + 12))
    {
      icu::DateTimePatternGenerator::adjustFieldTypes((uint64_t)v7, v14, v43, v44, a3, (uint64_t)&v58);
      icu::UnicodeString::operator=((icu::UnicodeString *)&v48, (icu::UnicodeString *)&v58);
      icu::UnicodeString::~UnicodeString(v35, (icu::UnicodeString *)&v58);
      icu::UnicodeString::UnicodeString(a5, (icu::UnicodeString *)&v48);
      goto LABEL_48;
    }

    uint64_t v18 = 0LL;
    int32x4_t v19 = (int32x4_t)xmmword_180A267F0;
    int8x16_t v20 = 0uLL;
    v21.i64[0] = 0x100000001LL;
    v21.i64[1] = 0x100000001LL;
    v22.i64[0] = 0x400000004LL;
    v22.i64[1] = 0x400000004LL;
    do
    {
      int8x16_t v20 = vorrq_s8( vbicq_s8( (int8x16_t)vshlq_u32(v21, (uint32x4_t)v19),  (int8x16_t)vceqzq_s32(*(int32x4_t *)(v7[30] + 16LL + v18))),  v20);
      int32x4_t v19 = vaddq_s32(v19, v22);
      v18 += 16LL;
    }

    while (v18 != 64);
    int8x8_t v23 = vorr_s8(*(int8x8_t *)v20.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
    __int16 v24 = v23.i16[0] | v23.i16[2];
    memset(v46, 0, sizeof(v46));
    char v25 = v44;
    icu::DateTimePatternGenerator::getBestAppending( v7,  (v23.i16[0] | v23.i16[2]) & 0x3FF,  v44,  a4,  a3,  (icu::UnicodeString *)v46);
    memset(v45, 0, sizeof(v45));
    icu::DateTimePatternGenerator::getBestAppending(v7, v24 & 0xFC00, v25, a4, a3, (icu::UnicodeString *)v45);
    if (*a4 >= 1)
    {
      *(void *)a5 = off_18971B688;
      uint64_t v26 = 2LL;
      *((_WORD *)a5 + 4) = 2;
LABEL_47:
      icu::UnicodeString::~UnicodeString((void *)v26, (icu::UnicodeString *)v45);
      icu::UnicodeString::~UnicodeString(v39, (icu::UnicodeString *)v46);
      goto LABEL_48;
    }

    if ((SWORD4(v46[0]) & 0x8000u) == 0) {
      int v27 = WORD4(v46[0]) >> 5;
    }
    else {
      int v27 = HIDWORD(v46[0]);
    }
    if (v27)
    {
      int v28 = HIDWORD(v45[0]);
      int v29 = WORD4(v45[0]) >> 5;
    }

    else
    {
      int v29 = WORD4(v45[0]) >> 5;
      int v28 = HIDWORD(v45[0]);
      if ((SWORD4(v45[0]) & 0x8000u) == 0) {
        int v36 = WORD4(v45[0]) >> 5;
      }
      else {
        int v36 = HIDWORD(v45[0]);
      }
      if (v36)
      {
        uint64_t v37 = (icu::UnicodeString *)v45;
LABEL_46:
        icu::UnicodeString::UnicodeString(a5, v37);
        goto LABEL_47;
      }

      if ((v49 & 1) != 0) {
        __int16 v42 = 2;
      }
      else {
        __int16 v42 = v49 & 0x1F;
      }
      LOWORD(v49) = v42;
    }

    if ((SWORD4(v45[0]) & 0x8000u) == 0) {
      int v30 = v29;
    }
    else {
      int v30 = v28;
    }
    if (v30)
    {
      if ((v49 & 1) != 0) {
        __int16 v31 = 2;
      }
      else {
        __int16 v31 = v49 & 0x1F;
      }
      LOWORD(v49) = v31;
      *a4 = 0;
      uint64_t v32 = v7[30];
      int v33 = *(char *)(v32 + 131);
      if (v33 == 3)
      {
        unsigned int v34 = 2;
      }

      else if (v33 == 4)
      {
        unsigned int v34 = *(char *)(v32 + 134) < 1;
      }

      else
      {
        unsigned int v34 = 3;
      }

      DateTimeFormat = (UChar **)icu::DateTimePatternGenerator::getDateTimeFormat((uint64_t)v7, v34, a4);
      icu::UnicodeString::operator=(&v53, DateTimeFormat);
      *(void *)&__int128 v59 = off_18971B688;
      WORD4(v59) = 2;
      icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)&v58,  (const icu::UnicodeString *)&v53,  2,  2,  0,  (UErrorCode *)a4);
      icu::SimpleFormatter::format( (icu::SimpleFormatter *)&v58,  (const icu::UnicodeString *)v45,  (const icu::UnicodeString *)v46,  (icu::UnicodeString *)&v48,  (UErrorCode *)a4);
      icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)&v58);
      uint64_t v37 = (icu::UnicodeString *)&v48;
    }

    else
    {
      uint64_t v37 = (icu::UnicodeString *)v46;
    }

    goto LABEL_46;
  }

  *a4 = v8;
LABEL_4:
  *(void *)a5 = off_18971B688;
  *((_WORD *)a5 + 4) = 2;
  return result;
}

void *icu::DateTimePatternGenerator::mapSkeletonMetacharacters@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, int a4@<W3>, _DWORD *a5@<X4>, icu::UnicodeString *a6@<X8>)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  uint64_t v50 = 0LL;
  __int128 v49 = 0u;
  uint64_t v46 = off_18971B688;
  LOWORD(v47) = 2;
  int v6 = *(unsigned __int16 *)(a1 + 4760);
  if ((a4 & 0x60000000) == 0x20000000) {
    int v6 = 104;
  }
  if ((a4 & 0x60000000) == 0x40000000) {
    int v7 = 72;
  }
  else {
    int v7 = v6;
  }
  unsigned int v8 = *(unsigned __int16 *)(a2 + 8);
  int v9 = (__int16)v8;
  unsigned int v10 = v8 >> 5;
  if (v9 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = *(unsigned int *)(a2 + 12);
  }
  int v13 = 0;
  BOOL v14 = 0;
  uint64_t v15 = a2 + 10;
  uint64_t v16 = a1 + 4764;
  do
  {
    unsigned int v17 = *(unsigned __int16 *)(a2 + 8);
    unsigned int v18 = v17 >> 5;
    if ((v17 & 0x8000u) != 0) {
      unsigned int v18 = *(_DWORD *)(a2 + 12);
    }
    if (v18 <= v13)
    {
      int v20 = 0xFFFF;
    }

    else
    {
      uint64_t v19 = *(void *)(a2 + 24);
      if ((v17 & 2) != 0) {
        uint64_t v19 = v15;
      }
      int v20 = *(unsigned __int16 *)(v19 + 2LL * v13);
      if (v20 == 39)
      {
        BOOL v14 = !v14;
        goto LABEL_81;
      }
    }

    if (v14)
    {
      BOOL v14 = 1;
      goto LABEL_81;
    }

    if (v20 != 106)
    {
      if (v20 == 74)
      {
        __int16 v45 = 72;
        icu::UnicodeString::doAppend((uint64_t)&v46, (uint64_t)&v45, 0, 1LL);
        BOOL v14 = 0;
        *a3 |= 2u;
        goto LABEL_81;
      }

      if (v20 != 67)
      {
        __int16 v45 = v20;
        icu::UnicodeString::doAppend((uint64_t)&v46, (uint64_t)&v45, 0, 1LL);
        BOOL v14 = 0;
        goto LABEL_81;
      }
    }

    int v21 = v13 + 1;
    if (v13 + 1 >= (int)v11)
    {
      int v28 = 1;
      int v29 = 1;
    }

    else
    {
      uint64_t v22 = 0LL;
      if ((v17 & 2) != 0) {
        uint64_t v23 = v15;
      }
      else {
        uint64_t v23 = *(void *)(a2 + 24);
      }
      unsigned int v24 = v11 - 1 - v13;
      uint64_t v25 = v23 + 2LL * v21;
      uint64_t v26 = v11 - v21;
      while (1)
      {
        int v27 = v18 <= v13 + (int)v22 + 1 ? 0xFFFF : *(unsigned __int16 *)(v25 + 2 * v22);
        if (v27 != v20) {
          break;
        }
        if (v26 == ++v22)
        {
          int v13 = v11 - 1;
          goto LABEL_39;
        }
      }

      v13 += v22;
      unsigned int v24 = v22;
LABEL_39:
      int v28 = (v24 & 1) + 1;
      if (v24 <= 1) {
        int v29 = 1;
      }
      else {
        int v29 = (v24 >> 1) + 3;
      }
    }

    if (v20 == 106)
    {
      __int16 v30 = 97;
      int v31 = v7;
      goto LABEL_74;
    }

    if (*(_DWORD *)(a1 + 4764) == -1)
    {
      *a5 = 3;
      *(void *)a6 = off_18971B688;
      uint64_t v39 = 2LL;
      *((_WORD *)a6 + 4) = 2;
      return icu::UnicodeString::~UnicodeString((void *)v39, (icu::UnicodeString *)&v46);
    }

    unint64_t v32 = 0LL;
    while (1)
    {
      unsigned int v33 = *(_DWORD *)(v16 + 4 * v32);
      if (v33 + 1 > 0xA)
      {
LABEL_56:
        if (v7 == 75 || v7 == 104) {
          goto LABEL_60;
        }
        goto LABEL_50;
      }

      if (((1 << (v33 + 1)) & 0x614) != 0)
      {
        if (v7 == 72 || v7 == 107) {
          goto LABEL_60;
        }
LABEL_50:
        int v34 = -1;
        goto LABEL_51;
      }

      int v34 = *(_DWORD *)(a1 + 4764);
      if (v33 != -1) {
        goto LABEL_56;
      }
LABEL_51:
      if (v34 != -1) {
        break;
      }
      unsigned int v33 = -1;
      if (v32++ >= 6) {
        goto LABEL_60;
      }
    }

    unsigned int v33 = v34;
LABEL_60:
    if (v33 > 9) {
      goto LABEL_67;
    }
    if (((1 << v33) & 0xC4) != 0)
    {
      int v31 = 75;
    }

    else
    {
      if (((1 << v33) & 0x302) != 0)
      {
        int v31 = 72;
        goto LABEL_68;
      }

      if (v33 == 3)
      {
        int v31 = 107;
        goto LABEL_73;
      }

uint64_t icu::DateTimePatternGenerator::getBestRaw( uint64_t a1, uint64_t a2, int a3, uint64_t a4, int *a5, void *a6)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  uint64_t v30 = 0LL;
  uint64_t v29 = 0LL;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  sub_1808EF1DC((uint64_t)&v27, a5);
  uint64_t v12 = 0LL;
  if (*a5 <= 0)
  {
    uint64_t v29 = *(void *)(a1 + 256);
    if (sub_1808EE100((uint64_t)&v27))
    {
      uint64_t v24 = a4;
      uint64_t v25 = a2;
      uint64_t v12 = 0LL;
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      int v14 = 0x7FFFFFFF;
      int v26 = -1;
      do
      {
        uint64_t v43 = 0LL;
        uint64_t v15 = sub_1808EE164((uint64_t)&v27);
        __int128 v16 = *(_OWORD *)(v15 + 32);
        __int128 v35 = *(_OWORD *)(v15 + 16);
        __int128 v36 = v16;
        __int128 v17 = *(_OWORD *)(v15 + 64);
        __int128 v37 = *(_OWORD *)(v15 + 48);
        __int128 v38 = v17;
        __int128 v18 = *(_OWORD *)(v15 + 96);
        __int128 v39 = *(_OWORD *)(v15 + 80);
        __int128 v40 = v18;
        __int128 v19 = *(_OWORD *)(v15 + 128);
        __int128 v41 = *(_OWORD *)(v15 + 112);
        unsigned int v33 = &off_189723200;
        int v34 = &off_189723268;
        __int128 v42 = v19;
        LOBYTE(v43) = *(_BYTE *)(v15 + 144);
        if (!sub_1808EE23C(&v33, *(void **)(a1 + 4680)))
        {
          int v20 = sub_1808EE274(v25, (uint64_t)&v33, a3, (uint64_t)&v31);
          int v21 = v20;
          int v22 = v32;
          if (v20 < v14 || v20 == v14 && v26 < (int)v32)
          {
            uint64_t v12 = sub_1808EDBAC(*(void *)(a1 + 256), &v34, &v30);
            int v23 = HIDWORD(v32);
            *(_DWORD *)(v24 + 8) = v22;
            *(_DWORD *)(v24 + 12) = v23;
            if (!v21) {
              break;
            }
            int v14 = v21;
            int v26 = v22;
          }
        }
      }

      while (sub_1808EE100((uint64_t)&v27));
      if (a6 && v12) {
        *a6 = v30;
      }
    }

    else
    {
      uint64_t v12 = 0LL;
    }
  }

  *(void *)&__int128 v27 = &off_189723248;
  if (*((void *)&v28 + 1)) {
    (*(void (**)(void))(**((void **)&v28 + 1) + 8LL))(*((void *)&v28 + 1));
  }
  return v12;
}

void *icu::DateTimePatternGenerator::adjustFieldTypes@<X0>( uint64_t a1@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, int a5@<W4>, uint64_t a6@<X8>)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a6 + 8) = 0u;
  *(void *)(a6 + 56) = 0LL;
  *(_OWORD *)(a6 + 40) = 0u;
  *(_OWORD *)(a6 + 24) = 0u;
  *(void *)a6 = off_18971B688;
  *(_WORD *)(a6 + 8) = 2;
  uint64_t result = sub_1808EBA0C(*(_DWORD **)(a1 + 232), a2);
  int v65 = 0;
  uint64_t v11 = *(void *)(a1 + 232);
  if (*(int *)(v11 + 3208) >= 1)
  {
    int v12 = 0;
    char v63 = a4;
    while (1)
    {
      __int128 v73 = 0u;
      __int128 v74 = 0u;
      __int128 v71 = 0u;
      __int128 v72 = 0u;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v71, (UChar **)(v11 + ((uint64_t)v12 << 6) + 8));
      char v13 = BYTE8(v71);
      if ((SWORD4(v71) & 0x8000u) == 0) {
        uint64_t v14 = WORD4(v71) >> 5;
      }
      else {
        uint64_t v14 = HIDWORD(v71);
      }
      if ((_DWORD)v14)
      {
        uint64_t v15 = (_WORD *)*((void *)&v72 + 1);
        if ((BYTE8(v71) & 2) != 0) {
          uint64_t v15 = (_WORD *)&v71 + 5;
        }
        if (*v15 == 39)
        {
          uint64_t v70 = 0LL;
          __int128 v68 = 0u;
          __int128 v69 = 0u;
          __int128 v67 = 0u;
          __int128 v66 = off_18971B688;
          LOWORD(v67) = 2;
          sub_1808EBAE4(*(void *)(a1 + 232), (icu::UnicodeString *)&v66, &v65);
          if ((v67 & 0x8000u) == 0LL) {
            uint64_t v16 = (unsigned __int16)v67 >> 5;
          }
          else {
            uint64_t v16 = DWORD1(v67);
          }
          icu::UnicodeString::doAppend(a6, (const icu::UnicodeString *)&v66, 0, v16);
          icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v66);
          goto LABEL_129;
        }
      }

      if (!sub_1808EBD0C(*(void *)(a1 + 232), (uint64_t)&v71))
      {
        unsigned int v21 = sub_1808EF0D0((uint64_t)&v71, 1);
        if ((v21 & 0x80000000) == 0) {
          break;
        }
      }

      uint64_t v19 = a6;
      uint64_t v20 = v14;
LABEL_128:
      icu::UnicodeString::doAppend(v19, (const icu::UnicodeString *)&v71, 0, v20);
LABEL_129:
      uint64_t result = icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v71);
      int v12 = v65 + 1;
      int v65 = v12;
      uint64_t v11 = *(void *)(a1 + 232);
      if (v12 >= *(_DWORD *)(v11 + 3208)) {
        return result;
      }
    }

    unsigned int v22 = v21 & 0xFFFFFFFE;
    if ((a4 & 1) != 0 && v22 == 64)
    {
      unsigned int v23 = *(unsigned __int16 *)(a1 + 4624);
      int v24 = (__int16)v23;
      unsigned int v25 = v23 >> 5;
      if (v24 >= 0) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = *(unsigned int *)(a1 + 4628);
      }
      icu::UnicodeString::doAppend((uint64_t)&v71, (const icu::UnicodeString *)(a1 + 4616), 0, v26);
      sub_1808EE348(*(void *)(a1 + 240) + 80LL, 14, (uint64_t)&v71);
      goto LABEL_124;
    }

    uint64_t v27 = *(int *)&aG_1[8 * v21 + 2];
    uint64_t v28 = *(void *)(a1 + 240);
    if (!*(_DWORD *)(v28 + 4 * v27 + 16))
    {
LABEL_124:
      if ((SWORD4(v71) & 0x8000u) == 0) {
        uint64_t v20 = WORD4(v71) >> 5;
      }
      else {
        uint64_t v20 = HIDWORD(v71);
      }
      uint64_t v19 = a6;
      goto LABEL_128;
    }

    uint64_t v29 = v28 + v27;
    int v30 = *(char *)(v29 + 80);
    int v31 = *(char *)(v29 + 96);
    BOOL v32 = v31 < 3 && v30 == 69;
    if (v32) {
      int v33 = 3;
    }
    else {
      int v33 = v31;
    }
    unint64_t v34 = v21 - 56LL;
    BOOL v36 = (a5 & 0x1000) == 0 && v21 == 63;
    BOOL v38 = (a5 & 0x2000) == 0 && v22 == 64;
    BOOL v39 = v34 < 7 && (a5 & 0x800) == 0;
    int v40 = v14;
    if (!v39)
    {
      int v40 = v14;
      if (!v36)
      {
        int v40 = v14;
        if (!v38)
        {
          if (!a3 || v30 == 99)
          {
            int v40 = v33;
          }

          else
          {
            int v40 = v33;
            if (v30 != 101)
            {
              int v41 = (__int16)aG_1[8 * v21 + 4];
              BOOL v42 = v41 < 1;
              int v43 = *(_DWORD *)(a3 + 4 * v27 + 8);
              BOOL v44 = v43 <= 0;
              BOOL v45 = v43 > 0;
              if (!v44) {
                BOOL v42 = 1;
              }
              int v46 = *(char *)(a3 + v27 + 88);
              BOOL v47 = v41 < 1 && v45;
              BOOL v32 = v33 == v46;
              int v48 = !v42;
              if (v32) {
                int v48 = 1;
              }
              if (v48 | v47) {
                int v40 = v14;
              }
              else {
                int v40 = v33;
              }
            }
          }
        }
      }
    }

    if ((unint64_t)v21 - 63 > 0xFFFFFFFFFFFFFFF8LL
      || (unint64_t)v21 - 27 > 0xFFFFFFFFFFFFFFF6LL
      || (unint64_t)v21 - 43 > 0xFFFFFFFFFFFFFFF1LL)
    {
      if (!(_DWORD)v14)
      {
        __int16 v50 = -1;
LABEL_80:
        if (v40 < 3 && v50 == 69) {
          __int16 v53 = 101;
        }
        else {
          __int16 v53 = v50;
        }
        if (v34 <= 6 && *(_WORD *)(a1 + 4760))
        {
          int v54 = icu::DateTimePatternGenerator::defaultHourPeriodCharForHourCycle(a1, a5);
          __int16 v55 = (a5 & 0x20000000) != 0 ? 104 : v54;
          __int16 v56 = (a5 & 0x20000000) != 0 ? 104 : v53;
          if ((a5 & 0x40000000) != 0)
          {
            __int16 v55 = 72;
            __int16 v57 = 72;
          }

          else
          {
            __int16 v57 = v56;
          }

          unsigned __int16 v58 = (v63 & 2) != 0 ? v55 : v30;
          __int16 v59 = (v63 & 2) != 0 ? v57 : v53;
          __int16 v53 = v54;
          if (v54 != v58)
          {
            if (v58 == 104 && v54 == 75)
            {
              __int16 v53 = 75;
            }

            else if (v58 == 72 && v54 == 107)
            {
              __int16 v53 = 107;
            }

            else if (v58 == 107 && v54 == 72)
            {
              __int16 v53 = 72;
            }

            else if (v54 == 104 && v58 == 75)
            {
              __int16 v53 = 104;
            }

            else
            {
              __int16 v53 = v59;
            }
          }
        }

        __int16 v61 = v13 & 0x1F;
        if ((v13 & 1) != 0) {
          __int16 v61 = 2;
        }
        WORD4(v7sub_1808F7164((uint64_t)v14, 1) = v61;
        a4 = v63;
        if (v40 >= 1)
        {
          unsigned int v62 = v40 + 1;
          do
          {
            LOWORD(v66) = v53;
            icu::UnicodeString::doAppend((uint64_t)&v71, (uint64_t)&v66, 0, 1LL);
            --v62;
          }

          while (v62 > 1);
        }

        goto LABEL_124;
      }
    }

    else
    {
      BOOL v49 = (unint64_t)v21 - 10 < 0xFFFFFFFFFFFFFFF9LL || v30 == 89;
      if (v49) {
        __int16 v50 = v30;
      }
      else {
        __int16 v50 = -1;
      }
      if (v49 || !(_DWORD)v14) {
        goto LABEL_80;
      }
    }

    uint64_t v51 = (__int16 *)*((void *)&v72 + 1);
    if ((v13 & 2) != 0) {
      uint64_t v51 = (__int16 *)&v71 + 5;
    }
    __int16 v50 = *v51;
    goto LABEL_80;
  }

  return result;
}

void *icu::DateTimePatternGenerator::getBestAppending@<X0>( void *result@<X0>, int a2@<W1>, char a3@<W2>, int *a4@<X3>, int a5@<W4>, icu::UnicodeString *a6@<X8>)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (*a4 >= 1)
  {
    *(void *)a6 = off_18971B688;
    *((_WORD *)a6 + 4) = 2;
    return result;
  }

  __int128 v46 = 0u;
  uint64_t v49 = 0LL;
  __int128 v48 = 0u;
  __int128 v47 = 0u;
  BOOL v45 = (UChar *)off_18971B688;
  LOWORD(v46) = 2;
  __int128 v41 = 0u;
  uint64_t v44 = 0LL;
  __int128 v43 = 0u;
  __int128 v42 = 0u;
  int v40 = (UChar *)off_18971B688;
  LOWORD(v4sub_1808F7164((uint64_t)v14, 1) = 2;
  if (!a2) {
    goto LABEL_22;
  }
  uint64_t v11 = (uint64_t)result;
  int v31 = off_18971B688;
  LOWORD(v32) = 2;
  icu::UnicodeString::operator=((icu::UnicodeString *)&v45, (icu::UnicodeString *)&v31);
  icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v31);
  uint64_t v30 = 0LL;
  uint64_t BestRaw = (UChar **)icu::DateTimePatternGenerator::getBestRaw( v11,  *(void *)(v11 + 240),  a2,  *(void *)(v11 + 248),  a4,  &v30);
  if (*a4 < 1)
  {
    icu::UnicodeString::operator=(&v40, BestRaw);
    icu::DateTimePatternGenerator::adjustFieldTypes(v11, (const icu::UnicodeString *)&v40, v30, a3, a5, (uint64_t)&v31);
    icu::UnicodeString::operator=((icu::UnicodeString *)&v45, (icu::UnicodeString *)&v31);
    icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)&v31);
    uint64_t v16 = *(void *)(v11 + 248);
    unsigned int v17 = *(_DWORD *)(v16 + 8);
    if (v17)
    {
      if ((~a2 & 0x6000) != 0
        || (*(_DWORD *)(v16 + 8) & 0x6000) != 0x4000
        || (icu::DateTimePatternGenerator::adjustFieldTypes( v11,  (const icu::UnicodeString *)&v45,  v30,  a3 | 1,  a5,  (uint64_t)&v31),  icu::UnicodeString::operator=((icu::UnicodeString *)&v45, (icu::UnicodeString *)&v31),  icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v31),  uint64_t v16 = *(void *)(v11 + 248),  v17 = *(_DWORD *)(v16 + 8) & 0xFFFFBFFF,  (*(_DWORD *)(v16 + 8) = v17) != 0))
      {
        uint64_t v19 = (UChar **)icu::DateTimePatternGenerator::getBestRaw(v11, *(void *)(v11 + 240), v17, v16, a4, &v30);
        if (*a4 >= 1) {
          goto LABEL_5;
        }
        icu::UnicodeString::operator=(&v40, v19);
        icu::DateTimePatternGenerator::adjustFieldTypes( v11,  (const icu::UnicodeString *)&v40,  v30,  a3,  a5,  (uint64_t)&v31);
        icu::UnicodeString::operator=((icu::UnicodeString *)&v40, (icu::UnicodeString *)&v31);
        icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v31);
        int v21 = v17 & ~*(_DWORD *)(*(void *)(v11 + 248) + 8LL);
        if (v21)
        {
          unsigned int v22 = -1;
          do
          {
            ++v22;
            BOOL v23 = v21 > 1;
            v21 >>= 1;
          }

          while (v23);
          if (v22 >= 0xF) {
            unsigned int v22 = 15;
          }
        }

        else
        {
          unsigned int v22 = 0;
        }

        unsigned int v24 = v22;
        unint64_t v25 = v11 + ((unint64_t)v22 << 6);
        else {
          int v26 = *(unsigned __int16 *)(v25 + 272) >> 5;
        }
        if (v26)
        {
          __int128 v36 = 0u;
          uint64_t v27 = (const icu::UnicodeString *)(v25 + 264);
          uint64_t v39 = 0LL;
          __int128 v38 = 0u;
          __int128 v37 = 0u;
          __int128 v35 = off_18971B688;
          LOWORD(v36) = 2;
          icu::DateTimePatternGenerator::getAppendName(v11, v24, (uint64_t)&v35);
          v34[0] = (icu::UnicodeString *)&v45;
          v34[1] = (icu::UnicodeString *)&v40;
          v34[2] = (icu::UnicodeString *)&v35;
          BOOL v32 = off_18971B688;
          __int16 v33 = 2;
          icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)&v31,  v27,  2,  3,  0,  (UErrorCode *)a4);
          icu::SimpleFormatter::formatAndReplace((icu::SimpleFormatter *)&v31, v34, 3u, &v45, 0LL, 0, (UErrorCode *)a4);
          icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)&v31);
          icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v35);
        }
      }
    }

void *icu::DateTimePatternGenerator::getDateTimeFormat(uint64_t a1, unsigned int a2, int *a3)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_18C535408);
  if ((v3 & 1) == 0)
  {
    uint64_t v5 = a1;
    int v6 = a3;
    unsigned int v7 = a2;
    int v8 = __cxa_guard_acquire(&qword_18C535408);
    a2 = v7;
    a3 = v6;
    int v9 = v8;
    a1 = v5;
    if (v9)
    {
      unsigned int v10 = &unk_180A479F2;
      icu::UnicodeString::UnicodeString(&unk_18C5353C8, 1LL, &v10);
      __cxa_atexit((void (*)(void *))icu::UnicodeString::~UnicodeString, &unk_18C5353C8, &dword_1807BC000);
      __cxa_guard_release(&qword_18C535408);
      a2 = v7;
      a1 = v5;
      a3 = v6;
    }
  }

  if (*a3 <= 0)
  {
    if (a2 < 4) {
      return (void *)(a1 + ((unint64_t)a2 << 6) + 4360);
    }
    *a3 = 1;
  }

  return &unk_18C5353C8;
}

void *icu::DateTimePatternGenerator::replaceFieldTypes@<X0>( icu::DateTimePatternGenerator *this@<X0>, const icu::UnicodeString *a2@<X1>, const icu::UnicodeString *a3@<X2>, UErrorCode *a4@<X3>, uint64_t a5@<X8>)
{
  return icu::DateTimePatternGenerator::replaceFieldTypes(this, a2, a3, 0, (int *)a4, a5);
}

void *icu::DateTimePatternGenerator::replaceFieldTypes@<X0>( void *result@<X0>, const icu::UnicodeString *a2@<X1>, const icu::UnicodeString *a3@<X2>, int a4@<W3>, int *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (*a5 >= 1) {
    goto LABEL_4;
  }
  uint64_t v7 = (uint64_t)result;
  int v8 = *((_DWORD *)result + 1198);
  if (v8 >= 1)
  {
    *a5 = v8;
LABEL_4:
    *(void *)a6 = off_18971B688;
    *(_WORD *)(a6 + 8) = 2;
    return result;
  }

  int v12 = (_DWORD *)*((void *)result + 29);
  uint64_t v11 = *((void *)result + 30);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  char v13 = &off_189723268;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  uint64_t v22 = 0LL;
  sub_1808EAB48(v11, a3, v12, (uint64_t)&v13);
  *(_OWORD *)(a6 + 32) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  return icu::DateTimePatternGenerator::adjustFieldTypes(v7, a2, 0LL, 0, a4, a6);
}

uint64_t icu::DateTimePatternGenerator::setDecimal(UChar **this, UChar **a2)
{
  uint64_t v2 = (icu::UnicodeString *)(this + 577);
  icu::UnicodeString::operator=(this + 577, a2);
  return icu::UnicodeString::getTerminatedBuffer(v2);
}

uint64_t icu::DateTimePatternGenerator::getDecimal(icu::DateTimePatternGenerator *this)
{
  return (uint64_t)this + 4616;
}

uint64_t icu::DateTimePatternGenerator::setDateTimeFormat(icu::DateTimePatternGenerator *this, UChar **a2)
{
  unsigned int v4 = 0;
  int v6 = 0;
  do
    uint64_t result = icu::DateTimePatternGenerator::setDateTimeFormat((uint64_t)this, v4++, a2, &v6);
  while (v4 != 4);
  return result;
}

uint64_t icu::DateTimePatternGenerator::setDateTimeFormat( uint64_t result, unsigned int a2, UChar **a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a2 < 4)
    {
      unsigned int v4 = (UChar **)(result + ((unint64_t)a2 << 6) + 4360);
      icu::UnicodeString::operator=(v4, a3);
      return icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v4);
    }

    else
    {
      *a4 = 1;
    }
  }

  return result;
}

void *icu::DateTimePatternGenerator::getDateTimeFormat(icu::DateTimePatternGenerator *this)
{
  int v2 = 0;
  return icu::DateTimePatternGenerator::getDateTimeFormat((uint64_t)this, 2u, &v2);
}

uint64_t sub_1808EDA38(uint64_t a1, uint64_t a2)
{
  int v3 = 0;
  if ((*(_WORD *)(a2 + 8) & 1) != 0) {
    __int16 v4 = 2;
  }
  else {
    __int16 v4 = *(_WORD *)(a2 + 8) & 0x1F;
  }
  *(_WORD *)(a2 + 8) = v4;
  uint64_t v5 = a1 + 112;
  do
    uint64_t result = sub_1808EE348(v5, v3++, a2);
  while (v3 != 16);
  return result;
}

uint64_t sub_1808EDA98(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 8);
  if ((v3 & 0x8000u) == 0) {
    unsigned int v4 = v3 >> 5;
  }
  else {
    unsigned int v4 = *(_DWORD *)(a2 + 12);
  }
  if (!v4) {
    return 0LL;
  }
  int v7 = -71;
  if ((v3 & 2) != 0) {
    int v8 = (unsigned __int16 *)(a2 + 10);
  }
  else {
    int v8 = *(unsigned __int16 **)(a2 + 24);
  }
  int v9 = *v8;
  if ((v9 - 65) >= 0x1A)
  {
  }

  else
  {
    int v7 = -65;
  }

  uint64_t v10 = *(void *)(a1 + 8LL * (v7 + v9) + 8);
  if (!v10) {
    return 0LL;
  }
  while (1)
  {
    unsigned int v11 = *(unsigned __int16 *)(a2 + 8);
    unsigned int v12 = *(unsigned __int16 *)(v10 + 16);
    if ((v12 & 1) == 0) {
      break;
    }
    if ((v11 & 1) != 0) {
      goto LABEL_27;
    }
LABEL_25:
    uint64_t v10 = *(void *)(v10 + 152);
    if (!v10) {
      return 0LL;
    }
  }

  int v13 = (__int16)v11;
  int32_t v14 = v11 >> 5;
  if (v13 >= 0) {
    int32_t v15 = v14;
  }
  else {
    int32_t v15 = *(_DWORD *)(a2 + 12);
  }
  if ((v12 & 0x8000u) == 0) {
    int v16 = v12 >> 5;
  }
  else {
    int v16 = *(_DWORD *)(v10 + 20);
  }
  if ((v12 & 2) != 0) {
    uint64_t v17 = v10 + 18;
  }
  else {
    uint64_t v17 = *(void *)(v10 + 32);
  }
  if (icu::UnicodeString::doCompare( a2,  0,  v15,  v17,  v16 & (v16 >> 31),  v16 & ~(v16 >> 31))) {
    goto LABEL_25;
  }
LABEL_27:
  *a3 = *(_BYTE *)(v10 + 144);
  return v10 + 80;
}

uint64_t sub_1808EDBAC(uint64_t a1, void *a2, void *a3)
{
  if (a3) {
    *a3 = 0LL;
  }
  uint64_t v3 = 0LL;
  while (1)
  {
    unsigned int v4 = (char *)a2 + v3;
    if (*((_BYTE *)a2 + v3 + 120)) {
      break;
    }
    if (++v3 == 16) {
      return 0LL;
    }
  }

  int v5 = -71;
  int v6 = v4[104];
  int v7 = (unsigned __int16)v4[104];
  if ((v6 - 65) >= 0x1A)
  {
  }

  else
  {
    int v5 = -65;
  }

  uint64_t v8 = *(void *)(a1 + 8LL * (v5 + v7) + 8);
  if (!v8) {
    return 0LL;
  }
  while (1)
  {
    int v9 = *(void **)(v8 + 72);
    if (a3) {
      break;
    }
    if (v9[13] == a2[13] && v9[14] == a2[14])
    {
      uint64_t v14 = v9[15];
      uint64_t v13 = v9[16];
      if (v14 == a2[15] && v13 == a2[16]) {
        return v8 + 80;
      }
    }

UChar **sub_1808EDC94(UChar **result, unint64_t a2, uint64_t a3, UChar **a4, char a5, int *a6)
{
  unsigned int v7 = *(unsigned __int16 *)(a2 + 8);
  if ((v7 & 0x8000u) == 0) {
    unsigned int v8 = v7 >> 5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a2 + 12);
  }
  if (!v8) {
    goto LABEL_23;
  }
  uint64_t v13 = result;
  if ((v7 & 2) != 0) {
    uint64_t v14 = (unsigned __int16 *)(a2 + 10);
  }
  else {
    uint64_t v14 = *(unsigned __int16 **)(a2 + 24);
  }
  uint64_t v15 = *v14;
  *a6 = 0;
  if ((v15 - 65) < 0x1A)
  {
    int v16 = -65;
    goto LABEL_12;
  }

  if ((v15 - 97) >= 0x1A)
  {
LABEL_23:
    int v32 = 65567;
    goto LABEL_24;
  }

  int v16 = -71;
LABEL_12:
  uint64_t v17 = (uint64_t *)&result[(v16 + v15)];
  uint64_t v18 = v17[1];
  if (v18)
  {
    uint64_t result = (UChar **)sub_1808EEE64((uint64_t)result, a2, a3, v17[1]);
    if (result)
    {
      if (*((_BYTE *)v13 + 424))
      {
        __int128 v21 = result;
        uint64_t result = (UChar **)icu::UnicodeString::operator=(result + 10, a4);
        *((_BYTE *)v21 + 144) = a5;
      }

      return result;
    }

    do
    {
      uint64_t v22 = v18;
      uint64_t v18 = *(void *)(v18 + 152);
    }

    while (v18);
    uint64_t result = (UChar **)icu::UMemory::operator new(v20, (icu::UMemory *)0xA0, v19);
    if (result)
    {
      uint64_t v23 = result;
      *uint64_t result = (UChar *)off_189723288;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)(result + 1), (UChar **)a2);
      v23[9] = 0LL;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v23 + 10), a4);
      v23[19] = 0LL;
      unint64_t v25 = (uint64_t *)*a6;
      int v26 = icu::UMemory::operator new(v25, (icu::UMemory *)0x90, v24);
      if (v26)
      {
        *int v26 = (uint64_t)&off_189723268;
        *(_OWORD *)(v26 + 9) = 0u;
        *(_OWORD *)(v26 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
        *(_OWORD *)(v26 + 13) = 0u;
        *(_OWORD *)(v26 + 15) = 0u;
        __int128 v27 = *(_OWORD *)(a3 + 8);
        __int128 v28 = *(_OWORD *)(a3 + 24);
        __int128 v29 = *(_OWORD *)(a3 + 40);
        *(_OWORD *)(v26 + 7) = *(_OWORD *)(a3 + 56);
        *(_OWORD *)(v26 + 5) = v29;
        *(_OWORD *)(v26 + 3) = v28;
        *(_OWORD *)(v26 + sub_1808F7164((uint64_t)v14, 1) = v27;
        *(_OWORD *)(v26 + 9) = *(_OWORD *)(a3 + 72);
        *(_OWORD *)(v26 + 1sub_1808F7164((uint64_t)v14, 1) = *(_OWORD *)(a3 + 88);
        *(_OWORD *)(v26 + 13) = *(_OWORD *)(a3 + 104);
        *(_OWORD *)(v26 + 15) = *(_OWORD *)(a3 + 120);
        *((_BYTE *)v26 + 136) = *(_BYTE *)(a3 + 136);
      }

      sub_1807C9194((uint64_t)(v23 + 9), (uint64_t)v26, a6);
      if (*a6 > 0)
      {
LABEL_22:
        uint64_t v30 = (uint64_t (*)(UChar **))*((void *)*v23 + 1);
        int v31 = v23;
        return (UChar **)v30(v31);
      }

      *((_BYTE *)v23 + 144) = a5;
      uint64_t result = *(UChar ***)(v22 + 152);
      if (result) {
        uint64_t result = (UChar **)(*((uint64_t (**)(UChar **))*result + 1))(result);
      }
      *(void *)(v22 + 152) = v23;
      return result;
    }

    goto LABEL_33;
  }

  uint64_t result = (UChar **)icu::UMemory::operator new(v17, (icu::UMemory *)0xA0, a2);
  if (!result)
  {
LABEL_33:
    if (*a6 > 0) {
      return result;
    }
    int v32 = 7;
LABEL_24:
    *a6 = v32;
    return result;
  }

  __int16 v33 = result;
  *uint64_t result = (UChar *)off_189723288;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(result + 1), (UChar **)a2);
  v33[9] = 0LL;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v33 + 10), a4);
  v33[19] = 0LL;
  __int128 v35 = (uint64_t *)*a6;
  __int128 v36 = icu::UMemory::operator new(v35, (icu::UMemory *)0x90, v34);
  if (v36)
  {
    uint64_t *v36 = (uint64_t)&off_189723268;
    *(_OWORD *)(v36 + 9) = 0u;
    *(_OWORD *)(v36 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_OWORD *)(v36 + 13) = 0u;
    *(_OWORD *)(v36 + 15) = 0u;
    __int128 v37 = *(_OWORD *)(a3 + 8);
    __int128 v38 = *(_OWORD *)(a3 + 24);
    __int128 v39 = *(_OWORD *)(a3 + 40);
    *(_OWORD *)(v36 + 7) = *(_OWORD *)(a3 + 56);
    *(_OWORD *)(v36 + 5) = v39;
    *(_OWORD *)(v36 + 3) = v38;
    *(_OWORD *)(v36 + sub_1808F7164((uint64_t)v14, 1) = v37;
    *(_OWORD *)(v36 + 9) = *(_OWORD *)(a3 + 72);
    *(_OWORD *)(v36 + 1sub_1808F7164((uint64_t)v14, 1) = *(_OWORD *)(a3 + 88);
    *(_OWORD *)(v36 + 13) = *(_OWORD *)(a3 + 104);
    *(_OWORD *)(v36 + 15) = *(_OWORD *)(a3 + 120);
    *((_BYTE *)v36 + 136) = *(_BYTE *)(a3 + 136);
  }

  uint64_t result = (UChar **)sub_1807C9194((uint64_t)(v33 + 9), (uint64_t)v36, a6);
  if (*a6 > 0)
  {
LABEL_31:
    uint64_t v30 = (uint64_t (*)(UChar **))*((void *)*v33 + 1);
    int v31 = v33;
    return (UChar **)v30(v31);
  }

  *((_BYTE *)v33 + 144) = a5;
  else {
    v13[(v15 - 71) + 1] = (UChar *)v33;
  }
  return result;
}

uint64_t icu::DateTimePatternGenerator::getAppendFormatNumber( icu::DateTimePatternGenerator *this, const char *__s2)
{
  for (uint64_t i = 0LL; i != 16; ++i)
  {
    if (!strcmp(off_1897230B8[i], __s2)) {
      break;
    }
  }

  return i;
}

uint64_t icu::DateTimePatternGenerator::getFieldAndWidthIndices(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  strncpy(__dst, a2, 0x18uLL);
  __dst[24] = 0;
  *a3 = 0;
  unsigned int v4 = strchr(__dst, 45);
  if (v4)
  {
    int v5 = v4;
    unint64_t v6 = 2LL;
    while (strcmp(*((const char **)&off_189723138 + v6), v5))
    {
      if (v6-- <= 1) {
        goto LABEL_7;
      }
    }

    *a3 = v6;
LABEL_7:
    *int v5 = 0;
  }

  for (uint64_t i = 0LL; i != 16; ++i)
  {
    if (!strcmp(off_189723150[i], __dst)) {
      break;
    }
  }

  return i;
}

uint64_t sub_1808EE100(uint64_t a1)
{
  uint64_t result = 0LL;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4 <= 51)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v7 = v5 + 1;
      while (1)
      {
        if (v6)
        {
          if (*(void *)(v6 + 152)) {
            return 1LL;
          }
        }

        else if (*(void *)(v3 + 8 * v7))
        {
          return 1LL;
        }

        uint64_t v6 = 0LL;
        if ((_DWORD)v7++ == 52) {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1808EE164(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= 52)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2)
    {
LABEL_15:
      uint64_t v5 = *(void *)(a1 + 24);
      uint64_t v6 = *(void *)(v2 + 72);
      __int128 v7 = *(_OWORD *)(v6 + 8);
      __int128 v8 = *(_OWORD *)(v6 + 24);
      __int128 v9 = *(_OWORD *)(v6 + 56);
      *(_OWORD *)(v5 + 48) = *(_OWORD *)(v6 + 40);
      *(_OWORD *)(v5 + 64) = v9;
      *(_OWORD *)(v5 + 16) = v7;
      *(_OWORD *)(v5 + 32) = v8;
      *(_OWORD *)(v5 + 80) = *(_OWORD *)(v6 + 72);
      *(_OWORD *)(v5 + 96) = *(_OWORD *)(v6 + 88);
      *(_OWORD *)(v5 + 112) = *(_OWORD *)(v6 + 104);
      *(_OWORD *)(v5 + 128) = *(_OWORD *)(v6 + 120);
      *(_BYTE *)(v5 + 144) = *(_BYTE *)(v6 + 136);
      return *(void *)(a1 + 24);
    }
  }

  else
  {
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = v2;
    do
    {
      if (v3)
      {
        uint64_t v2 = *(void *)(v3 + 152);
        if (v2) {
          goto LABEL_14;
        }
        *(_DWORD *)(a1 + 8) = ++v1;
        *(void *)(a1 + 16) = 0LL;
      }

      else
      {
        if (*(void *)(*(void *)(a1 + 32) + 8LL * v1 + 8))
        {
          uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL * v1 + 8);
LABEL_14:
          *(void *)(a1 + 16) = v2;
          goto LABEL_15;
        }

        *(_DWORD *)(a1 + 8) = ++v1;
      }

      uint64_t v3 = 0LL;
    }

    while (v1 < 52);
    if (v2) {
      goto LABEL_15;
    }
  }

  int v4 = *(_OWORD **)(a1 + 24);
  v4[7] = 0u;
  v4[8] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  return *(void *)(a1 + 24);
}

BOOL sub_1808EE23C(void *a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a1[10] != a2[10] || a1[11] != a2[11]) {
    return 0LL;
  }
  return a1[12] == a2[12] && a1[13] == a2[13];
}

uint64_t sub_1808EE274(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = 0LL;
  uint64_t result = 0LL;
  int v7 = 0;
  int v8 = 0;
  *(void *)(a4 + 8) = 0LL;
  uint64_t v9 = a1 + 16;
  uint64_t v10 = a2 + 16;
  do
  {
    int v11 = 1 << v5;
    if (((1 << v5) & a3) == 0)
    {
      if (!*(_DWORD *)(v10 + 4 * v5)) {
        goto LABEL_12;
      }
LABEL_11:
      uint64_t result = (result + 0x10000);
      v8 |= v11;
      *(_DWORD *)(a4 + 12) = v8;
      goto LABEL_12;
    }

    int v12 = *(_DWORD *)(v9 + 4 * v5);
    int v13 = *(_DWORD *)(v10 + 4 * v5);
    if (v12 == v13) {
      goto LABEL_12;
    }
    if (!v12) {
      goto LABEL_11;
    }
    if (v13)
    {
      if (v12 - v13 >= 0) {
        int v14 = v12 - v13;
      }
      else {
        int v14 = v13 - v12;
      }
      uint64_t result = (v14 + result);
    }

    else
    {
      uint64_t result = (result + 4096);
      v7 |= v11;
      *(_DWORD *)(a4 + 8) = v7;
    }

void *sub_1808EE304(void *a1)
{
  *a1 = &off_189723248;
  uint64_t v2 = a1[3];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

uint64_t sub_1808EE348(uint64_t a1, int a2, uint64_t a3)
{
  int v4 = (char *)(a1 + a2);
  int v5 = v4[16];
  if (v5 >= 1)
  {
    __int16 v6 = *v4;
    do
    {
      __int16 v8 = v6;
      icu::UnicodeString::doAppend(a3, (uint64_t)&v8, 0, 1LL);
      --v5;
    }

    while (v5);
  }

  return a3;
}

uint64_t icu::DateTimePatternGenerator::defaultHourPeriodCharForHourCycle(uint64_t a1, int a2)
{
  uint64_t result = *(unsigned __int16 *)(a1 + 4760);
  if ((a2 & 0x40000000) == 0)
  {
    if ((a2 & 0x20000000) == 0) {
      return result;
    }
LABEL_7:
    if ((_DWORD)result == 75 || (_DWORD)result == 104) {
      return result;
    }
    goto LABEL_9;
  }

  if ((_DWORD)result == 72 || (_DWORD)result == 107) {
    return result;
  }
  if ((a2 & 0x20000000) != 0) {
    goto LABEL_7;
  }
LABEL_9:
  uint64_t v4 = 0LL;
  uint64_t v5 = a1 + 4764;
  while (2)
  {
    switch(*(_DWORD *)(v5 + v4))
    {
      case 0xFFFFFFFF:
        return result;
      case 0:
      case 4:
      case 5:
        if ((a2 & 0x20000000) == 0) {
          goto LABEL_18;
        }
        uint64_t result = 104LL;
        break;
      case 1:
      case 8:
      case 9:
        if ((a2 & 0x40000000) == 0) {
          goto LABEL_18;
        }
        uint64_t result = 72LL;
        break;
      case 2:
      case 6:
      case 7:
        if ((a2 & 0x20000000) == 0) {
          goto LABEL_18;
        }
        uint64_t result = 75LL;
        break;
      case 3:
        if ((a2 & 0x40000000) == 0) {
          goto LABEL_18;
        }
        uint64_t result = 107LL;
        break;
      default:
LABEL_18:
        v4 += 4LL;
        if (v4 != 28) {
          continue;
        }
        break;
    }

    return result;
  }

uint64_t icu::DateTimePatternGenerator::getTopBitNumber(icu::DateTimePatternGenerator *this, int a2)
{
  if (!a2) {
    return 0LL;
  }
  unsigned int v2 = -1;
  do
  {
    ++v2;
    BOOL v3 = a2 > 1;
    a2 >>= 1;
  }

  while (v3);
  if (v2 >= 0xF) {
    return 15LL;
  }
  else {
    return v2;
  }
}

uint64_t icu::DateTimePatternGenerator::setAvailableFormat( icu::DateTimePatternGenerator *this, UChar **a2, UErrorCode *a3)
{
  uint64_t v5 = (uint64_t *)*((void *)this + 586);
  uint64_t v6 = *v5;
  int v7 = (icu::UnicodeString *)icu::UMemory::operator new(v5, (icu::UMemory *)0x40, (unint64_t)a2);
  uint64_t v8 = (uint64_t)v7;
  if (v7) {
    icu::UnicodeString::UnicodeString(v7, a2);
  }
  return uhash_puti(v6, v8, 1u, (int *)a3);
}

BOOL icu::DateTimePatternGenerator::isAvailableFormatSet( icu::DateTimePatternGenerator *this, const icu::UnicodeString *a2)
{
  return uhash_geti(**((void **)this + 586), (uint64_t)a2) == 1;
}

uint64_t icu::DateTimePatternGenerator::getSkeletons(icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  uint64_t v5 = (uint64_t *)*((unsigned int *)this + 1198);
  if ((int)v5 >= 1)
  {
    uint64_t result = 0LL;
LABEL_5:
    *a2 = (int)v5;
    return result;
  }

  uint64_t v6 = icu::UMemory::operator new(v5, (icu::UMemory *)0x80, (unint64_t)a2);
  if (!v6)
  {
    if (*(int *)a2 <= 0)
    {
      uint64_t result = 0LL;
      LODWORD(v5) = 7;
      goto LABEL_5;
    }

    return 0LL;
  }

  uint64_t result = sub_1808EF334((uint64_t)v6, *((void *)this + 32), 1, a2);
  if (*(int *)a2 >= 1)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8LL))(result);
    return 0LL;
  }

  return result;
}

uint64_t icu::DateTimePatternGenerator::getPatternForSkeleton( icu::DateTimePatternGenerator *this, const icu::UnicodeString *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  unsigned int v4 = *((unsigned __int16 *)a2 + 4);
  if (*((__int16 *)a2 + 4) < 0)
  {
    if (!*((_DWORD *)a2 + 3)) {
      return (uint64_t)this + 4696;
    }
  }

  else if (v4 <= 0x1F)
  {
    return (uint64_t)this + 4696;
  }

  int v5 = -71;
  if ((v4 & 2) != 0) {
    uint64_t v6 = (unsigned __int16 *)((char *)a2 + 10);
  }
  else {
    uint64_t v6 = (unsigned __int16 *)*((void *)a2 + 3);
  }
  int v7 = *v6;
  if ((v7 - 65) >= 0x1A)
  {
  }

  else
  {
    int v5 = -65;
  }

  for (uint64_t i = *(void *)(*((void *)this + 32) + 8LL * (v5 + v7) + 8); i; uint64_t i = *(void *)(i + 152))
  {
    sub_1808EAE54(*(void *)(i + 72), (uint64_t)v16);
    if ((v17 & 1) != 0)
    {
      __int16 v14 = *((_WORD *)a2 + 4);
      icu::UnicodeString::~UnicodeString((void *)v17, (icu::UnicodeString *)v16);
      if ((v14 & 1) != 0) {
        return i + 80;
      }
    }

    else
    {
      if ((v17 & 0x8000u) == 0) {
        int v9 = v17 >> 5;
      }
      else {
        int v9 = v18;
      }
      unsigned int v10 = *((unsigned __int16 *)a2 + 4);
      if ((v10 & 0x8000u) == 0) {
        int v11 = (void *)(v10 >> 5);
      }
      else {
        int v11 = (void *)*((unsigned int *)a2 + 3);
      }
      if ((v10 & 1) != 0 || v9 != (_DWORD)v11)
      {
        icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v16);
      }

      else
      {
        BOOL v12 = icu::UnicodeString::doEquals((icu::UnicodeString *)v16, a2, v9);
        icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v16);
        if (v12) {
          return i + 80;
        }
      }
    }
  }

  return (uint64_t)this + 4696;
}

uint64_t icu::DateTimePatternGenerator::getBaseSkeletons(icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  int v5 = (uint64_t *)*((unsigned int *)this + 1198);
  if ((int)v5 >= 1)
  {
    uint64_t result = 0LL;
LABEL_5:
    *a2 = (int)v5;
    return result;
  }

  uint64_t v6 = icu::UMemory::operator new(v5, (icu::UMemory *)0x80, (unint64_t)a2);
  if (!v6)
  {
    if (*(int *)a2 <= 0)
    {
      uint64_t result = 0LL;
      LODWORD(v5) = 7;
      goto LABEL_5;
    }

    return 0LL;
  }

  uint64_t result = sub_1808EF334((uint64_t)v6, *((void *)this + 32), 0, a2);
  if (*(int *)a2 >= 1)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8LL))(result);
    return 0LL;
  }

  return result;
}

uint64_t *icu::DateTimePatternGenerator::getRedundants(icu::DateTimePatternGenerator *this, UErrorCode *a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  int v5 = (uint64_t *)*((unsigned int *)this + 1198);
  if ((int)v5 >= 1)
  {
    unsigned int v2 = 0LL;
    goto LABEL_5;
  }

  uint64_t v6 = icu::UMemory::operator new(v5, (icu::UMemory *)0x80, (unint64_t)a2);
  if (!v6)
  {
    unsigned int v2 = 0LL;
    LODWORD(v5) = 7;
LABEL_5:
    *a2 = (int)v5;
    return v2;
  }

  int v7 = v6;
  uint64_t v8 = icu::StringEnumeration::StringEnumeration((uint64_t)v6);
  *(void *)uint64_t v8 = &off_189723310;
  *(_DWORD *)(v8 + 116) = 0;
  *(void *)(v8 + 120) = 0LL;
  if (*(int *)a2 > 0)
  {
    unsigned int v2 = 0LL;
    int v9 = v7;
    goto LABEL_40;
  }

  uint64_t v36 = 0LL;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  sub_1808EF1DC((uint64_t)&v34, (int *)a2);
  if (*(int *)a2 > 0)
  {
LABEL_12:
    unsigned int v2 = 0LL;
    goto LABEL_13;
  }

  uint64_t v36 = *((void *)this + 32);
  if (!sub_1808EE100((uint64_t)&v34))
  {
LABEL_36:
    int v9 = 0LL;
    unsigned int v2 = v7;
    goto LABEL_37;
  }

  while (1)
  {
    uint64_t v48 = 0LL;
    uint64_t v10 = sub_1808EE164((uint64_t)&v34);
    __int128 v11 = *(_OWORD *)(v10 + 32);
    __int128 v40 = *(_OWORD *)(v10 + 16);
    __int128 v41 = v11;
    __int128 v12 = *(_OWORD *)(v10 + 64);
    __int128 v42 = *(_OWORD *)(v10 + 48);
    __int128 v43 = v12;
    __int128 v13 = *(_OWORD *)(v10 + 96);
    __int128 v44 = *(_OWORD *)(v10 + 80);
    __int128 v45 = v13;
    __int128 v14 = *(_OWORD *)(v10 + 128);
    __int128 v46 = *(_OWORD *)(v10 + 112);
    v39[0] = &off_189723200;
    v39[1] = &off_189723268;
    __int128 v47 = v14;
    char v15 = *(_BYTE *)(v10 + 144);
    LOBYTE(v48) = v15;
    uint64_t v16 = sub_1808EDBAC(*((void *)this + 32), *(void **)(v35 + 72), 0LL);
    if (!icu::DateTimePatternGenerator::isCanonicalItem( (icu::DateTimePatternGenerator *)v16,  (const icu::UnicodeString *)v16)) {
      break;
    }
LABEL_35:
  }

  uint64_t v18 = *((void *)this + 585);
  if (v18)
  {
    __int128 v19 = *(_OWORD *)(v10 + 16);
    __int128 v20 = *(_OWORD *)(v10 + 32);
    __int128 v21 = *(_OWORD *)(v10 + 64);
    *(_OWORD *)(v18 + 48) = *(_OWORD *)(v10 + 48);
    *(_OWORD *)(v18 + 64) = v21;
    *(_OWORD *)(v18 + 16) = v19;
    *(_OWORD *)(v18 + 32) = v20;
    __int128 v22 = v45;
    *(_OWORD *)(v18 + 80) = v44;
    *(_OWORD *)(v18 + 96) = v22;
    __int128 v23 = v47;
    *(_OWORD *)(v18 + 112) = v46;
    *(_OWORD *)(v18 + 128) = v23;
    *(_BYTE *)(v18 + 144) = v15;
    goto LABEL_20;
  }

  unint64_t v24 = icu::UMemory::operator new(0LL, (icu::UMemory *)0x98, v17);
  if (v24)
  {
    uint64_t *v24 = (uint64_t)&off_189723200;
    v24[1] = (uint64_t)&off_189723268;
    __int128 v25 = v41;
    *((_OWORD *)v24 + sub_1808F7164((uint64_t)v14, 1) = v40;
    *((_OWORD *)v24 + 2) = v25;
    __int128 v26 = v43;
    *((_OWORD *)v24 + 3) = v42;
    *((_OWORD *)v24 + 4) = v26;
    __int128 v27 = v45;
    *((_OWORD *)v24 + 5) = v44;
    *((_OWORD *)v24 + 6) = v27;
    __int128 v28 = v47;
    *((_OWORD *)v24 + 7) = v46;
    *((_OWORD *)v24 + 8) = v28;
    *((_BYTE *)v24 + 144) = v15;
    *((void *)this + 585) = v24;
LABEL_20:
    memset(v38, 0, sizeof(v38));
    sub_1808EEBCC((uint64_t)v39, (icu::UnicodeString *)v37);
    icu::DateTimePatternGenerator::getBestPattern(this, (uint64_t)v37, 0, (int *)a2, (icu::UnicodeString *)v38);
    icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)v37);
    uint64_t v30 = (void *)*(unsigned int *)a2;
    if ((BYTE8(v38[0]) & 1) != 0)
    {
      uint64_t v30 = (void *)*(unsigned __int16 *)(v16 + 8);
      if ((v30 & 1) == 0)
      {
LABEL_34:
        icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)v38);
        goto LABEL_35;
      }
    }

    else
    {
      if ((SWORD4(v38[0]) & 0x8000u) == 0) {
        int v31 = WORD4(v38[0]) >> 5;
      }
      else {
        int v31 = HIDWORD(v38[0]);
      }
      unsigned int v32 = *(unsigned __int16 *)(v16 + 8);
      if ((v32 & 0x8000u) == 0) {
        uint64_t v30 = (void *)(v32 >> 5);
      }
      else {
        uint64_t v30 = (void *)*(unsigned int *)(v16 + 12);
      }
      if ((v32 & 1) != 0
        || v31 != (_DWORD)v30
        || !icu::UnicodeString::doEquals((icu::UnicodeString *)v38, (const icu::UnicodeString *)v16, v31))
      {
        goto LABEL_34;
      }
    }

    sub_1808EEC84(v7, (UChar **)v16, a2);
    uint64_t v30 = (void *)*(unsigned int *)a2;
    if ((int)v30 >= 1)
    {
LABEL_42:
      icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)v38);
      goto LABEL_12;
    }

    goto LABEL_34;
  }

  unsigned int v2 = 0LL;
  *((void *)this + 585) = 0LL;
  *a2 = U_MEMORY_ALLOCATION_ERROR;
LABEL_13:
  int v9 = v7;
LABEL_37:
  *(void *)&__int128 v34 = &off_189723248;
  if (*((void *)&v35 + 1)) {
    (*(void (**)(void))(**((void **)&v35 + 1) + 8LL))(*((void *)&v35 + 1));
  }
  if (v9) {
LABEL_40:
  }
    (*(void (**)(uint64_t *))(*v9 + 8))(v9);
  return v2;
}

BOOL icu::DateTimePatternGenerator::isCanonicalItem( icu::DateTimePatternGenerator *this, const icu::UnicodeString *a2)
{
  unsigned int v2 = *((unsigned __int16 *)a2 + 4);
  if ((v2 & 0x8000u) == 0) {
    unsigned int v3 = v2 >> 5;
  }
  else {
    unsigned int v3 = *((_DWORD *)a2 + 3);
  }
  if (v3 != 1) {
    return 0LL;
  }
  if ((v2 & 2) != 0) {
    unsigned int v4 = (unsigned __int16 *)((char *)a2 + 10);
  }
  else {
    unsigned int v4 = (unsigned __int16 *)*((void *)a2 + 3);
  }
  int v5 = *v4;
  if (v5 == 71) {
    return 1LL;
  }
  unint64_t v7 = 0LL;
  do
  {
    unint64_t v8 = v7;
    if (v7 == 15) {
      break;
    }
    int v9 = (unsigned __int16)aGyqmwwedfdahms[++v7];
  }

  while (v5 != v9);
  return v8 < 0xF;
}

void *sub_1808EEBCC@<X0>(uint64_t a1@<X0>, icu::UnicodeString *a2@<X8>)
{
  int v3 = 0;
  uint64_t v12 = *MEMORY[0x1895F89C0];
  __int128 v8 = 0u;
  unint64_t v7 = (UChar *)off_18971B688;
  LOWORD(v8) = 2;
  uint64_t v11 = 0LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  uint64_t v4 = a1 + 80;
  do
    sub_1808EE348(v4, v3++, (uint64_t)&v7);
  while (v3 != 16);
  icu::UnicodeString::UnicodeString(a2, &v7);
  return icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)&v7);
}

uint64_t *sub_1808EEC84(uint64_t *result, UChar **a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v6 = (icu::UVector **)(result + 15);
    int v5 = (uint64_t *)result[15];
    if (v5) {
      goto LABEL_4;
    }
    __int128 v8 = (icu::UVector *)icu::UMemory::operator new(0LL, (icu::UMemory *)0x28, (unint64_t)a2);
    uint64_t v9 = (uint64_t)v8;
    if (v8) {
      icu::UVector::UVector(v8, a3);
    }
    uint64_t result = (uint64_t *)sub_1807C9194((uint64_t)v6, v9, (int *)a3);
    int v5 = (uint64_t *)*(unsigned int *)a3;
    if ((int)v5 <= 0)
    {
LABEL_4:
      uint64_t result = icu::UMemory::operator new(v5, (icu::UMemory *)0x40, (unint64_t)a2);
      if (result)
      {
        unint64_t v7 = result;
        icu::UnicodeString::UnicodeString((icu::UnicodeString *)result, a2);
        uint64_t result = (uint64_t *)icu::UVector::addElement(*v6, v7, a3);
        if (*(int *)a3 >= 1)
        {
          if (*v6) {
            (*(void (**)(icu::UVector *))(*(void *)*v6 + 8LL))(*v6);
          }
          *uint64_t v6 = 0LL;
          return (uint64_t *)(*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7);
        }
      }

      else if (*(int *)a3 <= 0)
      {
        *a3 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }

  return result;
}

icu::DateTimePatternGenerator *icu::DateTimePatternGenerator::clone@<X0>( icu::DateTimePatternGenerator *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::DateTimePatternGenerator *)icu::UMemory::operator new(a3, (icu::UMemory *)0x12C0, a2);
  if (result) {
    return (icu::DateTimePatternGenerator *)icu::DateTimePatternGenerator::DateTimePatternGenerator(result, this);
  }
  return result;
}

void *sub_1808EEDBC(void *a1)
{
  *a1 = &off_1897231E0;
  for (uint64_t i = 1LL; i != 53; ++i)
  {
    uint64_t v3 = a1[i];
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
      a1[i] = 0LL;
    }
  }

  return a1;
}

void sub_1808EEE10(char *a1)
{
  *(void *)a1 = &off_1897231E0;
  for (uint64_t i = 8LL; i != 424; i += 8LL)
  {
    uint64_t v3 = *(void *)&a1[i];
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
      *(void *)&a1[i] = 0LL;
    }
  }

  icu::UMemory::operator delete(a1);
}

uint64_t sub_1808EEE64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v6 = a3 + 8;
    do
    {
      unsigned int v7 = *(unsigned __int16 *)(a2 + 8);
      unsigned int v8 = *(unsigned __int16 *)(v4 + 16);
      if ((v8 & 1) != 0)
      {
        if ((v7 & 1) != 0) {
          goto LABEL_18;
        }
      }

      else
      {
        int v9 = (__int16)v7;
        int32_t v10 = v7 >> 5;
        if (v9 >= 0) {
          int32_t v11 = v10;
        }
        else {
          int32_t v11 = *(_DWORD *)(a2 + 12);
        }
        if ((v8 & 0x8000u) == 0) {
          int v12 = v8 >> 5;
        }
        else {
          int v12 = *(_DWORD *)(v4 + 20);
        }
        if ((v8 & 2) != 0) {
          uint64_t v13 = v4 + 18;
        }
        else {
          uint64_t v13 = *(void *)(v4 + 32);
        }
        if (!icu::UnicodeString::doCompare( a2,  0,  v11,  v13,  v12 & (v12 >> 31),  v12 & ~(v12 >> 31)))
        {
LABEL_18:
          uint64_t v14 = 0LL;
          while (*(_DWORD *)(*(void *)(v4 + 72) + 8LL + v14) == *(_DWORD *)(v6 + v14))
          {
            v14 += 4LL;
            if (v14 == 64) {
              return v4;
            }
          }
        }
      }

      uint64_t v4 = *(void *)(v4 + 152);
    }

    while (v4);
  }

  return v4;
}

BOOL sub_1808EEF38(void *a1, void *a2)
{
  BOOL v2 = a1[9] == a2[9] && a1[10] == a2[10];
  if (v2
    && (a1[11] == a2[11] ? (BOOL v3 = a1[12] == a2[12]) : (BOOL v3 = 0),
        v3
     && (a1[13] == a2[13] ? (BOOL v4 = a1[14] == a2[14]) : (BOOL v4 = 0),
         v4 && (a1[15] == a2[15] ? (BOOL v5 = a1[16] == a2[16]) : (BOOL v5 = 0), v5))))
  {
    return memcmp(a1 + 1, a2 + 1, 0x40uLL) == 0;
  }

  else
  {
    return 0LL;
  }

void sub_1808EEFBC(void *a1)
{
  BOOL v2 = off_189723220;
  *a1 = off_189723220;
  for (uint64_t i = 393LL; i != -7; i -= 8LL)
    icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)&a1[i]);
  icu::UMemory::operator delete(a1);
}

uint64_t sub_1808EF000(uint64_t a1, uint64_t a2, signed int a3, int *a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 8);
  if ((v4 & 0x8000u) == 0) {
    unsigned int v5 = v4 >> 5;
  }
  else {
    unsigned int v5 = *(_DWORD *)(a2 + 12);
  }
  uint64_t v6 = 0LL;
  uint64_t v7 = a2 + 10;
  if ((v4 & 2) == 0) {
    uint64_t v7 = *(void *)(a2 + 24);
  }
  uint64_t v8 = v7 + 2LL * a3;
  while (v5 > a3 + (int)v6 && (*(_WORD *)(v8 + 2 * v6) & 0xFFDFu) - 65 <= 0x19)
  {
    else {
      int v9 = *(unsigned __int16 *)(v8 + 2 * v6 + 2);
    }
    if (v5 <= a3) {
      int v10 = 0xFFFF;
    }
    else {
      int v10 = *(unsigned __int16 *)(v7 + 2LL * a3);
    }
    int v11 = v6 + 1;
    if (v9 == v10)
    {
      uint64_t v12 = a3 + v6++;
    }

    goto LABEL_21;
  }

  int v11 = 1;
LABEL_21:
  *a4 = v11;
  return 1LL;
}

uint64_t sub_1808EF0D0(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    if (v2 >= 0x20)
    {
      int v3 = v2 >> 5;
      goto LABEL_5;
    }

    return 0xFFFFFFFFLL;
  }

  int v3 = *(_DWORD *)(a1 + 12);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
LABEL_5:
  unsigned int v4 = *(unsigned __int16 **)(a1 + 24);
  if ((v2 & 2) != 0) {
    unsigned int v4 = (unsigned __int16 *)(a1 + 10);
  }
  int v5 = *v4;
  if (v3 > 1)
  {
    int v6 = (__int16)v2;
    LODWORD(v7) = v2 >> 5;
    if (v6 >= 0) {
      unint64_t v7 = v7;
    }
    else {
      unint64_t v7 = *(unsigned int *)(a1 + 12);
    }
    unint64_t v8 = 1LL;
    do
    {
      int v9 = v8 >= v7 ? 0xFFFF : v4[v8];
      if (v5 != v9) {
        return 0xFFFFFFFFLL;
      }
    }

    while (v3 != ++v8);
  }

  uint64_t v10 = 0LL;
  unsigned int v11 = -1;
  int v12 = 71;
  while (v12)
  {
    uint64_t v13 = (char *)&aG_1[8 * (int)v10 + 8];
    uint64_t result = v10;
    while (v12 != v5)
    {
      int v15 = *(unsigned __int16 *)v13;
      v13 += 16;
      int v12 = v15;
      uint64_t result = (result + 1);
      if (!v15) {
        goto LABEL_27;
      }
    }

    uint64_t v10 = (result + 1);
    if (v5 == aG_1[8 * (int)v10])
    {
      int v12 = *v4;
      unsigned int v11 = result;
    }

    return result;
  }

uint64_t sub_1808EF1DC(uint64_t a1, int *a2)
{
  *(void *)a1 = &off_189723248;
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = 0LL;
  uint64_t v3 = a1 + 24;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  unsigned int v4 = (uint64_t *)*a2;
  if ((int)v4 <= 0)
  {
    int v6 = icu::UMemory::operator new(v4, (icu::UMemory *)0x98, (unint64_t)a2);
    if (v6)
    {
      *int v6 = (uint64_t)&off_189723200;
      v6[1] = (uint64_t)&off_189723268;
      *((_OWORD *)v6 + 5) = 0u;
      *((_OWORD *)v6 + 6) = 0u;
      *((_OWORD *)v6 + 7) = 0u;
      *((_OWORD *)v6 + 8) = 0u;
      *((_BYTE *)v6 + 144) = 0;
    }

    sub_1807C9194(v3, (uint64_t)v6, a2);
  }

  return a1;
}

void sub_1808EF274(void *a1)
{
  *a1 = &off_189723248;
  uint64_t v2 = a1[3];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UMemory::operator delete(a1);
}

void *sub_1808EF2B8(void *a1)
{
  *a1 = off_189723288;
  uint64_t v2 = a1[19];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 10));
  uint64_t v3 = a1[9];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 1));
  return a1;
}

void sub_1808EF320(void *a1)
{
  int v1 = sub_1808EF2B8(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_1808EF334(uint64_t a1, uint64_t a2, int a3, UErrorCode *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v8 = icu::StringEnumeration::StringEnumeration(a1);
  *(void *)uint64_t v8 = &off_1897232A8;
  *(void *)(v8 + 120) = 0LL;
  int v9 = (icu::UVector **)(v8 + 120);
  __int128 v24 = 0u;
  uint64_t v27 = 0LL;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v23 = (UChar *)off_18971B688;
  LOWORD(v24) = 2;
  *(_DWORD *)(v8 + 116) = 0;
  unsigned int v11 = (icu::UVector *)icu::UMemory::operator new((uint64_t *)2, (icu::UMemory *)0x28, v10);
  uint64_t v12 = (uint64_t)v11;
  if (v11) {
    icu::UVector::UVector(v11, a4);
  }
  uint64_t v13 = (void *)sub_1807C9194((uint64_t)v9, v12, (int *)a4);
  unint64_t v14 = *(unsigned int *)a4;
  uint64_t v16 = 0LL;
  while (1)
  {
    unint64_t v14 = a2 + 8 * v16;
    uint64_t v17 = *(void *)(v14 + 8);
    if (v17) {
      break;
    }
LABEL_20:
    if (++v16 == 52) {
      goto LABEL_4;
    }
  }

  while (1)
  {
    switch(a3)
    {
      case 2:
        uint64_t v18 = (UChar **)(v17 + 80);
        goto LABEL_12;
      case 1:
        sub_1808EAE54(*(void *)(v17 + 72), (uint64_t)v22);
        icu::UnicodeString::operator=((icu::UnicodeString *)&v23, (icu::UnicodeString *)v22);
        uint64_t v13 = icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v22);
        break;
      case 0:
        uint64_t v18 = (UChar **)(v17 + 8);
LABEL_12:
        uint64_t v13 = icu::UnicodeString::operator=(&v23, v18);
        break;
    }

    LODWORD(v13) = sub_1808EF530((uint64_t)v13, (uint64_t)&v23);
    if (!(_DWORD)v13)
    {
      __int128 v21 = icu::UnicodeString::clone(&v23, v20, (uint64_t *)v14);
      unint64_t v14 = *(unsigned int *)a4;
      if (!v21 && (int)v14 <= 0)
      {
        unint64_t v14 = 7LL;
        *a4 = U_MEMORY_ALLOCATION_ERROR;
        goto LABEL_4;
      }

      uint64_t v13 = (void *)icu::UVector::addElement(*v9, v21, a4);
      unint64_t v14 = *(unsigned int *)a4;
    }

    uint64_t v17 = *(void *)(v17 + 152);
    if (!v17) {
      goto LABEL_20;
    }
  }

  if (*v9) {
    (*(void (**)(icu::UVector *))(*(void *)*v9 + 8LL))(*v9);
  }
  *int v9 = 0LL;
LABEL_26:
  if (v21) {
    (*(void (**)(icu::UnicodeString *))(*(void *)v21 + 8LL))(v21);
  }
LABEL_4:
  icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)&v23);
  return a1;
}

BOOL sub_1808EF530(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  if ((v2 & 0x8000u) == 0) {
    unsigned int v3 = v2 >> 5;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a2 + 12);
  }
  if (v3 != 1) {
    return 0LL;
  }
  if ((v2 & 2) != 0) {
    unsigned int v4 = (unsigned __int16 *)(a2 + 10);
  }
  else {
    unsigned int v4 = *(unsigned __int16 **)(a2 + 24);
  }
  int v5 = *v4;
  if (v5 == 71) {
    return 1LL;
  }
  unint64_t v7 = 0LL;
  do
  {
    unint64_t v8 = v7;
    if (v7 == 15) {
      break;
    }
    int v9 = (unsigned __int16)aGyqmwwedfdahms[++v7];
  }

  while (v5 != v9);
  return v8 < 0xF;
}

uint64_t sub_1808EF5B4(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  unsigned int v3 = *(icu::UVector **)(a1 + 120);
  if (!v3) {
    return 0LL;
  }
  signed int v4 = *(_DWORD *)(a1 + 116);
  if (v4 >= *((_DWORD *)v3 + 2)) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 116) = v4 + 1;
  return icu::UVector::elementAt(v3, v4);
}

uint64_t sub_1808EF5F0(uint64_t result)
{
  *(_DWORD *)(result + 116) = 0;
  return result;
}

uint64_t sub_1808EF5F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0LL;
  }
}

void sub_1808EF610(icu::StringEnumeration *this)
{
  *(void *)this = &off_1897232A8;
  unsigned int v2 = (icu::UVector *)*((void *)this + 15);
  if (v2)
  {
    if (*((int *)v2 + 2) >= 1)
    {
      signed int v3 = 0;
      do
      {
        uint64_t v4 = icu::UVector::elementAt(v2, v3);
        if (v4) {
          (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
        }
        ++v3;
        unsigned int v2 = (icu::UVector *)*((void *)this + 15);
      }

      while (v3 < *((_DWORD *)v2 + 2));
    }

    (*(void (**)(icu::UVector *))(*(void *)v2 + 8LL))(v2);
  }

  icu::StringEnumeration::~StringEnumeration(this);
}

void sub_1808EF690(icu::StringEnumeration *a1)
{
}

uint64_t sub_1808EF6A4(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  signed int v3 = *(icu::UVector **)(a1 + 120);
  if (!v3) {
    return 0LL;
  }
  signed int v4 = *(_DWORD *)(a1 + 116);
  if (v4 >= *((_DWORD *)v3 + 2)) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 116) = v4 + 1;
  return icu::UVector::elementAt(v3, v4);
}

uint64_t sub_1808EF6E0(uint64_t result)
{
  *(_DWORD *)(result + 116) = 0;
  return result;
}

uint64_t sub_1808EF6E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0LL;
  }
}

void sub_1808EF700(icu::StringEnumeration *this)
{
  *(void *)this = &off_189723310;
  unsigned int v2 = (icu::UVector *)*((void *)this + 15);
  if (v2)
  {
    if (*((int *)v2 + 2) >= 1)
    {
      signed int v3 = 0;
      do
      {
        uint64_t v4 = icu::UVector::elementAt(v2, v3);
        if (v4) {
          (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
        }
        ++v3;
        unsigned int v2 = (icu::UVector *)*((void *)this + 15);
      }

      while (v3 < *((_DWORD *)v2 + 2));
    }

    (*(void (**)(icu::UVector *))(*(void *)v2 + 8LL))(v2);
  }

  icu::StringEnumeration::~StringEnumeration(this);
}

void sub_1808EF780(icu::StringEnumeration *a1)
{
}

BOOL sub_1808EF794(icu::UnicodeString *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  memset(v19, 0, sizeof(v19));
  icu::StringCharacterIterator::StringCharacterIterator((icu::StringCharacterIterator *)v19, a1);
  UChar32 v2 = icu::UCharCharacterIterator::first((icu::UCharCharacterIterator *)v19);
  if (!icu::UCharCharacterIterator::hasNext((icu::UCharCharacterIterator *)v19)) {
    goto LABEL_34;
  }
  uint64_t v18 = a1;
  int v3 = 0;
  int v4 = 0;
  int v5 = 0;
  int v6 = -1;
  int v7 = -1;
  int v8 = -1;
  do
  {
    uint64_t v9 = (v2 - 76);
    if (v9 <= 0x2D && ((1LL << (v2 - 76)) & 0x224001002003LL) != 0)
    {
      int v7 = HIDWORD(v19[0]);
      if (v8 == -1) {
        int v8 = HIDWORD(v19[0]);
      }
      if (((1LL << (v2 - 76)) & 0x224000002000LL) != 0)
      {
        int v3 = 1;
      }

      else if (((1LL << (v2 - 76)) & 3) != 0)
      {
        if (v5 > 1) {
          goto LABEL_34;
        }
        ++v5;
      }

      else if (v9 == 24)
      {
        int v4 = 1;
      }
    }

    else if (u_isalpha(v2))
    {
      if (v6 == -1 && v8 != -1) {
        int v6 = HIDWORD(v19[0]);
      }
    }

    else if (!u_isspace(v2) && !u_ispunct(v2) && v2 != 8207)
    {
      goto LABEL_34;
    }

    UChar32 v2 = icu::UCharCharacterIterator::next((icu::UCharCharacterIterator *)v19);
  }

  while (icu::UCharCharacterIterator::hasNext((icu::UCharCharacterIterator *)v19));
  BOOL v11 = 0LL;
  if ((v8 & 0x80000000) == 0 && (v7 & 0x80000000) == 0)
  {
    unsigned int v12 = *((unsigned __int16 *)v18 + 4);
    int v13 = (__int16)v12;
    unsigned int v14 = v12 >> 5;
    int32_t v15 = v13 >= 0 ? v14 : *((_DWORD *)v18 + 3);
    BOOL v11 = 0LL;
    if (icu::UnicodeString::doIndexOf((uint64_t)v18, 0x27u, 0, v15) == -1)
    {
      if (v6 != -1 && v6 < v7)
      {
LABEL_34:
        BOOL v11 = 0LL;
        goto LABEL_35;
      }

      unsigned int v17 = v5 > 0;
      if (v4) {
        ++v17;
      }
      if (v3) {
        ++v17;
      }
      BOOL v11 = v17 > 1;
    }
  }

uint64_t sub_1808EF9B8(uint64_t a1, char *__s2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v9 = (const char **)off_1897230B8;
  uint64_t v10 = 272LL;
  while (1)
  {
    uint64_t result = strcmp(*v9, __s2);
    if (!(_DWORD)result) {
      break;
    }
    v10 += 64LL;
    ++v9;
    if (v10 == 1296) {
      return result;
    }
  }

  int v15 = 0;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, int *, uint64_t))(*(void *)a3 + 32LL))(a3, &v15, a5);
  icu::UnicodeString::UnicodeString(&v16, 1LL, &v14);
  unsigned int v12 = *(char **)(a1 + 8);
  if (*(unsigned __int16 *)&v12[v10] <= 0x1Fu && v17 >= 0x20u)
  {
    int v13 = (UChar **)&v12[v10 - 8];
    icu::UnicodeString::operator=(v13, &v16);
    icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v13);
  }

  return (uint64_t)icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v16);
}

void *sub_1808EFADC(uint64_t a1, const char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  unsigned int v16 = 0;
  uint64_t result = (void *)icu::DateTimePatternGenerator::getFieldAndWidthIndices(a1, a2, &v16);
  if ((_DWORD)result != 16)
  {
    unsigned int v9 = result;
    uint64_t v15 = 0LL;
    memset(v14, 0, sizeof(v14));
    uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v14,  a3,  a5);
    if (*a5 <= 0)
    {
      uint64_t result = (void *)icu::ResourceTable::findValue((icu::ResourceTable *)v14, "dn", a3);
      if ((_DWORD)result)
      {
        int v17 = 0;
        uint64_t v18 = (*(uint64_t (**)(icu::ResourceValue *, int *, int *))(*(void *)a3 + 32LL))(a3, &v17, a5);
        icu::UnicodeString::UnicodeString(&v20, 1LL, &v18);
        unint64_t v10 = *a5;
        if ((int)v10 <= 0)
        {
          uint64_t v11 = v16;
          icu::UnicodeString::UnicodeString( (icu::UnicodeString *)&v18,  (UChar **)(*(void *)(a1 + 8) + 192LL * v9 + ((unint64_t)v16 << 6) + 1288));
          if (v19 < 0x20u)
          {
            unsigned int v12 = v21;
            icu::UnicodeString::~UnicodeString((void *)v19, (icu::UnicodeString *)&v18);
            if (v12 >= 0x20)
            {
              int v13 = (UChar **)(*(void *)(a1 + 8) + 192LL * v9 + (v11 << 6) + 1288);
              icu::UnicodeString::operator=(v13, &v20);
              icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v13);
            }
          }

          else
          {
            icu::UnicodeString::~UnicodeString((void *)v19, (icu::UnicodeString *)&v18);
          }
        }

        return icu::UnicodeString::~UnicodeString((void *)v10, (icu::UnicodeString *)&v20);
      }
    }
  }

  return result;
}

void *sub_1808EFC70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v16 = 0;
  memset(v23, 0, sizeof(v23));
  icu::UnicodeString::UnicodeString(v23, a2, 0xFFFFFFFFLL, 0LL);
  memset(v22, 0, sizeof(v22));
  LODWORD(v17) = 0;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), int *))(*(void *)a3 + 32LL))( a3,  &v17,  &v16);
  icu::UnicodeString::UnicodeString(v22, 1LL, &v19);
  unint64_t v8 = v16;
  if (v16 <= 0
    && uhash_geti(**(void **)(*(void *)(a1 + 8) + 4688LL), (uint64_t)v23) != 1
    && (!*(_BYTE *)(a1 + 16) || sub_1808EF794((icu::UnicodeString *)v22)))
  {
    if (!icu::Locale::isRightToLeft((icu::Locale *)(*(void *)(a1 + 8) + 8LL)))
    {
      icu::UnicodeString::UnicodeString((uint64_t)&v19, 8207);
      int v17 = off_18971B688;
      __int16 v18 = 2;
      if ((SWORD4(v22[0]) & 0x8000u) == 0) {
        int32_t v9 = WORD4(v22[0]) >> 5;
      }
      else {
        int32_t v9 = HIDWORD(v22[0]);
      }
      if ((v20 & 0x8000u) == 0) {
        uint64_t v10 = v20 >> 5;
      }
      else {
        uint64_t v10 = v21;
      }
      icu::UnicodeString::findAndReplace( (icu::UnicodeString *)v22,  0,  v9,  (const icu::UnicodeString *)&v19,  0,  v10,  (const icu::UnicodeString *)&v17,  0,  0);
      icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)&v17);
      icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v19);
    }

    icu::DateTimePatternGenerator::setAvailableFormat(*(icu::DateTimePatternGenerator **)(a1 + 8), (UChar **)v23, a5);
    if ((*(_WORD *)(a1 + 32) & 1) != 0) {
      __int16 v13 = 2;
    }
    else {
      __int16 v13 = *(_WORD *)(a1 + 32) & 0x1F;
    }
    *(_WORD *)(a1 + 32) = v13;
    icu::DateTimePatternGenerator::addPatternWithSkeleton( *(icu::DateTimePatternGenerator **)(a1 + 8),  (UChar **)v22,  (UChar **)v23,  1,  (UChar **)(a1 + 24),  a5);
  }

  icu::UnicodeString::~UnicodeString((void *)v8, (icu::UnicodeString *)v22);
  return icu::UnicodeString::~UnicodeString(v14, (icu::UnicodeString *)v23);
}

void sub_1808EFE60(icu::ResourceSink *a1)
{
}

void sub_1808EFE74(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  uint64_t v43 = 0LL;
  __s1 = a2;
  memset(v42, 0, sizeof(v42));
  (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))(v42, a3, a5);
  if (*a5 <= 0
    && icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v42, 0, (const char **)&__s1, a3))
  {
    int v7 = 0;
    unint64_t v8 = "allowed";
    int32_t v9 = "preferred";
    do
    {
      uint64_t v10 = __s1;
      uint64_t v41 = 0LL;
      memset(v40, 0, sizeof(v40));
      (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))(v40, a3, a5);
      if (*a5 > 0) {
        return;
      }
      __int128 v35 = v10;
      int v34 = v7;
      if (icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v40, 0, (const char **)&__s1, a3))
      {
        unsigned int v11 = 0;
        LODWORD(v37) = 0;
        unsigned int v12 = 0LL;
        int v36 = -1;
        do
        {
          __int16 v13 = __s1;
          if (!strcmp(__s1, v8))
          {
            if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24LL))(a3))
            {
              int v16 = v9;
              int v17 = v8;
              v38[0] = 0LL;
              v38[1] = 0LL;
              uint64_t v39 = 0LL;
              (*(void (**)(void *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 80LL))( v38,  a3,  a5);
              int v18 = v39;
              uint64_t v19 = (int *)uprv_malloc(4LL * (v39 + 2));
              if (!v19) {
                goto LABEL_32;
              }
              unsigned __int16 v20 = v19;
              uint64_t v37 = (v18 + 1);
              bzero(v19, 4LL * (v18 + 2));
              uprv_free(v12);
              if (v18 >= 1)
              {
                uint64_t v21 = 0LL;
                do
                {
                  icu::ResourceArray::getValue((icu::ResourceArray *)v38, v21, a3);
                  int v46 = 0;
                  uint64_t v45 = (*(uint64_t (**)(icu::ResourceValue *, int *, int *))(*(void *)a3 + 32LL))( a3,  &v46,  a5);
                  uint64_t v22 = icu::UnicodeString::UnicodeString(v47, 1LL, &v45);
                  v20[v21 + 1] = sub_1808F02A4(v22);
                  icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)v47);
                  ++v21;
                }

                while (v37 - 1 != v21);
              }

              unsigned int v12 = v20;
              unint64_t v8 = v17;
              int32_t v9 = v16;
            }

            else
            {
              uint64_t v24 = (int *)uprv_malloc(0xCuLL);
              if (!v24) {
                goto LABEL_32;
              }
              __int128 v25 = v24;
              UErrorCode v24[2] = 0;
              *(void *)uint64_t v24 = 0LL;
              uprv_free(v12);
              LODWORD(v45) = 0;
              v38[0] = (*(uint64_t (**)(icu::ResourceValue *, uint64_t *, int *))(*(void *)a3 + 32LL))( a3,  &v45,  a5);
              uint64_t v26 = icu::UnicodeString::UnicodeString(v47, 1LL, v38);
              v25[1] = sub_1808F02A4(v26);
              icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)v47);
              LODWORD(v37) = 2;
              unsigned int v12 = v25;
            }
          }

          else if (!strcmp(v13, v9))
          {
            LODWORD(v45) = 0;
            v38[0] = (*(uint64_t (**)(icu::ResourceValue *, uint64_t *, int *))(*(void *)a3 + 32LL))( a3,  &v45,  a5);
            uint64_t v14 = icu::UnicodeString::UnicodeString(v47, 1LL, v38);
            int v36 = sub_1808F02A4(v14);
            icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v47);
          }

          ++v11;
        }

        while (icu::ResourceTable::getKeyAndValue( (icu::ResourceTable *)v40,  v11,  (const char **)&__s1,  a3));
        unsigned int v28 = v37;
        if ((int)v37 >= 2)
        {
          int v29 = v36;
          uint64_t v30 = (uint64_t)v35;
          if (v36 == -1) {
            int v29 = v12[1];
          }
          *unsigned int v12 = v29;
          goto LABEL_29;
        }
      }

      else
      {
        unsigned int v12 = 0LL;
        int v36 = -1;
      }

      int v31 = (int *)uprv_malloc(0xCuLL);
      if (!v31)
      {
LABEL_32:
        *a5 = 7;
LABEL_33:
        uprv_free(v12);
        return;
      }

      unsigned int v32 = v31;
      v31[2] = 0;
      *(void *)int v31 = 0LL;
      uprv_free(v12);
      int v33 = v36;
      if (v36 == -1) {
        int v33 = 1;
      }
      *unsigned int v32 = v33;
      v32[1] = v33;
      unsigned int v28 = 2;
      unsigned int v12 = v32;
      uint64_t v30 = (uint64_t)v35;
LABEL_29:
      v12[v28] = -1;
      uhash_put(qword_18C4493E0, v30, (uint64_t)v12, a5);
      if (*a5 >= 1)
      {
        unsigned int v12 = 0LL;
        goto LABEL_33;
      }

      uprv_free(0LL);
      int v7 = v34 + 1;
    }

    while (icu::ResourceTable::getKeyAndValue( (icu::ResourceTable *)v42,  v34 + 1,  (const char **)&__s1,  a3));
  }

uint64_t sub_1808F02A4(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0)
  {
    int v2 = *(_DWORD *)(a1 + 12);
    if (v2 == 1) {
      goto LABEL_16;
    }
    if (v2 != 2) {
      return 0xFFFFFFFFLL;
    }
LABEL_7:
    if ((v1 & 2) != 0) {
      int v3 = (_WORD *)(a1 + 10);
    }
    else {
      int v3 = *(_WORD **)(a1 + 24);
    }
    if (*v3 == 104)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 12);
      if ((v1 & 0x8000u) == 0) {
        unsigned int v4 = v1 >> 5;
      }
      if (v4 >= 2 && v3[1] == 98) {
        return 4LL;
      }
    }

    if ((v1 & 0x8000u) == 0) {
      unsigned int v8 = v1 >> 5;
    }
    else {
      unsigned int v8 = *(_DWORD *)(a1 + 12);
    }
    if (v8)
    {
      int32_t v9 = *(_WORD **)(a1 + 24);
      if ((v1 & 2) != 0) {
        int32_t v9 = (_WORD *)(a1 + 10);
      }
      BOOL v10 = *v9 != 104 || v8 == 1;
      if (!v10 && v9[1] == 66) {
        return 5LL;
      }
      __int16 v13 = *(_WORD **)(a1 + 24);
      if ((v1 & 2) != 0) {
        __int16 v13 = (_WORD *)(a1 + 10);
      }
      BOOL v14 = *v13 == 75 && v8 >= 2;
      if (v14 && v13[1] == 98) {
        return 6LL;
      }
      uint64_t v15 = *(_WORD **)(a1 + 24);
      if ((v1 & 2) != 0) {
        uint64_t v15 = (_WORD *)(a1 + 10);
      }
      BOOL v16 = *v15 == 75 && v8 >= 2;
      if (v16 && v15[1] == 66) {
        return 7LL;
      }
      int v17 = *(_WORD **)(a1 + 24);
      if ((v1 & 2) != 0) {
        int v17 = (_WORD *)(a1 + 10);
      }
      BOOL v18 = *v17 == 72 && v8 >= 2;
      if (v18 && v17[1] == 98) {
        return 8LL;
      }
      uint64_t v19 = (v1 & 2) != 0 ? (_WORD *)(a1 + 10) : *(_WORD **)(a1 + 24);
      if (*v19 == 72 && v8 >= 2 && v19[1] == 66) {
        return 9LL;
      }
    }

    return 0xFFFFFFFFLL;
  }

  if ((v1 & 0xFFE0) == 0x40) {
    goto LABEL_7;
  }
  if ((v1 & 0xFFE0) != 0x20) {
    return 0xFFFFFFFFLL;
  }
LABEL_16:
  int v6 = (unsigned __int16 *)(a1 + 10);
  if ((v1 & 2) == 0) {
    int v6 = *(unsigned __int16 **)(a1 + 24);
  }
  int v7 = *v6;
  if (v7 == 104) {
    return 0LL;
  }
  int v11 = (__int16)v1;
  unsigned int v12 = v1 >> 5;
  if (v11 < 0) {
    unsigned int v12 = *(_DWORD *)(a1 + 12);
  }
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  if (v7 == 72) {
    return 1LL;
  }
  if (v7 != 75)
  {
    if (v7 == 107) {
      return 3LL;
    }
    return 0xFFFFFFFFLL;
  }

  return 2LL;
}

void *icu::DateTimeRule::getStaticClassID(icu::DateTimeRule *this)
{
  return &unk_18C535410;
}

void *icu::DateTimeRule::getDynamicClassID(icu::DateTimeRule *this)
{
  return &unk_18C535410;
}

uint64_t icu::DateTimeRule::DateTimeRule(uint64_t result, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 12) = a3;
  *(void *)uint64_t result = off_189723578;
  *(void *)(result + 16) = 0LL;
  *(_DWORD *)(result + 24) = a4;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = a5;
  return result;
}

{
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 12) = a3;
  *(void *)uint64_t result = off_189723578;
  *(void *)(result + 16) = 0LL;
  *(_DWORD *)(result + 24) = a4;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = a5;
  return result;
}

uint64_t icu::DateTimeRule::DateTimeRule(uint64_t result, int a2, int a3, int a4, int a5, int a6)
{
  *(void *)uint64_t result = off_189723578;
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = a4;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a5;
  *(_DWORD *)(result + 28) = 1;
  *(_DWORD *)(result + 32) = a6;
  return result;
}

{
  *(void *)uint64_t result = off_189723578;
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = a4;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a5;
  *(_DWORD *)(result + 28) = 1;
  *(_DWORD *)(result + 32) = a6;
  return result;
}

uint64_t icu::DateTimeRule::DateTimeRule(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(void *)uint64_t result = off_189723578;
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 12) = a3;
  *(_DWORD *)(result + 16) = a4;
  *(_DWORD *)(result + 20) = 0;
  if (a5) {
    int v7 = 2;
  }
  else {
    int v7 = 3;
  }
  *(_DWORD *)(result + 24) = a6;
  *(_DWORD *)(result + 28) = v7;
  *(_DWORD *)(result + 32) = a7;
  return result;
}

{
  int v7;
  *(void *)uint64_t result = off_189723578;
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 12) = a3;
  *(_DWORD *)(result + 16) = a4;
  *(_DWORD *)(result + 20) = 0;
  if (a5) {
    int v7 = 2;
  }
  else {
    int v7 = 3;
  }
  *(_DWORD *)(result + 24) = a6;
  *(_DWORD *)(result + 28) = v7;
  *(_DWORD *)(result + 32) = a7;
  return result;
}

double icu::DateTimeRule::DateTimeRule(icu::DateTimeRule *this, const icu::DateTimeRule *a2)
{
  *(void *)this = off_189723578;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  double result = *((double *)a2 + 3);
  *((double *)this + 3) = result;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  return result;
}

{
  double result;
  *(void *)this = off_189723578;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  double result = *((double *)a2 + 3);
  *((double *)this + 3) = result;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  return result;
}

void icu::DateTimeRule::~DateTimeRule(icu::DateTimeRule *this)
{
}

double icu::DateTimeRule::clone(icu::DateTimeRule *this, unint64_t a2)
{
  uint64_t v3 = icu::UMemory::operator new((icu::UMemory *)0x28, a2);
  if (v3)
  {
    *(void *)uint64_t v3 = off_189723578;
    *(_OWORD *)(v3 + 8) = *(_OWORD *)((char *)this + 8);
    double result = *((double *)this + 3);
    *(double *)(v3 + 24) = result;
    *(_DWORD *)(v3 + 32) = *((_DWORD *)this + 8);
  }

  return result;
}

double icu::DateTimeRule::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    double result = *(double *)(a2 + 24);
    *(double *)(a1 + 24) = result;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  }

  return result;
}

BOOL icu::DateTimeRule::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a1) {
    __cxa_bad_typeid();
  }
  BOOL result = sub_1807F874C(*(void *)(*(void *)a1 - 8LL), *(void *)(*(void *)a2 - 8LL));
  if (result) {
    return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
  }
        && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
        && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
        && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
  return result;
}

BOOL icu::DateTimeRule::operator!=(uint64_t a1, uint64_t a2)
{
  return !icu::DateTimeRule::operator==(a1, a2);
}

uint64_t icu::DateTimeRule::getDateRuleType(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t icu::DateTimeRule::getTimeRuleType(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t icu::DateTimeRule::getRuleMonth(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t icu::DateTimeRule::getRuleDayOfMonth(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t icu::DateTimeRule::getRuleDayOfWeek(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t icu::DateTimeRule::getRuleWeekInMonth(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t icu::DateTimeRule::getRuleMillisInDay(icu::DateTimeRule *this)
{
  return *((unsigned int *)this + 6);
}

icu::EraRules *icu::EraRules::EraRules(icu::EraRules *a1, void *a2, int a3)
{
  *(void *)a1 = 0LL;
  *((_DWORD *)a1 + 2) = a3;
  uprv_free(0LL);
  *(void *)a1 = *a2;
  *a2 = 0LL;
  icu::EraRules::initCurrentEra(a1);
  return a1;
}

{
  *(void *)a1 = 0LL;
  *((_DWORD *)a1 + 2) = a3;
  uprv_free(0LL);
  *(void *)a1 = *a2;
  *a2 = 0LL;
  icu::EraRules::initCurrentEra(a1);
  return a1;
}

void icu::EraRules::initCurrentEra(icu::EraRules *this)
{
  int v18 = 0;
  Now = (icu::TimeZone *)ucal_getNow();
  double v4 = v3;
  int v16 = 0;
  int v17 = 0;
  uint64_t Default = icu::TimeZone::createDefault(Now);
  if (Default)
  {
    uint64_t v6 = Default;
    (*(void (**)(uint64_t, void, int *, int *, int *, double))(*(void *)Default + 48LL))( Default,  0LL,  &v17,  &v16,  &v18,  v4);
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    double v4 = v4 + (double)(v16 + v17);
  }

  int v15 = 0;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  int v12 = 0;
  sub_1808FA670(&v15, (_DWORD *)&v14 + 1, &v14, (int *)&v13 + 1, (int *)&v13, &v12, v4);
  uint64_t v7 = *((unsigned int *)this + 2);
  else {
    int v8 = *((_DWORD *)this + 2);
  }
  int v9 = v8 - 1;
  uint64_t v10 = v7 - 1;
  while ((int)v7 >= 2)
  {
    signed int v11 = *(_DWORD *)(*(void *)this + 4LL * v10);
    LODWORD(v7) = v7 - 1;
    --v10;
  }

  LODWORD(v7) = v9;
LABEL_11:
  *((_DWORD *)this + 3) = v7;
}

void icu::EraRules::~EraRules(void **this)
{
}

{
  uprv_free(*this);
}

icu::EraRules *icu::EraRules::createInstance(icu::EraRules *this, const char *a2, int *a3, UErrorCode *a4)
{
  if (*a3 > 0) {
    return 0LL;
  }
  int v6 = (int)a2;
  uint64_t v8 = ures_openDirect(0LL, (uint64_t)"supplementalData", (uint64_t)a3);
  ures_getByKey(v8, "calendarData", v8, a3);
  ures_getByKey(v8, (const char *)this, v8, a3);
  ures_getByKey(v8, "eras", v8, a3);
  double v4 = 0LL;
  if (*a3 <= 0)
  {
    signed int Size = ures_getSize(v8);
    uint64_t v10 = uprv_malloc(4LL * Size);
    signed int v11 = v10;
    if (!v10) {
      goto LABEL_55;
    }
    bzero(v10, 4LL * Size);
    int v32 = 0x7FFFFFFF;
LABEL_6:
    if (ures_hasNext(v8))
    {
      NextResource = ures_getNextResource(v8, 0LL, a3);
      uint64_t v15 = (uint64_t)NextResource;
      if (*a3 > 0) {
        goto LABEL_13;
      }
      uint64_t Key = ures_getKey((uint64_t)NextResource);
      __endptr = 0LL;
      unsigned int v17 = strtol((const char *)Key, &__endptr, 10);
      if (&__endptr[-Key] != (char *)strlen((const char *)Key)
        || (v17 & 0x80000000) != 0
        || Size <= (int)v17
        || v11[v17])
      {
        goto LABEL_12;
      }

      int v33 = 0;
      char v19 = 1;
      while (1)
      {
        if (!ures_hasNext(v15))
        {
          if (v11[v17]) {
            goto LABEL_40;
          }
          if (v17) {
            goto LABEL_12;
          }
          v11[v17] = -2147483391;
LABEL_40:
          if (v19)
          {
            if (v32 > (int)v17)
            {
              int v18 = 0;
              goto LABEL_14;
            }

uint64_t icu::EraRules::getStartDate(uint64_t this, unsigned int a2, int (*a3)[3], UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    if ((a2 & 0x80000000) != 0 || *(_DWORD *)(this + 8) <= (signed int)a2)
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      int v4 = *(_DWORD *)(*(void *)this + 4LL * a2);
      int v5 = BYTE1(v4);
      int v6 = v4;
      if (v4 == -2147483391) {
        int v7 = -1;
      }
      else {
        int v7 = v4 >> 16;
      }
      (*a3)[0] = v7;
      (*a3)[1] = v5;
      (*a3)[2] = v6;
    }
  }

  return this;
}

uint64_t icu::EraRules::getStartYear(icu::EraRules *this, unsigned int a2, UErrorCode *a3)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 2) <= (signed int)a2)
  {
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0x3FFFFFFFLL;
  }

  int v3 = *(_DWORD *)(*(void *)this + 4LL * a2);
  if (v3 == -2147483391) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (v3 >> 16);
  }
}

uint64_t icu::EraRules::getEraIndex(icu::EraRules *this, int a2, int a3, unsigned int a4, UErrorCode *a5)
{
  if ((a3 - 13) < 0xFFFFFFF4 || a4 - 32 <= 0xFFFFFFE0)
  {
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0xFFFFFFFFLL;
  }

  int v6 = *((_DWORD *)this + 2);
  uint64_t result = *((int *)this + 3);
  uint64_t v8 = *(void *)this;
  int v9 = *(_DWORD *)(v8 + 4 * result);
  if (a2 <= -32769)
  {
    if (v9 == -2147483391) {
      goto LABEL_13;
    }
LABEL_12:
    uint64_t result = 0LL;
    goto LABEL_13;
  }

void *icu::EscapeTransliterator::getStaticClassID(icu::EscapeTransliterator *this)
{
  return &unk_18C535411;
}

void *sub_1808F0EDC()
{
  return &unk_18C535411;
}

void *sub_1808F0EE8()
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  int v27 = "A";
  unint64_t v0 = icu::UnicodeString::UnicodeString(v28, 1LL, &v27);
  icu::Transliterator::_registerFactory(v0, (uint64_t)sub_1808F10F8, 0LL);
  int v2 = icu::UnicodeString::~UnicodeString(v1, (icu::UnicodeString *)v28);
  int v26 = "A";
  unint64_t v3 = icu::UnicodeString::UnicodeString(v2, 1LL, &v26);
  icu::Transliterator::_registerFactory(v3, (uint64_t)sub_1808F11DC, 0LL);
  int v5 = icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v28);
  __int128 v25 = L"Any-Hex/C";
  unint64_t v6 = icu::UnicodeString::UnicodeString(v5, 1LL, &v25);
  icu::Transliterator::_registerFactory(v6, (uint64_t)sub_1808F12C0, 0LL);
  uint64_t v8 = icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v28);
  uint64_t v24 = L"Any-Hex/XML";
  unint64_t v9 = icu::UnicodeString::UnicodeString(v8, 1LL, &v24);
  icu::Transliterator::_registerFactory(v9, (uint64_t)sub_1808F145C, 0LL);
  int v11 = icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v28);
  __int128 v23 = L"Any-Hex/XML10";
  unint64_t v12 = icu::UnicodeString::UnicodeString(v11, 1LL, &v23);
  icu::Transliterator::_registerFactory(v12, (uint64_t)sub_1808F152C, 0LL);
  int v14 = icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v28);
  char v22 = L"Any-Hex/Perl";
  unint64_t v15 = icu::UnicodeString::UnicodeString(v14, 1LL, &v22);
  icu::Transliterator::_registerFactory(v15, (uint64_t)sub_1808F15FC, 0LL);
  unsigned int v17 = icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v28);
  uint64_t v21 = "A";
  unint64_t v18 = icu::UnicodeString::UnicodeString(v17, 1LL, &v21);
  icu::Transliterator::_registerFactory(v18, (uint64_t)sub_1808F11DC, 0LL);
  return icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v28);
}

uint64_t *sub_1808F10F8(UChar **a1, unint64_t a2)
{
  int v11 = (uint64_t *)*MEMORY[0x1895F89C0];
  unint64_t v3 = icu::UMemory::operator new(v11, (icu::UMemory *)0xF0, a2);
  if (v3)
  {
    int v7 = "U";
    icu::UnicodeString::UnicodeString(v10, 1LL, &v7);
    uint64_t v8 = (UChar *)off_18971B688;
    __int16 v9 = 2;
    sub_1808F16CC((uint64_t)v3, a1, v10, &v8, 16, 4, 1, 0LL);
    icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)&v8);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v10);
  }

  return v3;
}

uint64_t *sub_1808F11DC(UChar **a1, unint64_t a2)
{
  int v11 = (uint64_t *)*MEMORY[0x1895F89C0];
  unint64_t v3 = icu::UMemory::operator new(v11, (icu::UMemory *)0xF0, a2);
  if (v3)
  {
    int v7 = L"\\u";
    icu::UnicodeString::UnicodeString(v10, 1LL, &v7);
    uint64_t v8 = (UChar *)off_18971B688;
    __int16 v9 = 2;
    sub_1808F16CC((uint64_t)v3, a1, v10, &v8, 16, 4, 0, 0LL);
    icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)&v8);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v10);
  }

  return v3;
}

uint64_t *sub_1808F12C0(UChar **a1, unint64_t a2)
{
  __int128 v23 = (uint64_t *)*MEMORY[0x1895F89C0];
  unint64_t v3 = icu::UMemory::operator new(v23, (icu::UMemory *)0xF0, a2);
  if (v3)
  {
    int v14 = L"\\u";
    icu::UnicodeString::UnicodeString(v22, 1LL, &v14);
    unsigned __int16 v20 = (UChar *)off_18971B688;
    __int16 v21 = 2;
    if (v5)
    {
      uint64_t v6 = (uint64_t)v5;
      unint64_t v18 = (UChar *)off_18971B688;
      __int16 v19 = 2;
      int v13 = "\\"";
      icu::UnicodeString::UnicodeString(v17, 1LL, &v13);
      unint64_t v15 = (UChar *)off_18971B688;
      __int16 v16 = 2;
      sub_1808F16CC(v6, &v18, v17, &v15, 16, 8, 1, 0LL);
      sub_1808F16CC((uint64_t)v3, a1, v22, &v20, 16, 4, 1, v6);
      icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v15);
      icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v17);
      unint64_t v12 = v13;
      icu::UnicodeString::~UnicodeString(&v12, (icu::UnicodeString *)&v18);
    }

    else
    {
      sub_1808F16CC((uint64_t)v3, a1, v22, &v20, 16, 4, 1, 0LL);
    }

    icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)&v20);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v22);
  }

  return v3;
}

uint64_t *sub_1808F145C(UChar **a1, unint64_t a2)
{
  int v10 = (uint64_t *)*MEMORY[0x1895F89C0];
  unint64_t v3 = icu::UMemory::operator new(v10, (icu::UMemory *)0xF0, a2);
  if (v3)
  {
    int v7 = L"&#x";
    icu::UnicodeString::UnicodeString(v9, 1LL, &v7);
    icu::UnicodeString::UnicodeString((uint64_t)v8, 59);
    sub_1808F16CC((uint64_t)v3, a1, v9, v8, 16, 1, 1, 0LL);
    icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v8);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v9);
  }

  return v3;
}

uint64_t *sub_1808F152C(UChar **a1, unint64_t a2)
{
  int v10 = (uint64_t *)*MEMORY[0x1895F89C0];
  unint64_t v3 = icu::UMemory::operator new(v10, (icu::UMemory *)0xF0, a2);
  if (v3)
  {
    int v7 = L"&#";
    icu::UnicodeString::UnicodeString(v9, 1LL, &v7);
    icu::UnicodeString::UnicodeString((uint64_t)v8, 59);
    sub_1808F16CC((uint64_t)v3, a1, v9, v8, 10, 1, 1, 0LL);
    icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v8);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v9);
  }

  return v3;
}

uint64_t *sub_1808F15FC(UChar **a1, unint64_t a2)
{
  int v10 = (uint64_t *)*MEMORY[0x1895F89C0];
  unint64_t v3 = icu::UMemory::operator new(v10, (icu::UMemory *)0xF0, a2);
  if (v3)
  {
    int v7 = "\\"";
    icu::UnicodeString::UnicodeString(v9, 1LL, &v7);
    icu::UnicodeString::UnicodeString((uint64_t)v8, 125);
    sub_1808F16CC((uint64_t)v3, a1, v9, v8, 16, 1, 1, 0LL);
    icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v8);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v9);
  }

  return v3;
}

uint64_t sub_1808F16CC(uint64_t a1, UChar **a2, UChar **a3, UChar **a4, int a5, int a6, char a7, uint64_t a8)
{
  unint64_t v15 = icu::Transliterator::Transliterator((icu::Transliterator *)a1, a2, 0LL);
  *(void *)unint64_t v15 = off_1897235B8;
  *((void *)v15 + 1sub_1808F7164((uint64_t)v14, 1) = off_18971B688;
  *(_WORD *)(a1 + 96) = 2;
  *(void *)(a1 + 152) = off_18971B688;
  *(_WORD *)(a1 + 160) = 2;
  icu::UnicodeString::operator=((UChar **)v15 + 11, a3);
  icu::UnicodeString::operator=((UChar **)(a1 + 152), a4);
  *(_DWORD *)(a1 + 216) = a5;
  *(_DWORD *)(a1 + 220) = a6;
  *(_BYTE *)(a1 + 224) = a7;
  *(void *)(a1 + 232) = a8;
  return a1;
}

uint64_t sub_1808F1774(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = icu::Transliterator::Transliterator((icu::Transliterator *)a1, (UChar **)a2);
  *(void *)unint64_t v4 = off_1897235B8;
  icu::UnicodeString::UnicodeString((icu::Transliterator *)((char *)v4 + 88), (UChar **)(a2 + 88));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(a1 + 152), (UChar **)(a2 + 152));
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(_BYTE *)(a1 + 224) = *(_BYTE *)(a2 + 224);
  uint64_t v6 = *(uint64_t **)(a2 + 232);
  if (v6)
  {
    int v7 = icu::UMemory::operator new(v6, (icu::UMemory *)0xF0, v5);
    if (v7) {
      int v7 = (uint64_t *)sub_1808F1774(v7, *(void *)(a2 + 232));
    }
  }

  else
  {
    int v7 = 0LL;
  }

  *(void *)(a1 + 232) = v7;
  return a1;
}

void sub_1808F17F4(void *a1)
{
  int v2 = off_1897235B8;
  *a1 = off_1897235B8;
  uint64_t v3 = a1[29];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)(a1 + 19));
  icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)(a1 + 11));
  icu::Transliterator::~Transliterator((icu::Transliterator *)a1);
}

void sub_1808F1848(void *a1)
{
}

uint64_t *sub_1808F185C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0xF0, a2);
  if (result) {
    return (uint64_t *)sub_1808F1774((uint64_t)result, a1);
  }
  return result;
}

void *sub_1808F188C(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3[2];
  int v6 = a3[3];
  memset(v44, 0, sizeof(v44));
  int v7 = (const icu::UnicodeString *)(a1 + 88);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v44, (UChar **)(a1 + 88));
  else {
    int v8 = *(unsigned __int16 *)(a1 + 96) >> 5;
  }
  if ((int)v5 < v6)
  {
    int v9 = 0;
    while (1)
    {
      uint64_t v10 = *a2;
      if (!*(_BYTE *)(a1 + 224)) {
        break;
      }
      uint64_t v11 = (*(uint64_t (**)(uint64_t *, uint64_t))(v10 + 80))(a2, v5);
      unint64_t v12 = (icu::UnicodeString *)v11;
      if (*(_BYTE *)(a1 + 224)) {
        BOOL v13 = v11 >= 0x10000;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13) {
        int v14 = 2;
      }
      else {
        int v14 = 1;
      }
      uint64_t v15 = *(void *)(a1 + 232);
      if (!v15) {
        goto LABEL_23;
      }
      if ((BYTE8(v44[0]) & 1) != 0)
      {
        icu::UnicodeString::unBogus((uint64_t)v44);
        uint64_t v15 = *(void *)(a1 + 232);
      }

      else
      {
        if ((SWORD4(v44[0]) & 0x8000u) == 0) {
          int v16 = WORD4(v44[0]) >> 5;
        }
        else {
          int v16 = HIDWORD(v44[0]);
        }
        if (v16)
        {
          BYTE8(v44[0]) &= 0x1Fu;
          WORD4(v44[0]) = BYTE8(v44[0]);
        }
      }

      int v28 = (const icu::UnicodeString *)(v15 + 88);
      unsigned int v29 = *(unsigned __int16 *)(v15 + 96);
      int v30 = (__int16)v29;
      unsigned int v31 = v29 >> 5;
      unsigned int v32 = *(_DWORD *)(v15 + 100);
      if (v30 >= 0) {
        uint64_t v33 = v31;
      }
      else {
        uint64_t v33 = v32;
      }
      icu::UnicodeString::doAppend((uint64_t)v44, v28, 0, v33);
      icu::ICU_Utility::appendNumber( (icu::ICU_Utility *)v44,  v12,  *(_DWORD *)(*(void *)(a1 + 232) + 216LL),  *(_DWORD *)(*(void *)(a1 + 232) + 220LL));
      uint64_t v34 = *(void *)(a1 + 232);
      __int128 v35 = (const icu::UnicodeString *)(v34 + 152);
      unsigned int v36 = *(unsigned __int16 *)(v34 + 160);
      int v37 = (__int16)v36;
      unsigned int v38 = v36 >> 5;
      unsigned int v39 = *(_DWORD *)(v34 + 164);
      if (v37 >= 0) {
        uint64_t v40 = v38;
      }
      else {
        uint64_t v40 = v39;
      }
      icu::UnicodeString::doAppend((uint64_t)v44, v35, 0, v40);
      int v9 = 1;
LABEL_42:
      (*(void (**)(uint64_t *, uint64_t, void, _OWORD *))(*a2 + 32))(a2, v5, (v14 + v5), v44);
      int v26 = WORD4(v44[0]) >> 5;
      if (SWORD4(v44[0]) < 0) {
        int v26 = HIDWORD(v44[0]);
      }
      uint64_t v5 = (v26 + v5);
      int v6 = v6 - v14 + v26;
    }

    unint64_t v12 = (icu::UnicodeString *)(*(uint64_t (**)(uint64_t *, uint64_t))(v10 + 72))(a2, v5);
LABEL_22:
    int v14 = 1;
LABEL_23:
    if (v9)
    {
      if ((BYTE8(v44[0]) & 1) != 0)
      {
        icu::UnicodeString::unBogus((uint64_t)v44);
      }

      else
      {
        if ((SWORD4(v44[0]) & 0x8000u) == 0) {
          int v17 = WORD4(v44[0]) >> 5;
        }
        else {
          int v17 = HIDWORD(v44[0]);
        }
        if (v17)
        {
          BYTE8(v44[0]) &= 0x1Fu;
          WORD4(v44[0]) = BYTE8(v44[0]);
        }
      }

      unsigned int v18 = *(unsigned __int16 *)(a1 + 96);
      int v19 = (__int16)v18;
      unsigned int v20 = v18 >> 5;
      if (v19 >= 0) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = *(unsigned int *)(a1 + 100);
      }
      icu::UnicodeString::doAppend((uint64_t)v44, v7, 0, v21);
    }

    else if (v8 || (BYTE8(v44[0]) & 1) == 0)
    {
      if ((SWORD4(v44[0]) & 0x8000u) == 0) {
        unsigned int v27 = WORD4(v44[0]) >> 5;
      }
      else {
        unsigned int v27 = HIDWORD(v44[0]);
      }
      if (v27 > v8)
      {
        if (v8 > 1023)
        {
          WORD4(v44[0]) = BYTE8(v44[0]) | 0xFFE0;
          HIDWORD(v44[0]) = v8;
        }

        else
        {
          WORD4(v44[0]) = BYTE8(v44[0]) & 0x1F | (32 * v8);
        }
      }
    }

    else
    {
      icu::UnicodeString::unBogus((uint64_t)v44);
    }

    icu::ICU_Utility::appendNumber((icu::ICU_Utility *)v44, v12, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
    unsigned int v22 = *(unsigned __int16 *)(a1 + 160);
    int v23 = (__int16)v22;
    unsigned int v24 = v22 >> 5;
    if (v23 >= 0) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = *(unsigned int *)(a1 + 164);
    }
    icu::UnicodeString::doAppend((uint64_t)v44, (const icu::UnicodeString *)(a1 + 152), 0, v25);
    int v9 = 0;
    goto LABEL_42;
  }

void *icu::EthiopicCalendar::getStaticClassID(icu::EthiopicCalendar *this)
{
  return &unk_18C535414;
}

void *sub_1808F1BD0()
{
  return &unk_18C535414;
}

void *icu::EthiopicAmeteAlemCalendar::getStaticClassID(icu::EthiopicAmeteAlemCalendar *this)
{
  return &unk_18C535415;
}

void *sub_1808F1BE8()
{
  return &unk_18C535415;
}

icu::CECalendar *sub_1808F1BF4(icu::CECalendar *a1, char **a2, UErrorCode *a3)
{
  uint64_t result = icu::CECalendar::CECalendar(a1, a2, a3);
  *(void *)uint64_t result = &off_189723668;
  return result;
}

void sub_1808F1C18(icu::CECalendar *a1)
{
}

icu::CECalendar *sub_1808F1C2C@<X0>( const icu::CECalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::CECalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    uint64_t result = (icu::CECalendar *)icu::CECalendar::CECalendar(result, a1);
    *(void *)uint64_t result = &off_189723668;
  }

  return result;
}

const char *sub_1808F1C68()
{
  return "ethiopic";
}

uint64_t sub_1808F1C74(_DWORD *a1)
{
  if (icu::Calendar::newerField((uint64_t)a1, 0x13u, 1u) == 19)
  {
    return 1LL;
  }

  if ((int)a1[33] < 1 || a1[3] == 1)
  {
    return 1LL;
  }

  else {
    return (a1[4] - 5500);
  }
}

double sub_1808F1D0C(uint64_t a1, icu::CECalendar *a2)
{
  *(void *)unint64_t v12 = 0LL;
  int v11 = 0;
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 440LL))(a1);
  icu::CECalendar::jdToCE(a2, v4, &v12[1], v12, &v11, v5);
  int v6 = v12[1];
  *(_DWORD *)(a1 + 88) = v12[1];
  *(_DWORD *)(a1 + 208) = 1;
  *(_BYTE *)(a1 + 127) = 1;
  BOOL v7 = v6 > 0;
  *(_BYTE *)(a1 + 108) = 1;
  if (v6 <= 0) {
    v6 += 5500;
  }
  *(_DWORD *)(a1 + 12) = v7;
  *(_DWORD *)(a1 + 16) = v6;
  *(void *)&double result = 0x100000001LL;
  *(void *)(a1 + 132) = 0x100000001LL;
  *(_WORD *)(a1 + 109) = 257;
  int v10 = v11;
  int v9 = v12[0];
  *(_DWORD *)(a1 + 20) = v12[0];
  *(_DWORD *)(a1 + 140) = 1;
  *(_DWORD *)(a1 + 104) = v9;
  *(_DWORD *)(a1 + 224) = 1;
  *(_BYTE *)(a1 + 13sub_1808F7164((uint64_t)v14, 1) = 1;
  *(_BYTE *)(a1 + 113) = 1;
  *(_DWORD *)(a1 + 32) = v10;
  *(_DWORD *)(a1 + 36) = v10 + 30 * v9;
  *(void *)(a1 + 152) = 0x100000001LL;
  *(_BYTE *)(a1 + 114) = 1;
  return result;
}

uint64_t sub_1808F1DD0(_BYTE *a1, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(a1, 0x13u, a2) + 8;
  else {
    return 0LL;
  }
}

_BYTE *sub_1808F1E08(_BYTE *a1, int a2)
{
  return icu::Calendar::set(a1, 0x13u, a2 - 8);
}

double sub_1808F1E14()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_18C4493F0);
  if (v0 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C4493F0))
  {
    sub_1808F1E60();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C4493F0);
  }

  return *(double *)&qword_18C4483C8;
}

void sub_1808F1E60()
{
  v4[78] = *MEMORY[0x1895F89C0];
  UErrorCode v2 = U_ZERO_ERROR;
  bzero(v4, 0x270uLL);
  icu::Locale::Locale((icu::Locale *)v3, "@calendar=ethiopic", 0LL, 0LL, 0LL);
  icu::CECalendar::CECalendar((icu::CECalendar *)v4, v3, &v2);
  v4[0] = &off_189723668;
  icu::Locale::~Locale((icu::Locale *)v3);
  if (v2 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v4, v1, &v2);
    icu::Calendar::add(v4, 1u, -80, &v2);
    qword_18C4483C8 = icu::Calendar::getTimeInMillis((icu::Calendar *)v4, &v2);
    dword_18C4483D0 = icu::Calendar::get(v4, 1u, &v2);
  }

  icu::CECalendar::~CECalendar((icu::CECalendar *)v4);
}

uint64_t sub_1808F1F64()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_18C4493F0);
  if (v0 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C4493F0))
  {
    sub_1808F1E60();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C4493F0);
  }

  return dword_18C4483D0;
}

uint64_t sub_1808F1FB0()
{
  return 1723856LL;
}

icu::CECalendar *sub_1808F1FBC(icu::CECalendar *a1, char **a2, UErrorCode *a3)
{
  double result = icu::CECalendar::CECalendar(a1, a2, a3);
  *(void *)double result = &off_189723838;
  return result;
}

void sub_1808F1FE0(icu::CECalendar *a1)
{
}

icu::CECalendar *sub_1808F1FF4@<X0>( const icu::CECalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  double result = (icu::CECalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    double result = (icu::CECalendar *)icu::CECalendar::CECalendar(result, a1);
    *(void *)double result = &off_189723838;
  }

  return result;
}

const char *sub_1808F2030()
{
  return "ethiopic-amete-alem";
}

uint64_t sub_1808F203C(_DWORD *a1)
{
  if (icu::Calendar::newerField((uint64_t)a1, 0x13u, 1u) == 19)
  {
  }

  else if ((int)a1[34] >= 1)
  {
    return (a1[4] - 5500);
  }

  return 1LL;
}

double sub_1808F20A0(uint64_t a1, icu::CECalendar *a2)
{
  *(void *)int v11 = 0LL;
  int v10 = 0;
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 440LL))(a1);
  icu::CECalendar::jdToCE(a2, v4, &v11[1], v11, &v10, v5);
  int v6 = v11[1];
  *(_DWORD *)(a1 + 88) = v11[1];
  *(_DWORD *)(a1 + 208) = 1;
  *(_BYTE *)(a1 + 127) = 1;
  *(_BYTE *)(a1 + 108) = 1;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = v6 + 5500;
  *(void *)&double result = 0x100000001LL;
  *(void *)(a1 + 132) = 0x100000001LL;
  *(_WORD *)(a1 + 109) = 257;
  int v9 = v10;
  int v8 = v11[0];
  *(_DWORD *)(a1 + 20) = v11[0];
  *(_DWORD *)(a1 + 140) = 1;
  *(_DWORD *)(a1 + 104) = v8;
  *(_DWORD *)(a1 + 224) = 1;
  *(_BYTE *)(a1 + 13sub_1808F7164((uint64_t)v14, 1) = 1;
  *(_BYTE *)(a1 + 113) = 1;
  *(_DWORD *)(a1 + 32) = v9;
  *(_DWORD *)(a1 + 36) = v9 + 30 * v8;
  *(void *)(a1 + 152) = 0x100000001LL;
  *(_BYTE *)(a1 + 114) = 1;
  return result;
}

uint64_t sub_1808F2158(uint64_t a1, int a2, int a3)
{
  if (a2) {
    return icu::CECalendar::handleGetLimit(a1, a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1808F2168(_BYTE *a1, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(a1, 0x13u, a2) - 5492;
  else {
    return 0LL;
  }
}

_BYTE *sub_1808F21A4(_BYTE *a1, int a2)
{
  return icu::Calendar::set(a1, 0x13u, a2 + 5492);
}

uint64_t sub_1808F21B4()
{
  return sub_1808F1F64() + 5500;
}

void *icu::Formattable::getStaticClassID(icu::Formattable *this)
{
  return &unk_18C535418;
}

void *icu::Formattable::getDynamicClassID(icu::Formattable *this)
{
  return &unk_18C535418;
}

void icu::Formattable::init(icu::Formattable *this)
{
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  return this;
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  return this;
}

uint64_t icu::Formattable::Formattable(uint64_t a1, double a2)
{
  *(void *)(a1 + 48) = off_18971B688;
  *(_WORD *)(a1 + 56) = 2;
  *(void *)a1 = off_189723A38;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 40) = 2;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  icu::UnicodeString::setToBogus((icu::UnicodeString *)(a1 + 48));
  *(_DWORD *)(a1 + 40) = 0;
  *(double *)(a1 + 8) = a2;
  return a1;
}

{
  *(void *)(a1 + 48) = off_18971B688;
  *(_WORD *)(a1 + 56) = 2;
  *(void *)a1 = off_189723A38;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 40) = 2;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  icu::UnicodeString::setToBogus((icu::UnicodeString *)(a1 + 48));
  *(_DWORD *)(a1 + 40) = 0;
  *(double *)(a1 + 8) = a2;
  return a1;
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, double a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 1;
  *((double *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 1;
  *((double *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, int a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, uint64_t a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 5;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 5;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

uint64_t icu::Formattable::Formattable(uint64_t a1, const char *a2, int a3, UErrorCode *a4)
{
  *(void *)(a1 + 48) = off_18971B688;
  *(_WORD *)(a1 + 56) = 2;
  *(void *)a1 = off_189723A38;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 40) = 2;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  icu::UnicodeString::setToBogus((icu::UnicodeString *)(a1 + 48));
  icu::Formattable::setDecimalNumber((icu::Formattable *)a1, a2, a3, a4);
  return a1;
}

{
  *(void *)(a1 + 48) = off_18971B688;
  *(_WORD *)(a1 + 56) = 2;
  *(void *)a1 = off_189723A38;
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 40) = 2;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  icu::UnicodeString::setToBogus((icu::UnicodeString *)(a1 + 48));
  icu::Formattable::setDecimalNumber((icu::Formattable *)a1, a2, a3, a4);
  return a1;
}

void icu::Formattable::setDecimalNumber(icu::Formattable *a1, const char *a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    icu::Formattable::dispose(a1);
    int v10 = (icu::number::impl::DecimalQuantity *)icu::UMemory::operator new(v9, (icu::UMemory *)0x48, v8);
    int v11 = v10;
    if (v10) {
      icu::number::impl::DecimalQuantity::DecimalQuantity(v10);
    }
    icu::number::impl::DecimalQuantity::setToDecNumber((uint64_t)v11, a2, a3, a4);
    icu::Formattable::adoptDecimalQuantity(a1, v11);
  }

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, UChar **a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 3;
  uint64_t v5 = (icu::UnicodeString *)icu::UMemory::operator new((uint64_t *)3, (icu::UMemory *)0x40, v4);
  if (v5) {
    uint64_t v5 = icu::UnicodeString::UnicodeString(v5, a2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = v5;
  return this;
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, icu::UnicodeString *a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 3;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 3;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, icu::UObject *a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 6;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 6;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return this;
}

icu::Formattable *icu::Formattable::Formattable( icu::Formattable *this, const icu::Formattable *a2, unint64_t a3)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  *((_DWORD *)this + 10) = 4;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = sub_1808F29A8((uint64_t)a2, a3);
  *((_DWORD *)this + 4) = a3;
  return this;
}

void *sub_1808F29A8(uint64_t a1, unint64_t a2)
{
  LODWORD(v2) = a2;
  uint64_t v4 = (int)a2;
  BOOL v5 = !is_mul_ok((int)a2, 0x70uLL);
  uint64_t v6 = 112LL * (int)a2;
  BOOL v7 = __CFADD__(v6, 16LL);
  uint64_t v8 = v6 + 16;
  if (v7) {
    BOOL v5 = 1;
  }
  if (v5) {
    uint64_t v9 = -1LL;
  }
  else {
    uint64_t v9 = v8;
  }
  int v10 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v9, a2);
  if (!v10) {
    return 0LL;
  }
  *int v10 = 112LL;
  v10[1] = v4;
  int v11 = v10 + 2;
  if ((_DWORD)v2)
  {
    unint64_t v12 = &v11[14 * (int)v4];
    BOOL v13 = v10 + 2;
    do
    {
      v13[6] = off_18971B688;
      *((_WORD *)v13 + 28) = 2;
      *BOOL v13 = off_189723A38;
      v13[1] = 0LL;
      *((_DWORD *)v13 + 10) = 2;
      v13[3] = 0LL;
      _OWORD v13[4] = 0LL;
      icu::UnicodeString::setToBogus((icu::UnicodeString *)(v13 + 6));
      v13 += 14;
    }

    while (v13 != v12);
    if ((int)v2 >= 1)
    {
      uint64_t v2 = v2;
      uint64_t v14 = (uint64_t)v11;
      do
      {
        uint64_t v14 = icu::Formattable::operator=(v14, a1) + 112;
        a1 += 112LL;
        --v2;
      }

      while (v2);
    }
  }

  return v11;
}

uint64_t icu::Formattable::Formattable(icu::Formattable *this, const icu::Formattable *a2)
{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  return icu::Formattable::operator=((uint64_t)this, (uint64_t)a2);
}

{
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  *(void *)this = off_189723A38;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 10) = 2;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  icu::UnicodeString::setToBogus((icu::Formattable *)((char *)this + 48));
  return icu::Formattable::operator=((uint64_t)this, (uint64_t)a2);
}

uint64_t icu::Formattable::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    icu::Formattable::dispose((icu::Formattable *)a1);
    BOOL v5 = (uint64_t *)*(unsigned int *)(a2 + 40);
    *(_DWORD *)(a1 + 40) = (_DWORD)v5;
    switch((int)v5)
    {
      case 0:
      case 1:
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        break;
      case 2:
      case 5:
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        break;
      case 3:
        uint64_t v6 = (icu::UnicodeString *)icu::UMemory::operator new(v5, (icu::UMemory *)0x40, v4);
        if (v6) {
          uint64_t v6 = icu::UnicodeString::UnicodeString(v6, *(UChar ***)(a2 + 8));
        }
        goto LABEL_9;
      case 4:
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
        uint64_t v6 = (icu::UnicodeString *)sub_1808F29A8(*(void *)(a2 + 8), *(unsigned int *)(a2 + 16));
        goto LABEL_9;
      case 6:
        uint64_t v6 = (icu::UnicodeString *)(*(uint64_t (**)(void))(**(void **)(a2 + 8) + 24LL))(*(void *)(a2 + 8));
LABEL_9:
        *(void *)(a1 + 8) = v6;
        break;
      default:
        break;
    }

    UErrorCode v15 = U_ZERO_ERROR;
    BOOL v7 = *(uint64_t **)(a2 + 32);
    if (v7)
    {
      uint64_t v8 = (icu::number::impl::DecimalQuantity *)icu::UMemory::operator new(v7, (icu::UMemory *)0x48, v4);
      if (v8) {
        uint64_t v8 = icu::number::impl::DecimalQuantity::DecimalQuantity(v8, *(void *)(a2 + 32));
      }
      *(void *)(a1 + 32) = v8;
    }

    uint64_t v9 = *(uint64_t **)(a2 + 24);
    if (v9)
    {
      int v10 = icu::UMemory::operator new(v9, (icu::UMemory *)0x40, v4);
      if (!v10)
      {
        BOOL v13 = (void *)(a1 + 24);
LABEL_21:
        *BOOL v13 = 0LL;
        return a1;
      }

      int v11 = v10;
      uint64_t v12 = *(void *)(a2 + 24);
      *int v10 = (uint64_t)v10 + 13;
      *((_DWORD *)v10 + 2) = 40;
      *((_WORD *)v10 + 6) = 0;
      *((_DWORD *)v10 + 14) = 0;
      icu::CharString::append((icu::CharString *)v10, *(const char **)v12, *(_DWORD *)(v12 + 56), &v15);
      *(void *)(a1 + 24) = v11;
      BOOL v13 = (void *)(a1 + 24);
      if (v15 >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        if (*((_BYTE *)v11 + 12)) {
          uprv_free((void *)*v11);
        }
        icu::UMemory::operator delete(v11);
        goto LABEL_21;
      }
    }
  }

  return a1;
}

uint64_t icu::Formattable::dispose(icu::Formattable *this)
{
  int v2 = *((_DWORD *)this + 10);
  if (v2 == 6)
  {
LABEL_4:
    uint64_t v3 = *((void *)this + 1);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    goto LABEL_11;
  }

  if (v2 != 4)
  {
    if (v2 != 3) {
      goto LABEL_11;
    }
    goto LABEL_4;
  }

  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    BOOL v5 = (void *)(v4 - 16);
    uint64_t v6 = *(void *)(v4 - 8);
    if (v6)
    {
      uint64_t v7 = v4 - 112;
      uint64_t v8 = 112 * v6;
      do
      {
        icu::Formattable::~Formattable((icu::Formattable *)(v7 + v8));
        v8 -= 112LL;
      }

      while (v8);
    }

    icu::UMemory::operator delete[](v5);
  }

uint64_t icu::Formattable::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  int v4 = *(_DWORD *)(a1 + 40);
  if (v4 != *(_DWORD *)(a2 + 40)) {
    return 0LL;
  }
  switch(v4)
  {
    case 0:
    case 1:
      return *(double *)(a1 + 8) == *(double *)(a2 + 8);
    case 2:
    case 5:
      return *(void *)(a1 + 8) == *(void *)(a2 + 8);
    case 3:
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = *(void *)(a2 + 8);
      unsigned int v9 = *(unsigned __int16 *)(v7 + 8);
      if ((v9 & 1) != 0) {
        return *(_WORD *)(v8 + 8) & 1;
      }
      if ((v9 & 0x8000) != 0) {
        int v10 = *(_DWORD *)(v7 + 12);
      }
      else {
        int v10 = v9 >> 5;
      }
      uint64_t result = 0LL;
      unsigned int v15 = *(unsigned __int16 *)(v8 + 8);
      if ((v15 & 0x8000u) == 0) {
        unsigned int v16 = v15 >> 5;
      }
      else {
        unsigned int v16 = *(_DWORD *)(v8 + 12);
      }
      if ((v15 & 1) == 0 && v10 == v16) {
        return icu::UnicodeString::doEquals(*(icu::UnicodeString **)(a1 + 8), (const icu::UnicodeString *)v8, v10);
      }
      return result;
    case 4:
      int v11 = *(_DWORD *)(a1 + 16);
      if (v11 != *(_DWORD *)(a2 + 16)) {
        return 0LL;
      }
      if (v11 < 1) {
        return 1LL;
      }
      uint64_t v12 = 0LL;
      uint64_t v13 = 0LL;
      do
      {
        uint64_t result = icu::Formattable::operator==(*(void *)(a1 + 8) + v12, *(void *)(a2 + 8) + v12);
        if ((result & 1) == 0) {
          break;
        }
        ++v13;
        v12 += 112LL;
      }

      while (v13 < *(int *)(a1 + 16));
      return result;
    case 6:
      uint64_t result = *(void *)(a1 + 8);
      if (!result) {
        return result;
      }
      uint64_t v14 = *(void **)(a2 + 8);
      if (!v14) {
        return 0LL;
      }
      uint64_t result = icu::Measure::operator==((void *)result, v14);
      break;
    default:
      return 1LL;
  }

  return result;
}

void icu::Formattable::~Formattable(icu::Formattable *this)
{
  *(void *)this = off_189723A38;
  int v2 = (icu::Formattable *)((char *)this + 48);
  icu::Formattable::dispose(this);
  icu::UnicodeString::~UnicodeString(v3, v2);
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::Formattable::~Formattable(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::Formattable::clone@<X0>( icu::Formattable *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x70, a2);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    v4[6] = (uint64_t)off_18971B688;
    *((_WORD *)v4 + 28) = 2;
    *int v4 = (uint64_t)off_189723A38;
    v4[1] = 0LL;
    *((_DWORD *)v4 + 10) = 2;
    v4[3] = 0LL;
    v4[4] = 0LL;
    icu::UnicodeString::setToBogus((icu::UnicodeString *)(v4 + 6));
    icu::Formattable::operator=(v5, (uint64_t)this);
  }

  return v5;
}

uint64_t icu::Formattable::getType(icu::Formattable *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t icu::Formattable::isNumeric(icu::Formattable *this)
{
  unint64_t v1 = *((unsigned int *)this + 10);
  if (v1 >= 6) {
    char v2 = 0;
  }
  else {
    char v2 = 0x10000010100uLL >> (8 * v1);
  }
  return v2 & 1;
}

uint64_t icu::Formattable::getLong(icu::Formattable *this, UErrorCode *a2)
{
  while (1)
  {
    int v4 = *((_DWORD *)this + 10);
    if (v4 != 6) {
      break;
    }
    uint64_t v5 = *((void *)this + 1);
    if (!v5)
    {
      uint64_t result = 0LL;
      UErrorCode v7 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_18;
    }

    this = (icu::Formattable *)(v5 + 8);
    if (!v6) {
      goto LABEL_11;
    }
  }

  switch(v4)
  {
    case 1:
      double v8 = *((double *)this + 1);
      if (v8 > 2147483650.0)
      {
LABEL_16:
        *a2 = U_INVALID_FORMAT_ERROR;
        return 0x7FFFFFFFLL;
      }

      if (v8 >= -2147483650.0) {
        return (int)v8;
      }
LABEL_21:
      *a2 = U_INVALID_FORMAT_ERROR;
      return 0x80000000LL;
    case 5:
      uint64_t result = *((void *)this + 1);
      if (result >= 0x80000000LL) {
        goto LABEL_16;
      }
      goto LABEL_21;
    case 2:
      return *((unsigned int *)this + 2);
  }

uint64_t icu::Formattable::getInt64(icu::Formattable *this, UErrorCode *a2)
{
  while (1)
  {
    int v5 = *((_DWORD *)this + 10);
    if (v5 != 6) {
      break;
    }
    uint64_t v6 = *((void *)this + 1);
    if (!v6)
    {
      uint64_t result = 0LL;
      UErrorCode v9 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_18;
    }

    this = (icu::Formattable *)(v6 + 8);
    if (!v7) {
      goto LABEL_14;
    }
  }

  if (v5 != 1)
  {
    if (v5 == 5 || v5 == 2) {
      return *((void *)this + 1);
    }
LABEL_14:
    uint64_t result = 0LL;
    UErrorCode v9 = U_INVALID_FORMAT_ERROR;
LABEL_18:
    *a2 = v9;
    return result;
  }

  double v10 = *((double *)this + 1);
  if (v10 <= 9.22337204e18)
  {
    if (v10 >= -9.22337204e18)
    {
      if (fabs(v10) > 9.00719925e15 && (int v11 = (icu::number::impl::DecimalQuantity *)*((void *)this + 4)) != 0LL)
      {
        if (icu::number::impl::DecimalQuantity::fitsInLong(v11, 1))
        {
          return icu::number::impl::DecimalQuantity::toLong(*((icu::number::impl::DecimalQuantity **)this + 4), 0);
        }

        else
        {
          *a2 = U_INVALID_FORMAT_ERROR;
          if (icu::number::impl::DecimalQuantity::isNegative(*((icu::number::impl::DecimalQuantity **)this
                                                                            + 4)))
            return 0x8000000000000000LL;
          else {
            return 0x7FFFFFFFFFFFFFFFLL;
          }
        }
      }

      else
      {
        return (uint64_t)v10;
      }
    }

    else
    {
      *a2 = U_INVALID_FORMAT_ERROR;
      return 0x8000000000000000LL;
    }
  }

  else
  {
    *a2 = U_INVALID_FORMAT_ERROR;
    return 0x7FFFFFFFFFFFFFFFLL;
  }

double icu::Formattable::getDouble(icu::Formattable *this, UErrorCode *a2)
{
  double v2 = 0.0;
  if (*(int *)a2 <= 0)
  {
    while (1)
    {
      int v4 = *((_DWORD *)this + 10);
      if (v4 != 6) {
        break;
      }
      uint64_t v5 = *((void *)this + 1);
      if (!v5)
      {
        UErrorCode v8 = U_MEMORY_ALLOCATION_ERROR;
        goto LABEL_15;
      }

      this = (icu::Formattable *)(v5 + 8);
      if (!v6) {
        goto LABEL_13;
      }
    }

    if (v4 != 1)
    {
      if (v4 == 5 || v4 == 2) {
        return (double)*((uint64_t *)this + 1);
      }
LABEL_13:
      UErrorCode v8 = U_INVALID_FORMAT_ERROR;
LABEL_15:
      *a2 = v8;
      return v2;
    }

    return *((double *)this + 1);
  }

  return v2;
}

uint64_t icu::Formattable::getObject(icu::Formattable *this)
{
  if (*((_DWORD *)this + 10) == 6) {
    return *((void *)this + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t icu::Formattable::setDouble(icu::Formattable *this, double a2)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 1;
  *((double *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return result;
}

uint64_t icu::Formattable::setLong(icu::Formattable *this, int a2)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 2;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return result;
}

uint64_t icu::Formattable::setInt64(icu::Formattable *this, uint64_t a2)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 5;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return result;
}

uint64_t icu::Formattable::setDate(icu::Formattable *this, double a2)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 0;
  *((double *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return result;
}

icu::UnicodeString *icu::Formattable::setString(icu::Formattable *this, UChar **a2)
{
  *((_DWORD *)this + 10) = 3;
  uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new((uint64_t *)3, (icu::UMemory *)0x40, v4);
  if (result) {
    uint64_t result = icu::UnicodeString::UnicodeString(result, a2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = result;
  return result;
}

void *icu::Formattable::setArray(icu::Formattable *this, const icu::Formattable *a2, unint64_t a3)
{
  *((_DWORD *)this + 10) = 4;
  uint64_t result = sub_1808F29A8((uint64_t)a2, a3);
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = result;
  *((_DWORD *)this + 4) = a3;
  return result;
}

uint64_t icu::Formattable::adoptString(icu::Formattable *this, icu::UnicodeString *a2)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 3;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return result;
}

uint64_t icu::Formattable::adoptArray(icu::Formattable *this, icu::Formattable *a2, int a3)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 4;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  *((_DWORD *)this + 4) = a3;
  return result;
}

uint64_t icu::Formattable::adoptObject(icu::Formattable *this, icu::UObject *a2)
{
  uint64_t result = icu::Formattable::dispose(this);
  *((_DWORD *)this + 10) = 6;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = a2;
  return result;
}

UChar **icu::Formattable::getString(icu::Formattable *this, UChar **a2, UErrorCode *a3)
{
  if (*((_DWORD *)this + 10) == 3)
  {
    unint64_t v4 = (UChar **)*((void *)this + 1);
    if (v4)
    {
      icu::UnicodeString::operator=(a2, v4);
    }

    else if (*(int *)a3 <= 0)
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  else
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a2);
  }

  return a2;
}

uint64_t icu::Formattable::getString(icu::Formattable *this, UErrorCode *a2)
{
  if (*((_DWORD *)this + 10) != 3)
  {
    if (*(int *)a2 <= 0)
    {
      UErrorCode v3 = U_INVALID_FORMAT_ERROR;
      goto LABEL_7;
    }

    return (uint64_t)this + 48;
  }

  uint64_t v2 = *((void *)this + 1);
  if (!v2)
  {
    if (*(int *)a2 <= 0)
    {
      UErrorCode v3 = U_MEMORY_ALLOCATION_ERROR;
LABEL_7:
      *a2 = v3;
      return (uint64_t)this + 48;
    }

    return (uint64_t)this + 48;
  }

  return v2;
}

{
  uint64_t v2;
  UErrorCode v3;
  if (*((_DWORD *)this + 10) != 3)
  {
    if (*(int *)a2 <= 0)
    {
      UErrorCode v3 = U_INVALID_FORMAT_ERROR;
      goto LABEL_7;
    }

    return (uint64_t)this + 48;
  }

  uint64_t v2 = *((void *)this + 1);
  if (!v2)
  {
    if (*(int *)a2 <= 0)
    {
      UErrorCode v3 = U_MEMORY_ALLOCATION_ERROR;
LABEL_7:
      *a2 = v3;
      return (uint64_t)this + 48;
    }

    return (uint64_t)this + 48;
  }

  return v2;
}

uint64_t icu::Formattable::getBogus(icu::Formattable *this)
{
  return (uint64_t)this + 48;
}

uint64_t icu::Formattable::getArray(icu::Formattable *this, int *a2, UErrorCode *a3)
{
  if (*((_DWORD *)this + 10) == 4)
  {
    *a2 = *((_DWORD *)this + 4);
    return *((void *)this + 1);
  }

  else
  {
    uint64_t result = 0LL;
    *a2 = 0;
  }

  return result;
}

uint64_t icu::Formattable::getDecimalNumber(icu::Formattable *this, UErrorCode *a2)
{
  if (*(int *)a2 < 1)
  {
    uint64_t v2 = *((void *)this + 3);
    if (v2)
    {
      uint64_t v3 = *(void *)v2;
      uint64_t v4 = *(unsigned int *)(v2 + 56);
      uint64_t v8 = v3;
      uint64_t v9 = v4;
      return v8;
    }

    CharString = icu::Formattable::internalGetCharString(this, a2);
    if (CharString)
    {
      uint64_t v6 = *((unsigned int *)CharString + 14);
      uint64_t v8 = *CharString;
      uint64_t v9 = v6;
      return v8;
    }
  }

  icu::StringPiece::StringPiece((icu::StringPiece *)&v8, "");
  return v8;
}

uint64_t *icu::Formattable::internalGetCharString(icu::Formattable *this, UErrorCode *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 3)) {
    return (uint64_t *)*((void *)this + 3);
  }
  uint64_t v5 = (uint64_t *)*((void *)this + 4);
  if (!v5)
  {
    uint64_t v9 = (icu::number::impl::DecimalQuantity *)icu::UMemory::operator new( 0LL,  (icu::UMemory *)0x48,  (unint64_t)a2);
    if (v9)
    {
      double v10 = v9;
      icu::number::impl::DecimalQuantity::DecimalQuantity(v9);
      if (*(int *)a2 <= 0)
      {
        icu::Formattable::populateDecimalQuantity(this, v10, a2);
        uint64_t v5 = (uint64_t *)*(unsigned int *)a2;
        if ((int)v5 < 1)
        {
          *((void *)this + 4) = v10;
          goto LABEL_5;
        }
      }

      (*(void (**)(icu::number::impl::DecimalQuantity *))(*(void *)v10 + 8LL))(v10);
    }

    else if (*(int *)a2 <= 0)
    {
      uint64_t result = 0LL;
      goto LABEL_13;
    }

    return 0LL;
  }

void icu::Formattable::populateDecimalQuantity( icu::Formattable *this, icu::number::impl::DecimalQuantity *a2, UErrorCode *a3)
{
  uint64_t v4 = *((void *)this + 4);
  if (v4)
  {
    icu::number::impl::DecimalQuantity::operator=(a2, v4);
  }

  else
  {
    int v5 = *((_DWORD *)this + 10);
    switch(v5)
    {
      case 5:
        icu::number::impl::DecimalQuantity::setToLong((void **)a2, *((void *)this + 1));
        break;
      case 2:
        icu::number::impl::DecimalQuantity::setToInt((void **)a2, *((_DWORD *)this + 2));
        break;
      case 1:
        icu::number::impl::DecimalQuantity::setToDouble((void **)a2, *((double *)this + 1));
        icu::number::impl::DecimalQuantity::roundToInfinity(a2);
        break;
      default:
        *a3 = U_INVALID_STATE_ERROR;
        break;
    }
  }

void icu::Formattable::adoptDecimalQuantity(icu::Formattable *this, icu::number::impl::DecimalQuantity *a2)
{
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  *((void *)this + 4) = a2;
  if (a2)
  {
    if (icu::number::impl::DecimalQuantity::fitsInLong(a2, 0))
    {
      uint64_t v5 = icu::number::impl::DecimalQuantity::toLong(*((icu::number::impl::DecimalQuantity **)this + 4), 0);
      *((void *)this + sub_1808F7164((uint64_t)v14, 1) = v5;
      else {
        int v6 = 5;
      }
      *((_DWORD *)this + 10) = v6;
    }

    else
    {
      *((_DWORD *)this + 10) = 1;
      *((double *)this + sub_1808F7164((uint64_t)v14, 1) = icu::number::impl::DecimalQuantity::toDouble(*((icu::number::impl::DecimalQuantity **)this
                                                                           + 4));
    }
  }

uint64_t *ufmt_open(_DWORD *a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t *)*a1;
  uint64_t v5 = icu::UMemory::operator new(v2, (icu::UMemory *)0x70, a2);
  uint64_t v3 = v5;
  if (v5)
  {
    v5[6] = (uint64_t)off_18971B688;
    *((_WORD *)v5 + 28) = 2;
    *uint64_t v5 = (uint64_t)off_189723A38;
    v5[1] = 0LL;
    *((_DWORD *)v5 + 10) = 2;
    void v5[3] = 0LL;
    v5[4] = 0LL;
    icu::UnicodeString::setToBogus((icu::UnicodeString *)(v5 + 6));
  }

  else
  {
    *a1 = 7;
  }

  return v3;
}

uint64_t ufmt_close(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t ufmt_getType(uint64_t a1, int *a2)
{
  if (*a2 <= 0) {
    return *(unsigned int *)(a1 + 40);
  }
  else {
    return 7LL;
  }
}

uint64_t ufmt_isNumeric(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 40);
  if (v1 >= 6) {
    char v2 = 0;
  }
  else {
    char v2 = 0x10000010100uLL >> (8 * v1);
  }
  return v2 & 1;
}

uint64_t ufmt_getDate(uint64_t result, int *a2)
{
  if (*(_DWORD *)(result + 40))
  {
    if (*a2 <= 0) {
      *a2 = 3;
    }
  }

  return result;
}

uint64_t ufmt_getObject(uint64_t a1, int *a2)
{
  if (*(_DWORD *)(a1 + 40) == 6) {
    return *(void *)(a1 + 8);
  }
  uint64_t result = 0LL;
  if (*a2 <= 0) {
    *a2 = 3;
  }
  return result;
}

uint64_t ufmt_getUChars(uint64_t a1, int *a2, int *a3)
{
  if (*(_DWORD *)(a1 + 40) == 3)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = *a3;
    if (v4)
    {
      if (a2 && v5 <= 0)
      {
        else {
          int v6 = *(unsigned __int16 *)(v4 + 8) >> 5;
        }
        *a2 = v6;
      }
    }

    else
    {
      if (v5 <= 0) {
        *a3 = 7;
      }
      uint64_t v4 = a1 + 48;
    }

    return icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)v4);
  }

  else
  {
    if (*a3 <= 0) {
      *a3 = 3;
    }
    return 0LL;
  }

uint64_t ufmt_getArrayLength(uint64_t a1, int *a2)
{
  if (*(_DWORD *)(a1 + 40) == 4) {
    return *(unsigned int *)(a1 + 16);
  }
  uint64_t result = 0LL;
  if (*a2 <= 0) {
    *a2 = 3;
  }
  return result;
}

uint64_t ufmt_getArrayItemByIndex(uint64_t a1, unsigned int a2, int *a3)
{
  int v3 = *a3;
  if (*(_DWORD *)(a1 + 40) == 4)
  {
    if (v3 <= 0)
    {
      uint64_t result = 0LL;
      int v5 = 8;
      goto LABEL_10;
    }

    return 0LL;
  }

  if (v3 > 0) {
    return 0LL;
  }
  uint64_t result = 0LL;
  int v5 = 3;
LABEL_10:
  *a3 = v5;
  return result;
}

const char *ufmt_getDecNumChars(icu::Formattable *a1, _DWORD *a2, UErrorCode *a3)
{
  CharString = icu::Formattable::internalGetCharString(a1, a3);
  if (!CharString)
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
    return "";
  }

  if (a2) {
    *a2 = *((_DWORD *)CharString + 14);
  }
  return (const char *)*CharString;
}

icu::Formattable *icu::Formattable::Formattable(icu::Formattable *this, const char *a2)
{
  *(void *)this = off_189723A38;
  *((void *)this + 6) = off_18971B688;
  *((_WORD *)this + 28) = 2;
  icu::Formattable::init(this);
  *((_DWORD *)this + 10) = 3;
  int v5 = (icu::UnicodeString *)icu::UMemory::operator new((uint64_t *)3, (icu::UMemory *)0x40, v4);
  if (v5) {
    int v5 = (icu::UnicodeString *)icu::UnicodeString::UnicodeString(v5, a2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = v5;
  return this;
}

void *icu::FieldPosition::getStaticClassID(icu::FieldPosition *this)
{
  return &unk_18C535419;
}

void *icu::FieldPosition::getDynamicClassID(icu::FieldPosition *this)
{
  return &unk_18C535419;
}

void icu::FieldPosition::~FieldPosition(icu::FieldPosition *this)
{
}

double icu::FieldPosition::clone(icu::FieldPosition *this, unint64_t a2)
{
  uint64_t v3 = icu::UMemory::operator new((icu::UMemory *)0x18, a2);
  if (v3)
  {
    *(void *)uint64_t v3 = off_189723AC8;
    double result = *((double *)this + 1);
    *(double *)(v3 + 8) = result;
    *(_DWORD *)(v3 + 16) = *((_DWORD *)this + 4);
  }

  return result;
}

uint64_t icu::Format::Format(uint64_t this)
{
  *(void *)this = off_189723A78;
  *(_BYTE *)(this + 8) = 0;
  *(_BYTE *)(this + 165) = 0;
  return this;
}

uint64_t icu::Format::Format(uint64_t this, uint64_t a2)
{
  *(void *)this = off_189723A78;
  return icu::Format::operator=(this, a2);
}

uint64_t icu::Format::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    strcpy((char *)(a1 + 165), (const char *)(a2 + 165));
    strcpy((char *)(a1 + 8), (const char *)(a2 + 8));
  }

  return a1;
}

icu::UnicodeString *icu::Format::format( icu::Format *this, const icu::Formattable *a2, icu::UnicodeString *a3, UErrorCode *a4)
{
  unint64_t v4 = a3;
  if (*(int *)a4 <= 0)
  {
    v6[2] = 0LL;
    v6[0] = off_189723AC8;
    v6[1] = 0xFFFFFFFFLL;
    unint64_t v4 = (icu::UnicodeString *)(*(uint64_t (**)(icu::Format *, const icu::Formattable *, icu::UnicodeString *, void *, UErrorCode *))(*(void *)this + 40LL))( this,  a2,  a3,  v6,  a4);
    icu::UObject::~UObject((icu::UObject *)v6);
  }

  return v4;
}

uint64_t icu::Format::format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t result = a3;
  if (*a5 <= 0) {
    *a5 = 16;
  }
  return result;
}

void icu::Format::parseObject( icu::Format *this, const icu::UnicodeString *a2, icu::Formattable *a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    int v5 = off_18970F400;
    unint64_t v6 = 0xFFFFFFFF00000000LL;
    (*(void (**)(icu::Format *, const icu::UnicodeString *, icu::Formattable *, void (***)(icu::ParsePosition *__hidden)))(*(void *)this + 56LL))( this,  a2,  a3,  &v5);
    if (!(_DWORD)v6) {
      *a4 = U_INVALID_FORMAT_ERROR;
    }
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v5);
  }

BOOL icu::Format::operator==(void *a1, void *a2)
{
  if (!a1) {
    __cxa_bad_typeid();
  }
  return sub_1807F874C(*(void *)(*a1 - 8LL), *(void *)(*a2 - 8LL));
}

char *icu::Format::syntaxError(icu::Format *this, const icu::UnicodeString *a2, _DWORD *a3, UParseError *a4)
{
  int v5 = (int)a2;
  *a3 = 0;
  a3[1] = (_DWORD)a2;
  else {
    int v7 = 0;
  }
  int v8 = v5 - v7;
  uint64_t v9 = a3 + 2;
  icu::UnicodeString::doExtract((char *)this, v7, v5 - v7, (uint64_t)(a3 + 2), 0);
  *((_WORD *)v9 + v8) = 0;
  int v10 = v5 + 16;
  if (*((__int16 *)this + 4) < 0)
  {
    signed int v12 = *((_DWORD *)this + 3);
    if (v10 > v12) {
      goto LABEL_9;
    }
LABEL_8:
    signed int v12 = v5 + 15;
    goto LABEL_9;
  }

  unsigned int v11 = *((unsigned __int16 *)this + 4);
  signed int v12 = v11 >> 5;
LABEL_9:
  int v13 = v5 + 1;
  int v14 = v12 - (v5 + 1);
  uint64_t v15 = (uint64_t)(a3 + 10);
  uint64_t result = icu::UnicodeString::doExtract((char *)this, v13, v12 - v13, v15, 0);
  *(_WORD *)(v15 + 2LL * v14) = 0;
  return result;
}

uint64_t icu::Format::getLocale@<X0>(uint64_t a1@<X0>, int a2@<W1>, int *a3@<X2>, icu::Locale *a4@<X8>)
{
  v5[0] = (const char *)(a1 + 165);
  v5[1] = (const char *)(a1 + 8);
  return icu::LocaleBased::getLocale(v5, a2, a3, a4);
}

uint64_t icu::Format::getLocaleID(uint64_t a1, int a2, int *a3)
{
  v4[0] = a1 + 165;
  v4[1] = a1 + 8;
  return icu::LocaleBased::getLocaleID(v4, a2, a3);
}

char *icu::Format::setLocaleIDs(icu::Format *this, const char *a2, const char *a3)
{
  v4[0] = (char *)this + 165;
  v4[1] = (char *)this + 8;
  return icu::LocaleBased::setLocaleIDs((char *)v4, a2, a3);
}

double icu::FormattedStringBuilder::FormattedStringBuilder(icu::FormattedStringBuilder *this)
{
  *(_BYTE *)this = 0;
  *(void *)&double result = 20LL;
  *((void *)this + 16) = 20LL;
  return result;
}

{
  double result;
  *(_BYTE *)this = 0;
  *(void *)&double result = 20LL;
  *((void *)this + 16) = 20LL;
  return result;
}

void icu::FormattedStringBuilder::~FormattedStringBuilder(void **this)
{
  if (*(_BYTE *)this)
  {
    uprv_free(this[1]);
    uprv_free(this[11]);
  }

uint64_t icu::FormattedStringBuilder::FormattedStringBuilder(uint64_t this, uint64_t a2)
{
  *(_BYTE *)this = 0;
  *(void *)(this + 128) = 20LL;
  return icu::FormattedStringBuilder::operator=(this, a2);
}

{
  *(_BYTE *)this = 0;
  *(void *)(this + 128) = 20LL;
  return icu::FormattedStringBuilder::operator=(this, a2);
}

uint64_t icu::FormattedStringBuilder::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1 != a2)
  {
    if (*(_BYTE *)a1)
    {
      uprv_free(*(void **)(a1 + 8));
      uprv_free(*(void **)(a1 + 88));
      *(_BYTE *)a1 = 0;
    }

    if (!*(_BYTE *)a2)
    {
      int v5 = (void *)(a1 + 8);
      size_t v4 = 40LL;
      goto LABEL_16;
    }

    size_t v4 = *(unsigned int *)(a2 + 16);
    if ((int)v4 < 41)
    {
      if (!(_DWORD)v4)
      {
LABEL_25:
        *(void *)(a1 + 128) = *(void *)(a2 + 128);
        return a1;
      }

      size_t v4 = (int)v4;
      int v5 = (void *)(a1 + 8);
LABEL_16:
      if (*(_BYTE *)a2) {
        uint64_t v9 = *(const void **)(a2 + 8);
      }
      else {
        uint64_t v9 = (const void *)(a2 + 8);
      }
      memcpy(v5, v9, 2 * v4);
      int v10 = (void *)(a1 + 88);
      if (*(_BYTE *)a1) {
        int v10 = (void *)*v10;
      }
      if (*(_BYTE *)a2) {
        unsigned int v11 = *(const void **)(a2 + 88);
      }
      else {
        unsigned int v11 = (const void *)(a2 + 88);
      }
      memcpy(v10, v11, v4);
      goto LABEL_25;
    }

    int v5 = uprv_malloc(2 * v4);
    unint64_t v6 = uprv_malloc(v4);
    int v7 = v6;
    if (v5) {
      BOOL v8 = v6 == 0LL;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      *(_BYTE *)a1 = 1;
      *(_DWORD *)(a1 + 16) = v4;
      *(void *)(a1 + 8) = v5;
      *(_DWORD *)(a1 + 96) = v4;
      *(void *)(a1 + 88) = v6;
      goto LABEL_16;
    }

    uprv_free(v5);
    uprv_free(v7);
    v13[0] = 0;
    uint64_t v16 = 20LL;
    icu::FormattedStringBuilder::operator=(a1, v13);
    if (v13[0])
    {
      uprv_free(v14);
      uprv_free(v15);
    }
  }

  return a1;
}

uint64_t icu::FormattedStringBuilder::length(icu::FormattedStringBuilder *this)
{
  return *((unsigned int *)this + 33);
}

uint64_t icu::FormattedStringBuilder::codePointCount(icu::FormattedStringBuilder *this)
{
  unint64_t v1 = (const UChar *)((char *)this + 8);
  if (*(_BYTE *)this) {
    unint64_t v1 = *(const UChar **)v1;
  }
  return u_countChar32(&v1[*((int *)this + 32)], *((_DWORD *)this + 33));
}

uint64_t icu::FormattedStringBuilder::getFirstCodePoint(icu::FormattedStringBuilder *this)
{
  int v1 = *((_DWORD *)this + 33);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  char v2 = (char *)this + 8;
  if (*(_BYTE *)this) {
    char v2 = (char *)*((void *)this + 1);
  }
  uint64_t v3 = *((int *)this + 32);
  uint64_t result = *(unsigned __int16 *)&v2[2 * v3];
  if (v1 != 1 && (result & 0xFC00) == 55296)
  {
    int v6 = *(unsigned __int16 *)&v2[2 * v3 + 2];
    if ((v6 & 0xFC00) == 0xDC00) {
      return (v6 + ((_DWORD)result << 10) - 56613888);
    }
  }

  return result;
}

uint64_t icu::FormattedStringBuilder::getLastCodePoint(icu::FormattedStringBuilder *this)
{
  int v1 = *((_DWORD *)this + 33);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  char v2 = (char *)this + 8;
  int v3 = *(unsigned __int8 *)this;
  size_t v4 = (char *)this + 8;
  if (*(_BYTE *)this) {
    size_t v4 = *(char **)v2;
  }
  uint64_t v5 = *((int *)this + 32);
  int v6 = &v4[2 * v5];
  int v7 = v1 - 1;
  if (v1 >= 2 && (*(_WORD *)&v6[2 * v1 - 2] & 0xFC00) == 56320)
  {
    uint64_t v9 = (char *)this + 8;
    if (*(_BYTE *)this) {
      uint64_t v9 = *(char **)v2;
    }
  }

  int v10 = (char *)this + 8;
  if (*(_BYTE *)this) {
    int v10 = *(char **)v2;
  }
  uint64_t result = *(unsigned __int16 *)&v10[2 * v5 + 2 * v7];
  if ((result & 0xF800) == 0xD800)
  {
    if ((result & 0x400) != 0)
    {
      if (v7 >= 1)
      {
        if (v3) {
          char v2 = *(char **)v2;
        }
        int v15 = *(unsigned __int16 *)&v2[2 * v5 + 2 * (v7 - 1)];
        if ((v15 & 0xFC00) == 0xD800)
        {
          int v14 = result + (v15 << 10);
          return (v14 - 56613888);
        }
      }
    }

    else
    {
      uint64_t v12 = v7 + 1LL;
      if ((_DWORD)v12 != v1)
      {
        if (v3) {
          char v2 = *(char **)v2;
        }
        int v13 = *(unsigned __int16 *)&v2[2 * v5 + 2 * v12];
        if ((v13 & 0xFC00) == 0xDC00)
        {
          int v14 = v13 + ((_DWORD)result << 10);
          return (v14 - 56613888);
        }
      }
    }
  }

  return result;
}

uint64_t icu::FormattedStringBuilder::codePointAt(icu::FormattedStringBuilder *this, int a2)
{
  int v3 = (char *)this + 8;
  int v4 = *(unsigned __int8 *)this;
  uint64_t v5 = (char *)this + 8;
  if (*(_BYTE *)this) {
    uint64_t v5 = *(char **)v3;
  }
  uint64_t v6 = *((int *)this + 32);
  uint64_t result = *(unsigned __int16 *)&v5[2 * v6 + 2 * a2];
  if ((result & 0xF800) == 0xD800)
  {
    if ((result & 0x400) != 0)
    {
      if (a2 < 1) {
        return result;
      }
      if (v4) {
        int v3 = *(char **)v3;
      }
      int v12 = *(unsigned __int16 *)&v3[2 * v6 + 2 * (a2 - 1)];
      BOOL v10 = (v12 & 0xFC00) == 55296;
      int v11 = result + (v12 << 10);
    }

    else
    {
      uint64_t v8 = a2 + 1LL;
      if ((_DWORD)v8 == *((_DWORD *)this + 33)) {
        return result;
      }
      if (v4) {
        int v3 = *(char **)v3;
      }
      int v9 = *(unsigned __int16 *)&v3[2 * v6 + 2 * v8];
      BOOL v10 = (v9 & 0xFC00) == 56320;
      int v11 = v9 + ((_DWORD)result << 10);
    }

    unsigned int v13 = v11 - 56613888;
    if (v10) {
      return v13;
    }
    else {
      return result;
    }
  }

  return result;
}

uint64_t icu::FormattedStringBuilder::codePointBefore(icu::FormattedStringBuilder *this, int a2)
{
  char v2 = (char *)this + 8;
  int v3 = (char *)this + 8;
  if (*(_BYTE *)this) {
    int v3 = *(char **)v2;
  }
  uint64_t v4 = *((int *)this + 32);
  int v5 = a2 - 1;
  if (a2 >= 2 && (*(_WORD *)&v3[2 * v4 + 2 * v5] & 0xFC00) == 0xDC00)
  {
    uint64_t v6 = (char *)this + 8;
    if (*(_BYTE *)this) {
      uint64_t v6 = *(char **)v2;
    }
  }

  int v7 = (char *)this + 8;
  if (*(_BYTE *)this) {
    int v7 = *(char **)v2;
  }
  uint64_t v8 = *(unsigned __int16 *)&v7[2 * v4 + 2 * v5];
  if ((v8 & 0xF800) == 0xD800)
  {
    if ((v8 & 0x400) != 0)
    {
      BOOL v13 = __OFSUB__(v5, 1);
      int v14 = v5 - 1;
      if (v14 < 0 != v13) {
        return v8;
      }
      if (*(_BYTE *)this) {
        char v2 = *(char **)v2;
      }
      int v15 = *(unsigned __int16 *)&v2[2 * v4 + 2 * v14];
      BOOL v11 = (v15 & 0xFC00) == 55296;
      int v12 = v8 + (v15 << 10);
    }

    else
    {
      uint64_t v9 = v5 + 1LL;
      if ((_DWORD)v9 == *((_DWORD *)this + 33)) {
        return v8;
      }
      if (*(_BYTE *)this) {
        char v2 = *(char **)v2;
      }
      int v10 = *(unsigned __int16 *)&v2[2 * v4 + 2 * v9];
      BOOL v11 = (v10 & 0xFC00) == 56320;
      int v12 = v10 + ((_DWORD)v8 << 10);
    }

    unsigned int v16 = v12 - 56613888;
    if (v11) {
      return v16;
    }
    else {
      return v8;
    }
  }

  return v8;
}

uint64_t icu::FormattedStringBuilder::clear(uint64_t this)
{
  if (*(_BYTE *)this) {
    int v1 = *(_DWORD *)(this + 16) / 2;
  }
  else {
    int v1 = 20;
  }
  *(_DWORD *)(this + 128) = v1;
  *(_DWORD *)(this + 132) = 0;
  return this;
}

uint64_t icu::FormattedStringBuilder::insertCodePoint( void *a1, int a2, unsigned int a3, char a4, UErrorCode *a5)
{
  if (a3 < 0x10000) {
    uint64_t v9 = 1LL;
  }
  else {
    uint64_t v9 = 2LL;
  }
  int v10 = icu::FormattedStringBuilder::prepareForInsert((icu::FormattedStringBuilder *)a1, a2, v9, a5);
  if (*(int *)a5 <= 0)
  {
    if (HIWORD(a3))
    {
      int v13 = (a3 >> 10) - 10304;
      int v14 = a1 + 1;
      uint64_t v11 = v10;
      if (*(_BYTE *)a1)
      {
        *(_WORD *)(a1[1] + 2LL * v10) = v13;
        uint64_t v15 = v10 + 1LL;
        *(_WORD *)(a1[1] + 2 * v15) = a3 & 0x3FF | 0xDC00;
        int v12 = a1 + 11;
        unsigned int v16 = (void *)a1[11];
      }

      else
      {
        *((_WORD *)v14 + v10) = v13;
        uint64_t v15 = v10 + 1LL;
        *((_WORD *)v14 + v15) = a3 & 0x3FF | 0xDC00;
        int v12 = a1 + 11;
        unsigned int v16 = a1 + 11;
      }

      *((_BYTE *)v16 + v15) = a4;
      if (*(_BYTE *)a1) {
        int v12 = (void *)*v12;
      }
    }

    else
    {
      uint64_t v11 = v10;
      if (*(_BYTE *)a1)
      {
        *(_WORD *)(a1[1] + 2LL * v10) = a3;
        int v12 = (void *)a1[11];
      }

      else
      {
        *((_WORD *)a1 + v10 + 4) = a3;
        int v12 = a1 + 11;
      }
    }

    *((_BYTE *)v12 + v1sub_1808F7164((uint64_t)v14, 1) = a4;
  }

  return v9;
}

uint64_t icu::FormattedStringBuilder::prepareForInsert( icu::FormattedStringBuilder *this, int a2, uint64_t a3, UErrorCode *a4)
{
  if (a2 || (uint64_t v4 = (*((_DWORD *)this + 32) - a3), (int)v4 < 0))
  {
    if (*((_DWORD *)this + 33) != a2) {
      return icu::FormattedStringBuilder::prepareForInsertHelper(this, a2, a3, a4);
    }
    int v5 = *(_BYTE *)this ? *((_DWORD *)this + 4) : 40;
    uint64_t v4 = (*((_DWORD *)this + 32) + a2);
    int v6 = a2 + a3;
  }

  else
  {
    int v6 = *((_DWORD *)this + 33) + a3;
    *((_DWORD *)this + 32) = v4;
  }

  *((_DWORD *)this + 33) = v6;
  return v4;
}

uint64_t icu::FormattedStringBuilder::insert( icu::FormattedStringBuilder *a1, int a2, uint64_t a3, char a4, int a5, UErrorCode *a6)
{
  unsigned int v7 = *(unsigned __int16 *)(a3 + 8);
  if (*(__int16 *)(a3 + 8) < 0)
  {
    int v8 = *(_DWORD *)(a3 + 12);
    if (v8)
    {
      if (v8 != 1 || (a5 & 1) != 0) {
        return icu::FormattedStringBuilder::insert(a1, a2, a3, 0, v8, a4, a5, a6);
      }
      goto LABEL_9;
    }

    return 0LL;
  }

  if (v7 < 0x20) {
    return 0LL;
  }
  if ((v7 & 0xFFE0) != 0x20 || (a5 & 1) != 0)
  {
    int v8 = v7 >> 5;
    return icu::FormattedStringBuilder::insert(a1, a2, a3, 0, v8, a4, a5, a6);
  }

uint64_t icu::FormattedStringBuilder::insert( icu::FormattedStringBuilder *a1, int a2, uint64_t a3, unsigned int a4, int a5, char a6, int a7, UErrorCode *a8)
{
  unsigned int v11 = a4;
  uint64_t v14 = a5 - a4;
  if (a7) {
    int v15 = 2;
  }
  else {
    int v15 = 0;
  }
  uint64_t v16 = (v15 + v14);
  int v17 = icu::FormattedStringBuilder::prepareForInsert(a1, a2, v16, a8);
  if (*(int *)a8 <= 0)
  {
    if (a7)
    {
      if (*(_BYTE *)a1)
      {
        *(_WORD *)(*((void *)a1 + 1) + 2LL * v17) = 8296;
        int v18 = (void *)*((void *)a1 + 11);
      }

      else
      {
        *((_WORD *)a1 + v17 + 4) = 8296;
        int v18 = (void *)((char *)a1 + 88);
      }

      *((_BYTE *)v18 + v17++) = a6;
    }

    if ((int)v14 >= 1)
    {
      uint64_t v19 = 0LL;
      uint64_t v20 = 2LL * (int)v11;
      uint64_t v21 = v14;
      uint64_t v22 = v17;
      do
      {
        unsigned int v23 = *(unsigned __int16 *)(a3 + 8);
        if ((v23 & 0x8000u) == 0) {
          unsigned int v24 = v23 >> 5;
        }
        else {
          unsigned int v24 = *(_DWORD *)(a3 + 12);
        }
        if (v24 <= v11)
        {
          __int16 v26 = -1;
        }

        else
        {
          if ((v23 & 2) != 0) {
            uint64_t v25 = a3 + 10;
          }
          else {
            uint64_t v25 = *(void *)(a3 + 24);
          }
          __int16 v26 = *(_WORD *)(v25 + v20);
        }

        if (*(_BYTE *)a1)
        {
          *(_WORD *)(*((void *)a1 + 1) + 2 * v22) = v26;
          unsigned int v27 = (void *)*((void *)a1 + 11);
          uint64_t v28 = v22;
        }

        else
        {
          uint64_t v28 = v19 + v17;
          *((_WORD *)a1 + v22 + 4) = v26;
          unsigned int v27 = (void *)((char *)a1 + 88);
        }

        *((_BYTE *)v27 + v28) = a6;
        ++v19;
        ++v22;
        v20 += 2LL;
        ++v11;
        --v21;
      }

      while (v21);
    }

    if ((a7 & 1) != 0)
    {
      uint64_t v29 = v17 + (uint64_t)(int)v14;
      if (*(_BYTE *)a1)
      {
        *(_WORD *)(*((void *)a1 + 1) + 2 * v29) = 8297;
        int v30 = (void *)*((void *)a1 + 11);
      }

      else
      {
        *((_WORD *)a1 + v29 + 4) = 8297;
        int v30 = (void *)((char *)a1 + 88);
      }

      *((_BYTE *)v30 + v29) = a6;
    }
  }

  return v16;
}

uint64_t icu::FormattedStringBuilder::splice( icu::FormattedStringBuilder *this, int a2, int a3, uint64_t a4, unsigned int a5, int a6, char a7, UErrorCode *a8)
{
  uint64_t v8 = a6 - a5;
  uint64_t v9 = (v8 + a2 - a3);
  if (*(int *)a8 <= 0)
  {
    unsigned int v12 = a5;
    int v15 = (int)v9 < 1
    if (*(int *)a8 <= 0 && (int)v8 >= 1)
    {
      uint64_t v17 = 0LL;
      uint64_t v18 = 2LL * (int)v12;
      uint64_t v19 = v15;
      do
      {
        unsigned int v20 = *(unsigned __int16 *)(a4 + 8);
        if ((v20 & 0x8000u) == 0) {
          unsigned int v21 = v20 >> 5;
        }
        else {
          unsigned int v21 = *(_DWORD *)(a4 + 12);
        }
        if (v21 <= v12)
        {
          __int16 v23 = -1;
        }

        else
        {
          if ((v20 & 2) != 0) {
            uint64_t v22 = a4 + 10;
          }
          else {
            uint64_t v22 = *(void *)(a4 + 24);
          }
          __int16 v23 = *(_WORD *)(v22 + v18);
        }

        if (*(_BYTE *)this)
        {
          *(_WORD *)(*((void *)this + 1) + 2 * v19) = v23;
          unsigned int v24 = (char *)*((void *)this + 11);
          uint64_t v25 = v19;
        }

        else
        {
          uint64_t v25 = v17 + v15;
          *((_WORD *)this + v19 + 4) = v23;
          unsigned int v24 = (char *)this + 88;
        }

        v24[v25] = a7;
        ++v17;
        ++v19;
        v18 += 2LL;
        ++v12;
        --v8;
      }

      while (v8);
    }
  }

  return v9;
}

uint64_t icu::FormattedStringBuilder::remove(icu::FormattedStringBuilder *this, int a2, int a3)
{
  uint64_t v5 = *((int *)this + 32) + (uint64_t)a2;
  int v6 = *(unsigned __int8 *)this;
  unsigned int v7 = (void *)((char *)this + 8);
  if (*(_BYTE *)this)
  {
    unsigned int v7 = (void *)*v7;
    uint64_t v8 = (int)v5;
    uint64_t v9 = (char *)v7 + 2 * (int)v5;
  }

  else
  {
    uint64_t v9 = (char *)v7 + 2 * v5;
    uint64_t v8 = v5;
  }

  int v10 = a3 + a2;
  int v11 = *((_DWORD *)this + 33) - (a3 + a2);
  if (v11)
  {
    memmove(v9, (char *)v7 + 2 * v8 + 2 * a3, 2LL * v11);
    int v6 = *(unsigned __int8 *)this;
  }

  unsigned int v12 = (void *)((char *)this + 88);
  if (v6) {
    unsigned int v12 = (void *)*v12;
  }
  int v13 = *((_DWORD *)this + 33) - v10;
  if (v13)
  {
    memmove((char *)v12 + v8, (char *)v12 + v8 + a3, v13);
    int v10 = *((_DWORD *)this + 33);
  }

  *((_DWORD *)this + 33) = v10 - a3;
  return v5;
}

uint64_t icu::FormattedStringBuilder::append( icu::FormattedStringBuilder *this, const icu::FormattedStringBuilder *a2, UErrorCode *a3)
{
  return icu::FormattedStringBuilder::insert(this, *((_DWORD *)this + 33), a2, a3);
}

uint64_t icu::FormattedStringBuilder::insert( icu::FormattedStringBuilder *this, int a2, const icu::FormattedStringBuilder *a3, UErrorCode *a4)
{
  if (this == a3)
  {
    uint64_t v4 = 0LL;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  else
  {
    uint64_t v4 = *((unsigned int *)a3 + 33);
    if ((_DWORD)v4)
    {
      int v9 = icu::FormattedStringBuilder::prepareForInsert(this, a2, *((unsigned int *)a3 + 33), a4);
      if (*(int *)a4 <= 0 && (int)v4 >= 1)
      {
        uint64_t v10 = 0LL;
        int v11 = (char **)((char *)a3 + 88);
        uint64_t v12 = v9;
        do
        {
          int v13 = *(unsigned __int8 *)a3;
          if (*(_BYTE *)a3) {
            uint64_t v14 = (char *)*((void *)a3 + 1);
          }
          else {
            uint64_t v14 = (char *)a3 + 8;
          }
          uint64_t v15 = *((int *)a3 + 32);
          __int16 v16 = *(_WORD *)&v14[2 * v10 + 2 * v15];
          if (*(_BYTE *)this)
          {
            uint64_t v17 = v10 + v9;
            *(_WORD *)(*((void *)this + 1) + 2 * v12) = v16;
            if (v13) {
              uint64_t v18 = *v11;
            }
            else {
              uint64_t v18 = (char *)a3 + 88;
            }
            uint64_t v19 = (char *)*((void *)this + 11);
          }

          else
          {
            *((_WORD *)this + v12 + 4) = v16;
            if (v13) {
              uint64_t v18 = *v11;
            }
            else {
              uint64_t v18 = (char *)a3 + 88;
            }
            uint64_t v17 = v12;
            uint64_t v19 = (char *)this + 88;
          }

          v19[v17] = v18[v15 + v10++];
          ++v12;
        }

        while (v4 != v10);
      }
    }
  }

  return v4;
}

uint64_t icu::FormattedStringBuilder::writeTerminator(icu::FormattedStringBuilder *this, UErrorCode *a2)
{
  uint64_t result = icu::FormattedStringBuilder::prepareForInsert(this, *((_DWORD *)this + 33), 1LL, a2);
  if (*(int *)a2 <= 0)
  {
    if (*(_BYTE *)this)
    {
      *(_WORD *)(*((void *)this + 1) + 2LL * (int)result) = 0;
      uint64_t v5 = (char *)*((void *)this + 11);
    }

    else
    {
      *((_WORD *)this + (int)result + 4) = 0;
      uint64_t v5 = (char *)this + 88;
    }

    v5[(int)result] = 0;
    --*((_DWORD *)this + 33);
  }

  return result;
}

uint64_t icu::FormattedStringBuilder::prepareForInsertHelper( icu::FormattedStringBuilder *this, int a2, int a3, UErrorCode *a4)
{
  if (*(_BYTE *)this)
  {
    int v8 = *((_DWORD *)this + 4);
    int v9 = (char *)*((void *)this + 1);
    uint64_t v10 = (char *)*((void *)this + 11);
  }

  else
  {
    int v9 = (char *)this + 8;
    uint64_t v10 = (char *)this + 88;
    int v8 = 40;
  }

  int v39 = 0;
  uint64_t v11 = *((int *)this + 32);
  if (uprv_add32_overflow(*((_DWORD *)this + 33), a3, &v39)) {
    goto LABEL_5;
  }
  int v14 = v39;
  int v15 = v8 - v39;
  if (v8 >= v39)
  {
    if (v15 >= 0) {
      int v29 = v8 - v39;
    }
    else {
      int v29 = v15 + 1;
    }
    int v21 = v29 >> 1;
    uint64_t v30 = *((int *)this + 33);
    if ((_DWORD)v30)
    {
      memmove(&v9[2 * v21], &v9[2 * v11], 2 * v30);
      LODWORD(v30) = *((_DWORD *)this + 33);
    }

    int v31 = a2;
    int v32 = v30 - a2;
    if (v32)
    {
      memmove(&v9[2 * (v29 >> 1) + 2 * a2 + 2 * a3], &v9[2 * (v29 >> 1) + 2 * a2], 2LL * v32);
      int v31 = *((_DWORD *)this + 33);
    }

    uint64_t v33 = &v10[(uint64_t)v29 >> 1];
    if (v31)
    {
      memmove(v33, &v10[v11], v31);
      int v34 = *((_DWORD *)this + 33);
    }

    else
    {
      int v34 = 0;
    }

    int v35 = v34 - a2;
    if (v35) {
      memmove(&v33[a2 + a3], &v33[a2], v35);
    }
  }

  else
  {
    if (v39 >= 0x40000000)
    {
LABEL_5:
      UErrorCode v12 = U_STANDARD_ERROR_LIMIT;
LABEL_6:
      *a4 = v12;
      return 0xFFFFFFFFLL;
    }

    size_t v16 = 2LL * v39;
    if (v39 >= 0) {
      int v17 = v39;
    }
    else {
      int v17 = v39 + 1;
    }
    uint64_t v18 = (char *)uprv_malloc(4LL * v39);
    int v38 = v16;
    uint64_t v19 = (char *)uprv_malloc(v16);
    unsigned int v20 = v19;
    if (!v18 || !v19)
    {
      uprv_free(v18);
      uprv_free(v20);
      UErrorCode v12 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_6;
    }

    unsigned int v36 = v19;
    int v21 = v17 >> 1;
    size_t v22 = a2;
    if (a2)
    {
      memcpy(&v18[2 * v21], &v9[2 * v11], 2LL * a2);
      size_t v22 = a2;
    }

    uint64_t v23 = v21;
    uint64_t v24 = a3;
    int v25 = *((_DWORD *)this + 33);
    size_t v26 = v25 - a2;
    uint64_t v37 = v24;
    if (v25 != a2)
    {
      memcpy(&v18[2 * v21 + 2 * v22 + 2 * v24], &v9[2 * v11 + 2 * v22], 2LL * (v25 - a2));
      uint64_t v23 = v21;
      size_t v26 = v25 - a2;
      size_t v22 = a2;
      uint64_t v24 = v37;
    }

    unsigned int v27 = &v36[v23];
    uint64_t v28 = &v10[v11];
    if (a2)
    {
      memcpy(&v36[v23], v28, v22);
      size_t v26 = v25 - a2;
      size_t v22 = a2;
      uint64_t v24 = v37;
    }

    if (v25 != a2) {
      memcpy(&v27[v22 + v24], &v28[v22], v26);
    }
    if (*(_BYTE *)this)
    {
      uprv_free(v9);
      uprv_free(v10);
    }

    *(_BYTE *)this = 1;
    *((void *)this + sub_1808F7164((uint64_t)v14, 1) = v18;
    *((_DWORD *)this + 4) = v38;
    *((void *)this + 1sub_1808F7164((uint64_t)v14, 1) = v36;
    *((_DWORD *)this + 24) = v38;
    int v14 = v39;
  }

  *((_DWORD *)this + 32) = v21;
  *((_DWORD *)this + 33) = v14;
  return (v21 + a2);
}

uint64_t icu::FormattedStringBuilder::toUnicodeString@<X0>( icu::FormattedStringBuilder *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (void *)((char *)this + 8);
  if (*(_BYTE *)this) {
    uint64_t v4 = (void *)*v4;
  }
  return icu::UnicodeString::UnicodeString(a2, (uint64_t)v4 + 2 * *((int *)this + 32), *((unsigned int *)this + 33));
}

uint64_t icu::FormattedStringBuilder::toTempUnicodeString@<X0>( icu::FormattedStringBuilder *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (void *)((char *)this + 8);
  if (*(_BYTE *)this) {
    uint64_t v4 = (void *)*v4;
  }
  int v6 = (char *)v4 + 2 * *((int *)this + 32);
  return icu::UnicodeString::UnicodeString(a2, 0LL, &v6);
}

uint64_t icu::FormattedStringBuilder::toDebugString@<X0>( icu::FormattedStringBuilder *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  icu::UnicodeString::doAppend(a2, (uint64_t)"<", 0, 0xFFFFFFFFLL);
  uint64_t v4 = (void *)((char *)this + 8);
  if (*(_BYTE *)this) {
    uint64_t v4 = (void *)*v4;
  }
  icu::UnicodeString::UnicodeString((uint64_t)&v16, (uint64_t)v4 + 2 * *((int *)this + 32), *((unsigned int *)this + 33));
  if ((v17 & 0x8000u) == 0) {
    uint64_t v5 = v17 >> 5;
  }
  else {
    uint64_t v5 = v18;
  }
  icu::UnicodeString::doAppend(a2, (const icu::UnicodeString *)&v16, 0, v5);
  icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v16);
  icu::UnicodeString::doAppend(a2, (uint64_t)"]", 0, 0xFFFFFFFFLL);
  if (*((int *)this + 33) >= 1)
  {
    for (uint64_t i = 0LL; (int)i < *((_DWORD *)this + 33); ++i)
    {
      if (*(_BYTE *)this)
      {
        uint64_t v8 = *((int *)this + 32);
        unsigned int v9 = *(unsigned __int8 *)(*((void *)this + 11) + v8 + i);
        if (!*(_BYTE *)(*((void *)this + 11) + v8 + i)) {
          goto LABEL_17;
        }
        if ((v9 & 0xF0) == 0x20)
        {
          uint64_t v10 = v8 + (int)i;
          goto LABEL_15;
        }
      }

      else
      {
        uint64_t v11 = *((int *)this + 32);
        unsigned int v9 = *((unsigned __int8 *)this + i + v11 + 88);
        if (!*((_BYTE *)this + i + v11 + 88))
        {
LABEL_17:
          __int16 v16 = 110;
          goto LABEL_23;
        }

        if ((v9 & 0xF0) == 0x20)
        {
          uint64_t v10 = i + v11;
LABEL_15:
          unsigned int v12 = v9 & 0xF;
          if (v12 >= 0xB)
          {
            int v14 = (char *)this + 88;
            if (*(_BYTE *)this) {
              int v14 = (char *)*((void *)this + 11);
            }
            __int16 v13 = v14[v10] & 0xF | 0x30;
          }

          else
          {
            __int16 v13 = aIfEE[v12];
          }

          __int16 v16 = v13;
LABEL_23:
          icu::UnicodeString::doAppend(a2, (uint64_t)&v16, 0, 1LL);
          continue;
        }
      }

      icu::UnicodeString::append(a2, (v9 >> 4) | 0x30);
    }
  }

  return icu::UnicodeString::doAppend(a2, (uint64_t)"]", 0, 0xFFFFFFFFLL);
}

uint64_t icu::FormattedStringBuilder::chars(icu::FormattedStringBuilder *this)
{
  int v1 = (void *)((char *)this + 8);
  if (*(_BYTE *)this) {
    int v1 = (void *)*v1;
  }
  return (uint64_t)v1 + 2 * *((int *)this + 32);
}

BOOL icu::FormattedStringBuilder::contentEquals( icu::FormattedStringBuilder *this, const icu::FormattedStringBuilder *a2)
{
  unint64_t v2 = *((unsigned int *)this + 33);
  if ((_DWORD)v2 == *((_DWORD *)a2 + 33))
  {
    if ((int)v2 < 1)
    {
      return 1;
    }

    else
    {
      uint64_t v3 = 0LL;
      BOOL v4 = 0;
      int v5 = *(unsigned __int8 *)this;
      int v6 = (void *)((char *)this + 8);
      uint64_t v7 = *((int *)this + 32);
      BOOL v8 = *(_BYTE *)a2 == 0;
      if (*(_BYTE *)a2) {
        unsigned int v9 = (char *)*((void *)a2 + 1);
      }
      else {
        unsigned int v9 = (char *)a2 + 8;
      }
      uint64_t v10 = *((int *)a2 + 32);
      uint64_t v11 = (void *)((char *)this + 88);
      int v14 = (char *)*((void *)a2 + 11);
      unsigned int v12 = (char *)a2 + 88;
      __int16 v13 = v14;
      if (v8) {
        __int16 v13 = v12;
      }
      uint64_t v15 = *((int *)this + 32);
      uint64_t v16 = v10;
      do
      {
        if (v5)
        {
          unsigned __int16 v17 = (void *)*v11;
          uint64_t v18 = v15;
          uint64_t v19 = v16;
        }

        else
        {
          uint64_t v18 = v3 + v7;
          uint64_t v19 = v3 + v10;
          unsigned __int16 v17 = v11;
        }

        BOOL v4 = ++v3 >= v2;
        ++v16;
        ++v15;
      }

      while (v2 != v3);
    }
  }

  else
  {
    return 0;
  }

  return v4;
}

BOOL icu::FormattedStringBuilder::containsField(uint64_t a1, unsigned __int8 a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 132);
  if ((int)v2 < 1)
  {
    return 0;
  }

  else
  {
    uint64_t v3 = 0LL;
    BOOL v4 = 1;
    do
    {
      uint64_t v5 = a1 + 88;
      if (*(_BYTE *)a1) {
        uint64_t v5 = *(void *)(a1 + 88);
      }
      BOOL v4 = ++v3 < v2;
    }

    while (v2 != v3);
  }

  return v4;
}

uint64_t sub_1808F5480(uint64_t a1, int a2, UErrorCode *a3)
{
  *(void *)a1 = off_189723B20;
  *(void *)(a1 + 8) = off_18971B688;
  *(_WORD *)(a1 + 16) = 2;
  icu::UVector32::UVector32((icu::UVector32 *)(a1 + 72), 4 * a2, a3);
  return a1;
}

void sub_1808F54CC(void **a1)
{
  *a1 = off_189723B20;
  unint64_t v2 = (icu::UnicodeString *)(a1 + 1);
  icu::UVector32::~UVector32(a1 + 9);
  icu::UnicodeString::~UnicodeString(v3, v2);
  icu::FormattedValue::~FormattedValue((icu::FormattedValue *)a1);
}

void sub_1808F5510(void **a1)
{
}

icu::UnicodeString *sub_1808F5524@<X0>(uint64_t a1@<X0>, icu::UnicodeString *a2@<X8>)
{
  return icu::UnicodeString::UnicodeString(a2, (UChar **)(a1 + 8));
}

uint64_t sub_1808F5530@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int16 v4 = *(_WORD *)(a1 + 16);
  if ((v4 & 0x11) != 0)
  {
    uint64_t v5 = 0LL;
  }

  else if ((v4 & 2) != 0)
  {
    uint64_t v5 = a1 + 18;
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
  }

  uint64_t v7 = v5;
  return icu::UnicodeString::UnicodeString(a2, 1LL, &v7);
}

uint64_t sub_1808F55A4(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int16 *)(a1 + 16);
  if ((v3 & 0x11) == 0)
  {
    if ((v3 & 2) != 0)
    {
      uint64_t v4 = a1 + 18;
      if ((v3 & 0x8000) == 0) {
        goto LABEL_6;
      }
    }

    else
    {
      uint64_t v4 = *(void *)(a1 + 32);
      if ((v3 & 0x8000) == 0) {
        goto LABEL_6;
      }
    }

BOOL sub_1808F5610(uint64_t a1, icu::ConstrainedFieldPosition *this)
{
  int v3 = *(_DWORD *)(a1 + 80) / 4;
  int v4 = *(_DWORD *)this;
  if (v3 <= *(_DWORD *)this)
  {
    BOOL v7 = 0;
  }

  else
  {
    int v6 = (4 * v4) | 3;
    BOOL v7 = 1;
    while (1)
    {
      if (v4 < 0 || ((int v8 = v6 - 3, v9 = *(_DWORD *)(a1 + 80), v9 >= 1) ? (v10 = v9 <= v8) : (v10 = 1), v10)) {
        int v11 = 0;
      }
      else {
        int v11 = *(_DWORD *)(*(void *)(a1 + 96) + 4LL * v8);
      }
      int v12 = v6 - 2;
      if (v6 - 2 < 0 || ((int v13 = *(_DWORD *)(a1 + 80), v13 >= 1) ? (v14 = v13 <= v12) : (v14 = 1), v14)) {
        int v15 = 0;
      }
      else {
        int v15 = *(_DWORD *)(*(void *)(a1 + 96) + 4LL * v12);
      }
      if (icu::ConstrainedFieldPosition::matchesField(this, v11, v15)) {
        break;
      }
      BOOL v7 = ++v4 < v3;
      v6 += 4;
      if (v3 == v4)
      {
        int v4 = v3;
        goto LABEL_30;
      }
    }

    int v16 = 0;
    int v17 = v6 - 1;
    if (v6 - 1 >= 0)
    {
      int v18 = *(_DWORD *)(a1 + 80);
      if (v18 >= 1 && v18 > v17) {
        int v16 = *(_DWORD *)(*(void *)(a1 + 96) + 4LL * v17);
      }
    }

    int v19 = 0;
    if ((v6 & 0x80000000) == 0)
    {
      int v20 = *(_DWORD *)(a1 + 80);
      if (v20 >= 1 && v20 > v6) {
        int v19 = *(_DWORD *)(*(void *)(a1 + 96) + 4LL * v6);
      }
    }

    icu::ConstrainedFieldPosition::setState(this, v11, v15, v16, v19);
  }

uint64_t sub_1808F5774@<X0>(UErrorCode *a1@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  return icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler(a3, (icu::UVector32 *)(a2 + 72), a1);
}

uint64_t sub_1808F5784(uint64_t result, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
  {
    int v4 = (icu::UnicodeString *)(result + 8);
    unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
    int v6 = (__int16)v5;
    unsigned int v7 = v5 >> 5;
    if (v6 >= 0) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = *(unsigned int *)(a2 + 12);
    }
    icu::UnicodeString::doAppend(result + 8, (const icu::UnicodeString *)a2, 0, v8);
    uint64_t result = icu::UnicodeString::getTerminatedBuffer(v4);
    if (!result) {
      *a3 = 7;
    }
  }

  return result;
}

uint64_t sub_1808F57E8(uint64_t result, int a2, int a3, UErrorCode *a4)
{
  unint64_t v4 = *(unsigned int *)(result + 80);
  if ((int)v4 >= 4)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0LL;
    uint64_t result = 0LL;
    uint64_t v7 = 0LL;
    int v31 = (icu::UVector32 *)(v5 + 72);
    unint64_t v8 = v4 >> 2;
    uint64_t v9 = 0x7FFFFFFFLL;
    uint64_t v10 = 1LL;
    uint64_t v11 = 5LL;
    unsigned int v35 = 0x7FFFFFFF;
    do
    {
      uint64_t v12 = (4 * v6) | 1;
      uint64_t v13 = *(int *)(v5 + 80);
      else {
        int v15 = 0;
      }
      uint64_t v16 = v6 + 1;
      if (v6 + 1 < v8)
      {
        uint64_t v17 = 4 * v6;
        unint64_t v18 = v8;
        uint64_t v19 = v11;
        while (1)
        {
          int v20 = 0;
          if (v15 == v20) {
            break;
          }
          v19 += 4LL;
          if (v10 == --v18) {
            goto LABEL_30;
          }
        }

        int v21 = 0;
        uint64_t v22 = result;
        uint64_t v9 = uprv_min(v9, v21);
        int v23 = 0;
        uint64_t v24 = *(int *)(v5 + 80);
        uint64_t v7 = uprv_max(v7, v23);
        int v25 = 0;
        int v26 = *(_DWORD *)(v5 + 80);
        unsigned int v35 = uprv_min(v35, v25);
        int v27 = 0;
        int v28 = *(_DWORD *)(v5 + 80);
        uint64_t result = uprv_max(v22, v27);
      }

uint64_t sub_1808F5BE0(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 80);
  int v2 = v1 + 3;
  if (v1 >= 0) {
    int v2 = *(_DWORD *)(result + 80);
  }
  if (v1 >= 8)
  {
    int v3 = 0;
    int v4 = (v2 >> 2) - 1;
    char v5 = 1;
    int v26 = v4;
    uint64_t v25 = result;
    uint64_t v6 = result + 72;
    while (1)
    {
      int v7 = 0;
      unsigned int v8 = 4 * v3;
      int v9 = 0;
      unsigned int v10 = v8 | 1;
      int v11 = 0;
      unsigned int v12 = v8 | 2;
      int v13 = 0;
      unsigned int v14 = v8 | 3;
      int v15 = 0;
      int v16 = v8 + 4;
      if (v1 >= 1 && v1 > v16) {
        int v15 = *(_DWORD *)(*(void *)(result + 96) + 4LL * v16);
      }
      int v17 = 0;
      int v18 = v8 + 5;
      if (v1 >= 1 && v1 > v18) {
        int v17 = *(_DWORD *)(*(void *)(result + 96) + 4LL * v18);
      }
      int v19 = 0;
      unsigned int v20 = v8 + 6;
      int v21 = 0;
      unsigned int v22 = v8 + 7;
      int v23 = v19 - v11;
      if (v19 == v11 && (int v23 = v13 - v21, v13 == v21) && (int v23 = v7 - v15, v7 == v15) && (int v23 = v17 - v9, v17 == v9)
        || (v23 & 0x80000000) == 0)
      {
        BOOL v24 = v3 + 1 >= v4;
        if (v3 + 1 < v4) {
          ++v3;
        }
        else {
          int v3 = 0;
        }
        v5 |= v24;
      }

      else
      {
        unsigned int v27 = v8 + 4;
        int v28 = v7;
        int v30 = v9;
        int v31 = v11;
        int v32 = v13;
        unsigned int v29 = v8 + 5;
        icu::UVector32::setElementAt(v6, v15, v8);
        icu::UVector32::setElementAt(v6, v17, v10);
        icu::UVector32::setElementAt(v6, v19, v12);
        icu::UVector32::setElementAt(v6, v21, v14);
        icu::UVector32::setElementAt(v6, v28, v27);
        icu::UVector32::setElementAt(v6, v30, v29);
        icu::UVector32::setElementAt(v6, v31, v20);
        icu::UVector32::setElementAt(v6, v32, v22);
        uint64_t result = v25;
        int v4 = v26;
        char v5 = v3 + 1 >= v26;
        if (v3 + 1 < v26) {
          ++v3;
        }
        else {
          int v3 = 0;
        }
      }

      int v1 = *(_DWORD *)(result + 80);
    }
  }

  return result;
}

uint64_t icu::FormattedValueStringBuilderImpl::FormattedValueStringBuilderImpl(uint64_t a1, char a2)
{
  *(void *)a1 = off_189723B98;
  icu::FormattedStringBuilder::FormattedStringBuilder((icu::FormattedStringBuilder *)(a1 + 8));
  *(_BYTE *)(a1 + 144) = a2;
  *(void *)(a1 + 152) = a1 + 168;
  *(_DWORD *)(a1 + 160) = 8;
  *(_BYTE *)(a1 + 164) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  return a1;
}

{
  *(void *)a1 = off_189723B98;
  icu::FormattedStringBuilder::FormattedStringBuilder((icu::FormattedStringBuilder *)(a1 + 8));
  *(_BYTE *)(a1 + 144) = a2;
  *(void *)(a1 + 152) = a1 + 168;
  *(_DWORD *)(a1 + 160) = 8;
  *(_BYTE *)(a1 + 164) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  return a1;
}

void icu::FormattedValueStringBuilderImpl::~FormattedValueStringBuilderImpl(void **this)
{
  *this = off_189723B98;
  if (*((_BYTE *)this + 164)) {
    uprv_free(this[19]);
  }
  icu::FormattedStringBuilder::~FormattedStringBuilder((icu::FormattedStringBuilder *)(this + 1));
  icu::FormattedValue::~FormattedValue((icu::FormattedValue *)this);
}

{
  void *v1;
  icu::FormattedValueStringBuilderImpl::~FormattedValueStringBuilderImpl(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::FormattedValueStringBuilderImpl::toString@<X0>( icu::FormattedValueStringBuilderImpl *this@<X0>, uint64_t a2@<X8>)
{
  return icu::FormattedStringBuilder::toUnicodeString((icu::FormattedValueStringBuilderImpl *)((char *)this + 8), a2);
}

uint64_t icu::FormattedValueStringBuilderImpl::toTempString@<X0>( icu::FormattedValueStringBuilderImpl *this@<X0>, uint64_t a2@<X8>)
{
  return icu::FormattedStringBuilder::toTempUnicodeString( (icu::FormattedValueStringBuilderImpl *)((char *)this + 8),  a2);
}

icu::Appendable *icu::FormattedValueStringBuilderImpl::appendTo( icu::FormattedValueStringBuilderImpl *this, icu::Appendable *a2, UErrorCode *a3)
{
  int v4 = (icu::FormattedValueStringBuilderImpl *)((char *)this + 8);
  uint64_t v5 = icu::FormattedStringBuilder::chars((icu::FormattedValueStringBuilderImpl *)((char *)this + 8));
  uint64_t v6 = icu::FormattedStringBuilder::length(v4);
  (*(void (**)(icu::Appendable *, uint64_t, uint64_t))(*(void *)a2 + 40LL))(a2, v5, v6);
  return a2;
}

uint64_t icu::FormattedValueStringBuilderImpl::nextPosition( icu::FormattedValueStringBuilderImpl *this, icu::ConstrainedFieldPosition *a2, UErrorCode *a3)
{
  return icu::FormattedValueStringBuilderImpl::nextPositionImpl((uint64_t)this, a2, *((_BYTE *)this + 144));
}

uint64_t icu::FormattedValueStringBuilderImpl::nextPositionImpl( uint64_t a1, icu::ConstrainedFieldPosition *this, unsigned __int8 a3)
{
  int v5 = a3;
  uint64_t v6 = *(unsigned int *)(a1 + 296);
  if ((int)v6 < 1)
  {
    BOOL v9 = 0;
    int v61 = -1;
  }

  else
  {
    uint64_t v7 = *(void *)this;
    if (*(void *)this >= v6) {
      int v8 = -1;
    }
    else {
      int v8 = *(_DWORD *)(*(void *)(a1 + 152) + 16 * v7 + 8);
    }
    int v61 = v8;
    BOOL v10 = v7 < 1;
    uint64_t v11 = v7 - 1;
    BOOL v9 = !v10
      && (uint64_t v12 = *(void *)(a1 + 152), *((_DWORD *)this + 5) == *(_DWORD *)(v12 + 16 * v11))
      && *((_DWORD *)this + 2) == *(_DWORD *)(v12 + 16 * v11 + 4);
  }

  int v13 = *((_DWORD *)this + 5);
  BOOL v14 = a3 && v13 == a3 >> 4 && *((_DWORD *)this + 2) == (a3 & 0xF);
  int v15 = *((_DWORD *)this + 4);
  int v16 = *(_DWORD *)(a1 + 140);
  if (v15 > v16)
  {
LABEL_86:
    icu::ConstrainedFieldPosition::setState(this, v13, *((_DWORD *)this + 2), v16, v16);
    return 0LL;
  }

  uint64_t v17 = 0LL;
  int v18 = *(_DWORD *)(a1 + 136);
  int v19 = v16 + v18;
  int v20 = v15 + v18;
  BOOL v22 = v13 == 2 && *((_DWORD *)this + 2) == 0;
  int v23 = (uint64_t *)(a1 + 96);
  int v63 = a3 >> 4;
  int v64 = a3;
  int v62 = a3 & 0xF;
  BOOL v65 = v22;
  int v66 = -1;
  while (1)
  {
    BOOL v24 = &byte_180A38976;
    if (v20 < v19)
    {
      uint64_t v25 = a1 + 96;
      if (*(_BYTE *)(a1 + 8)) {
        uint64_t v25 = *v23;
      }
      BOOL v24 = (char *)(v25 + v20);
    }

    uint64_t v26 = *v24;
    if ((_BYTE)v17) {
      break;
    }
    if (v20 > v18 && v9)
    {
      uint64_t v27 = a1 + 96;
      if (*(_BYTE *)(a1 + 8)) {
        uint64_t v27 = *v23;
      }
      uint64_t v28 = *(void *)this - 1LL;
      uint64_t v29 = *(unsigned __int8 *)(v27 + v20 - (uint64_t)*(int *)(*(void *)(a1 + 152) + 16 * v28 + 12));
      if ((_DWORD)v29 == 49)
      {
        if (icu::ConstrainedFieldPosition::matchesField(this, 3, 1))
        {
          int v51 = v20 - *(_DWORD *)(a1 + 136) - *(_DWORD *)(*(void *)(a1 + 152) + 16 * v28 + 12);
          int v52 = v20 - *(_DWORD *)(a1 + 136);
LABEL_91:
          uint64_t v49 = 1LL;
          icu::ConstrainedFieldPosition::setState(this, 3, 1, v51, v52);
          return v49;
        }

        BOOL v9 = 0;
      }

      else
      {
        BOOL v9 = 1;
        uint64_t v26 = v29;
        v20 -= *(_DWORD *)(*(void *)(a1 + 152) + 16 * v28 + 12);
      }

      int v5 = v64;
    }

    if (icu::ConstrainedFieldPosition::matchesField(this, 2, 0))
    {
      uint64_t v32 = *(int *)(a1 + 136);
      if (v20 > (int)v32 && !v65 && !v14)
      {
        uint64_t v33 = a1 + 96;
        if (*(_BYTE *)(a1 + 8)) {
          uint64_t v33 = *v23;
        }
        int v34 = *(unsigned __int8 *)(v33 + v20 - 1);
        if ((v34 == 38 || v34 == 32) && (_DWORD)v26 != 32 && (_DWORD)v26 != 38)
        {
          uint64_t v53 = v20;
          int v54 = v20 - 1;
          while (1)
          {
            uint64_t v55 = a1 + 96;
            if (*(_BYTE *)(a1 + 8)) {
              uint64_t v55 = *v23;
            }
            int v56 = *(unsigned __int8 *)(v55 + v53 - 1);
            if (v56 != 38 && v56 != 32) {
              break;
            }
            --v53;
            --v54;
            if (v53 <= v32)
            {
              int v54 = v32 - 1;
              break;
            }
          }

          int v44 = v54 - v32 + 1;
          int v48 = v20 - v32;
          __int128 v47 = this;
          int v45 = 2;
          int v46 = 0;
          goto LABEL_108;
        }
      }
    }

    if (v5)
    {
      if (icu::ConstrainedFieldPosition::matchesField(this, v63, v62))
      {
        uint64_t v35 = *(int *)(a1 + 136);
        if (v20 > (int)v35 && !v14)
        {
          uint64_t v36 = a1 + 96;
          if (*(_BYTE *)(a1 + 8)) {
            uint64_t v36 = *v23;
          }
          int v37 = *(unsigned __int8 *)(v36 + v20 - 1);
          if ((v37 == 1 || (v37 & 0xF0) == 0x20) && (_DWORD)v26 != 1 && (v26 & 0xF0) != 0x20)
          {
            uint64_t v57 = v20;
            int v58 = v20 - 1;
            while (1)
            {
              uint64_t v59 = a1 + 96;
              if (*(_BYTE *)(a1 + 8)) {
                uint64_t v59 = *v23;
              }
              int v60 = *(unsigned __int8 *)(v59 + v57 - 1);
              if (v60 != 1 && (v60 & 0xF0) != 0x20) {
                break;
              }
              --v57;
              --v58;
              if (v57 <= v35)
              {
                int v58 = v35 - 1;
                break;
              }
            }

            int v44 = v58 - v35 + 1;
            int v48 = v20 - v35;
            __int128 v47 = this;
            int v46 = v62;
            int v45 = v63;
            goto LABEL_108;
          }
        }
      }
    }

    if (!v9 && ((_DWORD)v26 == 49 || v20 - *(_DWORD *)(a1 + 136) == v61))
    {
      uint64_t v38 = *(void *)this;
      if (*(void *)this >= *(int *)(a1 + 296))
      {
        int v16 = *(_DWORD *)(a1 + 140);
LABEL_85:
        int v13 = *((_DWORD *)this + 5);
        goto LABEL_86;
      }

      int v39 = (int *)(*(void *)(a1 + 152) + 16 * v38);
      int v40 = *v39;
      int v41 = v39[1];
      int v42 = v39[3];
      uint64_t v43 = v38 + 1;
      icu::ConstrainedFieldPosition::setInt64IterationContext(this, v38 + 1);
      if (v42)
      {
        if (icu::ConstrainedFieldPosition::matchesField(this, v40, v41))
        {
          int v44 = v20 - *(_DWORD *)(a1 + 136);
          int v48 = v44 + v42;
          __int128 v47 = this;
          int v45 = v40;
          int v46 = v41;
          goto LABEL_108;
        }

        if ((_DWORD)v26 == 49)
        {
          if (icu::ConstrainedFieldPosition::matchesField(this, 3, 1))
          {
            int v51 = v20 - *(_DWORD *)(a1 + 136);
            int v52 = v51 + v42;
            goto LABEL_91;
          }

          BOOL v9 = 0;
          BOOL v14 = 0;
          BOOL v65 = 0;
          uint64_t v26 = 0LL;
          int v20 = v20 + v42 - 1;
        }

        else
        {
          BOOL v9 = 0;
          BOOL v14 = 0;
          BOOL v65 = 0;
          uint64_t v26 = 0LL;
        }
      }

      else
      {
        BOOL v9 = 0;
        uint64_t v26 = 0LL;
        --v20;
      }

      int v5 = v64;
    }

    else
    {
      if (v26 >= 0x10)
      {
        BOOL v9 = 0;
        if ((_DWORD)v26 == 32 || (_DWORD)v26 == 255)
        {
          BOOL v14 = 0;
          BOOL v65 = 0;
          uint64_t v26 = 0LL;
          goto LABEL_79;
        }

        if (icu::ConstrainedFieldPosition::matchesField(this, v26 >> 4, v26 & 0xF))
        {
          BOOL v9 = 0;
          BOOL v14 = 0;
          BOOL v65 = 0;
          int v66 = v20 - *(_DWORD *)(a1 + 136);
          goto LABEL_79;
        }
      }

      BOOL v9 = 0;
      BOOL v14 = 0;
      BOOL v65 = 0;
      uint64_t v26 = 0LL;
    }

uint64_t icu::FormattedValueStringBuilderImpl::nextFieldPosition( icu::FormattedValueStringBuilderImpl *this, icu::FieldPosition *a2, UErrorCode *a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 2);
  if (v3 == -1) {
    return 0LL;
  }
  if (v3 < 0xE)
  {
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    icu::ConstrainedFieldPosition::ConstrainedFieldPosition((uint64_t)&v18);
    icu::ConstrainedFieldPosition::constrainField((uint64_t)&v18, 2, v3);
    icu::ConstrainedFieldPosition::setState(&v18, 2, v3, *((_DWORD *)a2 + 3), *((_DWORD *)a2 + 4));
    if (icu::FormattedValueStringBuilderImpl::nextPositionImpl( (uint64_t)this,  (icu::ConstrainedFieldPosition *)&v18,  0))
    {
      int v7 = v19;
      *((_DWORD *)a2 + 3) = HIDWORD(v18);
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
      if (v3 != 1 || *((_DWORD *)a2 + 4)) {
        goto LABEL_26;
      }
      int v8 = *((_DWORD *)this + 34);
      int v9 = *((_DWORD *)this + 35);
      if (v9 < 1)
      {
        int v14 = *((_DWORD *)this + 34);
      }

      else
      {
        int v10 = 0;
        uint64_t v11 = v8;
        uint64_t v12 = (void *)((char *)this + 96);
        if (v9 + v8 <= v8 + 1) {
          int v13 = v8 + 1;
        }
        else {
          int v13 = v9 + v8;
        }
        int v14 = *((_DWORD *)this + 34);
        while (1)
        {
          int v15 = *((_BYTE *)this + 8) ? *(unsigned __int8 *)(*v12 + v11) : *((unsigned __int8 *)v12 + v11);
          int v16 = 1;
          if (v15 != 32 && v15 != 38)
          {
            int v16 = (v15 == 34) | v10;
            if (v15 != 34 && ((v10 ^ 1) & 1) == 0) {
              break;
            }
          }

          ++v11;
          ++v14;
          int v10 = v16;
          if (v11 >= v9 + v8)
          {
            int v14 = v13;
            break;
          }
        }
      }

      uint64_t v4 = 0LL;
      int v7 = v14 - v8;
      *((_DWORD *)a2 + 3) = v7;
    }

    *((_DWORD *)a2 + 4) = v7;
LABEL_26:
    icu::ConstrainedFieldPosition::~ConstrainedFieldPosition((icu::ConstrainedFieldPosition *)&v18);
    return v4;
  }

  uint64_t v4 = 0LL;
  *a3 = U_ILLEGAL_ARGUMENT_ERROR;
  return v4;
}

BOOL icu::FormattedValueStringBuilderImpl::isIntOrGroup(char a1)
{
  return a1 == 32 || a1 == 38;
}

void icu::FormattedValueStringBuilderImpl::getAllFieldPositions( icu::FormattedValueStringBuilderImpl *this, icu::FieldPositionIteratorHandler *a2, UErrorCode *a3)
{
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  icu::ConstrainedFieldPosition::ConstrainedFieldPosition((uint64_t)&v5);
  if (icu::FormattedValueStringBuilderImpl::nextPositionImpl( (uint64_t)this,  (icu::ConstrainedFieldPosition *)&v5,  0))
  {
    do
      (*(void (**)(icu::FieldPositionIteratorHandler *, void, void, void))(*(void *)a2 + 16LL))( a2,  DWORD2(v5),  HIDWORD(v5),  v6);
    while ((icu::FormattedValueStringBuilderImpl::nextPositionImpl( (uint64_t)this,  (icu::ConstrainedFieldPosition *)&v5,  0) & 1) != 0);
  }

  icu::ConstrainedFieldPosition::~ConstrainedFieldPosition((icu::ConstrainedFieldPosition *)&v5);
}

uint64_t icu::FormattedValueStringBuilderImpl::resetString(icu::FormattedValueStringBuilderImpl *this)
{
  uint64_t result = icu::FormattedStringBuilder::clear((uint64_t)this + 8);
  *((_DWORD *)this + 74) = 0;
  return result;
}

BOOL icu::FormattedValueStringBuilderImpl::isTrimmable(char a1)
{
  return a1 != 38 && (a1 & 0xF0) != 48;
}

unint64_t icu::FormattedValueStringBuilderImpl::trimBack( icu::FormattedValueStringBuilderImpl *this, uint64_t a2)
{
  uint64_t v4 = (icu::UnicodeSet *)icu::unisets::get(1);
  __int128 v5 = (UChar *)((char *)this + 16);
  if (*((_BYTE *)this + 8)) {
    __int128 v5 = *(UChar **)v5;
  }
  return icu::UnicodeSet::spanBack(v4, &v5[*((int *)this + 34)], a2, 1);
}

uint64_t icu::FormattedValueStringBuilderImpl::trimFront(icu::FormattedValueStringBuilderImpl *this, int a2)
{
  uint64_t v4 = (icu::UnicodeSet *)icu::unisets::get(1);
  __int128 v5 = (UChar *)((char *)this + 16);
  if (*((_BYTE *)this + 8)) {
    __int128 v5 = *(UChar **)v5;
  }
  return icu::UnicodeSet::span( v4,  &v5[*((int *)this + 34) + a2],  (*((_DWORD *)this + 35) - a2),  1)
       + a2;
}

void icu::FormattedValueStringBuilderImpl::appendSpanInfo( uint64_t a1, int a2, int a3, int a4, int a5, int *a6)
{
  if (*a6 <= 0)
  {
    int v11 = *(_DWORD *)(a1 + 160);
    int v12 = *(_DWORD *)(a1 + 296);
    if (v11 != v12)
    {
      int v16 = *(char **)(a1 + 152);
LABEL_13:
      __int128 v19 = &v16[16 * v12];
      *(_DWORD *)__int128 v19 = a2;
      *((_DWORD *)v19 + sub_1808F7164((uint64_t)v14, 1) = a3;
      *((_DWORD *)v19 + 2) = a4;
      *((_DWORD *)v19 + 3) = a5;
      ++*(_DWORD *)(a1 + 296);
      return;
    }

    if (v11 >= 1)
    {
      int v14 = 2 * v11;
      int v15 = (char *)uprv_malloc(16LL * (2 * v11));
      if (v15)
      {
        int v16 = v15;
        int v17 = *(_DWORD *)(a1 + 160);
        if (v17 >= v11) {
          int v17 = v11;
        }
        if (v17 >= v14) {
          int v17 = 2 * v11;
        }
        __int128 v18 = *(void **)(a1 + 152);
        memcpy(v15, v18, 16LL * v17);
        if (*(_BYTE *)(a1 + 164)) {
          uprv_free(v18);
        }
        *(void *)(a1 + 152) = v16;
        *(_DWORD *)(a1 + 160) = v14;
        *(_BYTE *)(a1 + 164) = 1;
        int v12 = *(_DWORD *)(a1 + 296);
        goto LABEL_13;
      }
    }

    *a6 = 7;
  }

void icu::FormattedValueStringBuilderImpl::prependSpanInfo( uint64_t a1, int a2, int a3, int a4, int a5, int *a6)
{
  if (*a6 <= 0)
  {
    int v11 = *(_DWORD *)(a1 + 160);
    int v12 = *(_DWORD *)(a1 + 296);
    if (v11 == v12)
    {
      if (v11 < 1 || (int v14 = 2 * v11, (v15 = uprv_malloc(16LL * (2 * v11))) == 0LL))
      {
        *a6 = 7;
        return;
      }

      int v16 = v15;
      int v17 = *(_DWORD *)(a1 + 160);
      if (v17 >= v11) {
        int v17 = v11;
      }
      if (v17 >= v14) {
        int v17 = 2 * v11;
      }
      __int128 v18 = *(void **)(a1 + 152);
      memcpy(v15, v18, 16LL * v17);
      if (*(_BYTE *)(a1 + 164)) {
        uprv_free(v18);
      }
      *(void *)(a1 + 152) = v16;
      *(_DWORD *)(a1 + 160) = v14;
      *(_BYTE *)(a1 + 164) = 1;
      int v12 = *(_DWORD *)(a1 + 296);
    }

    if (v12 >= 1)
    {
      unint64_t v19 = v12 + 1LL;
      uint64_t v20 = 16LL * v12;
      do
      {
        *(_OWORD *)(*(void *)(a1 + 152) + v20) = *(_OWORD *)(*(void *)(a1 + 152) + 16LL * (v19-- - 2));
        v20 -= 16LL;
      }

      while (v19 > 1);
    }

    int v21 = *(_DWORD **)(a1 + 152);
    *int v21 = a2;
    v21[1] = a3;
    void v21[2] = a4;
    v21[3] = a5;
    ++*(_DWORD *)(a1 + 296);
  }

uint64_t icu::ConstrainedFieldPosition::ConstrainedFieldPosition(uint64_t this)
{
  *(void *)this = 0LL;
  *(void *)(this + 8) = 0LL;
  *(_BYTE *)(this + 24) = 0;
  *(void *)(this + 16) = 0LL;
  return this;
}

{
  *(void *)this = 0LL;
  *(void *)(this + 8) = 0LL;
  *(_BYTE *)(this + 24) = 0;
  *(void *)(this + 16) = 0LL;
  return this;
}

uint64_t icu::ConstrainedFieldPosition::reset(uint64_t this)
{
  *(void *)this = 0LL;
  *(void *)(this + 8) = 0LL;
  *(_BYTE *)(this + 24) = 0;
  *(void *)(this + 16) = 0LL;
  return this;
}

uint64_t icu::ConstrainedFieldPosition::constrainCategory(uint64_t this, int a2)
{
  *(_BYTE *)(this + 24) = 1;
  *(_DWORD *)(this + 20) = a2;
  return this;
}

uint64_t icu::ConstrainedFieldPosition::constrainField(uint64_t this, int a2, int a3)
{
  *(_BYTE *)(this + 24) = 2;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 8) = a3;
  return this;
}

void *icu::ConstrainedFieldPosition::setInt64IterationContext(void *this, uint64_t a2)
{
  *this = a2;
  return this;
}

BOOL icu::ConstrainedFieldPosition::matchesField(icu::ConstrainedFieldPosition *this, int a2, int a3)
{
  int v3 = *((char *)this + 24);
  if (!*((_BYTE *)this + 24)) {
    return 1LL;
  }
  if (v3 == 2)
  {
    if (*((_DWORD *)this + 5) != a2) {
      return 0LL;
    }
    return *((_DWORD *)this + 2) == a3;
  }

  else
  {
    if (v3 != 1) {
      abort();
    }
    return *((_DWORD *)this + 5) == a2;
  }

_DWORD *icu::ConstrainedFieldPosition::setState(_DWORD *this, int a2, int a3, int a4, int a5)
{
  this[2] = a3;
  this[3] = a4;
  this[4] = a5;
  this[5] = a2;
  return this;
}

uint64_t ucfpos_open(_DWORD *a1, unint64_t a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x28, a2);
  if (result)
  {
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)uint64_t result = 1430472192;
    *(void *)(result + 24) = 0LL;
    *(void *)(result + 32) = 0LL;
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(_BYTE *)(result + 32) = 0;
  }

  else
  {
    *a1 = 7;
  }

  return result;
}

uint64_t ucfpos_reset(uint64_t result, int *a2)
{
  if (*a2 <= 0)
  {
    if (result)
    {
      if (*(_DWORD *)result == 1430472192)
      {
        *(void *)(result + 8) = 0LL;
        *(void *)(result + 16) = 0LL;
        *(_BYTE *)(result + 32) = 0;
        *(void *)(result + 24) = 0LL;
        return result;
      }

      int v2 = 3;
    }

    else
    {
      int v2 = 1;
    }

    *a2 = v2;
  }

  return result;
}

uint64_t ucfpos_constrainCategory(uint64_t result, int a2, int *a3)
{
  if (*a3 <= 0)
  {
    if (result)
    {
      if (*(_DWORD *)result == 1430472192)
      {
        *(_BYTE *)(result + 32) = 1;
        *(_DWORD *)(result + 28) = a2;
        return result;
      }

      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

  return result;
}

uint64_t ucfpos_constrainField(uint64_t result, int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (result)
    {
      if (*(_DWORD *)result == 1430472192)
      {
        *(_BYTE *)(result + 32) = 2;
        *(_DWORD *)(result + 28) = a2;
        *(_DWORD *)(result + 16) = a3;
        return result;
      }

      int v4 = 3;
    }

    else
    {
      int v4 = 1;
    }

    *a4 = v4;
  }

  return result;
}

uint64_t ucfpos_getCategory(_DWORD *a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (a1)
  {
    if (*a1 == 1430472192) {
      return a1[7];
    }
    int v3 = 3;
  }

  else
  {
    int v3 = 1;
  }

  uint64_t result = 0LL;
  *a2 = v3;
  return result;
}

uint64_t ucfpos_getField(_DWORD *a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (a1)
  {
    if (*a1 == 1430472192) {
      return a1[4];
    }
    int v3 = 3;
  }

  else
  {
    int v3 = 1;
  }

  uint64_t result = 0LL;
  *a2 = v3;
  return result;
}

_DWORD *ucfpos_getIndexes(_DWORD *result, _DWORD *a2, _DWORD *a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (result)
    {
      if (*result == 1430472192)
      {
        *a2 = result[5];
        *a3 = result[6];
        return result;
      }

      int v4 = 3;
    }

    else
    {
      int v4 = 1;
    }

    *a4 = v4;
  }

  return result;
}

uint64_t ucfpos_getInt64IterationContext(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (a1)
  {
    if (*(_DWORD *)a1 == 1430472192) {
      return *(void *)(a1 + 8);
    }
    int v3 = 3;
  }

  else
  {
    int v3 = 1;
  }

  uint64_t result = 0LL;
  *a2 = v3;
  return result;
}

uint64_t ucfpos_setInt64IterationContext(uint64_t result, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
  {
    if (result)
    {
      if (*(_DWORD *)result == 1430472192)
      {
        *(void *)(result + 8) = a2;
        return result;
      }

      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

  return result;
}

BOOL ucfpos_matchesField(_DWORD *a1, int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a1)
    {
      if (*a1 == 1430472192) {
        return icu::ConstrainedFieldPosition::matchesField((icu::ConstrainedFieldPosition *)(a1 + 2), a2, a3);
      }
      int v5 = 3;
    }

    else
    {
      int v5 = 1;
    }

    *a4 = v5;
  }

  return 0LL;
}

_DWORD *ucfpos_setState(_DWORD *result, int a2, int a3, int a4, int a5, int *a6)
{
  if (*a6 <= 0)
  {
    if (result)
    {
      if (*result == 1430472192)
      {
        result[4] = a3;
        result[5] = a4;
        result[6] = a5;
        result[7] = a2;
        return result;
      }

      int v6 = 3;
    }

    else
    {
      int v6 = 1;
    }

    *a6 = v6;
  }

  return result;
}

void ucfpos_close(_DWORD *a1)
{
  if (a1)
  {
    if (*a1 == 1430472192)
    {
      *a1 = 0;
      icu::UMemory::operator delete(a1);
    }
  }

unint64_t ufmtval_getString(uint64_t a1, int *a2, int *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (*a3 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    int v8 = 1;
LABEL_16:
    unint64_t v3 = 0LL;
    *a3 = v8;
    return v3;
  }

  if (*(_DWORD *)a1 != 1430672896)
  {
    int v8 = 3;
    goto LABEL_16;
  }

  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  (*(void (**)(__int128 *__return_ptr, void, int *))(**(void **)(a1 + 8) + 24LL))( &v10,  *(void *)(a1 + 8),  a3);
  if (*a3 > 0) {
    goto LABEL_12;
  }
  char v6 = BYTE8(v10);
  if (a2)
  {
    if ((SWORD4(v10) & 0x8000u) == 0) {
      int v7 = WORD4(v10) >> 5;
    }
    else {
      int v7 = HIDWORD(v10);
    }
    *a2 = v7;
  }

  if ((v6 & 0x11) != 0)
  {
LABEL_12:
    unint64_t v3 = 0LL;
  }

  else if ((v6 & 2) != 0)
  {
    unint64_t v3 = (unint64_t)&v10 | 0xA;
  }

  else
  {
    unint64_t v3 = *((void *)&v11 + 1);
  }

  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v10);
  return v3;
}

uint64_t ufmtval_nextPosition(uint64_t a1, _DWORD *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if (a1)
  {
    if (*(_DWORD *)a1 != 1430672896)
    {
LABEL_8:
      int v4 = 3;
      goto LABEL_9;
    }

    if (a2)
    {
      if (*a2 == 1430472192) {
        return (*(uint64_t (**)(void, _DWORD *))(**(void **)(a1 + 8) + 40LL))(*(void *)(a1 + 8), a2 + 2);
      }
      goto LABEL_8;
    }
  }

  int v4 = 1;
LABEL_9:
  *a3 = v4;
  return 0LL;
}

uint64_t icu::FieldPositionHandler::setShift(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) = a2;
  return this;
}

uint64_t sub_1808F70B8(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = 0;
  *(void *)uint64_t result = &off_189723C60;
  *(void *)(result + 16) = a2;
  *(_WORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1808F70DC(uint64_t result, int a2, int a3, int a4)
{
  int v4 = *(_DWORD **)(result + 16);
  if (v4[2] == a2 && (!*(_BYTE *)(result + 24) || !*(_BYTE *)(result + 25)))
  {
    *(_BYTE *)(result + 25) = 1;
    int v5 = *(_DWORD *)(result + 8);
    v4[3] = v5 + a3;
    v4[4] = v5 + a4;
  }

  return result;
}

uint64_t sub_1808F711C(uint64_t result, int a2)
{
  if (a2)
  {
    int v2 = *(_DWORD **)(result + 16);
    if (v2[2] != -1)
    {
      int v3 = v2[3];
      if (v3 != -1)
      {
        int v4 = v2[4] + a2;
        v2[3] = v3 + a2;
        v2[4] = v4;
      }
    }
  }

  return result;
}

BOOL sub_1808F7150(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 16) + 8LL) != -1;
}

uint64_t sub_1808F7164(uint64_t result, char a2)
{
  *(_BYTE *)(result + 24) = a2;
  return result;
}

uint64_t icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler( uint64_t a1, unint64_t a2, unsigned int *a3)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = off_189723C98;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = 0LL;
  int v4 = (uint64_t *)*a3;
  *(_DWORD *)(a1 + 32) = (_DWORD)v4;
  int v5 = (UErrorCode *)(a1 + 32);
  *(_DWORD *)(a1 + 36) = 0;
  if (a2 && (int)v4 <= 0)
  {
    char v6 = (icu::UVector32 *)icu::UMemory::operator new(v4, (icu::UMemory *)0x20, a2);
    if (v6) {
      char v6 = icu::UVector32::UVector32(v6, v5);
    }
    *(void *)(a1 + 24) = v6;
  }

  return a1;
}

uint64_t icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler( uint64_t this, icu::UVector32 *a2, UErrorCode *a3)
{
  *(_DWORD *)(this + 8) = 0;
  *(void *)this = off_189723C98;
  *(void *)(this + 16) = 0LL;
  *(void *)(this + 24) = a2;
  *(void *)(this + 32) = *(unsigned int *)a3;
  return this;
}

{
  *(_DWORD *)(this + 8) = 0;
  *(void *)this = off_189723C98;
  *(void *)(this + 16) = 0LL;
  *(void *)(this + 24) = a2;
  *(void *)(this + 32) = *(unsigned int *)a3;
  return this;
}

void icu::FieldPositionIteratorHandler::~FieldPositionIteratorHandler( icu::FieldPositionIteratorHandler *this)
{
  *(void *)this = off_189723C98;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    icu::FieldPositionIterator::setData(v2, *((icu::UVector32 **)this + 3), (UErrorCode *)this + 8);
  }
  *((void *)this + 3) = 0LL;
}

{
  uint64_t v2;
  *(void *)this = off_189723C98;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    icu::FieldPositionIterator::setData(v2, *((icu::UVector32 **)this + 3), (UErrorCode *)this + 8);
  }
  *((void *)this + 3) = 0LL;
}

{
  uint64_t v2;
  *(void *)this = off_189723C98;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    icu::FieldPositionIterator::setData(v2, *((icu::UVector32 **)this + 3), (UErrorCode *)this + 8);
  }
  *((void *)this + 3) = 0LL;
  icu::UMemory::operator delete(this);
}

void icu::FieldPositionIteratorHandler::addAttribute(UErrorCode *this, int a2, int a3, int a4)
{
  uint64_t v4 = *((void *)this + 3);
  if (v4)
  {
    if (a3 < a4)
    {
      int v8 = this + 8;
      if (*((int *)this + 8) <= 0)
      {
        int v10 = *(_DWORD *)(v4 + 8);
        int v11 = *((_DWORD *)this + 9);
        if (v10 < -1 || (int v12 = *(_DWORD *)(v4 + 8), *(_DWORD *)(v4 + 12) <= v10))
        {
          if (!icu::UVector32::expandCapacity(*((icu::UVector32 **)this + 3), v10 + 1, v8))
          {
LABEL_9:
            uint64_t v13 = *((void *)this + 3);
            int v14 = *(_DWORD *)(v13 + 8);
            if (v14 < -1 || *(_DWORD *)(v13 + 12) <= v14)
            {
              if (!icu::UVector32::expandCapacity(*((icu::UVector32 **)this + 3), v14 + 1, v8))
              {
LABEL_14:
                uint64_t v15 = *((void *)this + 3);
                int v16 = *((_DWORD *)this + 2);
                int v17 = *(_DWORD *)(v15 + 8);
                if (v17 < -1 || *(_DWORD *)(v15 + 12) <= v17)
                {
                  if (!icu::UVector32::expandCapacity(*((icu::UVector32 **)this + 3), v17 + 1, v8))
                  {
LABEL_19:
                    uint64_t v18 = *((void *)this + 3);
                    int v19 = *((_DWORD *)this + 2);
                    int v20 = *(_DWORD *)(v18 + 8);
                    if (v20 < -1 || *(_DWORD *)(v18 + 12) <= v20)
                    {
                      int v20 = *(_DWORD *)(v18 + 8);
                    }

                    *(_DWORD *)(*(void *)(v18 + 24) + 4LL * v20) = v19 + a4;
                    ++*(_DWORD *)(v18 + 8);
LABEL_24:
                    return;
                  }

                  int v17 = *(_DWORD *)(v15 + 8);
                }

                *(_DWORD *)(*(void *)(v15 + 24) + 4LL * v17) = v16 + a3;
                ++*(_DWORD *)(v15 + 8);
                goto LABEL_19;
              }

              int v14 = *(_DWORD *)(v13 + 8);
            }

            *(_DWORD *)(*(void *)(v13 + 24) + 4LL * v14) = a2;
            ++*(_DWORD *)(v13 + 8);
            goto LABEL_14;
          }

          int v12 = *(_DWORD *)(v4 + 8);
        }

        *(_DWORD *)(*(void *)(v4 + 24) + 4LL * v12) = v11;
        ++*(_DWORD *)(v4 + 8);
        goto LABEL_9;
      }
    }
  }

uint64_t icu::FieldPositionIteratorHandler::shiftLast(uint64_t this, int a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    if (*(int *)(this + 32) <= 0)
    {
      this = *(void *)(this + 24);
      int v3 = *(_DWORD *)(this + 8);
      if (v3 >= 1)
      {
        icu::UVector32::setElementAt( this,  *(_DWORD *)(*(void *)(this + 24) + 4LL * (v3 - 1)) + a2,  v3 - 1);
        unsigned int v5 = v3 - 2;
        uint64_t v6 = *(void *)(v2 + 24);
        else {
          int v9 = *(_DWORD *)(*(void *)(v6 + 24) + 4LL * v5);
        }
        return icu::UVector32::setElementAt(v6, v9 + a2, v5);
      }
    }
  }

  return this;
}

BOOL icu::FieldPositionIteratorHandler::isRecording(icu::FieldPositionIteratorHandler *this)
{
  return *((_DWORD *)this + 8) < 1;
}

void icu::FieldPositionIterator::~FieldPositionIterator(icu::FieldPositionIterator *this)
{
  *(void *)this = off_189723D50;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 4) = -1;
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::FieldPositionIterator::~FieldPositionIterator(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::FieldPositionIterator::FieldPositionIterator(uint64_t this)
{
  *(void *)this = off_189723D50;
  *(void *)(this + 8) = 0LL;
  *(_DWORD *)(this + 16) = -1;
  return this;
}

{
  *(void *)this = off_189723D50;
  *(void *)(this + 8) = 0LL;
  *(_DWORD *)(this + 16) = -1;
  return this;
}

icu::FieldPositionIterator *icu::FieldPositionIterator::FieldPositionIterator( icu::FieldPositionIterator *this, const icu::FieldPositionIterator *a2)
{
  *(void *)this = off_189723D50;
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  int v3 = (uint64_t *)*((void *)a2 + 1);
  if (v3)
  {
    UErrorCode v8 = U_ZERO_ERROR;
    unsigned int v5 = (icu::UVector32 *)icu::UMemory::operator new(v3, (icu::UMemory *)0x20, (unint64_t)a2);
    if (v5) {
      unsigned int v5 = icu::UVector32::UVector32(v5, &v8);
    }
    *((void *)this + sub_1808F7164((uint64_t)v14, 1) = v5;
    icu::UVector32::assign(v5, *((const icu::UVector32 **)a2 + 1), &v8);
    if (v8)
    {
      uint64_t v6 = *((void *)this + 1);
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
      }
      *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
      *((_DWORD *)this + 4) = -1;
    }
  }

  return this;
}

uint64_t icu::FieldPositionIterator::operator==(uint64_t a1, uint64_t a2)
{
  if (a2 == a1) {
    return 1LL;
  }
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t result = (v2 | v3) == 0;
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    return icu::UVector32::operator==(v2, v3);
  }
  return result;
}

uint64_t icu::FieldPositionIterator::setData(uint64_t this, icu::UVector32 *a2, UErrorCode *a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = this;
  int v5 = *a3;
  if (a2 && v5 <= 0)
  {
    uint64_t v7 = *((unsigned int *)a2 + 2);
    if ((_DWORD)v7)
    {
      if ((v7 & 3) != 0)
      {
LABEL_5:
        *a3 = U_ILLEGAL_ARGUMENT_ERROR;
        return (*(uint64_t (**)(icu::UVector32 *))(*(void *)a2 + 8LL))(a2);
      }

      if ((int)v7 >= 3)
      {
        uint64_t v8 = 0LL;
        while (1)
        {
          int v9 = v8 + 3 >= v7 ? 0 : *(_DWORD *)(*((void *)a2 + 3) + 4 * v8 + 12);
          if (*(_DWORD *)(*((void *)a2 + 3) + 8LL + 4 * v8) >= v9) {
            goto LABEL_5;
          }
          v8 += 4LL;
        }
      }
    }

    else
    {
      this = (*(uint64_t (**)(icu::UVector32 *))(*(void *)a2 + 8LL))(a2);
      uint64_t v3 = 0LL;
    }
  }

  else
  {
LABEL_15:
    if (v5 > 0)
    {
      if (!a2) {
        return this;
      }
      return (*(uint64_t (**)(icu::UVector32 *))(*(void *)a2 + 8LL))(a2);
    }
  }

  this = *(void *)(v4 + 8);
  if (this) {
    this = (*(uint64_t (**)(uint64_t))(*(void *)this + 8LL))(this);
  }
  *(void *)(v4 + 8) = v3;
  if (v3) {
    int v10 = 0;
  }
  else {
    int v10 = -1;
  }
  *(_DWORD *)(v4 + 16) = v10;
  return this;
}

uint64_t icu::FieldPositionIterator::next(icu::FieldPositionIterator *this, icu::FieldPosition *a2)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  if ((_DWORD)v2 == -1) {
    return 0LL;
  }
  uint64_t v3 = *((void *)this + 1);
  int v4 = v2 + 2;
  *((_DWORD *)this + 4) = v2 + 2;
  if ((int)v2 >= -1)
  {
    uint64_t v5 = v2 + 1;
    int v6 = *(_DWORD *)(v3 + 8);
    else {
      int v10 = *(_DWORD *)(*(void *)(v3 + 24) + 4 * v5);
    }
    *((_DWORD *)a2 + 2) = v10;
    int v9 = v2 + 3;
    *((_DWORD *)this + 4) = v2 + 3;
    goto LABEL_13;
  }

  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)this + 4) = v2 + 3;
  if ((_DWORD)v2 == -2)
  {
    int v9 = 1;
LABEL_13:
    int v11 = *(_DWORD *)(v3 + 8);
    if (v11 < 1 || v11 <= v4) {
      int v13 = 0;
    }
    else {
      int v13 = *(_DWORD *)(*(void *)(v3 + 24) + 4LL * v4);
    }
    *((_DWORD *)a2 + 3) = v13;
    int v14 = v2 + 4;
    *((_DWORD *)this + 4) = v2 + 4;
    goto LABEL_20;
  }

  int v9 = 0;
  *((_DWORD *)a2 + 3) = 0;
  int v14 = v2 + 4;
  *((_DWORD *)this + 4) = v2 + 4;
  int v11 = *(_DWORD *)(v3 + 8);
  if ((_DWORD)v2 == -3)
  {
    int v14 = 1;
LABEL_20:
    if (v11 < 1 || v11 <= v9) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(*(void *)(v3 + 24) + 4LL * v9);
    }
  }

  *((_DWORD *)a2 + 4) = v9;
  if (v14 == v11) {
    *((_DWORD *)this + 4) = -1;
  }
  return 1LL;
}

void *sub_1808F78EC()
{
  return &unk_18C53541A;
}

void *sub_1808F78F8(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = off_189723D90;
  result[1] = &unk_189723DF0;
  result[2] = a2;
  result[3] = a3;
  return result;
}

void sub_1808F7910(void *a1)
{
  *a1 = off_189723D90;
  a1[1] = &unk_189723DF0;
  uint64_t v2 = (icu::UnicodeReplacer *)(a1 + 1);
  uint64_t v3 = a1[2];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = a1[3];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  icu::UnicodeReplacer::~UnicodeReplacer(v2);
  icu::UnicodeFunctor::~UnicodeFunctor((icu::UnicodeFunctor *)a1);
}

void sub_1808F797C(uint64_t a1)
{
}

void sub_1808F7984(void *a1)
{
}

void sub_1808F7998(uint64_t a1)
{
}

void *sub_1808F79B0(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = (void *)icu::UMemory::operator new((icu::UMemory *)0x20, a2);
  uint64_t v4 = v3;
  if (v3)
  {
    *uint64_t v3 = off_189723D90;
    v3[1] = &unk_189723DF0;
    v3[2] = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24LL))(*(void *)(a1 + 16));
    v4[3] = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24LL))(*(void *)(a1 + 24));
  }

  return v4;
}

uint64_t sub_1808F7A18(uint64_t a1)
{
  if (a1) {
    return a1 + 8;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1808F7A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24));
  int v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 16LL))( v10,  a2,  a3,  a4,  a5);
  return (*(unsigned int (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 16) + 32LL))( *(void *)(a1 + 16),  a2,  a3,  (v11 + a3))
       - a3;
}

uint64_t sub_1808F7AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40LL))(*(void *)(a1 + 16));
  int v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 16LL))( v10,  a2,  a3,  a4,  a5);
  return (*(unsigned int (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 8) + 32LL))( *(void *)(a1 + 8),  a2,  a3,  (v11 + a3))
       - a3;
}

icu::UnicodeString *sub_1808F7B38(uint64_t a1, icu::UnicodeString *this, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  __int128 v23 = 0u;
  uint64_t v26 = 0LL;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  BOOL v22 = off_18971B688;
  LOWORD(v23) = 2;
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if ((v6 & 1) != 0)
  {
    icu::UnicodeString::unBogus((uint64_t)this);
  }

  else
  {
    if ((v6 & 0x8000u) == 0) {
      unsigned int v7 = v6 >> 5;
    }
    else {
      unsigned int v7 = *((_DWORD *)this + 3);
    }
    if (v7) {
      *((_WORD *)this + 4) &= 0x1Fu;
    }
  }

  __int16 v21 = 38;
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v21, 0, 1LL);
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 104LL))(*(void *)(a1 + 16));
  unsigned int v9 = *(unsigned __int16 *)(v8 + 8);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 >= 0) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = *(unsigned int *)(v8 + 12);
  }
  icu::UnicodeString::doAppend((uint64_t)this, (const icu::UnicodeString *)v8, 0, v12);
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)L"( ", 0, 2LL);
  v20[1] = L"( ";
  uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24));
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), uint64_t))(*(void *)v13 + 24LL))( v13,  &v22,  a3);
  unsigned int v15 = *(unsigned __int16 *)(v14 + 8);
  int v16 = (__int16)v15;
  unsigned int v17 = v15 >> 5;
  if (v16 >= 0) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = *(unsigned int *)(v14 + 12);
  }
  icu::UnicodeString::doAppend((uint64_t)this, (const icu::UnicodeString *)v14, 0, v18);
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)" ", 0, 2LL);
  v20[0] = " ";
  icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v22);
  return this;
}

icu::UnicodeString *sub_1808F7CEC(uint64_t a1, icu::UnicodeString *a2, uint64_t a3)
{
  return sub_1808F7B38(a1 - 8, a2, a3);
}

void *sub_1808F7CF4(uint64_t a1, icu::UVector **a2)
{
  uint64_t v9 = 0LL;
  memset(v8, 0, sizeof(v8));
  double v4 = icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v8);
  uint64_t v5 = (const icu::UnicodeSet *)(*(uint64_t (**)(void, _OWORD *, double))(**(void **)(a1 + 16) + 128LL))( *(void *)(a1 + 16),  v8,  v4);
  icu::UnicodeSet::addAll(a2, v5);
  return icu::UnicodeSet::~UnicodeSet(v6, (icu::UnicodeSet *)v8);
}

void *sub_1808F7D6C(uint64_t a1, icu::UVector **a2)
{
  return sub_1808F7CF4(a1 - 8, a2);
}

uint64_t sub_1808F7D74(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 48LL))(*(void *)(a1 + 24));
}

void sub_1808F7D84(int *a1)
{
  if (*a1 <= 0)
  {
    uint64_t v3 = (_OWORD *)icu::UMemory::operator new[]((icu::UMemory *)0x40, v2);
    if (v3)
    {
      *uint64_t v3 = xmmword_180A38A60;
      for (uint64_t i = 1LL; i != 4; ++i)
        *(void *)&v3[i] = off_189723E60;
      uint64_t v5 = 0LL;
      qword_18C535420 = (uint64_t)(v3 + 1);
      unsigned int v6 = (_DWORD *)v3 + 6;
      do
      {
        *unsigned int v6 = v5;
        v6 += 4;
        ++v5;
      }

      while (v5 != 3);
      unsigned int v7 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0LL, a1);
      qword_18C535428 = (uint64_t)v7;
      if (*a1 < 1)
      {
        uhash_setKeyDeleter((uint64_t)v7, (uint64_t)uprv_free);
      }

      else if (qword_18C535420)
      {
        uint64_t v8 = (char *)(qword_18C535420 - 16);
        uint64_t v9 = *(void *)(qword_18C535420 - 8);
        if (v9)
        {
          uint64_t v10 = 16 * v9;
          do
          {
            icu::UObject::~UObject((icu::UObject *)&v8[v10]);
            v10 -= 16LL;
          }

          while (v10);
        }

        icu::UMemory::operator delete[](v8);
      }
    }

    else
    {
      qword_18C535420 = 0LL;
      *a1 = 7;
    }
  }

uint64_t sub_1808F7EA4()
{
  if (qword_18C535428)
  {
    uhash_close((_BYTE *)qword_18C535428);
    qword_18C535428 = 0LL;
    if (qword_18C535420)
    {
      unsigned int v0 = (char *)(qword_18C535420 - 16);
      uint64_t v1 = *(void *)(qword_18C535420 - 8);
      if (v1)
      {
        uint64_t v2 = 16 * v1;
        do
        {
          icu::UObject::~UObject((icu::UObject *)&v0[v2]);
          v2 -= 16LL;
        }

        while (v2);
      }

      icu::UMemory::operator delete[](v0);
    }
  }

  atomic_store(0, &dword_18C535480);
  return 1LL;
}

void *icu::GenderInfo::GenderInfo(void *this)
{
  *this = off_189723E60;
  return this;
}

{
  *this = off_189723E60;
  return this;
}

void icu::GenderInfo::~GenderInfo(icu::GenderInfo *this)
{
}

uint64_t icu::GenderInfo::getInstance(icu::GenderInfo *this, const icu::Locale *a2, UErrorCode *a3)
{
  if (*(int *)a2 <= 0)
  {
    unsigned int v7 = atomic_load(&dword_18C535480);
    if (v7 == 2 || !icu::umtx_initImplPreInit(&dword_18C535480))
    {
      if (dword_18C535484 >= 1)
      {
        uint64_t v3 = 0LL;
        *(_DWORD *)a2 = dword_18C535484;
        return v3;
      }
    }

    else
    {
      sub_1808F7D84((int *)a2);
      dword_18C535484 = *(_DWORD *)a2;
      icu::umtx_initImplPostInit(&dword_18C535480);
    }

    if (*(int *)a2 <= 0)
    {
      uint64_t v8 = (const char *)*((void *)this + 5);
      umtx_lock((icu::UMutex *)&unk_18C535430);
      uint64_t v3 = uhash_get(qword_18C535428, (uint64_t)v8);
      umtx_unlock((std::mutex **)&unk_18C535430);
      if (v3) {
        return v3;
      }
      uint64_t Instance = icu::GenderInfo::loadInstance(this, a2, v9);
      if (*(int *)a2 <= 0)
      {
        uint64_t v11 = Instance;
        umtx_lock((icu::UMutex *)&unk_18C535430);
        uint64_t v3 = uhash_get(qword_18C535428, (uint64_t)v8);
        if (v3
          || (uint64_t v12 = qword_18C535428,
              uint64_t v13 = uprv_strdup(v8),
              uhash_put(v12, (uint64_t)v13, v11, (int *)a2),
              uint64_t v3 = v11,
              *(int *)a2 < 1))
        {
          umtx_unlock((std::mutex **)&unk_18C535430);
          return v3;
        }

        umtx_unlock((std::mutex **)&unk_18C535430);
      }
    }
  }

  return 0LL;
}

uint64_t icu::GenderInfo::loadInstance(icu::GenderInfo *this, const icu::Locale *a2, UErrorCode *a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v5 = ures_openDirect(0LL, (uint64_t)"genderList", (uint64_t)a2);
  uint64_t v6 = v5;
  uint64_t v7 = 0LL;
  uint64_t v8 = ures_getByKey(v5, "genderList", 0LL, (int *)a2);
  uint64_t v9 = v8;
  uint64_t v7 = 0LL;
  if (*(int *)a2 > 0)
  {
LABEL_30:
    if (!v9) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  *(void *)__int16 v21 = 0LL;
  uint64_t v10 = (const char *)*((void *)this + 5);
  StringByuint64_t Key = ures_getStringByKey(v8, v10, (int *)&v21[1], (int *)v21);
  if (!StringByKey)
  {
    v21[0] = U_ZERO_ERROR;
    memset(&__s[1], 0, 56);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v19, v10);
    __s[0] = (char *)&__s[1] + 5;
    LODWORD(__s[1]) = 40;
    WORD2(__s[1]) = 0;
    LODWORD(__s[7]) = 0;
    icu::CharString::append((icu::CharString *)__s, v19, v20, v21);
    while (1)
    {
      uint64_t v36 = 0LL;
      memset(&v35[1], 0, 48);
      v35[0] = (char *)&v35[1] + 5;
      LODWORD(v35[1]) = 40;
      v18[0] = 0LL;
      v18[1] = 0LL;
      icu::CharStringByteSink::CharStringByteSink(v18, (uint64_t)v35);
      ulocimp_getParent(__s[0], (uint64_t)v18, (int *)a2);
      int v12 = v36;
      if ((_DWORD)v36) {
        icu::CharString::operator=((uint64_t)__s, (uint64_t)v35);
      }
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v18);
      if (BYTE4(v35[1])) {
        uprv_free(v35[0]);
      }
      if (!v12) {
        break;
      }
      *(void *)__int16 v21 = 0LL;
      uint64_t v13 = ures_getStringByKey(v9, __s[0], (int *)&v21[1], (int *)v21);
      v21[0] = U_ZERO_ERROR;
      if (v13)
      {
        StringByuint64_t Key = v13;
        goto LABEL_13;
      }
    }

    StringByuint64_t Key = 0LL;
LABEL_13:
    if (BYTE4(__s[1])) {
      uprv_free(__s[0]);
    }
    if (!StringByKey) {
      goto LABEL_29;
    }
  }

  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  memset(__s, 0, sizeof(__s));
  u_UCharsToChars(StringByKey, (char *)__s, v21[1] + 1);
  if (__s[0] == (char *)0x6C61727475656ELL)
  {
LABEL_29:
    uint64_t v7 = qword_18C535420;
    goto LABEL_30;
  }

  if (__s[0] != (char *)0x75654E646578696DLL || *(char **)((char *)__s + 5) != (char *)0x6C61727475654ELL)
  {
    BOOL v16 = __s[0] == (char *)0x6E696154656C616DLL && *(char **)((char *)__s + 3) == (char *)0x73746E69615465LL;
    uint64_t v7 = qword_18C535420 + 32 * v16;
    if (!v9) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  uint64_t v7 = qword_18C535420 + 16;
  if (v9) {
LABEL_31:
  }
    ures_close(v9);
LABEL_32:
  if (v6) {
    ures_close(v6);
  }
  return v7;
}

uint64_t icu::GenderInfo::getListGender(uint64_t a1, unsigned int *a2, int a3, int *a4)
{
  if (*a4 > 0 || !a3) {
    return 2LL;
  }
  if (a3 == 1) {
    return *a2;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (v5 == 2)
  {
    if (a3 < 1) {
      return 1LL;
    }
    if (*a2 != 1) {
      return 0LL;
    }
    uint64_t v10 = 1LL;
    do
    {
      unint64_t v11 = v10;
      if (a3 == v10) {
        break;
      }
      unsigned int v12 = a2[v10++];
    }

    while (v12 == 1);
    return v11 >= a3;
  }

  if (v5 != 1) {
    return 2LL;
  }
  if (a3 < 1)
  {
    int v6 = 0;
  }

  else
  {
    int v6 = 0;
    int v7 = 0;
    uint64_t v8 = a3;
    do
    {
      unsigned int v9 = *a2++;
      uint64_t result = v9;
      if (v9)
      {
        if ((_DWORD)result == 1)
        {
          if (v6) {
            return 2LL;
          }
          int v7 = 1;
        }

        else if ((_DWORD)result == 2)
        {
          return result;
        }
      }

      else
      {
        if (v7) {
          return 2LL;
        }
        int v6 = 1;
      }

      --v8;
    }

    while (v8);
  }

  return v6 == 0;
}

uint64_t icu::GenderInfo::getNeutralInstance(icu::GenderInfo *this)
{
  return qword_18C535420;
}

uint64_t icu::GenderInfo::getMixedNeutralInstance(icu::GenderInfo *this)
{
  return qword_18C535420 + 16;
}

uint64_t icu::GenderInfo::getMaleTaintsInstance(icu::GenderInfo *this)
{
  return qword_18C535420 + 32;
}

uint64_t ugender_getInstance(char *a1, const icu::Locale *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  icu::Locale::Locale((icu::Locale *)v6, a1, 0LL, 0LL, 0LL);
  uint64_t Instance = icu::GenderInfo::getInstance((icu::GenderInfo *)v6, a2, v3);
  icu::Locale::~Locale((icu::Locale *)v6);
  return Instance;
}

void *icu::GregorianCalendar::getStaticClassID(icu::GregorianCalendar *this)
{
  return &unk_18C535488;
}

void *icu::GregorianCalendar::getDynamicClassID(icu::GregorianCalendar *this)
{
  return &unk_18C535488;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, UErrorCode *a2)
{
  double v4 = icu::Calendar::Calendar(this, a2);
  *(void *)double v4 = off_189723EA0;
  *((void *)v4 + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)v4 + 158) = 2299161;
  *((void *)v4 + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)v4 + 162) = 1582;
  *((_WORD *)v4 + 326) = 1;
  icu::Calendar::getNow(v4);
  icu::Calendar::setTimeInMillis((uint64_t)this, v5, a2);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, icu::TimeZone *a2, UErrorCode *a3)
{
  uint64_t Default = icu::Locale::getDefault(this);
  uint64_t v7 = icu::Calendar::Calendar(this, a2, (const icu::Locale *)Default, a3);
  *(void *)this = off_189723EA0;
  *((void *)this + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 158) = 2299161;
  *((void *)this + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 162) = 1582;
  *((_WORD *)this + 326) = 1;
  icu::Calendar::getNow(v7);
  icu::Calendar::setTimeInMillis((uint64_t)this, v8, a3);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, const icu::TimeZone *a2, UErrorCode *a3)
{
  uint64_t Default = icu::Locale::getDefault(this);
  uint64_t v7 = icu::Calendar::Calendar(this, a2, (const icu::Locale *)Default, a3);
  *(void *)this = off_189723EA0;
  *((void *)this + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 158) = 2299161;
  *((void *)this + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 162) = 1582;
  *((_WORD *)this + 326) = 1;
  icu::Calendar::getNow(v7);
  icu::Calendar::setTimeInMillis((uint64_t)this, v8, a3);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, char **a2, UErrorCode *a3)
{
  int v6 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  uint64_t v7 = icu::Calendar::Calendar(this, v6, (const icu::Locale *)a2, a3);
  *(void *)this = off_189723EA0;
  *((void *)this + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 158) = 2299161;
  *((void *)this + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 162) = 1582;
  *((_WORD *)this + 326) = 1;
  icu::Calendar::getNow(v7);
  icu::Calendar::setTimeInMillis((uint64_t)this, v8, a3);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, icu::TimeZone *a2, const icu::Locale *a3, UErrorCode *a4)
{
  int v6 = icu::Calendar::Calendar(this, a2, a3, a4);
  *(void *)int v6 = off_189723EA0;
  *((void *)v6 + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)v6 + 158) = 2299161;
  *((void *)v6 + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)v6 + 162) = 1582;
  *((_WORD *)v6 + 326) = 1;
  icu::Calendar::getNow(v6);
  icu::Calendar::setTimeInMillis((uint64_t)this, v7, a4);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, const icu::TimeZone *a2, const icu::Locale *a3, UErrorCode *a4)
{
  int v6 = icu::Calendar::Calendar(this, a2, a3, a4);
  *(void *)int v6 = off_189723EA0;
  *((void *)v6 + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)v6 + 158) = 2299161;
  *((void *)v6 + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)v6 + 162) = 1582;
  *((_WORD *)v6 + 326) = 1;
  icu::Calendar::getNow(v6);
  icu::Calendar::setTimeInMillis((uint64_t)this, v7, a4);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, int a2, int a3, int a4, UErrorCode *a5)
{
  uint64_t Default = (icu::Locale *)icu::TimeZone::createDefault(this);
  unint64_t v11 = icu::Locale::getDefault(Default);
  unsigned int v12 = icu::Calendar::Calendar(this, Default, (const icu::Locale *)v11, a5);
  *(void *)this = off_189723EA0;
  *((void *)this + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 158) = 2299161;
  *((void *)this + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 162) = 1582;
  *((_WORD *)this + 326) = 1;
  icu::Calendar::set(v12, 0, 1);
  icu::Calendar::set(this, 1u, a2);
  icu::Calendar::set(this, 2u, a3);
  icu::Calendar::set(this, 5u, a4);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, int a2, int a3, int a4, int a5, int a6, UErrorCode *a7)
{
  uint64_t Default = (icu::Locale *)icu::TimeZone::createDefault(this);
  unsigned int v15 = icu::Locale::getDefault(Default);
  BOOL v16 = icu::Calendar::Calendar(this, Default, (const icu::Locale *)v15, a7);
  *(void *)this = off_189723EA0;
  *((void *)this + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 158) = 2299161;
  *((void *)this + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 162) = 1582;
  *((_WORD *)this + 326) = 1;
  icu::Calendar::set(v16, 0, 1);
  icu::Calendar::set(this, 1u, a2);
  icu::Calendar::set(this, 2u, a3);
  icu::Calendar::set(this, 5u, a4);
  icu::Calendar::set(this, 0xBu, a5);
  icu::Calendar::set(this, 0xCu, a6);
  return this;
}

icu::GregorianCalendar *icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, int a2, int a3, int a4, int a5, int a6, int a7, UErrorCode *a8)
{
  uint64_t Default = (icu::Locale *)icu::TimeZone::createDefault(this);
  unsigned int v17 = icu::Locale::getDefault(Default);
  uint64_t v18 = icu::Calendar::Calendar(this, Default, (const icu::Locale *)v17, a8);
  *(void *)this = off_189723EA0;
  *((void *)this + 78) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 158) = 2299161;
  *((void *)this + 80) = 0xC2A63A0D36A80000LL;
  *((_DWORD *)this + 162) = 1582;
  *((_WORD *)this + 326) = 1;
  icu::Calendar::set(v18, 0, 1);
  icu::Calendar::set(this, 1u, a2);
  icu::Calendar::set(this, 2u, a3);
  icu::Calendar::set(this, 5u, a4);
  icu::Calendar::set(this, 0xBu, a5);
  icu::Calendar::set(this, 0xCu, a6);
  icu::Calendar::set(this, 0xDu, a7);
  return this;
}

void icu::GregorianCalendar::~GregorianCalendar(icu::GregorianCalendar *this)
{
}

double icu::GregorianCalendar::GregorianCalendar( icu::GregorianCalendar *this, const icu::GregorianCalendar *a2)
{
  uint64_t v3 = icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v3 = off_189723EA0;
  *(void *)(v3 + 624) = *((void *)a2 + 78);
  *(_DWORD *)(v3 + 632) = *((_DWORD *)a2 + 158);
  double result = *((double *)a2 + 80);
  *(double *)(v3 + 640) = result;
  *(_DWORD *)(v3 + 648) = *((_DWORD *)a2 + 162);
  *(_WORD *)(v3 + 652) = *((_WORD *)a2 + 326);
  return result;
}

{
  uint64_t v3;
  double result;
  uint64_t v3 = icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v3 = off_189723EA0;
  *(void *)(v3 + 624) = *((void *)a2 + 78);
  *(_DWORD *)(v3 + 632) = *((_DWORD *)a2 + 158);
  double result = *((double *)a2 + 80);
  *(double *)(v3 + 640) = result;
  *(_DWORD *)(v3 + 648) = *((_DWORD *)a2 + 162);
  *(_WORD *)(v3 + 652) = *((_WORD *)a2 + 326);
  return result;
}

double icu::GregorianCalendar::clone@<D0>( icu::GregorianCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  double v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x290, a2);
  if (v4)
  {
    uint64_t v6 = icu::Calendar::Calendar((uint64_t)v4, (uint64_t)this);
    *(void *)uint64_t v6 = off_189723EA0;
    *(void *)(v6 + 624) = *((void *)this + 78);
    *(_DWORD *)(v6 + 632) = *((_DWORD *)this + 158);
    double result = *((double *)this + 80);
    *(double *)(v6 + 640) = result;
    *(_DWORD *)(v6 + 648) = *((_DWORD *)this + 162);
    *(_WORD *)(v6 + 652) = *((_WORD *)this + 326);
  }

  return result;
}

uint64_t icu::GregorianCalendar::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    icu::Calendar::operator=(a1, a2);
    *(void *)(a1 + 624) = *(void *)(a2 + 624);
    *(void *)(a1 + 640) = *(void *)(a2 + 640);
    *(_DWORD *)(a1 + 648) = *(_DWORD *)(a2 + 648);
    *(_DWORD *)(a1 + 632) = *(_DWORD *)(a2 + 632);
  }

  return a1;
}

uint64_t icu::GregorianCalendar::isEquivalentTo(icu::GregorianCalendar *this, const icu::Calendar *a2)
{
  uint64_t result = icu::Calendar::isEquivalentTo(this, a2);
  if ((_DWORD)result) {
    return *((double *)this + 78) == *((double *)a2 + 78);
  }
  return result;
}

icu::GregorianCalendar *icu::GregorianCalendar::setGregorianChange( icu::GregorianCalendar *this, double a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v4 = (uint64_t)this;
    if (*((double *)this + 78) != a2)
    {
      double v7 = uprv_floor(a2 / 86400000.0);
      if (v7 <= -2147483650.0)
      {
        unint64_t v8 = 0xC384997000000000LL;
        *(void *)(v4 + 640) = 0xC384997000000000LL;
        *(void *)(v4 + 624) = 0xC384997000000000LL;
        int v9 = 0x80000000;
      }

      else
      {
        unint64_t v8 = (unint64_t)&icu::Calendar::kYearPrecedence[1][1][1];
        if (v7 >= 2147483650.0)
        {
          unint64_t v8 = 0x4384996FFFD6CD20LL;
          *(void *)(v4 + 640) = 0x4384996FFFD6CD20LL;
          *(void *)(v4 + 624) = 0x4384996FFFD6CD20LL;
          int v9 = 0x7FFFFFFF;
        }

        else
        {
          *(double *)(v4 + 640) = v7 * 86400000.0;
          *(double *)(v4 + 624) = a2;
          int v9 = (int)v7;
        }
      }

      this = (icu::GregorianCalendar *)icu::UMemory::operator new((uint64_t *)v8, (icu::UMemory *)0x290, v6);
      if (this)
      {
        unint64_t v11 = this;
        TimeZone = (const icu::TimeZone *)icu::Calendar::getTimeZone(v10, (icu::Calendar *)v4);
        this = icu::GregorianCalendar::GregorianCalendar(v11, TimeZone, a3);
        if (*(int *)a3 <= 0)
        {
          icu::Calendar::setTimeInMillis((uint64_t)v11, a2, a3);
          *(_DWORD *)(v4 + 648) = icu::Calendar::get(v11, 1u, a3);
          *(_DWORD *)(v4 + 632) = v9;
          return (icu::GregorianCalendar *)(*(uint64_t (**)(icu::GregorianCalendar *))(*(void *)v11 + 8LL))(v11);
        }
      }

      else
      {
        *a3 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }

  return this;
}

_DWORD *icu::GregorianCalendar::handleComputeFields(_DWORD *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v4 = (uint64_t)this;
    int v18 = 0;
    if (this[158] <= a2)
    {
      int v13 = this[73];
      int v14 = this[75];
      int v15 = this[74];
      int v6 = this[72];
    }

    else
    {
      int v5 = a2 - 1721424;
      int v6 = sub_1808FA26C(1461, &v18, (double)(a2 - 1721424) * 4.0 + 1464.0);
      this = (_DWORD *)sub_1808FA234(v6 - 1, 4);
      int v7 = v5 - (_DWORD)this - 365 * (v6 - 1);
      if ((v6 & 3) != 0) {
        int v8 = 59;
      }
      else {
        int v8 = 60;
      }
      int v9 = (__int16 *)&unk_180A38AD0;
      if ((v6 & 3) != 0) {
        int v10 = 2;
      }
      else {
        int v10 = 1;
      }
      if ((v6 & 3) == 0) {
        int v9 = (__int16 *)&unk_180A38AB8;
      }
      if (v7 >= v8) {
        int v11 = v10;
      }
      else {
        int v11 = 0;
      }
      uint64_t v12 = 1497972245LL * (12 * (v11 + v7) + 6);
      int v13 = (v12 >> 39) + ((unint64_t)v12 >> 63);
      int v14 = v7 - v9[v13] + 1;
      int v15 = v7 + 1;
    }

    if (v6 == *(_DWORD *)(v4 + 648) && *(_DWORD *)(v4 + 632) <= a2)
    {
      int v16 = sub_1808FA250(v6 - 1LL, 400LL);
      this = (_DWORD *)sub_1808FA250(v6 - 1LL, 100LL);
      v15 += v16 - (_DWORD)this + 2;
    }

    *(_DWORD *)(v4 + 20) = v13;
    *(_DWORD *)(v4 + 140) = 1;
    *(_BYTE *)(v4 + 110) = 1;
    *(_DWORD *)(v4 + 104) = v13;
    *(_DWORD *)(v4 + 224) = 1;
    *(_BYTE *)(v4 + 13sub_1808F7164((uint64_t)v14, 1) = 1;
    *(_WORD *)(v4 + 113) = 257;
    *(_DWORD *)(v4 + 32) = v14;
    *(_DWORD *)(v4 + 36) = v15;
    *(void *)(v4 + 152) = 0x100000001LL;
    *(_DWORD *)(v4 + 88) = v6;
    *(_DWORD *)(v4 + 208) = 1;
    *(_BYTE *)(v4 + 127) = 1;
    int v17 = 1 - v6;
    if (v6 > 0) {
      int v17 = v6;
    }
    *(_WORD *)(v4 + 108) = 257;
    *(_DWORD *)(v4 + 12) = v6 > 0;
    *(_DWORD *)(v4 + 16) = v17;
    *(void *)(v4 + 132) = 0x100000001LL;
  }

  return this;
}

double icu::GregorianCalendar::getGregorianChange(icu::GregorianCalendar *this)
{
  return *((double *)this + 78);
}

uint64_t icu::GregorianCalendar::isLeapYear(icu::GregorianCalendar *this, int a2)
{
  int v2 = *((_DWORD *)this + 162);
  BOOL v3 = v2 > a2;
  if ((a2 & 3) != 0) {
    BOOL v3 = 0;
  }
  HIDWORD(v5) = -1030792151 * a2 + 85899344;
  LODWORD(v5) = HIDWORD(v5);
  unsigned int v4 = v5 >> 2;
  LODWORD(v5) = HIDWORD(v5);
  BOOL v6 = (v5 >> 4) < 0xA3D70B;
  unsigned int v7 = v4 > 0x28F5C28 || v6;
  if (v2 <= a2 && (a2 & 3) == 0) {
    return v7;
  }
  else {
    return v3;
  }
}

uint64_t icu::GregorianCalendar::handleComputeJulianDay(uint64_t a1, unsigned int a2)
{
  *(_BYTE *)(a1 + 653) = 0;
  uint64_t v4 = icu::Calendar::handleComputeJulianDay(a1, a2);
  uint64_t v5 = v4;
  if (a2 == 3 && *(_DWORD *)(a1 + 88) == *(_DWORD *)(a1 + 648) && (int)v4 >= *(_DWORD *)(a1 + 632))
  {
    *(_BYTE *)(a1 + 653) = 1;
    return icu::Calendar::handleComputeJulianDay(a1, 3u);
  }

  if (*(_BYTE *)(a1 + 652) == (int)v4 >= *(_DWORD *)(a1 + 632))
  {
    if (!*(_BYTE *)(a1 + 652)) {
      return v5;
    }
LABEL_8:
    uint64_t v6 = *(int *)(a1 + 88);
    if ((_DWORD)v6 == *(_DWORD *)(a1 + 648))
    {
      uint64_t v7 = v6 - 1;
      int v8 = sub_1808FA250(v6 - 1, 400LL);
      int v9 = sub_1808FA250(v7, 100LL);
      if (a2 == 4)
      {
        return (v5 + 14);
      }

      else if (a2 == 6)
      {
        return (v5 + v9 - v8 - 2);
      }
    }

    return v5;
  }

  *(_BYTE *)(a1 + 653) = 1;
  uint64_t v5 = icu::Calendar::handleComputeJulianDay(a1, a2);
  if (*(_BYTE *)(a1 + 652)) {
    goto LABEL_8;
  }
  return v5;
}

uint64_t icu::GregorianCalendar::handleComputeMonthStart(icu::GregorianCalendar *this, int a2, int a3)
{
  int v3 = a2;
  int v18 = a3;
  BOOL v5 = (v3 & 3) == 0;
  uint64_t v6 = v3 - 1LL;
  uint64_t v7 = sub_1808FA250(v6, 4LL);
  int v8 = *((_DWORD *)this + 162);
  BOOL v9 = v3 >= v8;
  *((_BYTE *)this + 652) = v9;
  if (*((_BYTE *)this + 653))
  {
    BOOL v9 = v3 < v8;
    *((_BYTE *)this + 652) = v9;
  }

  uint64_t v10 = v7 + 365 * v6 + 1721423;
  if (v9)
  {
    HIDWORD(v12) = -1030792151 * v3 + 85899344;
    LODWORD(v12) = HIDWORD(v12);
    unsigned int v11 = v12 >> 2;
    LODWORD(v12) = HIDWORD(v12);
    BOOL v13 = (v12 >> 4) < 0xA3D70B;
    int v14 = v11 > 0x28F5C28 || v13;
    if ((v3 & 3) != 0) {
      BOOL v5 = 0;
    }
    else {
      BOOL v5 = v14;
    }
    int v15 = sub_1808FA250(v3 - 1LL, 400LL);
    v10 += (int)(v15 - sub_1808FA250(v6, 100LL) + 2);
  }

  if (v18)
  {
    int v16 = (__int16 *)&unk_180A38AD0;
    if (v5) {
      int v16 = (__int16 *)&unk_180A38AB8;
    }
    v10 += v16[v18];
  }

  return v10;
}

uint64_t icu::GregorianCalendar::handleGetMonthLength(icu::GregorianCalendar *this, int a2, int a3)
{
  int v3 = a2;
  int v14 = a3;
  int v5 = *((_DWORD *)this + 162);
  int v6 = v3 & 3;
  if (v5 > v3 || v6 != 0)
  {
    uint64_t v8 = v14;
    if (v5 <= v3 || v6 != 0) {
      goto LABEL_16;
    }
LABEL_17:
    unint64_t v12 = (char *)&unk_180A38AE8;
    return v12[v8];
  }

  HIDWORD(v10) = -1030792151 * v3 + 85899344;
  LODWORD(v10) = HIDWORD(v10);
  if ((v10 >> 2) >= 0x28F5C29)
  {
    uint64_t v8 = v14;
    goto LABEL_17;
  }

  uint64_t v8 = v14;
  HIDWORD(v1sub_1808F7164((uint64_t)v14, 1) = -1030792151 * v3 + 85899344;
  LODWORD(v1sub_1808F7164((uint64_t)v14, 1) = HIDWORD(v11);
LABEL_16:
  unint64_t v12 = (char *)&unk_180A38AF4;
  return v12[v8];
}

uint64_t icu::GregorianCalendar::handleGetYearLength(icu::GregorianCalendar *this, int a2)
{
  int v2 = *((_DWORD *)this + 162);
  if (v2 <= a2 && (a2 & 3) == 0)
  {
    HIDWORD(v5) = -1030792151 * a2 + 85899344;
    LODWORD(v5) = HIDWORD(v5);
    return 366LL;
  }

  uint64_t result = 365LL;
  if ((a2 & 3) == 0 && v2 > a2) {
    return 366LL;
  }
  return result;
}

uint64_t icu::GregorianCalendar::monthLength(icu::GregorianCalendar *this, uint64_t a2)
{
  return (*(uint64_t (**)(icu::GregorianCalendar *, void, uint64_t))(*(void *)this + 312LL))( this,  *((unsigned int *)this + 22),  a2);
}

uint64_t icu::GregorianCalendar::monthLength(icu::GregorianCalendar *this, int a2, int a3)
{
  int v3 = *((_DWORD *)this + 162);
  if (v3 <= a3 && (a3 & 3) == 0)
  {
    HIDWORD(v6) = -1030792151 * a3 + 85899344;
    LODWORD(v6) = HIDWORD(v6);
    if ((v6 >> 2) < 0x28F5C29)
    {
      HIDWORD(v9) = -1030792151 * a3 + 85899344;
      LODWORD(v9) = HIDWORD(v9);
      if ((v9 >> 4) >= 0xA3D70B)
      {
        uint64_t v7 = (char *)&unk_180A38AF4;
        goto LABEL_10;
      }
    }

uint64_t icu::GregorianCalendar::yearLength(icu::GregorianCalendar *this)
{
  int v1 = *((_DWORD *)this + 4);
  int v2 = *((_DWORD *)this + 162);
  int v3 = v1 & 3;
  if (v2 <= v1 && v3 == 0)
  {
    HIDWORD(v7) = -1030792151 * v1 + 85899344;
    LODWORD(v7) = HIDWORD(v7);
    return 366LL;
  }

  if (v2 > v1 && v3 == 0) {
    return 366LL;
  }
  return 365LL;
}

BOOL icu::GregorianCalendar::validateFields(icu::GregorianCalendar *this)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    if ((v2 - 7) <= 0xFFFFFFFD && icu::Calendar::isSet((uint64_t)this, v2))
    {
      int v3 = *((_DWORD *)this + v2 + 3);
      if ((*(int (**)(icu::GregorianCalendar *, uint64_t))(*(void *)this + 112LL))(this, v2) > v3
        || (*(int (**)(icu::GregorianCalendar *, uint64_t))(*(void *)this + 128LL))(this, v2) < v3)
      {
        return 0LL;
      }
    }

    if (++v2 == 24)
    {
      if (icu::Calendar::isSet((uint64_t)this, 5u))
      {
        int v4 = *((_DWORD *)this + 8);
        uint64_t v5 = (*(uint64_t (**)(icu::GregorianCalendar *))(*(void *)this + 264LL))(this);
      }

      int v6 = *((_DWORD *)this + 9);
      if (v6 < 1) {
        return 0LL;
      }
      int v7 = *((_DWORD *)this + 4);
      int v8 = *((_DWORD *)this + 162);
      if (v8 > v7 || (v7 & 3) != 0)
      {
        unsigned int v11 = 365;
        if (v8 <= v7 || (v7 & 3) != 0) {
          goto LABEL_22;
        }
      }

      else
      {
        HIDWORD(v9) = -1030792151 * v7 + 85899344;
        LODWORD(v9) = HIDWORD(v9);
        if ((v9 >> 2) <= 0x28F5C28 && v7 % 400 != 0)
        {
          unsigned int v11 = 365;
LABEL_22:
          if (v6 > v11) {
            return 0LL;
          }
          return !icu::Calendar::isSet((uint64_t)this, 8u) || *((_DWORD *)this + 11);
        }
      }

      unsigned int v11 = 366;
      goto LABEL_22;
    }
  }

BOOL icu::GregorianCalendar::boundsCheck(uint64_t a1, int a2, uint64_t a3)
{
  return (*(int (**)(uint64_t, uint64_t))(*(void *)a1 + 112LL))(a1, a3) <= a2
      && (*(int (**)(uint64_t, uint64_t))(*(void *)a1 + 128LL))(a1, a3) >= a2;
}

double icu::GregorianCalendar::getEpochDay(icu::GregorianCalendar *this, UErrorCode *a2)
{
  uint64_t v3 = 274877907LL * (*((_DWORD *)this + 19) + *((_DWORD *)this + 18));
  return uprv_floor((*((double *)this + 29) / 1000.0 + (double)(int)((v3 >> 38) + ((unint64_t)v3 >> 63))) / 86400.0);
}

double icu::GregorianCalendar::computeJulianDayOfYear( icu::GregorianCalendar *this, int a2, BOOL *a3, signed __int8 *a4)
{
  int v6 = (int)this;
  *a3 = (a2 & 3) == 0;
  double v7 = (double)(int)sub_1808FA234(a2 - 1, 4) + (double)(a2 - 1) * 365.0 + 1721423.0;
  if (v6)
  {
    HIDWORD(v9) = -1030792151 * a2 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    unsigned int v8 = v9 >> 2;
    LODWORD(v9) = HIDWORD(v9);
    BOOL v10 = (v9 >> 4) < 0xA3D70B;
    char v11 = v8 > 0x28F5C28 || v10;
    if (*a3) {
      char v12 = v11;
    }
    else {
      char v12 = 0;
    }
    *a3 = v12;
    uint64_t v13 = a2 - 1LL;
    int v14 = sub_1808FA250(v13, 400LL);
    return v7 + (double)(int)(v14 - sub_1808FA250(v13, 100LL) + 2);
  }

  return v7;
}

double icu::GregorianCalendar::millisToJulianDay(icu::GregorianCalendar *this, double a2)
{
  return uprv_floor(a2 / 86400000.0) + 2440588.0;
}

double icu::GregorianCalendar::julianDayToMillis(icu::GregorianCalendar *this, double a2)
{
  return (a2 + -2440588.0) * 86400000.0;
}

uint64_t icu::GregorianCalendar::aggregateStamp(icu::GregorianCalendar *this, uint64_t a2, int a3)
{
  if ((_DWORD)a2 && a3) {
    return uprv_max(a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t icu::GregorianCalendar::roll(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
}

double *icu::GregorianCalendar::roll(double *result, uint64_t a2, int a3, UErrorCode *a4)
{
  double v7 = result;
  int v8 = icu::Calendar::get(result, 0x13u, a4);
  int v9 = 0;
  int v10 = 1;
  double v11 = 0.0;
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    int v12 = 0;
    if (v8 != *((_DWORD *)v7 + 162)) {
      goto LABEL_15;
    }
    uint64_t v13 = (*(uint64_t (**)(double *))(*(void *)v7 + 264LL))(v7);
    int v14 = (*(uint64_t (**)(double *, uint64_t))(*(void *)v7 + 448LL))(v7, v13);
    double v15 = v7[29];
    int v16 = *((_DWORD *)v7 + 8);
    double v17 = v7[78];
    if (v15 < v17) {
      int v18 = 0;
    }
    else {
      int v18 = -10;
    }
    int v9 = v18 + v16;
    double v11 = v15 + (double)(v18 + v16 - 1) * -86400000.0;
    if (v11 >= v17)
    {
      int v12 = 0;
    }

    else
    {
      int v12 = v14 - 10;
      if (v11 + (double)(v14 - 10) * 86400000.0 >= v17)
      {
        int v10 = 0;
        goto LABEL_15;
      }
    }

    int v10 = 1;
  }

  else
  {
    int v12 = 0;
  }

uint64_t icu::GregorianCalendar::getActualMinimum(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
}

{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
}

{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
}

uint64_t icu::GregorianCalendar::handleGetLimit(uint64_t a1, int a2, int a3)
{
  return dword_180A38B00[4 * a2 + a3];
}

uint64_t icu::GregorianCalendar::getActualMaximum(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  if ((_DWORD)a2 != 1) {
    return icu::Calendar::getActualMaximum(a1, a2, a3);
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  if (v6)
  {
    double v7 = (icu::Calendar *)v6;
    uint64_t v4 = 1LL;
    icu::Calendar::setLenient(v6, 1);
    int v8 = icu::Calendar::get(v7, 0, a3);
    double TimeInMillis = icu::Calendar::getTimeInMillis(v7, a3);
    int v10 = 140743;
    do
    {
      else {
        int v11 = v10 + v4;
      }
      int v12 = v11 >> 1;
      icu::Calendar::set(v7, 1u, v11 >> 1);
      if (icu::Calendar::get(v7, 1u, a3) == v11 >> 1 && icu::Calendar::get(v7, 0, a3) == v8)
      {
        uint64_t v4 = (v11 >> 1);
        int v12 = v10;
      }

      else
      {
        icu::Calendar::setTimeInMillis((uint64_t)v7, TimeInMillis, a3);
        int v10 = v11 >> 1;
      }
    }

    while ((int)v4 + 1 < v12);
    (*(void (**)(icu::Calendar *))(*(void *)v7 + 8LL))(v7);
  }

  else
  {
    uint64_t v4 = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v4;
}

uint64_t icu::GregorianCalendar::handleGetExtendedYear(icu::GregorianCalendar *this)
{
  int v1 = *((_DWORD *)this + 52);
  int v2 = *((_DWORD *)this + 34);
  if (v1 < v2) {
    unsigned int v3 = 1;
  }
  else {
    unsigned int v3 = 19;
  }
  if (*((_DWORD *)this + v3 + 33) < *((_DWORD *)this + 50)) {
    unsigned int v3 = 17;
  }
  if (v3 == 1)
  {
    if (*((int *)this + 33) < 1 || *((_DWORD *)this + 3))
    {
      if (v2 >= 1) {
        return *((unsigned int *)this + 4);
      }
      return 1970LL;
    }

    if (v2 < 1) {
      return 0LL;
    }
    else {
      return (1 - *((_DWORD *)this + 4));
    }
  }

  else
  {
    if (v3 != 17)
    {
      if (v1 >= 1) {
        return *((unsigned int *)this + 22);
      }
      return 1970LL;
    }

    return (*(uint64_t (**)(icu::GregorianCalendar *, void, void))(*(void *)this + 344LL))( this,  *((unsigned int *)this + 20),  *((unsigned int *)this + 6));
  }

uint64_t icu::GregorianCalendar::handleGetExtendedYearFromWeekFields( icu::GregorianCalendar *this, uint64_t a2, int a3)
{
  if (*((int *)this + 33) >= 1)
  {
    if (*((_DWORD *)this + 3)) {
      a2 = a2;
    }
    else {
      a2 = (1 - a2);
    }
  }

  return icu::Calendar::handleGetExtendedYearFromWeekFields(this, a2, a3);
}

uint64_t icu::GregorianCalendar::internalGetEra(icu::GregorianCalendar *this)
{
  else {
    return 1LL;
  }
}

const char *icu::GregorianCalendar::getType(icu::GregorianCalendar *this)
{
  return "gregorian";
}

uint64_t icu::GregorianCalendar::haveDefaultCentury(icu::GregorianCalendar *this)
{
  return 1LL;
}

double icu::GregorianCalendar::defaultCenturyStart(icu::GregorianCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C4493F8);
  if (v1 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C4493F8))
  {
    sub_1808FA11C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C4493F8);
  }

  return *(double *)&qword_18C4483D8;
}

void sub_1808FA11C()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  UErrorCode v2 = U_ZERO_ERROR;
  bzero(v3, 0x290uLL);
  unsigned int v0 = icu::GregorianCalendar::GregorianCalendar((icu::GregorianCalendar *)v3, &v2);
  if (v2 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v3, v1, &v2);
    icu::Calendar::add(v3, 1u, -80, &v2);
    qword_18C4483D8 = icu::Calendar::getTimeInMillis((icu::Calendar *)v3, &v2);
    dword_18C4483E0 = icu::Calendar::get(v3, 1u, &v2);
  }

  icu::Calendar::~Calendar((icu::Calendar *)v3);
}

uint64_t icu::GregorianCalendar::defaultCenturyStartYear(icu::GregorianCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C4493F8);
  if (v1 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C4493F8))
  {
    sub_1808FA11C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C4493F8);
  }

  return dword_18C4483E0;
}

uint64_t sub_1808FA234(int a1, int a2)
{
  if (a1 < 0) {
    return ((a1 + 1) / a2 - 1);
  }
  else {
    return (a1 / a2);
  }
}

uint64_t sub_1808FA250(uint64_t a1, uint64_t a2)
{
  if (a1 < 0) {
    return (a1 + 1) / a2 - 1;
  }
  else {
    return a1 / a2;
  }
}

uint64_t sub_1808FA26C(int a1, _DWORD *a2, double a3)
{
  double v5 = (double)a1;
  double v6 = uprv_floor(a3 / (double)a1);
  if (a2) {
    *a2 = (int)(uprv_floor(a3) - v6 * v5);
  }
  return (int)v6;
}

void sub_1808FA2C8(double *a1, double a2, double a3)
{
  double v6 = uprv_floor(a2 / a3);
  double v7 = a2 - v6 * a3;
  double v8 = -1.0;
  if (v7 < 0.0 || (double v8 = 1.0, v7 >= a3))
  {
    double v9 = v6 + v8;
    double v7 = a2 - v9 * a3;
    if (v6 == v9) {
      double v7 = 0.0;
    }
  }

  if (a1) {
    *a1 = v7;
  }
}

double sub_1808FA338(int a1, int a2, int a3)
{
  unsigned int v3 = a1 - 1;
  int v4 = 365 * (a1 - 1);
  if (a1 < 1)
  {
    unsigned int v5 = ~(-a1 / 0x190u) - (-a1 >> 2) + v4 + 1721422;
    unsigned int v6 = ~(-a1 / 0x64u);
  }

  else
  {
    unsigned int v5 = (v3 >> 2) + 1721422 + v4 + v3 / 0x190 + 1;
    unsigned int v6 = v3 / 0x64;
  }

  HIDWORD(v8) = -1030792151 * a1 + 85899344;
  LODWORD(v8) = HIDWORD(v8);
  unsigned int v7 = v8 >> 2;
  LODWORD(v8) = HIDWORD(v8);
  else {
    int v9 = 12;
  }
  if (v7 <= 0x28F5C28) {
    int v10 = v9;
  }
  else {
    int v10 = 12;
  }
  if ((a1 & 3) != 0) {
    int v10 = 0;
  }
  return (double)(int)(a3 + v5 - v6 + word_180A38CC0[v10 + a2] + 2) + -2440588.0;
}

void sub_1808FA420(int *a1, _DWORD *a2, _DWORD *a3, int *a4, int *a5, double a6)
{
  double v11 = a6 + 719162.0;
  double v12 = uprv_floor((a6 + 719162.0) / 146097.0);
  int v13 = (int)(uprv_floor(v11) - v12 * 146097.0);
  int v14 = (int)v12;
  *a5 = v13;
  double v15 = (double)v13;
  double v16 = uprv_floor((double)v13 / 36524.0);
  int v17 = (int)(uprv_floor(v15) - v16 * 36524.0);
  int v18 = (int)v16;
  *a5 = v17;
  double v19 = (double)v17;
  double v20 = uprv_floor((double)v17 / 1461.0);
  int v21 = (int)(uprv_floor(v19) - v20 * 1461.0);
  int v22 = (int)v20;
  *a5 = v21;
  double v23 = (double)v21;
  double v24 = uprv_floor((double)v21 / 365.0);
  *a5 = (int)(uprv_floor(v23) - v24 * 365.0);
  int v25 = 400 * v14 + 100 * v18 + 4 * v22 + (int)v24;
  *a1 = v25;
  if (v18 == 4 || (int)v24 == 4)
  {
    *a5 = 365;
    int v26 = *a1;
  }

  else
  {
    int v26 = v25 + 1;
    *a1 = v25 + 1;
  }

  BOOL v27 = 1;
  if ((v26 & 3) == 0)
  {
    int v28 = -1030792151 * v26 + 85899344;
    HIDWORD(v29) = v28;
    LODWORD(v29) = v28;
    if ((v29 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v30) = v28;
      LODWORD(v30) = v28;
      BOOL v27 = (v30 >> 4) > 0xA3D70A;
    }

    else
    {
      BOOL v27 = 0;
    }
  }

  int v31 = (int)uprv_fmod(v11 + 1.0, 7.0);
  if (v31 >= 0) {
    int v32 = v31 + 1;
  }
  else {
    int v32 = v31 + 8;
  }
  *a4 = v32;
  if (v27) {
    int v33 = 59;
  }
  else {
    int v33 = 60;
  }
  int v34 = *a5;
  if (v27) {
    int v35 = 2;
  }
  else {
    int v35 = 1;
  }
  if (v27) {
    int v36 = 0;
  }
  else {
    int v36 = 12;
  }
  if (v34 >= v33) {
    int v37 = v35;
  }
  else {
    int v37 = 0;
  }
  uint64_t v38 = 1497972245LL * (12 * (v37 + v34) + 6);
  LODWORD(v38) = (v38 >> 39) + ((unint64_t)v38 >> 63);
  *a2 = v38;
  *a3 = *a5 - word_180A38CC0[(int)v38 + v36] + 1;
  ++*a5;
}

void sub_1808FA670(int *a1, _DWORD *a2, _DWORD *a3, int *a4, int *a5, _DWORD *a6, double a7)
{
  double v14 = 0.0;
  sub_1808FA2C8(&v14, a7, 86400000.0);
  *a6 = (int)v14;
  sub_1808FA420(a1, a2, a3, a4, a5, v13);
}

uint64_t sub_1808FA6F0(double a1)
{
  double v1 = a1 + 5.0;
  double v2 = uprv_floor((a1 + 5.0) / 7.0);
  unsigned int v3 = (int)(uprv_floor(v1) - v2 * 7.0);
  if (v3) {
    return v3;
  }
  else {
    return 7LL;
  }
}

uint64_t sub_1808FA744(int a1, int a2, int a3)
{
  if ((a3 - 22) > 6)
  {
    else {
      return ((a3 + 6) / 7);
    }
  }

  else
  {
    if ((a1 & 3) != 0)
    {
      int v3 = 0;
    }

    else
    {
      int v3 = 12;
      HIDWORD(v5) = -1030792151 * a1 + 85899344;
      LODWORD(v5) = HIDWORD(v5);
      if ((v5 >> 2) <= 0x28F5C28)
      {
        HIDWORD(v6) = -1030792151 * a1 + 85899344;
        LODWORD(v6) = HIDWORD(v6);
        else {
          int v3 = 12;
        }
      }
    }

    if (a3 + 7 > byte_180A38CF0[v3 + a2]) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 4LL;
    }
  }

icu::HebrewCalendar *icu::HebrewCalendar::HebrewCalendar( icu::HebrewCalendar *this, char **a2, UErrorCode *a3)
{
  unint64_t v6 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  unsigned int v7 = icu::Calendar::Calendar(this, v6, (const icu::Locale *)a2, a3);
  *(void *)this = off_1897240A0;
  icu::Calendar::getNow(v7);
  icu::Calendar::setTimeInMillis((uint64_t)this, v8, a3);
  return this;
}

void icu::HebrewCalendar::~HebrewCalendar(icu::HebrewCalendar *this)
{
}

const char *icu::HebrewCalendar::getType(icu::HebrewCalendar *this)
{
  return "hebrew";
}

uint64_t *icu::HebrewCalendar::clone@<X0>( icu::HebrewCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *uint64_t result = (uint64_t)off_1897240A0;
  }

  return result;
}

void *icu::HebrewCalendar::HebrewCalendar(icu::HebrewCalendar *this, const icu::HebrewCalendar *a2)
{
  uint64_t result = (void *)icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *uint64_t result = off_1897240A0;
  return result;
}

{
  void *result;
  uint64_t result = (void *)icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *uint64_t result = off_1897240A0;
  return result;
}

_BYTE *icu::HebrewCalendar::add(_BYTE *result, unsigned int a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    unint64_t v6 = result;
    if (a2 == 23 || a2 == 2)
    {
      int v7 = icu::Calendar::get(result, 2u, a4);
      int v8 = icu::Calendar::get(v6, 1u, a4);
      int v9 = v8;
      int v10 = v7 + a3;
      if (a3 < 1)
      {
        int v13 = 12 * v8 + 17;
        if (v7 <= 5) {
          goto LABEL_21;
        }
        while (1)
        {
          if (v10 <= 5)
          {
            if (v13 % 19 >= 0) {
              int v14 = 12;
            }
            else {
              int v14 = -7;
            }
            v10 -= v13 % 19 < v14;
          }

BOOL icu::HebrewCalendar::isLeapYear(icu::HebrewCalendar *this)
{
  int v1 = (12 * (int)this + 17) % 19;
  if (v1 >= 0) {
    int v2 = 12;
  }
  else {
    int v2 = -7;
  }
  return v1 >= v2;
}

uint64_t icu::HebrewCalendar::add(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
}

_BYTE *icu::HebrewCalendar::roll(_BYTE *result, uint64_t a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    unint64_t v6 = result;
    if ((_DWORD)a2 == 23 || (_DWORD)a2 == 2)
    {
      int v7 = icu::Calendar::get(result, 2u, a4);
      int v8 = (int)(12 * icu::Calendar::get(v6, 1u, a4) + 17) % 19;
      if (v8 >= 0) {
        int v9 = 12;
      }
      else {
        int v9 = -7;
      }
      if (v8 < v9) {
        int v10 = 12;
      }
      else {
        int v10 = 13;
      }
      int v11 = a3 % v10 + v7;
      if (v8 < v9)
      {
        if (a3 < 1 || v7 > 4 || v11 < 5)
        {
          int v14 = a3 < 0 && v7 > 5 && v11 < 6;
          v11 -= v14;
        }

        else
        {
          ++v11;
        }
      }

      icu::Calendar::set(v6, 2u, (v11 + 13) % 13);
      return (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, UErrorCode *))(*(void *)v6 + 392LL))(v6, 5LL, a4);
    }

    else
    {
      return icu::Calendar::roll(result, a2, a3, a4);
    }
  }

  return result;
}

uint64_t icu::HebrewCalendar::monthsInYear(icu::HebrewCalendar *this)
{
  int v1 = (12 * (int)this + 17) % 19;
  if (v1 >= 0) {
    int v2 = 12;
  }
  else {
    int v2 = -7;
  }
  if (v1 < v2) {
    return 12LL;
  }
  else {
    return 13LL;
  }
}

uint64_t icu::HebrewCalendar::roll(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
}

uint64_t icu::HebrewCalendar::startOfYear(icu::HebrewCalendar *this, int *a2, UErrorCode *a3)
{
  signed int v4 = (int)this;
  sub_1809B36C0(0xAu, (uint64_t)sub_1808FAE9C);
  uint64_t v5 = sub_180896930((uint64_t **)&qword_18C449400, v4, a2);
  if (!(_DWORD)v5)
  {
    int v6 = sub_1808FA250(235LL * v4 - 234, 19LL);
    uint64_t v7 = 13753LL * v6 + 12084;
    signed int v8 = v7 / 25920 + 29 * v6;
    uint64_t v9 = v7 % 25920;
    BOOL v10 = (v8 % 7) > 6 || ((1 << (v8 % 7)) & 0x54) == 0;
    if (v10) {
      uint64_t v5 = v8;
    }
    else {
      uint64_t v5 = (v8 + 1);
    }
    if (v10) {
      int v11 = v8 % 7;
    }
    else {
      int v11 = (v8 + 1) % 7;
    }
    if (v9 >= 16405 && v11 == 1)
    {
      int v16 = (12 * v4 + 17) % 19;
      if (v16 >= 0) {
        int v17 = 12;
      }
      else {
        int v17 = -7;
      }
      if (v16 >= v17) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = (v5 + 2);
      }
    }

    else if (v9 >= 23270 && v11 == 0)
    {
      int v14 = (12 * v4 + 5) % 19;
      if (v14 >= 0) {
        int v15 = 12;
      }
      else {
        int v15 = -7;
      }
      if (v14 < v15) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = (v5 + 1);
      }
    }

    sub_1808969CC((uint64_t **)&qword_18C449400, v4, v5, a2);
  }

  return v5;
}

uint64_t sub_1808FAE9C()
{
  if (qword_18C449400) {
    (*(void (**)(uint64_t))(*(void *)qword_18C449400 + 8LL))(qword_18C449400);
  }
  qword_18C449400 = 0LL;
  return 1LL;
}

uint64_t icu::HebrewCalendar::absoluteDayToDayOfWeek(icu::HebrewCalendar *this)
{
  return ((int)this % 7 + 1);
}

uint64_t icu::HebrewCalendar::yearType(icu::HebrewCalendar *this)
{
  int v1 = (*(uint64_t (**)(icu::HebrewCalendar *))(*(void *)this + 320LL))(this);
  int v2 = v1 - 30;
  if (v1 <= 380) {
    int v2 = v1;
  }
  unsigned int v3 = v2 - 353;
  if (v3 >= 3) {
    return 1LL;
  }
  else {
    return v3;
  }
}

uint64_t icu::HebrewCalendar::handleGetLimit(uint64_t a1, int a2, int a3)
{
  return dword_180A38D28[4 * a2 + a3];
}

uint64_t icu::HebrewCalendar::handleGetMonthLength(icu::HebrewCalendar *this, uint64_t a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0)
  {
    int v6 = 12 * a2 + 5;
    do
    {
      a2 = (a2 - 1);
      if (v6 % 19 >= 0) {
        int v7 = 12;
      }
      else {
        int v7 = -7;
      }
      if (v6 % 19 < v7) {
        int v8 = 12;
      }
      else {
        int v8 = 13;
      }
      a3 += v8;
      v6 -= 12;
    }

    while ((a3 & 0x80000000) != 0);
  }

  else if (a3 >= 0xD)
  {
    int v3 = 12 * a2 + 17;
    do
    {
      a2 = (a2 + 1);
      if (v3 % 19 >= 0) {
        int v4 = 12;
      }
      else {
        int v4 = -7;
      }
      if (v3 % 19 >= v4) {
        int v5 = -13;
      }
      else {
        int v5 = -12;
      }
      a3 += v5;
      v3 += 12;
    }

    while (a3 > 0xC);
  }

  uint64_t v9 = a3;
  if (a3 - 1 > 1)
  {
    int v13 = (char *)&unk_180A38EA8 + 3 * a3;
  }

  else
  {
    int v10 = (*(uint64_t (**)(icu::HebrewCalendar *, uint64_t))(*(void *)this + 320LL))(this, a2);
    int v11 = v10 - 30;
    if (v10 <= 380) {
      int v11 = v10;
    }
    LODWORD(v12) = v11 - 353;
    else {
      uint64_t v12 = v12;
    }
    int v13 = (char *)&unk_180A38EA8 + 3 * v9 + v12;
  }

  return *v13;
}

uint64_t icu::HebrewCalendar::handleGetYearLength( icu::HebrewCalendar *this, icu::HebrewCalendar *a2, UErrorCode *a3)
{
  int v7 = 0;
  int v4 = icu::HebrewCalendar::startOfYear((icu::HebrewCalendar *)((_DWORD)a2 + 1), &v7, a3);
  return v4 - icu::HebrewCalendar::startOfYear(a2, &v7, v5);
}

_DWORD *icu::HebrewCalendar::validateField(_DWORD *a1, uint64_t a2, int *a3)
{
  if ((_DWORD)a2 != 23 && (_DWORD)a2 != 2) {
    return icu::Calendar::validateField(a1, a2, a3);
  }
  int v6 = (int)(12 * (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 328LL))(a1) + 17) % 19;
  int v7 = v6 >= 0 ? 12 : -7;
  if (v6 >= v7) {
    return icu::Calendar::validateField(a1, a2, a3);
  }
  uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 264LL))(a1);
  if ((_DWORD)result != 5) {
    return icu::Calendar::validateField(a1, a2, a3);
  }
  *a3 = 1;
  return result;
}

uint64_t icu::HebrewCalendar::handleComputeFields(icu::HebrewCalendar *this, int a2, UErrorCode *a3)
{
  int v5 = a2 - 347997;
  double v6 = uprv_floor((double)(a2 - 347997) * 25920.0 / 765433.0);
  int v7 = (icu::HebrewCalendar *)(int)(uprv_floor((v6 * 19.0 + 234.0) / 235.0) + 1.0);
  int v9 = icu::HebrewCalendar::startOfYear(v7, (int *)a3, v8);
  int v11 = v5 - v9;
  if (v5 <= v9)
  {
    do
    {
      int v7 = (icu::HebrewCalendar *)((_DWORD)v7 - 1);
      int v11 = v5 - icu::HebrewCalendar::startOfYear(v7, (int *)a3, v10);
    }

    while (v11 < 1);
  }

  uint64_t result = (*(uint64_t (**)(icu::HebrewCalendar *, icu::HebrewCalendar *))(*(void *)this + 320LL))(this, v7);
  uint64_t v13 = 0LL;
  int v14 = result - 30;
  unsigned int v15 = v14 - 353;
  if (v15 >= 3) {
    uint64_t v16 = 1LL;
  }
  else {
    uint64_t v16 = v15;
  }
  int v17 = (12 * (int)v7 + 17) % 19;
  if (v17 >= 0) {
    int v18 = 12;
  }
  else {
    int v18 = -7;
  }
  double v19 = (char *)&unk_180A38ED0 + 2 * v16;
  double v20 = (char *)&unk_180A38F24 + 2 * v16;
  while (1)
  {
    int v21 = v17 >= v18 ? v19 : v20;
    --v13;
    v19 += 6;
    v20 += 6;
    if (v13 == -14) {
      goto LABEL_28;
    }
  }

  if (!(_DWORD)v13)
  {
LABEL_28:
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    return result;
  }

  int v22 = ~(_DWORD)v13;
  double v23 = (char *)&unk_180A38ED0 + 6 * ~(_DWORD)v13 + 2 * v16;
  double v24 = (__int16 *)((char *)&unk_180A38F24 + 6 * ~(_DWORD)v13 + 2 * v16);
  if (v17 >= v18) {
    double v24 = (__int16 *)v23;
  }
  int v25 = *v24;
  *((_BYTE *)this + 108) = 1;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = (_DWORD)v7;
  *(void *)((char *)this + 132) = 0x100000001LL;
  *(_WORD *)((char *)this + 109) = 257;
  *((_DWORD *)this + 22) = (_DWORD)v7;
  int v26 = v11 - v25;
  *((_DWORD *)this + 52) = 1;
  *((_BYTE *)this + 127) = 1;
  else {
    int v28 = ~(_DWORD)v13;
  }
  *((_DWORD *)this + 26) = v28;
  *((_DWORD *)this + 56) = 1;
  *((_BYTE *)this + 13sub_1808F7164((uint64_t)v14, 1) = 1;
  *((_DWORD *)this + 5) = v22;
  *((_DWORD *)this + 35) = 1;
  *(_WORD *)((char *)this + 113) = 257;
  *((_DWORD *)this + 8) = v26;
  *((_DWORD *)this + 9) = v11;
  *((void *)this + 19) = 0x100000001LL;
  return result;
}

uint64_t icu::HebrewCalendar::handleGetExtendedYear(icu::HebrewCalendar *this)
{
  if (icu::Calendar::newerField((uint64_t)this, 0x13u, 1u) == 19)
  {
    if (*((int *)this + 52) >= 1)
    {
      int v2 = (char *)this + 88;
      return *(unsigned int *)v2;
    }
  }

  else if (*((int *)this + 34) >= 1)
  {
    int v2 = (char *)this + 16;
    return *(unsigned int *)v2;
  }

  return 1LL;
}

uint64_t icu::HebrewCalendar::handleComputeMonthStart( icu::HebrewCalendar *this, icu::HebrewCalendar *a2, UErrorCode *a3)
{
  unsigned int v3 = a3;
  int v4 = a2;
  int v21 = 0;
  if ((a3 & 0x80000000) != 0)
  {
    int v9 = 12 * (_DWORD)a2 + 5;
    do
    {
      int v4 = (icu::HebrewCalendar *)((_DWORD)v4 - 1);
      if (v9 % 19 >= 0) {
        int v10 = 12;
      }
      else {
        int v10 = -7;
      }
      if (v9 % 19 < v10) {
        int v11 = 12;
      }
      else {
        int v11 = 13;
      }
      v3 += v11;
      v9 -= 12;
    }

    while ((v3 & 0x80000000) != 0);
  }

  else if (a3 >= 0xD)
  {
    int v6 = 12 * (_DWORD)a2 + 17;
    do
    {
      int v4 = (icu::HebrewCalendar *)((_DWORD)v4 + 1);
      if (v6 % 19 >= 0) {
        int v7 = 12;
      }
      else {
        int v7 = -7;
      }
      if (v6 % 19 >= v7) {
        int v8 = -13;
      }
      else {
        int v8 = -12;
      }
      v3 += v8;
      v6 += 12;
    }

    while (v3 > 0xC);
  }

  int v12 = icu::HebrewCalendar::startOfYear(v4, &v21, a3);
  if (v21 > 0) {
    return 0LL;
  }
  int v14 = v12;
  if (v3)
  {
    int v15 = (12 * (int)v4 + 17) % 19;
    if (v15 >= 0) {
      int v16 = 12;
    }
    else {
      int v16 = -7;
    }
    int v17 = (*(uint64_t (**)(icu::HebrewCalendar *, icu::HebrewCalendar *))(*(void *)this + 320LL))(this, v4);
    int v18 = v17 - 30;
    if (v17 <= 380) {
      int v18 = v17;
    }
    unsigned int v19 = v18 - 353;
    if (v19 >= 3) {
      unsigned int v19 = 1;
    }
    double v20 = (__int16 *)&unk_180A38ED0;
    if (v15 < v16) {
      double v20 = (__int16 *)&unk_180A38F24;
    }
    v14 += v20[3 * v3 + v19];
  }

  return (v14 + 347997);
}

uint64_t icu::HebrewCalendar::getRelatedYear(icu::HebrewCalendar *this, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(this, 0x13u, a2) - 3760;
  else {
    return 0LL;
  }
}

_BYTE *icu::HebrewCalendar::setRelatedYear(icu::HebrewCalendar *this, int a2)
{
  return icu::Calendar::set(this, 0x13u, a2 + 3760);
}

uint64_t icu::HebrewCalendar::haveDefaultCentury(icu::HebrewCalendar *this)
{
  return 1LL;
}

double icu::HebrewCalendar::defaultCenturyStart(icu::HebrewCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C44940C);
  if (v1 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C44940C))
  {
    sub_1808FB62C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C44940C);
  }

  return *(double *)&qword_18C4483E8;
}

void sub_1808FB62C()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  UErrorCode v2 = U_ZERO_ERROR;
  bzero(v4, 0x270uLL);
  icu::Locale::Locale((icu::Locale *)v3, "@calendar=hebrew", 0LL, 0LL, 0LL);
  icu::HebrewCalendar::HebrewCalendar((icu::HebrewCalendar *)v4, v3, &v2);
  icu::Locale::~Locale((icu::Locale *)v3);
  if (v2 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v4, v1, &v2);
    if (v2 <= U_ZERO_ERROR) {
      icu::Calendar::add(v4, 1u, -80, &v2);
    }
    qword_18C4483E8 = icu::Calendar::getTimeInMillis((icu::Calendar *)v4, &v2);
    dword_18C4483F0 = icu::Calendar::get(v4, 1u, &v2);
  }

  icu::Calendar::~Calendar((icu::Calendar *)v4);
}

uint64_t icu::HebrewCalendar::defaultCenturyStartYear(icu::HebrewCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C44940C);
  if (v1 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C44940C))
  {
    sub_1808FB62C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C44940C);
  }

  return dword_18C4483F0;
}

BOOL icu::HebrewCalendar::inTemporalLeapYear(icu::HebrewCalendar *this, UErrorCode *a2)
{
  int v3 = icu::Calendar::get(this, 0x13u, a2);
  int v5 = (12 * v3 + 17) % 19;
  if (v5 >= 0) {
    int v6 = 12;
  }
  else {
    int v6 = -7;
  }
  return v5 >= v6;
}

char *icu::HebrewCalendar::getTemporalMonthCode(icu::HebrewCalendar *this, UErrorCode *a2)
{
  int v3 = icu::Calendar::get(this, 2u, a2);
  else {
    return 0LL;
  }
}

uint64_t icu::HebrewCalendar::setTemporalMonthCode(uint64_t this, const char *__s, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v5 = (_BYTE *)this;
    this = strlen(__s);
    if ((this - 3) > 1)
    {
LABEL_6:
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      uint64_t v6 = 0LL;
      while (1)
      {
        this = strcmp(__s, off_189724258[v6]);
        if (!(_DWORD)this) {
          return (uint64_t)icu::Calendar::set(v5, 2u, v6);
        }
        if (++v6 == 13) {
          goto LABEL_6;
        }
      }
    }
  }

  return this;
}

uint64_t icu::HebrewCalendar::internalGetMonth(icu::HebrewCalendar *this)
{
  int v2 = *((_DWORD *)this + 26);
  int v3 = (int)(12 * (*(uint64_t (**)(icu::HebrewCalendar *))(*(void *)this + 328LL))(this) + 17) % 19;
  if (v3 >= 0) {
    int v4 = 12;
  }
  else {
    int v4 = -7;
  }
  if (v3 >= v4 || v2 <= 5) {
    return v2;
  }
  else {
    return (v2 + 1);
  }
}

void *icu::HebrewCalendar::getStaticClassID(icu::HebrewCalendar *this)
{
  return &unk_18C535490;
}

void *icu::HebrewCalendar::getDynamicClassID(icu::HebrewCalendar *this)
{
  return &unk_18C535490;
}

uint64_t *icu::IndianCalendar::clone@<X0>( icu::IndianCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *uint64_t result = (uint64_t)off_1897242F0;
  }

  return result;
}

void *icu::IndianCalendar::IndianCalendar(icu::IndianCalendar *this, const icu::IndianCalendar *a2)
{
  uint64_t result = (void *)icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *uint64_t result = off_1897242F0;
  return result;
}

{
  void *result;
  uint64_t result = (void *)icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *uint64_t result = off_1897242F0;
  return result;
}

icu::IndianCalendar *icu::IndianCalendar::IndianCalendar( icu::IndianCalendar *this, char **a2, UErrorCode *a3)
{
  uint64_t v6 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  int v7 = icu::Calendar::Calendar(this, v6, (const icu::Locale *)a2, a3);
  *(void *)this = off_1897242F0;
  icu::Calendar::getNow(v7);
  icu::Calendar::setTimeInMillis((uint64_t)this, v8, a3);
  return this;
}

void icu::IndianCalendar::~IndianCalendar(icu::IndianCalendar *this)
{
}

const char *icu::IndianCalendar::getType(icu::IndianCalendar *this)
{
  return "indian";
}

uint64_t icu::IndianCalendar::handleGetLimit(uint64_t a1, int a2, int a3)
{
  return dword_180A38F90[4 * a2 + a3];
}

uint64_t icu::IndianCalendar::handleGetMonthLength(icu::IndianCalendar *this, int a2, int a3)
{
  int v3 = a2;
  int v10 = a3;
  HIDWORD(v5) = -1030792151 * (v3 + 78) + 85899344;
  LODWORD(v5) = HIDWORD(v5);
  unsigned int v4 = v5 >> 2;
  LODWORD(v5) = HIDWORD(v5);
  BOOL v6 = (v5 >> 4) < 0xA3D70B;
  int v7 = v4 > 0x28F5C28 || v6;
  if ((((_BYTE)v3 + 78) & 3) != 0) {
    int v8 = 0;
  }
  else {
    int v8 = v7;
  }
  if (v10) {
    int v8 = 0;
  }
  if (v8) {
    return 31LL;
  }
  else {
    return 30LL;
  }
}

uint64_t icu::IndianCalendar::handleGetYearLength(icu::IndianCalendar *this, int a2)
{
  if (((a2 + 78) & 3) != 0) {
    return 365LL;
  }
  HIDWORD(v3) = -1030792151 * (a2 + 78) + 85899344;
  LODWORD(v3) = HIDWORD(v3);
  HIDWORD(v4) = -1030792151 * (a2 + 78) + 85899344;
  LODWORD(v4) = HIDWORD(v4);
  else {
    return 366LL;
  }
}

uint64_t icu::IndianCalendar::handleComputeMonthStart(icu::IndianCalendar *this, int a2, int a3)
{
  int v3 = a2;
  int v15 = a3;
  if (a3 >= 0xC)
  {
    int v3 = sub_1808FA26C(12, &v15, (double)a3) + a2;
    a3 = v15;
  }

  if (a3 == 12) {
    int v4 = 1;
  }
  else {
    int v4 = a3 + 1;
  }
  int v5 = v3 + 78;
  if (((v3 + 78) & 3) == 0
    && ((HIDWORD(v6) = -1030792151 * v5 + 85899344, LODWORD(v6) = HIDWORD(v6), (v6 >> 2) <= 0x28F5C28)
      ? (BOOL v7 = v5 % 400 == 0)
      : (BOOL v7 = 1),
        v7))
  {
    double v8 = 31.0;
    int v9 = 21;
  }

  else
  {
    double v8 = 30.0;
    int v9 = 22;
  }

  double v10 = sub_1808FA338(v5, 2, v9) + 2440588.0 + -0.5;
  if (v4 != 1)
  {
    double v11 = v8 + v10;
    if (v4 >= 7) {
      int v12 = 7;
    }
    else {
      int v12 = v4;
    }
    double v13 = (double)(30 * v4 - 210);
    if (v4 <= 7) {
      double v13 = -0.0;
    }
    double v10 = v13 + v11 + (double)(31 * v12 - 62);
  }

  return (int)v10;
}

uint64_t icu::IndianCalendar::handleGetExtendedYear(icu::IndianCalendar *this)
{
  if (icu::Calendar::newerField((uint64_t)this, 0x13u, 1u) == 19)
  {
    if (*((int *)this + 52) >= 1)
    {
      int v2 = (char *)this + 88;
      return *(unsigned int *)v2;
    }
  }

  else if (*((int *)this + 34) >= 1)
  {
    int v2 = (char *)this + 16;
    return *(unsigned int *)v2;
  }

  return 1LL;
}

void icu::IndianCalendar::handleComputeFields(icu::IndianCalendar *this, int a2, UErrorCode *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v23 = 0;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  double v4 = (double)a2;
  sub_1808FA420((int *)&v22, (_DWORD *)&v22 + 1, &v23, (int *)&v21, (int *)&v21 + 1, (double)a2 + -2440588.0);
  int v5 = v22;
  int v6 = (int)(v4 - (sub_1808FA338(v22, 0, 1) + 2440588.0 + -0.5));
  if (v6 > 79)
  {
    int v7 = v5 - 78;
    HIDWORD(v13) = -1030792151 * v5 + 85899344;
    LODWORD(v13) = HIDWORD(v13);
    unsigned int v12 = v13 >> 2;
    LODWORD(v13) = HIDWORD(v13);
    else {
      int v14 = 31;
    }
    if (v12 <= 0x28F5C28) {
      int v15 = v14;
    }
    else {
      int v15 = 31;
    }
    if ((v5 & 3) != 0) {
      int v8 = 30;
    }
    else {
      int v8 = v15;
    }
    int v11 = -80;
  }

  else
  {
    int v7 = v5 - 79;
    int v8 = 30;
    if (((v5 - 1) & 3) == 0)
    {
      HIDWORD(v10) = -1030792151 * (v5 - 1) + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      unsigned int v9 = v10 >> 2;
      LODWORD(v10) = HIDWORD(v10);
      int v8 = (v10 >> 4) >= 0xA3D70B ? 30 : 31;
      if (v9 > 0x28F5C28) {
        int v8 = 31;
      }
    }

    int v11 = v8 + 255;
  }

  unsigned int v16 = v11 + v6;
  int v17 = v11 + v6 - v8;
  if (v11 + v6 >= v8)
  {
    if (v17 > 154)
    {
      unsigned int v20 = v17 - 155;
      int v18 = (int)uprv_floor((double)(v20 / 0x1E)) + 6;
      unsigned int v19 = v20 % 0x1E;
    }

    else
    {
      int v18 = (int)uprv_floor((double)(v17 / 31)) + 1;
      unsigned int v19 = v17 % 31;
    }
  }

  else
  {
    int v18 = 0;
    unsigned int v19 = v16;
  }

  *((_BYTE *)this + 108) = 1;
  *((_DWORD *)this + 22) = v7;
  *((_DWORD *)this + 52) = 1;
  *((_BYTE *)this + 127) = 1;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = v7;
  *(void *)((char *)this + 132) = 0x100000001LL;
  *(_WORD *)((char *)this + 109) = 257;
  *((_DWORD *)this + 5) = v18;
  *((_DWORD *)this + 35) = 1;
  *((_DWORD *)this + 26) = v18;
  *((_DWORD *)this + 56) = 1;
  *((_BYTE *)this + 13sub_1808F7164((uint64_t)v14, 1) = 1;
  *(_WORD *)((char *)this + 113) = 257;
  *((_DWORD *)this + 8) = v19 + 1;
  *((_DWORD *)this + 9) = v16 + 1;
  *((void *)this + 19) = 0x100000001LL;
}

uint64_t icu::IndianCalendar::getRelatedYear(icu::IndianCalendar *this, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(this, 0x13u, a2) + 79;
  else {
    return 0LL;
  }
}

_BYTE *icu::IndianCalendar::setRelatedYear(icu::IndianCalendar *this, int a2)
{
  return icu::Calendar::set(this, 0x13u, a2 - 79);
}

uint64_t icu::IndianCalendar::haveDefaultCentury(icu::IndianCalendar *this)
{
  return 1LL;
}

double icu::IndianCalendar::defaultCenturyStart(icu::IndianCalendar *this)
{
  unsigned int v1 = atomic_load(dword_18C449414);
  if (v1 != 2 && icu::umtx_initImplPreInit(dword_18C449414))
  {
    sub_1808FC06C();
    icu::umtx_initImplPostInit(dword_18C449414);
  }

  return *(double *)&qword_18C4483F8;
}

void sub_1808FC06C()
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  UErrorCode v4 = U_ZERO_ERROR;
  bzero(v6, 0x270uLL);
  icu::Locale::Locale((icu::Locale *)v5, "@calendar=Indian", 0LL, 0LL, 0LL);
  icu::IndianCalendar::IndianCalendar((icu::IndianCalendar *)v6, v5, &v4);
  icu::Locale::~Locale((icu::Locale *)v5);
  if (v4 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v6, v1, &v4);
    icu::Calendar::add(v6, 1u, -80, &v4);
    double TimeInMillis = icu::Calendar::getTimeInMillis((icu::Calendar *)v6, &v4);
    int v3 = icu::Calendar::get(v6, 1u, &v4);
    qword_18C4483F8 = *(void *)&TimeInMillis;
    dword_18C448400 = v3;
  }

  icu::Calendar::~Calendar((icu::Calendar *)v6);
}

uint64_t icu::IndianCalendar::defaultCenturyStartYear(icu::IndianCalendar *this)
{
  unsigned int v1 = atomic_load(dword_18C449414);
  if (v1 != 2 && icu::umtx_initImplPreInit(dword_18C449414))
  {
    sub_1808FC06C();
    icu::umtx_initImplPostInit(dword_18C449414);
  }

  return dword_18C448400;
}

void *icu::IndianCalendar::getStaticClassID(icu::IndianCalendar *this)
{
  return &unk_18C535494;
}

void *icu::IndianCalendar::getDynamicClassID(icu::IndianCalendar *this)
{
  return &unk_18C535494;
}

uint64_t sub_1808FC1D0(uint64_t a1, _DWORD *a2)
{
  *(void *)a1 = uprv_malloc(0x2000uLL);
  UErrorCode v4 = uprv_malloc(0x200uLL);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 48) = 0;
  if (*(void *)a1) {
    BOOL v5 = v4 == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    *a2 = 7;
  }
  return a1;
}

void **sub_1808FC230(void **a1)
{
  return a1;
}

size_t sub_1808FC26C(size_t result, char *__s, int a3)
{
  size_t v3 = result;
  *(_DWORD *)(result + 8) = 0;
  *(_WORD *)(result + 24) = 0;
  *(void *)(result + 40) = __s;
  if (a3 == -1)
  {
    uint64_t result = strlen(__s);
    a3 = result;
  }

  *(_DWORD *)(v3 + 48) = a3;
  return result;
}

char *sub_1808FC2AC(char *result, char *__s, int a3)
{
  if (__s)
  {
    uint64_t v4 = (uint64_t)result;
    if (a3 == -1) {
      a3 = strlen(__s);
    }
    int v5 = a3 + 1;
    uprv_free(*(void **)(v4 + 32));
    int v6 = (char *)uprv_malloc(v5);
    *(void *)(v4 + 32) = v6;
    return strncpy(v6, __s, v5);
  }

  return result;
}

BOOL sub_1808FC314(uint64_t a1)
{
  return *(void *)(a1 + 40) != 0LL;
}

unsigned __int8 **sub_1808FC324(unsigned __int8 **result, int a2)
{
  LODWORD(v2) = *((_DWORD *)result + 12);
  if (!a2) {
    goto LABEL_18;
  }
  uint64_t v3 = 0LL;
  signed int v4 = 0;
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  int v8 = 0;
  do
  {
    int v9 = result[5][v3];
    if (v9 != 60 || (v6 & 1) != 0)
    {
      if ((v9 != 123) | v7 & 1)
      {
        if (((v7 | v6) & 1) == 0)
        {
          int v6 = 0;
          int v7 = 0;
          (*result)[v8++] = v9;
          LODWORD(v2) = *((_DWORD *)result + 12);
        }
      }

      else
      {
        int v7 = 0;
        v4 += v6 & 1;
        ++v5;
        int v6 = 1;
      }
    }

    else
    {
      int v6 = 0;
      v4 += v7 & 1;
      ++v5;
      int v7 = 1;
    }

    BOOL v10 = v9 != 62;
    BOOL v11 = v9 != 125;
    v7 &= v10;
    v6 &= v11;
  }

  while (v8 < 0x2000);
  *((_DWORD *)result + 2) = v8;
  if (v5 < 5 || (int)(v5 / 5u) < v4)
  {
LABEL_18:
LABEL_24:
    LODWORD(v2) = 0;
LABEL_25:
    *((_DWORD *)result + 2) = v2;
    goto LABEL_26;
  }

  if (v8 <= 99 && (int)v2 > 600)
  {
LABEL_19:
    uint64_t v12 = 0LL;
    else {
      uint64_t v2 = v2;
    }
    do
    {
      (*result)[v12] = result[5][v12];
      ++v12;
    }

    while (v2 != v12);
    goto LABEL_25;
  }

const char *icu::IslamicCalendar::getType(icu::IslamicCalendar *this)
{
  return "islamic";
}

uint64_t *icu::IslamicCalendar::clone@<X0>( icu::IslamicCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *uint64_t result = (uint64_t)off_1897244D0;
  }

  return result;
}

icu::IslamicCalendar *icu::IslamicCalendar::IslamicCalendar( icu::IslamicCalendar *this, char **a2, UErrorCode *a3)
{
  int v6 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  icu::Calendar::Calendar(this, v6, (const icu::Locale *)a2, a3);
  *(void *)this = off_1897244D0;
  icu::IslamicCalendar::setLocation((icu::IslamicCalendar *)((char *)a2 + 26), (char *)a3, v7);
  icu::Calendar::getNow(v8);
  icu::Calendar::setTimeInMillis((uint64_t)this, v9, a3);
  return this;
}

void icu::IslamicCalendar::setLocation(icu::IslamicCalendar *this, char *a2, UErrorCode *a3)
{
  int v7 = (icu::CalendarAstronomer *)qword_18C5354F0;
  if (!qword_18C5354F0)
  {
    int v8 = (icu::CalendarAstronomer *)icu::UMemory::operator new(v6, (icu::UMemory *)0x88, v5);
    if (v8) {
      int v8 = (icu::CalendarAstronomer *)icu::CalendarAstronomer::CalendarAstronomer(v8);
    }
    else {
      *(_DWORD *)a2 = 7;
    }
    qword_18C5354F0 = (uint64_t)v8;
    sub_1809B36C0(8u, (uint64_t)sub_1808FC918);
    int v7 = (icu::CalendarAstronomer *)qword_18C5354F0;
  }

  icu::CalendarAstronomer::setLocation(v7, (char *)this);
  umtx_unlock((std::mutex **)&unk_18C535548);
}

void icu::IslamicCalendar::~IslamicCalendar(icu::IslamicCalendar *this)
{
}

uint64_t icu::IslamicCalendar::handleGetLimit(uint64_t a1, int a2, int a3)
{
  return dword_180A39614[4 * a2 + a3];
}

BOOL icu::IslamicCalendar::civilLeapYear(icu::IslamicCalendar *this)
{
  return (11 * (int)this + 14) % 30 < 11;
}

uint64_t icu::IslamicCalendar::yearStart(icu::IslamicCalendar *this, int a2)
{
  return icu::IslamicCalendar::trueMonthStart(this, 12 * a2 - 12);
}

uint64_t icu::IslamicCalendar::trueMonthStart(icu::IslamicCalendar *this, signed int a2)
{
  int v11 = 0;
  unsigned int v3 = sub_180896930((uint64_t **)&qword_18C535498, a2, &v11);
  if (!v3)
  {
    double v4 = uprv_floor(29.5305889 * (double)a2) * 86400000.0 + -4.25215872e13;
    icu::IslamicCalendar::moonAge((icu::IslamicCalendar *)&v11, v4, v5);
    if (v11 <= 0)
    {
      if (v7 >= 0.0)
      {
        while (1)
        {
          double v4 = v4 + -86400000.0;
          icu::IslamicCalendar::moonAge((icu::IslamicCalendar *)&v11, v4, v6);
          if (v11 > 0) {
            break;
          }
          if (v10 < 0.0)
          {
LABEL_13:
            unsigned int v3 = sub_1808FA250((uint64_t)((double)(uint64_t)v4 + 4.25215872e13), 86400000LL) + 1;
            sub_1808969CC((uint64_t **)&qword_18C535498, a2, v3, &v11);
            goto LABEL_4;
          }
        }
      }

      else
      {
        while (1)
        {
          double v4 = v4 + 86400000.0;
          icu::IslamicCalendar::moonAge((icu::IslamicCalendar *)&v11, v4, v6);
          if (v11 > 0) {
            break;
          }
          if (v9 >= 0.0) {
            goto LABEL_13;
          }
        }
      }
    }

    unsigned int v3 = 0;
  }

uint64_t icu::IslamicCalendar::monthStart(icu::IslamicCalendar *this, int a2, int a3)
{
  return icu::IslamicCalendar::trueMonthStart(this, a3 + 12 * a2 - 12);
}

void icu::IslamicCalendar::moonAge(icu::IslamicCalendar *this, double a2, UErrorCode *a3)
{
  double v7 = (icu::CalendarAstronomer *)qword_18C5354F0;
  if (qword_18C5354F0) {
    goto LABEL_4;
  }
  int v8 = (icu::CalendarAstronomer *)icu::UMemory::operator new(v6, (icu::UMemory *)0x88, v5);
  if (v8)
  {
    qword_18C5354F0 = icu::CalendarAstronomer::CalendarAstronomer(v8);
    sub_1809B36C0(8u, (uint64_t)sub_1808FC918);
    double v7 = (icu::CalendarAstronomer *)qword_18C5354F0;
LABEL_4:
    icu::CalendarAstronomer::setTime(v7, a2);
    icu::CalendarAstronomer::getMoonAge((icu::CalendarAstronomer *)qword_18C5354F0);
    umtx_unlock((std::mutex **)&unk_18C5354A0);
    return;
  }

  qword_18C5354F0 = 0LL;
  *(_DWORD *)this = 7;
}

uint64_t sub_1808FC918()
{
  if (qword_18C535498)
  {
    (*(void (**)(uint64_t))(*(void *)qword_18C535498 + 8LL))(qword_18C535498);
    qword_18C535498 = 0LL;
  }

  if (qword_18C5354F0)
  {
    icu::CalendarAstronomer::~CalendarAstronomer((icu::CalendarAstronomer *)qword_18C5354F0);
    icu::UMemory::operator delete(v0);
    qword_18C5354F0 = 0LL;
  }

  return 1LL;
}

void icu::IslamicCalendar::setLocation(icu::IslamicCalendar *this, double a2, double a3, UErrorCode *a4)
{
  uint64_t v9 = qword_18C5354F0;
  if (!qword_18C5354F0)
  {
    double v10 = (icu::CalendarAstronomer *)icu::UMemory::operator new(v8, (icu::UMemory *)0x88, v7);
    if (v10) {
      double v10 = (icu::CalendarAstronomer *)icu::CalendarAstronomer::CalendarAstronomer(v10);
    }
    else {
      *(_DWORD *)this = 7;
    }
    qword_18C5354F0 = (uint64_t)v10;
    sub_1809B36C0(8u, (uint64_t)sub_1808FC918);
    uint64_t v9 = qword_18C5354F0;
  }

  icu::CalendarAstronomer::setLocation(v9, a2, a3);
  umtx_unlock((std::mutex **)&unk_18C5354F8);
}

double icu::IslamicCalendar::getLocationLatitude(icu::IslamicCalendar *this, UErrorCode *a2)
{
  if (!qword_18C5354F0) {
    icu::IslamicCalendar::setLocation(this, 0.0, 0.0, v3);
  }
  umtx_unlock((std::mutex **)&unk_18C535598);
  return icu::CalendarAstronomer::getLocationLatitude((icu::CalendarAstronomer *)qword_18C5354F0);
}

double icu::IslamicCalendar::getLocationLongitude(icu::IslamicCalendar *this, UErrorCode *a2)
{
  if (!qword_18C5354F0) {
    icu::IslamicCalendar::setLocation(this, 0.0, 0.0, v3);
  }
  umtx_unlock((std::mutex **)&unk_18C5355E8);
  return icu::CalendarAstronomer::getLocationLongitude((icu::CalendarAstronomer *)qword_18C5354F0);
}

uint64_t icu::IslamicCalendar::handleGetMonthLength(icu::IslamicCalendar *this, int a2, int a3)
{
  int v3 = a3 + 12 * a2;
  signed int v4 = v3 - 12;
  unint64_t v5 = (icu::IslamicCalendar *)icu::IslamicCalendar::trueMonthStart(this, v3 - 11);
  return v5 - icu::IslamicCalendar::trueMonthStart(v5, v4);
}

uint64_t icu::IslamicCalendar::handleGetYearLength(icu::IslamicCalendar *this, int a2)
{
  signed int v2 = 12 * a2;
  signed int v3 = v2 - 12;
  signed int v4 = (icu::IslamicCalendar *)icu::IslamicCalendar::trueMonthStart(this, v2);
  return v4 - icu::IslamicCalendar::trueMonthStart(v4, v3);
}

uint64_t icu::IslamicCalendar::handleComputeMonthStart(icu::IslamicCalendar *this, int a2, int a3)
{
  unsigned int v4 = ~a3 / 0xCu;
  unsigned int v5 = a3 + 1 + 12 * v4 + 11;
  if (a3 < 0)
  {
    unsigned int v6 = ~v4 + a2;
  }

  else
  {
    unsigned int v5 = a3;
    unsigned int v6 = a2;
  }

  unsigned int v7 = a3 / 0xCu + a2;
  BOOL v8 = a3 < 12;
  if (a3 >= 12) {
    uint64_t v9 = a3 % 0xCu;
  }
  else {
    uint64_t v9 = v5;
  }
  if (v8) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = v7;
  }
  int v11 = (*(uint64_t (**)(icu::IslamicCalendar *, uint64_t, uint64_t))(*(void *)this + 448LL))(this, v10, v9);
  return v11 + (*(unsigned int (**)(icu::IslamicCalendar *))(*(void *)this + 456LL))(this) - 1;
}

uint64_t icu::IslamicCalendar::handleGetExtendedYear(icu::IslamicCalendar *this)
{
  if (icu::Calendar::newerField((uint64_t)this, 0x13u, 1u) == 19)
  {
    if (*((int *)this + 52) >= 1)
    {
      signed int v2 = (char *)this + 88;
      return *(unsigned int *)v2;
    }
  }

  else if (*((int *)this + 34) >= 1)
  {
    signed int v2 = (char *)this + 16;
    return *(unsigned int *)v2;
  }

  return 1LL;
}

void icu::IslamicCalendar::handleComputeFields(icu::IslamicCalendar *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v5 = a2 - (*(uint64_t (**)(icu::IslamicCalendar *))(*(void *)this + 456LL))(this);
    int v6 = (int)uprv_floor((double)v5 / 29.5305889);
    double v7 = uprv_floor(29.5305889 * (double)v6);
    icu::IslamicCalendar::moonAge((icu::IslamicCalendar *)a3, *((double *)this + 29), v8);
    if (*(int *)a3 < 1)
    {
      else {
        int v12 = v6 + 1;
      }
      int v13 = v12 + 2;
      do
      {
        uint64_t v9 = (icu::IslamicCalendar *)icu::IslamicCalendar::trueMonthStart(v9, v13 - 2);
        --v13;
      }

      while ((int)v9 > v5);
      int v14 = v13 - 1;
      if (v13 - 1 < 0) {
        uint64_t v15 = -(-v13 / 0xCu);
      }
      else {
        uint64_t v15 = v14 / 0xCu + 1;
      }
      unsigned int v16 = v14 % 12;
      if (v16 <= 0xFFFFFFF3) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 + 12;
      }
      int v18 = v5 + 1;
      int v19 = v18
          - (*(uint64_t (**)(icu::IslamicCalendar *, uint64_t, uint64_t))(*(void *)this + 448LL))( this,  v15,  v17);
      int v20 = (*(uint64_t (**)(icu::IslamicCalendar *, uint64_t, void))(*(void *)this + 448LL))( this,  v15,  0LL);
      *((_BYTE *)this + 108) = 1;
      *((_DWORD *)this + 3) = 0;
      *((_DWORD *)this + 4) = v15;
      *(void *)((char *)this + 132) = 0x100000001LL;
      *(_WORD *)((char *)this + 109) = 257;
      *((_DWORD *)this + 22) = v15;
      *((_DWORD *)this + 52) = 1;
      *((_BYTE *)this + 127) = 1;
      *((_DWORD *)this + 5) = v17;
      *((_DWORD *)this + 35) = 1;
      *((_DWORD *)this + 26) = v17;
      *((_DWORD *)this + 56) = 1;
      *((_BYTE *)this + 13sub_1808F7164((uint64_t)v14, 1) = 1;
      *(_WORD *)((char *)this + 113) = 257;
      *((_DWORD *)this + 8) = v19;
      *((_DWORD *)this + 9) = v18 - v20;
      *((void *)this + 19) = 0x100000001LL;
    }

    else
    {
      *a3 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

uint64_t icu::IslamicCalendar::getEpoc(icu::IslamicCalendar *this)
{
  return 1948440LL;
}

uint64_t icu::IslamicCalendar::getRelatedYear(icu::IslamicCalendar *this, UErrorCode *a2)
{
  int v3 = icu::Calendar::get(this, 0x13u, a2);
  unsigned int v5 = ((__PAIR64__(2 * ((1396 - v3) / 0x43u), (1396 - v3) % 0x43u) - 34) >> 32) + 2;
  if ((v3 - 1397) % 0x43u <= 0x20) {
    int v6 = 0;
  }
  else {
    int v6 = -1;
  }
  if (v3 >= 1397) {
    unsigned int v5 = v6 - 2 * ((v3 - 1397) / 0x43u);
  }
  return v3 + v5 + 579;
}

_BYTE *icu::IslamicCalendar::setRelatedYear(icu::IslamicCalendar *this, int a2)
{
  unsigned int v2 = ((1976 - a2) % 0x41u < 0x21) - 2 * ((1976 - a2) / 0x41u) - 2;
  if (a2 >= 1977) {
    unsigned int v2 = ((a2 - 1977) % 0x41u > 0x1F) | (2 * ((a2 - 1977) / 0x41u));
  }
  return icu::Calendar::set(this, 0x13u, a2 + v2 - 579);
}

uint64_t icu::IslamicCalendar::haveDefaultCentury(icu::IslamicCalendar *this)
{
  return 1LL;
}

double icu::IslamicCalendar::defaultCenturyStart(icu::IslamicCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C449420);
  if (v1 != 2)
  {
    inited = (icu::IslamicCalendar *)icu::umtx_initImplPreInit((unsigned int *)&unk_18C449420);
    if ((_DWORD)inited)
    {
      icu::IslamicCalendar::initializeSystemDefaultCentury(inited);
      icu::umtx_initImplPostInit((unsigned int *)&unk_18C449420);
    }
  }

  return *(double *)&qword_18C448408;
}

void icu::IslamicCalendar::initializeSystemDefaultCentury(icu::IslamicCalendar *this)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  UErrorCode v3 = U_ZERO_ERROR;
  bzero(v5, 0x270uLL);
  icu::Locale::Locale((icu::Locale *)v4, "@calendar=islamic-civil", 0LL, 0LL, 0LL);
  icu::IslamicCalendar::IslamicCalendar((icu::IslamicCalendar *)v5, v4, &v3);
  icu::Locale::~Locale((icu::Locale *)v4);
  if (v3 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v1);
    icu::Calendar::setTimeInMillis((uint64_t)v5, v2, &v3);
    icu::Calendar::add(v5, 1u, -80, &v3);
    qword_18C448408 = icu::Calendar::getTimeInMillis((icu::Calendar *)v5, &v3);
    dword_18C448410 = icu::Calendar::get(v5, 1u, &v3);
  }

  icu::Calendar::~Calendar((icu::Calendar *)v5);
}

uint64_t icu::IslamicCalendar::defaultCenturyStartYear(icu::IslamicCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C449420);
  if (v1 != 2)
  {
    inited = (icu::IslamicCalendar *)icu::umtx_initImplPreInit((unsigned int *)&unk_18C449420);
    if ((_DWORD)inited)
    {
      icu::IslamicCalendar::initializeSystemDefaultCentury(inited);
      icu::umtx_initImplPostInit((unsigned int *)&unk_18C449420);
    }
  }

  return dword_18C448410;
}

BOOL icu::IslamicCalendar::inTemporalLeapYear(icu::IslamicCalendar *this, UErrorCode *a2)
{
  int v3 = (*(uint64_t (**)(icu::IslamicCalendar *, uint64_t, UErrorCode *))(*(void *)this + 176LL))( this,  6LL,  a2);
  return *(int *)a2 < 1 && v3 == 355;
}

icu::IslamicCalendar *icu::IslamicCivilCalendar::IslamicCivilCalendar( icu::IslamicCivilCalendar *this, char **a2, UErrorCode *a3)
{
  uint64_t result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)uint64_t result = off_1897246B0;
  return result;
}

{
  icu::IslamicCalendar *result;
  uint64_t result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)uint64_t result = off_1897246B0;
  return result;
}

void icu::IslamicCivilCalendar::~IslamicCivilCalendar(icu::IslamicCivilCalendar *this)
{
}

const char *icu::IslamicCivilCalendar::getType(icu::IslamicCivilCalendar *this)
{
  return "islamic-civil";
}

uint64_t *icu::IslamicCivilCalendar::clone@<X0>( icu::IslamicCivilCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *uint64_t result = (uint64_t)off_1897246B0;
  }

  return result;
}

uint64_t icu::IslamicCivilCalendar::yearStart(icu::IslamicCivilCalendar *this, int a2)
{
  return sub_1808FA250(11LL * a2 + 3, 30LL) + 354 * a2 - 354;
}

uint64_t icu::IslamicCivilCalendar::monthStart(icu::IslamicCivilCalendar *this, int a2, int a3)
{
  double v4 = uprv_ceil((double)a3 * 29.5) + (double)(354 * a2 - 354);
  return (int)(v4 + (double)(int)sub_1808FA250(11LL * a2 + 3, 30LL));
}

uint64_t icu::IslamicCivilCalendar::handleGetMonthLength(icu::IslamicCivilCalendar *this, int a2, int a3)
{
  int v3 = (a3 + 1) & 1;
  if (a3 < -1) {
    int v3 = -v3;
  }
  uint64_t result = (v3 + 29);
  if (a3 == 11)
  {
    unsigned int v5 = v3 + 30;
    if ((11 * a2 + 14) % 30 <= 10) {
      return v5;
    }
    else {
      return result;
    }
  }

  return result;
}

uint64_t icu::IslamicCivilCalendar::handleGetYearLength(icu::IslamicCivilCalendar *this, int a2)
{
  return ((11 * a2 + 14) % 30 < 11) | 0x162u;
}

double icu::IslamicCivilCalendar::handleComputeFields( icu::IslamicCivilCalendar *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v4 = a2 - (*(uint64_t (**)(icu::IslamicCivilCalendar *))(*(void *)this + 456LL))(this);
    uint64_t v5 = sub_1808FA250(30LL * v4 + 10646, 10631LL);
    int v6 = (*(uint64_t (**)(icu::IslamicCivilCalendar *, uint64_t))(*(void *)this + 440LL))(this, v5);
    int v7 = (int)uprv_ceil((double)(v4 - v6 - 29) / 29.5);
    if (v7 >= 11) {
      uint64_t v8 = 11LL;
    }
    else {
      uint64_t v8 = v7;
    }
    int v9 = v4 + 1;
    int v10 = v9
        - (*(uint64_t (**)(icu::IslamicCivilCalendar *, uint64_t, uint64_t))(*(void *)this + 448LL))( this,  v5,  v8);
    int v11 = (*(uint64_t (**)(icu::IslamicCivilCalendar *, uint64_t, void))(*(void *)this + 448LL))( this,  v5,  0LL);
    *((_BYTE *)this + 108) = 1;
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 4) = v5;
    *(void *)&double result = 0x100000001LL;
    *(void *)((char *)this + 132) = 0x100000001LL;
    *(_WORD *)((char *)this + 109) = 257;
    *((_DWORD *)this + 22) = v5;
    *((_DWORD *)this + 52) = 1;
    *((_BYTE *)this + 127) = 1;
    *((_DWORD *)this + 5) = v8;
    *((_DWORD *)this + 35) = 1;
    *((_DWORD *)this + 26) = v8;
    *((_DWORD *)this + 56) = 1;
    *((_BYTE *)this + 13sub_1808F7164((uint64_t)v14, 1) = 1;
    *(_WORD *)((char *)this + 113) = 257;
    *((_DWORD *)this + 8) = v10;
    *((_DWORD *)this + 9) = v9 - v11;
    *((void *)this + 19) = 0x100000001LL;
  }

  return result;
}

icu::IslamicCalendar *icu::IslamicTBLACalendar::IslamicTBLACalendar( icu::IslamicTBLACalendar *this, char **a2, UErrorCode *a3)
{
  double result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)double result = off_189724890;
  return result;
}

{
  icu::IslamicCalendar *result;
  double result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)double result = off_189724890;
  return result;
}

void icu::IslamicTBLACalendar::~IslamicTBLACalendar(icu::IslamicTBLACalendar *this)
{
}

const char *icu::IslamicTBLACalendar::getType(icu::IslamicTBLACalendar *this)
{
  return "islamic-tbla";
}

uint64_t *icu::IslamicTBLACalendar::clone@<X0>( icu::IslamicTBLACalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  double result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    double result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *double result = (uint64_t)off_189724890;
  }

  return result;
}

uint64_t icu::IslamicTBLACalendar::getEpoc(icu::IslamicTBLACalendar *this)
{
  return 1948439LL;
}

icu::IslamicCalendar *icu::IslamicUmalquraCalendar::IslamicUmalquraCalendar( icu::IslamicUmalquraCalendar *this, char **a2, UErrorCode *a3)
{
  double result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)double result = off_189724A70;
  return result;
}

{
  icu::IslamicCalendar *result;
  double result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)double result = off_189724A70;
  return result;
}

void icu::IslamicUmalquraCalendar::~IslamicUmalquraCalendar(icu::IslamicUmalquraCalendar *this)
{
}

const char *icu::IslamicUmalquraCalendar::getType(icu::IslamicUmalquraCalendar *this)
{
  return "islamic-umalqura";
}

uint64_t *icu::IslamicUmalquraCalendar::clone@<X0>( icu::IslamicUmalquraCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  double result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    double result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *double result = (uint64_t)off_189724A70;
  }

  return result;
}

uint64_t icu::IslamicUmalquraCalendar::yearStart(icu::IslamicUmalquraCalendar *this, int a2)
{
  else {
    return sub_1808FA250(11LL * a2 + 3, 30LL) + 354 * a2 - 354;
  }
}

uint64_t icu::IslamicUmalquraCalendar::monthStart(icu::IslamicUmalquraCalendar *this, uint64_t a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(icu::IslamicUmalquraCalendar *))(*(void *)this + 440LL))(this);
  if (a3 >= 1)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v6 = (*(unsigned int (**)(icu::IslamicUmalquraCalendar *, uint64_t, uint64_t))(*(void *)this + 312LL))( this,  a2,  v7)
         + v6;
      uint64_t v7 = (v7 + 1);
    }

    while (a3 != (_DWORD)v7);
  }

  return v6;
}

uint64_t icu::IslamicUmalquraCalendar::handleGetMonthLength( icu::IslamicUmalquraCalendar *this, int a2, int a3)
{
  if ((a2 - 1601) > 0xFFFFFED2)
  {
    if (((dword_180A39160[a2 - 1300] >> (11 - a3)) & 1) != 0) {
      return 30LL;
    }
    else {
      return 29LL;
    }
  }

  else
  {
    int v3 = (a3 + 1) & 1;
    if (a3 < -1) {
      int v3 = -v3;
    }
    uint64_t result = (v3 + 29);
    if (a3 == 11)
    {
      unsigned int v5 = v3 + 30;
      if ((11 * a2 + 14) % 30 <= 10) {
        return v5;
      }
      else {
        return result;
      }
    }
  }

  return result;
}

uint64_t icu::IslamicUmalquraCalendar::handleGetYearLength(icu::IslamicUmalquraCalendar *this, uint64_t a2)
{
  uint64_t v5 = 0LL;
  LODWORD(v3) = 0;
  do
  {
    uint64_t v3 = (*(unsigned int (**)(icu::IslamicUmalquraCalendar *, uint64_t, uint64_t))(*(void *)this + 312LL))( this,  a2,  v5)
       + v3;
    uint64_t v5 = (v5 + 1);
  }

  while ((_DWORD)v5 != 12);
  return v3;
}

double icu::IslamicUmalquraCalendar::handleComputeFields( icu::IslamicUmalquraCalendar *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v4 = a2 - (*(uint64_t (**)(icu::IslamicUmalquraCalendar *))(*(void *)this + 456LL))(this);
    if (v4 >= (*(int (**)(icu::IslamicUmalquraCalendar *, uint64_t))(*(void *)this + 440LL))(this, 1300LL))
    {
      uint64_t v5 = 1299LL;
      uint64_t v9 = 1LL;
      do
      {
        if (v9 < 1) {
          goto LABEL_11;
        }
        uint64_t v5 = (v5 + 1);
        int v10 = v4
            - (*(uint64_t (**)(icu::IslamicUmalquraCalendar *, uint64_t))(*(void *)this + 440LL))(this, v5);
        int v11 = v10 + 1;
        if (v10 + 1 == (*(unsigned int (**)(icu::IslamicUmalquraCalendar *, uint64_t))(*(void *)this + 320LL))( this,  v5))
        {
          uint64_t v8 = 11LL;
          goto LABEL_15;
        }

        uint64_t v9 = v11;
      }

      while (v11 >= (*(int (**)(icu::IslamicUmalquraCalendar *, uint64_t))(*(void *)this + 320LL))( this,  v5));
      int v12 = (*(uint64_t (**)(icu::IslamicUmalquraCalendar *, uint64_t, void))(*(void *)this + 312LL))( this,  v5,  0LL);
      if (v10 < v12)
      {
LABEL_11:
        uint64_t v8 = 0LL;
        goto LABEL_15;
      }

      LODWORD(v8) = 0;
      uint64_t v13 = v12;
      do
      {
        v9 -= v13;
        uint64_t v8 = (v8 + 1);
        uint64_t v13 = (*(int (**)(icu::IslamicUmalquraCalendar *, uint64_t, uint64_t))(*(void *)this + 312LL))( this,  v5,  v8);
      }

      while (v9 > v13);
    }

    else
    {
      uint64_t v5 = sub_1808FA250(30LL * v4 + 10646, 10631LL);
      int v6 = (*(uint64_t (**)(icu::IslamicUmalquraCalendar *, uint64_t))(*(void *)this + 440LL))(this, v5);
      int v7 = (int)uprv_ceil((double)(v4 - v6 - 29) / 29.5);
      if (v7 >= 11) {
        uint64_t v8 = 11LL;
      }
      else {
        uint64_t v8 = v7;
      }
    }

icu::IslamicCalendar *icu::IslamicRGSACalendar::IslamicRGSACalendar( icu::IslamicRGSACalendar *this, char **a2, UErrorCode *a3)
{
  double result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)double result = off_189724C50;
  return result;
}

{
  icu::IslamicCalendar *result;
  double result = icu::IslamicCalendar::IslamicCalendar(this, a2, a3);
  *(void *)double result = off_189724C50;
  return result;
}

void icu::IslamicRGSACalendar::~IslamicRGSACalendar(icu::IslamicRGSACalendar *this)
{
}

const char *icu::IslamicRGSACalendar::getType(icu::IslamicRGSACalendar *this)
{
  return "islamic-rgsa";
}

uint64_t *icu::IslamicRGSACalendar::clone@<X0>( icu::IslamicRGSACalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  double result = icu::UMemory::operator new(a3, (icu::UMemory *)0x270, a2);
  if (result)
  {
    double result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *double result = (uint64_t)off_189724C50;
  }

  return result;
}

void *icu::IslamicCalendar::getStaticClassID(icu::IslamicCalendar *this)
{
  return &unk_18C535638;
}

void *icu::IslamicCalendar::getDynamicClassID(icu::IslamicCalendar *this)
{
  return &unk_18C535638;
}

void *icu::IslamicCivilCalendar::getStaticClassID(icu::IslamicCivilCalendar *this)
{
  return &unk_18C535639;
}

void *icu::IslamicCivilCalendar::getDynamicClassID(icu::IslamicCivilCalendar *this)
{
  return &unk_18C535639;
}

void *icu::IslamicUmalquraCalendar::getStaticClassID(icu::IslamicUmalquraCalendar *this)
{
  return &unk_18C53563A;
}

void *icu::IslamicUmalquraCalendar::getDynamicClassID(icu::IslamicUmalquraCalendar *this)
{
  return &unk_18C53563A;
}

void *icu::IslamicTBLACalendar::getStaticClassID(icu::IslamicTBLACalendar *this)
{
  return &unk_18C53563B;
}

void *icu::IslamicTBLACalendar::getDynamicClassID(icu::IslamicTBLACalendar *this)
{
  return &unk_18C53563B;
}

void *icu::IslamicRGSACalendar::getStaticClassID(icu::IslamicRGSACalendar *this)
{
  return &unk_18C53563C;
}

void *icu::IslamicRGSACalendar::getDynamicClassID(icu::IslamicRGSACalendar *this)
{
  return &unk_18C53563C;
}

void *icu::ISO8601Calendar::getStaticClassID(icu::ISO8601Calendar *this)
{
  return &unk_18C535640;
}

void *sub_1808FDA8C()
{
  return &unk_18C535640;
}

icu::GregorianCalendar *sub_1808FDA98(icu::GregorianCalendar *a1, char **a2, UErrorCode *a3)
{
  *(void *)icu::GregorianCalendar::GregorianCalendar(a1, a2, a3) = &off_189724EA8;
  UErrorCode v8 = U_ZERO_ERROR;
  int KeywordValue = icu::Locale::getKeywordValue(a2, "fw", 0LL, 0, &v8);
  if (v8 <= U_ZERO_ERROR && KeywordValue == 0) {
    icu::Calendar::setFirstDayOfWeek((uint64_t)a1, 2);
  }
  icu::Calendar::setMinimalDaysInFirstWeek((uint64_t)a1, 4u);
  return a1;
}

void sub_1808FDB24(icu::GregorianCalendar *a1)
{
}

void sub_1808FDB38(const icu::GregorianCalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = (icu::GregorianCalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x290, a2);
  if (v4)
  {
    icu::GregorianCalendar::GregorianCalendar(v4, a1);
    *uint64_t v5 = &off_189724EA8;
  }

const char *sub_1808FDB74()
{
  return "iso8601";
}

void *icu::JapaneseCalendar::getStaticClassID(icu::JapaneseCalendar *this)
{
  return &unk_18C535648;
}

void *sub_1808FDB8C()
{
  return &unk_18C535648;
}

char *icu::JapaneseCalendar::enableTentativeEra(icu::JapaneseCalendar *this)
{
  double result = getenv("ICU_ENABLE_TENTATIVE_ERA");
  if (result) {
    return (char *)(uprv_stricmp(result, "true") == 0);
  }
  return result;
}

uint64_t icu::JapaneseCalendar::getCurrentEra(icu::JapaneseCalendar *this)
{
  return dword_18C53564C;
}

icu::GregorianCalendar *sub_1808FDBD8(icu::GregorianCalendar *a1, char **a2, UErrorCode *a3)
{
  *(void *)icu::GregorianCalendar::GregorianCalendar(a1, a2, a3) = &off_1897250A8;
  sub_1808FDC24((int *)a3);
  icu::Calendar::getNow(v5);
  icu::Calendar::setTimeInMillis((uint64_t)a1, v6, a3);
  return a1;
}

void sub_1808FDC24(int *a1)
{
  if (*a1 <= 0)
  {
    unsigned int v2 = atomic_load(&dword_18C535658);
    if (v2 == 2 || (inited = (icu::JapaneseCalendar *)icu::umtx_initImplPreInit(&dword_18C535658), !(_DWORD)inited))
    {
      if (dword_18C53565C >= 1) {
        *a1 = dword_18C53565C;
      }
    }

    else
    {
      int v4 = icu::JapaneseCalendar::enableTentativeEra(inited);
      uint64_t Instance = icu::EraRules::createInstance((icu::EraRules *)"japanese", v4, a1, v5);
      qword_18C535650 = (uint64_t)Instance;
      int v7 = *a1;
      if (*a1 <= 0) {
        dword_18C53564C = *((_DWORD *)Instance + 3);
      }
      dword_18C53565C = v7;
      icu::umtx_initImplPostInit(&dword_18C535658);
    }
  }

  sub_1809B36C0(7u, (uint64_t)sub_1808FE240);
}

void sub_1808FDCE4(icu::GregorianCalendar *a1)
{
}

icu::GregorianCalendar *sub_1808FDCF8@<X0>( const icu::GregorianCalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = (icu::GregorianCalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x290, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    icu::GregorianCalendar::GregorianCalendar(v4, a1);
    *(void *)uint64_t v5 = &off_1897250A8;
    int v7 = 0;
    sub_1808FDC24(&v7);
  }

  return v5;
}

const char *sub_1808FDD54()
{
  return "japanese";
}

uint64_t sub_1808FDD60(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  unsigned int v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 440LL))(a1);
  void v5[3] = U_ZERO_ERROR;
  *(void *)&v5[1] = 0LL;
  v5[0] = U_ZERO_ERROR;
  icu::EraRules::getStartDate(qword_18C535650, v3, (int (*)[3])&v5[1], v5);
  if (v5[1] == a2) {
    return (v5[2] - 1);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1808FDDF0(uint64_t a1, int a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  unsigned int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 440LL))(a1);
  v7[3] = U_ZERO_ERROR;
  *(void *)&v7[1] = 0LL;
  v7[0] = U_ZERO_ERROR;
  icu::EraRules::getStartDate(qword_18C535650, v5, (int (*)[3])&v7[1], v7);
  if (v7[1] == a2 && v7[2] - 1 == a3) {
    return v7[3];
  }
  else {
    return 1LL;
  }
}

uint64_t sub_1808FDE9C(uint64_t a1)
{
  else {
    unsigned int v1 = (int *)(a1 + 12);
  }
  return *v1;
}

uint64_t sub_1808FDEBC(_DWORD *a1)
{
  if (icu::Calendar::newerField((uint64_t)a1, 0x13u, 1u) == 19
    && icu::Calendar::newerField((uint64_t)a1, 0x13u, 0) == 19)
  {
    else {
      return a1[22];
    }
  }

  else
  {
    UErrorCode v6 = U_ZERO_ERROR;
    else {
      unsigned int v3 = a1 + 3;
    }
    int StartYear = icu::EraRules::getStartYear((icu::EraRules *)qword_18C535650, *v3, &v6);
    else {
      int v5 = a1[4];
    }
    return (StartYear + v5 - 1);
  }

uint64_t sub_1808FDF78(uint64_t a1, int a2, UErrorCode *a3)
{
  int v5 = *(_DWORD *)(a1 + 88);
  UErrorCode v6 = (icu::EraRules *)qword_18C535650;
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 264LL))(a1);
  unsigned int EraIndex = icu::EraRules::getEraIndex(v6, v5, v7 + 1, *(_DWORD *)(a1 + 32), a3);
  *(_DWORD *)(a1 + 12) = EraIndex;
  *(_DWORD *)(a1 + 132) = 1;
  *(_BYTE *)(a1 + 108) = 1;
  uint64_t result = icu::EraRules::getStartYear((icu::EraRules *)qword_18C535650, EraIndex, a3);
  *(_DWORD *)(a1 + 16) = v5 - result + 1;
  *(_DWORD *)(a1 + 136) = 1;
  *(_BYTE *)(a1 + 109) = 1;
  return result;
}

uint64_t sub_1808FE014()
{
  return 0LL;
}

double sub_1808FE01C()
{
  return 0.0;
}

uint64_t sub_1808FE024()
{
  return 0LL;
}

uint64_t sub_1808FE02C(uint64_t a1, int a2, unsigned int a3)
{
  if (a2 == 1)
  {
    if (a3 - 3 > 1)
    {
      return 1LL;
    }

    else
    {
      UErrorCode v6 = U_ZERO_ERROR;
      int StartYear = icu::EraRules::getStartYear((icu::EraRules *)qword_18C535650, dword_18C53564C, &v6);
      return icu::GregorianCalendar::handleGetLimit(a1, 1, 3) - StartYear;
    }
  }

  else if (a2)
  {
    return icu::GregorianCalendar::handleGetLimit(a1, a2, a3);
  }

  else if (a3 >= 2)
  {
    return (*(_DWORD *)(qword_18C535650 + 8) - 1);
  }

  else
  {
    return 0LL;
  }

uint64_t sub_1808FE0DC(_BYTE *a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if ((_DWORD)a2 != 1) {
    return icu::GregorianCalendar::getActualMaximum((uint64_t)a1, a2, a3);
  }
  unsigned int v5 = icu::Calendar::get(a1, 0, a3);
  uint64_t result = 0LL;
  if (*(int *)a3 <= 0)
  {
    if (v5 == *(_DWORD *)(qword_18C535650 + 8) - 1)
    {
      return (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(*(void *)a1 + 288LL))(a1, 1LL, 3LL);
    }

    else
    {
      memset(v12, 0, sizeof(v12));
      icu::EraRules::getStartDate(qword_18C535650, v5 + 1, (int (*)[3])v12, a3);
      int v7 = v12[0];
      int v8 = v12[1];
      int v9 = v12[2];
      unsigned int v10 = v7 - icu::EraRules::getStartYear((icu::EraRules *)qword_18C535650, v5, a3);
      if (v8 == 1 && v9 == 1) {
        return v10;
      }
      else {
        return v10 + 1;
      }
    }
  }

  return result;
}

uint64_t sub_1808FE240()
{
  if (qword_18C535650)
  {
    icu::EraRules::~EraRules((void **)qword_18C535650);
    icu::UMemory::operator delete(v0);
    qword_18C535650 = 0LL;
  }

  dword_18C53564C = 0;
  atomic_store(0, &dword_18C535658);
  return 1LL;
}

void sub_1808FE28C(void **a1)
{
}

uint64_t icu::FormattedList::FormattedList(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = off_1897252A8;
  *(void *)(result + 8) = v2;
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 27;
  return result;
}

{
  uint64_t v2;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = off_1897252A8;
  *(void *)(result + 8) = v2;
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 27;
  return result;
}

void icu::FormattedList::~FormattedList(icu::FormattedList *this)
{
  *(void *)this = off_1897252A8;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  icu::FormattedValue::~FormattedValue(this);
}

{
  uint64_t v2;
  *(void *)this = off_1897252A8;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  icu::FormattedValue::~FormattedValue(this);
}

{
  uint64_t v2;
  void *v3;
  *(void *)this = off_1897252A8;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  icu::FormattedValue::~FormattedValue(this);
  icu::UMemory::operator delete(v3);
}

uint64_t icu::FormattedList::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 27;
  return a1;
}

void icu::FormattedList::toString(icu::FormattedList *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(int *)a2 >= 1)
  {
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)(a3 + 56) = 0LL;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
LABEL_3:
    *(void *)a3 = off_18971B688;
    *(_WORD *)(a3 + 8) = 2;
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
    return;
  }

  uint64_t v3 = *((void *)this + 1);
  if (!v3)
  {
    *a2 = *((UErrorCode *)this + 4);
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(void *)(a3 + 56) = 0LL;
    goto LABEL_3;
  }

  (*(void (**)(void))(*(void *)v3 + 16LL))(*((void *)this + 1));
}

void icu::FormattedList::toTempString(icu::FormattedList *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(int *)a2 >= 1)
  {
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)(a3 + 56) = 0LL;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
LABEL_3:
    *(void *)a3 = off_18971B688;
    *(_WORD *)(a3 + 8) = 2;
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
    return;
  }

  uint64_t v3 = *((void *)this + 1);
  if (!v3)
  {
    *a2 = *((UErrorCode *)this + 4);
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(void *)(a3 + 56) = 0LL;
    goto LABEL_3;
  }

  (*(void (**)(void))(*(void *)v3 + 24LL))(*((void *)this + 1));
}

icu::Appendable *icu::FormattedList::appendTo(icu::FormattedList *this, icu::Appendable *a2, UErrorCode *a3)
{
  uint64_t v4 = *((void *)this + 1);
  if (!v4)
  {
    *a3 = *((UErrorCode *)this + 4);
    return a2;
  }

  return (icu::Appendable *)(*(uint64_t (**)(void, icu::Appendable *))(*(void *)v4 + 32LL))( *((void *)this + 1),  a2);
}

uint64_t icu::FormattedList::nextPosition( icu::FormattedList *this, icu::ConstrainedFieldPosition *a2, UErrorCode *a3)
{
  uint64_t v4 = *((void *)this + 1);
  if (!v4)
  {
    *a3 = *((UErrorCode *)this + 4);
    return 0LL;
  }

  return (*(uint64_t (**)(void, icu::ConstrainedFieldPosition *))(*(void *)v4 + 40LL))( *((void *)this + 1),  a2);
}

icu::ListFormatter *icu::ListFormatter::ListFormatter( icu::ListFormatter *this, const icu::ListFormatter *a2)
{
  *(void *)this = off_1897252E8;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  uint64_t v3 = (uint64_t *)*((void *)a2 + 1);
  if (v3)
  {
    unsigned int v5 = icu::UMemory::operator new(v3, (icu::UMemory *)0xA8, (unint64_t)a2);
    if (v5) {
      unsigned int v5 = (uint64_t *)sub_1808FFAD4((uint64_t)v5, *((void *)a2 + 1));
    }
    *((void *)this + sub_1808F7164((uint64_t)v14, 1) = v5;
    *((void *)this + 2) = v5;
  }

  return this;
}

uint64_t icu::ListFormatter::operator=(uint64_t a1, unint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void **)(a1 + 8);
    if (v4)
    {
      uint64_t v5 = v4[19];
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      }
      icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(v4 + 10));
      icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(v4 + 1));
      icu::UMemory::operator delete(v4);
    }

    UErrorCode v6 = *(uint64_t **)(a2 + 8);
    if (v6)
    {
      int v7 = icu::UMemory::operator new(v6, (icu::UMemory *)0xA8, a2);
      if (v7) {
        int v7 = (uint64_t *)sub_1808FFAD4((uint64_t)v7, *(void *)(a2 + 8));
      }
      *(void *)(a1 + 8) = v7;
    }

    else
    {
      *(void *)(a1 + 8) = 0LL;
      int v7 = *(uint64_t **)(a2 + 16);
    }

    *(void *)(a1 + 16) = v7;
  }

  return a1;
}

void *sub_1808FE678(void *a1)
{
  uint64_t v2 = a1[19];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 10));
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 1));
  return a1;
}

void icu::ListFormatter::initializeHash(icu::ListFormatter *this, UErrorCode *a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)this;
  if ((int)v2 <= 0)
  {
    uint64_t v4 = (int32x2_t *)icu::UMemory::operator new(v2, (icu::UMemory *)0x58, (unint64_t)a2);
    if (v4)
    {
      uint64_t v5 = (uint64_t *)v4;
      *uint64_t v4 = 0LL;
      uint64_t v6 = (uint64_t)&v4[1];
      int v7 = 0;
      uhash_init(v4 + 1, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0LL, &v7);
      if (v7 <= 0)
      {
        *uint64_t v5 = v6;
        uhash_setKeyDeleter(v6, (uint64_t)uprv_deleteUObject);
      }

      qword_18C449428 = (uint64_t)v5;
      uhash_setValueDeleter(*v5, (uint64_t)sub_1808FE784);
      sub_1809B36C0(0x22u, (uint64_t)sub_1808FE7D0);
    }

    else
    {
      qword_18C449428 = 0LL;
      *(_DWORD *)this = 7;
    }
  }

void sub_1808FE784(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[19];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 10));
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 1));
    icu::UMemory::operator delete(a1);
  }

uint64_t sub_1808FE7D0()
{
  unsigned int v0 = (void *)qword_18C449428;
  if (qword_18C449428)
  {
    if (*(void *)qword_18C449428) {
      uhash_close(*(_BYTE **)qword_18C449428);
    }
    icu::UMemory::operator delete(v0);
  }

  qword_18C449428 = 0LL;
  return 1LL;
}

void *icu::ListFormatter::getListFormatInternal( const char **this, const icu::Locale *a2, UErrorCode *a3, UErrorCode *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v24 = 0LL;
  memset(&v23[1], 0, 48);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v20, this[5]);
  v23[0] = (char *)&v23[1] + 5;
  LODWORD(v23[1]) = 40;
  WORD2(v23[1]) = 0;
  LODWORD(v24) = 0;
  icu::CharString::append((icu::CharString *)v23, v20, v21, a3);
  int v8 = icu::CharString::append((icu::CharString *)v23, 58, a3);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v18, (const char *)a2);
  icu::CharString::append(v8, v18, v19, a3);
  memset(v22, 0, sizeof(v22));
  icu::UnicodeString::UnicodeString(v22, v23[0], 0xFFFFFFFFLL, 0LL);
  umtx_lock((icu::UMutex *)&unk_18C449430);
  unsigned int v10 = (uint64_t *)qword_18C449428;
  if (!qword_18C449428)
  {
    icu::ListFormatter::initializeHash((icu::ListFormatter *)a3, v9);
    if (*(int *)a3 > 0)
    {
LABEL_8:
      uint64_t v4 = 0LL;
      goto LABEL_14;
    }

    unsigned int v10 = (uint64_t *)qword_18C449428;
  }

  uint64_t v4 = (void *)uhash_get(*v10, (uint64_t)v22);
  umtx_unlock((std::mutex **)&unk_18C449430);
  if (v4) {
    goto LABEL_15;
  }
  ListFormatInternal = icu::ListFormatter::loadListFormatInternal((char **)this, a2, (char *)a3, v11);
  int v12 = (void *)*(unsigned int *)a3;
  if ((int)v12 > 0)
  {
    uint64_t v4 = 0LL;
    goto LABEL_15;
  }

  uint64_t v4 = ListFormatInternal;
  umtx_lock((icu::UMutex *)&unk_18C449430);
  uint64_t v14 = uhash_get(*(void *)qword_18C449428, (uint64_t)v22);
  if (v14)
  {
    int v15 = (void *)v14;
    if (v4)
    {
      int v16 = sub_1808FE678(v4);
      icu::UMemory::operator delete(v16);
    }

    uint64_t v4 = v15;
    goto LABEL_14;
  }

  sub_1807C33C4((uint64_t *)qword_18C449428, (UChar **)v22, (uint64_t)v4, (int *)a3);
LABEL_14:
  umtx_unlock((std::mutex **)&unk_18C449430);
LABEL_15:
  icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v22);
  if (BYTE4(v23[1])) {
    uprv_free(v23[0]);
  }
  return v4;
}

uint64_t *icu::ListFormatter::loadListFormatInternal( char **this, const icu::Locale *a2, char *a3, UErrorCode *a4)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v7 = ures_open(0LL, this[5], (int *)a3);
  uint64_t v8 = ures_getByKeyWithFallback(v7, "listPattern", v7, (UErrorCode *)a3);
  uint64_t v9 = v8;
  if (*(int *)a3 < 1)
  {
    uint64_t v38 = 0LL;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    uint64_t v33 = 0LL;
    __int128 v35 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    uint64_t v28 = 0LL;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v22 = 0u;
    uint64_t v23 = 0LL;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    int v18 = off_189725310;
    int v19 = off_18971B688;
    LOWORD(v20) = 2;
    uint64_t v24 = off_18971B688;
    LOWORD(v25) = 2;
    unint64_t v29 = off_18971B688;
    LOWORD(v30) = 2;
    int v34 = off_18971B688;
    LOWORD(v35) = 2;
    memset(v39, 0, sizeof(v39));
    strncpy(__dst, (const char *)a2, 0x18uLL);
    __dst[24] = 0;
    ures_getAllItemsWithFallback(v9, __dst, (uint64_t)&v18, (int *)a3);
    if (*(int *)a3 <= 0 && v39[0])
    {
      do
      {
        if (!strcmp(__dst, v39)) {
          break;
        }
        strcpy(__dst, v39);
        ures_getAllItemsWithFallback(v9, __dst, (uint64_t)&v18, (int *)a3);
      }

      while (*(int *)a3 <= 0 && v39[0] != 0);
    }

    ures_close(v9);
    if ((unsigned __int16)v20 < 0x20u
      || (unsigned __int16)v25 < 0x20u
      || (unsigned __int16)v30 < 0x20u
      || (unsigned __int16)v35 <= 0x1Fu)
    {
      unsigned int v10 = 0LL;
      int v15 = 2;
    }

    else
    {
      uint64_t v13 = icu::UMemory::operator new((uint64_t *)(unsigned __int16)v35, (icu::UMemory *)0xA8, v12);
      unsigned int v10 = v13;
      if (v13)
      {
        sub_1808FFB2C( (uint64_t)v13,  (uint64_t)&v19,  (icu::UnicodeString *)&v24,  (const icu::UnicodeString *)&v29,  (uint64_t)&v34,  (uint64_t)this,  (UErrorCode *)a3);
        uint64_t v14 = sub_1808FE678(v10);
        icu::UMemory::operator delete(v14);
LABEL_12:
        unsigned int v10 = 0LL;
LABEL_23:
        sub_1808FEC90((uint64_t)&v18);
        return v10;
      }

      int v15 = 7;
    }

    *(_DWORD *)a3 = v15;
    goto LABEL_23;
  }

  ures_close(v8);
  return 0LL;
}

void sub_1808FEC90(uint64_t a1)
{
  *(void *)a1 = off_189725310;
  uint64_t v2 = (icu::UnicodeString *)(a1 + 8);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 200));
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 136));
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 72));
  icu::UnicodeString::~UnicodeString(v2);
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)a1);
}

void sub_1808FECE4(uint64_t a1)
{
}

uint64_t *icu::ListFormatter::createInstance(UErrorCode *this, UErrorCode *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  memset(v6, 0, sizeof(v6));
  icu::Locale::Locale((icu::Locale *)v6);
  uint64_t Instance = icu::ListFormatter::createInstance((const char **)v6, (const icu::Locale *)"standard", this, v3);
  icu::Locale::~Locale((icu::Locale *)v6);
  return Instance;
}

uint64_t *icu::ListFormatter::createInstance( const char **this, UErrorCode *a2, UErrorCode *a3, UErrorCode *a4)
{
  return icu::ListFormatter::createInstance(this, (const icu::Locale *)"standard", a2, a4);
}

uint64_t *icu::ListFormatter::createInstance(const char **a1, int a2, unsigned int a3, UErrorCode *a4)
{
  if (a2 == 2)
  {
    if (a3 < 3)
    {
      uint64_t v4 = off_189725528;
      return icu::ListFormatter::createInstance(a1, (const icu::Locale *)v4[a3], a4, a4);
    }
  }

  else if (a2 == 1)
  {
    if (a3 < 3)
    {
      uint64_t v4 = off_189725510;
      return icu::ListFormatter::createInstance(a1, (const icu::Locale *)v4[a3], a4, a4);
    }
  }

  else if (!a2 && a3 < 3)
  {
    uint64_t v4 = off_1897254F8;
    return icu::ListFormatter::createInstance(a1, (const icu::Locale *)v4[a3], a4, a4);
  }

  *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  return 0LL;
}

uint64_t *icu::ListFormatter::createInstance( const char **this, const icu::Locale *a2, UErrorCode *a3, UErrorCode *a4)
{
  ListFormatInternal = icu::ListFormatter::getListFormatInternal(this, a2, a3, a4);
  uint64_t v7 = (uint64_t *)*(unsigned int *)a3;
  uint64_t v9 = ListFormatInternal;
  uint64_t result = icu::UMemory::operator new(v7, (icu::UMemory *)0x18, v6);
  if (result)
  {
    *uint64_t result = (uint64_t)off_1897252E8;
    result[1] = 0LL;
    result[2] = (uint64_t)v9;
  }

  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return result;
}

void *icu::ListFormatter::ListFormatter(void *result, uint64_t a2)
{
  *uint64_t result = off_1897252E8;
  result[1] = 0LL;
  result[2] = a2;
  return result;
}

{
  *uint64_t result = off_1897252E8;
  result[1] = 0LL;
  result[2] = a2;
  return result;
}

void *icu::ListFormatter::ListFormatter(void *a1, unint64_t a2, UErrorCode *a3)
{
  *a1 = off_1897252E8;
  unint64_t v6 = icu::UMemory::operator new((uint64_t *)off_1897252E8, (icu::UMemory *)0xA8, a2);
  if (v6) {
    unint64_t v6 = (uint64_t *)sub_1809010A8((uint64_t)v6, a2, a3);
  }
  a1[1] = v6;
  a1[2] = v6;
  return a1;
}

void icu::ListFormatter::~ListFormatter(icu::ListFormatter *this)
{
  *(void *)this = off_1897252E8;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = v2[19];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(v2 + 10));
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(v2 + 1));
    icu::UMemory::operator delete(v2);
  }

  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::ListFormatter::~ListFormatter(this);
  icu::UMemory::operator delete(v1);
}

icu::UnicodeString *icu::ListFormatter::format( icu::ListFormatter *this, const icu::UnicodeString *a2, int a3, icu::UnicodeString *a4, UErrorCode *a5)
{
  return a4;
}

icu::UnicodeString *icu::ListFormatter::format( icu::ListFormatter *this, const icu::UnicodeString *a2, int a3, icu::UnicodeString *a4, int a5, int *a6, UErrorCode *a7)
{
  unsigned int v11 = *((unsigned __int16 *)a4 + 4);
  int v12 = (__int16)v11;
  unsigned int v13 = v11 >> 5;
  if (v12 >= 0) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = *((_DWORD *)a4 + 3);
  }
  int v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  icu::ListFormatter::formatStringsToValue(this, a2, a7, a3, (uint64_t)&v18);
  v17[0] = &unk_18971B6F0;
  v17[1] = a4;
  if (*(int *)a7 <= 0)
  {
    if (!v19)
    {
      *a7 = v20;
      if (a5 < 0) {
        goto LABEL_15;
      }
      goto LABEL_8;
    }

    (*(void (**)(uint64_t, void *, UErrorCode *))(*(void *)v19 + 32LL))(v19, v17, a7);
  }

  if (a5 < 0) {
    goto LABEL_15;
  }
LABEL_8:
  memset(v16, 0, sizeof(v16));
  icu::ConstrainedFieldPosition::ConstrainedFieldPosition((uint64_t)v16);
  icu::ConstrainedFieldPosition::constrainField((uint64_t)v16, 4099, a5);
  if (*(int *)a7 <= 0)
  {
    if (v19) {
      (*(void (**)(uint64_t, _OWORD *, UErrorCode *))(*(void *)v19 + 40LL))(v19, v16, a7);
    }
    else {
      *a7 = v20;
    }
  }

  *a6 = HIDWORD(v16[0]) + v14;
  icu::ConstrainedFieldPosition::~ConstrainedFieldPosition((icu::ConstrainedFieldPosition *)v16);
LABEL_15:
  icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v17);
  int v18 = off_1897252A8;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  uint64_t v19 = 0LL;
  icu::FormattedValue::~FormattedValue((icu::FormattedValue *)&v18);
  return a4;
}

uint64_t *icu::ListFormatter::formatStringsToValue@<X0>( icu::ListFormatter *this@<X0>, const icu::UnicodeString *a2@<X1>, UErrorCode *a3@<X3>, int a4@<W2>, uint64_t a5@<X8>)
{
  if (a4 == 2)
  {
    __int128 v35 = 0LL;
    int v13 = icu::ListFormatter::needsBidiIsolates(this, a2);
    sub_1808FF50C((uint64_t *)&v35, (unint64_t)a2, v13, a3, v14);
    UErrorCode v15 = *a3;
    if (*(int *)a3 > 0
      || (int v16 = (const icu::UnicodeString *)((char *)a2 + 64),
          uint64_t v17 = (*(uint64_t (**)(void, const icu::UnicodeString *, char *))(**(void **)(*((void *)this + 2) + 152LL)
                                                                                      + 32LL))( *(void *)(*((void *)this + 2) + 152LL),  a2,  (char *)a2 + 64),  v18 = icu::ListFormatter::needsBidiIsolates(this, v16),  sub_1808FF5EC((uint64_t *)&v35, v17, (uint64_t)v16, 1, v18, a3),  icu::FormattedStringBuilder::writeTerminator((icu::FormattedStringBuilder *)(v35 + 1), a3),  UErrorCode v15 = *a3,  *(int *)a3 > 0))
    {
LABEL_18:
      uint64_t v33 = 0LL;
      goto LABEL_19;
    }

uint64_t icu::ListFormatter::needsBidiIsolates(icu::ListFormatter *this, const icu::UnicodeString *a2)
{
  unsigned int v2 = *((unsigned __int16 *)a2 + 4);
  int v3 = (__int16)v2;
  int v4 = v2 >> 5;
  if (v3 < 0) {
    int v4 = *((_DWORD *)a2 + 3);
  }
  if (v4 < 1) {
    return 0LL;
  }
  int v6 = 0;
  uint64_t v7 = *((void *)this + 2);
  int v8 = *(unsigned __int8 *)(v7 + 160);
  while (1)
  {
    unsigned int v9 = icu::UnicodeString::char32At((uint64_t *)v7, a2, v6);
    unsigned int Class = ubidi_getClass(v9);
    if (Class > 0xF) {
      goto LABEL_11;
    }
    if (((1 << Class) & 0xE022) == 0) {
      break;
    }
    if (!v8) {
      return 1LL;
    }
LABEL_11:
    ++v6;
    unsigned int v11 = *((unsigned __int16 *)a2 + 4);
    int v12 = (__int16)v11;
    LODWORD(v7) = v11 >> 5;
    if (v12 >= 0) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = *((unsigned int *)a2 + 3);
    }
  }

  if (((1 << Class) & 0x1801) == 0 || !v8) {
    goto LABEL_11;
  }
  return 1LL;
}

uint64_t *sub_1808FF50C@<X0>( uint64_t *a1@<X0>, unint64_t a2@<X1>, int a3@<W2>, UErrorCode *a4@<X3>, uint64_t *a5@<X8>)
{
  unsigned int v9 = icu::UMemory::operator new(a5, (icu::UMemory *)0x130, a2);
  if (v9)
  {
    uint64_t v10 = icu::FormattedValueStringBuilderImpl::FormattedValueStringBuilderImpl((uint64_t)v9, 0);
    *(void *)uint64_t v10 = &off_189725378;
    *a1 = v10;
    if (*(int *)a4 <= 0)
    {
      icu::FormattedStringBuilder::insert( (icu::FormattedStringBuilder *)(v10 + 8),  *(_DWORD *)(v10 + 140),  a2,  49,  a3,  a4);
      unsigned int v11 = *(unsigned __int16 *)(a2 + 8);
      int v12 = (__int16)v11;
      unsigned int v13 = v11 >> 5;
      if (v12 < 0) {
        unsigned int v13 = *(_DWORD *)(a2 + 12);
      }
      if (a3) {
        int v14 = 2;
      }
      else {
        int v14 = 0;
      }
      icu::FormattedValueStringBuilderImpl::appendSpanInfo(*a1, 4099, 0, -1, v13 + v14, (int *)a4);
    }
  }

  else
  {
    *a1 = 0LL;
  }

  return a1;
}

uint64_t *sub_1808FF5EC(uint64_t *result, uint64_t a2, uint64_t a3, int a4, int a5, UErrorCode *a6)
{
  __b[1] = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    uint64_t v10 = result;
    unsigned int v11 = *(unsigned __int16 *)(a2 + 16);
    if ((v11 & 0x11) != 0)
    {
      int v12 = 0LL;
    }

    else if ((v11 & 2) != 0)
    {
      int v12 = (_WORD *)(a2 + 18);
    }

    else
    {
      int v12 = *(_WORD **)(a2 + 32);
    }

    int v13 = (__int16)v11;
    unsigned int v14 = v11 >> 5;
    if (v13 < 0) {
      unsigned int v14 = *(_DWORD *)(a2 + 20);
    }
    if (v14 && *v12 == 2)
    {
      __b[0] = 0LL;
      memset(v37, 0, sizeof(v37));
      sub_1808E5E78(__b, a2, 2, (uint64_t)v37);
      UErrorCode v15 = (icu::FormattedStringBuilder *)(*v10 + 8);
      if (SLODWORD(__b[0]) <= SHIDWORD(__b[0]))
      {
        icu::UnicodeString::tempSubString((icu::UnicodeString *)v37, 0, __b[0], (icu::UnicodeString *)v36);
        icu::FormattedStringBuilder::insert(v15, 0, (uint64_t)v36, 48, 0, a6);
        icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v36);
        uint64_t v27 = *v10;
        uint64_t v28 = (icu::FormattedStringBuilder *)(*v10 + 8);
        icu::UnicodeString::tempSubString( (icu::UnicodeString *)v37,  __b[0],  HIDWORD(__b[0]) - LODWORD(__b[0]),  (icu::UnicodeString *)v36);
        icu::FormattedStringBuilder::insert(v28, *(_DWORD *)(v27 + 140), (uint64_t)v36, 48, 0, a6);
        icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)v36);
        icu::FormattedStringBuilder::insert( (icu::FormattedStringBuilder *)(*v10 + 8),  *(_DWORD *)(*v10 + 140),  a3,  49,  a5,  a6);
        unsigned int v30 = *(unsigned __int16 *)(a3 + 8);
        int v31 = (__int16)v30;
        unsigned int v32 = v30 >> 5;
        if (v31 < 0) {
          unsigned int v32 = *(_DWORD *)(a3 + 12);
        }
        if (a5) {
          int v33 = 2;
        }
        else {
          int v33 = 0;
        }
        icu::FormattedValueStringBuilderImpl::appendSpanInfo(*v10, 4099, a4, -1, v32 + v33, (int *)a6);
        uint64_t v23 = *v10;
        uint64_t v24 = (icu::FormattedStringBuilder *)(*v10 + 8);
        int v25 = HIDWORD(__b[0]);
      }

      else
      {
        icu::UnicodeString::tempSubString( (icu::UnicodeString *)v37,  SHIDWORD(__b[0]),  LODWORD(__b[0]) - HIDWORD(__b[0]),  (icu::UnicodeString *)v36);
        icu::FormattedStringBuilder::insert(v15, 0, (uint64_t)v36, 48, 0, a6);
        icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v36);
        icu::FormattedStringBuilder::insert((icu::FormattedStringBuilder *)(*v10 + 8), 0, a3, 49, a5, a6);
        unsigned int v17 = *(unsigned __int16 *)(a3 + 8);
        int v18 = (__int16)v17;
        unsigned int v19 = v17 >> 5;
        if (v18 < 0) {
          unsigned int v19 = *(_DWORD *)(a3 + 12);
        }
        if (a5) {
          int v20 = 2;
        }
        else {
          int v20 = 0;
        }
        icu::FormattedValueStringBuilderImpl::prependSpanInfo(*v10, 4099, a4, -1, v19 + v20, (int *)a6);
        UErrorCode v21 = (icu::FormattedStringBuilder *)(*v10 + 8);
        icu::UnicodeString::tempSubString((icu::UnicodeString *)v37, 0, SHIDWORD(__b[0]), (icu::UnicodeString *)v36);
        icu::FormattedStringBuilder::insert(v21, 0, (uint64_t)v36, 48, 0, a6);
        icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v36);
        uint64_t v23 = *v10;
        uint64_t v24 = (icu::FormattedStringBuilder *)(*v10 + 8);
        int v25 = __b[0];
      }

      icu::UnicodeString::tempSubString((icu::UnicodeString *)v37, v25, 0x7FFFFFFF, (icu::UnicodeString *)v36);
      icu::FormattedStringBuilder::insert(v24, *(_DWORD *)(v23 + 140), (uint64_t)v36, 48, 0, a6);
      icu::UnicodeString::~UnicodeString(v34, (icu::UnicodeString *)v36);
      return (uint64_t *)icu::UnicodeString::~UnicodeString(v35, (icu::UnicodeString *)v37);
    }

    else
    {
      *a6 = U_INTERNAL_PROGRAM_ERROR;
    }
  }

  return result;
}

uint64_t sub_1808FF8F8(unsigned __int16 *a1, char *a2, icu::ResourceValue *a3, uint64_t a4, int *a5)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  __s1 = a2;
  *((_BYTE *)a1 + 264) = 0;
  if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24LL))(a3) == 3)
  {
    int v19 = 0;
    *(void *)&v16[0] = (*(uint64_t (**)(icu::ResourceValue *, int *, int *))(*(void *)a3 + 40LL))( a3,  &v19,  a5);
    icu::UnicodeString::UnicodeString(v20, 1LL, v16);
    sub_180901180((uint64_t)a1, (uint64_t)v20);
    return (uint64_t)icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v20);
  }

  else
  {
    uint64_t v17 = 0LL;
    memset(v16, 0, sizeof(v16));
    uint64_t result = (uint64_t)(*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, int *))(*(void *)a3 + 88LL))( v16,  a3,  a5);
    if (*a5 <= 0)
    {
      unsigned int v10 = 0;
      do
      {
        uint64_t result = icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v16, v10, (const char **)&__s1, a3);
        if (!(_DWORD)result) {
          break;
        }
        unsigned int v11 = __s1;
        int v12 = strcmp(__s1, "2");
        int v13 = a1 + 4;
        if (v12)
        {
          int v14 = strcmp(v11, "end");
          int v13 = a1 + 100;
          if (v14)
          {
            int v15 = strcmp(v11, "middle");
            int v13 = a1 + 68;
            if (v15)
            {
              uint64_t result = strcmp(v11, "start");
              int v13 = a1 + 36;
              if ((_DWORD)result) {
                continue;
              }
            }
          }
        }

        uint64_t result = (uint64_t)sub_180901260(a1, (uint64_t)a3, v13, (uint64_t)a5);
        ++v10;
      }

      while (*a5 <= 0);
    }
  }

  return result;
}

uint64_t sub_1808FFAD4(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 152) = (*(uint64_t (**)(void))(**(void **)(a2 + 152) + 24LL))(*(void *)(a2 + 152));
  *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
  return a1;
}

uint64_t sub_1808FFB2C( uint64_t a1, uint64_t a2, icu::UnicodeString *a3, const icu::UnicodeString *a4, uint64_t a5, uint64_t a6, UErrorCode *a7)
{
  *(void *)(a1 + 16) = off_18971B688;
  *(_WORD *)(a1 + 24) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)(a1 + 8), a3, 2, 2, 0, a7);
  *(void *)(a1 + 88) = off_18971B688;
  *(_WORD *)(a1 + 96) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)(a1 + 80), a4, 2, 2, 0, a7);
  int v13 = sub_1808FFC18((const char *)(a6 + 8), a2, a5, a7);
  *(void *)(a1 + 152) = v13;
  *(_BYTE *)(a1 + 160) = uloc_getCharacterOrientation(*(char **)(a6 + 40), (int32_t *)a7) == 1;
  return a1;
}

uint64_t *sub_1808FFC18(const char *a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v7 = (uint64_t *)a1;
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (strcmp(a1, "es"))
  {
    if (strcmp((const char *)v7, "he") && strcmp((const char *)v7, "iw"))
    {
      if (!strcmp((const char *)v7, "th"))
      {
        unsigned int v10 = icu::UMemory::operator new(v9, (icu::UMemory *)0x238, v8);
        uint64_t v7 = v10;
        if (v10) {
          sub_180900518((uint64_t)v10, (const icu::UnicodeString *)a2, (const icu::UnicodeString *)a3, a4);
        }
        return v7;
      }

      goto LABEL_105;
    }

    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    int v66 = a0_2;
    icu::UnicodeString::UnicodeString(&v76, 1LL, &v66);
    v64[1] = (uint64_t)v66;
    unsigned int v11 = *(unsigned __int16 *)(a2 + 8);
    if ((v11 & 1) != 0)
    {
      int v12 = BYTE8(v76) & 1;
    }

    else
    {
      int v12 = 0;
      int v13 = (__int16)v11;
      int v14 = v11 >> 5;
      if (v13 >= 0) {
        int v15 = v14;
      }
      else {
        int v15 = *(_DWORD *)(a2 + 12);
      }
      if ((SWORD4(v76) & 0x8000u) == 0) {
        int v16 = WORD4(v76) >> 5;
      }
      else {
        int v16 = HIDWORD(v76);
      }
      if ((BYTE8(v76) & 1) == 0 && v15 == v16) {
        int v12 = icu::UnicodeString::doEquals((icu::UnicodeString *)a2, (const icu::UnicodeString *)&v76, v15);
      }
    }

    unsigned int v23 = *(unsigned __int16 *)(a3 + 8);
    if ((v23 & 1) != 0)
    {
      int v24 = BYTE8(v76) & 1;
    }

    else
    {
      int v24 = 0;
      int v25 = (__int16)v23;
      int v26 = v23 >> 5;
      if (v25 >= 0) {
        int v27 = v26;
      }
      else {
        int v27 = *(_DWORD *)(a3 + 12);
      }
      if ((SWORD4(v76) & 0x8000u) == 0) {
        int v28 = WORD4(v76) >> 5;
      }
      else {
        int v28 = HIDWORD(v76);
      }
      if ((BYTE8(v76) & 1) == 0 && v27 == v28) {
        int v24 = icu::UnicodeString::doEquals((icu::UnicodeString *)a3, (const icu::UnicodeString *)&v76, v27);
      }
    }

    if (((v12 | v24) & 1) != 0)
    {
      __int128 v74 = 0u;
      __int128 v75 = 0u;
      __int128 v72 = 0u;
      __int128 v73 = 0u;
      BOOL v65 = &unk_180A48132;
      icu::UnicodeString::UnicodeString(&v72, 1LL, &v65);
      v64[0] = (uint64_t)v65;
      uint64_t v7 = icu::UMemory::operator new(v64, (icu::UMemory *)0x130, v29);
      if (v7)
      {
        if (v12) {
          int v31 = (const icu::UnicodeString *)&v72;
        }
        else {
          int v31 = (const icu::UnicodeString *)a2;
        }
        if (v24) {
          unsigned int v32 = (const icu::UnicodeString *)&v72;
        }
        else {
          unsigned int v32 = (const icu::UnicodeString *)a3;
        }
        int v33 = sub_1809004D0;
LABEL_70:
        sub_180900304( (uint64_t)v7,  (uint64_t)v33,  v31,  (const icu::UnicodeString *)a2,  v32,  (const icu::UnicodeString *)a3,  a4);
        goto LABEL_71;
      }

      goto LABEL_71;
    }

    icu::UnicodeString::~UnicodeString((void *)(v12 | v24), (icu::UnicodeString *)&v76);
    goto LABEL_105;
  }

  __int128 v78 = 0u;
  __int128 v79 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  uint64_t v70 = L"{0} y {1}";
  icu::UnicodeString::UnicodeString(&v76, 1LL, &v70);
  v63[2] = (uint64_t)v70;
  unsigned int v17 = *(unsigned __int16 *)(a2 + 8);
  if ((v17 & 1) != 0)
  {
    int v18 = BYTE8(v76) & 1;
  }

  else
  {
    int v18 = 0;
    int v19 = (__int16)v17;
    int v20 = v17 >> 5;
    if (v19 >= 0) {
      int v21 = v20;
    }
    else {
      int v21 = *(_DWORD *)(a2 + 12);
    }
    if ((SWORD4(v76) & 0x8000u) == 0) {
      int v22 = WORD4(v76) >> 5;
    }
    else {
      int v22 = HIDWORD(v76);
    }
    if ((BYTE8(v76) & 1) == 0 && v21 == v22) {
      int v18 = icu::UnicodeString::doEquals((icu::UnicodeString *)a2, (const icu::UnicodeString *)&v76, v21);
    }
  }

  unsigned int v34 = *(unsigned __int16 *)(a3 + 8);
  if ((v34 & 1) != 0)
  {
    int v35 = BYTE8(v76) & 1;
  }

  else
  {
    int v35 = 0;
    int v36 = (__int16)v34;
    int v37 = v34 >> 5;
    if (v36 >= 0) {
      int v38 = v37;
    }
    else {
      int v38 = *(_DWORD *)(a3 + 12);
    }
    if ((SWORD4(v76) & 0x8000u) == 0) {
      int v39 = WORD4(v76) >> 5;
    }
    else {
      int v39 = HIDWORD(v76);
    }
    if ((BYTE8(v76) & 1) == 0 && v38 == v39) {
      int v35 = icu::UnicodeString::doEquals((icu::UnicodeString *)a3, (const icu::UnicodeString *)&v76, v38);
    }
  }

  if ((v18 | v35) == 1)
  {
    __int128 v74 = 0uLL;
    __int128 v75 = 0uLL;
    __int128 v72 = 0uLL;
    __int128 v73 = 0uLL;
    __int128 v69 = L"{0} e {1}";
    icu::UnicodeString::UnicodeString(&v72, 1LL, &v69);
    int v62 = v69;
    uint64_t v7 = icu::UMemory::operator new((uint64_t *)&v62, (icu::UMemory *)0x130, v40);
    if (v7)
    {
      if (v18) {
        int v31 = (const icu::UnicodeString *)&v72;
      }
      else {
        int v31 = (const icu::UnicodeString *)a2;
      }
      if (v35) {
        unsigned int v32 = (const icu::UnicodeString *)&v72;
      }
      else {
        unsigned int v32 = (const icu::UnicodeString *)a3;
      }
      int v33 = sub_1809001E0;
      goto LABEL_70;
    }

BOOL sub_1809001E0(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0)
  {
    int v2 = *(_DWORD *)(a1 + 12);
    if (!v2) {
      return 0LL;
    }
  }

  else
  {
    if (v1 < 0x20) {
      return 0LL;
    }
    int v2 = v1 >> 5;
  }

  if ((v1 & 2) != 0) {
    int v3 = (unsigned __int16 *)(a1 + 10);
  }
  else {
    int v3 = *(unsigned __int16 **)(a1 + 24);
  }
  int v4 = *v3;
  if (v4 != 104)
  {
    if ((v1 & 0x8000u) == 0) {
      unsigned int v5 = v1 >> 5;
    }
    else {
      unsigned int v5 = *(_DWORD *)(a1 + 12);
    }
    if (!v5) {
      return 0LL;
    }
    if (v2 < 2 || v4 != 72) {
      goto LABEL_33;
    }
    goto LABEL_18;
  }

  unsigned int v5 = *(_DWORD *)(a1 + 12);
  if (v2 > 1)
  {
    if ((v1 & 0x8000u) == 0) {
      unsigned int v5 = v1 >> 5;
    }
LABEL_18:
    if (v5 >= 2)
    {
      if ((v1 & 2) != 0) {
        uint64_t v6 = a1 + 10;
      }
      else {
        uint64_t v6 = *(void *)(a1 + 24);
      }
      if ((*(unsigned __int16 *)(v6 + 2) | 0x20) == 0x69)
      {
        uint64_t v7 = 1LL;
        if (v2 == 2 || v5 < 3) {
          return v7;
        }
        uint64_t v7 = 1LL;
        if ((unsigned __int16)(((unsigned __int16)(*(_WORD *)(v6 + 4) - 65) >> 2) | ((*(_WORD *)(v6 + 4) - 65) << 14)) > 9u
          || ((1 << ((unsigned __int16)(*(_WORD *)(v6 + 4) - 65) >> 2)) & 0x303) == 0)
        {
          return v7;
        }
      }

      goto LABEL_33;
    }

uint64_t sub_180900304( uint64_t a1, uint64_t a2, const icu::UnicodeString *a3, const icu::UnicodeString *a4, const icu::UnicodeString *a5, const icu::UnicodeString *a6, UErrorCode *a7)
{
  int v12 = (void *)sub_180900B44(a1, a4, a6, a7);
  *int v12 = off_189725400;
  v12[19] = a2;
  *(void *)(a1 + 168) = off_18971B688;
  *(_WORD *)(a1 + 176) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)(v12 + 20), a3, 2, 2, 0, a7);
  *(void *)(a1 + 240) = off_18971B688;
  *(_WORD *)(a1 + 248) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)(a1 + 232), a5, 2, 2, 0, a7);
  return a1;
}

BOOL sub_1809003BC(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0)
  {
    int v2 = *(_DWORD *)(a1 + 12);
    if (!v2) {
      return 0LL;
    }
  }

  else
  {
    if (v1 < 0x20) {
      return 0LL;
    }
    int v2 = v1 >> 5;
  }

  if ((v1 & 2) != 0) {
    int v3 = (unsigned __int16 *)(a1 + 10);
  }
  else {
    int v3 = *(unsigned __int16 **)(a1 + 24);
  }
  int v4 = *v3;
  if (v4 == 111) {
    return 1LL;
  }
  unsigned int v6 = v1 >> 5;
  if ((v1 & 0x8000u) != 0) {
    unsigned int v6 = *(_DWORD *)(a1 + 12);
  }
  if (!v6) {
    return 0LL;
  }
  uint64_t v5 = 1LL;
  if (v4 != 56 && v4 != 79)
  {
    if (v4 == 104)
    {
      if (v2 < 2) {
        return 0LL;
      }
    }

    else if (v2 < 2 || v4 != 72)
    {
      if (v2 < 2) {
        return 0LL;
      }
      goto LABEL_27;
    }

    if (v6 >= 2)
    {
      uint64_t v7 = (v1 & 2) != 0 ? a1 + 10 : *(void *)(a1 + 24);
    }

BOOL sub_1809004D0(unsigned __int16 *a1)
{
  unsigned int v1 = (uint64_t *)a1[4];
  int v4 = 0;
  unsigned int v2 = icu::UnicodeString::char32At(v1, (icu::UnicodeString *)a1, 0);
  return uscript_getScript(v2, &v4) != 19;
}

uint64_t sub_180900518( uint64_t a1, const icu::UnicodeString *a2, const icu::UnicodeString *a3, UErrorCode *a4)
{
  v55[9] = *(UChar **)MEMORY[0x1895F89C0];
  unint64_t v8 = (void *)sub_180900B44(a1, a2, a3, a4);
  *unint64_t v8 = off_1897254B0;
  BOOL v9 = (icu::UnicodeString *)(v8 + 27);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v8 + 19), (UChar **)a2);
  icu::UnicodeString::UnicodeString(v9, (UChar **)a3);
  icu::UnicodeString::UnicodeString(a1 + 288, 0);
  icu::UnicodeString::UnicodeString(a1 + 360, 0);
  icu::UnicodeString::UnicodeString(a1 + 432, 0);
  icu::UnicodeString::UnicodeString(a1 + 504, 0);
  memset(v55, 0, 64);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v55, (UChar **)a2);
  icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)&unk_180A48146);
  else {
    int32_t v10 = HIDWORD(v49);
  }
  if ((v49 & 1) != 0 || v10 <= 0)
  {
    icu::UnicodeString::~UnicodeString((void *)(unsigned __int16)v49, (icu::UnicodeString *)v48);
  }

  else
  {
    if (SLOWORD(v55[1]) >= 0) {
      int32_t v11 = LOWORD(v55[1]) >> 5;
    }
    else {
      int32_t v11 = HIDWORD(v55[1]);
    }
    else {
      int v12 = v51;
    }
    int v13 = icu::UnicodeString::indexOf((uint64_t)v55, (uint64_t)v12, 0, v10, 0, v11);
    icu::UnicodeString::~UnicodeString(v14, (icu::UnicodeString *)v48);
    int v15 = 0;
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_24;
    }
  }

  icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)L"{0}");
  icu::UnicodeString::UnicodeString((uint64_t)v52, (uint64_t)&unk_180A48146);
  if (SLOWORD(v55[1]) >= 0) {
    int32_t v16 = LOWORD(v55[1]) >> 5;
  }
  else {
    int32_t v16 = HIDWORD(v55[1]);
  }
  else {
    uint64_t v17 = HIDWORD(v49);
  }
  int v18 = v53 >> 5;
  if ((v53 & 0x8000u) != 0) {
    int v18 = v54;
  }
  icu::UnicodeString::findAndReplace( (icu::UnicodeString *)v55,  0,  v16,  (const icu::UnicodeString *)v48,  0,  v17,  (const icu::UnicodeString *)v52,  0,  v18);
  icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v52);
  icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v48);
  int v15 = 1;
LABEL_24:
  int v49 = off_18971B688;
  __int16 v50 = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v48,  (const icu::UnicodeString *)v55,  2,  2,  0,  a4);
  icu::SimpleFormatter::operator=(a1 + 280, (uint64_t)v48);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v48);
  icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)L" {1}");
  else {
    int32_t v21 = HIDWORD(v49);
  }
  if ((v49 & 1) != 0 || v21 <= 0)
  {
    icu::UnicodeString::~UnicodeString((void *)(unsigned __int16)v49, (icu::UnicodeString *)v48);
  }

  else
  {
    if (SLOWORD(v55[1]) >= 0) {
      int32_t v22 = LOWORD(v55[1]) >> 5;
    }
    else {
      int32_t v22 = HIDWORD(v55[1]);
    }
    else {
      unsigned int v23 = v51;
    }
    int v24 = icu::UnicodeString::indexOf((uint64_t)v55, (uint64_t)v23, 0, v21, 0, v22);
    icu::UnicodeString::~UnicodeString(v25, (icu::UnicodeString *)v48);
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_47;
    }
  }

  icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)"{");
  icu::UnicodeString::UnicodeString((uint64_t)v52, (uint64_t)L" {1}");
  if (SLOWORD(v55[1]) >= 0) {
    int32_t v26 = LOWORD(v55[1]) >> 5;
  }
  else {
    int32_t v26 = HIDWORD(v55[1]);
  }
  else {
    uint64_t v27 = HIDWORD(v49);
  }
  int v28 = v53 >> 5;
  if ((v53 & 0x8000u) != 0) {
    int v28 = v54;
  }
  icu::UnicodeString::findAndReplace( (icu::UnicodeString *)v55,  0,  v26,  (const icu::UnicodeString *)v48,  0,  v27,  (const icu::UnicodeString *)v52,  0,  v28);
  icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)v52);
  icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)v48);
LABEL_47:
  int v49 = off_18971B688;
  __int16 v50 = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v48,  (const icu::UnicodeString *)v55,  2,  2,  0,  a4);
  icu::SimpleFormatter::operator=(a1 + 424, (uint64_t)v48);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v48);
  if (v15)
  {
    icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)&unk_180A48146);
    icu::UnicodeString::UnicodeString((uint64_t)v52, (uint64_t)L"{0}");
    if (SLOWORD(v55[1]) >= 0) {
      int32_t v31 = LOWORD(v55[1]) >> 5;
    }
    else {
      int32_t v31 = HIDWORD(v55[1]);
    }
    else {
      uint64_t v32 = HIDWORD(v49);
    }
    int v33 = v53 >> 5;
    if ((v53 & 0x8000u) != 0) {
      int v33 = v54;
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)v55,  0,  v31,  (const icu::UnicodeString *)v48,  0,  v32,  (const icu::UnicodeString *)v52,  0,  v33);
    icu::UnicodeString::~UnicodeString(v34, (icu::UnicodeString *)v52);
    icu::UnicodeString::~UnicodeString(v35, (icu::UnicodeString *)v48);
  }

  int v49 = off_18971B688;
  __int16 v50 = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v48,  (const icu::UnicodeString *)v55,  2,  2,  0,  a4);
  icu::SimpleFormatter::operator=(a1 + 352, (uint64_t)v48);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v48);
  icu::UnicodeString::operator=(v55, (UChar **)a3);
  icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)L" {1}");
  else {
    int32_t v36 = HIDWORD(v49);
  }
  if ((v49 & 1) != 0 || v36 <= 0)
  {
    icu::UnicodeString::~UnicodeString((void *)(unsigned __int16)v49, (icu::UnicodeString *)v48);
LABEL_71:
    icu::UnicodeString::UnicodeString((uint64_t)v48, (uint64_t)"{");
    icu::UnicodeString::UnicodeString((uint64_t)v52, (uint64_t)L" {1}");
    if (SLOWORD(v55[1]) >= 0) {
      int32_t v41 = LOWORD(v55[1]) >> 5;
    }
    else {
      int32_t v41 = HIDWORD(v55[1]);
    }
    else {
      uint64_t v42 = HIDWORD(v49);
    }
    int v43 = v53 >> 5;
    if ((v53 & 0x8000u) != 0) {
      int v43 = v54;
    }
    icu::UnicodeString::findAndReplace( (icu::UnicodeString *)v55,  0,  v41,  (const icu::UnicodeString *)v48,  0,  v42,  (const icu::UnicodeString *)v52,  0,  v43);
    icu::UnicodeString::~UnicodeString(v44, (icu::UnicodeString *)v52);
    icu::UnicodeString::~UnicodeString(v45, (icu::UnicodeString *)v48);
    goto LABEL_80;
  }

  if (SLOWORD(v55[1]) >= 0) {
    int32_t v37 = LOWORD(v55[1]) >> 5;
  }
  else {
    int32_t v37 = HIDWORD(v55[1]);
  }
  else {
    int v38 = v51;
  }
  int v39 = icu::UnicodeString::indexOf((uint64_t)v55, (uint64_t)v38, 0, v36, 0, v37);
  icu::UnicodeString::~UnicodeString(v40, (icu::UnicodeString *)v48);
  if (v39 < 0) {
    goto LABEL_71;
  }
LABEL_80:
  int v49 = off_18971B688;
  __int16 v50 = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v48,  (const icu::UnicodeString *)v55,  2,  2,  0,  a4);
  icu::SimpleFormatter::operator=(a1 + 496, (uint64_t)v48);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v48);
  icu::UnicodeString::~UnicodeString(v46, (icu::UnicodeString *)v55);
  return a1;
}

uint64_t sub_180900B44( uint64_t a1, const icu::UnicodeString *a2, const icu::UnicodeString *a3, UErrorCode *a4)
{
  *(void *)a1 = off_189725470;
  *(void *)(a1 + 16) = off_18971B688;
  *(_WORD *)(a1 + 24) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)(a1 + 8), a2, 2, 2, 0, a4);
  *(void *)(a1 + 88) = off_18971B688;
  *(_WORD *)(a1 + 96) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments((icu::SimpleFormatter *)(a1 + 80), a3, 2, 2, 0, a4);
  return a1;
}

void sub_180900BD8(void *a1)
{
  *a1 = off_189725400;
  unsigned int v2 = (icu::SimpleFormatter *)(a1 + 20);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 29));
  icu::SimpleFormatter::~SimpleFormatter(v2);
  sub_180900E1C((uint64_t)a1);
}

void sub_180900C18(void *a1)
{
}

uint64_t *sub_180900C2C(uint64_t a1, unint64_t a2)
{
  int32_t v10 = (uint64_t *)*MEMORY[0x1895F89C0];
  int v3 = icu::UMemory::operator new(v10, (icu::UMemory *)0x130, a2);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 152);
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v9, (UChar **)(a1 + 16));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v7, (UChar **)(a1 + 88));
    *int v3 = (uint64_t)off_189725470;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v3 + 2), v9);
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v3 + 11), v7);
    *int v3 = (uint64_t)off_189725400;
    v3[19] = v4;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v3 + 21), (UChar **)(a1 + 168));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v3 + 30), (UChar **)(a1 + 240));
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v6);
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v8);
  }

  return v3;
}

uint64_t sub_180900D28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = (*(uint64_t (**)(uint64_t))(a1 + 152))(a3);
  uint64_t v5 = 8LL;
  if (v4) {
    uint64_t v5 = 160LL;
  }
  return a1 + v5;
}

uint64_t sub_180900D64(uint64_t a1, uint64_t a2)
{
  int v3 = (*(uint64_t (**)(uint64_t))(a1 + 152))(a2);
  uint64_t v4 = 80LL;
  if (v3) {
    uint64_t v4 = 232LL;
  }
  return a1 + v4;
}

void sub_180900DA4(uint64_t a1)
{
}

uint64_t *sub_180900DB8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x98, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    *uint64_t v4 = (uint64_t)off_189725470;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v4 + 2), (UChar **)(a1 + 16));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v5 + 11), (UChar **)(a1 + 88));
  }

  return v5;
}

uint64_t sub_180900E0C(uint64_t a1)
{
  return a1 + 8;
}

uint64_t sub_180900E14(uint64_t a1)
{
  return a1 + 80;
}

void sub_180900E1C(uint64_t a1)
{
  *(void *)a1 = off_189725470;
  unsigned int v2 = (icu::SimpleFormatter *)(a1 + 8);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 80));
  icu::SimpleFormatter::~SimpleFormatter(v2);
  icu::UObject::~UObject((icu::UObject *)a1);
}

void sub_180900E5C(void *a1)
{
  *a1 = off_1897254B0;
  unsigned int v2 = (icu::UnicodeString *)(a1 + 19);
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 62));
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 53));
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 44));
  icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)(a1 + 35));
  icu::UnicodeString::~UnicodeString(v3, (icu::UnicodeString *)(a1 + 27));
  icu::UnicodeString::~UnicodeString(v4, v2);
  sub_180900E1C((uint64_t)a1);
}

void sub_180900EBC(void *a1)
{
}

uint64_t *sub_180900ED0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v5 = 0;
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x238, a2);
  if (result) {
    return (uint64_t *)sub_180900518( (uint64_t)result,  (const icu::UnicodeString *)(a1 + 152),  (const icu::UnicodeString *)(a1 + 216),  (UErrorCode *)&v5);
  }
  return result;
}

uint64_t sub_180900F14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = 0;
  int v22 = 0;
  unsigned int v6 = *(unsigned __int16 *)(a2 + 8);
  if (v6 >= 0x20)
  {
    if ((v6 & 0x8000) != 0)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 12);
      if (!v7)
      {
        unsigned int v10 = 0xFFFF;
LABEL_9:
        BOOL v5 = uscript_getScript(v10, &v22) != 38;
        goto LABEL_10;
      }
    }

    else
    {
      unsigned int v7 = v6 >> 5;
    }

    signed int v8 = v7 - 1;
    if ((v6 & 2) != 0) {
      uint64_t v9 = a2 + 10;
    }
    else {
      uint64_t v9 = *(void *)(a2 + 24);
    }
    unsigned int v10 = *(unsigned __int16 *)(v9 + 2LL * v8);
    goto LABEL_9;
  }

uint64_t sub_180901024(uint64_t a1, uint64_t a2)
{
  int v8 = 0;
  unsigned int v3 = *(unsigned __int16 *)(a2 + 8);
  if (v3 < 0x20) {
    return a1 + 80;
  }
  if ((v3 & 0x8000u) == 0 ? v3 >> 5 : *(_DWORD *)(a2 + 12))
  {
    BOOL v5 = (v3 & 2) != 0 ? (unsigned __int16 *)(a2 + 10) : *(unsigned __int16 **)(a2 + 24);
    unsigned int v6 = *v5;
  }

  else
  {
    unsigned int v6 = 0xFFFF;
  }

  else {
    return a1 + 496;
  }
}

uint64_t sub_1809010A8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  *(void *)(a1 + 16) = off_18971B688;
  *(_WORD *)(a1 + 24) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)(a1 + 8),  (const icu::UnicodeString *)(a2 + 72),  0,  0x7FFFFFFF,  0,  a3);
  *(void *)(a1 + 88) = off_18971B688;
  *(_WORD *)(a1 + 96) = 2;
  icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)(a1 + 80),  (const icu::UnicodeString *)(a2 + 136),  0,  0x7FFFFFFF,  0,  a3);
  unsigned int v6 = sub_1808FFC18((const char *)(a2 + 272), a2 + 8, a2 + 200, a3);
  *(void *)(a1 + 152) = v6;
  *(_BYTE *)(a1 + 160) = uloc_getCharacterOrientation(*(char **)(a2 + 304), (int32_t *)a3) == 1;
  return a1;
}

uint64_t sub_180901180(uint64_t a1, uint64_t a2)
{
  if (*(__int16 *)(a2 + 8) < 0)
  {
    int v5 = *(_DWORD *)(a2 + 12);
    int v4 = v5 & (v5 >> 31);
  }

  else
  {
    int v4 = 0;
    int v5 = *(unsigned __int16 *)(a2 + 8) >> 5;
  }

  uint64_t result = icu::UnicodeString::indexOf(a2, (uint64_t)"l", 0, 12, v4, v5 - v4);
  if ((result & 0x80000000) == 0)
  {
    int v7 = result + 12;
    if (*(__int16 *)(a2 + 8) < 0)
    {
      int v8 = *(_DWORD *)(a2 + 12);
      if (v8 >= v7) {
        int v9 = result + 12;
      }
      else {
        int v9 = *(_DWORD *)(a2 + 12);
      }
    }

    else
    {
      int v8 = *(unsigned __int16 *)(a2 + 8) >> 5;
      else {
        int v9 = *(unsigned __int16 *)(a2 + 8) >> 5;
      }
    }

    int v10 = icu::UnicodeString::doIndexOf(a2, 0x2Fu, v9, v8 - v9);
    if (v10 < 0)
    {
      else {
        int v10 = *(unsigned __int16 *)(a2 + 8) >> 5;
      }
    }

    uint64_t result = icu::UnicodeString::extract(a2, v7, (v10 - v7), (char *)(a1 + 264), 25);
    *(_BYTE *)(a1 + 288) = 0;
  }

  return result;
}

void *sub_180901260(void *result, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a3[4] <= 0x1Fu)
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 24LL))(a2);
    if ((_DWORD)result == 3)
    {
      if (*(_BYTE *)(v7 + 264)) {
        return result;
      }
      LODWORD(v10) = 0;
      v12[0] = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a2 + 40LL))(a2, &v10, a4);
      icu::UnicodeString::UnicodeString(v13, 1LL, v12);
      sub_180901180(v7, (uint64_t)v13);
      int v9 = (icu::UnicodeString *)v13;
    }

    else
    {
      int v11 = 0;
      uint64_t v10 = (*(uint64_t (**)(uint64_t, int *, uint64_t))(*(void *)a2 + 32LL))(a2, &v11, a4);
      icu::UnicodeString::UnicodeString(v12, 1LL, &v10);
      icu::UnicodeString::operator=((icu::UnicodeString *)a3, (icu::UnicodeString *)v12);
      int v9 = (icu::UnicodeString *)v12;
    }

    return icu::UnicodeString::~UnicodeString(v8, v9);
  }

  return result;
}

void *icu::MeasureFormat::getStaticClassID(icu::MeasureFormat *this)
{
  return &unk_18C535660;
}

void *icu::MeasureFormat::getDynamicClassID(icu::MeasureFormat *this)
{
  return &unk_18C535660;
}

void sub_1809013B0(icu::SharedObject *this)
{
  unsigned int v2 = &off_189725550;
  *(void *)this = &off_189725550;
  for (uint64_t i = 40LL; i != 64; i += 8LL)
  {
    uint64_t v4 = *(void *)((char *)this + i);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

  uint64_t v5 = *((void *)this + 8);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *((void *)this + 9);
  if (v6)
  {
    icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)(v6 + 136));
    icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)(v6 + 72));
    icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)(v6 + 8));
    icu::UMemory::operator delete((void *)v6);
  }

  icu::SharedObject::~SharedObject(this);
}

void sub_180901440(icu::SharedObject *a1)
{
}

uint64_t *sub_180901454(uint64_t a1, uint64_t a2, int *a3)
{
  v30[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t v4 = *(char **)(a1 + 56);
  uint64_t v5 = ures_open("icudt74l-unit", v4, a3);
  int v8 = icu::UMemory::operator new(v7, (icu::UMemory *)0x50, v6);
  if (v8)
  {
    int v9 = v8;
    v8[1] = 0LL;
    _OWORD v8[2] = 0LL;
    *int v8 = (uint64_t)&off_189725550;
    _BYTE v8[8] = 0LL;
    uint64_t v10 = v8 + 8;
    v8[9] = 0LL;
    memset_pattern16(v8 + 3, &unk_180A39B30, 0xCuLL);
    v9[5] = 0LL;
    _OWORD v9[6] = 0LL;
    v9[7] = 0LL;
    unsigned int v12 = (uint64_t *)*a3;
    if ((int)v12 < 1)
    {
      uint64_t v14 = icu::UMemory::operator new(v12, (icu::UMemory *)0xC8, v11);
      if (v14)
      {
        sub_180903FAC(v5, "hm", (UErrorCode *)a3, (uint64_t)v28);
        sub_180903FAC(v5, "ms", (UErrorCode *)a3, (uint64_t)v30);
        sub_180903FAC(v5, "hms", (UErrorCode *)a3, (uint64_t)v29);
        icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v14 + 1), (UChar **)v28);
        icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v14 + 9), v30);
        icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v14 + 17), v29);
        icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v29);
        icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v30);
        icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v28);
        unint64_t v13 = *a3;
        if ((int)v13 >= 1)
        {
          icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)(v14 + 17));
          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)(v14 + 9));
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)(v14 + 1));
          icu::UMemory::operator delete(v14);
          uint64_t v14 = 0LL;
        }
      }

      sub_18090178C((uint64_t)v9, (uint64_t)v14, (void *)v13);
      if (*a3 <= 0)
      {
        uint64_t v21 = 0LL;
        while (1)
        {
          LODWORD(v30[0]) = 0;
          icu::Locale::Locale((icu::Locale *)v28, v4, 0LL, 0LL, 0LL);
          uint64_t Instance = icu::NumberFormat::createInstance(v28, dword_180A39A80[v21], (UErrorCode *)v30);
          unsigned int v23 = &v9[v21];
          uint64_t v24 = v23[5];
          if (v24) {
            (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
          }
          v23[5] = (uint64_t)Instance;
          icu::Locale::~Locale((icu::Locale *)v28);
          int v25 = (int)v30[0];
          if (LODWORD(v30[0])) {
            *a3 = (int)v30[0];
          }
          else {
            int v25 = *a3;
          }
          if (v25 >= 1) {
            break;
          }
          if (++v21 == 3)
          {
            icu::Locale::Locale((icu::Locale *)v28, v4, 0LL, 0LL, 0LL);
            int32_t v26 = icu::NumberFormat::createInstance(v28, 1u, (UErrorCode *)a3);
            icu::Locale::~Locale((icu::Locale *)v28);
            if (*a3 > 0) {
              break;
            }
            (*(void (**)(icu::DecimalFormat *, void))(*(void *)v26 + 232LL))(v26, 0LL);
            if (v27) {
              (*(void (**)(void *, uint64_t))(*(void *)v27 + 280LL))(v27, 2LL);
            }
            if (*v10) {
              (*(void (**)(void))(*(void *)*v10 + 8LL))(*v10);
            }
            _BYTE v9[8] = (uint64_t)v26;
            icu::SharedObject::addRef((uint64_t)v9);
            goto LABEL_10;
          }
        }
      }
    }

    (*(void (**)(uint64_t *))(*v9 + 8))(v9);
    goto LABEL_9;
  }

  if (*a3 > 0)
  {
LABEL_9:
    int v9 = 0LL;
    goto LABEL_10;
  }

  int v9 = 0LL;
  *a3 = 7;
LABEL_10:
  if (v5) {
    ures_close(v5);
  }
  return v9;
}

void sub_18090178C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5)
  {
    icu::UnicodeString::~UnicodeString(a3, (icu::UnicodeString *)(v5 + 136));
    icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)(v5 + 72));
    icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)(v5 + 8));
    icu::UMemory::operator delete((void *)v5);
  }

  *(void *)(a1 + 72) = a2;
}

uint64_t icu::MeasureFormat::MeasureFormat(uint64_t a1, const char **a2, int a3, UErrorCode *a4)
{
  uint64_t v8 = icu::Format::Format(a1);
  *(void *)uint64_t v8 = off_189725578;
  *(void *)(v8 + 336) = 0LL;
  *(void *)(v8 + 344) = 0LL;
  if (a3 == 8) {
    int v9 = 1;
  }
  else {
    int v9 = a3;
  }
  *(void *)(v8 + 328) = 0LL;
  *(_DWORD *)(v8 + 352) = v9;
  *(_BYTE *)(v8 + 356) = a3 == 8;
  *(void *)(v8 + 360) = 0LL;
  *(void *)(v8 + 368) = 0LL;
  icu::MeasureFormat::initMeasureFormat(v8, a2, v9, 0LL, a4);
  return a1;
}

void icu::MeasureFormat::initMeasureFormat( uint64_t a1, const char **a2, int a3, unint64_t a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0
    && (LODWORD(v7) = a3,
        icu::Format::setLocaleIDs((icu::Format *)a1, a2[5], a2[5]),
        sub_180903AA8((uint64_t)a2, (UErrorCode *)(a1 + 328), a5),
        *(int *)a5 <= 0)
    && (uint64_t v10 = (icu::SharedObject *)icu::PluralRules::createSharedInstance((uint64_t)a2, 0, a5), *(int *)a5 <= 0))
  {
    unint64_t v11 = v10;
    sub_18085C214(v10, (icu::SharedObject **)(a1 + 344));
    icu::SharedObject::removeRef(v11);
    if (a4)
    {
      icu::MeasureFormat::adoptNumberFormat((icu::SharedObject *)a1, a4, a5);
    }

    else
    {
      Shareduint64_t Instance = (icu::SharedObject *)icu::NumberFormat::createSharedInstance((uint64_t)a2, 1, a5);
      unint64_t v13 = SharedInstance;
      sub_18085C214(SharedInstance, (icu::SharedObject **)(a1 + 336));
      icu::SharedObject::removeRef(v13);
    }

    *(_DWORD *)(a1 + 352) = v7;
    int v14 = *(unsigned __int8 *)(a1 + 356);
    else {
      uint64_t v7 = v7;
    }
    uint64_t v15 = *(void *)(a1 + 360);
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    uint64_t v16 = 2LL;
    if (!v14) {
      uint64_t v16 = v7;
    }
    *(void *)(a1 + 360) = icu::ListFormatter::createInstance(a2, 2, dword_180A39A8C[v16], a5);
    uint64_t v17 = *(void *)(a1 + 368);
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    }
    *(void *)(a1 + 368) = icu::ListFormatter::createInstance(a2, 0, 0, a5);
  }

  else if (a4)
  {
    (*(void (**)(unint64_t))(*(void *)a4 + 8LL))(a4);
  }

uint64_t icu::MeasureFormat::MeasureFormat( uint64_t a1, const char **a2, int a3, unint64_t a4, UErrorCode *a5)
{
  uint64_t v10 = icu::Format::Format(a1);
  *(void *)uint64_t v10 = off_189725578;
  *(void *)(v10 + 336) = 0LL;
  *(void *)(v10 + 344) = 0LL;
  if (a3 == 8) {
    int v11 = 1;
  }
  else {
    int v11 = a3;
  }
  *(void *)(v10 + 328) = 0LL;
  *(_DWORD *)(v10 + 352) = v11;
  *(_BYTE *)(v10 + 356) = a3 == 8;
  *(void *)(v10 + 360) = 0LL;
  *(void *)(v10 + 368) = 0LL;
  icu::MeasureFormat::initMeasureFormat(v10, a2, v11, a4, a5);
  return a1;
}

icu::MeasureFormat *icu::MeasureFormat::MeasureFormat( icu::MeasureFormat *this, const icu::MeasureFormat *a2)
{
  uint64_t v4 = icu::Format::Format((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v4 = off_189725578;
  __int128 v5 = *(_OWORD *)((char *)a2 + 328);
  *(_OWORD *)(v4 + 328) = v5;
  *(void *)(v4 + 344) = *((void *)a2 + 43);
  *(_DWORD *)(v4 + 352) = *((_DWORD *)a2 + 88);
  *(_BYTE *)(v4 + 356) = *((_BYTE *)a2 + 356);
  *(void *)(v4 + 360) = 0LL;
  *(void *)(v4 + 368) = 0LL;
  icu::SharedObject::addRef(v5);
  icu::SharedObject::addRef(*((void *)this + 42));
  icu::SharedObject::addRef(*((void *)this + 43));
  uint64_t v7 = (uint64_t *)*((void *)a2 + 45);
  if (v7)
  {
    uint64_t v8 = (icu::ListFormatter *)icu::UMemory::operator new(v7, (icu::UMemory *)0x18, v6);
    if (v8) {
      uint64_t v8 = (icu::ListFormatter *)icu::ListFormatter::ListFormatter(v8, *((const icu::ListFormatter **)a2 + 45));
    }
    *((void *)this + 45) = v8;
  }

  int v9 = (uint64_t *)*((void *)a2 + 46);
  if (v9)
  {
    uint64_t v10 = (icu::ListFormatter *)icu::UMemory::operator new(v9, (icu::UMemory *)0x18, v6);
    if (v10) {
      uint64_t v10 = (icu::ListFormatter *)icu::ListFormatter::ListFormatter(v10, *((const icu::ListFormatter **)a2 + 46));
    }
    *((void *)this + 46) = v10;
  }

  return this;
}

uint64_t icu::MeasureFormat::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    icu::Format::operator=(a1, a2);
    sub_18085C214(*(icu::SharedObject **)(a2 + 328), (icu::SharedObject **)(a1 + 328));
    sub_18085C214(*(icu::SharedObject **)(a2 + 336), (icu::SharedObject **)(a1 + 336));
    sub_18085C214(*(icu::SharedObject **)(a2 + 344), (icu::SharedObject **)(a1 + 344));
    *(_DWORD *)(a1 + 352) = *(_DWORD *)(a2 + 352);
    *(_BYTE *)(a1 + 356) = *(_BYTE *)(a2 + 356);
    uint64_t v5 = *(void *)(a1 + 360);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    unint64_t v6 = *(uint64_t **)(a2 + 360);
    if (v6)
    {
      uint64_t v7 = (icu::ListFormatter *)icu::UMemory::operator new(v6, (icu::UMemory *)0x18, v4);
      if (v7) {
        uint64_t v7 = (icu::ListFormatter *)icu::ListFormatter::ListFormatter(v7, *(const icu::ListFormatter **)(a2 + 360));
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    *(void *)(a1 + 360) = v7;
    uint64_t v8 = *(void *)(a1 + 368);
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    int v9 = *(uint64_t **)(a2 + 368);
    if (v9)
    {
      uint64_t v10 = (icu::ListFormatter *)icu::UMemory::operator new(v9, (icu::UMemory *)0x18, v4);
      if (v10) {
        uint64_t v10 = (icu::ListFormatter *)icu::ListFormatter::ListFormatter(v10, *(const icu::ListFormatter **)(a2 + 368));
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    *(void *)(a1 + 368) = v10;
  }

  return a1;
}

uint64_t icu::MeasureFormat::MeasureFormat(icu::MeasureFormat *this)
{
  uint64_t result = icu::Format::Format((uint64_t)this);
  *(void *)uint64_t result = off_189725578;
  *(void *)(result + 336) = 0LL;
  *(void *)(result + 344) = 0LL;
  *(void *)(result + 328) = 0LL;
  *(_DWORD *)(result + 352) = 1;
  *(_BYTE *)(result + 356) = 0;
  *(void *)(result + 360) = 0LL;
  *(void *)(result + 368) = 0LL;
  return result;
}

{
  uint64_t result;
  uint64_t result = icu::Format::Format((uint64_t)this);
  *(void *)uint64_t result = off_189725578;
  *(void *)(result + 336) = 0LL;
  *(void *)(result + 344) = 0LL;
  *(void *)(result + 328) = 0LL;
  *(_DWORD *)(result + 352) = 1;
  *(_BYTE *)(result + 356) = 0;
  *(void *)(result + 360) = 0LL;
  *(void *)(result + 368) = 0LL;
  return result;
}

void icu::MeasureFormat::~MeasureFormat(icu::MeasureFormat *this)
{
  *(void *)this = off_189725578;
  unsigned int v2 = (void *)*((void *)this + 41);
  if (v2) {
    icu::SharedObject::removeRef(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 42);
  if (v3) {
    icu::SharedObject::removeRef(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 43);
  if (v4) {
    icu::SharedObject::removeRef(v4);
  }
  uint64_t v5 = *((void *)this + 45);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *((void *)this + 46);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  icu::Format::~Format(this);
}

{
  void *v1;
  icu::MeasureFormat::~MeasureFormat(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::MeasureFormat::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t v12 = v2;
  uint64_t v13 = v3;
  uint64_t result = icu::Format::operator==((void *)a1, (void *)a2);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(a1 + 352) == *(_DWORD *)(a2 + 352)
      && *(unsigned __int8 *)(a1 + 356) == *(unsigned __int8 *)(a2 + 356)
      && (*(void *)(a1 + 328) == *(void *)(a2 + 328)
       || (int v11 = 0,
           LocaleID = (const char *)icu::Format::getLocaleID(a1, 1, &v11),
           uint64_t v8 = (const char *)icu::Format::getLocaleID(a2, 1, &v11),
           v11 <= 0)
       && !strcmp(LocaleID, v8)))
    {
      uint64_t v9 = *(void *)(a1 + 336);
      uint64_t v10 = *(void *)(a2 + 336);
      if (v9 == v10) {
        return 1LL;
      }
      else {
        return (*(uint64_t (**)(void, void))(**(void **)(v9 + 24) + 24LL))( *(void *)(v9 + 24),  *(void *)(v10 + 24));
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t icu::MeasureFormat::getLocaleID(icu::MeasureFormat *this, UErrorCode *a2)
{
  return icu::Format::getLocaleID((uint64_t)this, 1, (int *)a2);
}

icu::MeasureFormat *icu::MeasureFormat::clone@<X0>( icu::MeasureFormat *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::MeasureFormat *)icu::UMemory::operator new(a3, (icu::UMemory *)0x178, a2);
  if (result) {
    return icu::MeasureFormat::MeasureFormat(result, this);
  }
  return result;
}

icu::UnicodeString *icu::MeasureFormat::format( icu::MeasureFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    if (icu::Formattable::getType(a2) == 6)
    {
      Object = (const void *)icu::Formattable::getObject(a2);
      if (Object)
      {
        if (v11) {
          return icu::MeasureFormat::formatMeasure( this,  v11,  *(const icu::NumberFormat **)(*((void *)this + 42) + 24LL),  a3,  a4,  a5);
        }
      }
    }

    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return a3;
}

icu::UnicodeString *icu::MeasureFormat::formatMeasure( icu::MeasureFormat *this, const icu::Measure *a2, const icu::NumberFormat *a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  uint64_t v104 = *MEMORY[0x1895F89C0];
  int v11 = (const icu::Measure *)((char *)a2 + 8);
  uint64_t v12 = (icu::MeasureUnit *)*((void *)a2 + 15);
  unsigned int Type = icu::MeasureUnit::getType(v12);
  if (!strcmp(Type, "currency"))
  {
    *(void *)us = 0LL;
    Subtype = icu::MeasureUnit::getSubtype(v12);
    u_charsToUChars(Subtype, us, 4);
    int v29 = *((_DWORD *)this + 88);
    if (v29 >= 2) {
      int v29 = 2;
    }
    unsigned int v30 = (uint64_t *)(*((void *)this + 41) + 8LL * v29);
    uint64_t v31 = v30[5];
    uint64_t v32 = icu::UMemory::operator new(v30, (icu::UMemory *)0x80, v28);
    int v33 = (icu::UObject *)v32;
    if (v32)
    {
      __int128 v76 = us;
      icu::CurrencyAmount::CurrencyAmount(v32, v11, &v76, a6);
    }

    icu::Formattable::Formattable((icu::Formattable *)&v78, v33);
    a4 = (icu::UnicodeString *)(*(uint64_t (**)(uint64_t, __int128 *, icu::UnicodeString *, icu::FieldPosition *, UErrorCode *))(*(void *)v31 + 40LL))( v31,  &v78,  a4,  a5,  a6);
    icu::Formattable::~Formattable((icu::Formattable *)&v78);
    return a4;
  }

  unsigned int v14 = *((unsigned __int16 *)a4 + 4);
  int v15 = (__int16)v14;
  LODWORD(v16) = v14 >> 5;
  if (v15 >= 0) {
    uint64_t v16 = v16;
  }
  else {
    uint64_t v16 = *((unsigned int *)a4 + 3);
  }
  uint64_t v75 = v16;
  int v17 = *((_DWORD *)a5 + 2);
  if (v17 == 0x40000000) {
    *((_DWORD *)a5 + 2) = -1;
  }
  if (!v18)
  {
    memset(&us[4], 0, 56);
    *(void *)us = off_18971B688;
    us[4] = 2;
    unsigned int v34 = icu::QuantityFormatter::selectPlural( v11,  a3,  *(const icu::NumberFormat **)(*((void *)this + 43) + 24LL),  (const icu::PluralRules *)us,  a5,  a6,  v19);
    if (v17 == 0x40000000)
    {
      *((void *)a5 + sub_1808F7164((uint64_t)v14, 1) = 0x40000000LL;
      int v35 = us[4] >> 5;
      if ((us[4] & 0x8000u) != 0) {
        int v35 = *(_DWORD *)&us[6];
      }
      *((_DWORD *)a5 + 4) = v35;
    }

    __int128 v86 = 0u;
    __int128 v85 = 0u;
    __int128 v84 = 0u;
    __int128 v83 = 0u;
    int v36 = 1;
    icu::Format::getLocale((uint64_t)this, 1, (int *)a6, (icu::Locale *)&v78);
    uint64_t v37 = *((int *)this + 88);
    sub_18092D7F8((uint64_t)&v78, v12, v36, v34, (int *)a6, (uint64_t)&v83);
    icu::Locale::~Locale((icu::Locale *)&v78);
    int v38 = (void *)*(unsigned int *)a6;
    if ((int)v38 > 0)
    {
      icu::UnicodeString::~UnicodeString(v38, (icu::UnicodeString *)&v83);
LABEL_81:
      icu::UnicodeString::~UnicodeString((void *)v39, (icu::UnicodeString *)us);
      return a4;
    }

    *(void *)&__int128 v78 = 0LL;
    __int128 v79 = 0u;
    uint64_t v82 = 0LL;
    __int128 v80 = 0u;
    __int128 v81 = 0u;
    *((void *)&v78 + sub_1808F7164((uint64_t)v14, 1) = off_18971B688;
    LOWORD(v79) = 2;
    icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)&v78,  (const icu::UnicodeString *)&v83,  0,  1,  0,  a6);
    icu::QuantityFormatter::format((icu::QuantityFormatter *)&v78, (const icu::SimpleFormatter *)us, a4, a5, a6, v72);
    icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)&v78);
    icu::UnicodeString::~UnicodeString(v73, (icu::UnicodeString *)&v83);
    icu::UnicodeString::~UnicodeString(v74, (icu::UnicodeString *)us);
    goto LABEL_51;
  }

  uint64_t v20 = v18;
  uint64_t v103 = 0LL;
  memset(v102, 0, sizeof(v102));
  __int128 v101 = 0u;
  __int128 v100 = 0u;
  __int128 v99 = 0u;
  __int128 v98 = 0u;
  __int128 v97 = 0u;
  __int128 v96 = 0u;
  __int128 v95 = 0u;
  __int128 v94 = 0u;
  __int128 v93 = 0u;
  __int128 v92 = 0u;
  __int128 v91 = 0u;
  __int128 v90 = 0u;
  __int128 v89 = 0u;
  __int128 v88 = 0u;
  __int128 v87 = 0u;
  __int128 v86 = 0u;
  __int128 v85 = 0u;
  __int128 v84 = 0u;
  __int128 v83 = 0u;
  sub_1808D4228((uint64_t)&v83);
  uint64_t v21 = icu::DecimalFormat::toNumberFormatter(v20, a6);
  if (v21)
  {
    uint64_t v23 = v21;
    double Double = icu::Formattable::getDouble(v11, a6);
    icu::number::impl::DecimalQuantity::setToDouble((void **)v102, Double);
    icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unit(us, v23, (unint64_t)v12);
    uint64_t v25 = *((int *)this + 88);
    else {
      int v26 = dword_180A39B40[v25];
    }
    icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unitWidth(&v78, (uint64_t)us, v26);
    icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)&v78,  (icu::number::impl::UFormattedNumberData *)&v83,  a6);
    icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)&v78);
    icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)us);
  }

  unsigned int v40 = *((unsigned __int16 *)a4 + 4);
  int v41 = (__int16)v40;
  unsigned int v42 = v40 >> 5;
  if (v41 >= 0) {
    unint64_t v43 = v42;
  }
  else {
    unint64_t v43 = *((unsigned int *)a4 + 3);
  }
  icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)&v83,  a5,  (icu::FieldPosition *)v43,  a6,  v22);
  if (v17 == 0x40000000)
  {
    *((_DWORD *)a5 + 2) = 0;
    unsigned int v45 = *((unsigned __int16 *)a4 + 4);
    int v46 = (__int16)v45;
    unsigned int v47 = v45 >> 5;
    if (v46 >= 0) {
      unint64_t v48 = v47;
    }
    else {
      unint64_t v48 = *((unsigned int *)a4 + 3);
    }
    icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)&v83,  a5,  (icu::FieldPosition *)v48,  a6,  v44);
    int v51 = *((_DWORD *)a5 + 3);
    int v50 = *((_DWORD *)a5 + 4);
    *((_DWORD *)a5 + 2) = 1;
    unsigned int v52 = *((unsigned __int16 *)a4 + 4);
    int v53 = (__int16)v52;
    unsigned int v54 = v52 >> 5;
    if (v53 >= 0) {
      unint64_t v55 = v54;
    }
    else {
      unint64_t v55 = *((unsigned int *)a4 + 3);
    }
    icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)&v83,  a5,  (icu::FieldPosition *)v55,  a6,  v49);
    int v56 = *((_DWORD *)a5 + 3);
    int v57 = *((_DWORD *)a5 + 4);
    if (v51 < 0 || v50 <= v51)
    {
      if ((v56 & 0x80000000) == 0 && v57 > v56) {
        goto LABEL_46;
      }
      int v50 = 0;
      *((_DWORD *)a5 + 3) = 0;
    }

    else
    {
      *((_DWORD *)a5 + 3) = v51;
      if (v56 >= v50 && v57 > v56) {
        goto LABEL_46;
      }
    }

    *((_DWORD *)a5 + 4) = v50;
LABEL_46:
    *((_DWORD *)a5 + 2) = 0x40000000;
  }

  icu::FormattedValueStringBuilderImpl::toTempString((icu::FormattedValueStringBuilderImpl *)&v83, (uint64_t)&v78);
  if ((SWORD4(v78) & 0x8000u) == 0) {
    uint64_t v58 = WORD4(v78) >> 5;
  }
  else {
    uint64_t v58 = HIDWORD(v78);
  }
  icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)&v78, 0, v58);
  icu::UnicodeString::~UnicodeString(v59, (icu::UnicodeString *)&v78);
  icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)&v83);
LABEL_51:
  if (*((_BYTE *)this + 356))
  {
    memset(us, 0, 64);
    icu::Format::getLocale((uint64_t)this, 1, (int *)a6, (icu::Locale *)&v78);
    sub_18092D7F8((uint64_t)&v78, v12, 0, 5u, (int *)a6, (uint64_t)us);
    icu::Locale::~Locale((icu::Locale *)&v78);
    uint64_t v39 = *(unsigned int *)a6;
    if ((int)v39 <= 0)
    {
      int32_t v60 = (us[4] & 0x8000u) == 0 ? us[4] >> 5 : *(_DWORD *)&us[6];
      if (icu::UnicodeString::doIndexOf((uint64_t)us, 0x20u, 0, v60) == -1)
      {
        int32_t v61 = (us[4] & 0x8000u) == 0 ? us[4] >> 5 : *(_DWORD *)&us[6];
        if (icu::UnicodeString::doIndexOf((uint64_t)us, 0xA0u, 0, v61) == -1)
        {
          int32_t v62 = (us[4] & 0x8000u) == 0 ? us[4] >> 5 : *(_DWORD *)&us[6];
          if (icu::UnicodeString::doIndexOf((uint64_t)us, 0x202Fu, 0, v62) == -1)
          {
            unsigned int v63 = *((unsigned __int16 *)a4 + 4);
            int v64 = (__int16)v63;
            unsigned int v65 = v63 >> 5;
            int v66 = v64 >= 0 ? v65 : *((_DWORD *)a4 + 3);
            uint64_t v39 = v75;
            if ((int)v75 < v66)
            {
              uint64_t v67 = (int)v75;
              do
              {
                uint64_t v39 = *((unsigned __int16 *)a4 + 4);
                if ((v39 & 0x8000u) == 0LL) {
                  unsigned int v68 = v39 >> 5;
                }
                else {
                  unsigned int v68 = *((_DWORD *)a4 + 3);
                }
                if (v68 > v67)
                {
                  if ((v39 & 2) != 0) {
                    __int128 v69 = (char *)a4 + 10;
                  }
                  else {
                    __int128 v69 = (char *)*((void *)a4 + 3);
                  }
                  uint64_t v39 = *(unsigned __int16 *)&v69[2 * v67];
                  if ((_DWORD)v39 == 32)
                  {
                    icu::UnicodeString::doReplace((uint64_t)a4, v67, 1LL, 0LL, 0, 0LL);
                    uint64_t v39 = *((int *)a5 + 3);
                    if (v67 < v39)
                    {
                      uint64_t v39 = (v39 - 1);
                      int v70 = *((_DWORD *)a5 + 4) - 1;
                      *((_DWORD *)a5 + 3) = v39;
                      *((_DWORD *)a5 + 4) = v70;
                    }
                  }
                }

                ++v67;
              }

              while (v66 != (_DWORD)v67);
            }
          }
        }
      }
    }

    goto LABEL_81;
  }

  return a4;
}

icu::UnicodeString *icu::MeasureFormat::formatMeasurePerUnit( icu::MeasureFormat *this, const icu::Measure *a2, const icu::MeasureUnit *a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v32 = 0LL;
      memset(v31, 0, sizeof(v31));
      memset(v30, 0, sizeof(v30));
      sub_1808D4228((uint64_t)v30);
      uint64_t v14 = icu::DecimalFormat::toNumberFormatter(v13, a6);
      if (v14)
      {
        uint64_t v16 = v14;
        double Double = icu::Formattable::getDouble((const icu::Measure *)((char *)a2 + 8), a6);
        icu::number::impl::DecimalQuantity::setToDouble((void **)v31, Double);
        icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unit( v27,  v16,  *((void *)a2 + 15));
        icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::perUnit( v28,  (uint64_t)v27,  (unint64_t)a3);
        uint64_t v18 = *((int *)this + 88);
        else {
          int v19 = dword_180A39B40[v18];
        }
        icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unitWidth(v29, (uint64_t)v28, v19);
        icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)v29,  (icu::number::impl::UFormattedNumberData *)v30,  a6);
        icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v29);
        icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v28);
        icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v27);
      }

      unsigned int v20 = *((unsigned __int16 *)a4 + 4);
      int v21 = (__int16)v20;
      unsigned int v22 = v20 >> 5;
      if (v21 >= 0) {
        unint64_t v23 = v22;
      }
      else {
        unint64_t v23 = *((unsigned int *)a4 + 3);
      }
      icu::DecimalFormat::fieldPositionHelper( (icu::FormattedValueStringBuilderImpl *)v30,  a5,  (icu::FieldPosition *)v23,  a6,  v15);
      icu::FormattedValueStringBuilderImpl::toTempString((icu::FormattedValueStringBuilderImpl *)v30, (uint64_t)v29);
      if ((SWORD4(v29[0]) & 0x8000u) == 0) {
        uint64_t v24 = WORD4(v29[0]) >> 5;
      }
      else {
        uint64_t v24 = HIDWORD(v29[0]);
      }
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)v29, 0, v24);
      icu::UnicodeString::~UnicodeString(v25, (icu::UnicodeString *)v29);
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v30);
    }

    else
    {
      *a6 = U_UNSUPPORTED_ERROR;
    }
  }

  return a4;
}

uint64_t icu::MeasureFormat::getNumberFormatInternal(icu::MeasureFormat *this)
{
  return *(void *)(*((void *)this + 42) + 24LL);
}

icu::UnicodeString *icu::MeasureFormat::formatMeasures( icu::MeasureFormat *this, const icu::Measure *a2, int a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v12 = a2;
  if (a3 != 1)
  {
    if (*((_DWORD *)this + 88) != 3) {
      goto LABEL_17;
    }
    uint64_t v14 = 0LL;
    memset(v29, 0, sizeof(v29));
    do
    {
      icu::Formattable::Formattable((icu::Formattable *)&v29[v14]);
      v14 += 7LL;
    }

    while (v14 != 21);
    int v15 = sub_180902B2C((uint64_t)v12, a3, (double *)v29, (int *)a6);
    if (v15 >= 1) {
      icu::MeasureFormat::formatNumeric(this, (const icu::Formattable *)v29, v15, a4, a6);
    }
    for (uint64_t i = 14LL; i != -7; i -= 7LL)
      icu::Formattable::~Formattable((icu::Formattable *)&v29[i]);
    if (v15 <= 0)
    {
LABEL_17:
      if (*((_DWORD *)a5 + 2) == -1)
      {
        if (a3 < 0) {
          uint64_t v17 = -1LL;
        }
        else {
          uint64_t v17 = ((uint64_t)a3 << 6) | 0x10;
        }
        uint64_t v18 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v17, (unint64_t)a2);
        if (v18)
        {
          int v19 = v18;
          *uint64_t v18 = 64LL;
          v18[1] = a3;
          unint64_t v28 = (icu::UnicodeString *)(v18 + 2);
          uint64_t v20 = 2LL;
          do
          {
            int v21 = &v18[v20];
            *int v21 = off_18971B688;
            *((_WORD *)v21 + 4) = 2;
            v20 += 8LL;
          }

          while (v21 + 8 != &v18[8 * (uint64_t)a3 + 2]);
          uint64_t v22 = (a3 - 1);
          if (a3 >= 1)
          {
            uint64_t v23 = a3;
            uint64_t v24 = (icu::UnicodeString *)(v18 + 2);
            do
            {
              if (v22) {
                uint64_t v25 = (const icu::NumberFormat **)(*((void *)this + 41) + 64LL);
              }
              else {
                uint64_t v25 = (const icu::NumberFormat **)(*((void *)this + 42) + 24LL);
              }
              icu::MeasureFormat::formatMeasure(this, v12, *v25, v24, a5, a6);
              --v22;
              uint64_t v24 = (icu::UnicodeString *)((char *)v24 + 64);
              uint64_t v12 = (const icu::Measure *)((char *)v12 + 128);
              --v23;
            }

            while (v23);
          }

          icu::ListFormatter::format(*((icu::ListFormatter **)this + 45), v28, a3, a4, a6);
          int v26 = (void *)v19[1];
          if (v26)
          {
            uint64_t v27 = (void)v26 << 6;
            do
            {
              icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)((char *)v19 + v27 - 48));
              v27 -= 64LL;
            }

            while (v27);
          }

          icu::UMemory::operator delete[](v19);
        }

        else
        {
          *a6 = U_MEMORY_ALLOCATION_ERROR;
        }
      }

      else
      {
        icu::MeasureFormat::formatMeasuresSlowTrack(this, v12, a3, a4, a5, a6);
      }
    }

    return a4;
  }

  return icu::MeasureFormat::formatMeasure( this,  a2,  *(const icu::NumberFormat **)(*((void *)this + 42) + 24LL),  a4,  a5,  a6);
}

uint64_t sub_180902B2C(uint64_t a1, int a2, double *a3, int *a4)
{
  if (*a4 <= 0 && a2 >= 1)
  {
    LODWORD(v7) = 0;
    uint64_t v8 = (uint64_t)(a3 + 14);
    uint64_t v9 = (uint64_t)(a3 + 28);
    uint64_t v10 = a2;
    for (uint64_t i = (icu::MeasureUnit **)(a1 + 120); ; i += 16)
    {
      if (sub_1809041D8(*i, "hour"))
      {
        icu::Formattable::operator=((uint64_t)a3, (uint64_t)(i - 14));
        if (a3[1] < 0.0) {
          return 0LL;
        }
        uint64_t v7 = 1LL;
      }

      else if (sub_1809041D8(*i, "minute"))
      {
        icu::Formattable::operator=(v8, (uint64_t)(i - 14));
        if (a3[15] < 0.0) {
          return 0LL;
        }
        uint64_t v7 = v7 | 2;
      }

      else
      {
        BOOL v12 = sub_1809041D8(*i, "second");
        uint64_t result = 0LL;
        icu::Formattable::operator=(v9, (uint64_t)(i - 14));
        if (a3[29] < 0.0) {
          return 0LL;
        }
        uint64_t v7 = v7 | 4;
      }

      uint64_t result = v7;
      if (!--v10) {
        return result;
      }
    }
  }

  return 0LL;
}

icu::UnicodeString *icu::MeasureFormat::formatNumeric( icu::MeasureFormat *this, const icu::Formattable *a2, int a3, icu::UnicodeString *a4, UErrorCode *a5)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    __int128 v56 = 0u;
    uint64_t v59 = 0LL;
    __int128 v58 = 0u;
    __int128 v57 = 0u;
    unint64_t v55 = (UChar *)off_18971B688;
    LOWORD(v56) = 2;
    double Double = icu::Formattable::getDouble(a2, a5);
    double v11 = icu::Formattable::getDouble((const icu::Formattable *)((char *)a2 + 112), a5);
    double v12 = icu::Formattable::getDouble((const icu::Formattable *)((char *)a2 + 224), a5);
    uint64_t v13 = *(unsigned int *)a5;
    if ((int)v13 > 0)
    {
LABEL_76:
      icu::UnicodeString::~UnicodeString((void *)v13, (icu::UnicodeString *)&v55);
      return a4;
    }

    double v14 = v12;
    if ((a3 & 0xFFFFFFFD) == 5)
    {
      icu::UnicodeString::operator=(&v55, (UChar **)(*(void *)(*((void *)this + 41) + 72LL) + 136LL));
      double Double = uprv_trunc(Double);
    }

    else
    {
      if (a3 != 6)
      {
        if (a3 != 3)
        {
LABEL_69:
          uint64_t v13 = 5LL;
          *a5 = U_INTERNAL_PROGRAM_ERROR;
          goto LABEL_76;
        }

        icu::UnicodeString::operator=(&v55, (UChar **)(*(void *)(*((void *)this + 41) + 72LL) + 8LL));
        double Double = uprv_trunc(Double);
LABEL_10:
        int v15 = *(const void **)(*((void *)this + 42) + 24LL);
        if (v15)
        {
          if (v16)
          {
            uint64_t v17 = v16;
            __int128 v53 = 0u;
            __int128 v54 = 0u;
            memset(v52, 0, sizeof(v52));
            sub_1808D3E38((uint64_t)v52);
            __int128 v54 = 0uLL;
            *((void *)&v53 + sub_1808F7164((uint64_t)v14, 1) = 0LL;
            uint64_t v18 = icu::DecimalFormat::toNumberFormatter(v17, a5);
            if (v18)
            {
              uint64_t v19 = v18;
              uint64_t v42 = icu::number::IntegerWidth::zeroFillTo((icu::number::IntegerWidth *)2);
              int v43 = v20;
              icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::integerWidth( v50,  v19,  (uint64_t)&v42);
              icu::number::LocalizedNumberFormatter::operator=((uint64_t)v52, (uint64_t)v50);
              icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v50);
              int v21 = *(const void **)(*((void *)this + 41) + 64LL);
              if (v21
              {
                *(void *)int v51 = 0LL;
                memset(v50, 0, sizeof(v50));
                icu::FormattedStringBuilder::FormattedStringBuilder((icu::FormattedStringBuilder *)v50);
                if ((v56 & 0x8000u) == 0LL) {
                  int v23 = (unsigned __int16)v56 >> 5;
                }
                else {
                  int v23 = DWORD1(v56);
                }
                if (v23 >= 1)
                {
                  signed int v24 = 0;
                  BOOL v25 = 0;
                  while (1)
                  {
                    unsigned int v26 = (v56 & 0x8000u) == 0LL ? (unsigned __int16)v56 >> 5 : DWORD1(v56);
                    if (v26 <= v24) {
                      break;
                    }
                    if ((v56 & 2) != 0) {
                      uint64_t v27 = (char *)&v56 + 2;
                    }
                    else {
                      uint64_t v27 = (char *)v57;
                    }
                    unsigned int v28 = *(unsigned __int16 *)&v27[2 * v24];
                    if (v28 > 0x6C)
                    {
                      if (v28 == 115)
                      {
                        if (!v25)
                        {
                          uint64_t v49 = 0LL;
                          __int128 v47 = 0u;
                          __int128 v48 = 0u;
                          __int128 v46 = 0u;
                          unsigned int v45 = off_18971B688;
                          BOOL v32 = 1;
                          double v29 = v14;
                          LOWORD(v46) = 2;
                          goto LABEL_53;
                        }

                        goto LABEL_44;
                      }

                      if (v28 == 109)
                      {
                        double v29 = v11;
LABEL_37:
                        if (!v25)
                        {
                          uint64_t v49 = 0LL;
                          __int128 v47 = 0u;
                          __int128 v48 = 0u;
                          __int128 v46 = 0u;
                          unsigned int v45 = off_18971B688;
                          LOWORD(v46) = 2;
                          BOOL v32 = a3 == 3 && v28 == 109;
LABEL_53:
                          uint64_t v30 = v24 + 1LL;
                          if (v24 + 1 < v23
                            && (v26 <= v30 ? (int v33 = 0xFFFF) : (int v33 = *(unsigned __int16 *)&v27[2 * v30]),
                                v33 == v28))
                          {
                            if (v32)
                            {
                              icu::number::LocalizedNumberFormatter::formatDouble(v52, v29, a5, (uint64_t)v41);
                              icu::number::FormattedNumber::toString( (icu::number::FormattedNumber *)v41,  a5,  (uint64_t)&v42);
                              icu::UnicodeString::operator=((icu::UnicodeString *)&v45, (icu::UnicodeString *)&v42);
                              icu::UnicodeString::~UnicodeString(v34, (icu::UnicodeString *)&v42);
                              icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)v41);
                            }

                            else
                            {
                              (*(void (**)(icu::Format *, uint64_t))(*(void *)v40 + 224LL))(v40, 2LL);
                              icu::Formattable::Formattable((icu::Formattable *)&v42, v29);
                              icu::Format::format(v40, (const icu::Formattable *)&v42, (icu::UnicodeString *)&v45, a5);
                              icu::Formattable::~Formattable((icu::Formattable *)&v42);
                            }
                          }

                          else
                          {
                            if (v32)
                            {
                              icu::Formattable::Formattable((icu::Formattable *)&v42, v29);
                              int v35 = v17;
                            }

                            else
                            {
                              (*(void (**)(icu::Format *, uint64_t))(*(void *)v40 + 224LL))(v40, 1LL);
                              icu::Formattable::Formattable((icu::Formattable *)&v42, v29);
                              int v35 = v40;
                            }

                            icu::Format::format(v35, (const icu::Formattable *)&v42, (icu::UnicodeString *)&v45, a5);
                            icu::Formattable::~Formattable((icu::Formattable *)&v42);
                            LODWORD(v30) = v24;
                          }

                          icu::FormattedStringBuilder::insert( (icu::FormattedStringBuilder *)v50,  v51[1],  (uint64_t)&v45,  0,  0,  a5);
                          icu::UnicodeString::~UnicodeString(v36, (icu::UnicodeString *)&v45);
                          BOOL v25 = 0;
                          goto LABEL_65;
                        }

icu::UnicodeString *icu::MeasureFormat::formatMeasuresSlowTrack( icu::MeasureFormat *this, const icu::Measure *a2, int a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  if (*(int *)a6 <= 0)
  {
    uint64_t v8 = a2;
    signed int v24 = a4;
    _OWORD v30[2] = 0LL;
    v30[0] = off_189723AC8;
    v30[1] = 0xFFFFFFFFLL;
    int v10 = *((_DWORD *)a5 + 2);
    uint64_t v27 = off_189723AC8;
    int v28 = v10;
    memset(v29, 0, sizeof(v29));
    uint64_t v11 = a3;
    if (a3 < 0) {
      uint64_t v12 = -1LL;
    }
    else {
      uint64_t v12 = ((uint64_t)a3 << 6) | 0x10;
    }
    uint64_t v13 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v12, (unint64_t)a2);
    if (v13)
    {
      *uint64_t v13 = 64LL;
      v13[1] = v11;
      double v14 = (const icu::UnicodeString *)(v13 + 2);
      if (a3)
      {
        int v15 = v13 + 2;
        do
        {
          *(void *)int v15 = off_18971B688;
          _OWORD v15[4] = 2;
          v15 += 32;
        }

        while (v15 != (_WORD *)((char *)v14 + 64 * v11));
      }

      unsigned int v26 = v13 + 2;
    }

    else
    {
      double v14 = 0LL;
      unsigned int v26 = 0LL;
      if (*(int *)a6 <= 0)
      {
        double v14 = 0LL;
        *a6 = U_MEMORY_ALLOCATION_ERROR;
      }
    }

    if (a3 < 1)
    {
      int v18 = -1;
    }

    else
    {
      int v16 = 0;
      uint64_t v17 = 0LL;
      int v18 = -1;
      do
      {
        else {
          uint64_t v19 = (const icu::NumberFormat **)(*((void *)this + 41) + 64LL);
        }
        int v20 = *v19;
        int v21 = (const icu::UnicodeString *)((char *)v14 + v17);
        if (v18 == -1)
        {
          icu::MeasureFormat::formatMeasure(this, v8, v20, v21, (icu::FieldPosition *)&v27, a6);
          if (*(void *)v29) {
            int v18 = v16;
          }
          else {
            int v18 = -1;
          }
        }

        else
        {
          icu::MeasureFormat::formatMeasure(this, v8, v20, v21, (icu::FieldPosition *)v30, a6);
        }

        v17 += 64LL;
        uint64_t v8 = (const icu::Measure *)((char *)v8 + 128);
        ++v16;
      }

      while ((unint64_t)a3 << 6 != v17);
    }

    int v25 = 0;
    icu::ListFormatter::format(*((icu::ListFormatter **)this + 45), v14, a3, v24, v18, &v25, a6);
LABEL_30:
    sub_1807CCEEC((uint64_t *)&v26);
    icu::FieldPosition::~FieldPosition((icu::FieldPosition *)&v27);
    icu::FieldPosition::~FieldPosition((icu::FieldPosition *)v30);
    return v24;
  }

  return a4;
}

icu::UnicodeString *icu::MeasureFormat::formatMeasures( icu::ListFormatter **this, icu::MeasureUnit **a2, int a3, icu::UnicodeString *a4, icu::FieldPositionIterator *a5, UErrorCode *a6)
{
  uint64_t v97 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    uint64_t v75 = 0LL;
    *(_OWORD *)__int128 v73 = 0u;
    __int128 v74 = 0u;
    icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler((icu::FieldPositionIteratorHandler *)v73, a5, a6);
    if (a3)
    {
      uint64_t v12 = (a3 - 1);
      if (a3 == 1)
      {
        unsigned int v13 = *((unsigned __int16 *)a4 + 4);
        int v14 = (__int16)v13;
        int v15 = v13 >> 5;
        if (v14 >= 0) {
          int v16 = v15;
        }
        else {
          int v16 = *((_DWORD *)a4 + 3);
        }
        int UAMeasureUnit = icu::MeasureUnit::getUAMeasureUnit(a2[15]);
        *(void *)&__int128 v77 = 0LL;
        *(void *)&__int128 v76 = off_189723AC8;
        *((void *)&v76 + sub_1808F7164((uint64_t)v14, 1) = 0x40000000LL;
        icu::MeasureFormat::formatMeasure( (icu::MeasureFormat *)this,  (const icu::Measure *)a2,  *((const icu::NumberFormat **)this[42] + 3),  a4,  (icu::FieldPosition *)&v76,  a6);
        unsigned int v18 = *((unsigned __int16 *)a4 + 4);
        int v19 = (__int16)v18;
        int v20 = v18 >> 5;
        if (v19 >= 0) {
          int v21 = v20;
        }
        else {
          int v21 = *((_DWORD *)a4 + 3);
        }
        icu::FieldPositionIteratorHandler::addAttribute(v73, UAMeasureUnit, v16, v21);
        icu::FieldPositionIteratorHandler::addAttribute(v73, UAMeasureUnit | 0x40000000, SHIDWORD(v76), v77);
        icu::FieldPosition::~FieldPosition((icu::FieldPosition *)&v76);
      }

      else
      {
        if (*((_DWORD *)this + 88) == 3)
        {
          uint64_t v22 = 0LL;
          __int128 v95 = 0u;
          __int128 v96 = 0u;
          __int128 v93 = 0u;
          __int128 v94 = 0u;
          __int128 v91 = 0u;
          __int128 v92 = 0u;
          __int128 v89 = 0u;
          __int128 v90 = 0u;
          __int128 v87 = 0u;
          __int128 v88 = 0u;
          __int128 v85 = 0u;
          __int128 v86 = 0u;
          __int128 v83 = 0u;
          __int128 v84 = 0u;
          __int128 v81 = 0u;
          __int128 v82 = 0u;
          __int128 v79 = 0u;
          __int128 v80 = 0u;
          __int128 v77 = 0u;
          __int128 v78 = 0u;
          __int128 v76 = 0u;
          do
          {
            icu::Formattable::Formattable((icu::Formattable *)((char *)&v76 + v22));
            v22 += 112LL;
          }

          while (v22 != 336);
          int v23 = sub_180902B2C((uint64_t)a2, a3, (double *)&v76, (int *)a6);
          if (v23 >= 1) {
            icu::MeasureFormat::formatNumeric((icu::MeasureFormat *)this, (const icu::Formattable *)&v76, v23, a4, a6);
          }
          for (uint64_t i = 224LL; i != -112; i -= 112LL)
            icu::Formattable::~Formattable((icu::Formattable *)((char *)&v76 + i));
          if (v23 > 0) {
            goto LABEL_73;
          }
        }

        if (a3 < 0) {
          uint64_t v25 = -1LL;
        }
        else {
          uint64_t v25 = ((uint64_t)a3 << 6) | 0x10;
        }
        unsigned int v26 = (unsigned __int16 *)icu::UMemory::operator new[]((icu::UMemory *)v25, v11);
        if (v26)
        {
          int v28 = v26;
          *(void *)unsigned int v26 = 64LL;
          *((void *)v26 + sub_1808F7164((uint64_t)v14, 1) = a3;
          double v29 = (const icu::UnicodeString *)(v26 + 8);
          uint64_t v30 = 8LL;
          do
          {
            uint64_t v31 = &v26[v30];
            *(void *)uint64_t v31 = off_18971B688;
            v31[4] = 2;
            v30 += 32LL;
          }

          while (v31 + 32 != &v26[32 * (uint64_t)a3 + 8]);
          BOOL v32 = !is_mul_ok(a3, 0x18uLL);
          if (v32) {
            uint64_t v33 = -1LL;
          }
          else {
            uint64_t v33 = 24LL * a3 + 16;
          }
          unsigned int v34 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v33, v27);
          if (v34)
          {
            *unsigned int v34 = 24LL;
            v34[1] = a3;
            int v35 = (icu::FieldPosition *)(v34 + 2);
            uint64_t v36 = 2LL;
            uint64_t v37 = v34;
            do
            {
              int v38 = &v34[v36];
              void *v38 = off_189723AC8;
              v38[1] = 0xFFFFFFFFLL;
              *((_DWORD *)v38 + 4) = 0;
              v36 += 3LL;
            }

            while (v38 + 3 != &v34[3 * a3 + 2]);
            if (a3 <= 0)
            {
              icu::ListFormatter::format(this[45], v29, a3, a4, a6);
            }

            else
            {
              int v70 = v34;
              __int128 v71 = a2;
              __int128 v72 = a4;
              uint64_t v39 = v29;
              uint64_t v40 = a3;
              uint64_t v41 = a3;
              uint64_t v42 = (const icu::Measure *)a2;
              __int128 v69 = v39;
              int v43 = v39;
              do
              {
                if (v12) {
                  unsigned int v44 = (const icu::NumberFormat **)((char *)this[41] + 64);
                }
                else {
                  unsigned int v44 = (const icu::NumberFormat **)((char *)this[42] + 24);
                }
                unsigned int v45 = *v44;
                *((_DWORD *)v35 + 2) = 0x40000000;
                icu::MeasureFormat::formatMeasure((icu::MeasureFormat *)this, v42, v45, v43, v35, a6);
                --v12;
                int v43 = (icu::UnicodeString *)((char *)v43 + 64);
                uint64_t v42 = (const icu::Measure *)((char *)v42 + 128);
                int v35 = (icu::FieldPosition *)((char *)v35 + 24);
                --v41;
              }

              while (v41);
              a4 = v72;
              icu::ListFormatter::format(this[45], v69, a3, v72, a6);
              __int128 v46 = v28 + 12;
              uint64_t v37 = v70;
              __int128 v47 = v71 + 15;
              __int128 v48 = v70 + 4;
              do
              {
                unsigned int v49 = *v46;
                if ((v49 & 0x8000u) == 0) {
                  int32_t v50 = v49 >> 5;
                }
                else {
                  int32_t v50 = *((_DWORD *)v46 + 1);
                }
                if ((v49 & 1) == 0 && v50 >= 1)
                {
                  unsigned int v51 = *((unsigned __int16 *)v72 + 4);
                  int v52 = (__int16)v51;
                  unsigned int v53 = v51 >> 5;
                  int32_t v54 = v52 >= 0 ? v53 : *((_DWORD *)v72 + 3);
                  uint64_t v55 = (v49 & 2) != 0 ? (uint64_t)(v46 + 1) : *((void *)v46 + 2);
                  int v56 = icu::UnicodeString::indexOf((uint64_t)v72, v55, 0, v50, 0, v54);
                  if ((v56 & 0x80000000) == 0)
                  {
                    int v57 = v56;
                    int v58 = icu::MeasureUnit::getUAMeasureUnit(*v47);
                    unsigned int v59 = *v46;
                    int v60 = (v59 & 0x8000) != 0 ? *((_DWORD *)v46 + 1) : v59 >> 5;
                    icu::FieldPositionIteratorHandler::addAttribute(v73, v58, v57, v60 + v57);
                    int v61 = *(v48 - 1);
                    if ((v61 & 0x80000000) == 0 && *v48 > v61) {
                      icu::FieldPositionIteratorHandler::addAttribute(v73, v58 | 0x40000000, v61 + v57, *v48 + v57);
                    }
                  }
                }

                v46 += 32;
                v47 += 16;
                v48 += 6;
                --v40;
              }

              while (v40);
            }

            int v64 = (void *)*((void *)v28 + 1);
            if (v64)
            {
              uint64_t v65 = (void)v64 << 6;
              do
              {
                icu::UnicodeString::~UnicodeString(v64, (icu::UnicodeString *)((char *)v28 + v65 - 48));
                v65 -= 64LL;
              }

              while (v65);
            }

            icu::UMemory::operator delete[](v28);
            uint64_t v66 = v37[1];
            if (v66)
            {
              uint64_t v67 = 3 * v66;
              do
              {
                icu::FieldPosition::~FieldPosition((icu::FieldPosition *)&v37[v67 - 1]);
                v67 -= 3LL;
              }

              while (v67 * 8);
            }

            icu::UMemory::operator delete[](v37);
            goto LABEL_73;
          }

          int32_t v62 = (void *)*((void *)v28 + 1);
          if (v62)
          {
            uint64_t v63 = (void)v62 << 6;
            do
            {
              icu::UnicodeString::~UnicodeString(v62, (icu::UnicodeString *)((char *)v28 + v63 - 48));
              v63 -= 64LL;
            }

            while (v63);
          }

          icu::UMemory::operator delete[](v28);
        }

        *a6 = U_MEMORY_ALLOCATION_ERROR;
      }
    }

void icu::MeasureFormat::getUnitDisplayName( icu::MeasureFormat *this@<X0>, const icu::MeasureUnit *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v8 = 1;
  icu::Format::getLocale((uint64_t)this, 1, (int *)a3, (icu::Locale *)v10);
  uint64_t v9 = *((int *)this + 88);
  sub_18092D698((uint64_t)v10, a2, v8, (int *)a3, a4);
  icu::Locale::~Locale((icu::Locale *)v10);
}

uint64_t icu::MeasureFormat::getLocale@<X0>( icu::MeasureFormat *this@<X0>, UErrorCode *a2@<X1>, icu::Locale *a3@<X8>)
{
  return icu::Format::getLocale((uint64_t)this, 1, (int *)a2, a3);
}

void sub_180903AA8(uint64_t a1, UErrorCode *a2, UErrorCode *this)
{
  v11[28] = *MEMORY[0x1895F89C0];
  uint64_t Instance = icu::UnifiedCache::getInstance(this, a2);
  if (*(int *)this <= 0)
  {
    uint64_t v7 = (icu::SharedObject **)Instance;
    int v9 = 0;
    char v10 = 0;
    int v8 = off_1897255F8;
    icu::Locale::Locale((icu::Locale *)v11, a1);
    sub_18089E200(v7, (const icu::CacheKeyBase *)&v8, 0LL, (icu::SharedObject **)a2, this);
    int v8 = off_1897255F8;
    icu::Locale::~Locale((icu::Locale *)v11);
    icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)&v8);
  }

icu::SharedObject *icu::MeasureFormat::adoptNumberFormat( icu::SharedObject *result, unint64_t a2, _DWORD *a3)
{
  unint64_t v4 = (uint64_t *)*a3;
  if ((int)v4 > 0)
  {
    if (!a2) {
      return result;
    }
    return (icu::SharedObject *)(*(uint64_t (**)(unint64_t))(*(void *)a2 + 8LL))(a2);
  }

  uint64_t v6 = result;
  uint64_t result = (icu::SharedObject *)icu::UMemory::operator new(v4, (icu::UMemory *)0x20, a2);
  if (result)
  {
    *(void *)uint64_t result = off_189728658;
    *((void *)result + sub_1808F7164((uint64_t)v14, 1) = 0LL;
    *((void *)result + 2) = 0LL;
    *((void *)result + 3) = a2;
    return sub_18085C214(result, (icu::SharedObject **)v6 + 42);
  }

  else
  {
    *a3 = 7;
    if (a2) {
      return (icu::SharedObject *)(*(uint64_t (**)(unint64_t))(*(void *)a2 + 8LL))(a2);
    }
  }

  return result;
}

BOOL icu::MeasureFormat::setMeasureFormatLocale(icu::MeasureFormat *this, const char **a2, UErrorCode *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  icu::Format::getLocale((uint64_t)this, 1, (int *)a3, (icu::Locale *)v8);
  BOOL v6 = icu::Locale::operator==((uint64_t)a2, (uint64_t)v8);
  icu::Locale::~Locale((icu::Locale *)v8);
  if (v6) {
    return 0LL;
  }
  icu::MeasureFormat::initMeasureFormat((uint64_t)this, a2, *((_DWORD *)this + 88), 0LL, a3);
  return *a3 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t icu::MeasureFormat::getWidth(icu::MeasureFormat *this)
{
  return *((unsigned int *)this + 88);
}

uint64_t icu::MeasureFormat::getCurrencyFormatInternal(icu::MeasureFormat *this)
{
  return *(void *)(*((void *)this + 41) + 56LL);
}

uint64_t icu::MeasureFormat::getPluralRules(icu::MeasureFormat *this)
{
  return *(void *)(*((void *)this + 43) + 24LL);
}

icu::UnicodeString *icu::MeasureFormat::getUnitName( icu::MeasureFormat *this, const icu::MeasureUnit *a2, icu::UnicodeString *a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  UErrorCode v6 = U_ZERO_ERROR;
  icu::MeasureFormat::getUnitDisplayName(this, a2, &v6, (uint64_t)v7);
  icu::UnicodeString::operator=(a3, (icu::UnicodeString *)v7);
  icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
  return a3;
}

icu::UnicodeString *icu::MeasureFormat::getMultipleUnitNames( icu::MeasureFormat *this, const icu::MeasureUnit **a2, int a3, int a4, icu::UnicodeString *a5)
{
  UErrorCode v6 = a2;
  if (a3 == 1)
  {
    icu::MeasureFormat::getUnitName(this, *a2, a5);
  }

  else if (a3)
  {
    if (a3 < 0) {
      uint64_t v11 = -1LL;
    }
    else {
      uint64_t v11 = ((uint64_t)a3 << 6) | 0x10;
    }
    uint64_t v12 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v11, (unint64_t)a2);
    if (!v12) {
      goto LABEL_23;
    }
    unsigned int v13 = v12;
    *uint64_t v12 = 64LL;
    v12[1] = a3;
    int v14 = (const icu::UnicodeString *)(v12 + 2);
    uint64_t v15 = 2LL;
    do
    {
      int v16 = &v12[v15];
      *int v16 = off_18971B688;
      *((_WORD *)v16 + 4) = 2;
      v15 += 8LL;
    }

    while (v16 + 8 != &v12[8 * (uint64_t)a3 + 2]);
    if (a3 >= 1)
    {
      uint64_t v17 = a3;
      unsigned int v18 = (icu::UnicodeString *)(v12 + 2);
      do
      {
        int v19 = *v6++;
        icu::MeasureFormat::getUnitName(this, v19, v18);
        unsigned int v18 = (icu::UnicodeString *)((char *)v18 + 64);
        --v17;
      }

      while (v17);
    }

    UErrorCode v24 = U_ZERO_ERROR;
    uint64_t v20 = 360LL;
    if (!a4) {
      uint64_t v20 = 368LL;
    }
    icu::ListFormatter::format(*(icu::ListFormatter **)((char *)this + v20), v14, a3, a5, &v24);
    int v21 = (void *)v13[1];
    if (v21)
    {
      uint64_t v22 = (void)v21 << 6;
      do
      {
        icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)((char *)v13 + v22 - 48));
        v22 -= 64LL;
      }

      while (v22);
    }

    icu::UMemory::operator delete[](v13);
    if (v24 >= U_ILLEGAL_ARGUMENT_ERROR) {
LABEL_23:
    }
      icu::UnicodeString::setToBogus(a5);
  }

  else
  {
    if ((*((_WORD *)a5 + 4) & 1) != 0) {
      __int16 v9 = 2;
    }
    else {
      __int16 v9 = *((_WORD *)a5 + 4) & 0x1F;
    }
    *((_WORD *)a5 + 4) = v9;
  }

  return a5;
}

void *icu::MeasureFormat::createCurrencyFormat(const char **this, UErrorCode *a2, UErrorCode *a3)
{
  uint64_t v3 = (uint64_t *)*(unsigned int *)a2;
  uint64_t v7 = icu::UMemory::operator new(v3, (icu::UMemory *)0x178, (unint64_t)a2);
  if (v7) {
    return sub_1808C0198((uint64_t)v7, this, a2);
  }
  uint64_t result = 0LL;
  *a2 = U_MEMORY_ALLOCATION_ERROR;
  return result;
}

void *icu::MeasureFormat::createCurrencyFormat(icu::MeasureFormat *this, UErrorCode *a2)
{
  uint64_t Default = icu::Locale::getDefault(this);
  return icu::MeasureFormat::createCurrencyFormat((const char **)Default, (UErrorCode *)this, v5);
}

void sub_180903FAC(uint64_t a1@<X0>, const char *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  v27[8] = *(void **)MEMORY[0x1895F89C0];
  *(_OWORD *)(a4 + 8) = 0u;
  *(void *)(a4 + 56) = 0LL;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(void *)a4 = off_18971B688;
  *(_WORD *)(a4 + 8) = 2;
  if (*(int *)a3 <= 0)
  {
    memset(&v27[1], 0, 56);
    v27[0] = (char *)&v27[1] + 5;
    LODWORD(v27[1]) = 40;
    icu::StringPiece::StringPiece((icu::StringPiece *)&v23, "durationUnits");
    uint64_t v8 = icu::CharString::append((icu::CharString *)v27, v23, v24, a3);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v21, "/");
    __int16 v9 = icu::CharString::append(v8, v21, v22, a3);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v19, a2);
    icu::CharString::append(v9, v19, v20, a3);
    uint64_t v10 = ures_getByKeyWithFallback(a1, (char *)v27[0], 0LL, a3);
    uint64_t v11 = v10;
    if (*(int *)a3 <= 0)
    {
      int v26 = 0;
      String = ures_getString(v10, &v26, (int *)a3);
      if (*(int *)a3 < 1)
      {
        uint64_t v25 = String;
        icu::UnicodeString::setTo((icu::UnicodeString *)a4, 1, &v25, v26);
        unsigned __int16 v14 = *(_WORD *)(a4 + 8);
        int v15 = (__int16)v14;
        unsigned int v16 = v14 >> 5;
        if (v15 >= 0) {
          uint64_t v13 = v16;
        }
        else {
          uint64_t v13 = *(unsigned int *)(a4 + 12);
        }
        Buffer = (_WORD *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a4, v13);
        if ((int)v13 >= 1)
        {
          uint64_t v18 = v13;
          do
          {
            if (*Buffer == 104) {
              _WORD *Buffer = 72;
            }
            ++Buffer;
            --v18;
          }

          while (v18);
        }
      }

      else
      {
        icu::UnicodeString::getBuffer((icu::UnicodeString *)a4, 0);
        LODWORD(v13) = 0;
      }

      icu::UnicodeString::releaseBuffer(a4, v13);
    }

    if (v11) {
      ures_close(v11);
    }
    if (BYTE4(v27[1])) {
      uprv_free(v27[0]);
    }
  }

BOOL sub_1809041D8(icu::MeasureUnit *a1, const char *a2)
{
  unsigned int Type = icu::MeasureUnit::getType(a1);
  if (strcmp(Type, "duration")) {
    return 0LL;
  }
  Subtype = icu::MeasureUnit::getSubtype(a1);
  return strcmp(Subtype, a2) == 0;
}

void sub_18090422C(uint64_t a1)
{
  *(void *)a1 = off_1897255F8;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
}

void sub_18090425C(uint64_t a1)
{
  *(void *)a1 = off_1897255F8;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
  icu::UMemory::operator delete(v2);
}

uint64_t sub_180904290(uint64_t a1)
{
  int v2 = strlen((const char *)((unint64_t)"N3icu22MeasureFormatCacheDataE" & 0x7FFFFFFFFFFFFFFFLL));
  unsigned int v3 = ustr_hashCharsN( (unsigned __int8 *)((unint64_t)"N3icu22MeasureFormatCacheDataE" & 0x7FFFFFFFFFFFFFFFLL),  v2);
  return icu::Locale::hashCode((icu::Locale *)(a1 + 16)) + 37 * v3;
}

uint64_t *sub_1809042E8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0xF0, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a1 + 8);
    *((_BYTE *)v4 + 12) = 0;
    *unint64_t v4 = (uint64_t)off_1897255F8;
    icu::Locale::Locale((icu::Locale *)(v4 + 2), a1 + 16);
  }

  return v5;
}

char *sub_18090433C(uint64_t a1, char *__dst, int a3)
{
  uint64_t result = strncpy(__dst, *(const char **)(a1 + 56), a3);
  __dst[a3 - 1] = 0;
  return result;
}

BOOL sub_180904374(void *a1, void *a2)
{
  BOOL result = sub_18089E3E8(a1, a2);
  if (result) {
    return icu::Locale::operator==((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  }
  return result;
}

void *icu::MeasureUnit::getStaticClassID(icu::MeasureUnit *this)
{
  return &unk_18C535661;
}

void *icu::MeasureUnit::getDynamicClassID(icu::MeasureUnit *this)
{
  return &unk_18C535661;
}

uint64_t icu::MeasureUnit::createGForce(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 0;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

uint64_t icu::MeasureUnit::create(icu::MeasureUnit *this, unint64_t a2, int *a3, UErrorCode *a4)
{
  if (*a3 > 0) {
    return 0LL;
  }
  __int16 v6 = a2;
  char v7 = (char)this;
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = v6;
    *(_BYTE *)(result + 18) = v7;
  }

  else
  {
    *a3 = 7;
  }

  return result;
}

void icu::MeasureUnit::getGForce(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 0;
}

uint64_t icu::MeasureUnit::MeasureUnit(uint64_t this, char a2, __int16 a3)
{
  *(void *)this = off_189725678;
  *(void *)(this + 8) = 0LL;
  *(_WORD *)(this + 16) = a3;
  *(_BYTE *)(this + 18) = a2;
  return this;
}

{
  *(void *)this = off_189725678;
  *(void *)(this + 8) = 0LL;
  *(_WORD *)(this + 16) = a3;
  *(_BYTE *)(this + 18) = a2;
  return this;
}

uint64_t icu::MeasureUnit::createMeterPerSecondSquared(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 0;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMeterPerSecondSquared(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 0;
}

uint64_t icu::MeasureUnit::createArcMinute(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 1;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getArcMinute(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 1;
}

uint64_t icu::MeasureUnit::createArcSecond(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 1;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getArcSecond(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 1;
}

uint64_t icu::MeasureUnit::createDegree(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 1;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDegree(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 1;
}

uint64_t icu::MeasureUnit::createRadian(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 1;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getRadian(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 1;
}

uint64_t icu::MeasureUnit::createRevolutionAngle(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 1;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getRevolutionAngle(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 1;
}

uint64_t icu::MeasureUnit::createAcre(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getAcre(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createDunam(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDunam(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createHectare(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getHectare(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareCentimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareCentimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareFoot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareFoot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareInch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareInch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareKilometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareKilometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareMeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareMeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareMile(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareMile(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createSquareYard(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 2;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSquareYard(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 2;
}

uint64_t icu::MeasureUnit::createItem(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getItem(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createKarat(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKarat(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createMilligramOfglucosePerDeciliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilligramOfglucosePerDeciliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createMilligramPerDeciliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilligramPerDeciliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createMillimolePerLiter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMillimolePerLiter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createMole(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMole(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createPercent(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPercent(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createPermille(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPermille(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createPartPerMillion(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPartPerMillion(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createPermyriad(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 3;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPermyriad(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 3;
}

uint64_t icu::MeasureUnit::createLiterPer100Kilometers(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 4;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getLiterPer100Kilometers(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 4;
}

uint64_t icu::MeasureUnit::createLiterPerKilometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 4;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getLiterPerKilometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 4;
}

uint64_t icu::MeasureUnit::createMilePerGallon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 4;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilePerGallon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 4;
}

uint64_t icu::MeasureUnit::createMilePerGallonImperial(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 4;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilePerGallonImperial(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 4;
}

uint64_t icu::MeasureUnit::createBit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getBit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createByte(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getByte(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createGigabit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGigabit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createGigabyte(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGigabyte(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createKilobit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilobit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createKilobyte(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilobyte(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createMegabit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegabit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createMegabyte(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegabyte(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createPetabyte(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPetabyte(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createTerabit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getTerabit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createTerabyte(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 10;
    *(_BYTE *)(result + 18) = 6;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getTerabyte(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 10;
  *(_BYTE *)(a1 + 18) = 6;
}

uint64_t icu::MeasureUnit::createCentury(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCentury(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createDay(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDay(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createDayPerson(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDayPerson(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createDecade(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDecade(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createHour(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getHour(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createMicrosecond(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMicrosecond(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createMillisecond(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMillisecond(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createMinute(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMinute(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createMonth(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMonth(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createMonthPerson(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMonthPerson(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createNanosecond(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 10;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getNanosecond(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 10;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createQuarter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 11;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getQuarter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 11;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createSecond(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 12;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSecond(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 12;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createWeek(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 13;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getWeek(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 13;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createWeekPerson(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 14;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getWeekPerson(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 14;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createYear(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 15;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getYear(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 15;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createYearPerson(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 16;
    *(_BYTE *)(result + 18) = 7;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getYearPerson(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 16;
  *(_BYTE *)(a1 + 18) = 7;
}

uint64_t icu::MeasureUnit::createAmpere(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 8;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getAmpere(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 8;
}

uint64_t icu::MeasureUnit::createMilliampere(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 8;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilliampere(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 8;
}

uint64_t icu::MeasureUnit::createOhm(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 8;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getOhm(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 8;
}

uint64_t icu::MeasureUnit::createVolt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 8;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getVolt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 8;
}

uint64_t icu::MeasureUnit::createBritishThermalUnit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getBritishThermalUnit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createCalorie(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCalorie(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createElectronvolt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getElectronvolt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createFoodcalorie(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFoodcalorie(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createJoule(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getJoule(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createKilocalorie(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilocalorie(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createKilojoule(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilojoule(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createKilowattHour(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilowattHour(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createThermUs(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 9;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getThermUs(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 9;
}

uint64_t icu::MeasureUnit::createKilowattHourPer100Kilometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 10;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilowattHourPer100Kilometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 10;
}

uint64_t icu::MeasureUnit::createNewton(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 10;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getNewton(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 10;
}

uint64_t icu::MeasureUnit::createPoundForce(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 10;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPoundForce(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 10;
}

uint64_t icu::MeasureUnit::createGigahertz(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 11;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGigahertz(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 11;
}

uint64_t icu::MeasureUnit::createHertz(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 11;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getHertz(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 11;
}

uint64_t icu::MeasureUnit::createKilohertz(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 11;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilohertz(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 11;
}

uint64_t icu::MeasureUnit::createMegahertz(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 11;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegahertz(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 11;
}

uint64_t icu::MeasureUnit::createDot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createDotPerCentimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDotPerCentimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createDotPerInch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDotPerInch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createEm(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getEm(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createMegapixel(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegapixel(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createPixel(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPixel(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createPixelPerCentimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPixelPerCentimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createPixelPerInch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 12;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPixelPerInch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 12;
}

uint64_t icu::MeasureUnit::createAstronomicalUnit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getAstronomicalUnit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createCentimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCentimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createDecimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDecimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createEarthRadius(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getEarthRadius(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createFathom(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFathom(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createFoot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFoot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createFurlong(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFurlong(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createInch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getInch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createKilometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createLightYear(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getLightYear(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createMeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 10;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 10;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createMicrometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 11;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMicrometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 11;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createMile(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 12;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMile(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 12;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createMileScandinavian(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 13;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMileScandinavian(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 13;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createMillimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 14;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMillimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 14;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createNanometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 15;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getNanometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 15;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createNauticalMile(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 16;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getNauticalMile(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 16;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createParsec(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 17;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getParsec(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 17;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createPicometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 18;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPicometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 18;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createPoint(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 19;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPoint(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 19;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createSolarRadius(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 20;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSolarRadius(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 20;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createYard(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 21;
    *(_BYTE *)(result + 18) = 13;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getYard(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 21;
  *(_BYTE *)(a1 + 18) = 13;
}

uint64_t icu::MeasureUnit::createCandela(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 14;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCandela(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 14;
}

uint64_t icu::MeasureUnit::createLumen(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 14;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getLumen(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 14;
}

uint64_t icu::MeasureUnit::createLux(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 14;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getLux(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 14;
}

uint64_t icu::MeasureUnit::createSolarLuminosity(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 14;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSolarLuminosity(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 14;
}

uint64_t icu::MeasureUnit::createCarat(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCarat(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createDalton(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDalton(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createEarthMass(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getEarthMass(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createGrain(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGrain(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createGram(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGram(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createKilogram(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilogram(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createMetricTon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 14;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMetricTon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 14;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createMicrogram(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMicrogram(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createMilligram(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilligram(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createOunce(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getOunce(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createOunceTroy(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getOunceTroy(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createPound(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 10;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPound(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 10;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createSolarMass(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 11;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getSolarMass(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 11;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createStone(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 12;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getStone(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 12;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createTon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 13;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getTon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 13;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createTonne(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 14;
    *(_BYTE *)(result + 18) = 15;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getTonne(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 14;
  *(_BYTE *)(a1 + 18) = 15;
}

uint64_t icu::MeasureUnit::createGigawatt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 17;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGigawatt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 17;
}

uint64_t icu::MeasureUnit::createHorsepower(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 17;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getHorsepower(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 17;
}

uint64_t icu::MeasureUnit::createKilowatt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 17;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilowatt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 17;
}

uint64_t icu::MeasureUnit::createMegawatt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 17;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegawatt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 17;
}

uint64_t icu::MeasureUnit::createMilliwatt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 17;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilliwatt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 17;
}

uint64_t icu::MeasureUnit::createWatt(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 17;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getWatt(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 17;
}

uint64_t icu::MeasureUnit::createAtmosphere(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getAtmosphere(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createBar(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getBar(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createGasolineEnergyDensity(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGasolineEnergyDensity(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createHectopascal(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getHectopascal(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createInchHg(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getInchHg(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createKilopascal(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilopascal(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createMegapascal(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegapascal(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createMillibar(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMillibar(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createMillimeterOfMercury(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMillimeterOfMercury(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createPascal(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPascal(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createPoundPerSquareInch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 10;
    *(_BYTE *)(result + 18) = 18;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPoundPerSquareInch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 10;
  *(_BYTE *)(a1 + 18) = 18;
}

uint64_t icu::MeasureUnit::createBeaufort(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 19;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getBeaufort(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 19;
}

uint64_t icu::MeasureUnit::createKilometerPerHour(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 19;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKilometerPerHour(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 19;
}

uint64_t icu::MeasureUnit::createKnot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 19;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKnot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 19;
}

uint64_t icu::MeasureUnit::createMeterPerSecond(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 19;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMeterPerSecond(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 19;
}

uint64_t icu::MeasureUnit::createMilePerHour(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 19;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilePerHour(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 19;
}

uint64_t icu::MeasureUnit::createCelsius(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 20;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCelsius(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 20;
}

uint64_t icu::MeasureUnit::createFahrenheit(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 20;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFahrenheit(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 20;
}

uint64_t icu::MeasureUnit::createGenericTemperature(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 20;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGenericTemperature(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 20;
}

uint64_t icu::MeasureUnit::createKelvin(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 20;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getKelvin(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 20;
}

uint64_t icu::MeasureUnit::createNewtonMeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 21;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getNewtonMeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 21;
}

uint64_t icu::MeasureUnit::createPoundFoot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 21;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPoundFoot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 21;
}

uint64_t icu::MeasureUnit::createAcreFoot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 0;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getAcreFoot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createBarrel(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 1;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getBarrel(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createBushel(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 2;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getBushel(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 2;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCentiliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 3;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCentiliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 3;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicCentimeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 4;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicCentimeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 4;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicFoot(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 5;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicFoot(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicInch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 6;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicInch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 6;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicKilometer(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 7;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicKilometer(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 7;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicMeter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 8;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicMeter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 8;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicMile(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 9;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicMile(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 9;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCubicYard(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 10;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCubicYard(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 10;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCup(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 11;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCup(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 11;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createCupMetric(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 12;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getCupMetric(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 12;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createDeciliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 13;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDeciliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 13;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createDessertSpoon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 14;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDessertSpoon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 14;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createDessertSpoonImperial(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 15;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDessertSpoonImperial(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 15;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createDram(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 16;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDram(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 16;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createDrop(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 17;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getDrop(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 17;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createFluidOunce(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 18;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFluidOunce(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 18;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createFluidOunceImperial(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 19;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getFluidOunceImperial(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 19;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createGallon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 20;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGallon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 20;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createGallonImperial(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 21;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getGallonImperial(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 21;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createHectoliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 22;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getHectoliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 22;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createJigger(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 23;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getJigger(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 23;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createLiter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 24;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getLiter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 24;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createMegaliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 25;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMegaliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 25;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createMilliliter(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 26;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getMilliliter(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 26;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createPinch(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 27;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPinch(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 27;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createPint(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 28;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPint(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 28;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createPintMetric(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 29;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getPintMetric(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 29;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createQuart(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 30;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getQuart(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 30;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createQuartImperial(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 31;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getQuartImperial(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 31;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createTablespoon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 32;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getTablespoon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 32;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::createTeaspoon(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x18, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_189725678;
    *(void *)(result + 8) = 0LL;
    *(_WORD *)(result + 16) = 33;
    *(_BYTE *)(result + 18) = 22;
  }

  else
  {
    *(_DWORD *)this = 7;
  }

  return result;
}

void icu::MeasureUnit::getTeaspoon(uint64_t a1@<X8>)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = 33;
  *(_BYTE *)(a1 + 18) = 22;
}

uint64_t icu::MeasureUnit::MeasureUnit(uint64_t this)
{
  *(void *)this = off_189725678;
  *(void *)(this + 8) = 0LL;
  *(_WORD *)(this + 16) = 0;
  *(_BYTE *)(this + 18) = 16;
  return this;
}

{
  *(void *)this = off_189725678;
  *(void *)(this + 8) = 0LL;
  *(_WORD *)(this + 16) = 0;
  *(_BYTE *)(this + 18) = 16;
  return this;
}

uint64_t icu::MeasureUnit::MeasureUnit(uint64_t this, unint64_t a2)
{
  *(void *)this = off_189725678;
  *(void *)(this + 8) = 0LL;
  return icu::MeasureUnit::operator=(this, a2);
}

{
  *(void *)this = off_189725678;
  *(void *)(this + 8) = 0LL;
  return icu::MeasureUnit::operator=(this, a2);
}

uint64_t icu::MeasureUnit::operator=(uint64_t a1, unint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      if (*(_BYTE *)(v4 + 108)) {
        uprv_free(*(void **)(v4 + 96));
      }
      sub_180850D68(v4 + 8);
      icu::UMemory::operator delete((void *)v4);
    }

    if (*(void *)(a2 + 8))
    {
      uint64_t v11 = qword_18970B7E0;
      uint64_t v12 = 0LL;
      uint64_t v5 = icu::UMemory::operator new(qword_18970B7E0, (icu::UMemory *)0xA0, a2);
      if (v5)
      {
        __int16 v6 = v5;
        icu::MeasureUnitImpl::copy(*(icu::MeasureUnitImpl **)(a2 + 8), (UErrorCode *)&v12, (uint64_t)v5);
        *(void *)(a1 + 8) = v6;
        if ((int)v12 <= 0)
        {
          icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v11);
LABEL_11:
          *(_BYTE *)(a1 + 18) = *(_BYTE *)(a2 + 18);
          *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
          return a1;
        }
      }

      else
      {
        *(void *)(a1 + 8) = 0LL;
      }

      v8[0] = off_189725678;
      v8[1] = 0LL;
      __int16 v9 = 0;
      char v10 = 16;
      icu::MeasureUnit::operator=(a1, (uint64_t)v8);
      icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)v8);
      icu::ErrorCode::~ErrorCode((icu::ErrorCode *)&v11);
      return a1;
    }

    *(void *)(a1 + 8) = 0LL;
    goto LABEL_11;
  }

  return a1;
}

uint64_t icu::MeasureUnit::MeasureUnit(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = off_189725678;
  *(void *)(result + 8) = v2;
  *(_WORD *)(result + 16) = *(_WORD *)(a2 + 16);
  *(_BYTE *)(result + 18) = *(_BYTE *)(a2 + 18);
  *(void *)(a2 + 8) = 0LL;
  return result;
}

{
  uint64_t v2;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = off_189725678;
  *(void *)(result + 8) = v2;
  *(_WORD *)(result + 16) = *(_WORD *)(a2 + 16);
  *(_BYTE *)(result + 18) = *(_BYTE *)(a2 + 18);
  *(void *)(a2 + 8) = 0LL;
  return result;
}

uint64_t icu::MeasureUnit::MeasureUnit(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_189725678;
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 16) = -1;
  *(_BYTE *)(a1 + 18) = -1;
  uint64_t v4 = a2 + 96;
  if (!icu::MeasureUnit::findBySubType(*(const char **)(a2 + 96), *(_DWORD *)(a2 + 152), (icu::MeasureUnit *)a1))
  {
    char v7 = icu::UMemory::operator new(v6, (icu::UMemory *)0xA0, v5);
    uint64_t v8 = v7;
    if (v7)
    {
      *(_DWORD *)char v7 = *(_DWORD *)a2;
      sub_18090BCB4((uint64_t)(v7 + 1), a2 + 8);
      icu::CharString::CharString(v8 + 12, v4);
    }

    *(void *)(a1 + 8) = v8;
  }

  return a1;
}

BOOL icu::MeasureUnit::findBySubType(const char *a1, int a2, icu::MeasureUnit *a3)
{
  unint64_t v5 = 0LL;
  BOOL v6 = 1;
  while (v5 == 5)
  {
    uint64_t v7 = 6LL;
LABEL_7:
    BOOL v6 = v5 < 0x16;
    unint64_t v5 = v7;
    if (v7 == 23) {
      return v6;
    }
  }

  int v8 = dword_180A39CBC[v5];
  uint64_t v7 = v5 + 1;
  int v9 = dword_180A39CBC[v5 + 1];
  int v10 = sub_18090AF48((uint64_t)off_189725758, v8, v9, (uint64_t)a1, a2);
  if (v10 < 0)
  {
    if (strcmp(a1, "hour-kilowatt")) {
      goto LABEL_7;
    }
    icu::StringPiece::StringPiece((icu::StringPiece *)&v13, "kilowatt-hour");
    int v10 = sub_18090AF48((uint64_t)off_189725758, v8, v9, v13, v14);
    if (v10 < 0) {
      goto LABEL_7;
    }
  }

  icu::MeasureUnit::setTo(a3, v5, v10 - v8);
  return v6;
}

void *icu::MeasureUnitImpl::copy@<X0>(icu::MeasureUnitImpl *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(void *)(a3 + 16) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 8;
  *(void *)(a3 + 96) = a3 + 109;
  *(_DWORD *)(a3 + 104) = 40;
  *(_DWORD *)(a3 + 152) = 0;
  *(_DWORD *)a3 = *(_DWORD *)this;
  uint64_t result = icu::CharString::append( (icu::CharString *)(a3 + 96),  *((const char **)this + 12),  *((_DWORD *)this + 38),  a2);
  if (*((int *)this + 2) >= 1)
  {
    uint64_t v7 = 0LL;
    int v8 = (const void **)(a3 + 8);
    while (1)
    {
      uint64_t result = sub_18090BD94(v8, *(void *)(*((void *)this + 2) + 8 * v7));
      if (!result) {
        break;
      }
    }

    *a2 = U_MEMORY_ALLOCATION_ERROR;
  }

  return result;
}

uint64_t icu::MeasureUnit::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      if (*(_BYTE *)(v4 + 108)) {
        uprv_free(*(void **)(v4 + 96));
      }
      sub_180850D68(v4 + 8);
      icu::UMemory::operator delete((void *)v4);
    }

    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = 0LL;
    *(_BYTE *)(a1 + 18) = *(_BYTE *)(a2 + 18);
    *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  }

  return a1;
}

uint64_t *icu::MeasureUnit::clone@<X0>( icu::MeasureUnit *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x18, a2);
  if (result)
  {
    *uint64_t result = (uint64_t)off_189725678;
    result[1] = 0LL;
    return (uint64_t *)icu::MeasureUnit::operator=((uint64_t)result, (unint64_t)this);
  }

  return result;
}

void icu::MeasureUnit::~MeasureUnit(icu::MeasureUnit *this)
{
  *(void *)this = off_189725678;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    if (*(_BYTE *)(v2 + 108)) {
      uprv_free(*(void **)(v2 + 96));
    }
    sub_180850D68(v2 + 8);
    icu::UMemory::operator delete((void *)v2);
    *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  }

  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::MeasureUnit::~MeasureUnit(this);
  icu::UMemory::operator delete(v1);
}

const char *icu::MeasureUnit::getType(icu::MeasureUnit *this)
{
  uint64_t v1 = *((char *)this + 18);
  if (v1 == -1) {
    return "";
  }
  else {
    return off_1897256A0[v1];
  }
}

const char *icu::MeasureUnit::getSubtype(icu::MeasureUnit *this)
{
  uint64_t v1 = *((unsigned __int8 *)this + 18);
  if (v1 == 255) {
    return "";
  }
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    unsigned int v3 = (char **)(v2 + 96);
  }

  else
  {
    else {
      unint64_t v5 = dword_180A39CBC[v1] + (unint64_t)*((unsigned __int16 *)this + 8);
    }
    unsigned int v3 = &off_189725758[v5];
  }

  return *v3;
}

char *icu::MeasureUnit::getIdentifier(icu::MeasureUnit *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v2 = (char **)(v1 + 96);
  }

  else
  {
    else {
      unint64_t v3 = dword_180A39CBC[*((unsigned __int8 *)this + 18)] + (unint64_t)*((unsigned __int16 *)this + 8);
    }
    uint64_t v2 = &off_189725758[v3];
  }

  return *v2;
}

uint64_t icu::MeasureUnit::getOffset(icu::MeasureUnit *this)
{
  else {
    return dword_180A39CBC[*((unsigned __int8 *)this + 18)] + *((unsigned __int16 *)this + 8);
  }
}

uint64_t icu::MeasureUnit::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a1) {
    __cxa_bad_typeid();
  }
  uint64_t result = sub_1807F874C(*(void *)(*(void *)a1 - 8LL), *(void *)(*(void *)a2 - 8LL));
  if ((_DWORD)result)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (v5)
    {
      BOOL v6 = (const char **)(v5 + 96);
    }

    else
    {
      else {
        unint64_t v7 = dword_180A39CBC[*(unsigned __int8 *)(a1 + 18)] + (unint64_t)*(unsigned __int16 *)(a1 + 16);
      }
      BOOL v6 = (const char **)&off_189725758[v7];
    }

    int v8 = *v6;
    uint64_t v9 = *(void *)(a2 + 8);
    if (v9)
    {
      int v10 = (const char **)(v9 + 96);
    }

    else
    {
      else {
        unint64_t v11 = dword_180A39CBC[*(unsigned __int8 *)(a2 + 18)] + (unint64_t)*(unsigned __int16 *)(a2 + 16);
      }
      int v10 = (const char **)&off_189725758[v11];
    }

    return strcmp(v8, *v10) == 0;
  }

  return result;
}

uint64_t icu::MeasureUnit::getAvailable( icu::MeasureUnit *this, icu::MeasureUnit *a2, int *a3, UErrorCode *a4)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if ((int)a2 >= 492)
  {
    int v6 = 0;
    uint64_t v7 = 0LL;
    int v8 = 0;
    do
    {
      int v9 = v6;
      uint64_t v10 = v7 + 1;
      int v6 = dword_180A39CBC[v7 + 1];
      int v11 = v6 - v9;
      if (v6 - v9 >= 1)
      {
        int v12 = 0;
        uint64_t v13 = (icu::MeasureUnit *)((char *)this + 24 * v8);
        do
        {
          icu::MeasureUnit::setTo(v13, v7, v12++);
          uint64_t v13 = (icu::MeasureUnit *)((char *)v13 + 24);
        }

        while (v11 != v12);
        v8 += v12;
      }

      ++v7;
    }

    while (v10 != 23);
  }

  else
  {
    *a3 = 15;
  }

  return 492LL;
}

void icu::MeasureUnit::setTo(icu::MeasureUnit *this, char a2, __int16 a3)
{
  *((_BYTE *)this + 18) = a2;
  *((_WORD *)this + 8) = a3;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    if (*(_BYTE *)(v3 + 108)) {
      uprv_free(*(void **)(v3 + 96));
    }
    sub_180850D68(v3 + 8);
    icu::UMemory::operator delete((void *)v3);
    *((void *)this + sub_1808F7164((uint64_t)v14, 1) = 0LL;
  }

uint64_t icu::MeasureUnit::getAvailable( icu::MeasureUnit *this, icu::MeasureUnit *a2, icu::MeasureUnit *a3, int *a4, UErrorCode *a5)
{
  if (*a4 > 0) {
    return 0LL;
  }
  int v8 = (int)a3;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v13, (const char *)this);
  int v10 = sub_18090AF48((uint64_t)off_1897256A0, 0, 23, v13, v14);
  if (v10 == -1) {
    return 0LL;
  }
  char v11 = v10;
  uint64_t v5 = (dword_180A39CBC[v10 + 1] - dword_180A39CBC[v10]);
  if ((int)v5 <= v8)
  {
    if ((int)v5 >= 1)
    {
      for (uint64_t i = 0LL; i != v5; ++i)
      {
        icu::MeasureUnit::setTo(a2, v11, i);
        a2 = (icu::MeasureUnit *)((char *)a2 + 24);
      }
    }
  }

  else
  {
    *a4 = 15;
  }

  return v5;
}

uint64_t sub_18090AF48(uint64_t a1, int a2, int a3, uint64_t a4, int a5)
{
  while (a2 < a3)
  {
    int v10 = a2 + a3;
    if (a2 + a3 < 0 != __OFADD__(a2, a3)) {
      ++v10;
    }
    uint64_t v11 = (v10 >> 1);
    icu::StringPiece::StringPiece((icu::StringPiece *)v15, *(const char **)(a1 + 8LL * (int)v11));
    int v13 = icu::StringPiece::compare((uint64_t)v15, a4, a5, v12);
    if (v13 < 0)
    {
      a2 = v11 + 1;
    }

    else
    {
      a3 = v11;
      if (!v13) {
        return v11;
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t icu::MeasureUnit::getAvailableTypes(icu::MeasureUnit *this, UErrorCode *a2)
{
  uint64_t v4 = (void **)uenum_openCharStringsEnumeration((uint64_t)off_1897256A0, 23, (int *)this);
  uint64_t v5 = (uint64_t *)*(unsigned int *)this;
  uint64_t v7 = icu::UMemory::operator new(v5, (icu::UMemory *)0x80, v3);
  if (!v7)
  {
    *(_DWORD *)this = 7;
LABEL_2:
    uenum_close(v4);
    return 0LL;
  }

  return icu::UStringEnumeration::UStringEnumeration((uint64_t)v7, (uint64_t)v4);
}

uint64_t icu::MeasureUnit::initTime(icu::MeasureUnit *this, const char *a2)
{
  char v4 = sub_18090AF48((uint64_t)off_1897256A0, 0, 23, v10, v11);
  *((_BYTE *)this + 18) = v4;
  int v5 = dword_180A39CBC[v4];
  int v6 = dword_180A39CBC[v4 + 1];
  icu::StringPiece::StringPiece((icu::StringPiece *)&v8, a2);
  uint64_t result = sub_18090AF48((uint64_t)off_189725758, v5, v6, v8, v9);
  *((_WORD *)this + 8) = result - LOWORD(dword_180A39CBC[*((char *)this + 18)]);
  return result;
}

uint64_t icu::MeasureUnit::initCurrency(uint64_t a1, const char *a2, int a3)
{
  char v6 = sub_18090AF48((uint64_t)off_1897256A0, 0, 23, v19, v20);
  *(_BYTE *)(a1 + 18) = v6;
  uint64_t result = sub_18090AF48((uint64_t)off_189725758, dword_180A39CBC[v6], dword_180A39CBC[v6 + 1], (uint64_t)a2, a3);
  if ((_DWORD)result == -1)
  {
    uint64_t v11 = icu::UMemory::operator new(v9, (icu::UMemory *)0xA0, v8);
    if (v11)
    {
      uint64_t v12 = v11;
      *((_OWORD *)v11 + 8) = 0u;
      *((_OWORD *)v11 + 9) = 0u;
      *((_OWORD *)v11 + 7) = 0u;
      *((_OWORD *)v11 + 4) = 0u;
      *((_OWORD *)v11 + 5) = 0u;
      *((_OWORD *)v11 + 3) = 0u;
      *((_OWORD *)v11 + 6) = 0u;
      int v13 = (icu::CharString *)(v11 + 12);
      *(_OWORD *)uint64_t v12 = 0u;
      *((_OWORD *)v12 + sub_1808F7164((uint64_t)v14, 1) = 0u;
      *((_OWORD *)v12 + 2) = 0u;
      int v12[2] = (uint64_t)(v12 + 4);
      *((_DWORD *)v12 + 6) = 8;
      *(void *)int v13 = (char *)v12 + 109;
      *((_DWORD *)v12 + 26) = 40;
      UErrorCode v21 = U_ZERO_ERROR;
      uint64_t result = (uint64_t)icu::CharString::append(v13, a2, a3, &v21);
      *(void *)(a1 + 8) = v12;
      LOWORD(v10) = -1;
      goto LABEL_5;
    }

    *(void *)(a1 + 8) = 0LL;
    uint64_t v14 = &dword_180A39CBC[*(char *)(a1 + 18)];
    int v15 = *v14;
    int v16 = v14[1];
    icu::StringPiece::StringPiece((icu::StringPiece *)&v17, "XXX");
    uint64_t result = sub_18090AF48((uint64_t)off_189725758, v15, v16, v17, v18);
  }

  int v10 = result - dword_180A39CBC[*(char *)(a1 + 18)];
LABEL_5:
  *(_WORD *)(a1 + 16) = v10;
  return result;
}

uint64_t icu::MeasureUnit::createFromUAMeasureUnit(int a1, icu::MeasureUnit *this)
{
  if (a1 > 2815)
  {
    if (a1 > 3583)
    {
      if (a1 > 4607)
      {
        if (a1 <= 4864)
        {
          switch(a1)
          {
            case 4608:
              uint64_t result = icu::MeasureUnit::createKarat(this, (UErrorCode *)this);
              break;
            case 4609:
            case 4617:
              uint64_t result = icu::MeasureUnit::createMilligramOfglucosePerDeciliter(this, (UErrorCode *)this);
              break;
            case 4610:
              uint64_t result = icu::MeasureUnit::createMillimolePerLiter(this, (UErrorCode *)this);
              break;
            case 4611:
              uint64_t result = icu::MeasureUnit::createPartPerMillion(this, (UErrorCode *)this);
              break;
            case 4612:
              uint64_t result = icu::MeasureUnit::createPercent(this, (UErrorCode *)this);
              break;
            case 4613:
              uint64_t result = icu::MeasureUnit::createPermille(this, (UErrorCode *)this);
              break;
            case 4614:
              uint64_t result = icu::MeasureUnit::createPermyriad(this, (UErrorCode *)this);
              break;
            case 4615:
              uint64_t result = icu::MeasureUnit::createMole(this, (UErrorCode *)this);
              break;
            case 4616:
              uint64_t result = icu::MeasureUnit::createItem(this, (UErrorCode *)this);
              break;
            default:
              if (a1 != 4864) {
                goto LABEL_121;
              }
              uint64_t result = icu::MeasureUnit::createNewton(this, (UErrorCode *)this);
              break;
          }
        }

        else if (a1 <= 5120)
        {
          switch(a1)
          {
            case 4865:
              return icu::MeasureUnit::createPoundForce(this, (UErrorCode *)this);
            case 4866:
              return icu::MeasureUnit::createKilowattHourPer100Kilometer(this, (UErrorCode *)this);
            case 5120:
              return icu::MeasureUnit::createNewtonMeter(this, (UErrorCode *)this);
            default:
LABEL_121:
              *(_DWORD *)this = 1;
              return 0LL;
          }
        }

        else
        {
          switch(a1)
          {
            case 5376:
              uint64_t result = icu::MeasureUnit::createEm(this, (UErrorCode *)this);
              break;
            case 5377:
              uint64_t result = icu::MeasureUnit::createPixel(this, (UErrorCode *)this);
              break;
            case 5378:
              uint64_t result = icu::MeasureUnit::createMegapixel(this, (UErrorCode *)this);
              break;
            case 5379:
              uint64_t result = icu::MeasureUnit::createPixelPerCentimeter(this, (UErrorCode *)this);
              break;
            case 5380:
              uint64_t result = icu::MeasureUnit::createPixelPerInch(this, (UErrorCode *)this);
              break;
            case 5381:
              uint64_t result = icu::MeasureUnit::createDotPerCentimeter(this, (UErrorCode *)this);
              break;
            case 5382:
              uint64_t result = icu::MeasureUnit::createDotPerInch(this, (UErrorCode *)this);
              break;
            case 5383:
              uint64_t result = icu::MeasureUnit::createDot(this, (UErrorCode *)this);
              break;
            default:
              if (a1 != 5121) {
                goto LABEL_121;
              }
              uint64_t result = icu::MeasureUnit::createPoundFoot(this, (UErrorCode *)this);
              break;
          }
        }
      }

      else if (a1 <= 3839)
      {
        switch(a1)
        {
          case 3584:
            uint64_t result = icu::MeasureUnit::createBit(this, (UErrorCode *)this);
            break;
          case 3585:
            uint64_t result = icu::MeasureUnit::createByte(this, (UErrorCode *)this);
            break;
          case 3586:
            uint64_t result = icu::MeasureUnit::createGigabit(this, (UErrorCode *)this);
            break;
          case 3587:
            uint64_t result = icu::MeasureUnit::createGigabyte(this, (UErrorCode *)this);
            break;
          case 3588:
            uint64_t result = icu::MeasureUnit::createKilobit(this, (UErrorCode *)this);
            break;
          case 3589:
            uint64_t result = icu::MeasureUnit::createKilobyte(this, (UErrorCode *)this);
            break;
          case 3590:
            uint64_t result = icu::MeasureUnit::createMegabit(this, (UErrorCode *)this);
            break;
          case 3591:
            uint64_t result = icu::MeasureUnit::createMegabyte(this, (UErrorCode *)this);
            break;
          case 3592:
            uint64_t result = icu::MeasureUnit::createTerabit(this, (UErrorCode *)this);
            break;
          case 3593:
            uint64_t result = icu::MeasureUnit::createTerabyte(this, (UErrorCode *)this);
            break;
          case 3594:
            uint64_t result = icu::MeasureUnit::createPetabyte(this, (UErrorCode *)this);
            break;
          default:
            goto LABEL_121;
        }
      }

      else
      {
        switch(a1)
        {
          case 3840:
            uint64_t result = icu::MeasureUnit::createAmpere(this, (UErrorCode *)this);
            break;
          case 3841:
            uint64_t result = icu::MeasureUnit::createMilliampere(this, (UErrorCode *)this);
            break;
          case 3842:
            uint64_t result = icu::MeasureUnit::createOhm(this, (UErrorCode *)this);
            break;
          case 3843:
            uint64_t result = icu::MeasureUnit::createVolt(this, (UErrorCode *)this);
            break;
          default:
            switch(a1)
            {
              case 4096:
                uint64_t result = icu::MeasureUnit::createHertz(this, (UErrorCode *)this);
                break;
              case 4097:
                uint64_t result = icu::MeasureUnit::createKilohertz(this, (UErrorCode *)this);
                break;
              case 4098:
                uint64_t result = icu::MeasureUnit::createMegahertz(this, (UErrorCode *)this);
                break;
              case 4099:
                uint64_t result = icu::MeasureUnit::createGigahertz(this, (UErrorCode *)this);
                break;
              default:
                switch(a1)
                {
                  case 4352:
                    uint64_t result = icu::MeasureUnit::createLux(this, (UErrorCode *)this);
                    break;
                  case 4353:
                    uint64_t result = icu::MeasureUnit::createSolarLuminosity(this, (UErrorCode *)this);
                    break;
                  case 4354:
                    uint64_t result = icu::MeasureUnit::createCandela(this, (UErrorCode *)this);
                    break;
                  case 4355:
                    uint64_t result = icu::MeasureUnit::createLumen(this, (UErrorCode *)this);
                    break;
                  default:
                    goto LABEL_121;
                }

                break;
            }

            break;
        }
      }
    }

    else
    {
      switch(a1)
      {
        case 2816:
          uint64_t result = icu::MeasureUnit::createLiter(this, (UErrorCode *)this);
          break;
        case 2817:
          uint64_t result = icu::MeasureUnit::createCubicKilometer(this, (UErrorCode *)this);
          break;
        case 2818:
          uint64_t result = icu::MeasureUnit::createCubicMile(this, (UErrorCode *)this);
          break;
        case 2819:
          uint64_t result = icu::MeasureUnit::createMilliliter(this, (UErrorCode *)this);
          break;
        case 2820:
          uint64_t result = icu::MeasureUnit::createCentiliter(this, (UErrorCode *)this);
          break;
        case 2821:
          uint64_t result = icu::MeasureUnit::createDeciliter(this, (UErrorCode *)this);
          break;
        case 2822:
          uint64_t result = icu::MeasureUnit::createHectoliter(this, (UErrorCode *)this);
          break;
        case 2823:
          uint64_t result = icu::MeasureUnit::createMegaliter(this, (UErrorCode *)this);
          break;
        case 2824:
          uint64_t result = icu::MeasureUnit::createCubicCentimeter(this, (UErrorCode *)this);
          break;
        case 2825:
          uint64_t result = icu::MeasureUnit::createCubicMeter(this, (UErrorCode *)this);
          break;
        case 2826:
          uint64_t result = icu::MeasureUnit::createCubicInch(this, (UErrorCode *)this);
          break;
        case 2827:
          uint64_t result = icu::MeasureUnit::createCubicFoot(this, (UErrorCode *)this);
          break;
        case 2828:
          uint64_t result = icu::MeasureUnit::createCubicYard(this, (UErrorCode *)this);
          break;
        case 2829:
          uint64_t result = icu::MeasureUnit::createAcreFoot(this, (UErrorCode *)this);
          break;
        case 2830:
          uint64_t result = icu::MeasureUnit::createBushel(this, (UErrorCode *)this);
          break;
        case 2831:
          uint64_t result = icu::MeasureUnit::createTeaspoon(this, (UErrorCode *)this);
          break;
        case 2832:
          uint64_t result = icu::MeasureUnit::createTablespoon(this, (UErrorCode *)this);
          break;
        case 2833:
          uint64_t result = icu::MeasureUnit::createFluidOunce(this, (UErrorCode *)this);
          break;
        case 2834:
          uint64_t result = icu::MeasureUnit::createCup(this, (UErrorCode *)this);
          break;
        case 2835:
          uint64_t result = icu::MeasureUnit::createPint(this, (UErrorCode *)this);
          break;
        case 2836:
          uint64_t result = icu::MeasureUnit::createQuart(this, (UErrorCode *)this);
          break;
        case 2837:
          uint64_t result = icu::MeasureUnit::createGallon(this, (UErrorCode *)this);
          break;
        case 2838:
          uint64_t result = icu::MeasureUnit::createCupMetric(this, (UErrorCode *)this);
          break;
        case 2839:
          uint64_t result = icu::MeasureUnit::createPintMetric(this, (UErrorCode *)this);
          break;
        case 2840:
          uint64_t result = icu::MeasureUnit::createGallonImperial(this, (UErrorCode *)this);
          break;
        case 2841:
          uint64_t result = icu::MeasureUnit::createFluidOunceImperial(this, (UErrorCode *)this);
          break;
        case 2842:
          uint64_t result = icu::MeasureUnit::createBarrel(this, (UErrorCode *)this);
          break;
        case 2843:
          uint64_t result = icu::MeasureUnit::createDessertSpoon(this, (UErrorCode *)this);
          break;
        case 2844:
          uint64_t result = icu::MeasureUnit::createDessertSpoonImperial(this, (UErrorCode *)this);
          break;
        case 2845:
          uint64_t result = icu::MeasureUnit::createDram(this, (UErrorCode *)this);
          break;
        case 2846:
          uint64_t result = icu::MeasureUnit::createDrop(this, (UErrorCode *)this);
          break;
        case 2847:
          uint64_t result = icu::MeasureUnit::createJigger(this, (UErrorCode *)this);
          break;
        case 2848:
          uint64_t result = icu::MeasureUnit::createPinch(this, (UErrorCode *)this);
          break;
        case 2849:
          uint64_t result = icu::MeasureUnit::createQuartImperial(this, (UErrorCode *)this);
          break;
        default:
          switch(a1)
          {
            case 3072:
              uint64_t result = icu::MeasureUnit::createCalorie(this, (UErrorCode *)this);
              break;
            case 3073:
              uint64_t result = icu::MeasureUnit::createFoodcalorie(this, (UErrorCode *)this);
              break;
            case 3074:
              uint64_t result = icu::MeasureUnit::createJoule(this, (UErrorCode *)this);
              break;
            case 3075:
              uint64_t result = icu::MeasureUnit::createKilocalorie(this, (UErrorCode *)this);
              break;
            case 3076:
              uint64_t result = icu::MeasureUnit::createKilojoule(this, (UErrorCode *)this);
              break;
            case 3077:
              uint64_t result = icu::MeasureUnit::createKilowattHour(this, (UErrorCode *)this);
              break;
            case 3078:
              uint64_t result = icu::MeasureUnit::createElectronvolt(this, (UErrorCode *)this);
              break;
            case 3079:
              uint64_t result = icu::MeasureUnit::createBritishThermalUnit(this, (UErrorCode *)this);
              break;
            case 3080:
              uint64_t result = icu::MeasureUnit::createThermUs(this, (UErrorCode *)this);
              break;
            default:
              switch(a1)
              {
                case 3328:
                  uint64_t result = icu::MeasureUnit::createLiterPerKilometer(this, (UErrorCode *)this);
                  break;
                case 3329:
                  uint64_t result = icu::MeasureUnit::createMilePerGallon(this, (UErrorCode *)this);
                  break;
                case 3330:
                  uint64_t result = icu::MeasureUnit::createLiterPer100Kilometers(this, (UErrorCode *)this);
                  break;
                case 3331:
                  uint64_t result = icu::MeasureUnit::createMilePerGallonImperial(this, (UErrorCode *)this);
                  break;
                default:
                  goto LABEL_121;
              }

              break;
          }

          break;
      }
    }
  }

  else if (a1 > 1535)
  {
    if (a1 > 2047)
    {
      switch(a1)
      {
        case 2048:
          uint64_t result = icu::MeasureUnit::createHectopascal(this, (UErrorCode *)this);
          break;
        case 2049:
          uint64_t result = icu::MeasureUnit::createInchHg(this, (UErrorCode *)this);
          break;
        case 2050:
          uint64_t result = icu::MeasureUnit::createMillibar(this, (UErrorCode *)this);
          break;
        case 2051:
          uint64_t result = icu::MeasureUnit::createMillimeterOfMercury(this, (UErrorCode *)this);
          break;
        case 2052:
          uint64_t result = icu::MeasureUnit::createPoundPerSquareInch(this, (UErrorCode *)this);
          break;
        case 2053:
          uint64_t result = icu::MeasureUnit::createAtmosphere(this, (UErrorCode *)this);
          break;
        case 2054:
          uint64_t result = icu::MeasureUnit::createKilopascal(this, (UErrorCode *)this);
          break;
        case 2055:
          uint64_t result = icu::MeasureUnit::createMegapascal(this, (UErrorCode *)this);
          break;
        case 2056:
          uint64_t result = icu::MeasureUnit::createPascal(this, (UErrorCode *)this);
          break;
        case 2057:
          uint64_t result = icu::MeasureUnit::createBar(this, (UErrorCode *)this);
          break;
        default:
          switch(a1)
          {
            case 2304:
              uint64_t result = icu::MeasureUnit::createMeterPerSecond(this, (UErrorCode *)this);
              break;
            case 2305:
              uint64_t result = icu::MeasureUnit::createKilometerPerHour(this, (UErrorCode *)this);
              break;
            case 2306:
              uint64_t result = icu::MeasureUnit::createMilePerHour(this, (UErrorCode *)this);
              break;
            case 2307:
              uint64_t result = icu::MeasureUnit::createKnot(this, (UErrorCode *)this);
              break;
            case 2308:
              uint64_t result = icu::MeasureUnit::createBeaufort(this, (UErrorCode *)this);
              break;
            default:
              switch(a1)
              {
                case 2560:
                  uint64_t result = icu::MeasureUnit::createCelsius(this, (UErrorCode *)this);
                  break;
                case 2561:
                  uint64_t result = icu::MeasureUnit::createFahrenheit(this, (UErrorCode *)this);
                  break;
                case 2562:
                  uint64_t result = icu::MeasureUnit::createKelvin(this, (UErrorCode *)this);
                  break;
                case 2563:
                  uint64_t result = icu::MeasureUnit::createGenericTemperature(this, (UErrorCode *)this);
                  break;
                default:
                  goto LABEL_121;
              }

              break;
          }

          break;
      }
    }

    else
    {
      switch(a1)
      {
        case 1536:
          uint64_t result = icu::MeasureUnit::createGram(this, (UErrorCode *)this);
          break;
        case 1537:
          uint64_t result = icu::MeasureUnit::createKilogram(this, (UErrorCode *)this);
          break;
        case 1538:
          uint64_t result = icu::MeasureUnit::createOunce(this, (UErrorCode *)this);
          break;
        case 1539:
          uint64_t result = icu::MeasureUnit::createPound(this, (UErrorCode *)this);
          break;
        case 1540:
          uint64_t result = icu::MeasureUnit::createStone(this, (UErrorCode *)this);
          break;
        case 1541:
          uint64_t result = icu::MeasureUnit::createMicrogram(this, (UErrorCode *)this);
          break;
        case 1542:
          uint64_t result = icu::MeasureUnit::createMilligram(this, (UErrorCode *)this);
          break;
        case 1543:
          uint64_t result = icu::MeasureUnit::createTonne(this, (UErrorCode *)this);
          break;
        case 1544:
          uint64_t result = icu::MeasureUnit::createTon(this, (UErrorCode *)this);
          break;
        case 1545:
          uint64_t result = icu::MeasureUnit::createCarat(this, (UErrorCode *)this);
          break;
        case 1546:
          uint64_t result = icu::MeasureUnit::createOunceTroy(this, (UErrorCode *)this);
          break;
        case 1547:
          uint64_t result = icu::MeasureUnit::createDalton(this, (UErrorCode *)this);
          break;
        case 1548:
          uint64_t result = icu::MeasureUnit::createEarthMass(this, (UErrorCode *)this);
          break;
        case 1549:
          uint64_t result = icu::MeasureUnit::createSolarMass(this, (UErrorCode *)this);
          break;
        case 1550:
          uint64_t result = icu::MeasureUnit::createGrain(this, (UErrorCode *)this);
          break;
        default:
          switch(a1)
          {
            case 1792:
              uint64_t result = icu::MeasureUnit::createWatt(this, (UErrorCode *)this);
              break;
            case 1793:
              uint64_t result = icu::MeasureUnit::createKilowatt(this, (UErrorCode *)this);
              break;
            case 1794:
              uint64_t result = icu::MeasureUnit::createHorsepower(this, (UErrorCode *)this);
              break;
            case 1795:
              uint64_t result = icu::MeasureUnit::createMilliwatt(this, (UErrorCode *)this);
              break;
            case 1796:
              uint64_t result = icu::MeasureUnit::createMegawatt(this, (UErrorCode *)this);
              break;
            case 1797:
              uint64_t result = icu::MeasureUnit::createGigawatt(this, (UErrorCode *)this);
              break;
            default:
              goto LABEL_121;
          }

          break;
      }
    }
  }

  else if (a1 > 1279)
  {
    switch(a1)
    {
      case 1280:
        uint64_t result = icu::MeasureUnit::createMeter(this, (UErrorCode *)this);
        break;
      case 1281:
        uint64_t result = icu::MeasureUnit::createCentimeter(this, (UErrorCode *)this);
        break;
      case 1282:
        uint64_t result = icu::MeasureUnit::createKilometer(this, (UErrorCode *)this);
        break;
      case 1283:
        uint64_t result = icu::MeasureUnit::createMillimeter(this, (UErrorCode *)this);
        break;
      case 1284:
        uint64_t result = icu::MeasureUnit::createPicometer(this, (UErrorCode *)this);
        break;
      case 1285:
        uint64_t result = icu::MeasureUnit::createFoot(this, (UErrorCode *)this);
        break;
      case 1286:
        uint64_t result = icu::MeasureUnit::createInch(this, (UErrorCode *)this);
        break;
      case 1287:
        uint64_t result = icu::MeasureUnit::createMile(this, (UErrorCode *)this);
        break;
      case 1288:
        uint64_t result = icu::MeasureUnit::createYard(this, (UErrorCode *)this);
        break;
      case 1289:
        uint64_t result = icu::MeasureUnit::createLightYear(this, (UErrorCode *)this);
        break;
      case 1290:
        uint64_t result = icu::MeasureUnit::createDecimeter(this, (UErrorCode *)this);
        break;
      case 1291:
        uint64_t result = icu::MeasureUnit::createMicrometer(this, (UErrorCode *)this);
        break;
      case 1292:
        uint64_t result = icu::MeasureUnit::createNanometer(this, (UErrorCode *)this);
        break;
      case 1293:
        uint64_t result = icu::MeasureUnit::createNauticalMile(this, (UErrorCode *)this);
        break;
      case 1294:
        uint64_t result = icu::MeasureUnit::createFathom(this, (UErrorCode *)this);
        break;
      case 1295:
        uint64_t result = icu::MeasureUnit::createFurlong(this, (UErrorCode *)this);
        break;
      case 1296:
        uint64_t result = icu::MeasureUnit::createAstronomicalUnit(this, (UErrorCode *)this);
        break;
      case 1297:
        uint64_t result = icu::MeasureUnit::createParsec(this, (UErrorCode *)this);
        break;
      case 1298:
        uint64_t result = icu::MeasureUnit::createMileScandinavian(this, (UErrorCode *)this);
        break;
      case 1299:
        uint64_t result = icu::MeasureUnit::createPoint(this, (UErrorCode *)this);
        break;
      case 1300:
        uint64_t result = icu::MeasureUnit::createSolarRadius(this, (UErrorCode *)this);
        break;
      case 1301:
        uint64_t result = icu::MeasureUnit::createEarthRadius(this, (UErrorCode *)this);
        break;
      default:
        goto LABEL_121;
    }
  }

  else if (a1 > 1023)
  {
    switch(a1)
    {
      case 1024:
        uint64_t result = icu::MeasureUnit::createYear(this, (UErrorCode *)this);
        break;
      case 1025:
        uint64_t result = icu::MeasureUnit::createMonth(this, (UErrorCode *)this);
        break;
      case 1026:
        uint64_t result = icu::MeasureUnit::createWeek(this, (UErrorCode *)this);
        break;
      case 1027:
        uint64_t result = icu::MeasureUnit::createDay(this, (UErrorCode *)this);
        break;
      case 1028:
        uint64_t result = icu::MeasureUnit::createHour(this, (UErrorCode *)this);
        break;
      case 1029:
        uint64_t result = icu::MeasureUnit::createMinute(this, (UErrorCode *)this);
        break;
      case 1030:
        uint64_t result = icu::MeasureUnit::createSecond(this, (UErrorCode *)this);
        break;
      case 1031:
        uint64_t result = icu::MeasureUnit::createMillisecond(this, (UErrorCode *)this);
        break;
      case 1032:
        uint64_t result = icu::MeasureUnit::createMicrosecond(this, (UErrorCode *)this);
        break;
      case 1033:
        uint64_t result = icu::MeasureUnit::createNanosecond(this, (UErrorCode *)this);
        break;
      case 1034:
        uint64_t result = icu::MeasureUnit::createCentury(this, (UErrorCode *)this);
        break;
      case 1035:
        uint64_t result = icu::MeasureUnit::createYearPerson(this, (UErrorCode *)this);
        break;
      case 1036:
        uint64_t result = icu::MeasureUnit::createMonthPerson(this, (UErrorCode *)this);
        break;
      case 1037:
        uint64_t result = icu::MeasureUnit::createWeekPerson(this, (UErrorCode *)this);
        break;
      case 1038:
        uint64_t result = icu::MeasureUnit::createDayPerson(this, (UErrorCode *)this);
        break;
      case 1039:
        uint64_t result = icu::MeasureUnit::createDecade(this, (UErrorCode *)this);
        break;
      case 1040:
        uint64_t result = icu::MeasureUnit::createQuarter(this, (UErrorCode *)this);
        break;
      default:
        goto LABEL_121;
    }
  }

  else if (a1 <= 511)
  {
    switch(a1)
    {
      case 256:
        uint64_t result = icu::MeasureUnit::createDegree(this, (UErrorCode *)this);
        break;
      case 257:
        uint64_t result = icu::MeasureUnit::createArcMinute(this, (UErrorCode *)this);
        break;
      case 258:
        uint64_t result = icu::MeasureUnit::createArcSecond(this, (UErrorCode *)this);
        break;
      case 259:
        uint64_t result = icu::MeasureUnit::createRadian(this, (UErrorCode *)this);
        break;
      case 260:
        uint64_t result = icu::MeasureUnit::createRevolutionAngle(this, (UErrorCode *)this);
        break;
      default:
        if (a1)
        {
          if (a1 != 1) {
            goto LABEL_121;
          }
          uint64_t result = icu::MeasureUnit::createMeterPerSecondSquared(this, (UErrorCode *)this);
        }

        else
        {
          uint64_t result = icu::MeasureUnit::createGForce(this, (UErrorCode *)this);
        }

        break;
    }
  }

  else
  {
    switch(a1)
    {
      case 512:
        uint64_t result = icu::MeasureUnit::createSquareMeter(this, (UErrorCode *)this);
        break;
      case 513:
        uint64_t result = icu::MeasureUnit::createSquareKilometer(this, (UErrorCode *)this);
        break;
      case 514:
        uint64_t result = icu::MeasureUnit::createSquareFoot(this, (UErrorCode *)this);
        break;
      case 515:
        uint64_t result = icu::MeasureUnit::createSquareMile(this, (UErrorCode *)this);
        break;
      case 516:
        uint64_t result = icu::MeasureUnit::createAcre(this, (UErrorCode *)this);
        break;
      case 517:
        uint64_t result = icu::MeasureUnit::createHectare(this, (UErrorCode *)this);
        break;
      case 518:
        uint64_t result = icu::MeasureUnit::createSquareCentimeter(this, (UErrorCode *)this);
        break;
      case 519:
        uint64_t result = icu::MeasureUnit::createSquareInch(this, (UErrorCode *)this);
        break;
      case 520:
        uint64_t result = icu::MeasureUnit::createSquareYard(this, (UErrorCode *)this);
        break;
      case 521:
        uint64_t result = icu::MeasureUnit::createDunam(this, (UErrorCode *)this);
        break;
      default:
        goto LABEL_121;
    }
  }

  return result;
}

uint64_t icu::MeasureUnit::getUAMeasureUnit(icu::MeasureUnit *this)
{
  uint64_t v1 = *((unsigned __int8 *)this + 18);
  int v2 = dword_180A39CBC[v1] + *((unsigned __int16 *)this + 8);
  if (v2 < 0) {
    return 0xFFFFFFFFLL;
  }
  int v3 = v1 <= 5 ? dword_180A39CBC[v1] + *((unsigned __int16 *)this + 8) : v2 - 301;
  if (v3 > 190) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dword_180A39D1C[v3];
  }
}

uint64_t icu::MeasureUnit::getUAMeasureUnits(icu::MeasureUnit *a1, _DWORD *a2, uint64_t a3, UErrorCode *a4)
{
  LODWORD(v5) = a3;
  if (icu::MeasureUnit::getComplexity(a1, a4, a3, a4) == 2)
  {
    int v13 = 0LL;
    int v14 = 0;
    icu::MeasureUnit::splitToSingleUnitsImpl(a1, &v14, a4, v8, &v13);
    uint64_t v9 = v13;
    v12[0] = (uint64_t)v13;
    int v13 = 0LL;
    uint64_t v10 = v14;
    v12[1] = v14;
    sub_18090BD34((uint64_t *)&v13);
    else {
      uint64_t v5 = v5;
    }
    if ((int)v5 >= 1)
    {
      do
      {
        *a2++ = icu::MeasureUnit::getUAMeasureUnit(v9);
        uint64_t v9 = (icu::MeasureUnit *)((char *)v9 + 24);
        --v5;
      }

      while (v5);
    }

    sub_18090BD34(v12);
  }

  else
  {
    return 1LL;
  }

  return v10;
}

uint64_t sub_18090BCB4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 20) = *(_BYTE *)(a2 + 20);
  char v4 = *(const void **)(a2 + 8);
  if (v4 == (const void *)(a2 + 24))
  {
    *(void *)(a1 + 8) = a1 + 24;
    memcpy((void *)(a1 + 24), v4, 8LL * *(int *)(a2 + 16));
  }

  else
  {
    *(void *)(a2 + 8) = a2 + 24;
    *(_DWORD *)(a2 + 16) = 8;
    *(_BYTE *)(a2 + 20) = 0;
  }

  *(_DWORD *)a2 = 0;
  return a1;
}

uint64_t *sub_18090BD34(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    int v3 = (void *)(v2 - 16);
    uint64_t v4 = *(void *)(v2 - 8);
    if (v4)
    {
      uint64_t v5 = v2 - 24;
      uint64_t v6 = 24 * v4;
      do
      {
        icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)(v5 + v6));
        v6 -= 24LL;
      }

      while (v6);
    }

    icu::UMemory::operator delete[](v3);
  }

  return a1;
}

uint64_t *sub_18090BD94(const void **a1, unint64_t a2)
{
  int v4 = *((_DWORD *)a1 + 4);
  uint64_t v5 = *(unsigned int *)a1;
  if ((_DWORD)v5 == v4)
  {
    if (v4 == 8) {
      int v6 = 32;
    }
    else {
      int v6 = 2 * v4;
    }
    if (v6 < 1) {
      return 0LL;
    }
    uint64_t result = (uint64_t *)uprv_malloc(8LL * v6);
    if (!result) {
      return result;
    }
    unint64_t v8 = result;
    if (v4 >= 1)
    {
      int v9 = *((_DWORD *)a1 + 4);
      if (v9 >= v4) {
        int v9 = v4;
      }
      if (v9 >= v6) {
        int v9 = v6;
      }
      memcpy(result, a1[1], 8LL * v9);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v8;
    *((_DWORD *)a1 + 4) = v6;
    uint64_t v5 = 1LL;
    *((_BYTE *)a1 + 20) = 1;
  }

  uint64_t result = icu::UMemory::operator new((uint64_t *)v5, (icu::UMemory *)0xC, a2);
  if (result)
  {
    uint64_t v10 = *(void *)a2;
    *((_DWORD *)result + 2) = *(_DWORD *)(a2 + 8);
    *uint64_t result = v10;
  }

  uint64_t v11 = *(int *)a1;
  *(_DWORD *)a1 = v11 + 1;
  *((void *)a1[1] + v1sub_1808F7164((uint64_t)v14, 1) = result;
  return result;
}

uint64_t umeas_getPrefixPower(int a1)
{
  else {
    int v1 = 60;
  }
  return (v1 + a1);
}

uint64_t umeas_getPrefixBase(int a1)
{
  else {
    return 1024LL;
  }
}

uint64_t icu::getUnitQuantity@<X0>(icu *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = a3 + 13;
  *(_DWORD *)(a3 + 8) = 40;
  *(_DWORD *)(a3 + 56) = 0;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 __s = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  icu::MeasureUnitImpl::copy(this, a2, (uint64_t)&v34);
  int v23 = 0;
  if (*(int *)a2 <= 0)
  {
    unsigned int v7 = atomic_load(&dword_18C535690);
    if (v7 == 2 || !icu::umtx_initImplPreInit(&dword_18C535690))
    {
      if (dword_18C535694 >= 1)
      {
        *a2 = dword_18C535694;
        goto LABEL_19;
      }
    }

    else
    {
      sub_18090C238((int *)a2);
      dword_18C535694 = *a2;
      icu::umtx_initImplPostInit(&dword_18C535690);
    }

    if (*(int *)a2 <= 0)
    {
      v22[0] = 0LL;
      v22[1] = (void *)qword_18C535668;
      void v22[2] = (void *)qword_18C535668;
      v22[3] = (void *)0xFFFFFFFFLL;
      icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)&v34, a2);
      uint64_t v20 = 0LL;
      uint64_t v21 = 0LL;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v20, (const char *)__s);
      int v8 = sub_18090CAD4((uint64_t)v22, v20, v21, &v23);
      if (v23 >= 1)
      {
        int v23 = 0;
        DWORD2(v43) = 0;
        *(_BYTE *)__int128 __s = 0;
        uint64_t v9 = DWORD2(v34);
        if (SDWORD2(v34) >= 1)
        {
          uint64_t v10 = (uint64_t *)v35;
          do
          {
            uint64_t v11 = *v10++;
            *(_DWORD *)(v11 + 8) = -*(_DWORD *)(v11 + 8);
            --v9;
          }

          while (v9);
        }

        icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)&v34, a2);
        icu::StringPiece::set((icu::StringPiece *)&v20, (const char *)__s);
        int v8 = sub_18090CAD4((uint64_t)v22, v20, v21, &v23);
      }

      int v12 = v8;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      __int128 v29 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v24 = 0u;
      icu::MeasureUnitImpl::copyAndSimplify((uint64_t)this, a2, (uint64_t)&v24);
      if (*(int *)a2 > 0)
      {
LABEL_15:
        if (BYTE12(v30)) {
          uprv_free((void *)v30);
        }
        sub_180850D68((uint64_t)&v24 + 8);
LABEL_18:
        icu::BytesTrie::~BytesTrie(v22);
        goto LABEL_19;
      }

      if (v23 >= 1)
      {
        int v23 = 0;
        icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)&v24, a2);
        icu::StringPiece::set((icu::StringPiece *)&v20, (const char *)v30);
        int v14 = sub_18090CAD4((uint64_t)v22, v20, v21, &v23);
        if (v23 >= 1)
        {
          int v23 = 0;
          DWORD2(v33) = 0;
          *(_BYTE *)__int128 v30 = 0;
          uint64_t v15 = DWORD2(v24);
          if (SDWORD2(v24) >= 1)
          {
            int v16 = (uint64_t *)v25;
            do
            {
              uint64_t v17 = *v16++;
              *(_DWORD *)(v17 + 8) = -*(_DWORD *)(v17 + 8);
              --v15;
            }

            while (v15);
          }

          icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)&v24, a2);
          icu::StringPiece::set((icu::StringPiece *)&v20, (const char *)v30);
          int v14 = sub_18090CAD4((uint64_t)v22, v20, v21, &v23);
          if (v23 >= 1)
          {
LABEL_34:
            *a2 = U_INVALID_FORMAT_ERROR;
            goto LABEL_15;
          }
        }

        int v12 = v14;
      }

      if ((v12 & 0x80000000) == 0 && v12 < dword_18C535670)
      {
        uint64_t v18 = *(UChar **)(qword_18C535678 + 8LL * v12);
        int32_t v19 = u_strlen(v18);
        icu::CharString::appendInvariantChars((int *)a3, v18, v19, a2);
        goto LABEL_15;
      }

      goto LABEL_34;
    }
  }

void sub_18090C238(int *a1)
{
  uint64_t v2 = ures_openDirect(0LL, (uint64_t)"units", (uint64_t)a1);
  uint64_t v3 = ures_getByKey(v2, "unitQuantities", 0LL, a1);
  uint64_t v4 = v3;
  if (*a1 > 0)
  {
    if (!v3) {
      goto LABEL_3;
    }
    goto LABEL_30;
  }

  dword_18C535670 = *(_DWORD *)(v3 + 128);
  size_t v5 = 8LL * dword_18C535670;
  int v6 = uprv_malloc(v5);
  qword_18C535678 = (uint64_t)v6;
  if (!v6)
  {
    *a1 = 7;
    goto LABEL_30;
  }

  bzero(v6, v5);
  uint64_t v73 = 0LL;
  memset(v72, 0, sizeof(v72));
  icu::BytesTrieBuilder::BytesTrieBuilder((icu::BytesTrieBuilder *)v72, (UErrorCode *)a1);
  v71[3] = v72;
  _OWORD v71[4] = 0LL;
  v71[0] = &off_1897268A0;
  v71[1] = qword_18C535678;
  _OWORD v71[2] = &dword_18C535670;
  ures_getAllItemsWithFallback(v2, "unitQuantities", (uint64_t)v71, a1);
  uint64_t v7 = icu::BytesTrieBuilder::buildStringPiece((uint64_t)v72, 0LL, a1);
  if (*a1 <= 0)
  {
    uint64_t v9 = (const void *)v7;
    uint64_t v10 = v8;
    size_t v11 = (int)v8;
    int v12 = uprv_malloc((int)v8);
    qword_18C535668 = (uint64_t)v12;
    if (!v12)
    {
      *a1 = 7;
      goto LABEL_29;
    }

    memcpy(v12, v9, v11);
    uint64_t v70 = 0LL;
    memset(v69, 0, sizeof(v69));
    icu::BytesTrieBuilder::BytesTrieBuilder((icu::BytesTrieBuilder *)v69, (UErrorCode *)a1);
    if (*a1 > 0) {
      goto LABEL_28;
    }
    int v13 = &off_1897266D0;
    do
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v67, *v13);
      icu::BytesTrieBuilder::add((uint64_t)v69, v67, v68, *((_DWORD *)v13 + 2) + 64, (UErrorCode *)a1);
      v13 += 2;
    }

    while (v13 != (char **)&unk_189726890);
    if (*a1 >= 1) {
      goto LABEL_28;
    }
    icu::StringPiece::StringPiece((icu::StringPiece *)&v65, "-per-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v65, v66, 128, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v63, "-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v63, v64, 129, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v61, "-and-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v61, v62, 130, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v59, "per-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v59, v60, 192, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v57, "square-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v57, v58, 258, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v55, "cubic-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v55, v56, 259, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v53, "pow2-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v53, v54, 258, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v51, "pow3-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v51, v52, 259, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v49, "pow4-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v49, v50, 260, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v47, "pow5-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v47, v48, 261, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v45, "pow6-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v45, v46, 262, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v43, "pow7-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v43, v44, 263, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v41, "pow8-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v41, v42, 264, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v39, "pow9-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v39, v40, 265, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v37, "pow10-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v37, v38, 266, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v35, "pow11-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v35, v36, 267, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v33, "pow12-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v33, v34, 268, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v31, "pow13-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v31, v32, 269, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v29, "pow14-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v29, v30, 270, (UErrorCode *)a1);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v27, "pow15-");
    icu::BytesTrieBuilder::add((uint64_t)v69, v27, v28, 271, (UErrorCode *)a1);
    if (*a1 > 0) {
      goto LABEL_28;
    }
    uint64_t v14 = ures_getByKey(v2, "convertUnits", 0LL, a1);
    uint64_t v15 = v14;
    if (*a1 <= 0)
    {
      unsigned int v16 = *(_DWORD *)(v14 + 128);
      uint64_t v17 = uprv_malloc((int)(8 * v16));
      qword_18C535680 = (uint64_t)v17;
      if (v17 && (bzero(v17, (int)(8 * v16)), uint64_t v18 = uprv_malloc((int)(4 * v16)), (qword_18C535688 = (uint64_t)v18) != 0))
      {
        int32_t v19 = v18;
        bzero(v18, (int)(4 * v16));
        v25[5] = 512LL;
        __int128 v26 = 0u;
        v25[0] = &off_1897268E8;
        v25[1] = qword_18C535680;
        v25[2] = v19;
        v25[3] = v16;
        _OWORD v25[4] = v69;
        v25[6] = v9;
        *(void *)&__int128 v26 = v10;
        ures_getAllItemsWithFallback(v2, "convertUnits", (uint64_t)v25, a1);
        uint64_t v20 = icu::BytesTrieBuilder::buildStringPiece((uint64_t)v69, 0LL, a1);
        if (*a1 <= 0)
        {
          int v22 = (const void *)v20;
          size_t v23 = v21;
          __int128 v24 = uprv_malloc(v21);
          qword_18C535698 = (uint64_t)v24;
          if (v24) {
            memcpy(v24, v22, v23);
          }
          else {
            *a1 = 7;
          }
        }

        icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v25);
      }

      else
      {
        *a1 = 7;
      }
    }

    else if (!v14)
    {
      goto LABEL_28;
    }

    ures_close(v15);
LABEL_28:
    icu::BytesTrieBuilder::~BytesTrieBuilder((icu::BytesTrieBuilder *)v69);
  }

void icu::MeasureUnitImpl::serialize(icu::MeasureUnitImpl *this, UErrorCode *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    uint64_t v4 = *((unsigned int *)this + 2);
    if ((_DWORD)v4)
    {
      if (*(_DWORD *)this == 1)
      {
        uprv_sortArray( *((void *)this + 2),  v4,  8,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18090D890,  0LL,  0,  (int *)a2);
        LODWORD(v4) = *((_DWORD *)this + 2);
      }

      memset(&v22[1], 0, 48);
      size_t v5 = (char *)&v22[1] + 5;
      v22[0] = (char *)&v22[1] + 5;
      LODWORD(v22[1]) = 40;
      uint64_t v23 = 0LL;
      if ((int)v4 >= 1)
      {
        uint64_t v6 = 0LL;
        LOBYTE(v7) = 0;
        char v8 = 1;
        while (1)
        {
          int v9 = *(_DWORD *)(*(void *)(*((void *)this + 2) + 8 * v6) + 8LL);
          if ((v8 & 1) != 0 && v9 < 0)
          {
            char v8 = 0;
            int v7 = 1;
          }

          else
          {
            int v7 = (v9 >= 0) & v7;
          }

          if (*(_DWORD *)this == 2)
          {
            if ((_DWORD)v23)
            {
              uint64_t v10 = v17;
              size_t v11 = (icu::StringPiece *)v17;
              int v12 = "-and-";
LABEL_23:
              icu::StringPiece::StringPiece(v11, v12);
              icu::CharString::append((icu::CharString *)v22, *(const char **)v10, *((_DWORD *)v10 + 2), a2);
            }
          }

          else
          {
            if (v7)
            {
              if ((_DWORD)v23)
              {
                uint64_t v10 = v15;
                size_t v11 = (icu::StringPiece *)v15;
                int v12 = "-per-";
              }

              else
              {
                uint64_t v10 = v16;
                size_t v11 = (icu::StringPiece *)v16;
                int v12 = "per-";
              }

              goto LABEL_23;
            }

            if ((_DWORD)v23)
            {
              uint64_t v10 = v14;
              size_t v11 = (icu::StringPiece *)v14;
              int v12 = "-";
              goto LABEL_23;
            }
          }

          icu::SingleUnitImpl::appendNeutralIdentifier( *(icu::CharString **)(*((void *)this + 2) + 8 * v6++),  (icu::CharString *)v22,  a2);
          if (v6 >= *((int *)this + 2))
          {
            size_t v5 = v22[0];
            int v13 = v23;
            goto LABEL_27;
          }
        }
      }

      int v13 = 0;
LABEL_27:
      uint64_t v18 = (char *)&v20 + 1;
      int v19 = 40;
      __int16 v20 = 0;
      int v21 = 0;
      icu::CharString::append((icu::CharString *)&v18, v5, v13, a2);
      icu::CharString::operator=((uint64_t)this + 96, (uint64_t)&v18);
      if ((_BYTE)v20) {
        uprv_free(v18);
      }
LABEL_29:
      if (BYTE4(v22[1])) {
        uprv_free(v22[0]);
      }
    }
  }

uint64_t sub_18090CAD4(uint64_t a1, const char *a2, int a3, _DWORD *a4)
{
  *(void *)(a1 + 16) = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 24) = -1;
  if ((int)icu::BytesTrie::next((icu::BytesTrie *)a1, a2, a3) > 1) {
    return icu::BytesTrie::readValue( (icu::BytesTrie *)(*(void *)(a1 + 16) + 1LL),  (const unsigned __int8 *)(**(unsigned __int8 **)(a1 + 16) >> 1));
  }
  *a4 = 16;
  return 0xFFFFFFFFLL;
}

uint64_t icu::MeasureUnitImpl::takeReciprocal(uint64_t this, UErrorCode *a2)
{
  *(_DWORD *)(this + 152) = 0;
  **(_BYTE **)(this + 96) = 0;
  uint64_t v2 = *(unsigned int *)(this + 8);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = *(uint64_t **)(this + 16);
    do
    {
      uint64_t v4 = *v3++;
      *(_DWORD *)(v4 + 8) = -*(_DWORD *)(v4 + 8);
      --v2;
    }

    while (v2);
  }

  return this;
}

uint64_t icu::MeasureUnitImpl::copyAndSimplify@<X0>(uint64_t this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(void *)(a3 + 16) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 8;
  *(void *)(a3 + 96) = a3 + 109;
  *(_DWORD *)(a3 + 104) = 40;
  *(_DWORD *)(a3 + 152) = 0;
  int v4 = *(_DWORD *)(this + 8);
  if (v4 >= 1)
  {
    uint64_t v5 = this;
    for (uint64_t i = 0LL; i < v4; ++i)
    {
      int v7 = *(const icu::SingleUnitImpl **)(*(void *)(v5 + 16) + 8 * i);
      uint64_t v8 = *(unsigned int *)(a3 + 8);
      if ((int)v8 < 1)
      {
LABEL_8:
        this = icu::MeasureUnitImpl::appendSingleUnit((icu::MeasureUnitImpl *)a3, v7, a2);
        int v4 = *(_DWORD *)(v5 + 8);
      }

      else
      {
        int v9 = *(int ***)(a3 + 16);
        uint64_t v10 = qword_18C535680;
        size_t v11 = *(const char **)(qword_18C535680 + 8LL * *(int *)v7);
        while (1)
        {
          uint64_t v12 = (uint64_t)*v9;
          this = strcmp(*(const char **)(v10 + 8LL * **v9), v11);
          if (!(_DWORD)this && *(_DWORD *)(v12 + 4) == *((_DWORD *)v7 + 1)) {
            break;
          }
          ++v9;
          if (!--v8) {
            goto LABEL_8;
          }
        }

        *(_DWORD *)(v12 + 8) += *((_DWORD *)v7 + 2);
      }
    }
  }

  return this;
}

unint64_t icu::SingleUnitImpl::forMeasureUnit( icu::SingleUnitImpl *this, const icu::MeasureUnit *a2, UErrorCode *a3, UErrorCode *a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v17 = 0u;
  memset(v14, 0, sizeof(v14));
  __int128 v11 = 0u;
  uint64_t v12 = v14;
  uint64_t v13 = 8LL;
  uint64_t v15 = (char *)&v16 + 5;
  uint64_t v16 = 40LL;
  DWORD2(v19) = 0;
  uint64_t v5 = icu::MeasureUnitImpl::forMeasureUnit(this, (const icu::MeasureUnit *)&v11, a2, a4);
  if (*(int *)a2 > 0 || (int v9 = *((_DWORD *)v5 + 2)) == 0)
  {
    unint64_t v6 = 0x1E00000000LL;
LABEL_3:
    uint64_t v7 = 0xFFFFFFFFLL;
    goto LABEL_4;
  }

  if (v9 != 1)
  {
    *(_DWORD *)a2 = 1;
    unint64_t v6 = 0x1E00000000LL;
    goto LABEL_3;
  }

  uint64_t v10 = (void *)**((void **)v5 + 2);
  unint64_t v6 = *v10 & 0xFFFFFFFF00000000LL;
  uint64_t v7 = *v10;
LABEL_4:
  if (BYTE4(v16)) {
    uprv_free(v15);
  }
  sub_180850D68((uint64_t)&v11 + 8);
  return v6 | v7;
}

const icu::MeasureUnit *icu::MeasureUnitImpl::forMeasureUnit( icu::MeasureUnitImpl *this, const icu::MeasureUnit *a2, icu::MeasureUnitImpl *a3, UErrorCode *a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t result = (const icu::MeasureUnit *)*((void *)this + 1);
  if (!result)
  {
    Identifier = icu::MeasureUnit::getIdentifier(this);
    icu::StringPiece::StringPiece((icu::StringPiece *)v9, Identifier);
    sub_18090D380(v9[0], v9[1], (int *)a3, (uint64_t)v10);
    sub_18090D470((uint64_t)v10, (UErrorCode *)a3, (uint64_t)&v12);
    *(_DWORD *)a2 = v12;
    sub_18090E4BC((int *)a2 + 2, v13);
    icu::CharString::operator=((uint64_t)a2 + 96, (uint64_t)&v14);
    if (v15) {
      uprv_free(v14);
    }
    sub_180850D68((uint64_t)v13);
    icu::BytesTrie::~BytesTrie(&v11);
    return a2;
  }

  return result;
}

uint64_t icu::SingleUnitImpl::build@<X0>( icu::SingleUnitImpl *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v12 = 0u;
  memset(v9, 0, sizeof(v9));
  __int128 v6 = 0u;
  uint64_t v7 = v9;
  uint64_t v8 = 8LL;
  uint64_t v10 = (char *)&v11 + 5;
  uint64_t v11 = 40LL;
  DWORD2(v14) = 0;
  icu::MeasureUnitImpl::appendSingleUnit((icu::MeasureUnitImpl *)&v6, this, a2);
  icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)&v6, a2);
  icu::MeasureUnit::MeasureUnit(a3, &v6);
  if (BYTE4(v11)) {
    uprv_free(v10);
  }
  return sub_180850D68((uint64_t)&v6 + 8);
}

uint64_t icu::MeasureUnitImpl::appendSingleUnit( icu::MeasureUnitImpl *this, const icu::SingleUnitImpl *a2, UErrorCode *a3)
{
  *((_DWORD *)this + 38) = 0;
  **((_BYTE **)this + 12) = 0;
  if (*(_DWORD *)a2 == -1) {
    return 0LL;
  }
  __int128 v6 = (const void **)((char *)this + 8);
  if (*((int *)this + 2) >= 1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    do
    {
      int v9 = *(int **)(*((void *)this + 2) + 8 * v7);
      ++v7;
    }

    while (v7 < *((int *)this + 2));
    if (v8)
    {
      uint64_t result = 0LL;
      v8[2] += *((_DWORD *)a2 + 2);
      return result;
    }
  }

  uint64_t result = (uint64_t)sub_18090BD94(v6, (unint64_t)a2);
  if (*(int *)a3 <= 0 && !result)
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
    return result;
  }

  uint64_t result = 1LL;
  if (!*(_DWORD *)this) {
    *(_DWORD *)this = 1;
  }
  return result;
}

uint64_t icu::MeasureUnitImpl::build@<X0>( icu::MeasureUnitImpl *a1@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  return icu::MeasureUnit::MeasureUnit(a3, a1);
}

uint64_t icu::SingleUnitImpl::getSimpleUnitID(icu::SingleUnitImpl *this)
{
  return *(void *)(qword_18C535680 + 8LL * *(int *)this);
}

icu::CharString *icu::SingleUnitImpl::appendNeutralIdentifier( icu::CharString *this, icu::CharString *a2, UErrorCode *a3)
{
  uint64_t v5 = this;
  int v6 = *((_DWORD *)this + 2);
  if (v6 >= 0) {
    unsigned int v7 = *((_DWORD *)this + 2);
  }
  else {
    unsigned int v7 = -v6;
  }
  if (v7 != 1)
  {
    if (v7 == 3)
    {
      uint64_t v8 = "cubic-";
      int v9 = v21;
      uint64_t v10 = (icu::StringPiece *)v21;
    }

    else if (v7 == 2)
    {
      uint64_t v8 = "square-";
      int v9 = v22;
      uint64_t v10 = (icu::StringPiece *)v22;
    }

    else
    {
      if (v7 > 0xF)
      {
        UErrorCode v13 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_19:
        *a3 = v13;
        return this;
      }

      icu::StringPiece::StringPiece((icu::StringPiece *)&v19, "pow");
      icu::CharString::append(a2, v19, v20, a3);
      icu::CharString::appendNumber(a2, v7, a3);
      uint64_t v8 = "-";
      int v9 = v18;
      uint64_t v10 = (icu::StringPiece *)v18;
    }

    icu::StringPiece::StringPiece(v10, v8);
    this = icu::CharString::append(a2, *(const char **)v9, *((_DWORD *)v9 + 2), a3);
  }

  if (*(int *)a3 <= 0)
  {
    int v11 = *((_DWORD *)v5 + 1);
    if (v11 != 30)
    {
      uint64_t v12 = 0LL;
      while (LODWORD((&off_1897266D0)[v12 + 1]) != v11)
      {
        v12 += 2LL;
        if (v12 == 56)
        {
          UErrorCode v13 = U_UNSUPPORTED_ERROR;
          goto LABEL_19;
        }
      }

      icu::StringPiece::StringPiece((icu::StringPiece *)&v16, (&off_1897266D0)[v12]);
      icu::CharString::append(a2, v16, v17, a3);
    }

    icu::StringPiece::StringPiece((icu::StringPiece *)&v14, *(const char **)(qword_18C535680 + 8LL * *(int *)v5));
    return icu::CharString::append(a2, v14, v15, a3);
  }

  return this;
}

uint64_t icu::SingleUnitImpl::getUnitCategoryIndex(icu::SingleUnitImpl *this)
{
  return *(unsigned int *)(qword_18C535688 + 4LL * *(int *)this);
}

icu::MeasureUnitImpl *icu::MeasureUnitImpl::MeasureUnitImpl( icu::MeasureUnitImpl *this, const icu::SingleUnitImpl *a2, UErrorCode *a3)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = (char *)this + 32;
  *((_DWORD *)this + 6) = 8;
  *((_BYTE *)this + 28) = 0;
  *((void *)this + 12) = (char *)this + 109;
  *((_DWORD *)this + 26) = 40;
  *((_WORD *)this + 54) = 0;
  *((_DWORD *)this + 38) = 0;
  icu::MeasureUnitImpl::appendSingleUnit(this, a2, a3);
  return this;
}

{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = (char *)this + 32;
  *((_DWORD *)this + 6) = 8;
  *((_BYTE *)this + 28) = 0;
  *((void *)this + 12) = (char *)this + 109;
  *((_DWORD *)this + 26) = 40;
  *((_WORD *)this + 54) = 0;
  *((_DWORD *)this + 38) = 0;
  icu::MeasureUnitImpl::appendSingleUnit(this, a2, a3);
  return this;
}

void icu::MeasureUnitImpl::forIdentifier(uint64_t a1@<X0>, uint64_t a2@<X1>, int *a3@<X2>, uint64_t a4@<X8>)
{
}

void sub_18090D380(uint64_t a1@<X0>, uint64_t a2@<X1>, int *a3@<X2>, uint64_t a4@<X8>)
{
  if (*a3 >= 1) {
    goto LABEL_8;
  }
  unsigned int v8 = atomic_load(&dword_18C535690);
  if (v8 == 2 || !icu::umtx_initImplPreInit(&dword_18C535690))
  {
    if (dword_18C535694 >= 1)
    {
      *a3 = dword_18C535694;
      goto LABEL_8;
    }
  }

  else
  {
    sub_18090C238(a3);
    dword_18C535694 = *a3;
    icu::umtx_initImplPostInit(&dword_18C535690);
  }

  if (*a3 < 1)
  {
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = a1;
    *(void *)(a4 + 16) = a2;
    int v9 = (void *)qword_18C535698;
    goto LABEL_9;
  }

uint64_t sub_18090D470@<X0>(uint64_t result@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(void *)(a3 + 16) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 8;
  *(void *)(a3 + 96) = a3 + 109;
  *(_DWORD *)(a3 + 104) = 40;
  *(_DWORD *)(a3 + 152) = 0;
  if (*(int *)a2 <= 0)
  {
    uint64_t v4 = result;
    int v5 = *(_DWORD *)(result + 16);
    if (v5)
    {
      int v6 = *(_DWORD *)result;
      if (*(_DWORD *)result < v5)
      {
        while (1)
        {
          int v17 = 0;
          unint64_t v16 = 0LL;
          uint64_t result = sub_18090E404((int *)v4, a2);
          int v8 = result & 0xFFFFFFC0;
          if (v6) {
            break;
          }
          if (v8 == 192)
          {
            *(_BYTE *)(v4 + 56) = 1;
            uint64_t result = sub_18090E404((int *)v4, a2);
            int v9 = 0;
            int v10 = -1;
          }

          else
          {
            int v9 = 0;
            int v10 = 1;
          }

void icu::MeasureUnitImpl::forMeasureUnitMaybeCopy( icu::MeasureUnitImpl **this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  if (this[1])
  {
    icu::MeasureUnitImpl::copy(this[1], a2, a3);
  }

  else
  {
    Identifier = icu::MeasureUnit::getIdentifier((icu::MeasureUnit *)this);
    icu::StringPiece::StringPiece((icu::StringPiece *)v7, Identifier);
    sub_18090D380(v7[0], v7[1], (int *)a2, (uint64_t)v8);
    sub_18090D470((uint64_t)v8, a2, a3);
    icu::BytesTrie::~BytesTrie(&v9);
  }

int *icu::MeasureUnitImpl::extractIndividualUnitsWithIndices@<X0>( int *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = this;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)(a3 + 80) = 0LL;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(void *)(a3 + 8) = a3 + 24;
  *(_DWORD *)(a3 + 16) = 8;
  if (*this == 2)
  {
    int v9 = 0;
    if (this[2] >= 1)
    {
      int v6 = 0;
      BOOL v7 = *a2 < U_ILLEGAL_ARGUMENT_ERROR;
      while (v7)
      {
        this = (int *)sub_18090E7E8( (unsigned int *)a3,  &v9,  *(const icu::SingleUnitImpl **)(*((void *)v4 + 2) + 8LL * v6),  a2);
        if (*(int *)a2 <= 0)
        {
          int v6 = v9 + 1;
          int v9 = v6;
          BOOL v7 = 1;
          if (v6 < v4[2]) {
            continue;
          }
        }

        return this;
      }
    }
  }

  else
  {
    int v10 = 0;
    if (*(int *)a2 <= 0)
    {
      this = (int *)sub_18090E6DC((unsigned int *)a3, &v10, (icu::MeasureUnitImpl *)this, a2);
      if (*(int *)a2 <= 0 && !this) {
LABEL_15:
      }
        *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

uint64_t sub_18090D890(uint64_t a1, int **a2, int **a3)
{
  return sub_18090E614(*a2, *a3);
}

void icu::MeasureUnit::forIdentifier(uint64_t a1@<X0>, uint64_t a2@<X1>, int *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  sub_18090D380(a1, a2, a3, (uint64_t)v6);
  sub_18090D470((uint64_t)v6, (UErrorCode *)a3, (uint64_t)v8);
  icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)v8, (UErrorCode *)a3);
  icu::MeasureUnit::MeasureUnit(a4, v8);
  if (v10) {
    uprv_free(v9[11]);
  }
  sub_180850D68((uint64_t)v9);
  icu::BytesTrie::~BytesTrie(&v7);
}

uint64_t icu::MeasureUnit::getComplexity(icu::MeasureUnit *this, UErrorCode *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v12 = 0u;
  memset(v9, 0, sizeof(v9));
  __int128 v6 = 0u;
  BOOL v7 = v9;
  uint64_t v8 = 8LL;
  char v10 = (char *)&v11 + 5;
  uint64_t v11 = 40LL;
  DWORD2(v14) = 0;
  uint64_t v4 = *(unsigned int *)icu::MeasureUnitImpl::forMeasureUnit( this,  (const icu::MeasureUnit *)&v6,  (icu::MeasureUnitImpl *)a2,  a4);
  if (BYTE4(v11)) {
    uprv_free(v10);
  }
  sub_180850D68((uint64_t)&v6 + 8);
  return v4;
}

unint64_t icu::MeasureUnit::getPrefix( icu::MeasureUnit *this, UErrorCode *a2, UErrorCode *a3, UErrorCode *a4)
{
  return icu::SingleUnitImpl::forMeasureUnit(this, (const icu::MeasureUnit *)a2, a3, a4) >> 32;
}

uint64_t icu::MeasureUnit::withPrefix@<X0>( icu::MeasureUnit *a1@<X2>, icu::SingleUnitImpl *a2@<X0>, int a3@<W1>, UErrorCode *a4@<X3>, uint64_t a5@<X8>)
{
  v10[0] = icu::SingleUnitImpl::forMeasureUnit(a2, a1, (UErrorCode *)a1, a4);
  v10[1] = a3;
  _OWORD v10[2] = v8;
  return icu::SingleUnitImpl::build((icu::SingleUnitImpl *)v10, (UErrorCode *)a1, a5);
}

uint64_t icu::MeasureUnit::getDimensionality( icu::MeasureUnit *this, UErrorCode *a2, UErrorCode *a3, UErrorCode *a4)
{
  if (icu::SingleUnitImpl::forMeasureUnit(this, (const icu::MeasureUnit *)a2, a3, a4) != -1
    && *a2 <= U_ZERO_ERROR)
  {
    return v5;
  }

  else
  {
    return 0LL;
  }

uint64_t icu::MeasureUnit::withDimensionality@<X0>( icu::MeasureUnit *this@<X0>, UErrorCode *a2@<X2>, int a3@<W1>, UErrorCode *a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v9 = icu::SingleUnitImpl::forMeasureUnit(this, (const icu::MeasureUnit *)a2, a2, a4);
  int v10 = a3;
  return icu::SingleUnitImpl::build((icu::SingleUnitImpl *)&v9, a2, a5);
}

uint64_t icu::MeasureUnit::reciprocal@<X0>( icu::MeasureUnitImpl **this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  icu::MeasureUnitImpl::forMeasureUnitMaybeCopy(this, a2, (uint64_t)&v9);
  DWORD2(v18) = 0;
  *(_BYTE *)__int128 v15 = 0;
  uint64_t v5 = DWORD2(v9);
  if (SDWORD2(v9) >= 1)
  {
    __int128 v6 = (uint64_t *)v10;
    do
    {
      uint64_t v7 = *v6++;
      *(_DWORD *)(v7 + 8) = -*(_DWORD *)(v7 + 8);
      --v5;
    }

    while (v5);
  }

  icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)&v9, a2);
  icu::MeasureUnit::MeasureUnit(a3, &v9);
  if (BYTE12(v15)) {
    uprv_free((void *)v15);
  }
  return sub_180850D68((uint64_t)&v9 + 8);
}

uint64_t icu::MeasureUnit::product@<X0>( icu::MeasureUnitImpl **this@<X0>, const icu::MeasureUnit *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  memset(v21, 0, sizeof(v21));
  icu::MeasureUnitImpl::forMeasureUnitMaybeCopy(this, a3, (uint64_t)v21);
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v18 = 0u;
  memset(v15, 0, sizeof(v15));
  __int128 v12 = 0u;
  __int128 v13 = v15;
  uint64_t v14 = 8LL;
  __int128 v16 = (char *)&v17 + 5;
  uint64_t v17 = 40LL;
  DWORD2(v20) = 0;
  int v8 = icu::MeasureUnitImpl::forMeasureUnit(a2, (const icu::MeasureUnit *)&v12, (icu::MeasureUnitImpl *)a3, v7);
  if (LODWORD(v21[0]) == 2 || (__int128 v9 = v8, *(_DWORD *)v8 == 2))
  {
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    icu::MeasureUnit::MeasureUnit(a4);
  }

  else
  {
    if (*((int *)v8 + 2) >= 1)
    {
      uint64_t v10 = 0LL;
      do
        icu::MeasureUnitImpl::appendSingleUnit( (icu::MeasureUnitImpl *)v21,  *(const icu::SingleUnitImpl **)(*((void *)v9 + 2) + 8 * v10++),  a3);
      while (v10 < *((int *)v9 + 2));
    }

    if (SDWORD2(v21[0]) > 1) {
      LODWORD(v21[0]) = 1;
    }
    icu::MeasureUnitImpl::serialize((icu::MeasureUnitImpl *)v21, a3);
    icu::MeasureUnit::MeasureUnit(a4, v21);
  }

  if (BYTE4(v17)) {
    uprv_free(v16);
  }
  sub_180850D68((uint64_t)&v12 + 8);
  if (BYTE12(v22)) {
    uprv_free((void *)v22);
  }
  return sub_180850D68((uint64_t)v21 + 8);
}

uint64_t icu::MeasureUnit::splitToSingleUnitsImpl@<X0>( icu::MeasureUnit *this@<X0>, int *a2@<X1>, UErrorCode *a3@<X2>, UErrorCode *a4@<X3>, void *a5@<X8>)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v27 = 0u;
  memset(v24, 0, sizeof(v24));
  __int128 v21 = 0u;
  __int128 v22 = v24;
  uint64_t v23 = 8LL;
  __int128 v25 = (char *)&v26 + 5;
  uint64_t v26 = 40LL;
  DWORD2(v29) = 0;
  __int128 v9 = icu::MeasureUnitImpl::forMeasureUnit(this, (const icu::MeasureUnit *)&v21, (icu::MeasureUnitImpl *)a3, a4);
  unint64_t v10 = *((int *)v9 + 2);
  *a2 = v10;
  BOOL v11 = !is_mul_ok(v10, 0x18uLL);
  if (24 * v10 >= 0xFFFFFFFFFFFFFFF0LL) {
    BOOL v11 = 1;
  }
  if (v11) {
    uint64_t v12 = -1LL;
  }
  else {
    uint64_t v12 = 24 * v10 + 16;
  }
  __int128 v13 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v12, v8);
  if (v13)
  {
    *__int128 v13 = 24LL;
    v13[1] = v10;
    uint64_t v14 = v13 + 2;
    if ((_DWORD)v10)
    {
      uint64_t v15 = 24 * v10;
      uint64_t v16 = (uint64_t)(v13 + 2);
      do
      {
        uint64_t v16 = icu::MeasureUnit::MeasureUnit(v16) + 24;
        v15 -= 24LL;
      }

      while (v15);
    }

    if (*a2 >= 1)
    {
      uint64_t v17 = 0LL;
      uint64_t v18 = (uint64_t)v14;
      do
      {
        icu::SingleUnitImpl::build(*(icu::SingleUnitImpl **)(*((void *)v9 + 2) + 8 * v17), a3, (uint64_t)v20);
        icu::MeasureUnit::operator=(v18, (uint64_t)v20);
        icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)v20);
        ++v17;
        v18 += 24LL;
      }

      while (v17 < *a2);
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  *a5 = v14;
  if (BYTE4(v26)) {
    uprv_free(v25);
  }
  return sub_180850D68((uint64_t)&v21 + 8);
}

uint64_t sub_18090DF30()
{
  qword_18C535668 = 0LL;
  uprv_free((void *)qword_18C535678);
  qword_18C535678 = 0LL;
  uprv_free((void *)qword_18C535698);
  qword_18C535698 = 0LL;
  uprv_free((void *)qword_18C535688);
  qword_18C535688 = 0LL;
  uprv_free((void *)qword_18C535680);
  qword_18C535680 = 0LL;
  atomic_store(0, &dword_18C535690);
  return 1LL;
}

void sub_18090DFB0(icu::ResourceSink *a1)
{
}

void *sub_18090DFC4(uint64_t a1, uint64_t a2, icu::ResourceValue *a3, uint64_t a4, UErrorCode *a5)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  uint64_t v19 = 0LL;
  uint64_t result = (*(void *(**)(void *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 80LL))( v18,  a3,  a5);
  if (*(int *)a5 <= 0)
  {
    if ((int)v19 + *(_DWORD *)(a1 + 32) <= **(_DWORD **)(a1 + 16))
    {
      uint64_t result = (void *)icu::ResourceArray::getValue((icu::ResourceArray *)v18, 0, a3);
      if ((_DWORD)result)
      {
        unsigned int v10 = 1;
        do
        {
          uint64_t v17 = 0LL;
          memset(v16, 0, sizeof(v16));
          uint64_t result = (*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))( v16,  a3,  a5);
          if ((_DWORD)v17 != 1)
          {
            int v9 = 3;
            goto LABEL_4;
          }

          __int128 __s = 0LL;
          icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v16, 0, (const char **)&__s, a3);
          int v14 = 0;
          *(void *)(*(void *)(a1 + 8) + 8LL * *(int *)(a1 + 32)) = (*(uint64_t (**)(icu::ResourceValue *, int *, UErrorCode *))(*(void *)a3 + 32LL))( a3,  &v14,  a5);
          uint64_t v11 = *(void *)(a1 + 24);
          icu::StringPiece::StringPiece((icu::StringPiece *)&v12, __s);
          icu::BytesTrieBuilder::add(v11, v12, v13, *(_DWORD *)(a1 + 32), a5);
          ++*(_DWORD *)(a1 + 32);
          uint64_t result = (void *)icu::ResourceArray::getValue((icu::ResourceArray *)v18, v10++, a3);
        }

        while ((_DWORD)result);
      }
    }

    else
    {
      int v9 = 8;
LABEL_4:
      *a5 = v9;
    }
  }

  return result;
}

void sub_18090E138(icu::ResourceSink *a1)
{
}

void sub_18090E14C(uint64_t a1, uint64_t a2, icu::ResourceValue *a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v26 = 0LL;
  memset(v25, 0, sizeof(v25));
  (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))(v25, a3, a5);
  if ((int)v26 + *(_DWORD *)(a1 + 64) > *(_DWORD *)(a1 + 24))
  {
    *a5 = U_INDEX_OUTOFBOUNDS_ERROR;
    return;
  }

  unint64_t v8 = *(unsigned __int8 **)(a1 + 48);
  __int128 v21 = 0LL;
  __int128 v22 = v8;
  uint64_t v23 = v8;
  uint64_t v24 = 0xFFFFFFFFLL;
  __s1 = 0LL;
  unsigned int v9 = 1;
  while (1)
  {
    unsigned int v10 = __s1;
    if (!strcmp(__s1, "kilogram")) {
      goto LABEL_16;
    }
    *(void *)(*(void *)(a1 + 8) + 8LL * *(int *)(a1 + 64)) = v10;
    uint64_t v11 = *(void *)(a1 + 32);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v18, __s1);
    icu::BytesTrieBuilder::add(v11, v18, v19, *(_DWORD *)(a1 + 64) + *(_DWORD *)(a1 + 40), a5);
    uint64_t v17 = 0LL;
    memset(v16, 0, sizeof(v16));
    (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))( v16,  a3,  a5);
    int32_t v15 = 0;
    uint64_t v12 = (UChar *)(*(uint64_t (**)(icu::ResourceValue *, int32_t *, UErrorCode *))(*(void *)a3 + 32LL))( a3,  &v15,  a5);
    int v29 = 0;
    memset(&v27[1], 0, 48);
    v27[0] = (char *)&v27[1] + 5;
    LODWORD(v27[1]) = 40;
    int v28 = 0;
    icu::CharString::appendInvariantChars((int *)v27, v12, v15, a5);
    int v13 = 0;
    if (*(int *)a5 <= 0)
    {
      uint64_t v23 = v22;
      LODWORD(v24) = -1;
      if ((int)icu::BytesTrie::next((icu::BytesTrie *)&v21, (const char *)v27[0], v28) <= 1)
      {
        int v13 = 0;
        *a5 = U_INVALID_FORMAT_ERROR;
      }

      else
      {
        *(_DWORD *)(*(void *)(a1 + 16) + 4LL * (int)(*(_DWORD *)(a1 + 64))++) = icu::BytesTrie::readValue( (icu::BytesTrie *)(v23 + 1),  (const unsigned __int8 *)(*v23 >> 1));
        int v13 = 1;
      }
    }

    if (BYTE4(v27[1])) {
      uprv_free(v27[0]);
    }
    if (!v13) {
      goto LABEL_19;
    }
LABEL_16:
  }

  *a5 = U_INVALID_FORMAT_ERROR;
LABEL_19:
  icu::BytesTrie::~BytesTrie(&v21);
}

uint64_t sub_18090E404(int *a1, _DWORD *a2)
{
  uint64_t v4 = (icu::BytesTrie *)(a1 + 6);
  *((void *)a1 + 5) = *((void *)a1 + 4);
  uint64_t Value = 0xFFFFFFFFLL;
  a1[12] = -1;
  int v6 = -1;
  while (1)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = *((void *)a1 + 1);
    *a1 = v7 + 1;
    int v9 = icu::BytesTrie::next(v4, *(char *)(v8 + v7));
    if (v9 != 1)
    {
      int v10 = v9;
      if (!v9) {
        break;
      }
      uint64_t Value = icu::BytesTrie::readValue( (icu::BytesTrie *)(*((void *)a1 + 5) + 1LL),  (const unsigned __int8 *)(**((unsigned __int8 **)a1 + 5) >> 1));
      int v6 = *a1;
      if (v10 == 2) {
        break;
      }
    }
  }

  if ((Value & 0x80000000) != 0) {
    *a2 = 1;
  }
  else {
    *a1 = v6;
  }
  return Value;
}

int *sub_18090E4BC(int *a1, int *a2)
{
  int v4 = *a1;
  *a1 = *a2;
  *a2 = v4;
  memset(v11, 0, sizeof(v11));
  uint64_t v12 = 0LL;
  uint64_t v5 = (int *)*((void *)a1 + 1);
  int v10 = v5;
  LODWORD(v11[0]) = a1[4];
  int v6 = *((unsigned __int8 *)a1 + 20);
  BYTE4(v11[0]) = *((_BYTE *)a1 + 20);
  uint64_t v7 = a1 + 6;
  if (v5 == a1 + 6)
  {
    int v10 = (int *)v11 + 2;
    memcpy((char *)v11 + 8, v5, 8LL * a1[4]);
    if (v6) {
      uprv_free(v5);
    }
  }

  else
  {
    *((void *)a1 + sub_1808F7164((uint64_t)v14, 1) = v7;
    a1[4] = 8;
    *((_BYTE *)a1 + 20) = 0;
  }

  a1[4] = a2[4];
  *((_BYTE *)a1 + 20) = *((_BYTE *)a2 + 20);
  uint64_t v8 = (int *)*((void *)a2 + 1);
  if (v8 == a2 + 6)
  {
    *((void *)a1 + sub_1808F7164((uint64_t)v14, 1) = v7;
    memcpy(v7, v8, 8LL * a2[4]);
    if (*((_BYTE *)a2 + 20)) {
      uprv_free(*((void **)a2 + 1));
    }
  }

  else
  {
    *((void *)a1 + sub_1808F7164((uint64_t)v14, 1) = v8;
  }

  a2[4] = v11[0];
  *((_BYTE *)a2 + 20) = BYTE4(v11[0]);
  if (v10 == (int *)((char *)v11 + 8))
  {
    *((void *)a2 + sub_1808F7164((uint64_t)v14, 1) = a2 + 6;
    memcpy(a2 + 6, (char *)v11 + 8, 8LL * SLODWORD(v11[0]));
    if (BYTE4(v11[0])) {
      uprv_free((char *)v11 + 8);
    }
  }

  else
  {
    *((void *)a2 + sub_1808F7164((uint64_t)v14, 1) = v10;
  }

  return a1;
}

uint64_t sub_18090E614(int *a1, int *a2)
{
  int v2 = a1[2];
  int v3 = a2[2];
  if (v2 < 0 && v3 > 0) {
    return 1LL;
  }
  if (v2 >= 1 && v3 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *a1;
  int v6 = *(_DWORD *)(qword_18C535688 + 4 * v5);
  uint64_t v7 = *a2;
  int v8 = *(_DWORD *)(qword_18C535688 + 4 * v7);
  if (v6 < v8) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v8) {
    return 1LL;
  }
  int v9 = a1[1];
  unsigned int v10 = v9 + 51;
  int v11 = a2[1];
  unsigned int v12 = v11 + 59;
  int v13 = 3 * v9 + 180;
  int v14 = v9 - 30;
  if (v10 >= 0xFFFFFFF8) {
    int v14 = v13;
  }
  int v15 = 3 * v11 + 180;
  int v16 = v11 - 30;
  if (v12 < 8) {
    int v16 = v15;
  }
  if (v14 < v16) {
    return 1LL;
  }
  if (v14 > v16) {
    return 0xFFFFFFFFLL;
  }
  if (v10 <= 0xFFFFFFF7 && v12 < 8) {
    return 1LL;
  }
  int v18 = v10 > 0xFFFFFFF7 && v12 > 7;
  return (v18 << 31 >> 31);
}

uint64_t *sub_18090E6DC(unsigned int *a1, _DWORD *a2, icu::MeasureUnitImpl *a3, UErrorCode *a4)
{
  int v8 = a1[4];
  uint64_t v9 = *a1;
  if ((_DWORD)v9 != v8)
  {
LABEL_16:
    int v14 = icu::UMemory::operator new((uint64_t *)v9, (icu::UMemory *)0xA8, (unint64_t)a2);
    unsigned int v12 = v14;
    if (v14)
    {
      *(_DWORD *)int v14 = *a2;
      icu::MeasureUnitImpl::copy(a3, a4, (uint64_t)(v14 + 1));
    }

    uint64_t v15 = (int)*a1;
    *a1 = v15 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v15) = v12;
    return v12;
  }

  if (v8 == 8) {
    int v10 = 32;
  }
  else {
    int v10 = 2 * v8;
  }
  if (v10 < 1) {
    return 0LL;
  }
  int v11 = (uint64_t *)uprv_malloc(8LL * v10);
  unsigned int v12 = v11;
  if (v11)
  {
    if (v8 >= 1)
    {
      int v13 = a1[4];
      if (v13 >= v8) {
        int v13 = v8;
      }
      if (v13 >= v10) {
        int v13 = v10;
      }
      memcpy(v11, *((const void **)a1 + 1), 8LL * v13);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + sub_1808F7164((uint64_t)v14, 1) = v12;
    a1[4] = v10;
    uint64_t v9 = 1LL;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v12;
}

uint64_t *sub_18090E7E8(unsigned int *a1, _DWORD *a2, const icu::SingleUnitImpl *a3, UErrorCode *a4)
{
  int v8 = a1[4];
  uint64_t v9 = *a1;
  if ((_DWORD)v9 != v8)
  {
LABEL_16:
    int v14 = icu::UMemory::operator new((uint64_t *)v9, (icu::UMemory *)0xA8, (unint64_t)a2);
    unsigned int v12 = v14;
    if (v14)
    {
      *(_DWORD *)int v14 = *a2;
      *((_DWORD *)v14 + 2) = 0;
      *((_DWORD *)v14 + 4) = 0;
      v14[3] = (uint64_t)(v14 + 5);
      *((_DWORD *)v14 + 8) = 8;
      *((_BYTE *)v14 + 36) = 0;
      v14[13] = (uint64_t)v14 + 117;
      *((_DWORD *)v14 + 28) = 40;
      *((_WORD *)v14 + 58) = 0;
      *((_DWORD *)v14 + 40) = 0;
      icu::MeasureUnitImpl::appendSingleUnit((icu::MeasureUnitImpl *)(v14 + 1), a3, a4);
    }

    uint64_t v15 = (int)*a1;
    *a1 = v15 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v15) = v12;
    return v12;
  }

  if (v8 == 8) {
    int v10 = 32;
  }
  else {
    int v10 = 2 * v8;
  }
  if (v10 < 1) {
    return 0LL;
  }
  int v11 = (uint64_t *)uprv_malloc(8LL * v10);
  unsigned int v12 = v11;
  if (v11)
  {
    if (v8 >= 1)
    {
      int v13 = a1[4];
      if (v13 >= v8) {
        int v13 = v8;
      }
      if (v13 >= v10) {
        int v13 = v10;
      }
      memcpy(v11, *((const void **)a1 + 1), 8LL * v13);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + sub_1808F7164((uint64_t)v14, 1) = v12;
    a1[4] = v10;
    uint64_t v9 = 1LL;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v12;
}

void *icu::Measure::getStaticClassID(icu::Measure *this)
{
  return &unk_18C5356A0;
}

void *icu::Measure::getDynamicClassID(icu::Measure *this)
{
  return &unk_18C5356A0;
}

icu::Measure *icu::Measure::Measure(icu::Measure *this)
{
  *(void *)this = off_189726930;
  icu::Formattable::Formattable((icu::Measure *)((char *)this + 8));
  *((void *)this + 15) = 0LL;
  return this;
}

{
  *(void *)this = off_189726930;
  icu::Formattable::Formattable((icu::Measure *)((char *)this + 8));
  *((void *)this + 15) = 0LL;
  return this;
}

icu::Measure *icu::Measure::Measure( icu::Measure *this, const icu::Formattable *a2, icu::MeasureUnit *a3, UErrorCode *a4)
{
  *(void *)this = off_189726930;
  uint64_t v7 = (icu::Formattable *)icu::Formattable::Formattable((icu::Measure *)((char *)this + 8), a2);
  *((void *)this + 15) = a3;
  if (*(int *)a4 <= 0)
  {
    int isNumeric = icu::Formattable::isNumeric(v7);
    if (!a3 || !isNumeric) {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  return this;
}

uint64_t icu::Measure::Measure(icu::Measure *this, const icu::Measure *a2)
{
  *(void *)this = off_189726930;
  icu::Formattable::Formattable((icu::Measure *)((char *)this + 8));
  *((void *)this + 15) = 0LL;
  return icu::Measure::operator=((uint64_t)this, (uint64_t)a2);
}

{
  *(void *)this = off_189726930;
  icu::Formattable::Formattable((icu::Measure *)((char *)this + 8));
  *((void *)this + 15) = 0LL;
  return icu::Measure::operator=((uint64_t)this, (uint64_t)a2);
}

uint64_t icu::Measure::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    icu::Formattable::operator=(a1 + 8, a2 + 8);
    uint64_t v5 = *(void *)(a2 + 120);
    if (v5) {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
    }
    *(void *)(a1 + 120) = v5;
  }

  return a1;
}

uint64_t icu::Measure::clone@<X0>(icu::Measure *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x80, a2);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    *uint64_t v4 = (uint64_t)off_189726930;
    icu::Formattable::Formattable((icu::Formattable *)(v4 + 1));
    *(void *)(v5 + 120) = 0LL;
    icu::Measure::operator=(v5, (uint64_t)this);
  }

  return v5;
}

void icu::Measure::~Measure(icu::Measure *this)
{
  *(void *)this = off_189726930;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::Formattable::~Formattable((icu::Measure *)((char *)this + 8));
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::Measure::~Measure(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::Measure::operator==(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a1) {
    __cxa_bad_typeid();
  }
  uint64_t result = sub_1807F874C(*(void *)(*a1 - 8LL), *(void *)(*a2 - 8LL));
  if ((_DWORD)result)
  {
    uint64_t result = icu::Formattable::operator==(a1 + 1, a2 + 1);
    if ((_DWORD)result)
    {
      uint64_t v5 = a1[15];
      uint64_t v6 = a2[15];
      uint64_t result = (v5 == 0) == (v6 == 0);
      if (v5)
      {
        if (v6) {
          return (*(uint64_t (**)(void))(*(void *)v5 + 32LL))(a1[15]);
        }
      }
    }
  }

  return result;
}

void *icu::MessageFormat::getStaticClassID(icu::MessageFormat *this)
{
  return &unk_18C5356A1;
}

void *icu::MessageFormat::getDynamicClassID(icu::MessageFormat *this)
{
  return &unk_18C5356A1;
}

void *sub_18090EC54()
{
  return &unk_18C5356A2;
}

icu::MessageFormat *icu::MessageFormat::MessageFormat( icu::MessageFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  uint64_t v6 = (icu::Locale *)icu::Format::Format((uint64_t)this);
  *(void *)uint64_t v6 = off_189726978;
  uint64_t v7 = (icu::Locale *)((char *)v6 + 328);
  uint64_t Default = icu::Locale::getDefault(v6);
  icu::Locale::Locale(v7, (uint64_t)Default);
  icu::MessagePattern::MessagePattern((icu::MessageFormat *)((char *)this + 552), a3);
  *((void *)this + 85) = 0LL;
  *((_DWORD *)this + 172) = 0;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_BYTE *)this + 712) = 0;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 94) = off_189726B60;
  *((void *)this + 95) = this;
  *((void *)this + 96) = 0LL;
  *((_DWORD *)this + 194) = 0;
  *((void *)this + 98) = off_189726B60;
  *((void *)this + 99) = this;
  *((void *)this + 100) = 0LL;
  *((_DWORD *)this + 202) = 1;
  icu::Format::setLocaleIDs(this, *((const char **)this + 46), *((const char **)this + 46));
  (*(void (**)(icu::MessageFormat *, const icu::UnicodeString *, UErrorCode *))(*(void *)this + 80LL))( this,  a2,  a3);
  return this;
}

uint64_t icu::MessageFormat::PluralSelectorProvider::PluralSelectorProvider( uint64_t result, uint64_t a2, int a3)
{
  *(void *)uint64_t result = off_189726B60;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = 0LL;
  *(_DWORD *)(result + 24) = a3;
  return result;
}

{
  *(void *)uint64_t result = off_189726B60;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = 0LL;
  *(_DWORD *)(result + 24) = a3;
  return result;
}

icu::MessageFormat *icu::MessageFormat::MessageFormat( icu::MessageFormat *this, const icu::UnicodeString *a2, const icu::Locale *a3, UErrorCode *a4)
{
  int v8 = (void *)icu::Format::Format((uint64_t)this);
  *int v8 = off_189726978;
  icu::Locale::Locale((icu::Locale *)(v8 + 41), (uint64_t)a3);
  icu::MessagePattern::MessagePattern((icu::MessageFormat *)((char *)this + 552), a4);
  *((void *)this + 85) = 0LL;
  *((_DWORD *)this + 172) = 0;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_BYTE *)this + 712) = 0;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 94) = off_189726B60;
  *((void *)this + 95) = this;
  *((void *)this + 96) = 0LL;
  *((_DWORD *)this + 194) = 0;
  *((void *)this + 98) = off_189726B60;
  *((void *)this + 99) = this;
  *((void *)this + 100) = 0LL;
  *((_DWORD *)this + 202) = 1;
  icu::Format::setLocaleIDs(this, *((const char **)this + 46), *((const char **)this + 46));
  (*(void (**)(icu::MessageFormat *, const icu::UnicodeString *, UErrorCode *))(*(void *)this + 80LL))( this,  a2,  a4);
  return this;
}

icu::MessageFormat *icu::MessageFormat::MessageFormat( icu::MessageFormat *this, const icu::UnicodeString *a2, const icu::Locale *a3, UParseError *a4, UErrorCode *a5)
{
  int v10 = (void *)icu::Format::Format((uint64_t)this);
  *int v10 = off_189726978;
  icu::Locale::Locale((icu::Locale *)(v10 + 41), (uint64_t)a3);
  icu::MessagePattern::MessagePattern((icu::MessageFormat *)((char *)this + 552), a5);
  *((void *)this + 85) = 0LL;
  *((_DWORD *)this + 172) = 0;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_BYTE *)this + 712) = 0;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 94) = off_189726B60;
  *((void *)this + 95) = this;
  *((void *)this + 96) = 0LL;
  *((_DWORD *)this + 194) = 0;
  *((void *)this + 98) = off_189726B60;
  *((void *)this + 99) = this;
  *((void *)this + 100) = 0LL;
  *((_DWORD *)this + 202) = 1;
  icu::Format::setLocaleIDs(this, *((const char **)this + 46), *((const char **)this + 46));
  (*(void (**)(icu::MessageFormat *, const icu::UnicodeString *, UParseError *, UErrorCode *))(*(void *)this + 88LL))( this,  a2,  a4,  a5);
  return this;
}

icu::MessageFormat *icu::MessageFormat::MessageFormat( icu::MessageFormat *this, const icu::MessageFormat *a2)
{
  uint64_t v4 = (void *)icu::Format::Format((uint64_t)this, (uint64_t)a2);
  *uint64_t v4 = off_189726978;
  icu::Locale::Locale((icu::Locale *)(v4 + 41), (uint64_t)a2 + 328);
  icu::MessagePattern::MessagePattern( (icu::MessageFormat *)((char *)this + 552),  (const icu::MessageFormat *)((char *)a2 + 552));
  *((void *)this + 85) = 0LL;
  *((_DWORD *)this + 172) = 0;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_BYTE *)this + 712) = *((_BYTE *)a2 + 712);
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 94) = off_189726B60;
  *((void *)this + 95) = this;
  *((void *)this + 96) = 0LL;
  *((_DWORD *)this + 194) = 0;
  *((void *)this + 98) = off_189726B60;
  *((void *)this + 99) = this;
  *((void *)this + 100) = 0LL;
  *((_DWORD *)this + 202) = 1;
  UErrorCode v6 = U_ZERO_ERROR;
  icu::MessageFormat::copyObjects(this, a2, &v6);
  if (v6 >= U_ILLEGAL_ARGUMENT_ERROR) {
    icu::MessageFormat::resetPattern(this);
  }
  return this;
}

uint64_t icu::MessageFormat::copyObjects( icu::MessageFormat *this, const icu::MessageFormat *a2, UErrorCode *a3)
{
  int v6 = *((_DWORD *)a2 + 176);
  *((_DWORD *)this + 176) = v6;
  if (v6 >= 1)
  {
    uint64_t result = icu::MessageFormat::allocateArgTypes(this, v6, a3);
    if (!(_DWORD)result) {
      return result;
    }
    memcpy(*((void **)this + 87), *((const void **)a2 + 87), 4LL * *((int *)this + 176));
  }

  uint64_t v8 = *((void *)this + 92);
  if (v8) {
    uhash_removeAll(v8);
  }
  uint64_t v9 = *((void *)this + 93);
  if (v9) {
    uhash_removeAll(v9);
  }
  uint64_t v10 = *((void *)a2 + 92);
  if (!v10) {
    goto LABEL_16;
  }
  if (!*((void *)this + 92))
  {
    uint64_t result = (uint64_t)uhash_open((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, (uint64_t)sub_18090FD28, (int *)a3);
    *((void *)this + 92) = result;
    uhash_setValueDeleter(result, (uint64_t)uprv_deleteUObject);
    uint64_t v10 = *((void *)a2 + 92);
  }

  int v11 = uhash_count(v10);
  int v19 = -1;
  if (v11 >= 1 && *(int *)a3 <= 0)
  {
    int v12 = v11;
    int v13 = 1;
    while (1)
    {
      uint64_t v14 = uhash_nextElement(*((uint64_t **)a2 + 92), &v19);
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v14 + 8) + 32LL))(*(void *)(v14 + 8));
      if (!result) {
        break;
      }
      uhash_iput(*((void *)this + 92), *(_DWORD *)(v14 + 16), result, (int *)a3);
      if (v13 < v12)
      {
        ++v13;
      }

      goto LABEL_16;
    }

    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  else
  {
LABEL_16:
    uint64_t result = *((void *)a2 + 93);
    if (result)
    {
      if (!*((void *)this + 93))
      {
        *((void *)this + 93) = uhash_open((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, 0LL, (int *)a3);
        uint64_t result = *((void *)a2 + 93);
      }

      uint64_t result = uhash_count(result);
      int v18 = -1;
      if ((int)result >= 1 && *(int *)a3 <= 0)
      {
        int v15 = result;
        int v16 = 1;
        do
        {
          uint64_t v17 = uhash_nextElement(*((uint64_t **)a2 + 93), &v18);
          uint64_t result = uhash_iputi(*((void *)this + 93), *(_DWORD *)(v17 + 16), *(_DWORD *)(v17 + 8), (int *)a3);
          if (v16 >= v15) {
            break;
          }
          ++v16;
        }

        while (*(int *)a3 < 1);
      }
    }
  }

  return result;
}

void icu::MessageFormat::resetPattern(icu::MessageFormat *this)
{
  *((void *)this + 92) = 0LL;
  uhash_close(*((_BYTE **)this + 93));
  *((void *)this + 93) = 0LL;
  *((_DWORD *)this + 176) = 0;
  *((_BYTE *)this + 712) = 0;
}

void icu::MessageFormat::~MessageFormat(icu::MessageFormat *this)
{
  *(void *)this = off_189726978;
  uhash_close(*((_BYTE **)this + 92));
  uhash_close(*((_BYTE **)this + 93));
  uprv_free(*((void **)this + 87));
  uprv_free(*((void **)this + 85));
  uint64_t v2 = *((void *)this + 90);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *((void *)this + 91);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  *((void *)this + 98) = off_189726B60;
  uint64_t v4 = *((void *)this + 100);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  icu::PluralFormat::PluralSelector::~PluralSelector((icu::MessageFormat *)((char *)this + 784));
  *((void *)this + 94) = off_189726B60;
  uint64_t v5 = *((void *)this + 96);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  icu::PluralFormat::PluralSelector::~PluralSelector((icu::MessageFormat *)((char *)this + 752));
  icu::MessagePattern::~MessagePattern((icu::MessageFormat *)((char *)this + 552));
  icu::Locale::~Locale((icu::MessageFormat *)((char *)this + 328));
  icu::Format::~Format(this);
}

{
  void *v1;
  icu::MessageFormat::~MessageFormat(this);
  icu::UMemory::operator delete(v1);
}

void icu::MessageFormat::PluralSelectorProvider::~PluralSelectorProvider( icu::MessageFormat::PluralSelectorProvider *this)
{
  *(void *)this = off_189726B60;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::PluralFormat::PluralSelector::~PluralSelector(this);
}

{
  uint64_t v2;
  *(void *)this = off_189726B60;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::PluralFormat::PluralSelector::~PluralSelector(this);
}

{
  uint64_t v2;
  void *v3;
  *(void *)this = off_189726B60;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::PluralFormat::PluralSelector::~PluralSelector(this);
  icu::UMemory::operator delete(v3);
}

uint64_t icu::MessageFormat::allocateArgTypes(icu::MessageFormat *this, int a2, UErrorCode *a3)
{
  int v5 = *((_DWORD *)this + 177);
  if (v5 >= a2) {
    return 1LL;
  }
  int v7 = 2 * v5;
  if (v7 <= a2) {
    int v7 = a2;
  }
  if (a2 >= 10) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 10;
  }
  uint64_t result = (uint64_t)uprv_realloc(*((void **)this + 87), 4LL * v8);
  if (result)
  {
    *((void *)this + 87) = result;
    *((_DWORD *)this + 177) = v8;
    return 1LL;
  }

  *a3 = U_MEMORY_ALLOCATION_ERROR;
  return result;
}

icu::MessageFormat *icu::MessageFormat::operator=(icu::MessageFormat *a1, icu::MessageFormat *a2)
{
  if (a1 != a2)
  {
    icu::Format::operator=((uint64_t)a1, (uint64_t)a2);
    (*(void (**)(icu::MessageFormat *, _BYTE *))(*(void *)a1 + 64LL))(a1, (_BYTE *)a2 + 328);
    icu::MessagePattern::operator=((uint64_t)a1 + 552, (uint64_t)a2 + 552);
    *((_BYTE *)a1 + 712) = *((_BYTE *)a2 + 712);
    UErrorCode v5 = U_ZERO_ERROR;
    icu::MessageFormat::copyObjects(a1, a2, &v5);
    if (v5 >= U_ILLEGAL_ARGUMENT_ERROR) {
      icu::MessageFormat::resetPattern(a1);
    }
  }

  return a1;
}

BOOL icu::MessageFormat::operator==(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (!icu::Format::operator==(a1, a2)
    || !icu::MessagePattern::operator==((uint64_t)(a1 + 69), (uint64_t)(a2 + 69))
    || !icu::Locale::operator==((uint64_t)(a1 + 41), (uint64_t)(a2 + 41)))
  {
    return 0;
  }

  uint64_t v4 = a1[93];
  uint64_t v5 = a2[93];
  BOOL v6 = (v4 == 0) == (v5 == 0);
  if (!v4 || !v5) {
    return v6;
  }
  int v7 = uhash_count(v4);
  int v18 = -1;
  int v19 = -1;
  if (v7 < 1) {
    return 1;
  }
  uint64_t v8 = uhash_nextElement((uint64_t *)a1[93], &v19);
  uint64_t v9 = uhash_nextElement((uint64_t *)a2[93], &v18);
  unsigned int v10 = *(_DWORD *)(v8 + 16);
  int v11 = (unsigned int *)(v9 + 16);
  if (v10 != *(_DWORD *)(v9 + 16)) {
    return 0;
  }
  BOOL v6 = 0;
  int v12 = 1;
  do
  {
    uint64_t v13 = uhash_iget(a1[92], v10);
    uint64_t v14 = uhash_iget(a2[92], *v11);
    BOOL v6 = v12 >= v7;
    if (v7 == v12) {
      break;
    }
    uint64_t v15 = uhash_nextElement((uint64_t *)a1[93], &v19);
    uint64_t v16 = uhash_nextElement((uint64_t *)a2[93], &v18);
    unsigned int v10 = *(_DWORD *)(v15 + 16);
    int v11 = (unsigned int *)(v16 + 16);
    ++v12;
  }

  while (v10 == *(_DWORD *)(v16 + 16));
  return v6;
}

icu::MessageFormat *icu::MessageFormat::clone@<X0>( icu::MessageFormat *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::MessageFormat *)icu::UMemory::operator new(a3, (icu::UMemory *)0x330, a2);
  if (result) {
    return icu::MessageFormat::MessageFormat(result, this);
  }
  return result;
}

uint64_t icu::MessageFormat::setLocale(icu::MessageFormat *this, const icu::Locale *a2)
{
  uint64_t v4 = (icu::MessageFormat *)((char *)this + 328);
  uint64_t result = icu::Locale::operator==((uint64_t)this + 328, (uint64_t)a2);
  if ((result & 1) == 0)
  {
    uint64_t v6 = *((void *)this + 90);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    *((void *)this + 90) = 0LL;
    uint64_t v7 = *((void *)this + 91);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    *((void *)this + 9sub_1808F7164((uint64_t)v14, 1) = 0LL;
    icu::Locale::operator=(v4, (uint64_t)a2);
    icu::Format::setLocaleIDs(this, *((const char **)this + 46), *((const char **)this + 46));
    uint64_t v8 = *((void *)this + 96);
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    *((void *)this + 96) = 0LL;
    uint64_t result = *((void *)this + 100);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
    *((void *)this + 100) = 0LL;
  }

  return result;
}

uint64_t icu::MessageFormat::PluralSelectorProvider::reset(icu::MessageFormat::PluralSelectorProvider *this)
{
  uint64_t result = *((void *)this + 2);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  *((void *)this + 2) = 0LL;
  return result;
}

uint64_t icu::MessageFormat::getLocale(icu::MessageFormat *this)
{
  return (uint64_t)this + 328;
}

uint64_t icu::MessageFormat::applyPattern( icu::MessageFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  uint64_t v5 = 0LL;
  memset(v4, 0, sizeof(v4));
  return (*(uint64_t (**)(icu::MessageFormat *, const icu::UnicodeString *, _OWORD *, UErrorCode *))(*(void *)this + 88LL))( this,  a2,  v4,  a3);
}

void icu::MessageFormat::applyPattern(int32x2_t *this, UChar **a2, UParseError *a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    icu::MessagePattern::parse((icu::MessagePattern *)&this[69], a2, a3, a4);
    icu::MessageFormat::cacheExplicitFormats(this, a4);
  }

void icu::MessageFormat::cacheExplicitFormats(int32x2_t *this, UErrorCode *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    uint64_t v4 = (uint64_t)this[92];
    if (v4) {
      uhash_removeAll(v4);
    }
    uint64_t v5 = (uint64_t)this[93];
    if (v5) {
      uhash_removeAll(v5);
    }
    int v6 = 0;
    int v7 = this[81].i32[0];
    unint64_t v8 = (v7 - 2);
    this[88].i32[0] = 0;
    UErrorCode v9 = *a2;
    if (v7 >= 5 && v9 <= U_ZERO_ERROR)
    {
      int v6 = 0;
      uint64_t v11 = *(void *)&this[80] + 32LL;
      unint64_t v12 = 3LL;
      uint64_t v13 = (int *)v11;
      do
      {
        int v14 = *v13;
        v13 += 4;
        if (v14 == 7)
        {
          int v15 = *(__int16 *)(v11 + 10);
          if (v6 <= v15)
          {
            int v6 = v15 + 1;
            this[88].i32[0] = v15 + 1;
            UErrorCode v9 = *a2;
          }
        }

        if (v12 >= v8) {
          break;
        }
        ++v12;
        uint64_t v11 = (uint64_t)v13;
      }

      while (v9 <= U_ZERO_ERROR);
    }

    if (icu::MessageFormat::allocateArgTypes((icu::MessageFormat *)this, v6, a2))
    {
      uint64_t v16 = this[88].u32[0];
      this[89].i8[0] = 0;
      if (v7 >= 4)
      {
        UErrorCode v17 = *a2;
        if (*(int *)a2 <= 0)
        {
          __int128 v33 = (icu::UnicodeString *)&this[71];
          unint64_t v18 = 1LL;
          do
          {
            int32x2_t v19 = this[80];
            if (*(_DWORD *)(*(void *)&v19 + 16LL * (int)v18) == 5)
            {
              uint64_t v20 = (int)v18 + 1LL;
              if (*(_DWORD *)(*(void *)&v19 + 16 * v20) == 7) {
                int v21 = *(__int16 *)(*(void *)&v19 + 16 * v20 + 10);
              }
              else {
                int v21 = -1;
              }
              int v22 = *(__int16 *)(*(void *)&v19 + 16LL * (int)v18 + 10);
              int v34 = 0;
              switch(v22)
              {
                case 0:
                case 4:
                  goto LABEL_31;
                case 1:
                  memset(v42, 0, 64);
                  uint64_t v23 = (int)v18 + 3LL;
                  icu::UnicodeString::tempSubString( v33,  *(_DWORD *)(*(void *)&v19 + 16LL * (int)v18 + 36),  *(unsigned __int16 *)(*(void *)&v19 + 16LL * (int)v18 + 40),  (icu::UnicodeString *)v42);
                  uint64_t v41 = 0LL;
                  __int128 v39 = 0u;
                  __int128 v40 = 0u;
                  __int128 v38 = 0u;
                  __int128 v37 = off_18971B688;
                  LOWORD(v38) = 2;
                  int32x2_t v24 = this[80];
                  if (*(_DWORD *)(*(void *)&v24 + 16 * v23) == 10)
                  {
                    icu::UnicodeString::tempSubString( v33,  *(_DWORD *)(*(void *)&v24 + 16 * v23 + 4),  *(unsigned __int16 *)(*(void *)&v24 + 16 * v23 + 8),  (icu::UnicodeString *)v35);
                    icu::UnicodeString::operator=((icu::UnicodeString *)&v37, (icu::UnicodeString *)v35);
                    icu::UnicodeString::~UnicodeString(v25, (icu::UnicodeString *)v35);
                    LODWORD(v23) = v18 + 4;
                  }

                  uint64_t v36 = 0LL;
                  memset(v35, 0, sizeof(v35));
                  uint64_t v26 = (icu::Format *)icu::MessageFormat::createAppropriateFormat( (uint64_t)this,  (uint64_t)v42,  (icu::UnicodeString *)&v37,  &v34,  (uint64_t)v35,  a2);
                  icu::MessageFormat::setArgStartFormat(this, v18, v26, a2);
                  icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)&v37);
                  icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)v42);
                  LODWORD(v18) = v23;
                  break;
                case 2:
                case 3:
                case 5:
                  int v34 = 1;
                  break;
                default:
                  *a2 = U_INTERNAL_PROGRAM_ERROR;
LABEL_31:
                  int v34 = 3;
                  break;
              }

              if (v21 != -1)
              {
                int32x2_t v29 = this[87];
                int v30 = *(_DWORD *)(*(void *)&v29 + 4LL * v21);
                int v31 = v34;
                if (v30 != 6 && v30 != v34) {
                  this[89].i8[0] = 1;
                }
                *(_DWORD *)(*(void *)&v29 + 4LL * v2sub_1808F7164((uint64_t)v14, 1) = v31;
              }

              UErrorCode v17 = *a2;
            }

            unint64_t v18 = (v18 + 1);
          }

          while ((int)v18 < (int)v8 && v17 < U_ILLEGAL_ARGUMENT_ERROR);
        }
      }
    }
  }

uint64_t icu::MessageFormat::applyPattern(_DWORD *a1, uint64_t a2, int a3, _OWORD *a4, uint64_t a5)
{
  if (a1[140] != a3)
  {
    icu::MessagePattern::clear((uint64_t)(a1 + 138));
    a1[140] = a3;
  }

  uint64_t v13 = 0LL;
  memset(v12, 0, sizeof(v12));
  if (a4) {
    unsigned int v10 = a4;
  }
  else {
    unsigned int v10 = v12;
  }
  return (*(uint64_t (**)(_DWORD *, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88LL))(a1, a2, v10, a5);
}

icu::UnicodeString *icu::MessageFormat::toPattern(icu::MessageFormat *this, icu::UnicodeString *a2)
{
  uint64_t v4 = *((void *)this + 93);
  if (v4 && uhash_count(v4) || !*((_DWORD *)this + 162))
  {
    icu::UnicodeString::setToBogus(a2);
    return a2;
  }

  else
  {
    unsigned int v5 = *((unsigned __int16 *)this + 288);
    int v6 = (__int16)v5;
    unsigned int v7 = v5 >> 5;
    if (v6 >= 0) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = *((unsigned int *)this + 145);
    }
    return (icu::UnicodeString *)icu::UnicodeString::doAppend( (uint64_t)a2,  (icu::MessageFormat *)((char *)this + 568),  0,  v8);
  }

uint64_t icu::MessageFormat::nextTopLevelArgStart(icu::MessageFormat *this, int a2)
{
  uint64_t v2 = *((void *)this + 80);
  if (a2)
  {
    int v3 = *(_DWORD *)(v2 + 16LL * a2 + 12);
    if (v3 <= a2) {
      int v3 = a2;
    }
    uint64_t result = v3;
  }

  else
  {
    uint64_t result = 0LL;
  }

  unsigned int v5 = (int *)(v2 + 16 * result + 16);
  while (1)
  {
    int v7 = *v5;
    v5 += 4;
    int v6 = v7;
    if (v7 == 1) {
      break;
    }
    uint64_t result = (result + 1);
    if (v6 == 5) {
      return result;
    }
  }

  return 0xFFFFFFFFLL;
}

int32x2_t *icu::MessageFormat::setArgStartFormat( int32x2_t *this, unint64_t a2, icu::Format *a3, UErrorCode *a4)
{
  uint64_t v4 = a3;
  if (*(int *)a4 < 1)
  {
    unsigned int v6 = a2;
    int v7 = this;
    uint64_t v8 = (uint64_t *)this[92];
    if (v8)
    {
      if (!a3)
      {
LABEL_6:
        UErrorCode v9 = icu::UMemory::operator new(v8, (icu::UMemory *)0x148, a2);
        uint64_t v4 = (icu::Format *)v9;
        if (v9)
        {
          v9[40] = 0LL;
          *((_OWORD *)v9 + 18) = 0u;
          *((_OWORD *)v9 + 19) = 0u;
          *((_OWORD *)v9 + 16) = 0u;
          *((_OWORD *)v9 + 17) = 0u;
          *((_OWORD *)v9 + 14) = 0u;
          *((_OWORD *)v9 + 15) = 0u;
          *((_OWORD *)v9 + 12) = 0u;
          *((_OWORD *)v9 + 13) = 0u;
          *((_OWORD *)v9 + 10) = 0u;
          *((_OWORD *)v9 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
          *((_OWORD *)v9 + 8) = 0u;
          *((_OWORD *)v9 + 9) = 0u;
          *((_OWORD *)v9 + 6) = 0u;
          *((_OWORD *)v9 + 7) = 0u;
          *((_OWORD *)v9 + 4) = 0u;
          *((_OWORD *)v9 + 5) = 0u;
          *((_OWORD *)v9 + 2) = 0u;
          *((_OWORD *)v9 + 3) = 0u;
          *(_OWORD *)UErrorCode v9 = 0u;
          *((_OWORD *)v9 + sub_1808F7164((uint64_t)v14, 1) = 0u;
          icu::Format::Format((uint64_t)v9);
          *(void *)uint64_t v4 = &off_189726BA0;
        }
      }
    }

    else
    {
      this = uhash_open((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, (uint64_t)sub_18090FD28, (int *)a4);
      v7[92] = (int32x2_t)this;
      if (*(int *)a4 >= 1)
      {
        if (v4) {
          return (int32x2_t *)(*(uint64_t (**)(icu::Format *))(*(void *)v4 + 8LL))(v4);
        }
        return this;
      }

      uhash_setValueDeleter((uint64_t)this, (uint64_t)uprv_deleteUObject);
      if (!v4) {
        goto LABEL_6;
      }
    }

    return (int32x2_t *)uhash_iput(*(void *)&v7[92], v6, (uint64_t)v4, (int *)a4);
  }

  if (a3) {
    return (int32x2_t *)(*(uint64_t (**)(icu::Format *))(*(void *)v4 + 8LL))(v4);
  }
  return this;
}

uint64_t sub_18090FD28(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
}

BOOL icu::MessageFormat::argNameMatches( icu::MessageFormat *this, int a2, const icu::UnicodeString *a3, int a4)
{
  uint64_t v4 = *((void *)this + 80);
  if (*(_DWORD *)(v4 + 16LL * a2) == 8) {
    return sub_18090FD7C((uint64_t)this + 552, v4 + 16LL * a2, (uint64_t)a3);
  }
  else {
    return *(__int16 *)(v4 + 16LL * a2 + 10) == a4;
  }
}

BOOL sub_18090FD7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a3 + 8);
  if ((v3 & 1) != 0)
  {
    int v9 = (*(_WORD *)(a1 + 24) & 1) == 0;
  }

  else
  {
    uint64_t v4 = a1 + 16;
    int32_t v5 = *(unsigned __int16 *)(a2 + 8);
    int v6 = *(_DWORD *)(a2 + 4);
    if ((v3 & 0x8000u) == 0) {
      int v7 = v3 >> 5;
    }
    else {
      int v7 = *(_DWORD *)(a3 + 12);
    }
    if ((v3 & 2) != 0) {
      uint64_t v8 = a3 + 10;
    }
    else {
      uint64_t v8 = *(void *)(a3 + 24);
    }
    int v9 = icu::UnicodeString::doCompare(v4, v6, v5, v8, v7 & (v7 >> 31), v7 & ~(v7 >> 31));
  }

  return v9 == 0;
}

uint64_t icu::MessageFormat::setCustomArgStartFormat( int32x2_t *this, unint64_t a2, icu::Format *a3, UErrorCode *a4)
{
  unsigned int v5 = a2;
  icu::MessageFormat::setArgStartFormat(this, a2, a3, a4);
  int v7 = (int32x2_t *)this[93];
  if (!v7)
  {
    int v7 = uhash_open((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, 0LL, (int *)a4);
    this[93] = (int32x2_t)v7;
  }

  return uhash_iputi((uint64_t)v7, v5, 1u, (int *)a4);
}

const void *icu::MessageFormat::getCachedFormatter(icu::MessageFormat *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 92);
  if (!v2) {
    return 0LL;
  }
  unsigned int v3 = (const void *)uhash_iget(v2, a2);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  {
    return 0LL;
  }

  return v4;
}

int32x2_t *icu::MessageFormat::adoptFormats(int32x2_t *this, icu::Format **a2, unsigned int a3)
{
  if (a2 && (a3 & 0x80000000) == 0)
  {
    unsigned int v5 = this;
    uint64_t v6 = (uint64_t)this[92];
    if (v6) {
      uhash_removeAll(v6);
    }
    this = (int32x2_t *)v5[93];
    if (this) {
      this = (int32x2_t *)uhash_removeAll((uint64_t)this);
    }
    UErrorCode v16 = U_ZERO_ERROR;
    if (a3)
    {
      unint64_t v7 = 0LL;
      LODWORD(v8) = 0;
LABEL_9:
      int32x2_t v9 = v5[80];
      if ((_DWORD)v8)
      {
        int v10 = *(_DWORD *)(*(void *)&v9 + 16LL * v8 + 12);
        else {
          unint64_t v8 = v10;
        }
      }

      else
      {
        unint64_t v8 = 0LL;
      }

      uint64_t v11 = (int *)(*(void *)&v9 + 16 * v8 + 16);
      while (1)
      {
        int v13 = *v11;
        v11 += 4;
        int v12 = v13;
        if (v13 == 1) {
          break;
        }
        unint64_t v8 = (v8 + 1);
        if (v12 == 5)
        {
          if ((v8 & 0x80000000) == 0)
          {
            this = (int32x2_t *)icu::MessageFormat::setCustomArgStartFormat(v5, v8, a2[v7++], &v16);
            if (v7 < a3 && v16 <= U_ZERO_ERROR) {
              goto LABEL_9;
            }
          }

          break;
        }
      }
    }

    else
    {
      LODWORD(v7) = 0;
    }

    if ((int)v7 < (int)a3)
    {
      int v14 = &a2[v7];
      unint64_t v15 = a3 - (unint64_t)v7;
      do
      {
        this = (int32x2_t *)*v14;
        if (*v14) {
          this = (int32x2_t *)(*(uint64_t (**)(int32x2_t *))(*(void *)this + 8LL))(this);
        }
        ++v14;
        --v15;
      }

      while (v15);
    }
  }

  return this;
}

void icu::MessageFormat::setFormats(int32x2_t *this, const icu::Format **a2, unsigned int a3)
{
  if (a2 && (a3 & 0x80000000) == 0)
  {
    uint64_t v6 = (uint64_t)this[92];
    if (v6) {
      uhash_removeAll(v6);
    }
    uint64_t v7 = (uint64_t)this[93];
    if (v7) {
      uhash_removeAll(v7);
    }
    UErrorCode v18 = U_ZERO_ERROR;
    if (a3)
    {
      UErrorCode v8 = U_ZERO_ERROR;
      unint64_t v9 = 0LL;
      LODWORD(v10) = 0;
LABEL_9:
      int32x2_t v11 = this[80];
      if ((_DWORD)v10)
      {
        int v12 = *(_DWORD *)(*(void *)&v11 + 16LL * v10 + 12);
        else {
          unint64_t v10 = v12;
        }
      }

      else
      {
        unint64_t v10 = 0LL;
      }

      int v13 = (int *)(*(void *)&v11 + 16 * v10 + 16);
      while (1)
      {
        int v15 = *v13;
        v13 += 4;
        int v14 = v15;
        if (v15 == 1) {
          break;
        }
        unint64_t v10 = (v10 + 1);
        if (v14 == 5)
        {
          if ((v10 & 0x80000000) == 0)
          {
            UErrorCode v16 = a2[v9];
            if (v16)
            {
              UErrorCode v17 = (icu::Format *)(*(uint64_t (**)(const icu::Format *))(*(void *)v16 + 32LL))(v16);
              if (!v17) {
                UErrorCode v18 = U_MEMORY_ALLOCATION_ERROR;
              }
            }

            else
            {
              UErrorCode v17 = 0LL;
            }

            icu::MessageFormat::setCustomArgStartFormat(this, v10, v17, &v18);
            ++v9;
            UErrorCode v8 = v18;
            if (v9 < a3 && v18 <= U_ZERO_ERROR) {
              goto LABEL_9;
            }
          }

          break;
        }
      }

      if (v8 >= U_ILLEGAL_ARGUMENT_ERROR) {
        icu::MessageFormat::resetPattern((icu::MessageFormat *)this);
      }
    }
  }

int32x2_t *icu::MessageFormat::adoptFormat(int32x2_t *this, int a2, icu::Format *a3)
{
  if ((a2 & 0x80000000) == 0)
  {
    int v4 = 0;
    LODWORD(v5) = 0;
    int32x2_t v6 = this[80];
LABEL_3:
    if ((_DWORD)v5)
    {
      int v7 = *(_DWORD *)(*(void *)&v6 + 16LL * v5 + 12);
      else {
        unint64_t v5 = v7;
      }
    }

    else
    {
      unint64_t v5 = 0LL;
    }

    UErrorCode v8 = (int *)(*(void *)&v6 + 16LL + 16 * v5);
    while (1)
    {
      int v10 = *v8;
      v8 += 4;
      int v9 = v10;
      if (v10 == 1) {
        break;
      }
      unint64_t v5 = (v5 + 1);
      if (v9 == 5)
      {
        if ((v5 & 0x80000000) != 0) {
          break;
        }
        if (v4++ == a2)
        {
          UErrorCode v12 = U_ZERO_ERROR;
          return (int32x2_t *)icu::MessageFormat::setCustomArgStartFormat(this, v5, a3, &v12);
        }

        goto LABEL_3;
      }
    }
  }

  if (a3) {
    return (int32x2_t *)(*(uint64_t (**)(icu::Format *))(*(void *)a3 + 8LL))(a3);
  }
  return this;
}

uint64_t icu::MessageFormat::adoptFormat( uint64_t this, const icu::UnicodeString *a2, icu::Format *a3, UErrorCode *a4)
{
  if (*(int *)a4 > 0)
  {
LABEL_4:
    if (a3) {
      return (*(uint64_t (**)(icu::Format *))(*(void *)a3 + 8LL))(a3);
    }
    return this;
  }

  int v7 = (int32x2_t *)this;
  this = icu::MessagePattern::validateArgumentName(a2, a2);
  if ((int)this < -1)
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    goto LABEL_4;
  }

  int v8 = this;
  unsigned int v9 = 0;
  int v10 = a3;
LABEL_7:
  int32x2_t v11 = v7[80];
  if (v9)
  {
    unsigned int v12 = *(_DWORD *)(*(void *)&v11 + 16LL * v9 + 12);
    else {
      uint64_t v13 = v12;
    }
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  uint64_t v14 = 0LL;
  int v15 = (int *)(*(void *)&v11 + 16 * v13 + 16);
  while (1)
  {
    int v17 = *v15;
    v15 += 4;
    int v16 = v17;
    if (v17 == 1) {
      break;
    }
    ++v14;
    if (v16 == 5)
    {
      unsigned int v9 = v13 + v14;
      if ((((_DWORD)v13 + (_DWORD)v14) & 0x80000000) == 0 && *(int *)a4 <= 0)
      {
        uint64_t v18 = (v13 + v14 + 1);
        int32x2_t v19 = (_DWORD *)(*(void *)&v11 + 16LL * v18);
        if (*v19 == 8)
        {
          this = sub_18090FD7C((uint64_t)&v7[69], (uint64_t)v19, (uint64_t)a2);
          if (!(_DWORD)this) {
            goto LABEL_7;
          }
        }

        else
        {
          this = v8 == *(__int16 *)(*(void *)&v11 + 16 * v18 + 10);
        }

        if (v10
          || !a3
          || (this = (*(uint64_t (**)(icu::Format *))(*(void *)a3 + 32LL))(a3),
              (int v10 = (icu::Format *)this) != 0LL))
        {
          unint64_t v20 = v13 + v14;
          this = icu::MessageFormat::setCustomArgStartFormat(v7, v20, v10, a4);
          int v10 = 0LL;
          unsigned int v9 = v20;
          goto LABEL_7;
        }

        *a4 = U_MEMORY_ALLOCATION_ERROR;
        return this;
      }

      break;
    }
  }

  a3 = v10;
  if (v10) {
    return (*(uint64_t (**)(icu::Format *))(*(void *)a3 + 8LL))(a3);
  }
  return this;
}

int32x2_t *icu::MessageFormat::setFormat(int32x2_t *this, int a2, const icu::Format *a3)
{
  if ((a2 & 0x80000000) == 0)
  {
    unsigned int v3 = this;
    int v4 = 0;
    LODWORD(v5) = 0;
    int32x2_t v6 = this[80];
LABEL_3:
    if ((_DWORD)v5)
    {
      int v7 = *(_DWORD *)(*(void *)&v6 + 16LL * v5 + 12);
      else {
        unint64_t v5 = v7;
      }
    }

    else
    {
      unint64_t v5 = 0LL;
    }

    int v8 = (int *)(*(void *)&v6 + 16LL + 16 * v5);
    while (1)
    {
      int v10 = *v8;
      v8 += 4;
      int v9 = v10;
      if (v10 == 1) {
        break;
      }
      unint64_t v5 = (v5 + 1);
      if (v9 == 5)
      {
        if ((v5 & 0x80000000) != 0) {
          return this;
        }
        if (v4++ == a2)
        {
          this = (int32x2_t *)(*(uint64_t (**)(const icu::Format *))(*(void *)a3 + 32LL))(a3);
          if (this)
          {
            UErrorCode v12 = U_ZERO_ERROR;
            return (int32x2_t *)icu::MessageFormat::setCustomArgStartFormat(v3, v5, (icu::Format *)this, &v12);
          }

          return this;
        }

        goto LABEL_3;
      }
    }
  }

  return this;
}

const void *icu::MessageFormat::getFormat( icu::MessageFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0 && *((void *)this + 92))
  {
    int v7 = icu::MessagePattern::validateArgumentName(a2, a2);
    if (v7 >= -1)
    {
      int v8 = v7;
      unsigned int v9 = 0;
LABEL_7:
      uint64_t v10 = *((void *)this + 80);
      if (v9)
      {
        unsigned int v11 = *(_DWORD *)(v10 + 16LL * v9 + 12);
        else {
          uint64_t v12 = v11;
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      int v13 = 0;
      uint64_t v14 = (int *)(v10 + 16 * v12 + 16);
      while (1)
      {
        int v16 = *v14;
        v14 += 4;
        int v15 = v16;
        if (v16 == 1) {
          break;
        }
        ++v13;
        if (v15 == 5)
        {
          unsigned int v9 = v12 + v13;
          if ((_DWORD)v12 + v13 < 0) {
            return 0LL;
          }
          uint64_t v17 = (v12 + v13 + 1);
          uint64_t v18 = (_DWORD *)(v10 + 16LL * v17);
          if (*v18 == 8)
          {
          }

          else if (v8 != *(__int16 *)(v10 + 16 * v17 + 10))
          {
            goto LABEL_7;
          }

          return icu::MessageFormat::getCachedFormatter(this, (int)v12 + v13);
        }
      }
    }

    else
    {
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  return 0LL;
}

uint64_t icu::MessageFormat::setFormat( uint64_t this, const icu::UnicodeString *a2, const icu::Format *a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    int v7 = (int32x2_t *)this;
    this = icu::MessagePattern::validateArgumentName(a2, a2);
    if ((int)this >= -1)
    {
      int v9 = this;
      LODWORD(v10) = 0;
LABEL_7:
      int32x2_t v11 = v7[80];
      if ((_DWORD)v10)
      {
        LODWORD(v12) = *(_DWORD *)(*(void *)&v11 + 16LL * v10 + 12);
        else {
          uint64_t v12 = v12;
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      uint64_t v13 = 0LL;
      uint64_t v14 = (int *)(*(void *)&v11 + 16 * v12 + 16);
      while (1)
      {
        int v16 = *v14;
        v14 += 4;
        int v15 = v16;
        if (v16 == 1) {
          break;
        }
        ++v13;
        if (v15 == 5)
        {
          unint64_t v10 = v12 + v13;
          uint64_t v17 = (v12 + v13 + 1);
          uint64_t v18 = (_DWORD *)(*(void *)&v11 + 16LL * v17);
          if (*v18 == 8)
          {
            this = sub_18090FD7C((uint64_t)&v7[69], (uint64_t)v18, (uint64_t)a2);
            if (!(_DWORD)this) {
              goto LABEL_7;
            }
          }

          else
          {
            this = v9 == *(__int16 *)(*(void *)&v11 + 16 * v17 + 10);
          }

          this = (*(uint64_t (**)(const icu::Format *))(*(void *)a3 + 32LL))(a3);
          if (this)
          {
            this = icu::MessageFormat::setCustomArgStartFormat(v7, v10, (icu::Format *)this, a4);
            goto LABEL_7;
          }

          UErrorCode v8 = U_MEMORY_ALLOCATION_ERROR;
          goto LABEL_4;
        }
      }
    }

    else
    {
      UErrorCode v8 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_4:
      *a4 = v8;
    }
  }

  return this;
}

void *icu::MessageFormat::getFormats(icu::MessageFormat *this, int *a2)
{
  unsigned int v4 = 0;
  uint64_t v5 = *((void *)this + 80);
LABEL_5:
  uint64_t v7 = 0LL;
LABEL_6:
  UErrorCode v8 = (int *)(v5 + 16 + 16 * v7);
  while (1)
  {
    int v10 = *v8;
    v8 += 4;
    int v9 = v10;
    if (v10 == 1) {
      break;
    }
    LODWORD(v7) = v7 + 1;
    if (v9 == 5)
    {
      if ((v7 & 0x80000000) != 0) {
        break;
      }
      ++v4;
      if ((_DWORD)v7)
      {
        int v6 = *(_DWORD *)(v5 + 16LL * v7 + 12);
        else {
          uint64_t v7 = v6;
        }
        goto LABEL_6;
      }

      goto LABEL_5;
    }
  }

  *a2 = 0;
  int32x2_t v11 = (void *)*((void *)this + 85);
  if (v11)
  {
    uint64_t result = uprv_realloc(v11, 8LL * v4);
    if (result)
    {
      *((void *)this + 85) = result;
      *((_DWORD *)this + 172) = v4;
      goto LABEL_18;
    }

icu::UnicodeString *icu::MessageFormat::getArgName@<X0>( icu::MessageFormat *this@<X0>, int a2@<W1>, icu::UnicodeString *a3@<X8>)
{
  return icu::UnicodeString::tempSubString( (icu::MessageFormat *)((char *)this + 568),  *(_DWORD *)(*((void *)this + 80) + 16LL * a2 + 4),  *(unsigned __int16 *)(*((void *)this + 80) + 16LL * a2 + 8),  a3);
}

uint64_t icu::MessageFormat::getFormatNames(icu::MessageFormat *this, UErrorCode *a2)
{
  _BYTE v22[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t v2 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v2 <= 0)
  {
    uint64_t v5 = (icu::UVector *)icu::UMemory::operator new(v2, (icu::UMemory *)0x28, (unint64_t)a2);
    if (v5)
    {
      int v6 = v5;
      icu::UVector::UVector(v5, a2);
      if (*(int *)a2 <= 0)
      {
        icu::UVector::setDeleter(v6, (void (*)(void *))uprv_deleteUObject);
        unsigned int v9 = 0;
LABEL_10:
        int v10 = (uint64_t *)*((void *)this + 80);
        if (v9)
        {
          LODWORD(v1sub_1808F7164((uint64_t)v14, 1) = HIDWORD(v10[2 * v9 + 1]);
          else {
            uint64_t v11 = v11;
          }
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        int v12 = 0;
        uint64_t v13 = &v10[2 * v11 + 2];
        while (1)
        {
          int v15 = *(_DWORD *)v13;
          v13 += 2;
          int v14 = v15;
          if (v15 == 1) {
            break;
          }
          ++v12;
          if (v14 == 5)
          {
            unsigned int v9 = v11 + v12;
            if ((((_DWORD)v11 + v12) & 0x80000000) == 0)
            {
              int v16 = &v10[2 * (v11 + v12 + 1)];
              icu::UnicodeString::tempSubString( (icu::MessageFormat *)((char *)this + 568),  *((_DWORD *)v16 + 1),  *((unsigned __int16 *)v16 + 4),  (icu::UnicodeString *)v22);
              uint64_t v20 = icu::UnicodeString::clone(v22, v17, v18);
              if (!v20)
              {
                int32x2_t v19 = (void *)*(unsigned int *)a2;
              }

              icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v22);
              icu::UVector::adoptElement(v6, v20, a2);
              goto LABEL_4;
            }

            break;
          }
        }

        uint64_t v21 = icu::UMemory::operator new(v10, (icu::UMemory *)0x80, v8);
        if (!v21)
        {
          goto LABEL_4;
        }

        uint64_t result = icu::StringEnumeration::StringEnumeration((uint64_t)v21);
        *(void *)uint64_t result = off_189726AF8;
        *(_DWORD *)(result + 116) = 0;
        *(void *)(result + 120) = v6;
        (*(void (**)(uint64_t))(*(void *)result + 8LL))(result);
      }

      else
      {
LABEL_4:
        (*(void (**)(icu::UVector *))(*(void *)v6 + 8LL))(v6);
      }
    }

    else if (*(int *)a2 <= 0)
    {
      uint64_t result = 0LL;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      return result;
    }
  }

  return 0LL;
}

icu::UnicodeString *icu::MessageFormat::format( icu::MessageFormat *this, const icu::Formattable *a2, unsigned int a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  return icu::MessageFormat::format(this, a2, 0LL, a3, a4, a5, a6);
}

icu::UnicodeString *icu::MessageFormat::format( icu::MessageFormat *this, const icu::Formattable *a2, const icu::UnicodeString *a3, unsigned int a4, icu::UnicodeString *a5, icu::FieldPosition *a6, UErrorCode *a7)
{
  if (*(int *)a7 <= 0)
  {
    v10[0] = &unk_18971B6F0;
    v10[1] = a5;
    v9[0] = (uint64_t)v10;
    v9[1] = 0LL;
    icu::MessageFormat::format((char *)this, 0, 0LL, a2, a3, a4, v9, (uint64_t)a6, a7);
    icu::UnicodeStringAppendable::~UnicodeStringAppendable((icu::UnicodeStringAppendable *)v10);
  }

  return a5;
}

icu::UnicodeString *icu::MessageFormat::format( icu::MessageFormat *this, const icu::UnicodeString *a2, const icu::Formattable *a3, icu::UnicodeString *a4, UErrorCode *a5, UErrorCode *a6)
{
  unsigned int v8 = a3;
  uint64_t v13 = *MEMORY[0x1895F89C0];
  bzero(v12, 0x330uLL);
  icu::MessageFormat::MessageFormat((icu::MessageFormat *)v12, this, a5);
  icu::MessageFormat::format((icu::MessageFormat *)v12, a2, 0LL, v8, a4, 0LL, a5);
  icu::MessageFormat::~MessageFormat((icu::MessageFormat *)v12);
  return a4;
}

icu::UnicodeString *icu::MessageFormat::format( icu::MessageFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    else {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  return a3;
}

icu::UnicodeString *icu::MessageFormat::format( icu::MessageFormat *this, const icu::UnicodeString *a2, const icu::Formattable *a3, unsigned int a4, icu::UnicodeString *a5, UErrorCode *a6)
{
  return icu::MessageFormat::format(this, a3, a2, a4, a5, 0LL, a6);
}

const icu::Formattable *icu::MessageFormat::getArgFromListByName( icu::MessageFormat *this, const icu::Formattable *a2, const icu::UnicodeString *a3, int a4, icu::UnicodeString *a5)
{
  if (a4 >= 1)
  {
    unsigned int v8 = (char *)a5 + 10;
    for (uint64_t i = a4; i; --i)
    {
      unsigned int v10 = *((unsigned __int16 *)a3 + 4);
      else {
        int32_t v11 = v10 >> 5;
      }
      unsigned int v12 = *((unsigned __int16 *)a5 + 4);
      if ((v12 & 1) != 0)
      {
        if ((v10 & 1) != 0) {
          return a2;
        }
      }

      else
      {
        if ((v12 & 0x8000u) == 0) {
          int v13 = v12 >> 5;
        }
        else {
          int v13 = *((_DWORD *)a5 + 3);
        }
        if ((v12 & 2) != 0) {
          uint64_t v14 = (uint64_t)v8;
        }
        else {
          uint64_t v14 = *((void *)a5 + 3);
        }
        if (!icu::UnicodeString::doCompare( (uint64_t)a3,  0,  v11,  v14,  v13 & (v13 >> 31),  v13 & ~(v13 >> 31))) {
          return a2;
        }
      }

      a2 = (const icu::Formattable *)((char *)a2 + 112);
      a3 = (const icu::UnicodeString *)((char *)a3 + 64);
    }
  }

  return 0LL;
}

char *icu::MessageFormat::format( char *result, int a2, uint64_t a3, const icu::Formattable *a4, const icu::UnicodeString *a5, unsigned int a6, uint64_t *a7, uint64_t a8, UErrorCode *a9)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  if (*(int *)a9 <= 0)
  {
    LODWORD(v10) = a2;
    int32_t v11 = (icu::MessageFormat *)result;
    uint64_t v67 = (icu::UnicodeString *)(result + 568);
    uint64_t v12 = *((void *)result + 80) + 16LL * a2;
    int v13 = *(_DWORD *)(v12 + 4) + *(unsigned __int16 *)(v12 + 8);
    uint64_t v60 = a3 + 152;
    int v61 = (icu::Formattable *)(a3 + 16);
    uint64_t v58 = (icu::MessagePattern *)(result + 552);
    unsigned int v59 = (icu::Locale *)(result + 328);
    uint64_t v56 = result + 784;
    int v57 = result + 752;
    do
    {
      uint64_t v14 = (int)v10;
      uint64_t v10 = (int)v10 + 1LL;
      uint64_t v15 = *((void *)v11 + 80);
      int v16 = (int *)(v15 + 16 * v10);
      int v17 = *v16;
      uint64_t result = (char *)sub_1809112EC(a7, v67, v13, v16[1] - v13);
      if (v17 == 1) {
        return result;
      }
      if (v17 != 5)
      {
        int v13 = v16[1] + *((unsigned __int16 *)v16 + 4);
        if (v17 == 4)
        {
          if (*(_BYTE *)(a3 + 216))
          {
            uint64_t result = (char *)sub_180911364(a7, *(icu::Format **)(a3 + 144), v61, v60, a9);
          }

          else
          {
            DefaultNumberFormat = icu::MessageFormat::getDefaultNumberFormat(v11, a9, v18);
            uint64_t result = (char *)sub_1809113F8(a7, DefaultNumberFormat, v61, a9);
          }
        }

        continue;
      }

      uint64_t v19 = *((void *)v11 + 80);
      else {
        int v20 = *(_DWORD *)(v19 + 16 * v10 + 12);
      }
      else {
        int v21 = *(__int16 *)(v15 + 16 * v10 + 10);
      }
      memset(v75, 0, sizeof(v75));
      uint64_t v22 = v19 + 16 * (v14 + 2);
      uint64_t v23 = icu::UnicodeString::tempSubString( v67,  *(_DWORD *)(v22 + 4),  *(unsigned __int16 *)(v22 + 8),  (icu::UnicodeString *)v75);
      if (a5)
      {
        ArgFromListByName = icu::MessageFormat::getArgFromListByName(v23, a4, a5, a6, (icu::UnicodeString *)v75);
        if (!ArgFromListByName) {
          goto LABEL_27;
        }
      }

      else
      {
        signed int v26 = *(__int16 *)(v22 + 10);
        if (v26 < 0 || v26 >= (int)a6)
        {
LABEL_27:
          icu::UnicodeString::UnicodeString((uint64_t)&v68, 123);
          if ((SWORD4(v75[0]) & 0x8000u) == 0) {
            uint64_t v28 = WORD4(v75[0]) >> 5;
          }
          else {
            uint64_t v28 = HIDWORD(v75[0]);
          }
          uint64_t v29 = icu::UnicodeString::doAppend((uint64_t)&v68, (const icu::UnicodeString *)v75, 0, v28);
          LOWORD(v70) = 125;
          uint64_t v30 = icu::UnicodeString::doAppend(v29, (uint64_t)&v70, 0, 1LL);
          sub_1809114A8(a7, v30);
          uint64_t v32 = (icu::UnicodeString *)&v68;
LABEL_54:
          icu::UnicodeString::~UnicodeString(v31, v32);
          goto LABEL_55;
        }

        if (!a4)
        {
          (*(void (**)(uint64_t, const __int16 *, uint64_t))(*(void *)*a7 + 40LL))(*a7, L"null", 4LL);
          *((_DWORD *)a7 + 2) += 4;
          goto LABEL_55;
        }

        ArgFromListByName = (const icu::Formattable *)((char *)a4 + 112 * v26);
      }

      if (a3 && *(_DWORD *)(a3 + 136) == (_DWORD)v10)
      {
        DateTimeuint64_t Instance = *(icu::DecimalFormat **)(a3 + 144);
        sub_180911364(a7, DateTimeInstance, v61, v60, a9);
      }

      else
      {
        CachedFormatter = (icu::Format *)icu::MessageFormat::getCachedFormatter(v11, v10);
        if (CachedFormatter)
        {
          int v34 = CachedFormatter;
          {
            uint64_t v74 = 0LL;
            __int128 v72 = 0u;
            __int128 v73 = 0u;
            __int128 v71 = 0u;
            uint64_t v70 = off_18971B688;
            LOWORD(v7sub_1808F7164((uint64_t)v14, 1) = 2;
            icu::Format::format(v34, ArgFromListByName, (icu::UnicodeString *)&v70, a9);
            if ((v71 & 0x8000u) == 0LL) {
              int32_t v35 = (unsigned __int16)v71 >> 5;
            }
            else {
              int32_t v35 = DWORD1(v71);
            }
            if ((icu::UnicodeString::doIndexOf((uint64_t)&v70, 0x7Bu, 0, v35) & 0x80000000) != 0
              && ((v71 & 0x8000u) == 0LL ? (int32_t v39 = (unsigned __int16)v71 >> 5) : (int32_t v39 = DWORD1(v71)),
                  (icu::UnicodeString::doIndexOf((uint64_t)&v70, 0x27u, 0, v39) & 0x80000000) != 0
               || *((_DWORD *)v11 + 140) == 1))
            {
              sub_1809114A8(a7, (uint64_t)&v70);
            }

            else
            {
              bzero(&v68, 0x330uLL);
              icu::MessageFormat::MessageFormat((icu::MessageFormat *)&v68, (const icu::UnicodeString *)&v70, v59, a9);
              icu::MessageFormat::format(&v68, 0LL, 0LL, a4, a5, a6, a7, a8, a9);
              icu::MessageFormat::~MessageFormat((icu::MessageFormat *)&v68);
            }

            uint64_t v32 = (icu::UnicodeString *)&v70;
            goto LABEL_54;
          }

          __int128 v38 = a7;
          DateTimeuint64_t Instance = v34;
          goto LABEL_46;
        }

        if (!v21 || (uint64_t v36 = *((void *)v11 + 92)) != 0 && uhash_iget(v36, v10))
        {
          if (icu::Formattable::isNumeric(ArgFromListByName))
          {
            DateTimeuint64_t Instance = icu::MessageFormat::getDefaultNumberFormat(v11, a9, v37);
          }

          else
          {
            if (icu::Formattable::getType(ArgFromListByName))
            {
              uint64_t String = icu::Formattable::getString(ArgFromListByName, a9);
              sub_1809114A8(a7, String);
              goto LABEL_55;
            }

            DateTimeuint64_t Instance = (icu::DecimalFormat *)*((void *)v11 + 91);
            if (!DateTimeInstance)
            {
              DateTimeuint64_t Instance = icu::DateFormat::createDateTimeInstance(3, 3LL, v59);
              *((void *)v11 + 9sub_1808F7164((uint64_t)v14, 1) = DateTimeInstance;
              if (!DateTimeInstance) {
                *a9 = U_MEMORY_ALLOCATION_ERROR;
              }
            }
          }

void *sub_1809112EC(uint64_t *a1, icu::UnicodeString *this, int a3, int32_t a4)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  icu::UnicodeString::tempSubString(this, a3, a4, (icu::UnicodeString *)v7);
  sub_1809114A8(a1, (uint64_t)v7);
  return icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v7);
}

uint64_t *sub_180911364(uint64_t *result, icu::Format *a2, icu::Formattable *a3, uint64_t a4, UErrorCode *a5)
{
  return result;
}

icu::DecimalFormat *icu::MessageFormat::getDefaultNumberFormat( icu::MessageFormat *this, UErrorCode *a2, UErrorCode *a3)
{
  uint64_t result = (icu::DecimalFormat *)*((void *)this + 90);
  if (!result)
  {
    uint64_t result = icu::NumberFormat::createInstance((char **)this + 41, a2, a3);
    *((void *)this + 90) = result;
    if (*(int *)a2 < 1)
    {
      if (!result) {
        *a2 = U_MEMORY_ALLOCATION_ERROR;
      }
    }

    else
    {
      if (result) {
        (*(void (**)(icu::DecimalFormat *))(*(void *)result + 8LL))(result);
      }
      uint64_t result = 0LL;
      *((void *)this + 90) = 0LL;
    }
  }

  return result;
}

void *sub_1809113F8(uint64_t *a1, icu::Format *this, icu::Formattable *a3, UErrorCode *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  uint64_t v12 = 0LL;
  __int128 v11 = 0u;
  uint64_t v8 = off_18971B688;
  LOWORD(v9) = 2;
  icu::Format::format(this, a3, (icu::UnicodeString *)&v8, a4);
  int v6 = (void *)*(unsigned int *)a4;
  return icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)&v8);
}

uint64_t sub_1809114A8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
  if ((v5 & 0x11) != 0)
  {
    uint64_t v6 = 0LL;
  }

  else if ((v5 & 2) != 0)
  {
    uint64_t v6 = a2 + 10;
  }

  else
  {
    uint64_t v6 = *(void *)(a2 + 24);
  }

  int v7 = (__int16)v5;
  unsigned int v8 = v5 >> 5;
  if (v7 >= 0) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = *(unsigned int *)(a2 + 12);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 40LL))(v4, v6, v9);
  unsigned int v11 = *(unsigned __int16 *)(a2 + 8);
  int v12 = (__int16)v11;
  unsigned int v13 = v11 >> 5;
  if (v12 < 0) {
    unsigned int v13 = *(_DWORD *)(a2 + 12);
  }
  *((_DWORD *)a1 + 2) += v13;
  return result;
}

icu::SimpleDateFormat *icu::MessageFormat::getDefaultDateFormat(icu::MessageFormat *this, UErrorCode *a2)
{
  uint64_t result = (icu::SimpleDateFormat *)*((void *)this + 91);
  if (!result)
  {
    uint64_t result = icu::DateFormat::createDateTimeInstance(3, 3LL, (icu::MessageFormat *)((char *)this + 328));
    *((void *)this + 9sub_1808F7164((uint64_t)v14, 1) = result;
    if (!result) {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return result;
}

void *icu::MessageFormat::formatComplexSubMessage( void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, UErrorCode *a8)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  if (*(int *)a8 <= 0)
  {
    LODWORD(v9) = a2;
    __int128 v10 = result;
    if (*((_DWORD *)result + 140) == 1)
    {
      unsigned int v35 = a6;
      __int128 v51 = 0u;
      uint64_t v54 = 0LL;
      __int128 v53 = 0u;
      __int128 v52 = 0u;
      uint64_t v50 = off_18971B688;
      LOWORD(v5sub_1808F7164((uint64_t)v14, 1) = 2;
      uint64_t v11 = result[80];
      int v12 = *(_DWORD *)(v11 + 16LL * (int)a2 + 4) + *(unsigned __int16 *)(v11 + 16LL * (int)a2 + 8);
      int32_t v39 = (icu::UnicodeString *)(a3 + 152);
      __int128 v37 = (icu::Formattable *)(a3 + 16);
      while (1)
      {
        uint64_t v9 = (int)v9 + 1LL;
        int v13 = *(_DWORD *)(v11 + 16 * v9);
        uint64_t v14 = v11 + 16 * v9;
        unsigned int v17 = *(_DWORD *)(v14 + 4);
        int v16 = (_DWORD *)(v14 + 4);
        uint64_t v15 = (const icu::UnicodeString *)v17;
        switch(v13)
        {
          case 1:
            icu::UnicodeString::doAppend( (uint64_t)&v50,  (const icu::UnicodeString *)(v10 + 71),  v12,  ((_DWORD)v15 - v12));
            if ((v51 & 0x8000u) == 0LL) {
              int32_t v30 = (unsigned __int16)v51 >> 5;
            }
            else {
              int32_t v30 = DWORD1(v51);
            }
            if ((icu::UnicodeString::doIndexOf((uint64_t)&v50, 0x7Bu, 0, v30) & 0x80000000) != 0)
            {
              sub_1809114A8(a7, (uint64_t)&v50);
            }

            else
            {
              __int128 v46 = 0u;
              uint64_t v49 = 0LL;
              __int128 v48 = 0u;
              __int128 v47 = 0u;
              unsigned int v45 = off_18971B688;
              LOWORD(v46) = 2;
              bzero(v42, 0x330uLL);
              icu::MessageFormat::MessageFormat( (icu::MessageFormat *)v42,  (const icu::UnicodeString *)&v45,  (const icu::Locale *)(v10 + 41),  a8);
              if (v44 != 1)
              {
                icu::MessagePattern::clear((uint64_t)&v43);
                int v44 = 1;
              }

              uint64_t v41 = 0LL;
              memset(v40, 0, sizeof(v40));
              (*(void (**)(void *, void (***)(icu::UnicodeString *__hidden), _OWORD *, UErrorCode *))(v42[0] + 88LL))( v42,  &v50,  v40,  a8);
              icu::MessageFormat::format(v42, 0LL, 0LL, a4, a5, v35, a7, 0LL, a8);
              icu::MessageFormat::~MessageFormat((icu::MessageFormat *)v42);
              icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)&v45);
            }

            return icu::UnicodeString::~UnicodeString(v32, (icu::UnicodeString *)&v50);
          case 2:
          case 4:
            icu::UnicodeString::doAppend( (uint64_t)&v50,  (const icu::UnicodeString *)(v10 + 71),  v12,  ((_DWORD)v15 - v12));
            if (v13 == 4)
            {
              if (*(_BYTE *)(a3 + 216))
              {
                unsigned int v19 = *(unsigned __int16 *)(a3 + 160);
                int v20 = (__int16)v19;
                unsigned int v21 = v19 >> 5;
                if (v20 >= 0) {
                  uint64_t v22 = v21;
                }
                else {
                  uint64_t v22 = *(unsigned int *)(a3 + 164);
                }
                uint64_t v23 = v39;
              }

              else
              {
                DefaultNumberFormat = icu::MessageFormat::getDefaultNumberFormat((icu::MessageFormat *)v10, a8, v18);
                uint64_t v23 = icu::Format::format(DefaultNumberFormat, v37, (icu::UnicodeString *)&v50, a8);
                unsigned int v27 = *((unsigned __int16 *)v23 + 4);
                int v28 = (__int16)v27;
                unsigned int v29 = v27 >> 5;
                if (v28 >= 0) {
                  uint64_t v22 = v29;
                }
                else {
                  uint64_t v22 = *((unsigned int *)v23 + 3);
                }
              }

              icu::UnicodeString::doAppend((uint64_t)&v50, v23, 0, v22);
            }

            int v12 = *v16 + *(unsigned __int16 *)(v11 + 16 * v9 + 8);
            goto LABEL_19;
          case 5:
            icu::UnicodeString::doAppend( (uint64_t)&v50,  (const icu::UnicodeString *)(v10 + 71),  v12,  ((_DWORD)v15 - v12));
            uint64_t v25 = v10[80];
            int v12 = *(_DWORD *)(v25 + 16LL * (int)v9 + 4) + *(unsigned __int16 *)(v25 + 16LL * (int)v9 + 8);
            icu::MessageImpl::appendReducedApostrophes((icu::MessageImpl *)(v10 + 71), v15, v12, (uint64_t)&v50, v24);
            goto LABEL_19;
          default:
LABEL_19:
            uint64_t v11 = v10[80];
            break;
        }
      }
    }

    return (void *)icu::MessageFormat::format(result, a2, a3, a4, a5, a6, a7, 0LL, a8);
  }

  return result;
}

uint64_t sub_1809118F4(uint64_t a1, int a2, uint64_t a3, icu::Formattable *a4, UErrorCode *a5, double a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  uint64_t v10 = a1 + 16;
  icu::Formattable::Formattable((icu::Formattable *)(a1 + 16));
  *(double *)(a1 + 128) = a6;
  *(_DWORD *)(a1 + 136) = -1;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 152) = off_18971B688;
  *(_WORD *)(a1 + 160) = 2;
  *(_BYTE *)(a1 + 216) = 0;
  if (a6 == 0.0)
  {
    icu::Formattable::operator=(v10, (uint64_t)a4);
  }

  else
  {
    double Double = icu::Formattable::getDouble(a4, a5);
    icu::Formattable::Formattable((icu::Formattable *)v13, Double - a6);
    icu::Formattable::operator=(v10, (uint64_t)v13);
    icu::Formattable::~Formattable((icu::Formattable *)v13);
  }

  return a1;
}

uint64_t icu::MessageFormat::updateMetaData()
{
  return 0LL;
}

uint64_t icu::MessageFormat::getLiteralStringUntilNextArgument@<X0>( icu::MessageFormat *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (icu::MessageFormat *)((char *)this + 568);
  uint64_t v7 = *((void *)this + 80);
  uint64_t v8 = v7 + 16LL * a2;
  int v9 = *(_DWORD *)(v8 + 4) + *(unsigned __int16 *)(v8 + 8);
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  int v11 = *(_DWORD *)(v8 + 20);
  uint64_t v10 = (_DWORD *)(v8 + 20);
  int v12 = *(v10 - 1);
  uint64_t result = icu::UnicodeString::doAppend(a3, (icu::MessageFormat *)((char *)this + 568), v9, (v11 - v9));
  if ((v12 & 0xFFFFFFFB) != 1)
  {
    uint64_t v14 = 16LL * a2;
    do
    {
      int v15 = *v10 + *(unsigned __int16 *)(v7 + v14 + 24);
      uint64_t v7 = *((void *)this + 80);
      uint64_t v10 = (_DWORD *)(v7 + v14 + 36);
      int v16 = *(_DWORD *)(v7 + v14 + 32);
      uint64_t result = icu::UnicodeString::doAppend(a3, v6, v15, (*v10 - v15));
      v14 += 16LL;
    }

    while ((v16 & 0xFFFFFFFB) != 1);
  }

  return result;
}

uint64_t icu::MessageFormat::findOtherSubMessage(icu::MessageFormat *this, int a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  unsigned int v3 = (char *)this + 552;
  int v4 = *((_DWORD *)this + 162);
  if ((*(_DWORD *)(*((void *)this + 80) + 16LL * a2) & 0xFFFFFFFE) == 0xC) {
    int v5 = a2 + 1;
  }
  else {
    int v5 = a2;
  }
  memset(v12, 0, sizeof(v12));
  int v11 = "o";
  icu::UnicodeString::UnicodeString(v12, 0LL, &v11);
  uint64_t v6 = (_DWORD *)*((void *)this + 80);
  do
  {
    uint64_t v7 = &v6[4 * v5];
    uint64_t v6 = (_DWORD *)*v7;
    if ((_DWORD)v6 == 6) {
      break;
    }
    uint64_t v8 = v5 + 1LL;
    uint64_t v6 = (_DWORD *)*((void *)this + 80);
    int v9 = (v6[4 * v8] & 0xFFFFFFFE) == 0xC ? v5 + 2 : v5 + 1;
    if (v6[4 * v9 + 3] > v9) {
      int v9 = v6[4 * v9 + 3];
    }
    int v5 = v9 + 1;
  }

  while (v9 + 1 < v4);
  uint64_t v8 = 0LL;
LABEL_14:
  icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)v12);
  return v8;
}

uint64_t icu::MessageFormat::findFirstPluralNumberArg( icu::MessageFormat *this, int a2, const icu::UnicodeString *a3)
{
  LODWORD(v4) = a2;
  uint64_t v6 = (char *)this + 552;
  uint64_t v7 = *((void *)this + 80);
LABEL_2:
  uint64_t v8 = 16LL * (int)v4;
  while (1)
  {
    int v9 = *(_DWORD *)(v7 + v8 + 16);
    if (v9 == 1) {
      return 0LL;
    }
    if (v9 == 4) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v4 = (v4 + 1);
    v8 += 16LL;
    if (v9 == 5)
    {
      if (*((unsigned __int16 *)a3 + 4) >= 0x20u && *(unsigned __int16 *)(v7 + v8 + 10) <= 1u)
      {
        uint64_t v7 = *((void *)this + 80);
      }

      goto LABEL_2;
    }
  }

uint64_t icu::MessageFormat::parse( icu::MessageFormat *this, unint64_t a2, const icu::UnicodeString *a3, icu::ParsePosition *a4, int *a5, UErrorCode *a6)
{
  uint64_t v96 = *MEMORY[0x1895F89C0];
  *a5 = 0;
  if (*(int *)a6 >= 1)
  {
    uint64_t v6 = 0LL;
LABEL_5:
    *((_DWORD *)a4 + 3) = *((_DWORD *)a4 + 2);
    return v6;
  }

  if (*((_BYTE *)this + 676))
  {
    uint64_t v6 = 0LL;
    *a6 = U_ARGUMENT_TYPE_MISMATCH;
    goto LABEL_5;
  }

  int v10 = a2;
  uint64_t v70 = (icu::MessageFormat *)((char *)this + 552);
  signed int v11 = *((_DWORD *)this + 176);
  unint64_t v12 = v11;
  uint64_t v13 = 112LL * v11;
  BOOL v14 = !is_mul_ok(v12, 0x70uLL);
  BOOL v15 = __CFADD__(v13, 16LL);
  uint64_t v16 = v13 + 16;
  if (v15) {
    BOOL v14 = 1;
  }
  if (v14) {
    uint64_t v17 = -1LL;
  }
  else {
    uint64_t v17 = v16;
  }
  int v18 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v17, a2);
  __int128 v73 = a5;
  if (v18)
  {
    *int v18 = 112LL;
    v18[1] = v12;
    uint64_t v20 = (uint64_t)(v18 + 2);
    uint64_t v21 = 112 * v12;
    uint64_t v22 = (icu::Formattable *)(v18 + 2);
    do
    {
      uint64_t v22 = (icu::Formattable *)((char *)icu::Formattable::Formattable(v22) + 112);
      v21 -= 112LL;
    }

    while (v21);
  }

  else
  {
    uint64_t v20 = 0LL;
  }

  uint64_t v74 = v20;
  uint64_t v75 = this;
  uint64_t v79 = v20;
  __int128 v72 = (char *)this + 568;
  uint64_t v23 = *((void *)this + 80);
  int v24 = *(_DWORD *)(v23 + 16LL * v10 + 4) + *(unsigned __int16 *)(v23 + 16LL * v10 + 8);
  int v25 = *((_DWORD *)a4 + 2);
  __int128 v77 = off_18970F400;
  unint64_t v78 = 0xFFFFFFFF00000000LL;
  signed int v26 = a3;
  while (1)
  {
    uint64_t v27 = v10;
    uint64_t v28 = v10 + 1LL;
    unsigned int v29 = (int *)(v23 + 16 * v28);
    int v30 = *v29;
    int v31 = v29[1];
    int32_t v32 = v31 - v24;
    if (v31 == v24) {
      goto LABEL_41;
    }
    unsigned int v33 = *((unsigned __int16 *)v26 + 4);
    if ((v33 & 1) != 0)
    {
      int v39 = (*((_WORD *)v75 + 288) & 1) == 0;
      goto LABEL_40;
    }

    int v34 = (v33 & 0x8000u) == 0 ? v33 >> 5 : *((_DWORD *)v26 + 3);
    if (v25 < 0)
    {
      int v35 = 0;
    }

    else
    {
      int v35 = v34;
      int v36 = v25;
      if (v34 >= v25)
      {
        if ((v32 & 0x80000000) == 0) {
          goto LABEL_29;
        }
        goto LABEL_34;
      }
    }

    int v36 = v35;
    if ((v32 & 0x80000000) == 0)
    {
LABEL_29:
      int32_t v37 = v34 - v36;
      int32_t v38 = v32;
      if (v37 >= v32) {
        goto LABEL_36;
      }
      goto LABEL_35;
    }

uint64_t icu::MessageFormat::parse( icu::MessageFormat *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, int *a4)
{
  UErrorCode v5 = U_ZERO_ERROR;
  return icu::MessageFormat::parse(this, 0LL, a2, a3, a4, &v5);
}

uint64_t icu::MessageFormat::parse( icu::MessageFormat *this, const icu::UnicodeString *a2, int *a3, UErrorCode *a4)
{
  if (*((_BYTE *)this + 676))
  {
    uint64_t v5 = 0LL;
    *a4 = U_ARGUMENT_TYPE_MISMATCH;
  }

  else
  {
    unint64_t v12 = off_18970F400;
    unint64_t v13 = 0xFFFFFFFF00000000LL;
    uint64_t v6 = (*(uint64_t (**)(icu::MessageFormat *, const icu::UnicodeString *, void (***)(icu::ParsePosition *__hidden), int *))(*(void *)this + 184LL))( this,  a2,  &v12,  a3);
    uint64_t v5 = v6;
    if (!(_DWORD)v13)
    {
      *a4 = U_MESSAGE_PARSE_ERROR;
      if (v6)
      {
        uint64_t v7 = (void *)(v6 - 16);
        uint64_t v8 = *(void *)(v6 - 8);
        if (v8)
        {
          uint64_t v9 = 112 * v8;
          uint64_t v10 = v6 - 112;
          do
          {
            icu::Formattable::~Formattable((icu::Formattable *)(v10 + v9));
            v9 -= 112LL;
          }

          while (v9);
        }

        icu::UMemory::operator delete[](v7);
        uint64_t v5 = 0LL;
      }
    }

    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v12);
  }

  return v5;
}

icu::Formattable *icu::MessageFormat::parseObject( icu::MessageFormat *this, const icu::UnicodeString *a2, icu::Formattable *a3, icu::ParsePosition *a4)
{
  int v6 = 0;
  uint64_t result = (icu::Formattable *)(*(uint64_t (**)(icu::MessageFormat *, const icu::UnicodeString *, icu::ParsePosition *, int *))(*(void *)this + 184LL))( this,  a2,  a4,  &v6);
  if (result) {
    return (icu::Formattable *)icu::Formattable::adoptArray(a3, result, v6);
  }
  return result;
}

void icu::MessageFormat::autoQuoteApostrophe( icu::MessageFormat *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if ((v6 & 0x8000u) == 0) {
    int32_t v7 = v6 >> 5;
  }
  else {
    int32_t v7 = *((_DWORD *)this + 3);
  }
  if ((v6 & 0x11) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else if ((v6 & 2) != 0)
  {
    uint64_t v8 = (UChar *)((char *)this + 10);
  }

  else
  {
    uint64_t v8 = (UChar *)*((void *)this + 3);
  }

  uint64_t Buffer = icu::UnicodeString::getBuffer((icu::UnicodeString *)a3, (2 * v7) | 1u);
  if (!Buffer)
  {
    *(_DWORD *)a2 = 7;
LABEL_2:
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
    return;
  }

  int v10 = umsg_autoQuoteApostrophe(v8, v7, Buffer, (2 * v7) | 1u, (int *)a2);
  else {
    int v11 = 0;
  }
  icu::UnicodeString::releaseBuffer(a3, v11);
}

uint64_t icu::MessageFormat::createAppropriateFormat( uint64_t a1, uint64_t a2, icu::UnicodeString *a3, _DWORD *a4, uint64_t a5, UErrorCode *a6)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    int Keyword = icu::MessageFormat::findKeyword(a2, (const UChar **)&off_189726A58);
    switch(Keyword)
    {
      case 0:
        *a4 = 1;
        int v18 = (icu::MessageFormat *)icu::MessageFormat::findKeyword((uint64_t)a3, (const UChar **)&off_189726A90);
        switch((int)v18)
        {
          case 0:
            uint64_t result = (uint64_t)icu::NumberFormat::createInstance((char **)(a1 + 328), a6, v19);
            break;
          case 1:
            uint64_t result = (uint64_t)icu::NumberFormat::createCurrencyInstance((char **)(a1 + 328), a6, v19);
            break;
          case 2:
            uint64_t result = (uint64_t)icu::NumberFormat::createPercentInstance((char **)(a1 + 328), a6, v19);
            break;
          case 3:
            *a4 = 2;
            uint64_t result = (uint64_t)icu::MessageFormat::createIntegerFormat(v18, (char **)(a1 + 328), a6);
            break;
          default:
            int v28 = icu::PatternProps::skipWhiteSpace((uint64_t)a3, 0LL);
            if (!icu::UnicodeString::doCompare((uint64_t)a3, v28, 2, (uint64_t)":", 0, 2))
            {
              memset(v34, 0, sizeof(v34));
              icu::UnicodeString::tempSubString(a3, v28 + 2, 0x7FFFFFFF, (icu::UnicodeString *)v34);
              icu::number::NumberFormatter::forSkeleton((UChar **)v34, a6, v32);
              icu::number::UnlocalizedNumberFormatter::locale((uint64_t)v32, a1 + 328, (uint64_t)v33);
              InstanceForSkeleton = icu::number::LocalizedNumberFormatter::toFormat((const char **)v33, a6);
              icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v33);
              sub_180912CB4((void **)v32);
              int v24 = (icu::UnicodeString *)v34;
              goto LABEL_16;
            }

            uint64_t Instance = icu::NumberFormat::createInstance((char **)(a1 + 328), a6, v29);
            InstanceForSkeleton = Instance;
            if (Instance)
            {
              if (v31) {
                (*(void (**)(void *, icu::UnicodeString *, uint64_t, UErrorCode *))(*(void *)v31 + 568LL))( v31,  a3,  a5,  a6);
              }
            }

            return (uint64_t)InstanceForSkeleton;
        }

        return result;
      case 1:
      case 2:
        *a4 = 0;
        int v14 = icu::PatternProps::skipWhiteSpace((uint64_t)a3, 0LL);
        if (icu::UnicodeString::doCompare((uint64_t)a3, v14, 2, (uint64_t)":", 0, 2))
        {
          int v15 = icu::MessageFormat::findKeyword((uint64_t)a3, (const UChar **)&off_189726AB8);
          int v16 = v15;
          if (v15 < 0) {
            uint64_t v17 = 2LL;
          }
          else {
            uint64_t v17 = dword_180A3A0E4[v15];
          }
          int v25 = (const icu::Locale *)(a1 + 328);
          if (Keyword == 1) {
            Dateuint64_t Instance = icu::DateFormat::createDateInstance(v17, v25);
          }
          else {
            Dateuint64_t Instance = icu::DateFormat::createTimeInstance(v17, v25);
          }
          InstanceForSkeleton = DateInstance;
          if (v16 < 0)
          {
            if (DateInstance)
            {
              if (v27) {
                (*(void (**)(void *, icu::UnicodeString *))(*(void *)v27 + 256LL))(v27, a3);
              }
            }
          }
        }

        else
        {
          memset(v33, 0, 64);
          icu::UnicodeString::tempSubString(a3, v14 + 2, 0x7FFFFFFF, (icu::UnicodeString *)v33);
          InstanceForSkeleton = icu::DateFormat::createInstanceForSkeleton( (UErrorCode *)v33,  (const icu::UnicodeString *)(a1 + 328),  a6,  v22);
          int v24 = (icu::UnicodeString *)v33;
LABEL_16:
          icu::UnicodeString::~UnicodeString(v23, v24);
        }

        return (uint64_t)InstanceForSkeleton;
      case 3:
        *a4 = 1;
        unint64_t v20 = a1 + 328;
        uint64_t v21 = 0LL;
        goto LABEL_14;
      case 4:
        *a4 = 1;
        unint64_t v20 = a1 + 328;
        uint64_t v21 = 1LL;
        goto LABEL_14;
      case 5:
        *a4 = 1;
        unint64_t v20 = a1 + 328;
        uint64_t v21 = 2LL;
LABEL_14:
        uint64_t result = sub_180912D0C(v21, v20, (uint64_t)a3, (int *)a6);
        break;
      default:
        InstanceForSkeleton = 0LL;
        *a4 = 3;
        *a6 = U_ILLEGAL_ARGUMENT_ERROR;
        return (uint64_t)InstanceForSkeleton;
    }
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t icu::MessageFormat::findKeyword(uint64_t a1, const UChar **a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if (v2 < 0x20) {
    return 0LL;
  }
  if ((v2 & 0x8000u) == 0) {
    unsigned int v4 = v2 >> 5;
  }
  else {
    unsigned int v4 = *(_DWORD *)(a1 + 12);
  }
  unsigned int v16 = v4;
  if ((v2 & 0x11) != 0)
  {
    uint64_t v5 = 0LL;
  }

  else if ((v2 & 2) != 0)
  {
    uint64_t v5 = (unsigned __int16 *)(a1 + 10);
  }

  else
  {
    uint64_t v5 = *(unsigned __int16 **)(a1 + 24);
  }

  int32_t v7 = icu::PatternProps::trimWhiteSpace(v5, &v16);
  memset(v18, 0, sizeof(v18));
  uint64_t v15 = (uint64_t)v7;
  icu::UnicodeString::UnicodeString(v18, 0LL, &v15);
  uint64_t v14 = v15;
  icu::Locale::Locale(&v14, (icu::Locale *)v17, "", 0LL, 0LL, 0LL);
  icu::UnicodeString::toLower((const UChar **)v18, (const icu::Locale *)v17);
  icu::Locale::~Locale((icu::Locale *)v17);
  uint64_t v9 = *a2;
  if (*a2)
  {
    uint64_t v6 = 0LL;
    int v10 = a2 + 1;
    while (1)
    {
      int32_t v11 = u_strlen(v9);
      int32_t v12 = (SWORD4(v18[0]) & 0x8000u) == 0 ? WORD4(v18[0]) >> 5 : HIDWORD(v18[0]);
      uint64_t v9 = v10[v6++];
      if (!v9) {
        goto LABEL_18;
      }
    }
  }

  else
  {
LABEL_18:
    uint64_t v6 = 0xFFFFFFFFLL;
  }

  icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v18);
  return v6;
}

icu::DecimalFormat *icu::MessageFormat::createIntegerFormat( icu::MessageFormat *this, char **a2, UErrorCode *a3)
{
  uint64_t Instance = icu::NumberFormat::createInstance(a2, a3, a3);
  unsigned int v4 = Instance;
  if (Instance)
  {
    if (v5)
    {
      uint64_t v6 = v5;
      (*(void (**)(void *, void))(*(void *)v5 + 232LL))(v5, 0LL);
      (*(void (**)(void *, void))(*(void *)v6 + 536LL))(v6, 0LL);
      (*(void (**)(void *, uint64_t))(*(void *)v6 + 184LL))(v6, 1LL);
    }
  }

  return v4;
}

void **sub_180912CB4(void **a1)
{
  return a1;
}

uint64_t sub_180912D0C(uint64_t a1, unint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8 = icu::UMemory::operator new((icu::UMemory *)0x2F0, a2);
  uint64_t v9 = v8;
  if (v8)
  {
    icu::RuleBasedNumberFormat::RuleBasedNumberFormat(v8, a1, a2, a4);
    if (*a4 <= 0)
    {
      unsigned int v10 = *(unsigned __int16 *)(a3 + 8);
      int v11 = (__int16)v10;
      int v12 = v10 >> 5;
      if (v11 < 0) {
        int v12 = *(_DWORD *)(a3 + 12);
      }
      if (v12 >= 1)
      {
        int v14 = 0;
        (*(void (**)(uint64_t, uint64_t, int *))(*(void *)v9 + 384LL))(v9, a3, &v14);
      }
    }
  }

  else
  {
    *a4 = 7;
  }

  return v9;
}

uint64_t icu::MessageFormat::usesNamedArguments(icu::MessageFormat *this)
{
  return *((char *)this + 676);
}

uint64_t icu::MessageFormat::getArgTypeCount(icu::MessageFormat *this)
{
  return *((unsigned int *)this + 176);
}

uint64_t icu::MessageFormat::equalFormats(icu::MessageFormat *this, const void *a2, const void *a3)
{
  return (*(uint64_t (**)(icu::MessageFormat *, const void *, const void *))(*(void *)this + 24LL))( this,  a2,  a3);
}

uint64_t icu::MessageFormat::DummyFormat::operator==()
{
  return 1LL;
}

uint64_t *icu::MessageFormat::DummyFormat::clone@<X0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a2, (icu::UMemory *)0x148, a1);
  if (result)
  {
    result[40] = 0LL;
    *((_OWORD *)result + 18) = 0u;
    *((_OWORD *)result + 19) = 0u;
    *((_OWORD *)result + 16) = 0u;
    *((_OWORD *)result + 17) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 15) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 10) = 0u;
    *((_OWORD *)result + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_OWORD *)result + 8) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 6) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 4) = 0u;
    *((_OWORD *)result + 5) = 0u;
    *((_OWORD *)result + 2) = 0u;
    *((_OWORD *)result + 3) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *((_OWORD *)result + sub_1808F7164((uint64_t)v14, 1) = 0u;
    uint64_t result = (uint64_t *)icu::Format::Format((uint64_t)result);
    *uint64_t result = (uint64_t)&off_189726BA0;
  }

  return result;
}

icu::UnicodeString *icu::MessageFormat::DummyFormat::format( icu::MessageFormat::DummyFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, UErrorCode *a4)
{
  uint64_t result = a3;
  return result;
}

icu::UnicodeString *icu::MessageFormat::DummyFormat::format( icu::MessageFormat::DummyFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  uint64_t result = a3;
  return result;
}

icu::UnicodeString *icu::MessageFormat::DummyFormat::format( icu::MessageFormat::DummyFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPositionIterator *a4, UErrorCode *a5)
{
  uint64_t result = a3;
  return result;
}

uint64_t sub_180912EBC(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  signed int v2 = *(_DWORD *)(a1 + 116);
  unsigned int v3 = *(icu::UVector **)(a1 + 120);
  if (v2 >= *((_DWORD *)v3 + 2)) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 116) = v2 + 1;
  return icu::UVector::elementAt(v3, v2);
}

uint64_t sub_180912EF4(uint64_t result)
{
  *(_DWORD *)(result + 116) = 0;
  return result;
}

uint64_t sub_180912EFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0LL;
  }
}

void sub_180912F14(icu::StringEnumeration *this)
{
  *(void *)this = off_189726AF8;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::StringEnumeration::~StringEnumeration(this);
}

void sub_180912F54(icu::StringEnumeration *this)
{
  *(void *)this = off_189726AF8;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::StringEnumeration::~StringEnumeration(this);
  icu::UMemory::operator delete(v3);
}

void icu::MessageFormat::PluralSelectorProvider::select( icu::MessageFormat **this@<X0>, const icu::UnicodeString **a2@<X1>, double a3@<D0>, UErrorCode *a4@<X2>, icu::UnicodeString *a5@<X8>)
{
  if (*(int *)a4 < 1)
  {
    if (this[2]
      || (this[2] = (icu::MessageFormat *)icu::PluralRules::forLocale( (icu::MessageFormat *)((char *)this[1] + 328),  *((unsigned int *)this + 6),  (icu::UnifiedCache *)a4),  *(int *)a4 < 1))
    {
      Otheruint64_t SubMessage = icu::MessageFormat::findOtherSubMessage(this[1], *(_DWORD *)a2);
      int FirstPluralNumberArg = icu::MessageFormat::findFirstPluralNumberArg(this[1], OtherSubMessage, a2[1]);
      *((_DWORD *)a2 + 34) = FirstPluralNumberArg;
      if (FirstPluralNumberArg >= 1)
      {
        unsigned int v13 = FirstPluralNumberArg;
        uint64_t v14 = *((void *)this[1] + 92);
        if (v14) {
          a2[18] = (const icu::UnicodeString *)uhash_iget(v14, v13);
        }
      }

      if (!a2[18])
      {
        a2[18] = icu::MessageFormat::getDefaultNumberFormat(this[1], a4, v12);
        *((_BYTE *)a2 + 216) = 1;
      }

      uint64_t v15 = (const icu::Formattable *)(a2 + 2);
      if (icu::Formattable::getDouble((icu::Formattable *)(a2 + 2), a4) == a3)
      {
        icu::Format::format(a2[18], (const icu::Formattable *)(a2 + 2), (icu::UnicodeString *)(a2 + 19), a4);
        unsigned int v16 = a2[18];
        if (v16
        {
          int v18 = v17;
          uint64_t v21 = 0LL;
          memset(v20, 0, sizeof(v20));
          icu::number::impl::DecimalQuantity::DecimalQuantity((icu::number::impl::DecimalQuantity *)v20);
          icu::DecimalFormat::formatToDecimalQuantity(v18, v15, (icu::number::impl::DecimalQuantity *)v20, a4);
          if (*(int *)a4 < 1)
          {
            icu::PluralRules::select(this[2], (const icu::IFixedDecimal *)v20, a5);
          }

          else
          {
            uint64_t v19 = "o";
            icu::UnicodeString::UnicodeString(a5, 0LL, &v19);
          }

          icu::number::impl::DecimalQuantity::~DecimalQuantity((void **)v20);
        }

        else
        {
          icu::PluralRules::select(this[2], a3, a5);
        }
      }

      else
      {
        *a4 = U_INTERNAL_PROGRAM_ERROR;
        uint64_t v22 = "o";
        icu::UnicodeString::UnicodeString(a5, 0LL, &v22);
      }
    }

    else
    {
      uint64_t v23 = "o";
      icu::UnicodeString::UnicodeString(a5, 0LL, &v23);
    }
  }

  else
  {
    int v24 = "o";
    icu::UnicodeString::UnicodeString(a5, 0LL, &v24);
  }

void sub_1809132B0(icu::Format *a1)
{
}

uint64_t *sub_1809132C4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    unsigned int v3 = (void *)(v2 - 16);
    uint64_t v4 = *(void *)(v2 - 8);
    if (v4)
    {
      uint64_t v5 = 112 * v4;
      uint64_t v6 = v2 - 112;
      do
      {
        icu::Formattable::~Formattable((icu::Formattable *)(v6 + v5));
        v5 -= 112LL;
      }

      while (v5);
    }

    icu::UMemory::operator delete[](v3);
  }

  return a1;
}

void *icu::NameUnicodeTransliterator::getStaticClassID(icu::NameUnicodeTransliterator *this)
{
  return &unk_18C5356A3;
}

void *sub_180913330()
{
  return &unk_18C5356A3;
}

uint64_t sub_18091333C(uint64_t a1, icu::UnicodeFilter *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int32_t v7 = L"Name-Any";
  icu::UnicodeString::UnicodeString(v8, 1LL, &v7);
  icu::Transliterator::Transliterator((icu::Transliterator *)a1, v8, a2);
  icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v8);
  *(void *)a1 = off_189726C28;
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 88));
  v8[0] = v5;
  v8[1] = (UChar *)j__uset_add;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  uprv_getCharNameCharacters((uint64_t)v8);
  return a1;
}

void sub_180913414(uint64_t a1)
{
  *(void *)a1 = off_189726C28;
  icu::UnicodeSet::~UnicodeSet(off_189726C28, (icu::UnicodeSet *)(a1 + 88));
  icu::Transliterator::~Transliterator((icu::Transliterator *)a1);
}

void sub_180913444(uint64_t a1)
{
  *(void *)a1 = off_189726C28;
  icu::UnicodeSet::~UnicodeSet(off_189726C28, (icu::UnicodeSet *)(a1 + 88));
  icu::Transliterator::~Transliterator((icu::Transliterator *)a1);
  icu::UMemory::operator delete(v2);
}

icu::Transliterator *sub_180913478@<X0>(UChar **a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = (icu::Transliterator *)icu::UMemory::operator new(a3, (icu::UMemory *)0x120, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = icu::Transliterator::Transliterator(v4, a1);
    *(void *)uint64_t v6 = off_189726C28;
    icu::UnicodeSet::UnicodeSet((icu::Transliterator *)((char *)v6 + 88), (const icu::UnicodeSet *)(a1 + 11));
  }

  return v5;
}

char *sub_1809134C8(uint64_t a1, const icu::UnicodeString *a2, _DWORD *a3, int a4)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t result = (char *)uprv_getMaxCharNameLength();
  if (!(_DWORD)result
    || (v9 = (int)result, v44 = (_DWORD)result + 1, (uint64_t result = (char *)uprv_malloc((int)result + 1)) == 0LL))
  {
    a3[2] = a3[3];
    return result;
  }

  uint64_t v42 = result;
  memset(v57, 0, 64);
  __int128 v46 = L"\\N~{~";
  LODWORD(v10) = -1;
  icu::UnicodeString::UnicodeString(v57, 1LL, &v46);
  __int128 v53 = 0u;
  uint64_t v56 = 0LL;
  __int128 v55 = 0u;
  __int128 v54 = 0u;
  uint64_t v51 = 0LL;
  int v52 = off_18971B688;
  LOWORD(v53) = 2;
  __int128 v48 = 0u;
  __int128 v50 = 0u;
  __int128 v49 = 0u;
  __int128 v47 = off_18971B688;
  LOWORD(v48) = 2;
  unint64_t v12 = a3[2];
  int v11 = a3[3];
  uint64_t v43 = (icu::UnicodeSet *)(a1 + 88);
  int v41 = a4;
  do
  {
    int v13 = 0;
    uint64_t v10 = 0xFFFFFFFFLL;
    unint64_t v14 = v12;
    while (1)
    {
      unint64_t v12 = v14;
      uint64_t v15 = (icu::PatternProps *)(*(uint64_t (**)(const icu::UnicodeString *, unint64_t))(*(void *)a2 + 80LL))( a2,  v14);
      unsigned int v16 = v15;
      if (v13 == 1) {
        break;
      }
      if ((_DWORD)v15 == 92)
      {
        unint64_t v17 = icu::ICU_Utility::parsePattern((icu::ICU_Utility *)v57, a2, v14, v11);
        int v13 = 0;
        if ((v17 & 0x80000000) == 0)
        {
          unint64_t v14 = v17;
          if ((int)v17 < v11)
          {
            if ((v48 & 1) != 0)
            {
              icu::UnicodeString::unBogus((uint64_t)&v47);
            }

            else
            {
              if ((v48 & 0x8000u) == 0LL) {
                int v18 = (unsigned __int16)v48 >> 5;
              }
              else {
                int v18 = DWORD1(v48);
              }
              if (v18)
              {
                LOBYTE(v48) = v48 & 0x1F;
                LOWORD(v48) = v48;
              }
            }

            int v13 = 1;
            uint64_t v10 = v12;
            goto LABEL_43;
          }
        }

        uint64_t v10 = v12;
      }

      else
      {
        int v13 = 0;
      }

uint64_t sub_18091397C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int *a5)
{
  v36[8] = *(UChar **)MEMORY[0x1895F89C0];
  *(void *)(a1 + 8) = off_18971B688;
  uint64_t v9 = a1 + 8;
  *(_WORD *)(a1 + 16) = 2;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 136) = a2;
  *(void *)(a1 + 144) = uprv_malloc(0x50uLL);
  *(void *)(v9 + 144) = 0xA00000000LL;
  *(_WORD *)(v9 + 152) = 0;
  *(_BYTE *)(v9 + 154) = 1;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  if (*a5 > 0) {
    return a1;
  }
  uint64_t v10 = a4;
  uint64_t v11 = a3 + ((uint64_t)a4 << 6);
  unint64_t v12 = (_WORD *)(v11 + 8);
  unsigned int v13 = *(unsigned __int16 *)(v11 + 8);
  if (*(__int16 *)(v11 + 8) < 0)
  {
    if (!*(_DWORD *)(v11 + 12)) {
      goto LABEL_4;
    }
  }

  else if (v13 <= 0x1F)
  {
LABEL_4:
    *a5 = 9;
    return a1;
  }

  if ((v13 & 2) != 0) {
    unint64_t v14 = (_WORD *)(v11 + 10);
  }
  else {
    unint64_t v14 = *(_WORD **)(a3 + (v10 << 6) + 24);
  }
  if (*v14 == 37)
  {
    if ((v13 & 0x8000) != 0) {
      int32_t v15 = *(_DWORD *)(a3 + (v10 << 6) + 12);
    }
    else {
      int32_t v15 = v13 >> 5;
    }
    uint64_t v17 = icu::UnicodeString::doIndexOf(v11, 0x3Au, 0, v15);
    if ((_DWORD)v17 == -1)
    {
      *a5 = 9;
    }

    else
    {
      uint64_t v18 = v17;
      icu::UnicodeString::unBogus(v9);
      else {
        uint64_t v19 = *(unsigned __int16 *)(a1 + 16) >> 5;
      }
      icu::UnicodeString::doReplace((icu::UnicodeString *)v9, 0LL, v19, (const icu::UnicodeString *)v11, 0, v18);
      uint64_t v20 = a3 + (v10 << 6);
      BOOL v21 = (int *)(v20 + 12);
      int v34 = (uint64_t *)(v20 + 24);
      uint64_t v18 = (int)v18;
      do
      {
        if ((__int16)*v12 < 0)
        {
          int64_t v22 = *v21;
          if (v18 >= v22) {
            break;
          }
        }

        else
        {
          int64_t v22 = (unint64_t)(unsigned __int16)*v12 >> 5;
        }

        if (v22 <= (int)v18 + 1)
        {
          uint64_t v24 = 0xFFFFLL;
        }

        else
        {
          uint64_t v23 = v11 + 10;
          if ((*v12 & 2) == 0) {
            uint64_t v23 = *v34;
          }
          uint64_t v24 = *(unsigned __int16 *)(v23 + 2 * v18 + 2);
        }

        ++v18;
      }

      while (icu::PatternProps::isWhiteSpace((icu::PatternProps *)v24));
      if ((_DWORD)v18 == 0x7FFFFFFF)
      {
        if ((*v12 & 1) != 0) {
          unsigned int v25 = 2;
        }
        else {
          unsigned int v25 = *v12 & 0x1F;
        }
        *unint64_t v12 = v25;
LABEL_38:
        if (v25 >> 5) {
          goto LABEL_40;
        }
        goto LABEL_39;
      }

      icu::UnicodeString::doReplace(v11, 0LL, v18, 0LL, 0, 0LL);
    }
  }

  else
  {
    int v35 = "%";
    icu::UnicodeString::UnicodeString(v36, 1LL, &v35);
    icu::UnicodeString::copyFrom((UChar **)v9, v36, 0);
    icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v36);
  }

  if (((__int16)*v12 & 0x80000000) == 0)
  {
    unsigned int v25 = (unsigned __int16)*v12;
    goto LABEL_38;
  }

  if (!*(_DWORD *)(a3 + (v10 << 6) + 12)) {
LABEL_39:
  }
    *a5 = 9;
LABEL_40:
  if (*(__int16 *)(a1 + 16) < 0)
  {
    int v27 = *(_DWORD *)(a1 + 20);
    int v26 = v27 & (v27 >> 31);
  }

  else
  {
    int v26 = 0;
    int v27 = *(unsigned __int16 *)(a1 + 16) >> 5;
  }

  *(_BYTE *)(a1 + 16sub_1808F7164((uint64_t)v14, 1) = icu::UnicodeString::indexOf(v9, (uint64_t)&unk_180A3A26E, 0, 2, v26, v27 - v26) != 0;
  unsigned int v28 = *(unsigned __int16 *)(a1 + 16);
  if ((v28 & 0x8000) != 0) {
    unsigned int v29 = *(_DWORD *)(a1 + 20);
  }
  else {
    unsigned int v29 = v28 >> 5;
  }
  if (icu::UnicodeString::doEqualsSubstring(v9, v29 - 8, 8, (uint64_t)L"@noparse", 0, 8))
  {
    *(_BYTE *)(a1 + 162) = 0;
    unsigned int v30 = *(unsigned __int16 *)(a1 + 16);
    if ((v30 & 0x8000) != 0) {
      unsigned int v31 = *(_DWORD *)(a1 + 20);
    }
    else {
      unsigned int v31 = v30 >> 5;
    }
    int v32 = v31 - 8;
    if ((v30 & 1) != 0 && v31 == 8)
    {
      icu::UnicodeString::unBogus(v9);
    }

    else if (v31 > v32)
    {
      if (v32 > 1023)
      {
        *(_WORD *)(a1 + 16) = v30 | 0xFFE0;
        *(_DWORD *)(a1 + 20) = v32;
      }

      else
      {
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 16) & 0x1F | (32 * v32);
      }
    }
  }

  return a1;
}

char *sub_180913D40(char *result, uint64_t a2, UErrorCode *a3)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    unint64_t v5 = (unint64_t)result;
    uint64_t v6 = result + 72;
    sub_180913F88((uint64_t)(result + 72));
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    uint64_t v34 = 0LL;
    __int128 v33 = 0u;
    unsigned int v30 = off_18971B688;
    LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 2;
    int v7 = *(__int16 *)(a2 + 8);
    int v8 = *(_WORD *)(a2 + 8) >> 5;
    signed int v9 = *(_DWORD *)(a2 + 12);
    if (v7 < 0) {
      int v8 = *(_DWORD *)(a2 + 12);
    }
    if (v8 >= 1)
    {
      int v10 = 0;
      unsigned int v11 = v7 >> 31;
      do
      {
        unsigned int v12 = (unsigned __int16)v7 >> 5;
        if ((v11 & 1) != 0) {
          unsigned int v13 = v9;
        }
        else {
          unsigned int v13 = v12;
        }
        if (v12 >= v10) {
          unsigned int v14 = v10;
        }
        else {
          unsigned int v14 = v12;
        }
        if (v9 >= v10) {
          int v15 = v10;
        }
        else {
          int v15 = v9;
        }
        BOOL v16 = (v11 & 1) == 0;
        if ((v11 & 1) != 0) {
          int v17 = v15;
        }
        else {
          int v17 = v14;
        }
        if (v16) {
          signed int v9 = v12;
        }
        if (v10 >= 0) {
          int v18 = v17;
        }
        else {
          int v18 = 0;
        }
        if (v10 < 0) {
          signed int v9 = v13;
        }
        int v19 = icu::UnicodeString::doIndexOf(a2, 0x3Bu, v18, v9 - v18);
        if (v19 == -1)
        {
          else {
            int v19 = *(unsigned __int16 *)(a2 + 8) >> 5;
          }
        }

        icu::UnicodeString::unBogus((uint64_t)&v30);
        if ((v31 & 0x8000u) == 0LL) {
          uint64_t v20 = (unsigned __int16)v31 >> 5;
        }
        else {
          uint64_t v20 = DWORD1(v31);
        }
        icu::UnicodeString::doReplace( (icu::UnicodeString *)&v30,  0LL,  v20,  (const icu::UnicodeString *)a2,  v10,  (v19 - v10));
        int v21 = *(_DWORD *)(v5 + 80);
        if (v21 && *v6) {
          uint64_t v22 = *(void *)(*v6 + 8LL * (v21 - 1));
        }
        else {
          uint64_t v22 = 0LL;
        }
        sub_180915864((uint64_t)&v30, v5, v22, *(void *)(v5 + 136), (uint64_t)v6, a3);
        int v10 = v19 + 1;
        int v7 = *(__int16 *)(a2 + 8);
        unsigned int v11 = v7 >> 31;
        int v23 = *(_WORD *)(a2 + 8) >> 5;
        signed int v9 = *(_DWORD *)(a2 + 12);
        if (v7 < 0) {
          int v23 = *(_DWORD *)(a2 + 12);
        }
      }

      while (v10 < v23);
    }

    uint64_t v24 = *(unsigned int *)(v5 + 80);
    if ((int)v24 >= 1)
    {
      uint64_t v25 = 0LL;
      uint64_t v26 = 0LL;
      uint64_t v27 = 8 * v24;
      do
      {
        unsigned int v28 = *(uint64_t **)(*v6 + v25);
        if (*v28)
        {
          BOOL v29 = *v28 < v26;
          uint64_t v26 = *v28;
          if (v29)
          {
            uint64_t v24 = 9LL;
            *a3 = U_PARSE_ERROR;
            return (char *)icu::UnicodeString::~UnicodeString((void *)v24, (icu::UnicodeString *)&v30);
          }
        }

        else
        {
          sub_180915FC8((uint64_t)v28, v26, (uint64_t)a3);
        }

        uint64_t v24 = *(unsigned __int8 *)(v5 + 160);
        if (!*(_BYTE *)(v5 + 160)) {
          ++v26;
        }
        v25 += 8LL;
      }

      while (v27 != v25);
    }

    return (char *)icu::UnicodeString::~UnicodeString((void *)v24, (icu::UnicodeString *)&v30);
  }

  return result;
}

void sub_180913F88(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  if ((int)v1 >= 1)
  {
    sub_1809141A4(a1, 0LL);
    uint64_t v3 = 0LL;
    uint64_t v4 = *(char **)a1;
    uint64_t v5 = 8 * v1;
    *(void *)a1 = 0LL;
    *(void *)(a1 + 8) = 0LL;
    do
    {
      uint64_t v6 = *(void **)&v4[v3];
      if (v6)
      {
        int v7 = sub_180915860(v6);
        icu::UMemory::operator delete(v7);
      }

      v3 += 8LL;
    }

    while (v5 != v3);
    uprv_free(v4);
  }

void sub_180914000(void *a1, void *a2)
{
  switch(*a2)
  {
    case 0xFFFFFFFFFFFFFFFALL:
      uint64_t v4 = (void *)a1[16];
      if (v4)
      {
        uint64_t v5 = sub_180915860(v4);
        icu::UMemory::operator delete(v5);
      }

      a1[16] = a2;
      return;
    case 0xFFFFFFFFFFFFFFFBLL:
      uint64_t v6 = (void *)a1[15];
      if (v6)
      {
        int v7 = sub_180915860(v6);
        icu::UMemory::operator delete(v7);
      }

      a1[15] = a2;
      return;
    case 0xFFFFFFFFFFFFFFFCLL:
      int v8 = 3;
      goto LABEL_11;
    case 0xFFFFFFFFFFFFFFFDLL:
      int v8 = 2;
      goto LABEL_11;
    case 0xFFFFFFFFFFFFFFFELL:
      int v8 = 1;
LABEL_11:
      sub_1809140C0(a1, v8, (uint64_t)a2, 1);
      break;
    case 0xFFFFFFFFFFFFFFFFLL:
      signed int v9 = (void *)a1[11];
      if (v9)
      {
        int v10 = sub_180915860(v9);
        icu::UMemory::operator delete(v10);
      }

      a1[11] = a2;
      break;
    default:
      return;
  }

void *sub_1809140C0(void *result, int a2, uint64_t a3, int a4)
{
  uint64_t v6 = result;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a4) {
    uint64_t result = sub_1809141A4((uint64_t)(result + 18), a3);
  }
  int v7 = &v6[a2];
  uint64_t v9 = v7[11];
  int v8 = v7 + 11;
  if (!v9) {
    goto LABEL_14;
  }
  uint64_t DecimalFormatSymbols = icu::RuleBasedNumberFormat::getDecimalFormatSymbols((icu::RuleBasedNumberFormat *)v6[17]);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v15, (UChar **)(DecimalFormatSymbols + 8));
  unint64_t v11 = v16;
  if ((v16 & 0x8000u) == 0 ? v16 >> 5 : *(_DWORD *)&v17[2])
  {
    unint64_t v11 = (unint64_t)((v16 & 2) != 0 ? v17 : v18);
    int v13 = *(unsigned __int16 *)v11;
  }

  else
  {
    int v13 = 0xFFFF;
  }

  int v14 = *(unsigned __int16 *)(a3 + 14);
  uint64_t result = icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)v15);
  if (v13 == v14) {
LABEL_14:
  }
    *int v8 = a3;
  return result;
}

void *sub_1809141A4(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 8);
  if (v4 != *(_DWORD *)(a1 + 12))
  {
    uint64_t result = *(void **)a1;
    if (*(void *)a1) {
      goto LABEL_3;
    }
LABEL_5:
    int v8 = 0;
    *(_DWORD *)(a1 + 12) = 0;
    goto LABEL_6;
  }

  unsigned int v5 = v4 + 10;
  *(_DWORD *)(a1 + 12) = v5;
  uint64_t result = uprv_realloc(*(void **)a1, 8LL * v5);
  *(void *)a1 = result;
  if (!result) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  int v8 = v7 + 1;
  result[v7] = a2;
LABEL_6:
  *(_DWORD *)(a1 + 8) = v8;
  return result;
}

uint64_t sub_180914210(uint64_t a1)
{
  for (uint64_t i = 0LL; i != 6; ++i)
  {
    if ((i - 4) <= 0xFFFFFFFC)
    {
      uint64_t v3 = *(void **)(a1 + 8 * i + 88);
      if (v3)
      {
        int v4 = sub_180915860(v3);
        icu::UMemory::operator delete(v4);
      }
    }
  }

  sub_180915108(a1 + 144);
  sub_180915108(a1 + 72);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)(a1 + 8));
  return a1;
}

uint64_t sub_18091427C(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 16);
  if ((v4 & 1) == 0)
  {
    if ((v4 & 0x8000) != 0) {
      int v5 = *(_DWORD *)(a1 + 20);
    }
    else {
      int v5 = v4 >> 5;
    }
    uint64_t result = 0LL;
    unsigned int v7 = *(unsigned __int16 *)(a2 + 16);
    if ((v7 & 0x8000u) == 0) {
      unsigned int v8 = v7 >> 5;
    }
    else {
      unsigned int v8 = *(_DWORD *)(a2 + 20);
    }
    if ((v7 & 1) != 0) {
      return result;
    }
    if (v5 != v8) {
      return result;
    }
    uint64_t result = icu::UnicodeString::doEquals((icu::UnicodeString *)(a1 + 8), (const icu::UnicodeString *)(a2 + 8), v5);
    if (!(_DWORD)result) {
      return result;
    }
    goto LABEL_16;
  }

  if ((*(_WORD *)(a2 + 16) & 1) == 0) {
    return 0LL;
  }
LABEL_16:
  for (uint64_t i = 0LL; i != 48; i += 8LL)
  {
    uint64_t v10 = *(void *)(a1 + 88 + i);
    uint64_t v11 = *(void *)(a2 + 88 + i);
    if (v10)
    {
      if (!v11) {
        return 0LL;
      }
      uint64_t result = sub_1809163EC(v10, v11);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else if (v11)
    {
      return 0LL;
    }
  }

  if (!*(_DWORD *)(a1 + 80)) {
    return 1LL;
  }
  unint64_t v12 = 0LL;
  do
  {
    uint64_t v13 = *(void *)(a1 + 72);
    if (v13) {
      uint64_t v14 = *(void *)(v13 + 8 * v12);
    }
    else {
      uint64_t v14 = 0LL;
    }
    uint64_t result = sub_1809163EC(v14, *(void *)(*(void *)(a2 + 72) + 8 * v12));
    if ((result & 1) == 0) {
      break;
    }
    ++v12;
  }

  while (v12 < *(unsigned int *)(a1 + 80));
  return result;
}

uint64_t sub_1809143AC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80))
  {
    unint64_t v2 = 0LL;
    do
    {
      uint64_t v3 = *(void *)(a1 + 72);
      if (v3) {
        uint64_t v4 = *(void *)(v3 + 8 * v2);
      }
      else {
        uint64_t v4 = 0LL;
      }
      sub_180918460(v4);
      ++v2;
    }

    while (v2 < *(unsigned int *)(a1 + 80));
  }

  for (uint64_t i = 1LL; i != 4; ++i)
  {
    uint64_t v6 = a1 + 8 * i;
    uint64_t v8 = *(void *)(v6 + 88);
    unsigned int v7 = (void **)(v6 + 88);
    if (v8)
    {
      unint64_t v9 = *(unsigned int *)(a1 + 152);
      if ((_DWORD)v9)
      {
        for (unint64_t j = 0LL; j < v9; ++j)
        {
          uint64_t v11 = *(void **)(*(void *)(a1 + 144) + 8 * j);
          if (**v7 == *v11)
          {
            sub_1809140C0((void *)a1, i, (uint64_t)v11, 0);
            unint64_t v9 = *(unsigned int *)(a1 + 152);
          }
        }
      }
    }
  }

  uint64_t v12 = 0LL;
  uint64_t v13 = a1 + 88;
  do
  {
    uint64_t result = *(void *)(v13 + v12);
    if (result) {
      uint64_t result = sub_180918460(result);
    }
    v12 += 8LL;
  }

  while (v12 != 48);
  return result;
}

_DWORD *sub_1809144A8( _DWORD *result, unint64_t a2, icu::UnicodeString *a3, uint64_t a4, int a5, UErrorCode *a6)
{
  if (a5 < 64)
  {
    uint64_t result = (_DWORD *)sub_180914528((uint64_t)result, a2);
    if (result) {
      return sub_180916A6C((uint64_t)result, a2, a3, a4, (a5 + 1), a6);
    }
  }

  else
  {
    *a6 = U_INVALID_STATE_ERROR;
  }

  return result;
}

uint64_t sub_180914528(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 160)) {
    return sub_18091478C(a1, (double)a2);
  }
  if ((a2 & 0x8000000000000000LL) == 0) {
    goto LABEL_4;
  }
  uint64_t v8 = *(uint64_t **)(a1 + 88);
  if (!v8)
  {
    a2 = -a2;
LABEL_4:
    int v4 = *(_DWORD *)(a1 + 80);
    if (v4 < 1)
    {
      return *(void *)(a1 + 112);
    }

    else
    {
      signed int v5 = 0;
      uint64_t v6 = *(void *)(a1 + 72);
      while (1)
      {
        unsigned int v7 = (v5 + v4) / 2;
        uint64_t v8 = *(uint64_t **)(v6 + 8LL * v7);
        if (*v8 == a2) {
          break;
        }
        if (*v8 <= a2) {
          signed int v5 = v7 + 1;
        }
        else {
          int v4 = (v5 + v4) / 2;
        }
        if (v5 >= v4)
        {
          if (!v4) {
            return 0LL;
          }
          uint64_t v8 = *(uint64_t **)(v6 + 8LL * (v4 - 1));
          if (v4 != 1 && (uint64_t v9 = *(void *)(a1 + 72)) != 0) {
            return *(void *)(v9 + 8LL * (v4 - 2));
          }
          else {
            return 0LL;
          }
        }
      }
    }
  }

  return (uint64_t)v8;
}

_DWORD *sub_180914608(_DWORD *result, icu::UnicodeString *a2, uint64_t a3, int a4, UErrorCode *a5, double a6)
{
  if (a4 < 64)
  {
    uint64_t result = (_DWORD *)sub_180914688((uint64_t)result, a6);
    if (result) {
      return sub_180916D94((uint64_t)result, a2, a3, (a4 + 1), a5, a6);
    }
  }

  else
  {
    *a5 = U_INVALID_STATE_ERROR;
  }

  return result;
}

uint64_t sub_180914688(uint64_t a1, double a2)
{
  double v2 = a2;
  if (*(_BYTE *)(a1 + 160)) {
    return sub_18091478C(a1, a2);
  }
  if (uprv_isNaN(a2))
  {
    uint64_t result = *(void *)(a1 + 128);
    if (!result) {
      return icu::RuleBasedNumberFormat::getDefaultNaNRule(*(icu::RuleBasedNumberFormat **)(a1 + 136));
    }
  }

  else
  {
    if (v2 < 0.0)
    {
      uint64_t result = *(void *)(a1 + 88);
      if (result) {
        return result;
      }
      double v2 = -v2;
    }

    if (uprv_isInfinite(v2))
    {
      uint64_t result = *(void *)(a1 + 120);
      if (!result) {
        return icu::RuleBasedNumberFormat::getDefaultInfinityRule(*(icu::RuleBasedNumberFormat **)(a1 + 136));
      }
    }

    else if (v2 == uprv_floor(v2) {
           || (v2 >= 1.0 || (uint64_t result = *(void *)(a1 + 104)) == 0) && (uint64_t result = *(void *)(a1 + 96)) == 0)
    }
    {
      uint64_t result = *(void *)(a1 + 112);
      if (!result)
      {
        uint64_t v5 = sub_180914940(v2 + 0.5);
        return sub_180914528(a1, v5);
      }
    }
  }

  return result;
}

uint64_t sub_18091478C(uint64_t a1, double a2)
{
  int v4 = *(uint64_t ***)(a1 + 72);
  uint64_t v5 = **v4;
  uint64_t v6 = *(unsigned int *)(a1 + 80);
  if (v6 >= 2)
  {
    for (uint64_t i = 1LL; i != v6; ++i)
    {
      uint64_t v8 = *v4[i];
      BOOL v9 = (v5 & 1) == 0;
      if (((v8 | v5) & 1) != 0)
      {
        char v10 = 0;
        uint64_t v12 = *v4[i];
        uint64_t v11 = v5;
      }

      else
      {
        char v10 = 0;
        uint64_t v11 = v5;
        uint64_t v12 = *v4[i];
        do
        {
          char v13 = v11 | v12;
          BOOL v14 = (v11 & 2) == 0;
          v11 >>= 1;
          v12 >>= 1;
          BOOL v9 = v14;
          ++v10;
        }

        while ((v13 & 2) == 0);
      }

      if (v9) {
        uint64_t v15 = v11;
      }
      else {
        uint64_t v15 = -v12;
      }
      if (v15)
      {
        do
        {
          do
          {
            uint64_t v16 = v15;
            v15 >>= 1;
          }

          while ((v16 & 1) == 0);
          if (v16 > 0) {
            uint64_t v11 = v16;
          }
          else {
            uint64_t v12 = -v16;
          }
          uint64_t v15 = v11 - v12;
        }

        while (v11 != v12);
      }

      uint64_t v5 = v5 / (v11 << v10) * v8;
    }
  }

  uint64_t v17 = sub_180914940(a2 * (double)v5 + 0.5);
  double v18 = uprv_maxMantissa();
  uint64_t v19 = sub_180914940(v18);
  uint64_t v20 = *(unsigned int *)(a1 + 80);
  uint64_t v21 = *(void *)(a1 + 72);
  if (!(_DWORD)v20)
  {
    unsigned int v23 = 0;
    goto LABEL_32;
  }

  uint64_t v22 = 0LL;
  unsigned int v23 = 0;
  while (1)
  {
    uint64_t v24 = **(void **)(v21 + 8 * v22) * v17 % v5;
    if (v5 - v24 < v24) {
      uint64_t v24 = v5 - v24;
    }
    if (v24 >= v19) {
      goto LABEL_28;
    }
    if (!v24) {
      break;
    }
    uint64_t v19 = v24;
    unsigned int v23 = v22;
LABEL_28:
    if (v20 == ++v22) {
      goto LABEL_32;
    }
  }

  unsigned int v23 = v22;
LABEL_32:
  if (v23 + 1 >= v20)
  {
    if (v21) {
      return *(void *)(v21 + 8LL * v23);
    }
    return 0LL;
  }

  else
  {
    uint64_t v25 = **(void **)(v21 + 8LL * (v23 + 1));
    if (v25 == **(void **)(v21 + 8LL * v23))
    {
      double v26 = (double)v25 * a2;
      if (v26 >= 2.0 || v26 < 0.5) {
        ++v23;
      }
    }

    return *(void *)(v21 + 8LL * v23);
  }

uint64_t sub_180914940(double a1)
{
  if (uprv_isNaN(a1)) {
    return 0LL;
  }
  double v3 = uprv_maxMantissa();
  double v4 = -v3;
  if (-v3 <= a1)
  {
    if (v3 < a1) {
      double v4 = v3;
    }
    else {
      double v4 = a1;
    }
  }

  double v5 = -v4;
  if (v4 >= 0.0) {
    double v5 = v4;
  }
  double v6 = uprv_floor(v5);
  if (v4 >= 0.0) {
    return (uint64_t)v6;
  }
  else {
    return -(uint64_t)v6;
  }
}

uint64_t sub_1809149A0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, icu::Formattable *this, int a6, double a7)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  icu::Formattable::setLong(this, 0);
  unsigned int v13 = *(unsigned __int16 *)(a2 + 8);
  int v14 = (__int16)v13;
  unsigned int v15 = v13 >> 5;
  if (v14 < 0) {
    unsigned int v15 = *(_DWORD *)(a2 + 12);
  }
  if (!v15) {
    return 0LL;
  }
  int v16 = 0;
  uint64_t v17 = 0LL;
  int v39 = off_18970F400;
  unint64_t v40 = 0xFFFFFFFF00000000LL;
  int v37 = off_18970F400;
  unint64_t v38 = *(void *)(a3 + 8);
  int v35 = -1;
  do
  {
    uint64_t v18 = a1 + 8 * v17;
    if (*(void *)(v18 + 88)) {
      BOOL v19 = ((1 << v17) & a4) == 0;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19)
    {
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v41 = 0u;
      icu::Formattable::Formattable((icu::Formattable *)&v41);
      uint64_t v20 = *(void *)(v18 + 88);
      if (a6) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = sub_180914C68(a1);
      }
      a4 = (1 << v17) | a4;
      else {
        BOOL v22 = 1;
      }
      if (!v22)
      {
        icu::Formattable::operator=((uint64_t)this, (uint64_t)&v41);
        int v16 = v38;
        unint64_t v40 = v38;
        int v35 = HIDWORD(v38);
      }

      unint64_t v38 = *(void *)(a3 + 8);
      icu::Formattable::~Formattable((icu::Formattable *)&v41);
    }

    ++v17;
  }

  while (v17 != 6);
  uint64_t v23 = sub_180914940(a7);
  uint64_t v24 = *(unsigned int *)(a1 + 80);
  if ((int)v24 < 1)
  {
    int v27 = v35;
  }

  else
  {
    uint64_t v25 = v23;
    unint64_t v26 = v24 + 1;
    int v27 = v35;
    do
    {
      unsigned int v28 = *(unsigned __int16 *)(a2 + 8);
      int v29 = (__int16)v28;
      int v30 = v28 >> 5;
      if (v29 < 0) {
        int v30 = *(_DWORD *)(a2 + 12);
      }
      if (v16 >= v30) {
        break;
      }
      unsigned int v31 = v26 - 2;
      if (*(_BYTE *)(a1 + 160) || **(void **)(*(void *)(a1 + 72) + 8LL * v31) < v25)
      {
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        __int128 v44 = 0u;
        __int128 v45 = 0u;
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        __int128 v41 = 0u;
        icu::Formattable::Formattable((icu::Formattable *)&v41);
        uint64_t v32 = *(void *)(a1 + 72);
        if (v32) {
          uint64_t v33 = *(void *)(v32 + 8LL * v31);
        }
        else {
          uint64_t v33 = 0LL;
        }
        if (sub_180917164( v33,  a2,  (uint64_t)&v37,  *(char *)(a1 + 160),  a4,  (icu::Formattable *)&v41,  1,  a7))
        {
          if ((int)v38 > v16)
          {
            icu::Formattable::operator=((uint64_t)this, (uint64_t)&v41);
            int v16 = v38;
            int v27 = HIDWORD(v38);
            unint64_t v40 = v38;
          }
        }

        unint64_t v38 = *(void *)(a3 + 8);
        icu::Formattable::~Formattable((icu::Formattable *)&v41);
      }

      --v26;
    }

    while (v26 > 1);
  }

  *(_DWORD *)(a3 + 8) = v16;
  *(_DWORD *)(a3 + 12) = v27;
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v37);
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v39);
  return 1LL;
}

BOOL sub_180914C68(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  unsigned int v13 = L"spellout-numbering-year";
  icu::UnicodeString::UnicodeString(&v18, 1LL, &v13);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  uint64_t v12 = L"spellout-ordinal";
  icu::UnicodeString::UnicodeString(&v14, 1LL, &v12);
  if ((SWORD4(v18) & 0x8000u) == 0) {
    int32_t v2 = WORD4(v18) >> 5;
  }
  else {
    int32_t v2 = HIDWORD(v18);
  }
  unint64_t v3 = *(__int16 *)(a1 + 16);
  if ((v3 & 0x80000000) != 0)
  {
    int32_t v4 = *(_DWORD *)(a1 + 20);
    if ((BYTE8(v18) & 1) != 0) {
      goto LABEL_14;
    }
  }

  else
  {
    int32_t v4 = *(unsigned __int16 *)(a1 + 16) >> 5;
    if ((BYTE8(v18) & 1) != 0) {
      goto LABEL_14;
    }
  }

  if (v2 >= 1)
  {
    if ((BYTE8(v18) & 2) != 0) {
      unint64_t v5 = (unint64_t)&v18 | 0xA;
    }
    else {
      unint64_t v5 = *((void *)&v19 + 1);
    }
    BOOL v6 = 0LL;
    unint64_t v3 = *(unsigned __int16 *)(a1 + 16);
  }

void *sub_180914E28(uint64_t a1, icu::UnicodeString *this)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 16);
  int v5 = (__int16)v4;
  unsigned int v6 = v4 >> 5;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *(unsigned int *)(a1 + 20);
  }
  icu::UnicodeString::doAppend((uint64_t)this, (const icu::UnicodeString *)(a1 + 8), 0, v7);
  __int16 v16 = 58;
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v16, 0, 1LL);
  __int16 v17 = 10;
  uint64_t result = (void *)icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v17, 0, 1LL);
  if (*(_DWORD *)(a1 + 80))
  {
    unint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(void *)(a1 + 72);
      if (v10) {
        uint64_t v11 = *(void *)(v10 + 8 * v9);
      }
      else {
        uint64_t v11 = 0LL;
      }
      sub_1809164F4(v11, (uint64_t)this);
      __int16 v18 = 10;
      uint64_t result = (void *)icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v18, 0, 1LL);
      ++v9;
    }

    while (v9 < *(unsigned int *)(a1 + 80));
  }

  for (uint64_t i = 0LL; i != 6; ++i)
  {
    unsigned int v13 = *(void **)(a1 + 8 * i + 88);
    if (v13)
    {
      if ((unint64_t)(*v13 + 4LL) > 2)
      {
        sub_1809164F4((uint64_t)v13, (uint64_t)this);
        __int16 v20 = 10;
        uint64_t result = (void *)icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v20, 0, 1LL);
      }

      else
      {
        unint64_t v14 = *(unsigned int *)(a1 + 152);
        if ((_DWORD)v14)
        {
          for (unint64_t j = 0LL; j < v14; ++j)
          {
            uint64_t result = *(void **)(*(void *)(a1 + 144) + 8 * j);
            if (*result == *v13)
            {
              sub_1809164F4((uint64_t)result, (uint64_t)this);
              __int16 v19 = 10;
              uint64_t result = (void *)icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v19, 0, 1LL);
              unint64_t v14 = *(unsigned int *)(a1 + 152);
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_180914FB8(uint64_t result, unsigned int a2)
{
  if (!(_DWORD)result) {
    return 0LL;
  }
  uint64_t v2 = result;
  if ((a2 & 1) != 0) {
    uint64_t result = result;
  }
  else {
    uint64_t result = 1LL;
  }
  if (a2 >= 2)
  {
    do
    {
      v2 *= v2;
      if ((a2 & 2) != 0) {
        uint64_t v3 = v2;
      }
      else {
        uint64_t v3 = 1LL;
      }
      result *= v3;
      BOOL v4 = a2 > 3;
      a2 >>= 1;
    }

    while (v4);
  }

  return result;
}

unint64_t sub_180914FFC(uint64_t a1, __int16 *a2, int a3, unsigned int a4, int a5)
{
  if (a4 <= 2) {
    unsigned int v5 = 2;
  }
  else {
    unsigned int v5 = a4;
  }
  if (v5 >= 0x24) {
    uint64_t v6 = 36LL;
  }
  else {
    uint64_t v6 = v5;
  }
  if (!a5 && a3 && a1 < 0 && (_DWORD)v6 == 10)
  {
    a1 = -a1;
    *a2 = 45;
    uint64_t v7 = (char *)(a2 + 1);
    --a3;
  }

  else
  {
    if (!a1 && a3)
    {
      if (a5) {
        __int16 v8 = 0;
      }
      else {
        __int16 v8 = 48;
      }
      *a2 = v8;
      uint64_t v7 = (char *)(a2 + 1);
      if (a3 == 1) {
        goto LABEL_33;
      }
      goto LABEL_32;
    }

    uint64_t v7 = (char *)a2;
  }

  BOOL v9 = a3 != 0;
  if (a3 && a1)
  {
    int v10 = a3 - 1;
    do
    {
      uint64_t v11 = a1 / v6;
      uint64_t v12 = a1 % v6;
      if (!a5) {
        LOWORD(v12) = a0123456789abcd_2[(int)v12];
      }
      *(_WORD *)uint64_t v7 = v12;
      v7 += 2;
      BOOL v13 = v10-- != 0;
      BOOL v9 = v13;
      if (!v13) {
        break;
      }
      a1 /= v6;
    }

    while (v11);
  }

  if (v9) {
LABEL_32:
  }
    *(_WORD *)uint64_t v7 = 0;
LABEL_33:
  unint64_t v14 = v7 - 2;
  if (v7 - 2 > (char *)&a2[*a2 == 45])
  {
    unint64_t v15 = (unint64_t)&a2[(*a2 == 45) + 1];
    do
    {
      __int16 v16 = *(_WORD *)v14;
      *(_WORD *)unint64_t v14 = *(_WORD *)(v15 - 2);
      v14 -= 2;
      *(_WORD *)(v15 - 2) = v16;
      BOOL v17 = (unint64_t)v14 > v15;
      v15 += 2LL;
    }

    while (v17);
  }

  return (unint64_t)(v7 - (char *)a2) >> 1;
}

uint64_t sub_180915108(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    unint64_t v3 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v3)
    {
      for (unint64_t i = 0LL; i < v3; ++i)
      {
        unsigned int v5 = *(void **)(*(void *)a1 + 8 * i);
        if (v5)
        {
          uint64_t v6 = sub_180915860(v5);
          icu::UMemory::operator delete(v6);
          unint64_t v3 = *(unsigned int *)(a1 + 8);
        }
      }

      uint64_t v2 = *(void **)a1;
    }

    uprv_free(v2);
  }

  return a1;
}

uint64_t sub_180915168(uint64_t a1, uint64_t a2, UChar **a3, _DWORD *a4)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 10LL;
  uint64_t v7 = a1 + 16;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(a1 + 16), a3);
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = a2;
  *(void *)(a1 + 104) = 0LL;
  return a1;
}

void *sub_1809151D4(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  unsigned int v6 = *(unsigned __int16 *)(a2 + 8);
  int v7 = (__int16)v6;
  int32_t v8 = v6 >> 5;
  if (v7 >= 0) {
    int32_t v9 = v8;
  }
  else {
    int32_t v9 = *(_DWORD *)(a2 + 12);
  }
  uint64_t result = (void *)icu::UnicodeString::doIndexOf(a2, 0x3Au, 0, v9);
  if ((_DWORD)result != -1)
  {
    uint64_t v11 = (uint64_t)result;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    uint64_t v64 = 0LL;
    __int128 v63 = 0u;
    int v60 = off_18971B688;
    LOWORD(v6sub_1808F7164((uint64_t)v14, 1) = 2;
    icu::UnicodeString::unBogus((uint64_t)&v60);
    if ((v61 & 0x8000u) == 0LL) {
      uint64_t v12 = (unsigned __int16)v61 >> 5;
    }
    else {
      uint64_t v12 = DWORD1(v61);
    }
    icu::UnicodeString::doReplace((icu::UnicodeString *)&v60, 0LL, v12, (const icu::UnicodeString *)a2, 0, v11);
    uint64_t v13 = (int)v11 + 1LL;
    do
    {
      uint64_t v14 = v13;
      int v15 = *(__int16 *)(a2 + 8);
      if (v15 < 0)
      {
        int64_t v16 = *(int *)(a2 + 12);
        if (v13 >= v16) {
          break;
        }
      }

      else
      {
        int64_t v16 = (unint64_t)*(unsigned __int16 *)(a2 + 8) >> 5;
      }

      if (v16 <= v13)
      {
        uint64_t v18 = 0xFFFFLL;
      }

      else
      {
        if ((v15 & 2) != 0) {
          uint64_t v17 = a2 + 10;
        }
        else {
          uint64_t v17 = *(void *)(a2 + 24);
        }
        uint64_t v18 = *(unsigned __int16 *)(v17 + 2 * v13);
      }

      ++v13;
    }

    while (icu::PatternProps::isWhiteSpace((icu::PatternProps *)v18));
    icu::UnicodeString::doReplace(a2, 0LL, v14, 0LL, 0, 0LL);
    if ((v61 & 0x8000u) == 0LL) {
      uint64_t v19 = (unsigned __int16)v61 >> 5;
    }
    else {
      uint64_t v19 = DWORD1(v61);
    }
    if ((_DWORD)v19)
    {
      __int16 v20 = (unsigned __int16 *)&v61 + 1;
      if ((v61 & 2) == 0) {
        __int16 v20 = (unsigned __int16 *)v62;
      }
      int v21 = *v20;
    }

    else
    {
      int v21 = 0xFFFF;
    }

    unsigned int v22 = v19 - 1;
    if ((v61 & 0x8000u) == 0LL) {
      unsigned int v23 = (unsigned __int16)v61 >> 5;
    }
    else {
      unsigned int v23 = DWORD1(v61);
    }
    if (v23 <= v22)
    {
      int v25 = 0xFFFF;
    }

    else
    {
      if ((v61 & 2) != 0) {
        uint64_t v24 = (char *)&v61 + 2;
      }
      else {
        uint64_t v24 = (char *)v62;
      }
      int v25 = *(unsigned __int16 *)&v24[2 * v22];
    }

    if ((v21 - 48) <= 9 && v25 != 120)
    {
      if ((int)v19 < 1)
      {
        LODWORD(v19) = 0;
        uint64_t v27 = 0LL;
        LODWORD(v30) = 32;
LABEL_64:
        sub_180915FC8(a1, v27, (uint64_t)a3);
        goto LABEL_65;
      }

      unint64_t v26 = 0LL;
      uint64_t v27 = 0LL;
      while (1)
      {
        if ((v61 & 0x8000u) == 0LL) {
          unint64_t v28 = (unsigned __int16)v61 >> 5;
        }
        else {
          unint64_t v28 = DWORD1(v61);
        }
        if (v26 >= v28)
        {
          uint64_t v30 = 0xFFFFLL;
        }

        else
        {
          if ((v61 & 2) != 0) {
            int v29 = (char *)&v61 + 2;
          }
          else {
            int v29 = (char *)v62;
          }
          uint64_t v30 = *(unsigned __int16 *)&v29[2 * v26];
          uint64_t v31 = (v30 - 48);
          if (v31 <= 9)
          {
            uint64_t v27 = v31 + 10 * v27;
            goto LABEL_55;
          }

          if ((_DWORD)v30 == 47 || (_DWORD)v30 == 62)
          {
            sub_180915FC8(a1, v27, (uint64_t)a3);
            if ((_DWORD)v30 == 47)
            {
              unint64_t v44 = v26 + 1;
              if ((int)v44 >= (int)v19)
              {
                *(_DWORD *)(a1 + 8) = 0;
                LODWORD(v30) = 47;
                LODWORD(v19) = v44;
                goto LABEL_128;
              }

              int v45 = 0;
              while (2)
              {
                if ((v61 & 0x8000u) == 0LL) {
                  unint64_t v46 = (unsigned __int16)v61 >> 5;
                }
                else {
                  unint64_t v46 = DWORD1(v61);
                }
                if (v44 >= v46)
                {
                  uint64_t v30 = 0xFFFFLL;
                }

                else
                {
                  if ((v61 & 2) != 0) {
                    __int128 v47 = (char *)&v61 + 2;
                  }
                  else {
                    __int128 v47 = (char *)v62;
                  }
                  uint64_t v30 = *(unsigned __int16 *)&v47[2 * v44];
                  if ((v30 - 48) <= 9)
                  {
                    int v45 = v30 + 10 * v45 - 48;
                    goto LABEL_96;
                  }

                  if ((_DWORD)v30 == 62)
                  {
                    LODWORD(v19) = v44;
LABEL_132:
                    *(_DWORD *)(a1 + 8) = v45;
                    if (v45)
                    {
LABEL_133:
                      *(_WORD *)(a1 + 12) = sub_180916054(a1);
                      goto LABEL_65;
                    }

void *sub_1809157E0(void *a1)
{
  uint64_t v2 = a1[10];
  uint64_t v3 = a1[11];
  if (v2 != v3)
  {
    if (v3)
    {
      (*(void (**)(void))(*(void *)v3 + 8LL))(a1[11]);
      uint64_t v2 = a1[10];
    }

    a1[11] = 0LL;
  }

  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  a1[10] = 0LL;
  uint64_t v4 = a1[13];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  a1[13] = 0LL;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)(a1 + 2));
  return a1;
}

void sub_180915864(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, UErrorCode *a6)
{
  int v54 = (uint64_t *)*MEMORY[0x1895F89C0];
  uint64_t v12 = icu::UMemory::operator new(v54, (icu::UMemory *)0x70, a2);
  if (!v12)
  {
    *a6 = U_MEMORY_ALLOCATION_ERROR;
    return;
  }

  uint64_t v13 = (uint64_t)v12;
  uint64_t v14 = sub_180915168((uint64_t)v12, a4, (UChar **)a1, a6);
  icu::UnicodeString::operator=((UChar **)a1, (UChar **)(v14 + 16));
  unsigned int v15 = *(unsigned __int16 *)(a1 + 8);
  int v16 = (__int16)v15;
  int32_t v17 = v15 >> 5;
  if (v16 >= 0) {
    int32_t v18 = v17;
  }
  else {
    int32_t v18 = *(_DWORD *)(a1 + 12);
  }
  uint64_t v19 = icu::UnicodeString::doIndexOf(a1, 0x5Bu, 0, v18);
  if ((v19 & 0x80000000) == 0)
  {
    uint64_t v20 = v19;
    unsigned int v21 = *(unsigned __int16 *)(a1 + 8);
    int v22 = (__int16)v21;
    unsigned int v23 = v21 >> 5;
    int32_t v24 = v22 >= 0 ? v23 : *(_DWORD *)(a1 + 12);
    int v25 = icu::UnicodeString::doIndexOf(a1, 0x5Du, 0, v24);
    if ((v25 & 0x80000000) == 0)
    {
      int v27 = v25;
      if ((int)v20 <= v25)
      {
        uint64_t v28 = *(void *)v13;
        int v29 = *(uint64_t *)v13 >= 1 ? -7 : *(void *)v13;
        unsigned int v30 = v29 + 6;
        BOOL v31 = v30 > 5;
        int v32 = (1 << v30) & 0x2B;
        if (v31 || v32 == 0)
        {
          __int128 v50 = 0u;
          uint64_t v53 = 0LL;
          __int128 v52 = 0u;
          __int128 v51 = 0u;
          unsigned int v49 = (UChar *)off_18971B688;
          LOWORD(v50) = 2;
          if (v28 >= 1)
          {
            unint64_t v34 = v28 % (unint64_t)sub_180914FB8(*(unsigned int *)(v13 + 8), *(unsigned __int16 *)(v13 + 12));
            if (!v34) {
              goto LABEL_30;
            }
            uint64_t v28 = *(void *)v13;
          }

          if (v28 >= 1) {
            int v35 = -7;
          }
          else {
            int v35 = v28;
          }
          unint64_t v34 = v35 | 2u;
          if ((_DWORD)v34 != -2)
          {
            uint64_t v37 = 0LL;
            int v41 = v27 + 1;
            goto LABEL_47;
          }

uint64_t sub_180915C34(uint64_t result, uint64_t a2, UChar **a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = result;
    int32_t v9 = (icu::UnicodeString *)(result + 16);
    icu::UnicodeString::operator=((UChar **)(result + 16), a3);
    int v10 = sub_1809160D4(v8, a2, a4, a5);
    *(void *)(v8 + 80) = v10;
    if (v10) {
      int v10 = sub_1809160D4(v8, a2, a4, a5);
    }
    *(void *)(v8 + 88) = v10;
    unsigned int v11 = *(unsigned __int16 *)(v8 + 24);
    if ((v11 & 0x8000) != 0)
    {
      int v13 = *(_DWORD *)(v8 + 28);
      int v12 = v13 & (v13 >> 31);
    }

    else
    {
      int v12 = 0;
      int v13 = v11 >> 5;
    }

    uint64_t result = icu::UnicodeString::indexOf((uint64_t)v9, (uint64_t)L"$(", 0, -1, v12, v13 - v12);
    if ((result & 0x80000000) == 0)
    {
      int v14 = result;
      if (*(__int16 *)(v8 + 24) < 0)
      {
        int v15 = *(_DWORD *)(v8 + 28);
        int v16 = v15 >= (int)result ? result : *(_DWORD *)(v8 + 28);
      }

      else
      {
        int v15 = *(unsigned __int16 *)(v8 + 24) >> 5;
        int v16 = v15 >= result ? result : *(unsigned __int16 *)(v8 + 24) >> 5;
      }

      uint64_t result = icu::UnicodeString::indexOf((uint64_t)v9, (uint64_t)")", 0, -1, v16, v15 - v16);
      if ((result & 0x80000000) == 0)
      {
        int v17 = result;
        if (*(__int16 *)(v8 + 24) < 0)
        {
          int v18 = *(_DWORD *)(v8 + 28);
          if (v18 >= v14) {
            int v19 = v14;
          }
          else {
            int v19 = *(_DWORD *)(v8 + 28);
          }
        }

        else
        {
          int v18 = *(unsigned __int16 *)(v8 + 24) >> 5;
          else {
            int v19 = *(unsigned __int16 *)(v8 + 24) >> 5;
          }
        }

        uint64_t result = icu::UnicodeString::doIndexOf((uint64_t)v9, 0x2Cu, v19, v18 - v19);
        if ((result & 0x80000000) != 0)
        {
          *a5 = U_PARSE_ERROR;
          return result;
        }

        int v20 = result;
        memset(v47, 0, sizeof(v47));
        icu::UnicodeString::tempSubString(v9, v14 + 2, result - v14 - 2, (icu::UnicodeString *)v47);
        int v41 = "c";
        icu::UnicodeString::UnicodeString(v42, 1LL, &v41);
        unint64_t v21 = v43;
        if ((v43 & 0x8000u) == 0) {
          int32_t v22 = v43 >> 5;
        }
        else {
          int32_t v22 = v45;
        }
        if ((v43 & 1) != 0)
        {
          unint64_t v21 = BYTE8(v47[0]);
          int v26 = BYTE8(v47[0]) & 1;
          goto LABEL_42;
        }

        int v23 = v22 & (v22 >> 31);
        if (v22 < 0)
        {
          int32_t v24 = 0;
        }

        else
        {
          int32_t v24 = v22 - v23;
          int32_t v25 = v22;
          if (v22 - v23 >= v22)
          {
LABEL_36:
            if ((BYTE8(v47[0]) & 1) != 0)
            {
              int v26 = 0;
            }

            else
            {
              if ((v43 & 2) != 0) {
                int v27 = v44;
              }
              else {
                int v27 = v46;
              }
              int v26 = icu::UnicodeString::doEqualsSubstring((uint64_t)v47, 0, v22, (uint64_t)v27, v23, v25);
            }

uint64_t sub_180915FC8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  *(void *)uint64_t result = a2;
  *(_DWORD *)(result + 8) = 10;
  if (a2 < 1)
  {
    *(_WORD *)(result + 12) = 0;
  }

  else
  {
    uint64_t v5 = sub_180916054(result);
    *(_WORD *)(v3 + 12) = v5;
    uint64_t v6 = *(void *)(v3 + 80);
    if (v6) {
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v6 + 32LL))( v6,  *(unsigned int *)(v3 + 8),  v5,  a3);
    }
    uint64_t result = *(void *)(v3 + 88);
    if (result) {
      return (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)result + 32LL))( result,  *(unsigned int *)(v3 + 8),  *(__int16 *)(v3 + 12),  a3);
    }
  }

  return result;
}

uint64_t sub_180916054(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1)
  {
    if (*(uint64_t *)a1 < 1)
    {
      LOWORD(vsub_1808F7164((uint64_t)v14, 1) = 0;
    }

    else
    {
      double v3 = uprv_log((double)*(uint64_t *)a1);
      int v4 = (int)(v3 / uprv_log((double)*(int *)(a1 + 8)));
      else {
        LOWORD(vsub_1808F7164((uint64_t)v14, 1) = v4 + 1;
      }
    }
  }

  return (__int16)v1;
}

uint64_t *sub_1809160D4(uint64_t a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v8 = sub_180916358(a1);
  if ((_DWORD)v8 == -1) {
    return 0LL;
  }
  uint64_t v9 = v8;
  if (*(__int16 *)(a1 + 24) < 0)
  {
    int v11 = *(_DWORD *)(a1 + 28);
    int v10 = v11 & (v11 >> 31);
  }

  else
  {
    int v10 = 0;
    int v11 = *(unsigned __int16 *)(a1 + 24) >> 5;
  }

  if (icu::UnicodeString::indexOf(a1 + 16, (uint64_t)L">>>", 0, 3, v10, v11 - v10) == (_DWORD)v8)
  {
    signed int v12 = v9 + 2;
  }

  else
  {
    unsigned int v14 = *(unsigned __int16 *)(a1 + 24);
    else {
      unsigned int v15 = v14 >> 5;
    }
    if (v15 <= v9)
    {
      int v17 = 0xFFFF;
    }

    else
    {
      if ((v14 & 2) != 0) {
        uint64_t v16 = a1 + 26;
      }
      else {
        uint64_t v16 = *(void *)(a1 + 40);
      }
      int v17 = *(unsigned __int16 *)(v16 + 2LL * (int)v9);
    }

    if ((int)v9 >= -1)
    {
      int v20 = v9 + 1;
      if ((v14 & 0x8000) != 0)
      {
        int v19 = *(_DWORD *)(a1 + 28);
        if (v19 >= v20) {
          int v18 = v9 + 1;
        }
        else {
          int v18 = *(_DWORD *)(a1 + 28);
        }
      }

      else
      {
        int v19 = v14 >> 5;
        else {
          int v18 = v19;
        }
      }
    }

    else
    {
      int v18 = 0;
      if ((v14 & 0x8000) != 0) {
        int v19 = *(_DWORD *)(a1 + 28);
      }
      else {
        int v19 = v14 >> 5;
      }
    }

    signed int v12 = icu::UnicodeString::doIndexOf(a1 + 16, v17, v18, v19 - v18);
    if (v17 == 60 && v12 != -1)
    {
      unsigned int v21 = *(unsigned __int16 *)(a1 + 24);
      else {
        unsigned int v22 = v21 >> 5;
      }
      if (v12 < (int)(v22 - 1) && v22 > v12 + 1)
      {
        uint64_t v23 = (v21 & 2) != 0 ? a1 + 26 : *(void *)(a1 + 40);
        if (*(_WORD *)(v23 + 2LL * (v12 + 1)) == 60) {
          ++v12;
        }
      }

      goto LABEL_41;
    }
  }

  if (v12 == -1) {
    return 0LL;
  }
LABEL_41:
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  uint64_t v32 = 0LL;
  __int128 v31 = 0u;
  unint64_t v28 = off_18971B688;
  LOWORD(v29) = 2;
  uint64_t v24 = (v12 - v9 + 1);
  icu::UnicodeString::unBogus((uint64_t)&v28);
  if ((v29 & 0x8000u) == 0LL) {
    uint64_t v25 = (unsigned __int16)v29 >> 5;
  }
  else {
    uint64_t v25 = DWORD1(v29);
  }
  icu::UnicodeString::doReplace((icu::UnicodeString *)&v28, 0LL, v25, (const icu::UnicodeString *)(a1 + 16), v9, v24);
  int v13 = sub_180918894(v9, (uint64_t **)a1, a3, a2, *(void *)(a1 + 96), (uint64_t)&v28, a4);
  icu::UnicodeString::doReplace(a1 + 16, v9, v24, 0LL, 0, 0LL);
  icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)&v28);
  return v13;
}

uint64_t sub_180916358(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = a1 + 16;
  LODWORD(v4) = -1;
  do
  {
    else {
      int32_t v5 = *(unsigned __int16 *)(a1 + 24) >> 5;
    }
    int v6 = icu::UnicodeString::doIndexOf(v3, *(&off_189726CC8)[v2], 0, v5);
    else {
      unsigned int v8 = v4;
    }
    if (v6 == -1) {
      uint64_t v4 = v4;
    }
    else {
      uint64_t v4 = v8;
    }
    ++v2;
  }

  while (v2 != 11);
  return v4;
}

uint64_t sub_1809163EC(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2
    || *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12))
  {
    return 0LL;
  }

  unsigned int v4 = *(unsigned __int16 *)(a1 + 24);
  if ((v4 & 1) != 0)
  {
    if ((*(_WORD *)(a2 + 24) & 1) == 0) {
      return 0LL;
    }
    goto LABEL_16;
  }

  if ((v4 & 0x8000) != 0) {
    int v5 = *(_DWORD *)(a1 + 28);
  }
  else {
    int v5 = v4 >> 5;
  }
  uint64_t result = 0LL;
  unsigned int v7 = *(unsigned __int16 *)(a2 + 24);
  if ((v7 & 0x8000u) == 0) {
    unsigned int v8 = v7 >> 5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a2 + 28);
  }
  if ((v7 & 1) == 0 && v5 == v8)
  {
    uint64_t result = icu::UnicodeString::doEquals((icu::UnicodeString *)(a1 + 16), (const icu::UnicodeString *)(a2 + 16), v5);
    if ((_DWORD)result)
    {
LABEL_16:
      uint64_t v9 = *(void *)(a1 + 80);
      uint64_t v10 = *(void *)(a2 + 80);
      if (v9)
      {
        if (v10)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24LL))(v9);
          if (!(_DWORD)result) {
            return result;
          }
          goto LABEL_21;
        }
      }

      else if (!v10)
      {
LABEL_21:
        uint64_t v11 = *(void *)(a1 + 88);
        uint64_t v12 = *(void *)(a2 + 88);
        if (v11)
        {
          if (v12) {
            return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 24LL))(v11);
          }
        }

        else if (!v12)
        {
          return 1LL;
        }
      }

      return 0LL;
    }
  }

  return result;
}

void *sub_1809164F4(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  else {
    int v4 = *(void *)a1;
  }
  switch(v4)
  {
    case -6:
      icu::UnicodeString::doAppend(a2, (uint64_t)L"NaN", 0, 3LL);
      break;
    case -5:
      icu::UnicodeString::doAppend(a2, (uint64_t)L"Inf", 0, 3LL);
      break;
    case -4:
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 120;
      uint64_t v6 = icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
      __int16 v7 = *(_WORD *)(a1 + 14);
      if (!v7) {
        __int16 v7 = 46;
      }
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = v7;
      uint64_t v8 = icu::UnicodeString::doAppend(v6, (uint64_t)&v31, 0, 1LL);
      __int16 v9 = 48;
      goto LABEL_18;
    case -3:
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 48;
      uint64_t v10 = icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
      __int16 v11 = *(_WORD *)(a1 + 14);
      if (!v11) {
        __int16 v11 = 46;
      }
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = v11;
      uint64_t v8 = icu::UnicodeString::doAppend(v10, (uint64_t)&v31, 0, 1LL);
      __int16 v9 = 120;
LABEL_18:
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = v9;
      goto LABEL_22;
    case -2:
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 120;
      uint64_t v12 = icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
      __int16 v13 = *(_WORD *)(a1 + 14);
      if (!v13) {
        __int16 v13 = 46;
      }
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = v13;
      uint64_t v8 = icu::UnicodeString::doAppend(v12, (uint64_t)&v31, 0, 1LL);
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 120;
LABEL_22:
      icu::UnicodeString::doAppend(v8, (uint64_t)&v31, 0, 1LL);
      break;
    case -1:
      icu::UnicodeString::doAppend(a2, (uint64_t)"-", 0, 2LL);
      break;
    default:
      sub_180916960(a2, *(void *)a1);
      if (*(_DWORD *)(a1 + 8) != 10)
      {
        LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 47;
        icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
        sub_180916960(a2, *(int *)(a1 + 8));
      }

      int v5 = sub_180916054(a1) - *(__int16 *)(a1 + 12);
      if (v5 >= 1)
      {
        do
        {
          LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 62;
          icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
          --v5;
        }

        while (v5);
      }

      break;
  }

  LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 58;
  icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
  LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 32;
  icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
  unsigned int v14 = *(unsigned __int16 *)(a1 + 24);
  if (*(__int16 *)(a1 + 24) < 0)
  {
    if (!*(_DWORD *)(a1 + 28)) {
      goto LABEL_35;
    }
  }

  else if (!(v14 >> 5))
  {
    goto LABEL_35;
  }

  if ((v14 & 2) != 0) {
    unsigned int v15 = (_WORD *)(a1 + 26);
  }
  else {
    unsigned int v15 = *(_WORD **)(a1 + 40);
  }
  if (*v15 == 32)
  {
    uint64_t v16 = *(void *)(a1 + 80);
    if (!v16 || *(_DWORD *)(v16 + 8))
    {
      LOWORD(v3sub_1808F7164((uint64_t)v14, 1) = 39;
      icu::UnicodeString::doAppend(a2, (uint64_t)&v31, 0, 1LL);
    }
  }

void *sub_180916960(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  memset(v8, 0, sizeof(v8));
  unint64_t v3 = sub_180914FFC(a2, (__int16 *)v8, 512, 0xAu, 0);
  memset(v7, 0, sizeof(v7));
  icu::UnicodeString::UnicodeString((uint64_t)v7, (uint64_t)v8, v3);
  if ((SWORD4(v7[0]) & 0x8000u) == 0) {
    uint64_t v4 = WORD4(v7[0]) >> 5;
  }
  else {
    uint64_t v4 = HIDWORD(v7[0]);
  }
  icu::UnicodeString::doAppend(a1, (const icu::UnicodeString *)v7, 0, v4);
  return icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v7);
}

uint64_t sub_180916A5C(uint64_t a1)
{
  return sub_180914FB8(*(unsigned int *)(a1 + 8), *(unsigned __int16 *)(a1 + 12));
}

_DWORD *sub_180916A6C( uint64_t a1, unint64_t a2, icu::UnicodeString *this, uint64_t a4, uint64_t a5, UErrorCode *a6)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  uint64_t v12 = (const icu::UnicodeString *)(a1 + 16);
  uint64_t v13 = *(void *)(a1 + 104);
  if (*(__int16 *)(a1 + 24) < 0)
  {
    uint64_t v14 = *(unsigned int *)(a1 + 28);
    if (v13)
    {
      int v15 = v14 & ((int)v14 >> 31);
      goto LABEL_6;
    }

_DWORD *sub_180916D94( uint64_t a1, icu::UnicodeString *this, uint64_t a3, uint64_t a4, UErrorCode *a5, double a6)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  uint64_t v12 = (const icu::UnicodeString *)(a1 + 16);
  uint64_t v13 = *(void *)(a1 + 104);
  if (*(__int16 *)(a1 + 24) < 0)
  {
    uint64_t v14 = *(unsigned int *)(a1 + 28);
    if (v13)
    {
      int v15 = v14 & ((int)v14 >> 31);
      goto LABEL_6;
    }

uint64_t sub_1809170E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4 && (*(unsigned int (**)(uint64_t))(*(void *)v4 + 112LL))(v4)
    || (uint64_t result = *(void *)(a1 + 88)) != 0
    && (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 112LL))(result), (_DWORD)result))
  {
    uint64_t v6 = sub_180914FB8(*(unsigned int *)(a1 + 8), *(unsigned __int16 *)(a1 + 12));
    return !(a2 % v6) && *(void *)a1 % v6 != 0;
  }

  return result;
}

uint64_t sub_180917164( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, icu::Formattable *a6, int a7, double a8)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  int v54 = off_18970F400;
  unint64_t v55 = 0xFFFFFFFF00000000LL;
  memset(v71, 0, sizeof(v71));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v71, (UChar **)a2);
  uint64_t v13 = *(void *)(a1 + 80);
  if (v13)
  {
    uint64_t v14 = *(unsigned int *)(v13 + 8);
  }

  else if (*(__int16 *)(a1 + 24) < 0)
  {
    uint64_t v14 = *(unsigned int *)(a1 + 28);
  }

  else
  {
    uint64_t v14 = *(unsigned __int16 *)(a1 + 24) >> 5;
  }

  uint64_t v15 = *(void *)(a1 + 88);
  if (v15)
  {
    int v16 = *(_DWORD *)(v15 + 8);
  }

  else if (*(__int16 *)(a1 + 24) < 0)
  {
    int v16 = *(_DWORD *)(a1 + 28);
  }

  else
  {
    int v16 = *(unsigned __int16 *)(a1 + 24) >> 5;
  }

  __int128 v67 = 0u;
  uint64_t v70 = 0LL;
  __int128 v69 = 0u;
  __int128 v68 = 0u;
  int v66 = off_18971B688;
  LOWORD(v67) = 2;
  icu::UnicodeString::unBogus((uint64_t)&v66);
  if ((v67 & 0x8000u) == 0LL) {
    uint64_t v17 = (unsigned __int16)v67 >> 5;
  }
  else {
    uint64_t v17 = DWORD1(v67);
  }
  icu::UnicodeString::doReplace((icu::UnicodeString *)&v66, 0LL, v17, (const icu::UnicodeString *)(a1 + 16), 0, v14);
  sub_1809176AC(a1, (uint64_t)v71, (uint64_t)&v66, (uint64_t)&v54);
  unsigned int v18 = *(unsigned __int16 *)(a2 + 8);
  int v19 = (__int16)v18;
  unsigned int v20 = v18 >> 5;
  if (v19 >= 0) {
    unsigned int v21 = v20;
  }
  else {
    unsigned int v21 = *(_DWORD *)(a2 + 12);
  }
  if ((SWORD4(v71[0]) & 0x8000u) == 0) {
    int v22 = WORD4(v71[0]) >> 5;
  }
  else {
    int v22 = HIDWORD(v71[0]);
  }
  if (!(_DWORD)v55 && (_DWORD)v14) {
    goto LABEL_22;
  }
  uint64_t v24 = *(void *)a1;
  if (*(void *)a1 == -6LL)
  {
    *(_DWORD *)(a3 + 8) = v55;
    double NaN = uprv_getNaN();
    goto LABEL_27;
  }

  if (v24 == -5)
  {
    *(_DWORD *)(a3 + 8) = v55;
    double NaN = uprv_getInfinity();
LABEL_27:
    icu::Formattable::setDouble(a6, NaN);
    goto LABEL_70;
  }

  if (!a7)
  {
    uint64_t v47 = *(void *)(a1 + 80);
    if (v47)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v47 + 120LL))(v47))
      {
LABEL_22:
        *(_DWORD *)(a3 + 12) = HIDWORD(v55);
        icu::Formattable::setLong(a6, 0);
        goto LABEL_70;
      }

      uint64_t v24 = *(void *)a1;
    }
  }

  int v26 = 0;
  uint64_t v27 = 0LL;
  unsigned int v49 = v21 - v22;
  double v28 = 0.0;
  __int128 v62 = 0u;
  uint64_t v65 = 0LL;
  if (v24 >= 1) {
    double v29 = (double)v24;
  }
  else {
    double v29 = 0.0;
  }
  __int128 v64 = 0uLL;
  __int128 v63 = 0uLL;
  __int128 v61 = off_18971B688;
  LOWORD(v62) = 2;
  do
  {
    LODWORD(v55) = 0;
    icu::UnicodeString::unBogus((uint64_t)&v61);
    if ((v62 & 0x8000u) == 0LL) {
      uint64_t v30 = (unsigned __int16)v62 >> 5;
    }
    else {
      uint64_t v30 = DWORD1(v62);
    }
    icu::UnicodeString::doReplace( (icu::UnicodeString *)&v61,  0LL,  v30,  (const icu::UnicodeString *)(a1 + 16),  v14,  (v16 - v14));
    double v31 = sub_18091775C( a1,  (const icu::UnicodeString *)v71,  v27,  (uint64_t)&v61,  (uint64_t)&v54,  *(void *)(a1 + 80),  a5,  v29,  a8);
    uint64_t v32 = v55;
    if ((_DWORD)v55 || !*(void *)(a1 + 80))
    {
      uint64_t v60 = 0LL;
      __int128 v58 = 0u;
      __int128 v59 = 0u;
      __int128 v57 = 0u;
      uint64_t v56 = off_18971B688;
      LOWORD(v57) = 2;
      int v33 = WORD4(v71[0]) >> 5;
      if (SWORD4(v71[0]) < 0) {
        int v33 = HIDWORD(v71[0]);
      }
      uint64_t v34 = (v33 - v55);
      icu::UnicodeString::unBogus((uint64_t)&v56);
      if ((v57 & 0x8000u) == 0LL) {
        uint64_t v35 = (unsigned __int16)v57 >> 5;
      }
      else {
        uint64_t v35 = DWORD1(v57);
      }
      icu::UnicodeString::doReplace((icu::UnicodeString *)&v56, 0LL, v35, (const icu::UnicodeString *)v71, v32, v34);
      __int128 v52 = off_18970F400;
      unint64_t v53 = 0xFFFFFFFF00000000LL;
      unsigned int v36 = *(unsigned __int16 *)(a1 + 24);
      if ((v36 & 0x8000) != 0) {
        unsigned int v37 = *(_DWORD *)(a1 + 28);
      }
      else {
        unsigned int v37 = v36 >> 5;
      }
      uint64_t v38 = v37 - v16;
      icu::UnicodeString::unBogus((uint64_t)&v61);
      if ((v62 & 0x8000u) == 0LL) {
        uint64_t v39 = (unsigned __int16)v62 >> 5;
      }
      else {
        uint64_t v39 = DWORD1(v62);
      }
      icu::UnicodeString::doReplace( (icu::UnicodeString *)&v61,  0LL,  v39,  (const icu::UnicodeString *)(a1 + 16),  v16,  v38);
      double v40 = sub_18091775C( a1,  (const icu::UnicodeString *)&v56,  0LL,  (uint64_t)&v61,  (uint64_t)&v52,  *(void *)(a1 + 88),  a5,  v31,  a8);
      if ((_DWORD)v53 || !*(void *)(a1 + 88))
      {
        if ((int)(v49 + v53 + v32) > v26)
        {
          int v26 = v49 + v53 + v32;
          double v28 = v40;
        }
      }

      else
      {
        int v43 = HIDWORD(v53) + v14 + v32;
        if (v43 > *(_DWORD *)(a3 + 12)) {
          *(_DWORD *)(a3 + 12) = v43;
        }
      }

      icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v52);
      icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)&v56);
      uint64_t v27 = v32;
    }

    else if (HIDWORD(v55) + (int)v14 > *(_DWORD *)(a3 + 12))
    {
      *(_DWORD *)(a3 + 12) = HIDWORD(v55) + v14;
    }

    int v42 = WORD4(v71[0]) >> 5;
    if (SWORD4(v71[0]) < 0) {
      int v42 = HIDWORD(v71[0]);
    }
  }

  while ((int)v32 < v42 && (_DWORD)v32 != (_DWORD)v27);
  *(_DWORD *)(a3 + 8) = v26;
  if (v26 >= 1)
  {
    *(_DWORD *)(a3 + 12) = 0;
    if (a4)
    {
      if (!*(void *)(a1 + 80)) {
        double v28 = 1.0 / v28;
      }
    }
  }

  icu::Formattable::setDouble(a6, v28);
  icu::UnicodeString::~UnicodeString(v44, (icu::UnicodeString *)&v61);
LABEL_70:
  icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)&v66);
  icu::UnicodeString::~UnicodeString(v45, (icu::UnicodeString *)v71);
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v54);
  return 1LL;
}

uint64_t sub_1809176AC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a3 + 8);
  int v5 = (__int16)v4;
  unsigned int v6 = v4 >> 5;
  if (v5 < 0) {
    unsigned int v6 = *(_DWORD *)(a3 + 12);
  }
  if (v6)
  {
    int v11 = 0;
    uint64_t result = (uint64_t)sub_180917A78(result, a2, a3, &v11);
    if (v11 <= 0 && (_DWORD)result != 0)
    {
      *(_DWORD *)(a4 + 8) += result;
      if ((_DWORD)result == 0x7FFFFFFF)
      {
        if ((*(_WORD *)(a2 + 8) & 1) != 0) {
          __int16 v10 = 2;
        }
        else {
          __int16 v10 = *(_WORD *)(a2 + 8) & 0x1F;
        }
        *(_WORD *)(a2 + 8) = v10;
      }

      else
      {
        return icu::UnicodeString::doReplace(a2, 0LL, result, 0LL, 0, 0LL);
      }
    }
  }

  return result;
}

double sub_18091775C( uint64_t a1, const icu::UnicodeString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, double a8, double a9)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  int v35 = 0;
  if (!sub_180917D44(a1, a4, &v35))
  {
    double v19 = 0.0;
    if (v35 > 0) {
      return v19;
    }
    int v33 = off_18970F400;
    unint64_t v34 = 0xFFFFFFFF00000000LL;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v41 = 0u;
    icu::Formattable::Formattable((icu::Formattable *)&v41);
    unsigned int v32 = 0;
    uint64_t v20 = sub_180917E24(a1, (uint64_t)a2, a4, a3, &v32);
    if ((v20 & 0x80000000) != 0)
    {
LABEL_23:
      *(_DWORD *)(a5 + 8) = 0;
      double v19 = 0.0;
      goto LABEL_28;
    }

    uint64_t v21 = v20;
    while (1)
    {
      uint64_t v40 = 0LL;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      __int128 v37 = 0u;
      unsigned int v36 = off_18971B688;
      LOWORD(v37) = 2;
      icu::UnicodeString::unBogus((uint64_t)&v36);
      if ((v37 & 0x8000u) == 0LL) {
        uint64_t v22 = (unsigned __int16)v37 >> 5;
      }
      else {
        uint64_t v22 = DWORD1(v37);
      }
      icu::UnicodeString::doReplace((icu::UnicodeString *)&v36, 0LL, v22, a2, 0, v21);
      int v23 = (unsigned __int16)v37 >> 5;
      if ((v37 & 0x8000u) != 0LL) {
        int v23 = DWORD1(v37);
      }
      if (v23 >= 1)
      {
        uint64_t v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 200LL))(*(void *)(a1 + 96));
        int v25 = (*(uint64_t (**)(uint64_t, void (***)(icu::ParsePosition *__hidden), void (***)(icu::ParsePosition *__hidden), uint64_t, uint64_t, __int128 *, double, double))(*(void *)a6 + 80LL))( a6,  &v36,  &v33,  v24,  a7,  &v41,  a8,  a9);
        int v26 = v34;
        if (v25) {
          BOOL v27 = (_DWORD)v34 == (_DWORD)v21;
        }
        else {
          BOOL v27 = 0;
        }
        if (v27)
        {
          uint64_t v30 = (void *)(v32 + v21);
          *(_DWORD *)(a5 + 8) = (_DWORD)v30;
          double v19 = *((double *)&v41 + 1);
          icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)&v36);
LABEL_28:
          icu::Formattable::~Formattable((icu::Formattable *)&v41);
          double v29 = &v33;
LABEL_29:
          icu::ParsePosition::~ParsePosition((icu::ParsePosition *)v29);
          return v19;
        }

        if (SHIDWORD(v34) > 0) {
          int v26 = HIDWORD(v34);
        }
        *(_DWORD *)(a5 + 12) = v26;
      }

      LODWORD(v34) = 0;
      uint64_t v21 = sub_180917E24(a1, (uint64_t)a2, a4, v32 + v21, &v32);
      icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v36);
      if ((v21 & 0x80000000) != 0) {
        goto LABEL_23;
      }
    }
  }

  if (a6)
  {
    unsigned int v36 = off_18970F400;
    *(void *)&__int128 v37 = 0xFFFFFFFF00000000LL;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v41 = 0u;
    icu::Formattable::Formattable((icu::Formattable *)&v41);
    uint64_t v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 200LL))(*(void *)(a1 + 96));
    if ((*(unsigned int (**)(uint64_t, const icu::UnicodeString *, void (***)(icu::ParsePosition *__hidden), uint64_t, uint64_t, __int128 *, double, double))(*(void *)a6 + 80LL))( a6,  a2,  &v36,  v18,  a7,  &v41,  a8,  a9)
      && (_DWORD)v37)
    {
      *(_DWORD *)(a5 + 8) = v37;
      double v19 = *((double *)&v41 + 1);
    }

    else
    {
      *(_DWORD *)(a5 + 12) = DWORD1(v37);
      double v19 = 0.0;
    }

    icu::Formattable::~Formattable((icu::Formattable *)&v41);
    double v29 = &v36;
    goto LABEL_29;
  }

  return a8;
}

icu::RuleBasedCollator *sub_180917A78(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a3 + 8);
  int v5 = (__int16)v4;
  unsigned int v6 = v4 >> 5;
  if (v5 < 0) {
    unsigned int v6 = *(_DWORD *)(a3 + 12);
  }
  if (!v6) {
    return 0LL;
  }
  int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 200LL))(*(void *)(a1 + 96));
  unsigned int v13 = *(unsigned __int16 *)(a3 + 8);
  if ((v13 & 0x8000u) == 0) {
    uint64_t v14 = (UErrorCode *)(v13 >> 5);
  }
  else {
    uint64_t v14 = (UErrorCode *)*(unsigned int *)(a3 + 12);
  }
  if (!v11)
  {
    if ((v13 & 1) != 0)
    {
      int v21 = *(_BYTE *)(a2 + 8) & 1;
      goto LABEL_51;
    }

    int v18 = v14 & ((int)v14 >> 31);
    if ((v14 & 0x80000000) != 0)
    {
      int32_t v19 = 0;
    }

    else
    {
      int32_t v19 = (_DWORD)v14 - v18;
      int32_t v20 = (int)v14;
      if ((int)v14 - v18 >= v14)
      {
LABEL_45:
        if ((*(_WORD *)(a2 + 8) & 1) != 0)
        {
          int v21 = 0;
        }

        else
        {
          if ((v13 & 2) != 0) {
            uint64_t v33 = a3 + 10;
          }
          else {
            uint64_t v33 = *(void *)(a3 + 24);
          }
          int v21 = icu::UnicodeString::doEqualsSubstring(a2, 0, (int32_t)v14, v33, v18, v20);
        }

uint64_t sub_180917D44(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 8);
  int v4 = (__int16)v3;
  unsigned int v5 = v3 >> 5;
  if (v4 < 0) {
    unsigned int v5 = *(_DWORD *)(a2 + 12);
  }
  if (!v5) {
    return 1LL;
  }
  Collator = (icu::RuleBasedCollator *)icu::RuleBasedNumberFormat::getCollator( *(icu::RuleBasedNumberFormat **)(a1 + 96),  v9,  v10);
  if (Collator
    && (CollationElementIterator = icu::RuleBasedCollator::createCollationElementIterator(Collator, (UChar **)a2)) != 0LL)
  {
    unsigned int v13 = CollationElementIterator;
    UErrorCode v18 = U_ZERO_ERROR;
    unsigned int v14 = icu::CollationElementIterator::next(CollationElementIterator, &v18);
    if (!HIWORD(v14))
    {
      do
        unsigned int v14 = icu::CollationElementIterator::next(v13, &v18);
      while (v14 < 0x10000);
    }

    BOOL v15 = v14 == -1;
    icu::CollationElementIterator::~CollationElementIterator(v13);
    icu::UMemory::operator delete(v16);
  }

  else
  {
    BOOL v15 = 0LL;
    *a3 = 7;
  }

  return v15;
}

uint64_t sub_180917E24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  if (*(void *)(a1 + 104))
  {
    memset(v61, 0, 112);
    icu::Formattable::Formattable((icu::Formattable *)v61);
    uint64_t v52 = 0LL;
    unsigned int v49 = off_189723AC8;
    int v51 = a4;
    int v50 = 0;
    icu::PluralFormat::parseType(*(void *)(a1 + 104), a2, a1, (icu::Formattable *)v61, (uint64_t)&v49);
    int v9 = v51;
    if (v51 < 0) {
      goto LABEL_63;
    }
    __int16 v10 = (icu::UnicodeString *)(a1 + 16);
    if (*(__int16 *)(a1 + 24) < 0)
    {
      int v12 = *(_DWORD *)(a1 + 28);
      int v11 = v12 & (v12 >> 31);
    }

    else
    {
      int v11 = 0;
      int v12 = *(unsigned __int16 *)(a1 + 24) >> 5;
    }

    int32_t v21 = icu::UnicodeString::indexOf(a1 + 16, (uint64_t)L"$(", 0, -1, v11, v12 - v11);
    int32_t v22 = v21;
    unsigned int v23 = *(unsigned __int16 *)(a1 + 24);
    if (v21 < 0)
    {
      int v25 = 0;
      if ((v23 & 0x8000) != 0) {
        int v24 = *(_DWORD *)(a1 + 28);
      }
      else {
        int v24 = v23 >> 5;
      }
    }

    else if ((v23 & 0x8000) != 0)
    {
      int v24 = *(_DWORD *)(a1 + 28);
      if (v24 >= v21) {
        int v25 = v21;
      }
      else {
        int v25 = *(_DWORD *)(a1 + 28);
      }
    }

    else
    {
      int v24 = v23 >> 5;
      else {
        int v25 = v24;
      }
    }

    uint64_t v32 = icu::UnicodeString::indexOf(a1 + 16, (uint64_t)")", 0, -1, v25, v24 - v25) + 2;
    int v34 = v52;
    __int128 v60 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v57 = 0u;
    icu::UnicodeString::tempSubString(v10, 0, v22, (icu::UnicodeString *)&v57);
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    icu::UnicodeString::tempSubString(v10, v32, 0x7FFFFFFF, (icu::UnicodeString *)&v53);
    if ((BYTE8(v57) & 1) != 0)
    {
      unint64_t v37 = *(unsigned __int16 *)(a2 + 8);
      if ((v37 & 1) == 0) {
        goto LABEL_61;
      }
    }

    else
    {
      if ((SWORD4(v57) & 0x8000u) == 0) {
        int32_t v35 = WORD4(v57) >> 5;
      }
      else {
        int32_t v35 = HIDWORD(v57);
      }
      if ((BYTE8(v57) & 2) != 0) {
        unint64_t v36 = (unint64_t)&v57 | 0xA;
      }
      else {
        unint64_t v36 = *((void *)&v58 + 1);
      }
      if (icu::UnicodeString::doCompare( a2,  v9 - v35,  v35,  v36,  v35 & (v35 >> 31),  v35 & ~(v35 >> 31))) {
        goto LABEL_61;
      }
    }

    if ((BYTE8(v53) & 1) == 0)
    {
      if ((SWORD4(v53) & 0x8000u) == 0) {
        int32_t v38 = WORD4(v53) >> 5;
      }
      else {
        int32_t v38 = HIDWORD(v53);
      }
      if ((BYTE8(v53) & 2) != 0) {
        unint64_t v39 = (unint64_t)&v53 | 0xA;
      }
      else {
        unint64_t v39 = *((void *)&v54 + 1);
      }
      if (icu::UnicodeString::doCompare( a2,  v34,  v38,  v39,  v38 & (v38 >> 31),  v38 & ~(v38 >> 31))) {
        goto LABEL_61;
      }
LABEL_67:
      int v40 = 0;
      int v42 = WORD4(v57) >> 5;
      if (SWORD4(v57) < 0) {
        int v42 = HIDWORD(v57);
      }
      int v43 = WORD4(v53) >> 5;
      if (SWORD4(v53) < 0) {
        int v43 = HIDWORD(v53);
      }
      unint64_t v37 = (v34 - v9 + v42 + v43);
      *a5 = v37;
      uint64_t v32 = (v9 - v42);
LABEL_62:
      icu::UnicodeString::~UnicodeString((void *)v37, (icu::UnicodeString *)&v53);
      icu::UnicodeString::~UnicodeString(v41, (icu::UnicodeString *)&v57);
      if (!v40)
      {
LABEL_64:
        icu::FieldPosition::~FieldPosition((icu::FieldPosition *)&v49);
        icu::Formattable::~Formattable((icu::Formattable *)v61);
        return v32;
      }

uint64_t sub_18091830C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v6 = a4;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t v21 = 0LL;
  __int128 v20 = 0u;
  unsigned int v17 = off_18971B688;
  LOWORD(v18) = 2;
  int v16 = 0;
  for (int i = -(int)a4; ; --i)
  {
    if (*(__int16 *)(a2 + 8) < 0)
    {
      unint64_t v11 = *(unsigned int *)(a2 + 12);
    }

    else
    {
      unint64_t v11 = *(unsigned __int16 *)(a2 + 8);
      LODWORD(v1sub_1808F7164((uint64_t)v14, 1) = v11 >> 5;
    }

    uint64_t v12 = (v11 + i);
    icu::UnicodeString::unBogus((uint64_t)&v17);
    uint64_t v13 = (v18 & 0x8000u) == 0LL ? (unsigned __int16)v18 >> 5 : DWORD1(v18);
    icu::UnicodeString::doReplace((icu::UnicodeString *)&v17, 0LL, v13, (const icu::UnicodeString *)a2, v6, v12);
    unsigned int v14 = sub_180917A78(a1, (uint64_t)&v17, a3, &v16);
    unint64_t v11 = v16;
    if (v16 > 0) {
      break;
    }
    if (v14) {
      goto LABEL_13;
    }
    uint64_t v6 = (v6 + 1);
  }

  unsigned int v14 = 0;
  uint64_t v6 = 0xFFFFFFFFLL;
LABEL_13:
  *a5 = v14;
  icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)&v17);
  return v6;
}

uint64_t sub_180918460(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2) {
    sub_180918D2C(v2);
  }
  uint64_t result = *(void *)(a1 + 88);
  if (result) {
    return sub_180918D2C(result);
  }
  return result;
}

void sub_1809184C0(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_180918504(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

void sub_18091854C(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_180918590(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

void sub_1809185D8(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_18091861C(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

void sub_180918664(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_1809186A8(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

void sub_1809186F0(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_180918734(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

void sub_18091877C(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_1809187C0(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

void sub_180918808(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
}

void sub_18091884C(icu::UObject *this)
{
  *(void *)this = off_189726D38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = 0LL;
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

uint64_t *sub_180918894(int a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, UErrorCode *a7)
{
  unsigned int v14 = *(unsigned __int16 *)(a6 + 8);
  if (*(__int16 *)(a6 + 8) < 0)
  {
    if (!*(_DWORD *)(a6 + 12)) {
      return 0LL;
    }
  }

  else if (v14 < 0x20)
  {
    return 0LL;
  }

  if ((v14 & 2) != 0) {
    int v16 = (unsigned __int16 *)(a6 + 10);
  }
  else {
    int v16 = *(unsigned __int16 **)(a6 + 24);
  }
  unsigned int v17 = (uint64_t *)*v16;
  if ((_DWORD)v17 != 62)
  {
    if ((_DWORD)v17 == 61)
    {
      uint64_t result = icu::UMemory::operator new(v17, (icu::UMemory *)0x20, (unint64_t)a2);
      if (result) {
        return (uint64_t *)sub_180919500((uint64_t)result, a1, a4, a6, a7);
      }
      return result;
    }

    if ((_DWORD)v17 == 60)
    {
      __int128 v18 = *a2;
      if ((unint64_t)*a2 + 4 < 3)
      {
        uint64_t result = icu::UMemory::operator new(v18, (icu::UMemory *)0x20, (unint64_t)a2);
        if (result)
        {
          uint64_t result = (uint64_t *)sub_180918AA0((uint64_t)result, a1, a4, (UChar **)a6, a7);
          __int128 v19 = off_189727068;
LABEL_26:
          *uint64_t result = (uint64_t)v19;
          return result;
        }

        return result;
      }

      if (v18 != (uint64_t *)-1LL)
      {
        uint64_t v21 = (uint64_t *)*(unsigned __int8 *)(a4 + 160);
        if (*(_BYTE *)(a4 + 160))
        {
          uint64_t result = icu::UMemory::operator new(v21, (icu::UMemory *)0x38, (unint64_t)a2);
          if (result) {
            return (uint64_t *)sub_18091A8E0((uint64_t)result, a1, *(void *)(a5 + 384), a6, a7, (double)(uint64_t)*a2);
          }
        }

        else
        {
          uint64_t result = icu::UMemory::operator new(v21, (icu::UMemory *)0x28, (unint64_t)a2);
          if (result) {
            return (uint64_t *)sub_18091AA6C((uint64_t)result, a1, (uint64_t)a2, a4, (UChar **)a6, a7);
          }
        }

        return result;
      }
    }

uint64_t sub_180918AA0(uint64_t a1, int a2, uint64_t a3, UChar **a4, UErrorCode *a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  *(void *)a1 = off_189726D38;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0LL;
  int v9 = (void *)(a1 + 16);
  *(void *)(a1 + 24) = 0LL;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v28, a4);
  unsigned int v10 = *((unsigned __int16 *)a4 + 4);
  if ((__int16)a4[1] < 0)
  {
    int v12 = *((_DWORD *)a4 + 3);
    if (v12 <= 1) {
      goto LABEL_18;
    }
    unint64_t v11 = (UChar *)a4 + 5;
    if ((v10 & 2) == 0) {
      unint64_t v11 = a4[3];
    }
  }

  else
  {
    if (v10 < 0x40) {
      goto LABEL_16;
    }
    unint64_t v11 = a4[3];
    if ((v10 & 2) != 0) {
      unint64_t v11 = (UChar *)a4 + 5;
    }
    int v12 = v10 >> 5;
  }

  int v13 = *v11;
  int v14 = v12 - 1;
  unsigned int v15 = (UChar *)a4 + 5;
  if ((v10 & 2) == 0) {
    unsigned int v15 = a4[3];
  }
  if (v13 != v15[v14])
  {
    if ((v10 & 0x8000) == 0)
    {
LABEL_16:
      if (!(v10 >> 5)) {
        goto LABEL_19;
      }
LABEL_38:
      uint64_t v18 = 9LL;
LABEL_39:
      *a5 = v18;
      goto LABEL_40;
    }

uint64_t sub_180918D2C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 336LL))(result);
  }
  return result;
}

void *sub_180918D44()
{
  return &unk_18C5356A4;
}

uint64_t sub_180918D50(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    __cxa_bad_typeid();
  }
  uint64_t result = sub_1807F874C(*(void *)(*(void *)a1 - 8LL), *(void *)(*(void *)a2 - 8LL));
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || (*(void *)(a1 + 16) != 0LL) == (*(void *)(a2 + 16) == 0LL))
    {
      return 0LL;
    }

    else
    {
      uint64_t v5 = *(void *)(a1 + 24);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v5) {
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 24LL))(v5, v6);
      }
      else {
        return v6 == 0;
      }
    }
  }

  return result;
}

void *sub_180918DF0(void *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if ((*(_WORD *)(a2 + 8) & 1) != 0) {
    __int16 v4 = 2;
  }
  else {
    __int16 v4 = *(_WORD *)(a2 + 8) & 0x1F;
  }
  *(_WORD *)(a2 + 8) = v4;
  LOWORD(v1sub_1808F7164((uint64_t)v14, 1) = (*(uint64_t (**)(void *))(*a1 + 104LL))(a1);
  icu::UnicodeString::doAppend(a2, (uint64_t)&v11, 0, 1LL);
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  uint64_t v15 = 0LL;
  __int128 v14 = 0u;
  unint64_t v11 = (UChar *)off_18971B688;
  LOWORD(v12) = 2;
  uint64_t v5 = a1[2];
  if (v5)
  {
    icu::UnicodeString::copyFrom(&v11, (UChar **)(v5 + 8), 0);
  }

  else
  {
    uint64_t v6 = a1[3];
    if (v6) {
      (*(void (**)(uint64_t, UChar **))(*(void *)v6 + 552LL))(v6, &v11);
    }
  }

  if ((v12 & 0x8000u) == 0LL) {
    uint64_t v7 = (unsigned __int16)v12 >> 5;
  }
  else {
    uint64_t v7 = DWORD1(v12);
  }
  icu::UnicodeString::doAppend(a2, (const icu::UnicodeString *)&v11, 0, v7);
  __int16 v10 = (*(uint64_t (**)(void *))(*a1 + 104LL))(a1);
  icu::UnicodeString::doAppend(a2, (uint64_t)&v10, 0, 1LL);
  return icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v11);
}

void *sub_180918F38(void *result, uint64_t a2, icu::UnicodeString *a3, int a4, int a5, UErrorCode *a6)
{
  int v9 = result;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  __int16 v10 = (_DWORD *)result[2];
  if (v10)
  {
    unint64_t v12 = (*(uint64_t (**)(void *))(*result + 64LL))(result);
    return sub_1809144A8(v10, v12, a3, (*((_DWORD *)v9 + 2) + a4), a5, a6);
  }

  else if (result[3])
  {
    if (a2 > 0x1FFFFFFFFFFFFFLL)
    {
      uint64_t v15 = (*(uint64_t (**)(void *))(*result + 64LL))(result);
      __int128 v20 = 0u;
      uint64_t v23 = 0LL;
      __int128 v22 = 0u;
      __int128 v21 = 0u;
      __int128 v19 = off_18971B688;
      LOWORD(v20) = 2;
      __int128 v14 = (icu::Format *)v9[3];
      icu::Formattable::Formattable((icu::Formattable *)v18, v15);
    }

    else
    {
      double v13 = (*(double (**)(void *, double))(*result + 72LL))(result, (double)a2);
      __int128 v20 = 0u;
      uint64_t v23 = 0LL;
      __int128 v22 = 0u;
      __int128 v21 = 0u;
      __int128 v19 = off_18971B688;
      LOWORD(v20) = 2;
      __int128 v14 = (icu::Format *)v9[3];
      icu::Formattable::Formattable((icu::Formattable *)v18, v13);
    }

    icu::Format::format(v14, (const icu::Formattable *)v18, (icu::UnicodeString *)&v19, a6);
    icu::Formattable::~Formattable((icu::Formattable *)v18);
    if ((v20 & 0x8000u) == 0LL) {
      uint64_t v16 = (unsigned __int16)v20 >> 5;
    }
    else {
      uint64_t v16 = DWORD1(v20);
    }
    icu::UnicodeString::doReplace( a3,  (*((_DWORD *)v9 + 2) + a4),  0LL,  (const icu::UnicodeString *)&v19,  0,  v16);
    return icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v19);
  }

  return result;
}

icu::NumberFormat *sub_180919150(uint64_t a1, icu::UnicodeString *a2, int a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  double v10 = (*(double (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  if (uprv_isInfinite(v10))
  {
    uint64_t v11 = *(void *)(a1 + 16);
    double Infinity = uprv_getInfinity();
    uint64_t v13 = sub_180914688(v11, Infinity);
    return (icu::NumberFormat *)sub_180916D94(v13, a2, (*(_DWORD *)(a1 + 8) + a3), a4, a5, v10);
  }

  double v15 = uprv_floor(v10);
  uint64_t v16 = *(_DWORD **)(a1 + 16);
  if (v10 == v15)
  {
    if (v16)
    {
      unint64_t v17 = sub_180914940(v10);
      return (icu::NumberFormat *)sub_1809144A8(v16, v17, a2, (*(_DWORD *)(a1 + 8) + a3), a4, a5);
    }
  }

  else if (v16)
  {
    return (icu::NumberFormat *)sub_180914608( *(_DWORD **)(a1 + 16),  a2,  (*(_DWORD *)(a1 + 8) + a3),  a4,  a5,  v10);
  }

  uint64_t result = *(icu::NumberFormat **)(a1 + 24);
  if (result)
  {
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    uint64_t v24 = 0LL;
    __int128 v23 = 0u;
    __int128 v20 = off_18971B688;
    LOWORD(v2sub_1808F7164((uint64_t)v14, 1) = 2;
    icu::NumberFormat::format(result, v10, (icu::UnicodeString *)&v20);
    if ((v21 & 0x8000u) == 0LL) {
      uint64_t v18 = (unsigned __int16)v21 >> 5;
    }
    else {
      uint64_t v18 = DWORD1(v21);
    }
    icu::UnicodeString::doReplace( a2,  (*(_DWORD *)(a1 + 8) + a3),  0LL,  (const icu::UnicodeString *)&v20,  0,  v18);
    return (icu::NumberFormat *)icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)&v20);
  }

  return result;
}

uint64_t sub_180919378( void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, icu::Formattable *a6, double a7, double a8)
{
  uint64_t v16 = a1[2];
  if (v16)
  {
    sub_1809149A0(v16, a2, a3, a5, a6, 0, v15);
    if (a4)
    {
      if (!*(_BYTE *)(a1[2] + 160LL) && *(_DWORD *)(a3 + 8) == 0)
      {
        int v26 = 0;
        uint64_t Instance = icu::NumberFormat::createInstance((icu::NumberFormat *)&v26, v17);
        __int128 v20 = Instance;
        if (v26 <= 0)
        {
          (*(void (**)(icu::DecimalFormat *, uint64_t, icu::Formattable *, uint64_t))(*(void *)Instance
                                                                                             + 160LL))( Instance,  a2,  a6,  a3);
        }

        else if (!Instance)
        {
          goto LABEL_15;
        }

        (*(void (**)(icu::DecimalFormat *))(*(void *)v20 + 8LL))(v20);
      }
    }
  }

  else
  {
    uint64_t v21 = a1[3];
    if (v21) {
      (*(void (**)(uint64_t, uint64_t, icu::Formattable *, uint64_t))(*(void *)v21 + 160LL))(v21, a2, a6, a3);
    }
  }

uint64_t sub_1809194D8()
{
  return 0LL;
}

BOOL sub_1809194E0(uint64_t a1)
{
  return !*(void *)(a1 + 16) && *(void *)(a1 + 24) != 0LL;
}

uint64_t sub_180919500(uint64_t a1, int a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  *(void *)sub_180918AA0(a1, a2, a3, (UChar **)a4, a5) = off_189726DC8;
  unsigned int v8 = *(unsigned __int16 *)(a4 + 8);
  int v9 = (__int16)v8;
  int32_t v10 = v8 >> 5;
  if (v9 >= 0) {
    int32_t v11 = v10;
  }
  else {
    int32_t v11 = *(_DWORD *)(a4 + 12);
  }
  return a1;
}

void *sub_180919594()
{
  return &unk_18C5356A5;
}

void *sub_1809195A0()
{
  return &unk_18C5356A6;
}

uint64_t sub_1809195AC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_180918D50(a1, a2);
  if ((_DWORD)result) {
    return *(void *)(a1 + 32) == *(void *)(a2 + 32);
  }
  return result;
}

uint64_t sub_1809195E4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, UChar **a6, UErrorCode *a7)
{
  *(void *)sub_180918AA0(a1, a2, a5, a6, a7) = off_189726E58;
  uint64_t v12 = sub_180916A5C(a3);
  *(void *)(a1 + 32) = v12;
  *(void *)(a1 + 40) = 0LL;
  if (!v12) {
    *a7 = U_PARSE_ERROR;
  }
  unsigned int v13 = *((unsigned __int16 *)a6 + 4);
  int v14 = (__int16)v13;
  int32_t v15 = v13 >> 5;
  if (v14 >= 0) {
    int32_t v16 = v15;
  }
  else {
    int32_t v16 = *((_DWORD *)a6 + 3);
  }
  return a1;
}

void *sub_1809196A8()
{
  return &unk_18C5356A7;
}

uint64_t sub_1809196B4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_180918D50(a1, a2);
  if ((_DWORD)result) {
    return *(void *)(a1 + 32) == *(void *)(a2 + 32) && *(void *)(a1 + 40) == *(void *)(a2 + 40);
  }
  return result;
}

void *sub_180919704(uint64_t a1, uint64_t a2, icu::UnicodeString *a3, int a4, uint64_t a5, UErrorCode *a6)
{
  if (!*(void *)(a1 + 40)) {
    return sub_180918F38((void *)a1, a2, a3, a4, a5, a6);
  }
  unint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64LL))(a1);
  return sub_180916A6C(*(void *)(a1 + 40), v11, a3, (*(_DWORD *)(a1 + 8) + a4), a5, a6);
}

icu::NumberFormat *sub_18091979C(uint64_t a1, icu::UnicodeString *a2, int a3, uint64_t a4, UErrorCode *a5)
{
  if (!*(void *)(a1 + 40)) {
    return sub_180919150(a1, a2, a3, a4, a5);
  }
  double v10 = (*(double (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  return (icu::NumberFormat *)sub_180916D94( *(void *)(a1 + 40),  a2,  (*(_DWORD *)(a1 + 8) + a3),  a4,  a5,  v10);
}

uint64_t sub_180919830( void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, icu::Formattable *a6, double a7, double a8)
{
  uint64_t v12 = a1[5];
  if (!v12) {
    return sub_180919378(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  sub_180917164(v12, a2, a3, 0, a5, a6, 1, a8);
  if (*(_DWORD *)(a3 + 8))
  {
    UErrorCode v16 = U_ZERO_ERROR;
    double Double = icu::Formattable::getDouble(a6, &v16);
    double v14 = (*(double (**)(void *, double, double))(*a1 + 88LL))(a1, Double, a7);
    icu::Formattable::setDouble(a6, v14);
  }

  return 1LL;
}

void *sub_1809198F0(void *a1, uint64_t a2)
{
  if (!a1[5]) {
    return sub_180918DF0(a1, a2);
  }
  if ((*(_WORD *)(a2 + 8) & 1) != 0) {
    __int16 v4 = 2;
  }
  else {
    __int16 v4 = *(_WORD *)(a2 + 8) & 0x1F;
  }
  *(_WORD *)(a2 + 8) = v4;
  __int16 v6 = (*(uint64_t (**)(void *))(*a1 + 104LL))(a1);
  icu::UnicodeString::doAppend(a2, (uint64_t)&v6, 0, 1LL);
  __int16 v7 = (*(uint64_t (**)(void *))(*a1 + 104LL))(a1);
  icu::UnicodeString::doAppend(a2, (uint64_t)&v7, 0, 1LL);
  __int16 v8 = (*(uint64_t (**)(void *))(*a1 + 104LL))(a1);
  return (void *)icu::UnicodeString::doAppend(a2, (uint64_t)&v8, 0, 1LL);
}

void *sub_1809199C8()
{
  return &unk_18C5356A8;
}

uint64_t sub_1809199D4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v8 = sub_180918AA0(a1, a2, a3, (UChar **)a4, a5);
  *(void *)uint64_t v8 = off_189726EE8;
  *(_WORD *)(v8 + 32) = 256;
  unsigned int v9 = *(unsigned __int16 *)(a4 + 8);
  int v10 = (__int16)v9;
  int32_t v11 = v9 >> 5;
  if (v10 >= 0) {
    int32_t v12 = v11;
  }
  else {
    int32_t v12 = *(_DWORD *)(a4 + 12);
  }
  if (icu::UnicodeString::doCompare(a4, 0, v12, (uint64_t)L">>", 0, 2)
    && ((unsigned int v13 = *(unsigned __int16 *)(a4 + 8), v14 = (__int16)v13, v15 = v13 >> 5, v14 >= 0)
      ? (int32_t v16 = v15)
      : (int32_t v16 = *(_DWORD *)(a4 + 12)),
        icu::UnicodeString::doCompare(a4, 0, v16, (uint64_t)L">>>", 0, 3) && *(void *)(a1 + 16) != a3))
  {
    *(_BYTE *)(*(void *)(a1 + 16) + 160LL) = 1;
  }

  else
  {
    *(_BYTE *)(a1 + 32) = 1;
    unsigned int v17 = *(unsigned __int16 *)(a4 + 8);
    int v18 = (__int16)v17;
    int32_t v19 = v17 >> 5;
    if (v18 >= 0) {
      int32_t v20 = v19;
    }
    else {
      int32_t v20 = *(_DWORD *)(a4 + 12);
    }
  }

  return a1;
}

void sub_180919B3C(uint64_t a1, icu::UnicodeString *a2, int a3, uint64_t a4, int *a5, double a6)
{
  int v7 = a4;
  if (*(_BYTE *)(a1 + 32))
  {
    uint64_t v19 = 0LL;
    memset(v18, 0, sizeof(v18));
    icu::number::impl::DecimalQuantity::DecimalQuantity((icu::number::impl::DecimalQuantity *)v18);
    icu::number::impl::DecimalQuantity::setToDouble((void **)v18, a6);
    icu::number::impl::DecimalQuantity::roundToMagnitude((uint64_t)v18, -20, 4u, a5);
    LowerDisplayint Magnitude = icu::number::impl::DecimalQuantity::getLowerDisplayMagnitude((icu::number::impl::DecimalQuantity *)v18);
    if (LowerDisplayMagnitude < 0)
    {
      int v13 = LowerDisplayMagnitude;
      char v14 = 1;
      do
      {
        if ((v14 & 1) == 0)
        {
          if (*(_BYTE *)(a1 + 33))
          {
            uint64_t v15 = (*(_DWORD *)(a1 + 8) + a3);
            __int16 v20 = 32;
            icu::UnicodeString::doReplace((uint64_t)a2, v15, 0LL, (uint64_t)&v20, 0, 1LL);
          }
        }

        int Digit = icu::number::impl::DecimalQuantity::getDigit((icu::number::impl::DecimalQuantity *)v18, v13);
        sub_1809144A8(*(_DWORD **)(a1 + 16), Digit, a2, (*(_DWORD *)(a1 + 8) + a3), v7, (UErrorCode *)a5);
        char v14 = 0;
      }

      while (!__CFADD__(v13++, 1));
    }

    else
    {
      sub_1809144A8(*(_DWORD **)(a1 + 16), 0LL, a2, (*(_DWORD *)(a1 + 8) + a3), v7, (UErrorCode *)a5);
    }

    icu::number::impl::DecimalQuantity::~DecimalQuantity((void **)v18);
  }

  else
  {
    sub_180919150(a1, a2, a3, a4, (UErrorCode *)a5);
  }

uint64_t sub_180919CB8( uint64_t a1, UChar **a2, uint64_t a3, int a4, uint64_t a5, icu::Formattable *a6, double a7)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(a1 + 32)) {
    return sub_180919378((void *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, 0.0);
  }
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v33, a2);
  __int128 v30 = off_18970F400;
  unint64_t v31 = 0xFFFFFFFF00000001LL;
  uint64_t v29 = 0LL;
  memset(v28, 0, sizeof(v28));
  icu::number::impl::DecimalQuantity::DecimalQuantity((icu::number::impl::DecimalQuantity *)v28);
  int v13 = WORD4(v33) >> 5;
  if (SWORD4(v33) < 0) {
    int v13 = HIDWORD(v33);
  }
  if (v13 < 1)
  {
    int v15 = 0;
    goto LABEL_38;
  }

  char v14 = 0LL;
  int v15 = 0;
  do
  {
    LODWORD(v3sub_1808F7164((uint64_t)v14, 1) = 0;
    memset(v32, 0, sizeof(v32));
    icu::Formattable::Formattable((icu::Formattable *)v32);
    sub_1809149A0(*(void *)(a1 + 16), (uint64_t)&v33, (uint64_t)&v30, a5, (icu::Formattable *)v32, 0, 10.0);
    UErrorCode v27 = U_ZERO_ERROR;
    char Long = icu::Formattable::getLong((icu::Formattable *)v32, &v27);
    if (!a4) {
      goto LABEL_10;
    }
    if (!(_DWORD)v31)
    {
      if (v14)
      {
LABEL_9:
        (*(void (**)(icu::DecimalFormat *, __int128 *, _OWORD *, void (***)(icu::ParsePosition *__hidden)))(*(void *)v14 + 160LL))( v14,  &v33,  v32,  &v30);
        char Long = icu::Formattable::getLong((icu::Formattable *)v32, &v27);
        goto LABEL_10;
      }

      UErrorCode v27 = U_ZERO_ERROR;
      uint64_t Instance = icu::NumberFormat::createInstance((icu::NumberFormat *)&v27, v16);
      char v14 = Instance;
      if (v27 < U_ILLEGAL_ARGUMENT_ERROR)
      {
        if (Instance) {
          goto LABEL_9;
        }
      }

      else if (Instance)
      {
        (*(void (**)(icu::DecimalFormat *))(*(void *)Instance + 8LL))(Instance);
        char v14 = 0LL;
      }

uint64_t sub_18091A040(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_180918D50(a1, a2);
  if ((_DWORD)result) {
    return *(unsigned __int8 *)(a2 + 32) == *(unsigned __int8 *)(a1 + 32);
  }
  return result;
}

void *sub_18091A078()
{
  return &unk_18C5356A9;
}

void *sub_18091A084()
{
  return &unk_18C5356AA;
}

_DWORD *sub_18091A090(uint64_t a1, uint64_t a2, unsigned int a3, int a4, UErrorCode *a5)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  double v10 = (*(double (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  uint64_t v11 = sub_180914940(v10);
  int64_t v12 = v11;
  int v13 = *(_DWORD **)(a1 + 16);
  if (*(_BYTE *)(a1 + 48)) {
    BOOL v14 = v13 == 0LL;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    unsigned int v15 = *(unsigned __int16 *)(a2 + 8);
    int v16 = (__int16)v15;
    unsigned int v17 = v15 >> 5;
    unsigned int v18 = *(_DWORD *)(a2 + 12);
    if (v16 >= 0) {
      unsigned int v19 = v17;
    }
    else {
      unsigned int v19 = *(_DWORD *)(a2 + 12);
    }
    uint64_t v20 = 10 * v11;
    if (*(double *)(a1 + 32) > (double)(10 * v11))
    {
      do
      {
        uint64_t v21 = *(_DWORD *)(a1 + 8) + a3;
        v28[0] = 32;
        icu::UnicodeString::doReplace(a2, v21, 0LL, (uint64_t)v28, 0, 1LL);
        sub_1809144A8(v13, 0LL, (icu::UnicodeString *)a2, *(_DWORD *)(a1 + 8) + a3, a4, a5);
        v20 *= 10LL;
      }

      while (*(double *)(a1 + 32) > (double)v20);
      int v16 = *(unsigned __int16 *)(a2 + 8);
      unsigned int v18 = *(_DWORD *)(a2 + 12);
      unsigned int v17 = v16 >> 5;
    }

    if ((v16 & 0x8000u) == 0) {
      unsigned int v22 = v17;
    }
    else {
      unsigned int v22 = v18;
    }
    a3 = a3 - v19 + v22;
  }

  if (v13) {
    return sub_180914608(v13, (icu::UnicodeString *)a2, *(_DWORD *)(a1 + 8) + a3, a4, a5, v10);
  }
  __int128 v30 = 0u;
  uint64_t v33 = 0LL;
  __int128 v32 = 0u;
  __int128 v31 = 0u;
  uint64_t v29 = off_18971B688;
  LOWORD(v30) = 2;
  double v25 = *(icu::Format **)(a1 + 24);
  icu::Formattable::Formattable((icu::Formattable *)v28, v10);
  icu::Format::format(v25, (const icu::Formattable *)v28, (icu::UnicodeString *)&v29, a5);
  icu::Formattable::~Formattable((icu::Formattable *)v28);
  if ((v30 & 0x8000u) == 0LL) {
    uint64_t v26 = (unsigned __int16)v30 >> 5;
  }
  else {
    uint64_t v26 = DWORD1(v30);
  }
  icu::UnicodeString::doReplace( (icu::UnicodeString *)a2,  *(_DWORD *)(a1 + 8) + a3,  0LL,  (const icu::UnicodeString *)&v29,  0,  v26);
  return icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)&v29);
}

uint64_t sub_18091A2E8( uint64_t a1, UChar **a2, uint64_t a3, double a4, double a5, uint64_t a6, uint64_t a7, icu::Formattable *a8)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  UErrorCode v31 = U_ZERO_ERROR;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)&v33, a2);
  if (*(_BYTE *)(a1 + 48))
  {
    uint64_t v29 = off_18970F400;
    unint64_t v30 = 0xFFFFFFFF00000001LL;
    memset(v32, 0, sizeof(v32));
    icu::Formattable::Formattable((icu::Formattable *)v32);
    int v15 = WORD4(v33) >> 5;
    if (SWORD4(v33) < 0) {
      int v15 = HIDWORD(v33);
    }
    if (v15 < 1)
    {
      int v16 = 0;
    }

    else
    {
      int v16 = 0;
      do
      {
        LODWORD(v30) = 0;
        sub_1809149A0(*(void *)(a1 + 16), (uint64_t)&v33, (uint64_t)&v29, a7, (icu::Formattable *)v32, 0, 1.0);
        uint64_t v17 = v30;
        if (!(_DWORD)v30) {
          break;
        }
        *(_DWORD *)(a3 + 8) += v30;
        if ((_DWORD)v17 == 0x7FFFFFFF)
        {
          __int16 v18 = (BYTE8(v33) & 1) != 0 ? 2 : BYTE8(v33) & 0x1F;
          WORD4(v33) = v18;
        }

        else
        {
          icu::UnicodeString::doReplace((uint64_t)&v33, 0LL, v17, 0LL, 0, 0LL);
        }

        ++v16;
        while (1)
        {
          if (SWORD4(v33) < 0)
          {
          }

          else if (WORD4(v33) < 0x20u)
          {
            break;
          }

          unsigned int v19 = (_WORD *)*((void *)&v34 + 1);
          if ((BYTE8(v33) & 2) != 0) {
            unsigned int v19 = (_WORD *)((unint64_t)&v33 | 0xA);
          }
          if (*v19 != 32) {
            break;
          }
          icu::UnicodeString::doReplace((uint64_t)&v33, 0LL, 1LL, 0LL, 0, 0LL);
          ++*(_DWORD *)(a3 + 8);
        }

        int v20 = WORD4(v33) >> 5;
        if (SWORD4(v33) < 0) {
          int v20 = HIDWORD(v33);
        }
      }

      while (v20 >= 1 && (_DWORD)v30 != 0);
    }

    icu::UnicodeString::operator=((UChar **)&v33, a2);
    uint64_t v22 = *(unsigned int *)(a3 + 8);
    if ((_DWORD)v22 == 0x7FFFFFFF)
    {
      if ((BYTE8(v33) & 1) != 0) {
        __int16 v23 = 2;
      }
      else {
        __int16 v23 = BYTE8(v33) & 0x1F;
      }
      WORD4(v33) = v23;
    }

    else
    {
      icu::UnicodeString::doReplace((uint64_t)&v33, 0LL, v22, 0LL, 0, 0LL);
    }

    *(_DWORD *)(a3 + 8) = 0;
    icu::Formattable::~Formattable((icu::Formattable *)v32);
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v29);
    if (*(_BYTE *)(a1 + 48)) {
      a4 = 1.0;
    }
  }

  else
  {
    int v16 = 0;
  }

  sub_180919378((void *)a1, (uint64_t)&v33, a3, 0, a7, a8, a4, a5);
  double v24 = (void *)*(unsigned __int8 *)(a1 + 48);
  if (*(_BYTE *)(a1 + 48))
  {
    int Long = icu::Formattable::getLong(a8, &v31);
    uint64_t v26 = 1LL;
    if (Long >= 1)
    {
      do
        v26 *= 10LL;
      while (v26 <= Long);
    }

    if (v16 >= 1)
    {
      unsigned int v27 = v16 + 1;
      do
      {
        v26 *= 10LL;
        --v27;
      }

      while (v27 > 1);
    }

    icu::Formattable::setDouble(a8, (double)Long / (double)v26);
  }

  icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)&v33);
  return 1LL;
}

uint64_t sub_18091A628(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_180918D50(a1, a2);
  if ((_DWORD)result) {
    return *(double *)(a1 + 32) == *(double *)(a2 + 32);
  }
  return result;
}

void *sub_18091A660()
{
  return &unk_18C5356AB;
}

uint64_t sub_18091A66C(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_18091A680()
{
  return 61LL;
}

uint64_t sub_18091A688(uint64_t a1, uint64_t a2, unsigned __int16 a3, _DWORD *a4)
{
  uint64_t result = sub_180914FB8(a2, a3);
  *(void *)(a1 + 32) = result;
  if (!result) {
    *a4 = 9;
  }
  return result;
}

uint64_t sub_18091A6C8(uint64_t a1, uint64_t a2)
{
  return a2 / *(void *)(a1 + 32);
}

double sub_18091A6D4(void *a1, double a2)
{
  if (!a1[2]
    && (uint64_t v5 = (icu::NumberFormat *)a1[3]) != 0LL
    && icu::NumberFormat::getMaximumFractionDigits(v5))
  {
    return a2 / (double)(uint64_t)a1[4];
  }

  else
  {
    return uprv_floor(a2 / (double)(uint64_t)a1[4]);
  }

double sub_18091A73C(uint64_t a1, double a2)
{
  return (double)*(uint64_t *)(a1 + 32) * a2;
}

double sub_18091A74C(uint64_t a1)
{
  return (double)*(uint64_t *)(a1 + 32);
}

uint64_t sub_18091A758()
{
  return 60LL;
}

uint64_t sub_18091A760(uint64_t a1, uint64_t a2, unsigned __int16 a3, _DWORD *a4)
{
  uint64_t result = sub_180914FB8(a2, a3);
  *(void *)(a1 + 32) = result;
  if (!result) {
    *a4 = 9;
  }
  return result;
}

uint64_t sub_18091A7A0(uint64_t a1, uint64_t a2)
{
  return a2 % *(void *)(a1 + 32);
}

double sub_18091A7B0(uint64_t a1, double a2)
{
  return uprv_fmod(a2, (double)*(uint64_t *)(a1 + 32));
}

double sub_18091A7BC(uint64_t a1, double a2, double a3)
{
  return a3 - uprv_fmod(a3, (double)*(uint64_t *)(a1 + 32)) + a2;
}

double sub_18091A7F4(uint64_t a1)
{
  return (double)*(uint64_t *)(a1 + 32);
}

uint64_t sub_18091A800()
{
  return 62LL;
}

uint64_t sub_18091A808()
{
  return 1LL;
}

uint64_t sub_18091A810(uint64_t a1, uint64_t a2)
{
  return a2;
}

double sub_18091A81C(double a1, double a2)
{
  return a1 + a2;
}

double sub_18091A824()
{
  return 1.79769313e308;
}

uint64_t sub_18091A830()
{
  return 60LL;
}

uint64_t sub_18091A83C()
{
  return 0LL;
}

double sub_18091A844(double a1)
{
  return a1 - uprv_floor(a1);
}

double sub_18091A868(double a1, double a2)
{
  return a1 + a2;
}

double sub_18091A870()
{
  return 0.0;
}

uint64_t sub_18091A878()
{
  return 62LL;
}

uint64_t sub_18091A880(uint64_t a1, uint64_t a2)
{
  if (a2 >= 0) {
    return a2;
  }
  else {
    return -a2;
  }
}

double sub_18091A890(double a1)
{
  return -a1;
}

double sub_18091A898()
{
  return 1.79769313e308;
}

uint64_t sub_18091A8A4()
{
  return 62LL;
}

uint64_t sub_18091A8B0(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 40) * a2;
}

double sub_18091A8BC(uint64_t a1, double a2)
{
  return uprv_round(*(double *)(a1 + 32) * a2);
}

double sub_18091A8C8(double a1, double a2)
{
  return a1 / a2;
}

double sub_18091A8D0(uint64_t a1)
{
  return *(double *)(a1 + 32);
}

uint64_t sub_18091A8D8()
{
  return 60LL;
}

uint64_t sub_18091A8E0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, UErrorCode *a5, double a6)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  unsigned int v12 = *(unsigned __int16 *)(a4 + 8);
  int v13 = (__int16)v12;
  unsigned int v14 = v12 >> 5;
  if (v13 < 0) {
    unsigned int v14 = *(_DWORD *)(a4 + 12);
  }
  if (icu::UnicodeString::doEqualsSubstring(a4, v14 - 2, 2, (uint64_t)"<", 0, 2))
  {
    memset(v23, 0, sizeof(v23));
    unsigned int v15 = *(unsigned __int16 *)(a4 + 8);
    int v16 = (__int16)v15;
    unsigned int v17 = v15 >> 5;
    if (v16 < 0) {
      unsigned int v17 = *(_DWORD *)(a4 + 12);
    }
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v23, (const icu::UnicodeString *)a4, 0, v17 - 1);
  }

  else
  {
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v23, (UChar **)a4);
  }

  sub_180918AA0(a1, a2, a3, (UChar **)v23, a5);
  icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v23);
  *(void *)a1 = off_1897271D0;
  *(double *)(a1 + 32) = a6;
  *(void *)(a1 + 40) = sub_180914940(a6);
  unsigned int v19 = *(unsigned __int16 *)(a4 + 8);
  int v20 = (__int16)v19;
  unsigned int v21 = v19 >> 5;
  if (v20 < 0) {
    unsigned int v21 = *(_DWORD *)(a4 + 12);
  }
  *(_BYTE *)(a1 + 48) = icu::UnicodeString::doEqualsSubstring(a4, v21 - 2, 2, (uint64_t)"<", 0, 2);
  return a1;
}

uint64_t sub_18091AA6C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, UChar **a5, UErrorCode *a6)
{
  *(void *)sub_180918AA0(a1, a2, a4, a5, a6) = off_189726FA8;
  uint64_t v9 = sub_180916A5C(a3);
  *(void *)(a1 + 32) = v9;
  if (!v9) {
    *a6 = U_PARSE_ERROR;
  }
  return a1;
}

void *icu::NormalizationTransliterator::getStaticClassID(icu::NormalizationTransliterator *this)
{
  return &unk_18C5356AC;
}

void *sub_18091AADC()
{
  return &unk_18C5356AC;
}

void *sub_18091AAE8()
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  int v43 = L"Any-NFC";
  unint64_t v0 = icu::UnicodeString::UnicodeString(v45, 1LL, &v43);
  icu::Transliterator::_registerFactory(v0, (uint64_t)sub_18091AE80, (uint64_t)"nfc");
  uint64_t v2 = icu::UnicodeString::~UnicodeString(v1, (icu::UnicodeString *)v45);
  v29[6] = v43;
  int v42 = L"Any-NFKC";
  unint64_t v3 = icu::UnicodeString::UnicodeString(v2, 1LL, &v42);
  icu::Transliterator::_registerFactory(v3, (uint64_t)sub_18091AE80, (uint64_t)"nfkc");
  uint64_t v5 = icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v45);
  _OWORD v29[5] = v42;
  __int128 v41 = "A";
  unint64_t v6 = icu::UnicodeString::UnicodeString(v5, 1LL, &v41);
  icu::Transliterator::_registerFactory(v6, (uint64_t)sub_18091AE80, (uint64_t)"nfc");
  uint64_t v8 = icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v45);
  _OWORD v29[4] = v41;
  int v40 = "A";
  unint64_t v9 = icu::UnicodeString::UnicodeString(v8, 1LL, &v40);
  icu::Transliterator::_registerFactory(v9, (uint64_t)sub_18091AE80, (uint64_t)"nfkc");
  uint64_t v11 = icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v45);
  v29[3] = v40;
  unint64_t v39 = L"Any-FCD";
  unint64_t v12 = icu::UnicodeString::UnicodeString(v11, 1LL, &v39);
  icu::Transliterator::_registerFactory(v12, (uint64_t)sub_18091AE80, (uint64_t)&unk_180A3A43C);
  unsigned int v14 = icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v45);
  void v29[2] = v39;
  int32_t v38 = L"Any-FCC";
  unint64_t v15 = icu::UnicodeString::UnicodeString(v14, 1LL, &v38);
  icu::Transliterator::_registerFactory(v15, (uint64_t)sub_18091AE80, (uint64_t)&unk_180A3A442);
  unsigned int v17 = icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v45);
  v29[1] = v38;
  uint64_t v37 = L"NFC";
  icu::UnicodeString::UnicodeString(v17, 1LL, &v37);
  __int128 v36 = L"NFD";
  icu::UnicodeString::UnicodeString(v44, 1LL, &v36);
  icu::Transliterator::_registerSpecialInverse( (icu::Transliterator *)v45,  (const icu::UnicodeString *)v44,  (const icu::UnicodeString *)1);
  icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v44);
  v29[0] = v36;
  unsigned int v19 = icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)v45);
  v28[1] = v37;
  __int128 v35 = L"NFKC";
  icu::UnicodeString::UnicodeString(v19, 1LL, &v35);
  __int128 v34 = "N";
  icu::UnicodeString::UnicodeString(v44, 1LL, &v34);
  icu::Transliterator::_registerSpecialInverse( (icu::Transliterator *)v45,  (const icu::UnicodeString *)v44,  (const icu::UnicodeString *)1);
  icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v44);
  v28[0] = v34;
  unsigned int v21 = icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)v45);
  v27[1] = v35;
  __int128 v33 = L"FCC";
  icu::UnicodeString::UnicodeString(v21, 1LL, &v33);
  __int128 v32 = L"NFD";
  icu::UnicodeString::UnicodeString(v44, 1LL, &v32);
  icu::Transliterator::_registerSpecialInverse((icu::Transliterator *)v45, (const icu::UnicodeString *)v44, 0LL);
  icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v44);
  v27[0] = v32;
  __int16 v23 = icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)v45);
  v26[1] = v33;
  UErrorCode v31 = L"FCD";
  icu::UnicodeString::UnicodeString(v23, 1LL, &v31);
  unint64_t v30 = L"FCD";
  icu::UnicodeString::UnicodeString(v44, 1LL, &v30);
  icu::Transliterator::_registerSpecialInverse((icu::Transliterator *)v45, (const icu::UnicodeString *)v44, 0LL);
  icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)v44);
  v26[0] = v30;
  return icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v45);
}

icu::Transliterator *sub_18091AE80(UChar **a1, char *__s)
{
  int v4 = __s[strlen(__s) + 1];
  unsigned int v8 = 0;
  uint64_t Instance = icu::Normalizer2::getInstance(0LL, __s, v4, (int *)&v8);
  uint64_t result = 0LL;
  if ((int)v8 <= 0)
  {
    uint64_t result = (icu::Transliterator *)icu::UMemory::operator new((uint64_t *)v8, (icu::UMemory *)0x60, v5);
    if (result)
    {
      uint64_t result = icu::Transliterator::Transliterator(result, a1, 0LL);
      *(void *)uint64_t result = &off_189727278;
      *((void *)result + 1sub_1808F7164((uint64_t)v14, 1) = Instance;
    }
  }

  return result;
}

void sub_18091AF0C(icu::Transliterator *a1)
{
}

icu::Transliterator *sub_18091AF20@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::Transliterator *)icu::UMemory::operator new(a3, (icu::UMemory *)0x60, a2);
  if (result)
  {
    uint64_t result = icu::Transliterator::Transliterator(result, (UChar **)a1);
    *(void *)uint64_t result = &off_189727278;
    *((void *)result + 1sub_1808F7164((uint64_t)v14, 1) = *(void *)(a1 + 88);
  }

  return result;
}

void *sub_18091AF64(void *result, uint64_t a2, _DWORD *a3, int a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3[2];
  int v5 = a3[3];
  unint64_t v9 = result;
  int v21 = 0;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  uint64_t v31 = 0LL;
  __int128 v30 = 0u;
  uint64_t v26 = 0LL;
  unsigned int v27 = off_18971B688;
  LOWORD(v28) = 2;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  uint64_t v22 = off_18971B688;
  LOWORD(v23) = 2;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 80LL))(a2, v4);
  LODWORD(v1sub_1808F7164((uint64_t)v14, 1) = v4;
  while (1)
  {
    __int16 v12 = (v28 & 1) != 0 ? 2 : v28 & 0x1F;
    LOWORD(v28) = v12;
    do
    {
      icu::UnicodeString::append((uint64_t)&v27, v10);
      else {
        int v13 = 2;
      }
      uint64_t v11 = (v13 + v11);
      uint64_t v14 = v9[11];
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 80LL))(a2, v11);
    }

    while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v14 + 120LL))(v14, v10));
    if (a4
      && (_DWORD)v11 == v5
      && !(*(unsigned int (**)(void, uint64_t))(*(void *)v9[11] + 128LL))(v9[11], v10))
    {
      break;
    }

    (*(void (**)(void, void (***)(icu::UnicodeString *__hidden), void (***)(icu::UnicodeString *__hidden), int *))(*(void *)v9[11] + 24LL))( v9[11],  &v27,  &v22,  &v21);
    if (v21 > 0) {
      goto LABEL_34;
    }
    if ((v28 & 1) == 0)
    {
      if ((v28 & 0x8000u) == 0LL) {
        int v15 = (unsigned __int16)v28 >> 5;
      }
      else {
        int v15 = DWORD1(v28);
      }
      if ((v23 & 0x8000u) == 0LL) {
        int v16 = (unsigned __int16)v23 >> 5;
      }
      else {
        int v16 = DWORD1(v23);
      }
      if ((v23 & 1) == 0
        && v15 == v16
        && icu::UnicodeString::doEquals((icu::UnicodeString *)&v27, (const icu::UnicodeString *)&v22, v15))
      {
        goto LABEL_31;
      }

void *icu::NullTransliterator::getStaticClassID(icu::NullTransliterator *this)
{
  return &unk_18C5356AD;
}

void *sub_18091B1E8()
{
  return &unk_18C5356AD;
}

icu::Transliterator *sub_18091B1F4(icu::Transliterator *a1)
{
  v5[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t v4 = L"Any-Null";
  icu::UnicodeString::UnicodeString(v5, 1LL, &v4);
  icu::Transliterator::Transliterator(a1, v5, 0LL);
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)v5);
  *(void *)a1 = &off_189727328;
  return a1;
}

void sub_18091B2A0(icu::Transliterator *a1)
{
}

icu::Transliterator *sub_18091B2B4@<X0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result = (icu::Transliterator *)icu::UMemory::operator new(a2, (icu::UMemory *)0x58, a1);
  if (result) {
    return sub_18091B1F4(result);
  }
  return result;
}

void sub_18091B2D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a3 + 12);
}

uint64_t icu::number::impl::AffixUtils::estimateLength( icu::number::impl::AffixUtils *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  int v4 = (__int16)v3;
  LODWORD(v5) = v3 >> 5;
  if (v4 >= 0) {
    unint64_t v5 = v5;
  }
  else {
    unint64_t v5 = *((unsigned int *)this + 3);
  }
  LODWORD(v8) = 0;
  int v9 = 0;
  int v10 = 0;
  while (2)
  {
    unsigned int v11 = icu::UnicodeString::char32At((uint64_t *)v5, this, v9);
    switch(v10)
    {
      case 0:
        int v10 = v11 == 39;
        BOOL v12 = v11 != 39;
        goto LABEL_16;
      case 1:
        int v10 = 2 * (v11 != 39);
        goto LABEL_15;
      case 2:
        BOOL v12 = v11 != 39;
        if (v11 == 39) {
          int v10 = 3;
        }
        else {
          int v10 = 2;
        }
        goto LABEL_16;
      case 3:
        if (v11 == 39) {
          int v10 = 2;
        }
        else {
          int v10 = 3;
        }
LABEL_15:
        BOOL v12 = 1;
LABEL_16:
        uint64_t v8 = (v8 + v12);
        if (v11 < 0x10000) {
          int v13 = 1;
        }
        else {
          int v13 = 2;
        }
        v9 += v13;
        unsigned int v14 = *((unsigned __int16 *)this + 4);
        int v15 = (__int16)v14;
        LODWORD(v5) = v14 >> 5;
        if (v15 >= 0) {
          unint64_t v5 = v5;
        }
        else {
          unint64_t v5 = *((unsigned int *)this + 3);
        }
        break;
      default:
        abort();
    }

    return v8;
  }

uint64_t icu::number::impl::AffixUtils::escape@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a2;
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  unsigned int v4 = *(unsigned __int16 *)(this + 8);
  int v5 = (__int16)v4;
  LODWORD(a2) = v4 >> 5;
  if (v5 >= 0) {
    a2 = a2;
  }
  else {
    a2 = *(unsigned int *)(this + 12);
  }
  if ((int)a2 >= 1)
  {
    uint64_t v6 = this;
    int v7 = 0;
    int v8 = 0;
    while (2)
    {
      unsigned int v9 = icu::UnicodeString::char32At((uint64_t *)a2, (icu::UnicodeString *)v6, v7);
      unsigned int v10 = v9;
      switch(v9)
      {
        case '%':
        case '+':
        case '-':
          goto LABEL_10;
        case '&':
        case '(':
        case ')':
        case '*':
        case ',':
          goto LABEL_12;
        case '\'':
          this = icu::UnicodeString::doAppend(v3, (uint64_t)"'", 0, 0xFFFFFFFFLL);
          goto LABEL_14;
        default:
          if (v9 == 164 || v9 == 8240)
          {
LABEL_10:
            if (!v8)
            {
              __int16 v14 = 39;
              icu::UnicodeString::doAppend(v3, (uint64_t)&v14, 0, 1LL);
              this = icu::UnicodeString::append(v3, v10);
              int v8 = 2;
              goto LABEL_14;
            }

uint64_t icu::number::impl::AffixUtils::getFieldForType(unsigned int a1)
{
  if (a1 <= 0xFFFFFFF0 || ((0x7FE1u >> (a1 + 15)) & 1) == 0) {
    abort();
  }
  return byte_180A3A4ED[a1 + 15];
}

uint64_t icu::number::impl::AffixUtils::unescape( icu::UnicodeString *a1, icu::FormattedStringBuilder *a2, int a3, uint64_t a4, char a5, UErrorCode *a6)
{
  v29[8] = *MEMORY[0x1895F89C0];
  unint64_t v27 = 0LL;
  unint64_t v28 = 0LL;
  uint64_t v12 = 0LL;
  if (icu::number::impl::AffixUtils::hasNext((unsigned int *)&v27, (uint64_t)a1))
  {
    char v26 = a5;
    uint64_t v13 = v27;
    int v14 = v28;
    do
    {
      unint64_t Token = icu::number::impl::AffixUtils::nextToken(v13, v14, a1, a6);
      unint64_t v27 = Token;
      unint64_t v28 = v16;
      uint64_t v13 = Token;
      int v14 = v16;
      unint64_t v17 = HIDWORD(v16);
      if (HIDWORD(v16) == -15)
      {
        int v18 = v12 + a3;
        unint64_t v19 = a2;
        LODWORD(v20) = 65533;
        char v21 = 39;
      }

      else
      {
        if ((v16 & 0x8000000000000000LL) != 0)
        {
          (*(void (**)(void *__return_ptr, uint64_t, unint64_t))(*(void *)a4 + 16LL))( v29,  a4,  HIDWORD(v16));
          FieldForunsigned int Type = icu::number::impl::AffixUtils::getFieldForType(v17);
          int inserted = icu::FormattedStringBuilder::insert(a2, (int)v12 + a3, (uint64_t)v29, FieldForType, 0, a6);
          icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)v29);
          goto LABEL_9;
        }

        unint64_t v20 = HIDWORD(Token);
        unint64_t v19 = a2;
        int v18 = v12 + a3;
        char v21 = v26;
      }

      int inserted = icu::FormattedStringBuilder::insertCodePoint(v19, v18, v20, v21, a6);
LABEL_9:
      uint64_t v12 = (inserted + v12);
    }

    while ((icu::number::impl::AffixUtils::hasNext((unsigned int *)&v27, (uint64_t)a1) & 1) != 0);
  }

  return v12;
}

uint64_t icu::number::impl::AffixUtils::hasNext(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if ((v2 & 0x80000000) != 0) {
    return 0LL;
  }
  if ((_DWORD)v2)
  {
    unsigned int v3 = a1[2];
    if (v3)
    {
      if (v3 == 2)
      {
        unsigned int v4 = *(unsigned __int16 *)(a2 + 8);
        unsigned int v5 = *(__int16 *)(a2 + 8) < 0 ? *(_DWORD *)(a2 + 12) : v4 >> 5;
        if ((_DWORD)v2 == v5 - 1 && v5 > v2)
        {
          uint64_t v13 = (v4 & 2) != 0 ? a2 + 10 : *(void *)(a2 + 24);
          if (*(_WORD *)(v13 + 2 * v2) == 39) {
            return 0LL;
          }
        }
      }

      return 1LL;
    }

    else
    {
      unsigned int v10 = *(unsigned __int16 *)(a2 + 8);
      int v11 = (__int16)v10;
      int v12 = v10 >> 5;
      if (v11 < 0) {
        int v12 = *(_DWORD *)(a2 + 12);
      }
      return (int)v2 < v12;
    }
  }

  else
  {
    unsigned int v6 = *(unsigned __int16 *)(a2 + 8);
    int v7 = (__int16)v6;
    signed int v8 = v6 >> 5;
    if (v7 < 0) {
      signed int v8 = *(_DWORD *)(a2 + 12);
    }
    return v8 > 0;
  }

unint64_t icu::number::impl::AffixUtils::nextToken( uint64_t a1, int a2, icu::UnicodeString *this, _DWORD *a4)
{
  int v6 = a1;
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  int v8 = (__int16)v7;
  LODWORD(v9) = v7 >> 5;
  if (v8 >= 0) {
    unint64_t v9 = v9;
  }
  else {
    unint64_t v9 = *((unsigned int *)this + 3);
  }
  if ((int)v9 <= (int)a1)
  {
LABEL_35:
    unsigned int v14 = -1;
    switch(a2)
    {
      case 0:
      case 3:
        return v14 | (unint64_t)(a1 << 32);
      case 1:
      case 2:
        *a4 = 1;
        unsigned int v14 = -1;
        return v14 | (unint64_t)(a1 << 32);
      case 4:
        a1 = 0LL;
        goto LABEL_43;
      case 5:
        goto LABEL_37;
      case 6:
        goto LABEL_38;
      case 7:
        goto LABEL_39;
      case 8:
        goto LABEL_40;
      case 9:
        goto LABEL_41;
      default:
        goto LABEL_57;
    }
  }

  while (1)
  {
    a1 = (uint64_t)icu::UnicodeString::char32At((uint64_t *)v9, this, v6);
    else {
      int v11 = 2;
    }
    switch(a2)
    {
      case 0:
        if ((int)a1 <= 125)
        {
          switch((int)a1)
          {
            case '%':
              a1 = 0LL;
              unsigned int v14 = v11 + v6;
              return v14 | (unint64_t)(a1 << 32);
            case '\'':
              v6 += v11;
              a2 = 1;
              goto LABEL_28;
            case '+':
              a1 = 0LL;
              unsigned int v14 = v11 + v6;
              return v14 | (unint64_t)(a1 << 32);
            case '-':
              a1 = 0LL;
              unsigned int v14 = v11 + v6;
              return v14 | (unint64_t)(a1 << 32);
            default:
              goto LABEL_56;
          }
        }

        switch((_DWORD)a1)
        {
          case 0xA4:
            v6 += v11;
            a2 = 4;
            goto LABEL_28;
          case 0x7E:
            a1 = 0LL;
            unsigned int v14 = v11 + v6;
            break;
          case 0x2030:
            a1 = 0LL;
            unsigned int v14 = v11 + v6;
            break;
          default:
LABEL_56:
            unsigned int v14 = v11 + v6;
            break;
        }

        return v14 | (unint64_t)(a1 << 32);
      case 1:
        unsigned int v14 = v11 + v6;
        return v14 | (unint64_t)(a1 << 32);
      case 2:
        v6 += v11;
        if ((_DWORD)a1 != 39) {
          goto LABEL_43;
        }
        a2 = 3;
        break;
      case 3:
        if ((_DWORD)a1 == 39)
        {
          unsigned int v14 = v11 + v6;
          a1 = 39LL;
          return v14 | (unint64_t)(a1 << 32);
        }

        a2 = 0;
        break;
      case 4:
        if ((_DWORD)a1 != 164)
        {
          a1 = 0LL;
          goto LABEL_43;
        }

        v6 += v11;
        a2 = 5;
        break;
      case 5:
        if ((_DWORD)a1 != 164)
        {
LABEL_37:
          a1 = 0LL;
LABEL_43:
          unsigned int v14 = v6;
          return v14 | (unint64_t)(a1 << 32);
        }

        v6 += v11;
        a2 = 6;
        break;
      case 6:
        if ((_DWORD)a1 != 164)
        {
LABEL_38:
          a1 = 0LL;
          goto LABEL_43;
        }

        v6 += v11;
        a2 = 7;
        break;
      case 7:
        if ((_DWORD)a1 != 164)
        {
LABEL_39:
          a1 = 0LL;
          goto LABEL_43;
        }

        v6 += v11;
        a2 = 8;
        break;
      case 8:
        if ((_DWORD)a1 == 164) {
          goto LABEL_27;
        }
LABEL_40:
        a1 = 0LL;
        goto LABEL_43;
      case 9:
        if ((_DWORD)a1 != 164)
        {
LABEL_41:
          a1 = 0LL;
          goto LABEL_43;
        }

uint64_t icu::number::impl::AffixUtils::unescapedCodePointCount( icu::number::impl::AffixUtils *this, const icu::UnicodeString *a2, const icu::number::impl::SymbolProvider *a3, UErrorCode *a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v7 = 0LL;
  if (icu::number::impl::AffixUtils::hasNext((unsigned int *)&v15, (uint64_t)this))
  {
    uint64_t v8 = v15;
    int v9 = v16;
    do
    {
      unint64_t Token = icu::number::impl::AffixUtils::nextToken(v8, v9, this, a3);
      unint64_t v15 = Token;
      uint64_t v16 = v11;
      uint64_t v8 = Token;
      int v9 = v11;
      if (HIDWORD(v11) == -15)
      {
        uint64_t v7 = (v7 + 1);
      }

      else if (v11 < 0)
      {
        (*(void (**)(uint64_t *__return_ptr, const icu::UnicodeString *))(*(void *)a2 + 16LL))(&v17, a2);
        LODWORD(v13) = v18 >> 5;
        int v13 = (v18 & 0x8000u) == 0 ? (void *)v13 : (void *)v19;
        uint64_t v7 = ((_DWORD)v13 + v7);
        icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)&v17);
      }

      else
      {
        int v12 = HIWORD(Token) ? 2 : 1;
        uint64_t v7 = (v12 + v7);
      }
    }

    while ((icu::number::impl::AffixUtils::hasNext((unsigned int *)&v15, (uint64_t)this) & 1) != 0);
  }

  return v7;
}

uint64_t icu::number::impl::AffixUtils::containsType(uint64_t a1, int a2, int *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a1 + 8);
  int v4 = (__int16)v3;
  unsigned int v5 = v3 >> 5;
  if (v4 < 0) {
    unsigned int v5 = *(_DWORD *)(a1 + 12);
  }
  if (!v5) {
    return 0LL;
  }
  int v9 = 0;
  uint64_t v10 = 0LL;
  unint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  while (1)
  {
    uint64_t result = icu::number::impl::AffixUtils::hasNext((unsigned int *)&v14, a1);
    if (!(_DWORD)result) {
      break;
    }
    unint64_t Token = icu::number::impl::AffixUtils::nextToken(v10, v9, (icu::UnicodeString *)a1, a3);
    unint64_t v14 = Token;
    uint64_t v15 = v13;
    if (*a3 > 0) {
      return 0LL;
    }
    uint64_t v10 = Token;
    int v9 = v13;
    if (HIDWORD(v13) == a2) {
      return 1LL;
    }
  }

  return result;
}

uint64_t icu::number::impl::AffixUtils::hasCurrencySymbols( icu::number::impl::AffixUtils *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  int v4 = (__int16)v3;
  unsigned int v5 = v3 >> 5;
  if (v4 < 0) {
    unsigned int v5 = *((_DWORD *)this + 3);
  }
  if (v5)
  {
    unint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t result = icu::number::impl::AffixUtils::hasNext((unsigned int *)&v13, (uint64_t)this);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v9 = v13;
    int v10 = v14;
    do
    {
      unint64_t Token = icu::number::impl::AffixUtils::nextToken(v9, v10, this, a2);
      unint64_t v13 = Token;
      uint64_t v14 = v12;
      uint64_t v9 = Token;
      int v10 = v12;
    }

    while ((icu::number::impl::AffixUtils::hasNext((unsigned int *)&v13, (uint64_t)this) & 1) != 0);
  }

  return 0LL;
}

uint64_t icu::number::impl::AffixUtils::replaceType@<X0>( UChar **a1@<X0>, int a2@<W1>, __int16 a3@<W2>, int *a4@<X3>, icu::UnicodeString *a5@<X8>)
{
  *((_OWORD *)a5 + 2) = 0u;
  *((_OWORD *)a5 + 3) = 0u;
  *(_OWORD *)a5 = 0u;
  *((_OWORD *)a5 + sub_1808F7164((uint64_t)v14, 1) = 0u;
  uint64_t result = (uint64_t)icu::UnicodeString::UnicodeString(a5, a1);
  unsigned int v11 = *((unsigned __int16 *)a1 + 4);
  int v12 = (__int16)v11;
  unsigned int v13 = v11 >> 5;
  if (v12 < 0) {
    unsigned int v13 = *((_DWORD *)a1 + 3);
  }
  if (v13)
  {
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t result = icu::number::impl::AffixUtils::hasNext((unsigned int *)&v17, (uint64_t)a1);
    if ((_DWORD)result)
    {
      uint64_t v14 = v17;
      int v15 = v18;
      do
      {
        uint64_t result = icu::number::impl::AffixUtils::nextToken(v14, v15, (icu::UnicodeString *)a1, a4);
        uint64_t v17 = result;
        uint64_t v18 = v16;
        if (*a4 > 0) {
          break;
        }
        uint64_t v14 = result;
        int v15 = v16;
        if (HIDWORD(v16) == a2)
        {
          __int16 v19 = a3;
          icu::UnicodeString::doReplace((uint64_t)a5, (result - 1), 1LL, (uint64_t)&v19, 0, 1LL);
        }

        uint64_t result = icu::number::impl::AffixUtils::hasNext((unsigned int *)&v17, (uint64_t)a1);
      }

      while ((result & 1) != 0);
    }
  }

  return result;
}

uint64_t icu::number::impl::AffixUtils::containsOnlySymbolsAndIgnorables( icu::number::impl::AffixUtils *this, const icu::UnicodeString *a2, const icu::UnicodeSet *a3, UErrorCode *a4)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  int v5 = (__int16)v4;
  unsigned int v6 = v4 >> 5;
  if (v5 < 0) {
    unsigned int v6 = *((_DWORD *)this + 3);
  }
  if (!v6) {
    return 1LL;
  }
  unint64_t v15 = 0LL;
  unint64_t v16 = 0LL;
  uint64_t v10 = v15;
  int v11 = v16;
  while (1)
  {
    unint64_t Token = icu::number::impl::AffixUtils::nextToken(v10, v11, this, a3);
    unint64_t v15 = Token;
    unint64_t v16 = v13;
    uint64_t v10 = Token;
    int v11 = v13;
    if (!HIDWORD(v13))
    {
      uint64_t result = icu::UnicodeSet::contains(a2, SHIDWORD(Token));
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  return 0LL;
}

unint64_t icu::number::impl::AffixUtils::iterateWithConsumer( unint64_t result, uint64_t a2, int *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(result + 8);
  int v4 = (__int16)v3;
  unsigned int v5 = v3 >> 5;
  if (v4 < 0) {
    unsigned int v5 = *(_DWORD *)(result + 12);
  }
  if (v5)
  {
    uint64_t v8 = (icu::UnicodeString *)result;
    int v9 = 0;
    uint64_t v10 = 0LL;
    unint64_t v12 = 0LL;
    unint64_t v13 = 0LL;
    do
    {
      uint64_t result = icu::number::impl::AffixUtils::hasNext((unsigned int *)&v12, (uint64_t)v8);
      if (!(_DWORD)result) {
        break;
      }
      uint64_t result = icu::number::impl::AffixUtils::nextToken(v10, v9, v8, a3);
      unint64_t v12 = result;
      unint64_t v13 = v11;
      if (*a3 > 0) {
        break;
      }
      uint64_t v10 = result;
      int v9 = v11;
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, int *))(*(void *)a2 + 16LL))( a2,  HIDWORD(v11),  HIDWORD(result),  a3);
    }

    while (*a3 < 1);
  }

  return result;
}

void *icu::number::impl::LocalizedNumberFormatterAsFormat::getStaticClassID( icu::number::impl::LocalizedNumberFormatterAsFormat *this)
{
  return &unk_18C5356AE;
}

void *icu::number::impl::LocalizedNumberFormatterAsFormat::getDynamicClassID( icu::number::impl::LocalizedNumberFormatterAsFormat *this)
{
  return &unk_18C5356AE;
}

icu::number::impl::LocalizedNumberFormatterAsFormat *icu::number::impl::LocalizedNumberFormatterAsFormat::LocalizedNumberFormatterAsFormat( icu::number::impl::LocalizedNumberFormatterAsFormat *this, const icu::number::LocalizedNumberFormatter *a2, const char **a3)
{
  unsigned int v6 = (void *)icu::Format::Format((uint64_t)this);
  *unsigned int v6 = off_189727420;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter( (icu::number::LocalizedNumberFormatter *)(v6 + 41),  a2);
  icu::Locale::Locale((icu::number::impl::LocalizedNumberFormatterAsFormat *)((char *)this + 824), (uint64_t)a3);
  icu::Format::setLocaleIDs(this, a3[5], a3[5]);
  return this;
}

void icu::number::impl::LocalizedNumberFormatterAsFormat::~LocalizedNumberFormatterAsFormat( icu::number::impl::LocalizedNumberFormatterAsFormat *this)
{
  *(void *)this = off_189727420;
  icu::Locale::~Locale((icu::number::impl::LocalizedNumberFormatterAsFormat *)((char *)this + 824));
  icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::impl::LocalizedNumberFormatterAsFormat *)((char *)this + 328));
  icu::Format::~Format(this);
}

{
  void *v1;
  icu::number::impl::LocalizedNumberFormatterAsFormat::~LocalizedNumberFormatterAsFormat(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::number::impl::LocalizedNumberFormatterAsFormat::operator==(uint64_t a1, void *lpsrc)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!v3) {
    return 0LL;
  }
  int v4 = v3;
  int v10 = 0;
  icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::toSkeleton( (UErrorCode *)&v10,  a1 + 328,  (uint64_t)v14);
  icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::toSkeleton( (UErrorCode *)&v10,  (uint64_t)v4 + 328,  (uint64_t)v11);
  if ((v15 & 1) != 0)
  {
    unint64_t v7 = v12;
    uint64_t v5 = v12 & 1;
  }

  else
  {
    uint64_t v5 = 0LL;
    if ((v15 & 0x8000u) == 0) {
      int v6 = v15 >> 5;
    }
    else {
      int v6 = v16;
    }
    if ((v12 & 0x8000u) == 0) {
      unint64_t v7 = v12 >> 5;
    }
    else {
      unint64_t v7 = v13;
    }
    if ((v12 & 1) == 0 && v6 == (_DWORD)v7) {
      uint64_t v5 = icu::UnicodeString::doEquals((icu::UnicodeString *)v14, (const icu::UnicodeString *)v11, v6);
    }
  }

  icu::UnicodeString::~UnicodeString((void *)v7, (icu::UnicodeString *)v11);
  icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v14);
  return v5;
}

uint64_t *icu::number::impl::LocalizedNumberFormatterAsFormat::clone@<X0>( icu::number::impl::LocalizedNumberFormatterAsFormat *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0x418, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    icu::Format::Format((uint64_t)v4, (uint64_t)this);
    *uint64_t v5 = (uint64_t)off_189727420;
    icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter( (icu::number::LocalizedNumberFormatter *)(v5 + 41),  (icu::number::impl::LocalizedNumberFormatterAsFormat *)((char *)this + 328));
    icu::Locale::Locale((icu::Locale *)(v5 + 103), (uint64_t)this + 824);
  }

  return v5;
}

icu::UnicodeString *icu::number::impl::LocalizedNumberFormatterAsFormat::format( icu::number::impl::LocalizedNumberFormatterAsFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPosition *a4, UErrorCode *a5)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v24 = 0LL;
    memset(v23, 0, sizeof(v23));
    memset(v22, 0, sizeof(v22));
    sub_1808D4228((uint64_t)v22);
    icu::Formattable::populateDecimalQuantity(a2, (icu::number::impl::DecimalQuantity *)v23, a5);
    if (*(int *)a5 > 0
      || (icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::impl::LocalizedNumberFormatterAsFormat *)((char *)this + 328),  (icu::number::impl::UFormattedNumberData *)v22,  a5),  *(int *)a5 > 0))
    {
LABEL_16:
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v22);
      return a3;
    }

    *((_DWORD *)a4 + 3) = 0;
    *((_DWORD *)a4 + 4) = 0;
    if (icu::FormattedValueStringBuilderImpl::nextFieldPosition( (icu::FormattedValueStringBuilderImpl *)v22,  a4,  a5))
    {
      if (*((__int16 *)a3 + 4) < 0)
      {
        unsigned int v11 = *((_DWORD *)a3 + 3);
        if (v11) {
          goto LABEL_9;
        }
      }

      else
      {
        unsigned int v10 = *((unsigned __int16 *)a3 + 4);
        if (v10 >= 0x20)
        {
          unsigned int v11 = v10 >> 5;
LABEL_9:
          int v12 = *((_DWORD *)a4 + 4);
          *((_DWORD *)a4 + 3) += v11;
          unsigned int v13 = *((unsigned __int16 *)a3 + 4);
          int v14 = (__int16)v13;
          unsigned int v15 = v13 >> 5;
          if (v14 < 0) {
            unsigned int v15 = *((_DWORD *)a3 + 3);
          }
          *((_DWORD *)a4 + 4) = v15 + v12;
        }
      }
    }

    icu::FormattedValueStringBuilderImpl::toTempString((icu::FormattedValueStringBuilderImpl *)v22, (uint64_t)&v19);
    if ((v20 & 0x8000u) == 0) {
      uint64_t v16 = v20 >> 5;
    }
    else {
      uint64_t v16 = v21;
    }
    icu::UnicodeString::doAppend((uint64_t)a3, (const icu::UnicodeString *)&v19, 0, v16);
    icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v19);
    goto LABEL_16;
  }

  return a3;
}

icu::UnicodeString *icu::number::impl::LocalizedNumberFormatterAsFormat::format( icu::number::impl::LocalizedNumberFormatterAsFormat *this, const icu::Formattable *a2, icu::UnicodeString *a3, icu::FieldPositionIterator *a4, UErrorCode *a5)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v17 = 0LL;
    memset(v16, 0, sizeof(v16));
    memset(v15, 0, sizeof(v15));
    sub_1808D4228((uint64_t)v15);
    icu::Formattable::populateDecimalQuantity(a2, (icu::number::impl::DecimalQuantity *)v16, a5);
    if (*(int *)a5 <= 0)
    {
      icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::impl::LocalizedNumberFormatterAsFormat *)((char *)this + 328),  (icu::number::impl::UFormattedNumberData *)v15,  a5);
      if (*(int *)a5 <= 0)
      {
        icu::FormattedValueStringBuilderImpl::toTempString((icu::FormattedValueStringBuilderImpl *)v15, (uint64_t)v13);
        if ((SWORD4(v13[0]) & 0x8000u) == 0) {
          uint64_t v10 = WORD4(v13[0]) >> 5;
        }
        else {
          uint64_t v10 = HIDWORD(v13[0]);
        }
        icu::UnicodeString::doAppend((uint64_t)a3, (const icu::UnicodeString *)v13, 0, v10);
        icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v13);
        if (a4)
        {
          uint64_t v14 = 0LL;
          memset(v13, 0, sizeof(v13));
          icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler( (icu::FieldPositionIteratorHandler *)v13,  a4,  a5);
          icu::FormattedValueStringBuilderImpl::getAllFieldPositions( (icu::FormattedValueStringBuilderImpl *)v15,  (icu::FieldPositionIteratorHandler *)v13,  a5);
          icu::FieldPositionIteratorHandler::~FieldPositionIteratorHandler((icu::FieldPositionIteratorHandler *)v13);
        }
      }
    }

    icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)v15);
  }

  return a3;
}

void icu::number::impl::LocalizedNumberFormatterAsFormat::parseObject( icu::number::impl::LocalizedNumberFormatterAsFormat *this, const icu::UnicodeString *a2, icu::Formattable *a3, icu::ParsePosition *a4)
{
  *((_DWORD *)a4 + 3) = 0;
}

uint64_t icu::number::impl::LocalizedNumberFormatterAsFormat::getNumberFormatter( icu::number::impl::LocalizedNumberFormatterAsFormat *this)
{
  return (uint64_t)this + 328;
}

icu::number::impl::LocalizedNumberFormatterAsFormat *icu::number::LocalizedNumberFormatter::toFormat( const char **this, UErrorCode *a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)a2;
  int v6 = (icu::number::impl::LocalizedNumberFormatterAsFormat *)icu::UMemory::operator new( v2,  (icu::UMemory *)0x418,  (unint64_t)a2);
  if (v6) {
    return icu::number::impl::LocalizedNumberFormatterAsFormat::LocalizedNumberFormatterAsFormat( v6,  (const icu::number::LocalizedNumberFormatter *)this,  this + 31);
  }
  uint64_t result = 0LL;
  *a2 = U_MEMORY_ALLOCATION_ERROR;
  return result;
}

uint64_t sub_18091C6C4(uint64_t a1, uint64_t a2)
{
  icu::number::impl::DecimalQuantity::operator=((icu::number::impl::DecimalQuantity *)(a1 + 304), a2 + 304);
  icu::MeasureUnit::operator=(a1 + 376, a2 + 376);
  *(void *)(a1 + 400) = *(void *)(a2 + 400);
  return a1;
}

uint64_t *unumf_openResult(_DWORD *a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t *)*a1;
  uint64_t v5 = icu::UMemory::operator new(v2, (icu::UMemory *)0x1C8, a2);
  unsigned int v3 = v5;
  if (v5)
  {
    *(_DWORD *)uint64_t v5 = 1430672896;
    v5[1] = 0LL;
    *((_DWORD *)v5 + 4) = 1178881536;
    void v5[3] = (uint64_t)off_189727E50;
    v5[4] = (uint64_t)(v5 + 6);
    *((_DWORD *)v5 + 10) = 0;
    sub_1808D4228((uint64_t)(v5 + 6));
    v3[1] = (uint64_t)(v3 + 3);
  }

  else
  {
    *a1 = 7;
  }

  return v3;
}

uint64_t unumf_resultAsValue(uint64_t result, int *a2)
{
  int v2 = *a2;
  if (*a2 > 0)
  {
    uint64_t result = 0LL;
    goto LABEL_8;
  }

  if (result)
  {
    if (*(_DWORD *)(result + 16) == 1178881536) {
      goto LABEL_8;
    }
    int v2 = 3;
  }

  else
  {
    int v2 = 1;
  }

  uint64_t result = 0LL;
  *a2 = v2;
LABEL_8:
  if (v2 >= 1) {
    return 0LL;
  }
  return result;
}

void unumf_closeResult(_DWORD *a1)
{
  if (a1)
  {
    if (a1[4] == 1178881536)
    {
      *((void *)a1 + 4) = 0LL;
      icu::number::impl::UFormattedNumberData::~UFormattedNumberData((icu::number::impl::UFormattedNumberData *)(a1 + 12));
      icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)(a1 + 6));
      a1[4] = 0;
      *a1 = 0;
      icu::UMemory::operator delete(a1);
    }
  }

uint64_t sub_18091C850(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if (*a2 > 0)
  {
    a1 = 0LL;
    goto LABEL_8;
  }

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1178881536) {
      goto LABEL_8;
    }
    int v2 = 3;
  }

  else
  {
    int v2 = 1;
  }

  a1 = 0LL;
  *a2 = v2;
LABEL_8:
  if (v2 >= 1) {
    return 0LL;
  }
  else {
    return a1 + 352;
  }
}

uint64_t *unumf_openForSkeletonAndLocale(uint64_t a1, unint64_t a2, const char *a3, UErrorCode *a4)
{
  int v6 = a2;
  char v26 = (uint64_t *)*MEMORY[0x1895F89C0];
  uint64_t v8 = icu::UMemory::operator new(v26, (icu::UMemory *)0x1F8, a2);
  int v9 = v8;
  if (v8)
  {
    v8[62] = 0LL;
    *((_OWORD *)v8 + 29) = 0u;
    *((_OWORD *)v8 + 30) = 0u;
    *((_OWORD *)v8 + 27) = 0u;
    *((_OWORD *)v8 + 28) = 0u;
    *((_OWORD *)v8 + 25) = 0u;
    *((_OWORD *)v8 + 26) = 0u;
    *((_OWORD *)v8 + 23) = 0u;
    *((_OWORD *)v8 + 24) = 0u;
    *((_OWORD *)v8 + 2sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_OWORD *)v8 + 22) = 0u;
    *((_OWORD *)v8 + 19) = 0u;
    *((_OWORD *)v8 + 20) = 0u;
    *((_OWORD *)v8 + 17) = 0u;
    *((_OWORD *)v8 + 18) = 0u;
    *((_OWORD *)v8 + 15) = 0u;
    *((_OWORD *)v8 + 16) = 0u;
    *((_OWORD *)v8 + 13) = 0u;
    *((_OWORD *)v8 + 14) = 0u;
    *((_OWORD *)v8 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
    *((_OWORD *)v8 + sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_DWORD *)uint64_t v8 = 1313231360;
    *((_OWORD *)v8 + 2) = 0u;
    sub_1808D3E38((uint64_t)(v8 + 1));
    v9[60] = 0LL;
    v9[61] = 0LL;
    v9[62] = 0LL;
    memset(v25, 0, sizeof(v25));
    uint64_t v14 = a1;
    uint64_t v10 = (UChar **)icu::UnicodeString::UnicodeString(v25, v6 == -1, &v14);
    icu::number::NumberFormatter::forSkeleton(v10, a4, &v16);
    icu::Locale::Locale(v11, (icu::Locale *)v15, a3, 0LL, 0LL, 0LL);
    icu::number::UnlocalizedNumberFormatter::locale((uint64_t)&v16, (uint64_t)v15, (uint64_t)v24);
    icu::number::LocalizedNumberFormatter::operator=((uint64_t)(v9 + 1), (uint64_t)v24);
    icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v24);
    icu::Locale::~Locale((icu::Locale *)v15);
    icu::Locale::~Locale((icu::Locale *)&v23);
    icu::number::impl::StringProp::~StringProp(&v22);
    icu::number::impl::StringProp::~StringProp(&v21);
    icu::number::Scale::~Scale((icu::number::Scale *)&v20);
    icu::number::impl::SymbolsWrapper::~SymbolsWrapper((icu::number::impl::SymbolsWrapper *)&v19);
    icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)&v18);
    icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)&v17);
    icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v25);
  }

  else
  {
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v9;
}

uint64_t *unumf_openForSkeletonAndLocaleWithError( uint64_t a1, unint64_t a2, const char *a3, const icu::UnicodeString *a4, UParseError *a5)
{
  int v8 = a2;
  uint64_t v32 = (uint64_t *)*MEMORY[0x1895F89C0];
  uint64_t v10 = icu::UMemory::operator new(v32, (icu::UMemory *)0x1F8, a2);
  unsigned int v11 = v10;
  if (v10)
  {
    v10[62] = 0LL;
    *((_OWORD *)v10 + 29) = 0u;
    *((_OWORD *)v10 + 30) = 0u;
    *((_OWORD *)v10 + 27) = 0u;
    *((_OWORD *)v10 + 28) = 0u;
    *((_OWORD *)v10 + 25) = 0u;
    *((_OWORD *)v10 + 26) = 0u;
    *((_OWORD *)v10 + 23) = 0u;
    *((_OWORD *)v10 + 24) = 0u;
    *((_OWORD *)v10 + 2sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_OWORD *)v10 + 22) = 0u;
    *((_OWORD *)v10 + 19) = 0u;
    *((_OWORD *)v10 + 20) = 0u;
    *((_OWORD *)v10 + 17) = 0u;
    *((_OWORD *)v10 + 18) = 0u;
    *((_OWORD *)v10 + 15) = 0u;
    *((_OWORD *)v10 + 16) = 0u;
    *((_OWORD *)v10 + 13) = 0u;
    *((_OWORD *)v10 + 14) = 0u;
    *((_OWORD *)v10 + 1sub_1808F7164((uint64_t)v14, 1) = 0u;
    *((_OWORD *)v10 + 12) = 0u;
    *((_OWORD *)v10 + 9) = 0u;
    *((_OWORD *)v10 + 10) = 0u;
    *((_OWORD *)v10 + 7) = 0u;
    *((_OWORD *)v10 + 8) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 6) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
    *((_OWORD *)v10 + sub_1808F7164((uint64_t)v14, 1) = 0u;
    *(_DWORD *)uint64_t v10 = 1313231360;
    *((_OWORD *)v10 + 2) = 0u;
    sub_1808D3E38((uint64_t)(v10 + 1));
    v11[60] = 0LL;
    v11[61] = 0LL;
    v11[62] = 0LL;
    memset(v31, 0, 64);
    uint64_t v20 = a1;
    int v12 = (icu::number::NumberFormatter *)icu::UnicodeString::UnicodeString(v31, v8 == -1, &v20);
    uint64_t v19 = 0LL;
    memset(v18, 0, sizeof(v18));
    if (a4) {
      uint64_t v14 = a4;
    }
    else {
      uint64_t v14 = (const icu::UnicodeString *)v18;
    }
    icu::number::NumberFormatter::forSkeleton(v22, v12, v14, a5, v13);
    icu::Locale::Locale(v15, (icu::Locale *)v21, a3, 0LL, 0LL, 0LL);
    icu::number::UnlocalizedNumberFormatter::locale((uint64_t)v22, (uint64_t)v21, (uint64_t)v30);
    icu::number::LocalizedNumberFormatter::operator=((uint64_t)(v11 + 1), (uint64_t)v30);
    icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)v30);
    icu::Locale::~Locale((icu::Locale *)v21);
    icu::Locale::~Locale((icu::Locale *)&v29);
    icu::number::impl::StringProp::~StringProp(&v28);
    icu::number::impl::StringProp::~StringProp(&v27);
    icu::number::Scale::~Scale((icu::number::Scale *)&v26);
    icu::number::impl::SymbolsWrapper::~SymbolsWrapper((icu::number::impl::SymbolsWrapper *)&v25);
    icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)&v24);
    icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)&v23);
    icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v31);
  }

  else
  {
    a5->line = 7;
  }

  return v11;
}

_DWORD *unumf_formatInt(_DWORD *result, unint64_t a2, uint64_t a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    uint64_t v5 = result;
    if (result)
    {
      if (*result != 1313231360)
      {
LABEL_8:
        int v10 = 3;
        goto LABEL_9;
      }

      if (a3)
      {
        if (*(_DWORD *)(a3 + 16) == 1178881536)
        {
          int v8 = (icu::number::impl::UFormattedNumberData *)(a3 + 48);
          icu::FormattedValueStringBuilderImpl::resetString((icu::FormattedValueStringBuilderImpl *)(a3 + 48));
          int v9 = (void **)(a3 + 352);
          icu::number::impl::DecimalQuantity::clear(v9);
          icu::number::impl::DecimalQuantity::setToLong(v9, a2);
          return (_DWORD *)icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(v5 + 2),  v8,  a4);
        }

        goto LABEL_8;
      }
    }

    int v10 = 1;
LABEL_9:
    *a4 = v10;
  }

  return result;
}

_DWORD *unumf_formatDouble(_DWORD *result, uint64_t a2, UErrorCode *a3, double a4)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v5 = result;
    if (result)
    {
      if (*result != 1313231360)
      {
LABEL_8:
        int v10 = 3;
        goto LABEL_9;
      }

      if (a2)
      {
        if (*(_DWORD *)(a2 + 16) == 1178881536)
        {
          int v8 = (icu::number::impl::UFormattedNumberData *)(a2 + 48);
          icu::FormattedValueStringBuilderImpl::resetString((icu::FormattedValueStringBuilderImpl *)(a2 + 48));
          int v9 = (void **)(a2 + 352);
          icu::number::impl::DecimalQuantity::clear(v9);
          icu::number::impl::DecimalQuantity::setToDouble(v9, a4);
          return (_DWORD *)icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(v5 + 2),  v8,  a3);
        }

        goto LABEL_8;
      }
    }

    int v10 = 1;
LABEL_9:
    *a3 = v10;
  }

  return result;
}

_DWORD *unumf_formatDecimal(_DWORD *result, const char *a2, int a3, uint64_t a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    int v6 = result;
    if (result)
    {
      if (*result != 1313231360)
      {
LABEL_9:
        int v12 = 3;
        goto LABEL_10;
      }

      if (a4)
      {
        if (*(_DWORD *)(a4 + 16) == 1178881536)
        {
          int v10 = (icu::number::impl::UFormattedNumberData *)(a4 + 48);
          icu::FormattedValueStringBuilderImpl::resetString((icu::FormattedValueStringBuilderImpl *)(a4 + 48));
          unsigned int v11 = (void **)(a4 + 352);
          icu::number::impl::DecimalQuantity::clear(v11);
          uint64_t result = (_DWORD *)icu::number::impl::DecimalQuantity::setToDecNumber((uint64_t)v11, a2, a3, a5);
          if (*(int *)a5 <= 0) {
            return (_DWORD *)icu::number::LocalizedNumberFormatter::formatImpl( (icu::number::LocalizedNumberFormatter *)(v6 + 2),  v10,  a5);
          }
          return result;
        }

        goto LABEL_9;
      }
    }

    int v12 = 1;
LABEL_10:
    *a5 = v12;
  }

  return result;
}

uint64_t unumf_resultToString(uint64_t a1, UChar *a2, int a3, UErrorCode *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 <= 0)
  {
    if (a1)
    {
      if (*(_DWORD *)(a1 + 16) == 1178881536)
      {
        if (a2)
        {
          if ((a3 & 0x80000000) == 0)
          {
LABEL_7:
            icu::FormattedValueStringBuilderImpl::toTempString( (icu::FormattedValueStringBuilderImpl *)(a1 + 48),  (uint64_t)v12);
            unsigned int v11 = a2;
            uint64_t v4 = icu::UnicodeString::extract((uint64_t)v12, &v11, a3, (int *)a4);
            int v10 = v11;
            icu::UnicodeString::~UnicodeString(&v10, (icu::UnicodeString *)v12);
            return v4;
          }
        }

        else if (!a3)
        {
          goto LABEL_7;
        }

        uint64_t v4 = 0LL;
        UErrorCode v8 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_11:
        *a4 = v8;
        return v4;
      }

      UErrorCode v8 = U_INVALID_FORMAT_ERROR;
    }

    else
    {
      UErrorCode v8 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    uint64_t v4 = 0LL;
    goto LABEL_11;
  }

  return 0LL;
}

BOOL unumf_resultNextFieldPosition(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (a1)
    {
      if (*(_DWORD *)(a1 + 16) == 1178881536)
      {
        if (a2)
        {
          *((void *)&v8 + sub_1808F7164((uint64_t)v14, 1) = 0LL;
          unint64_t v7 = off_189723AC8;
          *(void *)&__int128 v8 = *(void *)a2;
          DWORD2(v8) = *(_DWORD *)(a2 + 8);
          BOOL v3 = icu::FormattedValueStringBuilderImpl::nextFieldPosition( (icu::FormattedValueStringBuilderImpl *)(a1 + 48),  (icu::FieldPosition *)&v7,  a3) != 0;
          *(void *)(a2 + 4) = *(void *)((char *)&v8 + 4);
          icu::FieldPosition::~FieldPosition((icu::FieldPosition *)&v7);
          return v3;
        }

        BOOL v3 = 0LL;
        int v5 = 1;
LABEL_10:
        *a3 = v5;
        return v3;
      }

      int v5 = 3;
    }

    else
    {
      int v5 = 1;
    }

    BOOL v3 = 0LL;
    goto LABEL_10;
  }

  return 0LL;
}

void unumf_resultGetAllFieldPositions(uint64_t a1, icu::FieldPositionIterator *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (a1)
    {
      if (*(_DWORD *)(a1 + 16) != 1178881536)
      {
        int v5 = 3;
        goto LABEL_8;
      }

      if (a2)
      {
        uint64_t v7 = 0LL;
        memset(v6, 0, sizeof(v6));
        icu::FieldPositionIteratorHandler::FieldPositionIteratorHandler((icu::FieldPositionIteratorHandler *)v6, a2, a3);
        icu::FormattedValueStringBuilderImpl::getAllFieldPositions( (icu::FormattedValueStringBuilderImpl *)(a1 + 48),  (icu::FieldPositionIteratorHandler *)v6,  a3);
        icu::FieldPositionIteratorHandler::~FieldPositionIteratorHandler((icu::FieldPositionIteratorHandler *)v6);
        return;
      }
    }

    int v5 = 1;
LABEL_8:
    *a3 = v5;
  }

uint64_t unumf_resultToDecimalNumber(uint64_t a1, char *a2, int a3, UErrorCode *a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    int v10 = 1;
LABEL_11:
    uint64_t v4 = 0LL;
    *a4 = v10;
    return v4;
  }

  if (*(_DWORD *)(a1 + 16) != 1178881536)
  {
    int v10 = 3;
    goto LABEL_11;
  }

  memset(v14, 0, sizeof(v14));
  icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v14);
  int v9 = icu::number::impl::DecimalQuantity::toDecNum( (icu::number::impl::DecimalQuantity *)(a1 + 352),  (icu::number::impl::DecNum *)v14,  a4);
  memset(&v13[1], 0, 56);
  v12[1] = 0LL;
  v13[0] = (char *)&v13[1] + 5;
  LODWORD(v13[1]) = 40;
  v12[0] = 0LL;
  icu::CharStringByteSink::CharStringByteSink(v12, (uint64_t)v13);
  icu::number::impl::DecNum::toString(v9, (icu::ByteSink *)v12, a4);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v12);
  uint64_t v4 = icu::CharString::extract(v13, a2, a3, a4);
  if (BYTE4(v13[1])) {
    uprv_free(v13[0]);
  }
  if (BYTE12(v14[0])) {
    uprv_free(*(void **)&v14[0]);
  }
  return v4;
}

void unumf_close(_DWORD *a1)
{
  if (a1)
  {
    if (*a1 == 1313231360)
    {
      icu::number::LocalizedNumberFormatter::~LocalizedNumberFormatter((icu::number::LocalizedNumberFormatter *)(a1 + 2));
      *a1 = 0;
      icu::UMemory::operator delete(a1);
    }
  }

uint64_t *usnum_openForInt64@<X0>(void **a1@<X0>, int *a2@<X1>, uint64_t *a3@<X8>)
{
  int v5 = icu::UMemory::operator new(a3, (icu::UMemory *)0x18, (unint64_t)a2);
  int v6 = v5;
  if (v5)
  {
    *int v5 = 0LL;
    v5[2] = 0LL;
    v5[1] = 0LL;
    uint64_t v7 = v5 + 1;
    *(_DWORD *)int v5 = 1397640448;
    *((_DWORD *)v5 + 4) = 1;
    icu::number::SimpleNumber::forInt64(a1, a2, &v9);
    icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)(v6 + 1));
    void *v7 = v9;
    *((_DWORD *)v6 + 4) = v10;
    int v9 = 0LL;
    icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)&v9);
  }

  else
  {
    *a2 = 7;
  }

  return v6;
}

_DWORD *usnum_setToInt64(_DWORD *result, void **this, int *a3)
{
  if (*a3 <= 0)
  {
    BOOL v3 = result;
    if (result)
    {
      if (*result == 1397640448)
      {
        icu::number::SimpleNumber::forInt64(this, a3, &v5);
        icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)(v3 + 2));
        *((void *)v3 + sub_1808F7164((uint64_t)v14, 1) = v5;
        v3[4] = v6;
        int v5 = 0LL;
        return (_DWORD *)icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)&v5);
      }

      int v4 = 3;
    }

    else
    {
      int v4 = 1;
    }

    *a3 = v4;
  }

  return result;
}

_DWORD *usnum_multiplyByPowerOfTen(_DWORD *result, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (result)
    {
      if (*result == 1397640448) {
        return (_DWORD *)icu::number::SimpleNumber::multiplyByPowerOfTen((BOOL)(result + 2), a2, a3);
      }
      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

  return result;
}

void usnum_roundTo(uint64_t a1, int a2, unsigned int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a1)
    {
      if (*(_DWORD *)a1 == 1397640448)
      {
        icu::number::SimpleNumber::roundTo((void *)(a1 + 8), a2, a3, a4);
        return;
      }

      int v4 = 3;
    }

    else
    {
      int v4 = 1;
    }

    *a4 = v4;
  }

void *usnum_setMinimumIntegerDigits(void *result, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (result)
    {
      if (*(_DWORD *)result == 1397640448) {
        return icu::number::SimpleNumber::setMinimumIntegerDigits(result + 1, a2, a3);
      }
      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

  return result;
}

void *usnum_setMinimumFractionDigits(void *result, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (result)
    {
      if (*(_DWORD *)result == 1397640448) {
        return icu::number::SimpleNumber::setMinimumFractionDigits(result + 1, a2, a3);
      }
      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

  return result;
}

void usnum_truncateStart(_DWORD *a1, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (a1)
    {
      if (*a1 == 1397640448)
      {
        icu::number::SimpleNumber::truncateStart((icu::number::SimpleNumber *)(a1 + 2), a2, a3);
        return;
      }

      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

_DWORD *usnum_setSign(_DWORD *result, int a2, int *a3)
{
  if (*a3 <= 0)
  {
    if (result)
    {
      if (*result == 1397640448) {
        return (_DWORD *)icu::number::SimpleNumber::setSign((uint64_t)(result + 2), a2, a3);
      }
      int v3 = 3;
    }

    else
    {
      int v3 = 1;
    }

    *a3 = v3;
  }

  return result;
}

uint64_t *usnumf_openForLocale(const char *a1, UErrorCode *a2)
{
  uint64_t v14 = (uint64_t *)*MEMORY[0x1895F89C0];
  int v4 = icu::UMemory::operator new(v14, (icu::UMemory *)0x28, (unint64_t)a2);
  int v5 = v4;
  if (v4)
  {
    *int v4 = 0LL;
    v4[1] = 0LL;
    int v6 = v4 + 1;
    *(_DWORD *)int v4 = 1397638656;
    *((_DWORD *)v4 + 2) = 2;
    v4[3] = 0LL;
    _OWORD v4[4] = 0LL;
    void v4[2] = 0LL;
    icu::Locale::Locale((uint64_t *)2, (icu::Locale *)v13, a1, 0LL, 0LL, 0LL);
    icu::number::SimpleNumberFormatter::forLocale((icu::number::SimpleNumberFormatter *)v13, a2, &v10);
    icu::number::SimpleNumberFormatter::cleanup((icu::number::SimpleNumberFormatter *)(v5 + 1), v7);
    *int v6 = v10;
    *((_OWORD *)v5 + sub_1808F7164((uint64_t)v14, 1) = v11;
    __int128 v8 = v12;
    v5[4] = (uint64_t)v12;
    __int128 v11 = 0uLL;
    int v12 = 0LL;
    icu::number::SimpleNumberFormatter::cleanup((icu::number::SimpleNumberFormatter *)&v10, v8);
    icu::Locale::~Locale((icu::Locale *)v13);
  }

  else
  {
    *a2 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v5;
}

uint64_t *usnumf_openForLocaleAndGroupingStrategy(const char *a1, unint64_t a2, UErrorCode *a3)
{
  __int128 v16 = (uint64_t *)*MEMORY[0x1895F89C0];
  int v6 = icu::UMemory::operator new(v16, (icu::UMemory *)0x28, a2);
  uint64_t v7 = v6;
  if (v6)
  {
    *int v6 = 0LL;
    v6[1] = 0LL;
    __int128 v8 = v6 + 1;
    *(_DWORD *)int v6 = 1397638656;
    *((_DWORD *)v6 + 2) = 2;
    void v6[3] = 0LL;
    v6[4] = 0LL;
    _OWORD v6[2] = 0LL;
    icu::Locale::Locale((uint64_t *)2, (icu::Locale *)v15, a1, 0LL, 0LL, 0LL);
    icu::number::SimpleNumberFormatter::forLocaleAndGroupingStrategy((const icu::Locale *)v15, a2, a3, &v12);
    icu::number::SimpleNumberFormatter::cleanup((icu::number::SimpleNumberFormatter *)(v7 + 1), v9);
    *__int128 v8 = v12;
    *((_OWORD *)v7 + sub_1808F7164((uint64_t)v14, 1) = v13;
    uint64_t v10 = v14;
    _OWORD v7[4] = (uint64_t)v14;
    __int128 v13 = 0uLL;
    uint64_t v14 = 0LL;
    icu::number::SimpleNumberFormatter::cleanup((icu::number::SimpleNumberFormatter *)&v12, v10);
    icu::Locale::~Locale((icu::Locale *)v15);
  }

  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v7;
}

void usnumf_format(_DWORD *a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*a1 != 1397638656) {
    goto LABEL_12;
  }
  if (!a2)
  {
LABEL_11:
    int v6 = 1;
LABEL_13:
    *a4 = v6;
    return;
  }

  if (*(_DWORD *)a2 != 1397640448)
  {
LABEL_12:
    int v6 = 3;
    goto LABEL_13;
  }

  if (!a3) {
    goto LABEL_11;
  }
  if (*(_DWORD *)(a3 + 16) != 1178881536) {
    goto LABEL_12;
  }
  memset(v10, 0, sizeof(v10));
  uint64_t v8 = *(void *)(a2 + 8);
  int v9 = *(_DWORD *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  icu::number::SimpleNumberFormatter::format((uint64_t)(a1 + 2), (uint64_t)&v8, a4, (uint64_t)v10);
  icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)&v8);
  if (*(int *)a4 <= 0)
  {
    icu::number::FormattedNumber::FormattedNumber((uint64_t)v7, (uint64_t)v10);
    sub_18091C6C4(a3 + 48, v7[1]);
    icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)v7);
  }

  icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)v10);
}

void usnumf_formatInt64(_DWORD *a1, void **a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a1)
    {
      if (*a1 != 1397638656)
      {
LABEL_8:
        int v5 = 3;
        goto LABEL_9;
      }

      if (a3)
      {
        if (*(_DWORD *)(a3 + 16) == 1178881536)
        {
          memset(v7, 0, sizeof(v7));
          sub_18091D968(a2, (uint64_t)(a1 + 2), a4, (uint64_t)v7);
          icu::number::FormattedNumber::FormattedNumber((uint64_t)v6, (uint64_t)v7);
          sub_18091C6C4(a3 + 48, v6[1]);
          icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)v6);
          icu::number::FormattedNumber::~FormattedNumber((icu::number::FormattedNumber *)v7);
          return;
        }

        goto LABEL_8;
      }
    }

    int v5 = 1;
LABEL_9:
    *a4 = v5;
  }

uint64_t sub_18091D968@<X0>(void **this@<X1>, uint64_t a2@<X0>, int *a3@<X2>, uint64_t a4@<X8>)
{
  return icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)v8);
}

void usnum_close(_DWORD *a1)
{
  if (a1)
  {
    if (*a1 == 1397640448)
    {
      icu::number::SimpleNumber::cleanup((icu::number::SimpleNumber *)(a1 + 2));
      *a1 = 0;
      icu::UMemory::operator delete(a1);
    }
  }

void usnumf_close(unsigned int *a1)
{
  if (a1)
  {
    int v2 = (void *)*a1;
    if ((_DWORD)v2 == 1397638656)
    {
      icu::number::SimpleNumberFormatter::cleanup((icu::number::SimpleNumberFormatter *)(a1 + 2), v2);
      *a1 = 0;
      icu::UMemory::operator delete(a1);
    }
  }

uint64_t sub_18091DA68(uint64_t a1, uint64_t a2)
{
  icu::FormattedStringBuilder::operator=(a1 + 8, a2 + 8);
  *(_BYTE *)(a1 + 144) = *(_BYTE *)(a2 + 144);
  if (*(_BYTE *)(a1 + 164)) {
    uprv_free(*(void **)(a1 + 152));
  }
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_BYTE *)(a1 + 164) = *(_BYTE *)(a2 + 164);
  int v4 = *(const void **)(a2 + 152);
  if (v4 == (const void *)(a2 + 168))
  {
    *(void *)(a1 + 152) = a1 + 168;
    memcpy((void *)(a1 + 168), v4, 16LL * *(int *)(a2 + 160));
  }

  else
  {
    *(void *)(a1 + 152) = v4;
    *(void *)(a2 + 152) = a2 + 168;
    *(_DWORD *)(a2 + 160) = 8;
    *(_BYTE *)(a2 + 164) = 0;
  }

  *(_DWORD *)(a1 + 296) = *(_DWORD *)(a2 + 296);
  return a1;
}

void sub_18091DB04(uint64_t a1, uint64_t a2, const char *a3, int a4, int a5, int *a6)
{
  _BYTE v16[8] = *(void **)MEMORY[0x1895F89C0];
  v15[0] = &off_1897274D8;
  v15[1] = a1;
  uint64_t v11 = ures_open(0LL, *(char **)(a2 + 40), a6);
  if (*a6 <= 0)
  {
    int v12 = strcmp(a3, "latn");
    memset(&v16[1], 0, 56);
    v16[0] = (char *)&v16[1] + 5;
    LODWORD(v16[1]) = 40;
    sub_18091DD08(a3, a4, a5, (icu::CharString *)v16, (UErrorCode *)a6);
    int v14 = 0;
    ures_getAllItemsWithFallback(v11, (char *)v16[0], (uint64_t)v15, &v14);
    int v13 = *(unsigned __int8 *)(a1 + 1374);
    if (*(_BYTE *)(a1 + 1374) && v12)
    {
      sub_18091DD08("latn", a4, a5, (icu::CharString *)v16, (UErrorCode *)a6);
      int v14 = 0;
      ures_getAllItemsWithFallback(v11, (char *)v16[0], (uint64_t)v15, &v14);
      int v13 = *(unsigned __int8 *)(a1 + 1374);
    }

    if (a4 && v13)
    {
      sub_18091DD08(a3, 0, a5, (icu::CharString *)v16, (UErrorCode *)a6);
      int v14 = 0;
      ures_getAllItemsWithFallback(v11, (char *)v16[0], (uint64_t)v15, &v14);
      int v13 = *(unsigned __int8 *)(a1 + 1374);
    }

    if (a4 && v13 && v12)
    {
      sub_18091DD08("latn", 0, a5, (icu::CharString *)v16, (UErrorCode *)a6);
      int v14 = 0;
      ures_getAllItemsWithFallback(v11, (char *)v16[0], (uint64_t)v15, &v14);
      int v13 = *(unsigned __int8 *)(a1 + 1374);
    }

    if (v13) {
      *a6 = 5;
    }
    if (BYTE4(v16[1])) {
      uprv_free(v16[0]);
    }
  }

  if (v11) {
    ures_close(v11);
  }
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v15);
}

icu::CharString *sub_18091DD08(const char *a1, int a2, int a3, icu::CharString *a4, UErrorCode *a5)
{
  *((_DWORD *)a4 + 14) = 0;
  **(_BYTE **)a4 = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v19, "NumberElements/");
  icu::CharString::append(a4, v19, v20, a5);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v17, a1);
  icu::CharString::append(a4, v17, v18, a5);
  if (a2) {
    uint64_t v10 = "/patternsLong";
  }
  else {
    uint64_t v10 = "/patternsShort";
  }
  icu::StringPiece::StringPiece((icu::StringPiece *)&v15, v10);
  icu::CharString::append(a4, v15, v16, a5);
  if (a3) {
    uint64_t v11 = "/currencyFormat";
  }
  else {
    uint64_t v11 = "/decimalFormat";
  }
  icu::StringPiece::StringPiece((icu::StringPiece *)&v13, v11);
  return icu::CharString::append(a4, v13, v14, a5);
}

uint64_t sub_18091DE08(uint64_t a1, int a2)
{
  if (a2 < 0) {
    return 0LL;
  }
  int v2 = *(char *)(a1 + 1373);
  if (v2 >= a2) {
    int v2 = a2;
  }
  return *(char *)(a1 + v2 + 1352);
}

__int16 *sub_18091DE2C(uint64_t a1, int a2, icu::PluralRules *a3, icu::number::impl::DecimalQuantity *a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a2 < 0) {
    return 0LL;
  }
  else {
    int v7 = *(char *)(a1 + 1373);
  }
  if ((*(unsigned int (**)(icu::number::impl::DecimalQuantity *))(*(void *)a4 + 40LL))(a4))
  {
    uint64_t v8 = icu::number::impl::DecimalQuantity::toLong(a4, 1);
    if (!v8)
    {
      int v9 = 6;
LABEL_11:
      uint64_t result = *(__int16 **)(a1 + 8LL * (v9 | (8 * v7)) + 8);
      if (result) {
        return result;
      }
      goto LABEL_12;
    }

    if (v8 == 1)
    {
      int v9 = 7;
      goto LABEL_11;
    }
  }

uint64_t sub_18091DF6C(uint64_t result, icu::UVector *this, UErrorCode *a3)
{
  int v5 = (UChar **)(result + 8);
  int v6 = (UChar **)(result + 1352);
  do
  {
    int v7 = *v5;
    if (*v5) {
      BOOL v8 = v7 == (UChar *)L"<USE FALLBACK>";
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      signed int v9 = *((_DWORD *)this + 2);
      while (1)
      {
        BOOL v10 = __OFSUB__(v9--, 1);
        if (v9 < 0 != v10) {
          break;
        }
        int v11 = (const UChar *)icu::UVector::elementAt(this, v9);
        uint64_t result = u_strcmp(v7, v11);
        if (!(_DWORD)result) {
          goto LABEL_11;
        }
      }

      uint64_t result = icu::UVector::addElement(this, v7, a3);
    }

const UChar *sub_18091E008(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, char *a5)
{
  unint64_t v27 = a2;
  uint64_t v26 = 0LL;
  memset(v25, 0, sizeof(v25));
  uint64_t result = (const UChar *)(*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, char *))(*(void *)a3 + 88LL))( v25,  a3,  a5);
  uint64_t result = (const UChar *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v25, 0, (const char **)&v27, a3);
  if (!(_DWORD)result) {
    return result;
  }
  int v9 = 0;
  while (1)
  {
    int v10 = (char)(strlen(v27) - 1);
    if (v10 <= 19) {
      break;
    }
LABEL_29:
    uint64_t result = (const UChar *)icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v25, ++v9, (const char **)&v27, a3);
    if (!(_DWORD)result) {
      return result;
    }
  }

  int v11 = *(unsigned __int8 *)(*(void *)(a1 + 8) + v10 + 1352LL);
  uint64_t v24 = 0LL;
  memset(v23, 0, sizeof(v23));
  uint64_t result = (const UChar *)(*(void *(**)(_OWORD *__return_ptr, icu::ResourceValue *, char *))(*(void *)a3 + 88LL))( v23,  a3,  a5);
  if (!icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v23, 0, (const char **)&v27, a3))
  {
LABEL_25:
    uint64_t v20 = *(void *)(a1 + 8) + v10;
    if (!*(_BYTE *)(v20 + 1352))
    {
      *(_BYTE *)(v20 + 1352) = v11;
      uint64_t v21 = *(void *)(a1 + 8);
      *(_BYTE *)(v21 + 1374) = 0;
    }

    goto LABEL_29;
  }

  int v13 = 0;
  int v14 = 8 * v10;
  while (1)
  {
    uint64_t result = (const UChar *)icu::StandardPlural::indexFromString((icu::StandardPlural *)v27, a5, v12);
    int v15 = (_DWORD)result + v14;
    if (!*(void *)(*(void *)(a1 + 8) + 8LL * ((int)result + v14) + 8))
    {
      int v22 = 0;
      uint64_t result = (const UChar *)(*(uint64_t (**)(icu::ResourceValue *, int *, char *))(*(void *)a3 + 32LL))( a3,  &v22,  a5);
      int v16 = (const __int16 *)result;
      if (!u_strcmp(result, (const UChar *)"0"))
      {
        int v22 = 0;
        int v16 = L"<USE FALLBACK>";
      }

      *(void *)(*(void *)(a1 + 8) + 8LL * v15 + 8) = v16;
      if (!v11)
      {
        uint64_t v17 = v22;
        if (v22 < 1)
        {
LABEL_23:
          int v11 = 0;
        }

        else
        {
          int v18 = 0;
          do
          {
            int v19 = *(unsigned __int16 *)v16++;
            if (v19 == 48)
            {
              ++v18;
            }

            else if (v18 > 0)
            {
              goto LABEL_22;
            }

            --v17;
          }

          while (v17);
          if (v18 < 1) {
            goto LABEL_23;
          }
LABEL_22:
          int v11 = (v18 + ~(_BYTE)v10);
        }
      }
    }
  }

uint64_t sub_18091E268( uint64_t a1, int a2, uint64_t a3, const char *a4, int a5, uint64_t a6, icu::number::impl::MutablePatternModifier *a7, int a8, uint64_t a9, int *a10)
{
  *(void *)a1 = off_1897274B0;
  *(void *)(a1 + 8) = a6;
  *(void *)(a1 + 16) = a9;
  *(void *)(a1 + 24) = a1 + 40;
  *(_DWORD *)(a1 + 32) = 12;
  *(_BYTE *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = &off_189727488;
  uint64_t v17 = a1 + 240;
  bzero((void *)(a1 + 248), 0x556uLL);
  *(_BYTE *)(a1 + 1614) = 1;
  sub_18091E880(a1 + 1616);
  *(_BYTE *)(a1 + 2064) = a8;
  sub_18091DB04(v17, a3, a4, a2, a5, a10);
  if (a8) {
    sub_18091E350(a1, a7, (UErrorCode *)a10);
  }
  else {
    *(void *)(a1 + 2056) = a7;
  }
  return a1;
}

void sub_18091E350(uint64_t a1, icu::number::impl::MutablePatternModifier *a2, UErrorCode *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    uint64_t v19 = 0LL;
    memset(v18, 0, sizeof(v18));
    icu::UVector::UVector((icu::UVector *)v18, 0xCu, a3);
    if (*(int *)a3 > 0 || (sub_18091DF6C(a1 + 240, (icu::UVector *)v18, a3), *(int *)a3 > 0))
    {
LABEL_4:
      icu::UVector::~UVector((icu::UVector *)v18);
      return;
    }

    uint64_t v6 = DWORD2(v18[0]);
    *(_DWORD *)(a1 + 232) = DWORD2(v18[0]);
    if (*(_DWORD *)(a1 + 32) < (int)v6)
    {
      if ((int)v6 >= 1)
      {
        int v7 = uprv_malloc(16 * v6);
        if (v7)
        {
          BOOL v8 = v7;
          if (*(_BYTE *)(a1 + 36)) {
            uprv_free(*(void **)(a1 + 24));
          }
          *(void *)(a1 + 24) = v8;
          *(_DWORD *)(a1 + 32) = v6;
          *(_BYTE *)(a1 + 36) = 1;
        }
      }

      LODWORD(v6) = *(_DWORD *)(a1 + 232);
    }

    if ((int)v6 >= 1)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = icu::UVector::elementAt((icu::UVector *)v18, v10);
        memset(v23, 0, sizeof(v23));
        icu::UnicodeString::UnicodeString((uint64_t)v23, v11);
        uint64_t v12 = *(void *)(a1 + 24);
        uint64_t v22 = 0LL;
        memset(v21, 0, sizeof(v21));
        sub_18091E880((uint64_t)v21);
        icu::UnicodeString::UnicodeString((uint64_t)v20, v11);
        icu::number::impl::PatternParser::parseToPatternInfo(v20, (const icu::UnicodeString *)v21, a3, v13);
        icu::UnicodeString::~UnicodeString(v14, (icu::UnicodeString *)v20);
        icu::number::impl::MutablePatternModifier::setPatternInfo((uint64_t)a2, (uint64_t)v21, 44);
        *(void *)(v12 + v9) = icu::number::impl::MutablePatternModifier::createImmutable(a2, a3, v15);
        *(void *)(v12 + v9 + 8) = v11;
        sub_18091E95C((void **)v21);
        icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v23);
        ++v10;
        v9 += 16LL;
      }

      sub_18091E95C((void **)v21);
      icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v23);
    }

    goto LABEL_4;
  }

uint64_t sub_18091E594( uint64_t a1, int a2, uint64_t a3, const char *a4, int a5, uint64_t a6, icu::number::impl::MutablePatternModifier *a7, int a8, uint64_t a9, int *a10)
{
  return sub_18091E268(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t sub_18091E5A0(uint64_t a1)
{
  *(void *)a1 = off_1897274B0;
  int v2 = *(_DWORD *)(a1 + 232);
  if (v2 >= 1)
  {
    uint64_t v3 = 0LL;
    for (uint64_t i = 0LL; i < v2; ++i)
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 24) + v3);
      if (v5)
      {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
        int v2 = *(_DWORD *)(a1 + 232);
      }

      v3 += 16LL;
    }
  }

  sub_18091E95C((void **)(a1 + 1616));
  nullsub_17(a1 + 240);
  if (*(_BYTE *)(a1 + 36)) {
    uprv_free(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_18091E63C(uint64_t a1)
{
  int v1 = (void *)sub_18091E5A0(a1);
  icu::UMemory::operator delete(v1);
}

double sub_18091E650(uint64_t a1, icu::number::impl::DecimalQuantity *a2, uint64_t a3, int *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  (*(void (**)(void))(**(void **)(a1 + 16) + 16LL))(*(void *)(a1 + 16));
  if (*a4 <= 0)
  {
    if (icu::number::impl::DecimalQuantity::isZeroish(a2))
    {
      sub_180938418(a3 + 104, a2, a4);
      int v9 = 0;
      int v10 = 0;
    }

    else
    {
      int v9 = sub_180938334(a3 + 104, a2, a1 + 240, a4);
      if (icu::number::impl::DecimalQuantity::isZeroish(a2)) {
        int Magnitude = 0;
      }
      else {
        int Magnitude = icu::number::impl::DecimalQuantity::getMagnitude(a2);
      }
      int v10 = Magnitude - v9;
    }

    uint64_t v12 = sub_18091DE2C(a1 + 240, v10, *(icu::PluralRules **)(a1 + 8), a2);
    if (v12)
    {
      int v13 = (const UChar *)v12;
      if (*(_BYTE *)(a1 + 2064))
      {
        if (*(int *)(a1 + 232) >= 1)
        {
          uint64_t v14 = 0LL;
          uint64_t v15 = 0LL;
          while (1)
          {
            uint64_t v16 = *(void *)(a1 + 24);
            if (!u_strcmp(v13, *(const UChar **)(v16 + v14 + 8))) {
              break;
            }
            ++v15;
            v14 += 16LL;
          }

          icu::number::impl::ImmutablePatternModifier::applyToMicros(*(void *)(v16 + v14), a3, a2, a4);
        }
      }

      else
      {
        icu::UnicodeString::UnicodeString((uint64_t)&v24, (uint64_t)v12);
        icu::number::impl::PatternParser::parseToPatternInfo( (UChar **)&v24,  (const icu::UnicodeString *)(a1 + 1616),  (UErrorCode *)a4,  v17);
        icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v24);
        icu::number::impl::MutablePatternModifier::setPatternInfo(*(void *)(a1 + 2056), a1 + 1616, 44);
        uint64_t v19 = *(void *)(a1 + 2056);
        int v20 = icu::number::impl::DecimalQuantity::signum(a2);
        icu::number::impl::MutablePatternModifier::setNumberProperties(v19, v20, 8);
        uint64_t v21 = *(void *)(a1 + 2056);
        if (v21) {
          uint64_t v22 = v21 + 8;
        }
        else {
          uint64_t v22 = 0LL;
        }
        *(void *)(a3 + 200) = v22;
      }
    }

void sub_18091E858(icu::ResourceSink *a1)
{
}

void sub_18091E86C(uint64_t a1)
{
  int v1 = (void *)nullsub_17(a1);
  operator delete(v1);
}

uint64_t sub_18091E880(uint64_t a1)
{
  *(void *)a1 = &unk_189728270;
  *(void *)(a1 + 8) = off_18971B688;
  uint64_t v2 = a1 + 8;
  *(_WORD *)(a1 + 16) = 2;
  *(void *)(a1 + 72) = 0xFFFFFFFF0000LL;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_BYTE *)(a1 + 112) = 0;
  icu::number::impl::DecimalQuantity::DecimalQuantity((icu::number::impl::DecimalQuantity *)(a1 + 128));
  *(_BYTE *)(a1 + 200) = 0;
  *(void *)(a1 + 204) = 0LL;
  *(_WORD *)(a1 + 212) = 0;
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(void *)(a1 + 216) = 0LL;
  *(void *)(a1 + 240) = 0xFFFFFFFF0000LL;
  *(_DWORD *)(a1 + 284) = 0;
  *(_BYTE *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_BYTE *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  icu::number::impl::DecimalQuantity::DecimalQuantity((icu::number::impl::DecimalQuantity *)(a1 + 296));
  *(_BYTE *)(a1 + 368) = 0;
  *(void *)(a1 + 372) = 0LL;
  *(_WORD *)(a1 + 380) = 0;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 400) = 0LL;
  *(void *)(a1 + 408) = v2;
  *(_DWORD *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0LL;
  *(_BYTE *)(a1 + 432) = 0;
  return a1;
}

void sub_18091E95C(void **a1)
{
  *a1 = &unk_189728270;
  uint64_t v2 = a1 + 16;
  icu::number::impl::DecimalQuantity::~DecimalQuantity(a1 + 37);
  icu::number::impl::DecimalQuantity::~DecimalQuantity(v2);
  icu::UnicodeString::~UnicodeString(v3, (icu::UnicodeString *)(a1 + 1));
  icu::number::impl::AffixPatternProvider::~AffixPatternProvider((icu::number::impl::AffixPatternProvider *)a1);
}

uint64_t icu::number::impl::CurrencySymbols::CurrencySymbols( uint64_t a1, const UChar *a2, uint64_t a3, UErrorCode *a4)
{
  int v7 = v10;
  int v8 = v11;
  *(void *)(a1 + 40) = a1 + 53;
  *(_DWORD *)(a1 + 48) = 40;
  *(_WORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  icu::CharString::append((icu::CharString *)(a1 + 40), v7, v8, a4);
  *(void *)(a1 + 104) = off_18971B688;
  *(_WORD *)(a1 + 112) = 2;
  *(void *)(a1 + 168) = off_18971B688;
  *(_WORD *)(a1 + 176) = 2;
  icu::UnicodeString::setToBogus((icu::UnicodeString *)(a1 + 104));
  icu::UnicodeString::setToBogus((icu::UnicodeString *)(a1 + 168));
  return a1;
}

uint64_t icu::number::impl::CurrencySymbols::CurrencySymbols( uint64_t a1, const UChar *a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  if (*(_BYTE *)(a4 + 2872)) {
    icu::UnicodeString::operator=((UChar **)(a1 + 104), (UChar **)(a4 + 520));
  }
  if (*(_BYTE *)(a4 + 2873)) {
    icu::UnicodeString::operator=((UChar **)(a1 + 168), (UChar **)(a4 + 584));
  }
  return a1;
}

{
  UChar v10[16];
  icu::CurrencyUnit::CurrencyUnit((icu::CurrencyUnit *)v10, a2);
  icu::number::impl::CurrencySymbols::CurrencySymbols(a1, v10, a3, a5);
  icu::CurrencyUnit::~CurrencyUnit((icu::CurrencyUnit *)v10);
  if (*(_BYTE *)(a4 + 2872)) {
    icu::UnicodeString::operator=((UChar **)(a1 + 104), (UChar **)(a4 + 520));
  }
  if (*(_BYTE *)(a4 + 2873)) {
    icu::UnicodeString::operator=((UChar **)(a1 + 168), (UChar **)(a4 + 584));
  }
  return a1;
}

uint64_t icu::number::impl::CurrencySymbols::getIsoCode(icu::number::impl::CurrencySymbols *this)
{
  return (uint64_t)this + 28;
}

uint64_t icu::number::impl::CurrencySymbols::getNarrowCurrencySymbol@<X0>( icu::number::impl::CurrencySymbols *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  return icu::number::impl::CurrencySymbols::loadSymbol((uint64_t)this, 2u, (int *)a2, a3);
}

uint64_t icu::number::impl::CurrencySymbols::loadSymbol@<X0>( uint64_t a1@<X0>, unsigned int a2@<W1>, int *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a1 + 28;
  int v9 = 0;
  Name = ucurr_getName((const UChar *)(a1 + 28), *(char **)(a1 + 40), a2, 0LL, &v9, a3);
  if (Name == (const UChar *)v5) {
    return icu::UnicodeString::UnicodeString(a4, v5, 3LL);
  }
  int v8 = Name;
  return icu::UnicodeString::UnicodeString(a4, 1LL, &v8);
}

uint64_t icu::number::impl::CurrencySymbols::getFormalCurrencySymbol@<X0>( icu::number::impl::CurrencySymbols *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  return icu::number::impl::CurrencySymbols::loadSymbol((uint64_t)this, 3u, (int *)a2, a3);
}

uint64_t icu::number::impl::CurrencySymbols::getVariantCurrencySymbol@<X0>( icu::number::impl::CurrencySymbols *this@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  return icu::number::impl::CurrencySymbols::loadSymbol((uint64_t)this, 4u, (int *)a2, a3);
}

icu::UnicodeString *icu::number::impl::CurrencySymbols::getCurrencySymbol@<X0>( UChar **this@<X0>, UErrorCode *a2@<X1>, icu::UnicodeString *a3@<X8>)
{
  if (((_WORD)this[14] & 1) != 0) {
    return (icu::UnicodeString *)icu::number::impl::CurrencySymbols::loadSymbol( (uint64_t)this,  0,  (int *)a2,  (uint64_t)a3);
  }
  else {
    return icu::UnicodeString::UnicodeString(a3, this + 13);
  }
}

icu::UnicodeString *icu::number::impl::CurrencySymbols::getIntlCurrencySymbol@<X0>( UChar **this@<X0>, icu::UnicodeString *a2@<X8>)
{
  if (((_WORD)this[22] & 1) != 0) {
    return (icu::UnicodeString *)icu::UnicodeString::UnicodeString((uint64_t)a2, (uint64_t)this + 28, 3LL);
  }
  else {
    return icu::UnicodeString::UnicodeString(a2, this + 21);
  }
}

uint64_t icu::number::impl::CurrencySymbols::getPluralName@<X0>( uint64_t a1@<X0>, int a2@<W1>, int *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = (const UChar *)(a1 + 28);
  int v12 = 0;
  int v7 = *(char **)(a1 + 40);
  int Keyword = icu::StandardPlural::getKeyword(a2);
  PluralName = ucurr_getPluralName(v6, v7, 0LL, Keyword, &v12, a3);
  if (PluralName == v6) {
    return icu::UnicodeString::UnicodeString(a4, (uint64_t)v6, 3LL);
  }
  int v11 = PluralName;
  return icu::UnicodeString::UnicodeString(a4, 1LL, &v11);
}

BOOL icu::number::impl::CurrencySymbols::hasEmptyCurrencySymbol(icu::number::impl::CurrencySymbols *this)
{
  return (*((_WORD *)this + 56) & 0xFFE1) == 0;
}

icu::CurrencyUnit *sub_18091ED14@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, icu::CurrencyUnit *a4@<X8>)
{
  v9[1] = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(a1 + 8)) {
    return icu::CurrencyUnit::CurrencyUnit(a4, (const UChar *)(a1 + 16));
  }
  int v8 = 0;
  v9[0] = 0LL;
  ucurr_forLocale(*(char **)(a2 + 40), (UChar *)v9, 4LL, &v8);
  if (v8 > 0) {
    return (icu::CurrencyUnit *)icu::CurrencyUnit::CurrencyUnit(a4);
  }
  int v7 = v9;
  return (icu::CurrencyUnit *)icu::CurrencyUnit::CurrencyUnit(a4, &v7, a3);
}

icu::number::impl::DecimalQuantity *icu::number::impl::DecimalQuantity::DecimalQuantity( icu::number::impl::DecimalQuantity *this)
{
  *(void *)this = off_189727580;
  *((_BYTE *)this + 8) = 0;
  *((void *)this + 5) = 0LL;
  *((_DWORD *)this + 9) = 0;
  *((_WORD *)this + 32) = 0;
  icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
  *((_BYTE *)this + 20) = 0;
  return this;
}

{
  *(void *)this = off_189727580;
  *((_BYTE *)this + 8) = 0;
  *((void *)this + 5) = 0LL;
  *((_DWORD *)this + 9) = 0;
  *((_WORD *)this + 32) = 0;
  icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
  *((_BYTE *)this + 20) = 0;
  return this;
}

void icu::number::impl::DecimalQuantity::setBcdToZero(void **this)
{
  if (*((_BYTE *)this + 64))
  {
    uprv_free(this[6]);
    *((_BYTE *)this + 64) = 0;
  }

  this[6] = 0LL;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_BYTE *)this + 2sub_1808F7164((uint64_t)v14, 1) = 0;
  this[3] = 0LL;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 1sub_1808F7164((uint64_t)v14, 1) = 0;
}

void icu::number::impl::DecimalQuantity::~DecimalQuantity(void **this)
{
  *this = off_189727580;
  if (*((_BYTE *)this + 64))
  {
    uprv_free(this[6]);
    this[6] = 0LL;
    *((_BYTE *)this + 64) = 0;
  }

{
  *this = off_189727580;
  if (*((_BYTE *)this + 64))
  {
    uprv_free(this[6]);
    this[6] = 0LL;
    *((_BYTE *)this + 64) = 0;
  }

{
  *this = off_189727580;
  if (*((_BYTE *)this + 64))
  {
    uprv_free(this[6]);
    this[6] = 0LL;
    *((_BYTE *)this + 64) = 0;
  }

  icu::UMemory::operator delete(this);
}

icu::number::impl::DecimalQuantity *icu::number::impl::DecimalQuantity::DecimalQuantity( icu::number::impl::DecimalQuantity *this, uint64_t a2)
{
  *(void *)this = off_189727580;
  *((_BYTE *)this + 8) = 0;
  *((void *)this + 5) = 0LL;
  *((_DWORD *)this + 9) = 0;
  *((_WORD *)this + 32) = 0;
  return icu::number::impl::DecimalQuantity::operator=(this, a2);
}

{
  *(void *)this = off_189727580;
  *((_BYTE *)this + 8) = 0;
  *((void *)this + 5) = 0LL;
  *((_DWORD *)this + 9) = 0;
  *((_WORD *)this + 32) = 0;
  return icu::number::impl::DecimalQuantity::operator=(this, a2);
}

{
  *(void *)this = off_189727580;
  *((_BYTE *)this + 8) = 0;
  *((void *)this + 5) = 0LL;
  *((_DWORD *)this + 9) = 0;
  *((_WORD *)this + 32) = 0;
  return icu::number::impl::DecimalQuantity::operator=(this, a2);
}

{
  *(void *)this = off_189727580;
  *((_BYTE *)this + 8) = 0;
  *((void *)this + 5) = 0LL;
  *((_DWORD *)this + 9) = 0;
  *((_WORD *)this + 32) = 0;
  return icu::number::impl::DecimalQuantity::operator=(this, a2);
}

icu::number::impl::DecimalQuantity *icu::number::impl::DecimalQuantity::operator=( icu::number::impl::DecimalQuantity *this, uint64_t a2)
{
  if (this != (icu::number::impl::DecimalQuantity *)a2)
  {
    icu::number::impl::DecimalQuantity::copyBcdFrom((void **)this, (const icu::number::impl::DecimalQuantity *)a2);
    *((_BYTE *)this + 8) = *(_BYTE *)(a2 + 8);
    *(void *)((char *)this + 36) = *(void *)(a2 + 36);
    *(void *)((char *)this + 12) = *(void *)(a2 + 12);
    *((_WORD *)this + 10) = *(_WORD *)(a2 + 20);
    *((void *)this + 3) = *(void *)(a2 + 24);
    *((_DWORD *)this + 8) = *(_DWORD *)(a2 + 32);
    *((_DWORD *)this + 1sub_1808F7164((uint64_t)v14, 1) = *(_DWORD *)(a2 + 44);
  }

  return this;
}

{
  if (this != (icu::number::impl::DecimalQuantity *)a2)
  {
    icu::number::impl::DecimalQuantity::moveBcdFrom((void **)this, (icu::number::impl::DecimalQuantity *)a2);
    *((_BYTE *)this + 8) = *(_BYTE *)(a2 + 8);
    *(void *)((char *)this + 36) = *(void *)(a2 + 36);
    *(void *)((char *)this + 12) = *(void *)(a2 + 12);
    *((_WORD *)this + 10) = *(_WORD *)(a2 + 20);
    *((void *)this + 3) = *(void *)(a2 + 24);
    *((_DWORD *)this + 8) = *(_DWORD *)(a2 + 32);
    *((_DWORD *)this + 1sub_1808F7164((uint64_t)v14, 1) = *(_DWORD *)(a2 + 44);
  }

  return this;
}

void icu::number::impl::DecimalQuantity::copyBcdFrom( void **this, const icu::number::impl::DecimalQuantity *a2)
{
  if (*((_BYTE *)a2 + 64))
  {
    icu::number::impl::DecimalQuantity::ensureCapacity((icu::number::impl::DecimalQuantity *)this, *((_DWORD *)a2 + 4));
    memcpy(this[6], *((const void **)a2 + 6), *((int *)a2 + 4));
  }

  else
  {
    this[6] = (void *)*((void *)a2 + 6);
  }

double icu::number::impl::DecimalQuantity::copyFieldsFrom( icu::number::impl::DecimalQuantity *this, const icu::number::impl::DecimalQuantity *a2)
{
  *((_BYTE *)this + 8) = *((_BYTE *)a2 + 8);
  *(void *)((char *)this + 36) = *(void *)((char *)a2 + 36);
  *(void *)((char *)this + 12) = *(void *)((char *)a2 + 12);
  *((_WORD *)this + 10) = *((_WORD *)a2 + 10);
  double result = *((double *)a2 + 3);
  *((double *)this + 3) = result;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 1sub_1808F7164((uint64_t)v14, 1) = *((_DWORD *)a2 + 11);
  return result;
}

void icu::number::impl::DecimalQuantity::moveBcdFrom(void **this, icu::number::impl::DecimalQuantity *a2)
{
  if (*((_BYTE *)a2 + 64))
  {
    *((_BYTE *)this + 64) = 1;
    this[6] = (void *)*((void *)a2 + 6);
    *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
    *((void *)a2 + 6) = 0LL;
    *((_BYTE *)a2 + 64) = 0;
  }

  else
  {
    this[6] = (void *)*((void *)a2 + 6);
  }

void icu::number::impl::DecimalQuantity::clear(void **this)
{
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_BYTE *)this + 20) = 0;
  icu::number::impl::DecimalQuantity::setBcdToZero(this);
}

uint64_t icu::number::impl::DecimalQuantity::setMinInteger(uint64_t this, int a2)
{
  int v2 = *(_DWORD *)(this + 36);
  if (v2 <= a2) {
    int v2 = a2;
  }
  *(_DWORD *)(this + 36) = v2;
  return this;
}

uint64_t icu::number::impl::DecimalQuantity::setMinFraction(uint64_t this, int a2)
{
  *(_DWORD *)(this + 40) = -a2;
  return this;
}

void icu::number::impl::DecimalQuantity::applyMaxInteger(icu::number::impl::DecimalQuantity *this, int a2)
{
  int v2 = *((_DWORD *)this + 4);
  if (v2)
  {
    int v4 = *((_DWORD *)this + 3);
    if (v4 >= a2)
    {
      icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
    }

    else
    {
      int v5 = v2 + v4 - 1;
      BOOL v6 = __OFSUB__(v5, a2);
      int v7 = v5 - a2;
      if (v7 < 0 == v6)
      {
        icu::number::impl::DecimalQuantity::popFromLeft((uint64_t)this, v7 + 1);
        icu::number::impl::DecimalQuantity::compact(this);
      }
    }
  }

uint64_t icu::number::impl::DecimalQuantity::getMagnitude(icu::number::impl::DecimalQuantity *this)
{
  return (*((_DWORD *)this + 3) + *((_DWORD *)this + 4) - 1);
}

uint64_t icu::number::impl::DecimalQuantity::popFromLeft(uint64_t this, int a2)
{
  if (*(_BYTE *)(this + 64))
  {
    uint64_t v2 = *(int *)(this + 16);
    if (a2 <= 0)
    {
      LODWORD(v3) = v2 - a2;
    }

    else
    {
      do
      {
        *(_BYTE *)(*(void *)(this + 48) + v2 - sub_1808F7164((uint64_t)v14, 1) = 0;
        uint64_t v3 = *(int *)(this + 16) - (uint64_t)a2;
        --v2;
      }

      while (v2 > v3);
    }
  }

  else
  {
    LODWORD(v3) = *(_DWORD *)(this + 16) - a2;
    *(void *)(this + 48) &= ~(-1LL << (4 * (*(_BYTE *)(this + 16) - a2)));
  }

  *(_DWORD *)(this + 16) = v3;
  return this;
}

void icu::number::impl::DecimalQuantity::compact(icu::number::impl::DecimalQuantity *this)
{
  if (*((_BYTE *)this + 64))
  {
    uint64_t v2 = *((unsigned int *)this + 4);
    if ((int)v2 < 1)
    {
      LODWORD(v3) = 0;
    }

    else
    {
      uint64_t v3 = 0LL;
      while (!*(_BYTE *)(*((void *)this + 6) + v3))
      {
        if (v2 == ++v3) {
          goto LABEL_16;
        }
      }
    }

    if ((_DWORD)v3 == (_DWORD)v2) {
      goto LABEL_16;
    }
    icu::number::impl::DecimalQuantity::shiftRight((uint64_t)this, v3);
    uint64_t v7 = *((unsigned int *)this + 4);
    uint64_t v8 = v7 - 1;
    do
    {
      if ((int)v7 <= 0)
      {
        *((_DWORD *)this + 4) = v7;
        goto LABEL_23;
      }

      int v9 = *(unsigned __int8 *)(*((void *)this + 6) + v8);
      LODWORD(v7) = v7 - 1;
      --v8;
    }

    while (!v9);
    unsigned int v10 = v7 + 1;
    *((_DWORD *)this + 4) = v10;
    if (v10 > 0x10) {
      return;
    }
LABEL_23:
    icu::number::impl::DecimalQuantity::switchStorage(this);
  }

  else
  {
    unint64_t v4 = *((void *)this + 6);
    if (!v4)
    {
LABEL_16:
      icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
      return;
    }

    uint64_t v5 = *((unsigned int *)this + 4);
    if ((int)v5 < 1)
    {
      LODWORD(v6) = 0;
    }

    else
    {
      unint64_t v6 = 0LL;
      while (v6 > 0xF || ((v4 >> (4 * v6)) & 0xF) == 0)
      {
        if (++v6 == v5)
        {
          LODWORD(v6) = *((_DWORD *)this + 4);
          break;
        }
      }
    }

    unint64_t v11 = v4 >> (4 * v6);
    *((void *)this + 6) = v11;
    *((_DWORD *)this + 3) += v6;
    int v12 = v5 & ((int)v5 >> 31);
    uint64_t v13 = v5 - 1;
    uint64_t v14 = 4 * v5 - 4;
    while (1)
    {
      BOOL v15 = __OFSUB__((_DWORD)v5, 1);
      LODWORD(v5) = v5 - 1;
      char v16 = v14;
      v14 -= 4LL;
      uint64_t v17 = v13-- & 0xFFFFFFF0;
      if (!v17 && ((15LL << (v16 & 0xFC)) & v11) != 0)
      {
        int v12 = v5 + 1;
        break;
      }
    }

    *((_DWORD *)this + 4) = v12;
  }

unint64_t icu::number::impl::DecimalQuantity::getPositionFingerprint( icu::number::impl::DecimalQuantity *this)
{
  return (int)(*((_DWORD *)this + 9) << 16) ^ ((unint64_t)*((unsigned int *)this + 10) << 32);
}

void icu::number::impl::DecimalQuantity::roundToIncrement( icu::number::impl::DecimalQuantity *a1, unint64_t a2, int a3, unsigned int a4, UErrorCode *a5)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  int v9 = off_189727580;
  BYTE8(v13) = 0;
  *(void *)((char *)&v10 + 4) = 0LL;
  WORD6(v10) = 0;
  icu::number::impl::DecimalQuantity::setToLong((void **)&v9, a2);
  icu::number::impl::DecimalQuantity::adjustMagnitude((icu::number::impl::DecimalQuantity *)&v9, a3);
  memset(v14, 0, sizeof(v14));
  icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v14);
  icu::number::impl::DecimalQuantity::toDecNum( (icu::number::impl::DecimalQuantity *)&v9,  (icu::number::impl::DecNum *)v14,  a5);
  if (*(int *)a5 <= 0)
  {
    icu::number::impl::DecimalQuantity::divideBy(a1, (const icu::number::impl::DecNum *)v14, a5);
    if (*(int *)a5 <= 0)
    {
      icu::number::impl::DecimalQuantity::roundToMagnitude((uint64_t)a1, 0, a4, 0, (int *)a5);
    }
  }

  if (BYTE12(v14[0])) {
    uprv_free(*(void **)&v14[0]);
  }
  int v9 = off_189727580;
  if (BYTE8(v13)) {
    uprv_free(*((void **)&v12 + 1));
  }
}

void **icu::number::impl::DecimalQuantity::setToLong(void **this, unint64_t a2)
{
  *((_BYTE *)this + 20) = 0;
  if (a2 >= 0x8000000000000001LL)
  {
    *((_BYTE *)this + 20) = 1;
    a2 = -(uint64_t)a2;
LABEL_4:
    icu::number::impl::DecimalQuantity::_setToLong((icu::number::impl::DecimalQuantity *)this, a2);
    icu::number::impl::DecimalQuantity::compact((icu::number::impl::DecimalQuantity *)this);
    return this;
  }

  if (a2) {
    goto LABEL_4;
  }
  return this;
}

BOOL icu::number::impl::DecimalQuantity::adjustMagnitude(icu::number::impl::DecimalQuantity *this, int a2)
{
  if (!*((_DWORD *)this + 4)) {
    return 0LL;
  }
  BOOL v4 = uprv_add32_overflow(*((_DWORD *)this + 3), a2, (_DWORD *)this + 3);
  BOOL v5 = uprv_add32_overflow(*((_DWORD *)this + 8), a2, (_DWORD *)this + 8);
  int v7 = 0;
  return v5 || v4 || uprv_add32_overflow(*((_DWORD *)this + 3), *((_DWORD *)this + 4), &v7);
}

icu::number::impl::DecNum *icu::number::impl::DecimalQuantity::toDecNum( icu::number::impl::DecimalQuantity *this, icu::number::impl::DecNum *a2, UErrorCode *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  int v5 = *((_DWORD *)this + 4);
  if (v5)
  {
    uint64_t v15 = 0LL;
    *(_OWORD *)__int128 v13 = 0u;
    __int128 v14 = 0u;
    sub_1809211A0((uint64_t)v13, v5, *a3);
    if (*(int *)a3 <= 0)
    {
      LODWORD(v7) = *((_DWORD *)this + 4);
      if ((int)v7 >= 1)
      {
        char v8 = 0;
        unint64_t v9 = 0LL;
        int v10 = -1;
        do
        {
          if (*((_BYTE *)this + 64))
          {
            LOBYTE(v1sub_1808F7164((uint64_t)v14, 1) = *(_BYTE *)(*((void *)this + 6) + v9);
          }

          else if (v9 <= 0xF)
          {
            uint64_t v11 = (*((void *)this + 6) >> (v8 & 0xFC)) & 0xFLL;
          }

          else
          {
            LOBYTE(v1sub_1808F7164((uint64_t)v14, 1) = 0;
          }

          v13[0][(int)v7 + v10] = v11;
          ++v9;
          int64_t v7 = *((int *)this + 4);
          v8 += 4;
          --v10;
        }

        while ((uint64_t)v9 < v7);
      }

      icu::number::impl::DecNum::setTo(a2, (char *)v13[0], v7, *((_DWORD *)this + 3), *((_BYTE *)this + 20) & 1, a3);
    }

    if (BYTE4(v13[1])) {
      uprv_free(v13[0]);
    }
  }

  else
  {
    icu::number::impl::DecNum::setTo(a2, "0", a3);
  }

  return a2;
}

void icu::number::impl::DecimalQuantity::divideBy( icu::number::impl::DecimalQuantity *this, const icu::number::impl::DecNum *a2, UErrorCode *a3)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (*((_DWORD *)this + 4))
  {
    memset(v6, 0, sizeof(v6));
    icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v6);
    icu::number::impl::DecimalQuantity::toDecNum(this, (icu::number::impl::DecNum *)v6, a3);
    if (*(int *)a3 <= 0)
    {
      icu::number::impl::DecNum::divideBy((icu::number::impl::DecNum *)v6, a2, a3);
      if (*(int *)a3 <= 0)
      {
        icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
        *((_BYTE *)this + 20) = 0;
        icu::number::impl::DecimalQuantity::_setToDecNum(this, (const icu::number::impl::DecNum *)v6, a3);
      }
    }

    if (BYTE12(v6[0])) {
      uprv_free(*(void **)&v6[0]);
    }
  }

void icu::number::impl::DecimalQuantity::roundToMagnitude(uint64_t a1, int a2, unsigned int a3, int *a4)
{
}

void icu::number::impl::DecimalQuantity::multiplyBy( icu::number::impl::DecimalQuantity *this, const icu::number::impl::DecNum *a2, UErrorCode *a3)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (*((_DWORD *)this + 4))
  {
    memset(v6, 0, sizeof(v6));
    icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v6);
    icu::number::impl::DecimalQuantity::toDecNum(this, (icu::number::impl::DecNum *)v6, a3);
    if (*(int *)a3 <= 0)
    {
      icu::number::impl::DecNum::multiplyBy((icu::number::impl::DecNum *)v6, a2, a3);
      if (*(int *)a3 <= 0)
      {
        icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
        *((_BYTE *)this + 20) = 0;
        icu::number::impl::DecimalQuantity::_setToDecNum(this, (const icu::number::impl::DecNum *)v6, a3);
      }
    }

    if (BYTE12(v6[0])) {
      uprv_free(*(void **)&v6[0]);
    }
  }

BOOL icu::number::impl::DecimalQuantity::isZeroish(icu::number::impl::DecimalQuantity *this)
{
  return *((_DWORD *)this + 4) == 0;
}

void **icu::number::impl::DecimalQuantity::setToDecNum( void **this, const icu::number::impl::DecNum *a2, UErrorCode *a3)
{
  *((_BYTE *)this + 20) = 0;
  icu::number::impl::DecimalQuantity::_setToDecNum((icu::number::impl::DecimalQuantity *)this, a2, a3);
  return this;
}

uint64_t icu::number::impl::DecimalQuantity::negate(uint64_t this)
{
  *(_BYTE *)(this + 20) ^= 1u;
  return this;
}

uint64_t icu::number::impl::DecimalQuantity::adjustToZeroScale(icu::number::impl::DecimalQuantity *this)
{
  uint64_t v1 = *((unsigned int *)this + 3);
  *((_DWORD *)this + 3) = 0;
  return v1;
}

double icu::number::impl::DecimalQuantity::getPluralOperand(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1:
      char v4 = *(_BYTE *)(a1 + 20);
      uint64_t v5 = icu::number::impl::DecimalQuantity::toLong((icu::number::impl::DecimalQuantity *)a1, 1);
      if ((v4 & 1) != 0) {
        return (double)-v5;
      }
      else {
        return (double)v5;
      }
    case 2:
      int v7 = 1;
      return (double)icu::number::impl::DecimalQuantity::toFractionLong((icu::number::impl::DecimalQuantity *)a1, v7);
    case 3:
      int v7 = 0;
      return (double)icu::number::impl::DecimalQuantity::toFractionLong((icu::number::impl::DecimalQuantity *)a1, v7);
    case 4:
      int v8 = *(_DWORD *)(a1 + 12);
      if (*(_DWORD *)(a1 + 40) < v8) {
        int v8 = *(_DWORD *)(a1 + 40);
      }
      int v9 = -*(_DWORD *)(a1 + 44) - v8;
      goto LABEL_15;
    case 5:
      int v9 = -(*(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 44));
LABEL_15:
      int v2 = v9 & ~(v9 >> 31);
      goto LABEL_16;
    case 6:
    case 7:
      int v2 = *(_DWORD *)(a1 + 44);
LABEL_16:
      double result = (double)v2;
      break;
    default:
      double result = fabs(icu::number::impl::DecimalQuantity::toDouble((icu::number::impl::DecimalQuantity *)a1));
      break;
  }

  return result;
}

uint64_t icu::number::impl::DecimalQuantity::isNegative(icu::number::impl::DecimalQuantity *this)
{
  return *((_BYTE *)this + 20) & 1;
}

uint64_t icu::number::impl::DecimalQuantity::toLong(icu::number::impl::DecimalQuantity *this, int a2)
{
  signed int v2 = *((_DWORD *)this + 4);
  int v3 = *((_DWORD *)this + 3) + *((_DWORD *)this + 11);
  int v4 = v2 + v3 - 1;
  if (v4 >= 17) {
    unsigned int v5 = 17;
  }
  else {
    unsigned int v5 = v2 + v3 - 1;
  }
  if (a2) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = v4;
  }
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 0LL;
    int v8 = -v3;
    char v9 = 4 * v6 - 4 * v3;
    do
    {
      unsigned int v10 = v8 + v6;
      if (*((_BYTE *)this + 64))
      {
        LOBYTE(v1sub_1808F7164((uint64_t)v14, 1) = 0;
      }

      else if (v10 <= 0xF)
      {
        uint64_t v11 = (*((void *)this + 6) >> v9) & 0xFLL;
      }

      else
      {
        LOBYTE(v1sub_1808F7164((uint64_t)v14, 1) = 0;
      }

      uint64_t v7 = 10 * v7 + (char)v11;
      v9 -= 4;
    }

    while (v6-- > 0);
  }

  if ((*((_BYTE *)this + 20) & 1) != 0) {
    return -v7;
  }
  else {
    return v7;
  }
}

unint64_t icu::number::impl::DecimalQuantity::toFractionLong( icu::number::impl::DecimalQuantity *this, int a2)
{
  int v3 = *((_DWORD *)this + 11);
  int v4 = ~v3;
  int v5 = *((_DWORD *)this + 3);
  int v6 = v5;
  if (a2)
  {
    int v6 = *((_DWORD *)this + 10);
    if (v6 >= v5) {
      int v6 = *((_DWORD *)this + 3);
    }
  }

  if (v6 > v4) {
    return 0LL;
  }
  unint64_t result = 0LL;
  char v8 = 4 * ~(v3 + v5);
  int v9 = -v5;
  do
  {
    LODWORD(v10) = v9 + v4;
    if (!*((_BYTE *)this + 64))
    {
      if (v10 <= 0xF)
      {
        uint64_t v10 = (*((void *)this + 6) >> v8) & 0xFLL;
        goto LABEL_14;
      }

uint64_t icu::number::impl::DecimalQuantity::fractionCount(icu::number::impl::DecimalQuantity *this)
{
  int v1 = *((_DWORD *)this + 3);
  if (*((_DWORD *)this + 10) < v1) {
    int v1 = *((_DWORD *)this + 10);
  }
  return (-*((_DWORD *)this + 11) - v1) & ~((-*((_DWORD *)this + 11) - v1) >> 31);
}

uint64_t icu::number::impl::DecimalQuantity::fractionCountWithoutTrailingZeros( icu::number::impl::DecimalQuantity *this)
{
  int v1 = -(*((_DWORD *)this + 3) + *((_DWORD *)this + 11));
  return v1 & ~(v1 >> 31);
}

uint64_t icu::number::impl::DecimalQuantity::getExponent(icu::number::impl::DecimalQuantity *this)
{
  return *((unsigned int *)this + 11);
}

double icu::number::impl::DecimalQuantity::toDouble(icu::number::impl::DecimalQuantity *this)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((*(unsigned int (**)(icu::number::impl::DecimalQuantity *))(*(void *)this + 32LL))(this))
  {
    if ((*((_BYTE *)this + 20) & 1) != 0) {
      return -INFINITY;
    }
    else {
      return INFINITY;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    uint64_t v12 = 0LL;
    __int128 v8 = 0u;
    uint64_t v10 = "";
    BOOL v11 = "";
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    icu::number::impl::DecimalQuantity::toScientificString(this, (uint64_t)&v13);
    int v7 = 0;
    if ((BYTE8(v13) & 0x11) != 0)
    {
      int v3 = 0LL;
    }

    else if ((BYTE8(v13) & 2) != 0)
    {
      int v3 = (unsigned __int16 *)((unint64_t)&v13 | 0xA);
    }

    else
    {
      int v3 = (unsigned __int16 *)*((void *)&v14 + 1);
    }

    if ((SWORD4(v13) & 0x8000u) == 0) {
      int v4 = WORD4(v13) >> 5;
    }
    else {
      int v4 = HIDWORD(v13);
    }
    double v2 = sub_1808D6E78((double *)&v8, v3, v4, &v7);
    icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)&v13);
  }

  return v2;
}

uint64_t icu::number::impl::DecimalQuantity::adjustExponent(uint64_t this, int a2)
{
  *(_DWORD *)(this + 44) += a2;
  return this;
}

BOOL icu::number::impl::DecimalQuantity::resetExponent(icu::number::impl::DecimalQuantity *this)
{
  BOOL result = icu::number::impl::DecimalQuantity::adjustMagnitude(this, *((_DWORD *)this + 11));
  *((_DWORD *)this + 1sub_1808F7164((uint64_t)v14, 1) = 0;
  return result;
}

BOOL icu::number::impl::DecimalQuantity::hasIntegerValue(icu::number::impl::DecimalQuantity *this)
{
  return *((_DWORD *)this + 3) >= 0;
}

uint64_t icu::number::impl::DecimalQuantity::getUpperDisplayMagnitude( icu::number::impl::DecimalQuantity *this)
{
  int v1 = *((_DWORD *)this + 4) + *((_DWORD *)this + 3);
  if (*((_DWORD *)this + 9) > v1) {
    int v1 = *((_DWORD *)this + 9);
  }
  return (v1 - 1);
}

uint64_t icu::number::impl::DecimalQuantity::getLowerDisplayMagnitude( icu::number::impl::DecimalQuantity *this)
{
  unsigned int v1 = *((_DWORD *)this + 3);
  unsigned int v2 = *((_DWORD *)this + 10);
  else {
    return v2;
  }
}

uint64_t icu::number::impl::DecimalQuantity::getDigit(icu::number::impl::DecimalQuantity *this, int a2)
{
  LODWORD(v2) = a2 - *((_DWORD *)this + 3);
  if (!*((_BYTE *)this + 64))
  {
    if (v2 <= 0xF)
    {
      uint64_t v2 = (*((void *)this + 6) >> (4 * v2)) & 0xFLL;
      return (char)v2;
    }

    goto LABEL_6;
  }

  if ((v2 & 0x80000000) != 0 || *((_DWORD *)this + 4) <= (int)v2)
  {
LABEL_6:
    LOBYTE(v2) = 0;
    return (char)v2;
  }

  LOBYTE(v2) = *(_BYTE *)(*((void *)this + 6) + v2);
  return (char)v2;
}

uint64_t icu::number::impl::DecimalQuantity::getDigitPos( icu::number::impl::DecimalQuantity *this, unsigned int a2)
{
  if (!*((_BYTE *)this + 64))
  {
    if (a2 <= 0xF)
    {
      uint64_t v2 = (*((void *)this + 6) >> (4 * a2)) & 0xFLL;
      return (char)v2;
    }

    goto LABEL_6;
  }

  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 4) <= (signed int)a2)
  {
LABEL_6:
    LOBYTE(v2) = 0;
    return (char)v2;
  }

  LOBYTE(v2) = *(_BYTE *)(*((void *)this + 6) + a2);
  return (char)v2;
}

uint64_t icu::number::impl::DecimalQuantity::signum(icu::number::impl::DecimalQuantity *this)
{
  if (*((_DWORD *)this + 4))
  {
    if ((*((_BYTE *)this + 20) & 1) != 0) {
      return 0LL;
    }
    else {
      return 3LL;
    }
  }

  else
  {
    int v3 = (*(uint64_t (**)(icu::number::impl::DecimalQuantity *))(*(void *)this + 32LL))(this);
    if ((*((_BYTE *)this + 20) & 1) != 0) {
      unsigned int v4 = 0;
    }
    else {
      unsigned int v4 = 3;
    }
    if ((*((_BYTE *)this + 20) & 1) != 0) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = 2;
    }
    if (v3) {
      return v4;
    }
    else {
      return v5;
    }
  }

uint64_t icu::number::impl::DecimalQuantity::isInfinite(icu::number::impl::DecimalQuantity *this)
{
  return (*((unsigned __int8 *)this + 20) >> 1) & 1;
}

uint64_t icu::number::impl::DecimalQuantity::isNaN(icu::number::impl::DecimalQuantity *this)
{
  return (*((unsigned __int8 *)this + 20) >> 2) & 1;
}

void **icu::number::impl::DecimalQuantity::setToInt(void **this, int a2)
{
  *((_BYTE *)this + 20) = 0;
  if (a2 == 0x80000000)
  {
    *((_BYTE *)this + 20) = 1;
    a2 = 0x80000000;
  }

  else if (a2 < 0)
  {
    *((_BYTE *)this + 20) = 1;
    a2 = -a2;
  }

  else if (!a2)
  {
    return this;
  }

  icu::number::impl::DecimalQuantity::_setToInt((uint64_t)this, a2);
  icu::number::impl::DecimalQuantity::compact((icu::number::impl::DecimalQuantity *)this);
  return this;
}

uint64_t icu::number::impl::DecimalQuantity::_setToInt(uint64_t this, int a2)
{
  if (a2 == 0x80000000)
  {
    *(void *)(this + 48) = 0x2147483648LL;
    *(_DWORD *)(this + 12) = 0;
    int v4 = 10;
  }

  else
  {
    if (a2)
    {
      unint64_t v2 = 0LL;
      int v3 = 16;
      do
      {
        *((void *)&v5 + sub_1808F7164((uint64_t)v14, 1) = a2
                             - 10
                             * ((((unint64_t)a2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64) >> 3);
        *(void *)&__int128 v5 = v2;
        unint64_t v2 = v5 >> 4;
        unsigned int v6 = a2 + 9;
        --v3;
        a2 /= 10;
      }

      while (v6 > 0x12);
    }

    else
    {
      unint64_t v2 = 0LL;
      int v3 = 16;
    }

    *(void *)(this + 48) = v2 >> (4 * v3);
    *(_DWORD *)(this + 12) = 0;
    int v4 = 16 - v3;
  }

  *(_DWORD *)(this + 16) = v4;
  return this;
}

void icu::number::impl::DecimalQuantity::readLongToBcd(icu::number::impl::DecimalQuantity *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 <= 0x2386F26FC0FFFFLL)
  {
    unint64_t v6 = 0LL;
    int v7 = 16;
    if (a2)
    {
      do
      {
        *((void *)&v8 + sub_1808F7164((uint64_t)v14, 1) = ((int)v2 % 10);
        *(void *)&__int128 v8 = v6;
        unint64_t v6 = v8 >> 4;
        --v7;
        unint64_t v9 = v2 + 9;
        v2 /= 10LL;
      }

      while (v9 > 0x12);
    }

    *((void *)this + 6) = v6 >> (4 * v7);
    *((_DWORD *)this + 3) = 0;
    LODWORD(v4) = 16 - v7;
  }

  else
  {
    icu::number::impl::DecimalQuantity::ensureCapacity(this, 40);
    uint64_t v4 = 0LL;
    do
    {
      *(_BYTE *)(*((void *)this + 6) + v4++) = (char)v2 % 10;
      unint64_t v5 = v2 + 9;
      v2 /= 10LL;
    }

    while (v5 > 0x12);
    *((_DWORD *)this + 3) = 0;
  }

  *((_DWORD *)this + 4) = v4;
}

uint64_t icu::number::impl::DecimalQuantity::readIntToBcd(uint64_t this, int a2)
{
  unint64_t v2 = 0LL;
  int v3 = 16;
  if (a2)
  {
    do
    {
      *((void *)&v4 + sub_1808F7164((uint64_t)v14, 1) = a2
                           - 10
                           * ((((unint64_t)a2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64) >> 3);
      *(void *)&__int128 v4 = v2;
      unint64_t v2 = v4 >> 4;
      unsigned int v5 = a2 + 9;
      --v3;
      a2 /= 10;
    }

    while (v5 > 0x12);
  }

  *(void *)(this + 48) = v2 >> (4 * v3);
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 16 - v3;
  return this;
}

void icu::number::impl::DecimalQuantity::_setToLong(icu::number::impl::DecimalQuantity *this, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a2 == 0x8000000000000000LL)
  {
    memset(v8, 0, sizeof(v8));
    icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v8);
    UErrorCode v7 = U_ZERO_ERROR;
    icu::number::impl::DecNum::setTo((icu::number::impl::DecNum *)v8, "9.223372036854775808E+18", &v7);
    if (v7 <= U_ZERO_ERROR)
    {
      *((_BYTE *)this + 20) |= 1u;
      icu::number::impl::DecimalQuantity::readDecNumberToBcd(this, (int **)v8);
    }

    if (BYTE12(v8[0])) {
      uprv_free(*(void **)&v8[0]);
    }
  }

  else if (a2 > 0x7FFFFFFF)
  {
    icu::number::impl::DecimalQuantity::readLongToBcd(this, a2);
  }

  else
  {
    unint64_t v3 = 0LL;
    int v4 = 16;
    if ((_DWORD)a2)
    {
      do
      {
        *((void *)&v5 + sub_1808F7164((uint64_t)v14, 1) = a2
                             - 10
                             * ((((unint64_t)(int)a2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64) >> 3);
        *(void *)&__int128 v5 = v3;
        unint64_t v3 = v5 >> 4;
        unsigned int v6 = a2 + 9;
        --v4;
        LODWORD(a2) = (int)a2 / 10;
      }

      while (v6 > 0x12);
    }

    *((void *)this + 6) = v3 >> (4 * v4);
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 4) = 16 - v4;
  }

void icu::number::impl::DecimalQuantity::readDecNumberToBcd( icu::number::impl::DecimalQuantity *this, int **a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = **a2;
  if ((int)v4 <= 16)
  {
    if ((int)v4 < 1)
    {
      uint64_t v5 = 0LL;
    }

    else
    {
      uint64_t v7 = 0LL;
      uint64_t v5 = 0LL;
      __int128 v8 = (unsigned __int8 *)v3 + 9;
      do
      {
        unsigned int v9 = *v8++;
        v5 |= (unint64_t)v9 << v7;
        v7 += 4LL;
      }

      while (4 * v4 != v7);
    }

    *((void *)this + 6) = v5;
    LODWORD(v5) = *v3;
  }

  else
  {
    icu::number::impl::DecimalQuantity::ensureCapacity(this, v4);
    LODWORD(v5) = *v3;
    if (*v3 >= 1)
    {
      uint64_t v6 = 0LL;
      do
      {
        *(_BYTE *)(*((void *)this + 6) + v6) = *((_BYTE *)v3 + v6 + 9);
        ++v6;
        uint64_t v5 = *v3;
      }

      while (v6 < v5);
    }
  }

  *((_DWORD *)this + 3) = v3[1];
  *((_DWORD *)this + 4) = v5;
}

void **icu::number::impl::DecimalQuantity::setToDouble(void **this, double a2)
{
  *((_BYTE *)this + 20) = 0;
  if ((*(void *)&a2 & 0x8000000000000000LL) != 0)
  {
    char v4 = 1;
    *((_BYTE *)this + 20) = 1;
    a2 = -a2;
  }

  else
  {
    char v4 = 0;
  }

  if ((*(void *)&a2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000LL)
  {
    *((_BYTE *)this + 20) = v4 | 2;
  }

  else if (a2 != 0.0)
  {
    icu::number::impl::DecimalQuantity::_setToDoubleFast((icu::number::impl::DecimalQuantity *)this, a2);
    icu::number::impl::DecimalQuantity::compact((icu::number::impl::DecimalQuantity *)this);
  }

  return this;
}

void icu::number::impl::DecimalQuantity::_setToDoubleFast( icu::number::impl::DecimalQuantity *this, double a2)
{
  *((_BYTE *)this + 2sub_1808F7164((uint64_t)v14, 1) = 1;
  *((double *)this + 3) = a2;
  *((_DWORD *)this + 8) = 0;
  uint64_t v3 = (*(void *)&a2 >> 52) & 0x7FFLL;
  if (v3 <= 0x433 && (double)(uint64_t)a2 == a2)
  {
    icu::number::impl::DecimalQuantity::_setToLong(this, (uint64_t)a2);
  }

  else if ((_DWORD)v3 != 2047 && (_DWORD)v3)
  {
    double v5 = (double)(1075 - (int)v3) / 3.32192809;
    unsigned int v6 = (int)v5;
    if ((int)v5 < 0)
    {
      if (v6 > 0xFFFFFFEA)
      {
        int v11 = (int)v5;
      }

      else
      {
        int v10 = (int)v5;
        do
        {
          int v11 = v10 + 22;
          a2 = a2 / 1.0e22;
          BOOL v12 = __CFADD__(v10, 43);
          v10 += 22;
        }

        while (!v12);
      }

      double v13 = a2 / dbl_180A3A5D8[-v11];
    }

    else
    {
      if (v6 < 0x16)
      {
        unsigned int v8 = (int)v5;
      }

      else
      {
        unsigned int v7 = (int)v5;
        do
        {
          a2 = a2 * 1.0e22;
          unsigned int v8 = v7 - 22;
          BOOL v9 = v7 > 0x2B;
          v7 -= 22;
        }

        while (v9);
      }

      double v13 = a2 * dbl_180A3A5D8[v8];
    }

    uint64_t v14 = (uint64_t)uprv_round(v13);
    if (v14)
    {
      icu::number::impl::DecimalQuantity::_setToLong(this, v14);
      *((_DWORD *)this + 3) -= v6;
    }
  }

  else
  {
    icu::number::impl::DecimalQuantity::convertToAccurateDouble(this);
  }

void icu::number::impl::DecimalQuantity::convertToAccurateDouble(icu::number::impl::DecimalQuantity *this)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  int v2 = *((_DWORD *)this + 8);
  *(void *)unsigned int v6 = 0LL;
  uint64_t v7 = 0LL;
  __int16 v8 = 0;
  BOOL v5 = 0;
  int v3 = 0;
  int v4 = 0;
  icu::double_conversion::DoubleToStringConverter::DoubleToAscii( 0LL,  0,  v6,  0x12u,  &v5,  &v4,  &v3,  *((double *)this + 3));
  icu::number::impl::DecimalQuantity::setBcdToZero((void **)this);
  icu::number::impl::DecimalQuantity::readDoubleConversionToBcd(this, v6, v4, v3);
  *((_DWORD *)this + 3) += v2;
  *((_BYTE *)this + 65) = 1;
}

void icu::number::impl::DecimalQuantity::readDoubleConversionToBcd( icu::number::impl::DecimalQuantity *this, const char *a2, int a3, int a4)
{
  if (a3 <= 16)
  {
    int v10 = a3 - 1;
    if (a3 < 1)
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      do
      {
        v12 |= (a2[v10] - 48LL) << v11;
        v11 += 4LL;
        --v10;
      }

      while (4LL * a3 != v11);
    }

    *((void *)this + 6) = v12;
  }

  else
  {
    icu::number::impl::DecimalQuantity::ensureCapacity(this, a3);
    uint64_t v8 = 0LL;
    int v9 = a3 - 1;
    do
      *(_BYTE *)(*((void *)this + 6) + v8++) = a2[v9--] - 48;
    while (a3 != v8);
  }

  *((_DWORD *)this + 3) = a4 - a3;
  *((_DWORD *)this + 4) = a3;
}

uint64_t icu::number::impl::DecimalQuantity::setToDecNumber( uint64_t a1, const char *a2, int a3, UErrorCode *a4)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  icu::number::impl::DecimalQuantity::setBcdToZero((void **)a1);
  *(_BYTE *)(a1 + 20) = 0;
  memset(v9, 0, sizeof(v9));
  icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v9);
  icu::number::impl::DecNum::setTo((icu::number::impl::DecNum *)v9, a2, a3, a4);
  icu::number::impl::DecimalQuantity::_setToDecNum( (icu::number::impl::DecimalQuantity *)a1,  (const icu::number::impl::DecNum *)v9,  a4);
  if (BYTE12(v9[0])) {
    uprv_free(*(void **)&v9[0]);
  }
  return a1;
}

void icu::number::impl::DecimalQuantity::_setToDecNum( icu::number::impl::DecimalQuantity *this, const icu::number::impl::DecNum *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (icu::number::impl::DecNum::isNaN(a2))
    {
      char v5 = *((_BYTE *)this + 20) | 4;
LABEL_8:
      *((_BYTE *)this + 20) = v5;
      return;
    }

    if (icu::number::impl::DecNum::isInfinity(a2))
    {
      char v5 = *((_BYTE *)this + 20) | 2;
      goto LABEL_8;
    }

    if (!icu::number::impl::DecNum::isZero(a2))
    {
      icu::number::impl::DecimalQuantity::readDecNumberToBcd(this, (int **)a2);
      icu::number::impl::DecimalQuantity::compact(this);
    }
  }

void icu::number::impl::DecimalQuantity::fromExponentString( uint64_t a1@<X0>, UErrorCode *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  else {
    int32_t v6 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }
  if ((icu::UnicodeString::doIndexOf(a1, 0x65u, 0, v6) & 0x80000000) != 0
    && (*(__int16 *)(a1 + 8) < 0 ? (int32_t v7 = *(_DWORD *)(a1 + 12)) : (int32_t v7 = *(unsigned __int16 *)(a1 + 8) >> 5),
        (icu::UnicodeString::doIndexOf(a1, 0x63u, 0, v7) & 0x80000000) != 0
     && (*(__int16 *)(a1 + 8) < 0 ? (int32_t v8 = *(_DWORD *)(a1 + 12)) : (int32_t v8 = *(unsigned __int16 *)(a1 + 8) >> 5),
         (icu::UnicodeString::doIndexOf(a1, 0x45u, 0, v8) & 0x80000000) != 0
      && (*(__int16 *)(a1 + 8) < 0 ? (int32_t v9 = *(_DWORD *)(a1 + 12)) : (int32_t v9 = *(unsigned __int16 *)(a1 + 8) >> 5),
          (icu::UnicodeString::doIndexOf(a1, 0x43u, 0, v9) & 0x80000000) != 0))))
  {
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)a3 = off_189727580;
    *(_DWORD *)(a3 + 36) = 0;
    *(_DWORD *)(a3 + 44) = 0;
    *(_BYTE *)(a3 + 65) = 0;
    icu::number::impl::DecimalQuantity::setBcdToZero((void **)a3);
    *(_BYTE *)(a3 + 20) = 0;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v33, (UChar **)a1);
    int VisibleFractionCount = icu::number::impl::DecimalQuantity::getVisibleFractionCount((uint64_t)v33);
    icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v33);
    memset(&v35[1], 0, 56);
    v35[0] = (char *)&v35[1] + 5;
    LODWORD(v35[1]) = 40;
    icu::CharString::appendInvariantChars((icu::CharString *)v35, (const icu::UnicodeString *)a1, a2);
    icu::number::impl::DecimalQuantity::setToDecNumber(a3, v35[0], (int)v35[7], a2);
    *(_DWORD *)(a3 + 40) = -VisibleFractionCount;
    if (BYTE4(v35[1])) {
      uprv_free((void *)v35[0]);
    }
  }

  else
  {
    else {
      int32_t v10 = *(unsigned __int16 *)(a1 + 8) >> 5;
    }
    int32_t IndexOf = icu::UnicodeString::doLastIndexOf((icu::UnicodeString *)a1, 101, 0, v10);
    if (IndexOf < 0)
    {
      int32_t v12 = *(__int16 *)(a1 + 8) < 0 ? *(_DWORD *)(a1 + 12) : *(unsigned __int16 *)(a1 + 8) >> 5;
      int32_t IndexOf = icu::UnicodeString::doLastIndexOf((icu::UnicodeString *)a1, 99, 0, v12);
      if (IndexOf < 0)
      {
        int32_t v13 = *(__int16 *)(a1 + 8) < 0 ? *(_DWORD *)(a1 + 12) : *(unsigned __int16 *)(a1 + 8) >> 5;
        int32_t IndexOf = icu::UnicodeString::doLastIndexOf((icu::UnicodeString *)a1, 69, 0, v13);
        if (IndexOf < 0)
        {
          else {
            int32_t v14 = *(unsigned __int16 *)(a1 + 8) >> 5;
          }
          int32_t IndexOf = icu::UnicodeString::doLastIndexOf((icu::UnicodeString *)a1, 67, 0, v14);
        }
      }
    }

    int v17 = IndexOf + 1;
    memset(v42, 0, 64);
    unsigned int v18 = *(unsigned __int16 *)(a1 + 8);
    if ((v18 & 0x8000) != 0) {
      unsigned int v19 = *(_DWORD *)(a1 + 12);
    }
    else {
      unsigned int v19 = v18 >> 5;
    }
    icu::UnicodeString::tempSubString((icu::UnicodeString *)a1, IndexOf + 1, v19 - v17, (icu::UnicodeString *)v42);
    unsigned int v21 = *(unsigned __int16 *)(a1 + 8);
    else {
      unsigned int v22 = v21 >> 5;
    }
    if (v22 <= v17)
    {
      BOOL v24 = 0;
    }

    else
    {
      if ((v21 & 2) != 0) {
        uint64_t v23 = a1 + 10;
      }
      else {
        uint64_t v23 = *(void *)(a1 + 24);
      }
      BOOL v24 = *(unsigned __int16 *)(v23 + 2LL * v17) == 45;
    }

    BOOL v32 = v24;
    int v25 = icu::ICU_Utility::parseAsciiInteger((icu::ICU_Utility *)v42, (const icu::UnicodeString *)&v32, v20);
    memset(&v41[4], 0, 32);
    if (v24) {
      int v26 = -v25;
    }
    else {
      int v26 = v25;
    }
    memset(v41, 0, 32);
    icu::UnicodeString::tempSubString((icu::UnicodeString *)a1, 0, IndexOf, (icu::UnicodeString *)v41);
    memset(&v38[1], 0, 48);
    int v40 = 0;
    v38[0] = (char *)&v38[1] + 5;
    LODWORD(v38[1]) = 40;
    int v39 = 0;
    icu::CharString::appendInvariantChars((icu::CharString *)v38, (const icu::UnicodeString *)v41, a2);
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    memset(v35, 0, sizeof(v35));
    icu::number::impl::DecNum::DecNum((icu::number::impl::DecNum *)v35);
    icu::number::impl::DecNum::setTo((icu::number::impl::DecNum *)v35, (const char *)v38[0], v39, a2);
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 8) = 0u;
    *(void *)a3 = off_189727580;
    *(_DWORD *)(a3 + 36) = 0;
    *(_DWORD *)(a3 + 44) = 0;
    *(_BYTE *)(a3 + 65) = 0;
    icu::number::impl::DecimalQuantity::setBcdToZero((void **)a3);
    *(_BYTE *)(a3 + 20) = 0;
    icu::number::impl::DecimalQuantity::setBcdToZero((void **)a3);
    *(_BYTE *)(a3 + 20) = 0;
    icu::number::impl::DecimalQuantity::_setToDecNum( (icu::number::impl::DecimalQuantity *)a3,  (const icu::number::impl::DecNum *)v35,  a2);
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v34, v41);
    int v27 = icu::number::impl::DecimalQuantity::getVisibleFractionCount((uint64_t)v34);
    icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)v34);
    int v29 = *(_DWORD *)(a3 + 44) + v26;
    *(_DWORD *)(a3 + 40) = -v27;
    *(_DWORD *)(a3 + 44) = v29;
    if (BYTE4(v35[1])) {
      uprv_free((void *)v35[0]);
    }
    __int128 v30 = (void *)BYTE4(v38[1]);
    if (BYTE4(v38[1])) {
      uprv_free(v38[0]);
    }
    icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)v41);
    icu::UnicodeString::~UnicodeString(v31, (icu::UnicodeString *)v42);
  }

uint64_t icu::number::impl::DecimalQuantity::getVisibleFractionCount(uint64_t a1)
{
  else {
    int32_t v2 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }
  int v3 = icu::UnicodeString::doIndexOf((icu::UnicodeString *)a1, 46, 0, v2);
  uint64_t result = 0LL;
  BOOL v5 = __CFADD__(v3, 1);
  int v6 = v3 + 1;
  if (!v5)
  {
    else {
      int v7 = *(unsigned __int16 *)(a1 + 8) >> 5;
    }
    return (v7 - v6);
  }

  return result;
}

BOOL icu::number::impl::DecimalQuantity::fitsInLong(icu::number::impl::DecimalQuantity *this, int a2)
{
  if (((*(uint64_t (**)(icu::number::impl::DecimalQuantity *))(*(void *)this + 32LL))(this) & 1) != 0
    || ((*(uint64_t (**)(icu::number::impl::DecimalQuantity *))(*(void *)this + 24LL))(this) & 1) != 0)
  {
    return 0LL;
  }

  uint64_t v4 = *((unsigned int *)this + 4);
  if (!(_DWORD)v4) {
    return 1LL;
  }
  int v5 = *((_DWORD *)this + 3);
  if (v5 + *((_DWORD *)this + 11) < 0 && !a2) {
    return 0LL;
  }
  int v7 = v4 + v5 - 1;
  if (v7 < 18) {
    return 1LL;
  }
  if (v7 != 18) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = -v4;
  int32_t v10 = &byte_180A3A688;
  while (1)
  {
    int Digit = icu::number::impl::DecimalQuantity::getDigit(this, (int)v8 + 18);
    int v13 = *v10++;
    char v12 = v13;
    if (v9 == --v8) {
      return *((_BYTE *)this + 20) & 1;
    }
  }

  return Digit < v12;
}

void *icu::number::impl::DecimalQuantity::toScientificString@<X0>( icu::number::impl::DecimalQuantity *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  if ((*((_BYTE *)this + 20) & 1) != 0)
  {
    __int16 v21 = 45;
    icu::UnicodeString::doAppend(a2, (uint64_t)&v21, 0, 1LL);
  }

  int v4 = *((_DWORD *)this + 4);
  if (!v4) {
    return (void *)icu::UnicodeString::doAppend(a2, (uint64_t)"0", 0, 0xFFFFFFFFLL);
  }
  unsigned int v5 = v4 - 1;
  if (*((_BYTE *)this + 64))
  {
    if (v4 >= 1)
    {
      LOBYTE(v6) = *(_BYTE *)(*((void *)this + 6) + v5);
      goto LABEL_11;
    }

    goto LABEL_9;
  }

  if (v5 > 0xF)
  {
LABEL_9:
    LOBYTE(v6) = 0;
    goto LABEL_11;
  }

  uint64_t v6 = (*((void *)this + 6) >> (4 * v5)) & 0xFLL;
LABEL_11:
  icu::UnicodeString::append(a2, (char)v6 + 48);
  if (v4 > 1)
  {
    __int16 v21 = 46;
    icu::UnicodeString::doAppend(a2, (uint64_t)&v21, 0, 1LL);
    int64_t v8 = (v4 - 2);
    char v9 = 4 * v8;
    while (*((_BYTE *)this + 64))
    {
      LOBYTE(v10) = *(_BYTE *)(*((void *)this + 6) + v8);
LABEL_19:
      icu::UnicodeString::append(a2, (char)v10 + 48);
      v9 -= 4;
      if (v8-- <= 0) {
        goto LABEL_21;
      }
    }

    if ((unint64_t)v8 <= 0xF)
    {
      uint64_t v10 = (*((void *)this + 6) >> (v9 & 0xFC)) & 0xFLL;
      goto LABEL_19;
    }

uint64_t sub_1809211A0(uint64_t a1, int a2, int a3)
{
  *(void *)a1 = a1 + 13;
  *(_DWORD *)(a1 + 8) = 20;
  *(_BYTE *)(a1 + 12) = 0;
  if (a2 >= 21 && a3 <= 0)
  {
    unsigned int v5 = uprv_malloc(a2);
    if (v5)
    {
      uint64_t v6 = v5;
      if (*(_BYTE *)(a1 + 12)) {
        uprv_free(*(void **)a1);
      }
      *(void *)a1 = v6;
      *(_DWORD *)(a1 + 8) = a2;
      *(_BYTE *)(a1 + 12) = 1;
    }
  }

  return a1;
}

void icu::number::impl::DecimalQuantity::truncate(icu::number::impl::DecimalQuantity *this)
{
  int v1 = *((_DWORD *)this + 3);
  if (v1 < 0)
  {
    icu::number::impl::DecimalQuantity::shiftRight((uint64_t)this, -v1);
    *((_DWORD *)this + 3) = 0;
    icu::number::impl::DecimalQuantity::compact(this);
  }

uint64_t icu::number::impl::DecimalQuantity::shiftRight(uint64_t this, int a2)
{
  if (*(_BYTE *)(this + 64))
  {
    int v2 = *(_DWORD *)(this + 16);
    if (v2 <= a2)
    {
      LODWORD(v3) = 0;
    }

    else
    {
      uint64_t v3 = 0LL;
      do
      {
        *(_BYTE *)(*(void *)(this + 48) + v3) = *(_BYTE *)(*(void *)(this + 48) + v3 + a2);
        ++v3;
        int v2 = *(_DWORD *)(this + 16);
      }

      while (v3 < v2 - a2);
    }

    if ((int)v3 < v2)
    {
      uint64_t v4 = 0LL;
      do
      {
        *(_BYTE *)(*(void *)(this + 48) + v3 + v4) = 0;
        int v2 = *(_DWORD *)(this + 16);
        ++v4;
      }

      while (v2 > (int)v3 + (int)v4);
    }
  }

  else
  {
    *(void *)(this + 48) >>= 4 * a2;
    int v2 = *(_DWORD *)(this + 16);
  }

  *(_DWORD *)(this + 12) += a2;
  *(_DWORD *)(this + 16) = v2 - a2;
  return this;
}

void icu::number::impl::DecimalQuantity::roundToNickel(uint64_t a1, int a2, unsigned int a3, int *a4)
{
}

void icu::number::impl::DecimalQuantity::roundToMagnitude( uint64_t a1, int a2, unsigned int a3, int a4, int *a5)
{
  BOOL v55 = a3 < 4;
  while (1)
  {
    int v8 = *(_DWORD *)(a1 + 12);
    BOOL v9 = a2 - v8 <= a2 || v8 <= 0;
    if (v9) {
      unsigned int v10 = a2 - v8;
    }
    else {
      unsigned int v10 = 0x80000000;
    }
    if (a2 - v8 < a2 && v8 < 0) {
      int v12 = 0x7FFFFFFF;
    }
    else {
      int v12 = v10;
    }
    if (*(_BYTE *)(a1 + 64))
    {
      if (v12 < 0)
      {
        LODWORD(v13) = 0;
        goto LABEL_24;
      }

      if (*(_DWORD *)(a1 + 16) > v12)
      {
        LODWORD(v13) = *(unsigned __int8 *)(*(void *)(a1 + 48) + v12);
        goto LABEL_22;
      }

LABEL_169:
      BOOL v40 = (_DWORD)v13 == 7 && v29 == 3;
    }

    else
    {
      BOOL v40 = (v13 & 1) == 0;
    }

    int v39 = v40;
  }

  else
  {
    if ((char)v13 > 1)
    {
      int v29 = 3;
      if (v13 >= 5)
      {
        else {
          int v29 = 3;
        }
        goto LABEL_160;
      }

      goto LABEL_169;
    }

    int v29 = 1;
LABEL_161:
    int v39 = 1;
  }

LABEL_227:
          if ((v41 & 1) == 0)
          {
            int v48 = *(unsigned __int8 *)(a1 + 64);
            if ((_DWORD)v13 == 9)
            {
              char v49 = 0;
              unint64_t v50 = 0LL;
              if (!*(_BYTE *)(a1 + 64)) {
                goto LABEL_232;
              }
LABEL_230:
              if ((uint64_t)v50 < *(int *)(a1 + 16))
              {
                LODWORD(v5sub_1808F7164((uint64_t)v14, 1) = *(unsigned __int8 *)(*(void *)(a1 + 48) + v50);
                while ((_DWORD)v51 == 9)
                {
                  ++v50;
                  v49 += 4;
                  if (*(_BYTE *)(a1 + 64)) {
                    goto LABEL_230;
                  }
LABEL_232:
                  if (v50 > 0xF) {
                    break;
                  }
                  uint64_t v51 = (*(void *)(a1 + 48) >> (v49 & 0xFC)) & 0xFLL;
                }
              }

              icu::number::impl::DecimalQuantity::shiftRight(a1, v50);
              int v48 = *(unsigned __int8 *)(a1 + 64);
            }

            if (v48)
            {
              else {
                char v52 = **(_BYTE **)(a1 + 48) + 1;
              }
              icu::number::impl::DecimalQuantity::ensureCapacity((icu::number::impl::DecimalQuantity *)a1, 1);
              **(_BYTE **)(a1 + 48) = v52;
            }

            else
            {
              *(void *)(a1 + 48) = ((*(void *)(a1 + 48) & 0xFLL) + 1) | *(void *)(a1 + 48) & 0xFFFFFFFFFFFFFFF0LL;
            }

            ++*(_DWORD *)(a1 + 16);
          }
        }

        icu::number::impl::DecimalQuantity::compact((icu::number::impl::DecimalQuantity *)a1);
        return;
      default:
LABEL_198:
        *a5 = 65809;
        return;
    }
  }

  signed int v19 = v160;
LABEL_245:
  icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)&v163);
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v158);
  return v19;
}

void icu::number::impl::DecimalQuantity::setDigitPos( icu::number::impl::DecimalQuantity *this, int a2, int a3)
{
  char v3 = a3;
  if (*((_BYTE *)this + 64))
  {
    icu::number::impl::DecimalQuantity::ensureCapacity(this, a2 + 1);
    *(_BYTE *)(*((void *)this + 6) + a2) = v3;
  }

  else if (a2 < 16)
  {
    *((void *)this + 6) = *((void *)this + 6) & ~(15LL << (4 * a2)) | ((uint64_t)a3 << (4 * a2));
  }

  else
  {
    icu::number::impl::DecimalQuantity::switchStorage(this);
    icu::number::impl::DecimalQuantity::ensureCapacity(this, a2 + 1);
    *(_BYTE *)(*((void *)this + 6) + a2) = v3;
  }

void icu::number::impl::DecimalQuantity::roundToInfinity(icu::number::impl::DecimalQuantity *this)
{
  if (*((_BYTE *)this + 21)) {
    icu::number::impl::DecimalQuantity::convertToAccurateDouble(this);
  }
}

void icu::number::impl::DecimalQuantity::appendDigit( icu::number::impl::DecimalQuantity *this, int a2, int a3, int a4)
{
  if (a2)
  {
    int v8 = (int *)((char *)this + 12);
    int v7 = *((_DWORD *)this + 3);
    if (v7 >= 1)
    {
      a3 += v7;
      if (a4) {
        *int v8 = 0;
      }
    }

    int v9 = a3 + 1;
    icu::number::impl::DecimalQuantity::shiftLeft((const void **)this, a3 + 1);
    if (*((_BYTE *)this + 64))
    {
      icu::number::impl::DecimalQuantity::ensureCapacity(this, 1);
      **((_BYTE **)this + 6) = a2;
      if (!a4) {
        return;
      }
    }

    else
    {
      *((void *)this + 6) = *((void *)this + 6) & 0xFFFFFFFFFFFFFFF0LL | a2;
      if (!a4) {
        return;
      }
    }

    int v10 = *v8;
LABEL_13:
    *int v8 = v10 + v9;
    return;
  }

  if (a4 && *((_DWORD *)this + 4))
  {
    int v10 = a3 + 1;
    int v9 = *((_DWORD *)this + 3);
    int v8 = (int *)((char *)this + 12);
    goto LABEL_13;
  }

void icu::number::impl::DecimalQuantity::shiftLeft(const void **this, int a2)
{
  if (*((_BYTE *)this + 64)
    || *((_DWORD *)this + 4) + a2 >= 17
    && (icu::number::impl::DecimalQuantity::switchStorage((icu::number::impl::DecimalQuantity *)this),
        *((_BYTE *)this + 64)))
  {
    icu::number::impl::DecimalQuantity::ensureCapacity( (icu::number::impl::DecimalQuantity *)this,  *((_DWORD *)this + 4) + a2);
    memmove((char *)this[6] + a2, this[6], *((int *)this + 4));
    bzero((void *)this[6], a2);
  }

  else
  {
    this[6] = (const void *)((void)this[6] << (4 * a2));
  }

  int v4 = *((_DWORD *)this + 4) + a2;
  *((_DWORD *)this + 3) -= a2;
  *((_DWORD *)this + 4) = v4;
}

uint64_t icu::number::impl::DecimalQuantity::toPlainString@<X0>( icu::number::impl::DecimalQuantity *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  if ((*((_BYTE *)this + 20) & 1) != 0)
  {
    __int16 v19 = 45;
    icu::UnicodeString::doAppend(a2, (uint64_t)&v19, 0, 1LL);
  }

  int v4 = *((_DWORD *)this + 4);
  if (v4)
  {
    int v5 = *((_DWORD *)this + 11) + *((_DWORD *)this + 3);
    int v6 = v5 + v4;
    if (v6 <= *((_DWORD *)this + 9)) {
      int v7 = *((_DWORD *)this + 9);
    }
    else {
      int v7 = v6;
    }
    if (v5 >= *((_DWORD *)this + 10)) {
      int v8 = *((_DWORD *)this + 10);
    }
    else {
      int v8 = *((_DWORD *)this + 11) + *((_DWORD *)this + 3);
    }
    if (v7 > 0)
    {
      int v9 = v7 + 1;
      char v10 = 4 * v7 - 4;
      while (1)
      {
        int v11 = *((_DWORD *)this + 3) + *((_DWORD *)this + 11);
        LODWORD(v12) = v9 - v11 - 2;
        if (!*((_BYTE *)this + 64)) {
          break;
        }
        LOBYTE(v12) = *(_BYTE *)(*((void *)this + 6) + v12);
LABEL_19:
        uint64_t result = icu::UnicodeString::append(a2, (char)v12 + 48);
        --v9;
        v10 -= 4;
        if (v9 <= 1)
        {
          int v14 = -1;
          if (v8 < 0) {
            goto LABEL_21;
          }
          goto LABEL_22;
        }
      }

      if (v12 <= 0xF)
      {
        uint64_t v12 = (*((void *)this + 6) >> (v10 - 4 * v11)) & 0xFLL;
        goto LABEL_19;
      }

icu::ICU_Utility *icu::number::impl::DecimalQuantity::toExponentString@<X0>( icu::number::impl::DecimalQuantity *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  if ((*((_BYTE *)this + 20) & 1) != 0)
  {
    __int16 v17 = 45;
    icu::UnicodeString::doAppend(a2, (uint64_t)&v17, 0, 1LL);
  }

  int v4 = *((_DWORD *)this + 3);
  if (*((_DWORD *)this + 4) + v4 <= *((_DWORD *)this + 9)) {
    int v5 = *((_DWORD *)this + 9);
  }
  else {
    int v5 = *((_DWORD *)this + 4) + v4;
  }
  if (v4 >= *((_DWORD *)this + 10)) {
    int v6 = *((_DWORD *)this + 10);
  }
  else {
    int v6 = *((_DWORD *)this + 3);
  }
  if (v5 > 0)
  {
    int v7 = v5 + 1;
    char v8 = 4 * v5 - 4;
    while (1)
    {
      int v9 = *((_DWORD *)this + 3);
      LODWORD(v10) = v7 - v9 - 2;
      if (!*((_BYTE *)this + 64)) {
        break;
      }
      LOBYTE(v10) = *(_BYTE *)(*((void *)this + 6) + v10);
LABEL_18:
      uint64_t result = (icu::ICU_Utility *)icu::UnicodeString::append(a2, (char)v10 + 48);
      --v7;
      v8 -= 4;
      if (v7 <= 1)
      {
        int v12 = -1;
        if (v6 < 0) {
          goto LABEL_20;
        }
        goto LABEL_21;
      }
    }

    if (v10 <= 0xF)
    {
      uint64_t v10 = (*((void *)this + 6) >> (v8 - 4 * v9)) & 0xFLL;
      goto LABEL_18;
    }

void icu::number::impl::DecimalQuantity::ensureCapacity(icu::number::impl::DecimalQuantity *this, int a2)
{
  if (a2)
  {
    if (*((_BYTE *)this + 64))
    {
      size_t v4 = *((int *)this + 14);
      if (a2 > (int)v4)
      {
        int v5 = 2 * a2;
        int v6 = (char *)uprv_malloc(2 * a2);
        int v7 = (void *)*((void *)this + 6);
        memcpy(v6, v7, v4);
        bzero(&v6[v4], a2 - (int)v4);
        uprv_free(v7);
        *((void *)this + 6) = v6;
        *((_DWORD *)this + 14) = v5;
      }
    }

    else
    {
      char v8 = uprv_malloc(a2);
      *((void *)this + 6) = v8;
      *((_DWORD *)this + 14) = a2;
      bzero(v8, a2);
    }

    *((_BYTE *)this + 64) = 1;
  }

void icu::number::impl::DecimalQuantity::switchStorage(icu::number::impl::DecimalQuantity *this)
{
  if (*((_BYTE *)this + 64))
  {
    uint64_t v2 = *((unsigned int *)this + 4);
    char v3 = (char *)*((void *)this + 6);
    if ((int)v2 < 1)
    {
      unint64_t v4 = 0LL;
    }

    else
    {
      unint64_t v4 = 0LL;
      unint64_t v5 = v2 + 1;
      do
        unint64_t v4 = v3[(v5-- - 2)] | (16 * v4);
      while (v5 > 1);
    }

    uprv_free(v3);
    *((void *)this + 6) = v4;
    *((_BYTE *)this + 64) = 0;
  }

  else
  {
    unint64_t v6 = *((void *)this + 6);
    icu::number::impl::DecimalQuantity::ensureCapacity(this, 40);
    if (*((int *)this + 4) >= 1)
    {
      uint64_t v7 = 0LL;
      do
      {
        *(_BYTE *)(*((void *)this + 6) + v7) = v6 & 0xF;
        v6 >>= 4;
        ++v7;
      }

      while (v7 < *((int *)this + 4));
    }
  }

void icu::number::impl::DecimalQuantity::ensureCapacity(icu::number::impl::DecimalQuantity *this)
{
}

const __int16 *icu::number::impl::DecimalQuantity::checkHealth(icu::number::impl::DecimalQuantity *this)
{
  uint64_t v1 = *((unsigned int *)this + 4);
  if (*((_BYTE *)this + 64))
  {
    if (!(_DWORD)v1) {
      return L"Zero precision but we are in byte mode";
    }
    int v2 = *((_DWORD *)this + 14);
    unint64_t v4 = (char *)*((void *)this + 6);
    if (*v4)
    {
      uint64_t result = (const __int16 *)"D";
      uint64_t v5 = v1;
      unint64_t v6 = v4;
      uint64_t v7 = L"Digit below 0 in byte array";
      while (1)
      {
        int v9 = *v6++;
        int v8 = v9;
        if (v9 > 9) {
          break;
        }
        if (v8 < 0) {
          return v7;
        }
        if (!--v5)
        {
          uint64_t v7 = L"Nonzero digits outside of range in byte array";
          int v10 = v1;
          while (v10 < 0 || (int)v1 <= v10 || !v4[v10])
          {
            uint64_t result = 0LL;
            if (v2 == ++v10) {
              return result;
            }
          }

          return v7;
        }
      }

      return result;
    }

    return L"Least significant digit is zero in long mode";
  }

  if ((_DWORD)v1)
  {
    unint64_t v11 = *((void *)this + 6);
    if ((v11 & 0xF) == 0) {
      return L"Least significant digit is zero in long mode";
    }
    unint64_t v12 = 0LL;
    uint64_t result = L"Digit exceeding 10 in long";
    while (v12 > 0xF || ((v11 >> (4 * v12)) & 0xE) <= 9)
    {
      if (++v12 == v1)
      {
        return 0LL;
      }
    }
  }

  else
  {
    unint64_t v11 = *((void *)this + 6);
    if (v11)
    {
      return L"Value in bcdLong even though precision is zero";
    }

    else
    {
LABEL_34:
      char v13 = 4 * v1;
      uint64_t result = (const __int16 *)"N";
      while (v1 > 0xF || ((v11 >> v13) & 0xF) == 0)
      {
        LODWORD(vsub_1808F7164((uint64_t)v14, 1) = v1 + 1;
        v13 += 4;
        if ((_DWORD)v1 == 16) {
          return 0LL;
        }
      }
    }
  }

  return result;
}

BOOL icu::number::impl::DecimalQuantity::operator==(icu::number::impl::DecimalQuantity *this, uint64_t a2)
{
  int v2 = *((_DWORD *)this + 3);
  if (v2 != *(_DWORD *)(a2 + 12)) {
    return 0LL;
  }
  unsigned int v5 = *((_DWORD *)this + 4);
  if (__PAIR64__(*((unsigned __int8 *)this + 20), v5) != __PAIR64__( *(unsigned __int8 *)(a2 + 20),  *(_DWORD *)(a2 + 16))) {
    return 0LL;
  }
  int v6 = *((_DWORD *)this + 9);
  if (v6 != *(_DWORD *)(a2 + 36)) {
    return 0LL;
  }
  int v7 = *((_DWORD *)this + 10);
  if (!v5) {
    return 1LL;
  }
  if (*((_BYTE *)this + 21))
  {
    return 0LL;
  }

  int v10 = v5 + v2;
  if (v6 <= v10) {
    int v11 = v10;
  }
  else {
    int v11 = *((_DWORD *)this + 9);
  }
  if (v7 >= v2) {
    int v12 = *((_DWORD *)this + 3);
  }
  else {
    int v12 = *((_DWORD *)this + 10);
  }
  do
  {
    BOOL v8 = v11 <= v12;
    if (v11 <= v12) {
      break;
    }
    int Digit = icu::number::impl::DecimalQuantity::getDigit(this, --v11);
  }

  while (Digit == icu::number::impl::DecimalQuantity::getDigit( (icu::number::impl::DecimalQuantity *)a2,  v11));
  return v8;
}

void icu::number::impl::DecimalQuantity::toString( icu::number::impl::DecimalQuantity *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  memset(v19, 0, sizeof(v19));
  sub_1809228C4((uint64_t)v19, *((_DWORD *)this + 4) + 1, 0);
  int v4 = *((_DWORD *)this + 4);
  if (v4 > 0)
  {
    uint64_t v5 = 0LL;
    int v6 = -1;
    do
    {
      unsigned int v7 = v4 + v6;
      if (*((_BYTE *)this + 64))
      {
        LOBYTE(v8) = 0;
      }

      else if (v7 <= 0xF)
      {
        uint64_t v8 = (*((void *)this + 6) >> (4 * v7)) & 0xFLL;
      }

      else
      {
        LOBYTE(v8) = 0;
      }

      *(_BYTE *)(*(void *)&v19[0] + v5++) = v8 + 48;
      int v4 = *((_DWORD *)this + 4);
      --v6;
    }

    while (v5 < v4);
  }

  *(_BYTE *)(*(void *)&v19[0] + v4) = 0;
  int v18 = 0;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v13 = 0u;
  if (*((_BYTE *)this + 64)) {
    int v9 = "bytes";
  }
  else {
    int v9 = "long";
  }
  int v10 = "-";
  if ((*((_BYTE *)this + 20) & 1) == 0) {
    int v10 = "";
  }
  int v11 = *(const char **)&v19[0];
  if (!*((_DWORD *)this + 4)) {
    int v11 = "0";
  }
  snprintf( __str,  0x64uLL,  "<DecimalQuantity %d:%d %s %s%s%s%d>",  *((_DWORD *)this + 9),  *((_DWORD *)this + 10),  v9,  v10,  v11,  "E",  *((_DWORD *)this + 3));
  icu::UnicodeString::UnicodeString(a2, __str, 0xFFFFFFFFLL, 0LL);
  if (BYTE12(v19[0])) {
    uprv_free(*(void **)&v19[0]);
  }
}

uint64_t sub_1809228C4(uint64_t a1, int a2, int a3)
{
  *(void *)a1 = a1 + 13;
  *(_DWORD *)(a1 + 8) = 30;
  *(_BYTE *)(a1 + 12) = 0;
  if (a2 >= 31 && a3 <= 0)
  {
    uint64_t v5 = uprv_malloc(a2);
    if (v5)
    {
      int v6 = v5;
      if (*(_BYTE *)(a1 + 12)) {
        uprv_free(*(void **)a1);
      }
      *(void *)a1 = v6;
      *(_DWORD *)(a1 + 8) = a2;
      *(_BYTE *)(a1 + 12) = 1;
    }
  }

  return a1;
}

icu::number::impl::DecimalFormatProperties *icu::number::impl::DecimalFormatProperties::DecimalFormatProperties( icu::number::impl::DecimalFormatProperties *this)
{
  *(_BYTE *)this = 1;
  *((_BYTE *)this + 8) = 1;
  icu::CurrencyUnit::CurrencyUnit((icu::number::impl::DecimalFormatProperties *)((char *)this + 16));
  *((void *)this + 6) = 0LL;
  *((_BYTE *)this + 56) = 1;
  *((void *)this + 16) = off_18971B688;
  *((_WORD *)this + 68) = 2;
  *((void *)this + 24) = off_18971B688;
  *((_WORD *)this + 100) = 2;
  *((void *)this + 32) = off_18971B688;
  *((_WORD *)this + 132) = 2;
  *((void *)this + icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = off_18971B688;
  *((_WORD *)this + 164) = 2;
  *((_BYTE *)this + 384) = 1;
  *((void *)this + 49) = off_18971B688;
  *((_WORD *)this + 200) = 2;
  *((_BYTE *)this + 460) = 1;
  *((void *)this + 60) = off_18971B688;
  *((_WORD *)this + 244) = 2;
  *((void *)this + 68) = off_18971B688;
  *((_WORD *)this + 276) = 2;
  *((void *)this + 76) = off_18971B688;
  *((_WORD *)this + 308) = 2;
  *((void *)this + 84) = off_18971B688;
  *((_WORD *)this + 3icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 2;
  *((_BYTE *)this + 744) = 1;
  icu::number::impl::DecimalFormatProperties::clear(this);
  return this;
}

void icu::number::impl::DecimalFormatProperties::clear(icu::number::impl::DecimalFormatProperties *this)
{
  *(_BYTE *)this = 1;
  *((_BYTE *)this + 8) = 1;
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 6) = 0LL;
  *((_BYTE *)this + 56) = 1;
  *((_DWORD *)this + 16) = 0;
  *((_BYTE *)this + 68) = 0;
  *(void *)&__int128 v3 = -1LL;
  *((void *)&v3 + sub_1808F7164((uint64_t)v14, 1) = -1LL;
  *((void *)this + 9) = -1LL;
  *((_BYTE *)this + 80) = 1;
  *((_DWORD *)this + 2sub_1808F7164((uint64_t)v14, 1) = 0;
  *(_OWORD *)((char *)this + 88) = v3;
  *(_OWORD *)((char *)this + 104) = v3;
  *((void *)this + 15) = 1LL;
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 128));
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 192));
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 256));
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 320));
  *((_BYTE *)this + 384) = 1;
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 392));
  *((_WORD *)this + 228) = 0;
  *((_BYTE *)this + 460) = 1;
  *((_WORD *)this + 234) = 0;
  *((_DWORD *)this + 118) = 2;
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 480));
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 544));
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 608));
  icu::UnicodeString::setToBogus((icu::number::impl::DecimalFormatProperties *)((char *)this + 672));
  *((void *)this + 92) = 0LL;
  *((_BYTE *)this + 744) = 1;
  *((_DWORD *)this + 188) = -1;
  *((_WORD *)this + 378) = 0;
}

uint64_t icu::number::impl::DecimalFormatProperties::_equals( icu::number::impl::DecimalFormatProperties *this, const icu::number::impl::DecimalFormatProperties *a2, unsigned int a3)
{
  if (*(_BYTE *)this)
  {
    if (!*(_BYTE *)a2) {
      return 0LL;
    }
  }

  else if (*(_BYTE *)a2 || *((_DWORD *)this + 1) != *((_DWORD *)a2 + 1))
  {
    return 0LL;
  }

  if (*((_BYTE *)this + 8))
  {
    if (!*((_BYTE *)a2 + 8)) {
      return 0LL;
    }
  }

  else
  {
    if (*((_BYTE *)a2 + 8)) {
      return 0LL;
    }
    uint64_t result = icu::MeasureUnit::operator==((uint64_t)this + 16, (uint64_t)a2 + 16);
    if (!(_DWORD)result) {
      return result;
    }
  }

  if (*((void *)this + 6) != *((void *)a2 + 6)) {
    return 0LL;
  }
  if (*((_BYTE *)this + 56))
  {
    if (!*((_BYTE *)a2 + 56)) {
      return 0LL;
    }
  }

  else if (*((_BYTE *)a2 + 56) || *((_DWORD *)this + 15) != *((_DWORD *)a2 + 15))
  {
    return 0LL;
  }

  if (*((unsigned __int8 *)this + 65) != *((unsigned __int8 *)a2 + 65)
    || *((unsigned __int8 *)this + 66) != *((unsigned __int8 *)a2 + 66)
    || *((unsigned __int8 *)this + 67) != *((unsigned __int8 *)a2 + 67)
    || *((unsigned __int8 *)this + 68) != *((unsigned __int8 *)a2 + 68)
    || *((_DWORD *)this + 18) != *((_DWORD *)a2 + 18)
    || *((_DWORD *)this + 21) != *((_DWORD *)a2 + 21)
    || *((_DWORD *)this + 24) != *((_DWORD *)a2 + 24)
    || *((_DWORD *)this + 25) != *((_DWORD *)a2 + 25)
    || *((_DWORD *)this + 27) != *((_DWORD *)a2 + 27)
    || *((_DWORD *)this + 29) != *((_DWORD *)a2 + 29)
    || *((_DWORD *)this + 30) != *((_DWORD *)a2 + 30)
    || *((_DWORD *)this + 31) != *((_DWORD *)a2 + 31))
  {
    return 0LL;
  }

  uint64_t result = sub_1807FF934((uint64_t)this + 128, (uint64_t)a2 + 128);
  if ((_DWORD)result)
  {
    uint64_t result = sub_1807FF934((uint64_t)this + 256, (uint64_t)a2 + 256);
    if ((_DWORD)result)
    {
      if (*((_BYTE *)this + 384))
      {
        if (!*((_BYTE *)a2 + 384)) {
          return 0LL;
        }
      }

      else if (*((_BYTE *)a2 + 384) || *((_DWORD *)this + 97) != *((_DWORD *)a2 + 97))
      {
        return 0LL;
      }

      uint64_t result = sub_1807FF934((uint64_t)this + 392, (uint64_t)a2 + 392);
      if ((_DWORD)result)
      {
        uint64_t result = sub_1807FF934((uint64_t)this + 480, (uint64_t)a2 + 480);
        if ((_DWORD)result)
        {
          uint64_t result = sub_1807FF934((uint64_t)this + 608, (uint64_t)a2 + 608);
          if ((_DWORD)result)
          {
            if (*((_BYTE *)this + 744))
            {
              if (!*((_BYTE *)a2 + 744)) {
                return 0LL;
              }
            }

            else if (*((_BYTE *)a2 + 744) || *((_DWORD *)this + 187) != *((_DWORD *)a2 + 187))
            {
              return 0LL;
            }

            if (*((_DWORD *)this + 188) != *((_DWORD *)a2 + 188)
              || *((unsigned __int8 *)this + 756) != *((unsigned __int8 *)a2 + 756))
            {
              return 0LL;
            }

            int v7 = *((unsigned __int8 *)this + 757);
            int v8 = *((unsigned __int8 *)a2 + 757);
            uint64_t result = v7 == v8 ? a3 : 0LL;
            if (v7 == v8 && (a3 & 1) == 0)
            {
              if (*((_DWORD *)this + 19) != *((_DWORD *)a2 + 19)
                || *((unsigned __int8 *)this + 80) != *((unsigned __int8 *)a2 + 80)
                || *((_DWORD *)this + 26) != *((_DWORD *)a2 + 26)
                || *((_DWORD *)this + 22) != *((_DWORD *)a2 + 22)
                || *((_DWORD *)this + 23) != *((_DWORD *)a2 + 23)
                || *((_DWORD *)this + 28) != *((_DWORD *)a2 + 28))
              {
                return 0LL;
              }

              uint64_t result = sub_1807FF934((uint64_t)this + 192, (uint64_t)a2 + 192);
              if ((_DWORD)result)
              {
                uint64_t result = sub_1807FF934((uint64_t)this + 320, (uint64_t)a2 + 320);
                if ((_DWORD)result)
                {
                  uint64_t result = sub_1807FF934((uint64_t)this + 544, (uint64_t)a2 + 544);
                  if ((_DWORD)result)
                  {
                    uint64_t result = sub_1807FF934((uint64_t)this + 672, (uint64_t)a2 + 672);
                    if ((_DWORD)result)
                    {
                      if (*((unsigned __int8 *)this + 64) == *((unsigned __int8 *)a2 + 64)
                        && *((unsigned __int8 *)this + 456) == *((unsigned __int8 *)a2 + 456)
                        && *((unsigned __int8 *)this + 457) == *((unsigned __int8 *)a2 + 457))
                      {
                        if (*((_BYTE *)this + 460))
                        {
                          if (*((_BYTE *)a2 + 460)) {
                            goto LABEL_52;
                          }
                        }

                        else if (!*((_BYTE *)a2 + 460) && *((_DWORD *)this + 116) == *((_DWORD *)a2 + 116))
                        {
LABEL_52:
                          if (*((unsigned __int8 *)this + 468) == *((unsigned __int8 *)a2 + 468)
                            && *((unsigned __int8 *)this + 469) == *((unsigned __int8 *)a2 + 469))
                          {
                            return *((_DWORD *)this + 118) == *((_DWORD *)a2 + 118);
                          }
                        }
                      }

                      return 0LL;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t icu::number::impl::DecimalFormatProperties::equalsDefaultExceptFastFormat( icu::number::impl::DecimalFormatProperties *this)
{
  unsigned int v2 = atomic_load(&dword_18C449778);
  if (v2 != 2 && icu::umtx_initImplPreInit(&dword_18C449778))
  {
    icu::number::impl::DecimalFormatProperties::DecimalFormatProperties((icu::number::impl::DecimalFormatProperties *)&unk_18C449480);
    dword_18C44977C = 0;
    icu::umtx_initImplPostInit(&dword_18C449778);
  }

  return icu::number::impl::DecimalFormatProperties::_equals( this,  (const icu::number::impl::DecimalFormatProperties *)&unk_18C449480,  1u);
}

void *icu::number::impl::DecimalFormatProperties::getDefault( icu::number::impl::DecimalFormatProperties *this)
{
  unsigned int v1 = atomic_load(&dword_18C449778);
  if (v1 != 2 && icu::umtx_initImplPreInit(&dword_18C449778))
  {
    icu::number::impl::DecimalFormatProperties::DecimalFormatProperties((icu::number::impl::DecimalFormatProperties *)&unk_18C449480);
    dword_18C44977C = 0;
    icu::umtx_initImplPostInit(&dword_18C449778);
  }

  return &unk_18C449480;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::notation@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 4) = *(void *)a2;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 8);
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 4) = *(void *)a2;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::unit@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 1);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4, a2);
}

{
  uint64_t v4;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 1);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4, a2);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::adoptUnit@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 16, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 16, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::perUnit@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4 + 40, a2);
}

{
  uint64_t v4;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4 + 40, a2);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::adoptPerUnit@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 40, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 40, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

__n128 icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::precision@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(v4 + 76) = result;
  return result;
}

{
  uint64_t v4;
  __n128 result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(v4 + 76) = result;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::roundingMode@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 96) = a2;
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 96) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::grouping@<X0>( uint64_t a1@<X0>, signed int a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter(a3, a1);
  uint64_t result = icu::number::impl::Grouper::forStrategy(a2);
  *(void *)(a3 + 100) = result;
  *(_DWORD *)(a3 + 108) = v6;
  return result;
}

{
  uint64_t result;
  int v6;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter(a3, a1);
  uint64_t result = icu::number::impl::Grouper::forStrategy(a2);
  *(void *)(a3 + 100) = result;
  *(_DWORD *)(a3 + 108) = v6;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::integerWidth@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 124) = *(void *)a2;
  *(_BYTE *)(result + 132) = *(_BYTE *)(a2 + 8);
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 124) = *(void *)a2;
  *(_BYTE *)(result + 132) = *(_BYTE *)(a2 + 8);
  return result;
}

icu::DecimalFormatSymbols *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::symbols@<X0>( uint64_t a1@<X0>, const icu::DecimalFormatSymbols *a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((icu::number::impl::SymbolsWrapper *)(v4 + 136), a2);
}

{
  uint64_t v4;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((icu::number::impl::SymbolsWrapper *)(v4 + 136), a2);
}

void *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::adoptSymbols@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((void *)(v4 + 136), a2);
}

{
  uint64_t v4;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((void *)(v4 + 136), a2);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::unitWidth@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 152) = a2;
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 152) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::sign@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 156) = a2;
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 156) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::decimal@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 164) = a2;
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 164) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::scale@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::Scale::operator=(v4 + 168, a2);
}

{
  uint64_t v4;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::Scale::operator=(v4 + 168, a2);
}

char *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::usage@<X0>( uint64_t a1@<X0>, const char *a2@<X1>, __int16 a3@<W2>, _OWORD *a4@<X8>)
{
  a4[28] = 0u;
  a4[29] = 0u;
  a4[26] = 0u;
  a4[27] = 0u;
  a4[24] = 0u;
  a4[25] = 0u;
  a4[22] = 0u;
  a4[23] = 0u;
  a4[20] = 0u;
  a4[21] = 0u;
  a4[18] = 0u;
  a4[19] = 0u;
  a4[16] = 0u;
  a4[17] = 0u;
  a4[14] = 0u;
  a4[15] = 0u;
  a4[13] = 0u;
  a4[10] = 0u;
  a4[11] = 0u;
  a4[8] = 0u;
  a4[9] = 0u;
  a4[6] = 0u;
  a4[7] = 0u;
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  a4[12] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 12);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

{
  uint64_t v6;
  a4[28] = 0u;
  a4[29] = 0u;
  a4[26] = 0u;
  a4[27] = 0u;
  a4[24] = 0u;
  a4[25] = 0u;
  a4[22] = 0u;
  a4[23] = 0u;
  a4[20] = 0u;
  a4[21] = 0u;
  a4[18] = 0u;
  a4[19] = 0u;
  a4[16] = 0u;
  a4[17] = 0u;
  a4[14] = 0u;
  a4[15] = 0u;
  a4[13] = 0u;
  a4[10] = 0u;
  a4[11] = 0u;
  a4[8] = 0u;
  a4[9] = 0u;
  a4[6] = 0u;
  a4[7] = 0u;
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  a4[12] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 12);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

char *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::displayOptions@<X0>( uint64_t a1@<X0>, unsigned int *a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  a3[13] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 13);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  if (!*a2) {
    return icu::number::impl::StringProp::set(v4, 0LL, 0);
  }
  GrammaticalCaseIdentifier = udispopt_getGrammaticalCaseIdentifier(*a2);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v7, GrammaticalCaseIdentifier);
  return icu::number::impl::StringProp::set(v4, v7, v8);
}

{
  uint64_t v4;
  const char *GrammaticalCaseIdentifier;
  const char *v7;
  uint64_t v8;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  a3[13] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 13);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  if (!*a2) {
    return icu::number::impl::StringProp::set(v4, 0LL, 0);
  }
  GrammaticalCaseIdentifier = udispopt_getGrammaticalCaseIdentifier(*a2);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v7, GrammaticalCaseIdentifier);
  return icu::number::impl::StringProp::set(v4, v7, v8);
}

char *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::unitDisplayCase@<X0>( uint64_t a1@<X0>, const char *a2@<X1>, __int16 a3@<W2>, _OWORD *a4@<X8>)
{
  a4[28] = 0u;
  a4[29] = 0u;
  a4[26] = 0u;
  a4[27] = 0u;
  a4[24] = 0u;
  a4[25] = 0u;
  a4[22] = 0u;
  a4[23] = 0u;
  a4[20] = 0u;
  a4[21] = 0u;
  a4[18] = 0u;
  a4[19] = 0u;
  a4[16] = 0u;
  a4[17] = 0u;
  a4[14] = 0u;
  a4[15] = 0u;
  a4[11] = 0u;
  a4[12] = 0u;
  a4[9] = 0u;
  a4[10] = 0u;
  a4[7] = 0u;
  a4[8] = 0u;
  a4[5] = 0u;
  a4[6] = 0u;
  a4[3] = 0u;
  a4[4] = 0u;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  a4[13] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 13);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

{
  uint64_t v6;
  a4[28] = 0u;
  a4[29] = 0u;
  a4[26] = 0u;
  a4[27] = 0u;
  a4[24] = 0u;
  a4[25] = 0u;
  a4[22] = 0u;
  a4[23] = 0u;
  a4[20] = 0u;
  a4[21] = 0u;
  a4[18] = 0u;
  a4[19] = 0u;
  a4[16] = 0u;
  a4[17] = 0u;
  a4[14] = 0u;
  a4[15] = 0u;
  a4[11] = 0u;
  a4[12] = 0u;
  a4[9] = 0u;
  a4[10] = 0u;
  a4[7] = 0u;
  a4[8] = 0u;
  a4[5] = 0u;
  a4[6] = 0u;
  a4[3] = 0u;
  a4[4] = 0u;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  a4[13] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 13);
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::padding@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 112) = *(void *)a2;
  *(_DWORD *)(result + 120) = *(_DWORD *)(a2 + 8);
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 112) = *(void *)a2;
  *(_DWORD *)(result + 120) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::threshold@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = a2;
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::forDateFormat@<X0>( uint64_t a1@<X0>, char a2@<W1>, _OWORD *a3@<X8>)
{
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_BYTE *)(result + 245) = a2;
  return result;
}

{
  uint64_t result;
  a3[28] = 0u;
  a3[29] = 0u;
  a3[26] = 0u;
  a3[27] = 0u;
  a3[24] = 0u;
  a3[25] = 0u;
  a3[22] = 0u;
  a3[23] = 0u;
  a3[20] = 0u;
  a3[21] = 0u;
  a3[18] = 0u;
  a3[19] = 0u;
  a3[16] = 0u;
  a3[17] = 0u;
  a3[14] = 0u;
  a3[15] = 0u;
  a3[12] = 0u;
  a3[13] = 0u;
  a3[10] = 0u;
  a3[11] = 0u;
  a3[8] = 0u;
  a3[9] = 0u;
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t result = icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)a3, a1);
  *(_BYTE *)(result + 245) = a2;
  return result;
}

icu::Locale *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::macros@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=( (icu::number::impl::SymbolsWrapper *)(a3 + 136),  (icu::number::impl::SymbolsWrapper *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=((icu::Locale *)(a3 + 248), a2 + 248);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=( (icu::number::impl::SymbolsWrapper *)(a3 + 136),  (icu::number::impl::SymbolsWrapper *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=((icu::Locale *)(a3 + 248), a2 + 248);
}

{
  return __ZNO3icu6number23NumberFormatterSettingsINS0_26UnlocalizedNumberFormatterEE6macrosERKNS0_4impl10MacroPropsE( a1,  a2,  a3);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::macros@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=(a3 + 136, (int *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=(a3 + 248, a2 + 248);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=(a3 + 136, (int *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=(a3 + 248, a2 + 248);
}

{
  return __ZNO3icu6number23NumberFormatterSettingsINS0_26UnlocalizedNumberFormatterEE6macrosEONS0_4impl10MacroPropsE( a1,  a2,  a3);
}

uint64_t *icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::clone@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x1E0, a2);
  if (result) {
    uint64_t result = (uint64_t *)icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)result, a1);
  }
  *a3 = (uint64_t)result;
  return result;
}

{
  uint64_t *result;
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x1E0, a2);
  if (result) {
    uint64_t result = (uint64_t *)icu::number::UnlocalizedNumberFormatter::UnlocalizedNumberFormatter((uint64_t)result, a1);
  }
  *a3 = (uint64_t)result;
  return result;
}

BOOL icu::number::NumberFormatterSettings<icu::number::UnlocalizedNumberFormatter>::copyErrorTo( uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 1LL;
  }
  sub_18092486C(a1, a2);
  return *a2 > 0;
}

uint64_t sub_18092486C(uint64_t a1, int *a2)
{
  if (*(_DWORD *)(a1 + 4) == 3)
  {
    int v2 = *(_DWORD *)(a1 + 8);
  }

  else if (*(_DWORD *)(a1 + 64) == 10)
  {
    int v2 = *(_DWORD *)(a1 + 72);
  }

  else if (*(_DWORD *)(a1 + 112) == -3)
  {
    int v2 = *(_DWORD *)(a1 + 116);
  }

  else if (*(_BYTE *)(a1 + 132))
  {
    int v2 = *(_DWORD *)(a1 + 124);
  }

  else
  {
    int v3 = *(_DWORD *)(a1 + 136);
    if ((v3 == 2 || v3 == 1) && !*(void *)(a1 + 144))
    {
      int v2 = 7;
    }

    else
    {
      int v2 = *(_DWORD *)(a1 + 184);
      if (v2 <= 0)
      {
        int v2 = *(_DWORD *)(a1 + 204);
        if (v2 <= 0)
        {
          int v2 = *(_DWORD *)(a1 + 220);
          if (v2 < 1) {
            return 0LL;
          }
        }
      }
    }
  }

  *a2 = v2;
  return 1LL;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::notation@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 4) = *(void *)a2;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 8);
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 4) = *(void *)a2;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unit@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 1);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4, a2);
}

{
  uint64_t v4;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 1);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4, a2);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::adoptUnit@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 16, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 16, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::perUnit@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4 + 40, a2);
}

{
  uint64_t v4;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::MeasureUnit::operator=(v4 + 40, a2);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::adoptPerUnit@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 40, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  if (a2)
  {
    icu::MeasureUnit::operator=(result + 40, a2);
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
  }

  return result;
}

__n128 icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::precision@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(v4 + 76) = result;
  return result;
}

{
  uint64_t v4;
  __n128 result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(v4 + 76) = result;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::roundingMode@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 96) = a2;
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 96) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::grouping@<X0>( uint64_t a1@<X0>, signed int a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 480) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter(a3, a1);
  uint64_t result = icu::number::impl::Grouper::forStrategy(a2);
  *(void *)(a3 + 100) = result;
  *(_DWORD *)(a3 + 108) = v6;
  return result;
}

{
  uint64_t result;
  int v6;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 480) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter(a3, a1);
  uint64_t result = icu::number::impl::Grouper::forStrategy(a2);
  *(void *)(a3 + 100) = result;
  *(_DWORD *)(a3 + 108) = v6;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::integerWidth@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 124) = *(void *)a2;
  *(_BYTE *)(result + 132) = *(_BYTE *)(a2 + 8);
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 124) = *(void *)a2;
  *(_BYTE *)(result + 132) = *(_BYTE *)(a2 + 8);
  return result;
}

icu::DecimalFormatSymbols *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::symbols@<X0>( uint64_t a1@<X0>, const icu::DecimalFormatSymbols *a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((icu::number::impl::SymbolsWrapper *)(v4 + 136), a2);
}

{
  uint64_t v4;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((icu::number::impl::SymbolsWrapper *)(v4 + 136), a2);
}

void *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::adoptSymbols@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((void *)(v4 + 136), a2);
}

{
  uint64_t v4;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::impl::SymbolsWrapper::setTo((void *)(v4 + 136), a2);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unitWidth@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 152) = a2;
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 152) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::sign@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 156) = a2;
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 156) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::decimal@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 164) = a2;
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 164) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::scale@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::Scale::operator=(v4 + 168, a2);
}

{
  uint64_t v4;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v4 = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  return icu::number::Scale::operator=(v4 + 168, a2);
}

char *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::usage@<X0>( uint64_t a1@<X0>, const char *a2@<X1>, __int16 a3@<W2>, _OWORD *a4@<X8>)
{
  a4[29] = 0u;
  a4[30] = 0u;
  a4[27] = 0u;
  a4[28] = 0u;
  a4[25] = 0u;
  a4[26] = 0u;
  a4[23] = 0u;
  a4[24] = 0u;
  a4[21] = 0u;
  a4[22] = 0u;
  a4[19] = 0u;
  a4[20] = 0u;
  a4[17] = 0u;
  a4[18] = 0u;
  a4[15] = 0u;
  a4[16] = 0u;
  a4[13] = 0u;
  a4[14] = 0u;
  a4[10] = 0u;
  a4[11] = 0u;
  a4[8] = 0u;
  a4[9] = 0u;
  a4[6] = 0u;
  a4[7] = 0u;
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  a4[12] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 12);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

{
  uint64_t v6;
  a4[29] = 0u;
  a4[30] = 0u;
  a4[27] = 0u;
  a4[28] = 0u;
  a4[25] = 0u;
  a4[26] = 0u;
  a4[23] = 0u;
  a4[24] = 0u;
  a4[21] = 0u;
  a4[22] = 0u;
  a4[19] = 0u;
  a4[20] = 0u;
  a4[17] = 0u;
  a4[18] = 0u;
  a4[15] = 0u;
  a4[16] = 0u;
  a4[13] = 0u;
  a4[14] = 0u;
  a4[10] = 0u;
  a4[11] = 0u;
  a4[8] = 0u;
  a4[9] = 0u;
  a4[6] = 0u;
  a4[7] = 0u;
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  a4[12] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 12);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

char *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::displayOptions@<X0>( uint64_t a1@<X0>, unsigned int *a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  a3[13] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 13);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  if (!*a2) {
    return icu::number::impl::StringProp::set(v4, 0LL, 0);
  }
  GrammaticalCaseIdentifier = udispopt_getGrammaticalCaseIdentifier(*a2);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v7, GrammaticalCaseIdentifier);
  return icu::number::impl::StringProp::set(v4, v7, v8);
}

{
  uint64_t v4;
  const char *GrammaticalCaseIdentifier;
  const char *v7;
  uint64_t v8;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  a3[13] = 0u;
  uint64_t v4 = (uint64_t)(a3 + 13);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  if (!*a2) {
    return icu::number::impl::StringProp::set(v4, 0LL, 0);
  }
  GrammaticalCaseIdentifier = udispopt_getGrammaticalCaseIdentifier(*a2);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v7, GrammaticalCaseIdentifier);
  return icu::number::impl::StringProp::set(v4, v7, v8);
}

char *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::unitDisplayCase@<X0>( uint64_t a1@<X0>, const char *a2@<X1>, __int16 a3@<W2>, _OWORD *a4@<X8>)
{
  a4[29] = 0u;
  a4[30] = 0u;
  a4[27] = 0u;
  a4[28] = 0u;
  a4[25] = 0u;
  a4[26] = 0u;
  a4[23] = 0u;
  a4[24] = 0u;
  a4[21] = 0u;
  a4[22] = 0u;
  a4[19] = 0u;
  a4[20] = 0u;
  a4[17] = 0u;
  a4[18] = 0u;
  a4[15] = 0u;
  a4[16] = 0u;
  a4[14] = 0u;
  a4[11] = 0u;
  a4[12] = 0u;
  a4[9] = 0u;
  a4[10] = 0u;
  a4[7] = 0u;
  a4[8] = 0u;
  a4[5] = 0u;
  a4[6] = 0u;
  a4[3] = 0u;
  a4[4] = 0u;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  a4[13] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 13);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

{
  uint64_t v6;
  a4[29] = 0u;
  a4[30] = 0u;
  a4[27] = 0u;
  a4[28] = 0u;
  a4[25] = 0u;
  a4[26] = 0u;
  a4[23] = 0u;
  a4[24] = 0u;
  a4[21] = 0u;
  a4[22] = 0u;
  a4[19] = 0u;
  a4[20] = 0u;
  a4[17] = 0u;
  a4[18] = 0u;
  a4[15] = 0u;
  a4[16] = 0u;
  a4[14] = 0u;
  a4[11] = 0u;
  a4[12] = 0u;
  a4[9] = 0u;
  a4[10] = 0u;
  a4[7] = 0u;
  a4[8] = 0u;
  a4[5] = 0u;
  a4[6] = 0u;
  a4[3] = 0u;
  a4[4] = 0u;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  a4[13] = 0u;
  uint64_t v6 = (uint64_t)(a4 + 13);
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a4, a1);
  return icu::number::impl::StringProp::set(v6, a2, a3);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::padding@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 112) = *(void *)a2;
  *(_DWORD *)(result + 120) = *(_DWORD *)(a2 + 8);
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(void *)(result + 112) = *(void *)a2;
  *(_DWORD *)(result + 120) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::threshold@<X0>( uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = a2;
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_DWORD *)(result + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = a2;
  return result;
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::forDateFormat@<X0>( uint64_t a1@<X0>, char a2@<W1>, _OWORD *a3@<X8>)
{
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_BYTE *)(result + 245) = a2;
  return result;
}

{
  uint64_t result;
  a3[29] = 0u;
  a3[30] = 0u;
  a3[27] = 0u;
  a3[28] = 0u;
  a3[25] = 0u;
  a3[26] = 0u;
  a3[23] = 0u;
  a3[24] = 0u;
  a3[21] = 0u;
  a3[22] = 0u;
  a3[19] = 0u;
  a3[20] = 0u;
  a3[17] = 0u;
  a3[18] = 0u;
  a3[15] = 0u;
  a3[16] = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t result = icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)a3, a1);
  *(_BYTE *)(result + 245) = a2;
  return result;
}

icu::Locale *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::macros@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 480) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=( (icu::number::impl::SymbolsWrapper *)(a3 + 136),  (icu::number::impl::SymbolsWrapper *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=((icu::Locale *)(a3 + 248), a2 + 248);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 480) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=( (icu::number::impl::SymbolsWrapper *)(a3 + 136),  (icu::number::impl::SymbolsWrapper *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=((icu::Locale *)(a3 + 248), a2 + 248);
}

uint64_t icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::macros@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 480) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=(a3 + 136, (int *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=(a3 + 248, a2 + 248);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 480) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 2icu::number::impl::DecimalQuantity::ensureCapacity(this, 40) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  uint64_t v5 = a3 + 208;
  *(_OWORD *)(a3 + 192) = 0u;
  uint64_t v6 = a3 + 192;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v7 = a3 + 16;
  icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter(a3, a1);
  *(void *)(a3 + 4) = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  icu::MeasureUnit::operator=(v7, a2 + 16);
  icu::MeasureUnit::operator=(a3 + 40, a2 + 40);
  __int128 v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a3 + 112) = v8;
  *(void *)(a3 + 125) = *(void *)(a2 + 125);
  __int128 v9 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v9;
  icu::number::impl::SymbolsWrapper::operator=(a3 + 136, (int *)(a2 + 136));
  *(_OWORD *)(a3 + 152) = *(_OWORD *)(a2 + 152);
  icu::number::Scale::operator=(a3 + 168, a2 + 168);
  icu::number::impl::StringProp::operator=(v6, a2 + 192);
  icu::number::impl::StringProp::operator=(v5, a2 + 208);
  *(_OWORD *)(a3 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a3 + 238) = *(void *)(a2 + 238);
  return icu::Locale::operator=(a3 + 248, a2 + 248);
}

uint64_t *icu::number::NumberFormatterSettings<icu::number::LocalizedNumberFormatter>::clone@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x1F0, a2);
  if (result) {
    uint64_t result = (uint64_t *)icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)result, a1);
  }
  *a3 = (uint64_t)result;
  return result;
}

{
  uint64_t *result;
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x1F0, a2);
  if (result) {
    uint64_t result = (uint64_t *)icu::number::LocalizedNumberFormatter::LocalizedNumberFormatter((uint64_t)result, a1);
  }
  *a3 = (uint64_t)result;
  return result;
}