uint64_t uloc_getBaseName(char *a1, char *a2, int a3, UErrorCode *a4)
{
  uint64_t v4;
  __int128 v10;
  __int128 v11;
  v10 = 0u;
  v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18084EB3C(a1, (uint64_t)&v10, 2, a4);
  v4 = DWORD2(v11);
  if (*(int *)a4 <= 0)
  {
    if (BYTE12(v11)) {
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), (int *)a4);
    }
  }

  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

void ulocimp_getBaseName(char *a1, uint64_t a2, UErrorCode *a3)
{
}

uint64_t uloc_canonicalize(char *a1, char *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0LL;
  }
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18084EB3C(a1);
  uint64_t v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11)) {
      *a4 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
    }
  }

  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

uint64_t ulocimp_canonicalize(char *a1)
{
  return sub_18084EB3C(a1);
}

uint64_t ualoc_canonicalForm(icu::Locale *a1, void *a2, int a3, int *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (*a4 > 0) {
    return 0LL;
  }
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  *(_OWORD *)__s = 0u;
  __int128 v14 = 0u;
  memset(v12, 0, sizeof(v12));
  icu::Locale::createCanonical(a1, (icu::Locale *)v12);
  v8 = __s[1];
  size_t v9 = strlen(__s[1]);
  int v10 = uprv_min(v9, a3);
  memcpy(a2, v8, v10);
  uint64_t v4 = u_terminateChars((uint64_t)a2, a3, v9, a4);
  icu::Locale::~Locale((icu::Locale *)v12);
  return v4;
}

char *uloc_getISO3Language(uint64_t Default_0)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  int v3 = 0;
  if (!Default_0) {
    Default_0 = uloc_getDefault_0(0LL);
  }
  int v5 = 0;
  *(void *)__s1 = 0LL;
  uloc_getLanguage(Default_0, __s1, 12, &v3);
  if (v3 > 0) {
    return "";
  }
  int v2 = sub_18084D948((const char **)off_1897188E8, __s1);
  if (v2 < 0) {
    return "";
  }
  else {
    return off_189717560[(unsigned __int16)v2];
  }
}

char *uloc_getISO3Country(uint64_t Default_0)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  int v3 = 0;
  if (!Default_0) {
    Default_0 = uloc_getDefault_0(0LL);
  }
  int v5 = 0;
  *(void *)__s1 = 0LL;
  uloc_getCountry(Default_0, __s1, 12, &v3);
  if (v3 > 0) {
    return "";
  }
  int v2 = sub_18084D948((const char **)off_18971A4D8, __s1);
  if (v2 < 0) {
    return "";
  }
  else {
    return off_189719C70[(unsigned __int16)v2];
  }
}

uint64_t uloc_getLCID(char *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v9 = 0;
  if (!a1 || strlen(a1) < 2) {
    return 0LL;
  }
  memset(v22, 0, 157);
  uint64_t v2 = uprv_convertToLCIDPlatform();
  uint64_t v3 = v2;
  if (!(_DWORD)v2)
  {
    uloc_getLanguage((uint64_t)a1, v22, 157, &v9);
    if (v9 <= 0 && v9 != -124)
    {
      if (!strchr(a1, 64)) {
        return uprv_convertToLCID(v22, a1, &v9);
      }
      __int128 v20 = 0u;
      memset(v21, 0, sizeof(v21));
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      *(_OWORD *)__s = 0u;
      memset(v11, 0, sizeof(v11));
      uint64_t v12 = 0LL;
      *(void *)int v10 = (char *)v11 + 5;
      LODWORD(v11[0]) = 40;
      v8[0] = 0LL;
      v8[1] = 0LL;
      icu::CharStringByteSink::CharStringByteSink(v8, (uint64_t)v10);
      ulocimp_getKeywordValue(a1, "collation", (uint64_t)v8, &v9);
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v8);
      if (v9 > 0) {
        goto LABEL_17;
      }
      if ((_DWORD)v12
        && (int BaseName = uloc_getBaseName(a1, __s, 156, (UErrorCode *)&v9), v9 <= 0)
        && BaseName >= 1
        && (__s[BaseName] = 0, int v6 = uloc_setKeywordValue("collation", *(_BYTE **)v10, __s, 156 - BaseName, &v9), v9 <= 0)
        && v6 >= 1)
      {
        __s[v6] = 0;
        uint64_t v3 = uprv_convertToLCID(v22, __s, &v9);
        int v7 = 0;
      }

      else
      {
LABEL_17:
        int v9 = 0;
        int v7 = 1;
      }

      if (BYTE4(v11[0])) {
        uprv_free(*(void **)v10);
      }
      if (v7) {
        return uprv_convertToLCID(v22, a1, &v9);
      }
    }
  }

  return v3;
}

char *uloc_setDefault(char *a1, int *a2)
{
  if (*a2 <= 0) {
    return (char *)sub_1807D9604(a1);
  }
  return a1;
}

char **uloc_getISOLanguages()
{
  return off_1897188E8;
}

char **uloc_getISOCountries()
{
  return off_18971A4D8;
}

char *uloc_toUnicodeLocaleKey(uint64_t a1)
{
  v1 = (char *)a1;
  uint64_t v2 = sub_18084FA80(a1);
  if (v2 || !sub_18085136C(v1, -1)) {
    return (char *)v2;
  }
  return v1;
}

char *uloc_toUnicodeLocaleType(uint64_t a1, char *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = sub_180850588(a1, a2, 0LL, 0LL);
  if (v3 || !sub_1808512B8(v2, -1)) {
    return (char *)v3;
  }
  return v2;
}

uint64_t uloc_toLegacyKey(char *a1)
{
  uint64_t result = sub_180850544((uint64_t)a1);
  if (!result)
  {
    char v3 = *a1;
    if (*a1)
    {
      uint64_t v4 = (unsigned __int8 *)(a1 + 1);
      while (uprv_isASCIILetter(v3) || *(v4 - 1) - 48 <= 9)
      {
        int v5 = *v4++;
        char v3 = v5;
        if (!v5) {
          return (uint64_t)a1;
        }
      }

      return 0LL;
    }

    else
    {
      return (uint64_t)a1;
    }
  }

  return result;
}

uint64_t uloc_toLegacyType(uint64_t a1, _BYTE *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = sub_1808507C4(a1, a2, 0LL, 0LL);
  if (v3) {
    return v3;
  }
  int v5 = 0;
  for (i = v2; ; ++i)
  {
    int v7 = *i;
    if ((v7 - 45) <= 0x32 && ((1LL << (v7 - 45)) & 0x4000000000005LL) != 0)
    {
      if (!v5) {
        return v3;
      }
      int v5 = 0;
      continue;
    }

    if (!*i) {
      break;
    }
    ++v5;
  }

  if (!v5) {
    return v3;
  }
  return (uint64_t)v2;
}

void sub_18084F988(void ***a1)
{
}

uint64_t sub_18084F9BC(uint64_t a1)
{
  v1 = **(const char ***)(a1 + 8);
  if (!*v1) {
    return 0LL;
  }
  LODWORD(v2) = 0;
  do
  {
    uint64_t v2 = (v2 + 1);
    uint64_t v3 = &v1[strlen(v1)];
    int v4 = *((unsigned __int8 *)v3 + 1);
    v1 = v3 + 1;
  }

  while (v4);
  return v2;
}

_BYTE *sub_18084FA0C(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_BYTE **)(v3 + 8);
  if (!*v4)
  {
    int v4 = 0LL;
    int v5 = 0;
    if (!a2) {
      return v4;
    }
    goto LABEL_3;
  }

  int v5 = strlen(*(const char **)(v3 + 8));
  *(void *)(v3 + 8) = &v4[v5 + 1];
  if (a2) {
LABEL_3:
  }
    *a2 = v5;
  return v4;
}

uint64_t sub_18084FA70(uint64_t result)
{
  *(void *)(*(void *)(result + 8) + 8LL) = **(void **)(result + 8);
  return result;
}

uint64_t sub_18084FA80(uint64_t a1)
{
  if (!sub_18084FAC4()) {
    return 0LL;
  }
  uint64_t result = uhash_get(qword_18C4491D0, a1);
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

BOOL sub_18084FAC4()
{
  uint64_t v85 = *MEMORY[0x1895F89C0];
  UErrorCode v70 = U_ZERO_ERROR;
  unsigned int v0 = atomic_load(&dword_18C4491D8);
  if (v0 == 2 || !icu::umtx_initImplPreInit(&dword_18C4491D8))
  {
    if (dword_18C4491DC >= 1) {
      UErrorCode v70 = dword_18C4491DC;
    }
    return v70 < U_ILLEGAL_ARGUMENT_ERROR;
  }

  sub_180820C94(6u, (uint64_t)sub_1808508B0);
  qword_18C4491D0 = (uint64_t)uhash_open((uint64_t)uhash_hashIChars, (uint64_t)uhash_compareIChars, 0LL, (int *)&v70);
  uint64_t v1 = ures_openDirect(0LL, (uint64_t)"keyTypeData", (uint64_t)&v70);
  uint64_t v2 = ures_getByKey(v1, "keyMap", 0LL, (int *)&v70);
  uint64_t v3 = ures_getByKey(v1, "typeMap", 0LL, (int *)&v70);
  if (v70 > U_ZERO_ERROR) {
    goto LABEL_147;
  }
  int v72 = 0;
  uint64_t v4 = ures_getByKey(v1, "typeAlias", 0LL, &v72);
  int v72 = 0;
  uint64_t v5 = ures_getByKey(v1, "bcpTypeAlias", 0LL, &v72);
  uint64_t v7 = icu::UMemory::operator new((icu::UMemory *)0x58, v6);
  if (!v7)
  {
    qword_18C4491E0 = 0LL;
LABEL_142:
    UErrorCode v70 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_143;
  }

  *(_DWORD *)uint64_t v7 = 0;
  *(void *)(v7 + 8) = v7 + 24;
  *(_DWORD *)(v7 + 16) = 8;
  *(_BYTE *)(v7 + 20) = 0;
  qword_18C4491E0 = v7;
  uint64_t v9 = icu::UMemory::operator new((icu::UMemory *)0x58, v8);
  if (!v9)
  {
    qword_18C4491E8 = 0LL;
    goto LABEL_142;
  }

  *(_DWORD *)uint64_t v9 = 0;
  *(void *)(v9 + 8) = v9 + 24;
  *(_DWORD *)(v9 + 16) = 8;
  *(_BYTE *)(v9 + 20) = 0;
  qword_18C4491E8 = v9;
  uint64_t v11 = icu::UMemory::operator new((icu::UMemory *)0x58, v10);
  if (!v11)
  {
    qword_18C4491F0 = 0LL;
    goto LABEL_142;
  }

  uint64_t v12 = 0LL;
  *(_DWORD *)uint64_t v11 = 0;
  *(void *)(v11 + 8) = v11 + 24;
  *(_DWORD *)(v11 + 16) = 8;
  *(_BYTE *)(v11 + 20) = 0;
  qword_18C4491F0 = v11;
  uint64_t v62 = v4;
  uint64_t v63 = v5;
  uint64_t v61 = v3;
  do
  {
    if (!ures_hasNext(v2)) {
      break;
    }
    NextResource = ures_getNextResource(v2, v12, (int *)&v70);
    uint64_t v12 = (uint64_t)NextResource;
    if (v70 > U_ZERO_ERROR) {
      break;
    }
    Key = (const char *)ures_getKey((uint64_t)NextResource);
    uint64_t v84 = 0LL;
    __int128 v82 = 0u;
    __int128 v83 = 0u;
    __int128 v81 = 0u;
    v80 = off_18971B688;
    LOWORD(v81) = 2;
    LODWORD(v73) = 0;
    String = ures_getString(v12, (int *)&v73, (int *)&v70);
    if (v70 <= U_ZERO_ERROR)
    {
      v75 = String;
      icu::UnicodeString::setTo((icu::UnicodeString *)&v80, 1, &v75, (int)v73);
    }

    else
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)&v80);
    }

    if (v70 > U_ZERO_ERROR) {
      goto LABEL_156;
    }
    __int128 v17 = Key;
    if ((unsigned __int16)v81 >= 0x20u)
    {
      __int128 v18 = (icu::CharString *)sub_180850934((const void **)qword_18C4491E0, v16);
      if (!v18)
      {
        UErrorCode v70 = U_MEMORY_ALLOCATION_ERROR;
LABEL_156:
        icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v80);
        break;
      }

      __int128 v19 = (const char **)v18;
      icu::CharString::appendInvariantChars(v18, (const icu::UnicodeString *)&v80, &v70);
      if (v70 > U_ZERO_ERROR) {
        goto LABEL_156;
      }
      __int128 v17 = *v19;
    }

    int v67 = strcmp(Key, "timezone");
    v66 = uhash_open((uint64_t)uhash_hashIChars, (uint64_t)uhash_compareIChars, 0LL, (int *)&v70);
    if (v70 > U_ZERO_ERROR) {
      goto LABEL_156;
    }
    if (v4)
    {
      int v72 = 0;
      uint64_t v20 = ures_getByKey(v4, Key, 0LL, &v72);
      if (v72 >= 1) {
        uint64_t v21 = 0LL;
      }
      else {
        uint64_t v21 = v20;
      }
      uint64_t v69 = v21;
    }

    else
    {
      uint64_t v69 = 0LL;
    }

    uint64_t v65 = (uint64_t)v17;
    if (v5)
    {
      int v72 = 0;
      uint64_t v22 = ures_getByKey(v5, v17, 0LL, &v72);
      if (v72 >= 1) {
        uint64_t v23 = 0LL;
      }
      else {
        uint64_t v23 = v22;
      }
      uint64_t v68 = v23;
    }

    else
    {
      uint64_t v68 = 0LL;
    }

    uint64_t v24 = ures_getByKey(v3, Key, 0LL, (int *)&v70);
    if (v70 > U_ZERO_ERROR)
    {
      int v25 = 3;
      goto LABEL_128;
    }

    uint64_t v26 = 0LL;
    int v27 = 0;
    do
    {
      if (!ures_hasNext(v24)) {
        break;
      }
      v29 = ures_getNextResource(v24, v26, (int *)&v70);
      uint64_t v26 = (uint64_t)v29;
      if (v70 > U_ZERO_ERROR) {
        break;
      }
      __s = 0LL;
      v30 = (char *)ures_getKey((uint64_t)v29);
      __s = v30;
      if (!strcmp(v30, "CODEPOINTS"))
      {
        v27 |= 1u;
      }

      else if (!strcmp(v30, "REORDER_CODE"))
      {
        v27 |= 2u;
      }

      else
      {
        if (strcmp(v30, "RG_KEY_VALUE"))
        {
          if (!v67 && strchr(v30, 58))
          {
            uint64_t v31 = sub_180850A1C((int *)qword_18C4491E0, (const char **)&__s, &v70);
            if (!v31)
            {
              UErrorCode v70 = U_MEMORY_ALLOCATION_ERROR;
              break;
            }

            if (v70 > U_ZERO_ERROR) {
              break;
            }
            v32 = *(char **)v31;
            uint64_t v33 = *(int *)(v31 + 56);
            if ((_DWORD)v33)
            {
              do
              {
                if (*v32 == 58) {
                  char *v32 = 47;
                }
                ++v32;
                --v33;
              }

              while (v33);
              v32 = *(char **)v31;
            }

            __s = v32;
          }

          uint64_t v79 = 0LL;
          __int128 v77 = 0u;
          __int128 v78 = 0u;
          __int128 v76 = 0u;
          v75 = (const UChar *)off_18971B688;
          LOWORD(v76) = 2;
          int v74 = 0;
          v34 = (const char *)ures_getString(v26, &v74, (int *)&v70);
          if (v70 <= U_ZERO_ERROR)
          {
            v73 = (const UChar *)v34;
            icu::UnicodeString::setTo((icu::UnicodeString *)&v75, 1, &v73, v74);
          }

          else
          {
            icu::UnicodeString::setToBogus((icu::UnicodeString *)&v75);
          }

          if (v70 > U_ZERO_ERROR)
          {
LABEL_57:
            int v36 = 5;
            goto LABEL_91;
          }

          v64 = Key;
          if ((unsigned __int16)v76 < 0x20u)
          {
            p_s = &__s;
            goto LABEL_63;
          }

          v37 = (icu::CharString *)sub_180850934((const void **)qword_18C4491E0, v35);
          if (v37)
          {
            p_s = (char **)v37;
            icu::CharString::appendInvariantChars(v37, (const icu::UnicodeString *)&v75, &v70);
            if (v70 > U_ZERO_ERROR) {
              goto LABEL_90;
            }
LABEL_63:
            v39 = *p_s;
            v40 = sub_180850B44((const void **)qword_18C4491F0, v35);
            if (v40)
            {
              uint64_t v41 = (uint64_t)v40;
              void *v40 = __s;
              v40[1] = v39;
              uhash_put((uint64_t)v66, (uint64_t)__s, (uint64_t)v40, (int *)&v70);
              if (v39 != __s) {
                uhash_put((uint64_t)v66, (uint64_t)v39, v41, (int *)&v70);
              }
              uint64_t v59 = v41;
              v60 = v39;
              if (v70 <= U_ZERO_ERROR)
              {
                Key = v64;
                uint64_t v3 = v61;
                if (v69)
                {
                  ures_resetIterator(v69);
                  if (ures_hasNext(v69) && v70 <= U_ZERO_ERROR)
                  {
                    v42 = 0LL;
                    do
                    {
                      int v74 = 0;
                      v42 = ures_getNextResource(v69, (uint64_t)v42, (int *)&v70);
                      v43 = (UChar *)ures_getString((uint64_t)v42, &v74, (int *)&v70);
                      UErrorCode v44 = v70;
                      if (v70 > U_ZERO_ERROR) {
                        break;
                      }
                      if (!sub_18084AAE0(0, __s, -1, v43, v74))
                      {
                        v73 = 0LL;
                        v45 = (const char *)ures_getKey((uint64_t)v42);
                        v46 = (char *)v45;
                        v73 = (const UChar *)v45;
                        if (!v67 && strchr(v45, 58))
                        {
                          uint64_t v47 = sub_180850A1C((int *)qword_18C4491E0, (const char **)&v73, &v70);
                          if (!v47)
                          {
                            UErrorCode v44 = U_MEMORY_ALLOCATION_ERROR;
                            UErrorCode v70 = U_MEMORY_ALLOCATION_ERROR;
                            if (!v42) {
                              goto LABEL_97;
                            }
LABEL_87:
                            ures_close((uint64_t)v42);
                            if (v44 >= U_ILLEGAL_ARGUMENT_ERROR) {
                              goto LABEL_57;
                            }
                            goto LABEL_98;
                          }

                          UErrorCode v44 = v70;
                          if (v70 > U_ZERO_ERROR) {
                            break;
                          }
                          v46 = *(char **)v47;
                          uint64_t v48 = *(int *)(v47 + 56);
                          if ((_DWORD)v48)
                          {
                            do
                            {
                              if (*v46 == 58) {
                                char *v46 = 47;
                              }
                              ++v46;
                              --v48;
                            }

                            while (v48);
                            v46 = *(char **)v47;
                          }

                          v73 = (const UChar *)v46;
                        }

                        uhash_put((uint64_t)v66, (uint64_t)v46, v59, (int *)&v70);
                      }

                      BOOL hasNext = ures_hasNext(v69);
                      UErrorCode v44 = v70;
                    }

                    while (hasNext && v70 < U_ILLEGAL_ARGUMENT_ERROR);
                    if (v42) {
                      goto LABEL_87;
                    }
LABEL_97:
                    if (v44 > U_ZERO_ERROR) {
                      goto LABEL_57;
                    }
                  }

                  else if (v70 >= U_ILLEGAL_ARGUMENT_ERROR)
                  {
                    goto LABEL_57;
                  }
                }

LABEL_98:
                if (v68)
                {
                  ures_resetIterator(v68);
                  if (ures_hasNext(v68) && v70 <= U_ZERO_ERROR)
                  {
                    v50 = 0LL;
                    do
                    {
                      LODWORD(v73) = 0;
                      v50 = ures_getNextResource(v68, (uint64_t)v50, (int *)&v70);
                      v51 = (UChar *)ures_getString((uint64_t)v50, (int *)&v73, (int *)&v70);
                      UErrorCode v52 = v70;
                      if (v70 >= U_ILLEGAL_ARGUMENT_ERROR) {
                        break;
                      }
                      if (!sub_18084AAE0(0, v60, -1, v51, (int)v73))
                      {
                        uint64_t v53 = ures_getKey((uint64_t)v50);
                        uhash_put((uint64_t)v66, v53, v59, (int *)&v70);
                      }

                      BOOL v54 = ures_hasNext(v68);
                      UErrorCode v52 = v70;
                      if (!v54) {
                        break;
                      }
                    }

                    while (v70 < U_ILLEGAL_ARGUMENT_ERROR);
                    if (v50)
                    {
                      ures_close((uint64_t)v50);
                      if (v52 >= U_ILLEGAL_ARGUMENT_ERROR) {
                        goto LABEL_57;
                      }
                    }

                    else if (v52 > U_ZERO_ERROR)
                    {
                      goto LABEL_57;
                    }
                  }

                  else if (v70 >= U_ILLEGAL_ARGUMENT_ERROR)
                  {
                    goto LABEL_57;
                  }
                }

                int v36 = 0;
LABEL_91:
                icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v75);
                continue;
              }

  if (v27)
  {
    do
    {
      v43 = (const char **)v27[1];
      uprv_free(v27);
      int v27 = v43;
    }

    while (v43);
  }

  __int128 v15 = v92;
LABEL_101:
  UErrorCode v44 = (char *)v109[0];
  LODWORD(v117) = 0;
  v115 = 0u;
  v116 = 0u;
  memset(__s, 0, sizeof(__s));
  v108 = 0;
  v104 = 0LL;
  memset(v106, 0, sizeof(v106));
  v107 = 0LL;
  v105 = &v106[2];
  v106[0] = 8;
  v103[0] = 0LL;
  memset(&v103[2], 0, 72);
  v103[1] = &v103[3];
  LODWORD(v103[2]) = 8;
  v102[0] = 0LL;
  memset(&v102[2], 0, 72);
  v102[1] = &v102[3];
  LODWORD(v102[2]) = 8;
  v45 = (void **)uloc_openKeywords((char *)v109[0], a4);
  v46 = v45;
  v101 = 0;
  v99 = 0LL;
  v100 = 0LL;
  v98[0] = 0LL;
  memset(&v98[2], 0, 72);
  v98[1] = &v98[3];
  LODWORD(v98[2]) = 8;
  v97 = 0;
  uint64_t v47 = uenum_next((uint64_t)v45, 0LL, a4);
  if (!v47) {
    goto LABEL_179;
  }
  v49 = (char *)v47;
  v91 = 0LL;
  v93 = 0LL;
  while (2)
  {
    v113 = 0LL;
    memset(&v112[1], 0, 48);
    v112[0] = (char *)&v112[1] + 5;
    LODWORD(v112[1]) = 40;
    v96[0] = 0LL;
    v96[1] = 0LL;
    icu::CharStringByteSink::CharStringByteSink(v96, (uint64_t)v112);
    ulocimp_getKeywordValue(v44, v49, (uint64_t)v96, &v97);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v96);
    v50 = v113;
    v101 = v113;
    v51 = v97;
    if (v97 >= 1)
    {
      if (v97 != 7)
      {
        if (v94) {
          goto LABEL_109;
        }
        v97 = 0;
LABEL_149:
        UErrorCode v52 = 2;
        goto LABEL_111;
      }

        unint64_t v10 = 0;
        uint64_t v9 = v9 - sub_180864178((unsigned __int8 **)&v54);
      }
    }

    else
    {
      v46 = icu::UnicodeSet::spanBackUTF8(v52, s);
      __int128 v14 = v46;
      if (!(_DWORD)v46) {
        goto LABEL_118;
      }
      unint64_t v10 = v9 - v46;
      uint64_t v9 = v46;
      if (!v10) {
        goto LABEL_118;
      }
    }
  }

  if (HIDWORD(v55)) {
    goto LABEL_98;
  }
  __int128 v14 = v9;
LABEL_118:
  v29 = (char *)v54;
LABEL_119:
  return v14;
}

        v45 = 1;
        goto LABEL_99;
      }

            *a3 = 9;
            return icu::UnicodeString::~UnicodeString((void *)9, (icu::UnicodeString *)&v60);
          }
        }

        v32 = icu::PatternProps::isWhiteSpace((icu::PatternProps *)v30);
        if ((v30 & 0xFFFFFFFD) != 0x2C && !v32) {
          goto LABEL_98;
        }
LABEL_55:
        if (v19 == ++v26) {
          goto LABEL_64;
        }
      }
    }

    uint64_t v33 = icu::UnicodeString::doCompare((uint64_t)&v60, 0, v23, (uint64_t)"-", 0, 2);
    v57 = "-";
    v34 = (uint64_t)&v57;
    if (!v33)
    {
      v34 = -1LL;
      *(void *)a1 = -1LL;
      goto LABEL_112;
    }

    if ((_DWORD)v19 != 3) {
      goto LABEL_112;
    }
    if (v21 == 48 && v25 == 120)
    {
      unint64_t v35 = -3LL;
LABEL_102:
      *(void *)a1 = v35;
      *(_DWORD *)(a1 + 8) = 10;
      *(_WORD *)(a1 + 12) = 0;
      if ((v61 & 0x8000u) == 0LL) {
        v49 = (unsigned __int16)v61 >> 5;
      }
      else {
        v49 = DWORD1(v61);
      }
      if (v49 < 2)
      {
        v34 = 0xFFFFLL;
      }

      else
      {
        if ((v61 & 2) != 0) {
          v50 = (unsigned __int16 *)&v61 + 2;
        }
        else {
          v50 = (unsigned __int16 *)(v62 + 2);
        }
        v34 = *v50;
      }

      *(_WORD *)(a1 + 14) = v34;
      goto LABEL_112;
    }

    if (v21 == 120 && v25 == 120)
    {
      unint64_t v35 = -2LL;
      goto LABEL_102;
    }

    if (v21 == 120 && v25 == 48)
    {
      unint64_t v35 = -4LL;
      goto LABEL_102;
    }

    uint64_t v59 = L"NaN";
    uint64_t v53 = sub_1807C3C7C((uint64_t)&v60, (uint64_t *)&v59, 3);
    v56[1] = v59;
    if (v53)
    {
      v58 = L"Inf";
      BOOL v54 = sub_1807C3C7C((uint64_t)&v60, (uint64_t *)&v58, 3);
      v56[0] = v58;
      v34 = (uint64_t)v56;
      if (v54) {
        goto LABEL_112;
      }
      v55 = -5LL;
    }

    else
    {
      v55 = -6LL;
    }

    *(void *)a1 = v55;
    v34 = 10LL;
    *(_DWORD *)(a1 + 8) = 10;
    *(_WORD *)(a1 + 12) = 0;
LABEL_112:
    uint64_t result = icu::UnicodeString::~UnicodeString((void *)v34, (icu::UnicodeString *)&v60);
  }

  v51 = *(unsigned __int16 *)(a2 + 8);
  if (*(__int16 *)(a2 + 8) < 0)
  {
  }

  else if (v51 < 0x20)
  {
    return result;
  }

  if ((v51 & 2) != 0) {
    UErrorCode v52 = (_WORD *)(a2 + 10);
  }
  else {
    UErrorCode v52 = *(_WORD **)(a2 + 24);
  }
  if (*v52 == 39) {
    return (void *)icu::UnicodeString::doReplace(a2, 0LL, 1LL, 0LL, 0, 0LL);
  }
  return result;
}

uint64_t sub_180850544(uint64_t a1)
{
  if (!sub_18084FAC4()) {
    return 0LL;
  }
  uint64_t result = uhash_get(qword_18C4491D0, a1);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_180850588(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (!sub_18084FAC4()) {
    return 0LL;
  }
  uint64_t result = uhash_get(qword_18C4491D0, a1);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  if (a3) {
    *a3 = 1;
  }
  uint64_t v10 = uhash_get(*(void *)(result + 16), (uint64_t)a2);
  if (v10) {
    return *(void *)(v10 + 8);
  }
  int v11 = *(_DWORD *)(v9 + 24);
  if (!v11) {
    return 0LL;
  }
  if ((v11 & 1) != 0 && sub_180850674(a2))
  {
LABEL_16:
    if (!a4) {
      return (uint64_t)a2;
    }
    goto LABEL_27;
  }

  if ((v11 & 2) != 0)
  {
    if (sub_1808506E8(a2)) {
      goto LABEL_16;
    }
    int v11 = *(_DWORD *)(v9 + 24);
  }

  if ((v11 & 4) == 0) {
    return 0LL;
  }
  BOOL v12 = sub_180850758(a2);
  if (v12) {
    uint64_t result = (uint64_t)a2;
  }
  else {
    uint64_t result = 0LL;
  }
  if (a4 && v12)
  {
LABEL_27:
    *a4 = 1;
    return (uint64_t)a2;
  }

  return result;
}

BOOL sub_180850674(_BYTE *a1)
{
  int v1 = 0;
  while (1)
  {
    int v2 = *a1;
    if (v2 != 45) {
      break;
    }
    unsigned int v7 = v1 - 7;
    int v1 = 0;
    if (v7 < 0xFFFFFFFD) {
      return 0LL;
    }
LABEL_11:
    ++a1;
  }

  if (!*a1) {
    return (v1 - 4) < 3;
  }
  if ((v2 - 48) < 0xA
    || ((v3 = v2 - 65, BOOL v4 = v3 > 0x25, v5 = (1LL << v3) & 0x3F0000003FLL, !v4) ? (v6 = v5 == 0) : (v6 = 1), !v6))
  {
    ++v1;
    goto LABEL_11;
  }

  return 0LL;
}

BOOL sub_1808506E8(_BYTE *a1)
{
  int v2 = 0;
  while (1)
  {
    int v3 = *a1;
    if (v3 == 45) {
      break;
    }
    if (!*a1) {
      return (v2 - 3) < 6;
    }
    BOOL result = uprv_isASCIILetter(v3);
    if (!result) {
      return result;
    }
    ++v2;
LABEL_7:
    ++a1;
  }

  unsigned int v5 = v2 - 9;
  int v2 = 0;
  if (v5 >= 0xFFFFFFFA) {
    goto LABEL_7;
  }
  return 0LL;
}

BOOL sub_180850758(_BYTE *a1)
{
  LOBYTE(v1) = *a1;
  if (!*a1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  int v3 = a1 + 1;
  do
  {
    if (v2 > 1)
    {
    }

    else
    {
      BOOL result = uprv_isASCIILetter(v1);
      if (!result) {
        return result;
      }
    }

    int v1 = v3[v2++];
  }

  while (v1);
  return (_DWORD)v2 == 6;
}

uint64_t sub_1808507C4(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (!sub_18084FAC4()) {
    return 0LL;
  }
  uint64_t result = uhash_get(qword_18C4491D0, a1);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  if (a3) {
    *a3 = 1;
  }
  uint64_t v10 = uhash_get(*(void *)(result + 16), (uint64_t)a2);
  if (v10) {
    return *(void *)v10;
  }
  int v11 = *(_DWORD *)(v9 + 24);
  if (!v11) {
    return 0LL;
  }
  if ((v11 & 1) != 0 && sub_180850674(a2))
  {
LABEL_16:
    if (!a4) {
      return (uint64_t)a2;
    }
    goto LABEL_27;
  }

  if ((v11 & 2) != 0)
  {
    if (sub_1808506E8(a2)) {
      goto LABEL_16;
    }
    int v11 = *(_DWORD *)(v9 + 24);
  }

  if ((v11 & 4) == 0) {
    return 0LL;
  }
  BOOL v12 = sub_180850758(a2);
  if (v12) {
    uint64_t result = (uint64_t)a2;
  }
  else {
    uint64_t result = 0LL;
  }
  if (a4 && v12)
  {
LABEL_27:
    *a4 = 1;
    return (uint64_t)a2;
  }

  return result;
}

uint64_t sub_1808508B0()
{
  if (qword_18C4491D0)
  {
    uhash_close((_BYTE *)qword_18C4491D0);
    qword_18C4491D0 = 0LL;
  }

  if (qword_18C4491E8)
  {
    unsigned int v0 = (void *)sub_180850CF0(qword_18C4491E8);
    icu::UMemory::operator delete(v0);
  }

  qword_18C4491E8 = 0LL;
  if (qword_18C4491F0)
  {
    int v1 = (void *)sub_180850D68(qword_18C4491F0);
    icu::UMemory::operator delete(v1);
  }

  qword_18C4491F0 = 0LL;
  if (qword_18C4491E0)
  {
    uint64_t v2 = (void *)sub_180850DC8(qword_18C4491E0);
    icu::UMemory::operator delete(v2);
  }

  qword_18C4491E0 = 0LL;
  atomic_store(0, &dword_18C4491D8);
  return 1LL;
}

void *sub_180850934(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0LL;
    }
    uint64_t result = uprv_malloc(8LL * v4);
    if (!result) {
      return result;
    }
    BOOL v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8LL * v7);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }

  uint64_t result = (void *)icu::UMemory::operator new((icu::UMemory *)0x40, a2);
  if (result)
  {
    *uint64_t result = (char *)result + 13;
    *((_DWORD *)result + 2) = 40;
    *((_WORD *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
  }

  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_180850A1C(int *a1, const char **a2, UErrorCode *a3)
{
  int v6 = a1[4];
  if (*a1 != v6)
  {
LABEL_16:
    uint64_t v9 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    if (v9)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v15, *a2);
      int v11 = v15;
      int v12 = v16;
      *(void *)uint64_t v9 = v9 + 13;
      *(_DWORD *)(v9 + 8) = 40;
      *(_WORD *)(v9 + 12) = 0;
      *(_DWORD *)(v9 + 56) = 0;
      icu::CharString::append((icu::CharString *)v9, v11, v12, a3);
    }

    uint64_t v13 = *a1;
    *a1 = v13 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v13) = v9;
    return v9;
  }

  if (v6 == 8) {
    int v7 = 32;
  }
  else {
    int v7 = 2 * v6;
  }
  if (v7 < 1) {
    return 0LL;
  }
  uint64_t v8 = uprv_malloc(8LL * v7);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    if (v6 >= 1)
    {
      int v10 = a1[4];
      if (v10 >= v6) {
        int v10 = v6;
      }
      if (v10 >= v7) {
        int v10 = v7;
      }
      memcpy(v8, *((const void **)a1 + 1), 8LL * v10);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v9;
    a1[4] = v7;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v9;
}

void *sub_180850B44(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0LL;
    }
    uint64_t result = uprv_malloc(8LL * v4);
    if (!result) {
      return result;
    }
    int v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8LL * v7);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }

  uint64_t result = (void *)icu::UMemory::operator new((icu::UMemory *)0x10, a2);
  if (result)
  {
    *uint64_t result = 0LL;
    result[1] = 0LL;
  }

  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

_OWORD *sub_180850C18(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0LL;
    }
    uint64_t result = uprv_malloc(8LL * v4);
    if (!result) {
      return result;
    }
    int v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8LL * v7);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }

  uint64_t result = (_OWORD *)icu::UMemory::operator new((icu::UMemory *)0x20, a2);
  if (result)
  {
    *uint64_t result = 0u;
    result[1] = 0u;
  }

  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_180850CF0(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0LL;
    do
    {
      int v4 = *(void **)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        unsigned int v5 = (_BYTE *)v4[2];
        if (v5) {
          uhash_close(v5);
        }
        icu::UMemory::operator delete(v4);
        int v2 = *(_DWORD *)a1;
      }

      ++v3;
    }

    while (v3 < v2);
  }

  if (*(_BYTE *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_180850D68(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0LL;
    do
    {
      int v4 = *(void **)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        icu::UMemory::operator delete(v4);
        int v2 = *(_DWORD *)a1;
      }

      ++v3;
    }

    while (v3 < v2);
  }

  if (*(_BYTE *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_180850DC8(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 12)) {
          uprv_free(*(void **)v4);
        }
        icu::UMemory::operator delete((void *)v4);
        int v2 = *(_DWORD *)a1;
      }

      ++v3;
    }

    while (v3 < v2);
  }

  if (*(_BYTE *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

BOOL sub_180850E44(char *__s, unsigned int a2)
{
  int v2 = __s;
  if ((a2 & 0x80000000) != 0) {
    a2 = strlen(__s);
  }
  if (a2 - 2 > 6) {
    return 0LL;
  }
  uint64_t v3 = a2;
  while (1)
  {
    char v4 = *v2++;
    BOOL result = uprv_isASCIILetter(v4);
    if (!result) {
      break;
    }
    if (!--v3) {
      return 1LL;
    }
  }

  return result;
}

BOOL sub_180850EA0(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 != 4) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  while (1)
  {
    BOOL result = uprv_isASCIILetter(__s[v3]);
    if (!result) {
      break;
    }
    if (++v3 == 4) {
      return 1LL;
    }
  }

  return result;
}

BOOL sub_180850EFC(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 == 2)
  {
    uint64_t v5 = 0LL;
    while (1)
    {
      BOOL result = uprv_isASCIILetter(__s[v5]);
      if (!result) {
        break;
      }
      if (++v5 == 2) {
        return 1LL;
      }
    }
  }

  else
  {
    if (a2 == 3)
    {
      uint64_t v3 = 0LL;
      while (__s[v3] - 48 < 0xA)
      {
        if (++v3 == 3) {
          return 1LL;
        }
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_180850F84(char *__s, int a2)
{
  return sub_180850F98((uint64_t (*)(void))sub_180851058, __s, a2);
}

uint64_t sub_180850F98(uint64_t (*a1)(void), char *__s, int a3)
{
  if (a3 < 0) {
    a3 = strlen(__s);
  }
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  uint64_t v6 = a3;
  do
  {
    if (__s[v4] == 45)
    {
      uint64_t v5 = 0LL;
    }

    else if (!v5)
    {
      uint64_t v5 = &__s[v4];
    }

    ++v4;
  }

  while (v4 < v6);
  if (v5) {
    return a1();
  }
  else {
    return 0LL;
  }
}

uint64_t sub_180851058(char *__s, int a2)
{
  int v2 = a2;
  if (a2 < 0) {
    int v2 = strlen(__s);
  }
  if (sub_180851260(__s, v2, 5)) {
    return 1LL;
  }
  if (v2 == 4 && *__s - 48 <= 9)
  {
    uint64_t v5 = 1LL;
    while (uprv_isASCIILetter(__s[v5]) || __s[v5] - 48 <= 9)
    {
      if (++v5 == 4) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

BOOL sub_1808510F0(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = a2;
  uint64_t v5 = __s;
  do
  {
    while (*v5 == 45)
    {
      if (v3)
      {
        if (sub_180851260(v3, (_DWORD)v5 - (_DWORD)v3, 2))
        {
          uint64_t v3 = 0LL;
          if (++v5 - __s < v4) {
            continue;
          }
        }
      }

      return 0LL;
    }

    if (!v3) {
      uint64_t v3 = v5;
    }
    ++v5;
  }

  while (v5 - __s < v4);
  return sub_180851260(v3, (_DWORD)v5 - (_DWORD)v3, 2);
}

BOOL sub_1808511A4(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = a2;
  uint64_t v5 = __s;
  do
  {
    while (*v5 == 45)
    {
      if (v3)
      {
        if (sub_180851260(v3, (_DWORD)v5 - (_DWORD)v3, 1))
        {
          uint64_t v3 = 0LL;
          if (++v5 - __s < v4) {
            continue;
          }
        }
      }

      return 0LL;
    }

    if (!v3) {
      uint64_t v3 = v5;
    }
    ++v5;
  }

  while (v5 - __s < v4);
  return sub_180851260(v3, (_DWORD)v5 - (_DWORD)v3, 1);
}

BOOL sub_180851258(char *a1, int a2)
{
  return sub_180851260(a1, a2, 3);
}

BOOL sub_180851260(char *__s, int a2, int a3)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  return a2 >= a3 && a2 <= 8 && sub_180853AB4(__s, a2);
}

BOOL sub_1808512B8(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = a2;
  uint64_t v5 = __s;
  do
  {
    while (*v5 == 45)
    {
      if (v3)
      {
        if (sub_180851260(v3, (_DWORD)v5 - (_DWORD)v3, 3))
        {
          uint64_t v3 = 0LL;
          if (++v5 - __s < v4) {
            continue;
          }
        }
      }

      return 0LL;
    }

    if (!v3) {
      uint64_t v3 = v5;
    }
    ++v5;
  }

  while (v5 - __s < v4);
  return sub_180851260(v3, (_DWORD)v5 - (_DWORD)v3, 3);
}

BOOL sub_18085136C(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  return a2 == 2
}

char *ultag_getTKeyStart(const char *a1)
{
  int v1 = (char *)a1;
  int v2 = strchr(a1, 45);
  if (v2)
  {
    uint64_t v3 = v2;
    while (!sub_180851440(v1, (_DWORD)v3 - (_DWORD)v1))
    {
      int v1 = v3 + 1;
      uint64_t v3 = strchr(v3 + 1, 45);
      if (!v3) {
        goto LABEL_5;
      }
    }
  }

  else
  {
LABEL_5:
    if (!sub_180851440(v1, -1)) {
      return 0LL;
    }
  }

  return v1;
}

BOOL sub_180851440(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  return a2 == 2 && uprv_isASCIILetter(*__s) && __s[1] - 48 < 0xA;
}

uint64_t sub_18085149C(char *__s, int a2)
{
  return sub_1808514B0((uint64_t (*)(int *, char *, uint64_t))sub_18085156C, __s, a2);
}

uint64_t sub_1808514B0(uint64_t (*a1)(int *, char *, uint64_t), char *__s, int a3)
{
  int v3 = a3;
  uint64_t v4 = __s;
  int v11 = 0;
  if (a3 < 0) {
    int v3 = strlen(__s);
  }
  if (v3 < 1)
  {
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 0LL;
    int v7 = v4 + 1;
    int v8 = v3 + 1;
    do
    {
      if (*(v7 - 1) == 45)
      {
        uint64_t result = a1(&v11, v4, v6);
        uint64_t v6 = 0LL;
        uint64_t v4 = v7;
        if (!(_DWORD)result) {
          return result;
        }
      }

      else
      {
        uint64_t v6 = (v6 + 1);
      }

      ++v7;
      --v8;
    }

    while (v8 > 1);
  }

  else {
    BOOL v10 = 1;
  }
  return !v10;
}

BOOL sub_18085156C(int *a1, char *__s, unsigned int a3)
{
  unsigned int v3 = a3;
  if ((a3 & 0x80000000) != 0) {
    unsigned int v3 = strlen(__s);
  }
  BOOL result = 0LL;
  switch(*a1)
  {
    case -1:
      BOOL result = sub_180851260(__s, v3, 3);
      if ((_DWORD)result)
      {
        int v7 = 6;
        goto LABEL_19;
      }

      return result;
    case 0:
      if (!sub_180850E44(__s, v3) || v3 == 4) {
        goto LABEL_11;
      }
      BOOL result = 1LL;
      *a1 = 1;
      return result;
    case 1:
      if (!sub_180850EA0(__s, v3)) {
        goto LABEL_15;
      }
      int v7 = 2;
      goto LABEL_19;
    case 2:
LABEL_15:
      if (!sub_180850EFC(__s, v3)) {
        goto LABEL_4;
      }
      int v7 = 3;
      goto LABEL_19;
    case 3:
    case 4:
LABEL_4:
      if (sub_180851058(__s, v3))
      {
        int v7 = 4;
      }

      else
      {
LABEL_11:
        BOOL result = sub_180851440(__s, v3);
        if (!(_DWORD)result) {
          return result;
        }
LABEL_18:
        int v7 = -1;
      }

uint64_t sub_1808516A8(char *__s, int a2)
{
  return sub_1808514B0((uint64_t (*)(int *, char *, uint64_t))sub_1808516BC, __s, a2);
}

BOOL sub_1808516BC(int *a1, char *__s, int a3)
{
  int v6 = *a1;
  if (*a1 == 2) {
    goto LABEL_15;
  }
  if (v6 == 1)
  {
    if (!sub_18085136C(__s, a3))
    {
      BOOL result = sub_180851260(__s, a3, 3);
      if (!(_DWORD)result) {
        return result;
      }
      *a1 = 2;
    }

    return 1LL;
  }

  if (v6) {
    return 0LL;
  }
LABEL_15:
  if (!sub_18085136C(__s, a3)) {
    return sub_180851260(__s, a3, 3);
  }
  BOOL result = 1LL;
  *a1 = 1;
  return result;
}

uint64_t uloc_toLanguageTag(char *a1, char *a2, int a3, int a4, int *a5)
{
  if (*a5 > 0) {
    return 0LL;
  }
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a2, a3);
  ulocimp_toLanguageTag(a1, (uint64_t)&v12, a4, a5);
  uint64_t v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13)) {
      *a5 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v13), a5);
    }
  }

  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

void ulocimp_toLanguageTag(char *a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v120 = *MEMORY[0x1895F89C0];
  memset(&v109[1], 0, 48);
  int v111 = 0;
  v109[0] = (char *)&v109[1] + 5;
  LODWORD(v109[1]) = 40;
  int v110 = 0;
  int v95 = 0;
  *(void *)__s = 0LL;
  *(void *)&__s[8] = 0LL;
  icu::CharStringByteSink::CharStringByteSink(__s, (uint64_t)v109);
  ulocimp_canonicalize(a1);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s);
  KeywordsStart = locale_getKeywordsStart((const char *)v109[0]);
  if (KeywordsStart == v109[0])
  {
    uint64_t v9 = (void **)uloc_openKeywords(KeywordsStart, &v95);
    BOOL v10 = v9;
    if (v95 > 0
      || uenum_count((uint64_t)v9, &v95) != 1
      || (LODWORD(v103[0]) = 0, int v11 = (char *)uenum_next((uint64_t)v10, (uint64_t)v103, &v95), LODWORD(v103[0]) != 1)
      || (__int128 v12 = v11, *v11 != 120))
    {
LABEL_16:
      if (v10) {
        uenum_close(v10);
      }
      goto LABEL_18;
    }

    memset(&__s[8], 0, 56);
    *(void *)__s = &__s[13];
    *(_DWORD *)&__s[8] = 40;
    v104 = 0LL;
    v105 = 0LL;
    icu::CharStringByteSink::CharStringByteSink(&v104, (uint64_t)__s);
    ulocimp_getKeywordValue(a1, v12, (uint64_t)&v104, &v95);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v104);
    if (v95 > 0)
    {
      int v13 = 0;
      *a4 = 1;
      goto LABEL_13;
    }

    if (sub_1808511A4(*(char **)__s, *(int *)&__s[56]))
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16LL))(a2, "und-x-", 6LL);
      (*(void (**)(uint64_t, void, void))(*(void *)a2 + 16LL))( a2,  *(void *)__s,  *(unsigned int *)&__s[56]);
    }

    else
    {
      int v13 = 1;
      if (!a3) {
        goto LABEL_13;
      }
      *a4 = 1;
    }

    int v13 = 0;
LABEL_13:
    if (__s[12]) {
      uprv_free(*(void **)__s);
    }
    if (!v13)
    {
      if (v10) {
        uenum_close(v10);
      }
      goto LABEL_204;
    }

    goto LABEL_16;
  }

LABEL_110:
      *a4 = v51;
      int v52 = 3;
      goto LABEL_111;
    }

    int v53 = strlen(v49);
    if (strcmp(v49, "attribute"))
    {
      if (v53 >= 2)
      {
        v93 = uloc_toUnicodeLocaleKey((uint64_t)v49);
        if (v93)
        {
          BOOL v54 = uloc_toUnicodeLocaleType((uint64_t)v49, (char *)v112[0]);
          if (v54)
          {
            v91 = v54;
            if (v54 != v112[0]) {
              goto LABEL_172;
            }
            v55 = (unsigned __int8 **)sub_180853D48((int *)v98, (unint64_t)v112, (UErrorCode *)&v97);
            if (!v55) {
              goto LABEL_176;
            }
            int v51 = v97;
            if (v97 >= 1) {
              goto LABEL_110;
            }
            uint64_t v56 = v55;
            T_CString_toLowerCase(*v55);
            v91 = (char *)*v56;
LABEL_172:
            UErrorCode v70 = sub_180853FF0(v103, v48);
            if (!v70)
            {
LABEL_176:
              int v51 = 7;
              goto LABEL_110;
            }

            *UErrorCode v70 = v93;
            v70[1] = v91;
            int v71 = sub_1808540C8(&v100, (uint64_t)v70, 1);
            int v52 = 0;
            if (!v94 || v71) {
              goto LABEL_111;
            }
          }

          else
          {
            if (!v94)
            {
              v91 = 0LL;
              goto LABEL_149;
            }

            v91 = 0LL;
          }
        }

        else
        {
          if (!v94)
          {
            v93 = 0LL;
            goto LABEL_149;
          }

          v93 = 0LL;
        }

    uint64_t v23 = 0;
    int v24 = 0;
    size_t v29 = 3;
LABEL_127:
    if (a3 <= 3) {
      uint64_t v23 = 0;
    }
    if ((v24 & v55 & 1) == 0 && (v23 & 1) == 0)
    {
      char v15 = *(_DWORD *)(a1 + 16);
      if ((int)v16 >= v15 - 14)
      {
        *(_BYTE *)(a1 + 21) = 0;
        *(void *)(a1 + 24) = 0LL;
        *(_DWORD *)(a1 + 32) = 0;
        if (!v54) {
          goto LABEL_159;
        }
        if (a4 && (_DWORD)v13 && (_DWORD)v13 != 5) {
          goto LABEL_160;
        }
        return;
      }
    }

    icu::number::impl::DecimalQuantity::convertToAccurateDouble((icu::number::impl::DecimalQuantity *)a1);
  }

  if (!a4 || (_DWORD)v13 == 2 || (_DWORD)v13 == 7)
  {
    if ((char)v17 >= 5)
    {
      if ((_DWORD)v17 == 5)
      {
        LODWORD(v37) = v12 - 2;
        if (v12 >= -2147483646) {
          v37 = v37;
        }
        else {
          v37 = 0x80000000LL;
        }
        if ((v37 & 0x80000000) == 0)
        {
          unint64_t v38 = 4 * v37;
          do
          {
            if (*(_BYTE *)(a1 + 64))
            {
              if (v37 < v15 && *(_BYTE *)(*(void *)(a1 + 48) + v37)) {
                goto LABEL_158;
              }
            }

            else if ((unint64_t)v37 <= 0xF && ((*(void *)(a1 + 48) >> (v38 & 0xFC)) & 0xF) != 0)
            {
              goto LABEL_158;
            }

            v38 -= 4;
            uint64_t v9 = v37-- <= 0;
          }

          while (!v9);
        }

        size_t v29 = 2;
      }

      else
      {
LABEL_158:
        size_t v29 = 3;
      }
    }

    else
    {
      size_t v29 = 1;
    }

LABEL_109:
        int v51 = 1;
        goto LABEL_110;
      }

      if (*v49 == 120)
      {
      }

      else if (!sub_180853E5C(v49, v53) || !sub_1808510F0((char *)v112[0], v101))
      {
LABEL_158:
        if (!v94) {
          goto LABEL_149;
        }
        goto LABEL_109;
      }

      v96[0] = (const char *)v112[0];
      int v67 = (char **)sub_180853ECC((int *)v98, v96, &v101, (UErrorCode *)&v97);
      if (v67)
      {
        int v68 = v97;
        if (v97 < 1)
        {
          v91 = *v67;
          v93 = v49;
          goto LABEL_172;
        }
      }

      else
      {
        int v68 = 7;
      }

      *a4 = v68;
      int v52 = 3;
      v93 = v49;
      goto LABEL_111;
    }

    if (v50 < 1) {
      goto LABEL_172;
    }
    int v57 = 0;
    while (2)
    {
      int v108 = 0;
      int v58 = v101;
      if (v57 >= v101) {
        goto LABEL_140;
      }
      int v59 = v57;
      int v60 = *((unsigned __int8 *)v112[0] + v57);
      if (v60 == 45)
      {
        unint64_t v61 = 0LL;
LABEL_135:
        int v57 = v59 + 1;
LABEL_137:
        if ((int)v61 >= 1)
        {
          if (v61 > 0x63) {
            *a4 = -124;
          }
          else {
            __s[v61] = 0;
          }
LABEL_141:
          uint64_t v63 = sub_180850B44((const void **)&v104, v48);
          if (!v63 || (v64 = v63, (uint64_t v65 = (void *)sub_180853B7C((int *)v102, __s, &v108, (UErrorCode *)a4)) == 0LL))
          {
            v91 = 0LL;
            int v69 = 7;
LABEL_170:
            *a4 = v69;
LABEL_171:
            v93 = "attribute";
            goto LABEL_172;
          }

          if (*a4 > 0)
          {
LABEL_168:
            v91 = 0LL;
            goto LABEL_171;
          }

          void *v64 = *v65;
          int v66 = sub_180853C9C(&v99, (uint64_t)v64);
          if (v94 && !v66)
          {
            v91 = 0LL;
            int v69 = 1;
            goto LABEL_170;
          }

          continue;
        }

          unint64_t v61 = uprv_malloc(4 * v33);
          if (!v61) {
            goto LABEL_117;
          }
          uint64_t v62 = (uint64_t)v61;
          memcpy(v61, __src, 0x200uLL);
          if (LODWORD(v291[0]))
          {
            if (SLODWORD(v291[0]) < 1)
            {
              int v66 = -1LL;
            }

            else
            {
              uint64_t v63 = 0LL;
              v64 = 0;
              uint64_t v65 = -1;
              do
              {
                if (*((_DWORD *)&v291[16] + v63 + 2) > v64)
                {
                  uint64_t v65 = v63;
                  v64 = *((_DWORD *)&v291[16] + v63 + 2);
                }

                ++v63;
              }

              while (LODWORD(v291[0]) != v63);
              int v66 = v65;
            }

            int v67 = *((_DWORD *)v291 + v66 + 2);
          }

          else
          {
            int v67 = -1;
          }

          v289 = 0u;
          v290 = 0u;
          int v68 = (_DWORD *)*v5;
          *int v68 = 0;
          v68[4] = 64;
          if (!sub_180858080((uint64_t)&v289, v33, 64))
          {
LABEL_203:
            LODWORD(v124) = 0;
            v125 = 7;
            v123 = v281;
LABEL_204:
            *v123 = v125;
LABEL_205:
            v126 = v277;
            goto LABEL_206;
          }

          LODWORD(v69) = 128;
          sub_180858168((uint64_t)&v289, v62, 0, 128);
          UErrorCode v70 = v5[6].i32[0];
          if (v70 >= 144)
          {
            int v71 = 0LL;
            int v72 = v70 >> 4;
            int v69 = 128LL;
            v73 = 64LL;
            int v74 = 4;
            v75 = 8;
            v274 = v70 >> 4;
            v276 = v67;
            do
            {
              if (v75 == (_DWORD)v13)
              {
                sub_180858168((uint64_t)&v289, v62, 0, v69);
                int v74 = 1;
                v73 = 16LL;
                int v71 = v69;
              }

              if (v5[8].i8[v75] == 1)
              {
                v282 = v73;
                v284 = v74;
                v278 = v71;
                int v86 = *v5;
                v270 = 4LL * *(unsigned int *)(*(void *)v5 + 4LL * v75);
                v271 = v5[2];
                v88 = (int *)(*(void *)&v271 + v270 + 4);
                char v87 = *(_DWORD *)(*(void *)&v271 + v270);
                if (SDWORD2(v290) <= 2) {
                  int v89 = 2LL;
                }
                else {
                  int v89 = DWORD2(v290);
                }
                size_t v90 = v89 - 1;
                do
                {
                  v91 = *v88++;
                  char v87 = v91 + 37 * v87;
                  --v90;
                }

                while (v90);
                char v92 = sub_180858228((uint64_t)&v289, v62, *(void *)&v271 + v270, 0, v87);
                if ((v92 & 0x80000000) != 0 || (v93 = (DWORD1(v290) & *(_DWORD *)(v289 + 4LL * v92)) - 1, v93 < 0))
                {
                  int v94 = 4LL * (int)v69;
                  int v95 = v94 - 4LL * v282 + 4;
                  v96 = v282;
                  do
                  {
                    int v97 = v96--;
                    v98 = v95;
                    v99 = v97;
                    v100 = (_DWORD *)(*(void *)&v271 + v270);
                    while (*(_DWORD *)(v62 + v98) == *v100)
                    {
                      ++v100;
                      --v99;
                      v98 += 4LL;
                      if (v99 <= 1) {
                        goto LABEL_157;
                      }
                    }

                    v95 += 4LL;
                  }

                  while (v97 >= 3);
                  LODWORD(v96) = 0;
LABEL_157:
                  *(_DWORD *)(*(void *)&v86 + 4LL * v75) = v69 - v96;
                  int v101 = v69;
                  int v67 = v276;
                  if ((int)v96 < (int)v282)
                  {
                    v102 = (_DWORD *)(v62 + v94);
                    v103 = (int *)(*(void *)&v271 + v270 + 4LL * (int)v96);
                    v104 = v282 - (uint64_t)(int)v96;
                    int v101 = v69 + v282 - v96;
                    do
                    {
                      v105 = *v103++;
                      *v102++ = v105;
                      --v104;
                    }

                    while (v104);
                  }

                  sub_180858168((uint64_t)&v289, v62, v69, v101);
                  v73 = v282;
                  int v69 = v101;
                  int v72 = v274;
                  int v71 = v278;
                  int v74 = v284;
                }

                else
                {
                  *(_DWORD *)(*(void *)&v86 + 4LL * v75) = v93;
                  int v67 = v276;
                  int v72 = v274;
                  int v71 = v278;
                  int v74 = v284;
                  v73 = v282;
                }

                goto LABEL_200;
              }

              if (v5[8].i8[v75])
              {
                *(_DWORD *)(*(void *)v5 + 4LL * v75) = *(_DWORD *)(*(void *)v5
                                                                   + 4LL * *(unsigned int *)(*(void *)v5 + 4LL * v75));
              }

              else
              {
                __int128 v76 = *v5;
                size_t v77 = *(_DWORD *)(*(void *)v5 + 4LL * v75);
                __int128 v78 = v77;
                if (SDWORD2(v290) >= 2)
                {
                  size_t v79 = DWORD2(v290) - 1;
                  __int128 v78 = *(_DWORD *)(*(void *)v5 + 4LL * v75);
                  do
                  {
                    __int128 v78 = v77 + 37 * v78;
                    --v79;
                  }

                  while (v79);
                }

                v80 = v78 % (HIDWORD(v289) - 1) + 1;
                size_t v81 = *(_DWORD *)(v289 + 4LL * v80);
                if (v81)
                {
                  int v82 = v78 << v290;
                  __int128 v83 = v78 % (HIDWORD(v289) - 1) + 1;
                  while (1)
                  {
                    if ((v81 & ~DWORD1(v290)) == v82)
                    {
                      uint64_t v84 = (_DWORD *)(v62 + 4LL * ((v81 & DWORD1(v290)) - 1));
                      int v85 = &v84[SDWORD2(v290)];
                      if (SDWORD2(v290) >= 1)
                      {
                        do
                        {
                          if (*v84 != v77) {
                            break;
                          }
                          ++v84;
                        }

                        while (v84 < v85);
                      }

                      if (v84 == v85) {
                        break;
                      }
                    }

                    __int128 v83 = (v83 + v80) % SHIDWORD(v289);
                    size_t v81 = *(_DWORD *)(v289 + 4LL * v83);
                    if (!v81) {
                      goto LABEL_162;
                    }
                  }
                }

                else
                {
                  __int128 v83 = v78 % (HIDWORD(v289) - 1) + 1;
LABEL_162:
                  __int128 v83 = ~v83;
                }

                if (v83 < 0) {
                  v106 = -1;
                }
                else {
                  v106 = (DWORD1(v290) & *(_DWORD *)(v289 + 4LL * v83)) - 1;
                }
                uint64_t v107 = v106 >> 31;
                if (v75 == v67 && v75 >= (int)v13 && (v106 & 0x80000000) == 0 && v106 < (int)v71)
                {
                  int v108 = v69 - v73;
                  while (1)
                  {
                    v109 = 0LL;
                    while (*(_DWORD *)(*(void *)&v76 + 4 * v109) != v106)
                    {
                      v109 += 4LL;
                      if (v109 >= v13) {
                        goto LABEL_194;
                      }
                    }

                    if (v108 <= v106) {
                      break;
                    }
                    uint64_t v107 = v106;
                    while (1)
                    {
                      v106 = v107 + 1;
                      if (*(_DWORD *)(v62 + 4LL * (v107 + 1)) == v77) {
                        break;
                      }
LABEL_183:
                      uint64_t v107 = v106;
                      if (v106 >= v108) {
                        goto LABEL_188;
                      }
                    }

                    int v110 = 0LL;
                    do
                    {
                      if (*(_DWORD *)(v62 + 8 + 4LL * v107 + 4 * v110) != v77)
                      {
                        v106 = v107 + v110 + 2;
                        goto LABEL_183;
                      }

                      ++v110;
                    }

                    while (v73 - 1LL != v110);
                    int v111 = v107 < -1;
                    LOBYTE(v107) = v107 < -1;
                  }

    int v51 = v16 - v26;
    if ((v11 & 0x100) != 0)
    {
      if (v51 < 1) {
        goto LABEL_124;
      }
      if (a8) {
        icu::Edits::addUnchanged(a8, v16 - v26);
      }
      if ((v11 & 0x4000) != 0)
      {
LABEL_124:
        if ((v10 & 0x80000000) != 0) {
          goto LABEL_139;
        }
      }

      else
      {
        BOOL v10 = (v51 + v10);
      }

LABEL_228:
      ++v84;
    }

    while (v86);
  }

          v139 = 65566;
LABEL_243:
          sub_18095F4F8(v26, v139, a2, v8, a8);
LABEL_244:
          __int128 v19 = v8;
          goto LABEL_245;
        }
      }

      a6 = v28;
    }

    else if ((_DWORD)v24 == 92)
    {
      if (v160 == (_DWORD)a4)
      {
        uint64_t v26 = *(void *)(a1 + 104);
        v139 = 65552;
        goto LABEL_243;
      }

      int v25 = icu::UnicodeString::unescapeAt((icu::UnicodeString *)a2, &v160);
      uint64_t v26 = *(void *)(a1 + 104);
      if (v25 == -1)
      {
        v139 = 65540;
        goto LABEL_243;
      }

      icu::UnicodeString::append(a5, v25);
    }

    else
    {
      uint64_t v26 = *(void *)(a1 + 104);
      if (*(unsigned __int16 *)(*(void *)(v26 + 96) + 1162LL) <= v24
        && *(unsigned __int16 *)(v26 + 426) > v24)
      {
        goto LABEL_228;
      }

      size_t v31 = *(unsigned __int16 *)(a6 + 8);
      size_t v32 = (__int16)v31;
      uint64_t v33 = v31 >> 5;
      if (v32 >= 0) {
        unint64_t v34 = v33;
      }
      else {
        unint64_t v34 = *(_DWORD *)(a6 + 12);
      }
      if ((icu::UnicodeString::doIndexOf(a6, v24, 0, v34) & 0x80000000) == 0) {
        sub_18095F4F8(*(void *)(a1 + 104), 65567, a2, v8, a8);
      }
      if ((int)v24 <= 62)
      {
        int v11 = (v24 - 36);
        switch((int)v24)
        {
          case '$':
            if (v160 == (_DWORD)a4)
            {
              int v11 = 1LL;
              *(_BYTE *)(a1 + 93) = 1;
              goto LABEL_21;
            }

            __int128 v117 = *(unsigned __int16 *)(a2 + 8);
            if ((v117 & 0x8000u) == 0) {
              __int128 v118 = v117 >> 5;
            }
            else {
              __int128 v118 = *(_DWORD *)(a2 + 12);
            }
            if (v118 <= v160)
            {
              uint64_t v120 = 0xFFFF;
            }

            else
            {
              if ((v117 & 2) != 0) {
                v119 = v18;
              }
              else {
                v119 = *(void *)(a2 + 24);
              }
              uint64_t v120 = *(unsigned __int16 *)(v119 + 2LL * v160);
            }

            if ((u_digit(v120, 10) - 1) > 8)
            {
              LODWORD(v159) = v160;
              memset(v162, 0, sizeof(v162));
              (*(void (**)(_OWORD *__return_ptr, void, uint64_t, void (***)(icu::ParsePosition *__hidden), uint64_t))(**(void **)(*(void *)(a1 + 104) + 184LL) + 32LL))( v162,  *(void *)(*(void *)(a1 + 104) + 184LL),  a2,  &v158,  a4);
              v125 = WORD4(v162[0]) >> 5;
              if (SWORD4(v162[0]) < 0) {
                v125 = HIDWORD(v162[0]);
              }
              if (v125)
              {
                v160 = v159;
                v126 = *(unsigned __int16 *)(a5 + 8);
                v127 = (__int16)v126;
                v128 = v126 >> 5;
                if (v127 < 0) {
                  v128 = *(_DWORD *)(a5 + 12);
                }
                v149 = v128;
                sub_18095E524(*(void *)(a1 + 104), (UChar **)v162, a5, a8);
                LODWORD(v130) = *(unsigned __int16 *)(a5 + 8);
                v129 = (__int16)v130;
                LODWORD(v130) = v130 >> 5;
                if (v129 >= 0) {
                  v130 = v130;
                }
                else {
                  v130 = *(unsigned int *)(a5 + 12);
                }
                v148 = v130;
              }

              else
              {
                v130 = 1LL;
                *(_BYTE *)(a1 + 93) = 1;
              }

              icu::UnicodeString::~UnicodeString((void *)v130, (icu::UnicodeString *)v162);
              goto LABEL_21;
            }

            v124 = icu::ICU_Utility::parseNumber((icu::ICU_Utility *)a2, (const icu::UnicodeString *)&v160, (int *)0xA);
            uint64_t v26 = *(void *)(a1 + 104);
            if (v124 < 0)
            {
              v139 = 65553;
              goto LABEL_243;
            }

            v106 = sub_18095E2E8(v26, v124, a8);
LABEL_154:
            LOWORD(v162[0]) = v106;
            break;
          case '&':
            goto LABEL_78;
          case '(':
            v146 = a6;
            v147 = v8;
            v93 = *(unsigned __int16 *)(a5 + 8);
            v145 = *(_DWORD *)(a5 + 12);
            int v94 = *(_DWORD *)(a1 + 96);
            *(_DWORD *)(a1 + 96) = v94 + 1;
            int v95 = v160;
            v157 = &unk_180A3B976;
            icu::UnicodeString::UnicodeString(v162, 1LL, &v157);
            v160 = sub_18095D2CC(a1, a2, v95, a4, a5, v162, 1LL, a8);
            icu::UnicodeString::~UnicodeString(v96, (icu::UnicodeString *)v162);
            v154[0] = (uint64_t)v157;
            v98 = icu::UMemory::operator new(v154, (icu::UMemory *)0x70, v97);
            if (!v98) {
              goto LABEL_232;
            }
            v99 = v98;
            if ((v93 & 0x8000u) == 0) {
              v100 = v93 >> 5;
            }
            else {
              v100 = v145;
            }
            int v101 = *(unsigned __int16 *)(a5 + 8);
            v102 = (__int16)v101;
            v103 = v101 >> 5;
            if (v102 >= 0) {
              v104 = v103;
            }
            else {
              v104 = *(unsigned int *)(a5 + 12);
            }
            sub_180990750((uint64_t)v98, a5, v100, v104, v94, *(void *)(*(void *)(a1 + 104) + 96LL));
            sub_18095E1E8(*(void *)(a1 + 104), v94, v99, a8);
            sub_1808623BC(a5, v100);
            v105 = sub_18095E2E8(*(void *)(a1 + 104), v94, a8);
            goto LABEL_177;
          case ')':
            goto LABEL_227;
          case '*':
          case '+':
            goto LABEL_67;
          case '.':
            v106 = sub_18095E608(*(void *)(a1 + 104), a8);
            goto LABEL_154;
          default:
            goto LABEL_179;
        }

        goto LABEL_183;
      }

      if ((int)v24 <= 122)
      {
        switch((_DWORD)v24)
        {
          case '?':
LABEL_67:
            uint64_t v41 = (uint64_t *)*(unsigned __int16 *)(a5 + 8);
            if (a7)
            {
              uint64_t v42 = (__int16)v41 >= 0 ? v41 >> 5 : *(_DWORD *)(a5 + 12);
              if (v42 == v150)
              {
                uint64_t v26 = *(void *)(a1 + 104);
                v139 = 65546;
                goto LABEL_243;
              }
            }

            v146 = a6;
            v147 = v8;
            if (((unsigned __int16)v41 & 0x8000) == 0)
            {
              v143 = v153;
              v43 = v20;
              uint64_t v41 = (uint64_t *)(v41 >> 5);
              v143 = v149;
              v43 = v148;
              if (v148 == (_DWORD)v41) {
                goto LABEL_141;
              }
LABEL_140:
              v143 = (_DWORD)v41 - 1;
              v43 = (uint64_t)v41;
              goto LABEL_141;
            }

            uint64_t v41 = (uint64_t *)*(unsigned int *)(a5 + 12);
            v143 = v153;
            v43 = v20;
            if ((_DWORD)v41 != (_DWORD)v20)
            {
              v143 = v149;
              v43 = v148;
              if ((_DWORD)v41 != v148) {
                goto LABEL_140;
              }
            }

LABEL_204:
  if (BYTE4(v109[1])) {
    uprv_free(v109[0]);
  }
}

uint64_t uloc_forLanguageTag(char *a1, char *a2, int a3, _DWORD *a4, int *a5)
{
  if (*a5 > 0) {
    return 0LL;
  }
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a2, a3);
  ulocimp_forLanguageTag(a1, -1, (uint64_t)&v12, a4, a5);
  uint64_t v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13)) {
      *a5 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v13), a5);
    }
  }

  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

uint64_t *ulocimp_forLanguageTag(char *__s, int a2, uint64_t a3, _DWORD *a4, int *a5)
{
  int v8 = a2;
  uint64_t v174 = *MEMORY[0x1895F89C0];
  if (a4) {
    *a4 = 0;
  }
  uint64_t v155 = 0LL;
  if (*a5 > 0) {
    goto LABEL_4;
  }
  if (a2 < 0) {
    int v8 = strlen(__s);
  }
  int v11 = (char *)uprv_malloc(v8 + 1);
  if (!v11)
  {
    *a5 = 7;
LABEL_4:
    uint64_t v155 = 0LL;
    return sub_18085424C(&v155);
  }

  __int128 v12 = v11;
  v154 = (UErrorCode *)a5;
  if (v8 >= 1) {
    memcpy(v11, __s, v8);
  }
  v12[v8] = 0;
  __int128 v13 = uprv_malloc(0x58uLL);
  uint64_t v14 = (uint64_t)v13;
  *(void *)v166 = v13;
  if (!v13)
  {
    uprv_free(v12);
LABEL_32:
    int v24 = (int *)v154;
    UErrorCode *v154 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_149;
  }

  v13[2] = 0LL;
  v13[3] = 0LL;
  v13[4] = 0LL;
  v13[5] = &unk_180A270AE;
  v13[6] = &unk_180A270AE;
  v13[7] = 0LL;
  v13[9] = &unk_180A270AE;
  v13[10] = &unk_180A270AE;
  v13[8] = 0LL;
  *__int128 v13 = v12;
  v13[1] = &unk_180A270AE;
  if (v8 < 2) {
    goto LABEL_148;
  }
  v143 = a4;
  unint64_t v15 = 0LL;
  while (1)
  {
    int v16 = strlen(off_18971AE18[v15]);
    int v17 = v16;
    int v18 = v8 - v16;
    BOOL v19 = v15 >= 0x30;
    v15 += 2LL;
    if (v19)
    {
      int v141 = 0;
LABEL_21:
      unint64_t v20 = 0LL;
      while (1)
      {
        size_t v21 = strlen(off_18971AFA8[v20]);
        if (!uprv_strnicmp(off_18971AFA8[v20], v12, v21))
        {
          int v22 = v12[v21];
          BOOL v23 = v22 == 45 || v22 == 0;
          if (v23) {
            break;
          }
        }

        BOOL v19 = v20 >= 0x32;
        v20 += 2LL;
        if (v19) {
          goto LABEL_44;
        }
      }

      size_t v25 = strlen(off_18971AFA8[v20 + 1]);
      memcpy(*(void **)v14, off_18971AFA8[v20 + 1], v25);
      uint64_t v26 = &v12[v25];
      if (v12[v21] == 45) {
        memmove(v26, &v12[v21], v8 - v21 + 1);
      }
      else {
        *uint64_t v26 = 0;
      }
      int v141 = v21 - v25;
      goto LABEL_45;
    }
  }

  int v27 = off_18971AE18[v15 + 1];
  int v28 = strlen(v27);
  int v29 = v18 + v28;
  if (v8 >= v18 + v28)
  {
    v30 = *(char **)v14;
  }

  else
  {
    uprv_free(v12);
    v30 = (char *)uprv_malloc(v29 + 1);
    *(void *)uint64_t v14 = v30;
    __int128 v12 = v30;
    int v8 = v18 + v28;
    if (!v30)
    {
LABEL_37:
      uint64_t v14 = 0LL;
      goto LABEL_32;
    }
  }

  int v141 = v17 - v28;
  strcpy(v30, v27);
  int v31 = v17;
  if (v8 != v17)
  {
    memcpy((void *)(*(void *)v14 + v28), &__s[v17], v18);
    *(_BYTE *)(*(void *)v14 + v29) = 0;
    int v31 = v8;
  }

  int v8 = v31;
  if (!v17) {
    goto LABEL_21;
  }
LABEL_44:
  if (!v12) {
    goto LABEL_145;
  }
LABEL_45:
  int v140 = 0;
  v149 = 0LL;
  v150 = 0LL;
  v152 = 0LL;
  int v146 = 0;
  __int16 v32 = 129;
  uint64_t v33 = (unsigned __int8 *)v12;
  while (1)
  {
    for (size_t i = 0LL; ; ++i)
    {
      int v35 = v33[i];
      if (!v33[i] || v35 == 45) {
        break;
      }
    }

    size_t v36 = &v33[i];
    if (v33[i]) {
      v37 = v36 + 1;
    }
    else {
      v37 = 0LL;
    }
    if ((v32 & 1) != 0 && sub_180850E44((char *)v33, i))
    {
      v33[i] = 0;
      *(void *)(*(void *)v166 + 8LL) = T_CString_toLowerCase(v33);
      else {
        __int16 v32 = 190;
      }
      goto LABEL_91;
    }

    if ((v32 & 2) != 0)
    {
      int v38 = (i & 0x80000000) != 0 ? strlen((const char *)v33) : i;
      if (v38 == 3)
      {
        uint64_t v39 = 0LL;
        while (uprv_isASCIILetter(v33[v39]))
        {
          if (++v39 == 3)
          {
            *size_t v36 = 0;
            *(void *)(*(void *)v166 + 8LL * v146 + 16) = T_CString_toLowerCase(v33);
            if (v146 >= 2) {
              __int16 v32 = 188;
            }
            else {
              __int16 v32 = 190;
            }
            __int128 v12 = (char *)&v33[i];
            ++v146;
            goto LABEL_92;
          }
        }
      }
    }

    if ((v32 & 4) != 0 && sub_180850EA0((char *)v33, i))
    {
      *size_t v36 = 0;
      *uint64_t v33 = uprv_toupper((char)*v33);
      signed __int8 v40 = v33[1];
      if (v40)
      {
        uint64_t v41 = v33 + 2;
        do
        {
          *(v41 - 1) = uprv_asciitolower(v40);
          int v42 = *v41++;
          signed __int8 v40 = v42;
        }

        while (v42);
      }

      *(void *)(*(void *)v166 + 40LL) = v33;
      __int16 v32 = 184;
      goto LABEL_91;
    }

    if ((v32 & 8) != 0 && sub_180850EFC((char *)v33, i))
    {
      *size_t v36 = 0;
      *(void *)(*(void *)v166 + 48LL) = T_CString_toUpperCase(v33);
      goto LABEL_90;
    }

    if ((v32 & 0x10) != 0 && (sub_180851058((char *)v33, i) || v140 && sub_180851260((char *)v33, i, 1)))
    {
      v45 = uprv_malloc(0x10uLL);
      if (!v45) {
        goto LABEL_37;
      }
      v46 = v45;
      *size_t v36 = 0;
      void *v45 = T_CString_toUpperCase(v33);
      if (!sub_180853B18((const char ***)(*(void *)v166 + 56LL), (uint64_t)v46))
      {
        uprv_free(v46);
        goto LABEL_134;
      }

LABEL_145:
    uint64_t v56 = v143;
  }

  else
  {
LABEL_134:
    if (!v152) {
      goto LABEL_145;
    }
    uint64_t v56 = v143;
    if (v150
      && v149
      && (unsigned __int8 *v149 = 0,
          v152[1] = T_CString_toLowerCase(v150),
          sub_1808540C8((const char ***)(*(void *)v166 + 64LL), (uint64_t)v152, 0)))
    {
      LODWORD(v12) = (_DWORD)v149;
    }

    else
    {
      uprv_free(v152);
    }
  }

  uint64_t v14 = *(void *)v166;
  if (v56) {
    *uint64_t v56 = v141 + (_DWORD)v12 - **(_DWORD **)v166;
  }
LABEL_148:
  *(void *)v166 = 0LL;
  int v24 = (int *)v154;
LABEL_149:
  sub_18085424C((uint64_t *)v166);
  int v57 = *v24;
  uint64_t v155 = v14;
  if (v57 > 0) {
    return sub_18085424C(&v155);
  }
  uint64_t v58 = 0LL;
  int v59 = 0;
  do
  {
    if (*(void *)(v14 + 16 + v58)) {
      ++v59;
    }
    v58 += 8LL;
  }

  while (v58 != 24);
  BOOL v23 = v59 == 0;
  uint64_t v60 = 16LL;
  if (v23) {
    uint64_t v60 = 8LL;
  }
  unint64_t v61 = *(const char **)(v14 + v60);
  if (!strcmp(v61, "und") || (int)strlen(v61) < 1)
  {
    int v62 = 1;
  }

  else
  {
    (*(void (**)(uint64_t, const char *))(*(void *)a3 + 16LL))(a3, v61);
    int v62 = 0;
  }

  uint64_t v63 = *(const char **)(v14 + 40);
  int v64 = strlen(v63);
  uint64_t v65 = (v64 - 1);
  if (v64 >= 1)
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "_", 1LL);
    v166[0] = 0;
    v166[0] = uprv_toupper(*v63);
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16LL))(a3, v166, 1LL);
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, v63 + 1, v65);
    int v62 = 0;
  }

  int v66 = *(const char **)(v14 + 48);
  int v67 = strlen(v66);
  if (v67 >= 1)
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "_", 1LL);
    if (*v66)
    {
      int v68 = (unsigned __int8 *)(v66 + 1);
      do
      {
        v166[0] = 0;
        v166[0] = uprv_toupper((char)*(v68 - 1));
        (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16LL))(a3, v166, 1LL);
      }

      while (*v68++);
    }

    int v62 = 0;
  }

  sub_180853A44(*(void *)(v14 + 56));
  uint64_t v71 = *(void *)(v14 + 56);
  if (v71)
  {
    int v72 = 0;
    do
    {
      uint64_t v71 = *(void *)(v71 + 8);
      ++v72;
    }

    while (v71);
    if (v67 <= 0)
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "_", 1LL);
      int v62 = 0;
    }

    int v73 = 0;
    int v74 = 1;
    do
    {
      uint64_t v75 = *(void *)(v14 + 56);
      if (v75)
      {
        int v76 = v74;
        while (--v76)
        {
          uint64_t v75 = *(void *)(v75 + 8);
          if (!v75) {
            goto LABEL_177;
          }
        }

        size_t v77 = *(_BYTE **)v75;
      }

      else
      {
LABEL_177:
        size_t v77 = 0LL;
      }

      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "_", 1LL);
      if (*v77)
      {
        __int128 v78 = v77 + 1;
        do
        {
          v166[0] = 0;
          v166[0] = uprv_toupper((char)*(v78 - 1));
          (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16LL))(a3, v166, 1LL);
        }

        while (*v78++);
      }

      ++v73;
      ++v74;
    }

    while (v72 != v73);
  }

  if (*(void *)(v14 + 64))
  {
    if (v62) {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "und", 3LL);
    }
  }

  else if (!**(_BYTE **)(v14 + 72))
  {
    return sub_18085424C(&v155);
  }

  v158 = 0LL;
  v157[0] = 0LL;
  memset(&v157[2], 0, 72);
  v157[1] = &v157[3];
  LODWORD(v157[2]) = 8;
  v156[0] = 0LL;
  memset(&v156[2], 0, 72);
  v156[1] = &v156[3];
  LODWORD(v156[2]) = 8;
  UErrorCode v80 = *v154;
  uint64_t v81 = *(void *)(v14 + 64);
  if (!v81)
  {
    int v131 = 0;
    goto LABEL_301;
  }

  int v82 = -1;
  do
  {
    uint64_t v81 = *(void *)(v81 + 16);
    ++v82;
  }

  while (v81);
  int v83 = 0;
  int v151 = 0;
  int v84 = 1;
  while (2)
  {
    uint64_t v85 = *(void *)(v14 + 64);
    int v86 = v84;
    uint64_t v87 = v85;
    while (--v86)
    {
      uint64_t v87 = *(void *)(v87 + 16);
      if (!v87)
      {
        v88 = 0LL;
        goto LABEL_197;
      }
    }

    v88 = *(_BYTE **)v87;
LABEL_197:
    int v89 = v84;
    while (--v89)
    {
      uint64_t v85 = *(void *)(v85 + 16);
      if (!v85)
      {
        size_t v90 = 0LL;
        goto LABEL_202;
      }
    }

    size_t v90 = *(char **)(v85 + 8);
LABEL_202:
    if (*v88 != 117)
    {
      v127 = sub_180853FF0(v157, (unint64_t)v70);
      if (v127)
      {
        void *v127 = v88;
        v127[1] = v90;
        goto LABEL_316;
      }

      goto LABEL_315;
    }

    uint64_t v91 = *(void *)(v14 + 56);
    v164 = 0LL;
    v165 = 0LL;
    LODWORD(v172) = 0;
    __int128 v170 = 0u;
    __int128 v171 = 0u;
    __int128 v168 = 0u;
    __int128 v169 = 0u;
    *(_OWORD *)v166 = 0u;
    __int128 v167 = 0u;
    __n[0] = 0LL;
    memset(&__n[2], 0, 72);
    __n[1] = (size_t)&__n[3];
    LODWORD(__n[2]) = 8;
    int v92 = *v90;
    if (!*v90)
    {
      sub_180850D68((uint64_t)__n);
      goto LABEL_279;
    }

    uint64_t v147 = v91;
    int v153 = v83;
    int v93 = 0;
    while (2)
    {
      for (k = 0LL; v92; int v92 = v95[1])
      {
        if (v92 == 45) {
          break;
        }
        int v95 = &v90[k++];
      }

      if (sub_18085136C(v90, k)) {
        goto LABEL_216;
      }
      int v97 = sub_180850B44((const void **)__n, v96);
      if (!v97)
      {
        int v129 = 7;
LABEL_285:
        int v83 = v153;
        goto LABEL_287;
      }

      if (100 - v93 <= (int)k)
      {
        int v129 = 1;
        goto LABEL_285;
      }

      v98 = v97;
      memcpy(&v166[v93], v90, k);
      v166[(v93 + k)] = 0;
      void *v98 = &v166[v93];
      v93 += k + 1;
      sub_180853C9C(&v164, (uint64_t)v98);
      if (v90[k]) {
        v90 += k + 1;
      }
      else {
        v90 += k;
      }
      int v92 = *v90;
      if (*v90) {
        continue;
      }
      break;
    }

    size_t v90 = 0LL;
LABEL_216:
    v99 = v164;
    int v83 = v153;
    uint64_t v100 = v147;
    if (v164)
    {
      int v101 = sub_180853FF0(v157, v96);
      if (v101)
      {
        v103 = v101;
        v104 = (icu::CharString *)sub_180850934(v156, v102);
        if (v104)
        {
          v105 = v104;
          uint64_t v144 = (uint64_t)v103;
          v106 = v99;
          do
          {
            uint64_t v107 = (const char **)v106[1];
            if (v106 != v99) {
              icu::CharString::append(v105, 45, v154);
            }
            icu::StringPiece::StringPiece((icu::StringPiece *)&v161, *v106);
            icu::CharString::append(v105, v161, v162, v154);
            v106 = v107;
          }

          while (v107);
          int v83 = v153;
          if (*(int *)v154 <= 0)
          {
            void *v103 = "attribute";
            v103[1] = *(void *)v105;
            uint64_t v100 = v147;
            int v129 = 1;
LABEL_287:
            UErrorCode *v154 = v129;
          }

          sub_180850D68((uint64_t)__n);
          int v151 = 0;
          goto LABEL_289;
        }
      }

      int v129 = 7;
      goto LABEL_287;
    }

LABEL_225:
    sub_180850D68((uint64_t)__n);
    if (v90)
    {
      int v108 = 0LL;
      v109 = 0LL;
      LODWORD(__n[0]) = 0;
      LODWORD(v164) = 0;
      if (v100) {
        BOOL v110 = 0;
      }
      else {
        BOOL v110 = v151 == 0;
      }
      int v111 = v110;
      int v142 = v111;
      int v151 = 0;
      while (1)
      {
        int v112 = *v90;
        if (*v90)
        {
          uint64_t v113 = 0LL;
          do
          {
            if (v112 == 45) {
              break;
            }
            v114 = &v90[v113++];
            int v112 = v114[1];
          }

          while (v112);
          if (!sub_18085136C(v90, v113))
          {
            if (v108)
            {
              LODWORD(v164) = (_DWORD)v164 + v113 + 1;
            }

            else
            {
              LODWORD(v164) = v113;
              int v108 = v90;
            }

            goto LABEL_271;
          }

          if (!v109)
          {
            LODWORD(__n[0]) = v113;
            v109 = v90;
LABEL_271:
            if (v90[v113]) {
              v90 += v113 + 1;
            }
            else {
              v90 += v113;
            }
            continue;
          }

          int v115 = 0;
          __int128 v116 = v90;
          if (v90[v113]) {
            v90 += v113 + 1;
          }
          else {
            v90 += v113;
          }
        }

        else
        {
          LODWORD(v113) = 0;
          __int128 v116 = 0LL;
          int v115 = 1;
        }

        char v160 = 0;
        *(_WORD *)__dst = 0;
        uint64_t v117 = SLODWORD(__n[0]);
        if (SLODWORD(__n[0]) >= 3
          || (v145 = v116,
              int v148 = v115,
              strncpy(__dst, v109, SLODWORD(__n[0])),
              __dst[v117] = 0,
              (__int128 v118 = (char *)uloc_toLegacyKey(__dst)) == 0LL))
        {
          UErrorCode *v154 = U_ILLEGAL_ARGUMENT_ERROR;
          int v83 = v153;
          goto LABEL_289;
        }

        v119 = v118;
        int v83 = v153;
        if (v118 == __dst)
        {
          T_CString_toLowerCase((unsigned __int8 *)__dst);
          uint64_t v120 = (const char **)sub_180853B7C((int *)v156, __dst, (int *)__n, v154);
          if (!v120)
          {
            UErrorCode *v154 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_289;
          }

          v119 = *v120;
        }

        if (v108)
        {
          __int128 v172 = 0u;
          __int128 v173 = 0u;
          __int128 v170 = 0u;
          __int128 v171 = 0u;
          __int128 v168 = 0u;
          __int128 v169 = 0u;
          *(_OWORD *)v166 = 0u;
          __int128 v167 = 0u;
          uint64_t v121 = (int)v164;
          if ((int)v164 > 127
            || (strncpy(v166, v108, (int)v164),
                v166[v121] = 0,
                (v122 = (char *)uloc_toLegacyType((uint64_t)v119, v166)) == 0LL))
          {
            int v130 = 1;
            int v83 = v153;
LABEL_295:
            UErrorCode *v154 = v130;
            goto LABEL_289;
          }

          v123 = v122;
          int v83 = v153;
          if (v122 == v166)
          {
            T_CString_toLowerCase((unsigned __int8 *)v166);
            v124 = (const char **)sub_180853B7C((int *)v156, v166, (int *)&v164, v154);
            if (!v124)
            {
              int v130 = 7;
              goto LABEL_295;
            }

            v123 = *v124;
          }
        }

        else
        {
          v123 = "yes";
        }

        if (v142 && !strcmp(v119, "va") && !strcmp(v123, "posix"))
        {
          int v151 = 1;
        }

        else
        {
          v125 = sub_180853FF0(v157, (unint64_t)v70);
          if (!v125)
          {
            UErrorCode *v154 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_289;
          }

          void *v125 = v119;
          v125[1] = v123;
          sub_1808540C8(&v165, (uint64_t)v125, 0);
        }

        int v108 = 0LL;
        v109 = v145;
        if (v145) {
          int v126 = v113;
        }
        else {
          int v126 = 0;
        }
        LODWORD(__n[0]) = v126;
        LODWORD(v164) = 0;
        if (v148) {
          goto LABEL_280;
        }
      }
    }

LABEL_279:
    int v151 = 0;
LABEL_280:
    UErrorCode v70 = v165;
    if (v165)
    {
      do
      {
        v128 = (const char **)v70[2];
        sub_1808540C8(&v158, (uint64_t)v70, 0);
        UErrorCode v70 = v128;
      }

      while (v128);
    }

LABEL_289:
LABEL_290:
    ++v84;
    BOOL v23 = v82 == v83++;
    if (!v23) {
      continue;
    }
    break;
  }

  UErrorCode v80 = *v154;
  if (*(int *)v154 <= 0)
  {
    int v131 = v151;
LABEL_301:
    v132 = *(const char **)(v14 + 72);
    if ((int)strlen(v132) < 1)
    {
LABEL_305:
      if (v80 <= U_ZERO_ERROR && v131)
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "_POSIX", 6LL);
        UErrorCode v80 = *v154;
      }

      if (v80 <= U_ZERO_ERROR)
      {
        v135 = v158;
        if (v158)
        {
          v136 = "@";
          do
          {
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, v136, 1LL);
            size_t v137 = strlen(*v135);
            (*(void (**)(uint64_t, const char *, size_t))(*(void *)a3 + 16LL))(a3, *v135, v137);
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16LL))(a3, "=", 1LL);
            size_t v138 = strlen(v135[1]);
            (*(void (**)(uint64_t, const char *, size_t))(*(void *)a3 + 16LL))(a3, v135[1], v138);
            v135 = (const char **)v135[2];
            v136 = ";";
          }

          while (v135);
        }
      }

      goto LABEL_318;
    }

    v134 = sub_180853FF0(v157, v133);
    if (v134)
    {
      void *v134 = "x";
      v134[1] = v132;
      if (sub_1808540C8(&v158, (uint64_t)v134, 0))
      {
        UErrorCode v80 = *v154;
        goto LABEL_305;
      }

LABEL_316:
      int v139 = 1;
LABEL_317:
      UErrorCode *v154 = v139;
      goto LABEL_318;
    }

        *((_BYTE *)this + 168) = 1;
        goto LABEL_317;
      case 0x23:
        uint64_t v33 = *v15;
        unint64_t v34 = &v15[v18 & 0xFFFFFF];
LABEL_133:
        v34[2] = v33;
        goto LABEL_318;
      case 0x24:
        v15[1] = v17 + 2;
LABEL_135:
        int v111 = v18 & 0xFFFFFF;
        goto LABEL_654;
      case 0x25:
        int v112 = *((void *)this + 24);
        *(void *)(v112 + 8 * (v18 & 0xFFFFFF)) = *(int *)(*((void *)this + 22) + 8LL);
        *(void *)(v112 + 8LL * (v21 + 1)) = *v15;
        *(void *)(v112 + 8LL * (v21 + 2)) = *((void *)this + 14);
        *(void *)(v112 + 8LL * (v21 + 3)) = *((void *)this + 15);
        *((_OWORD *)this + 7) = *((_OWORD *)this + 6);
        goto LABEL_318;
      case 0x26:
        uint64_t v113 = *((void *)this + 22);
        v114 = *((void *)this + 24);
        int v115 = *(void *)(v114 + 8 * (v18 & 0xFFFFFF));
        if (*(_DWORD *)(v113 + 8) <= (int)v115)
        {
          uint64_t v117 = v15;
        }

        else
        {
          __int128 v116 = *((int *)this + 14);
          uint64_t v117 = (int64_t *)(*(void *)(v113 + 24) + 8LL * (int)v115 - 8 * v116);
          if ((int)v116 >= 1)
          {
            __int128 v118 = *((unsigned int *)this + 14);
            v119 = v117;
            do
            {
              uint64_t v120 = *v15++;
              *v119++ = v120;
              --v118;
            }

            while (v118);
          }

          icu::UVector64::setSize((icu::UVector64 *)v113, v115);
          v114 = *((void *)this + 24);
          unint64_t v15 = v117;
        }

        *uint64_t v117 = *(void *)(v114 + 8LL * (v21 + 1));
        goto LABEL_322;
      case 0x27:
        uint64_t v121 = *v15;
        if (*v15 >= *((void *)this + 15)) {
          goto LABEL_316;
        }
        v122 = (UText *)*((void *)this + 4);
        v123 = v121 - v122->chunkNativeStart;
        if (v123 < 0 || v123 >= v122->nativeIndexingLimit || v122->chunkContents[v123] >> 10 > 0x36u)
        {
          utext_setNativeIndex(v122, v121);
          v122 = (UText *)*((void *)this + 4);
          LODWORD(v123) = v122->chunkOffset;
        }

        else
        {
          v122->chunkOffset = v123;
        }

        else {
          v122->chunkOffset = v123 + 1;
        }
        if (u_foldCase(v244, 0) == v21) {
          goto LABEL_614;
        }
        goto LABEL_317;
      case 0x28:
        v124 = *(void *)(v11 + 8 * v19);
        v15[1] = v17 + 2;
        v125 = *((void *)this + 4);
        int v126 = *v15 - *(void *)(v125 + 32);
        if (v126 < 0
          || v126 >= *(int *)(v125 + 28)
          || *(unsigned __int16 *)(*(void *)(v125 + 48) + 2 * v126) >> 10 > 0x36u)
        {
          utext_setNativeIndex(*((UText **)this + 4), *v15);
          v125 = *((void *)this + 4);
        }

        else
        {
          *(_DWORD *)(v125 + 40) = v126;
        }

        v197 = v10 + 2 * (v18 & 0xFFFFFF);
        v198 = v124 & 0xFFFFFF;
        v402 = 0LL;
        v403 = 0LL;
        v404 = 0LL;
        sub_180969948((uint64_t)&v402, v125);
        v199 = 0;
        while (2)
        {
          v200 = sub_180847660((uint64_t)&v402);
          if (v199 < v198)
          {
            if (v200
              || ((v201 = *((void *)this + 4), v202 = *(int *)(v201 + 40), (int)v202 <= *(_DWORD *)(v201 + 28))
                ? (v203 = *(void *)(v201 + 32) + v202)
                : (v203 = (*(uint64_t (**)(void))(*(void *)(v201 + 56) + 64LL))()),
                  v203 < *((void *)this + 15)))
            {
              v204 = v199 + 1LL;
              v205 = *(unsigned __int16 *)(v197 + 2LL * v199);
              if ((v205 & 0xFC00) == 0xD800 && (_DWORD)v204 != v198)
              {
                v207 = *(unsigned __int16 *)(v197 + 2 * v204);
                v208 = (v207 & 0xFC00) == 56320;
                v209 = (v205 << 10) - 56613888 + v207;
                if (v208) {
                  LODWORD(v204) = v199 + 2;
                }
                if (v208) {
                  v205 = v209;
                }
              }

              v199 = v204;
              continue;
            }

            *((_BYTE *)this + 168) = 1;
LABEL_626:
            sub_180847660((uint64_t)&v402);
LABEL_627:
            v326 = *((void *)this + 22);
            v327 = *((int *)this + 14);
            v328 = (*(_DWORD *)(v326 + 8) - v327) & ~((*(_DWORD *)(v326 + 8) - (int)v327) >> 31);
            *(_DWORD *)(v326 + 8) = v328;
            unint64_t v15 = (int64_t *)(*(void *)(v326 + 24) + 8LL * v328 - 8 * v327);
            goto LABEL_681;
          }

          break;
        }

        if (v200) {
          goto LABEL_627;
        }
        v229 = *((void *)this + 4);
        v230 = *(int *)(v229 + 40);
        else {
          v231 = (*(uint64_t (**)(void))(*(void *)(v229 + 56) + 64LL))();
        }
        *unint64_t v15 = v231;
        goto LABEL_681;
      case 0x29:
        v127 = v15[(v18 & 0xFFFFFF) + 2];
        if (v127 < 0) {
          goto LABEL_317;
        }
        v128 = v15[(v21 + 1) + 2];
        utext_setNativeIndex(*((UText **)this + 5), v127);
        utext_setNativeIndex(*((UText **)this + 4), *v15);
        v402 = 0LL;
        v403 = 0LL;
        v404 = 0LL;
        sub_180969948((uint64_t)&v402, *((void *)this + 5));
        memset(v401, 0, sizeof(v401));
        sub_180969948((uint64_t)v401, *((void *)this + 4));
        while (2)
        {
          if (sub_180847660((uint64_t)&v402) || utext_getNativeIndex(*((const UText **)this + 5)) < v128)
          {
            if (sub_180847660((uint64_t)v401)
              || utext_getNativeIndex(*((const UText **)this + 4)) < *((void *)this + 15))
            {
              int v129 = sub_180969954((uint64_t)&v402);
              continue;
            }

            *((_BYTE *)this + 168) = 1;
LABEL_632:
            v332 = *((void *)this + 22);
            v333 = *((int *)this + 14);
            v334 = (*(_DWORD *)(v332 + 8) - v333) & ~((*(_DWORD *)(v332 + 8) - (int)v333) >> 31);
            *(_DWORD *)(v332 + 8) = v334;
            unint64_t v15 = (int64_t *)(*(void *)(v332 + 24) + 8LL * v334 - 8 * v333);
            goto LABEL_633;
          }

          break;
        }

        v329 = *((void *)this + 4);
        v330 = *(int *)(v329 + 40);
        else {
          v331 = (*(uint64_t (**)(void))(*(void *)(v329 + 56) + 64LL))();
        }
        *unint64_t v15 = v331;
LABEL_633:
        nullsub_17(v401);
LABEL_681:
        nullsub_17(&v402);
        goto LABEL_318;
      case 0x2A:
        int v130 = *v15;
        if (*v15 >= *((void *)this + 11)) {
          goto LABEL_751;
        }
        int v131 = (UText *)*((void *)this + 4);
        v132 = v130 - v131->chunkNativeStart;
        if (v132 < 0 || v132 >= v131->nativeIndexingLimit || v131->chunkContents[v132] >> 10 > 0x36u)
        {
          utext_setNativeIndex(v131, v130);
          int v131 = (UText *)*((void *)this + 4);
          LODWORD(v132) = v131->chunkOffset;
        }

        else
        {
          v131->chunkOffset = v132;
        }

        if ((v245 & 0xFFFFDF50) != 0) {
          goto LABEL_317;
        }
        if (v245 > 132)
        {
          goto LABEL_317;
        }

        if ((v245 - 11) >= 3)
        {
          if (v245 != 10) {
            goto LABEL_317;
          }
          if (*v15 > *((void *)this + 10))
          {
            v246 = (UText *)*((void *)this + 4);
            v247 = v246->chunkOffset;
            v248 = v247 - 1;
            if (v247 < 1 || (v249 = v246->chunkContents[v248], v249 >> 11 > 0x1A)) {
              v249 = utext_previous32(v246);
            }
            else {
              v246->chunkOffset = v248;
            }
            if (v249 == 13) {
              goto LABEL_317;
            }
          }
        }

        goto LABEL_318;
      case 0x2B:
        unint64_t v133 = *v15;
        if (*v15 != *((void *)this + 10))
        {
          v134 = (UText *)*((void *)this + 4);
          v135 = v133 - v134->chunkNativeStart;
          if (v135 < 0 || v135 >= v134->nativeIndexingLimit || v134->chunkContents[v135] >> 10 > 0x36u)
          {
            utext_setNativeIndex(v134, v133);
            v134 = (UText *)*((void *)this + 4);
            LODWORD(v135) = v134->chunkOffset;
          }

          else
          {
            v134->chunkOffset = v135;
          }

          v250 = v135 - 1;
          else {
            v134->chunkOffset = v250;
          }
        }

        goto LABEL_318;
      case 0x2C:
        int v35 = (int64_t *)*((void *)this + 24);
        v35[v18 & 0xFFFFFF] = *(int *)(*((void *)this + 22) + 8LL);
        v35[v21 + 1] = *v15;
        v35[v21 + 2] = *((void *)this + 14);
        v35[v21 + 3] = *((void *)this + 15);
        *((void *)this + 14) = *((void *)this + 8);
        *((void *)this + 15) = *v15;
        v37 = v21 + 4;
        size_t v36 = -1LL;
LABEL_170:
        v35[v37] = v36;
        goto LABEL_318;
      case 0x2D:
        v15[1] = v17 + 2;
        v136 = *(void *)(v11 + 8 * v19);
        v15[1] = v17 + 3;
        size_t v137 = *(void *)(v11 + 8 * (v17 + 2));
        size_t v138 = (UText *)*((void *)this + 4);
        if (v138->pFuncs->mapNativeIndexToUTF16) {
          int v139 = 3 * v137;
        }
        else {
          int v139 = v137;
        }
        int v140 = *((void *)this + 24);
        int v141 = (v21 + 4);
        int v142 = *(void *)(v140 + 8LL * v141);
        if ((v142 & 0x8000000000000000LL) == 0)
        {
          if (!v142)
          {
            *(void *)(v140 + 8 * v141) = -1LL;
LABEL_641:
            v335 = *((void *)this + 22);
            v336 = *((int *)this + 14);
            v337 = (*(_DWORD *)(v335 + 8) - v336) & ~((*(_DWORD *)(v335 + 8) - (int)v336) >> 31);
            *(_DWORD *)(v335 + 8) = v337;
            v338 = *(void *)(v335 + 24) + 8LL * v337;
            v339 = *((void *)this + 24);
            unint64_t v15 = (int64_t *)(v338 - 8 * v336);
            *((void *)this + 14) = *(void *)(v339 + 8LL * (v21 + 2));
            v228 = *(void *)(v339 + 8LL * (v21 + 3));
LABEL_642:
            *((void *)this + 15) = v228;
            goto LABEL_318;
          }

          v143 = v142 - v138->chunkNativeStart;
          if (v143 < 0 || v143 >= v138->nativeIndexingLimit || v138->chunkContents[v143] >> 10 > 0x36u)
          {
            utext_setNativeIndex(v138, v142);
            size_t v138 = (UText *)*((void *)this + 4);
            LODWORD(v143) = v138->chunkOffset;
          }

          else
          {
            v138->chunkOffset = v143;
          }

          uint64_t v91 = __OFSUB__((_DWORD)v143, 1);
          v289 = v143 - 1;
          if (v289 < 0 != v91 || v138->chunkContents[v289] >> 11 > 0x1Au)
          {
            utext_previous32(v138);
            size_t v138 = (UText *)*((void *)this + 4);
            v289 = v138->chunkOffset;
          }

          else
          {
            v138->chunkOffset = v289;
          }

          if (v289 <= v138->nativeIndexingLimit)
          {
            v270 = v138->chunkNativeStart + v289;
            goto LABEL_638;
          }

LABEL_315:
    int v139 = 7;
    goto LABEL_317;
  }

LABEL_318:
  sub_180850DC8((uint64_t)v156);
  sub_180850D68((uint64_t)v157);
  return sub_18085424C(&v155);
}

uint64_t sub_180853A44(uint64_t result)
{
  if (result)
  {
    for (uint64_t i = result; ; uint64_t i = v2)
    {
      uint64_t v2 = *(void *)(i + 8);
      uint64_t v3 = v2;
      if (!v2) {
        break;
      }
      do
      {
        uint64_t v4 = *(const char **)i;
        uint64_t v5 = *(const char **)v3;
        BOOL result = strcmp(*(const char **)i, *(const char **)v3);
        if ((int)result >= 1)
        {
          *(void *)uint64_t i = v5;
          *(void *)uint64_t v3 = v4;
        }

        uint64_t v3 = *(void *)(v3 + 8);
      }

      while (v3);
    }
  }

  return result;
}

uint64_t sub_180853AB4(char *a1, int a2)
{
  if (a2 < 1) {
    return 1LL;
  }
  uint64_t v3 = a2;
  while (uprv_isASCIILetter(*a1) || *a1 - 48 <= 9)
  {
    ++a1;
    if (!--v3) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t sub_180853B18(const char ***a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    uint64_t v4 = *(const char **)a2;
    while (1)
    {
      uint64_t v5 = v3;
      uint64_t result = strcmp(v4, *v3);
      if (!(_DWORD)result) {
        break;
      }
      uint64_t v3 = (const char **)v5[1];
      if (!v3)
      {
        v5[1] = (const char *)a2;
        *(void *)(a2 + 8) = 0LL;
        return 1LL;
      }
    }
  }

  else
  {
    *(void *)(a2 + 8) = 0LL;
    *a1 = (const char **)a2;
    return 1LL;
  }

  return result;
}

uint64_t sub_180853B7C(int *a1, const char *a2, int *a3, UErrorCode *a4)
{
  int v8 = a1[4];
  if (*a1 != v8)
  {
LABEL_16:
    uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    uint64_t v11 = v13;
    if (v13)
    {
      int v14 = *a3;
      *(void *)uint64_t v13 = v13 + 13;
      *(_DWORD *)(v13 + 8) = 40;
      *(_WORD *)(v13 + 12) = 0;
      *(_DWORD *)(v13 + 56) = 0;
      icu::CharString::append((icu::CharString *)v13, a2, v14, a4);
    }

    uint64_t v15 = *a1;
    *a1 = v15 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v15) = v11;
    return v11;
  }

  if (v8 == 8) {
    int v9 = 32;
  }
  else {
    int v9 = 2 * v8;
  }
  if (v9 < 1) {
    return 0LL;
  }
  BOOL v10 = uprv_malloc(8LL * v9);
  uint64_t v11 = (uint64_t)v10;
  if (v10)
  {
    if (v8 >= 1)
    {
      int v12 = a1[4];
      if (v12 >= v8) {
        int v12 = v8;
      }
      if (v12 >= v9) {
        int v12 = v9;
      }
      memcpy(v10, *((const void **)a1 + 1), 8LL * v12);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v11;
    a1[4] = v9;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v11;
}

uint64_t sub_180853C9C(const char ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (!*a1)
  {
    *(void *)(a2 + 8) = 0LL;
    *a1 = (const char **)a2;
    return 1LL;
  }

  uint64_t v5 = *(const char **)a2;
  uint64_t result = strcmp(*(const char **)a2, *v4);
  if ((result & 0x80000000) != 0)
  {
    int v7 = 0LL;
LABEL_9:
    if (v7) {
      int v9 = (const char ***)(v7 + 1);
    }
    else {
      int v9 = a1;
    }
    *int v9 = (const char **)a2;
    *(void *)(a2 + 8) = v4;
    return 1LL;
  }

  int v8 = v4;
  while ((_DWORD)result)
  {
    uint64_t v4 = (const char **)v8[1];
    if (!v4)
    {
      v8[1] = (const char *)a2;
      *(void *)(a2 + 8) = 0LL;
      return 1LL;
    }

    uint64_t result = strcmp(v5, *v4);
    int v7 = v8;
    int v8 = v4;
    if ((result & 0x80000000) != 0) {
      goto LABEL_9;
    }
  }

  return result;
}

uint64_t sub_180853D48(int *a1, unint64_t a2, UErrorCode *a3)
{
  int v6 = a1[4];
  if (*a1 != v6)
  {
LABEL_16:
    uint64_t v11 = icu::UMemory::operator new((icu::UMemory *)0x40, a2);
    uint64_t v9 = v11;
    if (v11)
    {
      *(void *)uint64_t v11 = v11 + 13;
      *(_DWORD *)(v11 + 8) = 40;
      *(_WORD *)(v11 + 12) = 0;
      *(_DWORD *)(v11 + 56) = 0;
      icu::CharString::append((icu::CharString *)v11, *(const char **)a2, *(_DWORD *)(a2 + 56), a3);
    }

    uint64_t v12 = *a1;
    *a1 = v12 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v12) = v9;
    return v9;
  }

  if (v6 == 8) {
    int v7 = 32;
  }
  else {
    int v7 = 2 * v6;
  }
  if (v7 < 1) {
    return 0LL;
  }
  int v8 = uprv_malloc(8LL * v7);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    if (v6 >= 1)
    {
      int v10 = a1[4];
      if (v10 >= v6) {
        int v10 = v6;
      }
      if (v10 >= v7) {
        int v10 = v7;
      }
      memcpy(v8, *((const void **)a1 + 1), 8LL * v10);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v9;
    a1[4] = v7;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v9;
}

BOOL sub_180853E5C(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  BOOL result = 0;
  if (a2 == 1)
  {
    BOOL v3 = !uprv_isASCIILetter(*__s) && (*__s - 48) > 9u;
  }

  return result;
}

uint64_t sub_180853ECC(int *a1, const char **a2, int *a3, UErrorCode *a4)
{
  int v8 = a1[4];
  if (*a1 != v8)
  {
LABEL_16:
    uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    uint64_t v11 = v13;
    if (v13)
    {
      int v14 = *a2;
      int v15 = *a3;
      *(_BYTE *)(v13 + 13) = 0;
      *(void *)uint64_t v13 = v13 + 13;
      *(_DWORD *)(v13 + 8) = 40;
      *(_BYTE *)(v13 + 12) = 0;
      *(_DWORD *)(v13 + 56) = 0;
      icu::CharString::append((icu::CharString *)v13, v14, v15, a4);
    }

    uint64_t v16 = *a1;
    *a1 = v16 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v16) = v11;
    return v11;
  }

  if (v8 == 8) {
    int v9 = 32;
  }
  else {
    int v9 = 2 * v8;
  }
  if (v9 < 1) {
    return 0LL;
  }
  int v10 = uprv_malloc(8LL * v9);
  uint64_t v11 = (uint64_t)v10;
  if (v10)
  {
    if (v8 >= 1)
    {
      int v12 = a1[4];
      if (v12 >= v8) {
        int v12 = v8;
      }
      if (v12 >= v9) {
        int v12 = v9;
      }
      memcpy(v10, *((const void **)a1 + 1), 8LL * v12);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v11;
    a1[4] = v9;
    *((_BYTE *)a1 + 20) = 1;
    goto LABEL_16;
  }

  return v11;
}

void *sub_180853FF0(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0LL;
    }
    BOOL result = uprv_malloc(8LL * v4);
    if (!result) {
      return result;
    }
    int v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8LL * v7);
    }

    if (*((_BYTE *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((_BYTE *)a1 + 20) = 1;
  }

  BOOL result = (void *)icu::UMemory::operator new((icu::UMemory *)0x18, a2);
  if (result)
  {
    *BOOL result = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
  }

  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_1808540C8(const char ***a1, uint64_t a2, int a3)
{
  uint64_t v5 = *a1;
  if (*a1)
  {
    int v7 = 0LL;
    uint64_t v8 = *(const char **)a2;
    while (1)
    {
      int v9 = v7;
      int v7 = v5;
      if (a3)
      {
        int v10 = strlen(v8);
        uint64_t v11 = *v7;
        uint64_t v12 = strlen(*v7);
        if (v10 == 1LL && v12 == 1)
        {
          int v13 = *(unsigned __int8 *)v8;
          int v14 = *(unsigned __int8 *)v11;
          if (v13 == v14) {
            return 0LL;
          }
          int v15 = (char)v13 - (char)v14;
        }

        else if (v10 == 1LL)
        {
          int v15 = *v8 - 117;
        }

        else if (v12 == 1)
        {
          int v15 = 117 - *v11;
        }

        else
        {
          uint64_t result = strcmp(v8, v11);
          if (!(_DWORD)result) {
            return result;
          }
          int v15 = result;
          if (!strcmp(v11, "attribute")) {
            goto LABEL_20;
          }
          if (!strcmp(v8, "attribute")) {
            goto LABEL_24;
          }
        }
      }

      else
      {
        int v15 = strcmp(v8, *v5);
      }

      if (v15 < 0)
      {
LABEL_24:
        int v17 = (const char ***)(v9 + 2);
        if (!v9) {
          int v17 = a1;
        }
        *int v17 = (const char **)a2;
        *(void *)(a2 + 16) = v7;
        return 1LL;
      }

      if (!v15) {
        return 0LL;
      }
LABEL_20:
      uint64_t v5 = (const char **)v7[2];
      if (!v5)
      {
        v7[2] = (const char *)a2;
        *(void *)(a2 + 16) = 0LL;
        return 1LL;
      }
    }
  }

  *(void *)(a2 + 16) = 0LL;
  *a1 = (const char **)a2;
  return 1LL;
}

uint64_t *sub_18085424C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uprv_free(*(void **)v2);
    int v3 = *(void **)(v2 + 56);
    if (v3)
    {
      do
      {
        int v4 = (void *)v3[1];
        uprv_free(v3);
        int v3 = v4;
      }

      while (v4);
    }

    uint64_t v5 = *(void **)(v2 + 64);
    if (v5)
    {
      do
      {
        int v6 = (void *)v5[2];
        uprv_free(v5);
        uint64_t v5 = v6;
      }

      while (v6);
    }

    uprv_free((void *)v2);
  }

  return a1;
}

icu::Locale *ulocale_openForLocaleID(char *__s, int a2, UErrorCode *a3)
{
  uint64_t v5 = __s;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  memset(&v12[1], 0, 48);
  if (a2 < 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v9, __s);
    uint64_t v5 = v9;
  }

  else
  {
    int v9 = __s;
    int v10 = a2;
  }

  v12[0] = (char *)&v12[1] + 5;
  LODWORD(v12[1]) = 40;
  WORD2(v12[1]) = 0;
  LODWORD(v13) = 0;
  icu::CharString::append((icu::CharString *)v12, v5, v10, a3);
  if (*(int *)a3 <= 0)
  {
    icu::Locale::createFromName((icu::Locale *)v12[0], (uint64_t)v11);
    int v6 = icu::Locale::clone((icu::Locale *)v11, v7);
    icu::Locale::~Locale((icu::Locale *)v11);
  }

  else
  {
    int v6 = 0LL;
  }

  if (BYTE4(v12[1])) {
    uprv_free(v12[0]);
  }
  return v6;
}

icu::Locale *ulocale_openForLanguageTag(char *__s, int a2, int *a3)
{
  int v4 = __s;
  uint64_t v11 = *MEMORY[0x1895F89C0];
  memset(v10, 0, sizeof(v10));
  if (a2 < 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v8, __s);
    int v4 = v8;
  }

  else
  {
    uint64_t v8 = __s;
    LODWORD(v9) = a2;
  }

  icu::Locale::forLanguageTag(v4, v9, a3, (uint64_t)v10);
  if (*a3 <= 0) {
    int v6 = icu::Locale::clone((icu::Locale *)v10, v5);
  }
  else {
    int v6 = 0LL;
  }
  icu::Locale::~Locale((icu::Locale *)v10);
  return v6;
}

uint64_t ulocale_close(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t ulocale_getLanguage(uint64_t a1)
{
  if (a1) {
    return a1 + 8;
  }
  else {
    return 0LL;
  }
}

uint64_t ulocale_getScript(uint64_t a1)
{
  if (a1) {
    return a1 + 20;
  }
  else {
    return 0LL;
  }
}

uint64_t ulocale_getRegion(uint64_t a1)
{
  if (a1) {
    return a1 + 26;
  }
  else {
    return 0LL;
  }
}

uint64_t ulocale_getVariant(uint64_t result)
{
  if (result) {
    return *(void *)(result + 208) + *(int *)(result + 32);
  }
  return result;
}

uint64_t ulocale_getLocaleID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

icu::Locale *ulocale_getBaseName(icu::Locale *result)
{
  if (result) {
    return (icu::Locale *)icu::Locale::getBaseName(result);
  }
  return result;
}

uint64_t ulocale_getKeywordValue(uint64_t a1, const char *a2, int a3, char *a4, int a5, UErrorCode *a6)
{
  uint64_t v6 = a1;
  if (a1)
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v15, a4, a5);
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v13, a2);
      a2 = v13;
    }

    else
    {
      uint64_t v13 = a2;
      LODWORD(v14) = a3;
    }

    icu::Locale::getKeywordValue(v6, a2, v14, (uint64_t)&v15, a6);
    uint64_t v6 = DWORD2(v16);
    if (*(int *)a6 <= 0)
    {
      if (BYTE12(v16)) {
        *a6 = U_BUFFER_OVERFLOW_ERROR;
      }
      else {
        u_terminateChars((uint64_t)a4, a5, DWORD2(v16), (int *)a6);
      }
    }

    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v15);
  }

  else
  {
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v6;
}

uint64_t ulocale_getUnicodeKeywordValue(uint64_t a1, const char *a2, int a3, char *a4, int a5, UErrorCode *a6)
{
  uint64_t v6 = a1;
  if (a1)
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v15, a4, a5);
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v13, a2);
      a2 = v13;
    }

    else
    {
      uint64_t v13 = a2;
      LODWORD(v14) = a3;
    }

    icu::Locale::getUnicodeKeywordValue(v6, a2, v14, (uint64_t)&v15, a6);
    uint64_t v6 = DWORD2(v16);
    if (*(int *)a6 <= 0)
    {
      if (BYTE12(v16)) {
        *a6 = U_BUFFER_OVERFLOW_ERROR;
      }
      else {
        u_terminateChars((uint64_t)a4, a5, DWORD2(v16), (int *)a6);
      }
    }

    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v15);
  }

  else
  {
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v6;
}

_OWORD *ulocale_getKeywords(icu::Locale *a1, UErrorCode *a2)
{
  if (!a1)
  {
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0LL;
  }

  Keywords = icu::Locale::createKeywords(a1, a2);
  return uenum_openFromStringEnumeration((uint64_t)Keywords, (int *)a2);
}

_OWORD *ulocale_getUnicodeKeywords(icu::Locale *a1, UErrorCode *a2)
{
  if (!a1)
  {
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0LL;
  }

  UnicodeKeywords = icu::Locale::createUnicodeKeywords(a1, a2);
  return uenum_openFromStringEnumeration((uint64_t)UnicodeKeywords, (int *)a2);
}

BOOL ulocale_isBogus(BOOL result)
{
  if (result) {
    return *(_BYTE *)(result + 216) != 0;
  }
  return result;
}

uint64_t *ulocbld_open@<X0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a2, (icu::UMemory *)0x30, a1);
  if (result) {
    return icu::LocaleBuilder::LocaleBuilder(result);
  }
  return result;
}

uint64_t ulocbld_close(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void ulocbld_setLocale(icu::LocaleBuilder *a1, const char *a2, unsigned int a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    memset(v9, 0, 224);
    icu::Locale::Locale((icu::Locale *)v9);
    if ((a3 & 0x80000000) != 0 || !a2[a3])
    {
      uint64_t v6 = a2;
    }

    else
    {
      if (a3 >= 0x9D)
      {
        icu::Locale::setToBogus((icu::Locale *)v9);
LABEL_9:
        icu::LocaleBuilder::setLocale(a1, (const icu::Locale *)v9);
        icu::Locale::~Locale((icu::Locale *)v9);
        return;
      }

      bzero(&__dst[a3], 157LL - a3);
      memcpy(__dst, a2, a3);
      __dst[a3] = 0;
      uint64_t v6 = __dst;
    }

    icu::Locale::Locale((icu::Locale *)v8, v6, 0LL, 0LL, 0LL);
    icu::Locale::operator=((uint64_t)v9, (uint64_t)v8);
    icu::Locale::~Locale((icu::Locale *)v8);
    goto LABEL_9;
  }

icu::LocaleBuilder *ulocbld_adoptULocale(icu::LocaleBuilder *result, const icu::Locale *a2)
{
  if (result)
  {
    icu::LocaleBuilder::setLocale(result, a2);
    return (icu::LocaleBuilder *)ulocale_close((uint64_t)a2);
  }

  return result;
}

int *ulocbld_setLanguageTag(int *result, char *a2, int a3)
{
  if (result)
  {
    int v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::setLanguageTag(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_setLanguage(uint64_t result, char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::setLanguage(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_setScript(uint64_t result, char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::setScript(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_setRegion(uint64_t result, char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::setRegion(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_setVariant(uint64_t result, const char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::setVariant(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_addUnicodeLocaleAttribute(uint64_t result, const char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::addUnicodeLocaleAttribute(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_removeUnicodeLocaleAttribute(uint64_t result, const char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }

    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }

    return icu::LocaleBuilder::removeUnicodeLocaleAttribute(v3, a2, v5);
  }

  return result;
}

uint64_t ulocbld_setExtension(uint64_t result, int a2, char *__s, int a4)
{
  if (result)
  {
    uint64_t v5 = result;
    if (a4 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v6, __s);
      __s = v6;
    }

    else
    {
      uint64_t v6 = __s;
      LODWORD(v7) = a4;
    }

    return icu::LocaleBuilder::setExtension(v5, a2, __s, v7);
  }

  return result;
}

uint64_t ulocbld_setUnicodeLocaleKeyword(uint64_t result, const char *a2, int a3, char *__s, int a5)
{
  if (result)
  {
    uint64_t v7 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v10, a2);
      if ((a5 & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      uint64_t v10 = (char *)a2;
      LODWORD(v11) = a3;
      if ((a5 & 0x80000000) == 0)
      {
LABEL_4:
        uint64_t v8 = __s;
        LODWORD(v9) = a5;
        return icu::LocaleBuilder::setUnicodeLocaleKeyword(v7, v10, v11, __s, v9);
      }
    }

    icu::StringPiece::StringPiece((icu::StringPiece *)&v8, __s);
    __s = v8;
    return icu::LocaleBuilder::setUnicodeLocaleKeyword(v7, v10, v11, __s, v9);
  }

  return result;
}

icu::LocaleBuilder *ulocbld_clear(icu::LocaleBuilder *this)
{
  if (this) {
    return icu::LocaleBuilder::clear(this);
  }
  return this;
}

icu::LocaleBuilder *ulocbld_clearExtensions(icu::LocaleBuilder *this)
{
  if (this) {
    return icu::LocaleBuilder::clearExtensions(this);
  }
  return this;
}

icu::Locale *ulocbld_buildULocale(icu::LocaleBuilder *a1, UErrorCode *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    memset(v6, 0, sizeof(v6));
    icu::LocaleBuilder::build(a1, a2, (icu::Locale *)v6);
    if (*(int *)a2 <= 0)
    {
      int v4 = icu::Locale::clone((icu::Locale *)v6, v3);
      if (!v4) {
        *a2 = U_MEMORY_ALLOCATION_ERROR;
      }
    }

    else
    {
      int v4 = 0LL;
    }

    icu::Locale::~Locale((icu::Locale *)v6);
  }

  else
  {
    int v4 = 0LL;
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v4;
}

uint64_t ulocbld_buildLocaleID(icu::LocaleBuilder *a1, void *a2, int a3, UErrorCode *a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    *(_OWORD *)__s = 0u;
    __int128 v13 = 0u;
    memset(v11, 0, sizeof(v11));
    icu::LocaleBuilder::build(a1, a4, (icu::Locale *)v11);
    if (*(int *)a4 <= 0)
    {
      size_t v8 = strlen(__s[1]);
      uint64_t v9 = v8;
      uint64_t v7 = u_terminateChars((uint64_t)a2, a3, v9, (int *)a4);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    icu::Locale::~Locale((icu::Locale *)v11);
  }

  else
  {
    uint64_t v7 = 0LL;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v7;
}

uint64_t ulocbld_buildLanguageTag(icu::LocaleBuilder *a1, char *a2, int a3, UErrorCode *a4)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    memset(v11, 0, sizeof(v11));
    icu::LocaleBuilder::build(a1, a4, (icu::Locale *)v11);
    if (*(int *)a4 <= 0)
    {
      __int128 v9 = 0u;
      __int128 v10 = 0u;
      icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v9, a2, a3);
      icu::Locale::toLanguageTag((char **)v11, (icu::ByteSink *)&v9, a4);
      uint64_t v7 = DWORD2(v10);
      if (*(int *)a4 <= 0)
      {
        if (BYTE12(v10)) {
          *a4 = U_BUFFER_OVERFLOW_ERROR;
        }
        else {
          u_terminateChars((uint64_t)a2, a3, DWORD2(v10), (int *)a4);
        }
      }

      icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v9);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    icu::Locale::~Locale((icu::Locale *)v11);
  }

  else
  {
    uint64_t v7 = 0LL;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v7;
}

BOOL ulocbld_copyErrorTo(icu::LocaleBuilder *a1, UErrorCode *a2)
{
  if (a1) {
    return icu::LocaleBuilder::copyErrorTo(a1, a2);
  }
  *a2 = U_ILLEGAL_ARGUMENT_ERROR;
  return 1LL;
}

void *ulocdata_open(char *a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  uint64_t v6 = uprv_malloc(0x18uLL);
  uint64_t v2 = v6;
  if (!v6)
  {
    *a2 = 7;
    return v2;
  }

  v6[2] = 0LL;
  *(_BYTE *)uint64_t v6 = 0;
  v6[1] = ures_open(0LL, a1, a2);
  int v7 = *a2;
  if (*a2 >= 1)
  {
    uprv_free(v2);
    return 0LL;
  }

  v2[2] = ures_open("icudt74l-lang", a1, a2);
  if (*a2 == 2) {
    *a2 = v7;
  }
  return v2;
}

void ulocdata_close(uint64_t *a1)
{
  if (a1)
  {
    ures_close(a1[2]);
    ures_close(a1[1]);
    uprv_free(a1);
  }

_BYTE *ulocdata_setNoSubstitute(_BYTE *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t ulocdata_getNoSubstitute(char *a1)
{
  return *a1;
}

icu::UnicodeSet *ulocdata_getExemplarSet(uint64_t a1, icu::UnicodeSet *a2, int a3, int a4, UErrorCode *a5)
{
  uint64_t v12 = 0LL;
  StringByKey = ures_getStringByKey(*(void *)(a1 + 8), off_18971B148[a4], (int *)&v12 + 1, (int *)&v12);
  int v10 = v12;
  if ((_DWORD)v12 == -127)
  {
    if (*(_BYTE *)a1)
    {
      int v10 = 2;
      LODWORD(v12) = 2;
    }

    else
    {
      int v10 = -127;
    }
  }

  else if (!(_DWORD)v12)
  {
    int v10 = *a5;
    goto LABEL_9;
  }

  *a5 = v10;
LABEL_9:
  if (v10 > 0) {
    return 0LL;
  }
  if (!a2) {
    return uset_openPatternOptions((uint64_t)StringByKey, SHIDWORD(v12), a3 | 1u, a5);
  }
  uset_applyPattern(a2, (uint64_t)StringByKey, HIDWORD(v12), a3 | 1, a5);
  return a2;
}

uint64_t ulocdata_getDelimiter(uint64_t a1, int a2, UChar *a3, int32_t a4, int *a5)
{
  uint64_t result = 0LL;
  uint64_t v16 = 0LL;
  if (*a5 <= 0)
  {
    uint64_t v11 = ures_getByKey(*(void *)(a1 + 8), "delimiters", 0LL, (int *)&v16);
    uint64_t v12 = v11;
    int v13 = v16;
    if ((_DWORD)v16 == -127)
    {
      if (*(_BYTE *)a1)
      {
        int v13 = 2;
        LODWORD(v16) = 2;
      }

      else
      {
        int v13 = -127;
      }
    }

    else if (!(_DWORD)v16)
    {
      int v13 = *a5;
      goto LABEL_9;
    }

    *a5 = v13;
LABEL_9:
    if (v13 >= 1)
    {
      ures_close(v11);
      return 0LL;
    }

    StringByKeyWithFallbacsize_t k = ures_getStringByKeyWithFallback( v11,  off_18971B168[a2],  (int *)&v16 + 1,  (UErrorCode *)&v16);
    ures_close(v12);
    int v15 = v16;
    if ((_DWORD)v16 == -127)
    {
      if (*(_BYTE *)a1)
      {
        int v15 = 2;
        LODWORD(v16) = 2;
      }

      else
      {
        int v15 = -127;
      }
    }

    else if (!(_DWORD)v16)
    {
      int v15 = *a5;
      goto LABEL_18;
    }

    *a5 = v15;
LABEL_18:
    if (v15 <= 0)
    {
      u_strncpy(a3, StringByKeyWithFallback, a4);
      return HIDWORD(v16);
    }

    return 0LL;
  }

  return result;
}

uint64_t ulocdata_getMeasurementSystem(char *a1, int *a2)
{
  if (!a2) {
    return 3LL;
  }
  uint64_t v3 = 3LL;
  if (*a2 <= 0)
  {
    uint64_t v4 = sub_180855334(a1, "MeasurementSystem", a2);
    unsigned int Int = ures_getInt(v4, a2);
    if (*a2 <= 0) {
      uint64_t v3 = Int;
    }
    else {
      uint64_t v3 = 3LL;
    }
    ures_close(v4);
  }

  return v3;
}

uint64_t sub_180855334(char *a1, const char *a2, int *a3)
{
  int v11 = 0;
  ulocimp_getRegionForSupplementalData(a1, 1, (char *)&v11, 4, a3);
  uint64_t v5 = ures_openDirect(0LL, (uint64_t)"supplementalData", (uint64_t)a3);
  ures_getByKey(v5, "measurementData", v5, a3);
  if (v5)
  {
    uint64_t v6 = ures_getByKey(v5, (const char *)&v11, 0LL, a3);
    uint64_t v7 = v6;
    int v8 = *a3;
    if (*a3 <= 0)
    {
      uint64_t v9 = ures_getByKey(v6, a2, 0LL, a3);
      int v8 = *a3;
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    if (v8 == 2)
    {
      *a3 = 0;
      if (v7) {
        ures_close(v7);
      }
      uint64_t v7 = ures_getByKey(v5, "001", 0LL, a3);
      uint64_t v9 = ures_getByKey(v7, a2, 0LL, a3);
    }

    ures_close(v7);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  ures_close(v5);
  return v9;
}

void ulocdata_getPaperSize(char *a1, int *a2, _DWORD *a3, int *a4)
{
  int v9 = 0;
  if (a4 && *a4 <= 0)
  {
    uint64_t v7 = sub_180855334(a1, "PaperSize", a4);
    IntVector = ures_getIntVector(v7, &v9, a4);
    if (*a4 <= 0)
    {
      if (v9 > 1)
      {
        *a2 = *IntVector;
        *a3 = IntVector[1];
      }

      else
      {
        *a4 = 5;
      }
    }

    ures_close(v7);
  }

void ulocdata_getCLDRVersion(uint8_t *a1, int *a2)
{
  uint64_t v4 = ures_openDirect(0LL, (uint64_t)"supplementalData", (uint64_t)a2);
  ures_getVersionByKey(v4, "cldrVersion", a1, a2);
  ures_close(v4);
}

uint64_t ulocdata_getLocaleDisplayPattern(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t result = 0LL;
  uint64_t v14 = 0LL;
  if (*a4 <= 0)
  {
    uint64_t result = *(void *)(a1 + 16);
    if (!result)
    {
      *a4 = 2;
      return result;
    }

    uint64_t v9 = ures_getByKey(result, "localeDisplayPattern", 0LL, (int *)&v14);
    uint64_t v10 = v9;
    int v11 = v14;
    if ((_DWORD)v14 == -127)
    {
      if (*(_BYTE *)a1)
      {
        int v11 = 2;
        LODWORD(v14) = 2;
      }

      else
      {
        int v11 = -127;
      }
    }

    else if (!(_DWORD)v14)
    {
      int v11 = *a4;
      goto LABEL_11;
    }

    *a4 = v11;
LABEL_11:
    if (v11 >= 1)
    {
      ures_close(v9);
      return 0LL;
    }

    StringByKey = ures_getStringByKey(v9, "pattern", (int *)&v14 + 1, (int *)&v14);
    ures_close(v10);
    int v13 = v14;
    if ((_DWORD)v14 == -127)
    {
      if (*(_BYTE *)a1)
      {
        int v13 = 2;
        LODWORD(v14) = 2;
      }

      else
      {
        int v13 = -127;
      }
    }

    else if (!(_DWORD)v14)
    {
      int v13 = *a4;
      goto LABEL_20;
    }

    *a4 = v13;
LABEL_20:
    if (v13 <= 0)
    {
      u_strncpy(a2, StringByKey, a3);
      return HIDWORD(v14);
    }

    return 0LL;
  }

  return result;
}

uint64_t ulocdata_getLocaleSeparator(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t result = 0LL;
  uint64_t v17 = 0LL;
  if (*a4 > 0) {
    return result;
  }
  uint64_t result = *(void *)(a1 + 16);
  if (!result)
  {
    *a4 = 2;
    return result;
  }

  uint64_t v9 = ures_getByKey(result, "localeDisplayPattern", 0LL, (int *)&v17);
  uint64_t v10 = v9;
  int v11 = v17;
  if ((_DWORD)v17 == -127)
  {
    if (*(_BYTE *)a1)
    {
      int v11 = 2;
      LODWORD(v17) = 2;
    }

    else
    {
      int v11 = -127;
    }
  }

  else if (!(_DWORD)v17)
  {
    int v11 = *a4;
    goto LABEL_11;
  }

  *a4 = v11;
LABEL_11:
  if (v11 >= 1)
  {
    ures_close(v9);
    return 0LL;
  }

  StringByKey = ures_getStringByKey(v9, "separator", (int *)&v17 + 1, (int *)&v17);
  ures_close(v10);
  int v13 = v17;
  if ((_DWORD)v17 == -127)
  {
    if (*(_BYTE *)a1)
    {
      int v13 = 2;
      LODWORD(v17) = 2;
    }

    else
    {
      int v13 = -127;
    }

    goto LABEL_19;
  }

  if ((_DWORD)v17)
  {
LABEL_19:
    *a4 = v13;
    goto LABEL_20;
  }

  int v13 = *a4;
LABEL_20:
  if (v13 > 0) {
    return 0LL;
  }
  uint64_t v14 = u_strstr(StringByKey, (const UChar *)"{");
  int v15 = u_strstr(StringByKey, (const UChar *)"{");
  if (v14
    && v15
    && v14 <= v15
    && (StringByKey = v14 + 3,
        unint64_t v16 = (unint64_t)((char *)v15 - (char *)(v14 + 3)) >> 1,
        HIDWORD(v17) = v16,
        (int)v16 < a3))
  {
    u_strncpy(a2, v14 + 3, v16);
    uint64_t result = SHIDWORD(v17);
    a2[SHIDWORD(v17)] = 0;
  }

  else
  {
    u_strncpy(a2, StringByKey, a3);
    return HIDWORD(v17);
  }

  return result;
}

uint64_t uprv_mapFile(void *a1, const char *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  memset(&v12, 0, sizeof(v12));
  sub_180847480((uint64_t)a1);
  uint64_t v3 = 0LL;
  if (!stat(a2, &v12))
  {
    int st_size = v12.st_size;
    if (v12.st_size >= 1)
    {
      int v8 = open( a2,  0,  *(_OWORD *)&v12.st_dev,  *(_OWORD *)&v12.st_uid,  *(_OWORD *)&v12.st_atimespec,  *(_OWORD *)&v12.st_mtimespec,  *(_OWORD *)&v12.st_ctimespec,  *(_OWORD *)&v12.st_birthtimespec);
      if (v8 != -1)
      {
        int v9 = v8;
        size_t v10 = st_size;
        int v11 = (char *)mmap(0LL, st_size, 1, 1, v8, 0LL);
        close(v9);
        if (v11 != (char *)-1LL)
        {
          a1[1] = v11;
          a1[4] = v11;
          a1[5] = &v11[v10];
          uint64_t v3 = 1LL;
          posix_madvise(v11, v10, 1);
          return v3;
        }
      }

      return 0LL;
    }
  }

  return v3;
}

uint64_t sub_180855938(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    uint64_t v2 = *(void *)(result + 40);
    if (v2)
    {
      uint64_t result = munmap(*(void **)(result + 32), v2 - *(void *)(result + 32));
      v1[1] = 0LL;
      v1[4] = 0LL;
      v1[5] = 0LL;
    }
  }

  return result;
}

uint64_t uprv_max(uint64_t result, int a2)
{
  else {
    return result;
  }
}

uint64_t uprv_min(uint64_t result, int a2)
{
  else {
    return result;
  }
}

void **umutablecptrie_open(int a1, unint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  int v5 = a2;
  uint64_t v7 = icu::UMemory::operator new((icu::UMemory *)0x11040, a2);
  if (!v7)
  {
    if (*a3 <= 0)
    {
      uint64_t result = 0LL;
      *a3 = 7;
      return result;
    }

    return 0LL;
  }

  uint64_t result = (void **)sub_180855A1C(v7, a1, v5, a3);
  if (*a3 >= 1)
  {
    int v8 = sub_180855C30(result);
    icu::UMemory::operator delete(v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_180855A1C(uint64_t a1, int a2, int a3, int *a4)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0xFFFFFFFF00000000LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = a2;
  *(void *)(a1 + 56) = 0LL;
  if (*a4 <= 0)
  {
    *(void *)a1 = uprv_malloc(0x4000uLL);
    uint64_t v6 = uprv_malloc(0x10000uLL);
    *(void *)(a1 + 16) = v6;
    if (*(void *)a1 && v6)
    {
      *(_DWORD *)(a1 + 8) = 4096;
      *(_DWORD *)(a1 + 24) = 0x4000;
    }

    else
    {
      *a4 = 7;
    }
  }

  return a1;
}

uint64_t *umutablecptrie_clone(uint64_t a1, int *a2)
{
  uint64_t v2 = 0LL;
  if (a1)
  {
    uint64_t v4 = (uint64_t *)*a2;
    if ((int)v4 <= 0)
    {
      uint64_t v6 = icu::UMemory::operator new(v4, (icu::UMemory *)0x11040, (unint64_t)a2);
      if (v6)
      {
        uint64_t v2 = v6;
        *uint64_t v6 = 0LL;
        int v7 = *(_DWORD *)(a1 + 12);
        *((_DWORD *)v6 + 2) = 0;
        *((_DWORD *)v6 + 3) = v7;
        v6[2] = 0LL;
        v6[3] = 0LL;
        *((_OWORD *)v6 + 2) = *(_OWORD *)(a1 + 32);
        uint64_t v8 = *(void *)(a1 + 48);
        v6[6] = v8;
        v6[7] = 0LL;
        if (*a2 <= 0)
        {
          else {
            int v9 = 4096;
          }
          *uint64_t v6 = (uint64_t)uprv_malloc((4 * v9));
          size_t v10 = uprv_malloc(4LL * *(int *)(a1 + 24));
          v2[2] = (uint64_t)v10;
          int v11 = (void *)*v2;
          if (*v2 && v10)
          {
            *((_DWORD *)v2 + 2) = v9;
            *((_DWORD *)v2 + 6) = *(_DWORD *)(a1 + 24);
            int v12 = *((_DWORD *)v2 + 12);
            int v13 = v12 >> 4;
            memcpy(v2 + 8, (const void *)(a1 + 64), (uint64_t)v12 >> 4);
            memcpy(v11, *(const void **)a1, 4 * v13);
            memcpy((void *)v2[2], *(const void **)(a1 + 16), 4LL * *(int *)(a1 + 28));
            *((_DWORD *)v2 + 7) = *(_DWORD *)(a1 + 28);
            if (*a2 < 1) {
              return v2;
            }
          }

          else
          {
            *a2 = 7;
          }
        }

        uint64_t v14 = sub_180855C30((void **)v2);
        icu::UMemory::operator delete(v14);
        return 0LL;
      }

      if (*a2 > 0) {
        return 0LL;
      }
      uint64_t v2 = 0LL;
      *a2 = 7;
    }
  }

  return v2;
}

void umutablecptrie_close(void **a1)
{
  if (a1)
  {
    int v1 = sub_180855C30(a1);
    icu::UMemory::operator delete(v1);
  }

void **sub_180855C30(void **a1)
{
  return a1;
}

void **umutablecptrie_fromUCPMap(UCPMap *map, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (!map)
  {
    uint64_t v2 = 0LL;
    int v15 = 1;
    goto LABEL_19;
  }

  uint32_t v6 = ucpmap_get(map, -1);
  uint32_t v7 = ucpmap_get(map, 1114111);
  size_t v10 = icu::UMemory::operator new(v9, (icu::UMemory *)0x11040, v8);
  if (!v10)
  {
    if (*a2 > 0) {
      return 0LL;
    }
    uint64_t v2 = 0LL;
    int v15 = 7;
LABEL_19:
    *a2 = v15;
    return v2;
  }

  uint64_t v2 = (void **)v10;
  sub_180855A1C((uint64_t)v10, v7, v6, a2);
  if (*a2 > 0) {
    goto LABEL_15;
  }
  uint32_t pValue = 0;
  UChar32 Range = ucpmap_getRange(map, 0, UCPMAP_RANGE_NORMAL, 0, 0LL, 0LL, &pValue);
  if ((Range & 0x80000000) == 0)
  {
    UChar32 v12 = Range;
    unsigned int v13 = 0;
    do
    {
      if (pValue != v7)
      {
        if (v13 == v12) {
          sub_1808562D0((uint64_t)v2, v12, pValue, a2);
        }
        else {
          sub_180856368((uint64_t)v2, v13, v12, pValue, a2);
        }
      }

      unsigned int v13 = v12 + 1;
      UChar32 v12 = ucpmap_getRange(map, v12 + 1, UCPMAP_RANGE_NORMAL, 0, 0LL, 0LL, &pValue);
    }

    while ((v12 & 0x80000000) == 0);
  }

  if (*a2 >= 1)
  {
LABEL_15:
    uint64_t v14 = sub_180855C30(v2);
    icu::UMemory::operator delete(v14);
    return 0LL;
  }

  return v2;
}

void **umutablecptrie_fromUCPTrie(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (!a1) {
    goto LABEL_8;
  }
  int v5 = *(char *)(a1 + 31);
  if (v5 == 2)
  {
    uint32_t v6 = (uint64_t *)(*(int *)(a1 + 20) + *(void *)(a1 + 8));
    int v8 = *((unsigned __int8 *)v6 - 1);
    int v9 = *((unsigned __int8 *)v6 - 2);
  }

  else
  {
    if (v5 != 1)
    {
      if (!*(_BYTE *)(a1 + 31))
      {
        uint32_t v6 = *(uint64_t **)(a1 + 8);
        int v7 = *(_DWORD *)(a1 + 20);
        int v8 = *((unsigned __int16 *)v6 + v7 - 1);
        int v9 = *((unsigned __int16 *)v6 + v7 - 2);
        goto LABEL_13;
      }

uint64_t umutablecptrie_get(uint64_t a1, unsigned int a2)
{
  if (a2 < 0x110000)
  {
    if (*(_DWORD *)(a1 + 48) <= (signed int)a2)
    {
      uint64_t v2 = (unsigned int *)(a1 + 52);
    }

    else
    {
      uint64_t v3 = a2 >> 4;
      if (*(_BYTE *)(a1 + v3 + 64)) {
        uint64_t v2 = (unsigned int *)(*(void *)(a1 + 16) + 4LL * (*(_DWORD *)(*(void *)a1 + 4 * v3) + (a2 & 0xF)));
      }
      else {
        uint64_t v2 = (unsigned int *)(*(void *)a1 + 4 * v3);
      }
    }
  }

  else
  {
    uint64_t v2 = (unsigned int *)(a1 + 44);
  }

  return *v2;
}

uint64_t umutablecptrie_getRange(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, int *a7)
{
  return sub_180841AE8( (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18085602C,  a1,  a2,  a3,  a4,  a5,  a6,  a7);
}

uint64_t sub_18085602C( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, _DWORD *a5)
{
  if (WORD1(a2) > 0x10u) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = a2;
  uint64_t v5 = 1114111LL;
  if (*(_DWORD *)(a1 + 48) <= (int)a2)
  {
    if (a5)
    {
      uint64_t v30 = *(unsigned int *)(a1 + 52);
      if (a3) {
        LODWORD(v30) = a3(a4, v30);
      }
      *a5 = v30;
    }

    return v5;
  }

  int v11 = *(_DWORD *)(a1 + 40);
  if (a3) {
    int v11 = a3(a4, *(unsigned int *)(a1 + 40));
  }
  uint64_t v12 = 0LL;
  int v13 = 0;
  char v14 = 0;
  uint64_t v15 = v9 >> 4;
  while (1)
  {
    uint64_t v16 = *(unsigned int *)(*(void *)a1 + 4 * v15);
    if (!*(_BYTE *)(a1 + v15 + 64))
    {
      if ((v14 & 1) != 0)
      {
        if ((_DWORD)v16 == (_DWORD)v12)
        {
          uint64_t v16 = v12;
        }

        else
        {
          if (!a3) {
            return (v9 - 1);
          }
          int v26 = v11;
          if ((_DWORD)v16 != *(_DWORD *)(a1 + 40)) {
            int v26 = a3(a4, *(unsigned int *)(*(void *)a1 + 4 * v15));
          }
          if (v26 != v13) {
            return (v9 - 1);
          }
        }
      }

      else
      {
        int v20 = *(_DWORD *)(a1 + 40);
        if ((_DWORD)v16 == v20) {
          int v13 = v11;
        }
        else {
          int v13 = *(_DWORD *)(*(void *)a1 + 4 * v15);
        }
        if (a3 && (_DWORD)v16 != v20) {
          int v13 = a3(a4, *(unsigned int *)(*(void *)a1 + 4 * v15));
        }
        if (a5) {
          *a5 = v13;
        }
      }

      uint64_t v9 = (v9 & 0xFFFFFFF0) + 16;
      goto LABEL_49;
    }

    int v17 = v16 + (v9 & 0xF);
    uint64_t v18 = *(void *)(a1 + 16);
    uint64_t v16 = *(unsigned int *)(v18 + 4LL * v17);
    if ((v14 & 1) != 0)
    {
      if ((_DWORD)v16 == (_DWORD)v12)
      {
        uint64_t v16 = v12;
      }

      else
      {
        if (!a3) {
          return (v9 - 1);
        }
        int v21 = v11;
        if ((_DWORD)v16 != *(_DWORD *)(a1 + 40)) {
          int v21 = a3(a4, *(unsigned int *)(v18 + 4LL * v17));
        }
        if (v21 != v13) {
          return (v9 - 1);
        }
      }
    }

    else
    {
      int v19 = *(_DWORD *)(a1 + 40);
      if ((_DWORD)v16 == v19) {
        int v13 = v11;
      }
      else {
        int v13 = *(_DWORD *)(v18 + 4LL * v17);
      }
      if (a3 && (_DWORD)v16 != v19) {
        int v13 = a3(a4, *(unsigned int *)(v18 + 4LL * v17));
      }
      if (a5) {
        *a5 = v13;
      }
    }

    if ((((_BYTE)v9 + 1) & 0xF) != 0) {
      break;
    }
    uint64_t v9 = (v9 + 1);
LABEL_49:
    ++v15;
    char v14 = 1;
    uint64_t v12 = v16;
    if ((int)v9 >= *(_DWORD *)(a1 + 48))
    {
      int v27 = *(_DWORD *)(a1 + 52);
      int v28 = *(_DWORD *)(a1 + 40);
      if (v27 == v28) {
        int v29 = v11;
      }
      else {
        int v29 = *(_DWORD *)(a1 + 52);
      }
      if (a3 && v27 != v28) {
        int v29 = ((uint64_t (*)(uint64_t))a3)(a4);
      }
      if (v29 == v13) {
        return 1114111LL;
      }
      else {
        return (v9 - 1);
      }
    }
  }

  uint64_t v22 = 4LL * v17 + 4;
  while (1)
  {
    int v23 = v16;
    uint64_t v16 = *(unsigned int *)(*(void *)(a1 + 16) + v22);
    if ((_DWORD)v16 != v23)
    {
      if (!a3) {
        return v9;
      }
      int v24 = v11;
      if ((_DWORD)v16 != *(_DWORD *)(a1 + 40)) {
        int v24 = a3(a4, *(unsigned int *)(*(void *)(a1 + 16) + v22));
      }
      if (v24 != v13) {
        return v9;
      }
    }

    char v25 = v9 + 2;
    uint64_t v9 = (v9 + 1);
    v22 += 4LL;
    if ((v25 & 0xF) == 0)
    {
      uint64_t v9 = (v9 + 1);
      goto LABEL_49;
    }
  }

uint64_t umutablecptrie_set(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0) {
    return sub_1808562D0(result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_1808562D0(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a2 < 0x110000)
    {
      int v8 = (void *)result;
      uint64_t result = sub_180857E08(result, a2);
      if ((_DWORD)result)
      {
        uint64_t result = sub_180857EC8(v8, a2 >> 4);
        if ((result & 0x80000000) == 0)
        {
          *(_DWORD *)(v8[2] + 4LL * (result + (a2 & 0xF))) = a3;
          return result;
        }
      }

      int v6 = 7;
    }

    else
    {
      int v6 = 1;
    }

    *a4 = v6;
  }

  return result;
}

uint64_t umutablecptrie_setRange(uint64_t result, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  if (*a5 <= 0) {
    return sub_180856368(result, a2, a3, a4, a5);
  }
  return result;
}

uint64_t sub_180856368(uint64_t result, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  if (*a5 > 0) {
    return result;
  }
  LODWORD(v7) = a2;
  int v8 = 1;
  if ((int)a2 > a3 || a2 > 0x10FFFF || a3 > 0x10FFFF)
  {
LABEL_29:
    *a5 = v8;
    return result;
  }

  int v10 = (void *)result;
  uint64_t result = sub_180857E08(result, a3);
  if (!(_DWORD)result) {
    goto LABEL_28;
  }
  unsigned int v11 = a3 + 1;
  unsigned int v12 = v7 & 0xF;
  if ((v7 & 0xF) == 0) {
    goto LABEL_15;
  }
  uint64_t result = sub_180857EC8(v10, v7 >> 4);
  if ((result & 0x80000000) != 0)
  {
LABEL_28:
    int v8 = 7;
    goto LABEL_29;
  }

  LODWORD(v7) = (v7 + 15) & 0xFFFFFFF0;
  uint64_t v13 = v10[2] + 4LL * result;
  if (v7 > v11)
  {
    if (v12 < (v11 & 0xF))
    {
      unint64_t v14 = v13 + 4LL * (v11 & 0xF);
      uint64_t v15 = (unsigned int *)(v13 + 4LL * v12);
      do
        *v15++ = a4;
      while ((unint64_t)v15 < v14);
    }

    return result;
  }

  uint64_t v16 = 4LL * v12;
  do
  {
    *(_DWORD *)(v13 + v16) = a4;
    v16 += 4LL;
  }

  while (v16 != 64);
LABEL_15:
  if ((int)v7 < (int)(v11 & 0xFFFFFFF0))
  {
    unint64_t v7 = v7;
    int32x4_t v17 = vdupq_n_s32(a4);
    do
    {
      unint64_t v18 = v7 >> 4;
      if (*((_BYTE *)v10 + (v7 >> 4) + 64))
      {
        uint64_t v19 = 0LL;
        uint64_t v20 = v10[2] + 4LL * *(unsigned int *)(*v10 + 4 * v18);
        do
        {
          *(int32x4_t *)(v20 + v19) = v17;
          v19 += 16LL;
        }

        while (v19 != 64);
      }

      else
      {
        *(_DWORD *)(*v10 + 4 * v18) = a4;
      }

      v7 += 16LL;
    }

    while ((int)(v11 & 0xFFFFFFF0) > (int)v7);
  }

  if ((v11 & 0xF) != 0)
  {
    uint64_t result = sub_180857EC8(v10, v7 >> 4);
    if ((result & 0x80000000) == 0)
    {
      int v21 = (unsigned int *)(v10[2] + 4LL * result);
      uint64_t v22 = &v21[v11 & 0xF];
      do
        *v21++ = a4;
      while (v21 < v22);
      return result;
    }

    goto LABEL_28;
  }

  return result;
}

char *umutablecptrie_buildImmutable()
{
  unsigned int v0 = (int8x8_t *)MEMORY[0x1895F8858]();
  uint64_t v297 = *MEMORY[0x1895F89C0];
  if (*v3 <= 0)
  {
    if (v1 > 1 || v2 >= 3)
    {
      uint64_t v4 = 0LL;
      *uint64_t v3 = 1;
      return v4;
    }

    uint64_t v5 = v0;
    if (v2)
    {
      if (v2 != 2) {
        goto LABEL_18;
      }
      unsigned int v6 = 255;
    }

    else
    {
      unsigned int v6 = 0xFFFF;
    }

    v0[5] = vand_s8(v0[5], (int8x8_t)vdup_n_s32(v6));
    unint64_t v7 = v0[6].u32[0];
    v0[6].i32[1] &= v6;
    if ((int)v7 >= 16)
    {
      uint64_t v8 = 0LL;
      unint64_t v9 = v7 >> 4;
      do
      {
        if (!v0[8].i8[v8]) {
          *(_DWORD *)(*(void *)v0 + 4 * v8) &= v6;
        }
        ++v8;
      }

      while (v9 != v8);
    }

    if (v0[3].i32[1] >= 1)
    {
      uint64_t v10 = 0LL;
      int8x8_t v11 = v0[2];
      do
        *(_DWORD *)(*(void *)&v11 + 4 * v10++) &= v6;
      while (v10 < v0[3].i32[1]);
    }

LABEL_188:
                  int v112 = v69 + 1;
                  int v113 = v69 + 1 - v73;
                  uint64_t v114 = v113;
                  uint64_t v115 = (int)v69;
                  while (v115 > v114)
                  {
                    uint64_t v116 = v62 + 4 * v115--;
                    --v112;
                    if (*(_DWORD *)(v116 - 4) != v77) {
                      goto LABEL_196;
                    }
                  }

                  int v112 = v113;
LABEL_196:
                  int v285 = v74;
                  uint64_t v117 = v71;
                  *(_DWORD *)(*(void *)&v76 + 4LL * v75) = v112;
                  uint64_t v118 = v69;
                  if ((int)v69 - v112 < (int)v73)
                  {
                    v119 = (unsigned int *)(v62 + 4LL * (int)v69);
                    int v120 = v112 + v73;
                    LODWORD(v118) = v69;
                    do
                    {
                      *v119++ = v77;
                      uint64_t v118 = (v118 + 1);
                    }

                    while (v120 != (_DWORD)v118);
                  }

                  int v121 = v69;
                  uint64_t v122 = v73;
                  sub_180858168((uint64_t)&v289, v62, v121, v118);
                  uint64_t v73 = v122;
                  uint64_t v69 = v118;
                  int v72 = v274;
                  uint64_t v71 = v117;
                  int v74 = v285;
                  unsigned int v67 = v276;
                  goto LABEL_200;
                }

LABEL_187:
                if ((v107 & 1) != 0) {
                  goto LABEL_188;
                }
LABEL_194:
                *(_DWORD *)(*(void *)&v76 + 4LL * v75) = v106;
              }

            if (v13)
            {
              *(_WORD *)uint64_t v16 = 11077;
              if ((v13 & 0x80000000) != 0)
              {
                v16[1] = 45;
                unint64_t v13 = -v13;
              }

              unsigned int v77 = 0;
              unsigned int v78 = 9u;
              v16 += 2;
              do
              {
                *uint64_t v16 = 48;
                int v79 = dword_180A37120[v78];
                if (v13 <= 2 * v79)
                {
                  uint64_t v85 = 2 * v79;
                  int v81 = 48;
                }

                else
                {
                  signed int v80 = 8 * v79;
                  if (v13 < 8 * v79) {
                    int v81 = 48;
                  }
                  else {
                    int v81 = 56;
                  }
                  if (v13 < 8 * v79) {
                    int v82 = 0;
                  }
                  else {
                    int v82 = 8 * v79;
                  }
                  int v83 = v13 - v82;
                  uint64_t result = 4 * (v79 & 0x1FFFFFFFu);
                  if (v83 < v80 >> 1)
                  {
                    int v84 = 0;
                  }

                  else
                  {
                    v81 |= 4u;
                    int v84 = 4 * (v79 & 0x1FFFFFFF);
                  }

                  unint64_t v13 = v83 - v84;
                  uint64_t v85 = v80 >> 2;
                }

                if (v13 < v85)
                {
                  int8x8_t v86 = 0;
                }

                else
                {
                  v81 += 2;
                  int8x8_t v86 = v85;
                }

                unsigned int v87 = v13 - v86;
                if (v87 < v85 >> 1)
                {
                  v88 = 0;
                }

                else
                {
                  ++v81;
                  v88 = v85 >> 1;
                }

                if (v13 >= v85 || v87 >= v85 >> 1) {
                  *uint64_t v16 = v81;
                }
                unint64_t v13 = v87 - v88;
                if (v77) {
                  uint64_t v90 = 0;
                }
                else {
                  uint64_t v90 = v81 == 48;
                }
                unsigned int v77 = !v90;
                if (!v90) {
                  ++v16;
                }
                --v78;
              }

              while (v78 != -1);
            }

            *uint64_t v16 = 0;
            return result;
          }

          int8x8_t v11 = 0;
          int v50 = *--v9;
          uint64_t v15 = v50;
        }

        int v51 = 48;
        v3[v48] = 48;
        int v52 = dword_180A37120[v11];
        if (v15 <= 2 * v52)
        {
          uint64_t v57 = 2 * v52;
        }

        else
        {
          uint64_t v53 = 8 * v52;
          if (v15 < 8 * v52) {
            int v51 = 48;
          }
          else {
            int v51 = 56;
          }
          if (v15 < 8 * v52) {
            int v54 = 0;
          }
          else {
            int v54 = 8 * v52;
          }
          int v55 = v15 - v54;
          if (v55 < v53 >> 1)
          {
            uint64_t v56 = 0;
          }

          else
          {
            v51 |= 4u;
            uint64_t v56 = 4 * (v52 & 0x1FFFFFFF);
          }

          if (v15 >= 8 * v52 || v55 >= 4 * (v52 & 0x1FFFFFFFu)) {
            v3[v48] = v51;
          }
          uint64_t v15 = v55 - v56;
          uint64_t v57 = v53 >> 2;
        }

        if (v15 < v57) {
          int v58 = 0;
        }
        else {
          int v58 = v57;
        }
        int v59 = v15 - v58;
        uint64_t v60 = v57 >> 1;
        if (v59 < v57 >> 1) {
          unint64_t v61 = 0;
        }
        else {
          unint64_t v61 = v57 >> 1;
        }
        if (v15 >= v57 || v59 >= v60)
        {
          if (v15 >= v57) {
            v51 += 2;
          }
          if (v59 >= v60) {
            ++v51;
          }
          v3[v48] = v51;
        }

        uint64_t v15 = v59 - v61;
        --v11;
        ++v48;
        if (v14 + (int)--v49 <= 1)
        {
          uint64_t v16 = &v3[v48];
          if (v14 >= *(_DWORD *)result) {
            goto LABEL_187;
          }
          goto LABEL_150;
        }
      }
    }
  }

  return result;
}

LABEL_200:
              v75 += v74;
            }

            while (v75 < v72);
          }

          v123 = v281;
          if (*v281 > 0)
          {
            LODWORD(v124) = 0;
            goto LABEL_205;
          }

          uprv_free(*(void **)&v5[2]);
          v5[2] = (int8x8_t)v62;
          v5[3].i32[0] = v33;
          v5[3].i32[1] = v69;
          if ((int)v69 >= 262160)
          {
            LODWORD(v124) = 0;
            int v125 = 8;
            goto LABEL_204;
          }

          if ((v67 & 0x80000000) != 0)
          {
            LODWORD(v138) = 0xFFFFF;
          }

          else
          {
            uint64_t v138 = *(int *)(*(void *)v5 + 4LL * v67);
            v5[5].i32[0] = *(_DWORD *)(v62 + 4 * v138);
          }

          v5[4].i32[0] = v138;
          uint64_t v124 = v273 >> 6;
          if ((int)v124 >= v5[6].i32[0] >> 6)
          {
            v5[1].i32[1] = 0x7FFF;
            goto LABEL_368;
          }

          bzero(v296, 0x800uLL);
          uint64_t v146 = 0LL;
          uint64_t v147 = 0LL;
          int8x8_t v148 = *v5;
          else {
            int v149 = v13;
          }
          uint64_t v150 = ((v149 - 1) >> 2) + 1;
          int v151 = -1;
          int8x8_t v152 = *v5;
          do
          {
            int v153 = *(_DWORD *)(*(void *)&v148 + 4 * v146);
            v296[v147] = v153;
            if (v153 == v5[4].i32[0])
            {
              if (v151 < 0)
              {
                int v151 = v147;
              }

              else if (v5[1].i32[1] < 0 && (_DWORD)v147 - v151 == 31)
              {
                v5[1].i32[1] = v151;
              }
            }

            else
            {
              int v151 = -1;
            }

            v146 += 4LL;
            int v154 = v153 + 16;
            for (uint64_t i = 4LL; i != 16; i += 4LL)
            {
              *(_DWORD *)(*(void *)&v152 + i) = v154;
              v154 += 16;
            }

            ++v147;
            *(void *)&v152 += 16LL;
          }

          while (v147 != v150);
          int v156 = v272 == 0;
          sub_1808582DC((uint64_t)&v289, (uint64_t)v296, 0, 0, v124);
          unint64_t v157 = (v156 << 12);
          int v158 = v5[6].i32[0] >> 4;
          int v286 = v158;
          if (v158 <= v156 << 12)
          {
            int v160 = 0;
            char v159 = 0;
          }

          else
          {
            char v159 = 0;
            int v160 = 0;
            __int32 v161 = v5[1].i32[1];
            int64_t v162 = v158;
            uint64_t v163 = (uint64_t)*v5;
            uint64_t v164 = *(void *)v5 + 4LL * v157;
            int64_t v165 = v157;
            do
            {
              uint64_t v166 = 0LL;
              __int128 v167 = (const float *)&v5[4];
              int32x4_t v168 = (int32x4_t)vld1q_dup_f32(v167);
              int8x16_t v169 = 0uLL;
              v170.i64[0] = 0x101010101010101LL;
              v170.i64[1] = 0x101010101010101LL;
              int8x16_t v171 = 0uLL;
              int8x16_t v172 = 0uLL;
              int8x16_t v173 = 0uLL;
              do
              {
                int32x4_t v174 = *(int32x4_t *)(v164 + v166);
                int32x4_t v175 = *(int32x4_t *)(v164 + v166 + 16);
                int32x4_t v177 = *(int32x4_t *)(v164 + v166 + 32);
                int32x4_t v176 = *(int32x4_t *)(v164 + v166 + 48);
                int8x16_t v172 = vorrq_s8((int8x16_t)v177, v172);
                int8x16_t v171 = vorrq_s8((int8x16_t)v175, v171);
                int8x16_t v169 = vorrq_s8((int8x16_t)v174, v169);
                int8x16_t v173 = vorrq_s8((int8x16_t)v176, v173);
                int8x16_t v170 = vandq_s8( vuzp1q_s8( (int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v174, v168), (int16x8_t)vceqq_s32(v175, v168)),  (int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v177, v168), (int16x8_t)vceqq_s32(v176, v168))),  v170);
                v166 += 64LL;
              }

              while (v166 != 128);
              int8x16_t v178 = vorrq_s8(vorrq_s8(v169, v172), vorrq_s8(v171, v173));
              *(int8x8_t *)v178.i8 = vorr_s8(*(int8x8_t *)v178.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v178, v178, 8uLL));
              unsigned __int32 v179 = v178.i32[0] | v178.i32[1];
              if ((vmaxvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vmvnq_s8(v170), 7uLL))) & 1) != 0)
              {
                if (HIWORD(v179))
                {
                  v5[8].i8[v165] = 3;
                  v160 += 36;
                  char v159 = 1;
                }

                else
                {
                  int v180 = sub_1808583A0((uint64_t *)&v289, (uint64_t)v296, v163, v165);
                  v181 = (char *)&v5[8] + v165;
                  if (v180 < 0)
                  {
                    _BYTE *v181 = 2;
                    v160 += 32;
                  }

                  else
                  {
                    _BYTE *v181 = 1;
                    *(_DWORD *)(v163 + 4 * v165) = v180;
                  }
                }
              }

              else
              {
                v5[8].i8[v165] = 0;
                if (v161 < 0)
                {
                  __int32 v161 = 0;
                  unsigned __int32 v182 = HIWORD(v179);
                  BOOL v183 = v182 == 0;
                  BOOL v184 = v182 != 0;
                  if (v183) {
                    int v185 = 32;
                  }
                  else {
                    int v185 = 36;
                  }
                  v160 += v185;
                  v159 |= v184;
                }
              }

              v165 += 32LL;
              v164 += 128LL;
            }

            while (v165 < v162);
          }

          uint64_t v207 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
          int v208 = v207 + ((v286 - (int)v157) >> 5) + v160 + 1;
          v209 = uprv_malloc(2 * v208);
          v5[7] = (int8x8_t)v209;
          if (v209)
          {
            memcpy(v209, v296, v273 >> 5);
            v123 = v281;
            if ((sub_180858080((uint64_t)&v289, v208, 32) & 1) != 0)
            {
              memset(v293, 0, sizeof(v293));
              if ((v159 & 1) != 0 && (sub_180858080((uint64_t)v293, v208, 36) & 1) == 0)
              {
                LODWORD(v124) = 0;
                int *v281 = 7;
              }

              else
              {
                char v279 = v159;
                bzero(v295, 0x1100uLL);
                uint64_t v210 = v5[1].u32[1];
                uint64_t v283 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
                if (v286 > (int)v157)
                {
                  uint64_t v211 = 0LL;
                  uint64_t v287 = ((v286 + ~(_DWORD)v157) >> 5) + 1;
                  uint64_t v275 = (int)v207;
                  uint64_t v212 = v207;
                  uint64_t v213 = 4LL * v157;
                  uint64_t v214 = v212;
                  uint64_t v215 = v5[1].u32[1];
                  while (1)
                  {
                    int v216 = v5[8].u8[v157];
                    if (!v5[8].i8[v157] && (v215 & 0x80000000) != 0) {
                      break;
                    }
                    if (v5[8].i8[v157])
                    {
                      if (v216 == 2) {
                        goto LABEL_320;
                      }
                      if (v216 != 1)
                      {
LABEL_322:
                        uint64_t v222 = (uint64_t)v5[7];
                        v223 = (int16x8_t *)(v222 + 2LL * (int)v214 + 2);
                        v224 = (int16x8_t *)(*(void *)v5 + v213);
                        unint64_t v225 = v157;
                        do
                        {
                          int16x8_t v226 = *v224;
                          int16x8_t v227 = v224[1];
                          v224 += 2;
                          v225 += 8LL;
                          int16x8_t *v223 = vuzp1q_s16(v226, v227);
                          v223[-1].i16[7] = ((unsigned __int32)v226.i32[1] >> 4) & 0x3000 | ((unsigned __int32)v226.i32[0] >> 2) & 0xC000 | ((unsigned __int32)v226.i32[2] >> 6) & 0xC00 | ((unsigned __int32)v226.i32[3] >> 8) & 0x300 | ((unsigned __int32)v227.i32[0] >> 10) & 0xC0 | ((unsigned __int32)v227.i32[1] >> 12) & 0x30 | ((unsigned __int32)v227.i32[2] >> 14) & 0xC | v227.i8[14] & 3;
                          v223 = (int16x8_t *)((char *)v223 + 18);
                        }

                        while (v225 < v157 + 32);
                        int v228 = sub_1808584A0((uint64_t)v293, v222, v222, v214);
                        if (v228 < 0)
                        {
                          int v229 = v283;
                          if ((_DWORD)v214 == (_DWORD)v283)
                          {
LABEL_349:
                            uint64_t v230 = (v214 + 36);
                          }

                          else
                          {
                            uint64_t v234 = 0LL;
                            uint64_t v235 = 0x7FFFFFFFFFFFFFDDLL;
                            uint64_t v236 = 35LL;
                            uint64_t v237 = 36LL;
LABEL_330:
                            unint64_t v238 = v237--;
                            int v239 = v238;
                            v240 = (unsigned __int16 *)(v222 + 2LL * (int)v214);
                            do
                            {
                              if (v240[v235] != *v240)
                              {
                                --v236;
                                ++v235;
                                v234 -= 2LL;
                                if (v238 >= 3) {
                                  goto LABEL_330;
                                }
                                int v229 = v214;
                                goto LABEL_349;
                              }

                              ++v240;
                              --v239;
                            }

                            while (v239 > 1);
                            int v229 = v214 - v237;
                            if (v237 > 0x23)
                            {
                              uint64_t v230 = v214;
                            }

                            else
                            {
                              uint64_t v245 = 0LL;
                              do
                              {
                                *(_WORD *)(v222 + 2LL * (int)v214 + 2 * v245++) = *(_WORD *)(v222
                                                                                           + 2LL * (int)v214
                                                                                           + v234
                                                                                           + 70);
                                v234 += 2LL;
                              }

                              while (v234 != 2);
                              uint64_t v230 = (v214 + v245);
                            }
                          }

                          sub_1808582DC((uint64_t)&v289, v222, v283, v214, v230);
                          if ((v279 & 1) != 0) {
                            sub_1808582DC((uint64_t)v293, *(void *)&v5[7], v283, v214, v230);
                          }
                        }

                        else
                        {
                          int v229 = v228;
                          uint64_t v230 = v214;
                        }

                        uint64_t v217 = v229 | 0x8000u;
                        uint64_t v214 = v230;
                        goto LABEL_359;
                      }

                      uint64_t v217 = *(unsigned int *)(*(void *)v5 + 4 * v157);
                    }

                    else
                    {
                      uint64_t v217 = v210;
                    }

LABEL_354:
                    v247 = (_WORD *)(v233 + 2 * v232);
                    uint64_t v248 = 4 * v231;
                    uint64_t v246 = (v232 - v231 + 32);
                    do
                    {
                      *v247++ = *(_DWORD *)(*(void *)&v220 + v213 + v248);
                      v248 += 4LL;
                    }

                    while (v248 != 128);
LABEL_356:
                    sub_1808582DC((uint64_t)&v289, v233, v283, v214, v246);
                    if ((v279 & 1) != 0) {
                      sub_1808582DC((uint64_t)v293, *(void *)&v5[7], v283, v214, v246);
                    }
                    uint64_t v214 = v246;
                    uint64_t v215 = v218;
                  }

                  else
                  {
                    uint64_t v217 = v221;
                    uint64_t v215 = v218;
                  }

                  goto LABEL_359;
                }

                int v249 = 0;
                uint64_t v250 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
LABEL_370:
                if ((v210 & 0x80000000) != 0) {
                  v5[1].i32[1] = 0x7FFF;
                }
                if ((int)v250 > 32798)
                {
                  LODWORD(v250) = 0;
                  int *v123 = 8;
                  goto LABEL_409;
                }

                if (v249 >= 1)
                {
                  int v251 = 0;
                  uint64_t v288 = (int)v207;
                  uint64_t v252 = (uint64_t)v5[7];
                  int v280 = v249 + 1;
                  int v253 = 32;
                  int v254 = v249;
                  do
                  {
                    int v255 = v249 - v251;
                    if (v249 - v251 >= v253)
                    {
                      uint64_t v257 = v250;
                      int v256 = sub_1808584A0((uint64_t)&v289, v252, (uint64_t)v295, v251);
                      uint64_t v250 = v257;
                      LOWORD(v257) = v256;
                      if (v256 < 0) {
                        goto LABEL_391;
                      }
                      goto LABEL_405;
                    }

                    if ((int)v250 - v255 < (int)v207)
                    {
LABEL_378:
                      int v253 = v249 - v251;
                      goto LABEL_391;
                    }

                    uint64_t v257 = v288;
                    while (1)
                    {
                      if (v255 >= 1)
                      {
                        v258 = (unsigned __int16 *)(v252 + 2 * v257);
                        int v259 = v280 - v251;
                        v260 = &v295[v251];
                        while (*v258 == *v260)
                        {
                          ++v258;
                          ++v260;
                          if (--v259 <= 1)
                          {
                            int v253 = v249 - v251;
                            if ((v257 & 0x80000000) == 0) {
                              goto LABEL_405;
                            }
                            goto LABEL_391;
                          }
                        }

                        goto LABEL_388;
                      }

                      if (!v255) {
                        break;
                      }
LABEL_388:
                      if ((_DWORD)v250 - v255 + 1 == (_DWORD)++v257) {
                        goto LABEL_378;
                      }
                    }

                    int v253 = 0;
                    if ((v257 & 0x80000000) != 0)
                    {
LABEL_391:
                      if ((_DWORD)v250 == (_DWORD)v207)
                      {
                        int v261 = 0;
                        goto LABEL_402;
                      }

                      int v261 = v253 - 1;
                      if (v253 <= 1)
                      {
                        LOWORD(v257) = v250 - v261;
                        goto LABEL_403;
                      }

                      uint64_t v262 = v253;
                      do
                      {
                        uint64_t v263 = v262--;
                        v264 = (unsigned __int16 *)(v252 + 2 * ((int)v250 - v262));
                        int v265 = v263;
                        v266 = &v295[v251];
                        while (*v264 == *v266)
                        {
                          ++v264;
                          ++v266;
                          if (--v265 <= 1)
                          {
                            int v261 = v262;
                            goto LABEL_402;
                          }
                        }

                        int v261 = 0;
                      }

                      while (v263 >= 3);
LABEL_402:
                      LOWORD(v257) = v250 - v261;
                      uint64_t v267 = v250;
                      if (v261 < v253)
                      {
LABEL_403:
                        int v268 = v250;
                        memcpy( (void *)(v252 + 2LL * (int)v250),  &v295[v261 + v251],  2LL * (v253 + ~v261) + 2);
                        LODWORD(v250) = v268;
                        uint64_t v267 = (v253 + v268 - v261);
                      }

                      LODWORD(v207) = v283;
                      sub_1808582DC((uint64_t)&v289, v252, v283, v250, v267);
                      uint64_t v252 = (uint64_t)v5[7];
                      uint64_t v250 = v267;
                      int v249 = v254;
                    }

LABEL_405:
                    *(_WORD *)(v252 + 2 * v124++) = v257;
                    v251 += v253;
                  }

                  while (v251 < v249);
                }

LABEL_409:
                LODWORD(v124) = v250;
                v123 = v281;
              }

              uprv_free(*(void **)&v293[0]);
LABEL_368:
              unsigned int v126 = v277;
              v5[6].i32[0] = v269;
LABEL_206:
              uprv_free((void *)v289);
              if (*v123 >= 1)
              {
LABEL_207:
                v5[1].i32[1] = -1;
                *(int8x8_t *)((char *)&v5[3] + 4) = (int8x8_t)0xFFFFFFFF00000000LL;
                __int32 v127 = v5[4].i32[1];
                v5[5].i32[0] = v127;
                v5[6].i32[0] = 0;
                v5[6].i32[1] = v127;
                uprv_free(*(void **)&v5[7]);
                uint64_t v4 = 0LL;
LABEL_208:
                v5[7] = 0LL;
                return v4;
              }

              if (v126 == 1 && (v124 & 1) != 0)
              {
                *(_WORD *)(*(void *)&v5[7] + 2LL * (int)v124) = -18;
                int v129 = 2 * (v124 + 1);
                LODWORD(v124) = v124 + 1;
                goto LABEL_219;
              }

              int v129 = 2 * v124;
              if (v126)
              {
                if (v126 != 1)
                {
                  int v130 = v5[3].i32[1];
                  int v131 = ((_BYTE)v130 + (_BYTE)v129) & 3;
                  if ((((_BYTE)v130 + (_BYTE)v129) & 3) != 0)
                  {
                    if (v131 == 3)
                    {
                      int8x8_t v132 = v5[2];
                      if (*(_DWORD *)(*(void *)&v132 + 4LL * (v130 - 1)) != v5[6].i32[1]) {
                        goto LABEL_280;
                      }
                    }

                    else
                    {
                      if (v131 == 2)
                      {
                        int8x8_t v132 = v5[2];
                        goto LABEL_282;
                      }

                      int8x8_t v132 = v5[2];
                      do
                      {
LABEL_280:
                        __int32 v186 = v5[6].i32[1];
                        uint64_t v187 = v5[3].i32[1];
                        v5[3].i32[1] = v187 + 1;
                        *(_DWORD *)(*(void *)&v132 + 4 * v187) = v186;
                        int v131 = (v131 + 1) & 3;
                      }

                      while (v131 != 2);
                      int v130 = v5[3].i32[1];
LABEL_282:
                      __int32 v188 = v5[6].i32[1];
                      v5[3].i32[1] = v130 + 1;
                      *(_DWORD *)(*(void *)&v132 + 4LL * v130) = v188;
                      int v130 = v5[3].i32[1];
                    }

                    __int32 v189 = v5[5].i32[1];
                    v5[3].i32[1] = v130 + 1;
                    *(_DWORD *)(*(void *)&v132 + 4LL * v130) = v189;
                    int v130 = v5[3].i32[1];
                  }

                  else
                  {
                    int8x8_t v132 = v5[2];
                    if (*(_DWORD *)(*(void *)&v132 + 4LL * (v130 - 1)) != v5[5].i32[1]
                      || *(_DWORD *)(*(void *)&v132 + 4LL * (v130 - 2)) != v5[6].i32[1])
                    {
                      goto LABEL_280;
                    }
                  }

LABEL_284:
                  v190 = (char *)uprv_malloc(v129 + v130 + 48);
                  uint64_t v4 = v190;
                  if (v190)
                  {
                    *(_OWORD *)(v190 + 8) = 0u;
                    v191 = (char **)(v190 + 8);
                    *(_OWORD *)(v190 + 24) = 0u;
                    signed int v192 = v5[6].i32[0];
                    *((_WORD *)v190 + 14) = (v192 + 4095) >> 12;
                    __int32 v193 = v5[4].i32[0];
                    uint64_t v194 = v5[3].i32[1];
                    *((_DWORD *)v190 + 4) = v124;
                    *((_DWORD *)v190 + 5) = v194;
                    *((_DWORD *)v190 + 6) = v192;
                    v190[30] = v272;
                    v190[31] = v126;
                    *((_WORD *)v190 + 19) = v5[1].i32[1];
                    __int32 v195 = v5[5].i32[0];
                    *((_DWORD *)v190 + 10) = v193;
                    *((_DWORD *)v190 + 11) = v195;
                    v196 = v190 + 48;
                    *(void *)v190 = v190 + 48;
                    if (v192 <= (int)v273)
                    {
                      if ((int)v124 < 1)
                      {
                        v197 = v190 + 48;
                      }

                      else
                      {
                        v198 = (int *)*v5;
                        v197 = v190 + 48;
                        do
                        {
                          int v199 = *v198;
                          v198 += 4;
                          *(_WORD *)v197 = v199;
                          v197 += 2;
                          LODWORD(v124) = v124 - 1;
                        }

                        while ((_DWORD)v124);
                      }
                    }

                    else
                    {
                      memcpy(v190 + 48, *(const void **)&v5[7], v129);
                      v197 = &v196[2 * (int)v124];
                    }

                    v200 = &v196[v129];
                    v201 = (int *)v5[2];
                    if (v126 == 2)
                    {
                      *v191 = v200;
                      if ((int)v194 >= 1)
                      {
                        unsigned int v204 = v194 + 1;
                        do
                        {
                          int v205 = *v201++;
                          *v200++ = v205;
                          --v204;
                        }

                        while (v204 > 1);
                      }
                    }

                    else if (v126 == 1)
                    {
                      *v191 = v200;
                      memcpy(v200, v201, 4 * v194);
                    }

                    else
                    {
                      *v191 = v197;
                      if ((int)v194 >= 1)
                      {
                        unsigned int v202 = v194 + 1;
                        do
                        {
                          int v203 = *v201++;
                          *(_WORD *)v197 = v203;
                          v197 += 2;
                          --v202;
                        }

                        while (v202 > 1);
                      }
                    }
                  }

                  else
                  {
                    int *v123 = 7;
                  }

                  v5[1].i32[1] = -1;
                  *(int8x8_t *)((char *)&v5[3] + 4) = (int8x8_t)0xFFFFFFFF00000000LL;
                  __int32 v206 = v5[4].i32[1];
                  v5[5].i32[0] = v206;
                  v5[6].i32[0] = 0;
                  v5[6].i32[1] = v206;
                  uprv_free(*(void **)&v5[7]);
                  goto LABEL_208;
                }

LABEL_219:
                int8x8_t v133 = v5[2];
                __int32 v134 = v5[3].i32[1];
                int v135 = *(_DWORD *)(*(void *)&v133 + 4LL * (v134 - 1));
                __int32 v136 = v5[5].i32[1];
                if (v135 == v136)
                {
                  __int32 v137 = v5[6].i32[1];
                  if (*(_DWORD *)(*(void *)&v133 + 4LL * (v134 - 2)) == v137)
                  {
LABEL_228:
                    int v130 = 4 * v134;
                    goto LABEL_284;
                  }
                }

                else
                {
                  __int32 v137 = v5[6].i32[1];
                }

                if (v135 != v137)
                {
                  v5[3].i32[1] = v134 + 1;
                  *(_DWORD *)(*(void *)&v133 + 4LL * v134) = v137;
                  __int32 v136 = v5[5].i32[1];
                  __int32 v134 = v5[3].i32[1];
                }

                v5[3].i32[1] = v134 + 1;
                *(_DWORD *)(*(void *)&v133 + 4LL * v134) = v136;
                __int32 v134 = v5[3].i32[1];
                goto LABEL_228;
              }

              __int32 v139 = v5[3].i32[1];
              int8x8_t v140 = v5[2];
              __int32 v141 = v139;
              if (((v139 ^ v124) & 1) != 0)
              {
                __int32 v142 = v5[5].i32[1];
                v5[3].i32[1] = v139 + 1;
                *(_DWORD *)(*(void *)&v140 + 4LL * v139) = v142;
                __int32 v141 = v5[3].i32[1];
              }

              if (*(_DWORD *)(*(void *)&v140 + 4LL * v141 - 4) == v5[5].i32[1])
              {
                __int32 v143 = v5[6].i32[1];
                if (*(_DWORD *)(*(void *)&v140 + 4LL * v141 - 8) == v143) {
                  goto LABEL_238;
                }
              }

              else
              {
                __int32 v143 = v5[6].i32[1];
              }

              v5[3].i32[1] = v141 + 1;
              *(_DWORD *)(*(void *)&v140 + 4LL * v141) = v143;
              __int32 v144 = v5[5].i32[1];
              uint64_t v145 = v5[3].i32[1];
              v5[3].i32[1] = v145 + 1;
              *(_DWORD *)(*(void *)&v140 + 4 * v145) = v144;
              __int32 v141 = v5[3].i32[1];
LABEL_238:
              int v130 = 2 * v141;
              goto LABEL_284;
            }

LABEL_365:
            LODWORD(v124) = 0;
          }

          else
          {
            LODWORD(v124) = 0;
            v123 = v281;
          }

          int *v123 = 7;
          goto LABEL_368;
        }
      }

      if (SLODWORD(v291[0]) >= 1)
      {
        uint64_t v48 = 0LL;
        do
        {
          if (*((_DWORD *)&v291[8] + v48 + 2) == (_DWORD)v37)
          {
            DWORD1(v291[0]) = v48;
            goto LABEL_76;
          }

          ++v48;
        }

        while (LODWORD(v291[0]) != v48);
        if (LODWORD(v291[0]) == 32) {
          goto LABEL_77;
        }
      }

      DWORD1(v291[0]) = v291[0];
      *((_DWORD *)v291 + SLODWORD(v291[0]) + 2) = v31;
      *((_DWORD *)&v291[8] + SLODWORD(v291[0]) + 2) = v37;
      uint64_t v49 = SLODWORD(v291[0]);
      ++LODWORD(v291[0]);
      goto LABEL_92;
    }

uint64_t sub_180857E08(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 48);
  if (v2 <= a2)
  {
    unsigned int v4 = (a2 & 0xFFFFFE00) + 512;
    int v5 = v2 >> 4;
    uint64_t v6 = v4 >> 4;
    if ((int)v6 > *(_DWORD *)(a1 + 8))
    {
      uint64_t result = (uint64_t)uprv_malloc(0x44000uLL);
      if (!result) {
        return result;
      }
      uint64_t v8 = result;
      unint64_t v9 = *(void **)a1;
      memcpy((void *)result, *(const void **)a1, 4 * v5);
      uprv_free(v9);
      *(void *)a1 = v8;
      *(_DWORD *)(a1 + 8) = 69632;
    }

    uint64_t v10 = v5;
    do
    {
      *(_BYTE *)(a1 + v10 + 64) = 0;
      *(_DWORD *)(*(void *)a1 + 4 * v10++) = *(_DWORD *)(a1 + 40);
    }

    while (v10 < v6);
    *(_DWORD *)(a1 + 48) = v4;
  }

  return 1LL;
}

uint64_t sub_180857EC8(void *a1, int a2)
{
  uint64_t v4 = a2;
  int v5 = (char *)a1 + a2;
  int v7 = v5[64];
  uint64_t v6 = v5 + 64;
  if (v7 == 1) {
    return *(unsigned int *)(*a1 + 4LL * a2);
  }
  if (a2 > 4095)
  {
    uint64_t result = sub_180857FE0((uint64_t)a1, 16);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v18 = 0LL;
      uint64_t v19 = a1[2] + 4LL * result;
      uint64_t v20 = (const float *)(*a1 + 4 * v4);
      float32x4_t v21 = vld1q_dup_f32(v20);
      do
      {
        *(float32x4_t *)(v19 + v18) = v21;
        v18 += 16LL;
      }

      while (v18 != 64);
      *uint64_t v6 = 1;
      *(_DWORD *)(*a1 + 4 * v4) = result;
    }
  }

  else
  {
    uint64_t result = sub_180857FE0((uint64_t)a1, 64);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v9 = (int)(a2 & 0xFFFFFFFC);
      uint64_t v10 = *a1;
      uint64_t v11 = 4LL * result;
      uint64_t v12 = result;
      do
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = a1[2];
        uint64_t v15 = (const float *)(v10 + 4 * v9);
        float32x4_t v16 = vld1q_dup_f32(v15);
        do
        {
          *(float32x4_t *)(v14 + v11 + v13) = v16;
          v13 += 16LL;
        }

        while (v13 != 64);
        *((_BYTE *)a1 + v9 + 64) = 1;
        uint64_t v10 = *a1;
        *(_DWORD *)(*a1 + 4 * v9) = v12;
        v12 += 16LL;
        v11 += 64LL;
      }

      while (v9++ < (a2 | 3));
      return *(unsigned int *)(v10 + 4 * v4);
    }
  }

  return result;
}

uint64_t sub_180857FE0(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a1 + 28);
  int v5 = v4 + a2;
  if (v3 >= 0x20000)
  {
    if (HIWORD(v3) > 0x10u) {
      return 0xFFFFFFFFLL;
    }
    int v6 = 1114112;
  }

  else
  {
    int v6 = 0x20000;
  }

  int v7 = uprv_malloc((4 * v6));
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void **)(a1 + 16);
  memcpy(v7, v9, 4LL * *(int *)(a1 + 28));
  uprv_free(v9);
  *(void *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 24) = v6;
LABEL_8:
  *(_DWORD *)(a1 + 28) = v5;
  return v4;
}

uint64_t sub_180858080(uint64_t a1, int a2, int a3)
{
  unsigned int v5 = a2 - a3;
  if (a2 - a3 > 4094)
  {
    if (v5 > 0x7FFE)
    {
      if (v5 > 0x1FFFE)
      {
        *(void *)(a1 + 16) = 0x1FFFFF00000015LL;
        int v6 = 1500007;
      }

      else
      {
        *(void *)(a1 + 16) = 0x1FFFF00000011LL;
        int v6 = 200003;
      }
    }

    else
    {
      *(void *)(a1 + 16) = 0x7FFF0000000FLL;
      int v6 = 50021;
    }
  }

  else
  {
    *(void *)(a1 + 16) = 0xFFF0000000CLL;
    int v6 = 6007;
  }

  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t result = *(void *)a1;
  if (v6 <= v7)
  {
    size_t v9 = (4 * v6);
  }

  else
  {
    uprv_free((void *)result);
    size_t v9 = (4 * v6);
    uint64_t result = (uint64_t)uprv_malloc(v9);
    *(void *)a1 = result;
    if (!result) {
      return result;
    }
    *(_DWORD *)(a1 + 8) = v6;
  }

  *(_DWORD *)(a1 + 12) = v6;
  bzero((void *)result, v9);
  *(_DWORD *)(a1 + 24) = a3;
  return 1LL;
}

uint64_t sub_180858168(uint64_t result, uint64_t a2, int a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  if (a3 >= v4) {
    int v5 = a3 - v4 + 1;
  }
  else {
    int v5 = 0;
  }
  int v6 = a4 - v4;
  if (v5 <= a4 - v4)
  {
    uint64_t v8 = result;
    do
    {
      int v9 = v5;
      uint64_t v10 = *(int *)(v8 + 24) + (uint64_t)v5++;
      unsigned int v11 = *(_DWORD *)(a2 + 4LL * v9);
      uint64_t v12 = v5;
      do
        unsigned int v11 = *(_DWORD *)(a2 + 4 * v12++) + 37 * v11;
      while (v12 < v10);
      uint64_t result = sub_180858228(v8, a2, a2, v9, v11);
      if ((result & 0x80000000) != 0) {
        *(_DWORD *)(*(void *)v8 + 4LL * ~(_DWORD)result) = (v11 << *(_DWORD *)(v8 + 16)) | v5;
      }
    }

    while (v5 <= v6);
  }

  return result;
}

uint64_t sub_180858228(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5 = *(_DWORD *)(a1 + 12);
  signed int v6 = a5 % (v5 - 1) + 1;
  int v7 = *(_DWORD *)(*(void *)a1 + 4LL * v6);
  if (v7)
  {
    int v8 = *(_DWORD *)(a1 + 20);
    int v9 = (_DWORD *)(a3 + 4LL * a4);
    uint64_t v10 = a5 % (v5 - 1) + 1;
    do
    {
      if ((v7 & ~v8) == a5 << *(_DWORD *)(a1 + 16))
      {
        int v11 = *(_DWORD *)(a1 + 24);
        if (v11 < 1)
        {
          if (!v11) {
            return v10;
          }
        }

        else
        {
          uint64_t v12 = (_DWORD *)(a2 + 4LL * ((v8 & v7) - 1));
          int v13 = v11 + 1;
          for (uint64_t i = v9; *v12 == *i; ++i)
          {
            ++v12;
            if (--v13 <= 1) {
              return v10;
            }
          }
        }
      }

      uint64_t v10 = (((int)v10 + v6) % v5);
      int v7 = *(_DWORD *)(*(void *)a1 + 4LL * (int)v10);
    }

    while (v7);
  }

  else
  {
    LODWORD(v10) = a5 % (v5 - 1) + 1;
  }

  return ~(_DWORD)v10;
}

uint64_t sub_1808582DC(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  int v5 = *(_DWORD *)(result + 24);
  if (a4 - v5 >= a3) {
    int v6 = a4 - v5 + 1;
  }
  else {
    int v6 = a3;
  }
  int v7 = a5 - v5;
  if (v6 <= a5 - v5)
  {
    uint64_t v9 = result;
    do
    {
      int v10 = v6;
      uint64_t v11 = *(int *)(v9 + 24) + (uint64_t)v6++;
      unsigned int v12 = *(unsigned __int16 *)(a2 + 2LL * v10);
      uint64_t v13 = v6;
      do
        unsigned int v12 = *(unsigned __int16 *)(a2 + 2 * v13++) + 37 * v12;
      while (v13 < v11);
      uint64_t result = sub_180858514(v9, a2, a2, v10, v12);
      if ((result & 0x80000000) != 0) {
        *(_DWORD *)(*(void *)v9 + 4LL * ~(_DWORD)result) = (v12 << *(_DWORD *)(v9 + 16)) | v6;
      }
    }

    while (v6 <= v7);
  }

  return result;
}

uint64_t sub_1808583A0(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *((_DWORD *)a1 + 6);
  int v5 = (unsigned int *)(a3 + 4LL * a4);
  unsigned int v6 = *v5;
  uint64_t v7 = a4 + 1;
  do
    unsigned int v6 = *(_DWORD *)(a3 + 4 * v7++) + 37 * v6;
  while (v7 < v4 + a4);
  int v8 = *((_DWORD *)a1 + 3);
  signed int v9 = v6 % (v8 - 1) + 1;
  uint64_t v10 = *a1;
  int v11 = *(_DWORD *)(*a1 + 4LL * v9);
  if (v11)
  {
    int v12 = *((_DWORD *)a1 + 5);
    unsigned int v13 = v6 << *((_DWORD *)a1 + 4);
    int v14 = v6 % (v8 - 1) + 1;
    do
    {
      if ((v11 & ~v12) == v13)
      {
        if (v4 < 1)
        {
          if (!v4) {
            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v15 = (unsigned __int16 *)(a2 + 2LL * ((v11 & v12) - 1));
          int v16 = v4 + 1;
          __int32 v17 = v5;
          while (*v17 == *v15)
          {
            ++v15;
            ++v17;
            if (--v16 <= 1) {
              goto LABEL_16;
            }
          }
        }
      }

      int v14 = (v14 + v9) % v8;
      int v11 = *(_DWORD *)(v10 + 4LL * v14);
    }

    while (v11);
  }

  else
  {
    int v14 = v6 % (v8 - 1) + 1;
  }

  int v14 = ~v14;
LABEL_16:
  if (v14 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return ((*((_DWORD *)a1 + 5) & *(_DWORD *)(v10 + 4LL * v14)) - 1);
  }
}

uint64_t sub_1808584A0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v5 = *(unsigned __int16 *)(a3 + 2LL * a4);
  uint64_t v6 = a4 + 1;
  do
    unsigned int v5 = *(unsigned __int16 *)(a3 + 2 * v6++) + 37 * v5;
  while (v6 < *(int *)(a1 + 24) + (uint64_t)a4);
  unsigned int v7 = sub_180858514(a1, a2, a3, a4, v5);
  if ((v7 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return ((*(_DWORD *)(a1 + 20) & *(_DWORD *)(*(void *)a1 + 4LL * v7)) - 1);
  }
}

uint64_t sub_180858514(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5 = *(_DWORD *)(a1 + 12);
  signed int v6 = a5 % (v5 - 1) + 1;
  int v7 = *(_DWORD *)(*(void *)a1 + 4LL * v6);
  if (v7)
  {
    int v8 = *(_DWORD *)(a1 + 20);
    signed int v9 = (unsigned __int16 *)(a3 + 2LL * a4);
    uint64_t v10 = a5 % (v5 - 1) + 1;
    do
    {
      if ((v7 & ~v8) == a5 << *(_DWORD *)(a1 + 16))
      {
        int v11 = *(_DWORD *)(a1 + 24);
        if (v11 < 1)
        {
          if (!v11) {
            return v10;
          }
        }

        else
        {
          int v12 = (unsigned __int16 *)(a2 + 2LL * ((v8 & v7) - 1));
          int v13 = v11 + 1;
          for (uint64_t i = v9; *v12 == *i; ++i)
          {
            ++v12;
            if (--v13 <= 1) {
              return v10;
            }
          }
        }
      }

      uint64_t v10 = (((int)v10 + v6) % v5);
      int v7 = *(_DWORD *)(*(void *)a1 + 4LL * (int)v10);
    }

    while (v7);
  }

  else
  {
    LODWORD(v10) = a5 % (v5 - 1) + 1;
  }

  return ~(_DWORD)v10;
}

unint64_t icu::UMutex::getMutex(icu::UMutex *this)
{
  unint64_t v1 = atomic_load((unint64_t *)this + 8);
  if (!v1)
  {
    unint64_t v3 = atomic_load((unint64_t *)&qword_18C449208);
    if (v3 != -1LL)
    {
      int v7 = &v8;
      int v8 = sub_18085869C;
      std::__call_once((unint64_t *)&qword_18C449208, &v7, (void (__cdecl *)(void *))sub_180858928);
    }

    int v4 = (std::mutex *)qword_18C4491F8;
    std::mutex::lock((std::mutex *)qword_18C4491F8);
    int v5 = (unint64_t *)((char *)this + 64);
    unint64_t v1 = atomic_load((unint64_t *)this + 8);
    if (!v1)
    {
      *(void *)this = 850045863LL;
      *(_OWORD *)((char *)this + 8) = 0u;
      *(_OWORD *)((char *)this + 24) = 0u;
      *(_OWORD *)((char *)this + 40) = 0u;
      *((void *)this + 7) = 0LL;
      atomic_store((unint64_t)this, v5);
      unint64_t v1 = atomic_load(v5);
      *((void *)this + 9) = icu::UMutex::gListHead;
      icu::UMutex::gListHead = (uint64_t)this;
    }

    std::mutex::unlock(v4);
  }

  return v1;
}

void sub_18085869C()
{
  qword_18C449210 = 850045863LL;
  unk_18C449218 = 0u;
  unk_18C449228 = 0u;
  unk_18C449238 = 0u;
  qword_18C4491F8 = (uint64_t)&qword_18C449210;
  qword_18C449248 = 0LL;
  qword_18C449250 = 1018212795LL;
  unk_18C449258 = 0u;
  qword_18C449200 = (uint64_t)&qword_18C449250;
  unk_18C449268 = 0u;
  qword_18C449278 = 0LL;
  sub_180820C94(0x1Du, (uint64_t)sub_1808588F0);
}

void icu::UMutex::cleanup(icu::UMutex *this)
{
  uint64_t v1 = icu::UMutex::gListHead;
  if (icu::UMutex::gListHead)
  {
    do
    {
      int v2 = (std::mutex *)atomic_load((unint64_t *)(v1 + 64));
      std::mutex::~mutex(v2);
      atomic_store(0LL, (unint64_t *)(v1 + 64));
      uint64_t v3 = *(void *)(v1 + 72);
      *(void *)(v1 + 72) = 0LL;
      uint64_t v1 = v3;
    }

    while (v3);
  }

  icu::UMutex::gListHead = 0LL;
}

void umtx_lock(icu::UMutex *a1)
{
  if (!a1) {
    a1 = (icu::UMutex *)&unk_18C449280;
  }
  sub_180858768(a1);
}

void sub_180858768(icu::UMutex *this)
{
  Mutex = (std::mutex *)atomic_load((unint64_t *)this + 8);
  if (!Mutex) {
    Mutex = (std::mutex *)icu::UMutex::getMutex(this);
  }
  std::mutex::lock(Mutex);
}

void umtx_unlock(std::mutex **a1)
{
  uint64_t v1 = (std::mutex **)&unk_18C449280;
  if (a1) {
    uint64_t v1 = a1;
  }
  std::mutex::unlock(v1[8]);
}

uint64_t icu::umtx_initImplPreInit(unsigned int *a1)
{
  unint64_t v2 = atomic_load((unint64_t *)&qword_18C449208);
  if (v2 != -1LL)
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_18085869C;
    p_lsize_t k = &__lk;
    std::__call_once((unint64_t *)&qword_18C449208, &p_lk, (void (__cdecl *)(void *))sub_180858928);
  }

  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)qword_18C4491F8;
  uint64_t v3 = 1LL;
  *(void *)&__lk.__owns_ = 1LL;
  std::mutex::lock((std::mutex *)qword_18C4491F8);
  if (atomic_load(a1))
  {
    unsigned int v5 = atomic_load(a1);
    if (v5 == 1)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)qword_18C449200, &__lk);
        unsigned int v6 = atomic_load(a1);
      }

      while (v6 == 1);
    }

    uint64_t v3 = 0LL;
  }

  else
  {
    atomic_store(1u, a1);
  }

  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  return v3;
}

void icu::umtx_initImplPostInit(unsigned int *a1)
{
  unint64_t v2 = (std::mutex *)qword_18C4491F8;
  std::mutex::lock((std::mutex *)qword_18C4491F8);
  atomic_store(2u, a1);
  std::mutex::unlock(v2);
  std::condition_variable::notify_all((std::condition_variable *)qword_18C449200);
}

void u_setMutexFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*a6 <= 0) {
    *a6 = 16;
  }
}

void u_setAtomicIncDecFunctions(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0) {
    *a4 = 16;
  }
}

uint64_t sub_1808588F0()
{
  qword_18C449208 = 0LL;
  return 1LL;
}

uint64_t sub_180858928(uint64_t (***a1)(void))
{
  return (**a1)();
}

int32_t u_charName( UChar32 code, UCharNameChoice nameChoice, char *buffer, int32_t bufferLength, UErrorCode *pErrorCode)
{
  if ((int)nameChoice > (int)U_CHAR_NAME_ALIAS || bufferLength < 0 || !buffer && bufferLength)
  {
    *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }

  if (HIWORD(code) <= 0x10u && sub_180858A9C(pErrorCode))
  {
    int v11 = (int *)(qword_18C535058 + *(unsigned int *)(qword_18C535058 + 12));
    int v12 = *v11;
    if (*v11)
    {
      uint64_t v13 = (uint64_t)(v11 + 1);
      while (*(_DWORD *)v13 > code || *(_DWORD *)(v13 + 4) < code)
      {
        v13 += *(unsigned __int16 *)(v13 + 10);
        if (!--v12) {
          goto LABEL_16;
        }
      }

      uint64_t v15 = sub_180858B80(v13, code, nameChoice, buffer, (unsigned __int16)bufferLength);
    }

    else
    {
LABEL_16:
      if (nameChoice == U_EXTENDED_CHAR_NAME)
      {
        uint64_t v14 = sub_180858D14((unsigned int *)qword_18C535058, code, 2, buffer, (unsigned __int16)bufferLength);
        if ((_DWORD)v14)
        {
LABEL_23:
          int v16 = buffer;
          int32_t v17 = bufferLength;
          return u_terminateChars((uint64_t)v16, v17, v14, (int *)pErrorCode);
        }

        uint64_t v15 = sub_180858E50(code, buffer, (unsigned __int16)bufferLength);
      }

      else
      {
        uint64_t v15 = sub_180858D14((unsigned int *)qword_18C535058, code, nameChoice, buffer, (unsigned __int16)bufferLength);
      }
    }

    uint64_t v14 = v15;
    goto LABEL_23;
  }

  int v16 = buffer;
  int32_t v17 = bufferLength;
  uint64_t v14 = 0LL;
  return u_terminateChars((uint64_t)v16, v17, v14, (int *)pErrorCode);
}

BOOL sub_180858A9C(UErrorCode *a1)
{
  if (*(int *)a1 <= 0)
  {
    unsigned int v2 = atomic_load(&dword_18C535084);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_18C535084))
    {
      if (dword_18C535088 >= 1) {
        *a1 = dword_18C535088;
      }
    }

    else
    {
      uint64_t v3 = udata_openChoice( 0LL,  "icu",  "unames",  (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18085AD24,  0LL,  a1);
      qword_18C535090 = (uint64_t)v3;
      else {
        qword_18C535090 = 0LL;
      }
      sub_180820C94(0x13u, (uint64_t)sub_18085AD88);
      dword_18C535088 = *a1;
      icu::umtx_initImplPostInit(&dword_18C535084);
    }
  }

  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t sub_180858B80(uint64_t a1, unsigned int a2, int a3, _BYTE *a4, int a5)
{
  unsigned int v5 = a4;
  v24[2] = *MEMORY[0x1895F89C0];
  if ((a3 & 0xFFFFFFFD) != 0)
  {
LABEL_2:
    unsigned __int16 v6 = 0;
    if (a5) {
      *a4 = 0;
    }
    return v6;
  }

  if (*(_BYTE *)(a1 + 8) == 1)
  {
    v24[0] = 0LL;
    v24[1] = 0LL;
    uint64_t v11 = *(unsigned __int8 *)(a1 + 9);
    int v12 = (unsigned __int8 *)(a1 + 12 + 2 * v11);
    int v15 = *v12;
    uint64_t v13 = v12 + 1;
    char v14 = v15;
    if (v15)
    {
      __int16 v16 = 0;
      do
      {
        if ((_WORD)a5)
        {
          *v5++ = v14;
          LOWORD(a5) = a5 - 1;
        }

        else
        {
          LOWORD(a5) = 0;
        }

        ++v16;
        int v17 = *v13++;
        char v14 = v17;
      }

      while (v17);
    }

    else
    {
      __int16 v16 = 0;
    }

    return (unsigned __int16)(sub_18085ADDC(a1 + 12, v11, v13, a2 - *(_DWORD *)a1, v24, 0LL, 0LL, v5, a5) + v16);
  }

  else
  {
    if (*(_BYTE *)(a1 + 8)) {
      goto LABEL_2;
    }
    char v7 = *(_BYTE *)(a1 + 12);
    if (v7)
    {
      __int16 v8 = 0;
      signed int v9 = (unsigned __int8 *)(a1 + 13);
      do
      {
        if ((_WORD)a5)
        {
          *v5++ = v7;
          LOWORD(a5) = a5 - 1;
        }

        else
        {
          LOWORD(a5) = 0;
        }

        ++v8;
        int v10 = *v9++;
        char v7 = v10;
      }

      while (v10);
    }

    else
    {
      __int16 v8 = 0;
    }

    uint64_t v18 = *(unsigned __int8 *)(a1 + 9);
    if ((_DWORD)v18)
    {
      uint64_t v19 = &v5[(unsigned __int16)(v18 - 1)];
      unsigned __int16 v20 = v18 - 1;
      do
      {
        if ((unsigned __int16)a5 > v20)
        {
          if ((a2 & 0xF) >= 0xA) {
            char v21 = (a2 & 0xF) + 55;
          }
          else {
            char v21 = a2 & 0xF | 0x30;
          }
          *uint64_t v19 = v21;
        }

        a2 >>= 4;
        --v19;
      }

      while (v20--);
    }

    return (unsigned __int16)(v8 + v18);
  }

uint64_t sub_180858D14(unsigned int *a1, unsigned int a2, int a3, char *a4, int a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v10 = sub_18085AED0((uint64_t)a1, a2);
  if (*v10 == (unsigned __int16)(a2 >> 5))
  {
    int v16 = 0;
    memset(v15, 0, sizeof(v15));
    int v14 = 0;
    memset(v13, 0, sizeof(v13));
    uint64_t v11 = sub_18085AC78((unsigned __int8 *)a1 + a1[2] + ((v10[1] << 16) | (unint64_t)v10[2]), v15, v13);
    return sub_18085AF3C( a1,  &v11[*((unsigned __int16 *)v15 + (a2 & 0x1F))],  *((unsigned __int16 *)v13 + (a2 & 0x1F)),  a3,  a4,  a5);
  }

  else
  {
    if (a5) {
      *a4 = 0;
    }
    return 0LL;
  }

uint64_t sub_180858E50(unsigned int a1, char *a2, int a3)
{
  int v5 = a1;
  unsigned int v6 = sub_180859574(a1);
  if (v6 <= 0x20)
  {
    char v7 = off_18971B188[v6];
    if (a3) {
      goto LABEL_3;
    }
  }

  else
  {
    char v7 = "unknown";
    if (a3)
    {
LABEL_3:
      *a2++ = 60;
      __int16 v8 = a3 - 1;
      goto LABEL_6;
    }
  }

  __int16 v8 = 0;
LABEL_6:
  char v9 = *v7;
  if (*v7)
  {
    __int16 v10 = 1;
    do
    {
      __int16 v11 = v10;
      if (v8)
      {
        *a2++ = v9;
        --v8;
      }

      else
      {
        __int16 v8 = 0;
      }

      ++v10;
      char v9 = v7[(unsigned __int16)(v11 + 1) - 1];
    }

    while (v9);
    __int16 v12 = v11 + 3;
  }

  else
  {
    __int16 v12 = 3;
  }

  if (v8)
  {
    *a2++ = 45;
    __int16 v13 = v8 - 1;
  }

  else
  {
    __int16 v13 = 0;
  }

  int v14 = 0;
  if (v5)
  {
    int v15 = v5;
    do
    {
      ++v14;
      BOOL v16 = v15 > 0xF;
      v15 >>= 4;
    }

    while (v16);
  }

  if ((v14 > 0 || v5 != 0) && v13 != 0)
  {
    uint64_t v19 = v14;
    do
    {
      if ((v5 & 0xFu) >= 0xA) {
        char v20 = (v5 & 0xF) + 55;
      }
      else {
        char v20 = v5 & 0xF | 0x30;
      }
      a2[v19 - 1] = v20;
      --v13;
      --v19;
      v5 >>= 4;
    }

    while (v13);
  }

  if (v13) {
    a2[v14] = 62;
  }
  return (unsigned __int16)(v12 + v14);
}

int32_t u_getISOComment(UChar32 c, char *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  if (destCapacity < 0 || !dest && destCapacity)
  {
    *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }

  return u_terminateChars((uint64_t)dest, destCapacity, 0LL, (int *)pErrorCode);
}

UChar32 u_charFromName(UCharNameChoice nameChoice, const char *name, UErrorCode *pErrorCode)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  uint64_t v65 = 0LL;
  memset(v64, 0, sizeof(v64));
  uint64_t v63 = 0LL;
  memset(v62, 0, sizeof(v62));
  uint64_t v4 = *(void *)&nameChoice;
  UErrorCode v5 = U_ILLEGAL_ARGUMENT_ERROR;
  unsigned int v6 = name;
  if (!name || !*name) {
    goto LABEL_75;
  }
  if (!sub_180858A9C(pErrorCode)) {
    return 0xFFFF;
  }
  uint64_t v7 = 0LL;
  unsigned int v8 = -1;
  while (1)
  {
    char v9 = *v6;
    if (!*v6) {
      break;
    }
    ++v6;
    int v10 = v9;
    *((_BYTE *)v64 + v7) = uprv_toupper(v9);
    *((_BYTE *)v62 + v7++) = uprv_asciitolower(v10);
    ++v8;
    if (v7 == 120) {
      goto LABEL_74;
    }
  }

  *((_BYTE *)v62 + v7) = 0;
  uint64_t v60 = 0LL;
  uint64_t v61 = 0LL;
  *((_BYTE *)v64 + v7) = 0;
  if (LOBYTE(v62[0]) == 60)
  {
    if ((_DWORD)v4 == 2)
    {
      unsigned int v11 = v7 - 1;
      if (*((_BYTE *)v62 + (v7 - 1)) == 62)
      {
        if (v11 < 3)
        {
          if ((_DWORD)v7 != 3) {
            goto LABEL_74;
          }
          unsigned int v16 = 2;
        }

        else
        {
          uint64_t v12 = -1LL;
          do
          {
            unint64_t v13 = v8 + v12;
            int v14 = *((unsigned __int8 *)v62 + v8 + v12--);
          }

          while (v14 != 45 && v13 > 2);
          unsigned int v16 = v7 + v12;
        }

        if (*((_BYTE *)v62 + v16) == 45 && v7 - v16 - 3 <= 7)
        {
          int v32 = 0;
          *((_BYTE *)v62 + v16) = 0;
          unsigned int v52 = v16 + 1;
          unsigned int v53 = v11 <= v16 + 1 ? v16 + 1 : v7 - 1;
          while (v52 < v11)
          {
            int v54 = *((char *)v62 + v52);
            if ((v54 - 48) >= 0xA)
            {
              int v55 = -87;
            }

            else
            {
              int v55 = -48;
            }

            int v32 = v55 + 16 * v32 + v54;
            ++v52;
            UErrorCode v5 = U_ILLEGAL_CHAR_FOUND;
            if (v32 >= 1114112) {
              goto LABEL_75;
            }
          }

          int v56 = sub_180859574(v32);
          uint64_t v57 = 0LL;
          *((_BYTE *)v62 + v53) = 0;
          while (strcmp((const char *)v62 + 1, off_18971B188[v57]))
          {
            ++v57;
            UErrorCode v5 = U_ILLEGAL_CHAR_FOUND;
            if (v57 == 33) {
              goto LABEL_75;
            }
          }

          if ((_DWORD)(v57 * 8) == 8 * v56) {
            return v32;
          }
        }
      }
    }

uint64_t sub_180859574(unsigned int c)
{
  if ((int)c >= 64976 && (c >> 4 < 0xFDF || HIWORD(c) <= 0x10u && (c & 0xFFFE) == 0xFFFE))
  {
    return 30;
  }

  else
  {
    int v3 = u_charType(c);
    if (c >> 10 == 54) {
      unsigned __int8 v2 = 31;
    }
    else {
      unsigned __int8 v2 = 32;
    }
    if (v3 != 18) {
      return v3;
    }
  }

  return v2;
}

uint64_t sub_1808595F0( uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a5, uint64_t a6)
{
  uint64_t v12 = sub_18085AED0(a1, a2);
  unint64_t v13 = v12;
  unsigned int v14 = (unsigned __int16)(a2 >> 5);
  uint64_t v15 = a2;
  if ((_DWORD)a6 == 2)
  {
    unsigned int v16 = *v12;
    uint64_t v15 = a2;
    if (v14 < v16)
    {
      int v17 = 32 * v16;
      uint64_t v15 = v17 >= a3 ? a3 : v17;
      uint64_t result = sub_18085B0B0(a2, (int)v15 - 1, a4, a5);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  unsigned int v19 = a3 - 1;
  unsigned int v20 = (a3 - 1) >> 5;
  if (v14 == (unsigned __int16)v20)
  {
    if (*v13 == (unsigned __int16)(a2 >> 5))
    {
      int v21 = (unsigned __int8 *)a1;
      uint64_t v22 = (uint64_t)v13;
      uint64_t v23 = v15;
      return sub_18085B190( v21,  v22,  v23,  a3 - 1,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4,  a5,  a6);
    }

    if ((_DWORD)a6 != 2) {
      return 1LL;
    }
LABEL_43:
    if (a3 >= 1114112) {
      int v35 = 1114112;
    }
    else {
      int v35 = a3;
    }
    return sub_18085B0B0(v15, v35 - 1, a4, a5);
  }

  unint64_t v24 = a1 + *(unsigned int *)(a1 + 4) + 6LL * *(unsigned __int16 *)(a1 + *(unsigned int *)(a1 + 4)) + 2;
  unsigned int v25 = *v13;
  if (v14 == v25)
  {
    if ((v15 & 0x1F) != 0)
    {
      uint64_t result = sub_18085B190( (unsigned __int8 *)a1,  (uint64_t)v13,  v15,  (32 * v14) | 0x1F,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4,  a5,  a6);
      if (!(_DWORD)result) {
        return result;
      }
      v13 += 3;
      unsigned int v20 = (a3 - 1) >> 5;
    }
  }

  else if (v14 > v25)
  {
    v13 += 3;
    if ((unint64_t)v13 < v24 && (_DWORD)a6 == 2)
    {
      unsigned int v26 = *v13;
      if (v14 < v26)
      {
        int v27 = 32 * v26;
        if (v27 >= a3) {
          int v27 = a3;
        }
        uint64_t result = sub_18085B0B0(v15, v27 - 1, a4, a5);
        unsigned int v20 = v19 >> 5;
        if (!(_DWORD)result) {
          return result;
        }
      }
    }
  }

  if ((unint64_t)v13 >= v24)
  {
LABEL_38:
    uint64_t result = 1LL;
    int v34 = 32 * *(unsigned __int16 *)(v24 - 6) + 32;
    else {
      uint64_t v15 = v34;
    }
    goto LABEL_43;
  }

  unsigned int v28 = (unsigned __int16)(v19 >> 5);
  unsigned int v29 = *v13;
  if (v28 <= v29)
  {
LABEL_35:
    if (v29 == (unsigned __int16)v20)
    {
      uint64_t v23 = v19 & 0xFFFFFFE0;
      int v21 = (unsigned __int8 *)a1;
      uint64_t v22 = (uint64_t)v13;
      return sub_18085B190( v21,  v22,  v23,  a3 - 1,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4,  a5,  a6);
    }

    goto LABEL_38;
  }

  __int16 v36 = v20;
  v13 += 3;
  while (1)
  {
    LODWORD(v15) = 32 * v29;
    uint64_t result = sub_18085B190( (unsigned __int8 *)a1,  (uint64_t)(v13 - 3),  32 * v29,  (32 * v29) | 0x1F,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4,  a5,  a6);
    if (!(_DWORD)result) {
      return result;
    }
    if ((_DWORD)a6 == 2)
    {
      unsigned int v30 = *v13;
      int v31 = *(v13 - 3);
      if (v31 + 1 < v30)
      {
        int v32 = 32 * v30;
        if (v32 >= a3) {
          int v32 = a3;
        }
        uint64_t result = sub_18085B0B0((32 * v31 + 32), v32 - 1, a4, a5);
        if (!(_DWORD)result) {
          return result;
        }
      }
    }

    unsigned int v33 = *v13;
    v13 += 3;
    unsigned int v29 = v33;
    if (v28 <= v33)
    {
      v13 -= 3;
      LOWORD(v20) = v36;
      goto LABEL_35;
    }
  }

void u_enumCharNames( UChar32 start, UChar32 limit, UEnumCharNamesFn *fn, void *context, UCharNameChoice nameChoice, UErrorCode *pErrorCode)
{
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (fn && (uint64_t v7 = *(void *)&nameChoice, (int)nameChoice < (int)U_CHAR_NAME_CHOICE_COUNT))
    {
      uint64_t v8 = *(void *)&start;
      else {
        unsigned int v9 = limit;
      }
      if (v9 > start && sub_180858A9C(pErrorCode))
      {
        uint64_t v11 = qword_18C535058;
        uint64_t v12 = (_DWORD *)(qword_18C535058 + *(unsigned int *)(qword_18C535058 + 12));
        int v13 = *v12;
        if (!*v12)
        {
LABEL_22:
          sub_1808595F0( v11,  v8,  v9,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn,  (uint64_t)context,  v7);
          return;
        }

        unsigned int v14 = v12 + 1;
        while (1)
        {
          unsigned int v15 = *v14;
          if (v8 < *v14)
          {
            uint64_t v11 = qword_18C535058;
            if (v9 <= v15) {
              goto LABEL_22;
            }
            if (!sub_1808595F0( qword_18C535058,  v8,  v15,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn,  (uint64_t)context,  v7)) {
              return;
            }
            uint64_t v8 = *v14;
          }

          unsigned int v16 = v14[1];
          if (v8 <= v16)
          {
            if (v9 <= v16 + 1)
            {
              sub_180859A5C( (uint64_t)v14,  v8,  v9,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn,  (uint64_t)context,  v7);
              return;
            }

            if (!sub_180859A5C( (uint64_t)v14,  v8,  v16 + 1,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn,  (uint64_t)context,  v7)) {
              return;
            }
            uint64_t v8 = v14[1] + 1;
          }

          unsigned int v14 = (unsigned int *)((char *)v14 + *((unsigned __int16 *)v14 + 5));
          if (!--v13)
          {
            uint64_t v11 = qword_18C535058;
            goto LABEL_22;
          }
        }
      }
    }

    else
    {
      *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

uint64_t sub_180859A5C( uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a5, uint64_t a6)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if ((a6 & 0xFFFFFFFD) != 0) {
    return 1LL;
  }
  uint64_t v11 = a2;
  uint64_t v56 = 0LL;
  memset(v55, 0, sizeof(v55));
  if (*(_BYTE *)(a1 + 8) == 1)
  {
    uint64_t v53 = 0LL;
    uint64_t v54 = 0LL;
    memset(v52, 0, sizeof(v52));
    memset(v51, 0, sizeof(v51));
    uint64_t v25 = a1 + 12;
    uint64_t v26 = *(unsigned __int8 *)(a1 + 9);
    int v27 = (unsigned __int8 *)(a1 + 12 + 2 * v26);
    int v30 = *v27;
    unsigned int v28 = v27 + 1;
    char v29 = v30;
    if (v30)
    {
      unsigned __int16 v31 = 0;
      int v32 = v55;
      do
      {
        *v32++ = v29;
        ++v31;
        int v33 = *v28++;
        char v29 = v33;
      }

      while (v33);
    }

    else
    {
      unsigned __int16 v31 = 0;
      int v32 = v55;
    }

    __int16 v34 = sub_18085ADDC(a1 + 12, v26, v28, (int)a2 - *(_DWORD *)a1, &v53, v52, v51, v32, 200 - v31);
    uint64_t v35 = (unsigned __int16)(v26 - 1);
    while (1)
    {
      uint64_t v11 = (v11 + 1);
      unsigned __int16 v36 = *((_WORD *)&v53 + v35) + 1;
      uint64_t v37 = (unsigned __int16)(v26 - 1);
      int v38 = v26 - 1;
      if (*(unsigned __int16 *)(v25 + 2 * v35) <= v36)
      {
        do
        {
          *((_WORD *)&v53 + v37) = 0;
          *((void *)v51 + v37) = *((void *)v52 + v37);
          uint64_t v37 = (unsigned __int16)--v38;
          unsigned __int16 v36 = *((_WORD *)&v53 + (unsigned __int16)v38) + 1;
        }

        while (*(unsigned __int16 *)(v25 + 2LL * (unsigned __int16)v38) <= v36);
      }

      *((_WORD *)&v53 + v37) = v36;
      unsigned __int16 v39 = (unsigned __int8 *)*((void *)v51 + v37);
      while (*v39++)
        ;
      *((void *)v51 + v37) = v39;
      unsigned __int16 v41 = v31;
      int v42 = v32;
      if ((_DWORD)v26)
      {
        uint64_t v43 = 0LL;
        int v42 = v32;
        unsigned __int16 v41 = v31;
        do
        {
          UErrorCode v44 = (_BYTE *)*((void *)v51 + v43);
          char v45 = *v44;
          if (*v44)
          {
            int v46 = v44 + 1;
            do
            {
              *v42++ = v45;
              ++v41;
              int v47 = *v46++;
              char v45 = v47;
            }

            while (v47);
          }

          ++v43;
        }

        while (v43 != v26);
      }

      _BYTE *v42 = 0;
    }

    return 1LL;
  }

  if (*(_BYTE *)(a1 + 8)) {
    return 1LL;
  }
  uint64_t v12 = sub_180858B80(a1, a2, a6, v55, 200);
  if (!(_DWORD)v12) {
    return 1LL;
  }
  uint64_t v13 = v12;
  uint64_t result = a4(a5, v11, a6, v55, v12);
  if ((_DWORD)result)
  {
    unsigned int v14 = (char *)&v54 + 5;
    do
    {
      int v15 = v14[3];
      ++v14;
    }

    while (v15);
    while (1)
    {
      uint64_t v11 = (v11 + 1);
      int v16 = v14[1];
      BOOL v17 = (v16 - 48) >= 9 && (v16 - 65) >= 5;
      uint64_t v18 = v14 + 1;
      unsigned int v19 = (unsigned __int8 *)v14;
      if (v17)
      {
        do
        {
          if (v16 == 70)
          {
            v19[1] = 48;
          }

          else if (v16 == 57)
          {
            uint64_t v18 = (char *)(v19 + 1);
            char v24 = 65;
            goto LABEL_26;
          }

          int v20 = *v19--;
          int v16 = v20;
          unsigned int v21 = v20 - 65;
        }

        while ((v20 - 48) >= 9 && v21 >= 5);
        uint64_t v18 = (char *)(v19 + 1);
      }

      char v24 = v16 + 1;
LABEL_26:
      *uint64_t v18 = v24;
      unsigned int v23 = a4(a5, v11, a6, v55, v13);
      uint64_t result = 0LL;
      if (!v23) {
        return result;
      }
    }
  }

  return result;
}

uint64_t uprv_getMaxCharNameLength()
{
  int v1 = 0;
  if (sub_180859DCC((UErrorCode *)&v1)) {
    return dword_18C535060;
  }
  else {
    return 0LL;
  }
}

BOOL sub_180859DCC(UErrorCode *a1)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (!dword_18C535060)
  {
    BOOL result = sub_180858A9C(a1);
    if (!result) {
      return result;
    }
    for (uint64_t i = 0LL; i != 19; ++i)
      *(_DWORD *)((char *)dword_18C535064 + (((unint64_t)a0123456789abcd[i] >> 3) & 0x1C)) |= 1 << a0123456789abcd[i];
    int v3 = (unsigned int *)qword_18C535058;
    uint64_t v4 = (int *)(qword_18C535058 + *(unsigned int *)(qword_18C535058 + 12));
    int v5 = *v4;
    if (*v4)
    {
      int v6 = 0;
      uint64_t v7 = v4 + 1;
      while (*((_BYTE *)v7 + 8) != 1)
      {
        if (!*((_BYTE *)v7 + 8))
        {
          unsigned int v8 = *((unsigned __int8 *)v7 + 12);
          if (*((_BYTE *)v7 + 12))
          {
            uint64_t v9 = 0LL;
            do
            {
              dword_18C535064[v8 >> 5] |= 1 << v8;
              unsigned int v8 = *((unsigned __int8 *)v7 + v9++ + 13);
            }

            while (v8);
          }

          else
          {
            LODWORD(v9) = 0;
          }

          int v15 = v9 + *((unsigned __int8 *)v7 + 9);
          if (v15 > v6) {
            int v6 = v15;
          }
        }

void uprv_getCharNameCharacters(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  memset(us, 0, sizeof(us));
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  *(_OWORD *)unsigned int v8 = 0u;
  __int128 v9 = 0u;
  int v7 = 0;
  if (sub_180859DCC((UErrorCode *)&v7))
  {
    LODWORD(v2) = 0;
    for (unsigned int i = 0; i != 256; ++i)
    {
      if (((dword_18C535064[i >> 5] >> i) & 1) != 0)
      {
        v8[(int)v2] = i;
        LODWORD(v2) = v2 + 1;
      }
    }

    u_charsToUChars(v8, (UChar *)us, v2);
    if ((int)v2 >= 1)
    {
      uint64_t v2 = v2;
      uint64_t v4 = v8;
      int v5 = (unsigned __int16 *)us;
      do
      {
        int v6 = *v5++;
        if (v6 || !*v4) {
          (*(void (**)(void))(a1 + 8))(*(void *)a1);
        }
        ++v4;
        --v2;
      }

      while (v2);
    }
  }

uint64_t uchar_swapNames( uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3;
  v121[64] = *MEMORY[0x1895F89C0];
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0LL;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x6E00000075LL
    || *(_BYTE *)(a2 + 14) != 97
    || *(_BYTE *)(a2 + 15) != 109
    || *(_BYTE *)(a2 + 16) != 1)
  {
    udata_printError( a1,  (uint64_t)"uchar_swapNames(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as unames.icu\n",  v14,  v15,  v16,  v17,  v18,  v19,  v21);
    uint64_t result = 0LL;
    int v27 = 16;
    goto LABEL_16;
  }

  int v22 = v13;
  __int128 v23 = (unsigned int *)(a2 + v13);
  if (a4) {
    char v24 = (unsigned int *)((char *)a4 + v13);
  }
  else {
    char v24 = 0LL;
  }
  if (v10 < 0)
  {
    unsigned int v28 = (*(uint64_t (**)(void))(a1 + 16))(v23[3]);
    int v29 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)((char *)v23 + v28));
    unsigned int v30 = v28 + 4;
    if (v29)
    {
      int v31 = v29;
      do
      {
        v30 += (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)((char *)v23 + v30 + 10));
        --v31;
      }

      while (v31);
    }

    return v30 + v22;
  }

  size_t v25 = (v10 - v13);
  if ((int)v25 < 20 || (unsigned int v26 = (*(uint64_t (**)(void))(a1 + 16))(v23[3]), v25 < v26))
  {
    udata_printError( a1,  (uint64_t)"uchar_swapNames(): too few bytes (%d after header) for unames.icu\n",  v14,  v15,  v16,  v17,  v18,  v19,  v25);
    uint64_t result = 0LL;
    int v27 = 8;
LABEL_16:
    *a5 = v27;
    return result;
  }

  unsigned int v103 = v26;
  bzero(v120, 0x400uLL);
  memset(v119, 0, sizeof(v119));
  memset(v118, 0, sizeof(v118));
  if (v23 != v24) {
    memcpy(v24, v23, v25);
  }
  uint64_t v110 = v25;
  unsigned int v105 = (*(uint64_t (**)(void))(a1 + 16))(*v23);
  unsigned int v107 = (*(uint64_t (**)(void))(a1 + 16))(v23[1]);
  unsigned int v102 = (*(uint64_t (**)(void))(a1 + 16))(v23[2]);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, v23, 16LL, v24, a5);
  BOOL v111 = (char *)v24;
  unint64_t v109 = v23;
  unsigned int v33 = *((unsigned __int16 *)v23 + 8);
  int v32 = v23 + 4;
  uint64_t v34 = (*(uint64_t (**)(void))(a1 + 8))(v33);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 48))( a1,  v32,  2LL,  (char *)v24 + 16,  a5);
  uint64_t v35 = (unsigned __int16 *)v32 + 1;
  else {
    uint64_t v36 = v34;
  }
  if (!(_DWORD)v36) {
    goto LABEL_30;
  }
  uint64_t v37 = v120;
  uint64_t v38 = v36;
  unsigned __int16 v39 = v35;
  do
  {
    unsigned __int16 v40 = *v39++;
    *v37++ = udata_readInt16(a1, v40);
    --v38;
  }

  while (v38);
  if (v36 <= 0x1FF) {
LABEL_30:
  }
    bzero((char *)v120 + (2 * v36), ((2 * (_DWORD)v36) ^ 0x3FEu) + 2);
  sub_18085AAA4(a1, (uint64_t)v120, v34, v119, a5);
  else {
    unsigned int v41 = 0;
  }
  sub_18085AAA4(a1, (uint64_t)v121, v41, v118, a5);
  if (*a5 > 0) {
    return 0LL;
  }
  int v42 = uprv_malloc((2 * v34));
  if (!v42)
  {
    udata_printError(a1, (uint64_t)"out of memory swapping %u unames.icu tokens\n", v43, v44, v45, v46, v47, v48, v34);
    int v63 = 7;
    goto LABEL_48;
  }

  BOOL v49 = v42;
  else {
    uint64_t v50 = v34;
  }
  if ((_DWORD)v50)
  {
    int v51 = (unsigned __int8 *)v119;
    uint64_t v52 = v50;
    do
    {
      unsigned int v53 = *v51++;
      (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, uint64_t, int *))(a1 + 48))( a1,  v35++,  2LL,  (uint64_t)v49 + 2 * v53,  a5);
      --v52;
    }

    while (v52);
  }

  if (v34 >= 0x101)
  {
    uint64_t v54 = v22 + 2LL * v50 + a2 + 18;
    do
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(a1 + 48))( a1,  v54,  2LL,  (uint64_t)v49 + 2 * (v50 & 0x7FFFFF00) + 2 * *((unsigned __int8 *)v118 + v50),  a5);
      ++v50;
      v54 += 2LL;
    }

    while (v34 != v50);
  }

  memcpy(v111 + 18, v49, (2 * v34));
  uprv_free(v49);
  int v55 = v109;
  uint64_t v56 = v111;
  udata_swapInvStringBlock(a1, (uint64_t)v109 + v105, v107 - v105, (uint64_t)&v111[v105], a5);
  if (*a5 >= 1)
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(token strings) failed\n", v57, v58, v59, v60, v61, v62, v101);
    return 0LL;
  }

  int v64 = (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)((char *)v109 + v107));
  (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 48))( a1,  (char *)v109 + v107,  (6 * v64 + 2),  &v111[v107],  a5);
  if (*(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 3))
  {
    __int16 v117 = 0;
    __int128 v116 = 0u;
    memset(v115, 0, sizeof(v115));
    __int16 v114 = 0;
    __int128 v113 = 0u;
    unsigned int v65 = v103 - v102;
    memset(v112, 0, sizeof(v112));
    if (v103 - v102 >= 0x21)
    {
      uint64_t v66 = (unsigned __int8 *)&v111[v102];
      unsigned int v67 = (unsigned __int8 *)v109 + v102;
      do
      {
        int v68 = v67;
        unsigned int v67 = sub_18085AC78(v67, v115, v112);
        int v69 = (_DWORD)v67 - (_DWORD)v68;
        v66 += v67 - v68;
        int v70 = HIWORD(v113) + HIWORD(v116);
        if (v70)
        {
          int v71 = HIWORD(v113) + HIWORD(v116);
          do
          {
            uint64_t v72 = *v67;
            unsigned __int8 *v66 = *((_BYTE *)v119 + v72);
            int v73 = v120[v72];
            if (v73 == -2)
            {
              unsigned __int8 v74 = *((_BYTE *)v118 + v67[1]);
              v67 += 2;
              v66[1] = v74;
              v66 += 2;
            }

            else
            {
              int v73 = -1;
              ++v67;
              ++v66;
            }

            v71 += v73;
          }

          while (v71);
        }

        unsigned int v65 = v65 - v69 - v70;
      }

      while (v65 >= 0x21);
    }

    int v55 = v109;
    uint64_t v56 = v111;
  }

  int v75 = (unsigned int *)((char *)v55 + v103);
  int v76 = (*(uint64_t (**)(void))(a1 + 16))(*v75);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, v75, 4LL, &v56[v103], a5);
  unsigned int v83 = v103 + 4;
  int v106 = v76;
  if (!v76)
  {
    unsigned int v30 = v103 + 4;
    return v30 + v22;
  }

  uint64_t v84 = 0LL;
  uint64_t v104 = v22 + a2 + 11;
  while (1)
  {
    if (v83 > v110)
    {
      udata_printError( a1,  (uint64_t)"uchar_swapNames(): too few bytes (%d after header) for unames.icu algorithmic range %u\n",  v77,  v78,  v79,  v80,  v81,  v82,  v110);
      int v63 = 8;
      goto LABEL_48;
    }

    uint64_t v85 = (uint64_t)v55 + v83;
    int8x8_t v86 = &v56[v83];
    int v108 = (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)(v85 + 10));
    unsigned int v30 = v83 + v108;
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, v85, 8LL, v86, a5);
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v85 + 10, 2LL, v86 + 10, a5);
    if (*(_BYTE *)(v85 + 8) == 1)
    {
      uint64_t v94 = v83;
      uint64_t v95 = *(unsigned __int8 *)(v85 + 9);
      uint64_t v96 = v85 + 12;
      (*(void (**)(uint64_t, uint64_t, void, char *, int *))(a1 + 48))( a1,  v96,  (2 * v95),  v86 + 12,  a5);
      uint64_t v97 = v55 + v30 - ((_DWORD)v96 + 2 * (_DWORD)v95);
      int v98 = v108 - 2 * v95 - 11;
      int v99 = (unsigned __int8 *)(v104 + v94 + 2 * v95 + v97);
      uint64_t v56 = v111;
      do
      {
        if (!v97) {
          break;
        }
        --v97;
        int v100 = *v99--;
        --v98;
      }

      while (v100);
      (*(void (**)(uint64_t))(a1 + 72))(a1);
      goto LABEL_71;
    }

    if (*(_BYTE *)(v85 + 8)) {
      break;
    }
    size_t v93 = strlen((const char *)(v85 + 12));
    (*(void (**)(uint64_t, uint64_t, size_t, char *, int *))(a1 + 72))(a1, v85 + 12, v93, v86 + 12, a5);
    int v55 = v109;
    uint64_t v56 = v111;
    if (*a5 >= 1)
    {
      udata_printError( a1,  (uint64_t)"uchar_swapNames(prefix string of algorithmic range %u) failed\n",  v77,  v78,  v79,  v80,  v81,  v82,  v84);
      return 0LL;
    }

uint64_t sub_18085AAA4(uint64_t result, uint64_t a2, unsigned int a3, _OWORD *a4, int *a5)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (*a5 <= 0)
  {
    uint64_t v6 = result;
    if (*(unsigned __int8 *)(result + 1) == *(unsigned __int8 *)(result + 3))
    {
      uint64_t v7 = 0LL;
      int8x16_t v8 = (int8x16_t)xmmword_180A270F0;
      v9.i64[0] = 0x1010101010101010LL;
      v9.i64[1] = 0x1010101010101010LL;
      do
      {
        a4[v7++] = v8;
        int8x16_t v8 = vaddq_s8(v8, v9);
      }

      while (v7 != 16);
    }

    else
    {
      a4[14] = 0u;
      a4[15] = 0u;
      if (a3 >= 0x100) {
        uint64_t v10 = 256LL;
      }
      else {
        uint64_t v10 = a3;
      }
      a4[12] = 0uLL;
      a4[13] = 0uLL;
      a4[10] = 0uLL;
      a4[11] = 0uLL;
      a4[8] = 0uLL;
      a4[9] = 0uLL;
      a4[6] = 0uLL;
      a4[7] = 0uLL;
      a4[4] = 0uLL;
      a4[5] = 0uLL;
      a4[2] = 0uLL;
      a4[3] = 0uLL;
      *a4 = 0uLL;
      a4[1] = 0uLL;
      memset(v27, 0, sizeof(v27));
      if (v10 >= 2)
      {
        unsigned __int8 v25 = 0;
        for (uint64_t i = 1LL; i != v10; ++i)
        {
          if (*(__int16 *)(a2 + 2 * i) == -1)
          {
            unsigned __int8 v26 = i;
            uint64_t result = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, unsigned __int8 *, int *))(v6 + 72))( v6,  &v26,  1LL,  &v25,  a5);
            if (*a5 >= 1) {
              return udata_printError( v6,  (uint64_t)"unames/makeTokenMap() finds variant character 0x%02x used (input charset family %d)\n",  v14,  v15,  v16,  v17,  v18,  v19,  i);
            }
            uint64_t v20 = v25;
            *((_BYTE *)a4 + v26) = v25;
            *((_BYTE *)v27 + v20) = 1;
          }
        }

        uint64_t v21 = 1LL;
        int v22 = 1;
        do
        {
          if (!*((_BYTE *)a4 + v21))
          {
            do
              char v23 = v22;
            while (*((unsigned __int8 *)v27 + (unsigned __int16)v22++));
            *((_BYTE *)a4 + v21) = v23;
          }

          ++v21;
        }

        while (v21 != v10);
      }
    }
  }

  return result;
}

unsigned __int8 *sub_18085AC78(unsigned __int8 *result, _WORD *a2, _WORD *a3)
{
  LOWORD(v3) = 0;
  int v4 = 0;
  unsigned int v5 = 0;
  do
  {
    unsigned int v7 = *result++;
    unsigned int v6 = v7;
    if ((unsigned __int16)v3 < 0xCu)
    {
      if (v6 > 0xBF)
      {
        LOWORD(v3) = 0;
        int v9 = (v6 & 0x3F) + 12;
        *a2++ = v4;
        *a3++ = v9;
        v4 += v9;
        ++v5;
        continue;
      }

      unsigned int v8 = v6 >> 4;
    }

    else
    {
      unsigned int v8 = ((v6 >> 4) & 0xFFFFFFCF | (16 * (v3 & 3))) + 12;
    }

    *a2 = v4;
    unsigned int v3 = v6 & 0xF;
    *a3 = v8;
    v4 += v8;
    if (v3 > 0xB)
    {
      ++v5;
      ++a2;
      ++a3;
    }

    else
    {
      a2[1] = v4;
      a2 += 2;
      a3[1] = v3;
      a3 += 2;
      v4 += v3;
      v5 += 2;
    }
  }

  while (v5 < 0x20);
  return result;
}

BOOL sub_18085AD24(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 117
      && a4[9] == 110
      && a4[10] == 97
      && a4[11] == 109
      && a4[12] == 1;
}

uint64_t sub_18085AD88()
{
  if (qword_18C535090)
  {
    udata_close((_OWORD *)qword_18C535090);
    qword_18C535090 = 0LL;
  }

  if (qword_18C535058) {
    qword_18C535058 = 0LL;
  }
  atomic_store(0, &dword_18C535084);
  dword_18C535060 = 0;
  return 1LL;
}

uint64_t sub_18085ADDC( uint64_t a1, __int16 a2, unsigned __int8 *a3, unsigned int a4, _WORD *a5, void *a6, void *a7, _BYTE *a8, __int16 a9)
{
  if (a2 == 1)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = (unsigned __int16)(a2 - 1);
    uint64_t v11 = v10;
    do
    {
      __int16 v12 = a4;
      a4 /= *(unsigned __int16 *)(a1 + 2 * v11);
      a5[v11] = v12 - a4 * *(_WORD *)(a1 + 2 * v11);
      --v11;
    }

    while ((_WORD)v11);
  }

  uint64_t v13 = 0LL;
  unsigned __int16 v14 = 0;
  *a5 = a4;
  if (a6)
  {
LABEL_7:
    *a6++ = a3;
    goto LABEL_8;
  }

  while (1)
  {
LABEL_8:
    int v15 = (unsigned __int16)a5[v13];
    if (a5[v13])
    {
      do
      {
        while (*a3++)
          ;
        --v15;
      }

      while ((_WORD)v15);
    }

    if (a7) {
      *a7++ = a3;
    }
    while (1)
    {
      int v18 = *a3++;
      char v17 = v18;
      if (!v18) {
        break;
      }
      if (a9)
      {
        *a8++ = v17;
        --a9;
      }

      else
      {
        a9 = 0;
      }

      ++v14;
    }

    if (v13 == v10) {
      break;
    }
    for (__int16 i = *(_WORD *)(a1 + 2 * v13) + ~a5[v13]; i; --i)
    {
      while (*a3++)
        ;
    }

    ++v13;
    if (a6) {
      goto LABEL_7;
    }
  }

  if (a9) {
    *a8 = 0;
  }
  return v14;
}

unsigned __int16 *sub_18085AED0(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (unsigned __int16 *)(a1 + *(unsigned int *)(a1 + 4));
  unsigned int v5 = *v2;
  unsigned int v3 = v2 + 1;
  unsigned int v4 = v5;
  if (v5 < 2)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    int v6 = 0;
    unsigned __int16 v7 = 0;
    unsigned __int16 v8 = v4;
    do
    {
      unsigned int v9 = (v4 + v6) >> 1;
      else {
        unsigned __int16 v7 = v9;
      }
      int v6 = v7;
      unsigned int v4 = v8;
    }

    while (v8 - 1 > v7);
    uint64_t v10 = 3 * v7;
  }

  return &v3[v10];
}

uint64_t sub_18085AF3C(unsigned int *a1, unsigned __int8 *a2, int a3, int a4, char *a5, int a6)
{
  unsigned int v6 = *((unsigned __int16 *)a1 + 8);
  uint64_t v7 = *a1;
  unsigned __int16 v8 = (char *)a1 + v7;
  if ((a4 & 0xFFFFFFFD) != 0)
  {
    if (v6 < 0x3C || *((__int16 *)a1 + 68) == -1)
    {
      int v9 = a4;
      do
      {
        if ((_WORD)a3)
        {
          do
          {
            --a3;
            int v10 = *a2++;
          }

          while (v10 != 59 && (unsigned __int16)a3 != 0);
        }

        else
        {
          a3 = 0;
        }

        BOOL v12 = __OFSUB__(v9--, 1);
      }

      while (!((v9 < 0) ^ v12 | (v9 == 0)));
    }

    else
    {
      a3 = 0;
    }
  }

  int v13 = 0;
  unsigned __int16 v14 = (char *)a1 + 18;
  uint64_t v15 = (uint64_t)a1 + v7 + 1;
LABEL_17:
  int v16 = a3;
  char v17 = a2;
  while ((_WORD)v16)
  {
    a3 = v16 - 1;
    a2 = v17 + 1;
    uint64_t v18 = *v17;
    if (v6 <= v18)
    {
      if ((_DWORD)v18 == 59) {
        break;
      }
LABEL_29:
      if ((_WORD)a6)
      {
        *a5++ = v18;
        --a6;
      }

      else
      {
        a6 = 0;
      }

      ++v13;
      goto LABEL_17;
    }

    unsigned int v19 = *(unsigned __int16 *)&v14[2 * v18];
    if (v19 == 65534)
    {
      a2 = v17 + 2;
      unsigned int v19 = *(unsigned __int16 *)&v14[(2LL * v17[1]) | (v18 << 9)];
      a3 = v16 - 2;
    }

    if (v19 != 0xFFFF)
    {
      char v20 = v8[v19];
      if (v20)
      {
        uint64_t v21 = (unsigned __int8 *)(v15 + v19);
        do
        {
          if ((_WORD)a6)
          {
            *a5++ = v20;
            --a6;
          }

          else
          {
            a6 = 0;
          }

          ++v13;
          int v22 = *v21++;
          char v20 = v22;
        }

        while (v22);
      }

      goto LABEL_17;
    }

    if ((_DWORD)v18 != 59) {
      goto LABEL_29;
    }
    if (a4 == 2 && !(_WORD)v13)
    {
      int v13 = 0;
      int v16 = a3;
      char v17 = a2;
    }

    break;
  }

  if ((_WORD)a6) {
    *a5 = 0;
  }
  return (unsigned __int16)v13;
}

uint64_t sub_18085B0B0( uint64_t a1, int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!a3) {
    return 1LL;
  }
  uint64_t v4 = a1;
  uint64_t v11 = 0LL;
  memset(v10, 0, sizeof(v10));
  int v7 = a2 + 1;
  while (1)
  {
    uint64_t v8 = sub_180858E50(v4, (char *)v10, 200);
    *((_BYTE *)v10 + v8) = 0;
    if ((_DWORD)v8)
    {
      uint64_t result = a3(a4, v4, 2LL, v10, v8);
      if (!(_DWORD)result) {
        break;
      }
    }

    uint64_t v4 = (v4 + 1);
    if (v7 == (_DWORD)v4) {
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_18085B190( unsigned __int8 *a1, uint64_t a2, uint64_t a3, int a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, _OWORD *), uint64_t a6, uint64_t a7)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  int v42 = 0;
  memset(v41, 0, sizeof(v41));
  int v40 = 0;
  memset(v39, 0, sizeof(v39));
  int v13 = sub_18085AC78( &a1[*((unsigned int *)a1 + 2)
            + ((*(unsigned __int16 *)(a2 + 2) << 16) | (unint64_t)*(unsigned __int16 *)(a2 + 4))],
          v41,
          v39);
  if (a5)
  {
    uint64_t v38 = 0LL;
    memset(v37, 0, sizeof(v37));
    if ((int)a3 <= a4)
    {
      int v14 = a4 + 1;
      while (1)
      {
        unsigned int v15 = sub_18085AF3C( (unsigned int *)a1,  &v13[*((unsigned __int16 *)v41 + (a3 & 0x1F))],  *((unsigned __int16 *)v39 + (a3 & 0x1F)),  a7,  (char *)v37,  200);
        unsigned int v16 = v15;
        if ((_DWORD)a7 == 2 && !v15)
        {
          unsigned int v16 = sub_180858E50(a3, (char *)v37, 200);
          *((_BYTE *)v37 + v16) = 0;
        }

        if (v16)
        {
          uint64_t result = a5(a6, a3, a7, v37);
          if (!(_DWORD)result) {
            break;
          }
        }

        a3 = (a3 + 1);
        if (v14 == (_DWORD)a3) {
          return 1LL;
        }
      }

      return result;
    }

    return 1LL;
  }

  uint64_t v18 = (char *)(a1 + 18);
  unsigned int v19 = *((unsigned __int16 *)a1 + 8);
LABEL_13:
  char v20 = &v13[*((unsigned __int16 *)v41 + (a3 & 0x1F))];
  int v21 = *((unsigned __int16 *)v39 + (a3 & 0x1F));
  if ((a7 & 0xFFFFFFFD) != 0)
  {
    if (v19 < 0x3C || *((__int16 *)a1 + 68) == -1)
    {
      int v22 = a7;
      do
      {
        if ((_WORD)v21)
        {
          do
          {
            --v21;
            int v23 = *v20++;
            BOOL v24 = v23 == 59 || (unsigned __int16)v21 == 0;
          }

          while (!v24);
        }

        else
        {
          int v21 = 0;
        }

        BOOL v25 = __OFSUB__(v22--, 1);
      }

      while (!((v22 < 0) ^ v25 | (v22 == 0)));
    }

    else
    {
      int v21 = 0;
    }
  }

  unsigned __int8 v26 = *(_BYTE **)a6;
LABEL_29:
  BOOL v28 = (_DWORD)a7 == 2 && v26 == *(_BYTE **)a6;
  int v29 = v20;
  int v30 = v21;
  while ((_WORD)v30)
  {
    int v21 = v30 - 1;
    char v20 = v29 + 1;
    uint64_t v31 = *v29;
    if (v19 <= v31)
    {
      if ((_DWORD)v31 == 59) {
        break;
      }
LABEL_46:
      int v33 = *v26++;
      if ((_DWORD)v31 == v33) {
        goto LABEL_29;
      }
LABEL_53:
      BOOL v24 = (_DWORD)a3 == a4;
      LODWORD(a3) = a3 + 1;
      if (v24) {
        return 1LL;
      }
      goto LABEL_13;
    }

    int v32 = *(unsigned __int16 *)&v18[2 * v31];
    if (v32 == 65534)
    {
      char v20 = v29 + 2;
      int v32 = *(unsigned __int16 *)&v18[(2LL * v29[1]) | (v31 << 9)];
      int v21 = v30 - 2;
    }

    if (v32 != 0xFFFF)
    {
      uint64_t v34 = &a1[*(unsigned int *)a1 + v32];
      while (1)
      {
        int v35 = *v34;
        if (!*v34) {
          goto LABEL_29;
        }
        ++v34;
        int v36 = *v26++;
        if (v35 != v36) {
          goto LABEL_53;
        }
      }
    }

    if ((_DWORD)v31 != 59) {
      goto LABEL_46;
    }
    if (!v28) {
      break;
    }
    int v29 = v20;
    int v30 = v21;
    if (*((__int16 *)a1 + 68) != -1)
    {
      unsigned __int8 v26 = *(_BYTE **)a6;
      break;
    }
  }

  if (*v26) {
    goto LABEL_53;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a6 + 8) = a3;
  return result;
}

uint64_t sub_18085B490( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned __int8 **a5, unsigned __int8 *a6)
{
  unsigned int v6 = *a5;
  if (*a5 != a6)
  {
    uint64_t result = 0LL;
    uint64_t v9 = a3 + 1;
    int v10 = *a5;
    while (1)
    {
      unsigned int v12 = *v10++;
      unint64_t v11 = v12;
      if (v12 == 59)
      {
        a6 = v10;
        goto LABEL_29;
      }

      if (v11 >= a2)
      {
        *(_DWORD *)((char *)dword_18C535064 + ((v11 >> 3) & 0x1C)) |= 1 << v11;
      }

      else
      {
        unsigned int v13 = *(unsigned __int16 *)(a1 + 2LL * v11);
        if (v13 == 65534)
        {
          int v10 = v6 + 2;
          LODWORD(v11) = v6[1] | ((_DWORD)v11 << 8);
          unsigned int v13 = *(unsigned __int16 *)(a1 + 2LL * v11);
        }

        if (v13 != 0xFFFF)
        {
          if (a4)
          {
            LODWORD(v14) = *(char *)(a4 + v11);
            if (!*(_BYTE *)(a4 + v11))
            {
              unsigned int v15 = *(unsigned __int8 *)(a3 + v13);
              if (*(_BYTE *)(a3 + v13))
              {
                uint64_t v14 = 0LL;
                uint64_t v16 = v9 + v13;
                do
                {
                  dword_18C535064[v15 >> 5] |= 1 << v15;
                  unsigned int v15 = *(unsigned __int8 *)(v16 + v14++);
                }

                while (v15);
              }

              else
              {
                LODWORD(v14) = 0;
              }

              *(_BYTE *)(a4 + v11) = v14;
            }
          }

          else
          {
            unsigned int v17 = *(unsigned __int8 *)(a3 + v13);
            if (*(_BYTE *)(a3 + v13))
            {
              uint64_t v14 = 0LL;
              uint64_t v18 = v9 + v13;
              do
              {
                dword_18C535064[v17 >> 5] |= 1 << v17;
                unsigned int v17 = *(unsigned __int8 *)(v18 + v14++);
              }

              while (v17);
            }

            else
            {
              LODWORD(v14) = 0;
            }
          }

          uint64_t result = (v14 + result);
          goto LABEL_25;
        }

        dword_18C535064[v11 >> 5] |= 1 << v11;
      }

      uint64_t result = (result + 1);
LABEL_25:
      unsigned int v6 = v10;
      if (v10 == a6) {
        goto LABEL_29;
      }
    }
  }

  uint64_t result = 0LL;
LABEL_29:
  *a5 = a6;
  return result;
}

uint64_t sub_18085B5F0(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
}

uint64_t sub_18085B5FC(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
}

uint64_t sub_18085B618(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t icu::UnifiedCache::getInstance(UErrorCode *this, UErrorCode *a2)
{
  unsigned int v3 = atomic_load(&dword_18C4492E8);
  if (v3 != 2 && icu::umtx_initImplPreInit(&dword_18C4492E8))
  {
    sub_180820C94(0x1Bu, (uint64_t)sub_18085C2EC);
    qword_18C4492F0 = 850045863LL;
    unk_18C4492F8 = 0u;
    unk_18C449308 = 0u;
    unk_18C449318 = 0u;
    qword_18C449328 = 0LL;
    qword_18C4492D8 = (uint64_t)&qword_18C4492F0;
    qword_18C449330 = 1018212795LL;
    unk_18C449338 = 0u;
    unk_18C449348 = 0u;
    qword_18C449358 = 0LL;
    qword_18C4492E0 = (uint64_t)&qword_18C449330;
    unsigned int v5 = (icu::UnifiedCache *)icu::UMemory::operator new(&qword_18C449330, (icu::UMemory *)0x38, v4);
    if (v5)
    {
      unsigned int v6 = icu::UnifiedCache::UnifiedCache(v5, this);
      qword_18C4492D0 = (uint64_t)v6;
      UErrorCode v7 = *this;
      if (*(int *)this < 1)
      {
LABEL_11:
        dword_18C4492EC = v7;
        icu::umtx_initImplPostInit(&dword_18C4492E8);
        goto LABEL_12;
      }

      (*(void (**)(icu::UnifiedCache *))(*(void *)v6 + 8LL))(v6);
      UErrorCode v7 = *this;
    }

    else
    {
      UErrorCode v7 = U_MEMORY_ALLOCATION_ERROR;
      *this = U_MEMORY_ALLOCATION_ERROR;
    }

    qword_18C4492D0 = 0LL;
    goto LABEL_11;
  }

  if (dword_18C4492EC >= 1) {
    *this = dword_18C4492EC;
  }
LABEL_12:
  else {
    return qword_18C4492D0;
  }
}

icu::UnifiedCache *icu::UnifiedCache::UnifiedCache(icu::UnifiedCache *this, UErrorCode *a2)
{
  *(void *)this = off_18971B2A0;
  *((void *)this + 1) = 0LL;
  *((_OWORD *)this + 1) = xmmword_180A27110;
  *((_DWORD *)this + 8) = 100;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  unsigned int v3 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v3 <= 0)
  {
    unsigned int v6 = icu::UMemory::operator new(v3, (icu::UMemory *)0x18, (unint64_t)a2);
    if (v6)
    {
      v6[1] = 0LL;
      v6[2] = 0LL;
      *unsigned int v6 = (uint64_t)&unk_189710360;
      *((void *)this + 6) = v6;
      *((_DWORD *)v6 + 2) = 1;
      atomic_store(1u, (unsigned int *)v6 + 3);
      *(void *)(*((void *)this + 6) + 16LL) = this;
      UErrorCode v7 = uhash_open((uint64_t)sub_18085B5F0, (uint64_t)sub_18085B5FC, 0LL, (int *)a2);
      *((void *)this + 1) = v7;
    }

    else
    {
      *((void *)this + 6) = 0LL;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

void icu::UnifiedCache::setEvictionPolicy(icu::UnifiedCache *this, int a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    if ((a3 | a2) < 0)
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      UErrorCode v7 = (std::mutex *)qword_18C4492D8;
      std::mutex::lock((std::mutex *)qword_18C4492D8);
      *((_DWORD *)this + 7) = a2;
      *((_DWORD *)this + 8) = a3;
      std::mutex::unlock(v7);
    }
  }

uint64_t icu::UnifiedCache::unusedCount(icu::UnifiedCache *this)
{
  uint64_t v2 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  uint64_t v3 = uhash_count(*((void *)this + 1)) - *((_DWORD *)this + 6);
  std::mutex::unlock(v2);
  return v3;
}

uint64_t icu::UnifiedCache::autoEvictedCount(icu::UnifiedCache *this)
{
  uint64_t v2 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  uint64_t v3 = *((void *)this + 5);
  std::mutex::unlock(v2);
  return v3;
}

uint64_t icu::UnifiedCache::keyCount(icu::UnifiedCache *this)
{
  uint64_t v2 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  uint64_t v3 = uhash_count(*((void *)this + 1));
  std::mutex::unlock(v2);
  return v3;
}

void icu::UnifiedCache::flush(icu::UnifiedCache *this)
{
  uint64_t v2 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  std::mutex::unlock(v2);
}

uint64_t icu::UnifiedCache::_flush(icu::UnifiedCache *this, int a2)
{
  int v4 = uhash_count(*((void *)this + 1));
  if (v4 < 1)
  {
    return 0;
  }

  else
  {
    int v5 = v4;
    char v6 = 0;
    do
    {
      uint64_t Element = icu::UnifiedCache::_nextElement(this);
      if (!Element) {
        break;
      }
      uint64_t v8 = Element;
      if (a2 || icu::UnifiedCache::_isEvictable((uint64_t)this, Element))
      {
        uint64_t v9 = *(const icu::SharedObject **)(v8 + 8);
        uhash_removeElement(*((void *)this + 1), (_DWORD *)v8);
        icu::UnifiedCache::removeSoftRef((uint64_t)this, v9);
        char v6 = 1;
      }

      --v5;
    }

    while (v5);
  }

  return v6;
}

void icu::UnifiedCache::handleUnreferencedObject(icu::UnifiedCache *this)
{
  uint64_t v2 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  --*((_DWORD *)this + 6);
  icu::UnifiedCache::_runEvictionSlice(this);
  std::mutex::unlock(v2);
}

uint64_t icu::UnifiedCache::_runEvictionSlice(icu::UnifiedCache *this)
{
  uint64_t result = uhash_count(*((void *)this + 1));
  int v3 = *((_DWORD *)this + 6);
  unint64_t v4 = 1374389535LL * *((_DWORD *)this + 8) * v3;
  int v5 = (v4 >> 63) + (SHIDWORD(v4) >> 5);
  if (v5 <= *((_DWORD *)this + 7)) {
    int v5 = *((_DWORD *)this + 7);
  }
  int v6 = result - v3 - v5;
  if (v6 >= 1)
  {
    int v7 = 10;
    do
    {
      uint64_t result = icu::UnifiedCache::_nextElement(this);
      if (!result) {
        break;
      }
      uint64_t v8 = result;
      uint64_t result = icu::UnifiedCache::_isEvictable((uint64_t)this, result);
      if ((_DWORD)result)
      {
        uint64_t v9 = *(const icu::SharedObject **)(v8 + 8);
        uhash_removeElement(*((void *)this + 1), (_DWORD *)v8);
        uint64_t result = icu::UnifiedCache::removeSoftRef((uint64_t)this, v9);
        ++*((void *)this + 5);
        if (!--v6) {
          break;
        }
      }

      --v7;
    }

    while (v7);
  }

  return result;
}

void icu::UnifiedCache::~UnifiedCache(icu::UnifiedCache *this)
{
  *(void *)this = off_18971B2A0;
  icu::UnifiedCache::flush(this);
  uint64_t v2 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  icu::UnifiedCache::_flush(this, 1);
  std::mutex::unlock(v2);
  uhash_close(*((_BYTE **)this + 1));
  *((void *)this + 1) = 0LL;
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  *((void *)this + 6) = 0LL;
  icu::UnifiedCacheBase::~UnifiedCacheBase(this);
}

{
  void *v1;
  icu::UnifiedCache::~UnifiedCache(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnifiedCache::_nextElement(icu::UnifiedCache *this)
{
  uint64_t result = uhash_nextElement(*((uint64_t **)this + 1), (int *)this + 4);
  if (!result)
  {
    *((_DWORD *)this + 4) = -1;
    return uhash_nextElement(*((uint64_t **)this + 1), (int *)this + 4);
  }

  return result;
}

BOOL icu::UnifiedCache::_isEvictable(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(icu::SharedObject **)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  int v5 = *(icu::SharedObject **)(a1 + 48);
  if (*(_DWORD *)(v4 + 8)) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = v5 == v3;
  }
  if (v6) {
    return 0LL;
  }
  if (*(_BYTE *)(v4 + 12))
  {
    if (*((_DWORD *)v3 + 2) == 1) {
      return icu::SharedObject::getRefCount(v3) == 0;
    }
    return 0LL;
  }

  return 1LL;
}

uint64_t icu::UnifiedCache::removeSoftRef(uint64_t this, const icu::SharedObject *a2)
{
  int v2 = *((_DWORD *)a2 + 2) - 1;
  *((_DWORD *)a2 + 2) = v2;
  if (!v2)
  {
    --*(_DWORD *)(this + 20);
    this = icu::SharedObject::getRefCount(a2);
    if ((_DWORD)this) {
      *((void *)a2 + 2) = 0LL;
    }
    else {
      return (*(uint64_t (**)(const icu::SharedObject *))(*(void *)a2 + 8LL))(a2);
    }
  }

  return this;
}

uint64_t icu::UnifiedCache::_computeCountOfItemsToEvict(icu::UnifiedCache *this)
{
  int v2 = uhash_count(*((void *)this + 1));
  int v3 = *((_DWORD *)this + 6);
  unint64_t v4 = 1374389535LL * *((_DWORD *)this + 8) * v3;
  int v5 = (v4 >> 63) + (SHIDWORD(v4) >> 5);
  if (v5 <= *((_DWORD *)this + 7)) {
    int v5 = *((_DWORD *)this + 7);
  }
  return (v2 - v3 - v5) & ~((v2 - v3 - v5) >> 31);
}

uint64_t icu::UnifiedCache::_putNew( uint64_t this, const icu::CacheKeyBase *a2, const icu::SharedObject *a3, UErrorCode a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = this;
    this = (*(uint64_t (**)(const icu::CacheKeyBase *))(*(void *)a2 + 32LL))(a2);
    if (this)
    {
      *(_DWORD *)(this + 8) = a4;
      if (!*((_DWORD *)a3 + 2))
      {
        *(_BYTE *)(this + 12) = 1;
        *((void *)a3 + 2) = v8;
        *(int32x2_t *)(v8 + 20) = vadd_s32(*(int32x2_t *)(v8 + 20), (int32x2_t)0x100000001LL);
      }

      this = uhash_put(*(void *)(v8 + 8), this, (uint64_t)a3, (int *)a5);
    }

    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

int32x2_t icu::UnifiedCache::_registerPrimary( icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject *a3)
{
  *((_BYTE *)a2 + 12) = 1;
  *((void *)a3 + 2) = this;
  int32x2_t result = vadd_s32(*(int32x2_t *)((char *)this + 20), (int32x2_t)0x100000001LL);
  *(int32x2_t *)((char *)this + 20) = result;
  return result;
}

void icu::UnifiedCache::_putIfAbsentAndGet( icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, UErrorCode *a4)
{
  uint64_t v8 = (std::mutex *)qword_18C4492D8;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  uint64_t v9 = uhash_find(*((void *)this + 1), (uint64_t)a2);
  if (v9)
  {
    uint64_t v10 = (uint64_t)v9;
    if (!icu::UnifiedCache::_inProgress((uint64_t)this, (uint64_t)v9))
    {
      icu::UnifiedCache::_fetch((uint64_t)this, v10, a3, a4);
      goto LABEL_7;
    }

    icu::UnifiedCache::_put((uint64_t)this, v10, (uint64_t)*a3, *a4);
  }

  else
  {
    UErrorCode v11 = U_ZERO_ERROR;
    icu::UnifiedCache::_putNew((uint64_t)this, a2, *a3, *a4, &v11);
  }

  icu::UnifiedCache::_runEvictionSlice(this);
LABEL_7:
  std::mutex::unlock(v8);
}

BOOL icu::UnifiedCache::_inProgress(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  int v3 = *(_DWORD *)(*(void *)(a2 + 16) + 8LL);
  if (v2)
  {
    unint64_t v4 = (unsigned int *)(v2 + 12);
    do
      unsigned int v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
    if (!v5) {
      ++*(_DWORD *)(a1 + 24);
    }
    if (v3) {
      BOOL v6 = 0;
    }
    else {
      BOOL v6 = *(void *)(a1 + 48) == v2;
    }
    uint64_t v7 = v6;
    do
    {
      unsigned int v8 = __ldaxr(v4);
      unsigned int v9 = v8 - 1;
    }

    while (__stlxr(v9, v4));
    if (!v9) {
      --*(_DWORD *)(a1 + 24);
    }
  }

  else
  {
    return !v3 && *(void *)(a1 + 48) == 0LL;
  }

  return v7;
}

uint64_t icu::UnifiedCache::_fetch(uint64_t result, uint64_t a2, void *a3, _DWORD *a4)
{
  *a4 = *(_DWORD *)(*(void *)(a2 + 16) + 8LL);
  if (*a3)
  {
    unint64_t v4 = (unsigned int *)(*a3 + 12LL);
    do
    {
      unsigned int v5 = __ldaxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stlxr(v6, v4));
    if (!v6) {
      --*(_DWORD *)(result + 24);
    }
  }

  uint64_t v7 = *(void *)(a2 + 8);
  *a3 = v7;
  if (v7)
  {
    unsigned int v8 = (unsigned int *)(v7 + 12);
    do
      unsigned int v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    if (!v9) {
      ++*(_DWORD *)(result + 24);
    }
  }

  return result;
}

void icu::UnifiedCache::_put(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = a2 + 8;
  unsigned int v5 = *(const icu::SharedObject **)(a2 + 8);
  uint64_t v6 = *(void *)(v7 + 8);
  *(_DWORD *)(v6 + 8) = a4;
  int v8 = *(_DWORD *)(a3 + 8);
  if (!v8)
  {
    *(_BYTE *)(v6 + 12) = 1;
    *(void *)(a3 + 16) = a1;
    *(int32x2_t *)(a1 + 20) = vadd_s32(*(int32x2_t *)(a1 + 20), (int32x2_t)0x100000001LL);
  }

  *(_DWORD *)(a3 + 8) = v8 + 1;
  *(void *)(a2 + 8) = a3;
  icu::UnifiedCache::removeSoftRef(a1, v5);
  std::condition_variable::notify_all((std::condition_variable *)qword_18C4492E0);
}

uint64_t icu::UnifiedCache::_poll( icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, UErrorCode *a4)
{
  v12.__m_ = (std::unique_lock<std::mutex>::mutex_type *)qword_18C4492D8;
  *(void *)&v12.__owns_ = 1LL;
  std::mutex::lock((std::mutex *)qword_18C4492D8);
  int v8 = uhash_find(*((void *)this + 1), (uint64_t)a2);
  if (v8)
  {
    unsigned int v9 = v8;
    while (icu::UnifiedCache::_inProgress((uint64_t)this, (uint64_t)v9))
    {
      std::condition_variable::wait((std::condition_variable *)qword_18C4492E0, &v12);
      unsigned int v9 = uhash_find(*((void *)this + 1), (uint64_t)a2);
      if (!v9) {
        goto LABEL_5;
      }
    }

    icu::UnifiedCache::_fetch((uint64_t)this, (uint64_t)v9, a3, a4);
    uint64_t v10 = 1LL;
  }

  else
  {
LABEL_5:
    icu::UnifiedCache::_putNew((uint64_t)this, a2, *((const icu::SharedObject **)this + 6), U_ZERO_ERROR, a4);
    uint64_t v10 = 0LL;
  }

  if (v12.__owns_) {
    std::mutex::unlock(v12.__m_);
  }
  return v10;
}

const icu::SharedObject *icu::UnifiedCache::_get( icu::SharedObject **this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, const void *a4, UErrorCode *a5)
{
  int32x2_t result = (const icu::SharedObject *)icu::UnifiedCache::_poll((icu::UnifiedCache *)this, a2, a3, a5);
  if ((_DWORD)result)
  {
    int32x2_t result = *a3;
    if (*a3) {
      BOOL v11 = result == this[6];
    }
    else {
      BOOL v11 = 0;
    }
    if (!v11) {
      return result;
    }
LABEL_7:
    int32x2_t result = (const icu::SharedObject *)icu::SharedObject::removeRef(result);
    *a3 = 0LL;
    return result;
  }

  if (*(int *)a5 <= 0)
  {
    std::unique_lock<std::mutex> v12 = (const icu::SharedObject *)(*(uint64_t (**)(const icu::CacheKeyBase *, const void *, UErrorCode *))(*(void *)a2 + 40LL))( a2,  a4,  a5);
    *a3 = v12;
    if (!v12) {
      sub_18085C214(this[6], a3);
    }
    icu::UnifiedCache::_putIfAbsentAndGet((icu::UnifiedCache *)this, a2, a3, a5);
    int32x2_t result = *a3;
    if (*a3)
    {
      if (result == this[6]) {
        goto LABEL_7;
      }
    }
  }

  return result;
}

icu::SharedObject *sub_18085C214(icu::SharedObject *this, icu::SharedObject **a2)
{
  int32x2_t result = *a2;
  if (*a2 != this)
  {
    if (result) {
      int32x2_t result = (icu::SharedObject *)icu::SharedObject::removeRef(result);
    }
    *a2 = this;
    if (this) {
      return (icu::SharedObject *)icu::SharedObject::addRef((uint64_t)this);
    }
  }

  return result;
}

uint64_t icu::UnifiedCache::removeHardRef(icu::UnifiedCache *this, const icu::SharedObject *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = (unsigned int *)((char *)a2 + 12);
  do
  {
    unsigned int v3 = __ldaxr(v2);
    uint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!(_DWORD)v4)
  {
    uint64_t v4 = 0LL;
    --*((_DWORD *)this + 6);
  }

  return v4;
}

uint64_t icu::UnifiedCache::addHardRef(icu::UnifiedCache *this, const icu::SharedObject *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = (unsigned int *)((char *)a2 + 12);
  do
  {
    unsigned int v3 = __ldaxr(v2);
    uint64_t v4 = v3 + 1;
  }

  while (__stlxr(v4, v2));
  if (!v3)
  {
    ++*((_DWORD *)this + 6);
    return 1LL;
  }

  return v4;
}

BOOL icu::UnifiedCache::_inProgress(icu::UnifiedCache *this, const icu::SharedObject *a2, UErrorCode a3)
{
  return a3 == U_ZERO_ERROR && *((void *)this + 6) == (void)a2;
}

uint64_t sub_18085C2EC()
{
  if (qword_18C4492D0) {
    (*(void (**)(uint64_t))(*(void *)qword_18C4492D0 + 8LL))(qword_18C4492D0);
  }
  qword_18C4492D0 = 0LL;
  std::mutex::~mutex((std::mutex *)qword_18C4492D8);
  qword_18C4492D8 = 0LL;
  std::condition_variable::~condition_variable((std::condition_variable *)qword_18C4492E0);
  qword_18C4492E0 = 0LL;
  return 1LL;
}

void *icu::UnicodeFilter::getStaticClassID(icu::UnicodeFilter *this)
{
  return &unk_18C535098;
}

uint64_t icu::UnicodeFilter::toMatcher(icu::UnicodeFilter *this)
{
  if (this) {
    return (uint64_t)this + 8;
  }
  else {
    return 0LL;
  }
}

uint64_t icu::UnicodeFilter::matches(uint64_t a1, uint64_t a2, int *a3, int a4, int a5)
{
  int v10 = *a3;
  if (*a3 < a4)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
    int v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 56LL))(a1, v11);
    int v10 = *a3;
    if (v12)
    {
      else {
        int v13 = 2;
      }
      int v14 = v10 + v13;
      goto LABEL_11;
    }
  }

  if (v10 > a4)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
    int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 56LL))(a1, v15);
    int v10 = *a3;
    if (v16)
    {
      BOOL v17 = __OFSUB__(v10, 1);
      int v18 = v10 - 1;
      *a3 = v18;
      if (v18 < 0 != v17) {
        return 2LL;
      }
      int v14 = *a3 - (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 80LL))(a2) & 0xFFFF0000) != 0);
LABEL_11:
      *a3 = v14;
      return 2LL;
    }
  }

  return a5 && v10 == a4;
}

uint64_t non-virtual thunk to'icu::UnicodeFilter::matches(uint64_t a1, uint64_t a2, int *a3, int a4, int a5)
{
  return icu::UnicodeFilter::matches(a1 - 8, a2, a3, a4, a5);
}

void *icu::UnicodeFunctor::getStaticClassID(icu::UnicodeFunctor *this)
{
  return &unk_18C535099;
}

uint64_t icu::UnicodeFunctor::toMatcher(icu::UnicodeFunctor *this)
{
  return 0LL;
}

uint64_t icu::UnicodeFunctor::toReplacer(icu::UnicodeFunctor *this)
{
  return 0LL;
}

void *icu::UnicodeSet::getStaticClassID(icu::UnicodeSet *this)
{
  return &unk_18C53509A;
}

void *icu::UnicodeSet::getDynamicClassID(icu::UnicodeSet *this)
{
  return &unk_18C53509A;
}

BOOL icu::UnicodeSet::hasStrings(icu::UnicodeSet *this)
{
  uint64_t v1 = *((void *)this + 10);
  return v1 && *(_DWORD *)(v1 + 8) != 0;
}

uint64_t icu::UnicodeSet::stringsSize(icu::UnicodeSet *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0LL;
  }
}

icu::UVector *icu::UnicodeSet::stringsContains(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  int32x2_t result = (icu::UVector *)*((void *)this + 10);
  if (result) {
    return (icu::UVector *)((int)icu::UVector::indexOf(result, (uint64_t)a2, 0LL) >= 0);
  }
  return result;
}

double icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 2) = (char *)this + 96;
  *(void *)&double result = 0x100000019LL;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return result;
}

{
  double result;
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 2) = (char *)this + 96;
  *(void *)&double result = 0x100000019LL;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::add(this, a2, a3);
}

{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::add(this, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
  }

  else
  {
    int v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }
  }

  a2 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if (a3 > 0x10FFFF) {
LABEL_9:
  }
    a3 = v4;
  if (a2 < a3)
  {
    unsigned int v6 = a3 + 1;
    int v7 = *((_DWORD *)this + 7);
    if ((v7 & 1) != 0)
    {
      if (v7 == 1)
      {
        int v8 = -2;
      }

      else
      {
        int v8 = *(_DWORD *)(*((void *)this + 2) + 4LL * (v7 - 2));
      }

      if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
      {
        uint64_t v9 = *((void *)this + 2);
        if (v8 == a2)
        {
          *(_DWORD *)(v9 + 4LL * (v7 - 2)) = v6;
          if (a3 == 1114111) {
            --*((_DWORD *)this + 7);
          }
          goto LABEL_31;
        }

        *(_DWORD *)(v9 + 4LL * (v7 - 1)) = a2;
        int v11 = *((_DWORD *)this + 7);
        if (a3 >= 0x10FFFF)
        {
          uint64_t v12 = *((void *)this + 2);
        }

        else
        {
          uint64_t v12 = *((void *)this + 2);
          uint64_t v13 = *((int *)this + 7);
          *((_DWORD *)this + 7) = v13 + 1;
          *(_DWORD *)(v12 + 4 * v13) = v6;
        }

        uint64_t v14 = *((int *)this + 7);
        *((_DWORD *)this + 7) = v14 + 1;
        *(_DWORD *)(v12 + 4 * v14) = 1114112;
LABEL_31:
        uint64_t v15 = (void *)*((void *)this + 8);
        if (v15)
        {
          uprv_free(v15);
          *((void *)this + 8) = 0LL;
          *((_DWORD *)this + 18) = 0;
        }

        return this;
      }
    }

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::copyFrom(this, a2, 0);
}

{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::copyFrom(this, a2, 0);
}

{
  icu::UVector **v4;
  uint64_t v5;
  uint64_t v6;
  const UChar *v7;
  UErrorCode v9;
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((void *)this + 10) = 0LL;
  int v4 = (icu::UVector **)((char *)this + 80);
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0LL;
  if (icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)a2 + 7)))
  {
    int v5 = *((int *)a2 + 7);
    *((_DWORD *)this + 7) = v5;
    memcpy(*((void **)this + 2), *((const void **)a2 + 2), 4 * v5);
    unsigned int v6 = *((void *)a2 + 10);
    if (v6
      && *(_DWORD *)(v6 + 8)
      && ((uint64_t v9 = U_ZERO_ERROR, !icu::UnicodeSet::allocateStrings(this, &v9))
       || (icu::UVector::assign(*v4, *((void *)a2 + 10), (uint64_t (*)(uint64_t, uint64_t))sub_18085CB1C, &v9),
           v9 > U_ZERO_ERROR)))
    {
      icu::UnicodeSet::clear(this);
      *((_BYTE *)this + 32) = 1;
    }

    else
    {
      int v7 = (const UChar *)*((void *)a2 + 8);
      if (v7) {
        icu::UnicodeSet::setPattern((uint64_t)this, v7, *((_DWORD *)a2 + 18));
      }
    }
  }

  return this;
}

{
  return icu::UnicodeSet::UnicodeSet(this, a2);
}

icu::UnicodeSet *icu::UnicodeSet::operator=(icu::UnicodeSet *a1, const icu::UnicodeSet *a2)
{
  return icu::UnicodeSet::copyFrom(a1, a2, 0);
}

uint64_t icu::UnicodeSet::ensureCapacity(icu::UnicodeSet *this, int a2)
{
  if (a2 > 1114112) {
    int v2 = 1114113;
  }
  else {
    int v2 = a2;
  }
  if (v2 <= *((_DWORD *)this + 6)) {
    return 1LL;
  }
  else {
    int v4 = 2 * v2;
  }
  if (v2 <= 24) {
    int v5 = v2 + 25;
  }
  else {
    int v5 = v4;
  }
  unsigned int v6 = uprv_malloc(4LL * v5);
  if (v6)
  {
    int v7 = v6;
    int v8 = (char *)*((void *)this + 2);
    memcpy(v6, v8, 4LL * *((int *)this + 7));
    *((void *)this + 2) = v7;
    *((_DWORD *)this + 6) = v5;
    return 1LL;
  }

  icu::UnicodeSet::clear(this);
  uint64_t result = 0LL;
  *((_BYTE *)this + 32) = 1;
  return result;
}

uint64_t icu::UnicodeSet::allocateStrings(icu::UnicodeSet *this, UErrorCode *a2)
{
  uint64_t v6 = icu::UMemory::operator new((icu::UMemory *)0x28, (unint64_t)a2);
  if (v6)
  {
    uint64_t v2 = 1LL;
    uint64_t v7 = icu::UVector::UVector(v6, uprv_deleteUObject, uhash_compareUnicodeString, 1LL, a2);
    *((void *)this + 10) = v7;
    if (*(int *)a2 >= 1)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
      uint64_t v2 = 0LL;
      *((void *)this + 10) = 0LL;
    }
  }

  else
  {
    uint64_t v2 = 0LL;
    *((void *)this + 10) = 0LL;
    *a2 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v2;
}

icu::UnicodeString *sub_18085CB1C(icu::UnicodeString **a1, UChar ***a2)
{
  uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
  if (result) {
    uint64_t result = icu::UnicodeString::UnicodeString(result, *a2);
  }
  *a1 = result;
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::setToBogus(icu::UnicodeSet *this)
{
  uint64_t result = icu::UnicodeSet::clear(this);
  *((_BYTE *)result + 32) = 1;
  return result;
}

UChar *icu::UnicodeSet::setPattern(uint64_t a1, const UChar *a2, int32_t a3)
{
  uint64_t v6 = *(void **)(a1 + 64);
  if (v6)
  {
    uprv_free(v6);
    *(void *)(a1 + 64) = 0LL;
    *(_DWORD *)(a1 + 72) = 0;
  }

  uint64_t result = (UChar *)uprv_malloc(2LL * (a3 + 1));
  *(void *)(a1 + 64) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = a3;
    uint64_t result = u_memcpy(result, a2, a3);
    *(_WORD *)(*(void *)(a1 + 64) + 2LL * *(int *)(a1 + 72)) = 0;
  }

  return result;
}

void icu::UnicodeSet::~UnicodeSet(icu::UnicodeSet *this)
{
  uint64_t v2 = (char *)*((void *)this + 2);
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  int v4 = (char *)*((void *)this + 6);
  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *((void *)this + 11);
  if (v6)
  {
    uint64_t v7 = (void *)sub_18086391C(v6);
    icu::UMemory::operator delete(v7);
  }

  int v8 = (void *)*((void *)this + 8);
  if (v8)
  {
    uprv_free(v8);
    *((void *)this + 8) = 0LL;
    *((_DWORD *)this + 18) = 0;
  }

  icu::UnicodeFilter::~UnicodeFilter(this);
}

{
  void *v1;
  icu::UnicodeSet::~UnicodeSet(this);
  icu::UMemory::operator delete(v1);
}

void icu::UnicodeSet::releasePattern(icu::UnicodeSet *this)
{
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    uprv_free(v2);
    *((void *)this + 8) = 0LL;
    *((_DWORD *)this + 18) = 0;
  }

void non-virtual thunk to'icu::UnicodeSet::~UnicodeSet(icu::UnicodeSet *this)
{
}

{
  void *v1;
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)((char *)this - 8));
  icu::UMemory::operator delete(v1);
}

icu::UnicodeSet *icu::UnicodeSet::copyFrom(icu::UnicodeSet *this, const icu::UnicodeSet *a2, int a3)
{
  if (this == a2 || *((void *)this + 5) || *((void *)this + 11)) {
    return this;
  }
  if ((*((_BYTE *)a2 + 32) & 1) != 0) {
    goto LABEL_30;
  }
  uint64_t v6 = *((int *)a2 + 7);
  *((_DWORD *)this + 7) = v6;
  memcpy(*((void **)this + 2), *((const void **)a2 + 2), 4 * v6);
  if (!a3 && *((void *)a2 + 5))
  {
    uint64_t v8 = icu::UMemory::operator new((icu::UMemory *)0x368, v7);
    if (!v8)
    {
      *((void *)this + 5) = 0LL;
      goto LABEL_30;
    }

    sub_1807BD84C(v8, *((void *)a2 + 5), *((void *)this + 2), *((_DWORD *)this + 7));
    *((void *)this + 5) = v9;
  }

  unint64_t v10 = *((void *)a2 + 10);
  if (v10 && *(_DWORD *)(v10 + 8))
  {
    UErrorCode v17 = U_ZERO_ERROR;
    int v11 = (icu::UVector *)*((void *)this + 10);
    if (!v11)
    {
      int v11 = (icu::UVector *)*((void *)this + 10);
      unint64_t v10 = *((void *)a2 + 10);
    }

    icu::UVector::assign(v11, v10, (uint64_t (*)(uint64_t, uint64_t))sub_18085CB1C, &v17);
    if (v17 <= U_ZERO_ERROR) {
      goto LABEL_20;
    }
LABEL_30:
    icu::UnicodeSet::clear(this);
    *((_BYTE *)this + 32) = 1;
    return this;
  }

  uint64_t v12 = *((void *)this + 10);
  if (v12 && *(_DWORD *)(v12 + 8)) {
    icu::UVector::removeAllElements(v12);
  }
LABEL_20:
  if (a3 || !*((void *)a2 + 11)) {
    goto LABEL_24;
  }
  uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x188, v10);
  if (!v13)
  {
    *((void *)this + 11) = 0LL;
    goto LABEL_30;
  }

  *((void *)this + 11) = sub_1808638BC(v13, *((void *)a2 + 11), *((void *)this + 10));
LABEL_24:
  uint64_t v14 = (void *)*((void *)this + 8);
  if (v14)
  {
    uprv_free(v14);
    *((void *)this + 8) = 0LL;
    *((_DWORD *)this + 18) = 0;
  }

  uint64_t v15 = (const UChar *)*((void *)a2 + 8);
  if (v15) {
    icu::UnicodeSet::setPattern((uint64_t)this, v15, *((_DWORD *)a2 + 18));
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::clone@<X0>( icu::UnicodeSet *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result)
  {
    *(void *)uint64_t result = off_18971B4D0;
    *((void *)result + 1) = &unk_18971B5E8;
    *((void *)result + 2) = (char *)result + 96;
    *((void *)result + 3) = 0x100000019LL;
    *((_BYTE *)result + 32) = 0;
    *((void *)result + 8) = 0LL;
    *((_DWORD *)result + 18) = 0;
    *((void *)result + 5) = 0LL;
    *((void *)result + 6) = 0LL;
    *((_DWORD *)result + 14) = 0;
    *((void *)result + 10) = 0LL;
    *((void *)result + 11) = 0LL;
    return icu::UnicodeSet::copyFrom(result, this, 0);
  }

  return result;
}

icu::UnicodeSet *icu::UnicodeSet::cloneAsThawed@<X0>( icu::UnicodeSet *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result) {
    return icu::UnicodeSet::UnicodeSet(result, this);
  }
  return result;
}

BOOL icu::UnicodeSet::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  if ((_DWORD)v2 != *(_DWORD *)(a2 + 28)) {
    return 0LL;
  }
  if ((int)v2 >= 1)
  {
    uint64_t v3 = *(int **)(a1 + 16);
    int v4 = *(int **)(a2 + 16);
    do
    {
      int v6 = *v3++;
      int v5 = v6;
      int v7 = *v4++;
      if (v5 != v7) {
        return 0LL;
      }
    }

    while (--v2);
  }

  uint64_t v8 = *(void *)(a1 + 80);
  if (!v8)
  {
    uint64_t v11 = *(void *)(a2 + 80);
    return !v11 || !*(_DWORD *)(v11 + 8);
  }

  int v9 = *(_DWORD *)(v8 + 8);
  uint64_t v10 = *(void *)(a2 + 80);
  if (v10)
  {
    if ((v9 != 0) == (*(_DWORD *)(v10 + 8) != 0)) {
      goto LABEL_17;
    }
    return 0LL;
  }

  if (v9) {
    return 0LL;
  }
  uint64_t v10 = 0LL;
LABEL_17:
  if (!*(_DWORD *)(v8 + 8)) {
    return 1LL;
  }
  BOOL result = icu::UVector::operator==(v8, v10);
  if (result) {
    return 1LL;
  }
  return result;
}

uint64_t icu::UnicodeSet::hashCode(icu::UnicodeSet *this)
{
  uint64_t result = *((unsigned int *)this + 7);
  if ((int)result >= 1)
  {
    uint64_t v3 = (int *)*((void *)this + 2);
    uint64_t v4 = result;
    do
    {
      int v5 = *v3++;
      uint64_t result = (v5 + 1000003 * result);
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t icu::UnicodeSet::size(icu::UnicodeSet *this)
{
  unint64_t v1 = *((unsigned int *)this + 7);
  if ((int)v1 < 2)
  {
    int v2 = 0;
  }

  else
  {
    int v2 = 0;
    unint64_t v3 = v1 >> 1;
    uint64_t v4 = (_DWORD *)(*((void *)this + 2) + 4LL);
    do
    {
      int v2 = *v4 + v2 - *(v4 - 1);
      v4 += 2;
      --v3;
    }

    while (v3);
  }

  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    LODWORD(v5) = *(_DWORD *)(v5 + 8);
  }
  return (v5 + v2);
}

uint64_t icu::UnicodeSet::getRangeCount(icu::UnicodeSet *this)
{
  return (*((_DWORD *)this + 7) / 2);
}

uint64_t icu::UnicodeSet::getRangeEnd(icu::UnicodeSet *this, int a2)
{
  return (*(_DWORD *)(*((void *)this + 2) + 4LL * ((2 * a2) | 1)) - 1);
}

uint64_t icu::UnicodeSet::getRangeStart(icu::UnicodeSet *this, int a2)
{
  return *(unsigned int *)(*((void *)this + 2) + 8LL * a2);
}

BOOL icu::UnicodeSet::isEmpty(icu::UnicodeSet *this)
{
  if (*((_DWORD *)this + 7) != 1) {
    return 0LL;
  }
  uint64_t v1 = *((void *)this + 10);
  return !v1 || *(_DWORD *)(v1 + 8) == 0;
}

uint64_t icu::UnicodeSet::contains(icu::UnicodeSet *this, int a2)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  }
  while (1)
  {
    uint64_t v4 = *((void *)this + 11);
    if (!v4) {
      break;
    }
    this = (icu::UnicodeSet *)(v4 + 8);
    uint64_t v2 = *(void *)(v4 + 48);
    if (v2) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
    }
  }

  if (a2 < 1114112) {
    return icu::UnicodeSet::findCodePoint(this, a2) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t icu::UnicodeSet::findCodePoint(icu::UnicodeSet *this, int a2)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 2);
  if (*v2 > a2) {
    return 0LL;
  }
  int v4 = *((_DWORD *)this + 7);
  uint64_t result = (v4 - 1);
  if (v4 >= 2 && v2[v4 - 2] > a2 && v4 != 2)
  {
    unsigned int v6 = 0;
    unsigned int v7 = result >> 1;
    do
    {
      if (v2[v7] > a2)
      {
        uint64_t result = v7;
      }

      else
      {
        unsigned int v6 = v7;
        uint64_t result = result;
      }

      unsigned int v7 = (int)(result + v6) >> 1;
    }

    while (v7 != v6);
  }

  return result;
}

BOOL icu::UnicodeSet::contains(icu::UnicodeSet *this, int a2, int a3)
{
  int CodePoint = icu::UnicodeSet::findCodePoint(this, a2);
  return (CodePoint & 1) != 0 && *(_DWORD *)(*((void *)this + 2) + 4LL * CodePoint) > a3;
}

icu::UVector *icu::UnicodeSet::contains(icu::UVector **this, const icu::UnicodeString *a2)
{
  int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
  if ((SingleCP & 0x80000000) == 0) {
    return (icu::UVector *)icu::UnicodeSet::contains((icu::UnicodeSet *)this, SingleCP);
  }
  uint64_t result = this[10];
  if (result) {
    return (icu::UVector *)((int)icu::UVector::indexOf(result, (uint64_t)a2, 0LL) >= 0);
  }
  return result;
}

uint64_t icu::UnicodeSet::getSingleCP(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 0x8000u) == 0) {
    unsigned int v3 = v2 >> 5;
  }
  else {
    unsigned int v3 = *((_DWORD *)this + 3);
  }
  if (v3 == 2)
  {
    uint64_t result = icu::UnicodeString::char32At(this, 0);
    return 0xFFFFFFFFLL;
  }

  if (v3 != 1) {
    return 0xFFFFFFFFLL;
  }
  if ((v2 & 2) != 0) {
    int v4 = (unsigned __int16 *)((char *)this + 10);
  }
  else {
    int v4 = (unsigned __int16 *)*((void *)this + 3);
  }
  return *v4;
}

uint64_t icu::UnicodeSet::containsAll(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 7);
  if ((int)v4 < 2)
  {
LABEL_6:
    uint64_t v8 = (const icu::UVector *)*((void *)a2 + 10);
    if (v8 && *((_DWORD *)v8 + 2))
    {
      uint64_t result = *((void *)this + 10);
      if (result) {
        return icu::UVector::containsAll((icu::UVector *)result, v8);
      }
    }

    else
    {
      return 1LL;
    }
  }

  else
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = (_DWORD *)(*((void *)a2 + 2) + 4LL);
    while (1)
    {
      int CodePoint = icu::UnicodeSet::findCodePoint(this, *(v6 - 1));
      v6 += 2;
      if (!--v5) {
        goto LABEL_6;
      }
    }
  }

  return result;
}

BOOL icu::UnicodeSet::containsAll(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  if ((v3 & 0x11) != 0)
  {
    unint64_t v4 = 0LL;
  }

  else if ((v3 & 2) != 0)
  {
    unint64_t v4 = (UChar *)((char *)a2 + 10);
  }

  else
  {
    unint64_t v4 = (UChar *)*((void *)a2 + 3);
  }

  int v5 = (__int16)v3;
  unsigned int v6 = v3 >> 5;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *((unsigned int *)a2 + 3);
  }
  int v8 = icu::UnicodeSet::span(this, v4, v7, 1);
  unsigned int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 < 0) {
    unsigned int v11 = *((_DWORD *)a2 + 3);
  }
  return v8 == v11;
}

unint64_t icu::UnicodeSet::span(icu::UnicodeSet *this, UChar *s, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0LL;
    }
    uint64_t v5 = u_strlen(s);
    if (!(_DWORD)v5) {
      return 0LL;
    }
  }

  else
  {
    int v8 = (unsigned int *)*((void *)this + 5);
    if (v8) {
      return (unint64_t)((char *)sub_1807BDB60(v8, s, (unint64_t)&s[a3], a4) - (char *)s) >> 1;
    }
  }

  uint64_t v11 = *((void *)this + 11);
  if (!v11)
  {
    uint64_t v12 = *((void *)this + 10);
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      uint64_t v31 = 0LL;
      if (a4) {
        uint64_t v13 = 42LL;
      }
      else {
        uint64_t v13 = 41LL;
      }
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v22 = 0u;
      memset(v21, 0, sizeof(v21));
      sub_1808637CC(v21, this, v12, v13);
      if (HIDWORD(v22))
      {
        uint64_t v9 = sub_180863920((uint64_t)v21, s, v5, a4);
        sub_18086391C(v21);
        return v9;
      }

      sub_18086391C(v21);
    }

    uint64_t v9 = 0LL;
    int v14 = a4 != 0;
    do
    {
      uint64_t v15 = (int)v9 + 1LL;
      int v16 = s[(int)v9];
      if ((v16 & 0xFC00) == 0xD800 && (_DWORD)v15 != (_DWORD)v5)
      {
        int v18 = s[v15];
        BOOL v19 = (v18 & 0xFC00) == 56320;
        int v20 = v18 + (v16 << 10) - 56613888;
        if (v19) {
          int v16 = v20;
        }
        if (v19) {
          uint64_t v15 = (v9 + 2);
        }
        else {
          uint64_t v15 = v15;
        }
      }

      uint64_t v9 = v15;
    }

    while ((int)v15 < (int)v5);
    return v9;
  }

  return sub_180863920(v11, s, v5, a4);
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, int a2, int a3)
{
  int CodePoint = icu::UnicodeSet::findCodePoint(this, a2);
  return (CodePoint & 1) == 0 && *(_DWORD *)(*((void *)this + 2) + 4LL * CodePoint) > a3;
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 7);
  if ((int)v4 < 2)
  {
LABEL_6:
    int v8 = (icu::UVector *)*((void *)this + 10);
    return !v8
        || (uint64_t v9 = (const icu::UVector *)*((void *)a2 + 10)) == 0LL
        || !*((_DWORD *)v9 + 2)
        || icu::UVector::containsNone(v8, v9) != 0;
  }

  else
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = (_DWORD *)(*((void *)a2 + 2) + 4LL);
    while (1)
    {
      int CodePoint = icu::UnicodeSet::findCodePoint(this, *(v6 - 1));
      v6 += 2;
      if (!--v5) {
        goto LABEL_6;
      }
    }
  }

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  if ((v3 & 0x11) != 0)
  {
    unint64_t v4 = 0LL;
  }

  else if ((v3 & 2) != 0)
  {
    unint64_t v4 = (UChar *)((char *)a2 + 10);
  }

  else
  {
    unint64_t v4 = (UChar *)*((void *)a2 + 3);
  }

  int v5 = (__int16)v3;
  unsigned int v6 = v3 >> 5;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *((unsigned int *)a2 + 3);
  }
  int v8 = icu::UnicodeSet::span(this, v4, v7, 0);
  unsigned int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 < 0) {
    unsigned int v11 = *((_DWORD *)a2 + 3);
  }
  return v8 == v11;
}

uint64_t icu::UnicodeSet::matchesIndexValue(icu::UnicodeSet *this, unsigned int a2)
{
  unint64_t v4 = *((unsigned int *)this + 7);
  if ((int)v4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = (_BYTE *)(*((void *)this + 2) + 4LL);
    do
    {
      unsigned int v7 = *((_DWORD *)v6 - 1);
      unsigned int v8 = (*v6 - 1);
      if (((*(_DWORD *)v6 - 1) ^ *((_DWORD *)v6 - 1)) > 0xFF)
      {
        if (v7 <= a2 || v8 >= a2) {
          return 1LL;
        }
      }

      else if (v7 <= a2 && v8 >= a2)
      {
        return 1LL;
      }

      v6 += 8;
      --v5;
    }

    while (v5);
  }

  uint64_t result = *((void *)this + 10);
  if (result)
  {
    if (*(int *)(result + 8) < 1)
    {
      return 0LL;
    }

    else
    {
      signed int v12 = 0;
      while (1)
      {
        uint64_t v13 = (unsigned __int16 *)icu::UVector::elementAt((icu::UVector *)result, v12);
        int v14 = (uint64_t *)v13[4];
        if (v14 >= 0x20
          && a2 == icu::UnicodeString::char32At(v14, (icu::UnicodeString *)v13, 0))
        {
          break;
        }

        ++v12;
        uint64_t result = *((void *)this + 10);
        if (v12 >= *(_DWORD *)(result + 8)) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  return result;
}

uint64_t non-virtual thunk to'icu::UnicodeSet::matchesIndexValue(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::matchesIndexValue((icu::UnicodeSet *)((char *)this - 8), a2);
}

uint64_t icu::UnicodeSet::matches(int **this, const icu::Replaceable *a2, int *a3, int a4, int a5)
{
  int v7 = *a3;
  if (*a3 == a4)
  {
    int v8 = icu::UnicodeSet::contains((icu::UnicodeSet *)this, 0xFFFF);
    if (a5) {
      unsigned int v9 = 1;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v8) {
      return v9;
    }
    else {
      return 0LL;
    }
  }

  int v14 = this[10];
  if (!v14) {
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  }
  if (!v14[2]) {
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  }
  unsigned int v15 = (*(uint64_t (**)(const icu::Replaceable *, void))(*(void *)a2 + 72LL))(a2, *a3);
  int v16 = this[10];
  if (v16[2] < 1) {
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  }
  uint64_t v17 = 0LL;
  signed int v18 = 0;
  while (1)
  {
    uint64_t v19 = icu::UVector::elementAt((icu::UVector *)v16, v18);
    unsigned int v20 = *(unsigned __int16 *)(v19 + 8);
    if (v20 < 0x20)
    {
LABEL_44:
      uint64_t v30 = v17;
      goto LABEL_45;
    }

    uint64_t v21 = v19;
    if (v7 >= a4)
    {
      if ((v20 & 0x8000) != 0) {
        unsigned int v24 = *(_DWORD *)(v19 + 12);
      }
      else {
        unsigned int v24 = v20 >> 5;
      }
      unsigned int v22 = v24 - 1;
      if ((v20 & 0x8000) == 0)
      {
LABEL_15:
        unsigned int v23 = v20 >> 5;
        goto LABEL_21;
      }
    }

    else
    {
      unsigned int v22 = 0;
      if ((v20 & 0x8000) == 0) {
        goto LABEL_15;
      }
    }

    unsigned int v23 = *(_DWORD *)(v19 + 12);
LABEL_21:
    if (v23 <= v22)
    {
      unsigned int v26 = 0xFFFF;
    }

    else
    {
      uint64_t v25 = (v20 & 2) != 0 ? v19 + 10 : *(void *)(v19 + 24);
      unsigned int v26 = *(unsigned __int16 *)(v25 + 2LL * (int)v22);
    }

    if (v7 < a4 && v26 > v15) {
      break;
    }
    if (v26 != v15) {
      goto LABEL_44;
    }
    int matched = icu::UnicodeSet::matchRest((uint64_t)a2, *a3, a4, v19);
    if (a5)
    {
      int v28 = *a3 - a4;
      if (v7 < a4) {
        int v28 = a4 - *a3;
      }
      if (matched == v28) {
        return 1LL;
      }
    }

    int v29 = *(__int16 *)(v21 + 8) < 0 ? *(_DWORD *)(v21 + 12) : *(unsigned __int16 *)(v21 + 8) >> 5;
    if (matched != v29) {
      goto LABEL_44;
    }
    else {
      uint64_t v30 = matched;
    }
    if (v7 < a4 && matched < (int)v17)
    {
LABEL_46:
      if (!(_DWORD)v30) {
        return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
      }
      goto LABEL_47;
    }

uint64_t icu::UnicodeSet::matchRest(uint64_t a1, int a2, int a3, uint64_t a4)
{
  unsigned int v6 = *(unsigned __int16 *)(a4 + 8);
  int v7 = (__int16)v6;
  unsigned int v8 = v6 >> 5;
  if (v7 < 0) {
    unsigned int v8 = *(_DWORD *)(a4 + 12);
  }
  unsigned int v9 = a2 - a3;
  if (a2 >= a3)
  {
    else {
      uint64_t v10 = v9;
    }
    if ((int)v10 >= 2)
    {
      unsigned int v18 = v8 - 2;
      uint64_t v19 = (a2 - 1);
      uint64_t v20 = v10 - 1;
      while (1)
      {
        int v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v19);
        unsigned int v22 = *(unsigned __int16 *)(a4 + 8);
        unsigned int v23 = (v22 & 0x8000u) == 0 ? v22 >> 5 : *(_DWORD *)(a4 + 12);
        if (v23 <= v18)
        {
          int v25 = 0xFFFF;
        }

        else
        {
          uint64_t v24 = (v22 & 2) != 0 ? a4 + 10 : *(void *)(a4 + 24);
          int v25 = *(unsigned __int16 *)(v24 + 2LL * (int)v18);
        }

        if (v21 != v25) {
          break;
        }
        --v18;
        uint64_t v19 = (v19 - 1);
        if (!--v20) {
          return v10;
        }
      }

      return 0LL;
    }
  }

  else
  {
    else {
      uint64_t v10 = (a3 - a2);
    }
    if ((int)v10 >= 2)
    {
      unint64_t v12 = 1LL;
      while (1)
      {
        int v13 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 72LL))(a1, (a2 + v12));
        unsigned int v14 = *(unsigned __int16 *)(a4 + 8);
        unint64_t v15 = (v14 & 0x8000u) == 0 ? v14 >> 5 : *(unsigned int *)(a4 + 12);
        if (v12 >= v15)
        {
          int v17 = 0xFFFF;
        }

        else
        {
          uint64_t v16 = (v14 & 2) != 0 ? a4 + 10 : *(void *)(a4 + 24);
          int v17 = *(unsigned __int16 *)(v16 + 2 * v12);
        }

        if (v13 != v17) {
          break;
        }
        if (v10 == ++v12) {
          return v10;
        }
      }

      return 0LL;
    }
  }

  return v10;
}

uint64_t non-virtual thunk to'icu::UnicodeSet::matches( int **this, const icu::Replaceable *a2, int *a3, int a4, int a5)
{
  return icu::UnicodeSet::matches(this - 1, a2, a3, a4, a5);
}

icu::UnicodeSet *icu::UnicodeSet::addMatchSetTo(icu::UnicodeSet *this, icu::UVector **a2)
{
  return icu::UnicodeSet::addAll(a2, this);
}

icu::UnicodeSet *icu::UnicodeSet::addAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  int v4 = *((_DWORD *)a2 + 7);
  if (v4 >= 1)
  {
    unint64_t v5 = (int *)*((void *)a2 + 2);
    if (v5) {
      icu::UnicodeSet::add((icu::UnicodeSet *)this, v5, v4, 0);
    }
  }

  unsigned int v6 = (icu::UVector *)*((void *)a2 + 10);
  if (v6 && *((int *)v6 + 2) >= 1)
  {
    signed int v7 = 0;
    do
    {
      unsigned int v8 = (UChar **)icu::UVector::elementAt(v6, v7);
      unsigned int v9 = this[10];
      ++v7;
      unsigned int v6 = (icu::UVector *)*((void *)a2 + 10);
    }

    while (v7 < *((_DWORD *)v6 + 2));
  }

  return (icu::UnicodeSet *)this;
}

icu::UnicodeSet *non-virtual thunk to'icu::UnicodeSet::addMatchSetTo( icu::UnicodeSet *this, icu::UVector **a2)
{
  return icu::UnicodeSet::addAll(a2, (icu::UnicodeSet *)((char *)this - 8));
}

uint64_t icu::UnicodeSet::indexOf(icu::UnicodeSet *this, unsigned int a2)
{
  if (HIWORD(a2) <= 0x10u)
  {
    int v3 = 0;
    for (__int16 i = (int *)(*((void *)this + 2) + 4LL); ; i += 2)
    {
      int v5 = *(i - 1);
      int v6 = v3;
      int v7 = *i;
      int v3 = v3 - v5 + v7;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t icu::UnicodeSet::charAt(icu::UnicodeSet *this, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    int64_t v2 = 0LL;
    while (v2 < (uint64_t)(*((int *)this + 7) & 0xFFFFFFFFFFFFFFFELL))
    {
      int v3 = a2;
      uint64_t v4 = *((void *)this + 2) + 4 * v2;
      v2 += 2LL;
      int v5 = *(_DWORD *)v4;
      LODWORD(v4) = *(_DWORD *)(v4 + 4) - *(_DWORD *)v4;
      BOOL v6 = __OFSUB__(a2, (_DWORD)v4);
      a2 -= v4;
      if (a2 < 0 != v6) {
        return (v5 + v3);
      }
    }
  }

  return 0xFFFFFFFFLL;
}

icu::UnicodeSet *icu::UnicodeSet::set(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  int v5 = icu::UnicodeSet::clear(this);
  return icu::UnicodeSet::complement(v5, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::clear(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11))
  {
    **((_DWORD **)this + 2) = 1114112;
    *((_DWORD *)this + 7) = 1;
    int64_t v2 = (void *)*((void *)this + 8);
    if (v2)
    {
      uprv_free(v2);
      *((void *)this + 8) = 0LL;
      *((_DWORD *)this + 18) = 0;
    }

    uint64_t v3 = *((void *)this + 10);
    if (v3) {
      icu::UVector::removeAllElements(v3);
    }
    *((_BYTE *)this + 32) = 0;
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 5) || *((void *)this + 11) || (*((_BYTE *)this + 32) & 1) != 0) {
    return this;
  }
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
    goto LABEL_8;
  }

  int v5 = 1114111;
  if (a2 > 0x10FFFF) {
LABEL_8:
  }
    a2 = v5;
  if ((a3 & 0x80000000) != 0)
  {
    int v4 = 0;
  }

  else if (a3 <= 0x10FFFF)
  {
    goto LABEL_14;
  }

  a3 = v4;
LABEL_14:
  if (a2 <= a3)
  {
    v8[0] = a2;
    v8[1] = a3 + 1;
    void v8[2] = 1114112;
    icu::UnicodeSet::exclusiveOr(this, v8, 2, 0);
  }

  BOOL v6 = (void *)*((void *)this + 8);
  if (v6)
  {
    uprv_free(v6);
    *((void *)this + 8) = 0LL;
    *((_DWORD *)this + 18) = 0;
  }

  return this;
}

void icu::UnicodeSet::add(icu::UnicodeSet *this, int *a2, int a3, char a4)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 5)
    || *((void *)this + 11)
    || !a2
    || (*((_BYTE *)this + 32) & 1) != 0
    || !icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    return;
  }

  int v27 = a3;
  int v8 = 0;
  uint64_t v9 = (int *)*((void *)this + 2);
  int v10 = *v9;
  int v11 = *a2;
  int v12 = 1;
  int v13 = 1;
  while (2)
  {
    switch(a4)
    {
      case 0:
        if (v10 >= v11)
        {
          if (v11 >= v10)
          {
            if (v10 == 1114112) {
              goto LABEL_55;
            }
            uint64_t v22 = *((void *)this + 6);
            unsigned int v23 = v8 - 1;
            if (v8 >= 1 && (int v24 = *(_DWORD *)(v22 + 4LL * v23), v10 <= v24))
            {
              if (v9[v12] <= v24) {
                int v10 = *(_DWORD *)(v22 + 4LL * v23);
              }
              else {
                int v10 = v9[v12];
              }
            }

            else
            {
              unsigned int v23 = v8 + 1;
              *(_DWORD *)(v22 + 4LL * v8) = v10;
              int v10 = v9[v12];
            }

            ++v12;
            int v11 = a2[v13++];
            a4 = 3;
            int v8 = v23;
          }

          else
          {
            uint64_t v19 = *((void *)this + 6);
            unsigned int v20 = v8 - 1;
            if (v8 >= 1 && (int v21 = *(_DWORD *)(v19 + 4LL * v20), v11 <= v21))
            {
              if (a2[v13] <= v21) {
                int v11 = *(_DWORD *)(v19 + 4LL * v20);
              }
              else {
                int v11 = a2[v13];
              }
            }

            else
            {
              unsigned int v20 = v8 + 1;
              *(_DWORD *)(v19 + 4LL * v8) = v11;
              int v11 = a2[v13];
            }

            ++v13;
            a4 = 2;
            int v8 = v20;
          }
        }

        else
        {
          uint64_t v14 = *((void *)this + 6);
          unsigned int v15 = v8 - 1;
          if (v8 >= 1 && (int v16 = *(_DWORD *)(v14 + 4LL * v15), v10 <= v16))
          {
            if (v9[v12] <= v16) {
              int v10 = *(_DWORD *)(v14 + 4LL * v15);
            }
            else {
              int v10 = v9[v12];
            }
          }

          else
          {
            unsigned int v15 = v8 + 1;
            *(_DWORD *)(v14 + 4LL * v8) = v10;
            int v10 = v9[v12];
          }

          ++v12;
          a4 = 1;
          int v8 = v15;
        }

        continue;
      case 1:
        if (v10 >= v11)
        {
          if (v11 >= v10)
          {
            if (v10 == 1114112) {
              goto LABEL_55;
            }
            int v10 = v9[v12++];
            int v11 = a2[v13++];
            a4 = 2;
          }

          else
          {
            int v11 = a2[v13++];
            a4 = 3;
          }
        }

        else
        {
          int v17 = *((_DWORD *)this + 14);
          if ((v8 >= v17 || v12 >= *((_DWORD *)this + 6))
            && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEFAULT))
          {
            int v18 = *((_DWORD *)this + 6);
            *(_DWORD *)buf = 67110912;
            int v29 = v8;
            __int16 v30 = 1024;
            int v31 = v17;
            __int16 v32 = 1024;
            int v33 = v12;
            __int16 v34 = 1024;
            int v35 = v18;
            __int16 v36 = 1024;
            int v37 = v13;
            __int16 v38 = 1024;
            int v39 = v27;
            __int16 v40 = 1024;
            int v41 = v10;
            __int16 v42 = 1024;
            int v43 = v11;
            _os_log_impl( &dword_1807BC000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEFAULT,  "# UnicodeSet::add case 1, k %d bufCap %d i %d cap %d j %d otherLen %d a %04X b %04X",  buf,  0x32u);
            uint64_t v9 = (int *)*((void *)this + 2);
          }

          a4 = 0;
          *(_DWORD *)(*((void *)this + 6) + 4LL * v8++) = v10;
          int v10 = v9[v12++];
        }

        continue;
      case 2:
        if (v11 < v10)
        {
          a4 = 0;
          *(_DWORD *)(*((void *)this + 6) + 4LL * v8++) = v11;
LABEL_34:
          int v11 = a2[v13++];
          continue;
        }

        if (v10 < v11)
        {
          int v10 = v9[v12++];
          a4 = 3;
          continue;
        }

        if (v10 != 1114112)
        {
          int v10 = v9[v12++];
          int v11 = a2[v13++];
          a4 = 1;
          continue;
        }

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0)
  {
    int v3 = 0;
  }

  else
  {
    int v3 = a2;
    if (a2 >= 0x110000) {
      int v3 = 1114111;
    }
  }

  int CodePoint = icu::UnicodeSet::findCodePoint(this, v3);
  if ((CodePoint & 1) == 0 && !*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    int v5 = CodePoint;
    uint64_t v6 = *((void *)this + 2);
    uint64_t v7 = CodePoint;
    if (v3 == *(_DWORD *)(v6 + 4LL * CodePoint) - 1)
    {
      *(_DWORD *)(v6 + 4LL * CodePoint) = v3;
      if (v3 == 1114111)
      {
        uint64_t v6 = *((void *)this + 2);
        uint64_t v8 = *((int *)this + 7);
        *((_DWORD *)this + 7) = v8 + 1;
        *(_DWORD *)(v6 + 4 * v8) = 1114112;
      }

      uint64_t v9 = v6 + 4 * v7;
      int v10 = *((_DWORD *)this + 7);
      if (v9 + 4 < (unint64_t)(v6 + 4LL * v10))
      {
        unint64_t v11 = v6 + 4LL * v10;
        if (v9 + 8 > v11) {
          unint64_t v11 = v9 + 8;
        }
        memmove((void *)(v9 - 4), (const void *)(v9 + 4), ((v11 - v9 - 5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        int v10 = *((_DWORD *)this + 7);
      }

      int v12 = v10 - 2;
    }

    else
    {
      uint64_t v13 = (CodePoint - 1);
      if (CodePoint >= 1 && v3 == *(_DWORD *)(v6 + 4LL * v13))
      {
        *(_DWORD *)(v6 + 4 * v13) = v3 + 1;
        goto LABEL_26;
      }

      memmove( (void *)(*((void *)this + 2) + 4 * v7 + 8),  (const void *)(*((void *)this + 2) + 4 * v7),  4LL * (*((_DWORD *)this + 7) - v5));
      uint64_t v14 = (int *)(*((void *)this + 2) + 4 * v7);
      *uint64_t v14 = v3;
      v14[1] = v3 + 1;
      int v12 = *((_DWORD *)this + 7) + 2;
    }

    *((_DWORD *)this + 7) = v12;
LABEL_26:
    unsigned int v15 = (void *)*((void *)this + 8);
    if (v15)
    {
      uprv_free(v15);
      *((void *)this + 8) = 0LL;
      *((_DWORD *)this + 18) = 0;
    }
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      uint64_t v6 = (icu::UVector *)*((void *)this + 10);
      if (!v6 || (icu::UVector::indexOf(v6, (uint64_t)a2, 0LL) & 0x80000000) != 0)
      {
        icu::UnicodeSet::_add(this, (UChar **)a2);
        uint64_t v7 = (void *)*((void *)this + 8);
        if (v7)
        {
          uprv_free(v7);
          *((void *)this + 8) = 0LL;
          *((_DWORD *)this + 18) = 0;
        }
      }
    }

    else
    {
      icu::UnicodeSet::add(this, SingleCP);
    }
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::_add(icu::UnicodeSet *this, UChar **a2)
{
  if (!*((void *)this + 5))
  {
    int64_t v2 = this;
    if (!*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
    {
      if ((UErrorCode v6 = U_ZERO_ERROR, !*((void *)this + 10)) && !icu::UnicodeSet::allocateStrings(this, &v6)
        || (int v4 = (icu::UnicodeString *)icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2)) == 0LL
        || (int v5 = v4,
            icu::UnicodeString::UnicodeString(v4, a2),
            this = (icu::UnicodeSet *)icu::UVector::sortedInsert(*((void *)v2 + 10), v5, sub_18085E518, &v6),
            v6 >= U_ILLEGAL_ARGUMENT_ERROR))
      {
        this = icu::UnicodeSet::clear(v2);
        *((_BYTE *)v2 + 32) = 1;
      }
    }
  }

  return this;
}

uint64_t sub_18085E518(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  else {
    int32_t v3 = v2 >> 5;
  }
  unsigned int v4 = *(unsigned __int16 *)(a2 + 8);
  if ((v4 & 1) != 0) {
    return (v2 & 1) == 0;
  }
  if ((v4 & 0x8000u) == 0) {
    int v5 = v4 >> 5;
  }
  else {
    int v5 = *(_DWORD *)(a2 + 12);
  }
  if ((v4 & 2) != 0) {
    uint64_t v6 = a2 + 10;
  }
  else {
    uint64_t v6 = *(void *)(a2 + 24);
  }
  return icu::UnicodeString::doCompare(a1, 0, v3, v6, v5 & (v5 >> 31), v5 & ~(v5 >> 31));
}

icu::UnicodeSet *icu::UnicodeSet::addAll(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  int v4 = (__int16)v3;
  LODWORD(v5) = v3 >> 5;
  if (v4 >= 0) {
    unint64_t v5 = v5;
  }
  else {
    unint64_t v5 = *((unsigned int *)a2 + 3);
  }
  if ((int)v5 >= 1)
  {
    int v7 = 0;
    do
    {
      unsigned int v8 = icu::UnicodeString::char32At((uint64_t *)v5, a2, v7);
      icu::UnicodeSet::add(this, v8);
      if (v8 < 0x10000) {
        int v9 = 1;
      }
      else {
        int v9 = 2;
      }
      v7 += v9;
      unsigned int v10 = *((unsigned __int16 *)a2 + 4);
      int v11 = (__int16)v10;
      LODWORD(v5) = v10 >> 5;
      if (v11 >= 0) {
        unint64_t v5 = v5;
      }
      else {
        unint64_t v5 = *((unsigned int *)a2 + 3);
      }
    }

    while (v7 < (int)v5);
  }

  return this;
}

icu::UVector **icu::UnicodeSet::retainAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  __int128 v5 = 0u;
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  v4[0] = off_18971B4D0;
  v4[1] = &unk_18971B5E8;
  v4[2] = v9;
  v4[3] = 0x100000019LL;
  __int128 v6 = 0uLL;
  __int128 v8 = 0uLL;
  __int128 v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::retainAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::retainAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::retain((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 0);
    int v4 = this[10];
    if (v4)
    {
      if (*((_DWORD *)v4 + 2))
      {
        __int128 v5 = (const icu::UVector *)*((void *)a2 + 10);
        if (v5 && *((_DWORD *)v5 + 2)) {
          icu::UVector::retainAll(v4, v5);
        }
        else {
          icu::UVector::removeAllElements((uint64_t)v4);
        }
      }
    }
  }

  return (icu::UnicodeSet *)this;
}

icu::UVector **icu::UnicodeSet::complementAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  __int128 v5 = 0u;
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  v4[0] = off_18971B4D0;
  v4[1] = &unk_18971B5E8;
  v4[2] = v9;
  v4[3] = 0x100000019LL;
  __int128 v6 = 0uLL;
  __int128 v8 = 0uLL;
  __int128 v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::complementAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complementAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::exclusiveOr((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 0);
    int v4 = (icu::UVector *)*((void *)a2 + 10);
    if (v4)
    {
      if (*((int *)v4 + 2) >= 1)
      {
        signed int v5 = 0;
        do
        {
          __int128 v6 = (UChar **)icu::UVector::elementAt(v4, v5);
          __int128 v7 = this[10];
          ++v5;
          int v4 = (icu::UVector *)*((void *)a2 + 10);
        }

        while (v5 < *((_DWORD *)v4 + 2));
      }
    }
  }

  return (icu::UnicodeSet *)this;
}

icu::UVector **icu::UnicodeSet::removeAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  __int128 v5 = 0u;
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  v4[0] = off_18971B4D0;
  v4[1] = &unk_18971B5E8;
  v4[2] = v9;
  v4[3] = 0x100000019LL;
  __int128 v6 = 0uLL;
  __int128 v8 = 0uLL;
  __int128 v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::removeAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::removeAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::retain((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 2);
    int v4 = this[10];
    if (v4)
    {
      if (*((_DWORD *)v4 + 2))
      {
        __int128 v5 = (const icu::UVector *)*((void *)a2 + 10);
        if (v5)
        {
          if (*((_DWORD *)v5 + 2)) {
            icu::UVector::removeAll(v4, v5);
          }
        }
      }
    }
  }

  return (icu::UnicodeSet *)this;
}

icu::UnicodeSet *icu::UnicodeSet::removeAllStrings(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11))
  {
    uint64_t v3 = *((void *)this + 10);
    if (v3)
    {
      if (*(_DWORD *)(v3 + 8))
      {
        icu::UVector::removeAllElements(v3);
        int v4 = (void *)*((void *)this + 8);
        if (v4)
        {
          uprv_free(v4);
          *((void *)this + 8) = 0LL;
          *((_DWORD *)this + 18) = 0;
        }
      }
    }
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::createFrom@<X0>( icu::UnicodeSet *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_18971B4D0;
    *((void *)result + 1) = &unk_18971B5E8;
    *((_DWORD *)result + 24) = 1114112;
    *((void *)result + 2) = (char *)result + 96;
    *((void *)result + 3) = 0x100000019LL;
    *((_BYTE *)result + 32) = 0;
    *((void *)result + 8) = 0LL;
    *((_DWORD *)result + 18) = 0;
    *((void *)result + 5) = 0LL;
    *((void *)result + 6) = 0LL;
    *((_DWORD *)result + 14) = 0;
    *((void *)result + 10) = 0LL;
    *((void *)result + 11) = 0LL;
    return icu::UnicodeSet::add(result, this);
  }

  return result;
}

icu::UnicodeSet *icu::UnicodeSet::createFromAll@<X0>( icu::UnicodeSet *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = off_18971B4D0;
    *((void *)result + 1) = &unk_18971B5E8;
    *((_DWORD *)result + 24) = 1114112;
    *((void *)result + 2) = (char *)result + 96;
    *((void *)result + 3) = 0x100000019LL;
    *((_BYTE *)result + 32) = 0;
    *((void *)result + 8) = 0LL;
    *((_DWORD *)result + 18) = 0;
    *((void *)result + 5) = 0LL;
    *((void *)result + 6) = 0LL;
    *((_DWORD *)result + 14) = 0;
    *((void *)result + 10) = 0LL;
    *((void *)result + 11) = 0LL;
    return icu::UnicodeSet::addAll(result, this);
  }

  return result;
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
  }

  else
  {
    int v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }
  }

  a2 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if (a3 > 0x10FFFF) {
LABEL_9:
  }
    a3 = v4;
  if (a2 <= a3)
  {
    v7[0] = a2;
    v7[1] = a3 + 1;
    v7[2] = 1114112;
    icu::UnicodeSet::retain(this, v7, 2, 0);
  }

  else
  {
    icu::UnicodeSet::clear(this);
  }

  return this;
}

void icu::UnicodeSet::retain(icu::UnicodeSet *this, int *a2, int a3, char a4)
{
  if (!*((void *)this + 5)
    && !*((void *)this + 11)
    && (*((_BYTE *)this + 32) & 1) == 0
    && icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    int v7 = 0;
    uint64_t v8 = (int *)*((void *)this + 2);
    int v9 = *v8;
    int v10 = *a2;
    int v11 = 1;
    int v12 = 1;
    while (1)
    {
      switch(a4)
      {
        case 0:
          if (v9 < v10)
          {
            int v9 = v8[v11++];
            a4 = 1;
            continue;
          }

          if (v10 < v9) {
            goto LABEL_27;
          }
          if (v9 == 1114112) {
            goto LABEL_34;
          }
          *(_DWORD *)(*((void *)this + 6) + 4LL * v7++) = v9;
          int v9 = v8[v11];
          int v10 = a2[v12];
          ++v11;
          goto LABEL_20;
        case 1:
          if (v9 >= v10)
          {
            if (v10 >= v9)
            {
              if (v9 == 1114112) {
                goto LABEL_34;
              }
              int v9 = v8[v11++];
LABEL_27:
              int v10 = a2[v12++];
              a4 = 2;
            }

            else
            {
              *(_DWORD *)(*((void *)this + 6) + 4LL * v7++) = v10;
              int v10 = a2[v12];
LABEL_20:
              ++v12;
              a4 = 3;
            }
          }

          else
          {
            a4 = 0;
            int v9 = v8[v11++];
          }

          continue;
        case 2:
          if (v10 < v9)
          {
            a4 = 0;
            goto LABEL_33;
          }

          if (v9 < v10)
          {
            *(_DWORD *)(*((void *)this + 6) + 4LL * v7++) = v9;
            int v9 = v8[v11++];
            a4 = 3;
            continue;
          }

          if (v9 == 1114112) {
            goto LABEL_34;
          }
          int v9 = v8[v11++];
          goto LABEL_30;
        case 3:
          if (v9 >= v10)
          {
            if (v10 >= v9)
            {
              if (v9 == 1114112)
              {
LABEL_34:
                uint64_t v13 = *((void *)this + 6);
                *(_DWORD *)(v13 + 4LL * v7) = 1114112;
                *((void *)this + 2) = v13;
                *((void *)this + 6) = v8;
                int v14 = *((_DWORD *)this + 6);
                *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
                *((_DWORD *)this + 7) = v7 + 1;
                *((_DWORD *)this + 14) = v14;
                unsigned int v15 = (void *)*((void *)this + 8);
                if (v15)
                {
                  uprv_free(v15);
                  *((void *)this + 8) = 0LL;
                  *((_DWORD *)this + 18) = 0;
                }

                return;
              }

              a4 = 0;
              *(_DWORD *)(*((void *)this + 6) + 4LL * v7++) = v9;
              int v9 = v8[v11++];
LABEL_33:
              int v10 = a2[v12++];
            }

            else
            {
              *(_DWORD *)(*((void *)this + 6) + 4LL * v7++) = v10;
LABEL_30:
              int v10 = a2[v12++];
              a4 = 1;
            }
          }

          else
          {
            *(_DWORD *)(*((void *)this + 6) + 4LL * v7++) = v9;
            int v9 = v8[v11++];
            a4 = 2;
          }

          break;
        default:
          continue;
      }
    }
  }

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::retain(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      int v5 = (icu::UVector *)*((void *)this + 10);
      if (!v5 || (icu::UVector::indexOf(v5, (uint64_t)a2, 0LL) & 0x80000000) != 0)
      {
        icu::UnicodeSet::clear(this);
      }

      else if ((*((_DWORD *)this + 7) + 1) > 2 || icu::UnicodeSet::size(this) != 1)
      {
        __int128 v6 = icu::UnicodeSet::clear(this);
        icu::UnicodeSet::_add(v6, (UChar **)a2);
      }
    }

    else
    {
      icu::UnicodeSet::retain(this, SingleCP, SingleCP);
    }
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
  }

  else
  {
    int v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }
  }

  a2 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if (a3 > 0x10FFFF) {
LABEL_9:
  }
    a3 = v4;
  if (a2 <= a3)
  {
    v7[0] = a2;
    v7[1] = a3 + 1;
    v7[2] = 1114112;
    icu::UnicodeSet::retain(this, v7, 2, 2);
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::remove(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      __int128 v6 = (icu::UVector *)*((void *)this + 10);
      if (v6)
      {
        if (icu::UVector::removeElement(v6, (uint64_t)a2))
        {
          int v7 = (void *)*((void *)this + 8);
          if (v7)
          {
            uprv_free(v7);
            *((void *)this + 8) = 0LL;
            *((_DWORD *)this + 18) = 0;
          }
        }
      }
    }

    else
    {
      icu::UnicodeSet::remove(this, SingleCP, SingleCP);
    }
  }

  return this;
}

void icu::UnicodeSet::exclusiveOr(icu::UnicodeSet *this, int *a2, int a3, unsigned __int8 a4)
{
  if (*((void *)this + 5)
    || *((void *)this + 11)
    || (*((_BYTE *)this + 32) & 1) != 0
    || !icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    return;
  }

  int v7 = (int *)*((void *)this + 2);
  int v8 = *v7;
  int v9 = *a2;
  if (!v9)
  {
    int v9 = a2[1];
LABEL_9:
    int v10 = 1;
    goto LABEL_10;
  }

  int v10 = 0;
  int v9 = 0;
LABEL_10:
  int v11 = 0;
  uint64_t v12 = 1LL;
LABEL_11:
  uint64_t v13 = 0LL;
  for (i = &a2[v10]; ; int v9 = i[v13++])
  {
    if (v8 < v9)
    {
      *(_DWORD *)(*((void *)this + 6) + 4LL * v11 + 4 * v13) = v8;
      v10 += v13;
      v11 += v13 + 1;
LABEL_18:
      int v8 = v7[v12++];
      goto LABEL_11;
    }

    if (v9 >= v8) {
      break;
    }
    *(_DWORD *)(*((void *)this + 6) + 4LL * v11 + 4 * v13) = v9;
  }

  if (v8 != 1114112)
  {
    v11 += v13;
    v10 += v13 + 1;
    int v9 = i[v13];
    goto LABEL_18;
  }

  uint64_t v15 = *((void *)this + 6);
  *(_DWORD *)(v15 + 4LL * v11 + 4 * v13) = 1114112;
  *((void *)this + 2) = v15;
  *((void *)this + 6) = v7;
  int v16 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 7) = v11 + v13 + 1;
  *((_DWORD *)this + 14) = v16;
  int v17 = (void *)*((void *)this + 8);
  if (v17)
  {
    uprv_free(v17);
    *((void *)this + 8) = 0LL;
    *((_DWORD *)this + 18) = 0;
  }

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::complement(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    unsigned int v2 = (_DWORD *)*((void *)this + 2);
    if (*v2)
    {
      memmove((void *)(*((void *)this + 2) + 4LL), *((const void **)this + 2), 4LL * *((int *)this + 7));
      **((_DWORD **)this + 2) = 0;
      int v3 = 1;
    }

    else
    {
      memmove(v2, v2 + 1, 4LL * *((int *)this + 7) - 4);
      int v3 = -1;
    }

    *((_DWORD *)this + 7) += v3;
    int v4 = (void *)*((void *)this + 8);
    if (v4)
    {
      uprv_free(v4);
      *((void *)this + 8) = 0LL;
      *((_DWORD *)this + 18) = 0;
    }
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      int v5 = (icu::UVector *)*((void *)this + 10);
      else {
        icu::UVector::removeElement(*((icu::UVector **)this + 10), (uint64_t)a2);
      }
      __int128 v6 = (void *)*((void *)this + 8);
      if (v6)
      {
        uprv_free(v6);
        *((void *)this + 8) = 0LL;
        *((_DWORD *)this + 18) = 0;
      }
    }

    else
    {
      icu::UnicodeSet::complement(this, SingleCP, SingleCP);
    }
  }

  return this;
}

uint64_t icu::UnicodeSet::getString(icu::UVector **this, unsigned int a2)
{
  return icu::UVector::elementAt(this[10], a2);
}

icu::UnicodeSet *icu::UnicodeSet::compact(icu::UnicodeSet *this)
{
  if (*((void *)this + 5) || *((void *)this + 11) || (*((_BYTE *)this + 32) & 1) != 0) {
    return this;
  }
  unsigned int v2 = (char *)*((void *)this + 6);
  int v3 = (char *)this + 96;
  if (v2 != (char *)this + 96)
  {
    uprv_free(v2);
    *((void *)this + 6) = 0LL;
    *((_DWORD *)this + 14) = 0;
  }

  int v4 = (char *)*((void *)this + 2);
  if (v4 != v3)
  {
    uint64_t v5 = *((int *)this + 7);
    if ((int)v5 <= 25)
    {
      memcpy((char *)this + 96, *((const void **)this + 2), 4 * v5);
      uprv_free(v4);
      *((void *)this + 2) = v3;
      int v6 = 25;
LABEL_12:
      *((_DWORD *)this + 6) = v6;
      goto LABEL_13;
    }

    if ((int)v5 + 7 < *((_DWORD *)this + 6))
    {
      int v7 = uprv_realloc(*((void **)this + 2), 4LL * *((unsigned int *)this + 7));
      if (v7)
      {
        *((void *)this + 2) = v7;
        int v6 = *((_DWORD *)this + 7);
        goto LABEL_12;
      }
    }
  }

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet( icu::UnicodeSet *this, unsigned __int16 *a2, int a3, int a4, int *a5)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  if (*a5 < 1)
  {
    if (a3 < 1 || !a2 || a4)
    {
      *a5 = 1;
      icu::UnicodeSet::clear(this);
      *((_BYTE *)this + 32) = 1;
    }

    else
    {
      int v7 = (__int16)*a2;
      if (v7 >= 0) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = 2;
      }
      LODWORD(v9) = *a2;
      if (v7 < 0) {
        LODWORD(v9) = a2[1];
      }
      int v10 = *a2 & 0x7FFF;
      int v11 = v10 - v9;
      else {
        int v12 = v11 + 1;
      }
      int v13 = v9 + (v12 >> 1);
      if (icu::UnicodeSet::ensureCapacity(this, v13 + 1))
      {
        uint64_t v14 = *((void *)this + 2);
        if ((_DWORD)v9)
        {
          uint64_t v15 = v9;
          int v16 = (_DWORD *)*((void *)this + 2);
          int v17 = (__int16 *)&a2[v8];
          do
          {
            int v18 = (unsigned __int16)*v17++;
            *v16++ = v18;
            --v15;
          }

          while (v15);
        }

        if (v11 >= 2)
        {
          uint64_t v9 = v9;
          uint64_t v19 = (__int16 *)&a2[v8 + 1 + v9];
          do
          {
            int v20 = (unsigned __int16)*(v19 - 1);
            int v21 = (unsigned __int16)*v19;
            v19 += 2;
            *(_DWORD *)(v14 + 4 * v9++) = v21 | (v20 << 16);
          }

          while (v9 < v13);
        }

        if (!(_DWORD)v9 || *(_DWORD *)(v14 + 4LL * ((int)v9 - 1)) != 1114112)
        {
          *(_DWORD *)(v14 + 4LL * v9) = 1114112;
          LODWORD(v9) = v9 + 1;
        }

        *((_DWORD *)this + 7) = v9;
      }
    }
  }

  else
  {
    icu::UnicodeSet::clear(this);
    *((_BYTE *)this + 32) = 1;
  }

  return this;
}

uint64_t icu::UnicodeSet::serialize(icu::UnicodeSet *this, unsigned __int16 *a2, int a3, UErrorCode *a4)
{
  if (a3 < 0 || !a2 && a3)
  {
    uint64_t result = 0LL;
    UErrorCode v5 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_7:
    *a4 = v5;
    return result;
  }

  int v6 = *((_DWORD *)this + 7);
  uint64_t v7 = (v6 - 1);
  if (v6 == 1)
  {
    if (a3) {
      *a2 = 0;
    }
    else {
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    }
    return 1LL;
  }

  else
  {
    unsigned int v8 = (int *)*((void *)this + 2);
    if (v8[v6 - 2] >= 0x10000)
    {
      if (*v8 < 0x10000)
      {
        if (v6 < 2)
        {
          LODWORD(v10) = 0;
        }

        else
        {
          uint64_t v10 = 0LL;
          while (v8[v10] < 0x10000)
          {
            if (v7 == ++v10)
            {
              LODWORD(v10) = v6 - 1;
              break;
            }
          }
        }

        int v9 = v10 + 2 * (v7 - v10);
        LODWORD(v7) = v10;
      }

      else
      {
        int v9 = 2 * v7;
        LODWORD(v7) = 0;
      }
    }

    else
    {
      int v9 = v6 - 1;
    }

    if (v9 >= 0x8000)
    {
      uint64_t result = 0LL;
      UErrorCode v5 = U_INDEX_OUTOFBOUNDS_ERROR;
      goto LABEL_7;
    }

    else {
      int v11 = 2;
    }
    uint64_t result = (v11 + v9);
    if ((int)result > a3)
    {
      UErrorCode v5 = U_BUFFER_OVERFLOW_ERROR;
      goto LABEL_7;
    }

    *a2 = v9;
    if (v9 > (int)v7)
    {
      *a2 = v9 | 0x8000;
      a2[1] = v7;
      ++a2;
    }

    int v12 = a2 + 1;
    if ((int)v7 < 1)
    {
      LODWORD(v7) = 0;
    }

    else
    {
      int v13 = v7;
      do
      {
        int v14 = *v8++;
        *v12++ = v14;
        --v13;
      }

      while (v13);
    }

    while ((int)v7 < v9)
    {
      int v15 = *v8++;
      HIDWORD(v16) = v15;
      LODWORD(v16) = v15;
      *(_DWORD *)int v12 = v16 >> 16;
      v12 += 2;
      LODWORD(v7) = v7 + 2;
    }
  }

  return result;
}

uint64_t icu::UnicodeSet::nextCapacity(icu::UnicodeSet *this)
{
  return (2 * (_DWORD)this);
}

uint64_t icu::UnicodeSet::ensureBufferCapacity(icu::UnicodeSet *this, int a2)
{
  if (a2 > 1114112) {
    int v2 = 1114113;
  }
  else {
    int v2 = a2;
  }
  if (v2 <= *((_DWORD *)this + 14)) {
    return 1LL;
  }
  else {
    int v4 = 2 * v2;
  }
  if (v2 <= 24) {
    int v5 = v2 + 25;
  }
  else {
    int v5 = v4;
  }
  int v6 = uprv_malloc(4LL * v5);
  if (v6)
  {
    uint64_t v7 = v6;
    unsigned int v8 = (char *)*((void *)this + 6);
    *((void *)this + 6) = v7;
    *((_DWORD *)this + 14) = v5;
    return 1LL;
  }

  icu::UnicodeSet::clear(this);
  uint64_t result = 0LL;
  *((_BYTE *)this + 32) = 1;
  return result;
}

uint64_t icu::UnicodeSet::swapBuffers(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 16);
  *(void *)(this + 16) = *(void *)(this + 48);
  *(void *)(this + 48) = v1;
  LODWORD(v1) = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 24) = *(_DWORD *)(this + 56);
  *(_DWORD *)(this + 56) = v1;
  return this;
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat( icu::ICU_Utility *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  int v4 = (__int16)v3;
  int v5 = v3 >> 5;
  if (v4 < 0) {
    int v5 = *((_DWORD *)a2 + 3);
  }
  if (v5 >= 1)
  {
    int v6 = (int)a3;
    unsigned int v8 = this;
    int v9 = 0;
    do
    {
      uint64_t v10 = (icu::UnicodeString *)icu::UnicodeString::char32At(a2, v9);
      unsigned int v11 = v10;
      this = icu::UnicodeSet::_appendToPat(v8, v10, v6);
      if (v11 < 0x10000) {
        int v12 = 1;
      }
      else {
        int v12 = 2;
      }
      v9 += v12;
      unsigned int v13 = *((unsigned __int16 *)a2 + 4);
      int v14 = (__int16)v13;
      int v15 = v13 >> 5;
      if (v14 < 0) {
        int v15 = *((_DWORD *)a2 + 3);
      }
    }

    while (v9 < v15);
  }

  return this;
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::UnicodeSet *this, icu::UnicodeString *a2, int a3)
{
  if (a3)
  {
  }

  else if (icu::ICU_Utility::shouldAlwaysBeEscaped(a2))
  {
    return icu::ICU_Utility::escape(this, a2);
  }

  if (((_DWORD)a2 - 36) <= 0x3A && ((1LL << (a2 - 36)) & 0x780000000400205LL) != 0
    || (_DWORD)a2 == 125
    || (_DWORD)a2 == 123)
  {
    __int16 v7 = 92;
    int v6 = &v7;
  }

  else
  {
    if (!icu::PatternProps::isWhiteSpace(a2)) {
      return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)this, a2);
    }
    __int16 v8 = 92;
    int v6 = &v8;
  }

  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)v6, 0, 1LL);
  return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)this, a2);
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat( icu::UnicodeSet *this, icu::UnicodeString *a2, icu::UnicodeString *a3, int a4)
{
  int v6 = (int)a2;
  uint64_t result = icu::UnicodeSet::_appendToPat(this, a2, a4);
  if (v6 != (_DWORD)a3)
  {
    if (v6 == 56319 || v6 + 1 != (_DWORD)a3)
    {
      __int16 v9 = 45;
      icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v9, 0, 1LL);
    }

    return icu::UnicodeSet::_appendToPat(this, a3, a4);
  }

  return result;
}

icu::UnicodeString *icu::UnicodeSet::_toPattern( icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v3 = (int)a3;
  if (!*((void *)this + 8)) {
    return (icu::UnicodeString *)icu::UnicodeSet::_generatePattern(this, a2, a3);
  }
  int v6 = *((_DWORD *)this + 18);
  if (v6 >= 1)
  {
    int v7 = 0;
    int v8 = 0;
    do
    {
      uint64_t v9 = *((void *)this + 8);
      uint64_t v10 = v8 + 1LL;
      unint64_t v11 = *(unsigned __int16 *)(v9 + 2LL * v8);
      if ((v11 & 0xFC00) != 0xD800 || (_DWORD)v10 == v6)
      {
        ++v8;
      }

      else
      {
        int v13 = *(unsigned __int16 *)(v9 + 2 * v10);
        BOOL v14 = (v13 & 0xFC00) == 56320;
        unsigned int v15 = v13 + ((_DWORD)v11 << 10) - 56613888;
        if (v14) {
          v8 += 2;
        }
        else {
          ++v8;
        }
        if (v14) {
          unint64_t v11 = v15;
        }
        else {
          unint64_t v11 = v11;
        }
      }

      if (v3)
      {
      }

      else if (icu::ICU_Utility::shouldAlwaysBeEscaped((icu::ICU_Utility *)v11))
      {
LABEL_18:
        if ((v7 & 0x80000001) == 1)
        {
          unsigned int v16 = *((unsigned __int16 *)a2 + 4);
          else {
            unsigned int v17 = v16 >> 5;
          }
          int v18 = v17 - 1;
          if ((v16 & 1) != 0 && v17 == 1)
          {
            icu::UnicodeString::unBogus((uint64_t)a2);
          }

          else if (v17 > v18)
          {
            if (v18 > 1023)
            {
              *((_WORD *)a2 + 4) = v16 | 0xFFE0;
              *((_DWORD *)a2 + 3) = v18;
            }

            else
            {
              *((_WORD *)a2 + 4) = *((_WORD *)a2 + 4) & 0x1F | (32 * v18);
            }
          }
        }

        icu::ICU_Utility::escape(a2, (icu::UnicodeString *)v11);
        int v7 = 0;
        goto LABEL_34;
      }

      icu::UnicodeString::append((uint64_t)a2, v11);
      if ((_DWORD)v11 == 92) {
        ++v7;
      }
      else {
        int v7 = 0;
      }
LABEL_34:
      int v6 = *((_DWORD *)this + 18);
    }

    while (v8 < v6);
  }

  return a2;
}

uint64_t icu::UnicodeSet::_generatePattern( icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  __int16 v30 = 91;
  icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v30, 0, 1LL);
  int v6 = *((_DWORD *)this + 7);
  signed int v7 = v6 & 0xFFFFFFFE;
  if (v6 >= 4 && (v7 == v6 ? (BOOL v8 = **((_DWORD **)this + 2) == 0) : (BOOL v8 = 0), v8))
  {
    uint64_t v28 = *((void *)this + 10);
    if (v28 && *(_DWORD *)(v28 + 8))
    {
      LODWORD(v9) = 0;
      signed int v7 = *((_DWORD *)this + 7);
    }

    else
    {
      __int16 v31 = 94;
      LODWORD(v9) = 1;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v31, 0, 1LL);
      signed int v7 = v6 - 1;
    }
  }

  else
  {
    LODWORD(v9) = 0;
  }

  if ((int)v9 < v7)
  {
    uint64_t v10 = v7;
    signed int v29 = v7;
    do
    {
      uint64_t v11 = *((void *)this + 2);
      uint64_t v12 = (int)v9;
      int v13 = *(_DWORD *)(v11 + 4LL * (int)v9 + 4);
      if ((v13 - 55297) > 0x3FF)
      {
        icu::UnicodeSet::_appendToPat( a2,  (icu::UnicodeString *)*(unsigned int *)(v11 + 4LL * (int)v9),  (icu::UnicodeString *)(v13 - 1),  (int)a3);
        signed int v7 = v29;
        LODWORD(v9) = v9 + 2;
      }

      else
      {
        uint64_t v14 = (int)v9 + 2;
        uint64_t v15 = (uint64_t)(int)v9 << 32;
        uint64_t v16 = (int)v9 + 2LL;
        do
        {
          uint64_t v17 = v14;
          uint64_t v18 = v15;
          if (v16 >= v10) {
            break;
          }
          int v19 = *(_DWORD *)(v11 + 4 * v16);
          v14 += 2LL;
          v15 += 0x200000000LL;
          v16 += 2LL;
        }

        while (v19 < 56320);
        LODWORD(v9) = v17;
        if (v7 > (int)v17)
        {
          uint64_t v9 = v17;
          do
          {
            uint64_t v20 = *((void *)this + 2);
            int v21 = (icu::UnicodeString *)*(unsigned int *)(v20 + 4 * v9);
            icu::UnicodeSet::_appendToPat( a2,  v21,  (icu::UnicodeString *)(*(_DWORD *)(v20 + 4 * v9 + 4) - 1),  (int)a3);
            v9 += 2LL;
          }

          while (v9 < v10);
          signed int v7 = v29;
        }

        if ((int)v12 < (int)v17)
        {
          uint64_t v22 = v18 >> 32;
          do
          {
            icu::UnicodeSet::_appendToPat( a2,  (icu::UnicodeString *)*(unsigned int *)(*((void *)this + 2) + 4 * v12),  (icu::UnicodeString *)(*(_DWORD *)(*((void *)this + 2) + 4 * v12 + 4) - 1),  (int)a3);
            BOOL v23 = v12 < v22;
            v12 += 2LL;
          }

          while (v23);
          signed int v7 = v29;
        }
      }
    }

    while ((int)v9 < v7);
  }

  uint64_t v24 = *((void *)this + 10);
  if (v24 && *(int *)(v24 + 8) >= 1)
  {
    signed int v25 = 0;
    do
    {
      __int16 v32 = 123;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v32, 0, 1LL);
      unsigned int v26 = (icu::UnicodeString *)icu::UVector::elementAt(*((icu::UVector **)this + 10), v25);
      icu::UnicodeSet::_appendToPat(a2, v26, a3);
      __int16 v33 = 125;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v33, 0, 1LL);
      ++v25;
    }

    while (v25 < *(_DWORD *)(*((void *)this + 10) + 8LL));
  }

  __int16 v34 = 93;
  return icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v34, 0, 1LL);
}

icu::UnicodeString *icu::UnicodeSet::toPattern( icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  unsigned int v6 = *((unsigned __int16 *)a2 + 4);
  if ((v6 & 1) != 0)
  {
    icu::UnicodeString::unBogus((uint64_t)a2);
  }

  else
  {
    if ((v6 & 0x8000u) == 0) {
      unsigned int v7 = v6 >> 5;
    }
    else {
      unsigned int v7 = *((_DWORD *)a2 + 3);
    }
    if (v7) {
      *((_WORD *)a2 + 4) &= 0x1Fu;
    }
  }

  return icu::UnicodeSet::_toPattern(this, a2, a3);
}

icu::UnicodeString *non-virtual thunk to'icu::UnicodeSet::toPattern( icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  return icu::UnicodeSet::toPattern((icu::UnicodeSet *)((char *)this - 8), a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::freeze(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((_BYTE *)this + 32) & 1) == 0)
  {
    icu::UnicodeSet::compact(this);
    uint64_t v3 = *((void *)this + 10);
    if (v3 && *(_DWORD *)(v3 + 8))
    {
      uint64_t v4 = icu::UMemory::operator new((icu::UMemory *)0x188, v2);
      if (!v4)
      {
        *((void *)this + 11) = 0LL;
        goto LABEL_14;
      }

      uint64_t v5 = sub_1808637CC(v4, this, *((void *)this + 10), 63LL);
      *((void *)this + 11) = v5;
      if (!*(_DWORD *)(v5 + 252))
      {
        unsigned int v6 = (void *)sub_18086391C();
        icu::UMemory::operator delete(v6);
        *((void *)this + 11) = 0LL;
LABEL_10:
        uint64_t v7 = icu::UMemory::operator new((icu::UMemory *)0x368, v2);
        if (v7)
        {
          *((void *)this + 5) = sub_1807BD848(v7, *((void *)this + 2), *((_DWORD *)this + 7));
          return this;
        }

        *((void *)this + 5) = 0LL;
LABEL_14:
        icu::UnicodeSet::clear(this);
        *((_BYTE *)this + 32) = 1;
      }
    }

    else if (!*((void *)this + 11))
    {
      goto LABEL_10;
    }
  }

  return this;
}

unint64_t icu::UnicodeSet::spanBack(icu::UnicodeSet *this, UChar *s, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0LL;
    }
    uint64_t v5 = u_strlen(s);
    if (!(_DWORD)v5) {
      return v5;
    }
  }

  else
  {
    BOOL v8 = (unsigned int *)*((void *)this + 5);
    if (v8) {
      return (unint64_t)(sub_1807BDDB4(v8, (uint64_t)s, (uint64_t)&s[a3], a4) - (void)s) >> 1;
    }
  }

  uint64_t v10 = *((void *)this + 11);
  if (!v10)
  {
    uint64_t v11 = *((void *)this + 10);
    if (v11 && *(_DWORD *)(v11 + 8))
    {
      uint64_t v29 = 0LL;
      if (a4) {
        uint64_t v12 = 26LL;
      }
      else {
        uint64_t v12 = 25LL;
      }
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v20 = 0u;
      memset(v19, 0, sizeof(v19));
      sub_1808637CC(v19, this, v11, v12);
      if (HIDWORD(v20))
      {
        uint64_t v5 = sub_1808641EC((uint64_t)v19, s, v5, a4);
        sub_18086391C(v19);
        return v5;
      }

      sub_18086391C(v19);
    }

    int v13 = a4 != 0;
    do
    {
      uint64_t v14 = (v5 - 1);
      int v15 = s[(int)v14];
      if ((int)v5 > 1 && (v15 & 0xFC00) == 0xDC00)
      {
        int v16 = s[(v5 - 2)];
        int v17 = v16 & 0xFC00;
        int v18 = v15 + (v16 << 10) - 56613888;
        if (v17 == 55296) {
          uint64_t v14 = (v5 - 2);
        }
        else {
          uint64_t v14 = v14;
        }
        if (v17 == 55296) {
          int v15 = v18;
        }
      }

      uint64_t v5 = v14;
    }

    while ((int)v14 >= 1);
    return v5;
  }

  return sub_1808641EC(v10, s, v5, a4);
}

uint64_t icu::UnicodeSet::spanUTF8(icu::UnicodeSet *this, char *__s, size_t a3, int a4)
{
  size_t v5 = a3;
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0LL;
    }
    size_t v5 = strlen(__s);
    if (!(_DWORD)v5) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v8 = *((void *)this + 5);
    if (v8) {
      return sub_1807BE004(v8, __s, a3, a4) - __s;
    }
  }

  uint64_t v11 = *((void *)this + 11);
  if (!v11)
  {
    uint64_t v12 = *((void *)this + 10);
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      uint64_t v33 = 0LL;
      if (a4) {
        uint64_t v13 = 38LL;
      }
      else {
        uint64_t v13 = 37LL;
      }
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      memset(v24, 0, sizeof(v24));
      sub_1808637CC(v24, this, v12, v13);
      if ((_DWORD)v25)
      {
        uint64_t v9 = sub_180864A30((uint64_t)v24, __s, v5, a4);
        sub_18086391C(v24);
        return v9;
      }

      sub_18086391C(v24);
    }

    uint64_t v9 = 0LL;
    int v14 = a4 != 0;
    while (1)
    {
      uint64_t v15 = (int)v9 + 1LL;
      int v16 = __s[(int)v9];
      unsigned int v17 = __s[(int)v9];
      if ((v16 & 0x80000000) == 0) {
        goto LABEL_42;
      }
      if ((_DWORD)v15 == (_DWORD)v5) {
        goto LABEL_21;
      }
      if (v17 < 0xE0) {
        break;
      }
      if (v17 <= 0xEF)
      {
        uint64_t v18 = v16 & 0xF;
        if (((a00000000000000[v18] >> (__s[v15] >> 5)) & 1) != 0)
        {
          unsigned int v19 = __s[v15] & 0x3F;
          goto LABEL_26;
        }

        goto LABEL_41;
      }

      if (v17 > 0xF4) {
        goto LABEL_41;
      }
      unint64_t v23 = __s[v15];
      uint64_t v15 = (int)v9 + 2LL;
      if ((_DWORD)v9 + 2 == (_DWORD)v5) {
        goto LABEL_21;
      }
      unsigned int v19 = __s[v15] ^ 0x80;
      if (v19 <= 0x3F)
      {
        LODWORD(v18) = v23 & 0x3F | ((v17 - 240) << 6);
LABEL_26:
        LODWORD(v15) = v15 + 1;
        if ((_DWORD)v15 != (_DWORD)v5)
        {
          int v20 = v19 | ((_DWORD)v18 << 6);
LABEL_30:
          unsigned int v21 = __s[(int)v15] ^ 0x80;
          int v22 = v21 | (v20 << 6);
          if (v21 <= 0x3F) {
            unsigned int v17 = v22;
          }
          else {
            unsigned int v17 = 65533;
          }
          if (v21 > 0x3F) {
            uint64_t v15 = v15;
          }
          else {
            uint64_t v15 = (v15 + 1);
          }
          goto LABEL_42;
        }

uint64_t icu::UnicodeSet::spanBackUTF8(icu::UnicodeSet *this, uint8_t *s, uint64_t a3, int a4)
{
  size_t v5 = a3;
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0LL;
    }
    size_t v5 = strlen((const char *)s);
    if ((_DWORD)v5) {
      goto LABEL_8;
    }
    return v5;
  }

  uint64_t v8 = *((void *)this + 5);
  if (v8) {
    return sub_1807BE314(v8, s, a3, a4);
  }
LABEL_8:
  uint64_t v10 = *((void *)this + 11);
  if (!v10)
  {
    uint64_t v11 = *((void *)this + 10);
    if (v11 && *(_DWORD *)(v11 + 8))
    {
      uint64_t v25 = 0LL;
      if (a4) {
        uint64_t v12 = 22LL;
      }
      else {
        uint64_t v12 = 21LL;
      }
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      memset(v16, 0, sizeof(v16));
      sub_1808637CC(v16, this, v11, v12);
      if ((_DWORD)v17)
      {
        size_t v5 = sub_18086515C((uint64_t)v16, s, v5, a4);
        sub_18086391C(v16);
        return v5;
      }

      sub_18086391C(v16);
    }

    int v13 = a4 != 0;
    do
    {
      p__int16 i = v5 - 1;
      UChar32 v14 = s[(int)v5 - 1];
      if ((v14 & 0x80) != 0) {
        UChar32 v14 = utf8_prevCharSafeBody(s, 0, &pi, v14, -3);
      }
      size_t v5 = pi;
    }

    while (pi > 0);
    return v5;
  }

  return sub_18086515C(v10, s, v5, a4);
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet( icu::UnicodeSet *this, const icu::UnicodeString *a2, unsigned int a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5);
}

{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern( icu::UnicodeSet *this, const icu::UnicodeString *a2, unsigned int a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  char v6 = a3;
  uint64_t v15 = off_18970F400;
  unint64_t v16 = 0xFFFFFFFF00000000LL;
  icu::UnicodeSet::applyPattern(this, a2, (icu::ParsePosition *)&v15, a3, a4, a5);
  if (*(int *)a5 <= 0)
  {
    int v9 = v16;
    int v14 = v16;
    if ((v6 & 1) != 0)
    {
      icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v14, (int *)1);
      int v9 = v14;
    }

    unsigned int v10 = *((unsigned __int16 *)a2 + 4);
    int v11 = (__int16)v10;
    unsigned int v12 = v10 >> 5;
    if (v11 < 0) {
      unsigned int v12 = *((_DWORD *)a2 + 3);
    }
    if (v9 != v12) {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v15);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet( icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, unsigned int a4, const icu::SymbolTable *a5, UErrorCode *a6)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5, a6);
}

{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5, a6);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern( icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, unsigned int a4, const icu::SymbolTable *a5, UErrorCode *a6)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    if (*((void *)this + 5) || *((void *)this + 11))
    {
      *a6 = U_NO_WRITE_PERMISSION;
    }

    else
    {
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      uint64_t v19 = 0LL;
      __int128 v18 = 0u;
      uint64_t v14 = 0LL;
      uint64_t v15 = off_18971B688;
      LOWORD(v16) = 2;
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      sub_180808814((uint64_t)&v12, (uint64_t)a2, (uint64_t)a5, (uint64_t)a3);
      icu::UnicodeSet::applyPattern( this,  (uint64_t *)&v12,  (uint64_t)a5,  (icu::UnicodeString *)&v15,  a4,  (void (*)(void *))icu::UnicodeSet::closeOver,  0LL,  0,  a6);
      uint64_t v11 = *(unsigned int *)a6;
      if ((int)v11 <= 0)
      {
        if (*((void *)&v13 + 1))
        {
          uint64_t v11 = 65538LL;
          *a6 = U_MALFORMED_SET;
        }

        else
        {
          sub_180860970((uint64_t)this, (uint64_t)&v15);
        }
      }

      icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)&v15);
    }
  }

  return this;
}

uint64_t icu::UnicodeSet::closeOver(uint64_t this, char a2)
{
  if (!*(void *)(this + 40) && !*(void *)(this + 88) && (*(_BYTE *)(this + 32) & 1) == 0) {
    __asm { BR              X10 }
  }

  return this;
}

UChar *sub_180860970(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  if ((v2 & 0x11) != 0)
  {
    uint64_t v3 = 0LL;
  }

  else if ((v2 & 2) != 0)
  {
    uint64_t v3 = (const UChar *)(a2 + 10);
  }

  else
  {
    uint64_t v3 = *(const UChar **)(a2 + 24);
  }

  int v4 = (__int16)v2;
  int32_t v5 = v2 >> 5;
  if (v4 >= 0) {
    int32_t v6 = v5;
  }
  else {
    int32_t v6 = *(_DWORD *)(a2 + 12);
  }
  return icu::UnicodeSet::setPattern(a1, v3, v6);
}

void icu::UnicodeSet::closeOverCaseInsensitive(icu::UnicodeSet *this, int a2)
{
  uint64_t v3 = this;
  uint64_t v66 = *MEMORY[0x1895F89C0];
  uint64_t v60 = 0LL;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  *(_OWORD *)unsigned int v53 = 0u;
  memset(v52, 0, sizeof(v52));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v52, this);
  if ((a2 & 1) == 0 && icu::UnicodeSet::hasStrings((icu::UnicodeSet *)v52)) {
    icu::UVector::removeAllElements((uint64_t)v53[0]);
  }
  v51[0] = v52;
  v51[1] = icu::UnicodeSet::add;
  v51[2] = icu::UnicodeSet::add;
  v51[3] = sub_180861260;
  _OWORD v51[4] = 0LL;
  v51[5] = 0LL;
  uint64_t v50 = 0LL;
  memset(v49, 0, sizeof(v49));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v49, 0, 0x10FFFFu);
  int v4 = sub_1808612EC(v3, (icu::UVector **)v49);
  int RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)v4);
  if (RangeCount >= 1)
  {
    int v6 = RangeCount;
    for (int i = 0; i != v6; ++i)
    {
      uint64_t RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)v4, i);
      int RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)v4, i);
      if ((a2 & 1) != 0)
      {
        if ((int)RangeStart <= RangeEnd)
        {
          int v10 = RangeEnd + 1;
          do
          {
            sub_180818394(RangeStart, v51);
            uint64_t RangeStart = (RangeStart + 1);
          }

          while (v10 != (_DWORD)RangeStart);
        }
      }

      else if ((int)RangeStart <= RangeEnd)
      {
        int v11 = RangeEnd + 1;
        do
        {
          sub_18081809C(RangeStart, v51);
          uint64_t RangeStart = (RangeStart + 1);
        }

        while (v11 != (_DWORD)RangeStart);
      }
    }
  }

  if (icu::UnicodeSet::hasStrings(v3))
  {
    int v48 = a2;
    __int128 v62 = 0u;
    uint64_t v65 = 0LL;
    __int128 v64 = 0u;
    __int128 v63 = 0u;
    uint64_t v61 = (UChar *)off_18971B688;
    LOWORD(v62) = 2;
    __int128 v12 = (unsigned int *)*((void *)v3 + 10);
    __int128 v13 = (void *)v12[2];
    if ((int)v13 >= 1)
    {
      signed int v14 = 0;
      uint64_t v47 = (unsigned int **)v3;
      do
      {
        uint64_t v15 = icu::UVector::elementAt((icu::UVector *)v12, v14);
        __int128 v16 = (const icu::UnicodeString *)v15;
        if (v48)
        {
          unsigned int v17 = *(unsigned __int16 *)(v15 + 8);
          if ((v17 & 0x11) != 0)
          {
            uint64_t v18 = 0LL;
          }

          else if ((v17 & 2) != 0)
          {
            uint64_t v18 = v15 + 10;
          }

          else
          {
            uint64_t v18 = *(void *)(v15 + 24);
          }

          int v23 = (__int16)v17;
          int v24 = v17 >> 5;
          if (v23 >= 0) {
            int v25 = v24;
          }
          else {
            int v25 = *(_DWORD *)(v15 + 12);
          }
          if (v25 < 1) {
            goto LABEL_75;
          }
          int v26 = 0;
          while (1)
          {
            uint64_t v27 = v26 + 1LL;
            unsigned int v28 = *(unsigned __int16 *)(v18 + 2LL * v26);
            if ((v28 & 0xFC00) != 0xD800 || (_DWORD)v27 == v25)
            {
              ++v26;
            }

            else
            {
              int v30 = *(unsigned __int16 *)(v18 + 2 * v27);
              BOOL v31 = (v30 & 0xFC00) == 56320;
              unsigned int v32 = (v28 << 10) - 56613888 + v30;
              if (v31) {
                v26 += 2;
              }
              else {
                ++v26;
              }
              if (v31) {
                unsigned int v28 = v32;
              }
            }

            UChar32 v33 = u_foldCase(v28, 0);
            if (v33 != v28) {
              break;
            }
            if (v26 >= v25) {
              goto LABEL_75;
            }
          }

          unsigned int v34 = v33;
          if (v28 >= 0x10000) {
            int v35 = -2;
          }
          else {
            int v35 = -1;
          }
          uint64_t v36 = (v35 + v26);
          icu::UnicodeString::unBogus((uint64_t)&v61);
          if ((v62 & 0x8000u) == 0LL) {
            uint64_t v37 = (unsigned __int16)v62 >> 5;
          }
          else {
            uint64_t v37 = DWORD1(v62);
          }
          icu::UnicodeString::doReplace((uint64_t)&v61, 0LL, v37, v18, 0, v36);
          icu::UnicodeString::append((uint64_t)&v61, v34);
          if (v26 != v25)
          {
            int v38 = v26;
            do
            {
              uint64_t v39 = v38 + 1LL;
              UChar32 v40 = *(unsigned __int16 *)(v18 + 2LL * v38);
              if ((v40 & 0xFC00) == 0xD800 && (_DWORD)v39 != v25)
              {
                int v42 = *(unsigned __int16 *)(v18 + 2 * v39);
                BOOL v43 = (v42 & 0xFC00) == 56320;
                int v44 = v38 + 2;
                UChar32 v45 = (v40 << 10) - 56613888 + v42;
                if (v43) {
                  LODWORD(v39) = v44;
                }
                if (v43) {
                  UChar32 v40 = v45;
                }
              }

              UChar32 v46 = u_foldCase(v40, 0);
              icu::UnicodeString::append((uint64_t)&v61, v46);
              int v38 = v39;
            }

            while ((_DWORD)v39 != v25);
          }

          __int128 v22 = icu::UnicodeSet::remove((icu::UnicodeSet *)v52, v16);
        }

        else
        {
          icu::UnicodeString::operator=(&v61, (UChar **)v15);
          icu::UnicodeString::foldCase((const UChar **)&v61, 0LL);
          uint64_t v19 = (unsigned __int16 *)v63;
          if ((v62 & 2) != 0) {
            uint64_t v19 = (unsigned __int16 *)&v62 + 1;
          }
          if ((v62 & 0x11) != 0) {
            uint64_t v20 = 0LL;
          }
          else {
            uint64_t v20 = v19;
          }
          if ((v62 & 0x8000u) == 0LL) {
            int v21 = (unsigned __int16)v62 >> 5;
          }
          else {
            int v21 = DWORD1(v62);
          }
          __int128 v22 = (icu::UnicodeSet *)v52;
        }

        icu::UnicodeSet::add(v22, (const icu::UnicodeString *)&v61);
LABEL_75:
        ++v14;
        uint64_t v3 = (icu::UnicodeSet *)v47;
        __int128 v12 = v47[10];
        __int128 v13 = (void *)v12[2];
      }

      while (v14 < (int)v13);
    }

    icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)&v61);
  }

  icu::UnicodeSet::operator=(v3, (const icu::UnicodeSet *)v52);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v49);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v52);
}

void icu::UnicodeSet::closeOverAddCaseMappings(icu::UVector **this)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v29 = 0LL;
  memset(v28, 0, sizeof(v28));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v28, (const icu::UnicodeSet *)this);
  uint64_t v27 = 0LL;
  memset(v26, 0, sizeof(v26));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v26, 0, 0x10FFFFu);
  unsigned int v2 = sub_1808612EC((icu::UnicodeSet *)this, (icu::UVector **)v26);
  int RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)v2);
  uint64_t v25 = 0LL;
  __int128 v32 = 0u;
  uint64_t v35 = 0LL;
  __int128 v34 = 0u;
  __int128 v33 = 0u;
  BOOL v31 = (UChar *)off_18971B688;
  LOWORD(v32) = 2;
  if (RangeCount >= 1)
  {
    int v4 = RangeCount;
    for (int i = 0; i != v4; ++i)
    {
      signed int RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)v2, i);
      signed int RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)v2, i);
      if (RangeStart <= RangeEnd)
      {
        int v8 = RangeEnd + 1;
        do
        {
          unsigned int v9 = ucase_toFullLower(RangeStart, 0LL, 0LL, &v25, 1);
          if ((v9 & 0x80000000) == 0)
          {
            if (v9 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v9);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }

            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v9);
            }
          }

          unsigned int v10 = ucase_toFullTitle(RangeStart, 0LL, 0LL, &v25, 1);
          if ((v10 & 0x80000000) == 0)
          {
            if (v10 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v10);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }

            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v10);
            }
          }

          unsigned int v11 = ucase_toFullUpper(RangeStart, 0LL, 0LL, &v25, 1);
          if ((v11 & 0x80000000) == 0)
          {
            if (v11 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v11);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }

            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v11);
            }
          }

          unsigned int v12 = ucase_toFullFolding(RangeStart, &v25, 0);
          if ((v12 & 0x80000000) == 0)
          {
            if (v12 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v12);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }

            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v12);
            }
          }

          ++RangeStart;
        }

        while (v8 != RangeStart);
      }
    }
  }

  if (icu::UnicodeSet::hasStrings((icu::UnicodeSet *)this))
  {
    memset(v30, 0, sizeof(v30));
    icu::Locale::Locale((icu::Locale *)v30, "", 0LL, 0LL, 0LL);
    int v24 = 0;
    WordInstance = icu::BreakIterator::createWordInstance((char **)v30, (const icu::Locale *)&v24, v13, v14);
    if (v24 <= 0)
    {
      __int128 v16 = this[10];
      if (*((int *)v16 + 2) >= 1)
      {
        signed int v17 = 0;
        do
        {
          uint64_t v18 = (UChar **)icu::UVector::elementAt(v16, v17);
          uint64_t v19 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toLower(v19, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          uint64_t v20 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toTitle(v20, (icu::BreakIterator *)WordInstance, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          int v21 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toUpper(v21, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          __int128 v22 = (const UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::foldCase(v22, 0LL);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          ++v17;
          __int128 v16 = this[10];
        }

        while (v17 < *((_DWORD *)v16 + 2));
      }
    }

    if (WordInstance) {
      (*(void (**)(char *))(*(void *)WordInstance + 8LL))(WordInstance);
    }
    icu::Locale::~Locale((icu::Locale *)v30);
  }

  icu::UnicodeSet::operator=((icu::UnicodeSet *)this, (const icu::UnicodeSet *)v28);
  icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)&v31);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v26);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v28);
}

void *sub_180861260(icu::UnicodeSet *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 >> 31, &v6);
  icu::UnicodeSet::add(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

icu::UVector **sub_1808612EC(icu::UnicodeSet *a1, icu::UVector **a2)
{
  uint64_t v3 = a1;
  if ((int)icu::UnicodeSet::size(a1) >= 30)
  {
    int v10 = 0;
    int v4 = sub_1807C3FA8(34LL, (UErrorCode *)&v10);
    if (v10 <= 0)
    {
      int32_t v5 = v4;
      int RangeCount = icu::UnicodeSet::getRangeCount(v3);
      int v7 = icu::UnicodeSet::getRangeCount(v5);
      if (RangeCount <= v7) {
        uint64_t v8 = v3;
      }
      else {
        uint64_t v8 = v5;
      }
      if (RangeCount <= v7) {
        uint64_t v3 = v5;
      }
      icu::UnicodeSet::retainAll(a2, v8);
      icu::UnicodeSet::retainAll(a2, v3);
      return a2;
    }
  }

  return (icu::UVector **)v3;
}

uint64_t sub_180861384(UErrorCode *a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (*(int *)a1 <= 0)
  {
    unsigned int v2 = atomic_load(&dword_18C5350A8);
    if (v2 != 2 && icu::umtx_initImplPreInit(&dword_18C5350A8))
    {
      uint64_t v4 = icu::UMemory::operator new((icu::UMemory *)0xC8, v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v8 = "[";
        icu::UnicodeString::UnicodeString(v9, 1LL, &v8);
        *(void *)uint64_t v5 = off_18971B4D0;
        *(void *)(v5 + 8) = &unk_18971B5E8;
        *(void *)(v5 + 16) = v5 + 96;
        *(void *)(v5 + 24) = 0x100000019LL;
        *(_BYTE *)(v5 + 32) = 0;
        *(void *)(v5 + 64) = 0LL;
        *(_DWORD *)(v5 + 72) = 0;
        *(void *)(v5 + 40) = 0LL;
        *(void *)(v5 + 48) = 0LL;
        *(_DWORD *)(v5 + 56) = 0;
        *(void *)(v5 + 80) = 0LL;
        *(void *)(v5 + 88) = 0LL;
        icu::UnicodeSet::applyPattern((icu::UnicodeSet *)v5, (const icu::UnicodeString *)v9, a1);
        qword_18C5350A0 = v5;
        icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)v9);
        if (qword_18C5350A0)
        {
          icu::UnicodeSet::freeze((icu::UnicodeSet *)qword_18C5350A0);
LABEL_11:
          sub_180820C94(0x12u, (uint64_t)sub_18086319C);
          dword_18C5350AC = *a1;
          icu::umtx_initImplPostInit(&dword_18C5350A8);
          return qword_18C5350A0;
        }
      }

      else
      {
        qword_18C5350A0 = 0LL;
      }

      *a1 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_11;
    }

    if (dword_18C5350AC >= 1) {
      *a1 = dword_18C5350AC;
    }
  }

  return qword_18C5350A0;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet( icu::UnicodeSet *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::applyPattern(this, a2, a3);
}

{
  *(void *)this = off_18971B4D0;
  *((void *)this + 1) = &unk_18971B5E8;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019LL;
  *((_BYTE *)this + 32) = 0;
  *((void *)this + 8) = 0LL;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0LL;
  *((void *)this + 11) = 0LL;
  return icu::UnicodeSet::applyPattern(this, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern( icu::UnicodeSet *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  unsigned int v11 = off_18970F400;
  unint64_t v12 = 0xFFFFFFFF00000000LL;
  icu::UnicodeSet::applyPatternIgnoreSpace(this, a2, (icu::ParsePosition *)&v11, 0LL, a3);
  if (*(int *)a3 <= 0)
  {
    int v10 = v12;
    icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v10, (int *)1);
    unsigned int v6 = *((unsigned __int16 *)a2 + 4);
    int v7 = (__int16)v6;
    unsigned int v8 = v6 >> 5;
    if (v7 < 0) {
      unsigned int v8 = *((_DWORD *)a2 + 3);
    }
    if (v10 != v8) {
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v11);
  return this;
}

void icu::UnicodeSet::applyPatternIgnoreSpace( icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 5) || *((void *)this + 11))
    {
      *a5 = U_NO_WRITE_PERMISSION;
    }

    else
    {
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      uint64_t v15 = 0LL;
      __int128 v14 = 0u;
      uint64_t v10 = 0LL;
      unsigned int v11 = off_18971B688;
      LOWORD(v12) = 2;
      __int128 v8 = 0u;
      __int128 v9 = 0u;
      sub_180808814((uint64_t)&v8, (uint64_t)a2, (uint64_t)a4, (uint64_t)a3);
      icu::UnicodeSet::applyPattern(this, (uint64_t *)&v8, (uint64_t)a4, (icu::UnicodeString *)&v11, 1u, 0LL, 0LL, 0, a5);
      if (*(int *)a5 <= 0)
      {
        if (*((void *)&v9 + 1)) {
          *a5 = U_MALFORMED_SET;
        }
        else {
          sub_180860970((uint64_t)this, (uint64_t)&v11);
        }
      }

      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v11);
    }
  }

void icu::UnicodeSet::applyPattern( icu::UnicodeSet *a1, uint64_t *a2, uint64_t a3, icu::UnicodeString *a4, unsigned int a5, void (*a6)(void *), uint64_t a7, int a8, UErrorCode *a9)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (a8 >= 101)
  {
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return;
  }

  __int128 v54 = 0u;
  if ((a5 & 1) != 0) {
    char v12 = 7;
  }
  else {
    char v12 = 3;
  }
  uint64_t v57 = 0LL;
  __int128 v56 = 0uLL;
  __int128 v55 = 0uLL;
  unsigned int v53 = off_18971B688;
  LOWORD(v54) = 2;
  __int128 v49 = 0uLL;
  uint64_t v52 = 0LL;
  __int128 v51 = 0uLL;
  __int128 v50 = 0uLL;
  int v48 = off_18971B688;
  LOWORD(v49) = 2;
  v46[0] = 0LL;
  v46[1] = 0LL;
  icu::UnicodeSet::clear(a1);
  int v13 = 0;
  int v14 = 0;
  unsigned int v43 = 0;
  int v15 = 0;
  char v16 = 0;
  int v44 = 0LL;
  int v37 = 0;
  unsigned int v38 = a8 + 1;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        if (sub_180808824(a2)) {
          goto LABEL_134;
        }
        char v45 = 0;
        uint64_t v18 = 0LL;
        int v19 = 2;
LABEL_11:
        if (v16 == 1)
        {
          if (v14) {
            goto LABEL_123;
          }
          icu::UnicodeSet::add(a1, v43, v43);
          icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
        }

        else if (v14 == 45 || v14 == 38)
        {
          __int16 v47 = v14;
          icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1LL);
        }

        if (!v18)
        {
          uint64_t v18 = v44;
          if (!v44)
          {
            uint64_t v20 = (icu::UnicodeSet *)icu::UMemory::operator new((icu::UMemory *)0xC8, v17);
            if (!v20) {
              goto LABEL_117;
            }
            icu::UnicodeSet::UnicodeSet(v20);
            int v44 = v21;
            uint64_t v18 = v21;
          }
        }

        if (v19 == 3)
        {
          icu::UnicodeSet::_toPattern(v18, (icu::UnicodeString *)&v53, 0LL);
        }

        else if (v19 == 2)
        {
          sub_180808C00((BOOL)a2, v12);
          icu::UnicodeSet::applyPropertyPattern(v18, a2, (uint64_t)&v53, a9);
        }

        else
        {
          icu::UnicodeSet::applyPattern(v18, a2, a3, &v53, a5, a6, a7, v38, a9);
        }

        if (!v15)
        {
          icu::UnicodeSet::operator=(a1, v18);
          int v13 = 1;
          goto LABEL_103;
        }

        if (v14)
        {
          if (v14 == 38) {
            icu::UnicodeSet::retainAll((icu::UVector **)a1, v18);
          }
          else {
            icu::UnicodeSet::removeAll((icu::UVector **)a1, v18);
          }
          int v14 = 0;
        }

        else
        {
          icu::UnicodeSet::addAll((icu::UVector **)a1, v18);
        }

        int v13 = 1;
LABEL_39:
        char v16 = 2;
      }

      sub_180808BC8((uint64_t)a2, (uint64_t)v46);
      uint64_t v22 = sub_180808860((uint64_t)a2, v12, &v45, (int *)a9);
      uint64_t v23 = v22;
      if ((_DWORD)v22 != 91 || v45) {
        break;
      }
      if (v15 == 1)
      {
        sub_180808BE4((uint64_t)a2, (uint64_t)v46);
        uint64_t v18 = 0LL;
        int v19 = 1;
        goto LABEL_11;
      }

      __int16 v47 = 91;
      icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1LL);
      sub_180808BC8((uint64_t)a2, (uint64_t)v46);
      int v25 = sub_180808860((uint64_t)a2, v12, &v45, (int *)a9);
      if (v25 == 94 && !v45)
      {
        __int16 v47 = 94;
        int v37 = 1;
        icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1LL);
        sub_180808BC8((uint64_t)a2, (uint64_t)v46);
        int v25 = sub_180808860((uint64_t)a2, v12, &v45, (int *)a9);
      }

      if (v25 == 45)
      {
        int v15 = 1;
        char v45 = 1;
        uint64_t v23 = 45LL;
        goto LABEL_59;
      }

      sub_180808BE4((uint64_t)a2, (uint64_t)v46);
      int v15 = 1;
    }

    if (a3)
    {
      int v24 = (void (***)(icu::UnicodeSet *__hidden))(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24LL))( a3,  v22);
      if (v24)
      {
        uint64_t v18 = (icu::UnicodeSet *)v24;
        if (*v24 != off_18971B4D0) {
          goto LABEL_123;
        }
        int v19 = 3;
        goto LABEL_11;
      }
    }

    if (!v15) {
      goto LABEL_123;
    }
    if (v45) {
      goto LABEL_59;
    }
    if ((int)v23 > 93)
    {
      if ((_DWORD)v23 == 123)
      {
        if (!v14)
        {
          if (v16 == 1)
          {
            icu::UnicodeSet::add(a1, v43, v43);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
          }

          sub_1808623BC((uint64_t)&v48, 0);
          while (!sub_180808824(a2))
          {
            unsigned int v27 = sub_180808860((uint64_t)a2, v12, &v45, (int *)a9);
            if (v27 == 125 && !v45)
            {
              icu::UnicodeSet::add(a1, (const icu::UnicodeString *)&v48);
              __int16 v47 = 123;
              icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1LL);
              icu::UnicodeSet::_appendToPat((icu::ICU_Utility *)&v53, (icu::UnicodeString *)&v48, 0LL);
              __int16 v47 = 125;
              icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1LL);
              goto LABEL_69;
            }

            icu::UnicodeString::append((uint64_t)&v48, v27);
          }
        }

LABEL_123:
        int v26 = 65538;
        goto LABEL_124;
      }

      if ((_DWORD)v23 == 94) {
        goto LABEL_123;
      }
LABEL_59:
      switch(v16)
      {
        case 2:
          if (v14) {
            goto LABEL_123;
          }
LABEL_65:
          char v16 = 1;
          goto LABEL_76;
        case 1:
          if (v14 == 45)
          {
            icu::UnicodeSet::add(a1, v43, v23);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
            __int16 v47 = 45;
            icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&v47, 0, 1LL);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v23, 0);
LABEL_69:
            char v16 = 0;
            int v14 = 0;
          }

          else
          {
            icu::UnicodeSet::add(a1, v43, v43);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
LABEL_76:
            unsigned int v43 = v23;
          }

          break;
        case 0:
          goto LABEL_65;
      }
    }

    else
    {
      if ((_DWORD)v23 != 45)
      {
        if ((_DWORD)v23 == 93)
        {
          if (v16 == 1)
          {
            icu::UnicodeSet::add(a1, v43, v43);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v53, (icu::UnicodeString *)v43, 0);
          }

          if (v14 != 38)
          {
            if (v14 == 45)
            {
              icu::UnicodeSet::add(a1, 0x2Du, 0x2Du);
              __int16 v47 = 45;
              goto LABEL_132;
            }

            goto LABEL_133;
          }

          goto LABEL_123;
        }

        goto LABEL_59;
      }

      if (v14) {
        goto LABEL_123;
      }
      if (!v16)
      {
        icu::UnicodeSet::add(a1, 0x2Du, 0x2Du);
        int v35 = sub_180808860((uint64_t)a2, v12, &v45, (int *)a9);
        int v26 = 65538;
        if (v35 == 93 && !v45)
        {
          icu::UnicodeString::doAppend((uint64_t)&v53, (uint64_t)&unk_180A47C4E, 0, 2LL);
          goto LABEL_103;
        }

LABEL_135:
  uint64_t v20 = v44;
LABEL_136:
  if (v20)
  {
    icu::UnicodeSet::~UnicodeSet(v20);
    icu::UMemory::operator delete(v34);
  }

  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v48);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v53);
}

                icu::UnicodeString::operator=((UChar **)(v8 + 672), a2);
                return (icu::RuleBasedNumberFormat *)icu::UnicodeString::~UnicodeString( (void *)v67,  (icu::UnicodeString *)&v79);
              }
            }

            else
            {
              __int128 v55 = v54;
              __int128 v56 = 0LL;
              uint64_t v57 = 0LL;
              uint64_t v58 = 0;
              while (1)
              {
                __int128 v59 = v58;
                uint64_t v60 = *(void *)(v8 + 368) + v56;
                icu::UnicodeString::unBogus(v60);
                else {
                  uint64_t v61 = *(unsigned __int16 *)(v60 + 8) >> 5;
                }
                uint64_t v58 = v55 + 1;
                icu::UnicodeString::doReplace( (icu::UnicodeString *)v60,  0LL,  v61,  (const icu::UnicodeString *)&v79,  v59,  (v55 + 1 - v59));
                __int128 v64 = icu::UMemory::operator new(v63, (icu::UMemory *)0xA8, v62);
                if (v64) {
                  __int128 v64 = (uint64_t *)sub_180913D3C((uint64_t)v64, v8, *(void *)(v8 + 368), v57, (int *)a5);
                }
                *(void *)(*(void *)(v8 + 360) + 8 * v57) = v64;
                if (!*(void *)(*(void *)(v8 + 360) + 8 * v57)) {
                  break;
                }
                if (v55 >= -1)
                {
                  if ((WORD4(v79) & 0x8000) != 0)
                  {
                    uint64_t v66 = HIDWORD(v79);
                    if (SHIDWORD(v79) >= v58) {
                      uint64_t v65 = v55 + 1;
                    }
                    else {
                      uint64_t v65 = HIDWORD(v79);
                    }
                  }

                  else
                  {
                    uint64_t v66 = WORD4(v79) >> 5;
                    if (v66 >= v58) {
                      uint64_t v65 = v55 + 1;
                    }
                    else {
                      uint64_t v65 = WORD4(v79) >> 5;
                    }
                  }
                }

                else
                {
                  uint64_t v65 = 0;
                  if ((WORD4(v79) & 0x8000) != 0) {
                    uint64_t v66 = HIDWORD(v79);
                  }
                  else {
                    uint64_t v66 = WORD4(v79) >> 5;
                  }
                }

                __int128 v55 = icu::UnicodeString::indexOf((uint64_t)&v79, (uint64_t)L";%", 0, 2, v65, v66 - v65);
                v56 += 64LL;
                ++v57;
                if (v55 == -1) {
                  goto LABEL_112;
                }
              }
            }
          }

          else
          {
            *(void *)(v8 + 368) = 0LL;
          }
        }

      HIDWORD(v108[0]) = 7;
    }
  }

BOOL icu::UnicodeSet::resemblesPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  int v2 = (_DWORD)a2 + 1;
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
  {
    unsigned int v4 = *((_DWORD *)this + 3);
  }

  else
  {
    unsigned int v4 = v3 >> 5;
  }

  if (v4 > a2)
  {
    uint64_t v5 = (v3 & 2) != 0 ? (icu::UnicodeSet *)((char *)this + 10) : (icu::UnicodeSet *)*((void *)this + 3);
  }

  return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
}

uint64_t icu::UnicodeSet::resemblesPropertyPattern(uint64_t a1, signed int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if ((v2 & 0x8000u) == 0) {
    unsigned int v3 = v2 >> 5;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = a1 + 10;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 24);
  }
  int v5 = *(unsigned __int16 *)(v4 + 2LL * a2);
  if (v5 != 92)
  {
    if (v5 == 91)
    {
      uint64_t v6 = a2 + 1LL;
    }

    return 0LL;
  }

  uint64_t v8 = a2 + 1LL;
  int v9 = *(_WORD *)(v4 + 2 * v8) & 0xFFDF;
  uint64_t result = v9 == 80;
  return result;
}

BOOL icu::UnicodeSet::resemblesPropertyPattern(uint64_t a1, char a2)
{
  char v12 = 0;
  int v11 = 0;
  char v4 = a2 & 0xFD;
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_180808BC8(a1, (uint64_t)v10);
  int v5 = sub_180808860(a1, v4, &v12, &v11);
  if ((v5 - 91) <= 1)
  {
    int v6 = v5;
    int v7 = sub_180808860(a1, a2 & 0xF9, &v12, &v11);
    int v8 = v7;
    if (v6 == 91)
    {
      sub_180808BE4(a1, (uint64_t)v10);
      if (v8 != 58) {
        return 0LL;
      }
      return v11 < 1;
    }

    if ((v7 - 78) <= 0x22 && ((1LL << (v7 - 78)) & 0x400000005LL) != 0)
    {
      sub_180808BE4(a1, (uint64_t)v10);
      return v11 < 1;
    }
  }

  sub_180808BE4(a1, (uint64_t)v10);
  return 0LL;
}

void icu::UnicodeSet::applyPropertyPattern(icu::UnicodeSet *a1, uint64_t *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 <= 0)
  {
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    uint64_t v15 = 0LL;
    __int128 v14 = 0u;
    int v11 = off_18971B688;
    LOWORD(v12) = 2;
    sub_180808B5C((uint64_t)a2, (icu::UnicodeString *)&v11, 0xFFFFFFFF);
    int v9 = off_18970F400;
    unint64_t v10 = 0xFFFFFFFF00000000LL;
    icu::UnicodeSet::applyPropertyPattern(a1, (const icu::UnicodeString *)&v11, (icu::ParsePosition *)&v9, a4);
    if (*(int *)a4 <= 0)
    {
      uint64_t v8 = v10;
      if ((_DWORD)v10)
      {
        sub_180808BC4(a2, v10);
        icu::UnicodeString::doAppend(a3, (const icu::UnicodeString *)&v11, 0, v8);
      }

      else
      {
        *a4 = U_MALFORMED_SET;
      }
    }

    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v9);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v11);
  }

uint64_t sub_1808623BC(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if (!a2 && (v2 & 1) != 0)
  {
    icu::UnicodeString::unBogus(a1);
    return 0LL;
  }

  if ((v2 & 0x8000) != 0) {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
  }
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0LL;
  }
  if (a2 > 1023)
  {
    *(_WORD *)(a1 + 8) = v2 | 0xFFE0;
    *(_DWORD *)(a1 + 12) = a2;
  }

  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0x1F | (32 * a2);
  }

  return 1LL;
}

icu::UnicodeSet *icu::UnicodeSet::applyFilter( icu::UnicodeSet *this, signed __int8 (*a2)(int, void *), void *a3, const icu::UnicodeSet *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    int v5 = a5;
    int v9 = this;
    icu::UnicodeSet::clear(this);
    this = (icu::UnicodeSet *)icu::UnicodeSet::getRangeCount(a4);
    if ((int)this >= 1)
    {
      int v10 = (int)this;
      uint64_t v16 = v5;
      int v11 = 0;
      signed int v12 = -1;
      do
      {
        int RangeStart = icu::UnicodeSet::getRangeStart(a4, v11);
        this = (icu::UnicodeSet *)icu::UnicodeSet::getRangeEnd(a4, v11);
        if (RangeStart <= (int)this)
        {
          int v14 = (int)this;
          unsigned int v15 = RangeStart - 1;
          do
          {
            this = (icu::UnicodeSet *)((uint64_t (*)(void, void *))a2)(v15 + 1, a3);
            if ((_DWORD)this)
            {
              if (v12 < 0) {
                signed int v12 = v15 + 1;
              }
            }

            else if ((v12 & 0x80000000) == 0)
            {
              this = icu::UnicodeSet::add(v9, v12, v15);
              signed int v12 = -1;
            }

            ++v15;
          }

          while (v14 != v15);
        }

        ++v11;
      }

      while (v11 != v10);
      int v5 = v16;
      if ((v12 & 0x80000000) == 0) {
        this = icu::UnicodeSet::add(v9, v12, 0x10FFFFu);
      }
    }
  }

  return this;
}

icu::UnicodeSet *icu::UnicodeSet::applyIntPropertyValue( icu::UnicodeSet *this, uint64_t property, unsigned int a3, UErrorCode *pErrorCode)
{
  unsigned int v15 = a3;
  int v7 = property;
  if ((_DWORD)property == 28672)
  {
    uint64_t v8 = (const icu::UnicodeSet *)sub_1807C3CA8(28672LL, (int *)pErrorCode);
    v14[0] = a3;
    int v9 = (signed __int8 (*)(int, void *))sub_1808626C8;
LABEL_8:
    int v10 = v14;
    goto LABEL_9;
  }

  if ((_DWORD)property == 0x2000)
  {
    uint64_t v8 = (const icu::UnicodeSet *)sub_1807C3CA8(0x2000LL, (int *)pErrorCode);
    int v9 = (signed __int8 (*)(int, void *))sub_1808626A0;
    int v10 = &v15;
LABEL_9:
    icu::UnicodeSet::applyFilter(this, v9, v10, v8, pErrorCode);
    return this;
  }

  if (property > 0x4A)
  {
    if ((property - 4096) > 0x18)
    {
      *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return this;
    }

    uint64_t v8 = (const icu::UnicodeSet *)sub_1807C3CA8(property, (int *)pErrorCode);
    v14[0] = v7;
    v14[1] = a3;
    int v9 = (signed __int8 (*)(int, void *))sub_1808626D0;
    goto LABEL_8;
  }

  if (a3 > 1)
  {
    icu::UnicodeSet::clear(this);
  }

  else
  {
    BinaryPropertySet = u_getBinaryPropertySet((UProperty)property, pErrorCode);
    if (*(int *)pErrorCode <= 0)
    {
      icu::UnicodeSet::copyFrom(this, BinaryPropertySet, 1);
      if (!a3)
      {
        __int128 v13 = icu::UnicodeSet::complement(this);
        icu::UnicodeSet::removeAllStrings(v13);
      }
    }
  }

  return this;
}

uint64_t sub_1808626A0(UChar32 a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  return (v2 >> u_charType(a1)) & 1;
}

BOOL sub_1808626C8(unsigned int a1, unsigned int *a2)
{
  return uscript_hasScript(a1, *a2);
}

BOOL sub_1808626D0(UChar32 a1, uint64_t a2)
{
  return u_getIntPropertyValue(a1, *(UProperty *)a2) == *(_DWORD *)(a2 + 4);
}

icu::UnicodeSet *icu::UnicodeSet::applyPropertyAlias( icu::UnicodeSet *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, UErrorCode *a4)
{
  v49[8] = *(void **)MEMORY[0x1895F89C0];
  unsigned int v8 = *((unsigned __int16 *)a2 + 4);
  if ((v8 & 0x11) != 0)
  {
    int v9 = 0LL;
  }

  else if ((v8 & 2) != 0)
  {
    int v9 = (_WORD *)((char *)a2 + 10);
  }

  else
  {
    int v9 = (_WORD *)*((void *)a2 + 3);
  }

  int v10 = (__int16)v8;
  int v11 = v8 >> 5;
  if (v10 >= 0) {
    int v12 = v11;
  }
  else {
    int v12 = *((_DWORD *)a2 + 3);
  }
  if (!uprv_isInvariantUString(v9, v12)
    || ((unsigned int v13 = *((unsigned __int16 *)a3 + 4), (v13 & 0x11) == 0)
      ? ((v13 & 2) != 0
       ? (int v14 = (_WORD *)((char *)a3 + 10))
       : (int v14 = (_WORD *)*((void *)a3 + 3)))
      : (int v14 = 0LL),
        (int v15 = (__int16)v13, v16 = v13 >> 5, v15 >= 0) ? (v17 = v16) : (v17 = *((_DWORD *)a3 + 3)),
        !uprv_isInvariantUString(v14, v17)))
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return this;
  }

  memset(&v49[1], 0, 56);
  v49[0] = (char *)&v49[1] + 5;
  LODWORD(v49[1]) = 40;
  memset(&alias[1], 0, 56);
  alias[0] = (char *)&alias[1] + 5;
  LODWORD(alias[1]) = 40;
  icu::CharString::appendInvariantChars((icu::CharString *)v49, a2, a4);
  icu::CharString::appendInvariantChars((icu::CharString *)alias, a3, a4);
  if (*(int *)a4 <= 0)
  {
    unsigned int v18 = *((unsigned __int16 *)a3 + 4);
    int v19 = (__int16)v18;
    int v20 = v18 >> 5;
    if (v19 < 0) {
      int v20 = *((_DWORD *)a3 + 3);
    }
    if (v20 < 1)
    {
      uint64_t v23 = 0x2000LL;
      int32_t PropertyValueEnum = u_getPropertyValueEnum(UCHAR_GENERAL_CATEGORY_MASK, (const char *)v49[0]);
      if (PropertyValueEnum != -1
        || (uint64_t v23 = 4106LL,
            int32_t PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, (const char *)v49[0]),
            PropertyValueEnum != -1))
      {
        int32_t v25 = PropertyValueEnum;
        goto LABEL_43;
      }

      uint64_t PropertyEnum = u_getPropertyEnum((const char *)v49[0]);
      if (PropertyEnum < 0x4B)
      {
        uint64_t v23 = PropertyEnum;
        int32_t v25 = 1;
        goto LABEL_43;
      }

      if (uprv_compareASCIIPropertyNames(byte_180A271F0, (unsigned __int8 *)v49[0]))
      {
        if (uprv_compareASCIIPropertyNames("ASCII", (unsigned __int8 *)v49[0]))
        {
          if (!uprv_compareASCIIPropertyNames("Assigned", (unsigned __int8 *)v49[0]))
          {
            int v37 = icu::UnicodeSet::applyIntPropertyValue(this, 0x2000LL, 1u, a4);
            unsigned int v38 = icu::UnicodeSet::complement(v37);
            icu::UnicodeSet::removeAllStrings(v38);
LABEL_44:
            UErrorCode v27 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_70;
          }

          goto LABEL_69;
        }

        int v35 = this;
        unsigned int v36 = 127;
      }

      else
      {
        int v35 = this;
        unsigned int v36 = 1114111;
      }

      icu::UnicodeSet::set(v35, 0, v36);
      goto LABEL_71;
    }

    uint64_t v21 = u_getPropertyEnum((const char *)v49[0]);
    if ((_DWORD)v21 == -1) {
      goto LABEL_69;
    }
    uint64_t v22 = v21;
    if ((_DWORD)v21 == 4101) {
      uint64_t v23 = 0x2000LL;
    }
    else {
      uint64_t v23 = v21;
    }
    if ((_DWORD)v23 == 0x2000 || v23 < 0x4B || (v23 - 4096) <= 0x18)
    {
      int32_t v25 = u_getPropertyValueEnum((UProperty)v23, alias[0]);
      if (v25 != -1) {
        goto LABEL_43;
      }
      if ((v23 - 4098) <= 0xF && ((1 << (v23 - 2)) & 0xC001) != 0)
      {
        *(void *)versionString = 0LL;
        double v30 = strtod(alias[0], (char **)versionString);
        if (!**(_BYTE **)versionString && v30 >= 0.0 && v30 <= 255.0)
        {
          int32_t v25 = (int)v30;
          if (v30 == (double)(int)v30)
          {
            uint64_t v23 = v22;
            goto LABEL_43;
          }
        }
      }

      goto LABEL_69;
    }

    if ((int)v23 <= 16388)
    {
      if ((_DWORD)v23 == 12288)
      {
        *(void *)versionString = 0LL;
        double versionArray = strtod(alias[0], (char **)versionString);
        if (**(_BYTE **)versionString) {
          goto LABEL_69;
        }
        int v28 = (const icu::UnicodeSet *)sub_1807C3CA8(12288LL, (int *)a4);
        uint64_t v29 = (signed __int8 (*)(int, void *))sub_180862C04;
      }

      else
      {
        if ((_DWORD)v23 != 0x4000) {
          goto LABEL_69;
        }
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        __int128 v44 = 0u;
        __int128 v45 = 0u;
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        *(_OWORD *)versionString = 0u;
        __int128 v41 = 0u;
        LODWORD(versionArray) = 0;
        u_versionFromString((uint8_t *)&versionArray, versionString);
        int v28 = (const icu::UnicodeSet *)sub_1807C3CA8(0x4000LL, (int *)a4);
        uint64_t v29 = (signed __int8 (*)(int, void *))sub_180862CB0;
      }

      icu::UnicodeSet::applyFilter(this, v29, &versionArray, v28, a4);
    }

    else
    {
      if ((_DWORD)v23 != 16389)
      {
        if ((_DWORD)v23 == 28672)
        {
          int32_t v24 = u_getPropertyValueEnum(UCHAR_SCRIPT, alias[0]);
          if (v24 != -1)
          {
            int32_t v25 = v24;
            uint64_t v23 = 28672LL;
LABEL_43:
            icu::UnicodeSet::applyIntPropertyValue(this, v23, v25, a4);
            goto LABEL_44;
          }
        }

BOOL sub_180862C04(UChar32 a1, double *a2)
{
  return u_getNumericValue(a1) == *a2;
}

uint64_t sub_180862C30(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  while (2)
  {
    uint64_t v3 = a2 + 1;
    while (1)
    {
      a2 = v3;
      int v4 = *(unsigned __int8 *)(v3 - 1);
      if (v4 != 32) {
        break;
      }
      ++v3;
    }

    if (!*(_BYTE *)(v3 - 1))
    {
      if ((_DWORD)v2)
      {
        uint64_t v2 = (int)v2;
      }

      else
      {
        uint64_t v2 = 0LL;
      }

      *(_BYTE *)(a1 + v2) = 0;
      return 1LL;
    }

BOOL sub_180862CB0(UChar32 a1, unsigned int *a2)
{
  *(_DWORD *)UVersionInfo versionArray = 0;
  u_charAge(a1, versionArray);
  BOOL result = 0LL;
  if (bswap32(*(unsigned int *)versionArray))
  {
    unsigned int v4 = bswap32(*(unsigned int *)versionArray);
    unsigned int v5 = bswap32(*a2);
    BOOL v6 = v4 >= v5;
    BOOL v7 = v4 > v5;
    int v8 = !v6;
    return v7 - v8 < 1;
  }

  return result;
}

icu::UnicodeSet *icu::UnicodeSet::applyPropertyPattern( icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, UErrorCode *a4)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *((int *)a3 + 2);
  unsigned int v9 = *((unsigned __int16 *)a2 + 4);
  if ((v9 & 0x8000u) == 0) {
    unsigned int v10 = v9 >> 5;
  }
  else {
    unsigned int v10 = *((_DWORD *)a2 + 3);
  }
  unsigned int v42 = 0;
  if ((v9 & 2) != 0) {
    int v11 = (char *)a2 + 10;
  }
  else {
    int v11 = (char *)*((void *)a2 + 3);
  }
  int v12 = *(unsigned __int16 *)&v11[2 * v8];
  if (v12 == 92)
  {
    unsigned int v21 = v8 + 1;
    if (v10 > (int)v8 + 1)
    {
      int v22 = *(unsigned __int16 *)&v11[2 * v21];
      if ((v22 & 0xFFFFFFDF) != 0x50)
      {
        if (v10 <= v21 || *(_WORD *)&v11[2 * v21] != 78) {
          goto LABEL_88;
        }
        int v22 = 78;
      }

      BOOL v20 = v22 == 80;
      BOOL v23 = v22 == 78;
      unsigned int v42 = v8 + 2;
      int v24 = icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v42, 0LL);
      unsigned int v25 = *((unsigned __int16 *)a2 + 4);
      if ((v25 & 0x8000) != 0)
      {
        unsigned int v26 = *((_DWORD *)a2 + 3);
        if (v24 == v26) {
          goto LABEL_88;
        }
      }

      else
      {
        if (v24 == v25 >> 5) {
          goto LABEL_88;
        }
        unsigned int v26 = v25 >> 5;
      }

      int v27 = v24 + 1;
      unsigned int v42 = v24 + 1;
      if (v26 > v24)
      {
        int v28 = (char *)*((void *)a2 + 3);
        if ((v25 & 2) != 0) {
          int v28 = (char *)a2 + 10;
        }
        if (*(_WORD *)&v28[2 * v24] == 123)
        {
          if (v24 >= -1)
          {
            if ((v25 & 0x8000) != 0)
            {
              int v30 = *((_DWORD *)a2 + 3);
              int v29 = v30 >= v27 ? v24 + 1 : *((_DWORD *)a2 + 3);
            }

            else
            {
              int v30 = v25 >> 5;
              int v29 = v30 >= v27 ? v24 + 1 : v30;
            }
          }

          else
          {
            int v29 = 0;
            int v30 = (v25 & 0x8000) != 0 ? *((_DWORD *)a2 + 3) : v25 >> 5;
          }

          uint64_t v34 = icu::UnicodeString::doIndexOf((uint64_t)a2, 0x7Du, v29, v30 - v29);
          int v33 = 1;
          if ((v34 & 0x80000000) == 0) {
            goto LABEL_57;
          }
        }
      }
    }

LABEL_88:
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return this;
  }

  BOOL v13 = v12 == 91;
  unsigned int v14 = v8 + 1;
  BOOL v15 = v13 && v10 > v14;
  if (!v15 || *(_WORD *)&v11[2 * v14] != 58) {
    goto LABEL_88;
  }
  unsigned int v42 = v8 + 2;
  int v16 = icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v42, 0LL);
  unsigned int v42 = v16;
  unsigned int v17 = *((unsigned __int16 *)a2 + 4);
  int v18 = v17 >> 5;
  if ((v17 & 0x8000) != 0)
  {
    int v19 = *((_DWORD *)a2 + 3);
    if (v16 >= v19)
    {
      BOOL v20 = 0;
      if ((v16 & 0x80000000) == 0) {
        goto LABEL_50;
      }
LABEL_55:
      int v32 = 0;
      int v18 = *((_DWORD *)a2 + 3);
      goto LABEL_56;
    }
  }

  else
  {
    int v19 = v17 >> 5;
    if (v16 >= (int)(v17 >> 5))
    {
      BOOL v20 = 0;
      if (v16 < 0) {
        goto LABEL_54;
      }
      goto LABEL_46;
    }
  }

  BOOL v31 = (char *)*((void *)a2 + 3);
  if ((v17 & 2) != 0) {
    BOOL v31 = (char *)a2 + 10;
  }
  if (*(_WORD *)&v31[2 * v16] == 94)
  {
    unsigned int v42 = ++v16;
    BOOL v20 = 1;
  }

  else
  {
LABEL_43:
    BOOL v20 = 0;
  }

  if (v16 < 0)
  {
    if ((v17 & 0x8000) == 0)
    {
LABEL_54:
      int v32 = 0;
      goto LABEL_56;
    }

    goto LABEL_55;
  }

  if ((v17 & 0x8000) == 0)
  {
LABEL_46:
    else {
      int v32 = v17 >> 5;
    }
    goto LABEL_56;
  }

    ++v43;
  }

  __int128 v45 = *((_DWORD *)this + 3);
  if (v43 < v45) {
    goto LABEL_26;
  }
LABEL_93:
  int v69 = v42 - 3;
  if (v69 >= 2)
  {
    if (v42)
    {
      int v69 = 65799LL;
      *a4 = 65799;
    }
  }

  else
  {
    LOWORD(v76) = 39;
    icu::UnicodeString::doAppend(a5, (uint64_t)&v76, 0, 1LL);
  }

  for (n = 2624LL; n != -64; n -= 64LL)
    BOOL result = icu::UnicodeString::~UnicodeString((void *)v69, (icu::UnicodeString *)&v80[n]);
  return result;
}

uint64_t sub_18086319C()
{
  if (qword_18C5350A0)
  {
    icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)qword_18C5350A0);
    icu::UMemory::operator delete(v0);
  }

  qword_18C5350A0 = 0LL;
  atomic_store(0, &dword_18C5350A8);
  return 1LL;
}

uint64_t sub_1808631DC(uint64_t a1, const icu::UnicodeSet *a2, uint64_t a3, int a4)
{
  uint64_t v8 = (icu::UnicodeSet *)(a1 + 8);
  unsigned int v9 = (icu::UVector **)icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 8), 0, 0x10FFFFu);
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 208) = 0LL;
  *(void *)(a1 + 216) = a3;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 256) = 0;
  __int128 v56 = (char **)(a1 + 224);
  *(_BYTE *)(a1 + 260) = a4 == 63;
  icu::UnicodeSet::retainAll(v9, a2);
  if ((a4 & 1) != 0) {
    *(void *)(a1 + 208) = v8;
  }
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  unsigned int v11 = 0;
  char v12 = 0;
  do
  {
    uint64_t v13 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v11);
    unsigned int v14 = *(unsigned __int16 *)(v13 + 8);
    if ((v14 & 0x11) != 0)
    {
      BOOL v15 = 0LL;
      if ((v14 & 0x8000) == 0) {
        goto LABEL_10;
      }
    }

    else if ((v14 & 2) != 0)
    {
      BOOL v15 = (UChar *)(v13 + 10);
      if ((v14 & 0x8000) == 0)
      {
LABEL_10:
        uint64_t v16 = v14 >> 5;
        if (!(_DWORD)v16) {
          goto LABEL_34;
        }
        goto LABEL_14;
      }
    }

    else
    {
      BOOL v15 = *(UChar **)(v13 + 24);
      if ((v14 & 0x8000) == 0) {
        goto LABEL_10;
      }
    }

    uint64_t v16 = *(unsigned int *)(v13 + 12);
    if (!(_DWORD)v16) {
      goto LABEL_34;
    }
LABEL_14:
    int v17 = icu::UnicodeSet::span(v8, v15, v16, 1);
    BOOL v19 = (a4 & 2) == 0 && v17 >= (int)v16;
    if ((a4 & 4) != 0 && !v19)
    {
      *(void *)pErrorCode = 0LL;
      u_strToUTF8(0LL, 0, (int32_t *)pErrorCode, v15, v16, &pErrorCode[1]);
      BOOL v20 = pErrorCode[1] == U_BUFFER_OVERFLOW_ERROR || pErrorCode[1] < U_ILLEGAL_ARGUMENT_ERROR;
      UErrorCode v21 = pErrorCode[0];
      if (!v20) {
        UErrorCode v21 = U_ZERO_ERROR;
      }
      *(_DWORD *)(a1 + 248) += v21;
      if (v21 > *(_DWORD *)(a1 + 256)) {
        *(_DWORD *)(a1 + 256) = v21;
      }
    }

LABEL_114:
    if (v10 != ++v28) {
      continue;
    }
    break;
  }

  if (*(_BYTE *)(a1 + 260)) {
    icu::UnicodeSet::freeze(*(icu::UnicodeSet **)(a1 + 208));
  }
  return a1;
}

icu::UnicodeSet *sub_18086375C(uint64_t a1, unsigned int a2)
{
  BOOL result = *(icu::UnicodeSet **)(a1 + 208);
  if (result) {
    BOOL v5 = result == (icu::UnicodeSet *)(a1 + 8);
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    return icu::UnicodeSet::add(result, a2);
  }
  BOOL result = (icu::UnicodeSet *)icu::UnicodeSet::contains((icu::UnicodeSet *)(a1 + 8), a2);
  if (!(_DWORD)result)
  {
    BOOL result = icu::UnicodeSet::cloneAsThawed((icu::UnicodeSet *)(a1 + 8), v6, v7);
    if (result)
    {
      *(void *)(a1 + 208) = result;
      return icu::UnicodeSet::add(result, a2);
    }
  }

  return result;
}

uint64_t sub_1808637D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (uint64_t *)(a2 + 8);
  BOOL v7 = icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 8), (const icu::UnicodeSet *)(a2 + 8));
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 208) = 0LL;
  *(void *)(a1 + 216) = a3;
  *(void *)(a1 + 232) = 0LL;
  *(void *)(a1 + 240) = 0LL;
  uint64_t v9 = *(void *)(a2 + 248);
  *(void *)(a1 + 248) = v9;
  *(_DWORD *)(a1 + 256) = *(_DWORD *)(a2 + 256);
  *(_BYTE *)(a1 + 260) = 1;
  uint64_t v10 = *(uint64_t **)(a2 + 208);
  if (v10 == v6)
  {
    int v11 = v9;
  }

  else
  {
    BOOL v7 = icu::UnicodeSet::clone(*(icu::UnicodeSet **)(a2 + 208), v8, v10);
    a3 = *(void *)(a1 + 216);
    int v11 = *(_DWORD *)(a1 + 248);
  }

  *(void *)(a1 + 208) = v7;
  uint64_t v12 = *(int *)(a3 + 8);
  size_t v13 = 8 * v12 + v11;
  if ((int)v13 > 128)
  {
    unsigned int v14 = (char *)uprv_malloc(v13);
    *(void *)(a1 + 224) = v14;
    if (!v14)
    {
      *(_DWORD *)(a1 + 252) = 0;
      *(_DWORD *)(a1 + 256) = 0;
      return a1;
    }
  }

  else
  {
    unsigned int v14 = (char *)(a1 + 264);
    *(void *)(a1 + 224) = a1 + 264;
  }

  BOOL v15 = &v14[4 * v12];
  *(void *)(a1 + 232) = v15;
  *(void *)(a1 + 240) = &v15[4 * (int)v12];
  memcpy(v14, *(const void **)(a2 + 224), v13);
  return a1;
}

void *sub_1808638C0(void *a1)
{
  uint64_t v2 = (icu::UnicodeSet *)a1[26];
  if (v2) {
    BOOL v3 = v2 == (icu::UnicodeSet *)(a1 + 1);
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    icu::UnicodeSet::~UnicodeSet(v2);
    icu::UMemory::operator delete(v4);
  }

  BOOL v5 = (void *)a1[28];
  if (v5) {
    BOOL v6 = v5 == a1 + 33;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    uprv_free(v5);
  }
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)(a1 + 1));
  return a1;
}

uint64_t sub_180863920(uint64_t a1, UChar *s, uint64_t a3, int a4)
{
  uint64_t v4 = a3;
  v70[3] = *MEMORY[0x1895F89C0];
  if (!a4) {
    return sub_180863F64(a1, (uint64_t)s, a3);
  }
  int v7 = a4;
  __int128 v64 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v8 = icu::UnicodeSet::span((icu::UnicodeSet *)(a1 + 8), s);
  int v9 = v4 - v8;
  if ((_DWORD)v4 == (_DWORD)v8) {
    return v4;
  }
  uint64_t v10 = v8;
  memset(v70, 0, 24);
  int v68 = (char *)v70 + 4;
  uint64_t v69 = 0LL;
  if (v7 == 1)
  {
    int v11 = *(_DWORD *)(a1 + 252);
    if (v11 > 16)
    {
      uint64_t v12 = (char *)uprv_malloc(*(unsigned int *)(a1 + 252));
      if (v12)
      {
        int v68 = v12;
        LODWORD(v69) = v11;
      }

      else
      {
        int v11 = v69;
        uint64_t v12 = (char *)v68;
      }
    }

    else
    {
      int v11 = 16;
      LODWORD(v69) = 16;
      uint64_t v12 = (char *)v70 + 4;
    }

    bzero(v12, v11);
  }

  uint64_t v63 = v4;
  uint64_t v67 = (int)v4;
  uint64_t v14 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  int v15 = v10;
  int v65 = v7;
  while (1)
  {
    if (v7 == 1)
    {
      if ((int)v14 >= 1)
      {
        uint64_t v16 = 0LL;
        while (1)
        {
          LODWORD(v17) = *(unsigned __int8 *)(*(void *)(a1 + 232) + v16);
          if ((_DWORD)v17 != 255) {
            break;
          }
LABEL_35:
          if (++v16 == v14) {
            goto LABEL_99;
          }
        }

        uint64_t v18 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v16);
        unsigned int v19 = *(unsigned __int16 *)(v18 + 8);
        if ((v19 & 0x11) != 0)
        {
          BOOL v20 = 0LL;
          if ((v19 & 0x8000) != 0) {
            goto LABEL_23;
          }
LABEL_21:
          int v21 = v19 >> 5;
LABEL_24:
          if ((_DWORD)v17 == 254)
          {
            uint64_t v17 = v21 - 1LL;
            BOOL v22 = (v20[v17] & 0xFC00) != 0xDC00 || v21 < 2;
            if (!v22 && (v20[v21 - 2] & 0xFC00) == 0xD800) {
              LODWORD(v17) = v21 - 2;
            }
          }

          else {
            LODWORD(v23) = v17;
          }
          int v24 = v21 - v23;
          if (v21 - (int)v23 <= v9)
          {
            uint64_t v25 = v21;
            uint64_t v26 = v21 - 1LL;
            uint64_t v23 = (int)v23;
            uint64_t v27 = v67 - v21;
            int v28 = v21 + 1;
            do
            {
              int v29 = v69;
              int v30 = LODWORD(v70[0]) + v24 - v29;
              if (!*((_BYTE *)v68 + v30))
              {
                uint64_t v32 = (int)v10 - v23;
                int v33 = &s[v32];
                int v34 = v28;
                int v35 = v33;
                int v36 = v20;
                while (*v35 == *v36)
                {
                  ++v36;
                  ++v35;
                  if (--v34 <= 1)
                  {
                    if ((v32 < 1 || (*(v33 - 1) & 0xFC00) != 0xD800 || (*v33 & 0xFC00) != 0xDC00)
                      && (v32 >= v27 || (v33[v26] & 0xFC00) != 0xD800 || (v33[v25] & 0xFC00) != 0xDC00))
                    {
                      if (v24 == v9) {
                        goto LABEL_121;
                      }
                      *((_BYTE *)v68 + v30) = 1;
                      ++HIDWORD(v69);
                    }

                    break;
                  }
                }
              }

              if (!(_DWORD)v23) {
                break;
              }
              --v23;
            }

            while (v24++ != v9);
          }

          goto LABEL_35;
        }

        if ((v19 & 2) != 0)
        {
          BOOL v20 = (unsigned __int16 *)(v18 + 10);
          if ((v19 & 0x8000) == 0) {
            goto LABEL_21;
          }
        }

        else
        {
          BOOL v20 = *(unsigned __int16 **)(v18 + 24);
          if ((v19 & 0x8000) == 0) {
            goto LABEL_21;
          }
        }

LABEL_108:
      LODWORD(v46) = sub_180864178((unsigned __int8 **)&v68);
      int v15 = 0;
      v9 -= v46;
      goto LABEL_120;
    }

    uint64_t v58 = &s[(int)v10];
    if (HIDWORD(v69)) {
      break;
    }
    LODWORD(v46) = icu::UnicodeSet::span(v64, &s[(int)v10]);
    v9 -= v46;
    if (!v9 || !(_DWORD)v46)
    {
      uint64_t v4 = (v46 + v10);
      goto LABEL_122;
    }

    int v15 = v46;
LABEL_120:
    uint64_t v10 = (v46 + v10);
  }

  int v59 = *v58;
  if (v9 >= 2 && (v59 & 0xFC00) == 0xD800 && (int v60 = v58[1], (v60 & 0xFC00) == 0xDC00))
  {
    LODWORD(v46) = 2;
  }

  else
  {
    LODWORD(v46) = 1;
  }

  v9 -= v46;
  if (v9)
  {
    int v61 = v69;
    int v62 = LODWORD(v70[0]) + v46 - v61;
    if (*((_BYTE *)v68 + v62))
    {
      *((_BYTE *)v68 + v62) = 0;
      --HIDWORD(v69);
    }

    int v15 = 0;
    LODWORD(v70[0]) = v62;
    goto LABEL_120;
  }

    v123 = "s";
    icu::UnicodeString::UnicodeString(v34, 1LL, &v123);
    unsigned int v44 = sub_1807FF934((uint64_t)&v171, (uint64_t)&v166);
    icu::UnicodeString::~UnicodeString(v45, (icu::UnicodeString *)&v166);
    v122[0] = v123;
    if (!v44)
    {
      icu::UnicodeSet::~UnicodeSet(v122, (icu::UnicodeSet *)&__src);
      goto LABEL_212;
    }

    int v35 = *(void (**)(void))(**(void **)(v3 + 56) + 40LL);
    goto LABEL_110;
  }

  return this;
}

uint64_t sub_180863F64(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v3 = a3;
  int v6 = 0;
  uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  uint64_t v25 = (icu::UnicodeSet *)(a1 + 8);
  while (1)
  {
    int v8 = icu::UnicodeSet::span(*(icu::UnicodeSet **)(a1 + 208), (UChar *)(a2 + 2LL * v6));
    int v9 = v3 - v8;
    if (v3 == v8) {
      return a3;
    }
    uint64_t v10 = (v8 + v6);
    int v11 = (unsigned __int16 *)(a2 + 2LL * (int)v10);
    int v12 = *v11;
    if (v9 < 2 || (v12 & 0xFC00) != 55296) {
      break;
    }
    int v14 = v11[1];
    if ((v14 & 0xFC00) != 0xDC00) {
      break;
    }
    int v15 = -2;
LABEL_13:
    if ((int)v7 >= 1)
    {
      uint64_t v16 = 0LL;
      while (*(unsigned __int8 *)(*(void *)(a1 + 232) + v16) == 255)
      {
LABEL_34:
        if (++v16 == v7) {
          goto LABEL_35;
        }
      }

      uint64_t v17 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v16);
      unsigned int v18 = *(unsigned __int16 *)(v17 + 8);
      if ((v18 & 0x11) != 0)
      {
        unsigned int v19 = 0LL;
        if ((v18 & 0x8000) != 0)
        {
LABEL_23:
          int v20 = *(_DWORD *)(v17 + 12);
LABEL_24:
          if (v20 <= v9)
          {
            int v21 = v20 + 1;
            BOOL v22 = (unsigned __int16 *)(a2 + 2LL * (int)v10);
            while (*v22 == *v19)
            {
              ++v19;
              ++v22;
              if (--v21 <= 1)
              {
                if (((int)v10 < 1 || (*(v11 - 1) & 0xFC00) != 0xD800 || (*v11 & 0xFC00) != 0xDC00)
                  && ((int)(a3 - v10) <= v20 || (v11[v20 - 1] & 0xFC00) != 0xD800 || (v11[v20] & 0xFC00) != 0xDC00))
                {
                  return v10;
                }

                goto LABEL_34;
              }
            }
          }

          goto LABEL_34;
        }
      }

      else if ((v18 & 2) != 0)
      {
        unsigned int v19 = (unsigned __int16 *)(v17 + 10);
        if ((v18 & 0x8000) != 0) {
          goto LABEL_23;
        }
      }

      else
      {
        unsigned int v19 = *(unsigned __int16 **)(v17 + 24);
        if ((v18 & 0x8000) != 0) {
          goto LABEL_23;
        }
      }

      int v20 = v18 >> 5;
      goto LABEL_24;
    }

uint64_t sub_180864178(unsigned __int8 **a1)
{
  int v1 = *((_DWORD *)a1 + 4);
  uint64_t v2 = *((int *)a1 + 2);
  int v3 = *a1;
  uint64_t v4 = v1;
  while (1)
  {
    uint64_t v5 = v4 + 1;
    if (v4 + 1 >= v2) {
      break;
    }
    if (v3[++v4])
    {
      v3[v5] = 0;
      uint64_t v7 = (v5 - *((_DWORD *)a1 + 4));
      --*((_DWORD *)a1 + 3);
      *((_DWORD *)a1 + 4) = v5;
      return v7;
    }
  }

  int v8 = -1;
  do
  {
    int v9 = *v3++;
    ++v8;
  }

  while (!v9);
  *(v3 - 1) = 0;
  --*((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 4) = v8;
  return (v2 - v1 + v8);
}

uint64_t sub_1808641EC(uint64_t a1, UChar *s, int a3, int a4)
{
  v70[3] = *MEMORY[0x1895F89C0];
  if (!a4) {
    return sub_180864844(a1, s, a3);
  }
  __int128 v64 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v7 = icu::UnicodeSet::spanBack((icu::UnicodeSet *)(a1 + 8), s);
  if (!(_DWORD)v7) {
    return 0LL;
  }
  uint64_t v8 = v7;
  int v9 = a3 - v7;
  memset(v70, 0, 24);
  int v68 = (char *)v70 + 4;
  uint64_t v69 = 0LL;
  if (a4 == 1)
  {
    int v10 = *(_DWORD *)(a1 + 252);
    if (v10 > 16)
    {
      int v11 = (char *)uprv_malloc(*(unsigned int *)(a1 + 252));
      if (v11)
      {
        int v68 = v11;
        LODWORD(v69) = v10;
      }

      else
      {
        int v10 = v69;
        int v11 = (char *)v68;
      }
    }

    else
    {
      int v10 = 16;
      LODWORD(v69) = 16;
      int v11 = (char *)v70 + 4;
    }

    bzero(v11, v10);
  }

  uint64_t v14 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  if (*(_BYTE *)(a1 + 260)) {
    uint64_t v15 = (int)v14;
  }
  else {
    uint64_t v15 = 0LL;
  }
  uint64_t v67 = a1;
  uint64_t v16 = *(void *)(a1 + 232) + v15;
  while (1)
  {
    while (a4 != 1)
    {
      if ((int)v14 >= 1)
      {
        uint64_t v38 = 0LL;
        uint64_t v39 = 0LL;
        int v66 = 0;
        while (1)
        {
          unsigned int v40 = *(unsigned __int8 *)(v16 + v38);
          uint64_t v41 = icu::UVector::elementAt(*(icu::UVector **)(v67 + 216), v38);
          unsigned int v42 = *(unsigned __int16 *)(v41 + 8);
          if ((v42 & 0x11) != 0)
          {
            size_t v43 = 0LL;
            if ((v42 & 0x8000) == 0) {
              goto LABEL_66;
            }
          }

          else if ((v42 & 2) != 0)
          {
            size_t v43 = (unsigned __int16 *)(v41 + 10);
            if ((v42 & 0x8000) == 0)
            {
LABEL_66:
              unsigned int v44 = v42 >> 5;
              if (v42 >> 5) {
                goto LABEL_70;
              }
              goto LABEL_95;
            }
          }

          else
          {
            size_t v43 = *(unsigned __int16 **)(v41 + 24);
            if ((v42 & 0x8000) == 0) {
              goto LABEL_66;
            }
          }

          unsigned int v44 = *(_DWORD *)(v41 + 12);
          if (v44)
          {
LABEL_70:
            if (v40 <= 0xFD) {
              LODWORD(v45) = v40;
            }
            else {
              LODWORD(v45) = v44;
            }
            else {
              uint64_t v45 = v45;
            }
            LODWORD(v46) = v44 - v45;
            BOOL v47 = (int)(v44 - v45) > (int)v8 || (int)v45 < (int)v39;
            if (!v47)
            {
              uint64_t v48 = (int)v44;
              uint64_t v49 = (int)v44 - 1LL;
              uint64_t v46 = (int)v46;
              uint64_t v50 = a3 - (uint64_t)(int)v44;
              unsigned int v51 = v44 + 1;
              do
              {
                if ((int)v45 > (int)v39 || v46 > v66)
                {
                  uint64_t v52 = (int)v8 - v46;
                  int v53 = &s[v52];
                  unsigned int v54 = v51;
                  __int128 v55 = v53;
                  __int128 v56 = v43;
                  while (*v55 == *v56)
                  {
                    ++v56;
                    ++v55;
                    if ((int)--v54 <= 1)
                    {
                      if ((v52 < 1 || (*(v53 - 1) & 0xFC00) != 0xD800 || (*v53 & 0xFC00) != 0xDC00)
                        && (v52 >= v50 || (v53[v49] & 0xFC00) != 0xD800 || (v53[v48] & 0xFC00) != 0xDC00))
                      {
                        int v66 = v46;
                        goto LABEL_96;
                      }

                      break;
                    }
                  }
                }

                ++v46;
                BOOL v47 = (int)v45 <= (int)v39;
                uint64_t v45 = (v45 - 1);
              }

              while (!v47);
            }
          }

uint64_t sub_180864844(uint64_t a1, UChar *s, int a3)
{
  int v23 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  do
  {
    uint64_t v7 = icu::UnicodeSet::spanBack(*(icu::UnicodeSet **)(a1 + 208), s);
    uint64_t v8 = v7;
    if (!(_DWORD)v7) {
      return v8;
    }
    int v9 = s[(int)v7 - 1];
    BOOL v10 = (int)v7 >= 2 && (v9 & 0xFC00) == 56320;
    if (v10 && (int v11 = s[(v7 - 2)], (v11 & 0xFC00) == 0xD800))
    {
      int v12 = -2;
    }

    else
    {
      int v12 = -1;
    }

    if ((int)v6 >= 1)
    {
      uint64_t v13 = 0LL;
      while (*(unsigned __int8 *)(*(void *)(a1 + 232) + v13) == 255)
      {
LABEL_34:
        if (++v13 == v6) {
          goto LABEL_35;
        }
      }

      uint64_t v14 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v13);
      unsigned int v15 = *(unsigned __int16 *)(v14 + 8);
      if ((v15 & 0x11) != 0)
      {
        uint64_t v16 = 0LL;
        if ((v15 & 0x8000) != 0) {
          goto LABEL_23;
        }
LABEL_21:
        int v17 = v15 >> 5;
        goto LABEL_24;
      }

      if ((v15 & 2) != 0)
      {
        uint64_t v16 = (unsigned __int16 *)(v14 + 10);
        if ((v15 & 0x8000) == 0) {
          goto LABEL_21;
        }
      }

      else
      {
        uint64_t v16 = *(unsigned __int16 **)(v14 + 24);
        if ((v15 & 0x8000) == 0) {
          goto LABEL_21;
        }
      }

uint64_t sub_180864A30(uint64_t a1, char *__s, uint64_t a3, int a4)
{
  uint64_t i = a3;
  v51[3] = *MEMORY[0x1895F89C0];
  if (!a4) {
    return sub_180864EE8(a1, (uint64_t)__s, a3);
  }
  uint64_t v45 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v6 = icu::UnicodeSet::spanUTF8((icu::UnicodeSet *)(a1 + 8), __s);
  signed int v7 = i - v6;
  if ((_DWORD)i == (_DWORD)v6) {
    return i;
  }
  uint64_t v8 = v6;
  memset(v51, 0, 24);
  uint64_t v49 = (char *)v51 + 4;
  uint64_t v50 = 0LL;
  if (a4 == 1)
  {
    int v9 = *(_DWORD *)(a1 + 256);
    if (v9 > 16)
    {
      BOOL v10 = (char *)uprv_malloc(*(unsigned int *)(a1 + 256));
      if (v10)
      {
        uint64_t v49 = v10;
        LODWORD(v50) = v9;
      }

      else
      {
        int v9 = v50;
        BOOL v10 = (char *)v49;
      }
    }

    else
    {
      int v9 = 16;
      LODWORD(v50) = 16;
      BOOL v10 = (char *)v51 + 4;
    }

    bzero(v10, v9);
  }

  unsigned int v44 = i;
  uint64_t v12 = a1;
  uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  uint64_t v14 = 2LL * (int)v13;
  if (!*(_BYTE *)(a1 + 260)) {
    uint64_t v14 = 0LL;
  }
  uint64_t v15 = *(void *)(a1 + 232) + v14;
  for (uint64_t i = v8; ; uint64_t i = (v32 + i))
  {
    uint64_t v16 = *(const uint8_t **)(v12 + 240);
    uint64_t v48 = i;
    if (a4 == 1) {
      break;
    }
    if ((int)v13 < 1)
    {
      LODWORD(v32) = 0;
      int v31 = 0;
    }

    else
    {
      uint64_t v30 = 0LL;
      int v31 = 0;
      uint64_t v32 = 0LL;
      do
      {
        uint64_t v33 = *(int *)(*(void *)(v12 + 224) + 4 * v30);
        if ((_DWORD)v33)
        {
          int v34 = *(unsigned __int8 *)(v15 + v30);
          else {
            LODWORD(v35) = v34;
          }
          uint64_t v36 = (v33 - v35);
          BOOL v37 = (int)v36 > v7 || (int)v35 < v31;
          if (!v37)
          {
            uint64_t v35 = (int)v35;
            do
            {
              if (__s[(int)i - v35] >= -64 && (v35 > v31 || (int)v36 > (int)v32))
              {
                uint64_t v38 = &__s[(int)i - v35];
                int v39 = v33 + 1;
                unsigned int v40 = v16;
                while (*v38 == *v40)
                {
                  ++v40;
                  ++v38;
                  if (--v39 <= 1)
                  {
                    int v31 = v35;
                    goto LABEL_67;
                  }
                }
              }

              uint64_t v36 = (v36 + 1);
              BOOL v37 = v35-- <= v31;
            }

            while (!v37);
          }

          uint64_t v36 = v32;
LABEL_67:
          v16 += v33;
          uint64_t v32 = v36;
        }

        ++v30;
      }

      while (v30 != v13);
    }

    v7 -= v32;
    if (!v7)
    {
LABEL_90:
      uint64_t i = v44;
      goto LABEL_91;
    }

    LODWORD(v8) = 0;
LABEL_89:
    ;
  }

  if ((int)v13 >= 1)
  {
    uint64_t v17 = 0LL;
    int v18 = &__s[(int)i];
    do
    {
      uint64_t v19 = *(int *)(*(void *)(v12 + 224) + 4 * v17);
      if ((_DWORD)v19)
      {
        int32_t v20 = *(unsigned __int8 *)(v15 + v17);
        if (v20 != 255)
        {
          if (v20 == 254)
          {
            int32_t v20 = v19 - 1;
            if ((char)v16[v19 - 1] <= -65)
            {
              int32_t v21 = utf8_back1SafeBody(v16, 0, v20);
              uint64_t v12 = a1;
              int32_t v20 = v21;
            }
          }

          LODWORD(v22) = v20 >= (int)v8 ? v8 : v20;
          int v23 = v19 - v22;
          if ((int)v19 - (int)v22 <= v7)
          {
            uint64_t v22 = (int)v22;
            do
            {
              if (__s[(int)v48 - v22] >= -64)
              {
                int v24 = v50;
                int v25 = LODWORD(v51[0]) + v23 - v24;
                if (!*((_BYTE *)v49 + v25))
                {
                  uint64_t v26 = &v18[-v22];
                  int v27 = v19 + 1;
                  uint64_t v28 = v16;
                  while (*v26 == *v28)
                  {
                    ++v28;
                    ++v26;
                    if (--v27 <= 1)
                    {
                      if (v23 == v7) {
                        goto LABEL_90;
                      }
                      *((_BYTE *)v49 + v25) = 1;
                      ++HIDWORD(v50);
                      break;
                    }
                  }
                }
              }

              if (!(_DWORD)v22) {
                break;
              }
              --v22;
            }

            while (v23++ != v7);
          }
        }

        v16 += v19;
      }

      ++v17;
    }

    while (v17 != v13);
  }

uint64_t sub_180864EE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  int v6 = 0;
  uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  uint64_t v8 = 2LL * (int)v7;
  if (!*(_BYTE *)(a1 + 260)) {
    uint64_t v8 = 0LL;
  }
  uint64_t v9 = *(void *)(a1 + 232) + v8;
  BOOL v10 = (icu::UnicodeSet *)(a1 + 8);
  int v11 = a3;
  do
  {
    int v12 = icu::UnicodeSet::spanUTF8(*(icu::UnicodeSet **)(a1 + 208), (char *)(a2 + v6));
    signed int v13 = v11 - v12;
    if (!v13) {
      break;
    }
    uint64_t v14 = v6 + (uint64_t)v12;
    int v15 = sub_180865028(v10, (unsigned __int8 *)(a2 + v14), v13);
    if (v15 > 0) {
      return v14;
    }
    if ((int)v7 >= 1)
    {
      uint64_t v16 = 0LL;
      uint64_t v17 = *(unsigned __int8 **)(a1 + 240);
      do
      {
        uint64_t v18 = *(int *)(*(void *)(a1 + 224) + 4 * v16);
        if ((_DWORD)v18 && (int)v18 <= v13 && *(unsigned __int8 *)(v9 + v16) != 255)
        {
          int v19 = v18 + 1;
          int32_t v20 = (unsigned __int8 *)(a2 + v14);
          for (uint64_t i = v17; *v20 == *i; ++i)
          {
            ++v20;
            if (--v19 <= 1) {
              return v14;
            }
          }
        }

        v17 += v18;
        ++v16;
      }

      while (v16 != v7);
    }

    int v6 = v14 - v15;
    int v11 = v15 + v13;
  }

  while (v11);
  return v3;
}

uint64_t sub_180865028(icu::UnicodeSet *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3 = (char)*a2;
  unsigned int v4 = *a2;
  if ((v3 & 0x80000000) == 0)
  {
    else {
      return 0xFFFFFFFFLL;
    }
  }

  unsigned int v6 = a3;
  if (a3 == 1) {
    goto LABEL_22;
  }
  if (v4 < 0xE0)
  {
    if (v4 >= 0xC2)
    {
      int v10 = v4 & 0x1F;
      unsigned int v9 = 1;
LABEL_14:
      unsigned int v11 = a2[v9] ^ 0x80;
      if (v11 > 0x3F)
      {
        int v12 = 65533;
        unsigned int v6 = v9;
      }

      else
      {
        int v12 = v11 | (v10 << 6);
        unsigned int v6 = v9 + 1;
      }

      goto LABEL_23;
    }

    goto LABEL_21;
  }

  if (v4 <= 0xEF)
  {
    int v7 = v3 & 0xF;
    if (((a00000000000000[v3 & 0xF] >> (a2[1] >> 5)) & 1) != 0)
    {
      unsigned int v8 = a2[1] & 0x3F;
      unsigned int v9 = 2;
      goto LABEL_10;
    }

uint64_t sub_18086515C(uint64_t a1, uint8_t *s, int a3, int a4)
{
  v56[3] = *MEMORY[0x1895F89C0];
  if (!a4) {
    return sub_180865718(a1, s);
  }
  uint64_t v52 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v8 = icu::UnicodeSet::spanBackUTF8((icu::UnicodeSet *)(a1 + 8), s);
  if (!(_DWORD)v8) {
    return 0LL;
  }
  uint64_t v9 = v8;
  int v10 = a3 - v8;
  memset(v56, 0, 24);
  unsigned int v54 = (char *)v56 + 4;
  uint64_t v55 = 0LL;
  if (a4 == 1)
  {
    int v11 = *(_DWORD *)(a1 + 256);
    if (v11 > 16)
    {
      int v12 = (char *)uprv_malloc(*(unsigned int *)(a1 + 256));
      if (v12)
      {
        unsigned int v54 = v12;
        LODWORD(v55) = v11;
      }

      else
      {
        int v11 = v55;
        int v12 = (char *)v54;
      }
    }

    else
    {
      int v11 = 16;
      LODWORD(v55) = 16;
      int v12 = (char *)v56 + 4;
    }

    bzero(v12, v11);
  }

  uint64_t v15 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  uint64_t v16 = 3LL * (int)v15;
  if (!*(_BYTE *)(a1 + 260)) {
    uint64_t v16 = 0LL;
  }
  uint64_t v17 = *(void *)(a1 + 232) + v16;
  while (1)
  {
    while (1)
    {
      uint64_t v18 = *(unsigned __int8 **)(a1 + 240);
      if (a4 == 1) {
        break;
      }
      if ((int)v15 < 1)
      {
        int v35 = 0;
        LODWORD(v34) = 0;
      }

      else
      {
        uint64_t v33 = 0LL;
        uint64_t v34 = 0LL;
        int v35 = 0;
        do
        {
          uint64_t v36 = *(int *)(*(void *)(a1 + 224) + 4 * v33);
          if ((_DWORD)v36)
          {
            LODWORD(v37) = *(unsigned __int8 *)(v17 + v33);
            else {
              uint64_t v37 = v37;
            }
            LODWORD(v38) = v36 - v37;
            if ((int)v36 - (int)v37 <= (int)v9 && (int)v37 >= (int)v34)
            {
              uint64_t v38 = (int)v38;
              do
              {
                if ((char)s[(int)v9 - v38] >= -64 && ((int)v37 > (int)v34 || v38 > v35))
                {
                  unsigned int v40 = &s[(int)v9 - v38];
                  int v41 = v36 + 1;
                  int v42 = v18;
                  while (*v40 == *v42)
                  {
                    ++v42;
                    ++v40;
                    if (--v41 <= 1)
                    {
                      int v35 = v38;
                      goto LABEL_86;
                    }
                  }
                }

                ++v38;
                BOOL v25 = (int)v37 <= (int)v34;
                uint64_t v37 = (v37 - 1);
              }

              while (!v25);
            }

            uint64_t v37 = v34;
LABEL_86:
            v18 += v36;
            uint64_t v34 = v37;
          }

          ++v33;
        }

        while (v33 != v15);
      }

      int v10 = 0;
      uint64_t v14 = 0LL;
      uint64_t v9 = (v9 - v35);
      if (!(_DWORD)v9) {
        goto LABEL_118;
      }
    }

    if ((int)v15 >= 1)
    {
      uint64_t v19 = 0LL;
      while (1)
      {
        uint64_t v20 = *(int *)(*(void *)(a1 + 224) + 4 * v19);
        if ((_DWORD)v20) {
          break;
        }
LABEL_58:
        if (++v19 == v15) {
          goto LABEL_91;
        }
      }

      int v21 = *(unsigned __int8 *)(v17 + v19);
      if (v21 == 255)
      {
LABEL_57:
        v18 += v20;
        goto LABEL_58;
      }

      if (v21 != 254)
      {
LABEL_42:
        if (v21 >= v10) {
          int v21 = v10;
        }
        LODWORD(v26) = v20 - v21;
        if ((int)v20 - v21 <= (int)v9)
        {
          uint64_t v26 = (int)v26;
          do
          {
            if ((char)s[(int)v9 - v26] >= -64)
            {
              int v27 = v55;
              int v28 = LODWORD(v56[0]) + v26 - v27;
              unsigned int v29 = (char *)v54;
              if (!*((_BYTE *)v54 + v28))
              {
                uint64_t v30 = &s[(int)v9 - v26];
                int v31 = v20 + 1;
                uint64_t v32 = v18;
                while (*v30 == *v32)
                {
                  ++v32;
                  ++v30;
                  if (--v31 <= 1)
                  {
                    if ((_DWORD)v9 != (_DWORD)v26)
                    {
                      *((_BYTE *)v54 + v28) = 1;
                      ++HIDWORD(v55);
                      break;
                    }

                    uint64_t v14 = 0LL;
                    goto LABEL_119;
                  }
                }
              }
            }

            if (!v21) {
              break;
            }
            --v21;
            ++v26;
          }

          while ((_DWORD)v9 + 1 != (_DWORD)v26);
        }

        goto LABEL_57;
      }

      int v22 = -1;
      if ((_DWORD)v20 != 1)
      {
        unsigned int v23 = *v18;
        if ((v23 + 11) >= 0xCDu)
        {
          unint64_t v24 = v18[1];
          if ((v23 & 0xF0) == 0xE0)
          {
            if (((a00000000000000[v23 & 0xF] >> (v18[1] >> 5)) & 1) != 0)
            {
              if ((_DWORD)v20 != 2)
              {
                BOOL v25 = (char)v18[2] < -64;
                int v22 = -3;
                goto LABEL_27;
              }

              goto LABEL_40;
            }

            goto LABEL_39;
          }

          if (v23 <= 0xDF)
          {
            else {
              int v22 = -1;
            }
            goto LABEL_41;
          }

          if (((byte_180A27203[v24 >> 4] >> (v23 & 7)) & 1) == 0)
          {
LABEL_39:
            int v22 = -1;
            goto LABEL_41;
          }

          if ((_DWORD)v20 == 2 || (char)v18[2] > -65)
          {
LABEL_40:
            int v22 = -2;
            goto LABEL_41;
          }

          if ((_DWORD)v20 != 3)
          {
            BOOL v25 = (char)v18[3] < -64;
            int v22 = -4;
LABEL_27:
            if (!v25) {
              ++v22;
            }
            goto LABEL_41;
          }

          int v22 = -3;
        }
      }

uint64_t sub_180865718(uint64_t a1, uint8_t *s)
{
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 216) + 8LL);
  uint64_t v5 = 3LL * (int)v4;
  if (!*(_BYTE *)(a1 + 260)) {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 232) + v5;
  int v7 = (icu::UnicodeSet *)(a1 + 8);
  while (1)
  {
    uint64_t v8 = icu::UnicodeSet::spanBackUTF8(*(icu::UnicodeSet **)(a1 + 208), s);
    uint64_t v9 = v8;
    if (!(_DWORD)v8) {
      break;
    }
    uint64_t v10 = (int)v8 - 1LL;
    UChar32 v11 = s[v10];
    if ((char)s[v10] < 0)
    {
      puint64_t i = v8 - 1;
      UChar32 v13 = utf8_prevCharSafeBody(s, 0, &pi, v11, -3);
      int v14 = v9 - pi;
      else {
        int v12 = -v14;
      }
      if (v12 > 0) {
        return v9;
      }
    }

    else
    {
      int v12 = -1;
    }

    if ((int)v4 >= 1)
    {
      uint64_t v15 = 0LL;
      uint64_t v16 = *(unsigned __int8 **)(a1 + 240);
      do
      {
        uint64_t v17 = *(int *)(*(void *)(a1 + 224) + 4 * v15);
        if ((_DWORD)v17 && (int)v17 <= (int)v9 && *(unsigned __int8 *)(v6 + v15) != 255)
        {
          uint64_t v18 = &s[(int)v9 - v17];
          int v19 = v17 + 1;
          for (uint64_t i = v16; *v18 == *i; ++i)
          {
            ++v18;
            if (--v19 <= 1) {
              return v9;
            }
          }
        }

        v16 += v17;
        ++v15;
      }

      while (v15 != v4);
    }

    if (!(v12 + (_DWORD)v9)) {
      return 0LL;
    }
  }

  return v9;
}

void *icu::UnicodeString::getStaticClassID(icu::UnicodeString *this)
{
  return &unk_18C5350B0;
}

void *icu::UnicodeString::getDynamicClassID(icu::UnicodeString *this)
{
  return &unk_18C5350B0;
}

void icu::operator+(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  int v7 = (__int16)v6;
  unsigned int v8 = v6 >> 5;
  if (v7 < 0) {
    unsigned int v8 = *(_DWORD *)(a1 + 12);
  }
  unsigned int v9 = *(unsigned __int16 *)(a2 + 8);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 < 0) {
    unsigned int v11 = *(_DWORD *)(a2 + 12);
  }
  int v22 = off_18971B688;
  __int16 v23 = 0;
  icu::UnicodeString::allocate((icu::UnicodeString *)&v22, v8 + v11 + 1);
  unsigned int v12 = *(unsigned __int16 *)(a1 + 8);
  int v13 = (__int16)v12;
  unsigned int v14 = v12 >> 5;
  if (v13 >= 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = *(unsigned int *)(a1 + 12);
  }
  uint64_t v16 = icu::UnicodeString::doAppend((uint64_t)&v22, (const icu::UnicodeString *)a1, 0, v15);
  unsigned int v17 = *(unsigned __int16 *)(a2 + 8);
  int v18 = (__int16)v17;
  unsigned int v19 = v17 >> 5;
  if (v18 >= 0) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = *(unsigned int *)(a2 + 12);
  }
  int v21 = (UChar **)icu::UnicodeString::doAppend(v16, (const icu::UnicodeString *)a2, 0, v20);
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  icu::UnicodeString::copyFrom((UChar **)a3, v21, 0);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v22);
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, UChar **a2)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  return icu::UnicodeString::copyFrom((UChar **)this, a2, 0);
}

{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  return icu::UnicodeString::copyFrom((UChar **)this, a2, 0);
}

uint64_t icu::UnicodeString::addRef(uint64_t this)
{
  int v1 = (unsigned int *)(*(void *)(this + 24) - 4LL);
  do
    unsigned int v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

uint64_t icu::UnicodeString::removeRef(icu::UnicodeString *this)
{
  int v1 = (unsigned int *)(*((void *)this + 3) - 4LL);
  do
  {
    unsigned int v2 = __ldaxr(v1);
    uint64_t result = v2 - 1;
  }

  while (__stlxr(result, v1));
  return result;
}

uint64_t icu::UnicodeString::refCount(icu::UnicodeString *this)
{
  return atomic_load((unsigned int *)(*((void *)this + 3) - 4LL));
}

void icu::UnicodeString::releaseArray(icu::UnicodeString *this)
{
  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    int v1 = (unsigned int *)(*((void *)this + 3) - 4LL);
    do
    {
      unsigned int v2 = __ldaxr(v1);
      unsigned int v3 = v2 - 1;
    }

    while (__stlxr(v3, v1));
    if (!v3) {
      uprv_free((void *)(*((void *)this + 3) - 4LL));
    }
  }

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, int a2, unsigned int a3, int a4)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 0;
  if (HIWORD(a3) > 0x10u || a4 <= 0) {
    goto LABEL_10;
  }
  if (!HIWORD(a3))
  {
    if (a2 <= a4) {
      a2 = a4;
    }
    if (icu::UnicodeString::allocate(this, a2))
    {
      if ((*((_WORD *)this + 4) & 2) != 0) {
        int v7 = (_WORD *)((char *)this + 10);
      }
      else {
        int v7 = (_WORD *)*((void *)this + 3);
      }
      uint64_t v11 = a4;
      do
      {
        *v7++ = a3;
        --v11;
      }

      while (v11);
      if (a4 <= 1023)
      {
        __int16 v12 = *((_WORD *)this + 4) & 0x1F | (32 * a4);
LABEL_28:
        *((_WORD *)this + 4) = v12;
        return this;
      }

      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a4;
    }

    return this;
  }

  if (a4 >> 30)
  {
LABEL_10:
    icu::UnicodeString::allocate(this, a2);
    return this;
  }

  unint64_t v9 = (2 * a4);
  if (icu::UnicodeString::allocate(this, a2))
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v10 = (char *)this + 10;
    }
    else {
      int v10 = (char *)*((void *)this + 3);
    }
    unint64_t v13 = 0LL;
    do
    {
      unsigned int v14 = &v10[2 * v13];
      *(_WORD *)unsigned int v14 = (a3 >> 10) - 10304;
      *((_WORD *)v14 + 1) = a3 & 0x3FF | 0xDC00;
      v13 += 2LL;
    }

    while (v13 < v9);
    if (a4 > 0x1FF)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = v9;
      return this;
    }

    __int16 v12 = *((_WORD *)this + 4) & 0x1F | (32 * v9);
    goto LABEL_28;
  }

  return this;
}

uint64_t icu::UnicodeString::allocate(icu::UnicodeString *this, int a2)
{
  if (a2 > 27)
  {
    if (a2 <= 0x7FFFFFF5
      && (size_t v4 = (2LL * (a2 + 1) + 19) & 0x3FFFFFFF0LL, (v5 = uprv_malloc(v4)) != 0LL))
    {
      unsigned int v6 = v5;
      uint64_t result = 1LL;
      *unsigned int v6 = 1;
      *((void *)this + 3) = v6 + 1;
      *((_DWORD *)this + 4) = (v4 + 0x1FFFFFFFCLL) >> 1;
      *((_WORD *)this + 4) = 4;
    }

    else
    {
      uint64_t result = 0LL;
      *((_WORD *)this + 4) = 1;
      *((void *)this + 3) = 0LL;
      *((_DWORD *)this + 4) = 0;
    }
  }

  else
  {
    *((_WORD *)this + 4) = 2;
    return 1LL;
  }

  return result;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t result, __int16 a2)
{
  *(void *)uint64_t result = off_18971B688;
  *(_WORD *)(result + 8) = 34;
  *(_WORD *)(result + 10) = a2;
  return result;
}

{
  *(void *)uint64_t result = off_18971B688;
  *(_WORD *)(result + 8) = 34;
  *(_WORD *)(result + 10) = a2;
  return result;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t this, unsigned int a2)
{
  *(void *)this = off_18971B688;
  *(_WORD *)(this + 8) = 2;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u) {
      return this;
    }
    *(_WORD *)(this + 10) = (a2 >> 10) - 10304;
    __int16 v2 = 66;
    uint64_t v3 = 12LL;
    LOWORD(a2) = a2 & 0x3FF | 0xDC00;
  }

  else
  {
    __int16 v2 = 34;
    uint64_t v3 = 10LL;
  }

  *(_WORD *)(this + v3) = a2;
  *(_WORD *)(this + 8) = v2;
  return this;
}

{
  __int16 v2;
  uint64_t v3;
  *(void *)this = off_18971B688;
  *(_WORD *)(this + 8) = 2;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u) {
      return this;
    }
    *(_WORD *)(this + 10) = (a2 >> 10) - 10304;
    __int16 v2 = 66;
    uint64_t v3 = 12LL;
    LOWORD(a2) = a2 & 0x3FF | 0xDC00;
  }

  else
  {
    __int16 v2 = 34;
    uint64_t v3 = 10LL;
  }

  *(_WORD *)(this + v3) = a2;
  *(_WORD *)(this + 8) = v2;
  return this;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, 0xFFFFFFFFLL);
  return a1;
}

{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, 0xFFFFFFFFLL);
  return a1;
}

uint64_t icu::UnicodeString::doAppend(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = a1;
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return v4;
  }
  uint64_t v5 = a4;
  if (!(_DWORD)a4) {
    return v4;
  }
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 0x11) != 0) {
    return v4;
  }
  int v7 = (const void *)(a2 + 2LL * a3);
  if ((a4 & 0x80000000) != 0)
  {
    uint64_t v9 = u_strlen((const UChar *)(a2 + 2LL * a3));
    if (!(_DWORD)v9) {
      return v4;
    }
    uint64_t v5 = v9;
    unsigned int v6 = *(unsigned __int16 *)(v4 + 8);
    if ((v6 & 0x8000) == 0) {
      goto LABEL_6;
    }
  }

  else if ((v6 & 0x8000) == 0)
  {
LABEL_6:
    LODWORD(v8) = v6 >> 5;
    goto LABEL_10;
  }

  LODWORD(v8) = *(_DWORD *)(v4 + 12);
LABEL_10:
  int v25 = 0;
  if (uprv_add32_overflow(v8, v5, &v25))
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)v4);
    return v4;
  }

  __int16 v11 = *(_WORD *)(v4 + 8);
  if ((v11 & 2) != 0) {
    unint64_t v12 = v4 + 10;
  }
  else {
    unint64_t v12 = *(void *)(v4 + 24);
  }
  if ((v11 & 0x19) != 0)
  {
    uint64_t v8 = (int)v8;
  }

  else
  {
    if ((v11 & 4) != 0)
    {
      unsigned int v14 = atomic_load((unsigned int *)(*(void *)(v4 + 24) - 4LL));
      BOOL v13 = v14 == 1;
    }

    else
    {
      BOOL v13 = 1;
    }

    if (v13 && v12 < (unint64_t)v7 + 2 * (int)v5 && (unint64_t)v7 < v12 + 2LL * (int)v8)
    {
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      uint64_t v30 = 0LL;
      __int128 v29 = 0u;
      uint64_t v26 = off_18971B688;
      LOWORD(v27) = 2;
      icu::UnicodeString::doAppend(&v26, v7, 0LL, v5);
      if ((v27 & 1) != 0)
      {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)v4);
      }

      else
      {
        if ((v27 & 2) != 0) {
          uint64_t v15 = (char *)&v27 + 2;
        }
        else {
          uint64_t v15 = (char *)v28;
        }
        uint64_t v4 = icu::UnicodeString::doAppend(v4, v15, 0LL, v5);
      }

      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v26);
      return v4;
    }

    uint64_t v8 = (int)v8;
    __int16 v11 = *(_WORD *)(v4 + 8);
  }

  int v16 = v25;
  if ((v11 & 2) != 0) {
    int v17 = 27;
  }
  else {
    int v17 = *(_DWORD *)(v4 + 16);
  }
  if (v25 <= v17 && (v11 & 0x19) == 0)
  {
    if ((v11 & 4) == 0 || (unsigned int v24 = atomic_load((unsigned int *)(*(void *)(v4 + 24) - 4LL)), v24 == 1))
    {
LABEL_39:
      __int16 v20 = *(_WORD *)(v4 + 8);
      if ((v20 & 2) != 0) {
        uint64_t v21 = v4 + 10;
      }
      else {
        uint64_t v21 = *(void *)(v4 + 24);
      }
      if ((int)v5 >= 1)
      {
        int v22 = (void *)(v21 + 2 * v8);
        if (v7 != v22)
        {
          memmove(v22, v7, 2LL * v5);
          __int16 v20 = *(_WORD *)(v4 + 8);
        }
      }

      int v23 = v25;
      if (v25 > 1023)
      {
        *(_WORD *)(v4 + 8) = v20 | 0xFFE0;
        *(_DWORD *)(v4 + 12) = v23;
      }

      else
      {
        *(_WORD *)(v4 + 8) = v20 & 0x1F | (32 * v25);
      }

      return v4;
    }

    int v16 = v25;
  }

  int v18 = (v16 >> 2) + 128;
  if (v18 <= 2147483637 - v16) {
    int v19 = v18 + v16;
  }
  else {
    int v19 = 2147483637;
  }
  return v4;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, a3);
  return a1;
}

{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, a3);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, int a2, const UChar **a3, int32_t a4)
{
  *(void *)this = off_18971B688;
  LOBYTE(v5) = 8;
  *((_WORD *)this + 4) = 8;
  unsigned int v6 = *a3;
  if (!*a3)
  {
    *((_WORD *)this + 4) = 2;
    return this;
  }

  if (a4 < -1 || !a2 && a4 == -1) {
    goto LABEL_8;
  }
  if (!a2 || a4 < 0)
  {
    if (a4 == -1)
    {
      a4 = u_strlen(*a3);
      __int16 v5 = *((_WORD *)this + 4);
    }
  }

  else
  {
    if (v6[a4])
    {
LABEL_8:
      icu::UnicodeString::setToBogus(this);
      return this;
    }

    LOBYTE(v5) = 8;
  }

  if (a2) {
    int32_t v8 = a4 + 1;
  }
  else {
    int32_t v8 = a4;
  }
  if (a4 > 1023)
  {
    __int16 v9 = v5 | 0xFFE0;
    *((_DWORD *)this + 3) = a4;
  }

  else
  {
    __int16 v9 = v5 & 0x1F | (32 * a4);
  }

  *((_WORD *)this + 4) = v9;
  *((void *)this + 3) = v6;
  *((_DWORD *)this + 4) = v8;
  return this;
}

void icu::UnicodeString::setToBogus(icu::UnicodeString *this)
{
  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    __int16 v2 = (unsigned int *)(*((void *)this + 3) - 4LL);
    do
    {
      unsigned int v3 = __ldaxr(v2);
      unsigned int v4 = v3 - 1;
    }

    while (__stlxr(v4, v2));
    if (!v4) {
      uprv_free((void *)(*((void *)this + 3) - 4LL));
    }
  }

  *((_WORD *)this + 4) = 1;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 4) = 0;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, char *a2, unint64_t a3, unsigned int a4)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 0;
  if (a2)
  {
    if ((int)a3 > (int)a4 || (int)a3 < -1 || (a4 & 0x80000000) != 0)
    {
      icu::UnicodeString::setToBogus(this);
    }

    else
    {
      if ((_DWORD)a3 == -1)
      {
        __int16 v5 = a2;
        if (a4)
        {
          uint64_t v6 = 2LL * a4;
          __int16 v5 = a2;
          while (*(_WORD *)v5)
          {
            v5 += 2;
            v6 -= 2LL;
            if (!v6)
            {
              __int16 v5 = &a2[2 * a4];
              break;
            }
          }
        }

        a3 = (unint64_t)(v5 - a2) >> 1;
      }

      if ((int)a3 > 1023)
      {
        *((_DWORD *)this + 3) = a3;
        __int16 v7 = -32;
      }

      else
      {
        __int16 v7 = 32 * a3;
      }

      *((_WORD *)this + 4) = v7;
      *((void *)this + 3) = a2;
      *((_DWORD *)this + 4) = a4;
    }
  }

  else
  {
    *((_WORD *)this + 4) = 2;
  }

  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, char *__s, int32_t a3)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (__s)
  {
    int32_t v4 = a3;
    if (a3 < 0) {
      int32_t v4 = strlen(__s);
    }
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v4, v4, 0, 0LL, 0))
    {
      if ((*((_WORD *)this + 4) & 2) != 0) {
        uint64_t v6 = (UChar *)((char *)this + 10);
      }
      else {
        uint64_t v6 = (UChar *)*((void *)this + 3);
      }
      u_charsToUChars(__s, v6, v4);
      if (v4 > 1023)
      {
        *((_WORD *)this + 4) |= 0xFFE0u;
        *((_DWORD *)this + 3) = v4;
      }

      else
      {
        *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * v4);
      }
    }

    else
    {
      icu::UnicodeString::setToBogus(this);
    }
  }

  return this;
}

uint64_t icu::UnicodeString::cloneArrayIfNeeded( icu::UnicodeString *this, int a2, int a3, int a4, unsigned int **a5, int a6)
{
  int v8 = a2;
  v26[7] = *MEMORY[0x1895F89C0];
  unsigned int v10 = *((unsigned __int16 *)this + 4);
  if (a2 == -1)
  {
    if ((v10 & 2) != 0) {
      int v8 = 27;
    }
    else {
      int v8 = *((_DWORD *)this + 4);
    }
  }

  if ((v10 & 0x11) != 0) {
    return 0LL;
  }
  if (!a6 && (v10 & 8) == 0)
  {
    if ((v10 & 4) == 0
      || (int v12 = atomic_load((unsigned int *)(*((void *)this + 3) - 4LL)),
          unsigned int v10 = *((unsigned __int16 *)this + 4),
          v12 <= 1))
    {
      int v13 = (v10 & 2) != 0 ? 27 : *((_DWORD *)this + 4);
      if (v8 <= v13) {
        return 1LL;
      }
    }
  }

  if (v8 >= 28 || a3 <= 27) {
    int v15 = a3;
  }
  else {
    int v15 = 27;
  }
  memset(&v26[2], 0, 38);
  if (a3 >= 0) {
    int v16 = v15;
  }
  else {
    int v16 = v8;
  }
  *(_OWORD *)uint64_t v26 = 0uLL;
  if ((v10 & 0x8000) != 0)
  {
    int v17 = *((_DWORD *)this + 3);
    if ((v10 & 2) == 0) {
      goto LABEL_26;
    }
  }

  else
  {
    int v17 = v10 >> 5;
    if ((v10 & 2) == 0)
    {
LABEL_26:
      int v18 = (void *)*((void *)this + 3);
      goto LABEL_32;
    }
  }

  int v18 = 0LL;
  if (a4)
  {
    if (v16 >= 28)
    {
      int v18 = v26;
      if (v17 >= 1) {
        memcpy(v26, (char *)this + 10, 2LL * v17);
      }
    }
  }

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *a2)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (a2)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
    icu::UnicodeString::setToUTF8((uint64_t)this, v4, v5);
  }

  return this;
}

uint64_t icu::UnicodeString::setToUTF8(uint64_t a1, const char *a2, int32_t a3)
{
  if ((*(_WORD *)(a1 + 8) & 1) != 0) {
    *(_WORD *)(a1 + 8) = 2;
  }
  int32_t v6 = 27;
  if (a3 > 27) {
    int v7 = a3 + 1;
  }
  else {
    int v7 = 27;
  }
  Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a1, v7);
  *(void *)pErrorCode = 0LL;
  if ((*(_WORD *)(a1 + 8) & 2) == 0) {
    int32_t v6 = *(_DWORD *)(a1 + 16);
  }
  u_strFromUTF8WithSub(Buffer, v6, (int32_t *)&pErrorCode[1], a2, a3, 65533, 0LL, pErrorCode);
  icu::UnicodeString::releaseBuffer(a1, pErrorCode[1]);
  if (pErrorCode[0] >= U_ILLEGAL_ARGUMENT_ERROR) {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a1);
  }
  return a1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, int32_t a3)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (a3 >= -1 && __s && a3)
  {
    if (a3 == -1) {
      a3 = strlen(__s);
    }
    icu::UnicodeString::setToUTF8((uint64_t)this, __s, a3);
  }

  return this;
}

icu::UnicodeString *icu::UnicodeString::copyFrom(UChar **this, UChar **a2, int a3)
{
  if (this != a2)
  {
    if (((_WORD)a2[1] & 1) != 0)
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    }

    else
    {
      if (((_WORD)this[1] & 4) != 0)
      {
        int32_t v6 = (unsigned int *)(this[3] - 2);
        do
        {
          unsigned int v7 = __ldaxr(v6);
          unsigned int v8 = v7 - 1;
        }

        while (__stlxr(v8, v6));
        if (!v8) {
          uprv_free(this[3] - 2);
        }
      }

      unsigned int v9 = *((unsigned __int16 *)a2 + 4);
      if (v9 <= 0x1F)
      {
        __int16 v11 = 2;
LABEL_13:
        *((_WORD *)this + 4) = v11;
      }

      else
      {
        *((_WORD *)this + 4) = v9;
        unsigned int v10 = *((unsigned __int16 *)a2 + 4);
        switch(v10 & 0x1F)
        {
          case 0u:
            goto LABEL_21;
          case 2u:
            memcpy((char *)this + 10, (char *)a2 + 10, 2 * ((__int16)v9 >> 5));
            return (icu::UnicodeString *)this;
          case 4u:
            int v12 = (unsigned int *)(a2[3] - 2);
            do
              unsigned int v13 = __ldaxr(v12);
            while (__stlxr(v13 + 1, v12));
            this[3] = a2[3];
            *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
            return (icu::UnicodeString *)this;
          case 8u:
            if (a3)
            {
              this[3] = a2[3];
              *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
              if ((v9 & 0x8000) != 0) {
LABEL_20:
              }
                *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
            }

            else
            {
LABEL_21:
              int v14 = (__int16)v10;
              int v15 = v10 >> 5;
              if (v14 >= 0) {
                int v16 = v15;
              }
              else {
                int v16 = *((_DWORD *)a2 + 3);
              }
              if (!icu::UnicodeString::allocate((icu::UnicodeString *)this, v16))
              {
LABEL_27:
                *((_WORD *)this + 4) = 1;
                this[3] = 0LL;
                *((_DWORD *)this + 4) = 0;
                return (icu::UnicodeString *)this;
              }

              if (((_WORD)this[1] & 2) != 0) {
                int v17 = (UChar *)this + 5;
              }
              else {
                int v17 = this[3];
              }
              if (((_WORD)a2[1] & 2) != 0) {
                int v18 = (const UChar *)a2 + 5;
              }
              else {
                int v18 = a2[3];
              }
              u_memcpy(v17, v18, v16);
              if (v16 <= 1023)
              {
                __int16 v11 = (_WORD)this[1] & 0x1F | (32 * v16);
                goto LABEL_13;
              }

              *((_WORD *)this + 4) |= 0xFFE0u;
              *((_DWORD *)this + 3) = v16;
            }

            break;
          default:
            goto LABEL_27;
        }
      }
    }
  }

  return (icu::UnicodeString *)this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *a1, icu::UnicodeString *a2)
{
  *(void *)a1 = off_18971B688;
  icu::UnicodeString::copyFieldsFrom(a1, a2, 1);
  return a1;
}

{
  *(void *)a1 = off_18971B688;
  icu::UnicodeString::copyFieldsFrom(a1, a2, 1);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::copyFieldsFrom( icu::UnicodeString *this, icu::UnicodeString *a2, int a3)
{
  int v3 = *((__int16 *)a2 + 4);
  *((_WORD *)this + 4) = *((_WORD *)a2 + 4);
  if ((v3 & 2) != 0)
  {
    if (this != a2) {
      return (icu::UnicodeString *)memcpy((char *)this + 10, (char *)a2 + 10, 2 * (v3 >> 5));
    }
  }

  else
  {
    *((void *)this + 3) = *((void *)a2 + 3);
    *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
    if ((v3 & 0x80000000) == 0)
    {
      if (!a3) {
        return this;
      }
LABEL_8:
      *((_WORD *)a2 + 4) = 1;
      *((void *)a2 + 3) = 0LL;
      *((_DWORD *)a2 + 4) = 0;
      return this;
    }

    *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
    if (a3) {
      goto LABEL_8;
    }
  }

  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, const icu::UnicodeString *a2, int a3)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  unsigned int v4 = *((unsigned __int16 *)a2 + 4);
  unsigned int v5 = v4 >> 5;
  if (a3 < 0)
  {
    int v7 = 0;
    goto LABEL_7;
  }

  int v6 = a3;
  if ((v4 & 0x8000) != 0)
  {
    int v7 = *((_DWORD *)a2 + 3);
    if (v7 >= a3) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  int v7 = v4 >> 5;
  if (v5 < a3) {
LABEL_7:
  }
    int v6 = v7;
LABEL_8:
  if ((v4 & 0x8000u) != 0) {
    unsigned int v5 = *((_DWORD *)a2 + 3);
  }
  icu::UnicodeString::doReplace(this, 0LL, 0LL, a2, v6, v5 - v6);
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  icu::UnicodeString::doReplace(this, 0LL, 0LL, a2, a3, a4);
  return this;
}

{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  icu::UnicodeString::doReplace(this, 0LL, 0LL, a2, a3, a4);
  return this;
}

uint64_t icu::Replaceable::clone(icu::Replaceable *this)
{
  return 0LL;
}

icu::UnicodeString *icu::UnicodeString::clone@<X0>( UChar **this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new(a3, (icu::UMemory *)0x40, a2);
  if (result)
  {
    *(void *)uint64_t result = off_18971B688;
    *((_WORD *)result + 4) = 2;
    uint64_t result = icu::UnicodeString::copyFrom((UChar **)result, this, 0);
    if ((*((_WORD *)result + 4) & 1) != 0)
    {
      (*(void (**)(icu::UnicodeString *))(*(void *)result + 8LL))(result);
      return 0LL;
    }
  }

  return result;
}

void icu::UnicodeString::~UnicodeString(icu::UnicodeString *this)
{
  *(void *)this = off_18971B688;
  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    __int16 v2 = (unsigned int *)(*((void *)this + 3) - 4LL);
    do
    {
      unsigned int v3 = __ldaxr(v2);
      unsigned int v4 = v3 - 1;
    }

    while (__stlxr(v4, v2));
    if (!v4) {
      uprv_free((void *)(*((void *)this + 3) - 4LL));
    }
  }

  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::UnicodeString::~UnicodeString(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnicodeString::fromUTF8@<X0>(const char *a1@<X0>, int32_t a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  return icu::UnicodeString::setToUTF8(a3, a1, a2);
}

void icu::UnicodeString::fromUTF32(const UChar32 *this@<X0>, const int *a2@<X1>, uint64_t a3@<X8>)
{
  int32_t v3 = (int)a2;
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  else {
    int v6 = (_DWORD)a2 + (a2 >> 4) + 4;
  }
  while (1)
  {
    Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a3, v6);
    *(void *)pErrorCode = 0LL;
    int32_t v8 = (*(_WORD *)(a3 + 8) & 2) != 0 ? 27 : *(_DWORD *)(a3 + 16);
    u_strFromUTF32WithSub(Buffer, v8, (int32_t *)&pErrorCode[1], this, v3, 65533, 0LL, pErrorCode);
    UErrorCode v9 = pErrorCode[1];
    icu::UnicodeString::releaseBuffer(a3, pErrorCode[1]);
    if (pErrorCode[0] != U_BUFFER_OVERFLOW_ERROR) {
      break;
    }
    int v6 = v9 + 1;
  }

  if (pErrorCode[0] >= U_ILLEGAL_ARGUMENT_ERROR) {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
  }
}

uint64_t icu::UnicodeString::getBuffer(icu::UnicodeString *this, int a2)
{
  if (a2 < -1) {
    return 0LL;
  }
  __int16 v3 = *((_WORD *)this + 4);
  *((_WORD *)this + 4) = v3 & 0xF | 0x10;
  if ((v3 & 2) != 0) {
    return (uint64_t)this + 10;
  }
  else {
    return *((void *)this + 3);
  }
}

uint64_t icu::UnicodeString::releaseBuffer(uint64_t this, int a2)
{
  if (a2 < -1) {
    return this;
  }
  __int16 v2 = *(_WORD *)(this + 8);
  if ((v2 & 0x10) == 0) {
    return this;
  }
  if ((v2 & 2) != 0)
  {
    if (a2 == -1)
    {
      unsigned int v4 = (char *)(this + 10);
      unint64_t v5 = this + 64;
      goto LABEL_13;
    }

    int v3 = 27;
  }

  else
  {
    int v3 = *(_DWORD *)(this + 16);
    if (a2 == -1)
    {
      unsigned int v4 = *(char **)(this + 24);
      if (v3 < 1)
      {
        int v7 = *(char **)(this + 24);
LABEL_18:
        unint64_t v6 = (unint64_t)(v7 - v4) >> 1;
        goto LABEL_19;
      }

      unint64_t v5 = (unint64_t)&v4[2 * v3];
LABEL_13:
      int v7 = v4;
      do
      {
        if (!*(_WORD *)v7) {
          break;
        }
        v7 += 2;
      }

      while ((unint64_t)v7 < v5);
      goto LABEL_18;
    }
  }

  if (v3 >= a2) {
    LODWORD(v6) = a2;
  }
  else {
    LODWORD(v6) = v3;
  }
LABEL_19:
  if ((int)v6 > 1023)
  {
    __int16 v8 = v2 | 0xFFE0;
    *(_DWORD *)(this + 12) = v6;
  }

  else
  {
    __int16 v8 = *(_WORD *)(this + 8) & 0x1F | (32 * v6);
  }

  *(_WORD *)(this + 8) = v8 & 0xFFEF;
  return this;
}

icu::UnicodeString *icu::UnicodeString::operator=(UChar **a1, UChar **a2)
{
  return icu::UnicodeString::copyFrom(a1, a2, 0);
}

icu::UnicodeString *icu::UnicodeString::fastCopyFrom(UChar **this, UChar **a2)
{
  return icu::UnicodeString::copyFrom(this, a2, 1);
}

icu::UnicodeString *icu::UnicodeString::operator=(icu::UnicodeString *this, icu::UnicodeString *a2)
{
  if ((*((_WORD *)this + 4) & 4) != 0)
  {
    unsigned int v4 = (unsigned int *)(*((void *)this + 3) - 4LL);
    do
    {
      unsigned int v5 = __ldaxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stlxr(v6, v4));
    if (!v6) {
      uprv_free((void *)(*((void *)this + 3) - 4LL));
    }
  }

  icu::UnicodeString::copyFieldsFrom(this, a2, 1);
  return this;
}

void icu::UnicodeString::swap( icu::UnicodeString *this, void (***a2)(icu::UnicodeString *__hidden this))
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  uint64_t v9 = 0LL;
  __int128 v8 = 0u;
  unsigned int v5 = off_18971B688;
  LOWORD(v6) = 2;
  icu::UnicodeString::copyFieldsFrom((icu::UnicodeString *)&v5, this, 0);
  icu::UnicodeString::copyFieldsFrom(this, (icu::UnicodeString *)a2, 0);
  int v4 = (__int16)v6;
  *((_WORD *)a2 + 4) = v6;
  if ((v4 & 2) != 0)
  {
    if (&v5 != a2) {
      memcpy((char *)a2 + 10, (char *)&v6 + 2, 2 * (v4 >> 5));
    }
  }

  else
  {
    a2[3] = (void (**)(icu::UnicodeString *__hidden))v7;
    *((_DWORD *)a2 + 4) = DWORD2(v6);
    if (v4 < 0) {
      *((_DWORD *)a2 + 3) = DWORD1(v6);
    }
  }

  LOWORD(v6) = 2;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v5);
}

uint64_t icu::UnicodeString::unescape@<X0>(icu::UnicodeString *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((v4 & 0x8000) != 0) {
    int v5 = *((_DWORD *)this + 3);
  }
  else {
    int v5 = v4 >> 5;
  }
  *(void *)a2 = off_18971B688;
  uint64_t result = icu::UnicodeString::allocate((icu::UnicodeString *)a2, v5);
  if ((*(_WORD *)(a2 + 8) & 1) != 0) {
    return result;
  }
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  if ((v7 & 0x11) != 0)
  {
    __int128 v8 = 0LL;
    if ((v7 & 0x8000) != 0) {
      goto LABEL_12;
    }
LABEL_10:
    unsigned int v9 = v7 >> 5;
    goto LABEL_13;
  }

  if ((v7 & 2) != 0)
  {
    __int128 v8 = (char *)this + 10;
    if ((v7 & 0x8000) == 0) {
      goto LABEL_10;
    }
  }

  else
  {
    __int128 v8 = (char *)*((void *)this + 3);
    if ((v7 & 0x8000) == 0) {
      goto LABEL_10;
    }
  }

uint64_t icu::UnicodeString::unescapeAt(icu::UnicodeString *this, int *a2)
{
  else {
    int32_t v2 = *((unsigned __int16 *)this + 4) >> 5;
  }
  return u_unescapeAt((UNESCAPE_CHAR_AT)sub_1808671A4, a2, v2, this);
}

uint64_t icu::UnicodeString::append(uint64_t this, unsigned int a2)
{
  int v3 = 0;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u) {
      return this;
    }
    LOWORD(v3) = (a2 >> 10) - 10304;
    HIWORD(v3) = a2 & 0x3FF | 0xDC00;
    uint64_t v2 = 2LL;
  }

  else
  {
    LOWORD(v3) = a2;
    uint64_t v2 = 1LL;
  }

  return icu::UnicodeString::doAppend(this, (uint64_t)&v3, 0, v2);
}

uint64_t sub_1808671A4(unsigned int a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a1) {
    return 0xFFFFLL;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = a2 + 10;
  }
  else {
    uint64_t v4 = *(void *)(a2 + 24);
  }
  return *(unsigned __int16 *)(v4 + 2LL * (int)a1);
}

BOOL icu::UnicodeString::doEquals(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3)
{
  if ((*((_WORD *)this + 4) & 2) != 0) {
    unsigned int v3 = (char *)this + 10;
  }
  else {
    unsigned int v3 = (char *)*((void *)this + 3);
  }
  if ((*((_WORD *)a2 + 4) & 2) != 0) {
    uint64_t v4 = (char *)a2 + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)a2 + 3);
  }
  return memcmp(v3, v4, 2 * a3) == 0;
}

BOOL icu::UnicodeString::doEqualsSubstring( uint64_t a1, int a2, int32_t count, uint64_t a4, int a5, int32_t a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 1) != 0) {
    return 0LL;
  }
  int32_t v7 = count;
  int v8 = a2;
  if ((v6 & 0x8000) == 0)
  {
    signed int v9 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_11:
    int v10 = 0;
    goto LABEL_12;
  }

  signed int v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_11;
  }
LABEL_4:
  int v10 = v9;
  if (v9 >= v8)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_13:
    int32_t v11 = 0;
    goto LABEL_14;
  }

uint64_t icu::UnicodeString::doCompare(uint64_t a1, int a2, int32_t a3, uint64_t a4, int a5, int32_t a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 1) != 0)
  {
    LOBYTE(v13) = -1;
    return (char)v13;
  }

  int32_t v7 = a3;
  int v8 = a2;
  if ((v6 & 0x8000) == 0)
  {
    signed int v9 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_12:
    int v10 = 0;
    goto LABEL_13;
  }

  signed int v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_12;
  }
LABEL_4:
  int v10 = v9;
  if (v9 >= v8)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_14:
    int32_t v11 = 0;
    goto LABEL_15;
  }

uint64_t icu::UnicodeString::doCompareCodePointOrder(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 1) != 0)
  {
    LOBYTE(v10) = -1;
    return (char)v10;
  }

  if ((v6 & 0x8000) == 0)
  {
    signed int v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_10:
    int v8 = 0;
    goto LABEL_11;
  }

  signed int v7 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_10;
  }
LABEL_4:
  int v8 = v7;
  if (v7 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }

uint64_t icu::UnicodeString::getLength(icu::UnicodeString *this)
{
  else {
    return *((unsigned __int16 *)this + 4) >> 5;
  }
}

uint64_t icu::UnicodeString::getCharAt(icu::UnicodeString *this, unsigned int a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0xFFFFLL;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = (char *)this + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)this + 3);
  }
  return *(unsigned __int16 *)&v4[2 * a2];
}

uint64_t icu::UnicodeString::char32At(icu::UnicodeString *this, int a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0xFFFFLL;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = (char *)this + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)this + 3);
  }
  uint64_t result = *(unsigned __int16 *)&v4[2 * a2];
  if ((result & 0xF800) == 0xD800)
  {
    if ((result & 0x400) != 0)
    {
      if (a2 >= 1)
      {
        int v9 = *(unsigned __int16 *)&v4[2 * (a2 - 1)];
        if ((v9 & 0xFC00) == 0xD800)
        {
          int v8 = result + (v9 << 10);
          return (v8 - 56613888);
        }
      }
    }

    else
    {
      uint64_t v6 = a2 + 1LL;
      if ((_DWORD)v6 != v3)
      {
        int v7 = *(unsigned __int16 *)&v4[2 * v6];
        if ((v7 & 0xFC00) == 0xDC00)
        {
          int v8 = v7 + ((_DWORD)result << 10);
          return (v8 - 56613888);
        }
      }
    }
  }

  return result;
}

uint64_t icu::UnicodeString::getChar32Start(icu::UnicodeString *this, uint64_t a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  else {
    unsigned int v3 = v2 >> 5;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = (char *)this + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)this + 3);
  }
  unsigned int v5 = a2 - 1;
  if ((int)a2 >= 1 && (*(_WORD *)&v4[2 * (int)a2] & 0xFC00) == 0xDC00)
  {
    if ((*(_WORD *)&v4[2 * v5] & 0xFC00) == 0xD800) {
      return v5;
    }
    else {
      return a2;
    }
  }

  return a2;
}

uint64_t icu::UnicodeString::getChar32Limit(icu::UnicodeString *this, uint64_t a2)
{
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  else {
    uint64_t result = v3 >> 5;
  }
  if (result > a2)
  {
    if ((v3 & 2) != 0) {
      unsigned int v5 = (char *)this + 10;
    }
    else {
      unsigned int v5 = (char *)*((void *)this + 3);
    }
    if ((int)a2 >= 1
      && ((int)result > (int)a2 || (result & 0x80000000) != 0)
      && (*(_WORD *)&v5[2 * (a2 - 1)] & 0xFC00) == 0xD800)
    {
      else {
        return a2;
      }
    }

    else
    {
      return a2;
    }
  }

  return result;
}

uint64_t icu::UnicodeString::countChar32(icu::UnicodeString *this, int a2, int32_t length)
{
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v4 = v3 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v5 = 0;
    goto LABEL_10;
  }

  signed int v4 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v5 = v4;
  if (v4 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v6 = 0;
LABEL_12:
    length = v6;
    if ((v3 & 2) == 0) {
      goto LABEL_7;
    }
LABEL_13:
    int v7 = (char *)this + 10;
    return u_countChar32((const UChar *)&v7[2 * a2], length);
  }

uint64_t icu::UnicodeString::hasMoreChar32Than( icu::UnicodeString *this, int a2, int32_t length, int32_t number)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }

  signed int v5 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    length = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
LABEL_13:
    int v8 = (char *)this + 10;
    return u_strHasMoreChar32Than((const UChar *)&v8[2 * a2], length, number);
  }

uint64_t icu::UnicodeString::moveIndex32(icu::UnicodeString *this, int a2, int a3)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  else {
    int v5 = v4 >> 5;
  }
  if (v5 >= a2) {
    unsigned int v6 = a2;
  }
  else {
    unsigned int v6 = v5;
  }
  if (a2 >= 0) {
    uint64_t result = v6;
  }
  else {
    uint64_t result = 0LL;
  }
  if ((v4 & 2) != 0) {
    int v8 = (char *)this + 10;
  }
  else {
    int v8 = (char *)*((void *)this + 3);
  }
  if (a3 >= 1)
  {
    int v9 = a3 + 1;
    uint64_t v10 = result;
    while (1)
    {
      if ((int)v10 >= v5)
      {
        if ((v5 & 0x80000000) == 0) {
          return v10;
        }
        __int16 v11 = *(_WORD *)&v8[2 * (int)v10];
        if (!v11) {
          return v10;
        }
      }

      else
      {
        __int16 v11 = *(_WORD *)&v8[2 * (int)v10];
      }

      uint64_t result = (int)v10 + 1LL;
      if ((v11 & 0xFC00) == 0xD800 && (_DWORD)result != v5)
      {
        unsigned int v13 = v10 + 2;
        if ((*(_WORD *)&v8[2 * result] & 0xFC00) == 0xDC00) {
          uint64_t result = v13;
        }
        else {
          uint64_t result = result;
        }
      }

      --v9;
      uint64_t v10 = result;
      if (v9 <= 1) {
        return result;
      }
    }
  }

  if (a3 && (int)result >= 1)
  {
    int v14 = -a3;
    do
    {
      uint64_t result = v6 - 1;
      if ((*(_WORD *)&v8[2 * result] & 0xFC00) == 0xDC00 && v6 >= 2)
      {
        unsigned int v16 = v6 - 2;
        if ((*(_WORD *)&v8[2 * v16] & 0xFC00) == 0xD800) {
          uint64_t result = v16;
        }
        else {
          uint64_t result = result;
        }
      }

      if (v14 < 2) {
        break;
      }
      --v14;
      unsigned int v6 = result;
    }

    while ((int)result > 0);
  }

  return result;
}

char *icu::UnicodeString::doExtract(char *result, int a2, int a3, uint64_t a4, int a5)
{
  unsigned int v5 = *((unsigned __int16 *)result + 4);
  if ((*((__int16 *)result + 4) & 0x80000000) == 0)
  {
    signed int v6 = v5 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v7 = 0;
    goto LABEL_10;
  }

  signed int v6 = *((_DWORD *)result + 3);
  if (a2 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v7 = v6;
  if (v6 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int v8 = 0;
LABEL_12:
    a3 = v8;
    if ((v5 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }

uint64_t icu::UnicodeString::extract(uint64_t a1, UChar **a2, int a3, int *a4)
{
  unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
  else {
    uint64_t v8 = v7 >> 5;
  }
  if (*a4 > 0) {
    return v8;
  }
  if (a3 < 0 || (v7 & 1) != 0 || a3 && !*a2)
  {
    *a4 = 1;
    return v8;
  }

  if ((v7 & 2) != 0) {
    int v9 = (const UChar *)(a1 + 10);
  }
  else {
    int v9 = *(const UChar **)(a1 + 24);
  }
  __int16 v11 = *a2;
  if ((int)v8 >= 1 && (int)v8 <= a3)
  {
    if (v9 == v11)
    {
      __int16 v11 = (UChar *)v9;
    }

    else
    {
      u_memcpy(v11, v9, v8);
      __int16 v11 = *a2;
    }
  }

  return u_terminateUChars((uint64_t)v11, a3, v8, a4);
}

uint64_t icu::UnicodeString::extract(uint64_t a1, int a2, uint64_t length, char *cs, int a5)
{
  if (a5 < 0) {
    return 0LL;
  }
  if (!cs && a5) {
    return 0LL;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    signed int v10 = v9 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
LABEL_13:
    int v11 = 0;
    goto LABEL_14;
  }

  signed int v10 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_13;
  }
LABEL_8:
  int v11 = v10;
  if (v10 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_15;
  }

icu::UnicodeString *icu::UnicodeString::tempSubString@<X0>( icu::UnicodeString *this@<X0>, int a2@<W1>, int32_t a3@<W2>, icu::UnicodeString *a4@<X8>)
{
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v8 = v7 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_8:
    int v9 = 0;
    goto LABEL_9;
  }

  signed int v8 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_8;
  }
LABEL_3:
  int v9 = v8;
  if (v8 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }

uint64_t icu::UnicodeString::toUTF8( icu::UnicodeString *this, int a2, int32_t srcLength, char *dest, int32_t destCapacity)
{
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_8:
    int v8 = 0;
    goto LABEL_9;
  }

  signed int v7 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_8;
  }
LABEL_3:
  int v8 = v7;
  if (v7 >= a2)
  {
    if ((srcLength & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    int32_t v9 = 0;
    goto LABEL_11;
  }

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, int a2, int32_t a3, char *a4, int32_t a5)
{
  if (!a4 && a5) {
    return 0LL;
  }
  if (a5 < 0) {
    a5 = 0x7FFFFFFF;
  }
  return icu::UnicodeString::toUTF8(this, a2, a3, a4, a5);
}

uint64_t icu::UnicodeString::extractBetween( icu::UnicodeString *this, int a2, unsigned int a3, icu::UnicodeString *a4)
{
  if (a2 < 0)
  {
    int v5 = 0;
  }

  else
  {
    int v4 = a2;
    if (*((__int16 *)this + 4) < 0)
    {
      int v5 = *((_DWORD *)this + 3);
      if (v5 >= a2)
      {
LABEL_4:
        if ((a3 & 0x80000000) == 0) {
          goto LABEL_5;
        }
LABEL_11:
        int v6 = 0;
        goto LABEL_13;
      }
    }

    else
    {
      int v5 = *((unsigned __int16 *)this + 4) >> 5;
    }
  }

  int v4 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_11;
  }
LABEL_5:
  if (*((__int16 *)this + 4) < 0)
  {
    int v6 = *((_DWORD *)this + 3);
    goto LABEL_13;
  }

  int v6 = *((unsigned __int16 *)this + 4) >> 5;
  if (v6 < a3) {
LABEL_13:
  }
    a3 = v6;
LABEL_14:
  uint64_t v7 = a3 - v4;
  unsigned int v8 = *((unsigned __int16 *)a4 + 4);
  int v9 = (__int16)v8;
  unsigned int v10 = v8 >> 5;
  if (v9 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = *((unsigned int *)a4 + 3);
  }
  return icu::UnicodeString::doReplace(a4, 0LL, v11, this, v4, v7);
}

void icu::UnicodeString::toUTF8(icu::UnicodeString *this, icu::ByteSink *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*((__int16 *)this + 4) < 0)
  {
    int32_t v4 = *((_DWORD *)this + 3);
    if (!v4) {
      return;
    }
  }

  else
  {
    int32_t v4 = *((unsigned __int16 *)this + 4) >> 5;
    if (!v4) {
      return;
    }
  }

  bzero(v18, 0x400uLL);
  int32_t destCapacity = 1024;
  if (v4 >= 1024) {
    uint64_t v5 = 1024LL;
  }
  else {
    uint64_t v5 = v4;
  }
  int v6 = (char *)(*(uint64_t (**)(icu::ByteSink *, uint64_t, void, _BYTE *, uint64_t, int32_t *))(*(void *)a2 + 24LL))( a2,  v5,  (3 * v4),  v18,  1024LL,  &destCapacity);
  uint64_t v7 = v6;
  UErrorCode pErrorCode = U_ZERO_ERROR;
  int32_t pDestLength = 0;
  __int16 v8 = *((_WORD *)this + 4);
  if ((v8 & 0x11) != 0)
  {
    int v9 = 0LL;
  }

  else if ((v8 & 2) != 0)
  {
    int v9 = (const UChar *)((char *)this + 10);
  }

  else
  {
    int v9 = (const UChar *)*((void *)this + 3);
  }

  u_strToUTF8WithSub(v6, destCapacity, &pDestLength, v9, v4, 65533, 0LL, &pErrorCode);
  UErrorCode v10 = pErrorCode;
  UErrorCode v11 = pErrorCode;
  if (pErrorCode == U_BUFFER_OVERFLOW_ERROR)
  {
    uint64_t v12 = (char *)uprv_malloc(pDestLength);
    if (!v12) {
      return;
    }
    uint64_t v7 = v12;
    UErrorCode pErrorCode = U_ZERO_ERROR;
    __int16 v13 = *((_WORD *)this + 4);
    if ((v13 & 0x11) != 0)
    {
      int v14 = 0LL;
    }

    else if ((v13 & 2) != 0)
    {
      int v14 = (const UChar *)((char *)this + 10);
    }

    else
    {
      int v14 = (const UChar *)*((void *)this + 3);
    }

    u_strToUTF8WithSub(v12, pDestLength, &pDestLength, v14, v4, 65533, 0LL, &pErrorCode);
    UErrorCode v11 = pErrorCode;
  }

  if (v11 <= U_ZERO_ERROR)
  {
    (*(void (**)(icu::ByteSink *, char *, void))(*(void *)a2 + 16LL))(a2, v7, pDestLength);
    (*(void (**)(icu::ByteSink *))(*(void *)a2 + 32LL))(a2);
  }

  if (v10 == U_BUFFER_OVERFLOW_ERROR) {
    uprv_free(v7);
  }
}

uint64_t icu::UnicodeString::toUTF32( icu::UnicodeString *this, UChar32 *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  uint64_t v4 = 0LL;
  int32_t pDestLength = 0;
  if (*(int *)pErrorCode <= 0)
  {
    unsigned int v6 = *((unsigned __int16 *)this + 4);
    if ((v6 & 0x11) != 0)
    {
      uint64_t v7 = 0LL;
      if ((v6 & 0x8000) != 0) {
        goto LABEL_9;
      }
LABEL_7:
      int32_t v8 = v6 >> 5;
LABEL_10:
      u_strToUTF32WithSub(dest, destCapacity, &pDestLength, v7, v8, 65533, 0LL, pErrorCode);
      return pDestLength;
    }

    if ((v6 & 2) != 0)
    {
      uint64_t v7 = (const UChar *)((char *)this + 10);
      if ((v6 & 0x8000) == 0) {
        goto LABEL_7;
      }
    }

    else
    {
      uint64_t v7 = (const UChar *)*((void *)this + 3);
      if ((v6 & 0x8000) == 0) {
        goto LABEL_7;
      }
    }

uint64_t icu::UnicodeString::indexOf( uint64_t a1, uint64_t a2, unsigned int a3, int32_t a4, int a5, int32_t length)
{
  uint64_t v6 = 0xFFFFFFFFLL;
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (a2)
      {
        unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
        if ((v7 & 1) == 0)
        {
          if (a4 < 0 && !*(_WORD *)(a2 + 2LL * a3)) {
            return 0xFFFFFFFFLL;
          }
          if ((v7 & 0x8000) != 0)
          {
            signed int v8 = *(_DWORD *)(a1 + 12);
            if ((a5 & 0x80000000) == 0)
            {
LABEL_9:
              int v9 = v8;
              if (v8 >= a5)
              {
                if ((length & 0x80000000) == 0) {
                  goto LABEL_11;
                }
                goto LABEL_17;
              }

uint64_t icu::UnicodeString::doIndexOf(uint64_t a1, UChar a2, int a3, int32_t count)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }

  signed int v5 = *(_DWORD *)(a1 + 12);
  if (a3 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }

uint64_t icu::UnicodeString::doIndexOf(icu::UnicodeString *this, UChar32 a2, int a3, int32_t count)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }

  signed int v5 = *((_DWORD *)this + 3);
  if (a3 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }

uint64_t icu::UnicodeString::lastIndexOf( uint64_t a1, uint64_t a2, unsigned int a3, int32_t a4, int a5, int32_t length)
{
  uint64_t v6 = 0xFFFFFFFFLL;
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (a2)
      {
        unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
        if ((v7 & 1) == 0)
        {
          if (a4 < 0 && !*(_WORD *)(a2 + 2LL * a3)) {
            return 0xFFFFFFFFLL;
          }
          if ((v7 & 0x8000) != 0)
          {
            signed int v8 = *(_DWORD *)(a1 + 12);
            if ((a5 & 0x80000000) == 0)
            {
LABEL_9:
              int v9 = v8;
              if (v8 >= a5)
              {
                if ((length & 0x80000000) == 0) {
                  goto LABEL_11;
                }
                goto LABEL_17;
              }

uint64_t icu::UnicodeString::doLastIndexOf(uint64_t a1, UChar a2, int a3, int32_t count)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 8);
  if ((v4 & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  if ((v4 & 0x8000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_11:
    int v6 = 0;
    goto LABEL_12;
  }

  signed int v5 = *(_DWORD *)(a1 + 12);
  if (a3 < 0) {
    goto LABEL_11;
  }
LABEL_4:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_13:
    int32_t v7 = 0;
LABEL_14:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_15;
  }

uint64_t icu::UnicodeString::doLastIndexOf(icu::UnicodeString *this, UChar32 a2, int a3, int32_t count)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }

  signed int v5 = *((_DWORD *)this + 3);
  if (a3 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }

icu::UnicodeString *icu::UnicodeString::findAndReplace( icu::UnicodeString *this, int a2, int32_t length, const icu::UnicodeString *a4, signed int a5, uint64_t a6, const icu::UnicodeString *a7, int a8, int a9)
{
  unsigned int v10 = *((unsigned __int16 *)this + 4);
  if ((v10 & 1) != 0) {
    return this;
  }
  unsigned int v12 = *((unsigned __int16 *)a4 + 4);
  if ((v12 & 1) != 0) {
    return this;
  }
  unsigned int v14 = *((unsigned __int16 *)a7 + 4);
  if ((v14 & 1) != 0) {
    return this;
  }
  int v15 = a8;
  uint64_t v16 = a6;
  signed int v17 = a5;
  int32_t v18 = length;
  int v19 = a2;
  if ((v10 & 0x8000) == 0)
  {
    int v20 = v10 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_11:
    int v21 = 0;
    goto LABEL_12;
  }

  int v20 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_11;
  }
LABEL_6:
  int v21 = v20;
  if (v20 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_8;
    }
LABEL_13:
    int32_t v22 = 0;
    goto LABEL_14;
  }

uint64_t icu::UnicodeString::unBogus(uint64_t this)
{
  if ((*(_WORD *)(this + 8) & 1) != 0) {
    *(_WORD *)(this + 8) = 2;
  }
  return this;
}

uint64_t icu::UnicodeString::getTerminatedBuffer(icu::UnicodeString *this)
{
  unsigned int v1 = *((unsigned __int16 *)this + 4);
  if ((v1 & 0x11) != 0) {
    return 0LL;
  }
  if ((v1 & 2) == 0)
  {
    uint64_t result = *((void *)this + 3);
    if ((v1 & 0x8000) == 0) {
      goto LABEL_6;
    }
LABEL_9:
    int v4 = *((_DWORD *)this + 3);
    if ((v1 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }

  uint64_t result = (uint64_t)this + 10;
  if ((v1 & 0x8000) != 0) {
    goto LABEL_9;
  }
LABEL_6:
  int v4 = v1 >> 5;
  if ((v1 & 2) == 0)
  {
LABEL_7:
    int v5 = *((_DWORD *)this + 4);
    goto LABEL_11;
  }

icu::UnicodeString *icu::UnicodeString::setTo(icu::UnicodeString *this, int a2, const UChar **a3, int a4)
{
  __int16 v5 = *((_WORD *)this + 4);
  if ((v5 & 0x10) == 0)
  {
    unsigned int v6 = *a3;
    if (*a3)
    {
      int32_t v7 = a4;
      if (a4 < -1 || !a2 && a4 == -1 || a2 && (a4 & 0x80000000) == 0 && v6[a4])
      {
        icu::UnicodeString::setToBogus(this);
      }

      else
      {
        if ((v5 & 4) != 0)
        {
          unsigned int v12 = (unsigned int *)(*((void *)this + 3) - 4LL);
          do
          {
            unsigned int v13 = __ldaxr(v12);
            unsigned int v14 = v13 - 1;
          }

          while (__stlxr(v14, v12));
          if (!v14) {
            uprv_free((void *)(*((void *)this + 3) - 4LL));
          }
        }

        if (v7 == -1) {
          int32_t v7 = u_strlen(v6);
        }
        if (a2) {
          int32_t v15 = v7 + 1;
        }
        else {
          int32_t v15 = v7;
        }
        if (v7 > 1023)
        {
          *((_DWORD *)this + 3) = v7;
          __int16 v16 = -24;
        }

        else
        {
          __int16 v16 = (32 * v7) | 8;
        }

        *((_WORD *)this + 4) = v16;
        *((void *)this + 3) = v6;
        *((_DWORD *)this + 4) = v15;
      }
    }

    else
    {
      if ((v5 & 4) != 0)
      {
        int v9 = (unsigned int *)(*((void *)this + 3) - 4LL);
        do
        {
          unsigned int v10 = __ldaxr(v9);
          unsigned int v11 = v10 - 1;
        }

        while (__stlxr(v11, v9));
        if (!v11) {
          uprv_free((void *)(*((void *)this + 3) - 4LL));
        }
      }

      *((_WORD *)this + 4) = 2;
    }
  }

  return this;
}

icu::UnicodeString *icu::UnicodeString::setTo(icu::UnicodeString *this, char *a2, int a3, unsigned int a4)
{
  __int16 v5 = *((_WORD *)this + 4);
  if ((v5 & 0x10) == 0)
  {
    if (a2)
    {
      LODWORD(v8) = a3;
      if (a3 > (int)a4 || a3 < -1 || (a4 & 0x80000000) != 0)
      {
        icu::UnicodeString::setToBogus(this);
      }

      else
      {
        if (a3 == -1)
        {
          int v9 = a2;
          if (a4)
          {
            uint64_t v10 = 2LL * a4;
            int v9 = a2;
            while (*(_WORD *)v9)
            {
              v9 += 2;
              v10 -= 2LL;
              if (!v10)
              {
                int v9 = &a2[2 * a4];
                break;
              }
            }
          }

          unint64_t v8 = (unint64_t)(v9 - a2) >> 1;
        }

        if ((v5 & 4) != 0)
        {
          unsigned int v11 = (unsigned int *)(*((void *)this + 3) - 4LL);
          do
          {
            unsigned int v12 = __ldaxr(v11);
            unsigned int v13 = v12 - 1;
          }

          while (__stlxr(v13, v11));
          if (!v13) {
            uprv_free((void *)(*((void *)this + 3) - 4LL));
          }
        }

        if ((int)v8 > 1023)
        {
          *((_DWORD *)this + 3) = v8;
          __int16 v14 = -32;
        }

        else
        {
          __int16 v14 = 32 * v8;
        }

        *((_WORD *)this + 4) = v14;
        *((void *)this + 3) = a2;
        *((_DWORD *)this + 4) = a4;
      }
    }

    else
    {
      if ((v5 & 4) != 0)
      {
        int32_t v15 = (unsigned int *)(*((void *)this + 3) - 4LL);
        do
        {
          unsigned int v16 = __ldaxr(v15);
          unsigned int v17 = v16 - 1;
        }

        while (__stlxr(v17, v15));
        if (!v17) {
          uprv_free((void *)(*((void *)this + 3) - 4LL));
        }
      }

      *((_WORD *)this + 4) = 2;
    }
  }

  return this;
}

icu::UnicodeString *icu::UnicodeString::setCharAt(icu::UnicodeString *this, int a2, __int16 a3)
{
  else {
    int v6 = *((unsigned __int16 *)this + 4) >> 5;
  }
  if (icu::UnicodeString::cloneArrayIfNeeded(this, -1, -1, 1, 0LL, 0))
  {
    int v7 = v6 - 1;
    if (v6 >= 1)
    {
      if (v6 > a2) {
        int v7 = a2;
      }
      if (a2 < 0) {
        int v7 = 0;
      }
      if ((*((_WORD *)this + 4) & 2) != 0) {
        unint64_t v8 = (char *)this + 10;
      }
      else {
        unint64_t v8 = (char *)*((void *)this + 3);
      }
      *(_WORD *)&v8[2 * v7] = a3;
    }
  }

  return this;
}

uint64_t icu::UnicodeString::replace(icu::UnicodeString *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v6 = 0;
  if (HIWORD(a4))
  {
    if (HIWORD(a4) > 0x10u)
    {
      uint64_t v4 = 0LL;
    }

    else
    {
      LOWORD(v6) = (a4 >> 10) - 10304;
      HIWORD(v6) = a4 & 0x3FF | 0xDC00;
      uint64_t v4 = 2LL;
    }
  }

  else
  {
    LOWORD(v6) = a4;
    uint64_t v4 = 1LL;
  }

  return icu::UnicodeString::doReplace((uint64_t)this, a2, a3, (uint64_t)&v6, 0, v4);
}

uint64_t icu::UnicodeString::doReplace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6 = a1;
  uint64_t v38 = *MEMORY[0x1895F89C0];
  unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
  if ((v7 & 0x11) != 0) {
    return v6;
  }
  uint64_t v9 = a6;
  uint64_t v10 = a3;
  uint64_t v11 = a2;
  unsigned __int16 v12 = *(_WORD *)(a1 + 8);
  if ((__int16)v7 < 0)
  {
    int32_t v13 = *(_DWORD *)(a1 + 12);
    if ((_DWORD)a6) {
      goto LABEL_21;
    }
  }

  else
  {
    int32_t v13 = v7 >> 5;
    if ((_DWORD)a6) {
      goto LABEL_21;
    }
  }

  if ((v7 & 8) == 0) {
    goto LABEL_21;
  }
  if (!(_DWORD)a2)
  {
    if ((a3 & 0x80000000) != 0)
    {
      int v15 = 0;
    }

    else if ((__int16)v7 < 0)
    {
      int v15 = *(_DWORD *)(a1 + 12);
    }

    else
    {
      int v15 = v7 >> 5;
      if (v15 >= a3)
      {
LABEL_53:
        *(void *)(a1 + 24) += 2LL * (int)v10;
        *(_DWORD *)(a1 + 16) -= v10;
        int v24 = v13 - v10;
        if (v13 - (int)v10 > 1023)
        {
          *(_WORD *)(a1 + 8) = v12 | 0xFFE0;
          *(_DWORD *)(a1 + 12) = v24;
        }

        else
        {
          *(_WORD *)(a1 + 8) = v12 & 0x1F | (32 * v24);
        }

        return v6;
      }
    }

    LODWORD(v10) = v15;
    goto LABEL_53;
  }

  if ((a2 & 0x80000000) != 0)
  {
    uint64_t v14 = 0LL;
    goto LABEL_19;
  }

  if ((__int16)v7 < 0)
  {
    uint64_t v14 = *(unsigned int *)(a1 + 12);
    goto LABEL_19;
  }

  uint64_t v14 = v7 >> 5;
  if (v14 < a2) {
LABEL_19:
  }
    uint64_t v11 = v14;
LABEL_20:
  if (v13 - (int)v11 <= (int)a3)
  {
    if ((int)v11 > 1023)
    {
      __int16 v17 = v12 | 0xFFE0;
      *(_DWORD *)(a1 + 12) = v11;
    }

    else
    {
      __int16 v17 = *(_WORD *)(a1 + 8) & 0x1F | (32 * v11);
    }

    *(_WORD *)(a1 + 8) = v17;
    *(_DWORD *)(a1 + 16) = v11;
    return v6;
  }

uint64_t icu::UnicodeString::doReplace( icu::UnicodeString *this, uint64_t a2, uint64_t a3, const icu::UnicodeString *a4, int a5, uint64_t a6)
{
  unsigned int v6 = *((unsigned __int16 *)a4 + 4);
  if ((v6 & 0x8000u) == 0) {
    int v7 = v6 >> 5;
  }
  else {
    int v7 = *((_DWORD *)a4 + 3);
  }
  if (a5 < 0)
  {
    int v8 = 0;
  }

  else
  {
    int v8 = v7;
    if (v7 >= a5)
    {
      if ((a6 & 0x80000000) == 0) {
        goto LABEL_7;
      }
LABEL_11:
      uint64_t v9 = 0LL;
      goto LABEL_12;
    }
  }

  a5 = v8;
  if ((a6 & 0x80000000) != 0) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v9 = (v7 - a5);
  if ((int)v9 < (int)a6) {
LABEL_12:
  }
    a6 = v9;
  if ((v6 & 2) != 0) {
    uint64_t v10 = (char *)a4 + 10;
  }
  else {
    uint64_t v10 = (char *)*((void *)a4 + 3);
  }
  return icu::UnicodeString::doReplace((uint64_t)this, a2, a3, (uint64_t)v10, a5, a6);
}

uint64_t icu::UnicodeString::doAppend(uint64_t this, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  if (!(_DWORD)a4) {
    return this;
  }
  unsigned int v4 = *((unsigned __int16 *)a2 + 4);
  if ((v4 & 0x8000u) == 0) {
    int v5 = v4 >> 5;
  }
  else {
    int v5 = *((_DWORD *)a2 + 3);
  }
  if (a3 < 0)
  {
    int v6 = 0;
  }

  else
  {
    int v6 = v5;
    if (v5 >= a3)
    {
      if ((a4 & 0x80000000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
  }

  a3 = v6;
  if ((a4 & 0x80000000) == 0)
  {
LABEL_8:
    uint64_t v7 = (v5 - a3);
    goto LABEL_14;
  }

uint64_t icu::UnicodeString::handleReplaceBetween( icu::UnicodeString *this, uint64_t a2, int a3, const icu::UnicodeString *a4)
{
  uint64_t v4 = (a3 - a2);
  unsigned int v5 = *((unsigned __int16 *)a4 + 4);
  int v6 = (__int16)v5;
  unsigned int v7 = v5 >> 5;
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = *((unsigned int *)a4 + 3);
  }
  return icu::UnicodeString::doReplace(this, a2, v4, a4, 0, v8);
}

void icu::UnicodeString::copy(icu::UnicodeString *this, int a2, int a3, uint64_t a4)
{
  uint64_t v4 = (a3 - a2);
  if (a3 > a2)
  {
    int v6 = a3;
    int v7 = a2;
    uint64_t v9 = uprv_malloc(2LL * (int)v4);
    if (v9)
    {
      uint64_t v10 = v9;
      if (v7 < 0)
      {
        int v11 = 0;
      }

      else if (*((__int16 *)this + 4) < 0)
      {
        int v11 = *((_DWORD *)this + 3);
        if (v11 >= v7)
        {
LABEL_6:
          if ((v6 & 0x80000000) == 0) {
            goto LABEL_7;
          }
          goto LABEL_14;
        }
      }

      else
      {
        int v11 = *((unsigned __int16 *)this + 4) >> 5;
      }

      int v7 = v11;
      if ((v6 & 0x80000000) == 0)
      {
LABEL_7:
        if (*((__int16 *)this + 4) < 0)
        {
          int v12 = *((_DWORD *)this + 3);
          if (v12 >= v6)
          {
LABEL_17:
            icu::UnicodeString::doExtract((char *)this, v7, v6 - v7, (uint64_t)v9, 0);
            icu::UnicodeString::doReplace((uint64_t)this, a4, 0LL, (uint64_t)v10, 0, v4);
            uprv_free(v10);
            return;
          }
        }

        else
        {
          int v12 = *((unsigned __int16 *)this + 4) >> 5;
        }

uint64_t icu::Replaceable::hasMetaData(icu::Replaceable *this)
{
  return 1LL;
}

uint64_t icu::UnicodeString::hasMetaData(icu::UnicodeString *this)
{
  return 0LL;
}

icu::UnicodeString *icu::UnicodeString::doReverse(icu::UnicodeString *this, int a2, int a3)
{
  if (a3 < 2) {
    return this;
  }
  int v4 = a3;
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_8:
    int v8 = 0;
    goto LABEL_9;
  }

  signed int v7 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_8;
  }
LABEL_5:
  int v8 = v7;
  if (v7 < a2) {
LABEL_9:
  }
    a2 = v8;
  int v9 = v7 - a2;
  if (v9 >= v4 || (int v4 = v9, v9 >= 2))
  {
    uint64_t v10 = (v6 & 2) != 0 ? (icu::UnicodeString *)((char *)this + 10) : (icu::UnicodeString *)*((void *)this + 3);
    int v11 = 0;
    int v12 = (__int16 *)((char *)v10 + 2 * a2);
    unint64_t v13 = (unint64_t)v10 + 2 * a2 + 2 * v4 - 4;
    do
    {
      __int16 v14 = *v12;
      BOOL v15 = (*v12 & 0xFC00) == 55296;
      __int16 v16 = *(_WORD *)(v13 + 2);
      *v12++ = v16;
      v11 |= v15 || (v16 & 0xFC00) == 55296;
      *(_WORD *)(v13 + 2) = v14;
      BOOL v17 = (unint64_t)v12 >= v13;
      v13 -= 2LL;
    }

    while (!v17);
    if (v11 | ((*v12 & 0xFC00) == 55296))
    {
      uint64_t v18 = (*((_WORD *)this + 4) & 2) != 0
      uint64_t v19 = (__int16 *)((char *)v18 + 2 * a2);
      unint64_t v20 = (unint64_t)&v19[v4 - 1];
      while ((unint64_t)v19 < v20)
      {
        __int16 v21 = *v19;
        if ((*v19 & 0xFC00) == 0xDC00 && (__int16 v22 = v19[1], (v22 & 0xFC00) == 0xD800))
        {
          *uint64_t v19 = v22;
          v19[1] = v21;
          v19 += 2;
        }

        else
        {
          ++v19;
        }
      }
    }
  }

  return this;
}

uint64_t icu::UnicodeString::padLeading(icu::UnicodeString *this, int a2, __int16 a3)
{
  else {
    int v6 = *((unsigned __int16 *)this + 4) >> 5;
  }
  int v7 = a2 - v6;
  if (a2 <= v6) {
    return 0LL;
  }
  uint64_t result = icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0LL, 0);
  if ((_DWORD)result)
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v9 = (char *)this + 10;
    }
    else {
      int v9 = (char *)*((void *)this + 3);
    }
    if (v6 >= 1) {
      memmove(&v9[2 * v7], v9, 2LL * v6);
    }
    if (v7 >= 1)
    {
      uint64_t v10 = -1LL;
      do
        *(_WORD *)&v9[2 * (v7 + v10--)] = a3;
      while (v7 + (int)v10 + 2 > 1);
    }

    if (a2 > 1023)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a2;
    }

    else
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * a2);
    }

    return 1LL;
  }

  return result;
}

uint64_t icu::UnicodeString::padTrailing(icu::UnicodeString *this, int a2, __int16 a3)
{
  else {
    int v6 = *((unsigned __int16 *)this + 4) >> 5;
  }
  if (v6 >= a2) {
    return 0LL;
  }
  uint64_t result = icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0LL, 0);
  if ((_DWORD)result)
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v8 = (char *)this + 10;
    }
    else {
      int v8 = (char *)*((void *)this + 3);
    }
    uint64_t v9 = a2;
    uint64_t v10 = v8 - 2;
    do
      *(_WORD *)&v10[2 * v9--] = a3;
    while (v9 > v6);
    if (a2 > 1023)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a2;
    }

    else
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * a2);
    }

    return 1LL;
  }

  return result;
}

uint64_t icu::UnicodeString::doHashCode(icu::UnicodeString *this)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 2) != 0)
  {
    unsigned int v3 = (unsigned __int16 *)((char *)this + 10);
    if ((v2 & 0x8000) == 0) {
      goto LABEL_3;
    }
  }

  else
  {
    unsigned int v3 = (unsigned __int16 *)*((void *)this + 3);
    if ((v2 & 0x8000) == 0)
    {
LABEL_3:
      int v4 = v2 >> 5;
      goto LABEL_6;
    }
  }

  int v4 = *((_DWORD *)this + 3);
LABEL_6:
  LODWORD(result) = ustr_hashUCharsN(v3, v4);
  else {
    return result;
  }
}

void icu::UnicodeStringAppendable::~UnicodeStringAppendable(icu::UnicodeStringAppendable *this)
{
}

BOOL icu::UnicodeStringAppendable::appendCodeUnit(uint64_t a1, __int16 a2)
{
  __int16 v3 = a2;
  return (*(_WORD *)(icu::UnicodeString::doAppend(*(void *)(a1 + 8), (uint64_t)&v3, 0, 1LL) + 8) & 0x11) == 0;
}

BOOL icu::UnicodeStringAppendable::appendCodePoint(icu::UnicodeStringAppendable *this, unsigned int a2)
{
  int v4 = 0;
  if (!HIWORD(a2))
  {
    LOWORD(v4) = a2;
    uint64_t v2 = 1LL;
    return (*(_WORD *)(icu::UnicodeString::doAppend(*((void *)this + 1), (uint64_t)&v4, 0, v2) + 8) & 0x11) == 0;
  }

  if (HIWORD(a2) <= 0x10u)
  {
    LOWORD(v4) = (a2 >> 10) - 10304;
    HIWORD(v4) = a2 & 0x3FF | 0xDC00;
    uint64_t v2 = 2LL;
    return (*(_WORD *)(icu::UnicodeString::doAppend(*((void *)this + 1), (uint64_t)&v4, 0, v2) + 8) & 0x11) == 0;
  }

  return 0LL;
}

BOOL icu::UnicodeStringAppendable::appendString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_WORD *)(icu::UnicodeString::doAppend(*(void *)(a1 + 8), a2, 0, a3) + 8) & 0x11) == 0;
}

uint64_t icu::UnicodeStringAppendable::reserveAppendCapacity(icu::UnicodeStringAppendable *this, int a2)
{
  uint64_t v2 = *((void *)this + 1);
  else {
    int v3 = *(unsigned __int16 *)(v2 + 8) >> 5;
  }
  return icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v2, v3 + a2, -1, 1, 0LL, 0);
}

uint64_t icu::UnicodeStringAppendable::getAppendBuffer( uint64_t a1, int a2, int a3, uint64_t a4, int a5, int *a6)
{
  if (a2 < 1 || a5 < a2)
  {
    a4 = 0LL;
    *a6 = 0;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 8);
    else {
      int v11 = *(unsigned __int16 *)(v10 + 8) >> 5;
    }
    BOOL v12 = 2147483637 - v11 < a2 || 2147483637 - v11 < a3;
    if (v12
      || !icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v10, v11 + a2, v11 + a3, 1, 0LL, 0))
    {
      *a6 = a5;
    }

    else
    {
      uint64_t v13 = *(void *)(a1 + 8);
      if ((*(_WORD *)(v13 + 8) & 2) != 0) {
        int v14 = 27;
      }
      else {
        int v14 = *(_DWORD *)(v13 + 16);
      }
      *a6 = v14 - v11;
      if ((*(_WORD *)(v13 + 8) & 2) != 0) {
        uint64_t v15 = v13 + 10;
      }
      else {
        uint64_t v15 = *(void *)(v13 + 24);
      }
      return v15 + 2LL * v11;
    }
  }

  return a4;
}

icu::UnicodeString *uhash_hashUnicodeString(icu::UnicodeString *result)
{
  if (result) {
    return (icu::UnicodeString *)icu::UnicodeString::doHashCode(result);
  }
  return result;
}

BOOL uhash_compareUnicodeString(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    unsigned int v3 = *(unsigned __int16 *)(a1 + 8);
    if ((v3 & 1) != 0)
    {
      return *(_WORD *)(a2 + 8) & 1;
    }

    else
    {
      if ((v3 & 0x8000) != 0) {
        int v4 = *(_DWORD *)(a1 + 12);
      }
      else {
        int v4 = v3 >> 5;
      }
      uint64_t v2 = 0LL;
      unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
      if ((v5 & 0x8000u) == 0) {
        unsigned int v6 = v5 >> 5;
      }
      else {
        unsigned int v6 = *(_DWORD *)(a2 + 12);
      }
      if ((v5 & 1) == 0 && v4 == v6) {
        return icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v4);
      }
    }
  }

  return v2;
}

uint64_t icu::UnicodeString::doCaseCompare( uint64_t a1, int a2, int a3, uint64_t a4, int a5, int32_t a6, __int16 a7)
{
  unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
  if ((v7 & 1) != 0) {
    return -1;
  }
  if ((v7 & 0x8000) == 0)
  {
    signed int v9 = v7 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_10:
    int v10 = 0;
    goto LABEL_11;
  }

  signed int v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_10;
  }
LABEL_4:
  int v10 = v9;
  if (v9 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }

icu::UnicodeString *icu::UnicodeString::caseMap( const UChar **this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if (v6 >= 0x20 && (v6 & 0x11) == 0)
  {
    __int128 v12 = 0uLL;
    __int128 v84 = 0u;
    memset(v85, 0, sizeof(v85));
    __int128 v82 = 0u;
    __int128 v83 = 0u;
    *(_OWORD *)dest = 0u;
    __int128 v81 = 0u;
    if ((v6 & 0x8000) != 0) {
      uint64_t v13 = *((unsigned int *)this + 3);
    }
    else {
      uint64_t v13 = v6 >> 5;
    }
    if ((v6 & 0x19) != 0)
    {
      UErrorCode v49 = U_ZERO_ERROR;
      __int128 v76 = 0uLL;
      uint64_t v79 = 0LL;
      __int128 v78 = 0uLL;
      __int128 v77 = 0uLL;
      int v75 = off_18971B688;
      LOWORD(v76) = 2;
      goto LABEL_11;
    }

    if ((v6 & 4) != 0)
    {
      int v15 = icu::UnicodeString::refCount((icu::UnicodeString *)this);
      UErrorCode v49 = U_ZERO_ERROR;
      __int128 v12 = 0uLL;
      __int128 v76 = 0u;
      uint64_t v79 = 0LL;
      __int128 v78 = 0u;
      __int128 v77 = 0u;
      int v75 = off_18971B688;
      LOWORD(v76) = 2;
      if (v15 != 1)
      {
LABEL_11:
        if ((int)v13 <= 26)
        {
          int v14 = 0;
          goto LABEL_18;
        }

        goto LABEL_20;
      }
    }

    else
    {
      UErrorCode v49 = U_ZERO_ERROR;
      __int128 v76 = 0uLL;
      uint64_t v79 = 0LL;
      __int128 v78 = 0uLL;
      __int128 v77 = 0uLL;
      int v75 = off_18971B688;
      LOWORD(v76) = 2;
    }

    if ((int)v13 < 55)
    {
      int v14 = 1;
LABEL_18:
      if (((_WORD)this[1] & 2) != 0) {
        uint64_t v16 = (const UChar *)this + 5;
      }
      else {
        uint64_t v16 = this[3];
      }
      u_memcpy(dest, v16, v13);
      if (v14)
      {
        if (((_WORD)this[1] & 2) == 0)
        {
          uint64_t v18 = *((unsigned int *)this + 4);
          if (!a4) {
            goto LABEL_37;
          }
          goto LABEL_36;
        }
      }

      else
      {
        uint64_t v16 = (const UChar *)this + 5;
      }

      uint64_t v18 = 27LL;
      if (!a4)
      {
LABEL_37:
        int v21 = a5(a2, a3, a4, v16, v18, dest, v13, 0LL, &v49);
        int v19 = v21;
        if (v49 <= U_ZERO_ERROR)
        {
          int v24 = *((unsigned __int16 *)this + 4);
          if (v21 > 1023)
          {
            unsigned int v20 = (void *)(v24 | 0xFFE0u);
            *((_WORD *)this + 4) = (_WORD)v20;
            *((_DWORD *)this + 3) = v21;
            goto LABEL_63;
          }

          unsigned int v20 = (void *)(v24 & 0x1F | (32 * v21));
          goto LABEL_61;
        }

        if (v49 != U_BUFFER_OVERFLOW_ERROR)
        {
LABEL_57:
          icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
          goto LABEL_63;
        }

        BOOL v17 = dest;
        goto LABEL_40;
      }

icu::UnicodeString *icu::UnicodeString::foldCase(const UChar **this, uint64_t a2)
{
  return icu::UnicodeString::caseMap( this,  1LL,  a2,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087D1C4);
}

uint64_t uhash_hashCaselessUnicodeString(UChar **a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  memset(v4, 0, sizeof(v4));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v4, a1);
  icu::UnicodeString::caseMap( (const UChar **)v4,  1LL,  0LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087D1C4);
  uint64_t v1 = icu::UnicodeString::doHashCode((icu::UnicodeString *)v4);
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)v4);
  return v1;
}

BOOL uhash_compareCaselessUnicodeString(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    unsigned int v3 = *(unsigned __int16 *)(a1 + 8);
    else {
      int v4 = v3 >> 5;
    }
    unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
    if ((v5 & 1) != 0)
    {
      int v8 = (v3 & 1) == 0;
    }

    else
    {
      if ((v5 & 0x8000u) == 0) {
        int v6 = v5 >> 5;
      }
      else {
        int v6 = *(_DWORD *)(a2 + 12);
      }
      if ((v5 & 2) != 0) {
        uint64_t v7 = a2 + 10;
      }
      else {
        uint64_t v7 = *(void *)(a2 + 24);
      }
      int v8 = icu::UnicodeString::doCaseCompare( a1,  0,  v4,  v7,  v6 & (v6 >> 31),  v6 & ~(v6 >> 31),  0);
    }

    return v8 == 0;
  }

  return v2;
}

icu::UnicodeString *icu::UnicodeString::toLower(const UChar **this)
{
  uint64_t v2 = sub_18087DD70(0LL);
  return icu::UnicodeString::caseMap( this,  v2,  0LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087CD1C);
}

icu::UnicodeString *icu::UnicodeString::toLower(const UChar **this, const icu::Locale *a2)
{
  int BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a2);
  uint64_t v4 = sub_18087DD70(BaseName);
  return icu::UnicodeString::caseMap( this,  v4,  0LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087CD1C);
}

icu::UnicodeString *icu::UnicodeString::toUpper(const UChar **this)
{
  uint64_t v2 = sub_18087DD70(0LL);
  return icu::UnicodeString::caseMap( this,  v2,  0LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087CDB8);
}

icu::UnicodeString *icu::UnicodeString::toUpper(const UChar **this, const icu::Locale *a2)
{
  int BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a2);
  uint64_t v4 = sub_18087DD70(BaseName);
  return icu::UnicodeString::caseMap( this,  v4,  0LL,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087CDB8);
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, char *a3)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (__s)
  {
    int v6 = strlen(__s);
    icu::UnicodeString::doCodepageCreate((UChar **)this, __s, v6, a3);
  }

  return this;
}

void icu::UnicodeString::doCodepageCreate(UChar **this, const char *__s, int a3, char *a4)
{
  if (a3 < -1) {
    return;
  }
  uint64_t v17 = v4;
  uint64_t v18 = v5;
  if (!__s) {
    return;
  }
  int32_t v7 = a3;
  if (!a3) {
    return;
  }
  if (a3 == -1) {
    int32_t v7 = strlen(__s);
  }
  UErrorCode v16 = U_ZERO_ERROR;
  if (!a4)
  {
    DefaultName = ucnv_getDefaultName();
    int v12 = *(unsigned __int8 *)DefaultName;
    if (v12 == 117)
    {
      if (DefaultName[1] != 116 || DefaultName[2] != 102) {
        goto LABEL_29;
      }
    }

    else if (v12 != 85 || DefaultName[1] != 84 || DefaultName[2] != 70)
    {
      goto LABEL_29;
    }

    int v14 = *((unsigned __int8 *)DefaultName + 3);
    if (v14 == 56)
    {
      if (!DefaultName[4])
      {
LABEL_23:
        icu::UnicodeString::setToUTF8((uint64_t)this, __s, v7);
        return;
      }
    }

    else if (v14 == 45 && DefaultName[4] == 56 && !DefaultName[5])
    {
      goto LABEL_23;
    }

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, const char *a2, int a3, char *a4)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (a2) {
    icu::UnicodeString::doCodepageCreate((UChar **)this, a2, a3, a4);
  }
  return this;
}

{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (a2) {
    icu::UnicodeString::doCodepageCreate((UChar **)this, a2, a3, a4);
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString( icu::UnicodeString *this, const char *__s, int a3, UConverter *a4, UErrorCode *a5)
{
  *(void *)this = off_18971B688;
  *((_WORD *)this + 4) = 2;
  if (*(int *)a5 <= 0 && __s != 0LL)
  {
    int v8 = a3;
    if (a3 <= -2)
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_14:
      icu::UnicodeString::setToBogus(this);
      return this;
    }

    if (a3 == -1) {
      int v8 = strlen(__s);
    }
    if (v8 >= 1)
    {
      if (a4)
      {
        ucnv_resetToUnicode((uint64_t)a4);
        icu::UnicodeString::doCodepageCreate(this, __s, v8, a4, a5);
      }

      else
      {
        DefaultConverter = (UConverter *)u_getDefaultConverter(a5);
        icu::UnicodeString::doCodepageCreate(this, __s, v8, DefaultConverter, a5);
        u_releaseDefaultConverter(DefaultConverter);
      }
    }
  }

  return this;
}

void icu::UnicodeString::doCodepageCreate( icu::UnicodeString *this, const char *a2, int a3, UConverter *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    unsigned int v20 = 0LL;
    int v21 = a2;
    if (a3 <= 27) {
      int v10 = 27;
    }
    else {
      int v10 = a3 + (a3 >> 2);
    }
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v10, v10, 0, 0LL, 0))
    {
      int v11 = &a2[a3];
      while (1)
      {
        unsigned int v12 = *((unsigned __int16 *)this + 4);
        uint64_t v13 = (char *)this + 10;
        if ((v12 & 2) == 0) {
          uint64_t v13 = (char *)*((void *)this + 3);
        }
        int v14 = (v12 & 0x8000) != 0 ? *((_DWORD *)this + 3) : v12 >> 5;
        unsigned int v20 = &v13[2 * v14];
        int v15 = (v12 & 2) != 0 ? 27 : *((_DWORD *)this + 4);
        ucnv_toUnicode( (uint64_t)a4,  &v20,  (unint64_t)&v13[2 * v15],  (unint64_t *)&v21,  (unint64_t)v11,  0LL,  1,  (int *)a5);
        unint64_t v16 = (unint64_t)(v20 - v13) >> 1;
        __int16 v17 = *((_WORD *)this + 4);
        if ((int)v16 > 1023)
        {
          LOWORD(v18) = v17 | 0xFFE0;
          *((_DWORD *)this + 3) = v16;
        }

        else
        {
          unsigned int v18 = v17 & 0x1F | (32 * (((_DWORD)v20 - (_DWORD)v13) >> 1));
        }

        *((_WORD *)this + 4) = v18;
        if (*a5 != U_BUFFER_OVERFLOW_ERROR) {
          break;
        }
        *a5 = U_ZERO_ERROR;
        else {
          int v19 = *((unsigned __int16 *)this + 4) >> 5;
        }
        if (!icu::UnicodeString::cloneArrayIfNeeded( this,  v19 + 2 * ((int)v11 - (int)v21),  v19 + 2 * ((int)v11 - (int)v21),  1,  0LL,  0)) {
          goto LABEL_23;
        }
      }
    }

    else
    {
LABEL_23:
      icu::UnicodeString::setToBogus(this);
    }
  }

uint64_t icu::UnicodeString::extract( icu::UnicodeString *this, int a2, uint64_t a3, char *cs, unsigned int a5, char *a6)
{
  uint64_t v7 = a3;
  int v8 = a2;
  if (cs || !a5)
  {
    unsigned int v11 = *((unsigned __int16 *)this + 4);
    if (*((__int16 *)this + 4) < 0)
    {
      int v12 = *((_DWORD *)this + 3);
      if ((a2 & 0x80000000) == 0)
      {
LABEL_6:
        int v13 = v12;
        if (v12 >= a2)
        {
          if ((a3 & 0x80000000) == 0) {
            goto LABEL_8;
          }
          goto LABEL_13;
        }

uint64_t icu::UnicodeString::doExtract( icu::UnicodeString *this, int a2, int a3, char *a4, int a5, UConverter *a6, UErrorCode *a7)
{
  int v7 = a5;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v17 = a4;
  if (*(int *)a7 < 1)
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v12 = (char *)this + 10;
    }
    else {
      int v12 = (char *)*((void *)this + 3);
    }
    int v16 = &v12[2 * a2];
    unint64_t v13 = (unint64_t)&v16[2 * a3];
    if (a5 == -1)
    {
      int v7 = 0x7FFFFFFF;
      else {
        unint64_t v14 = (unint64_t)(a4 + 0x7FFFFFFF);
      }
    }

    else if (a5)
    {
      unint64_t v14 = (unint64_t)&a4[a5];
    }

    else
    {
      unint64_t v14 = 0LL;
      int v17 = 0LL;
    }

    ucnv_fromUnicode((uint64_t)a6, (uint64_t *)&v17, v14, (unint64_t *)&v16, v13, 0LL, 1, (int *)a7);
    uint64_t v15 = ((_DWORD)v17 - (_DWORD)a4);
    if (*a7 == U_BUFFER_OVERFLOW_ERROR)
    {
      bzero(v18, 0x400uLL);
      do
      {
        int v17 = v18;
        *a7 = U_ZERO_ERROR;
        ucnv_fromUnicode( (uint64_t)a6,  (uint64_t *)&v17,  (unint64_t)&v19,  (unint64_t *)&v16,  v13,  0LL,  1,  (int *)a7);
        uint64_t v15 = v15 + (_DWORD)v17 - v18;
      }

      while (*a7 == U_BUFFER_OVERFLOW_ERROR);
    }

    return u_terminateChars((uint64_t)a4, v7, v15, (int *)a7);
  }

  else
  {
    uint64_t result = 0LL;
    if (a5) {
      *a4 = 0;
    }
  }

  return result;
}

uint64_t icu::UnicodeString::extract( icu::UnicodeString *this, char *a2, int a3, UConverter *a4, UErrorCode *a5)
{
  if (a3 < 0 || (unsigned int v9 = *((unsigned __int16 *)this + 4), (v9 & 1) != 0) || !a2 && a3)
  {
    uint64_t v5 = 0LL;
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    return v5;
  }

  if (v9 > 0x1F)
  {
    if (a4)
    {
      ucnv_resetFromUnicode((uint64_t)a4);
      unint64_t v13 = a4;
    }

    else
    {
      uint64_t DefaultConverter = u_getDefaultConverter(a5);
      unint64_t v13 = (UConverter *)DefaultConverter;
    }

    else {
      int v14 = *((unsigned __int16 *)this + 4) >> 5;
    }
    uint64_t v5 = icu::UnicodeString::doExtract(this, 0, v14, a2, a3, v13, a5);
    if (!a4) {
      u_releaseDefaultConverter(v13);
    }
    return v5;
  }

  return u_terminateChars((uint64_t)a2, a3, 0LL, (int *)a5);
}

icu::UnicodeString *icu::UnicodeString::trim(icu::UnicodeString *this)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 1) != 0) {
    return this;
  }
  if ((v2 & 2) != 0)
  {
    unsigned int v3 = (char *)this + 10;
    if ((v2 & 0x8000) == 0) {
      goto LABEL_4;
    }
LABEL_6:
    int v4 = *((_DWORD *)this + 3);
    goto LABEL_7;
  }

  unsigned int v3 = (char *)*((void *)this + 3);
  if ((v2 & 0x8000) != 0) {
    goto LABEL_6;
  }
LABEL_4:
  int v4 = v2 >> 5;
LABEL_7:
  if (v4 < 1) {
    return this;
  }
  int v5 = v4;
  do
  {
    int v6 = v5 - 1;
    UChar32 v7 = *(unsigned __int16 *)&v3[2 * (v5 - 1)];
    if ((v7 & 0xFC00) == 0xDC00)
    {
      if (v5 < 2)
      {
        int v6 = 0;
      }

      else
      {
        int v8 = *(unsigned __int16 *)&v3[2 * (v5 - 2)];
        BOOL v9 = (v8 & 0xFC00) == 55296;
        int v10 = v7 - 56613888 + (v8 << 10);
        if (v9) {
          int v6 = v5 - 2;
        }
        if (v9) {
          UChar32 v7 = v10;
        }
      }
    }

    else if (v7 == 32)
    {
      goto LABEL_21;
    }

    if (!u_isWhitespace(v7)) {
      break;
    }
LABEL_21:
    int v5 = v6;
  }

  while (v6 > 0);
  if (v5 >= v4)
  {
LABEL_25:
    if (v5 < 1) {
      return this;
    }
  }

  else
  {
    if (v5 <= 1023)
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * v5);
      goto LABEL_25;
    }

    *((_WORD *)this + 4) |= 0xFFE0u;
    *((_DWORD *)this + 3) = v5;
  }

  uint64_t v11 = 0LL;
  while (2)
  {
    uint64_t v12 = (int)v11 + 1LL;
    UChar32 v13 = *(unsigned __int16 *)&v3[2 * (int)v11];
    if ((v13 & 0xFC00) == 0xD800 && (_DWORD)v12 != v5)
    {
      int v15 = *(unsigned __int16 *)&v3[2 * v12];
      BOOL v16 = (v15 & 0xFC00) == 56320;
      UChar32 v17 = (v13 << 10) - 56613888 + v15;
      if (v16) {
        uint64_t v12 = (v11 + 2);
      }
      else {
        uint64_t v12 = v12;
      }
      if (v16) {
        UChar32 v13 = v17;
      }
      goto LABEL_42;
    }

    if (v13 != 32)
    {
LABEL_42:
      if (!u_isWhitespace(v13)) {
        break;
      }
    }

    uint64_t v11 = v12;
    break;
  }

  return this;
}

const UChar **icu::UnicodeString::toTitle(icu::UnicodeString *this, icu::BreakIterator *a2)
{
  Default = icu::Locale::getDefault(this);
  return icu::UnicodeString::toTitle((const UChar **)this, a2, (const icu::Locale *)Default, 0LL);
}

const UChar **icu::UnicodeString::toTitle( const UChar **this, icu::BreakIterator *a2, const icu::Locale *a3, uint64_t a4)
{
  uint64_t v13 = 0LL;
  int v12 = 0;
  uint64_t v7 = sub_18087B438(a3, "", a4, (uint64_t)a2, &v13, (const icu::Locale *)&v12);
  if (v7)
  {
    uint64_t v8 = v7;
    int BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a3);
    uint64_t v10 = sub_18087DD70(BaseName);
    icu::UnicodeString::caseMap( this,  v10,  a4,  v8,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18087BA30);
  }

  else
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
  }

  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  return this;
}

const UChar **icu::UnicodeString::toTitle(const UChar **this, icu::BreakIterator *a2, const icu::Locale *a3)
{
  return icu::UnicodeString::toTitle(this, a2, a3, 0LL);
}

uint64_t unorm_quickCheck(uint64_t a1, int a2, int a3, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);
  return unorm2_quickCheck(Instance, a1, a2, (int *)this);
}

uint64_t unorm_quickCheckWithOptions(uint64_t a1, int a2, int a3, char a4, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) == 0) {
    return unorm2_quickCheck(Instance, a1, a2, (int *)this);
  }
  v12[0] = off_18970BA28;
  v12[1] = Instance;
  _OWORD v12[2] = sub_180861384((UErrorCode *)this);
  uint64_t v11 = unorm2_quickCheck((uint64_t)v12, a1, a2, (int *)this);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v12);
  return v11;
}

uint64_t unorm_isNormalized(uint64_t a1, int a2, int a3, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);
  return unorm2_isNormalized(Instance, a1, a2, (int *)this);
}

uint64_t unorm_isNormalizedWithOptions(uint64_t a1, int a2, int a3, char a4, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) == 0) {
    return unorm2_isNormalized(Instance, a1, a2, (int *)this);
  }
  v12[0] = off_18970BA28;
  v12[1] = Instance;
  _OWORD v12[2] = sub_180861384((UErrorCode *)this);
  uint64_t isNormalized = unorm2_isNormalized((uint64_t)v12, a1, a2, (int *)this);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v12);
  return isNormalized;
}

uint64_t unorm_normalize( UChar *a1, int a2, int a3, char a4, UChar *a5, uint64_t a6, icu::Normalizer2Factory *this)
{
  uint64_t Instance = (const void *)icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) == 0) {
    return unorm2_normalize(Instance, a1, a2, a5, a6, (UErrorCode *)this);
  }
  v16[0] = off_18970BA28;
  v16[1] = Instance;
  v16[2] = sub_180861384((UErrorCode *)this);
  uint64_t v15 = unorm2_normalize(v16, a1, a2, a5, a6, (UErrorCode *)this);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v16);
  return v15;
}

uint64_t unorm_previous( uint64_t a1, UChar *a2, uint64_t a3, int a4, char a5, int a6, _BYTE *a7, icu::Normalizer2Factory *a8)
{
  return sub_18086AF24(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_18086AF24( uint64_t a1, int a2, UChar *a3, uint64_t a4, int a5, char a6, int a7, _BYTE *a8, icu::Normalizer2Factory *a9)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a5, a9);
  if ((a6 & 0x20) == 0) {
    return sub_18086B394(a1, a2, a3, a4, Instance, a7, a8, (int *)a9);
  }
  uint64_t v18 = sub_180861384((UErrorCode *)a9);
  v20[0] = off_18970BA28;
  v20[1] = Instance;
  v20[2] = v18;
  uint64_t v19 = sub_18086B394(a1, a2, a3, a4, (uint64_t)v20, a7, a8, (int *)a9);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v20);
  return v19;
}

uint64_t unorm_next( uint64_t a1, UChar *a2, uint64_t a3, int a4, char a5, int a6, _BYTE *a7, icu::Normalizer2Factory *a8)
{
  return sub_18086AF24(a1, 1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t unorm_concatenate( uint64_t a1, uint64_t a2, unint64_t a3, int a4, char *a5, unsigned int a6, int a7, char a8, icu::Normalizer2Factory *a9)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a7, a9);
  if ((a8 & 0x20) == 0) {
    return sub_18086B194(a1, a2, a3, a4, a5, a6, Instance, (int *)a9);
  }
  uint64_t v18 = sub_180861384((UErrorCode *)a9);
  v20[0] = off_18970BA28;
  v20[1] = Instance;
  v20[2] = v18;
  uint64_t v19 = sub_18086B194(a1, a2, a3, a4, a5, a6, (uint64_t)v20, (int *)a9);
  icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v20);
  return v19;
}

uint64_t sub_18086B194( uint64_t a1, uint64_t a2, unint64_t a3, int a4, char *a5, unsigned int a6, uint64_t a7, int *a8)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (*a8 > 0) {
    return 0LL;
  }
  if ((a6 & 0x80000000) != 0
    || (!a5 ? (BOOL v13 = a6 == 0) : (BOOL v13 = 1),
        v13 ? (int v14 = 0) : (int v14 = 1),
        a4 < -1
     || !a3
     || (int)a2 < -1
     || !a1
     || v14
     || a5
     && (a3 >= (unint64_t)a5 && (unint64_t)&a5[2 * a6] > a3
      || a4 >= 1 && (unint64_t)a5 >= a3 && a3 + 2LL * a4 > (unint64_t)a5)))
  {
    uint64_t v8 = 0LL;
    *a8 = 1;
  }

  else
  {
    __int128 v27 = 0u;
    uint64_t v30 = 0LL;
    __int128 v29 = 0u;
    __int128 v28 = 0u;
    int v26 = off_18971B688;
    LOWORD(v27) = 2;
    if ((char *)a1 == a5)
    {
      icu::UnicodeString::setTo((icu::UnicodeString *)&v26, a5, a2, a6);
    }

    else
    {
      icu::UnicodeString::setTo((icu::UnicodeString *)&v26, a5, 0, a6);
      icu::UnicodeString::doAppend((uint64_t)&v26, a1, 0, a2);
      v22[1] = a1;
    }

    unint64_t v24 = a3;
    icu::UnicodeString::UnicodeString(v25, a4 >> 31, &v24);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), _BYTE *, int *))(*(void *)a7 + 48LL))( a7,  &v26,  v25,  a8);
    int v23 = (UChar *)a5;
    uint64_t v8 = icu::UnicodeString::extract(v20, &v23, a6, a8);
    v22[0] = v23;
    icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v25);
    unint64_t v21 = v24;
    icu::UnicodeString::~UnicodeString(&v21, (icu::UnicodeString *)&v26);
  }

  return v8;
}

uint64_t sub_18086B394(uint64_t a1, int a2, UChar *a3, uint64_t a4, uint64_t a5, int a6, _BYTE *a7, int *a8)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (*a8 <= 0)
  {
    if ((a4 & 0x80000000) != 0 || (!a3 ? (v13 = (_DWORD)a4 == 0) : (v13 = 1), v13 ? (int v14 = 0) : (int v14 = 1), !a1 || v14))
    {
      uint64_t v8 = 0LL;
      *a8 = 1;
      return v8;
    }

    if (a7) {
      *a7 = 0;
    }
    if (a2)
    {
      if ((*(unsigned int (**)(uint64_t))(a1 + 48))(a1))
      {
        __int128 v34 = 0u;
        uint64_t v37 = 0LL;
        __int128 v36 = 0u;
        __int128 v35 = 0u;
        int v33 = off_18971B688;
        LOWORD(v34) = 2;
        UChar32 v18 = uiter_next32((UCharIterator *)a1);
        icu::UnicodeString::append((uint64_t)&v33, v18);
        uint64_t v19 = uiter_next32((UCharIterator *)a1);
        if ((v19 & 0x80000000) == 0)
        {
          uint64_t v20 = v19;
          while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a5 + 120LL))(a5, v20))
          {
            icu::UnicodeString::append((uint64_t)&v33, v20);
            uint64_t v20 = uiter_next32((UCharIterator *)a1);
            if ((v20 & 0x80000000) != 0) {
              goto LABEL_32;
            }
          }

          else {
            uint64_t v24 = 0xFFFFFFFFLL;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v24, 1LL);
        }

        goto LABEL_32;
      }
    }

    else if ((*(unsigned int (**)(uint64_t))(a1 + 56))(a1))
    {
      __int128 v34 = 0u;
      uint64_t v37 = 0LL;
      __int128 v36 = 0u;
      __int128 v35 = 0u;
      int v33 = off_18971B688;
      LOWORD(v34) = 2;
      do
      {
        uint64_t v21 = uiter_previous32((UCharIterator *)a1);
        if ((v21 & 0x80000000) != 0) {
          break;
        }
        uint64_t v22 = v21;
        icu::UnicodeString::replace((icu::UnicodeString *)&v33, 0LL, 0LL, v21);
      }

      while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a5 + 120LL))(a5, v22));
LABEL_32:
      memset(v32, 0, sizeof(v32));
      icu::UnicodeString::UnicodeString(v32, a3, 0LL, a4);
      int v25 = (unsigned __int16)v34 >> 5;
      if ((v34 & 0x8000u) != 0LL) {
        int v25 = DWORD1(v34);
      }
      if (a6 && v25 >= 1)
      {
        uint64_t v26 = (*(uint64_t (**)(uint64_t, void (***)(icu::UnicodeString *__hidden), _OWORD *, int *))(*(void *)a5 + 24LL))( a5,  &v33,  v32,  a8);
        uint64_t v31 = a3;
        icu::UnicodeString::extract(v26, &v31, a4, a8);
        if (a7 && *a8 <= 0) {
          *a7 = sub_18086B6D8((uint64_t)v32, (uint64_t)&v33);
        }
        unint64_t v27 = SWORD4(v32[0]);
        if ((v27 & 0x80000000) != 0)
        {
          uint64_t v8 = HIDWORD(v32[0]);
        }

        else
        {
          unint64_t v27 = WORD4(v32[0]);
          uint64_t v8 = WORD4(v32[0]) >> 5;
        }
      }

      else
      {
        uint64_t v30 = a3;
        uint64_t v8 = icu::UnicodeString::extract((uint64_t)&v33, &v30, a4, a8);
        __int128 v29 = v30;
        unint64_t v27 = (unint64_t)&v29;
      }

      icu::UnicodeString::~UnicodeString((void *)v27, (icu::UnicodeString *)v32);
      icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v33);
      return v8;
    }

    return u_terminateUChars((uint64_t)a3, a4, 0LL, a8);
  }

  return 0LL;
}

uint64_t sub_18086B6D8(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if ((v2 & 1) != 0)
  {
    int v4 = *(_WORD *)(a2 + 8) & 1;
  }

  else
  {
    if ((v2 & 0x8000) != 0) {
      int v3 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v3 = v2 >> 5;
    }
    int v4 = 0;
    unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
    if ((v5 & 0x8000u) == 0) {
      unsigned int v6 = v5 >> 5;
    }
    else {
      unsigned int v6 = *(_DWORD *)(a2 + 12);
    }
    if ((v5 & 1) == 0 && v3 == v6) {
      int v4 = icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v3);
    }
  }

  return v4 ^ 1u;
}

uint64_t unorm_compare( UChar *a1, UErrorCode *a2, UChar *a3, int a4, unsigned int a5, icu::Normalizer2Factory *this)
{
  v76[5] = *MEMORY[0x1895F89C0];
  uint64_t v8 = a1;
  if (!a1 || (v9 = (int)a2, (int)a2 < -1) || (uint64_t v10 = a3) == 0LL || (v11 = a4, a4 <= -2))
  {
    uint64_t v6 = 0LL;
    *(_DWORD *)this = 1;
    return v6;
  }

  __int128 v59 = 0u;
  uint64_t v62 = 0LL;
  __int128 v61 = 0u;
  __int128 v60 = 0u;
  uint64_t v57 = 0LL;
  __int128 v58 = off_18971B688;
  LOWORD(v59) = 2;
  __int128 v54 = 0u;
  __int128 v56 = 0u;
  __int128 v55 = 0u;
  __int128 v53 = off_18971B688;
  LOWORD(v54) = 2;
  if ((a5 & 0x20001) != 0x20000)
  {
    if ((a5 & 1) != 0) {
      NFDuint64_t Instance = icu::Normalizer2::getNFDInstance(this, a2);
    }
    else {
      NFDuint64_t Instance = icu::Normalizer2Factory::getFCDInstance(this, a2);
    }
    uint64_t v42 = NFDInstance;
    uint64_t v12 = a5;
    if ((a5 & 0x2000000) != 0)
    {
      *(void *)dest = off_18970BA28;
      *(void *)&dest[4] = NFDInstance;
      *(void *)&__int128 v68 = sub_180861384((UErrorCode *)this);
      if (sub_18086C068((uint64_t)dest, (uint64_t)v8, v9, (icu::UnicodeString *)&v58, (unsigned int *)this))
      {
        if ((v59 & 0x11) != 0)
        {
          uint64_t v8 = 0LL;
        }

        else if ((v59 & 2) != 0)
        {
          uint64_t v8 = (UChar *)&v59 + 1;
        }

        else
        {
          uint64_t v8 = (UChar *)v60;
        }

        if ((v59 & 0x8000) != 0) {
          signed int v9 = DWORD1(v59);
        }
        else {
          signed int v9 = (unsigned __int16)v59 >> 5;
        }
      }

      if (sub_18086C068( (uint64_t)dest,  (uint64_t)v10,  v11,  (icu::UnicodeString *)&v53,  (unsigned int *)this))
      {
        if ((v54 & 0x11) != 0)
        {
          uint64_t v10 = 0LL;
        }

        else if ((v54 & 2) != 0)
        {
          uint64_t v10 = (UChar *)&v54 + 1;
        }

        else
        {
          uint64_t v10 = (UChar *)v55;
        }

        if ((v54 & 0x8000) != 0) {
          signed int v11 = DWORD1(v54);
        }
        else {
          signed int v11 = (unsigned __int16)v54 >> 5;
        }
      }

      icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)dest);
    }

    else
    {
      if (sub_18086C068(NFDInstance, (uint64_t)v8, v9, (icu::UnicodeString *)&v58, (unsigned int *)this))
      {
        if ((v59 & 0x11) != 0)
        {
          uint64_t v8 = 0LL;
        }

        else if ((v59 & 2) != 0)
        {
          uint64_t v8 = (UChar *)&v59 + 1;
        }

        else
        {
          uint64_t v8 = (UChar *)v60;
        }

        if ((v59 & 0x8000) != 0) {
          signed int v9 = DWORD1(v59);
        }
        else {
          signed int v9 = (unsigned __int16)v59 >> 5;
        }
      }

      if (sub_18086C068(v42, (uint64_t)v10, v11, (icu::UnicodeString *)&v53, (unsigned int *)this))
      {
        if ((v54 & 0x11) != 0)
        {
          uint64_t v10 = 0LL;
        }

        else if ((v54 & 2) != 0)
        {
          uint64_t v10 = (UChar *)&v54 + 1;
        }

        else
        {
          uint64_t v10 = (UChar *)v55;
        }

        if ((v54 & 0x8000) != 0) {
          signed int v11 = DWORD1(v54);
        }
        else {
          signed int v11 = (unsigned __int16)v54 >> 5;
        }
      }
    }
  }

  uint64_t v12 = *(unsigned int *)this;
  if ((int)v12 > 0
    || (NFCImpl = icu::Normalizer2Factory::getNFCImpl(this, a2), uint64_t v12 = *(unsigned int *)this, (int)v12 > 0))
  {
LABEL_123:
    uint64_t v6 = 0LL;
    goto LABEL_124;
  }

  uint64_t v45 = NFCImpl;
  int v14 = 0;
  int v15 = 0;
  src = 0LL;
  unsigned int v16 = a5;
  unsigned int v51 = 0;
  memset(v76, 0, 32);
  __int128 v73 = 0u;
  memset(v74, 0, sizeof(v74));
  __int128 v75 = 0u;
  uint64_t v71 = 0LL;
  uint64_t v72 = 0LL;
  *(_OWORD *)dest = 0u;
  __int128 v68 = 0u;
  if (v9 == -1) {
    UChar32 v17 = 0LL;
  }
  else {
    UChar32 v17 = &v8[v9];
  }
  uint64_t v12 = (uint64_t)&v10[v11];
  __int128 v69 = 0uLL;
  __int128 v70 = 0uLL;
  if (v11 == -1) {
    UChar32 v18 = 0LL;
  }
  else {
    UChar32 v18 = &v10[v11];
  }
  uint64_t v19 = 0xFFFFFFFFLL;
  *(_OWORD *)__int128 v63 = 0uLL;
  __int128 v64 = 0uLL;
  uint64_t v20 = v8;
  uint64_t v21 = v10;
  unsigned int v22 = -1;
  __int128 v65 = 0uLL;
  __int128 v66 = 0uLL;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if ((v19 & 0x80000000) != 0)
            {
              while (1)
              {
                if (v8 != v17)
                {
                  uint64_t v12 = v16 & 0x1000;
                  BOOL v24 = v17 && (_DWORD)v12 == 0;
                  uint64_t v23 = *v8;
                  if (v24 || *v8)
                  {
                    ++v8;
                    if ((v22 & 0x80000000) != 0) {
                      goto LABEL_37;
                    }
                    goto LABEL_46;
                  }
                }

                if (!v14) {
                  break;
                }
                uint64_t v12 = (uint64_t)&v76[3 * v14];
                do
                {
                  uint64_t v20 = *(UChar **)(v12 - 40);
                  v12 -= 24LL;
                  --v14;
                }

                while (!v20);
                uint64_t v8 = *(UChar **)(v12 - 8);
                UChar32 v17 = *(UChar **)v12;
              }

              uint64_t v23 = 0xFFFFFFFFLL;
              if ((v22 & 0x80000000) != 0) {
                goto LABEL_37;
              }
            }

            else
            {
              uint64_t v23 = v19;
              if ((v22 & 0x80000000) != 0)
              {
LABEL_37:
                while (1)
                {
                  if (v10 != v18)
                  {
                    uint64_t v12 = v16 & 0x1000;
                    BOOL v25 = v18 && (_DWORD)v12 == 0;
                    unsigned int v22 = *v10;
                    if (v25 || *v10) {
                      break;
                    }
                  }

                  if (!v15)
                  {
                    unsigned int v22 = -1;
                    goto LABEL_46;
                  }

                  uint64_t v12 = (uint64_t)&v74[3 * v15];
                  do
                  {
                    uint64_t v21 = *(UChar **)(v12 - 40);
                    v12 -= 24LL;
                    --v15;
                  }

                  while (!v21);
                  uint64_t v10 = *(UChar **)(v12 - 8);
                  UChar32 v18 = *(UChar **)v12;
                }

                ++v10;
              }
            }

uint64_t sub_18086C068(uint64_t a1, uint64_t a2, unsigned int a3, icu::UnicodeString *a4, unsigned int *a5)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  uint64_t v17 = a2;
  icu::UnicodeString::UnicodeString(&v19, a3 >> 31, &v17);
  int v8 = (*(uint64_t (**)(uint64_t, __int128 *, unsigned int *))(*(void *)a1 + 112LL))(a1, &v19, a5);
  signed int v9 = (void *)*a5;
  int v10 = v8;
  LODWORD(v9) = WORD4(v19) >> 5;
  signed int v9 = (SWORD4(v19) & 0x8000u) == 0 ? (void *)v9 : (void *)HIDWORD(v19);
  memset(v18, 0, sizeof(v18));
  icu::UnicodeString::tempSubString((icu::UnicodeString *)&v19, v8, 0x7FFFFFFF, (icu::UnicodeString *)v18);
  if ((BYTE8(v19) & 0x11) != 0) {
    signed int v11 = 0LL;
  }
  else {
    signed int v11 = (const UChar *)((BYTE8(v19) & 2) != 0 ? (unint64_t)&v19 | 0xA : *((void *)&v20 + 1));
  }
  unsigned int v16 = v11;
  icu::UnicodeString::setTo(a4, 0, &v16, v10);
  (*(void (**)(uint64_t, icu::UnicodeString *, _OWORD *, unsigned int *))(*(void *)a1 + 40LL))( a1,  a4,  v18,  a5);
  int v12 = *a5;
  icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v18);
  if (v12 < 1) {
    uint64_t v14 = 1LL;
  }
  else {
LABEL_12:
  }
    uint64_t v14 = 0LL;
  icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)&v19);
  return v14;
}

void icu::UMemory::operator delete(void *a1)
{
  if (a1) {
    uprv_free(a1);
  }
}

void icu::UMemory::operator delete[](void *a1)
{
  if (a1) {
    uprv_free(a1);
  }
}

void icu::UObject::~UObject(void *this)
{
  if (this) {
    uprv_free(this);
  }
}

uint64_t icu::UObject::getDynamicClassID(icu::UObject *this)
{
  return 0LL;
}

uint64_t uprv_deleteUObject(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  if (which <= (UCHAR_EXTENDED_PICTOGRAPHIC|UCHAR_GRAPHEME_BASE)) {
    return (*((uint64_t (**)(char *, void))&unk_18971B820 + 2 * which + 1))( (char *)&unk_18971B820 + 16 * which,  *(void *)&c);
  }
  else {
    return 0;
  }
}

BOOL u_isEmoji(unsigned int a1)
{
  return sub_1807CB5EC(a1, 57);
}

UBool u_isIDStart(UChar32 c)
{
  return (sub_18081C7AC(c, 1) >> 24) & 1;
}

UBool u_isIDPart(UChar32 c)
{
  return (sub_18081C7AC(c, 1) >> 25) & 1;
}

UBool u_stringHasBinaryProperty(const UChar *s, int32_t length, UProperty which)
{
  if (!s && length) {
    return 0;
  }
  if (length != 1)
  {
    if (length == 2)
    {
      UChar v4 = *s;
    }

    else
    {
      if ((length & 0x80000000) == 0) {
        goto LABEL_20;
      }
      UChar v4 = *s;
      if (!*s) {
        goto LABEL_20;
      }
    }

    int v5 = 1;
    if ((v4 & 0xFC00) == 0xD800)
    {
      if ((s[1] & 0xFC00) == 0xDC00) {
        int v5 = 2;
      }
      else {
        int v5 = 1;
      }
    }

    if (length < 1)
    {
      if (!s[v5]) {
        goto LABEL_22;
      }
    }

    else if (v5 == length)
    {
LABEL_22:
      if (which <= (UCHAR_EXTENDED_PICTOGRAPHIC|UCHAR_GRAPHEME_BASE))
      {
        uint64_t v6 = *(uint64_t (**)(void))&dword_18971B820[4 * which + 2];
        return v6();
      }

      return 0;
    }

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_REGIONAL_INDICATOR|0xF80))
  {
    if (which <= (UCHAR_LEAD_CANONICAL_COMBINING_CLASS|UCHAR_EXTENDER)) {
      return ((uint64_t (*)(uint64_t (**)(void), void))qword_18971BCD0[4 * (which - 4096) + 2])( &qword_18971BCD0[4 * (which - 4096)],  *(void *)&c);
    }
    if (which == UCHAR_GENERAL_CATEGORY_MASK) {
      return 1 << u_charType(c);
    }
  }

  else if (which <= (UCHAR_EXTENDED_PICTOGRAPHIC|UCHAR_GRAPHEME_BASE))
  {
    return (*(uint64_t (**)(unsigned int *, void))&dword_18971B820[4 * which + 2])( &dword_18971B820[4 * which],  *(void *)&c);
  }

  return 0;
}

int32_t u_getIntPropertyMinValue(UProperty which)
{
  return 0;
}

int32_t u_getIntPropertyMaxValue(UProperty which)
{
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_REGIONAL_INDICATOR|0xF80))
  {
  }

  else if (which < (UCHAR_BINARY_LIMIT|UCHAR_GRAPHEME_BASE))
  {
    return 1;
  }

  return -1;
}

uint64_t sub_18086C48C(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0) {
    return 0LL;
  }
  if (a1 > 0x4A)
  {
    if (a1 >= 0x1000)
    {
      if (a1 <= 0x1018)
      {
        if (((0x1E3FEE5uLL >> a1) & 1) == 0) {
          return 2LL;
        }
        return LODWORD(qword_18971BCD0[4 * a1 - 0x4000]);
      }

      if (!(a1 >> 14)) {
        return (a1 & 0xFFFFEFFF) == 0x2000;
      }
      if (a1 > 0x400D) {
        return 2 * (a1 == 28672);
      }
      if (a1 - 0x4000 < 0xD) {
        return dword_180A272FC[a1 - 0x4000];
      }
    }

    return 0LL;
  }

  if (dword_18971B820[4 * a1 + 1]) {
    return 2LL;
  }
  return dword_18971B820[4 * a1];
}

uint64_t sub_18086C554(uint64_t result, void *a2, UErrorCode *a3)
{
  int v4 = result;
  if ((_DWORD)result == 17)
  {
    for (uint64_t i = 0LL; i != 10; ++i)
      ((void (*)(void, void))a2[1])(*a2, dword_180A27278[i]);
    for (uint64_t j = 0LL; j != 13; ++j)
    {
      unsigned int v7 = dword_180A272A0[j];
      ((void (*)(void, void))a2[1])(*a2, v7);
      uint64_t result = ((uint64_t (*)(void, void))a2[1])(*a2, v7 + 1);
    }

    return result;
  }

  uint64_t result = sub_18086C694(a3);
  if (!(_DWORD)result) {
    return result;
  }
  if ((v4 - 12) > 2)
  {
    int v13 = 1;
LABEL_17:
    *a3 = v13;
    return result;
  }

  signed int v9 = (uint64_t *)off_18971BFF0[v4 - 12];
  uint64_t v10 = *v9;
  if (!*v9)
  {
    int v13 = 2;
    goto LABEL_17;
  }

  uint64_t result = ucptrie_getRange(*v9, 0LL, 0, 0, 0LL, 0LL, 0LL);
  if ((result & 0x80000000) == 0)
  {
    int v11 = result;
    uint64_t v12 = 0LL;
    do
    {
      ((void (*)(void, uint64_t))a2[1])(*a2, v12);
      uint64_t v12 = (v11 + 1);
      uint64_t result = ucptrie_getRange(v10, v12, 0, 0, 0LL, 0LL, 0LL);
      int v11 = result;
    }

    while ((result & 0x80000000) == 0);
  }

  return result;
}

BOOL sub_18086C694(UErrorCode *a1)
{
  unsigned int v3 = atomic_load(&dword_18C5350DC);
  if (v3 == 2 || !icu::umtx_initImplPreInit(&dword_18C5350DC))
  {
    if (dword_18C5350E0 >= 1) {
      *a1 = dword_18C5350E0;
    }
  }

  else
  {
    int v4 = udata_openChoice( 0LL,  "icu",  "ulayout",  (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18086D5C0,  0LL,  a1);
    qword_18C5350E8 = (uint64_t)v4;
    UErrorCode v5 = *a1;
    if (*(int *)a1 <= 0)
    {
      Memory = (int *)udata_getMemory((uint64_t)v4);
      uint64_t v7 = *Memory;
      if ((int)v7 > 11)
      {
        int v8 = Memory;
        uint64_t v9 = 4 * v7;
        uint64_t v10 = Memory[1];
        if ((int)v10 - (int)v9 >= 16) {
          qword_18C5350B8 = (uint64_t)ucptrie_openFromBinary( -1,  -1,  (uint64_t)&Memory[(unint64_t)v9 / 4],  (int)v10 - (int)v9,  0LL,  (int *)a1);
        }
        uint64_t v11 = v8[2];
        if ((int)v11 - (int)v10 >= 16) {
          qword_18C5350C0 = (uint64_t)ucptrie_openFromBinary( -1,  -1,  (uint64_t)v8 + v10,  (int)v11 - (int)v10,  0LL,  (int *)a1);
        }
        int v12 = v8[3] - v11;
        if (v12 >= 16) {
          qword_18C5350C8 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)v8 + v11, v12, 0LL, (int *)a1);
        }
        unsigned int v13 = v8[9];
        dword_18C5350D0 = HIBYTE(v13);
        dword_18C5350D4 = BYTE2(v13);
        dword_18C5350D8 = BYTE1(v13);
        sub_180820C94(0x14u, (uint64_t)sub_18086D624);
        UErrorCode v5 = *a1;
      }

      else
      {
        UErrorCode v5 = U_INVALID_FORMAT_ERROR;
        *a1 = U_INVALID_FORMAT_ERROR;
      }
    }

    dword_18C5350E0 = v5;
    icu::umtx_initImplPostInit(&dword_18C5350DC);
  }

  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

int32_t u_getFC_NFKC_Closure(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (destCapacity < 0 || !dest && destCapacity)
    {
      int32_t v5 = 0;
      *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return v5;
    }

    NFKCuint64_t Instance = icu::Normalizer2::getNFKCInstance((icu::Normalizer2 *)pErrorCode, (UErrorCode *)dest);
    if (*(int *)pErrorCode <= 0)
    {
      uint64_t v11 = (icu::Normalizer2Factory *)NFKCInstance;
      uint64_t v41 = 0LL;
      __int128 v40 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      int v37 = off_18971B688;
      LOWORD(v38) = 2;
      BOOL v25 = 0LL;
      unsigned int v12 = ucase_toFullFolding(c, &v25, 0);
      if ((v12 & 0x80000000) != 0)
      {
        uint64_t Impl = icu::Normalizer2Factory::getImpl(v11, v13);
        unsigned int v16 = sub_1807E9A8C(Impl, c);
        if (v16 > 0xFE01 || *(unsigned __int16 *)(Impl + 18) > v16 || *(unsigned __int16 *)(Impl + 30) <= v16)
        {
          int32_t v5 = u_terminateUChars((uint64_t)dest, destCapacity, 0LL, (int *)pErrorCode);
LABEL_24:
          icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)&v37);
          return v5;
        }

        UChar32 v14 = c;
      }

      else
      {
        if (v12 < 0x20)
        {
          BOOL v24 = v25;
          icu::UnicodeString::setTo((icu::UnicodeString *)&v37, 0, &v24, v12);
          v22[1] = v24;
LABEL_19:
          uint64_t v36 = 0LL;
          __int128 v34 = 0u;
          __int128 v35 = 0u;
          __int128 v33 = 0u;
          unsigned int v32 = (UChar *)off_18971B688;
          LOWORD(v33) = 2;
          (*(void (**)(icu::Normalizer2Factory *, void (***)(icu::UnicodeString *__hidden), UChar **, UErrorCode *))(*(void *)v11 + 24LL))( v11,  &v37,  &v32,  pErrorCode);
          memset(v31, 0, sizeof(v31));
          icu::UnicodeString::UnicodeString((icu::UnicodeString *)v31, &v32);
          uint64_t v17 = icu::UnicodeString::foldCase((const UChar **)v31, 0LL);
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          __int128 v29 = 0u;
          uint64_t v30 = 0LL;
          unsigned int v26 = off_18971B688;
          LOWORD(v27) = 2;
          (*(void (**)(icu::Normalizer2Factory *, icu::UnicodeString *, void (***)(icu::UnicodeString *__hidden), UErrorCode *))(*(void *)v11 + 24LL))( v11,  v17,  &v26,  pErrorCode);
          if (*(int *)pErrorCode > 0 || sub_1807FF934((uint64_t)&v32, (uint64_t)&v26))
          {
            int32_t v5 = u_terminateUChars((uint64_t)dest, destCapacity, 0LL, (int *)pErrorCode);
          }

          else
          {
            uint64_t v23 = dest;
            int32_t v5 = icu::UnicodeString::extract((uint64_t)&v26, &v23, destCapacity, (int *)pErrorCode);
            v22[0] = v23;
            UChar32 v18 = v22;
          }

          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v26);
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v31);
          icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v32);
          goto LABEL_24;
        }

        UChar32 v14 = v12;
      }

      sub_18086CB20((uint64_t)&v37, v14);
      goto LABEL_19;
    }
  }

  return 0;
}

uint64_t sub_18086CB20(uint64_t a1, unsigned int a2)
{
  else {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }
  return icu::UnicodeString::replace((icu::UnicodeString *)a1, 0LL, v4, a2);
}

BOOL sub_18086CB68(int *a1, unsigned int a2)
{
  return (a1[1] & sub_18081C7AC(a2, *a1)) != 0;
}

uint64_t sub_18086CBA0(uint64_t a1, unsigned int a2)
{
  return sub_180814274(a2);
}

uint64_t sub_18086CBA8(int a1, UChar32 c)
{
  return u_isMirrored_0(c);
}

BOOL sub_18086CBB0(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  int v6 = 0;
  uint64_t NFCImpl = icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)&v6, a2);
  BOOL result = 0LL;
  if (v6 <= 0)
  {
    unsigned int v5 = sub_1807E9A8C(NFCImpl, v2);
    return *(unsigned __int16 *)(NFCImpl + 18) <= v5 && *(unsigned __int16 *)(NFCImpl + 30) > v5;
  }

  return result;
}

uint64_t sub_18086CC20(uint64_t a1, unsigned int a2)
{
  return sub_1808142E8(a2);
}

uint64_t sub_18086CC28(uint64_t a1, unsigned int a2, int a3)
{
  return (char)sub_180819A64(a2, a3);
}

BOOL sub_18086CC48(uint64_t a1, uint64_t a2, int a3)
{
  int v7 = 0;
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3 - 35, (icu::Normalizer2Factory *)&v7);
  uint64_t v5 = 0LL;
  if (v7 <= 0) {
    return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)Instance + 136LL))(Instance, a2) != 0;
  }
  return v5;
}

BOOL sub_18086CCA8(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  UErrorCode v5 = U_ZERO_ERROR;
  uint64_t NFCImpl = (icu::Normalizer2Impl *)icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)&v5, a2);
  BOOL result = 0LL;
  if (v5 <= U_ZERO_ERROR)
  {
    BOOL result = icu::Normalizer2Impl::ensureCanonIterData(NFCImpl, &v5);
    if (result) {
      return icu::Normalizer2Impl::isCanonSegmentStarter(NFCImpl, v2);
    }
  }

  return result;
}

BOOL sub_18086CD10(uint64_t a1, unsigned int a2)
{
  return sub_18081C8C0(a2);
}

uint64_t sub_18086CD18(int a1, UChar32 c)
{
  return u_isblank(c);
}

BOOL sub_18086CD20(uint64_t a1, unsigned int a2)
{
  return sub_18081CE60(a2);
}

BOOL sub_18086CD28(uint64_t a1, unsigned int a2)
{
  return sub_18081CDC4(a2);
}

uint64_t sub_18086CD30(int a1, UChar32 c)
{
  return u_isxdigit(c);
}

BOOL sub_18086CD38(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  uint64_t v34 = *MEMORY[0x1895F89C0];
  __int128 v30 = 0u;
  uint64_t v33 = 0LL;
  __int128 v32 = 0u;
  __int128 v31 = 0u;
  __int128 v29 = off_18971B688;
  LOWORD(v30) = 2;
  UErrorCode pErrorCode = U_ZERO_ERROR;
  NFCuint64_t Instance = icu::Normalizer2::getNFCInstance((icu::Normalizer2 *)&pErrorCode, a2);
  BOOL v4 = 0LL;
  unint64_t v5 = pErrorCode;
  if (pErrorCode > U_ZERO_ERROR) {
    goto LABEL_15;
  }
  if (!(*(unsigned int (**)(uint64_t, UErrorCode *, void (***)(icu::UnicodeString *__hidden)))(*(void *)NFCInstance + 56LL))( NFCInstance,  v2,  &v29))
  {
    if ((v2 & 0x80000000) != 0)
    {
      BOOL v4 = 0LL;
      goto LABEL_15;
    }

uint64_t sub_18086CF7C(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  UErrorCode v18 = U_ZERO_ERROR;
  NFKC_CFuint64_t Impl = icu::Normalizer2Factory::getNFKC_CFImpl((icu::Normalizer2Factory *)&v18, a2);
  uint64_t v4 = 0LL;
  if (v18 <= U_ZERO_ERROR)
  {
    unint64_t v5 = (UChar *)NFKC_CFImpl;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    icu::UnicodeString::UnicodeString((uint64_t)&v24, v2);
    __int128 v20 = 0u;
    uint64_t v23 = 0LL;
    __int128 v22 = 0u;
    __int128 v21 = 0u;
    __int128 v19 = off_18971B688;
    LOWORD(v20) = 2;
    __int128 v17 = 0u;
    unsigned int v13 = v5;
    int v14 = (icu::UnicodeString *)&v19;
    __int128 v16 = 0u;
    __int128 v15 = 0u;
    *(void *)((char *)&v16 + 5) = 0LL;
    if (icu::ReorderingBuffer::init((icu::ReorderingBuffer *)&v13, 5, &v18))
    {
      if ((BYTE8(v24) & 0x11) != 0)
      {
        unsigned int v6 = 0LL;
      }

      else if ((BYTE8(v24) & 2) != 0)
      {
        unsigned int v6 = (UChar *)((unint64_t)&v24 | 0xA);
      }

      else
      {
        unsigned int v6 = (UChar *)*((void *)&v25 + 1);
      }

      int v7 = WORD4(v24) >> 5;
      if (SWORD4(v24) < 0) {
        int v7 = HIDWORD(v24);
      }
      icu::Normalizer2Impl::compose((uint64_t)v5, v6, &v6[v7], 0, 1, &v13, &v18);
    }

    if ((void)v15) {
      icu::UnicodeString::releaseBuffer((uint64_t)v14, ((void)v16 - (void)v15) >> 1);
    }
    unint64_t v8 = v18;
    if (v18 <= U_ZERO_ERROR)
    {
      if ((v20 & 1) != 0)
      {
        unint64_t v8 = BYTE8(v24) & 1;
      }

      else
      {
        unint64_t v8 = 0LL;
        if ((v20 & 0x8000u) == 0LL) {
          int v9 = (unsigned __int16)v20 >> 5;
        }
        else {
          int v9 = DWORD1(v20);
        }
        if ((SWORD4(v24) & 0x8000u) == 0) {
          int v10 = WORD4(v24) >> 5;
        }
        else {
          int v10 = HIDWORD(v24);
        }
        if ((BYTE8(v24) & 1) == 0 && v9 == v10) {
          unint64_t v8 = icu::UnicodeString::doEquals((icu::UnicodeString *)&v19, (const icu::UnicodeString *)&v24, v9);
        }
      }

      uint64_t v4 = v8 ^ 1;
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    icu::UnicodeString::~UnicodeString((void *)v8, (icu::UnicodeString *)&v19);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)&v24);
  }

  return v4;
}

BOOL sub_18086D174(uint64_t a1, unsigned int a2, int a3)
{
  return sub_1807CB5EC(a2, a3);
}

BOOL sub_18086D180(uint64_t a1, int a2)
{
  return (a2 - 127462) < 0x1A;
}

BOOL sub_18086D194(uint64_t a1, unsigned int a2)
{
  return a2 >> 1 == 6143;
}

BOOL sub_18086D1A4(uint64_t a1, int a2)
{
  if (a2 < 8706) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  do
  {
    int v4 = dword_180A272A0[v3];
    if (v4 == a2) {
      break;
    }
  }

  while (v3++ != 12);
  return v4 == a2;
}

BOOL sub_18086D1EC(uint64_t a1, int a2)
{
  unint64_t v2 = 0LL;
  do
  {
    if (dword_180A27278[v2] > a2) {
      return 0LL;
    }
    if (dword_180A27278[v2 + 1] > a2) {
      return 1LL;
    }
    BOOL v3 = v2 > 7;
    v2 += 2LL;
  }

  while (!v3);
  if (a2 < 8706) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  do
  {
    int v6 = dword_180A272A0[v5];
    if (v6 == a2) {
      break;
    }
  }

  while (v5++ != 12);
  return v6 == a2;
}

uint64_t sub_18086D274(int a1, UChar32 c)
{
  return u_charDirection(c);
}

uint64_t sub_18086D27C(uint64_t a1, int a2)
{
  return sub_180814064(a2);
}

uint64_t sub_18086D284(int *a1, unsigned int a2)
{
  return ((int)(a1[1] & sub_18081C7AC(a2, *a1)) >> a1[2]);
}

uint64_t sub_18086D2BC(int *a1)
{
  return (a1[1] & sub_18081D568(*a1)) >> a1[2];
}

uint64_t sub_18086D2EC(int a1, UChar32 c)
{
  return u_getCombiningClass(c);
}

uint64_t sub_18086D304(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_18086D30C(int a1, UChar32 c)
{
  return u_charType(c);
}

uint64_t sub_18086D324(uint64_t a1, int a2)
{
  return sub_1808143D0(a2);
}

uint64_t sub_18086D32C(uint64_t a1, unsigned int a2)
{
  return sub_18081435C(a2);
}

uint64_t sub_18086D334(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = sub_18081D4F8(a2);
  if (v2 < 0x540) {
    int v3 = 2;
  }
  else {
    int v3 = 3;
  }
  if (v2 >= 0x2C0) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 1;
  }
  if (v2 >= 0x40) {
    return v4;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_18086D36C(uint64_t a1, unsigned int a2)
{
  int v3 = 0;
  return uscript_getScript(a2, &v3);
}

uint64_t sub_18086D394()
{
  unsigned int v0 = sub_18081D568(0);
  return v0 | (((v0 >> 20) & 3) << 8);
}

uint64_t sub_18086D3B8(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = (sub_18081C7AC(a2, 2) >> 5) & 0x1F;
  if (v2 > 9) {
    return 0LL;
  }
  else {
    return dword_180A272D4[v2];
  }
}

uint64_t sub_18086D3F4(int a1, uint64_t a2, int a3)
{
  return sub_1807CEAF0(a2, a3 - 4106);
}

uint64_t sub_18086D404(uint64_t a1, signed int a2)
{
  return sub_1807E8B10(a2) >> 8;
}

uint64_t sub_18086D420(uint64_t a1, signed int a2)
{
  return sub_1807E8B10(a2);
}

uint64_t sub_18086D43C(uint64_t a1, unsigned int a2)
{
  return sub_180814410(a2);
}

uint64_t sub_18086D444(uint64_t a1, unsigned int a2)
{
  int v5 = 0;
  BOOL v3 = sub_18086C694((UErrorCode *)&v5);
  uint64_t result = 0LL;
  if (v3)
  {
    if (qword_18C5350B8) {
      return ucptrie_get(qword_18C5350B8, a2);
    }
  }

  return result;
}

uint64_t sub_18086D498(uint64_t a1, int a2)
{
  int v4 = 0;
  uint64_t result = sub_18086C694((UErrorCode *)&v4);
  if ((_DWORD)result)
  {
    switch(a2)
    {
      case 4120:
        return dword_18C5350D8;
      case 4119:
        return dword_18C5350D4;
      case 4118:
        return dword_18C5350D0;
      default:
        return 0LL;
    }
  }

  return result;
}

uint64_t sub_18086D518(uint64_t a1, unsigned int a2)
{
  int v5 = 0;
  BOOL v3 = sub_18086C694((UErrorCode *)&v5);
  uint64_t result = 0LL;
  if (v3)
  {
    if (qword_18C5350C0) {
      return ucptrie_get(qword_18C5350C0, a2);
    }
  }

  return result;
}

uint64_t sub_18086D56C(uint64_t a1, unsigned int a2)
{
  int v5 = 0;
  BOOL v3 = sub_18086C694((UErrorCode *)&v5);
  uint64_t result = 0LL;
  if (v3)
  {
    if (qword_18C5350C8) {
      return ucptrie_get(qword_18C5350C8, a2);
    }
  }

  return result;
}

BOOL sub_18086D5C0(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 76
      && a4[9] == 97
      && a4[10] == 121
      && a4[11] == 111
      && a4[12] == 1;
}

uint64_t sub_18086D624()
{
  qword_18C5350E8 = 0LL;
  ucptrie_close(qword_18C5350B8);
  qword_18C5350B8 = 0LL;
  ucptrie_close(qword_18C5350C0);
  qword_18C5350C0 = 0LL;
  ucptrie_close(qword_18C5350C8);
  qword_18C5350C8 = 0LL;
  dword_18C5350D0 = 0;
  dword_18C5350D4 = 0;
  dword_18C5350D8 = 0;
  atomic_store(0, &dword_18C5350DC);
  return 1LL;
}

char *urbtok_open(int a1, const char *a2, const icu::Locale *a3)
{
  int v4 = ubrk_open(a1, a2, 0LL, 0, a3);
  int v5 = v4;
  return v5;
}

icu::RuleBasedBreakIterator *urbtok_openRules(uint64_t a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  memset(v10, 0, sizeof(v10));
  icu::UnicodeString::UnicodeString((uint64_t)v10, a1, a2);
  int v7 = sub_1807FDC38((UChar **)v10, a3, a4);
  unint64_t v8 = (void *)*(unsigned int *)a4;
  if ((int)v8 <= 0)
  {
    int v5 = v7;
    icu::RuleBasedBreakIterator::initLatin1Cat(v7);
  }

  else
  {
    int v5 = 0LL;
  }

  icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v10);
  return v5;
}

icu::RuleBasedBreakIterator *urbtok_openBinaryRules(unsigned int *a1, UErrorCode *a2)
{
  size_t v6 = a1[2];
  int v7 = uprv_malloc(v6);
  if (!v7)
  {
    BOOL v3 = 0LL;
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    return v3;
  }

  uint64_t v8 = (uint64_t)v7;
  memcpy(v7, a1, v6);
  uint64_t v11 = (icu::RuleBasedBreakIterator *)icu::UMemory::operator new(v10, (icu::UMemory *)0x310, v9);
  BOOL v3 = v11;
  if (!v11)
  {
LABEL_11:
    icu::RuleBasedBreakIterator::initLatin1Cat(v3);
    return v3;
  }

  icu::RuleBasedBreakIterator::RuleBasedBreakIterator(v11, v8, a2);
  (*(void (**)(icu::RuleBasedBreakIterator *))(*(void *)v3 + 8LL))(v3);
  return 0LL;
}

icu::RuleBasedBreakIterator *urbtok_openBinaryRulesNoCopy(uint64_t a1, UErrorCode *a2)
{
  if (!a2) {
    return 0LL;
  }
  BOOL v3 = (uint64_t *)*(unsigned int *)a2;
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = (icu::RuleBasedBreakIterator *)icu::UMemory::operator new(v3, (icu::UMemory *)0x310, (unint64_t)a2);
  int v4 = v8;
  if (!v8)
  {
LABEL_9:
    icu::RuleBasedBreakIterator::initLatin1Cat(v4);
    return v4;
  }

  icu::RuleBasedBreakIterator::RuleBasedBreakIterator(v8, (const unsigned __int8 *)a1, v7, a2);
  (*(void (**)(icu::RuleBasedBreakIterator *))(*(void *)v4 + 8LL))(v4);
  return 0LL;
}

uint64_t urbtok_getBinaryRules(const void *a1, void *a2, unsigned int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if ((a2 || !a3) {
      && a1
    }
    {
      LODWORD(__n) = 0;
      unint64_t v9 = (const void *)(*(uint64_t (**)(void *, size_t *))(*(void *)v8 + 200LL))(v8, &__n);
      uint64_t v5 = __n;
      if (!a2) {
        return v5;
      }
      if (__n <= a3)
      {
        memcpy(a2, v9, __n);
        return v5;
      }

      int v10 = 15;
    }

    else
    {
      uint64_t v5 = 0LL;
      int v10 = 1;
    }

    *a4 = v10;
    return v5;
  }

  return 0LL;
}

unint64_t urbtok_tokenize(uint64_t a1, int a2, char *a3, void *a4)
{
  if (a1 && a3) {
    return icu::RuleBasedBreakIterator::tokenize(a1, a2, a3, a4);
  }
  else {
    return 0LL;
  }
}

_OWORD *urbtok_swapBinaryRules(_DWORD *a1, void *a2, int a3, int a4, int *a5)
{
  char v6 = a3;
  uint64_t result = udata_openSwapper(a3, 0, a4, 0, a5);
  if (a5 && *a5 <= 0)
  {
    uint64_t v10 = (uint64_t)result;
    unsigned int v11 = (*((uint64_t (**)(void))result + 2))(a1[2]);
    size_t v12 = v11 + 24;
    unsigned int v13 = uprv_malloc(v12);
    if (v13)
    {
      int v14 = v13;
      __int128 v15 = (unsigned __int16 *)uprv_malloc(v12);
      if (v15)
      {
        __int128 v16 = v15;
        *int v14 = (*(uint64_t (**)(uint64_t))(v10 + 8))(24LL);
        v14[1] = 10202;
        v14[2] = (*(uint64_t (**)(uint64_t))(v10 + 8))(20LL);
        _DWORD v14[3] = 0;
        *((_BYTE *)v14 + 8) = v6;
        *(_WORD *)((char *)v14 + 9) = 512;
        *((_BYTE *)v14 + 11) = 0;
        int v17 = a1[1];
        *((_DWORD *)v14 + 3) = 543912514;
        *((_DWORD *)v14 + 4) = v17;
        *((_DWORD *)v14 + 5) = 260;
        memcpy(v14 + 12, a1, v11);
        int v21 = ubrk_swap(v10, (uint64_t)v14, v12, v16, a5, v18, v19, v20);
        if (*a5 > 0 || v21 == (_DWORD)v12)
        {
          if (*a5 <= 0) {
            memcpy(a2, v16 + 12, v11);
          }
        }

        else
        {
          *a5 = 3;
        }

        uprv_free(v16);
      }

      else
      {
        *a5 = 7;
      }

      uprv_free(v14);
    }

    else
    {
      *a5 = 7;
    }

    return (_OWORD *)udata_closeSwapper(v10);
  }

  return result;
}

icu::RuleBasedTokenizer *urbtok57_openRules(uint64_t a1, uint64_t a2, UParseError *a3, UErrorCode *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  memset(v12, 0, sizeof(v12));
  icu::UnicodeString::UnicodeString((uint64_t)v12, a1, a2);
  unint64_t v9 = (icu::RuleBasedTokenizer *)icu::UMemory::operator new(v8, (icu::UMemory *)0x260, v7);
  uint64_t v5 = v9;
  if (v9)
  {
    icu::RuleBasedTokenizer::RuleBasedTokenizer(v9, (const icu::UnicodeString *)v12, a3, a4);
    uint64_t v10 = (void *)*(unsigned int *)a4;
    if ((int)v10 >= 1)
    {
      (*(void (**)(icu::RuleBasedTokenizer *))(*(void *)v5 + 8LL))(v5);
      uint64_t v5 = 0LL;
    }
  }

  icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v12);
  return v5;
}

uint64_t *urbtok57_openBinaryRules(unsigned int *a1, UErrorCode *a2)
{
  if (!a2) {
    return 0LL;
  }
  size_t v5 = a1[2];
  uint64_t result = (uint64_t *)uprv_malloc(v5);
  if (!result)
  {
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    return result;
  }

  char v6 = (unsigned __int8 *)result;
  memcpy(result, a1, v5);
  uint64_t result = icu::UMemory::operator new(v8, (icu::UMemory *)0x260, v7);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::RuleBasedTokenizer::RuleBasedTokenizer((icu::RuleBasedTokenizer *)result, v6, a2);
    if (*(int *)a2 >= 1)
    {
      (*(void (**)(uint64_t *))(*result + 8))(result);
      return 0LL;
    }
  }

  return result;
}

uint64_t urbtok57_openBinaryRulesNoCopy(uint64_t a1, int *a2)
{
  if (!a2) {
    return 0LL;
  }
  if (*a2 > 0) {
    return 0LL;
  }
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x260, (unint64_t)a2);
  if (result)
  {
    uint64_t result = icu::RuleBasedTokenizer::RuleBasedTokenizer(result, a1, 0LL, a2);
    if (*a2 >= 1)
    {
      (*(void (**)(uint64_t))(*(void *)result + 8LL))(result);
      return 0LL;
    }
  }

  return result;
}

uint64_t urbtok57_getBinaryRules(const void *a1, void *a2, unsigned int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if ((a2 || !a3) {
      && a1
    }
    {
      LODWORD(__n) = 0;
      unint64_t v9 = (const void *)(*(uint64_t (**)(void *, size_t *))(*(void *)v8 + 192LL))(v8, &__n);
      uint64_t v5 = __n;
      if (!a2) {
        return v5;
      }
      if (__n <= a3)
      {
        memcpy(a2, v9, __n);
        return v5;
      }

      int v10 = 15;
    }

    else
    {
      uint64_t v5 = 0LL;
      int v10 = 1;
    }

    *a4 = v10;
    return v5;
  }

  return 0LL;
}

uint64_t ures_openU(UChar *a1, char *a2, int *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a3 || *a3 > 0) {
    return 0LL;
  }
  bzero(v13, 0x400uLL);
  if (!a1)
  {
    uint64_t v8 = 0LL;
    return ures_open(v8, a2, a3);
  }

  int32_t v7 = u_strlen(a1);
  if (v7 >= 1024)
  {
LABEL_7:
    uint64_t result = 0LL;
    *a3 = 1;
    return result;
  }

  int v9 = v7;
  if (uprv_isInvariantUString(a1, v7))
  {
    int32_t v10 = v9 + 1;
    uint64_t v8 = v13;
    u_UCharsToChars(a1, v13, v10);
    return ures_open(v8, a2, a3);
  }

  uint64_t DefaultConverter = (void *)u_getDefaultConverter((UErrorCode *)a3);
  int v12 = ucnv_fromUChars((uint64_t)DefaultConverter, (unint64_t)v13, 1024, a1, v9, a3);
  u_releaseDefaultConverter(DefaultConverter);
  if (*a3 <= 0)
  {
    if (v12 >= 1024) {
      goto LABEL_7;
    }
    uint64_t v8 = v13;
    return ures_open(v8, a2, a3);
  }

  return 0LL;
}

uint64_t ures_getLocParent(char *Default, void *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0LL;
  }
  if (!Default) {
    Default = (char *)uloc_getDefault(0LL);
  }
  uint64_t v8 = (const char *)sub_18086E040(Default, (uint64_t)"ar_Latn", (uint64_t)"ar_Latn", dword_180A27C80, 714);
  if (!v8) {
    return 0LL;
  }
  int v9 = v8;
  size_t v10 = strlen(v8);
  int v11 = uprv_min(v10, a3);
  memcpy(a2, v9, v11);
  return u_terminateChars((uint64_t)a2, a3, v10, a4);
}

uint64_t sub_18086E040(char *__s1, uint64_t a2, uint64_t a3, int *a4, int a5)
{
  if (!a5) {
    return 0LL;
  }
  uint64_t v5 = a4;
  int v9 = &a4[a5];
  while (1)
  {
    size_t v10 = &v5[2 * ((v9 - v5 + (v9 - v5 < 0 ? 3uLL : 0)) >> 2)];
    int v11 = strcmp(__s1, (const char *)(a2 + *v10));
    if (!v11) {
      break;
    }
    if (v11 < 0) {
      int v9 = &v5[2 * ((v9 - v5 + (v9 - v5 < 0 ? 3uLL : 0)) >> 2)];
    }
    else {
      uint64_t v5 = v10 + 2;
    }
    if (v5 >= v9) {
      return 0LL;
    }
  }

  return a3 + v10[1];
}

double ures_initStackObject(uint64_t a1)
{
  *(void *)(a1 + 128) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

double icu::StackUResourceBundle::StackUResourceBundle(icu::StackUResourceBundle *this)
{
  *((void *)this + 16) = 0LL;
  double result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;
  *((void *)this + 16) = 0LL;
  double result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void icu::StackUResourceBundle::~StackUResourceBundle(icu::StackUResourceBundle *this)
{
}

{
  sub_18086E18C((uint64_t)this, 1);
}

void ures_close(uint64_t a1)
{
}

void sub_18086E18C(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4) {
      sub_180871DB4(v4);
    }
    uint64_t v5 = *(void **)(a1 + 16);
    if (v5) {
      uprv_free(v5);
    }
    char v6 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = 0LL;
    *(_DWORD *)(a1 + 104) = 0;
    if (*(_DWORD *)(a1 + 116) == 19700503 && a2 && *(_DWORD *)(a1 + 120) == 19641227) {
      uprv_free((void *)a1);
    }
  }

char *sub_18086E224(uint64_t a1, __int128 *a2, int *a3)
{
  BOOL v3 = (char *)a1;
  if (a2 && (__int128 *)a1 != a2 && *a3 <= 0)
  {
    if (a1)
    {
      BOOL v6 = *(_DWORD *)(a1 + 116) != 19700503 || *(_DWORD *)(a1 + 120) != 19641227;
      sub_18086E18C(a1, 0);
    }

    else
    {
      BOOL v3 = (char *)uprv_malloc(0x88uLL);
      if (!v3)
      {
        *a3 = 7;
        return v3;
      }

      BOOL v6 = 0;
    }

    __int128 v7 = a2[3];
    __int128 v8 = a2[4];
    __int128 v9 = a2[1];
    *((_OWORD *)v3 + 2) = a2[2];
    __int128 v10 = a2[7];
    uint64_t v11 = *((void *)a2 + 16);
    __int128 v12 = a2[5];
    *((_OWORD *)v3 + 6) = a2[6];
    __int128 v13 = *a2;
    *((_OWORD *)v3 + 3) = v7;
    *((_OWORD *)v3 + 4) = v8;
    *(_OWORD *)BOOL v3 = v13;
    *((_OWORD *)v3 + sub_18086E18C((uint64_t)this, 1) = v9;
    *((void *)v3 + 16) = v11;
    *((_OWORD *)v3 + 7) = v10;
    *((_OWORD *)v3 + 5) = v12;
    *((void *)v3 + 4) = 0LL;
    *((_DWORD *)v3 + 26) = 0;
    uint64_t v14 = (char *)*((void *)a2 + 4);
    if (v14) {
      sub_18086E354((uint64_t)v3, v14, *((_DWORD *)a2 + 26), a3);
    }
    *(int8x8_t *)(v3 + 116) = vand_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(!v6), 0x1FuLL)),  (int8x8_t)0x12BB38B012C9B17LL);
    uint64_t v15 = *((void *)v3 + 1);
    if (v15) {
      sub_18086E41C(v15);
    }
  }

  return v3;
}

char *sub_18086E354(uint64_t a1, char *__src, int a3, _DWORD *a4)
{
  int v7 = *(_DWORD *)(a1 + 104);
  double result = *(char **)(a1 + 32);
  if (result)
  {
    int v9 = v7;
  }

  else
  {
    int v9 = 0;
    *(_BYTE *)(a1 + 40) = 0;
    double result = (char *)(a1 + 40);
    *(void *)(a1 + 32) = a1 + 40;
  }

  int v10 = v9 + a3;
  *(_DWORD *)(a1 + 104) = v10;
  if (v10 < 63) {
    return strcpy(&result[v7], __src);
  }
  if (result == (char *)(a1 + 40))
  {
    double result = (char *)uprv_malloc((v10 + 1));
    *(void *)(a1 + 32) = result;
    if (result)
    {
      double result = strcpy(result, (const char *)(a1 + 40));
      return strcpy(&result[v7], __src);
    }
  }

  else
  {
    double result = (char *)uprv_realloc(result, (v10 + 1));
    if (result)
    {
      *(void *)(a1 + 32) = result;
      return strcpy(&result[v7], __src);
    }
  }

  *a4 = 7;
  return result;
}

void sub_18086E41C(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 16); i; uint64_t i = *(void *)(i + 16))
    ++*(_DWORD *)(i + 108);
  umtx_unlock((std::mutex **)&unk_18C449360);
}

const UChar *ures_getString(uint64_t a1, int *a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    int v5 = 1;
    goto LABEL_9;
  }

  double result = res_getStringNoTrace(*(void *)(a1 + 8) + 40LL, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    int v5 = 17;
LABEL_9:
    double result = 0LL;
    *a3 = v5;
  }

  return result;
}

char *ures_getUTF8String(uint64_t a1, char *a2, int32_t *a3, int a4, int *a5)
{
  int32_t srcLength = 0;
  String = (UChar *)ures_getString(a1, &srcLength, a5);
  return sub_18086E53C(String, srcLength, a2, a3, a4, a5);
}

char *sub_18086E53C(UChar *src, int32_t srcLength, char *dest, int32_t *pDestLength, int a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  BOOL v6 = dest;
  if (!pDestLength)
  {
    int v9 = 0;
    if (srcLength) {
      goto LABEL_12;
    }
    if (!a5) {
      return "";
    }
LABEL_10:
    u_terminateChars((uint64_t)dest, v9, 0LL, a6);
    return v6;
  }

  int v9 = *pDestLength;
  if (*pDestLength < 0 || !dest && v9)
  {
    BOOL v6 = 0LL;
    *a6 = 1;
    return v6;
  }

  if (!srcLength)
  {
    *int32_t pDestLength = 0;
    if (!a5) {
      return "";
    }
    goto LABEL_10;
  }

int *ures_getBinary(uint64_t a1, int *a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    int v5 = 1;
    goto LABEL_9;
  }

  double result = res_getBinaryNoTrace(*(void *)(a1 + 8) + 40LL, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    int v5 = 17;
LABEL_9:
    double result = 0LL;
    *a3 = v5;
  }

  return result;
}

int *ures_getIntVector(uint64_t a1, int *a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    int v5 = 1;
    goto LABEL_9;
  }

  double result = res_getIntVectorNoTrace(*(void *)(a1 + 8) + 40LL, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    int v5 = 17;
LABEL_9:
    double result = 0LL;
    *a3 = v5;
  }

  return result;
}

uint64_t ures_getInt(uint64_t a1, int *a2)
{
  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      unsigned int v2 = *(_DWORD *)(a1 + 108);
      if (v2 >> 28 == 7) {
        return ((int)(16 * v2) >> 4);
      }
      int v4 = 17;
    }

    else
    {
      int v4 = 1;
    }

    *a2 = v4;
  }

  return 0xFFFFFFFFLL;
}

uint64_t ures_getUInt(uint64_t a1, int *a2)
{
  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      unsigned int v2 = *(_DWORD *)(a1 + 108);
      if (v2 >> 28 == 7) {
        return v2 & 0xFFFFFFF;
      }
      int v4 = 17;
    }

    else
    {
      int v4 = 1;
    }

    *a2 = v4;
  }

  return 0xFFFFFFFFLL;
}

uint64_t ures_getType(uint64_t a1)
{
  if (a1) {
    return res_getPublicType(*(_DWORD *)(a1 + 108));
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ures_getKey(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t ures_getSize(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 128);
  }
  return result;
}

uint64_t ures_resetIterator(uint64_t result)
{
  if (result) {
    *(_DWORD *)(result + 124) = -1;
  }
  return result;
}

BOOL ures_hasNext(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 124) < *(_DWORD *)(result + 128) - 1;
  }
  return result;
}

const UChar *ures_getNextString(uint64_t a1, int *a2, void *a3, int *a4)
{
  if (!a4 || *a4 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    int v7 = 1;
    goto LABEL_7;
  }

  int v6 = *(_DWORD *)(a1 + 124);
  if (v6 == *(_DWORD *)(a1 + 128) - 1)
  {
    int v7 = 8;
LABEL_7:
    *a4 = v7;
    return 0LL;
  }

  unsigned int v11 = v6 + 1;
  *(_DWORD *)(a1 + 124) = v6 + 1;
  unsigned int v12 = *(_DWORD *)(a1 + 108);
  switch(v12 >> 28)
  {
    case 0u:
    case 6u:
      return res_getStringNoTrace(*(void *)(a1 + 8) + 40LL, v12, a2);
    case 1u:
    case 7u:
    case 0xEu:
      int v7 = 17;
      goto LABEL_7;
    case 2u:
    case 4u:
    case 5u:
      unsigned int TableItemByIndex = res_getTableItemByIndex(*(void *)(a1 + 8) + 40LL, v12, v11, a3);
      goto LABEL_14;
    case 3u:
      goto LABEL_15;
    case 8u:
    case 9u:
      unsigned int TableItemByIndex = res_getArrayItem(*(void *)(a1 + 8) + 40LL, v12, v11);
LABEL_14:
      unsigned int v12 = TableItemByIndex;
      unsigned int v11 = *(_DWORD *)(a1 + 124);
LABEL_15:
      double result = sub_18086E8DC(a1, v12, v11, a2, a4);
      break;
    default:
      return 0LL;
  }

  return result;
}

const UChar *sub_18086E8DC(uint64_t a1, unsigned int a2, signed int a3, int *a4, int *a5)
{
  if (a2 >> 28 != 3) {
    return res_getStringNoTrace(*(void *)(a1 + 8) + 40LL, a2, a4);
  }
  int v7 = ures_getByIndex(a1, a3, 0LL, a5);
  String = ures_getString((uint64_t)v7, a4, a5);
  sub_18086E18C((uint64_t)v7, 1);
  return String;
}

char *ures_getNextResource(uint64_t a1, uint64_t a2, int *a3)
{
  int v14 = 0LL;
  if (!a3 || *a3 > 0) {
    return (char *)a2;
  }
  if (!a1)
  {
    int v7 = 1;
    goto LABEL_7;
  }

  int v6 = *(_DWORD *)(a1 + 124);
  if (v6 == *(_DWORD *)(a1 + 128) - 1)
  {
    int v7 = 8;
LABEL_7:
    *a3 = v7;
    return (char *)a2;
  }

  unsigned int v9 = v6 + 1;
  *(_DWORD *)(a1 + 124) = v6 + 1;
  unsigned int v10 = *(_DWORD *)(a1 + 108);
  unsigned int v11 = v10 >> 28;
  if (v10 >> 28 != 15)
  {
    if (((1 << v11) & 0x40C3) != 0) {
      return sub_18086E224(a2, (__int128 *)a1, a3);
    }
    if (((1 << v11) & 0x34) != 0)
    {
      unsigned int TableItemByIndex = res_getTableItemByIndex(*(void *)(a1 + 8) + 40LL, v10, v9, &v14);
      return (char *)sub_180871E00( *(void *)(a1 + 8),  TableItemByIndex,  v14,  *(_DWORD *)(a1 + 124),  *(void *)(a1 + 24),  *(char **)(a1 + 32),  0,  a2,  (UErrorCode *)a3);
    }

    else if (((1 << v11) & 0x300) != 0)
    {
      unsigned int ArrayItem = res_getArrayItem(*(void *)(a1 + 8) + 40LL, v10, v9);
      return (char *)sub_180871E00( *(void *)(a1 + 8),  ArrayItem,  0LL,  *(_DWORD *)(a1 + 124),  *(void *)(a1 + 24),  *(char **)(a1 + 32),  0,  a2,  (UErrorCode *)a3);
    }
  }

  return (char *)a2;
}

char *ures_getByIndex(uint64_t a1, signed int a2, uint64_t a3, int *a4)
{
  uint64_t v4 = a3;
  int v14 = 0LL;
  if (!a4 || *a4 > 0) {
    return (char *)v4;
  }
  if (!a1)
  {
    int v11 = 1;
    goto LABEL_12;
  }

  if (a2 < 0 || *(_DWORD *)(a1 + 128) <= a2)
  {
    int v11 = 2;
LABEL_12:
    *a4 = v11;
    return (char *)v4;
  }

  unsigned int v8 = *(_DWORD *)(a1 + 108);
  unsigned int v9 = v8 >> 28;
  if (v8 >> 28 != 15)
  {
    if (((1 << v9) & 0x40C3) != 0) {
      return sub_18086E224(a3, (__int128 *)a1, a4);
    }
    if (((1 << v9) & 0x34) != 0)
    {
      unsigned int TableItemByIndex = res_getTableItemByIndex(*(void *)(a1 + 8) + 40LL, v8, a2, &v14);
      return (char *)sub_180871E00( *(void *)(a1 + 8),  TableItemByIndex,  v14,  a2,  *(void *)(a1 + 24),  *(char **)(a1 + 32),  0,  v4,  (UErrorCode *)a4);
    }

    else if (((1 << v9) & 0x300) != 0)
    {
      unsigned int ArrayItem = res_getArrayItem(*(void *)(a1 + 8) + 40LL, v8, a2);
      return (char *)sub_180871E00( *(void *)(a1 + 8),  ArrayItem,  0LL,  a2,  *(void *)(a1 + 24),  *(char **)(a1 + 32),  0,  v4,  (UErrorCode *)a4);
    }
  }

  return (char *)v4;
}

const UChar *ures_getStringByIndex(uint64_t a1, signed int a2, int *a3, int *a4)
{
  uint64_t v12 = 0LL;
  if (!a4 || *a4 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    double result = 0LL;
    int v10 = 1;
    goto LABEL_11;
  }

  if (a2 < 0 || *(_DWORD *)(a1 + 128) <= a2)
  {
    double result = 0LL;
    int v10 = 2;
LABEL_11:
    *a4 = v10;
    return result;
  }

  unsigned int ArrayItem = *(_DWORD *)(a1 + 108);
  switch(ArrayItem >> 28)
  {
    case 0u:
    case 6u:
      return res_getStringNoTrace(*(void *)(a1 + 8) + 40LL, ArrayItem, a3);
    case 1u:
    case 7u:
    case 0xEu:
      double result = 0LL;
      int v10 = 17;
      goto LABEL_11;
    case 2u:
    case 4u:
    case 5u:
      unsigned int TableItemByIndex = res_getTableItemByIndex(*(void *)(a1 + 8) + 40LL, ArrayItem, a2, &v12);
      return sub_18086E8DC(a1, TableItemByIndex, a2, a3, a4);
    case 3u:
      goto LABEL_16;
    case 8u:
    case 9u:
      unsigned int ArrayItem = res_getArrayItem(*(void *)(a1 + 8) + 40LL, ArrayItem, a2);
LABEL_16:
      double result = sub_18086E8DC(a1, ArrayItem, a2, a3, a4);
      break;
    default:
      double result = 0LL;
      int v10 = 5;
      goto LABEL_11;
  }

  return result;
}

char *ures_getUTF8StringByIndex(uint64_t a1, signed int a2, char *a3, int32_t *a4, int a5, int *a6)
{
  int32_t srcLength = 0;
  StringByIndex = (UChar *)ures_getStringByIndex(a1, a2, &srcLength, a6);
  return sub_18086E53C(StringByIndex, srcLength, a3, a4, a5, a6);
}

uint64_t ures_findResource(const char *a1, uint64_t a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    size_t v6 = (int)(strlen(a1) + 1);
    int v7 = (char *)uprv_malloc(v6);
    if (v7)
    {
      unsigned int v8 = v7;
      memcpy(v7, a1, v6);
      if (*v8 == 47)
      {
        unsigned int v9 = v8 + 1;
        int v10 = strchr(v8 + 1, 47);
        if (v10)
        {
          *int v10 = 0;
          int v11 = v10 + 1;
          goto LABEL_11;
        }

        *a3 = 1;
      }

      else
      {
        unsigned int v9 = 0LL;
      }

      int v11 = v8;
LABEL_11:
      uint64_t v12 = strchr(v11, 47);
      if (v12)
      {
        __int128 v13 = v12;
        *uint64_t v12 = 0;
        uint64_t v14 = sub_18087000C(0LL, v9, v11, 0, a3);
        if (*a3 <= 0)
        {
          uint64_t v15 = v14;
          uint64_t SubResource = ures_findSubResource(v14, v13 + 1, a2, (UErrorCode *)a3);
LABEL_16:
          a2 = SubResource;
          sub_18086E18C(v15, 1);
        }
      }

      else
      {
        int v17 = (__int128 *)sub_18087000C(0LL, v9, v11, 0, a3);
        if (*a3 <= 0)
        {
          uint64_t v15 = (uint64_t)v17;
          uint64_t SubResource = (uint64_t)sub_18086E224(a2, v17, a3);
          goto LABEL_16;
        }
      }

      uprv_free(v8);
      return a2;
    }

    *a3 = 7;
  }

  return a2;
}

uint64_t ures_open(const char *a1, char *a2, int *a3)
{
  return sub_18087000C(0LL, a1, a2, 0, a3);
}

uint64_t ures_findSubResource(uint64_t a1, const char *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v12 = a2;
  if (a4 && *(int *)a4 <= 0)
  {
    uint64_t v6 = a1;
    int v11 = 0LL;
    unsigned int v7 = sub_180875000(*(void *)(a1 + 8) + 40LL, *(unsigned int *)(a1 + 108), &v12, &v11);
    if (v7 == -1)
    {
      uint64_t v6 = a3;
LABEL_9:
      *a4 = U_MISSING_RESOURCE_ERROR;
    }

    else
    {
      unsigned int v8 = v7;
      while (1)
      {
        uint64_t v9 = sub_180871E00( *(void *)(v6 + 8),  v8,  v11,  0xFFFFFFFF,  *(void *)(v6 + 24),  *(char **)(v6 + 32),  0,  a3,  a4);
        uint64_t v6 = v9;
        if (!*v12) {
          break;
        }
        unsigned int v8 = sub_180875000(*(void *)(v9 + 8) + 40LL, *(unsigned int *)(v9 + 108), &v12, &v11);
        if (v8 == -1) {
          goto LABEL_9;
        }
      }
    }

    return v6;
  }

  return a3;
}

const UChar *ures_getStringByKeyWithFallback(uint64_t a1, char *a2, int *a3, UErrorCode *a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  memset(v10, 0, sizeof(v10));
  ures_getByKeyWithFallback(a1, a2, (uint64_t)v10, a4);
  int v9 = 0;
  if (a4 && *(int *)a4 <= 0)
  {
    StringNoTrace = res_getStringNoTrace(*((void *)&v10[0] + 1) + 40LL, HIDWORD(v11), &v9);
    if (!StringNoTrace) {
      *a4 = U_RESOURCE_TYPE_MISMATCH;
    }
  }

  else
  {
    StringNoTrace = 0LL;
  }

  sub_18086E18C((uint64_t)v10, 1);
  int v7 = v9;
  if (v9 == 3)
  {
    if (*StringNoTrace == 8709 && StringNoTrace[1] == 8709 && StringNoTrace[2] == 8709)
    {
      int v7 = 0;
      StringNoTrace = 0LL;
      *a4 = U_MISSING_RESOURCE_ERROR;
    }

    else
    {
      int v7 = 3;
    }
  }

  if (a3) {
    *a3 = v7;
  }
  return StringNoTrace;
}

uint64_t ures_getByKeyWithFallback(uint64_t a1, char *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return a3;
  }

  unsigned int v7 = *(_DWORD *)(a1 + 108);
  if (v7 >> 28 != 2 && (v7 & 0xE0000000) != 0x40000000)
  {
    uint64_t v13 = 0LL;
    *a4 = U_RESOURCE_TYPE_MISMATCH;
LABEL_68:
    sub_18086E18C(v13, 1);
    return a3;
  }

  __int128 v39 = *(unsigned __int8 **)(a1 + 32);
  int v40 = *(_DWORD *)(a1 + 104);
  uint64_t v10 = *(void *)(a1 + 8);
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  uint64_t v52 = 0LL;
  __int128 v51 = 0u;
  __s = (char *)&v49 + 5;
  LODWORD(v49) = 40;
  UErrorCode v47 = U_ZERO_ERROR;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v45, a2);
  icu::CharString::append((icu::CharString *)&__s, v45, v46, &v47);
  if (v47 <= U_ZERO_ERROR)
  {
    uint64_t v14 = __s;
    if (!*__s) {
      goto LABEL_11;
    }
    uint64_t v15 = v10 + 40;
    while (v7 >> 28 == 2 || (v7 & 0xE0000000) == 0x40000000 || (v7 & 0xE0000000) == 0x80000000)
    {
      __int128 v16 = strchr(v14, 47);
      if (v16)
      {
        *__int128 v16 = 0;
        int v17 = v16 + 1;
      }

      else
      {
        int v17 = &v14[strlen(v14)];
      }

      unsigned int v44 = 0;
      __int128 v43 = v14;
      unsigned int TableItemByKey = res_getTableItemByKey(v15, v7, &v44, (const char **)&v43);
      unsigned int v7 = TableItemByKey;
      if (*v17) {
        BOOL v19 = TableItemByKey == -1;
      }
      else {
        BOOL v19 = 1;
      }
      uint64_t v14 = v17;
      if (v19)
      {
        if (*v17) {
          break;
        }
        goto LABEL_11;
      }
    }
  }

  unsigned int v7 = -1;
LABEL_11:
  if (BYTE4(v49)) {
    uprv_free(__s);
  }
  uint64_t v45 = a2;
  uint64_t v11 = *(void *)(a1 + 8);
  if (v7 != -1)
  {
    uint64_t v12 = sub_180871E00(v11, v7, a2, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a3, a4);
    uint64_t v13 = 0LL;
LABEL_67:
    a3 = v12;
    goto LABEL_68;
  }

  uint64_t v13 = 0LL;
  int v20 = 0;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  uint64_t v52 = 0LL;
  __int128 v51 = 0u;
  __s = (char *)&v49 + 5;
  LODWORD(v49) = 40;
  uint64_t v42 = *(char **)(a1 + 32);
  __int128 v43 = 0LL;
  int v41 = *(_DWORD *)(a1 + 104);
  uint64_t v21 = *(void *)(v11 + 16);
  BOOL v22 = v21 == 0;
  while (1)
  {
    if (!v22) {
      uint64_t v11 = v21;
    }
    if (!*(_DWORD *)(v11 + 112)) {
      break;
    }
LABEL_35:
    v20 |= v22;
    uint64_t v21 = *(void *)(v11 + 16);
    BOOL v22 = v21 == 0;
    if ((v22 & v20) != 0)
    {
      *a4 = U_MISSING_RESOURCE_ERROR;
      char v37 = 1;
LABEL_63:
      uint64_t v12 = a3;
      goto LABEL_64;
    }
  }

  uint64_t v23 = *(unsigned int *)(v11 + 72);
  sub_18086F62C(v39, v40, v42, v41, a2, (icu::CharString *)&__s, a4);
  if (*(int *)a4 >= 1)
  {
    sub_18086E18C(v13, 1);
    char v37 = 0;
    goto LABEL_63;
  }

  __int128 v43 = __s;
  uint64_t v45 = a2;
  do
  {
    uint64_t v24 = sub_180875000(v11 + 40, v23, (const char **)&v43, (const char **)&v45);
    unsigned int v25 = v24;
    if (v24 >> 28 == 3)
    {
      if (*v43)
      {
        uint64_t v24 = sub_180871E00(v11, v24, 0LL, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, v13, a4);
        uint64_t v13 = v24;
        if (!v24) {
          break;
        }
        uint64_t v11 = *(void *)(v24 + 8);
        uint64_t v42 = *(char **)(v24 + 32);
        uint64_t v23 = *(unsigned int *)(v24 + 108);
        int v41 = *(_DWORD *)(v24 + 104);
      }
    }

    else if ((_DWORD)v24 == -1)
    {
      goto LABEL_35;
    }
  }

  while (*v43);
  __int128 v26 = *(const char **)v11;
  Default = (const char *)uloc_getDefault(v24);
  if (!strcmp(v26, Default))
  {
    int v28 = -127;
  }

  else if (!strcmp(*(const char **)v11, "root"))
  {
    int v28 = -127;
  }

  else
  {
    int v28 = -128;
  }

  *a4 = v28;
  uint64_t v29 = sub_180871E00(v11, v25, v45, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a3, a4);
  uint64_t v12 = v29;
  if (v42)
  {
    __int128 v30 = v39;
    int v31 = v40;
    int v32 = v41;
    uint64_t v33 = v42;
  }

  else
  {
    uint64_t v34 = *(const char **)(v29 + 32);
    if (v34 && (__int128 v35 = strchr(*(const char **)(v29 + 32), 47)) != 0LL && v35[1])
    {
      int v32 = strlen(v34);
      __int128 v30 = v39;
      int v31 = v40;
      uint64_t v33 = (char *)v34;
    }

    else
    {
      uint64_t v33 = "";
      __int128 v30 = v39;
      int v31 = v40;
      int v32 = 0;
    }
  }

  sub_18086F62C(v30, v31, v33, v32, a2, (icu::CharString *)&__s, a4);
  uint64_t v36 = *(void **)(v12 + 32);
  *(void *)(v12 + 32) = 0LL;
  *(_DWORD *)(v12 + 104) = 0;
  sub_18086E354(v12, __s, v52, a4);
  char v37 = 1;
LABEL_64:
  if (BYTE4(v49)) {
    uprv_free(__s);
  }
  if ((v37 & 1) != 0) {
    goto LABEL_67;
  }
  return a3;
}

icu::CharString *sub_18086F62C( unsigned __int8 *a1, int a2, char *a3, int a4, const char *a5, icu::CharString *this, UErrorCode *a7)
{
  *((_DWORD *)this + 14) = 0;
  **(_BYTE **)this = 0;
  if (a4 < 1)
  {
    uint64_t v24 = v27;
    unsigned int v25 = (icu::StringPiece *)v27;
  }

  else
  {
    icu::CharString::append(this, a3, a4, a7);
    if (*(int *)a7 <= 0)
    {
      uint64_t v14 = a3;
      uint64_t v15 = &a3[a4];
      if (a2 >= 1)
      {
        __int128 v16 = &a1[a2];
        uint64_t v14 = a3;
        do
        {
          do
            int v17 = *a1++;
          while (v17 != 47 && a1 < v16);
          if (v14 < v15)
          {
            BOOL v19 = (char *)(&a3[a4] - v14++);
            while (*(v14 - 1) != 47)
            {
              ++v14;
              if (!--v19)
              {
                uint64_t v14 = &a3[a4];
                break;
              }
            }
          }
        }

        while (a1 < v16 && v14 < v15);
      }

      if (v14 < v15)
      {
        while (1)
        {
          int v20 = *(unsigned __int8 *)a5;
          if (!*a5) {
            break;
          }
          if (v14 < v15)
          {
            uint64_t v21 = (char *)(&a3[a4] - v14++);
            while (*(v14 - 1) != 47)
            {
              ++v14;
              if (!--v21)
              {
                uint64_t v14 = &a3[a4];
                break;
              }
            }
          }

          BOOL v22 = a5;
          if (*a5)
          {
            do
            {
              if (v20 == 47) {
                break;
              }
              int v23 = *(unsigned __int8 *)++v22;
              int v20 = v23;
            }

            while (v23);
          }

          if (v20 == 47) {
            a5 = v22 + 1;
          }
          else {
            a5 = v22;
          }
          if (v14 >= v15)
          {
            if (v20 == 47) {
              a5 = v22 + 1;
            }
            else {
              a5 = v22;
            }
            break;
          }
        }
      }
    }

    uint64_t v24 = v28;
    unsigned int v25 = (icu::StringPiece *)v28;
  }

  icu::StringPiece::StringPiece(v25, a5);
  return icu::CharString::append(this, *(const char **)v24, *((_DWORD *)v24 + 2), a7);
}

void ures_getAllChildrenWithFallback(uint64_t a1, char *a2, uint64_t a3, int *a4)
{
  v4[0] = &off_18971C0A0;
  v4[1] = a3;
  ures_getAllItemsWithFallback(a1, a2, (uint64_t)v4, a4);
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v4);
}

void ures_getAllItemsWithFallback(uint64_t a1, char *a2, uint64_t a3, int *a4)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (*a4 <= 0)
  {
    if (a2)
    {
      uint64_t v8 = 0LL;
      memset(v7, 0, sizeof(v7));
      if (!*a2 || (a1 = ures_getByKeyWithFallback(a1, a2, (uint64_t)v7, (UErrorCode *)a4), *a4 <= 0))
      {
        v6[2] = 0LL;
        v6[0] = &unk_18971C0E8;
        v6[1] = 0LL;
        v6[3] = 0xFFFFFFFFLL;
        sub_18086F954(a1, (uint64_t)v6, a3, a4);
        icu::ResourceValue::~ResourceValue((icu::ResourceValue *)v6);
      }

      sub_18086E18C((uint64_t)v7, 1);
    }

    else
    {
      *a4 = 1;
    }
  }

uint64_t ures_getValueWithFallback(uint64_t result, char *a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    if (a2)
    {
      if (!*a2 || (double result = ures_getByKeyWithFallback(result, a2, a3, a5), *(int *)a5 <= 0))
      {
        uint64_t v7 = *(void *)(result + 24);
        *(void *)(a4 + 8) = *(void *)(result + 8) + 40LL;
        *(void *)(a4 + 16) = v7;
        *(_DWORD *)(a4 + 24) = *(_DWORD *)(result + 108);
      }
    }

    else
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  return result;
}

void sub_18086F954(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (*a4 <= 0)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    *(void *)(a2 + 8) = v8 + 40;
    *(void *)(a2 + 16) = *(void *)(a1 + 24);
    uint64_t v9 = *(void *)(v8 + 16);
    BOOL v10 = v9 && *(_DWORD *)(v9 + 112) < 1;
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 108);
    BOOL v11 = !v10;
    (*(void (**)(uint64_t, void, uint64_t, BOOL, int *))(*(void *)a3 + 24LL))( a3,  *(void *)a1,  a2,  v11,  a4);
    if (!v11)
    {
      v17[0] = 0LL;
      __int128 v18 = 0u;
      uint64_t v25 = 0LL;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      v17[1] = v9;
      *((void *)&v18 + sub_18086E18C((uint64_t)this, 1) = *(void *)(a1 + 24);
      LOBYTE(v24) = *(_BYTE *)(v9 + 96) == 0;
      BYTE1(v24) = 1;
      HIDWORD(v23) = *(_DWORD *)(v9 + 72);
      uint64_t v25 = res_countArrayItems(v9 + 40, HIDWORD(v23));
      HIDWORD(v24) = -1;
      sub_18086E41C(v9);
      uint64_t v16 = 0LL;
      memset(v15, 0, sizeof(v15));
      int v14 = 0;
      uint64_t v12 = *(char **)(a1 + 32);
      if (v12 && *v12)
      {
        uint64_t v13 = (void *)ures_getByKeyWithFallback((uint64_t)v17, v12, (uint64_t)v15, (UErrorCode *)&v14);
        if (v14 > 0)
        {
LABEL_12:
          sub_18086E18C((uint64_t)v15, 1);
          sub_18086E18C((uint64_t)v17, 1);
          return;
        }
      }

      else
      {
        uint64_t v13 = v17;
      }

      sub_18086F954(v13, a2, a3, a4);
      goto LABEL_12;
    }
  }

uint64_t ures_getByKey(uint64_t a1, const char *a2, uint64_t a3, int *a4)
{
  uint64_t v16 = a2;
  if (a4 && *a4 <= 0)
  {
    if (!a1)
    {
      int v13 = 1;
      goto LABEL_16;
    }

    unsigned int v8 = *(_DWORD *)(a1 + 108);
    if (v8 >> 28 != 2 && (v8 & 0xE0000000) != 0x40000000)
    {
      int v13 = 17;
LABEL_16:
      *a4 = v13;
      return a3;
    }

    unsigned int v15 = 0;
    unsigned int TableItemByKey = res_getTableItemByKey(*(void *)(a1 + 8) + 40LL, v8, &v15, &v16);
    unsigned int v17 = TableItemByKey;
    if (TableItemByKey == -1)
    {
      uint64_t v16 = a2;
      if (!*(_BYTE *)(a1 + 112) || (uint64_t v12 = sub_18086FC1C(a1, &v16, &v17, a4), *a4 > 0))
      {
        int v13 = 2;
        goto LABEL_16;
      }

      unsigned int v11 = v17;
    }

    else
    {
      unsigned int v11 = TableItemByKey;
      uint64_t v12 = *(void *)(a1 + 8);
    }

    return sub_180871E00(v12, v11, v16, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a3, (UErrorCode *)a4);
  }

  return a3;
}

uint64_t sub_18086FC1C(uint64_t a1, const char **a2, _DWORD *a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 8);
  unsigned int v17 = -1;
  *a3 = -1;
  if (!v5) {
    goto LABEL_23;
  }
  if (*(_DWORD *)(v5 + 112))
  {
    if (!*(_BYTE *)(a1 + 112))
    {
LABEL_22:
      uint64_t v5 = 0LL;
LABEL_23:
      int v15 = 2;
LABEL_24:
      *a4 = v15;
      return v5;
    }

    int v9 = 0;
  }

  else
  {
    uint64_t TableItemByKey = res_getTableItemByKey(v5 + 40, *(_DWORD *)(v5 + 72), &v17, a2);
    *a3 = TableItemByKey;
    if (!*(_BYTE *)(a1 + 112))
    {
      int v9 = 1;
      goto LABEL_16;
    }

    if ((_DWORD)TableItemByKey != -1) {
      return v5;
    }
    int v9 = 1;
  }

  uint64_t TableItemByKey = 0xFFFFFFFFLL;
  while (1)
  {
    uint64_t v11 = *(void *)(v5 + 16);
    if (!v11) {
      break;
    }
    uint64_t v5 = *(void *)(v5 + 16);
    if (*(_DWORD *)(v11 + 112))
    {
      int v12 = -1;
    }

    else
    {
      ++v9;
      uint64_t TableItemByKey = res_getTableItemByKey(v11 + 40, *(_DWORD *)(v11 + 72), &v17, a2);
      *a3 = TableItemByKey;
      int v12 = TableItemByKey;
    }

    if (v12 != -1) {
      goto LABEL_17;
    }
  }

const UChar *ures_getStringByKey(uint64_t a1, const char *a2, int *a3, int *a4)
{
  __int128 v21 = a2;
  if (a4 && *a4 <= 0)
  {
    if (!a1)
    {
      String = 0LL;
      int v15 = 1;
      goto LABEL_27;
    }

    unsigned int v8 = *(_DWORD *)(a1 + 108);
    if (v8 >> 28 != 2 && (v8 & 0xE0000000) != 0x40000000)
    {
      String = 0LL;
      int v15 = 17;
LABEL_27:
      *a4 = v15;
      return String;
    }

    unsigned int v20 = 0;
    unsigned int TableItemByKey = res_getTableItemByKey(*(void *)(a1 + 8) + 40LL, v8, &v20, &v21);
    unsigned int v22 = TableItemByKey;
    if (TableItemByKey != -1)
    {
      unsigned int v12 = TableItemByKey;
      unsigned int v13 = TableItemByKey >> 28;
      if (TableItemByKey >> 28 == 6)
      {
LABEL_14:
        uint64_t v14 = *(void *)(a1 + 8) + 40LL;
        return res_getStringNoTrace(v14, v12, a3);
      }

      if (v13 != 3)
      {
        if (!v13) {
          goto LABEL_14;
        }
        goto LABEL_25;
      }

char *ures_getUTF8StringByKey(uint64_t a1, const char *a2, char *a3, int32_t *a4, int a5, int *a6)
{
  int32_t srcLength = 0;
  StringByKey = (UChar *)ures_getStringByKey(a1, a2, &srcLength, a6);
  return sub_18086E53C(StringByKey, srcLength, a3, a4, a5, a6);
}

uint64_t ures_getLocaleInternal(uint64_t result, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0LL;
  }
  if (result) {
    return **(void **)(result + 8);
  }
  *a2 = 1;
  return result;
}

uint64_t ures_getLocale(uint64_t result, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0LL;
  }
  if (result) {
    return **(void **)(result + 8);
  }
  *a2 = 1;
  return result;
}

uint64_t ures_getLocaleByType(uint64_t result, int a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0LL;
  }
  if (result)
  {
    if (a2 == 1)
    {
      uint64_t v3 = *(void *)(result + 24);
      return *(void *)v3;
    }

    if (!a2)
    {
      uint64_t v3 = *(void *)(result + 8);
      return *(void *)v3;
    }

    double result = 0LL;
  }

  *a3 = 1;
  return result;
}

uint64_t sub_18086FFFC(uint64_t result)
{
  if (result) {
    return **(void **)(result + 8);
  }
  return result;
}

uint64_t sub_18087000C(uint64_t a1, const char *a2, char *a3, int a4, int *a5)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (*a5 > 0) {
    return 0LL;
  }
  uint64_t v5 = a1;
  if (a4 == 2)
  {
    sub_180872A84(a5);
    if (*a5 > 0) {
      return 0LL;
    }
    if (a3)
    {
      if (*a3) {
        Default = a3;
      }
      else {
        Default = "root";
      }
    }

    else
    {
      Default = (const char *)uloc_getDefault(v11);
    }

    umtx_lock((icu::UMutex *)&unk_18C449360);
    unsigned int v20 = sub_180873194(Default, a2, (UErrorCode *)a5);
    if (*a5 > 0) {
      goto LABEL_25;
    }
    uint64_t v14 = (uint64_t)v20;
    if (v20[28])
    {
      --v20[27];
LABEL_25:
      uint64_t v14 = 0LL;
LABEL_26:
      umtx_unlock((std::mutex **)&unk_18C449360);
      goto LABEL_27;
    }

    v44[0] = v20;
    int v30 = strcmp(Default, "root");
    int v31 = (void *)v14;
    if (!v30
      || (int v31 = (void *)v14, *(void *)(v14 + 16))
      || (int v31 = (void *)v14, *(_BYTE *)(v14 + 96))
      || (v32 = strlen(Default), int v31 = (void *)v14, v32 > 0x9C))
    {
LABEL_65:
      while (1)
      {
        int v31 = (void *)v31[2];
        if (!v31) {
          break;
        }
        ++*((_DWORD *)v31 + 27);
      }

      goto LABEL_26;
    }

    __int128 v52 = 0u;
    memset(v53, 0, sizeof(v53));
    __int128 v50 = 0u;
    __int128 v51 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    *(_OWORD *)__dst = 0u;
    strcpy(__dst, Default);
    uint64_t v33 = strrchr(__dst, 95);
    uint64_t v34 = (const char **)v14;
    if (v33)
    {
      *uint64_t v33 = 0;
      uint64_t v34 = (const char **)v14;
      if (*(_DWORD *)__dst ^ 0x746F6F72 | __dst[4])
      {
        if (!sub_180873494((uint64_t *)v44, __dst, a5))
        {
LABEL_62:
          if (*a5 > 0) {
            goto LABEL_25;
          }
          int v31 = v44[0];
          goto LABEL_65;
        }

        uint64_t v34 = (const char **)v44[0];
      }
    }

    if (strcmp(*v34, "root") && !v34[2]) {
      sub_18087361C((uint64_t)v44, a5);
    }
    goto LABEL_62;
  }

  memset(&v44[1], 0, 56);
  memset(__dst, 0, sizeof(__dst));
  v44[0] = (char *)&v44[1] + 5;
  LODWORD(v44[1]) = 40;
  icu::CharStringByteSink::CharStringByteSink(__dst, (uint64_t)v44);
  ulocimp_getBaseName(a3, (uint64_t)__dst, (UErrorCode *)a5);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__dst);
  int v13 = *a5;
  if (*a5 >= 1)
  {
    uint64_t v14 = 0LL;
    *a5 = 1;
    goto LABEL_17;
  }

  int v15 = (const char *)v44[0];
  int v43 = 0;
  uint64_t v42 = 0LL;
  __int16 v41 = 0;
  char v40 = 1;
  sub_180872A84(a5);
  uint64_t v14 = 0LL;
  if (*a5 <= 0)
  {
    uint64_t v16 = strncpy(__dst, v15, 0x9CuLL);
    v53[28] = 0;
    unsigned int v17 = (const char *)uloc_getDefault(v16);
    umtx_lock((icu::UMutex *)&unk_18C449360);
    uint64_t v18 = sub_180872B34(a2, __dst, v17, a4, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
    int v19 = v43;
    if (v43 == 7)
    {
LABEL_14:
      uint64_t v14 = 0LL;
      goto LABEL_15;
    }

    uint64_t v14 = (uint64_t)v18;
    if (v18)
    {
      uint64_t v42 = v18;
      if (v40)
      {
        int v25 = v41;
        if (!(_BYTE)v41)
        {
LABEL_72:
          int v25 = 0;
        }

uint64_t ures_openNoDefault(const char *a1, char *a2, int *a3)
{
  return sub_18087000C(0LL, a1, a2, 1, a3);
}

uint64_t ures_openDirect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_18087000C(0LL, a1, a2, 2LL, a3);
}

uint64_t ures_openFillIn(uint64_t result, const char *a2, char *a3, int *a4)
{
  if (result || *a4 > 0) {
    return sub_18087000C(result, a2, a3, 0, a4);
  }
  *a4 = 1;
  return result;
}

uint64_t ures_openDirectFillIn(uint64_t result, const char *a2, char *a3, int *a4)
{
  if (result || *a4 > 0) {
    return sub_18087000C(result, a2, a3, 2, a4);
  }
  *a4 = 1;
  return result;
}

uint64_t ures_openWithCountryFallback(const char *a1, char *a2, BOOL *a3, int *a4)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  int v31 = 0;
  if ((int)ulocimp_setRegionToSupplementalRegion(a2, 0LL, 0) >= 1)
  {
    __int128 v43 = 0u;
    memset(v44, 0, sizeof(v44));
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    *(_OWORD *)uint64_t v36 = 0u;
    ulocimp_setRegionToSupplementalRegion(a2, v36, 157);
    if (*a4 <= 0)
    {
      uint64_t v8 = ures_openWithCountryFallback(a1, v36, a3, a4);
      if (a3) {
        *a3 = 1;
      }
      return v8;
    }
  }

  uint64_t v8 = sub_18087000C(0LL, a1, a2, 0, a4);
  if (a3) {
    *a3 = 0;
  }
  *(_DWORD *)__s1 = 0;
  uloc_getCountry((uint64_t)a2, __s1, 4, a4);
  BOOL v9 = *a4 == -128;
  if (!a1 || *a4 != -128) {
    goto LABEL_9;
  }
  if (strcmp(a1, "icudt74l"))
  {
    *(_DWORD *)uint64_t v36 = 0;
    uint64_t v10 = sub_18087000C(0LL, 0LL, a2, 0, (int *)v36);
    sub_18086E18C(v10, 1);
    BOOL v9 = *(_DWORD *)v36 == -128;
LABEL_9:
    if (!v9) {
      return v8;
    }
  }

  if (__s1[0])
  {
    *(_DWORD *)__s2 = 0;
    if (*a4 <= 0)
    {
      if (v8)
      {
        uint64_t v11 = **(void **)(v8 + 8);
      }

      else
      {
        uint64_t v11 = 0LL;
        *a4 = 1;
      }
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    uloc_getCountry(v11, __s2, 4, a4);
    if (strcmp(__s1, __s2))
    {
      int v35 = 0;
      *(void *)__dst = 0LL;
      __int16 v28 = 0;
      *(_DWORD *)__s = 0;
      __int128 v43 = 0u;
      memset(v44, 0, sizeof(v44));
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      *(_OWORD *)uint64_t v36 = 0u;
      uloc_getLanguage((uint64_t)a2, __dst, 12, a4);
      uloc_getScript((uint64_t)a2, __s, 6, a4);
      size_t v12 = strlen(__s);
      size_t v13 = strlen(__dst);
      if (v12) {
        size_t v14 = v12 + 1;
      }
      else {
        size_t v14 = 0LL;
      }
      sprintf(v36, "und_%s", __s1);
      uloc_addLikelySubtags(v36, v36, 157, (UErrorCode *)a4);
      uloc_getLanguage((uint64_t)v36, __dst, 12, a4);
      uloc_getScript((uint64_t)v36, __s, 6, a4);
      if (*a4 > 0) {
        return v8;
      }
      int v15 = &a2[v13 + 1 + v14];
      *a4 = 0;
      sprintf(v36, "%s_%s_%s", __dst, __s, v15);
      uint64_t v16 = sub_18087000C(0LL, a1, v36, 0, a4);
      uint64_t v17 = v16;
      int v18 = *a4;
      if ((*a4 & 0xFFFFFFFE) == 0xFFFFFF80)
      {
        int v33 = 0;
        *(void *)size_t v32 = 0LL;
        if (v16)
        {
          uint64_t v19 = **(void **)(v16 + 8);
        }

        else
        {
          uint64_t v19 = 0LL;
          *a4 = 1;
        }

        uloc_getLanguage(v19, v32, 12, a4);
        int v18 = *a4;
        if (*a4 == -127 || strcmp(__dst, v32))
        {
          unint64_t v20 = 0LL;
          strcpy(__dst, "en");
          while (1)
          {
            size_t v21 = strlen((&off_18971C008)[v20]);
            if (!strncmp(v36, (&off_18971C008)[v20], v21)) {
              break;
            }
            BOOL v22 = v20 >= 8;
            v20 += 2LL;
            if (v22) {
              goto LABEL_36;
            }
          }

          strcpy(__dst, (&off_18971C008)[v20 + 1]);
LABEL_36:
          sprintf(v36, "%s_%s_%s", __dst, __s, v15);
          sub_18086E18C(v17, 1);
          uint64_t v17 = sub_18087000C(0LL, a1, v36, 0, a4);
          int v18 = *a4;
        }
      }

      if (v18 > 0) {
        return v8;
      }
      if (a3)
      {
        if (v8 && v17)
        {
          BOOL v24 = 0;
          int v25 = **(const char ***)(v8 + 8);
          if (v25)
          {
            uint64_t v26 = **(const char ***)(v17 + 8);
            if (v26) {
              BOOL v24 = strcmp(v25, v26) != 0;
            }
          }
        }

        else
        {
          BOOL v24 = 0;
        }

        *a3 = v24;
      }

      sub_18086E18C(v8, 1);
      return v17;
    }
  }

  return v8;
}

uint64_t ures_countArrayItems(uint64_t a1, const char *a2, int *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  memset(v6, 0, sizeof(v6));
  if (a3 && *a3 <= 0)
  {
    if (!a1)
    {
      uint64_t v4 = 0LL;
      *a3 = 1;
      return v4;
    }

    ures_getByKey(a1, a2, (uint64_t)v6, a3);
    if (*(void *)(*((void *)&v6[0] + 1) + 40LL))
    {
      uint64_t v4 = res_countArrayItems(*((void *)&v6[0] + 1) + 40LL, HIDWORD(v7));
      sub_18086E18C((uint64_t)v6, 1);
      return v4;
    }

    *a3 = 2;
    sub_18086E18C((uint64_t)v6, 1);
  }

  return 0LL;
}

char *ures_getVersionNumberInternal(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  unsigned int v2 = *(char **)(a1 + 16);
  if (!v2)
  {
    *(void *)length = 0LL;
    StringByKey = ures_getStringByKey(a1, "Version", length, &length[1]);
    if (length[0] <= 1) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = length[0];
    }
    uint64_t v6 = (char *)uprv_malloc(v5 + 1);
    unsigned int v2 = v6;
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      if (length[0] < 1)
      {
        *(_WORD *)uint64_t v6 = 48;
      }

      else
      {
        u_UCharsToChars(StringByKey, v6, length[0]);
        *(_BYTE *)(*(void *)(a1 + 16) + v5) = 0;
        return *(char **)(a1 + 16);
      }
    }
  }

  return v2;
}

void ures_getVersion(uint64_t a1, uint8_t *a2)
{
  if (a1)
  {
    VersionNumberInternal = ures_getVersionNumberInternal(a1);
    u_versionFromString(a2, VersionNumberInternal);
  }

void *ures_openAvailableLocales(const char *a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  uint64_t v4 = uprv_malloc(0x110uLL);
  unsigned int v5 = uprv_malloc(0x38uLL);
  uint64_t v6 = v5;
  if (!v5 || !v4)
  {
    *a2 = 7;
    uprv_free(v5);
    uprv_free(v4);
    return 0LL;
  }

  *unsigned int v5 = xmmword_18971C058;
  v5[1] = *(_OWORD *)&off_18971C068;
  v5[2] = xmmword_18971C078;
  *((void *)v5 + 6) = sub_180873B68;
  *uint64_t v4 = 0u;
  v4[1] = 0u;
  void v4[2] = 0u;
  v4[3] = 0u;
  _OWORD v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  v4[14] = 0u;
  v4[15] = 0u;
  v4[16] = 0u;
  uint64_t v7 = sub_18087000C(0LL, a1, "res_index", 2, a2);
  ures_getByKey(v7, "InstalledLocales", (uint64_t)v4, a2);
  if (*a2 <= 0)
  {
    v6[1] = v4;
  }

  else
  {
    sub_18086E18C((uint64_t)v4, 1);
    uprv_free(v4);
    uprv_free(v6);
    uint64_t v6 = 0LL;
  }

  sub_18086E18C(v7, 1);
  return v6;
}

uint64_t ures_getFunctionalEquivalent( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  int v11 = v10;
  size_t v13 = v12;
  int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  size_t v21 = v20;
  int v23 = v22;
  BOOL v24 = (char *)v9;
  uint64_t v100 = *MEMORY[0x1895F89C0];
  bzero(v99, 0x400uLL);
  bzero(__s, 0x400uLL);
  memset(&v97[1], 0, 56);
  v97[0] = (char *)&v97[1] + 5;
  LODWORD(v97[1]) = 40;
  bzero(__dst, 0x400uLL);
  bzero(__src, 0x400uLL);
  bzero(v93, 0x400uLL);
  UErrorCode v68 = U_ZERO_ERROR;
  if (*a9 >= 1) {
    return 0LL;
  }
  __int128 v59 = v24;
  uint64_t v92 = 0LL;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  __int128 v84 = 0u;
  __int128 v85 = 0u;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  __int128 v79 = 0u;
  __int128 v80 = 0u;
  __int128 v81 = 0u;
  __int128 v82 = 0u;
  uint64_t v83 = 0LL;
  memset(&__s1[1], 0, 48);
  uint64_t v72 = 0LL;
  __s1[0] = (char *)&__s1[1] + 5;
  LODWORD(__s1[1]) = 40;
  uint64_t v74 = 0LL;
  *(void *)uint64_t v71 = 0LL;
  icu::CharStringByteSink::CharStringByteSink(v71, (uint64_t)__s1);
  ulocimp_getKeywordValue(v15, v17, (uint64_t)v71, (int *)&v68);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v71);
  icu::StringPiece::StringPiece((icu::StringPiece *)&__s2, "default");
  uint64_t v26 = v17;
  if ((_DWORD)v74 == (_DWORD)v67)
  {
    BOOL v27 = __s1[0];
    if (!(_DWORD)v67 || !memcmp(__s1[0], __s2, (int)v67))
    {
      LODWORD(v74) = 0;
      *BOOL v27 = 0;
    }
  }

  *(void *)uint64_t v71 = 0LL;
  uint64_t v72 = 0LL;
  icu::CharStringByteSink::CharStringByteSink(v71, (uint64_t)v97);
  ulocimp_getBaseName(v15, (uint64_t)v71, &v68);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v71);
  __int128 v84 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  uint64_t v92 = 0LL;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  __int128 v79 = 0u;
  __int128 v80 = 0u;
  __int128 v81 = 0u;
  __int128 v82 = 0u;
  uint64_t v83 = 0LL;
  icu::CharString::extract(v97, __src, 1024, &v68);
  icu::CharString::extract(v97, __dst, 1024, &v68);
  if (v13)
  {
    __int16 v28 = (void **)ures_openAvailableLocales(v21, (int *)&v68);
    *size_t v13 = 1;
    if (v68 <= U_ZERO_ERROR)
    {
      do
      {
        int v29 = (const char *)uenum_next((uint64_t)v28, 0LL, (int *)&v68);
        if (!v29)
        {
          char v30 = 0;
          goto LABEL_14;
        }
      }

      while (strcmp(v29, __src));
      char v30 = 1;
LABEL_14:
      *size_t v13 = v30;
    }

    uenum_close(v28);
  }

  if (v68 > U_ZERO_ERROR)
  {
    uint64_t v25 = 0LL;
    *a9 = v68;
    goto LABEL_107;
  }

  do
  {
    UErrorCode v68 = U_ZERO_ERROR;
    uint64_t v31 = sub_18087000C(0LL, v21, __src, 0, (int *)&v68);
    uint64_t v32 = v31;
    if (v13 && (v68 & 0xFFFFFFFE) == 0xFFFFFF80)
    {
      *size_t v13 = 0;
    }

    else if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey(v31, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          *(_DWORD *)uint64_t v71 = 0;
          StringByKey = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
          if (v68 <= U_ZERO_ERROR)
          {
            if (*(_DWORD *)v71)
            {
              uint64_t v34 = StringByKey;
              int32_t v35 = u_strlen(StringByKey);
              u_UCharsToChars(v34, v99, v35);
              strcpy(__s, __src);
              if (!(_DWORD)v74) {
                icu::CharString::append((icu::CharString *)__s1, v99, *(int *)v71, &v68);
              }
            }
          }
        }
      }
    }

    else
    {
      *a9 = v68;
    }

    UErrorCode v68 = U_ZERO_ERROR;
    if (v32) {
      strcpy(__dst, **(const char ***)(v32 + 24));
    }
    if (!strcmp(__dst, __src)) {
      sub_180871960(__dst, v32, (uint64_t)&v84, __src, 1024);
    }
    else {
      strcpy(__src, __dst);
    }
    sub_18086E18C(v32, 1);
    if (v99[0]) {
      break;
    }
    if (!__dst[0]) {
      break;
    }
    if (!(*(_DWORD *)__dst ^ 0x746F6F72 | v96)) {
      break;
    }
    size_t v13 = 0LL;
  }

  while (*a9 < 1);
  icu::CharString::extract(v97, __src, 1024, &v68);
  icu::CharString::extract(v97, __dst, 1024, &v68);
  while (1)
  {
    uint64_t v36 = sub_18087000C(0LL, v21, __src, 0, (int *)&v68);
    uint64_t v37 = v36;
    if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey(v36, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          ures_getByKey((uint64_t)&v84, (const char *)__s1[0], (uint64_t)&v75, (int *)&v68);
          if (v68 == U_ZERO_ERROR)
          {
            strcpy(v93, __src);
            if (!v93[0]) {
              strcpy(v93, "root");
            }
            size_t v38 = strlen(__s);
            if (v38 > strlen(v93))
            {
              *(_DWORD *)uint64_t v71 = 0;
              __int128 v39 = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
              if (v68 <= U_ZERO_ERROR)
              {
                if (*(_DWORD *)v71)
                {
                  __int128 v40 = v39;
                  int32_t v41 = u_strlen(v39);
                  u_UCharsToChars(v40, v99, v41);
                  strcpy(__s, v93);
                }
              }
            }
          }
        }
      }
    }

    else
    {
      *a9 = v68;
    }

    if (v37)
    {
      if (!strcmp(v19, "collations"))
      {
        UErrorCode v68 = U_ZERO_ERROR;
        __int128 v42 = **(const char ***)(v37 + 24);
        if (v42)
        {
          if (*v42 && strcmp(v42, "root"))
          {
            LODWORD(v72) = 0;
            *(void *)uint64_t v71 = 0LL;
            int v70 = 0;
            *(void *)__int128 v69 = 0LL;
            uloc_getLanguage((uint64_t)v42, v71, 12, (int *)&v68);
            uloc_getLanguage((uint64_t)__src, v69, 12, (int *)&v68);
            if (v68 <= U_ZERO_ERROR && strcmp(v71, v69))
            {
              strcpy(__dst, v42);
              UErrorCode v68 = U_ZERO_ERROR;
              goto LABEL_54;
            }

            UErrorCode v68 = U_ZERO_ERROR;
          }
        }
      }
    }

    strcpy(__dst, __src);
LABEL_54:
    sub_180871960(__dst, v37, (uint64_t)&v84, __src, 1023);
    sub_18086E18C(v37, 1);
    UErrorCode v68 = U_ZERO_ERROR;
    if (v93[0] || !__dst[0]) {
      break;
    }
    if (*a9 > 0) {
      goto LABEL_66;
    }
  }

  if (v93[0]) {
    goto LABEL_69;
  }
LABEL_66:
  icu::StringPiece::StringPiece((icu::StringPiece *)&v64, v99);
  if ((_DWORD)v74 == (_DWORD)v65)
  {
    if (!(_DWORD)v65) {
      goto LABEL_69;
    }
    __int128 v43 = __s1[0];
  }

  else
  {
    __int128 v43 = __s1[0];
  }

  LODWORD(v74) = 0;
  _BYTE *v43 = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v62, v99);
  icu::CharString::append((icu::CharString *)__s1, v62, v63, &v68);
  icu::CharString::extract(v97, __src, 1024, &v68);
  icu::CharString::extract(v97, __dst, 1024, &v68);
  while (1)
  {
    uint64_t v47 = sub_18087000C(0LL, v21, __src, 0, (int *)&v68);
    uint64_t v48 = v47;
    if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey(v47, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          ures_getByKey((uint64_t)&v84, (const char *)__s1[0], (uint64_t)&v75, (int *)&v68);
          if (v68 == U_ZERO_ERROR)
          {
            strcpy(v93, __src);
            if (!v93[0]) {
              strcpy(v93, "root");
            }
            size_t v49 = strlen(__s);
            if (v49 > strlen(v93))
            {
              *(_DWORD *)uint64_t v71 = 0;
              __int128 v50 = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
              if (v68 <= U_ZERO_ERROR)
              {
                if (*(_DWORD *)v71)
                {
                  __int128 v51 = v50;
                  int32_t v52 = u_strlen(v50);
                  u_UCharsToChars(v51, v99, v52);
                  strcpy(__s, v93);
                }
              }
            }
          }
        }
      }
    }

    else
    {
      *a9 = v68;
    }

    strcpy(__dst, __src);
    sub_180871960(__dst, v48, (uint64_t)&v84, __src, 1023);
    sub_18086E18C(v48, 1);
    UErrorCode v68 = U_ZERO_ERROR;
    if (v93[0] || !__dst[0]) {
      break;
    }
    if (*a9 > 0) {
      goto LABEL_100;
    }
  }

char *sub_180871960(char *a1, uint64_t a2, uint64_t a3, char *a4, int32_t a5)
{
  int v13 = 0;
  *a4 = 0;
  if (!a2) {
    goto LABEL_9;
  }
  ures_getByKey(a2, "%%Parent", a3, &v13);
  if (v13 > 0) {
    goto LABEL_9;
  }
  int32_t pDestLength = a5;
  int32_t srcLength = 0;
  if (!a3)
  {
    int v10 = 1;
    goto LABEL_7;
  }

  StringNoTrace = (UChar *)res_getStringNoTrace(*(void *)(a3 + 8) + 40LL, *(_DWORD *)(a3 + 108), &srcLength);
  if (!StringNoTrace)
  {
    int v10 = 17;
LABEL_7:
    StringNoTrace = 0LL;
    int v13 = v10;
  }

  double result = sub_18086E53C(StringNoTrace, srcLength, a4, &pDestLength, 1, &v13);
  if (v13 > 0 || !*a4)
  {
LABEL_9:
    int v13 = 0;
    return (char *)uloc_getParent(a1, a4, a5, &v13);
  }

  return result;
}

_OWORD *ures_getKeywordValues(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1895F8858](a1);
  uint64_t v3 = v2;
  unsigned int v5 = v4;
  uint64_t v6 = (const char *)v1;
  *(void *)&v33[2046] = *MEMORY[0x1895F89C0];
  bzero(v33, 0x7FEuLL);
  bzero(v31, 0x1000uLL);
  int v26 = 0;
  memset(v29, 0, sizeof(v29));
  uint64_t v30 = 0LL;
  memset(v27, 0, sizeof(v27));
  uint64_t v28 = 0LL;
  uint64_t v7 = (void **)ures_openAvailableLocales(v6, v3);
  if (*v3 < 1)
  {
    uint64_t v9 = v7;
    __int16 v32 = 0;
    uint64_t v10 = uenum_next((uint64_t)v7, (uint64_t)&v26, v3);
    if (v10)
    {
      int v11 = (char *)v10;
      int v12 = 0;
      int v24 = 0;
      do
      {
        int v25 = 0;
        uint64_t v13 = sub_18087000C(0LL, v6, v11, 0, &v25);
        ures_getByKey(v13, v5, (uint64_t)v29, &v25);
        if (v13)
        {
          if (v25 <= 0)
          {
            NextResource = (const char **)ures_getNextResource((uint64_t)v29, (uint64_t)v27, &v25);
            if (NextResource)
            {
              if (v25 <= 0)
              {
                do
                {
                  int v15 = *NextResource;
                  if (*NextResource && *v15 && strcmp(*NextResource, "default") && strncmp(v15, "private-", 8uLL))
                  {
                    if (v12 >= 1)
                    {
                      uint64_t v16 = v9;
                      uint64_t v17 = v6;
                      int v18 = v5;
                      uint64_t v19 = v12;
                      unint64_t v20 = (const char **)v31;
                      do
                      {
                        if (!strcmp(*v20, v15))
                        {
                          unsigned int v5 = v18;
                          uint64_t v6 = v17;
                          uint64_t v9 = v16;
                          goto LABEL_22;
                        }

                        ++v20;
                        --v19;
                      }

                      while (v19);
                      unsigned int v5 = v18;
                      uint64_t v6 = v17;
                      uint64_t v9 = v16;
                      if (v12 > 510) {
                        goto LABEL_19;
                      }
                    }

                    int v21 = strlen(v15);
                    uint64_t v22 = v24;
                    uint64_t v23 = v24 + (uint64_t)v21;
                    if ((int)v23 < 2046)
                    {
                      int v24 = v23 + 1;
                      v31[v12++] = strcpy(&v33[v22 - 2], v15);
                      v33[v23 - 2] = 0;
                    }

                    else
                    {
LABEL_19:
                      *uint64_t v3 = 1;
                    }
                  }

void ures_getVersionByKey(uint64_t a1, const char *a2, uint8_t *a3, int *a4)
{
  int v7 = 0;
  StringByKey = ures_getStringByKey(a1, a2, &v7, a4);
  if (*a4 <= 0) {
    u_versionFromUString(a3, StringByKey);
  }
}

void sub_180871DB4(uint64_t a1)
{
  if (a1)
  {
    do
    {
      uint64_t v2 = *(void *)(a1 + 16);
      --*(_DWORD *)(a1 + 108);
      a1 = v2;
    }

    while (v2);
  }

  umtx_unlock((std::mutex **)&unk_18C449360);
}

uint64_t sub_180871E00( uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, uint64_t a5, char *a6, int a7, uint64_t a8, UErrorCode *a9)
{
  uint64_t v9 = a8;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a5)
  {
    if (a2 >> 28 == 3)
    {
      if (a7 < 256) {
        return sub_1808720BC(a1 + 40, a2, a3, a4, a5, a6, a7, a8, a9);
      }
      int v16 = 24;
      goto LABEL_8;
    }

    if (a8)
    {
      uint64_t v17 = *(void *)(a8 + 8);
      if (v17) {
        sub_180871DB4(v17);
      }
      int v18 = *(void **)(v9 + 16);
      if (v18) {
        uprv_free(v18);
      }
      uint64_t v19 = *(char **)(v9 + 32);
      if (v19 == a6)
      {
LABEL_22:
        *(void *)(v9 + 8) = a1;
        sub_18086E41C(a1);
        *(_WORD *)(v9 + 112) = 0;
        *(_DWORD *)(v9 + 124) = -1;
        *(void *)uint64_t v9 = a3;
        *(void *)(v9 + 24) = a5;
        if (*(char **)(v9 + 32) != a6)
        {
          int v22 = strlen(a6);
          sub_18086E354(v9, a6, v22, a9);
        }

        if (a3)
        {
          int v23 = strlen(a3);
          uint64_t v24 = v9;
          int v25 = (char *)a3;
        }

        else
        {
          if ((a4 & 0x80000000) != 0)
          {
LABEL_30:
            if (v9 + 40 == *(void *)(v9 + 32)) {
              uint64_t v26 = *(int *)(v9 + 104);
            }
            else {
              uint64_t v26 = 0LL;
            }
            bzero((void *)(v9 + 40 + v26), 64 - v26);
            *(void *)(v9 + 16) = 0LL;
            *(_DWORD *)(v9 + 108) = a2;
            *(_DWORD *)(v9 + 128) = res_countArrayItems(*(void *)(v9 + 8) + 40LL, a2);
            return v9;
          }

          memset(v27, 0, sizeof(v27));
          int v23 = T_CString_integerToString(v27, a4, 0xAu);
          int v25 = (char *)v27;
          uint64_t v24 = v9;
        }

        sub_18086E354(v24, v25, v23, a9);
        goto LABEL_30;
      }

uint64_t sub_1808720BC( uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, uint64_t a5, const char *a6, int a7, uint64_t a8, UErrorCode *a9)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  int32_t v50 = 0;
  Alias = res_getAlias(a1, a2, &v50);
  if (v50 <= 0)
  {
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return a8;
  }

  memset(&__s[1], 0, 48);
  __s[0] = (char *)&__s[1] + 5;
  LODWORD(__s[1]) = 40;
  uint64_t v56 = 0LL;
  icu::CharString::appendInvariantChars((int *)__s, (UChar *)Alias, v50, a9);
  uint64_t v16 = 0LL;
  if (*(int *)a9 <= 0)
  {
    uint64_t v17 = __s[0];
    if (*__s[0] == 47)
    {
      int v18 = __s[0] + 1;
      uint64_t v19 = strchr(__s[0] + 1, 47);
      uint64_t v17 = v19;
      if (v19)
      {
        *uint64_t v19 = 0;
        uint64_t v17 = v19 + 1;
      }

      if (!strcmp(v18, "LOCALE"))
      {
        uint64_t v41 = 0LL;
        uint64_t v26 = a5;
        goto LABEL_22;
      }

      if (!strcmp(v18, "ICUDATA")) {
        unint64_t v20 = 0LL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v17)
      {
        int v21 = strchr(v17, 47);
        int v22 = v21;
        if (v21)
        {
          *int v21 = 0;
          int v22 = v21 + 1;
        }
      }

      else
      {
        int v22 = 0LL;
        uint64_t v17 = "";
      }
    }

    else
    {
      int v23 = strchr(__s[0], 47);
      int v22 = v23;
      if (v23)
      {
        *int v23 = 0;
        int v22 = v23 + 1;
      }

      unint64_t v20 = *(const char **)(a5 + 8);
    }

    LODWORD(__dst[0]) = 0;
    uint64_t v24 = sub_18087000C(0LL, v20, v17, 2LL, __dst);
    uint64_t v25 = v24;
    if (SLODWORD(__dst[0]) > 0)
    {
      *a9 = (UErrorCode)__dst[0];
LABEL_72:
      if (v25) {
        sub_18086E18C(v25, 1);
      }
      uint64_t v16 = a8;
      goto LABEL_75;
    }

    uint64_t v41 = v24;
    uint64_t v26 = *(void *)(v24 + 8);
    uint64_t v17 = v22;
LABEL_22:
    __s2 = 0LL;
    if (v17)
    {
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      *(_OWORD *)__dst = 0u;
      __int128 v52 = 0u;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v43, v17);
      __dst[0] = (char *)((unint64_t)__dst | 0xD);
      LODWORD(__dst[1]) = 40;
      WORD2(__dst[1]) = 0;
      DWORD2(v54) = 0;
      icu::CharString::append((icu::CharString *)__dst, v43, v44, a9);
      UErrorCode v27 = *a9;
      if (*(int *)a9 <= 0)
      {
        uint64_t v30 = 0LL;
        uint64_t v31 = __dst[0];
        __int128 v42 = __dst[0];
        uint64_t v32 = (a7 + 1);
        UErrorCode v33 = v27;
        uint64_t v28 = a8;
        while (1)
        {
          uint64_t v34 = *(unsigned int *)(v26 + 72);
          while (*v31)
          {
            if (v33 > U_ZERO_ERROR) {
              goto LABEL_25;
            }
            uint64_t v34 = sub_180875000(v26 + 40, v34, (const char **)&v42, (const char **)&__s2);
            if ((_DWORD)v34 == -1)
            {
              UErrorCode v33 = *a9;
              break;
            }

            uint64_t v28 = sub_180871E00(v26, v34, __s2, 0xFFFFFFFFLL, a5, v30, v32, v28, a9);
            UErrorCode v33 = *a9;
            if (!__s2 || strcmp(v17, __s2))
            {
              int32_t v35 = *(void **)(v28 + 32);
              if (v35) {
                BOOL v36 = v35 == (void *)(v28 + 40);
              }
              else {
                BOOL v36 = 1;
              }
              if (!v36) {
                uprv_free(v35);
              }
              *(void *)(v28 + 32) = 0LL;
              *(_DWORD *)(v28 + 104) = 0;
              int v37 = strlen(v17);
              sub_18086E354(v28, v17, v37, a9);
              UErrorCode v33 = *a9;
            }

            uint64_t v26 = *(void *)(v28 + 8);
            uint64_t v30 = *(void *)(v28 + 32);
            uint64_t v34 = *(unsigned int *)(v28 + 108);
            uint64_t v31 = v42;
          }

          if (v33 > U_ZERO_ERROR || (_DWORD)v34 != -1) {
            break;
          }
          uint64_t v26 = *(void *)(v26 + 16);
          if (!v26)
          {
            *a9 = U_MISSING_RESOURCE_ERROR;
            break;
          }

          __int128 v42 = __dst[0];
          strcpy(__dst[0], v17);
          uint64_t v31 = v42;
          UErrorCode v33 = *a9;
        }
      }

      else
      {
        uint64_t v28 = a8;
        a8 = 0LL;
      }

void sub_180872644(icu::ResourceSink *a1)
{
}

void sub_180872658(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v31 = 0LL;
  uint64_t v32 = a2;
  memset(v30, 0, sizeof(v30));
  (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88LL))(v30, a3, a5);
  if (*(int *)a5 <= 0
    && icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, 0, (const char **)&v32, a3))
  {
    unsigned int v9 = 0;
    do
    {
      if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24LL))(a3) == 3)
      {
        uint64_t v40 = 0LL;
        memset(v39, 0, sizeof(v39));
        uint64_t v10 = sub_1808720BC( *((void *)a3 + 1),  *((_DWORD *)a3 + 6),  0LL,  0xFFFFFFFF,  *((void *)a3 + 2),  0LL,  0,  (uint64_t)v39,  a5);
        if (*(int *)a5 <= 0)
        {
          uint64_t v11 = v10;
          uint64_t v29 = 0LL;
          uint64_t v27 = 0LL;
          uint64_t v28 = 0LL;
          uint64_t v12 = *(void *)(v10 + 8) + 40LL;
          uint64_t v26 = &unk_18971C0E8;
          uint64_t v27 = v12;
          uint64_t v28 = *(void *)(v10 + 24);
          LODWORD(v29) = *(_DWORD *)(v10 + 108);
          if (sub_180874158((uint64_t)&v26) == 2)
          {
            int v38 = 0;
            memset(&v36[1], 0, 48);
            v36[0] = (char *)&v36[1] + 5;
            LODWORD(v36[1]) = 40;
            int v37 = 0;
            icu::StringPiece::StringPiece((icu::StringPiece *)&v24, *(const char **)(v11 + 32));
            icu::CharString::append((icu::CharString *)v36, v24, v25, a5);
            uint64_t v19 = v32;
            (*(void (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
            uint64_t v13 = *(void *)(v11 + 8);
            int v14 = 2;
            while (v14 == 2 && *(void *)(v13 + 16))
            {
              int v35 = 0;
              memset(&v33[1], 0, 48);
              v33[0] = (char *)&v33[1] + 5;
              LODWORD(v33[1]) = 40;
              int v34 = 0;
              icu::CharString::copyFrom(v33, v36, a5);
              int v22 = 0LL;
              int v23 = (const char *)v33[0];
              uint64_t v13 = *(void *)(v13 + 16);
              int v15 = sub_180875000(v13 + 40, *(unsigned int *)(v13 + 72), &v23, &v22);
              if (v15 == -1)
              {
                char v18 = 1;
                int v14 = 2;
              }

              else
              {
                uint64_t v27 = v13 + 40;
                LODWORD(v29) = v15;
                int v14 = sub_180874158((uint64_t)&v26);
                if (v14 == 3)
                {
                  uint64_t v16 = sub_1808720BC(v27, v29, 0LL, 0xFFFFFFFF, v28, 0LL, 0, (uint64_t)v39, a5);
                  int v37 = 0;
                  *(_BYTE *)v36[0] = 0;
                  icu::StringPiece::StringPiece((icu::StringPiece *)&v20, *(const char **)(v16 + 32));
                  icu::CharString::append((icu::CharString *)v36, v20, v21, a5);
                  uint64_t v13 = *(void *)(v16 + 8);
                  int v17 = *(_DWORD *)(v16 + 108);
                  uint64_t v27 = v13 + 40;
                  LODWORD(v29) = v17;
                  int v14 = sub_180874158((uint64_t)&v26);
                }

                if (v14 == 2)
                {
                  (*(void (**)(void, char *, void **, uint64_t, UErrorCode *))(**(void **)(a1 + 8) + 24LL))( *(void *)(a1 + 8),  v19,  &v26,  a4,  a5);
                  char v18 = 1;
                }

                else
                {
                  char v18 = 0;
                  *a5 = U_INTERNAL_PROGRAM_ERROR;
                }
              }

              if (BYTE4(v33[1])) {
                uprv_free((void *)v33[0]);
              }
              if ((v18 & 1) == 0)
              {
                if (BYTE4(v36[1])) {
                  uprv_free((void *)v36[0]);
                }
                icu::ResourceValue::~ResourceValue((icu::ResourceValue *)&v26);
                sub_18086E18C((uint64_t)v39, 1);
                return;
              }
            }

            if (BYTE4(v36[1])) {
              uprv_free((void *)v36[0]);
            }
          }

          else
          {
            (*(void (**)(void, char *, void **, uint64_t, UErrorCode *))(**(void **)(a1 + 8) + 24LL))( *(void *)(a1 + 8),  v32,  &v26,  a4,  a5);
          }

          icu::ResourceValue::~ResourceValue((icu::ResourceValue *)&v26);
        }

        sub_18086E18C((uint64_t)v39, 1);
      }

      else
      {
        (*(void (**)(void, char *, icu::ResourceValue *, uint64_t, UErrorCode *))(**(void **)(a1 + 8)
                                                                                            + 24LL))( *(void *)(a1 + 8),  v32,  a3,  a4,  a5);
      }

      ++v9;
    }

    while (icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, v9, (const char **)&v32, a3));
  }

void sub_180872A84(int *a1)
{
  if (*a1 <= 0)
  {
    unsigned int v2 = atomic_load(&dword_18C4493B0);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_18C4493B0))
    {
      if (dword_18C4493B4 >= 1) {
        *a1 = dword_18C4493B4;
      }
    }

    else
    {
      qword_18C4493B8 = (uint64_t)uhash_open((uint64_t)sub_18087369C, (uint64_t)sub_1808736D4, 0LL, a1);
      sub_180820C94(0x1Cu, (uint64_t)sub_180873718);
      dword_18C4493B4 = *a1;
      icu::umtx_initImplPostInit(&dword_18C4493B0);
    }
  }

const char **sub_180872B34( const char *a1, char *a2, const char *a3, int a4, BOOL *a5, _BYTE *a6, BOOL *a7, UErrorCode *a8)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  *a6 = 1;
  __int128 v58 = 0u;
  memset(v59, 0, sizeof(v59));
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  *(_OWORD *)__dst = 0u;
  strcpy(__dst, a2);
  while (1)
  {
    int v15 = (const char **)sub_180873194(a2, a1, a8);
    uint64_t v16 = v15;
    size_t v17 = strlen(a2);
    *a7 = strncmp(a2, a3, v17) == 0;
    int v18 = *((_DWORD *)v16 + 28);
    if (v18)
    {
      --*((_DWORD *)v16 + 27);
      uint64_t v16 = 0LL;
      *a8 = U_USING_FALLBACK_WARNING;
    }

    else
    {
      strcpy(a2, *v16);
    }

    *a5 = strcmp(a2, "root") == 0;
    uint64_t v19 = a2;
    if (!v18) {
      break;
    }
    size_t v20 = strlen(a2);
    if (!v20 || a2[v20 - 1] == 95 || (LODWORD(v77[0]) = 0, uloc_getVariant(a2, 0LL, 0, (int *)v77)))
    {
      uint64_t v19 = a2;
      break;
    }

    UErrorCode v50 = U_ZERO_ERROR;
    size_t v49 = a2;
    __int128 v78 = 0u;
    memset(v77, 0, sizeof(v77));
    sub_18084DA08((uint64_t)a2, &v49, &v50, (uint64_t)v77);
    int v23 = (icu::CharString *)v49;
    if (*v49 == 95) {
      int v23 = (icu::CharString *)++v49;
    }
    __int128 v76 = 0u;
    memset(v75, 0, sizeof(v75));
    sub_18084DB88(v23, &v49, &v50, (uint64_t)v75);
    uint64_t v24 = (uint64_t)v49;
    if (*v49 == 95) {
      uint64_t v24 = (uint64_t)++v49;
    }
    __int128 v74 = 0u;
    memset(v73, 0, sizeof(v73));
    sub_18084DC94(v24, (uint64_t *)&v49, &v50, (uint64_t)v73);
    uint64_t v72 = 0LL;
    memset(&__src[1], 0, 48);
    __src[0] = (char *)&__src[1] + 5;
    LODWORD(__src[1]) = 40;
    if (v50 >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      int v25 = strrchr(a2, 95);
      if (!v25) {
        goto LABEL_39;
      }
      *int v25 = 0;
      goto LABEL_69;
    }

    if (!a4)
    {
      uint64_t v27 = sub_18086E040(a2, (uint64_t)"ar_Latn", (uint64_t)"ar_Latn", dword_180A27C80, 714);
      if (v27)
      {
        uint64_t v28 = (const char *)v27;
LABEL_68:
        strcpy(a2, v28);
LABEL_69:
        LOBYTE(v3sub_18086E18C((uint64_t)this, 1) = 1;
        goto LABEL_70;
      }
    }

    if (DWORD2(v76))
    {
      if (DWORD2(v74))
      {
        sub_180873864((uint64_t)v77, (uint64_t)v73, (uint64_t)&__s1);
        if (DWORD2(v70) == DWORD2(v76))
        {
          if (DWORD2(v76)) {
            BOOL v26 = memcmp((const void *)__s1, v75[0], SDWORD2(v76)) == 0;
          }
          else {
            BOOL v26 = 1;
          }
        }

        else
        {
          BOOL v26 = 0;
        }

        if (BYTE12(__s1)) {
          uprv_free((void *)__s1);
        }
        int v38 = icu::CharString::append((icu::CharString *)__src, v77[0], SDWORD2(v78), &v50);
        if (v26)
        {
          icu::StringPiece::StringPiece((icu::StringPiece *)&v47, "_");
          UErrorCode v33 = icu::CharString::append(v38, v47, v48, &v50);
          int v34 = (const char *)v73[0];
          int v35 = DWORD2(v74);
        }

        else
        {
          icu::StringPiece::StringPiece((icu::StringPiece *)&v45, "_");
          UErrorCode v33 = icu::CharString::append(v38, v45, v46, &v50);
          int v34 = (const char *)v75[0];
          int v35 = DWORD2(v76);
        }
      }

      else
      {
        if (!a4)
        {
          *(void *)&__int128 v63 = (char *)&v63 + 13;
          DWORD2(v63) = 40;
          WORD6(v63) = 0;
          DWORD2(v66) = 0;
          sub_180873864((uint64_t)v77, (uint64_t)&v63, (uint64_t)&__s1);
          BOOL v31 = 0;
          if (DWORD2(v70) == DWORD2(v76))
          {
            if (DWORD2(v76)) {
              BOOL v31 = memcmp((const void *)__s1, v75[0], SDWORD2(v76)) == 0;
            }
            else {
              BOOL v31 = 1;
            }
          }

          if (BYTE12(__s1)) {
            uprv_free((void *)__s1);
          }
          if (BYTE12(v63)) {
            uprv_free((void *)v63);
          }
          if (!v31) {
            goto LABEL_70;
          }
        }

        int v34 = v77[0];
        int v35 = DWORD2(v78);
        UErrorCode v33 = (icu::CharString *)__src;
      }

      icu::CharString::append(v33, v34, v35, &v50);
    }

    else
    {
      if (!DWORD2(v74))
      {
LABEL_39:
        LOBYTE(v3sub_18086E18C((uint64_t)this, 1) = 0;
        goto LABEL_70;
      }

      UErrorCode v44 = U_ZERO_ERROR;
      size_t v49 = __dst;
      __int128 v69 = 0u;
      __int128 v70 = 0u;
      __int128 __s1 = 0u;
      __int128 v68 = 0u;
      sub_18084DA08((uint64_t)__dst, &v49, &v44, (uint64_t)&__s1);
      if (*v49 == 95) {
        ++v49;
      }
      __int128 v65 = 0u;
      __int128 v66 = 0u;
      __int128 v63 = 0u;
      __int128 v64 = 0u;
      sub_18084DB88((icu::CharString *)__dst, 0LL, &v44, (uint64_t)&v63);
      int v29 = DWORD2(v66);
      int v37 = icu::CharString::append((icu::CharString *)__src, v77[0], SDWORD2(v78), &v44);
      if (v29)
      {
        icu::StringPiece::StringPiece((icu::StringPiece *)&v42, "_");
        uint64_t v30 = icu::CharString::append(v37, v42, v43, &v44);
        icu::CharString::append(v30, (const char *)v63, SDWORD2(v66), &v44);
      }

      else
      {
        icu::StringPiece::StringPiece((icu::StringPiece *)&v40, "_");
        uint64_t v32 = icu::CharString::append(v37, v40, v41, &v44);
        sub_180873864((uint64_t)v77, (uint64_t)v73, (uint64_t)&v60);
        icu::CharString::append(v32, v60, v62, &v44);
        if (v61) {
          uprv_free(v60);
        }
      }

      if (BYTE12(v63)) {
        uprv_free((void *)v63);
      }
      if (BYTE12(__s1)) {
        uprv_free((void *)__s1);
      }
    }

    LOBYTE(v3sub_18086E18C((uint64_t)this, 1) = 0;
    if (v50 <= U_ZERO_ERROR && (_DWORD)v72)
    {
      uint64_t v28 = __src[0];
      goto LABEL_68;
    }

LABEL_70:
    if (BYTE4(__src[1])) {
      uprv_free(__src[0]);
    }
    if (BYTE4(v73[1])) {
      uprv_free(v73[0]);
    }
    if (BYTE4(v75[1])) {
      uprv_free((void *)v75[0]);
    }
    if (BYTE4(v77[1])) {
      uprv_free((void *)v77[0]);
    }
    *a6 = v31;
    if (v31) {
      goto LABEL_13;
    }
    int v22 = 0;
LABEL_17:
    if (!v22) {
      return v16;
    }
  }

  int v21 = strrchr(v19, 95);
  if (v21)
  {
    *int v21 = 0;
    *a6 = 1;
LABEL_13:
    if (*a2)
    {
      int v22 = 1;
      if (!v18) {
        return v16;
      }
    }

    else
    {
      *(_DWORD *)a2 = 6581877;
      int v22 = *a6;
      if (!v18) {
        return v16;
      }
    }

    goto LABEL_17;
  }

  *a6 = 0;
  return v16;
}

    icu::UnicodeString::~UnicodeString((void *)v40, (icu::UnicodeString *)v58);
    __int128 v8 = v12 + 1;
  }

  while (v12 != -1);
  if (v7) {
    icu::SimpleDateFormat::NSOverride::free(v7);
  }
LABEL_82:
  icu::UnicodeString::~UnicodeString(v44, (icu::UnicodeString *)&v59);
  return icu::UnicodeString::~UnicodeString(v45, (icu::UnicodeString *)&v64);
}

          icu::SimpleDateFormat::zeroPaddingNumber(v35, v36, v37, v38, v39, v40);
        }

        goto LABEL_165;
      case 0x23u:
        if (icu::Calendar::get(a9, 0xBu, a10) == 12
          && (!*(_BYTE *)(v14 + 792) || !icu::Calendar::get(a9, 0xCu, a10))
          && (!*(_BYTE *)(v14 + 793) || !icu::Calendar::get(a9, 0xDu, a10)))
        {
          __int128 v57 = icu::Calendar::get(a9, 9u, a10);
          if ((int)a4 > 3)
          {
            unsigned int v126 = *(void *)(v14 + 768);
            __int128 v59 = v57;
            else {
              __int128 v58 = *(void *)(v126 + 896);
            }
          }

          else
          {
            __int128 v58 = *(void *)(*(void *)(v14 + 768) + 864LL);
            __int128 v59 = v57;
          }

          uint64_t v155 = v58 + (v59 << 6);
          if (v155)
          {
            int v156 = *(unsigned __int16 *)(v155 + 8);
            if ((v156 & 1) == 0) {
              goto LABEL_276;
            }
          }
        }

        icu::SimpleDateFormat::subFormat(v14, a2, 97LL, a4, a5, a6, 98LL, a8, a9, a10);
        return (uint64_t)icu::UnicodeString::~UnicodeString(v89, (icu::UnicodeString *)v173);
      case 0x24u:
        __int128 v60 = sub_1808C32FC((icu::Locale *)(v14 + 544), (int *)a10);
        char v61 = (_BYTE *)v60;
        if (!v60)
        {
          uint64_t v163 = a9;
          uint64_t v164 = a10;
          uint64_t v122 = v14;
          v123 = a2;
          uint64_t v124 = a4;
          int v125 = a5;
          goto LABEL_281;
        }

        int v62 = icu::Calendar::get(a9, 0xBu, a10);
        if (*(_BYTE *)(v14 + 792)) {
          __int128 v63 = icu::Calendar::get(a9, 0xCu, a10);
        }
        else {
          __int128 v63 = 0;
        }
        if (*(_BYTE *)(v14 + 793)) {
          __int32 v127 = icu::Calendar::get(a9, 0xDu, a10);
        }
        else {
          __int32 v127 = 0;
        }
        int v125 = a5;
        v128 = &v61[4 * v62];
        if (v62 || v63 || v127)
        {
          if (v62 == 12 && !v63 && !v127 && v61[1])
          {
            int v129 = 1;
LABEL_216:
            if ((int)a4 > 3)
            {
              unint64_t v157 = *(void *)(v14 + 768);
              int v131 = (int)v129;
              else {
                int v130 = *(void *)(v157 + 896);
              }
            }

            else
            {
              int v130 = *(void *)(*(void *)(v14 + 768) + 864LL);
              int v131 = (int)v129;
            }

            uint64_t v155 = v130 + (v131 << 6);
            if (v155)
            {
              if (v129 > 1)
              {
                int v125 = a5;
                goto LABEL_274;
              }

              int v125 = a5;
              if ((*(_WORD *)(v155 + 8) & 1) == 0)
              {
LABEL_274:
                if ((v129 & 0xFFFFFFFE) != 0xA)
                {
                  int v156 = *(unsigned __int16 *)(v155 + 8);
                  if ((v156 & 1) == 0)
                  {
LABEL_276:
                    int v160 = (__int16)v156;
                    __int32 v161 = v156 >> 5;
                    if (v160 >= 0) {
                      int64_t v162 = v161;
                    }
                    else {
                      int64_t v162 = *(unsigned int *)(v155 + 12);
                    }
                    icu::UnicodeString::doAppend(a2, (const icu::UnicodeString *)v155, 0, v162);
LABEL_165:
                    uint64_t v32 = 0;
LABEL_225:
                    int v121 = a7;
                    int v46 = v168;
                    if ((_DWORD)a6) {
                      goto LABEL_244;
                    }
                    goto LABEL_226;
                  }
                }

                uint64_t v163 = a9;
                uint64_t v164 = a10;
                uint64_t v122 = v14;
                v123 = a2;
                uint64_t v124 = a4;
LABEL_281:
                icu::SimpleDateFormat::subFormat(v122, v123, 97LL, v124, v125, a6, 66LL, a8, v163, v164);
                return (uint64_t)icu::UnicodeString::~UnicodeString(v89, (icu::UnicodeString *)v173);
              }

void *sub_180873194(const char *a1, const char *a2, UErrorCode *a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  int v35 = 0;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  *(_OWORD *)int v29 = 0u;
  __int128 v30 = 0u;
  int v20 = 0;
  if (a1)
  {
    if (*a1) {
      Default = a1;
    }
    else {
      Default = "root";
    }
  }

  else
  {
    Default = (const char *)uloc_getDefault(0LL);
  }

  uint64_t v28 = 0LL;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  v21[0] = Default;
  v21[1] = a2;
  int v7 = (char *)uhash_get(qword_18C4493B8, (uint64_t)v21);
  if (v7) {
    goto LABEL_10;
  }
  double result = uprv_malloc(0x78uLL);
  if (!result)
  {
    int v8 = 7;
LABEL_18:
    *a3 = v8;
    return result;
  }

  int v7 = (char *)result;
  *((void *)result + 14) = 0LL;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + sub_18086E18C((uint64_t)this, 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  *(_OWORD *)double result = 0u;
  int v9 = strlen(Default);
  if (v9 > 2)
  {
    uint64_t v10 = (char *)uprv_malloc(v9 + 1);
    *(void *)int v7 = v10;
    if (!v10)
    {
LABEL_23:
      *a3 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_27;
    }
  }

  else
  {
    uint64_t v10 = v7 + 104;
    *(void *)int v7 = v7 + 104;
  }

  strcpy(v10, Default);
  if (*(int *)a3 >= 1)
  {
LABEL_27:
    uprv_free(v7);
    return 0LL;
  }

  if (a2)
  {
    uint64_t v11 = (char *)uprv_strdup(a2);
    *((void *)v7 + sub_18086E18C((uint64_t)this, 1) = v11;
    if (!v11) {
      goto LABEL_23;
    }
  }

  else
  {
    uint64_t v11 = (char *)*((void *)v7 + 1);
  }

  sub_180873E24(v7 + 40, v11, *(const char **)v7, a3);
  if (*(int *)a3 >= 1)
  {
    if (*a3 == U_MEMORY_ALLOCATION_ERROR) {
      goto LABEL_27;
    }
    UErrorCode v13 = U_USING_FALLBACK_WARNING;
    goto LABEL_37;
  }

  if (v7[98])
  {
    uint64_t v12 = sub_180873A3C(*((void *)v7 + 1), (int *)a3);
    *((void *)v7 + 4) = v12;
    UErrorCode v13 = *a3;
    if (*(int *)a3 > 0)
    {
LABEL_38:
      *((_DWORD *)v7 + 28) = v13;
      goto LABEL_39;
    }

    uint64_t v14 = *(void *)(v12 + 48);
    if (*(_DWORD *)(*((void *)v7 + 6) + 32LL) != *(_DWORD *)(v14 + 32))
    {
      UErrorCode v13 = U_INVALID_FORMAT_ERROR;
LABEL_37:
      *a3 = v13;
      goto LABEL_38;
    }

    *((void *)v7 + 8) = v14 + 4 + 4LL * *(unsigned __int8 *)(v14 + 4);
    *((void *)v7 + 10) = *(void *)(v12 + 56);
  }

  unsigned int Resource = res_getResource((uint64_t)(v7 + 40), "%%ALIAS");
  if (Resource != -1)
  {
    StringNoTrace = res_getStringNoTrace((uint64_t)(v7 + 40), Resource, &v20);
    if (StringNoTrace)
    {
      if (v20 >= 1)
      {
        u_UCharsToChars(StringNoTrace, v29, v20 + 1);
        *((void *)v7 + 3) = sub_180873194(v29, a2, a3);
      }
    }
  }

uint64_t sub_180873494(uint64_t *a1, char *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  uint64_t v5 = *a1;
  if (!*(void *)(*a1 + 16))
  {
    while (!*(_BYTE *)(v5 + 96) && res_getResource(v5 + 40, "%%ParentIsRoot") == -1)
    {
      unsigned int Resource = res_getResource(*a1 + 40, "%%Parent");
      if (Resource != -1)
      {
        int v14 = 0;
        StringNoTrace = res_getStringNoTrace(*a1 + 40, Resource, &v14);
        if (StringNoTrace && v14 >= 1 && v14 <= 156)
        {
          u_UCharsToChars(StringNoTrace, a2, v14 + 1);
          if (!strcmp(a2, "root")) {
            break;
          }
        }
      }

      int v13 = 0;
      uint64_t v11 = sub_180873194(a2, *(const char **)(*a1 + 8), (UErrorCode *)&v13);
      if (v13 >= 1)
      {
        uint64_t result = 0LL;
        *a3 = v13;
        return result;
      }

      *(void *)(*a1 + 16) = v11;
      *a1 = (uint64_t)v11;
      uint64_t v12 = strrchr(a2, 95);
      if (v12)
      {
        *uint64_t v12 = 0;
      }

      else if (!*a2 || !strstr("nb nn", a2))
      {
        return 1LL;
      }

      uint64_t v5 = *a1;
      uint64_t result = 1LL;
      if (*(void *)(*a1 + 16)) {
        return result;
      }
    }
  }

  return 1LL;
}

uint64_t sub_18087361C(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  int v6 = 0;
  uint64_t v5 = sub_180873194("root", *(const char **)(*(void *)a1 + 8LL), (UErrorCode *)&v6);
  if (v6 < 1)
  {
    *(void *)(*(void *)a1 + 16LL) = v5;
    *(void *)a1 = v5;
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *a2 = v6;
  }

  return result;
}

uint64_t sub_18087369C(unsigned __int8 **a1)
{
  uint64_t v1 = a1[1];
  unsigned int v2 = uhash_hashChars(*a1);
  return v2 + 37 * uhash_hashChars(v1);
}

BOOL sub_1808736D4(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned int v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL result = uhash_compareChars(*a1, *a2);
  if (result) {
    return uhash_compareChars(v2, v3);
  }
  return result;
}

uint64_t sub_180873718()
{
  if (qword_18C4493B8)
  {
    int v5 = 0;
    umtx_lock((icu::UMutex *)&unk_18C449360);
    if (qword_18C4493B8)
    {
      do
      {
        int v5 = -1;
        uint64_t v0 = uhash_nextElement((uint64_t *)qword_18C4493B8, &v5);
        if (!v0) {
          break;
        }
        uint64_t v1 = v0;
        int v2 = 0;
        do
        {
          uint64_t v3 = *(void *)(v1 + 8);
          if (!*(_DWORD *)(v3 + 108))
          {
            uhash_removeElement(qword_18C4493B8, (_DWORD *)v1);
            sub_1808737E4((char *)v3);
            int v2 = 1;
          }

          uint64_t v1 = uhash_nextElement((uint64_t *)qword_18C4493B8, &v5);
        }

        while (v1);
      }

      while (v2);
    }

    umtx_unlock((std::mutex **)&unk_18C449360);
    uhash_close((_BYTE *)qword_18C4493B8);
    qword_18C4493B8 = 0LL;
  }

  atomic_store(0, &dword_18C4493B0);
  return 1LL;
}

void sub_1808737E4(char *a1)
{
  int v2 = *(char **)a1;
  if (*(void *)a1) {
    BOOL v3 = v2 == a1 + 104;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    uprv_free(v2);
  }
  uint64_t v4 = (void *)*((void *)a1 + 1);
  if (v4) {
    uprv_free(v4);
  }
  uint64_t v5 = *((void *)a1 + 4);
  if (v5) {
    --*(_DWORD *)(v5 + 108);
  }
  uint64_t v6 = *((void *)a1 + 3);
  if (v6)
  {
    do
    {
      uint64_t v7 = v6;
      uint64_t v6 = *(void *)(v6 + 24);
    }

    while (v6);
    --*(_DWORD *)(v7 + 108);
  }

  uprv_free(a1);
}

void sub_180873864(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char __s1[8] = *(char **)MEMORY[0x1895F89C0];
  UErrorCode v18 = U_ZERO_ERROR;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(void *)(a3 + 56) = 0LL;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v16, "Latn");
  uint64_t v6 = v16;
  int v7 = v17;
  *(void *)a3 = a3 + 13;
  *(_DWORD *)(a3 + 8) = 40;
  *(_WORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  icu::CharString::append((icu::CharString *)a3, v6, v7, &v18);
  if (!*(_DWORD *)(a2 + 56)) {
    goto LABEL_8;
  }
  memset(&__s1[1], 0, 56);
  __s1[0] = (char *)&__s1[1] + 5;
  LODWORD(__s1[1]) = 40;
  int v8 = icu::CharString::append((icu::CharString *)__s1, *(const char **)a1, *(_DWORD *)(a1 + 56), &v18);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v14, "_");
  int v9 = icu::CharString::append(v8, v14, v15, &v18);
  icu::CharString::append(v9, *(const char **)a2, *(_DWORD *)(a2 + 56), &v18);
  uint64_t v10 = 0LL;
  UErrorCode v11 = v18;
  if (v18 <= U_ZERO_ERROR) {
    uint64_t v10 = (const char *)sub_18086E040(__s1[0], (uint64_t)&unk_180A287CD, (uint64_t)"Aghb", dword_180A29A60, 2052);
  }
  if (BYTE4(__s1[1])) {
    uprv_free(__s1[0]);
  }
  if (v11 <= U_ZERO_ERROR)
  {
    if (v10)
    {
LABEL_9:
      *(_DWORD *)(a3 + 56) = 0;
      **(_BYTE **)a3 = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v12, v10);
      icu::CharString::append((icu::CharString *)a3, v12, v13, &v18);
      return;
    }

uint64_t sub_180873A3C(uint64_t a1, int *a2)
{
  uint64_t result = sub_180873194("pool", a1, a2);
  if (*a2 <= 0 && (!result || *(_DWORD *)(result + 112) || !*(_BYTE *)(result + 97))) {
    *a2 = 3;
  }
  return result;
}

void sub_180873A98(void *a1)
{
  int v2 = (void *)a1[1];
  sub_18086E18C((uint64_t)v2 + 136, 1);
  sub_18086E18C((uint64_t)v2, 1);
  uprv_free(v2);
  uprv_free(a1);
}

uint64_t sub_180873ADC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return *(unsigned int *)(v1 + 128);
  }
  else {
    return 0LL;
  }
}

const char *sub_180873AF4(uint64_t a1, _DWORD *a2, int *a3)
{
  Nextunsigned int Resource = *(char **)(a1 + 8);
  if (NextResource)
  {
    if (*((_DWORD *)NextResource + 31) >= *((_DWORD *)NextResource + 32) - 1)
    {
      uint64_t v5 = 0LL;
      LODWORD(NextResource) = 0;
      if (!a2) {
        return v5;
      }
      goto LABEL_7;
    }

    Nextunsigned int Resource = ures_getNextResource((uint64_t)NextResource, (uint64_t)(NextResource + 136), a3);
    if (NextResource)
    {
      uint64_t v5 = *(const char **)NextResource;
      LODWORD(NextResource) = strlen(*(const char **)NextResource);
      if (!a2) {
        return v5;
      }
      goto LABEL_7;
    }
  }

  uint64_t v5 = 0LL;
  if (a2) {
LABEL_7:
  }
    *a2 = (_DWORD)NextResource;
  return v5;
}

uint64_t sub_180873B68(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (v1) {
    *(_DWORD *)(v1 + 124) = -1;
  }
  return result;
}

void res_read(_OWORD *a1, unsigned __int16 *a2, unsigned int *a3, unsigned int a4, int *a5)
{
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  if (*a5 <= 0)
  {
    int v9 = 0;
    else {
      *a5 = 3;
    }
  }

BOOL sub_180873C04(_DWORD *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  *a1 = *((_DWORD *)a4 + 3);
  return *a4 >= 0x14u
      && !*((_BYTE *)a4 + 4)
      && !*((_BYTE *)a4 + 5)
      && *((_BYTE *)a4 + 6) == 2
      && *((_BYTE *)a4 + 8) == 82
      && *((_BYTE *)a4 + 9) == 101
      && *((_BYTE *)a4 + 10) == 115
      && *((_BYTE *)a4 + 11) == 66
      && *((unsigned __int8 *)a4 + 12) - 1 < 3;
}

void sub_180873C80(uint64_t a1, unsigned __int8 *a2, unsigned int *a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v6 = *a3;
  *(_DWORD *)(a1 + 32) = *a3;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = &unk_180A2BACA;
  if ((a4 & 0x80000000) == 0)
  {
    unsigned int v7 = 6;
    if (*a2 == 1)
    {
      if (a2[1]) {
        unsigned int v7 = 6;
      }
      else {
        unsigned int v7 = 1;
      }
    }

    if (a4 >> 2 < v7) {
      goto LABEL_34;
    }
  }

  if (v6 >> 28 != 2 && (v6 & 0xE0000000) != 0x40000000) {
    goto LABEL_34;
  }
  unsigned int v9 = *a2;
  if (v9 == 1 && !a2[1])
  {
    *(_DWORD *)(a1 + 36) = 0x10000;
    goto LABEL_29;
  }

  unsigned int v10 = *((unsigned __int8 *)a3 + 4);
  if (v10 > 4 && ((a4 & 0x80000000) != 0 || 4 * v10 + 4 <= a4 && (int)a4 >= (int)(4 * a3[4])))
  {
    signed int v11 = a3[2];
    if (v11 > (int)(v10 + 1))
    {
      *(_DWORD *)(a1 + 36) = 4 * v11;
      unsigned int v9 = *a2;
    }

    if (v9 >= 3) {
      *(_DWORD *)(a1 + 48) = a3[1] >> 8;
    }
    if (v10 < 6)
    {
      if (!*(_BYTE *)(a1 + 57) && !*(_BYTE *)(a1 + 58)) {
        goto LABEL_29;
      }
    }

    else
    {
      unsigned int v12 = a3[6];
      *(_BYTE *)(a1 + 56) = v12 & 1;
      *(_BYTE *)(a1 + 57) = (v12 & 2) != 0;
      *(_BYTE *)(a1 + 58) = (v12 & 4) != 0;
      *(_DWORD *)(a1 + 48) |= (v12 << 12) & 0xF000000;
      *(_DWORD *)(a1 + 52) = HIWORD(v12);
      if (((v12 >> 1) & 1) != 0)
      {
        if (v10 > 7) {
          goto LABEL_37;
        }
      }

      else if (v10 > 7 || ((v12 >> 2) & 1) == 0)
      {
        if (v10 >= 7)
        {
LABEL_37:
          uint64_t v14 = (int)a3[2];
        }

void sub_180873E24(_OWORD *a1, char *a2, const char *a3, UErrorCode *a4)
{
  int v8 = 0;
  *a1 = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  unsigned int v6 = udata_openChoice( a2,  "res",  a3,  (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_180873C04,  (uint64_t)&v8,  a4);
  *(void *)a1 = v6;
  if (*(int *)a4 <= 0)
  {
    Memory = (unsigned int *)udata_getMemory((uint64_t)v6);
    sub_180873C80((uint64_t)a1, (unsigned __int8 *)&v8, Memory, 0xFFFFFFFF, a4);
  }

void sub_180873EAC(_OWORD **a1)
{
  int v2 = *a1;
  if (v2)
  {
    udata_close(v2);
    *a1 = 0LL;
  }

uint64_t res_getPublicType(unsigned int a1)
{
  return byte_180A2BA8E[(unint64_t)a1 >> 28];
}

const UChar *res_getStringNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 6)
  {
    int v4 = *(_DWORD *)(a1 + 48);
    BOOL v5 = (int)(a2 & 0xFFFFFFF) < v4;
    uint64_t v6 = 16LL;
    if (v5) {
      uint64_t v6 = 40LL;
    }
    unsigned int v7 = (const UChar *)(*(void *)(a1 + v6) + 2LL * ((a2 & 0xFFFFFFF) - v4));
    unsigned int v8 = *v7;
    if ((v8 & 0xFC00) == 0xDC00)
    {
      if (v8 > 0xDFEE)
      {
        if (v8 > 0xDFFE)
        {
          int v9 = v7[2] | (v7[1] << 16);
          v7 += 3;
          if (!a3) {
            return v7;
          }
        }

        else
        {
          int v9 = (v7[1] | (v8 << 16)) + 537985024;
          v7 += 2;
          if (!a3) {
            return v7;
          }
        }
      }

      else
      {
        int v9 = v8 & 0x3FF;
        ++v7;
        if (!a3) {
          return v7;
        }
      }
    }

    else
    {
      int v9 = u_strlen(v7);
      if (!a3) {
        return v7;
      }
    }

    goto LABEL_22;
  }

  if (a2 >> 28)
  {
    unsigned int v7 = 0LL;
    int v9 = 0;
    if (!a3) {
      return v7;
    }
    goto LABEL_22;
  }

  if (a2) {
    unsigned int v10 = (int *)(*(void *)(a1 + 8) + 4LL * a2);
  }
  else {
    unsigned int v10 = &dword_180A2BAA0;
  }
  int v11 = *v10;
  unsigned int v7 = (const UChar *)(v10 + 1);
  int v9 = v11;
  if (a3) {
LABEL_22:
  }
    *a3 = v9;
  return v7;
}

int *res_getAlias(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 3)
  {
    if ((a2 & 0xFFFFFFF) != 0) {
      BOOL v3 = (int *)(*(void *)(a1 + 8) + 4LL * (a2 & 0xFFFFFFF));
    }
    else {
      BOOL v3 = &dword_180A2BAA0;
    }
    int v6 = *v3;
    uint64_t result = v3 + 1;
    int v5 = v6;
    if (a3) {
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t result = 0LL;
    int v5 = 0;
    if (a3) {
LABEL_8:
    }
      *a3 = v5;
  }

  return result;
}

int *res_getBinaryNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 1)
  {
    if ((a2 & 0xFFFFFFF) != 0) {
      BOOL v3 = (int *)(*(void *)(a1 + 8) + 4LL * (a2 & 0xFFFFFFF));
    }
    else {
      BOOL v3 = &dword_180A2BAA8;
    }
    int v6 = *v3;
    uint64_t result = v3 + 1;
    int v5 = v6;
    if (a3) {
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t result = 0LL;
    int v5 = 0;
    if (a3) {
LABEL_8:
    }
      *a3 = v5;
  }

  return result;
}

int *res_getIntVectorNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 14)
  {
    if ((a2 & 0xFFFFFFF) != 0) {
      BOOL v3 = (int *)(*(void *)(a1 + 8) + 4LL * (a2 & 0xFFFFFFF));
    }
    else {
      BOOL v3 = &dword_180A2BAA8;
    }
    int v6 = *v3;
    uint64_t result = v3 + 1;
    int v5 = v6;
    if (a3) {
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t result = 0LL;
    int v5 = 0;
    if (a3) {
LABEL_8:
    }
      *a3 = v5;
  }

  return result;
}

uint64_t res_countArrayItems(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = a2 & 0xFFFFFFF;
  uint64_t result = 1LL;
  switch(a2 >> 28)
  {
    case 0u:
    case 1u:
    case 3u:
    case 6u:
    case 7u:
    case 0xEu:
      return result;
    case 2u:
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t result = *(unsigned __int16 *)(*(void *)(a1 + 8) + 4LL * (a2 & 0xFFFFFFF));
      break;
    case 4u:
    case 8u:
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t result = *(unsigned int *)(*(void *)(a1 + 8) + 4LL * v3);
      break;
    case 5u:
    case 9u:
      uint64_t result = *(unsigned __int16 *)(*(void *)(a1 + 16) + 2LL * v3);
      break;
    default:
LABEL_7:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

void sub_180874144(icu::ResourceValue *a1)
{
}

uint64_t sub_180874158(uint64_t a1)
{
  return byte_180A2BA8E[(unint64_t)*(unsigned int *)(a1 + 24) >> 28];
}

const UChar *sub_180874170(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  uint64_t result = res_getStringNoTrace(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), a2);
  if (!result) {
    *a3 = 17;
  }
  return result;
}

int *sub_1808741C0(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 3)
  {
    uint64_t v5 = v4 & 0xFFFFFFF;
    if ((_DWORD)v5) {
      int v6 = (int *)(*(void *)(*(void *)(a1 + 8) + 8LL) + 4 * v5);
    }
    else {
      int v6 = &dword_180A2BAA0;
    }
    int v7 = *v6;
    uint64_t result = v6 + 1;
    *a2 = v7;
  }

  else
  {
    uint64_t result = 0LL;
    *a2 = 0;
    *a3 = 17;
  }

  return result;
}

uint64_t sub_180874224(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (v3 >> 28 != 7) {
    *a2 = 17;
  }
  return ((int)(16 * v3) >> 4);
}

uint64_t sub_180874258(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (v3 >> 28 != 7) {
    *a2 = 17;
  }
  return v3 & 0xFFFFFFF;
}

int *sub_18087428C(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 14)
  {
    uint64_t v5 = v4 & 0xFFFFFFF;
    if ((_DWORD)v5) {
      int v6 = (int *)(*(void *)(*(void *)(a1 + 8) + 8LL) + 4 * v5);
    }
    else {
      int v6 = &dword_180A2BAA8;
    }
    int v7 = *v6;
    uint64_t result = v6 + 1;
    *a2 = v7;
  }

  else
  {
    uint64_t result = 0LL;
    *a2 = 0;
    *a3 = 17;
  }

  return result;
}

int *sub_1808742F0(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 1)
  {
    uint64_t v5 = v4 & 0xFFFFFFF;
    if ((_DWORD)v5) {
      int v6 = (int *)(*(void *)(*(void *)(a1 + 8) + 8LL) + 4 * v5);
    }
    else {
      int v6 = &dword_180A2BAA8;
    }
    int v7 = *v6;
    uint64_t result = v6 + 1;
    *a2 = v7;
  }

  else
  {
    uint64_t result = 0LL;
    *a2 = 0;
    *a3 = 17;
  }

  return result;
}

uint64_t sub_180874354@<X0>(uint64_t result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2 >= 1) {
    goto LABEL_2;
  }
  unsigned int v3 = *(_DWORD *)(result + 24);
  uint64_t v4 = v3 & 0xFFFFFFF;
  unsigned int v5 = v3 >> 28;
  if (v5 == 9)
  {
    unsigned int v8 = 0LL;
    unsigned int v10 = (unsigned __int16 *)(*(void *)(*(void *)(result + 8) + 16LL) + 2LL * v4);
    int v11 = *v10;
    int v6 = v10 + 1;
    LODWORD(v4) = v11;
  }

  else
  {
    if (v5 != 8)
    {
      *a2 = 17;
LABEL_2:
      *(void *)a3 = 0LL;
      *(void *)(a3 + 8) = 0LL;
      *(_DWORD *)(a3 + 16) = 0;
      return result;
    }

    int v6 = 0LL;
    if ((_DWORD)v4)
    {
      int v7 = (int *)(*(void *)(*(void *)(result + 8) + 8LL) + 4 * v4);
      int v9 = *v7;
      unsigned int v8 = v7 + 1;
      LODWORD(v4) = v9;
    }

    else
    {
      unsigned int v8 = 0LL;
    }
  }

  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v8;
  *(_DWORD *)(a3 + 16) = v4;
  return result;
}

uint64_t sub_1808743D8@<X0>(uint64_t result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2 >= 1)
  {
    *(_DWORD *)(a3 + 32) = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    return result;
  }

  unsigned int v3 = *(_DWORD *)(result + 24);
  uint64_t v4 = v3 & 0xFFFFFFF;
  unsigned int v5 = v3 >> 28;
  if (v5 == 5)
  {
    int v6 = 0LL;
    uint64_t v11 = 0LL;
    unsigned int v12 = (unsigned __int16 *)(*(void *)(*(void *)(result + 8) + 16LL) + 2LL * v4);
    int v13 = *v12;
    int v9 = v12 + 1;
    LODWORD(v4) = v13;
    int v7 = &v9[v13];
    goto LABEL_13;
  }

  if (v5 == 4)
  {
    if ((_DWORD)v4)
    {
      int v9 = 0LL;
      int v7 = 0LL;
      uint64_t v14 = (int *)(*(void *)(*(void *)(result + 8) + 8LL) + 4LL * v4);
      uint64_t v15 = *v14;
      int v6 = v14 + 1;
      LODWORD(v4) = v15;
      uint64_t v11 = (uint64_t)&v6[v15];
      goto LABEL_13;
    }

BOOL sub_1808744C4(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  int v2 = v1 & 0xFFFFFFF;
  if ((v1 & 0xFFFFFFF) == 0) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (!(v1 >> 28))
  {
    uint64_t v4 = *(void *)(v3 + 8) + 4 * v1;
    if (*(_DWORD *)v4 == 3)
    {
      int v5 = 8709;
      if (*(_WORD *)(v4 + 4) == 8709 && *(_WORD *)(v4 + 6) == 8709)
      {
        int v6 = (unsigned __int16 *)(v4 + 8);
        return *v6 == v5;
      }
    }

    return 0LL;
  }

  int v7 = *(_DWORD *)(v3 + 48);
  BOOL v8 = v2 < v7;
  if (v2 < v7) {
    int v7 = 0;
  }
  uint64_t v9 = 16LL;
  if (v8) {
    uint64_t v9 = 40LL;
  }
  int v10 = (unsigned __int16 *)(*(void *)(v3 + v9) + 2LL * (v2 - v7));
  int v11 = *v10;
  if (v11 == 56323)
  {
    int v5 = 8709;
    if (v10[1] == 8709 && v10[2] == 8709) {
      goto LABEL_19;
    }
    return 0LL;
  }

  BOOL result = 0LL;
  if (v11 == 8709)
  {
    if (v10[1] == 8709 && v10[2] == 8709)
    {
      int v5 = 0;
LABEL_19:
      int v6 = v10 + 3;
      return *v6 == v5;
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_1808745B8(void *a1, icu::UnicodeString *a2, int a3, int *a4)
{
  uint64_t v7 = a1[1];
  (*(void (**)(void *__return_ptr, void *, int *))(*a1 + 80LL))(v9, a1, a4);
  return sub_180874618(v7, (uint64_t)v9, a2, a3, a4);
}

uint64_t sub_180874618(uint64_t a1, uint64_t a2, icu::UnicodeString *a3, int a4, int *a5)
{
  if (*a5 <= 0)
  {
    uint64_t v7 = a3;
    if (a3)
    {
      if ((a4 & 0x80000000) == 0)
      {
LABEL_5:
        uint64_t v5 = *(unsigned int *)(a2 + 16);
        if (!(_DWORD)v5) {
          return v5;
        }
        if ((int)v5 <= a4)
        {
          uint64_t v12 = 0LL;
          while (1)
          {
            int v20 = 0;
            if (*(void *)a2)
            {
              int v13 = *(unsigned __int16 *)(*(void *)a2 + 2 * v12);
              int v14 = *(_DWORD *)(a1 + 52);
              BOOL v15 = __OFSUB__(v13, v14);
              int v16 = v13 - v14;
              if (v16 < 0 == v15) {
                int v13 = v16 + *(_DWORD *)(a1 + 48);
              }
              unsigned int v17 = v13 | 0x60000000;
            }

            else
            {
              unsigned int v17 = *(_DWORD *)(*(void *)(a2 + 8) + 4 * v12);
            }

            StringNoTrace = res_getStringNoTrace(a1, v17, &v20);
            if (!StringNoTrace) {
              break;
            }
            UErrorCode v19 = StringNoTrace;
            icu::UnicodeString::setTo(v7, 1, &v19, v20);
            ++v12;
            uint64_t v7 = (icu::UnicodeString *)((char *)v7 + 64);
            if (v5 == v12) {
              return v5;
            }
          }

          uint64_t v5 = 0LL;
          int v10 = 17;
        }

        else
        {
          int v10 = 15;
        }

uint64_t sub_18087473C(uint64_t a1, icu::UnicodeString *a2, int a3, int *a4)
{
  unsigned int v7 = *(_DWORD *)(a1 + 24);
  if ((v7 & 0xFFFFFFFE) != 8)
  {
    if (*a4 > 0) {
      return 0LL;
    }
    if (a2)
    {
      if ((a3 & 0x80000000) == 0)
      {
        if (a3)
        {
          LODWORD(v14[0]) = 0;
          StringNoTrace = res_getStringNoTrace(*(void *)(a1 + 8), v7, (int *)v14);
          if (StringNoTrace)
          {
            int v13 = StringNoTrace;
            uint64_t v9 = 1LL;
            icu::UnicodeString::setTo(a2, 1, &v13, v14[0]);
            return v9;
          }

          uint64_t v9 = 0LL;
          int v11 = 17;
LABEL_12:
          *a4 = v11;
          return v9;
        }

icu::UnicodeString *sub_180874844@<X0>(icu::UnicodeString *result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  if (*a2 <= 0)
  {
    uint64_t v5 = result;
    int v18 = 0;
    StringNoTrace = res_getStringNoTrace(*((void *)result + 1), *((_DWORD *)result + 6), &v18);
    if (StringNoTrace)
    {
      unsigned int v17 = StringNoTrace;
      return icu::UnicodeString::setTo((icu::UnicodeString *)a3, 1, &v17, v18);
    }

    else
    {
      int v14 = 0LL;
      BOOL v15 = 0LL;
      uint64_t v16 = 0LL;
      BOOL result = (icu::UnicodeString *)(*(void *(**)(unsigned __int16 **__return_ptr, icu::UnicodeString *, int *))(*(void *)v5 + 80LL))( &v14,  v5,  a2);
      if (*a2 <= 0)
      {
        uint64_t v7 = *((void *)v5 + 1);
        if (v14)
        {
          int v8 = *v14;
          int v9 = *(_DWORD *)(v7 + 52);
          BOOL v10 = __OFSUB__(v8, v9);
          int v11 = v8 - v9;
          if (v11 < 0 == v10) {
            int v8 = v11 + *(_DWORD *)(v7 + 48);
          }
          unsigned int v12 = v8 | 0x60000000;
        }

        else
        {
          unsigned int v12 = *v15;
        }

        BOOL result = (icu::UnicodeString *)res_getStringNoTrace(v7, v12, &v18);
        if (result)
        {
          int v13 = (const UChar *)result;
          return icu::UnicodeString::setTo((icu::UnicodeString *)a3, 1, &v13, v18);
        }

        else
        {
LABEL_13:
          *a2 = 17;
        }
      }
    }
  }

  return result;
}

uint64_t icu::ResourceArray::internalGetResource(void *a1, uint64_t a2, int a3)
{
  if (!*a1) {
    return *(unsigned int *)(a1[1] + 4LL * a3);
  }
  int v3 = *(unsigned __int16 *)(*a1 + 2LL * a3);
  int v4 = *(_DWORD *)(a2 + 52);
  BOOL v5 = __OFSUB__(v3, v4);
  int v6 = v3 - v4;
  if (v6 < 0 == v5) {
    int v3 = v6 + *(_DWORD *)(a2 + 48);
  }
  return v3 | 0x60000000u;
}

uint64_t res_getTableItemByKey(uint64_t a1, unsigned int a2, unsigned int *a3, const char **a4)
{
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  BOOL v5 = (char *)*a4;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = a2 & 0xFFFFFFF;
  unsigned int v9 = a2 >> 28;
  if (a2 >> 28 != 5)
  {
    if (v9 == 4)
    {
      if (v8)
      {
        __int128 v25 = (int *)(*(void *)(a1 + 8) + 4LL * v8);
        int v28 = *v25;
        uint64_t v26 = (uint64_t)(v25 + 1);
        int v27 = v28;
        unsigned int v29 = sub_180874BB0(a1, v26, v28, v5, a4);
        *a3 = v29;
        if ((v29 & 0x80000000) == 0) {
          return *(unsigned int *)(v26 + 4LL * (int)(v29 + v27));
        }
      }
    }

    else if (v9 == 2)
    {
      if (v8)
      {
        BOOL v10 = (unsigned __int16 *)(*(void *)(a1 + 8) + 4LL * v8);
        int v13 = *v10;
        uint64_t v12 = (uint64_t)(v10 + 1);
        unsigned int v11 = v13;
        unsigned int v14 = sub_180874AEC(a1, v12, v13, v5, a4);
        *a3 = v14;
        if ((v14 & 0x80000000) == 0) {
          return *(unsigned int *)(v12 + 2LL * v11 + 2LL * ((v11 & 1) == 0) + 4LL * v14);
        }
      }
    }

    return 0xFFFFFFFFLL;
  }

  uint64_t v16 = (unsigned __int16 *)(*(void *)(a1 + 16) + 2LL * v8);
  int v19 = *v16;
  uint64_t v17 = (uint64_t)(v16 + 1);
  int v18 = v19;
  unsigned int v20 = sub_180874AEC(a1, v17, v19, v5, a4);
  *a3 = v20;
  if ((v20 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  int v21 = *(unsigned __int16 *)(v17 + 2LL * (v20 + v18));
  int v22 = *(_DWORD *)(a1 + 52);
  BOOL v23 = __OFSUB__(v21, v22);
  int v24 = v21 - v22;
  if (v24 < 0 == v23) {
    int v21 = v24 + *(_DWORD *)(a1 + 48);
  }
  return v21 | 0x60000000u;
}

uint64_t sub_180874AEC(uint64_t a1, uint64_t a2, int a3, char *__s1, void *a5)
{
  if (a3 >= 1)
  {
    int v7 = a3;
    int v10 = 0;
    uint64_t v11 = *(int *)(a1 + 36);
    do
    {
      int v12 = v7 + v10;
      if (v7 + v10 < 0 != __OFADD__(v7, v10)) {
        ++v12;
      }
      uint64_t v13 = (v12 >> 1);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 2LL * (int)v13);
      else {
        uint64_t v15 = *(void *)(a1 + 8);
      }
      uint64_t v16 = v15 + v14;
      int v17 = strcmp(__s1, (const char *)(v15 + v14));
      if (v17 < 0)
      {
        int v7 = v13;
      }

      else
      {
        if (!v17)
        {
          *a5 = v16;
          return v13;
        }

        int v10 = v13 + 1;
      }
    }

    while (v10 < v7);
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_180874BB0(uint64_t a1, uint64_t a2, int a3, char *__s1, const char **a5)
{
  if (a3 >= 1)
  {
    int v7 = a3;
    int v10 = 0;
    do
    {
      int v11 = v7 + v10;
      if (v7 + v10 < 0 != __OFADD__(v7, v10)) {
        ++v11;
      }
      uint64_t v12 = (v11 >> 1);
      int v13 = *(_DWORD *)(a2 + 4LL * (int)v12);
      uint64_t v14 = v13 & 0x7FFFFFFF;
      if (v13 >= 0) {
        uint64_t v15 = 8LL;
      }
      else {
        uint64_t v15 = 24LL;
      }
      uint64_t v16 = (const char *)(*(void *)(a1 + v15) + v14);
      int v17 = strcmp(__s1, v16);
      if (v17 < 0)
      {
        int v7 = v12;
      }

      else
      {
        if (!v17)
        {
          *a5 = v16;
          return v12;
        }

        int v10 = v12 + 1;
      }
    }

    while (v10 < v7);
  }

  return 0xFFFFFFFFLL;
}

uint64_t res_getTableItemByIndex(uint64_t a1, unsigned int a2, unsigned int a3, void *a4)
{
  if ((a3 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = a2 & 0xFFFFFFF;
  unsigned int v5 = a2 >> 28;
  if (a2 >> 28 == 5)
  {
    uint64_t v15 = (unsigned __int16 *)(*(void *)(a1 + 16) + 2LL * v4);
    unsigned int v18 = *v15;
    uint64_t v16 = v15 + 1;
    unsigned int v17 = v18;
    if (v18 <= a3) {
      return 0xFFFFFFFFLL;
    }
    if (a4)
    {
      uint64_t v19 = v16[a3];
      uint64_t v20 = *(int *)(a1 + 36);
      else {
        uint64_t v21 = *(void *)(a1 + 8) + v19;
      }
      *a4 = v21;
    }

    int v29 = v16[v17 + a3];
    int v30 = *(_DWORD *)(a1 + 52);
    BOOL v31 = __OFSUB__(v29, v30);
    int v32 = v29 - v30;
    if (v32 < 0 == v31) {
      int v29 = v32 + *(_DWORD *)(a1 + 48);
    }
    return v29 | 0x60000000u;
  }

  else
  {
    if (v5 != 4)
    {
      if (v5 == 2)
      {
        if (v4)
        {
          uint64_t v6 = *(void *)(a1 + 8);
          int v7 = (unsigned __int16 *)(v6 + 4LL * v4);
          unsigned int v10 = *v7;
          unsigned int v9 = v7 + 1;
          unsigned int v8 = v10;
          if (v10 > a3)
          {
            uint64_t v11 = (uint64_t)&v9[v8 + ((v8 & 1) == 0)];
            if (a4)
            {
              uint64_t v12 = v9[a3];
              uint64_t v13 = *(int *)(a1 + 36);
              else {
                uint64_t v14 = v6 + v12;
              }
              *a4 = v14;
            }

            return *(unsigned int *)(v11 + 4LL * a3);
          }
        }
      }

      return 0xFFFFFFFFLL;
    }

    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v22 = *(void *)(a1 + 8);
    BOOL v23 = (int *)(v22 + 4LL * v4);
    int v26 = *v23;
    int v24 = v23 + 1;
    int v25 = v26;
    if (a4)
    {
      unsigned int v27 = v24[a3];
      if ((v27 & 0x80000000) != 0)
      {
        uint64_t v22 = *(void *)(a1 + 24);
        v27 &= ~0x80000000;
      }

      *a4 = v22 + v27;
    }

    return v24[v25 + a3];
  }

uint64_t res_getResource(uint64_t a1, const char *a2)
{
  unsigned int v4 = a2;
  return res_getTableItemByKey(a1, *(_DWORD *)(a1 + 32), &v3, &v4);
}

uint64_t icu::ResourceTable::getKeyAndValue( icu::ResourceTable *this, unsigned int a2, const char **a3, icu::ResourceValue *a4)
{
  if (!*(void *)this)
  {
    uint64_t v4 = *(unsigned int *)(*((void *)this + 1) + 4LL * a2);
    uint64_t v5 = *((void *)a4 + 1);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v9 = *(void *)(v5 + 24);
      v4 &= 0x7FFFFFFFu;
      goto LABEL_10;
    }

uint64_t icu::ResourceTable::findValue(icu::ResourceTable *this, char *__s1, icu::ResourceValue *a3)
{
  uint64_t v5 = *((void *)a3 + 1);
  if (!*(void *)this)
  {
    unsigned int v6 = sub_180874BB0(v5, *((void *)this + 1), *((_DWORD *)this + 8), __s1, &v14);
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_3;
    }
    return 0LL;
  }

  unsigned int v6 = sub_180874AEC(v5, *(void *)this, *((_DWORD *)this + 8), __s1, &v14);
  if ((v6 & 0x80000000) != 0) {
    return 0LL;
  }
LABEL_3:
  uint64_t v7 = *((void *)this + 2);
  if (v7)
  {
    int v8 = *(unsigned __int16 *)(v7 + 2LL * v6);
    int v9 = *(_DWORD *)(v5 + 52);
    BOOL v10 = __OFSUB__(v8, v9);
    int v11 = v8 - v9;
    if (v11 < 0 == v10) {
      int v8 = v11 + *(_DWORD *)(v5 + 48);
    }
    int v12 = v8 | 0x60000000;
  }

  else
  {
    int v12 = *(_DWORD *)(*((void *)this + 3) + 4LL * v6);
  }

  *((_DWORD *)a3 + 6) = v12;
  return 1LL;
}

uint64_t res_getArrayItem(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = a2 & 0xFFFFFFF;
  if (a2 >> 28 != 9)
  {
    if (a2 >> 28 == 8)
    {
      if (v3)
      {
        uint64_t v4 = (_DWORD *)(*(void *)(a1 + 8) + 4LL * v3);
      }
    }

    return 0xFFFFFFFFLL;
  }

  unsigned int v6 = (unsigned __int16 *)(*(void *)(a1 + 16) + 2LL * v3);
  if (*v6 <= a3) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v6[a3 + 1];
  int v8 = *(_DWORD *)(a1 + 52);
  BOOL v9 = __OFSUB__(v7, v8);
  int v10 = v7 - v8;
  if (v10 < 0 == v9) {
    int v7 = v10 + *(_DWORD *)(a1 + 48);
  }
  return v7 | 0x60000000u;
}

uint64_t icu::ResourceArray::getValue(icu::ResourceArray *this, unsigned int a2, icu::ResourceValue *a3)
{
  if (*(void *)this)
  {
    uint64_t v3 = *((void *)a3 + 1);
    int v4 = *(unsigned __int16 *)(*(void *)this + 2LL * a2);
    int v5 = *(_DWORD *)(v3 + 52);
    BOOL v6 = __OFSUB__(v4, v5);
    int v7 = v4 - v5;
    if (v7 < 0 == v6) {
      int v4 = v7 + *(_DWORD *)(v3 + 48);
    }
    int v8 = v4 | 0x60000000;
  }

  else
  {
    int v8 = *(_DWORD *)(*((void *)this + 1) + 4LL * a2);
  }

  *((_DWORD *)a3 + 6) = v8;
  return 1LL;
}

uint64_t sub_180875000(uint64_t a1, uint64_t a2, const char **a3, const char **a4)
{
  uint64_t TableItemByKey = a2;
  int v5 = *a3;
  __endptr = 0LL;
  if (*v5)
  {
    unsigned int v9 = a2 >> 28;
    if (a2 >> 28 == 2 || (a2 & 0xE0000000) == 0x40000000 || (a2 & 0xE0000000) == 0x80000000)
    {
      do
      {
        if (*v5) {
          BOOL v10 = (_DWORD)TableItemByKey == -1;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10) {
          break;
        }
        int v11 = v9 & 0xE;
        BOOL v12 = v11 == 4 || v9 == 2;
        if (v9 != 2 && v11 != 8 && v11 != 4) {
          break;
        }
        int v13 = strchr(v5, 47);
        BOOL v14 = v13;
        if (v13)
        {
          if (v13 == v5) {
            return 0xFFFFFFFFLL;
          }
          *int v13 = 0;
          int v15 = v13 + 1;
        }

        else
        {
          int v15 = &v5[strlen(v5)];
        }

        *a3 = v15;
        if (v12)
        {
          *a4 = v5;
          uint64_t TableItemByKey = res_getTableItemByKey(a1, TableItemByKey, &v18, a4);
        }

        else if (v11 == 8)
        {
          unsigned int v16 = strtol(v5, &__endptr, 10);
          if ((v16 & 0x80000000) != 0 || *__endptr) {
            uint64_t TableItemByKey = 0xFFFFFFFFLL;
          }
          else {
            uint64_t TableItemByKey = res_getArrayItem(a1, TableItemByKey, v16);
          }
          *a4 = 0LL;
        }

        else
        {
          uint64_t TableItemByKey = 0xFFFFFFFFLL;
        }

        unsigned int v9 = TableItemByKey >> 28;
        int v5 = *a3;
      }

      while (v14);
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return TableItemByKey;
}

uint64_t ures_swap( uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3;
  uint64_t v92 = *MEMORY[0x1895F89C0];
  int v13 = udata_swapDataHeader(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0LL;
  }
  uint64_t v21 = *((unsigned __int8 *)a2 + 12);
  if (__PAIR64__(*((unsigned __int8 *)a2 + 13), v21) != 0x6500000052LL
    || *((_BYTE *)a2 + 14) != 115
    || *((_BYTE *)a2 + 15) != 66)
  {
    goto LABEL_13;
  }

  int v22 = v13;
  unsigned int v23 = *((unsigned __int8 *)a2 + 16);
  if (v23 == 1)
  {
    if (*((_BYTE *)a2 + 17)) {
      goto LABEL_9;
    }
LABEL_13:
    udata_printError( a1,  (uint64_t)"ures_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not a resource bundle\n",  v14,  v15,  v16,  v17,  v18,  v19,  v21);
    uint64_t result = 0LL;
    int v24 = 16;
LABEL_14:
    *a5 = v24;
    return result;
  }

  if ((v23 & 0xFE) != 2) {
    goto LABEL_13;
  }
LABEL_9:
  uint64_t v88 = 0LL;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  BYTE4(v88) = v23;
  if (v10 < 0)
  {
    signed int v25 = -1;
  }

  else
  {
    if (v10 - v13 <= 23)
    {
      udata_printError( a1,  (uint64_t)"ures_swap(): too few bytes (%d after header) for a resource bundle\n",  v14,  v15,  v16,  v17,  v18,  v19,  (v10 - v13));
LABEL_25:
      uint64_t result = 0LL;
      int v24 = 8;
      goto LABEL_14;
    }

    signed int v25 = (v10 - v13) >> 2;
  }

  int v26 = (unsigned int *)((char *)a2 + v13);
  uint64_t v85 = (*(uint64_t (**)(void))(a1 + 16))(*v26);
  unsigned int Int32 = udata_readInt32(a1, v26[1]);
  if (Int32 <= 4)
  {
    __int128 v34 = "ures_swap(): too few indexes for a 1.1+ resource bundle\n";
LABEL_24:
    udata_printError(a1, (uint64_t)v34, v27, v28, v29, v30, v31, v32, v78);
    goto LABEL_25;
  }

  signed int v35 = udata_readInt32(a1, v26[2]);
  signed int v84 = v35;
  if (Int32 >= 7) {
    signed int v35 = udata_readInt32(a1, v26[7]);
  }
  int v82 = v35;
  uint64_t v36 = udata_readInt32(a1, v26[4]);
  __src = (unsigned int *)((char *)a2 + v22);
  uint64_t v37 = udata_readInt32(a1, __src[5]);
  if ((v25 & 0x80000000) == 0 && v25 < (int)v36)
  {
    uint64_t v78 = v36;
    __int128 v34 = "ures_swap(): resource top %d exceeds bundle length %d\n";
    goto LABEL_24;
  }

  unsigned int v38 = Int32 + 1;
  int v39 = 4 * v84;
  LODWORD(v88) = v39;
  if ((v10 & 0x80000000) == 0)
  {
    unsigned int v81 = v84 - v38;
    uint64_t v80 = v37;
    bzero(v89, 0x320uLL);
    unsigned int v40 = ((v10 + 31) >> 5) + 3;
    size_t v41 = v40 & 0xFFFFFFC;
    if (v41 > 0x320)
    {
      __int128 v42 = uprv_malloc(v40 & 0xFFFFFFC);
      *((void *)&v87 + sub_18086E18C((uint64_t)this, 1) = v42;
      if (!v42)
      {
        udata_printError( a1,  (uint64_t)"ures_swap(): unable to allocate memory for tracking resources\n",  v43,  v44,  v45,  v46,  v47,  v48,  v78);
        *a5 = 7;
        return 0LL;
      }
    }

    else
    {
      *((void *)&v87 + sub_18086E18C((uint64_t)this, 1) = v89;
      __int128 v42 = v89;
    }

    uint64_t v79 = v42;
    bzero(v42, v41);
    BOOL v49 = a2 == a4;
    UErrorCode v50 = (char *)a4 + v22;
    if (!v49) {
      memcpy(v50, __src, 4 * (int)v36);
    }
    bzero(v91, 0x640uLL);
    bzero(v90, 0x320uLL);
    udata_swapInvStringBlock(a1, (uint64_t)&__src[v38], 4 * v81, (uint64_t)&v50[4 * v38], a5);
    if (*a5 >= 1)
    {
      udata_printError( a1,  (uint64_t)"ures_swap().udata_swapInvStringBlock(keys[%d]) failed\n",  v51,  v52,  v53,  v54,  v55,  v56,  4 * v81);
      return 0LL;
    }

    int v57 = v82 - v84;
    if (v82 > v84)
    {
      (*(void (**)(uint64_t, unsigned int *, void, char *, int *))(a1 + 48))( a1,  &__src[v84],  (4 * v57),  &v50[4 * v84],  a5);
      if (*a5 >= 1)
      {
        udata_printError( a1,  (uint64_t)"ures_swap().swapArray16(16-bit units[%d]) failed\n",  v58,  v59,  v60,  v61,  v62,  v63,  (2 * v57));
        return 0LL;
      }
    }

    *(void *)&__int128 v86 = v50;
    if (v23 > 1 || (int)v80 <= 200)
    {
      *((void *)&v86 + sub_18086E18C((uint64_t)this, 1) = v91;
      uint64_t v71 = v90;
    }

    else
    {
      __int128 v64 = (char *)uprv_malloc(8LL * v80 + 4 * (int)v80);
      *((void *)&v86 + sub_18086E18C((uint64_t)this, 1) = v64;
      if (!v64)
      {
        udata_printError( a1,  (uint64_t)"ures_swap(): unable to allocate memory for sorting tables (max length: %d)\n",  v65,  v66,  v67,  v68,  v69,  v70,  v80);
        *a5 = 7;
        if (v79 != v89) {
          uprv_free(v79);
        }
        return 0LL;
      }

      uint64_t v71 = &v64[8 * v80];
    }

    *(void *)&__int128 v87 = v71;
    sub_18087561C(a1, (uint64_t)__src, (uint64_t)v50, v85, 0LL, (uint64_t)&v86, a5);
    if (*a5 >= 1) {
      udata_printError(a1, (uint64_t)"ures_swapResource(root res=%08x) failed\n", v72, v73, v74, v75, v76, v77, v85);
    }
    if (*((_BYTE **)&v86 + 1) != v91) {
      uprv_free(*((void **)&v86 + 1));
    }
    if (*((_BYTE **)&v87 + 1) != v89) {
      uprv_free(*((void **)&v87 + 1));
    }
    (*(void (**)(uint64_t, unsigned int *, void, char *, int *))(a1 + 56))(a1, __src, 4 * v38, v50, a5);
  }

  return (v22 + 4 * v36);
}

uint64_t sub_18087561C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, int *a7)
{
  BOOL v7 = a4 >> 28 > 9 || ((1 << (a4 >> 28)) & 0x2E0) == 0;
  unsigned int v8 = a4 & 0xFFFFFFF;
  if (v7 && v8 != 0)
  {
    uint64_t v12 = *(void *)(a6 + 24);
    uint64_t v13 = v8 >> 5;
    int v14 = *(_DWORD *)(v12 + 4LL * v13);
    if ((v14 & (1 << a4)) == 0)
    {
      *(_DWORD *)(v12 + 4 * v13) = v14 | (1 << a4);
      uint64_t v18 = result;
      uint64_t v19 = (unsigned int *)(a2 + 4LL * v8);
      uint64_t v20 = (unsigned int *)(a3 + 4LL * v8);
      switch(a4 >> 28)
      {
        case 0u:
        case 3u:
          int Int32 = udata_readInt32(result, *v19);
          (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))( v18,  v19,  4LL,  v20,  a7);
          int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 48);
          uint64_t v23 = (2 * Int32);
          int v24 = v20 + 1;
          uint64_t v25 = v18;
          int v26 = v19 + 1;
          return v22(v25, v26, v23, v24, a7);
        case 1u:
          uint64_t v28 = udata_readInt32(result, *v19);
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))( v18,  v19,  4LL,  v20,  a7);
          if (a5)
          {
            if (a5 == "") {
              uint64_t result = ucol_looksLikeCollationBinary( (unsigned __int8 *)v18,  (unsigned __int16 *)v19 + 2,  v28,  v29,  v30,  v31,  v32,  v33);
            }
            else {
              uint64_t result = (*(unsigned int (**)(uint64_t, char *, uint64_t, const __int16 *, uint64_t))(v18 + 24))( v18,  a5,  0xFFFFFFFFLL,  L"%%CollationBin",  14LL) == 0;
            }
            if ((_DWORD)result) {
              return ucol_swap( (unsigned __int8 *)v18,  (uint64_t)(v19 + 1),  v28,  (unsigned __int16 *)v20 + 2,  a7,  v34,  v35,  v36);
            }
          }

          return result;
        case 2u:
          __srcb = (char *)(a3 + 4LL * v8);
          uint64_t v37 = (*(uint64_t (**)(void))(result + 8))(*(unsigned __int16 *)v19);
          size_t v93 = __srcb + 2;
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v18 + 48))(v18, v19, 2LL);
          unsigned int v38 = (char *)v19 + 2;
          int v39 = 0LL;
          __dst = 0LL;
          unsigned int v40 = (v37 + 2) >> 1;
          goto LABEL_18;
        case 4u:
          __srcc = (char *)(a3 + 4LL * v8);
          int v39 = v19 + 1;
          uint64_t v37 = udata_readInt32(result, *v19);
          __dst = (unsigned int *)(__srcc + 4);
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v18 + 56))(v18, v19, 4LL);
          unsigned int v38 = 0LL;
          size_t v93 = 0LL;
          unsigned int v40 = v37 + 1;
LABEL_18:
          if (!(_DWORD)v37) {
            return result;
          }
          uint64_t v94 = v37;
          uint64_t v95 = v39;
          unsigned int v91 = v40 + v8;
          size_t v41 = (unsigned int *)(a2 + 4LL * (int)(v40 + v8));
          __src = v38;
          uint64_t v42 = 0LL;
          do
          {
            if (v38)
            {
              signed int v43 = (*(uint64_t (**)(void))(v18 + 8))(*(unsigned __int16 *)&v38[2 * v42]);
              BOOL v44 = *(_DWORD *)(a6 + 32) > v43;
            }

            else
            {
              signed int v43 = udata_readInt32(v18, v95[v42]);
              BOOL v44 = v43 >= 0;
            }

            if (v44) {
              uint64_t v45 = (const char *)(a3 + v43);
            }
            else {
              uint64_t v45 = "";
            }
            uint64_t v46 = v41;
            uint64_t v47 = (*(uint64_t (**)(void))(v18 + 16))(v41[v42]);
            sub_18087561C(v18, a2, a3, v47, v45, a6, a7);
            if (*a7 >= 1) {
              return udata_printError( v18,  (uint64_t)"ures_swapResource(table res=%08x)[%d].recurse(%08x) failed\n",  v48,  v49,  v50,  v51,  v52,  v53,  a4);
            }
            ++v42;
            unsigned int v38 = __src;
            size_t v41 = v46;
          }

          while (v94 != v42);
LABEL_29:
          if (*(unsigned __int8 *)(a6 + 36) > 1u || *(unsigned __int8 *)(v18 + 1) == *(unsigned __int8 *)(v18 + 3))
          {
            if (v38)
            {
              (*(void (**)(uint64_t, char *, void, char *, int *))(v18 + 48))( v18,  v38,  (2 * v94),  v93,  a7);
              int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
              uint64_t v23 = (4 * v94);
              uint64_t v25 = v18;
              int v26 = v41;
              int v24 = (unsigned int *)(a3 + 4LL * (int)v91);
            }

            else
            {
              int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
              uint64_t v23 = (8 * v94);
              uint64_t v25 = v18;
              int v26 = v95;
              int v24 = __dst;
            }

            return v22(v25, v26, v23, v24, a7);
          }

          uint64_t v97 = (char *)(a3 + 4LL * (int)v91);
          uint64_t v65 = v41;
          if (v38)
          {
            if ((int)v94 >= 1)
            {
              uint64_t v66 = 0LL;
              int v67 = 0;
              do
              {
                int v68 = (*(uint64_t (**)(void))(v18 + 8))(*(unsigned __int16 *)&__src[v66]);
                uint64_t v69 = (_DWORD *)(*(void *)(a6 + 8) + 4 * v66);
                *uint64_t v69 = v68;
                v69[1] = v67++;
                v66 += 2LL;
              }

              while (2LL * v94 != v66);
            }
          }

          else if ((int)v94 >= 1)
          {
            uint64_t v70 = 0LL;
            uint64_t v71 = 4LL;
            do
            {
              int v72 = udata_readInt32(v18, v95[v70]);
              uint64_t v73 = (_DWORD *)(*(void *)(a6 + 8) + v71);
              *(v73 - sub_18086E18C((uint64_t)this, 1) = v72;
              _DWORD *v73 = v70++;
              v71 += 8LL;
            }

            while (v94 != v70);
          }

          uprv_sortArray( *(void *)(a6 + 8),  v94,  8,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_180875D8C,  *(void *)a6,  0,  a7);
          if (*a7 >= 1) {
            return udata_printError( v18,  (uint64_t)"ures_swapResource(table res=%08x).uprv_sortArray(%d items) failed\n",  v74,  v75,  v76,  v77,  v78,  v79,  a4);
          }
          if (__src)
          {
            uint64_t v80 = v93;
            if (__src == v93) {
              uint64_t v80 = *(char **)(a6 + 16);
            }
            if ((int)v94 >= 1)
            {
              uint64_t v81 = 0LL;
              do
              {
                (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(v18 + 48))( v18,  &__src[2 * *(int *)(*(void *)(a6 + 8) + 4 * v81 + 4)],  2LL,  &v80[v81],  a7);
                v81 += 2LL;
              }

              while (2LL * v94 != v81);
            }

            int v82 = v94;
            if (v93 != v80)
            {
              size_t v83 = 2 * (int)v94;
              signed int v84 = v93;
              uint64_t v85 = v80;
LABEL_72:
              memcpy(v84, v85, v83);
            }
          }

          else
          {
            __srca = __dst;
            if (v95 == __dst) {
              __srca = *(unsigned int **)(a6 + 16);
            }
            if ((int)v94 >= 1)
            {
              uint64_t v86 = 0LL;
              __int128 v87 = (char *)__srca;
              do
              {
                (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(v18 + 56))( v18,  &v95[*(int *)(*(void *)(a6 + 8) + v86 + 4)],  4LL,  v87,  a7);
                v87 += 4;
                v86 += 8LL;
              }

              while (8LL * v94 != v86);
            }

            signed int v84 = (char *)__dst;
            uint64_t v85 = __srca;
            int v82 = v94;
            if (__dst != __srca)
            {
              size_t v83 = 4 * (int)v94;
              goto LABEL_72;
            }
          }

          uint64_t v88 = (char *)(a3 + 4LL * (int)v91);
          if (a2 == a3) {
            uint64_t v88 = *(char **)(a6 + 16);
          }
          if (v82 >= 1)
          {
            uint64_t v89 = 0LL;
            __int128 v90 = v88;
            do
            {
              (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(v18 + 56))( v18,  &v65[*(int *)(*(void *)(a6 + 8) + v89 + 4)],  4LL,  v90,  a7);
              v90 += 4;
              v89 += 8LL;
            }

            while (8LL * v82 != v89);
          }

          uint64_t result = (uint64_t)v97;
          if (v97 != v88) {
            uint64_t result = (uint64_t)memcpy(v97, v88, 4 * v82);
          }
          break;
        case 8u:
          uint64_t v54 = v19 + 1;
          int v55 = udata_readInt32(result, *v19);
          (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))( v18,  v19,  4LL,  v20,  a7);
          int v96 = v55;
          if (v55 < 1) {
            goto LABEL_38;
          }
          uint64_t v56 = 0LL;
          do
          {
            uint64_t v57 = (*(uint64_t (**)(void))(v18 + 16))(v54[v56]);
            sub_18087561C(v18, a2, a3, v57, 0LL, a6, a7);
            if (*a7 >= 1) {
              return udata_printError( v18,  (uint64_t)"ures_swapResource(array res=%08x)[%d].recurse(%08x) failed\n",  v58,  v59,  v60,  v61,  v62,  v63,  a4);
            }
            ++v56;
          }

          while (v96 != v56);
LABEL_38:
          int v24 = v20 + 1;
          int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
          uint64_t v23 = (4 * v96);
          uint64_t v25 = v18;
          int v26 = v54;
          return v22(v25, v26, v23, v24, a7);
        case 0xEu:
          int v64 = udata_readInt32(result, *v19);
          int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
          uint64_t v23 = (4 * v64 + 4);
          uint64_t v25 = v18;
          int v26 = v19;
          int v24 = v20;
          return v22(v25, v26, v23, v24, a7);
        default:
          *a7 = 16;
          return result;
      }
    }
  }

  return result;
}

uint64_t sub_180875D8C(uint64_t a1, int *a2, int *a3)
{
  return strcmp((const char *)(a1 + *a2), (const char *)(a1 + *a3));
}

void *uscript_openRun(uint64_t a1, int a2, int *a3)
{
  if (!a3) {
    return 0LL;
  }
  if (*a3 <= 0)
  {
    uint64_t result = uprv_malloc(0x128uLL);
    if (!result)
    {
      *a3 = 7;
      return result;
    }

    if (*a3 <= 0)
    {
      if ((a2 & 0x80000000) == 0 && (a1 != 0) != (a2 == 0))
      {
        result[1] = a1;
        *(_DWORD *)uint64_t result = a2;
        result[2] = 0LL;
        *((_DWORD *)result + 6) = -1;
        *((_DWORD *)result + 7sub_18086E18C((uint64_t)this, 1) = -1;
        result[36] = 0LL;
        return result;
      }

      *a3 = 1;
    }

    uprv_free(result);
  }

  return 0LL;
}

uint64_t uscript_setRunText(uint64_t result, uint64_t a2, int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if (result && (a3 & 0x80000000) == 0 && (a2 != 0) != (a3 == 0))
    {
      *(void *)(result + 8) = a2;
      *(_DWORD *)uint64_t result = a3;
      *(void *)(result + 16) = 0LL;
      *(_DWORD *)(result + 24) = -1;
      *(_DWORD *)(result + 284) = -1;
      *(void *)(result + 288) = 0LL;
    }

    else
    {
      *a4 = 1;
    }
  }

  return result;
}

void uscript_closeRun(void *a1)
{
  if (a1) {
    uprv_free(a1);
  }
}

double uscript_resetRun(uint64_t a1)
{
  if (a1)
  {
    double result = 0.0;
    *(void *)(a1 + 16) = 0LL;
    *(_DWORD *)(a1 + 24) = -1;
    *(_DWORD *)(a1 + 284) = -1;
    *(void *)(a1 + 288) = 0LL;
  }

  return result;
}

uint64_t uscript_nextRun(uint64_t result, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v58 = 0;
  if (result)
  {
    uint64_t v4 = result;
    int v5 = *(_DWORD *)(result + 20);
    int v6 = *(_DWORD *)result;
    if (v5 >= *(_DWORD *)result)
    {
      return 0LL;
    }

    else
    {
      *(_DWORD *)(result + 292) = 0;
      *(_DWORD *)(result + 24) = 0;
      *(_DWORD *)(result + 16) = v5;
      while (1)
      {
        uint64_t v10 = *(void *)(v4 + 8);
        signed int v11 = *(unsigned __int16 *)(v10 + 2LL * v5);
        int v12 = v6 - 1;
        BOOL v13 = (v11 & 0xFC00) == 0xD800 && v5 < v12;
        if (v13)
        {
          uint64_t v14 = v5 + 1LL;
          int v15 = *(unsigned __int16 *)(v10 + 2 * v14);
          if ((v15 & 0xFC00) == 0xDC00)
          {
            signed int v11 = v15 + (v11 << 10) - 56613888;
            *(_DWORD *)(v4 + 20) = v14;
          }
        }

        int Script = uscript_getScript(v11, &v58);
        int v17 = 2 * (v11 > 59);
        unsigned int v18 = 32;
        do
        {
          if (*(_DWORD *)&asc_180A2BAEC[2 * (v17 + (v18 >> 1))] <= v11) {
            v17 += v18 >> 1;
          }
          BOOL v13 = v18 > 3;
          v18 >>= 1;
        }

        while (v13);
        if (*(_DWORD *)&asc_180A2BAEC[2 * v17] != v11) {
          int v17 = -1;
        }
        if ((v17 & 0x80000000) == 0)
        {
          int v19 = *(_DWORD *)(v4 + 288);
          if ((v17 & 1) != 0)
          {
            if (v19 >= 1)
            {
              int v29 = *(_DWORD *)(v4 + 284);
              while (1)
              {
                int v30 = v29;
                if (*(_DWORD *)(v4 + 8LL * v29 + 28) == (v17 & 0xFFFFFFFE)) {
                  break;
                }
                int v31 = *(_DWORD *)(v4 + 292);
                BOOL v32 = __OFSUB__(v31, 1);
                int v33 = v31 - 1;
                if (v33 < 0 == v32) {
                  *(_DWORD *)(v4 + 292) = v33;
                }
                *(_DWORD *)(v4 + 288) = v19 - 1;
                int v34 = v30 + 31;
                BOOL v25 = -v34 < 0;
                int v35 = -v34 & 0x1F;
                int v36 = v34 & 0x1F;
                if (!v25) {
                  int v36 = -v35;
                }
                BOOL v37 = v19 < 2;
                else {
                  int v29 = v36;
                }
                *(_DWORD *)(v4 + 284) = v29;
                --v19;
                if (v37) {
                  goto LABEL_42;
                }
              }

              int Script = *(_DWORD *)(v4 + 8LL * v29 + 32);
            }
          }

          else
          {
            int v20 = *(_DWORD *)(v4 + 24);
            if (v19 < 32) {
              int v21 = v19 + 1;
            }
            else {
              int v21 = 32;
            }
            *(_DWORD *)(v4 + 288) = v21;
            int v22 = *(_DWORD *)(v4 + 292);
            if (v22 < 32) {
              int v23 = v22 + 1;
            }
            else {
              int v23 = 32;
            }
            *(_DWORD *)(v4 + 292) = v23;
            int v24 = *(_DWORD *)(v4 + 284) + 1;
            BOOL v25 = -v24 < 0;
            int v26 = -v24 & 0x1F;
            int v27 = v24 & 0x1F;
            if (!v25) {
              int v27 = -v26;
            }
            *(_DWORD *)(v4 + 284) = v27;
            uint64_t v28 = v4 + 8LL * v27;
            *(_DWORD *)(v28 + 28) = v17;
            *(_DWORD *)(v28 + 32) = v20;
          }
        }

uint64_t uscript_getCode(char *__s1, int32_t *a2, int a3, int *a4)
{
  v19[8] = *(void **)MEMORY[0x1895F89C0];
  if (*a4 > 0) {
    return 0LL;
  }
  int v6 = __s1;
  if (!__s1) {
    goto LABEL_15;
  }
  if (a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_15:
    uint64_t v4 = 0LL;
    *a4 = 1;
    return v4;
  }

  if (a3) {
    goto LABEL_15;
  }
LABEL_6:
  if (!strcmp(__s1, "Aran")) {
    int v6 = "Arab";
  }
  unsigned int v9 = strrchr(v6, 45);
  if (v9 || (unsigned int v9 = strrchr(v6, 95)) != 0LL)
  {
    if (v9 - v6 == 7)
    {
      if (strlen(v6) != 11)
      {
LABEL_13:
        int v10 = 1;
LABEL_23:
        int v18 = 0;
        uint64_t v13 = sub_180876468((uint64_t)v6, a2, a3, a4);
        uint64_t v4 = v13;
        if (*a4 > 0 || (_DWORD)v13) {
          return v4;
        }
        memset(&v19[1], 0, 56);
        v19[0] = (char *)&v19[1] + 5;
        LODWORD(v19[1]) = 40;
        v17[0] = 0LL;
        v17[1] = 0LL;
        icu::CharStringByteSink::CharStringByteSink(v17, (uint64_t)v19);
        ulocimp_addLikelySubtags(v6, v17, &v18);
        icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v17);
        if (v18 > 0 || v18 == -124)
        {
          if (!v10) {
            goto LABEL_40;
          }
        }

        else
        {
          unsigned int v14 = sub_180876468((uint64_t)v19[0], a2, a3, a4);
          BOOL v15 = *a4 <= 0 && v14 == 0;
          if (v15) {
            uint64_t v4 = 0LL;
          }
          else {
            uint64_t v4 = v14;
          }
          if (!v15 || ((v10 ^ 1) & 1) != 0) {
            goto LABEL_41;
          }
        }

        int32_t PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, v6);
        if (PropertyValueEnum != -1 && *a4 <= 0)
        {
          if (a3) {
            *a2 = PropertyValueEnum;
          }
          else {
            *a4 = 15;
          }
          uint64_t v4 = 1LL;
          goto LABEL_41;
        }

uint64_t sub_180876468(uint64_t a1, int32_t *a2, int a3, int *a4)
{
  uint64_t result = 0LL;
  v15[1] = *MEMORY[0x1895F89C0];
  int v13 = 0;
  *(void *)alias = 0LL;
  v15[0] = 0LL;
  if (*a4 > 0) {
    return result;
  }
  uloc_getLanguage(a1, (char *)v15, 8, &v13);
  uint64_t result = 0LL;
  if (v13 > 0 || v13 == -124) {
    return result;
  }
  if (LOWORD(v15[0]) ^ 0x616A | BYTE2(v15[0]))
  {
    if (LOWORD(v15[0]) ^ 0x6F6B | BYTE2(v15[0]))
    {
      int Script = uloc_getScript(a1, alias, 8, &v13);
      uint64_t result = 0LL;
      if (v13 > 0 || v13 == -124) {
        return result;
      }
      if (LOWORD(v15[0]) ^ 0x687A | BYTE2(v15[0]) || *(_DWORD *)alias ^ 0x746E6148 | alias[4])
      {
        if (Script)
        {
          int32_t PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, alias);
          if (PropertyValueEnum != -1)
          {
            int32_t v11 = (PropertyValueEnum - 73) >= 2 ? PropertyValueEnum : 17;
            if (*a4 <= 0)
            {
              if (a3 <= 0) {
                *a4 = 15;
              }
              else {
                *a2 = v11;
              }
              return 1LL;
            }
          }
        }

        return 0LL;
      }

      if (*a4 > 0) {
        return 0LL;
      }
      if (a3 >= 2)
      {
        uint64_t v12 = 0x500000011LL;
        goto LABEL_31;
      }
    }

    else
    {
      if (*a4 > 0) {
        return 0LL;
      }
      if (a3 >= 2)
      {
        uint64_t v12 = 0x1100000012LL;
LABEL_31:
        *(void *)a2 = v12;
        return 2LL;
      }
    }

    *a4 = 15;
    return 2LL;
  }

  if (*a4 > 0) {
    return 0LL;
  }
  if (a3 >= 3)
  {
    *(void *)a2 = 0x1400000016LL;
    a2[2] = 17;
  }

  else
  {
    *a4 = 15;
  }

  return 3LL;
}

uint64_t uscript_getSampleString(unsigned int a1, _WORD *a2, unsigned int a3, int *a4)
{
  if (*a4 > 0) {
    return 0LL;
  }
  if ((a3 & 0x80000000) != 0 || !a2 && a3)
  {
    *a4 = 1;
    return 0LL;
  }

  if (a1 <= 0xC7 && (int v5 = dword_180A2BB90[a1], v6 = v5 & 0x1FFFFF, (v5 & 0x1FFFFF) != 0))
  {
    if (v6 < 0x10000) {
      uint64_t v7 = 1LL;
    }
    else {
      uint64_t v7 = 2LL;
    }
    if (v7 <= a3)
    {
      if (HIWORD(v6))
      {
        *a2 = (v6 >> 10) - 10304;
        a2[1] = v5 & 0x3FF | 0xDC00;
        uint64_t v7 = 2LL;
      }

      else
      {
        *a2 = v5;
        uint64_t v7 = 1LL;
      }
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  return u_terminateUChars((uint64_t)a2, a3, v7, a4);
}

uint64_t uscript_getSampleUnicodeString@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  if (result <= 0xC7)
  {
    unsigned int v2 = dword_180A2BB90[result] & 0x1FFFFF;
    if (v2) {
      return icu::UnicodeString::append(a2, v2);
    }
  }

  return result;
}

uint64_t uscript_getUsage(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0LL;
  }
  else {
    return (dword_180A2BB90[a1] >> 21) & 7;
  }
}

uint64_t uscript_isRightToLeft(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0LL;
  }
  else {
    return HIBYTE(dword_180A2BB90[a1]) & 1;
  }
}

uint64_t uscript_breaksBetweenLetters(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0LL;
  }
  else {
    return (dword_180A2BB90[a1] >> 25) & 1;
  }
}

uint64_t uscript_isCased(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0LL;
  }
  else {
    return (dword_180A2BB90[a1] >> 26) & 1;
  }
}

double uset_openEmpty@<D0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  unsigned int v2 = (icu::UnicodeSet *)icu::UMemory::operator new(a2, (icu::UMemory *)0xC8, a1);
  if (v2) {
    return icu::UnicodeSet::UnicodeSet(v2);
  }
  return result;
}

icu::UnicodeSet *uset_open@<X0>(unsigned int a1@<W0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unsigned int v3 = a2;
  double result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result) {
    return icu::UnicodeSet::UnicodeSet(result, a1, v3);
  }
  return result;
}

void uset_close(icu::UnicodeSet *a1)
{
  if (a1)
  {
    icu::UnicodeSet::~UnicodeSet(a1);
    icu::UMemory::operator delete(v1);
  }

BOOL uset_isFrozen(uint64_t a1)
{
  return *(void *)(a1 + 40) || *(void *)(a1 + 88) != 0LL;
}

void *uset_addString(icu::UnicodeSet *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 >> 31, &v6);
  icu::UnicodeSet::add(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_addAllCodePoints(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  memset(v6, 0, sizeof(v6));
  icu::UnicodeString::UnicodeString((uint64_t)v6, a2, a3);
  icu::UnicodeSet::addAll(a1, (const icu::UnicodeString *)v6);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v6);
}

void *uset_removeString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::remove(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_removeAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::removeAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_retainString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::retain(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_retainAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::retainAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_complementString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::complement(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_complementAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::complementAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

icu::UVector *uset_containsString(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  memset(v8, 0, sizeof(v8));
  uint64_t v7 = a2;
  icu::UnicodeString::UnicodeString(v8, a3 == -1, &v7);
  uint64_t v4 = icu::UnicodeSet::contains(a1, (const icu::UnicodeString *)v8);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
  return v4;
}

BOOL uset_containsAllCodePoints(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  memset(v8, 0, sizeof(v8));
  uint64_t v7 = a2;
  icu::UnicodeString::UnicodeString(v8, a3 == -1, &v7);
  BOOL v4 = icu::UnicodeSet::containsAll(a1, (const icu::UnicodeString *)v8);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
  return v4;
}

BOOL uset_containsSome(icu::UnicodeSet *a1, const icu::UnicodeSet *a2)
{
  return !icu::UnicodeSet::containsNone(a1, a2);
}

BOOL uset_equals(uint64_t a1, uint64_t a2)
{
  return icu::UnicodeSet::operator==(a1, a2);
}

uint64_t uset_getItemCount(icu::UnicodeSet *a1)
{
  int RangeCount = icu::UnicodeSet::getRangeCount(a1);
  return icu::UnicodeSet::stringsSize(a1) + RangeCount;
}

uint64_t uset_getItem(icu::UnicodeSet *a1, int a2, _DWORD *a3, _DWORD *a4, UChar *a5, int a6, int *a7)
{
  if (*a7 > 0) {
    return 0LL;
  }
  if (a2 < 0)
  {
    int v18 = 1;
  }

  else
  {
    int RangeCount = icu::UnicodeSet::getRangeCount(a1);
    signed int v16 = a2 - RangeCount;
    if (a2 < RangeCount)
    {
      *a3 = icu::UnicodeSet::getRangeStart(a1, a2);
      int RangeEnd = icu::UnicodeSet::getRangeEnd(a1, a2);
      uint64_t result = 0LL;
      *a4 = RangeEnd;
      return result;
    }

    if (v16 < (int)icu::UnicodeSet::stringsSize(a1))
    {
      uint64_t String = icu::UnicodeSet::getString((icu::UVector **)a1, v16);
      int v20 = a5;
      return icu::UnicodeString::extract(String, &v20, a6, a7);
    }

    int v18 = 8;
  }

  *a7 = v18;
  return 0xFFFFFFFFLL;
}

uint64_t uset_serialize(icu::UnicodeSet *a1, unsigned __int16 *a2, int a3, UErrorCode *a4)
{
  else {
    return 0LL;
  }
}

uint64_t uset_getSerializedSet(uint64_t a1, __int16 *a2, int a3)
{
  if (a1)
  {
    if (a2 && a3 > 0)
    {
      unsigned int v3 = (unsigned __int16 *)(a2 + 1);
      unsigned int v4 = (unsigned __int16)*a2;
      if (*a2 < 0)
      {
        v4 &= 0x7FFFu;
        if (v4 + 2 <= a3)
        {
          unsigned int v3 = (unsigned __int16 *)(a2 + 2);
          *(_DWORD *)(a1 + 8) = (unsigned __int16)a2[1];
          goto LABEL_11;
        }
      }

      else if (v4 < a3)
      {
        *(_DWORD *)(a1 + 8) = v4;
LABEL_11:
        *(void *)a1 = v3;
        uint64_t v5 = 1LL;
        goto LABEL_12;
      }
    }

    unsigned int v4 = 0;
    uint64_t v5 = 0LL;
    *(_DWORD *)(a1 + 8) = 0;
LABEL_12:
    *(_DWORD *)(a1 + 12) = v4;
    return v5;
  }

  return 0LL;
}

uint64_t uset_setSerializedToOne(uint64_t result, unsigned int a2)
{
  if (result && a2 <= 0x10FFFF)
  {
    *(void *)uint64_t result = result + 16;
    if (a2 > 0xFFFE)
    {
      if (a2 == 0xFFFF)
      {
        *(void *)(result + 8) = 0x300000001LL;
        *(_DWORD *)(result + 16) = 0x1FFFF;
        *(_WORD *)(result + 20) = 0;
      }

      else
      {
        *(_DWORD *)(result + 8) = 0;
        if (a2 >= 0x10FFFF)
        {
          *(void *)(result + 12) = 0xFFFF001000000002LL;
        }

        else
        {
          *(_DWORD *)(result + 12) = 4;
          *(_WORD *)(result + 16) = HIWORD(a2);
          *(_WORD *)(result + 18) = a2;
          *(_WORD *)(result + 20) = (a2 + 1) >> 16;
          *(_WORD *)(result + 22) = a2 + 1;
        }
      }
    }

    else
    {
      *(void *)(result + 8) = 0x200000002LL;
      *(_WORD *)(result + 16) = a2;
      *(_WORD *)(result + 18) = a2 + 1;
    }
  }

  return result;
}

uint64_t uset_serializedContains(unsigned __int16 **a1, unsigned int a2)
{
  uint64_t v2 = 0LL;
  if (a1)
  {
    unsigned int v3 = HIWORD(a2);
    if (HIWORD(a2) <= 0x10u)
    {
      unsigned int v4 = *a1;
      if (v3)
      {
        int v6 = *((_DWORD *)a1 + 3);
        uint64_t v7 = *((int *)a1 + 2);
        int v8 = v6 - 2 - v7;
        unsigned int v9 = v4[v7];
        if (v3 < v9 || v3 == v9 && v4[(int)v7 + 1] > (unsigned __int16)a2)
        {
          int v8 = 0;
        }

        else
        {
          unsigned int v11 = v4[v6 - 2];
          if (v3 < v11 || v3 == v11 && v4[v6 - 1] > (unsigned __int16)a2)
          {
            unsigned int v12 = (v8 >> 1) & 0xFFFFFFFE;
            if (v12)
            {
              for (i = 0; i != v12; unsigned int v12 = ((int)(v8 + i) >> 1) & 0xFFFFFFFE)
              {
                unsigned int v14 = v4[(int)(v12 + v7)];
                else {
                  unsigned int i = v12;
                }
              }
            }
          }

          else
          {
            int v8 = v6 - v7;
          }
        }

        return ((_BYTE)v7 + (v8 >> 1)) & 1;
      }

      else
      {
        if (*v4 <= a2)
        {
          int v5 = *((_DWORD *)a1 + 2);
          int v10 = v5 - 1;
          if (v4[v5 - 1] > a2)
          {
            if (v10 >= 2)
            {
              int v15 = 0;
              int v16 = v10 >> 1;
              --v5;
              do
              {
                else {
                  int v15 = v16;
                }
                int v16 = (v5 + v15) >> 1;
              }

              while (v16 != v15);
            }

            else
            {
              LOBYTE(v5) = v5 - 1;
            }
          }
        }

        else
        {
          LOBYTE(v5) = 0;
        }

        return v5 & 1;
      }
    }
  }

  return v2;
}

uint64_t uset_getSerializedRangeCount(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 8);
    int v2 = *(_DWORD *)(result + 12);
    BOOL v3 = __OFSUB__(v2, v1);
    int v4 = v2 - v1;
    if (v4 < 0 != v3) {
      ++v4;
    }
    int v5 = v1 + (v4 >> 1);
    if (v5 + 1 >= 0) {
      int v6 = v5 + 1;
    }
    else {
      int v6 = v5 + 2;
    }
    return (v6 >> 1);
  }

  return result;
}

uint64_t uset_getSerializedRange(uint64_t *a1, int a2, int *a3, int *a4)
{
  uint64_t result = 0LL;
  if (a1 && (a2 & 0x80000000) == 0 && a3 && a4)
  {
    uint64_t v6 = *a1;
    signed int v7 = *((_DWORD *)a1 + 3);
    uint64_t v8 = *((int *)a1 + 2);
    unsigned int v9 = 2 * a2;
    if (2 * a2 >= (int)v8)
    {
      uint64_t v12 = 2LL * (int)(v9 - v8);
      int v13 = v7 - v8;
      uint64_t v14 = v6 + 2 * v8;
      uint64_t v15 = (int)v12;
      *a3 = *(unsigned __int16 *)(v14 + ((2 * v12) | 2)) | (*(unsigned __int16 *)(v14 + 2LL * (int)v12) << 16);
      uint64_t v16 = (int)v12 + 2LL;
      if ((int)v16 < v13)
      {
        int v11 = *(unsigned __int16 *)(v14 + 2 * v15 + 6) | (*(unsigned __int16 *)(v14 + 2 * v16) << 16);
        goto LABEL_13;
      }
    }

    else
    {
      unsigned int v10 = v9 | 1;
      *a3 = *(unsigned __int16 *)(v6 + 2LL * v9);
      if ((int)(v9 | 1) < (int)v8)
      {
        int v11 = *(unsigned __int16 *)(v6 + 2LL * v10);
LABEL_13:
        int v17 = v11 - 1;
LABEL_16:
        *a4 = v17;
        return 1LL;
      }

      if ((int)v10 < v7)
      {
        int v11 = *(unsigned __int16 *)(v6 + 2LL * (int)(v9 + 2)) | (*(unsigned __int16 *)(v6 + 2LL * v10) << 16);
        goto LABEL_13;
      }
    }

    int v17 = 1114111;
    goto LABEL_16;
  }

  return result;
}

icu::UnicodeSet *uset_openPattern(uint64_t a1, int a2, UErrorCode *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  memset(v12, 0, sizeof(v12));
  uint64_t v11 = a1;
  icu::UnicodeString::UnicodeString(v12, a2 == -1, &v11);
  uint64_t v10 = v11;
  int v5 = (icu::UnicodeSet *)icu::UMemory::operator new(&v10, (icu::UMemory *)0xC8, v4);
  uint64_t v6 = v5;
  if (v5)
  {
    icu::UnicodeSet::UnicodeSet(v5, (const icu::UnicodeString *)v12, a3);
    uint64_t v7 = *(unsigned int *)a3;
    if ((int)v7 >= 1)
    {
      icu::UnicodeSet::~UnicodeSet(v6);
      icu::UMemory::operator delete(v8);
      uint64_t v6 = 0LL;
    }
  }

  else
  {
    uint64_t v7 = 7LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  icu::UnicodeString::~UnicodeString((void *)v7, (icu::UnicodeString *)v12);
  return v6;
}

icu::UnicodeSet *uset_openPatternOptions(uint64_t a1, int a2, unsigned int a3, UErrorCode *a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = a1;
  icu::UnicodeString::UnicodeString(v14, a2 == -1, &v13);
  uint64_t v12 = v13;
  uint64_t v7 = (icu::UnicodeSet *)icu::UMemory::operator new(&v12, (icu::UMemory *)0xC8, v6);
  uint64_t v8 = v7;
  if (v7)
  {
    icu::UnicodeSet::UnicodeSet(v7, (const icu::UnicodeString *)v14, a3, 0LL, a4);
    uint64_t v9 = *(unsigned int *)a4;
    if ((int)v9 >= 1)
    {
      icu::UnicodeSet::~UnicodeSet(v8);
      icu::UMemory::operator delete(v10);
      uint64_t v8 = 0LL;
    }
  }

  else
  {
    uint64_t v9 = 7LL;
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }

  icu::UnicodeString::~UnicodeString((void *)v9, (icu::UnicodeString *)v14);
  return v8;
}

uint64_t uset_applyPattern(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3, unsigned int a4, UErrorCode *a5)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    memset(v13, 0, sizeof(v13));
    icu::UnicodeString::UnicodeString((uint64_t)v13, a2, a3);
    uint64_t v11 = off_18970F400;
    unint64_t v12 = 0xFFFFFFFF00000000LL;
    icu::UnicodeSet::applyPattern(a1, (const icu::UnicodeString *)v13, (icu::ParsePosition *)&v11, a4, 0LL, a5);
    uint64_t v6 = v12;
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v11);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
  }

  else
  {
    uint64_t v6 = 0LL;
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v6;
}

void *uset_applyPropertyAlias( icu::UnicodeSet *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, UErrorCode *a6)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  memset(v14, 0, sizeof(v14));
  icu::UnicodeString::UnicodeString((uint64_t)v14, a2, a3);
  memset(v13, 0, sizeof(v13));
  icu::UnicodeString::UnicodeString((uint64_t)v13, a4, a5);
  icu::UnicodeSet::applyPropertyAlias(a1, (const icu::UnicodeString *)v14, (const icu::UnicodeString *)v13, a6);
  icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
  return icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v14);
}

BOOL uset_resemblesPattern(uint64_t a1, uint64_t a2, const icu::UnicodeString *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  icu::UnicodeString::UnicodeString((uint64_t)&v10, a1, a2);
  int v4 = (_DWORD)a3 + 1;
  if (SWORD4(v10) < 0)
  {
    unsigned int v5 = HIDWORD(v10);
    if (v4 < SHIDWORD(v10)) {
      goto LABEL_5;
    }
LABEL_11:
    BOOL v8 = icu::UnicodeSet::resemblesPattern((icu::UnicodeSet *)&v10, a3);
    goto LABEL_12;
  }

  if (v4 >= WORD4(v10) >> 5) {
    goto LABEL_11;
  }
  unsigned int v5 = WORD4(v10) >> 5;
LABEL_5:
  unint64_t v6 = (BYTE8(v10) & 2) != 0 ? (unint64_t)&v10 | 0xA : *((void *)&v11 + 1);
  uint64_t v7 = (void *)*(unsigned __int16 *)(v6 + 2LL * (int)a3);
  if ((_DWORD)v7 != 91) {
    goto LABEL_11;
  }
  BOOL v8 = 1LL;
LABEL_12:
  icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v10);
  return v8;
}

uint64_t uset_toPattern(icu::UnicodeSet *a1, UChar *a2, int a3, const icu::UnicodeString *a4, int *a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  uint64_t v16 = 0LL;
  __int128 v15 = 0u;
  __int128 v12 = off_18971B688;
  LOWORD(v13) = 2;
  icu::UnicodeSet::toPattern(a1, (icu::UnicodeString *)&v12, a4);
  __int128 v11 = a2;
  uint64_t v8 = icu::UnicodeString::extract((uint64_t)&v12, &v11, a3, a5);
  __int128 v10 = v11;
  icu::UnicodeString::~UnicodeString(&v10, (icu::UnicodeString *)&v12);
  return v8;
}

void *icu::UnicodeSetIterator::getStaticClassID(icu::UnicodeSetIterator *this)
{
  return &unk_18C5350F0;
}

void *icu::UnicodeSetIterator::getDynamicClassID(icu::UnicodeSetIterator *this)
{
  return &unk_18C5350F0;
}

icu::UnicodeSetIterator *icu::UnicodeSetIterator::UnicodeSetIterator( icu::UnicodeSetIterator *this, const icu::UnicodeSet *a2)
{
  *(void *)this = off_18971C190;
  *((void *)this + 7) = 0LL;
  *((void *)this + 3) = a2;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

{
  *(void *)this = off_18971C190;
  *((void *)this + 7) = 0LL;
  *((void *)this + 3) = a2;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

icu::UnicodeSet *icu::UnicodeSetIterator::reset(icu::UnicodeSetIterator *this, const icu::UnicodeSet *a2)
{
  *((void *)this + 3) = a2;
  return icu::UnicodeSetIterator::reset(this);
}

icu::UnicodeSetIterator *icu::UnicodeSetIterator::UnicodeSetIterator(icu::UnicodeSetIterator *this)
{
  *(void *)this = off_18971C190;
  *((void *)this + 3) = 0LL;
  *((void *)this + 7) = 0LL;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

{
  *(void *)this = off_18971C190;
  *((void *)this + 3) = 0LL;
  *((void *)this + 7) = 0LL;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

icu::UnicodeSet *icu::UnicodeSetIterator::reset(icu::UnicodeSetIterator *this)
{
  uint64_t result = (icu::UnicodeSet *)*((void *)this + 3);
  if (result)
  {
    *((_DWORD *)this + 8) = icu::UnicodeSet::getRangeCount(result) - 1;
    uint64_t result = (icu::UnicodeSet *)icu::UnicodeSet::stringsSize(*((icu::UnicodeSet **)this + 3));
    int v3 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 13) = (_DWORD)result;
    *(void *)((char *)this + 36) = 0xFFFFFFFF00000000LL;
    *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = 0;
    if ((v3 & 0x80000000) == 0)
    {
      *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), 0);
      uint64_t result = (icu::UnicodeSet *)icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), 0);
      *((_DWORD *)this + 10) = (_DWORD)result;
    }
  }

  else
  {
    *((_DWORD *)this + 13) = 0;
    *(void *)&__int128 v4 = 0xFFFFFFFFLL;
    *((void *)&v4 + sub_18086E18C((uint64_t)this, 1) = 0xFFFFFFFFLL;
    *((_OWORD *)this + 2) = v4;
  }

  *((_DWORD *)this + 12) = 0;
  *((void *)this + 2) = 0LL;
  return result;
}

void icu::UnicodeSetIterator::~UnicodeSetIterator(icu::UnicodeSetIterator *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UObject::~UObject(this);
}

{
  uint64_t v2;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UObject::~UObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UObject::~UObject(this);
  icu::UMemory::operator delete(v3);
}

uint64_t icu::UnicodeSetIterator::next(icu::UnicodeSetIterator *this)
{
  int v2 = *((_DWORD *)this + 11);
  if (v2 <= *((_DWORD *)this + 10))
  {
    uint64_t v6 = 0LL;
    *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = v2 + 1;
    *((_DWORD *)this + 2) = v2;
    *((_DWORD *)this + 3) = v2;
    goto LABEL_7;
  }

  int v3 = *((_DWORD *)this + 9);
  if (v3 < *((_DWORD *)this + 8))
  {
    int v4 = v3 + 1;
    *((_DWORD *)this + 9) = v3 + 1;
    *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), v3 + 1);
    int RangeEnd = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), v4);
    uint64_t v6 = 0LL;
    int v7 = *((_DWORD *)this + 11);
    *((_DWORD *)this + 10) = RangeEnd;
    *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = v7 + 1;
    *((_DWORD *)this + 2) = v7;
    *((_DWORD *)this + 3) = v7;
LABEL_7:
    *((void *)this + 2) = v6;
    return 1LL;
  }

  signed int v8 = *((_DWORD *)this + 12);
  if (v8 < *((_DWORD *)this + 13))
  {
    *((_DWORD *)this + 2) = -1;
    uint64_t v9 = *(icu::UVector **)(*((void *)this + 3) + 80LL);
    *((_DWORD *)this + 12) = v8 + 1;
    uint64_t v6 = icu::UVector::elementAt(v9, v8);
    goto LABEL_7;
  }

  return 0LL;
}

uint64_t icu::UnicodeSetIterator::loadRange(icu::UnicodeSetIterator *this, int a2)
{
  *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), a2);
  uint64_t result = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), a2);
  *((_DWORD *)this + 10) = result;
  return result;
}

uint64_t icu::UnicodeSetIterator::nextRange(icu::UnicodeSetIterator *this)
{
  *((void *)this + 2) = 0LL;
  int v3 = *((_DWORD *)this + 10);
  int v2 = *((_DWORD *)this + 11);
  if (v2 <= v3)
  {
    *((_DWORD *)this + 2) = v2;
    *((_DWORD *)this + 3) = v3;
    int v7 = v3 + 1;
    goto LABEL_5;
  }

  int v4 = *((_DWORD *)this + 9);
  if (v4 < *((_DWORD *)this + 8))
  {
    int v5 = v4 + 1;
    *((_DWORD *)this + 9) = v4 + 1;
    *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), v4 + 1);
    int RangeEnd = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), v5);
    *((_DWORD *)this + 2) = *((_DWORD *)this + 11);
    *((_DWORD *)this + 3) = RangeEnd;
    int v7 = RangeEnd + 1;
    *((_DWORD *)this + 10) = RangeEnd;
LABEL_5:
    *((_DWORD *)this + 1sub_18086E18C((uint64_t)this, 1) = v7;
    return 1LL;
  }

  signed int v9 = *((_DWORD *)this + 12);
  if (v9 < *((_DWORD *)this + 13))
  {
    *((_DWORD *)this + 2) = -1;
    __int128 v10 = *(icu::UVector **)(*((void *)this + 3) + 80LL);
    *((_DWORD *)this + 12) = v9 + 1;
    *((void *)this + 2) = icu::UVector::elementAt(v10, v9);
    return 1LL;
  }

  return 0LL;
}

uint64_t *icu::UnicodeSetIterator::getString@<X0>( icu::UnicodeSetIterator *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (uint64_t *)*((void *)this + 2);
  if (!result)
  {
    unsigned int v5 = *((_DWORD *)this + 2);
    if (v5 == -1) {
      return 0LL;
    }
    uint64_t v6 = *((void *)this + 7);
    if (!v6)
    {
      uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x40, a2);
      if (!result)
      {
        *((void *)this + 7) = 0LL;
LABEL_11:
        *((void *)this + 2) = result;
        return result;
      }

      uint64_t v6 = (uint64_t)result;
      *uint64_t result = (uint64_t)off_18971B688;
      *((_WORD *)result + 4) = 2;
      *((void *)this + 7) = result;
      unsigned int v5 = *((_DWORD *)this + 2);
    }

    icu::UnicodeString::unBogus(v6);
    else {
      uint64_t v7 = *(unsigned __int16 *)(v6 + 8) >> 5;
    }
    icu::UnicodeString::replace((icu::UnicodeString *)v6, 0LL, v7, v5);
    uint64_t result = (uint64_t *)*((void *)this + 7);
    goto LABEL_11;
  }

  return result;
}

uint64_t u_shapeArabic(UChar *src, uint64_t count, UChar *dest, int a4, int a5, int *a6)
{
  uint64_t v117 = *MEMORY[0x1895F89C0];
  if (!a6 || *a6 > 0) {
    return 0LL;
  }
  signed int v8 = (__int16 *)src;
  if (!src) {
    goto LABEL_27;
  }
  uint64_t v7 = count;
  BOOL v11 = dest || a4 == 0;
  BOOL v12 = !v11;
  if (a4 < 0) {
    goto LABEL_27;
  }
  if (v12) {
    goto LABEL_27;
  }
  int v14 = a5 & 0x18;
  unsigned int v15 = a5 & 0xE0000;
  if ((a5 & 0xE0000) != 0 && v14 == 24) {
    goto LABEL_27;
  }
  BOOL v16 = v15 && v14 == 16;
  BOOL v17 = v16;
  if ((a5 & 0x200) != 0) {
    goto LABEL_27;
  }
  if (v17) {
    goto LABEL_27;
  }
  int v18 = a5 & 0xE0;
  if (v18 == 160 || (a5 & 0x1001B) != 0x18 && (a5 & 0x4000) != 0) {
    goto LABEL_27;
  }
  int v21 = a5 & 0x10003;
  if ((a5 & 0x10003u) >= 4 && v21 != 0x10000) {
    goto LABEL_27;
  }
  if (v15 >> 17 > 6 || ((1 << (v15 >> 17)) & 0x5D) == 0) {
    goto LABEL_27;
  }
  if ((_DWORD)count == -1) {
    uint64_t v7 = u_strlen(src);
  }
  if ((int)v7 > 0)
  {
    if (!dest
      || (v8 > (__int16 *)dest || &v8[v7] <= (__int16 *)dest)
      && (dest > (UChar *)v8 || &dest[a4] <= (UChar *)v8))
    {
      if ((a5 & 0x8000000) != 0) {
        __int16 v22 = -397;
      }
      else {
        __int16 v22 = 8203;
      }
      if (v14)
      {
        unsigned __int16 v88 = v22;
        bzero(desta, 0x258uLL);
        if ((a5 & 0x4000) != 0)
        {
          int v85 = v21;
          if ((a5 & 4) != 0) {
            int v24 = -1;
          }
          else {
            int v24 = 1;
          }
          if ((a5 & 4) != 0) {
            int v25 = -1;
          }
          else {
            int v25 = v7;
          }
          int v95 = v25;
          int v26 = uprv_malloc(4 * (int)v7);
          if (!v26)
          {
            uint64_t v29 = 0LL;
            int v30 = 7;
LABEL_147:
            *a6 = v30;
            return v29;
          }

          uint64_t v92 = v26;
          int v86 = v18;
          if ((a5 & 4) != 0) {
            int v27 = v7;
          }
          else {
            int v27 = -1;
          }
          int v28 = 2 * v7;
          if ((a5 & 4) == 0) {
            int v28 = -1;
          }
          int v97 = v28;
          if (v27 + v24 == v95)
          {
            uint64_t v7 = 0LL;
          }

          else
          {
            uint64_t v7 = 0LL;
            unsigned __int16 v89 = 0;
            int v31 = &v8[v27 + (uint64_t)v24];
            int v90 = v24;
            uint64_t v91 = 2LL * v24;
            int v32 = v95 - (v27 + v24);
            unsigned __int8 v94 = 0;
            int v96 = 1;
            do
            {
              unsigned int v33 = (unsigned __int16)*v31;
              unsigned __int8 v34 = sub_18087865C(v33);
              if ((a5 & 0x4018) == 0x4018 && v96 && ((v34 | v94) & 0xC0) == 0xC0)
              {
                __int16 v35 = v89;
                if (v89 >= v33) {
                  __int16 v35 = v33;
                }
                unsigned __int16 v36 = v35 - 2542;
                v92[v97] = v36;
                unsigned __int8 v34 = sub_18087865C(v36);
                int v96 = 0;
                int v37 = v90;
              }

              else
              {
                int v37 = v90;
                v92[v97 + v90] = v33;
                uint64_t v7 = (v7 + 1);
                int v96 = 1;
                v97 += v90;
                unsigned __int16 v89 = v33;
              }

              int v31 = (__int16 *)((char *)v31 + v91);
              unsigned __int8 v94 = v34;
              v32 -= v37;
            }

            while (v32);
          }

          int v23 = v92;
          signed int v8 = &v92[v97 & (a5 << 29 >> 31)];
          int v21 = v85;
          int v18 = v86;
        }

        else
        {
          int v23 = 0LL;
        }

        if (!v21 || (uint64_t v29 = v7, v15 == 0x80000))
        {
          int v38 = v23;
          uint64_t v29 = sub_1808786F8(v8, v7, a5);
          int v23 = v38;
        }

        if ((int)v29 > a4)
        {
          *a6 = 15;
          if (v23)
          {
            uint64_t v39 = v29;
            uprv_free(v23);
            return v39;
          }

          return v29;
        }

        size_t v93 = v23;
        int v87 = v18;
        else {
          int v40 = v7;
        }
        if (v40 >= 301)
        {
          int v42 = (UChar *)uprv_malloc((2 * v40));
          if (!v42)
          {
            *a6 = 7;
            if (v93) {
              uprv_free(v93);
            }
            return 0LL;
          }

          size_t v41 = v42;
        }

        else
        {
          int v40 = 300;
          size_t v41 = desta;
        }

        u_memcpy(v41, (const UChar *)v8, v7);
        if (v93) {
          uprv_free(v93);
        }
        if ((a5 & 4) == 0)
        {
          LODWORD(v43) = 0;
          int v44 = (int)v7 > 0;
          if ((int)v7 >= 1 && *v41 == 32)
          {
            uint64_t v43 = 0LL;
            do
            {
              int v45 = v41[++v43];
              int v44 = (int)v7 > (int)v43;
            }

            while (v45 == 32 && (int)v7 > (int)v43);
          }

          if (v44)
          {
            int v47 = &v41[(int)v7 - 1];
            int v44 = -1;
            do
            {
              int v48 = *v47--;
              ++v44;
            }

            while (v48 == 32);
          }

          LODWORD(v49) = v7 + ~v44;
          if ((int)v49 > (int)v43)
          {
            uint64_t v49 = (int)v49;
            uint64_t v43 = (int)v43;
            do
            {
              UChar v50 = v41[v43];
              v41[v43] = v41[v49];
              v41[v49] = v50;
              ++v43;
              --v49;
            }

            while (v43 < v49);
          }
        }

        if ((~a5 & 0x4000004) != 0)
        {
          int v55 = 0;
          int v51 = 3;
          int v52 = 2;
          int v53 = 0x40000;
          int v54 = 393216;
        }

        else
        {
          int v51 = 2;
          int v52 = 3;
          int v53 = 393216;
          int v54 = 0x40000;
          int v55 = 1;
        }

        if (v14 != 24)
        {
          if (v14 == 16)
          {
            LODWORD(v98) = v88;
            *(void *)((char *)&v98 + 4) = __PAIR64__(v52, v51);
            HIDWORD(v98) = v53;
            int v99 = v54;
            int v100 = v55;
            uint64_t v57 = sub_18087905C(v41, v7, a5, a6, &v98);
          }

          else
          {
            if (v14 == 8)
            {
              if (!v15 || v15 == 786432)
              {
                LODWORD(v107) = v88;
                *(void *)((char *)&v107 + 4) = __PAIR64__(v52, v51);
                HIDWORD(v107) = v53;
                int v108 = v54;
                int v109 = v55;
                uint64_t v56 = sub_18087884C(v41, v7, a5, a6, 1, &v107);
                if (v15 == 786432) {
                  sub_180878F78(v41, v56);
                }
                uint64_t v57 = v56;
                goto LABEL_128;
              }

              v110[0] = v88;
              v110[1] = 0;
              int v111 = v51;
              int v112 = v52;
              int v113 = v53;
              int v114 = v54;
              int v115 = v55;
              int v58 = (__int128 *)v110;
              uint64_t v59 = v41;
              unsigned int v60 = v7;
              int v61 = a5;
              uint64_t v62 = a6;
              int v63 = 2;
              goto LABEL_127;
            }

            uint64_t v57 = 0LL;
          }

uint64_t sub_18087865C(int a1)
{
  if (a1 == 8205) {
    return 3LL;
  }
  if ((unsigned __int16)(a1 + 1200) <= 0x112u)
  {
    int v2 = a1 - 64336;
    int v3 = (unsigned __int8 *)&unk_180A2C03C;
    return v3[v2];
  }

  if ((unsigned __int16)(a1 + 400) <= 0x8Cu)
  {
    int v2 = a1 - 65136;
    int v3 = (unsigned __int8 *)&unk_180A2C14F;
    return v3[v2];
  }

  return 0LL;
}

uint64_t sub_1808786F8(__int16 *a1, uint64_t a2, int a3)
{
  BOOL v3 = (a3 & 0x1000B) == 8 || (a3 & 0xE0018) == 524296;
  uint64_t v4 = a2;
  if (v3)
  {
    unint64_t v5 = (a2 - 1);
    if ((a3 & 4) == 0)
    {
      if ((int)a2 >= 1)
      {
        unint64_t v6 = 0LL;
        uint64_t v4 = a2;
        while (1)
        {
          int v7 = (unsigned __int16)a1[v6];
          if (v7 != 1604 || v6 >= v5)
          {
            if ((v7 & 0xFFF0) != 0xFE70) {
              goto LABEL_21;
            }
          }

          else
          {
            unsigned int v9 = (unsigned __int16)a1[v6 + 1] - 1570;
            BOOL v10 = v9 > 5;
            int v11 = (1 << v9) & 0x2B;
            if (v10 || v11 == 0) {
              goto LABEL_21;
            }
          }

          uint64_t v4 = (v4 - 1);
LABEL_21:
        }
      }

      return a2;
    }

    unint64_t v15 = 0LL;
    uint64_t v4 = a2;
    while (1)
    {
      int v16 = (unsigned __int16)a1[v15];
      BOOL v17 = (v16 - 1570) > 5 || ((1 << (v16 - 34)) & 0x2B) == 0;
      if (!v17 && v15 < v5) {
        break;
      }
      if ((v16 & 0xFFF0) == 0xFE70) {
        goto LABEL_41;
      }
LABEL_42:
    }

    if (a1[v15 + 1] != 1604) {
      goto LABEL_42;
    }
LABEL_41:
    uint64_t v4 = (v4 - 1);
    goto LABEL_42;
  }

uint64_t sub_18087884C(UChar *a1, unsigned int a2, int a3, _DWORD *a4, int a5, __int128 *a6)
{
  if ((a3 & 0x8000) == 0 && (int)a2 >= 1)
  {
    uint64_t v7 = a2;
    signed int v8 = a1;
    while (1)
    {
      int v9 = *v8;
      if ((unsigned __int16)(v9 + 400) <= 0x8Cu)
      {
        LOWORD(v9) = word_180A2C340[v9 - 65136];
LABEL_9:
        UChar *v8 = v9;
      }

LABEL_163:
            if (v43 != v37) {
              goto LABEL_133;
            }
            char v59 = 0;
            BOOL v58 = 1;
LABEL_116:
            bzero(v42, v40);
            if ((a2 & 0x80000000) == 0)
            {
              int v60 = 0;
              signed int v61 = a2;
              uint64_t v62 = a2;
              do
              {
                int v63 = a1[v62];
                if (v63 == 0xFFFF) {
                  char v64 = v59;
                }
                else {
                  char v64 = 0;
                }
                BOOL v65 = v63 == 65534 && v58;
                if ((v64 & 1) != 0 || v65)
                {
                  ++v61;
                  ++v60;
                }

                else
                {
                  *(_WORD *)&v42[2 * v61] = v63;
                }

                --v61;
                char v26 = v62-- <= 0;
              }

              while (!v26);
              if (v60 >= 1) {
                memset_pattern16(v42, asc_180A2C4E0, 2LL * v60);
              }
            }

            uint64_t v34 = a2;
            u_memcpy(a1, (const UChar *)v42, a2);
LABEL_133:
            if (v44 == v36 || v44 == 0x10000 && !v84)
            {
              BOOL v66 = v43 == v86;
              char v67 = 1;
              uint64_t v33 = a2;
            }

            else
            {
              BOOL v51 = v43 == v86;
              uint64_t v33 = a2;
              if (!v51) {
                goto LABEL_155;
              }
              char v67 = 0;
              BOOL v66 = 1;
            }

            bzero(v42, v40);
            if ((int)v33 < 1)
            {
              unsigned int v68 = 0;
              uint64_t v76 = 0LL;
            }

            else
            {
              unsigned int v68 = 0;
              int v69 = 0;
              uint64_t v70 = v33;
              uint64_t v71 = a1;
              do
              {
                int v73 = *v71++;
                int v72 = v73;
                if (v73 == 0xFFFF) {
                  char v74 = v67;
                }
                else {
                  char v74 = 0;
                }
                BOOL v75 = v72 == 65534 && v66;
                if ((v74 & 1) != 0 || v75)
                {
                  --v69;
                  ++v68;
                }

                else
                {
                  *(_WORD *)&v42[2 * v69] = v72;
                }

                ++v69;
                --v70;
              }

              while (v70);
              if ((v68 & 0x80000000) != 0) {
                goto LABEL_154;
              }
              uint64_t v76 = 2LL * v33;
            }

            memset_pattern16(&v42[v76 - 2LL * v68], asc_180A2C4E0, 2LL * (v68 + 1));
LABEL_154:
            u_memcpy(a1, (const UChar *)v42, v33);
            uint64_t v34 = v33;
LABEL_155:
            uprv_free(v42);
            goto LABEL_156;
          }

          uint64_t v56 = a2;
          uint64_t v57 = a1;
          do
          {
            ++v57;
            --v56;
          }

          while (v56);
          uint64_t v34 = a2;
        }

        if (v44 == v35 || v44 == 0x10000 && v84 == 1) {
          goto LABEL_115;
        }
        goto LABEL_163;
      }
    }

    bzero(v41, v40);
    if ((int)a2 < 1)
    {
      unsigned int v45 = 0;
      unsigned int v55 = 0;
    }

    else
    {
      unsigned int v45 = 0;
      int v46 = 0;
      int v47 = a1;
      uint64_t v48 = a2;
      do
      {
        int v50 = *v47++;
        int v49 = v50;
        BOOL v51 = v43 == 0x80000 && v49 == 65534;
        int v52 = v51;
        if ((v49 != 0xFFFF || v44 != 0) && v52 == 0)
        {
          *(_WORD *)&v42[2 * v46] = v49;
        }

        else
        {
          --v46;
          ++v45;
        }

        ++v46;
        --v48;
      }

      while (v48);
      unsigned int v55 = a2;
      if ((v45 & 0x80000000) != 0) {
        goto LABEL_104;
      }
    }

    bzero(&v42[2 * (v55 - (unint64_t)v45)], 2LL * (v45 + 1));
LABEL_104:
    u_memcpy(a1, (const UChar *)v42, a2);
    uint64_t v34 = u_strlen(a1);
    goto LABEL_105;
  }

  char v67 = (int)v31 <= 0;
  int v28 = v86;
  if (v67) {
    goto LABEL_166;
  }
LABEL_164:
  *(_DWORD *)a2 = v10 - 1;
  unsigned int v55 = (unint64_t)a4;
  *(_DWORD *)a4 = i;
  unsigned int v68 = 1LL;
LABEL_165:
  icu::UnicodeString::~UnicodeString((void *)v55, (icu::UnicodeString *)&v92);
  return v68;
}

LABEL_156:
  if (HIDWORD(v85) | v15)
  {
    __int128 v87 = *a6;
    uint64_t v88 = *((void *)a6 + 2);
    return sub_180879334(a1, v33, v34, a3, a4, 0, (uint64_t)&v87);
  }

  return v34;
}

                    __int32 v139 = "m";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v139);
                    signed int v61 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v62, (icu::UnicodeString *)&__src);
                    v121[2] = (uint64_t)v139;
                    if (v61)
                    {
                      uint64_t v138 = "s";
                      icu::UnicodeString::UnicodeString(&__src, 1LL, &v138);
                      int v63 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                      icu::UnicodeString::~UnicodeString(v64, (icu::UnicodeString *)&__src);
                      _OWORD v115[3] = v138;
                      if (v63)
                      {
                        BOOL v65 = 0;
                      }

                      else
                      {
                        __int32 v137 = "p";
                        BOOL v65 = 1;
                        icu::UnicodeString::UnicodeString(&__src, 1LL, &v137);
                        int v73 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                        icu::UnicodeString::~UnicodeString(v74, (icu::UnicodeString *)&__src);
                        v115[2] = v137;
                        if (!v73)
                        {
                          __int32 v136 = "s";
                          icu::UnicodeString::UnicodeString(&__src, 1LL, &v136);
                          BOOL v75 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                          icu::UnicodeString::~UnicodeString(v76, (icu::UnicodeString *)&__src);
                          v115[1] = v136;
                          if (v75)
                          {
                            BOOL v65 = 2;
                          }

                          else
                          {
                            int v135 = L"currency";
                            icu::UnicodeString::UnicodeString(&__src, 1LL, &v135);
                            int v90 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                            icu::UnicodeString::~UnicodeString(v91, (icu::UnicodeString *)&__src);
                            v115[0] = v135;
                            int v49 = (unint64_t)v115;
                            if (!v90) {
                              goto LABEL_211;
                            }
                            BOOL v65 = 3;
                          }
                        }
                      }

                      icu::CollationSettings::setMaxVariable(*(void *)(v3 + 32), v65, 0, a2);
                      LastPrimaryForGroup = icu::CollationData::getLastPrimaryForGroup( *(icu::CollationData **)(v3 + 24),  v65 | 0x1000);
                      int v49 = *(void *)(v3 + 32);
                      *(_DWORD *)(v49 + 28) = LastPrimaryForGroup;
                      goto LABEL_189;
                    }

                    __int32 v134 = "c";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v134);
                    BOOL v66 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v67, (icu::UnicodeString *)&__src);
                    v121[1] = (uint64_t)v134;
                    if (v66)
                    {
                      int8x8_t v133 = "o";
                      icu::UnicodeString::UnicodeString(&__src, 1LL, &v133);
                      unsigned int v68 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                      icu::UnicodeString::~UnicodeString(v69, (icu::UnicodeString *)&__src);
                      v116[2] = v133;
                      if (v68)
                      {
                        uint64_t v70 = 16;
                      }

                      else
                      {
                        int8x8_t v132 = "l";
                        icu::UnicodeString::UnicodeString(&__src, 1LL, &v132);
                        int v84 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                        icu::UnicodeString::~UnicodeString(v85, (icu::UnicodeString *)&__src);
                        v116[1] = v132;
                        if (v84)
                        {
                          uint64_t v70 = 24;
                        }

                        else
                        {
                          int v131 = "u";
                          icu::UnicodeString::UnicodeString(&__src, 1LL, &v131);
                          size_t v93 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                          icu::UnicodeString::~UnicodeString(v94, (icu::UnicodeString *)&__src);
                          v116[0] = v131;
                          int v49 = (unint64_t)v116;
                          if (!v93) {
                            goto LABEL_211;
                          }
                          uint64_t v70 = 25;
                        }
                      }

                      icu::CollationSettings::setCaseFirst(*(void *)(v3 + 32), v70, 0, (int *)a2);
                      goto LABEL_189;
                    }

                    int v130 = "c";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v130);
                    uint64_t v77 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v78, (icu::UnicodeString *)&__src);
                    v121[0] = (uint64_t)v130;
                    if (v77)
                    {
                      uint64_t v80 = icu::CollationRuleParser::getOnOffValue( v121,  (icu::CollationRuleParser *)&v166,  v79);
                      if (v80 == -1) {
                        goto LABEL_211;
                      }
                      int v81 = v80;
                      int v82 = *(void *)(v3 + 32);
                      BOOL v83 = 1024;
LABEL_188:
                      icu::CollationSettings::setFlag(v82, v83, v81, 0, (int *)a2);
                      goto LABEL_189;
                    }

                    int v129 = "n";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v129);
                    int v86 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v87, (icu::UnicodeString *)&__src);
                    int v120 = v129;
                    if (v86)
                    {
                      unsigned __int16 v89 = icu::CollationRuleParser::getOnOffValue( (uint64_t *)&v120,  (icu::CollationRuleParser *)&v166,  v88);
                      if (v89 == -1) {
                        goto LABEL_211;
                      }
                      int v81 = v89;
                      int v82 = *(void *)(v3 + 32);
                      BOOL v83 = 1;
                      goto LABEL_188;
                    }

                    v128 = "n";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v128);
                    int v95 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v96, (icu::UnicodeString *)&__src);
                    v119 = v128;
                    if (v95)
                    {
                      __int128 v98 = icu::CollationRuleParser::getOnOffValue( (uint64_t *)&v119,  (icu::CollationRuleParser *)&v166,  v97);
                      if (v98 == -1) {
                        goto LABEL_211;
                      }
                      int v81 = v98;
                      int v82 = *(void *)(v3 + 32);
                      BOOL v83 = 2;
                      goto LABEL_188;
                    }

                    __int32 v127 = "h";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v127);
                    int v99 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v100, (icu::UnicodeString *)&__src);
                    uint64_t v118 = v127;
                    if (v99)
                    {
                      int v102 = icu::CollationRuleParser::getOnOffValue( (uint64_t *)&v118,  (icu::CollationRuleParser *)&v166,  v101);
                      if (v102 != -1)
                      {
                        if (v102 == 17)
                        {
                          int v49 = *(unsigned int *)a2;
                          if ((int)v49 <= 0)
                          {
                            *a2 = U_INVALID_FORMAT_ERROR;
                            *(void *)(v3 + 48) = "[hiraganaQ on] is not supported";
                            int v49 = *(void *)(v3 + 40);
                            if (v49) {
                              icu::CollationRuleParser::setErrorContext((char *)v3);
                            }
                          }
                        }

                        goto LABEL_189;
                      }

                      goto LABEL_211;
                    }

                    unsigned int v126 = "i";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v126);
                    int v103 = sub_1807FF934((uint64_t)&v171, (uint64_t)&__src);
                    icu::UnicodeString::~UnicodeString(v104, (icu::UnicodeString *)&__src);
                    uint64_t v117 = v126;
                    int v49 = (unint64_t)&v117;
                    if (!v103)
                    {
LABEL_211:
                      icu::UnicodeString::~UnicodeString((void *)v49, (icu::UnicodeString *)&v166);
LABEL_212:
                      uint64_t v29 = (void *)*(unsigned int *)a2;
                      if ((int)v29 <= 0)
                      {
                        *a2 = U_INVALID_FORMAT_ERROR;
                        *(void *)(v3 + 48) = "not a valid setting/option";
                        uint64_t v29 = *(void **)(v3 + 40);
                        if (v29) {
                          icu::CollationRuleParser::setErrorContext((char *)v3);
                        }
                      }

                      return (icu::CollationRuleParser *)icu::UnicodeString::~UnicodeString( v29,  (icu::UnicodeString *)&v171);
                    }

                    memset(&__s[1], 0, 48);
                    __s[0] = (char *)&__s[1] + 5;
                    LODWORD(__s[1]) = 40;
                    int64_t v165 = 0LL;
                    icu::CharString::appendInvariantChars((icu::CharString *)__s, (const icu::UnicodeString *)&v166, a2);
                    if (*a2 == U_MEMORY_ALLOCATION_ERROR)
                    {
LABEL_221:
                      int v49 = BYTE4(__s[1]);
                      if (BYTE4(__s[1])) {
                        uprv_free(__s[0]);
                      }
                      goto LABEL_190;
                    }

                    memset(&v163[1], 0, 56);
                    v163[0] = (char *)&v163[1] + 5;
                    LODWORD(v163[1]) = 40;
                    int v125 = 0;
                    __src = 0uLL;
                    icu::CharStringByteSink::CharStringByteSink(&__src, (uint64_t)v163);
                    ulocimp_forLanguageTag(__s[0], -1, (uint64_t)&__src, &v125, (int *)a2);
                    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&__src);
                    if (v125 != (_DWORD)v165) {
                      goto LABEL_217;
                    }
                    int v153 = 0u;
                    memset(v154, 0, 29);
                    int v151 = 0u;
                    int8x8_t v152 = 0u;
                    int v149 = 0u;
                    uint64_t v150 = 0u;
                    uint64_t v147 = 0u;
                    int8x8_t v148 = 0u;
                    __src = 0u;
                    int BaseName = uloc_getBaseName((char *)v163[0], (char *)&__src, 157, a2);
                    if (*(int *)a2 > 0 || BaseName >= 96)
                    {
LABEL_217:
                      *a2 = U_INVALID_FORMAT_ERROR;
                      *(void *)(v3 + 48) = "expected language tag in [import langTag]";
                      if (*(void *)(v3 + 40)) {
                        icu::CollationRuleParser::setErrorContext((char *)v3);
                      }
                      goto LABEL_219;
                    }

                    if (!BaseName
                      || BaseName == 3
                      && ((unsigned __int16)__src == 28277 ? (int v106 = BYTE2(__src) == 100) : (int v106 = 0), v106))
                    {
                      strcpy((char *)&__src, "root");
                    }

                    else if (__src == 95)
                    {
                      memmove((char *)&__src + 3, &__src, BaseName + 1);
                      qmemcpy(&__src, "und", 3);
                    }

                    memset(&v161[1], 0, 48);
                    v161[0] = (char *)&v161[1] + 5;
                    LODWORD(v161[1]) = 40;
                    int64_t v162 = 0LL;
                    *(void *)&unint64_t v157 = 0LL;
                    int v156 = 0LL;
                    icu::CharStringByteSink::CharStringByteSink(&v156, (uint64_t)v161);
                    ulocimp_getKeywordValue((char *)v163[0], "collation", (uint64_t)&v156, (int *)a2);
                    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v156);
                    if (*(int *)a2 < 1)
                    {
                      int v108 = *(void *)(v3 + 64);
                      if (v108)
                      {
                        int v160 = 0LL;
                        int v158 = 0u;
                        char v159 = 0u;
                        unint64_t v157 = 0u;
                        int v156 = off_18971B688;
                        LOWORD(v157) = 2;
                        if ((_DWORD)v162) {
                          int v109 = (const char *)v161[0];
                        }
                        else {
                          int v109 = "standard";
                        }
                        uint64_t v110 = (void *)(v3 + 48);
                        (*(void (**)(uint64_t, __int128 *, const char *, void (***)(icu::UnicodeString *__hidden), uint64_t, UErrorCode *))(*(void *)v108 + 24LL))( v108,  &__src,  v109,  &v156,  v3 + 48,  a2);
                        if (*(int *)a2 < 1)
                        {
                          int v112 = *(void *)(v3 + 16);
                          int v113 = *(_DWORD *)(v3 + 72);
                          icu::CollationRuleParser::parse( (icu::CollationRuleParser *)v3,  (const icu::UnicodeString *)&v156,  a2);
                          int v111 = (_DWORD *)*(unsigned int *)a2;
                          if ((int)v111 >= 1)
                          {
                            int v111 = *(_DWORD **)(v3 + 40);
                            if (v111) {
                              v111[1] = v113;
                            }
                          }

                          *(void *)(v3 + 16) = v112;
                          *(_DWORD *)(v3 + 72) = v11;
                        }

                        else
                        {
                          if (!*v110) {
                            *uint64_t v110 = "[import langTag] failed";
                          }
                          icu::CollationRuleParser::setErrorContext((char *)v3);
                        }

                        icu::UnicodeString::~UnicodeString(v111, (icu::UnicodeString *)&v156);
                        goto LABEL_242;
                      }

                      *a2 = U_INVALID_FORMAT_ERROR;
                      __int128 v107 = "[import langTag] is not supported";
                    }

                    else
                    {
                      *a2 = U_INVALID_FORMAT_ERROR;
                      __int128 v107 = "expected language tag in [import langTag]";
                    }

                    *(void *)(v3 + 48) = v107;
                    if (*(void *)(v3 + 40)) {
                      icu::CollationRuleParser::setErrorContext((char *)v3);
                    }
LABEL_242:
                    if (BYTE4(v161[1])) {
                      uprv_free(v161[0]);
                    }
LABEL_219:
                    if (BYTE4(v163[1])) {
                      uprv_free(v163[0]);
                    }
                    goto LABEL_221;
                  }
                }

                icu::UnicodeString::~UnicodeString(v47, (icu::UnicodeString *)&__src);
                v121[5] = (uint64_t)v143;
                goto LABEL_141;
              }
            }

            else if ((v172 & 0xFFE0) != 0xE0)
            {
              int v27 = (unsigned __int16)v172 >> 5;
              goto LABEL_58;
            }

            icu::UnicodeString::~UnicodeString((void *)(unsigned __int16)v172, (icu::UnicodeString *)&__src);
            v121[10] = (uint64_t)v145;
LABEL_65:
            icu::CollationRuleParser::parseReordering( (icu::CollationRuleParser *)v3,  (const icu::UnicodeString *)&v171,  a2);
LABEL_79:
            *(_DWORD *)(v3 + 72) = v11;
            return (icu::CollationRuleParser *)icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v171);
          }
        }

        int v15 = v14;
        goto LABEL_45;
      }
    }

    if ((v7 & 0x8000) != 0) {
      signed int v8 = *(_DWORD *)(v6 + 12);
    }
    if (v8 <= Words) {
      goto LABEL_212;
    }
    int v16 = (v7 & 2) != 0 ? v6 + 10 : *(void *)(v6 + 24);
    if (*(_WORD *)(v16 + 2LL * Words) != 91) {
      goto LABEL_212;
    }
    uint64_t v155 = 0LL;
    memset(v154, 0, sizeof(v154));
    int8x8_t v152 = 0u;
    int v153 = 0u;
    uint64_t v150 = 0u;
    int v151 = 0u;
    int8x8_t v148 = 0u;
    int v149 = 0u;
    __src = 0u;
    uint64_t v147 = 0u;
    icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)&__src);
    int v17 = icu::CollationRuleParser::parseUnicodeSet( (icu::CollationRuleParser *)v3,  Words,  (icu::UnicodeSet *)&__src,  a2);
    if (*(int *)a2 > 0)
    {
LABEL_113:
      ((void (*)(icu::UnicodeSet *__hidden))icu::UnicodeSet::~UnicodeSet)((icu::UnicodeSet *)&__src);
      return (icu::CollationRuleParser *)icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v171);
    }

    int v18 = v17;
    uint64_t v124 = L"optimize";
    int v19 = (icu::UnicodeString *)icu::UnicodeString::UnicodeString(&v166, 1LL, &v124);
    if ((v172 & 1) != 0)
    {
      int v22 = (unsigned __int16)v167;
      int v23 = v167 & 1;
    }

    else
    {
      if ((v172 & 0x8000u) == 0LL) {
        unsigned int v20 = (unsigned __int16)v172 >> 5;
      }
      else {
        unsigned int v20 = DWORD1(v172);
      }
      if ((v167 & 0x8000u) == 0LL) {
        unsigned int v21 = (void *)((unsigned __int16)v167 >> 5);
      }
      else {
        unsigned int v21 = (void *)DWORD1(v167);
      }
      if ((v167 & 1) != 0 || v20 != (_DWORD)v21)
      {
        uint64_t v34 = icu::UnicodeString::~UnicodeString(v21, v19);
        v122[2] = v124;
        goto LABEL_108;
      }

      int v23 = icu::UnicodeString::doEquals((icu::UnicodeString *)&v171, (const icu::UnicodeString *)&v166, v20);
    }

    uint64_t v34 = icu::UnicodeString::~UnicodeString((void *)v22, (icu::UnicodeString *)&v166);
    v122[1] = v124;
    if (v23)
    {
      int v35 = *(void (**)(void))(**(void **)(v3 + 56) + 48LL);
LABEL_110:
      v35();
      *(_DWORD *)(v3 + 72) = v18;
      goto LABEL_113;
    }

uint64_t sub_180878F78(_WORD *a1, uint64_t a2)
{
  if ((int)a2 >= 1)
  {
    for (uint64_t i = a2; i; --i)
    {
      int v3 = (unsigned __int16)*a1;
      if ((v3 & 0xFFF0) == 0xFE70)
      {
        if (v3 != 65139 && v3 != 65141)
        {
          if (v3 == 65149) {
            goto LABEL_24;
          }
          if (((0xAA82uLL >> (v3 - 112)) & 1) != 0)
          {
            LOWORD(v3) = 1600;
            goto LABEL_24;
          }

          if (v3 != 65139 && v3 != 65141)
          {
            int v5 = 1 - byte_180A2C4B6[v3 - 65136];
            goto LABEL_20;
          }
        }
      }

      else if ((v3 - 64754) < 3 || v3 == 65149)
      {
        LOWORD(v3) = -387;
        goto LABEL_24;
      }

      int v5 = (unsigned __int16)(v3 + 930) < 6u;
LABEL_20:
      if (v3 == 65148 || !v5) {
        goto LABEL_25;
      }
      LOWORD(v3) = 32;
LABEL_24:
      *a1 = v3;
LABEL_25:
      ++a1;
    }
  }

  return a2;
}

uint64_t sub_18087905C(UChar *a1, uint64_t a2, int a3, _DWORD *a4, __int128 *a5)
{
  unint64_t v7 = (a2 - 1);
  uint64_t v20 = v5;
  uint64_t v21 = v6;
  unint64_t v8 = 0LL;
  int v9 = 0;
  do
  {
    int v10 = a1[v8];
    if ((unsigned __int16)(v10 + 1200) > 0xAFu)
    {
      if ((a3 & 0x3800000) == 0x1000000 && (v10 == 65152 || v10 == 1569) && v8 < v7)
      {
        unsigned int v12 = &a1[v8];
        int v13 = v12[1];
        if ((v13 - 65263) < 2 || v13 == 1609)
        {
          LOWORD(v10) = 32;
          a1[v8] = 32;
          v12[1] = 1574;
          goto LABEL_27;
        }
      }

      if ((a3 & 0x700000) != 0x200000
        || (v10 != 8203 ? (BOOL v14 = v10 == 65139) : (BOOL v14 = 1),
            v14 ? (BOOL v15 = v8 >= v7) : (BOOL v15 = 1),
            v15
         || (UChar v16 = a1[v8 + 1], (unsigned __int16)(v16 + 335) > 0xDu)
         || ((0xCCCuLL >> (v16 + 79)) & 1) != 0))
      {
        LOWORD(v10) = word_180A2C340[v10 - 65136];
      }

      else
      {
        LOWORD(v10) = 32;
      }

      a1[v8] = v10;
    }

    else
    {
      unsigned __int16 v11 = word_180A2C1E0[v10 - 64336];
      if (v11)
      {
        a1[v8] = v11;
        LOWORD(v10) = v11;
      }
    }

uint64_t sub_18087921C(uint64_t result, int a2, __int16 a3, int a4, unsigned __int8 a5)
{
  uint64_t v5 = (_WORD *)result;
  int v6 = a5;
  __int16 v7 = a3 - 48;
  if (a4)
  {
    if (a2 >= 1)
    {
      uint64_t v8 = a2;
      do
      {
        unsigned int v9 = (unsigned __int16)*v5;
        uint64_t result = ubidi_getClass(v9);
        if (result < 2)
        {
          int v6 = 0;
        }

        else if ((_DWORD)result == 2)
        {
          if (v6)
          {
            if (v9 - 48 <= 9) {
              *uint64_t v5 = v9 + v7;
            }
            int v6 = 1;
          }
        }

        else if ((_DWORD)result == 13)
        {
          int v6 = 1;
        }

        ++v5;
        --v8;
      }

      while (v8);
    }
  }

  else
  {
    unsigned int v10 = a2 - 1;
    if (a2 >= 1)
    {
      uint64_t v11 = a2 + 1LL;
      do
      {
        unsigned int v12 = (unsigned __int16)v5[v10];
        uint64_t v13 = v10;
        uint64_t result = ubidi_getClass(v12);
        if (result < 2)
        {
          int v6 = 0;
        }

        else if ((_DWORD)result == 2)
        {
          if (v6)
          {
            if (v12 - 48 <= 9) {
              v5[v13] = v12 + v7;
            }
            int v6 = 1;
          }
        }

        else if ((_DWORD)result == 13)
        {
          int v6 = 1;
        }

        --v11;
        unsigned int v10 = v13 - 1;
      }

      while (v11 > 1);
    }
  }

  return result;
}

uint64_t sub_180879334(UChar *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, int a6, uint64_t a7)
{
  int v14 = a4 & 0x10003;
  if ((a4 & 0x10003) == 0x10000 && a6 == 1)
  {
    if (*(_DWORD *)(a7 + 20))
    {
      uint64_t v19 = sub_1808798CC(a1, a2, a5);
      if (*a5 == 20)
      {
        *a5 = 0;
        uint64_t v20 = sub_180879720(a1, a2, a5);
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v19 = sub_180879720(a1, a2, a5);
      if (*a5 == 20)
      {
        *a5 = 0;
        uint64_t v20 = sub_1808798CC(a1, a2, a5);
LABEL_17:
        a3 = v20;
        if (*a5 != 20) {
          goto LABEL_27;
        }
        *a5 = 0;
        a3 = a2;
        uint64_t v21 = a2;
        int v22 = a1 + 1;
        do
        {
          uint64_t v23 = (unsigned __int16)*v22;
          if ((unsigned __int16)(v23 + 259) >= 0xFFF8u)
          {
            if (*(v22 - 1) == 32)
            {
              *int v22 = 1604;
              *(v22 - sub_18086E18C((uint64_t)this, 1) = word_180A2C4A2[v23 - 65269];
            }

            else
            {
              *a5 = 20;
            }
          }

          ++v22;
          --v21;
        }

        while (v21);
        a3 = a2;
        goto LABEL_5;
      }
    }

    a3 = v19;
    goto LABEL_27;
  }

LABEL_5:
  if (a6 != 1)
  {
    BOOL v16 = (a4 & 0x3800000) == 0x1000000;
    BOOL v17 = (a4 & 0x700000) == 0x200000;
    if (a6)
    {
      BOOL v16 = 0;
      BOOL v18 = 0;
    }

    else
    {
      BOOL v18 = (a4 & 0x700000) == 0x200000;
    }

    if (a6) {
      BOOL v17 = 0;
    }
    goto LABEL_32;
  }

  icu::UCharsTrieBuilder::~UCharsTrieBuilder((icu::UCharsTrieBuilder *)&v68);
  icu::UCharsTrieBuilder::~UCharsTrieBuilder((icu::UCharsTrieBuilder *)v75);
  return v3;
}

  uint64_t v5 = v3 | v4;
  *a3 = v5;
  return v5 != v3;
}

  *(void *)a6 = off_18971B688;
  int v14 = 2LL;
  *((_WORD *)a6 + 4) = 2;
LABEL_23:
  icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)&v40);
  return icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v45);
}

  uint64_t result = icu::UMemory::operator new(v5, (icu::UMemory *)0x40, (unint64_t)a2);
  if (!result)
  {
    *((void *)this + 3) = 0LL;
LABEL_13:
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    return result;
  }

  *uint64_t result = (uint64_t)result + 13;
  *((_DWORD *)result + 2) = 40;
  *((_WORD *)result + 6) = 0;
  *((_DWORD *)result + 14) = 0;
  *((void *)this + 3) = result;
  if ((*(unsigned int (**)(void))(**((void **)this + 4) + 32LL))(*((void *)this + 4)))
  {
    int v6 = (icu::CharString *)*((void *)this + 3);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v19, "Infinity");
    __int16 v7 = (const char *)v19;
    uint64_t v8 = v20;
  }

  else
  {
    if (!(*(unsigned int (**)(void))(**((void **)this + 4) + 24LL))(*((void *)this + 4)))
    {
      if (!icu::number::impl::DecimalQuantity::isZeroish(*((icu::number::impl::DecimalQuantity **)this + 4)))
      {
        unsigned int v12 = *((_DWORD *)this + 10);
        if (v12 == 2
          || v12 == 5
          || icu::number::impl::DecimalQuantity::getMagnitude(*((icu::number::impl::DecimalQuantity **)this
                                                                            + 4)) != 0x80000000
          && ((Magnitude = icu::number::impl::DecimalQuantity::getMagnitude(*((icu::number::impl::DecimalQuantity **)this
                                                                            + 4)),
               Magnitude >= 0)
            ? (int v14 = Magnitude)
            : (int v14 = -Magnitude),
              v14 <= 4))
        {
          BOOL v15 = (icu::CharString *)*((void *)this + 3);
          icu::number::impl::DecimalQuantity::toPlainString( *((icu::number::impl::DecimalQuantity **)this + 4),  (uint64_t)v21);
        }

        else
        {
          BOOL v15 = (icu::CharString *)*((void *)this + 3);
          icu::number::impl::DecimalQuantity::toScientificString( *((icu::number::impl::DecimalQuantity **)this + 4),  (uint64_t)v21);
        }

        icu::CharString::appendInvariantChars(v15, (const icu::UnicodeString *)v21, a2);
        icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v21);
        return (uint64_t *)*((void *)this + 3);
      }

      uint64_t v11 = (icu::CharString *)*((void *)this + 3);
      __int16 v7 = "0";
      uint64_t v8 = -1;
      goto LABEL_17;
    }

    int v6 = (icu::CharString *)*((void *)this + 3);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v17, "NaN");
    __int16 v7 = v17;
    uint64_t v8 = v18;
  }

  uint64_t v11 = v6;
LABEL_17:
  icu::CharString::append(v11, v7, v8, a2);
  return (uint64_t *)*((void *)this + 3);
}

uint64_t sub_180879720(UChar *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4 = a2;
  size_t v6 = 2 * (int)a2 + 2;
  __int16 v7 = (UChar *)uprv_malloc(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    bzero(v7, v6);
    int v9 = 0;
    int v10 = v4 - 1;
    uint64_t v11 = 2LL * (int)v4 - 2;
    do
    {
      int v12 = *(UChar *)((char *)a1 + v11);
      ++v9;
      v11 -= 2LL;
    }

    while (v12 == 32);
    uint64_t v13 = (v4 - v9);
    int v14 = v9 - 1;
    if ((v13 & 0x80000000) == 0 && (int)v4 >= 1)
    {
      int v15 = v4 - 1;
      while (1)
      {
        if (v14 < 1)
        {
          LOWORD(v16) = a1[v13];
        }

        else
        {
          uint64_t v16 = a1[v13];
          if ((unsigned __int16)(v16 + 259) >= 0xFFF8u)
          {
            v8[v15--] = 1604;
            v8[v15] = word_180A2C4A2[v16 - 65269];
            --v14;
            goto LABEL_14;
          }
        }

        v8[v15] = v16;
LABEL_14:
        if ((int)v13 >= 1)
        {
          --v13;
          if (v15-- > 0) {
            continue;
          }
        }

        break;
      }
    }

    if (v14 >= 1)
    {
      u_memmove(v8, &v8[v14], v4);
      if (u_strlen(v8) < (int)v4)
      {
        int v18 = v4 - v14;
        memset_pattern16(&v8[(int)v4 - (v10 - v18) - 1], asc_180A2C4E0, 2LL * (v10 - v18) + 2);
      }
    }

    u_memcpy(a1, v8, v4);
    uprv_free(v8);
  }

  else
  {
    uint64_t v4 = 0LL;
    *a3 = 7;
  }

  return v4;
}

uint64_t sub_1808798CC(UChar *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4 = a2;
  size_t v6 = 2 * (int)a2 + 2;
  __int16 v7 = (UChar *)uprv_malloc(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    bzero(v7, v6);
    if (*a1 == 32)
    {
      uint64_t v9 = 0LL;
      do
        int v10 = a1[++v9];
      while (v10 == 32);
    }

    else
    {
      LODWORD(v9) = 0;
    }

    uint64_t v11 = (v4 - 1);
    if ((int)v4 >= 1)
    {
      int v12 = v4 - 1;
      while (1)
      {
        if ((int)v9 < 1)
        {
          LOWORD(v13) = a1[v11];
        }

        else
        {
          uint64_t v13 = a1[v11];
          if ((unsigned __int16)(v13 + 259) >= 0xFFF8u)
          {
            v8[v12--] = 1604;
            v8[v12] = word_180A2C4A2[v13 - 65269];
            LODWORD(v9) = v9 - 1;
            goto LABEL_17;
          }
        }

        v8[v12] = v13;
LABEL_17:
        BOOL v14 = v11-- < 1;
        if (!v14)
        {
          BOOL v14 = v12-- <= 0;
          if (!v14) {
            continue;
          }
        }

        break;
      }
    }

    u_memcpy(a1, v8, v4);
    uprv_free(v8);
  }

  else
  {
    uint64_t v4 = 0LL;
    *a3 = 7;
  }

  return v4;
}

uint64_t usprep_open(char *a1, const char *a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    unsigned int v8 = atomic_load(&dword_18C535100);
    if (v8 == 2 || !icu::umtx_initImplPreInit(&dword_18C535100))
    {
      if (dword_18C535104 >= 1)
      {
        uint64_t v4 = 0LL;
        *a3 = dword_18C535104;
        return v4;
      }
    }

    else
    {
      uint64_t v9 = uhash_open((uint64_t)sub_18087AA9C, (uint64_t)sub_18087AAD4, 0LL, a3);
      uint64_t v10 = *a3 >= 1 ? 0LL : (uint64_t)v9;
      qword_18C5350F8 = v10;
      sub_180820C94(1u, (uint64_t)sub_18087AB1C);
      dword_18C535104 = *a3;
      icu::umtx_initImplPostInit(&dword_18C535100);
    }

    if (*a3 <= 0)
    {
      v36[0] = a2;
      v36[1] = a1;
      umtx_lock((icu::UMutex *)&unk_18C535110);
      uint64_t v11 = uhash_get(qword_18C5350F8, (uint64_t)v36);
      if (v11)
      {
        uint64_t v4 = v11;
        ++*(_DWORD *)(v11 + 120);
        umtx_unlock((std::mutex **)&unk_18C535110);
        return v4;
      }

      umtx_unlock((std::mutex **)&unk_18C535110);
      int v12 = (uint64_t *)uprv_malloc(0x80uLL);
      uint64_t v13 = v12;
      if (!v12)
      {
        *a3 = 7;
LABEL_23:
        uprv_free(v13);
        return 0LL;
      }

      *((_OWORD *)v12 + 6) = 0u;
      *((_OWORD *)v12 + 7) = 0u;
      *((_OWORD *)v12 + 4) = 0u;
      *((_OWORD *)v12 + 5) = 0u;
      *((_OWORD *)v12 + 2) = 0u;
      *((_OWORD *)v12 + 3) = 0u;
      *(_OWORD *)int v12 = 0u;
      *((_OWORD *)v12 + sub_18086E18C((uint64_t)this, 1) = 0u;
      uprv_free(0LL);
      uint64_t v40 = 0LL;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      if (*a3 > 0) {
        goto LABEL_23;
      }
      BOOL v14 = udata_openChoice( a1,  "spp",  a2,  (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18087AC20,  0LL,  (UErrorCode *)a3);
      if (*a3 > 0) {
        goto LABEL_23;
      }
      int v15 = v14;
      *(_DWORD *)UVersionInfo versionArray = 0;
      uint64_t Memory = udata_getMemory((uint64_t)v14);
      utrie_unserialize((uint64_t)&v38, (_DWORD *)(Memory + 64), *(_DWORD *)Memory, a3);
      *(void *)&__int128 v39 = nullsub_21;
      if (*a3 > 0) {
        goto LABEL_26;
      }
      umtx_lock((icu::UMutex *)&unk_18C535110);
      uint64_t v17 = v13[14];
      if (v17)
      {
        uint64_t Memory = udata_getMemory(v17);
      }

      else
      {
        v13[14] = (uint64_t)v15;
        __int128 v18 = *(_OWORD *)Memory;
        __int128 v19 = *(_OWORD *)(Memory + 16);
        __int128 v20 = *(_OWORD *)(Memory + 48);
        *((_OWORD *)v13 + 2) = *(_OWORD *)(Memory + 32);
        *((_OWORD *)v13 + 3) = v20;
        *(_OWORD *)uint64_t v13 = v18;
        *((_OWORD *)v13 + sub_18086E18C((uint64_t)this, 1) = v19;
        __int128 v21 = v39;
        *((_OWORD *)v13 + 4) = v38;
        *((_OWORD *)v13 + 5) = v21;
        v13[12] = v40;
        int v15 = 0LL;
      }

      umtx_unlock((std::mutex **)&unk_18C535110);
      v13[13] = Memory + *(int *)v13 + 64;
      u_getUnicodeVersion(versionArray);
      if (*a3 > 0)
      {
LABEL_26:
        udata_close(v15);
        goto LABEL_23;
      }

      signed int v22 = bswap32(*(unsigned int *)versionArray);
      if (v22 < (int)bswap32(dword_18C535108) && v22 < *((_DWORD *)v13 + 2) && (*((_BYTE *)v13 + 28) & 1) != 0)
      {
        *a3 = 3;
        goto LABEL_26;
      }

      *((_BYTE *)v13 + 124) = 1;
      if (v15)
      {
        udata_close(v15);
        if (!*((_BYTE *)v13 + 124) || *a3 > 0) {
          goto LABEL_23;
        }
      }

      char v23 = *((_BYTE *)v13 + 28);
      *((_BYTE *)v13 + 125) = v23 & 1;
      *((_BYTE *)v13 + 126) = (v23 & 2) != 0;
      BOOL v24 = (char **)uprv_malloc(0x10uLL);
      int v35 = v24;
      if (v24)
      {
        *BOOL v24 = 0LL;
        v24[1] = 0LL;
        uprv_free(0LL);
        unsigned int v25 = strlen(a2);
        uint64_t v26 = 0LL;
        if (v25 <= 0x7FFFFFFE)
        {
          uint64_t v26 = (char *)uprv_malloc(v25 + 1);
          if (v26)
          {
            uprv_free(0LL);
            if (!a1)
            {
              size_t v34 = 0LL;
              goto LABEL_46;
            }

            unsigned int v27 = strlen(a1);
            if (v27 <= 0x7FFFFFFE)
            {
              size_t v34 = (char *)uprv_malloc(v27 + 1);
              if (v34)
              {
                uprv_free(0LL);
LABEL_46:
                umtx_lock((icu::UMutex *)&unk_18C535110);
                uint64_t v31 = uhash_get(qword_18C5350F8, (uint64_t)v36);
                if (v31)
                {
                  uint64_t v32 = (uint64_t *)v31;
                  ++*(_DWORD *)(v31 + 120);
                  udata_close((_OWORD *)v13[14]);
                  uint64_t v33 = v13;
                  uint64_t v13 = v32;
                }

                else
                {
                  *int v35 = v26;
                  strcpy(v26, a2);
                  if (a1)
                  {
                    v35[1] = v34;
                    strcpy(v34, a1);
                    size_t v34 = 0LL;
                  }

                  *((_DWORD *)v13 + 30) = 1;
                  uhash_put(qword_18C5350F8, (uint64_t)v35, (uint64_t)v13, a3);
                  uint64_t v26 = 0LL;
                  uint64_t v33 = 0LL;
                  int v35 = 0LL;
                }

                uint64_t v29 = v13;
                umtx_unlock((std::mutex **)&unk_18C535110);
                int v30 = 1;
                uint64_t v13 = v33;
                UChar v28 = v34;
LABEL_43:
                uprv_free(v28);
                uprv_free(v26);
                uprv_free(v35);
                uprv_free(v13);
                uint64_t v4 = (uint64_t)v29;
                if (v30) {
                  return v4;
                }
                return 0LL;
              }
            }
          }
        }
      }

      else
      {
        uint64_t v26 = 0LL;
      }

      *a3 = 7;
      udata_close((_OWORD *)v13[14]);
      UChar v28 = 0LL;
      uint64_t v29 = 0LL;
      int v30 = 0;
      goto LABEL_43;
    }
  }

  return 0LL;
}

uint64_t usprep_openByType(unsigned int a1, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0LL;
  }
  if (a1 >= 0xE)
  {
    *a2 = 1;
    return 0LL;
  }

  return usprep_open(0LL, off_18971C1C0[a1], a2);
}

void usprep_close(uint64_t a1)
{
  if (a1)
  {
    umtx_lock((icu::UMutex *)&unk_18C535110);
    int v2 = *(_DWORD *)(a1 + 120);
    BOOL v3 = __OFSUB__(v2, 1);
    int v4 = v2 - 1;
    if (v4 < 0 == v3) {
      *(_DWORD *)(a1 + 120) = v4;
    }
    umtx_unlock((std::mutex **)&unk_18C535110);
  }

UChar *uprv_syntaxError(UChar *result, int a2, int a3, uint64_t a4)
{
  if (a4)
  {
    __int16 v7 = result;
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = a2;
    int v8 = a2 - 15;
    if (a2 < 16) {
      int v8 = 0;
    }
    uint64_t v9 = a4 + 8;
    int v10 = a2 - v8;
    uint64_t result = u_memcpy((UChar *)(a4 + 8), &result[v8], a2 - v8);
    *(_WORD *)(v9 + 2LL * v10) = 0;
    int v11 = a2 + 15;
    if (a2 + 15 >= a3) {
      int v11 = a3;
    }
    if (a2 >= a3)
    {
      int32_t v13 = v11 - a2;
    }

    else
    {
      int v12 = &v7[a2];
      int32_t v13 = v11 - a2;
      uint64_t result = u_memcpy((UChar *)(a4 + 40), v12, v13);
    }

    *(_WORD *)(a4 + 2LL * v13 + 40) = 0;
  }

  return result;
}

uint64_t usprep_prepare(uint64_t a1, UChar *s, int a3, UChar *a4, int a5, char a6, uint64_t a7, int *a8)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  if (*a8 <= 0)
  {
    if (a1)
    {
      int32_t v15 = a3;
      if (s)
      {
        if (a3 < -1) {
          goto LABEL_31;
        }
      }

      else if (a3)
      {
        goto LABEL_31;
      }

      if (a4)
      {
        if ((a5 & 0x80000000) == 0) {
          goto LABEL_10;
        }
      }

      else if (!a5)
      {
LABEL_10:
        if (a3 < 0) {
          int32_t v15 = u_strlen(s);
        }
        __int128 v62 = 0u;
        uint64_t v65 = 0LL;
        __int128 v64 = 0u;
        __int128 v63 = 0u;
        signed int v61 = (UChar *)off_18971B688;
        LOWORD(v62) = 2;
        uint64_t Buffer = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v61, v15);
        if (Buffer)
        {
          if ((v62 & 2) != 0) {
            int v18 = 27;
          }
          else {
            int v18 = DWORD2(v62);
          }
          int v19 = sub_18087A52C(a1, s, v15, Buffer, v18, a6, a7, a8);
          int v20 = v19;
          if (*a8 <= 0) {
            int v21 = v19;
          }
          else {
            int v21 = 0;
          }
          icu::UnicodeString::releaseBuffer((uint64_t)&v61, v21);
          uint64_t v23 = *a8;
          if ((_DWORD)v23 != 15)
          {
LABEL_28:
            if ((int)v23 > 0)
            {
              uint64_t v8 = 0LL;
LABEL_102:
              icu::UnicodeString::~UnicodeString((void *)v23, (icu::UnicodeString *)&v61);
              return v8;
            }

            __int128 v57 = 0u;
            uint64_t v60 = 0LL;
            __int128 v59 = 0u;
            __int128 v58 = 0u;
            uint64_t v56 = (UChar *)off_18971B688;
            LOWORD(v57) = 2;
            if (*(_BYTE *)(a1 + 125))
            {
              v55[0] = off_18970BA28;
              v55[1] = icu::Normalizer2::getNFKCInstance((icu::Normalizer2 *)a8, v22);
              v55[2] = sub_180861384((UErrorCode *)a8);
              if (*a8 > 0)
              {
                icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v55);
LABEL_100:
                uint64_t v8 = 0LL;
                goto LABEL_101;
              }

              icu::FilteredNormalizer2::normalize( (icu::FilteredNormalizer2 *)v55,  (const icu::UnicodeString *)&v61,  (icu::UnicodeString *)&v56,  (UErrorCode *)a8);
              icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v55);
            }

            else
            {
              icu::UnicodeString::fastCopyFrom(&v56, &v61);
            }

            uint64_t v29 = (UChar **)*a8;
            if ((v57 & 0x11) != 0)
            {
              int v30 = 0LL;
            }

            else if ((v57 & 2) != 0)
            {
              int v30 = (UChar *)&v57 + 1;
            }

            else
            {
              int v30 = (UChar *)v58;
            }

            if ((v57 & 0x8000u) == 0LL) {
              int v31 = (unsigned __int16)v57 >> 5;
            }
            else {
              int v31 = DWORD1(v57);
            }
            if (v31 >= 1)
            {
              int v32 = 0;
              int v33 = 23;
              int v51 = -1;
              int v52 = 0;
              int v47 = -1;
              int v48 = 0;
              int v34 = 23;
              int v50 = v30;
              int v49 = v31;
              while (1)
              {
                uint64_t v35 = v32 + 1LL;
                unsigned int v36 = v30[v32];
                BOOL v37 = (v36 & 0xFC00) != 0xD800 || (_DWORD)v35 == v31;
                if (v37 || (unsigned int v38 = v30[v35], (v38 & 0xFC00) != 0xDC00))
                {
                  if ((v36 & 0xFC00) == 0xD800) {
                    int v41 = 320;
                  }
                  else {
                    int v41 = 0;
                  }
                  unsigned int v40 = *(unsigned __int16 *)(*(void *)(a1 + 64)
                                            + 2LL
                                            * ((v36 & 0x1F)
                                             + 4
                                             * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2LL * (v41 + (v36 >> 5)))));
                  int v42 = -1;
                  ++v32;
                }

                else
                {
                  v32 += 2;
                  unsigned int v36 = v38 + (v36 << 10) - 56613888;
                  if (v36 >= 0x110000)
                  {
                    unsigned int v40 = *(unsigned __int16 *)(a1 + 96);
                    int v42 = -2;
                  }

                  else
                  {
                    int v39 = (*(uint64_t (**)(void))(a1 + 80))(*(unsigned __int16 *)(*(void *)(a1 + 64)
                                                                                            + 2LL
                                                                                            * (((v36 >> 10) & 0x1F)
                                                                                             + 4
                                                                                             * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2LL * (((v36 >> 10) + 55232) >> 5)))));
                    if (v39 < 1) {
                      unsigned int v40 = *(unsigned __int16 *)(a1 + 96);
                    }
                    else {
                      unsigned int v40 = *(unsigned __int16 *)(*(void *)(a1 + 64)
                    }
                                                + 2LL
                                                * ((v38 & 0x1F)
                                                 + 4
                    int v42 = -2;
                    int v30 = v50;
                    int v31 = v49;
                  }
                }

                if (v40)
                {
                  if (v40 >> 4 <= 0xFFE)
                  {
                    if ((v40 & 1) != 0)
                    {
LABEL_91:
                      *a8 = 66560;
                      int v46 = v32 + v42;
                      goto LABEL_99;
                    }
                  }

                  else if (v40 == 65522)
                  {
                    goto LABEL_91;
                  }
                }

                if (*(_BYTE *)(a1 + 126))
                {
                  int Class = ubidi_getClass(v36);
                  int v34 = Class;
                  if (v33 == 23) {
                    int v33 = Class;
                  }
                  if (Class) {
                    int v44 = v52;
                  }
                  else {
                    int v44 = 1;
                  }
                  int v45 = v51;
                  if (!Class) {
                    int v45 = v32 - 1;
                  }
                  int v51 = v45;
                  int v52 = v44;
                  if (Class == 13 || Class == 1)
                  {
                    int v47 = v32 - 1;
                    int v48 = 1;
                  }

                  int v30 = v50;
                  int v31 = v49;
                }

                if (v32 >= v31) {
                  goto LABEL_85;
                }
              }
            }

            int v47 = -1;
            int v48 = 0;
            int v34 = 23;
            int v33 = 23;
            int v51 = -1;
            LOBYTE(v52) = 0;
LABEL_85:
            if (*(_BYTE *)(a1 + 126))
            {
              if ((_BYTE)v52 && v48)
              {
                *a8 = 66562;
                if (v47 <= v51) {
                  int v46 = v51;
                }
                else {
                  int v46 = v47;
                }
                goto LABEL_99;
              }

              if (v48 && (v33 != 13 && v33 != 1 || v34 != 1 && v34 != 13))
              {
                *a8 = 66562;
                int v46 = v47;
LABEL_99:
                uprv_syntaxError(v30, v46, v31, a7);
                goto LABEL_100;
              }
            }

            int v54 = a4;
            uint64_t v8 = icu::UnicodeString::extract((uint64_t)&v56, &v54, a5, a8);
            int v53 = v54;
            uint64_t v29 = &v53;
LABEL_101:
            icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v56);
            goto LABEL_102;
          }

          uint64_t v24 = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v61, v20);
          if (v24)
          {
            *a8 = 0;
            if ((v62 & 2) != 0) {
              int v25 = 27;
            }
            else {
              int v25 = DWORD2(v62);
            }
            int v26 = sub_18087A52C(a1, s, v15, v24, v25, a6, a7, a8);
            if (*a8 <= 0) {
              int v27 = v26;
            }
            else {
              int v27 = 0;
            }
            icu::UnicodeString::releaseBuffer((uint64_t)&v61, v27);
            uint64_t v23 = *a8;
            goto LABEL_28;
          }
        }

        uint64_t v8 = 0LL;
        uint64_t v23 = 7LL;
        *a8 = 7;
        goto LABEL_102;
      }
    }

uint64_t sub_18087A52C(uint64_t a1, UChar *a2, int a3, uint64_t a4, int a5, char a6, uint64_t a7, int *a8)
{
  if (a3 >= 1)
  {
    int v13 = 0;
    uint64_t v14 = 0LL;
    int v15 = a6 & 1;
    int v36 = v15;
    while (1)
    {
      uint64_t v16 = v13 + 1LL;
      unsigned int v17 = a2[v13];
      BOOL v18 = (v17 & 0xFC00) != 0xD800 || (_DWORD)v16 == a3;
      if (v18 || (unsigned int v19 = a2[v16], (v19 & 0xFC00) != 0xDC00))
      {
        int v22 = (v17 & 0xFC00) == 0xD800 ? 320 : 0;
        LOWORD(v2sub_18086E18C((uint64_t)this, 1) = *(_WORD *)(*(void *)(a1 + 64)
                               + 2LL
                               * ((v17 & 0x1F)
                                + 4 * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2LL * (v22 + (v17 >> 5)))));
        int v23 = -1;
        ++v13;
      }

      else
      {
        v13 += 2;
        unsigned int v17 = v19 + (v17 << 10) - 56613888;
        if (v17 >= 0x110000)
        {
          int v21 = *(_DWORD *)(a1 + 96);
          int v23 = -2;
        }

        else
        {
          int v20 = (*(uint64_t (**)(void, uint64_t))(a1 + 80))( *(unsigned __int16 *)(*(void *)(a1 + 64)
                                      + 2LL
                                      * (((v17 >> 10) & 0x1F)
                                       + 4
                                       * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2LL * (((v17 >> 10) + 55232) >> 5)))),
                  4238353408LL);
          if (v20 < 1) {
            int v21 = *(_DWORD *)(a1 + 96);
          }
          else {
            LOWORD(v2sub_18086E18C((uint64_t)this, 1) = *(_WORD *)(*(void *)(a1 + 64)
          }
                                   + 2LL
                                   * ((v19 & 0x1F)
                                    + 4
                                    * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2LL * (v20 + ((v19 >> 5) & 0x1F)))));
          int v23 = -2;
          int v15 = v36;
        }
      }

      unsigned int v24 = (unsigned __int16)v21;
      if (!(_WORD)v21) {
        break;
      }
      if ((unsigned __int16)v21 >> 4 >= 0xFFFu)
      {
        int v25 = (unsigned __int16)v21 - 65520;
LABEL_23:
        LOWORD(v26) = 0;
        int v27 = 0;
        goto LABEL_24;
      }

      int v26 = (__int16)v21 >> 2;
      if ((v24 & 2) != 0) {
        LOWORD(v26) = v24 >> 2;
      }
      if ((v24 & 0xFFFC) == 0xFEFC)
      {
        int v25 = 3;
        goto LABEL_23;
      }

      int v27 = (v24 & 2) >> 1;
      int v25 = 1;
LABEL_24:
      if (!(v25 | v15))
      {
        uprv_syntaxError(a2, v13 + v23, a3, a7);
        *a8 = 66561;
        return 0LL;
      }

      if (v25 != 3)
      {
        if (v25 != 1) {
          goto LABEL_34;
        }
        int v28 = (__int16)v26;
        if (!v27)
        {
          v17 -= (__int16)v26;
LABEL_34:
          if ((int)v17 >= 0x10000)
          {
            uint64_t v31 = (int)v14 + 1LL;
            if ((int)v31 < a5)
            {
              *(_WORD *)(a4 + 2LL * (int)v14) = (v17 >> 10) - 10304;
              *(_WORD *)(a4 + 2 * v3sub_18086E18C((uint64_t)this, 1) = v17 & 0x3FF | 0xDC00;
            }

            uint64_t v14 = (v14 + 2);
          }

          else
          {
            uint64_t v14 = (v14 + 1);
          }

          goto LABEL_55;
        }

        int v29 = *(_DWORD *)(a1 + 16);
        if (*(_DWORD *)(a1 + 12) <= (__int16)v26 && v29 > (__int16)v26)
        {
          uint64_t v30 = 1LL;
          goto LABEL_51;
        }

        int v32 = *(_DWORD *)(a1 + 20);
        if (v29 <= (__int16)v26 && v32 > (__int16)v26)
        {
          uint64_t v30 = 2LL;
          goto LABEL_51;
        }

        if (v32 <= (__int16)v26 && *(_DWORD *)(a1 + 24) > (__int16)v26)
        {
          uint64_t v30 = 3LL;
          goto LABEL_51;
        }

        uint64_t v30 = *(unsigned __int16 *)(*(void *)(a1 + 104) + 2LL * (__int16)v26);
        if (v30)
        {
          ++v28;
LABEL_51:
          uint64_t v14 = (int)v14;
          uint64_t v33 = 2LL * v28;
          do
          {
            if (v14 < a5) {
              *(_WORD *)(a4 + 2 * v14) = *(_WORD *)(*(void *)(a1 + 104) + v33);
            }
            ++v14;
            v33 += 2LL;
            --v30;
          }

          while (v30);
        }
      }

uint64_t usprep_swap( uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a3;
  uint64_t v38 = *MEMORY[0x1895F89C0];
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0LL;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x5000000053LL
    || *(_BYTE *)(a2 + 14) != 82
    || *(_BYTE *)(a2 + 15) != 80
    || *(_BYTE *)(a2 + 16) != 3)
  {
    udata_printError( a1,  (uint64_t)"usprep_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as StringPrep .spp data\n",  v14,  v15,  v16,  v17,  v18,  v19,  v21);
    uint64_t result = 0LL;
    int v24 = 16;
LABEL_15:
    *a5 = v24;
    return result;
  }

  int v22 = v13;
  if (a4) {
    int v23 = (unsigned int *)((char *)a4 + v13);
  }
  else {
    int v23 = 0LL;
  }
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t v10 = (v10 - v13);
    if ((int)v10 <= 63)
    {
      udata_printError( a1,  (uint64_t)"usprep_swap(): too few bytes (%d after header) for StringPrep .spp data\n",  v14,  v15,  v16,  v17,  v18,  v19,  v10);
LABEL_21:
      uint64_t result = 0LL;
      int v24 = 8;
      goto LABEL_15;
    }
  }

  uint64_t v25 = 0LL;
  int v26 = (unsigned int *)(a2 + v13);
  memset(v37, 0, sizeof(v37));
  do
  {
    *(_DWORD *)((char *)v37 + v25 * 4) = udata_readInt32(a1, v26[v25]);
    ++v25;
  }

  while (v25 != 16);
  uint64_t v33 = DWORD1(v37[0]);
  int v34 = v37[0];
  uint64_t v35 = SLODWORD(v37[0]) + 64LL;
  int v36 = v35 + DWORD1(v37[0]);
  if ((v10 & 0x80000000) == 0)
  {
    if ((int)v10 < v36)
    {
      udata_printError( a1,  (uint64_t)"usprep_swap(): too few bytes (%d after header) for all of StringPrep .spp data\n",  v27,  v28,  v29,  v30,  v31,  v32,  v10);
      goto LABEL_21;
    }

    if (v26 != v23) {
      memcpy(v23, v26, v36);
    }
    (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, v26, 64LL, v23, a5);
    utrie_swap(a1, v26 + 16, v34, (uint64_t)(v23 + 16), a5);
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 48))( a1,  (char *)v26 + v35,  v33,  (char *)v23 + v35,  a5);
  }

  return (v36 + v22);
}

uint64_t sub_18087AA9C(unsigned __int8 **a1)
{
  int v1 = a1[1];
  unsigned int v2 = uhash_hashChars(*a1);
  return v2 + 37 * uhash_hashChars(v1);
}

uint64_t sub_18087AAD4(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned int v2 = a1[1];
  BOOL v3 = a2[1];
  BOOL v4 = uhash_compareChars(*a1, *a2);
  return uhash_compareChars(v2, v3) & v4;
}

BOOL sub_18087AB1C()
{
  if (qword_18C5350F8)
  {
    int v8 = -1;
    umtx_lock((icu::UMutex *)&unk_18C535110);
    if (qword_18C5350F8)
    {
      uint64_t v0 = uhash_nextElement((uint64_t *)qword_18C5350F8, &v8);
      if (v0)
      {
        uint64_t v1 = v0;
        do
        {
          BOOL v3 = *(_OWORD ***)(v1 + 8);
          uint64_t v2 = *(void *)(v1 + 16);
          uhash_removeElement(qword_18C5350F8, (_DWORD *)v1);
          udata_close(v3[14]);
          if (*(void *)v2)
          {
            uprv_free(*(void **)v2);
            *(void *)uint64_t v2 = 0LL;
          }

          BOOL v4 = *(void **)(v2 + 8);
          if (v4)
          {
            uprv_free(v4);
            *(void *)(v2 + 8) = 0LL;
          }

          uprv_free(v3);
          uprv_free((void *)v2);
          uint64_t v1 = uhash_nextElement((uint64_t *)qword_18C5350F8, &v8);
        }

        while (v1);
      }
    }

    umtx_unlock((std::mutex **)&unk_18C535110);
    uint64_t v5 = qword_18C5350F8;
    if (qword_18C5350F8)
    {
      int v6 = uhash_count(qword_18C5350F8);
      uint64_t v5 = qword_18C5350F8;
      if (!v6)
      {
        uhash_close((_BYTE *)qword_18C5350F8);
        uint64_t v5 = 0LL;
        qword_18C5350F8 = 0LL;
      }
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  atomic_store(0, &dword_18C535100);
  return v5 == 0;
}

uint64_t sub_18087AC20(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  if (*a4 < 0x14u
    || *((_BYTE *)a4 + 4)
    || *((_BYTE *)a4 + 5)
    || *((_BYTE *)a4 + 8) != 83
    || *((_BYTE *)a4 + 9) != 80
    || *((_BYTE *)a4 + 10) != 82
    || *((_BYTE *)a4 + 11) != 80
    || *((_BYTE *)a4 + 12) != 3
    || *((_BYTE *)a4 + 14) != 5
    || *((_BYTE *)a4 + 15) != 2)
  {
    return 0LL;
  }

  dword_18C535108 = *((_DWORD *)a4 + 4);
  return 1LL;
}

void *icu::UStack::getStaticClassID(icu::UStack *this)
{
  return &unk_18C535160;
}

void *icu::UStack::getDynamicClassID(icu::UStack *this)
{
  return &unk_18C535160;
}

icu::UVector *icu::UStack::UStack(icu::UStack *this, UErrorCode *a2)
{
  uint64_t result = icu::UVector::UVector(this, a2);
  *(void *)uint64_t result = off_18971C240;
  return result;
}

{
  icu::UVector *result;
  uint64_t result = icu::UVector::UVector(this, a2);
  *(void *)uint64_t result = off_18971C240;
  return result;
}

void *icu::UStack::UStack(icu::UStack *this, unsigned int a2, UErrorCode *a3)
{
  uint64_t result = (void *)icu::UVector::UVector(this, a2, a3);
  *uint64_t result = off_18971C240;
  return result;
}

{
  void *result;
  uint64_t result = (void *)icu::UVector::UVector(this, a2, a3);
  *uint64_t result = off_18971C240;
  return result;
}

void *icu::UStack::UStack(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4);
  *uint64_t result = off_18971C240;
  return result;
}

{
  void *result;
  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4);
  *uint64_t result = off_18971C240;
  return result;
}

void *icu::UStack::UStack(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int *a5)
{
  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4, a5);
  *uint64_t result = off_18971C240;
  return result;
}

{
  void *result;
  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4, a5);
  *uint64_t result = off_18971C240;
  return result;
}

void icu::UStack::~UStack(void **this)
{
}

uint64_t icu::UStack::pop(icu::UStack *this)
{
  int v1 = *((_DWORD *)this + 2);
  if (v1 < 1) {
    return 0LL;
  }
  else {
    return icu::UVector::orphanElementAt(this, v1 - 1);
  }
}

uint64_t icu::UStack::popi(icu::UStack *this)
{
  int v1 = *((_DWORD *)this + 2);
  int v2 = v1 - 1;
  if (v1 < 1) {
    return 0LL;
  }
  uint64_t v4 = icu::UVector::elementAti(this, v1 - 1);
  icu::UVector::removeElementAt((uint64_t (**)(void))this, v2);
  return v4;
}

uint64_t icu::UStack::search(icu::UStack *this, uint64_t a2)
{
  uint64_t result = icu::UVector::indexOf(this, a2, 0LL);
  if ((result & 0x80000000) == 0) {
    return (*((_DWORD *)this + 2) - result);
  }
  return result;
}

uint64_t u_getDefaultConverter(UErrorCode *a1)
{
  uint64_t v2 = qword_18C535168;
  if (qword_18C535168)
  {
    qword_18C535168 = 0LL;
    umtx_unlock(0LL);
  }

  else
  {
    umtx_unlock(0LL);
    BOOL v3 = ucnv_open(0LL, a1);
    uint64_t v2 = (uint64_t)v3;
    if (*(int *)a1 >= 1)
    {
      ucnv_close(v3);
      return 0LL;
    }
  }

  return v2;
}

void u_releaseDefaultConverter(void *a1)
{
  if (qword_18C535168) {
    goto LABEL_5;
  }
  umtx_unlock(0LL);
  if (a1) {
    ucnv_reset((uint64_t)a1);
  }
  ucnv_enableCleanup();
  umtx_lock(0LL);
  if (qword_18C535168)
  {
LABEL_5:
    umtx_unlock(0LL);
    if (a1) {
      ucnv_close(a1);
    }
  }

  else
  {
    qword_18C535168 = (uint64_t)a1;
    umtx_unlock(0LL);
  }

void u_flushDefaultConverter()
{
  if (qword_18C535168)
  {
    umtx_lock(0LL);
    uint64_t v0 = (void *)qword_18C535168;
    if (qword_18C535168)
    {
      qword_18C535168 = 0LL;
      umtx_unlock(0LL);
      ucnv_close(v0);
    }

    else
    {
      umtx_unlock(0LL);
    }
  }

UChar *__cdecl u_uastrncpy(UChar *dst, const char *src, int32_t n)
{
  uint64_t v15 = dst;
  uint64_t v16 = src;
  int v14 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v14);
  BOOL v7 = v14 > 0 || DefaultConverter == 0;
  int v8 = dst;
  if (v7) {
    goto LABEL_18;
  }
  uint64_t v9 = (void *)DefaultConverter;
  ucnv_reset(DefaultConverter);
  int32_t v10 = 0;
  if (n && src)
  {
    uint64_t v11 = 0LL;
    int32_t v10 = n;
    while (src[v11])
    {
      if (n == (_DWORD)++v11) {
        goto LABEL_12;
      }
    }

    int32_t v10 = v11;
  }

UChar *__cdecl u_uastrcpy(UChar *dst, const char *src)
{
  int v9 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v9);
  BOOL v5 = v9 > 0 || DefaultConverter == 0;
  if (v5
    || (int v6 = (void *)DefaultConverter,
        int v7 = strlen(src),
        ucnv_toUChars((uint64_t)v6, (unint64_t)dst, 0xFFFFFFF, src, v7, &v9),
        u_releaseDefaultConverter(v6),
        v9 >= 1))
  {
    *dst = 0;
  }

  return dst;
}

char *__cdecl u_austrncpy(char *dst, const UChar *src, int32_t n)
{
  uint64_t v15 = dst;
  uint64_t v16 = src;
  int v14 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v14);
  BOOL v7 = v14 > 0 || DefaultConverter == 0;
  int v8 = dst;
  if (v7) {
    goto LABEL_18;
  }
  int v9 = (void *)DefaultConverter;
  ucnv_reset(DefaultConverter);
  int32_t v10 = 0;
  if (n && src)
  {
    uint64_t v11 = 0LL;
    int32_t v10 = n;
    while (src[v11])
    {
      if (n == (_DWORD)++v11) {
        goto LABEL_12;
      }
    }

    int32_t v10 = v11;
  }

char *__cdecl u_austrcpy(char *dst, const UChar *src)
{
  int v10 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v10);
  BOOL v5 = v10 > 0 || DefaultConverter == 0;
  int v6 = dst;
  if (!v5)
  {
    BOOL v7 = (void *)DefaultConverter;
    int v8 = ucnv_fromUChars(DefaultConverter, (unint64_t)dst, 0xFFFFFFF, src, -1, &v10);
    u_releaseDefaultConverter(v7);
    int v6 = &dst[v8];
  }

  *int v6 = 0;
  return dst;
}

void *sub_18087B2E0()
{
  return &unk_18C535170;
}

void sub_18087B2F0(icu::BreakIterator *a1)
{
}

uint64_t sub_18087B304()
{
  return 0LL;
}

uint64_t sub_18087B30C()
{
  return 0LL;
}

void sub_18087B314()
{
}

uint64_t sub_18087B320(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0) {
    *a3 = 16;
  }
  return 0LL;
}

uint64_t sub_18087B33C(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  int v3 = (__int16)v2;
  unsigned int v4 = v2 >> 5;
  if (v3 < 0) {
    unsigned int v4 = *(_DWORD *)(a2 + 12);
  }
  *(_DWORD *)(result + 484) = v4;
  return result;
}

int64_t sub_18087B35C(int64_t result, UText *ut, int *a3)
{
  if (*a3 <= 0)
  {
    uint64_t v4 = result;
    uint64_t result = utext_nativeLength(ut);
    if (result > 0x7FFFFFFF) {
      *a3 = 8;
    }
    else {
      *(_DWORD *)(v4 + 484) = result;
    }
  }

  return result;
}

void sub_18087B3AC()
{
}

uint64_t sub_18087B3B8()
{
  return 0LL;
}

uint64_t sub_18087B3C0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18087B3C8()
{
  return 0LL;
}

uint64_t sub_18087B3D0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18087B3D8()
{
  return 0LL;
}

uint64_t sub_18087B3E0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18087B3E8()
{
  return 0LL;
}

uint64_t sub_18087B3F0()
{
  return 0LL;
}

uint64_t sub_18087B3F8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18087B400(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0) {
    *a4 = 16;
  }
  return 0LL;
}

void sub_18087B41C(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0) {
    *a3 = 16;
  }
}

uint64_t sub_18087B438( icu::Locale *a1, const char *a2, char a3, uint64_t a4, uint64_t *a5, const icu::Locale *a6)
{
  v18[28] = *(char **)MEMORY[0x1895F89C0];
  uint64_t v6 = a4;
  int v9 = a3 & 0xE0;
  if ((a3 & 0xE0) != 0 && a4)
  {
    uint64_t v6 = 0LL;
    *(_DWORD *)a6 = 1;
    return v6;
  }

  if (a4) {
    return v6;
  }
  if (v9 == 64)
  {
    if (a1) {
      icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a1);
    }
    else {
      icu::Locale::Locale((icu::Locale *)v18, a2, 0LL, 0LL, 0LL);
    }
    Sentenceuint64_t Instance = icu::BreakIterator::createSentenceInstance(v18, a6, v12, v13);
    goto LABEL_21;
  }

  if (v9 != 32)
  {
    if ((a3 & 0xE0) == 0)
    {
      if (a1) {
        icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a1);
      }
      else {
        icu::Locale::Locale((icu::Locale *)v18, a2, 0LL, 0LL, 0LL);
      }
      Sentenceuint64_t Instance = icu::BreakIterator::createWordInstance(v18, a6, v10, v11);
LABEL_21:
      uint64_t v6 = (uint64_t)SentenceInstance;
      icu::Locale::~Locale((icu::Locale *)v18);
      goto LABEL_24;
    }

    uint64_t v6 = 0LL;
    int v15 = 1;
LABEL_23:
    *(_DWORD *)a6 = v15;
    goto LABEL_24;
  }

  uint64_t v14 = icu::UMemory::operator new((icu::UMemory *)0x1E8, (unint64_t)a2);
  uint64_t v6 = v14;
  if (!v14)
  {
    int v15 = 7;
    goto LABEL_23;
  }

  icu::BreakIterator::BreakIterator(v14);
  *(void *)uint64_t v6 = &off_18971C280;
  *(_DWORD *)(v6 + 484) = 0;
LABEL_24:
  if (*a5) {
    (*(void (**)(uint64_t))(*(void *)*a5 + 8LL))(*a5);
  }
  *a5 = v6;
  return v6;
}

uint64_t icu::CaseMap::toTitle( char *a1, uint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, unint64_t a6, uint64_t a7, icu::Edits *a8, const icu::Locale *a9)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v23 = 0LL;
  uint64_t v16 = sub_18087B438(0LL, a1, a2, a3, &v23, a9);
  if (v16)
  {
    uint64_t v17 = v16;
    memset(v24, 0, sizeof(v24));
    int v22 = a4;
    icu::UnicodeString::UnicodeString(v24, a5 >> 31, &v22);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)v17 + 56LL))(v17, v24);
    uint64_t v18 = sub_18087DD70((unsigned __int8 *)a1);
    uint64_t v19 = sub_18087D254( v18,  a2,  v17,  a6,  a7,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18087BA30,  a8,  (int *)a9);
    icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v24);
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
  }
  return v19;
}

int32_t u_strToTitle( UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UBreakIterator *titleIter, const char *locale, UErrorCode *pErrorCode)
{
  uint64_t v9 = *(void *)&srcLength;
  uint64_t v11 = *(void *)&destCapacity;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v20 = 0LL;
  uint64_t v13 = sub_18087B438(0LL, locale, 0, (uint64_t)titleIter, &v20, (const icu::Locale *)pErrorCode);
  if (v13)
  {
    uint64_t v14 = v13;
    memset(v21, 0, sizeof(v21));
    uint64_t v19 = src;
    icu::UnicodeString::UnicodeString(v21, v9 >> 31, &v19);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)v14 + 56LL))(v14, v21);
    uint64_t v15 = sub_18087DD70((unsigned __int8 *)locale);
    int32_t v16 = sub_18087D3A0( v15,  0LL,  v14,  dest,  v11,  (UChar *)src,  v9,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, int *))sub_18087BA30,  (int *)pErrorCode);
    icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v21);
  }

  else
  {
    int32_t v16 = 0;
  }

  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  return v16;
}

uint64_t ucasemap_toTitle( uint64_t *a1, unint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, const icu::Locale *a6)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    if (!*a1)
    {
      *(void *)&v16[0] = 0LL;
      if (!sub_18087B438(0LL, (const char *)a1 + 8, *((_DWORD *)a1 + 11), 0LL, (uint64_t *)v16, a6))
      {
        if (*(void *)&v16[0]) {
          (*(void (**)(void))(**(void **)&v16[0] + 8LL))();
        }
        return 0LL;
      }

      *a1 = *(void *)&v16[0];
    }

    memset(v16, 0, sizeof(v16));
    uint64_t v15 = a4;
    icu::UnicodeString::UnicodeString(v16, a5 >> 31, &v15);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)*a1 + 56LL))(*a1, v16);
    uint64_t v6 = sub_18087D254( *((unsigned int *)a1 + 10),  *((unsigned int *)a1 + 11),  *a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18087BA30,  0LL,  (int *)a6);
    icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v16);
    return v6;
  }

  return 0LL;
}

__int32 *__cdecl u_strToWCS( __int32 *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  if (src) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = srcLength == 0;
  }
  char v7 = !v6;
  if (destCapacity < 0 || srcLength < -1 || (v7 & 1) != 0 || !dest && destCapacity)
  {
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0LL;
  }

  return u_strToUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode);
}

UChar *__cdecl u_strFromWCS( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const __int32 *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  if (src) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = srcLength == 0;
  }
  char v7 = !v6;
  if (destCapacity < 0 || srcLength < -1 || (v7 & 1) != 0 || !dest && destCapacity)
  {
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0LL;
  }

  return u_strFromUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode);
}

uint64_t sub_18087BA30( int a1, int a2, void *a3, uint64_t a4, int a5, uint64_t a6, int a7, icu::Edits *a8, int *a9)
{
  uint64_t v9 = a9;
  if (*a9 > 0) {
    return 0LL;
  }
  __int16 v11 = a2;
  if ((~a2 & 0x600) == 0)
  {
    uint64_t v10 = 0LL;
    int v12 = 1;
    goto LABEL_141;
  }

  int v13 = a7;
  uint64_t v63 = 0LL;
  v61[0] = a6;
  v61[1] = 0LL;
  uint64_t v62 = a7;
  if (a7 < 1)
  {
    uint64_t v10 = 0LL;
    goto LABEL_135;
  }

  uint64_t v15 = a3;
  LODWORD(v16) = 0;
  uint64_t v10 = 0LL;
  uint64_t v17 = 10LL;
  while (2)
  {
    int v18 = v16;
    int v19 = (*(uint64_t (**)(void *))(*v15 + 8 * v17))(v15);
    if (v19 > v13 || v19 == -1) {
      uint64_t v16 = v13;
    }
    else {
      uint64_t v16 = v19;
    }
    uint64_t v21 = v18 + 1LL;
    uint64_t v22 = (const UChar *)(a6 + 2LL * v18);
    unsigned int v23 = *v22;
    if ((v23 & 0xFC00) != 0xD800 || (_DWORD)v21 == (_DWORD)v16)
    {
      if ((v11 & 0x200) != 0) {
        goto LABEL_20;
      }
    }

    else
    {
      int v27 = *(unsigned __int16 *)(a6 + 2 * v21);
      BOOL v28 = (v27 & 0xFC00) == 56320;
      unsigned int v29 = (v23 << 10) - 56613888 + v27;
      if (v28) {
        uint64_t v21 = (v18 + 2);
      }
      else {
        uint64_t v21 = v21;
      }
      if (v28) {
        unsigned int v23 = v29;
      }
      if ((v11 & 0x200) != 0)
      {
LABEL_20:
        int v25 = v18;
        uint64_t v26 = v21;
        goto LABEL_52;
      }
    }

    int v25 = v18;
    while (1)
    {
      uint64_t v26 = v21;
      unsigned int v30 = v23;
      if ((v11 & 0x400) == 0)
      {
        int v31 = u_charType(v23);
        if (((1 << v31) & 0xF020E2E) != 0) {
          goto LABEL_42;
        }
        if (v31 != 4) {
          goto LABEL_34;
        }
        unsigned int v30 = v23;
      }

uint64_t sub_18087C080(uint64_t *a1, int a2)
{
  if (a2 < 0)
  {
    int v2 = *((_DWORD *)a1 + 5);
    *((_DWORD *)a1 + 3) = v2;
    *((_BYTE *)a1 + 28) = a2;
  }

  else
  {
    if (a2)
    {
      int v2 = *((_DWORD *)a1 + 6);
      *((_DWORD *)a1 + 3) = v2;
      *((_BYTE *)a1 + 28) = a2;
      goto LABEL_14;
    }

    int v2 = *((_DWORD *)a1 + 3);
    if ((*((char *)a1 + 28) & 0x80000000) == 0)
    {
LABEL_14:
      int v11 = *((_DWORD *)a1 + 4);
      if (v2 < v11)
      {
        uint64_t v12 = *a1;
        uint64_t v13 = v2 + 1LL;
        *((_DWORD *)a1 + 3) = v13;
        uint64_t v6 = *(unsigned __int16 *)(v12 + 2LL * v2);
        if ((v6 & 0xFC00) == 0xD800 && (_DWORD)v13 != v11)
        {
          int v15 = *(unsigned __int16 *)(v12 + 2 * v13);
          if ((v15 & 0xFC00) == 0xDC00)
          {
            *((_DWORD *)a1 + 3) = v2 + 2;
            int v10 = v15 + ((_DWORD)v6 << 10);
            return (v10 - 56613888);
          }
        }

        return v6;
      }

      return 0xFFFFFFFFLL;
    }
  }

  int v3 = *((_DWORD *)a1 + 2);
  if (v3 >= v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *a1;
  uint64_t v5 = v2 - 1LL;
  *((_DWORD *)a1 + 3) = v5;
  uint64_t v6 = *(unsigned __int16 *)(v4 + 2 * v5);
  if ((int)v5 > v3 && (v6 & 0xFC00) == 56320)
  {
    uint64_t v8 = v2 - 2LL;
    int v9 = *(unsigned __int16 *)(v4 + 2 * v8);
    if ((v9 & 0xFC00) == 0xD800)
    {
      *((_DWORD *)a1 + 3) = v8;
      int v10 = v6 + (v9 << 10);
      return (v10 - 56613888);
    }
  }

  return v6;
}

uint64_t sub_18087C17C( uint64_t a1, uint64_t a2, int a3, unsigned int a4, __int16 *a5, unsigned int a6, __int16 a7, icu::Edits *this)
{
  int v10 = a4;
  if ((a4 & 0x80000000) != 0)
  {
    if (this) {
      icu::Edits::addUnchanged(this, a6);
    }
    if ((a7 & 0x4000) != 0) {
      return a2;
    }
    unsigned int v14 = ~v10;
    int v10 = a6;
    goto LABEL_20;
  }

  if (a4 < 0x20)
  {
    unsigned int v14 = -1;
    if (!this) {
      goto LABEL_20;
    }
LABEL_19:
    icu::Edits::addReplace(this, a6, v10);
    goto LABEL_20;
  }

  if ((int)a2 >= a3 || HIWORD(a4))
  {
    unsigned int v14 = a4;
    if (a4 < 0x10000) {
      int v10 = 1;
    }
    else {
      int v10 = 2;
    }
    if (this) {
      goto LABEL_19;
    }
LABEL_20:
    if ((v14 & 0x80000000) == 0)
    {
      if (!HIWORD(v14))
      {
LABEL_25:
        uint64_t v16 = (a2 + 1);
        *(_WORD *)(a1 + 2LL * (int)a2) = v14;
        return v16;
      }

      if (HIWORD(v14) <= 0x10u)
      {
        uint64_t v20 = (int)a2 + 1LL;
        if ((int)v20 < a3)
        {
          *(_WORD *)(a1 + 2LL * (int)a2) = (v14 >> 10) - 10304;
          uint64_t v16 = (a2 + 2);
          *(_WORD *)(a1 + 2 * v20) = v14 & 0x3FF | 0xDC00;
          return v16;
        }
      }

      return (v10 + a2);
    }

    uint64_t v16 = (v10 + a2);
    if (v10 >= 1)
    {
      uint64_t v17 = (_WORD *)(a1 + 2LL * (int)a2);
      unsigned int v18 = v10 + 1;
      do
      {
        __int16 v19 = *a5++;
        *v17++ = v19;
        --v18;
      }

      while (v18 > 1);
      return v16;
    }

    return a2;
  }

  uint64_t v16 = (a2 + 1);
  *(_WORD *)(a1 + 2LL * (int)a2) = a4;
  if (this) {
    icu::Edits::addReplace(this, a6, 1);
  }
  return v16;
}

uint64_t sub_18087C314( int a1, __int16 a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, icu::Edits *a9, _DWORD *a10)
{
  if (a1 == 1) {
    goto LABEL_4;
  }
  if (a1 < 0)
  {
    if ((a2 & 7) == 0) {
      goto LABEL_4;
    }
  }

  else if ((a1 & 0xFFFFFFFE) != 2)
  {
LABEL_4:
    uint64_t v13 = &unk_1809F9F66;
    goto LABEL_7;
  }

  uint64_t v13 = &unk_1809FA0E6;
LABEL_7:
  signed int v38 = v13;
  int v37 = sub_180817CFC();
  uint64_t v14 = 0LL;
  LODWORD(v15) = a7;
  while (2)
  {
    if ((int)v15 >= a8)
    {
      LOWORD(v18) = 0;
      LODWORD(v16) = v15;
      goto LABEL_43;
    }

    LODWORD(v16) = v15;
    uint64_t v17 = a7;
    while (1)
    {
      unint64_t v18 = *(unsigned __int16 *)(a5 + 2LL * (int)v16);
      if (v18 <= 0x17E)
      {
        int v19 = (char)v38[v18];
        if (v19 == -128) {
          break;
        }
        uint64_t v16 = (v16 + 1);
        a7 = v16;
        if (v38[v18]) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }

      unsigned int v20 = *((unsigned __int16 *)*v37
      if ((v20 & 8) != 0) {
        break;
      }
      uint64_t v16 = (v16 + 1);
      if (v20 >= 0x80 && (v20 & 2) != 0)
      {
        int v19 = (__int16)v20 >> 7;
        a7 = v16;
LABEL_22:
        int32_t v22 = a7 + ~(_DWORD)v17;
        if (v22 < 1) {
          goto LABEL_29;
        }
        if (a9) {
          icu::Edits::addUnchanged(a9, a7 + ~(_DWORD)v17);
        }
        if ((a2 & 0x4000) != 0)
        {
LABEL_29:
          int v23 = v14;
        }

        else
        {
          int v23 = v22 + v14;
        }

        if (v23 < 0) {
          goto LABEL_73;
        }
        LOWORD(v18) = v19 + v18;
        if (v23 < a4)
        {
          *(_WORD *)(a3 + 2LL * v23) = v18;
          goto LABEL_36;
        }

        if (v23 == 0x7FFFFFFF)
        {
          uint64_t v14 = 0xFFFFFFFFLL;
          if (!a9)
          {
LABEL_38:
            LODWORD(v16) = a7;
            if ((v14 & 0x80000000) != 0) {
              goto LABEL_73;
            }
            goto LABEL_39;
          }
        }

        else
        {
LABEL_36:
          uint64_t v14 = (v23 + 1);
          if (!a9) {
            goto LABEL_38;
          }
        }

        icu::Edits::addReplace(a9, 1, 1);
        goto LABEL_38;
      }

uint64_t sub_18087C6C8(unsigned int a1)
{
  if (a1 - 8487 < 0xFFFFE249 || (a1 - 1024) >> 8 < 0x1B) {
    return 0LL;
  }
  if (a1 <= 0x3FF) {
    return word_180A2C524[a1 - 880];
  }
  if (!(a1 >> 13)) {
    return word_180A2C644[a1 - 7936];
  }
  if (a1 == 8486) {
    return 5033LL;
  }
  return 0LL;
}

uint64_t sub_18087C740(int a1)
{
  uint64_t result = 0x4000LL;
  if ((a1 - 768) <= 0x14)
  {
    if (((1 << a1) & 0x2000F) != 0) {
      return result;
    }
    if (((1 << a1) & 0x180050) != 0) {
      return 0x20000LL;
    }
    if (a1 == 776) {
      return 0x10000LL;
    }
  }

  switch(a1)
  {
    case 834:
      return result;
    case 835:
      return 0x20000LL;
    case 836:
      uint64_t result = 81920LL;
      break;
    case 837:
      uint64_t result = 0x2000LL;
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

BOOL sub_18087C7D4(uint64_t a1, int a2, int a3)
{
  while (a2 < a3)
  {
    uint64_t v5 = a2 + 1LL;
    unsigned int v6 = *(unsigned __int16 *)(a1 + 2LL * a2);
    if ((v6 & 0xFC00) == 0xD800 && (_DWORD)v5 != a3)
    {
      int v8 = *(unsigned __int16 *)(a1 + 2 * v5);
      BOOL v9 = (v8 & 0xFC00) == 56320;
      int v10 = v8 + (v6 << 10) - 56613888;
      if (v9) {
        LODWORD(v5) = a2 + 2;
      }
      if (v9) {
        unsigned int v6 = v10;
      }
    }

    int TypeOrIgnorable = ucase_getTypeOrIgnorable(v6);
    a2 = v5;
    if ((TypeOrIgnorable & 4) == 0) {
      return TypeOrIgnorable != 0;
    }
  }

  return 0LL;
}

uint64_t sub_18087C874(__int16 a1, uint64_t a2, int a3, uint64_t a4, int a5, icu::Edits *a6, _DWORD *a7)
{
  if (a5 < 1) {
    return 0LL;
  }
  int v7 = a5;
  LODWORD(v10) = 0;
  char v11 = 0;
  uint64_t v12 = 0LL;
  BOOL v14 = (a1 & 0x4000) == 0 && a6 == 0LL;
  BOOL v59 = v14;
  uint64_t v65 = a5;
  while (1)
  {
    uint64_t v15 = (int)v10;
    uint64_t v16 = (int)v10 + 1LL;
    unsigned int v17 = *(unsigned __int16 *)(a4 + 2LL * (int)v10);
    BOOL v18 = (v17 & 0xFC00) != 0xD800 || (_DWORD)v16 == v7;
    LODWORD(v10) = v10 + 1;
    if (!v18)
    {
      int v19 = *(unsigned __int16 *)(a4 + 2 * v16);
      BOOL v20 = (v19 & 0xFC00) == 56320;
      int v21 = v19 + (v17 << 10) - 56613888;
      LODWORD(v10) = v20 ? v15 + 2 : v16;
      if (v20) {
        unsigned int v17 = v21;
      }
    }

    uint64_t v64 = v15;
    int TypeOrIgnorable = ucase_getTypeOrIgnorable(v17);
    char v23 = v11;
    int v24 = v11 & 1;
    char v25 = TypeOrIgnorable != 0;
    if ((TypeOrIgnorable & 4) != 0) {
      char v25 = v11 & 1;
    }
    char v63 = v25;
    unsigned int v26 = sub_18087C6C8(v17);
    if (!v26)
    {
      *(void *)uint64_t v66 = 0LL;
      unsigned int v34 = ucase_toFullUpper(v17, 0LL, 0LL, v66, 4);
      uint64_t v35 = sub_18087C17C(a2, v12, a3, v34, *(__int16 **)v66, (int)v10 - (int)v64, a1, a6);
      if ((v35 & 0x80000000) != 0) {
        break;
      }
      uint64_t v12 = v35;
      char v11 = v63;
      goto LABEL_113;
    }

    unsigned int v27 = v26;
    int v28 = v26 & 0x3FF;
    if ((v26 & 0x1000) != 0 && (v23 & 6) != 0 && (v28 == 933 || v28 == 921))
    {
      if ((v23 & 4) != 0) {
        int v29 = 0x8000;
      }
      else {
        int v29 = 0x10000;
      }
      unsigned int v27 = v26 | v29;
    }

    int v30 = (v27 >> 13) & 1;
    if ((int)v10 >= v7)
    {
      unsigned int v32 = v27;
    }

    else
    {
      int v31 = v26 & 0x3FF;
      uint64_t v10 = (int)v10;
      unsigned int v32 = v27;
      while (1)
      {
        unsigned int v33 = sub_18087C740(*(unsigned __int16 *)(a4 + 2 * v10));
        if (!v33) {
          break;
        }
        v32 |= v33;
        v30 += (v33 >> 13) & 1;
        if (v65 == ++v10)
        {
          LODWORD(v10) = v65;
          break;
        }
      }

      int v28 = v31;
    }

    if ((v27 & 0x4000) != 0) {
      char v36 = 4;
    }
    else {
      char v36 = 2;
    }
    if ((v32 & 0xD000) == 0x5000) {
      char v37 = v36;
    }
    else {
      char v37 = 0;
    }
    if (v28 != 919
      || (v32 & 0x4000) == 0
      || v30
      || v24
      || (v38 = v28, v39 = v37, v40 = sub_18087C7D4(a4, v10, a5), v37 = v39, int v28 = v38, v40))
    {
      if ((v32 & 0x8000) != 0)
      {
        uint64_t v43 = v64;
        if (v28 == 933)
        {
          unsigned int v32 = 0;
          BOOL v41 = 0;
          LOBYTE(v42) = 1;
          int v28 = 939;
        }

        else if (v28 == 921)
        {
          unsigned int v32 = 0;
          BOOL v41 = 0;
          LOBYTE(v42) = 1;
          int v28 = 938;
        }

        else
        {
          BOOL v41 = 0;
          LOBYTE(v42) = 1;
        }
      }

      else
      {
        BOOL v41 = 0;
        LOBYTE(v42) = 1;
        uint64_t v43 = v64;
      }
    }

    else
    {
      int v42 = (unsigned __int16)(v27 & 0x4000) >> 14;
      if ((v27 & 0x4000) != 0) {
        int v28 = 905;
      }
      else {
        int v28 = 919;
      }
      uint64_t v43 = v64;
      BOOL v41 = (v27 & 0x4000) == 0;
    }

    char v11 = v37 | v63;
    if (!v59)
    {
      char v45 = v28 != *(unsigned __int16 *)(a4 + 2 * v43) || v30 != 0;
      if ((v32 & 0x18000) != 0)
      {
        BOOL v46 = (int)v16 >= (int)v10 || *(_WORD *)(a4 + 2LL * (int)v16) != 776;
        v45 |= v46;
        LODWORD(v16) = v43 + 2;
      }

      if ((v42 & 1) == 0)
      {
        BOOL v47 = (int)v16 >= (int)v10 || *(_WORD *)(a4 + 2LL * (int)v16) != 769;
        v45 |= v47;
        LODWORD(v16) = v16 + 1;
      }

      unsigned int v48 = v10 - v43;
      int v49 = v16 - v43 + v30;
      if ((v45 & 1) != 0 || v48 != v49)
      {
        if (a6)
        {
          __int16 v51 = v28;
          icu::Edits::addReplace(a6, v48, v49);
          LOWORD(v28) = v51;
        }
      }

      else
      {
        if (a6)
        {
          __int16 v50 = v28;
          icu::Edits::addUnchanged(a6, v48);
          LOWORD(v28) = v50;
        }

        if ((a1 & 0x4000) != 0) {
          goto LABEL_113;
        }
      }
    }

    if ((int)v12 >= a3)
    {
      if ((_DWORD)v12 == 0x7FFFFFFF) {
        break;
      }
    }

    else
    {
      *(_WORD *)(a2 + 2LL * (int)v12) = v28;
    }

    uint64_t v52 = (v12 + 1);
    if ((int)v12 >= -1 && (v32 & 0x18000) != 0)
    {
      if ((int)v52 >= a3)
      {
        if ((_DWORD)v12 == 2147483646) {
          break;
        }
      }

      else
      {
        *(_WORD *)(a2 + 2LL * v52) = 776;
      }

      uint64_t v52 = (v12 + 2);
    }

    char v53 = !v41;
    if ((v53 & 1) == 0)
    {
      if ((int)v52 >= a3)
      {
        if ((_DWORD)v52 == 0x7FFFFFFF) {
          break;
        }
      }

      else
      {
        *(_WORD *)(a2 + 2LL * v52) = 769;
      }

      uint64_t v52 = (v52 + 1);
    }

    if ((v52 & 0x80000000) != 0 || v30 < 1)
    {
      uint64_t v12 = v52;
    }

    else
    {
      int v54 = (_WORD *)(a2 + 2LL * (int)v52);
      do
      {
        if ((int)v52 >= a3)
        {
          if ((_DWORD)v52 == 0x7FFFFFFF) {
            goto LABEL_115;
          }
        }

        else
        {
          *int v54 = 921;
        }

        uint64_t v12 = (v52 + 1);
        ++v54;
        LODWORD(v52) = v52 + 1;
      }

      while (v30-- > 1);
    }

    if ((v12 & 0x80000000) != 0) {
      break;
    }
LABEL_113:
    int v7 = a5;
  }

LABEL_115:
  uint64_t v12 = 0LL;
  *a7 = 8;
  return v12;
}

uint64_t sub_18087CD1C( int a1, __int16 a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, unsigned int a7, icu::Edits *a8, UErrorCode *a9)
{
  void v14[3] = 0LL;
  v14[0] = a6;
  v14[1] = 0LL;
  v14[2] = a7;
  uint64_t v11 = sub_18087C314(a1, a2, a4, a5, a6, (uint64_t)v14, 0LL, a7, a8, a9);
  uint64_t v12 = v11;
  if (*(int *)a9 <= 0)
  {
    if ((int)v11 <= a5)
    {
      if (a8) {
        icu::Edits::copyErrorTo(a8, a9);
      }
    }

    else
    {
      *a9 = U_BUFFER_OVERFLOW_ERROR;
    }
  }

  return v12;
}

uint64_t sub_18087CDB8( int a1, __int16 a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, icu::Edits *a8, UErrorCode *a9)
{
  int v12 = a5;
  uint64_t v13 = a9;
  if (a1 == 4)
  {
    uint64_t v14 = sub_18087C874(a2, a4, a5, a6, a7, a8, a9);
    goto LABEL_62;
  }

  uint64_t v45 = 0LL;
  v43[0] = a6;
  v43[1] = 0LL;
  uint64_t v44 = a7;
  uint64_t v15 = &unk_1809FA266;
  if (a1 == 2) {
    uint64_t v15 = &unk_1809FA3E6;
  }
  BOOL v40 = v15;
  char v39 = sub_180817CFC();
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  LODWORD(v18) = 0;
  while (2)
  {
    if ((int)v18 >= a7)
    {
      LOWORD(v2sub_18086E18C((uint64_t)this, 1) = 0;
      LODWORD(v19) = v18;
      goto LABEL_41;
    }

    LODWORD(v19) = v18;
    uint64_t v20 = v17;
    while (1)
    {
      unint64_t v21 = *(unsigned __int16 *)(a6 + 2LL * (int)v19);
      if (v21 <= 0x17E)
      {
        int v22 = (char)v40[v21];
        if (v22 == -128) {
          break;
        }
        uint64_t v19 = (v19 + 1);
        uint64_t v17 = v19;
        if (v40[v21]) {
          goto LABEL_20;
        }
        goto LABEL_18;
      }

      unsigned int v23 = *((unsigned __int16 *)*v39
      if ((v23 & 8) != 0) {
        break;
      }
      uint64_t v19 = (v19 + 1);
      if (v23 >= 0x80 && (v23 & 3) == 1)
      {
        int v22 = (__int16)v23 >> 7;
        uint64_t v17 = v19;
LABEL_20:
        int32_t v25 = v17 + ~(_DWORD)v20;
        if (v25 < 1) {
          goto LABEL_27;
        }
        if (a8) {
          icu::Edits::addUnchanged(a8, v17 + ~(_DWORD)v20);
        }
        if ((a2 & 0x4000) != 0)
        {
LABEL_27:
          int v26 = v16;
        }

        else
        {
          int v26 = v25 + v16;
        }

        if (v26 < 0) {
          goto LABEL_61;
        }
        LOWORD(v2sub_18086E18C((uint64_t)this, 1) = v22 + v21;
        if (v26 < a5)
        {
          *(_WORD *)(a4 + 2LL * v26) = v21;
          goto LABEL_34;
        }

        if (v26 == 0x7FFFFFFF)
        {
          uint64_t v16 = 0xFFFFFFFFLL;
          if (!a8)
          {
LABEL_36:
            LODWORD(v19) = v17;
            if ((v16 & 0x80000000) != 0) {
              goto LABEL_61;
            }
            goto LABEL_37;
          }
        }

        else
        {
LABEL_34:
          uint64_t v16 = (v26 + 1);
          if (!a8) {
            goto LABEL_36;
          }
        }

        icu::Edits::addReplace(a8, 1, 1);
        goto LABEL_36;
      }

uint64_t sub_18087D1C4( uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, icu::Edits *a8, UErrorCode *a9)
{
  uint64_t v11 = sub_18087C314(-1, a2, a4, a5, a6, 0LL, 0LL, a7, a8, a9);
  uint64_t v12 = v11;
  if (*(int *)a9 <= 0)
  {
    if ((int)v11 <= a5)
    {
      if (a8) {
        icu::Edits::copyErrorTo(a8, a9);
      }
    }

    else
    {
      *a9 = U_BUFFER_OVERFLOW_ERROR;
    }
  }

  return v12;
}

uint64_t sub_18087D254( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, UChar *s, uint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *), icu::Edits *a9, int *a10)
{
  if (*a10 > 0) {
    return 0LL;
  }
  if ((a5 & 0x80000000) != 0 || ((_DWORD)a5 ? (v12 = a4 == 0) : (v12 = 0), v12 || !s || (uint64_t v14 = a7, (int)a7 <= -2)))
  {
LABEL_17:
    *a10 = 1;
    return 0LL;
  }

  if ((_DWORD)a7 == -1)
  {
    uint64_t v14 = u_strlen(s);
    if (!a4) {
      goto LABEL_19;
    }
  }

  else if (!a4)
  {
    goto LABEL_19;
  }

  if ((unint64_t)s >= a4 && a4 + 2LL * a5 > (unint64_t)s
    || a4 >= (unint64_t)s && (unint64_t)&s[(int)v14] > a4)
  {
    goto LABEL_17;
  }

UChar *sub_18087D3A0( uint64_t a1, uint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, UChar *s, uint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, int *), int *a9)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (*a9 > 0) {
    return 0LL;
  }
  if ((a5 & 0x80000000) != 0 || ((_DWORD)a5 ? (v12 = a4 == 0LL) : (v12 = 0), v12 || !s || (uint64_t v14 = a7, (int)a7 <= -2)))
  {
    uint64_t result = 0LL;
    int v20 = 1;
    goto LABEL_20;
  }

  if ((_DWORD)a7 == -1) {
    uint64_t v14 = u_strlen(s);
  }
  bzero(v23, 0x258uLL);
  if (a4 && (s >= a4 && &a4[a5] > s || a4 >= s && &s[(int)v14] > a4))
  {
    if (a5 < 0x12D)
    {
      uint64_t v19 = (UChar *)v23;
      goto LABEL_23;
    }

    uint64_t result = (UChar *)uprv_malloc((2 * a5));
    uint64_t v19 = result;
    if (result)
    {
LABEL_23:
      uint64_t v22 = a8(a1, a2, a3, v19, a5, s, v14, 0LL, a9);
      uint64_t v21 = v22;
      if (v19 != a4)
      {
        if (v19 != (UChar *)v23) {
          uprv_free(v19);
        }
      }

      return (UChar *)u_terminateUChars((uint64_t)a4, a5, v21, a9);
    }

    int v20 = 7;
LABEL_20:
    *a9 = v20;
    return result;
  }

  uint64_t v21 = a8(a1, a2, a3, a4, a5, s, v14, 0LL, a9);
  return (UChar *)u_terminateUChars((uint64_t)a4, a5, v21, a9);
}

int32_t u_strFoldCase( UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, uint32_t options, UErrorCode *pErrorCode)
{
  return sub_18087D3A0( 1LL,  *(uint64_t *)&options,  0LL,  dest,  *(uint64_t *)&destCapacity,  (UChar *)src,  *(uint64_t *)&srcLength,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, int *))sub_18087D1C4,  (int *)pErrorCode);
}

uint64_t icu::CaseMap::fold( uint64_t a1, UChar *s, uint64_t a3, unint64_t a4, uint64_t a5, icu::Edits *a6, int *a7)
{
  return sub_18087D254( 1LL,  a1,  0LL,  a4,  a5,  s,  a3,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18087D1C4,  a6,  a7);
}

uint64_t sub_18087D62C(UChar *a1, int a2, UChar *a3, int a4, __int16 a5, int *a6)
{
  return u_caseInsensitivePrefixMatch_0(a1, a2, a3, a4, a5, 0LL, 0LL, a6);
}

uint64_t u_caseInsensitivePrefixMatch_0( UChar *a1, int a2, UChar *a3, int a4, __int16 a5, _DWORD *a6, _DWORD *a7, int *a8)
{
  v64[5] = *MEMORY[0x1895F89C0];
  src = 0LL;
  memset(v64, 0, 32);
  __int128 v63 = 0u;
  __int128 v61 = 0u;
  memset(v62, 0, sizeof(v62));
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  *(_OWORD *)__int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  *(_OWORD *)dest = 0u;
  __int128 v54 = 0u;
  if (*a8 > 0) {
    return 0LL;
  }
  if (a6)
  {
    *a6 = 0;
    *a7 = 0;
  }

  int v42 = 0LL;
  uint64_t v43 = a1;
  int v49 = 0LL;
  int v9 = 0;
  int v10 = 0;
  if (a2 == -1) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = &a1[a2];
  }
  if (a4 == -1) {
    BOOL v12 = 0LL;
  }
  else {
    BOOL v12 = &a3[a4];
  }
  uint64_t v13 = a3;
  uint64_t v14 = a1;
  uint64_t v15 = a1;
  uint64_t v16 = a3;
  unsigned int v48 = a3;
  __int16 v50 = a5;
LABEL_12:
  unsigned int v17 = -1;
LABEL_17:
  while (1)
  {
    if (v14 != v11)
    {
      unsigned int v19 = *v14;
      BOOL v20 = (a5 & 0x1000) != 0 || v11 == 0LL;
      BOOL v21 = !v20;
      if (*v14 || v21) {
        break;
      }
    }

    if (!v9)
    {
      unsigned int v19 = -1;
      goto LABEL_28;
    }

    uint64_t v18 = (UChar **)&v64[3 * v9];
    do
    {
      uint64_t v15 = *(v18 - 5);
      --v9;
      v18 -= 3;
    }

    while (!v15);
    uint64_t v14 = *(v18 - 1);
    uint64_t v11 = *v18;
  }

  ++v14;
  if ((v17 & 0x80000000) != 0) {
    goto LABEL_35;
  }
  while (1)
  {
LABEL_47:
    if (v19 == v17)
    {
      if ((v19 & 0x80000000) != 0)
      {
        uint64_t result = 0LL;
        goto LABEL_126;
      }

      uint64_t v34 = v14;
      if (v9)
      {
        unsigned int v17 = -1;
        uint64_t v34 = v42;
        if (v14 != v11) {
          goto LABEL_17;
        }
      }

      unsigned int v17 = -1;
      if (!v34) {
        goto LABEL_17;
      }
      char v37 = v49;
      if (v13 != v12) {
        char v37 = 0LL;
      }
      if (!v10) {
        char v37 = v13;
      }
      int v38 = v43;
      if (v37) {
        int v38 = v34;
      }
      uint64_t v43 = v38;
      char v39 = v48;
      if (v37) {
        char v39 = v37;
      }
      unsigned int v48 = v39;
      goto LABEL_12;
    }

    if ((v19 & 0x80000000) != 0)
    {
      uint64_t result = 0xFFFFFFFFLL;
LABEL_126:
      BOOL v41 = a6;
      BOOL v40 = a7;
      goto LABEL_127;
    }

    if ((v17 & 0x80000000) != 0)
    {
      uint64_t result = 1LL;
      goto LABEL_126;
    }

    __int16 v51 = v11;
    unsigned int v25 = v19;
    if ((v19 & 0xFFFFF800) == 0xD800)
    {
      if ((v19 & 0x400) != 0)
      {
        unsigned int v25 = v19;
        if (v15 <= v14 - 2)
        {
          int v27 = *(v14 - 2);
          unsigned int v25 = v19;
          if ((v27 & 0xFC00) == 0xD800) {
            unsigned int v25 = v19 - 56613888 + (v27 << 10);
          }
        }
      }

      else
      {
        unsigned int v25 = v19;
        if (v14 != v11)
        {
          int v26 = *v14;
          unsigned int v25 = v19;
          if ((v26 & 0xFC00) == 0xDC00) {
            unsigned int v25 = (v19 << 10) - 56613888 + v26;
          }
        }
      }
    }

    unsigned int v28 = v17;
    if ((v17 & 0xFFFFF800) == 0xD800)
    {
      if ((v17 & 0x400) != 0)
      {
        unsigned int v28 = v17;
        if (v16 <= v13 - 2)
        {
          int v30 = *(v13 - 2);
          unsigned int v28 = v17;
          if ((v30 & 0xFC00) == 0xD800) {
            unsigned int v28 = v17 - 56613888 + (v30 << 10);
          }
        }
      }

      else
      {
        unsigned int v28 = v17;
        if (v13 != v12)
        {
          int v29 = *v13;
          unsigned int v28 = v17;
          if ((v29 & 0xFC00) == 0xDC00) {
            unsigned int v28 = (v17 << 10) - 56613888 + v29;
          }
        }
      }
    }

    if (!v9)
    {
      unsigned int v31 = ucase_toFullFolding(v25, &src, a5);
      a5 = v50;
      if ((v31 & 0x80000000) == 0)
      {
        if ((v19 & 0xFFFFF800) == 0xD800)
        {
          uint64_t v35 = v51;
          if ((v19 & 0x400) != 0)
          {
            unsigned int v17 = *(v13 - 2);
            --v13;
            --v48;
          }

          else
          {
            ++v14;
          }
        }

        else
        {
          uint64_t v35 = v51;
        }

        *(void *)&__int128 v63 = v15;
        *((void *)&v63 + sub_18086E18C((uint64_t)this, 1) = v14;
        int v42 = v14;
        v64[0] = v35;
        if (v31 > 0x1F)
        {
          if (HIWORD(v31))
          {
            v57[0] = (v31 >> 10) - 10304;
            v57[1] = v31 & 0x3FF | 0xDC00;
            int v36 = 2;
          }

          else
          {
            v57[0] = v31;
            int v36 = 1;
          }
        }

        else
        {
          int v36 = v31;
          u_memcpy(v57, src, v31);
          a5 = v50;
        }

        uint64_t v14 = v57;
        uint64_t v11 = &v57[v36];
        int v9 = 1;
        uint64_t v15 = v57;
        goto LABEL_17;
      }
    }

    if (v10) {
      break;
    }
    unsigned int v32 = ucase_toFullFolding(v28, &src, a5);
    a5 = v50;
    if ((v32 & 0x80000000) != 0) {
      break;
    }
    int v33 = v32;
    if ((v17 & 0xFFFFF800) == 0xD800)
    {
      if ((v17 & 0x400) != 0)
      {
        unsigned int v19 = *(v14 - 2);
        --v14;
        --v48;
      }

      else
      {
        ++v13;
      }
    }

    *(void *)&__int128 v61 = v16;
    *((void *)&v61 + sub_18086E18C((uint64_t)this, 1) = v13;
    v62[0] = v12;
    int v49 = v13;
    if (v32 > 0x1F)
    {
      if (HIWORD(v32))
      {
        dest[0] = (v32 >> 10) - 10304;
        dest[1] = v32 & 0x3FF | 0xDC00;
        int v33 = 2;
      }

      else
      {
        dest[0] = v32;
        int v33 = 1;
      }
    }

    else
    {
      u_memcpy(dest, src, v32);
      a5 = v50;
    }

    uint64_t v11 = v51;
    uint64_t v13 = dest;
    BOOL v12 = &dest[v33];
    unsigned int v17 = -1;
    int v10 = 1;
    uint64_t v16 = dest;
    if ((v19 & 0x80000000) != 0) {
      goto LABEL_17;
    }
LABEL_28:
    if ((v17 & 0x80000000) != 0)
    {
LABEL_35:
      while (1)
      {
        if (v13 != v12)
        {
          unsigned int v17 = *v13;
          BOOL v23 = (a5 & 0x1000) != 0 || v12 == 0LL;
          BOOL v24 = !v23;
          if (*v13 || v24) {
            break;
          }
        }

        if (!v10)
        {
          unsigned int v17 = -1;
          goto LABEL_47;
        }

        uint64_t v22 = (UChar **)&v62[3 * v10];
        do
        {
          uint64_t v16 = *(v22 - 5);
          --v10;
          v22 -= 3;
        }

        while (!v16);
        uint64_t v13 = *(v22 - 1);
        BOOL v12 = *v22;
      }

      ++v13;
    }
  }

  if (a5 < 0 && v19 >> 11 >= 0x1B && v17 >> 11 >= 0x1B)
  {
    if ((v19 >> 10 > 0x36 || v14 == v51 || (*v14 & 0xFC00) != 0xDC00)
      && (v19 >> 10 != 55 || v15 == v14 - 1 || (*(v14 - 2) & 0xFC00) != 0xD800))
    {
      v19 -= 10240;
    }

    if ((v17 >> 10 > 0x36 || v13 == v12 || (*v13 & 0xFC00) != 0xDC00)
      && (v17 >> 10 != 55 || v16 == v13 - 1 || (*(v13 - 2) & 0xFC00) != 0xD800))
    {
      v17 -= 10240;
    }
  }

  BOOL v41 = a6;
  BOOL v40 = a7;
  uint64_t result = v19 - v17;
LABEL_127:
  if (v41)
  {
    *BOOL v41 = (unint64_t)((char *)v43 - (char *)a1) >> 1;
    _DWORD *v40 = (unint64_t)((char *)v48 - (char *)a3) >> 1;
  }

  return result;
}

int32_t u_strCaseCompare( const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, uint32_t options, UErrorCode *pErrorCode)
{
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (s1 && length1 >= -1 && s2 && length2 > -2) {
      return u_caseInsensitivePrefixMatch_0( (UChar *)s1,  length1,  (UChar *)s2,  length2,  options,  0LL,  0LL,  (int *)pErrorCode);
    }
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return 0;
}

int32_t u_strcasecmp(const UChar *s1, const UChar *s2, uint32_t options)
{
  int v4 = 0;
  return u_caseInsensitivePrefixMatch_0((UChar *)s1, -1, (UChar *)s2, -1, options, 0LL, 0LL, &v4);
}

int32_t u_memcasecmp(const UChar *s1, const UChar *s2, int32_t length, uint32_t options)
{
  int v5 = 0;
  return u_caseInsensitivePrefixMatch_0((UChar *)s1, length, (UChar *)s2, length, options, 0LL, 0LL, &v5);
}

int32_t u_strncasecmp(const UChar *s1, const UChar *s2, int32_t n, uint32_t options)
{
  int v5 = 0;
  return u_caseInsensitivePrefixMatch_0((UChar *)s1, n, (UChar *)s2, n, options | 0x1000, 0LL, 0LL, &v5);
}

uint64_t sub_18087DD70(unsigned __int8 *Default)
{
  if (!Default) {
    Default = (unsigned __int8 *)uloc_getDefault(0LL);
  }
  if (*Default) {
    return sub_180818B2C(Default);
  }
  else {
    return 1LL;
  }
}

int32_t u_strToLower( UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, UErrorCode *pErrorCode)
{
  uint64_t v7 = *(void *)&srcLength;
  uint64_t v9 = *(void *)&destCapacity;
  uint64_t v11 = sub_18087DD70((unsigned __int8 *)locale);
  return sub_18087D3A0( v11,  0LL,  0LL,  dest,  v9,  (UChar *)src,  v7,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, int *))sub_18087CD1C,  (int *)pErrorCode);
}

int32_t u_strToUpper( UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, UErrorCode *pErrorCode)
{
  uint64_t v7 = *(void *)&srcLength;
  uint64_t v9 = *(void *)&destCapacity;
  uint64_t v11 = sub_18087DD70((unsigned __int8 *)locale);
  return sub_18087D3A0( v11,  0LL,  0LL,  dest,  v9,  (UChar *)src,  v7,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, int *))sub_18087CDB8,  (int *)pErrorCode);
}

uint64_t icu::CaseMap::toLower( unsigned __int8 *a1, uint64_t a2, UChar *a3, uint64_t a4, unint64_t a5, uint64_t a6, icu::Edits *a7, int *a8)
{
  uint64_t v15 = sub_18087DD70(a1);
  return sub_18087D254( v15,  a2,  0LL,  a5,  a6,  a3,  a4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18087CD1C,  a7,  a8);
}

uint64_t icu::CaseMap::toUpper( unsigned __int8 *a1, uint64_t a2, UChar *a3, uint64_t a4, unint64_t a5, uint64_t a6, icu::Edits *a7, int *a8)
{
  uint64_t v15 = sub_18087DD70(a1);
  return sub_18087D254( v15,  a2,  0LL,  a5,  a6,  a3,  a4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18087CDB8,  a7,  a8);
}

uint64_t icu::StringEnumeration::StringEnumeration(uint64_t this)
{
  *(void *)this = off_18971C360;
  *(void *)(this + 8) = off_18971B688;
  *(_WORD *)(this + 16) = 2;
  *(void *)(this + 104) = this + 72;
  *(_DWORD *)(this + 112) = 32;
  return this;
}

void icu::StringEnumeration::~StringEnumeration(icu::StringEnumeration *this)
{
  *(void *)this = off_18971C360;
  int v2 = (char *)*((void *)this + 13);
  if (v2) {
    BOOL v3 = v2 == (char *)this + 72;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    uprv_free(v2);
  }
  icu::UnicodeString::~UnicodeString((icu::StringEnumeration *)((char *)this + 8));
  icu::UObject::~UObject(this);
}

uint64_t icu::StringEnumeration::clone(icu::StringEnumeration *this)
{
  return 0LL;
}

UChar *icu::StringEnumeration::next(UChar **this, int *a2, UErrorCode *a3)
{
  unsigned int v6 = (UChar **)(*((uint64_t (**)(UChar **, UErrorCode *))*this + 7))(this, a3);
  icu::UnicodeString::operator=(this + 1, v6);
  unsigned int v8 = *((unsigned __int16 *)this + 8);
  int v9 = (v8 & 0x8000) != 0 ? *((_DWORD *)this + 5) : v8 >> 5;
  icu::StringEnumeration::ensureCharsCapacity((int *)this, v9 + 1, a3);
  if (a2)
  {
    else {
      int v11 = *((unsigned __int16 *)this + 8) >> 5;
    }
    *a2 = v11;
  }

  icu::UnicodeString::extract((uint64_t)(this + 1), 0, 0x7FFFFFFFLL, (char *)this[13], *((_DWORD *)this + 28));
  return this[13];
}

int *icu::StringEnumeration::ensureCharsCapacity(int *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    BOOL v3 = this;
    int v4 = this[28];
    if (v4 < a2)
    {
      if (v4 >= 0) {
        int v6 = this[28];
      }
      else {
        int v6 = v4 + 1;
      }
      int v7 = v4 + (v6 >> 1);
      if (v7 <= a2) {
        int v8 = a2;
      }
      else {
        int v8 = v7;
      }
      int v9 = (char *)*((void *)this + 13);
      this = (int *)uprv_malloc(v8);
      *((void *)v3 + 13) = this;
      if (this)
      {
        v3[28] = v8;
      }

      else
      {
        *((void *)v3 + 13) = v3 + 18;
        v3[28] = 32;
        *a3 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }

  return this;
}

uint64_t icu::StringEnumeration::unext(UChar **this, int *a2, UErrorCode *a3)
{
  int v6 = (UChar **)(*((uint64_t (**)(UChar **, UErrorCode *))*this + 7))(this, a3);
  icu::UnicodeString::operator=(this + 1, v6);
  if (a2)
  {
    else {
      int v9 = *((unsigned __int16 *)this + 8) >> 5;
    }
    *a2 = v9;
  }

  return icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)(this + 1));
}

char *icu::StringEnumeration::snext(icu::StringEnumeration *this, UErrorCode *a2)
{
  int v6 = 0;
  int v4 = (const char *)(*(uint64_t (**)(icu::StringEnumeration *, int *, UErrorCode *))(*(void *)this + 40LL))( this,  &v6,  a2);
  return icu::StringEnumeration::setChars(this, v4, v6, a2);
}

char *icu::StringEnumeration::setChars( icu::StringEnumeration *this, const char *__s, int32_t a3, UErrorCode *a4)
{
  int v4 = 0LL;
  if (__s && *(int *)a4 <= 0)
  {
    int32_t v6 = a3;
    if (a3 < 0) {
      int32_t v6 = strlen(__s);
    }
    int v4 = (char *)this + 8;
    uint64_t Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::StringEnumeration *)((char *)this + 8), v6 + 1);
    if (Buffer)
    {
      int v10 = Buffer;
      u_charsToUChars(__s, Buffer, v6);
      v10[v6] = 0;
      icu::UnicodeString::releaseBuffer((uint64_t)v4, v6);
    }

    else
    {
      int v4 = 0LL;
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return v4;
}

BOOL icu::StringEnumeration::operator==(void *a1, void *a2)
{
  if (!a1) {
    __cxa_bad_typeid();
  }
  return sub_1807F874C(*(void *)(*a1 - 8LL), *(void *)(*a2 - 8LL));
}

uint64_t icu::StringEnumeration::operator!=(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1) ^ 1;
}

uint64_t *icu::UStringEnumeration::fromUEnumeration(void **a1, _DWORD *a2)
{
  BOOL v3 = (uint64_t *)*a2;
  uint64_t result = icu::UMemory::operator new(v3, (icu::UMemory *)0x80, (unint64_t)a2);
  if (!result)
  {
    *a2 = 7;
LABEL_2:
    uenum_close(a1);
    return 0LL;
  }

  *((_WORD *)result + 8) = 2;
  result[13] = (uint64_t)(result + 9);
  *((_DWORD *)result + 28) = 32;
  *uint64_t result = (uint64_t)off_18971C3C8;
  result[1] = (uint64_t)off_18971B688;
  result[15] = (uint64_t)a1;
  return result;
}

uint64_t icu::UStringEnumeration::UStringEnumeration(uint64_t result, uint64_t a2)
{
  *(_WORD *)(result + 16) = 2;
  *(void *)(result + 104) = result + 72;
  *(_DWORD *)(result + 112) = 32;
  *(void *)uint64_t result = off_18971C3C8;
  *(void *)(result + 8) = off_18971B688;
  *(void *)(result + 120) = a2;
  return result;
}

{
  *(_WORD *)(result + 16) = 2;
  *(void *)(result + 104) = result + 72;
  *(_DWORD *)(result + 112) = 32;
  *(void *)uint64_t result = off_18971C3C8;
  *(void *)(result + 8) = off_18971B688;
  *(void *)(result + 120) = a2;
  return result;
}

void icu::UStringEnumeration::~UStringEnumeration(void ***this)
{
  *this = (void **)off_18971C3C8;
  uenum_close(this[15]);
  icu::StringEnumeration::~StringEnumeration((icu::StringEnumeration *)this);
}

{
  *this = (void **)off_18971C3C8;
  uenum_close(this[15]);
  icu::StringEnumeration::~StringEnumeration((icu::StringEnumeration *)this);
}

{
  void *v2;
  *this = (void **)off_18971C3C8;
  uenum_close(this[15]);
  icu::StringEnumeration::~StringEnumeration((icu::StringEnumeration *)this);
  icu::UMemory::operator delete(v2);
}

uint64_t icu::UStringEnumeration::count(icu::UStringEnumeration *this, UErrorCode *a2)
{
  return uenum_count(*((void *)this + 15), (int *)a2);
}

uint64_t icu::UStringEnumeration::next(icu::UStringEnumeration *this, int *a2, UErrorCode *a3)
{
  return uenum_next(*((void *)this + 15), (uint64_t)a2, (int *)a3);
}

uint64_t icu::UStringEnumeration::snext(icu::UStringEnumeration *this, UErrorCode *a2)
{
  unsigned int v10 = 0;
  uint64_t v4 = uenum_unext(*((void *)this + 15), (uint64_t)&v10, (int *)a2);
  if (v4) {
    BOOL v5 = *a2 <= U_ZERO_ERROR;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5) {
    return 0LL;
  }
  uint64_t v7 = v4;
  uint64_t v8 = v10;
  icu::UnicodeString::unBogus((uint64_t)this + 8);
  else {
    uint64_t v9 = *((unsigned __int16 *)this + 8) >> 5;
  }
  return icu::UnicodeString::doReplace((uint64_t)this + 8, 0LL, v9, v7, 0, v8);
}

uint64_t icu::UStringEnumeration::reset(icu::UStringEnumeration *this, UErrorCode *a2)
{
  return uenum_reset(*((void *)this + 15), (int *)a2);
}

void *icu::UStringEnumeration::getStaticClassID(icu::UStringEnumeration *this)
{
  return &unk_18C535171;
}

void *icu::UStringEnumeration::getDynamicClassID(icu::UStringEnumeration *this)
{
  return &unk_18C535171;
}

_OWORD *uenum_openFromStringEnumeration(uint64_t a1, int *a2)
{
  if (a1 && *a2 <= 0)
  {
    uint64_t result = uprv_malloc(0x38uLL);
    if (result)
    {
      *uint64_t result = xmmword_18971C420;
      result[1] = *(_OWORD *)&off_18971C430;
      result[2] = xmmword_18971C440;
      *((void *)result + 6) = sub_18087E7C8;
      *((void *)result + sub_18086E18C((uint64_t)this, 1) = a1;
      return result;
    }

    *a2 = 7;
  }

  else if (!a1)
  {
    return 0LL;
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 8LL))(a1);
  return 0LL;
}

_OWORD *uenum_openCharStringsEnumeration(uint64_t a1, int a2, int *a3)
{
  uint64_t result = 0LL;
  if ((a2 & 0x80000000) == 0 && *a3 <= 0)
  {
    if (a1 || !a2)
    {
      uint64_t result = uprv_malloc(0x40uLL);
      if (result)
      {
        *uint64_t result = xmmword_18971C458;
        result[1] = *(_OWORD *)&off_18971C468;
        result[2] = xmmword_18971C478;
        *((void *)result + 6) = sub_18087E83C;
        *((void *)result + sub_18086E18C((uint64_t)this, 1) = a1;
        *((_DWORD *)result + 14) = 0;
        *((_DWORD *)result + 15) = a2;
      }

      else
      {
        *a3 = 7;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

_OWORD *uenum_openUCharStringsEnumeration(uint64_t a1, int a2, int *a3)
{
  uint64_t result = 0LL;
  if ((a2 & 0x80000000) == 0 && *a3 <= 0)
  {
    if (a1 || !a2)
    {
      uint64_t result = uprv_malloc(0x40uLL);
      if (result)
      {
        *uint64_t result = xmmword_18971C490;
        result[1] = *(_OWORD *)&off_18971C4A0;
        result[2] = xmmword_18971C4B0;
        *((void *)result + 6) = sub_18087E83C;
        *((void *)result + sub_18086E18C((uint64_t)this, 1) = a1;
        *((_DWORD *)result + 14) = 0;
        *((_DWORD *)result + 15) = a2;
      }

      else
      {
        *a3 = 7;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void sub_18087E764(void *a1)
{
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uprv_free(a1);
}

uint64_t sub_18087E798(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32LL))(*(void *)(a1 + 8));
}

uint64_t sub_18087E7A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48LL))(*(void *)(a1 + 8));
}

uint64_t sub_18087E7B8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40LL))(*(void *)(a1 + 8));
}

uint64_t sub_18087E7C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64LL))(*(void *)(a1 + 8));
}

uint64_t sub_18087E7DC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t sub_18087E7E4(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(int *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 56) = v2 + 1;
  uint64_t v4 = *(void *)(v3 + 8 * v2);
  if (a2) {
    *a2 = strlen(*(const char **)(v3 + 8 * v2));
  }
  return v4;
}

uint64_t sub_18087E83C(uint64_t result)
{
  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t sub_18087E844(uint64_t a1, int32_t *a2)
{
  uint64_t v2 = *(int *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 56) = v2 + 1;
  uint64_t v4 = *(void *)(v3 + 8 * v2);
  if (a2) {
    *a2 = u_strlen(*(const UChar **)(v3 + 8 * v2));
  }
  return v4;
}

uint64_t uprv_itou(__int16 *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v7 = a1;
  uint64_t v8 = 0LL;
  do
  {
    else {
      __int16 v9 = 48;
    }
    ++v8;
    *a1++ = v9 + a3 % a4;
    if (a3 < a4) {
      break;
    }
    a3 /= a4;
  }

  while (v8 < a2);
  if ((int)v8 >= (int)a5)
  {
    uint64_t result = v8;
  }

  else
  {
    memset_pattern16(a1, a00000000, 2LL * (~(_DWORD)v8 + a5) + 2);
    uint64_t result = a5;
  }

  if (result >= 2)
  {
    else {
      unint64_t v11 = a5;
    }
    BOOL v12 = &v7[v11 - 1];
    unint64_t v13 = v11 >> 1;
    do
    {
      __int16 v14 = *v12;
      *v12-- = *v7;
      *v7++ = v14;
      --v13;
    }

    while (v13);
  }

  return result;
}

UChar *__cdecl u_strFindFirst(const UChar *s, int32_t length, const UChar *substring, int32_t subLength)
{
  if (!substring || subLength < -1) {
    return (UChar *)s;
  }
  int32_t v6 = 0LL;
  if (!s || length < -1) {
    return v6;
  }
  if ((subLength & length) < 0 != __OFSUB__(length, -1))
  {
    unsigned int v11 = *substring;
    if (*substring)
    {
      if (v11 >> 11 == 27 || substring[1])
      {
        UChar v20 = *s;
        if (!*s) {
          return 0LL;
        }
        BOOL v21 = s;
        while (1)
        {
          int32_t v6 = (UChar *)v21++;
          if (v11 == v20)
          {
            uint64_t v22 = v21;
            if (substring[1])
            {
              uint64_t v23 = 0LL;
              int v24 = substring[1];
              do
              {
                if (!v6[v23 + 1]) {
                  return 0LL;
                }
                if (v6[v23 + 1] != v24) {
                  goto LABEL_52;
                }
                int v24 = substring[v23 + 2];
                ++v23;
              }

              while (v24);
              uint64_t v22 = &v6[v23 + 1];
            }

            if ((v6 == s || (v11 & 0xFC00) != 0xDC00 || (*(v6 - 1) & 0xFC00) != 0xD800)
              && ((*(v22 - 1) & 0xFC00) != 0xD800 || (*v22 & 0xFC00) != 0xDC00))
            {
              return v6;
            }
          }

UChar *__cdecl u_strchr(UChar *s, UChar c)
{
  UChar substring = c;
  if ((c & 0xF800) == 0xD800) {
    return u_strFindFirst(s, -1, &substring, 1);
  }
  for (int i = *s; i != c; int i = v3)
  {
    if (!i) {
      return 0LL;
    }
    int v3 = s[1];
    ++s;
  }

  return s;
}

BOOL sub_18087ECD0(_WORD *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  return (a1 == a2 || (*a2 & 0xFC00) != 0xDC00 || (*(a2 - 1) & 0xFC00) != 0xD800)
      && (a3 == a4 || (*(a3 - 1) & 0xFC00) != 0xD800 || (*a3 & 0xFC00) != 0xDC00);
}

int32_t u_strlen(const UChar *s)
{
  int32_t result = -1;
  do
  {
    int v3 = *s++;
    ++result;
  }

  while (v3);
  return result;
}

UChar *__cdecl u_memchr(UChar *s, UChar c, int32_t count)
{
  UChar substring = c;
  if (count < 1) {
    return 0LL;
  }
  if ((c & 0xF800) == 0xD800) {
    return u_strFindFirst(s, count, &substring, 1);
  }
  uint64_t v3 = 2LL * count;
  while (*s != c)
  {
    ++s;
    v3 -= 2LL;
    if (!v3) {
      return 0LL;
    }
  }

  return s;
}

UChar *__cdecl u_strstr(const UChar *s, const UChar *substring)
{
  return u_strFindFirst(s, -1, substring, -1);
}

UChar *__cdecl u_strchr32(UChar *s, UChar32 c)
{
  if (!HIWORD(c)) {
    return u_strchr(s, c);
  }
  if (HIWORD(c) > 0x10u) {
    return 0LL;
  }
  int v2 = *s;
  if (!*s) {
    return 0LL;
  }
  uint64_t v3 = s;
  while (1)
  {
    int v5 = v3[1];
    ++v3;
    int v4 = v5;
    int v2 = v4;
    s = v3;
    if (!v4) {
      return 0LL;
    }
  }

  return s;
}

UChar *__cdecl u_memchr32(const UChar *s, UChar32 c, int32_t count)
{
  if (!HIWORD(c)) {
    return u_memchr(s, c, count);
  }
  int v4 = 0LL;
  if (HIWORD(c) <= 0x10u && count >= 2)
  {
    uint64_t v5 = 2LL * count - 2;
    while (*s != (unsigned __int16)(c >> 10) + 55232 || (c & 0x3FF | 0xDC00) != s[1])
    {
      ++s;
      v5 -= 2LL;
      if (!v5) {
        return 0LL;
      }
    }

    return (UChar *)s;
  }

  return v4;
}

UChar *__cdecl u_strFindLast(const UChar *s, int32_t length, const UChar *substring, int32_t subLength)
{
  if (!substring || subLength < -1) {
    return (UChar *)s;
  }
  int v4 = 0LL;
  if (!s) {
    return v4;
  }
  int32_t v5 = length;
  if (length < -1) {
    return v4;
  }
  if (subLength < 0)
  {
    subLength = -1;
    int32_t v6 = substring;
    do
    {
      int v7 = *v6++;
      ++subLength;
    }

    while (v7);
  }

  if (!subLength) {
    return (UChar *)s;
  }
  uint64_t v8 = &substring[subLength];
  int v11 = *(v8 - 1);
  int v10 = v8 - 1;
  int v9 = v11;
  uint64_t v12 = subLength - 1LL;
  if (subLength != 1 || (v9 & 0xF800) == 0xD800)
  {
    if (v5 < 0)
    {
      int32_t v5 = -1;
      __int16 v14 = s;
      do
      {
        int v15 = *v14++;
        ++v5;
      }

      while (v15);
    }

    if (v5 >= subLength && (_DWORD)v12 != v5)
    {
      uint64_t v16 = &s[v5];
      int v17 = &s[v12];
      uint64_t v18 = &substring[subLength - 2];
      unint64_t v19 = (UChar *)v16;
      uint64_t v20 = 2 - 2LL * subLength;
      while (1)
      {
        BOOL v21 = v19;
        int v22 = *--v19;
        if (v22 == v9)
        {
          LOWORD(v23) = v9;
          int v4 = v19;
          if (v10 == substring)
          {
LABEL_29:
            if ((v4 == s || (v23 & 0xFC00) != 0xDC00 || (*(v4 - 1) & 0xFC00) != 0xD800)
              && (v21 == v16 || (v9 & 0xFC00) != 0xD800 || (*v21 & 0xFC00) != 0xDC00))
            {
              return v4;
            }
          }

          else
          {
            unint64_t v24 = 0LL;
            while (1)
            {
              int v23 = v21[v24 / 2 - 2];
              if (v23 != v18[v24 / 2]) {
                break;
              }
              v24 -= 2LL;
              if (v20 == v24)
              {
                int v4 = (UChar *)&v21[v24 / 2 - 1];
                goto LABEL_29;
              }
            }
          }
        }

        int v4 = 0LL;
        if (v17 == v19) {
          return v4;
        }
      }
    }

    return 0LL;
  }

  if (v5 < 0) {
    return u_strrchr(s, v9);
  }
  else {
    return u_memrchr(s, v9, v5);
  }
}

UChar *__cdecl u_strrchr(const UChar *s, UChar c)
{
  UChar substring = c;
  if ((c & 0xF800) == 0xD800) {
    return u_strFindLast(s, -1, &substring, 1);
  }
  int v2 = 0LL;
  uint64_t v3 = s;
  do
  {
    int v5 = *v3++;
    int v4 = v5;
    if (v5 == c) {
      int v2 = (UChar *)s;
    }
    s = v3;
  }

  while (v4);
  return v2;
}

UChar *__cdecl u_memrchr(const UChar *s, UChar c, int32_t count)
{
  UChar substring = c;
  if (count < 1) {
    return 0LL;
  }
  if ((c & 0xF800) == 0xD800) {
    return u_strFindLast(s, count, &substring, 1);
  }
  uint64_t v4 = count;
  while (s[v4 - 1] != c)
  {
    if (!(--v4 * 2)) {
      return 0LL;
    }
  }

  return (UChar *)&s[v4 - 1];
}

UChar *__cdecl u_strrstr(const UChar *s, const UChar *substring)
{
  return u_strFindLast(s, -1, substring, -1);
}

UChar *__cdecl u_strrchr32(const UChar *s, UChar32 c)
{
  if (!HIWORD(c)) {
    return u_strrchr(s, c);
  }
  if (HIWORD(c) > 0x10u) {
    return 0LL;
  }
  int v3 = *s;
  if (!*s) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  int v5 = s;
  do
  {
    int v7 = v5[1];
    ++v5;
    int v6 = v7;
    int v3 = v6;
    s = v5;
  }

  while (v6);
  return v4;
}

UChar *__cdecl u_memrchr32(const UChar *s, UChar32 c, int32_t count)
{
  if (!HIWORD(c)) {
    return u_memrchr(s, c, count);
  }
  uint64_t v4 = 0LL;
  if (HIWORD(c) <= 0x10u && count >= 2)
  {
    uint64_t v5 = count;
    while ((c & 0x3FF | 0xDC00) != s[v5 - 1] || s[v5 - 2] != (unsigned __int16)(c >> 10) + 55232)
    {
      if (--v5 == 1) {
        return 0LL;
      }
    }

    return (UChar *)&s[v5 - 2];
  }

  return v4;
}

UChar *__cdecl u_strpbrk(const UChar *string, const UChar *matchSet)
{
  int v3 = sub_18087F220(string, (uint64_t)matchSet, 1);
  if (v3 < 0) {
    return 0LL;
  }
  else {
    return (UChar *)&string[v3];
  }
}

uint64_t sub_18087F220(_WORD *a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0LL;
  do
  {
    int v4 = *(unsigned __int16 *)(a2 + 2 * v3++);
    if (v4) {
      BOOL v5 = (v4 & 0xF800) == 55296;
    }
    else {
      BOOL v5 = 1;
    }
  }

  while (!v5);
  uint64_t v6 = v3;
  unsigned int v8 = (unsigned __int16)*a1;
  if (*a1)
  {
    uint64_t v9 = 0LL;
    int v10 = v3 - 1;
    uint64_t v11 = v6 - 2;
    while (1)
    {
      uint64_t v12 = (v9 + 1);
      if ((v8 & 0xF800) == 0xD800)
      {
        if ((v8 & 0x400) == 0)
        {
          int v13 = (unsigned __int16)a1[(int)v12];
          if ((v13 & 0xFC00) == 0xDC00)
          {
            uint64_t v12 = (v9 + 2);
            unsigned int v8 = (v8 << 10) - 56613888 + v13;
          }
        }

        int v14 = v10;
        if (!a3)
        {
          while (v14 < (int)v11)
          {
            uint64_t v22 = v14 + 1LL;
            int v23 = *(unsigned __int16 *)(a2 + 2LL * v14);
            if ((v23 & 0xFC00) == 0xD800 && v14 + 3 != (_DWORD)v6)
            {
              int v25 = *(unsigned __int16 *)(a2 + 2 * v22);
              BOOL v26 = (v25 & 0xFC00) == 56320;
              int v27 = v14 + 2;
              int v28 = (v23 << 10) - 56613888 + v25;
              if (v26) {
                LODWORD(v22) = v27;
              }
              if (v26) {
                int v23 = v28;
              }
            }

            int v14 = v22;
            if (v8 == v23) {
              goto LABEL_47;
            }
          }

int32_t u_strcspn(const UChar *string, const UChar *matchSet)
{
  int v2 = sub_18087F220(string, (uint64_t)matchSet, 1);
  return v2 ^ (v2 >> 31);
}

int32_t u_strspn(const UChar *string, const UChar *matchSet)
{
  int v2 = sub_18087F220(string, (uint64_t)matchSet, 0);
  return v2 ^ (v2 >> 31);
}

UChar *__cdecl u_strtok_r(UChar *src, const UChar *delim, UChar **saveState)
{
  if (src)
  {
    BOOL v5 = src;
    *saveState = src;
  }

  else
  {
    BOOL v5 = *saveState;
    if (!*saveState) {
      return v5;
    }
  }

  int v6 = sub_18087F220(v5, (uint64_t)delim, 0);
  v5 += v6 ^ (v6 >> 31);
  if (*v5)
  {
    int v7 = sub_18087F220(v5, (uint64_t)delim, 1);
    if (v7 < 0)
    {
      uint64_t v9 = 0LL;
    }

    else
    {
      unsigned int v8 = &v5[v7];
      UChar *v8 = 0;
      uint64_t v9 = v8 + 1;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    BOOL v5 = 0LL;
  }

  *saveState = v9;
  return v5;
}

UChar *__cdecl u_strcat(UChar *dst, const UChar *src)
{
  int v2 = dst - 1;
  do
  {
    int v3 = v2[1];
    ++v2;
  }

  while (v3);
  uint64_t v4 = 0LL;
  do
  {
    int v5 = src[v4];
    v2[v4++] = v5;
  }

  while (v5);
  return dst;
}

UChar *__cdecl u_strncat(UChar *dst, const UChar *src, int32_t n)
{
  if (n >= 1)
  {
    int v3 = dst;
    do
      uint64_t v4 = v3;
    while (*v3++);
    int v6 = *src;
    *uint64_t v4 = v6;
    if (v6)
    {
      uint64_t v7 = 0LL;
      while (n - 1 != (_DWORD)v7)
      {
        int v8 = src[v7 + 1];
        v3[v7++] = v8;
        if (!v8) {
          return dst;
        }
      }

      v3[v7] = 0;
    }
  }

  return dst;
}

int32_t u_strcmp(const UChar *s1, const UChar *s2)
{
  do
  {
    int v3 = *s1++;
    int v2 = v3;
    int v5 = *s2++;
    int v4 = v5;
    if (v2) {
      BOOL v6 = v2 == v4;
    }
    else {
      BOOL v6 = 0;
    }
  }

  while (v6);
  return v2 - v4;
}

uint64_t sub_18087F540(unsigned __int16 *a1, int a2, unsigned __int16 *a3, int a4, int a5, int a6)
{
  if ((a4 & a2) < 0 != v6)
  {
    if (a1 != a3)
    {
      unsigned int v11 = *a1;
      unsigned int v12 = *a3;
      if (v11 != v12)
      {
        uint64_t v7 = 0LL;
        int v16 = 0LL;
        int i = a3;
        uint64_t v9 = a1;
        if (!a6) {
          return (unsigned __int16)v11 - (unsigned __int16)v12;
        }
LABEL_44:
        if (v11 >> 11 >= 0x1B && v12 >> 11 >= 0x1B)
        {
          int v25 = v9 + 1;
          BOOL v26 = v11 >> 10 > 0x36 || v25 == v7;
          if ((v26 || (*v25 & 0xFC00) != 0xDC00)
            && (v9 == a1 || (v11 & 0xFC00) != 0xDC00 || (*(v9 - 1) & 0xFC00) != 0xD800))
          {
            LOWORD(v1sub_18086E18C((uint64_t)this, 1) = v11 - 10240;
          }

          if ((v12 >> 10 > 0x36 || i + 1 == v16 || (i[1] & 0xFC00) != 0xDC00)
            && (v12 >> 10 != 55 || i == a3 || (*(i - 1) & 0xFC00) != 0xD800))
          {
            LOWORD(v12) = v12 - 10240;
          }
        }

        return (unsigned __int16)v11 - (unsigned __int16)v12;
      }

      uint64_t v9 = a1;
      int i = a3;
      while ((_WORD)v11)
      {
        unsigned int v14 = v9[1];
        ++v9;
        unsigned int v11 = v14;
        unsigned int v15 = i[1];
        ++i;
        unsigned int v12 = v15;
        if (v11 != v15)
        {
          uint64_t v7 = 0LL;
          int v16 = 0LL;
          if (a6) {
            goto LABEL_44;
          }
          return (unsigned __int16)v11 - (unsigned __int16)v12;
        }
      }
    }

    return 0LL;
  }

  if (a5)
  {
    if (a1 != a3 && a2)
    {
      uint64_t v7 = &a1[a2];
      uint64_t v8 = 2LL * a2 - 2;
      uint64_t v9 = a1;
      int i = a3;
      while (1)
      {
        unsigned int v11 = *v9;
        unsigned int v12 = *i;
        if (v11 != v12) {
          break;
        }
        ++v9;
        ++i;
        if (v11) {
          BOOL v13 = v8 == 0;
        }
        else {
          BOOL v13 = 1;
        }
        v8 -= 2LL;
        if (v13) {
          return 0LL;
        }
      }

      int v16 = &a3[a2];
      if (!a6) {
        return (unsigned __int16)v11 - (unsigned __int16)v12;
      }
      goto LABEL_44;
    }

    return 0LL;
  }

  if (a2 < 0)
  {
    a2 = -1;
    int v18 = a1;
    do
    {
      int v19 = *v18++;
      ++a2;
    }

    while (v19);
  }

  if (a4 < 0)
  {
    a4 = -1;
    int v20 = a3;
    do
    {
      int v21 = *v20++;
      ++a4;
    }

    while (v21);
  }

  if (a2 >= a4) {
    int v22 = a4;
  }
  else {
    int v22 = a2;
  }
  if (a2 < a4) {
    uint64_t v17 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v17 = a2 != a4;
  }
  if (a1 != a3 && v22)
  {
    uint64_t v23 = 2LL * v22;
    uint64_t v9 = a1;
    for (int i = a3; ; ++i)
    {
      unsigned int v11 = *v9;
      unsigned int v12 = *i;
      if (v11 != v12) {
        break;
      }
      ++v9;
      v23 -= 2LL;
      if (!v23) {
        return v17;
      }
    }

    uint64_t v7 = &a1[a2];
    int v16 = &a3[a4];
    if (!a6) {
      return (unsigned __int16)v11 - (unsigned __int16)v12;
    }
    goto LABEL_44;
  }

  return v17;
}

int32_t u_strCompareIter(UCharIterator *iter1, UCharIterator *iter2, UBool codePointOrder)
{
  int32_t result = 0;
  if (iter1 != iter2 && iter1 && iter2)
  {
    int v6 = codePointOrder;
    ((void (*)(UCharIterator *, void, void))iter1->move)(iter1, 0LL, 0LL);
    ((void (*)(UCharIterator *, void, void))iter2->move)(iter2, 0LL, 0LL);
    while (1)
    {
      int v7 = ((uint64_t (*)(UCharIterator *))iter1->next)(iter1);
      int v8 = ((uint64_t (*)(UCharIterator *))iter2->next)(iter2);
      if (v7 != v8) {
        break;
      }
      if (v7 == -1) {
        return 0;
      }
    }

    unsigned int v9 = v8;
    if (v6)
    {
      if (v7 >= 55296 && v8 >= 55296)
      {
        if (v7 >> 10 > 0x36
          || ((unsigned int (*)(UCharIterator *))iter1->current)(iter1) >> 10 != 55)
        {
          if (v7 >> 10 != 55
            || (((void (*)(UCharIterator *))iter1->previous)(iter1),
                ((unsigned int (*)(UCharIterator *))iter1->previous)(iter1) >> 10 != 54))
          {
            v7 -= 10240;
          }
        }

        if (v9 >> 10 > 0x36 || ((unsigned int (*)(UCharIterator *))iter2->current)(iter2) >> 10 != 55)
        {
          if (v9 >> 10 != 55
            || (((void (*)(UCharIterator *))iter2->previous)(iter2),
                ((unsigned int (*)(UCharIterator *))iter2->previous)(iter2) >> 10 != 54))
          {
            v9 -= 10240;
          }
        }
      }
    }

    return v7 - v9;
  }

  return result;
}

int32_t u_strCompare(const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, UBool codePointOrder)
{
  if (s1 && length1 >= -1 && s2 && length2 >= -1) {
    return sub_18087F540((unsigned __int16 *)s1, length1, (unsigned __int16 *)s2, length2, 0, codePointOrder);
  }
  else {
    return 0;
  }
}

int32_t u_strcmpCodePointOrder(const UChar *s1, const UChar *s2)
{
  return sub_18087F540((unsigned __int16 *)s1, -1, (unsigned __int16 *)s2, -1, 0, 1);
}

int32_t u_strncmp(const UChar *ucs1, const UChar *ucs2, int32_t n)
{
  int v3 = n - 1;
  if (n < 1) {
    return 0;
  }
  int v5 = *ucs1;
  int32_t result = v5 - *ucs2;
  if (v5) {
    BOOL v7 = v5 == *ucs2;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    int v8 = ucs2 + 1;
    unsigned int v9 = ucs1 + 1;
    while (v3)
    {
      int v11 = *v9++;
      int v10 = v11;
      int v12 = *v8++;
      int32_t result = v10 - v12;
      --v3;
      if (v10) {
        BOOL v13 = result == 0;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        return result;
      }
    }

    return 0;
  }

  return result;
}

int32_t u_strncmpCodePointOrder(const UChar *s1, const UChar *s2, int32_t n)
{
  return sub_18087F540((unsigned __int16 *)s1, n, (unsigned __int16 *)s2, n, 1, 1);
}

UChar *__cdecl u_strcpy(UChar *dst, const UChar *src)
{
  uint64_t v2 = 0LL;
  do
  {
    int v3 = src[v2];
    dst[v2++] = v3;
  }

  while (v3);
  return dst;
}

UChar *__cdecl u_strncpy(UChar *dst, const UChar *src, int32_t n)
{
  if (n >= 1)
  {
    int v3 = dst;
    do
    {
      int v4 = *src++;
      *v3++ = v4;
      if (v4) {
        BOOL v5 = n > 1;
      }
      else {
        BOOL v5 = 0;
      }
      --n;
    }

    while (v5);
  }

  return dst;
}

int32_t u_countChar32(const UChar *s, int32_t length)
{
  int32_t result = 0;
  if (!s || length < -1) {
    return result;
  }
  if ((length & 0x80000000) == 0)
  {
    if (length)
    {
      int32_t result = 0;
      do
      {
        if (length != 1 && (*s & 0xFC00) == 0xD800 && (s[1] & 0xFC00) == 0xDC00)
        {
          int v4 = -2;
          uint64_t v5 = 2LL;
        }

        else
        {
          int v4 = -1;
          uint64_t v5 = 1LL;
        }

        s += v5;
        ++result;
        length += v4;
      }

      while (length);
      return result;
    }

    return 0;
  }

  UChar v6 = *s;
  if (!*s) {
    return 0;
  }
  int32_t result = 0;
  do
  {
    BOOL v7 = s + 1;
    if ((v6 & 0xFC00) == 0xD800)
    {
      int v8 = s[1] & 0xFC00;
      unsigned int v9 = s + 2;
      if (v8 == 56320) {
        BOOL v7 = v9;
      }
    }

    UChar v6 = *v7;
    ++result;
    s = v7;
  }

  while (*v7);
  return result;
}

UBool u_strHasMoreChar32Than(const UChar *s, int32_t length, int32_t number)
{
  if (number < 0) {
    return 1;
  }
  UBool v3 = 0;
  if (s && length >= -1)
  {
    if (length == -1)
    {
      UChar v4 = *s;
      if (*s)
      {
        int v5 = number + 1;
        while (--v5)
        {
          UChar v6 = s + 1;
          if ((v4 & 0xFC00) == 0xD800 && (s[1] & 0xFC00) == 0xDC00) {
            UChar v6 = s + 2;
          }
          UChar v4 = *v6;
          s = v6;
          if (!*v6) {
            return 0;
          }
        }

        return 1;
      }
    }

    else
    {
      int v7 = length - number;
      if (length - number >= 1 && length)
      {
        int v8 = number + 1;
        unsigned int v9 = &s[length];
        while (--v8)
        {
          int v10 = s + 1;
          BOOL v11 = (*s & 0xFC00) != 0xD800 || v10 == v9;
          if (!v11 && (*v10 & 0xFC00) == 0xDC00)
          {
            if (v7 < 2) {
              return 0;
            }
            int v10 = s + 2;
            --v7;
          }

          UBool v3 = 0;
          s = v10;
          if (v10 == v9) {
            return v3;
          }
        }

        return 1;
      }
    }

    return 0;
  }

  return v3;
}

UBool u_strIsWellFormed(const UChar *s, int32_t length)
{
  UBool v2 = 0;
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (s && length >= -1)
  {
    int v23 = 0;
    char v22 = 0;
    memset(v31, 0, sizeof(v31));
    __int128 v30 = 0u;
    __int128 v29 = 0u;
    __int128 v28 = 0u;
    __int128 v27 = 0u;
    __int128 v26 = 0u;
    __int128 v25 = 0u;
    uint64_t v21 = 0LL;
    char v24 = 0;
    unsigned int v4 = 0;
    if (length < 0)
    {
      BOOL v13 = s;
      while (1)
      {
        UChar32 v15 = *v13++;
        UChar32 v14 = v15;
        if (!v15) {
          break;
        }
        if ((v14 & 0xFC00) == 0xD800)
        {
          int v16 = *v13;
          BOOL v17 = (v16 & 0xFC00) == 56320;
          UChar32 v18 = (v14 << 10) - 56613888 + v16;
          if (v17) {
            BOOL v13 = s + 2;
          }
          if (v17) {
            UChar32 v14 = v18;
          }
        }

        BOOL v19 = sub_18087FD44(v14, v4, &v23, &v22, (uint64_t)&v24, (int *)&v21 + 1, (int *)&v21);
        s = v13;
        unsigned int v4 = v14;
        if (!v19) {
          return 0;
        }
      }
    }

    else
    {
      int v5 = &s[length];
      while (s < v5)
      {
        int v7 = s + 1;
        UChar32 v6 = *s;
        if ((v6 & 0xFC00) == 0xD800 && v7 < v5)
        {
          int v9 = *v7;
          BOOL v10 = (v9 & 0xFC00) == 56320;
          UChar32 v11 = (v6 << 10) - 56613888 + v9;
          if (v10) {
            int v7 = s + 2;
          }
          if (v10) {
            UChar32 v6 = v11;
          }
        }

        BOOL v12 = sub_18087FD44(v6, v4, &v23, &v22, (uint64_t)&v24, (int *)&v21 + 1, (int *)&v21);
        s = v7;
        unsigned int v4 = v6;
        if (!v12) {
          return 0;
        }
      }
    }

    return 1;
  }

  return v2;
}

BOOL sub_18087FD44(UChar32 c, unsigned int a2, _DWORD *a3, _BYTE *a4, uint64_t a5, int *a6, int *a7)
{
  if (*a4)
  {
    if (c == 917631)
    {
      *a4 = 0;
      return 1LL;
    }

    return (c - 917631) >= 0xFFFFFFA1;
  }

  if (c <= 767)
  {
    *a3 = 0;
    goto LABEL_17;
  }

  if ((c - 8233) < 6 || (c - 8294) < 4)
  {
    *a3 = 0;
    if (c == 8297)
    {
      if (*a7 >= 1)
      {
        int v11 = *a6;
        do
        {
          if (v11 < 1) {
            break;
          }
          *a6 = v11 - 1;
          int v12 = *(char *)(a5 + v11--);
        }

        while ((v12 & 0x80000000) == 0);
        --*a7;
      }

      return 1LL;
    }

    if (c == 8236)
    {
      uint64_t v13 = *a6;
      return 1LL;
    }

    if (c != 8233)
    {
      uint64_t v14 = *a6;
      int v15 = *(_BYTE *)(a5 + v14) & 0x7F;
      unsigned int v16 = v15 + 1;
      switch(c)
      {
        case 8234:
        case 8237:
          goto LABEL_41;
        case 8235:
        case 8238:
          goto LABEL_38;
        case 8236:
          goto LABEL_43;
        default:
          if (c == 8294) {
            goto LABEL_41;
          }
          if (c != 8295) {
            goto LABEL_43;
          }
LABEL_38:
          if ((v16 & 1) == 0) {
            goto LABEL_42;
          }
          if (c == 8294 || c == 8237)
          {
LABEL_41:
            if ((v16 & 1) != 0) {
LABEL_42:
            }
              unsigned int v16 = v15 + 2;
          }

UChar *__cdecl u_memcpy(UChar *dest, const UChar *src, int32_t count)
{
  if (count >= 1) {
    memcpy(dest, src, 2LL * count);
  }
  return dest;
}

UChar *__cdecl u_memmove(UChar *dest, const UChar *src, int32_t count)
{
  if (count >= 1) {
    memmove(dest, src, 2LL * count);
  }
  return dest;
}

UChar *__cdecl u_memset(UChar *dest, UChar c, int32_t count)
{
  if (count >= 1)
  {
    UBool v3 = dest;
    do
      *v3++ = c;
    while (v3 < &dest[count]);
  }

  return dest;
}

int32_t u_memcmp(const UChar *buf1, const UChar *buf2, int32_t count)
{
  if (count < 1) {
    return 0;
  }
  UBool v3 = &buf1[count];
  while (1)
  {
    int32_t v4 = *buf1 - *buf2;
    if (v4) {
      break;
    }
    ++buf1;
    ++buf2;
    if (buf1 >= v3) {
      return 0;
    }
  }

  return v4;
}

int32_t u_memcmpCodePointOrder(const UChar *s1, const UChar *s2, int32_t count)
{
  return sub_18087F540((unsigned __int16 *)s1, count, (unsigned __int16 *)s2, count, 0, 1);
}

UChar32 u_unescapeAt(UNESCAPE_CHAR_AT charAt, int32_t *offset, int32_t length, void *context)
{
  UNESCAPE_CHAR_AT v5 = (UNESCAPE_CHAR_AT)*offset;
  *int32_t offset = (_DWORD)v5 + 1;
  unsigned int v9 = ((uint64_t (*)(UNESCAPE_CHAR_AT, void *))charAt)(v5, context);
  UChar32 v10 = v9;
  int v11 = 4;
  if (v9 == 85)
  {
    int v36 = (int)v5;
    UNESCAPE_CHAR_AT v5 = charAt;
    char v37 = context;
    int v13 = 0;
    unsigned int v14 = 0;
    int v12 = 8;
    char v34 = 1;
    int v15 = 8;
LABEL_13:
    int v35 = v15;
    goto LABEL_16;
  }

  int v12 = 4;
  if (v9 == 117)
  {
LABEL_15:
    int v35 = v11;
    int v36 = (int)v5;
    UNESCAPE_CHAR_AT v5 = charAt;
    char v37 = context;
    int v13 = 0;
    unsigned int v14 = 0;
    LOBYTE(v1sub_18086E18C((uint64_t)this, 1) = 4;
    char v34 = 1;
LABEL_16:
    int32_t v16 = length;
    if (*offset < length)
    {
      int v17 = v13;
      char v18 = v13;
      while (1)
      {
        UChar32 v19 = ((uint64_t (*)(void))v5)();
        UChar32 v10 = v19;
        if (v13)
        {
          if ((v19 & 0xFFF8) != 0x30) {
            goto LABEL_36;
          }
          int v20 = v19 - 48;
          if (v19 - 48 < 0) {
            goto LABEL_36;
          }
        }

        else
        {
          int v20 = v19 - 48;
          if ((v19 - 48) > 9)
          {
            if ((v19 - 65) > 5)
            {
              int v20 = v19 - 87;
              if (v19 - 87 < 0) {
                goto LABEL_36;
              }
              goto LABEL_26;
            }

            int v20 = v19 - 55;
          }

          if (v20 < 0) {
            goto LABEL_36;
          }
        }

int32_t u_unescape(const char *src, UChar *dest, int32_t destCapacity)
{
  int32_t v6 = 0;
LABEL_2:
  for (uint64_t i = 0LL; src[i]; ++i)
  {
    if (src[i] == 92)
    {
      int32_t offset = 0;
      if (i)
      {
        if (dest)
        {
          else {
            int32_t v8 = (destCapacity - v6) & ~((destCapacity - v6) >> 31);
          }
          u_charsToUChars(src, &dest[v6], v8);
        }

        v6 += i;
      }

      int32_t v9 = strlen(&src[i + 1]);
      unsigned int v10 = u_unescapeAt((UNESCAPE_CHAR_AT)sub_180880674, &offset, v9, (void *)&src[i + 1]);
      uint64_t v11 = offset;
      if (!offset)
      {
        int32_t v6 = 0;
        if (!dest || destCapacity < 1) {
          return v6;
        }
LABEL_36:
        *dest = 0;
        return v6;
      }

      if (dest && (v10 < 0x10000 ? (int v12 = 1) : (int v12 = 2), v12 <= destCapacity - v6))
      {
        if (HIWORD(v10))
        {
          unsigned int v14 = &dest[v6];
          *unsigned int v14 = (v10 >> 10) - 10304;
          v14[1] = v10 & 0x3FF | 0xDC00;
          int v13 = 2;
        }

        else
        {
          dest[v6] = v10;
          int v13 = 1;
        }
      }

      else if (v10 < 0x10000)
      {
        int v13 = 1;
      }

      else
      {
        int v13 = 2;
      }

      src += v11 + i + 1;
      v6 += v13;
      goto LABEL_2;
    }
  }

  if (i)
  {
    if (dest)
    {
      else {
        int32_t v15 = (destCapacity - v6) & ~((destCapacity - v6) >> 31);
      }
      u_charsToUChars(src, &dest[v6], v15);
    }

    v6 += i;
  }

  if (dest && v6 < destCapacity)
  {
    dest += v6;
    goto LABEL_36;
  }

  return v6;
}

uint64_t sub_180880674(int a1, uint64_t a2)
{
  UChar us = 0;
  u_charsToUChars((const char *)(a2 + a1), &us, 1);
  return us;
}

uint64_t u_asciiToUpper(int a1)
{
  else {
    return (unsigned __int16)(a1 - 32);
  }
}

uint64_t u_terminateUChars(uint64_t a1, int a2, uint64_t a3, int *a4)
{
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      int v4 = *a4;
      if (*a4 <= 0)
      {
        if ((int)a3 >= a2)
        {
          if ((_DWORD)a3 == a2) {
            int v5 = -124;
          }
          else {
            int v5 = 15;
          }
        }

        else
        {
          int v5 = 0;
          *(_WORD *)(a1 + 2LL * a3) = 0;
          if (v4 != -124) {
            return a3;
          }
        }

        *a4 = v5;
      }
    }
  }

  return a3;
}

uint64_t u_terminateChars(uint64_t a1, int a2, uint64_t a3, int *a4)
{
  if (a4 && (a3 & 0x80000000) == 0 && *a4 <= 0)
  {
    if ((int)a3 >= a2)
    {
      if ((_DWORD)a3 == a2) {
        int v4 = -124;
      }
      else {
        int v4 = 15;
      }
    }

    else
    {
      int v4 = 0;
      *(_BYTE *)(a1 + a3) = 0;
      if (*a4 != -124) {
        return a3;
      }
    }

    *a4 = v4;
  }

  return a3;
}

uint64_t u_terminateUChar32s(uint64_t a1, int a2, uint64_t a3, int *a4)
{
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      int v4 = *a4;
      if (*a4 <= 0)
      {
        if ((int)a3 >= a2)
        {
          if ((_DWORD)a3 == a2) {
            int v5 = -124;
          }
          else {
            int v5 = 15;
          }
        }

        else
        {
          int v5 = 0;
          *(_DWORD *)(a1 + 4LL * a3) = 0;
          if (v4 != -124) {
            return a3;
          }
        }

        *a4 = v5;
      }
    }
  }

  return a3;
}

uint64_t u_terminateWChars(uint64_t a1, int a2, uint64_t a3, int *a4)
{
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      int v4 = *a4;
      if (*a4 <= 0)
      {
        if ((int)a3 >= a2)
        {
          if ((_DWORD)a3 == a2) {
            int v5 = -124;
          }
          else {
            int v5 = 15;
          }
        }

        else
        {
          int v5 = 0;
          *(_DWORD *)(a1 + 4LL * a3) = 0;
          if (v4 != -124) {
            return a3;
          }
        }

        *a4 = v5;
      }
    }
  }

  return a3;
}

unsigned __int16 *ustr_hashUCharsN(unsigned __int16 *result, int a2)
{
  if (result)
  {
    int v2 = a2 - 1;
    if (a2 < 1)
    {
      return 0LL;
    }

    else
    {
      UBool v3 = result;
      LODWORD(result) = 0;
      int v4 = &v3[a2];
      if (a2 >= 32) {
        int v2 = a2 - 32;
      }
      uint64_t v5 = 2LL * (v2 >> 5) + 2;
      do
      {
        BOOL result = (unsigned __int16 *)(*v3 + 37 * (_DWORD)result);
        UBool v3 = (unsigned __int16 *)((char *)v3 + v5);
      }

      while (v3 < v4);
    }
  }

  return result;
}

unsigned __int8 *ustr_hashCharsN(unsigned __int8 *result, int a2)
{
  if (result)
  {
    int v2 = a2 - 1;
    if (a2 < 1)
    {
      return 0LL;
    }

    else
    {
      UBool v3 = result;
      LODWORD(result) = 0;
      int v4 = &v3[a2];
      if (a2 >= 32) {
        int v2 = a2 - 32;
      }
      uint64_t v5 = ((v2 >> 5) + 1);
      do
      {
        BOOL result = (unsigned __int8 *)(*v3 + 37 * (_DWORD)result);
        v3 += v5;
      }

      while (v3 < v4);
    }
  }

  return result;
}

char *ustr_hashICharsN(char *result, int a2)
{
  if (result)
  {
    int v2 = a2 - 1;
    if (a2 < 1)
    {
      return 0LL;
    }

    else
    {
      UBool v3 = result;
      LODWORD(result) = 0;
      int v4 = &v3[a2];
      if (a2 >= 32) {
        int v2 = a2 - 32;
      }
      uint64_t v5 = ((v2 >> 5) + 1);
      do
      {
        BOOL result = (char *)(37 * (_DWORD)result + uprv_asciitolower(*v3));
        v3 += v5;
      }

      while (v3 < v4);
    }
  }

  return result;
}

UChar *__cdecl u_strFromUTF32WithSub( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const UChar32 *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)
{
  if (src) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = srcLength == 0;
  }
  char v10 = !v9;
  if ((destCapacity & 0x80000000) == 0 && srcLength >= -1 && (v10 & 1) == 0)
  {
    int32_t v8 = dest;
    BOOL v11 = destCapacity && dest == 0LL;
    if (!v11 && subchar < 1114112 && (subchar & 0xFFFFF800) != 0xD800)
    {
      if (pNumSubstitutions) {
        *pNumSubstitutions = 0;
      }
      if (dest) {
        int v12 = &dest[destCapacity];
      }
      else {
        int v12 = 0LL;
      }
      if (srcLength < 0)
      {
        unsigned int v23 = *src;
        if (!*src)
        {
          int v13 = 0;
          int32_t v16 = 0;
          int32_t v15 = dest;
LABEL_64:
          uint64_t v25 = v13 + ((unint64_t)((char *)v15 - (char *)dest) >> 1);
          if (pDestLength) {
            *int32_t pDestLength = v25;
          }
          if (pNumSubstitutions) {
            *pNumSubstitutions = v16;
          }
          u_terminateUChars((uint64_t)dest, destCapacity, v25, (int *)pErrorCode);
          return v8;
        }

        int v13 = 0;
        int32_t v15 = dest;
        while (v23 >> 11 < 0x1B || (v23 & 0xFFFFE000) == 0xE000)
        {
          if (v15 >= v12) {
            ++v13;
          }
          else {
            *v15++ = v23;
          }
          UChar32 v24 = src[1];
          ++src;
          unsigned int v23 = v24;
          if (!v24) {
            goto LABEL_61;
          }
        }

        unsigned int v14 = src;
        do
        {
          UChar32 v26 = v14[1];
          ++v14;
        }

        while (v26);
      }

      else
      {
        int v13 = 0;
        if (src) {
          unsigned int v14 = &src[srcLength];
        }
        else {
          unsigned int v14 = 0LL;
        }
        int32_t v15 = dest;
      }

      if (src >= v14)
      {
LABEL_61:
        int32_t v16 = 0;
      }

      else
      {
        int32_t v16 = 0;
        BOOL v18 = subchar >> 11 < 0x1B || (subchar & 0xFFFFE000) == 57344;
        do
        {
          unsigned int v20 = *src++;
          unsigned int v19 = v20;
          if (v20 >> 11 < 0x1B || (v19 & 0xFFFFE000) == 0xE000)
          {
LABEL_41:
            if (v15 >= v12) {
              ++v13;
            }
            else {
              *v15++ = v19;
            }
          }

          else
          {
            while ((v19 - 0x10000) >> 20)
            {
              if (subchar < 0)
              {
                int32_t v8 = 0LL;
                UErrorCode v21 = U_INVALID_CHAR_FOUND;
                goto LABEL_51;
              }

              ++v16;
              unsigned int v19 = subchar;
              if (v18)
              {
                LOWORD(v19) = subchar;
                goto LABEL_41;
              }
            }

            if (v15 && v15 + 2 <= v12)
            {
              *int32_t v15 = (v19 >> 10) - 10304;
              v15[1] = v19 & 0x3FF | 0xDC00;
              v15 += 2;
            }

            else
            {
              v13 += 2;
            }
          }
        }

        while (src < v14);
      }

      goto LABEL_64;
    }
  }

  int32_t v8 = 0LL;
  UErrorCode v21 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_51:
  *UErrorCode pErrorCode = v21;
  return v8;
}

UChar *__cdecl u_strFromUTF32( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const UChar32 *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return u_strFromUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, -1, 0LL, pErrorCode);
}

UChar32 *__cdecl u_strToUTF32WithSub( UChar32 *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)
{
  if (src) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = srcLength == 0;
  }
  char v10 = !v9;
  if (destCapacity < 0
    || srcLength < -1
    || (v10 & 1) != 0
    || ((v8 = dest, destCapacity) ? (BOOL v11 = dest == 0LL) : (BOOL v11 = 0),
        v11 || subchar >= 1114112 || (subchar & 0xFFFFF800) == 0xD800))
  {
    int32_t v8 = 0LL;
    UErrorCode v16 = U_ILLEGAL_ARGUMENT_ERROR;
    goto LABEL_29;
  }

  if (pNumSubstitutions) {
    *pNumSubstitutions = 0;
  }
  if (dest) {
    int v12 = &dest[destCapacity];
  }
  else {
    int v12 = 0LL;
  }
  int v13 = 0;
  if (srcLength < 0)
  {
    UChar32 v17 = *src;
    BOOL v18 = *src != 0;
    if (!*src || (v17 & 0xF800) == 0xD800)
    {
      unsigned int v19 = src;
      int32_t v15 = dest;
    }

    else
    {
      int v13 = 0;
      int32_t v15 = dest;
      do
      {
        if (v15 >= v12) {
          ++v13;
        }
        else {
          *v15++ = v17;
        }
        unsigned int v19 = src + 1;
        UChar32 v17 = src[1];
        BOOL v18 = src[1] != 0;
        if (src[1]) {
          BOOL v20 = (v17 & 0xF800) == 55296;
        }
        else {
          BOOL v20 = 1;
        }
        ++src;
      }

      while (!v20);
    }

    if (!v18)
    {
LABEL_62:
      int32_t v22 = 0;
LABEL_63:
      uint64_t v26 = v13 + ((unint64_t)((char *)v15 - (char *)v8) >> 2);
      if (pDestLength) {
        *int32_t pDestLength = v26;
      }
      if (pNumSubstitutions) {
        *pNumSubstitutions = v22;
      }
      u_terminateUChar32s((uint64_t)v8, destCapacity, v26, (int *)pErrorCode);
      return v8;
    }

    unsigned int v14 = v19;
    do
    {
      int v21 = v14[1];
      ++v14;
    }

    while (v21);
    src = v19;
  }

  else
  {
    if (src) {
      unsigned int v14 = &src[srcLength];
    }
    else {
      unsigned int v14 = 0LL;
    }
    int32_t v15 = dest;
  }

  if (src >= v14) {
    goto LABEL_62;
  }
  int32_t v22 = 0;
  while (1)
  {
    UChar32 v24 = src + 1;
    int v23 = *src;
    if ((v23 & 0xF800) != 0xD800)
    {
      ++src;
      goto LABEL_57;
    }

    if ((v23 & 0x400) != 0) {
      break;
    }
    if (v24 >= v14) {
      break;
    }
    int v25 = *v24;
    if ((v25 & 0xFC00) != 0xDC00) {
      break;
    }
    src += 2;
    int v23 = v25 + (v23 << 10) - 56613888;
LABEL_57:
    if (v15 >= v12) {
      ++v13;
    }
    else {
      *v15++ = v23;
    }
    if (src >= v14) {
      goto LABEL_63;
    }
  }

  if ((subchar & 0x80000000) == 0)
  {
    ++v22;
    ++src;
    int v23 = subchar;
    goto LABEL_57;
  }

  int32_t v8 = 0LL;
  UErrorCode v16 = U_INVALID_CHAR_FOUND;
LABEL_29:
  *UErrorCode pErrorCode = v16;
  return v8;
}

UChar32 *__cdecl u_strToUTF32( UChar32 *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return u_strToUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, -1, 0LL, pErrorCode);
}

UChar *__cdecl u_strFromUTF8WithSub( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)
{
  if (src) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = srcLength == 0;
  }
  char v14 = !v13;
  if (destCapacity < 0
    || srcLength < -1
    || (v14 & 1) != 0
    || ((v8 = dest, destCapacity) ? (BOOL v15 = dest == 0LL) : (BOOL v15 = 0),
        v15 || subchar >= 1114112 || (subchar & 0xFFFFF800) == 0xD800))
  {
    int32_t v8 = 0LL;
    UErrorCode v33 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_55:
    *UErrorCode pErrorCode = v33;
    return v8;
  }

  if (pNumSubstitutions) {
    *pNumSubstitutions = 0;
  }
  UChar32 v17 = &dest[destCapacity];
  if ((srcLength & 0x80000000) == 0)
  {
    int32_t v69 = 0;
    puint64_t i = 0;
    LODWORD(v18) = 0;
    if (srcLength / 3 >= destCapacity) {
      int v19 = destCapacity;
    }
    else {
      int v19 = srcLength / 3;
    }
    BOOL v20 = dest;
    if (v19 < 3)
    {
LABEL_25:
      int v21 = 0;
      if ((int)v18 < srcLength && v20 < v17)
      {
        while (1)
        {
          int v22 = v18;
          uint64_t v23 = (int)v18 + 1LL;
          puint64_t i = v18 + 1;
          UChar32 v24 = src[(int)v18];
          if ((v24 & 0x80) != 0)
          {
            if ((v24 & 0xF0) == 0xE0)
            {
              uint64_t v26 = (int)v18 + 2LL;
              if (v22 + 2 < srcLength)
              {
                unsigned int v27 = src[v23];
                if (((a00000000000000[v24 & 0xF] >> (v27 >> 5)) & 1) != 0)
                {
                  unsigned int v28 = src[v26] ^ 0x80;
                  if (v28 <= 0x3F)
                  {
                    *v20++ = ((_WORD)v24 << 12) | ((v27 & 0x3F) << 6) | v28;
                    int32_t v29 = v22 + 3;
LABEL_46:
                    puint64_t i = v29;
                    goto LABEL_29;
                  }
                }
              }
            }

            else if ((v24 + 32) >= 0xE2u && (_DWORD)v23 != srcLength)
            {
              unsigned int v31 = src[v23] ^ 0x80;
              if (v31 <= 0x3F)
              {
                *v20++ = ((v24 & 0x1F) << 6) | v31;
                int32_t v29 = v22 + 2;
                goto LABEL_46;
              }
            }

            unsigned int v32 = utf8_nextCharSafeBody((const uint8_t *)src, &pi, srcLength, v24, -1);
            if ((v32 & 0x80000000) != 0)
            {
              ++v69;
              unsigned int v32 = subchar;
            }

            if (HIWORD(v32))
            {
              *BOOL v20 = (v32 >> 10) - 10304;
              if (v20 + 1 >= v17)
              {
                int v21 = 1;
                LODWORD(v18) = pi;
                ++v20;
                break;
              }

              v20[1] = v32 & 0x3FF | 0xDC00;
              v20 += 2;
            }

            else
            {
              *v20++ = v32;
            }
          }

          else
          {
            *v20++ = v24;
          }

LABEL_151:
        unsigned int v63 = utf8_nextCharSafeBody((const uint8_t *)src, &v71, -1, v35, -1);
        if ((v63 & 0x80000000) != 0)
        {
          ++v61;
          unsigned int v63 = subchar;
        }

        if (v63 < 0x10000) {
          int v64 = 1;
        }
        else {
          int v64 = 2;
        }
        v21 += v64;
        LODWORD(v34) = v71;
      }

      else
      {
        ++v21;
        LODWORD(v34) = v62 + 2;
LABEL_150:
        int32_t v71 = v34;
      }

LABEL_159:
  if (pNumSubstitutions) {
    *pNumSubstitutions = v61;
  }
  uint64_t v65 = v21 + ((unint64_t)((char *)v20 - (char *)v8) >> 1);
  if (pDestLength) {
    *int32_t pDestLength = v65;
  }
  u_terminateUChars((uint64_t)v8, destCapacity, v65, (int *)pErrorCode);
  return v8;
}

    if (a4)
    {
LABEL_160:
      if ((_DWORD)v13 == 2 && v29 != 3)
      {
        BOOL v39 = 1;
        LODWORD(v13) = 2;
        goto LABEL_175;
      }

          icu::UnicodeString::~UnicodeString(v75, (icu::UnicodeString *)v130);
          if (!*((_DWORD *)v167 + v58))
          {
            *((_DWORD *)v167 + v58) = v76;
            int v105 = v73;
          }

          a2 = v108;
          BOOL v83 = 0uLL;
          if (v109 != 30)
          {
            *(void *)&v130[0] = 0LL;
            memset(&v130[1], 0, 48);
            int v131 = 0LL;
            *((void *)&v130[0] + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
            LOWORD(v130[1]) = 2;
            icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v130,  (const icu::UnicodeString *)&v142,  1,  1,  0,  a6);
            int v129 = 0LL;
            __int32 v127 = 0u;
            v128 = 0u;
            unsigned int v126 = 0u;
            int v125 = (UChar *)off_18971B688;
            LOWORD(v126) = 2;
            if (*v107 == 2) {
              icu::UnicodeString::toLower((const UChar **)v135, (const icu::Locale *)v108);
            }
            icu::SimpleFormatter::format( (icu::SimpleFormatter *)v130,  (const icu::UnicodeString *)v135,  (icu::UnicodeString *)&v125,  a6);
            int v84 = (void *)*(unsigned int *)a6;
            icu::UnicodeString::operator=((UChar **)v135, &v125);
            icu::UnicodeString::~UnicodeString(v85, (icu::UnicodeString *)&v125);
            icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v130);
            BOOL v83 = 0uLL;
          }

          if (v110 != 1)
          {
            int v131 = 0LL;
            v130[2] = v83;
            v130[3] = v83;
            v130[0] = v83;
            v130[1] = v83;
            sub_18092CBC0((uint64_t)&v147, v113, a6, (uint64_t)&v125);
            *((void *)&v130[0] + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
            LOWORD(v130[1]) = 2;
            icu::SimpleFormatter::applyPatternMinMaxArguments( (icu::SimpleFormatter *)v130,  (const icu::UnicodeString *)&v125,  1,  1,  0,  a6);
            icu::UnicodeString::~UnicodeString(v86, (icu::UnicodeString *)&v125);
            int v129 = 0LL;
            __int32 v127 = 0u;
            v128 = 0u;
            unsigned int v126 = 0u;
            int v125 = (UChar *)off_18971B688;
            LOWORD(v126) = 2;
            if (*v107 == 2) {
              icu::UnicodeString::toLower((const UChar **)v135, (const icu::Locale *)v108);
            }
            icu::SimpleFormatter::format( (icu::SimpleFormatter *)v130,  (const icu::UnicodeString *)v135,  (icu::UnicodeString *)&v125,  a6);
            int v84 = (void *)*(unsigned int *)a6;
            if ((int)v84 > 0)
            {
LABEL_181:
              icu::UnicodeString::~UnicodeString(v84, (icu::UnicodeString *)&v125);
LABEL_182:
              icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v130);
              goto LABEL_183;
            }

            icu::UnicodeString::operator=((UChar **)v135, &v125);
            icu::UnicodeString::~UnicodeString(v87, (icu::UnicodeString *)&v125);
            icu::SimpleFormatter::~SimpleFormatter((icu::SimpleFormatter *)v130);
            BOOL v83 = 0uLL;
          }

          if ((__int16)v111[4] < 0)
          {
            if (*(_DWORD *)(a5 + v57 + 12)) {
              goto LABEL_175;
            }
          }

          else if (v111[4] >> 5)
          {
LABEL_175:
            *((void *)&v130[3] + sub_18086E18C((uint64_t)this, 1) = 0LL;
            *(_OWORD *)((char *)&v130[1] + 8) = v83;
            *(_OWORD *)((char *)&v130[2] + 8) = v83;
            *(_OWORD *)((char *)v130 + 8) = v83;
            *(void *)&v130[0] = off_18971B688;
            WORD4(v130[0]) = 2;
            icu::SimpleFormatter::format( (icu::SimpleFormatter *)v168,  (const icu::UnicodeString *)v111,  (const icu::UnicodeString *)v135,  (icu::UnicodeString *)v130,  a6);
            icu::UnicodeString::operator=((UChar **)v111, (UChar **)v130);
            icu::UnicodeString::~UnicodeString(v88, (icu::UnicodeString *)v130);
LABEL_178:
            icu::UnicodeString::~UnicodeString(v89, (icu::UnicodeString *)v135);
            unsigned int v50 = 0uLL;
            goto LABEL_179;
          }

          icu::UnicodeString::operator=((UChar **)v111, (UChar **)v135);
          goto LABEL_178;
        }

        if (icu::UnicodeString::doEqualsSubstring((uint64_t)v130, v64 - 3, 3, (uint64_t)L"{0}", 0, 3))
        {
          char v67 = v62 - 4LL;
          if ((SWORD4(v130[0]) & 0x8000u) == 0) {
            unsigned int v68 = WORD4(v130[0]) >> 5;
          }
          else {
            unsigned int v68 = HIDWORD(v130[0]);
          }
          if (v68 <= v67)
          {
            uint64_t v70 = 0xFFFF;
          }

          else
          {
            int32_t v69 = (char *)v130 + 10;
            if ((BYTE8(v130[0]) & 2) == 0) {
              int32_t v69 = (char *)*((void *)&v130[1] + 1);
            }
            uint64_t v70 = *(unsigned __int16 *)&v69[2 * (int)v67];
          }

          if (u_isJavaSpaceChar(v70))
          {
            icu::UnicodeString::unBogus((uint64_t)v135);
            else {
              uint64_t v80 = *(unsigned int *)&v135[12];
            }
            icu::UnicodeString::doReplace( (icu::UnicodeString *)v135,  0LL,  v80,  (const icu::UnicodeString *)v130,  0,  v62 - 4LL);
            BOOL v75 = (char *)WORD4(v130[0]);
            if ((SWORD4(v130[0]) & 0x8000u) == 0) {
              int v81 = WORD4(v130[0]) >> 5;
            }
            else {
              int v81 = HIDWORD(v130[0]);
            }
            if (v81 <= v67)
            {
              uint64_t v76 = 4;
              int v73 = 0xFFFF;
              goto LABEL_159;
            }

            BOOL v75 = (char *)v130 + 10;
            if ((BYTE8(v130[0]) & 2) == 0) {
              BOOL v75 = (char *)*((void *)&v130[1] + 1);
            }
            int v73 = *(unsigned __int16 *)&v75[2 * v67];
          }

          else
          {
            icu::UnicodeString::unBogus((uint64_t)v135);
            else {
              int v82 = *(unsigned int *)&v135[12];
            }
            icu::UnicodeString::doReplace( (icu::UnicodeString *)v135,  0LL,  v82,  (const icu::UnicodeString *)v130,  0,  (v62 - 3));
            int v73 = 0;
          }

          uint64_t v76 = 4;
          goto LABEL_159;
        }

        uint64_t v78 = v62 - 2;
        uint64_t v76 = 1;
        int v79 = icu::UnicodeString::indexOf((uint64_t)v130, (uint64_t)L"{0}", 0, 3, 1, v78);
        icu::UnicodeString::operator=((UChar **)v135, (UChar **)v130);
        if (v79 == -1)
        {
          int v73 = 0;
          goto LABEL_159;
        }

        icu::UnicodeString::~UnicodeString(v75, (icu::UnicodeString *)v130);
        int v90 = 16LL;
        *a6 = U_UNSUPPORTED_ERROR;
        a2 = v108;
LABEL_183:
        icu::UnicodeString::~UnicodeString((void *)v90, (icu::UnicodeString *)v135);
LABEL_184:
        unsigned int v41 = 1;
LABEL_185:
        for (uint64_t k = 80LL; k != -8; k -= 8LL)
          icu::UnicodeString::~UnicodeString(v49, (icu::UnicodeString *)&(&v136)[k]);
        icu::UnicodeString::~UnicodeString(v49, (icu::UnicodeString *)&v142);
LABEL_188:
        for (m = 80LL; m != -8; m -= 8LL)
          icu::UnicodeString::~UnicodeString(v40, (icu::UnicodeString *)&(&v147)[m]);
        icu::MeasureUnit::~MeasureUnit((icu::MeasureUnit *)v118);
        size_t v93 = 0uLL;
        if (v41) {
          goto LABEL_211;
        }
        BOOL v20 = (uint64_t)(v104 + 1);
        int v19 = *((int *)this + 2);
        if ((uint64_t)(v104 + 1) >= v19)
        {
LABEL_195:
          unsigned __int8 v94 = 0LL;
          while (1)
          {
            int v95 = *(_DWORD *)((char *)v167 + v94);
            if (v95 == 4) {
              break;
            }
            if (v95 == 2)
            {
              int v151 = 0LL;
              int v149 = v93;
              uint64_t v150 = v93;
              int8x8_t v148 = v93;
              uint64_t v147 = (UChar *)off_18971B688;
              LOWORD(v148) = 2;
              icu::UnicodeString::doAppend((uint64_t)&v147, (uint64_t)L"{0}", 0, 3LL);
              if (v105)
              {
                LOWORD(v136) = v105;
                icu::UnicodeString::doAppend((uint64_t)&v147, (uint64_t)&v136, 0, 1LL);
              }

              int v96 = *(unsigned __int16 *)(a5 + 8);
              int v97 = (__int16)v96;
              __int128 v98 = v96 >> 5;
              if (v97 >= 0) {
                int v99 = v98;
              }
              else {
                int v99 = *(unsigned int *)(a5 + 12);
              }
              icu::UnicodeString::doAppend((uint64_t)&v147, (const icu::UnicodeString *)a5, 0, v99);
              icu::UnicodeString::operator=((UChar **)a5, &v147);
              icu::UnicodeString::~UnicodeString(v100, (icu::UnicodeString *)&v147);
LABEL_207:
              size_t v93 = 0uLL;
            }

            v94 += 4LL;
            a5 += 64LL;
            if (v94 == 32) {
              goto LABEL_211;
            }
          }

          if (v105)
          {
            LOWORD(v147) = v105;
            icu::UnicodeString::doAppend(a5, (uint64_t)&v147, 0, 1LL);
          }

          icu::UnicodeString::doAppend(a5, (uint64_t)L"{0}", 0, 3LL);
          goto LABEL_207;
        }
      }

      memset(v130, 0, sizeof(v130));
      icu::StringPiece::StringPiece((icu::StringPiece *)&v114, "compound/power");
      *(void *)&v130[0] = (char *)v130 + 13;
      DWORD2(v130[0]) = 40;
      WORD6(v130[0]) = 0;
      DWORD2(v130[3]) = 0;
      icu::CharString::append((icu::CharString *)v130, v114, v115, a6);
      icu::CharString::appendNumber((icu::CharString *)v130, v30, a6);
      uint64_t v34 = 0LL;
      int v112 = *(char **)&v130[0];
      int v35 = DWORD2(v130[3]);
      __int32 v142 = &off_189727938;
      *(void *)&__int32 v143 = v28;
      *((void *)&v143 + sub_18086E18C((uint64_t)this, 1) = v24;
      *(void *)&__int32 v144 = &v147;
      do
      {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)&(&v147)[v34]);
        v34 += 8LL;
      }

      while (v34 != 88);
      int32_t v36 = ures_open("icudt74l-unit", v108[5], (int *)a6);
      if (*(int *)a6 > 0)
      {
LABEL_56:
        if (v36) {
          ures_close(v36);
        }
        icu::ResourceSink::~ResourceSink((icu::ResourceSink *)&v142);
        BOOL v39 = *a6;
        a2 = v108;
        if (*(int *)a6 < 1)
        {
          if (!BYTE4(v153[0])) {
            UChar32 v24 = (const char *)*((void *)&v153[0] + 1);
          }
          *((_DWORD *)v26 + 2) = 1;
          UErrorCode v33 = 0uLL;
        }

        else if (v39 == U_RESOURCE_TYPE_MISMATCH)
        {
          UErrorCode v33 = 0uLL;
          if (v110 >= 4) {
            *a6 = U_UNSUPPORTED_ERROR;
          }
        }

        else
        {
          UErrorCode v33 = 0uLL;
        }

        unsigned __int8 v40 = (void *)BYTE12(v130[0]);
        if (BYTE12(v130[0]))
        {
          uprv_free(*(void **)&v130[0]);
          UErrorCode v33 = 0uLL;
        }

        if (v39 > U_ZERO_ERROR)
        {
          unsigned int v41 = 1;
          goto LABEL_188;
        }

        goto LABEL_70;
      }

      int8x8_t v140 = 0LL;
      uint64_t v138 = 0u;
      __int32 v139 = 0u;
      __int32 v137 = 0u;
      __int32 v136 = (char *)&v137 + 5;
      LODWORD(v137) = 40;
      icu::StringPiece::StringPiece((icu::StringPiece *)v135, "units");
      icu::CharString::append((icu::CharString *)&v136, *(const char **)v135, *(int *)&v135[8], a6);
      UChar32 v37 = v107;
      if (*v107 == 1)
      {
        uint64_t v38 = "Short";
      }

      else
      {
        if (*v107)
        {
LABEL_52:
          icu::StringPiece::StringPiece((icu::StringPiece *)&v123, "/");
          icu::CharString::append((icu::CharString *)&v136, v123, v124, a6);
          icu::CharString::append((icu::CharString *)&v136, v112, v35, a6);
          uint64_t v122 = *a6;
          ures_getAllChildrenWithFallback(v36, v136, (uint64_t)&v142, (int *)&v122);
          if (*v37 == 1) {
            *a6 = v122;
          }
          if (BYTE4(v137)) {
            uprv_free(v136);
          }
          goto LABEL_56;
        }

        uint64_t v38 = "Narrow";
      }

      icu::StringPiece::StringPiece((icu::StringPiece *)&v125, v38);
      icu::CharString::append((icu::CharString *)&v136, (const char *)v125, v126, a6);
      UChar32 v37 = v107;
      goto LABEL_52;
    }
  }

UChar *__cdecl u_strFromUTF8( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return u_strFromUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, -1, 0LL, pErrorCode);
}

UChar *__cdecl u_strFromUTF8Lenient( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  if (src) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = srcLength == 0;
  }
  char v8 = !v7;
  if (destCapacity < 0 || srcLength < -1 || (v8 & 1) != 0 || (int32_t v6 = dest) == 0LL && destCapacity)
  {
    int32_t v6 = 0LL;
    UErrorCode v9 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_15:
    *UErrorCode pErrorCode = v9;
    return v6;
  }

  if ((srcLength & 0x80000000) == 0)
  {
    if (src) {
      BOOL v11 = &src[srcLength];
    }
    else {
      BOOL v11 = 0LL;
    }
    if (destCapacity < srcLength)
    {
      if (pDestLength) {
        *int32_t pDestLength = srcLength;
      }
      int32_t v6 = 0LL;
      UErrorCode v9 = U_BUFFER_OVERFLOW_ERROR;
      goto LABEL_15;
    }

    if (v11 - src < 4)
    {
      BOOL v15 = dest;
LABEL_65:
      while (src < v11)
      {
        BOOL v30 = src + 1;
        unsigned int v29 = *(unsigned __int8 *)src;
        if (v29 > 0xBF)
        {
          if (v29 > 0xDF)
          {
            uint64_t v32 = v11 - v30;
            if (v29 > 0xEF)
            {
              if (v32 < 3) {
                goto LABEL_78;
              }
              unsigned int v33 = (v29 << 18)
                  - 63447168
                  + (*((unsigned __int8 *)src + 1) << 12)
              *BOOL v15 = (v33 >> 10) - 10304;
              v15[1] = v33 & 0x3FF | 0xDC00;
              v15 += 2;
              src += 8;
            }

            else
            {
              if (v32 < 2) {
                goto LABEL_78;
              }
              *v15++ = (*((unsigned __int8 *)src + 1) << 6) + ((_WORD)v29 << 12) + *((unsigned __int8 *)src + 2) - 8320;
              src += 6;
            }
          }

          else
          {
            if (v30 >= v11) {
              goto LABEL_78;
            }
            __int16 v31 = *((unsigned __int8 *)src + 1);
            src += 2;
            *v15++ = v31 + ((_WORD)v29 << 6) - 12416;
          }
        }

        else
        {
          *v15++ = v29;
          ++src;
        }
      }

      int v12 = 0;
      goto LABEL_97;
    }

    BOOL v15 = dest;
    while (1)
    {
      unsigned int v21 = *(unsigned __int8 *)src;
      if (v21 > 0xBF)
      {
        int v22 = *((unsigned __int8 *)src + 1);
        if (v21 > 0xDF)
        {
          if (v21 > 0xEF)
          {
            int v26 = *((unsigned __int8 *)src + 2);
            int v27 = *((unsigned __int8 *)src + 3);
            src += 4;
            unsigned int v28 = (v21 << 18) - 63447168 + (v22 << 12) + (v26 << 6) + v27;
            *BOOL v15 = (v28 >> 10) - 10304;
            v15[1] = v28 & 0x3FF | 0xDC00;
            v15 += 2;
            goto LABEL_61;
          }

          __int16 v24 = ((_WORD)v22 << 6) + ((_WORD)v21 << 12);
          __int16 v25 = *((unsigned __int8 *)src + 2);
          src += 3;
          UChar v23 = v24 + v25 - 8320;
        }

        else
        {
          src += 2;
          UChar v23 = v22 + ((_WORD)v21 << 6) - 12416;
        }

        *v15++ = v23;
      }

      else
      {
        *v15++ = v21;
        ++src;
      }

char *__cdecl u_strToUTF8WithSub( char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)
{
  BOOL result = 0LL;
  if (dest) {
    char v10 = &dest[destCapacity];
  }
  else {
    char v10 = 0LL;
  }
  if (src) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = srcLength == 0;
  }
  char v14 = !v13;
  if (destCapacity < 0
    || srcLength < -1
    || (v14 & 1) != 0
    || (destCapacity ? (BOOL v15 = dest == 0LL) : (BOOL v15 = 0), v15 || subchar >= 1114112 || (subchar & 0xFFFFF800) == 0xD800))
  {
    BOOL result = 0LL;
    UErrorCode v30 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_63:
    *UErrorCode pErrorCode = v30;
    return result;
  }

  if (pNumSubstitutions) {
    *pNumSubstitutions = 0;
  }
  if (srcLength == -1)
  {
    unsigned int v29 = *src;
    if (!*src)
    {
      int32_t v23 = 0;
      LODWORD(v24) = (_DWORD)dest;
      goto LABEL_166;
    }

    int32_t v23 = 0;
    __int16 v24 = dest;
    while (1)
    {
      __int16 v31 = src + 1;
      if ((unsigned __int16)v29 > 0x7Fu)
      {
        if ((unsigned __int16)v29 > 0x7FFu)
        {
          if ((unsigned __int16)((unsigned __int16)(v29 + 0x2000) >> 11) <= 0x1Eu)
          {
            if (v10 - v24 < 3)
            {
              unsigned int v29 = 3;
              goto LABEL_173;
            }

            *__int16 v24 = ((unsigned __int16)v29 >> 12) | 0xE0;
            v24[1] = ((unsigned __int16)v29 >> 6) & 0x3F | 0x80;
            v24[2] = v29 & 0x3F | 0x80;
LABEL_76:
            v24 += 3;
            goto LABEL_96;
          }

          if ((v29 & 0x400) != 0 || (int v32 = *v31, (v32 & 0xFC00) != 0xDC00))
          {
            if (subchar < 0)
            {
LABEL_200:
              BOOL result = 0LL;
              UErrorCode v30 = U_INVALID_CHAR_FOUND;
              goto LABEL_63;
            }

            ++v23;
            unsigned int v33 = subchar;
          }

          else
          {
            __int16 v31 = src + 2;
            unsigned int v33 = v32 + ((unsigned __int16)v29 << 10) - 56613888;
          }

          if (v33 >= 0x80)
          {
            if (v33 >= 0x800)
            {
              if (v33 >> 11 >= 0x1B)
              {
                if (v33 - 1114112 >= 0xFFEFE000)
                {
                  if (v33 < 0x10000) {
                    unsigned int v29 = 3;
                  }
                  else {
                    unsigned int v29 = 4;
                  }
                }

                else
                {
                  unsigned int v29 = 0;
                }
              }

              else
              {
                unsigned int v29 = 3;
              }
            }

            else
            {
              unsigned int v29 = 2;
            }
          }

          else
          {
            unsigned int v29 = 1;
          }

          if (v10 - v24 < v29) {
            goto LABEL_173;
          }
          if ((int)v33 <= 127)
          {
            *v24++ = v33;
            goto LABEL_96;
          }

          if (v33 > 0x7FF)
          {
            if (HIWORD(v33))
            {
              *__int16 v24 = (v33 >> 18) | 0xF0;
              v24[1] = (v33 >> 12) & 0x3F | 0x80;
              v24[2] = (v33 >> 6) & 0x3F | 0x80;
              void v24[3] = v33 & 0x3F | 0x80;
              v24 += 4;
              goto LABEL_96;
            }

            *__int16 v24 = (v33 >> 12) | 0xE0;
            v24[1] = (v33 >> 6) & 0x3F | 0x80;
            v24[2] = v33 & 0x3F | 0x80;
            goto LABEL_76;
          }

          *__int16 v24 = (v33 >> 6) | 0xC0;
          v24[1] = v33 & 0x3F | 0x80;
        }

        else
        {
          if (v10 - v24 < 2)
          {
            unsigned int v29 = 2;
            goto LABEL_173;
          }

          *__int16 v24 = ((unsigned __int16)v29 >> 6) | 0xC0;
          v24[1] = v29 & 0x3F | 0x80;
        }

        v24 += 2;
      }

      else
      {
        if (v24 >= v10)
        {
          unsigned int v29 = 1;
LABEL_173:
          unsigned int v49 = *v31;
          if (!*v31) {
            goto LABEL_166;
          }
          else {
            int v50 = 4;
          }
          else {
            int v51 = 2;
          }
          else {
            int v52 = v51;
          }
          while (1)
          {
            char v53 = v31 + 1;
            if (v49 > 0x7F)
            {
              if (v49 > 0x7FF)
              {
                if ((v49 & 0xF800) == 0xD800)
                {
                  if ((v49 & 0x400) != 0 || (*v53 & 0xFC00) != 0xDC00)
                  {
                    v29 += v52;
                    ++v23;
                  }

                  else
                  {
                    char v53 = v31 + 2;
                    v29 += 4;
                  }
                }

                else
                {
                  v29 += 3;
                }
              }

              else
              {
                v29 += 2;
              }
            }

            else
            {
              ++v29;
            }

            unsigned int v49 = *v53;
            __int16 v31 = v53;
            if (!*v53) {
              goto LABEL_166;
            }
          }
        }

        *v24++ = v29;
      }

_BYTE *sub_1808820B4(_BYTE *a1, unsigned int a2)
{
  if ((int)a2 > 127)
  {
    if (a2 > 0x7FF)
    {
      if (HIWORD(a2))
      {
        *a1 = (a2 >> 18) | 0xF0;
        a1[1] = (a2 >> 12) & 0x3F | 0x80;
        a1[2] = (a2 >> 6) & 0x3F | 0x80;
        a1[3] = a2 & 0x3F | 0x80;
        return a1 + 4;
      }

      else
      {
        *a1 = (a2 >> 12) | 0xE0;
        a1[1] = (a2 >> 6) & 0x3F | 0x80;
        a1[2] = a2 & 0x3F | 0x80;
        return a1 + 3;
      }
    }

    else
    {
      *a1 = (a2 >> 6) | 0xC0;
      a1[1] = a2 & 0x3F | 0x80;
      return a1 + 2;
    }
  }

  else
  {
    *a1 = a2;
    return a1 + 1;
  }

char *__cdecl u_strToUTF8( char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return u_strToUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, -1, 0LL, pErrorCode);
}

UChar *__cdecl u_strFromJavaModifiedUTF8WithSub( UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UChar32 subchar, int32_t *pNumSubstitutions, UErrorCode *pErrorCode)
{
  int32_t v10 = srcLength;
  BOOL v11 = src;
  if (src) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = srcLength == 0;
  }
  char v13 = !v12;
  if (srcLength < -1
    || (v13 & 1) != 0
    || ((int32_t v14 = destCapacity, (v8 = dest) == 0LL) ? (v15 = destCapacity == 0) : (v15 = 1),
        v15 ? (char v16 = 0) : (char v16 = 1),
        destCapacity < 0 || (v16 & 1) != 0 || subchar >= 1114112 || (subchar & 0xFFFFF800) == 0xD800))
  {
    char v8 = 0LL;
    UErrorCode v21 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_26:
    *UErrorCode pErrorCode = v21;
    return v8;
  }

  if (pNumSubstitutions) {
    *pNumSubstitutions = 0;
  }
  unsigned int v19 = &dest[destCapacity];
  if (srcLength < 0)
  {
    int v23 = *(unsigned __int8 *)src;
    if (*src >= 1 && destCapacity)
    {
      unint64_t v20 = dest;
      do
      {
        *v20++ = v23;
        int v24 = *++v11;
        int v23 = v24;
      }

      while (v24 >= 1 && v20 < v19);
    }

    else
    {
      unint64_t v20 = dest;
    }

    if (!v23)
    {
      uint64_t v47 = (unint64_t)((char *)v20 - (char *)dest) >> 1;
      if (pDestLength) {
        *int32_t pDestLength = v47;
      }
      goto LABEL_141;
    }

    uint64_t v70 = pDestLength;
    int32_t v71 = pNumSubstitutions;
    int32_t v10 = strlen(v11);
  }

  else
  {
    uint64_t v70 = pDestLength;
    int32_t v71 = pNumSubstitutions;
    unint64_t v20 = dest;
  }

  int32_t v26 = 0;
  puint64_t i = 0;
LABEL_41:
  unint64_t v27 = (unint64_t)((char *)v19 - (char *)v20) >> 1;
  int32_t v28 = pi;
  int v29 = v10 - pi;
  if (v10 >= 1 && v29 <= (int)v27 && (*v11 & 0x80000000) == 0)
  {
    if (v10 <= pi)
    {
      int32_t v31 = pi;
    }

    else
    {
      UErrorCode v30 = &v11[pi];
      int32_t v31 = pi;
      while (1)
      {
        int v33 = *v30++;
        unsigned __int8 v32 = v33;
        if (v33 < 0) {
          break;
        }
        *v20++ = v32;
        puint64_t i = ++v31;
        if (v10 == v31)
        {
          int32_t v31 = v10;
          break;
        }
      }
    }

    int v34 = v31 - v28;
    LODWORD(v27) = v27 - v34;
    v29 -= v34;
  }

  if (subchar < 0x10000)
  {
    int v35 = v29 / 3;
    if ((int)v27 >= 3)
    {
      int v36 = v27 + 1;
      while (1)
      {
        uint64_t v37 = pi;
        uint64_t v38 = ++pi;
        unsigned int v39 = v11[v37];
        if (v11[v37] < 0)
        {
          if (v39 < 0xE0)
          {
            if (v39 < 0xC0 || (unsigned int v43 = v11[v38] ^ 0x80, v43 > 0x3F))
            {
LABEL_67:
              utf8_nextCharSafeBody((const uint8_t *)v11, &pi, v10, v39, -1);
              ++v26;
              *unint64_t v20 = subchar;
              goto LABEL_69;
            }

            *unint64_t v20 = ((v39 & 0x1F) << 6) | v43;
            int32_t v42 = v37 + 2;
          }

          else
          {
            if (v39 > 0xEF) {
              goto LABEL_67;
            }
            unsigned int v40 = v11[v38] ^ 0x80;
            if (v40 > 0x3F) {
              goto LABEL_67;
            }
            unsigned int v41 = v11[v37 + 2] ^ 0x80;
            if (v41 > 0x3F) {
              goto LABEL_67;
            }
            *unint64_t v20 = ((_WORD)v40 << 6) | ((_WORD)v39 << 12) | v41;
            int32_t v42 = v37 + 3;
          }

          puint64_t i = v42;
        }

        else
        {
          *unint64_t v20 = v39;
        }

char *__cdecl u_strToJavaModifiedUTF8( char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  char v8 = src;
  if (src) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = srcLength == 0;
  }
  char v10 = !v9;
  if (srcLength < -1
    || (v10 & 1) != 0
    || ((int32_t v6 = dest) == 0LL ? (v12 = destCapacity == 0) : (v12 = 1), v12 ? (v13 = 0) : (v13 = 1), destCapacity < 0 || v13))
  {
    int32_t v6 = 0LL;
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return v6;
  }

  BOOL v15 = &dest[destCapacity];
  if (srcLength == -1)
  {
    int v17 = *src;
    if ((v17 - 1) <= 0x7E && destCapacity)
    {
      char v18 = *src;
      char v16 = dest;
      do
      {
        *v16++ = v18;
        int v19 = v8[1];
        ++v8;
        int v17 = v19;
        char v18 = v19;
      }

      while ((v19 - 1) <= 0x7E && v16 < v15);
    }

    else
    {
      char v16 = dest;
    }

    if (!v17)
    {
      uint64_t v38 = ((_DWORD)v16 - (_DWORD)dest);
      if (pDestLength) {
        goto LABEL_82;
      }
      goto LABEL_83;
    }

    int32_t srcLength = u_strlen(v8);
  }

  else
  {
    char v16 = dest;
  }

  UErrorCode v21 = &v8[srcLength];
  if (!v8) {
    UErrorCode v21 = 0LL;
  }
  while (1)
  {
    int v22 = (_DWORD)v15 - (_DWORD)v16;
    unint64_t v23 = (unint64_t)((char *)v21 - (char *)v8) >> 1;
    BOOL v24 = (int)v15 - (int)v16 < (int)v23 || (int)v23 < 1;
    if (!v24 && *v8 <= 0x7Fu)
    {
      unsigned int v25 = (char *)v8;
      if (v8 < v21)
      {
        do
        {
          int v26 = *(unsigned __int16 *)v25;
          *v16++ = v26;
          v25 += 2;
        }

        while (v25 < (char *)v21);
      }

      unint64_t v27 = (unint64_t)(v25 - (char *)v8) >> 1;
      v22 -= v27;
      LODWORD(v23) = v23 - v27;
      char v8 = (const UChar *)v25;
    }

    int v28 = v22 / 3;
    int v29 = v23 + 1;
    do
    {
      unsigned int v31 = *v8++;
      unsigned int v30 = v31;
      if (v31 - 1 > 0x7E)
      {
        char v32 = v30 & 0x3F | 0x80;
        if (v30 > 0x7FF)
        {
          *char v16 = (v30 >> 12) | 0xE0;
          v16[1] = (v30 >> 6) & 0x3F | 0x80;
          v16[2] = v32;
          v16 += 3;
        }

        else
        {
          *char v16 = (v30 >> 6) | 0xC0;
          v16[1] = v32;
          v16 += 2;
        }
      }

      else
      {
        *v16++ = v30;
      }

      --v29;
    }

    while (v29 > 1);
  }

  if (v8 >= v21)
  {
    int v37 = 0;
    goto LABEL_74;
  }

  while (1)
  {
    int v33 = v8;
    unsigned int v35 = *v8++;
    unsigned int v34 = v35;
    if (v35 - 1 <= 0x7E)
    {
      if (v16 >= v15)
      {
        int v37 = 1;
        goto LABEL_73;
      }

      *v16++ = v34;
      goto LABEL_65;
    }

    uint64_t v36 = v15 - v16;
    if (v34 > 0x7FF) {
      break;
    }
    if (v36 < 2)
    {
      int v37 = 2;
      goto LABEL_73;
    }

    *char v16 = (v34 >> 6) | 0xC0;
    v16[1] = v34 & 0x3F | 0x80;
    v16 += 2;
LABEL_65:
    if (v8 >= v21)
    {
      int v37 = 0;
      goto LABEL_73;
    }
  }

  if (v36 >= 3)
  {
    *char v16 = (v34 >> 12) | 0xE0;
    v16[1] = (v34 >> 6) & 0x3F | 0x80;
    v16[2] = v34 & 0x3F | 0x80;
    v16 += 3;
    goto LABEL_65;
  }

  int v37 = 3;
LABEL_73:
  char v8 = v33 + 1;
LABEL_74:
  while (v8 < v21)
  {
    unsigned int v39 = *v8++;
    unsigned int v40 = v39 - 1;
    if (v39 < 0x800) {
      int v41 = 2;
    }
    else {
      int v41 = 3;
    }
    if (v40 < 0x7F) {
      int v41 = 1;
    }
    v37 += v41;
  }

  uint64_t v38 = (v37 + (_DWORD)v16 - (_DWORD)v6);
  if (pDestLength) {
LABEL_82:
  }
    *int32_t pDestLength = v38;
LABEL_83:
  u_terminateChars((uint64_t)v6, destCapacity, v38, (int *)pErrorCode);
  return v6;
}

UBool utext_moveIndex32(UText *ut, int32_t delta)
{
  int32_t v2 = delta;
  if (delta < 1)
  {
    if (delta < 0)
    {
      do
      {
        int32_t chunkOffset = ut->chunkOffset;
        if (chunkOffset <= 0)
        {
          int v6 = ((uint64_t (*)(UText *, int64_t, void))ut->pFuncs->access)(ut, ut->chunkNativeStart, 0LL);
          if (!v6) {
            return v6;
          }
          int32_t chunkOffset = ut->chunkOffset;
        }

        int32_t v8 = chunkOffset - 1;
        if ((ut->chunkContents[v8] & 0xF800) == 0xD800)
        {
          if (utext_previous32(ut) == -1)
          {
LABEL_23:
            LOBYTE(v6) = 0;
            return v6;
          }
        }

        else
        {
          ut->int32_t chunkOffset = v8;
        }
      }

      while (!__CFADD__(v2++, 1));
    }
  }

  else
  {
    int v4 = delta + 1;
    do
    {
      int32_t v5 = ut->chunkOffset;
      if (v5 >= ut->chunkLength)
      {
        int v6 = ((uint64_t (*)(UText *, int64_t, uint64_t))ut->pFuncs->access)(ut, ut->chunkNativeLimit, 1LL);
        if (!v6) {
          return v6;
        }
        int32_t v5 = ut->chunkOffset;
      }

      if ((ut->chunkContents[v5] & 0xF800) == 0xD800)
      {
        if (utext_next32(ut) == -1) {
          goto LABEL_23;
        }
      }

      else
      {
        ut->int32_t chunkOffset = v5 + 1;
      }

      --v4;
    }

    while (v4 > 1);
  }

  LOBYTE(v6) = 1;
  return v6;
}

UChar32 utext_next32(UText *ut)
{
  int32_t chunkOffset = ut->chunkOffset;
  if (chunkOffset >= ut->chunkLength)
  {
    int32_t chunkOffset = ut->chunkOffset;
  }

  chunkContents = ut->chunkContents;
  int32_t v4 = chunkOffset + 1;
  ut->int32_t chunkOffset = chunkOffset + 1;
  UChar32 v5 = chunkContents[chunkOffset];
  if ((v5 & 0xFC00) == 0xD800)
  {
    if (v4 >= ut->chunkLength)
    {
      chunkContents = ut->chunkContents;
      int32_t v4 = ut->chunkOffset;
    }

    int v6 = chunkContents[v4];
    if ((v6 & 0xFC00) == 0xDC00)
    {
      UChar32 v5 = v6 + (v5 << 10) - 56613888;
      ut->int32_t chunkOffset = v4 + 1;
    }
  }

  return v5;
}

UChar32 utext_previous32(UText *ut)
{
  int32_t chunkOffset = ut->chunkOffset;
  if (chunkOffset <= 0)
  {
    int32_t chunkOffset = ut->chunkOffset;
  }

  int32_t v3 = chunkOffset - 1;
  ut->int32_t chunkOffset = chunkOffset - 1;
  chunkContents = ut->chunkContents;
  UChar32 v5 = chunkContents[chunkOffset - 1];
  if ((v5 & 0xFC00) == 0xDC00)
  {
    if (chunkOffset <= 1)
    {
      chunkContents = ut->chunkContents;
      int32_t v3 = ut->chunkOffset;
    }

    int32_t v6 = v3 - 1;
    int v7 = chunkContents[v6];
    if ((v7 & 0xFC00) == 0xD800)
    {
      UChar32 v5 = v5 + (v7 << 10) - 56613888;
      ut->int32_t chunkOffset = v6;
    }
  }

  return v5;
}

int64_t utext_nativeLength(UText *ut)
{
  return ((uint64_t (*)(void))ut->pFuncs->nativeLength)();
}

UBool utext_isLengthExpensive(const UText *ut)
{
  return (LOBYTE(ut->providerProperties) >> 1) & 1;
}

int64_t utext_getNativeIndex(const UText *ut)
{
  uint64_t chunkOffset = ut->chunkOffset;
  else {
    return ((uint64_t (*)(void))ut->pFuncs->mapOffsetToNative)();
  }
}

void utext_setNativeIndex(UText *ut, int64_t nativeIndex)
{
  int64_t chunkNativeStart = ut->chunkNativeStart;
  if (nativeIndex < chunkNativeStart || ut->chunkNativeLimit <= nativeIndex)
  {
    ((void (*)(UText *))ut->pFuncs->access)(ut);
    int32_t chunkOffset = ut->chunkOffset;
  }

  else
  {
    int32_t chunkOffset = nativeIndex - chunkNativeStart;
    ut->int32_t chunkOffset = chunkOffset;
  }

  if (chunkOffset < ut->chunkLength && (ut->chunkContents[chunkOffset] & 0xFC00) == 0xDC00)
  {
    if (!chunkOffset) {
      ((void (*)(UText *, int64_t, void))ut->pFuncs->access)(ut, ut->chunkNativeStart, 0LL);
    }
    int32_t v5 = ut->chunkOffset;
    BOOL v6 = __OFSUB__(v5, 1);
    int32_t v7 = v5 - 1;
    if (v7 < 0 == v6 && (ut->chunkContents[v7] & 0xFC00) == 0xD800) {
      ut->int32_t chunkOffset = v7;
    }
  }

int64_t utext_getPreviousNativeIndex(UText *ut)
{
  int32_t chunkOffset = ut->chunkOffset;
  uint64_t v3 = (chunkOffset - 1);
  if (chunkOffset < 1)
  {
    if (!chunkOffset && !ut->chunkNativeStart) {
      return 0LL;
    }
LABEL_7:
    utext_previous32(ut);
    uint64_t v5 = ut->chunkOffset;
    else {
      int64_t v6 = ((uint64_t (*)(UText *))ut->pFuncs->mapOffsetToNative)(ut);
    }
    utext_next32(ut);
    return v6;
  }

  if ((int)v3 > ut->nativeIndexingLimit)
  {
    ut->int32_t chunkOffset = v3;
    int64_t result = ((uint64_t (*)(UText *))ut->pFuncs->mapOffsetToNative)(ut);
    ++ut->chunkOffset;
    return result;
  }

  return ut->chunkNativeStart + v3;
}

UChar32 utext_current32(UText *ut)
{
  int32_t chunkOffset = ut->chunkOffset;
  if (chunkOffset == ut->chunkLength)
  {
    int32_t chunkOffset = ut->chunkOffset;
  }

  chunkContents = ut->chunkContents;
  UChar32 v4 = chunkContents[chunkOffset];
  if ((v4 & 0xFC00) != 0xD800) {
    return v4;
  }
  uint64_t v5 = chunkOffset + 1LL;
  if ((int)v5 >= ut->chunkLength)
  {
    int64_t chunkNativeLimit = ut->chunkNativeLimit;
    else {
      unsigned int v6 = 0;
    }
    int v8 = ((uint64_t (*)(UText *, int64_t, void))ut->pFuncs->access)(ut, chunkNativeLimit, 0LL);
    ut->int32_t chunkOffset = ut->chunkLength - 1;
    if (v8) {
      goto LABEL_11;
    }
    return -1;
  }

  unsigned int v6 = chunkContents[v5];
LABEL_11:
  if (v6 >> 10 == 55) {
    return v6 + (v4 << 10) - 56613888;
  }
  return v4;
}

UChar32 utext_char32At(UText *ut, int64_t nativeIndex)
{
  int64_t chunkNativeStart = ut->chunkNativeStart;
  int32_t v5 = nativeIndex - chunkNativeStart;
  if (nativeIndex < chunkNativeStart || chunkNativeStart + ut->nativeIndexingLimit <= nativeIndex)
  {
    UChar32 v6 = -1;
  }

  else
  {
    ut->uint64_t chunkOffset = v5;
    UChar32 v6 = ut->chunkContents[v5];
    if ((v6 & 0xF800) != 0xD800) {
      return v6;
    }
  }

  utext_setNativeIndex(ut, nativeIndex);
  if (ut->chunkNativeStart <= nativeIndex)
  {
    uint64_t chunkOffset = ut->chunkOffset;
    if ((int)chunkOffset < ut->chunkLength)
    {
      UChar32 v6 = ut->chunkContents[chunkOffset];
      if ((v6 & 0xF800) == 0xD800) {
        return utext_current32(ut);
      }
    }
  }

  return v6;
}

UChar32 utext_next32From(UText *ut, int64_t nativeIndex)
{
  int64_t chunkNativeStart = ut->chunkNativeStart;
  int64_t v5 = nativeIndex - chunkNativeStart;
  if (nativeIndex < chunkNativeStart || ut->chunkNativeLimit <= nativeIndex)
  {
    LODWORD(v5) = ut->chunkOffset;
  }

  else if (v5 > ut->nativeIndexingLimit)
  {
    LODWORD(v5) = ((uint64_t (*)(UText *, int64_t))ut->pFuncs->mapNativeIndexToUTF16)(ut, nativeIndex);
  }

  chunkContents = ut->chunkContents;
  ut->uint64_t chunkOffset = v5 + 1;
  UChar32 result = chunkContents[(int)v5];
  if ((result & 0xF800) == 0xD800)
  {
    utext_setNativeIndex(ut, nativeIndex);
    return utext_next32(ut);
  }

  return result;
}

UChar32 utext_previous32From(UText *ut, int64_t nativeIndex)
{
  int64_t chunkNativeStart = ut->chunkNativeStart;
  BOOL v5 = __OFSUB__(nativeIndex, chunkNativeStart);
  uint64_t v6 = nativeIndex - chunkNativeStart;
  if (!((v6 < 0) ^ v5 | (v6 == 0)) && ut->chunkNativeLimit >= nativeIndex)
  {
    if (v6 <= ut->nativeIndexingLimit)
    {
      ut->uint64_t chunkOffset = v6;
      goto LABEL_9;
    }

    int32_t v8 = ((uint64_t (*)(UText *, int64_t))ut->pFuncs->mapNativeIndexToUTF16)(ut, nativeIndex);
    ut->uint64_t chunkOffset = v8;
    if (v8) {
      goto LABEL_9;
    }
  }

int32_t utext_extract( UText *ut, int64_t nativeStart, int64_t nativeLimit, UChar *dest, int32_t destCapacity, UErrorCode *status)
{
  return ((uint64_t (*)(void))ut->pFuncs->extract)();
}

UBool utext_equals(const UText *a, const UText *b)
{
  UBool v2 = 0;
  if (a && b)
  {
    if (a->magic == 878368812
      && b->magic == 878368812
      && (pFuncs = a->pFuncs, pFuncs == b->pFuncs)
      && a->context == b->context)
    {
      uint64_t chunkOffset = a->chunkOffset;
      else {
        uint64_t v7 = ((uint64_t (*)(void))pFuncs->mapOffsetToNative)();
      }
      uint64_t v8 = b->chunkOffset;
      else {
        uint64_t v9 = ((uint64_t (*)(const UText *))b->pFuncs->mapOffsetToNative)(b);
      }
      return v7 == v9;
    }

    else
    {
      return 0;
    }
  }

  return v2;
}

UBool utext_isWritable(const UText *ut)
{
  return (LOBYTE(ut->providerProperties) >> 3) & 1;
}

void utext_freeze(UText *ut)
{
  ut->providerProperties &= ~8u;
}

UBool utext_hasMetaData(const UText *ut)
{
  return (LOBYTE(ut->providerProperties) >> 4) & 1;
}

int32_t utext_replace( UText *ut, int64_t nativeStart, int64_t nativeLimit, const UChar *replacementText, int32_t replacementLength, UErrorCode *status)
{
  if ((ut->providerProperties & 8) == 0)
  {
    *statUChar us = U_NO_WRITE_PERMISSION;
    return 0;
  }

  return ((uint64_t (*)(void))ut->pFuncs->replace)();
}

void utext_copy( UText *ut, int64_t nativeStart, int64_t nativeLimit, int64_t destIndex, UBool move, UErrorCode *status)
{
  if (*(int *)status <= 0)
  {
    if ((ut->providerProperties & 8) != 0) {
      ((void (*)(void))ut->pFuncs->copy)();
    }
    else {
      *statUChar us = U_NO_WRITE_PERMISSION;
    }
  }

UText *__cdecl utext_clone(UText *dest, const UText *src, UBool deep, UBool readOnly, UErrorCode *status)
{
  if (*(int *)status <= 0)
  {
    int v6 = readOnly;
    dest = (UText *)((uint64_t (*)(UText *))src->pFuncs->clone)(dest);
    if (*(int *)status <= 0)
    {
      if (dest)
      {
        if (v6) {
          dest->providerProperties &= ~8u;
        }
      }

      else
      {
        *statUChar us = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }

  return dest;
}

UText *__cdecl utext_setup(UText *ut, int32_t extraSpace, UErrorCode *status)
{
  uint64_t v3 = ut;
  if (!ut)
  {
    if (extraSpace <= 0) {
      int v9 = 144;
    }
    else {
      int v9 = extraSpace + 144;
    }
    char v10 = (UText *)uprv_malloc(v9);
    uint64_t v3 = v10;
    if (v10)
    {
      *(_OWORD *)&v10->r = xmmword_180A2C918;
      *(_OWORD *)&v10->a = unk_180A2C928;
      *(_OWORD *)&v10->privA = xmmword_180A2C938;
      *(_OWORD *)&v10->int64_t chunkNativeStart = xmmword_180A2C8D8;
      *(_OWORD *)&v10->chunkContents = unk_180A2C8E8;
      *(_OWORD *)&v10->pExtra = xmmword_180A2C8F8;
      *(_OWORD *)&v10->p = unk_180A2C908;
      *(_OWORD *)&v10->magic = xmmword_180A2C8B8;
      *(_OWORD *)&v10->int64_t chunkNativeLimit = unk_180A2C8C8;
      v10->int32_t flags = 1;
      if (v9 >= 1)
      {
        v10->size_t extraSize = extraSpace;
        v10->pExtra = &v10[1];
      }

      goto LABEL_18;
    }

    goto LABEL_23;
  }

  if (ut->magic != 878368812)
  {
    UErrorCode v14 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_24:
    *statUChar us = v14;
    return v3;
  }

  int32_t flags = ut->flags;
  if ((flags & 4) != 0)
  {
    close = ut->pFuncs->close;
    if (close)
    {
      ((void (*)(UText *))close)(ut);
      int32_t flags = v3->flags;
    }
  }

  v3->int32_t flags = flags & 0xFFFFFFFB;
  if (v3->extraSize >= extraSpace) {
    goto LABEL_18;
  }
  if ((flags & 2) != 0)
  {
    uprv_free(v3->pExtra);
    v3->size_t extraSize = 0;
  }

  uint64_t v8 = uprv_malloc(extraSpace);
  v3->pExtra = v8;
  if (!v8)
  {
LABEL_23:
    UErrorCode v14 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_24;
  }

  v3->size_t extraSize = extraSpace;
  v3->flags |= 2u;
LABEL_18:
  if (*(int *)status <= 0)
  {
    unsigned int v11 = v3->flags | 4;
    v3->int64_t chunkNativeLimit = 0LL;
    *(void *)&v3->int32_t flags = v11;
    *(void *)&v3->nativeIndexingLimit = 0LL;
    *(void *)&v3->chunkLength = 0LL;
    *(int64_t *)((char *)&v3->chunkNativeStart + 4) = 0LL;
    HIDWORD(v3->chunkContents) = 0;
    *(_OWORD *)&v3->context = 0u;
    *(_OWORD *)&v3->q = 0u;
    *(_OWORD *)&v3->privP = 0u;
    *(_OWORD *)&v3->b = 0u;
    *(void *)&v3->privB = 0LL;
    pExtra = v3->pExtra;
    if (pExtra)
    {
      size_t extraSize = v3->extraSize;
    }
  }

  return v3;
}

UText *__cdecl utext_close(UText *ut)
{
  int v1 = ut;
  if (ut)
  {
    if (ut->magic == 878368812)
    {
      int32_t flags = ut->flags;
      if ((flags & 4) != 0)
      {
        close = ut->pFuncs->close;
        if (close)
        {
          ((void (*)(UText *))close)(ut);
          int32_t flags = v1->flags;
        }

        LOBYTE(v4) = flags & 0xFB;
        v1->int32_t flags = flags & 0xFFFFFFFB;
        if ((flags & 2) != 0)
        {
          uprv_free(v1->pExtra);
          v1->pExtra = 0LL;
          unsigned int v4 = v1->flags & 0xFFFFFFFD;
          v1->int32_t flags = v4;
          v1->size_t extraSize = 0;
        }

        v1->pFuncs = 0LL;
        if ((v4 & 1) != 0)
        {
          v1->magic = 0;
          uprv_free(v1);
          return 0LL;
        }
      }
    }
  }

  return v1;
}

UText *__cdecl utext_openUTF8(UText *ut, const char *s, int64_t length, UErrorCode *status)
{
  int32_t v6 = length;
  else {
    uint64_t v7 = (const char *)&unk_180A2C948;
  }
  if ((unint64_t)(length - 0x80000000LL) >= 0xFFFFFFFF7FFFFFFFLL && v7)
  {
    UChar32 result = utext_setup(ut, 480, status);
    if (*(int *)status <= 0)
    {
      result->pFuncs = (const UTextFuncs *)&unk_18971C4F8;
      result->context = v7;
      result->b = v6;
      result->c = v6;
      if (v6 < 0)
      {
        result->c = 0;
        result->providerProperties |= 2u;
      }

      pExtra = (char *)result->pExtra;
      result->p = pExtra;
      result->q = pExtra + 240;
    }
  }

  else
  {
    UChar32 result = 0LL;
    *statUChar us = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return result;
}

UText *utext_openReplaceable(UText *a1, const void *a2, UErrorCode *status)
{
  if (a2)
  {
    uint64_t v7 = utext_setup(a1, 22, status);
    uint64_t v3 = v7;
    if (*(int *)status <= 0)
    {
      v7->providerProperties = 8;
      v3->pFuncs = (const UTextFuncs *)&unk_18971C568;
      v3->context = a2;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
    *statUChar us = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return v3;
}

UText *utext_openUnicodeString(UText *a1, uint64_t a2, UErrorCode *a3)
{
  UChar32 result = utext_openConstUnicodeString(a1, a2, a3);
  return result;
}

UText *utext_openConstUnicodeString(UText *ut, uint64_t a2, UErrorCode *status)
{
  BOOL v5 = ut;
  if (*(int *)status <= 0 && (*(_WORD *)(a2 + 8) & 1) != 0)
  {
    utext_openUChars(ut, 0LL, 0LL, status);
    *statUChar us = U_ILLEGAL_ARGUMENT_ERROR;
  }

  else
  {
    int32_t v6 = utext_setup(ut, 0, status);
    BOOL v5 = v6;
    if (*(int *)status <= 0)
    {
      v6->pFuncs = (const UTextFuncs *)&unk_18971C5D8;
      v6->context = (const void *)a2;
      v6->providerProperties = 4;
      __int16 v7 = *(_WORD *)(a2 + 8);
      if ((v7 & 0x11) != 0)
      {
        uint64_t v8 = 0LL;
      }

      else if ((v7 & 2) != 0)
      {
        uint64_t v8 = (const UChar *)(a2 + 10);
      }

      else
      {
        uint64_t v8 = *(const UChar **)(a2 + 24);
      }

      v6->chunkContents = v8;
      else {
        int v9 = *(unsigned __int16 *)(a2 + 8) >> 5;
      }
      v6->chunkLength = v9;
      v6->int64_t chunkNativeStart = 0LL;
      v6->int64_t chunkNativeLimit = v9;
      v6->nativeIndexingLimit = v9;
    }
  }

  return v5;
}

UText *__cdecl utext_openUChars(UText *ut, const UChar *s, int64_t length, UErrorCode *status)
{
  else {
    __int16 v7 = (const UChar *)&unk_180A2C94A;
  }
  if ((unint64_t)(length - 0x80000000LL) >= 0xFFFFFFFF7FFFFFFFLL && v7)
  {
    UChar32 result = utext_setup(ut, 0, status);
    if (*(int *)status <= 0)
    {
      result->context = v7;
      if (length == -1) {
        int32_t v8 = 6;
      }
      else {
        int32_t v8 = 4;
      }
      result->providerProperties = v8;
      result->a = length;
      result->chunkContents = v7;
      result->pFuncs = (const UTextFuncs *)&unk_18971C648;
      result->int64_t chunkNativeStart = 0LL;
      int64_t v9 = length & ~(length >> 63);
      result->int64_t chunkNativeLimit = v9;
      result->uint64_t chunkOffset = 0;
      result->chunkLength = v9;
      result->nativeIndexingLimit = v9;
    }
  }

  else
  {
    UChar32 result = 0LL;
    *statUChar us = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return result;
}

double utext_openCharacterIterator(UText *a1, int *a2, UErrorCode *status)
{
  if (*(int *)status <= 0)
  {
    if (a2[4] < 1)
    {
      BOOL v5 = utext_setup(a1, 64, status);
      if (*(int *)status <= 0)
      {
        v5->a = a2[5];
        pExtra = (char *)v5->pExtra;
        v5->p = pExtra;
        v5->q = pExtra + 32;
        v5->providerProperties = 0;
        v5->context = a2;
        *(void *)&v5->b = -1LL;
        v5->chunkContents = (const UChar *)pExtra;
        v5->pFuncs = (const UTextFuncs *)&unk_18971C6B8;
        v5->int64_t chunkNativeStart = -1LL;
        v5->int64_t chunkNativeLimit = 0LL;
        *(void *)&double result = 1LL;
        *(void *)&v5->uint64_t chunkOffset = 1LL;
        v5->nativeIndexingLimit = 1;
      }
    }

    else
    {
      *statUChar us = U_UNSUPPORTED_ERROR;
    }
  }

  return result;
}

UText *sub_1808839C4(UText *a1, unint64_t a2, int a3, UErrorCode *a4)
{
  __int16 v7 = sub_18088454C(a1, a2, a4);
  if (a3 && *(int *)a4 <= 0)
  {
    size_t v8 = (int)((*(uint64_t (**)(unint64_t))(*(void *)(a2 + 56) + 24LL))(a2) + 1);
    int64_t v9 = uprv_malloc(v8);
    if (v9)
    {
      char v10 = v9;
      memcpy(v9, *(const void **)(a2 + 72), v8);
      v7->context = v10;
      v7->providerProperties |= 0x20u;
    }

    else
    {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return v7;
}

uint64_t sub_180883A68(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 120);
  if (v1 < 0)
  {
    uint64_t v2 = *(int *)(a1 + 124);
    int v1 = v2 - 1;
    if (v2 - 1 >= 0x7FFFFFFF) {
      int v1 = 0x7FFFFFFF;
    }
    *(_DWORD *)(a1 + 120) = v1;
    *(_DWORD *)(a1 + 8) &= ~2u;
  }

  return v1;
}

BOOL sub_180883AAC(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = *(const uint8_t **)(a1 + 72);
  int32_t v5 = *(_DWORD *)(a1 + 120);
  uint64_t v6 = 0x7FFFFFFFLL;
  if (a2 < 0x7FFFFFFF) {
    uint64_t v6 = a2;
  }
  int32_t v7 = v6 & ~(v6 >> 63);
  if (v5 < v7)
  {
    if (v5 < 0)
    {
      int32_t v8 = *(_DWORD *)(a1 + 124);
      if (v8 <= v7)
      {
        if (v8 < v7)
        {
          int64_t v9 = &v4[v8];
          while (*v9++)
          {
            *(_DWORD *)(a1 + 124) = ++v8;
            if (v7 == v8)
            {
              int32_t v8 = v7;
              break;
            }
          }
        }

        if (!v4[v8])
        {
          *(_DWORD *)(a1 + 120) = v8;
          *(_DWORD *)(a1 + 8) &= ~2u;
          int32_t v5 = v8;
          int32_t v7 = v8;
        }
      }
    }

    else
    {
      int32_t v7 = *(_DWORD *)(a1 + 120);
    }
  }

  uint64_t v11 = v7;
  uint64_t v78 = v4;
  if (!a3)
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (v16 == v7)
    {
      if (!v7)
      {
LABEL_97:
        BOOL result = 0LL;
        *(_DWORD *)(a1 + 40) = 0;
        return result;
      }

      uint64_t v13 = *(void *)(a1 + 88);
      int32_t v14 = *(_DWORD *)v13;
      if (v7 > *(_DWORD *)v13)
      {
        int32_t v15 = *(_DWORD *)(v13 + 4);
        if (v7 <= v15) {
          goto LABEL_40;
        }
      }
    }

    else
    {
      uint64_t v13 = *(void *)(a1 + 88);
      int32_t v14 = *(_DWORD *)v13;
    }

    if (v7 > v14)
    {
      int32_t v15 = *(_DWORD *)(v13 + 4);
      if (v7 <= v15) {
        goto LABEL_40;
      }
    }

    if (v7)
    {
      if (v16 < v7 && *(void *)(a1 + 16) >= v7)
      {
        *(_DWORD *)(a1 + 40) = v51;
        return v51 != 0;
      }

      if (v7 != v5)
      {
        if ((char)v4[v7] > -65)
        {
          int32_t v5 = v7;
        }

        else
        {
          int32_t v18 = utf8_back1SafeBody(v4, 0, v7);
          unsigned int v4 = v78;
          int32_t v5 = v18;
          uint64_t v13 = *(void *)(a1 + 88);
        }
      }

      uint64_t v52 = *(void *)(a1 + 80);
      *(void *)(a1 + 80) = v13;
      *(void *)(a1 + 88) = v52;
      uint64_t v53 = v13 + 24;
      uint64_t v54 = v13 + 96;
      uint64_t v55 = v13 + 132;
      int v56 = v5 - 101;
      int32_t v75 = v5;
      puint64_t i = v5;
      *(_BYTE *)(v13 + 130) = 101;
      int v57 = 34;
      *(_BYTE *)(v13 + 233) = 34;
      int v58 = (int32_t *)v13;
      uint64_t v59 = v13 - (v5 - 101) + 132;
      int v60 = 34;
      do
      {
        int32_t v61 = pi;
        uint64_t v62 = (pi - 1);
        BOOL v63 = pi < 1 || pi - v56 < 6;
        if (v63) {
          goto LABEL_115;
        }
        --pi;
        unsigned int v64 = v60 - 1;
        UChar32 v65 = v4[v62];
        if ((char)v4[v62] < 0)
        {
          UChar32 v66 = utf8_prevCharSafeBody(v4, 0, &pi, v65, -3);
          if (v66 >= 0x10000)
          {
            *(_WORD *)(v53 + 2LL * v64) = v66 & 0x3FF | 0xDC00;
            *(_BYTE *)(v54 + v64) = pi - v56;
            UChar32 v66 = (v66 >> 10) - 10304;
            unsigned int v64 = v60 - 2;
          }

          unsigned int v4 = v78;
          *(_WORD *)(v53 + 2LL * v64) = v66;
          *(_BYTE *)(v54 + v64) = pi - v56;
          do
          {
            *(_BYTE *)(v59 + v62) = v64;
            BOOL v63 = v62-- <= pi;
          }

          while (!v63);
          int v60 = v64;
          int v57 = v64;
        }

        else
        {
          *(_WORD *)(v53 + 2LL * v64) = v65;
          *(_BYTE *)(v55 + (int)v62 - v56) = v60 - 1;
          *(_BYTE *)(v54 + v64) = pi - v56;
          --v60;
        }
      }

      while (v60 > 2);
      int32_t v61 = pi;
LABEL_115:
      *int v58 = v61;
      v58[1] = v75;
      v58[2] = v60;
      v58[3] = 34;
      int v67 = v57 - v60;
      v58[4] = v67;
      v58[5] = v56;
      *(void *)(a1 + 48) = v53 + 2LL * v60;
      *(_DWORD *)(a1 + 40) = 34 - v60;
      *(_DWORD *)(a1 + 44) = 34 - v60;
      *(void *)(a1 + 32) = v61;
      *(void *)(a1 + 16) = v75;
      BOOL result = 1LL;
      *(_DWORD *)(a1 + 28) = v67;
      return result;
    }

    if (!v14)
    {
LABEL_95:
      uint64_t v46 = *(void *)(a1 + 80);
      *(void *)(a1 + 80) = v13;
      *(void *)(a1 + 88) = v46;
      uint64_t v48 = *(int *)(v13 + 4);
      uint64_t v47 = *(int *)(v13 + 8);
      *(void *)(a1 + 48) = v13 + 2 * v47 + 24;
      int v49 = *(_DWORD *)(v13 + 16);
      int v50 = *(_DWORD *)(v13 + 12) - v47;
      *(_DWORD *)(a1 + 44) = v50;
      *(void *)(a1 + 32) = v14;
      *(void *)(a1 + 16) = v48;
      *(_DWORD *)(a1 + 28) = v49;
      if (v7 == (_DWORD)v48)
      {
        BOOL result = 0LL;
        *(_DWORD *)(a1 + 40) = v50;
        return result;
      }

      goto LABEL_97;
    }

uint64_t sub_18088421C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  if ((a5 & 0x80000000) != 0 || (int v10 = a3, !a4) && a5)
  {
    uint64_t v6 = 0LL;
    int v12 = 1;
LABEL_7:
    *a6 = v12;
    return v6;
  }

  uint64_t v14 = *(int *)(a1 + 120);
  if (a2 < 0)
  {
    int v15 = 0;
  }

  else
  {
    int v15 = *(_DWORD *)(a1 + 120);
    if (v14 >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_12;
      }
LABEL_16:
      LODWORD(v14) = 0;
      goto LABEL_17;
    }
  }

  LODWORD(a2) = v15;
  if (a3 < 0) {
    goto LABEL_16;
  }
LABEL_12:
  if (v14 < a3) {
LABEL_17:
  }
    int v10 = v14;
  if ((int)a2 > v10)
  {
    uint64_t v6 = 0LL;
    int v12 = 8;
    goto LABEL_7;
  }

  uint64_t v16 = *(void *)(a1 + 72);
  uint64_t v17 = *(void *)(a1 + 16);
  if (v17 > (int)a2)
  {
    int v18 = 0;
    uint64_t v19 = (int)a2;
    while (1)
    {
      int v20 = *(char *)(v16 + v19);
      if ((v20 & 0x80000000) == 0) {
        break;
      }
      --v19;
      if (++v18 == 3)
      {
        LODWORD(a2) = a2 - 3;
        goto LABEL_30;
      }
    }

    LODWORD(a2) = a2 - v18;
  }

unint64_t sub_1808844D8(uint64_t a1)
{
  return *(int *)(*(void *)(a1 + 80) + 20LL)
       + (unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 80)
                                              + *(int *)(a1 + 40)
}

uint64_t sub_1808844FC(uint64_t a1, int a2)
{
}

void sub_18088451C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 8) & 0x20) != 0)
  {
    uprv_free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0LL;
  }

UText *sub_18088454C(UText *a1, unint64_t a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    unint64_t v5 = a2;
    size_t v6 = *(unsigned int *)(a2 + 24);
    int32_t v7 = utext_setup(a1, *(_DWORD *)(a2 + 24), a3);
    uint64_t v3 = v7;
    pExtra = v7->pExtra;
    int32_t flags = v7->flags;
    int32_t sizeOfStruct = *(_DWORD *)(v5 + 12);
    if (sizeOfStruct >= v7->sizeOfStruct) {
      int32_t sizeOfStruct = v7->sizeOfStruct;
    }
    memcpy(v7, (const void *)v5, sizeOfStruct);
    v3->pExtra = pExtra;
    v3->int32_t flags = flags;
    unint64_t context = (unint64_t)v3->context;
    unint64_t v12 = *(void *)(v5 + 64);
    if (context < v12 || context >= v12 + *(int *)(v5 + 24))
    {
      if (context < v5 || (unint64_t v14 = v5, v13 = (char *)v3, context >= v5 + *(int *)(v5 + 12)))
      {
LABEL_14:
        unint64_t p = (unint64_t)v3->p;
        if (p < v12 || p >= v12 + *(int *)(v5 + 24))
        {
          if (p < v5 || (v17 = v5, uint64_t v16 = (char *)v3, p >= v5 + *(int *)(v5 + 12)))
          {
LABEL_20:
            unint64_t q = (unint64_t)v3->q;
            if (q < v12 || q >= v12 + *(int *)(v5 + 24))
            {
              if (q < v5 || (v20 = v5, uint64_t v19 = (char *)v3, q >= v5 + *(int *)(v5 + 12)))
              {
LABEL_26:
                unint64_t r = (unint64_t)v3->r;
                if (r < v12 || r >= v12 + *(int *)(v5 + 24))
                {
                  if (r < v5 || (v23 = v5, int v22 = (char *)v3, r >= v5 + *(int *)(v5 + 12)))
                  {
LABEL_32:
                    unint64_t chunkContents = (unint64_t)v3->chunkContents;
                    if (chunkContents < v12 || chunkContents >= v12 + *(int *)(v5 + 24))
                    {
                      if (chunkContents < v5) {
                        goto LABEL_38;
                      }
                      int v25 = (char *)v3;
                    }

                    else
                    {
                      int v25 = (char *)v3->pExtra;
                      unint64_t v5 = v12;
                    }

                    v3->unint64_t chunkContents = (const UChar *)&v25[chunkContents - v5];
LABEL_38:
                    v3->providerProperties &= ~0x20u;
                    return v3;
                  }
                }

                else
                {
                  int v22 = (char *)v3->pExtra;
                  unint64_t v23 = v12;
                }

                v3->unint64_t r = &v22[r - v23];
                unint64_t v12 = *(void *)(v5 + 64);
                goto LABEL_32;
              }
            }

            else
            {
              uint64_t v19 = (char *)v3->pExtra;
              unint64_t v20 = v12;
            }

            v3->unint64_t q = &v19[q - v20];
            unint64_t v12 = *(void *)(v5 + 64);
            goto LABEL_26;
          }
        }

        else
        {
          uint64_t v16 = (char *)v3->pExtra;
          unint64_t v17 = v12;
        }

        v3->unint64_t p = &v16[p - v17];
        unint64_t v12 = *(void *)(v5 + 64);
        goto LABEL_20;
      }
    }

    else
    {
      uint64_t v13 = (char *)v3->pExtra;
      unint64_t v14 = *(void *)(v5 + 64);
    }

    v3->unint64_t context = &v13[context - v14];
    unint64_t v12 = *(void *)(v5 + 64);
    goto LABEL_14;
  }

  return 0LL;
}

UText *sub_1808847B8(UText *a1, unint64_t a2, int a3, UErrorCode *a4)
{
  int32_t v7 = sub_18088454C(a1, a2, a4);
  if (a3 && *(int *)a4 <= 0)
  {
    v7->unint64_t context = (const void *)(*(uint64_t (**)(void))(**(void **)(a2 + 72) + 56LL))(*(void *)(a2 + 72));
    v7->providerProperties |= 0x28u;
  }

  return v7;
}

uint64_t sub_180884828(uint64_t a1)
{
  return (*(int (**)(void))(**(void **)(a1 + 72) + 64LL))(*(void *)(a1 + 72));
}

uint64_t sub_18088484C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 72);
  LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 64LL))(v6);
  uint64_t v8 = (int)v7;
  if (a2 < 0)
  {
    uint64_t v7 = 0LL;
    goto LABEL_5;
  }

  uint64_t v7 = (int)v7;
  if ((int)v7 < a2) {
LABEL_5:
  }
    a2 = v7;
  uint64_t v9 = *(void *)(a1 + 32);
  if (a3)
  {
    if (v9 > (int)a2 || *(void *)(a1 + 16) <= (int)a2)
    {
      if ((int)v8 <= (int)a2 && *(void *)(a1 + 16) == v8)
      {
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 40) = v8 - v9;
        return result;
      }

      uint64_t v11 = a2 + 9;
      if (a2 + 9 >= v8) {
        uint64_t v11 = v8;
      }
      *(void *)(a1 + 16) = v11;
      BOOL v12 = v11 < 10;
      uint64_t v13 = v11 - 10;
      if (v12) {
        uint64_t v13 = 0LL;
      }
      *(void *)(a1 + 32) = v13;
LABEL_28:
      uint64_t v16 = *(_WORD **)(a1 + 64);
      memset(v23, 0, sizeof(v23));
      icu::UnicodeString::UnicodeString(v23, v16, 0LL, 10LL);
      (*(void (**)(uint64_t, void, void, _OWORD *))(*(void *)v6 + 24LL))( v6,  *(unsigned int *)(a1 + 32),  *(unsigned int *)(a1 + 16),  v23);
      *(void *)(a1 + 48) = v16;
      uint64_t v17 = *(void *)(a1 + 16);
      uint64_t v18 = *(void *)(a1 + 32);
      int v19 = v17 - v18;
      int v20 = a2 - v18;
      *(_DWORD *)(a1 + 40) = a2 - v18;
      *(_DWORD *)(a1 + 44) = v17 - v18;
      if (v17 < v8 && (uint64_t v21 = v19 - 1LL, (v16[v21] & 0xFC00) == 0xD800))
      {
        *(_DWORD *)(a1 + 44) = v21;
        *(void *)(a1 + 16) = v17 - 1;
        if (v20 >= v19)
        {
          *(_DWORD *)(a1 + 40) = v21;
          int v20 = v19 - 1;
        }
      }

      else
      {
        LODWORD(v2sub_18086E18C((uint64_t)this, 1) = v17 - v18;
      }

      if (v18 >= 1 && (*v16 & 0xFC00) == 0xDC00)
      {
        *(void *)(a1 + 48) = ++v16;
        *(void *)(a1 + 32) = v18 + 1;
        LODWORD(v2sub_18086E18C((uint64_t)this, 1) = v21 - 1;
        *(_DWORD *)(a1 + 40) = --v20;
        *(_DWORD *)(a1 + 44) = v21;
      }

      int v22 = v20 - 1;
      if (v20 >= 1 && (v16[v20] & 0xFC00) == 0xDC00 && (v16[v22] & 0xFC00) == 0xD800) {
        *(_DWORD *)(a1 + 40) = v22;
      }
      *(_DWORD *)(a1 + 28) = v21;
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)v23);
      return 1LL;
    }
  }

  else if (v9 > (int)a2 || *(void *)(a1 + 16) < (int)a2)
  {
    if (!(_DWORD)a2 && !v9)
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 40) = 0;
      return result;
    }

    uint64_t v14 = ((a2 << 32) - 0x900000000LL) >> 32;
    *(void *)(a1 + 32) = v14;
    uint64_t v15 = ((a2 << 32) + 0x100000000LL) >> 32;
    *(void *)(a1 + 16) = v15;
    goto LABEL_28;
  }

  *(_DWORD *)(a1 + 40) = a2 - v9;
  return 1LL;
}

uint64_t sub_180884AD0(uint64_t a1, int64_t a2, int64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v12 = *(void *)(a1 + 72);
  LODWORD(v13) = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 64LL))(v12);
  if (*a6 > 0) {
    return 0LL;
  }
  int v15 = v13;
  if ((a5 & 0x80000000) != 0 || !a4 && (_DWORD)a5) {
    *a6 = 1;
  }
  if (a2 > a3)
  {
    uint64_t v14 = 0LL;
    *a6 = 8;
    return v14;
  }

  int64_t v16 = (int)v13;
  if (a2 < 0)
  {
    int64_t v13 = 0LL;
  }

  else
  {
    int64_t v13 = (int)v13;
    if ((int)v13 >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_12;
      }
LABEL_16:
      int64_t v16 = 0LL;
      goto LABEL_17;
    }
  }

  a2 = v13;
  if (a3 < 0) {
    goto LABEL_16;
  }
LABEL_12:
  if (v15 < a3) {
LABEL_17:
  }
    a3 = v16;
  if (v15 > (int)a2
    && ((*(uint64_t (**)(uint64_t, int64_t))(*(void *)v12 + 72LL))(v12, a2) & 0xFC00) == 0xDC00)
  {
    a2 = (__PAIR64__( a2,  (*(unsigned int (**)(uint64_t, int64_t))(*(void *)v12 + 80LL))(v12, a2) - 0x10000)
        - 0x100000) >> 32;
  }

  if (v15 > (int)a3
    && ((*(uint64_t (**)(uint64_t, int64_t))(*(void *)v12 + 72LL))(v12, a3) & 0xFC00) == 0xDC00)
  {
    LODWORD(a3) = (__PAIR64__( a3,  (*(unsigned int (**)(uint64_t, int64_t))(*(void *)v12 + 80LL))(v12, a3)
                   - 0x10000)
                 - 0x100000) >> 32;
  }

  uint64_t v17 = (a3 - a2);
  memset(&v20[2], 0, 32);
  else {
    a3 = (a2 + a5);
  }
  memset(v20, 0, 32);
  icu::UnicodeString::UnicodeString(v20, a4, 0LL, a5);
  (*(void (**)(uint64_t, int64_t, int64_t, _OWORD *))(*(void *)v12 + 24LL))(v12, a2, a3, v20);
  sub_18088484C(a1, (int)a3, 1);
  uint64_t v14 = u_terminateUChars(a4, a5, v17, a6);
  icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v20);
  return v14;
}

uint64_t sub_180884CFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (*a6 > 0) {
    return 0LL;
  }
  uint64_t v13 = *(void *)(a1 + 72);
  if (!a4 && a5)
  {
    uint64_t v6 = 0LL;
    int v14 = 1;
LABEL_8:
    *a6 = v14;
    return v6;
  }

  LODWORD(v15) = (*(uint64_t (**)(void))(*(void *)v13 + 64LL))(*(void *)(a1 + 72));
  if (a2 > a3)
  {
    uint64_t v6 = 0LL;
    int v14 = 8;
    goto LABEL_8;
  }

  int v16 = v15;
  uint64_t v17 = (int)v15;
  if (a2 < 0)
  {
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = (int)v15;
    if ((int)v15 >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_12;
      }
LABEL_16:
      uint64_t v17 = 0LL;
      goto LABEL_17;
    }
  }

  a2 = v15;
  if (a3 < 0) {
    goto LABEL_16;
  }
LABEL_12:
  if (v17 < a3) {
LABEL_17:
  }
    a3 = v17;
  if (v16 > (int)a2
    && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 72LL))(v13, a2) & 0xFC00) == 0xDC00
    && (int)a2 >= 1)
  {
    else {
      a2 = a2;
    }
  }

  if (v16 > (int)a3
    && ((*(uint64_t (**)(uint64_t, void))(*(void *)v13 + 72LL))(v13, (a3 - 1)) & 0xFC00) == 0xD800)
  {
    else {
      a3 = a3;
    }
  }

  memset(v22, 0, sizeof(v22));
  uint64_t v21 = a4;
  icu::UnicodeString::UnicodeString(v22, a5 >> 31, &v21);
  (*(void (**)(uint64_t, uint64_t, uint64_t, _OWORD *))(*(void *)v13 + 32LL))(v13, a2, a3, v22);
  uint64_t v6 = (*(unsigned int (**)(uint64_t))(*(void *)v13 + 64LL))(v13) - v16;
  if (*(void *)(a1 + 16) > (int)a2)
  {
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 36) = 0LL;
    *(void *)(a1 + 28) = 0LL;
    *(_DWORD *)(a1 + 44) = 0;
  }

  sub_18088484C(a1, (int)v6 + (int)a3, 1);
  icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v22);
  return v6;
}

uint64_t sub_180884F4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v12 = *(void *)(a1 + 72);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 64LL))(v12);
  if (*a6 > 0) {
    return result;
  }
  if (a2 > a3 || a2 < a4 && a4 < a3)
  {
    *a6 = 8;
    return result;
  }

  uint64_t v14 = (int)result;
  if (a2 < 0)
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = (int)result;
    if ((int)result >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_9;
      }
LABEL_15:
      uint64_t v15 = 0LL;
      goto LABEL_16;
    }
  }

  a2 = result;
  if (a3 < 0) {
    goto LABEL_15;
  }
LABEL_9:
  uint64_t v15 = v14;
  if (v14 >= a3)
  {
    if ((a4 & 0x8000000000000000LL) == 0) {
      goto LABEL_11;
    }
    goto LABEL_17;
  }

uint64_t sub_180885120(uint64_t result)
{
  if ((*(_BYTE *)(result + 8) & 0x20) != 0)
  {
    uint64_t v1 = result;
    uint64_t result = *(void *)(result + 72);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
    *(void *)(v1 + 72) = 0LL;
  }

  return result;
}

UText *sub_18088515C(UText *a1, unint64_t a2, int a3, UErrorCode *a4)
{
  uint64_t v8 = sub_18088454C(a1, a2, a4);
  if (a3)
  {
    uint64_t v9 = (uint64_t *)*(unsigned int *)a4;
    if ((int)v9 <= 0)
    {
      int v10 = *(UChar ***)(a2 + 72);
      uint64_t v11 = (icu::UnicodeString *)icu::UMemory::operator new(v9, (icu::UMemory *)0x40, v7);
      if (v11) {
        uint64_t v11 = icu::UnicodeString::UnicodeString(v11, v10);
      }
      v8->unint64_t context = v11;
      v8->providerProperties |= 0x28u;
    }
  }

  return v8;
}

uint64_t sub_1808851D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  else {
    return *(unsigned __int16 *)(v1 + 8) >> 5;
  }
}

BOOL sub_1808851F8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(int *)(a1 + 44);
  if (a2 < 0)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    uint64_t v4 = *(int *)(a1 + 44);
    if (v3 >= a2) {
      goto LABEL_6;
    }
  }

  a2 = v4;
LABEL_6:
  *(_DWORD *)(a1 + 40) = a2;
  if (a3 && a2 < v3) {
    return 1LL;
  }
  if (a3) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = a2 <= 0;
  }
  return !v6;
}

uint64_t sub_180885240(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  uint64_t v11 = *(void *)(a1 + 72);
  else {
    int v12 = *(unsigned __int16 *)(v11 + 8) >> 5;
  }
  if (*a6 > 0) {
    return 0LL;
  }
  if (a5 < 0 || !a4 && a5) {
    *a6 = 1;
  }
  if (a2 < 0 || a2 > a3)
  {
    uint64_t v13 = 0LL;
    *a6 = 8;
  }

  else
  {
    int Char32Start = v12;
    if (v12 > a2) {
      int Char32Start = icu::UnicodeString::getChar32Start((icu::UnicodeString *)v11, a2);
    }
    if (v12 > a3) {
      int v12 = icu::UnicodeString::getChar32Start((icu::UnicodeString *)v11, a3);
    }
    uint64_t v13 = (v12 - Char32Start);
    if (a4 && a5 >= 1)
    {
      else {
        int v15 = v12 - Char32Start;
      }
      icu::UnicodeString::doExtract((char *)v11, Char32Start, v15, a4, 0);
      Char32Start += v15;
    }

    *(_DWORD *)(a1 + 40) = Char32Start;
    u_terminateUChars(a4, a5, v13, a6);
  }

  return v13;
}

uint64_t sub_180885380(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  uint64_t v9 = a3;
  uint64_t Char32Start = a2;
  uint64_t v12 = *(void *)(a1 + 72);
  if (!a4 && (_DWORD)a5) {
    *a6 = 1;
  }
  if (a2 > a3)
  {
    uint64_t result = 0LL;
    *a6 = 8;
    return result;
  }

  else {
    int v13 = *(unsigned __int16 *)(v12 + 8) >> 5;
  }
  int v14 = v13;
  if (a2 < 0)
  {
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = v13;
    if (v13 >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_14;
      }
      goto LABEL_18;
    }
  }

  uint64_t Char32Start = v15;
  if ((a3 & 0x8000000000000000LL) == 0)
  {
LABEL_14:
    uint64_t v16 = v13;
    if (v13 >= a3) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

uint64_t sub_18088550C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  uint64_t v7 = a4;
  uint64_t v8 = a3;
  uint64_t v9 = a2;
  uint64_t v10 = result;
  uint64_t v11 = *(void *)(result + 72);
  else {
    LODWORD(v12) = *(unsigned __int16 *)(v11 + 8) >> 5;
  }
  if (*a6 > 0) {
    return result;
  }
  uint64_t v12 = (int)v12;
  if (a2 < 0)
  {
    uint64_t v13 = 0LL;
  }

  else
  {
    uint64_t v13 = (int)v12;
    if ((int)v12 >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_8;
      }
LABEL_14:
      uint64_t result = 0LL;
      goto LABEL_15;
    }
  }

  uint64_t v9 = v13;
  if (a3 < 0) {
    goto LABEL_14;
  }
LABEL_8:
  uint64_t result = (int)v12;
  if ((int)v12 >= a3)
  {
    if ((a4 & 0x8000000000000000LL) == 0) {
      goto LABEL_10;
    }
    goto LABEL_16;
  }

uint64_t sub_1808856E4(uint64_t result)
{
  if ((*(_BYTE *)(result + 8) & 0x20) != 0)
  {
    uint64_t v1 = result;
    uint64_t result = *(void *)(result + 72);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
    *(void *)(v1 + 72) = 0LL;
  }

  return result;
}

UText *sub_180885720(UText *a1, unint64_t a2, int a3, UErrorCode *a4)
{
  uint64_t v7 = sub_18088454C(a1, a2, a4);
  uint64_t v8 = v7;
  if (a3 && *(int *)a4 <= 0)
  {
    uint64_t v9 = ((uint64_t (*)(UText *))v7->pFuncs->nativeLength)(v7);
    uint64_t v10 = *(__int16 **)(a2 + 72);
    uint64_t v11 = uprv_malloc(((v9 << 32) + 0x100000000LL) >> 31);
    if (v11)
    {
      if (v9 << 32 >= 1)
      {
        else {
          uint64_t v12 = (int)v9;
        }
        uint64_t v13 = v11;
        do
        {
          __int16 v14 = *v10++;
          *v13++ = v14;
          --v12;
        }

        while (v12);
      }

      v11[(int)v9] = 0;
      v8->unint64_t context = v11;
      v8->providerProperties |= 0x20u;
    }

    else
    {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return v8;
}

uint64_t sub_1808857E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 112);
  if (v1 < 0)
  {
    uint64_t v2 = *(void *)(a1 + 72);
    uint64_t v1 = *(void *)(a1 + 16);
    if (*(_WORD *)(v2 + 2 * v1))
    {
      uint64_t v3 = v2 + 2;
      *(void *)(a1 + 16) = v1;
    }

    *(void *)(a1 + 112) = v1;
    *(_DWORD *)(a1 + 44) = v1;
    *(_DWORD *)(a1 + 28) = v1;
    *(_DWORD *)(a1 + 8) &= ~2u;
  }

  return v1;
}

BOOL sub_180885830(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 < 0)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 72);
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4 <= a2)
    {
      uint64_t v5 = *(void *)(a1 + 112);
      if (v5 < 0)
      {
        int v6 = a2 + 32;
        if (v6 <= (int)v4)
        {
LABEL_17:
          uint64_t v5 = a2 - 1;
          if (a2 >= 1 && (*(_WORD *)(v3 + 2 * a2) & 0xFC00) == 0xDC00)
          {
            if ((*(_WORD *)(v3 + 2 * v5) & 0xFC00) != 0xD800) {
              uint64_t v5 = a2;
            }
          }

          else
          {
            uint64_t v5 = a2;
          }

          if ((_DWORD)v4 != 0x7FFFFFFF)
          {
            else {
              int v7 = v4;
            }
            *(void *)(a1 + 16) = v7;
            *(_DWORD *)(a1 + 28) = v7;
            *(_DWORD *)(a1 + 44) = v7;
            goto LABEL_41;
          }

          *(void *)(a1 + 112) = 0x7FFFFFFFLL;
          *(_DWORD *)(a1 + 44) = 0x7FFFFFFF;
          *(_DWORD *)(a1 + 28) = 0x7FFFFFFF;
          if (v5 >= 0x7FFFFFFF) {
            uint64_t v5 = 0x7FFFFFFFLL;
          }
          *(void *)(a1 + 16) = 0x7FFFFFFFLL;
        }

        else
        {
          uint64_t v4 = (int)v4;
          while (*(_WORD *)(v3 + 2 * v4))
          {
            if (v6 == ++v4)
            {
              LODWORD(v4) = v6;
              goto LABEL_17;
            }
          }

          *(void *)(a1 + 112) = v4;
          *(_DWORD *)(a1 + 44) = v4;
          uint64_t v5 = v4;
          *(_DWORD *)(a1 + 28) = v4;
          if (v4 > a2)
          {
            uint64_t v5 = a2 - 1;
            if (a2 >= 1 && (*(_WORD *)(v3 + 2 * a2) & 0xFC00) == 0xDC00)
            {
              if ((*(_WORD *)(v3 + 2 * v5) & 0xFC00) != 0xD800) {
                uint64_t v5 = a2;
              }
            }

            else
            {
              uint64_t v5 = a2;
            }
          }

          *(void *)(a1 + 16) = v4;
        }

        *(_DWORD *)(a1 + 8) &= ~2u;
      }
    }

    else if (a2 && (*(_WORD *)(v3 + 2 * a2) & 0xFC00) == 0xDC00)
    {
      uint64_t v5 = a2 - 1;
      if ((*(_WORD *)(v3 + 2 * (a2 - 1)) & 0xFC00) != 0xD800) {
        uint64_t v5 = a2;
      }
    }

    else
    {
      uint64_t v5 = a2;
    }
  }

uint64_t sub_1808859E8(uint64_t a1, uint64_t a2, int64_t a3, uint64_t a4, int a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  if (a5 < 0 || ((unint64_t v10 = a3, !a4) ? (v11 = a5 == 0) : (v11 = 1), v11 ? (v12 = 0) : (v12 = 1), a3 < a2 || v12))
  {
    uint64_t v6 = 0LL;
    *a6 = 1;
    return v6;
  }

  sub_180885830(a1, a2, 1);
  int v14 = *(_DWORD *)(a1 + 40);
  uint64_t v15 = *(void *)(a1 + 112);
  if ((v15 & 0x80000000) != 0)
  {
    if ((v10 & 0x8000000000000000LL) != 0)
    {
      LODWORD(v10) = 0;
    }

    else if (v10 >> 31)
    {
      LODWORD(v10) = 0x7FFFFFFF;
    }

    goto LABEL_23;
  }

  if ((v10 & 0x8000000000000000LL) != 0)
  {
    unsigned int v16 = 0;
  }

  else
  {
    unsigned int v16 = *(void *)(a1 + 112);
    if (v16 >= v10) {
      goto LABEL_23;
    }
  }

  LODWORD(v10) = v16;
LABEL_23:
  uint64_t v17 = *(void *)(a1 + 48);
  uint64_t v6 = (v10 - v14);
  if ((int)v10 <= v14)
  {
    uint64_t v6 = 0LL;
    LODWORD(v10) = *(_DWORD *)(a1 + 40);
  }

  else
  {
    unint64_t v18 = 0LL;
    uint64_t v19 = v17 + 2LL * v14;
    while ((v15 & 0x80000000) == 0 || *(_WORD *)(v19 + 2 * v18))
    {
      if (v18 >= a5)
      {
        if ((v15 & 0x80000000) == 0) {
          goto LABEL_33;
        }
      }

      else
      {
        *(_WORD *)(a4 + 2 * v18) = *(_WORD *)(v19 + 2 * v18);
      }

      if (v6 == ++v18)
      {
        LODWORD(v10) = v14 + v18;
        goto LABEL_33;
      }
    }

    *(void *)(a1 + 112) = v14 + v18;
    LODWORD(v10) = v14 + v18;
    *(void *)(a1 + 16) = v14 + v18;
    *(_DWORD *)(a1 + 44) = v14 + v18;
    *(_DWORD *)(a1 + 28) = v14 + v18;
    uint64_t v6 = v18;
    LODWORD(v15) = v14 + v18;
  }

void sub_180885BC0(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 8) & 0x20) != 0)
  {
    uprv_free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0LL;
  }

UText *sub_180885BF0(UText *a1, uint64_t a2, int a3, UErrorCode *a4)
{
  if (a3)
  {
    uint64_t v4 = 0LL;
    *a4 = U_UNSUPPORTED_ERROR;
  }

  else
  {
    uint64_t v8 = (int *)(*(uint64_t (**)(void))(**(void **)(a2 + 72) + 64LL))(*(void *)(a2 + 72));
    double v9 = utext_openCharacterIterator(a1, v8, a4);
    uint64_t v4 = v10;
    if (*(int *)a4 <= 0)
    {
      uint64_t v11 = *(int *)(a2 + 40);
      else {
        int64_t v12 = (*(uint64_t (**)(uint64_t, double))(*(void *)(a2 + 56) + 64LL))(a2, v9);
      }
      utext_setNativeIndex(v4, v12);
      v4->unint64_t r = v8;
    }
  }

  return v4;
}

uint64_t sub_180885CB8(uint64_t a1)
{
  return *(int *)(a1 + 112);
}

BOOL sub_180885CC0(uint64_t a1, unsigned int a2, int a3)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 112);
    if (v4 <= a2) {
      int v5 = *(void *)(a1 + 112);
    }
    else {
      int v5 = a2;
    }
    BOOL v6 = v5 > 0;
    if (a3 || (int v7 = v5 - 1, v5 < 1))
    {
      if (!a3)
      {
        char v8 = 1;
        int v7 = v5;
        goto LABEL_17;
      }

      goto LABEL_11;
    }

uint64_t sub_180885E6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  if (a5 < 0 || ((signed int v10 = a3, !a4) ? (v11 = a5 == 0) : (v11 = 1), v11 ? (v12 = 0) : (v12 = 1), a2 > a3 || v12))
  {
    uint64_t v6 = 0LL;
    *a6 = 1;
    return v6;
  }

  uint64_t v14 = *(int *)(a1 + 112);
  if (a2 < 0)
  {
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = *(int *)(a1 + 112);
    if (v14 >= a2)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_15;
      }
      goto LABEL_20;
    }
  }

  a2 = v15;
  if ((a3 & 0x8000000000000000LL) == 0)
  {
LABEL_15:
    if (v14 >= a3) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

uint64_t sub_180886010(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 96);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  *(void *)(a1 + 96) = 0LL;
  return result;
}

UChar32 utf8_nextCharSafeBody(const uint8_t *s, int32_t *pi, int32_t length, UChar32 c, UBool strict)
{
  int32_t v5 = *pi;
  LODWORD(v6) = *pi;
  if (c <= 244 && v5 != length)
  {
    if (c < 240)
    {
      if (c < 224)
      {
        if (c >= 194)
        {
          unsigned int v14 = s[v5] ^ 0x80;
          if (v14 <= 0x3F)
          {
            *puint64_t i = v5 + 1;
            return ((c << 6) - 12288) | v14;
          }
        }
      }

      else
      {
        uint64_t v8 = c & 0xF;
        int v9 = s[v5];
        if (strict == -2)
        {
          unsigned int v10 = v9 ^ 0x80;
          if (v10 <= 0x3F && ((c & 0xF) != 0 || v10 >= 0x20))
          {
            uint64_t v11 = v5 + 1LL;
            LODWORD(v6) = length;
            if ((_DWORD)v11 != length)
            {
              unsigned int v12 = s[v11] ^ 0x80;
              LODWORD(v6) = v5 + 1;
              if (v12 <= 0x3F)
              {
                *puint64_t i = v5 + 2;
                return (v10 << 6) | ((_DWORD)v8 << 12) | v12;
              }
            }
          }

          goto LABEL_41;
        }

        if (((a00000000000000[v8] >> (s[v5] >> 5)) & 1) != 0)
        {
          LODWORD(v6) = length;
          if (v5 + 1 != length)
          {
            unsigned int v18 = s[v5 + 1] ^ 0x80;
            LODWORD(v6) = v5 + 1;
            if (v18 <= 0x3F)
            {
              LODWORD(v6) = v5 + 2;
              UChar32 result = ((_DWORD)v8 << 12) | ((v9 & 0x3F) << 6) | v18;
              if (result >> 4 >= 0xFDF
                && (unsigned __int16)(((_WORD)v8 << 12) | ((v9 & 0x3F) << 6) | v18 & 0xFFFE) != 65534)
              {
                goto LABEL_44;
              }

              goto LABEL_40;
            }
          }
        }
      }
    }

    else
    {
      unint64_t v7 = s[v5];
      if (((byte_180A2CA60[v7 >> 4] >> (c & 7)) & 1) != 0)
      {
        uint64_t v6 = v5 + 1LL;
        if (v5 + 1 == length)
        {
          LODWORD(v6) = length;
        }

        else
        {
          unsigned int v15 = s[v6] ^ 0x80;
          if (v15 <= 0x3F)
          {
            LODWORD(v6) = length;
            if (v5 + 2 != length)
            {
              unsigned int v16 = s[v5 + 2] ^ 0x80;
              LODWORD(v6) = v5 + 2;
              if (v16 <= 0x3F)
              {
                LODWORD(v6) = v5 + 3;
                UChar32 result = ((c & 7) << 18) | ((v7 & 0x3F) << 12) | (v15 << 6) | v16;
                if (result >> 4 >= 0xFDF
                  && (HIWORD(result) > 0x10u
                   || (((v7 & 0x3F) << 12) & 0xFFFE | (v15 << 6) & 0xFFFE | (unsigned __int16)v16 & 0xFFFE) != 65534))
                {
                  goto LABEL_44;
                }

                goto LABEL_40;
              }
            }
          }
        }
      }
    }
  }

  if (strict < 0)
  {
LABEL_41:
    if (strict == -3) {
      UChar32 result = 65533;
    }
    else {
      UChar32 result = -1;
    }
    goto LABEL_44;
  }

int32_t utf8_appendCharSafeBody(uint8_t *s, int32_t i, int32_t length, UChar32 c, UBool *pIsError)
{
  if (c > 0x7FF)
  {
    if (HIWORD(c))
    {
      if (HIWORD(c) > 0x10u) {
        goto LABEL_12;
      }
      uint64_t v6 = i + 3LL;
      int v9 = &s[i];
      *int v9 = (c >> 18) | 0xF0;
      v9[1] = (c >> 12) & 0x3F | 0x80;
      v9[2] = (c >> 6) & 0x3F | 0x80;
      uint8_t v8 = c & 0x3F | 0x80;
      i += 4;
    }

    else
    {
      uint64_t v6 = i + 2LL;
      unint64_t v7 = &s[i];
      *unint64_t v7 = (c >> 12) | 0xE0;
      v7[1] = (c >> 6) & 0x3F | 0x80;
      uint8_t v8 = c & 0x3F | 0x80;
      i += 3;
    }

    s[v6] = v8;
    return i;
  }

  uint64_t v5 = i + 1LL;
  if ((int)v5 < length)
  {
    s[i] = (c >> 6) | 0xC0;
    i += 2;
    s[v5] = c & 0x3F | 0x80;
    return i;
  }

UChar32 utf8_prevCharSafeBody(const uint8_t *s, int32_t start, int32_t *pi, UChar32 c, UBool strict)
{
  if (c << 24 > -1073741825) {
    goto LABEL_43;
  }
  int32_t v5 = *pi;
  if (*pi <= start) {
    goto LABEL_43;
  }
  uint64_t v6 = v5;
  uint64_t v7 = v5 - 1LL;
  unint64_t v8 = s[v7];
  if ((v8 + 62) <= 0x32u)
  {
    if (v8 <= 0xDF)
    {
      *puint64_t i = v7;
      return (c & 0x3F | ((_DWORD)v8 << 6)) - 12288;
    }

    uint8_t v16 = &byte_180A2CA60[c >> 4];
    signed int v17 = &a00000000000000[v8 & 0xF];
    if (v8 <= 0xEF)
    {
      LOBYTE(v8) = c >> 5;
      uint8_t v16 = (unsigned __int8 *)v17;
    }

    if (((*v16 >> (v8 & 7)) & 1) != 0)
    {
      *puint64_t i = v7;
      if ((strict & 0x80000000) == 0) {
        return 159;
      }
      goto LABEL_45;
    }

    goto LABEL_43;
  }

  int v10 = c & 0x3F;
  int32_t v11 = v6 - 2;
  unint64_t v12 = s[v6 - 2];
  if ((v12 + 32) > 0x14u)
  {
    if (v11 <= start) {
      goto LABEL_43;
    }
    int32_t v18 = v6 - 3;
    uint8_t v19 = s[v6 - 3];
    int v20 = v19 & 7;
    if (((byte_180A2CA60[v12 >> 4] >> v20) & 1) == 0) {
      goto LABEL_43;
    }
    *puint64_t i = v18;
    UChar32 result = ((v12 & 0x3F) << 12) | (v20 << 18) | ((v8 & 0x3F) << 6) | v10;
    if (strict >= 1
      && result >> 4 >= 0xFDD
      && (result >> 4 < 0xFDF
       || HIWORD(result) <= 0x10u
       && (((v12 & 0x3F) << 12) & 0xFFFE | ((v8 & 0x3F) << 6) | c & 0x3E) == 0xFFFE))
    {
      return 1114111;
    }
  }

  else
  {
    if (v12 > 0xEF)
    {
      if (((byte_180A2CA60[v8 >> 4] >> (v12 & 7)) & 1) != 0)
      {
        *puint64_t i = v11;
        if ((strict & 0x80000000) == 0) {
          return 0xFFFF;
        }
        goto LABEL_45;
      }

      goto LABEL_43;
    }

    uint64_t v13 = v12 & 0xF;
    if (strict == -2)
    {
      unsigned int v14 = v8 ^ 0x80;
      if (v14 > 0x1F || (_DWORD)v13 != 0)
      {
        *puint64_t i = v11;
        return (v14 << 6) | ((_DWORD)v13 << 12) | v10;
      }

int32_t utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i)
{
  uint64_t v3 = i - 1LL;
  unint64_t v4 = s[v3];
  if ((v4 + 62) > 0x32u)
  {
    LODWORD(v3) = i - 2;
    unint64_t v9 = s[i - 2];
    if ((v9 + 32) > 0x14u)
    {
      LODWORD(v3) = i - 3;
      uint8_t v15 = s[i - 3];
    }

    else
    {
      BOOL v5 = v9 > 0xEF;
      int v10 = &byte_180A2CA60[v4 >> 4];
      char v11 = v9 & 7;
      unint64_t v12 = &a00000000000000[v9 & 0xF];
      unsigned int v13 = v4 >> 5;
      if (v5) {
        LOBYTE(v13) = v11;
      }
      else {
        int v10 = (unsigned __int8 *)v12;
      }
      if (((*v10 >> v13) & 1) == 0) {
        return i;
      }
    }

    return v3;
  }

  BOOL v5 = v4 > 0xEF;
  char v6 = v4 & 7;
  uint64_t v7 = (unsigned __int8 *)&a00000000000000[v4 & 0xF];
  int v8 = s[i] >> 5;
  if (v5)
  {
    LOBYTE(v8) = v6;
    uint64_t v7 = &byte_180A2CA60[s[i] >> 4];
  }

  if (((*v7 >> v8) & 1) != 0) {
    return v3;
  }
  return i;
}

icu::ICU_Utility *icu::ICU_Utility::appendNumber( icu::ICU_Utility *this, icu::UnicodeString *a2, unsigned int a3, int a4)
{
  unint64_t v4 = this;
  if (a3 - 37 > 0xFFFFFFDC)
  {
    int v7 = (int)a2;
    if ((a2 & 0x80000000) != 0)
    {
      int v7 = -(int)a2;
      __int16 v14 = 45;
      icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v14, 0, 1LL);
    }

    int v8 = 1;
    if (v7 >= a3)
    {
      int v9 = v7;
      do
      {
        v9 /= a3;
        v8 *= a3;
        --a4;
      }

      while (v9 >= (int)a3);
    }

    if (a4 > 1)
    {
      unsigned int v10 = a4 + 1;
      do
      {
        __int16 v15 = 48;
        icu::UnicodeString::doAppend((uint64_t)v4, (uint64_t)&v15, 0, 1LL);
        --v10;
      }

      while (v10 > 2);
    }

    if (v8 >= 1)
    {
      do
      {
        __int16 v16 = a0123456789abcd_1[v7 / v8];
        icu::UnicodeString::doAppend((uint64_t)v4, (uint64_t)&v16, 0, 1LL);
        v7 %= v8;
        BOOL v11 = v8 >= a3;
        v8 /= a3;
      }

      while (v11);
    }
  }

  else
  {
    __int16 v13 = 63;
    return (icu::ICU_Utility *)icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v13, 0, 1LL);
  }

  return v4;
}

BOOL icu::ICU_Utility::isUnprintable(icu::ICU_Utility *this)
{
  return ((_DWORD)this - 127) < 0xFFFFFFA1;
}

BOOL icu::ICU_Utility::shouldAlwaysBeEscaped(icu::ICU_Utility *this)
{
  unsigned int v2 = this;
  BOOL result = 1LL;
  if ((~v2 & 0xFFFE) != 0)
  {
    BOOL v3 = v2 - 64976 < 0x20 || HIWORD(v2) > 0x10u;
    return v2 < 0xE000 || v3;
  }

  return result;
}

uint64_t icu::ICU_Utility::escapeUnprintable(icu::ICU_Utility *this, icu::UnicodeString *a2)
{
  return 1LL;
}

icu::ICU_Utility *icu::ICU_Utility::escape(icu::ICU_Utility *this, icu::UnicodeString *a2)
{
  unsigned int v2 = a2;
  __int16 v6 = 92;
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
  if (v2 >= 0x10000)
  {
    __int16 v6 = 85;
    icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
    __int16 v6 = a0123456789abcd_1[v2 >> 28];
    icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
    __int16 v6 = a0123456789abcd_1[HIBYTE(v2) & 0xF];
    icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
    __int16 v6 = a0123456789abcd_1[(v2 >> 20) & 0xF];
    icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
    __int16 v4 = a0123456789abcd_1[HIWORD(v2) & 0xF];
  }

  else
  {
    __int16 v4 = 117;
  }

  __int16 v6 = v4;
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
  __int16 v6 = a0123456789abcd_1[(unsigned __int16)v2 >> 12];
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
  __int16 v6 = a0123456789abcd_1[(v2 >> 8) & 0xF];
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
  __int16 v6 = a0123456789abcd_1[v2 >> 4];
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
  __int16 v6 = a0123456789abcd_1[v2 & 0xF];
  icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v6, 0, 1LL);
  return this;
}

unint64_t icu::ICU_Utility::skipWhitespace( icu::ICU_Utility *this, const icu::UnicodeString *a2, int *a3)
{
  int v3 = (int)a3;
  unsigned int v5 = *((unsigned __int16 *)this + 4);
  if ((v5 & 0x11) != 0)
  {
    __int16 v6 = 0LL;
  }

  else if ((v5 & 2) != 0)
  {
    __int16 v6 = (char *)this + 10;
  }

  else
  {
    __int16 v6 = (char *)*((void *)this + 3);
  }

  int v7 = (__int16)v5;
  unsigned int v8 = v5 >> 5;
  if (v7 < 0) {
    unsigned int v8 = *((_DWORD *)this + 3);
  }
  unint64_t result = (unint64_t)((char *)icu::PatternProps::skipWhiteSpace( (unsigned __int16 *)&v6[2 * *(int *)a2],  v8 - *(_DWORD *)a2)
                            - v6) >> 1;
  if (v3) {
    *(_DWORD *)a2 = result;
  }
  return result;
}

BOOL icu::ICU_Utility::parseChar(uint64_t a1, const icu::UnicodeString *a2, int a3)
{
  int v6 = *(_DWORD *)a2;
  icu::ICU_Utility::skipWhitespace((icu::ICU_Utility *)a1, a2, (int *)1);
  uint64_t v7 = *(int *)a2;
  unsigned int v8 = *(unsigned __int16 *)(a1 + 8);
  if ((v8 & 0x8000) != 0)
  {
    unsigned int v9 = *(_DWORD *)(a1 + 12);
    if ((_DWORD)v7 != v9) {
      goto LABEL_6;
    }
LABEL_5:
    BOOL result = 0LL;
    goto LABEL_14;
  }

  if ((_DWORD)v7 == v8 >> 5) {
    goto LABEL_5;
  }
  unsigned int v9 = v8 >> 5;
LABEL_6:
  if (v9 <= v7)
  {
    int v12 = 0xFFFF;
  }

  else
  {
    if ((v8 & 2) != 0) {
      uint64_t v11 = a1 + 10;
    }
    else {
      uint64_t v11 = *(void *)(a1 + 24);
    }
    int v12 = *(unsigned __int16 *)(v11 + 2 * v7);
  }

  BOOL result = v12 == a3;
  if (v12 == a3) {
    int v6 = v7 + 1;
  }
LABEL_14:
  *(_DWORD *)a2 = v6;
  return result;
}

unint64_t icu::ICU_Utility::parsePattern( icu::ICU_Utility *this, const icu::UnicodeString *a2, unint64_t a3, int a4)
{
  unsigned int v5 = *((unsigned __int16 *)this + 4);
  int v6 = (__int16)v5;
  LODWORD(v7) = v5 >> 5;
  if (v6 >= 0) {
    unint64_t v7 = v7;
  }
  else {
    unint64_t v7 = *((unsigned int *)this + 3);
  }
  if ((_DWORD)v7)
  {
    unsigned int v11 = icu::UnicodeString::char32At((uint64_t *)v7, this, 0);
    if ((int)a3 < a4)
    {
      unsigned int v12 = v11;
      int v13 = 0;
      do
      {
        __int16 v14 = (icu::PatternProps *)(*(uint64_t (**)(const icu::UnicodeString *, unint64_t))(*(void *)a2 + 80LL))( a2,  a3);
        unsigned int v15 = v14;
        if (v12 == 126)
        {
          if (icu::PatternProps::isWhiteSpace(v14))
          {
            if (v15 < 0x10000) {
              int v16 = 1;
            }
            else {
              int v16 = 2;
            }
            a3 = (v16 + a3);
            unsigned int v12 = 126;
            continue;
          }

          ++v13;
        }

        else
        {
          if ((_DWORD)v14 != v12) {
            return 0xFFFFFFFFLL;
          }
          if (v12 < 0x10000) {
            int v17 = 1;
          }
          else {
            int v17 = 2;
          }
          a3 = (v17 + a3);
          v13 += v17;
        }

        unsigned int v18 = *((unsigned __int16 *)this + 4);
        int v19 = (__int16)v18;
        LODWORD(v20) = v18 >> 5;
        if (v19 >= 0) {
          unint64_t v20 = v20;
        }
        else {
          unint64_t v20 = *((unsigned int *)this + 3);
        }
        if (v13 == (_DWORD)v20) {
          return a3;
        }
        unsigned int v12 = icu::UnicodeString::char32At((uint64_t *)v20, this, v13);
      }

      while ((int)a3 < a4);
    }

    return 0xFFFFFFFFLL;
  }

  return a3;
}

uint64_t icu::ICU_Utility::parseAsciiInteger(icu::ICU_Utility *this, const icu::UnicodeString *a2, int *a3)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = *(int *)a2;
  for (uint64_t i = 2 * v4; ; i += 2LL)
  {
    unsigned int v6 = *((unsigned __int16 *)this + 4);
    if (*((__int16 *)this + 4) < 0)
    {
      int v7 = *((_DWORD *)this + 3);
    }

    else
    {
      int v7 = v6 >> 5;
    }

    unsigned int v8 = (v6 & 2) != 0 ? (icu::ICU_Utility *)((char *)this + 10) : (icu::ICU_Utility *)*((void *)this + 3);
    int v9 = *(unsigned __int16 *)((char *)v8 + i);
    uint64_t v3 = (v9 + 10 * v3 - 48);
    LODWORD(v4) = v4 + 1;
    *(_DWORD *)a2 = v4;
  }

  return v3;
}

icu::ICU_Utility *icu::ICU_Utility::appendToRule( icu::ICU_Utility *this, icu::UnicodeString *a2, int a3, int a4, icu::UnicodeString *a5, icu::UnicodeString *a6)
{
  int v9 = this;
  if (!a3 && (((_DWORD)a2 - 32) < 0x5F || !a4))
  {
    unsigned int v29 = *((unsigned __int16 *)a5 + 4);
    int v30 = (__int16)v29;
    int v31 = v29 >> 5;
    if (v30 < 0) {
      int v31 = *((_DWORD *)a5 + 3);
    }
    if (v31)
    {
      if (v31 > 0)
      {
LABEL_87:
        this = (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)a5, a2);
        if ((_DWORD)a2 == 39) {
          return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)a5, 0x27u);
        }
        return this;
      }
    }

    else if ((_DWORD)a2 == 92 || (_DWORD)a2 == 39)
    {
      __int16 v45 = 92;
      icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v45, 0, 1LL);
LABEL_80:
      uint64_t v37 = (uint64_t)v9;
      unsigned int v38 = a2;
      return (icu::ICU_Utility *)icu::UnicodeString::append(v37, v38);
    }

    if ((((_DWORD)a2 - 127) < 0xFFFFFFA2
       || ((_DWORD)a2 - 48) < 0xA
       || (a2 & 0xFFFFFFDF) - 65 <= 0x19)
      && !icu::PatternProps::isWhiteSpace(a2))
    {
      return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)v9, a2);
    }

    goto LABEL_87;
  }

  unsigned int v10 = *((unsigned __int16 *)a5 + 4);
  int v11 = (__int16)v10;
  int v12 = v10 >> 5;
  if (v11 < 0) {
    int v12 = *((_DWORD *)a5 + 3);
  }
  if (v12 < 1) {
    goto LABEL_63;
  }
  if ((v11 & 0x8000) != 0) {
    goto LABEL_10;
  }
LABEL_8:
  if ((unsigned __int16)v11 >= 0x40u)
  {
    do
    {
      int v13 = (_WORD *)*((void *)a5 + 3);
      if ((v11 & 2) != 0) {
        int v13 = (_WORD *)((char *)a5 + 10);
      }
      if (*v13 != 39) {
        break;
      }
      unsigned int v14 = (v11 & 0x8000u) == 0 ? (unsigned __int16)v11 >> 5 : *((_DWORD *)a5 + 3);
      if (v14 < 2 || v13[1] != 39) {
        break;
      }
      __int16 v39 = 92;
      uint64_t v15 = icu::UnicodeString::doAppend((uint64_t)v9, (uint64_t)&v39, 0, 1LL);
      __int16 v40 = 39;
      icu::UnicodeString::doAppend(v15, (uint64_t)&v40, 0, 1LL);
      this = (icu::ICU_Utility *)icu::UnicodeString::doReplace((uint64_t)a5, 0LL, 2LL, 0LL, 0, 0LL);
      LOWORD(v1sub_18086E18C((uint64_t)this, 1) = *((_WORD *)a5 + 4);
      if ((v11 & 0x8000) == 0) {
        goto LABEL_8;
      }
LABEL_10:
      ;
    }

    while (*((int *)a5 + 3) > 1);
  }

  for (int i = 1; ; ++i)
  {
    int v17 = (unsigned __int16)v11 >> 5;
    if ((v11 & 0x8000) != 0)
    {
      int v18 = *((_DWORD *)a5 + 3);
      if (v18 <= 1) {
        goto LABEL_44;
      }
    }

    else
    {
      int v18 = (unsigned __int16)v11 >> 5;
    }

    int v19 = v18 - 2;
    unint64_t v20 = (char *)*((void *)a5 + 3);
    if ((v11 & 2) != 0) {
      unint64_t v20 = (char *)a5 + 10;
    }
    if (*(_WORD *)&v20[2 * v19] != 39) {
      break;
    }
    if ((v11 & 0x8000) != 0)
    {
      unsigned int v21 = *((_DWORD *)a5 + 3);
      if (!v21) {
        goto LABEL_44;
      }
      if (*(_WORD *)&v20[2 * (v21 - 1)] != 39) {
        break;
      }
      int v22 = v21 - 2;
      if ((v11 & 1) == 0) {
        goto LABEL_38;
      }
    }

    else
    {
      if (*(_WORD *)&v20[2 * (v17 - 1)] != 39) {
        goto LABEL_45;
      }
      unsigned int v21 = (unsigned __int16)v11 >> 5;
      int v22 = v17 - 2;
      if ((v11 & 1) == 0) {
        goto LABEL_38;
      }
    }

    if (!v22)
    {
      this = (icu::ICU_Utility *)icu::UnicodeString::unBogus((uint64_t)a5);
      LOWORD(v1sub_18086E18C((uint64_t)this, 1) = *((_WORD *)a5 + 4);
      continue;
    }

icu::ICU_Utility *icu::ICU_Utility::appendToRule( icu::ICU_Utility *this, icu::UnicodeString *a2, const icu::UnicodeString *a3, int a4, icu::UnicodeString *a5, icu::UnicodeString *a6)
{
  int v8 = (int)a3;
  unsigned int v10 = this;
  unint64_t v11 = 0LL;
  int v12 = (char *)a2 + 10;
  while (1)
  {
    int v13 = *((__int16 *)a2 + 4);
    if (v13 < 0) {
      break;
    }
    unint64_t v14 = (unint64_t)*((unsigned __int16 *)a2 + 4) >> 5;
LABEL_7:
    if (v14 <= v11)
    {
      uint64_t v16 = 0xFFFFLL;
    }

    else
    {
      if ((v13 & 2) != 0) {
        uint64_t v15 = v12;
      }
      else {
        uint64_t v15 = (char *)*((void *)a2 + 3);
      }
      uint64_t v16 = *(unsigned __int16 *)&v15[2 * v11];
    }

    this = icu::ICU_Utility::appendToRule(v10, (icu::UnicodeString *)v16, v8, a4, a5, a6);
    ++v11;
  }

  if ((uint64_t)v11 < *((int *)a2 + 3))
  {
    unint64_t v14 = *((unsigned int *)a2 + 3);
    goto LABEL_7;
  }

  return this;
}

icu::ICU_Utility *icu::ICU_Utility::appendToRule( icu::ICU_Utility *this, icu::UnicodeString *a2, const icu::UnicodeMatcher *a3, icu::UnicodeString *a4, icu::UnicodeString *a5)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    int v6 = (int)a3;
    int v7 = this;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    uint64_t v15 = 0LL;
    __int128 v14 = 0u;
    unint64_t v11 = off_18971B688;
    LOWORD(v12) = 2;
    int v8 = (icu::UnicodeString *)(*(uint64_t (**)(icu::UnicodeString *, void (***)(icu::UnicodeString *__hidden), const icu::UnicodeMatcher *, icu::UnicodeString *, icu::UnicodeString *))(*(void *)a2 + 24LL))( a2,  &v11,  a3,  a4,  a5);
    icu::ICU_Utility::appendToRule(v7, v8, (const icu::UnicodeString *)1, v6, a4, v9);
    return (icu::ICU_Utility *)icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)&v11);
  }

  return this;
}

uint64_t icu::ICU_Utility::parseInteger(icu::ICU_Utility *this, const icu::UnicodeString *a2, int *a3)
{
  int v5 = *(_DWORD *)a2;
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  unsigned int v7 = (v6 & 0x8000u) == 0 ? v6 >> 5 : *((_DWORD *)this + 3);
  if (v7 <= v5) {
    goto LABEL_13;
  }
  int v8 = (char *)this + 10;
  if ((v6 & 2) == 0) {
    int v8 = (char *)*((void *)this + 3);
  }
  if (*(_WORD *)&v8[2 * v5] == 48)
  {
    unsigned int v9 = v5 + 1;
    int v10 = 8;
    int v11 = 1;
    if (v5 + 1 < (int)a3 && v7 > v9 && (*(unsigned __int16 *)&v8[2 * v9] | 0x20) == 0x78)
    {
      int v11 = 0;
      v5 += 2;
      int v10 = 16;
    }

    else
    {
      ++v5;
    }
  }

  else
  {
LABEL_13:
    int v11 = 0;
    int v10 = 10;
  }

  uint64_t v12 = 0LL;
  uint64_t v13 = v5;
  else {
    int v14 = v5;
  }
  while (v14 != v13)
  {
    unsigned int v15 = *((unsigned __int16 *)this + 4);
    if ((v15 & 0x8000u) == 0) {
      unsigned int v16 = v15 >> 5;
    }
    else {
      unsigned int v16 = *((_DWORD *)this + 3);
    }
    if (v16 <= v13)
    {
      UChar32 v18 = 0xFFFF;
    }

    else
    {
      if ((v15 & 2) != 0) {
        int v17 = (char *)this + 10;
      }
      else {
        int v17 = (char *)*((void *)this + 3);
      }
      UChar32 v18 = *(unsigned __int16 *)&v17[2 * v13];
    }

    int32_t v19 = u_digit(v18, v10);
    if (v19 < 0) {
      goto LABEL_32;
    }
    ++v11;
    ++v13;
    BOOL v20 = v19 + (int)v12 * v10 <= (int)v12;
    uint64_t v12 = (v19 + v12 * v10);
    if (v20) {
      return 0LL;
    }
  }

  LODWORD(v13) = v14;
LABEL_32:
  if (v11) {
    *(_DWORD *)a2 = v13;
  }
  return v12;
}

uint64_t icu::ICU_Utility::parsePattern( icu::ICU_Utility *this, const icu::UnicodeString *a2, int *a3, uint64_t a4, const icu::UnicodeString *a5, int *a6)
{
  unint64_t v10 = 0LL;
  int v11 = 0;
  int v30 = (int)a2;
  uint64_t v12 = a4 + 10;
  uint64_t v13 = (char *)this + 10;
  while (1)
  {
    int v14 = *(__int16 *)(a4 + 8);
    if (v14 < 0) {
      break;
    }
    unint64_t v15 = (unint64_t)*(unsigned __int16 *)(a4 + 8) >> 5;
LABEL_7:
    if (v15 <= v10)
    {
      int v17 = 0xFFFF;
    }

    else
    {
      if ((v14 & 2) != 0) {
        uint64_t v16 = v12;
      }
      else {
        uint64_t v16 = *(void *)(a4 + 24);
      }
      int v17 = *(unsigned __int16 *)(v16 + 2 * v10);
      switch(v17)
      {
        case '~':
          goto LABEL_40;
        case '#':
          int v29 = v30;
          *((_DWORD *)a5 + v1sub_18086E18C((uint64_t)this, 1) = icu::ICU_Utility::parseInteger(this, (const icu::UnicodeString *)&v29, a3);
          if (v29 == v30) {
            return 0xFFFFFFFFLL;
          }
          ++v11;
          int v30 = v29;
          goto LABEL_41;
        case ' ':
          uint64_t v18 = v30;
          ++v30;
          unsigned int v19 = *((unsigned __int16 *)this + 4);
          unsigned int v20 = (v19 & 0x8000u) == 0 ? v19 >> 5 : *((_DWORD *)this + 3);
          if (v20 <= v18)
          {
            uint64_t v22 = 0xFFFFLL;
          }

          else
          {
            unsigned int v21 = (v19 & 2) != 0 ? v13 : (char *)*((void *)this + 3);
            uint64_t v22 = *(unsigned __int16 *)&v21[2 * v18];
          }

          if (!icu::PatternProps::isWhiteSpace((icu::PatternProps *)v22)) {
            return 0xFFFFFFFFLL;
          }
LABEL_40:
          int v30 = icu::ICU_Utility::skipWhitespace(this, (const icu::UnicodeString *)&v30, 0LL);
          goto LABEL_41;
      }
    }

    uint64_t v23 = v30;
    ++v30;
    unsigned int v24 = *((unsigned __int16 *)this + 4);
    unsigned int v25 = (v24 & 0x8000u) == 0 ? v24 >> 5 : *((_DWORD *)this + 3);
    if (v25 <= v23)
    {
      UChar32 v27 = 0xFFFF;
    }

    else
    {
      uint64_t v26 = (v24 & 2) != 0 ? v13 : (char *)*((void *)this + 3);
      UChar32 v27 = *(unsigned __int16 *)&v26[2 * v23];
    }

uint64_t icu::ICU_Utility::parseUnicodeIdentifier@<X0>( uint64_t this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a3;
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0LL;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = off_18971B688;
  *(_WORD *)(a3 + 8) = 2;
  int v6 = *(_DWORD *)a2;
  unsigned int v7 = *(unsigned __int16 *)(this + 8);
  int v8 = (__int16)v7;
  LODWORD(a3) = v7 >> 5;
  if (v8 >= 0) {
    a3 = a3;
  }
  else {
    a3 = *(unsigned int *)(this + 12);
  }
  if (v6 >= (int)a3)
  {
LABEL_19:
    *(_DWORD *)a2 = v6;
    return this;
  }

  uint64_t v9 = this;
  while (1)
  {
    UChar32 v10 = icu::UnicodeString::char32At((uint64_t *)a3, (icu::UnicodeString *)v9, v6);
    unsigned int v11 = v10;
    unsigned int v12 = *(unsigned __int16 *)(v5 + 8);
    int v13 = (__int16)v12;
    unsigned int v14 = v12 >> 5;
    if (v13 < 0) {
      unsigned int v14 = *(_DWORD *)(v5 + 12);
    }
    if (v14)
    {
      this = u_isIDPart(v10);
      if (!(_DWORD)this) {
        goto LABEL_19;
      }
      goto LABEL_12;
    }

    this = u_isIDStart(v10);
    if (!(_DWORD)this) {
      break;
    }
LABEL_12:
    this = icu::UnicodeString::append(v5, v11);
    if (v11 < 0x10000) {
      int v15 = 1;
    }
    else {
      int v15 = 2;
    }
    v6 += v15;
    unsigned int v16 = *(unsigned __int16 *)(v9 + 8);
    int v17 = (__int16)v16;
    LODWORD(a3) = v16 >> 5;
    if (v17 >= 0) {
      a3 = a3;
    }
    else {
      a3 = *(unsigned int *)(v9 + 12);
    }
  }

  unsigned int v18 = *(unsigned __int16 *)(v5 + 8);
  if ((v18 & 1) != 0) {
    return icu::UnicodeString::unBogus(v5);
  }
  if ((v18 & 0x8000u) == 0) {
    unsigned int v19 = v18 >> 5;
  }
  else {
    unsigned int v19 = *(_DWORD *)(v5 + 12);
  }
  if (v19) {
    *(_WORD *)(v5 + 8) &= 0x1Fu;
  }
  return this;
}

uint64_t icu::ICU_Utility::parseNumber(icu::ICU_Utility *this, const icu::UnicodeString *a2, int *a3)
{
  int v3 = (int)a3;
  uint64_t v6 = 0LL;
  for (int i = *(_DWORD *)a2; ; ++i)
  {
    unsigned int v8 = *((unsigned __int16 *)this + 4);
    int v9 = (__int16)v8;
    LODWORD(v10) = v8 >> 5;
    UChar32 v10 = v9 >= 0 ? (uint64_t *)v10 : (uint64_t *)*((unsigned int *)this + 3);
    UChar32 v11 = icu::UnicodeString::char32At(v10, this, i);
    int32_t v12 = u_digit(v11, v3);
    if (v12 < 0) {
      break;
    }
    uint64_t v6 = (v12 + v6 * v3);
    if ((v6 & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
  }

  if (*(_DWORD *)a2 == i) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)a2 = i;
  return v6;
}

uint64_t utrace_entry(uint64_t result)
{
  if (off_18C535178) {
    return off_18C535178(qword_18C535180, result);
  }
  return result;
}

uint64_t utrace_exit( uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (off_18C535188)
  {
    if (a2 <= 15)
    {
      if (!a2)
      {
        int v9 = "Returns.";
        return off_18C535188(qword_18C535180, result, v9, &a9);
      }

      if (a2 == 1)
      {
        int v9 = "Returns %d.";
        return off_18C535188(qword_18C535180, result, v9, &a9);
      }
    }

    else
    {
      switch(a2)
      {
        case 16:
          int v9 = "Returns.  Status = %d.";
          return off_18C535188(qword_18C535180, result, v9, &a9);
        case 17:
          int v9 = "Returns %d.  Status = %d.";
          return off_18C535188(qword_18C535180, result, v9, &a9);
        case 18:
          int v9 = "Returns %d.  Status = %p.";
          return off_18C535188(qword_18C535180, result, v9, &a9);
      }
    }

    abort();
  }

  return result;
}

uint64_t utrace_data( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (off_18C535190) {
    return off_18C535190(qword_18C535180, result, a2, a3, &a9);
  }
  return result;
}

uint64_t utrace_vformat(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = a4;
  uint64_t v9 = 0LL;
  int v10 = 0;
  unsigned int v64 = a5;
  int v63 = 0;
LABEL_2:
  uint64_t v11 = v10;
  int v12 = v10 + 3;
  int v13 = (unsigned __int8 *)(v5 + v10);
  uint64_t v14 = (v11 << 32) + 0x100000000LL;
  do
  {
    int v16 = *v13++;
    int v15 = v16;
    if (v16 == 37)
    {
      int v10 = v12 - 1;
      uint64_t v17 = v14 >> 32;
      uint64_t v5 = a4;
      int v18 = *(char *)(a4 + v17);
      if (v18 <= 97)
      {
        if (v18)
        {
          if (v18 == 83)
          {
            uint64_t v22 = v64++;
            uint64_t v23 = *v22;
            unsigned int v64 = v22 + 2;
            sub_180888060(v23, *((_DWORD *)v22 + 2), a1, &v63, a2, a3);
            goto LABEL_2;
          }

uint64_t sub_180887FB8(uint64_t result, uint64_t a2, int *a3, int a4, int a5)
{
  int v5 = *a3;
  if (*a3)
  {
    if (!(_DWORD)result) {
      goto LABEL_16;
    }
    if ((_DWORD)result == 10)
    {
      if (v5 >= a4)
      {
        BOOL v6 = a5 == 0;
        BOOL v7 = a5 < 0;
      }

      else
      {
        BOOL v6 = 1;
        BOOL v7 = 0;
      }

      if (v7 || v6) {
        goto LABEL_16;
      }
      goto LABEL_13;
    }

    if (v5 >= a4 || *(_BYTE *)(v5 + a2 - 1) != 10) {
      goto LABEL_16;
    }
  }

  if (a5 < 1) {
    goto LABEL_16;
  }
  do
  {
LABEL_13:
    if (v5 < a4)
    {
      *(_BYTE *)(a2 + v5) = 32;
      int v5 = *a3;
    }

    *a3 = ++v5;
    --a5;
  }

  while (a5);
LABEL_16:
  if (v5 < a4) {
    *(_BYTE *)(a2 + v5) = result;
  }
  if ((_DWORD)result) {
    ++*a3;
  }
  return result;
}

uint64_t sub_180888060(uint64_t result, int a2, uint64_t a3, int *a4, int a5, int a6)
{
  if (result)
  {
    uint64_t v11 = result;
    if (a2 == -1 || a2 >= 1)
    {
      for (uint64_t i = 0LL; a2 == -1 || (int)i < a2; ++i)
      {
        unint64_t v13 = *(unsigned __int16 *)(v11 + 2 * i);
        for (uint64_t j = 12LL; j != -4; j -= 4LL)
          sub_180887FB8(a0123456789abcd_0[(v13 >> j) & 0xF], a3, a4, a5, 0);
        BOOL result = sub_180887FB8(32LL, a3, a4, a5, a6);
        if (a2 == -1 && !(_DWORD)v13) {
          break;
        }
      }
    }
  }

  else
  {
    uint64_t v15 = 0LL;
    do
    {
      uint64_t v16 = v15 + 1;
      BOOL result = sub_180887FB8(aNull_0[v15], a3, a4, a5, a6);
      uint64_t v15 = v16;
    }

    while (v16 != 7);
  }

  return result;
}

uint64_t sub_180888174(uint64_t result, int a2, uint64_t a3, int *a4, int a5)
{
  int v5 = 4 * a2 - 4;
  if (v5 >= 0)
  {
    uint64_t v9 = result;
    do
    {
      BOOL result = sub_180887FB8(a0123456789abcd_0[(v9 >> v5) & 0xF], a3, a4, a5, 0);
      v5 -= 4;
    }

    while (v5 != -4);
  }

  return result;
}

uint64_t sub_1808881EC(uint64_t a1, uint64_t a2, int *a3, int a4)
{
  int v7 = 0;
  HIWORD(v12) = HIWORD(a1);
  unsigned int v8 = (char *)&v12 + 7;
  do
  {
    uint64_t v9 = *v8;
    for (uint64_t i = 4LL; i != -4; i -= 4LL)
      uint64_t result = sub_180887FB8(a0123456789abcd_0[(v9 >> i) & 0xF], a2, a3, a4, 0);
    --v8;
    ++v7;
  }

  while (v7 != 8);
  return result;
}

uint64_t utrace_format( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return utrace_vformat(a1, a2, a3, a4, &a9);
}

uint64_t utrace_setFunctions( uint64_t result, uint64_t (*a2)(void, void), void *a3, uint64_t (*a4)(void, void, void, void, void))
{
  off_18C535178 = a2;
  off_18C535188 = a3;
  off_18C535190 = a4;
  qword_18C535180 = result;
  return result;
}

void *utrace_getFunctions(void *result, void *a2, void *a3, void *a4)
{
  *a2 = off_18C535178;
  *a3 = off_18C535188;
  *a4 = off_18C535190;
  *uint64_t result = qword_18C535180;
  return result;
}

uint64_t utrace_setLevel(uint64_t result)
{
  else {
    int v1 = result;
  }
  if (v1 >= 9) {
    int v1 = 9;
  }
  dword_18C535198 = v1;
  return result;
}

uint64_t utrace_getLevel()
{
  return dword_18C535198;
}

uint64_t sub_180888338()
{
  off_18C535178 = 0LL;
  off_18C535188 = 0LL;
  off_18C535190 = 0LL;
  dword_18C535198 = -1;
  qword_18C535180 = 0LL;
  return 1LL;
}

const char *utrace_functionName(unsigned int a1)
{
  if (a1 <= 1)
  {
    int v1 = &off_18971C728[a1];
    return *v1;
  }

  if ((a1 & 0xFFFFFFF8) == 0x1000)
  {
    unsigned int v2 = a1 - 4096;
    int v3 = off_18971C740;
LABEL_9:
    int v1 = &v3[v2];
    return *v1;
  }

  unsigned int v2 = a1 - 0x2000;
  if (a1 - 0x2000 <= 8)
  {
    int v3 = off_18971C788;
    goto LABEL_9;
  }

  if ((a1 & 0xFFFFFFFC) == 0x3000)
  {
    unsigned int v2 = a1 - 12288;
    int v3 = off_18971C7D8;
    goto LABEL_9;
  }

  return "[BOGUS Trace Function Number]";
}

char **utrie_open(char **a1, char *a2, int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v12 = a1;
  if (a1 || (uint64_t v12 = (char **)uprv_malloc(0x44120uLL)) != 0LL)
  {
    uint64_t v14 = v12 + 17424;
    bzero(v12, 0x44120uLL);
    *((_BYTE *)v12 + 139416) = a1 == 0LL;
    if (a2)
    {
      char v15 = 0;
      *uint64_t v14 = a2;
    }

    else
    {
      uint64_t v16 = (char *)uprv_malloc(4 * a3);
      *uint64_t v14 = v16;
      if (!v16)
      {
        uprv_free(v12);
        return 0LL;
      }

      a2 = v16;
      char v15 = 1;
    }

    *((_BYTE *)v12 + 139417) = v15;
    if (a6)
    {
      *(_OWORD *)uint64_t v12 = xmmword_180A2CB60;
      *((_OWORD *)v12 + sub_18086E18C((uint64_t)this, 1) = xmmword_180A2CB70;
      unsigned int v17 = 288;
    }

    else
    {
      unsigned int v17 = 32;
    }

    *((_DWORD *)v12 + 34853) = v17;
    int32x4_t v18 = vdupq_n_s32(a4);
    uint64_t v19 = 4LL * v17;
    do
    {
      *(int32x4_t *)&a2[v19 - 16] = v18;
      v19 -= 16LL;
    }

    while (v19);
    *((_DWORD *)v12 + 34850) = a5;
    *((_DWORD *)v12 + 3485sub_18086E18C((uint64_t)this, 1) = 34816;
    *((_DWORD *)v12 + 34852) = a3;
    *((_BYTE *)v12 + 139418) = a6;
    *((_BYTE *)v12 + 139419) = 0;
  }

  return v12;
}

char **utrie_clone(char **a1, uint64_t a2, char *a3, int a4)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v5 = a2 + 139392;
  BOOL v6 = *(unsigned int **)(a2 + 139392);
  if (!v6 || *(_BYTE *)(a2 + 139419)) {
    return 0LL;
  }
  uint64_t v9 = a3;
  int v11 = *(_DWORD *)(a2 + 139408);
  if (a3 && v11 <= a4)
  {
    char v12 = 0;
  }

  else
  {
    unint64_t v13 = (char *)uprv_malloc(4LL * v11);
    if (!v13) {
      return 0LL;
    }
    uint64_t v9 = v13;
    BOOL v6 = *(unsigned int **)v5;
    char v12 = 1;
    a4 = v11;
  }

  uint64_t v14 = utrie_open(a1, v9, a4, *v6, *(_DWORD *)(v5 + 8), *(char *)(v5 + 26));
  int v7 = v14;
  if (v14)
  {
    char v15 = (void **)(v14 + 17424);
    memcpy(v14, (const void *)a2, 0x22080uLL);
    memcpy(*v15, *(const void **)v5, 4LL * *(int *)(v5 + 20));
    *((_DWORD *)v7 + 34853) = *(_DWORD *)(v5 + 20);
    *((_BYTE *)v7 + 139417) = v12;
  }

  else
  {
    uprv_free(v9);
  }

  return v7;
}

void utrie_close(void **a1)
{
  if (a1)
  {
    unsigned int v2 = a1 + 17424;
    if (*((_BYTE *)a1 + 139417))
    {
      uprv_free(*v2);
      *unsigned int v2 = 0LL;
    }

    if (*((_BYTE *)v2 + 24)) {
      uprv_free(a1);
    }
  }

uint64_t utrie_getData(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 0LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = (_DWORD *)(a1 + 139392);
      *a2 = v4[5];
      return *(void *)v4;
    }
  }

  return result;
}

uint64_t utrie_set32(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0LL;
  if (a1)
  {
    if (HIWORD(a2) <= 0x10u)
    {
      uint64_t v4 = (void *)(a1 + 139392);
      if (!*(_BYTE *)(a1 + 139419))
      {
        uint64_t v5 = a2 >> 5;
        int v6 = *(_DWORD *)(a1 + 4LL * v5);
        LODWORD(v7) = v6;
        if (v6 <= 0)
        {
          uint64_t v7 = *(unsigned int *)(a1 + 139412);
          *(_DWORD *)(a1 + 139412) = v7 + 32;
          if ((v7 & 0x80000000) != 0) {
            return 0LL;
          }
          *(_DWORD *)(a1 + 4 * v5) = v7;
          unsigned int v8 = (__int128 *)(*v4 - 4LL * v6);
          __int128 v9 = *v8;
          __int128 v11 = v8[2];
          __int128 v10 = v8[3];
          char v12 = (_OWORD *)(*v4 + 4 * v7);
          v12[1] = v8[1];
          _OWORD v12[2] = v11;
          *char v12 = v9;
          __int128 v13 = v8[4];
          __int128 v14 = v8[5];
          __int128 v15 = v8[7];
          v12[6] = v8[6];
          v12[7] = v15;
          _OWORD v12[4] = v13;
          v12[5] = v14;
          void v12[3] = v10;
        }

        *(_DWORD *)(*v4 + 4LL * (v7 + (a2 & 0x1F))) = a3;
        return 1LL;
      }
    }
  }

  return v3;
}

uint64_t utrie_get32(uint64_t a1, unsigned int a2, BOOL *a3)
{
  if (!a1 || HIWORD(a2) > 0x10u || *(_BYTE *)(a1 + 139419))
  {
    uint64_t result = 0LL;
    if (a3) {
      *a3 = 1;
    }
  }

  else
  {
    int v3 = *(_DWORD *)(a1 + 4LL * (a2 >> 5));
    if (a3) {
      *a3 = v3 == 0;
    }
    if (v3 < 0) {
      int v3 = -v3;
    }
    return *(unsigned int *)(*(void *)(a1 + 139392) + 4LL * (v3 + (a2 & 0x1F)));
  }

  return result;
}

uint64_t utrie_setRange32(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v5 = 0LL;
  if (!a1) {
    return v5;
  }
  if (a3 > 0x110000) {
    return v5;
  }
  if (WORD1(a2) > 0x10u) {
    return v5;
  }
  int v6 = (unsigned int **)(a1 + 139392);
  if (*(_BYTE *)(a1 + 139419)) {
    return v5;
  }
  if ((_DWORD)a2 == a3) {
    return 1LL;
  }
  unsigned int v8 = *v6;
  unsigned int v9 = **v6;
  uint64_t v10 = a2 & 0x1F;
  if ((a2 & 0x1F) == 0) {
    goto LABEL_26;
  }
  uint64_t v11 = a2 >> 5;
  int v12 = *(_DWORD *)(a1 + 4LL * v11);
  LODWORD(v13) = v12;
  if (v12 <= 0)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 139412);
    *(_DWORD *)(a1 + 139412) = v13 + 32;
    if ((v13 & 0x80000000) != 0) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 4 * v1sub_18086E18C((uint64_t)this, 1) = v13;
    int32x4_t v18 = &v8[-v12];
    __int128 v19 = *(_OWORD *)v18;
    __int128 v20 = *((_OWORD *)v18 + 1);
    __int128 v21 = *((_OWORD *)v18 + 3);
    uint64_t v22 = &v8[v13];
    *((_OWORD *)v22 + 2) = *((_OWORD *)v18 + 2);
    *((_OWORD *)v22 + 3) = v21;
    *(_OWORD *)uint64_t v22 = v19;
    *((_OWORD *)v22 + sub_18086E18C((uint64_t)this, 1) = v20;
    __int128 v23 = *((_OWORD *)v18 + 4);
    __int128 v24 = *((_OWORD *)v18 + 5);
    __int128 v25 = *((_OWORD *)v18 + 7);
    *((_OWORD *)v22 + 6) = *((_OWORD *)v18 + 6);
    *((_OWORD *)v22 + 7) = v25;
    *((_OWORD *)v22 + 4) = v23;
    *((_OWORD *)v22 + 5) = v24;
  }

  LODWORD(a2) = (a2 & 0xFFFFFFE0) + 32;
  unsigned int v8 = *v6;
  uint64_t v14 = (uint64_t)&(*v6)[v13];
  if (a2 <= a3)
  {
    uint64_t v26 = 4 * v10;
    if (a5)
    {
      do
      {
        *(_DWORD *)(v14 + v26) = a4;
        v26 += 4LL;
      }

      while (v26 != 128);
    }

    else
    {
      do
      {
        if (*(_DWORD *)(v14 + v26) == v9) {
          *(_DWORD *)(v14 + v26) = a4;
        }
        v26 += 4LL;
      }

      while (v26 != 128);
    }

uint64_t utrie_serialize( uint64_t a1, _DWORD *a2, int a3, uint64_t (*a4)(uint64_t a1, unsigned int a2, uint64_t a3), int a5, int *a6)
{
  if (!a6 || *a6 > 0) {
    return 0LL;
  }
  uint64_t v9 = a1;
  if (!a1 || a3 < 0 || !a2 && a3)
  {
    uint64_t v7 = 0LL;
    *a6 = 1;
    return v7;
  }

  uint64_t v13 = a1 + 139392;
  if (!*(_BYTE *)(a1 + 139419))
  {
    __int128 v25 = sub_180888F48;
    if (a4) {
      __int128 v25 = a4;
    }
    uint64_t v49 = v25;
    sub_180888FC0(a1, 0, a6);
    unsigned int v26 = 0;
    __int128 v54 = *(_OWORD *)(v9 + 6976);
    __int128 v55 = *(_OWORD *)(v9 + 6992);
    __int128 v56 = *(_OWORD *)(v9 + 7008);
    __int128 v57 = *(_OWORD *)(v9 + 7024);
    __int128 v50 = *(_OWORD *)(v9 + 6912);
    __int128 v51 = *(_OWORD *)(v9 + 6928);
    __int128 v52 = *(_OWORD *)(v9 + 6944);
    __int128 v53 = *(_OWORD *)(v9 + 6960);
    unsigned int v27 = *(_DWORD *)(v9 + 139400);
    int32x4_t v28 = *(int **)v13;
    if (v27 != **(_DWORD **)v13)
    {
      uint64_t v29 = *(unsigned int *)(v9 + 139412);
      if ((int)v29 + 32 > *(_DWORD *)(v9 + 139408) || (*(_DWORD *)(v9 + 139412) = v29 + 32, (v29 & 0x80000000) != 0))
      {
        *a6 = 7;
        goto LABEL_74;
      }

      uint64_t v30 = 0LL;
      uint64_t v31 = &v28[v29];
      int32x4_t v32 = vdupq_n_s32(v27);
      do
      {
        *(int32x4_t *)&v31[v30] = v32;
        v30 += 4LL;
      }

      while (v30 != 32);
      unsigned int v26 = -(int)v29;
    }

    int32x4_t v33 = vdupq_n_s32(v26);
    uint64_t v34 = -128LL;
    do
    {
      *(int32x4_t *)(v9 + v34 + 7040) = v33;
      v34 += 16LL;
    }

    while (v34);
    signed int v35 = 0x10000;
    int v36 = 2048;
    do
    {
      if (*(_DWORD *)(v9 + 4LL * (v35 >> 5)))
      {
        int v37 = (int)(v35 & 0xFFFFFC00) >> 5;
        LODWORD(i) = v36;
        if (v36 >= 2049)
        {
          uint64_t v39 = v9 + 0x2000;
          for (unint64_t i = 2048LL; i < v36; i += 32LL)
          {
            uint64_t v40 = 0LL;
            while (*(_DWORD *)(v39 + v40) == *(_DWORD *)(v9 + 4LL * v37 + v40))
            {
              v40 += 4LL;
              if (v40 == 128) {
                goto LABEL_52;
              }
            }

            v39 += 128LL;
          }

          LODWORD(i) = v36;
        }

uint64_t sub_180888F48(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v3 = a2 + 1024;
  do
  {
    if (!a1)
    {
LABEL_10:
      int v4 = 32;
      goto LABEL_11;
    }

    int v4 = 32;
    if (HIWORD(a2) <= 0x10u && !*(_BYTE *)(a1 + 139419))
    {
      int v5 = *(_DWORD *)(a1 + 4LL * (a2 >> 5));
      if (!v5) {
        goto LABEL_10;
      }
      if (v5 < 0) {
        int v5 = -v5;
      }
      if (*(_DWORD *)(*(void *)(a1 + 139392) + 4LL * (v5 + (a2 & 0x1F))) != **(_DWORD **)(a1 + 139392)) {
        return a3;
      }
      int v4 = 1;
    }

uint64_t sub_180888FC0(uint64_t result, int a2, int *a3)
{
  if (*a3 > 0) {
    return result;
  }
  int v3 = (int *)result;
  uint64_t v4 = result + 139392;
  if (*(_BYTE *)(result + 139419)) {
    return result;
  }
  uint64_t result = (uint64_t)memset((void *)(result + 139420), 255, 0x22084uLL);
  uint64_t v6 = *(unsigned int *)(v4 + 12);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = v3;
    do
    {
      int v9 = *v7++;
      unsigned int v8 = v9;
      if (v9 < 0) {
        unsigned int v8 = -v8;
      }
      v3[(v8 >> 5) + 34855] = 0;
      --v6;
    }

    while (v6);
  }

  *(_DWORD *)(v4 + 28) = 0;
  int v10 = 32;
  if (*(_BYTE *)(v4 + 26)) {
    int v11 = 288;
  }
  else {
    int v11 = 32;
  }
  int v12 = *(_DWORD *)(v4 + 20);
  if (v12 < 33) {
    goto LABEL_49;
  }
  if (a2) {
    uint64_t v13 = 4LL;
  }
  else {
    uint64_t v13 = 32LL;
  }
  int v14 = 32;
  int v10 = 32;
  do
  {
    uint64_t v15 = 4LL * v14;
    while (1)
    {
      int v16 = &v3[(v14 >> 5) + 34855];
      if ((*v16 & 0x80000000) == 0) {
        break;
      }
LABEL_29:
      v14 += 32;
      v15 += 128LL;
      if (v14 >= v12) {
        goto LABEL_49;
      }
    }

    if (v14 < v11) {
      goto LABEL_38;
    }
    uint64_t v17 = *(void *)v4;
    if (v10 >= 32)
    {
      uint64_t result = 0LL;
LABEL_21:
      int32x4_t v18 = (_DWORD *)(v17 + 4 * result);
      unsigned int v19 = 33;
      unsigned int v20 = (_DWORD *)(*(void *)v4 + 4LL * v14);
      do
      {
        if (*v18 != *v20)
        {
          result += v13;
          goto LABEL_31;
        }

        ++v18;
        ++v20;
        --v19;
      }

      while (v19 > 1);
      if ((result & 0x80000000) != 0) {
        goto LABEL_31;
      }
      *int v16 = result;
      int v12 = *(_DWORD *)(v4 + 20);
      goto LABEL_29;
    }

uint64_t utrie_unserialize(uint64_t a1, _DWORD *a2, int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if (a3 > 15 && *a2 == 1416784229)
    {
      int v4 = a2[1];
      if (v4 == 37)
      {
        *(_BYTE *)(a1 + 36) = (v4 & 0x200) != 0;
        int v5 = a2[3];
        uint64_t v6 = (int)a2[2];
        *(_DWORD *)(a1 + 24) = v6;
        *(_DWORD *)(a1 + 28) = v5;
        if (a3 - 16 >= 2 * (int)v6)
        {
          *(void *)a1 = a2 + 4;
          uint64_t v7 = (_DWORD *)((char *)a2 + 2 * v6 + 16);
          int v8 = a3 - 16 - 2 * v6;
          if ((v4 & 0x100) != 0)
          {
            if (v8 >= 4 * v5)
            {
              *(void *)(a1 + 8) = v7;
              *(_DWORD *)(a1 + 32) = *v7;
              int v9 = 2 * v6 + 4 * v5;
              goto LABEL_15;
            }
          }

          else if (v8 >= 2 * v5)
          {
            *(void *)(a1 + 8) = 0LL;
            *(_DWORD *)(a1 + 32) = *(unsigned __int16 *)v7;
            int v9 = 2 * (v5 + v6);
LABEL_15:
            uint64_t v10 = (v9 + 16);
            *(void *)(a1 + 16) = utrie_defaultGetFoldingOffset;
            return v10;
          }
        }
      }
    }

    *a4 = 3;
  }

  return 0xFFFFFFFFLL;
}

uint64_t utrie_unserializeDummy( uint64_t a1, char *__b, int a3, unsigned int a4, unsigned int a5, int a6, int *a7)
{
  if (a7 && *a7 <= 0)
  {
    if (a5 == a4) {
      int v13 = 256;
    }
    else {
      int v13 = 288;
    }
    *(_DWORD *)(a1 + 24) = 2080;
    *(_DWORD *)(a1 + 28) = v13;
    if (a6)
    {
      uint64_t v7 = (2 * v13 + 4160);
      if ((int)v7 <= a3)
      {
        *(_BYTE *)(a1 + 36) = 1;
        *(_DWORD *)(a1 + 32) = a4;
        *(void *)a1 = __b;
        memset_pattern16(__b, &unk_180A2CB80, 0x1040uLL);
        if (a5 != a4) {
          memset_pattern16(__b + 3456, &unk_180A2CB90, 0x40uLL);
        }
        uint64_t v14 = 0LL;
        *(void *)(a1 + 8) = 0LL;
        int16x8_t v15 = vdupq_n_s16(a4);
        do
        {
          *(int16x8_t *)&__b[v14 + 4160] = v15;
          v14 += 16LL;
        }

        while (v14 != 512);
        if (a5 != a4)
        {
          uint64_t v16 = 0LL;
          int16x8_t v17 = vdupq_n_s16(a5);
          do
          {
            *(int16x8_t *)&__b[v16 + 4672] = v17;
            v16 += 16LL;
          }

          while (v16 != 64);
        }

uint64_t utrie_enum( uint64_t result, uint64_t (*a2)(uint64_t a1, uint64_t a2), uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v47 = result;
  if (result)
  {
    uint64_t result = (uint64_t)a3;
    if (a3)
    {
      uint64_t v49 = *(void *)v47;
      if (*(void *)v47)
      {
        int v5 = sub_180889A24;
        if (a2) {
          int v5 = a2;
        }
        uint64_t v6 = *(void *)(v47 + 8);
        __int128 v57 = v5;
        unsigned int v50 = v5(a4, *(unsigned int *)(v47 + 32));
        if (v6) {
          int v7 = 0;
        }
        else {
          int v7 = *(_DWORD *)(v47 + 24);
        }
        uint64_t v8 = v49;
        int v9 = 0;
        uint64_t v10 = 0LL;
        LODWORD(v1sub_18086E18C((uint64_t)this, 1) = 0;
        int v12 = v7;
        uint64_t v13 = v50;
        uint64_t v56 = v6;
        int v48 = v7;
        do
        {
          if ((_DWORD)v11 == 56320) {
            int v9 = 1760;
          }
          if ((_DWORD)v11 == 55296) {
            int v14 = 2048;
          }
          else {
            int v14 = v9;
          }
          uint64_t v15 = *(unsigned __int16 *)(v8 + 2LL * v14);
          if (4 * (_DWORD)v15 == v12)
          {
            uint64_t v11 = (v11 + 32);
          }

          else
          {
            unsigned int v53 = v11;
            if (4 * (_DWORD)v15 == v7)
            {
              if ((_DWORD)v13 == v50)
              {
                uint64_t v16 = v10;
              }

              else
              {
                uint64_t v16 = v11;
                int v12 = v7;
                if ((int)v10 < (int)v11)
                {
                  uint64_t v16 = v11;
                  uint64_t result = a3(a4, v10, v11, v13);
                  int v12 = v48;
                  if (!(_DWORD)result) {
                    return result;
                  }
                }
              }

              uint64_t v11 = (v11 + 32);
              uint64_t v13 = v50;
              uint64_t v10 = v16;
              uint64_t v8 = v49;
              uint64_t v6 = v56;
              int v7 = v48;
            }

            else
            {
              int v51 = v14;
              uint64_t v17 = 0LL;
              uint64_t v18 = v6 + 16 * v15;
              uint64_t v19 = v8 + 8 * v15;
              int v12 = 4 * v15;
              int v20 = v11;
              do
              {
                if (v6) {
                  uint64_t v21 = *(unsigned int *)(v18 + 4 * v17);
                }
                else {
                  uint64_t v21 = *(unsigned __int16 *)(v19 + 2 * v17);
                }
                uint64_t v22 = v57(a4, v21);
                if ((_DWORD)v22 != (_DWORD)v13)
                {
                  uint64_t v23 = v22;
                  if ((int)v10 < v20 + (int)v17)
                  {
                    uint64_t result = a3(a4, v10, v53 + v17, v13);
                    if (!(_DWORD)result) {
                      return result;
                    }
                  }

                  if (v17) {
                    int v12 = -1;
                  }
                  uint64_t v13 = v23;
                  uint64_t v10 = v53 + v17;
                  uint64_t v6 = v56;
                }

                ++v17;
              }

              while (v17 != 32);
              uint64_t v11 = v53 + 32;
              uint64_t v8 = v49;
              int v7 = v48;
              int v14 = v51;
            }
          }

          int v9 = v14 + 1;
        }

        while ((int)v11 < 0x10000);
        int v24 = 55296;
        do
        {
          int v25 = 4 * *(unsigned __int16 *)(v8 + 2LL * (v24 >> 5));
          if (v25 == v7)
          {
            int v26 = v24;
            if ((_DWORD)v13 == v50)
            {
              int v27 = v11;
              uint64_t v28 = v10;
            }

            else
            {
              uint64_t v28 = v11;
              int v12 = v7;
              int v27 = v11;
              if ((int)v10 < (int)v11)
              {
                uint64_t v28 = v11;
                uint64_t result = a3(a4, v10, v11, v13);
                int v12 = v48;
                if (!(_DWORD)result) {
                  return result;
                }
              }
            }

            int v24 = v26 + 32;
            uint64_t v11 = (v27 + 0x8000);
            uint64_t v13 = v50;
            uint64_t v10 = v28;
            uint64_t v8 = v49;
            uint64_t v6 = v56;
            int v7 = v48;
          }

          else
          {
            uint64_t v29 = v25 + (v24 & 0x1Fu);
            if (v6) {
              uint64_t v30 = *(unsigned int *)(v6 + 4 * v29);
            }
            else {
              uint64_t v30 = *(unsigned __int16 *)(v8 + 2 * v29);
            }
            int v45 = v24;
            int v31 = (*(uint64_t (**)(uint64_t))(v47 + 16))(v30);
            if (v31 >= 1)
            {
              int v32 = v31 + 31;
              uint64_t v33 = v31;
              if (__OFSUB__(v31, v31 + 31)) {
                int v32 = v31;
              }
              int v34 = v32 + 1;
              int v46 = v32 + 1;
              while (1)
              {
                uint64_t v35 = *(unsigned __int16 *)(v8 + 2 * v33);
                if (4 * (_DWORD)v35 == v12)
                {
                  uint64_t v11 = (v11 + 32);
                }

                else
                {
                  unsigned int v54 = v11;
                  if (4 * (_DWORD)v35 == v7)
                  {
                    if ((_DWORD)v13 == v50)
                    {
                      uint64_t v36 = v10;
                    }

                    else
                    {
                      uint64_t v36 = v11;
                      int v12 = v7;
                      if ((int)v10 < (int)v11)
                      {
                        uint64_t v36 = v11;
                        uint64_t result = a3(a4, v10, v11, v13);
                        int v12 = v48;
                        if (!(_DWORD)result) {
                          return result;
                        }
                      }
                    }

                    uint64_t v11 = (v11 + 32);
                    uint64_t v13 = v50;
                    uint64_t v10 = v36;
                    uint64_t v8 = v49;
                    uint64_t v6 = v56;
                  }

                  else
                  {
                    uint64_t v37 = 0LL;
                    uint64_t v38 = v6 + 16 * v35;
                    uint64_t v52 = v8 + 8 * v35;
                    int v12 = 4 * v35;
                    int v39 = v11;
                    do
                    {
                      if (v6) {
                        uint64_t v40 = *(unsigned int *)(v38 + 4 * v37);
                      }
                      else {
                        uint64_t v40 = *(unsigned __int16 *)(v52 + 2 * v37);
                      }
                      uint64_t v41 = v57(a4, v40);
                      if ((_DWORD)v41 != (_DWORD)v13)
                      {
                        uint64_t v42 = v41;
                        if ((int)v10 < v39 + (int)v37)
                        {
                          uint64_t result = a3(a4, v10, v54 + v37, v13);
                          if (!(_DWORD)result) {
                            return result;
                          }
                        }

                        if (v37) {
                          int v12 = -1;
                        }
                        uint64_t v13 = v42;
                        uint64_t v10 = v54 + v37;
                        uint64_t v6 = v56;
                      }

                      ++v37;
                    }

                    while (v37 != 32);
                    uint64_t v11 = v54 + 32;
                    uint64_t v8 = v49;
                  }

                  int v7 = v48;
                  int v34 = v46;
                }

                if (v34 == (_DWORD)++v33) {
                  goto LABEL_78;
                }
              }
            }

            if ((_DWORD)v13 == v50)
            {
              int v43 = v11;
              uint64_t v44 = v10;
            }

            else
            {
              uint64_t v44 = v11;
              int v12 = v7;
              int v43 = v11;
              if ((int)v10 < (int)v11)
              {
                uint64_t v44 = v11;
                uint64_t result = a3(a4, v10, v11, v13);
                int v12 = v48;
                if (!(_DWORD)result) {
                  return result;
                }
              }
            }

            uint64_t v11 = (v43 + 1024);
            uint64_t v13 = v50;
            uint64_t v10 = v44;
            uint64_t v8 = v49;
            uint64_t v6 = v56;
            int v7 = v48;
LABEL_78:
            int v24 = v45 + 1;
          }
        }

        while (v24 < 56320);
        return a3(a4, v10, v11, v13);
      }
    }
  }

  return result;
}

uint64_t sub_180889A24(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t utrie2_get32(uint64_t *a1, unsigned int a2)
{
  if (a1[1])
  {
    uint64_t v2 = *a1;
    if (a2 >> 11 > 0x1A)
    {
      if (HIWORD(a2))
      {
        if (a2 >= 0x110000)
        {
          int v8 = *((_DWORD *)a1 + 6) + 128;
          return *(unsigned __int16 *)(v2 + 2LL * v8);
        }

        if (*((_DWORD *)a1 + 11) <= (signed int)a2)
        {
          int v8 = *((_DWORD *)a1 + 12);
          return *(unsigned __int16 *)(v2 + 2LL * v8);
        }

        unsigned int v3 = ((a2 >> 5) & 0x3F) + *(unsigned __int16 *)(v2 + 2LL * ((a2 >> 11) + 2080));
      }

      else
      {
        if (a2 >> 10 >= 0x37) {
          int v7 = 0;
        }
        else {
          int v7 = 320;
        }
        unsigned int v3 = v7 + (a2 >> 5);
      }
    }

    else
    {
      unsigned int v3 = a2 >> 5;
    }

    int v8 = (a2 & 0x1F) + 4 * *(unsigned __int16 *)(v2 + 2LL * v3);
    return *(unsigned __int16 *)(v2 + 2LL * v8);
  }

  uint64_t v4 = a1[2];
  if (v4)
  {
    if (a2 >> 11 > 0x1A)
    {
      if (HIWORD(a2))
      {
        if (HIWORD(a2) > 0x10u)
        {
          int v12 = 128;
          return *(unsigned int *)(v4 + 4LL * v12);
        }

        if (*((_DWORD *)a1 + 11) <= (signed int)a2)
        {
          int v12 = *((_DWORD *)a1 + 12);
          return *(unsigned int *)(v4 + 4LL * v12);
        }

        int v11 = *(unsigned __int16 *)(*a1
                                  + 2LL * (((a2 >> 5) & 0x3F) + *(unsigned __int16 *)(*a1 + 2LL * ((a2 >> 11) + 2080))));
LABEL_24:
        int v12 = (a2 & 0x1F) + 4 * v11;
        return *(unsigned int *)(v4 + 4LL * v12);
      }

      uint64_t v5 = *a1;
      if (a2 >> 10 >= 0x37) {
        int v10 = 0;
      }
      else {
        int v10 = 320;
      }
      unsigned int v6 = v10 + (a2 >> 5);
    }

    else
    {
      uint64_t v5 = *a1;
      unsigned int v6 = a2 >> 5;
    }

    int v11 = *(unsigned __int16 *)(v5 + 2LL * v6);
    goto LABEL_24;
  }

  if (a2 < 0x110000) {
    return sub_180889B68(a1[9], a2, 1);
  }
  else {
    return *((unsigned int *)a1 + 10);
  }
}

uint64_t sub_180889B68(uint64_t a1, int a2, int a3)
{
  unsigned int v3 = a2 & 0xFFFFFC00;
  if (*(_DWORD *)(a1 + 144168) <= a2)
  {
    if (v3 != 55296 || a3)
    {
      int v5 = *(_DWORD *)(a1 + 144152) - 4;
      return *(unsigned int *)(*(void *)(a1 + 144128) + 4LL * v5);
    }

    goto LABEL_7;
  }

  if (v3 != 55296 || !a3)
  {
LABEL_7:
    int v4 = *(_DWORD *)(a1 + 4LL * (a2 >> 11)) + ((a2 >> 5) & 0x3F);
    goto LABEL_8;
  }

  int v4 = (a2 >> 5) + 320;
LABEL_8:
  int v5 = *(_DWORD *)(a1 + 4LL * v4 + 2176) + (a2 & 0x1F);
  return *(unsigned int *)(*(void *)(a1 + 144128) + 4LL * v5);
}

uint64_t utrie2_get32FromLeadSurrogateCodeUnit(uint64_t a1, unsigned int a2)
{
  if (a2 >> 10 != 54) {
    return *(unsigned int *)(a1 + 40);
  }
  if (*(void *)(a1 + 8)) {
    return *(unsigned __int16 *)(*(void *)a1
  }
                               + 2LL * ((a2 & 0x1F) + 4 * *(unsigned __int16 *)(*(void *)a1 + 2LL * (a2 >> 5))));
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    return *(unsigned int *)(v3 + 4LL * ((a2 & 0x1F) + 4 * *(unsigned __int16 *)(*(void *)a1 + 2LL * (a2 >> 5))));
  }
  else {
    return sub_180889B68(*(void *)(a1 + 72), a2, 0);
  }
}

uint64_t utrie2_internalU8NextIndex(uint64_t *a1, UChar32 c, uint8_t *s, uint64_t a4)
{
  punint64_t i = 0;
  else {
    int32_t v6 = a4 - (_DWORD)s;
  }
  unsigned int v7 = utf8_nextCharSafeBody(s, &pi, v6, c, -1);
  if (v7 >> 11 <= 0x1A)
  {
    uint64_t v8 = *a1;
    unsigned int v9 = v7 >> 5;
LABEL_11:
    int v11 = *(unsigned __int16 *)(v8 + 2LL * v9);
LABEL_12:
    int v12 = (v7 & 0x1F) + 4 * v11;
    return pi | (8 * v12);
  }

  if (!HIWORD(v7))
  {
    uint64_t v8 = *a1;
    if (v7 >> 10 >= 0x37) {
      int v10 = 0;
    }
    else {
      int v10 = 320;
    }
    unsigned int v9 = v10 + (v7 >> 5);
    goto LABEL_11;
  }

  if (v7 < 0x110000)
  {
    if (*((_DWORD *)a1 + 11) <= (signed int)v7)
    {
      int v12 = *((_DWORD *)a1 + 12);
      return pi | (8 * v12);
    }

    int v11 = *(unsigned __int16 *)(*a1 + 2LL
                                    * (((v7 >> 5) & 0x3F) + *(unsigned __int16 *)(*a1 + 2LL * ((v7 >> 11) + 2080))));
    goto LABEL_12;
  }

  if (a1[2]) {
    int v12 = 128;
  }
  else {
    int v12 = *((_DWORD *)a1 + 6) + 128;
  }
  return pi | (8 * v12);
}

uint64_t utrie2_internalU8PrevIndex(uint64_t *a1, UChar32 c, const uint8_t *a3, uint64_t a4)
{
  else {
    int32_t v5 = a4 - (_DWORD)a3;
  }
  else {
    int32_t v6 = a3;
  }
  punint64_t i = v5;
  unsigned int v7 = utf8_prevCharSafeBody(v6, 0, &pi, c, -1);
  if (v7 >> 11 <= 0x1A)
  {
    uint64_t v8 = *a1;
    unsigned int v9 = v7 >> 5;
LABEL_14:
    int v11 = *(unsigned __int16 *)(v8 + 2LL * v9);
LABEL_15:
    int v12 = (v7 & 0x1F) + 4 * v11;
    return (v5 - pi) | (8 * v12);
  }

  if (!HIWORD(v7))
  {
    uint64_t v8 = *a1;
    if (v7 >> 10 >= 0x37) {
      int v10 = 0;
    }
    else {
      int v10 = 320;
    }
    unsigned int v9 = v10 + (v7 >> 5);
    goto LABEL_14;
  }

  if (v7 < 0x110000)
  {
    if (*((_DWORD *)a1 + 11) <= (signed int)v7)
    {
      int v12 = *((_DWORD *)a1 + 12);
      return (v5 - pi) | (8 * v12);
    }

    int v11 = *(unsigned __int16 *)(*a1 + 2LL
                                    * (((v7 >> 5) & 0x3F) + *(unsigned __int16 *)(*a1 + 2LL * ((v7 >> 11) + 2080))));
    goto LABEL_15;
  }

  if (a1[2]) {
    int v12 = 128;
  }
  else {
    int v12 = *((_DWORD *)a1 + 6) + 128;
  }
  return (v5 - pi) | (8 * v12);
}

void *utrie2_openFromSerialized(unsigned int a1, uint64_t a2, int a3, unsigned int *a4, int *a5)
{
  if (*a5 > 0) {
    return 0LL;
  }
  if (a3 < 1 || a1 > 1 || (a2 & 3) != 0)
  {
    uint64_t result = 0LL;
    int v12 = 1;
    goto LABEL_23;
  }

  unsigned int v9 = *(unsigned __int16 *)(a2 + 6);
  int v10 = *(unsigned __int16 *)(a2 + 8);
  if (a1) {
    int v11 = -4;
  }
  else {
    int v11 = v9 - 4;
  }
  int v12 = 3;
  if (a1) {
    char v13 = 4;
  }
  else {
    char v13 = 3;
  }
  unsigned int v14 = (v10 << v13) + 2 * v9 + 16;
  if (v14 > a3)
  {
    uint64_t result = 0LL;
LABEL_23:
    *a5 = v12;
    return result;
  }

  __int16 v20 = *(_WORD *)(a2 + 10);
  uint64_t v16 = *(unsigned __int16 *)(a2 + 12);
  int v17 = *(unsigned __int16 *)(a2 + 14);
  uint64_t result = uprv_malloc(0x50uLL);
  if (!result)
  {
    int v12 = 7;
    goto LABEL_23;
  }

  result[1] = 0LL;
  result[2] = 0LL;
  *((_DWORD *)result + 6) = v9;
  *((_DWORD *)result + 7) = 4 * v10;
  *((_WORD *)result + 16) = v20;
  *((_WORD *)result + 17) = v16;
  *(void *)((char *)result + 36) = 0LL;
  *((_DWORD *)result + 1sub_18086E18C((uint64_t)this, 1) = v17 << 11;
  *((_DWORD *)result + 12) = v11 + 4 * v10;
  *(void *)((char *)result + 52) = 0LL;
  *(void *)((char *)result + 60) = 0LL;
  *(void *)((char *)result + 68) = 0LL;
  *((_DWORD *)result + 19) = 0;
  result[7] = a2;
  *((_DWORD *)result + 16) = v14;
  uint64_t v18 = a2 + 16 + 2LL * v9;
  *uint64_t result = a2 + 16;
  if (a1 != 1)
  {
    if (!a1)
    {
      result[1] = v18;
      *((_DWORD *)result + 9) = *(unsigned __int16 *)(a2 + 16 + 2 * v16);
      int v19 = *(unsigned __int16 *)(v18 + 256);
      goto LABEL_27;
    }

void *utrie2_openDummy(unsigned int a1, unsigned int a2, unsigned int a3, int *a4)
{
  if (*a4 > 0) {
    return 0LL;
  }
  if (a1 >= 2) {
    goto LABEL_4;
  }
  if (a1) {
    size_t v10 = 5024LL;
  }
  else {
    size_t v10 = 4632LL;
  }
  int v11 = uprv_malloc(0x50uLL);
  int v4 = v11;
  if (!v11)
  {
LABEL_25:
    int v7 = 7;
    goto LABEL_26;
  }

  _OWORD v11[3] = 0u;
  v11[4] = 0u;
  v11[1] = 0u;
  _OWORD v11[2] = 0u;
  *int v11 = 0u;
  int v12 = (char *)uprv_malloc(v10);
  v4[7] = v12;
  if (!v12)
  {
    uprv_free(v4);
    int v4 = 0LL;
    goto LABEL_25;
  }

  *((_DWORD *)v4 + 16) = v10;
  *((_BYTE *)v4 + 68) = 1;
  if (a1) {
    unsigned int v13 = 0;
  }
  else {
    unsigned int v13 = 2112;
  }
  v4[3] = 0xC400000840LL;
  *((_WORD *)v4 + 16) = 0;
  *((_WORD *)v4 + 17) = v13;
  *((_DWORD *)v4 + 9) = a2;
  *((_DWORD *)v4 + 10) = a3;
  *((_DWORD *)v4 + 1sub_18086E18C((uint64_t)this, 1) = 0;
  *((_DWORD *)v4 + 12) = v13 + 192;
  *(_DWORD *)int v12 = 1416784178;
  *((_WORD *)v12 + 2) = a1;
  *(_DWORD *)(v12 + 6) = 3213376;
  *((_WORD *)v12 + 5) = 0;
  *((_WORD *)v12 + 6) = v13;
  *((_WORD *)v12 + 7) = 0;
  int16x8_t v14 = vdupq_n_s16(v13 >> 2);
  uint64_t v15 = -4160LL;
  *int v4 = v12 + 16;
  do
  {
    *(int16x8_t *)&v12[v15 + 4176] = v14;
    v15 += 16LL;
  }

  while (v15);
  uint64_t v16 = 0LL;
  *((_WORD *)v12 + 2088) = v13 | 0x80;
  *((_WORD *)v12 + 2089) = v13 | 0x80;
  do
  {
    *(_WORD *)&v12[v16 + 4180] = v13;
    v16 += 2LL;
  }

  while ((_DWORD)v16 != 60);
  int v17 = &v12[v16];
  uint64_t v18 = (uint64_t)&v12[v16 + 4180];
  if (a1 == 1)
  {
    uint64_t v25 = 0LL;
    int v26 = (int32x4_t *)(v17 + 4692);
    v4[1] = 0LL;
    void v4[2] = v18;
    int32x4_t v27 = vdupq_n_s32(a2);
    do
    {
      *(int32x4_t *)&v12[v25 + 4180 + v16] = v27;
      v25 += 16LL;
    }

    while (v25 != 512);
    uint64_t v28 = (uint64_t)&v12[v16 + 4564];
    int32x4_t v29 = vdupq_n_s32(a3);
    uint64_t v30 = 64LL;
    do
    {
      *v26++ = v29;
      v30 -= 4LL;
    }

    while (v30);
    *(int32x4_t *)(v28 + 384) = v27;
  }

  else
  {
    if (a1)
    {
LABEL_4:
      int v4 = 0LL;
      int v7 = 1;
LABEL_26:
      *a4 = v7;
      return v4;
    }

    uint64_t v19 = 0LL;
    __int16 v20 = (int16x8_t *)(v17 + 4436);
    v4[1] = v18;
    void v4[2] = 0LL;
    int16x8_t v21 = vdupq_n_s16(a2);
    do
    {
      *(int16x8_t *)&v12[v19 + 4180 + v16] = v21;
      v19 += 16LL;
    }

    while (v19 != 256);
    int16x8_t v22 = vdupq_n_s16(a3);
    uint64_t v23 = 64LL;
    do
    {
      *v20++ = v22;
      v23 -= 8LL;
    }

    while (v23);
    *(int16x4_t *)&v12[v16 + 4564] = vdup_n_s16(a2);
  }

  return v4;
}

void utrie2_close(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 68)) {
      uprv_free(*(void **)(a1 + 56));
    }
    uint64_t v2 = *(void *)(a1 + 72);
    if (v2)
    {
      uprv_free(*(void **)(v2 + 144128));
      uprv_free(*(void **)(a1 + 72));
    }

    uprv_free((void *)a1);
  }

BOOL utrie2_isFrozen(uint64_t a1)
{
  return *(void *)(a1 + 72) == 0LL;
}

uint64_t utrie2_serialize(uint64_t a1, void *__dst, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0LL;
  }
  if (!a1
    || !*(void *)(a1 + 56)
    || a3 < 0
    || *(void *)(a1 + 72)
    || a3 && (!__dst || (__dst & 3) != 0))
  {
    uint64_t result = 0LL;
    int v6 = 1;
    goto LABEL_13;
  }

  uint64_t result = *(unsigned int *)(a1 + 64);
  if ((int)result > a3)
  {
    int v6 = 15;
LABEL_13:
    *a4 = v6;
    return result;
  }

  memcpy(__dst, *(const void **)(a1 + 56), (int)result);
  return *(unsigned int *)(a1 + 64);
}

uint64_t utrie2_enum( uint64_t a1, uint64_t (*a2)(uint64_t a1, uint64_t a2), uint64_t (*a3)(uint64_t, uint64_t, void, uint64_t), uint64_t a4)
{
  return sub_18088A330(a1, 0LL, 1114112, a2, a3, a4);
}

uint64_t sub_18088A330( uint64_t result, uint64_t a2, int a3, uint64_t (*a4)(uint64_t a1, uint64_t a2), uint64_t (*a5)(uint64_t, uint64_t, void, uint64_t), uint64_t a6)
{
  int v52 = a3;
  uint64_t v53 = result;
  if (a5)
  {
    int v7 = sub_18088A7C0;
    if (a4) {
      int v7 = a4;
    }
    __int128 v57 = v7;
    uint64_t v8 = *(void *)(result + 72);
    if (v8)
    {
      uint64_t v54 = 0LL;
      uint64_t v9 = v8 + 144128;
      int v50 = *(_DWORD *)(v9 + 32);
      int v10 = *(_DWORD *)(v9 + 36);
    }

    else
    {
      uint64_t v54 = *(void *)result;
      uint64_t v9 = result + 16;
      int v50 = *(unsigned __int16 *)(result + 32);
      int v10 = *(unsigned __int16 *)(result + 34);
    }

    int v55 = v10;
    int v11 = a3;
    uint64_t v12 = *(void *)v9;
    int v13 = *(_DWORD *)(result + 44);
    unsigned int v14 = v57(a6, *(unsigned int *)(result + 36));
    uint64_t v15 = 0LL;
    BOOL v16 = (int)a2 < v52;
    if ((int)a2 < v52 && v13 > (int)a2)
    {
      unsigned int v51 = v14;
      uint64_t v15 = 0LL;
      int v17 = -1;
      int v18 = -1;
      uint64_t v19 = a2;
      int v47 = v13;
      while (1)
      {
        uint64_t v20 = (v19 + 2048);
        unsigned int v21 = (int)v20 >= v11 ? v11 : v19 + 2048;
        unsigned int v22 = v19 >> 11;
        if (v54) {
          int v26 = *(unsigned __int16 *)(v54 + 2LL * (v22 + 2080));
        }
        else {
          int v26 = *(_DWORD *)(*(void *)(v53 + 72) + 4LL * v22);
        }
LABEL_72:
        int v11 = v52;
        BOOL v16 = (int)v20 < v52;
        if ((int)v20 < v52)
        {
          uint64_t v19 = v20;
        }

        goto LABEL_76;
      }

      if ((v19 & 0x400) != 0) {
        int v23 = 1728;
      }
      else {
        int v23 = 2048;
      }
      if ((v19 & 0x400) != 0) {
        int v24 = 57344;
      }
      else {
        int v24 = 56320;
      }
      if (v24 >= v11) {
        int v24 = v11;
      }
      BOOL v25 = v22 == 27;
      if (v22 == 27) {
        int v26 = v23;
      }
      else {
        int v26 = (int)v19 >> 5;
      }
      if (v25) {
        unsigned int v21 = v24;
      }
LABEL_33:
      if (v26 == v50)
      {
        if ((_DWORD)v15 == v51)
        {
          uint64_t v15 = v51;
          int v18 = v50;
        }

        else if ((int)v19 <= (int)a2)
        {
          int v18 = v50;
          uint64_t v15 = v51;
          a2 = v19;
          int v17 = v55;
        }

        else
        {
          uint64_t result = a5(a6, a2, (v19 - 1), v15);
          int v18 = v50;
          uint64_t v15 = v51;
          a2 = v19;
          int v17 = v55;
          if (!(_DWORD)result) {
            return result;
          }
        }
      }

      else
      {
        uint64_t v27 = (v19 >> 5) & 0x3F;
        unsigned int v28 = v21 ^ v19;
        unsigned int v29 = (v21 >> 5) & 0x3F;
        if (v28 >= 0x800) {
          uint64_t v30 = 64LL;
        }
        else {
          uint64_t v30 = v29;
        }
        if (v27 >= v30)
        {
          uint64_t v20 = v19;
          int v18 = v26;
        }

        else
        {
          int v46 = v26;
          uint64_t v31 = v26;
          uint64_t v32 = v54;
          uint64_t v48 = v31;
          uint64_t v49 = v30;
          do
          {
            if (v32) {
              int v33 = 4 * *(unsigned __int16 *)(v32 + 2 * (v27 + v31));
            }
            else {
              int v33 = *(_DWORD *)(*(void *)(v53 + 72) + 4 * (v27 + v31) + 2176);
            }
            if (v33 == v17 && (int)v19 - (int)a2 >= 32)
            {
              uint64_t v19 = (v19 + 32);
            }

            else
            {
              if (v33 == v55)
              {
                if ((_DWORD)v15 == v51)
                {
                  uint64_t v34 = a2;
                }

                else
                {
                  uint64_t v34 = v19;
                  if ((int)v19 > (int)a2)
                  {
                    uint64_t result = a5(a6, a2, (v19 - 1), v15);
                    uint64_t v34 = v19;
                    if (!(_DWORD)result) {
                      return result;
                    }
                  }
                }

                uint64_t v19 = (v19 + 32);
                uint64_t v15 = v51;
                a2 = v34;
                int v17 = v55;
              }

              else
              {
                uint64_t v35 = 0LL;
                uint64_t v36 = (unsigned int *)(v12 + 4LL * v33);
                uint64_t v37 = v32 + 2LL * v33;
                do
                {
                  if (v12) {
                    uint64_t v38 = *v36;
                  }
                  else {
                    uint64_t v38 = *(unsigned __int16 *)(v37 + v35);
                  }
                  uint64_t v39 = v57(a6, v38);
                  if ((_DWORD)v39 != (_DWORD)v15)
                  {
                    uint64_t v40 = v39;
                    if ((int)a2 >= (int)v19)
                    {
                      uint64_t v15 = v39;
                      a2 = v19;
                    }

                    else
                    {
                      uint64_t result = a5(a6, a2, (v19 - 1), v15);
                      uint64_t v15 = v40;
                      a2 = v19;
                      if (!(_DWORD)result) {
                        return result;
                      }
                    }
                  }

                  uint64_t v19 = (v19 + 1);
                  ++v36;
                  v35 += 2LL;
                }

                while (v35 != 64);
                int v17 = v33;
              }

              uint64_t v32 = v54;
              uint64_t v31 = v48;
              uint64_t v30 = v49;
            }

            ++v27;
          }

          while (v27 != v30);
          uint64_t v20 = v19;
          int v18 = v46;
        }
      }

      goto LABEL_72;
    }

    uint64_t v20 = a2;
LABEL_76:
    else {
      int v41 = v20;
    }
    if (!v16)
    {
      uint64_t v44 = v15;
      int v52 = v41;
LABEL_88:
      uint64_t v20 = a2;
      return a5(a6, v20, (v52 - 1), v44);
    }

    if (v54)
    {
      uint64_t v42 = *(int *)(v53 + 48);
      if (v12) {
        uint64_t v43 = *(unsigned int *)(v12 + 4 * v42);
      }
      else {
        uint64_t v43 = *(unsigned __int16 *)(v54 + 2 * v42);
      }
    }

    else
    {
      uint64_t v43 = *(unsigned int *)(*(void *)(*(void *)(v53 + 72) + 144128LL)
    }

    uint64_t v45 = v57(a6, v43);
    if ((_DWORD)v45 == (_DWORD)v15)
    {
      uint64_t v44 = v15;
      goto LABEL_88;
    }

    uint64_t v44 = v45;
    uint64_t result = a5(a6, a2, (v20 - 1), v15);
    if ((_DWORD)result) {
      return a5(a6, v20, (v52 - 1), v44);
    }
  }

  return result;
}

uint64_t utrie2_enumForLeadSurrogate( uint64_t result, unsigned int a2, uint64_t (*a3)(uint64_t a1, uint64_t a2), uint64_t (*a4)(uint64_t, uint64_t, void, uint64_t), uint64_t a5)
{
  if (a2 >> 10 == 54) {
    return sub_18088A330(result, (a2 << 10) - 56557568, (a2 << 10) - 56556544, a3, a4, a5);
  }
  return result;
}

uint64_t sub_18088A7C0(uint64_t a1, uint64_t a2)
{
  return a2;
}

_OWORD *utrie2_open(unsigned int a1, unsigned int a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  uint64_t v3 = uprv_malloc(0x50uLL);
  int v7 = uprv_malloc(0x453C0uLL);
  uint64_t v8 = (char *)uprv_malloc(0x10000uLL);
  uint64_t v9 = v8;
  if (v3 && v7 && v8)
  {
    uint64_t v10 = 0LL;
    v3[2] = 0u;
    v3[3] = 0u;
    *uint64_t v3 = 0u;
    v3[1] = 0u;
    *((_DWORD *)v3 + 9) = a1;
    *((_DWORD *)v3 + 10) = a2;
    v7[36037] = 0x4000;
    *((_DWORD *)v3 + 1sub_18086E18C((uint64_t)this, 1) = 1114112;
    *((void *)v3 + 8) = 0LL;
    *((void *)v3 + 9) = v7;
    *((void *)v7 + 18016) = v8;
    v7[36034] = a1;
    v7[36035] = a2;
    v7[36042] = 1114112;
    v7[36039] = 0;
    *((_BYTE *)v7 + 144172) = 0;
    int32x4_t v11 = vdupq_n_s32(a1);
    do
    {
      *(int32x4_t *)&v8[v10] = v11;
      v10 += 16LL;
    }

    while (v10 != 512);
    uint64_t v12 = 0LL;
    int32x4_t v13 = vdupq_n_s32(a2);
    do
    {
      *(int32x4_t *)&v8[v12 + 512] = v13;
      v12 += 16LL;
    }

    while (v12 != 256);
    for (uint64_t i = 0LL; i != 256; i += 16LL)
      *(int32x4_t *)&v8[i + 768] = v11;
    v7[36038] = 256;
    *((_OWORD *)v7 + 136) = xmmword_180A2CBC0;
    *(void *)&__int128 v15 = 0x100000001LL;
    *((void *)&v15 + sub_18086E18C((uint64_t)this, 1) = 0x100000001LL;
    *((_OWORD *)v7 + 901sub_18086E18C((uint64_t)this, 1) = v15;
    *((void *)v7 + 18024) = 0LL;
    *((void *)v7 + 18025) = 34845LL;
    memset_pattern16(v7 + 548, &unk_180A2CBF0, 0x2070uLL);
    memset(v7 + 2624, 255, 0x900uLL);
    memset_pattern16(v7 + 3200, &unk_180A2CBF0, 0x100uLL);
    uint64_t v16 = 0LL;
    *((void *)v7 + 18020) = 0xC000000A60LL;
    v7[36036] = 2720;
    int32x4_t v17 = (int32x4_t)xmmword_180A2CBD0;
    v18.i64[0] = 0x10000000100LL;
    v18.i64[1] = 0x10000000100LL;
    do
    {
      *(int32x4_t *)&v7[v16] = v17;
      int32x4_t v17 = vaddq_s32(v17, v18);
      v16 += 4LL;
    }

    while (v16 != 32);
    memset_pattern16(v7 + 32, &unk_180A2CC00, 0x800uLL);
    unsigned int v19 = 96;
    do
    {
      v19 += 32;
      if (*a3 <= 0) {
        sub_18088BA30((uint64_t)v7, v19, 1, a1, a3);
      }
    }

    while (v19 < 0x7E0);
  }

  else
  {
    uprv_free(v3);
    uprv_free(v7);
    uprv_free(v9);
    uint64_t v3 = 0LL;
    *a3 = 7;
  }

  return v3;
}

uint64_t utrie2_set32(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a2 < 0x110000) {
      return sub_18088BA30(*(void *)(result + 72), a2, 1, a3, a4);
    }
    else {
      *a4 = 1;
    }
  }

  return result;
}

void *utrie2_clone(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (!a1 || !*(void *)(a1 + 56) && !*(void *)(a1 + 72))
  {
    uint64_t v2 = 0LL;
    int v13 = 1;
LABEL_15:
    *a2 = v13;
    return v2;
  }

  int32_t v5 = uprv_malloc(0x50uLL);
  uint64_t v2 = v5;
  if (!v5)
  {
    int v13 = 7;
    goto LABEL_15;
  }

  __int128 v6 = *(_OWORD *)(a1 + 48);
  v5[2] = *(_OWORD *)(a1 + 32);
  v5[3] = v6;
  v5[4] = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 16);
  *int32_t v5 = *(_OWORD *)a1;
  v5[1] = v7;
  if (*(void *)(a1 + 56))
  {
    uint64_t v8 = (char *)uprv_malloc(*(int *)(a1 + 64));
    v2[7] = v8;
    if (v8)
    {
      uint64_t v9 = v8;
      *((_BYTE *)v2 + 68) = 1;
      uint64_t v10 = *(const void **)(a1 + 56);
      memcpy(v8, v10, *(int *)(a1 + 64));
      uint64_t v11 = *(void *)(a1 + 8);
      *uint64_t v2 = &v9[*(void *)a1 - (void)v10];
      if (v11) {
        v2[1] = &v9[v11 - (void)v10];
      }
      uint64_t v12 = *(void *)(a1 + 16);
      if (v12) {
        v2[2] = &v9[v12 - (void)v10];
      }
      return v2;
    }

void *utrie2_cloneAsThawed(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0LL;
  }
  if (!a1) {
    goto LABEL_23;
  }
  uint64_t v5 = *(void *)(a1 + 72);
  if (*(void *)(a1 + 56))
  {
    if (!v5) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  if (!v5)
  {
LABEL_23:
    uint64_t result = 0LL;
    *a2 = 1;
    return result;
  }

BOOL sub_18088ADD0(uint64_t a1, unsigned int a2, int a3, unsigned int a4)
{
  uint64_t v5 = *(void *)a1;
  if (*(_DWORD *)(v5 + 36) == a4) {
    return 1LL;
  }
  unsigned int v7 = a3 - (*(_BYTE *)(a1 + 12) != 0);
  uint64_t v8 = (int *)(a1 + 8);
  if (v7 == a2)
  {
    if (*v8 <= 0)
    {
      if (a2 < 0x110000) {
        sub_18088BA30(*(void *)(v5 + 72), a2, 1, a4, v8);
      }
      else {
        int *v8 = 1;
      }
    }
  }

  else
  {
    utrie2_setRange32(v5, a2, v7, a4, 1, (int *)(a1 + 8));
  }

  return *v8 < 1;
}

uint64_t utrie2_set32ForLeadSurrogateCodeUnit(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a2 >> 10 == 54) {
      return sub_18088BA30(*(void *)(result + 72), a2, 0, a3, a4);
    }
    else {
      *a4 = 1;
    }
  }

  return result;
}

_OWORD *utrie2_fromUTrie(uint64_t a1, unsigned int a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if (!a1)
  {
    uint64_t result = 0LL;
    *a3 = 1;
    return result;
  }

  uint64_t v11 = utrie2_open(*(_DWORD *)(a1 + 32), a2, a3);
  int v6 = *a3;
  if (*a3 > 0) {
    return 0LL;
  }
  int v13 = 1;
  int v12 = v6;
  utrie_enum(a1, 0LL, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18088ADD0, (uint64_t)&v11);
  int v7 = 0;
  *a3 = v12;
  do
  {
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = (v7 & 0x1F) + 4 * *(unsigned __int16 *)(*(void *)a1 + 2LL * ((v7 + 55296) >> 5));
    if (v8) {
      int v10 = *(_DWORD *)(v8 + 4 * v9);
    }
    else {
      int v10 = *(unsigned __int16 *)(*(void *)a1 + 2 * v9);
    }
    if (v10 != *(_DWORD *)(a1 + 32) && *a3 <= 0)
    {
      if ((((_WORD)v7 - 10240) & 0xFC00) == 0xD800) {
        sub_18088BA30(*((void *)v11 + 9), v7 + 55296, 0, v10, a3);
      }
      else {
        *a3 = 1;
      }
    }

    ++v7;
  }

  while (v7 != 1024);
  uint64_t result = v11;
  if (*a3 > 0 || (utrie2_freeze((uint64_t)v11, *(void *)(a1 + 8) != 0LL, a3), uint64_t result = v11, *a3 >= 1))
  {
    utrie2_close((uint64_t)result);
    return 0LL;
  }

  return result;
}

void utrie2_freeze(uint64_t a1, unsigned int a2, int *a3)
{
  if (*a3 > 0) {
    return;
  }
  if (!a1 || a2 >= 2) {
    goto LABEL_11;
  }
  uint64_t v6 = *(void *)(a1 + 72);
  if (!v6)
  {
    if ((*(void *)(a1 + 8) == 0LL) == a2) {
      return;
    }
    goto LABEL_11;
  }

  int v7 = (const void **)(v6 + 144128);
  if (*(_BYTE *)(v6 + 144172))
  {
LABEL_6:
    int v8 = *(_DWORD *)(a1 + 44);
    if (v8 > 0x10000)
    {
      int v10 = *(_DWORD *)(v6 + 144144);
      BOOL v9 = a2 == 0;
      if (a2) {
        signed int v11 = 0;
      }
      else {
        signed int v11 = *(_DWORD *)(v6 + 144144);
      }
      if (v10 >= 0x10000) {
        goto LABEL_101;
      }
    }

    else
    {
      BOOL v9 = a2 == 0;
      int v10 = 2112;
      if (a2) {
        signed int v11 = 0;
      }
      else {
        signed int v11 = 2112;
      }
    }

    if (v11 > 63359
      || *(_DWORD *)(v6 + 144164) + v11 >= 0x10000
      || (int v74 = *(_DWORD *)(v6 + 144152), v74 + v11 >= 262141))
    {
LABEL_101:
      int v12 = 8;
      goto LABEL_102;
    }

    if (v9) {
      char v75 = 1;
    }
    else {
      char v75 = 2;
    }
    int v76 = (v74 << v75) + 2 * v10 + 16;
    uint64_t v77 = (int16x8_t *)uprv_malloc(v76);
    *(void *)(a1 + 56) = v77;
    if (!v77)
    {
      int v12 = 7;
      goto LABEL_102;
    }

    *(_DWORD *)(a1 + 64) = v76;
    *(_BYTE *)(a1 + 68) = 1;
    uint64_t v78 = *(int *)(v6 + 144152);
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 28) = v78;
    if (v8 > 0x10000) {
      int v79 = *(_DWORD *)(v6 + 144160);
    }
    else {
      LOWORD(v79) = -1;
    }
    *(_WORD *)(a1 + 32) = v79;
    __int16 v110 = *(_DWORD *)(v6 + 144164) + v11;
    *(_WORD *)(a1 + 34) = v110;
    *(_DWORD *)(a1 + 48) = v11 + v78 - 4;
    v77->i32[0] = 1416784178;
    v77->i16[2] = a2;
    v77->i16[3] = v10;
    v77->i16[4] = v78 >> 2;
    v77->i16[5] = v79;
    v77->i16[6] = v110;
    v77->i16[7] = v8 >> 11;
    int v111 = v77 + 1;
    *(void *)a1 = v77 + 1;
    int32x4_t v112 = vdupq_n_s32(v11);
    uint64_t v113 = -8320LL;
    do
    {
      *v111++ = vshrn_high_n_s32( vshrn_n_s32(vaddq_s32(*(int32x4_t *)(v6 + v113 + 10496), v112), 2uLL),  vaddq_s32(*(int32x4_t *)(v6 + v113 + 10512), v112),  2uLL);
      v113 += 32LL;
    }

    while (v113);
    uint64_t v114 = 0LL;
    v77[261].i16[0] = v11 + 128;
    v77[261].i16[1] = v11 + 128;
    do
    {
      v77[261].i16[v114 + 2] = *(_WORD *)(v6 + 2 * v114 + 2192) + v11;
      ++v114;
    }

    while (v114 != 30);
    int v115 = v77 + 265;
    unsigned int v116 = v8 - 0x10000;
    if (v8 > 0x10000)
    {
      unsigned int v117 = v116 >> 11;
      unsigned int v118 = (v116 >> 11) + 2112;
      if (v116 >= 0x800)
      {
        v119 = (int *)(v6 + 128);
        unsigned int v120 = v117 + 1;
        do
        {
          int v121 = *v119++;
          v115->i16[0] = v121;
          int v115 = (int16x8_t *)((char *)v115 + 2);
          --v120;
        }

        while (v120 > 1);
      }

      int v122 = *(_DWORD *)(v6 + 144144);
      if ((int)(v122 - v118) >= 1)
      {
        v123 = (int *)(v6 + 2176 + 4LL * v118);
        unsigned int v124 = v122 - v117 - 2111;
        do
        {
          int v125 = *v123++;
          v115->i16[0] = (v125 + v11) >> 2;
          int v115 = (int16x8_t *)((char *)v115 + 2);
          --v124;
        }

        while (v124 > 1);
      }
    }

    if (a2 == 1)
    {
      *(void *)(a1 + 8) = 0LL;
      *(void *)(a1 + 16) = v115;
      memcpy(v115, *v7, 4 * v78);
      unsigned int v126 = (void *)*v7;
LABEL_182:
      uprv_free(v126);
      uprv_free((void *)v6);
      *(void *)(a1 + 72) = 0LL;
      return;
    }

    if (!a2)
    {
      *(void *)(a1 + 8) = v115;
      *(void *)(a1 + 16) = 0LL;
      unsigned int v126 = (void *)*v7;
      if ((int)v78 >= 1)
      {
        unsigned int v127 = v78 + 1;
        v128 = (int *)*v7;
        do
        {
          int v129 = *v128++;
          v115->i16[0] = v129;
          int v115 = (int16x8_t *)((char *)v115 + 2);
          --v127;
        }

        while (v127 > 1);
      }

      goto LABEL_182;
    }

LABEL_183:
  int v27 = v19;
LABEL_184:
  signed int v29 = (v27 + 2047) & 0xFFFFF800;
  if (v29 == 1114112)
  {
    int v14 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(v6 + 144168) = 1114112;
    *(_DWORD *)(a1 + 44) = 1114112;
  }

  else
  {
    *(_DWORD *)(v6 + 144168) = v29;
    *(_DWORD *)(a1 + 44) = v29;
    if (v29 < 1114112)
    {
LABEL_41:
      if (v29 <= 0x10000) {
        unsigned int v30 = 0x10000;
      }
      else {
        unsigned int v30 = v29;
      }
      utrie2_setRange32(a1, v30, 0x10FFFFu, *(_DWORD *)(a1 + 36), 1, a3);
      if (*a3 > 0) {
        return;
      }
    }
  }

  uint64_t v31 = 0LL;
  uint64_t v32 = (_DWORD *)(v6 + 144176);
  do
  {
    *v32++ = v31;
    v31 += 32LL;
  }

  while (v31 != 192);
  int v33 = *(_DWORD *)(v6 + 144152);
  if (v33 >= 193)
  {
    uint64_t v34 = v6 + 144176;
    uint64_t v35 = v6 + 144180;
    int v36 = 192;
    LODWORD(v37) = 64;
    int v38 = 2;
    int v39 = 192;
    while (1)
    {
      if (v39 == 2176) {
        uint64_t v37 = 32LL;
      }
      else {
        uint64_t v37 = v37;
      }
      if (v39 == 2176) {
        int v38 = 1;
      }
      if (*(int *)(v6 + 4LL * (v39 >> 5) + 144176) > 0)
      {
        uint64_t v40 = (uint64_t)v39 >> 5;
        int v41 = (char *)*v7;
        if (v36 - (int)v37 < 0)
        {
LABEL_74:
          uint64_t v54 = v37 - 4;
          int v55 = v37 - 3;
          while (2)
          {
            uint64_t v56 = v54;
            __int128 v57 = &v41[4 * (v36 - v54)];
            int v58 = v55;
            __int128 v59 = &v41[4 * v39];
            while (*(_DWORD *)v57 == *(_DWORD *)v59)
            {
              v57 += 4;
              v59 += 4;
              if (--v58 <= 1) {
                goto LABEL_81;
              }
            }

            uint64_t v54 = v56 - 4;
            v55 -= 4;
            if (v56 >= 5) {
              continue;
            }
            break;
          }

          LODWORD(v56) = v56 - 4;
          if (v36 >= v39)
          {
            uint64_t v72 = (int *)(v34 + 4 * v40);
            int v73 = v38 + 1;
            do
            {
              *v72++ = v39;
              v39 += 32;
              --v73;
              int v36 = v39;
            }

            while (v73 > 1);
            goto LABEL_90;
          }

uint64_t sub_18088BA30(uint64_t result, unsigned int a2, int a3, int a4, int *a5)
{
  if (!result || (uint64_t v6 = (void *)(result + 144128), *(_BYTE *)(result + 144172)))
  {
    int v7 = 30;
LABEL_4:
    *a5 = v7;
    return result;
  }

  char v9 = a2;
  uint64_t result = sub_18088BEFC((_DWORD *)result, a2, a3);
  if ((result & 0x80000000) != 0)
  {
    int v7 = 7;
    goto LABEL_4;
  }

  *(_DWORD *)(*v6 + 4LL * (result + (v9 & 0x1F))) = a4;
  return result;
}

uint64_t utrie2_setRange32( uint64_t result, unsigned int a2, unsigned int a3, unsigned int a4, int a5, int *a6)
{
  if (*a6 <= 0)
  {
    int v7 = a2;
    int v8 = 1;
    if ((int)a2 > (int)a3 || a2 > 0x10FFFF || a3 > 0x10FFFF)
    {
LABEL_8:
      *a6 = v8;
      return result;
    }

    uint64_t v9 = *(void *)(result + 72);
    if (!v9 || (int v10 = (void *)(v9 + 144128), *(_BYTE *)(v9 + 144172)))
    {
      int v8 = 30;
      goto LABEL_8;
    }

    if (a5 || *(_DWORD *)(v9 + 144136) != a4)
    {
      unsigned int v13 = a3 + 1;
      uint64_t v14 = a2 & 0x1F;
      if ((a2 & 0x1F) != 0)
      {
        uint64_t result = sub_18088BEFC(*(_DWORD **)(result + 72), a2, 1);
        if ((result & 0x80000000) != 0) {
          goto LABEL_85;
        }
        int v7 = (v7 + 31) & 0xFFFFFFE0;
        uint64_t v15 = *v10 + 4LL * result;
        if (v7 > v13)
        {
          unsigned int v16 = v13 & 0x1F;
          unint64_t v17 = v15 + 4LL * (v13 & 0x1F);
          uint64_t v18 = (unsigned int *)(v15 + 4LL * v14);
          if (a5)
          {
            if (v14 < v16)
            {
              do
                *v18++ = a4;
              while ((unint64_t)v18 < v17);
            }
          }

          else if (v14 < v16)
          {
            int v20 = *(_DWORD *)(v9 + 144136);
            do
            {
              if (*v18 == v20) {
                *uint64_t v18 = a4;
              }
              ++v18;
            }

            while ((unint64_t)v18 < v17);
          }

          return result;
        }

        if (a5)
        {
          uint64_t v19 = 4 * v14;
          do
          {
            *(_DWORD *)(v15 + v19) = a4;
            v19 += 4LL;
          }

          while (v19 != 128);
        }

        else
        {
          int v21 = *(_DWORD *)(v9 + 144136);
          uint64_t v22 = 4 * v14;
          do
          {
            if (*(_DWORD *)(v15 + v22) == v21) {
              *(_DWORD *)(v15 + v22) = a4;
            }
            v22 += 4LL;
          }

          while (v22 != 128);
        }
      }

      char v65 = v13;
      signed int v23 = v13 & 0xFFFFFFE0;
      if (*(_DWORD *)(v9 + 144136) == a4) {
        uint64_t result = *(unsigned int *)(v9 + 144164);
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      if (v7 < v23)
      {
        uint64_t v24 = v9 + 2176;
        int32x4_t v25 = vdupq_n_s32(a4);
        uint64_t v26 = v9 + 144176;
        int32x4_t v64 = v25;
        do
        {
          unsigned int v27 = v7 & 0xFFFFFC00;
          if (*(_DWORD *)(v9 + 144136) != a4
            || (v27 != 55296
              ? (int v28 = *(_DWORD *)(v9 + 4LL * (v7 >> 11)) + ((v7 >> 5) & 0x3F))
              : (int v28 = (v7 >> 5) + 320),
                *(_DWORD *)(v9 + 4LL * v28 + 2176) != *(_DWORD *)(v9 + 144164)))
          {
            if (v27 == 55296)
            {
              int v29 = 2048;
            }

            else
            {
              int v30 = *(_DWORD *)(v9 + 4LL * (v7 >> 11));
              if (v30 == *(_DWORD *)(v9 + 144160))
              {
                int v29 = *(_DWORD *)(v9 + 144144);
                if (v29 > 35424) {
                  goto LABEL_86;
                }
                *(_DWORD *)(v9 + 144144) = v29 + 64;
                uint64_t v31 = (_OWORD *)(v24 + 4LL * v29);
                uint64_t v32 = (__int128 *)(v24 + 4LL * v30);
                __int128 v33 = *v32;
                __int128 v34 = v32[1];
                __int128 v35 = v32[3];
                v31[2] = v32[2];
                v31[3] = v35;
                *uint64_t v31 = v33;
                v31[1] = v34;
                __int128 v36 = v32[4];
                __int128 v37 = v32[5];
                __int128 v38 = v32[7];
                v31[6] = v32[6];
                v31[7] = v38;
                _OWORD v31[4] = v36;
                v31[5] = v37;
                __int128 v39 = v32[8];
                __int128 v40 = v32[9];
                __int128 v41 = v32[11];
                v31[10] = v32[10];
                v31[11] = v41;
                v31[8] = v39;
                v31[9] = v40;
                __int128 v42 = v32[12];
                __int128 v43 = v32[13];
                __int128 v44 = v32[15];
                v31[14] = v32[14];
                v31[15] = v44;
                v31[12] = v42;
                v31[13] = v43;
                if (v29 < 0)
                {
LABEL_86:
                  int v8 = 5;
                  goto LABEL_8;
                }

                *(_DWORD *)(v9 + 4 * ((uint64_t)v7 >> 11)) = v29;
              }

              else
              {
                int v29 = *(_DWORD *)(v9 + 4LL * (v7 >> 11));
                if (v30 < 0) {
                  goto LABEL_86;
                }
              }
            }

            uint64_t v45 = v9 + 4LL * (v29 + ((v7 >> 5) & 0x3F));
            uint64_t v46 = *(int *)(v45 + 2176);
            int v47 = *(_DWORD *)(v9 + 144164);
            if (v47 == (_DWORD)v46 || *(_DWORD *)(v9 + 4LL * ((int)v46 >> 5) + 144176) != 1)
            {
              BOOL v50 = v47 != (_DWORD)v46 && a5 == 0;
              int v51 = *(_DWORD *)(*v10 + 4 * v46);
              if (!v50 && v51 != a4)
              {
LABEL_64:
                if ((result & 0x80000000) != 0)
                {
                  uint64_t result = sub_18088BEFC((_DWORD *)v9, v7, 1);
                  if ((result & 0x80000000) != 0) {
                    goto LABEL_85;
                  }
                  uint64_t v56 = 0LL;
                  uint64_t v57 = *v10 + 4LL * result;
                  int32x4_t v25 = v64;
                  do
                  {
                    *(int32x4_t *)(v57 + v56) = v64;
                    v56 += 16LL;
                  }

                  while (v56 != 128);
                }

                else
                {
                  int32x2_t v53 = (int *)(v45 + 2176);
                  ++*(_DWORD *)(v26 + 4LL * (result >> 5));
                  int v54 = *v53;
                  int v55 = (_DWORD *)(v26 + 4LL * (*v53 >> 5));
                  BOOL v50 = (*v55)-- == 1;
                  if (v50)
                  {
                    _DWORD *v55 = -*(_DWORD *)(v9 + 144156);
                    *(_DWORD *)(v9 + 144156) = v54;
                  }

                  *int32x2_t v53 = result;
                }
              }
            }

            else
            {
              uint64_t v48 = *v10 + 4 * v46;
              uint64_t v49 = 0LL;
              if (a5)
              {
                do
                {
                  *(int32x4_t *)(v48 + v49) = v25;
                  v49 += 16LL;
                }

                while (v49 != 128);
              }

              else
              {
                int v58 = (const float *)(v9 + 144136);
                int32x2_t v59 = (int32x2_t)vld1_dup_f32(v58);
                do
                {
                  int32x2_t v60 = vceq_s32(*(int32x2_t *)(v48 + v49), v59);
                  if ((v60.i8[0] & 1) != 0) {
                    *(_DWORD *)(v48 + v49) = a4;
                  }
                  if ((v60.i8[4] & 1) != 0) {
                    *(_DWORD *)(v48 + v49 + 4) = a4;
                  }
                  v49 += 8LL;
                }

                while (v49 != 128);
              }
            }
          }

          v7 += 32;
        }

        while (v7 < v23);
      }

      if ((v65 & 0x1F) == 0) {
        return result;
      }
      uint64_t result = sub_18088BEFC((_DWORD *)v9, v7, 1);
      if ((result & 0x80000000) == 0)
      {
        unint64_t v61 = (unsigned int *)(*v10 + 4LL * result);
        uint64_t v62 = &v61[v65 & 0x1F];
        if (a5)
        {
          do
            *v61++ = a4;
          while (v61 < v62);
        }

        else
        {
          int v63 = *(_DWORD *)(v9 + 144136);
          do
          {
            if (*v61 == v63) {
              *unint64_t v61 = a4;
            }
            ++v61;
          }

          while (v61 < v62);
        }

        return result;
      }

uint64_t sub_18088BEFC(_DWORD *a1, unsigned int a2, int a3)
{
  int v5 = sub_18088C0BC((uint64_t)a1, a2, a3);
  if (v5 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = (const void **)(a1 + 36032);
  int v7 = &a1[v5 + ((a2 >> 5) & 0x3F)];
  int v8 = v7[544];
  if (a1[36041] != v8)
  {
    uint64_t v9 = v7[544];
    if (a1[(v8 >> 5) + 36044] == 1) {
      return v9;
    }
  }

  uint64_t v9 = a1[36039];
  if ((_DWORD)v9)
  {
    uint64_t v10 = (uint64_t)(int)v9 >> 5;
    a1[36039] = -a1[((int)v9 >> 5) + 36044];
    goto LABEL_13;
  }

  int v11 = a1[36037];
  uint64_t v9 = a1[36038];
  if ((int)v9 + 32 > v11)
  {
    if (v11 >= 0x20000)
    {
      int v12 = 1115264;
    }

    else
    {
      int v12 = 0x20000;
    }

    unsigned int v13 = uprv_malloc((4 * v12));
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = (void *)*v6;
      memcpy(v13, *v6, 4LL * (int)a1[36038]);
      uprv_free(v15);
      *uint64_t v6 = v14;
      a1[36037] = v12;
      goto LABEL_12;
    }

    return 0xFFFFFFFFLL;
  }

uint64_t sub_18088C0BC(uint64_t a1, int a2, int a3)
{
  int v4 = (_DWORD *)(a1 + 144144);
  uint64_t v5 = *(unsigned int *)(a1 + 4LL * (a2 >> 11));
  uint64_t v3 = v5;
  if ((_DWORD)v5 == *(_DWORD *)(a1 + 144160))
  {
    uint64_t v3 = *v4;
    *int v4 = v3 + 64;
    uint64_t v6 = (_OWORD *)(a1 + 2176 + 4LL * (int)v3);
    int v7 = (__int128 *)(a1 + 2176 + 4LL * (int)v5);
    __int128 v8 = *v7;
    __int128 v9 = v7[1];
    __int128 v10 = v7[3];
    v6[2] = v7[2];
    v6[3] = v10;
    *uint64_t v6 = v8;
    v6[1] = v9;
    __int128 v11 = v7[4];
    __int128 v12 = v7[5];
    __int128 v13 = v7[7];
    _OWORD v6[6] = v7[6];
    v6[7] = v13;
    _OWORD v6[4] = v11;
    v6[5] = v12;
    __int128 v14 = v7[8];
    __int128 v15 = v7[9];
    __int128 v16 = v7[11];
    v6[10] = v7[10];
    v6[11] = v16;
    v6[8] = v14;
    v6[9] = v15;
    __int128 v17 = v7[12];
    __int128 v18 = v7[13];
    __int128 v19 = v7[15];
    _OWORD v6[14] = v7[14];
    v6[15] = v19;
    v6[12] = v17;
    v6[13] = v18;
    if ((v3 & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    else {
      *(_DWORD *)(a1 + 4 * ((uint64_t)a2 >> 11)) = v3;
    }
  }

  return v3;
}

uint64_t utrie_swap(uint64_t a1, unsigned int *a2, int a3, uint64_t a4, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0LL;
  }
  if (!a1 || !a2 || (a3 & 0x80000000) == 0 && !a4)
  {
    uint64_t v6 = 0LL;
    int v11 = 1;
LABEL_9:
    *a5 = v11;
    return v6;
  }

  if (a3 <= 0xF)
  {
LABEL_12:
    uint64_t v6 = 0LL;
    int v11 = 8;
    goto LABEL_9;
  }

  int v13 = (*(uint64_t (**)(void))(a1 + 16))(*a2);
  __int16 v14 = (*(uint64_t (**)(void))(a1 + 16))(a2[1]);
  int Int32 = udata_readInt32(a1, a2[2]);
  int v16 = udata_readInt32(a1, a2[3]);
  if (v13 != 1416784229
    || (v14 & 0xF) != 5
    || (v14 & 0xF0) != 0x20
    || Int32 < 2048
    || (Int32 & 0x1F) != 0
    || (int v17 = v16, v16 < 32)
    || (v16 & 3) != 0
    || (v14 & 0x200) != 0 && v16 <= 0x11F)
  {
    uint64_t v6 = 0LL;
    int v11 = 3;
    goto LABEL_9;
  }

  if ((v14 & 0x100) != 0) {
    char v18 = 2;
  }
  else {
    char v18 = 1;
  }
  uint64_t v6 = ((v16 << v18) + 2 * Int32 + 16);
  if ((a3 & 0x80000000) == 0)
  {
    (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, int *))(a1 + 56))(a1, a2, 16LL, a4, a5);
    __int128 v19 = *(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, int *))(a1 + 48);
    int v20 = a2 + 4;
    if ((v14 & 0x100) != 0)
    {
      uint64_t v25 = a4 + 16;
      v19(a1, v20, (2 * Int32), v25, a5);
      __int128 v19 = *(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, int *))(a1 + 56);
      int v24 = (unsigned int *)((char *)v20 + 2 * Int32);
      uint64_t v21 = (4 * v17);
      uint64_t v22 = v25 + 2LL * Int32;
      uint64_t v23 = a1;
    }

    else
    {
      uint64_t v21 = (2 * (v17 + Int32));
      uint64_t v22 = a4 + 16;
      uint64_t v23 = a1;
      int v24 = v20;
    }

    v19(v23, v24, v21, v22, a5);
  }

  return v6;
}

uint64_t utrie2_swap(uint64_t a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4, int *a5)
{
  if (*a5 > 0) {
    return 0LL;
  }
  if (!a1 || !a2 || (a3 & 0x80000000) == 0 && !a4)
  {
    uint64_t v5 = 0LL;
    int v11 = 1;
LABEL_8:
    *a5 = v11;
    return v5;
  }

  if (a3 <= 0xF)
  {
LABEL_11:
    uint64_t v5 = 0LL;
    int v11 = 8;
    goto LABEL_8;
  }

  int v13 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)a2);
  char v14 = (*(uint64_t (**)(void))(a1 + 8))(a2[2]);
  unsigned int v15 = (*(uint64_t (**)(void))(a1 + 8))(a2[3]);
  unsigned int v16 = (*(uint64_t (**)(void))(a1 + 8))(a2[4]);
  if (v13 != 1416784178) {
    goto LABEL_24;
  }
  unsigned int v17 = v14 & 0xF;
  if (v17 > 1) {
    goto LABEL_24;
  }
  if (v15 < 0x840) {
    goto LABEL_24;
  }
  unsigned int v18 = v16;
  if (v16 <= 0x2F) {
    goto LABEL_24;
  }
  if ((v14 & 0xF) != 0)
  {
    if (v17 == 1)
    {
      char v19 = 4;
      goto LABEL_20;
    }

uint64_t ucptrie_swap(uint64_t a1, unsigned __int16 *a2, unsigned int a3, unsigned __int16 *a4, int *a5)
{
  if (*a5 > 0) {
    return 0LL;
  }
  if (!a1 || !a2 || (a3 & 0x80000000) == 0 && !a4)
  {
    uint64_t v5 = 0LL;
    int v11 = 1;
LABEL_8:
    *a5 = v11;
    return v5;
  }

  if (a3 <= 0xF)
  {
LABEL_11:
    uint64_t v5 = 0LL;
    int v11 = 8;
    goto LABEL_8;
  }

  int v13 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)a2);
  unsigned __int16 v14 = (*(uint64_t (**)(void))(a1 + 8))(a2[2]);
  unsigned int v15 = (*(uint64_t (**)(void))(a1 + 8))(a2[3]);
  int v16 = (*(uint64_t (**)(void))(a1 + 8))(a2[4]);
  int v11 = 3;
  else {
    unsigned int v17 = 1024;
  }
  if (v13 != 1416784179) {
    goto LABEL_25;
  }
  if ((v14 & 0x38) != 0) {
    goto LABEL_25;
  }
  unsigned int v18 = v14 & 7;
  if (v18 > 2) {
    goto LABEL_25;
  }
  if (v17 > v15) {
    goto LABEL_25;
  }
  size_t v19 = v16 & 0xFFF0FFFF | (v14 >> 12 << 16);
  if (v18 == 2)
  {
    unsigned int v20 = v16 & 0xFFF0FFFF | (v14 >> 12 << 16);
  }

  else
  {
    if (v18 != 1)
    {
      if ((v14 & 7) == 0)
      {
        unsigned int v20 = 2 * v19;
        goto LABEL_28;
      }

uint64_t utrie_swapAnyVersion(uint64_t a1, unsigned int *a2, int a3, unsigned __int16 *a4, int *a5)
{
  if (*a5 > 0) {
    return 0LL;
  }
  if (!a2 || a3 < 16 || (a2 & 3) != 0)
  {
LABEL_14:
    *a5 = 3;
    return 0LL;
  }

  unsigned int v5 = *a2;
  if ((int)*a2 > 1416784178)
  {
    if (v5 != 1416784179)
    {
      if (v5 == 1701409364 || v5 == 1416784229) {
        return utrie_swap(a1, a2, a3, (uint64_t)a4, a5);
      }
      goto LABEL_14;
    }
  }

  else
  {
    if (v5 == 845771348) {
      return utrie2_swap(a1, (unsigned __int16 *)a2, a3, (uint64_t)a4, a5);
    }
    if (v5 != 862548564)
    {
      if (v5 == 1416784178) {
        return utrie2_swap(a1, (unsigned __int16 *)a2, a3, (uint64_t)a4, a5);
      }
      goto LABEL_14;
    }
  }

  return ucptrie_swap(a1, (unsigned __int16 *)a2, a3, a4, a5);
}

void *icu::IDNA::labelToASCII_UTF8( void *result, const char *a2, int32_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*a6 <= 0)
  {
    __int128 v9 = result;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    uint64_t v18 = 0LL;
    __int128 v17 = 0u;
    unsigned __int16 v14 = off_18971B688;
    LOWORD(v15) = 2;
    icu::UnicodeString::fromUTF8(a2, a3, (uint64_t)v13);
    __int128 v10 = (icu::UnicodeString *)(*(uint64_t (**)(void *, _BYTE *, void (***)(icu::UnicodeString *__hidden), uint64_t, int *))(*(void *)v9 + 24LL))( v9,  v13,  &v14,  a5,  a6);
    icu::UnicodeString::toUTF8(v10, a4);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v13);
    return icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v14);
  }

  return result;
}

void *icu::IDNA::labelToUnicodeUTF8( void *result, const char *a2, int32_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*a6 <= 0)
  {
    __int128 v9 = result;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    uint64_t v18 = 0LL;
    __int128 v17 = 0u;
    unsigned __int16 v14 = off_18971B688;
    LOWORD(v15) = 2;
    icu::UnicodeString::fromUTF8(a2, a3, (uint64_t)v13);
    __int128 v10 = (icu::UnicodeString *)(*(uint64_t (**)(void *, _BYTE *, void (***)(icu::UnicodeString *__hidden), uint64_t, int *))(*(void *)v9 + 32LL))( v9,  v13,  &v14,  a5,  a6);
    icu::UnicodeString::toUTF8(v10, a4);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v13);
    return icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v14);
  }

  return result;
}

void *icu::IDNA::nameToASCII_UTF8( void *result, const char *a2, int32_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*a6 <= 0)
  {
    __int128 v9 = result;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    uint64_t v18 = 0LL;
    __int128 v17 = 0u;
    unsigned __int16 v14 = off_18971B688;
    LOWORD(v15) = 2;
    icu::UnicodeString::fromUTF8(a2, a3, (uint64_t)v13);
    __int128 v10 = (icu::UnicodeString *)(*(uint64_t (**)(void *, _BYTE *, void (***)(icu::UnicodeString *__hidden), uint64_t, int *))(*(void *)v9 + 40LL))( v9,  v13,  &v14,  a5,  a6);
    icu::UnicodeString::toUTF8(v10, a4);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v13);
    return icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v14);
  }

  return result;
}

void *icu::IDNA::nameToUnicodeUTF8( void *result, const char *a2, int32_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*a6 <= 0)
  {
    __int128 v9 = result;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    uint64_t v18 = 0LL;
    __int128 v17 = 0u;
    unsigned __int16 v14 = off_18971B688;
    LOWORD(v15) = 2;
    icu::UnicodeString::fromUTF8(a2, a3, (uint64_t)v13);
    __int128 v10 = (icu::UnicodeString *)(*(uint64_t (**)(void *, _BYTE *, void (***)(icu::UnicodeString *__hidden), uint64_t, int *))(*(void *)v9 + 48LL))( v9,  v13,  &v14,  a5,  a6);
    icu::UnicodeString::toUTF8(v10, a4);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v13);
    return icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v14);
  }

  return result;
}

uint64_t *icu::IDNA::createUTS46Instance(icu::IDNA *this, int *a2, UErrorCode *a3)
{
  uint64_t v3 = (uint64_t *)*a2;
  int v7 = (int)this;
  __int128 v8 = icu::UMemory::operator new(v3, (icu::UMemory *)0x18, (unint64_t)a2);
  int v4 = v8;
  if (!v8)
  {
    *a2 = 7;
    return v4;
  }

  uint64_t *v8 = (uint64_t)&off_18971C810;
  v8[1] = icu::Normalizer2::getInstance(0LL, "uts46", 0, a2);
  *((_DWORD *)v4 + 4) = v7;
  if (*a2 >= 1)
  {
    (*(void (**)(uint64_t *))(*v4 + 8))(v4);
    return 0LL;
  }

  return v4;
}

void sub_18088CC60(icu::UObject *a1)
{
}

icu::UnicodeString *sub_18088CC74(uint64_t a1, uint64_t a2, icu::UnicodeString *this, uint64_t a4, int *a5)
{
  return sub_18088CC8C(a1, a2, 1, 1u, this, a4, a5);
}

icu::UnicodeString *sub_18088CC8C( uint64_t a1, uint64_t a2, int a3, unsigned int a4, icu::UnicodeString *this, uint64_t a6, int *a7)
{
  if (*a7 >= 1) {
    goto LABEL_4;
  }
  __int16 v10 = *(_WORD *)(a2 + 8);
  if ((v10 & 0x11) != 0
    || ((v10 & 2) != 0 ? (__int128 v12 = (unsigned __int16 *)(a2 + 10)) : (__int128 v12 = *(unsigned __int16 **)(a2 + 24)),
        this == (icu::UnicodeString *)a2 || !v12))
  {
    *a7 = 1;
LABEL_4:
    icu::UnicodeString::setToBogus(this);
    return this;
  }

  if ((*((_WORD *)this + 4) & 1) != 0) {
    __int16 v14 = 2;
  }
  else {
    __int16 v14 = *((_WORD *)this + 4) & 0x1F;
  }
  *((_WORD *)this + 4) = v14;
  *(_WORD *)(a6 + 8) = 0;
  *(void *)a6 = 0LL;
  int v15 = 1;
  *(_BYTE *)(a6 + 10) = 1;
  unsigned int v16 = *(unsigned __int16 *)(a2 + 8);
  int v17 = (__int16)v16;
  unsigned int v18 = v16 >> 5;
  if (v17 >= 0) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = *(unsigned int *)(a2 + 12);
  }
  if (!(_DWORD)v19)
  {
LABEL_74:
    *(_DWORD *)a6 = v15;
    return this;
  }

  uint64_t Buffer = icu::UnicodeString::getBuffer(this, v19);
  if (!Buffer)
  {
    *a7 = 7;
    return this;
  }

  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  int v26 = *(_DWORD *)a6;
  int v27 = *(_DWORD *)(a6 + 4);
  int v28 = *(_DWORD *)(a1 + 16) & 2;
  int v29 = v12;
  while (1)
  {
    unsigned int v31 = *v29++;
    uint64_t v30 = v31;
    if (v31 > 0x7F)
    {
LABEL_57:
      uint64_t v38 = v25;
      goto LABEL_58;
    }

    if ((unint64_t)(v30 - 65) <= 0x19)
    {
      *(_WORD *)(Buffer + 2 * v24) = v30 + 32;
      goto LABEL_41;
    }

    if (byte_180A2CC38[v30] < 0 && v28) {
      goto LABEL_57;
    }
    *(_WORD *)(Buffer + 2 * v24) = v30;
    if ((_DWORD)v30 != 46) {
      break;
    }
    if (a3) {
      goto LABEL_68;
    }
    BOOL v32 = (int)v24 - (int)v25 <= 63 || a4 == 0;
    int v33 = v27 | (v24 == v25);
    if (!v32) {
      v33 |= 2u;
    }
    v26 |= v33;
    *(_DWORD *)(a6 + 4) = 0;
    uint64_t v25 = (v24 + 1);
    int v27 = 0;
LABEL_41:
    ++v24;
    __int128 v12 = v29;
    if (v19 == v24)
    {
      if (a4)
      {
        unsigned int v34 = v24 - 1;
        if ((int)v19 - (int)v25 >= 64)
        {
          v27 |= 2u;
          *(_DWORD *)(a6 + 4) = v27;
        }

        BOOL v35 = (int)v25 < 254 || v34 > 0xFD;
        int v36 = v26 | 4;
        if (!v35) {
          int v36 = v26;
        }
        if (v34 >= 0xFD) {
          int v37 = v36;
        }
        else {
          int v37 = v26;
        }
        if (!a3) {
          int v26 = v37;
        }
      }

      *(_DWORD *)a6 = v26 | v27;
      icu::UnicodeString::releaseBuffer((uint64_t)this, v19);
      return this;
    }
  }

  if ((_DWORD)v30 != 45) {
    goto LABEL_41;
  }
  if (v24 != (_DWORD)v25 + 3 || *(v12 - 1) != 45)
  {
    if (v24 == v25)
    {
      v27 |= 8u;
      *(_DWORD *)(a6 + 4) = v27;
    }

    if (v19 - 1 == v24 || v12[1] == 46)
    {
      v27 |= 0x10u;
      *(_DWORD *)(a6 + 4) = v27;
    }

    goto LABEL_41;
  }

icu::UnicodeString *sub_18088CFA0(uint64_t a1, uint64_t a2, icu::UnicodeString *this, uint64_t a4, int *a5)
{
  return sub_18088CC8C(a1, a2, 1, 0, this, a4, a5);
}

icu::UnicodeString *sub_18088CFB8(uint64_t a1, uint64_t a2, icu::UnicodeString *this, _DWORD *a4, int *a5)
{
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  int v8 = *((_DWORD *)this + 3);
  if ((v7 & 0x8000u) == 0) {
    int v9 = v7 >> 5;
  }
  else {
    int v9 = *((_DWORD *)this + 3);
  }
  if (v9 >= 254 && (*a4 & 4) == 0)
  {
    if ((v7 & 0x11) != 0)
    {
      __int16 v10 = 0LL;
    }

    else if ((v7 & 2) != 0)
    {
      __int16 v10 = (unsigned __int16 *)((char *)this + 10);
    }

    else
    {
      __int16 v10 = (unsigned __int16 *)*((void *)this + 3);
    }

    int v11 = &v10[v9];
    while (v10 < v11)
    {
      unsigned int v12 = *v10++;
      if (v12 > 0x7F) {
        return this;
      }
    }

    if ((v7 & 0x8000) != 0)
    {
      if (v8 > 254)
      {
LABEL_24:
        *a4 |= 4u;
        return this;
      }
    }

    else
    {
      int v8 = v7 >> 5;
      if (v7 >> 5 > 0xFE) {
        goto LABEL_24;
      }
    }

    int v13 = (v7 & 2) != 0 ? (icu::UnicodeString *)((char *)this + 10) : (icu::UnicodeString *)*((void *)this + 3);
    if (*((_WORD *)v13 + 253) != 46) {
      goto LABEL_24;
    }
  }

  return this;
}

icu::UnicodeString *sub_18088D0A4(uint64_t a1, uint64_t a2, icu::UnicodeString *this, uint64_t a4, int *a5)
{
  return sub_18088CC8C(a1, a2, 0, 0, this, a4, a5);
}

void *sub_18088D0BC(void *a1, const char *a2, uint64_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  return sub_18088D0D4(a1, a2, a3, 1, 1u, a4, a5, a6);
}

void *sub_18088D0D4( void *result, const char *a2, uint64_t a3, int a4, unsigned int a5, icu::ByteSink *a6, uint64_t a7, int *a8)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  v41[0] = a2;
  v41[1] = a3;
  if (*a8 <= 0)
  {
    uint64_t v15 = (uint64_t)result;
    if (a2 || !(_DWORD)a3)
    {
      *(_WORD *)(a7 + 8) = 0;
      *(void *)a7 = 0LL;
      *(_BYTE *)(a7 + 10) = 1;
      if ((_DWORD)a3)
      {
        __int128 v45 = 0u;
        uint64_t v48 = 0LL;
        __int128 v47 = 0u;
        __int128 v46 = 0u;
        __int128 v44 = off_18971B688;
        LOWORD(v45) = 2;
        if ((int)a3 > 256)
        {
          icu::UnicodeString::fromUTF8(a2, a3, (uint64_t)v43);
          sub_18088D630(v15, (icu::UnicodeString *)v43, 0LL, 0, a4, a5, (uint64_t)&v44, a7, a8);
          icu::UnicodeString::~UnicodeString(v27, (icu::UnicodeString *)v43);
          LODWORD(v19) = 0;
LABEL_42:
          icu::UnicodeString::toUTF8((icu::UnicodeString *)&v44, a6);
          if (!a4 && a5)
          {
            int v31 = (v45 & 0x8000u) == 0LL ? (unsigned __int16)v45 >> 5 : DWORD1(v45);
            if (v31 + (int)v19 >= 254)
            {
              if ((v45 & 0x11) != 0)
              {
                BOOL v32 = 0LL;
              }

              else if ((v45 & 2) != 0)
              {
                BOOL v32 = (unsigned __int16 *)&v45 + 1;
              }

              else
              {
                BOOL v32 = (unsigned __int16 *)v46;
              }

              int v33 = &v32[v31];
              while (v32 < v33)
              {
                unsigned int v34 = *v32++;
                if (v34 > 0x7F) {
                  goto LABEL_65;
                }
              }

              if (v31 + (int)v19 > 254
                || (int)v19 <= 253
                && (v31 <= (253 - v19)
                 || ((v45 & 2) != 0 ? (BOOL v35 = (char *)&v45 + 2) : (BOOL v35 = (char *)v46),
                     *(_WORD *)&v35[2 * (253 - v19)] != 46)))
              {
                *(_DWORD *)a7 |= 4u;
              }
            }
          }

void *sub_18088D5E8(void *a1, const char *a2, uint64_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  return sub_18088D0D4(a1, a2, a3, 1, 0, a4, a5, a6);
}

void *sub_18088D600(void *a1, const char *a2, uint64_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  return sub_18088D0D4(a1, a2, a3, 0, 1u, a4, a5, a6);
}

void *sub_18088D618(void *a1, const char *a2, uint64_t a3, icu::ByteSink *a4, uint64_t a5, int *a6)
{
  return sub_18088D0D4(a1, a2, a3, 0, 0, a4, a5, a6);
}

uint64_t sub_18088D630( uint64_t a1, icu::UnicodeString *this, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v15 = *(void *)(a1 + 8);
  if (a4)
  {
    icu::UnicodeString::tempSubString(this, a4, 0x7FFFFFFF, (icu::UnicodeString *)v35);
    (*(void (**)(uint64_t, uint64_t, _BYTE *, int *))(*(void *)v15 + 40LL))(v15, a7, v35, a9);
    icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v35);
  }

  else
  {
    (*(void (**)(void, icu::UnicodeString *, uint64_t, int *))(*(void *)v15 + 24LL))( *(void *)(a1 + 8),  this,  a7,  a9);
  }

  if (*a9 > 0) {
    return a7;
  }
  if (a6) {
    int v18 = 16;
  }
  else {
    int v18 = 32;
  }
  BOOL v34 = (*(_DWORD *)(a1 + 16) & v18) == 0;
  unsigned int v19 = *(unsigned __int16 *)(a7 + 8);
  if ((v19 & 0x11) != 0)
  {
    uint64_t v20 = 0LL;
  }

  else if ((v19 & 2) != 0)
  {
    uint64_t v20 = a7 + 10;
  }

  else
  {
    uint64_t v20 = *(void *)(a7 + 24);
  }

  int v21 = (__int16)v19;
  int v22 = v19 >> 5;
  if (v21 >= 0) {
    int v23 = v22;
  }
  else {
    int v23 = *(_DWORD *)(a7 + 12);
  }
  if (v23 <= (int)a3)
  {
    uint64_t v24 = a3;
    if (!(_DWORD)a3) {
      goto LABEL_58;
    }
    goto LABEL_57;
  }

  uint64_t v24 = a3;
  do
  {
    unsigned int v25 = *(unsigned __int16 *)(v20 + 2LL * (int)a3);
    if (a5 || v25 != 46)
    {
      if (v25 < 0xDF) {
        goto LABEL_52;
      }
      if (v25 > 0x200D || v25 >> 2 <= 0x802 && v25 != 962 && v25 != 223)
      {
        if ((v25 & 0xF800) == 0xD800)
        {
          if ((v25 & 0x400) == 0)
          {
            if ((_DWORD)a3 + 1 != v23)
            {
              int v31 = *(_WORD *)(v20 + 2 * ((int)a3 + 1LL)) & 0xFC00;
              int v32 = 56320;
              goto LABEL_43;
            }

            goto LABEL_44;
          }

          if ((_DWORD)a3 == (_DWORD)v24) {
            goto LABEL_44;
          }
          int v31 = *(_WORD *)(v20 + 2LL * (int)a3 - 2) & 0xFC00;
          int v32 = 55296;
LABEL_43:
          if (v31 != v32)
          {
LABEL_44:
            *(_DWORD *)(a8 + 4) |= 0x80u;
            icu::UnicodeString::setCharAt((icu::UnicodeString *)a7, a3, 65533);
            __int16 v33 = *(_WORD *)(a7 + 8);
            if ((v33 & 0x11) != 0)
            {
              uint64_t v20 = 0LL;
            }

            else if ((v33 & 2) != 0)
            {
              uint64_t v20 = a7 + 10;
            }

            else
            {
              uint64_t v20 = *(void *)(a7 + 24);
            }
          }
        }

BOOL sub_18088D998(uint64_t a1, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = 0LL;
    BOOL v3 = 0;
    int v4 = 0;
    while (1)
    {
      unsigned int v5 = *(unsigned __int16 *)(a1 + 2 * v2);
      if (v5 == 46)
      {
        if (v2 > v4)
        {
          int v6 = *(unsigned __int16 *)(a1 + 2 * v2 - 2);
          unsigned int v7 = v6 - 97;
          unsigned int v8 = v6 - 48;
          if (v7 >= 0x1A && v8 > 9) {
            return v3;
          }
        }

        int v4 = v2 + 1;
      }

      else if (v2 == v4)
      {
        if (v5 - 97 >= 0x1A) {
          return v3;
        }
      }

      else if (v5 <= 0x20 && (v5 > 0x1B || v5 - 9 < 5))
      {
        return v3;
      }

      BOOL v3 = ++v2 >= (unint64_t)a2;
      if (a2 == v2) {
        return v3;
      }
    }
  }

  return 1;
}

BOOL sub_18088DA3C(uint64_t a1, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = 0LL;
    BOOL v3 = 0;
    int v4 = 0;
    while (1)
    {
      int v5 = *(unsigned __int8 *)(a1 + v2);
      if (v5 == 46)
      {
        if (v2 > v4)
        {
          int v6 = *(unsigned __int8 *)(a1 + v2 - 1);
        }

        int v4 = v2 + 1;
      }

      else if (v2 == v4)
      {
        if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A) {
          return v3;
        }
      }

      else
      {
        int v8 = (char)v5;
        if ((char)v5 <= 32)
        {
          unsigned int v9 = v5 - 9;
          if (v8 > 27 || v9 < 5) {
            return v3;
          }
        }
      }

      BOOL v3 = ++v2 >= (unint64_t)a2;
      if (a2 == v2) {
        return v3;
      }
    }
  }

  return 1;
}

uint64_t sub_18088DAEC( uint64_t a1, void (***this)(icu::UnicodeString *__hidden this), uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, int *a7)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (*a7 > 0) {
    return 0LL;
  }
  uint64_t v7 = a4;
  uint64_t v12 = a1;
  int v13 = 0LL;
  __int128 v70 = 0u;
  uint64_t v73 = 0LL;
  __int128 v72 = 0u;
  __int128 v71 = 0u;
  unsigned int v69 = off_18971B688;
  LOWORD(v70) = 2;
  __int16 v14 = *((_WORD *)this + 4);
  if ((v14 & 0x11) == 0)
  {
    if ((v14 & 2) != 0) {
      int v13 = (void (**)(icu::UnicodeString *__hidden))((char *)this + 10);
    }
    else {
      int v13 = this[3];
    }
  }

  uint64_t v15 = (unsigned __int16 *)v13 + (int)a3;
  BOOL v16 = (int)a4 < 4;
  int v63 = (icu::UnicodeString *)this;
  if ((int)a4 < 4)
  {
    uint64_t v17 = a4;
    uint64_t v18 = a3;
    unsigned int v19 = this;
    if ((_DWORD)a4) {
      goto LABEL_9;
    }
LABEL_119:
    *(_DWORD *)(a6 + 4) |= 1u;
    __int128 v45 = (icu::UnicodeString *)this;
    uint64_t v46 = a3;
    uint64_t v47 = v7;
    uint64_t v48 = (uint64_t)v19;
    uint64_t v49 = 0LL;
    goto LABEL_120;
  }

  if (*v15 != 120 || v15[1] != 110 || v15[2] != 45 || v15[3] != 45)
  {
    BOOL v16 = 1;
    uint64_t v17 = a4;
    uint64_t v18 = a3;
    unsigned int v19 = this;
    goto LABEL_21;
  }

  BOOL v61 = (int)a4 < 4;
  if ((_DWORD)a4 == 4 || a4 >= 6 && v15[(a4 - 1)] == 45)
  {
    *(_DWORD *)(a6 + 4) |= 0x400u;
LABEL_19:
    int v20 = a3;
    uint64_t v21 = v7;
    int v22 = a5;
    goto LABEL_56;
  }

  uint64_t Buffer = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v69, -1);
  if (!Buffer) {
    goto LABEL_106;
  }
  LODWORD(v64) = 0;
  int v51 = v15 + 4;
  if ((v70 & 2) != 0) {
    int v52 = 27;
  }
  else {
    int v52 = DWORD2(v70);
  }
  int v53 = u_strFromPunycode(v51, (v7 - 4), Buffer, v52, 0LL, (int *)&v64);
  if ((_DWORD)v64 == 15)
  {
    icu::UnicodeString::releaseBuffer((uint64_t)&v69, 0);
    uint64_t v54 = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v69, v53);
    if (v54)
    {
      LODWORD(v64) = 0;
      if ((v70 & 2) != 0) {
        int v55 = 27;
      }
      else {
        int v55 = DWORD2(v70);
      }
      int v53 = u_strFromPunycode(v51, (v7 - 4), v54, v55, 0LL, (int *)&v64);
      goto LABEL_103;
    }

LABEL_106:
    uint64_t v36 = 7LL;
    *a7 = 7;
    goto LABEL_122;
  }

            void v8[2] = v66;
            uint64_t v101 = icu::TimeZoneFormat::createTimeZoneForOffset(TZDBTimeZoneNames, v65, v48, v49, v50, v51);
LABEL_175:
            icu::UnicodeString::~UnicodeString((void *)v53, (icu::UnicodeString *)v114);
            __int16 v31 = (uint64_t)v101;
LABEL_176:
            icu::UnicodeString::~UnicodeString((void *)v34, (icu::UnicodeString *)v119);
            goto LABEL_177;
          }

          int v13 = 1;
          goto LABEL_113;
        }

        int v52 = (UChar **)(v3 + 88);
      }

      else
      {
        int v52 = &v172;
      }

      icu::UnicodeString::operator=(v52, &v142);
      goto LABEL_106;
    }

    if ((v148 & 0x8000u) == 0LL) {
      uint64_t v30 = (unsigned __int16)v148 >> 5;
    }
    else {
      uint64_t v30 = DWORD1(v148);
    }
    if (!icu::UnicodeString::doCompare((uint64_t)&v147, 0, v30, (uint64_t)"D", 0, -1))
    {
      int v51 = &v152;
LABEL_111:
      icu::UnicodeString::operator=((UChar **)v51, &v142);
      goto LABEL_112;
    }

    if ((v148 & 0x8000u) == 0LL) {
      __int16 v31 = (unsigned __int16)v148 >> 5;
    }
    else {
      __int16 v31 = DWORD1(v148);
    }
    if (!icu::UnicodeString::doCompare((uint64_t)&v147, 0, v31, (uint64_t)"T", 0, -1))
    {
      int v51 = (void (***)(icu::UnicodeString *__hidden))&v157;
      goto LABEL_111;
    }

    if ((v148 & 0x8000u) == 0LL) {
      int v32 = (unsigned __int16)v148 >> 5;
    }
    else {
      int v32 = DWORD1(v148);
    }
    if (!icu::UnicodeString::doCompare((uint64_t)&v147, 0, v32, (uint64_t)L"TZOFFSETFROM", 0, -1))
    {
      int v51 = &v167;
      goto LABEL_111;
    }

    if ((v148 & 0x8000u) == 0LL) {
      int v33 = (unsigned __int16)v148 >> 5;
    }
    else {
      int v33 = DWORD1(v148);
    }
    if (!icu::UnicodeString::doCompare((uint64_t)&v147, 0, v33, (uint64_t)"T", 0, -1))
    {
      int v51 = &v162;
      goto LABEL_111;
    }

    if ((v148 & 0x8000u) == 0LL) {
      int v34 = (unsigned __int16)v148 >> 5;
    }
    else {
      int v34 = DWORD1(v148);
    }
    if (icu::UnicodeString::doCompare((uint64_t)&v147, 0, v34, (uint64_t)L"RDATE", 0, -1))
    {
      int v131 = L"RRULE";
      if (sub_1807C3C7C((uint64_t)&v147, (uint64_t *)&v131, -1))
      {
        int v130 = "E";
        uint64_t v36 = (unsigned __int16)v153 >> 5;
        if ((v153 & 0x8000u) != 0LL) {
          uint64_t v36 = DWORD1(v153);
        }
        if (v36)
        {
          int v37 = (unsigned __int16)v168 >> 5;
          if ((v168 & 0x8000u) != 0LL) {
            int v37 = DWORD1(v168);
          }
          if (v37)
          {
            BOOL v38 = (unsigned __int16)v163 >> 5;
            if ((v163 & 0x8000u) != 0LL) {
              BOOL v38 = DWORD1(v163);
            }
            if (v38)
            {
              uint64_t v39 = (unsigned __int16)v158 >> 5;
              if ((v158 & 0x8000u) != 0LL) {
                uint64_t v39 = DWORD1(v158);
              }
              if (!v39) {
                sub_1809D69E4(&v172, v120, &v157);
              }
              *(double *)&__int32 v137 = 0.0;
              int v40 = sub_1809D6B04((uint64_t)&v167, (int *)a2);
              int v41 = sub_1809D6B04((uint64_t)&v162, (int *)a2);
              if (*(int *)a2 < 1)
              {
                uint64_t v42 = v41;
                if (v120)
                {
                  int v43 = (int)v41 <= (int)v40 ? (v41 - 3600000) : v40;
                  uint64_t v44 = (int)v41 <= (int)v40 ? 3600000 : v41 - v40;
                }

                else
                {
                  uint64_t v44 = 0;
                  int v43 = v41;
                }

                v70.n128_f64[0] = sub_1809D676C((uint64_t)&v152, v40, (int *)a2);
                if (*(int *)a2 <= 0
                  && ((int v129 = 1.83882169e17, !v121)
                    ? (__int128 v71 = sub_1809D71E8(&v157, v43, v44, v134, v40, (int *)a2, v70.n128_f64[0]))
                    : (__int128 v71 = sub_1809D6C1C(&v157, v43, v44, (icu::UVector *)v134, v40, (int *)a2, v70.n128_f64[0])),
                      sub_1807C9194((uint64_t)&v137, (uint64_t)v71, (int *)a2),
                      *(int *)a2 <= 0))
                {
                  if ((*(unsigned int (**)(void *, uint64_t, void, double *))(*(void *)v137 + 56LL))( v137,  v40,  0LL,  &v129)
                    && v129 < v15)
                  {
                    uint64_t v73 = v44 < 1;
                    uint64_t v74 = (_DWORD)v40 - v42 == 3600000;
                    char v75 = !v73 || !v74;
                    if (v73 && v74) {
                      int v76 = v40 - 3600000;
                    }
                    else {
                      int v76 = v40;
                    }
                    if (v75) {
                      uint64_t v77 = 0;
                    }
                    else {
                      uint64_t v77 = 3600000;
                    }
                    v123 = __PAIR64__(v76, v77);
                    uint64_t v15 = v129;
                  }

                  uint64_t v78 = v137;
                  *(double *)&__int32 v137 = 0.0;
                  icu::UVector::adoptElement((icu::UVector *)v136, v78, a2);
                  __int128 v72 = *a2 > U_ZERO_ERROR;
                  int v13 = *(int *)a2 <= 0 ? 1 : 2;
                }

                else
                {
                  int v13 = 2;
                  __int128 v72 = 1;
                }

                if (!v72) {
                  goto LABEL_113;
                }
              }
            }
          }
        }
      }

      else
      {
        __int128 v67 = v121;
        if (v121 || (__int128 v67 = v134[2], !v134[2]))
        {
          uint64_t v68 = (icu::UnicodeString *)icu::UMemory::operator new((uint64_t *)v67, (icu::UMemory *)0x40, v35);
          unsigned int v69 = v68;
          if (v68)
          {
            icu::UnicodeString::UnicodeString(v68, &v142);
          }

          else if (*(int *)a2 <= 0)
          {
            *a2 = U_MEMORY_ALLOCATION_ERROR;
          }

          icu::UVector::adoptElement((icu::UVector *)v134, v69, a2);
          if (*(int *)a2 < 1)
          {
            int v13 = 2;
            int v121 = 1;
            goto LABEL_113;
          }
        }
      }

      goto LABEL_5;
    }

    if (v121) {
      goto LABEL_5;
    }
    int v58 = 0;
    unsigned int v59 = 1;
    while (v59)
    {
      if (v58 < 0)
      {
        BOOL v61 = 0;
        if ((v143 & 0x8000) != 0) {
          int32x2_t v60 = DWORD1(v143);
        }
        else {
          int32x2_t v60 = (unsigned __int16)v143 >> 5;
        }
      }

      else if ((v143 & 0x8000) != 0)
      {
        int32x2_t v60 = DWORD1(v143);
        if (SDWORD1(v143) >= v58) {
          BOOL v61 = v58;
        }
        else {
          BOOL v61 = DWORD1(v143);
        }
      }

      else
      {
        int32x2_t v60 = (unsigned __int16)v143 >> 5;
        if (v60 >= v58) {
          BOOL v61 = v58;
        }
        else {
          BOOL v61 = (unsigned __int16)v143 >> 5;
        }
      }

      BOOL v62 = icu::UnicodeString::doIndexOf((uint64_t)&v142, 0x2Cu, v61, v60 - v61);
      __int128 v65 = (icu::UnicodeString *)icu::UMemory::operator new(v64, (icu::UMemory *)0x40, v63);
      __int128 v66 = v65;
      if (v62 == -1)
      {
        if (v65)
        {
          icu::UnicodeString::UnicodeString(v65, (const icu::UnicodeString *)&v142, v58);
          if (*(int *)a2 > 0)
          {
            (*(void (**)(icu::UnicodeString *))(*(void *)v66 + 8LL))(v66);
            goto LABEL_155;
          }
        }

        else
        {
          if (*(int *)a2 <= 0)
          {
            __int128 v66 = 0LL;
            unsigned int v59 = 0;
            *a2 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_157;
          }

uint64_t sub_18088E254(uint64_t a1, icu::UnicodeString *this, unsigned int a3, unsigned int a4, int *a5)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (*a5 > 0) {
    return 0LL;
  }
  signed int v8 = a4;
  unsigned int v12 = *((unsigned __int16 *)this + 4);
  if ((v12 & 0x8000u) == 0) {
    uint64_t v5 = v12 >> 5;
  }
  else {
    uint64_t v5 = *((unsigned int *)this + 3);
  }
  if (v5 <= a4)
  {
    BOOL v14 = 0;
  }

  else
  {
    if ((v12 & 2) != 0) {
      int v13 = (char *)this + 10;
    }
    else {
      int v13 = (char *)*((void *)this + 3);
    }
    BOOL v14 = *(unsigned __int16 *)&v13[2 * a4] == 223;
  }

  uint64_t Buffer = icu::UnicodeString::getBuffer(this, v14 + (int)v5);
  if (!Buffer)
  {
LABEL_47:
    *a5 = 7;
    return v5;
  }

  uint64_t v16 = Buffer;
  uint64_t v31 = a1;
  unsigned int v32 = a3;
  int v17 = 0;
  if ((*((_WORD *)this + 4) & 2) != 0) {
    int v18 = 27;
  }
  else {
    int v18 = *((_DWORD *)this + 4);
  }
  int v19 = v8;
  do
  {
    signed int v20 = v8 + 1;
    int v21 = *(unsigned __int16 *)(v16 + 2LL * v8);
    if ((v21 - 8204) >= 2)
    {
      if (v21 == 962)
      {
        *(_WORD *)(v16 + 2LL * v19) = 963;
        int v24 = v19 + 1;
        int v17 = 1;
      }

      else
      {
        if (v21 == 223)
        {
          uint64_t v22 = v19 + 1LL;
          *(_WORD *)(v16 + 2LL * v19) = 115;
          if (v19 == v8)
          {
            if ((_DWORD)v5 == v18)
            {
              icu::UnicodeString::releaseBuffer((uint64_t)this, v5);
              uint64_t v23 = icu::UnicodeString::getBuffer(this, (int)v5 + 1);
              if (!v23) {
                goto LABEL_47;
              }
              uint64_t v16 = v23;
              if ((*((_WORD *)this + 4) & 2) != 0) {
                int v18 = 27;
              }
              else {
                int v18 = *((_DWORD *)this + 4);
              }
            }

            u_memmove((UChar *)(v16 + 2 * v22 + 2), (const UChar *)(v16 + 2 * v22), v5 - v22);
            signed int v20 = v8 + 2;
          }

          else
          {
            uint64_t v22 = (int)v22;
          }

          v19 += 2;
          *(_WORD *)(v16 + 2 * v22) = 115;
          uint64_t v5 = (v5 + 1);
          goto LABEL_34;
        }

        *(_WORD *)(v16 + 2LL * v19) = v21;
        int v24 = v19 + 1;
      }

      int v19 = v24;
      goto LABEL_35;
    }

    uint64_t v5 = (v5 - 1);
LABEL_34:
    int v17 = 1;
LABEL_35:
    signed int v8 = v20;
  }

  while (v19 < (int)v5);
  icu::UnicodeString::releaseBuffer((uint64_t)this, v5);
  if (v17)
  {
    __int128 v35 = 0u;
    uint64_t v38 = 0LL;
    __int128 v37 = 0u;
    __int128 v36 = 0u;
    int v34 = off_18971B688;
    LOWORD(v35) = 2;
    uint64_t v25 = *(void *)(v31 + 8);
    icu::UnicodeString::tempSubString(this, v32, 0x7FFFFFFF, (icu::UnicodeString *)v33);
    (*(void (**)(uint64_t, _BYTE *, void (***)(icu::UnicodeString *__hidden), int *))(*(void *)v25 + 24LL))( v25,  v33,  &v34,  a5);
    icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)v33);
    unint64_t v27 = *a5;
    if ((int)v27 <= 0)
    {
      if ((v35 & 0x8000u) == 0LL) {
        uint64_t v28 = (unsigned __int16)v35 >> 5;
      }
      else {
        uint64_t v28 = DWORD1(v35);
      }
      icu::UnicodeString::doReplace(this, v32, 0x7FFFFFFFLL, (const icu::UnicodeString *)&v34, 0, v28);
      unsigned int v29 = *((unsigned __int16 *)this + 4);
      if ((v29 & 1) != 0)
      {
        *a5 = 7;
        unsigned int v29 = *((unsigned __int16 *)this + 4);
      }

      int v30 = (__int16)v29;
      unint64_t v27 = v29 >> 5;
      if (v30 >= 0) {
        uint64_t v5 = v27;
      }
      else {
        uint64_t v5 = *((unsigned int *)this + 3);
      }
    }

    icu::UnicodeString::~UnicodeString((void *)v27, (icu::UnicodeString *)&v34);
  }

  return v5;
}

uint64_t sub_18088E544(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int *a7)
{
  if (*a7 > 0) {
    return 0LL;
  }
  uint64_t v7 = a4;
  __int16 v11 = *(_WORD *)(a2 + 8);
  if ((v11 & 0x11) != 0)
  {
    uint64_t v12 = 0LL;
  }

  else if ((v11 & 2) != 0)
  {
    uint64_t v12 = a2 + 10;
  }

  else
  {
    uint64_t v12 = *(void *)(a2 + 24);
  }

  if ((int)a4 < 5)
  {
LABEL_20:
    __int16 v22 = -3;
    icu::UnicodeString::doReplace(a2, (a4 + a3), 0LL, (uint64_t)&v22, 0, 1LL);
    if ((*(_WORD *)(a2 + 8) & 1) == 0) {
      return (v7 + 1);
    }
    uint64_t v7 = 0LL;
    *a7 = 7;
    return v7;
  }

  uint64_t v13 = v12 + 2LL * a3;
  unint64_t v14 = v13 + 2LL * (int)a4;
  uint64_t v15 = (_WORD *)(v13 + 8);
  int v16 = *(_DWORD *)(a6 + 4);
  int v17 = 1;
  int v18 = *(_DWORD *)(a1 + 16) & 2;
  int v19 = 1;
  do
  {
    uint64_t v20 = (unsigned __int16)*v15;
    if (v20 > 0x7F)
    {
      int v19 = 0;
      int v17 = 0;
      goto LABEL_18;
    }

    if ((_DWORD)v20 == 46)
    {
      v16 |= 0x200u;
      *(_DWORD *)(a6 + 4) = v16;
LABEL_17:
      int v19 = 0;
      int v17 = 0;
      *uint64_t v15 = -3;
      goto LABEL_18;
    }

    int v21 = byte_180A2CC38[v20];
    v17 &= ~(v21 >> 31);
    if (v21 < 0 && v18) {
      goto LABEL_17;
    }
LABEL_18:
    ++v15;
  }

  while ((unint64_t)v15 < v14);
  if (v17) {
    goto LABEL_20;
  }
  return v7;
}

uint64_t sub_18088E6A4(icu::UnicodeString *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  uint64_t v6 = a5;
  if ((icu::UnicodeString *)a4 != this)
  {
    unsigned int v10 = *(unsigned __int16 *)(a4 + 8);
    int v11 = (__int16)v10;
    unsigned int v12 = v10 >> 5;
    if (v11 >= 0) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = *(unsigned int *)(a4 + 12);
    }
    icu::UnicodeString::doReplace(this, a2, a3, (const icu::UnicodeString *)a4, 0, v13);
    if ((*((_WORD *)this + 4) & 1) != 0)
    {
      uint64_t v6 = 0LL;
      *a6 = 7;
    }
  }

  return v6;
}

uint64_t sub_18088E728(uint64_t a1, unsigned __int16 *a2, int a3, uint64_t a4)
{
  UChar32 v7 = *a2;
  if ((v7 & 0xFC00) == 0xD800)
  {
    UChar32 v7 = (v7 << 10) - 56613888 + a2[1];
    int v8 = 2;
  }

  else
  {
    int v8 = 1;
  }

  uint64_t result = u_charDirection(v7);
  int v10 = result;
  int v11 = 1 << result;
  if (((1 << result) & 0xFFFFDFFC) != 0) {
    *(_BYTE *)(a4 + 10) = 0;
  }
  do
  {
    if (v8 >= a3)
    {
      int v13 = v11;
      if (v10) {
        goto LABEL_12;
      }
      goto LABEL_14;
    }

    UChar32 v12 = a2[a3 - 1];
    if ((v12 & 0xFC00) == 0xDC00)
    {
      a3 -= 2;
      UChar32 v12 = v12 - 56613888 + (a2[a3] << 10);
    }

    else
    {
      --a3;
    }

    uint64_t result = u_charDirection(v12);
  }

  while ((_DWORD)result == 17);
  int v13 = 1 << result;
  if (v10)
  {
LABEL_12:
    int v14 = -8231;
    goto LABEL_15;
  }

BOOL sub_18088E8D8(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 < 1) {
    return 1;
  }
  unint64_t v6 = 0LL;
  BOOL v7 = 0;
  int v8 = 0;
  unint64_t v9 = a3;
  while (1)
  {
    int v10 = *(unsigned __int16 *)(a2 + 2 * v6);
    if (v10 != 8205) {
      break;
    }
    if (!v6) {
      return v7;
    }
    uint64_t v13 = a2 + 2 * v6;
    uint64_t v14 = *(unsigned __int16 *)(v13 - 2);
    if ((v14 & 0xFC00) == 0xDC00) {
      uint64_t v14 = (int)v14 - 56613888 + (*(unsigned __int16 *)(v13 - 4) << 10);
    }
LABEL_33:
    ++v6;
    ++v8;
    BOOL v7 = v6 >= v9;
    if (v6 == v9) {
      return v7;
    }
  }

  if (v10 != 8204) {
    goto LABEL_33;
  }
  if (!v6) {
    return v7;
  }
  uint64_t v11 = *(unsigned __int16 *)(a2 + 2 * v6 - 2);
  if ((v11 & 0xFC00) == 0xDC00)
  {
    LODWORD(v12) = v6 - 2;
    uint64_t v11 = (int)v11 - 56613888 + (*(unsigned __int16 *)(a2 + 2 * (v6 - 2)) << 10);
  }

  else
  {
    LODWORD(v12) = v8 - 1;
  }

  unsigned int v15 = v11;
  while (1)
  {
    int v16 = sub_18081435C(v15);
    if (v16 != 5) {
      break;
    }
    if (!(_DWORD)v12) {
      return v7;
    }
    uint64_t v17 = (int)v12;
    uint64_t v12 = (int)v12 - 1LL;
    unsigned int v15 = *(unsigned __int16 *)(a2 + 2 * v12);
    if ((v15 & 0xFC00) == 0xDC00)
    {
      LODWORD(v12) = v17 - 2;
      unsigned int v15 = v15 - 56613888 + (*(unsigned __int16 *)(a2 + 2 * (v17 - 2)) << 10);
    }
  }

  if ((v16 & 0xFFFFFFFE) == 2)
  {
    int v18 = v6 + 1;
    while (v18 != a3)
    {
      uint64_t v19 = v18 + 1LL;
      unsigned int v20 = *(unsigned __int16 *)(a2 + 2LL * v18);
      if ((v20 & 0xFC00) == 0xD800)
      {
        v18 += 2;
        unsigned int v20 = (v20 << 10) - 56613888 + *(unsigned __int16 *)(a2 + 2 * v19);
      }

      else
      {
        ++v18;
      }

      int v21 = sub_18081435C(v20);
      if (v21 != 5)
      {
        if (v21 == 2 || v21 == 4) {
          goto LABEL_33;
        }
        return v7;
      }
    }
  }

  return v7;
}

void sub_18088EAC8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v31 = (a3 - 1);
  if (a3 >= 1)
  {
    unint64_t v7 = 0LL;
    int v30 = 0;
    uint64_t v8 = a3;
    do
    {
      unsigned int v9 = *(unsigned __int16 *)(a2 + 2 * v7);
      if (v9 >= 0xB7)
      {
        if (v9 > 0x6F9)
        {
          if (v9 == 12539)
          {
            int v11 = 0;
            int v32 = 0;
            while (v11 < a3)
            {
              uint64_t v12 = v11 + 1LL;
              unsigned int v13 = *(unsigned __int16 *)(a2 + 2LL * v11);
              BOOL v14 = (v13 & 0xFC00) != 0xD800 || (_DWORD)v12 == a3;
              if (!v14)
              {
                int v15 = *(unsigned __int16 *)(a2 + 2 * v12);
                BOOL v16 = (v15 & 0xFC00) == 56320;
                int v17 = v11 + 2;
                unsigned int v18 = (v13 << 10) - 56613888 + v15;
                if (v16) {
                  unsigned int v13 = v18;
                }
                if (v16) {
                  LODWORD(v12) = v17;
                }
              }

              unsigned int Script = uscript_getScript(v13, &v32);
              BOOL v20 = Script > 0x16 || ((1 << Script) & 0x520000) == 0;
              int v11 = v12;
              if (!v20) {
                goto LABEL_51;
              }
            }

void uidna_close(UIDNA *idna)
{
  if (idna) {
    (*(void (**)(UIDNA *))(*(void *)idna + 8LL))(idna);
  }
}

int32_t uidna_labelToASCII( const UIDNA *idna, const UChar *label, int32_t length, UChar *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  uint64_t v9 = *(void *)&capacity;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!sub_18088EED8( (uint64_t)label,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  memset(v23, 0, sizeof(v23));
  unint64_t v21 = label;
  icu::UnicodeString::UnicodeString(v23, length >> 31, &v21);
  v17[1] = v21;
  memset(v22, 0, sizeof(v22));
  icu::UnicodeString::UnicodeString(v22, dest, 0LL, v9);
  int v20 = 0x10000;
  uint64_t v19 = 0LL;
  (*(void (**)(const UIDNA *, _OWORD *, _OWORD *, uint64_t *, UErrorCode *))(*(void *)idna + 24LL))( idna,  v23,  v22,  &v19,  pErrorCode);
  pInfo->isTransitionalDifferent = v20;
  pInfo->errors = v19;
  unsigned int v18 = dest;
  int32_t v14 = icu::UnicodeString::extract((uint64_t)v22, &v18, v9, (int *)pErrorCode);
  v17[0] = v18;
  icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v22);
  icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v23);
  return v14;
}

uint64_t sub_18088EED8(uint64_t a1, int a2, uint64_t a3, int a4, unsigned __int16 *a5, int *a6)
{
  if (*a6 > 0) {
    return 0LL;
  }
  if (a1)
  {
    if (a2 < -1) {
      goto LABEL_15;
    }
  }

  else if (a2)
  {
    goto LABEL_15;
  }

  if (a3)
  {
    if (a4 < 0) {
      goto LABEL_15;
    }
  }

  else if (a4)
  {
    goto LABEL_15;
  }

  if (!a1 || a3 != a1)
  {
    bzero(a5 + 1, *a5 - 2LL);
    return 1LL;
  }

int32_t uidna_labelToUnicode( const UIDNA *idna, const UChar *label, int32_t length, UChar *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  uint64_t v9 = *(void *)&capacity;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!sub_18088EED8( (uint64_t)label,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  memset(v23, 0, sizeof(v23));
  unint64_t v21 = label;
  icu::UnicodeString::UnicodeString(v23, length >> 31, &v21);
  v17[1] = v21;
  memset(v22, 0, sizeof(v22));
  icu::UnicodeString::UnicodeString(v22, dest, 0LL, v9);
  int v20 = 0x10000;
  uint64_t v19 = 0LL;
  (*(void (**)(const UIDNA *, _OWORD *, _OWORD *, uint64_t *, UErrorCode *))(*(void *)idna + 32LL))( idna,  v23,  v22,  &v19,  pErrorCode);
  pInfo->isTransitionalDifferent = v20;
  pInfo->errors = v19;
  unsigned int v18 = dest;
  int32_t v14 = icu::UnicodeString::extract((uint64_t)v22, &v18, v9, (int *)pErrorCode);
  v17[0] = v18;
  icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v22);
  icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v23);
  return v14;
}

int32_t uidna_nameToASCII( const UIDNA *idna, const UChar *name, int32_t length, UChar *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  uint64_t v9 = *(void *)&capacity;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!sub_18088EED8( (uint64_t)name,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  memset(v23, 0, sizeof(v23));
  unint64_t v21 = name;
  icu::UnicodeString::UnicodeString(v23, length >> 31, &v21);
  v17[1] = v21;
  memset(v22, 0, sizeof(v22));
  icu::UnicodeString::UnicodeString(v22, dest, 0LL, v9);
  int v20 = 0x10000;
  uint64_t v19 = 0LL;
  (*(void (**)(const UIDNA *, _OWORD *, _OWORD *, uint64_t *, UErrorCode *))(*(void *)idna + 40LL))( idna,  v23,  v22,  &v19,  pErrorCode);
  pInfo->isTransitionalDifferent = v20;
  pInfo->errors = v19;
  unsigned int v18 = dest;
  int32_t v14 = icu::UnicodeString::extract((uint64_t)v22, &v18, v9, (int *)pErrorCode);
  v17[0] = v18;
  icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v22);
  icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v23);
  return v14;
}

int32_t uidna_nameToUnicode( const UIDNA *idna, const UChar *name, int32_t length, UChar *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  uint64_t v9 = *(void *)&capacity;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!sub_18088EED8( (uint64_t)name,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  memset(v23, 0, sizeof(v23));
  unint64_t v21 = name;
  icu::UnicodeString::UnicodeString(v23, length >> 31, &v21);
  v17[1] = v21;
  memset(v22, 0, sizeof(v22));
  icu::UnicodeString::UnicodeString(v22, dest, 0LL, v9);
  int v20 = 0x10000;
  uint64_t v19 = 0LL;
  (*(void (**)(const UIDNA *, _OWORD *, _OWORD *, uint64_t *, UErrorCode *))(*(void *)idna + 48LL))( idna,  v23,  v22,  &v19,  pErrorCode);
  pInfo->isTransitionalDifferent = v20;
  pInfo->errors = v19;
  unsigned int v18 = dest;
  int32_t v14 = icu::UnicodeString::extract((uint64_t)v22, &v18, v9, (int *)pErrorCode);
  v17[0] = v18;
  icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v22);
  icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v23);
  return v14;
}

int32_t uidna_labelToASCII_UTF8( const UIDNA *idna, const char *label, int32_t length, char *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  unsigned int v11 = length;
  if (!sub_18088EED8( (uint64_t)label,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  if ((v11 & 0x80000000) != 0) {
    unsigned int v11 = strlen(label);
  }
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v18, dest, capacity);
  int v17 = 0x10000;
  uint64_t v16 = 0LL;
  (*(void (**)(const UIDNA *, const char *, void, __int128 *, uint64_t *, UErrorCode *))(*(void *)idna + 56LL))( idna,  label,  v11,  &v18,  &v16,  pErrorCode);
  pInfo->isTransitionalDifferent = v17;
  pInfo->errors = v16;
  int32_t v14 = u_terminateChars((uint64_t)dest, capacity, DWORD2(v19), (int *)pErrorCode);
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v18);
  return v14;
}

int32_t uidna_labelToUnicodeUTF8( const UIDNA *idna, const char *label, int32_t length, char *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  unsigned int v11 = length;
  if (!sub_18088EED8( (uint64_t)label,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  if ((v11 & 0x80000000) != 0) {
    unsigned int v11 = strlen(label);
  }
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v18, dest, capacity);
  int v17 = 0x10000;
  uint64_t v16 = 0LL;
  (*(void (**)(const UIDNA *, const char *, void, __int128 *, uint64_t *, UErrorCode *))(*(void *)idna + 64LL))( idna,  label,  v11,  &v18,  &v16,  pErrorCode);
  pInfo->isTransitionalDifferent = v17;
  pInfo->errors = v16;
  int32_t v14 = u_terminateChars((uint64_t)dest, capacity, DWORD2(v19), (int *)pErrorCode);
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v18);
  return v14;
}

int32_t uidna_nameToASCII_UTF8( const UIDNA *idna, const char *name, int32_t length, char *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  unsigned int v11 = length;
  if (!sub_18088EED8( (uint64_t)name,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  if ((v11 & 0x80000000) != 0) {
    unsigned int v11 = strlen(name);
  }
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v18, dest, capacity);
  int v17 = 0x10000;
  uint64_t v16 = 0LL;
  (*(void (**)(const UIDNA *, const char *, void, __int128 *, uint64_t *, UErrorCode *))(*(void *)idna + 72LL))( idna,  name,  v11,  &v18,  &v16,  pErrorCode);
  pInfo->isTransitionalDifferent = v17;
  pInfo->errors = v16;
  int32_t v14 = u_terminateChars((uint64_t)dest, capacity, DWORD2(v19), (int *)pErrorCode);
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v18);
  return v14;
}

int32_t uidna_nameToUnicodeUTF8( const UIDNA *idna, const char *name, int32_t length, char *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  unsigned int v11 = length;
  if (!sub_18088EED8( (uint64_t)name,  length,  (uint64_t)dest,  capacity,  (unsigned __int16 *)pInfo,  (int *)pErrorCode)) {
    return 0;
  }
  if ((v11 & 0x80000000) != 0) {
    unsigned int v11 = strlen(name);
  }
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v18, dest, capacity);
  int v17 = 0x10000;
  uint64_t v16 = 0LL;
  (*(void (**)(const UIDNA *, const char *, void, __int128 *, uint64_t *, UErrorCode *))(*(void *)idna + 80LL))( idna,  name,  v11,  &v18,  &v16,  pErrorCode);
  pInfo->isTransitionalDifferent = v17;
  pInfo->errors = v16;
  int32_t v14 = u_terminateChars((uint64_t)dest, capacity, DWORD2(v19), (int *)pErrorCode);
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v18);
  return v14;
}

const char *__cdecl u_errorName(UErrorCode code)
{
  if (code <= U_STANDARD_ERROR_LIMIT)
  {
    int v1 = &off_18971C900[code];
    return *v1;
  }

  unsigned __int32 v2 = code + 128;
  if ((code + 128) <= 8)
  {
    BOOL v3 = off_18971CA00;
LABEL_7:
    int v1 = &v3[v2];
    return *v1;
  }

  unsigned __int32 v2 = code - 0x10000;
  if ((code - 0x10000) <= 0x22)
  {
    BOOL v3 = off_18971CA48;
    goto LABEL_7;
  }

  unsigned __int32 v5 = code - 65792;
  if ((code - 65792) <= 0x13)
  {
    unint64_t v6 = off_18971CB60;
LABEL_17:
    int v1 = &v6[v5];
    return *v1;
  }

  if ((code - 66048) <= 0xD)
  {
    int v1 = &off_18971CC00[code - 66048];
    return *v1;
  }

  unsigned __int32 v5 = code - 66304;
  if ((code - 66304) <= 0x15)
  {
    unint64_t v6 = off_18971CC70;
    goto LABEL_17;
  }

  unsigned __int32 v5 = code - 66560;
  if ((code - 66560) <= 8)
  {
    unint64_t v6 = off_18971CD20;
    goto LABEL_17;
  }

  if (code >> 1 == 33408)
  {
    unsigned __int32 v2 = code - 66816;
    BOOL v3 = off_18971CD68;
    goto LABEL_7;
  }

  return "[BOGUS UErrorCode]";
}

void *icu::UVector::getStaticClassID(icu::UVector *this)
{
  return &unk_18C53519C;
}

void *icu::UVector::getDynamicClassID(icu::UVector *this)
{
  return &unk_18C53519C;
}

icu::UVector *icu::UVector::UVector(icu::UVector *this, UErrorCode *a2)
{
  *(void *)this = off_18971CD88;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  if (*(int *)a2 <= 0)
  {
    int v4 = uprv_malloc(0x40uLL);
    *((void *)this + 2) = v4;
    if (v4) {
      *((_DWORD *)this + 3) = 8;
    }
    else {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

{
  void *v4;
  *(void *)this = off_18971CD88;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  if (*(int *)a2 <= 0)
  {
    int v4 = uprv_malloc(0x40uLL);
    *((void *)this + 2) = v4;
    if (v4) {
      *((_DWORD *)this + 3) = 8;
    }
    else {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

  return this;
}

uint64_t icu::UVector::UVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int *a5)
{
  *(void *)a1 = off_18971CD88;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  if (*a5 <= 0)
  {
    if (a4 - 0x10000000 >= 0xF0000001) {
      unsigned int v7 = a4;
    }
    else {
      unsigned int v7 = 8;
    }
    uint64_t v8 = uprv_malloc(8LL * v7);
    *(void *)(a1 + 16) = v8;
    if (v8) {
      *(_DWORD *)(a1 + 12) = v7;
    }
    else {
      *a5 = 7;
    }
  }

  return a1;
}

uint64_t icu::UVector::UVector(icu::UVector *this, unsigned int a2, UErrorCode *a3)
{
  return icu::UVector::UVector((uint64_t)this, 0LL, 0LL, a2, (int *)a3);
}

{
  return icu::UVector::UVector((uint64_t)this, 0LL, 0LL, a2, (int *)a3);
}

uint64_t icu::UVector::UVector(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  *(void *)a1 = off_18971CD88;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  if (*a4 <= 0)
  {
    unint64_t v6 = uprv_malloc(0x40uLL);
    *(void *)(a1 + 16) = v6;
    if (v6) {
      *(_DWORD *)(a1 + 12) = 8;
    }
    else {
      *a4 = 7;
    }
  }

  return a1;
}

{
  void *v6;
  *(void *)a1 = off_18971CD88;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  if (*a4 <= 0)
  {
    unint64_t v6 = uprv_malloc(0x40uLL);
    *(void *)(a1 + 16) = v6;
    if (v6) {
      *(_DWORD *)(a1 + 12) = 8;
    }
    else {
      *a4 = 7;
    }
  }

  return a1;
}

void icu::UVector::~UVector(void **this)
{
  *this = off_18971CD88;
  icu::UVector::removeAllElements((uint64_t)this);
  uprv_free(this[2]);
  this[2] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  void *v1;
  icu::UVector::~UVector(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::UVector::removeAllElements(uint64_t this)
{
  uint64_t v1 = this;
  if (*(void *)(this + 24))
  {
    int v2 = *(_DWORD *)(this + 8);
    if (v2 >= 1)
    {
      for (uint64_t i = 0LL; i < v2; ++i)
      {
        this = *(void *)(*(void *)(v1 + 16) + 8 * i);
        if (this)
        {
          this = (*(uint64_t (**)(void))(v1 + 24))();
          int v2 = *(_DWORD *)(v1 + 8);
        }
      }
    }
  }

  *(_DWORD *)(v1 + 8) = 0;
  return this;
}

uint64_t icu::UVector::assign( icu::UVector *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), UErrorCode *a4)
{
  uint64_t result = icu::UVector::ensureCapacity(a1, *(_DWORD *)(a2 + 8), a4);
  if ((_DWORD)result)
  {
    uint64_t result = icu::UVector::setSize((uint64_t (**)(void))a1, *(_DWORD *)(a2 + 8), a4);
    if (*(int *)a4 <= 0 && *(_DWORD *)(a2 + 8) >= 1)
    {
      uint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
      do
      {
        uint64_t v12 = *((void *)a1 + 2);
        if (*(void *)(v12 + v10))
        {
          unsigned int v13 = (void (*)(void))*((void *)a1 + 3);
          if (v13)
          {
            v13();
            uint64_t v12 = *((void *)a1 + 2);
          }
        }

        uint64_t result = a3(v12 + v10, *(void *)(a2 + 16) + v10);
        ++v11;
        v10 += 8LL;
      }

      while (v11 < *(int *)(a2 + 8));
    }
  }

  return result;
}

uint64_t icu::UVector::ensureCapacity(icu::UVector *this, int a2, UErrorCode *a3)
{
  if (a2 < 0) {
    goto LABEL_10;
  }
  int v6 = *((_DWORD *)this + 3);
  if (v6 < a2)
  {
    if (v6 >= 0x40000000 || ((int v7 = 2 * v6, v7 <= a2) ? (v8 = a2) : (v8 = v7), v8 >> 28))
    {
LABEL_10:
      uint64_t result = 0LL;
      UErrorCode v9 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_11:
      *a3 = v9;
      return result;
    }

    uint64_t result = (uint64_t)uprv_realloc(*((void **)this + 2), 8LL * v8);
    if (!result)
    {
      UErrorCode v9 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_11;
    }

    *((void *)this + 2) = result;
    *((_DWORD *)this + 3) = v8;
  }

  return 1LL;
}

uint64_t icu::UVector::setSize(uint64_t (**this)(void), int a2, UErrorCode *a3)
{
  uint64_t result = icu::UVector::ensureCapacity((icu::UVector *)this, a2, a3);
  if ((_DWORD)result)
  {
    int v6 = *((_DWORD *)this + 2);
    BOOL v7 = v6 <= a2;
    if (v6 >= a2)
    {
      while (!v7)
      {
        uint64_t result = icu::UVector::orphanElementAt((icu::UVector *)this, --v6);
        if (result)
        {
          UErrorCode v9 = this[3];
          if (v9) {
            uint64_t result = v9();
          }
        }

        BOOL v7 = v6 <= a2;
      }
    }

    else
    {
      uint64_t v8 = v6;
      do
        *((void *)this[2] + v8++) = 0LL;
      while (a2 != v8);
    }

    *((_DWORD *)this + 2) = a2;
  }

  return result;
}

BOOL icu::UVector::operator==(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != *(_DWORD *)(a2 + 8)) {
    return 0LL;
  }
  if (*(void *)(a1 + 32)) {
    BOOL v4 = v2 < 1;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 1LL;
  }
  uint64_t v7 = 0LL;
  do
  {
    int v8 = (*(uint64_t (**)(void, void))(a1 + 32))( *(void *)(*(void *)(a1 + 16) + 8 * v7),  *(void *)(*(void *)(a2 + 16) + 8 * v7));
    BOOL result = v8 != 0;
    if (!v8) {
      break;
    }
    ++v7;
  }

  while (v7 < *(int *)(a1 + 8));
  return result;
}

uint64_t icu::UVector::addElement(icu::UVector *this, void *a2, UErrorCode *a3)
{
  uint64_t result = icu::UVector::ensureCapacity(this, *((_DWORD *)this + 2) + 1, a3);
  if ((_DWORD)result)
  {
    uint64_t v6 = *((void *)this + 2);
    uint64_t v7 = *((int *)this + 2);
    *((_DWORD *)this + 2) = v7 + 1;
    *(void *)(v6 + 8 * v7) = a2;
  }

  return result;
}

uint64_t icu::UVector::adoptElement(icu::UVector *this, void *a2, UErrorCode *a3)
{
  uint64_t result = icu::UVector::ensureCapacity(this, *((_DWORD *)this + 2) + 1, a3);
  if (!(_DWORD)result) {
    return (*((uint64_t (**)(void *))this + 3))(a2);
  }
  uint64_t v6 = *((void *)this + 2);
  uint64_t v7 = *((int *)this + 2);
  *((_DWORD *)this + 2) = v7 + 1;
  *(void *)(v6 + 8 * v7) = a2;
  return result;
}

uint64_t icu::UVector::addElement(icu::UVector *this, int a2, UErrorCode *a3)
{
  uint64_t result = icu::UVector::ensureCapacity(this, *((_DWORD *)this + 2) + 1, a3);
  if ((_DWORD)result)
  {
    *(void *)(*((void *)this + 2) + 8LL * *((int *)this + 2)) = 0LL;
    *(_DWORD *)(*((void *)this + 2) + 8LL * (int)(*((_DWORD *)this + 2))++) = a2;
  }

  return result;
}

uint64_t icu::UVector::setElementAt(uint64_t this, void *a2, unsigned int a3)
{
  uint64_t v4 = this;
  if ((a3 & 0x80000000) != 0 || *(_DWORD *)(this + 8) <= (signed int)a3)
  {
    int v8 = *(uint64_t (**)(void *))(this + 24);
    if (v8) {
      return v8(a2);
    }
  }

  else
  {
    uint64_t v5 = *(void *)(this + 16);
    uint64_t v6 = a3;
    this = *(void *)(v5 + 8LL * a3);
    if (this)
    {
      uint64_t v7 = *(uint64_t (**)(void))(v4 + 24);
      if (v7)
      {
        this = v7();
        uint64_t v5 = *(void *)(v4 + 16);
      }
    }

    *(void *)(v5 + 8 * v6) = a2;
  }

  return this;
}

uint64_t icu::UVector::setElementAt(uint64_t this, int a2, unsigned int a3)
{
  if ((a3 & 0x80000000) == 0 && *(_DWORD *)(this + 8) > (signed int)a3)
  {
    *(void *)(*(void *)(this + 16) + 8LL * a3) = 0LL;
    *(_DWORD *)(*(void *)(this + 16) + 8LL * a3) = a2;
  }

  return this;
}

uint64_t icu::UVector::insertElementAt( uint64_t (**this)(void *), void *a2, signed int a3, UErrorCode *a4)
{
  uint64_t result = icu::UVector::ensureCapacity((icu::UVector *)this, *((_DWORD *)this + 2) + 1, a4);
  if (!(_DWORD)result) {
    goto LABEL_8;
  }
  if ((a3 & 0x80000000) == 0)
  {
    signed int v9 = *((_DWORD *)this + 2);
    if (v9 >= a3)
    {
      for (; v9 > a3; --v9)
        *((void *)this[2] + v9) = *((void *)this[2] + (v9 - 1));
      *((void *)this[2] + a3) = a2;
      ++*((_DWORD *)this + 2);
LABEL_8:
      goto LABEL_9;
    }
  }

  *a4 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_9:
  uint64_t v10 = this[3];
  if (v10) {
    return v10(a2);
  }
  return result;
}

uint64_t icu::UVector::insertElementAt(icu::UVector *this, int a2, unsigned int a3, UErrorCode *a4)
{
  uint64_t result = icu::UVector::ensureCapacity(this, *((_DWORD *)this + 2) + 1, a4);
  if ((_DWORD)result)
  {
    if ((a3 & 0x80000000) != 0 || (signed int v9 = *((_DWORD *)this + 2), v9 < (int)a3))
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      for (; v9 > (int)a3; --v9)
      *(void *)(*((void *)this + 2) + 8LL * a3) = 0LL;
      *(_DWORD *)(*((void *)this + 2) + 8LL * a3) = a2;
      ++*((_DWORD *)this + 2);
    }
  }

  return result;
}

uint64_t icu::UVector::elementAt(icu::UVector *this, unsigned int a2)
{
  else {
    return *(void *)(*((void *)this + 2) + 8LL * a2);
  }
}

uint64_t icu::UVector::elementAti(icu::UVector *this, unsigned int a2)
{
  else {
    return *(unsigned int *)(*((void *)this + 2) + 8LL * a2);
  }
}

BOOL icu::UVector::containsAll(icu::UVector *this, const icu::UVector *a2)
{
  uint64_t v4 = 0LL;
  do
  {
    int v5 = icu::UVector::indexOf((uint64_t)this, *(void *)(*((void *)a2 + 2) + 8 * v4), 0LL, 0);
    BOOL result = v5 >= 0;
    if (v5 < 0) {
      break;
    }
    ++v4;
  }

  while (v4 < *((int *)a2 + 2));
  return result;
}

uint64_t icu::UVector::indexOf(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (!*(void *)(a1 + 32))
  {
    int v7 = *(_DWORD *)(a1 + 8);
    if (v7 > (int)a3)
    {
      int v8 = (void *)(*(void *)(a1 + 16) + 8LL * (int)a3);
      do
      {
        if ((a4 & 1) != 0)
        {
          if (*v8 == a2) {
            return a3;
          }
        }

        else if (*(_DWORD *)v8 == (_DWORD)a2)
        {
          return a3;
        }

        a3 = (a3 + 1);
        ++v8;
      }

      while (v7 != (_DWORD)a3);
    }

    return 0xFFFFFFFFLL;
  }

  uint64_t v6 = (int)a3;
  while (!(*(unsigned int (**)(uint64_t, void))(a1 + 32))(a2, *(void *)(*(void *)(a1 + 16) + 8 * v6)))
  {
  }

  return v6;
}

uint64_t icu::UVector::containsNone(icu::UVector *this, const icu::UVector *a2)
{
  uint64_t v4 = 0LL;
  do
  {
    unsigned int v5 = icu::UVector::indexOf((uint64_t)this, *(void *)(*((void *)a2 + 2) + 8 * v4), 0LL, 0);
    uint64_t result = v5 >> 31;
    if ((v5 & 0x80000000) == 0) {
      break;
    }
    ++v4;
  }

  while (v4 < *((int *)a2 + 2));
  return result;
}

uint64_t icu::UVector::removeAll(icu::UVector *this, const icu::UVector *a2)
{
  if (*((int *)a2 + 2) < 1)
  {
    return 0;
  }

  else
  {
    uint64_t v4 = 0LL;
    char v5 = 0;
    do
    {
      int v6 = icu::UVector::indexOf((uint64_t)this, *(void *)(*((void *)a2 + 2) + 8 * v4), 0LL, 0);
      if ((v6 & 0x80000000) == 0)
      {
        if (icu::UVector::orphanElementAt(this, v6))
        {
          int v7 = (void (*)(void))*((void *)this + 3);
          if (v7) {
            v7();
          }
        }

        char v5 = 1;
      }

      ++v4;
    }

    while (v4 < *((int *)a2 + 2));
  }

  return v5;
}

uint64_t icu::UVector::removeElementAt(uint64_t (**this)(void), int a2)
{
  uint64_t result = icu::UVector::orphanElementAt((icu::UVector *)this, a2);
  if (result)
  {
    uint64_t v4 = this[3];
    if (v4) {
      return v4();
    }
  }

  return result;
}

uint64_t icu::UVector::retainAll(icu::UVector *this, const icu::UVector *a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if ((int)v2 < 1)
  {
    return 0;
  }

  else
  {
    char v5 = 0;
    uint64_t v6 = v2 + 1;
    unsigned int v7 = v2 - 1;
    do
    {
      if ((icu::UVector::indexOf((uint64_t)a2, *(void *)(*((void *)this + 2) + 8LL * v7), 0LL, 0) & 0x80000000) != 0)
      {
        if (icu::UVector::orphanElementAt(this, v7))
        {
          int v8 = (void (*)(void))*((void *)this + 3);
          if (v8) {
            v8();
          }
        }

        char v5 = 1;
      }

      --v6;
      --v7;
    }

    while (v6 > 1);
  }

  return v5;
}

uint64_t icu::UVector::orphanElementAt(icu::UVector *this, int a2)
{
  if (a2 < 0) {
    return 0LL;
  }
  int v3 = *((_DWORD *)this + 2);
  if (v3 <= a2) {
    return 0LL;
  }
  uint64_t result = *(void *)(*((void *)this + 2) + 8LL * a2);
  LODWORD(v5) = v3 - 1;
  if ((int)v5 > a2)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)(*((void *)this + 2) + 8 * v6) = *(void *)(*((void *)this + 2) + 8 * v6 + 8);
      uint64_t v5 = *((int *)this + 2) - 1LL;
      ++v6;
    }

    while (v6 < v5);
  }

  *((_DWORD *)this + 2) = v5;
  return result;
}

uint64_t icu::UVector::removeElement(icu::UVector *this, uint64_t a2)
{
  int v3 = icu::UVector::indexOf((uint64_t)this, a2, 0LL, 1);
  if (v3 < 0) {
    return 0LL;
  }
  if (icu::UVector::orphanElementAt(this, v3))
  {
    uint64_t v4 = (void (*)(void))*((void *)this + 3);
    if (v4) {
      v4();
    }
  }

  return 1LL;
}

uint64_t icu::UVector::indexOf(icu::UVector *this, uint64_t a2, uint64_t a3)
{
  return icu::UVector::indexOf((uint64_t)this, a2, a3, 1);
}

uint64_t icu::UVector::equals(icu::UVector *this, const icu::UVector *a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if ((_DWORD)v2 != *((_DWORD *)a2 + 2)) {
    return 0LL;
  }
  if (!*((void *)this + 4))
  {
    int v8 = (void *)*((void *)this + 2);
    for (uint64_t i = (void *)*((void *)a2 + 2); *v8 == *i; ++i)
    {
      ++v8;
      if (!--v2) {
        return 1LL;
      }
    }

    return 0LL;
  }

  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  while (1)
  {
    uint64_t result = (*((uint64_t (**)(uint64_t, void))this + 4))( v5 + *((void *)a2 + 2),  *(void *)(*((void *)this + 2) + v5));
    if (!(_DWORD)result) {
      break;
    }
    ++v6;
    v5 += 8LL;
  }

  return result;
}

uint64_t icu::UVector::indexOf(icu::UVector *this, unsigned int a2, uint64_t a3)
{
  return icu::UVector::indexOf((uint64_t)this, a2, a3, 0);
}

void **icu::UVector::toArray(icu::UVector *this, void **a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if ((int)v2 >= 1)
  {
    unint64_t v3 = 0LL;
    uint64_t v4 = 8 * v2;
    do
    {
      a2[v3 / 8] = *(void **)(*((void *)this + 2) + v3);
      v3 += 8LL;
    }

    while (v4 != v3);
  }

  return a2;
}

uint64_t icu::UVector::setDeleter(icu::UVector *this, void (*a2)(void *))
{
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = a2;
  return v2;
}

uint64_t icu::UVector::setComparer(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = a2;
  return v2;
}

uint64_t icu::UVector::sortedInsert( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, uint64_t), UErrorCode *a4)
{
  uint64_t result = icu::UVector::ensureCapacity((icu::UVector *)a1, *(_DWORD *)(a1 + 8) + 1, a4);
  if ((_DWORD)result)
  {
    int v8 = *(_DWORD *)(a1 + 8);
    if (!v8) {
      goto LABEL_14;
    }
    int v9 = 0;
    do
    {
      int v10 = v9 + v8;
      if (v9 + v8 < 0 != __OFADD__(v9, v8)) {
        ++v10;
      }
      int v11 = v10 >> 1;
      uint64_t result = a3(*(void *)(*(void *)(a1 + 16) + 8LL * (v10 >> 1)), a2);
      else {
        int v8 = v11;
      }
    }

    while (v9 != v8);
    uint64_t v12 = *(int *)(a1 + 8);
    if ((int)v12 > v8)
    {
      uint64_t v13 = v8;
      do
      {
        *(void *)(*(void *)(a1 + 16) + 8 * v12) = *(void *)(*(void *)(a1 + 16) + 8 * v12 - 8);
        --v12;
      }

      while (v12 > v8);
    }

    else
    {
LABEL_14:
      uint64_t v13 = v8;
    }

    *(void *)(*(void *)(a1 + 16) + 8 * v13) = a2;
    ++*(_DWORD *)(a1 + 8);
  }

  else
  {
    int32_t v14 = *(uint64_t (**)(uint64_t))(a1 + 24);
    if (v14) {
      return v14(a2);
    }
  }

  return result;
}

uint64_t icu::UVector::sortedInsert( uint64_t a1, unsigned int a2, uint64_t (*a3)(void, uint64_t), UErrorCode *a4)
{
  return icu::UVector::sortedInsert(a1, a2, a3, a4);
}

void icu::UVector::sorti(icu::UVector *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0) {
    uprv_sortArray( *((void *)this + 2),  *((unsigned int *)this + 2),  8,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_1808907F0,  0LL,  0,  (int *)a2);
  }
}

uint64_t sub_1808907F0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (*a2 < *a3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 != *a3;
  }
}

void icu::UVector::sort(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v3 = a2;
  if (*a3 <= 0) {
    uprv_sortArray( *(void *)(a1 + 16),  *(unsigned int *)(a1 + 8),  8,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_180890858,  (uint64_t)&v3,  0,  a3);
  }
}

uint64_t sub_180890858(uint64_t (**a1)(void, void), void *a2, void *a3)
{
  return (*a1)(*a2, *a3);
}

void icu::UVector::sortWithUComparator( icu::UVector *this, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3, UErrorCode *a4)
{
}

void *icu::UVector32::getStaticClassID(icu::UVector32 *this)
{
  return &unk_18C53519D;
}

void *icu::UVector32::getDynamicClassID(icu::UVector32 *this)
{
  return &unk_18C53519D;
}

icu::UVector32 *icu::UVector32::UVector32(icu::UVector32 *this, UErrorCode *a2)
{
  *(void *)this = off_18971CDC8;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector32::_init(this, 8, a2);
  return this;
}

{
  *(void *)this = off_18971CDC8;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector32::_init(this, 8, a2);
  return this;
}

void *icu::UVector32::_init(icu::UVector32 *this, int a2, UErrorCode *a3)
{
  if (a2 >= 1) {
    int v5 = a2;
  }
  else {
    int v5 = 8;
  }
  int v6 = *((_DWORD *)this + 4);
  if (v6 >= v5 || v6 <= 0) {
    int v8 = v5;
  }
  else {
    int v8 = *((_DWORD *)this + 4);
  }
  if (v8 >= 0x20000000) {
    int v8 = uprv_min(8LL, v6);
  }
  uint64_t result = uprv_malloc(4LL * v8);
  *((void *)this + 3) = result;
  if (result) {
    *((_DWORD *)this + 3) = v8;
  }
  else {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
  return result;
}

icu::UVector32 *icu::UVector32::UVector32(icu::UVector32 *this, int a2, UErrorCode *a3)
{
  *(void *)this = off_18971CDC8;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector32::_init(this, a2, a3);
  return this;
}

{
  *(void *)this = off_18971CDC8;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector32::_init(this, a2, a3);
  return this;
}

void icu::UVector32::~UVector32(void **this)
{
  *this = off_18971CDC8;
  uprv_free(this[3]);
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  *this = off_18971CDC8;
  uprv_free(this[3]);
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  void *v2;
  *this = off_18971CDC8;
  uprv_free(this[3]);
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
  icu::UMemory::operator delete(v2);
}

void icu::UVector32::assign(icu::UVector32 *this, const icu::UVector32 *a2, UErrorCode *a3)
{
  int v5 = *((_DWORD *)a2 + 2);
  if (v5 < 0 || *((_DWORD *)this + 3) < v5)
  {
    int v5 = *((_DWORD *)a2 + 2);
  }

  icu::UVector32::setSize(this, v5);
  if (*((int *)a2 + 2) >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *((void *)a2 + 3);
    uint64_t v8 = *((void *)this + 3);
    do
    {
      *(_DWORD *)(v8 + 4 * v6) = *(_DWORD *)(v7 + 4 * v6);
      ++v6;
    }

    while (v6 < *((int *)a2 + 2));
  }

void icu::UVector32::setSize(icu::UVector32 *this, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    int v4 = *((_DWORD *)this + 2);
    if (v4 < a2)
    {
      UErrorCode v5 = U_ZERO_ERROR;
      if (*((_DWORD *)this + 3) < a2)
      {
        int v4 = *((_DWORD *)this + 2);
      }

      if (v4 < a2) {
        bzero((void *)(*((void *)this + 3) + 4LL * v4), 4LL * (~v4 + a2) + 4);
      }
    }

    *((_DWORD *)this + 2) = a2;
  }

BOOL icu::UVector32::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2 != *(_DWORD *)(a2 + 8)) {
    return 0LL;
  }
  uint64_t v3 = *(int **)(a1 + 24);
  int v4 = *(int **)(a2 + 24);
  uint64_t v5 = v2 - 1;
  do
  {
    int v7 = *v3++;
    int v6 = v7;
    int v9 = *v4++;
    int v8 = v9;
    BOOL v11 = v5-- != 0;
    BOOL result = v6 == v8;
  }

  while (v6 == v8 && v11);
  return result;
}

uint64_t icu::UVector32::setElementAt(uint64_t this, int a2, unsigned int a3)
{
  return this;
}

_DWORD *icu::UVector32::insertElementAt(_DWORD *this, int a2, signed int a3, UErrorCode *a4)
{
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v5 = this;
    signed int v6 = this[2];
    if (v6 >= a3)
    {
      if (this[3] <= v6)
      {
        this = (_DWORD *)icu::UVector32::expandCapacity((icu::UVector32 *)this, v6 + 1, a4);
        if (!(_DWORD)this) {
          return this;
        }
        signed int v6 = v5[2];
      }

      for (uint64_t i = *((void *)v5 + 3); v6 > a3; --v6)
        *(_DWORD *)(i + 4LL * v6) = *(_DWORD *)(i + 4LL * (v6 - 1));
      *(_DWORD *)(i + 4LL * a3) = a2;
      ++v5[2];
    }
  }

  return this;
}

BOOL icu::UVector32::containsAll(icu::UVector32 *this, const icu::UVector32 *a2)
{
  unint64_t v2 = *((unsigned int *)a2 + 2);
  if ((int)v2 < 1)
  {
    return 1;
  }

  else
  {
    uint64_t v3 = 0LL;
    BOOL v4 = 0;
    uint64_t v5 = *((unsigned int *)this + 2);
    while ((int)v5 >= 1)
    {
      uint64_t v6 = 0LL;
      while (*(_DWORD *)(*((void *)this + 3) + 4 * v6) != *(_DWORD *)(*((void *)a2 + 3) + 4 * v3))
      {
        if (v5 == ++v6) {
          return v4;
        }
      }

      if ((v6 & 0x80000000) == 0)
      {
        BOOL v4 = ++v3 >= v2;
        if (v3 != v2) {
          continue;
        }
      }

      return v4;
    }

    return 0;
  }

uint64_t icu::UVector32::indexOf(icu::UVector32 *this, int a2, uint64_t a3)
{
  int v3 = *((_DWORD *)this + 2);
  BOOL v4 = (int *)(*((void *)this + 3) + 4LL * (int)a3);
  while (1)
  {
    int v5 = *v4++;
    if (v5 == a2) {
      break;
    }
    a3 = (a3 + 1);
    if (v3 == (_DWORD)a3) {
      return 0xFFFFFFFFLL;
    }
  }

  return a3;
}

BOOL icu::UVector32::containsNone(icu::UVector32 *this, const icu::UVector32 *a2)
{
  unint64_t v2 = *((unsigned int *)a2 + 2);
  if ((int)v2 < 1)
  {
    return 1;
  }

  else
  {
    uint64_t v3 = 0LL;
    BOOL v4 = 0;
    uint64_t v5 = *((unsigned int *)this + 2);
    do
    {
      if ((int)v5 >= 1)
      {
        uint64_t v6 = 0LL;
        while (*(_DWORD *)(*((void *)this + 3) + 4 * v6) != *(_DWORD *)(*((void *)a2 + 3) + 4 * v3))
        {
          if (v5 == ++v6) {
            goto LABEL_9;
          }
        }

        if ((v6 & 0x80000000) == 0) {
          break;
        }
      }

uint64_t icu::UVector32::removeAll(icu::UVector32 *this, const icu::UVector32 *a2)
{
  int v2 = *((_DWORD *)a2 + 2);
  if (v2 < 1)
  {
    return 0;
  }

  else
  {
    uint64_t v3 = 0LL;
    char v4 = 0;
    uint64_t v5 = *((void *)a2 + 3);
    LODWORD(v6) = *((_DWORD *)this + 2);
    do
    {
      int v7 = v6;
      if ((int)v6 > 0)
      {
        uint64_t v8 = 0LL;
        uint64_t v9 = *((void *)this + 3);
        while (*(_DWORD *)(v9 + 4 * v8) != *(_DWORD *)(v5 + 4 * v3))
        {
        }

        if ((v8 & 0x80000000) == 0)
        {
          LODWORD(v6) = v6 - 1;
          if (v7 - 1 > (int)v8)
          {
            do
            {
              *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(v9 + 4 * v8 + 4);
              uint64_t v6 = *((int *)this + 2) - 1LL;
              ++v8;
            }

            while (v8 < v6);
          }

          *((_DWORD *)this + 2) = v6;
          int v2 = *((_DWORD *)a2 + 2);
          char v4 = 1;
        }
      }

uint64_t icu::UVector32::removeElementAt(uint64_t this, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    LODWORD(v2) = *(_DWORD *)(this + 8) - 1;
    if ((int)v2 > a2)
    {
      uint64_t v3 = *(void *)(this + 24);
      uint64_t v4 = a2;
      do
      {
        *(_DWORD *)(v3 + 4 * v4) = *(_DWORD *)(v3 + 4 * v4 + 4);
        uint64_t v2 = *(int *)(this + 8) - 1LL;
        ++v4;
      }

      while (v4 < v2);
    }

    *(_DWORD *)(this + 8) = v2;
  }

  return this;
}

uint64_t icu::UVector32::retainAll(icu::UVector32 *this, const icu::UVector32 *a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if ((int)v2 < 1)
  {
    return 0;
  }

  else
  {
    char v3 = 0;
    uint64_t v4 = *((void *)this + 3);
    uint64_t v5 = *((void *)a2 + 3);
    LODWORD(v6) = *((_DWORD *)this + 2);
    LODWORD(v7) = v6;
    do
    {
      uint64_t v7 = (v7 - 1);
      uint64_t v8 = *((unsigned int *)a2 + 2);
      uint64_t v9 = 0LL;
      while (*(_DWORD *)(v5 + 4 * v9) != *(_DWORD *)(v4 + 4LL * v7))
      {
        if (v8 == ++v9) {
          goto LABEL_9;
        }
      }

      if ((v9 & 0x80000000) != 0)
      {
LABEL_9:
        if (v2 >= (int)v6)
        {
          LODWORD(v6) = v6 - 1;
        }

        else
        {
          uint64_t v10 = v7;
          do
          {
            *(_DWORD *)(v4 + 4 * v10) = *(_DWORD *)(v4 + 4 * v10 + 4);
            uint64_t v6 = *((int *)this + 2) - 1LL;
            ++v10;
          }

          while (v10 < v6);
        }

        *((_DWORD *)this + 2) = v6;
        char v3 = 1;
      }
    }

    while (v2-- > 1);
  }

  return v3;
}

uint64_t icu::UVector32::removeAllElements(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  return this;
}

uint64_t icu::UVector32::equals(icu::UVector32 *this, const icu::UVector32 *a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if ((_DWORD)v2 == *((_DWORD *)a2 + 2))
  {
    char v3 = (int *)*((void *)this + 3);
    uint64_t v4 = (int *)*((void *)a2 + 3);
    while (1)
    {
      int v6 = *v3++;
      int v5 = v6;
      int v7 = *v4++;
      if (v5 != v7) {
        break;
      }
      if (!--v2) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

uint64_t icu::UVector32::expandCapacity(icu::UVector32 *this, int a2, UErrorCode *a3)
{
  if (a2 < 0) {
    goto LABEL_19;
  }
  int v6 = *((_DWORD *)this + 3);
  if (v6 < a2)
  {
    int v7 = *((_DWORD *)this + 4);
    if (v7 >= 1 && v7 < a2)
    {
      uint64_t result = 0LL;
      UErrorCode v12 = U_BUFFER_OVERFLOW_ERROR;
      goto LABEL_21;
    }

    if (v6 >= 0x40000000) {
      goto LABEL_19;
    }
    int v9 = 2 * v6;
    if (v9 <= a2) {
      int v9 = a2;
    }
    BOOL v10 = v9 <= v7 || v7 <= 0;
    int v11 = v10 ? v9 : *((_DWORD *)this + 4);
    if (v11 >= 0x20000000)
    {
LABEL_19:
      uint64_t result = 0LL;
      UErrorCode v12 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_21:
      *a3 = v12;
      return result;
    }

    uint64_t result = (uint64_t)uprv_realloc(*((void **)this + 3), 4LL * v11);
    if (!result)
    {
      UErrorCode v12 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_21;
    }

    *((void *)this + 3) = result;
    *((_DWORD *)this + 3) = v11;
  }

  return 1LL;
}

void *icu::UVector32::setMaxCapacity(void *this, int a2)
{
  int v2 = a2 & ~(a2 >> 31);
  if (!(v2 >> 29))
  {
    uint64_t v3 = (uint64_t)this;
    *((_DWORD *)this + 4) = v2;
    if (a2 >= 1 && *((_DWORD *)this + 3) > v2)
    {
      this = uprv_realloc(*((void **)this + 3), 4LL * (a2 & ~(a2 >> 31)));
      if (this)
      {
        *(void *)(v3 + 24) = this;
        int v4 = *(_DWORD *)(v3 + 16);
        *(_DWORD *)(v3 + 12) = v4;
        if (*(_DWORD *)(v3 + 8) > v4) {
          *(_DWORD *)(v3 + 8) = v4;
        }
      }
    }
  }

  return this;
}

uint64_t icu::UVector32::sortedInsert(uint64_t this, int a2, UErrorCode *a3)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 8);
  if (!v5)
  {
    int v6 = 0;
    int v10 = 1;
    goto LABEL_12;
  }

  int v6 = 0;
  int v7 = *(_DWORD *)(this + 8);
  do
  {
    int v8 = v7 + v6;
    if (v7 + v6 < 0 != __OFADD__(v7, v6)) {
      ++v8;
    }
    int v9 = v8 >> 1;
    if (*(_DWORD *)(*(void *)(this + 24) + 4LL * v9) > a2) {
      int v7 = v9;
    }
    else {
      int v6 = v9 + 1;
    }
  }

  while (v6 != v7);
  int v10 = v5 + 1;
  if (v5 >= -1)
  {
LABEL_12:
    if (*(_DWORD *)(this + 12) > v5) {
      goto LABEL_15;
    }
  }

  this = icu::UVector32::expandCapacity((icu::UVector32 *)this, v10, a3);
  if (!(_DWORD)this) {
    return this;
  }
  int v5 = *(_DWORD *)(v4 + 8);
LABEL_15:
  uint64_t v11 = *(void *)(v4 + 24);
  if (v5 <= v6)
  {
    uint64_t v13 = v6;
  }

  else
  {
    uint64_t v12 = v5;
    uint64_t v13 = v6;
    do
    {
      *(_DWORD *)(v11 + 4 * v12) = *(_DWORD *)(v11 + 4 * v12 - 4);
      --v12;
    }

    while (v12 > v6);
  }

  *(_DWORD *)(v11 + 4 * v13) = a2;
  ++*(_DWORD *)(v4 + 8);
  return this;
}

void *icu::UVector64::getStaticClassID(icu::UVector64 *this)
{
  return &unk_18C53519E;
}

void *icu::UVector64::getDynamicClassID(icu::UVector64 *this)
{
  return &unk_18C53519E;
}

icu::UVector64 *icu::UVector64::UVector64(icu::UVector64 *this, UErrorCode *a2)
{
  *(void *)this = off_18971CE08;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector64::_init(this, 8, a2);
  return this;
}

{
  *(void *)this = off_18971CE08;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector64::_init(this, 8, a2);
  return this;
}

void *icu::UVector64::_init(icu::UVector64 *this, int a2, UErrorCode *a3)
{
  if (a2 >= 1) {
    int v5 = a2;
  }
  else {
    int v5 = 8;
  }
  int v6 = *((_DWORD *)this + 4);
  if (v6 >= v5 || v6 <= 0) {
    int v8 = v5;
  }
  else {
    int v8 = *((_DWORD *)this + 4);
  }
  if (v8 >= 0x10000000) {
    int v8 = uprv_min(8LL, v6);
  }
  uint64_t result = uprv_malloc(8LL * v8);
  *((void *)this + 3) = result;
  if (result) {
    *((_DWORD *)this + 3) = v8;
  }
  else {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
  return result;
}

icu::UVector64 *icu::UVector64::UVector64(icu::UVector64 *this, int a2, UErrorCode *a3)
{
  *(void *)this = off_18971CE08;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector64::_init(this, a2, a3);
  return this;
}

{
  *(void *)this = off_18971CE08;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0LL;
  icu::UVector64::_init(this, a2, a3);
  return this;
}

void icu::UVector64::~UVector64(void **this)
{
  *this = off_18971CE08;
  uprv_free(this[3]);
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  *this = off_18971CE08;
  uprv_free(this[3]);
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  void *v2;
  *this = off_18971CE08;
  uprv_free(this[3]);
  this[3] = 0LL;
  icu::UObject::~UObject((icu::UObject *)this);
  icu::UMemory::operator delete(v2);
}

void icu::UVector64::assign(icu::UVector64 *this, const icu::UVector64 *a2, UErrorCode *a3)
{
  int v5 = *((_DWORD *)a2 + 2);
  if (v5 < 0 || *((_DWORD *)this + 3) < v5)
  {
    int v5 = *((_DWORD *)a2 + 2);
  }

  icu::UVector64::setSize(this, v5);
  uint64_t v6 = *((unsigned int *)a2 + 2);
  if ((int)v6 >= 1)
  {
    int v7 = (uint64_t *)*((void *)a2 + 3);
    int v8 = (void *)*((void *)this + 3);
    do
    {
      uint64_t v9 = *v7++;
      *v8++ = v9;
      --v6;
    }

    while (v6);
  }

void icu::UVector64::setSize(icu::UVector64 *this, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    int v4 = *((_DWORD *)this + 2);
    if (v4 < a2)
    {
      UErrorCode v5 = U_ZERO_ERROR;
      if (*((_DWORD *)this + 3) < a2)
      {
        int v4 = *((_DWORD *)this + 2);
      }

      if (v4 < a2) {
        bzero((void *)(*((void *)this + 3) + 8LL * v4), 8LL * (~v4 + a2) + 8);
      }
    }

    *((_DWORD *)this + 2) = a2;
  }

BOOL icu::UVector64::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2 != *(_DWORD *)(a2 + 8)) {
    return 0LL;
  }
  uint64_t v3 = *(uint64_t **)(a1 + 24);
  int v4 = *(uint64_t **)(a2 + 24);
  uint64_t v5 = v2 - 1;
  do
  {
    uint64_t v7 = *v3++;
    uint64_t v6 = v7;
    uint64_t v9 = *v4++;
    uint64_t v8 = v9;
    BOOL v11 = v5-- != 0;
    BOOL result = v6 == v8;
  }

  while (v6 == v8 && v11);
  return result;
}

uint64_t icu::UVector64::setElementAt(uint64_t this, uint64_t a2, unsigned int a3)
{
  return this;
}

_DWORD *icu::UVector64::insertElementAt(_DWORD *this, uint64_t a2, signed int a3, UErrorCode *a4)
{
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v5 = this;
    int v6 = this[2];
    if (v6 >= a3)
    {
      if (this[3] <= v6)
      {
        this = (_DWORD *)icu::UVector64::expandCapacity((icu::UVector64 *)this, v6 + 1, a4);
        if (!(_DWORD)this) {
          return this;
        }
        int v6 = v5[2];
      }

      uint64_t v8 = *((void *)v5 + 3);
      if (v6 > a3)
      {
        unsigned int v9 = v6;
        do
        {
          *(void *)(v8 + 8LL * v9) = *(void *)(v8 + 8LL * (v9 - 1));
          --v9;
        }

        while ((int)v9 > a3);
      }

      *(void *)(v8 + 8LL * a3) = a2;
      v5[2] = v6 + 1;
    }
  }

  return this;
}

uint64_t icu::UVector64::removeAllElements(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  return this;
}

uint64_t icu::UVector64::expandCapacity(icu::UVector64 *this, int a2, UErrorCode *a3)
{
  if (a2 < 0) {
    goto LABEL_19;
  }
  int v6 = *((_DWORD *)this + 3);
  if (v6 < a2)
  {
    int v7 = *((_DWORD *)this + 4);
    if (v7 >= 1 && v7 < a2)
    {
      uint64_t result = 0LL;
      UErrorCode v12 = U_BUFFER_OVERFLOW_ERROR;
      goto LABEL_21;
    }

    if (v6 >= 0x40000000) {
      goto LABEL_19;
    }
    int v9 = 2 * v6;
    if (v9 <= a2) {
      int v9 = a2;
    }
    BOOL v10 = v9 <= v7 || v7 <= 0;
    int v11 = v10 ? v9 : *((_DWORD *)this + 4);
    if (v11 >= 0x10000000)
    {
LABEL_19:
      uint64_t result = 0LL;
      UErrorCode v12 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_21:
      *a3 = v12;
      return result;
    }

    uint64_t result = (uint64_t)uprv_realloc(*((void **)this + 3), 8LL * v11);
    if (!result)
    {
      UErrorCode v12 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_21;
    }

    *((void *)this + 3) = result;
    *((_DWORD *)this + 3) = v11;
  }

  return 1LL;
}

void *icu::UVector64::setMaxCapacity(void *this, int a2)
{
  int v2 = a2 & ~(a2 >> 31);
  if (!(v2 >> 28))
  {
    uint64_t v3 = (uint64_t)this;
    *((_DWORD *)this + 4) = v2;
    if (a2 >= 1 && *((_DWORD *)this + 3) > v2)
    {
      this = uprv_realloc(*((void **)this + 3), 8LL * (a2 & ~(a2 >> 31)));
      if (this)
      {
        *(void *)(v3 + 24) = this;
        int v4 = *(_DWORD *)(v3 + 16);
        *(_DWORD *)(v3 + 12) = v4;
        if (*(_DWORD *)(v3 + 8) > v4) {
          *(_DWORD *)(v3 + 8) = v4;
        }
      }
    }
  }

  return this;
}

void sub_180891778(icu::UObject *a1)
{
  *(void *)a1 = off_18971CE48;
  uint64_t v2 = *((void *)a1 + 1);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    uint64_t v3 = *((void *)a1 + 1);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  uint64_t v4 = *((void *)a1 + 2);
  if (v4) {
    BOOL v5 = v4 == v3;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  icu::UObject::~UObject(a1);
}

void sub_1808917E4(icu::UObject *a1)
{
}

void icu::AlphabeticIndex::ImmutableIndex::~ImmutableIndex(icu::AlphabeticIndex::ImmutableIndex *this)
{
  *(void *)this = off_18971CE70;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::AlphabeticIndex::ImmutableIndex::~ImmutableIndex(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::AlphabeticIndex::ImmutableIndex::getBucketCount(icu::AlphabeticIndex::ImmutableIndex *this)
{
  return *(unsigned int *)(*(void *)(*((void *)this + 1) + 16LL) + 8LL);
}

uint64_t icu::AlphabeticIndex::ImmutableIndex::getBucketIndex( icu::AlphabeticIndex::ImmutableIndex *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  return sub_180891884(*((void *)this + 1), (uint64_t)a2, *((void *)this + 2), (uint64_t)a3);
}

uint64_t sub_180891884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v5 = *(icu::UVector **)(a1 + 8);
  int v6 = *((_DWORD *)v5 + 2);
  if (v6 < 2)
  {
    unsigned int v10 = 0;
  }

  else
  {
    unsigned int v10 = 0;
    do
    {
      int v11 = v10 + v6;
      int v12 = v11 >> 1;
      uint64_t v13 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 8), v11 >> 1);
      else {
        int v6 = v12;
      }
    }

    while ((int)(v10 + 1) < v6);
    BOOL v5 = *(icu::UVector **)(a1 + 8);
  }

  uint64_t v14 = icu::UVector::elementAt(v5, v10);
  uint64_t v15 = *(void *)(v14 + 144);
  if (!v15) {
    uint64_t v15 = v14;
  }
  return *(unsigned int *)(v15 + 152);
}

uint64_t icu::AlphabeticIndex::ImmutableIndex::getBucket( icu::AlphabeticIndex::ImmutableIndex *this, signed int a2)
{
  if (a2 < 0) {
    return 0LL;
  }
  uint64_t v2 = *(icu::UVector **)(*((void *)this + 1) + 16LL);
  if (*((_DWORD *)v2 + 2) <= a2) {
    return 0LL;
  }
  else {
    return icu::UVector::elementAt(v2, a2);
  }
}

icu::AlphabeticIndex *icu::AlphabeticIndex::AlphabeticIndex( icu::AlphabeticIndex *this, const icu::Locale *a2, UErrorCode *a3)
{
  *(void *)this = off_18971CE98;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 2) = 0xFFFFFFFFLL;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 8) = 99;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((void *)this + 9) = 0LL;
  *((void *)this + 10) = off_18971B688;
  *((_WORD *)this + 44) = 2;
  *((void *)this + 18) = off_18971B688;
  *((_WORD *)this + 76) = 2;
  *((void *)this + 26) = off_18971B688;
  *((_WORD *)this + 108) = 2;
  *((void *)this + 34) = off_18971B688;
  *((_WORD *)this + 140) = 2;
  *((void *)this + 42) = off_18971B688;
  *((_WORD *)this + 172) = 2;
  icu::AlphabeticIndex::init(this, a2, a3);
  return this;
}

void icu::AlphabeticIndex::init(icu::AlphabeticIndex *this, const icu::Locale *a2, UErrorCode *a3)
{
  uint64_t v3 = (uint64_t *)*(unsigned int *)a3;
  if (!a2)
  {
    uint64_t v3 = (uint64_t *)*((void *)this + 7);
    if (!v3)
    {
LABEL_20:
      UErrorCode v19 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_28:
      *a3 = v19;
      return;
    }
  }

  int v7 = (icu::UnicodeSet *)icu::UMemory::operator new(v3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (!v7)
  {
    *((void *)this + 5) = 0LL;
    goto LABEL_27;
  }

  icu::UnicodeSet::UnicodeSet(v7);
  *((void *)this + 5) = v8;
  __int16 v22 = 8230;
  icu::UnicodeString::unBogus((uint64_t)this + 80);
  else {
    uint64_t v9 = *((unsigned __int16 *)this + 44) >> 5;
  }
  icu::UnicodeString::doReplace((uint64_t)this + 80, 0LL, v9, (uint64_t)&v22, 0, 1LL);
  icu::UnicodeString::operator=((UChar **)this + 18, (UChar **)this + 10);
  icu::UnicodeString::operator=((UChar **)this + 26, (UChar **)this + 10);
  uint64_t Instance = (icu::RuleBasedCollator *)*((void *)this + 7);
  if (Instance) {
    goto LABEL_10;
  }
  uint64_t Instance = icu::Collator::createInstance(a2, (const icu::Locale *)a3, v11);
  if (*(int *)a3 >= 1)
  {
    if (Instance) {
      (*(void (**)(icu::RuleBasedCollator *))(*(void *)Instance + 8LL))(Instance);
    }
    return;
  }

  if (!Instance)
  {
LABEL_27:
    UErrorCode v19 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_28;
  }

  uint64_t v12 = *(void *)Instance;
  else {
    int v20 = 0LL;
  }
  *((void *)this + 7) = v20;
  if (!v20)
  {
    (*(void (**)(void))(v12 + 8))();
    UErrorCode v19 = U_UNSUPPORTED_ERROR;
    goto LABEL_28;
  }

icu::AlphabeticIndex *icu::AlphabeticIndex::AlphabeticIndex( icu::AlphabeticIndex *this, icu::RuleBasedCollator *a2, UErrorCode *a3)
{
  *(void *)this = off_18971CE98;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 2) = 0xFFFFFFFFLL;
  *((void *)this + 3) = 0LL;
  *((_DWORD *)this + 8) = 99;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((void *)this + 7) = a2;
  *((void *)this + 8) = 0LL;
  *((void *)this + 9) = 0LL;
  *((void *)this + 10) = off_18971B688;
  *((_WORD *)this + 44) = 2;
  *((void *)this + 18) = off_18971B688;
  *((_WORD *)this + 76) = 2;
  *((void *)this + 26) = off_18971B688;
  *((_WORD *)this + 108) = 2;
  *((void *)this + 34) = off_18971B688;
  *((_WORD *)this + 140) = 2;
  *((void *)this + 42) = off_18971B688;
  *((_WORD *)this + 172) = 2;
  icu::AlphabeticIndex::init(this, 0LL, a3);
  return this;
}

void icu::AlphabeticIndex::~AlphabeticIndex(icu::AlphabeticIndex *this)
{
  uint64_t v2 = off_18971CE98;
  *(void *)this = off_18971CE98;
  uint64_t v3 = (icu::RuleBasedCollator *)*((void *)this + 7);
  if (v3)
  {
    icu::RuleBasedCollator::~RuleBasedCollator(v3);
    icu::UMemory::operator delete(v4);
  }

  BOOL v5 = (icu::RuleBasedCollator *)*((void *)this + 8);
  if (v5)
  {
    icu::RuleBasedCollator::~RuleBasedCollator(v5);
    icu::UMemory::operator delete(v6);
  }

  uint64_t v7 = *((void *)this + 6);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *((void *)this + 9);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *((void *)this + 1);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  unint64_t v10 = (icu::UnicodeSet *)*((void *)this + 5);
  if (v10)
  {
    icu::UnicodeSet::~UnicodeSet(v10);
    icu::UMemory::operator delete(v11);
  }

  icu::UnicodeString::~UnicodeString(v2, (icu::AlphabeticIndex *)((char *)this + 336));
  icu::UnicodeString::~UnicodeString(v12, (icu::AlphabeticIndex *)((char *)this + 272));
  icu::UnicodeString::~UnicodeString(v13, (icu::AlphabeticIndex *)((char *)this + 208));
  icu::UnicodeString::~UnicodeString(v14, (icu::AlphabeticIndex *)((char *)this + 144));
  icu::UnicodeString::~UnicodeString(v15, (icu::AlphabeticIndex *)((char *)this + 80));
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::AlphabeticIndex::~AlphabeticIndex(this);
  icu::UMemory::operator delete(v1);
}

icu::UVector ***icu::AlphabeticIndex::addLabels( icu::UVector ***this, const icu::UnicodeSet *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    icu::UnicodeSet::addAll(this[5], a2);
    uint64_t v4 = this[9];
    if (v4)
    {
      (*((void (**)(icu::UVector **))*v4 + 1))(v4);
      this[9] = 0LL;
      *((_DWORD *)this + 4) = -1;
      this[3] = 0LL;
    }
  }

  return this;
}

uint64_t icu::AlphabeticIndex::clearBuckets(icu::AlphabeticIndex *this)
{
  uint64_t result = *((void *)this + 9);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    *((void *)this + 9) = 0LL;
    *((_DWORD *)this + 4) = -1;
    *((void *)this + 3) = 0LL;
  }

  return result;
}

icu::UVector ***icu::AlphabeticIndex::addLabels(icu::UVector ***this, char **a2, UErrorCode *a3)
{
  uint64_t v4 = this[9];
  if (v4)
  {
    (*((void (**)(icu::UVector **))*v4 + 1))(v4);
    this[9] = 0LL;
    *((_DWORD *)this + 4) = -1;
    this[3] = 0LL;
  }

  return this;
}

void icu::AlphabeticIndex::addIndexExemplars(icu::UVector ***this, char **a2, UErrorCode *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  int v6 = ulocdata_open(a2[5], (int *)a3);
  if (*(int *)a3 <= 0)
  {
    uint64_t v40 = 0LL;
    memset(v39, 0, sizeof(v39));
    icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v39);
    ulocdata_getExemplarSet((uint64_t)v6, (icu::UnicodeSet *)v39, 0, 2, a3);
    if (*(int *)a3 <= 0)
    {
      icu::UnicodeSet::addAll(this[5], (const icu::UnicodeSet *)v39);
    }

    else
    {
      *a3 = U_ZERO_ERROR;
      ulocdata_getExemplarSet((uint64_t)v6, (icu::UnicodeSet *)v39, 0, 0, a3);
      if (*(int *)a3 <= 0)
      {
        if (!icu::UnicodeSet::containsNone((icu::UnicodeSet *)v39, 97, 122)
          || icu::UnicodeSet::isEmpty((icu::UnicodeSet *)v39))
        {
          icu::UnicodeSet::add((icu::UnicodeSet *)v39, 0x61u, 0x7Au);
        }

        if (!icu::UnicodeSet::containsNone((icu::UnicodeSet *)v39, 44032, 55203))
        {
          uint64_t v7 = icu::UnicodeSet::remove((icu::UnicodeSet *)v39, 0xAC00u, 0xD7A3u);
          uint64_t v8 = icu::UnicodeSet::add(v7, 0xAC00u);
          uint64_t v9 = icu::UnicodeSet::add(v8, 0xB098u);
          unint64_t v10 = icu::UnicodeSet::add(v9, 0xB2E4u);
          int v11 = icu::UnicodeSet::add(v10, 0xB77Cu);
          uint64_t v12 = icu::UnicodeSet::add(v11, 0xB9C8u);
          uint64_t v13 = icu::UnicodeSet::add(v12, 0xBC14u);
          uint64_t v14 = icu::UnicodeSet::add(v13, 0xC0ACu);
          uint64_t v15 = icu::UnicodeSet::add(v14, 0xC544u);
          uint64_t v16 = icu::UnicodeSet::add(v15, 0xC790u);
          int v17 = icu::UnicodeSet::add(v16, 0xCC28u);
          __int128 v18 = icu::UnicodeSet::add(v17, 0xCE74u);
          UErrorCode v19 = icu::UnicodeSet::add(v18, 0xD0C0u);
          int v20 = icu::UnicodeSet::add(v19, 0xD30Cu);
          icu::UnicodeSet::add(v20, 0xD558u);
        }

        if (!icu::UnicodeSet::containsNone((icu::UnicodeSet *)v39, 4608, 4991))
        {
          uint64_t v38 = 0LL;
          __int128 v36 = 0u;
          __int128 v37 = 0u;
          __int128 v34 = 0u;
          __int128 v35 = 0u;
          __int128 v32 = 0u;
          __int128 v33 = 0u;
          __int128 v30 = 0u;
          __int128 v31 = 0u;
          __int128 v28 = 0u;
          __int128 v29 = 0u;
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          icu::UnicodeString::UnicodeString((uint64_t)&v41, (uint64_t)"[");
          icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)&v26, (const icu::UnicodeString *)&v41, a3);
          icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)&v41);
          icu::UnicodeSet::retainAll((icu::UVector **)&v26, (const icu::UnicodeSet *)v39);
          __int16 v22 = (icu::UVector **)icu::UnicodeSet::remove((icu::UnicodeSet *)v39, 0x1200u, 0x137Fu);
          icu::UnicodeSet::addAll(v22, (const icu::UnicodeSet *)&v26);
          icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)&v26);
        }

        __int128 v28 = 0u;
        __int128 v29 = 0u;
        __int128 v26 = 0u;
        __int128 v27 = 0u;
        icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)&v26, (const icu::UnicodeSet *)v39);
        __int128 v42 = 0u;
        uint64_t v45 = 0LL;
        __int128 v44 = 0u;
        __int128 v43 = 0u;
        int v41 = (UChar *)off_18971B688;
        LOWORD(v42) = 2;
        while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)&v26))
        {
          uint64_t String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)&v26, v23, v24);
          icu::UnicodeString::operator=(&v41, (UChar **)String);
          icu::UnicodeString::toUpper((const UChar **)&v41, (const icu::Locale *)a2);
          icu::UnicodeSet::add((icu::UnicodeSet *)this[5], (const icu::UnicodeString *)&v41);
        }

        icu::UnicodeString::~UnicodeString(v24, (icu::UnicodeString *)&v41);
        icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)&v26);
      }
    }

    icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v39);
  }

  if (v6) {
    ulocdata_close(v6);
  }
}

uint64_t *icu::AlphabeticIndex::buildImmutableIndex(icu::UVector **this, UErrorCode *a2)
{
  BucketList = icu::AlphabeticIndex::createBucketList(this, a2);
  uint64_t v7 = icu::RuleBasedCollator::clone(this[8], v5, v6);
  unint64_t v10 = (icu::RuleBasedCollator *)v7;
  if (BucketList && v7)
  {
    uint64_t result = icu::UMemory::operator new(v9, (icu::UMemory *)0x18, v8);
    if (result)
    {
      *uint64_t result = (uint64_t)off_18971CE70;
      result[1] = (uint64_t)BucketList;
      result[2] = (uint64_t)v10;
      return result;
    }

    *a2 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_9;
  }

  *a2 = U_MEMORY_ALLOCATION_ERROR;
  if (v7)
  {
LABEL_9:
    icu::RuleBasedCollator::~RuleBasedCollator(v10);
    icu::UMemory::operator delete(v12);
  }

  if (BucketList) {
    (*(void (**)(uint64_t *))(*BucketList + 8))(BucketList);
  }
  return 0LL;
}

uint64_t *icu::AlphabeticIndex::createBucketList(icu::UVector **this, UErrorCode *a2)
{
  uint64_t v114 = *MEMORY[0x1895F89C0];
  uint64_t v104 = 0LL;
  memset(v103, 0, sizeof(v103));
  icu::UVector::UVector((icu::UVector *)v103, a2);
  icu::UVector::setDeleter((icu::UVector *)v103, (void (*)(void *))uprv_deleteUObject);
  icu::AlphabeticIndex::initLabels(this, (UErrorCode *)v103, a2);
  uint64_t v4 = 0LL;
  if (*(int *)a2 <= 0)
  {
    memset(v102, 0, sizeof(v102));
    icu::UVector64::UVector64((icu::UVector64 *)v102, a2);
    else {
      VariableTounint64_t p = 0;
    }
    memset(v113, 0, sizeof(v113));
    memset(v112, 0, sizeof(v112));
    unint64_t v8 = (icu::UVector *)icu::UMemory::operator new(v6, (icu::UMemory *)0x28, v5);
    if (!v8)
    {
      uint64_t v4 = 0LL;
      goto LABEL_137;
    }

    uint64_t v9 = (unsigned int *)v8;
    icu::UVector::UVector(v8, a2);
    icu::UVector::setDeleter((icu::UVector *)v9, (void (*)(void *))uprv_deleteUObject);
    uint64_t v101 = 0LL;
    uint64_t v12 = icu::UMemory::operator new(v11, (icu::UMemory *)0xA8, v10);
    if (!v12)
    {
LABEL_7:
      uint64_t v4 = 0LL;
      goto LABEL_8;
    }

    uint64_t v13 = v12;
    uint64_t v14 = (UChar **)(*((uint64_t (**)(icu::UVector **))*this + 10))(this);
    uint64_t v15 = (const icu::UnicodeString *)(this + 42);
    *(void *)uint64_t v13 = off_18971CFA0;
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v13 + 2), v14);
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v13 + 18), (UChar **)this + 42);
    v13[34] = 1;
    *((void *)v13 + 18) = 0LL;
    v13[38] = -1;
    *((void *)v13 + 20) = 0LL;
    uint64_t v101 = v13;
    if (*(int *)a2 > 0)
    {
      uint64_t v4 = 0LL;
      goto LABEL_135;
    }

    uint64_t v101 = 0LL;
    icu::UVector::adoptElement((icu::UVector *)v9, v13, a2);
    if (*(int *)a2 > 0)
    {
      uint64_t v4 = 0LL;
      goto LABEL_134;
    }

    __int128 v108 = 0u;
    uint64_t v111 = 0LL;
    __int128 v110 = 0u;
    __int128 v109 = 0u;
    __int128 v107 = off_18971B688;
    LOWORD(v108) = 2;
    if (SDWORD2(v103[0]) >= 1)
    {
      unsigned int v17 = 0;
      int v93 = 0;
      int v91 = 0;
      uint64_t v90 = (UChar **)(this + 42);
      int v18 = -1;
      while (1)
      {
        UErrorCode v19 = (UChar **)v15;
        uint64_t v20 = icu::UVector::elementAt((icu::UVector *)v103, v17);
        if ((icu::RuleBasedCollator::compare(this[8], (const icu::UnicodeString *)v20, v15, a2) & 0x80000000) != 0) {
          goto LABEL_37;
        }
        LOBYTE(v22) = 1;
        do
        {
          char v23 = v22;
          uint64_t v15 = (const icu::UnicodeString *)icu::UVector::elementAt(this[6], ++v18);
          int v24 = icu::RuleBasedCollator::compare(this[8], (const icu::UnicodeString *)v20, v15, a2);
          uint64_t v22 = 0LL;
        }

        while ((v24 & 0x80000000) == 0);
        if ((v23 & 1) != 0) {
          goto LABEL_37;
        }
        uint64_t v22 = v9[2];
        unsigned int v25 = icu::UMemory::operator new((uint64_t *)v22, (icu::UMemory *)0xA8, v21);
        if (v25)
        {
          __int128 v26 = (UChar **)(*((uint64_t (**)(icu::UVector **))*this + 6))(this);
          *unsigned int v25 = (uint64_t)off_18971CFA0;
          icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v25 + 1), v26);
          icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v25 + 9), v19);
          *((_DWORD *)v25 + 34) = 2;
          v25[18] = 0LL;
          *((_DWORD *)v25 + 38) = -1;
          v25[20] = 0LL;
          if (*(int *)a2 > 0)
          {
            (*(void (**)(uint64_t *))(*v25 + 8))(v25);
            goto LABEL_36;
          }
        }

        else if (*(int *)a2 > 0)
        {
          goto LABEL_36;
        }

        if (v101) {
          (*(void (**)(void *))(*(void *)v101 + 8LL))(v101);
        }
        uint64_t v101 = v25;
        if (!v25) {
          *a2 = U_MEMORY_ALLOCATION_ERROR;
        }
LABEL_36:
        __int128 v27 = v101;
        uint64_t v101 = 0LL;
        icu::UVector::adoptElement((icu::UVector *)v9, v27, a2);
        uint64_t v22 = *(unsigned int *)a2;
LABEL_37:
        __int128 v28 = icu::UMemory::operator new((uint64_t *)v22, (icu::UMemory *)0xA8, v21);
        if (!v28)
        {
          goto LABEL_69;
        }

        BOOL v29 = icu::UnicodeString::doEqualsSubstring(v20, 0, 1, (uint64_t)&unk_180A2CD02, 0, 1);
        int v100 = &unk_180A2CD02;
        __int128 v30 = (UChar **)v20;
        if (v29)
        {
          unsigned int v31 = *(unsigned __int16 *)(v20 + 8);
          if ((v31 & 0x8000u) == 0) {
            unsigned int v32 = v31 >> 5;
          }
          else {
            unsigned int v32 = *(_DWORD *)(v20 + 12);
          }
          if (v32 >= 2)
          {
            uint64_t v33 = (v31 & 2) != 0 ? v20 + 10 : *(void *)(v20 + 24);
            unsigned int v34 = *(unsigned __int16 *)(v33 + 2);
            if (v34 - 10241 <= 0xFE)
            {
              unsigned int v92 = *(_WORD *)(v33 + 2) / 0xAu;
              v106[0] = (v34 - 10 * v92) | 0x30;
              icu::UnicodeString::unBogus((uint64_t)&v107);
              if ((v108 & 0x8000u) == 0LL) {
                uint64_t v35 = (unsigned __int16)v108 >> 5;
              }
              else {
                uint64_t v35 = DWORD1(v108);
              }
              icu::UnicodeString::doReplace((uint64_t)&v107, 0LL, v35, (uint64_t)v106, 0, 1LL);
              if (v34 >= 0x280A)
              {
                v106[0] = (v92 - 10 * ((unsigned __int16)(26 * v92) >> 8)) | 0x30;
                icu::UnicodeString::doReplace((uint64_t)&v107, 0LL, 0LL, (uint64_t)v106, 0, 1LL);
                if (v34 - 10340 <= 0xFFFFFF9B)
                {
                  v106[0] = (v34 / 0x64u) | 0x30;
                  icu::UnicodeString::doReplace((uint64_t)&v107, 0LL, 0LL, (uint64_t)v106, 0, 1LL);
                }
              }

              v106[0] = 21123;
              __int128 v30 = (UChar **)icu::UnicodeString::doAppend((uint64_t)&v107, (uint64_t)v106, 0, 1LL);
              goto LABEL_67;
            }
          }

          icu::UnicodeString::unBogus((uint64_t)&v107);
          unsigned int v36 = *(unsigned __int16 *)(v20 + 8);
          if (*(__int16 *)(v20 + 8) < 0)
          {
            int v37 = *(_DWORD *)(v20 + 12);
            if (v37 < 1) {
              goto LABEL_61;
            }
          }

          else if (v36 <= 0x1F)
          {
            int v37 = 0;
LABEL_61:
            int v38 = (__int16)v36;
            if ((v108 & 0x8000u) == 0LL) {
              uint64_t v39 = (unsigned __int16)v108 >> 5;
            }
            else {
              uint64_t v39 = DWORD1(v108);
            }
            unsigned int v40 = v36 >> 5;
            if (v38 < 0) {
              unsigned int v40 = *(_DWORD *)(v20 + 12);
            }
            __int128 v30 = (UChar **)icu::UnicodeString::doReplace( (icu::UnicodeString *)&v107,  0LL,  v39,  (const icu::UnicodeString *)v20,  v37,  v40 - v37);
            goto LABEL_67;
          }

          int v37 = 1;
          goto LABEL_61;
        }

LABEL_138:
  icu::UVector::~UVector((icu::UVector *)v103);
  return v4;
}

uint64_t icu::AlphabeticIndex::getBucketCount(icu::AlphabeticIndex *this, UErrorCode *a2)
{
  else {
    return 0LL;
  }
}

uint64_t *icu::AlphabeticIndex::initBuckets(uint64_t *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    uint64_t v2 = this;
    if (!this[9])
    {
      this = icu::AlphabeticIndex::createBucketList((icu::UVector **)this, a2);
      v2[9] = (uint64_t)this;
      if (*(int *)a2 <= 0)
      {
        this = (uint64_t *)v2[1];
        if (this)
        {
          if (*((_DWORD *)this + 2))
          {
            icu::UVector::sortWithUComparator( (icu::UVector *)this,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_1808938A0,  v2[7],  a2);
            uint64_t v4 = icu::UVector::elementAt(*(icu::UVector **)(v2[9] + 8), 0);
            unint64_t v5 = *(int **)(v2[9] + 8);
            if (v5[2] <= 1)
            {
              uint64_t v6 = 0LL;
              uint64_t v7 = 0LL;
              signed int v8 = 1;
            }

            else
            {
              uint64_t v6 = icu::UVector::elementAt((icu::UVector *)v5, 1u);
              uint64_t v7 = (const icu::UnicodeString *)(v6 + 72);
              signed int v8 = 2;
            }

            this = (uint64_t *)v2[1];
            if (*((int *)this + 2) >= 1)
            {
              for (signed int i = 0; i < *((_DWORD *)this + 2); ++i)
              {
                uint64_t v11 = icu::UVector::elementAt((icu::UVector *)this, i);
                if (v7
                  && (icu::RuleBasedCollator::compare( (icu::RuleBasedCollator *)v2[8],  (const icu::UnicodeString *)(v11 + 8),  v7,  a2) & 0x80000000) == 0)
                {
                  while (1)
                  {
                    uint64_t v4 = v6;
                    uint64_t v12 = *(icu::UVector **)(v2[9] + 8);
                    if (v8 >= *((_DWORD *)v12 + 2)) {
                      break;
                    }
                    signed int v13 = v8 + 1;
                    uint64_t v6 = icu::UVector::elementAt(v12, v8);
                    uint64_t v7 = (const icu::UnicodeString *)(v6 + 72);
                    ++v8;
                    if ((icu::RuleBasedCollator::compare( (icu::RuleBasedCollator *)v2[8],  (const icu::UnicodeString *)(v11 + 8),  (const icu::UnicodeString *)(v6 + 72),  a2) & 0x80000000) != 0)
                    {
                      signed int v8 = v13;
                      goto LABEL_18;
                    }
                  }

                  uint64_t v7 = 0LL;
                }

uint64_t icu::AlphabeticIndex::getRecordCount(icu::AlphabeticIndex *this, UErrorCode *a2)
{
  else {
    return 0LL;
  }
}

void icu::AlphabeticIndex::initLabels(icu::UVector **this, UErrorCode *a2, UErrorCode *a3)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  NFKDuint64_t Instance = icu::Normalizer2::getNFKDInstance((icu::Normalizer2 *)a3, a2);
  if (*(int *)a3 <= 0)
  {
    uint64_t v60 = NFKDInstance;
    uint64_t v7 = (const icu::UnicodeString *)icu::UVector::elementAt(this[6], 0);
    signed int v8 = (const icu::UnicodeString *)icu::UVector::elementAt(this[6], *((_DWORD *)this[6] + 2) - 1);
    memset(v62, 0, sizeof(v62));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v62, this[5]);
    while (1)
    {
      if (!icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v62))
      {
        if (*(int *)a3 <= 0)
        {
          int v54 = *((_DWORD *)a2 + 2);
          int v55 = v54 - 1;
          if (v54 - 1 > *((_DWORD *)this + 8) && v54 >= 1)
          {
            int v57 = 0;
            int v58 = -1;
            int v59 = 1;
            do
            {
              if (*((_DWORD *)this + 8) * v59 / v55 == v58)
              {
                icu::UVector::removeElementAt((uint64_t (**)(void))a2, v57);
                int v54 = *((_DWORD *)a2 + 2);
              }

              else
              {
                ++v57;
                int v58 = *((_DWORD *)this + 8) * v59 / v55;
              }

              ++v59;
            }

            while (v57 < v54);
          }
        }

        goto LABEL_3;
      }

      uint64_t String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)v62, v9, v10);
      uint64_t v12 = (icu::UnicodeString *)String;
      uint64_t v61 = 0LL;
      unsigned int v13 = *((unsigned __int16 *)String + 4);
      int v14 = (__int16)v13;
      int32_t v15 = v13 >> 5;
      if (v14 >= 0) {
        int32_t v16 = v15;
      }
      else {
        int32_t v16 = *((_DWORD *)String + 3);
      }
      char v17 = 1;
      if (icu::UnicodeString::hasMoreChar32Than((icu::UnicodeString *)String, 0, v16, 1))
      {
        uint64_t v19 = v16;
        uint64_t v20 = v16 - 1LL;
        unsigned int v21 = *((unsigned __int16 *)v12 + 4);
        if ((v21 & 0x8000u) == 0) {
          unsigned int v22 = v21 >> 5;
        }
        else {
          unsigned int v22 = *((_DWORD *)v12 + 3);
        }
        if (v22 > v20
          && ((v21 & 2) != 0 ? (char v23 = (char *)v12 + 10) : (char v23 = (char *)*((void *)v12 + 3)),
              *(_WORD *)&v23[2 * v20] == 42
           && ((int v24 = (uint64_t *)(v19 - 2), v22 <= v24)
            || (int v24 = (uint64_t *)*(unsigned __int16 *)&v23[2 * (void)v24], (_DWORD)v24 != 42))))
        {
          uint64_t v35 = (icu::UnicodeString *)icu::UMemory::operator new(v24, (icu::UMemory *)0x40, v18);
          if (!v35)
          {
            *a3 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_3;
          }

          uint64_t v61 = icu::UnicodeString::UnicodeString(v35, v12, 0, v20);
          uint64_t v12 = v61;
        }

        else
        {
          char v17 = 0;
        }
      }

      if ((icu::RuleBasedCollator::compare(this[8], v12, v7, a3) & 0x80000000) != 0) {
        goto LABEL_72;
      }
      if ((icu::RuleBasedCollator::compare(this[8], v12, v8, a3) & 0x80000000) == 0) {
        goto LABEL_72;
      }
      if ((v17 & 1) == 0)
      {
        unsigned int v25 = this[8];
        icu::AlphabeticIndex::separated((uint64_t)v12, (uint64_t)&v69);
        LODWORD(v25) = icu::RuleBasedCollator::compare(v25, v12, (const icu::UnicodeString *)&v69, a3);
        icu::UnicodeString::~UnicodeString(v26, (icu::UnicodeString *)&v69);
        if (!(_DWORD)v25) {
          goto LABEL_72;
        }
      }

      int v27 = *((_DWORD *)a2 + 2);
      if (!v27)
      {
        LODWORD(v3sub_18086E18C((uint64_t)this, 1) = -1;
LABEL_54:
        unsigned int v45 = sub_18089371C((UChar **)v12, &v61, a3);
        icu::UVector::insertElementAt((uint64_t (**)(void *))a2, v45, ~(_DWORD)v31, a3);
        goto LABEL_72;
      }

      uint64_t v28 = 0LL;
      BOOL v29 = this[8];
      while (1)
      {
        int v30 = v27 + v28;
        uint64_t v31 = (v30 >> 1);
        uint64_t v32 = icu::UVector::elementAt((icu::UVector *)a2, v30 >> 1);
        LODWORD(v69) = 0;
        int v33 = (*(uint64_t (**)(icu::UVector *, icu::UnicodeString *, uint64_t, void (***)(icu::UnicodeString *__hidden)))(*(void *)v29 + 56LL))( v29,  v12,  v32,  &v69);
        if (!v33) {
          goto LABEL_39;
        }
        if (v33 < 0) {
          break;
        }
        uint64_t v34 = v31;
        if ((_DWORD)v31 == (_DWORD)v28)
        {
          LODWORD(v3sub_18086E18C((uint64_t)this, 1) = -2 - v28;
LABEL_39:
          if ((v31 & 0x80000000) != 0) {
            goto LABEL_54;
          }
          goto LABEL_40;
        }

uint64_t icu::AlphabeticIndex::separated@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a2;
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  unsigned int v4 = *(unsigned __int16 *)(this + 8);
  int v5 = (__int16)v4;
  LODWORD(a2) = v4 >> 5;
  if (v5 >= 0) {
    a2 = a2;
  }
  else {
    a2 = *(unsigned int *)(this + 12);
  }
  if ((_DWORD)a2)
  {
    uint64_t v6 = this;
    int v7 = 0;
    while (1)
    {
      unsigned int v8 = icu::UnicodeString::char32At((uint64_t *)a2, (icu::UnicodeString *)v6, v7);
      icu::UnicodeString::append(v3, v8);
      this = icu::UnicodeString::moveIndex32((icu::UnicodeString *)v6, v7, 1);
      unsigned int v9 = *(unsigned __int16 *)(v6 + 8);
      int v10 = (__int16)v9;
      int v11 = v9 >> 5;
      if (v10 < 0) {
        int v11 = *(_DWORD *)(v6 + 12);
      }
      int v7 = this;
      __int16 v12 = 847;
      icu::UnicodeString::doAppend(v3, (uint64_t)&v12, 0, 1LL);
    }
  }

  return this;
}

icu::UnicodeString *sub_18089371C(UChar **a1, icu::UnicodeString **a2, _DWORD *a3)
{
  uint64_t v3 = (uint64_t *)*a3;
  uint64_t result = *a2;
  if (*a2)
  {
    *a2 = 0LL;
  }

  else
  {
    uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new(v3, (icu::UMemory *)0x40, (unint64_t)a2);
    if (result) {
      return icu::UnicodeString::UnicodeString(result, a1);
    }
    else {
      *a3 = 7;
    }
  }

  return result;
}

uint64_t icu::AlphabeticIndex::Bucket::Bucket(uint64_t a1, UChar **a2, UChar **a3, int a4)
{
  *(void *)a1 = off_18971CFA0;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(a1 + 8), a2);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(a1 + 72), a3);
  *(_DWORD *)(a1 + 136) = a4;
  *(void *)(a1 + 144) = 0LL;
  *(_DWORD *)(a1 + 152) = -1;
  *(void *)(a1 + 160) = 0LL;
  return a1;
}

{
  *(void *)a1 = off_18971CFA0;
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(a1 + 8), a2);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)(a1 + 72), a3);
  *(_DWORD *)(a1 + 136) = a4;
  *(void *)(a1 + 144) = 0LL;
  *(_DWORD *)(a1 + 152) = -1;
  *(void *)(a1 + 160) = 0LL;
  return a1;
}

BOOL sub_1808937E0( icu::RuleBasedCollator *a1, unsigned int a2, const icu::UnicodeString *a3, icu::UVector64 *this, UErrorCode *a5)
{
  unint64_t v11 = *((unsigned int *)this + 2);
  if ((int)v11 < 1)
  {
    return 0;
  }

  else
  {
    uint64_t v12 = 0LL;
    int v13 = 0;
    BOOL v14 = 1;
    do
    {
      if (*(_DWORD *)(*((void *)this + 3) + 8 * v12 + 4) > a2)
      {
        if (v13) {
          return v14;
        }
        int v13 = 1;
      }

      BOOL v14 = ++v12 < v11;
    }

    while (v11 != v12);
  }

  return v14;
}

uint64_t sub_1808938A0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  int v6 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)a1 + 56LL))(a1, v3 + 8, v4 + 8, &v6);
}

uint64_t icu::AlphabeticIndex::internalResetBucketIterator(uint64_t this)
{
  *(_DWORD *)(this + 16) = -1;
  *(void *)(this + 24) = 0LL;
  return this;
}

uint64_t icu::AlphabeticIndex::addChineseIndexCharacters(icu::AlphabeticIndex *this, UErrorCode *a2)
{
  uint64_t v15 = 0LL;
  memset(v14, 0, sizeof(v14));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v14);
  icu::RuleBasedCollator::internalAddContractions(*((uint64_t ***)this + 8), 64976LL, (icu::UnicodeSet *)v14, a2);
  if (*(int *)a2 > 0 || icu::UnicodeSet::isEmpty((icu::UnicodeSet *)v14))
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    icu::UnicodeSet::addAll(*((icu::UVector ***)this + 5), (const icu::UnicodeSet *)v14);
    memset(v13, 0, sizeof(v13));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v13, (const icu::UnicodeSet *)v14);
    while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v13))
    {
      uint64_t String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)v13, v6, v7);
      unsigned int v9 = *((unsigned __int16 *)String + 4);
      if ((v9 & 0x8000u) == 0) {
        unsigned int v10 = v9 >> 5;
      }
      else {
        unsigned int v10 = *((_DWORD *)String + 3);
      }
      if (v10)
      {
        unsigned int v11 = v10 - 1;
        uint64_t v12 = (v9 & 2) != 0 ? (uint64_t)String + 10 : String[3];
        if (*(unsigned __int16 *)(v12 + 2LL * (int)v11) - 65 <= 0x19)
        {
          icu::UnicodeSet::add(*((icu::UnicodeSet **)this + 5), 0x41u, 0x5Au);
          break;
        }
      }
    }

    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v13);
    uint64_t v4 = 1LL;
  }

  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v14);
  return v4;
}

uint64_t icu::AlphabeticIndex::operator==()
{
  return 0LL;
}

uint64_t icu::AlphabeticIndex::operator!=()
{
  return 0LL;
}

uint64_t icu::AlphabeticIndex::getCollator(icu::AlphabeticIndex *this)
{
  return *((void *)this + 7);
}

uint64_t icu::AlphabeticIndex::getInflowLabel(icu::AlphabeticIndex *this)
{
  return (uint64_t)this + 80;
}

uint64_t icu::AlphabeticIndex::getOverflowLabel(icu::AlphabeticIndex *this)
{
  return (uint64_t)this + 144;
}

uint64_t icu::AlphabeticIndex::getUnderflowLabel(icu::AlphabeticIndex *this)
{
  return (uint64_t)this + 208;
}

UChar **icu::AlphabeticIndex::setInflowLabel(UChar **this, UChar **a2, UErrorCode *a3)
{
  icu::UnicodeString::operator=(this + 10, a2);
  uint64_t v4 = this[9];
  if (v4)
  {
    (*(void (**)(UChar *))(*(void *)v4 + 8LL))(v4);
    this[9] = 0LL;
    *((_DWORD *)this + 4) = -1;
    this[3] = 0LL;
  }

  return this;
}

UChar **icu::AlphabeticIndex::setOverflowLabel(UChar **this, UChar **a2, UErrorCode *a3)
{
  icu::UnicodeString::operator=(this + 18, a2);
  uint64_t v4 = this[9];
  if (v4)
  {
    (*(void (**)(UChar *))(*(void *)v4 + 8LL))(v4);
    this[9] = 0LL;
    *((_DWORD *)this + 4) = -1;
    this[3] = 0LL;
  }

  return this;
}

UChar **icu::AlphabeticIndex::setUnderflowLabel(UChar **this, UChar **a2, UErrorCode *a3)
{
  icu::UnicodeString::operator=(this + 26, a2);
  uint64_t v4 = this[9];
  if (v4)
  {
    (*(void (**)(UChar *))(*(void *)v4 + 8LL))(v4);
    this[9] = 0LL;
    *((_DWORD *)this + 4) = -1;
    this[3] = 0LL;
  }

  return this;
}

uint64_t icu::AlphabeticIndex::getMaxLabelCount(icu::AlphabeticIndex *this)
{
  return *((unsigned int *)this + 8);
}

icu::AlphabeticIndex *icu::AlphabeticIndex::setMaxLabelCount( icu::AlphabeticIndex *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (a2 <= 0)
    {
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      *((_DWORD *)this + 8) = a2;
      uint64_t v5 = *((void *)this + 9);
      if (v5)
      {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
        *((void *)this + 9) = 0LL;
        *((_DWORD *)this + 4) = -1;
        *((void *)this + 3) = 0LL;
      }
    }
  }

  return this;
}

icu::UVector *icu::AlphabeticIndex::firstStringsInScript(uint64_t ***this, UErrorCode *a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)a2;
  unint64_t v6 = (icu::UVector *)icu::UMemory::operator new(v2, (icu::UMemory *)0x28, (unint64_t)a2);
  if (!v6)
  {
    if (*(int *)a2 <= 0)
    {
      uint64_t v3 = 0LL;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      return v3;
    }

    return 0LL;
  }

  int v7 = v6;
  icu::UVector::UVector(v6, a2);
  icu::UVector::setDeleter(v7, (void (*)(void *))uprv_deleteUObject);
  uint64_t v21 = 0LL;
  memset(v20, 0, sizeof(v20));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v20);
  icu::RuleBasedCollator::internalAddContractions(this[8], 64977LL, (icu::UnicodeSet *)v20, a2);
  if (*(int *)a2 > 0)
  {
LABEL_8:
    icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v20);
LABEL_9:
    uint64_t v3 = 0LL;
LABEL_10:
    (*(void (**)(icu::UVector *))(*(void *)v7 + 8LL))(v7);
    return v3;
  }

  if (icu::UnicodeSet::isEmpty((icu::UnicodeSet *)v20))
  {
    *a2 = U_UNSUPPORTED_ERROR;
    goto LABEL_8;
  }

  memset(v19, 0, sizeof(v19));
  icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v19, (const icu::UnicodeSet *)v20);
  if (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v19))
  {
    while (1)
    {
      uint64_t String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)v19, v9, v10);
      UChar32 v13 = icu::UnicodeString::char32At(v12, (icu::UnicodeString *)String, 1);
      if (u_charType(v13) <= 5)
      {
        int32_t v16 = (icu::UnicodeString *)icu::UMemory::operator new(v15, (icu::UMemory *)0x40, v14);
        char v17 = v16;
        if (v16)
        {
          icu::UnicodeString::UnicodeString(v16, (UChar **)String);
        }

        else if (*(int *)a2 <= 0)
        {
          *a2 = U_MEMORY_ALLOCATION_ERROR;
        }

        icu::UVector::adoptElement(v7, v17, a2);
      }
    }

    unint64_t v18 = v7;
    int v7 = 0LL;
  }

  else
  {
LABEL_22:
    unint64_t v18 = 0LL;
  }

  uint64_t v3 = v7;
  icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v19);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v20);
  int v7 = v18;
  if (v18) {
    goto LABEL_10;
  }
  return v3;
}

uint64_t sub_180893D88(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  if (v3 == v4) {
    return 0LL;
  }
  if (!v3) {
    return 1LL;
  }
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v6 = 0;
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
}

icu::AlphabeticIndex::Record *icu::AlphabeticIndex::Record::Record( icu::AlphabeticIndex::Record *this, UChar **a2, const void *a3)
{
  *((void *)this + 9) = a3;
  return this;
}

{
  icu::UnicodeString::UnicodeString((icu::AlphabeticIndex::Record *)((char *)this + 8), a2);
  *((void *)this + 9) = a3;
  return this;
}

void icu::AlphabeticIndex::Record::~Record(icu::AlphabeticIndex::Record *this)
{
}

{
  icu::UnicodeString::~UnicodeString((icu::AlphabeticIndex::Record *)((char *)this + 8));
}

icu::AlphabeticIndex *icu::AlphabeticIndex::addRecord( icu::AlphabeticIndex *this, UChar **a2, uint64_t a3, UErrorCode *a4)
{
  unsigned int v8 = (uint64_t *)*((void *)this + 1);
  if (v8) {
    goto LABEL_3;
  }
  unsigned int v11 = (icu::UVector *)icu::UMemory::operator new(0LL, (icu::UMemory *)0x28, (unint64_t)a2);
  if (v11)
  {
    uint64_t v12 = icu::UVector::UVector(v11, a4);
    if (*(int *)a4 > 0)
    {
      (*(void (**)(icu::UVector *))(*(void *)v12 + 8LL))(v12);
      return this;
    }

    *((void *)this + sub_18086E18C((uint64_t)this, 1) = v12;
    icu::UVector::setDeleter(v12, (void (*)(void *))sub_180893FB8);
LABEL_3:
    unint64_t v9 = icu::UMemory::operator new(v8, (icu::UMemory *)0x50, (unint64_t)a2);
    unsigned int v10 = v9;
    if (v9)
    {
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v9 + 1), a2);
      v10[9] = a3;
    }

    else if (*(int *)a4 <= 0)
    {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }

    icu::UVector::adoptElement(*((icu::UVector **)this + 1), v10, a4);
    if (*(int *)a4 <= 0)
    {
      uint64_t v13 = *((void *)this + 9);
      if (v13)
      {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
        *((void *)this + 9) = 0LL;
        *((_DWORD *)this + 4) = -1;
        *((void *)this + 3) = 0LL;
      }
    }

    return this;
  }

  return this;
}

void sub_180893FB8(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (a1)
  {
    icu::UnicodeString::~UnicodeString(a2, (icu::UnicodeString *)(a1 + 8));
    icu::UMemory::operator delete((void *)a1);
  }

icu::AlphabeticIndex *icu::AlphabeticIndex::clearRecords(icu::AlphabeticIndex *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    uint64_t v4 = *((void *)this + 1);
    if (v4)
    {
      if (*(_DWORD *)(v4 + 8))
      {
        icu::UVector::removeAllElements(v4);
        uint64_t v5 = *((void *)this + 9);
        if (v5)
        {
          (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
          *((void *)this + 9) = 0LL;
          *((_DWORD *)this + 4) = -1;
          *((void *)this + 3) = 0LL;
        }
      }
    }
  }

  return this;
}

uint64_t icu::AlphabeticIndex::getBucketIndex( icu::AlphabeticIndex *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  else {
    return 0LL;
  }
}

uint64_t icu::AlphabeticIndex::getBucketIndex(icu::AlphabeticIndex *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t icu::AlphabeticIndex::nextBucket(icu::AlphabeticIndex *this, UErrorCode *a2)
{
  if (!*((void *)this + 9) && *((void *)this + 3))
  {
    uint64_t result = 0LL;
    *a2 = U_ENUM_OUT_OF_SYNC_ERROR;
    return result;
  }

  icu::AlphabeticIndex::initBuckets((uint64_t *)this, a2);
  signed int v5 = *((_DWORD *)this + 4) + 1;
  *((_DWORD *)this + 4) = v5;
  int v6 = *(icu::UVector **)(*((void *)this + 9) + 16LL);
  signed int v7 = *((_DWORD *)v6 + 2);
  if (v5 >= v7)
  {
    uint64_t result = 0LL;
    *((_DWORD *)this + 4) = v7;
  }

  else
  {
    *((void *)this + 3) = icu::UVector::elementAt(v6, v5);
    (*(void (**)(icu::AlphabeticIndex *))(*(void *)this + 224LL))(this);
    return 1LL;
  }

  return result;
}

uint64_t icu::AlphabeticIndex::getBucketLabel(icu::AlphabeticIndex *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return v1 + 8;
  }
  else {
    return (uint64_t)this + 336;
  }
}

uint64_t icu::AlphabeticIndex::getBucketLabelType(icu::AlphabeticIndex *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return *(unsigned int *)(v1 + 136);
  }
  else {
    return 0LL;
  }
}

uint64_t icu::AlphabeticIndex::getBucketRecordCount(icu::AlphabeticIndex *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 160)) != 0) {
    return *(unsigned int *)(v2 + 8);
  }
  else {
    return 0LL;
  }
}

uint64_t icu::AlphabeticIndex::resetBucketIterator(uint64_t this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    *(_DWORD *)(this + 16) = -1;
    *(void *)(this + 24) = 0LL;
  }

  return this;
}

uint64_t icu::AlphabeticIndex::nextRecord(icu::AlphabeticIndex *this, UErrorCode *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2)
  {
    UErrorCode v6 = U_INVALID_STATE_ERROR;
LABEL_12:
    *a2 = v6;
    return v2;
  }

  if (!*((void *)this + 9))
  {
    uint64_t v2 = 0LL;
    UErrorCode v6 = U_ENUM_OUT_OF_SYNC_ERROR;
    goto LABEL_12;
  }

  uint64_t v2 = *(void *)(v2 + 160);
  if (v2)
  {
    int v3 = *((_DWORD *)this + 5);
    int v4 = *(_DWORD *)(v2 + 8);
    uint64_t v2 = v3 + 1 < v4;
    if (v3 + 1 < v4) {
      int v5 = v3 + 1;
    }
    else {
      int v5 = v4;
    }
    *((_DWORD *)this + 5) = v5;
  }

  return v2;
}

uint64_t icu::AlphabeticIndex::getRecordName(icu::AlphabeticIndex *this)
{
  uint64_t result = (uint64_t)this + 336;
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {
    int v4 = *(icu::UVector **)(v3 + 160);
    if (v4)
    {
      signed int v5 = *((_DWORD *)this + 5);
      if ((v5 & 0x80000000) == 0 && v5 < *((_DWORD *)v4 + 2)) {
        return icu::UVector::elementAt(v4, v5) + 8;
      }
    }
  }

  return result;
}

icu::UVector *icu::AlphabeticIndex::getRecordData(icu::AlphabeticIndex *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (!v1) {
    return 0LL;
  }
  uint64_t result = *(icu::UVector **)(v1 + 160);
  if (!result) {
    return result;
  }
  signed int v4 = *((_DWORD *)this + 5);
  if (v4 < 0 || v4 >= *((_DWORD *)result + 2)) {
    return 0LL;
  }
  else {
    return *(icu::UVector **)(icu::UVector::elementAt(result, v4) + 72);
  }
}

uint64_t icu::AlphabeticIndex::resetRecordIterator(uint64_t this)
{
  *(_DWORD *)(this + 20) = -1;
  return this;
}

void icu::AlphabeticIndex::Bucket::~Bucket(icu::AlphabeticIndex::Bucket *this)
{
  *(void *)this = off_18971CFA0;
  uint64_t v2 = *((void *)this + 20);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UnicodeString::~UnicodeString((icu::AlphabeticIndex::Bucket *)((char *)this + 72));
  icu::UnicodeString::~UnicodeString((icu::AlphabeticIndex::Bucket *)((char *)this + 8));
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::AlphabeticIndex::Bucket::~Bucket(this);
  icu::UMemory::operator delete(v1);
}

void *sub_1808943A8(void *a1, uint64_t a2, icu::UVector *this)
{
  *a1 = off_18971CE48;
  a1[1] = a2;
  a1[2] = this;
  if (*((int *)this + 2) >= 1)
  {
    signed int v5 = 0;
    do
    {
      *(_DWORD *)(icu::UVector::elementAt(this, v5) + 152) = v5;
      ++v5;
    }

    while (v5 < *((_DWORD *)this + 2));
  }

  return a1;
}

uint64_t sub_180894418(_DWORD *a1)
{
  uint64_t result = 0LL;
  int v9 = 0;
  int i = a1[6];
  a1[4] = -1;
  a1[5] = i;
  int v4 = a1[3];
  if (i != v4)
  {
    if (i <= a1[2]) {
      goto LABEL_7;
    }
    do
    {
      unsigned int v5 = (*(uint64_t (**)(void, void))(**(void **)a1 + 80LL))(*(void *)a1, (i - 1));
      int i = a1[5] - 1;
      a1[5] = i;
    }

    while (i > a1[2]);
    for (int i = a1[6]; ; a1[6] = i)
    {
      int v4 = a1[3];
LABEL_7:
      if (i >= v4) {
        break;
      }
      unsigned int v6 = (*(uint64_t (**)(void))(**(void **)a1 + 80LL))(*(void *)a1);
      unsigned int Script = uscript_getScript(v6, &v9);
      if (Script >= 2)
      {
        int v8 = a1[4];
        if (v8 == -1)
        {
          a1[4] = Script;
        }

        else if (Script != v8)
        {
          return 1LL;
        }
      }

      int i = a1[6] + 1;
    }

    return 1LL;
  }

  return result;
}

void *icu::AnyTransliterator::getStaticClassID(icu::AnyTransliterator *this)
{
  return &unk_18C53519F;
}

void *sub_18089450C()
{
  return &unk_18C53519F;
}

icu::Transliterator *sub_180894518( icu::Transliterator *a1, UChar **a2, UChar **a3, uint64_t a4, int a5, int *a6)
{
  unsigned int v11 = icu::Transliterator::Transliterator(a1, a2, 0LL);
  *(void *)unsigned int v11 = off_18971D028;
  *((void *)v11 + 12) = off_18971B688;
  uint64_t v12 = (UChar **)((char *)v11 + 96);
  *((_WORD *)v11 + 52) = 2;
  *((_DWORD *)v11 + 40) = a5;
  uint64_t v13 = uhash_openSize((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, 0LL, 7, a6);
  *((void *)a1 + 1sub_18086E18C((uint64_t)this, 1) = v13;
  if (*a6 <= 0)
  {
    uhash_setValueDeleter((uint64_t)v13, (uint64_t)sub_18089463C);
    icu::UnicodeString::operator=(v12, a3);
    unsigned int v14 = *(unsigned __int16 *)(a4 + 8);
    int v15 = (__int16)v14;
    int v16 = v14 >> 5;
    if (v15 < 0) {
      int v16 = *(_DWORD *)(a4 + 12);
    }
    if (v16 >= 1)
    {
      __int16 v23 = 47;
      uint64_t v17 = icu::UnicodeString::doAppend((uint64_t)v12, (uint64_t)&v23, 0, 1LL);
      unsigned int v18 = *(unsigned __int16 *)(a4 + 8);
      int v19 = (__int16)v18;
      unsigned int v20 = v18 >> 5;
      if (v19 >= 0) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = *(unsigned int *)(a4 + 12);
      }
      icu::UnicodeString::doAppend(v17, (const icu::UnicodeString *)a4, 0, v21);
    }
  }

  return a1;
}

uint64_t sub_18089463C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_180894650(_BYTE **a1)
{
  *a1 = off_18971D028;
  uhash_close(a1[11]);
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)(a1 + 12));
  icu::Transliterator::~Transliterator((icu::Transliterator *)a1);
}

void sub_180894690(_BYTE **a1)
{
}

uint64_t sub_1808946A4(uint64_t a1, uint64_t a2)
{
  int v4 = icu::Transliterator::Transliterator((icu::Transliterator *)a1, (UChar **)a2);
  *(void *)int v4 = off_18971D028;
  icu::UnicodeString::UnicodeString((icu::Transliterator *)((char *)v4 + 96), (UChar **)(a2 + 96));
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  int v7 = 0;
  unsigned int v5 = uhash_openSize((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, 0LL, 7, &v7);
  *(void *)(a1 + 88) = v5;
  if (v7 <= 0) {
    uhash_setValueDeleter((uint64_t)v5, (uint64_t)sub_18089463C);
  }
  return a1;
}

uint64_t *sub_180894730@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0xA8, a2);
  if (result) {
    return (uint64_t *)sub_1808946A4((uint64_t)result, a1);
  }
  return result;
}

uint64_t sub_180894760(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  uint64_t v9 = *((unsigned int *)a3 + 2);
  uint64_t v8 = *((unsigned int *)a3 + 3);
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v18 = a2;
  uint64_t v19 = *a3;
  LODWORD(v2sub_18086E18C((uint64_t)this, 1) = v19;
  while (1)
  {
    uint64_t result = sub_180894418(&v18);
    if (!(_DWORD)result) {
      break;
    }
    int v11 = v21;
    if ((int)v21 > (int)v9)
    {
      uint64_t v12 = sub_180894878(a1, v20);
      if (v12)
      {
        uint64_t v13 = v12;
        BOOL v14 = v11 >= (int)v8 && a4 != 0;
        *((_DWORD *)a3 + 2) = uprv_max(v9, SHIDWORD(v20));
        int v15 = uprv_min(v8, v11);
        *((_DWORD *)a3 + 3) = v15;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, BOOL))(*(void *)v13 + 88LL))( v13,  a2,  a3,  v14);
        int v16 = *((_DWORD *)a3 + 3) - v15;
        LODWORD(v2sub_18086E18C((uint64_t)this, 1) = v16 + v11;
        HIDWORD(v19) += v16;
        BOOL v17 = v11 < (int)v8;
        uint64_t v8 = (v16 + v8);
        if (!v17) {
          break;
        }
      }

      else
      {
        *((_DWORD *)a3 + 2) = v11;
      }
    }
  }

  *((_DWORD *)a3 + 3) = v8;
  return result;
}

uint64_t sub_180894878(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0LL;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a2 != -1 && *(_DWORD *)(a1 + 160) != a2)
  {
    umtx_lock(0LL);
    uint64_t v2 = uhash_iget(*(void *)(a1 + 88), a2);
    umtx_unlock(0LL);
    if (!v2)
    {
      UErrorCode v24 = U_ZERO_ERROR;
      memset(v27, 0, sizeof(v27));
      ShortName = uscript_getShortName(a2);
      icu::UnicodeString::UnicodeString(v27, ShortName, 0xFFFFFFFFLL, 0LL);
      memset(v26, 0, sizeof(v26));
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)v26, (UChar **)v27);
      __int16 v25 = 45;
      uint64_t v6 = icu::UnicodeString::doAppend((uint64_t)v26, (uint64_t)&v25, 0, 1LL);
      unsigned int v7 = *(unsigned __int16 *)(a1 + 104);
      int v8 = (__int16)v7;
      unsigned int v9 = v7 >> 5;
      if (v8 >= 0) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = *(unsigned int *)(a1 + 108);
      }
      icu::UnicodeString::doAppend(v6, (const icu::UnicodeString *)(a1 + 96), 0, v10);
      uint64_t v11 = icu::Transliterator::createInstance((uint64_t)v26, 0, &v24);
      uint64_t v2 = v11;
      if (v24 > U_ZERO_ERROR || !v11)
      {
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
        }
        icu::UnicodeString::operator=((UChar **)v26, (UChar **)v27);
        uint64_t v12 = icu::UnicodeString::doAppend((uint64_t)v26, (uint64_t)"-", 0, 0xFFFFFFFFLL);
        unsigned int v13 = *(unsigned __int16 *)(a1 + 104);
        int v14 = (__int16)v13;
        unsigned int v15 = v13 >> 5;
        if (v14 >= 0) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = *(unsigned int *)(a1 + 108);
        }
        icu::UnicodeString::doAppend(v12, (const icu::UnicodeString *)(a1 + 96), 0, v16);
        uint64_t v17 = icu::Transliterator::createInstance((uint64_t)v26, 0, &v24);
        uint64_t v2 = v17;
        BOOL v18 = v24 > U_ZERO_ERROR || v17 == 0;
        uint64_t v19 = v18;
        if (v18 && v17)
        {
          (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
LABEL_25:
          uint64_t v2 = 0LL;
LABEL_29:
          icu::UnicodeString::~UnicodeString((void *)v19, (icu::UnicodeString *)v26);
          icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v27);
          return v2;
        }

        if ((v19 & 1) != 0) {
          goto LABEL_25;
        }
      }

      umtx_lock(0LL);
      uint64_t v20 = uhash_iget(*(void *)(a1 + 88), a2);
      if (v20)
      {
        uint64_t v21 = v20;
        umtx_unlock(0LL);
        (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
        uint64_t v2 = v21;
      }

      else
      {
        uhash_iput(*(void *)(a1 + 88), a2, v2, (int *)&v24);
        umtx_unlock(0LL);
      }

      goto LABEL_29;
    }
  }

  return v2;
}

void sub_180894ADC()
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  int v39 = 0;
  memset(&v38[1], 0, 88);
  uint64_t v0 = (icu::Transliterator *)uhash_init( (int32x2_t *)&v38[2],  (uint64_t)uhash_hashCaselessUnicodeString,  (uint64_t)uhash_compareCaselessUnicodeString,  0LL,  &v39);
  if (v39 <= 0)
  {
    v38[1] = &v38[2];
    uint64_t v0 = (icu::Transliterator *)uhash_setKeyDeleter((uint64_t)&v38[2], (uint64_t)uprv_deleteUObject);
  }

  int v32 = icu::Transliterator::_countAvailableSources(v0);
  if (v32 >= 1)
  {
    uint64_t v2 = 0LL;
    while (1)
    {
      uint64_t v55 = 0LL;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      __int128 v52 = 0u;
      uint64_t v51 = (UChar *)off_18971B688;
      LOWORD(v52) = 2;
      int v33 = (int)v2;
      icu::Transliterator::_getAvailableSource(v2, &v51, v1);
      int v3 = (v52 & 0x8000u) == 0LL ? (unsigned __int16)v52 >> 5 : DWORD1(v52);
      int v4 = icu::UnicodeString::doCaseCompare((uint64_t)&v51, 0, v3, (uint64_t)"A", 0, 3, 0);
      uint64_t v36 = "A";
      uint64_t v6 = &v36;
      if (v4)
      {
        int v7 = icu::Transliterator::_countAvailableTargets((icu::Transliterator *)&v51, v5);
        if (v7 >= 1) {
          break;
        }
      }

icu::CalendarAstronomer *icu::CalendarAstronomer::CalendarAstronomer(icu::CalendarAstronomer *this)
{
  *(void *)this = v2;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 14) = 0LL;
  *((void *)this + 15) = 0LL;
  *((_BYTE *)this + 128) = 0;
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  return this;
}

void icu::CalendarAstronomer::clearCache(icu::CalendarAstronomer *this)
{
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
}

icu::CalendarAstronomer *icu::CalendarAstronomer::CalendarAstronomer( icu::CalendarAstronomer *this, double a2)
{
  *(double *)this = a2;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 14) = 0LL;
  *((void *)this + 15) = 0LL;
  *((_BYTE *)this + 128) = 0;
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  return this;
}

{
  double NaN;
  *(double *)this = a2;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 14) = 0LL;
  *((void *)this + 15) = 0LL;
  *((_BYTE *)this + 128) = 0;
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  return this;
}

icu::CalendarAstronomer *icu::CalendarAstronomer::CalendarAstronomer( icu::CalendarAstronomer *this, double a2, double a3)
{
  *(void *)this = v6;
  *((void *)this + 14) = 0LL;
  *((void *)this + 15) = 0LL;
  *((_BYTE *)this + 128) = 0;
  *((double *)this + sub_18086E18C((uint64_t)this, 1) = a2 * 0.0174532925
                        + 3.14159265
                        + uprv_floor((a2 * 0.0174532925 + 3.14159265) / 6.28318531) * -6.28318531
                        + -3.14159265;
  double v7 = a3 * 0.0174532925 + 3.14159265;
  double v8 = uprv_floor(v7 / 6.28318531);
  double v9 = *((double *)this + 1) * 24.0 * 3600000.0 / 6.28318531;
  *((double *)this + 2) = v7 + v8 * -6.28318531 + -3.14159265;
  *((double *)this + 3) = v9;
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  return this;
}

void icu::CalendarAstronomer::setTime(icu::CalendarAstronomer *this, double a2)
{
  *(double *)this = a2;
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
}

void icu::CalendarAstronomer::setJulianDay(icu::CalendarAstronomer *this, double a2)
{
  *(double *)this = a2 * 86400000.0 + -2.1086676e14;
  double NaN = uprv_getNaN();
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  *((double *)this + 4) = a2;
  *((double *)this + 5) = NaN;
}

uint64_t icu::CalendarAstronomer::setLocation(uint64_t this, double a2, double a3)
{
  *(double *)(this + 8) = a3;
  *(double *)(this + 16) = a2;
  return this;
}

uint64_t sub_180895224(char *__s1, int a2, int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (__s1)
  {
    int v5 = a3;
    int v6 = a2;
    if (a2 <= a3)
    {
      while (1)
      {
        int v7 = v5 - v6;
        int v8 = v5 >= v6 ? v5 - v6 : v7 + 1;
        uint64_t v9 = (v6 + (v8 >> 1));
        int v10 = strcmp(__s1, (&off_18971D0C8)[3 * (int)v9]);
        if (!v10) {
          break;
        }
        if (v10 > 0)
        {
          int v6 = v9 + 1;
          uint64_t result = 0xFFFFFFFFLL;
        }

        else
        {
          int v5 = v9 - 1;
          if (v7 < 2) {
            return 0xFFFFFFFFLL;
          }
        }
      }

      return v9;
    }
  }

  return result;
}

int8x16_t icu::CalendarAstronomer::setLocation(icu::CalendarAstronomer *this, char *__s1)
{
  int v3 = sub_180895224(__s1, 0, 244);
  if (v3 == -1) {
    int8x16_t v4 = 0uLL;
  }
  else {
    int8x16_t v4 = *(int8x16_t *)&(&off_18971D0C8)[3 * v3 + 1];
  }
  int8x16_t result = vextq_s8(v4, v4, 8uLL);
  *(int8x16_t *)((char *)this + 8) = result;
  return result;
}

double icu::CalendarAstronomer::getTime(icu::CalendarAstronomer *this)
{
  return *(double *)this;
}

double icu::CalendarAstronomer::getJulianDay(icu::CalendarAstronomer *this)
{
  double result = (*(double *)this + 2.1086676e14) / 86400000.0;
  *((double *)this + 4) = result;
  return result;
}

double icu::CalendarAstronomer::getLocationLongitude(icu::CalendarAstronomer *this)
{
  return *((double *)this + 1);
}

double icu::CalendarAstronomer::getLocationLatitude(icu::CalendarAstronomer *this)
{
  return *((double *)this + 2);
}

double icu::CalendarAstronomer::getJulianCentury(icu::CalendarAstronomer *this)
{
  if (uprv_isNaN(*((double *)this + 4)))
  {
    double v2 = (*(double *)this + 2.1086676e14) / 86400000.0;
    *((double *)this + 4) = v2;
  }

  else
  {
    double v2 = *((double *)this + 4);
  }

  double result = (v2 + -2415020.0) / 36525.0;
  *((double *)this + 5) = result;
  return result;
}

void icu::CalendarAstronomer::getGreenwichSidereal(icu::CalendarAstronomer *this)
{
  if (uprv_isNaN(*((double *)this + 13)))
  {
    double v2 = *(double *)this / 3600000.0;
    double v3 = v2 + uprv_floor(v2 / 24.0) * -24.0;
    icu::CalendarAstronomer::getSiderealOffset(this);
    *((double *)this + 13) = v4 + v3 * 1.00273791 + uprv_floor((v4 + v3 * 1.00273791) / 24.0) * -24.0;
  }

void icu::CalendarAstronomer::getSiderealOffset(icu::CalendarAstronomer *this)
{
  if (uprv_isNaN(*((double *)this + 12)))
  {
    if (uprv_isNaN(*((double *)this + 4)))
    {
      double v2 = (*(double *)this + 2.1086676e14) / 86400000.0;
      *((double *)this + 4) = v2;
    }

    else
    {
      double v2 = *((double *)this + 4);
    }

    double v3 = uprv_floor(v2 + -0.5);
    double v4 = (v3 + 0.5 + -2451545.0) / 36525.0 * 2400.05134
       + 6.69737456
       + (v3 + 0.5 + -2451545.0) / 36525.0 * 0.000025862 * ((v3 + 0.5 + -2451545.0) / 36525.0);
    *((double *)this + 12) = v4 + uprv_floor(v4 / 24.0) * -24.0;
  }

double icu::CalendarAstronomer::getLocalSidereal(icu::CalendarAstronomer *this)
{
  double v3 = v2 + *((double *)this + 3) / 3600000.0;
  return v3 + uprv_floor(v3 / 24.0) * -24.0;
}

double icu::CalendarAstronomer::lstToUT(icu::CalendarAstronomer *this, double a2)
{
  double v5 = (a2 - v4) * 0.997269566 + uprv_floor((a2 - v4) * 0.997269566 / 24.0) * -24.0;
  return (double)(uint64_t)(v5 * 3600000.0)
}

icu::CalendarAstronomer::Equatorial *icu::CalendarAstronomer::eclipticToEquatorial( icu::CalendarAstronomer *this, icu::CalendarAstronomer::Equatorial *a2, const icu::CalendarAstronomer::Ecliptic *a3)
{
  return icu::CalendarAstronomer::eclipticToEquatorial(this, a2, *((double *)a3 + 1), *(double *)a3);
}

icu::CalendarAstronomer::Equatorial *icu::CalendarAstronomer::eclipticToEquatorial( icu::CalendarAstronomer *this, icu::CalendarAstronomer::Equatorial *a2, double a3, double a4)
{
  double v7 = icu::CalendarAstronomer::eclipticObliquity(this);
  __double2 v8 = __sincos_stret(v7);
  __double2 v9 = __sincos_stret(a3);
  __double2 v10 = __sincos_stret(a4);
  double v11 = tan(a4);
  double v12 = atan2(v9.__sinval * v8.__cosval - v11 * v8.__sinval, v9.__cosval);
  double v13 = asin(v9.__sinval * (v10.__cosval * v8.__sinval) + v10.__sinval * v8.__cosval);
  *(double *)a2 = v12;
  *((double *)a2 + sub_18086E18C((uint64_t)this, 1) = v13;
  return a2;
}

double icu::CalendarAstronomer::eclipticObliquity(icu::CalendarAstronomer *this)
{
  if (uprv_isNaN(*((double *)this + 4)))
  {
    double v2 = (*(double *)this + 2.1086676e14) / 86400000.0;
    *((double *)this + 4) = v2;
  }

  else
  {
    double v2 = *((double *)this + 4);
  }

  double v4 = (v2 + -2451545.0) / 36525.0;
  double result = (v4 * -0.0130041667 + 23.439292 + v4 * -0.000000166666667 * v4 + v4 * (v4 * 0.000000502777778) * v4)
         * 0.0174532925;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = result;
  return result;
}

icu::CalendarAstronomer::Equatorial *icu::CalendarAstronomer::eclipticToEquatorial( icu::CalendarAstronomer *this, icu::CalendarAstronomer::Equatorial *a2, double a3)
{
  return icu::CalendarAstronomer::eclipticToEquatorial(this, a2, a3, 0.0);
}

icu::CalendarAstronomer::Horizon *icu::CalendarAstronomer::eclipticToHorizon( icu::CalendarAstronomer *this, icu::CalendarAstronomer::Horizon *a2, double a3)
{
  double v14 = 0.0;
  double v15 = 0.0;
  icu::CalendarAstronomer::eclipticToEquatorial(this, (icu::CalendarAstronomer::Equatorial *)&v14, a3, 0.0);
  icu::CalendarAstronomer::getGreenwichSidereal(this);
  double v6 = v5 + *((double *)this + 3) / 3600000.0;
  double v7 = uprv_floor(v6 / 24.0);
  __double2 v8 = __sincos_stret((v6 + v7 * -24.0) * 3.14159265 / 12.0 - v14);
  __double2 v9 = __sincos_stret(v15);
  __double2 v10 = __sincos_stret(*((double *)this + 2));
  double v11 = asin(v9.__cosval * v10.__cosval * v8.__cosval + v9.__sinval * v10.__sinval);
  double v12 = sin(v11);
  *(double *)a2 = atan2(-(v9.__cosval * v10.__cosval) * v8.__sinval, v9.__sinval - v10.__sinval * v12);
  *((double *)a2 + sub_18086E18C((uint64_t)this, 1) = v11;
  return a2;
}

double icu::CalendarAstronomer::adjustSunLongitude(icu::CalendarAstronomer *this, double *a2, double a3)
{
  if (a3 < -2.20984944e12 || a3 >= 4.13310186e12) {
    return *(double *)this;
  }
  uint64_t v3 = (int)((a3 + 2.20984944e12) * 202.0 / 6.3429513e12);
  int v4 = (int)(a3 / 10000.0);
  uint64_t v5 = v3 << 32;
  double v6 = (int *)((char *)&unk_180A2D000 + 4 * (int)v3 + 8);
  do
  {
    int v7 = *(v6 - 2);
    v5 -= 0x100000000LL;
    --v6;
  }

  while (v7 > v4);
  do
  {
    int v9 = *v6++;
    int v8 = v9;
    v5 += 0x100000000LL;
  }

  while (v9 <= v4);
  int v10 = *(v6 - 2);
  int v11 = v4 - v10;
  if (v11 > 1570331)
  {
    if (v11 > 0x244EC2)
    {
      double v12 = (double)(v11 - 2379459) / (double)(v8 - 2379459 - v10);
      double v13 = (char *)&unk_180A2D328 + 4 * (v5 >> 32) + 3;
      double v14 = (char *)&unk_180A2D328 + 4 * ((v5 + 0x100000000LL) >> 32);
    }

    else
    {
      double v12 = (double)(v11 - 1570332) / 809127.0;
      uint64_t v16 = (char *)&unk_180A2D328 + 4 * (v5 >> 32);
      double v13 = v16 + 2;
      double v14 = v16 + 3;
    }
  }

  else if (v11 > 768902)
  {
    double v12 = (double)(v11 - 768903) / 801429.0;
    uint64_t v17 = (char *)&unk_180A2D328 + 4 * (v5 >> 32);
    double v13 = v17 + 1;
    double v14 = v17 + 2;
  }

  else
  {
    double v12 = (double)v11 / 768903.0;
    double v13 = (char *)&unk_180A2D328 + 4 * (v5 >> 32);
    double v14 = v13 + 1;
  }

  double result = *(double *)this + ((double)*v13 + v12 * (double)(*v14 - *v13)) / 100000.0;
  *(double *)this = result;
  double v18 = 6.28318531;
  if (result >= 6.28318531)
  {
    double v18 = -6.28318531;
    goto LABEL_18;
  }

  if (result < 0.0)
  {
LABEL_18:
    double result = result + v18;
    *(double *)this = result;
  }

  return result;
}

void icu::CalendarAstronomer::getSunLongitudeForTime( icu::CalendarAstronomer *this, double a2, uint64_t a3, double *a4)
{
  uint64_t v7 = 0LL;
  icu::CalendarAstronomer::getSunLongitude((icu::CalendarAstronomer *)&v7, (a2 + 2.1086676e14) / 86400000.0, &v6, a4);
  icu::CalendarAstronomer::adjustSunLongitude((icu::CalendarAstronomer *)&v7, v5, a2);
}

double icu::CalendarAstronomer::getSunLongitude( icu::CalendarAstronomer *this, double a2, double *a3, double *a4)
{
  double v6 = (a2 + -2447891.5) * 0.0172027916
     + uprv_floor((a2 + -2447891.5) * 0.0172027916 / 6.28318531) * -6.28318531
     + 4.87650758
     + -4.93523998;
  double v7 = v6 + uprv_floor(v6 / 6.28318531) * -6.28318531;
  *a3 = v7;
  double v8 = v7;
  do
  {
    __double2 v9 = __sincos_stret(v8);
    double v10 = v8 + v9.__sinval * -0.016713 - v7;
    double v8 = v8 - v10 / (v9.__cosval * -0.016713 + 1.0);
  }

  while (uprv_fabs(v10) > 0.00001);
  double v11 = tan(v8 * 0.5);
  double v12 = atan(v11 * 1.01685503);
  double result = v12 + v12 + 4.93523998 + uprv_floor((v12 + v12 + 4.93523998) / 6.28318531) * -6.28318531;
  *(double *)this = result;
  return result;
}

double icu::CalendarAstronomer::getSunLongitude(icu::CalendarAstronomer *this)
{
  double v2 = (icu::CalendarAstronomer *)((char *)this + 48);
  if (uprv_isNaN(*((double *)this + 6)))
  {
    if (uprv_isNaN(*((double *)this + 4)))
    {
      double v5 = (*(double *)this + 2.1086676e14) / 86400000.0;
      *((double *)this + 4) = v5;
    }

    else
    {
      double v5 = *((double *)this + 4);
    }

    icu::CalendarAstronomer::getSunLongitude(v2, v5, (double *)this + 7, v4);
  }

  return icu::CalendarAstronomer::adjustSunLongitude(v2, v3, *(double *)this);
}

icu::CalendarAstronomer::Equatorial *icu::CalendarAstronomer::getSunPosition( icu::CalendarAstronomer *this, icu::CalendarAstronomer::Equatorial *a2)
{
  double SunLongitude = icu::CalendarAstronomer::getSunLongitude(this);
  return icu::CalendarAstronomer::eclipticToEquatorial(this, a2, SunLongitude, 0.0);
}

double icu::CalendarAstronomer::SUMMER_SOLSTICE(icu::CalendarAstronomer *this)
{
  return 1.57079633;
}

double icu::CalendarAstronomer::WINTER_SOLSTICE(icu::CalendarAstronomer *this)
{
  return 4.71238898;
}

double icu::CalendarAstronomer::getSunTime(icu::CalendarAstronomer *this, double a2, int a3)
{
  if (a2 == 4.71238898 && (double v3 = *(double *)this, *(double *)this >= -2.20984944e12) && v3 < 4.13310186e12)
  {
    int v4 = (int)(v3 / 10000.0);
    double v5 = (int *)((char *)&unk_180A2D000 + 4 * (int)((v3 + 2.20984944e12) * 202.0 / 6.3429513e12) + 4);
    do
      int v6 = *--v5;
    while (v6 > v4);
    do
    {
      int v7 = v5[1];
      ++v5;
    }

    while (v7 <= v4);
    if (!a3) {
      --v5;
    }
    return (double)*v5 * 10000.0;
  }

  else
  {
    __double2 v9 = &off_18971E818;
    return icu::CalendarAstronomer::timeOfAngle( this,  (icu::CalendarAstronomer::AngleFunc *)&v9,  a2,  365.242191,  60000.0,  a3);
  }

double icu::CalendarAstronomer::timeOfAngle( icu::CalendarAstronomer *this, icu::CalendarAstronomer::AngleFunc *a2, double a3, double a4, double a5, int a6)
{
  double v7 = a3;
  if (a6) {
    double v10 = 0.0;
  }
  else {
    double v10 = -6.28318531;
  }
  double v11 = a4 * 86400000.0;
  double v26 = a4 * 86400000.0 * 0.125;
  double v27 = a4 * 86400000.0;
  double v28 = v10;
LABEL_5:
  double v12 = (**(double (***)(icu::CalendarAstronomer::AngleFunc *, icu::CalendarAstronomer *))a2)(a2, this);
  double v13 = v11 * (v10 + v7 - v12 + uprv_floor((v7 - v12) / 6.28318531) * -6.28318531) / 6.28318531;
  double v29 = *(double *)this;
  *(double *)this = v29 + uprv_ceil(v13);
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  do
  {
    double v15 = v13;
    double v16 = (**(double (***)(icu::CalendarAstronomer::AngleFunc *, icu::CalendarAstronomer *))a2)(a2, this);
    double v17 = v16 - v12 + 3.14159265;
    double v18 = uprv_floor(v17 / 6.28318531);
    double v19 = uprv_fabs(v15 / (v17 + v18 * -6.28318531 + -3.14159265));
    double v13 = v19 * (a3 - v16 + 3.14159265 + uprv_floor((a3 - v16 + 3.14159265) / 6.28318531) * -6.28318531 + -3.14159265);
    double v20 = uprv_fabs(v13);
    if (v20 > uprv_fabs(v15))
    {
      double v23 = uprv_ceil(v26);
      if (!a6) {
        double v23 = -v23;
      }
      *(double *)this = v29 + v23;
      double v24 = uprv_getNaN();
      *((double *)this + 4) = v24;
      *((double *)this + 5) = v24;
      *((double *)this + 6) = v24;
      *((double *)this + 7) = v24;
      *((double *)this + 8) = v24;
      *((double *)this + 9) = v24;
      *((double *)this + 10) = v24;
      *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = v24;
      *((double *)this + 12) = v24;
      *((double *)this + 13) = v24;
      *((_BYTE *)this + 128) = 0;
      double v7 = a3;
      double v11 = v27;
      double v10 = v28;
      goto LABEL_5;
    }

    double v21 = *(double *)this;
    *(double *)this = v21 + uprv_ceil(v13);
    double v22 = uprv_getNaN();
    *((double *)this + 4) = v22;
    *((double *)this + 5) = v22;
    *((double *)this + 6) = v22;
    *((double *)this + 7) = v22;
    *((double *)this + 8) = v22;
    *((double *)this + 9) = v22;
    *((double *)this + 10) = v22;
    *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = v22;
    *((double *)this + 12) = v22;
    *((double *)this + 13) = v22;
    *((_BYTE *)this + 128) = 0;
    double v12 = v16;
  }

  while (uprv_fabs(v13) > a5);
  return *(double *)this;
}

double icu::CalendarAstronomer::getSunRiseSet(icu::CalendarAstronomer *this, int a2)
{
  double v4 = *(double *)this;
  *(double *)this = dbl_180A2CFE0[a2 == 0]
                  + 43200000.0
  double NaN = uprv_getNaN();
  *((double *)this + 4) = NaN;
  *((double *)this + 5) = NaN;
  *((double *)this + 6) = NaN;
  *((double *)this + 7) = NaN;
  *((double *)this + 8) = NaN;
  *((double *)this + 9) = NaN;
  *((double *)this + 10) = NaN;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
  *((double *)this + 12) = NaN;
  *((double *)this + 13) = NaN;
  *((_BYTE *)this + 128) = 0;
  __double2 v9 = &off_18971E898;
  double v6 = icu::CalendarAstronomer::riseOrSet( this,  (icu::CalendarAstronomer::CoordFunc *)&v9,  a2,  0.00930260491,  0.00989019909,  5000.0);
  *(double *)this = v4;
  double v7 = uprv_getNaN();
  *((double *)this + 4) = v7;
  *((double *)this + 5) = v7;
  *((double *)this + 6) = v7;
  *((double *)this + 7) = v7;
  *((double *)this + 8) = v7;
  *((double *)this + 9) = v7;
  *((double *)this + 10) = v7;
  *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = v7;
  *((double *)this + 12) = v7;
  *((double *)this + 13) = v7;
  *((_BYTE *)this + 128) = 0;
  return v6;
}

double icu::CalendarAstronomer::riseOrSet( icu::CalendarAstronomer *this, icu::CalendarAstronomer::CoordFunc *a2, int a3, double a4, double a5, double a6)
{
  double v26 = 0.0;
  double v27 = 0.0;
  double v12 = -tan(*((double *)this + 2));
  int v13 = 5;
  do
  {
    (**(void (***)(icu::CalendarAstronomer::CoordFunc *, double *, icu::CalendarAstronomer *))a2)( a2,  &v26,  this);
    double v14 = tan(v27);
    double v15 = acos(v14 * v12);
    if (a3) {
      double v15 = 6.28318531 - v15;
    }
    double v16 = icu::CalendarAstronomer::lstToUT(this, (v26 + v15) * 24.0 / 6.28318531);
    double v17 = *(double *)this;
    *(double *)this = v16;
    double NaN = uprv_getNaN();
    *((double *)this + 4) = NaN;
    *((double *)this + 5) = NaN;
    *((double *)this + 6) = NaN;
    *((double *)this + 7) = NaN;
    *((double *)this + 8) = NaN;
    *((double *)this + 9) = NaN;
    *((double *)this + 10) = NaN;
    *((double *)this + 1sub_18086E18C((uint64_t)this, 1) = NaN;
    *((double *)this + 12) = NaN;
    *((double *)this + 13) = NaN;
    *((_BYTE *)this + 128) = 0;
    --v13;
  }

  while (v13 && uprv_fabs(v16 - v17) > a6);
  double v19 = cos(v27);
  double v20 = sin(*((double *)this + 2));
  double v21 = acos(v20 / v19);
  double v22 = sin(a4 * 0.5 + a5);
  double v23 = sin(v21);
  uint64_t v24 = (uint64_t)(asin(v22 / v23) * 240.0 * 57.2957795 / v19 * 1000.0);
  if (a3) {
    uint64_t v24 = -v24;
  }
  return *(double *)this + (double)v24;
}

uint64_t icu::CalendarAstronomer::getMoonPosition(icu::CalendarAstronomer *this)
{
  if (!*((_BYTE *)this + 128))
  {
    icu::CalendarAstronomer::getSunLongitude(this);
    if (uprv_isNaN(*((double *)this + 4)))
    {
      double v2 = (*(double *)this + 2.1086676e14) / 86400000.0;
      *((double *)this + 4) = v2;
    }

    else
    {
      double v2 = *((double *)this + 4);
    }

    double v3 = v2 + -2447891.5;
    double v19 = v2 + -2447891.5;
    double v4 = (v2 + -2447891.5) * 0.229971504
       + 5.55628444
       + uprv_floor(((v2 + -2447891.5) * 0.229971504 + 5.55628444) / 6.28318531) * -6.28318531;
    double v5 = v4
       + v3 * -0.00194436835
       + -0.634259806
       + uprv_floor((v4 + v3 * -0.00194436835 + -0.634259806) / 6.28318531) * -6.28318531;
    double v6 = *((double *)this + 6);
    double v7 = sin(-(v5 - (v4 - v6) * 2.0)) * 0.0222337493;
    double v8 = sin(*((double *)this + 7));
    double v9 = v8 * 0.00324282175;
    double v10 = v5 + v7 - v8 * 0.00324282175 + v8 * -0.00645771823;
    *((double *)this + 10) = v10;
    double v11 = sin(v10) * 0.109756775;
    double v12 = sin(v10 + v10) * 0.0037350046 + v4 + v7 + v11 - v9;
    *((double *)this + 8) = v12 + sin(v12 - v6 + v12 - v6) * 0.0114895025;
    double v13 = v19 * -0.000924219907
        + 5.55905007
        + uprv_floor((v19 * -0.000924219907 + 5.55905007) / 6.28318531) * -6.28318531;
    double v14 = v13 + sin(*((double *)this + 7)) * -0.0027925268;
    __double2 v15 = __sincos_stret(*((double *)this + 8) - v14);
    double v16 = atan2(v15.__sinval * 0.995970368, v15.__cosval) + v14;
    *((double *)this + 9) = v16;
    double v17 = asin(v15.__sinval * 0.0896829204);
    icu::CalendarAstronomer::eclipticToEquatorial(this, (icu::CalendarAstronomer *)((char *)this + 112), v16, v17);
    *((_BYTE *)this + 128) = 1;
  }

  return (uint64_t)this + 112;
}

void icu::CalendarAstronomer::getMoonAge(icu::CalendarAstronomer *this)
{
  double v2 = *(double *)this;
  if (*(double *)this < -2.21149158e12 || v2 >= 4.13644464e12)
  {
    icu::CalendarAstronomer::getMoonPosition(this);
    uprv_floor((*((double *)this + 9) - *((double *)this + 6)) / 6.28318531);
  }

  else
  {
    uint64_t v3 = (int)((v2 + 2.21149158e12) * 2489.0 / 6.34793622e12);
    int v4 = (int)(v2 / 10000.0);
    uint64_t v5 = v3 << 32;
    double v6 = (int *)((char *)&unk_180A2D650 + 4 * (int)v3 + 8);
    do
    {
      int v7 = *(v6 - 2);
      v5 -= 0x100000000LL;
      --v6;
    }

    while (v7 > v4);
    do
    {
      int v8 = *v6++;
      v5 += 0x100000000LL;
    }

    while (v8 <= v4);
  }

double icu::CalendarAstronomer::getMoonPhase(icu::CalendarAstronomer *this)
{
  return (1.0 - cos(v1)) * 0.5;
}

double icu::CalendarAstronomer::NEW_MOON(icu::CalendarAstronomer *this)
{
  return 0.0;
}

double icu::CalendarAstronomer::FULL_MOON(icu::CalendarAstronomer *this)
{
  return 3.14159265;
}

double icu::CalendarAstronomer::getNewMoonTimeInRange(icu::CalendarAstronomer *this, double a2)
{
  double v2 = 0.0;
  if (a2 >= -2.21149158e12 && a2 < 4.13644464e12)
  {
    int v3 = (int)(a2 / 10000.0);
    int v4 = (int *)((char *)&unk_180A2D650 + 4 * (int)((a2 + 2.21149158e12) * 2489.0 / 6.34793622e12) + 4);
    do
      int v5 = *--v4;
    while (v5 > v3);
    do
    {
      int v6 = v4[1];
      ++v4;
    }

    while (v6 <= v3);
    if (!(_DWORD)this) {
      --v4;
    }
    return (double)*v4 * 10000.0;
  }

  return v2;
}

void icu::CalendarAstronomer::getMoonTime( icu::CalendarAstronomer *this, double a2, icu::CalendarAstronomer *a3)
{
  int v3 = (int)a3;
  if (a2 != 0.0 || icu::CalendarAstronomer::getNewMoonTimeInRange(a3, *(double *)this) == 0.0)
  {
    int v6 = &off_18971E8D8;
    icu::CalendarAstronomer::timeOfAngle(this, (icu::CalendarAstronomer::AngleFunc *)&v6, a2, 29.5305889, 60000.0, v3);
  }

void icu::CalendarAstronomer::getMoonTime( icu::CalendarAstronomer *a1, double *a2, icu::CalendarAstronomer *a3)
{
}

double icu::CalendarAstronomer::getMoonRiseSet(icu::CalendarAstronomer *this, int a2)
{
  int v3 = &off_18971E918;
  return icu::CalendarAstronomer::riseOrSet( this,  (icu::CalendarAstronomer::CoordFunc *)&v3,  a2,  0.00930260491,  0.00989019909,  60000.0);
}

void icu::CalendarAstronomer::Ecliptic::toString(uint64_t a1@<X8>)
{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
}

void icu::CalendarAstronomer::Equatorial::toString(uint64_t a1@<X8>)
{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
}

void icu::CalendarAstronomer::Horizon::toString(uint64_t a1@<X8>)
{
  *(void *)a1 = off_18971B688;
  *(_WORD *)(a1 + 8) = 2;
}

void sub_180896868(uint64_t **a1, int *a2)
{
  if (!a1)
  {
    *a2 = 7;
    return;
  }

  int v6 = icu::UMemory::operator new(v5, (icu::UMemory *)0x10, v4);
  if (v6)
  {
    int v7 = v6;
    *int v6 = (uint64_t)&off_18971E7B8;
    v6[1] = (uint64_t)uhash_openSize((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, 0LL, 32, a2);
    *a1 = v7;
    if (*a2 < 1) {
      return;
    }
    (*(void (**)(uint64_t *))(*v7 + 8))(v7);
  }

  else
  {
    *a1 = 0LL;
    if (*a2 < 1) {
      return;
    }
  }

  *a1 = 0LL;
}

uint64_t sub_180896928()
{
  return 1LL;
}

uint64_t sub_180896930(uint64_t **a1, unsigned int a2, int *a3)
{
  if (*a3 <= 0)
  {
    umtx_lock((icu::UMutex *)&unk_18C5351A0);
    int v7 = *a1;
    if (!*a1)
    {
      sub_180896868(a1, a3);
      if (*a3 > 0)
      {
        uint64_t v3 = 0LL;
        goto LABEL_7;
      }

      int v7 = *a1;
    }

    uint64_t v3 = uhash_igeti(v7[1], a2);
LABEL_7:
    umtx_unlock((std::mutex **)&unk_18C5351A0);
    return v3;
  }

  return 0LL;
}

void sub_1808969CC(uint64_t **a1, unsigned int a2, unsigned int a3, int *a4)
{
  if (*a4 <= 0)
  {
    umtx_lock((icu::UMutex *)&unk_18C5351A0);
    int v8 = *a1;
    if (!*a1)
    {
      sub_180896868(a1, a4);
      if (*a4 > 0) {
        goto LABEL_5;
      }
      int v8 = *a1;
    }

    uhash_iputi(v8[1], a2, a3, a4);
LABEL_5:
    umtx_unlock((std::mutex **)&unk_18C5351A0);
  }

void *sub_180896A6C(void *a1)
{
  *a1 = &off_18971E7B8;
  double v2 = (_BYTE *)a1[1];
  if (v2) {
    uhash_close(v2);
  }
  return a1;
}

void sub_180896AA4(void *a1)
{
  *a1 = &off_18971E7B8;
  double v2 = (_BYTE *)a1[1];
  if (v2) {
    uhash_close(v2);
  }
  icu::UMemory::operator delete(a1);
}

double sub_180896ADC(int a1, icu::CalendarAstronomer *this)
{
  return icu::CalendarAstronomer::getSunLongitude(this);
}

icu::CalendarAstronomer::Equatorial *sub_180896AE4( int a1, icu::CalendarAstronomer::Equatorial *a2, icu::CalendarAstronomer *this)
{
  double SunLongitude = icu::CalendarAstronomer::getSunLongitude(this);
  return icu::CalendarAstronomer::eclipticToEquatorial(this, a2, SunLongitude, 0.0);
}

void sub_180896B18(int a1, icu::CalendarAstronomer *this)
{
}

__n128 sub_180896B20(int a1, __n128 *a2, icu::CalendarAstronomer *this)
{
  MoonPositiouint64_t n = (__n128 *)icu::CalendarAstronomer::getMoonPosition(this);
  __n128 result = *MoonPosition;
  *a2 = *MoonPosition;
  return result;
}

void *icu::BasicTimeZone::BasicTimeZone(icu::BasicTimeZone *this)
{
  __n128 result = (void *)icu::TimeZone::TimeZone((uint64_t)this);
  *__n128 result = off_18971E970;
  return result;
}

icu::TimeZone *icu::BasicTimeZone::BasicTimeZone(icu::BasicTimeZone *this, UChar **a2)
{
  __n128 result = icu::TimeZone::TimeZone(this, a2);
  *(void *)__n128 result = off_18971E970;
  return result;
}

{
  icu::TimeZone *result;
  __n128 result = icu::TimeZone::TimeZone(this, a2);
  *(void *)__n128 result = off_18971E970;
  return result;
}

uint64_t icu::BasicTimeZone::hasEquivalentTransitions( icu::BasicTimeZone *this, const icu::BasicTimeZone *a2, double a3, double a4, int a5, UErrorCode *a6)
{
  __int128 v55 = 0uLL;
  (*(void (**)(icu::BasicTimeZone *, void, char *, char *, UErrorCode *, double))(*(void *)this + 48LL))( this,  0LL,  (char *)&v55 + 12,  (char *)&v55 + 4,  a6,  a3);
  uint64_t v6 = 0LL;
  if (*(int *)a6 <= 0)
  {
    (*(void (**)(const icu::BasicTimeZone *, void, char *, __int128 *, UErrorCode *, double))(*(void *)a2 + 48LL))( a2,  0LL,  (char *)&v55 + 8,  &v55,  a6,  a3);
    uint64_t v6 = 0LL;
    if (*(int *)a6 <= 0)
    {
      if (a5)
      {
        if (DWORD1(v55) + HIDWORD(v55) != (_DWORD)v55 + DWORD2(v55)
          || DWORD1(v55) && !(_DWORD)v55
          || !DWORD1(v55) && (_DWORD)v55)
        {
          return 0LL;
        }
      }

      else if (__PAIR64__(HIDWORD(v55), v55) != *(void *)((char *)&v55 + 4))
      {
        return 0LL;
      }

      memset(v54, 0, sizeof(v54));
      icu::TimeZoneTransition::TimeZoneTransition(v54);
      memset(v53, 0, sizeof(v53));
      icu::TimeZoneTransition::TimeZoneTransition(v53);
      while (1)
      {
        int v14 = (*(uint64_t (**)(icu::BasicTimeZone *, void, _OWORD *, double))(*(void *)this + 112LL))( this,  0LL,  v54,  a3);
        int v15 = (*(uint64_t (**)(const icu::BasicTimeZone *, void, _OWORD *, double))(*(void *)a2 + 112LL))( a2,  0LL,  v53,  a3);
        if (a5)
        {
          if (v14)
          {
            while (icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v54) <= a4)
            {
              double v16 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v54);
              int RawOffset = icu::TimeZoneRule::getRawOffset(v16);
              double v18 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v54);
              int v19 = icu::TimeZoneRule::getDSTSavings(v18) + RawOffset;
              double v20 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54);
              int v21 = icu::TimeZoneRule::getRawOffset(v20);
              double v22 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54);
              double v23 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v54);
              uint64_t v24 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54);
              double Time = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v54);
              (*(void (**)(icu::BasicTimeZone *, void, _OWORD *, double))(*(void *)this + 112LL))( this,  0LL,  v54,  Time);
            }
          }

          if (v15)
          {
            while (icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v53) <= a4)
            {
              double v26 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v53);
              int v27 = icu::TimeZoneRule::getRawOffset(v26);
              double v28 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v53);
              int v29 = icu::TimeZoneRule::getDSTSavings(v28) + v27;
              int v30 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
              int v31 = icu::TimeZoneRule::getRawOffset(v30);
              int v32 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
              int v33 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v53);
              uint64_t v34 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
              double v35 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v53);
              (*(void (**)(const icu::BasicTimeZone *, void, _OWORD *, double))(*(void *)a2 + 112LL))( a2,  0LL,  v53,  v35);
            }
          }
        }

        if (v14) {
          int v14 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v54) <= a4;
        }
        BOOL v36 = v15 && icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v53) <= a4;
        if ((v14 | v36) != 1) {
          break;
        }
        if ((v14 & v36) != 1) {
          goto LABEL_48;
        }
        double v37 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v54);
        if (v37 != icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v53)) {
          goto LABEL_48;
        }
        unint64_t v38 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54);
        int v39 = icu::TimeZoneRule::getRawOffset(v38);
        if (a5)
        {
          int v40 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54);
          int v41 = icu::TimeZoneRule::getDSTSavings(v40) + v39;
          __int128 v42 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
          int v43 = icu::TimeZoneRule::getRawOffset(v42);
          __int128 v44 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
          if (v41 != icu::TimeZoneRule::getDSTSavings(v44) + v43
            || (uint64_t v45 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54),
                icu::TimeZoneRule::getDSTSavings(v45))
            && (unsigned int v46 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53),
                !icu::TimeZoneRule::getDSTSavings(v46))
            || (__int128 v47 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54),
                !icu::TimeZoneRule::getDSTSavings(v47))
            && (__int128 v48 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53),
                icu::TimeZoneRule::getDSTSavings(v48)))
          {
LABEL_48:
            uint64_t v6 = 0LL;
            goto LABEL_50;
          }
        }

        else
        {
          __int128 v49 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
          uint64_t v50 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v54);
          int DSTSavings = icu::TimeZoneRule::getDSTSavings(v50);
          __int128 v52 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v53);
        }

        a3 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v54);
      }

      uint64_t v6 = 1LL;
LABEL_50:
      icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v53);
      icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v54);
    }
  }

  return v6;
}

void *icu::BasicTimeZone::getSimpleRulesNear( void *this, double a2, icu::InitialTimeZoneRule **a3, icu::AnnualTimeZoneRule **a4, icu::AnnualTimeZoneRule **a5, UErrorCode *a6)
{
  uint64_t v114 = *MEMORY[0x1895F89C0];
  *a3 = 0LL;
  *a4 = 0LL;
  *a5 = 0LL;
  if (*(int *)a6 <= 0)
  {
    uint64_t v11 = (uint64_t)this;
    uint64_t v103 = 0LL;
    __int128 v110 = 0u;
    uint64_t v113 = 0LL;
    __int128 v112 = 0u;
    __int128 v111 = 0u;
    uint64_t v108 = 0LL;
    __int128 v109 = (UChar *)off_18971B688;
    LOWORD(v110) = 2;
    __int128 v105 = 0u;
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    uint64_t v104 = (UChar *)off_18971B688;
    LOWORD(v105) = 2;
    memset(v102, 0, sizeof(v102));
    icu::TimeZoneTransition::TimeZoneTransition(v102);
    if ((*(unsigned int (**)(uint64_t, void, _OWORD *, double))(*(void *)v11 + 112LL))( v11,  0LL,  v102,  a2))
    {
      double v12 = (UChar **)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
      icu::TimeZoneRule::getName(v12, &v109);
      double v13 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
      int RawOffset = icu::TimeZoneRule::getRawOffset(v13);
      HIDWORD(v103) = RawOffset;
      int v15 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
      int DSTSavings = icu::TimeZoneRule::getDSTSavings(v15);
      LODWORD(v103) = DSTSavings;
      double Time = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v102);
      double v18 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
      if (icu::TimeZoneRule::getDSTSavings(v18)
        || (int v29 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102),
            !icu::TimeZoneRule::getDSTSavings(v29)))
      {
        int v19 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
        if (icu::TimeZoneRule::getDSTSavings(v19))
        {
          double v22 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
          double v23 = 0LL;
          if (icu::TimeZoneRule::getDSTSavings(v22))
          {
            uint64_t v24 = 0LL;
            goto LABEL_54;
          }

          int v21 = (uint64_t *)&unk_180A31000;
          uint64_t v24 = 0LL;
          if (a2 + 3.1536e10 <= Time) {
            goto LABEL_54;
          }
          goto LABEL_13;
        }
      }

      else
      {
        int v21 = (uint64_t *)&unk_180A31000;
        if (a2 + 3.1536e10 > Time)
        {
LABEL_13:
          uint64_t v100 = 0LL;
          *(void *)uint64_t v101 = 0LL;
          double v98 = 0.0;
          uint64_t v99 = 0LL;
          sub_1808FA670( &v101[1],  v101,  (_DWORD *)&v100 + 1,  (int *)&v100,  (int *)&v99 + 1,  &v99,  Time + (double)RawOffset + (double)DSTSavings);
          int v30 = sub_1808FA744(v101[1], v101[0], SHIDWORD(v100));
          int v33 = icu::UMemory::operator new(v32, (icu::UMemory *)0x28, v31);
          uint64_t v34 = (icu::DateTimeRule *)v33;
          if (v33) {
            icu::DateTimeRule::DateTimeRule((uint64_t)v33, v101[0], v30, v100, v99, 0);
          }
          double v35 = (UChar **)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
          icu::TimeZoneRule::getName(v35, &v104);
          double v23 = (icu::AnnualTimeZoneRule *)icu::UMemory::operator new(v37, (icu::UMemory *)0x60, v36);
          if (v23)
          {
            unint64_t v38 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
            int v39 = icu::TimeZoneRule::getDSTSavings(v38);
            icu::AnnualTimeZoneRule::AnnualTimeZoneRule(v23, &v104, RawOffset, v39, v34, v101[1], 0x7FFFFFFF);
          }

          int v40 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
          if (icu::TimeZoneRule::getRawOffset(v40) == RawOffset
            && (*(unsigned int (**)(uint64_t, void, _OWORD *, double))(*(void *)v11 + 112LL))( v11,  0LL,  v102,  Time))
          {
            if ((int v41 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102),
                  !icu::TimeZoneRule::getDSTSavings(v41))
              && (__int128 v44 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102),
                  icu::TimeZoneRule::getDSTSavings(v44))
              || (__int128 v42 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102),
                  icu::TimeZoneRule::getDSTSavings(v42))
              && (int v43 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102),
                  !icu::TimeZoneRule::getDSTSavings(v43)))
            {
              if (Time + 3.1536e10 > icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v102))
              {
                double v45 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v102);
                unsigned int v46 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
                double v47 = v45 + (double)(int)icu::TimeZoneRule::getRawOffset(v46);
                __int128 v48 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
                int v49 = icu::TimeZoneRule::getDSTSavings(v48);
                sub_1808FA670( &v101[1],  v101,  (_DWORD *)&v100 + 1,  (int *)&v100,  (int *)&v99 + 1,  &v99,  v47 + (double)v49);
                int v50 = sub_1808FA744(v101[1], v101[0], SHIDWORD(v100));
                __int128 v53 = icu::UMemory::operator new(v52, (icu::UMemory *)0x28, v51);
                __int128 v54 = (icu::DateTimeRule *)v53;
                if (v53) {
                  icu::DateTimeRule::DateTimeRule((uint64_t)v53, v101[0], v50, v100, v99, 0);
                }
                __int128 v55 = (UChar **)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
                icu::TimeZoneRule::getName(v55, &v104);
                uint64_t v24 = icu::UMemory::operator new(v57, (icu::UMemory *)0x60, v56);
                if (v24)
                {
                  __int128 v58 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
                  int v59 = icu::TimeZoneRule::getRawOffset(v58);
                  __int128 v60 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
                  int v61 = icu::TimeZoneRule::getDSTSavings(v60);
                  icu::AnnualTimeZoneRule::AnnualTimeZoneRule( (icu::AnnualTimeZoneRule *)v24,  &v104,  v59,  v61,  v54,  v101[1] - 1,  0x7FFFFFFF);
                }

                BOOL v62 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
                uint64_t v63 = icu::TimeZoneRule::getRawOffset(v62);
                int32x4_t v64 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
                uint64_t v65 = icu::TimeZoneRule::getDSTSavings(v64);
                if ((*(unsigned int (**)(uint64_t *, uint64_t, uint64_t, uint64_t, double *, double))(*v24 + 80))( v24,  v63,  v65,  1LL,  &v98,  a2))
                {
                  v66.n128_f64[0] = v98;
                  if (v98 <= a2)
                  {
                    __int128 v67 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
                    if (RawOffset == icu::TimeZoneRule::getRawOffset(v67))
                    {
                      uint64_t v68 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
                    }
                  }
                }

                (*(void (**)(uint64_t *, __n128))(*v24 + 8))(v24, v66);
              }
            }
          }

          if ((*(unsigned int (**)(uint64_t, uint64_t, _OWORD *, double))(*(void *)v11 + 120LL))( v11,  1LL,  v102,  a2))
          {
            if ((unsigned int v69 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102),
                  !icu::TimeZoneRule::getDSTSavings(v69))
              && (__int128 v72 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102),
                  icu::TimeZoneRule::getDSTSavings(v72))
              || (__int128 v70 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102),
                  icu::TimeZoneRule::getDSTSavings(v70))
              && (__int128 v71 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102),
                  !icu::TimeZoneRule::getDSTSavings(v71)))
            {
              double v73 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v102);
              uint64_t v74 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
              double v75 = v73 + (double)(int)icu::TimeZoneRule::getRawOffset(v74);
              BOOL v76 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
              int v77 = icu::TimeZoneRule::getDSTSavings(v76);
              sub_1808FA670(&v101[1], v101, (_DWORD *)&v100 + 1, (int *)&v100, (int *)&v99 + 1, &v99, v75 + (double)v77);
              int v78 = sub_1808FA744(v101[1], v101[0], SHIDWORD(v100));
              int v81 = icu::UMemory::operator new(v80, (icu::UMemory *)0x28, v79);
              uint64_t v82 = (icu::DateTimeRule *)v81;
              if (v81) {
                icu::DateTimeRule::DateTimeRule((uint64_t)v81, v101[0], v78, v100, v99, 0);
              }
              uint64_t v83 = (UChar **)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v102);
              icu::TimeZoneRule::getName(v83, &v104);
              uint64_t v24 = icu::UMemory::operator new(v85, (icu::UMemory *)0x60, v84);
              if (v24)
              {
                StartYeaunint64_t r = icu::AnnualTimeZoneRule::getStartYear(v23);
                icu::AnnualTimeZoneRule::AnnualTimeZoneRule( (icu::AnnualTimeZoneRule *)v24,  &v104,  RawOffset,  DSTSavings,  v82,  StartYear - 1,  0x7FFFFFFF);
              }

              int v87 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
              uint64_t v88 = icu::TimeZoneRule::getRawOffset(v87);
              int v89 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v102);
              uint64_t v90 = icu::TimeZoneRule::getDSTSavings(v89);
              if ((*(unsigned int (**)(uint64_t *, uint64_t, uint64_t, void, double *, double))(*v24 + 72))( v24,  v88,  v90,  0LL,  &v98,  a2))
              {
                v91.n128_f64[0] = v98;
                if (v98 > Time)
                {
LABEL_50:
                  icu::TimeZoneRule::getName((UChar **)v23, &v109);
                  HIDWORD(v103) = icu::TimeZoneRule::getRawOffset(v23);
                  int v28 = icu::TimeZoneRule::getDSTSavings(v23);
                  goto LABEL_10;
                }
              }

              (*(void (**)(uint64_t *, __n128))(*v24 + 8))(v24, v91);
            }
          }

          if (v23)
          {
            (*(void (**)(icu::AnnualTimeZoneRule *))(*(void *)v23 + 8LL))(v23);
            uint64_t v24 = 0LL;
            double v23 = 0LL;
            goto LABEL_54;
          }

void icu::BasicTimeZone::getTimeZoneRulesAfter( icu::BasicTimeZone *this, double a2, icu::InitialTimeZoneRule **a3, icu::UVector **a4, UErrorCode *a5)
{
  uint64_t v112 = *MEMORY[0x1895F89C0];
  uint64_t v106 = 0LL;
  memset(v105, 0, sizeof(v105));
  icu::TimeZoneTransition::TimeZoneTransition(v105);
  __int128 v108 = 0u;
  uint64_t v111 = 0LL;
  __int128 v110 = 0u;
  __int128 v109 = 0u;
  int v104 = 0;
  __int128 v107 = (UChar *)off_18971B688;
  LOWORD(v108) = 2;
  double v102 = 0.0;
  double v103 = 0.0;
  double v101 = 0.0;
  *a3 = 0LL;
  *a4 = 0LL;
  int v104 = (*(uint64_t (**)(icu::BasicTimeZone *, UErrorCode *))(*(void *)this + 136LL))(this, a5);
  uint64_t v11 = *(unsigned int *)a5;
  double v12 = icu::UMemory::operator new((uint64_t *)v11, (icu::UMemory *)0x28, v10);
  if (!v12)
  {
    uint64_t v11 = *(unsigned int *)a5;
    if ((int)v11 <= 0)
    {
      uint64_t v11 = 7LL;
      *a5 = U_MEMORY_ALLOCATION_ERROR;
    }

    goto LABEL_118;
  }

  double v13 = (icu::UVector *)v12;
  icu::UVector::UVector(v12, uprv_deleteUObject, 0LL, v104, a5);
  int v14 = (void **)uprv_malloc(8LL * v104);
  if (!v14)
  {
LABEL_106:
    *a5 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_116;
  }

  (*(void (**)(icu::BasicTimeZone *, uint64_t *, void **, int *, UErrorCode *))(*(void *)this + 144LL))( this,  &v106,  v14,  &v104,  a5);
  if (v104 >= 1)
  {
    for (uint64_t i = 0LL; i < v104; ++i)
    {
      double v16 = (void *)(*(uint64_t (**)(void *))(*v14[i] + 24LL))(v14[i]);
      if (v16) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = *a5 <= U_ZERO_ERROR;
      }
      if (v17) {
        *a5 = U_MEMORY_ALLOCATION_ERROR;
      }
      icu::UVector::adoptElement(v13, v16, a5);
    }
  }

  if (!(*(unsigned int (**)(icu::BasicTimeZone *, uint64_t, _OWORD *, double))(*(void *)this + 120LL))( this,  1LL,  v105,  a2))
  {
    uint64_t v82 = (icu::InitialTimeZoneRule *)(*(uint64_t (**)(uint64_t))(*(void *)v106 + 24LL))(v106);
    *a3 = v82;
    if (v82)
    {
      *a4 = v13;
      uprv_free(v14);
      goto LABEL_118;
    }

    goto LABEL_106;
  }

  unint64_t v20 = uprv_malloc(v104);
  if (!v20)
  {
LABEL_108:
    *a5 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_115;
  }

  int v21 = icu::UMemory::operator new(v19, (icu::UMemory *)0x28, v18);
  if (!v21)
  {
    goto LABEL_108;
  }

  double v22 = (icu::UVector *)v21;
  icu::UVector::UVector((uint64_t)v21, (uint64_t)uprv_deleteUObject, 0LL, (int *)a5);
  unint64_t v96 = v20;
  double v23 = (UChar **)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v105);
  icu::TimeZoneRule::getName(v23, &v107);
  double v26 = icu::UMemory::operator new(v25, (icu::UMemory *)0x50, v24);
  if (!v26)
  {
    goto LABEL_114;
  }

  int v27 = (icu::InitialTimeZoneRule *)v26;
  int v28 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v105);
  int RawOffset = icu::TimeZoneRule::getRawOffset(v28);
  int v30 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v105);
  int DSTSavings = icu::TimeZoneRule::getDSTSavings(v30);
  int v95 = v27;
  icu::InitialTimeZoneRule::InitialTimeZoneRule(v27, &v107, RawOffset, DSTSavings);
  int v89 = v22;
  unint64_t v20 = v96;
  if (v104 >= 1)
  {
    for (uint64_t j = 0LL;
          j < v104;
          v96[j++] = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, void, double *, double))(*(void *)v33 + 72LL))( v33,  v34,  v35,  0LL,  &v103,  a2) == 0)
    {
      uint64_t v33 = icu::UVector::elementAt(v13, j);
      uint64_t v34 = icu::TimeZoneRule::getRawOffset(v95);
      uint64_t v35 = icu::TimeZoneRule::getDSTSavings(v95);
      unint64_t v20 = v96;
    }
  }

  int v36 = 0;
  int v92 = 0;
  double v103 = a2;
  while (1)
  {
    if (!(*(unsigned int (**)(icu::BasicTimeZone *, void, _OWORD *, double))(*(void *)this + 112LL))( this,  0LL,  v105,  v103))
    {
LABEL_101:
      *a3 = v95;
      *a4 = v89;
      goto LABEL_115;
    }

    double Time = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v105);
    if (Time == v103) {
      goto LABEL_111;
    }
    double v103 = Time;
    unint64_t v38 = (const void *)icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v105);
    int v39 = v104;
    if (v104 < 1)
    {
      unsigned int k = 0;
    }

    else
    {
      for (unsigned int k = 0; (int)k < v104; ++k)
      {
        uint64_t v41 = icu::UVector::elementAt(v13, k);
        char v42 = (*(uint64_t (**)(uint64_t, const void *))(*(void *)v41 + 32LL))(v41, v38);
        int v39 = v104;
        if ((v42 & 1) != 0) {
          break;
        }
      }
    }

    if ((int)k >= v39)
    {
LABEL_111:
      *a5 = U_INVALID_STATE_ERROR;
      goto LABEL_112;
    }

    if (!v20[k]) {
      break;
    }
LABEL_99:
    if ((_BYTE)v92 && (_BYTE)v36) {
      goto LABEL_101;
    }
  }

  if (!v38)
  {
LABEL_98:
    v20[k] = 1;
    goto LABEL_99;
  }

  if (!v93)
  {
    int v87 = v36;
    if (!v47) {
      goto LABEL_92;
    }
    __int128 v48 = v47;
    int v49 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v105);
    uint64_t v50 = icu::TimeZoneRule::getRawOffset(v49);
    unint64_t v51 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v105);
    uint64_t v52 = icu::TimeZoneRule::getDSTSavings(v51);
    (*((void (**)(UChar **, uint64_t, uint64_t, double *))*v48 + 7))(v48, v50, v52, &v101);
    double v53 = v101;
    if (v53 == icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v105))
    {
      __int128 v54 = (void *)(*((uint64_t (**)(UChar **))*v48 + 3))(v48);
      if (v54) {
        BOOL v55 = 0;
      }
      else {
        BOOL v55 = *a5 <= U_ZERO_ERROR;
      }
      if (v55) {
        *a5 = U_MEMORY_ALLOCATION_ERROR;
      }
      double v22 = v89;
      icu::UVector::adoptElement(v89, v54, a5);
    }

    else
    {
      LODWORD(v100[0]) = 0;
      uint64_t v98 = 0LL;
      uint64_t v99 = 0LL;
      int v97 = 0;
      double v68 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v105);
      sub_1808FA670((int *)v100, (_DWORD *)&v99 + 1, &v99, (int *)&v98 + 1, (int *)&v98, &v97, v68);
      icu::TimeZoneRule::getName(v48, &v107);
      __int128 v71 = (icu::AnnualTimeZoneRule *)icu::UMemory::operator new(v70, (icu::UMemory *)0x60, v69);
      if (v71)
      {
        int v94 = icu::TimeZoneRule::getRawOffset((icu::TimeZoneRule *)v48);
        int v91 = icu::TimeZoneRule::getDSTSavings((icu::TimeZoneRule *)v48);
        Rule = (const icu::DateTimeRule *)icu::AnnualTimeZoneRule::getRule((icu::AnnualTimeZoneRule *)v48);
        int v85 = v100[0];
        EndYeaunint64_t r = icu::AnnualTimeZoneRule::getEndYear((icu::AnnualTimeZoneRule *)v48);
        icu::AnnualTimeZoneRule::AnnualTimeZoneRule( v71,  (const icu::UnicodeString *)&v107,  v94,  v91,  Rule,  v85,  EndYear);
      }

      else if (*(int *)a5 <= 0)
      {
        *a5 = U_MEMORY_ALLOCATION_ERROR;
      }

      double v22 = v89;
      icu::UVector::adoptElement(v89, v71, a5);
    }

    if (icu::AnnualTimeZoneRule::getEndYear((icu::AnnualTimeZoneRule *)v48) == 0x7FFFFFFF)
    {
      int v80 = icu::TimeZoneRule::getDSTSavings((icu::TimeZoneRule *)v48);
      int v81 = v92;
      if (!v80) {
        int v81 = 1;
      }
      int v92 = v81;
      int v36 = v87;
      if (v80) {
        int v36 = 1;
      }
      unint64_t v20 = v96;
    }

    else
    {
LABEL_92:
      unint64_t v20 = v96;
      int v36 = v87;
    }

    goto LABEL_98;
  }

  memset(v100, 0, sizeof(v100));
  icu::TimeZoneTransition::TimeZoneTransition(v100);
  double v102 = a2;
  v43.n128_f64[0] = a2;
  for (int m = (*(uint64_t (**)(icu::BasicTimeZone *, void, _OWORD *, __n128))(*(void *)this + 112LL))( this,  0LL,  v100,  v43);
        ;
        int m = (*(uint64_t (**)(icu::BasicTimeZone *, void, _OWORD *, __n128))(*(void *)this + 112LL))( this,  0LL,  v100,  v46))
  {
    if (!m) {
      goto LABEL_97;
    }
    uint64_t v45 = icu::TimeZoneTransition::getTo((icu::TimeZoneTransition *)v100);
    v46.n128_f64[0] = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v100);
    double v102 = v46.n128_f64[0];
  }

  int v88 = v36;
  unint64_t v56 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v105);
  uint64_t v57 = icu::TimeZoneRule::getRawOffset(v56);
  __int128 v58 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v105);
  uint64_t v59 = icu::TimeZoneRule::getDSTSavings(v58);
  (*(void (**)(icu::TimeZoneRule *, uint64_t, uint64_t, double *))(*(void *)v93 + 56LL))( v93,  v57,  v59,  &v101);
  if (v101 > a2)
  {
    __int128 v60 = (void *)(*(uint64_t (**)(icu::TimeZoneRule *, double))(*(void *)v93 + 24LL))(v93, v101);
    if (v60) {
      BOOL v61 = 0;
    }
    else {
      BOOL v61 = *a5 <= U_ZERO_ERROR;
    }
    if (v61) {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
    }
    icu::UVector::adoptElement(v89, v60, a5);
    unint64_t v20 = v96;
    int v36 = v88;
LABEL_97:
    icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v100);
    goto LABEL_98;
  }

  int started = icu::TimeArrayTimeZoneRule::countStartTimes(v93);
  int TimeType = icu::TimeArrayTimeZoneRule::getTimeType(v93);
  int v90 = started;
  if (started >= 1)
  {
    unsigned int v63 = 0;
    while (1)
    {
      icu::TimeArrayTimeZoneRule::getStartTimeAt(v93, v63, &v102);
      if (TimeType)
      {
        if (TimeType != 1)
        {
          double v67 = v102;
          goto LABEL_70;
        }

        int32x4_t v64 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v105);
        int v65 = icu::TimeZoneRule::getRawOffset(v64);
      }

      else
      {
        __n128 v66 = (icu::TimeZoneRule *)icu::TimeZoneTransition::getFrom((icu::TimeZoneTransition *)v105);
        int v65 = icu::TimeZoneRule::getDSTSavings(v66);
      }

      double v67 = v102 - (double)v65;
      double v102 = v67;
LABEL_70:
      if (v67 > a2) {
        goto LABEL_76;
      }
      if (started == ++v63)
      {
        unsigned int v63 = started;
        goto LABEL_76;
      }
    }
  }

  unsigned int v63 = 0;
LABEL_76:
  unint64_t v20 = v96;
  int v36 = v88;
  uint64_t v86 = v90 - v63;
  unint64_t v84 = (double *)uprv_malloc(8LL * (v90 - v63));
  if (v84)
  {
    for (uint64_t n = 0LL; n != v86; ++n)
      icu::TimeArrayTimeZoneRule::getStartTimeAt(v93, v63++, &v84[n]);
    icu::TimeZoneRule::getName((UChar **)v93, &v107);
    int v77 = icu::UMemory::operator new(v76, (icu::UMemory *)0x160, v75);
    if (v77)
    {
      int v78 = icu::TimeZoneRule::getRawOffset(v93);
      int v79 = icu::TimeZoneRule::getDSTSavings(v93);
      icu::TimeArrayTimeZoneRule::TimeArrayTimeZoneRule((uint64_t)v77, &v107, v78, v79, v84, v86, TimeType);
    }

    else if (*(int *)a5 <= 0)
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
    }

    icu::UVector::adoptElement(v89, v77, a5);
    uprv_free(v84);
    unint64_t v20 = v96;
    int v36 = v88;
    goto LABEL_97;
  }

  *a5 = U_MEMORY_ALLOCATION_ERROR;
LABEL_121:
  uprv_free(v84);
LABEL_122:
  icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v100);
LABEL_112:
  double v22 = v89;
LABEL_113:
  (*(void (**)(icu::TimeZoneRule *))(*(void *)v95 + 8LL))(v95);
  unint64_t v20 = v96;
LABEL_114:
  (*(void (**)(icu::UVector *))(*(void *)v22 + 8LL))(v22);
LABEL_115:
  uprv_free(v20);
LABEL_116:
  uprv_free(v14);
LABEL_117:
  (*(void (**)(icu::UVector *))(*(void *)v13 + 8LL))(v13);
LABEL_118:
  icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)&v107);
  icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v105);
}

void icu::BasicTimeZone::getOffsetFromLocal( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*a6 <= 0) {
    *a6 = 16;
  }
}

uint64_t icu::BasicTimeZone::getOffsetFromLocal( icu::BasicTimeZone *this, double a2, uint64_t a3, uint64_t a4, int *a5, int *a6, UErrorCode *a7)
{
  return (*(uint64_t (**)(icu::BasicTimeZone *, uint64_t, uint64_t, int *, int *, UErrorCode *, double))(*(void *)this + 160LL))( this,  a3,  a4,  a5,  a6,  a7,  a2);
}

uint64_t sub_18089817C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (a3 >= 1)
  {
    int v8 = 0;
    unsigned int v40 = 2 * a3;
    int v41 = 0;
    memset(v42, 0, sizeof(v42));
    while (1)
    {
      uint64_t v9 = a4;
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, _OWORD *, uint64_t, int *))(*(void *)a4 + 24LL))( a4,  1LL,  v40,  v42,  64LL,  &v41);
      uint64_t v11 = v41;
      if (v41 > 15)
      {
        double v12 = (_OWORD *)v10;
      }

      else
      {
        int v41 = 64;
        double v12 = v42;
        uint64_t v11 = 64LL;
      }

      if (v8 < a3)
      {
        unint64_t v13 = (unint64_t)v12 + v11 - 4;
      }

      LODWORD(v14) = (_DWORD)v12;
LABEL_63:
      (*(void (**)(uint64_t, _OWORD *, void, uint64_t, uint64_t))(*(void *)v9 + 16LL))( v9,  v12,  ((_DWORD)v14 - (_DWORD)v12),  56320LL,  4238353408LL);
      a4 = v9;
      if (v8 >= a3) {
        return a1;
      }
    }

    int v14 = v12;
    while (1)
    {
      else {
        int v15 = a1 & 0xFFFFFF80 ^ 0xFFFFFFB0;
      }
      uint64_t v16 = v8 + 1LL;
      a1 = *(unsigned __int16 *)(a2 + 2LL * v8);
      BOOL v17 = (a1 & 0xFC00) != 0xD800 || (_DWORD)v16 == a3;
      if (v17 || (int v18 = *(unsigned __int16 *)(a2 + 2 * v16), (v18 & 0xFC00) != 0xDC00))
      {
        if ((_DWORD)a1 == 65534)
        {
          a1 = 0LL;
          *v14++ = 2;
          ++v8;
          goto LABEL_59;
        }

        ++v8;
      }

      else
      {
        v8 += 2;
        a1 = (v18 + ((_DWORD)a1 << 10) - 56613888);
      }

      unsigned int v19 = a1 + v15;
      if ((int)v19 < -80)
      {
        if (v19 >= 0xFFFFD654)
        {
          int v20 = -v19;
          unsigned int v21 = (unsigned __int16)v20 / 0xFDu;
          unsigned int v22 = (unsigned __int16)v20 % 0xFDu;
          int v23 = -v21;
          BOOL v24 = (unsigned __int16)v22 == 0;
          if ((_WORD)v22) {
            unsigned int v19 = -v22;
          }
          else {
            LOBYTE(v19) = 3;
          }
          if (!v24) {
            LOBYTE(v23) = ~(_BYTE)v21;
          }
          *int v14 = v23 + 49;
          goto LABEL_33;
        }

        unsigned int v25 = -v19 / 0xFD;
        if (-v19 == 253 * v25) {
          unsigned int v26 = -v19 / 0xFD;
        }
        else {
          unsigned int v26 = v25 + 1;
        }
        if (-v19 == 253 * v25) {
          LOBYTE(v27) = 3;
        }
        else {
          unsigned int v27 = -(-v19 % 0xFD);
        }
        if (v19 >= 0xFFFD0EEE)
        {
          v14[2] = v27;
          unsigned int v28 = (unsigned __int16)v26 / 0xFDu;
          unsigned int v29 = v26 - 253 * v28;
          unsigned int v30 = -v28;
          BOOL v31 = (unsigned __int16)v29 == 0;
          if ((_WORD)v29) {
            int v32 = -v29;
          }
          else {
            LOBYTE(v32) = 3;
          }
          v14[1] = v32;
          if (!v31) {
            LOBYTE(v30) = ~(_BYTE)v28;
          }
          LOBYTE(v30) = v30 + 7;
          goto LABEL_49;
        }

        void v14[3] = v27;
        unsigned int v34 = v26 / 0xFD;
        unsigned int v35 = v26 % 0xFD;
        if (v35)
        {
          ++v34;
          int v36 = -v35;
        }

        else
        {
          LOBYTE(v36) = 3;
        }

        v14[2] = v36;
        unsigned int v37 = v34 - 253 * ((unsigned __int16)v34 / 0xFDu);
        if ((_WORD)v37) {
          int v38 = -v37;
        }
        else {
          LOBYTE(v38) = 3;
        }
        v14[1] = v38;
        *int v14 = 3;
      }

      else
      {
        if ((int)v19 <= 80)
        {
          *v14++ = v19 - 127;
          goto LABEL_59;
        }

        if (v19 >> 2 <= 0xA6A)
        {
          *int v14 = (unsigned __int16)v19 / 0xFDu - 46;
          LOBYTE(v19) = (unsigned __int16)v19 % 0xFDu + 3;
LABEL_33:
          v14[1] = v19;
          v14 += 2;
          goto LABEL_59;
        }

        unsigned int v33 = v19 % 0xFD + 3;
        if (v19 <= 0x2F111)
        {
          v14[2] = v33;
          v14[1] = (unsigned __int16)(v19 / 0xFD) % 0xFDu + 3;
          unsigned int v30 = v19 / 0xFA09 - 4;
LABEL_49:
          *int v14 = v30;
          v14 += 3;
          goto LABEL_59;
        }

        void v14[3] = v33;
        v14[2] = v19 / 0xFD - -3 * ((33952311 * (unint64_t)(v19 / 0xFD)) >> 33) + 3;
        v14[1] = (unsigned __int16)(v19 / 0xFA09) % 0xFDu + 3;
        *int v14 = -1;
      }

      v14 += 4;
LABEL_59:
    }
  }

  return a1;
}

void *icu::BreakTransliterator::getStaticClassID(icu::BreakTransliterator *this)
{
  return &unk_18C5351F0;
}

void *sub_180898560()
{
  return &unk_18C5351F0;
}

icu::Transliterator *sub_18089856C(icu::Transliterator *a1, icu::UnicodeFilter *a2)
{
  _OWORD v7[8] = *(UChar **)MEMORY[0x1895F89C0];
  uint64_t v6 = L"Any-BreakInternal";
  icu::UnicodeString::UnicodeString(v7, 1LL, &v6);
  icu::Transliterator::Transliterator(a1, v7, a2);
  icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
  *(void *)a1 = off_18971EA40;
  *((void *)a1 + 1sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)a1 + 12) = 0LL;
  icu::UnicodeString::UnicodeString((uint64_t)a1 + 104, 32);
  return a1;
}

void sub_180898628(void *a1)
{
  *a1 = off_18971EA40;
  icu::UnicodeString::~UnicodeString(off_18971EA40, (icu::UnicodeString *)(a1 + 13));
  uint64_t v2 = a1[12];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[11];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  icu::Transliterator::~Transliterator((icu::Transliterator *)a1);
}

void sub_180898684(void *a1)
{
}

icu::Transliterator *sub_180898698@<X0>(UChar **a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v4 = (icu::Transliterator *)icu::UMemory::operator new(a3, (icu::UMemory *)0xA8, a2);
  int v5 = v4;
  if (v4)
  {
    icu::Transliterator::Transliterator(v4, a1);
    *(void *)int v5 = off_18971EA40;
    *((void *)v5 + 1sub_18086E18C((uint64_t)this, 1) = 0LL;
    *((void *)v5 + 12) = 0LL;
    icu::UnicodeString::UnicodeString((icu::Transliterator *)((char *)v5 + 104), a1 + 13);
  }

  return v5;
}

icu::UVector32 *sub_1808986F0(uint64_t a1, const void *a2, _DWORD *a3, int a4)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  UErrorCode v34 = U_ZERO_ERROR;
  umtx_lock(0LL);
  Worduint64_t Instance = *(char **)(a1 + 88);
  uint64_t v9 = *(icu::UVector32 **)(a1 + 96);
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  umtx_unlock(0LL);
  if (WordInstance)
  {
    if (v9) {
      goto LABEL_3;
    }
LABEL_6:
    __n128 result = (icu::UVector32 *)icu::UMemory::operator new(v12, (icu::UMemory *)0x20, v11);
    if (!result) {
      goto LABEL_45;
    }
    uint64_t v9 = result;
    icu::UVector32::UVector32(result, &v34);
    if (!WordInstance) {
      goto LABEL_44;
    }
    goto LABEL_8;
  }

  English = (char **)icu::Locale::getEnglish(v10);
  Worduint64_t Instance = icu::BreakIterator::createWordInstance(English, (const icu::Locale *)&v34, v14, v15);
  if (!v9) {
    goto LABEL_6;
  }
LABEL_3:
  if (!WordInstance) {
    goto LABEL_44;
  }
LABEL_8:
  if (v34 > U_ZERO_ERROR)
  {
LABEL_44:
    __n128 result = (icu::UVector32 *)(*(uint64_t (**)(icu::UVector32 *))(*(void *)v9 + 8LL))(v9);
    goto LABEL_45;
  }

  icu::UVector32::removeAllElements((uint64_t)v9);
  memset(v35, 0, sizeof(v35));
  sub_1808989E8(a2, (uint64_t)v35);
  (*(void (**)(char *, _OWORD *))(*(void *)WordInstance + 56LL))(WordInstance, v35);
  (*(void (**)(char *, void))(*(void *)WordInstance + 128LL))(WordInstance, a3[2]);
  int v17 = (*(uint64_t (**)(char *))(*(void *)WordInstance + 104LL))(WordInstance);
  int v18 = (uint64_t *)a3[3];
  if (v17 != -1 && v17 < (int)v18)
  {
    int v20 = v17;
    while (1)
    {
      if (v20)
      {
        UChar32 v21 = icu::UnicodeString::char32At(v18, (icu::UnicodeString *)v35, v20 - 1);
        unsigned int v22 = (uint64_t *)(1 << u_charType(v21));
        if (((unsigned __int16)v22 & 0x1FE) != 0)
        {
          UChar32 v23 = icu::UnicodeString::char32At(v22, (icu::UnicodeString *)v35, v20);
          if (((1 << u_charType(v23)) & 0x1FE) != 0)
          {
            int v24 = *((_DWORD *)v9 + 2);
            if (v24 >= -1 && *((_DWORD *)v9 + 3) > v24) {
              goto LABEL_22;
            }
          }
        }
      }

icu::UnicodeString *sub_1808989E8@<X0>(const void *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0LL;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = off_18971B688;
  *(_WORD *)(a2 + 8) = 2;
  if (v4) {
    return icu::UnicodeString::operator=((UChar **)a2, v4);
  }
  uint64_t v6 = (*(uint64_t (**)(const void *))(*(void *)a1 + 64LL))(a1);
  return (icu::UnicodeString *)(*(uint64_t (**)(const void *, void, uint64_t, uint64_t))(*(void *)a1 + 24LL))( a1,  0LL,  v6,  a2);
}

uint64_t sub_180898A8C(uint64_t a1)
{
  return a1 + 104;
}

icu::UnicodeString *sub_180898A94(uint64_t a1, UChar **a2)
{
  return icu::UnicodeString::operator=((UChar **)(a1 + 104), a2);
}

void *icu::BuddhistCalendar::getStaticClassID(icu::BuddhistCalendar *this)
{
  return &unk_18C5351F4;
}

void *sub_180898AA8()
{
  return &unk_18C5351F4;
}

icu::GregorianCalendar *sub_180898AB4(icu::GregorianCalendar *a1, char **a2, UErrorCode *a3)
{
  int v5 = icu::GregorianCalendar::GregorianCalendar(a1, a2, a3);
  *(void *)int v5 = &off_18971EB00;
  icu::Calendar::getNow(v5);
  icu::Calendar::setTimeInMillis((uint64_t)a1, v6, a3);
  return a1;
}

void sub_180898B00(icu::GregorianCalendar *a1)
{
}

void sub_180898B14(const icu::GregorianCalendar *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v4 = (icu::GregorianCalendar *)icu::UMemory::operator new(a3, (icu::UMemory *)0x290, a2);
  if (v4)
  {
    icu::GregorianCalendar::GregorianCalendar(v4, a1);
    *int v5 = &off_18971EB00;
  }

const char *sub_180898B50()
{
  return "buddhist";
}

uint64_t sub_180898B5C(_DWORD *a1)
{
  if (icu::Calendar::newerField((uint64_t)a1, 0x13u, 1u) == 19)
  {
  }

  else if ((int)a1[34] >= 1)
  {
    return (a1[4] - 543);
  }

  return 1970LL;
}

double sub_180898BBC(uint64_t a1, int a2, UErrorCode *a3)
{
  int v4 = *(_DWORD *)(a1 + 88) + 543;
  *(_WORD *)(a1 + 108) = 257;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = v4;
  *(void *)&double result = 0x100000001LL;
  *(void *)(a1 + 132) = 0x100000001LL;
  return result;
}

uint64_t sub_180898BF8(uint64_t a1, int a2, int a3)
{
  if (a2) {
    return icu::GregorianCalendar::handleGetLimit(a1, a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_180898C08()
{
  return 1LL;
}

double sub_180898C10()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_18C5351F8);
  if (v0 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C5351F8))
  {
    sub_180898C5C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C5351F8);
  }

  return *(double *)&qword_18C448398;
}

void sub_180898C5C()
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  UErrorCode v3 = U_ZERO_ERROR;
  bzero(v5, 0x290uLL);
  icu::Locale::Locale((icu::Locale *)v4, "@calendar=buddhist", 0LL, 0LL, 0LL);
  sub_180898AB4((icu::GregorianCalendar *)v5, v4, &v3);
  icu::Locale::~Locale((icu::Locale *)v4);
  if (v3 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v5, v1, &v3);
    icu::Calendar::add(v5, 1u, -80, &v3);
    double TimeInMillis = icu::Calendar::getTimeInMillis((icu::Calendar *)v5, &v3);
    dword_18C4483A0 = icu::Calendar::get(v5, 1u, &v3);
    qword_18C448398 = *(void *)&TimeInMillis;
  }

  icu::GregorianCalendar::~GregorianCalendar((icu::GregorianCalendar *)v5);
}

uint64_t sub_180898D5C()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_18C5351F8);
  if (v0 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C5351F8))
  {
    sub_180898C5C();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C5351F8);
  }

  return dword_18C4483A0;
}

void icu::SharedCalendar::~SharedCalendar(icu::SharedCalendar *this)
{
  *(void *)this = off_18971ED00;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::SharedObject::~SharedObject(this);
}

{
  uint64_t v2;
  *(void *)this = off_18971ED00;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::SharedObject::~SharedObject(this);
}

{
  uint64_t v2;
  void *v3;
  *(void *)this = off_18971ED00;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::SharedObject::~SharedObject(this);
  icu::UMemory::operator delete(v3);
}

uint64_t *icu::LocaleCacheKey<icu::SharedCalendar>::createObject(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t Instance = icu::Calendar::makeInstance((icu::Calendar *)(a1 + 16), a3, a3);
  uint64_t v6 = (uint64_t *)*(unsigned int *)a3;
  uint64_t v9 = Instance;
  uint64_t v10 = icu::UMemory::operator new(v6, (icu::UMemory *)0x20, v5);
  if (v10)
  {
    int v7 = v10;
    *uint64_t v10 = (uint64_t)off_18971ED00;
    v10[1] = 0LL;
    void v10[2] = 0LL;
    v10[3] = (uint64_t)v9;
    icu::SharedObject::addRef((uint64_t)v10);
  }

  else
  {
    if (v9) {
      (*(void (**)(void *))(*(void *)v9 + 8LL))(v9);
    }
    int v7 = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v7;
}

void *icu::Calendar::makeInstance(icu::Calendar *this, UErrorCode *a2, UErrorCode *a3)
{
  v41[8] = *(void **)MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    memset(v38, 0, sizeof(v38));
    icu::Locale::Locale((icu::Locale *)v38);
    uint64_t v6 = (char *)*((void *)this + 5);
    int v37 = 0;
    memset(&v41[1], 0, 56);
    v41[0] = (char *)&v41[1] + 5;
    LODWORD(v41[1]) = 40;
    v39[0] = 0LL;
    v39[1] = 0LL;
    icu::CharStringByteSink::CharStringByteSink(v39, (uint64_t)v41);
    ulocimp_canonicalize(v6);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v39);
    memset(&v39[1], 0, 48);
    uint64_t v40 = 0LL;
    v39[0] = (char *)&v39[1] + 5;
    LODWORD(v39[1]) = 40;
    v36[0] = 0LL;
    v36[1] = 0LL;
    icu::CharStringByteSink::CharStringByteSink(v36, (uint64_t)v39);
    ulocimp_getKeywordValue((char *)v41[0], "calendar", (uint64_t)v36, &v37);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v36);
    if (v37 > 0) {
      goto LABEL_9;
    }
    uint64_t v7 = 0LL;
    int v8 = v39[0];
    while (uprv_stricmp(v8, (unsigned __int8 *)off_18971EF78[v7]))
    {
      if (++v7 == 18) {
        goto LABEL_9;
      }
    }

    if ((_DWORD)v7 == -1)
    {
LABEL_9:
      int v37 = 0;
      LODWORD(v36[0]) = 0;
      ulocimp_getRegionForSupplementalData((char *)v41[0], 1, (char *)v36, 4, &v37);
      LODWORD(v7) = 0;
      if (v37 <= 0)
      {
        uint64_t v10 = ures_openDirect(0LL, (uint64_t)"supplementalData", (uint64_t)&v37);
        ures_getByKey(v10, "calendarPreferenceData", v10, &v37);
        uint64_t v11 = ures_getByKey(v10, (const char *)v36, 0LL, &v37);
        if (v10 && v37 == 2)
        {
          int v37 = 0;
          uint64_t v11 = ures_getByKey(v10, "001", 0LL, &v37);
        }

        LODWORD(v40) = 0;
        *(_BYTE *)v39[0] = 0;
        LODWORD(v12) = -1;
        if (v37 <= 0 && v11)
        {
          int32_t v35 = 0;
          StringByIndex = (UChar *)ures_getStringByIndex(v11, 0, &v35, &v37);
          icu::CharString::appendInvariantChars((int *)v39, StringByIndex, v35, (UErrorCode *)&v37);
          uint64_t v12 = 0LL;
          int v14 = v39[0];
          while (uprv_stricmp(v14, (unsigned __int8 *)off_18971EF78[v12]))
          {
            if (++v12 == 18)
            {
              LODWORD(v12) = -1;
              break;
            }
          }
        }

        ures_close(v11);
        ures_close(v10);
        if ((_DWORD)v12 == -1) {
          LODWORD(v7) = 0;
        }
        else {
          LODWORD(v7) = v12;
        }
      }
    }

    if (BYTE4(v39[1])) {
      uprv_free(v39[0]);
    }
    if (BYTE4(v41[1])) {
      uprv_free(v41[0]);
    }
    if (*(int *)a2 > 0)
    {
LABEL_27:
      UErrorCode v3 = 0LL;
LABEL_28:
      icu::Locale::~Locale((icu::Locale *)v38);
      return v3;
    }

    switch((int)v7)
    {
      case 0:
        uint64_t v16 = (icu::GregorianCalendar *)icu::UMemory::operator new( (uint64_t *)v7,  (icu::UMemory *)0x290,  v9);
        if (!v16) {
          goto LABEL_71;
        }
        UErrorCode v3 = v16;
        icu::GregorianCalendar::GregorianCalendar(v16, this, a2);
        goto LABEL_68;
      case 1:
        int v18 = icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x290, v9);
        if (!v18) {
          goto LABEL_71;
        }
        UErrorCode v3 = v18;
        sub_1808FDCDC(v18, this, a2);
        goto LABEL_68;
      case 2:
        unsigned int v19 = (icu::GregorianCalendar *)icu::UMemory::operator new( (uint64_t *)v7,  (icu::UMemory *)0x290,  v9);
        if (!v19) {
          goto LABEL_71;
        }
        UErrorCode v3 = v19;
        sub_180898AF8(v19, (char **)this, a2);
        goto LABEL_68;
      case 3:
        int v20 = icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x290, v9);
        if (!v20) {
          goto LABEL_71;
        }
        UErrorCode v3 = v20;
        sub_180992954(v20, this, a2);
        goto LABEL_68;
      case 4:
        UChar32 v21 = icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v21) {
          goto LABEL_71;
        }
        UErrorCode v3 = v21;
        sub_18094F828(v21, this, a2);
        goto LABEL_68;
      case 5:
        unsigned int v22 = (icu::IslamicCivilCalendar *)icu::UMemory::operator new( (uint64_t *)v7,  (icu::UMemory *)0x270,  v9);
        if (!v22) {
          goto LABEL_71;
        }
        UErrorCode v3 = v22;
        icu::IslamicCivilCalendar::IslamicCivilCalendar(v22, (char **)this, a2);
        goto LABEL_68;
      case 6:
        UChar32 v23 = (icu::IslamicCalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v23) {
          goto LABEL_71;
        }
        UErrorCode v3 = v23;
        icu::IslamicCalendar::IslamicCalendar(v23, this, a2);
        goto LABEL_68;
      case 7:
        int v24 = (icu::HebrewCalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v24) {
          goto LABEL_71;
        }
        UErrorCode v3 = v24;
        icu::HebrewCalendar::HebrewCalendar(v24, this, a2);
        goto LABEL_68;
      case 8:
        int v25 = (icu::ChineseCalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x278, v9);
        if (!v25) {
          goto LABEL_71;
        }
        UErrorCode v3 = v25;
        icu::ChineseCalendar::ChineseCalendar(v25, this, a2);
        goto LABEL_68;
      case 9:
        unsigned int v26 = (icu::IndianCalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v26) {
          goto LABEL_71;
        }
        UErrorCode v3 = v26;
        icu::IndianCalendar::IndianCalendar(v26, this, a2);
        goto LABEL_68;
      case 10:
        int v27 = (icu::CECalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v27) {
          goto LABEL_71;
        }
        UErrorCode v3 = v27;
        sub_1808BB3E8(v27, (char **)this, a2);
        goto LABEL_68;
      case 11:
        int v28 = (icu::CECalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v28) {
          goto LABEL_71;
        }
        UErrorCode v3 = v28;
        sub_1808F1BF4(v28, (char **)this, a2);
        goto LABEL_68;
      case 12:
        int v29 = (icu::CECalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x270, v9);
        if (!v29) {
          goto LABEL_71;
        }
        UErrorCode v3 = v29;
        sub_1808F1FBC(v29, (char **)this, a2);
        goto LABEL_68;
      case 13:
        int v30 = icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x290, v9);
        if (!v30) {
          goto LABEL_71;
        }
        UErrorCode v3 = v30;
        sub_1808FDB1C(v30, this, a2);
        goto LABEL_68;
      case 14:
        int v31 = (icu::ChineseCalendar *)icu::UMemory::operator new((uint64_t *)v7, (icu::UMemory *)0x278, v9);
        if (!v31) {
          goto LABEL_71;
        }
        UErrorCode v3 = v31;
        sub_1808C1C6C(v31, (char **)this, a2);
        goto LABEL_68;
      case 15:
        int v32 = (icu::IslamicUmalquraCalendar *)icu::UMemory::operator new( (uint64_t *)v7,  (icu::UMemory *)0x270,  v9);
        if (!v32) {
          goto LABEL_71;
        }
        UErrorCode v3 = v32;
        icu::IslamicUmalquraCalendar::IslamicUmalquraCalendar(v32, (char **)this, a2);
        goto LABEL_68;
      case 16:
        unsigned int v33 = (icu::IslamicTBLACalendar *)icu::UMemory::operator new( (uint64_t *)v7,  (icu::UMemory *)0x270,  v9);
        if (!v33) {
          goto LABEL_71;
        }
        UErrorCode v3 = v33;
        icu::IslamicTBLACalendar::IslamicTBLACalendar(v33, (char **)this, a2);
        goto LABEL_68;
      case 17:
        UErrorCode v34 = (icu::IslamicRGSACalendar *)icu::UMemory::operator new( (uint64_t *)v7,  (icu::UMemory *)0x270,  v9);
        if (v34)
        {
          UErrorCode v3 = v34;
          icu::IslamicRGSACalendar::IslamicRGSACalendar(v34, (char **)this, a2);
LABEL_68:
          (*(void (**)(void *))(*(void *)v3 + 8LL))(v3);
          int v17 = 5;
        }

        else
        {
LABEL_71:
          int v17 = 7;
        }

icu::Calendar *icu::Calendar::Calendar(icu::Calendar *this, UErrorCode *a2)
{
  *(void *)this = off_18971ED28;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 57) = 2;
  *((void *)this + 29) = 0LL;
  *((_BYTE *)this + 240) = 1;
  *((void *)this + 3sub_18086E18C((uint64_t)this, 1) = 0LL;
  int v4 = (icu::Locale **)((char *)this + 248);
  *((_BYTE *)this + 304) = 0;
  *((_BYTE *)this + 46sub_18086E18C((uint64_t)this, 1) = 0;
  *((void *)this + 32) = 0LL;
  unint64_t v5 = (icu::TimeZone *)icu::Calendar::clear(this);
  if (*(int *)a2 <= 0)
  {
    Default = (icu::Locale *)icu::TimeZone::createDefault(v5);
    *int v4 = Default;
    if (!Default) {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
    uint64_t v7 = icu::Locale::getDefault(Default);
    icu::Calendar::setWeekData(this, (const icu::Locale *)v7, 0LL, a2);
  }

  return this;
}

_BYTE *icu::Calendar::clear(_BYTE *this)
{
  uint64_t v1 = (uint64_t)this;
  if (!this
  {
LABEL_5:
    int v3 = 0;
    goto LABEL_6;
  }

  UErrorCode v6 = U_ZERO_ERROR;
  double UTCtime = uprv_getUTCtime();
  this = (_BYTE *)icu::Calendar::setTimeInMillis(v1, UTCtime, &v6);
  int v3 = 0;
  if (v6 <= U_ZERO_ERROR)
  {
    this = icu::Calendar::complete((_BYTE *)v1, &v6);
    if (v6 <= U_ZERO_ERROR)
    {
      int v3 = *(_DWORD *)(v1 + 12);
      goto LABEL_6;
    }

    goto LABEL_5;
  }

void icu::Calendar::setWeekData(icu::Calendar *this, const icu::Locale *a2, char *a3, UErrorCode *a4)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  *((_DWORD *)this + 66) = 1;
  *((_BYTE *)this + 268) = 1;
  *((_OWORD *)this + 17) = xmmword_180A321E0;
  UErrorCode v22 = U_ZERO_ERROR;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  icu::Locale::Locale((icu::Locale *)&v34, (uint64_t)a2);
  icu::Locale::minimizeSubtags((char **)&v34, &v22);
  memset(v33, 0, sizeof(v33));
  icu::Locale::Locale((icu::Locale *)v33);
  if (*((_BYTE *)a2 + 26) && (!*((_BYTE *)a2 + 20) || BYTE4(v35)))
  {
    icu::Locale::operator=((icu::Locale *)v33, (uint64_t)a2);
  }

  else
  {
    UErrorCode v22 = U_ZERO_ERROR;
    memset(v32, 0, sizeof(v32));
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    icu::Locale::Locale((icu::Locale *)&v24, (uint64_t)a2);
    icu::Locale::addLikelySubtags((icu::Locale *)&v24, &v22);
    icu::Locale::Locale((icu::Locale *)v23, (const char *)&v24 + 8, (const char *)&v25 + 10, 0LL, 0LL);
    icu::Locale::operator=((uint64_t)v33, (uint64_t)v23);
    icu::Locale::~Locale((icu::Locale *)v23);
    icu::Locale::~Locale((icu::Locale *)&v24);
  }

  int BaseName = (char *)icu::Locale::getBaseName((icu::Locale *)v33);
  uint64_t v9 = ures_open(0LL, BaseName, (int *)a4);
  ures_getByKey(v9, "calendar", v9, (int *)a4);
  if (!a3) {
    goto LABEL_14;
  }
  if (!*a3 || !strcmp(a3, "gregorian"))
  {
    a3 = 0LL;
LABEL_14:
    *a4 = U_ZERO_ERROR;
    a3 = (char *)ures_getByKeyWithFallback(v9, "gregorian", (uint64_t)a3, a4);
    ures_getByKeyWithFallback((uint64_t)a3, "monthNames", (uint64_t)a3, a4);
    int v10 = *a4;
    goto LABEL_15;
  }

  a3 = (char *)ures_getByKeyWithFallback(v9, a3, 0LL, a4);
  ures_getByKeyWithFallback((uint64_t)a3, "monthNames", (uint64_t)a3, a4);
  if (!a3) {
    goto LABEL_14;
  }
  int v10 = *a4;
  if (*a4 == U_MISSING_RESOURCE_ERROR) {
    goto LABEL_14;
  }
LABEL_15:
  if (v10 <= 0)
  {
    *(void *)&__int128 v24 = (char *)this + 304;
    *((void *)&v24 + sub_18086E18C((uint64_t)this, 1) = (char *)this + 461;
    LocaleByType = (const char *)ures_getLocaleByType((uint64_t)a3, 1, (int *)a4);
    uint64_t v12 = (const char *)ures_getLocaleByType((uint64_t)a3, 0, (int *)a4);
    icu::LocaleBased::setLocaleIDs((char *)&v24, LocaleByType, v12);
    *(_DWORD *)UChar32 v23 = 0;
    ulocimp_getRegionForSupplementalData(*((char **)a2 + 5), 1, v23, 4, (int *)a4);
    uint64_t v13 = ures_openDirect(0LL, (uint64_t)"supplementalData", (uint64_t)a4);
    ures_getByKey(v13, "weekData", v13, (int *)a4);
    uint64_t v14 = ures_getByKey(v13, v23, 0LL, (int *)a4);
    int v15 = *a4;
    if (v13 && v15 == 2)
    {
      *a4 = U_ZERO_ERROR;
      uint64_t v14 = ures_getByKey(v13, "001", 0LL, (int *)a4);
      int v15 = *a4;
    }

    if (v15 >= 1)
    {
      *a4 = U_USING_FALLBACK_WARNING;
      goto LABEL_51;
    }

    int v21 = 0;
    IntVectounint64_t r = ures_getIntVector(v14, &v21, (int *)a4);
    if (*(int *)a4 <= 0
      && v21 == 6
      && (*IntVector - 1) <= 6
      && (int v17 = IntVector[1], (v17 - 1) <= 6)
      && (int v18 = IntVector[2], (v18 - 1) <= 6)
      && (IntVector[4] - 1) <= 6)
    {
      *((_DWORD *)this + 66) = *IntVector;
      *((_BYTE *)this + 268) = v17;
      *((_DWORD *)this + 68) = v18;
      *((_DWORD *)this + 69) = IntVector[3];
      *((void *)this + 35) = *((void *)IntVector + 2);
    }

    else
    {
      *a4 = U_INVALID_FORMAT_ERROR;
    }

    UErrorCode v20 = U_ZERO_ERROR;
    __int128 v31 = 0u;
    memset(v32, 0, 29);
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v24 = 0u;
    icu::Locale::getKeywordValue((char **)a2, "fw", (char *)&v24, 157, &v20);
    if (v20 <= U_ZERO_ERROR)
    {
      switch((_DWORD)v24)
      {
        case 0x6E7573:
          int v19 = 1;
          break;
        case 0x6E6F6D:
          int v19 = 2;
          break;
        case 0x657574:
          int v19 = 3;
          break;
        case 0x646577:
          int v19 = 4;
          break;
        case 0x756874:
          int v19 = 5;
          break;
        case 0x697266:
          int v19 = 6;
          break;
        case 0x746173:
          int v19 = 7;
          break;
        default:
          goto LABEL_51;
      }

      *((_DWORD *)this + 66) = v19;
    }

icu::Calendar *icu::Calendar::Calendar( icu::Calendar *this, icu::TimeZone *a2, const icu::Locale *a3, UErrorCode *a4)
{
  *(void *)this = off_18971ED28;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 57) = 2;
  *((void *)this + 29) = 0LL;
  *((_BYTE *)this + 240) = 1;
  *((_BYTE *)this + 304) = 0;
  *((_BYTE *)this + 46sub_18086E18C((uint64_t)this, 1) = 0;
  *((void *)this + 3sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 32) = 0LL;
  if (*(int *)a4 < 1)
  {
    if (a2)
    {
      icu::Calendar::clear(this);
      *((void *)this + 3sub_18086E18C((uint64_t)this, 1) = a2;
      icu::Calendar::setWeekData(this, a3, 0LL, a4);
    }

    else
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  else if (a2)
  {
    (*(void (**)(icu::TimeZone *, icu::TimeZone *, const icu::Locale *))(*(void *)a2 + 8LL))(a2, a2, a3);
  }

  return this;
}

icu::Calendar *icu::Calendar::Calendar( icu::Calendar *this, const icu::TimeZone *a2, const icu::Locale *a3, UErrorCode *a4)
{
  *(void *)this = off_18971ED28;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 57) = 2;
  *((void *)this + 29) = 0LL;
  *((_BYTE *)this + 240) = 1;
  *((_BYTE *)this + 304) = 0;
  *((_BYTE *)this + 46sub_18086E18C((uint64_t)this, 1) = 0;
  *((void *)this + 3sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 32) = 0LL;
  if (*(int *)a4 <= 0)
  {
    icu::Calendar::clear(this);
    uint64_t v8 = (*(uint64_t (**)(const icu::TimeZone *))(*(void *)a2 + 96LL))(a2);
    *((void *)this + 3sub_18086E18C((uint64_t)this, 1) = v8;
    if (!v8) {
      *a4 = U_MEMORY_ALLOCATION_ERROR;
    }
    icu::Calendar::setWeekData(this, a3, 0LL, a4);
  }

  return this;
}

void icu::Calendar::~Calendar(icu::Calendar *this)
{
  *(void *)this = off_18971ED28;
  uint64_t v2 = *((void *)this + 31);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UObject::~UObject(this);
}

uint64_t icu::Calendar::Calendar(uint64_t this, uint64_t a2)
{
  *(void *)this = off_18971ED28;
  *(void *)(this + 248) = 0LL;
  return icu::Calendar::operator=(this, a2);
}

uint64_t icu::Calendar::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    __int128 v4 = *(_OWORD *)(a2 + 12);
    *(_OWORD *)(a1 + 28) = *(_OWORD *)(a2 + 28);
    *(_OWORD *)(a1 + 12) = v4;
    __int128 v5 = *(_OWORD *)(a2 + 44);
    __int128 v6 = *(_OWORD *)(a2 + 60);
    __int128 v7 = *(_OWORD *)(a2 + 76);
    *(_OWORD *)(a1 + 92) = *(_OWORD *)(a2 + 92);
    *(_OWORD *)(a1 + 76) = v7;
    *(_OWORD *)(a1 + 60) = v6;
    *(_OWORD *)(a1 + 44) = v5;
    __int128 v8 = *(_OWORD *)(a2 + 108);
    *(void *)(a1 + 124) = *(void *)(a2 + 124);
    *(_OWORD *)(a1 + 108) = v8;
    __int128 v9 = *(_OWORD *)(a2 + 180);
    __int128 v10 = *(_OWORD *)(a2 + 196);
    __int128 v11 = *(_OWORD *)(a2 + 212);
    *(_OWORD *)(a1 + 164) = *(_OWORD *)(a2 + 164);
    *(_OWORD *)(a1 + 212) = v11;
    *(_OWORD *)(a1 + 196) = v10;
    *(_OWORD *)(a1 + 180) = v9;
    __int128 v12 = *(_OWORD *)(a2 + 132);
    *(_OWORD *)(a1 + 148) = *(_OWORD *)(a2 + 148);
    *(_OWORD *)(a1 + 132) = v12;
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_BYTE *)(a1 + 240) = *(_BYTE *)(a2 + 240);
    *(void *)(a1 + 256) = *(void *)(a2 + 256);
    uint64_t v13 = *(void *)(a1 + 248);
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
    *(void *)(a1 + 248) = 0LL;
    uint64_t v14 = *(void *)(a2 + 248);
    if (v14) {
      *(void *)(a1 + 248) = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 96LL))(v14);
    }
    *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 264);
    *(_BYTE *)(a1 + 268) = *(_BYTE *)(a2 + 268);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_DWORD *)(a1 + 228) = *(_DWORD *)(a2 + 228);
    strncpy((char *)(a1 + 304), (const char *)(a2 + 304), 0x9DuLL);
    strncpy((char *)(a1 + 461), (const char *)(a2 + 461), 0x9DuLL);
    *(_BYTE *)(a1 + 460) = 0;
    *(_BYTE *)(a1 + 617) = 0;
  }

  return a1;
}

uint64_t icu::Calendar::createInstance(icu::Calendar *this, UErrorCode *a2)
{
  Default = (icu::Locale *)icu::TimeZone::createDefault(this);
  __int128 v4 = icu::Locale::getDefault(Default);
  return icu::Calendar::createInstance(Default, (icu::TimeZone *)v4, (UErrorCode *)this, v5);
}

uint64_t icu::Calendar::createInstance( icu::Calendar *this, icu::TimeZone *a2, UErrorCode *a3, UErrorCode *a4)
{
  __int128 v10 = 0LL;
  sub_18089A084((uint64_t)a2, (UErrorCode *)&v10, a3);
  if (*(int *)a3 > 0)
  {
    if (!this) {
      return 0LL;
    }
LABEL_3:
    (*(void (**)(icu::Calendar *))(*(void *)this + 8LL))(this);
    return 0LL;
  }

  uint64_t v6 = (*(uint64_t (**)(void))(**((void **)v10 + 3) + 24LL))(*((void *)v10 + 3));
  icu::SharedObject::removeRef(v10);
  if (!v6)
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
    if (!this) {
      return 0LL;
    }
    goto LABEL_3;
  }

  if (this)
  {
    uint64_t v7 = *(void *)(v6 + 248);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    *(void *)(v6 + 248) = this;
    *(_BYTE *)(v6 + 9) = 0;
  }

  double UTCtime = uprv_getUTCtime();
  icu::Calendar::setTimeInMillis(v6, UTCtime, a3);
  return v6;
}

uint64_t icu::Calendar::createInstance(icu::Calendar *this, UErrorCode *a2, UErrorCode *a3)
{
  Default = icu::Locale::getDefault(this);
  return icu::Calendar::createInstance(this, (char **)Default, a2, v6);
}

uint64_t icu::Calendar::createInstance(icu::Calendar *this, char **a2, UErrorCode *a3, UErrorCode *a4)
{
  uint64_t v7 = (icu::Calendar *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  uint64_t Instance = icu::Calendar::createInstance(v7, (icu::TimeZone *)a2, a3, v8);
  uint64_t v10 = Instance;
  if (*(int *)a3 <= 0 && Instance != 0)
  {
    uint64_t v12 = (*(uint64_t (**)(icu::Calendar *))(*(void *)this + 96LL))(this);
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)(v10 + 248);
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
      }
      *(void *)(v10 + 248) = v13;
      *(_BYTE *)(v10 + 9) = 0;
    }
  }

  return v10;
}

uint64_t icu::Calendar::createInstance(char **this, const icu::Locale *a2, UErrorCode *a3)
{
  __int128 v5 = (icu::Calendar *)icu::TimeZone::forLocaleOrDefault(this, a2);
  return icu::Calendar::createInstance(v5, (icu::TimeZone *)this, (UErrorCode *)a2, v6);
}

void sub_18089A084(uint64_t a1, UErrorCode *a2, UErrorCode *this)
{
  v11[28] = *MEMORY[0x1895F89C0];
  uint64_t Instance = icu::UnifiedCache::getInstance(this, a2);
  if (*(int *)this <= 0)
  {
    uint64_t v7 = (icu::SharedObject **)Instance;
    int v9 = 0;
    char v10 = 0;
    __int128 v8 = off_18971F020;
    icu::Locale::Locale((icu::Locale *)v11, a1);
    sub_18089E200(v7, (const icu::CacheKeyBase *)&v8, 0LL, (icu::SharedObject **)a2, this);
    __int128 v8 = off_18971F020;
    icu::Locale::~Locale((icu::Locale *)v11);
    icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)&v8);
  }

void *icu::Calendar::adoptTimeZone(void *result, uint64_t a2)
{
  if (a2)
  {
    int v3 = result;
    double result = (void *)result[31];
    if (result) {
      double result = (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
    v3[31] = a2;
    *((_BYTE *)v3 + 9) = 0;
  }

  return result;
}

uint64_t icu::Calendar::setTimeInMillis(uint64_t this, double a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v5 = this;
    double v6 = 1.83882169e17;
    if (a2 <= 1.83882169e17 && (double v6 = -1.84303903e17, a2 >= -1.84303903e17))
    {
      this = uprv_isNaN(a2);
      double v6 = a2;
      if (!(_DWORD)this)
      {
LABEL_5:
        uint64_t v7 = 0LL;
        *(double *)(v5 + 232) = v6;
        *(_DWORD *)(v5 + 8) = 16777217;
        *(_OWORD *)(v5 + 12) = 0u;
        *(_OWORD *)(v5 + 28) = 0u;
        *(_OWORD *)(v5 + 44) = 0u;
        *(_OWORD *)(v5 + 60) = 0u;
        *(_OWORD *)(v5 + 76) = 0u;
        *(_OWORD *)(v5 + 92) = 0u;
        *(_OWORD *)(v5 + 108) = 0u;
        *(void *)(v5 + 124) = 0LL;
        do
        {
          __int128 v8 = (void *)(v5 + 132 + v7);
          void *v8 = 0LL;
          v8[1] = 0LL;
          v7 += 16LL;
        }

        while (v7 != 96);
        return this;
      }
    }

    else if (*(_BYTE *)(this + 240))
    {
      goto LABEL_5;
    }

    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return this;
}

uint64_t icu::Calendar::setTimeZone(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96LL))(a2);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = *(void *)(a1 + 248);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
    *(void *)(a1 + 248) = v4;
    *(_BYTE *)(a1 + 9) = 0;
  }

  return result;
}

void icu::Calendar::getCalendarTypeFromLocale( icu::Calendar *this, const icu::Locale *a2, char *a3, UErrorCode *a4, UErrorCode *a5)
{
  int v6 = (int)a3;
  int v9 = 0LL;
  sub_18089A084((uint64_t)this, (UErrorCode *)&v9, a4);
  if (*(int *)a4 <= 0)
  {
    __int128 v8 = (const char *)(*(uint64_t (**)(void))(**((void **)v9 + 3) + 184LL))(*((void *)v9 + 3));
    strncpy((char *)a2, v8, v6);
    icu::SharedObject::removeRef(v9);
    if (*((_BYTE *)a2 + v6 - 1)) {
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    }
  }

uint64_t icu::Calendar::operator==(icu::Calendar *a1, icu::Calendar *a2)
{
  UErrorCode v6 = U_ZERO_ERROR;
  uint64_t result = (*(uint64_t (**)(icu::Calendar *))(*(void *)a1 + 40LL))(a1);
  if ((_DWORD)result)
  {
    double TimeInMillis = icu::Calendar::getTimeInMillis(a1, &v6);
    return TimeInMillis == icu::Calendar::getTimeInMillis(a2, &v6) && v6 < U_ILLEGAL_ARGUMENT_ERROR;
  }

  return result;
}

double icu::Calendar::getTimeInMillis(icu::Calendar *this, UErrorCode *a2)
{
  double v2 = 0.0;
  if (*(int *)a2 <= 0)
  {
    if (!*((_BYTE *)this + 8))
    {
      (*(void (**)(icu::Calendar *))(*(void *)this + 248LL))(this);
      if (*((_BYTE *)this + 240) || !*((_BYTE *)this + 10)) {
        *((_BYTE *)this + 9) = 0;
      }
      *((_BYTE *)this + 8) = 1;
      *((_BYTE *)this + 1sub_18086E18C((uint64_t)this, 1) = 0;
    }

    return *((double *)this + 29);
  }

  return v2;
}

uint64_t icu::Calendar::isEquivalentTo(icu::Calendar *this, const icu::Calendar *a2)
{
  if (!this) {
    __cxa_bad_typeid();
  }
  uint64_t result = sub_1807F874C(*(void *)(*(void *)this - 8LL), *(void *)(*(void *)a2 - 8LL));
  if ((_DWORD)result)
  {
    if (*((unsigned __int8 *)this + 240) == *((unsigned __int8 *)a2 + 240)
      && *((_DWORD *)this + 64) == *((_DWORD *)a2 + 64)
      && *((_DWORD *)this + 65) == *((_DWORD *)a2 + 65)
      && *((_DWORD *)this + 66) == *((_DWORD *)a2 + 66)
      && *((unsigned __int8 *)this + 268) == *((unsigned __int8 *)a2 + 268)
      && *((_DWORD *)this + 68) == *((_DWORD *)a2 + 68)
      && *((_DWORD *)this + 69) == *((_DWORD *)a2 + 69)
      && *((_DWORD *)this + 70) == *((_DWORD *)a2 + 70)
      && *((_DWORD *)this + 71) == *((_DWORD *)a2 + 71))
    {
      return (*(uint64_t (**)(void, void))(**((void **)this + 31) + 24LL))( *((void *)this + 31),  *((void *)a2 + 31));
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL icu::Calendar::equals(icu::Calendar *this, const icu::Calendar *a2, UErrorCode *a3)
{
  if (this == a2) {
    return 1LL;
  }
  double TimeInMillis = icu::Calendar::getTimeInMillis(this, a3);
  return TimeInMillis == icu::Calendar::getTimeInMillis(a2, a3);
}

BOOL icu::Calendar::before(icu::Calendar *this, const icu::Calendar *a2, UErrorCode *a3)
{
  if (this == a2) {
    return 0LL;
  }
  double TimeInMillis = icu::Calendar::getTimeInMillis(this, a3);
  return TimeInMillis < icu::Calendar::getTimeInMillis(a2, a3);
}

BOOL icu::Calendar::after(icu::Calendar *this, const icu::Calendar *a2, UErrorCode *a3)
{
  if (this == a2) {
    return 0LL;
  }
  double TimeInMillis = icu::Calendar::getTimeInMillis(this, a3);
  return TimeInMillis > icu::Calendar::getTimeInMillis(a2, a3);
}

uint64_t *icu::Calendar::getKeywordValuesForLocale( icu::Calendar *this, char **a2, const icu::Locale *a3, int *a4, UErrorCode *a5)
{
  KeywordValuesForLocale = (void **)ucal_getKeywordValuesForLocale((uint64_t)this, a2[5], (int)a3, a4);
  uint64_t v8 = (uint64_t)KeywordValuesForLocale;
  int v9 = (uint64_t *)*a4;
  if ((int)v9 < 1)
  {
    uint64_t result = icu::UMemory::operator new(v9, (icu::UMemory *)0x80, v7);
    if (result) {
      return (uint64_t *)icu::UStringEnumeration::UStringEnumeration((uint64_t)result, v8);
    }
    else {
      *a4 = 7;
    }
  }

  else
  {
    uenum_close(KeywordValuesForLocale);
    return 0LL;
  }

  return result;
}

uint64_t icu::Calendar::updateTime(icu::Calendar *this, UErrorCode *a2)
{
  uint64_t result = (*(uint64_t (**)(icu::Calendar *))(*(void *)this + 248LL))(this);
  if (*(int *)a2 <= 0)
  {
    if (*((_BYTE *)this + 240) || !*((_BYTE *)this + 10)) {
      *((_BYTE *)this + 9) = 0;
    }
    *((_BYTE *)this + 8) = 1;
    *((_BYTE *)this + 1sub_18086E18C((uint64_t)this, 1) = 0;
  }

  return result;
}

uint64_t icu::Calendar::isLenient(icu::Calendar *this)
{
  return *((char *)this + 240);
}

uint64_t icu::Calendar::get(_BYTE *a1, unsigned int a2, UErrorCode *a3)
{
  if (a2 < 0x18)
  {
    icu::Calendar::complete(a1, a3);
    return *(unsigned int *)&a1[4 * a2 + 12];
  }

  else
  {
    uint64_t result = 0LL;
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return result;
}

_BYTE *icu::Calendar::complete(_BYTE *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    int v3 = this;
    if (!this[8])
    {
      this = (_BYTE *)(*(uint64_t (**)(_BYTE *, UErrorCode *))(*(void *)this + 248LL))(this, a2);
      if (v3[240] || !v3[10]) {
        v3[9] = 0;
      }
      v3[8] = 1;
      v3[11] = 0;
    }

    if (!v3[9])
    {
      this = (_BYTE *)(*(uint64_t (**)(_BYTE *, UErrorCode *))(*(void *)v3 + 256LL))(v3, a2);
    }
  }

  return this;
}

_BYTE *icu::Calendar::set(_BYTE *this, unsigned int a2, int a3)
{
  if (a2 <= 0x17)
  {
    uint64_t v10 = v3;
    uint64_t v11 = v4;
    uint64_t v7 = (uint64_t)this;
    if (this[11])
    {
      int v9 = 0;
      this = (_BYTE *)(*(uint64_t (**)(_BYTE *, int *))(*(void *)this + 256LL))(this, &v9);
    }

    *(_DWORD *)(v7 + 4LL * a2 + 12) = a3;
    int v8 = *(_DWORD *)(v7 + 228);
    if (v8 == 10000)
    {
      this = (_BYTE *)icu::Calendar::recalculateStamp(v7);
      int v8 = *(_DWORD *)(v7 + 228);
    }

    *(_DWORD *)(v7 + 228) = v8 + 1;
    *(_DWORD *)(v7 + 4LL * a2 + 132) = v8;
    *(_BYTE *)(v7 + a2 + 108) = 1;
    *(_BYTE *)(v7 + 1sub_18086E18C((uint64_t)this, 1) = 0;
    *(_WORD *)(v7 + 8) = 0;
  }

  return this;
}

uint64_t icu::Calendar::recalculateStamp(uint64_t this)
{
  int v1 = 0;
  *(_DWORD *)(this + 228) = 1;
  while (1)
  {
    uint64_t v2 = 0LL;
    int v3 = *(_DWORD *)(this + 228);
    unsigned int v4 = -1;
    int v5 = 10000;
    do
    {
      if (*(_DWORD *)(this + 132 + 4 * v2) > v3 && *(_DWORD *)(this + 132 + 4 * v2) < v5)
      {
        unsigned int v4 = v2;
        int v5 = *(_DWORD *)(this + 132 + 4 * v2);
      }

      ++v2;
    }

    while (v2 != 24);
    if ((v4 & 0x80000000) != 0) {
      break;
    }
    int v6 = v3 + 1;
    *(_DWORD *)(this + 228) = v6;
    *(_DWORD *)(this + 4LL * v4 + 132) = v6;
    if (++v1 == 24)
    {
      int v3 = *(_DWORD *)(this + 228);
      break;
    }
  }

  *(_DWORD *)(this + 228) = v3 + 1;
  return this;
}

_BYTE *icu::Calendar::set(icu::Calendar *this, int a2, int a3, int a4)
{
  return icu::Calendar::set(this, 5u, a4);
}

_BYTE *icu::Calendar::set(icu::Calendar *this, int a2, int a3, int a4, int a5, int a6)
{
  return icu::Calendar::set(this, 0xCu, a6);
}

_BYTE *icu::Calendar::set(icu::Calendar *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return icu::Calendar::set(this, 0xDu, a7);
}

uint64_t icu::Calendar::getRelatedYear(icu::Calendar *this, UErrorCode *a2)
{
  else {
    return 0LL;
  }
}

_BYTE *icu::Calendar::setRelatedYear(icu::Calendar *this, int a2)
{
  return icu::Calendar::set(this, 0x13u, a2);
}

_BYTE *icu::Calendar::clear(_BYTE *result, unsigned int a2)
{
  if (a2 <= 0x17)
  {
    uint64_t v8 = v2;
    uint64_t v9 = v3;
    int v5 = result;
    if (result[11])
    {
      int v7 = 0;
      uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, int *))(*(void *)result + 256LL))(result, &v7);
    }

    int v6 = &v5[4 * a2];
    *((_DWORD *)v6 + 3) = 0;
    *((_DWORD *)v6 + 33) = 0;
    if (a2 == 23)
    {
      *((_DWORD *)v5 + 5) = 0;
      *((_DWORD *)v5 + 35) = 0;
      v5[110] = 0;
    }

    else if (a2 == 2)
    {
      *((_DWORD *)v5 + 26) = 0;
      *((_DWORD *)v5 + 56) = 0;
      v5[131] = 0;
    }

    *((_DWORD *)v5 + 2) = 0;
  }

  return result;
}

BOOL icu::Calendar::isSet(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x17) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 11)) {
    return 1LL;
  }
  return *(_DWORD *)(a1 + 4LL * a2 + 132) != 0;
}

uint64_t icu::Calendar::newestStamp(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a2 <= a3)
  {
    unsigned int v4 = (int *)(a1 + 4LL * a2 + 132);
    int v5 = a3 - a2 + 1;
    do
    {
      int v7 = *v4++;
      unsigned int v6 = v7;
      else {
        a4 = v6;
      }
      --v5;
    }

    while (v5);
  }

  return a4;
}

_BYTE *icu::Calendar::pinField(_BYTE *result, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
  {
    if (a2 < 0x18)
    {
      int v5 = result;
      int v6 = (*(uint64_t (**)(_BYTE *, uint64_t, int *))(*(void *)result + 176LL))(result, a2, a3);
      uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, int *))(*(void *)v5 + 168LL))(v5, a2, a3);
      int v7 = *(_DWORD *)&v5[4 * a2 + 12];
      if (v7 <= v6)
      {
      }

      else
      {
        return icu::Calendar::set(v5, a2, v6);
      }
    }

    else
    {
      *a3 = 1;
    }
  }

  return result;
}

uint64_t icu::Calendar::computeFields(uint64_t this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    uint64_t v3 = this;
    double v4 = *(double *)(this + 232);
    uint64_t v14 = 0LL;
    this = (*(uint64_t (**)(void, void, char *, uint64_t *, UErrorCode *, double))(**(void **)(this + 248)
                                                                                              + 48LL))( *(void *)(this + 248),  0LL,  (char *)&v14 + 4,  &v14,  a2,  v4);
    if (*(int *)a2 <= 0)
    {
      uint64_t v5 = 0LL;
      double v6 = (double)((int)v14 + HIDWORD(v14));
      unsigned int v7 = 8912999;
      do
      {
        *(_DWORD *)(v3 + 4 * v5 + 132) = !(v7 & 1);
        *(_BYTE *)(v3 + v5 + 108) = (v7 & 1) == 0;
        v7 >>= 1;
        ++v5;
      }

      while (v5 != 24);
      int v13 = 0;
      int v8 = sub_1808FA26C(86400000, &v13, v4 + v6);
      *(_DWORD *)(v3 + 92) = v8 + 2440588;
      *(_DWORD *)(v3 + 212) = 1;
      *(_BYTE *)(v3 + 128) = 1;
      icu::Calendar::computeGregorianAndDOWFields((icu::Calendar *)v3, v8 + 2440588, a2);
      (*(void (**)(uint64_t, void, UErrorCode *))(*(void *)v3 + 368LL))( v3,  *(unsigned int *)(v3 + 92),  a2);
      this = icu::Calendar::computeWeekFields(v3, a2);
      if (*(int *)a2 < 1)
      {
        int v9 = v13;
        int v10 = v13 % 1000;
        int v11 = v13 / 1000 % 60;
        *(_DWORD *)(v3 + 96) = v13;
        *(_DWORD *)(v3 + 64) = v11;
        *(_DWORD *)(v3 + 68) = v10;
        *(_DWORD *)(v3 + 56) = v9 / 3600000;
        *(_DWORD *)(v3 + 60) = v9 / 60000 % 60;
        *(_DWORD *)(v3 + 48) = v9 / 43200000;
        *(_DWORD *)(v3 + 52) = v9 / 3600000 % 12;
        int v12 = v14;
        *(_DWORD *)(v3 + 72) = HIDWORD(v14);
        *(_DWORD *)(v3 + 76) = v12;
      }
    }
  }

  return this;
}

uint64_t icu::Calendar::getTimeZone(icu::Calendar *this)
{
  return *((void *)this + 31);
}

void icu::Calendar::computeGregorianAndDOWFields(icu::Calendar *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v6 = (int)uprv_fmod((double)a2 + 1.0, 7.0);
    if (v6 >= 0) {
      unsigned __int8 v7 = v6 + 1;
    }
    else {
      unsigned __int8 v7 = v6 + 8;
    }
    *((_DWORD *)this + 10) = v7;
    *((_DWORD *)this + 40) = 1;
    *((_BYTE *)this + 115) = 1;
    int v8 = *((_DWORD *)this + 66);
    BOOL v9 = __OFSUB__(v7, v8);
    int v10 = v7 - v8;
    if (v10 < 0 != v9) {
      int v11 = v10 + 8;
    }
    else {
      int v11 = v10 + 1;
    }
    *((_DWORD *)this + 5sub_18086E18C((uint64_t)this, 1) = 1;
    *((_BYTE *)this + 126) = 1;
    *((_DWORD *)this + 2sub_18086E18C((uint64_t)this, 1) = v11;
  }

uint64_t icu::Calendar::computeWeekFields(uint64_t this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    uint64_t v2 = this;
    LODWORD(v3) = *(_DWORD *)(this + 88);
    int v5 = *(_DWORD *)(this + 36);
    int v4 = *(_DWORD *)(this + 40);
    int v6 = *(_DWORD *)(this + 264);
    int v7 = (v4 - (v5 + v6) + 7001) % 7;
    else {
      int v8 = (v5 + v7 - 1) / 7 + 1;
    }
    if (v8)
    {
      int v9 = (v4 - v6 + 7) % 7;
      this = (*(uint64_t (**)(uint64_t, void))(*(void *)this + 320LL))(this, *(unsigned int *)(this + 88));
      unsigned int v10 = *(unsigned __int8 *)(v2 + 268);
      unsigned int v11 = 6 - ((v9 - v5 + (int)this) % 7 + ((v9 - v5 + (int)this) % 7 < 0 ? 7 : 0));
      int v12 = v5 - v9 + 7;
      BOOL v13 = v12 <= (int)this;
      else {
        int v14 = v3 + 1;
      }
      if (v13) {
        int v15 = v8;
      }
      else {
        int v15 = 1;
      }
      BOOL v16 = v11 >= v10;
      if (v11 >= v10) {
        int v17 = v14;
      }
      else {
        int v17 = v3;
      }
      if (v16) {
        int v18 = v15;
      }
      else {
        int v18 = v8;
      }
      unsigned int v19 = *(unsigned __int8 *)(v2 + 268);
      if (v5 < (int)this - 5)
      {
        int v20 = v8;
      }

      else
      {
        LODWORD(v3) = v17;
        int v20 = v18;
      }
    }

    else
    {
      uint64_t v3 = (v3 - 1);
      this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)this + 320LL))(this, v3);
      int v21 = (v4 - *(_DWORD *)(v2 + 264) - ((int)this + v5) + 1) % 7;
      int v22 = v21 + (v21 < 0 ? 7 : 0);
      unsigned int v19 = *(unsigned __int8 *)(v2 + 268);
      if (7 - v22 < v19) {
        int v20 = ((int)this + v5 + v22 - 1) / 7;
      }
      else {
        int v20 = ((int)this + v5 + v22 - 1) / 7 + 1;
      }
    }

    *(_DWORD *)(v2 + 80) = v3;
    int v23 = *(_DWORD *)(v2 + 32);
    int v24 = (v4 - (v23 + *(_DWORD *)(v2 + 264)) + 1) % 7;
    int v25 = v24 + (v24 < 0 ? 7 : 0);
    int v26 = v23 - 1;
    if (7 - v25 < v19) {
      int v27 = (v25 + v26) / 7;
    }
    else {
      int v27 = (v25 + v26) / 7 + 1;
    }
    *(_DWORD *)(v2 + 24) = v20;
    *(_DWORD *)(v2 + 28) = v27;
    *(_DWORD *)(v2 + 44) = v26 / 7 + 1;
  }

  return this;
}

uint64_t icu::Calendar::julianDayToDayOfWeek(icu::Calendar *this, double a2)
{
  int v2 = (int)uprv_fmod(a2 + 1.0, 7.0);
  if (v2 >= 0) {
    return (v2 + 1);
  }
  else {
    return (v2 + 8);
  }
}

void icu::Calendar::computeGregorianFields(icu::Calendar *this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v3 = 0;
    sub_1808FA420( (int *)this + 72,  (_DWORD *)this + 73,  (_DWORD *)this + 75,  &v3,  (int *)this + 74,  (double)(a2 - 2440588));
  }

uint64_t icu::Calendar::getFirstDayOfWeek(icu::Calendar *this)
{
  return *((unsigned int *)this + 66);
}

uint64_t icu::Calendar::getMinimalDaysInFirstWeek(icu::Calendar *this)
{
  return *((unsigned __int8 *)this + 268);
}

uint64_t icu::Calendar::weekNumber(icu::Calendar *this, int a2, int a3, int a4)
{
  int v4 = (a4 - a3 - *((_DWORD *)this + 66) + 1) % 7;
  int v5 = v4 + (v4 < 0 ? 7 : 0);
  unsigned int v6 = (a2 + v5 - 1) / 7;
  else {
    return v6 + 1;
  }
}

uint64_t icu::Calendar::handleComputeFields(uint64_t this, int a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v3 = *(_DWORD *)(this + 292);
    *(_DWORD *)(this + 20) = v3;
    *(_DWORD *)(this + 140) = 1;
    *(_BYTE *)(this + 110) = 1;
    *(_DWORD *)(this + 104) = v3;
    *(_DWORD *)(this + 224) = 1;
    *(_BYTE *)(this + 13sub_18086E18C((uint64_t)this, 1) = 1;
    *(_WORD *)(this + 113) = 257;
    *(int32x2_t *)(this + 32) = vrev64_s32(*(int32x2_t *)(this + 296));
    *(void *)(this + 152) = 0x100000001LL;
    int v4 = *(_DWORD *)(this + 288);
    *(_DWORD *)(this + 88) = v4;
    *(_DWORD *)(this + 208) = 1;
    *(_BYTE *)(this + 127) = 1;
    BOOL v5 = v4 > 0;
    if (v4 <= 0) {
      int v4 = 1 - v4;
    }
    *(_BYTE *)(this + 108) = 1;
    *(_DWORD *)(this + 12) = v5;
    *(_DWORD *)(this + 16) = v4;
    *(void *)(this + 132) = 0x100000001LL;
    *(_BYTE *)(this + 109) = 1;
  }

  return this;
}

uint64_t icu::Calendar::roll(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
}

_BYTE *icu::Calendar::roll(_BYTE *result, uint64_t a2, int a3, UErrorCode *a4)
{
  if (a3)
  {
    int v5 = a3;
    uint64_t v7 = (uint64_t)result;
    uint64_t result = icu::Calendar::complete(result, a4);
    if (*(int *)a4 <= 0)
    {
      switch((int)a2)
      {
        case 0:
        case 5:
        case 9:
        case 12:
        case 13:
        case 14:
        case 21:
          int v9 = (*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 168LL))(v7, a2, a4);
          int v10 = (*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 176LL))(v7, a2, a4);
          int v11 = v5 - v9 + *(_DWORD *)(v7 + 4LL * a2 + 12);
          int v12 = v11 % (v10 - v9 + 1) + v9 + ((v10 - v9 + 1) & ((v11 % (v10 - v9 + 1)) >> 31));
          BOOL v13 = (_BYTE *)v7;
          unsigned int v14 = a2;
          goto LABEL_9;
        case 1:
        case 17:
          icu::Calendar::complete((_BYTE *)v7, a4);
          if (*(int *)a4 <= 0)
          {
            int v16 = *(_DWORD *)(v7 + 12);
            if (v16) {
              goto LABEL_51;
            }
          }

          int v15 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 184LL))(v7);
          if (!strcmp(v15, "gregorian") || !strcmp(v15, "roc") || !strcmp(v15, "coptic"))
          {
            int v16 = 0;
            int v25 = 0;
            int v5 = -v5;
          }

          else
          {
            int v16 = 0;
LABEL_51:
            int v25 = 1;
          }

          int v62 = *(_DWORD *)(v7 + 4LL * a2 + 12) + v5;
          if (v16 > 0 || v62 >= 1)
          {
            int v63 = (*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 176LL))(v7, a2, a4);
            if (v63 >= 0x8000)
            {
              if (v62 <= 1) {
                int v62 = 1;
              }
            }

            else if (v62 <= 0)
            {
              int v62 = v62 % v63 + v63;
            }

            else if (v62 > v63)
            {
              int v62 = (v62 - 1) % v63 + 1;
            }
          }

          else if (!v25)
          {
            int v62 = 1;
          }

          unint64_t v56 = (_BYTE *)v7;
          unsigned int v57 = a2;
          int v55 = v62;
          goto LABEL_78;
        case 2:
        case 23:
          int v17 = (*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 176LL))(v7, 2LL, a4);
          int v18 = (*(_DWORD *)(v7 + 20) + v5) % (v17 + 1);
          icu::Calendar::set((_BYTE *)v7, 2u, ((v17 + 1) & (v18 >> 31)) + v18);
          return (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 392LL))( v7,  5LL,  a4);
        case 3:
          int v26 = *(_DWORD *)(v7 + 264);
          int v27 = *(_DWORD *)(v7 + 40);
          BOOL v28 = __OFSUB__(v27, v26);
          int v29 = v27 - v26;
          if (v29 < 0 != v28) {
            int v30 = v29 + 7;
          }
          else {
            int v30 = v29;
          }
          int v31 = (v30 - *(_DWORD *)(v7 + 36) + 1) % 7;
          int v32 = v31 + (v31 < 0 ? 7 : 0);
          else {
            int v33 = 8;
          }
          int v34 = v33 - v32;
          uint64_t result = (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 176LL))( v7,  6LL,  a4);
          int v35 = *(_DWORD *)(v7 + 36);
          int v36 = (_DWORD)result + 7 - (v34 + ((int)result + v30 - v35) % 7);
          if (v36)
          {
            int v64 = (v35 - v5 + 8 * v5 - v34) % v36 + v34 + (v36 & (((v35 - v5 + 8 * v5 - v34) % v36) >> 31));
            if (v64 <= 1) {
              int v64 = 1;
            }
            else {
              int v65 = v64;
            }
            uint64_t result = icu::Calendar::set((_BYTE *)v7, 6u, v65);
            if (*(_BYTE *)(v7 + 11))
            {
              int v67 = 0;
              uint64_t result = (_BYTE *)(*(uint64_t (**)(uint64_t, int *))(*(void *)v7 + 256LL))(v7, &v67);
            }

            *(_BYTE *)(v7 + 13sub_18086E18C((uint64_t)this, 1) = 0;
            *(_DWORD *)(v7 + 104) = 0;
            *(_DWORD *)(v7 + 224) = 0;
            *(_DWORD *)(v7 + 20) = 0;
            *(_DWORD *)(v7 + 140) = 0;
            *(_BYTE *)(v7 + 110) = 0;
            *(_DWORD *)(v7 + 8) = 0;
          }

          else
          {
            UErrorCode v8 = U_INTERNAL_PROGRAM_ERROR;
LABEL_5:
            *a4 = v8;
          }

          break;
        case 4:
          int v37 = *(_DWORD *)(v7 + 40);
          int v38 = *(_DWORD *)(v7 + 264);
          BOOL v28 = __OFSUB__(v37, v38);
          int v39 = v37 - v38;
          if (v39 < 0 != v28) {
            int v40 = v39 + 7;
          }
          else {
            int v40 = v39;
          }
          int v41 = (v40 - *(_DWORD *)(v7 + 32) + 1) % 7;
          int v42 = v41 + (v41 < 0 ? 7 : 0);
          else {
            int v43 = 8;
          }
          int v44 = v43 - v42;
          uint64_t result = (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 176LL))( v7,  5LL,  a4);
          int v45 = *(_DWORD *)(v7 + 32);
          int v46 = (_DWORD)result + 7 - (v44 + ((int)result + v40 - v45) % 7);
          if (v46)
          {
            int v66 = (v45 - v5 + 8 * v5 - v44) % v46 + v44 + (v46 & (((v45 - v5 + 8 * v5 - v44) % v46) >> 31));
            if (v66 <= 1) {
              int v66 = 1;
            }
            else {
              int v12 = v66;
            }
            BOOL v13 = (_BYTE *)v7;
            unsigned int v14 = 5;
LABEL_9:
            uint64_t result = icu::Calendar::set(v13, v14, v12);
          }

          else
          {
            *a4 = U_INTERNAL_PROGRAM_ERROR;
          }

          break;
        case 6:
          double v47 = (double)v5 * 86400000.0;
          double v48 = *(double *)(v7 + 232) - (double)(*(_DWORD *)(v7 + 36) - 1) * 86400000.0;
          double v50 = *(double *)(v7 + 232);
          goto LABEL_38;
        case 7:
        case 18:
          int v19 = *(_DWORD *)(v7 + 4LL * a2 + 12);
          if ((_DWORD)a2 == 7) {
            int v20 = *(_DWORD *)(v7 + 264);
          }
          else {
            int v20 = 1;
          }
          BOOL v28 = __OFSUB__(v19, v20);
          int v58 = v19 - v20;
          if (v58 < 0 != v28) {
            v58 += 7;
          }
          double v59 = *(double *)(v7 + 232);
          double v60 = v59 + (double)v58 * -86400000.0;
          double v61 = uprv_fmod((double)v5 * 86400000.0 + v59 - v60, 604800000.0);
          if (v61 < 0.0) {
            double v61 = v61 + 604800000.0;
          }
          double v24 = v61 + v60;
          return (_BYTE *)icu::Calendar::setTimeInMillis(v7, v24, a4);
        case 8:
          double v47 = (double)v5 * 604800000.0;
          int v51 = (*(_DWORD *)(v7 + 32) - 1) / 7;
          int v52 = (*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 176LL))(v7, 5LL, a4);
          double v50 = *(double *)(v7 + 232);
          double v48 = v50 - (double)v51 * 604800000.0;
          double v49 = (double)(v51 + (v52 - *(_DWORD *)(v7 + 32)) / 7 + 1) * 604800000.0;
LABEL_38:
          double v53 = uprv_fmod(v47 + v50 - v48, v49);
          double v54 = -0.0;
          if (v53 < 0.0) {
            double v54 = v49;
          }
          double v24 = v48 + v53 + v54;
          return (_BYTE *)icu::Calendar::setTimeInMillis(v7, v24, a4);
        case 10:
        case 11:
          double TimeInMillis = icu::Calendar::getTimeInMillis((icu::Calendar *)v7, a4);
          int v22 = *(_DWORD *)(v7 + 4LL * a2 + 12);
          int v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 128LL))(v7, a2);
          double v24 = TimeInMillis
              + (double)(3600000 * ((v22 + v5) % (v23 + 1) - v22 + ((v23 + 1) & (((v22 + v5) % (v23 + 1)) >> 31))));
          return (_BYTE *)icu::Calendar::setTimeInMillis(v7, v24, a4);
        case 19:
          int v55 = *(_DWORD *)(v7 + 88) + v5;
          unint64_t v56 = (_BYTE *)v7;
          unsigned int v57 = 19;
LABEL_78:
          icu::Calendar::set(v56, v57, v55);
          (*(void (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 392LL))(v7, 2LL, a4);
          return (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v7 + 392LL))( v7,  5LL,  a4);
        case 20:
          int v12 = *(_DWORD *)(v7 + 92) + v5;
          BOOL v13 = (_BYTE *)v7;
          unsigned int v14 = 20;
          goto LABEL_9;
        default:
          UErrorCode v8 = U_ILLEGAL_ARGUMENT_ERROR;
          goto LABEL_5;
      }
    }
  }

  return result;
}

_BYTE *icu::Calendar::add(_BYTE *result, unsigned int a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    if (a2 >= 0x18)
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
      return result;
    }

    int v6 = a3;
    if (a3)
    {
      char v7 = 1;
      uint64_t v8 = (uint64_t)result;
      int v9 = 0;
      int v10 = 0;
      double v11 = (double)a3;
      double v12 = 604800000.0;
      switch(a2)
      {
        case 0u:
          int v15 = icu::Calendar::get(result, 0, a4);
          icu::Calendar::set((_BYTE *)v8, 0, v15 + v6);
          return (_BYTE *)(*(uint64_t (**)(uint64_t, void, UErrorCode *))(*(void *)v8 + 392LL))( v8,  0LL,  a4);
        case 1u:
        case 0x11u:
          icu::Calendar::complete(result, a4);
          if (*(int *)a4 > 0 || !*(_DWORD *)(v8 + 12))
          {
            BOOL v13 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 184LL))(v8);
            if (!strcmp(v13, "gregorian") || !strcmp(v13, "roc") || !strcmp(v13, "coptic")) {
              int v6 = -v6;
            }
          }

          goto LABEL_39;
        case 2u:
        case 0x13u:
        case 0x17u:
LABEL_39:
          int v24 = *(unsigned __int8 *)(v8 + 240);
          *(_BYTE *)(v8 + 240) = 1;
          int v25 = icu::Calendar::get((_BYTE *)v8, a2, a4);
          icu::Calendar::set((_BYTE *)v8, a2, v25 + v6);
          uint64_t result = (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, UErrorCode *))(*(void *)v8 + 392LL))( v8,  5LL,  a4);
          if (!v24)
          {
            uint64_t result = icu::Calendar::complete((_BYTE *)v8, a4);
            *(_BYTE *)(v8 + 240) = 0;
          }

          return result;
        case 3u:
        case 4u:
        case 8u:
          goto LABEL_7;
        case 5u:
        case 6u:
        case 7u:
        case 0x12u:
        case 0x14u:
          double v12 = 86400000.0;
          goto LABEL_7;
        case 9u:
          double v12 = 43200000.0;
LABEL_7:
          double v11 = v12 * v11;
          icu::Calendar::complete(result, a4);
          if (*(int *)a4 > 0)
          {
            char v7 = 0;
            int v9 = 0;
LABEL_12:
            int v10 = 0;
            goto LABEL_24;
          }

          int v9 = *(_DWORD *)(v8 + 76);
          icu::Calendar::complete((_BYTE *)v8, a4);
          if (*(int *)a4 > 0 || (v9 += *(_DWORD *)(v8 + 72), icu::Calendar::complete((_BYTE *)v8, a4), *(int *)a4 > 0))
          {
            char v7 = 0;
            goto LABEL_12;
          }

          char v7 = 0;
          int v10 = *(_DWORD *)(v8 + 96);
LABEL_24:
          double TimeInMillis = icu::Calendar::getTimeInMillis((icu::Calendar *)v8, a4);
          uint64_t result = (_BYTE *)icu::Calendar::setTimeInMillis(v8, v11 + TimeInMillis, a4);
          if ((v7 & 1) != 0) {
            return result;
          }
          UErrorCode v17 = *a4;
          else {
            int v18 = 0;
          }
          if (v18 == v10) {
            return result;
          }
          double v19 = *(double *)(v8 + 232);
          if (v17 > U_ZERO_ERROR || (uint64_t result = icu::Calendar::complete((_BYTE *)v8, a4), *(int *)a4 > 0))
          {
            int v20 = 0;
LABEL_32:
            int v21 = 0;
            goto LABEL_33;
          }

          int v20 = *(_DWORD *)(v8 + 76);
          uint64_t result = icu::Calendar::complete((_BYTE *)v8, a4);
          int v21 = *(_DWORD *)(v8 + 72);
LABEL_33:
          int v22 = v9 - (v21 + v20);
          if (!v22) {
            return result;
          }
          if (v22 < 0) {
            signed int v23 = v22 + 86400000 * (-v22 / 0x5265C00u);
          }
          else {
            signed int v23 = v22 % 0x5265C00u;
          }
          if (v23)
          {
            uint64_t result = (_BYTE *)icu::Calendar::setTimeInMillis(v8, v19 + (double)v23, a4);
            else {
              int v18 = 0;
            }
          }

          if (v18 == v10) {
            return result;
          }
          int v26 = *(_DWORD *)(v8 + 260);
          if (!v26)
          {
            if ((v23 & 0x80000000) == 0) {
              return result;
            }
            return (_BYTE *)icu::Calendar::setTimeInMillis(v8, v19, a4);
          }

          if (v26 != 2)
          {
            if (v26 != 1 || v23 < 1) {
              return result;
            }
            return (_BYTE *)icu::Calendar::setTimeInMillis(v8, v19, a4);
          }

          if (v23 >= 1) {
            double v19 = *(double *)(v8 + 232);
          }
          double v27 = 0.0;
          uint64_t result = (_BYTE *)icu::Calendar::getImmediatePreviousZoneTransition((icu::Calendar *)v8, v19, &v27, a4);
          break;
        case 0xAu:
        case 0xBu:
          int v9 = 0;
          int v10 = 0;
          double v14 = 3600000.0;
          goto LABEL_23;
        case 0xCu:
          int v9 = 0;
          int v10 = 0;
          double v14 = 60000.0;
          goto LABEL_23;
        case 0xDu:
          int v9 = 0;
          int v10 = 0;
          double v14 = 1000.0;
LABEL_23:
          double v11 = v11 * v14;
          goto LABEL_24;
        case 0xEu:
        case 0x15u:
          goto LABEL_24;
        default:
          *a4 = U_ILLEGAL_ARGUMENT_ERROR;
          return result;
      }
    }
  }

  return result;
}

uint64_t icu::Calendar::setLenient(uint64_t this, char a2)
{
  *(_BYTE *)(this + 240) = a2;
  return this;
}

uint64_t icu::Calendar::getImmediatePreviousZoneTransition( icu::Calendar *this, double a2, double *a3, UErrorCode *a4)
{
  uint64_t result = (uint64_t)icu::Calendar::getBasicTimeZone(this);
  if (result)
  {
    uint64_t v8 = result;
    memset(v9, 0, sizeof(v9));
    icu::TimeZoneTransition::TimeZoneTransition(v9);
    if (!(*(unsigned int (**)(uint64_t, uint64_t, _OWORD *, double))(*(void *)v8 + 120LL))(v8, 1LL, v9, a2))
    {
      *a4 = U_INTERNAL_PROGRAM_ERROR;
      icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v9);
      return 0LL;
    }

    *a3 = icu::TimeZoneTransition::getTime((icu::TimeZoneTransition *)v9);
    icu::TimeZoneTransition::~TimeZoneTransition((icu::TimeZoneTransition *)v9);
    return 1LL;
  }

  else
  {
    *a4 = U_UNSUPPORTED_ERROR;
  }

  return result;
}

uint64_t icu::Calendar::fieldDifference(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88LL))(a1);
}

uint64_t icu::Calendar::fieldDifference(icu::Calendar *a1, uint64_t a2, UErrorCode *a3, double a4)
{
  if (a2 < 0x18)
  {
    double TimeInMillis = icu::Calendar::getTimeInMillis(a1, a3);
    double v10 = TimeInMillis;
    if (TimeInMillis >= a4)
    {
      if (TimeInMillis <= a4)
      {
        uint64_t v11 = 0LL;
LABEL_38:
        icu::Calendar::setTimeInMillis((uint64_t)a1, v10, a3);
        (*(void (**)(icu::Calendar *, uint64_t, uint64_t, UErrorCode *))(*(void *)a1 + 56LL))( a1,  a2,  v11,  a3);
        else {
          return 0LL;
        }
      }

      else
      {
        if (*(int *)a3 > 0)
        {
          uint64_t v11 = 0LL;
          LODWORD(v15) = -1;
          goto LABEL_23;
        }

        uint64_t v11 = 0LL;
        uint64_t v15 = 0xFFFFFFFFLL;
        while (1)
        {
          uint64_t v4 = v15;
          icu::Calendar::setTimeInMillis((uint64_t)a1, v10, a3);
          (*(void (**)(icu::Calendar *, uint64_t, uint64_t, UErrorCode *))(*(void *)a1 + 56LL))( a1,  a2,  v15,  a3);
          double v21 = icu::Calendar::getTimeInMillis(a1, a3);
          if (v21 == a4) {
            break;
          }
          if (v21 >= a4)
          {
            uint64_t v15 = (2 * v15);
            if (!(_DWORD)v15)
            {
              *a3 = U_ILLEGAL_ARGUMENT_ERROR;
              uint64_t v11 = v4;
              goto LABEL_23;
            }

            uint64_t v11 = v4;
          }

uint64_t icu::Calendar::orphanTimeZone(icu::Calendar *this)
{
  uint64_t result = icu::TimeZone::createDefault(this);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = *((void *)this + 31);
    *((void *)this + 3sub_18086E18C((uint64_t)this, 1) = v3;
  }

  return result;
}

uint64_t icu::Calendar::setRepeatedWallTimeOption(uint64_t result, unsigned int a2)
{
  if (a2 <= 1) {
    *(_DWORD *)(result + 256) = a2;
  }
  return result;
}

uint64_t icu::Calendar::getRepeatedWallTimeOption(icu::Calendar *this)
{
  return *((unsigned int *)this + 64);
}

uint64_t icu::Calendar::setSkippedWallTimeOption(uint64_t result, int a2)
{
  *(_DWORD *)(result + 260) = a2;
  return result;
}

uint64_t icu::Calendar::getSkippedWallTimeOption(icu::Calendar *this)
{
  return *((unsigned int *)this + 65);
}

uint64_t icu::Calendar::setFirstDayOfWeek(uint64_t result, int a2)
{
  if ((a2 - 1) <= 6 && *(_DWORD *)(result + 264) != a2)
  {
    *(_DWORD *)(result + 264) = a2;
    *(_BYTE *)(result + 9) = 0;
  }

  return result;
}

uint64_t icu::Calendar::getFirstDayOfWeek(icu::Calendar *this, UErrorCode *a2)
{
  return *((unsigned int *)this + 66);
}

uint64_t icu::Calendar::setMinimalDaysInFirstWeek(uint64_t this, unsigned int a2)
{
  if (a2 >= 7) {
    int v2 = 7;
  }
  else {
    int v2 = a2;
  }
  if (!a2) {
    int v2 = 1;
  }
  if (*(unsigned __int8 *)(this + 268) != v2)
  {
    *(_BYTE *)(this + 268) = v2;
    *(_BYTE *)(this + 9) = 0;
  }

  return this;
}

uint64_t icu::Calendar::getDayOfWeekType(_DWORD *a1, int a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if ((a2 - 8) <= 0xFFFFFFF8)
  {
    uint64_t v3 = 0LL;
    *a3 = 1;
    return v3;
  }

  int v4 = a1[68];
  int v5 = a1[70];
  if (v4 == v5)
  {
    if (v4 == a2)
    {
LABEL_15:
      if (a1[69]) {
        return 2LL;
      }
      else {
        return 1LL;
      }
    }

    return 0LL;
  }

  if (v4 >= v5)
  {
    if (v4 > a2 && v5 < a2) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
    if (v4 > a2 || v5 < a2) {
      return v3;
    }
  }

  if (v4 == a2) {
    goto LABEL_15;
  }
  if (v5 != a2) {
    return 1LL;
  }
  return 3LL;
}

uint64_t icu::Calendar::getWeekendTransition(_DWORD *a1, int a2, int *a3)
{
  if (*a3 > 0) {
    return 0LL;
  }
  if (a1[68] == a2) {
    return a1[69];
  }
  if (a1[70] == a2) {
    return a1[71];
  }
  uint64_t result = 0LL;
  *a3 = 1;
  return result;
}

uint64_t icu::Calendar::isWeekend(icu::Calendar *this, double a2, UErrorCode *a3)
{
  uint64_t v6 = (*(uint64_t (**)(icu::Calendar *))(*(void *)this + 24LL))(this);
  if (v6)
  {
    uint64_t v7 = v6;
    icu::Calendar::setTimeInMillis(v6, a2, a3);
    else {
      uint64_t v3 = 0LL;
    }
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }

  else
  {
    uint64_t v3 = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return v3;
}

BOOL icu::Calendar::isWeekend(icu::Calendar *this)
{
  UErrorCode v8 = U_ZERO_ERROR;
  icu::Calendar::complete(this, &v8);
  uint64_t v2 = 0LL;
  if (v8 <= U_ZERO_ERROR) {
    uint64_t v2 = *((unsigned int *)this + 10);
  }
  int v3 = (*(uint64_t (**)(icu::Calendar *, uint64_t, UErrorCode *))(*(void *)this + 192LL))(this, v2, &v8);
  if (v8 > U_ZERO_ERROR) {
    return 0LL;
  }
  int v5 = v3;
  int v6 = *((_DWORD *)this + 24);
  int v7 = (*(uint64_t (**)(icu::Calendar *, uint64_t, UErrorCode *))(*(void *)this + 200LL))(this, v2, &v8);
  if (v8 > U_ZERO_ERROR) {
    return 0LL;
  }
  if (v5 == 2) {
    return v6 >= v7;
  }
  else {
    return v6 < v7;
  }
}

uint64_t icu::Calendar::getMinimum(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 296LL))(a1, a2, 0LL);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 296LL))(a1, a2, 0LL);
}

uint64_t icu::Calendar::getMaximum(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296LL))(a1, a2, 3LL);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296LL))(a1, a2, 3LL);
}

uint64_t icu::Calendar::getGreatestMinimum(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296LL))(a1, a2, 1LL);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296LL))(a1, a2, 1LL);
}

uint64_t icu::Calendar::getLeastMaximum(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296LL))(a1, a2, 2LL);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 296LL))(a1, a2, 2LL);
}

uint64_t icu::Calendar::getActualMinimum(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 168LL))(a1);
}

uint64_t icu::Calendar::getLimit(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a2 <= 0x16)
  {
    if (((1 << a2) & 0x75FE80) != 0) {
      return dword_180A3125C[4 * a2 + a3];
    }
    if (a2 == 4)
    {
      if ((_DWORD)a3 != 1)
      {
        if ((_DWORD)a3)
        {
          int v5 = a1[268];
          int v6 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t))(*(void *)a1 + 288LL))(a1, 5LL, a3);
          if ((_DWORD)v3 == 2) {
            int v7 = 7;
          }
          else {
            int v7 = 13;
          }
          int v8 = (unint64_t)(2454267027LL * (v7 - v5 + v6)) >> 32;
          return (v8 >> 2) + (v8 >> 31);
        }

        else
        {
          return a1[268] == 1;
        }
      }

      return v3;
    }
  }

  return (*(uint64_t (**)(unsigned __int8 *))(*(void *)a1 + 288LL))(a1);
}

uint64_t icu::Calendar::getActualMinimum(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  if (a2 >= 0x18)
  {
    uint64_t v3 = 0LL;
    int v6 = 1;
LABEL_5:
    *a3 = v6;
    return v3;
  }

  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, a2);
  int v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 112LL))(a1, a2);
  if ((_DWORD)v3 == v8) {
    return v3;
  }
  int v9 = v8;
  double v10 = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  if (!v10)
  {
    uint64_t v3 = 0LL;
    int v6 = 7;
    goto LABEL_5;
  }

  uint64_t v11 = v10;
  v10[240] = 1;
  icu::Calendar::set(v10, a2, v3);
  if (icu::Calendar::get(v11, a2, a3) == (_DWORD)v3)
  {
    do
    {
      unsigned int v12 = v3;
      LODWORD(v3) = v3 - 1;
      icu::Calendar::set(v11, a2, v12 - 1);
    }

    while ((_DWORD)v3 == icu::Calendar::get(v11, a2, a3));
  }

  else
  {
    unsigned int v12 = v3;
  }

  (*(void (**)(_BYTE *))(*(void *)v11 + 8LL))(v11);
  else {
    return 0LL;
  }
}

uint64_t icu::Calendar::inDaylightTime(icu::Calendar *this, UErrorCode *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 31) + 72LL))(*((void *)this + 31));
  if ((_DWORD)result)
  {
    icu::Calendar::complete(this, a2);
    return 0LL;
  }

  return result;
}

BOOL icu::Calendar::inTemporalLeapYear(icu::Calendar *this, UErrorCode *a2)
{
  return (*(unsigned int (**)(icu::Calendar *, uint64_t, UErrorCode *))(*(void *)this + 176LL))( this,  6LL,  a2) == 366;
}

char *icu::Calendar::getTemporalMonthCode(icu::Calendar *this, UErrorCode *a2)
{
  else {
    return 0LL;
  }
}

uint64_t icu::Calendar::setTemporalMonthCode(uint64_t this, const char *__s, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    int v5 = (_BYTE *)this;
    this = strlen(__s);
    if ((_DWORD)this == 3 && *__s == 77)
    {
      uint64_t v6 = 0LL;
      while (1)
      {
        this = strcmp(__s, off_18971EEF8[v6]);
        if (!(_DWORD)this) {
          break;
        }
        if (++v6 == 12) {
          goto LABEL_7;
        }
      }

      icu::Calendar::set(v5, 2u, v6);
      return (uint64_t)icu::Calendar::set(v5, 0x16u, 0);
    }

    else
    {
LABEL_7:
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }

  return this;
}

uint64_t icu::Calendar::validateFields(uint64_t this, UErrorCode *a2)
{
  int v2 = *a2;
  if (*(int *)a2 <= 0)
  {
    uint64_t v4 = this;
    unint64_t v5 = 0LL;
    do
    {
      if (*(int *)(v4 + 4 * v5 + 132) > 1)
      {
        this = (*(uint64_t (**)(uint64_t, unint64_t, UErrorCode *))(*(void *)v4 + 352LL))(v4, v5, a2);
        int v2 = *a2;
      }

      if (v2 >= 1) {
        break;
      }
    }

    while (v5++ < 0x17);
  }

  return this;
}

_DWORD *icu::Calendar::validateField(_DWORD *result, uint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return result;
  }
  if (a2 > 0x17)
  {
LABEL_3:
    *a3 = 1;
    return result;
  }

  unint64_t v5 = result;
  if ((_DWORD)a2 != 8)
  {
    if ((_DWORD)a2 == 6)
    {
      uint64_t v12 = (*(uint64_t (**)(_DWORD *))(*(void *)result + 328LL))(result);
      uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v5 + 320LL))(v5, v12);
      if (*a3 > 0) {
        return result;
      }
      int v8 = v5[9];
      goto LABEL_15;
    }

    if ((_DWORD)a2 == 5)
    {
      uint64_t v6 = (*(uint64_t (**)(_DWORD *))(*(void *)result + 328LL))(result);
      uint64_t v7 = (*(uint64_t (**)(_DWORD *))(*(void *)v5 + 264LL))(v5);
      uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t, uint64_t))(*(void *)v5 + 312LL))(v5, v6, v7);
      if (*a3 > 0) {
        return result;
      }
      int v8 = v5[8];
LABEL_15:
      return result;
    }

    int v13 = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)result + 112LL))(result, a2);
    uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v5 + 128LL))(v5, a2);
    if (*a3 > 0) {
      return result;
    }
    int v10 = v5[a2 + 3];
    BOOL v11 = v10 < v13;
LABEL_20:
    return result;
  }

  if (!result[11]) {
    goto LABEL_3;
  }
  int v9 = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)result + 112LL))(result, 8LL);
  uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v5 + 128LL))(v5, 8LL);
  if (*a3 <= 0)
  {
    int v10 = v5[11];
    BOOL v11 = v10 < v9;
    goto LABEL_20;
  }

  return result;
}

uint64_t icu::Calendar::validateField(uint64_t result, unsigned int a2, int a3, int a4, int *a5)
{
  if (*a5 <= 0)
  {
    if (a2 > 0x17 || ((int v5 = *(_DWORD *)(result + 4LL * a2 + 12), v5 >= a3) ? (v6 = v5 <= a4) : (v6 = 0), !v6)) {
      *a5 = 1;
    }
  }

  return result;
}

void *icu::Calendar::getFieldResolutionTable(icu::Calendar *this)
{
  return &icu::Calendar::kDatePrecedence;
}

uint64_t icu::Calendar::newerField(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 132 + 4LL * a3) <= *(_DWORD *)(a1 + 132 + 4LL * a2)) {
    return a2;
  }
  else {
    return a3;
  }
}

uint64_t icu::Calendar::resolveFields(icu::Calendar *this, const int (*a2)[12][8])
{
  int v2 = *((_DWORD *)this + 40);
  if (v2 >= 2
    && (int v3 = *((_DWORD *)this + 38), v3 >= 2)
    && (int v4 = *((_DWORD *)this + 35), v4 >= 2)
    && *((_DWORD *)this + 36) == 1
    && *((_DWORD *)this + 37) == 1
    && *((_DWORD *)this + 41) == 1)
  {
    unsigned int v5 = v2 + ~v4;
    char v6 = 1;
    if (v5 <= 2)
    {
      int v7 = v2 - v3;
      if (v7 >= 1 && v7 <= 3)
      {
        char v6 = 0;
        *((void *)this + 18) = 0LL;
        *((_DWORD *)this + 4sub_18086E18C((uint64_t)this, 1) = 0;
      }
    }
  }

  else
  {
    char v6 = 1;
  }

  if ((*a2)[0][0] == -1)
  {
    uint64_t v13 = 24LL;
    if ((v6 & 1) != 0) {
      return v13;
    }
    goto LABEL_40;
  }

  uint64_t v8 = 0LL;
  int v9 = &(*a2)[0][1];
  do
  {
    uint64_t v10 = (*a2)[12 * v8][0];
    if ((_DWORD)v10 == -1)
    {
      uint64_t v13 = 24LL;
    }

    else
    {
      uint64_t v11 = 0LL;
      int v12 = 0;
      uint64_t v13 = 24LL;
      double v14 = v9;
      do
      {
        int v15 = (*a2)[12 * v8][8 * v11 + ((int)v10 > 31)];
        if (v15 == -1)
        {
          int v16 = 0;
LABEL_24:
          if (v16 > v12)
          {
            else {
              uint64_t v13 = v10;
            }
            if ((_DWORD)v13 == (_DWORD)v10) {
              int v12 = v16;
            }
          }
        }

        else
        {
          int v16 = 0;
          int v17 = (int *)&v14[(int)v10 > 31];
          while (1)
          {
            int v18 = *((_DWORD *)this + v15 + 33);
            if (!v18) {
              break;
            }
            if (v18 > v16) {
              int v16 = v18;
            }
            int v19 = *v17++;
            int v15 = v19;
            if (v19 == -1) {
              goto LABEL_24;
            }
          }
        }

        ++v11;
        uint64_t v10 = (*a2)[12 * v8][8 * v11];
        v14 += 8;
      }

      while ((_DWORD)v10 != -1);
    }

    ++v8;
    v9 += 96;
  }

  while ((*a2)[12 * v8][0] != -1 && (_DWORD)v13 == 24);
  if ((v6 & 1) == 0)
  {
LABEL_40:
    *((void *)this + 18) = 0x100000001LL;
    *((_DWORD *)this + 4sub_18086E18C((uint64_t)this, 1) = 1;
  }

  return v13;
}

void icu::Calendar::computeTime(icu::Calendar *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    if (*((_BYTE *)this + 240) || (icu::Calendar::validateFields((uint64_t)this, a2), *(int *)a2 <= 0))
    {
      double v4 = (double)(int)(icu::Calendar::computeJulianDay(this) - 2440588);
      int v5 = *((_DWORD *)this + 54);
      if (v5 < 2) {
        goto LABEL_9;
      }
      uint64_t v6 = 0LL;
      int v7 = 0;
      do
      {
        v6 += 4LL;
      }

      while (v6 != 24);
      if (v7 <= v5) {
        double v8 = (double)*((int *)this + 24);
      }
      else {
LABEL_9:
      }
        double v8 = icu::Calendar::computeMillisInDay(this);
      double v9 = v4 * 86400000.0;
      if (*((int *)this + 48) <= 1 && *((int *)this + 49) < 2)
      {
        if (*((_BYTE *)this + 240) && *((_DWORD *)this + 65) != 2)
        {
          double v10 = v9 + v8 - (double)(int)icu::Calendar::computeZoneOffset(this, v9, v8, a2);
        }

        else
        {
          int v11 = icu::Calendar::computeZoneOffset(this, v9, v8, a2);
          double v12 = v9 + v8 - (double)v11;
          uint64_t v15 = 0LL;
          (*(void (**)(void, void, char *, uint64_t *, UErrorCode *, double))(**((void **)this + 31)
                                                                                          + 48LL))( *((void *)this + 31),  0LL,  (char *)&v15 + 4,  &v15,  a2,  v12);
          double v10 = 0.0;
          if (*(int *)a2 <= 0)
          {
            if (v11 == (_DWORD)v15 + HIDWORD(v15))
            {
              double v10 = v12;
            }

            else if (*((_BYTE *)this + 240))
            {
              double v14 = 0.0;
              else {
                BOOL v13 = 0;
              }
              double v10 = v14;
              if (!v13) {
                double v10 = 0.0;
              }
            }

            else
            {
              *a2 = U_ILLEGAL_ARGUMENT_ERROR;
            }
          }
        }
      }

      else
      {
        double v10 = v9 + v8 - (double)(*((_DWORD *)this + 19) + *((_DWORD *)this + 18));
      }
    }
  }

uint64_t icu::Calendar::computeJulianDay(icu::Calendar *this)
{
  int v2 = *((_DWORD *)this + 53);
  if (v2 >= 2)
  {
    uint64_t v3 = 0LL;
    int v4 = 0;
    do
    {
      v3 += 4LL;
    }

    while (v3 != 36);
    for (uint64_t i = 0LL; i != 12; i += 4LL)
    {
    }

    if (*((_DWORD *)this + 56) > v4) {
      int v4 = *((_DWORD *)this + 56);
    }
    if (v4 <= v2) {
      return *((unsigned int *)this + 23);
    }
  }

  uint64_t v6 = (const int (*)[12][8])(*(uint64_t (**)(icu::Calendar *))(*(void *)this + 360LL))(this);
  unsigned int v7 = icu::Calendar::resolveFields(this, v6);
  if (v7 == 24) {
    uint64_t v8 = 5LL;
  }
  else {
    uint64_t v8 = v7;
  }
  return (*(uint64_t (**)(icu::Calendar *, uint64_t))(*(void *)this + 336LL))(this, v8);
}

double icu::Calendar::computeMillisInDay(icu::Calendar *this)
{
  int v2 = *((_DWORD *)this + 43);
  int v1 = *((_DWORD *)this + 44);
  if (v2 <= *((_DWORD *)this + 42)) {
    int v2 = *((_DWORD *)this + 42);
  }
  if (v2 <= v1) {
    int v3 = *((_DWORD *)this + 44);
  }
  else {
    int v3 = v2;
  }
  if (v3)
  {
    if (v1 >= v2) {
      double v4 = (double)*((int *)this + 14);
    }
    else {
      double v4 = (double)*((int *)this + 13) + (double)(12 * *((_DWORD *)this + 12));
    }
  }

  else
  {
    double v4 = 0.0;
  }

  return ((v4 * 60.0 + (double)*((int *)this + 15)) * 60.0 + (double)*((int *)this + 16)) * 1000.0
       + (double)*((int *)this + 17);
}

uint64_t icu::Calendar::computeZoneOffset(icu::Calendar *this, double a2, double a3, UErrorCode *a4)
{
  uint64_t v15 = 0LL;
  double v7 = a2 + a3;
  BasicTimeZone = icu::Calendar::getBasicTimeZone(this);
  if (BasicTimeZone)
  {
    if (*((_DWORD *)this + 64) == 1) {
      uint64_t v9 = 4LL;
    }
    else {
      uint64_t v9 = 12LL;
    }
    if (*((_DWORD *)this + 65) == 1) {
      uint64_t v10 = 12LL;
    }
    else {
      uint64_t v10 = 4LL;
    }
    (*(void (**)(const void *, uint64_t, uint64_t, char *, uint64_t *, UErrorCode *, double))(*(void *)BasicTimeZone + 160LL))( BasicTimeZone,  v10,  v9,  (char *)&v15 + 4,  &v15,  a4,  v7);
  }

  else
  {
    uint64_t v11 = *((void *)this + 31);
    (*(void (**)(uint64_t, uint64_t, char *, uint64_t *, UErrorCode *, double))(*(void *)v11 + 48LL))( v11,  1LL,  (char *)&v15 + 4,  &v15,  a4,  v7);
    if (*((_DWORD *)this + 64) == 1
      && (uint64_t v14 = 0LL,
          (*(void (**)(uint64_t, void, char *, uint64_t *, UErrorCode *, double))(*(void *)v11 + 48LL))( v11,  0LL,  (char *)&v14 + 4,  &v14,  a4,  v7 - (double)((int)v15 + HIDWORD(v15)) + -21600000.0),  int v13 = v15 + HIDWORD(v15) - (HIDWORD(v14) + v14),  v13 < 0))
    {
      v12.n128_f64[0] = v7 + (double)v13;
      (*(void (**)(uint64_t, uint64_t, char *, uint64_t *, UErrorCode *, __n128))(*(void *)v11 + 48LL))( v11,  1LL,  (char *)&v15 + 4,  &v15,  a4,  v12);
    }

    else if (*((_DWORD *)this + 65) == 1)
    {
      v12.n128_f64[0] = v7 - (double)((int)v15 + HIDWORD(v15));
      (*(void (**)(uint64_t, void, char *, uint64_t *, UErrorCode *, __n128))(*(void *)v11 + 48LL))( v11,  0LL,  (char *)&v15 + 4,  &v15,  a4,  v12);
    }
  }

  return (v15 + HIDWORD(v15));
}

const void *icu::Calendar::getBasicTimeZone(icu::Calendar *this)
{
  int v1 = (const void *)*((void *)this + 31);
  if (v1
  {
    return 0LL;
  }

  return v1;
}

uint64_t icu::Calendar::handleComputeJulianDay(uint64_t a1, unsigned int a2)
{
  BOOL v5 = a2 == 8 || (a2 & 0xFFFFFFFE) == 4;
  if (a2 == 3 && *(_DWORD *)(a1 + 136) <= *(_DWORD *)(a1 + 200)) {
    uint64_t v6 = *(unsigned int *)(a1 + 80);
  }
  else {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 328LL))(a1);
  }
  *(_DWORD *)(a1 + 88) = v6;
  *(_DWORD *)(a1 + 208) = 1;
  *(_BYTE *)(a1 + 127) = 1;
  if (*(_BYTE *)(a1 + 11) || *(_DWORD *)(a1 + 140) || *(_DWORD *)(a1 + 224)) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 264LL))(a1);
  }
  else {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 376LL))(a1, v6);
  }
  uint64_t v8 = v7;
  if (v5) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = 0LL;
  }
  int v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)a1 + 304LL))(a1, v6, v9, v5);
  int v11 = v10;
  if (a2 == 6) {
    return (*(_DWORD *)(a1 + 36) + v10);
  }
  if (a2 != 5)
  {
    int v15 = *(_DWORD *)(a1 + 264);
    int v16 = (int)uprv_fmod((double)(v10 + 1) + 1.0, 7.0);
    if (v16 >= 0) {
      unsigned __int8 v17 = v16 + 1;
    }
    else {
      unsigned __int8 v17 = v16 + 8;
    }
    BOOL v18 = __OFSUB__(v17, v15);
    int v19 = v17 - v15;
    if (v19 < 0 != v18) {
      int v20 = v19 + 7;
    }
    else {
      int v20 = v19;
    }
    int LocalDOW = icu::Calendar::getLocalDOW((icu::Calendar *)a1);
    unsigned int v22 = LocalDOW - v20;
    int v23 = LocalDOW - v20 + 1;
    if (a2 == 8)
    {
      if (v22 <= 0x7FFFFFFE) {
        int v24 = LocalDOW - v20 + 1;
      }
      else {
        int v24 = v22 + 8;
      }
      if (*(int *)(a1 + 164) < 1)
      {
        int v27 = -7;
        int v25 = 1;
        return (v27 - v25 + 8 * v25 + v24 + v11);
      }

      int v25 = *(_DWORD *)(a1 + 44);
      if (v25 < 0)
      {
        uint64_t v26 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 272LL))(a1, 0LL);
        int v27 = 7;
        return (v27 - v25 + 8 * v25 + v24 + v11);
      }
    }

    else
    {
      if (a2 == 3)
      {
        if ((int v28 = LocalDOW, !*(_BYTE *)(a1 + 11)) && !*(_DWORD *)(a1 + 200)
          || icu::Calendar::resolveFields((icu::Calendar *)a1, icu::Calendar::kYearPrecedence) != 17
          && *(_DWORD *)(a1 + 200) != 1)
        {
          int v29 = *(_DWORD *)(a1 + 24);
          int v39 = (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a1 + 304LL))( a1,  (v6 + 1),  0LL,  0LL);
          double v30 = (double)(v39 + 1);
          int v32 = (int)uprv_fmod(v30 + 1.0, 7.0);
          if (v32 >= 0) {
            unsigned __int8 v33 = v32 + 1;
          }
          else {
            unsigned __int8 v33 = v32 + 8;
          }
          BOOL v18 = __OFSUB__(v33, v15);
          int v34 = v33 - v15;
          if (v34 < 0 != v18) {
            v34 += 7;
          }
          if (v29 == 1)
          {
            if (v34 >= 1 && 7 - v34 >= *(unsigned __int8 *)(a1 + 268))
            {
              int v35 = icu::Calendar::julianDayToDayOfWeek(v31, v30);
              if (v35 >= v15) {
                int v20 = v35 - v15;
              }
              else {
                int v20 = v35 - v15 + 7;
              }
              int v23 = v28 - v20 + 1;
              int v11 = v39;
            }
          }

          else if (v29 >= (*(int (**)(uint64_t, uint64_t))(*(void *)a1 + 160LL))(a1, 3LL))
          {
            unsigned int v36 = 7 - v20 >= *(unsigned __int8 *)(a1 + 268) ? v23 : v22 + 8;
            if ((int)(v11 - v29 + 8 * v29 + v36 - 7) > v39)
            {
              int v37 = (icu::Calendar *)(*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a1 + 304LL))( a1,  (v6 - 1),  0LL,  0LL);
              int v11 = (int)v37;
              int v38 = icu::Calendar::julianDayToDayOfWeek(v37, (double)((int)v37 + 1));
              if (v38 >= v15) {
                int v20 = v38 - v15;
              }
              else {
                int v20 = v38 - v15 + 7;
              }
              int v23 = v28 - v20 + 1;
            }
          }
        }
      }

      else {
        int v24 = v23 + 7;
      }
      int v25 = *(_DWORD *)(a1 + 4LL * a2 + 12);
    }

    int v27 = -7;
    return (v27 - v25 + 8 * v25 + v24 + v11);
  }

  int v12 = *(_DWORD *)(a1 + 152);
  if (*(_BYTE *)(a1 + 11) || v12)
  {
    if (v12 < 1) {
      int v13 = 1;
    }
    else {
      int v13 = *(_DWORD *)(a1 + 32);
    }
  }

  else
  {
    int v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 384LL))(a1, v6, v8);
  }

  return (v13 + v11);
}

uint64_t icu::Calendar::getLocalDOW(icu::Calendar *this)
{
  int v2 = icu::Calendar::resolveFields(this, icu::Calendar::kDOWPrecedence);
  if (v2 == 18)
  {
    int v3 = *((_DWORD *)this + 21) - 1;
  }

  else if (v2 == 7)
  {
    int v3 = *((_DWORD *)this + 10) - *((_DWORD *)this + 66);
  }

  else
  {
    int v3 = 0;
  }

  int v4 = v3 % 7;
  if (v4 >= 0) {
    return v4;
  }
  else {
    return (v4 + 7);
  }
}

uint64_t icu::Calendar::getDefaultMonthInYear(icu::Calendar *this)
{
  return 0LL;
}

uint64_t icu::Calendar::getDefaultDayInMonth(icu::Calendar *this)
{
  return 1LL;
}

uint64_t icu::Calendar::handleGetExtendedYearFromWeekFields(icu::Calendar *this, uint64_t a2, int a3)
{
  int v6 = icu::Calendar::resolveFields(this, icu::Calendar::kDatePrecedence);
  int LocalDOW = icu::Calendar::getLocalDOW(this);
  int v8 = *((_DWORD *)this + 66);
  int v9 = (*(uint64_t (**)(icu::Calendar *, uint64_t, void, void))(*(void *)this + 304LL))( this,  a2,  0LL,  0LL);
  uint64_t v10 = (a2 + 1);
  int v11 = (*(uint64_t (**)(icu::Calendar *, uint64_t, void, void))(*(void *)this + 304LL))( this,  v10,  0LL,  0LL);
  int v12 = (int)uprv_fmod((double)(v9 + 1) + 1.0, 7.0);
  if (v12 >= 0) {
    unsigned __int8 v13 = v12 + 1;
  }
  else {
    unsigned __int8 v13 = v12 + 8;
  }
  BOOL v14 = __OFSUB__(v13, v8);
  int v15 = v13 - v8;
  if (v15 < 0 != v14) {
    v15 += 7;
  }
  if (v6 == 5)
  {
    int v20 = (*(uint64_t (**)(icu::Calendar *))(*(void *)this + 264LL))(this);
    if (v20 || (*(int (**)(icu::Calendar *, uint64_t))(*(void *)this + 160LL))(this, 3LL) > a3)
    {
      if (a3 == 1)
      {
        BOOL v19 = v20 != 0;
        return (a2 - v19);
      }

      return a2;
    }
  }

  else
  {
    if (v6 != 3) {
      return a2;
    }
    int v16 = *((unsigned __int8 *)this + 268);
    int v17 = 7 - v15;
    if (a3 == 1)
    {
      BOOL v19 = v17 >= v16 && LocalDOW < v15;
      return (a2 - v19);
    }

    int v22 = LocalDOW - a3 + 8 * a3 + v9 + v17;
    int v23 = v22 - 7;
    int v24 = v22 - 14;
    if (v17 < v16) {
      int v24 = v23;
    }
    if (v24 + 1 >= v11) {
      return v10;
    }
    else {
      return a2;
    }
  }

  return v10;
}

uint64_t icu::Calendar::handleGetMonthLength(icu::Calendar *this, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(icu::Calendar *, uint64_t, void, uint64_t))(*(void *)this + 304LL))( this,  a2,  (a3 + 1),  1LL);
  return v6
       - (*(unsigned int (**)(icu::Calendar *, uint64_t, uint64_t, uint64_t))(*(void *)this + 304LL))( this,  a2,  a3,  1LL);
}

uint64_t icu::Calendar::handleGetYearLength(icu::Calendar *this, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(icu::Calendar *, void, void, void))(*(void *)this + 304LL))( this,  (a2 + 1),  0LL,  0LL);
  return v4
       - (*(unsigned int (**)(icu::Calendar *, uint64_t, void, void))(*(void *)this + 304LL))( this,  a2,  0LL,  0LL);
}

uint64_t icu::Calendar::getActualMaximum(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (a2 >= 0x18)
    {
      int v5 = 1;
LABEL_4:
      *a3 = v5;
      return 0LL;
    }

    switch((int)a2)
    {
      case 5:
        int v9 = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
        if (!v9) {
          goto LABEL_20;
        }
        uint64_t v10 = v9;
        v9[240] = 1;
        (*(void (**)(_BYTE *, uint64_t, void, UErrorCode *))(*(void *)v9 + 280LL))(v9, 5LL, 0LL, a3);
        uint64_t v11 = 0LL;
        uint64_t v12 = 0LL;
        icu::Calendar::complete(v10, a3);
        if (*(int *)a3 <= 0)
        {
          uint64_t v11 = *((unsigned int *)v10 + 22);
          icu::Calendar::complete(v10, a3);
          if (*(int *)a3 <= 0)
          {
            uint64_t v12 = *((unsigned int *)v10 + 5);
            goto LABEL_24;
          }
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        uint64_t v12 = 0LL;
LABEL_24:
        uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 312LL))(a1, v11, v12);
        goto LABEL_27;
      case 6:
        unsigned __int8 v13 = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
        if (!v13)
        {
LABEL_20:
          int v5 = 7;
          goto LABEL_4;
        }

        uint64_t v10 = v13;
        v13[240] = 1;
        (*(void (**)(_BYTE *, uint64_t, void, UErrorCode *))(*(void *)v13 + 280LL))(v13, 6LL, 0LL, a3);
        uint64_t v14 = 0LL;
        if (*(int *)a3 <= 0)
        {
          icu::Calendar::complete(v10, a3);
          else {
            uint64_t v14 = 0LL;
          }
        }

        uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 320LL))(a1, v14);
LABEL_27:
        uint64_t v20 = v19;
        (*(void (**)(_BYTE *))(*(void *)v10 + 8LL))(v10);
        return v20;
      case 7:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 18:
      case 20:
      case 21:
        int v8 = *(uint64_t (**)(void))(*(void *)a1 + 128LL);
        return v8();
      case 23:
        int v17 = (*(uint64_t (**)(uint64_t, UErrorCode *))(*(void *)a1 + 224LL))(a1, a3);
        uint64_t v18 = *(void *)a1;
        if (v17) {
          int v8 = *(uint64_t (**)(void))(v18 + 128);
        }
        else {
          int v8 = *(uint64_t (**)(void))(v18 + 160);
        }
        return v8();
      default:
        uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 160LL))(a1, a2);
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128LL))(a1, a2);
        return icu::Calendar::getActualHelper(a1, a2, v15, v16, a3);
    }
  }

  return 0LL;
}

uint64_t icu::Calendar::getActualHelper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  if (a2 >= 0x18)
  {
    uint64_t v5 = 0LL;
    int v8 = 1;
LABEL_5:
    *a5 = v8;
    return v5;
  }

  uint64_t v5 = a3;
  if ((_DWORD)a3 == (_DWORD)a4) {
    return v5;
  }
  else {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  uint64_t v11 = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  if (!v11)
  {
    int v8 = 7;
    goto LABEL_5;
  }

  uint64_t v12 = v11;
  icu::Calendar::complete(v11, a5);
  v12[240] = 1;
  (*(void (**)(_BYTE *, uint64_t, BOOL, UErrorCode *))(*(void *)v12 + 280LL))( v12,  a2,  (int)a4 <= (int)v5,  a5);
  icu::Calendar::set(v12, a2, v5);
  if ((icu::Calendar::get(v12, a2, a5) == (_DWORD)v5 || (_DWORD)a2 == 4 || (int)a4 <= (int)v5)
    && *a5 <= U_ZERO_ERROR)
  {
    while (1)
    {
      int v16 = v5 + v10;
      (*(void (**)(_BYTE *, uint64_t, uint64_t, UErrorCode *))(*(void *)v12 + 56LL))(v12, a2, v10, a5);
      uint64_t v5 = (v5 + v10);
      if ((_DWORD)a4 == v16)
      {
        uint64_t v5 = a4;
        break;
      }
    }
  }

  (*(void (**)(_BYTE *))(*(void *)v12 + 8LL))(v12);
  return v5;
}

_BYTE *icu::Calendar::prepareGetActual(_BYTE *result, uint64_t a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    if (a2 < 0x18)
    {
      uint64_t v7 = result;
      icu::Calendar::set(result, 0x15u, 0);
      switch((int)a2)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_18;
        case 3:
        case 4:
          int v8 = *((_DWORD *)v7 + 66);
          if (a3)
          {
            int v9 = (v8 + 6) % 7;
            if (v9 >= 1) {
              int v8 = (v8 + 6) % 7;
            }
            else {
              int v8 = v9 + 7;
            }
          }

          goto LABEL_16;
        case 5:
        case 6:
        case 7:
          goto LABEL_20;
        case 8:
          icu::Calendar::set(v7, 5u, 1);
          else {
            int v8 = 0;
          }
LABEL_16:
          uint64_t v10 = v7;
          unsigned int v11 = 7;
          goto LABEL_19;
        default:
          if ((_DWORD)a2 == 17)
          {
            int v12 = (*(uint64_t (**)(_BYTE *, uint64_t))(*(void *)v7 + 144LL))(v7, 3LL);
            icu::Calendar::set(v7, 3u, v12);
LABEL_18:
            int v8 = (*(uint64_t (**)(_BYTE *, uint64_t))(*(void *)v7 + 144LL))(v7, 5LL);
            uint64_t v10 = v7;
            unsigned int v11 = 5;
          }

          else
          {
            if ((_DWORD)a2 != 19) {
              goto LABEL_20;
            }
LABEL_12:
            int v8 = (*(uint64_t (**)(_BYTE *, uint64_t))(*(void *)v7 + 144LL))(v7, 6LL);
            uint64_t v10 = v7;
            unsigned int v11 = 6;
          }

uint64_t icu::Calendar::getLocale@<X0>(uint64_t a1@<X0>, int a2@<W1>, int *a3@<X2>, icu::Locale *a4@<X8>)
{
  v5[0] = (const char *)(a1 + 304);
  v5[1] = (const char *)(a1 + 461);
  return icu::LocaleBased::getLocale(v5, a2, a3, a4);
}

uint64_t icu::Calendar::getLocaleID(uint64_t a1, int a2, int *a3)
{
  v4[0] = a1 + 304;
  v4[1] = a1 + 461;
  return icu::LocaleBased::getLocaleID(v4, a2, a3);
}

uint64_t icu::Calendar::internalSet(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v3 = result + 4LL * a2;
  *(_DWORD *)(v3 + 12) = a3;
  *(_DWORD *)(v3 + 132) = 1;
  *(_BYTE *)(result + a2 + 108) = 1;
  return result;
}

uint64_t icu::Calendar::internalGetMonth(icu::Calendar *this)
{
  int v2 = icu::Calendar::resolveFields(this, icu::Calendar::kMonthPrecedence);
  uint64_t v3 = 104LL;
  if (v2 == 2) {
    uint64_t v3 = 20LL;
  }
  return *(unsigned int *)((char *)this + v3);
}

uint64_t icu::Calendar::internalGetMonth(icu::Calendar *this, uint64_t a2)
{
  if (icu::Calendar::resolveFields(this, icu::Calendar::kMonthPrecedence) != 2)
  {
    int v4 = (char *)this + 104;
    return *(unsigned int *)v4;
  }

  if (*((int *)this + 35) >= 1)
  {
    int v4 = (char *)this + 20;
    return *(unsigned int *)v4;
  }

  return a2;
}

void sub_18089E1D0(uint64_t a1)
{
  *(void *)a1 = off_18971F020;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
}

icu::SharedObject **sub_18089E200( icu::SharedObject **result, const icu::CacheKeyBase *a2, void *a3, icu::SharedObject **a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    UErrorCode v9 = U_ZERO_ERROR;
    int v8 = 0LL;
    uint64_t result = (icu::SharedObject **)icu::UnifiedCache::_get(result, a2, &v8, a3, &v9);
    uint64_t v7 = v8;
    if (v9 <= U_ZERO_ERROR) {
      uint64_t result = (icu::SharedObject **)sub_18085C214(v8, a4);
    }
    if (v7) {
      uint64_t result = (icu::SharedObject **)icu::SharedObject::removeRef(v7);
    }
    if (*a5 == U_ZERO_ERROR || v9 >= U_ILLEGAL_ARGUMENT_ERROR) {
      *a5 = v9;
    }
  }

  return result;
}

void sub_18089E294(uint64_t a1)
{
  *(void *)a1 = off_18971F020;
  icu::Locale::~Locale((icu::Locale *)(a1 + 16));
  icu::CacheKeyBase::~CacheKeyBase((icu::CacheKeyBase *)a1);
  icu::UMemory::operator delete(v2);
}

uint64_t sub_18089E2C8(uint64_t a1)
{
  int v2 = strlen((const char *)((unint64_t)"N3icu14SharedCalendarE" & 0x7FFFFFFFFFFFFFFFLL));
  unsigned int v3 = ustr_hashCharsN( (unsigned __int8 *)((unint64_t)"N3icu14SharedCalendarE" & 0x7FFFFFFFFFFFFFFFLL),  v2);
  return icu::Locale::hashCode((icu::Locale *)(a1 + 16)) + 37 * v3;
}

uint64_t *sub_18089E320@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v4 = icu::UMemory::operator new(a3, (icu::UMemory *)0xF0, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a1 + 8);
    *((_BYTE *)v4 + 12) = 0;
    *int v4 = (uint64_t)off_18971F020;
    icu::Locale::Locale((icu::Locale *)(v4 + 2), a1 + 16);
  }

  return v5;
}

char *sub_18089E374(uint64_t a1, char *__dst, int a3)
{
  uint64_t result = strncpy(__dst, *(const char **)(a1 + 56), a3);
  __dst[a3 - 1] = 0;
  return result;
}

BOOL sub_18089E3AC(void *a1, void *a2)
{
  BOOL result = sub_18089E3E8(a1, a2);
  if (result) {
    return icu::Locale::operator==((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  }
  return result;
}

BOOL sub_18089E3E8(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a1) {
    __cxa_bad_typeid();
  }
  return sub_1807F874C(*(void *)(*a1 - 8LL), *(void *)(*a2 - 8LL));
}

uint64_t sub_18089E424(uint64_t *a1, int a2)
{
  char v2 = a2;
  uint64_t v4 = *a1;
  if (a2 < 0)
  {
    int v5 = *((_DWORD *)a1 + 5);
    *((_DWORD *)a1 + 3) = v5;
    *((_BYTE *)a1 + 28) = v2;
  }

  else
  {
    if (a2)
    {
      int v5 = *((_DWORD *)a1 + 6);
      *((_DWORD *)a1 + 3) = v5;
      *((_BYTE *)a1 + 28) = v2;
LABEL_11:
      if (v5 < *((_DWORD *)a1 + 4))
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 80LL))(v4);
        if ((result & 0x80000000) == 0)
        {
          else {
            int v7 = 2;
          }
LABEL_16:
          *((_DWORD *)a1 + 3) += v7;
          return result;
        }

        *((_DWORD *)a1 + 4) = *((_DWORD *)a1 + 3);
      }

      *((_BYTE *)a1 + 29) = 1;
      return 0xFFFFFFFFLL;
    }

    int v5 = *((_DWORD *)a1 + 3);
  }

  if (*((_DWORD *)a1 + 2) < v5)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 80LL))(v4, (v5 - 1));
    if ((result & 0x80000000) == 0)
    {
      else {
        int v7 = -1;
      }
      goto LABEL_16;
    }

    *((_DWORD *)a1 + 2) = *((_DWORD *)a1 + 3);
  }

  return 0xFFFFFFFFLL;
}

void *icu::CaseMapTransliterator::getStaticClassID(icu::CaseMapTransliterator *this)
{
  return &unk_18C535200;
}

icu::Transliterator *sub_18089E50C(icu::Transliterator *a1, UChar **a2, uint64_t a3)
{
  uint64_t result = icu::Transliterator::Transliterator(a1, a2, 0LL);
  *(void *)uint64_t result = off_18971F0A0;
  *((void *)result + 1sub_18086E18C((uint64_t)this, 1) = a3;
  return result;
}

icu::Transliterator *sub_18089E54C(icu::Transliterator *a1, uint64_t a2)
{
  uint64_t result = icu::Transliterator::Transliterator(a1, (UChar **)a2);
  *(void *)uint64_t result = off_18971F0A0;
  *((void *)result + 1sub_18086E18C((uint64_t)this, 1) = *(void *)(a2 + 88);
  return result;
}

uint64_t (**sub_18089E580( uint64_t (**result)(uint64_t), uint64_t a2, _DWORD *a3, int a4))(uint64_t)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3[2];
  if ((int)v4 < a3[3])
  {
    int v8 = result;
    uint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    uint64_t v21 = a2;
    uint64_t v22 = 0LL;
    int v9 = a3[1];
    LODWORD(v22) = *a3;
    LODWORD(v23) = v9;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    uint64_t v29 = 0LL;
    __int128 v28 = 0u;
    int v25 = off_18971B688;
    LOWORD(v26) = 2;
    uint64_t v20 = 0LL;
    while (1)
    {
      HIDWORD(v23) = v4;
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 80LL))(a2, v4);
      int v11 = v10 < 0x10000 ? 1 : 2;
      uint64_t v12 = (v11 + v4);
      LODWORD(v24) = v11 + v4;
      unsigned int v13 = v8[11](v10);
      unsigned int v14 = v13;
      if (a4)
      {
        unint64_t v15 = BYTE5(v24);
        if (BYTE5(v24)) {
          break;
        }
      }

      if ((v13 & 0x80000000) != 0)
      {
        unint64_t v15 = a3[3];
      }

      else
      {
        if (v13 > 0x1F)
        {
          icu::UnicodeString::unBogus((uint64_t)&v25);
          if ((v26 & 0x8000u) == 0LL) {
            uint64_t v16 = (unsigned __int16)v26 >> 5;
          }
          else {
            uint64_t v16 = DWORD1(v26);
          }
          icu::UnicodeString::replace((icu::UnicodeString *)&v25, 0LL, v16, v14);
          if ((v26 & 0x8000) != 0) {
            unsigned int v14 = DWORD1(v26);
          }
          else {
            unsigned int v14 = (unsigned __int16)v26 >> 5;
          }
        }

        else
        {
          uint64_t v19 = v20;
          icu::UnicodeString::setTo((icu::UnicodeString *)&v25, 0, &v19, v13);
        }

        (*(void (**)(uint64_t, void, void, void (***)(icu::UnicodeString *__hidden)))(*(void *)a2 + 32LL))( a2,  HIDWORD(v23),  (v11 + v4),  &v25);
        unint64_t v15 = a3[3];
        unsigned int v17 = v14 - v11;
        if (v14 != v11)
        {
          uint64_t v12 = v14 + v4;
          unsigned int v18 = a3[1] + v17;
          a3[1] = v18;
          LODWORD(v23) = v18;
          unint64_t v15 = v15 + v17;
          a3[3] = v15;
        }
      }

      uint64_t v4 = v12;
    }

    LODWORD(v12) = HIDWORD(v23);
LABEL_23:
    a3[2] = v12;
    return (uint64_t (**)(uint64_t))icu::UnicodeString::~UnicodeString((void *)v15, (icu::UnicodeString *)&v25);
  }

  return result;
}

icu::CECalendar *icu::CECalendar::CECalendar(icu::CECalendar *this, char **a2, UErrorCode *a3)
{
  int v6 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  int v7 = icu::Calendar::Calendar(this, v6, (const icu::Locale *)a2, a3);
  *(void *)this = off_18971F150;
  icu::Calendar::getNow(v7);
  icu::Calendar::setTimeInMillis((uint64_t)this, v8, a3);
  return this;
}

void *icu::CECalendar::CECalendar(icu::CECalendar *this, const icu::CECalendar *a2)
{
  uint64_t result = (void *)icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *uint64_t result = off_18971F150;
  return result;
}

uint64_t icu::CECalendar::operator=(uint64_t a1, uint64_t a2)
{
  icu::Calendar::operator=(a1, a2);
  return a1;
}

uint64_t icu::CECalendar::handleComputeMonthStart(icu::CECalendar *this, icu::CECalendar *a2, int a3)
{
  int v5 = (*(uint64_t (**)(icu::CECalendar *))(*(void *)this + 440LL))(this);
  return icu::CECalendar::ceToJD(a2, a3, 0, v5);
}

uint64_t icu::CECalendar::ceToJD(icu::CECalendar *this, int a2, int a3, int a4)
{
  unsigned int v4 = ~a2 / 0xDu;
  if (a2 >= 0) {
    unsigned int v5 = a2 % 0xDu;
  }
  else {
    unsigned int v5 = a2 + 1 + 13 * v4 + 12;
  }
  if (a2 < 0) {
    unsigned int v6 = ~v4;
  }
  else {
    unsigned int v6 = a2 / 0xDu;
  }
  return a3 + a4 + 30 * v5 + sub_1808FA234(v6 + this, 4) + 365 * (v6 + (_DWORD)this) - 1;
}

uint64_t icu::CECalendar::handleGetLimit(uint64_t a1, int a2, int a3)
{
  return dword_180A32240[4 * a2 + a3];
}

uint64_t icu::CECalendar::haveDefaultCentury(icu::CECalendar *this)
{
  return 1LL;
}

uint64_t icu::CECalendar::jdToCE(icu::CECalendar *this, int a2, _DWORD *a3, int *a4, int *a5, int *a6)
{
  int v14 = 0;
  uint64_t result = sub_1808FA26C(1461, &v14, (double)((int)this - a2));
  uint64_t v10 = v14;
  int v11 = v14 / 365;
  *a3 = v14 / 365
      + 4 * result
  int v12 = v10 - 365 * v11;
  if (v10 == 1460) {
    int v13 = 365;
  }
  else {
    int v13 = v12;
  }
  *a5 = (__int16)(v13
                - 30
                * (((__int16)((34953 * (__int16)v13) >> 16) >> 4)
  return result;
}

char *icu::CECalendar::getTemporalMonthCode(icu::CECalendar *this, UErrorCode *a2)
{
  else {
    return icu::Calendar::getTemporalMonthCode(this, a2);
  }
}

_BYTE *icu::CECalendar::setTemporalMonthCode(_BYTE *this, const char *__s1, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    unsigned int v5 = this;
    if (!strcmp(__s1, "M13"))
    {
      icu::Calendar::set(v5, 2u, 12);
      return icu::Calendar::set(v5, 0x16u, 0);
    }

    else
    {
      return (_BYTE *)icu::Calendar::setTemporalMonthCode((uint64_t)v5, __s1, a3);
    }
  }

  return this;
}

uint64_t *icu::ChineseCalendar::clone@<X0>( icu::ChineseCalendar *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x278, a2);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::Calendar::Calendar((uint64_t)result, (uint64_t)this);
    *uint64_t result = (uint64_t)off_18971F338;
    *((_BYTE *)result + 618) = *((_BYTE *)this + 618);
    *((_DWORD *)result + 155) = *((_DWORD *)this + 155);
    result[78] = *((void *)this + 78);
  }

  return result;
}

uint64_t icu::ChineseCalendar::ChineseCalendar(icu::ChineseCalendar *this, const icu::ChineseCalendar *a2)
{
  uint64_t result = icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t result = off_18971F338;
  *(_BYTE *)(result + 618) = *((_BYTE *)a2 + 618);
  *(_DWORD *)(result + 620) = *((_DWORD *)a2 + 155);
  *(void *)(result + 624) = *((void *)a2 + 78);
  return result;
}

{
  uint64_t result;
  uint64_t result = icu::Calendar::Calendar((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t result = off_18971F338;
  *(_BYTE *)(result + 618) = *((_BYTE *)a2 + 618);
  *(_DWORD *)(result + 620) = *((_DWORD *)a2 + 155);
  *(void *)(result + 624) = *((void *)a2 + 78);
  return result;
}

icu::ChineseCalendar *icu::ChineseCalendar::ChineseCalendar( icu::ChineseCalendar *this, char **a2, UErrorCode *a3)
{
  unsigned int v6 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  int v7 = icu::Calendar::Calendar(this, v6, (const icu::Locale *)a2, a3);
  *(void *)this = off_18971F338;
  *((_BYTE *)this + 618) = 0;
  *((_DWORD *)this + 155) = -2636;
  ChineseCalZoneAstroCalc = (icu::Calendar *)icu::ChineseCalendar::getChineseCalZoneAstroCalc(v7);
  *((void *)this + 78) = ChineseCalZoneAstroCalc;
  icu::Calendar::getNow(ChineseCalZoneAstroCalc);
  icu::Calendar::setTimeInMillis((uint64_t)this, v9, a3);
  return this;
}

uint64_t icu::ChineseCalendar::getChineseCalZoneAstroCalc(icu::ChineseCalendar *this)
{
  v9[8] = *(UChar **)MEMORY[0x1895F89C0];
  unsigned int v1 = atomic_load(dword_18C53522C);
  if (v1 != 2 && icu::umtx_initImplPreInit(dword_18C53522C))
  {
    unsigned int v4 = icu::UMemory::operator new(v3, (icu::UMemory *)0xA0, v2);
    if (v4)
    {
      unsigned int v5 = (icu::SimpleTimeZone *)v4;
      double v8 = L"CHINA_ZONE";
      icu::UnicodeString::UnicodeString(v9, 1LL, &v8);
      icu::SimpleTimeZone::SimpleTimeZone(v5, 28800000, v9);
      qword_18C535208 = (uint64_t)v5;
      icu::UnicodeString::~UnicodeString(v6, (icu::UnicodeString *)v9);
    }

    else
    {
      qword_18C535208 = 0LL;
    }

    sub_1809B36C0(9u, (uint64_t)sub_18089F5E8);
    icu::umtx_initImplPostInit(dword_18C53522C);
  }

  return qword_18C535208;
}

icu::ChineseCalendar *icu::ChineseCalendar::ChineseCalendar( icu::ChineseCalendar *this, char **a2, int a3, const icu::TimeZone *a4, UErrorCode *a5)
{
  uint64_t v10 = (icu::TimeZone *)icu::TimeZone::forLocaleOrDefault(a2, (const icu::Locale *)a2);
  int v11 = icu::Calendar::Calendar(this, v10, (const icu::Locale *)a2, a5);
  *(void *)this = off_18971F338;
  *((_BYTE *)this + 618) = 0;
  *((_DWORD *)this + 155) = a3;
  *((void *)this + 78) = a4;
  icu::Calendar::getNow(v11);
  icu::Calendar::setTimeInMillis((uint64_t)this, v12, a5);
  return this;
}

void icu::ChineseCalendar::~ChineseCalendar(icu::ChineseCalendar *this)
{
}

const char *icu::ChineseCalendar::getType(icu::ChineseCalendar *this)
{
  return "chinese";
}

uint64_t icu::ChineseCalendar::handleGetLimit(uint64_t a1, int a2, int a3)
{
  return dword_180A32408[4 * a2 + a3];
}

uint64_t icu::ChineseCalendar::handleGetExtendedYear(icu::ChineseCalendar *this)
{
  int v2 = icu::Calendar::newestStamp((uint64_t)this, 0, 1, 0LL);
  int v3 = *((_DWORD *)this + 52);
  if (v2 <= v3)
  {
    if (v3 < 1) {
      return 1LL;
    }
    else {
      return *((unsigned int *)this + 22);
    }
  }

  else
  {
    else {
      int v4 = 60 * *((_DWORD *)this + 3) - 2696;
    }
    else {
      int v6 = *((_DWORD *)this + 4);
    }
    return (v4 + v6 - *((_DWORD *)this + 155));
  }

uint64_t icu::ChineseCalendar::handleGetMonthLength(icu::ChineseCalendar *this, uint64_t a2, uint64_t a3)
{
  int v4 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, uint64_t, uint64_t))(*(void *)this + 304LL))( this,  a2,  a3,  1LL);
  return (*(unsigned int (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)(v4 - 2440562))
       - v4
       + 2440587;
}

uint64_t icu::ChineseCalendar::handleComputeFields(icu::ChineseCalendar *this, int a2, UErrorCode *a3)
{
  return (*(uint64_t (**)(icu::ChineseCalendar *, void, void, void, uint64_t))(*(void *)this + 488LL))( this,  (a2 - 2440588),  *((unsigned int *)this + 72),  *((unsigned int *)this + 73),  1LL);
}

void *icu::ChineseCalendar::getFieldResolutionTable(icu::ChineseCalendar *this)
{
  return &icu::ChineseCalendar::CHINESE_DATE_PRECEDENCE;
}

uint64_t icu::ChineseCalendar::handleComputeMonthStart(icu::ChineseCalendar *this, int a2, int a3, int a4)
{
  int v5 = a3;
  if (a3 >= 0xC)
  {
    double v17 = (double)a3;
    sub_1808FA2C8(&v17, (double)a3, 12.0);
    a2 += (int)v8;
    int v5 = (int)v17;
  }

  int v9 = (*(uint64_t (**)(icu::ChineseCalendar *, void))(*(void *)this + 496LL))( this,  (a2 + *((_DWORD *)this + 155) - 1));
  uint64_t v10 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)(v9 + 29 * v5));
  int v11 = v10 + 2440588;
  int v12 = *((_DWORD *)this + 5);
  uint64_t v15 = *(void *)((char *)this + 100);
  if (a4) {
    int v13 = *(void *)((char *)this + 100);
  }
  else {
    int v13 = 0;
  }
  UErrorCode v16 = U_ZERO_ERROR;
  icu::Calendar::computeGregorianFields(this, v11, &v16);
  uint64_t result = 0LL;
  if (v16 <= U_ZERO_ERROR)
  {
    (*(void (**)(icu::ChineseCalendar *, uint64_t, void, void, void))(*(void *)this + 488LL))( this,  v10,  *((unsigned int *)this + 72),  *((unsigned int *)this + 73),  0LL);
    if (v5 != *((_DWORD *)this + 5) || v13 != *((_DWORD *)this + 25)) {
      int v11 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)((int)v10 + 25))
    }
          + 2440588;
    *((_DWORD *)this + 5) = v12;
    *((_DWORD *)this + 35) = 1;
    *((_BYTE *)this + 110) = 1;
    *(void *)((char *)this + 100) = v15;
    *(void *)((char *)this + 220) = 0x100000001LL;
    *((_WORD *)this + 65) = 257;
    return (v11 - 1);
  }

  return result;
}

_BYTE *icu::ChineseCalendar::add(_BYTE *result, unsigned int a2, uint64_t a3, UErrorCode *a4)
{
  int v6 = result;
  if (a2 != 23 && a2 != 2) {
    return icu::Calendar::add(result, a2, a3, a4);
  }
  if ((_DWORD)a3)
  {
    uint64_t result = (_BYTE *)icu::Calendar::get(result, 5u, a4);
    if (*(int *)a4 <= 0)
    {
      int v7 = result;
      uint64_t result = (_BYTE *)icu::Calendar::get(v6, 0x14u, a4);
      if (*(int *)a4 <= 0) {
        return (_BYTE *)(*(uint64_t (**)(_BYTE *, void, _BYTE *, uint64_t, UErrorCode *))(*(void *)v6 + 504LL))( v6,  ((_DWORD)result - (_DWORD)v7 - 2440587),  v7,  a3,  a4);
      }
    }
  }

  return result;
}

uint64_t icu::ChineseCalendar::add(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
}

_BYTE *icu::ChineseCalendar::roll(_BYTE *result, uint64_t a2, int a3, UErrorCode *a4)
{
  int v6 = result;
  if ((_DWORD)a2 != 23 && (_DWORD)a2 != 2) {
    return icu::Calendar::roll(result, a2, a3, a4);
  }
  if (a3)
  {
    uint64_t result = (_BYTE *)icu::Calendar::get(result, 5u, a4);
    if (*(int *)a4 <= 0)
    {
      int v7 = result;
      uint64_t result = (_BYTE *)icu::Calendar::get(v6, 0x14u, a4);
      if (*(int *)a4 <= 0)
      {
        int v8 = (int)result;
        uint64_t result = (_BYTE *)icu::Calendar::get(v6, 2u, a4);
        if (*(int *)a4 <= 0)
        {
          int v9 = (int)result;
          uint64_t v10 = (v8 - (_DWORD)v7 - 2440587);
          if (v6[618])
          {
            uint64_t result = (_BYTE *)icu::Calendar::get(v6, 0x16u, a4);
            if ((_DWORD)result == 1)
            {
              int v11 = 1;
            }

            else
            {
              uint64_t v13 = (*(uint64_t (**)(_BYTE *, uint64_t, double))(*(void *)v6 + 448LL))( v6,  1LL,  (double)((int)v10 - (int)(((double)v9 + -0.5) * 29.5305889)));
              uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(*(void *)v6 + 480LL))( v6,  v13,  v10);
              int v11 = (_DWORD)result != 0;
            }

            v9 += v11;
            if (v6[618]) {
              int v12 = 13;
            }
            else {
              int v12 = 12;
            }
          }

          else
          {
            int v12 = 12;
          }

          int v14 = (v12 & (((v9 + a3) % v12) >> 31)) + (v9 + a3) % v12;
          if (v14 != v9) {
            return (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, _BYTE *, void, UErrorCode *))(*(void *)v6 + 504LL))( v6,  v10,  v7,  (v14 - v9),  a4);
          }
        }
      }
    }
  }

  return result;
}

uint64_t icu::ChineseCalendar::roll(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
}

uint64_t icu::ChineseCalendar::daysToMillis(icu::ChineseCalendar *this, double a2)
{
  uint64_t result = *((void *)this + 78);
  if (result)
  {
    uint64_t v4 = 0LL;
    int v3 = 0;
    return (*(uint64_t (**)(uint64_t, void, char *, uint64_t *, int *, double))(*(void *)result + 48LL))( result,  0LL,  (char *)&v4 + 4,  &v4,  &v3,  a2 * 86400000.0);
  }

  return result;
}

void icu::ChineseCalendar::millisToDays(icu::ChineseCalendar *this, double a2)
{
  uint64_t v3 = *((void *)this + 78);
  if (v3
    && (uint64_t v6 = 0LL,
        int v5 = 0,
        (*(void (**)(uint64_t, void, char *, uint64_t *, int *, double))(*(void *)v3 + 48LL))( v3,  0LL,  (char *)&v6 + 4,  &v6,  &v5,  a2),  v5 < 1))
  {
    double v4 = (double)((int)v6 + HIDWORD(v6)) + a2;
  }

  else
  {
    double v4 = a2 + 28800000.0;
  }

  uprv_floor(v4 / 86400000.0);
}

uint64_t icu::ChineseCalendar::winterSolstice(icu::ChineseCalendar *this, unsigned int a2)
{
  unsigned int v2 = a2 - 1900;
  if (a2 - 1900 > 0xC8)
  {
    int v22 = 0;
    unsigned int v9 = sub_180896930((uint64_t **)&qword_18C535210, a2, &v22);
    if (!v9)
    {
      double v10 = sub_1808FA338(a2, 11, 1);
      icu::ChineseCalendar::daysToMillis(this, v10);
      double v12 = v11;
      umtx_lock((icu::UMutex *)&unk_18C535238);
      uint64_t v15 = (icu::CalendarAstronomer *)qword_18C535218;
      if (!qword_18C535218)
      {
        UErrorCode v16 = (icu::CalendarAstronomer *)icu::UMemory::operator new(v14, (icu::UMemory *)0x88, v13);
        if (v16) {
          UErrorCode v16 = (icu::CalendarAstronomer *)icu::CalendarAstronomer::CalendarAstronomer(v16);
        }
        qword_18C535218 = (uint64_t)v16;
        sub_1809B36C0(9u, (uint64_t)sub_18089F5E8);
        uint64_t v15 = (icu::CalendarAstronomer *)qword_18C535218;
      }

      icu::CalendarAstronomer::setTime(v15, v12);
      double v17 = (icu::CalendarAstronomer *)qword_18C535218;
      double v19 = icu::CalendarAstronomer::WINTER_SOLSTICE(v18);
      Sundouble Time = icu::CalendarAstronomer::getSunTime(v17, v19, 1);
      umtx_unlock((std::mutex **)&unk_18C535238);
      icu::ChineseCalendar::millisToDays(this, SunTime);
      unsigned int v9 = (int)v21;
      sub_1808969CC((uint64_t **)&qword_18C535210, a2, (int)v21, &v22);
    }

    if (v22 <= 0) {
      return v9;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    int v3 = (int)((double)(int)v2 * 365.243 + -0.3);
    uint64_t result = (v3 - 25211);
    unsigned int v5 = v2 >> 4;
    if (v2 >> 4 != 2 && v5 != 4)
    {
      unsigned int v6 = v3 - 25212;
      if (((word_180A32A08[v5] >> (v2 & 0xF)) & 1) != 0) {
        return v6;
      }
      else {
        return result;
      }
    }
  }

  return result;
}

uint64_t sub_18089F5E8()
{
  if (qword_18C535218)
  {
    icu::CalendarAstronomer::~CalendarAstronomer((icu::CalendarAstronomer *)qword_18C535218);
    icu::UMemory::operator delete(v0);
    qword_18C535218 = 0LL;
  }

  if (qword_18C535210)
  {
    (*(void (**)(uint64_t))(*(void *)qword_18C535210 + 8LL))(qword_18C535210);
    qword_18C535210 = 0LL;
  }

  if (qword_18C535220)
  {
    (*(void (**)(uint64_t))(*(void *)qword_18C535220 + 8LL))(qword_18C535220);
    qword_18C535220 = 0LL;
  }

  if (qword_18C535208)
  {
    (*(void (**)(uint64_t))(*(void *)qword_18C535208 + 8LL))(qword_18C535208);
    qword_18C535208 = 0LL;
  }

  atomic_store(0, dword_18C53522C);
  return 1LL;
}

uint64_t icu::ChineseCalendar::newMoonNear( icu::ChineseCalendar *this, double a2, icu::CalendarAstronomer *a3)
{
  double v6 = v5;
  NewMoonTimeInunsigned int Range = icu::CalendarAstronomer::getNewMoonTimeInRange(a3, v5);
  if (NewMoonTimeInRange == 0.0)
  {
    umtx_lock((icu::UMutex *)&unk_18C535238);
    double v10 = (icu::CalendarAstronomer *)qword_18C535218;
    if (!qword_18C535218)
    {
      double v11 = (icu::CalendarAstronomer *)icu::UMemory::operator new(v9, (icu::UMemory *)0x88, v8);
      if (v11) {
        double v11 = (icu::CalendarAstronomer *)icu::CalendarAstronomer::CalendarAstronomer(v11);
      }
      qword_18C535218 = (uint64_t)v11;
      sub_1809B36C0(9u, (uint64_t)sub_18089F5E8);
      double v10 = (icu::CalendarAstronomer *)qword_18C535218;
    }

    icu::CalendarAstronomer::setTime(v10, v6);
    double v12 = (icu::CalendarAstronomer *)qword_18C535218;
    double v18 = icu::CalendarAstronomer::NEW_MOON(v13);
    icu::CalendarAstronomer::getMoonTime(v12, &v18, a3);
    double v15 = v14;
    umtx_unlock((std::mutex **)&unk_18C535238);
  }

  else
  {
    double v15 = NewMoonTimeInRange;
  }

  icu::ChineseCalendar::millisToDays(this, v15);
  return (int)v16;
}

uint64_t icu::ChineseCalendar::synodicMonthsBetween(icu::ChineseCalendar *this, int a2, int a3)
{
  double v3 = (double)(a3 - a2) / 29.5305889;
  double v4 = -0.5;
  if (v3 >= 0.0) {
    double v4 = 0.5;
  }
  return (int)(v3 + v4);
}

uint64_t icu::ChineseCalendar::majorSolarTerm(icu::ChineseCalendar *this, int a2)
{
  unsigned int v2 = (icu::CalendarAstronomer *)icu::ChineseCalendar::daysToMillis(this, (double)a2);
  icu::CalendarAstronomer::getSunLongitudeForTime(v2, v5, v3, v4);
  int v7 = ((int)(v6 * 6.0 / 3.14159265) + 2) % 12;
  if (v7 >= 1) {
    return v7;
  }
  else {
    return (v7 + 12);
  }
}

BOOL icu::ChineseCalendar::hasNoMajorSolarTerm(icu::ChineseCalendar *this, int a2)
{
  int v4 = (*(uint64_t (**)(icu::ChineseCalendar *))(*(void *)this + 464LL))(this);
  uint64_t v5 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)(a2 + 25));
  return v4 == (*(unsigned int (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 464LL))(this, v5);
}

uint64_t icu::ChineseCalendar::isLeapMonthBetween(icu::ChineseCalendar *this, int a2, uint64_t a3)
{
  uint64_t v4 = a3;
  while (!(*(unsigned int (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 472LL))(this, v4))
  {
    uint64_t v4 = (*(uint64_t (**)(icu::ChineseCalendar *, void, double))(*(void *)this + 448LL))( this,  0LL,  (double)((int)v4 - 25));
  }

  return 1LL;
}

uint64_t icu::ChineseCalendar::computeChineseFields( icu::ChineseCalendar *this, int a2, uint64_t a3, int a4, int a5)
{
  int v10 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 440LL))(this, a3);
  double v11 = *(uint64_t (**)(icu::ChineseCalendar *, void))(*(void *)this + 440LL);
  if (v10 <= a2)
  {
    int v12 = v11(this, (a3 + 1));
  }

  else
  {
    int v12 = v10;
    int v10 = v11(this, (a3 - 1));
  }

  uint64_t v13 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)(v10 + 1));
  uint64_t v14 = (*(uint64_t (**)(icu::ChineseCalendar *, void, double))(*(void *)this + 448LL))( this,  0LL,  (double)(v12 + 1));
  int v15 = a2 + 1;
  uint64_t v16 = (*(uint64_t (**)(icu::ChineseCalendar *, void, double))(*(void *)this + 448LL))( this,  0LL,  (double)(a2 + 1));
  *((_BYTE *)this + 618) = (*(unsigned int (**)(icu::ChineseCalendar *, uint64_t, uint64_t))(*(void *)this + 456LL))( this,  v13,  v14) == 12;
  int v17 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, uint64_t))(*(void *)this + 456LL))(this, v13, v16);
  uint64_t v18 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 496LL))(this, a3);
  if ((int)v18 > a2) {
    uint64_t v18 = (*(uint64_t (**)(icu::ChineseCalendar *, void))(*(void *)this + 496LL))( this,  (a3 - 1));
  }
  if (*((_BYTE *)this + 618)) {
    v17 -= (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, uint64_t))(*(void *)this + 480LL))( this,  v13,  v16) != 0;
  }
  if (v17 < 1) {
    v17 += 12;
  }
  uint64_t result = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, uint64_t))(*(void *)this + 456LL))( this,  v18,  v16);
  else {
    int v20 = result + 12;
  }
  int v21 = *((unsigned __int8 *)this + 618);
  if (*((_BYTE *)this + 618))
  {
    uint64_t result = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 472LL))(this, v16);
    if ((_DWORD)result)
    {
      uint64_t v22 = (*(uint64_t (**)(icu::ChineseCalendar *, void, double))(*(void *)this + 448LL))( this,  0LL,  (double)((int)v16 - 25));
      uint64_t result = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, uint64_t))(*(void *)this + 480LL))( this,  v13,  v22);
      int v21 = result == 0;
    }

    else
    {
      int v21 = 0;
    }
  }

  *((_DWORD *)this + 5) = v17 - 1;
  *((_DWORD *)this + 35) = 1;
  *((_BYTE *)this + 110) = 1;
  *((_DWORD *)this + 25) = v21;
  *((_DWORD *)this + 26) = v20;
  *(void *)((char *)this + 220) = 0x100000001LL;
  *((_WORD *)this + 65) = 257;
  if (a5)
  {
    BOOL v23 = a4 > 5 || v17 < 11;
    int v24 = v23;
    if (v23) {
      int v25 = a3 + 1;
    }
    else {
      int v25 = a3;
    }
    if (v24) {
      int v26 = 2637;
    }
    else {
      int v26 = 2636;
    }
    *((_DWORD *)this + 22) = v25 - *((_DWORD *)this + 155);
    *((_DWORD *)this + 52) = 1;
    *((_BYTE *)this + 127) = 1;
    int v29 = 0;
    int v27 = sub_1808FA26C(60, &v29, (double)((int)a3 - 1 + v26));
    *((_WORD *)this + 54) = 257;
    int v28 = v29 + 1;
    *((_DWORD *)this + 3) = v27 + 1;
    *((_DWORD *)this + 4) = v28;
    *(void *)((char *)this + 132) = 0x100000001LL;
    *((_DWORD *)this + 8) = v15 - v16;
    *((_DWORD *)this + 38) = 1;
    *((_BYTE *)this + 113) = 1;
    uint64_t result = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 496LL))(this, a3);
    if ((int)result > a2) {
      uint64_t result = (*(uint64_t (**)(icu::ChineseCalendar *, void))(*(void *)this + 496LL))( this,  (a3 - 1));
    }
    *((_DWORD *)this + 9) = v15 - result;
    *((_DWORD *)this + 39) = 1;
    *((_BYTE *)this + 114) = 1;
  }

  return result;
}

uint64_t icu::ChineseCalendar::newYear(icu::ChineseCalendar *this, uint64_t a2)
{
  int v10 = 0;
  LODWORD(v5) = sub_180896930((uint64_t **)&qword_18C535220, a2, &v10);
  if (!(_DWORD)v5)
  {
    int v6 = (*(uint64_t (**)(icu::ChineseCalendar *, void))(*(void *)this + 440LL))( this,  (a2 - 1));
    int v7 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 440LL))(this, a2);
    uint64_t v8 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)(v6 + 1));
    uint64_t v5 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)((int)v8 + 25));
    uint64_t v9 = (*(uint64_t (**)(icu::ChineseCalendar *, void, double))(*(void *)this + 448LL))( this,  0LL,  (double)(v7 + 1));
    if ((*(unsigned int (**)(icu::ChineseCalendar *, uint64_t, uint64_t))(*(void *)this + 456LL))( this,  v8,  v9) == 12 && ((*(unsigned int (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 472LL))(this, v8)
       || (*(unsigned int (**)(icu::ChineseCalendar *, uint64_t))(*(void *)this + 472LL))(this, v5)))
    {
      LODWORD(v5) = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, double))(*(void *)this + 448LL))( this,  1LL,  (double)((int)v5 + 25));
    }

    sub_1808969CC((uint64_t **)&qword_18C535220, a2, v5, &v10);
  }

  if (v10 <= 0) {
    return v5;
  }
  else {
    return 0LL;
  }
}

_BYTE *icu::ChineseCalendar::offsetMonth(_BYTE *this, int a2, int a3, int a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    double v6 = (double)a2 + 29.5305889 * ((double)a4 + -0.5);
    if (v6 < -2147483650.0 || v6 > 2147483650.0)
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }

    else
    {
      uint64_t v8 = this;
      int v9 = a3
         + 2440587
         + (*(uint64_t (**)(_BYTE *, uint64_t, double))(*(void *)this + 448LL))(this, 1LL, (double)(int)v6);
      if (a3 < 30) {
        return icu::Calendar::set(v8, 0x14u, v9);
      }
      icu::Calendar::set(v8, 0x14u, v9 - 1);
      this = icu::Calendar::complete(v8, a5);
      if (*(int *)a5 <= 0)
      {
        this = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, UErrorCode *))(*(void *)v8 + 176LL))(v8, 5LL, a5);
      }
    }
  }

  return this;
}

uint64_t icu::ChineseCalendar::getRelatedYear(icu::ChineseCalendar *this, UErrorCode *a2)
{
  unsigned int v3 = icu::Calendar::get(this, 0x13u, a2) - 2637;
  else {
    return 0LL;
  }
}

_BYTE *icu::ChineseCalendar::setRelatedYear(icu::ChineseCalendar *this, int a2)
{
  return icu::Calendar::set(this, 0x13u, a2 + 2637);
}

uint64_t icu::ChineseCalendar::haveDefaultCentury(icu::ChineseCalendar *this)
{
  return 1LL;
}

double icu::ChineseCalendar::internalGetDefaultCenturyStart(icu::ChineseCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C535288);
  if (v1 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C535288))
  {
    sub_18089FFC4();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C535288);
  }

  return *(double *)&qword_18C4483A8;
}

uint64_t icu::ChineseCalendar::internalGetDefaultCenturyStartYear(icu::ChineseCalendar *this)
{
  unsigned int v1 = atomic_load((unsigned int *)&unk_18C535288);
  if (v1 != 2 && icu::umtx_initImplPreInit((unsigned int *)&unk_18C535288))
  {
    sub_18089FFC4();
    icu::umtx_initImplPostInit((unsigned int *)&unk_18C535288);
  }

  return dword_18C4483B0;
}

void sub_18089FFC4()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  UErrorCode v2 = U_ZERO_ERROR;
  bzero(v4, 0x278uLL);
  icu::Locale::Locale((icu::Locale *)v3, "@calendar=chinese", 0LL, 0LL, 0LL);
  icu::ChineseCalendar::ChineseCalendar((icu::ChineseCalendar *)v4, v3, &v2);
  icu::Locale::~Locale((icu::Locale *)v3);
  if (v2 <= U_ZERO_ERROR)
  {
    icu::Calendar::getNow(v0);
    icu::Calendar::setTimeInMillis((uint64_t)v4, v1, &v2);
    icu::Calendar::add(v4, 1u, -80, &v2);
    qword_18C4483A8 = icu::Calendar::getTimeInMillis((icu::Calendar *)v4, &v2);
    dword_18C4483B0 = icu::Calendar::get(v4, 1u, &v2);
  }

  icu::Calendar::~Calendar((icu::Calendar *)v4);
}

BOOL icu::ChineseCalendar::inTemporalLeapYear(icu::ChineseCalendar *this, UErrorCode *a2)
{
  int v3 = (*(uint64_t (**)(icu::ChineseCalendar *, uint64_t, UErrorCode *))(*(void *)this + 176LL))( this,  6LL,  a2);
  return *(int *)a2 < 1 && v3 > 360;
}

void *icu::ChineseCalendar::getStaticClassID(icu::ChineseCalendar *this)
{
  return &unk_18C535228;
}

void *icu::ChineseCalendar::getDynamicClassID(icu::ChineseCalendar *this)
{
  return &unk_18C535228;
}

char *icu::ChineseCalendar::getTemporalMonthCode(icu::ChineseCalendar *this, UErrorCode *a2)
{
  int v4 = icu::Calendar::get(this, 0x16u, a2);
  if (!v4) {
    return icu::Calendar::getTemporalMonthCode(this, a2);
  }
  int v6 = icu::Calendar::get(this, 2u, a2);
  return off_18971F538[v6];
}

uint64_t icu::ChineseCalendar::setTemporalMonthCode(uint64_t this, const char *__s, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v5 = (_BYTE *)this;
    if (strlen(__s) == 4 && *__s == 77 && __s[3] == 76)
    {
      uint64_t v6 = 0LL;
      while (1)
      {
        this = strcmp(__s, off_18971F538[v6]);
        if (!(_DWORD)this) {
          break;
        }
        if (++v6 == 12)
        {
          *a3 = U_ILLEGAL_ARGUMENT_ERROR;
          return this;
        }
      }

      icu::Calendar::set(v5, 2u, v6);
      return (uint64_t)icu::Calendar::set(v5, 0x16u, 1);
    }

    else
    {
      icu::Calendar::set(v5, 0x16u, 0);
      return icu::Calendar::setTemporalMonthCode((uint64_t)v5, __s, a3);
    }
  }

  return this;
}

uint64_t icu::ChineseCalendar::internalGetMonth(icu::ChineseCalendar *this)
{
  int v3 = (_BYTE *)(*(uint64_t (**)(icu::ChineseCalendar *))(*(void *)this + 24LL))(this);
  icu::Calendar::set(v3, 2u, 0);
  icu::Calendar::set(v3, 0x16u, 0);
  icu::Calendar::set(v3, 5u, 1);
  UErrorCode v5 = U_ZERO_ERROR;
  (*(void (**)(_BYTE *, uint64_t, void, UErrorCode *))(*(void *)v3 + 72LL))( v3,  2LL,  *((unsigned int *)this + 26),  &v5);
  *((_DWORD *)this + 25) = icu::Calendar::get(v3, 0x16u, &v5);
  *((_DWORD *)this + 55) = 1;
  *((_BYTE *)this + 130) = 1;
  uint64_t v2 = icu::Calendar::get(v3, 2u, &v5);
  *((_DWORD *)this + 5) = v2;
  *((_DWORD *)this + 35) = 1;
  *((_BYTE *)this + 110) = 1;
  (*(void (**)(_BYTE *))(*(void *)v3 + 8LL))(v3);
  return v2;
}

uint64_t icu::ChineseCalendar::internalGetMonth(icu::ChineseCalendar *this, uint64_t a2)
{
  return a2;
}

void *icu::ChoiceFormat::getStaticClassID(icu::ChoiceFormat *this)
{
  return &unk_18C535290;
}

void *icu::ChoiceFormat::getDynamicClassID(icu::ChoiceFormat *this)
{
  return &unk_18C535290;
}

icu::ChoiceFormat *icu::ChoiceFormat::ChoiceFormat( icu::ChoiceFormat *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  *(void *)uint64_t v6 = off_18971F5C8;
  *(UErrorCode *)(v6 + 356) = *a3;
  icu::MessagePattern::MessagePattern((icu::MessagePattern *)(v6 + 360), a3);
  (*(void (**)(icu::ChoiceFormat *, const icu::UnicodeString *, UErrorCode *))(*(void *)this + 304LL))( this,  a2,  a3);
  return this;
}

icu::ChoiceFormat *icu::ChoiceFormat::ChoiceFormat( icu::ChoiceFormat *this, const double *a2, const icu::UnicodeString *a3, uint64_t a4)
{
  *(void *)uint64_t v8 = off_18971F5C8;
  uint64_t v9 = v8 + 356;
  *(_DWORD *)(v8 + 356) = 0;
  icu::MessagePattern::MessagePattern((icu::MessagePattern *)(v8 + 360), (UErrorCode *)(v8 + 356));
  (*(void (**)(icu::ChoiceFormat *, const double *, void, const icu::UnicodeString *, uint64_t, uint64_t))(*(void *)this + 376LL))( this,  a2,  0LL,  a3,  a4,  v9);
  return this;
}

icu::ChoiceFormat *icu::ChoiceFormat::ChoiceFormat( icu::ChoiceFormat *this, const double *a2, const signed __int8 *a3, const icu::UnicodeString *a4, uint64_t a5)
{
  *(void *)uint64_t v10 = off_18971F5C8;
  uint64_t v11 = v10 + 356;
  *(_DWORD *)(v10 + 356) = 0;
  icu::MessagePattern::MessagePattern((icu::MessagePattern *)(v10 + 360), (UErrorCode *)(v10 + 356));
  (*(void (**)(icu::ChoiceFormat *, const double *, const signed __int8 *, const icu::UnicodeString *, uint64_t, uint64_t))(*(void *)this + 376LL))( this,  a2,  a3,  a4,  a5,  v11);
  return this;
}

icu::ChoiceFormat *icu::ChoiceFormat::ChoiceFormat(icu::ChoiceFormat *this, const icu::ChoiceFormat *a2)
{
  uint64_t v4 = icu::NumberFormat::NumberFormat(this, a2);
  *(void *)uint64_t v4 = off_18971F5C8;
  *(_DWORD *)(v4 + 356) = *((_DWORD *)a2 + 89);
  icu::MessagePattern::MessagePattern((icu::MessagePattern *)(v4 + 360), (const icu::ChoiceFormat *)((char *)a2 + 360));
  return this;
}

{
  uint64_t v4;
  uint64_t v4 = icu::NumberFormat::NumberFormat(this, a2);
  *(void *)uint64_t v4 = off_18971F5C8;
  *(_DWORD *)(v4 + 356) = *((_DWORD *)a2 + 89);
  icu::MessagePattern::MessagePattern((icu::MessagePattern *)(v4 + 360), (const icu::ChoiceFormat *)((char *)a2 + 360));
  return this;
}

icu::ChoiceFormat *icu::ChoiceFormat::ChoiceFormat( icu::ChoiceFormat *this, const icu::UnicodeString *a2, UParseError *a3, UErrorCode *a4)
{
  *(void *)uint64_t v8 = off_18971F5C8;
  *(UErrorCode *)(v8 + 356) = *a4;
  icu::MessagePattern::MessagePattern((icu::MessagePattern *)(v8 + 360), a4);
  (*(void (**)(icu::ChoiceFormat *, const icu::UnicodeString *, UParseError *, UErrorCode *))(*(void *)this + 312LL))( this,  a2,  a3,  a4);
  return this;
}

uint64_t icu::ChoiceFormat::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t result = icu::NumberFormat::operator==(a1, a2);
  if ((_DWORD)result) {
    return icu::MessagePattern::operator==(a1 + 360, a2 + 360);
  }
  return result;
}

uint64_t icu::ChoiceFormat::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    icu::NumberFormat::operator=(a1, a2);
    *(_DWORD *)(a1 + 356) = *(_DWORD *)(a2 + 356);
    icu::MessagePattern::operator=(a1 + 360, a2 + 360);
  }

  return a1;
}

void icu::ChoiceFormat::~ChoiceFormat(icu::ChoiceFormat *this)
{
  *(void *)this = off_18971F5C8;
  icu::MessagePattern::~MessagePattern((icu::ChoiceFormat *)((char *)this + 360));
  icu::NumberFormat::~NumberFormat(this);
}

{
  *(void *)this = off_18971F5C8;
  icu::MessagePattern::~MessagePattern((icu::ChoiceFormat *)((char *)this + 360));
  icu::NumberFormat::~NumberFormat(this);
}

{
  void *v2;
  *(void *)this = off_18971F5C8;
  icu::MessagePattern::~MessagePattern((icu::ChoiceFormat *)((char *)this + 360));
  icu::NumberFormat::~NumberFormat(this);
  icu::UMemory::operator delete(v2);
}

icu::ChoiceFormat *icu::ChoiceFormat::dtos(icu::ChoiceFormat *this, double a2, icu::UnicodeString *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  *(void *)__stunint64_t r = 0LL;
  uint64_t v16 = 0LL;
  memset(v17, 0, sizeof(v17));
  uint64_t v4 = __str;
  snprintf(__str, 0x1FuLL, "%.*g", 15, a2);
  while (1)
  {
    uint64_t v5 = *v4;
    if ((_DWORD)v5 != 45)
    {
      if (!*v4) {
        goto LABEL_9;
      }
      if ((v5 & 0x80) != 0 || (*(_DWORD *)(MEMORY[0x1895F8770] + 4 * v5 + 60) & 0x400) == 0) {
        break;
      }
    }

    ++v4;
  }

  if ((_DWORD)v5 != 101) {
    *v4++ = 46;
  }
LABEL_9:
  for (uint64_t i = v4 + 1; *(i - 1); ++i)
  {
    if (*(i - 1) == 101)
    {
      int v7 = *i;
      if (v7 == 43 || v7 == 45) {
        ++i;
      }
      for (uint64_t j = i; ; ++j)
      {
        int v9 = *j;
        if (v9 != 48) {
          break;
        }
      }

      if (*j) {
        BOOL v10 = j == i;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        uint64_t v11 = 1LL;
        do
        {
          *i++ = v9;
          int v9 = j[v11++];
        }

        while (v9);
        _BYTE *i = 0;
      }

      break;
    }
  }

  icu::UnicodeString::UnicodeString(v14, __str, 0xFFFFFFFFLL, 0LL);
  icu::UnicodeString::operator=(this, (icu::UnicodeString *)v14);
  icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v14);
  return this;
}

icu::MessagePattern *icu::ChoiceFormat::applyPattern(UErrorCode *this, UChar **a2, UErrorCode *a3)
{
  uint64_t result = icu::MessagePattern::parseChoiceStyle((icu::MessagePattern *)(this + 90), a2, 0LL, a3);
  this[89] = *a3;
  return result;
}

icu::MessagePattern *icu::ChoiceFormat::applyPattern( UErrorCode *this, UChar **a2, UParseError *a3, UErrorCode *a4)
{
  uint64_t result = icu::MessagePattern::parseChoiceStyle((icu::MessagePattern *)(this + 90), a2, a3, a4);
  this[89] = *a4;
  return result;
}

icu::UnicodeString *icu::ChoiceFormat::toPattern(UChar **this, UChar **a2)
{
  return icu::UnicodeString::operator=(a2, this + 47);
}

uint64_t icu::ChoiceFormat::setChoices( icu::ChoiceFormat *this, const double *a2, const icu::UnicodeString *a3, uint64_t a4)
{
  int v5 = 0;
  return (*(uint64_t (**)(icu::ChoiceFormat *, const double *, void, const icu::UnicodeString *, uint64_t, int *))(*(void *)this + 376LL))( this,  a2,  0LL,  a3,  a4,  &v5);
}

uint64_t icu::ChoiceFormat::setChoices( icu::ChoiceFormat *this, const double *a2, const signed __int8 *a3, const icu::UnicodeString *a4, uint64_t a5)
{
  int v6 = 0;
  return (*(uint64_t (**)(icu::ChoiceFormat *, const double *, const signed __int8 *, const icu::UnicodeString *, uint64_t, int *))(*(void *)this + 376LL))( this,  a2,  a3,  a4,  a5,  &v6);
}

void *icu::ChoiceFormat::setChoices( void *this, const double *a2, const signed __int8 *a3, const icu::UnicodeString *a4, int a5, UErrorCode *a6)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (*(int *)a6 <= 0)
  {
    int v6 = a2;
    if (a2 && (int v7 = a4) != 0LL)
    {
      uint64_t v34 = (uint64_t)this;
      __int128 v48 = 0u;
      uint64_t v51 = 0LL;
      __int128 v50 = 0u;
      __int128 v49 = 0u;
      double v47 = off_18971B688;
      LOWORD(v48) = 2;
      if (a5 >= 1)
      {
        uint64_t v8 = a3;
        uint64_t v9 = 0LL;
        unsigned int v36 = (char *)a4 + 10;
        uint64_t v37 = a5;
        while (1)
        {
          if (v9)
          {
            LOWORD(v42) = 124;
            icu::UnicodeString::doAppend((uint64_t)&v47, (uint64_t)&v42, 0, 1LL);
          }

          uint64_t v46 = 0LL;
          __int128 v44 = 0u;
          __int128 v45 = 0u;
          __int128 v43 = 0u;
          int v42 = off_18971B688;
          LOWORD(v43) = 2;
          if (uprv_isPositiveInfinity(v6[v9])) {
            goto LABEL_11;
          }
          if (uprv_isNegativeInfinity(v6[v9])) {
            break;
          }
          icu::ChoiceFormat::dtos((icu::ChoiceFormat *)&v42, v6[v9], v10);
          if ((v43 & 0x8000u) == 0LL) {
            uint64_t v12 = (unsigned __int16)v43 >> 5;
          }
          else {
            uint64_t v12 = DWORD1(v43);
          }
          icu::UnicodeString::doAppend((uint64_t)&v47, (const icu::UnicodeString *)&v42, 0, v12);
          if (!v8) {
            goto LABEL_18;
          }
LABEL_12:
          if (v8[v9])
          {
            __int16 v11 = 60;
            goto LABEL_19;
          }

uint64_t icu::ChoiceFormat::getLimits(icu::ChoiceFormat *this, int *a2)
{
  *a2 = 0;
  return 0LL;
}

uint64_t icu::ChoiceFormat::getClosures(icu::ChoiceFormat *this, int *a2)
{
  *a2 = 0;
  return 0LL;
}

uint64_t icu::ChoiceFormat::getFormats(icu::ChoiceFormat *this, int *a2)
{
  *a2 = 0;
  return 0LL;
}

uint64_t icu::ChoiceFormat::format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 64LL))(a1, a3, a4, (double)a2);
}

uint64_t icu::ChoiceFormat::format(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 64LL))(a1, a3, a4, (double)a2);
}

icu::UnicodeString *icu::ChoiceFormat::format( icu::ChoiceFormat *this, double a2, icu::UnicodeString *a3, icu::FieldPosition *a4)
{
  if (*((_DWORD *)this + 114))
  {
    int v6 = (icu::ChoiceFormat *)((char *)this + 360);
    SubMessage = (const icu::MessagePattern *)icu::ChoiceFormat::findSubMessage( (icu::ChoiceFormat *)((char *)this + 360),  0LL,  a2);
    if (*((_DWORD *)this + 92) == 1) {
      return (icu::UnicodeString *)icu::MessageImpl::appendSubMessageWithoutSkipSyntax(v6, SubMessage, a3, v8);
    }
    uint64_t v10 = *((void *)this + 56);
    uint64_t v11 = v10 + 16LL * (int)SubMessage;
    int v12 = *(_DWORD *)(v11 + 4) + *(unsigned __int16 *)(v11 + 8);
    int v13 = *(_DWORD *)(v11 + 12);
    icu::UnicodeString::doAppend( (uint64_t)a3,  (icu::ChoiceFormat *)((char *)this + 376),  v12,  (*(_DWORD *)(v10 + 16LL * v13 + 4) - v12));
  }

  return a3;
}

uint64_t icu::ChoiceFormat::findSubMessage(icu::ChoiceFormat *this, const icu::MessagePattern *a2, double a3)
{
  int v3 = *((_DWORD *)this + 24);
  uint64_t v4 = (int)a2 + 2LL;
  uint64_t v5 = *((void *)this + 11);
  else {
    int v6 = *(_DWORD *)(v5 + 16 * v4 + 12);
  }
  if (v6 + 1 < v3)
  {
    int v7 = (_DWORD *)(v5 + 16LL * (v6 + 1));
    if (*v7 != 6)
    {
      uint64_t v10 = (char *)this + 26;
      do
      {
        double NumericValue = icu::MessagePattern::getNumericValue((uint64_t)this, (uint64_t)v7);
        uint64_t v12 = *((void *)this + 11);
        uint64_t v13 = *(int *)(v12 + 16LL * v6 + 36);
        unsigned int v14 = *((unsigned __int16 *)this + 12);
        if ((v14 & 0x8000u) == 0) {
          unsigned int v15 = v14 >> 5;
        }
        else {
          unsigned int v15 = *((_DWORD *)this + 7);
        }
        if (v15 > v13
          && ((v14 & 2) != 0 ? (int v16 = v10) : (int v16 = (char *)*((void *)this + 5)), *(_WORD *)&v16[2 * v13] == 60))
        {
          if (NumericValue >= a3) {
            return v4;
          }
        }

        else if (NumericValue > a3)
        {
          return v4;
        }

        uint64_t v4 = v6 + 3LL;
        else {
          int v6 = *(_DWORD *)(v12 + 16 * v4 + 12);
        }
        if (v6 + 1 >= v3) {
          break;
        }
        int v7 = (_DWORD *)(v12 + 16LL * (v6 + 1));
      }

      while (*v7 != 6);
    }
  }

  return v4;
}

icu::UnicodeString *icu::ChoiceFormat::format( icu::ChoiceFormat *this, const icu::Formattable *a2, unsigned int a3, icu::UnicodeString *a4, icu::FieldPosition *a5, UErrorCode *a6)
{
  if ((a3 & 0x80000000) != 0)
  {
    UErrorCode v13 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_11:
    *a6 = v13;
    return a4;
  }

  if (!*((_DWORD *)this + 114))
  {
    UErrorCode v13 = U_INVALID_STATE_ERROR;
    goto LABEL_11;
  }

  if (a3)
  {
    uint64_t v11 = a3;
    do
    {
      double Double = icu::Formattable::getDouble(a2, a6);
      if (*(int *)a6 <= 0) {
        (*(void (**)(icu::ChoiceFormat *, icu::UnicodeString *, icu::FieldPosition *, double))(*(void *)this + 64LL))( this,  a4,  a5,  Double);
      }
      a2 = (const icu::Formattable *)((char *)a2 + 112);
      --v11;
    }

    while (v11);
  }

  return a4;
}

uint64_t icu::ChoiceFormat::parse( icu::ChoiceFormat *this, const icu::UnicodeString *a2, icu::Formattable *a3, icu::ParsePosition *a4, icu::ParsePosition *a5)
{
  double v6 = icu::ChoiceFormat::parseArgument((icu::ChoiceFormat *)((char *)this + 360), 0LL, (uint64_t)a2, a4, a5);
  return icu::Formattable::setDouble(a3, v6);
}

double icu::ChoiceFormat::parseArgument( icu::ChoiceFormat *this, const icu::MessagePattern *a2, uint64_t a3, const icu::UnicodeString *a4, icu::ParsePosition *a5)
{
  int v7 = (int)a2;
  uint64_t v9 = (const icu::UnicodeString *)*((unsigned int *)a4 + 2);
  double NaN = uprv_getNaN();
  int v11 = *((_DWORD *)this + 24);
  if (v11 <= v7) {
    goto LABEL_14;
  }
  int v12 = (int)v9;
  do
  {
    UErrorCode v13 = (_DWORD *)(*((void *)this + 11) + 16LL * v7);
    if (*v13 == 6) {
      break;
    }
    double NumericValue = icu::MessagePattern::getNumericValue((uint64_t)this, (uint64_t)v13);
    unsigned int v15 = (const icu::MessagePattern *)(v7 + 2LL);
    int v16 = *(_DWORD *)(*((void *)this + 11) + 16LL * (void)v15 + 12) <= v7 + 2
        ? (int)v15
        : *(_DWORD *)(*((void *)this + 11) + 16 * (v7 + 2LL) + 12);
    int matched = icu::ChoiceFormat::matchStringUntilLimitPart(this, v15, v16, a3, v9);
    if ((matched & 0x80000000) == 0 && matched + (int)v9 > v12)
    {
      unsigned int v18 = *(unsigned __int16 *)(a3 + 8);
      int v19 = (__int16)v18;
      unsigned int v20 = v18 >> 5;
      if (v19 < 0) {
        unsigned int v20 = *(_DWORD *)(a3 + 12);
      }
      int v12 = matched + (_DWORD)v9;
      double NaN = NumericValue;
      if (matched + (_DWORD)v9 == v20) {
        break;
      }
    }

    int v7 = v16 + 1;
  }

  while (v7 < v11);
  if (v12 == (_DWORD)v9) {
LABEL_14:
  }
    *((_DWORD *)a4 + 3) = (_DWORD)v9;
  else {
    *((_DWORD *)a4 + 2) = v12;
  }
  return NaN;
}

uint64_t icu::ChoiceFormat::matchStringUntilLimitPart( icu::ChoiceFormat *this, const icu::MessagePattern *a2, int a3, uint64_t a4, const icu::UnicodeString *a5)
{
  int v5 = (int)a5;
  LODWORD(v8) = 0;
  uint64_t v9 = *((void *)this + 11);
  uint64_t v10 = (int)a2;
  int v11 = *(_DWORD *)(v9 + 16LL * (int)a2 + 4) + *(unsigned __int16 *)(v9 + 16LL * (int)a2 + 8);
  int v12 = (char *)this + 26;
  uint64_t v13 = a3;
  while (1)
  {
    uint64_t v14 = v9 + 16 * v10 + 24;
    do
    {
      unsigned int v15 = (unsigned __int16 *)v14;
      if (v13 == ++v10) {
        break;
      }
      v14 += 16LL;
    }

    while (*((_DWORD *)v15 - 2) != 2);
    int v16 = *((_DWORD *)v15 - 1);
    int32_t v17 = v16 - v11;
    if (v16 == v11) {
      goto LABEL_25;
    }
    unsigned int v18 = *((unsigned __int16 *)this + 12);
    if ((v18 & 1) == 0) {
      break;
    }
    if ((*(_WORD *)(a4 + 8) & 1) == 0) {
      return 0xFFFFFFFFLL;
    }
LABEL_25:
    uint64_t v8 = (v17 + v8);
    if (v13 == v10) {
      return v8;
    }
    int v11 = *((_DWORD *)v15 - 1) + *v15;
    uint64_t v9 = *((void *)this + 11);
  }

  if ((v18 & 0x8000u) == 0) {
    int v19 = v18 >> 5;
  }
  else {
    int v19 = *((_DWORD *)this + 7);
  }
  if (v11 < 0)
  {
    int v20 = 0;
  }

  else
  {
    int v20 = v19;
    if (v19 >= v11)
    {
      if ((v17 & 0x80000000) == 0) {
        goto LABEL_13;
      }
LABEL_19:
      int32_t v21 = 0;
      goto LABEL_20;
    }
  }

  int v11 = v20;
  if (v17 < 0) {
    goto LABEL_19;
  }
LABEL_13:
  int32_t v21 = v19 - v11;
  int32_t v22 = v17;
  if (v21 < v17) {
LABEL_20:
  }
    int32_t v22 = v21;
  if ((v18 & 2) != 0) {
    uint64_t v23 = (uint64_t)v12;
  }
  else {
    uint64_t v23 = *((void *)this + 5);
  }
  return 0xFFFFFFFFLL;
}

icu::NumberFormat *icu::ChoiceFormat::clone@<X0>( icu::ChoiceFormat *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = (icu::NumberFormat *)icu::UMemory::operator new(a3, (icu::UMemory *)0x1E8, a2);
  int v5 = v4;
  if (v4)
  {
    icu::NumberFormat::NumberFormat(v4, this);
    *(void *)int v5 = off_18971F5C8;
    *((_DWORD *)v5 + 89) = *((_DWORD *)this + 89);
    icu::MessagePattern::MessagePattern( (icu::NumberFormat *)((char *)v5 + 360),  (icu::ChoiceFormat *)((char *)this + 360));
  }

  return v5;
}

uint64_t sub_1808A12F8(uint64_t a1)
{
  return *(char *)(a1 + 341);
}

void *icu::CollationElementIterator::getStaticClassID(icu::CollationElementIterator *this)
{
  return &unk_18C535291;
}

void *icu::CollationElementIterator::getDynamicClassID(icu::CollationElementIterator *this)
{
  return &unk_18C535291;
}

uint64_t icu::CollationElementIterator::CollationElementIterator(uint64_t this, uint64_t a2)
{
  *(void *)(this + 8) = 0LL;
  *(void *)(this + 16) = 0LL;
  *(void *)this = off_18971F770;
  *(void *)(this + 2sub_18086E18C((uint64_t)this, 1) = 0LL;
  *(void *)(this + 32) = 0LL;
  *(void *)(this + 40) = off_18971B688;
  *(_WORD *)(this + 48) = 2;
  return icu::CollationElementIterator::operator=(this, a2);
}

{
  *(void *)(this + 8) = 0LL;
  *(void *)(this + 16) = 0LL;
  *(void *)this = off_18971F770;
  *(void *)(this + 2sub_18086E18C((uint64_t)this, 1) = 0LL;
  *(void *)(this + 32) = 0LL;
  *(void *)(this + 40) = off_18971B688;
  *(_WORD *)(this + 48) = 2;
  return icu::CollationElementIterator::operator=(this, a2);
}

uint64_t icu::CollationElementIterator::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(const void **)(a2 + 8);
  if (v4)
  {
    if (v5)
    {
      uint64_t v8 = v5;
      uint64_t v9 = icu::UMemory::operator new(v7, (icu::UMemory *)0x210, v6);
      if (!v9) {
        goto LABEL_22;
      }
      uint64_t v10 = v9;
      __int16 v11 = *(_WORD *)(a1 + 48);
      if ((v11 & 0x11) != 0)
      {
        uint64_t v12 = 0LL;
      }

      else if ((v11 & 2) != 0)
      {
        uint64_t v12 = a1 + 50;
      }

      else
      {
        uint64_t v12 = *(void *)(a1 + 64);
      }

      icu::FCDUTF16CollationIterator::FCDUTF16CollationIterator(v9, v8, v12);
    }

    else
    {
      if (!v13) {
        goto LABEL_22;
      }
      int v16 = v13;
      int32_t v17 = icu::UMemory::operator new(v15, (icu::UMemory *)0x1A0, v14);
      if (!v17) {
        goto LABEL_22;
      }
      uint64_t v10 = v17;
      __int16 v18 = *(_WORD *)(a1 + 48);
      if ((v18 & 0x11) != 0)
      {
        uint64_t v19 = 0LL;
      }

      else if ((v18 & 2) != 0)
      {
        uint64_t v19 = a1 + 50;
      }

      else
      {
        uint64_t v19 = *(void *)(a1 + 64);
      }

      icu::UTF16CollationIterator::UTF16CollationIterator((uint64_t)v17, v16, v19);
    }

    uint64_t v20 = *(void *)(a1 + 8);
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
    }
    uint64_t v21 = *(void *)(a2 + 16);
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v21;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    *(_BYTE *)(a1 + 28) = *(_BYTE *)(a2 + 28);
    icu::UnicodeString::operator=((UChar **)(a1 + 40), (UChar **)(a2 + 40));
  }

void icu::CollationElementIterator::~CollationElementIterator(icu::CollationElementIterator *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  icu::UnicodeString::~UnicodeString((icu::CollationElementIterator *)((char *)this + 40));
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::CollationElementIterator::~CollationElementIterator(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::CollationElementIterator::getOffset(icu::CollationElementIterator *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (!v2) {
    return (*(uint64_t (**)(void))(**((void **)this + 1) + 40LL))(*((void *)this + 1));
  }
  int v3 = *(_DWORD *)(v2 + 8);
  if (!v3) {
    return (*(uint64_t (**)(void))(**((void **)this + 1) + 40LL))(*((void *)this + 1));
  }
  unsigned int v4 = *(_DWORD *)(*((void *)this + 1) + 24LL);
  if (*((_DWORD *)this + 6)) {
    ++v4;
  }
  if ((v4 & 0x80000000) != 0) {
    return 0LL;
  }
  if (v3 >= 1)
  {
    BOOL v7 = __OFSUB__(v3, v4);
    BOOL v5 = v3 == v4;
    BOOL v6 = (int)(v3 - v4) < 0;
  }

  else
  {
    BOOL v7 = 0;
    BOOL v5 = 1;
    BOOL v6 = 0;
  }

  if (v6 ^ v7 | v5) {
    return 0LL;
  }
  else {
    return *(unsigned int *)(*(void *)(v2 + 24) + 4LL * v4);
  }
}

uint64_t icu::CollationElementIterator::next(icu::CollationElementIterator *this, UErrorCode *a2)
{
  if (*((char *)this + 28) < 2)
  {
    if (*((unsigned __int8 *)this + 28) >= 2u)
    {
      *a2 = U_INVALID_STATE_ERROR;
      return 0xFFFFFFFFLL;
    }

    *((_BYTE *)this + 28) = 2;
  }

  else
  {
    uint64_t result = *((unsigned int *)this + 6);
    if ((_DWORD)result)
    {
      *((_DWORD *)this + 6) = 0;
      return result;
    }
  }

  unsigned int v4 = (icu::CollationIterator::CEBuffer *)*((void *)this + 1);
  if (*((_DWORD *)v4 + 92) == *((_DWORD *)v4 + 6))
  {
    *((_DWORD *)v4 + 6) = 0;
    *((_DWORD *)v4 + 92) = 0;
  }

  unint64_t v5 = sub_1808A16BC(v4, a2);
  if (v5 == 0x101000100LL) {
    return 0xFFFFFFFFLL;
  }
  char v6 = v5;
  unsigned int v7 = (v5 >> 8) & 0xFF00 | (HIDWORD(v5) << 16);
  uint64_t result = HIDWORD(v5) & 0xFFFF0000 | WORD1(v5) & 0xFF00 | BYTE1(v5);
  unsigned int v8 = v7 & 0xFFFFFFC0 | v6 & 0x3F;
  if (v8) {
    *((_DWORD *)this + 6) = v8 | 0xC0;
  }
  return result;
}

unint64_t sub_1808A16BC(icu::CollationIterator::CEBuffer *this, UErrorCode *a2)
{
  unsigned int v4 = (int *)((char *)this + 24);
  int v3 = *((_DWORD *)this + 6);
  uint64_t v5 = *((int *)this + 92);
  if ((int)v5 < v3)
  {
    *((_DWORD *)this + 92) = v5 + 1;
    return *(void *)(*((void *)this + 4) + 8 * v5);
  }

  if (v3 >= 40)
  {
    if (!icu::CollationIterator::CEBuffer::ensureAppendCapacity( (icu::CollationIterator::CEBuffer *)((char *)this + 24),  1,  a2)) {
      return 0x101000100LL;
    }
    int v3 = *v4;
  }

  *((_DWORD *)this + 6) = v3 + 1;
  int v13 = 0;
  int v8 = (*(uint64_t (**)(icu::CollationIterator::CEBuffer *, int *, UErrorCode *))(*(void *)this + 64LL))( this,  &v13,  a2);
  int v9 = v8;
  if (v8 <= 0xBFu)
  {
LABEL_7:
    uint64_t v10 = *((int *)this + 92);
    *((_DWORD *)this + 92) = v10 + 1;
    unint64_t result = (v8 << 16) & 0xFF000000 | ((unint64_t)((v8 & 0xFFFF0000) >> 16) << 48) | (v9 << 8);
    *(void *)(*((void *)this + 4) + 8 * v10) = result;
    return result;
  }

  if (v8 == 192)
  {
    if (v13 < 0)
    {
      unint64_t result = 0x101000100LL;
      uint64_t v12 = *((int *)this + 92);
      *((_DWORD *)this + 92) = v12 + 1;
      goto LABEL_18;
    }

    __int16 v11 = *(uint64_t **)(*((void *)this + 2) + 32LL);
    int v8 = sub_1808A22C4(v11, v13);
    int v9 = v8;
  }

  else
  {
    __int16 v11 = (uint64_t *)*((void *)this + 2);
  }

  if (v9 != 193) {
    return icu::CollationIterator::nextCEFromCE32(this, (const icu::CollationData *)v11, v13, v8, a2);
  }
  uint64_t v12 = *((int *)this + 92);
  *((_DWORD *)this + 92) = v12 + 1;
  unint64_t result = ((unint64_t)(v8 - 193) << 32) | 0x5000500;
LABEL_18:
  *(void *)(*((void *)this + 4) + 8 * v12) = result;
  return result;
}

uint64_t icu::CollationElementIterator::operator!=(uint64_t a1, uint64_t a2)
{
  return icu::CollationElementIterator::operator==(a1, a2) ^ 1;
}

uint64_t icu::CollationElementIterator::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  unsigned int v4 = *(icu::RuleBasedCollator **)(a1 + 16);
  uint64_t v5 = *(icu::RuleBasedCollator **)(a2 + 16);
  if (v4 != v5)
  {
    uint64_t result = icu::RuleBasedCollator::operator==(v4, v5);
    if (!(_DWORD)result) {
      return result;
    }
  }

  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
    return 0LL;
  }
  uint64_t result = 0LL;
  int v7 = *(unsigned __int8 *)(a1 + 28);
  if (v7 == 1) {
    int v7 = 0;
  }
  int v8 = *(unsigned __int8 *)(a2 + 28);
  if (v8 == 1) {
    int v8 = 0;
  }
  if (v7 != v8) {
    return result;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 48);
  if ((v9 & 1) != 0)
  {
    if ((*(_WORD *)(a2 + 48) & 1) != 0) {
      return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 24LL))( *(void *)(a1 + 8),  *(void *)(a2 + 8));
    }
    return 0LL;
  }

  if ((v9 & 0x8000) != 0) {
    int v10 = *(_DWORD *)(a1 + 52);
  }
  else {
    int v10 = v9 >> 5;
  }
  uint64_t result = 0LL;
  unsigned int v11 = *(unsigned __int16 *)(a2 + 48);
  if ((v11 & 0x8000u) == 0) {
    unsigned int v12 = v11 >> 5;
  }
  else {
    unsigned int v12 = *(_DWORD *)(a2 + 52);
  }
  if ((v11 & 1) == 0 && v10 == v12)
  {
    uint64_t result = icu::UnicodeString::doEquals((icu::UnicodeString *)(a1 + 40), (const icu::UnicodeString *)(a2 + 40), v10);
    if ((_DWORD)result) {
      return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 24LL))( *(void *)(a1 + 8),  *(void *)(a2 + 8));
    }
  }

  return result;
}

uint64_t icu::CollationElementIterator::previous(icu::CollationElementIterator *this, UErrorCode *a2)
{
  uint64_t v6 = *((char *)this + 28);
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v2 = *((unsigned int *)this + 6);
    if ((_DWORD)v2)
    {
      *((_DWORD *)this + 6) = 0;
      return v2;
    }
  }

  else
  {
    if (*((_BYTE *)this + 28) != 1)
    {
      if (*((_BYTE *)this + 28))
      {
        UErrorCode v9 = U_INVALID_STATE_ERROR;
        goto LABEL_36;
      }

      uint64_t v7 = *((void *)this + 1);
      else {
        uint64_t v8 = *((unsigned __int16 *)this + 24) >> 5;
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 32LL))(v7, v8);
    }

    uint64_t v6 = 255LL;
    *((_BYTE *)this + 28) = -1;
  }

  int v10 = (icu::UVector32 *)*((void *)this + 4);
  if (v10) {
    goto LABEL_18;
  }
  unsigned int v11 = (icu::UVector32 *)icu::UMemory::operator new((uint64_t *)v6, (icu::UMemory *)0x20, (unint64_t)a2);
  if (v11)
  {
    int v10 = v11;
    *((void *)this + 4) = icu::UVector32::UVector32(v11, a2);
LABEL_18:
    unsigned int v12 = (icu::CollationIterator *)*((void *)this + 1);
    if (*((_DWORD *)v12 + 6))
    {
      int v13 = 0;
    }

    else
    {
      int v13 = (*(uint64_t (**)(icu::CollationIterator *))(*(void *)v12 + 40LL))(v12);
      unsigned int v12 = (icu::CollationIterator *)*((void *)this + 1);
      int v10 = (icu::UVector32 *)*((void *)this + 4);
    }

    unint64_t v14 = icu::CollationIterator::previousCE(v12, v10, a2);
    if (v14 == 0x101000100LL) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v2 = HIDWORD(v14) & 0xFFFF0000 | WORD1(v14) & 0xFF00 | BYTE1(v14);
    int v15 = (v14 >> 8) & 0xFF00 | (HIDWORD(v14) << 16) | v14 & 0x3F;
    if (!v15) {
      return v2;
    }
    uint64_t v16 = *((void *)this + 4);
    if (*(_DWORD *)(v16 + 8)) {
      goto LABEL_34;
    }
    int v17 = (*(uint64_t (**)(void))(**((void **)this + 1) + 40LL))(*((void *)this + 1));
    int v18 = *(_DWORD *)(v16 + 8);
    if (v18 < -1 || *(_DWORD *)(v16 + 12) <= v18)
    {
      int v18 = *(_DWORD *)(v16 + 8);
    }

    *(_DWORD *)(*(void *)(v16 + 24) + 4LL * v18) = v17;
    ++*(_DWORD *)(v16 + 8);
LABEL_29:
    uint64_t v19 = *((void *)this + 4);
    int v20 = *(_DWORD *)(v19 + 8);
    if (v20 >= -1 && *(_DWORD *)(v19 + 12) > v20) {
      goto LABEL_33;
    }
    if (icu::UVector32::expandCapacity(*((icu::UVector32 **)this + 4), v20 + 1, a2))
    {
      int v20 = *(_DWORD *)(v19 + 8);
LABEL_33:
      *(_DWORD *)(*(void *)(v19 + 24) + 4LL * v20) = v13;
      ++*(_DWORD *)(v19 + 8);
    }

uint64_t icu::CollationElementIterator::reset(icu::CollationElementIterator *this)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 1) + 32LL))(*((void *)this + 1), 0LL);
  *((_DWORD *)this + 6) = 0;
  *((_BYTE *)this + 28) = 0;
  return result;
}

unint64_t icu::CollationElementIterator::setOffset(unint64_t this, uint64_t a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v4 = this;
    int v6 = *(__int16 *)(this + 48) < 0 ? *(_DWORD *)(this + 52) : *(unsigned __int16 *)(this + 48) >> 5;
    uint64_t v7 = a2;
    do
    {
      unsigned int v8 = *(unsigned __int16 *)(v4 + 48);
      else {
        unsigned int v9 = v8 >> 5;
      }
      if (v9 <= v7)
      {
        int v11 = 0xFFFF;
      }

      else
      {
        uint64_t v10 = v4 + 50;
        if ((v8 & 2) == 0) {
          uint64_t v10 = *(void *)(v4 + 64);
        }
        int v11 = *(unsigned __int16 *)(v10 + 2LL * v7);
      }

      unsigned int v12 = (uint64_t *)((unsigned __int16)v11 & 0xFC00);
      if ((_DWORD)v12 == 55296)
      {
        int v13 = *(icu::RuleBasedCollator **)(v4 + 16);
        int v14 = icu::UnicodeString::char32At(v12, (icu::UnicodeString *)(v4 + 40), v7);
      }

      uint64_t v7 = (v7 - 1);
    }

    while ((_DWORD)v7);
    if ((int)v7 >= (int)a2)
    {
LABEL_29:
      uint64_t v7 = a2;
LABEL_30:
      this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 8) + 32LL))(*(void *)(v4 + 8), v7);
      *(_DWORD *)(v4 + 24) = 0;
      *(_BYTE *)(v4 + 28) = 1;
    }

    else
    {
LABEL_21:
      (*(void (**)(void, uint64_t))(**(void **)(v4 + 8) + 32LL))(*(void *)(v4 + 8), v7);
      while (1)
      {
        this = sub_1808A16BC(*(icu::CollationIterator::CEBuffer **)(v4 + 8), a3);
        int v15 = (*(uint64_t (**)(void))(**(void **)(v4 + 8) + 40LL))(*(void *)(v4 + 8));
        if (v15 != (_DWORD)v7)
        {
          else {
            uint64_t v7 = v7;
          }
          goto LABEL_30;
        }
      }
    }
  }

  return this;
}

uint64_t *icu::CollationElementIterator::setText(uint64_t *this, UChar **a2, UErrorCode *a3)
{
  uint64_t v4 = this;
  icu::UnicodeString::operator=((UChar **)this + 5, a2);
  __int16 v6 = *((_WORD *)v4 + 24);
  if ((v6 & 0x11) != 0)
  {
    uint64_t v7 = 0LL;
  }

  else if ((v6 & 2) != 0)
  {
    uint64_t v7 = (char *)v4 + 50;
  }

  else
  {
    uint64_t v7 = (char *)v4[8];
  }

  unsigned int v8 = (uint64_t *)*(unsigned int *)(*(void *)(v4[2] + 16) + 24LL);
  unsigned int v9 = (v8 >> 1) & 1;
  if ((v8 & 1) != 0)
  {
    this = icu::UMemory::operator new(v8, (icu::UMemory *)0x210, v5);
    if (this)
    {
      uint64_t v10 = this;
      int v13 = *(uint64_t **)(v4[2] + 8);
      else {
        int v14 = *((unsigned __int16 *)v4 + 24) >> 5;
      }
      this[4] = (uint64_t)(this + 6);
      *((_DWORD *)this + 10) = 40;
      uint64_t v16 = (uint64_t)&v7[2 * v14];
      *((_DWORD *)this + 96) = -1;
      uint64_t v17 = *v13;
      this[2] = (uint64_t)v13;
      *((_DWORD *)this + 6) = 0;
      *((_BYTE *)this + 44) = 0;
      *((_DWORD *)this + 92) = 0;
      this[47] = 0LL;
      *((_BYTE *)this + 388) = v9;
      this[49] = (uint64_t)v7;
      this[50] = (uint64_t)v7;
      *this = (uint64_t)off_18972D040;
      this[1] = v17;
      this[51] = v16;
      this[52] = (uint64_t)v7;
      this[53] = (uint64_t)v7;
      this[54] = 0LL;
      uint64_t v18 = v13[6];
      this[55] = v16;
      this[56] = v18;
      this[57] = (uint64_t)off_18971B688;
      *((_WORD *)this + 232) = 2;
      *((_BYTE *)this + 520) = 1;
      goto LABEL_19;
    }

uint64_t *icu::CollationElementIterator::setText(uint64_t *this, icu::CharacterIterator *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v4 = this;
    unint64_t v5 = (UChar **)(this + 5);
    (*(void (**)(icu::CharacterIterator *, uint64_t *))(*(void *)a2 + 208LL))(a2, this + 5);
    return icu::CollationElementIterator::setText(v4, v5, a3);
  }

  return this;
}

uint64_t icu::CollationElementIterator::strengthOrder(icu::CollationElementIterator *this, uint64_t a2)
{
  int v2 = *(int *)(*(void *)(*((void *)this + 2) + 16LL) + 24LL) >> 12;
  if (v2 == 1) {
    return a2 & 0xFFFFFF00;
  }
  if (!v2) {
    return a2 & 0xFFFF0000;
  }
  return a2;
}

uint64_t icu::CollationElementIterator::CollationElementIterator( uint64_t a1, UChar **a2, uint64_t a3, UErrorCode *a4)
{
  *(void *)a1 = off_18971F770;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 28) = 0;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = off_18971B688;
  *(_WORD *)(a1 + 48) = 2;
  icu::CollationElementIterator::setText((uint64_t *)a1, a2, a4);
  return a1;
}

{
  *(void *)a1 = off_18971F770;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 28) = 0;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = off_18971B688;
  *(_WORD *)(a1 + 48) = 2;
  icu::CollationElementIterator::setText((uint64_t *)a1, a2, a4);
  return a1;
}

uint64_t icu::CollationElementIterator::CollationElementIterator( uint64_t a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  *(void *)a1 = off_18971F770;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 28) = 0;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = off_18971B688;
  unint64_t v5 = (UChar **)(a1 + 40);
  *(_WORD *)(a1 + 48) = 2;
  if (*(int *)a4 <= 0)
  {
    (*(void (**)(uint64_t, UChar **))(*(void *)a2 + 208LL))(a2, v5);
    icu::CollationElementIterator::setText((uint64_t *)a1, v5, a4);
  }

  return a1;
}

int32x2_t *icu::CollationElementIterator::computeMaxExpansions( icu::CollationElementIterator *this, const icu::CollationData *a2, UErrorCode *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unint64_t v5 = uhash_open((uint64_t)uhash_hashLong, (uint64_t)uhash_compareLong, (uint64_t)uhash_compareLong, (int *)a2);
  __int16 v6 = v5;
  v11[0] = &off_18971F7B0;
  v11[1] = v5;
  _OWORD v11[2] = a2;
  memset(v12, 0, 24);
  void v12[3] = v11;
  __int16 v13 = 1;
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v14);
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v15);
  uint64_t v16 = off_18971B688;
  __int16 v17 = 2;
  uint64_t v18 = 0LL;
  int v19 = 0;
  sub_1808B9054((uint64_t)v12, (uint64_t *)this, (int *)a2);
  icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)&v16);
  icu::UnicodeSet::~UnicodeSet(v9, (icu::UnicodeSet *)v15);
  icu::UnicodeSet::~UnicodeSet(v10, (icu::UnicodeSet *)v14);
  if (*(int *)a2 >= 1)
  {
    uhash_close(v6);
    __int16 v6 = 0LL;
  }

  nullsub_17(v11);
  return v6;
}

uint64_t icu::CollationElementIterator::getMaxExpansion(icu::CollationElementIterator *this, unsigned int a2)
{
  if (!a2) {
    return 1LL;
  }
  uint64_t v3 = *(void *)(*(void *)(*((void *)this + 2) + 24LL) + 384LL);
  if (!v3 || (uint64_t result = uhash_igeti(v3, a2), !(_DWORD)result))
  {
    if ((~a2 & 0xC0) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t icu::CollationElementIterator::getMaxExpansion(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 1LL;
  }
  if (!a1 || (uint64_t result = uhash_igeti(a1, a2), !(_DWORD)result))
  {
    if ((~a2 & 0xC0) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t sub_1808A22C4(uint64_t *a1, unsigned int a2)
{
  int v2 = (uint64_t *)*a1;
  if (a2 >> 11 <= 0x1A)
  {
    uint64_t v3 = *v2;
    unsigned int v4 = a2 >> 5;
LABEL_12:
    int v6 = (a2 & 0x1F) + 4 * *(unsigned __int16 *)(v3 + 2LL * v4);
    return *(unsigned int *)(*(void *)(*a1 + 16) + 4LL * v6);
  }

  if (!HIWORD(a2))
  {
    uint64_t v3 = *v2;
    if (a2 >> 10 >= 0x37) {
      int v5 = 0;
    }
    else {
      int v5 = 320;
    }
    unsigned int v4 = v5 + (a2 >> 5);
    goto LABEL_12;
  }

  if (HIWORD(a2) <= 0x10u)
  {
    if (*((_DWORD *)v2 + 11) <= (signed int)a2)
    {
      int v6 = *((_DWORD *)v2 + 12);
      return *(unsigned int *)(*(void *)(*a1 + 16) + 4LL * v6);
    }

    uint64_t v3 = *v2;
    unsigned int v4 = ((a2 >> 5) & 0x3F) + *(unsigned __int16 *)(v3 + 2LL * ((a2 >> 11) + 2080));
    goto LABEL_12;
  }

  int v6 = 128;
  return *(unsigned int *)(*(void *)(*a1 + 16) + 4LL * v6);
}

void sub_1808A2354(uint64_t a1)
{
  double v1 = (void *)nullsub_17(a1);
  icu::UMemory::operator delete(v1);
}

uint64_t sub_1808A236C(uint64_t result, uint64_t *a2, int a3)
{
  if (a3 >= 2)
  {
    uint64_t v3 = result;
    signed int v4 = 0;
    int v5 = a2;
    uint64_t v6 = a3;
    do
    {
      uint64_t v7 = *v5++;
      if ((v7 & 0xFFFF00FF003FLL) != 0) {
        int v8 = 2;
      }
      else {
        int v8 = 1;
      }
      v4 += v8;
      --v6;
    }

    while (v6);
    unsigned int v9 = a2[a3 - 1];
    int v10 = HIDWORD(a2[a3 - 1]);
    int v11 = (v9 >> 8) & 0xFF00 | (v10 << 16) | v9 & 0x3F;
    unsigned int v12 = v10 & 0xFFFF0000 | HIWORD(v9) & 0xFF00 | BYTE1(v9);
    if (v11) {
      unsigned int v13 = v11 | 0xC0;
    }
    else {
      unsigned int v13 = v12;
    }
    uint64_t result = uhash_igeti(*(void *)(result + 8), v13);
  }

  return result;
}

icu::RuleBasedCollator *icu::Collator::createInstance(icu::Collator *this, UErrorCode *a2)
{
  Default = icu::Locale::getDefault(this);
  return icu::Collator::createInstance((icu::Collator *)Default, this, v4);
}

icu::RuleBasedCollator *icu::Collator::createInstance( icu::Collator *this, const icu::Locale *a2, UErrorCode *a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (*((_BYTE *)this + 216))
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = 1;
    return v3;
  }

  uint64_t Instance = icu::Collator::makeInstance(this, a2, a3);
  uint64_t v3 = Instance;
  int v8 = (const char *)*((void *)this + 5);
  int BaseName = (const char *)icu::Locale::getBaseName(this);
  if (!strcmp(v8, BaseName)) {
    goto LABEL_100;
  }
  memset(__s1, 0, 25);
  bzero(__dst, 0x400uLL);
  for (uint64_t i = (unsigned __int8 *)*((void *)this + 5); ; ++i)
  {
    int v11 = *i;
    if ((v11 | 0x40) == 0x40) {
      break;
    }
  }

  unsigned int v12 = (const char *)(v11 == 64 ? i + 1 : i);
  int v13 = *(unsigned __int8 *)v12;
  if (!*v12) {
    goto LABEL_100;
  }
  while (1)
  {
    while (1)
    {
      if (!v13) {
        goto LABEL_44;
      }
      if (v13 != 32) {
        break;
      }
      int v14 = *(unsigned __int8 *)++v12;
      int v13 = v14;
    }

    uint64_t v15 = strchr(v12, 61);
    uint64_t v16 = strchr(v12, 59);
    if (!v15) {
      goto LABEL_97;
    }
    __int16 v17 = v16;
    if (v16)
    {
      if (v16 < v15) {
        goto LABEL_97;
      }
    }

    uint64_t v18 = v15 - v12;
    if (v15 - v12 > 24) {
      break;
    }
    if (v18 < 1) {
      goto LABEL_97;
    }
    uint64_t v19 = 0LL;
    int v20 = 0;
    do
    {
      int v21 = v12[v19];
      if (v21 != 32) {
        __s1[v20++] = uprv_asciitolower((char)v21);
      }
      ++v19;
    }

    while (v18 > v19);
    if (!v20) {
      goto LABEL_97;
    }
    __s1[v20] = 0;
    int v22 = (_DWORD)v17 - (_DWORD)v15 + 1;
    do
    {
      int v24 = *++v15;
      int v23 = v24;
      --v22;
    }

    while (v24 == 32);
    if (!v23 || v15 == v17)
    {
LABEL_97:
      int v45 = 3;
      goto LABEL_99;
    }

    if (!v17)
    {
      uint64_t v29 = (int)strlen(v15) - 1LL;
      while (v29 != -1)
      {
        int v30 = v15[v29--];
        if (v30 != 32)
        {
          unsigned int v12 = 0LL;
          int v28 = v29 + 2;
          goto LABEL_42;
        }
      }

      unsigned int v12 = 0LL;
      int v28 = 0;
      goto LABEL_43;
    }

    uint64_t v26 = 0LL;
    do
      int v27 = v17[--v26];
    while (v27 == 32);
    int v28 = v22 + v26;
    unsigned int v12 = v17 + 1;
LABEL_42:
    if (v28 >= 1025) {
      break;
    }
LABEL_43:
    strncpy(__dst, v15, v28);
    __dst[v28] = 0;
LABEL_44:
    if (*(void *)__s1 != 0x6F6974616C6C6F63LL || *(unsigned __int16 *)&__s1[8] != 110)
    {
      BOOL v33 = *(void *)__s1 == 0x67617269686C6F63LL
         && *(void *)&__s1[8] == 0x6574617571616E61LL
         && *(void *)&__s1[14] == 0x7972616E726574LL;
      if (v33 || (*(void *)__s1 == 0x656C626169726176LL ? (BOOL v34 = *(_DWORD *)&__s1[8] == 7368564) : (BOOL v34 = 0), v34))
      {
        int v45 = 16;
        goto LABEL_99;
      }

      for (uint64_t j = 0LL; j != 14; j += 2LL)
      {
        if (!strcmp(__s1, (&off_18971F9C8)[j]))
        {
          uint64_t v38 = 0LL;
          while (uprv_stricmp(__dst, (unsigned __int8 *)(&off_18971FA38)[v38]))
          {
            v38 += 2LL;
            if (v38 == 22) {
              goto LABEL_98;
            }
          }

          (*(void (**)(icu::RuleBasedCollator *, void, void, const icu::Locale *))(*(void *)v3 + 184LL))( v3,  LODWORD((&off_18971F9C8)[j + 1]),  LODWORD((&off_18971FA38)[v38 + 1]),  a2);
          goto LABEL_75;
        }
      }

      if (*(void *)__s1 == 0x64726F65726C6F63LL && *(void *)&__s1[3] == 0x726564726F6572LL)
      {
        bzero(v46, 0x334uLL);
        uint64_t v39 = 0LL;
        int v40 = __dst;
        while (v39 != 205)
        {
          for (uint64_t k = 0LL; ; ++k)
          {
            int v42 = v40[k];
            if (!v40[k] || v42 == 45) {
              break;
            }
          }

          v40[k] = 0;
          if (k == 4)
          {
            int32_t PropertyValueEnum = u_getPropertyValueEnum(UCHAR_SCRIPT, v40);
          }

          else
          {
            uint64_t v44 = 0LL;
            while (uprv_stricmp(v40, (unsigned __int8 *)off_18971FAE8[v44]))
            {
              if (++v44 == 5) {
                goto LABEL_98;
              }
            }

            int32_t PropertyValueEnum = v44 + 4096;
          }

          if (PropertyValueEnum < 0) {
            break;
          }
          v46[v39] = PropertyValueEnum;
          v40 += k + 1;
          ++v39;
          if (!v42)
          {
            (*(void (**)(icu::RuleBasedCollator *, _DWORD *))(*(void *)v3 + 168LL))(v3, v46);
            goto LABEL_75;
          }
        }

        goto LABEL_98;
      }

      if (!(*(unsigned __int16 *)__s1 ^ 0x766B | __s1[2]))
      {
        uint64_t v37 = sub_1808A3494(__dst);
        if ((v37 & 0x80000000) == 0)
        {
          (*(void (**)(icu::RuleBasedCollator *, uint64_t, const icu::Locale *))(*(void *)v3 + 200LL))( v3,  v37,  a2);
          goto LABEL_75;
        }

icu::RuleBasedCollator *icu::Collator::makeInstance( icu::Collator *this, const icu::Locale *a2, UErrorCode *a3)
{
  signed int v4 = sub_1809B4508((uint64_t)this, a2);
  uint64_t v6 = (const icu::CollationCacheEntry *)v4;
  uint64_t v7 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v7 <= 0)
  {
    unsigned int v9 = (icu::RuleBasedCollator *)icu::UMemory::operator new(v7, (icu::UMemory *)0x110, v5);
    if (v9)
    {
      int v8 = v9;
      icu::RuleBasedCollator::RuleBasedCollator(v9, v6);
      icu::SharedObject::removeRef(v6);
      return v8;
    }

    *(_DWORD *)a2 = 7;
    if (v6) {
      goto LABEL_3;
    }
  }

  else if (v4)
  {
LABEL_3:
    icu::SharedObject::removeRef(v6);
  }

  return 0LL;
}

uint64_t icu::Collator::safeClone(icu::Collator *this)
{
  return (*(uint64_t (**)(icu::Collator *))(*(void *)this + 40LL))(this);
}

uint64_t icu::Collator::compare( icu::Collator *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v4 = 0;
  return (*(uint64_t (**)(icu::Collator *, const icu::UnicodeString *, const icu::UnicodeString *, int *))(*(void *)this + 56LL))( this,  a2,  a3,  &v4);
}

uint64_t icu::Collator::compare( icu::Collator *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, uint64_t a4)
{
  int v5 = 0;
  return (*(uint64_t (**)(icu::Collator *, const icu::UnicodeString *, const icu::UnicodeString *, uint64_t, int *))(*(void *)this + 72LL))( this,  a2,  a3,  a4,  &v5);
}

uint64_t icu::Collator::compare(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v6 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)a1 + 88LL))( a1,  a2,  a3,  a4,  a5,  &v6);
}

uint64_t icu::Collator::compare(icu::Collator *this, UCharIterator *a2, UCharIterator *a3, UErrorCode *a4)
{
  return 0LL;
}

uint64_t icu::Collator::compareUTF8( icu::Collator *this, const icu::StringPiece *a2, const icu::StringPiece *a3, UErrorCode *a4)
{
  return (*(uint64_t (**)(icu::Collator *, UCharIterator *, UCharIterator *, UErrorCode *))(*(void *)this + 96LL))( this,  &iter,  &v8,  a4);
}

BOOL icu::Collator::equals(icu::Collator *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v4 = 0;
  return (*(unsigned int (**)(icu::Collator *, const icu::UnicodeString *, const icu::UnicodeString *, int *))(*(void *)this + 56LL))( this,  a2,  a3,  &v4) == 0;
}

BOOL icu::Collator::greaterOrEqual( icu::Collator *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v4 = 0;
  return (*(unsigned int (**)(icu::Collator *, const icu::UnicodeString *, const icu::UnicodeString *, int *))(*(void *)this + 56LL))( this,  a2,  a3,  &v4) != -1;
}

BOOL icu::Collator::greater(icu::Collator *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v4 = 0;
  return (*(unsigned int (**)(icu::Collator *, const icu::UnicodeString *, const icu::UnicodeString *, int *))(*(void *)this + 56LL))( this,  a2,  a3,  &v4) == 1;
}

uint64_t icu::Collator::getAvailableLocales(icu::Collator *this, int *a2)
{
  int v4 = 0;
  *(_DWORD *)this = 0;
  if (!sub_1808A2C74(&v4)) {
    return 0LL;
  }
  uint64_t result = qword_18C535298;
  *(_DWORD *)this = dword_18C5352A0;
  return result;
}

BOOL sub_1808A2C74(int *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (*a1 <= 0)
  {
    unsigned int v2 = atomic_load(&dword_18C5352A8);
    if (v2 == 2 || !icu::umtx_initImplPreInit(&dword_18C5352A8))
    {
      if (dword_18C5352AC >= 1) {
        *a1 = dword_18C5352AC;
      }
    }

    else
    {
      uint64_t v17 = 0LL;
      memset(v16, 0, sizeof(v16));
      icu::StackUResourceBundle::StackUResourceBundle((icu::StackUResourceBundle *)v16);
      uint64_t v3 = ures_openDirect((uint64_t)"icudt74l-coll", (uint64_t)"res_index", (uint64_t)a1);
      ures_getByKey(v3, "InstalledLocales", (uint64_t)v16, a1);
      if (*a1 <= 0)
      {
        int Size = ures_getSize((uint64_t)v16);
        dword_18C5352A0 = Size;
        uint64_t v7 = Size;
        if (is_mul_ok(Size, 0xE0uLL)) {
          uint64_t v8 = (224LL * Size) | 0x10;
        }
        else {
          uint64_t v8 = -1LL;
        }
        unsigned int v9 = (void *)icu::UMemory::operator new[]((icu::UMemory *)v8, v6);
        if (v9)
        {
          *unsigned int v9 = 224LL;
          v9[1] = v7;
          uint64_t v10 = (uint64_t)(v9 + 2);
          if ((_DWORD)v7)
          {
            uint64_t v11 = 224 * v7;
            unsigned int v12 = (icu::Locale *)(v9 + 2);
            do
            {
              unsigned int v12 = (icu::Locale *)(icu::Locale::Locale(v12) + 224);
              v11 -= 224LL;
            }

            while (v11);
          }

          qword_18C535298 = v10;
          ures_resetIterator((uint64_t)v16);
          if (ures_hasNext((BOOL)v16))
          {
            uint64_t v13 = 0LL;
            do
            {
              int v14 = 0LL;
              ures_getNextString((uint64_t)v16, 0LL, &v14, a1);
              icu::Locale::Locale((icu::Locale *)v15, v14, 0LL, 0LL, 0LL);
              icu::Locale::operator=(qword_18C535298 + v13, (uint64_t)v15);
              icu::Locale::~Locale((icu::Locale *)v15);
              v13 += 224LL;
            }

            while (ures_hasNext((BOOL)v16));
          }
        }

        else
        {
          qword_18C535298 = 0LL;
        }
      }

      ures_close(v3);
      sub_1809B36C0(0x1Bu, (uint64_t)sub_1808A34EC);
      icu::StackUResourceBundle::~StackUResourceBundle((icu::StackUResourceBundle *)v16);
      dword_18C5352AC = *a1;
      icu::umtx_initImplPostInit(&dword_18C5352A8);
    }
  }

  return *a1 < 1;
}

icu::UnicodeString *icu::Collator::getDisplayName( icu::Collator *this, const icu::Locale *a2, icu::UnicodeString *a3)
{
  Default = icu::Locale::getDefault(this);
  return icu::Locale::getDisplayName((char **)this, (char **)Default, a2);
}

void *icu::Collator::Collator(void *this)
{
  *this = off_18971F7F8;
  return this;
}

void *icu::Collator::Collator(void *result)
{
  *uint64_t result = off_18971F7F8;
  return result;
}

void *icu::Collator::Collator(void *this, const icu::Collator *a2)
{
  *this = off_18971F7F8;
  return this;
}

BOOL icu::Collator::operator==(void *a1, void *a2)
{
  if (!a1) {
    __cxa_bad_typeid();
  }
  return sub_1807F874C(*(void *)(*a1 - 8LL), *(void *)(*a2 - 8LL));
}

uint64_t icu::Collator::operator!=(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 24LL))(a1) ^ 1;
}

icu::UnicodeSet *icu::Collator::getTailoredSet(icu::Collator *this, UErrorCode *a2)
{
  unsigned int v2 = (uint64_t *)*(unsigned int *)a2;
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(v2, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result) {
    return icu::UnicodeSet::UnicodeSet(result, 0, 0x10FFFFu);
  }
  return result;
}

void sub_1808A2FA8(icu::StringEnumeration *a1)
{
}

void *sub_1808A2FBC()
{
  return &unk_18C5352A4;
}

uint64_t *icu::Collator::getAvailableLocales(icu::Collator *this)
{
  int v4 = 0;
  if (!sub_1808A2C74(&v4)) {
    return 0LL;
  }
  uint64_t result = icu::UMemory::operator new(v2, (icu::UMemory *)0x78, v1);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::StringEnumeration::StringEnumeration((uint64_t)result);
    *uint64_t result = (uint64_t)&off_18971F958;
    *((_DWORD *)result + 29) = 0;
  }

  return result;
}

uint64_t *icu::Collator::getKeywords(icu::Collator *this, UErrorCode *a2)
{
  Keywords = (void **)ucol_getKeywords((int *)this);
  return icu::UStringEnumeration::fromUEnumeration(Keywords, this);
}

uint64_t *icu::Collator::getKeywordValues(icu::Collator *this, char *a2, UErrorCode *a3)
{
  KeywordValues = (void **)ucol_getKeywordValues((const char *)this, (int *)a2);
  return icu::UStringEnumeration::fromUEnumeration(KeywordValues, a2);
}

uint64_t *icu::Collator::getKeywordValuesForLocale( icu::Collator *this, char **a2, const icu::Locale *a3, int *a4, UErrorCode *a5)
{
  KeywordValuesForLocale = (void **)ucol_getKeywordValuesForLocale((uint64_t)this, a2[5], (uint64_t)a3, a4);
  return icu::UStringEnumeration::fromUEnumeration(KeywordValuesForLocale, a4);
}

icu::Locale *icu::Collator::getFunctionalEquivalent@<X0>( icu::Collator *this@<X0>, const char *a2@<X1>, const icu::Locale *a3@<X2>, signed __int8 *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  memset(v9, 0, 157);
  ucol_getFunctionalEquivalent((uint64_t)v9, 157LL, (uint64_t)this, *((void *)a2 + 5), (uint64_t)a3, (int *)a4);
  return icu::Locale::createFromName((icu::Locale *)v9, a5);
}

uint64_t icu::Collator::getStrength(icu::Collator *this)
{
  int v2 = 0;
  return (*(uint64_t (**)(icu::Collator *, uint64_t, int *))(*(void *)this + 192LL))(this, 5LL, &v2);
}

uint64_t icu::Collator::setStrength(uint64_t a1, uint64_t a2)
{
  int v3 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)a1 + 184LL))(a1, 5LL, a2, &v3);
}

void icu::Collator::setMaxVariable(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0) {
    *a3 = 16;
  }
}

uint64_t icu::Collator::getMaxVariable(icu::Collator *this)
{
  return 4097LL;
}

uint64_t icu::Collator::getReorderCodes(icu::Collator *this, int *a2, int a3, UErrorCode *a4)
{
  return 0LL;
}

void icu::Collator::setReorderCodes(icu::Collator *this, const int *a2, int a3, UErrorCode *a4)
{
}

uint64_t icu::Collator::getEquivalentReorderCodes( icu::Collator *this, UErrorCode *a2, int *a3, icu::CollationRoot *a4, UErrorCode *a5)
{
  int v6 = (int)a3;
  if ((a3 & 0x80000000) != 0 || (unsigned int v8 = this, !a2) && (_DWORD)a3)
  {
    *(_DWORD *)a4 = 1;
    return 0LL;
  }

  Data = (icu::CollationData *)icu::CollationRoot::getData(a4, a2);
  return icu::CollationData::getEquivalentScripts(Data, v8, (unsigned int *)a2, v6, (UErrorCode *)a4);
}

uint64_t icu::Collator::internalGetShortDefinitionString( icu::Collator *this, const char *a2, char *a3, int a4, UErrorCode *a5)
{
  return 0LL;
}

uint64_t icu::Collator::internalCompareUTF8( icu::Collator *this, const char *__s, int a3, const char *a4, int a5, UErrorCode *a6)
{
  int v8 = a5;
  if ((__s || !a3) && (a4 || !a5))
  {
    if (a3 < 0) {
      a3 = strlen(__s);
    }
    int v14 = __s;
    int v15 = a3;
    if (v8 < 0) {
      int v8 = strlen(a4);
    }
    unsigned int v12 = a4;
    int v13 = v8;
    return (*(uint64_t (**)(icu::Collator *, const char **, const char **, UErrorCode *))(*(void *)this
                                                                                                  + 104LL))( this,  &v14,  &v12,  a6);
  }

  else
  {
    uint64_t result = 0LL;
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return result;
}

uint64_t icu::Collator::internalNextSortKeyPart( icu::Collator *this, UCharIterator *a2, unsigned int *a3, unsigned __int8 *a4, int a5, UErrorCode *a6)
{
  return 0LL;
}

uint64_t *sub_1808A3378@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x78, a2);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::StringEnumeration::StringEnumeration((uint64_t)result);
    *uint64_t result = (uint64_t)&off_18971F958;
    *((_DWORD *)result + 29) = 0;
    *((_DWORD *)result + 29) = *(_DWORD *)(a1 + 116);
  }

  return result;
}

uint64_t sub_1808A33BC()
{
  return dword_18C5352A0;
}

uint64_t sub_1808A33C8(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 116);
  if (v3 >= dword_18C5352A0)
  {
    uint64_t v6 = 0LL;
    if (a2)
    {
      int v7 = 0;
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v4 = qword_18C535298;
    *(_DWORD *)(a1 + 116) = v3 + 1;
    uint64_t v5 = v4 + 224LL * v3;
    uint64_t v6 = *(void *)(v5 + 40);
    if (a2)
    {
      int v7 = strlen(*(const char **)(v5 + 40));
LABEL_6:
      *a2 = v7;
    }
  }

  return v6;
}

char *sub_1808A3438(icu::StringEnumeration *a1, UErrorCode *a2)
{
  int v6 = 0;
  uint64_t v4 = (const char *)(*(uint64_t (**)(icu::StringEnumeration *, int *, UErrorCode *))(*(void *)a1 + 40LL))( a1,  &v6,  a2);
  return icu::StringEnumeration::setChars(a1, v4, v6, a2);
}

uint64_t sub_1808A348C(uint64_t result)
{
  *(_DWORD *)(result + 116) = 0;
  return result;
}

uint64_t sub_1808A3494(_BYTE *a1)
{
  uint64_t v2 = 0LL;
  while (uprv_stricmp(a1, (unsigned __int8 *)off_18971FAE8[v2]))
  {
    if (++v2 == 5) {
      return 0xFFFFFFFFLL;
    }
  }

  return (v2 + 4096);
}

uint64_t sub_1808A34EC()
{
  if (qword_18C535298)
  {
    unsigned int v0 = (void *)(qword_18C535298 - 16);
    uint64_t v1 = *(void *)(qword_18C535298 - 8);
    if (v1)
    {
      uint64_t v2 = 224 * v1;
      uint64_t v3 = qword_18C535298 - 224;
      do
      {
        icu::Locale::~Locale((icu::Locale *)(v3 + v2));
        v2 -= 224LL;
      }

      while (v2);
    }

    icu::UMemory::operator delete[](v0);
    qword_18C535298 = 0LL;
  }

  dword_18C5352A0 = 0;
  atomic_store(0, &dword_18C5352A8);
  return 1LL;
}

uint64_t icu::Collation::incTwoBytePrimaryByOffset(icu::Collation *this, int a2, int a3)
{
  int v3 = BYTE2(this) + a3;
  int v4 = (v3 - 2) / 254;
  int v5 = (v3 - 2) % 254;
  v3 -= 4;
  int v6 = v3 / 251;
  int v7 = v3 % 251;
  if (a2)
  {
    int v8 = 0x40000;
  }

  else
  {
    int v7 = v5;
    int v8 = 0x20000;
  }

  if (a2) {
    int v4 = v6;
  }
  return ((this & 0xFF000000) + (v4 << 24)) | (v8 + (v7 << 16));
}

uint64_t icu::Collation::incThreeBytePrimaryByOffset(icu::Collation *this, int a2, int a3)
{
  int v3 = a3 + BYTE1(this) - 2;
  int v4 = BYTE2(this) + v3 / 254;
  int v5 = (v4 - 2) / 254;
  int v6 = (v4 - 2) % 254;
  v4 -= 4;
  int v7 = v4 / 251;
  int v8 = v4 % 251;
  if (a2)
  {
    int v9 = 0x40000;
  }

  else
  {
    int v8 = v6;
    int v9 = 0x20000;
  }

  if (a2) {
    int v5 = v7;
  }
  return (v9 + (v8 << 16)) | (((v3 % 254) << 8) + 512) | ((this & 0xFF000000) + (v5 << 24));
}

uint64_t icu::Collation::decTwoBytePrimaryByOneStep(icu::Collation *this, int a2, int a3)
{
  int v3 = BYTE2(this) - a3;
  int v4 = v3 + 254;
  int v5 = (_DWORD)this - 0x1000000;
  if (v3 <= 1) {
    int v6 = (_DWORD)this - 0x1000000;
  }
  else {
    int v6 = (int)this;
  }
  if (v3 > 1) {
    int v4 = BYTE2(this) - a3;
  }
  if (v3 <= 3) {
    v3 += 251;
  }
  else {
    int v5 = (int)this;
  }
  if (!a2)
  {
    int v5 = v6;
    int v3 = v4;
  }

  return v5 & 0xFF000000 | (v3 << 16);
}

uint64_t icu::Collation::decThreeBytePrimaryByOneStep(icu::Collation *this, int a2, int a3)
{
  int v3 = BYTE1(this) - a3;
  int v4 = BYTE2(this) - 1;
  if (BYTE2(this) >= 3u) {
    int v5 = (int)this;
  }
  else {
    int v5 = (_DWORD)this - 0x1000000;
  }
  if (BYTE2(this) >= 3u) {
    int v6 = BYTE2(this) - 1;
  }
  else {
    int v6 = 255;
  }
  if (BYTE2(this) >= 5u) {
    int v7 = (int)this;
  }
  else {
    int v7 = (_DWORD)this - 0x1000000;
  }
  if (BYTE2(this) < 5u) {
    int v4 = 254;
  }
  if (!a2)
  {
    int v7 = v5;
    int v4 = v6;
  }

  unsigned int v8 = v7 & 0xFF000000 | ((v3 << 8) + 65024) | (v4 << 16);
  if (v3 >= 2) {
    return this & 0xFFFF0000 | (v3 << 8);
  }
  else {
    return v8;
  }
}

uint64_t icu::Collation::getThreeBytePrimaryForOffsetData(icu::Collation *this, unint64_t a2)
{
  return icu::Collation::incThreeBytePrimaryByOffset( (icu::Collation *)HIDWORD(a2),  (a2 >> 7) & 1,  ((_DWORD)this - ((int)a2 >> 8)) * (a2 & 0x7F));
}

uint64_t icu::Collation::unassignedPrimaryFromCodePoint(icu::Collation *this)
{
  return (14 * (((int)this + 1) % 18) + 2) | (((((int)this + 1) / 18 % 254) << 8) + 512) | (((((int)this + 1) / 4572
                                                                                            % 251) << 16)
                                                                                          + 0x40000) | 0xFE000000;
}

icu::RuleBasedCollator *icu::RuleBasedCollator::RuleBasedCollator(icu::RuleBasedCollator *this)
{
  uint64_t v2 = icu::Collator::Collator(this);
  *uint64_t v2 = off_18972A990;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  icu::Locale::Locale((icu::Locale *)(v2 + 5), "", 0LL, 0LL, 0LL);
  *((_DWORD *)this + 66) = 0;
  *((_BYTE *)this + 268) = 0;
  return this;
}

icu::RuleBasedCollator *icu::RuleBasedCollator::RuleBasedCollator( icu::RuleBasedCollator *this, UErrorCode *a2, UErrorCode *a3)
{
  int v6 = icu::Collator::Collator(this);
  *int v6 = off_18972A990;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  icu::Locale::Locale((icu::Locale *)(v6 + 5), "", 0LL, 0LL, 0LL);
  *((_DWORD *)this + 66) = 0;
  *((_BYTE *)this + 268) = 0;
  icu::RuleBasedCollator::internalBuildTailoring(this, a2, 0xFFFFFFFF, 0xFFFFFFFF, 0LL, 0LL, (icu::CollationRoot *)a3);
  return this;
}

void icu::RuleBasedCollator::internalBuildTailoring( icu::RuleBasedCollator *a1, UErrorCode *a2, unsigned int a3, unsigned int a4, UParseError *a5, icu::UnicodeString *a6, icu::CollationRoot *this)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t Root = icu::CollationRoot::getRoot(this, a2);
  if (*(int *)this <= 0)
  {
    int v15 = (UErrorCode *)Root;
    if (a6)
    {
      if ((*((_WORD *)a6 + 4) & 1) != 0) {
        __int16 v16 = 2;
      }
      else {
        __int16 v16 = *((_WORD *)a6 + 4) & 0x1F;
      }
      *((_WORD *)a6 + 4) = v16;
    }

    bzero(v22, 0x268uLL);
    icu::CollationBuilder::CollationBuilder((icu::CollationBuilder *)v22, v15, 0, (UErrorCode *)this);
    *(_DWORD *)int v21 = 0;
    int v20 = &off_18971FBD0;
    uint64_t v17 = icu::CollationBuilder::parseAndBuild( (icu::CollationBuilder *)v22,  (const icu::UnicodeString *)a2,  v21,  (icu::CollationRuleParser::Importer *)&v20,  a5,  (UErrorCode *)this);
    uint64_t v18 = (icu::CollationTailoring *)v17;
    if (*(int *)this < 1)
    {
      icu::Locale::setToBogus((icu::Locale *)(v17 + 13));
      icu::RuleBasedCollator::adoptTailoring(a1, v18, (UErrorCode *)this);
      if (a3 != -1) {
        icu::RuleBasedCollator::setAttribute((uint64_t)a1, 5, a3, (int *)this);
      }
      if (a4 != -1) {
        icu::RuleBasedCollator::setAttribute((uint64_t)a1, 4, a4, (int *)this);
      }
    }

    else
    {
      if (a6 && v23)
      {
        icu::UnicodeString::UnicodeString(v24, v23, 0xFFFFFFFFLL, 0LL);
        icu::UnicodeString::operator=(a6, (icu::UnicodeString *)v24);
        icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v24);
      }

      if (v18) {
        (*(void (**)(icu::CollationTailoring *))(*(void *)v18 + 8LL))(v18);
      }
    }

    icu::CollationRuleParser::Importer::~Importer((icu::CollationRuleParser::Importer *)&v20);
    icu::CollationBuilder::~CollationBuilder((icu::CollationBuilder *)v22);
  }

uint64_t icu::RuleBasedCollator::RuleBasedCollator( uint64_t a1, UErrorCode *a2, unsigned int a3, icu::CollationRoot *a4)
{
  unsigned int v8 = icu::Collator::Collator((void *)a1);
  void *v8 = off_18972A990;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  icu::Locale::Locale((icu::Locale *)(v8 + 5), "", 0LL, 0LL, 0LL);
  *(_DWORD *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 268) = 0;
  icu::RuleBasedCollator::internalBuildTailoring((icu::RuleBasedCollator *)a1, a2, a3, 0xFFFFFFFF, 0LL, 0LL, a4);
  return a1;
}

{
  void *v8;
  unsigned int v8 = icu::Collator::Collator((void *)a1);
  void *v8 = off_18972A990;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  icu::Locale::Locale((icu::Locale *)(v8 + 5), "", 0LL, 0LL, 0LL);
  *(_DWORD *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 268) = 0;
  icu::RuleBasedCollator::internalBuildTailoring((icu::RuleBasedCollator *)a1, a2, 0xFFFFFFFF, a3, 0LL, 0LL, a4);
  return a1;
}

uint64_t icu::RuleBasedCollator::RuleBasedCollator( uint64_t a1, UErrorCode *a2, unsigned int a3, unsigned int a4, icu::CollationRoot *a5)
{
  uint64_t v10 = icu::Collator::Collator((void *)a1);
  *uint64_t v10 = off_18972A990;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  icu::Locale::Locale((icu::Locale *)(v10 + 5), "", 0LL, 0LL, 0LL);
  *(_DWORD *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 268) = 0;
  icu::RuleBasedCollator::internalBuildTailoring((icu::RuleBasedCollator *)a1, a2, a3, a4, 0LL, 0LL, a5);
  return a1;
}

icu::RuleBasedCollator *icu::RuleBasedCollator::RuleBasedCollator( icu::RuleBasedCollator *this, UErrorCode *a2, UParseError *a3, icu::UnicodeString *a4, UErrorCode *a5)
{
  uint64_t v10 = icu::Collator::Collator(this);
  *uint64_t v10 = off_18972A990;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  icu::Locale::Locale((icu::Locale *)(v10 + 5), "", 0LL, 0LL, 0LL);
  *((_DWORD *)this + 66) = 0;
  *((_BYTE *)this + 268) = 0;
  icu::RuleBasedCollator::internalBuildTailoring(this, a2, 0xFFFFFFFF, 0xFFFFFFFF, a3, a4, (icu::CollationRoot *)a5);
  return this;
}

icu::CollationBuilder *icu::CollationBuilder::CollationBuilder( icu::CollationBuilder *this, UErrorCode *a2, UErrorCode *a3)
{
  return icu::CollationBuilder::CollationBuilder(this, a2, 0, a3);
}

{
  return icu::CollationBuilder::CollationBuilder(this, a2, 0, a3);
}

icu::SharedObject **icu::CollationBuilder::parseAndBuild( icu::CollationBuilder *this, const icu::UnicodeString *a2, const unsigned __int8 *a3, icu::CollationRuleParser::Importer *a4, UParseError *a5, UErrorCode *a6)
{
  if (*(int *)a6 <= 0)
  {
    uint64_t v10 = *(uint64_t **)(*((void *)this + 5) + 128LL);
    if (!v10)
    {
      int v6 = 0LL;
      *a6 = U_MISSING_RESOURCE_ERROR;
      *((void *)this + 36) = "missing root elements data, tailoring not supported";
      return v6;
    }

    int v15 = (icu::CollationTailoring *)icu::UMemory::operator new(v10, (icu::UMemory *)0x190, (unint64_t)a2);
    __int16 v16 = (icu::SharedObject **)v15;
    if (!v15
      || (icu::CollationTailoring::CollationTailoring( v15,  *(const icu::CollationSettings **)(*((void *)this + 4) + 32LL)),  !v16[4]))
    {
      int v6 = 0LL;
      *a6 = U_MEMORY_ALLOCATION_ERROR;
      if (!v16) {
        return v6;
      }
LABEL_13:
      (*((void (**)(icu::SharedObject **))*v16 + 1))(v16);
      return v6;
    }

    __int128 v21 = 0u;
    __int128 v22 = 0u;
    memset(v20, 0, sizeof(v20));
    icu::CollationRuleParser::CollationRuleParser((icu::CollationRuleParser *)v20, *((UErrorCode **)this + 5), a6);
    *((_DWORD *)this + 16) = *(_DWORD *)(*(void *)(*((void *)this + 4) + 32LL) + 28LL);
    *((void *)&v21 + sub_18086E18C((uint64_t)this, 1) = this;
    *(void *)&__int128 v22 = a4;
    uint64_t v17 = sub_1808A41AC(v16 + 4);
    icu::CollationRuleParser::parse(v20, a2, v17, a5, a6);
    *((void *)this + 36) = v21;
    if (*(_BYTE *)(*((void *)this + 9) + 616LL))
    {
      icu::CollationBuilder::makeTailoredCEs(this, a6);
      if (!*((_BYTE *)this + 81)) {
        icu::CollationBuilder::closeOverComposites(this, a6);
      }
      icu::CollationBuilder::finalizeCEs(this, a6);
      if (!*((_BYTE *)this + 81))
      {
        icu::UnicodeSet::add((icu::CollationBuilder *)((char *)this + 88), 0, 0x7Fu);
        icu::UnicodeSet::add((icu::CollationBuilder *)((char *)this + 88), 0xC0u, 0xFFu);
        icu::UnicodeSet::remove((icu::CollationBuilder *)((char *)this + 88), 0xAC00u, 0xD7A3u);
        icu::CollationDataBuilder::optimize( *((icu::CollationDataBuilder **)this + 9),  (icu::CollationBuilder *)((char *)this + 88),  a6);
      }

      icu::CollationTailoring::ensureOwnedData((icu::CollationTailoring *)v16, a6);
      uint64_t v19 = (_BYTE *)*((void *)this + 9);
      if (*((_BYTE *)this + 80)) {
        v19[618] = 1;
      }
      (*(void (**)(_BYTE *, icu::SharedObject *, UErrorCode *))(*(void *)v19 + 40LL))(v19, v16[42], a6);
      v16[43] = (icu::SharedObject *)*((void *)this + 9);
      *((void *)this + 9) = 0LL;
      if (*(int *)a6 > 0)
      {
LABEL_9:
        uint64_t v18 = v16;
        __int16 v16 = 0LL;
        goto LABEL_10;
      }
    }

    else
    {
      void v16[3] = (icu::SharedObject *)*((void *)this + 5);
    }

    *((_DWORD *)v17 + 20) = icu::CollationFastLatin::getOptions( v16[3],  v17,  (const icu::CollationSettings *)((char *)v17 + 84),  (unsigned __int16 *)0x180);
    icu::UnicodeString::operator=((UChar **)v16 + 5, (UChar **)a2);
    icu::UnicodeString::getTerminatedBuffer((icu::UnicodeString *)(v16 + 5));
    icu::CollationTailoring::setVersion(v16, (const unsigned __int8 *)(*((void *)this + 4) + 328LL), a3);
    uint64_t v18 = 0LL;
LABEL_10:
    int v6 = v16;
    icu::CollationRuleParser::~CollationRuleParser((icu::CollationRuleParser *)v20);
    __int16 v16 = v18;
    if (!v18) {
      return v6;
    }
    goto LABEL_13;
  }

  return 0LL;
}

icu::CollationBuilder *icu::CollationBuilder::CollationBuilder( icu::CollationBuilder *this, UErrorCode *a2, signed __int8 a3, UErrorCode *a4)
{
  *(void *)this = off_18971FB20;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = icu::Normalizer2::getNFDInstance((icu::Normalizer2 *)a4, a2);
  *((void *)this + 2) = icu::Normalizer2Factory::getFCDInstance((icu::Normalizer2Factory *)a4, v8);
  *((void *)this + 3) = icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)a4, v9);
  *((void *)this + 4) = a2;
  uint64_t v10 = *((void *)a2 + 3);
  uint64_t v11 = *(void *)(v10 + 128);
  int v12 = *(_DWORD *)(v10 + 136);
  *((void *)this + 5) = v10;
  *((void *)this + 6) = v11;
  *((_DWORD *)this + 14) = v12;
  *((_DWORD *)this + 16) = 0;
  int v14 = (icu::CollationDataBuilder *)icu::UMemory::operator new((uint64_t *)v10, (icu::UMemory *)0x280, v13);
  if (v14) {
    int v14 = (icu::CollationDataBuilder *)icu::CollationDataBuilder::CollationDataBuilder(v14, a3, a4);
  }
  *((void *)this + 9) = v14;
  *((_BYTE *)this + 80) = 1;
  *((_BYTE *)this + 8sub_18086E18C((uint64_t)this, 1) = a3;
  icu::UnicodeSet::UnicodeSet((icu::CollationBuilder *)((char *)this + 88));
  *((void *)this + 36) = 0LL;
  *((_DWORD *)this + 136) = 0;
  icu::UVector32::UVector32((icu::CollationBuilder *)((char *)this + 552), a4);
  icu::UVector64::UVector64((icu::CollationBuilder *)((char *)this + 584), a4);
  icu::Normalizer2Impl::ensureCanonIterData(*((icu::Normalizer2Impl **)this + 3), a4);
  if (*(int *)a4 >= 1)
  {
    int v15 = "CollationBuilder fields initialization failed";
LABEL_5:
    *((void *)this + 36) = v15;
    return this;
  }

  uint64_t v17 = (icu::UnicodeSet *)*((void *)this + 9);
  if (!v17)
  {
    *a4 = U_MEMORY_ALLOCATION_ERROR;
    return this;
  }

  icu::CollationDataBuilder::initForTailoring(v17, *((const icu::UnicodeSet ***)this + 5), a4);
  if (*(int *)a4 >= 1)
  {
    int v15 = "CollationBuilder initialization failed";
    goto LABEL_5;
  }

  return this;
}

void icu::CollationBuilder::~CollationBuilder(icu::CollationBuilder *this)
{
  *(void *)this = off_18971FB20;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  icu::UVector64::~UVector64((void **)this + 73);
  icu::UVector32::~UVector32((void **)this + 69);
  icu::UnicodeSet::~UnicodeSet(v3, (icu::CollationBuilder *)((char *)this + 88));
  icu::CollationRuleParser::Sink::~Sink(this);
}

{
  void *v1;
  icu::CollationBuilder::~CollationBuilder(this);
  icu::UMemory::operator delete(v1);
}

const icu::CollationSettings *sub_1808A41AC(icu::SharedObject **a1)
{
  uint64_t v2 = *a1;
  if ((int)icu::SharedObject::getRefCount(*a1) >= 2)
  {
    int v5 = (icu::CollationSettings *)icu::UMemory::operator new(v4, (icu::UMemory *)0x358, v3);
    if (v5)
    {
      uint64_t v6 = (uint64_t)v5;
      icu::CollationSettings::CollationSettings(v5, v2);
      icu::SharedObject::removeRef(v2);
      *a1 = (icu::SharedObject *)v6;
      icu::SharedObject::addRef(v6);
      return (const icu::CollationSettings *)v6;
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

void icu::CollationBuilder::makeTailoredCEs(icu::CollationBuilder *this, UErrorCode *a2)
{
  int v47 = 0;
  memset(v46, 0, sizeof(v46));
  icu::CollationWeights::CollationWeights((icu::CollationWeights *)v46);
  int v45 = 0;
  memset(v44, 0, sizeof(v44));
  icu::CollationWeights::CollationWeights((icu::CollationWeights *)v44);
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  icu::CollationWeights::CollationWeights((icu::CollationWeights *)v42);
  uint64_t v3 = 0LL;
  __int16 v41 = (icu::CollationBuilder *)((char *)this + 48);
  uint64_t v4 = *((void *)this + 76);
  uint64_t v37 = this;
  while (1)
  {
    unint64_t v5 = *(void *)(v4 + 8LL * *(int *)(*((void *)this + 72) + 4 * v3));
    unint64_t Weight = HIDWORD(v5);
    LODWORD(v7) = HIDWORD(v5) ? 1280 : 0;
    uint64_t v39 = v3;
    unsigned int v40 = HIDWORD(v5) ? icu::CollationRootElements::findPrimary(v41, HIDWORD(v5)) : 0;
    uint64_t v8 = (v5 >> 8) & 0xFFFFF;
    if (v8) {
      break;
    }
LABEL_77:
    uint64_t v3 = v39 + 1;
  }

  int v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0LL;
  int v12 = 0;
  LODWORD(v13) = v7;
  while (1)
  {
    unint64_t v14 = *(void *)(v4 + 8 * v8);
    uint64_t v15 = (v14 >> 8) & 0xFFFFF;
    uint64_t v16 = v14 & 3;
    if (v16 == 1)
    {
      if ((v14 & 8) == 0)
      {
        int v10 = 0;
        unint64_t v13 = HIWORD(v14);
        goto LABEL_66;
      }

      if (v10)
      {
LABEL_65:
        LODWORD(v13) = icu::CollationWeights::nextWeight((icu::CollationWeights *)v44);
        int v10 = 1;
LABEL_66:
        int v12 = 0;
        int v9 = 0;
        if ((_DWORD)v13) {
          LODWORD(v7) = 1280;
        }
        else {
          LODWORD(v7) = 0;
        }
        if ((v14 & 8) == 0) {
          goto LABEL_71;
        }
LABEL_70:
        *(void *)(v4 + 8 * v8) = ((_DWORD)v13 << 16) | (Weight << 32) | v7 | (unint64_t)(v12 << 6);
        goto LABEL_71;
      }

      uint64_t v23 = v11;
      int v24 = 0;
      if (v15)
      {
        unint64_t v25 = (v14 >> 8) & 0xFFFFF;
        do
        {
          uint64_t v26 = *(void *)(v4 + 8 * v25);
          if ((v26 & 3) == 1)
          {
            if ((v26 & 8) == 0) {
              break;
            }
            ++v24;
          }

          else if ((v26 & 3) == 0)
          {
            break;
          }

          unint64_t v25 = ((unint64_t)v26 >> 8) & 0xFFFFF;
        }

        while (v25);
      }

      if ((_DWORD)v13)
      {
        if ((_DWORD)v23)
        {
          if ((_DWORD)v13 == 256)
          {
            LODWORD(v13) = 256;
            SecondaryAfteunint64_t r = 1280;
            goto LABEL_64;
          }

          SecondaryAfteunint64_t r = (*(_DWORD *)(*(void *)v41 + 16LL) >> 8) & 0xFF00;
        }

        else
        {
          SecondaryAfteunint64_t r = icu::CollationRootElements::getSecondaryAfter(v41, v40, v13);
        }
      }

      else
      {
        LODWORD(v13) = ((*(_DWORD *)(*(void *)v41 + 16LL) >> 8) & 0xFF00) - 256;
        SecondaryAfteunint64_t r = *(unsigned __int16 *)(*(void *)v41 + 4LL * *(unsigned int *)(*(void *)v41 + 4LL) + 2);
      }

      if ((_DWORD)v13 == 1280) {
        LODWORD(v13) = *(unsigned __int8 *)(*(void *)v41 + 19LL) << 8;
      }
LABEL_64:
      icu::CollationWeights::initForSecondary((icu::CollationWeights *)v44);
      BOOL v32 = icu::CollationWeights::allocWeights((icu::CollationWeights *)v44, v13, SecondaryAfter, v24 + 1);
      uint64_t v11 = v23;
      if (!v32)
      {
        int v35 = "secondary tailoring gap too small";
        goto LABEL_83;
      }

      goto LABEL_65;
    }

    if (v16 == 2) {
      break;
    }
    if (v16 == 3)
    {
      if (v12 == 3)
      {
        BOOL v34 = a2;
        int v35 = "quaternary tailoring gap too small";
        goto LABEL_84;
      }

      ++v12;
      if ((v14 & 8) != 0) {
        goto LABEL_70;
      }
    }

    else
    {
      if (!(_DWORD)v11)
      {
        int v17 = 0;
        if (v15)
        {
          unint64_t v18 = (v14 >> 8) & 0xFFFFF;
          do
          {
            uint64_t v19 = *(void *)(v4 + 8 * v18);
            if ((v19 & 3) == 0)
            {
              if ((v19 & 8) == 0) {
                break;
              }
              ++v17;
            }

            unint64_t v18 = ((unint64_t)v19 >> 8) & 0xFFFFF;
          }

          while (v18);
        }

        int v20 = v17 + 1;
        int v21 = *(char *)(*(void *)(*((void *)this + 5) + 72LL) + ((unint64_t)Weight >> 24));
        PrimaryAfteunint64_t r = icu::CollationRootElements::getPrimaryAfter(v41, (icu::Collation *)Weight, v40, v21);
        icu::CollationWeights::initForPrimary((icu::CollationWeights *)v46, v21);
        if (!icu::CollationWeights::allocWeights((icu::CollationWeights *)v46, Weight, PrimaryAfter, v20))
        {
          int v35 = "primary tailoring gap too small";
          goto LABEL_83;
        }
      }

      unint64_t Weight = icu::CollationWeights::nextWeight((icu::CollationWeights *)v46);
      int v12 = 0;
      int v10 = 0;
      int v9 = 0;
      uint64_t v11 = 1LL;
      LODWORD(v13) = 1280;
      LODWORD(v7) = 1280;
      if ((v14 & 8) != 0) {
        goto LABEL_70;
      }
    }

void icu::CollationBuilder::closeOverComposites(icu::CollationBuilder *this, UErrorCode *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v15 = 0LL;
  memset(v14, 0, sizeof(v14));
  unint64_t v13 = "[";
  icu::UnicodeString::UnicodeString(&v21, 1LL, &v13);
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v14, (const icu::UnicodeString *)&v21, a2);
  icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)&v21);
  if (*(int *)a2 <= 0)
  {
    icu::UnicodeSet::remove((icu::UnicodeSet *)v14, 0xAC00u, 0xD7A3u);
    __int128 v22 = 0u;
    uint64_t v25 = 0LL;
    __int128 v24 = 0u;
    __int128 v23 = 0u;
    uint64_t v20 = 0LL;
    int v21 = off_18971B688;
    LOWORD(v22) = 2;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v17 = 0u;
    uint64_t v16 = off_18971B688;
    LOWORD(v17) = 2;
    memset(v12, 0, sizeof(v12));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v12, (const icu::UnicodeSet *)v14);
    while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v12))
    {
      (*(void (**)(void, void, void (***)(icu::UnicodeString *__hidden)))(**((void **)this + 1)
                                                                                                  + 56LL))( *((void *)this + 1),  DWORD2(v12[0]),  &v16);
      int CEs = icu::CollationDataBuilder::getCEs( *((icu::CollationDataBuilder **)this + 9),  (const icu::UnicodeString *)&v16,  (uint64_t *)this + 37,  0LL,  v5);
      *((_DWORD *)this + 136) = CEs;
      if (CEs <= 31)
      {
        uint64_t String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)v12, v7, v8);
        icu::CollationBuilder::addIfDifferent( (icu::CollationDataBuilder **)this,  (const icu::UnicodeString *)&v21,  (const icu::UnicodeString *)String,  (const uint64_t *)this + 37,  *((unsigned int *)this + 136),  0xFFFFFFFFLL,  a2);
      }
    }

    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v12);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)&v16);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)&v21);
  }

  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v14);
}

void icu::CollationBuilder::finalizeCEs(icu::CollationBuilder *this, UErrorCode *a2)
{
  uint64_t v2 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v2 <= 0)
  {
    unint64_t v5 = (icu::CollationDataBuilder *)icu::UMemory::operator new(v2, (icu::UMemory *)0x280, (unint64_t)a2);
    if (v5)
    {
      uint64_t v6 = v5;
      icu::CollationDataBuilder::CollationDataBuilder(v5, *((_BYTE *)this + 81), a2);
      if (*(int *)a2 > 0)
      {
LABEL_6:
        (*(void (**)(icu::UnicodeSet *))(*(void *)v6 + 8LL))(v6);
        return;
      }

      icu::CollationDataBuilder::initForTailoring(v6, *((const icu::UnicodeSet ***)this + 5), a2);
      uint64_t v7 = *((void *)this + 76);
      v9[0] = &off_18971FB80;
      v9[1] = v7;
      icu::CollationDataBuilder::copyFrom( (uint64_t)v6,  *((const icu::CollationDataBuilder **)this + 9),  (const icu::CollationDataBuilder::CEModifier *)v9,  a2);
      if (*(int *)a2 > 0)
      {
        icu::CollationDataBuilder::CEModifier::~CEModifier((icu::CollationDataBuilder::CEModifier *)v9);
        goto LABEL_6;
      }

      uint64_t v8 = *((void *)this + 9);
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
      }
      *((void *)this + 9) = v6;
      icu::CollationDataBuilder::CEModifier::~CEModifier((icu::CollationDataBuilder::CEModifier *)v9);
    }

    else if (*(int *)a2 <= 0)
    {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }

uint64_t icu::CollationBuilder::addReset( uint64_t this, signed int a2, const icu::UnicodeString *a3, const char **a4, UErrorCode *a5)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = this;
    unsigned int v9 = *((unsigned __int16 *)a3 + 4);
    if ((v9 & 0x8000u) == 0) {
      unsigned int v10 = v9 >> 5;
    }
    else {
      unsigned int v10 = *((_DWORD *)a3 + 3);
    }
    if (v10)
    {
      uint64_t v11 = (v9 & 2) != 0
      if (*(__int16 *)v11 == -2)
      {
        this = icu::CollationBuilder::getSpecialResetPosition((icu::CollationData **)this, a3, a4, a5);
        *(void *)(v8 + 296) = this;
        *(_DWORD *)(v8 + 544) = 1;
LABEL_20:
        this = icu::CollationBuilder::findOrInsertNodeForCEs((icu::CollationBuilder *)v8, a2, a4, a5);
        uint64_t v17 = this;
        else {
          unint64_t v18 = *(void *)(*(void *)(v8 + 608) + 8LL * this);
        }
        for (signed int i = v18 & 3; i > a2; signed int i = v18 & 3)
        {
          uint64_t v17 = (v18 >> 28) & 0xFFFFF;
          else {
            unint64_t v18 = *(void *)(*(void *)(v8 + 608) + 8 * v17);
          }
        }

        if ((v18 & 8) != 0 && i == a2)
        {
          uint64_t v20 = (v18 >> 28) & 0xFFFFF;
LABEL_33:
          if (*(int *)a5 < 1)
          {
            *(void *)(v8 + 8LL * *(int *)(v8 + 544) + 288) = (((unint64_t)(v20 & 0x1FC0) << 42) & 0x80FFFFFFFFFFFFFFLL | ((((unint64_t)(v20 & 0xFE000) >> 13) & 0x7F) << 56) | ((v20 & 0x3F) << 24))
                                                             + (a2 << 8)
                                                             + 0x4040000006002000LL;
            return this;
          }

          int v21 = "inserting reset position for &[before n]";
LABEL_35:
          *a4 = v21;
          return this;
        }

        if (!a2)
        {
          if (!HIDWORD(v18))
          {
            *a5 = U_UNSUPPORTED_ERROR;
            int v21 = "reset primary-before ignorable not possible";
            goto LABEL_35;
          }

          this = v8 + 48;
          if (*(_DWORD *)(*(void *)(v8 + 48) + 4LL * *(unsigned int *)(*(void *)(v8 + 48) + 8LL)) >= HIDWORD(v18))
          {
            *a5 = U_UNSUPPORTED_ERROR;
            int v21 = "reset primary-before first non-ignorable not supported";
            goto LABEL_35;
          }

          if (HIDWORD(v18) == -16645632)
          {
            *a5 = U_UNSUPPORTED_ERROR;
            int v21 = "reset primary-before [first trailing] not supported";
            goto LABEL_35;
          }

          uint64_t PrimaryBefore = icu::CollationRootElements::getPrimaryBefore( (icu::CollationRootElements *)this,  (icu::Collation *)HIDWORD(v18),  *(char *)(*(void *)(*(void *)(v8 + 40) + 72LL) + HIBYTE(v18)));
          this = icu::CollationBuilder::findOrInsertNodeForPrimary((icu::CollationBuilder *)v8, PrimaryBefore, a5);
          while (1)
          {
            LODWORD(v20) = this;
            a2 = 0;
            this = (*(void *)(*(void *)(v8 + 608) + 8LL * this) >> 8) & 0xFFFFF;
            if (!(_DWORD)this) {
              goto LABEL_33;
            }
          }
        }

        this = icu::CollationBuilder::findCommonNode((icu::CollationBuilder *)v8, v17, 1);
        uint64_t v23 = this;
        if (a2 >= 2)
        {
          this = icu::CollationBuilder::findCommonNode((icu::CollationBuilder *)v8, this, 2);
          uint64_t v23 = this;
        }

        else {
          unint64_t v24 = *(void *)(*(void *)(v8 + 608) + 8LL * v23);
        }
        if ((v24 & 3) == a2)
        {
          if (!HIWORD(v24))
          {
            *a5 = U_UNSUPPORTED_ERROR;
            int v21 = "reset secondary-before secondary ignorable not possible";
            if (a2 != 1) {
              int v21 = "reset tertiary-before completely ignorable not possible";
            }
            goto LABEL_35;
          }

          this = icu::CollationBuilder::getWeight16Before((icu::CollationBuilder *)v8, v22, v24, a2);
          uint64_t v20 = (v24 >> 28) & 0xFFFFF;
          LODWORD(v28) = v20;
          while (1)
          {
            else {
              unint64_t v29 = *(void *)(*(void *)(v8 + 608) + 8LL * v28);
            }
            if ((v29 & 3) < a2)
            {
              LODWORD(v30) = 1280;
              goto LABEL_76;
            }

            if ((v29 & 8) == 0 && (v29 & 3) == a2) {
              break;
            }
            uint64_t v28 = (v29 >> 28) & 0xFFFFF;
          }

          unint64_t v30 = HIWORD(v29);
LABEL_76:
          if ((_DWORD)v30 == (_DWORD)this) {
            goto LABEL_55;
          }
          this = icu::CollationBuilder::insertNodeBetween( (icu::CollationBuilder *)v8,  v20,  v23,  a2 | (unint64_t)(this << 48),  a5);
        }

        else
        {
          uint64_t Weight16Before = icu::CollationBuilder::getWeight16Before((icu::CollationBuilder *)v8, v22, v24, a2);
          this = icu::CollationBuilder::findOrInsertWeakNode((icu::CollationBuilder *)v8, v23, Weight16Before, a2, a5);
        }

        LODWORD(v20) = this;
LABEL_55:
        unint64_t v26 = *(void *)(v8 + 8LL * *(int *)(v8 + 544) + 288);
        if ((v26 - 1174405120) >> 30 == 3)
        {
          a2 = (v26 >> 8) & 3;
          goto LABEL_33;
        }

        if (!HIBYTE(v26))
        {
          if (v26) {
            int v27 = 2;
          }
          else {
            int v27 = 15;
          }
          if ((v26 & 0xFF000000) != 0) {
            a2 = 1;
          }
          else {
            a2 = v27;
          }
          goto LABEL_33;
        }

unint64_t icu::CollationBuilder::getSpecialResetPosition( icu::CollationData **this, const icu::UnicodeString *a2, const char **a3, UErrorCode *a4)
{
  unsigned int v4 = *((unsigned __int16 *)a2 + 4);
  if ((v4 & 0x8000u) == 0) {
    unsigned int v5 = v4 >> 5;
  }
  else {
    unsigned int v5 = *((_DWORD *)a2 + 3);
  }
  if (v5 < 2) {
LABEL_87:
  }
    abort();
  if ((v4 & 2) != 0) {
    uint64_t v6 = (char *)a2 + 10;
  }
  else {
    uint64_t v6 = (char *)*((void *)a2 + 3);
  }
  int v7 = *((unsigned __int16 *)v6 + 1);
  unsigned int v10 = 0;
  unint64_t v11 = 0LL;
  unint64_t CEWithPrimaryAtLeast = 0xFF02020005000500LL;
  char v13 = 1;
  switch(v7)
  {
    case 10240:
    case 10241:
      return v11;
    case 10242:
      signed int inserted = icu::CollationBuilder::findOrInsertNodeForRootCE((icu::CollationBuilder *)this, 0LL, 2, a4);
      unint64_t v11 = 0LL;
      if (*(int *)a4 <= 0)
      {
        if ((inserted & 0x80000000) == 0
          && (signed int v15 = *((_DWORD *)this + 148), v15 > inserted)
          && (uint64_t v16 = this[76],
              uint64_t v17 = *((void *)v16 + inserted),
              (unsigned int v18 = (v17 >> 8) & 0xFFFFF) != 0)
          && v15 > (int)v18
          && (*((void *)v16 + v18) & 0xBLL) == 0xA)
        {
        }

        else
        {
          return *((_DWORD *)this[6] + *(unsigned int *)this[6]) & 0xFFFFFF7F;
        }
      }

      return v11;
    case 10243:
      char v13 = 0;
      unint64_t CEWithPrimaryAtLeast = *((_DWORD *)this[6] + (*((_DWORD *)this[6] + 1) - 1)) & 0xFFFFFF7F;
      unsigned int v10 = 2;
      goto LABEL_41;
    case 10244:
      unsigned int v19 = icu::CollationBuilder::findOrInsertNodeForRootCE((icu::CollationBuilder *)this, 0LL, 1, a4);
      unint64_t v11 = 0LL;
      else {
        uint64_t v20 = *((void *)this[76] + v19);
      }
      break;
    case 10245:
      char v13 = 0;
      uint64_t v21 = *((unsigned int *)this[6] + (*((_DWORD *)this[6] + 2) - 1));
      goto LABEL_40;
    case 10246:
      unsigned int v10 = 0;
      unint64_t CEWithPrimaryAtLeast = ((unint64_t)*((unsigned int *)this[6] + *((unsigned int *)this[6] + 2)) << 32) | 0x5000500;
      goto LABEL_41;
    case 10247:
      CEWithuint64_t PrimaryBefore = icu::CollationRootElements::lastCEWithPrimaryBefore( (icu::CollationRootElements *)(this + 6),  *((_DWORD *)this + 16) + 1);
      goto LABEL_27;
    case 10248:
      unint64_t CEWithPrimaryAtLeast = icu::CollationRootElements::firstCEWithPrimaryAtLeast( (icu::CollationRootElements *)(this + 6),  (*((_DWORD *)this + 16) + 1));
      goto LABEL_28;
    case 10249:
      FirstPrimaryForGrouunint64_t p = icu::CollationData::getFirstPrimaryForGroup(this[5], 0x11u);
      CEWithuint64_t PrimaryBefore = icu::CollationRootElements::firstCEWithPrimaryAtLeast( (icu::CollationRootElements *)(this + 6),  FirstPrimaryForGroup);
      goto LABEL_27;
    case 10250:
      CEWithuint64_t PrimaryBefore = icu::CollationData::getSingleCE(this[5], 0x4E00u, a4);
LABEL_27:
      unint64_t CEWithPrimaryAtLeast = CEWithPrimaryBefore;
      char v13 = 0;
LABEL_28:
      unsigned int v10 = 0;
      goto LABEL_41;
    case 10251:
      unint64_t v11 = 0LL;
      *a4 = U_UNSUPPORTED_ERROR;
      unint64_t v24 = "reset to [last implicit] not supported";
      goto LABEL_31;
    case 10252:
      goto LABEL_41;
    case 10253:
      unint64_t v11 = 0LL;
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
      unint64_t v24 = "LDML forbids tailoring to U+FFFF";
LABEL_31:
      *a3 = v24;
      return v11;
    default:
      goto LABEL_87;
  }

  do
  {
    unsigned int v25 = (v20 >> 8) & 0xFFFFF;
    if (v25)
    {
      signed int v26 = *((_DWORD *)this + 148);
      if (v26 > (int)v25)
      {
        int v27 = this[76];
        uint64_t v20 = *((void *)v27 + v25);
        if ((*((_DWORD *)v27 + 2 * v25) & 3) != 0) {
          continue;
        }
      }
    }

    goto LABEL_39;
  }

  while ((v20 & 3) != 1);
  if ((v20 & 8) != 0)
  {
    if ((v20 & 0x20) != 0)
    {
      unsigned int v42 = (v20 >> 8) & 0xFFFFF;
      else {
        unsigned int v25 = (*((void *)v27 + v42) >> 8) & 0xFFFFF;
      }
    }
  }

  else
  {
LABEL_39:
    char v13 = 0;
    uint64_t v21 = *((unsigned int *)this[6] + *((unsigned int *)this[6] + 1));
LABEL_40:
    unint64_t CEWithPrimaryAtLeast = v21 & 0xFFFFFFFFFFFFFF7FLL;
    unsigned int v10 = 1;
LABEL_41:
    signed int v28 = icu::CollationBuilder::findOrInsertNodeForRootCE((icu::CollationBuilder *)this, CEWithPrimaryAtLeast, v10, a4);
    if (v28 < 0 || *((_DWORD *)this + 148) <= v28)
    {
      LODWORD(v29) = 0;
      if ((v7 & 1) != 0)
      {
LABEL_46:
        for (i = (v29 >> 8) & 0xFFFFF; i; signed int v28 = v31)
        {
          unsigned int v31 = i;
          else {
            uint64_t v32 = *((void *)this[76] + i);
          }
          unsigned int i = (v32 >> 8) & 0xFFFFF;
          LOBYTE(v29) = v32;
        }

        unint64_t v11 = CEWithPrimaryAtLeast;
        if ((v29 & 8) == 0) {
          return v11;
        }
        return ((v10 << 8) | 0x4040000006002000LL)
             + ((unint64_t)(v28 & 0xFE000) << 43)
      }
    }

    else
    {
      uint64_t v29 = *((void *)this[76] + v28);
      if ((v7 & 1) != 0) {
        goto LABEL_46;
      }
    }

    char v33 = v13 ^ 1;
    if ((v29 & 0x60) != 0) {
      char v33 = 1;
    }
    if ((v33 & 1) == 0)
    {
      signed int v28 = (v29 >> 8) & 0xFFFFF;
      if (v28)
      {
        unsigned int v34 = v29 >> 8;
        if (*((_DWORD *)this + 148) <= v28) {
          LODWORD(v29) = 0;
        }
        else {
          uint64_t v29 = *((void *)this[76] + v28);
        }
        unint64_t CEWithPrimaryAtLeast = ((v10 << 8) | 0x4040000006002000LL)
                             + ((unint64_t)(v34 & 0xFE000) << 43)
      }

      else
      {
        int Primary = icu::CollationRootElements::findPrimary( (icu::CollationRootElements *)(this + 6),  HIDWORD(CEWithPrimaryAtLeast));
        PrimaryAfteunint64_t r = icu::CollationRootElements::getPrimaryAfter( (icu::CollationRootElements *)(this + 6),  (icu::Collation *)HIDWORD(CEWithPrimaryAtLeast),  Primary,  *(char *)(*((void *)this[5] + 9) + HIBYTE(CEWithPrimaryAtLeast)));
        uint64_t v37 = PrimaryAfter;
        signed int v28 = icu::CollationBuilder::findOrInsertNodeForPrimary((icu::CollationBuilder *)this, PrimaryAfter, a4);
        unint64_t CEWithPrimaryAtLeast = (v37 << 32) | 0x5000500;
        if (v28 < 0 || *((_DWORD *)this + 148) <= v28) {
          return CEWithPrimaryAtLeast;
        }
        uint64_t v29 = *((void *)this[76] + v28);
      }
    }

    unint64_t v11 = CEWithPrimaryAtLeast;
    if ((v29 & 0x60) != 0)
    {
      if ((v29 & 0x40) != 0)
      {
        unsigned int v38 = (v29 >> 8) & 0xFFFFF;
        signed int v39 = *((_DWORD *)this + 148);
        else {
          signed int v28 = (*((void *)this[76] + v38) >> 8) & 0xFFFFF;
        }
        if (v39 <= v28) {
          return ((v10 << 8) | 0x4040000006002000LL)
        }
               + ((unint64_t)(v28 & 0xFE000) << 43)
        uint64_t v29 = *((void *)this[76] + v28);
      }

      if ((v29 & 0x20) != 0)
      {
        unsigned int v40 = (v29 >> 8) & 0xFFFFF;
        else {
          signed int v28 = (*((void *)this[76] + v40) >> 8) & 0xFFFFF;
        }
      }

      return ((v10 << 8) | 0x4040000006002000LL)
           + ((unint64_t)(v28 & 0xFE000) << 43)
    }
  }

  return v11;
}

unint64_t icu::CollationBuilder::findOrInsertNodeForCEs( icu::CollationBuilder *this, int a2, const char **a3, UErrorCode *a4)
{
  uint64_t v6 = *((int *)this + 136);
  if (!(_DWORD)v6)
  {
LABEL_17:
    unint64_t v10 = 0LL;
    *((void *)this + 37) = 0LL;
    *((_DWORD *)this + 136) = 1;
    return icu::CollationBuilder::findOrInsertNodeForRootCE(this, v10, a2, a4);
  }

  int v7 = (char *)this + 8 * v6;
  int v8 = v6 - 1;
  unsigned int v9 = (unint64_t *)(v7 + 288);
  while (1)
  {
    unint64_t v11 = *v9--;
    unint64_t v10 = v11;
LABEL_16:
    *((_DWORD *)this + 136) = v8--;
    if (v8 == -1) {
      goto LABEL_17;
    }
  }

  unint64_t v12 = HIBYTE(v10);
  if (v10) {
    int v13 = 2;
  }
  else {
    int v13 = 15;
  }
  if ((v10 & 0xFF000000) != 0) {
    int v13 = 1;
  }
  if (v12) {
    int v13 = 0;
  }
  if (v13 > a2) {
    goto LABEL_16;
  }
  if (v12 != 254) {
    return icu::CollationBuilder::findOrInsertNodeForRootCE(this, v10, a2, a4);
  }
  unint64_t result = 0LL;
  *a4 = U_UNSUPPORTED_ERROR;
  *a3 = "tailoring relative to an unassigned code point not supported";
  return result;
}

uint64_t icu::CollationBuilder::findOrInsertNodeForPrimary( icu::CollationBuilder *this, uint64_t a2, UErrorCode *a3)
{
  int v7 = *((_DWORD *)this + 140);
  uint64_t v8 = *((void *)this + 76);
  if (!v7)
  {
    int v11 = -1;
    goto LABEL_25;
  }

  uint64_t v9 = *((void *)this + 72);
  if (v7 >= 0) {
    int v10 = *((_DWORD *)this + 140);
  }
  else {
    int v10 = v7 + 1;
  }
  int v11 = v10 >> 1;
  unsigned int v12 = *(_DWORD *)(v8 + 8LL * *(int *)(v9 + 4LL * (v10 >> 1)) + 4);
  if (v12 == (_DWORD)a2)
  {
LABEL_20:
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_25:
    uint64_t v3 = *((unsigned int *)this + 148);
    int v16 = v3 + 1;
    if ((int)v3 < -1 || *((_DWORD *)this + 149) <= (int)v3)
    {
      if (!icu::UVector64::expandCapacity((icu::CollationBuilder *)((char *)this + 584), v16, a3))
      {
LABEL_31:
        icu::UVector32::insertElementAt((_DWORD *)this + 138, v3, ~v11, a3);
        return v3;
      }

      int v17 = *((_DWORD *)this + 148);
      int v16 = v17 + 1;
      uint64_t v8 = *((void *)this + 76);
    }

    else
    {
      int v17 = *((_DWORD *)this + 148);
    }

    *(void *)(v8 + 8LL * v17) = a2 << 32;
    *((_DWORD *)this + 148) = v16;
    goto LABEL_31;
  }

  int v13 = 0;
  int v14 = *((_DWORD *)this + 140);
  while (v12 <= a2)
  {
    if (v11 == v13)
    {
      int v11 = -2 - v11;
      goto LABEL_20;
    }

    int v13 = v11;
LABEL_14:
    int v15 = v14 + v13;
    if (v14 + v13 < 0 != __OFADD__(v14, v13)) {
      ++v15;
    }
    int v11 = v15 >> 1;
    unsigned int v12 = *(_DWORD *)(v8 + 8LL * *(int *)(v9 + 4LL * (v15 >> 1)) + 4);
    if (v12 == (_DWORD)a2) {
      goto LABEL_20;
    }
  }

  if (v11 != v13)
  {
    int v14 = v11;
    goto LABEL_14;
  }

  int v11 = ~v11;
  if (v11 < 0) {
    goto LABEL_25;
  }
LABEL_21:
  uint64_t v3 = 0LL;
  if (v7 >= 1 && v7 > v11) {
    return *(unsigned int *)(v9 + 4LL * v11);
  }
  return v3;
}

uint64_t icu::CollationBuilder::findCommonNode(icu::CollationBuilder *this, uint64_t a2, int a3)
{
  else {
    uint64_t v3 = *(void *)(*((void *)this + 76) + 8LL * a2);
  }
  if ((v3 & 3) < a3)
  {
    if (a3 == 1)
    {
      if ((v3 & 0x40) == 0) {
        return a2;
      }
    }

    else if ((v3 & 0x20) == 0)
    {
      return a2;
    }

    unsigned int v4 = (v3 >> 8) & 0xFFFFF;
    int v5 = *((_DWORD *)this + 148);
    else {
      unint64_t v6 = *(void *)(*((void *)this + 76) + 8LL * v4);
    }
    do
    {
      do
      {
        a2 = (v6 >> 8) & 0xFFFFF;
        LODWORD(v6) = 0;
      }

      while (v5 <= (int)a2);
      unint64_t v6 = *(void *)(*((void *)this + 76) + 8LL * a2);
    }

    while ((v6 & 8) != 0 || (v6 & 3) > a3 || HIWORD(v6) < 0x500);
  }

  return a2;
}

uint64_t icu::CollationBuilder::getWeight16Before( icu::CollationBuilder *this, int a2, unint64_t a3, int a4)
{
  if ((a3 & 3) == 2) {
    int v4 = HIWORD(a3);
  }
  else {
    int v4 = 1280;
  }
  unsigned int v5 = a3 & 3;
  if (v5 >= 2)
  {
    while (1)
    {
      uint64_t v6 = (a3 >> 28) & 0xFFFFF;
      a3 = *(void *)(*((void *)this + 76) + 8 * v6);
      unsigned int v5 = a3 & 3;
      if (v5 <= 1) {
        goto LABEL_7;
      }
    }

    HIDWORD(a3) = 0;
    unsigned int v7 = 1280;
    goto LABEL_18;
  }

uint64_t icu::CollationBuilder::insertNodeBetween( icu::CollationBuilder *this, signed int a2, unsigned int a3, uint64_t a4, UErrorCode *a5)
{
  int v10 = (char *)this + 584;
  uint64_t v11 = *((unsigned int *)this + 148);
  int v12 = v11 + 1;
  if ((int)v11 < -1 || *((_DWORD *)this + 149) <= (int)v11)
  {
    int v13 = *((_DWORD *)this + 148);
    int v12 = v13 + 1;
  }

  else
  {
    int v13 = *((_DWORD *)this + 148);
  }

  *(void *)(*((void *)this + 76) + 8LL * v13) = a4 | ((uint64_t)a2 << 28) | (int)(a3 << 8);
  *((_DWORD *)this + 148) = v12;
LABEL_8:
  if (a2 < 0 || *((_DWORD *)this + 148) <= a2) {
    unint64_t v15 = 0LL;
  }
  else {
    unint64_t v15 = *(void *)(*((void *)this + 76) + 8LL * a2) & 0xFFFFFFFFF00000FFLL;
  }
  icu::UVector64::setElementAt((uint64_t)v10, v15 | (int)((_DWORD)v11 << 8), a2);
  if (a3)
  {
    else {
      unint64_t v16 = *(void *)(*((void *)this + 76) + 8LL * a3) & 0xFFFF00000FFFFFFFLL;
    }
    icu::UVector64::setElementAt((uint64_t)v10, v16 | ((uint64_t)(int)v11 << 28), a3);
  }

  return v11;
}

uint64_t icu::CollationBuilder::findOrInsertWeakNode( icu::CollationBuilder *this, uint64_t a2, uint64_t a3, int a4, UErrorCode *a5)
{
  signed int v8 = a2;
  if ((_DWORD)a3 == 1280) {
    return icu::CollationBuilder::findCommonNode(this, a2, a4);
  }
  else {
    unint64_t v11 = *(void *)(*((void *)this + 76) + 8LL * a2);
  }
  if ((a3 - 1) <= 0x4FE)
  {
    uint64_t v12 = 32LL;
    if (a4 == 1) {
      uint64_t v12 = 64LL;
    }
    if ((v11 & v12) == 0)
    {
      unint64_t v15 = (char *)this + 584;
      uint64_t v16 = a4;
      if (a4 == 1) {
        unint64_t v17 = v11 & 0xFFFFFFFFFFFFFFDFLL;
      }
      else {
        unint64_t v17 = v11;
      }
      if (a4 == 1) {
        unint64_t v18 = v11 & 0x20;
      }
      else {
        unint64_t v18 = 0LL;
      }
      uint64_t v19 = v18 | a4 | 0x500000000000000LL;
      icu::UVector64::setElementAt((uint64_t)v15, v17 | v12, a2);
      unsigned int v20 = (v17 >> 8) & 0xFFFFF;
      uint64_t inserted = icu::CollationBuilder::insertNodeBetween(this, v8, v20, v16 | (a3 << 48), a5);
      icu::CollationBuilder::insertNodeBetween(this, inserted, v20, v19, a5);
      return inserted;
    }
  }

  while (1)
  {
    unsigned int v13 = (v11 >> 8) & 0xFFFFF;
    if (!v13) {
      return icu::CollationBuilder::insertNodeBetween(this, v8, v13, a4 | (unint64_t)(a3 << 48), a5);
    }
    else {
      unint64_t v11 = *(void *)(*((void *)this + 76) + 8LL * v13);
    }
    if ((v11 & 8) != 0) {
      goto LABEL_30;
    }
    int v14 = HIWORD(v11) <= a3 ? 0 : 3;
    uint64_t inserted = HIWORD(v11) == (_DWORD)a3 ? v13 : inserted;
    if (HIWORD(v11) == (_DWORD)a3) {
      int v14 = 1;
    }
    if (HIWORD(v11) < a3)
    {
LABEL_30:
      int v14 = 0;
      signed int v8 = v13;
    }

    if (v14)
    {
      if (v14 != 3) {
        return inserted;
      }
      return icu::CollationBuilder::insertNodeBetween(this, v8, v13, a4 | (unint64_t)(a3 << 48), a5);
    }
  }

uint64_t icu::CollationBuilder::ceStrength(unint64_t this)
{
  if (this) {
    int v1 = 2;
  }
  else {
    int v1 = 15;
  }
  if ((this & 0xFF000000) != 0) {
    int v1 = 1;
  }
  if (HIBYTE(this)) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = v1;
  }
  else {
    return v2;
  }
}

uint64_t icu::CollationBuilder::findOrInsertNodeForRootCE( icu::CollationBuilder *this, unint64_t a2, int a3, UErrorCode *a4)
{
  int v8 = a2;
  uint64_t inserted = icu::CollationBuilder::findOrInsertNodeForPrimary(this, HIDWORD(a2), a4);
  if (a3 < 1) {
    return inserted;
  }
  uint64_t inserted = icu::CollationBuilder::findOrInsertWeakNode(this, inserted, HIWORD(v8), 1, a4);
  if (a3 == 1) {
    return inserted;
  }
  return icu::CollationBuilder::findOrInsertWeakNode(this, inserted, v8 & 0x3F3F, 2, a4);
}

void **icu::CollationBuilder::addRelation( void **this, int a2, const icu::UnicodeString *a3, const icu::UnicodeString *a4, const icu::UnicodeString *a5, char **a6, UErrorCode *a7)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (*(int *)a7 <= 0)
  {
    uint64_t v13 = (uint64_t)this;
    __int128 v14 = 0uLL;
    __int128 v54 = 0u;
    uint64_t v57 = 0LL;
    __int128 v56 = 0u;
    __int128 v55 = 0u;
    double v53 = off_18971B688;
    LOWORD(v54) = 2;
    if (*((unsigned __int16 *)a3 + 4) >= 0x20u)
    {
      (*(void (**)(void *, const icu::UnicodeString *, void (***)(icu::UnicodeString *__hidden), UErrorCode *))(*this[1] + 24LL))( this[1],  a3,  &v53,  a7);
      __int128 v14 = 0uLL;
      if (*(int *)a7 >= 1)
      {
        unint64_t v15 = "normalizing the relation prefix";
        *a6 = "normalizing the relation prefix";
        return (void **)icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)&v53);
      }
    }

    uint64_t v16 = *(void *)(v13 + 8);
    __int128 v49 = v14;
    __int128 v50 = v14;
    __int128 v51 = v14;
    uint64_t v52 = 0LL;
    __int128 v48 = off_18971B688;
    LOWORD(v49) = 2;
    (*(void (**)(uint64_t, const icu::UnicodeString *, void (***)(icu::UnicodeString *__hidden), UErrorCode *))(*(void *)v16 + 24LL))( v16,  a4,  &v48,  a7);
    if (*(int *)a7 >= 1)
    {
      unint64_t v17 = "normalizing the relation string";
LABEL_7:
      *a6 = v17;
LABEL_8:
      icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v48);
      return (void **)icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)&v53);
    }

    if ((__int16)v49 < 0)
    {
      int v18 = DWORD1(v49);
      if (SDWORD1(v49) <= 1) {
        goto LABEL_30;
      }
    }

    else
    {
      int v18 = (unsigned __int16)v49 >> 5;
    }

    uint64_t v19 = (unsigned __int16 *)&v49 + 1;
    if ((v49 & 2) == 0) {
      uint64_t v19 = (unsigned __int16 *)v50;
    }
    int v20 = *v19;
    unsigned int v21 = v20 - 4371;
    unsigned int v22 = v20 - 4470;
    if (v21 > 0xFFFFFFEC || v22 >= 0xFFFFFFEB)
    {
      *a7 = U_UNSUPPORTED_ERROR;
      unint64_t v17 = "contractions starting with conjoining Jamo L or V not supported";
      goto LABEL_7;
    }

    unsigned int v24 = v18 - 1;
    unsigned int v25 = (unsigned __int16)v49 >> 5;
    if ((v49 & 0x8000u) != 0LL) {
      unsigned int v25 = DWORD1(v49);
    }
    if (v25 > v24)
    {
      int v26 = v19[v24];
      if ((v26 - 4371) > 0xFFFFFFEC
        || (v26 - 4470) >= 0xFFFFFFEB
        && (unsigned int v27 = v18 - 2, v25 > v27)
        && v19[v27] - 4371 >= 0xFFFFFFED)
      {
        *a7 = U_UNSUPPORTED_ERROR;
        unint64_t v17 = "contractions ending with conjoining Jamo L or L+V not supported";
        goto LABEL_7;
      }
    }

uint64_t icu::CollationBuilder::insertTailoredNodeAfter( icu::CollationBuilder *this, uint64_t CommonNode, int a3, UErrorCode *a4)
{
  if (a3 >= 1)
  {
    CommonNode = icu::CollationBuilder::findCommonNode(this, CommonNode, 1);
    if (a3 != 1) {
      LODWORD(CommonNode) = icu::CollationBuilder::findCommonNode(this, CommonNode, 2);
    }
  }

  if ((CommonNode & 0x80000000) != 0
    || (int v8 = *((_DWORD *)this + 148), v8 <= (int)CommonNode)
    || (unsigned int v9 = (*(void *)(*((void *)this + 76) + 8LL * CommonNode) >> 8) & 0xFFFFF) == 0)
  {
LABEL_15:
    unsigned int v10 = 0;
  }

  else
  {
    while (1)
    {
      unsigned int v10 = v9;
      else {
        uint64_t v11 = *(void *)(*((void *)this + 76) + 8LL * v9);
      }
      if ((v11 & 3) <= a3) {
        break;
      }
      unsigned int v9 = (v11 >> 8) & 0xFFFFF;
      LODWORD(CommonNode) = v10;
      if (!v9)
      {
        LODWORD(CommonNode) = v10;
        goto LABEL_15;
      }
    }
  }

  return icu::CollationBuilder::insertNodeBetween(this, CommonNode, v10, a3 | 8, a4);
}

void icu::CollationBuilder::setCaseBits( icu::CollationBuilder *this, const icu::UnicodeString *a2, const char **a3, UErrorCode *a4)
{
  int v5 = *((_DWORD *)this + 136);
  if (v5 < 1) {
    return;
  }
  uint64_t v8 = 0LL;
  unsigned int v9 = (unint64_t *)((char *)this + 296);
  uint64_t v10 = *((unsigned int *)this + 136);
  do
  {
    unint64_t v12 = *v9++;
    unint64_t v11 = v12;
    if ((v12 - 1174405120) >> 30 != 3)
    {
      if (!HIBYTE(v11)) {
        goto LABEL_8;
      }
LABEL_7:
      uint64_t v8 = (v8 + 1);
      goto LABEL_8;
    }

    if ((v11 & 0x300) == 0) {
      goto LABEL_7;
    }
LABEL_8:
    --v10;
  }

  while (v10);
  if ((int)v8 <= 0)
  {
    uint64_t v15 = 0LL;
    goto LABEL_38;
  }

  unsigned int v13 = *((unsigned __int16 *)a2 + 4);
  if ((v13 & 0x11) != 0)
  {
    __int128 v14 = 0LL;
  }

  else if ((v13 & 2) != 0)
  {
    __int128 v14 = (char *)a2 + 10;
  }

  else
  {
    __int128 v14 = (char *)*((void *)a2 + 3);
  }

  __int128 v37 = 0u;
  __int128 v38 = 0u;
  int v16 = (__int16)v13;
  memset(v36, 0, sizeof(v36));
  __int128 v35 = 0u;
  unsigned int v17 = v13 >> 5;
  if (v16 < 0) {
    unsigned int v17 = *((_DWORD *)a2 + 3);
  }
  uint64_t v18 = **((void **)this + 5);
  int v34[2] = *((void *)this + 5);
  *((void *)&v35 + sub_18086E18C((uint64_t)this, 1) = (char *)v36 + 8;
  LODWORD(v36[0]) = 40;
  DWORD2(v37) = 0;
  DWORD2(v38) = -1;
  v34[0] = off_18972CFB0;
  v34[1] = v18;
  signed int v39 = v14;
  uint64_t v40 = v14;
  uint64_t v41 = &v14[2 * v17];
  int CEs = icu::CollationIterator::fetchCEs((icu::CollationIterator *)v34, a4);
  if (*(int *)a4 > 0)
  {
    *a3 = "fetching root CEs for tailored string";
    icu::UTF16CollationIterator::~UTF16CollationIterator((icu::UTF16CollationIterator *)v34);
    return;
  }

  if (CEs < 2)
  {
    uint64_t v22 = 0LL;
    unsigned int v21 = 0;
    LODWORD(v27) = 0;
    goto LABEL_35;
  }

  uint64_t v20 = 0LL;
  unsigned int v21 = 0;
  uint64_t v22 = 0LL;
  uint64_t v23 = (CEs - 1);
  unsigned int v24 = (unint64_t *)*((void *)&v35 + 1);
  while (2)
  {
    unint64_t v26 = *v24++;
    unsigned __int16 v25 = v26;
    if (!HIDWORD(v26))
    {
      uint64_t v27 = v20;
      goto LABEL_32;
    }

    uint64_t v27 = (v20 + 1);
    uint64_t v28 = v25 >> 14;
    if ((int)v27 < (int)v8)
    {
      v22 |= v28 << (2 * v20);
      goto LABEL_32;
    }

    if ((_DWORD)v27 == (_DWORD)v8)
    {
      unsigned int v21 = v28;
      uint64_t v27 = v8;
      goto LABEL_32;
    }

    if ((_DWORD)v28 == v21)
    {
LABEL_32:
      uint64_t v20 = v27;
      if (!--v23) {
        goto LABEL_35;
      }
      continue;
    }

    break;
  }

  unsigned int v21 = 1;
LABEL_35:
  unint64_t v29 = (unint64_t)v21 << (2 * v8 - 2);
  uint64_t v15 = v29 | v22;
  icu::UTF16CollationIterator::~UTF16CollationIterator((icu::UTF16CollationIterator *)v34);
  int v5 = *((_DWORD *)this + 136);
LABEL_38:
  if (v5 >= 1)
  {
    uint64_t v30 = v5;
    for (unsigned int i = (unint64_t *)((char *)this + 296); ; ++i)
    {
      unint64_t v32 = *i & 0xFFFFFFFFFFFF3FFFLL;
      unsigned int v33 = (v32 >> 8) & 3;
      if (v33 == 2) {
        goto LABEL_48;
      }
      if (!v33) {
        goto LABEL_47;
      }
LABEL_49:
      unint64_t *i = v32;
      if (!--v30) {
        return;
      }
    }

    if (!HIBYTE(v32))
    {
      if ((*i & 0xFF000000) != 0 || !v32) {
        goto LABEL_49;
      }
LABEL_48:
      v32 |= 0x8000uLL;
      goto LABEL_49;
    }

BOOL icu::CollationBuilder::ignorePrefix( icu::CollationBuilder *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  return *(int *)a3 > 0
      || (*(unsigned int (**)(void, const icu::UnicodeString *))(**((void **)this + 2) + 88LL))( *((void *)this + 2),  a2) == 0;
}

BOOL icu::CollationBuilder::ignoreString( icu::CollationBuilder *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 > 0
    || !(*(unsigned int (**)(void))(**((void **)this + 2) + 88LL))(*((void *)this + 2)))
  {
    return 1LL;
  }

  unsigned int v5 = *((unsigned __int16 *)a2 + 4);
  if ((v5 & 0x8000u) == 0) {
    unsigned int v6 = v5 >> 5;
  }
  else {
    unsigned int v6 = *((_DWORD *)a2 + 3);
  }
  if (!v6) {
    return 0LL;
  }
  if ((v5 & 2) != 0) {
    unsigned int v7 = (unsigned __int16 *)((char *)a2 + 10);
  }
  else {
    unsigned int v7 = (unsigned __int16 *)*((void *)a2 + 3);
  }
  return (*v7 - 44032) >> 2 < 0xAE9;
}

uint64_t icu::CollationBuilder::addIfDifferent( icu::CollationDataBuilder **this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, const uint64_t *a4, uint64_t a5, uint64_t a6, UErrorCode *a7)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (*(int *)a7 <= 0)
  {
    uint64_t v20 = 0LL;
    memset(v19, 0, sizeof(v19));
    if ((int)a5 >= 1)
    {
      if (*a4 != *(void *)&v19[0]) {
        goto LABEL_9;
      }
      uint64_t v14 = 1LL;
      do
      {
        unint64_t v15 = v14;
        uint64_t v16 = a4[v14];
        uint64_t v17 = *((void *)v19 + v14++);
      }

      while (v16 == v17);
      if (v15 < a5)
      {
LABEL_9:
        if ((_DWORD)a6 == -1) {
          a6 = (*(uint64_t (**)(icu::CollationDataBuilder *, const uint64_t *, uint64_t, UErrorCode *))(*(void *)this[9] + 32LL))( this[9],  a4,  a5,  a7);
        }
        icu::CollationDataBuilder::addCE32((uint64_t)this[9], a2, a3, a6, a7);
      }
    }
  }

  return a6;
}

uint64_t icu::CollationBuilder::addWithClosure( icu::CollationDataBuilder **this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, const uint64_t *a4, uint64_t a5, uint64_t a6, UErrorCode *a7)
{
  uint64_t v13 = icu::CollationBuilder::addIfDifferent(this, a2, a3, a4, a5, a6, a7);
  uint64_t v14 = icu::CollationBuilder::addOnlyClosure(this, a2, a3, a4, a5, v13, a7);
  icu::CollationBuilder::addTailComposites(this, a2, a3, a7);
  return v14;
}

void icu::CollationBuilder::suppressContractions( uint64_t ***this, const icu::UnicodeSet *a2, const char **a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    icu::CollationDataBuilder::suppressContractions(this[9], a2, a4);
  }

icu::UnicodeSet *icu::CollationBuilder::optimize( icu::UnicodeSet *this, const icu::UnicodeSet *a2, const char **a3, UErrorCode *a4)
{
  return this;
}

uint64_t icu::CollationBuilder::addOnlyClosure( icu::CollationDataBuilder **this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, const uint64_t *a4, uint64_t a5, uint64_t a6, UErrorCode *a7)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (*((unsigned __int16 *)a2 + 4) <= 0x1Fu)
  {
    uint64_t v52 = 0LL;
    __int128 v50 = 0u;
    __int128 v51 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    icu::CanonicalIterator::CanonicalIterator((icu::CanonicalIterator *)&v40, a3, a7);
    memset((char *)v34 + 8, 0, 56);
    *(void *)&v34[0] = off_18971B688;
    WORD4(v34[0]) = 2;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    icu::CanonicalIterator::next((icu::CanonicalIterator *)&v40, (icu::UnicodeString *)&v36);
    uint64_t v14 = WORD4(v36);
    if ((BYTE8(v36) & 1) != 0) {
      goto LABEL_25;
    }
    int v15 = 0;
    while (1)
    {
      if (!icu::CollationBuilder::ignoreString((icu::CollationBuilder *)this, (const icu::UnicodeString *)&v36, a7))
      {
        if ((BYTE8(v36) & 1) != 0)
        {
          uint64_t v14 = *((unsigned __int16 *)a3 + 4);
          if ((v14 & 1) != 0) {
            goto LABEL_24;
          }
        }

        else
        {
          if ((SWORD4(v36) & 0x8000u) == 0) {
            int v16 = WORD4(v36) >> 5;
          }
          else {
            int v16 = HIDWORD(v36);
          }
          unsigned int v17 = *((unsigned __int16 *)a3 + 4);
          if ((v17 & 0x8000u) == 0) {
            unsigned int v18 = v17 >> 5;
          }
          else {
            unsigned int v18 = *((_DWORD *)a3 + 3);
          }
          if ((v17 & 1) == 0 && v16 == v18 && icu::UnicodeString::doEquals((icu::UnicodeString *)&v36, a3, v16)) {
            goto LABEL_24;
          }
        }

        if (v15 >= 6561)
        {
          uint64_t v14 = 31LL;
          *a7 = U_STANDARD_ERROR_LIMIT;
LABEL_25:
          icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)&v36);
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v34);
          goto LABEL_64;
        }

        a6 = icu::CollationBuilder::addIfDifferent( this,  (const icu::UnicodeString *)v34,  (const icu::UnicodeString *)&v36,  a4,  a5,  a6,  a7);
        uint64_t v14 = *(unsigned int *)a7;
        ++v15;
      }

void *icu::CollationBuilder::addTailComposites( void *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, UErrorCode *a4)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 <= 0)
  {
    unsigned int v5 = *((unsigned __int16 *)a3 + 4);
    int v6 = (__int16)v5;
    uint64_t v7 = v5 >> 5;
    uint64_t v8 = v6 >= 0 ? v7 : *((unsigned int *)a3 + 3);
    if ((_DWORD)v8)
    {
      uint64_t v11 = (uint64_t)this;
      while (1)
      {
        unint64_t v12 = icu::UnicodeString::char32At((uint64_t *)v7, a3, (int)v8 - 1);
        this = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v11 + 8) + 80LL))( *(void *)(v11 + 8),  v12);
        if (!(_DWORD)this) {
          break;
        }
        else {
          uint64_t v7 = 0xFFFFFFFFLL;
        }
        uint64_t v8 = (v7 + v8);
        if (!(_DWORD)v8) {
          return this;
        }
      }

      if (((_DWORD)v12 - 4371) <= 0xFFFFFFEC)
      {
        uint64_t v23 = 0LL;
        memset(v22, 0, sizeof(v22));
        icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v22);
        if (icu::Normalizer2Impl::getCanonStartSet( *(icu::Normalizer2Impl **)(v11 + 24),  v12,  (icu::UnicodeSet *)v22))
        {
          __int128 v51 = 0u;
          uint64_t v54 = 0LL;
          __int128 v53 = 0u;
          __int128 v52 = 0u;
          uint64_t v49 = 0LL;
          __int128 v50 = off_18971B688;
          LOWORD(v5sub_18086E18C((uint64_t)this, 1) = 2;
          __int128 v46 = 0u;
          __int128 v48 = 0u;
          __int128 v47 = 0u;
          __int128 v45 = off_18971B688;
          LOWORD(v46) = 2;
          __int128 v41 = 0u;
          uint64_t v44 = 0LL;
          __int128 v43 = 0u;
          __int128 v42 = 0u;
          __int128 v40 = off_18971B688;
          LOWORD(v4sub_18086E18C((uint64_t)this, 1) = 2;
          uint64_t v39 = 0LL;
          __int128 v37 = 0u;
          __int128 v38 = 0u;
          __int128 v35 = 0u;
          __int128 v36 = 0u;
          __int128 v33 = 0u;
          __int128 v34 = 0u;
          __int128 v31 = 0u;
          __int128 v32 = 0u;
          __int128 v29 = 0u;
          __int128 v30 = 0u;
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          __int128 v25 = 0u;
          __int128 v26 = 0u;
          *(_OWORD *)int v24 = 0u;
          memset(v21, 0, sizeof(v21));
          icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v21, (const icu::UnicodeSet *)v22);
          while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v21))
          {
            unsigned int v14 = DWORD2(v21[0]);
            (*(void (**)(void, void, void (***)(icu::UnicodeString *__hidden)))(**(void **)(v11 + 8) + 56LL))( *(void *)(v11 + 8),  DWORD2(v21[0]),  &v50);
            if (icu::CollationBuilder::mergeCompositeIntoString( (icu::CollationBuilder *)v11,  a3,  v8,  v14,  (const icu::UnicodeString *)&v50,  (icu::UnicodeString *)&v45,  (icu::UnicodeString *)&v40,  a4))
            {
              int CEs = icu::CollationDataBuilder::getCEs( *(icu::CollationDataBuilder **)(v11 + 72),  a2,  (const icu::UnicodeString *)&v45,  v24,  0LL);
              if ((int)CEs <= 31)
              {
                uint64_t v16 = (uint64_t)CEs;
                uint64_t v17 = icu::CollationBuilder::addIfDifferent( (icu::CollationDataBuilder **)v11,  a2,  (const icu::UnicodeString *)&v40,  v24,  (uint64_t)CEs,  0xFFFFFFFFLL,  a4);
                if ((_DWORD)v17 != -1) {
                  icu::CollationBuilder::addOnlyClosure( (icu::CollationDataBuilder **)v11,  a2,  (const icu::UnicodeString *)&v45,  v24,  v16,  v17,  a4);
                }
              }
            }
          }

          icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v21);
          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v40);
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)&v45);
          icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v50);
        }

        return icu::UnicodeSet::~UnicodeSet(v13, (icu::UnicodeSet *)v22);
      }
    }
  }

  return this;
}

uint64_t icu::CollationBuilder::mergeCompositeIntoString( icu::CollationBuilder *this, const icu::UnicodeString *a2, uint64_t a3, unsigned int a4, const icu::UnicodeString *a5, icu::UnicodeString *a6, icu::UnicodeString *a7, UErrorCode *a8)
{
  int v16 = icu::UnicodeString::moveIndex32(a5, 0, 1);
  uint64_t result = 0LL;
  unsigned int v17 = *((unsigned __int16 *)a5 + 4);
  if ((v17 & 0x8000u) == 0) {
    int v18 = v17 >> 5;
  }
  else {
    int v18 = *((_DWORD *)a5 + 3);
  }
  if (v16 == v18) {
    return result;
  }
  if ((v17 & 1) == 0)
  {
    if (v16 < 0)
    {
      int v19 = 0;
    }

    else
    {
      int v19 = v18;
      int v20 = v16;
      if (v18 >= v16)
      {
LABEL_15:
        if ((v17 & 2) != 0) {
          int v21 = (char *)a5 + 10;
        }
        else {
          int v21 = (char *)*((void *)a5 + 3);
        }
        uint64_t result = icu::UnicodeString::doCompare((uint64_t)a2, a3, 0x7FFFFFFF, (uint64_t)v21, v20, v18 - v20);
        if ((_DWORD)result) {
          goto LABEL_19;
        }
        return result;
      }
    }

    int v20 = v19;
    goto LABEL_15;
  }

  uint64_t result = (*((_WORD *)a2 + 4) & 1) == 0;
  if ((*((_WORD *)a2 + 4) & 1) == 0)
  {
LABEL_19:
    icu::UnicodeString::unBogus((uint64_t)a6);
    unsigned int v22 = *((unsigned __int16 *)a6 + 4);
    int v23 = (__int16)v22;
    unsigned int v24 = v22 >> 5;
    if (v23 >= 0) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = *((unsigned int *)a6 + 3);
    }
    icu::UnicodeString::doReplace(a6, 0LL, v25, a2, 0, a3);
    icu::UnicodeString::unBogus((uint64_t)a7);
    unsigned int v26 = *((unsigned __int16 *)a7 + 4);
    int v27 = (__int16)v26;
    unsigned int v28 = v26 >> 5;
    if (v27 >= 0) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = *((unsigned int *)a7 + 3);
    }
    uint64_t v49 = a7;
    uint64_t v30 = icu::UnicodeString::doReplace(a7, 0LL, v29, a2, 0, (a3 - v16));
    icu::UnicodeString::append(v30, a4);
    unsigned __int8 v31 = 0;
LABEL_26:
    unsigned int v32 = *((unsigned __int16 *)a2 + 4);
    int v33 = (__int16)v32;
    LODWORD(v34) = v32 >> 5;
    if (v33 >= 0) {
      unint64_t v34 = v34;
    }
    else {
      unint64_t v34 = *((unsigned int *)a2 + 3);
    }
    if ((int)a3 >= (int)v34)
    {
      LODWORD(v38) = *((unsigned __int16 *)a5 + 4);
      signed int v40 = *((_DWORD *)a5 + 3);
      unsigned int v39 = v38 >> 5;
    }

    else
    {
      __int128 v35 = icu::UnicodeString::char32At((uint64_t *)v34, a2, a3);
      unsigned __int8 v36 = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 1) + 80LL))(*((void *)this + 1), v35);
      while (1)
      {
        unsigned int v37 = *((unsigned __int16 *)a5 + 4);
        __int128 v38 = (uint64_t *)(__int16)v37;
        unsigned int v39 = v37 >> 5;
        signed int v40 = *((_DWORD *)a5 + 3);
        int v41 = (int)v38 >= 0 ? v39 : *((_DWORD *)a5 + 3);
        if (v16 >= v41) {
          break;
        }
        __int128 v42 = icu::UnicodeString::char32At(v38, a5, v16);
        unsigned int v43 = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 1) + 80LL))( *((void *)this + 1),  v42);
        unsigned __int8 v31 = v43;
        if (v43 >= v36)
        {
          if ((_DWORD)v42 != (_DWORD)v35) {
            return 0LL;
          }
          icu::UnicodeString::append((uint64_t)a6, v35);
          else {
            int v44 = 2;
          }
          LODWORD(a3) = v44 + a3;
          LODWORD(v35) = -1;
        }

        else
        {
          icu::UnicodeString::append((uint64_t)a6, v42);
          else {
            int v44 = 2;
          }
        }

        v16 += v44;
      }

      if ((v35 & 0x80000000) == 0)
      {
        icu::UnicodeString::doAppend((uint64_t)a6, a2, a3, 0x7FFFFFFFLL);
        __int128 v45 = v49;
        __int128 v46 = a2;
        int v47 = a3;
        goto LABEL_56;
      }
    }

    else {
      signed int v48 = v40;
    }
    if (v16 >= v48) {
      return 1LL;
    }
    __int128 v45 = a6;
    __int128 v46 = a5;
    int v47 = v16;
LABEL_56:
    icu::UnicodeString::doAppend((uint64_t)v45, v46, v47, 0x7FFFFFFFLL);
    return 1LL;
  }

  return result;
}

BOOL icu::CollationBuilder::isFCD(icu::CollationBuilder *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  return *(int *)a3 <= 0
      && (*(unsigned int (**)(void, const icu::UnicodeString *))(**((void **)this + 2) + 88LL))( *((void *)this + 2),  a2) != 0;
}

BOOL icu::CollationBuilder::sameCEs( icu::CollationBuilder *this, const uint64_t *a2, void *a3, const uint64_t *a4)
{
  if ((_DWORD)a2 != (_DWORD)a4) {
    return 0LL;
  }
  if (*(void *)this != *a3) {
    return 0LL;
  }
  uint64_t v4 = 1LL;
  do
  {
    unint64_t v5 = v4;
    uint64_t v6 = *((void *)this + v4);
    uint64_t v7 = a3[v4++];
  }

  while (v6 == v7);
  return v5 >= a2;
}

uint64_t icu::CollationBuilder::countTailoredNodes(icu::CollationBuilder *this, const uint64_t *a2, int a3)
{
  if (!(_DWORD)a2) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    uint64_t v5 = *((void *)this + (int)a2);
    if ((v5 & 3) < a3) {
      break;
    }
    if ((v5 & 3) == a3)
    {
      if ((v5 & 8) == 0) {
        return result;
      }
      uint64_t result = (result + 1);
    }

    LODWORD(a2) = (v5 >> 8) & 0xFFFFF;
  }

  while ((_DWORD)a2);
  return result;
}

void sub_1808A732C(icu::CollationDataBuilder::CEModifier *a1)
{
}

icu::RuleBasedCollator *ucol_openRules( uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4, UParseError *a5, icu::CollationRoot *a6)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (uint64_t *)*(unsigned int *)a6;
  unsigned int v12 = a2;
  if (!a1 && (_DWORD)a2)
  {
    uint64_t v7 = 0LL;
    int v14 = 1;
LABEL_11:
    *(_DWORD *)a6 = v14;
    return v7;
  }

  int v15 = (icu::RuleBasedCollator *)icu::UMemory::operator new(v6, (icu::UMemory *)0x110, a2);
  uint64_t v7 = v15;
  if (!v15)
  {
    int v14 = 7;
    goto LABEL_11;
  }

  icu::RuleBasedCollator::RuleBasedCollator(v15);
  memset(v20, 0, sizeof(v20));
  uint64_t v19 = a1;
  icu::UnicodeString::UnicodeString(v20, v12 >> 31, &v19);
  icu::RuleBasedCollator::internalBuildTailoring(v7, (UErrorCode *)v20, a4, a3, a5, 0LL, a6);
  int v16 = (void *)*(unsigned int *)a6;
  if ((int)v16 >= 1)
  {
    icu::RuleBasedCollator::~RuleBasedCollator(v7);
    icu::UMemory::operator delete(v17);
    uint64_t v7 = 0LL;
  }

  icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v20);
  return v7;
}

uint64_t ucol_getUnsafeSet(void *a1, icu::UnicodeSet *a2, UErrorCode *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  bzero(v22, 0x400uLL);
  uset_clear(a2);
  uset_applyPattern(a2, (uint64_t)&unk_180A32BAE, 24LL, 1u, a3);
  uset_addRange(a2, 55296LL, 57343LL);
  uint64_t v7 = uset_open(0, 0LL, v6);
  uint64_t v21 = (int *)a3;
  ucol_getContractionsAndExpansions(a1, v7, 0LL, 0, a3);
  int v8 = uset_size(v7);
  if (v8 >= 1)
  {
    int v9 = v8;
    for (int i = 0; i != v9; ++i)
    {
      Iteint m = uset_getItem(v7, i, 0LL, 0LL, v22, 512, v21);
      if (Item >= 1)
      {
        int v12 = Item;
        int v13 = 0;
        while (1)
        {
          uint64_t v14 = v13 + 1LL;
          uint64_t v15 = v22[v13];
          if ((v15 & 0xFC00) != 0xD800 || (_DWORD)v14 == v12)
          {
            ++v13;
          }

          else
          {
            int v17 = v22[v14];
            BOOL v18 = (v17 & 0xFC00) == 56320;
            unsigned int v19 = v17 + ((_DWORD)v15 << 10) - 56613888;
            if (v18) {
              v13 += 2;
            }
            else {
              ++v13;
            }
            uint64_t v15 = v18 ? v19 : v15;
          }

          if (v13 >= v12) {
            break;
          }
          uset_add(a2, v15);
        }
      }
    }
  }

  uset_close(v7);
  return uset_size(a2);
}

uint64_t sub_1808A7634(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0x101000100LL;
  if ((a2 & 0xFE) != 0 && ((a2 >> 8) & 0xFE) - 70 >= 0xFFFFFFC0) {
    return *(void *)(*(void *)(a1 + 8)
  }
                     + 8LL
                     * (((a2 - 1077937696) >> 11) & 0xFE000 | ((a2 - 1077937696) >> 10) & 0x1FC0 | ((a2 - 1077937696) >> 8) & 0x3F)) | (a2 << 8) & 0xC000;
  return result;
}

uint64_t sub_1808A7694(uint64_t a1, uint64_t a2)
{
  if ((a2 - 1174405120) >> 30 == 3) {
    return *(void *)(*(void *)(a1 + 8)
  }
                     + 8
                     * (((unint64_t)(a2 - 0x4040000006002000LL) >> 43) & 0xFE000 | ((unint64_t)(a2 - 0x4040000006002000LL) >> 42) & 0x1FC0 | ((unint64_t)(a2 - 0x4040000006002000LL) >> 24) & 0x3F)) | (unsigned __int16)a2 & 0xC000;
  else {
    return 0x101000100LL;
  }
}

void sub_1808A76EC(icu::CollationRuleParser::Importer *a1)
{
}

void sub_1808A7700(uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, int *a6)
{
}

unint64_t icu::CollationCompare::compareUpToQuaternary( icu::CollationCompare *this, icu::CollationIterator *a2, icu::CollationIterator *a3, UErrorCode *a4, UErrorCode *a5)
{
  int v10 = 0;
  int v93 = *((_DWORD *)a3 + 6);
  if ((v93 & 0xC) != 0) {
    unsigned int v11 = *((_DWORD *)a3 + 7) + 1;
  }
  else {
    unsigned int v11 = 0;
  }
  do
  {
    while (1)
    {
      unint64_t v12 = sub_1808A16BC(this, a4);
      uint64_t i = HIDWORD(v12);
      if (v11 > HIDWORD(v12) && HIDWORD(v12) >= 0x2000001) {
        break;
      }
      if (HIDWORD(v12)) {
        goto LABEL_16;
      }
    }

    do
    {
      *(void *)(*((void *)this + 4) + 8LL * *((int *)this + 92) - 8) = v12 & 0xFFFFFFFF00000000LL;
      unint64_t v12 = sub_1808A16BC(this, a4);
      for (uint64_t i = HIDWORD(v12); !HIDWORD(v12); uint64_t i = HIDWORD(v12))
      {
        *(void *)(*((void *)this + 4) + 8LL * *((int *)this + 92) - 8) = 0LL;
        unint64_t v12 = sub_1808A16BC(this, a4);
      }

      int v10 = 1;
    }

    while (v11 > i && i > 0x2000000);
LABEL_16:
    while (1)
    {
      unint64_t result = sub_1808A16BC(a2, a4);
      unint64_t j = HIDWORD(result);
      if (v11 > HIDWORD(result) && HIDWORD(result) >= 0x2000001) {
        break;
      }
      if (HIDWORD(result)) {
        goto LABEL_26;
      }
    }

    do
    {
      *(void *)(*((void *)a2 + 4) + 8LL * *((int *)a2 + 92) - 8) = result & 0xFFFFFFFF00000000LL;
      unint64_t result = sub_1808A16BC(a2, a4);
      for (unint64_t j = HIDWORD(result); !HIDWORD(result); unint64_t j = HIDWORD(result))
      {
        *(void *)(*((void *)a2 + 4) + 8LL * *((int *)a2 + 92) - 8) = 0LL;
        unint64_t result = sub_1808A16BC(a2, a4);
      }

      int v10 = 1;
    }

    while (v11 > j && j > 0x2000000);
LABEL_26:
    if ((_DWORD)i != (_DWORD)j)
    {
      uint64_t v28 = *((void *)a3 + 4);
      if (v28)
      {
        if (i < 2 || *(_BYTE *)(v28 + ((unint64_t)i >> 24)))
        {
          LODWORD(i) = i & 0xFFFFFF | (*(unsigned __int8 *)(v28 + ((unint64_t)i >> 24)) << 24);
        }

        else
        {
          LODWORD(i) = icu::CollationSettings::reorderEx(a3, i);
          uint64_t v28 = *((void *)a3 + 4);
        }

        int v29 = *(unsigned __int8 *)(v28 + ((unint64_t)j >> 24));
        else {
          LODWORD(j) = icu::CollationSettings::reorderEx(a3, j);
        }
      }

      BOOL v30 = i >= j;
      goto LABEL_58;
    }
  }

  while ((_DWORD)i != 1);
  if (v93 < 4096)
  {
LABEL_104:
    if ((v93 & 0x400) != 0)
    {
      LODWORD(v54) = 0;
      LODWORD(v55) = 0;
      uint64_t v56 = *((void *)this + 4);
      uint64_t v57 = *((void *)a2 + 4);
      while (1)
      {
        uint64_t v54 = (int)v54;
        if (v93 >= 0x1000)
        {
          do
            unint64_t v58 = *(void *)(v56 + 8 * v54++);
          while (v58 < 0x10000);
          uint64_t v55 = (int)v55;
          do
            unint64_t v60 = *(void *)(v57 + 8 * v55++);
          while (v60 < 0x10000);
        }

        else
        {
          do
          {
            unint64_t v58 = *(void *)(v56 + 8 * v54++);
            if (HIDWORD(v58)) {
              BOOL v59 = (_DWORD)v58 == 0;
            }
            else {
              BOOL v59 = 1;
            }
          }

          while (v59);
          uint64_t v55 = (int)v55;
          do
          {
            unint64_t v60 = *(void *)(v57 + 8 * v55++);
            if (HIDWORD(v60)) {
              BOOL v61 = (_DWORD)v60 == 0;
            }
            else {
              BOOL v61 = 1;
            }
          }

          while (v61);
        }

        unsigned int v62 = v60 & 0xC000;
        if ((v58 & 0xC000) != v62) {
          break;
        }
        if (WORD1(v58) == 256) {
          goto LABEL_122;
        }
      }

      BOOL v30 = (v58 & 0xC000) >= v62;
      if ((v93 & 0x100) != 0)
      {
        unsigned int v31 = 1;
LABEL_59:
        if (v30) {
          return -v31;
        }
        else {
          return v31;
        }
      }
    }

    else
    {
LABEL_122:
      if (v93 < 0x2000) {
        return 0LL;
      }
      LODWORD(v63) = 0;
      LODWORD(v64) = 0;
      int v65 = 0;
      if ((v93 & 0x600) == 0x200) {
        int v66 = 65343;
      }
      else {
        int v66 = 16191;
      }
      uint64_t v67 = *((void *)this + 4);
      uint64_t v68 = *((void *)a2 + 4);
      do
      {
        uint64_t v63 = (int)v63;
        do
        {
          uint64_t v69 = *(void *)(v67 + 8 * v63++);
          v65 |= v69;
          unsigned int v70 = v66 & v69;
        }

        while ((v66 & v69) == 0);
        uint64_t v64 = (int)v64;
        do
        {
          uint64_t v71 = *(void *)(v68 + 8 * v64++);
          v65 |= v71;
          unsigned int v72 = v66 & v71;
        }

        while ((v66 & v71) == 0);
        if (v70 != v72)
        {
          int v87 = v93 & 0x700;
          int v88 = v70 + 0x4000;
          if (v70 < 0x101) {
            int v88 = v66 & v69;
          }
          int v89 = v72 + 0x4000;
          if (v72 < 0x101) {
            int v89 = v66 & v71;
          }
          BOOL v90 = v87 == 768;
          if (v87 == 768) {
            unsigned int v91 = v88;
          }
          else {
            unsigned int v91 = v66 & v69;
          }
          if (v90) {
            unsigned int v92 = v89;
          }
          else {
            unsigned int v92 = v66 & v71;
          }
          BOOL v30 = v91 >= v92;
          goto LABEL_58;
        }
      }

      while (v70 != 256);
      if (v93 < 12288 || !(v10 | v65 & 0xC0)) {
        return 0LL;
      }
      LODWORD(v73) = 0;
      LODWORD(v74) = 0;
      while (1)
      {
        uint64_t v73 = (int)v73;
        do
        {
          unint64_t v75 = (_DWORD *)(v67 + 8 * v73++);
          int v77 = v75;
          LODWORD(v75) = *v75;
          unsigned int v76 = v77[1];
          unsigned int v78 = (unsigned __int16)v75;
          unsigned int v79 = v75 | 0xFFFFFF3F;
          if (v78 >= 0x101) {
            uint64_t v80 = v79;
          }
          else {
            uint64_t v80 = v76;
          }
        }

        while (!(_DWORD)v80);
        uint64_t v74 = (int)v74;
        do
        {
          int v81 = (_DWORD *)(v68 + 8 * v74++);
          uint64_t v83 = v81;
          LODWORD(v8sub_18086E18C((uint64_t)this, 1) = *v81;
          unsigned int v82 = v83[1];
          unsigned int v84 = (unsigned __int16)v81;
          unsigned int v85 = v81 | 0xFFFFFF3F;
          if (v84 >= 0x101) {
            uint64_t v86 = v85;
          }
          else {
            uint64_t v86 = v82;
          }
        }

        while (!(_DWORD)v86);
        if ((_DWORD)v80 != (_DWORD)v86) {
          break;
        }
        unint64_t result = 0LL;
        if ((_DWORD)v80 == 1) {
          return result;
        }
      }

      if (*((void *)a3 + 4))
      {
        LODWORD(v80) = sub_1808A7CF0(a3, v80);
        LODWORD(v86) = sub_1808A7CF0(a3, v86);
      }

      BOOL v30 = v80 >= v86;
    }

uint64_t sub_1808A7CF0(icu::CollationSettings *a1, uint64_t a2)
{
  else {
    return icu::CollationSettings::reorderEx(a1, a2);
  }
}

uint64_t icu::CollationData::getIndirectCE32(icu::CollationData *this, uint64_t a2)
{
  int v2 = a2 & 0xF;
  switch(v2)
  {
    case 13:
      return 0xFFFFFFFFLL;
    case 11:
      return **((unsigned int **)this + 1);
    case 10:
      return *(unsigned int *)(*((void *)this + 1) + 4LL * (a2 >> 13));
  }

  return a2;
}

uint64_t icu::CollationData::getFinalCE32(icu::CollationData *this, uint64_t a2)
{
  if ((~(_DWORD)a2 & 0xC0) == 0)
  {
    int v2 = a2 & 0xF;
    switch(v2)
    {
      case 13:
        return 0xFFFFFFFFLL;
      case 11:
        return **((unsigned int **)this + 1);
      case 10:
        return *(unsigned int *)(*((void *)this + 1) + 4LL * (a2 >> 13));
    }
  }

  return a2;
}

unint64_t icu::CollationData::getSingleCE(icu::CollationData *this, unsigned int a2, UErrorCode *a3)
{
  int v6 = sub_1808A22C4((uint64_t *)this, a2);
  if (v6 == 192) {
    int v6 = sub_1808A22C4(*((uint64_t **)this + 4), a2);
  }
  if ((~v6 & 0xC0) == 0) {
    __asm { BR              X11 }
  }

  return (v6 << 16) & 0xFF000000 | ((unint64_t)((v6 & 0xFFFF0000) >> 16) << 48) | (v6 << 8);
}

void sub_1808A7EB4(unsigned int a1)
{
}

uint64_t icu::CollationData::getFirstPrimaryForGroup(icu::CollationData *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0LL;
  }
  int v2 = *((_DWORD *)this + 25);
  if (v2 <= (int)a2)
  {
    if ((a2 & 0xFFFFFFF8) != 0x1000) {
      return 0LL;
    }
    uint64_t v3 = (unsigned __int16 *)(*((void *)this + 13) + 2LL * (int)(a2 + v2 - 4096));
  }

  else
  {
    uint64_t v3 = (unsigned __int16 *)(*((void *)this + 13) + 2LL * a2);
  }

  uint64_t v4 = *v3;
  if (v4) {
    return *(unsigned __int16 *)(*((void *)this + 14) + 2 * v4) << 16;
  }
  return 0LL;
}

uint64_t icu::CollationData::getScriptIndex(icu::CollationData *this, unsigned int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    int v2 = *((_DWORD *)this + 25);
    if (v2 > (int)a2)
    {
      uint64_t v3 = (unsigned __int16 *)(*((void *)this + 13) + 2LL * a2);
      return *v3;
    }

    if ((a2 & 0xFFFFFFF8) == 0x1000)
    {
      uint64_t v3 = (unsigned __int16 *)(*((void *)this + 13) + 2LL * (int)(a2 + v2 - 4096));
      return *v3;
    }
  }

  return 0LL;
}

uint64_t icu::CollationData::getLastPrimaryForGroup(icu::CollationData *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0LL;
  }
  int v2 = *((_DWORD *)this + 25);
  if (v2 <= (int)a2)
  {
    if ((a2 & 0xFFFFFFF8) != 0x1000) {
      return 0LL;
    }
    uint64_t v3 = (unsigned __int16 *)(*((void *)this + 13) + 2LL * (int)(a2 + v2 - 4096));
  }

  else
  {
    uint64_t v3 = (unsigned __int16 *)(*((void *)this + 13) + 2LL * a2);
  }

  uint64_t v4 = *v3;
  if (v4) {
    return (*(unsigned __int16 *)(*((void *)this + 14) + 2 * v4 + 2) << 16) - 1;
  }
  return 0LL;
}

uint64_t icu::CollationData::getGroupForPrimary(icu::CollationData *this, unsigned int a2)
{
  unsigned int v2 = HIWORD(a2);
  uint64_t v3 = *((void *)this + 14);
  uint64_t v4 = 0LL;
  uint64_t v5 = v3 + 4;
  do
    unsigned int v6 = *(unsigned __int16 *)(v5 + 2 * v4++);
  while (v6 <= v2);
  uint64_t v7 = *((unsigned int *)this + 25);
  uint64_t v8 = *((void *)this + 13);
  if ((int)v7 < 1)
  {
LABEL_9:
    uint64_t v10 = 0LL;
    uint64_t v11 = v8 + 2LL * (int)v7;
    while (*(unsigned __int16 *)(v11 + 2 * v10) != (_DWORD)v4)
    {
      if (++v10 == 8) {
        return 0xFFFFFFFFLL;
      }
    }

    return (v10 + 4096);
  }

  else
  {
    uint64_t result = 0LL;
    while (*(unsigned __int16 *)(v8 + 2 * result) != (_DWORD)v4)
    {
      if (v7 == ++result) {
        goto LABEL_9;
      }
    }
  }

  return result;
}

uint64_t icu::CollationData::getEquivalentScripts( icu::CollationData *this, unsigned int a2, unsigned int *a3, int a4, UErrorCode *a5)
{
  uint64_t v5 = 0LL;
  int v6 = *((_DWORD *)this + 25);
  if (v6 <= (int)a2)
  {
    if ((a2 & 0xFFFFFFF8) != 0x1000) {
      return 0LL;
    }
    uint64_t v7 = *((void *)this + 13);
    uint64_t v8 = (_WORD *)(v7 + 2LL * (int)(a2 + v6 - 4096));
  }

  else
  {
    uint64_t v7 = *((void *)this + 13);
    uint64_t v8 = (_WORD *)(v7 + 2LL * a2);
  }

  int v9 = (unsigned __int16)*v8;
  if (!*v8) {
    return 0LL;
  }
  if (a2 <= 0xFFF)
  {
    if (v6 < 1)
    {
      uint64_t v5 = 0LL;
    }

    else
    {
      uint64_t v10 = 0LL;
      uint64_t v5 = 0LL;
      do
      {
        if (v9 == *(unsigned __int16 *)(v7 + 2 * v10))
        {
          if ((int)v5 < a4)
          {
            a3[(int)v5] = v10;
            int v6 = *((_DWORD *)this + 25);
          }

          uint64_t v5 = (v5 + 1);
        }

        ++v10;
      }

      while (v10 < v6);
    }
  }

  else
  {
    if (a4 < 1) {
      *a5 = U_BUFFER_OVERFLOW_ERROR;
    }
    else {
      *a3 = a2;
    }
    return 1LL;
  }

  return v5;
}

uint64_t icu::CollationData::makeReorderRanges( icu::CollationData *this, const int *a2, int a3, icu::UVector32 *a4, UErrorCode *a5)
{
  return icu::CollationData::makeReorderRanges((uint64_t)this, a2, a3, 0, a4, a5);
}

uint64_t icu::CollationData::makeReorderRanges( uint64_t this, const int *a2, int a3, int a4, icu::UVector32 *a5, UErrorCode *a6)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  uint64_t v11 = this;
  this = icu::UVector32::removeAllElements((uint64_t)a5);
  if (!a3 || a3 == 1 && *a2 == 103) {
    return this;
  }
  memset(v55, 0, sizeof(v55));
  uint64_t v12 = *(void *)(v11 + 104);
  uint64_t v13 = *(int *)(v11 + 100);
  if (*(_WORD *)(v12 + 2 * v13 + 28)) {
    *((_BYTE *)v55 + *(unsigned __int16 *)(v12 + 2 * v13 + 2icu::UnicodeString::~UnicodeString((icu::AlphabeticIndex::Record *)((char *)this + 8)) = -1;
  }
  uint64_t v14 = *(void *)(v11 + 112);
  signed int v15 = *(unsigned __int16 *)(v14 + 2);
  int v16 = *(_DWORD *)(v11 + 120);
  uint64_t v17 = (v16 - 1);
  signed int v18 = *(unsigned __int16 *)(v14 + 2LL * (int)v17);
  uint64_t v19 = a3;
  if (a3 < 1)
  {
    unsigned int v20 = 0;
  }

  else
  {
    unsigned int v20 = 0;
    uint64_t v21 = a3;
    uint64_t v22 = a2;
    do
    {
      int v23 = *v22++;
      int v24 = 1 << v23;
      if ((v23 & 0xFFFFFFF8) != 0x1000) {
        int v24 = 0;
      }
      v20 |= v24;
      --v21;
    }

    while (v21);
  }

  uint64_t v25 = 0LL;
  this = v12 + 2 * v13;
  do
  {
    uint64_t v26 = *(unsigned __int16 *)(this + 2 * v25);
    if (*(_WORD *)(this + 2 * v25) && ((v20 >> v25) & 1) == 0)
    {
      int v27 = (__int16 *)(v14 + 2 * v26);
      __int16 v28 = *v27;
      *((_BYTE *)v55 + v26) = BYTE1(v15);
      signed int v15 = (((v27[1] & 0xFF00) - (v28 & 0xFF00)) & 0xFFFFFF00 | v27[1]) + (v15 & 0xFF00);
    }

    ++v25;
  }

  while (v25 != 8);
  if (v20)
  {
    unsigned int v20 = 0;
  }

  else if (!a4 && *a2 == 25)
  {
    unsigned int v20 = (*(_WORD *)(v14 + 2LL * *(unsigned __int16 *)(v12 + 50)) - (_WORD)v15) & 0xFF00;
    signed int v15 = *(unsigned __int16 *)(v14 + 2LL * *(unsigned __int16 *)(v12 + 50));
  }

  if (a3 < 1)
  {
    BOOL v30 = 1;
    goto LABEL_61;
  }

  uint64_t v29 = 0LL;
  BOOL v30 = 0;
  this = (v13 - 4096);
  while (1)
  {
    uint64_t v31 = a2[v29];
    if ((_DWORD)v31 == -1)
    {
LABEL_96:
      UErrorCode v46 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_97:
      *a6 = v46;
      return this;
    }

    if ((_DWORD)v31 == 103) {
      break;
    }
    if ((v31 & 0x80000000) == 0)
    {
      if ((v31 & 0xFFFFFFF8) == 0x1000)
      {
        uint64_t v31 = (int)this + (int)v31;
LABEL_37:
        uint64_t v32 = *(unsigned __int16 *)(v12 + 2 * v31);
        if (*(_WORD *)(v12 + 2 * v31))
        {
          if (*((_BYTE *)v55 + v32)) {
            goto LABEL_96;
          }
          int v33 = (__int16 *)(v14 + 2 * v32);
          __int16 v34 = *v33;
          *((_BYTE *)v55 + v32) = BYTE1(v15);
          signed int v15 = (((v33[1] & 0xFF00) - (v34 & 0xFF00)) & 0xFFFFFF00 | v33[1]) + (v15 & 0xFF00);
        }
      }
    }

    BOOL v30 = ++v29 >= (unint64_t)a3;
    if (a3 == v29) {
      goto LABEL_61;
    }
  }

  if ((int)v29 + 1 < a3)
  {
    uint64_t v35 = v29 + 1;
    while (1)
    {
      uint64_t v36 = a2[v19 - 1];
      BOOL v37 = (_DWORD)v36 == 103 || (_DWORD)v36 == -1;
      if (v37) {
        goto LABEL_96;
      }
      if ((v36 & 0x80000000) == 0)
      {
        if ((v36 & 0xFFFFFFF8) == 0x1000) {
          break;
        }
      }

uint64_t icu::CollationData::addLowScriptRange( icu::CollationData *this, unsigned __int8 *a2, int a3, __int16 a4)
{
  __int16 v4 = *(_WORD *)(*((void *)this + 14) + 2LL * a3);
  else {
    __int16 v5 = a4 + 256;
  }
  a2[a3] = HIBYTE(v5);
  return ((*(_WORD *)(*((void *)this + 14) + 2LL * a3 + 2) & 0xFF00) - (v4 & 0xFF00) + (v5 & 0xFF00)) & 0xFFFFFF00 | *(_WORD *)(*((void *)this + 14) + 2LL * a3 + 2);
}

uint64_t icu::CollationData::addHighScriptRange( icu::CollationData *this, unsigned __int8 *a2, int a3, __int16 a4)
{
  __int16 v4 = (__int16 *)(*((void *)this + 14) + 2LL * a3);
  __int16 v5 = v4[1];
  else {
    __int16 v6 = a4 - 256;
  }
  __int16 v7 = *v4;
  unsigned int v8 = (v6 & 0xFF00) + (v7 & 0xFF00) - (v5 & 0xFF00);
  unsigned int v9 = v8 >> 8;
  uint64_t result = v8 & 0xFFFFFF00 | v7;
  a2[a3] = v9;
  return result;
}

void sub_1808A870C(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (a1)
  {
    icu::UnicodeString::~UnicodeString(a2, (icu::UnicodeString *)(a1 + 8));
    icu::UMemory::operator delete((void *)a1);
  }

uint64_t sub_1808A873C(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 0LL;
  *(void *)(result + 8) = *(void *)(result + 400);
  *(void *)(result + 16) = result + 400;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 32) = result + 48;
  *(_DWORD *)(result + 40) = 40;
  *(_BYTE *)(result + 44) = 0;
  *(_DWORD *)(result + 368) = 0;
  *(void *)(result + 376) = 0LL;
  *(_DWORD *)(result + 384) = -1;
  *(_BYTE *)(result + 388) = 0;
  *(void *)uint64_t result = &off_18971FC18;
  *(void *)(result + 392) = a2;
  uint64_t v3 = *(void *)(a2 + 8);
  *(_OWORD *)(result + 400) = 0u;
  *(_OWORD *)(result + 416) = 0u;
  *(_OWORD *)(result + 432) = 0u;
  *(void *)(result + 448) = v3;
  *(_DWORD *)(result + 456) = 301989888;
  *(void *)(result + 528) = 0LL;
  *(_DWORD *)(result + 536) = 0;
  *(_OWORD *)(result + 460) = 0u;
  *(_OWORD *)(result + 476) = 0u;
  *(_OWORD *)(result + 492) = 0u;
  *(_OWORD *)(result + 508) = 0u;
  *(void *)(result + 816) = 0LL;
  *(_DWORD *)(result + 824) = 0;
  __int16 v4 = (_DWORD *)(result + 548);
  *(void *)(result + 432) = *(void *)(a2 + 16);
  int64x2_t v5 = (int64x2_t)xmmword_180A2CBE0;
  int64x2_t v6 = vdupq_n_s64(2uLL);
  uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(0x43uLL);
  do
  {
    if ((vmovn_s64((int64x2_t)vcgtq_u64(v7, (uint64x2_t)v5)).u8[0] & 1) != 0)
    {
      if (v2 >= 0x28) {
        int v8 = 4480;
      }
      else {
        int v8 = 4430;
      }
      if (v2 < 0x13) {
        int v8 = 4352;
      }
      *(v4 - sub_18086E18C((uint64_t)this, 1) = (((_DWORD)v2 + v8) << 13) | 0x1C7;
    }

    if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x43uLL), *(uint64x2_t *)&v5)).i32[1] & 1) != 0)
    {
      if (v2 + 1 >= 0x28) {
        int v9 = 4480;
      }
      else {
        int v9 = 4430;
      }
      if (v2 + 1 >= 0x13) {
        int v10 = v9;
      }
      else {
        int v10 = 4352;
      }
      *__int16 v4 = (((_DWORD)v2 + v10) << 13) + 8647;
    }

    v2 += 2LL;
    int64x2_t v5 = vaddq_s64(v5, v6);
    v4 += 2;
  }

  while (v2 != 68);
  *(void *)(result + 440) = result + 544;
  return result;
}

void sub_1808A8880(icu::CollationIterator *a1)
{
}

uint64_t sub_1808A8894(icu::CollationIterator *this, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *((void *)this + 49);
  uint64_t v11 = (uint64_t *)((char *)this + 400);
  uint64_t v12 = *(void *)(v10 + 96);
  *((void *)this + 5sub_18086E18C((uint64_t)this, 1) = *(void *)(v10 + 64);
  *((void *)this + 52) = v12;
  __int16 v13 = *(_WORD *)(v10 + 352);
  if ((v13 & 0x11) != 0)
  {
    uint64_t v14 = 0LL;
  }

  else if ((v13 & 2) != 0)
  {
    uint64_t v14 = v10 + 354;
  }

  else
  {
    uint64_t v14 = *(void *)(v10 + 368);
  }

  *((void *)this + 53) = v14;
  icu::CollationIterator::reset((uint64_t)this);
  *((void *)this + 102) = a2;
  *((_DWORD *)this + 206) = a3;
  UErrorCode v27 = U_ZERO_ERROR;
  do
  {
    uint64_t v15 = *((void *)this + 102);
    else {
      int v16 = (uint64_t *)(*(unsigned __int16 *)(v15 + 8) >> 5);
    }
    int v17 = *((_DWORD *)this + 206);
    *((_DWORD *)this + 6) = 0;
    *((_DWORD *)this + 92) = 0;
    unsigned int v18 = icu::UnicodeString::char32At(v16, (icu::UnicodeString *)v15, v17);
    if (v18 < 0x10000) {
      int v19 = 1;
    }
    else {
      int v19 = 2;
    }
    *((_DWORD *)this + 206) += v19;
    int v20 = utrie2_get32(*(uint64_t **)(*((void *)this + 49) + 32LL), v18);
    uint64_t v21 = v11;
    if (v20 == 192)
    {
      uint64_t v21 = *(uint64_t **)(*((void *)this + 49) + 16LL);
      int v20 = sub_1808A22C4(v21, v18);
    }

    icu::CollationIterator::appendCEsFromCE32((uint64_t)this, (const icu::CollationData *)v21, v18, v20, 1, &v27);
    uint64_t v22 = *((unsigned int *)this + 6);
    if ((int)v22 >= 1)
    {
      int v23 = (uint64_t *)*((void *)this + 4);
      do
      {
        uint64_t v25 = *v23++;
        uint64_t v24 = v25;
        if (v25)
        {
          a5 = (a5 + 1);
        }

        --v22;
      }

      while (v22);
    }
  }

  while (v27 <= U_ZERO_ERROR);
  return a5;
}

uint64_t sub_1808A8A14(uint64_t a1, int a2)
{
  uint64_t result = icu::CollationIterator::reset(a1);
  *(_DWORD *)(a1 + 824) = a2;
  return result;
}

uint64_t sub_1808A8A3C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 824);
}

uint64_t *sub_1808A8A44(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 824);
  uint64_t v3 = *(void *)(a1 + 816);
  else {
    __int16 v4 = (uint64_t *)(*(unsigned __int16 *)(v3 + 8) >> 5);
  }
  if (v2 == (_DWORD)v4) {
    return (uint64_t *)0xFFFFFFFFLL;
  }
  uint64_t result = icu::UnicodeString::char32At(v4, (icu::UnicodeString *)v3, v2);
  else {
    int v6 = 2;
  }
  *(_DWORD *)(a1 + 824) += v6;
  return result;
}

uint64_t *sub_1808A8AAC(uint64_t a1)
{
  int v1 = (uint64_t *)*(unsigned int *)(a1 + 824);
  if (!(_DWORD)v1) {
    return (uint64_t *)0xFFFFFFFFLL;
  }
  uint64_t result = icu::UnicodeString::char32At(v1, *(icu::UnicodeString **)(a1 + 816), (int)v1 - 1);
  else {
    int v4 = -1;
  }
  *(_DWORD *)(a1 + 824) += v4;
  return result;
}

uint64_t sub_1808A8AFC(uint64_t a1, int a2)
{
  uint64_t result = icu::UnicodeString::moveIndex32(*(icu::UnicodeString **)(a1 + 816), *(_DWORD *)(a1 + 824), a2);
  *(_DWORD *)(a1 + 824) = result;
  return result;
}

uint64_t sub_1808A8B2C(uint64_t a1, int a2)
{
  uint64_t result = icu::UnicodeString::moveIndex32(*(icu::UnicodeString **)(a1 + 816), *(_DWORD *)(a1 + 824), -a2);
  *(_DWORD *)(a1 + 824) = result;
  return result;
}

uint64_t sub_1808A8B60(uint64_t a1, unsigned int a2)
{
  return utrie2_get32(*(uint64_t **)(*(void *)(a1 + 392) + 32LL), a2);
}

uint64_t sub_1808A8B6C(uint64_t a1, unsigned int a2, UErrorCode *a3)
{
  if ((a2 & 0x100) != 0) {
    return utrie2_get32(*(uint64_t **)(*(void *)(a1 + 392) + 32LL), a2 >> 13);
  }
  uint64_t result = icu::UVector::elementAt((icu::UVector *)(*(void *)(a1 + 392) + 104LL), a2 >> 13);
  if (result)
  {
    uint64_t v6 = result;
    uint64_t result = *(unsigned int *)(result + 80);
    if ((_DWORD)result == 1 || *(_DWORD *)(v6 + 84) != *(_DWORD *)(*(void *)(a1 + 392) + 408LL))
    {
      uint64_t result = icu::CollationDataBuilder::buildContext(*(void *)(a1 + 392), v6, a3);
      *(_DWORD *)(v6 + 80) = result;
      if (*a3 == U_BUFFER_OVERFLOW_ERROR)
      {
        *a3 = U_ZERO_ERROR;
        uint64_t v7 = *(void *)(a1 + 392);
        if ((*(_WORD *)(v7 + 352) & 1) != 0) {
          __int16 v8 = 2;
        }
        else {
          __int16 v8 = *(_WORD *)(v7 + 352) & 0x1F;
        }
        *(_WORD *)(v7 + 352) = v8;
        ++*(_DWORD *)(v7 + 408);
        uint64_t result = icu::CollationDataBuilder::buildContext(*(void *)(a1 + 392), v6, a3);
        *(_DWORD *)(v6 + 80) = result;
      }

      uint64_t v9 = *(void *)(a1 + 392);
      *(_DWORD *)(v6 + 84) = *(_DWORD *)(v9 + 408);
      __int16 v10 = *(_WORD *)(v9 + 352);
      if ((v10 & 0x11) != 0)
      {
        uint64_t v11 = 0LL;
      }

      else if ((v10 & 2) != 0)
      {
        uint64_t v11 = v9 + 354;
      }

      else
      {
        uint64_t v11 = *(void *)(v9 + 368);
      }

      *(void *)(a1 + 424) = v11;
    }
  }

  else
  {
    *a3 = U_INTERNAL_PROGRAM_ERROR;
  }

  return result;
}

uint64_t icu::CollationDataBuilder::buildContext(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  memset(v75, 0, sizeof(v75));
  icu::UCharsTrieBuilder::UCharsTrieBuilder((icu::UCharsTrieBuilder *)v75, a3);
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v68 = 0u;
  icu::UCharsTrieBuilder::UCharsTrieBuilder((icu::UCharsTrieBuilder *)&v68, a3);
  uint64_t v59 = a2;
  while (2)
  {
    unsigned int v8 = *(unsigned __int16 *)(a2 + 16);
    else {
      unsigned int v9 = v8 >> 5;
    }
    if (v9)
    {
      if ((v8 & 2) != 0) {
        __int16 v10 = (unsigned __int16 *)(a2 + 18);
      }
      else {
        __int16 v10 = *(unsigned __int16 **)(a2 + 32);
      }
      int v11 = *v10;
    }

    else
    {
      int v11 = 0xFFFF;
    }

    __int128 v66 = 0uLL;
    __int128 v67 = 0uLL;
    int v61 = v11;
    int v12 = v11 + 1;
    __int128 v64 = 0uLL;
    __int128 v65 = 0uLL;
    icu::UnicodeString::UnicodeString( (icu::UnicodeString *)&v64,  (const icu::UnicodeString *)(a2 + 8),  0,  (v11 + 1));
    uint64_t v13 = a2;
    while (1)
    {
      uint64_t v14 = v13;
      *(_DWORD *)(v13 + 76) = 1;
      unsigned int v15 = *(_DWORD *)(v13 + 88);
      if ((v15 & 0x80000000) != 0) {
        break;
      }
      uint64_t v16 = icu::UVector::elementAt((icu::UVector *)(a1 + 104), v15);
      uint64_t v13 = v16;
      if ((SWORD4(v64) & 0x8000u) == 0) {
        int32_t v17 = WORD4(v64) >> 5;
      }
      else {
        int32_t v17 = HIDWORD(v64);
      }
      if ((BYTE8(v64) & 1) != 0)
      {
        if ((*(_BYTE *)(v16 + 16) & 1) == 0) {
          break;
        }
      }

      else
      {
        int v18 = v17 & (v17 >> 31);
        if (v17 < 0)
        {
          int32_t v19 = 0;
LABEL_29:
          int32_t v20 = v19;
          goto LABEL_30;
        }

        int32_t v19 = v17 - v18;
        int32_t v20 = v17;
LABEL_30:
        if ((*(_WORD *)(v16 + 16) & 1) != 0) {
          break;
        }
        uint64_t v21 = v16 + 8;
        uint64_t v22 = (BYTE8(v64) & 2) != 0 ? (__int128 *)((char *)&v64 + 10) : (__int128 *)*((void *)&v65 + 1);
      }
    }

    else {
      int v23 = *(unsigned __int16 *)(v14 + 16) >> 5;
    }
    int v24 = v61;
    if (v23 == v12)
    {
      uint64_t v3 = *(unsigned int *)(v14 + 72);
      goto LABEL_118;
    }

    if ((BYTE8(v69) & 1) != 0) {
      __int16 v25 = 2;
    }
    else {
      __int16 v25 = BYTE8(v69) & 0x1F;
    }
    WORD4(v69) = v25;
    HIDWORD(v73) = 0;
    HIDWORD(v74) = 0;
    else {
      int v26 = *(unsigned __int16 *)(a2 + 16) >> 5;
    }
    uint64_t v60 = a2;
    if (v26 == v12)
    {
      unsigned int v62 = *(_DWORD *)(a2 + 72);
      UErrorCode v27 = (unsigned int *)icu::UVector::elementAt((icu::UVector *)(a1 + 104), *(_DWORD *)(a2 + 88));
      int v28 = 512;
      goto LABEL_88;
    }

    unsigned int v62 = 0;
    uint64_t v29 = v59;
    while (2)
    {
      unsigned int v30 = *(unsigned __int16 *)(v29 + 16);
      else {
        unsigned int v31 = v30 >> 5;
      }
      __int128 v32 = 0uLL;
      if (v31)
      {
        if ((v30 & 2) != 0) {
          int v33 = (unsigned __int16 *)(v29 + 18);
        }
        else {
          int v33 = *(unsigned __int16 **)(v29 + 32);
        }
        int v34 = *v33;
      }

      else
      {
        int v34 = 0xFFFF;
      }

      if (v34 != v61)
      {
        if (*(_DWORD *)(v29 + 76) == 1) {
          goto LABEL_83;
        }
        if (!v34)
        {
          unsigned int v62 = *(_DWORD *)(v29 + 76);
          goto LABEL_83;
        }

        int v35 = v30 >> 5;
        if ((v30 & 0x8000u) != 0) {
          int v35 = *(_DWORD *)(v29 + 20);
        }
        if (v35 >= 1) {
          int v36 = 1;
        }
        else {
          int v36 = v35;
        }
        if (v35 - v36 >= v34) {
          int32_t v37 = v34;
        }
        else {
          int32_t v37 = v35 - v36;
        }
        int v38 = WORD4(v64) >> 5;
        if (SWORD4(v64) < 0) {
          int v38 = HIDWORD(v64);
        }
        if ((v30 & 1) != 0)
        {
          if ((BYTE8(v64) & 1) == 0) {
            goto LABEL_83;
          }
        }

        else
        {
          int v39 = v36 & ~(v36 >> 31);
          if (v37 < 0)
          {
            int v40 = 0;
          }

          else
          {
            int v40 = v35 - v39;
            int32_t v41 = v37;
            if (v40 >= v37)
            {
              if ((BYTE8(v64) & 1) == 0) {
                goto LABEL_75;
              }
LABEL_83:
              uint64_t v29 = icu::UVector::elementAt((icu::UVector *)(a1 + 104), *(_DWORD *)(v29 + 88));
              continue;
            }
          }

          int32_t v41 = v40;
          if ((BYTE8(v64) & 1) != 0) {
            goto LABEL_83;
          }
LABEL_75:
          if ((v30 & 2) != 0) {
            uint64_t v42 = v29 + 18;
          }
          else {
            uint64_t v42 = *(void *)(v29 + 32);
          }
        }

        unsigned int v62 = *(_DWORD *)(v29 + 76);
        goto LABEL_83;
      }

      break;
    }

    int v28 = 768;
    UErrorCode v27 = (unsigned int *)a2;
    while (1)
    {
      v63[2] = v32;
      v63[3] = v32;
      v63[0] = v32;
      v63[1] = v32;
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)v63, (const icu::UnicodeString *)(v27 + 2), v12);
      uint64_t v43 = *(void *)(a1 + 8);
      signed int v45 = icu::UnicodeString::char32At(v44, (icu::UnicodeString *)v63, 0);
      uint64_t v46 = *(void *)(a1 + 8);
      LODWORD(v47) = WORD4(v63[0]) >> 5;
      if ((SWORD4(v63[0]) & 0x8000u) == 0) {
        unint64_t v47 = v47;
      }
      else {
        unint64_t v47 = HIDWORD(v63[0]);
      }
      signed int v48 = icu::UnicodeString::char32At((uint64_t *)v47, (icu::UnicodeString *)v63, (int)v47 - 1);
      if (*(_BYTE *)(a1 + 617) && (v28 & 0x800) == 0)
      {
        LODWORD(v49) = WORD4(v63[0]) >> 5;
        unint64_t v49 = (SWORD4(v63[0]) & 0x8000u) == 0 ? v49 : HIDWORD(v63[0]);
        if ((int)v49 >= 1)
        {
          int v50 = 0;
          while (1)
          {
            UChar32 v51 = icu::UnicodeString::char32At((uint64_t *)v49, (icu::UnicodeString *)v63, v50);
            if (!u_getCombiningClass(v51)) {
              break;
            }
            if (v51 < 0x10000) {
              int v52 = 1;
            }
            else {
              int v52 = 2;
            }
            v50 += v52;
            LODWORD(v49) = WORD4(v63[0]) >> 5;
            if ((SWORD4(v63[0]) & 0x8000u) == 0) {
              unint64_t v49 = v49;
            }
            else {
              unint64_t v49 = HIDWORD(v63[0]);
            }
          }

          v28 |= 0x800u;
        }
      }

uint64_t icu::CollationDataBuilder::clearContexts(uint64_t this)
{
  if ((*(_WORD *)(this + 352) & 1) != 0) {
    __int16 v1 = 2;
  }
  else {
    __int16 v1 = *(_WORD *)(this + 352) & 0x1F;
  }
  *(_WORD *)(this + 352) = v1;
  ++*(_DWORD *)(this + 408);
  return this;
}

icu::CollationDataBuilder *icu::CollationDataBuilder::CollationDataBuilder( icu::CollationDataBuilder *this, UErrorCode *a2, UErrorCode *a3)
{
  int v4 = (int)a2;
  *(void *)this = off_18971FCA8;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)a3, a2);
  *((void *)this + 2) = 0LL;
  *(_OWORD *)((char *)this + 24) = 0u;
  icu::UVector32::UVector32((icu::CollationDataBuilder *)((char *)this + 40), a3);
  icu::UVector64::UVector64((icu::CollationDataBuilder *)((char *)this + 72), a3);
  icu::UVector::UVector((icu::CollationDataBuilder *)((char *)this + 104), a3);
  icu::UnicodeSet::UnicodeSet((icu::CollationDataBuilder *)((char *)this + 144));
  *((void *)this + 43) = off_18971B688;
  *((_WORD *)this + 176) = 2;
  *((_DWORD *)this + 102) = 0;
  icu::UnicodeSet::UnicodeSet((icu::CollationDataBuilder *)((char *)this + 416));
  *((_BYTE *)this + 616) = 0;
  *((_BYTE *)this + 617) = v4;
  *((_BYTE *)this + 618) = 0;
  *((_OWORD *)this + 39) = 0u;
  if (!v4)
  {
    int v6 = *((_DWORD *)this + 12);
    if (v6 >= -1 && *((_DWORD *)this + 13) > v6) {
      goto LABEL_6;
    }
    if (icu::UVector32::expandCapacity((icu::CollationDataBuilder *)((char *)this + 40), v6 + 1, a3))
    {
      int v6 = *((_DWORD *)this + 12);
LABEL_6:
      *(_DWORD *)(*((void *)this + 8) + 4LL * v6) = 0;
      ++*((_DWORD *)this + 12);
    }
  }

  icu::UVector::setDeleter( (icu::CollationDataBuilder *)((char *)this + 104),  (void (*)(void *))sub_1808A870C);
  return this;
}

void icu::CollationDataBuilder::~CollationDataBuilder(icu::CollationDataBuilder *this)
{
  *(void *)this = off_18971FCA8;
  utrie2_close(*((void *)this + 4));
  uint64_t v3 = *((void *)this + 78);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *((void *)this + 79);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  icu::UnicodeSet::~UnicodeSet(v2, (icu::CollationDataBuilder *)((char *)this + 416));
  icu::UnicodeString::~UnicodeString(v5, (icu::CollationDataBuilder *)((char *)this + 344));
  icu::UnicodeSet::~UnicodeSet(v6, (icu::CollationDataBuilder *)((char *)this + 144));
  icu::UVector::~UVector((icu::CollationDataBuilder *)((char *)this + 104));
  icu::UVector64::~UVector64((void **)this + 9);
  icu::UVector32::~UVector32((void **)this + 5);
  icu::UObject::~UObject(this);
}

{
  void *v1;
  icu::CollationDataBuilder::~CollationDataBuilder(this);
  icu::UMemory::operator delete(v1);
}

icu::UnicodeSet *icu::CollationDataBuilder::initForTailoring( icu::UnicodeSet *this, const icu::UnicodeSet **a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v4 = this;
    if (*((void *)this + 4))
    {
      UErrorCode v5 = U_INVALID_STATE_ERROR;
LABEL_4:
      *a3 = v5;
      return this;
    }

    if (!a2)
    {
      UErrorCode v5 = U_ILLEGAL_ARGUMENT_ERROR;
      goto LABEL_4;
    }

    *((void *)this + 2) = a2;
    if (*((_BYTE *)this + 617)) {
      unsigned int v7 = 192;
    }
    else {
      unsigned int v7 = -195323;
    }
    this = (icu::UnicodeSet *)utrie2_open(0xC0u, v7, (int *)a3);
    *((void *)v4 + 4) = this;
    if (!*((_BYTE *)v4 + 617))
    {
      for (unsigned int i = 192; i != 256; ++i)
        utrie2_set32(*((void *)v4 + 4), i, 192, (int *)a3);
      utrie2_setRange32(*((void *)v4 + 4), 0xAC00u, 0xD7A3u, 0xCCu, 1, (int *)a3);
      return icu::UnicodeSet::addAll((icu::UVector **)v4 + 52, a2[10]);
    }
  }

  return this;
}

uint64_t icu::CollationDataBuilder::maybeSetPrimaryRange( icu::CollationDataBuilder *this, signed int a2, signed int a3, uint64_t a4, unsigned int a5, UErrorCode *a6)
{
  int v10 = (a3 >> 5) - (a2 >> 5);
  if (v10 > 2 || (uint64_t v11 = 0LL, (a3 & 0x1Fu) >= 3) && (a2 & 0x1Fu) <= 0x1C && v10 >= 1)
  {
    uint64_t v12 = (a2 << 8) | (unint64_t)(a4 << 32) | a5;
    else {
      uint64_t v13 = v12;
    }
    int v14 = icu::CollationDataBuilder::addCE(this, v13, a6);
    if (v14 < 0x80000)
    {
      uint64_t v11 = 1LL;
      utrie2_setRange32(*((void *)this + 4), a2, a3, (v14 << 13) | 0xCE, 1, (int *)a6);
      *((_BYTE *)this + 616) = 1;
    }

    else
    {
      uint64_t v11 = 0LL;
      *a6 = U_BUFFER_OVERFLOW_ERROR;
    }
  }

  return v11;
}

uint64_t icu::CollationDataBuilder::addCE(icu::CollationDataBuilder *this, uint64_t a2, UErrorCode *a3)
{
  uint64_t v5 = *((unsigned int *)this + 20);
  if ((int)v5 < 1)
  {
LABEL_5:
    int v7 = v5 + 1;
    if ((int)v5 < -1 || *((_DWORD *)this + 21) <= (int)v5)
    {
      int v8 = *((_DWORD *)this + 20);
      int v7 = v8 + 1;
    }

    else
    {
      int v8 = *((_DWORD *)this + 20);
    }

    *(void *)(*((void *)this + 12) + 8LL * v8) = a2;
    *((_DWORD *)this + 20) = v7;
    return v5;
  }

  uint64_t v6 = 0LL;
  while (*(void *)(*((void *)this + 12) + 8 * v6) != a2)
  {
    if (v5 == ++v6) {
      goto LABEL_5;
    }
  }

  return v6;
}

uint64_t icu::CollationDataBuilder::setPrimaryRangeAndReturnNext( icu::CollationDataBuilder *this, signed int a2, signed int a3, uint64_t a4, unsigned int a5, UErrorCode *a6)
{
  uint64_t v6 = a4;
  int v13 = (*(uint64_t (**)(icu::CollationDataBuilder *, void))(*(void *)this + 24LL))(this, BYTE3(a4));
  if (!icu::CollationDataBuilder::maybeSetPrimaryRange(this, a2, a3, v6, a5, a6))
  {
    if (a3 <= a2) {
      signed int v14 = a2;
    }
    else {
      signed int v14 = a3;
    }
    int v15 = v14 + 1;
    do
    {
      utrie2_set32(*((void *)this + 4), a2++, v6 | 0xC1, (int *)a6);
      uint64_t v6 = icu::Collation::incThreeBytePrimaryByOffset((icu::Collation *)v6, v13, a5);
    }

    while (v15 != a2);
    return v6;
  }

  return icu::Collation::incThreeBytePrimaryByOffset((icu::Collation *)v6, v13, a5 + a5 * (a3 - a2));
}

uint64_t icu::CollationDataBuilder::getCE32FromOffsetCE32( icu::CollationDataBuilder *this, int a2, icu::Collation *a3, unsigned int a4)
{
  unsigned int v4 = a4 >> 13;
  if (a2)
  {
    uint64_t v5 = (void *)(*((void *)this + 2) + 16LL);
  }

  else
  {
    if (*((_DWORD *)this + 20) <= (signed int)v4)
    {
      unint64_t v6 = 0LL;
      return icu::Collation::getThreeBytePrimaryForOffsetData(a3, v6) | 0xC1;
    }

    uint64_t v5 = (void *)((char *)this + 96);
  }

  unint64_t v6 = *(void *)(*v5 + 8LL * v4);
  return icu::Collation::getThreeBytePrimaryForOffsetData(a3, v6) | 0xC1;
}

uint64_t icu::CollationDataBuilder::isCompressibleLeadByte(icu::CollationDataBuilder *this, unsigned int a2)
{
  return *(char *)(*(void *)(*((void *)this + 2) + 72LL) + a2);
}

BOOL icu::CollationDataBuilder::isAssigned(uint64_t **this, unsigned int a2)
{
  int v2 = utrie2_get32(this[4], a2);
  return v2 != 192 && v2 != -1;
}

uint64_t icu::CollationDataBuilder::getLongPrimaryIfSingleCE(uint64_t **this, unsigned int a2)
{
  int v2 = utrie2_get32(this[4], a2);
  if ((v2 & 0xCF) == 0xC1) {
    return v2 & 0xFFFFFF00;
  }
  else {
    return 0LL;
  }
}

unint64_t icu::CollationDataBuilder::getSingleCE(uint64_t **this, unsigned int a2, UErrorCode *a3)
{
  int v6 = utrie2_get32(this[4], a2);
  if (v6 == 192) {
    int v6 = sub_1808A22C4(this[2], a2);
  }
  if ((~v6 & 0xC0) == 0) {
    __asm { BR              X9 }
  }

  return (v6 << 16) & 0xFF000000 | ((unint64_t)((v6 & 0xFFFF0000) >> 16) << 48) | (v6 << 8);
}

uint64_t icu::CollationDataBuilder::addCE32(icu::CollationDataBuilder *this, int a2, UErrorCode *a3)
{
  uint64_t v5 = *((unsigned int *)this + 12);
  if ((int)v5 < 1)
  {
LABEL_5:
    if ((int)v5 < -1 || (int v7 = *((_DWORD *)this + 12), *((_DWORD *)this + 13) <= (int)v5))
    {
      if (!icu::UVector32::expandCapacity( (icu::CollationDataBuilder *)((char *)this + 40),  (int)v5 + 1,  a3)) {
        return v5;
      }
      int v7 = *((_DWORD *)this + 12);
    }

    *(_DWORD *)(*((void *)this + 8) + 4LL * v7) = a2;
    ++*((_DWORD *)this + 12);
    return v5;
  }

  uint64_t v6 = 0LL;
  while (*(_DWORD *)(*((void *)this + 8) + 4 * v6) != a2)
  {
    if (v5 == ++v6) {
      goto LABEL_5;
    }
  }

  return v6;
}

uint64_t icu::CollationDataBuilder::addConditionalCE32( icu::CollationDataBuilder *this, UChar **a2, int a3, UErrorCode *a4)
{
  unsigned int v4 = (uint64_t *)*(unsigned int *)a4;
  int v6 = *((_DWORD *)this + 28);
  if (v6 >= 0x80000)
  {
    *a4 = U_BUFFER_OVERFLOW_ERROR;
    return 0xFFFFFFFFLL;
  }

  int v10 = (icu::CollationDataBuilder *)((char *)this + 104);
  uint64_t v11 = icu::UMemory::operator new(v4, (icu::UMemory *)0x60, (unint64_t)a2);
  uint64_t v12 = v11;
  if (v11)
  {
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)(v11 + 1), a2);
    *((_DWORD *)v12 + 18) = a3;
    *(_OWORD *)((char *)v12 + 76) = xmmword_180A32C50;
  }

  else if (*(int *)a4 <= 0)
  {
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }

  icu::UVector::adoptElement(v10, v12, a4);
  else {
    return v6;
  }
}

uint64_t icu::CollationDataBuilder::add( icu::CollationDataBuilder *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, const uint64_t *a4, uint64_t a5, UErrorCode *a6)
{
  int v10 = (*(uint64_t (**)(icu::CollationDataBuilder *, const uint64_t *, uint64_t, UErrorCode *))(*(void *)this + 32LL))( this,  a4,  a5,  a6);
  return icu::CollationDataBuilder::addCE32((uint64_t)this, a2, a3, v10, a6);
}

uint64_t icu::CollationDataBuilder::addCE32( uint64_t this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, int a4, UErrorCode *a5)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  if (*((unsigned __int16 *)a3 + 4) <= 0x1Fu)
  {
    UErrorCode v11 = U_ILLEGAL_ARGUMENT_ERROR;
    goto LABEL_7;
  }

  uint64_t v7 = this;
  this = *(void *)(this + 32);
  if (!this || (this = utrie2_isFrozen(this), (_DWORD)this))
  {
    UErrorCode v11 = U_INVALID_STATE_ERROR;
LABEL_7:
    *a5 = v11;
    return this;
  }

  uint64_t v12 = (icu::Collation *)icu::UnicodeString::char32At(v10, a3, 0);
  BOOL v13 = 1;
  else {
    int v14 = 2;
  }
  unsigned int v16 = utrie2_get32(*(uint64_t **)(v7 + 32), v12);
  if (*((unsigned __int16 *)a2 + 4) <= 0x1Fu)
  {
    unsigned int v17 = *((unsigned __int16 *)a3 + 4);
    int v18 = (__int16)v17;
    int v19 = v17 >> 5;
    if (v18 < 0) {
      int v19 = *((_DWORD *)a3 + 3);
    }
    BOOL v13 = v19 > v14;
  }

  if (!*(_BYTE *)(v7 + 617)) {
    goto LABEL_70;
  }
  NFDuint64_t Instance = icu::Normalizer2::getNFDInstance((icu::Normalizer2 *)a5, v15);
  memset((char *)v66 + 8, 0, 56);
  *(void *)&v66[0] = off_18971B688;
  WORD4(v66[0]) = 2;
  (*(void (**)(uint64_t, const icu::UnicodeString *, _OWORD *, UErrorCode *))(*(void *)NFDInstance + 24LL))( NFDInstance,  a3,  v66,  a5);
  unsigned int v21 = *((unsigned __int16 *)a3 + 4);
  if ((v21 & 1) != 0)
  {
    if ((BYTE8(v66[0]) & 1) != 0) {
      goto LABEL_27;
    }
    goto LABEL_38;
  }

  if ((v21 & 0x8000u) == 0) {
    int v22 = v21 >> 5;
  }
  else {
    int v22 = *((_DWORD *)a3 + 3);
  }
  if ((SWORD4(v66[0]) & 0x8000u) == 0) {
    int v23 = WORD4(v66[0]) >> 5;
  }
  else {
    int v23 = HIDWORD(v66[0]);
  }
  if ((BYTE8(v66[0]) & 1) != 0 || v22 != v23) {
    goto LABEL_39;
  }
  if (!icu::UnicodeString::doEquals(a3, (const icu::UnicodeString *)v66, v22))
  {
LABEL_38:
    LOWORD(v2sub_18086E18C((uint64_t)this, 1) = *((_WORD *)a3 + 4);
LABEL_39:
    if ((v21 & 0x8000) != 0)
    {
      if (*((_DWORD *)a3 + 3) != 2) {
        goto LABEL_67;
      }
    }

    else if ((v21 & 0xFFE0) != 0x40)
    {
      goto LABEL_67;
    }

    if ((v21 & 2) != 0) {
      uint64_t v29 = (char *)a3 + 10;
    }
    else {
      uint64_t v29 = (char *)*((void *)a3 + 3);
    }
    uint64_t v28 = *((unsigned __int16 *)v29 + 1);
    if ((v28 - 3955) <= 0xE && ((1 << (v28 - 115)) & 0x4005) != 0
      || (_DWORD)v12 == 64977 && (_DWORD)v28 == 44032)
    {
      return (uint64_t)icu::UnicodeString::~UnicodeString((void *)v28, (icu::UnicodeString *)v66);
    }

uint64_t icu::CollationDataBuilder::copyFromBaseCE32( icu::CollationDataBuilder *this, icu::Collation *a2, uint64_t a3, unsigned __int8 a4, UErrorCode *a5)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  if ((~(_DWORD)a3 & 0xC0) == 0)
  {
    unsigned int v7 = a2;
    int v9 = a4;
    while (1)
    {
      switch(v5 & 0xF)
      {
        case 1LL:
        case 2LL:
        case 4LL:
          return v5;
        case 5LL:
          return icu::CollationDataBuilder::encodeExpansion32( this,  (const int *)(*(void *)(*((void *)this + 2) + 8LL) + 4LL * (v5 >> 13)),  (v5 >> 8) & 0x1F,  a5);
        case 6LL:
          return icu::CollationDataBuilder::encodeExpansion( this,  (const uint64_t *)(*(void *)(*((void *)this + 2) + 16LL) + 8LL * (v5 >> 13)),  (v5 >> 8) & 0x1F,  a5);
        case 8LL:
          int v10 = (unsigned __int16 *)(*(void *)(*((void *)this + 2) + 24LL) + 2LL * (v5 >> 13));
          int v11 = v10[1];
          uint64_t v5 = v11 | (*v10 << 16);
          if (!v9) {
            goto LABEL_10;
          }
          *(void *)&__int128 v38 = 0LL;
          __int128 v39 = 0u;
          memset(v42, 0, sizeof(v42));
          __int128 v40 = 0u;
          __int128 v41 = 0u;
          *((void *)&v38 + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
          LOWORD(v39) = 2;
          *(_OWORD *)&v42[3] = xmmword_180A32C50;
          memset(v37, 0, sizeof(v37));
          icu::UnicodeString::UnicodeString((uint64_t)v37, 0);
          if ((v11 & 0xCF) == 0xC9)
          {
            unsigned int v15 = icu::CollationDataBuilder::copyContractionsFromBaseCE32(this, (uint64_t)v37, v7, v5, (uint64_t)&v38, a5);
          }

          else
          {
            uint64_t v5 = icu::CollationDataBuilder::copyFromBaseCE32(this, v7, v5, 1, a5);
            unsigned int v15 = icu::CollationDataBuilder::addConditionalCE32(this, v37, v5, a5);
            v42[6] = v15;
          }

          int v18 = (void *)*(unsigned int *)a5;
          if ((int)v18 > 0)
          {
            int v19 = 1;
            goto LABEL_38;
          }

          uint64_t v20 = icu::UVector::elementAt((icu::CollationDataBuilder *)((char *)this + 104), v15);
          uint64_t v36 = 0LL;
          *(_OWORD *)unsigned int v35 = 0u;
          __int128 v33 = 0u;
          memset(v34, 0, sizeof(v34));
          __int128 v31 = 0u;
          __int128 v32 = 0u;
          __int128 v30 = 0u;
          uint64_t v28 = (uint64_t)(v10 + 2);
          icu::UCharsTrie::Iterator::Iterator(&v30, &v28, 0LL, a5);
          uint64_t v27 = v28;
          while (1)
          {
            icu::UnicodeString::operator=(v37, (UChar **)&v32 + 1);
            if (SLOWORD(v37[1]) >= 0) {
              int v21 = LOWORD(v37[1]) >> 5;
            }
            else {
              int v21 = HIDWORD(v37[1]);
            }
            icu::UnicodeString::doReverse((icu::UnicodeString *)v37, 0, v21);
            int v22 = LOWORD(v37[1]) >> 5;
            if (SLOWORD(v37[1]) < 0) {
              LOWORD(v22) = WORD2(v37[1]);
            }
            __int16 v29 = v22;
            icu::UnicodeString::doReplace((uint64_t)v37, 0LL, 0LL, (uint64_t)&v29, 0, 1LL);
            uint64_t v5 = v35[3];
            if ((v35[3] & 0xCF) == 0xC9)
            {
              unsigned int v23 = icu::CollationDataBuilder::copyContractionsFromBaseCE32(this, (uint64_t)v37, v7, v35[3], v20, a5);
            }

            else
            {
              uint64_t v5 = icu::CollationDataBuilder::copyFromBaseCE32(this, v7, v35[3], 1, a5);
              unsigned int v23 = icu::CollationDataBuilder::addConditionalCE32(this, v37, v5, a5);
              *(_DWORD *)(v20 + 88) = v23;
            }

            uint64_t v20 = icu::UVector::elementAt((icu::CollationDataBuilder *)((char *)this + 104), v23);
            if (!icu::UCharsTrie::Iterator::next(v24, (icu::UCharsTrie::Iterator *)&v30, a5))
            {
LABEL_35:
              uint64_t v5 = (v42[6] << 13) | 0xC7u;
              icu::UnicodeSet::add((icu::CollationDataBuilder *)((char *)this + 144), v7);
              int v19 = 2;
              goto LABEL_37;
            }
          }

          int v19 = 1;
LABEL_37:
          icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)&v30);
LABEL_38:
          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)v37);
          icu::UnicodeString::~UnicodeString(v25, (icu::UnicodeString *)((char *)&v38 + 8));
          if (v19 != 1) {
            return v5;
          }
          return 0LL;
        case 9LL:
          if (v9)
          {
            *(void *)&__int128 v30 = 0LL;
            __int128 v31 = 0u;
            v34[0] = 0u;
            HIDWORD(v34[1]) = 0;
            __int128 v32 = 0u;
            __int128 v33 = 0u;
            *((void *)&v30 + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
            LOWORD(v3sub_18086E18C((uint64_t)this, 1) = 2;
            *(_OWORD *)((char *)v34 + 12) = xmmword_180A32C50;
            __int128 v40 = 0u;
            __int128 v41 = 0u;
            __int128 v38 = 0u;
            __int128 v39 = 0u;
            icu::UnicodeString::UnicodeString((uint64_t)&v38, 0);
            icu::CollationDataBuilder::copyContractionsFromBaseCE32(this, (uint64_t)&v38, v7, v5, (uint64_t)&v30, a5);
            uint64_t v5 = (DWORD2(v34[1]) << 13) | 0xC7u;
            icu::UnicodeSet::add((icu::CollationDataBuilder *)((char *)this + 144), v7);
            icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)&v38);
            icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)((char *)&v30 + 8));
            return v5;
          }

          uint64_t v12 = (unsigned __int16 *)(*(void *)(*((void *)this + 2) + 24LL) + 2LL * (v5 >> 13));
          uint64_t v5 = v12[1] | (*v12 << 16);
LABEL_10:
          int v9 = 0;
          if ((~(_DWORD)v5 & 0xC0) != 0) {
            return v5;
          }
          break;
        case 0xCLL:
          *a5 = U_UNSUPPORTED_ERROR;
          return v5;
        case 0xELL:
          return icu::Collation::getThreeBytePrimaryForOffsetData( a2,  *(void *)(*(void *)(*((void *)this + 2) + 16LL) + 8LL * (v5 >> 13))) | 0xC1;
        case 0xFLL:
          uint64_t v14 = icu::Collation::unassignedPrimaryFromCodePoint(a2);
          return icu::CollationDataBuilder::encodeOneCE( this,  (icu::CollationDataBuilder *)((v14 << 32) | 0x5000500),  a5);
        default:
          abort();
      }
    }
  }

  return v5;
}

uint64_t icu::CollationDataBuilder::encodeOneCEAsCE32(unint64_t this)
{
  else {
    unsigned int v1 = this | 0xC2;
  }
  if ((this & 0xFFFFFFFFFFLL) == 0x5000500) {
    unsigned int v2 = HIDWORD(this) | 0xC1;
  }
  else {
    unsigned int v2 = v1;
  }
  if ((this & 0xFFFF00FF00FFLL) != 0) {
    return v2;
  }
  else {
    return BYTE1(this) | WORD1(this) | HIDWORD(this);
  }
}

uint64_t icu::CollationDataBuilder::encodeOneCE( icu::CollationDataBuilder *this, icu::CollationDataBuilder *a2, UErrorCode *a3)
{
  uint64_t result = icu::CollationDataBuilder::encodeOneCEAsCE32((unint64_t)a2);
  if ((_DWORD)result == 1)
  {
    int v7 = icu::CollationDataBuilder::addCE(this, (uint64_t)a2, a3);
    if (*(int *)a3 <= 0)
    {
      if (v7 < 0x80000)
      {
        return (v7 << 13) | 0x1C6u;
      }

      else
      {
        uint64_t result = 0LL;
        *a3 = U_BUFFER_OVERFLOW_ERROR;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t icu::CollationDataBuilder::encodeCEs( icu::CollationDataBuilder *this, unint64_t *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3;
  if (a3 >= 0x20)
  {
    uint64_t v4 = 0LL;
    UErrorCode v6 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_8:
    *a4 = v6;
    return v4;
  }

  uint64_t v8 = *((void *)this + 4);
  if (!v8 || utrie2_isFrozen(v8))
  {
    uint64_t v4 = 0LL;
    UErrorCode v6 = U_INVALID_STATE_ERROR;
    goto LABEL_8;
  }

  if (!(_DWORD)v4) {
    return v4;
  }
  if ((_DWORD)v4 == 2)
  {
    if (!*((_BYTE *)this + 617))
    {
      unint64_t v11 = *a2;
      if ((*a2 & 0xFFFFFFFFFF00FFLL) == 0x5000000)
      {
        unint64_t v12 = a2[1];
        if ((v12 & 0xFFFFFFFF00FFFFFFLL) == 0x500)
        {
          if (HIDWORD(v11)) {
            return ((_DWORD)v11 << 8) & 0xFF0000 | HIDWORD(v11) | (v12 >> 16) | 0xC4;
          }
        }
      }
    }

uint64_t icu::CollationDataBuilder::encodeExpansion32( icu::CollationDataBuilder *this, const int *a2, int a3, UErrorCode *a4)
{
  int v7 = a2;
  uint64_t v9 = *((int *)this + 12);
  if ((int)v9 >= a3)
  {
    unint64_t v10 = 0LL;
    uint64_t v11 = 1LL;
    do
    {
      int v12 = 0;
      if (*a2 == v12)
      {
        if (v10 >> 19) {
          goto LABEL_5;
        }
        uint64_t v13 = a3 - 1LL;
        int v14 = a2 + 1;
        uint64_t v15 = v11;
        if (a3 == 1)
        {
LABEL_21:
          int v17 = (a3 << 8) | ((_DWORD)v10 << 13);
          return v17 | 0xC5u;
        }

        while (1)
        {
          int v16 = 0;
          if (v16 != *v14) {
            break;
          }
          ++v15;
          ++v14;
          if (!--v13) {
            goto LABEL_21;
          }
        }
      }

      ++v10;
      ++v11;
    }

    while (v10 != (_DWORD)v9 - a3 + 1);
  }

  if ((int)v9 >= 0x80000)
  {
LABEL_5:
    uint64_t result = 0LL;
    *a4 = U_BUFFER_OVERFLOW_ERROR;
    return result;
  }

  if (a3 >= 1)
  {
    uint64_t v18 = a3;
    while (1)
    {
      int v20 = *v7++;
      int v19 = v20;
      int v21 = *((_DWORD *)this + 12);
      if (v21 >= -1 && *((_DWORD *)this + 13) > v21) {
        goto LABEL_28;
      }
LABEL_29:
      if (!--v18) {
        goto LABEL_30;
      }
    }

    int v21 = *((_DWORD *)this + 12);
LABEL_28:
    *(_DWORD *)(*((void *)this + 8) + 4LL * v2sub_18086E18C((uint64_t)this, 1) = v19;
    ++*((_DWORD *)this + 12);
    goto LABEL_29;
  }

uint64_t icu::CollationDataBuilder::encodeExpansion( icu::CollationDataBuilder *this, const uint64_t *a2, int a3, UErrorCode *a4)
{
  int v7 = a2;
  uint64_t v9 = *((int *)this + 20);
  if ((int)v9 >= a3)
  {
    unint64_t v10 = 0LL;
    uint64_t v11 = 1LL;
    do
    {
      else {
        uint64_t v12 = *(void *)(*((void *)this + 12) + 8 * v10);
      }
      if (*a2 == v12)
      {
        if (v10 >> 19) {
          goto LABEL_5;
        }
        uint64_t v13 = a3 - 1LL;
        int v14 = a2 + 1;
        uint64_t v15 = v11;
        if (a3 == 1)
        {
LABEL_21:
          int v17 = (a3 << 8) | ((_DWORD)v10 << 13);
          return v17 | 0xC6u;
        }

        while (1)
        {
          uint64_t v16 = (int)v9 <= (int)v15 ? 0LL : *(void *)(*((void *)this + 12) + 8 * v15);
          if (v16 != *v14) {
            break;
          }
          ++v15;
          ++v14;
          if (!--v13) {
            goto LABEL_21;
          }
        }
      }

      ++v10;
      ++v11;
    }

    while (v10 != (_DWORD)v9 - a3 + 1);
  }

  if ((int)v9 >= 0x80000)
  {
LABEL_5:
    uint64_t result = 0LL;
    *a4 = U_BUFFER_OVERFLOW_ERROR;
    return result;
  }

  if (a3 >= 1)
  {
    uint64_t v18 = a3;
    while (1)
    {
      uint64_t v20 = *v7++;
      uint64_t v19 = v20;
      int v21 = *((_DWORD *)this + 20);
      int v22 = v21 + 1;
      if (v21 >= -1 && *((_DWORD *)this + 21) > v21) {
        goto LABEL_28;
      }
LABEL_29:
      if (!--v18) {
        goto LABEL_30;
      }
    }

    int v21 = *((_DWORD *)this + 20);
    int v22 = v21 + 1;
LABEL_28:
    *(void *)(*((void *)this + 12) + 8LL * v2sub_18086E18C((uint64_t)this, 1) = v19;
    *((_DWORD *)this + 20) = v22;
    goto LABEL_29;
  }

uint64_t icu::CollationDataBuilder::copyContractionsFromBaseCE32( icu::CollationDataBuilder *this, uint64_t a2, int a3, unsigned int a4, uint64_t a5, UErrorCode *a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v12 = (unsigned __int16 *)(*(void *)(*((void *)this + 2) + 24LL) + 2LL * (a4 >> 13));
  if ((a4 & 0x100) != 0)
  {
    uint64_t v6 = 0xFFFFFFFFLL;
  }

  else
  {
    int v13 = icu::CollationDataBuilder::copyFromBaseCE32(this, a3, v12[1] | (*v12 << 16), 1, a6);
    uint64_t v14 = icu::CollationDataBuilder::addConditionalCE32(this, (UChar **)a2, v13, a6);
    *(_DWORD *)(a5 + 88) = v14;
    uint64_t v6 = v14;
    a5 = icu::UVector::elementAt((icu::CollationDataBuilder *)((char *)this + 104), v14);
  }

  unsigned int v15 = *(unsigned __int16 *)(a2 + 8);
  int v16 = (__int16)v15;
  int v17 = v15 >> 5;
  if (v16 >= 0) {
    int v18 = v17;
  }
  else {
    int v18 = *(_DWORD *)(a2 + 12);
  }
  uint64_t v33 = 0LL;
  __int128 v31 = 0u;
  *(_OWORD *)__int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v28 = 0u;
  memset(v27, 0, sizeof(v27));
  uint64_t v26 = (uint64_t)(v12 + 2);
  icu::UCharsTrie::Iterator::Iterator(v27, &v26, 0LL, a6);
  uint64_t v25 = v26;
  if (icu::UCharsTrie::Iterator::next(&v25, (icu::UCharsTrie::Iterator *)v27, a6))
  {
    while (1)
    {
      uint64_t v19 = (v29 & 0x8000u) == 0LL ? (unsigned __int16)v29 >> 5 : DWORD1(v29);
      icu::UnicodeString::doAppend(a2, (const icu::UnicodeString *)((char *)&v28 + 8), 0, v19);
      int v20 = icu::CollationDataBuilder::copyFromBaseCE32(this, a3, v32[3], 1, a6);
      uint64_t v21 = icu::CollationDataBuilder::addConditionalCE32(this, (UChar **)a2, v20, a6);
      *(_DWORD *)(a5 + 88) = v21;
      uint64_t v6 = v21;
      a5 = icu::UVector::elementAt((icu::CollationDataBuilder *)((char *)this + 104), v21);
      int v22 = (uint64_t *)*(unsigned __int16 *)(a2 + 8);
      if (v18 || (v22 & 1) == 0)
      {
        else {
          unsigned int v23 = *(_DWORD *)(a2 + 12);
        }
        if (v23 > v18)
        {
          if (v18 > 1023)
          {
            int v22 = (uint64_t *)(v22 | 0xFFE0);
            *(_WORD *)(a2 + 8) = (_WORD)v22;
            *(_DWORD *)(a2 + 12) = v18;
          }

          else
          {
            int v22 = (uint64_t *)(v22 & 0x1F | (32 * v18));
            *(_WORD *)(a2 + 8) = (_WORD)v22;
          }
        }
      }

      else
      {
        icu::UnicodeString::unBogus(a2);
      }
    }

    uint64_t v6 = 0LL;
  }

uint64_t icu::CollationDataBuilder::copyFrom( uint64_t this, const icu::CollationDataBuilder *a2, const icu::CollationDataBuilder::CEModifier *a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    uint64_t v5 = this;
    this = *(void *)(this + 32);
    if (this && (this = utrie2_isFrozen(this), !(_DWORD)this))
    {
      __int128 v24 = 0u;
      __int128 v23 = 0u;
      __int128 v22 = 0u;
      __int128 v21 = 0u;
      __int128 v20 = 0u;
      __int128 v19 = 0u;
      __int128 v18 = 0u;
      __int128 v17 = 0u;
      __int128 v16 = 0u;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      __int128 v10 = 0u;
      __int128 v11 = 0u;
      __int128 v9 = 0u;
      v8[0] = a2;
      v8[1] = v5;
      void v8[2] = a3;
      SDWORD2(v24) = *a4;
      this = utrie2_enum( *((void *)a2 + 4),  0LL,  (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))sub_1808AB244,  (uint64_t)v8);
      *a4 = SDWORD2(v24);
      *(_BYTE *)(v5 + 616) |= *((_BYTE *)a2 + 616);
    }

    else
    {
      *a4 = U_INVALID_STATE_ERROR;
    }
  }

  return this;
}

BOOL sub_1808AB244(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  BOOL result = 1LL;
  if ((_DWORD)a4 != -1 && (_DWORD)a4 != 192) {
    return sub_1808AC318(a1, a2, a3, a4);
  }
  return result;
}

void icu::CollationDataBuilder::optimize( icu::CollationDataBuilder *this, const icu::UnicodeSet *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0 && !icu::UnicodeSet::isEmpty(a2))
  {
    memset(v11, 0, sizeof(v11));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v11, a2);
    while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v11))
    {
      uint64_t v6 = (icu::Collation *)DWORD2(v11[0]);
      if ((DWORD2(v11[0]) & 0x80000000) != 0) {
        break;
      }
      if (utrie2_get32(*((uint64_t **)this + 4), DWORD2(v11[0])) == 192)
      {
        int v7 = (uint64_t *)*((void *)this + 2);
        uint64_t v8 = sub_1808A22C4(v7, v6);
        uint64_t FinalCE32 = icu::CollationData::getFinalCE32((icu::CollationData *)v7, v8);
        int v10 = icu::CollationDataBuilder::copyFromBaseCE32(this, v6, FinalCE32, 1u, a3);
        utrie2_set32(*((void *)this + 4), v6, v10, (int *)a3);
      }
    }

    *((_BYTE *)this + 616) = 1;
    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v11);
  }

void icu::CollationDataBuilder::suppressContractions( uint64_t **this, const icu::UnicodeSet *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0 && !icu::UnicodeSet::isEmpty(a2))
  {
    memset(v13, 0, sizeof(v13));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v13, a2);
    while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v13))
    {
      uint64_t v6 = (icu::Collation *)DWORD2(v13[0]);
      if ((DWORD2(v13[0]) & 0x80000000) != 0) {
        break;
      }
      unsigned int v7 = utrie2_get32(this[4], DWORD2(v13[0]));
      if (v7 == 192)
      {
        uint64_t v8 = this[2];
        uint64_t v9 = sub_1808A22C4(v8, v6);
        uint64_t FinalCE32 = icu::CollationData::getFinalCE32((icu::CollationData *)v8, v9);
        if ((FinalCE32 & 0xCE) == 0xC8)
        {
          int v11 = icu::CollationDataBuilder::copyFromBaseCE32((icu::CollationDataBuilder *)this, v6, FinalCE32, 0, a3);
          utrie2_set32((uint64_t)this[4], v6, v11, (int *)a3);
        }
      }

      else if ((v7 & 0xCF) == 0xC7)
      {
        uint64_t v12 = icu::UVector::elementAt((icu::UVector *)(this + 13), v7 >> 13);
        utrie2_set32((uint64_t)this[4], v6, *(_DWORD *)(v12 + 72), (int *)a3);
        icu::UnicodeSet::remove((icu::UnicodeSet *)(this + 18), v6);
      }
    }

    *((_BYTE *)this + 616) = 1;
    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v13);
  }

BOOL icu::CollationDataBuilder::getJamoCE32s( icu::CollationDataBuilder *this, unsigned int *a2, UErrorCode *a3)
{
  unint64_t v6 = 0LL;
  char v7 = 0;
  char v8 = *((void *)this + 2) == 0LL;
  __int128 v23 = (char *)this + 96;
  while (2)
  {
    if (v6 >= 0x28) {
      LODWORD(v9) = 4480;
    }
    else {
      LODWORD(v9) = 4430;
    }
    if (v6 >= 0x13) {
      uint64_t v9 = v9;
    }
    else {
      uint64_t v9 = 4352LL;
    }
    int v10 = (icu::Collation *)(v6 + v9);
    unsigned int v11 = utrie2_get32(*((uint64_t **)this + 4), (int)v6 + (int)v9);
    unsigned int v12 = v11;
    BOOL v13 = v11 != -1 && v11 != 192;
    if (v11 == 192) {
      unsigned int v11 = sub_1808A22C4(*((uint64_t **)this + 2), v10);
    }
    switch(v11 & 0xF)
    {
      case 0u:
      case 3u:
      case 7u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
        BOOL result = 0LL;
        *a3 = U_INTERNAL_PROGRAM_ERROR;
        return result;
      case 5u:
      case 6u:
      case 8u:
      case 9u:
        if (v12 == 192) {
          char v7 = 1;
        }
        unsigned int v11 = v12;
        goto LABEL_19;
      case 0xEu:
        unsigned int v14 = v11 >> 13;
        if (v12 == 192)
        {
          __int128 v15 = (void *)(*((void *)this + 2) + 16LL);
LABEL_25:
          unint64_t v16 = *(void *)(*v15 + 8LL * v14);
          goto LABEL_27;
        }

        __int128 v15 = v23;
        unint64_t v16 = 0LL;
LABEL_27:
        unsigned int v11 = icu::Collation::getThreeBytePrimaryForOffsetData(v10, v16) | 0xC1;
LABEL_19:
        v8 |= v13;
        a2[v6++] = v11;
        if (v6 != 67) {
          continue;
        }
        if (v8) {
          BOOL v17 = v7 == 0;
        }
        else {
          BOOL v17 = 1;
        }
        if (!v17)
        {
          for (unint64_t i = 0LL; i != 67; ++i)
          {
            if (a2[i] == 192)
            {
              if (i >= 0x28) {
                int v19 = 4480;
              }
              else {
                int v19 = 4430;
              }
              if (i < 0x13) {
                int v19 = 4352;
              }
              __int128 v20 = (icu::Collation *)(i + v19);
              uint64_t v21 = sub_1808A22C4(*((uint64_t **)this + 2), (int)i + v19);
              a2[i] = icu::CollationDataBuilder::copyFromBaseCE32(this, v20, v21, 1u, a3);
            }
          }
        }

        if (v8) {
          BOOL v22 = *a3 < U_ILLEGAL_ARGUMENT_ERROR;
        }
        else {
          BOOL v22 = 0;
        }
        BOOL result = v22;
        break;
      case 0xFu:
        unsigned int v11 = 192;
        char v7 = 1;
        goto LABEL_19;
      default:
        goto LABEL_19;
    }

    return result;
  }

void *icu::CollationDataBuilder::setDigitTags(uint64_t **this, UErrorCode *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v16 = 0LL;
  memset(v15, 0, sizeof(v15));
  unsigned int v14 = L"[:Nd:]";
  icu::UnicodeString::UnicodeString(v17, 1LL, &v14);
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v15, (const icu::UnicodeString *)v17, a2);
  uint64_t v5 = (icu::UnicodeSetIterator *)icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v17);
  unint64_t v6 = (void *)*(unsigned int *)a2;
  memset(v17, 0, sizeof(v17));
  char v7 = icu::UnicodeSetIterator::UnicodeSetIterator(v5, (const icu::UnicodeSet *)v15);
  while (1)
  {
    unsigned int v8 = DWORD2(v17[0]);
    int v9 = utrie2_get32(this[4], DWORD2(v17[0]));
    if (v9 == -1 || v9 == 192) {
      goto LABEL_8;
    }
    int v10 = icu::CollationDataBuilder::addCE32((icu::CollationDataBuilder *)this, v9, a2);
    int v11 = v10;
    if (v10 >= 0x80000) {
      break;
    }
    int32_t v12 = u_charDigitValue(v8);
    utrie2_set32((uint64_t)this[4], v8, (v11 << 13) | (v12 << 8) | 0xCA, (int *)a2);
LABEL_8:
  }

  *a2 = U_BUFFER_OVERFLOW_ERROR;
LABEL_11:
  icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v17);
  return icu::UnicodeSet::~UnicodeSet(v6, (icu::UnicodeSet *)v15);
}

uint64_t icu::CollationDataBuilder::setLeadSurrogates(icu::CollationDataBuilder *this, UErrorCode *a2)
{
  for (int i = 0; i != 1024; ++i)
  {
    int v6 = -1;
    utrie2_enumForLeadSurrogate( *((void *)this + 4),  i + 55296,  0LL,  (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))sub_1808AB8FC,  (uint64_t)&v6);
    uint64_t result = utrie2_set32ForLeadSurrogateCodeUnit(*((void *)this + 4), i + 55296, v6 | 0xCDu, (int *)a2);
  }

  return result;
}

uint64_t sub_1808AB8FC(int *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == -1)
  {
    int v4 = 0;
  }

  else
  {
    if (a4 != 192) {
      goto LABEL_8;
    }
    int v4 = 256;
  }

  if (*a1 < 0)
  {
    uint64_t v5 = 1LL;
    goto LABEL_10;
  }

  if (*a1 != v4)
  {
LABEL_8:
    uint64_t v5 = 0LL;
    int v4 = 512;
LABEL_10:
    *a1 = v4;
    return v5;
  }

  return 1LL;
}

uint64_t icu::CollationDataBuilder::build( icu::CollationDataBuilder *this, icu::CollationData *a2, UErrorCode *a3)
{
  uint64_t v6 = *((void *)this + 2);
  if (v6)
  {
    *((_DWORD *)a2 + 14) = *(_DWORD *)(v6 + 56);
    *((void *)a2 + 9) = *(void *)(v6 + 72);
    *((_DWORD *)a2 + 25) = *(_DWORD *)(v6 + 100);
    *(_OWORD *)((char *)a2 + 104) = *(_OWORD *)(v6 + 104);
    *((_DWORD *)a2 + 30) = *(_DWORD *)(v6 + 120);
  }

  return icu::CollationDataBuilder::buildFastLatinTable((uint64_t)this, a2, a3);
}

void icu::CollationDataBuilder::buildMappings( icu::CollationDataBuilder *this, icu::CollationData *a2, UErrorCode *a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *((void *)this + 4);
  if (!v5 || utrie2_isFrozen(v5))
  {
    *a3 = U_INVALID_STATE_ERROR;
    return;
  }

  icu::CollationDataBuilder::buildContexts(this, a3);
  __int128 v38 = 0u;
  memset(v39, 0, 188);
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  *(_OWORD *)uint64_t v34 = 0u;
  __int128 v35 = 0u;
  if (!icu::CollationDataBuilder::getJamoCE32s(this, v34, a3))
  {
    unsigned int v12 = 44032;
    do
    {
      unsigned int v13 = sub_1808A22C4(*((uint64_t **)this + 2), v12);
      utrie2_setRange32(*((void *)this + 4), v12, v12 + 587, v13, 1, (int *)a3);
      BOOL v14 = v12 >= 0xD558;
      v12 += 588;
    }

    while (!v14);
    unsigned int v15 = -1;
    goto LABEL_33;
  }

  uint64_t v7 = 0LL;
  int v8 = *((_DWORD *)this + 12);
  int v9 = v8;
  while (1)
  {
    unsigned int v10 = v34[v7];
    if (v9 < -1 || *((_DWORD *)this + 13) <= v9)
    {
      int v9 = *((_DWORD *)this + 12);
    }

    *(_DWORD *)(*((void *)this + 8) + 4LL * v9) = v10;
    ++*((_DWORD *)this + 12);
LABEL_13:
    if (v7 == 66) {
      break;
    }
    int v9 = *((_DWORD *)this + 12);
    ++v7;
  }

  unsigned int v33 = v8;
  if ((~HIDWORD(v38) & 0xC0) != 0)
  {
    uint64_t v16 = 0LL;
    do
    {
      uint64_t v17 = v16;
      if (v16 == 47) {
        break;
      }
      int v18 = *((_DWORD *)v39 + v16++);
    }

    while ((~v18 & 0xC0) != 0);
    BOOL v11 = (unint64_t)(v17 + 19) > 0x41;
  }

  else
  {
    BOOL v11 = 0;
  }

  uint64_t v19 = 0LL;
  unsigned int v20 = 44032;
  do
  {
    if (v11)
    {
      if ((~v34[v19] & 0xC0) != 0) {
        unsigned int v21 = 460;
      }
      else {
        unsigned int v21 = 204;
      }
    }

    else
    {
      unsigned int v21 = 204;
    }

    utrie2_setRange32(*((void *)this + 4), v20, v20 + 587, v21, 1, (int *)a3);
    ++v19;
    v20 += 588;
  }

  while (v19 != 19);
  unsigned int v15 = v33;
LABEL_33:
  icu::CollationDataBuilder::setDigitTags((uint64_t **)this, a3);
  icu::CollationDataBuilder::setLeadSurrogates(this, a3);
  if (!*((_BYTE *)this + 617))
  {
    int v22 = utrie2_get32(*((uint64_t **)this + 4), 0);
    icu::UVector32::setElementAt((uint64_t)this + 40, v22, 0);
    utrie2_set32(*((void *)this + 4), 0, 203, (int *)a3);
  }

  utrie2_freeze(*((void *)this + 4), 1u, (int *)a3);
  if (*(int *)a3 <= 0)
  {
    int v23 = 0x10000;
    unsigned int v24 = 55296;
    do
    {
      ++v24;
      BOOL v25 = v23 == 1113088;
      v23 += 1024;
    }

    while (!v25);
    icu::UnicodeSet::freeze((icu::CollationDataBuilder *)((char *)this + 416));
    *(void *)a2 = *((void *)this + 4);
    uint64_t v26 = *((void *)this + 8);
    *((void *)a2 + sub_18086E18C((uint64_t)this, 1) = v26;
    *((void *)a2 + 2) = *((void *)this + 12);
    __int16 v27 = *((_WORD *)this + 176);
    if ((v27 & 0x11) != 0)
    {
      __int128 v28 = 0LL;
    }

    else if ((v27 & 2) != 0)
    {
      __int128 v28 = (char *)this + 354;
    }

    else
    {
      __int128 v28 = (char *)*((void *)this + 46);
    }

    *((void *)a2 + 3) = v28;
    *((_DWORD *)a2 + 15) = *((_DWORD *)this + 12);
    *((_DWORD *)a2 + 16) = *((_DWORD *)this + 20);
    unsigned int v29 = *((unsigned __int16 *)this + 176);
    if ((v29 & 0x8000) != 0) {
      unsigned int v30 = *((_DWORD *)this + 89);
    }
    else {
      unsigned int v30 = v29 >> 5;
    }
    *((_DWORD *)a2 + 17) = v30;
    uint64_t v31 = *((void *)this + 2);
    *((void *)a2 + 4) = v31;
    if ((v15 & 0x80000000) != 0) {
      uint64_t v32 = *(void *)(v31 + 40);
    }
    else {
      uint64_t v32 = v26 + 4LL * v15;
    }
    *((void *)a2 + 5) = v32;
    *((void *)a2 + 10) = (char *)this + 416;
  }

uint64_t icu::CollationDataBuilder::buildFastLatinTable(uint64_t this, icu::CollationData *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v3 = this;
    int v4 = (uint64_t *)*(unsigned __int8 *)(this + 618);
    if (*(_BYTE *)(this + 618))
    {
      uint64_t v7 = *(void *)(this + 624);
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
      }
      this = (uint64_t)icu::UMemory::operator new(v4, (icu::UMemory *)0x1CD0, (unint64_t)a2);
      if (this)
      {
        int v8 = (icu::CollationFastLatinBuilder *)icu::CollationFastLatinBuilder::CollationFastLatinBuilder( (icu::CollationFastLatinBuilder *)this,  a3);
        *(void *)(v3 + 624) = v8;
        this = icu::CollationFastLatinBuilder::forData(v8, a2, a3);
        uint64_t v9 = *(void *)(v3 + 624);
        if ((_DWORD)this)
        {
          unsigned int v10 = *(unsigned __int16 *)(v9 + 7312);
          if ((v10 & 0x11) != 0)
          {
            BOOL v11 = 0LL;
          }

          else if ((v10 & 2) != 0)
          {
            BOOL v11 = (const void *)(v9 + 7314);
          }

          else
          {
            BOOL v11 = *(const void **)(v9 + 7328);
          }

          if ((v10 & 0x8000) != 0) {
            unsigned int v12 = *(_DWORD *)(v9 + 7316);
          }
          else {
            unsigned int v12 = v10 >> 5;
          }
          uint64_t v13 = *(void *)(v3 + 16);
          if (v13 && v12 == *(_DWORD *)(v13 + 96))
          {
            this = memcmp(v11, *(const void **)(v13 + 88), (int)(2 * v12));
            if (!(_DWORD)this)
            {
              this = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
              *(void *)(v3 + 624) = 0LL;
              BOOL v11 = *(const void **)(*(void *)(v3 + 16) + 88LL);
            }
          }

          *((void *)a2 + 1sub_18086E18C((uint64_t)this, 1) = v11;
          *((_DWORD *)a2 + 24) = v12;
        }

        else
        {
          if (v9) {
            this = (*(uint64_t (**)(void))(*(void *)v9 + 8LL))(*(void *)(v3 + 624));
          }
          *(void *)(v3 + 624) = 0LL;
        }
      }

      else
      {
        *(void *)(v3 + 624) = 0LL;
        *a3 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }

  return this;
}

void icu::CollationDataBuilder::buildContexts(icu::CollationDataBuilder *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    if ((*((_WORD *)this + 176) & 1) != 0) {
      __int16 v4 = 2;
    }
    else {
      __int16 v4 = *((_WORD *)this + 176) & 0x1F;
    }
    *((_WORD *)this + 176) = v4;
    ++*((_DWORD *)this + 102);
    memset(v9, 0, sizeof(v9));
    icu::UnicodeSetIterator::UnicodeSetIterator( (icu::UnicodeSetIterator *)v9,  (icu::CollationDataBuilder *)((char *)this + 144));
    if (*(int *)a2 <= 0)
    {
      while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v9))
      {
        unsigned int v5 = DWORD2(v9[0]);
        unsigned int v6 = utrie2_get32(*((uint64_t **)this + 4), DWORD2(v9[0]));
        if ((v6 & 0xCF) != 0xC7)
        {
          *a2 = U_INTERNAL_PROGRAM_ERROR;
          break;
        }

        uint64_t v7 = icu::UVector::elementAt((icu::CollationDataBuilder *)((char *)this + 104), v6 >> 13);
        int v8 = icu::CollationDataBuilder::buildContext((uint64_t)this, v7, a2);
        utrie2_set32(*((void *)this + 4), v5, v8, (int *)a2);
      }
    }

    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v9);
  }

uint64_t icu::CollationDataBuilder::addContextTrie( icu::CollationDataBuilder *this, int a2, icu::UCharsTrieBuilder *a3, UErrorCode *a4)
{
  __int16 v6 = a2;
  uint64_t v33 = *MEMORY[0x1895F89C0];
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  uint64_t v32 = 0LL;
  __int128 v31 = 0u;
  __int128 v28 = off_18971B688;
  LOWORD(v29) = 2;
  LOWORD(v23) = HIWORD(a2);
  uint64_t v8 = icu::UnicodeString::doAppend((uint64_t)&v28, (uint64_t)&v23, 0, 1LL);
  LOWORD(v23) = v6;
  icu::UnicodeString::doAppend(v8, (uint64_t)&v23, 0, 1LL);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  uint64_t v27 = 0LL;
  __int128 v26 = 0u;
  int v23 = off_18971B688;
  LOWORD(v24) = 2;
  uint64_t v9 = icu::UCharsTrieBuilder::buildUnicodeString((uint64_t)a3, 1LL, (icu::UnicodeString *)&v23, a4);
  unsigned int v10 = *((unsigned __int16 *)v9 + 4);
  int v11 = (__int16)v10;
  unsigned int v12 = v10 >> 5;
  if (v11 >= 0) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = *((unsigned int *)v9 + 3);
  }
  icu::UnicodeString::doAppend((uint64_t)&v28, v9, 0, v13);
  BOOL v14 = (void *)*(unsigned int *)a4;
  if ((int)v14 > 0)
  {
    uint64_t v15 = 0xFFFFFFFFLL;
    goto LABEL_26;
  }

  if ((v29 & 0x8000u) == 0LL) {
    int32_t v16 = (unsigned __int16)v29 >> 5;
  }
  else {
    int32_t v16 = DWORD1(v29);
  }
  int v17 = *((__int16 *)this + 176);
  if (v17 < 0)
  {
    int32_t v18 = *((_DWORD *)this + 89);
    if ((v29 & 1) != 0)
    {
LABEL_19:
      if ((v17 & 0x8000) != 0) {
        uint64_t v15 = *((unsigned int *)this + 89);
      }
      else {
        uint64_t v15 = (unsigned __int16)v17 >> 5;
      }
      if ((v29 & 0x8000u) == 0LL) {
        uint64_t v20 = (unsigned __int16)v29 >> 5;
      }
      else {
        uint64_t v20 = DWORD1(v29);
      }
      icu::UnicodeString::doAppend((uint64_t)this + 344, (const icu::UnicodeString *)&v28, 0, v20);
      goto LABEL_26;
    }
  }

  else
  {
    int32_t v18 = *((unsigned __int16 *)this + 176) >> 5;
    if ((v29 & 1) != 0) {
      goto LABEL_19;
    }
  }

  if (v16 < 1) {
    goto LABEL_19;
  }
  if ((v29 & 2) != 0) {
    uint64_t v19 = (char *)&v29 + 2;
  }
  else {
    uint64_t v19 = (char *)v30;
  }
  uint64_t v15 = icu::UnicodeString::indexOf((uint64_t)this + 344, (uint64_t)v19, 0, v16, 0, v18);
  if ((v15 & 0x80000000) != 0)
  {
    LOWORD(v17) = *((_WORD *)this + 176);
    goto LABEL_19;
  }

uint64_t *icu::CollationDataBuilder::getCEs@<X0>( icu::CollationDataBuilder *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  return icu::CollationDataBuilder::getCEs(this, a2, a3, 0, a4, a5);
}

uint64_t *icu::CollationDataBuilder::getCEs@<X0>( icu::CollationDataBuilder *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X3>, int a4@<W2>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  int v11 = (icu::CollationIterator *)*((void *)this + 79);
  if (v11) {
    return (uint64_t *)sub_1808A8894(v11, (uint64_t)a2, a4, (uint64_t)a3, a5);
  }
  uint64_t result = icu::UMemory::operator new(a6, (icu::UMemory *)0x340, (unint64_t)a2);
  if (result)
  {
    int v11 = (icu::CollationIterator *)sub_1808A873C((uint64_t)result, (uint64_t)this);
    *((void *)this + 79) = v11;
    return (uint64_t *)sub_1808A8894(v11, (uint64_t)a2, a4, (uint64_t)a3, a5);
  }

  *((void *)this + 79) = 0LL;
  return result;
}

uint64_t *icu::CollationDataBuilder::getCEs( icu::CollationDataBuilder *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, uint64_t *a4, uint64_t a5)
{
  int v17 = (uint64_t *)*MEMORY[0x1895F89C0];
  unsigned int v8 = *((unsigned __int16 *)a2 + 4);
  int v9 = (__int16)v8;
  int v10 = v8 >> 5;
  if (v9 >= 0) {
    int v11 = v10;
  }
  else {
    int v11 = *((_DWORD *)a2 + 3);
  }
  if (!v11) {
    return icu::CollationDataBuilder::getCEs(this, a3, a4, 0, a5, v17);
  }
  icu::operator+((uint64_t)a2, (uint64_t)a3, (uint64_t)v16);
  int CEs = icu::CollationDataBuilder::getCEs(this, (const icu::UnicodeString *)v16, a4, v11, a5, v12);
  icu::UnicodeString::~UnicodeString(v14, (icu::UnicodeString *)v16);
  return CEs;
}

BOOL sub_1808AC318(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unsigned int v7 = sub_1808AC3AC(a1, a4);
  char v8 = v7;
  utrie2_setRange32(*(void *)(*(void *)(a1 + 8) + 32LL), a2, a3, v7, 1, (int *)(a1 + 272));
  if ((v8 & 0xCF) == 0xC7) {
    icu::UnicodeSet::add((icu::UnicodeSet *)(*(void *)(a1 + 8) + 144LL), a2, a3);
  }
  return *(_DWORD *)(a1 + 272) < 1;
}

uint64_t sub_1808AC3AC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if ((~(_DWORD)a2 & 0xC0) != 0)
  {
    int32_t v18 = (icu::CollationDataBuilder *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 24LL))( *(void *)(a1 + 16),  a2);
    if (v18 != (icu::CollationDataBuilder *)0x101000100LL) {
      return icu::CollationDataBuilder::encodeOneCE( *(icu::CollationDataBuilder **)(a1 + 8),  v18,  (UErrorCode *)(a1 + 272));
    }
    return v2;
  }

  int v4 = a2 & 0xF;
  if (v4 == 7)
  {
    uint64_t v19 = icu::UVector::elementAt((icu::UVector *)(*(void *)a1 + 104LL), a2 >> 13);
    uint64_t v20 = *(icu::CollationDataBuilder **)(a1 + 8);
    int v21 = sub_1808AC3AC(a1, *(unsigned int *)(v19 + 72));
    unsigned int v22 = icu::CollationDataBuilder::addConditionalCE32(v20, (UChar **)(v19 + 8), v21, (UErrorCode *)(a1 + 272));
    uint64_t v2 = (v22 << 13) | 0xC7;
    unsigned int v23 = *(_DWORD *)(v19 + 88);
    if ((v23 & 0x80000000) != 0) {
      return v2;
    }
    unsigned int v24 = v22;
    while (1)
    {
      uint64_t v25 = icu::UVector::elementAt((icu::UVector *)(*(void *)a1 + 104LL), v23);
      uint64_t v26 = icu::UVector::elementAt((icu::UVector *)(*(void *)(a1 + 8) + 104LL), v24);
      uint64_t v27 = *(icu::CollationDataBuilder **)(a1 + 8);
      int v28 = sub_1808AC3AC(a1, *(unsigned int *)(v25 + 72));
      unsigned int v24 = icu::CollationDataBuilder::addConditionalCE32(v27, (UChar **)(v25 + 8), v28, (UErrorCode *)(a1 + 272));
      unsigned int v29 = *(unsigned __int16 *)(v25 + 16);
      if ((v29 & 0x8000) != 0)
      {
        if (*(_DWORD *)(v25 + 20))
        {
LABEL_35:
          if ((v29 & 2) != 0) {
            __int128 v30 = (unsigned __int16 *)(v25 + 18);
          }
          else {
            __int128 v30 = *(unsigned __int16 **)(v25 + 32);
          }
          int v31 = *v30;
          goto LABEL_41;
        }
      }

      else if (v29 >> 5)
      {
        goto LABEL_35;
      }

      int v31 = 0xFFFF;
LABEL_41:
      uint64_t v32 = (icu::UnicodeSet *)(*(void *)(a1 + 8) + 416LL);
      icu::UnicodeString::tempSubString((icu::UnicodeString *)(v25 + 8), v31 + 1, 0x7FFFFFFF, (icu::UnicodeString *)v41);
      icu::UnicodeSet::addAll(v32, (const icu::UnicodeString *)v41);
      icu::UnicodeString::~UnicodeString(v33, (icu::UnicodeString *)v41);
      *(_DWORD *)(v26 + 88) = v24;
      unsigned int v23 = *(_DWORD *)(v25 + 88);
      if ((v23 & 0x80000000) != 0) {
        return v2;
      }
    }
  }

  if (v4 == 6)
  {
    uint64_t v34 = (const uint64_t *)(*(void *)(*(void *)a1 + 96LL) + 8LL * (a2 >> 13));
    uint64_t v6 = (a2 >> 8) & 0x1F;
    if (!(_DWORD)v6) {
      return icu::CollationDataBuilder::encodeExpansion( *(icu::CollationDataBuilder **)(a1 + 8),  v34,  v6,  (UErrorCode *)(a1 + 272));
    }
    uint64_t v35 = 0LL;
    int v36 = 0;
    while (1)
    {
      uint64_t v37 = v34[v35];
      uint64_t v38 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 32LL))(*(void *)(a1 + 16), v37);
      if (v38 != 0x101000100LL) {
        break;
      }
      uint64_t v38 = v37;
      if (v36) {
        goto LABEL_52;
      }
      char v39 = 1;
LABEL_53:
      if (++v35 == v6)
      {
        if ((v39 & 1) == 0) {
          return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 8) + 32LL))( *(void *)(a1 + 8),  a1 + 24,  v6,  a1 + 272);
        }
        return icu::CollationDataBuilder::encodeExpansion( *(icu::CollationDataBuilder **)(a1 + 8),  v34,  v6,  (UErrorCode *)(a1 + 272));
      }
    }

    if (!v36 && v35)
    {
      for (uint64_t i = 0LL; i != v35; ++i)
        *(void *)(a1 + 24 + 8 * i) = v34[i];
    }

uint64_t icu::CollationDataReader::read( uint64_t this, const icu::CollationTailoring *a2, const unsigned __int8 *a3, uint64_t a4, UErrorCode *a5, UErrorCode *a6)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  int v8 = (int)a3;
  int v9 = a2;
  uint64_t v10 = (icu::CollationTailoring *)this;
  if (this)
  {
    if (*((_BYTE *)a2 + 3) != 39) {
      goto LABEL_30;
    }
    this = icu::CollationDataReader::isAcceptable( (_DWORD *)(a4 + 328),  (uint64_t)a2,  (uint64_t)a3,  (unsigned __int16 *)a2 + 2);
    if (!(_DWORD)this) {
      goto LABEL_30;
    }
    UCAVersiouint64_t n = icu::CollationTailoring::getUCAVersion(v10);
    this = icu::CollationTailoring::getUCAVersion((icu::CollationTailoring *)a4);
    if (UCAVersion != (_DWORD)this)
    {
      int v13 = 28;
      goto LABEL_31;
    }

    uint64_t v12 = *(unsigned __int16 *)v9;
    int v9 = (const icu::CollationTailoring *)((char *)v9 + v12);
    if (v8 < 0)
    {
      BOOL v14 = 0;
      goto LABEL_15;
    }

    v8 -= v12;
  }

  else if (!a2)
  {
LABEL_13:
    int v13 = 1;
LABEL_31:
    *a5 = v13;
    return this;
  }

  BOOL v14 = v8 >= 0;
LABEL_15:
  int v15 = *(_DWORD *)v9;
  if (v8 < 4 * v15 && v14) {
    goto LABEL_30;
  }
  if (v15 > 0x13)
  {
    uint64_t v17 = 19LL;
LABEL_24:
    int v18 = *((_DWORD *)v9 + v17);
    goto LABEL_27;
  }

  if (v15 >= 6)
  {
    uint64_t v17 = (v15 - 1);
    goto LABEL_24;
  }

  int v18 = 0;
LABEL_27:
  if (v8 >= v18) {
    BOOL v14 = 0;
  }
  if (v14) {
    goto LABEL_30;
  }
  if (v10) {
    uint64_t v19 = *((void *)v10 + 3);
  }
  else {
    uint64_t v19 = 0LL;
  }
  if (v15 < 6)
  {
    int v21 = 0;
    int v20 = -1;
    goto LABEL_40;
  }

  int v20 = *((_DWORD *)v9 + 5);
  if (v15 == 6)
  {
    int v21 = 0;
LABEL_40:
    int v22 = -1;
    goto LABEL_43;
  }

  int v22 = *((_DWORD *)v9 + 6);
  int v21 = 1;
LABEL_43:
  unsigned int v23 = v22 - v20;
  if (v22 - v20 < 4)
  {
    uint64_t v25 = 0LL;
    LODWORD(v26) = 0;
LABEL_50:
    unsigned int v29 = 0LL;
    LODWORD(v28) = 0;
  }

  else
  {
    if (!v19) {
      goto LABEL_30;
    }
    uint64_t v24 = 0LL;
    uint64_t v25 = (char *)v9 + v20;
    uint64_t v26 = v23 >> 2;
    uint64_t v27 = (uint64_t)v9 + 4 * v26 + v20 - 4;
    while (*(_DWORD *)(v27 + 4 * v24) >= 0x10000u)
    {
      if (-v26 == --v24)
      {
        LODWORD(v28) = v23 >> 2;
        goto LABEL_53;
      }
    }

    if (!(_DWORD)v24) {
      goto LABEL_50;
    }
    uint64_t v28 = -v24;
LABEL_53:
    LODWORD(v26) = v26 - v28;
    unsigned int v29 = (const unsigned int *)&v25[4 * (int)v26];
  }

  if (v21) {
    int v30 = *((_DWORD *)v9 + 6);
  }
  else {
    int v30 = -1;
  }
  if (v15 < 8) {
    int v31 = -1;
  }
  else {
    int v31 = *((_DWORD *)v9 + 7);
  }
  if (v31 - v30 < 256)
  {
    uint64_t v32 = 0LL;
  }

  else
  {
    if (!(_DWORD)v26) {
      goto LABEL_30;
    }
    uint64_t v32 = (const unsigned __int8 *)v9 + v30;
  }

  if (v15 < 8)
  {
    int v33 = -1;
  }

  else
  {
    int v33 = *((_DWORD *)v9 + 7);
    if (v15 != 8)
    {
      int v34 = *((_DWORD *)v9 + 8);
      goto LABEL_71;
    }
  }

  int v34 = -1;
LABEL_71:
  int v35 = v34 - v33;
  if (v34 - v33 < 8)
  {
    if (!v19) {
      goto LABEL_30;
    }
    uint64_t v38 = 0LL;
    *(void *)(a4 + 24) = v19;
  }

  else
  {
    unint64_t v96 = v32;
    __int128 __s1 = v25;
    uint64_t v36 = v19;
    int v95 = v26;
    int v37 = v28;
    this = icu::CollationTailoring::ensureOwnedData((icu::CollationTailoring *)a4, a5);
    if (!(_DWORD)this) {
      return this;
    }
    uint64_t v26 = *(void *)(a4 + 336);
    *(void *)(v26 + 32) = v36;
    *(_DWORD *)(v26 + 56) = *((unsigned __int8 *)v9 + 7) << 24;
    this = (uint64_t)utrie2_openFromSerialized(1u, (uint64_t)v9 + v33, v35, 0LL, (int *)a5);
    *(void *)(a4 + 368) = this;
    *(void *)uint64_t v26 = this;
    uint64_t v38 = v26;
    LODWORD(v28) = v37;
    LODWORD(v26) = v95;
    uint64_t v32 = v96;
    uint64_t v19 = v36;
    uint64_t v25 = __s1;
  }

  if (v15 < 10)
  {
    int v39 = -1;
  }

  else
  {
    int v39 = *((_DWORD *)v9 + 9);
    if (v15 != 10)
    {
      int v40 = *((_DWORD *)v9 + 10);
      goto LABEL_82;
    }
  }

  int v40 = -1;
LABEL_82:
  int v41 = v40 - v39;
  if (v41 >= 8)
  {
    if (!v38) {
      goto LABEL_30;
    }
    *(void *)(v38 + 16) = (char *)v9 + v39;
    *(_DWORD *)(v38 + 64) = v41 >> 3;
  }

  if (v15 < 12)
  {
    int v43 = 0;
    int v42 = -1;
    goto LABEL_89;
  }

  int v42 = *((_DWORD *)v9 + 11);
  if (v15 == 12)
  {
    int v43 = 0;
LABEL_89:
    int v44 = -1;
    goto LABEL_91;
  }

  int v44 = *((_DWORD *)v9 + 12);
  int v43 = 1;
LABEL_91:
  int v45 = v44 - v42;
  if (v45 >= 4)
  {
    if (!v38) {
      goto LABEL_30;
    }
    *(void *)(v38 + 8) = (char *)v9 + v42;
    *(_DWORD *)(v38 + 60) = v45 >> 2;
  }

  if (v15 <= 4 || (uint64_t v46 = *((unsigned int *)v9 + 4), (v46 & 0x80000000) != 0))
  {
    if (!v38) {
      goto LABEL_103;
    }
    if (!v19) {
      goto LABEL_30;
    }
    uint64_t v48 = *(void *)(v19 + 40);
  }

  else
  {
    if (!v38) {
      goto LABEL_30;
    }
    uint64_t v47 = *(void *)(v38 + 8);
    if (!v47) {
      goto LABEL_30;
    }
    uint64_t v48 = v47 + 4 * v46;
  }

  *(void *)(v38 + 40) = v48;
LABEL_103:
  if (v43) {
    int v49 = *((_DWORD *)v9 + 12);
  }
  else {
    int v49 = -1;
  }
  if (v15 < 14) {
    int v50 = -1;
  }
  else {
    int v50 = *((_DWORD *)v9 + 13);
  }
  int v51 = v50 - v49;
  if (v51 >= 4)
  {
    if (!v38) {
      goto LABEL_30;
    }
    uint64_t v52 = (char *)v9 + v49;
    *(void *)(v38 + 128) = v52;
    *(_DWORD *)(v38 + 136) = v51 >> 2;
  }

  if (v15 < 14)
  {
    int v54 = 0;
    int v53 = -1;
    goto LABEL_118;
  }

  int v53 = *((_DWORD *)v9 + 13);
  if (v15 == 14)
  {
    int v54 = 0;
LABEL_118:
    int v55 = -1;
    goto LABEL_120;
  }

  int v55 = *((_DWORD *)v9 + 14);
  int v54 = 1;
LABEL_120:
  int v56 = v55 - v53;
  if (v56 >= 2)
  {
    if (!v38) {
      goto LABEL_30;
    }
    *(void *)(v38 + 24) = (char *)v9 + v53;
    *(_DWORD *)(v38 + 68) = v56 >> 1;
  }

  if (v54) {
    int v57 = *((_DWORD *)v9 + 14);
  }
  else {
    int v57 = -1;
  }
  if (v15 < 16) {
    uint64_t v58 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v58 = *((unsigned int *)v9 + 15);
  }
  unsigned int v59 = v58 - v57;
  uint64_t v60 = v38;
  int v97 = v32;
  __s1a = (const int *)v25;
  int v93 = v29;
  int v94 = v28;
  if ((int)v58 - v57 < 2)
  {
    if (!v38)
    {
      uint64_t v61 = v19;
      char v71 = 0;
      goto LABEL_162;
    }

    if (!v19) {
      goto LABEL_30;
    }
    uint64_t v61 = v19;
    uint64_t v68 = *(void *)(v19 + 80);
  }

  else
  {
    if (!v38) {
      goto LABEL_30;
    }
    uint64_t v61 = v19;
    if (v19)
    {
      this = (uint64_t)icu::UnicodeSet::cloneAsThawed( *(icu::UnicodeSet **)(v19 + 80),  (unint64_t)a2,  (uint64_t *)v58);
      *(void *)(a4 + 376) = this;
      if (!this) {
        goto LABEL_206;
      }
    }

    else
    {
      this = (uint64_t)icu::UMemory::operator new((uint64_t *)v58, (icu::UMemory *)0xC8, (unint64_t)a2);
      if (!this)
      {
        *(void *)(a4 + 376) = 0LL;
        goto LABEL_206;
      }

      this = icu::UnicodeSet::UnicodeSet(this, &unk_180A32D00, 850LL, 0LL, a5);
      *(void *)(a4 + 376) = this;
    }

    memset(v101, 0, 32);
    this = uset_getSerializedSet((uint64_t)v101, (__int16 *)((char *)v9 + v57), v59 >> 1);
    if (!(_DWORD)this) {
      goto LABEL_30;
    }
    Serializedint RangeCount = uset_getSerializedRangeCount((uint64_t)v101);
    if (SerializedRangeCount >= 1)
    {
      int v63 = SerializedRangeCount;
      for (int i = 0; i != v63; ++i)
      {
        uint64_t v100 = 0LL;
        uset_getSerializedRange((uint64_t *)v101, i, (int *)&v100 + 1, (int *)&v100);
        icu::UnicodeSet::add(*(icu::UnicodeSet **)(a4 + 376), HIDWORD(v100), v100);
      }
    }

    int v65 = 0x10000;
    unsigned int v66 = 55296;
    do
    {
      if (!icu::UnicodeSet::containsNone(*(icu::UnicodeSet **)(a4 + 376), v65, v65 + 1023)) {
        icu::UnicodeSet::add(*(icu::UnicodeSet **)(a4 + 376), v66);
      }
      ++v66;
      BOOL v67 = v65 == 1113088;
      v65 += 1024;
    }

    while (!v67);
    this = (uint64_t)icu::UnicodeSet::freeze(*(icu::UnicodeSet **)(a4 + 376));
    uint64_t v68 = *(void *)(a4 + 376);
  }

  *(void *)(v60 + 80) = v68;
  *(void *)(v60 + 88) = 0LL;
  *(_DWORD *)(v60 + 96) = 0;
  if (*((unsigned __int8 *)v9 + 6) << 16 == 0x20000)
  {
    if (v15 < 16)
    {
      int v69 = -1;
    }

    else
    {
      int v69 = *((_DWORD *)v9 + 15);
      if (v15 != 16)
      {
        int v70 = *((_DWORD *)v9 + 16);
        goto LABEL_156;
      }
    }

    int v70 = -1;
LABEL_156:
    int v72 = v70 - v69;
    if (v72 < 2)
    {
      if (v61)
      {
        *(void *)(v60 + 88) = *(void *)(v61 + 88);
        *(_DWORD *)(v60 + 96) = *(_DWORD *)(v61 + 96);
      }
    }

    else
    {
      __int128 v73 = (char *)v9 + v69;
      *(void *)(v60 + 88) = v73;
      *(_DWORD *)(v60 + 96) = v72 >> 1;
    }
  }

  char v71 = 1;
LABEL_162:
  if (v15 < 17)
  {
    int v75 = 0;
    int v74 = -1;
    goto LABEL_166;
  }

  int v74 = *((_DWORD *)v9 + 16);
  if (v15 == 17)
  {
    int v75 = 0;
LABEL_166:
    int v76 = -1;
    goto LABEL_168;
  }

  int v76 = *((_DWORD *)v9 + 17);
  int v75 = 1;
LABEL_168:
  unsigned int v77 = v76 - v74;
  if (v76 - v74 < 2)
  {
    char v85 = v71 ^ 1;
    if (!v61) {
      char v85 = 1;
    }
    if ((v85 & 1) == 0)
    {
      *(_DWORD *)(v60 + 100) = *(_DWORD *)(v61 + 100);
      *(_OWORD *)(v60 + 104) = *(_OWORD *)(v61 + 104);
      *(_DWORD *)(v60 + 120) = *(_DWORD *)(v61 + 120);
    }
  }

  else
  {
    if (!v60) {
      goto LABEL_30;
    }
    unsigned int v78 = (unsigned __int16 *)((char *)v9 + v74);
    uint64_t v79 = *v78;
    *(_DWORD *)(v60 + 100) = v79;
    int v80 = (v77 >> 1) - v79;
    int v81 = v80 - 17;
    *(_DWORD *)(v60 + 120) = v80 - 17;
    unsigned int v82 = v78 + 1;
    *(void *)(v60 + 104) = v82;
    uint64_t v83 = &v82[v79];
    int v84 = v83[16];
    *(void *)(v60 + 112) = v83 + 16;
  }

  if (v75) {
    int v86 = *((_DWORD *)v9 + 17);
  }
  else {
    int v86 = -1;
  }
  if (v15 < 19) {
    int v87 = -1;
  }
  else {
    int v87 = *((_DWORD *)v9 + 18);
  }
  if (v87 - v86 < 256)
  {
    if (!v60) {
      goto LABEL_192;
    }
    if (!v61) {
      goto LABEL_30;
    }
    int v88 = *(char **)(v61 + 72);
  }

  else
  {
    if (!v60) {
      goto LABEL_30;
    }
    int v88 = (char *)v9 + v86;
  }

  *(void *)(v60 + 72) = v88;
LABEL_192:
  uint64_t v89 = *(void *)(a4 + 32);
  unsigned int v90 = *((_DWORD *)v9 + 1);
  bzero(v101, 0x300uLL);
  this = icu::CollationFastLatin::getOptions( *(icu::CollationFastLatin **)(a4 + 24),  (const icu::CollationData *)v89,  (const icu::CollationSettings *)v101,  (unsigned __int16 *)0x180);
  if ((unsigned __int16)v90 != *(_DWORD *)(v89 + 24)
    || !*(_DWORD *)(v89 + 28)
    || (_DWORD)v26 != *(_DWORD *)(v89 + 72)
    || (int v91 = this, (_DWORD)v26) && (this = memcmp(__s1a, *(const void **)(v89 + 64), 4 * (int)v26), (_DWORD)this)
    || v91 != *(_DWORD *)(v89 + 80)
    || (v91 & 0x80000000) == 0 && (this = memcmp(v101, (const void *)(v89 + 84), 0x300uLL), (_DWORD)this))
  {
    this = (uint64_t)sub_1808A41AC((icu::SharedObject **)(a4 + 32));
    if (this)
    {
      uint64_t v92 = this;
      *(_DWORD *)(this + 24) = (unsigned __int16)v90;
      this = icu::CollationData::getLastPrimaryForGroup(*(icu::CollationData **)(a4 + 24), (v90 >> 4) & 7 | 0x1000);
      *(_DWORD *)(v92 + 28) = this;
      if ((_DWORD)this)
      {
        if ((_DWORD)v26) {
          icu::CollationSettings::aliasReordering( (void **)v92,  (const icu::CollationData *)v61,  __s1a,  v26,  v93,  v94,  v97,  a5);
        }
        this = icu::CollationFastLatin::getOptions( *(icu::CollationFastLatin **)(a4 + 24),  (const icu::CollationData *)v92,  (const icu::CollationSettings *)(v92 + 84),  (unsigned __int16 *)0x180);
        *(_DWORD *)(v92 + 80) = this;
        return this;
      }

LABEL_206:
    int v13 = 7;
    goto LABEL_31;
  }

  return this;
}

uint64_t icu::CollationDataReader::isAcceptable(_DWORD *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  if (*a4 < 0x14u
    || *((_BYTE *)a4 + 4)
    || *((_BYTE *)a4 + 5)
    || *((_BYTE *)a4 + 8) != 85
    || *((_BYTE *)a4 + 9) != 67
    || *((_BYTE *)a4 + 10) != 111
    || *((_BYTE *)a4 + 11) != 108
    || *((_BYTE *)a4 + 12) != 5)
  {
    return 0LL;
  }

  if (a1) {
    *a1 = *((_DWORD *)a4 + 4);
  }
  return 1LL;
}

int *icu::RuleBasedCollator::cloneRuleData(icu::RuleBasedCollator *this, int *a2, UErrorCode *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (*(int *)a3 <= 0)
  {
    uint64_t v7 = (int *)uprv_malloc(0x4E20uLL);
    if (v7)
    {
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      *(_OWORD *)unint64_t v16 = 0u;
      LODWORD(v14) = 20000;
      int v8 = icu::CollationDataWriter::write( 0LL,  (int *)(*((void *)this + 3) + 328LL),  *(unsigned __int8 **)(*((void *)this + 3) + 24LL),  *((const icu::CollationData **)this + 2),  0LL,  0LL,  (int *)v16,  v7,  v14,  a3,  0LL);
      *a2 = v8;
      UErrorCode v9 = *a3;
      if (*a3 != U_BUFFER_OVERFLOW_ERROR)
      {
LABEL_8:
        if (v9 >= U_ILLEGAL_ARGUMENT_ERROR) {
          uint64_t v3 = 0LL;
        }
        else {
          uint64_t v3 = v7;
        }
        if (v9 < U_ILLEGAL_ARGUMENT_ERROR) {
          uint64_t v7 = 0LL;
        }
        goto LABEL_15;
      }

      if (v8 >= 1)
      {
        uint64_t v10 = (int *)uprv_malloc(v8);
        if (v10)
        {
          char v11 = v10;
          uprv_free(v7);
          *a3 = U_ZERO_ERROR;
          int v12 = *a2;
          __int128 v19 = 0u;
          __int128 v20 = 0u;
          __int128 v17 = 0u;
          __int128 v18 = 0u;
          *(_OWORD *)unint64_t v16 = 0u;
          LODWORD(v15) = v12;
          *a2 = icu::CollationDataWriter::write( 0LL,  (int *)(*((void *)this + 3) + 328LL),  *(unsigned __int8 **)(*((void *)this + 3) + 24LL),  *((const icu::CollationData **)this + 2),  0LL,  0LL,  (int *)v16,  v11,  v15,  a3,  0LL);
          UErrorCode v9 = *a3;
          uint64_t v7 = v11;
          goto LABEL_8;
        }
      }
    }

    uint64_t v3 = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
LABEL_15:
    uprv_free(v7);
    return v3;
  }

  return 0LL;
}

uint64_t icu::RuleBasedCollator::cloneBinary( icu::RuleBasedCollator *this, unsigned __int8 *a2, int a3, UErrorCode *a4)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  LODWORD(v5) = a3;
  return icu::CollationDataWriter::write( 0LL,  (int *)(*((void *)this + 3) + 328LL),  *(unsigned __int8 **)(*((void *)this + 3) + 24LL),  *((const icu::CollationData **)this + 2),  0LL,  0LL,  (int *)v6,  (int *)a2,  v5,  a4,  0LL);
}

uint64_t icu::CollationDataWriter::writeTailoring( icu::CollationDataWriter *this, const icu::CollationTailoring *a2, const icu::CollationSettings *a3, int *a4, unsigned __int8 *a5, UErrorCode *a6, UErrorCode *a7)
{
  LODWORD(v8) = (_DWORD)a5;
  return icu::CollationDataWriter::write( 0LL,  (int *)this + 82,  *((unsigned __int8 **)this + 3),  a2,  0LL,  0LL,  (int *)a3,  a4,  v8,  a6,  vars0);
}

uint64_t icu::CollationDataWriter::writeBase( icu::CollationDataWriter *this, const icu::CollationData *a2, const icu::CollationSettings *a3, const void *a4, int *a5, int *a6, unsigned __int8 *a7, UErrorCode *a8, UErrorCode *a9)
{
  LODWORD(v10) = (_DWORD)a7;
  return icu::CollationDataWriter::write( (icu::CollationDataWriter *)1,  0LL,  (unsigned __int8 *)this,  a2,  a3,  a4,  a5,  a6,  v10,  a8,  vars0);
}

uint64_t icu::CollationDataWriter::write( icu::CollationDataWriter *this, int *a2, unsigned __int8 *a3, const icu::CollationData *a4, const icu::CollationSettings *a5, const void *a6, int *a7, int *a8, unsigned __int8 *a9, UErrorCode *a10, UErrorCode *a11)
{
  uint64_t v97 = *MEMORY[0x1895F89C0];
  if (*(int *)a10 <= 0)
  {
    if ((a9 & 0x80000000) != 0 || (int v14 = (int)a6, v18 = (int)this, !a8) && (_DWORD)a9)
    {
      uint64_t v11 = 0LL;
      *a10 = U_ILLEGAL_ARGUMENT_ERROR;
      return v11;
    }

    int v86 = (int)a9;
    uint64_t v90 = 0LL;
    memset(v89, 0, sizeof(v89));
    icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v89);
    uint64_t v19 = *((void *)a3 + 4);
    int v82 = *((void *)a3 + 11) != 0LL;
    __dst = a8;
    uint64_t v80 = v19;
    if (v18)
    {
      icu::UnicodeSet::operator=((icu::UnicodeSet *)v89, *((const icu::UnicodeSet **)a3 + 10));
      int v85 = 0;
      int v81 = *((_DWORD *)a3 + 24);
      int v20 = 20;
    }

    else if (v19)
    {
      if (*((_DWORD *)a3 + 17)) {
        int v20 = 15;
      }
      else {
        int v20 = 13;
      }
      uint64_t v28 = (icu::UVector **)icu::UnicodeSet::addAll((icu::UVector **)v89, *((const icu::UnicodeSet **)a3 + 10));
      icu::UnicodeSet::removeAll(v28, *(const icu::UnicodeSet **)(v19 + 80));
      if (!icu::UnicodeSet::isEmpty((icu::UnicodeSet *)v89)) {
        int v20 = 16;
      }
      int v85 = 0;
      if (*((void *)a3 + 11) == *(void *)(v19 + 88))
      {
        int v81 = 0;
      }

      else
      {
        int v81 = *((_DWORD *)a3 + 24);
        int v20 = 17;
      }
    }

    else
    {
      int v81 = 0;
      if (*((_DWORD *)a4 + 18)) {
        int v20 = 8;
      }
      else {
        int v20 = 2;
      }
      int v85 = 1;
    }

    __int128 v87 = 0u;
    __int128 v88 = 0u;
    icu::UVector32::UVector32((icu::UVector32 *)&v87, a10);
    int v22 = (const int *)*((void *)a4 + 8);
    uint64_t v23 = *((unsigned int *)a4 + 18);
    uint64_t v24 = (icu::CollationSettings *)*((void *)a4 + 4);
    if (v24 && icu::CollationSettings::reorderTableHasSplitBytes(v24, v21))
    {
      int v77 = v20;
      icu::CollationData::makeReorderRanges((icu::CollationData *)a3, v22, v23, (icu::UVector32 *)&v87, a10);
      if ((int)v23 >= 1)
      {
        for (uint64_t i = 0LL; i != v23; ++i)
          icu::UVector32::insertElementAt(&v87, v22[i], i, a10);
      }

      int v26 = v85;
      if (*(int *)a10 >= 1)
      {
        uint64_t v11 = 0LL;
LABEL_112:
        icu::UVector32::~UVector32((void **)&v87);
        icu::UnicodeSet::~UnicodeSet(v74, (icu::UnicodeSet *)v89);
        return v11;
      }

      int v22 = (const int *)*((void *)&v88 + 1);
      LODWORD(v23) = DWORD2(v87);
      int v20 = v77;
    }

    else
    {
      int v26 = v85;
    }

    int v27 = v82 << 17;
    if (v18)
    {
      int v83 = 0;
    }

    else
    {
      if (*((_DWORD *)a3 + 16)) {
        int v29 = v26;
      }
      else {
        int v29 = 1;
      }
      int v78 = v20;
      if ((((_BYTE)v23 + (_BYTE)v20) & 1) == 0) {
        int v29 = 1;
      }
      if (v29) {
        int v30 = 24;
      }
      else {
        int v30 = 28;
      }
      int v83 = v30;
      if ((int)a9 >= v30)
      {
        int v86 = (_DWORD)a9 - v30;
        int v31 = *a2;
        *(_WORD *)__dst = v30;
        int v76 = v27;
        *((_WORD *)__dst + sub_18086E18C((uint64_t)this, 1) = 10202;
        *(_OWORD *)(__dst + sub_18086E18C((uint64_t)this, 1) = xmmword_180A333A4;
        __dst[5] = v31;
        bzero(__dst + 6, (v30 - 24));
        int v27 = v76;
        int v26 = v85;
        __dst = (int *)((char *)__dst + v30);
      }

      else
      {
        int v86 = 0;
        __dst = 0LL;
      }

      int v20 = v78;
    }

    *a7 = v20;
    int v32 = *((_DWORD *)a3 + 14) | v27 | *((_DWORD *)a4 + 6);
    *((void *)a7 + sub_18086E18C((uint64_t)this, 1) = 0LL;
    a7[1] = v32;
    size_t v33 = (4 * v20);
    if ((v26 & 1) != 0 || (uint64_t v35 = *((void *)a3 + 5), !v18) && v35 == *(void *)(v80 + 40)) {
      LODWORD(v34) = -1;
    }
    else {
      unint64_t v34 = (unint64_t)(v35 - *((void *)a3 + 1)) >> 2;
    }
    a7[4] = v34;
    a7[5] = v33;
    int v36 = 4 * (v23 + v20);
    a7[6] = v36;
    if (*((void *)a4 + 4)) {
      int v37 = v36 + 256;
    }
    else {
      int v37 = 4 * (v23 + v20);
    }
    a7[7] = v37;
    if (v26)
    {
      a7[8] = v37;
      a7[9] = v37;
    }

    else
    {
      v92[0] = U_ZERO_ERROR;
      int v38 = v86 - v37;
      if (v86 <= v37)
      {
        int v39 = 0LL;
        int v38 = 0;
      }

      else
      {
        int v39 = (char *)__dst + v37;
      }

      int v40 = utrie2_serialize(*(void *)a3, v39, v38, (int *)v92);
      UErrorCode v41 = v92[0];
      if (v92[0] >= U_ILLEGAL_ARGUMENT_ERROR && v92[0] != U_BUFFER_OVERFLOW_ERROR) {
        goto LABEL_77;
      }
      a7[8] = v40 + v37;
      a7[9] = v40 + v37;
      int v42 = *((_DWORD *)a3 + 16);
      if (v42) {
        v37 += v40 + 8 * v42;
      }
      else {
        v37 += v40;
      }
      int v26 = v85;
    }

    a7[10] = v37;
    a7[11] = v37;
    int v43 = 4 * *((_DWORD *)a3 + 15);
    if (v26) {
      int v43 = 0;
    }
    int v44 = v43 + v37;
    int v45 = v43 + v37 + 4 * v14;
    a7[12] = v44;
    a7[13] = v45;
    uint64_t v46 = 2LL * *((int *)a3 + 17) + v45;
    if (v26) {
      int v47 = v45;
    }
    else {
      int v47 = 2 * *((_DWORD *)a3 + 17) + v45;
    }
    a7[14] = v47;
    if ((v26 & 1) != 0) {
      goto LABEL_79;
    }
    if (icu::UnicodeSet::isEmpty((icu::UnicodeSet *)v89))
    {
      int v45 = v46;
LABEL_79:
      int v51 = v45 + 2 * v81;
      __int128 v93 = 0u;
      uint64_t v96 = 0LL;
      __int128 v95 = 0u;
      __int128 v94 = 0u;
      *(void *)uint64_t v92 = off_18971B688;
      LOWORD(v93) = 2;
      a7[15] = v45;
      a7[16] = v51;
      if (v18)
      {
        __int16 v91 = *((_DWORD *)a3 + 25);
        icu::UnicodeString::doAppend((uint64_t)v92, (uint64_t)&v91, 0, 1LL);
        icu::UnicodeString::doAppend((uint64_t)v92, *((void *)a3 + 13), 0, (*((_DWORD *)a3 + 25) + 16));
        icu::UnicodeString::doAppend((uint64_t)v92, *((void *)a3 + 14), 0, *((unsigned int *)a3 + 30));
        int v52 = (unsigned __int16)v93 >> 5;
        if ((v93 & 0x8000u) != 0LL) {
          int v52 = DWORD1(v93);
        }
        v51 += 2 * v52;
      }

      if (v18) {
        int v53 = v51 + 256;
      }
      else {
        int v53 = v51;
      }
      a7[17] = v51;
      a7[18] = v53;
      a7[19] = v53;
      if (v53 <= v86)
      {
        memcpy(__dst, a7, v33);
        int v56 = a7[6];
        uint64_t v57 = a7[5];
        if (v56 > (int)v57)
        {
          memcpy((char *)__dst + v57, v22, v56 - (int)v57);
          int v56 = a7[6];
        }

        int v58 = a7[7];
        BOOL v59 = __OFSUB__(v58, v56);
        int v60 = v58 - v56;
        if (!((v60 < 0) ^ v59 | (v60 == 0))) {
          memcpy((char *)__dst + v56, *((const void **)a4 + 4), v60);
        }
        int v61 = a7[10];
        uint64_t v62 = a7[9];
        int v63 = a7[12];
        uint64_t v64 = a7[11];
        int v55 = v83;
        if (v63 > (int)v64)
        {
          memcpy((char *)__dst + v64, *((const void **)a3 + 1), v63 - (int)v64);
          int v63 = a7[12];
        }

        int v65 = a7[13];
        if (v65 > v63)
        {
          memcpy((char *)__dst + v63, a5, v65 - v63);
          int v65 = a7[13];
        }

        int v66 = a7[14];
        BOOL v59 = __OFSUB__(v66, v65);
        int v67 = v66 - v65;
        if (!((v67 < 0) ^ v59 | (v67 == 0))) {
          memcpy((char *)__dst + v65, *((const void **)a3 + 3), v67);
        }
        int v68 = a7[16];
        uint64_t v69 = a7[15];
        if ((v93 & 0x11) != 0)
        {
          int v70 = 0LL;
        }

        else if ((v93 & 2) != 0)
        {
          int v70 = (char *)&v93 + 2;
        }

        else
        {
          int v70 = (char *)v94;
        }

        uint64_t v54 = a7[17];
        uint64_t v71 = a7[16];
        if ((int)v54 > (int)v71)
        {
          memcpy((char *)__dst + v71, v70, (int)v54 - (int)v71);
          uint64_t v54 = a7[17];
        }

        int v72 = a7[18];
        BOOL v59 = __OFSUB__(v72, (_DWORD)v54);
        int v73 = v72 - v54;
        if (!((v73 < 0) ^ v59 | (v73 == 0))) {
          memcpy((char *)__dst + (int)v54, *((const void **)a3 + 9), v73);
        }
      }

      else
      {
        uint64_t v54 = 15LL;
        *a10 = U_BUFFER_OVERFLOW_ERROR;
        int v55 = v83;
      }

      uint64_t v11 = (v53 + v55);
      icu::UnicodeString::~UnicodeString((void *)v54, (icu::UnicodeString *)v92);
      goto LABEL_112;
    }

    v92[0] = U_ZERO_ERROR;
    if (v86 <= (int)v46)
    {
      uint64_t v48 = 0LL;
      int v49 = 0;
    }

    else
    {
      uint64_t v48 = (unsigned __int16 *)((char *)__dst + v46);
      int v49 = (v86 - (int)v46) / 2;
    }

    int v50 = icu::UnicodeSet::serialize((icu::UnicodeSet *)v89, v48, v49, v92);
    UErrorCode v41 = v92[0];
    if (v92[0] < U_ILLEGAL_ARGUMENT_ERROR || v92[0] == U_BUFFER_OVERFLOW_ERROR)
    {
      int v45 = v46 + 2 * v50;
      goto LABEL_79;
    }

LABEL_77:
    uint64_t v11 = 0LL;
    *a10 = v41;
    goto LABEL_112;
  }

  return 0LL;
}

  int v42 = *(icu::CollationIterator **)v20;
  int v43 = (const unsigned __int16 *)*(unsigned int *)(*(void *)v20 + 80LL);
  int v66 = v20;
  if ((v43 & 0x80000000) == 0 && (a3 == pi || a2[pi] <= 0xC5u) && (v7 == pi || a4[pi] <= 0xC5u))
  {
    int v44 = a6;
    int v45 = (const unsigned __int16 *)((char *)v42 + 84);
    if (a3 < 0)
    {
      int v47 = &a4[pi];
      int v49 = v43;
      uint64_t v46 = 0xFFFFFFFFLL;
      uint64_t v48 = 0xFFFFFFFFLL;
    }

    else
    {
      uint64_t v46 = (a3 - pi);
      int v47 = &a4[pi];
      uint64_t v48 = (v7 - pi);
      int v49 = v43;
    }

    int v12 = icu::CollationFastLatin::compareUTF8( *(icu::CollationFastLatin **)(*((void *)this + 1) + 88LL),  v45,  v49,  (uint64_t)&a2[pi],  (const unsigned __int8 *)v46,  (uint64_t)v47,  (const unsigned __int8 *)v48);
    if ((_DWORD)v12 != -2)
    {
LABEL_89:
      if ((_DWORD)v12) {
        return v12;
      }
      goto LABEL_92;
    }

    int v42 = *(icu::CollationIterator **)v66;
    a6 = v44;
  }

  if ((*((_BYTE *)v42 + 24) & 1) == 0)
  {
    int v129 = 0u;
    int v130 = 0u;
    unsigned int v127 = 0u;
    v128 = 0u;
    int v125 = 0u;
    unsigned int v126 = 0u;
    v123 = 0u;
    unsigned int v124 = 0u;
    int v122 = 0u;
    int v121 = 0u;
    unsigned int v120 = 0u;
    v119 = 0u;
    unsigned int v118 = 0u;
    unsigned int v117 = 0u;
    unsigned int v116 = 0u;
    int v115 = 0u;
    uint64_t v114 = 0u;
    uint64_t v113 = 0u;
    uint64_t v112 = 0u;
    uint64_t v111 = 0u;
    __int128 v110 = 0u;
    __int128 v109 = 0u;
    __int128 v108 = 0u;
    int v50 = (void *)*((void *)this + 1);
    int v51 = *v50;
    __int128 v107 = v50;
    *((void *)&v108 + sub_18086E18C((uint64_t)this, 1) = (char *)&v109 + 8;
    LODWORD(v109) = 40;
    DWORD2(v129) = 0;
    DWORD2(v130) = -1;
    BYTE12(v130) = v21;
    __int128 v105 = (void (**)(icu::UObject *__hidden))&unk_18972D190;
    uint64_t v106 = v51;
    *(void *)&int v131 = a2;
    *((void *)&v131 + sub_18086E18C((uint64_t)this, 1) = __PAIR64__(a3, pi);
    __int128 v93 = 0u;
    __int128 v94 = 0u;
    __int16 v91 = 0u;
    uint64_t v92 = 0u;
    uint64_t v89 = 0u;
    uint64_t v90 = 0u;
    __int128 v87 = 0u;
    __int128 v88 = 0u;
    int v86 = 0u;
    int v85 = 0u;
    int v84 = 0u;
    int v83 = 0u;
    int v82 = 0u;
    int v81 = 0u;
    uint64_t v80 = 0u;
    uint64_t v79 = 0u;
    int v78 = 0u;
    int v77 = 0u;
    int v76 = 0u;
    int v75 = 0u;
    int v74 = 0u;
    int v73 = 0u;
    uint64_t v71 = 0LL;
    uint64_t v69 = v51;
    int v70 = v50;
    int v72 = (void (**)(icu::FCDUTF8CollationIterator *__hidden))&v73 + 1;
    LODWORD(v73) = 40;
    DWORD2(v93) = 0;
    DWORD2(v94) = -1;
    BYTE12(v94) = v21;
    int v68 = (void (**)(icu::UObject *__hidden))&unk_18972D190;
    __int128 v95 = a4;
    uint64_t v96 = pi;
    uint64_t v97 = v7;
    int v44 = a6;
    int v12 = icu::CollationCompare::compareUpToQuaternary( (icu::CollationCompare *)&v105,  (icu::CollationIterator *)&v68,  v42,  a6,  a5);
    icu::UTF8CollationIterator::~UTF8CollationIterator((icu::UTF8CollationIterator *)&v68);
    icu::UTF8CollationIterator::~UTF8CollationIterator((icu::UTF8CollationIterator *)&v105);
    goto LABEL_89;
  }

  int v135 = 0u;
  __int32 v136 = 0u;
  int8x8_t v133 = 0u;
  __int32 v134 = 0u;
  int v131 = 0u;
  int8x8_t v132 = 0u;
  int v129 = 0u;
  int v130 = 0u;
  unsigned int v127 = 0u;
  v128 = 0u;
  int v125 = 0u;
  unsigned int v126 = 0u;
  v123 = 0u;
  unsigned int v124 = 0u;
  __int32 v137 = 0LL;
  int v122 = 0u;
  int v121 = 0u;
  unsigned int v120 = 0u;
  v119 = 0u;
  unsigned int v118 = 0u;
  unsigned int v117 = 0u;
  unsigned int v116 = 0u;
  int v115 = 0u;
  uint64_t v114 = 0u;
  uint64_t v113 = 0u;
  uint64_t v112 = 0u;
  uint64_t v111 = 0u;
  __int128 v110 = 0u;
  __int128 v109 = 0u;
  __int128 v108 = 0u;
  int v52 = (void *)*((void *)this + 1);
  int v53 = *v52;
  __int128 v107 = v52;
  *((void *)&v108 + sub_18086E18C((uint64_t)this, 1) = (char *)&v109 + 8;
  LODWORD(v109) = 40;
  DWORD2(v129) = 0;
  DWORD2(v130) = -1;
  BYTE12(v130) = v21;
  *(void *)&int v131 = a2;
  *((void *)&v131 + sub_18086E18C((uint64_t)this, 1) = __PAIR64__(a3, pi);
  __int128 v105 = off_18972D100;
  uint64_t v106 = v53;
  DWORD1(v132) = pi;
  *(void *)&int8x8_t v133 = v52[6];
  *((void *)&v133 + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
  LOWORD(v134) = 2;
  uint64_t v102 = 0u;
  double v103 = 0u;
  double v101 = 0u;
  uint64_t v98 = 0u;
  __int128 v93 = 0u;
  __int128 v94 = 0u;
  __int16 v91 = 0u;
  uint64_t v92 = 0u;
  uint64_t v89 = 0u;
  uint64_t v90 = 0u;
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  int v104 = 0LL;
  int v86 = 0u;
  int v85 = 0u;
  int v84 = 0u;
  int v83 = 0u;
  int v82 = 0u;
  int v81 = 0u;
  uint64_t v80 = 0u;
  uint64_t v79 = 0u;
  int v78 = 0u;
  int v77 = 0u;
  int v76 = 0u;
  int v75 = 0u;
  int v74 = 0u;
  int v73 = 0u;
  uint64_t v71 = 0LL;
  uint64_t v69 = v53;
  int v70 = v52;
  int v72 = (void (**)(icu::FCDUTF8CollationIterator *__hidden))&v73 + 1;
  LODWORD(v73) = 40;
  DWORD2(v93) = 0;
  DWORD2(v94) = -1;
  BYTE12(v94) = v21;
  __int128 v95 = a4;
  uint64_t v96 = pi;
  uint64_t v97 = v7;
  int v68 = off_18972D100;
  DWORD1(v98) = pi;
  uint64_t v99 = (const unsigned __int8 *)v133;
  uint64_t v100 = off_18971B688;
  LOWORD(v10sub_18086E18C((uint64_t)this, 1) = 2;
  int v44 = a6;
  int v12 = icu::CollationCompare::compareUpToQuaternary( (icu::CollationCompare *)&v105,  (icu::CollationIterator *)&v68,  v42,  a6,  a5);
  icu::FCDUTF8CollationIterator::~FCDUTF8CollationIterator((icu::FCDUTF8CollationIterator *)&v68);
  icu::FCDUTF8CollationIterator::~FCDUTF8CollationIterator((icu::FCDUTF8CollationIterator *)&v105);
  if ((_DWORD)v12) {
    return v12;
  }
LABEL_92:
  uint64_t v54 = *(_DWORD *)(*(void *)v66 + 24LL);
  if (v54 >= 61440 && *(int *)v44 <= 0)
  {
    int v55 = (uint64_t *)*((void *)this + 1);
    int v56 = v55[6];
    uint64_t v57 = pi;
    int v58 = &a2[pi];
    if (a3 <= 0) {
      uint64_t v57 = 0;
    }
    BOOL v59 = a3 - v57;
    int v60 = v7 - v57;
    if ((v54 & 1) != 0)
    {
      int v65 = &a4[pi];
      bzero(&v106, 0x208uLL);
      LODWORD(v108) = -1;
      __int128 v105 = (void (**)(icu::UObject *__hidden))off_18972AC50;
      int v61 = *v55;
      *((void *)&v109 + sub_18086E18C((uint64_t)this, 1) = v55;
      *((void *)&v110 + sub_18086E18C((uint64_t)this, 1) = (char *)&v111 + 8;
      LODWORD(v11sub_18086E18C((uint64_t)this, 1) = 40;
      DWORD2(v13sub_18086E18C((uint64_t)this, 1) = 0;
      DWORD2(v132) = -1;
      *(void *)&int8x8_t v133 = v58;
      HIDWORD(v133) = v59;
      *((void *)&v108 + sub_18086E18C((uint64_t)this, 1) = off_18972D100;
      *(void *)&__int128 v109 = v61;
      DWORD1(v134) = 0;
      *(void *)&int v135 = v56;
      *((void *)&v135 + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
      LOWORD(v136) = 2;
      bzero(&v69, 0x208uLL);
      LODWORD(v7sub_18086E18C((uint64_t)this, 1) = -1;
      int v68 = (void (**)(icu::UObject *__hidden))off_18972AC50;
      *(void *)&int v73 = v61;
      *((void *)&v73 + sub_18086E18C((uint64_t)this, 1) = v55;
      *((void *)&v74 + sub_18086E18C((uint64_t)this, 1) = (char *)&v75 + 8;
      LODWORD(v75) = 40;
      uint64_t v96 = 0;
      DWORD2(v98) = -1;
      uint64_t v99 = v65;
      HIDWORD(v100) = v60;
      int v72 = off_18972D100;
      DWORD1(v10sub_18086E18C((uint64_t)this, 1) = 0;
      *(void *)&uint64_t v102 = v56;
      *((void *)&v102 + sub_18086E18C((uint64_t)this, 1) = off_18971B688;
      LOWORD(v103) = 2;
      int v12 = sub_18097F3A0(v56, (uint64_t)&v105, (uint64_t)&v68);
      int v68 = (void (**)(icu::UObject *__hidden))off_18972AC50;
      icu::FCDUTF8CollationIterator::~FCDUTF8CollationIterator((icu::FCDUTF8CollationIterator *)&v72);
      icu::UObject::~UObject((icu::UObject *)&v68);
      __int128 v105 = (void (**)(icu::UObject *__hidden))off_18972AC50;
      icu::FCDUTF8CollationIterator::~FCDUTF8CollationIterator((icu::FCDUTF8CollationIterator *)((char *)&v108 + 8));
    }

    else
    {
      uint64_t v106 = 0LL;
      __int128 v107 = 0LL;
      *(void *)&__int128 v108 = 0xFFFFFFFFLL;
      __int128 v105 = &off_18972AC08;
      *((void *)&v108 + sub_18086E18C((uint64_t)this, 1) = v58;
      LODWORD(v109) = 0;
      DWORD1(v109) = v59;
      uint64_t v69 = 0LL;
      int v70 = 0LL;
      uint64_t v71 = 0xFFFFFFFFLL;
      int v68 = &off_18972AC08;
      int v72 = (void (**)(icu::FCDUTF8CollationIterator *__hidden))&a4[pi];
      LODWORD(v73) = 0;
      DWORD1(v73) = v7 - v57;
      int v12 = sub_18097F3A0(v56, (uint64_t)&v105, (uint64_t)&v68);
      icu::UObject::~UObject((icu::UObject *)&v68);
    }

    icu::UObject::~UObject((icu::UObject *)&v105);
  }

  return v12;
}

  BOOL v59 = 0LL;
  *(void *)int v60 = 0LL;
  int v58 = 0LL;
  sub_1808FA670(&v60[1], v60, (_DWORD *)&v59 + 1, (int *)&v59, (int *)&v58 + 1, &v58, (double)a5 + a7);
  if (v18 == -1) {
    int v39 = v60[0];
  }
  else {
    int v39 = v18;
  }
  UErrorCode v41 = v67;
  int v40 = v68;
  int v42 = __PAIR64__(v68, v67) == 0;
  else {
    int v43 = HIDWORD(v59);
  }
  uint64_t v57 = 0;
  if (v65 == -1.84303903e17)
  {
    uint64_t v57 = 0x7FFFFFFF;
  }

  else
  {
    LODWORD(v69[0]) = 0;
    LODWORD(v64) = 0;
    int v63 = 0LL;
    uint64_t v62 = 0;
    sub_1808FA670(&v57, v69, &v64, (int *)&v63 + 1, (int *)&v63, &v62, v65);
  }

  if (v43) {
    int v44 = (uint64_t *)v42;
  }
  else {
    int v44 = 0LL;
  }
  if ((_DWORD)v44 != 1)
  {
    if (v40 && v41 && !v43)
    {
      int v49 = icu::UMemory::operator new(v44, (icu::UMemory *)0x28, v38);
      if (v49)
      {
        uint64_t v46 = (icu::DateTimeRule *)v49;
        icu::DateTimeRule::DateTimeRule((uint64_t)v49, v39, v41, v40, v58, 0);
        goto LABEL_102;
      }
    }

    else if (v40)
    {
      if (!v41)
      {
        if (v43)
        {
          int v50 = icu::UMemory::operator new(v44, (icu::UMemory *)0x28, v38);
          if (v50)
          {
            uint64_t v46 = (icu::DateTimeRule *)v50;
            icu::DateTimeRule::DateTimeRule((uint64_t)v50, v39, v43, v40, 1, v58, 0);
            goto LABEL_102;
          }
        }
      }
    }

char *icu::CollationDataWriter::copyData( char *this, const int *a2, void *__src, char *a4, unsigned __int8 *a5)
{
  unsigned int v5 = &this[4 * (int)a2];
  int v6 = *(_DWORD *)v5;
  int v7 = *((_DWORD *)v5 + 1);
  if (v7 > v6) {
    return (char *)memcpy(&a4[v6], __src, v7 - v6);
  }
  return this;
}

uint64_t icu::CollationFastLatin::getOptions( icu::CollationFastLatin *this, const icu::CollationData *a2, const icu::CollationSettings *a3, unsigned __int16 *a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if ((_DWORD)a4 == 384)
  {
    int v6 = (unsigned __int8 *)*((void *)this + 11);
    if (v6)
    {
      unint64_t v9 = *((unsigned int *)a2 + 6);
      if ((v9 & 0xC) != 0)
      {
        uint64_t v10 = ((v9 >> 4) & 7) + 1;
        unsigned int v11 = *(unsigned __int16 *)&v6[2 * v10];
      }

      else
      {
        unsigned int v11 = 3071;
      }

      uint64_t v12 = *((void *)a2 + 4);
      if (v12)
      {
        int v13 = 0;
        unsigned int v14 = 0;
        unsigned int v15 = 0;
        unsigned int v16 = 0;
        unsigned int v17 = 0;
        do
        {
          FirstPrimaryForGrouunint64_t p = icu::CollationData::getFirstPrimaryForGroup(this, v13 + 4096);
          int v19 = *(unsigned __int8 *)(*((void *)a2 + 4) + ((unint64_t)FirstPrimaryForGroup >> 24));
          else {
            unsigned int v21 = FirstPrimaryForGroup & 0xFFFFFF | (v19 << 24);
          }
          if (v13 == 4)
          {
            unsigned int v16 = v17;
            unsigned int v15 = v21;
          }

          else if (v21)
          {
            if (v21 < v17) {
              return 0xFFFFFFFFLL;
            }
            if (v17 == v16) {
              unsigned int v22 = v21;
            }
            else {
              unsigned int v22 = 0;
            }
            if (v14) {
              unsigned int v22 = v14;
            }
            if (v15) {
              unsigned int v14 = v22;
            }
            unsigned int v17 = v21;
          }

          ++v13;
        }

        while (v13 != 8);
        uint64_t v23 = icu::CollationData::getFirstPrimaryForGroup(this, 0x19u);
        else {
          unsigned int v24 = icu::CollationSettings::reorderEx(a2, v23);
        }
        if (v24 < v17) {
          return 0xFFFFFFFFLL;
        }
        if (v14) {
          unsigned int v25 = v14;
        }
        else {
          unsigned int v25 = v24;
        }
        LODWORD(v12) = v16 >= v15 || v15 >= v25;
      }

      uint64_t v27 = 0LL;
      uint64_t v28 = &v6[2 * *v6];
      do
      {
        unsigned int v29 = *(unsigned __int16 *)&v28[v27];
        __int16 v30 = v29 & 0xFFF8;
        if (v11 >= v29) {
          __int16 v30 = 0;
        }
        if (v29 <= 0xFFF) {
          __int16 v31 = v30;
        }
        else {
          __int16 v31 = v29 & 0xFC00;
        }
        *(_WORD *)((char *)a3 + v27) = v31;
        v27 += 2LL;
      }

      while (v27 != 768);
      int v32 = *((_DWORD *)a2 + 6);
      if ((_DWORD)v12 || (v32 & 2) != 0)
      {
        *((void *)a3 + 12) = 0LL;
        *((void *)a3 + 13) = 0LL;
        *((_DWORD *)a3 + 28) = 0;
      }

      return v32 | (v11 << 16);
    }
  }

  return result;
}

uint64_t icu::CollationFastLatin::compareUTF16( unsigned __int8 *a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  __int16 v9 = a3;
  unsigned int v11 = 0;
  unsigned int v12 = 0;
  int v90 = a7;
  int v91 = a5;
  uint64_t v13 = (uint64_t)&a1[2 * *a1];
  unsigned int v14 = (icu::CollationFastLatin *)HIWORD(a3);
  unsigned int v88 = (unsigned __int16)a3;
  uint64_t v89 = 0LL;
  while (2)
  {
    if (!v11)
    {
      while (1)
      {
        uint64_t v18 = SHIDWORD(v89);
        if (HIDWORD(v89) == v91)
        {
          unsigned int v11 = 2;
          goto LABEL_3;
        }

        ++HIDWORD(v89);
        uint64_t v19 = *(unsigned __int16 *)(a4 + 2 * v18);
        if ((v19 & 0xFFC0) == 0x2000)
        {
          uint64_t v20 = (v19 - 7808);
LABEL_25:
          uint64_t v17 = *(unsigned __int16 *)(v13 + 2 * v20);
          goto LABEL_26;
        }

        if ((_DWORD)v19 == 0xFFFF) {
          uint64_t v17 = 64680LL;
        }
        else {
          uint64_t v17 = 1LL;
        }
        if ((_DWORD)v19 == 65534)
        {
          uint64_t v17 = 3LL;
          goto LABEL_27;
        }

LABEL_162:
LABEL_163:
        if (v52 > v14)
        {
          unsigned int v45 = 192;
          goto LABEL_129;
        }

        unsigned int v56 = icu::CollationFastLatin::nextPair(v13, v54, v52, a6, 0LL, (int *)&v89, &v90);
        unsigned int Secondaries = icu::CollationFastLatin::getSecondaries(v14, v56);
        if (Secondaries)
        {
          unsigned int v45 = Secondaries;
          goto LABEL_129;
        }
      }

      else {
        unsigned int v45 = (v52 & 0x3E0) + 32;
      }
LABEL_129:
      if (v44 != v45)
      {
        if ((unsigned __int16)v44 != (unsigned __int16)v45)
        {
          else {
            unsigned int v71 = 1;
          }
          if ((v9 & 0x800) != 0) {
            return 4294967294LL;
          }
          else {
            return v71;
          }
        }

        if (v44 != 2)
        {
          v44 >>= 16;
          v45 >>= 16;
          continue;
        }

        goto LABEL_75;
      }

      unsigned int v45 = 0;
      BOOL v15 = v44 == 2;
      unsigned int v44 = 0;
      if (v15) {
        goto LABEL_75;
      }
    }

    while (1)
    {
      uint64_t v47 = SHIDWORD(v89);
      if (HIDWORD(v89) == v91)
      {
        unsigned int v44 = 2;
        goto LABEL_128;
      }

      ++HIDWORD(v89);
      unsigned int v48 = *(unsigned __int16 *)(a4 + 2 * v47);
      if (v48 <= 0x17F) {
        break;
      }
      if ((v48 & 0xFFC0) == 0x2000)
      {
        uint64_t v49 = v48 - 7808;
        goto LABEL_146;
      }

      if (v48 == 0xFFFF) {
        uint64_t v46 = 64680LL;
      }
      else {
        uint64_t v46 = 1LL;
      }
      if (v48 == 65534)
      {
        uint64_t v46 = 3LL;
        goto LABEL_148;
      }

LABEL_147:
      if (v46 >= 0x1000)
      {
        else {
          unsigned int v44 = (v46 & 0x3E0) + 32;
        }
        goto LABEL_128;
      }

LABEL_148:
      if (v46 > v14)
      {
        unsigned int v44 = 192;
        goto LABEL_128;
      }

      unsigned int v50 = icu::CollationFastLatin::nextPair(v13, v48, v46, a4, 0LL, (int *)&v89 + 1, &v91);
      unsigned int v51 = icu::CollationFastLatin::getSecondaries(v14, v50);
      if (v51)
      {
        unsigned int v44 = v51;
        goto LABEL_128;
      }
    }

    uint64_t v49 = *(unsigned __int16 *)(a4 + 2 * v47);
LABEL_146:
    uint64_t v46 = *(unsigned __int16 *)(v13 + 2 * v49);
    goto LABEL_147;
  }

LABEL_221:
  if (v88 < 0x3000) {
    return 0LL;
  }
  unsigned int v76 = 0;
  unsigned int v77 = 0;
  uint64_t v89 = 0LL;
  while (2)
  {
    while (2)
    {
      if (!v76)
      {
        while (1)
        {
          uint64_t v78 = SHIDWORD(v89);
          if (HIDWORD(v89) == v91)
          {
            unsigned int v76 = 2;
            goto LABEL_246;
          }

          ++HIDWORD(v89);
          unsigned int v79 = *(unsigned __int16 *)(a4 + 2 * v78);
          if (v79 <= 0x17F) {
            break;
          }
          if ((v79 & 0xFFC0) == 0x2000)
          {
            uint64_t v80 = v79 - 7808;
            goto LABEL_256;
          }

          if (v79 == 0xFFFF) {
            uint64_t v81 = 64680LL;
          }
          else {
            uint64_t v81 = 1LL;
          }
          if (v79 == 65534)
          {
            uint64_t v81 = 3LL;
LABEL_264:
            unsigned int v82 = icu::CollationFastLatin::nextPair(v13, v79, v81, a4, 0LL, (int *)&v89 + 1, &v91);
            LODWORD(v8sub_18086E18C((uint64_t)this, 1) = v82;
            if (!HIWORD(v82)) {
              goto LABEL_265;
            }
            if (v14 < (unsigned __int16)v82)
            {
              unsigned int v76 = -67044352;
              goto LABEL_246;
            }

            unsigned int v76 = v82 & 0xFFF8FFF8;
            if ((v82 & 0xFFF8FFF8) != 0) {
              goto LABEL_246;
            }
          }

          else
          {
LABEL_257:
LABEL_265:
            if (v81 >= 0x1000)
            {
              else {
                unsigned int v76 = -67044352;
              }
              goto LABEL_246;
            }

            if (v81 > v14)
            {
              unsigned int v76 = 64512;
              goto LABEL_246;
            }

            else {
              unsigned int v76 = v81 & 0xFF8;
            }
            if (v76) {
              goto LABEL_246;
            }
          }
        }

        uint64_t v80 = *(unsigned __int16 *)(a4 + 2 * v78);
LABEL_256:
        uint64_t v81 = *(unsigned __int16 *)(v13 + 2 * v80);
        goto LABEL_257;
      }

LABEL_246:
      if (v77) {
        goto LABEL_247;
      }
      while (2)
      {
        while (2)
        {
          uint64_t v83 = (int)v89;
          if ((_DWORD)v89 == v90)
          {
            unsigned int v77 = 2;
            goto LABEL_247;
          }

          LODWORD(v89) = v89 + 1;
          unsigned int v84 = *(unsigned __int16 *)(a6 + 2 * v83);
          if (v84 <= 0x17F)
          {
            uint64_t v85 = *(unsigned __int16 *)(a6 + 2 * v83);
            goto LABEL_280;
          }

          if ((v84 & 0xFFC0) == 0x2000)
          {
            uint64_t v85 = v84 - 7808;
LABEL_280:
            uint64_t v86 = *(unsigned __int16 *)(v13 + 2 * v85);
LABEL_281:
          }

          else
          {
            if (v84 == 0xFFFF) {
              uint64_t v86 = 64680LL;
            }
            else {
              uint64_t v86 = 1LL;
            }
            if (v84 != 65534) {
              goto LABEL_281;
            }
            uint64_t v86 = 3LL;
          }

          unsigned int v87 = icu::CollationFastLatin::nextPair(v13, v84, v86, a6, 0LL, (int *)&v89, &v90);
          LODWORD(v86) = v87;
          if (HIWORD(v87))
          {
            if (v14 < (unsigned __int16)v87)
            {
              unsigned int v77 = -67044352;
              goto LABEL_247;
            }

            unsigned int v77 = v87 & 0xFFF8FFF8;
            if ((v87 & 0xFFF8FFF8) != 0) {
              goto LABEL_247;
            }
            continue;
          }

          break;
        }

        if (v86 < 0x1000)
        {
          if (v86 > v14)
          {
            unsigned int v77 = 64512;
            goto LABEL_247;
          }

          else {
            unsigned int v77 = v86 & 0xFF8;
          }
          if (v77) {
            goto LABEL_247;
          }
          continue;
        }

        break;
      }

      else {
        unsigned int v77 = -67044352;
      }
LABEL_247:
      if (v76 == v77)
      {
        unsigned int v77 = 0;
        uint64_t result = 0LL;
        BOOL v15 = v76 == 2;
        unsigned int v76 = 0;
        if (v15) {
          return result;
        }
        continue;
      }

      break;
    }

    unsigned int v16 = (unsigned __int16)v76;
    if ((unsigned __int16)v76 == (unsigned __int16)v77)
    {
      if (v76 != 2)
      {
        v76 >>= 16;
        v77 >>= 16;
        continue;
      }

      return 0LL;
    }

    break;
  }

  unsigned int v43 = (unsigned __int16)v77;
LABEL_123:
  if (v16 < v43) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1LL;
  }
}

uint64_t icu::CollationFastLatin::lookup(icu::CollationFastLatin *this, const unsigned __int16 *a2)
{
  if ((_DWORD)a2 == 0xFFFF) {
    unsigned int v3 = 64680;
  }
  else {
    unsigned int v3 = 1;
  }
  if ((_DWORD)a2 == 65534) {
    return 3LL;
  }
  else {
    return v3;
  }
}

uint64_t icu::CollationFastLatin::nextPair( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, int *a7)
{
  int v7 = *a7;
  if (!a2 && v7 < 0)
  {
    *a7 = *a6 - 1;
    return 2LL;
  }

  unsigned int v8 = (a3 & 0x3FF) + 448;
  int v9 = *a6;
  if (*a6 != v7)
  {
    uint64_t v10 = v9 + 1LL;
    if (a4)
    {
      unsigned int v11 = *(unsigned __int16 *)(a4 + 2LL * v9);
      if (v11 >= 0x180)
      {
        if ((v11 & 0xFFC0) != 0x2000)
        {
          if (v11 <= 0xFFFD) {
            return 1LL;
          }
          goto LABEL_17;
        }

        v11 -= 7808;
        if (v11) {
          goto LABEL_18;
        }
LABEL_15:
        if (v7 < 0)
        {
          *a7 = v9;
LABEL_17:
          unsigned int v11 = -1;
        }

uint64_t icu::CollationFastLatin::getSecondaries(icu::CollationFastLatin *this, unsigned int a2)
{
  else {
    unsigned int v2 = 12583104;
  }
  if ((a2 & 0xF000) != 0) {
    unsigned int v2 = (a2 & 0x3E003E0) + 2097184;
  }
  if (a2 <= 0xBFF) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v4 = 192;
  }
  int v5 = ((a2 & 0x3E0) << 16) + 2097344;
  if ((a2 & 0x3E0) < 0x180) {
    int v5 = (a2 & 0x3E0) + 32;
  }
  if (a2 >= 0x1000) {
    unsigned int v4 = v5;
  }
  if (HIWORD(a2)) {
    return v2;
  }
  else {
    return v4;
  }
}

uint64_t icu::CollationFastLatin::getCases(icu::CollationFastLatin *this, int a2, unsigned int a3)
{
  if (HIWORD(a3))
  {
    if ((unsigned __int16)a3 < 0x1000u)
    {
      else {
        return 524296LL;
      }
    }

    else if (!a2 || a3 >> 26)
    {
      return a3 & 0x180018;
    }

    else
    {
      return a3 & 0x18;
    }
  }

  else
  {
    if (a3 <= 0xBFF) {
      unsigned int v3 = a3;
    }
    else {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v4 = 8;
    }
    unsigned int v5 = a3 & 0x18;
    if ((a3 & 0x380) > 0x17F && a2 == 0) {
      v5 |= 0x80000u;
    }
    if (a3 >= 0x1000) {
      return v5;
    }
    else {
      return v4;
    }
  }

uint64_t icu::CollationFastLatin::getTertiaries(icu::CollationFastLatin *this, int a2, unsigned int a3)
{
  if (HIWORD(a3))
  {
    if (a2) {
      int v10 = 2621480;
    }
    else {
      int v10 = 2097184;
    }
    unsigned int v11 = a3 & 0x70007 | v10;
    if (a2) {
      int v12 = 2031647;
    }
    else {
      int v12 = 458759;
    }
    unsigned int v13 = v12 & a3 | 0x200020;
    else {
      return v11;
    }
  }

  else
  {
    if (a3 <= 0xBFF) {
      unsigned int v3 = a3;
    }
    else {
      unsigned int v3 = 0;
    }
    if (a2) {
      int v4 = 40;
    }
    else {
      int v4 = 32;
    }
    unsigned int v5 = v4 & 0xFFFFFFF8 | a3 & 7;
    if ((a3 & 0x380) <= 0x17F) {
      int v6 = 32;
    }
    else {
      int v6 = 2097184;
    }
    int v7 = 2621472;
    if ((a3 & 0x380) <= 0x17F) {
      int v7 = 32;
    }
    unsigned int v8 = v7 | a3 & 0x1F;
    if (!a2) {
      unsigned int v8 = v6 | a3 & 7;
    }
    if (a3 >= 0x1000) {
      return v8;
    }
    else {
      return v3;
    }
  }

uint64_t icu::CollationFastLatin::getQuaternaries(icu::CollationFastLatin *this, unsigned int a2)
{
  unsigned int v2 = a2 & 0xFFF8FFF8;
  int v3 = a2 & 0xFFF8;
  if (a2 <= 0xBFF) {
    int v3 = a2;
  }
  if ((a2 & 0x380) <= 0x17F) {
    unsigned int v4 = 64512;
  }
  else {
    unsigned int v4 = -67044352;
  }
  if (a2 < 0x1000) {
    unsigned int v4 = v3;
  }
  if (HIWORD(a2)) {
    return v2;
  }
  else {
    return v4;
  }
}

uint64_t icu::CollationFastLatin::compareUTF8( icu::CollationFastLatin *this, const unsigned __int16 *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, const unsigned __int8 *a7)
{
  __int16 v9 = (__int16)a3;
  unsigned int v11 = 0;
  unsigned int v12 = 0;
  unsigned int v108 = a7;
  v109[0] = (int)a5;
  unsigned int v13 = (icu::CollationFastLatin *)((char *)this + 2 * *(unsigned __int8 *)this);
  int v14 = (icu::CollationFastLatin *)(a3 >> 16);
  unsigned int v106 = (unsigned __int16)a3;
  *(void *)__int128 v107 = 0LL;
  while (1)
  {
    while (1)
    {
      if (!v11)
      {
        while (1)
        {
          uint64_t v15 = *(int *)&v107[4];
          if (*(_DWORD *)&v107[4] == v109[0])
          {
            unsigned int v11 = 2;
            goto LABEL_3;
          }

          uint64_t v16 = *(int *)&v107[4] + 1LL;
          ++*(_DWORD *)&v107[4];
          uint64_t v17 = *(unsigned __int8 *)(a4 + v15);
          if ((v17 & 0x80) != 0)
          {
            BOOL v19 = (v17 + 58) < 0xFCu || (_DWORD)v16 == v109[0];
            if (v19 || (int v20 = *(char *)(a4 + v16), v20 > -65))
            {
              uint64_t v18 = icu::CollationFastLatin::lookupUTF8( v13,  (const unsigned __int16 *)*(unsigned __int8 *)(a4 + v15),  a4,  &v107[4],  (int *)v109[0]);
            }

            else
            {
              *(_DWORD *)&v107[4] = v15 + 2;
              uint64_t v17 = v20 + ((_DWORD)v17 << 6) - 12416;
              unsigned int v11 = a2[v17];
              uint64_t v18 = *((unsigned __int16 *)v13 + v17);
            }
          }

          else
          {
            unsigned int v11 = a2[v17];
            if (a2[v17]) {
              goto LABEL_3;
            }
            uint64_t v18 = *((unsigned __int16 *)v13 + v17);
          }

          if (v18 >= 0x1000)
          {
            unsigned int v11 = v18 & 0xFC00;
            goto LABEL_3;
          }

          Paiunint64_t r = icu::CollationFastLatin::nextPair((uint64_t)v13, v17, v18, 0LL, a4, (int *)&v107[4], v109);
          if (Pair == 1) {
            return 4294967294LL;
          }
          else {
            unsigned int v22 = 0;
          }
          else {
            unsigned int v11 = v22;
          }
          if (v11) {
            goto LABEL_3;
          }
        }

        unsigned int v11 = v18 & 0xFF8;
      }

LABEL_213:
  if (v106 < 0x3000) {
    return 0LL;
  }
  unsigned int v90 = 0;
  unsigned int v91 = 0;
  *(void *)__int128 v107 = 0LL;
  while (2)
  {
    while (2)
    {
      if (v90) {
        goto LABEL_238;
      }
      while (2)
      {
        uint64_t v92 = *(int *)&v107[4];
        if (*(_DWORD *)&v107[4] == v109[0])
        {
          unsigned int v90 = 2;
          goto LABEL_238;
        }

        ++*(_DWORD *)&v107[4];
        uint64_t v93 = *(unsigned __int8 *)(a4 + v92);
        if ((v93 & 0x80) == 0)
        {
          uint64_t v94 = *(unsigned __int8 *)(a4 + v92);
          goto LABEL_250;
        }

        if (v93 <= 0xC5)
        {
          uint64_t v95 = *(unsigned __int8 *)(a4 + v92 + 1) + (v93 << 6);
          *(_DWORD *)&v107[4] = v92 + 2;
          uint64_t v94 = v95 - 12416;
          goto LABEL_250;
        }

        uint64_t v96 = *(unsigned __int8 *)(v92 + a4 + 2);
        *(_DWORD *)&v107[4] = v92 + 3;
        if ((_DWORD)v93 == 226)
        {
          uint64_t v94 = v96 | 0x100;
LABEL_250:
          uint64_t v97 = *((unsigned __int16 *)v13 + v94);
          if (v97 <= 0xBFF)
          {
LABEL_251:
            unsigned int v98 = icu::CollationFastLatin::nextPair((uint64_t)v13, v93, v97, 0LL, a4, (int *)&v107[4], v109);
            LODWORD(v97) = v98;
            if (HIWORD(v98))
            {
              if (v14 < (unsigned __int16)v98)
              {
                unsigned int v90 = -67044352;
                goto LABEL_238;
              }

              unsigned int v90 = v98 & 0xFFF8FFF8;
              if ((v98 & 0xFFF8FFF8) != 0) {
                goto LABEL_238;
              }
              continue;
            }
          }

          if (v97 > v14)
          {
            unsigned int v90 = 64512;
            goto LABEL_238;
          }

          else {
            unsigned int v90 = v97 & 0xFF8;
          }
          if (v90) {
            goto LABEL_238;
          }
          continue;
        }

        break;
      }

      if ((_DWORD)v96 == 190)
      {
        uint64_t v97 = 3LL;
        goto LABEL_251;
      }

      LOWORD(v97) = -856;
LABEL_295:
      else {
        unsigned int v90 = -67044352;
      }
LABEL_238:
      if (v91) {
        goto LABEL_239;
      }
      while (2)
      {
        uint64_t v99 = *(int *)v107;
        if (*(_DWORD *)v107 == v108)
        {
          unsigned int v91 = 2;
          goto LABEL_239;
        }

        ++*(_DWORD *)v107;
        uint64_t v100 = *(unsigned __int8 *)(a6 + v99);
        if ((v100 & 0x80) == 0)
        {
          uint64_t v101 = *(unsigned __int8 *)(a6 + v99);
          goto LABEL_271;
        }

        if (v100 <= 0xC5)
        {
          uint64_t v102 = *(unsigned __int8 *)(a6 + v99 + 1) + (v100 << 6);
          *(_DWORD *)__int128 v107 = v99 + 2;
          uint64_t v101 = v102 - 12416;
          goto LABEL_271;
        }

        uint64_t v103 = *(unsigned __int8 *)(v99 + a6 + 2);
        *(_DWORD *)__int128 v107 = v99 + 3;
        if ((_DWORD)v100 == 226)
        {
          uint64_t v101 = v103 | 0x100;
LABEL_271:
          uint64_t v104 = *((unsigned __int16 *)v13 + v101);
          if (v104 <= 0xBFF)
          {
LABEL_272:
            unsigned int v105 = icu::CollationFastLatin::nextPair((uint64_t)v13, v100, v104, 0LL, a6, (int *)v107, (int *)&v108);
            LODWORD(v104) = v105;
            if (HIWORD(v105))
            {
              if (v14 < (unsigned __int16)v105)
              {
                unsigned int v91 = -67044352;
                goto LABEL_239;
              }

              unsigned int v91 = v105 & 0xFFF8FFF8;
              if ((v105 & 0xFFF8FFF8) != 0) {
                goto LABEL_239;
              }
              continue;
            }
          }

          if (v104 > v14)
          {
            unsigned int v91 = 64512;
            goto LABEL_239;
          }

          else {
            unsigned int v91 = v104 & 0xFF8;
          }
          if (v91) {
            goto LABEL_239;
          }
          continue;
        }

        break;
      }

      if ((_DWORD)v103 == 190)
      {
        uint64_t v104 = 3LL;
        goto LABEL_272;
      }

      LOWORD(v104) = -856;
LABEL_299:
      else {
        unsigned int v91 = -67044352;
      }
LABEL_239:
      if (v90 != v91)
      {
        unsigned int v31 = (unsigned __int16)v90;
        if ((unsigned __int16)v90 == (unsigned __int16)v91)
        {
          if (v90 != 2)
          {
            v90 >>= 16;
            v91 >>= 16;
            continue;
          }

          return 0LL;
        }

        unsigned int v50 = (unsigned __int16)v91;
        goto LABEL_119;
      }

      break;
    }

    unsigned int v91 = 0;
    uint64_t result = 0LL;
    BOOL v19 = v90 == 2;
    unsigned int v90 = 0;
    if (!v19) {
      continue;
    }
    return result;
  }

uint64_t icu::CollationFastLatin::lookupUTF8( icu::CollationFastLatin *this, const unsigned __int16 *a2, uint64_t a3, unsigned __int8 *a4, int *a5)
{
  uint64_t v5 = *(int *)a4;
  uint64_t v6 = v5 + 1;
  int v8 = *(unsigned __int8 *)(a3 + v5);
  int v9 = *(char *)(a3 + v6);
  unsigned int v10 = *(unsigned __int8 *)(a3 + v6);
  *(_DWORD *)a4 = v5 + 2;
  if ((_DWORD)a2 == 226 && v8 == 128 && v9 < 0 && v10 <= 0xBF) {
    return *((unsigned __int16 *)this + v9 + 256);
  }
  uint64_t result = 1LL;
  if ((_DWORD)a2 == 239 && v8 == 191)
  {
    if (v10 == 190)
    {
      return 3LL;
    }

    else if (v10 == 191)
    {
      return 64680LL;
    }
  }

  return result;
}

uint64_t icu::CollationFastLatin::lookupUTF8Unsafe( icu::CollationFastLatin *this, const unsigned __int16 *a2, uint64_t a3, unsigned __int8 *a4, int *a5)
{
  if ((int)a2 > 197)
  {
    uint64_t v7 = *(int *)a4;
    uint64_t v8 = *(unsigned __int8 *)(v7 + a3 + 1);
    *(_DWORD *)a4 = v7 + 2;
    if ((_DWORD)a2 == 226)
    {
      return *((unsigned __int16 *)this + v8 + 256);
    }

    else if ((_DWORD)v8 == 190)
    {
      return 3LL;
    }

    else
    {
      return 64680LL;
    }
  }

  else
  {
    uint64_t v5 = *(int *)a4;
    *(_DWORD *)a4 = v5 + 1;
    return *((unsigned __int16 *)this + 64 * (int)a2 + *(unsigned __int8 *)(a3 + v5) - 12416);
  }

icu::CollationFastLatinBuilder *icu::CollationFastLatinBuilder::CollationFastLatinBuilder( icu::CollationFastLatinBuilder *this, UErrorCode *a2)
{
  *(void *)this = off_18971FD68;
  *(_OWORD *)((char *)this + 8) = 0u;
  icu::UVector64::UVector64((icu::CollationFastLatinBuilder *)((char *)this + 7192), a2);
  icu::UVector64::UVector64((icu::CollationFastLatinBuilder *)((char *)this + 7224), a2);
  *((void *)this + 907) = 0LL;
  *((_OWORD *)this + 455) = 0u;
  *((_BYTE *)this + 7296) = 0;
  *((void *)this + 913) = off_18971B688;
  *((_WORD *)this + 3656) = 2;
  *((_DWORD *)this + 1842) = 0;
  return this;
}

void icu::CollationFastLatinBuilder::~CollationFastLatinBuilder(void **this)
{
  *this = off_18971FD68;
  uprv_free(this[907]);
  icu::UnicodeString::~UnicodeString((void *)0x1C88, (icu::UnicodeString *)(this + 913));
  icu::UVector64::~UVector64(this + 903);
  icu::UVector64::~UVector64(this + 899);
  icu::UObject::~UObject((icu::UObject *)this);
}

{
  void *v1;
  icu::CollationFastLatinBuilder::~CollationFastLatinBuilder(this);
  icu::UMemory::operator delete(v1);
}

BOOL icu::CollationFastLatinBuilder::forData( icu::CollationFastLatinBuilder *this, const icu::CollationData *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    if (*((unsigned __int16 *)this + 3656) >= 0x20u)
    {
      BOOL v3 = 0LL;
      *a3 = U_INVALID_STATE_ERROR;
      return v3;
    }

    if (icu::CollationFastLatinBuilder::loadGroups(this, a2, a3))
    {
      *((_DWORD *)this + 1823) = *((_DWORD *)this + 1820);
      icu::CollationFastLatinBuilder::getCEs((uint64_t)this, a2, a3);
      if (icu::CollationFastLatinBuilder::encodeUniqueCEs((void **)this, a3))
      {
        if (!*((_BYTE *)this + 7296))
        {
LABEL_11:
          if (icu::CollationFastLatinBuilder::encodeCharCEs(this, a3))
          {
            BOOL v3 = icu::CollationFastLatinBuilder::encodeContractions(this, a3) != 0;
LABEL_14:
            icu::UVector64::removeAllElements((uint64_t)this + 7192);
            icu::UVector64::removeAllElements((uint64_t)this + 7224);
            return v3;
          }

uint64_t icu::CollationFastLatinBuilder::loadGroups( icu::CollationFastLatinBuilder *this, const icu::CollationData *a2, UErrorCode *a3)
{
  *((_DWORD *)this + 1842) = 5;
  uint64_t v6 = (char *)this + 7304;
  __int16 v8 = 517;
  icu::UnicodeString::doAppend((uint64_t)this + 7304, (uint64_t)&v8, 0, 1LL);
  uint64_t v7 = 0LL;
  while (1)
  {
    uint64_t result = icu::CollationData::getLastPrimaryForGroup(a2, (int)v7 + 4096);
    *((_DWORD *)this + v7 + 1816) = result;
    if (!(_DWORD)result) {
      break;
    }
    __int16 v9 = 0;
    icu::UnicodeString::doAppend((uint64_t)v6, (uint64_t)&v9, 0, 1LL);
    if (++v7 == 4)
    {
      *((_DWORD *)this + 1820) = icu::CollationData::getFirstPrimaryForGroup(a2, 0x1004u);
      *((_DWORD *)this + 182sub_18086E18C((uint64_t)this, 1) = icu::CollationData::getFirstPrimaryForGroup(a2, 0x19u);
      *((_DWORD *)this + 1822) = icu::CollationData::getLastPrimaryForGroup(a2, 0x19u);
      if (!*((_DWORD *)this + 1820)) {
        return 0LL;
      }
      return *((_DWORD *)this + 1821) != 0;
    }
  }

  return result;
}

uint64_t icu::CollationFastLatinBuilder::getCEs(uint64_t this, const icu::CollationData *a2, UErrorCode *a3)
{
  uint64_t v5 = this;
  unsigned __int16 v6 = 0;
  uint64_t v7 = 24LL;
  while (v6 == 384)
  {
    unsigned __int16 v6 = 0x2000;
LABEL_7:
    __int16 v8 = (icu::Collation *)v6;
    uint64_t v9 = sub_1808A22C4((uint64_t *)a2, v6);
    unsigned int v10 = (uint64_t *)a2;
    if ((_DWORD)v9 == 192)
    {
      unsigned int v10 = (uint64_t *)*((void *)a2 + 4);
      uint64_t v9 = sub_1808A22C4(v10, v8);
    }

    this = icu::CollationFastLatinBuilder::getCEsFromCE32( (icu::CollationFastLatinBuilder *)v5,  (const icu::CollationData *)v10,  v8,  v9,  a3);
    if ((_DWORD)this)
    {
      __int128 v11 = *(_OWORD *)(v5 + 8);
      *(_OWORD *)(v5 + v7) = v11;
      icu::CollationFastLatinBuilder::addUniqueCE((_DWORD *)v5, v11, a3);
      this = (uint64_t)icu::CollationFastLatinBuilder::addUniqueCE((_DWORD *)v5, *(void *)(v5 + 16), a3);
      if ((_DWORD)v8) {
        goto LABEL_16;
      }
    }

    else
    {
      *(_OWORD *)(v5 + 8) = xmmword_180A333C0;
      *(_OWORD *)(v5 + v7) = xmmword_180A333C0;
      if ((_DWORD)v8) {
        goto LABEL_16;
      }
    }

    unint64_t v12 = *(void *)(v5 + 8);
    if (v12 == 0x101000100LL || (v12 & 0xFFFFFFFF00000000LL) != 0x100000000LL)
    {
      this = (uint64_t)icu::CollationFastLatinBuilder::addContractionEntry( (icu::CollationFastLatinBuilder *)v5,  511,  v12,  *(void *)(v5 + 16),  a3);
      *(_OWORD *)(v5 + 24) = xmmword_180A333D0;
    }

void *icu::CollationFastLatinBuilder::encodeUniqueCEs(void **this, UErrorCode *a2)
{
  uint64_t result = uprv_malloc(2LL * *((int *)this + 1808));
  this[907] = result;
  if (result)
  {
    uint64_t v23 = a2;
    if (*((int *)this + 1808) >= 1)
    {
      uint64_t v5 = 0LL;
      unsigned int v6 = 0;
      unsigned int v7 = 0;
      unsigned int v8 = 0;
      uint64_t v9 = 0LL;
      unint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
      unsigned int v12 = *((_DWORD *)this + 1816);
      while (1)
      {
        unint64_t v13 = *((void *)this[906] + v5);
        unint64_t v14 = HIDWORD(v13);
        if ((_DWORD)v10 == HIDWORD(v13))
        {
          uint64_t v15 = v11;
          unint64_t v14 = v10;
          uint64_t v16 = v9;
          goto LABEL_32;
        }

        if (v12 >= HIDWORD(v13))
        {
          uint64_t v15 = v11;
        }

        else
        {
          uint64_t v25 = v9;
          unsigned int v26 = v7;
          unsigned int v27 = v6;
          uint64_t v17 = (int)v11;
          int v18 = (int)v11 <= 3 ? 3 : v11;
          unsigned int v24 = v18 + 1;
          uint64_t v19 = v17 - (int)v11;
          int v20 = (unsigned int *)this + (int)v11 + 1817;
          while (1)
          {
            uint64_t v11 = (v11 + 1);
            icu::UnicodeString::setCharAt((icu::UnicodeString *)(this + 913), v11, v8);
            if (!v19) {
              break;
            }
            unsigned int v21 = *v20++;
            unsigned int v12 = v21;
            --v19;
            if (v21 >= HIDWORD(v13))
            {
              uint64_t v15 = v11;
              unsigned int v7 = v26;
              unsigned int v6 = v27;
              goto LABEL_20;
            }
          }

          unsigned int v12 = -1;
          unsigned int v7 = v26;
          unsigned int v6 = v27;
          uint64_t v15 = v24;
LABEL_20:
          uint64_t v9 = v25;
        }

        if (*((_DWORD *)this + 1823) > HIDWORD(v13)) {
          break;
        }
        if (v8 >= 0x1000)
        {
          if (v8 >> 11 > 0x1E)
          {
            __int16 v22 = 1;
            *((_BYTE *)this + 7296) = 1;
            goto LABEL_56;
          }

          unsigned int v6 = 0;
          v8 += 1024;
LABEL_29:
          unsigned int v7 = 160;
          goto LABEL_31;
        }

        unsigned int v6 = 0;
        unsigned int v7 = 160;
        unsigned int v8 = 4096;
LABEL_31:
        uint64_t v16 = 1280LL;
LABEL_32:
        uint64_t v9 = WORD1(v13);
        if (WORD1(v13) == (_DWORD)v16)
        {
          uint64_t v9 = v16;
        }

        else
        {
          if (!v8)
          {
            if (!v7)
            {
              unsigned int v6 = 0;
              unsigned int v7 = 384;
              goto LABEL_34;
            }

            if (v7 > 0x3DF)
            {
              unsigned int v8 = 0;
LABEL_59:
              __int16 v22 = 1;
              uint64_t v9 = v16;
              goto LABEL_60;
            }

            goto LABEL_52;
          }

          if (BYTE3(v13) > 4u)
          {
            if (WORD1(v13) != 1280)
            {
              if (v7 < 0xC0)
              {
                unsigned int v6 = 0;
                unsigned int v7 = 192;
                goto LABEL_34;
              }

              if (v7 > 0x15F) {
                goto LABEL_59;
              }
              goto LABEL_52;
            }

            unsigned int v6 = 0;
            unsigned int v7 = 160;
            uint64_t v9 = 1280LL;
          }

          else
          {
            if (v7 != 160)
            {
              if (v7 > 0x7F) {
                goto LABEL_59;
              }
LABEL_52:
              unsigned int v6 = 0;
              v7 += 32;
              goto LABEL_34;
            }

            unsigned int v7 = 0;
            unsigned int v6 = 0;
          }
        }

uint64_t icu::CollationFastLatinBuilder::resetCEs(icu::CollationFastLatinBuilder *this)
{
  uint64_t result = icu::UVector64::removeAllElements((uint64_t)this + 7224);
  *((_BYTE *)this + 7296) = 0;
  int v3 = *((_DWORD *)this + 1842);
  unsigned int v4 = *((unsigned __int16 *)this + 3656);
  if (v3) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = (v4 & 1) == 0;
  }
  if (!v5) {
    return icu::UnicodeString::unBogus((uint64_t)this + 7304);
  }
  if ((v4 & 0x8000) != 0) {
    unsigned int v6 = *((_DWORD *)this + 1829);
  }
  else {
    unsigned int v6 = v4 >> 5;
  }
  if (v6 > v3)
  {
    if (v3 > 1023)
    {
      *((_WORD *)this + 3656) = v4 | 0xFFE0;
      *((_DWORD *)this + 1829) = v3;
    }

    else
    {
      *((_WORD *)this + 3656) = *((_WORD *)this + 3656) & 0x1F | (32 * v3);
    }
  }

  return result;
}

BOOL icu::CollationFastLatinBuilder::encodeCharCEs(icu::CollationFastLatinBuilder *this, UErrorCode *a2)
{
  BOOL v5 = (icu::CollationFastLatinBuilder *)((char *)this + 7304);
  else {
    int v6 = *((unsigned __int16 *)this + 3656) >> 5;
  }
  int v7 = 448;
  do
  {
    __int16 v17 = 0;
    icu::UnicodeString::doAppend((uint64_t)v5, (uint64_t)&v17, 0, 1LL);
    --v7;
  }

  while (v7);
  else {
    int v8 = *((unsigned __int16 *)this + 3656) >> 5;
  }
  uint64_t v9 = -7168LL;
  do
  {
    uint64_t v10 = *(void *)((char *)this + v9 + 7192);
    if (v10 == 0x101000100LL || (v10 & 0xFFFFFFFF00000000LL) != 0x100000000LL)
    {
      unsigned int v12 = icu::CollationFastLatinBuilder::encodeTwoCEs(this, v10, *(void *)((char *)this + v9 + 7200));
      __int16 v13 = v12;
      if (v12 >= 0x10000)
      {
        else {
          int v14 = *((unsigned __int16 *)this + 3656) >> 5;
        }
        __int16 v15 = v14 - v8;
        if (v14 - v8 <= 1023)
        {
          __int16 v18 = HIWORD(v12);
          uint64_t v16 = icu::UnicodeString::doAppend((uint64_t)v5, (uint64_t)&v18, 0, 1LL);
          __int16 v19 = v13;
          icu::UnicodeString::doAppend(v16, (uint64_t)&v19, 0, 1LL);
          __int16 v13 = v15 | 0x800;
        }

        else
        {
          __int16 v13 = 1;
        }
      }

      icu::UnicodeString::setCharAt(v5, v6, v13);
    }

    ++v6;
    v9 += 16LL;
  }

  while (v9);
  return *a2 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t icu::CollationFastLatinBuilder::encodeContractions( icu::CollationFastLatinBuilder *this, UErrorCode *a2)
{
  unsigned int v4 = (icu::CollationFastLatinBuilder *)((char *)this + 7304);
  else {
    int v5 = *((unsigned __int16 *)this + 3656) >> 5;
  }
  int v26 = v5;
  uint64_t v6 = 0LL;
  int v7 = *((_DWORD *)this + 1842);
  do
  {
    uint64_t v8 = *((void *)this + 2 * v6 + 3);
    if (v8 != 0x101000100LL && (v8 & 0xFFFFFFFF00000000LL) == 0x100000000LL)
    {
      else {
        int v10 = *((unsigned __int16 *)this + 3656) >> 5;
      }
      int v11 = v10 - v7 - 448;
      if (v11 >= 1024)
      {
        icu::UnicodeString::setCharAt(v4, *((_DWORD *)this + 1842) + v6, 1);
        goto LABEL_35;
      }

      uint64_t v12 = *((void *)this + 2 * v6 + 3) & 0x7FFFFFFFLL;
      for (int i = 1; ; int i = 0)
      {
        uint64_t v14 = *((int *)this + 1800);
        if (v12 >= v14)
        {
          LOWORD(v15) = 0;
        }

        else
        {
          uint64_t v15 = *(unsigned int *)(*((void *)this + 902) + 8 * v12);
          if (((v15 == 511) & ~i) != 0)
          {
            icu::UnicodeString::setCharAt(v4, *((_DWORD *)this + 1842) + v6, v11 | 0x400);
            goto LABEL_35;
          }
        }

        uint64_t v16 = (int)v14 <= (int)v12 + 1 ? 0LL : *(void *)(*((void *)this + 902) + 8 * v12 + 8);
        uint64_t v17 = (int)v14 <= (int)v12 + 2 ? 0LL : *(void *)(*((void *)this + 902) + 8 * v12 + 16);
        unsigned int v18 = icu::CollationFastLatinBuilder::encodeTwoCEs(this, v16, v17);
        if (v18 == 1) {
          break;
        }
        __int16 v20 = v18;
        unsigned int v21 = HIWORD(v18);
        if (!HIWORD(v18))
        {
          __int16 v28 = v15 | 0x400;
          icu::UnicodeString::doAppend((uint64_t)v4, (uint64_t)&v28, 0, 1LL);
          __int16 v29 = v20;
          __int16 v19 = &v29;
          goto LABEL_32;
        }

        __int16 v30 = v15 | 0x600;
        icu::UnicodeString::doAppend((uint64_t)v4, (uint64_t)&v30, 0, 1LL);
        __int16 v31 = v21;
        uint64_t v22 = icu::UnicodeString::doAppend((uint64_t)v4, (uint64_t)&v31, 0, 1LL);
        __int16 v32 = v20;
        __int16 v19 = &v32;
LABEL_34:
        icu::UnicodeString::doAppend(v22, (uint64_t)v19, 0, 1LL);
        v12 += 3LL;
      }

      __int16 v27 = v15 | 0x200;
      __int16 v19 = &v27;
LABEL_32:
      uint64_t v22 = (uint64_t)v4;
      goto LABEL_34;
    }

BOOL icu::CollationFastLatinBuilder::inSameGroup( icu::CollationFastLatinBuilder *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = *((_DWORD *)this + 1823);
  if (v3 <= a2) {
    return v3 <= a3;
  }
  if (v3 <= a3) {
    return 0LL;
  }
  unsigned int v4 = *((_DWORD *)this + 1819);
  BOOL v5 = v4 < a3 && v4 < a2;
  if (v4 >= a2 && v4 >= a3)
  {
    unsigned int v7 = *((_DWORD *)this + 1816);
    if (v7 >= a2) {
      return v7 >= a3;
    }
    uint64_t v8 = (unsigned int *)((char *)this + 7268);
    while (v7 < a3)
    {
      unsigned int v9 = *v8++;
      unsigned int v7 = v9;
      if (v9 >= a2) {
        return v7 >= a3;
      }
    }

    return 0LL;
  }

  return v5;
}

uint64_t icu::CollationFastLatinBuilder::getCEsFromCE32( icu::CollationFastLatinBuilder *this, const icu::CollationData *a2, icu::Collation *a3, uint64_t a4, UErrorCode *a5)
{
  unsigned int FinalCE32 = icu::CollationData::getFinalCE32(a2, a4);
  unsigned int v11 = FinalCE32;
  *((void *)this + 2) = 0LL;
  int v12 = FinalCE32 & 0xF;
  if ((~FinalCE32 & 0xC0) == 0 && (v12 - 3) < 0xFFFFFFFE)
  {
    uint64_t result = 0LL;
    switch(v12)
    {
      case 4:
        unint64_t v13 = (unsigned __int16)(v11 >> 8) & 0xFF00 | ((unint64_t)((v11 & 0xFF000000) >> 24) << 56) | 0x5000000;
        *((void *)this + sub_18086E18C((uint64_t)this, 1) = v13;
        *((void *)this + 2) = (BYTE1(v11) << 24) | 0x500u;
        goto LABEL_15;
      case 5:
        unsigned int v20 = (v11 >> 8) & 0x1F;
        if (v20 > 2) {
          return 0LL;
        }
        unsigned int v21 = (int *)(*((void *)a2 + 1) + 4LL * (v11 >> 13));
        unint64_t v13 = sub_1808B0B88(*v21);
        *((void *)this + sub_18086E18C((uint64_t)this, 1) = v13;
        if (v20 == 2)
        {
          *((void *)this + 2) = sub_1808B0B88(v21[1]);
          unint64_t v13 = *((void *)this + 1);
        }

        goto LABEL_14;
      case 6:
        unsigned int v22 = (v11 >> 8) & 0x1F;
        if (v22 > 2) {
          return 0LL;
        }
        unsigned int v23 = (unint64_t *)(*((void *)a2 + 2) + 8LL * (v11 >> 13));
        unint64_t v13 = *v23;
        *((void *)this + sub_18086E18C((uint64_t)this, 1) = *v23;
        if (v22 == 2) {
          *((void *)this + 2) = v23[1];
        }
        goto LABEL_14;
      case 9:
        return icu::CollationFastLatinBuilder::getCEsFromContractionCE32(this, a2, v11, a5);
      case 14:
        unint64_t v13 = (icu::Collation::getThreeBytePrimaryForOffsetData( a3,  *(void *)(*((void *)a2 + 2) + 8LL * (v11 >> 13))) << 32) | 0x5000500;
        *((void *)this + sub_18086E18C((uint64_t)this, 1) = v13;
        goto LABEL_15;
      default:
        return result;
    }
  }

  BOOL v19 = v12 == 1;
  unint64_t v14 = ((unint64_t)(FinalCE32 & 0xFFFFFF00) << 32) | 0x5000500;
  if (!v19) {
    unint64_t v14 = FinalCE32 & 0xFFFFFF00;
  }
  else {
    unint64_t v13 = v14;
  }
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = v13;
LABEL_14:
  if (!v13) {
    return *((void *)this + 2) == 0LL;
  }
LABEL_15:
  if (!HIDWORD(v13) || *((_DWORD *)this + 1822) < HIDWORD(v13)) {
    return 0LL;
  }
  uint64_t result = 0LL;
  unsigned int v15 = *((_DWORD *)this + 1823);
  BOOL v17 = v13 >> 14 != 5120 && v15 > HIDWORD(v13);
  if ((v13 & 0x3F00) >= 0x500 && !v17)
  {
    uint64_t v18 = *((void *)this + 2);
    if (!v18) {
      return ((v18 | v13) & 0xC0LL) == 0;
    }
    if (HIDWORD(v18))
    {
      uint64_t result = icu::CollationFastLatinBuilder::inSameGroup(this, HIDWORD(v13), HIDWORD(v18));
      if (!(_DWORD)result) {
        return result;
      }
      goto LABEL_46;
    }

    uint64_t result = 0LL;
    if (v15 <= HIDWORD(v13) && v18 >= 0x10000)
    {
LABEL_46:
      return 0LL;
    }
  }

  return result;
}

_DWORD *icu::CollationFastLatinBuilder::addUniqueCE(_DWORD *this, unint64_t a2, UErrorCode *a3)
{
  if (HIDWORD(a2) == 1 || a2 == 0 || *a3 > U_ZERO_ERROR) {
    return this;
  }
  unint64_t v5 = a2 & 0xFFFFFFFFFFFF3FFFLL;
  int v6 = this[1808];
  if (!v6)
  {
    int v9 = -1;
    return icu::UVector64::insertElementAt(this + 1806, v5, ~v9, a3);
  }

  uint64_t v7 = *((void *)this + 906);
  if (v6 >= 0) {
    int v8 = this[1808];
  }
  else {
    int v8 = v6 + 1;
  }
  int v9 = v8 >> 1;
  unint64_t v10 = *(void *)(v7 + 8LL * v9);
  if (v10 == v5)
  {
LABEL_26:
    if (v9 < 0) {
      return icu::UVector64::insertElementAt(this + 1806, v5, ~v9, a3);
    }
    return this;
  }

  int v11 = 0;
  while (v10 > v5)
  {
    if (v9 == v11)
    {
      int v9 = ~v9;
      goto LABEL_26;
    }

    int v6 = v9;
LABEL_20:
    int v12 = v11 + v6;
    if (v11 + v6 < 0 != __OFADD__(v11, v6)) {
      ++v12;
    }
    int v9 = v12 >> 1;
    unint64_t v10 = *(void *)(v7 + 8LL * v9);
    if (v10 == v5) {
      goto LABEL_26;
    }
  }

  if (v9 != v11)
  {
    int v11 = v9;
    goto LABEL_20;
  }

  int v9 = -2 - v9;
  if (v9 < 0) {
    return icu::UVector64::insertElementAt(this + 1806, v5, ~v9, a3);
  }
  return this;
}

_DWORD *icu::CollationFastLatinBuilder::addContractionEntry( icu::CollationFastLatinBuilder *this, int a2, unint64_t a3, unint64_t a4, UErrorCode *a5)
{
  unint64_t v10 = (icu::CollationFastLatinBuilder *)((char *)this + 7192);
  int v11 = *((_DWORD *)this + 1800);
  int v12 = v11 + 1;
  if (v11 >= -1 && *((_DWORD *)this + 1801) > v11) {
    goto LABEL_5;
  }
  int v13 = icu::UVector64::expandCapacity((icu::CollationFastLatinBuilder *)((char *)this + 7192), v12, a5);
  int v11 = *((_DWORD *)this + 1800);
  if (v13)
  {
    int v12 = v11 + 1;
LABEL_5:
    *(void *)(*((void *)this + 902) + 8LL * v1sub_18086E18C((uint64_t)this, 1) = a2;
    *((_DWORD *)this + 1800) = v12;
    int v11 = v12;
  }

  int v14 = v11 + 1;
  if (v11 >= -1 && *((_DWORD *)this + 1801) > v11) {
    goto LABEL_10;
  }
  int v15 = icu::UVector64::expandCapacity(v10, v14, a5);
  int v11 = *((_DWORD *)this + 1800);
  if (v15)
  {
    int v14 = v11 + 1;
LABEL_10:
    *(void *)(*((void *)this + 902) + 8LL * v1sub_18086E18C((uint64_t)this, 1) = a3;
    *((_DWORD *)this + 1800) = v14;
    int v11 = v14;
  }

  int v16 = v11 + 1;
  if (v11 >= -1 && *((_DWORD *)this + 1801) > v11) {
    goto LABEL_15;
  }
  if (icu::UVector64::expandCapacity(v10, v16, a5))
  {
    int v11 = *((_DWORD *)this + 1800);
    int v16 = v11 + 1;
LABEL_15:
    *(void *)(*((void *)this + 902) + 8LL * v1sub_18086E18C((uint64_t)this, 1) = a4;
    *((_DWORD *)this + 1800) = v16;
  }

  icu::CollationFastLatinBuilder::addUniqueCE(this, a3, a5);
  return icu::CollationFastLatinBuilder::addUniqueCE(this, a4, a5);
}

unint64_t sub_1808B0B88(int a1)
{
  uint64_t v1 = a1 & 0xFFFFFF00;
  if ((a1 & 0xF) == 1) {
    uint64_t v1 = (v1 << 32) | 0x5000500;
  }
  else {
    return v1;
  }
}

uint64_t icu::CollationFastLatinBuilder::getCEsFromContractionCE32( icu::CollationFastLatinBuilder *this, const icu::CollationData *a2, unsigned int a3, UErrorCode *a4)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  int v8 = (unsigned __int16 *)(*((void *)a2 + 3) + 2LL * (a3 >> 13));
  uint64_t v9 = *((int *)this + 1800);
  if (icu::CollationFastLatinBuilder::getCEsFromCE32(this, a2, -1, v8[1] | (*v8 << 16), a4))
  {
    unint64_t v10 = *((void *)this + 1);
    unint64_t v11 = *((void *)this + 2);
    int v12 = this;
  }

  else
  {
    int v12 = this;
    unint64_t v10 = 0x101000100LL;
    unint64_t v11 = 0LL;
  }

  icu::CollationFastLatinBuilder::addContractionEntry(v12, 511, v10, v11, a4);
  uint64_t v30 = 0LL;
  __int128 v28 = 0u;
  *(_OWORD *)__int16 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  memset(v25, 0, sizeof(v25));
  uint64_t v24 = (uint64_t)(v8 + 2);
  icu::UCharsTrie::Iterator::Iterator(v25, &v24, 0LL, a4);
  uint64_t v23 = v24;
  int v13 = 0;
  uint64_t v14 = 0xFFFFFFFFLL;
  do
  {
    int v15 = (uint64_t *)(unsigned __int16)v26;
    int v16 = (unsigned __int16)v26 >> 5;
    int v17 = DWORD1(v26);
    if ((v26 & 0x8000u) == 0LL) {
      int v18 = (unsigned __int16)v26 >> 5;
    }
    else {
      int v18 = DWORD1(v26);
    }
    if (v18)
    {
      BOOL v19 = (unsigned __int16 *)v27;
      if ((v26 & 2) != 0) {
        BOOL v19 = (unsigned __int16 *)&v26 + 1;
      }
      uint64_t v20 = *v19;
      if ((v20 & 0xFFC0) == 0x2000 && v20 >> 7 >= 0x3D)
      {
        uint64_t v20 = (v20 - 7808);
LABEL_18:
        if ((_DWORD)v20 == (_DWORD)v14)
        {
          if (!v13) {
            continue;
          }
          uint64_t v20 = v14;
        }

        else
        {
          if (v13)
          {
            icu::CollationFastLatinBuilder::addContractionEntry( this,  v14,  *((void *)this + 1),  *((void *)this + 2),  a4);
            LOWORD(v15) = v26;
            int v17 = DWORD1(v26);
            int v16 = (unsigned __int16)v26 >> 5;
          }

          else {
            int v21 = v17;
          }
          if (v21 == 1 && icu::CollationFastLatinBuilder::getCEsFromCE32(this, a2, -1, v29[3], a4))
          {
            int v13 = 1;
LABEL_30:
            uint64_t v14 = v20;
            continue;
          }
        }

        icu::CollationFastLatinBuilder::addContractionEntry(this, v20, 0x101000100uLL, 0LL, a4);
        int v13 = 0;
        goto LABEL_30;
      }
    }
  }

  while (icu::UCharsTrie::Iterator::next(v15, (icu::UCharsTrie::Iterator *)v25, a4));
  if (v13) {
    icu::CollationFastLatinBuilder::addContractionEntry(this, v14, *((void *)this + 1), *((void *)this + 2), a4);
  }
LABEL_34:
  if (*(int *)a4 <= 0)
  {
    *((void *)this + sub_18086E18C((uint64_t)this, 1) = v9 | 0x180000000LL;
    *((void *)this + 2) = 0LL;
    uint64_t v4 = 1LL;
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v25);
  return v4;
}

uint64_t icu::CollationFastLatinBuilder::getMiniCE(icu::CollationFastLatinBuilder *this, uint64_t a2)
{
  int v2 = *((_DWORD *)this + 1808);
  if (v2)
  {
    unint64_t v3 = a2 & 0xFFFFFFFFFFFF3FFFLL;
    uint64_t v4 = *((void *)this + 906);
    if (v2 >= 0) {
      int v5 = *((_DWORD *)this + 1808);
    }
    else {
      int v5 = v2 + 1;
    }
    int v6 = v5 >> 1;
    unint64_t v7 = *(void *)(v4 + 8LL * v6);
    if (v7 != v3)
    {
      int v8 = 0;
      do
      {
        if (v7 <= v3)
        {
          if (v6 == v8)
          {
            int v6 = -2 - v6;
            return *(unsigned __int16 *)(*((void *)this + 907) + 2LL * v6);
          }

          int v8 = v6;
        }

        else
        {
          if (v6 == v8)
          {
            int v6 = ~v6;
            return *(unsigned __int16 *)(*((void *)this + 907) + 2LL * v6);
          }

          int v2 = v6;
        }

        int v9 = v8 + v2;
        if (v8 + v2 < 0 != __OFADD__(v8, v2)) {
          ++v9;
        }
        int v6 = v9 >> 1;
        unint64_t v7 = *(void *)(v4 + 8LL * v6);
      }

      while (v7 != v3);
    }
  }

  else
  {
    int v6 = -1;
  }

  return *(unsigned __int16 *)(*((void *)this + 907) + 2LL * v6);
}

uint64_t icu::CollationFastLatinBuilder::encodeTwoCEs( icu::CollationFastLatinBuilder *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (a2 == 0x101000100LL) {
      return 1LL;
    }
    unsigned int MiniCE = icu::CollationFastLatinBuilder::getMiniCE(this, a2);
    if (MiniCE == 1) {
      return 1LL;
    }
    unsigned int v7 = ((v3 >> 11) & 0x18) + 8;
    if (MiniCE <= 0xFFF) {
      unsigned int v7 = 0;
    }
    uint64_t v3 = v7 | MiniCE;
    if (a3)
    {
      unsigned int v8 = icu::CollationFastLatinBuilder::getMiniCE(this, a3);
      if (v8 == 1) {
        return 1LL;
      }
      unsigned int v10 = a3 & 0xC000;
      if (v3 < 0x1000 || (v3 & 0x3E0) != 0xA0 || (v8 & 0x3E0) < 0x180 || v8 & 7 | v10)
      {
        int v11 = (v10 >> 11) + 8;
        if (v8 - 4096 >= 0xFFFFF3E1) {
          int v11 = 0;
        }
        return v11 | ((_DWORD)v3 << 16) | v8;
      }

      else
      {
        return v8 & 0x3E0 | v3 & 0xFC1F;
      }
    }
  }

  return v3;
}

void icu::CollationIterator::CEBuffer::~CEBuffer(void **this)
{
  if (*((_BYTE *)this + 20)) {
    uprv_free(this[1]);
  }
}

{
  if (*((_BYTE *)this + 20)) {
    uprv_free(this[1]);
  }
}

uint64_t icu::CollationIterator::CEBuffer::ensureAppendCapacity( icu::CollationIterator::CEBuffer *this, int a2, UErrorCode *a3)
{
  int v3 = *((_DWORD *)this + 4);
  int v4 = *(_DWORD *)this;
  int v5 = *(_DWORD *)this + a2;
  if (v5 <= v3) {
    return 1LL;
  }
  do
  {
    int v9 = v3;
    if (v3 >= 1000) {
      char v10 = 1;
    }
    else {
      char v10 = 2;
    }
    v3 <<= v10;
  }

  while (v3 < v5);
  if (v9 >= 1 && (int v11 = uprv_malloc(8LL * v3)) != 0LL)
  {
    int v12 = v11;
    if (v4 >= 1)
    {
      int v13 = *((_DWORD *)this + 4);
      if (v13 >= v4) {
        int v13 = v4;
      }
      if (v13 >= v3) {
        int v13 = v3;
      }
      memcpy(v11, *((const void **)this + 1), 8LL * v13);
    }

    if (*((_BYTE *)this + 20)) {
      uprv_free(*((void **)this + 1));
    }
    *((void *)this + sub_18086E18C((uint64_t)this, 1) = v12;
    *((_DWORD *)this + 4) = v3;
    uint64_t result = 1LL;
    *((_BYTE *)this + 20) = 1;
  }

  else
  {
    uint64_t result = 0LL;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }

  return result;
}

uint64_t icu::CollationIterator::CollationIterator(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_18971FDA8;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 24) = 0;
  int v3 = (_DWORD *)(a1 + 24);
  *(void *)(a1 + 32) = a1 + 48;
  *(_DWORD *)(a1 + 40) = 40;
  *(_BYTE *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 368) = *(_DWORD *)(a2 + 368);
  *(void *)(a1 + 376) = 0LL;
  *(_DWORD *)(a1 + 384) = *(_DWORD *)(a2 + 384);
  *(_BYTE *)(a1 + 388) = *(_BYTE *)(a2 + 388);
  UErrorCode v11 = U_ZERO_ERROR;
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  if ((int)v4 >= 1
    && icu::CollationIterator::CEBuffer::ensureAppendCapacity( (icu::CollationIterator::CEBuffer *)(a1 + 24),  *(_DWORD *)(a2 + 24),  &v11))
  {
    int v6 = *(uint64_t **)(a2 + 32);
    unsigned int v7 = *(void **)(a1 + 32);
    uint64_t v8 = v4;
    do
    {
      uint64_t v9 = *v6++;
      *v7++ = v9;
      --v8;
    }

    while (v8);
    *int v3 = v4;
  }

  else
  {
    *(_DWORD *)(a1 + 368) = 0;
  }

  return a1;
}

void icu::CollationIterator::~CollationIterator(icu::CollationIterator *this)
{
  *(void *)this = off_18971FDA8;
  uint64_t v2 = *((void *)this + 47);
  if (v2)
  {
    icu::UnicodeString::~UnicodeString(off_18971FDA8, (icu::UnicodeString *)(v2 + 72));
    icu::UnicodeString::~UnicodeString(v3, (icu::UnicodeString *)(v2 + 8));
    icu::UMemory::operator delete((void *)v2);
  }

  if (*((_BYTE *)this + 44)) {
    uprv_free(*((void **)this + 4));
  }
  icu::UObject::~UObject(this);
}

uint64_t icu::CollationIterator::operator==(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    __cxa_bad_typeid();
  }
  uint64_t result = sub_1807F874C(*(void *)(*(void *)a1 - 8LL), *(void *)(*(void *)a2 - 8LL));
  if ((_DWORD)result)
  {
    unint64_t v5 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v5 != *(_DWORD *)(a2 + 24)
      || *(_DWORD *)(a1 + 368) != *(_DWORD *)(a2 + 368)
      || *(_DWORD *)(a1 + 384) != *(_DWORD *)(a2 + 384)
      || *(unsigned __int8 *)(a1 + 388) != *(unsigned __int8 *)(a2 + 388))
    {
      return 0LL;
    }

    int v6 = *(void **)(a1 + 32);
    unsigned int v7 = *(void **)(a2 + 32);
    if (*v6 == *v7)
    {
      uint64_t v8 = 1LL;
      do
      {
        unint64_t v9 = v8;
        if (v5 == v8) {
          break;
        }
        uint64_t v10 = v6[v8];
        uint64_t v11 = v7[v8++];
      }

      while (v10 == v11);
      return v9 >= v5;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t icu::CollationIterator::reset(uint64_t this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 368) = 0;
  uint64_t v1 = *(void *)(this + 376);
  if (v1)
  {
    if ((*(_WORD *)(v1 + 16) & 1) != 0) {
      __int16 v2 = 2;
    }
    else {
      __int16 v2 = *(_WORD *)(v1 + 16) & 0x1F;
    }
    *(_WORD *)(v1 + 16) = v2;
    *(_DWORD *)(v1 + 136) = 0;
  }

  return this;
}

uint64_t icu::CollationIterator::fetchCEs(icu::CollationIterator *this, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    do
    {
      if (sub_1808A16BC(this, a2) == 0x101000100LL) {
        break;
      }
      *((_DWORD *)this + 92) = *((_DWORD *)this + 6);
    }

    while (*(int *)a2 < 1);
  }

  return *((unsigned int *)this + 6);
}

uint64_t icu::CollationIterator::handleNextCE32(uint64_t **this, unsigned int *a2, UErrorCode *a3)
{
  unsigned int v5 = ((uint64_t (*)(uint64_t **, UErrorCode *))(*this)[6])(this, a3);
  *a2 = v5;
  if ((v5 & 0x80000000) != 0) {
    return 192LL;
  }
  else {
    return sub_1808A22C4(this[2], v5);
  }
}

uint64_t icu::CollationIterator::handleGetTrailSurrogate(icu::CollationIterator *this)
{
  return 0LL;
}

uint64_t icu::CollationIterator::foundNULTerminator(icu::CollationIterator *this)
{
  return 0LL;
}

uint64_t icu::CollationIterator::forbidSurrogateCodePoints(icu::CollationIterator *this)
{
  return 0LL;
}

uint64_t icu::CollationIterator::getDataCE32(uint64_t **this, unsigned int a2)
{
  return sub_1808A22C4(this[2], a2);
}

uint64_t icu::CollationIterator::getCE32FromBuilderData( icu::CollationIterator *this, unsigned int a2, UErrorCode *a3)
{
  return 0LL;
}

uint64_t icu::CollationIterator::nextCEFromCE32( icu::CollationIterator *this, const icu::CollationData *a2, int a3, int a4, UErrorCode *a5)
{
  uint64_t v7 = 1LL;
  icu::CollationIterator::appendCEsFromCE32((uint64_t)this, a2, a3, a4, 1, a5);
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = *((int *)this + 92);
    *((_DWORD *)this + 92) = v8 + 1;
    return *(void *)(*((void *)this + 4) + 8 * v8);
  }

  return v7;
}

uint64_t icu::CollationIterator::appendCEsFromCE32( uint64_t this, const icu::CollationData *a2, int a3, int a4, signed __int8 a5, UErrorCode *a6)
{
  uint64_t v7 = this;
  if ((~a4 & 0xC0) == 0) {
    __asm { BR              X9 }
  }

  unint64_t v9 = (int *)(this + 24);
  int v8 = *(_DWORD *)(this + 24);
  if (v8 >= 40)
  {
    this = icu::CollationIterator::CEBuffer::ensureAppendCapacity( (icu::CollationIterator::CEBuffer *)(this + 24),  1,  a6);
    if (!(_DWORD)this) {
      return this;
    }
    int v8 = *v9;
  }

  *(_DWORD *)(v7 + 24) = v8 + 1;
  *(void *)(*(void *)(v7 + 32) + 8LL * v8) = (a4 << 16) & 0xFF000000 | ((unint64_t)((a4 & 0xFFFF0000) >> 16) << 48) | (a4 << 8);
  return this;
}

uint64_t icu::CollationIterator::getCE32FromPrefix( icu::CollationIterator *this, const icu::CollationData *a2, unsigned int a3, UErrorCode *a4)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = (unsigned __int16 *)(*((void *)a2 + 3) + 2LL * (a3 >> 13));
  uint64_t v8 = v7[1] | (*v7 << 16);
  v16[0] = 0LL;
  v16[1] = v7 + 2;
  int v17 = v7 + 2;
  uint64_t v18 = 0xFFFFFFFFLL;
  do
  {
    int v9 = (*(uint64_t (**)(icu::CollationIterator *, UErrorCode *))(*(void *)this + 56LL))(this, a4);
    if (v9 < 0) {
      break;
    }
    int v10 = icu::UCharsTrie::nextForCodePoint((icu::UCharsTrie *)v16, v9);
    if (v10 >= 2)
    {
      uint64_t v11 = v17 + 1;
      unsigned int v12 = *v17;
      if ((__int16)*v17 < 0)
      {
        uint64_t v8 = v12 & 0x7FFF;
        if (v8 >= 0x4000)
        {
          if ((_DWORD)v8 == 0x7FFF)
          {
            int v14 = v17[1] << 16;
            uint64_t v11 = v17 + 2;
          }

          else
          {
            int v14 = ((_DWORD)v8 << 16) - 0x40000000;
          }

          uint64_t v8 = v14 | *v11;
        }
      }

      else
      {
        unsigned int v13 = v12 >> 6;
        if (v13 > 0x100)
        {
          if (v13 > 0x1FE) {
            uint64_t v8 = v17[2] | (v17[1] << 16);
          }
          else {
            uint64_t v8 = (*v11 | ((unsigned __int16)(v13 & 0x1FF) << 16)) - 16842752;
          }
        }

        else
        {
          uint64_t v8 = v13 - 1;
        }
      }
    }

    uint64_t v6 = (v6 + 1);
  }

  while ((v10 & 1) != 0);
  (*(void (**)(icu::CollationIterator *, uint64_t, UErrorCode *))(*(void *)this + 96LL))(this, v6, a4);
  icu::UCharsTrie::~UCharsTrie(v16);
  return v8;
}

uint64_t icu::CollationIterator::nextSkippedCodePoint(icu::CollationIterator *this, UErrorCode *a2)
{
  uint64_t v3 = *((void *)this + 47);
  if (v3
    && ((uint64_t v4 = (uint64_t *)*(unsigned int *)(v3 + 136), *(__int16 *)(v3 + 16) < 0)
      ? (int v5 = *(_DWORD *)(v3 + 20))
      : (int v5 = *(unsigned __int16 *)(v3 + 16) >> 5),
        (int)v4 < v5))
  {
    uint64_t result = (uint64_t)icu::UnicodeString::char32At(v4, (icu::UnicodeString *)(v3 + 8), *(_DWORD *)(v3 + 136));
    else {
      int v7 = 2;
    }
    *(_DWORD *)(v3 + 136) += v7;
  }

  else if (*((_DWORD *)this + 96))
  {
    uint64_t result = (*(uint64_t (**)(icu::CollationIterator *, UErrorCode *))(*(void *)this + 48LL))(this, a2);
    uint64_t v8 = *((void *)this + 47);
    int v9 = *((_DWORD *)this + 96);
    BOOL v10 = __OFSUB__(v9, 1);
    int v11 = v9 - 1;
    if (v11 < 0 == v10 && (result & 0x80000000) == 0) {
      *((_DWORD *)this + 9--*((_DWORD *)this + 6) = v11;
    }
  }

  else
  {
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t icu::CollationIterator::backwardNumSkipped(icu::CollationIterator *this, uint64_t a2, UErrorCode *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *((void *)this + 47);
  uint64_t result = (*(uint64_t (**)(icu::CollationIterator *, uint64_t, UErrorCode *))(*(void *)this + 104LL))( this,  v4,  a3);
  int v8 = *((_DWORD *)this + 96);
  if ((v8 & 0x80000000) == 0) {
    *((_DWORD *)this + 9--*((_DWORD *)this + 6) = v8 + v4;
  }
  return result;
}

uint64_t icu::CollationIterator::nextCE32FromContraction( icu::CollationIterator *a1, uint64_t *a2, __int16 a3, uint64_t a4, uint64_t CE32FromDiscontiguousContraction, int a6, UErrorCode *a7)
{
  unsigned int v8 = a6;
  __int128 v26 = 0LL;
  *(void *)&__int128 v27 = a4;
  *((void *)&v27 + sub_18086E18C((uint64_t)this, 1) = a4;
  uint64_t v28 = 0xFFFFFFFFLL;
  uint64_t v13 = *((void *)a1 + 47);
  if (v13 && *(unsigned __int16 *)(v13 + 16) >= 0x20u)
  {
    *(void *)(v13 + 144) = a4;
    *(void *)(v13 + 152) = a4;
    *(_DWORD *)(v13 + 160) = -1;
  }

  int v14 = icu::UCharsTrie::firstForCodePoint((icu::UCharsTrie *)&v26, a6);
  uint64_t v15 = 1LL;
  int v16 = 2;
  while (v14 >= 2)
  {
    int v17 = (unsigned __int16 *)(*((void *)&v27 + 1) + 2LL);
    unsigned int v18 = (unsigned __int16)**((_WORD **)&v27 + 1);
    if ((__int16)**((_WORD **)&v27 + 1) < 0)
    {
      CE32FromDiscontiguousContractiouint64_t n = v18 & 0x7FFF;
      if (CE32FromDiscontiguousContraction >= 0x4000)
      {
        if ((_DWORD)CE32FromDiscontiguousContraction == 0x7FFF)
        {
          int v21 = *(unsigned __int16 *)(*((void *)&v27 + 1) + 2LL) << 16;
          int v17 = (unsigned __int16 *)(*((void *)&v27 + 1) + 4LL);
        }

        else
        {
          int v21 = ((_DWORD)CE32FromDiscontiguousContraction << 16) - 0x40000000;
        }

        CE32FromDiscontiguousContractiouint64_t n = v21 | *v17;
      }
    }

    else
    {
      unsigned int v19 = v18 >> 6;
      if (v19 > 0x100)
      {
        if (v19 > 0x1FE) {
          CE32FromDiscontiguousContractiouint64_t n = *(unsigned __int16 *)(*((void *)&v27 + 1) + 4LL) | (*(unsigned __int16 *)(*((void *)&v27 + 1) + 2LL) << 16);
        }
        else {
          CE32FromDiscontiguousContractiouint64_t n = (*v17 | ((unsigned __int16)(v19 & 0x1FF) << 16)) - 16842752;
        }
      }

      else
      {
        CE32FromDiscontiguousContractiouint64_t n = v19 - 1;
      }
    }

    if ((v14 & 1) == 0) {
      goto LABEL_35;
    }
    Skippedint CodePoint = icu::CollationIterator::nextSkippedCodePoint(a1, a7);
    unsigned int v8 = SkippedCodePoint;
    uint64_t v23 = *((void *)a1 + 47);
    if (v23)
    {
      if (*(unsigned __int16 *)(v23 + 16) >= 0x20u)
      {
        *(_OWORD *)(v23 + 144) = v27;
        *(_DWORD *)(v23 + 160) = v28;
      }
    }

    uint64_t v15 = 1LL;
LABEL_26:
    int v14 = icu::UCharsTrie::nextForCodePoint((icu::UCharsTrie *)&v26, v8);
    ++v16;
  }

  if (v14)
  {
    unsigned int v20 = icu::CollationIterator::nextSkippedCodePoint(a1, a7);
    if ((v20 & 0x80000000) == 0)
    {
      uint64_t v15 = (v15 + 1);
      unsigned int v8 = v20;
      goto LABEL_26;
    }
  }

  if ((a3 & 0x400) == 0) {
    goto LABEL_34;
  }
  int v24 = v16 - 1;
  if ((int)v15 >= 2)
  {
    icu::CollationIterator::backwardNumSkipped(a1, v15, a7);
    unsigned int v8 = icu::CollationIterator::nextSkippedCodePoint(a1, a7);
    int v24 = v16 - v15;
    uint64_t v15 = 1LL;
  }

  if (sub_1807E8B6C(a2[6], v8) < 0x100) {
LABEL_34:
  }
    icu::CollationIterator::backwardNumSkipped(a1, v15, a7);
  else {
    CE32FromDiscontiguousContractiouint64_t n = icu::CollationIterator::nextCE32FromDiscontiguousContraction( a1,  (const icu::CollationData *)a2,  (icu::UCharsTrie *)&v26,  CE32FromDiscontiguousContraction,  v24,  v8,  a7);
  }
LABEL_35:
  icu::UCharsTrie::~UCharsTrie(&v26);
  return CE32FromDiscontiguousContraction;
}

void icu::CollationIterator::appendNumericCEs(uint64_t **this, __int16 a2, int a3, UErrorCode *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  memset(&v26[1], 0, 48);
  uint64_t v27 = 0LL;
  v26[0] = (char *)&v26[1] + 5;
  LODWORD(v26[1]) = 40;
  if (a3)
  {
    icu::CharString::append((icu::CharString *)v26, HIBYTE(a2) & 0xF, a4);
    while (*((_DWORD *)this + 96))
    {
      unsigned int v6 = ((uint64_t (*)(uint64_t **, UErrorCode *))(*this)[6])(this, a4);
      if ((v6 & 0x80000000) != 0) {
        break;
      }
      unsigned int v7 = v6;
      int v8 = sub_1808A22C4(this[2], v6);
      if (v8 == 192) {
        LOWORD(v8) = sub_1808A22C4((uint64_t *)this[2][4], v7);
      }
      if ((v8 & 0xCF) != 0xCA)
      {
        ((void (*)(uint64_t **, uint64_t, UErrorCode *))(*this)[13])(this, 1LL, a4);
        break;
      }

      int v9 = *((_DWORD *)this + 96);
      BOOL v10 = __OFSUB__(v9, 1);
      int v11 = v9 - 1;
      if (v11 < 0 == v10) {
        *((_DWORD *)this + 9--*((_DWORD *)this + 6) = v11;
      }
      icu::CharString::append((icu::CharString *)v26, BYTE1(v8) & 0xF, a4);
    }
  }

  else
  {
    while (1)
    {
      icu::CharString::append((icu::CharString *)v26, HIBYTE(a2) & 0xF, a4);
      unsigned int v12 = ((uint64_t (*)(uint64_t **, UErrorCode *))(*this)[7])(this, a4);
      if ((v12 & 0x80000000) != 0) {
        break;
      }
      unsigned int v13 = v12;
      int v14 = sub_1808A22C4(this[2], v12);
      a2 = v14;
      if (v14 == 192) {
        a2 = sub_1808A22C4((uint64_t *)this[2][4], v13);
      }
      if ((a2 & 0xCF) != 0xCA)
      {
        ((void (*)(uint64_t **, uint64_t, UErrorCode *))(*this)[12])(this, 1LL, a4);
        break;
      }
    }

    uint64_t v15 = (char *)v26[0] + (int)v27 - 1;
    if (v26[0] < v15)
    {
      int v16 = (char *)v26[0] + 1;
      do
      {
        char v17 = *(v16 - 1);
        *(v16 - sub_18086E18C((uint64_t)this, 1) = *v15;
        *v15-- = v17;
      }

      while (v16++ < v15);
    }
  }

  if (*(int *)a4 <= 0)
  {
    int v19 = 0;
    int v20 = v27;
    do
    {
      if (v19 < v20 - 1)
      {
        int v21 = (char *)v26[0] + v19;
        uint64_t v22 = ~(uint64_t)v19 + v20;
        while (!*v21++)
        {
          ++v19;
          if (!--v22)
          {
            int v19 = v20 - 1;
            break;
          }
        }
      }

      int v24 = v20 - v19;
      if (v24 >= 254) {
        int v25 = 254;
      }
      else {
        int v25 = v24;
      }
      icu::CollationIterator::appendNumericSegmentCEs((uint64_t)this, (const char *)v26[0] + v19, v25, a4);
      v19 += v25;
      int v20 = v27;
    }

    while (v19 < (int)v27);
  }

  if (BYTE4(v26[1])) {
    uprv_free(v26[0]);
  }
}

uint64_t sub_1808B2488(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  if (*(_DWORD *)(*a1 + 44) <= a2) {
    int v3 = *(_DWORD *)(v2 + 48);
  }
  else {
    int v3 = (a2 & 0x1F)
  }
       + 4
       * *(unsigned __int16 *)(*(void *)v2
                             + 2LL
  return *(unsigned int *)(*(void *)(*a1 + 16) + 4LL * v3);
}

uint64_t sub_1808B24D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (icu::UnicodeString *)(a1 + 8);
  else {
    int v5 = *(unsigned __int16 *)(a1 + 16) >> 5;
  }
  int v6 = *(_DWORD *)(a1 + 136);
  uint64_t v7 = (v6 - v5);
  if ((int)v7 < 1)
  {
    int v8 = icu::UnicodeString::moveIndex32(v4, *(_DWORD *)(a1 + 136), -(int)a2);
    a2 = 0LL;
  }

  else if ((int)v7 >= (int)a2)
  {
    int v8 = v6 - a2;
  }

  else
  {
    int v8 = icu::UnicodeString::moveIndex32(v4, v5, (int)v7 - (int)a2);
    a2 = v7;
  }

  *(_DWORD *)(a1 + 13--*((_DWORD *)this + 6) = v8;
  return a2;
}

uint64_t icu::CollationIterator::nextCE32FromDiscontiguousContraction( icu::CollationIterator *this, const icu::CollationData *a2, icu::UCharsTrie *a3, uint64_t a4, int a5, unsigned int a6, UErrorCode *a7)
{
  uint64_t v7 = a4;
  unsigned int v12 = a2;
  LOBYTE(v14) = sub_1807E8B6C(*((void *)a2 + 6), a6);
  Skippedint CodePoint = icu::CollationIterator::nextSkippedCodePoint(this, a7);
  if (SkippedCodePoint < 0)
  {
    int v20 = this;
    uint64_t v21 = 1LL;
    goto LABEL_7;
  }

  unsigned int v16 = SkippedCodePoint;
  unsigned int v17 = sub_1807E8B6C(*((void *)v12 + 6), SkippedCodePoint);
  if (v17 <= 0xFF)
  {
    int v20 = this;
    uint64_t v21 = 2LL;
LABEL_7:
    icu::CollationIterator::backwardNumSkipped(v20, v21, a7);
    return v7;
  }

  __int16 v23 = v17;
  int v24 = (uint64_t *)*((void *)this + 47);
  if (!v24)
  {
    int v24 = icu::UMemory::operator new(v19, (icu::UMemory *)0xA8, v18);
    if (!v24)
    {
      uint64_t v7 = 0LL;
      *((void *)this + 47) = 0LL;
      *a7 = U_MEMORY_ALLOCATION_ERROR;
      return v7;
    }

    v24[1] = (uint64_t)off_18971B688;
    *((_WORD *)v24 + 8) = 2;
    v24[9] = (uint64_t)off_18971B688;
    *((_WORD *)v24 + 40) = 2;
    v24[17] = 0LL;
    v24[18] = 0LL;
    *((void *)this + 47) = v24;
    goto LABEL_16;
  }

  if (*((unsigned __int16 *)v24 + 8) <= 0x1Fu)
  {
LABEL_16:
    unint64_t v26 = *((void *)a3 + 1);
    *((void *)a3 + 2) = v26;
    int v27 = -1;
    *((_DWORD *)a3 + --*((_DWORD *)this + 6) = -1;
    if (a5 < 2)
    {
      int64x2_t v31 = vdupq_n_s64(v26);
    }

    else
    {
      (*(void (**)(icu::CollationIterator *, void, UErrorCode *))(*(void *)this + 104LL))( this,  (a5 + 1),  a7);
      int v28 = (*(uint64_t (**)(icu::CollationIterator *, UErrorCode *))(*(void *)this + 48LL))(this, a7);
      icu::UCharsTrie::firstForCodePoint(a3, v28);
      for (int i = a5 - 2; i; --i)
      {
        int v30 = (*(uint64_t (**)(icu::CollationIterator *, UErrorCode *))(*(void *)this + 48LL))(this, a7);
        icu::UCharsTrie::nextForCodePoint(a3, v30);
      }

      (*(void (**)(icu::CollationIterator *, uint64_t, UErrorCode *))(*(void *)this + 96LL))(this, 2LL, a7);
      int v24 = (uint64_t *)*((void *)this + 47);
      int64x2_t v31 = *(int64x2_t *)((char *)a3 + 8);
      int v27 = *((_DWORD *)a3 + 6);
    }

    *((int64x2_t *)v24 + 9) = v31;
    *((_DWORD *)v24 + 40) = v27;
    goto LABEL_22;
  }

  uint64_t v25 = *((void *)a3 + 1);
  if (v25 && v25 == v24[18])
  {
    *((void *)a3 + 2) = v24[19];
    *((_DWORD *)a3 + --*((_DWORD *)this + 6) = *((_DWORD *)v24 + 40);
  }

uint64_t sub_1808B29C4(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 140) = 0;
  uint64_t v4 = (icu::UnicodeString *)(a1 + 72);
  icu::UnicodeString::unBogus(a1 + 72);
  else {
    uint64_t v5 = *(unsigned __int16 *)(a1 + 80) >> 5;
  }
  return icu::UnicodeString::replace(v4, 0LL, v5, a2);
}

uint64_t icu::CollationIterator::appendNumericSegmentCEs( uint64_t this, const char *a2, int a3, UErrorCode *a4)
{
  uint64_t v5 = this;
  unsigned int v6 = *(_DWORD *)(*(void *)(this + 16) + 56LL);
  if (a3 <= 7)
  {
    int v7 = *a2;
    if (a3 >= 2)
    {
      int v8 = a2 + 1;
      uint64_t v9 = a3 - 1LL;
      do
      {
        int v10 = *v8++;
        int v7 = v10 + 10 * v7;
        --v9;
      }

      while (v9);
    }

    unsigned __int16 v11 = v7 - 74;
    if (v7 < 74)
    {
      uint64_t v12 = ((v7 << 16) + 0x20000) | v6;
LABEL_12:
      unsigned int v17 = (icu::CollationIterator::CEBuffer *)(this + 24);
      int v16 = *(_DWORD *)(this + 24);
      uint64_t v18 = (v12 << 32) | 0x5000500;
      goto LABEL_34;
    }

    if (v7 <= 0x27F9)
    {
      unsigned int v13 = ((v11 % 0xFEu) << 8) + 512;
      unsigned int v14 = (((v11 / 0xFEu) << 16) + 4980736) | v6;
LABEL_11:
      uint64_t v12 = v13 | v14;
      goto LABEL_12;
    }

    if (v7 <= 0xFE839)
    {
      unsigned int v15 = v7 - 10234;
      unsigned int v14 = ((v15 / 0xFE
      unsigned int v13 = (v15 % 0xFE + 2) | (((16 * ((1090717717 * (unint64_t)(v15 >> 2)) >> 32)) & 0xFFFF0000) + 7602176) | v6;
      goto LABEL_11;
    }
  }

  int v19 = a3 + 2;
  if (a3 >= -1) {
    int v19 = a3 + 1;
  }
  unsigned int v20 = v6 | (((v19 << 15) & 0xFFFF0000) + 0x800000);
  uint64_t v21 = &a2[a3 - 1];
  uint64_t v22 = v21;
  do
  {
    int v23 = a3;
    int v24 = *(unsigned __int8 *)v22;
    v22 -= 2;
    if (v24) {
      break;
    }
    int v25 = *((unsigned __int8 *)v21 - 1);
    a3 -= 2;
    uint64_t v21 = v22;
  }

  while (!v25);
  int v26 = *a2;
  if ((v23 & 1) != 0)
  {
    int v27 = 1;
  }

  else
  {
    int v26 = a2[1] + 10 * v26;
    int v27 = 2;
  }

  int v28 = 2 * v26;
  if (v27 < v23)
  {
    __int16 v29 = (int *)(this + 24);
    int v30 = 8;
    uint64_t v31 = v27;
    while (1)
    {
      int v32 = v28 + 11;
      if (!v30) {
        break;
      }
      v20 |= v32 << v30;
      v30 -= 8;
LABEL_30:
      int v34 = a2[v31 + 1] + 10 * a2[v31];
      v31 += 2LL;
      int v28 = 2 * v34;
    }

    int v33 = *v29;
    if (*v29 >= 40)
    {
      this = icu::CollationIterator::CEBuffer::ensureAppendCapacity( (icu::CollationIterator::CEBuffer *)(v5 + 24),  1,  a4);
      if (!(_DWORD)this)
      {
LABEL_29:
        int v30 = 16;
        unsigned int v20 = v6;
        goto LABEL_30;
      }

      int v33 = *v29;
    }

    *(_DWORD *)(v5 + 24) = v33 + 1;
    *(void *)(*(void *)(v5 + 32) + 8LL * v33) = ((unint64_t)(v32 | v20) << 32) | 0x5000500;
    goto LABEL_29;
  }

  LOBYTE(v30) = 8;
LABEL_33:
  uint64_t v35 = ((v28 + 10) << v30) | v20;
  unsigned int v17 = (icu::CollationIterator::CEBuffer *)(v5 + 24);
  int v16 = *(_DWORD *)(v5 + 24);
  uint64_t v18 = (v35 << 32) | 0x5000500;
LABEL_34:
  if (v16 >= 40)
  {
    this = icu::CollationIterator::CEBuffer::ensureAppendCapacity(v17, 1, a4);
    if (!(_DWORD)this) {
      return this;
    }
    int v16 = *(_DWORD *)v17;
  }

  *(_DWORD *)(v5 + 24) = v16 + 1;
  *(void *)(*(void *)(v5 + 32) + 8LL * v1--*((_DWORD *)this + 6) = v18;
  return this;
}

unint64_t icu::CollationIterator::previousCE( icu::CollationIterator *this, icu::UVector32 *a2, UErrorCode *a3)
{
  int v4 = *((_DWORD *)this + 6);
  BOOL v5 = __OFSUB__(v4, 1);
  int v6 = v4 - 1;
  if (v6 < 0 != v5)
  {
    icu::UVector32::removeAllElements((uint64_t)a2);
    int v10 = (*(uint64_t (**)(icu::CollationIterator *))(*(void *)this + 40LL))(this);
    int v11 = (*(uint64_t (**)(icu::CollationIterator *, UErrorCode *))(*(void *)this + 56LL))(this, a3);
    if (v11 < 0)
    {
      return 0x101000100LL;
    }

    else
    {
      unsigned int v12 = v11;
      if (sub_1808B2F00(*((void *)this + 2), v11, *((char *)this + 388)))
      {
        return icu::CollationIterator::previousCEUnsafe(this, v13, a2, a3);
      }

      else
      {
        int v14 = sub_1808A22C4(*((uint64_t **)this + 2), v12);
        unsigned int v15 = (uint64_t *)*((void *)this + 2);
        if (v14 == 192)
        {
          unsigned int v15 = (uint64_t *)v15[4];
          int v14 = sub_1808A22C4(v15, v12);
        }

        int v16 = v14 & 0xF;
        if ((~v14 & 0xC0) != 0 || (v14 & 0xFu) - 3 >= 0xFFFFFFFE)
        {
          if (v14 > 0xBFu)
          {
            unint64_t result = v14 & 0xFFFFFF00;
            if (v16 == 1) {
              return (result << 32) | 0x5000500;
            }
          }

          else
          {
            return (v14 << 16) & 0xFF000000 | ((unint64_t)((v14 & 0xFFFF0000) >> 16) << 48) | (v14 << 8);
          }
        }

        else
        {
          icu::CollationIterator::appendCEsFromCE32((uint64_t)this, (const icu::CollationData *)v15, v12, v14, 0, a3);
          if (*(int *)a3 <= 0)
          {
            int v18 = *((_DWORD *)this + 6);
            if (v18 >= 2)
            {
              int v19 = (*(uint64_t (**)(icu::CollationIterator *))(*(void *)this + 40LL))(this);
              sub_1807C9210(a2, v19, a3);
              int v20 = *((_DWORD *)a2 + 2);
              while (1)
              {
                int v18 = *((_DWORD *)this + 6);
                if (v20 > v18) {
                  break;
                }
                if (v20 < -1 || *((_DWORD *)a2 + 3) <= v20)
                {
                  int v21 = icu::UVector32::expandCapacity(a2, v20 + 1, a3);
                  int v20 = *((_DWORD *)a2 + 2);
                  if (!v21) {
                    continue;
                  }
                }

                *(_DWORD *)(*((void *)a2 + 3) + 4LL * v20) = v10;
                int v20 = *((_DWORD *)a2 + 2) + 1;
                *((_DWORD *)a2 + 2) = v20;
              }
            }

            *((_DWORD *)this + --*((_DWORD *)this + 6) = v18 - 1;
            return *(void *)(*((void *)this + 4) + 8LL * (v18 - 1));
          }

          else
          {
            return 1LL;
          }
        }
      }
    }
  }

  else
  {
    *((_DWORD *)this + --*((_DWORD *)this + 6) = v6;
    return *(void *)(*((void *)this + 4) + 8LL * v6);
  }

  return result;
}

uint64_t sub_1808B2F00(uint64_t a1, int a2, int a3)
{
  if (!a3) {
    return 0LL;
  }
  if (a2 > 1631) {
    return (sub_1808A22C4((uint64_t *)a1, a2) & 0xCF) == 202;
  }
  return (a2 - 48) < 0xA;
}

uint64_t icu::CollationIterator::previousCEUnsafe( icu::CollationIterator *this, int a2, icu::UVector32 *a3, UErrorCode *a4)
{
  uint64_t v7 = 1LL;
  do
  {
    int v8 = (*(uint64_t (**)(icu::CollationIterator *, UErrorCode *))(*(void *)this + 56LL))(this, a4);
    if (v8 < 0) {
      break;
    }
    uint64_t v7 = (v7 + 1);
  }

  while (sub_1808B2F00(*((void *)this + 2), v8, *((char *)this + 388)));
  *((_DWORD *)this + 9--*((_DWORD *)this + 6) = v7;
  *((_DWORD *)this + 92) = 0;
  int v9 = (*(uint64_t (**)(icu::CollationIterator *))(*(void *)this + 40LL))(this);
  int v10 = *((_DWORD *)this + 96);
  if (v10 > 0)
  {
    while (1)
    {
      *((_DWORD *)this + 9--*((_DWORD *)this + 6) = v10 - 1;
      sub_1808A16BC(this, a4);
      *((_DWORD *)this + 92) = *((_DWORD *)this + 6);
      int v11 = *((_DWORD *)a3 + 2);
      if (v11 < -1 || *((_DWORD *)a3 + 3) <= v11)
      {
        int v11 = *((_DWORD *)a3 + 2);
      }

      *(_DWORD *)(*((void *)a3 + 3) + 4LL * v1sub_18086E18C((uint64_t)this, 1) = v9;
      ++*((_DWORD *)a3 + 2);
LABEL_13:
      int v9 = (*(uint64_t (**)(icu::CollationIterator *))(*(void *)this + 40LL))(this);
      int v13 = *((_DWORD *)a3 + 2);
      while (v13 < *((_DWORD *)this + 6))
      {
        if (v13 < -1 || *((_DWORD *)a3 + 3) <= v13)
        {
          int v14 = icu::UVector32::expandCapacity(a3, v13 + 1, a4);
          int v13 = *((_DWORD *)a3 + 2);
          if (!v14) {
            continue;
          }
        }

        *(_DWORD *)(*((void *)a3 + 3) + 4LL * v13) = v9;
        int v13 = *((_DWORD *)a3 + 2) + 1;
        *((_DWORD *)a3 + 2) = v13;
      }

      int v10 = *((_DWORD *)this + 96);
      if (v10 < 1) {
        goto LABEL_22;
      }
    }
  }

  int v13 = *((_DWORD *)a3 + 2);
LABEL_22:
  if (v13 < -1 || *((_DWORD *)a3 + 3) <= v13)
  {
    int v13 = *((_DWORD *)a3 + 2);
  }

  *(_DWORD *)(*((void *)a3 + 3) + 4LL * v13) = v9;
  ++*((_DWORD *)a3 + 2);
LABEL_27:
  *((_DWORD *)this + 9--*((_DWORD *)this + 6) = -1;
  (*(void (**)(icu::CollationIterator *, uint64_t, UErrorCode *))(*(void *)this + 104LL))(this, v7, a4);
  *((_DWORD *)this + 92) = 0;
  uint64_t v16 = *((int *)this + 6) - 1LL;
  *((_DWORD *)this + --*((_DWORD *)this + 6) = v16;
  return *(void *)(*((void *)this + 4) + 8 * v16);
}

_DWORD *sub_1808B3174(_DWORD *result, char *a2, size_t __n)
{
  if (a2 && (int)__n >= 1)
  {
    uint64_t v3 = result[6];
    if ((int)v3 >= 1)
    {
      result[6] = (v3 - __n) & ~(((int)v3 - (int)__n) >> 31);
      if ((((_DWORD)v3 - (_DWORD)__n) & 0x80000000) == 0) {
        return result;
      }
      a2 += v3;
      LODWORD(__n) = __n - v3;
    }

    uint64_t v4 = (int)result[5];
    result[5] = v4 + __n;
    if ((char *)(*((void *)result + 1) + v4) != a2)
    {
      else {
        return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 40LL))(result);
      }
    }
  }

  return result;
}

uint64_t sub_1808B31EC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  if (a2 < 1 || a5 < a2)
  {
    a4 = 0LL;
    *a6 = 0;
    return a4;
  }

  if (*(int *)(a1 + 24) < 1)
  {
    int v10 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20);
    if (v10 >= a2)
    {
      *a6 = v10;
    }

    else
    {
      if (!(*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)a1 + 48LL))( a1,  a3,  *(unsigned int *)(a1 + 20))) {
        goto LABEL_4;
      }
      *a6 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20);
    }

    return *(void *)(a1 + 8) + *(int *)(a1 + 20);
  }

uint64_t icu::CollationKeys::LevelCallback::needToWrite()
{
  return 1LL;
}

void icu::CollationKeys::writeSortKeyUpToQuaternary( icu::CollationIterator::CEBuffer *this, uint64_t a2, uint64_t a3, _DWORD *a4, char a5, uint64_t a6, int a7, UErrorCode *a8)
{
  uint64_t v133 = *MEMORY[0x1895F89C0];
  int v9 = *(_DWORD *)(a3 + 24);
  int v10 = (v9 >> 7) & 8 | dword_180A3475C[v9 >> 12];
  char v11 = v10 & (-1 << a5);
  if ((v10 & (-1 << a5)) == 0) {
    return;
  }
  unsigned int v121 = 0;
  int v118 = 0;
  int v116 = 0;
  int v14 = 0;
  int v15 = 0;
  int v16 = *(_DWORD *)(a3 + 28);
  memset(&v131[1], 0, 48);
  uint64_t v132 = 0LL;
  int v106 = v9 & 0xC;
  int v107 = 0;
  LODWORD(v131[1]) = 40;
  if ((v9 & 0xC) != 0) {
    unsigned int v17 = v16 + 1;
  }
  else {
    unsigned int v17 = 0;
  }
  unsigned int v109 = v9;
  LODWORD(v132) = 0;
  unsigned int v104 = 0;
  int v105 = v9 & 0x600;
  BYTE4(v132) = 1;
  v129[0] = 0uLL;
  if (v105 == 512) {
    int v18 = 65343;
  }
  else {
    int v18 = 16191;
  }
  int v108 = v18;
  uint64_t v130 = 0x100000000LL;
  v131[0] = (char *)&v131[1] + 5;
  memset(&v129[1], 0, 32);
  v128 = (char *)v129 + 5;
  LODWORD(v129[0]) = 40;
  memset(&v126[1], 0, 48);
  uint64_t v127 = 0x100000000LL;
  uint64_t v125 = 0x100000000LL;
  v126[0] = (char *)&v126[1] + 5;
  LODWORD(v126[1]) = 40;
  memset(&v124[1], 0, 48);
  v124[0] = (char *)&v124[1] + 5;
  LODWORD(v124[1]) = 40;
  do
  {
    int v117 = v15;
    do
    {
      if (*((_DWORD *)this + 92) == *((_DWORD *)this + 6))
      {
        *((_DWORD *)this + --*((_DWORD *)this + 6) = 0;
        *((_DWORD *)this + 92) = 0;
      }

      unint64_t v19 = sub_1808A16BC(this, a8);
      uint64_t v20 = HIDWORD(v19);
      if (v17 > HIDWORD(v19) && HIDWORD(v19) >= 0x2000001)
      {
        if (v14)
        {
          if (v14 < 114)
          {
            char v22 = v14 - 1;
          }

          else
          {
            unsigned int v21 = v14 + 112;
            do
            {
              sub_1808B3F60((uint64_t)v124, 140);
              v21 -= 113;
            }

            while (v21 > 0xE1);
            char v22 = v21 - 113;
          }

          sub_1808B3F60((uint64_t)v124, v22 + 28);
        }

        while (1)
        {
          if ((v11 & 0x20) != 0)
          {
            uint64_t v23 = *(void *)(a3 + 32);
            if (v23)
            {
              int v24 = *(unsigned __int8 *)(v23 + ((unint64_t)v20 >> 24));
              if (v24) {
                LODWORD(v20) = v20 & 0xFFFFFF | (v24 << 24);
              }
              else {
                LODWORD(v20) = icu::CollationSettings::reorderEx((icu::CollationSettings *)a3, v20);
              }
            }

            if (BYTE3(v20) >= 0x1Bu) {
              sub_1808B3F60((uint64_t)v124, 27);
            }
            if ((_BYTE)v20) {
              int v25 = 4;
            }
            else {
              int v25 = 3;
            }
            if ((v20 & 0xFF00) == 0) {
              int v25 = 2;
            }
            if ((v20 & 0xFF0000) != 0) {
              int v26 = v25;
            }
            else {
              int v26 = 1;
            }
            int v27 = v125;
          }

          do
          {
LABEL_45:
            unint64_t v31 = sub_1808A16BC(this, a8);
            uint64_t v20 = HIDWORD(v31);
          }

          while (!HIDWORD(v31));
          LODWORD(v19) = v31;
          int v14 = 0;
          if (v17 <= HIDWORD(v31) || HIDWORD(v31) <= 0x2000000) {
            goto LABEL_48;
          }
        }

        int v27 = v125;
LABEL_41:
        LODWORD(v125) = v27 + 1;
        *((_BYTE *)v124[0] + v27) = BYTE3(v20);
        if ((v20 & 0xFF0000) != 0)
        {
          uint64_t v28 = (int)v125;
          LODWORD(v125) = v125 + 1;
          *((_BYTE *)v124[0] + v28) = BYTE2(v20);
          if ((v20 & 0xFF00) != 0)
          {
            uint64_t v29 = (int)v125;
            LODWORD(v125) = v125 + 1;
            *((_BYTE *)v124[0] + v29) = BYTE1(v20);
            if ((_BYTE)v20)
            {
              uint64_t v30 = (int)v125;
              LODWORD(v125) = v125 + 1;
              *((_BYTE *)v124[0] + v30) = v20;
            }
          }
        }

        goto LABEL_45;
      }

uint64_t sub_1808B3F60(uint64_t result, char a2)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 56);
  if (v4 >= *(_DWORD *)(result + 8))
  {
    unint64_t result = sub_1808B40A8(result, 1);
    if (!(_DWORD)result) {
      return result;
    }
    int v4 = *(_DWORD *)(v3 + 56);
  }

  *(_DWORD *)(v3 + 5--*((_DWORD *)this + 6) = v4 + 1;
  *(_BYTE *)(*(void *)v3 + v4) = a2;
  return result;
}

_DWORD *sub_1808B3FB4(_DWORD *result, char a2)
{
  uint64_t v2 = result;
  int v3 = result[6];
  BOOL v4 = __OFSUB__(v3, 1);
  int v5 = v3 - 1;
  if (v5 < 0 == v4)
  {
    result[6] = v5;
    return result;
  }

  int v7 = result[5];
  if (v7 < result[4]) {
    goto LABEL_6;
  }
  unint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)result + 48LL))(result, 1LL);
  if ((_DWORD)result)
  {
    int v7 = v2[5];
LABEL_6:
    *(_BYTE *)(*((void *)v2 + 1) + v7) = a2;
  }

  ++v2[5];
  return result;
}

uint64_t sub_1808B4024(uint64_t result, __int16 a2)
{
  uint64_t v3 = result;
  int v4 = a2;
  if ((_BYTE)a2) {
    int v5 = 2;
  }
  else {
    int v5 = 1;
  }
  int v6 = *(_DWORD *)(result + 56);
  if (v6 + v5 > *(_DWORD *)(result + 8))
  {
    unint64_t result = sub_1808B40A8(result, v5);
    if (!(_DWORD)result) {
      return result;
    }
    int v6 = *(_DWORD *)(v3 + 56);
  }

  *(_DWORD *)(v3 + 5--*((_DWORD *)this + 6) = v6 + 1;
  *(_BYTE *)(*(void *)v3 + v--*((_DWORD *)this + 6) = HIBYTE(a2);
  if (v4)
  {
    uint64_t v7 = *(int *)(v3 + 56);
    *(_DWORD *)(v3 + 5--*((_DWORD *)this + 6) = v7 + 1;
    *(_BYTE *)(*(void *)v3 + v7) = a2;
  }

  return result;
}

uint64_t sub_1808B40A8(uint64_t a1, int a2)
{
  if (!*(_BYTE *)(a1 + 60)) {
    return 0LL;
  }
  int v3 = 2 * *(_DWORD *)(a1 + 8);
  int v4 = *(_DWORD *)(a1 + 56);
  if (v3 <= v4 + 2 * a2) {
    int v3 = v4 + 2 * a2;
  }
  if (v3 <= 200) {
    size_t v5 = 200LL;
  }
  else {
    size_t v5 = v3;
  }
  uint64_t result = (uint64_t)uprv_malloc(v5);
  if (result)
  {
    uint64_t v7 = result;
    if (v4 >= 1)
    {
      int v8 = *(_DWORD *)(a1 + 8);
      if (v8 >= v4) {
        int v8 = v4;
      }
      memcpy((void *)result, *(const void **)a1, v8);
    }

    if (*(_BYTE *)(a1 + 12)) {
      uprv_free(*(void **)a1);
    }
    *(void *)a1 = v7;
    *(_DWORD *)(a1 + 8) = v5;
    uint64_t result = 1LL;
    *(_BYTE *)(a1 + 12) = 1;
  }

  else
  {
    *(_BYTE *)(a1 + 60) = 0;
  }

  return result;
}

void *icu::CollationRoot::loadFromFile(icu::CollationRoot *this, char *a2, UErrorCode *a3)
{
  uint64_t v8 = 0LL;
  __int128 v7 = 0u;
  memset(v6, 0, sizeof(v6));
  if (!uprv_mapFile(v6, (const char *)this, (int *)a2))
  {
    uint64_t result = 0LL;
    int v5 = 2;
    goto LABEL_10;
  }

  if (__PAIR64__( *(unsigned __int8 *)(*((void *)&v6[0] + 1) + 3LL),  *(unsigned __int8 *)(*((void *)&v6[0] + 1) + 2LL)) != 0x27000000DALL || !icu::CollationDataReader::isAcceptable( 0LL,  (uint64_t)"icu",  (uint64_t)"ucadata",  (unsigned __int16 *)(*((void *)&v6[0] + 1) + 4LL)))
  {
    uint64_t result = 0LL;
    int v5 = 3;
LABEL_10:
    *(_DWORD *)a2 = v5;
    return result;
  }

  uint64_t result = UDataMemory_createNewInstance((int *)a2);
  result[1] = *((void *)&v6[0] + 1);
  *((_OWORD *)result + 2) = v7;
  return result;
}

icu::CollationTailoring *icu::CollationRoot::load(icu::CollationTailoring *this, char *a2, UErrorCode *a3)
{
  int v3 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v3 <= 0)
  {
    int v5 = this;
    this = (icu::CollationTailoring *)icu::UMemory::operator new(v3, (icu::UMemory *)0x190, (unint64_t)a2);
    if (!this)
    {
      *(_DWORD *)a2 = 7;
      return this;
    }

    int v6 = (uint64_t *)this;
    if (*(void *)(icu::CollationTailoring::CollationTailoring(this, 0LL) + 32))
    {
      if (v5) {
        uint64_t v8 = icu::CollationRoot::loadFromFile(v5, a2, v7);
      }
      else {
        uint64_t v8 = udata_openChoice( "icudt74l-coll",  "icu",  "ucadata",  (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))icu::CollationDataReader::isAcceptable,  (uint64_t)(v6 + 41),  (UErrorCode *)a2);
      }
      v6[44] = (uint64_t)v8;
      if (*(int *)a2 <= 0)
      {
        uint64_t Memory = (const icu::CollationTailoring *)udata_getMemory((uint64_t)v8);
        Length = (const unsigned __int8 *)udata_getLength(v6[44]);
        icu::CollationDataReader::read(0LL, Memory, Length, (uint64_t)v6, (UErrorCode *)a2, v11);
        if (*(int *)a2 <= 0)
        {
          sub_1809B36C0(0x1Eu, (uint64_t)sub_1808B438C);
          int v14 = (icu::Locale *)icu::UMemory::operator new(v13, (icu::UMemory *)0x100, v12);
          if (v14)
          {
            int v15 = v14;
            uint64_t Root = icu::Locale::getRoot(v14);
            unsigned int v17 = sub_1808B4534(v15, Root, (uint64_t)v6);
            this = (icu::CollationTailoring *)icu::SharedObject::addRef((uint64_t)v17);
            qword_18C4493C0 = (uint64_t)v15;
            return this;
          }
        }
      }
    }

    else
    {
      *(_DWORD *)a2 = 7;
    }

    return (icu::CollationTailoring *)(*(uint64_t (**)(uint64_t *))(*v6 + 8))(v6);
  }

  return this;
}

uint64_t sub_1808B438C()
{
  if (qword_18C4493C0)
  {
    icu::SharedObject::removeRef((void *)qword_18C4493C0);
    qword_18C4493C0 = 0LL;
  }

  atomic_store(0, (unsigned int *)&unk_18C4493C8);
  return 1LL;
}

uint64_t icu::CollationRoot::getRootCacheEntry(icu::CollationRoot *this, UErrorCode *a2)
{
  else {
    return qword_18C4493C0;
  }
}

uint64_t icu::CollationRoot::getRoot(icu::CollationRoot *this, UErrorCode *a2)
{
  uint64_t result = 0LL;
  return result;
}

uint64_t icu::CollationRoot::getData(icu::CollationRoot *this, UErrorCode *a2)
{
  uint64_t result = 0LL;
  return result;
}

uint64_t icu::CollationRoot::getSettings(icu::CollationRoot *this, UErrorCode *a2)
{
  uint64_t result = 0LL;
  return result;
}

void icu::CollationRoot::forceLoadFromFile(icu::CollationRoot *this, char *a2, UErrorCode *a3)
{
}

void *sub_1808B4534(void *a1, uint64_t a2, uint64_t a3)
{
  a1[2] = 0LL;
  *a1 = off_189720068;
  a1[1] = 0LL;
  icu::Locale::Locale((icu::Locale *)(a1 + 3), a2);
  a1[31] = a3;
  if (a3) {
    icu::SharedObject::addRef(a3);
  }
  return a1;
}

unint64_t icu::CollationRootElements::lastCEWithPrimaryBefore( icu::CollationRootElements *this, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  int v4 = icu::CollationRootElements::findP(this, a2);
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *(_DWORD *)(*(void *)this + 4LL * v4) & 0xFFFFFF00;
  if ((_DWORD)v6 == a2)
  {
    int v7 = *(_DWORD *)(v5 + 4LL * v4 - 4);
    if ((v7 & 0x80) != 0)
    {
      unint64_t v12 = (int *)(v5 + 4LL * (v4 - 2));
      do
      {
        int v14 = *v12--;
        int v13 = v14;
      }

      while ((v14 & 0x80) != 0);
      uint64_t v6 = v13 & 0xFFFFFF00;
    }

    else
    {
      uint64_t v6 = v7 & 0xFFFFFF00;
      int v7 = 83887360;
    }
  }

  else
  {
    int v9 = 83887360;
    int v10 = (int *)(v5 + 4LL * v4 + 4);
    do
    {
      int v7 = v9;
      int v11 = *v10++;
      int v9 = v11;
    }

    while ((v11 & 0x80) != 0);
  }

  return v7 & 0xFFFFFF7F | (unint64_t)(v6 << 32);
}

uint64_t icu::CollationRootElements::findP(icu::CollationRootElements *this, unsigned int a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t result = *(unsigned int *)(*(void *)this + 8LL);
  int v5 = *((_DWORD *)this + 2) - 1;
  while ((int)result + 1 < v5)
  {
    else {
      int v6 = v5 + result;
    }
    LODWORD(v7) = v6 >> 1;
    int v8 = *(_DWORD *)(v3 + 4LL * (v6 >> 1));
    if ((v8 & 0x80) != 0)
    {
      if ((_DWORD)v7 + 1 == v5)
      {
LABEL_11:
        LODWORD(v7) = v7 - 1;
        if ((_DWORD)v7 == (_DWORD)result) {
          return result;
        }
        uint64_t v7 = (int)v7;
        while (1)
        {
          int v8 = *(_DWORD *)(v3 + 4 * v7);
          if ((v8 & 0x80) == 0) {
            break;
          }
          if ((_DWORD)result == (_DWORD)--v7) {
            return result;
          }
        }
      }

      else
      {
        uint64_t v9 = ((uint64_t)v6 >> 1) + 1;
        while (1)
        {
          int v8 = *(_DWORD *)(v3 + 4 * v9);
          if ((v8 & 0x80) == 0) {
            break;
          }
          if (v5 == (_DWORD)++v9) {
            goto LABEL_11;
          }
        }

        LODWORD(v7) = v9;
      }
    }

    unsigned int v10 = v8 & 0xFFFFFF00;
    if (v10 <= a2) {
      uint64_t result = v7;
    }
    else {
      uint64_t result = result;
    }
    if (v10 > a2) {
      int v5 = v7;
    }
  }

  return result;
}

uint64_t icu::CollationRootElements::firstCEWithPrimaryAtLeast(icu::CollationRootElements *this, uint64_t a2)
{
  if (!(_DWORD)a2) {
    return 0LL;
  }
  uint64_t v2 = a2;
  int v4 = icu::CollationRootElements::findP(this, a2);
  if ((*(_DWORD *)(*(void *)this + 4LL * v4) & 0xFFFFFF00) != (_DWORD)v2)
  {
    int v5 = (unsigned int *)(*(void *)this + 4LL * v4 + 4);
    do
    {
      unsigned int v6 = *v5++;
      uint64_t v2 = v6;
    }

    while ((v6 & 0x80) != 0);
  }

  return (v2 << 32) | 0x5000500;
}

uint64_t icu::CollationRootElements::getPrimaryBefore( icu::CollationRootElements *this, icu::Collation *a2, int a3)
{
  int v6 = icu::CollationRootElements::findP(this, a2);
  uint64_t v7 = *(void *)this;
  int v8 = *(_DWORD *)(*(void *)this + 4LL * v6);
  if ((v8 & 0xFFFFFF00) == (_DWORD)a2)
  {
    int v9 = *(_DWORD *)(*(void *)this + 4LL * v6) & 0x7F;
    if ((v8 & 0x7F) == 0)
    {
      unsigned int v10 = (int *)(v7 + 4LL * v6 - 4);
      do
      {
        int v12 = *v10--;
        int v11 = v12;
      }

      while ((v12 & 0x80) != 0);
      return v11 & 0xFFFFFF00;
    }
  }

  else
  {
    int v9 = *(_DWORD *)(v7 + 4LL * (v6 + 1)) & 0x7F;
  }

  if ((_WORD)a2) {
    return icu::Collation::decThreeBytePrimaryByOneStep(a2, a3, v9);
  }
  else {
    return icu::Collation::decTwoBytePrimaryByOneStep(a2, a3, v9);
  }
}

uint64_t icu::CollationRootElements::getSecondaryBefore( icu::CollationRootElements *this, unsigned int a2, unsigned int a3)
{
  if (a2)
  {
    LODWORD(v5) = icu::CollationRootElements::findP(this, a2) + 1;
    uint64_t v6 = *(void *)this;
    int v7 = *(_DWORD *)(*(void *)this + 4LL * (int)v5);
    unsigned int v8 = v7 & 0xFFFFFF7F;
    if ((v7 & 0xFFFFFF7F) >= 0x5000500) {
      unsigned int v8 = 83887360;
    }
    if ((v7 & 0x80) != 0) {
      unsigned int v9 = v8;
    }
    else {
      unsigned int v9 = 83887360;
    }
    uint64_t result = 256LL;
  }

  else
  {
    uint64_t result = 0LL;
    uint64_t v6 = *(void *)this;
    uint64_t v5 = *(int *)(*(void *)this + 4LL);
    unsigned int v9 = *(_DWORD *)(*(void *)this + 4 * v5);
  }

  uint64_t v11 = HIWORD(v9);
  if (v11 < a3)
  {
    int v12 = (unsigned int *)(v6 + 4LL * (int)v5);
    do
    {
      uint64_t result = v11;
      unsigned int v13 = *v12++;
      uint64_t v11 = HIWORD(v13);
    }

    while (v11 < a3);
  }

  return result;
}

uint64_t icu::CollationRootElements::getFirstSecTerForPrimary(icu::CollationRootElements *this, int a2)
{
  int v2 = *(_DWORD *)(*(void *)this + 4LL * a2);
  unsigned int v3 = v2 & 0xFFFFFF7F;
  if ((v2 & 0xFFFFFF7F) >= 0x5000500) {
    unsigned int v3 = 83887360;
  }
  if ((v2 & 0x80) != 0) {
    return v3;
  }
  else {
    return 83887360LL;
  }
}

uint64_t icu::CollationRootElements::getTertiaryBefore( icu::CollationRootElements *this, unsigned int a2, int a3, int a4)
{
  if (a2)
  {
    LODWORD(v7) = icu::CollationRootElements::findP(this, a2) + 1;
    uint64_t v8 = *(void *)this;
    int v9 = *(_DWORD *)(*(void *)this + 4LL * (int)v7);
    unsigned int v10 = v9 & 0xFFFFFF7F;
    if ((v9 & 0xFFFFFF7F) >= 0x5000500) {
      unsigned int v10 = 83887360;
    }
    if ((v9 & 0x80) == 0) {
      unsigned int v10 = 83887360;
    }
    unsigned __int16 v11 = 256;
  }

  else
  {
    uint64_t v8 = *(void *)this;
    unsigned __int16 v11 = (a3 != 0) << 8;
    uint64_t v7 = *(int *)(*(void *)this + 4LL * (a3 != 0));
    unsigned int v10 = *(_DWORD *)(*(void *)this + 4 * v7) & 0xFFFFFF7F;
  }

  unsigned int v12 = a4 | (a3 << 16);
  if (v12 > v10)
  {
    unsigned int v13 = (int *)(v8 + 4LL * (int)v7);
    do
    {
      if (a3 == HIWORD(v10)) {
        unsigned __int16 v11 = v10;
      }
      int v14 = *v13++;
      unsigned int v10 = v14 & 0xFFFFFF7F;
    }

    while (v12 > (v14 & 0xFFFFFF7F));
  }

  return v11;
}

uint64_t icu::CollationRootElements::getPrimaryAfter( icu::CollationRootElements *this, icu::Collation *a2, int a3, int a4)
{
  uint64_t v4 = *(void *)this;
  uint64_t result = *(unsigned int *)(*(void *)this + 4LL * (a3 + 1));
  if ((result & 0x80) != 0)
  {
    uint64_t v7 = (unsigned int *)(v4 + 4LL * a3 + 8);
    do
    {
      unsigned int v8 = *v7++;
      uint64_t result = v8;
    }

    while ((v8 & 0x80) != 0);
  }

  else
  {
    int v6 = result & 0x7F;
    if ((result & 0x7F) != 0)
    {
      if ((_WORD)a2) {
        return icu::Collation::incThreeBytePrimaryByOffset(a2, a4, v6);
      }
      else {
        return icu::Collation::incTwoBytePrimaryByOffset(a2, a4, v6);
      }
    }
  }

  return result;
}

uint64_t icu::CollationRootElements::getSecondaryAfter( icu::CollationRootElements *this, uint64_t a2, unsigned int a3)
{
  if ((_DWORD)a2)
  {
    uint64_t v3 = *(void *)this;
    int v4 = *(_DWORD *)(*(void *)this + 4LL * ((int)a2 + 1));
    unsigned int v5 = v4 & 0xFFFFFF7F;
    if ((v4 & 0xFFFFFF7F) >= 0x5000500) {
      unsigned int v5 = 83887360;
    }
    if ((v4 & 0x80) != 0) {
      unsigned int v6 = v5;
    }
    else {
      unsigned int v6 = 83887360;
    }
    uint64_t result = (*(_DWORD *)(v3 + 16) >> 8) & 0xFF00;
  }

  else
  {
    uint64_t v3 = *(void *)this;
    a2 = *(int *)(*(void *)this + 4LL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 4 * a2);
    uint64_t result = 0x10000LL;
  }

  for (int i = (unsigned int *)(v3 + 4LL * (int)a2 + 4); ; ++i)
  {
    uint64_t v9 = HIWORD(v6);
    unsigned int v10 = *i;
    unsigned int v6 = v10;
    if ((v10 & 0x80) == 0) {
      return result;
    }
  }

  return v9;
}

uint64_t icu::CollationRootElements::getTertiaryAfter(int **this, uint64_t a2, unsigned int a3, int a4)
{
  int v4 = *this;
  if ((_DWORD)a2)
  {
    int v5 = v4[(int)a2 + 1];
    unsigned int v6 = v5 & 0xFFFFFF7F;
    if ((v5 & 0xFFFFFF7F) >= 0x5000500) {
      unsigned int v6 = 83887360;
    }
    if ((v5 & 0x80) != 0) {
      unsigned int v7 = v6;
    }
    else {
      unsigned int v7 = 83887360;
    }
    uint64_t result = v4[4] << 8;
  }

  else
  {
    if (a3)
    {
      uint64_t v9 = v4 + 1;
      uint64_t result = v4[4] << 8;
    }

    else
    {
      uint64_t result = 0x4000LL;
      uint64_t v9 = v4;
    }

    a2 = *v9;
    unsigned int v7 = v4[a2] & 0xFFFFFF7F;
  }

  unsigned int v10 = a4 | (a3 << 16);
  if (v7 > v10) {
    return (unsigned __int16)v7;
  }
  unsigned __int16 v11 = &v4[(int)a2 + 1];
  while (1)
  {
    unsigned int v13 = *v11++;
    unsigned int v12 = v13;
    if ((v13 & 0x80) == 0 || HIWORD(v12) > a3) {
      break;
    }
    unsigned int v7 = v12 & 0xFFFFFF7F;
    if (v7 > v10) {
      return (unsigned __int16)v7;
    }
  }

  return result;
}

icu::CollationRuleParser *icu::CollationRuleParser::CollationRuleParser( icu::CollationRuleParser *this, UErrorCode *a2, UErrorCode *a3)
{
  *(void *)this = icu::Normalizer2::getNFDInstance((icu::Normalizer2 *)a3, a2);
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = icu::Normalizer2::getNFCInstance((icu::Normalizer2 *)a3, v6);
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = a2;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  return this;
}

{
  UErrorCode *v6;
  *(void *)this = icu::Normalizer2::getNFDInstance((icu::Normalizer2 *)a3, a2);
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = icu::Normalizer2::getNFCInstance((icu::Normalizer2 *)a3, v6);
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = a2;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  return this;
}

void *icu::CollationRuleParser::parse( void *this, const icu::UnicodeString *a2, icu::CollationSettings *a3, UParseError *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    this[4] = a3;
    this[5] = a4;
    if (a4)
    {
      *(void *)&a4->line = 0xFFFFFFFF00000000LL;
      a4->preContext[0] = 0;
      a4->postContext[0] = 0;
    }

    this[6] = 0LL;
    return (void *)icu::CollationRuleParser::parse((uint64_t)this, a2, a5);
  }

  return this;
}

uint64_t icu::CollationRuleParser::parse(uint64_t this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    uint64_t v4 = this;
    int v5 = 0;
    *(void *)(this + 1--*((_DWORD *)this + 6) = a2;
    *(_DWORD *)(this + 72) = 0;
    while (1)
    {
      unsigned int v6 = *((unsigned __int16 *)a2 + 4);
      if (*((__int16 *)a2 + 4) < 0)
      {
        int v7 = *((_DWORD *)a2 + 3);
        if (v5 >= v7) {
          return this;
        }
      }

      else
      {
        int v7 = v6 >> 5;
      }

      if (v7 <= v5)
      {
        uint64_t v9 = 0xFFFFLL;
      }

      else
      {
        if ((v6 & 2) != 0) {
          unsigned int v8 = (char *)a2 + 10;
        }
        else {
          unsigned int v8 = (char *)*((void *)a2 + 3);
        }
        uint64_t v9 = *(unsigned __int16 *)&v8[2 * v5];
      }

      this = icu::PatternProps::isWhiteSpace((icu::PatternProps *)v9);
      if ((_DWORD)this)
      {
        int v5 = *(_DWORD *)(v4 + 72) + 1;
        *(_DWORD *)(v4 + 72) = v5;
        goto LABEL_32;
      }

      if ((int)v9 <= 37)
      {
        if ((_DWORD)v9 == 33) {
          goto LABEL_26;
        }
        if ((_DWORD)v9 != 35)
        {
LABEL_27:
          *a3 = U_INVALID_FORMAT_ERROR;
          *(void *)(v4 + 48) = "expected a reset or setting or comment";
          if (!*(void *)(v4 + 40)) {
            return this;
          }
          this = (uint64_t)icu::CollationRuleParser::setErrorContext((char *)v4);
          goto LABEL_30;
        }

        this = icu::CollationRuleParser::skipComment((icu::CollationRuleParser *)v4, *(_DWORD *)(v4 + 72) + 1);
        *(_DWORD *)(v4 + 72) = this;
      }

      else
      {
        switch((_DWORD)v9)
        {
          case '[':
            this = (uint64_t)icu::CollationRuleParser::parseSetting((icu::CollationRuleParser *)v4, a3);
            break;
          case '@':
            this = icu::CollationSettings::setFlag(*(void *)(v4 + 32), 2048, 17, 0, (int *)a3);
LABEL_26:
            ++*(_DWORD *)(v4 + 72);
            break;
          case '&':
            this = icu::CollationRuleParser::parseRuleChain((icu::CollationRuleParser *)v4, a3);
            break;
          default:
            goto LABEL_27;
        }
      }

uint64_t icu::CollationRuleParser::parseRuleChain(icu::CollationRuleParser *this, UErrorCode *a2)
{
  int v4 = icu::CollationRuleParser::parseResetAndPosition(this, a2);
  uint64_t result = icu::CollationRuleParser::parseRelationOperator(this, a2);
  int v6 = 1;
  while ((result & 0x80000000) == 0)
  {
    uint64_t v7 = result & 0xF;
    if (v4 <= 14)
    {
      if (v6)
      {
        if ((_DWORD)v7 != v4)
        {
          *a2 = U_INVALID_FORMAT_ERROR;
          int v14 = "reset-before strength differs from its first relation";
          goto LABEL_30;
        }
      }

      else if ((int)v7 < v4)
      {
        *a2 = U_INVALID_FORMAT_ERROR;
        int v14 = "reset-before strength followed by a stronger relation";
        goto LABEL_30;
      }
    }

    int v13 = *((_DWORD *)this + 18) + (result >> 8);
    if ((result & 0x10) != 0) {
      uint64_t result = (uint64_t)icu::CollationRuleParser::parseStarredCharacters(this, v7, v13, a2);
    }
    else {
      uint64_t result = (uint64_t)icu::CollationRuleParser::parseRelationStrings(this, v7, v13, a2);
    }
    int v6 = 0;
LABEL_25:
    uint64_t result = icu::CollationRuleParser::parseRelationOperator(this, a2);
  }

  uint64_t v8 = *((int *)this + 18);
  uint64_t v9 = *((void *)this + 2);
  unsigned int v10 = *(unsigned __int16 *)(v9 + 8);
  if (*(__int16 *)(v9 + 8) < 0)
  {
    int v11 = *(_DWORD *)(v9 + 12);
  }

  else
  {
    int v11 = v10 >> 5;
  }

  if (v11 > v8)
  {
    uint64_t v12 = (v10 & 2) != 0 ? v9 + 10 : *(void *)(v9 + 24);
    if (*(_WORD *)(v12 + 2 * v8) == 35)
    {
      *((_DWORD *)this + 18) = icu::CollationRuleParser::skipComment(this, (int)v8 + 1);
      goto LABEL_25;
    }
  }

icu::CollationRuleParser *icu::CollationRuleParser::parseSetting( icu::CollationRuleParser *this, UErrorCode *a2)
{
  v173[5] = *MEMORY[0x1895F89C0];
  if (*(int *)a2 <= 0)
  {
    uint64_t v3 = (uint64_t)this;
    __int128 v172 = 0u;
    memset(v173, 0, 40);
    int8x16_t v171 = off_18971B688;
    LOWORD(v172) = 2;
    int v4 = *((_DWORD *)this + 18) + 1;
    int Words = icu::CollationRuleParser::readWords(this, v4, (icu::UnicodeString *)&v171);
    if (Words <= v4)
    {
    }

    else if ((unsigned __int16)v172 > 0x1Fu || *(int *)a2 >= 1)
    {
      goto LABEL_9;
    }

    *a2 = U_INVALID_FORMAT_ERROR;
    *(void *)(v3 + 48) = "expected a setting/option at '['";
    if (*(void *)(v3 + 40)) {
      icu::CollationRuleParser::setErrorContext((char *)v3);
    }
LABEL_9:
    uint64_t v6 = *(void *)(v3 + 16);
    unsigned int v7 = *(unsigned __int16 *)(v6 + 8);
    unsigned int v8 = v7 >> 5;
    else {
      unsigned int v9 = v7 >> 5;
    }
    if (v9 > Words)
    {
      uint64_t v10 = (v7 & 2) != 0 ? v6 + 10 : *(void *)(v6 + 24);
      if (*(_WORD *)(v10 + 2LL * Words) == 93)
      {
        int v11 = Words + 1;
        uint64_t v145 = L"reorder";
        icu::UnicodeString::UnicodeString(&__src, 1LL, &v145);
        if ((SWORD4(__src) & 0x8000u) == 0) {
          int32_t v12 = WORD4(__src) >> 5;
        }
        else {
          int32_t v12 = HIDWORD(__src);
        }
        if ((BYTE8(__src) & 1) != 0)
        {
          BOOL v24 = v172 & 1;
          goto LABEL_51;
        }

        int v13 = v12 & (v12 >> 31);
        if (v12 < 0)
        {
          int32_t v14 = 0;
        }

        else
        {
          int32_t v14 = v12 - v13;
          int32_t v15 = v12;
          if (v12 - v13 >= v12)
          {
LABEL_45:
            if ((v172 & 1) != 0)
            {
              BOOL v24 = 0LL;
            }

            else
            {
              if ((BYTE8(__src) & 2) != 0) {
                int v25 = (char *)&__src + 10;
              }
              else {
                int v25 = (char *)*((void *)&v147 + 1);
              }
              BOOL v24 = icu::UnicodeString::doEqualsSubstring((uint64_t)&v171, 0, v12, (uint64_t)v25, v13, v15);
            }

LABEL_84:
                __int128 v167 = 0u;
                uint64_t v170 = 0LL;
                __int128 v169 = 0u;
                __int128 v168 = 0u;
                uint64_t v166 = off_18971B688;
                LOWORD(v167) = 2;
                if ((v172 & 0x8000u) == 0LL) {
                  int32_t v36 = (unsigned __int16)v172 >> 5;
                }
                else {
                  int32_t v36 = DWORD1(v172);
                }
                unsigned int IndexOf = icu::UnicodeString::doLastIndexOf((uint64_t)&v171, 0x20u, 0, v36);
                if ((IndexOf & 0x80000000) != 0) {
                  goto LABEL_116;
                }
                unsigned int v38 = IndexOf;
                int v39 = IndexOf + 1;
                icu::UnicodeString::unBogus((uint64_t)&v166);
                if ((__int16)v172 < 0)
                {
                  int v40 = DWORD1(v172);
                }

                else if (v38 >= (unsigned __int16)v172 >> 5)
                {
                  int v40 = (unsigned __int16)v172 >> 5;
LABEL_92:
                  int v39 = v40;
                }

                if ((v167 & 0x8000u) == 0LL) {
                  uint64_t v41 = (unsigned __int16)v167 >> 5;
                }
                else {
                  uint64_t v41 = DWORD1(v167);
                }
                int v42 = (unsigned __int16)v172 >> 5;
                if ((v172 & 0x8000u) != 0LL) {
                  int v42 = DWORD1(v172);
                }
                icu::UnicodeString::doReplace( (icu::UnicodeString *)&v166,  0LL,  v41,  (const icu::UnicodeString *)&v171,  v39,  (v42 - v39));
                if (v38 || (v172 & 1) == 0)
                {
                  if ((v172 & 0x8000u) == 0LL) {
                    unsigned int v43 = (unsigned __int16)v172 >> 5;
                  }
                  else {
                    unsigned int v43 = DWORD1(v172);
                  }
                  if (v43 > v38)
                  {
                    if (v38 > 0x3FF)
                    {
                      LOWORD(v172) = v172 | 0xFFE0;
                      DWORD1(v172) = v38;
                    }

                    else
                    {
                      LOWORD(v172) = v172 & 0x1F | (32 * v38);
                    }
                  }
                }

                else
                {
                  icu::UnicodeString::unBogus((uint64_t)&v171);
                }

        int v48 = offset;
        if (offset >= v9)
        {
          char v47 = 0;
          goto LABEL_137;
        }

        unint64_t v49 = 0;
        int v50 = 0;
        char v78 = *(_DWORD *)(*(void *)(*(void *)(v74 + 8) + 136LL) + 8LL);
        while (2)
        {
          char v51 = replacementText[v48];
          if ((v51 & 0xF800) == 0xD800)
          {
            if ((v51 & 0x400) != 0)
            {
              if (v48 >= 1)
              {
                int v56 = replacementText[v48 - 1];
                int v54 = (v56 & 0xFC00) == 55296;
                char v55 = v51 - 56613888 + (v56 << 10);
                goto LABEL_92;
              }
            }

            else
            {
              __int16 v52 = v48 + 1LL;
              if ((_DWORD)v52 != v9)
              {
                unsigned int v53 = replacementText[v52];
                int v54 = (v53 & 0xFC00) == 56320;
                char v55 = (v51 << 10) - 56613888 + v53;
LABEL_92:
                if (v54) {
                  char v51 = v55;
                }
              }
            }
          }

          if (!u_isdigit(v51))
          {
            char v47 = v50;
            goto LABEL_137;
          }

          int v57 = u_charDigitValue(v51);
          char v47 = v57 + 10 * v50;
          if (v47 > v78)
          {
            char v47 = v50;
            if (v49) {
              goto LABEL_137;
            }
            BOOL v73 = U_INDEX_OUTOFBOUNDS_ERROR;
            int v18 = v76;
            goto LABEL_148;
          }

          BOOL v58 = offset;
          int v48 = ++offset;
          unsigned int v59 = (replacementText[v58] & 0xFC00) != 0xD800 || v48 == v9;
          if (!v59 && (replacementText[v48] & 0xFC00) == 0xDC00)
          {
            int v48 = v58 + 2;
            int32_t offset = v58 + 2;
          }

          --v49;
          int v50 = v57 + 10 * v50;
          if (v48 >= v9) {
            goto LABEL_137;
          }
          continue;
        }
      }

      unsigned int v38 = replacementText[(int)v35];
      int v39 = v33 + 2;
      if ((v38 & 0xFC00) == 0xD800 && (_DWORD)v39 != v9)
      {
        uint64_t v41 = replacementText[v39];
        int v13 = (v41 & 0xFC00) == 56320;
        int v42 = (v38 << 10) - 56613888 + v41;
        if (v13) {
          unsigned int v38 = v42;
        }
      }

      if (u_isdigit(v38)) {
        goto LABEL_84;
      }
      if (v38 != 123) {
        goto LABEL_147;
      }
      BOOL v84 = 0LL;
      uint64_t v82 = 0u;
      int v83 = 0u;
      int v81 = 0u;
      *(void *)statusa = off_18971B688;
      LOWORD(v8sub_18086E18C((uint64_t)this, 1) = 2;
      unsigned int v43 = offset;
      BOOL v44 = ++offset;
      unsigned int v45 = (replacementText[v43] & 0xFC00) != 0xD800 || v44 == v9;
      if (!v45 && (replacementText[v44] & 0xFC00) == 0xDC00) {
        int32_t offset = v43 + 2;
      }
      int v46 = *(unsigned int *)status;
      if ((int)v46 > 0)
      {
LABEL_76:
        char v47 = 0;
        goto LABEL_136;
      }

      while (1)
      {
        int v46 = offset;
        if (offset >= v9) {
          goto LABEL_135;
        }
        BOOL v61 = ++offset;
        int v62 = replacementText[v46];
        if ((v62 & 0xFC00) == 0xD800 && v61 != v9)
        {
          BOOL v64 = replacementText[v61];
          if ((v64 & 0xFC00) == 0xDC00)
          {
            int32_t offset = v46 + 2;
            int v62 = (v62 << 10) - 56613888 + v64;
          }
        }

        if ((v62 & 0xFFFFFFDF) - 65 >= 0x1A && v62 - 49 > 8) {
          break;
        }
        icu::UnicodeString::append((uint64_t)statusa, v62);
LABEL_128:
        int v46 = *(unsigned int *)status;
      }

      if (v62 != 125) {
        break;
      }
      int v46 = *((void *)regexp + 1);
      char v67 = *(void *)(v46 + 192);
      if (!v67 || (char v47 = uhash_geti(v67, (uint64_t)statusa)) == 0)
      {
LABEL_135:
        char v47 = 0;
        *statUChar us = U_REGEX_INVALID_CAPTURE_GROUP_NAME;
      }

LABEL_141:
                    __int32 v142 = "a";
                    icu::UnicodeString::UnicodeString(&__src, 1LL, &v142);
                    if ((v172 & 1) != 0)
                    {
                      int v56 = (void *)WORD4(__src);
                      int v57 = BYTE8(__src) & 1;
                    }

                    else
                    {
                      if ((v172 & 0x8000u) == 0LL) {
                        int v54 = (unsigned __int16)v172 >> 5;
                      }
                      else {
                        int v54 = DWORD1(v172);
                      }
                      if ((SWORD4(__src) & 0x8000u) == 0) {
                        char v55 = (void *)(WORD4(__src) >> 5);
                      }
                      else {
                        char v55 = (void *)HIDWORD(__src);
                      }
                      if ((BYTE8(__src) & 1) != 0 || v54 != (_DWORD)v55)
                      {
                        icu::UnicodeString::~UnicodeString(v55, (icu::UnicodeString *)&__src);
                        v121[4] = (uint64_t)v142;
                        goto LABEL_156;
                      }

                      int v57 = icu::UnicodeString::doEquals( (icu::UnicodeString *)&v171,  (const icu::UnicodeString *)&__src,  v54);
                    }

                    icu::UnicodeString::~UnicodeString(v56, (icu::UnicodeString *)&__src);
                    v121[3] = (uint64_t)v142;
                    if (v57)
                    {
                      __int32 v141 = "n";
                      icu::UnicodeString::UnicodeString(&__src, 1LL, &v141);
                      BOOL v58 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                      icu::UnicodeString::~UnicodeString(v59, (icu::UnicodeString *)&__src);
                      v114[1] = v141;
                      if (v58)
                      {
                        int v60 = 21;
LABEL_164:
                        icu::CollationSettings::setAlternateHandling(*(void *)(v3 + 32), v60, 0, (int *)a2);
LABEL_189:
                        *(_DWORD *)(v3 + 72) = v11;
LABEL_190:
                        icu::UnicodeString::~UnicodeString((void *)v49, (icu::UnicodeString *)&v166);
                        return (icu::CollationRuleParser *)icu::UnicodeString::~UnicodeString( v29,  (icu::UnicodeString *)&v171);
                      }

                      int8x8_t v140 = "s";
                      icu::UnicodeString::UnicodeString(&__src, 1LL, &v140);
                      BOOL v71 = sub_1807FF934((uint64_t)&v166, (uint64_t)&__src);
                      icu::UnicodeString::~UnicodeString(v72, (icu::UnicodeString *)&__src);
                      v114[0] = v140;
                      unint64_t v49 = (unint64_t)v114;
                      if (v71)
                      {
                        int v60 = 20;
                        goto LABEL_164;
                      }

                      goto LABEL_211;
                    }

            char v88 = icu::UMemory::operator new(v41, (icu::UMemory *)0x70, v35);
            unsigned int v89 = *(void *)(a1 + 104);
            if (!v88) {
              goto LABEL_233;
            }
            sub_180990750((uint64_t)v88, a5, v143, v43, 0, *(void *)(v89 + 96));
            if ((_DWORD)v24 == 63)
            {
              unsigned int v92 = 0;
              char v91 = 1LL;
            }

            else
            {
              if ((_DWORD)v24 == 43)
              {
                char v91 = 0x7FFFFFFFLL;
                __int32 v142 = 0x7FFFFFFF;
                unsigned int v92 = 1;
LABEL_175:
                unsigned int v115 = icu::UMemory::operator new((uint64_t *)v91, (icu::UMemory *)0x20, v90);
                if (!v115)
                {
LABEL_232:
                  unsigned int v89 = *(void *)(a1 + 104);
LABEL_233:
                  unint64_t v19 = v147;
                  sub_18095F4F8(v89, 7, a2, v147, a8);
                  goto LABEL_245;
                }

                int v116 = v115;
                sub_180957598((uint64_t)v115, (uint64_t)v88, v92, v142);
                sub_1808623BC(a5, v143);
                int v105 = sub_18095E428(*(void *)(a1 + 104), v116, a8);
LABEL_177:
                LOWORD(v162[0]) = v105;
                icu::UnicodeString::doAppend(a5, (uint64_t)v162, 0, 1LL);
LABEL_178:
                unsigned int v8 = v147;
                a6 = v146;
                break;
              }

              unsigned int v92 = 0;
              char v91 = 0x7FFFFFFFLL;
            }

            __int32 v142 = v91;
            goto LABEL_175;
          case '@':
            unsigned int v109 = *(_DWORD *)(a1 + 84);
            if (v109 < 0)
            {
              unsigned int v121 = *(unsigned __int16 *)(a5 + 8);
              int v122 = (__int16)v121;
              v123 = v121 >> 5;
              if (v122 < 0) {
                v123 = *(_DWORD *)(a5 + 12);
              }
              if (v123 >= 1)
              {
LABEL_237:
                uint64_t v26 = *(void *)(a1 + 104);
                __int32 v139 = 65545;
                goto LABEL_243;
              }

              int v11 = (v109 - 1);
              goto LABEL_196;
            }

            if (v109)
            {
              unsigned int v110 = *(unsigned __int16 *)(a5 + 8);
              unsigned int v111 = (__int16)v110;
              uint64_t v112 = v110 >> 5;
              if (v111 < 0) {
                uint64_t v112 = *(_DWORD *)(a5 + 12);
              }
              if (v112 != *(_DWORD *)(a1 + 88) || (*(_DWORD *)(a1 + 72) & 0x80000000) == 0) {
                goto LABEL_237;
              }
              int v11 = (v109 + 1);
LABEL_196:
              *(_DWORD *)(a1 + 84) = v11;
              break;
            }

            int v131 = *(_DWORD *)(a1 + 72);
            if (!v131)
            {
              __int32 v136 = *(unsigned __int16 *)(a5 + 8);
              __int32 v137 = (__int16)v136;
              uint64_t v138 = v136 >> 5;
              if (v137 < 0) {
                uint64_t v138 = *(_DWORD *)(a5 + 12);
              }
              if (v138) {
                goto LABEL_237;
              }
              int v11 = 0xFFFFFFFFLL;
              goto LABEL_196;
            }

            if ((v131 & 0x80000000) == 0) {
              goto LABEL_237;
            }
            uint64_t v132 = *(unsigned __int16 *)(a5 + 8);
            uint64_t v133 = (__int16)v132;
            __int32 v134 = v132 >> 5;
            if (v133 >= 0) {
              int v135 = v134;
            }
            else {
              int v135 = *(_DWORD *)(a5 + 12);
            }
            int v11 = 1LL;
            *(_DWORD *)(a1 + 84) = 1;
            *(_DWORD *)(a1 + 88) = v135;
            break;
          case '^':
            unsigned int v38 = *(unsigned __int16 *)(a5 + 8);
            int v39 = (__int16)v38;
            int v40 = v38 >> 5;
            if (v39 < 0) {
              int v40 = *(_DWORD *)(a5 + 12);
            }
            if (v40 || *(_BYTE *)(a1 + 92))
            {
              uint64_t v26 = *(void *)(a1 + 104);
              __int32 v139 = 65544;
              goto LABEL_243;
            }

            int v11 = 1LL;
            *(_BYTE *)(a1 + 92) = 1;
            break;
          default:
            goto LABEL_179;
        }
      }

      else if ((int)v24 > 124)
      {
        if ((_DWORD)v24 != 125)
        {
          if ((_DWORD)v24 != 8710)
          {
LABEL_179:
            if ((unsigned __int16)(v24 - 127) >= 0xFFA2u
              && (unsigned __int16)(v24 - 48) >= 0xAu
              && (unsigned __int16)((v24 & 0xFFDF) - 65) >= 0x1Au)
            {
              uint64_t v26 = *(void *)(a1 + 104);
              __int32 v139 = 65555;
              goto LABEL_243;
            }

            LOWORD(v162[0]) = v24;
LABEL_183:
            icu::UnicodeString::doAppend(a5, (uint64_t)v162, 0, 1LL);
            goto LABEL_21;
          }

uint64_t icu::CollationRuleParser::skipComment(icu::CollationRuleParser *this, int a2)
{
  uint64_t v2 = *((void *)this + 2);
  unint64_t v3 = *(unsigned __int16 *)(v2 + 8);
  uint64_t result = a2;
  if ((v3 & 0x8000) != 0) {
    goto LABEL_4;
  }
LABEL_2:
  uint64_t v5 = v3 >> 5;
  if (result < (uint64_t)(v3 >> 5))
  {
    while (1)
    {
      if (v5 > result)
      {
        uint64_t v6 = v2 + 10;
        if ((v3 & 2) == 0) {
          uint64_t v6 = *(void *)(v2 + 24);
        }
        unsigned int v7 = *(unsigned __int16 *)(v6 + 2 * result);
        BOOL v8 = v7 > 0xD || ((1 << v7) & 0x3400) == 0;
        BOOL v9 = v8 && v7 - 8232 >= 2;
        if (!v9 || v7 == 133) {
          return (result + 1);
        }
      }

      ++result;
      if ((v3 & 0x8000) == 0) {
        goto LABEL_2;
      }
LABEL_4:
      uint64_t v5 = *(int *)(v2 + 12);
      if (result >= v5) {
        return result;
      }
    }
  }

  return result;
}

char *icu::CollationRuleParser::setParseError(char *this, const char *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    *a3 = U_INVALID_FORMAT_ERROR;
    *((void *)this + --*((_DWORD *)this + 6) = a2;
    if (*((void *)this + 5)) {
      return icu::CollationRuleParser::setErrorContext(this);
    }
  }

  return this;
}

uint64_t icu::CollationRuleParser::parseResetAndPosition(icu::CollationRuleParser *this, UErrorCode *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v6 = icu::CollationRuleParser::skipWhiteSpace(this, *((_DWORD *)this + 18) + 1);
  int v10 = v6 + 7;
  uint64_t v11 = *((void *)this + 2);
  unsigned int v12 = *(unsigned __int16 *)(v11 + 8);
  if (*(__int16 *)(v11 + 8) < 0)
  {
    unsigned int v13 = *(_DWORD *)(v11 + 12);
  }

  else
  {
    unsigned int v13 = v12 >> 5;
  }

  if (v13 <= v10)
  {
    uint64_t v19 = 0xFFFFLL;
  }

  else
  {
    if ((v12 & 2) != 0) {
      uint64_t v15 = v11 + 10;
    }
    else {
      uint64_t v15 = *(void *)(v11 + 24);
    }
    uint64_t v19 = *(unsigned __int16 *)(v15 + 2LL * v10);
  }

  if (!icu::PatternProps::isWhiteSpace((icu::PatternProps *)v19)) {
    goto LABEL_5;
  }
  signed int v20 = icu::CollationRuleParser::skipWhiteSpace(this, (int)v6 + 8);
  uint64_t v21 = v20 + 1LL;
  uint64_t v22 = *((void *)this + 2);
  unsigned int v23 = *(unsigned __int16 *)(v22 + 8);
  if ((v23 & 0x8000) != 0)
  {
    int v24 = *(_DWORD *)(v22 + 12);
LABEL_5:
    uint64_t v2 = 15LL;
    goto LABEL_6;
  }

  int v24 = v23 >> 5;
LABEL_39:
  uint64_t v25 = (v23 & 2) != 0 ? v22 + 10 : *(void *)(v22 + 24);
  uint64_t v2 = *(unsigned __int16 *)(v25 + 2LL * v20) - 49;
  unsigned int v26 = (v23 & 0x8000) != 0 ? *(_DWORD *)(v22 + 12) : v23 >> 5;
  uint64_t v27 = (v23 & 2) != 0 ? v22 + 10 : *(void *)(v22 + 24);
  if (*(_WORD *)(v27 + 2 * v21) != 93) {
    goto LABEL_5;
  }
  uint64_t v6 = icu::CollationRuleParser::skipWhiteSpace(this, v20 + 2);
LABEL_6:
  uint64_t v7 = *((void *)this + 2);
  unsigned int v8 = *(unsigned __int16 *)(v7 + 8);
  if ((*(__int16 *)(v7 + 8) & 0x80000000) == 0)
  {
    if ((int)v6 < (int)(v8 >> 5))
    {
      unsigned int v9 = v8 >> 5;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      uint64_t v32 = 0LL;
      __int128 v31 = 0u;
      int v28 = off_18971B688;
      LOWORD(v29) = 2;
      goto LABEL_14;
    }

uint64_t icu::CollationRuleParser::parseRelationOperator(icu::CollationRuleParser *this, UErrorCode *a2)
{
  int v5 = icu::CollationRuleParser::skipWhiteSpace(this, *((_DWORD *)this + 18));
  *((_DWORD *)this + 18) = v5;
  uint64_t v6 = *((void *)this + 2);
  unsigned int v7 = *(unsigned __int16 *)(v6 + 8);
  if (*(__int16 *)(v6 + 8) < 0)
  {
    unsigned int v8 = *(_DWORD *)(v6 + 12);
  }

  else
  {
    unsigned int v8 = v7 >> 5;
  }

  if (v8 > v5)
  {
    uint64_t v9 = v5 + 1LL;
    if ((v7 & 2) != 0) {
      uint64_t v10 = v6 + 10;
    }
    else {
      uint64_t v10 = *(void *)(v6 + 24);
    }
    int v11 = *(unsigned __int16 *)(v10 + 2LL * v5);
    uint64_t v2 = 0xFFFFFFFFLL;
    if (v11 <= 59)
    {
      if (v11 == 44)
      {
        int v12 = 2;
      }

      else
      {
        if (v11 != 59) {
          return v2;
        }
        int v12 = 1;
      }

      return v12 | (((_DWORD)v9 - v5) << 8);
    }

    if (v11 != 61)
    {
      if (v11 != 60) {
        return v2;
      }
      if ((v7 & 0x8000) != 0)
      {
        int v13 = *(_DWORD *)(v6 + 12);
        if ((int)v9 >= v13)
        {
          int v12 = 0;
          goto LABEL_55;
        }
      }

      else
      {
        int v13 = v7 >> 5;
        if ((int)v9 >= (int)(v7 >> 5))
        {
          int v12 = 0;
LABEL_56:
          if ((int)v9 < v13 && v13 > v9)
          {
            if ((v7 & 2) != 0) {
              uint64_t v19 = v6 + 10;
            }
            else {
              uint64_t v19 = *(void *)(v6 + 24);
            }
            if (*(_WORD *)(v19 + 2LL * (int)v9) == 42)
            {
              v12 |= 0x10u;
              LODWORD(v9) = v9 + 1;
            }
          }

          return v12 | (((_DWORD)v9 - v5) << 8);
        }
      }

      if (v13 > v9
        && ((v7 & 2) != 0 ? (uint64_t v15 = v6 + 10) : (uint64_t v15 = *(void *)(v6 + 24)), *(_WORD *)(v15 + 2 * v9) == 60))
      {
        uint64_t v9 = v5 + 2LL;
        if ((v7 & 0x8000) != 0)
        {
          int v13 = *(_DWORD *)(v6 + 12);
          if ((int)v9 >= v13)
          {
            int v12 = 1;
            goto LABEL_55;
          }
        }

        else
        {
          int v13 = v7 >> 5;
          if ((int)v9 >= (int)(v7 >> 5))
          {
            int v12 = 1;
            goto LABEL_56;
          }
        }

        if (v13 > v9
          && ((v7 & 2) != 0 ? (uint64_t v18 = v6 + 10) : (uint64_t v18 = *(void *)(v6 + 24)), *(_WORD *)(v18 + 2 * v9) == 60))
        {
          uint64_t v9 = v5 + 3LL;
          if ((v7 & 0x8000) != 0)
          {
            int v13 = *(_DWORD *)(v6 + 12);
            if ((int)v9 >= v13)
            {
              int v12 = 2;
              goto LABEL_55;
            }
          }

          else
          {
            int v13 = v7 >> 5;
            if ((int)v9 >= (int)(v7 >> 5))
            {
              int v12 = 2;
              goto LABEL_56;
            }
          }

          if (v13 <= v9)
          {
            int v12 = 2;
          }

          else
          {
            if ((v7 & 2) != 0) {
              uint64_t v20 = v6 + 10;
            }
            else {
              uint64_t v20 = *(void *)(v6 + 24);
            }
            BOOL v21 = *(unsigned __int16 *)(v20 + 2 * v9) == 60;
            if (*(_WORD *)(v20 + 2 * v9) == 60) {
              int v12 = 3;
            }
            else {
              int v12 = 2;
            }
            if (v21) {
              LODWORD(v9) = v5 + 4;
            }
          }
        }

        else
        {
          int v12 = 1;
        }
      }

      else
      {
        int v12 = 0;
      }

      if ((v7 & 0x8000) == 0)
      {
        int v13 = v7 >> 5;
        goto LABEL_56;
      }

void *icu::CollationRuleParser::parseRelationStrings( icu::CollationRuleParser *this, uint64_t a2, int a3, UErrorCode *a4)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  __int128 v37 = 0u;
  uint64_t v40 = 0LL;
  __int128 v39 = 0u;
  __int128 v38 = 0u;
  uint64_t v35 = 0LL;
  int32_t v36 = (UChar *)off_18971B688;
  LOWORD(v37) = 2;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  uint64_t v30 = 0LL;
  __int128 v31 = (UChar *)off_18971B688;
  LOWORD(v32) = 2;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  unsigned int v26 = off_18971B688;
  LOWORD(v27) = 2;
  int v7 = icu::CollationRuleParser::parseTailoringString(this, a3, (icu::UnicodeString *)&v31, a4);
  unsigned int v8 = (void *)*(unsigned int *)a4;
  int v9 = v7;
  uint64_t v10 = *((void *)this + 2);
  unsigned int v11 = *(unsigned __int16 *)(v10 + 8);
  if (*(__int16 *)(v10 + 8) < 0)
  {
    unsigned int v12 = *(_DWORD *)(v10 + 12);
  }

  else
  {
    unsigned int v12 = v11 >> 5;
  }

  if (v12 > v7)
  {
    if ((v11 & 2) != 0) {
      uint64_t v13 = v10 + 10;
    }
    else {
      uint64_t v13 = *(void *)(v10 + 24);
    }
    int v14 = *(unsigned __int16 *)(v13 + 2LL * v7);
    if (v14 != 124)
    {
LABEL_21:
      if (v14 == 47) {
        int v9 = icu::CollationRuleParser::parseTailoringString(this, v9 + 1, (icu::UnicodeString *)&v26, a4);
      }
      goto LABEL_23;
    }

    icu::UnicodeString::operator=(&v36, &v31);
    int v15 = icu::CollationRuleParser::parseTailoringString(this, v9 + 1, (icu::UnicodeString *)&v31, a4);
    unsigned int v8 = (void *)*(unsigned int *)a4;
    int v9 = v15;
    uint64_t v16 = *((void *)this + 2);
    unsigned int v17 = *(unsigned __int16 *)(v16 + 8);
    if (*(__int16 *)(v16 + 8) < 0)
    {
      unsigned int v18 = *(_DWORD *)(v16 + 12);
    }

    else
    {
      unsigned int v18 = v17 >> 5;
    }

    if (v18 > v15)
    {
      if ((v17 & 2) != 0) {
        uint64_t v19 = v16 + 10;
      }
      else {
        uint64_t v19 = *(void *)(v16 + 24);
      }
      int v14 = *(unsigned __int16 *)(v19 + 2LL * v15);
      goto LABEL_21;
    }
  }

void *icu::CollationRuleParser::parseStarredCharacters( icu::CollationRuleParser *this, uint64_t a2, int a3, UErrorCode *a4)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  __int128 v46 = 0u;
  uint64_t v49 = 0LL;
  __int128 v48 = 0u;
  __int128 v47 = 0u;
  uint64_t v44 = 0LL;
  unsigned int v45 = off_18971B688;
  LOWORD(v4--*((_DWORD *)this + 6) = 2;
  __int128 v41 = 0u;
  __int128 v43 = 0u;
  __int128 v42 = 0u;
  uint64_t v40 = off_18971B688;
  LOWORD(v4sub_18086E18C((uint64_t)this, 1) = 2;
  uint64_t v7 = icu::CollationRuleParser::skipWhiteSpace(this, a3);
  int v8 = icu::CollationRuleParser::parseString(this, v7, (icu::UnicodeString *)&v40, a4);
  int v9 = (void *)*(unsigned int *)a4;
  if ((int)v9 <= 0)
  {
    unsigned int v10 = (unsigned __int16)v41;
    if ((unsigned __int16)v41 < 0x20u)
    {
      *a4 = U_INVALID_FORMAT_ERROR;
      uint64_t v30 = "missing starred-relation string";
    }

    else
    {
      int v11 = v8;
      int v12 = 0;
      while (1)
      {
        int v13 = (__int16)v10;
        LODWORD(v14) = v10 >> 5;
        if (v13 >= 0) {
          unint64_t v14 = v14;
        }
        else {
          unint64_t v14 = DWORD1(v41);
        }
        if (v12 < (int)v14)
        {
          while (1)
          {
            int v15 = icu::UnicodeString::char32At((uint64_t *)v14, (icu::UnicodeString *)&v40, v12);
            uint64_t v16 = *((void *)this + 7);
            icu::UnicodeString::UnicodeString((uint64_t)&v35, v15);
            (*(void (**)(uint64_t, uint64_t, void (***)(icu::UnicodeString *__hidden), void (***)(icu::UnicodeString *__hidden), void (***)(icu::UnicodeString *__hidden), char *, UErrorCode *))(*(void *)v16 + 32LL))( v16,  a2,  &v45,  &v35,  &v45,  (char *)this + 48,  a4);
            icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)&v35);
            else {
              int v18 = 2;
            }
            v12 += v18;
            LODWORD(v14) = (unsigned __int16)v41 >> 5;
            if ((v41 & 0x8000u) == 0LL) {
              unint64_t v14 = v14;
            }
            else {
              unint64_t v14 = DWORD1(v41);
            }
          }

          int v9 = (void *)*(unsigned int *)a4;
          if ((int)v9 <= 0)
          {
            *a4 = U_INVALID_FORMAT_ERROR;
            uint64_t v30 = "starred-relation string is not all NFD-inert";
            goto LABEL_47;
          }

          goto LABEL_60;
        }

        LODWORD(v15) = -1;
LABEL_19:
        uint64_t v19 = *((void *)this + 2);
        unsigned int v20 = *(unsigned __int16 *)(v19 + 8);
        if (*(__int16 *)(v19 + 8) < 0)
        {
          int v21 = *(_DWORD *)(v19 + 12);
          if (v11 >= v21) {
            goto LABEL_61;
          }
        }

        else
        {
          int v21 = v20 >> 5;
        }

        if (v21 <= v11
          || ((v20 & 2) != 0 ? (uint64_t v22 = v19 + 10) : (uint64_t v22 = *(void *)(v19 + 24)), *(_WORD *)(v22 + 2LL * v11) != 45))
        {
LABEL_61:
          *((_DWORD *)this + 18) = icu::CollationRuleParser::skipWhiteSpace(this, v11);
          goto LABEL_60;
        }

        if ((v15 & 0x80000000) != 0)
        {
          int v9 = (void *)*(unsigned int *)a4;
          *a4 = U_INVALID_FORMAT_ERROR;
          uint64_t v30 = "range without start in starred-relation string";
          goto LABEL_47;
        }

        int v23 = icu::CollationRuleParser::parseString(this, (v11 + 1), (icu::UnicodeString *)&v40, a4);
        int v9 = (void *)*(unsigned int *)a4;
        if ((unsigned __int16)v41 <= 0x1Fu)
        {
          *a4 = U_INVALID_FORMAT_ERROR;
          uint64_t v30 = "range without end in starred-relation string";
          goto LABEL_47;
        }

        int v11 = v23;
        int v24 = icu::UnicodeString::char32At( (uint64_t *)(unsigned __int16)v41,  (icu::UnicodeString *)&v40,  0);
        unsigned int v25 = v24;
        uint64_t v39 = 0LL;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v36 = 0u;
        uint64_t v35 = off_18971B688;
        uint64_t v26 = 2LL;
        LOWORD(v3--*((_DWORD *)this + 6) = 2;
        while (v25 != (_DWORD)v15)
        {
          uint64_t v27 = ((_DWORD)v15 + 1);
          if (!(*(unsigned int (**)(void, uint64_t))(**(void **)this + 136LL))(*(void *)this, v27))
          {
            __int128 v31 = (void *)*(unsigned int *)a4;
            *a4 = U_INVALID_FORMAT_ERROR;
            __int128 v32 = "starred-relation string range is not all NFD-inert";
            goto LABEL_57;
          }

          if (v27 >> 11 == 27)
          {
            __int128 v31 = (void *)*(unsigned int *)a4;
            *a4 = U_INVALID_FORMAT_ERROR;
            __int128 v32 = "starred-relation string range contains a surrogate";
LABEL_57:
            *((void *)this + --*((_DWORD *)this + 6) = v32;
            __int128 v31 = (void *)*((void *)this + 5);
            if (v31) {
LABEL_58:
            }
              icu::CollationRuleParser::setErrorContext((char *)this);
            goto LABEL_59;
          }

          unsigned int v28 = v27 - 65533;
          if (v28 <= 2)
          {
            __int128 v31 = (void *)*(unsigned int *)a4;
            if ((int)v31 <= 0)
            {
              *a4 = U_INVALID_FORMAT_ERROR;
              __int128 v32 = "starred-relation string range contains U+FFFD, U+FFFE or U+FFFF";
              goto LABEL_57;
            }

uint64_t icu::CollationRuleParser::skipWhiteSpace(icu::CollationRuleParser *this, int a2)
{
  int64_t v3 = a2;
  do
  {
    int64_t v4 = v3;
    uint64_t v5 = *((void *)this + 2);
    int v6 = *(__int16 *)(v5 + 8);
    if (v6 < 0)
    {
      int64_t v7 = *(int *)(v5 + 12);
      if (v3 >= v7) {
        return v4;
      }
    }

    else
    {
      int64_t v7 = (unint64_t)*(unsigned __int16 *)(v5 + 8) >> 5;
    }

    if (v7 <= v3)
    {
      uint64_t v9 = 0xFFFFLL;
    }

    else
    {
      if ((v6 & 2) != 0) {
        uint64_t v8 = v5 + 10;
      }
      else {
        uint64_t v8 = *(void *)(v5 + 24);
      }
      uint64_t v9 = *(unsigned __int16 *)(v8 + 2 * v3);
    }

    ++v3;
  }

  while (icu::PatternProps::isWhiteSpace((icu::PatternProps *)v9));
  return v4;
}

uint64_t icu::CollationRuleParser::parseSpecialPosition( icu::CollationRuleParser *this, uint64_t a2, icu::UnicodeString *a3, UErrorCode *a4)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (*(int *)a4 <= 0)
  {
    __int128 v36 = 0u;
    uint64_t v39 = 0LL;
    __int128 v38 = 0u;
    __int128 v37 = 0u;
    uint64_t v35 = off_18971B688;
    LOWORD(v3--*((_DWORD *)this + 6) = 2;
    int Words = icu::CollationRuleParser::readWords(this, (int)a2 + 1, (icu::UnicodeString *)&v35);
    if (Words <= (int)a2
      || ((uint64_t v10 = *((void *)this + 2), v11 = *(unsigned __int16 *)(v10 + 8), *(__int16 *)(v10 + 8) < 0)
        ? (unsigned int v12 = *(_DWORD *)(v10 + 12))
        : (unsigned int v12 = v11 >> 5),
          v12 <= Words
       || ((v11 & 2) != 0 ? (uint64_t v13 = v10 + 10) : (uint64_t v13 = *(void *)(v10 + 24)),
           *(_WORD *)(v13 + 2LL * Words) != 93 || (unsigned __int16)v36 < 0x20u)))
    {
LABEL_47:
      unsigned int v28 = (void *)*(unsigned int *)a4;
      if ((int)v28 <= 0)
      {
        *a4 = U_INVALID_FORMAT_ERROR;
        *((void *)this + --*((_DWORD *)this + 6) = "not a valid special reset position";
        unsigned int v28 = (void *)*((void *)this + 5);
        if (v28) {
          icu::CollationRuleParser::setErrorContext((char *)this);
        }
      }

      uint64_t v4 = a2;
      goto LABEL_51;
    }

    uint64_t v14 = 0LL;
    uint64_t v4 = (Words + 1);
    do
    {
      icu::UnicodeString::UnicodeString(&v32, off_18971FE98[v14], 0xFFFFFFFFLL, 0LL);
      if ((v36 & 1) != 0)
      {
        char v19 = v33;
        icu::UnicodeString::~UnicodeString((void *)(unsigned __int16)v36, (icu::UnicodeString *)&v32);
        if ((v19 & 1) != 0)
        {
LABEL_39:
          uint64_t v24 = sub_1808B7A2C((uint64_t)a3, 65534);
          __int16 v25 = v14 + 10240;
          goto LABEL_46;
        }
      }

      else
      {
        if ((v36 & 0x8000u) == 0LL) {
          int v15 = (unsigned __int16)v36 >> 5;
        }
        else {
          int v15 = DWORD1(v36);
        }
        if ((v33 & 0x8000u) == 0) {
          unint64_t v16 = v33 >> 5;
        }
        else {
          unint64_t v16 = v34;
        }
        if ((v33 & 1) != 0 || v15 != (_DWORD)v16)
        {
          icu::UnicodeString::~UnicodeString((void *)v16, (icu::UnicodeString *)&v32);
        }

        else
        {
          BOOL v17 = icu::UnicodeString::doEquals((icu::UnicodeString *)&v35, (const icu::UnicodeString *)&v32, v15);
          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v32);
          if (v17) {
            goto LABEL_39;
          }
        }
      }

      ++v14;
    }

    while (v14 != 14);
    __int128 v31 = "t";
    icu::UnicodeString::UnicodeString(&v32, 1LL, &v31);
    if ((v36 & 1) != 0)
    {
      unint64_t v22 = v33;
      int v23 = v33 & 1;
    }

    else
    {
      if ((v36 & 0x8000u) == 0LL) {
        int v20 = (unsigned __int16)v36 >> 5;
      }
      else {
        int v20 = DWORD1(v36);
      }
      if ((v33 & 0x8000u) == 0) {
        unint64_t v21 = v33 >> 5;
      }
      else {
        unint64_t v21 = v34;
      }
      if ((v33 & 1) != 0 || v20 != (_DWORD)v21)
      {
        icu::UnicodeString::~UnicodeString((void *)v21, (icu::UnicodeString *)&v32);
        goto LABEL_44;
      }

      int v23 = icu::UnicodeString::doEquals((icu::UnicodeString *)&v35, (const icu::UnicodeString *)&v32, v20);
    }

    icu::UnicodeString::~UnicodeString((void *)v22, (icu::UnicodeString *)&v32);
    if (v23)
    {
      uint64_t v24 = sub_1808B7A2C((uint64_t)a3, 65534);
      __int16 v25 = 10249;
LABEL_46:
      __int16 v32 = v25;
      icu::UnicodeString::doAppend(v24, (uint64_t)&v32, 0, 1LL);
LABEL_51:
      icu::UnicodeString::~UnicodeString(v28, (icu::UnicodeString *)&v35);
      return v4;
    }

uint64_t icu::CollationRuleParser::parseTailoringString( icu::CollationRuleParser *this, int a2, icu::UnicodeString *a3, UErrorCode *a4)
{
  uint64_t v7 = icu::CollationRuleParser::skipWhiteSpace(this, a2);
  int v8 = icu::CollationRuleParser::parseString(this, v7, a3, a4);
  if (*(int *)a4 <= 0 && *((unsigned __int16 *)a3 + 4) <= 0x1Fu)
  {
    *a4 = U_INVALID_FORMAT_ERROR;
    *((void *)this + --*((_DWORD *)this + 6) = "missing relation string";
    if (*((void *)this + 5)) {
      icu::CollationRuleParser::setErrorContext((char *)this);
    }
  }

  return icu::CollationRuleParser::skipWhiteSpace(this, v8);
}

char *icu::CollationRuleParser::setErrorContext(char *this)
{
  uint64_t v1 = (_DWORD *)*((void *)this + 5);
  if (v1)
  {
    uint64_t v2 = this;
    unsigned int v3 = 0;
    int v4 = *((_DWORD *)this + 18);
    _DWORD *v1 = 0;
    v1[1] = v4;
    uint64_t v5 = *((void *)this + 2);
    if (v4 >= 16)
    {
      unsigned int v3 = v4 - 15;
      unsigned int v6 = *(unsigned __int16 *)(v5 + 8);
      unsigned int v7 = *(__int16 *)(v5 + 8) < 0 ? *(_DWORD *)(v5 + 12) : v6 >> 5;
      if (v7 > v3)
      {
        uint64_t v8 = (v6 & 2) != 0 ? v5 + 10 : *(void *)(v5 + 24);
        if (*(_WORD *)(v8 + 2LL * v3) >> 10 == 55) {
          unsigned int v3 = v4 - 14;
        }
      }
    }

    signed int v9 = v4 - v3;
    icu::UnicodeString::doExtract((char *)v5, v3, v4 - v3, (uint64_t)(v1 + 2), 0);
    uint64_t v10 = *((void *)v2 + 5);
    *(_WORD *)(v10 + 2LL * v9 + 8) = 0;
    uint64_t v11 = *((void *)v2 + 2);
    unsigned int v12 = *(unsigned __int16 *)(v11 + 8);
    int v13 = *((_DWORD *)v2 + 18);
    if (*(__int16 *)(v11 + 8) < 0)
    {
      unsigned int v14 = *(_DWORD *)(v11 + 12);
      int v15 = v14 - v13;
      if ((int)(v14 - v13) <= 15)
      {
LABEL_24:
        this = icu::UnicodeString::doExtract((char *)v11, v13, v15, v10 + 40, 0);
        *(_WORD *)(*((void *)v2 + 5) + 2LL * v15 + 40) = 0;
        return this;
      }
    }

    else
    {
      unsigned int v14 = v12 >> 5;
      int v15 = (v12 >> 5) - v13;
      if (v15 < 16) {
        goto LABEL_24;
      }
    }

    if (v14 <= v13 + 14)
    {
      int v15 = 15;
    }

    else
    {
      if ((v12 & 2) != 0) {
        uint64_t v16 = v11 + 10;
      }
      else {
        uint64_t v16 = *(void *)(v11 + 24);
      }
      if ((*(_WORD *)(v16 + 2LL * (v13 + 14)) & 0xFC00) == 0xD800) {
        int v15 = 14;
      }
      else {
        int v15 = 15;
      }
    }

    goto LABEL_24;
  }

  return this;
}

uint64_t icu::CollationRuleParser::parseString( icu::CollationRuleParser *this, uint64_t a2, icu::UnicodeString *a3, UErrorCode *a4)
{
  if ((*((_WORD *)a3 + 4) & 1) != 0) {
    __int16 v10 = 2;
  }
  else {
    __int16 v10 = *((_WORD *)a3 + 4) & 0x1F;
  }
  *((_WORD *)a3 + 4) = v10;
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_8:
        uint64_t v11 = *((void *)this + 2);
        unsigned int v12 = *(unsigned __int16 *)(v11 + 8);
        if (*(__int16 *)(v11 + 8) < 0)
        {
          int v13 = *(_DWORD *)(v11 + 12);
        }

        else
        {
          int v13 = v12 >> 5;
        }

        uint64_t v5 = (int)a2 + 1LL;
        if (v13 <= a2)
        {
          uint64_t v15 = 0xFFFFLL;
          goto LABEL_55;
        }

        uint64_t v14 = (v12 & 2) != 0 ? v11 + 10 : *(void *)(v11 + 24);
        uint64_t v15 = *(unsigned __int16 *)(v14 + 2LL * (int)a2);
LABEL_55:
        if (icu::PatternProps::isWhiteSpace((icu::PatternProps *)v15))
        {
LABEL_66:
          unsigned int v28 = *((unsigned __int16 *)a3 + 4);
          int v29 = (__int16)v28;
          LODWORD(v30) = v28 >> 5;
          if (v29 >= 0) {
            unint64_t v30 = v30;
          }
          else {
            unint64_t v30 = *((unsigned int *)a3 + 3);
          }
          int v31 = 0;
          while (1)
          {
            unsigned int v32 = icu::UnicodeString::char32At((uint64_t *)v30, a3, v31);
            if (v32 >> 11 == 27) {
              break;
            }
            if (v32 - 65533 <= 2)
            {
              if (*(int *)a4 <= 0)
              {
                *a4 = U_INVALID_FORMAT_ERROR;
                __int128 v36 = "string contains U+FFFD, U+FFFE or U+FFFF";
LABEL_88:
                *((void *)this + --*((_DWORD *)this + 6) = v36;
                uint64_t v20 = a2;
                uint64_t v5 = a2;
                if (*((void *)this + 5)) {
                  goto LABEL_89;
                }
                return v5;
              }

              return a2;
            }

            if (v32 < 0x10000) {
              int v33 = 1;
            }
            else {
              int v33 = 2;
            }
            v31 += v33;
            unsigned int v34 = *((unsigned __int16 *)a3 + 4);
            int v35 = (__int16)v34;
            LODWORD(v30) = v34 >> 5;
            if (v35 >= 0) {
              unint64_t v30 = v30;
            }
            else {
              unint64_t v30 = *((unsigned int *)a3 + 3);
            }
          }

          if (*(int *)a4 <= 0)
          {
            *a4 = U_INVALID_FORMAT_ERROR;
            __int128 v36 = "string contains an unpaired surrogate";
            goto LABEL_88;
          }

          return a2;
        }

        __int16 v39 = v15;
        icu::UnicodeString::doAppend((uint64_t)a3, (uint64_t)&v39, 0, 1LL);
        a2 = (int)a2 + 1LL;
      }

      uint64_t v17 = (v15 - 58);
      if (v17 != 34)
      {
        break;
      }

      if ((v12 & 0x8000) != 0) {
        int v18 = (uint64_t *)*(unsigned int *)(v11 + 12);
      }
      else {
        int v18 = (uint64_t *)(v12 >> 5);
      }
      if ((_DWORD)v5 == (_DWORD)v18)
      {
        if (*(int *)a4 <= 0)
        {
          *a4 = U_INVALID_FORMAT_ERROR;
          *((void *)this + --*((_DWORD *)this + 6) = "backslash escape at the end of the rule string";
          uint64_t v20 = (int)a2 + 1LL;
          if (*((void *)this + 5)) {
            goto LABEL_89;
          }
        }

        return v5;
      }

      unsigned int v26 = icu::UnicodeString::char32At(v18, (icu::UnicodeString *)v11, (int)a2 + 1);
      icu::UnicodeString::append((uint64_t)a3, v26);
      if (v26 < 0x10000) {
        int v27 = 1;
      }
      else {
        int v27 = 2;
      }
      a2 = (v27 + v5);
    }

BOOL icu::CollationRuleParser::isSyntaxChar(icu::CollationRuleParser *this)
{
  if (this < 0x30
    || ((_DWORD)this - 58) < 0x27 && ((0x7E0000007FuLL >> (this - 58)) & 1) != 0)
  {
    return 1LL;
  }

  return this > 0x7A;
}

uint64_t icu::CollationRuleParser::readWords(icu::CollationRuleParser *this, int a2, icu::UnicodeString *a3)
{
  if ((*((_WORD *)a3 + 4) & 1) != 0) {
    __int16 v5 = 2;
  }
  else {
    __int16 v5 = *((_WORD *)a3 + 4) & 0x1F;
  }
  *((_WORD *)a3 + 4) = v5;
  uint64_t v6 = icu::CollationRuleParser::skipWhiteSpace(this, a2);
  while (1)
  {
    uint64_t v7 = *((void *)this + 2);
    unsigned int v8 = *(unsigned __int16 *)(v7 + 8);
    if (*(__int16 *)(v7 + 8) < 0)
    {
      int v9 = *(_DWORD *)(v7 + 12);
    }

    else
    {
      int v9 = v8 >> 5;
    }

    if (v9 <= v6)
    {
      uint64_t v11 = 0xFFFFLL;
      goto LABEL_22;
    }

    uint64_t v10 = (v8 & 2) != 0 ? v7 + 10 : *(void *)(v7 + 24);
    uint64_t v11 = *(unsigned __int16 *)(v10 + 2LL * (int)v6);
LABEL_22:
    uint64_t v6 = (v6 + 1);
    if (icu::PatternProps::isWhiteSpace((icu::PatternProps *)v11))
    {
      __int16 v20 = 32;
      icu::UnicodeString::doAppend((uint64_t)a3, (uint64_t)&v20, 0, 1LL);
      uint64_t v6 = icu::CollationRuleParser::skipWhiteSpace(this, v6);
    }

    else
    {
      __int16 v21 = v11;
      icu::UnicodeString::doAppend((uint64_t)a3, (uint64_t)&v21, 0, 1LL);
    }
  }

  if (v11 < 0x30)
  {
LABEL_16:
    if ((_DWORD)v11 != 45) {
      goto LABEL_26;
    }
    goto LABEL_22;
  }

  uint64_t v12 = (v11 - 58);
  if (v12 == 37) {
    goto LABEL_22;
  }
  if (((1LL << (v11 - 58)) & 0x5E0000007FLL) == 0)
  {
LABEL_21:
    goto LABEL_16;
  }

uint64_t sub_1808B7A2C(uint64_t a1, __int16 a2)
{
  __int16 v5 = a2;
  icu::UnicodeString::unBogus(a1);
  else {
    uint64_t v3 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }
  return icu::UnicodeString::doReplace(a1, 0LL, v3, (uint64_t)&v5, 0, 1LL);
}

void icu::CollationRuleParser::parseReordering( icu::CollationRuleParser *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  unsigned int v5 = *((unsigned __int16 *)a2 + 4);
  int v6 = (__int16)v5;
  unsigned int v7 = v5 >> 5;
  if (v6 < 0) {
    unsigned int v7 = *((_DWORD *)a2 + 3);
  }
  if (v7 == 7)
  {
    icu::CollationSettings::resetReordering(*((void *)this + 4));
    return;
  }

  *(_OWORD *)uint64_t v22 = 0u;
  *(_OWORD *)int v23 = 0u;
  icu::UVector32::UVector32((icu::UVector32 *)v22, a3);
  memset(&v25[1], 0, 48);
  v25[0] = (icu::CollationRuleParser *)((char *)&v25[1] + 5);
  LODWORD(v25[1]) = 40;
  int v9 = 7;
  uint64_t v26 = 0LL;
  while (1)
  {
    unsigned int v10 = *((unsigned __int16 *)a2 + 4);
    int v11 = (__int16)v10;
    unsigned int v12 = v10 >> 5;
    if (v11 >= 0) {
      int v13 = v12;
    }
    else {
      int v13 = *((_DWORD *)a2 + 3);
    }
    if (v9 >= v13)
    {
      icu::CollationSettings::setReordering( *((icu::CollationSettings **)this + 4),  *((const icu::CollationData **)this + 3),  v23[1],  v22[2],  a3);
      goto LABEL_40;
    }

    int v14 = v9 + 1;
    if (v9 < -1)
    {
      int v15 = 0;
      int v16 = 0;
      if ((v11 & 0x80000000) == 0) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }

    if (v11 < 0)
    {
      if (*((_DWORD *)a2 + 3) >= v14) {
        int v15 = v9 + 1;
      }
      else {
        int v15 = *((_DWORD *)a2 + 3);
      }
LABEL_22:
      int v16 = v15;
      unsigned int v12 = *((_DWORD *)a2 + 3);
      goto LABEL_23;
    }

    int v16 = v12 >= v14 ? v9 + 1 : v12;
LABEL_23:
    int v9 = icu::UnicodeString::doIndexOf((uint64_t)a2, 0x20u, v16, v12 - v16);
    if (v9 < 0)
    {
      else {
        int v9 = *((unsigned __int16 *)a2 + 4) >> 5;
      }
    }

    LODWORD(v2--*((_DWORD *)this + 6) = 0;
    *(_BYTE *)v25[0] = 0;
    icu::UnicodeString::tempSubString(a2, v14, v9 - v14, (icu::UnicodeString *)v24);
    icu::CharString::appendInvariantChars((icu::CharString *)v25, (const icu::UnicodeString *)v24, a3);
    icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v24);
    int ReorderCode = icu::CollationRuleParser::getReorderCode(v25[0], v18);
    if (ReorderCode < 0) {
      break;
    }
    int v20 = ReorderCode;
    int v21 = v22[2];
    if (v22[2] >= -1 && v22[3] > v22[2]) {
      goto LABEL_33;
    }
    if (icu::UVector32::expandCapacity((icu::UVector32 *)v22, v22[2] + 1, a3))
    {
      int v21 = v22[2];
LABEL_33:
      v23[1][v21] = v20;
      ++v22[2];
    }
  }

  if (*(int *)a3 <= 0)
  {
    *a3 = U_INVALID_FORMAT_ERROR;
    *((void *)this + --*((_DWORD *)this + 6) = "unknown script or reorder code";
    if (*((void *)this + 5)) {
      icu::CollationRuleParser::setErrorContext((char *)this);
    }
  }

uint64_t icu::CollationRuleParser::getOnOffValue( icu::CollationRuleParser *this, const icu::UnicodeString *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int v18 = L"on";
  icu::UnicodeString::UnicodeString(v19, 1LL, &v18);
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  if ((v3 & 1) != 0)
  {
    unint64_t v8 = v20;
    char v9 = v20 & 1;
  }

  else
  {
    int v4 = (__int16)v3;
    int v5 = v3 >> 5;
    if (v4 >= 0) {
      int v6 = v5;
    }
    else {
      int v6 = *((_DWORD *)this + 3);
    }
    if ((v20 & 0x8000u) == 0) {
      unint64_t v7 = v20 >> 5;
    }
    else {
      unint64_t v7 = v21;
    }
    if ((v20 & 1) != 0 || v6 != (_DWORD)v7)
    {
      icu::UnicodeString::~UnicodeString((void *)v7, (icu::UnicodeString *)v19);
      goto LABEL_15;
    }

    char v9 = icu::UnicodeString::doEquals(this, (const icu::UnicodeString *)v19, v6);
  }

  icu::UnicodeString::~UnicodeString((void *)v8, (icu::UnicodeString *)v19);
  if ((v9 & 1) != 0) {
    return 17LL;
  }
LABEL_15:
  unsigned int v17 = "o";
  icu::UnicodeString::UnicodeString(v19, 1LL, &v17);
  unsigned int v11 = *((unsigned __int16 *)this + 4);
  if ((v11 & 1) != 0)
  {
    unint64_t v16 = v20;
    int v12 = v20 & 1;
  }

  else
  {
    int v12 = 0;
    int v13 = (__int16)v11;
    int v14 = v11 >> 5;
    if (v13 >= 0) {
      int v15 = v14;
    }
    else {
      int v15 = *((_DWORD *)this + 3);
    }
    if ((v20 & 0x8000u) == 0) {
      unint64_t v16 = v20 >> 5;
    }
    else {
      unint64_t v16 = v21;
    }
    if ((v20 & 1) == 0 && v15 == (_DWORD)v16) {
      int v12 = icu::UnicodeString::doEquals(this, (const icu::UnicodeString *)v19, v15);
    }
  }

  icu::UnicodeString::~UnicodeString((void *)v16, (icu::UnicodeString *)v19);
  if (v12) {
    return 16LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t icu::CollationRuleParser::parseUnicodeSet( icu::CollationRuleParser *this, int a2, icu::UnicodeSet *a3, UErrorCode *a4)
{
  int v7 = 0;
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *((void *)this + 2);
  unint64_t v9 = *(unsigned __int16 *)(v8 + 8);
  uint64_t v10 = a2;
  if ((v9 & 0x8000) != 0) {
    goto LABEL_4;
  }
LABEL_2:
  unint64_t v11 = v9 >> 5;
  if (v9 >> 5 == v10)
  {
LABEL_15:
    *a4 = U_INVALID_FORMAT_ERROR;
    int v14 = "unbalanced UnicodeSet pattern brackets";
    goto LABEL_17;
  }

  while (1)
  {
    uint64_t v12 = v8 + 10;
    if ((v9 & 2) == 0) {
      uint64_t v12 = *(void *)(v8 + 24);
    }
    int v13 = *(unsigned __int16 *)(v12 + 2 * v10);
    if (v13 == 93) {
      break;
    }
    if (v13 == 91) {
      ++v7;
    }
LABEL_11:
    ++v10;
    if ((v9 & 0x8000) == 0) {
      goto LABEL_2;
    }
LABEL_4:
    LODWORD(v1sub_18086E18C((uint64_t)this, 1) = *(_DWORD *)(v8 + 12);
    if ((_DWORD)v10 == (_DWORD)v11) {
      goto LABEL_15;
    }
  }

  if (--v7) {
    goto LABEL_11;
  }
  icu::UnicodeString::tempSubString((icu::UnicodeString *)v8, a2, v10 - a2 + 1, (icu::UnicodeString *)v22);
  icu::UnicodeSet::applyPattern(a3, (const icu::UnicodeString *)v22, a4);
  icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v22);
  if (*(int *)a4 < 1)
  {
    uint64_t v17 = icu::CollationRuleParser::skipWhiteSpace(this, (int)v10 + 1);
    uint64_t v10 = v17;
    uint64_t v18 = *((void *)this + 2);
    unsigned int v19 = *(unsigned __int16 *)(v18 + 8);
    if ((v19 & 0x8000) != 0)
    {
      unsigned int v20 = *(_DWORD *)(v18 + 12);
      if ((_DWORD)v17 != v20) {
        goto LABEL_28;
      }
    }

    else if ((_DWORD)v17 != v19 >> 5)
    {
      unsigned int v20 = v19 >> 5;
LABEL_28:
      if (v20 > v17)
      {
        uint64_t v21 = (v19 & 2) != 0 ? v18 + 10 : *(void *)(v18 + 24);
      }
    }

    *a4 = U_INVALID_FORMAT_ERROR;
    int v14 = "missing option-terminating ']' after UnicodeSet pattern";
LABEL_17:
    *((void *)this + --*((_DWORD *)this + 6) = v14;
    if (*((void *)this + 5)) {
      icu::CollationRuleParser::setErrorContext((char *)this);
    }
    return v10;
  }

  *a4 = U_INVALID_FORMAT_ERROR;
  *((void *)this + --*((_DWORD *)this + 6) = "not a valid UnicodeSet pattern";
  if (*((void *)this + 5)) {
    icu::CollationRuleParser::setErrorContext((char *)this);
  }
  return ++v10;
}

uint64_t icu::CollationRuleParser::getReorderCode(icu::CollationRuleParser *this, const char *a2)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
  }

  uint64_t result = u_getPropertyValueEnum(UCHAR_SCRIPT, (const char *)this);
  if ((result & 0x80000000) != 0)
  {
    else {
      return 103LL;
    }
  }

  return result;
}

uint64_t sub_1808B8164(uint64_t result, uint64_t *a2, _DWORD *a3)
{
  if ((int)*a3 <= 0)
  {
    uint64_t v4 = result;
    *(_DWORD *)(result + 9--*((_DWORD *)this + 6) = *a3;
    uint64_t v5 = a2[4];
    *(void *)uint64_t result = a2;
    *(void *)(result + 8) = v5;
    uint64_t result = utrie2_enum(*a2, 0LL, (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))sub_1808B81BC, result);
    *a3 = *(_DWORD *)(v4 + 96);
  }

  return result;
}

BOOL sub_1808B81BC(uint64_t a1, icu::Collation *a2, int a3, uint64_t a4)
{
  return (_DWORD)a4 == 192 || sub_1808B81D0(a1, a2, a3, a4);
}

BOOL sub_1808B81D0(uint64_t a1, icu::Collation *a2, int a3, uint64_t a4)
{
  unsigned int IndirectCE32 = a4;
  if ((~(_DWORD)a4 & 0xC0) != 0
    || (unsigned int IndirectCE32 = icu::CollationData::getIndirectCE32(*(icu::CollationData **)a1, a4), IndirectCE32 != 192))
  {
    unsigned int v8 = IndirectCE32 & 0xF;
    else {
      int v9 = a3;
    }
    int v10 = v9 + 1;
    do
    {
      unint64_t v11 = *(uint64_t **)(a1 + 8);
      uint64_t v12 = sub_1808A22C4(v11, a2);
      unsigned int FinalCE32 = icu::CollationData::getFinalCE32((icu::CollationData *)v11, v12);
      if ((IndirectCE32 & 0xC0) == 0xC0 && (v8 > 4 || ((1 << v8) & 0x16) == 0)
        || (~FinalCE32 & 0xC0) == 0
        && ((FinalCE32 & 0xF) <= 4 ? (BOOL v14 = ((1 << (FinalCE32 & 0xF)) & 0x16) == 0) : (BOOL v14 = 1), v14))
      {
        sub_1808B82F4(a1, a2, IndirectCE32, FinalCE32);
      }

      else if (IndirectCE32 != FinalCE32)
      {
        icu::UnicodeSet::add(*(icu::UnicodeSet **)(a1 + 16), a2);
      }

      a2 = (icu::Collation *)((_DWORD)a2 + 1);
    }

    while (v10 != (_DWORD)a2);
  }

  return *(_DWORD *)(a1 + 96) < 1;
}

void sub_1808B82F4(uint64_t a1, icu::Collation *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = a4;
  unsigned int FinalCE32 = a3;
  if ((a3 & 0xCF) == 0xC8)
  {
    unsigned int v8 = (unsigned __int16 *)(*(void *)(*(void *)a1 + 24LL) + 2LL * (a3 >> 13));
    unsigned int FinalCE32 = icu::CollationData::getFinalCE32(*(icu::CollationData **)a1, v8[1] | (*v8 << 16));
    if ((v4 & 0xCF) == 0xC8)
    {
      int v9 = *(icu::CollationData **)(a1 + 8);
      int v10 = (unsigned __int16 *)(*((void *)v9 + 3) + 2LL * (v4 >> 13));
      unsigned int v4 = icu::CollationData::getFinalCE32(v9, v10[1] | (*v10 << 16));
      sub_1808B86BC(a1, (uint64_t)a2, (uint64_t)(v8 + 2), (uint64_t)(v10 + 2));
      goto LABEL_8;
    }

    uint64_t v12 = *(icu::CollationData **)a1;
  }

  else
  {
    if ((a4 & 0xCF) != 0xC8) {
      goto LABEL_8;
    }
    unint64_t v11 = *(icu::CollationData **)(a1 + 8);
    unsigned int v8 = (unsigned __int16 *)(*((void *)v11 + 3) + 2LL * (a4 >> 13));
    unsigned int v4 = icu::CollationData::getFinalCE32(v11, v8[1] | (*v8 << 16));
    uint64_t v12 = *(icu::CollationData **)(a1 + 8);
  }

  sub_1808B893C(a1, v12, a2, (uint64_t)(v8 + 2));
LABEL_8:
  if ((FinalCE32 & 0xCF) != 0xC9)
  {
    if ((v4 & 0xCF) != 0xC9) {
      goto LABEL_20;
    }
    BOOL v14 = *(icu::CollationData **)(a1 + 8);
    int v13 = (unsigned __int16 *)(*((void *)v14 + 3) + 2LL * (v4 >> 13));
    unsigned int v4 = icu::CollationData::getFinalCE32(v14, v13[1] | (*v13 << 16));
    goto LABEL_17;
  }

  int v13 = (unsigned __int16 *)(*(void *)(*(void *)a1 + 24LL) + 2LL * (FinalCE32 >> 13));
  if ((FinalCE32 & 0x100) != 0) {
    unsigned int FinalCE32 = 1;
  }
  else {
    unsigned int FinalCE32 = icu::CollationData::getFinalCE32(*(icu::CollationData **)a1, v13[1] | (*v13 << 16));
  }
  if ((v4 & 0xCF) != 0xC9)
  {
LABEL_17:
    sub_1808B8C9C(a1, a2, (uint64_t)(v13 + 2));
    goto LABEL_20;
  }

  int v15 = *(icu::CollationData **)(a1 + 8);
  unint64_t v16 = (unsigned __int16 *)(*((void *)v15 + 3) + 2LL * (v4 >> 13));
  if ((v4 & 0x100) != 0) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = icu::CollationData::getFinalCE32(v15, v16[1] | (*v16 << 16));
  }
  sub_1808B8A2C(a1, (uint64_t)a2, (uint64_t)(v13 + 2), (uint64_t)(v16 + 2));
LABEL_20:
  if ((~FinalCE32 & 0xC0) != 0) {
    int v17 = -1;
  }
  else {
    int v17 = FinalCE32 & 0xF;
  }
  if ((~v4 & 0xC0) != 0)
  {
    int v18 = -1;
  }

  else
  {
    int v18 = v4 & 0xF;
    if (v18 == 14)
    {
      if ((FinalCE32 & 0xCF) != 0xC1
        || (FinalCE32 & 0xFFFFFF00) != icu::Collation::getThreeBytePrimaryForOffsetData( a2,  *(void *)(*(void *)(*(void *)(a1 + 8) + 16LL)
                                                                 + 8LL * (v4 >> 13))))
      {
        goto LABEL_52;
      }

      int v18 = 14;
    }
  }

  if (v17 != v18)
  {
LABEL_52:
    sub_1808B8D78(a1, a2);
    return;
  }

  if (v17 == 12)
  {
    int v25 = (_DWORD)a2 - 44032;
    if (!icu::UnicodeSet::contains( *(icu::UnicodeSet **)(a1 + 16),  (unsigned __int16)(((int)a2 - 44032) / 588 + 4352))
      && !icu::UnicodeSet::contains(*(icu::UnicodeSet **)(a1 + 16), v25 / 28 % 21 + 4449)
      && (!(v25 % 28) || !icu::UnicodeSet::contains(*(icu::UnicodeSet **)(a1 + 16), v25 % 28 + 4519)))
    {
      return;
    }

    goto LABEL_52;
  }

  if (v17 == 6)
  {
    uint64_t v26 = (FinalCE32 >> 8) & 0x1F;
    if ((_DWORD)v26 == ((v4 >> 8) & 0x1F))
    {
      if ((_DWORD)v26)
      {
        uint64_t v27 = (uint64_t *)(*(void *)(*(void *)a1 + 16LL) + 8LL * (FinalCE32 >> 13));
        unsigned int v28 = (uint64_t *)(*(void *)(*(void *)(a1 + 8) + 16LL) + 8LL * (v4 >> 13));
        while (1)
        {
          uint64_t v30 = *v27++;
          uint64_t v29 = v30;
          uint64_t v31 = *v28++;
          if (v29 != v31) {
            break;
          }
          if (!--v26) {
            return;
          }
        }

        goto LABEL_52;
      }

      return;
    }

    goto LABEL_52;
  }

  if (v17 != 5)
  {
    if (FinalCE32 == v4) {
      return;
    }
    goto LABEL_52;
  }

  uint64_t v19 = (FinalCE32 >> 8) & 0x1F;
  if ((_DWORD)v19 != ((v4 >> 8) & 0x1F)) {
    goto LABEL_52;
  }
  if ((_DWORD)v19)
  {
    unsigned int v20 = (int *)(*(void *)(*(void *)a1 + 8LL) + 4LL * (FinalCE32 >> 13));
    uint64_t v21 = (int *)(*(void *)(*(void *)(a1 + 8) + 8LL) + 4LL * (v4 >> 13));
    while (1)
    {
      int v23 = *v20++;
      int v22 = v23;
      int v24 = *v21++;
      if (v22 != v24) {
        break;
      }
      if (!--v19) {
        return;
      }
    }

    goto LABEL_52;
  }

void sub_1808B86BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v26 = 0LL;
  __int128 v25 = 0u;
  memset(v24, 0, sizeof(v24));
  uint64_t v19 = a3;
  int v7 = (UErrorCode *)(a1 + 96);
  icu::UCharsTrie::Iterator::Iterator(v24, &v19, 0LL, a1 + 96);
  uint64_t v23 = 0LL;
  __int128 v22 = 0u;
  memset(v21, 0, sizeof(v21));
  uint64_t v18 = a4;
  icu::UCharsTrie::Iterator::Iterator(v21, &v18, 0LL, v7);
  memset(v20, 0, sizeof(v20));
  icu::UnicodeString::UnicodeString((uint64_t)v20, 0xFFFF);
  int v9 = 0LL;
  int v10 = 0LL;
  while (1)
  {
    if (v9)
    {
      if (v10) {
        goto LABEL_11;
      }
    }

    else
    {
      else {
        int v9 = (char *)v20;
      }
      if (v10) {
        goto LABEL_11;
      }
    }

    int v10 = (char *)&v21[2] + 8;
    int v10 = (char *)v20;
LABEL_11:
LABEL_13:
    unsigned int v11 = *((unsigned __int16 *)v9 + 4);
    else {
      int32_t v12 = v11 >> 5;
    }
    unsigned int v13 = *((unsigned __int16 *)v10 + 4);
    if ((v13 & 1) != 0)
    {
      if ((v11 & 1) != 0) {
        goto LABEL_27;
      }
LABEL_25:
      sub_1808B8E74(a1, *(icu::CollationData **)(a1 + 8), (UChar **)v10, a2, HIDWORD(v22));
      int v10 = 0LL;
    }

    else
    {
      if ((v13 & 0x8000u) == 0) {
        int v14 = v13 >> 5;
      }
      else {
        int v14 = *((_DWORD *)v10 + 3);
      }
      if ((v13 & 2) != 0) {
        uint64_t v15 = (uint64_t)(v10 + 10);
      }
      else {
        uint64_t v15 = *((void *)v10 + 3);
      }
      int v16 = icu::UnicodeString::doCompare( (uint64_t)v9,  0,  v12,  v15,  v14 & (v14 >> 31),  v14 & ~(v14 >> 31));
      if (v16 < 0)
      {
        sub_1808B8E74(a1, *(icu::CollationData **)a1, (UChar **)v9, a2, HIDWORD(v25));
        int v9 = 0LL;
      }

      else
      {
        if (v16) {
          goto LABEL_25;
        }
LABEL_27:
        sub_1808B8F60(a1, (UChar **)v9);
        sub_1808B82F4(a1, a2, HIDWORD(v25), HIDWORD(v22));
        int v9 = 0LL;
        int v10 = 0LL;
        __int16 v17 = *(_WORD *)(a1 + 32);
        if ((v17 & 1) != 0) {
          uint64_t v8 = 2LL;
        }
        else {
          uint64_t v8 = v17 & 0x1F;
        }
        *(_WORD *)(a1 + 32) = v8;
      }
    }
  }

  icu::UnicodeString::~UnicodeString((void *)(v10 == (char *)v20), (icu::UnicodeString *)v20);
  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v21);
  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v24);
}

void sub_1808B893C(uint64_t a1, icu::CollationData *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  __int128 v12 = 0u;
  memset(v11, 0, sizeof(v11));
  uint64_t v10 = a4;
  int v7 = (UErrorCode *)(a1 + 96);
  icu::UCharsTrie::Iterator::Iterator(v11, &v10, 0LL, a1 + 96);
  uint64_t v9 = v10;
  if (icu::UCharsTrie::Iterator::next(&v9, (icu::UCharsTrie::Iterator *)v11, v7))
  {
    do
      sub_1808B8E74(a1, a2, (UChar **)&v11[2] + 1, a3, HIDWORD(v12));
    while (icu::UCharsTrie::Iterator::next(v8, (icu::UCharsTrie::Iterator *)v11, v7));
  }

  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v11);
}

void sub_1808B8A2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v26 = 0LL;
  __int128 v25 = 0u;
  memset(v24, 0, sizeof(v24));
  uint64_t v18 = a3;
  int v7 = (UErrorCode *)(a1 + 96);
  icu::UCharsTrie::Iterator::Iterator(v24, &v18, 0LL, a1 + 96);
  uint64_t v23 = 0LL;
  __int128 v22 = 0u;
  memset(v21, 0, sizeof(v21));
  uint64_t v17 = a4;
  icu::UCharsTrie::Iterator::Iterator(v21, &v17, 0LL, v7);
  memset(v20, 0, sizeof(v20));
  icu::UnicodeString::UnicodeString((uint64_t)v20, 0xFFFF);
  __int16 v19 = -1;
  icu::UnicodeString::doAppend((uint64_t)v20, (uint64_t)&v19, 0, 1LL);
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  while (1)
  {
    if (v9)
    {
      if (v10) {
        goto LABEL_11;
      }
    }

    else
    {
      else {
        uint64_t v9 = v20;
      }
      if (v10) {
        goto LABEL_11;
      }
    }

    uint64_t v10 = (char *)&v21[2] + 8;
    uint64_t v10 = (char *)v20;
LABEL_11:
LABEL_13:
    unsigned int v11 = *((unsigned __int16 *)v9 + 4);
    else {
      int32_t v12 = v11 >> 5;
    }
    unsigned int v13 = *((unsigned __int16 *)v10 + 4);
    if ((v13 & 1) != 0)
    {
      if ((v11 & 1) != 0) {
        goto LABEL_27;
      }
LABEL_25:
      sub_1808B8FA4(a1, a2, (uint64_t)v10);
      uint64_t v10 = 0LL;
    }

    else
    {
      if ((v13 & 0x8000u) == 0) {
        int v14 = v13 >> 5;
      }
      else {
        int v14 = *((_DWORD *)v10 + 3);
      }
      if ((v13 & 2) != 0) {
        uint64_t v15 = (uint64_t)(v10 + 10);
      }
      else {
        uint64_t v15 = *((void *)v10 + 3);
      }
      int v16 = icu::UnicodeString::doCompare( (uint64_t)v9,  0,  v12,  v15,  v14 & (v14 >> 31),  v14 & ~(v14 >> 31));
      if (v16 < 0)
      {
        sub_1808B8FA4(a1, a2, (uint64_t)v9);
        uint64_t v9 = 0LL;
      }

      else
      {
        if (v16) {
          goto LABEL_25;
        }
LABEL_27:
        *(void *)(a1 + 88) = v9;
        sub_1808B82F4(a1, a2, HIDWORD(v25), HIDWORD(v22));
        uint64_t v9 = 0LL;
        uint64_t v10 = 0LL;
        *(void *)(a1 + 88) = 0LL;
      }
    }
  }

  icu::UnicodeString::~UnicodeString((void *)(v10 == (char *)v20), (icu::UnicodeString *)v20);
  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v21);
  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v24);
}

void sub_1808B8C9C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v10 = 0LL;
  memset(v9, 0, sizeof(v9));
  uint64_t v8 = a3;
  uint64_t v5 = (UErrorCode *)(a1 + 96);
  icu::UCharsTrie::Iterator::Iterator(v9, &v8, 0LL, a1 + 96);
  uint64_t v7 = v8;
  if (icu::UCharsTrie::Iterator::next(&v7, (icu::UCharsTrie::Iterator *)v9, v5))
  {
    do
      sub_1808B8FA4(a1, a2, (uint64_t)&v9[2] + 8);
    while (icu::UCharsTrie::Iterator::next(v6, (icu::UCharsTrie::Iterator *)v9, v5));
  }

  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v9);
}

icu::UnicodeSet *sub_1808B8D78(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  memset(v11, 0, sizeof(v11));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v11, (UChar **)(a1 + 24));
  icu::UnicodeString::append((uint64_t)v11, a2);
  uint64_t v4 = *(void *)(a1 + 88);
  if (v4)
  {
    unsigned int v5 = *(unsigned __int16 *)(v4 + 8);
    int v6 = (__int16)v5;
    unsigned int v7 = v5 >> 5;
    if (v6 >= 0) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = *(unsigned int *)(v4 + 12);
    }
    icu::UnicodeString::doAppend((uint64_t)v11, (const icu::UnicodeString *)v4, 0, v8);
  }

  icu::UnicodeSet::add(*(icu::UnicodeSet **)(a1 + 16), (const icu::UnicodeString *)v11);
  return (icu::UnicodeSet *)icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)v11);
}

void *sub_1808B8E74(uint64_t a1, icu::CollationData *a2, UChar **a3, unsigned int a4, uint64_t a5)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  sub_1808B8F60(a1, a3);
  unsigned int FinalCE32 = icu::CollationData::getFinalCE32(a2, a5);
  if ((FinalCE32 & 0xCF) == 0xC9) {
    sub_1808B8C9C(a1, a4, *((void *)a2 + 3) + 2LL * (FinalCE32 >> 13) + 4);
  }
  uint64_t v10 = *(icu::UnicodeSet **)(a1 + 16);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v15, (UChar **)(a1 + 24));
  uint64_t v11 = (const icu::UnicodeString *)icu::UnicodeString::append((uint64_t)v15, a4);
  icu::UnicodeSet::add(v10, v11);
  uint64_t result = icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v15);
  if ((*(_WORD *)(a1 + 32) & 1) != 0) {
    __int16 v14 = 2;
  }
  else {
    __int16 v14 = *(_WORD *)(a1 + 32) & 0x1F;
  }
  *(_WORD *)(a1 + 32) = v14;
  return result;
}

icu::UnicodeString *sub_1808B8F60(uint64_t a1, UChar **a2)
{
  unsigned int v3 = (icu::UnicodeString *)(a1 + 24);
  icu::UnicodeString::operator=((UChar **)(a1 + 24), a2);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 32);
  if ((v4 & 0x8000) != 0) {
    int v5 = *(_DWORD *)(a1 + 36);
  }
  else {
    int v5 = v4 >> 5;
  }
  return icu::UnicodeString::doReverse(v3, 0, v5);
}

void *sub_1808B8FA4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  int v5 = *(icu::UnicodeSet **)(a1 + 16);
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v14, (UChar **)(a1 + 24));
  uint64_t v6 = icu::UnicodeString::append((uint64_t)v14, a2);
  unsigned int v7 = *(unsigned __int16 *)(a3 + 8);
  int v8 = (__int16)v7;
  unsigned int v9 = v7 >> 5;
  if (v8 >= 0) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = *(unsigned int *)(a3 + 12);
  }
  uint64_t v11 = (const icu::UnicodeString *)icu::UnicodeString::doAppend(v6, (const icu::UnicodeString *)a3, 0, v10);
  icu::UnicodeSet::add(v5, v11);
  return icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)v14);
}

uint64_t sub_1808B9054(uint64_t result, uint64_t *a2, int *a3)
{
  if (*a3 <= 0)
  {
    uint64_t v5 = result;
    *(_DWORD *)(result + 760) = *a3;
    if (a2[4]) {
      *(_BYTE *)(result + 33) = -1;
    }
    *(void *)uint64_t result = a2;
    uint64_t result = utrie2_enum(*a2, 0LL, (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))sub_1808B9108, result);
    int v6 = *(_DWORD *)(v5 + 760);
    if (a2[4])
    {
      if (v6 <= 0)
      {
        icu::UnicodeSet::freeze((icu::UnicodeSet *)(v5 + 40));
        *(_BYTE *)(v5 + 33) = 1;
        unsigned int v7 = (uint64_t *)a2[4];
        *(void *)uint64_t v5 = v7;
        uint64_t result = utrie2_enum(*v7, 0LL, (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))sub_1808B9108, v5);
        int v6 = *(_DWORD *)(v5 + 760);
      }
    }

    *a3 = v6;
  }

  return result;
}

BOOL sub_1808B9108(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(_BYTE *)(a1 + 33)) {
    goto LABEL_14;
  }
  if (*(char *)(a1 + 33) < 0)
  {
    if (a4 == 192) {
      return 1LL;
    }
    icu::UnicodeSet::add((icu::UnicodeSet *)(a1 + 40), a2, a3);
  }

  else
  {
    if ((_DWORD)a2 == (_DWORD)a3)
    {
      return 1LL;
    }

    if (!icu::UnicodeSet::containsNone((icu::UnicodeSet *)(a1 + 40), a2, a3))
    {
      unsigned int v9 = (icu::UVector **)icu::UnicodeSet::set((icu::UnicodeSet *)(a1 + 240), a2, a3);
      icu::UnicodeSet::removeAll(v9, (const icu::UnicodeSet *)(a1 + 40));
      int RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)(a1 + 240));
      if (RangeCount >= 1)
      {
        int v11 = RangeCount;
        for (int i = 0; i != v11; ++i)
        {
          uint64_t RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)(a1 + 240), i);
          uint64_t RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)(a1 + 240), i);
          sub_1808B92B8(a1, RangeStart, RangeEnd, a4);
        }
      }

      return *(_DWORD *)(a1 + 760) < 1;
    }
  }

uint64_t sub_1808B9234(uint64_t result, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  if ((int)*a4 <= 0)
  {
    int v6 = a2;
    uint64_t v7 = result;
    *(_DWORD *)(result + 760) = *a4;
    int v8 = sub_1808A22C4(a2, a3);
    if (v8 == 192)
    {
      int v6 = (uint64_t *)v6[4];
      int v8 = sub_1808A22C4(v6, a3);
    }

    *(void *)uint64_t v7 = v6;
    uint64_t result = sub_1808B92B8(v7, a3, a3, v8);
    *a4 = *(_DWORD *)(v7 + 760);
  }

  return result;
}

uint64_t sub_1808B92B8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if ((~a4 & 0xC0) == 0) {
    __asm { BR              X11 }
  }

  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    __asm { BR              X2 }
  }

  return result;
}

icu::UnicodeSet *sub_1808B96B4(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t result = *(icu::UnicodeSet **)(a1 + 16);
  if (result) {
    return icu::UnicodeSet::add(result, a2, a3);
  }
  return result;
}

void sub_1808B96E0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v7 = *(void *)(*(void *)a1 + 24LL) + 2LL * (a4 >> 13);
  ((void (*)(void))sub_1808B92B8)();
  if (*(_BYTE *)(a1 + 32))
  {
    uint64_t v14 = 0LL;
    __int128 v13 = 0u;
    memset(v12, 0, sizeof(v12));
    uint64_t v11 = v7 + 4;
    icu::UCharsTrie::Iterator::Iterator(v12, &v11, 0LL, a1 + 760);
    uint64_t v10 = v11;
    if (icu::UCharsTrie::Iterator::next(&v10, (icu::UCharsTrie::Iterator *)v12, (UErrorCode *)(a1 + 760)))
    {
      do
      {
        sub_1808B99A0(a1, (UChar **)&v12[2] + 1);
        sub_1808B99E4((UChar **)a1, a2, a3, *(icu::UnicodeSet **)(a1 + 8));
        sub_1808B99E4((UChar **)a1, a2, a3, *(icu::UnicodeSet **)(a1 + 16));
        sub_1808B92B8(a1, a2, a3, HIDWORD(v13));
      }

      while (icu::UCharsTrie::Iterator::next( v8,  (icu::UCharsTrie::Iterator *)v12,  (UErrorCode *)(a1 + 760)));
    }

    if ((*(_WORD *)(a1 + 448) & 1) != 0) {
      __int16 v9 = 2;
    }
    else {
      __int16 v9 = *(_WORD *)(a1 + 448) & 0x1F;
    }
    *(_WORD *)(a1 + 448) = v9;
    icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v12);
  }

void sub_1808B9844(void *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v7 = (unsigned __int16 *)(*(void *)(*a1 + 24LL) + 2LL * (a4 >> 13));
  if ((a4 & 0x100) == 0) {
    sub_1808B92B8(a1, a2, a3, v7[1] | (*v7 << 16));
  }
  uint64_t v13 = 0LL;
  __int128 v12 = 0u;
  memset(v11, 0, sizeof(v11));
  uint64_t v10 = (uint64_t)(v7 + 2);
  icu::UCharsTrie::Iterator::Iterator(v11, &v10, 0LL, a1 + 95);
  uint64_t v9 = v10;
  if (icu::UCharsTrie::Iterator::next(&v9, (icu::UCharsTrie::Iterator *)v11, (UErrorCode *)a1 + 190))
  {
    do
    {
      a1[63] = (char *)&v11[2] + 8;
      sub_1808B99E4((UChar **)a1, a2, a3, (icu::UnicodeSet *)a1[1]);
      sub_1808B92B8(a1, a2, a3, HIDWORD(v12));
    }

    while (icu::UCharsTrie::Iterator::next(v8, (icu::UCharsTrie::Iterator *)v11, (UErrorCode *)a1 + 190));
  }

  a1[63] = 0LL;
  icu::UCharsTrie::Iterator::~Iterator((icu::UCharsTrie::Iterator *)v11);
}

icu::UnicodeString *sub_1808B99A0(uint64_t a1, UChar **a2)
{
  unsigned int v3 = (icu::UnicodeString *)(a1 + 440);
  icu::UnicodeString::operator=((UChar **)(a1 + 440), a2);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 448);
  if ((v4 & 0x8000) != 0) {
    int v5 = *(_DWORD *)(a1 + 452);
  }
  else {
    int v5 = v4 >> 5;
  }
  return icu::UnicodeString::doReverse(v3, 0, v5);
}

UChar **sub_1808B99E4(UChar **result, signed int a2, signed int a3, icu::UnicodeSet *a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a4)
  {
    uint64_t v7 = result;
    memset(v18, 0, sizeof(v18));
    icu::UnicodeString::UnicodeString((icu::UnicodeString *)v18, result + 55);
    if (a3 <= a2) {
      signed int v8 = a2;
    }
    else {
      signed int v8 = a3;
    }
    int v9 = v8 + 1;
    do
    {
      icu::UnicodeString::append((uint64_t)v18, a2);
      uint64_t v10 = v7[63];
      if (v10)
      {
        unsigned int v11 = v10[4];
        int v12 = (__int16)v11;
        unsigned int v13 = v11 >> 5;
        if (v12 >= 0) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = *((unsigned int *)v10 + 3);
        }
        icu::UnicodeString::doAppend((uint64_t)v18, (const icu::UnicodeString *)v10, 0, v14);
      }

      icu::UnicodeSet::add(a4, (const icu::UnicodeString *)v18);
      unsigned int v15 = *((unsigned __int16 *)v7 + 224);
      if ((v15 & 0x8000) != 0) {
        uint64_t v16 = (void *)*((unsigned int *)v7 + 113);
      }
      else {
        uint64_t v16 = (void *)(v15 >> 5);
      }
      if ((_DWORD)v16 || (BYTE8(v18[0]) & 1) == 0)
      {
        if ((SWORD4(v18[0]) & 0x8000u) == 0) {
          unsigned int v17 = WORD4(v18[0]) >> 5;
        }
        else {
          unsigned int v17 = HIDWORD(v18[0]);
        }
        if (v17 > v16)
        {
          if ((int)v16 > 1023)
          {
            WORD4(v18[0]) = BYTE8(v18[0]) | 0xFFE0;
            HIDWORD(v18[0]) = (_DWORD)v16;
          }

          else
          {
            WORD4(v18[0]) = BYTE8(v18[0]) & 0x1F | (32 * (_WORD)v16);
          }
        }
      }

      else
      {
        icu::UnicodeString::unBogus((uint64_t)v18);
      }

      ++a2;
    }

    while (v9 != a2);
    return (UChar **)icu::UnicodeString::~UnicodeString(v16, (icu::UnicodeString *)v18);
  }

  return result;
}

icu::CollationSettings *icu::CollationSettings::CollationSettings( icu::CollationSettings *this, const icu::CollationSettings *a2)
{
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *(void *)this = off_189720000;
  *((void *)this + 3) = *((void *)a2 + 3);
  *((void *)this + 4) = 0LL;
  *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
  *((void *)this + --*((_DWORD *)this + 6) = 0LL;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0LL;
  *((void *)this + 9) = 0LL;
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  UErrorCode v5 = U_ZERO_ERROR;
  icu::CollationSettings::copyReorderingFrom(this, a2, &v5);
  if ((*((_DWORD *)this + 20) & 0x80000000) == 0) {
    memcpy((char *)this + 84, (char *)a2 + 84, 0x300uLL);
  }
  return this;
}

_DWORD *icu::CollationSettings::copyReorderingFrom( _DWORD *this, const icu::CollationSettings *a2, UErrorCode *a3)
{
  if (*(int *)a3 <= 0)
  {
    unsigned int v3 = (const unsigned __int8 *)*((void *)a2 + 4);
    if (v3)
    {
      this[10] = *((_DWORD *)a2 + 10);
      if (*((_DWORD *)a2 + 19))
      {
        return icu::CollationSettings::setReorderArrays( this,  *((const int **)a2 + 8),  *((_DWORD *)a2 + 18),  *((const unsigned int **)a2 + 6),  *((_DWORD *)a2 + 14),  v3,  a3);
      }

      else
      {
        *((void *)this + 4) = v3;
        *((void *)this + --*((_DWORD *)this + 6) = *((void *)a2 + 6);
        this[14] = *((_DWORD *)a2 + 14);
        *((void *)this + 8) = *((void *)a2 + 8);
        this[18] = *((_DWORD *)a2 + 18);
      }
    }

    else
    {
      *((void *)this + 4) = 0LL;
      this[10] = 0;
      this[14] = 0;
      this[18] = 0;
    }
  }

  return this;
}

void icu::CollationSettings::~CollationSettings(void **this)
{
  *this = off_189720000;
  if (*((_DWORD *)this + 19)) {
    uprv_free(this[8]);
  }
  icu::SharedObject::~SharedObject((icu::SharedObject *)this);
}

{
  void *v1;
  icu::CollationSettings::~CollationSettings(this);
  icu::UMemory::operator delete(v1);
}

BOOL icu::CollationSettings::operator==(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 != *(_DWORD *)(a2 + 24) || (v2 & 0xC) != 0 && *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28)) {
    return 0LL;
  }
  unint64_t v3 = *(unsigned int *)(a1 + 72);
  if ((_DWORD)v3 != *(_DWORD *)(a2 + 72)) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD **)(a1 + 64);
  UErrorCode v5 = *(_DWORD **)(a2 + 64);
  if (*v4 != *v5) {
    return 0LL;
  }
  uint64_t v6 = 1LL;
  do
  {
    unint64_t v7 = v6;
    if (v3 == v6) {
      break;
    }
    int v8 = v4[v6];
    int v9 = v5[v6++];
  }

  while (v8 == v9);
  return v7 >= v3;
}

uint64_t icu::CollationSettings::hashCode(icu::CollationSettings *this)
{
  int v2 = *((_DWORD *)this + 6);
  int v3 = v2 << 8;
  if ((v2 & 0xC) != 0) {
    v3 ^= *((_DWORD *)this + 7);
  }
  uint64_t v4 = *((unsigned int *)this + 18);
  uint64_t result = v4 ^ v3;
  if ((int)v4 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *((void *)this + 8);
    do
    {
      uint64_t result = (*(_DWORD *)(v7 + 4 * v6) << v6) ^ result;
      ++v6;
    }

    while (v4 != v6);
  }

  return result;
}

uint64_t icu::CollationSettings::resetReordering(uint64_t this)
{
  *(void *)(this + 32) = 0LL;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 5--*((_DWORD *)this + 6) = 0;
  *(_DWORD *)(this + 72) = 0;
  return this;
}

void icu::CollationSettings::aliasReordering( void **this, const icu::CollationData *a2, const int *a3, int a4, const unsigned int *a5, int a6, const unsigned __int8 *a7, UErrorCode *a8)
{
  if (!a7) {
    goto LABEL_13;
  }
  if (a6)
  {
    if (a6 < 2 || *(_WORD *)a5 || !LOWORD(a5[a6 - 1])) {
      goto LABEL_13;
    }
    goto LABEL_14;
  }

  if (!a7[1])
  {
LABEL_13:
    icu::CollationSettings::setReordering((icu::CollationSettings *)this, a2, a3, a4, a8);
    return;
  }

  unint64_t v14 = 0LL;
  while (v14 != 254)
  {
    if (!a7[v14++ + 2])
    {
      if (v14 >= 0xFF) {
        break;
      }
      goto LABEL_13;
    }
  }

BOOL icu::CollationSettings::reorderTableHasSplitBytes( icu::CollationSettings *this, const unsigned __int8 *a2)
{
  if (!*((_BYTE *)this + 1)) {
    return 1LL;
  }
  uint64_t v2 = 2LL;
  do
  {
    uint64_t v3 = v2;
    if (v2 == 256) {
      break;
    }
    ++v2;
  }

  while (*((_BYTE *)this + v3));
  return (unint64_t)(v3 - 1) < 0xFF;
}

void icu::CollationSettings::setReordering( icu::CollationSettings *this, const icu::CollationData *a2, const int *a3, int a4, UErrorCode *a5)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (*(int *)a5 <= 0)
  {
    if (!a4 || a4 == 1 && *a3 == 103)
    {
      *((void *)this + 4) = 0LL;
      *((_DWORD *)this + 10) = 0;
      *((_DWORD *)this + 14) = 0;
      *((_DWORD *)this + 18) = 0;
      return;
    }

    __int128 v23 = 0u;
    __int128 v24 = 0u;
    icu::UVector32::UVector32((icu::UVector32 *)&v23, a5);
    icu::CollationData::makeReorderRanges(a2, a3, a4, (icu::UVector32 *)&v23, a5);
    uint64_t v10 = DWORD2(v23);
    if (!DWORD2(v23))
    {
      *((void *)this + 4) = 0LL;
      *((_DWORD *)this + 10) = 0;
      *((_DWORD *)this + 14) = 0;
      *((_DWORD *)this + 18) = 0;
LABEL_28:
      icu::UVector32::~UVector32((void **)&v23);
      return;
    }

    uint64_t v11 = *((void *)&v24 + 1);
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    *(_OWORD *)__int128 v25 = 0u;
    __int128 v26 = 0u;
    *((_DWORD *)this + 10) = *(unsigned __int16 *)(*((void *)&v24 + 1) + 4LL * (DWORD2(v23) - 1) + 2) << 16;
    if ((int)v10 < 1)
    {
      LODWORD(v13) = 0;
      int v14 = -1;
    }

    else
    {
      uint64_t v12 = 0LL;
      LODWORD(v13) = 0;
      int v14 = -1;
      do
      {
        unint64_t v15 = *(unsigned int *)(v11 + 4 * v12);
        unint64_t v16 = v15 >> 24;
        if ((int)v13 < SHIBYTE(*(_DWORD *)(v11 + 4 * v12)))
        {
          unsigned int v17 = &v25[v13];
          int v18 = v13 + v15;
          unint64_t v19 = v16 - v13;
          do
          {
            *v17++ = v18++;
            --v19;
          }

          while (v19);
          unint64_t v13 = v15 >> 24;
        }

        if ((v15 & 0xFF0000) != 0)
        {
          v25[v16] = 0;
          LODWORD(v13) = v16 + 1;
          if (v14 < 0) {
            int v14 = v12;
          }
        }

        ++v12;
      }

      while (v12 != v10);
    }

    uint64_t v20 = v13;
    do
    {
      v25[v20] = v20;
      ++v20;
    }

    while ((_DWORD)v20 != 256);
LABEL_24:
    int v21 = v10 - v14;
    if (v14 >= 0) {
      int v22 = v21;
    }
    else {
      int v22 = 0;
    }
    icu::CollationSettings::setReorderArrays( this,  a3,  a4,  (const unsigned int *)(v11 + 4LL * (v14 & ~(v14 >> 31))),  v22,  v25,  a5);
    goto LABEL_28;
  }

_DWORD *icu::CollationSettings::setReorderArrays( _DWORD *this, const int *a2, int a3, const unsigned int *a4, int a5, const unsigned __int8 *a6, UErrorCode *a7)
{
  if (*(int *)a7 <= 0)
  {
    uint64_t v12 = (uint64_t)this;
    signed int v13 = this[19];
    if (a5 + a3 <= v13)
    {
      unint64_t v15 = (char *)*((void *)this + 8);
LABEL_8:
      unint64_t v16 = &v15[4 * v13];
      __int128 v17 = *(_OWORD *)a6;
      __int128 v18 = *((_OWORD *)a6 + 1);
      __int128 v19 = *((_OWORD *)a6 + 3);
      *((_OWORD *)v16 + 2) = *((_OWORD *)a6 + 2);
      *((_OWORD *)v16 + 3) = v19;
      *(_OWORD *)unint64_t v16 = v17;
      *((_OWORD *)v16 + sub_18086E18C((uint64_t)this, 1) = v18;
      __int128 v20 = *((_OWORD *)a6 + 4);
      __int128 v21 = *((_OWORD *)a6 + 5);
      __int128 v22 = *((_OWORD *)a6 + 7);
      *((_OWORD *)v16 + --*((_DWORD *)this + 6) = *((_OWORD *)a6 + 6);
      *((_OWORD *)v16 + 7) = v22;
      *((_OWORD *)v16 + 4) = v20;
      *((_OWORD *)v16 + 5) = v21;
      __int128 v23 = *((_OWORD *)a6 + 8);
      __int128 v24 = *((_OWORD *)a6 + 9);
      __int128 v25 = *((_OWORD *)a6 + 11);
      *((_OWORD *)v16 + 10) = *((_OWORD *)a6 + 10);
      *((_OWORD *)v16 + 1sub_18086E18C((uint64_t)this, 1) = v25;
      *((_OWORD *)v16 + 8) = v23;
      *((_OWORD *)v16 + 9) = v24;
      __int128 v26 = *((_OWORD *)a6 + 12);
      __int128 v27 = *((_OWORD *)a6 + 13);
      __int128 v28 = *((_OWORD *)a6 + 15);
      *((_OWORD *)v16 + 14) = *((_OWORD *)a6 + 14);
      *((_OWORD *)v16 + 15) = v28;
      *((_OWORD *)v16 + 12) = v26;
      *((_OWORD *)v16 + 13) = v27;
      memcpy(v15, a2, 4 * a3);
      this = memcpy(&v15[4 * a3], a4, 4 * a5);
      *(void *)(v12 + 32) = *(void *)(v12 + 64) + 4LL * *(int *)(v12 + 76);
      *(_DWORD *)(v12 + 72) = a3;
      *(void *)(v12 + 48) = &v15[4 * a3];
      *(_DWORD *)(v12 + 5--*((_DWORD *)this + 6) = a5;
      return this;
    }

    signed int v13 = (a5 + a3 + 3) & 0xFFFFFFFC;
    this = uprv_malloc(4 * v13 + 256);
    if (this)
    {
      unint64_t v15 = (char *)this;
      if (*(_DWORD *)(v12 + 76)) {
        uprv_free(*(void **)(v12 + 64));
      }
      *(void *)(v12 + 64) = v15;
      *(_DWORD *)(v12 + 7--*((_DWORD *)this + 6) = v13;
      goto LABEL_8;
    }

    *(void *)(v12 + 32) = 0LL;
    *(_DWORD *)(v12 + 40) = 0;
    *(_DWORD *)(v12 + 5--*((_DWORD *)this + 6) = 0;
    *(_DWORD *)(v12 + 72) = 0;
    *a7 = U_MEMORY_ALLOCATION_ERROR;
  }

  return this;
}

uint64_t icu::CollationSettings::reorderEx(icu::CollationSettings *this, uint64_t a2)
{
  if (*((_DWORD *)this + 10) > a2)
  {
    uint64_t v2 = (unsigned int *)*((void *)this + 6);
    do
    {
      unsigned int v4 = *v2++;
      unsigned int v3 = v4;
    }

    while ((a2 | 0xFFFF) >= v4);
    return a2 + (v3 << 24);
  }

  return a2;
}

uint64_t icu::CollationSettings::setStrength(uint64_t this, unsigned int a2, __int16 a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    unsigned int v4 = *(_DWORD *)(this + 24) & 0xFFFF0FFF;
    if (a2 < 4) {
      goto LABEL_5;
    }
    if (a2 == -1)
    {
      int v5 = v4 | a3 & 0xF000;
      goto LABEL_6;
    }

    if (a2 == 15)
    {
LABEL_5:
      int v5 = v4 | (a2 << 12);
LABEL_6:
      *(_DWORD *)(this + 24) = v5;
      return this;
    }

    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return this;
}

uint64_t icu::CollationSettings::setFlag(uint64_t result, int a2, int a3, int a4, int *a5)
{
  if (*a5 <= 0)
  {
    switch(a3)
    {
      case -1:
        int v5 = *(_DWORD *)(result + 24) & ~a2 | a4 & a2;
        goto LABEL_8;
      case 16:
        int v5 = *(_DWORD *)(result + 24) & ~a2;
        goto LABEL_8;
      case 17:
        int v5 = *(_DWORD *)(result + 24) | a2;
LABEL_8:
        *(_DWORD *)(result + 24) = v5;
        return result;
    }

    *a5 = 1;
  }

  return result;
}

uint64_t icu::CollationSettings::setCaseFirst(uint64_t result, int a2, __int16 a3, int *a4)
{
  if (*a4 <= 0)
  {
    int v4 = *(_DWORD *)(result + 24);
    unsigned int v5 = v4 & 0xFFFFFCFF;
    if (a2 > 23)
    {
      if (a2 == 24)
      {
        v5 |= 0x200u;
      }

      else
      {
        if (a2 != 25)
        {
LABEL_12:
          *a4 = 1;
          return result;
        }

        unsigned int v5 = v4 | 0x300;
      }
    }

    else if (a2 == -1)
    {
      v5 |= a3 & 0x300;
    }

    else if (a2 != 16)
    {
      goto LABEL_12;
    }

    *(_DWORD *)(result + 24) = v5;
  }

  return result;
}

uint64_t icu::CollationSettings::setAlternateHandling(uint64_t result, int a2, char a3, int *a4)
{
  if (*a4 <= 0)
  {
    unsigned int v4 = *(_DWORD *)(result + 24) & 0xFFFFFFF3;
    switch(a2)
    {
      case -1:
        v4 |= a3 & 0xC;
        break;
      case 20:
        v4 |= 4u;
        break;
      case 21:
        break;
      default:
        *a4 = 1;
        return result;
    }

    *(_DWORD *)(result + 24) = v4;
  }

  return result;
}

uint64_t icu::CollationSettings::setMaxVariable(uint64_t this, unsigned int a2, char a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    unsigned int v4 = *(_DWORD *)(this + 24) & 0xFFFFFF8F;
    if (a2 < 4)
    {
      int v5 = v4 | (16 * a2);
LABEL_6:
      *(_DWORD *)(this + 24) = v5;
      return this;
    }

    if (a2 == -1)
    {
      int v5 = v4 | a3 & 0x70;
      goto LABEL_6;
    }

    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }

  return this;
}

icu::CollationTailoring *icu::CollationTailoring::CollationTailoring( icu::CollationTailoring *this, const icu::CollationSettings *a2)
{
  *(void *)this = off_189720040;
  *((void *)this + sub_18086E18C((uint64_t)this, 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = a2;
  *((void *)this + 5) = off_18971B688;
  unsigned int v4 = (icu::CollationTailoring *)((char *)this + 40);
  *((_WORD *)this + 24) = 2;
  icu::Locale::Locale((icu::CollationTailoring *)((char *)this + 104), "", 0LL, 0LL, 0LL);
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 2sub_18086E18C((uint64_t)this, 1) = 0u;
  *((_OWORD *)this + 22) = 0u;
  if (a2)
  {
    uint64_t v7 = (uint64_t *)*((void *)this + 4);
    if (v7) {
LABEL_3:
    }
      icu::SharedObject::addRef((uint64_t)v7);
  }

  else
  {
    uint64_t v7 = icu::UMemory::operator new(v6, (icu::UMemory *)0x358, v5);
    if (v7)
    {
      v7[2] = 0LL;
      *uint64_t v7 = (uint64_t)off_189720000;
      v7[1] = 0LL;
      *((_DWORD *)v7 + --*((_DWORD *)this + 6) = 8208;
      v7[6] = 0LL;
      *((_DWORD *)v7 + 14) = 0;
      *(uint64_t *)((char *)v7 + 3--*((_DWORD *)this + 6) = 0LL;
      *(uint64_t *)((char *)v7 + 28) = 0LL;
      _OWORD v7[8] = 0LL;
      v7[9] = 0LL;
      *((_DWORD *)v7 + 20) = -1;
    }

    *((void *)this + 4) = v7;
    if (v7) {
      goto LABEL_3;
    }
  }

  icu::UnicodeString::getTerminatedBuffer(v4);
  *((_DWORD *)this + 82) = 0;
  atomic_store(0, (unsigned int *)this + 98);
  return this;
}

void icu::CollationTailoring::~CollationTailoring(icu::CollationTailoring *this)
{
  *(void *)this = off_189720040;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    icu::SharedObject::removeRef(v2);
    *((void *)this + 4) = 0LL;
  }

  unsigned int v3 = (void *)*((void *)this + 42);
  if (v3) {
    icu::UMemory::operator delete(v3);
  }
  uint64_t v4 = *((void *)this + 43);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  udata_close(*((_OWORD **)this + 44));
  ures_close(*((void *)this + 45));
  utrie2_close(*((void *)this + 46));
  uint64_t v6 = (icu::UnicodeSet *)*((void *)this + 47);
  if (v6)
  {
    uint64_t v7 = icu::UnicodeSet::~UnicodeSet(v5, v6);
    icu::UMemory::operator delete(v7);
  }

  uhash_close(*((_BYTE **)this + 48));
  atomic_store(0, (unsigned int *)this + 98);
  icu::Locale::~Locale((icu::CollationTailoring *)((char *)this + 104));
  icu::UnicodeString::~UnicodeString(v8, (icu::CollationTailoring *)((char *)this + 40));
  icu::SharedObject::~SharedObject(this);
}

{
  void *v1;
  icu::CollationTailoring::~CollationTailoring(this);
  icu::UMemory::operator delete(v1);
}

uint64_t icu::CollationTailoring::ensureOwnedData(icu::CollationTailoring *this, UErrorCode *a2)
{
  uint64_t result = *((void *)this + 42);
  if (result) {
    goto LABEL_4;
  }
  uint64_t NFCImpl = icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)a2, a2);
  uint64_t v7 = (uint64_t *)*(unsigned int *)a2;
  uint64_t v8 = NFCImpl;
  uint64_t result = (uint64_t)icu::UMemory::operator new(v7, (icu::UMemory *)0x90, v6);
  if (result)
  {
    *(_OWORD *)(result + 1--*((_DWORD *)this + 6) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(void *)(result + 48) = v8;
    *(_DWORD *)(result + 5--*((_DWORD *)this + 6) = 301989888;
    *(void *)(result + 128) = 0LL;
    *(_DWORD *)(result + 13--*((_DWORD *)this + 6) = 0;
    *(_OWORD *)(result + 60) = 0u;
    *(_OWORD *)(result + 7--*((_DWORD *)this + 6) = 0u;
    *(_OWORD *)(result + 92) = 0u;
    *(_OWORD *)(result + 108) = 0u;
    *((void *)this + 42) = result;
LABEL_4:
    *((void *)this + 3) = result;
    return 1LL;
  }

  *((void *)this + 42) = 0LL;
  *a2 = U_MEMORY_ALLOCATION_ERROR;
  return result;
}