id nw_protocol_boringssl_copy_definition()
{
  if (nw_protocol_boringssl_copy_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_boringssl_copy_definition_onceToken, &__block_literal_global_127);
  }
  return (id)nw_protocol_boringssl_copy_definition_definition;
}

void *nw_protocol_boringssl_allocate_options()
{
  return calloc(1uLL, 0x170uLL);
}

void nw_protocol_boringssl_deallocate_options(void *a1, void *a2)
{
  id v31 = a1;
  if (a2)
  {
    v3 = (void *)a2[1];
    if (v3)
    {
      free(v3);
      a2[1] = 0LL;
    }

    v4 = (void *)a2[2];
    if (v4)
    {
      free(v4);
      a2[2] = 0LL;
    }

    v5 = (void *)a2[5];
    a2[5] = 0LL;

    v6 = (void *)a2[29];
    a2[29] = 0LL;

    v7 = (void *)a2[6];
    a2[6] = 0LL;

    v8 = (void *)a2[7];
    a2[7] = 0LL;

    v9 = (void *)a2[11];
    a2[11] = 0LL;

    v10 = (void *)a2[12];
    a2[12] = 0LL;

    v11 = (void *)a2[13];
    a2[13] = 0LL;

    v12 = (void *)a2[14];
    a2[14] = 0LL;

    v13 = (void *)a2[15];
    a2[15] = 0LL;

    v14 = (void *)a2[16];
    a2[16] = 0LL;

    v15 = (void *)a2[22];
    a2[22] = 0LL;

    v16 = (void *)a2[23];
    a2[23] = 0LL;

    v17 = (void *)a2[9];
    a2[9] = 0LL;

    v18 = (void *)a2[24];
    a2[24] = 0LL;

    v19 = (void *)a2[17];
    a2[17] = 0LL;

    v20 = (void *)a2[18];
    a2[18] = 0LL;

    v21 = (void *)a2[19];
    a2[19] = 0LL;

    v22 = (void *)a2[20];
    a2[20] = 0LL;

    v23 = (void *)a2[21];
    a2[21] = 0LL;

    v24 = (void *)a2[41];
    a2[41] = 0LL;

    v25 = (void *)a2[33];
    a2[33] = 0LL;

    v26 = (void *)a2[32];
    a2[32] = 0LL;

    v27 = (void *)a2[10];
    a2[10] = 0LL;

    a2[43] = 0LL;
    v28 = (const void *)a2[35];
    if (v28) {
      CFRelease(v28);
    }
    a2[35] = 0LL;
    v29 = (const void *)a2[36];
    if (v29) {
      CFRelease(v29);
    }
    a2[36] = 0LL;
    v30 = (void *)a2[42];
    if (v30)
    {
      free(v30);
      a2[42] = 0LL;
    }

    a2[44] = 0LL;
    cc_clear();
    free(a2);
  }

  else
  {
    cc_clear();
  }
}

void *nw_protocol_boringssl_copy_options(uint64_t a1, uint64_t a2)
{
  v3 = calloc(1uLL, 0x170uLL);
  nw_protocol_boringssl_copy_options_contents((uint64_t)v3, a2);
  return v3;
}

void nw_protocol_boringssl_copy_options_contents(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    unint64_t v4 = *(_DWORD *)(a1 + 361) & 0xFFFFFFFE | ((unint64_t)*(unsigned __int8 *)(a1 + 365) << 32) | *(_DWORD *)(a2 + 361) & 1;
    *(_DWORD *)(a1 + 361) = *(_DWORD *)(a1 + 361) & 0xFFFFFFFE | *(_DWORD *)(a2 + 361) & 1;
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFF7LL | (8 * (((unint64_t)*(unsigned int *)(a2 + 361) >> 3) & 1));
    *(_DWORD *)(a1 + 361) = v5;
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFEFLL | (16 * (((unint64_t)*(unsigned int *)(a2 + 361) >> 4) & 1));
    *(_DWORD *)(a1 + 361) = v6;
    unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFDFLL | (32 * (((unint64_t)*(unsigned int *)(a2 + 361) >> 5) & 1));
    *(_DWORD *)(a1 + 361) = v7;
    unint64_t v8 = v7 & 0xFFFFFFFFFFFFFFBFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 6) & 1) << 6);
    *(_DWORD *)(a1 + 361) = v8;
    unint64_t v9 = v8 & 0xFFFFFFFFFFFFFDFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 9) & 1) << 9);
    *(_DWORD *)(a1 + 361) = v9;
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFBFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 10) & 1) << 10);
    *(_DWORD *)(a1 + 361) = v10;
    unint64_t v11 = v10 & 0xFFFFFFFFFFFFF7FFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 11) & 1) << 11);
    *(_DWORD *)(a1 + 361) = v11;
    unint64_t v12 = v11 & 0xFFFFFFFFFFFFEFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 12) & 1) << 12);
    *(_DWORD *)(a1 + 361) = v12;
    unint64_t v13 = v12 & 0xFFFFFFFFFFFFDFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 13) & 1) << 13);
    *(_DWORD *)(a1 + 361) = v13;
    unint64_t v14 = v13 & 0xFFFFFFFFFFFFBFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 14) & 1) << 14);
    *(_DWORD *)(a1 + 361) = v14;
    unint64_t v15 = v14 & 0xFFFFFFFFFFFF7FFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 15) & 1) << 15);
    *(_DWORD *)(a1 + 361) = v15;
    unint64_t v16 = v15 & 0xFFFFFFFFFFFEFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 16) & 1) << 16);
    *(_DWORD *)(a1 + 361) = v16;
    unint64_t v17 = v16 & 0xFFFFFFFFFFFDFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 17) & 1) << 17);
    *(_DWORD *)(a1 + 361) = v17;
    unint64_t v18 = v17 & 0xFFFFFFFFFFFBFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 18) & 1) << 18);
    *(_DWORD *)(a1 + 361) = v18;
    unint64_t v19 = v18 & 0xFFFFFFFFFDFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 25) & 1) << 25);
    *(_DWORD *)(a1 + 361) = v19;
    unint64_t v20 = v19 & 0xFFFFFFFFFFF7FFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 19) & 1) << 19);
    *(_DWORD *)(a1 + 361) = v20;
    unint64_t v21 = v20 & 0xFFFFFFFFFFEFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 20) & 1) << 20);
    *(_DWORD *)(a1 + 361) = v21;
    unint64_t v22 = v21 & 0xFFFFFFFFFFDFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 21) & 1) << 21);
    *(_DWORD *)(a1 + 361) = v22;
    unint64_t v23 = v22 & 0xFFFFFFFFFFBFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 22) & 1) << 22);
    *(_DWORD *)(a1 + 361) = v23;
    unint64_t v24 = v23 & 0xFFFFFFFFFF7FFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 23) & 1) << 23);
    *(_DWORD *)(a1 + 361) = v24;
    unint64_t v25 = v24 & 0xFFFFFFEFFFFFFFFFLL | ((((unint64_t)*(unsigned __int8 *)(a2 + 365) >> 4) & 1) << 36);
    *(_DWORD *)(a1 + 361) = v24;
    *(_BYTE *)(a1 + 365) = BYTE4(v25);
    unint64_t v26 = v25 & 0xFFFFFFDFFFFFFFFFLL | ((((unint64_t)*(unsigned __int8 *)(a2 + 365) >> 5) & 1) << 37);
    *(_DWORD *)(a1 + 361) = v24;
    unint64_t v27 = HIDWORD(v26);
    *(_BYTE *)(a1 + 365) = BYTE4(v26);
    unint64_t v28 = v26 & 0xFFFFFFFFFEFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 24) & 1) << 24);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v28;
    unint64_t v29 = v28 & 0xFFFFFFFFFBFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 26) & 1) << 26);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v29;
    unint64_t v30 = v29 & 0xFFFFFFFFF7FFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 27) & 1) << 27);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v30;
    unint64_t v31 = v30 & 0xFFFFFFFFEFFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 28) & 1) << 28);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v31;
    unint64_t v32 = v31 & 0xFFFFFFFFDFFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 29) & 1) << 29);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v32;
    unint64_t v33 = v32 & 0xFFFFFFFFBFFFFFFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 30) & 1) << 30);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v33;
    unint64_t v34 = v33 & 0xFFFFFFFFFFFFFF7FLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 7) & 1) << 7);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v34;
    unint64_t v35 = v34 & 0xFFFFFFFFFFFFFEFFLL | ((((unint64_t)*(unsigned int *)(a2 + 361) >> 8) & 1) << 8);
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v35;
    unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFFELL | *(_DWORD *)(a2 + 361) & 1;
    *(_BYTE *)(a1 + 365) = v27;
    *(_DWORD *)(a1 + 361) = v36;
    unint64_t v37 = v36 & 0xFDFFFFFFFFLL | ((((unint64_t)*(unsigned __int8 *)(a2 + 365) >> 1) & 1) << 33);
    *(_DWORD *)(a1 + 361) = v36;
    *(_BYTE *)(a1 + 365) = BYTE4(v37);
    *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
    *(_DWORD *)(a1 + 320) = *(_DWORD *)(a2 + 320);
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    v38 = *(const char **)(a2 + 8);
    if (v38) {
      *(void *)(a1 + 8) = strdup(v38);
    }
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    v39 = *(const char **)(a2 + 16);
    if (v39) {
      *(void *)(a1 + 16) = strdup(v39);
    }
    v40 = *(void **)(a2 + 56);
    if (v40) {
      objc_storeStrong((id *)(a1 + 56), v40);
    }
    v41 = *(void **)(a2 + 48);
    if (v41)
    {
      xpc_object_t v42 = xpc_copy(v41);
      v43 = *(void **)(a1 + 48);
      *(void *)(a1 + 48) = v42;
    }

    v44 = *(void **)(a2 + 40);
    if (v44)
    {
      xpc_object_t v45 = xpc_copy(v44);
      v46 = *(void **)(a1 + 40);
      *(void *)(a1 + 40) = v45;
    }

    v47 = *(void **)(a2 + 232);
    if (v47)
    {
      xpc_object_t v48 = xpc_copy(v47);
      v49 = *(void **)(a1 + 232);
      *(void *)(a1 + 232) = v48;
    }

    if (*(void *)(a2 + 88))
    {
      uint64_t v50 = MEMORY[0x1895A97C0]();
      v51 = *(void **)(a1 + 88);
      *(void *)(a1 + 88) = v50;

      objc_storeStrong((id *)(a1 + 96), *(id *)(a2 + 96));
    }

    if (*(void *)(a2 + 104))
    {
      uint64_t v52 = MEMORY[0x1895A97C0]();
      v53 = *(void **)(a1 + 104);
      *(void *)(a1 + 104) = v52;

      objc_storeStrong((id *)(a1 + 112), *(id *)(a2 + 112));
    }

    if (*(void *)(a2 + 120))
    {
      uint64_t v54 = MEMORY[0x1895A97C0]();
      v55 = *(void **)(a1 + 120);
      *(void *)(a1 + 120) = v54;

      objc_storeStrong((id *)(a1 + 128), *(id *)(a2 + 128));
    }

    v56 = *(void **)(a2 + 192);
    if (v56) {
      objc_storeStrong((id *)(a1 + 192), v56);
    }
    if (*(void *)(a2 + 176))
    {
      uint64_t v57 = MEMORY[0x1895A97C0]();
      v58 = *(void **)(a1 + 176);
      *(void *)(a1 + 176) = v57;

      objc_storeStrong((id *)(a1 + 184), *(id *)(a2 + 184));
    }

    v59 = *(void **)(a2 + 72);
    if (v59)
    {
      xpc_object_t v60 = xpc_copy(v59);
      v61 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = v60;
    }

    v62 = *(void **)(a2 + 136);
    if (v62) {
      objc_storeStrong((id *)(a1 + 136), v62);
    }
    v63 = *(void **)(a2 + 216);
    if (v63) {
      objc_storeStrong((id *)(a1 + 216), v63);
    }
    if (*(void *)(a2 + 200))
    {
      uint64_t v64 = MEMORY[0x1895A97C0]();
      v65 = *(void **)(a1 + 200);
      *(void *)(a1 + 200) = v64;
    }

    if (*(void *)(a2 + 208))
    {
      uint64_t v66 = MEMORY[0x1895A97C0]();
      v67 = *(void **)(a1 + 208);
      *(void *)(a1 + 208) = v66;
    }

    v68 = *(void **)(a2 + 64);
    if (v68) {
      objc_storeStrong((id *)(a1 + 64), v68);
    }
    if (*(void *)(a2 + 144))
    {
      uint64_t v69 = MEMORY[0x1895A97C0]();
      v70 = *(void **)(a1 + 144);
      *(void *)(a1 + 144) = v69;
    }

    v71 = *(void **)(a2 + 152);
    if (v71) {
      objc_storeStrong((id *)(a1 + 152), v71);
    }
    if (*(void *)(a2 + 160))
    {
      uint64_t v72 = MEMORY[0x1895A97C0]();
      v73 = *(void **)(a1 + 160);
      *(void *)(a1 + 160) = v72;
    }

    v74 = *(void **)(a2 + 168);
    if (v74) {
      objc_storeStrong((id *)(a1 + 168), v74);
    }
    if (*(void *)(a2 + 328))
    {
      uint64_t v75 = MEMORY[0x1895A97C0]();
      v76 = *(void **)(a1 + 328);
      *(void *)(a1 + 328) = v75;
    }

    v77 = *(void **)(a2 + 248);
    if (v77) {
      objc_storeStrong((id *)(a1 + 248), v77);
    }
    if (*(void *)(a2 + 240))
    {
      uint64_t v78 = MEMORY[0x1895A97C0]();
      v79 = *(void **)(a1 + 240);
      *(void *)(a1 + 240) = v78;
    }

    if (*(void *)(a2 + 256))
    {
      uint64_t v80 = MEMORY[0x1895A97C0]();
      v81 = *(void **)(a1 + 256);
      *(void *)(a1 + 256) = v80;
    }

    v82 = *(void **)(a2 + 264);
    if (v82) {
      objc_storeStrong((id *)(a1 + 264), v82);
    }
    v83 = *(void **)(a2 + 80);
    if (v83) {
      objc_storeStrong((id *)(a1 + 80), v83);
    }
    v84 = *(const __CFArray **)(a2 + 280);
    v85 = (CFAllocatorRef *)MEMORY[0x189604DB0];
    if (v84) {
      *(void *)(a1 + 280) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v84);
    }
    v86 = *(const __CFArray **)(a2 + 288);
    if (v86) {
      *(void *)(a1 + 288) = CFArrayCreateCopy(*v85, v86);
    }
    if (*(_BYTE *)(a2 + 296)) {
      *(_BYTE *)(a1 + 296) = *(_BYTE *)(a2 + 296);
    }
    if (*(_BYTE *)(a2 + 297)) {
      *(_BYTE *)(a1 + 297) = *(_BYTE *)(a2 + 297);
    }
    if (*(_BYTE *)(a2 + 360)) {
      *(_BYTE *)(a1 + 360) = *(_BYTE *)(a2 + 360);
    }
  }
}

  ;
}

  ;
}

nw_protocol *nw_protocol_boringssl_create()
{
  v0 = objc_alloc_init(&OBJC_CLASS___boringssl_concrete_nw_protocol_boringssl);
  v1 = v0;
  if (v0)
  {
    p_protocol = &v0->protocol;
    v0->protocol.identifier = (nw_protocol_identifier *)&g_boringssl_protocol_identifier;
    v0->protocol.callbacks = (nw_protocol_callbacks *)&g_boringssl_protocol_callbacks;
    v3 = v0;
    v3->protocol.handle = v3;
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    nw_frame_array_init();
    v3->input_frame_byte_count = 0;
    *((_BYTE *)v3 + 388) &= ~0x80u;
    v3->read_func = boringssl_session_read;
    v3->write_func = boringssl_session_write;
    v3->handshake_func = boringssl_session_handshake_negotiate;
    v3->handshake_timer = 0LL;
  }

  else
  {
    p_protocol = 0LL;
  }

  return p_protocol;
}

uint64_t nw_protocol_boringssl_add_input_handler(uint64_t a1, unsigned __int8 *src)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        if (g_boringssl_log)
        {
          uint64_t v15 = a1;
          BOOL v14 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
          a1 = v15;
          if (v14)
          {
            nw_protocol_boringssl_add_input_handler_cold_7();
            a1 = v15;
          }
        }
      }
    }

    if (!src || (uint64_t v4 = *((void *)src + 3)) == 0 || !*(void *)(v4 + 176))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_1();
      }

      return 0LL;
    }

    if (!*(void *)(v4 + 112))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_2();
      }

      return 0LL;
    }

    if (*(void *)(a1 + 48))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_6();
      }

      return 0LL;
    }

    *(void *)(a1 + 48) = src;
    uuid_copy((unsigned __int8 *)(v2 + 8), src);
    *((void *)src + 4) = v2 + 8;
    else {
      char v6 = 0;
    }
    *(_BYTE *)(v2 + 389) = *(_BYTE *)(v2 + 389) & 0xEF | v6;
    uint64_t v7 = (*(void (**)(unsigned __int8 *))(*((void *)src + 3) + 112LL))(src);
    unint64_t v8 = *(void **)(v2 + 312);
    *(void *)(v2 + 312) = v7;

    if (!*(void *)(v2 + 312))
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_3();
      }

      return 0LL;
    }

    unint64_t v9 = (void *)nw_parameters_copy_context();
    unint64_t v10 = boringssl_context_create_with_nw_context((void *)v2, v9);
    *(void *)(v2 + 336) = v10;
    if (v10)
    {
      uint64_t v11 = (uint64_t)v10;
      int attribution = nw_parameters_get_attribution(*(nw_parameters_t *)(v2 + 312));
      boringssl_context_set_attribution(v11, attribution);
      uint64_t v13 = boringssl_bio_create( v2,  (uint64_t)nw_protocol_boringssl_read_bytes,  (uint64_t)nw_protocol_boringssl_write_bytes);
      *(void *)(v2 + 344) = v13;
      if (v13)
      {
        uint64_t v2 = 1LL;
LABEL_39:

        return v2;
      }

      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_add_input_handler_cold_5();
      }
    }

    else if ((*(_BYTE *)(v2 + 475) & 1) == 0 {
           && g_boringssl_log
    }
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_add_input_handler_cold_4();
    }

    uint64_t v2 = 0LL;
    goto LABEL_39;
  }

  return v2;
}

void *boringssl_context_create_with_nw_context(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  unint64_t v5 = v4;
  char v6 = 0LL;
  if (v3 && v4)
  {
    uint64_t v7 = objc_alloc_init(&OBJC_CLASS___boringssl_concrete_boringssl_ctx);
    unint64_t v8 = v7;
    if (v7)
    {
      v7->ssl_state = 0;
      v7->peer_trust_result = 0;
      v7->max_allowed_tls_version = boringssl_config_get_max_tls_version_allowed();
      v8->max_allowed_dtls_version = boringssl_config_get_max_dtls_version_allowed();
      v8->min_allowed_tls_version = boringssl_config_get_min_tls_version_allowed();
      v8->min_allowed_dtls_version = boringssl_config_get_min_dtls_version_allowed();
      id v9 = nw_protocol_boringssl_copy_definition();
      uint64_t singleton = nw_protocol_metadata_create_singleton();
      metadata = v8->metadata;
      v8->metadata = (OS_nw_protocol_metadata *)singleton;

      boringssl_log_open();
      objc_storeWeak((id *)&v8->boringssl_handle, v3);
      objc_storeStrong((id *)&v8->async_context, a2);
      unint64_t v12 = v8;
      uint64_t v13 = malloc(0x10uLL);
      if (v13)
      {
        char v6 = v13;
        v12->legacy_context = (boringssl_legacy_ctx *)v13;
        *(_DWORD *)uint64_t v13 = -1252936367;
        v13[1] = v12;
LABEL_17:

        goto LABEL_18;
      }

      id WeakRetained = objc_loadWeakRetained((id *)&v8->boringssl_handle);
      if (!WeakRetained
        || (uint64_t v15 = WeakRetained,
            unint64_t v16 = objc_loadWeakRetained((id *)&v8->boringssl_handle),
            char v17 = v16[475],
            v16,
            v15,
            (v17 & 1) == 0))
      {
        id v18 = objc_loadWeakRetained((id *)&v8->boringssl_handle);
        if (v18)
        {
          unint64_t v19 = objc_loadWeakRetained((id *)&v8->boringssl_handle);
          BOOL v20 = (v19[475] & 1) == 0;
        }

        else
        {
          BOOL v20 = 1;
        }

        char v6 = 0LL;
        if (!v20 || !g_boringssl_log) {
          goto LABEL_17;
        }
        unint64_t v21 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          boringssl_context_create_with_nw_context_cold_1(&v8->boringssl_handle, v21);
        }
      }
    }

    char v6 = 0LL;
    goto LABEL_17;
  }

LABEL_18:
  return v6;
}

  xpc_object_t v45 = 0;
  v43 = 0;
  --v7;
  v38 = 1;
LABEL_28:
  if (v4 == 58 || (a4 & 1) != 0)
  {
    if (v4 == 58) {
      goto LABEL_32;
    }
  }

  else if (v4 <= 0x3Bu && ((1LL << v4) & 0x800100100000000LL) != 0)
  {
LABEL_32:
    ++v7;
    goto LABEL_33;
  }

  unint64_t v37 = v8;
  xpc_object_t v42 = a3;
  v40 = 0;
  v41 = a4;
  v46 = 0LL;
  v47 = 0LL;
  v49 = 0xAAAAAAAAAAAA0000LL;
  v48.i64[0] = -1LL;
  v48.i64[1] = -1LL;
  v12.i64[0] = -1LL;
  v12.i64[1] = -1LL;
  v39 = v12;
  uint64_t v13 = 1;
  BOOL v14 = v7;
  BYTE2(v49) = v43;
  while (2)
  {
    for (i = 0LL; ; ++i)
    {
      unint64_t v16 = v14[i];
      if (!OPENSSL_isalnum((char)v16))
      {
        char v17 = v16;
      }
    }

    if (!i)
    {
      unint64_t v34 = 1250;
LABEL_109:
      unint64_t v35 = 158;
      goto LABEL_110;
    }

    if ((v45 & 1) == 0)
    {
      if (v16 != 43 && (v13 & 1) != 0)
      {
        unint64_t v19 = 0LL;
        while (1)
        {
          BOOL v20 = bssl::kCiphers[v19];
          if (!strncmp(v20, v14, i) && !v20[i]) {
            break;
          }
          unint64_t v21 = bssl::kCiphers[v19 + 1];
          if (!strncmp(v21, v14, i) && !v21[i]) {
            break;
          }
          v19 += 5LL;
          if (v19 == 190) {
            goto LABEL_55;
          }
        }

        LODWORD(v46) = bssl::kCiphers[v19 + 2];
      }

  _Block_object_dispose(&v35, 8);
  return v11;
}

    uint64_t v13 = 0LL;
LABEL_19:
    unint64_t v10 = v48;

LABEL_20:
    id v18 = 0LL;
    if (!length || !v11) {
      goto LABEL_26;
    }
    if (length > **(unsigned int **)(a1 + 32)
      || v11 > **(unsigned int **)(a1 + 40)
      || (unint64_t)v13 > **(unsigned int **)(a1 + 48))
    {
      id v18 = 0LL;
LABEL_26:

      goto LABEL_27;
    }

    v49 = v11;
    unint64_t v21 = *(void *)(a1 + 56);
    if (!v21) {
      goto LABEL_36;
    }
    id WeakRetained = objc_loadWeakRetained((id *)(v21 + 16));
    if (WeakRetained)
    {
      unint64_t v23 = WeakRetained;
      unint64_t v24 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
      unint64_t v25 = v24[475];

      if ((v25 & 1) != 0)
      {
LABEL_60:
        **(void **)(a1 + 64) = SSL_get_cipher_by_value(4865);
        **(_DWORD **)(a1 + 32) = length;
        unint64_t v37 = *(void **)(a1 + 72);
        bytes_ptr = xpc_data_get_bytes_ptr(v8);
        memcpy(v37, bytes_ptr, length);
        **(_DWORD **)(a1 + 40) = v49;
        v39 = *(void **)(a1 + 80);
        v40 = xpc_data_get_bytes_ptr(v10);
        memcpy(v39, v40, v49);
        **(_DWORD **)(a1 + 48) = (_DWORD)v13;
        if (v13)
        {
          v41 = *(void **)(a1 + 88);
          string_ptr = xpc_string_get_string_ptr(v17);
          memcpy(v41, string_ptr, (size_t)v13);
        }

        id v18 = 1LL;
        goto LABEL_26;
      }
    }

    unint64_t v26 = *(void *)(a1 + 56);
    if (v26)
    {
      unint64_t v27 = objc_loadWeakRetained((id *)(v26 + 16));
      if (v27)
      {
        unint64_t v28 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
        unint64_t v29 = (v28[475] & 1) == 0;
      }

      else
      {
        unint64_t v29 = 1;
      }
    }

    else
    {
LABEL_36:
      unint64_t v29 = 1;
    }

    if (v29 && g_boringssl_log)
    {
      unint64_t v30 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        unint64_t v31 = *(void *)(a1 + 56);
        v47 = v31;
        if (v31)
        {
          unint64_t v32 = (char *)objc_loadWeakRetained((id *)(v31 + 16));
          unint64_t v33 = *(void *)(a1 + 56);
          v44 = v32;
          if (v32)
          {
            v46 = v33 != 0;
            if (v33)
            {
              unint64_t v32 = (char *)objc_loadWeakRetained((id *)(v33 + 16));
              unint64_t v33 = *(void *)(a1 + 56);
            }

            else
            {
              unint64_t v32 = 0LL;
            }

            unint64_t v35 = v32 + 391;
          }

          else
          {
            v46 = 0;
            unint64_t v35 = &unk_1875F4C23;
          }

          v43 = v32;
          if (v33)
          {
            unint64_t v34 = objc_loadWeakRetained((id *)(v33 + 16));
            xpc_object_t v45 = 0;
          }

          else
          {
            unint64_t v34 = 0LL;
            xpc_object_t v45 = 1;
          }
        }

        else
        {
          unint64_t v34 = 0LL;
          xpc_object_t v45 = 1;
          v46 = 0;
          unint64_t v35 = &unk_1875F4C23;
        }

        *(_DWORD *)buf = 136446978;
        uint64_t v52 = "boringssl_session_psk_client13_ext_callback_handler_block_invoke";
        v53 = 1024;
        uint64_t v54 = 1715;
        v55 = 2082;
        v56 = v35;
        uint64_t v57 = 2048;
        unint64_t v36 = v34;
        v58 = v34;
        _os_log_impl( &dword_187560000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Running TLS 1.3 external PSK client callback",  buf,  0x26u);
        if ((v45 & 1) == 0) {

        }
        if (v46) {
        if (v47)
        }
      }
    }

    goto LABEL_60;
  }

  id v18 = 0LL;
LABEL_28:

  return v18;
}

      OPENSSL_free(v20);
      goto LABEL_19;
    }

    id v18 = 2LL;
    bssl::ssl_send_alert(v12, (ssl_st *)2, 80);
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 794);
    id v18 = 2LL;
  }

          uint64_t v15 = 3LL;
          goto LABEL_35;
        }

        if (*(_BYTE *)(v18 + 241)) {
          goto LABEL_20;
        }
      }
    }

    else if ((*((_BYTE *)a1 + 1586) & 8) == 0)
    {
      unint64_t v22 = *(void *)(v18 + 136);
      if (v22)
      {
        unint64_t v23 = *(const void **)(v18 + 128);
        if (bssl::Array<unsigned char>::Init((uint64_t)&__dst, *(void *)(v18 + 136)))
        {
          memmove(__dst, v23, v22);
          uint64_t v15 = 0LL;
          goto LABEL_35;
        }

        goto LABEL_18;
      }

      if (*(_BYTE *)(v18 + 144))
      {
LABEL_20:
        uint64_t v15 = 2LL;
        goto LABEL_35;
      }
    }

    unint64_t v24 = v13[16];
    if (*(void *)(v24 + 784))
    {
      v40 = 0LL;
      v41 = 0LL;
      unint64_t v25 = bssl::Array<unsigned char>::Init((uint64_t)&v40, a5);
      unint64_t v26 = v40;
      if ((v25 & 1) != 0)
      {
        v39 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v15 = (*(uint64_t (**)(void))(*(void *)(*(void *)(*a1 + 128) + 784LL) + 16LL))();
        if ((_DWORD)v15)
        {
          unint64_t v26 = v40;
        }

        else
        {
          if (v41 < v39) {
            abort();
          }
          v41 = v39;
          OPENSSL_free(__dst);
          unint64_t v26 = 0LL;
          __dst = v40;
          v38 = v41;
          v40 = 0LL;
          v41 = 0LL;
        }
      }

      else
      {
        uint64_t v15 = 3LL;
      }

      OPENSSL_free(v26);
      if (v18)
      {
LABEL_35:
        if ((*((_BYTE *)a1 + 1586) & 8) == 0) {
          goto LABEL_36;
        }
        if ((_DWORD)v15)
        {
          if ((_DWORD)v15 != 2) {
            goto LABEL_60;
          }
          if (v17 < 0x304) {
            *(_BYTE *)(v18 + 241) = 1;
          }
          else {
            *(_BYTE *)(v18 + 144) = 1;
          }
          goto LABEL_52;
        }

        unint64_t v30 = __dst;
        unint64_t v31 = v38;
        if (v17 < 0x304)
        {
          unint64_t v34 = bssl::Array<unsigned char>::Init(v18 + 224, v38);
          unint64_t v35 = v34 ^ 1;
          if (!v31) {
            unint64_t v35 = 1;
          }
          if ((v35 & 1) == 0) {
            memmove(*(void **)(v18 + 224), v30, v31);
          }
          if (!v34) {
            goto LABEL_59;
          }
          *(_BYTE *)(v18 + 240) = *a3;
        }

        else
        {
          unint64_t v32 = bssl::Array<unsigned char>::Init(v18 + 128, v38);
          unint64_t v33 = v32 ^ 1;
          if (!v31) {
            unint64_t v33 = 1;
          }
          if ((v33 & 1) == 0) {
            memmove(*(void **)(v18 + 128), v30, v31);
          }
          if ((v32 & 1) == 0)
          {
LABEL_59:
            uint64_t v15 = 3LL;
            goto LABEL_60;
          }
        }

uint64_t boringssl_config_get_max_tls_version_allowed()
{
  return 772LL;
}

uint64_t boringssl_config_get_max_dtls_version_allowed()
{
  return 65277LL;
}

uint64_t boringssl_config_get_min_tls_version_allowed()
{
  return 769LL;
}

uint64_t boringssl_config_get_min_dtls_version_allowed()
{
  return 65279LL;
}

void *nw_protocol_boringssl_allocate_metadata()
{
  return calloc(1uLL, 0x168uLL);
}

void boringssl_log_open()
{
  if (boringssl_log_open_onceToken != -1) {
    dispatch_once(&boringssl_log_open_onceToken, &__block_literal_global_1);
  }
}

uint64_t boringssl_context_set_attribution(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v2 = *(void *)(result + 8)) != 0)
    {
      *(void *)(v2 + 272) = a2 == 2;
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_bio_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  if (a2 && a3)
  {
    uint64_t v7 = BIO_new(&methods_boringssl_bio);
    if (v7)
    {
      uint64_t v3 = (uint64_t)v7;
      unint64_t v8 = malloc(0x18uLL);
      if (v8)
      {
        void *v8 = a1;
        v8[1] = a2;
        v8[2] = a3;
        *(void *)(v3 + 40) = v8;
      }

      else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        boringssl_bio_create_cold_2();
      }
    }

    else
    {
      uint64_t v3 = g_boringssl_log;
      if (g_boringssl_log)
      {
        if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
          boringssl_bio_create_cold_1();
        }
        return 0LL;
      }
    }
  }

  return v3;
}

BIO *__cdecl BIO_new(BIO_METHOD *type)
{
  uint64_t v2 = (BIO *)OPENSSL_zalloc(0x48uLL);
  unint64_t v5 = v2;
  if (v2)
  {
    v2->method = type;
    HIDWORD(v2->cb_arg) = 1;
    v2->retry_reason = 1;
    CRYPTO_new_ex_data((_DWORD)v2 + 8, v3, v4);
    create = type->create;
    if (create)
    {
      if (!((unsigned int (*)(BIO *))create)(v5))
      {
        OPENSSL_free(v5);
        return 0LL;
      }
    }
  }

  return v5;
}

void *OPENSSL_malloc(unint64_t a1)
{
  if (a1 <= 0xFFFFFFFFFFFFFFF7LL && (uint64_t v2 = malloc(a1 + 8)) != 0LL)
  {
    *uint64_t v2 = a1;
    return v2 + 1;
  }

  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/mem.c", 288);
    return 0LL;
  }

uint64_t boringssl_bio_new(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  return 1LL;
}

uint64_t nw_protocol_boringssl_connect(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 40);
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_connect_cold_4();
      }

      if (*(void *)(v2 + 336) && (*(_BYTE *)(v2 + 390) & 1) == 0)
      {
        uint64_t v3 = (*(void (**)(void))(*(void *)(*(void *)(v1 + 48) + 24LL) + 112LL))();
        if (!v3)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0 && g_boringssl_log)
          {
            result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)result) {
              return result;
            }
            nw_protocol_boringssl_connect_cold_1();
          }

          return 0LL;
        }

        id v4 = (void *)v3;
        uint64_t v5 = *(void *)(v1 + 32);
        if (v5)
        {
          uint64_t v6 = *(void *)(v5 + 24);
          if (v6)
          {
            uint64_t v7 = *(void (**)(void))(v6 + 248);
            if (v7) {
              v7();
            }
          }
        }

        if (nw_parameters_get_server_mode())
        {
          uint64_t v8 = *(void *)(v1 + 48);
          if (v8)
          {
            uint64_t v9 = *(void *)(v8 + 24);
            if (v9)
            {
              unint64_t v10 = *(void (**)(void))(v9 + 128);
              if (v10)
              {
                v10();
                uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
                unint64_t v12 = (void *)nw_parameters_copy_context();
                uint64_t v13 = (void *)nw_context_copy_registered_endpoint();

                uint64_t v14 = nw_endpoint_copy_association();
                uint64_t v15 = *(void **)(v2 + 328);
                *(void *)(v2 + 328) = v14;
              }
            }
          }
        }

        uint64_t v16 = *(void *)(v2 + 336);
        int server_mode = nw_parameters_get_server_mode();
        if ((boringssl_context_ssl_context_create(v16, server_mode) & 1) == 0)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_connect_cold_2();
          }

          return 0LL;
        }

        id v18 = (void *)nw_parameters_copy_protocol_options_legacy();
        if (v18) {
          nw_protocol_options_get_log_id_str();
        }
        *(_BYTE *)(v2 + 390) |= 1u;
      }

      result = *(void *)(v1 + 32);
      if (!result) {
        return result;
      }
      uint64_t v19 = *(void *)(result + 24);
      if (v19)
      {
        BOOL v20 = *(uint64_t (**)(void))(v19 + 24);
        if (v20) {
          return v20();
        }
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t boringssl_context_ssl_context_create(uint64_t a1, int a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367 && (uint64_t v3 = *(void *)(a1 + 8)) != 0)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));

      if (WeakRetained)
      {
        uint64_t v6 = (id *)objc_loadWeakRetained((id *)(v3 + 16));
        id v7 = v6[41];
      }

      else
      {
        id v7 = 0LL;
      }

      uint64_t v8 = (SSL_METHOD *)TLS_with_buffers_method();
      uint64_t v9 = boringssl_context_restore_ssl_context((void *)v3, v7, v8);
      *(void *)(v3 + 408) = v9;
      if (a2) {
        char v10 = 16;
      }
      else {
        char v10 = 0;
      }
      *(_BYTE *)(v3 + 556) = *(_BYTE *)(v3 + 556) & 0xCF | v10;
      if (v9) {
        uint64_t v2 = boringssl_context_configure_defaults(v2);
      }
      else {
        uint64_t v2 = 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

void *TLS_with_buffers_method()
{
  return &TLS_with_buffers_method::kMethod;
}

uint64_t boringssl_context_restore_ssl_context(void *a1, void *a2, SSL_METHOD *a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  uint64_t v44 = 0LL;
  xpc_object_t v45 = &v44;
  uint64_t v46 = 0x2020000000LL;
  uint64_t v47 = 0LL;
  if (v8)
  {
    id v9 = nw_protocol_boringssl_copy_definition();
    cached_content_for_protocol = (void *)nw_association_get_cached_content_for_protocol();

    if (cached_content_for_protocol)
    {
      id WeakRetained = objc_loadWeakRetained(v7 + 2);
      uint64_t v3 = (uint64_t)&OBJC_IVAR___boringssl_concrete_nw_protocol_boringssl_logging_disabled;
      if (!WeakRetained
        || (unint64_t v12 = objc_loadWeakRetained(v7 + 2),
            unint64_t v4 = (v12[475] & 1) == 0,
            v12,
            WeakRetained,
            (_DWORD)v4))
      {
        id v13 = objc_loadWeakRetained(v7 + 2);
        if (v13)
        {
          uint64_t v14 = objc_loadWeakRetained(v7 + 2);
          uint64_t v3 = (v14[475] & 1) == 0;
        }

        else
        {
          uint64_t v3 = 1LL;
        }

        int v15 = g_boringssl_log ? v3 : 0;
        if (v15 == 1)
        {
          uint64_t v16 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            uint64_t v3 = (uint64_t)objc_loadWeakRetained(v7 + 2);
            if (v3)
            {
              unint64_t v4 = (unint64_t)objc_loadWeakRetained(v7 + 2);
              char v17 = (void *)(v4 + 391);
            }

            else
            {
              char v17 = &unk_1875F4C23;
            }

            id v18 = objc_loadWeakRetained(v7 + 2);
            *(_DWORD *)buf = 136446978;
            v49 = "boringssl_context_restore_ssl_context";
            __int16 v50 = 1024;
            int v51 = 2616;
            __int16 v52 = 2082;
            v53 = v17;
            __int16 v54 = 2048;
            id v55 = v18;
            _os_log_impl( &dword_187560000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Reusing context",  buf,  0x26u);

            if (v3) {
          }
            }
        }
      }

      id v19 = cached_content_for_protocol;
      v43 = v7;
      sec_array_apply();
    }
  }

  BOOL v20 = (unsigned int *)v45[3];
  if (v20)
  {
    SSL_CTX_up_ref(v20);
    unint64_t v21 = v45;
    if (!v8) {
      goto LABEL_49;
    }
    goto LABEL_42;
  }

  id v22 = objc_loadWeakRetained(v7 + 2);
  if (!v22
    || (unint64_t v23 = objc_loadWeakRetained(v7 + 2), v24 = (v23[475] & 1) == 0, v23, v22, v24))
  {
    id v25 = objc_loadWeakRetained(v7 + 2);
    if (v25)
    {
      unint64_t v26 = objc_loadWeakRetained(v7 + 2);
      BOOL v27 = (v26[475] & 1) == 0;
    }

    else
    {
      BOOL v27 = 1;
    }

    if (g_boringssl_log && v27)
    {
      unint64_t v29 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        id v30 = objc_loadWeakRetained(v7 + 2);
        if (v30)
        {
          uint64_t v3 = (uint64_t)objc_loadWeakRetained(v7 + 2);
          unint64_t v31 = (void *)(v3 + 391);
        }

        else
        {
          unint64_t v31 = &unk_1875F4C23;
        }

        id v32 = objc_loadWeakRetained(v7 + 2);
        *(_DWORD *)buf = 136446978;
        v49 = "boringssl_context_restore_ssl_context";
        __int16 v50 = 1024;
        int v51 = 2632;
        __int16 v52 = 2082;
        v53 = v31;
        __int16 v54 = 2048;
        id v55 = v32;
        _os_log_impl(&dword_187560000, v29, OS_LOG_TYPE_INFO, "%{public}s(%d) %{public}s[%p] New context", buf, 0x26u);

        if (v30) {
      }
        }
    }
  }

  unint64_t v33 = SSL_CTX_new(a3);
  unint64_t v21 = v45;
  v45[3] = (uint64_t)v33;
  if (v8)
  {
LABEL_42:
    unint64_t v34 = (unsigned int *)v21[3];
    id v35 = v8;
    if (v34)
    {
      unint64_t v36 = boringssl_context_state_create(v34);
      if (v36)
      {
        unint64_t v37 = (void *)sec_array_create();
        v38 = v37;
        if (v37)
        {
          id v39 = v37;
          sec_array_append();
          id v40 = nw_protocol_boringssl_copy_definition();
          time(0LL);
          nw_association_set_cached_content_for_protocol();
        }
      }
    }

    unint64_t v21 = v45;
  }

LABEL_49:
  uint64_t v41 = v21[3];
  _Block_object_dispose(&v44, 8);

  return v41;
}

        id v32 = (bssl *)*((void *)this + 194);
        unint64_t v33 = *((_DWORD *)v32 + 5);
        unint64_t v34 = *((_DWORD *)v32 + 6);
        if ((bssl::ssl_cipher_requires_server_key_exchange(v32, (const ssl_cipher_st *)v31) & 1) == 0
          && ((v34 & 8) == 0 || !*(void *)(*((void *)this + 1) + 56LL)))
        {
          goto LABEL_326;
        }

        *(void *)&id v35 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&v219.read_ahead + 2) = v35;
        *(_OWORD *)((char *)&v219.msg_callback_arg + 2) = v35;
        *(_OWORD *)((char *)&v219.s3 + 2) = v35;
        if (!CBB_init((uint64_t)&v219.param + 2, 0xC0uLL)
          || !CBB_add_bytes((uint64_t)&v219.param + 2, (const void *)(v28[6] + 48LL), 0x20uLL)
          || !CBB_add_bytes((uint64_t)&v219.param + 2, (const void *)(v28[6] + 16LL), 0x20uLL))
        {
          goto LABEL_259;
        }

        if ((v34 & 8) != 0)
        {
          unint64_t v36 = *(const char **)(*((void *)this + 1) + 56LL);
          unint64_t v37 = v36 ? strlen(v36) : 0LL;
          if (!CBB_add_u16_length_prefixed((uint64_t *)((char *)&v219.param + 2), (uint64_t)&v219.s3 + 2)
            || !CBB_add_bytes((uint64_t)&v219.s3 + 2, *(const void **)(*((void *)this + 1) + 56LL), v37))
          {
            goto LABEL_259;
          }
        }

        if ((v33 & 2) != 0)
        {
          v134 = *((void *)this + 190);
          if (*(_WORD *)(v134 + 6))
          {
            bssl::SSLKeyShare::Create( (void *)*(unsigned __int16 *)(v134 + 6),  (BUF_MEM **)((char *)&v219.init_buf + 2));
            v135 = *(BUF_MEM **)((char *)&v219.init_buf + 2);
            *(BUF_MEM **)((char *)&v219.init_buf + 2) = 0LL;
            std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v206, v135);
            std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]( (void **)((char *)&v219.init_buf + 2),  0LL);
            if (!*v206
              || !CBB_add_u8((uint64_t)&v219.param + 2, 3u)
              || !CBB_add_u16( (uint64_t)&v219.param + 2,  *(unsigned __int16 *)(*((void *)this + 190) + 6LL))
              || !CBB_add_u8_length_prefixed((uint64_t *)((char *)&v219.param + 2), (uint64_t)&v219.s3 + 2))
            {
              goto LABEL_259;
            }

            v136 = *((void *)this + 197);
            if (v136
              && (*((_BYTE *)this + 1586) & 8) == 0
              && *(unsigned __int16 *)(v136 + 184) == *(unsigned __int16 *)(*((void *)this + 190) + 6LL)
              && *(void *)(v136 + 200)
              && (v137 = *(void **)(v136 + 216)) != 0LL
              && (*(BUF_MEM **)((char *)&v219.init_buf + 2) = *(BUF_MEM **)(v136 + 208),
                  *(void **)((char *)&v219.init_msg + 2) = v137,
                  ((*(uint64_t (**)(void, char *))(**v206 + 56LL))(*v206, (char *)&v219.init_buf + 2) & 1) != 0))
            {
              if (!CBB_add_bytes( (uint64_t)&v219.s3 + 2,  *(const void **)(v136 + 192),  *(void *)(v136 + 200))) {
                goto LABEL_259;
              }
            }

            else
            {
              if (v136 && (*((_BYTE *)this + 1586) & 8) != 0)
              {
                *(void *)&v166 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v166 + 1) = 0xAAAAAAAAAAAAAAAALL;
                *(_OWORD *)((char *)&v219.init_num + 2) = v166;
                *(_OWORD *)((char *)&v219.packet_length + 2) = v166;
                *(_OWORD *)((char *)&v219.init_buf + 2) = v166;
                CBB_zero((BUF_MEM **)((char *)&v219.init_buf + 2));
                v167 = CBB_data((uint64_t)&v219.s3 + 2);
                v168 = CBB_len((uint64_t)&v219.s3 + 2);
                v169 = bssl::Array<unsigned char>::Init(v136 + 192, v168);
                v170 = v169 ^ 1;
                if (!v168) {
                  v170 = 1;
                }
                if ((v170 & 1) == 0) {
                  memmove(*(void **)(v136 + 192), v167, v168);
                }
                if (!v169
                  || !CBB_init((uint64_t)&v219.init_buf + 2, 0x20uLL)
                  || !(*(unsigned int (**)(void, char *))(**v206 + 48LL))( *v206,  (char *)&v219.init_buf + 2)
                  || !bssl::CBBFinishArray((uint64_t)&v219.init_buf + 2, v136 + 208))
                {
                  CBB_cleanup((uint64_t)&v219.init_buf + 2);
                  goto LABEL_259;
                }

                *(_WORD *)(v136 + 184) = *(_WORD *)(*((void *)this + 190) + 6LL);
                CBB_cleanup((uint64_t)&v219.init_buf + 2);
              }
            }

void sub_187562720( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

SSL_CTX *__cdecl SSL_CTX_new(SSL_METHOD *meth)
{
  id v9 = meth;
  if (!meth)
  {
    ERR_put_error(16, 0, 186, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 570);
    return 0LL;
  }

  bssl::New<ssl_ctx_st,ssl_method_st const*&>(&v9);
  uint64_t v2 = v1;
  uint64_t v8 = v1;
  if (v1)
  {
    uint64_t v3 = (bssl::CERT *)bssl::New<bssl::CERT,bssl::SSL_X509_METHOD const* const&>(&v9->ssl_clear);
    id v7 = 0LL;
    std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)(v2 + 432), v3);
    std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100](&v7, 0LL);
    *(void *)(v2 + 264) = OPENSSL_lh_new((uint64_t)ssl_session_hash, (uint64_t)ssl_session_cmp);
    unint64_t v4 = OPENSSL_sk_new_null();
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)(v2 + 400),  v4);
    uint64_t v5 = *(void *)(v2 + 432);
    if (!v5
      || !*(void *)(v5 + 24)
      || !*(void *)(v2 + 264)
      || !*(void *)(v2 + 400)
      || ((*(uint64_t (**)(uint64_t))(*(void *)(v2 + 16) + 120LL))(v2) & 1) == 0)
    {
      goto LABEL_12;
    }

    if (!SSL_CTX_set_strict_cipher_list(v2, (uint64_t)"ALL")
      || !SSL_CTX_set_max_proto_version(v2, LOWORD(v9->version))
      || !SSL_CTX_set_min_proto_version(v2, LOWORD(v9->version)))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 595);
LABEL_12:
      uint64_t v8 = 0LL;
      bssl::RefCounted<ssl_ctx_st>::DecRefInternal((ssl_ctx_st *)v2);
      return 0LL;
    }
  }

  return (SSL_CTX *)v2;
}

void sub_18756289C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void bssl::New<ssl_ctx_st,ssl_method_st const*&>(const ssl_method_st **a1)
{
  uint64_t v2 = (ssl_ctx_st *)OPENSSL_malloc(0x348uLL);
  if (v2) {
    ssl_ctx_st::ssl_ctx_st(v2, *a1);
  }
}

void ssl_ctx_st::ssl_ctx_st(ssl_ctx_st *this, const ssl_method_st *a2)
{
  int v2 = (int)this;
  LODWORD(this->method) = 1;
  *(_OWORD *)&this->cipher_list = *(_OWORD *)&a2->ssl_new;
  LODWORD(this->rsa_md5) = 0;
  BYTE4(this->rsa_md5) = 2;
  *(_OWORD *)&this->md5 = 0u;
  *(_OWORD *)&this->comp_methods = 0u;
  this->client_CA = (STACK *)20480;
  *(_OWORD *)&this->options = 0u;
  this->max_cert_list = 0x200000000LL;
  this->cert = (cert_st *)0x2A30000001C20LL;
  this->default_verify_callback = 0LL;
  *(_OWORD *)this->sid_ctx = 0u;
  *(_OWORD *)&this->sid_ctx[16] = 0u;
  *(_OWORD *)&this->read_ahead = 0u;
  *(_OWORD *)&this->msg_callback_arg = 0u;
  this->client_cert_engine = 0LL;
  LODWORD(this->tlsext_servername_callback) = 0;
  *(_OWORD *)&this->param = 0u;
  *(int (__cdecl **)(SSL *, int *, void *))((char *)&this->tlsext_servername_callback + 4) = (int (__cdecl *)(SSL *, int *, void *))0x1900000000008LL;
  *(void *)this->tlsext_tick_hmac_key = 0LL;
  *(_DWORD *)&this->tlsext_tick_hmac_key[8] = 0;
  *(_OWORD *)this->tlsext_tick_key_name = 0u;
  *(_OWORD *)this->tlsext_tick_aes_key = 0u;
  *(_OWORD *)&this->tlsext_ticket_key_cb = 0u;
  LOBYTE(this->tlsext_status_arg) = 0;
  WORD1(this->tlsext_status_arg) = 0x4000;
  *(_OWORD *)&this[1].read_ahead = 0u;
  *(_OWORD *)&this[1].method = 0u;
  *(_OWORD *)&this[1].cipher_list_by_id = 0u;
  *(_OWORD *)&this[1].sessions = 0u;
  *(_OWORD *)&this[1].session_cache_head = 0u;
  *(_OWORD *)&this[1].session_cache_mode = 0u;
  *(_OWORD *)&this[1].new_session_cb = 0u;
  *(_OWORD *)&this[1].get_session_cb = 0u;
  *(_OWORD *)&this[1].stats.sess_connect_good = 0u;
  *(_OWORD *)&this[1].stats.sess_miss = 0u;
  *(_OWORD *)&this[1].stats.sess_cb_hit = 0u;
  *(_OWORD *)&this[1].app_verify_arg = 0u;
  *(_OWORD *)((char *)&this[1].default_passwd_callback + 2) = 0u;
  LODWORD(this[1].cert) = 0;
  *(_OWORD *)&this[1].client_CA = 0u;
  *(_OWORD *)&this[1].mode = 0u;
  *(_OWORD *)&this[1].sha1 = 0u;
  *(_OWORD *)&this[1].comp_methods = 0u;
  this[1].ex_data = 0u;
  *(_OWORD *)&this[1].rsa_md5 = 0u;
  LOWORD(this[1].msg_callback_arg) &= 0xE000u;
  *(_OWORD *)&this[1].app_gen_cookie_cb = 0u;
  CRYPTO_MUTEX_init((pthread_rwlock_t *)&this->cert_store);
  CRYPTO_new_ex_data(v2 + 384, v3, v4);
}

void sub_187562A2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _Unwind_Exception *exception_object)
{
}

uint64_t CRYPTO_MUTEX_init(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_init(a1, 0LL);
  if ((_DWORD)result) {
    abort();
  }
  return result;
}

int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  **(void **)&class_index = 0LL;
  return class_index;
}

void *bssl::New<bssl::CERT,bssl::SSL_X509_METHOD const* const&>(void *a1)
{
  uint64_t result = OPENSSL_malloc(0x80uLL);
  if (result) {
    return (void *)bssl::CERT::CERT(result, *a1);
  }
  return result;
}

void *OPENSSL_lh_new(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = OPENSSL_zalloc(0x30uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    v4[2] = 16LL;
    uint64_t v6 = OPENSSL_calloc(0x10uLL, 8uLL);
    v5[1] = v6;
    if (v6)
    {
      v5[4] = a2;
      v5[5] = a1;
    }

    else
    {
      OPENSSL_free(v5);
      return 0LL;
    }
  }

  return v5;
}

uint64_t bssl::ssl_noop_x509_ssl_ctx_new(bssl *this, ssl_ctx_st *a2)
{
  return 1LL;
}

void OPENSSL_free(void *a1)
{
  if (a1)
  {
    int v2 = (char *)(a1 - 1);
    uint64_t v1 = *(a1 - 1);
    if (v1 != -8) {
      bzero(a1 - 1, v1 + 8);
    }
    free(v2);
  }

uint64_t ssl_credential_st::UsesPrivateKey(ssl_credential_st *this)
{
  return 1LL;
}

uint64_t bssl::ssl_cipher_process_rulestr(unsigned __int8 *a1, uint64_t **a2, void *a3, int a4)
{
  unsigned __int8 v4 = *a1;
  if (!*a1) {
    return 1LL;
  }
  id v7 = (const char *)a1;
  int v8 = 0;
  char v9 = 0;
LABEL_3:
  ++v7;
  while (1)
  {
    if ((v9 & 1) == 0)
    {
      if (v4 <= 0x2Cu)
      {
        if (v4 == 33)
        {
          char v45 = 0;
          int v11 = 2;
        }

        else
        {
          if (v4 != 43) {
            goto LABEL_18;
          }
          char v45 = 0;
          int v11 = 4;
        }

        goto LABEL_25;
      }

      if (v4 == 45)
      {
        char v45 = 0;
        int v11 = 3;
LABEL_25:
        int v38 = v11;
        goto LABEL_26;
      }

      if (v4 == 64)
      {
        int v38 = 5;
        char v45 = 1;
LABEL_26:
        if ((v8 & 1) == 0)
        {
          int v43 = 1;
          goto LABEL_28;
        }

        int v35 = 168;
        int v34 = 1221;
LABEL_110:
        ERR_put_error(16, 0, v35, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cipher.cc", v34);
        return 0LL;
      }

      if (v4 != 91) {
        goto LABEL_18;
      }
      int v8 = 1;
LABEL_11:
      char v9 = 1;
LABEL_33:
      unsigned __int8 v4 = *v7;
      if (!*v7)
      {
        if ((v9 & 1) != 0)
        {
          int v35 = 158;
          int v34 = 1335;
          goto LABEL_110;
        }

        return 1LL;
      }

      goto LABEL_3;
    }

    if (v4 != 93) {
      break;
    }
    if (*a3) {
      *(_BYTE *)(*a3 + 9LL) = 0;
    }
    char v9 = 0;
    int v10 = *(unsigned __int8 *)v7++;
    unsigned __int8 v4 = v10;
    if (!v10) {
      return 1LL;
    }
  }

  if (v4 == 124) {
    goto LABEL_11;
  }
  if (!OPENSSL_isalnum((char)v4))
  {
    int v35 = 224;
    int v34 = 1191;
    goto LABEL_110;
  }

LABEL_55:
      if ((_DWORD)v46)
      {
LABEL_62:
        int v24 = HIDWORD(v46);
      }

      else
      {
        uint64_t v22 = 0LL;
        while (1)
        {
          unint64_t v23 = (&bssl::kCipherAliases)[v22];
          if (!strncmp(v23, v14, i) && !v23[i]) {
            break;
          }
          v22 += 4LL;
          if (v22 == 116)
          {
            if ((v41 & 1) == 0)
            {
LABEL_61:
              char v40 = 1;
              goto LABEL_62;
            }

            int v34 = 1299;
            goto LABEL_109;
          }
        }

        int8x16_t v39 = vandq_s8(v39, *(int8x16_t *)&(&bssl::kCipherAliases)[v22 + 1]);
        int8x16_t v48 = v39;
        v43 |= *((unsigned __int8 *)&bssl::kCipherAliases + 8 * v22 + 26);
        BYTE2(v49) = v43;
        int v24 = LOWORD((&bssl::kCipherAliases)[v22 + 3]);
        if (HIDWORD(v46))
        {
          if (HIDWORD(v46) != v24) {
            goto LABEL_61;
          }
          int v24 = HIDWORD(v46);
        }

        LOWORD(v49) = v24;
      }

      if (v17 != 43)
      {
        id v7 = &v14[i];
        int v8 = v37;
        if ((v40 & 1) == 0)
        {
          a3 = v42;
          bssl::ssl_cipher_apply_rule(v46, (uint64_t)&v47, v38, -1, v9 & 1, a2, v42);
          a4 = v41;
          goto LABEL_33;
        }

        goto LABEL_103;
      }

      HIDWORD(v46) = v24;
      char v13 = 0;
      v14 += i + 1;
      continue;
    }

    break;
  }

  if (i != 8 || strncmp(v7, "STRENGTH", 8uLL))
  {
    int v34 = 1316;
    goto LABEL_109;
  }

  id v25 = *a2;
  if (*a2)
  {
    LODWORD(v26) = 0;
    do
    {
      id v25 = (uint64_t *)v25[2];
    }

    while (v25);
  }

  else
  {
    LODWORD(v26) = 0;
  }

  v50[0] = 0LL;
  v50[1] = 0LL;
  int v27 = bssl::Array<int>::Init((uint64_t)v50, (v26 + 1));
  unint64_t v28 = v50[0];
  if ((v27 & 1) != 0)
  {
    bzero(v50[0], 4LL * (v26 + 1));
    for (j = *a2; j; j = (uint64_t *)j[2])
    {
      if (*((_BYTE *)j + 8))
      {
        unsigned int bits = SSL_CIPHER_get_bits((const SSL_CIPHER *)*j, 0LL);
        ++*((_DWORD *)v50[0] + bits);
      }
    }

    uint64_t v26 = v26;
    do
    {
    }

    while (v26-- > 0);
    unint64_t v28 = v50[0];
  }

  OPENSSL_free(v28);
  int v8 = v37;
  if (v27)
  {
    id v7 = v14 + 8;
    unsigned int v32 = *((unsigned __int8 *)v14 + 8);
    if (v14[8])
    {
      a4 = v41;
      a3 = v42;
      while (1)
      {
        if (v32 == 58 || (v41 & 1) != 0)
        {
          if (v32 == 58) {
            goto LABEL_33;
          }
        }

        else if (v32 <= 0x3B && ((1LL << v32) & 0x800100100000000LL) != 0)
        {
          goto LABEL_33;
        }

        unsigned int v33 = *(unsigned __int8 *)++v7;
        unsigned int v32 = v33;
        if (!v33) {
          goto LABEL_33;
        }
      }
    }

LABEL_103:
    a4 = v41;
    a3 = v42;
    goto LABEL_33;
  }

  return 0LL;
}

    id v7 = 0LL;
    goto LABEL_104;
  }

  uint64_t v72 = v71;
  v73 = malloc(v12);
  if (v73)
  {
    v74 = v73;
    loga = (os_log_t)v12;
    uint64_t v75 = 0LL;
    v76 = 0LL;
    do
    {
      v77 = xpc_array_get_string(v27, v75);
      uint64_t v78 = strlen(v77);
      v74[v76] = v78;
      memcpy(&v74[v76 + 1], v77, v78);
      v76 += v78 + 1;
      ++v75;
    }

    while (v72 != v75);
    if ((v108[556] & 0x10) != 0)
    {
      SSL_set_alpn_select_cb(v107, (uint64_t)boringssl_context_select_alpn_callback, a1);
      id v7 = 1LL;
    }

    else
    {
      id v7 = SSL_set_alpn_protos(v107, v74, (unint64_t)loga) == 0;
    }

    free(v74);
    v108[557] |= 0x40u;
    objc_storeStrong((id *)v108 + 8, v27);
    goto LABEL_104;
  }

  v87 = (id *)(v108 + 16);
  v88 = objc_loadWeakRetained((id *)v108 + 2);
  if (v88)
  {
    v89 = v88;
    v90 = objc_loadWeakRetained(v87);
    v91 = v90[475];

    if ((v91 & 1) != 0) {
      goto LABEL_103;
    }
  }

  v92 = objc_loadWeakRetained(v87);
  if (v92)
  {
    v93 = objc_loadWeakRetained(v87);
    v94 = (v93[475] & 1) == 0;
  }

  else
  {
    v94 = 1;
  }

  id v7 = 0LL;
  if (v94 && g_boringssl_log)
  {
    v96 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
      boringssl_context_set_alpn_protocol_list_cold_2(v87, v12, v96);
    }

    goto LABEL_103;
  }

void sub_187563200(_Unwind_Exception *a1)
{
}

BOOL OPENSSL_isalnum(int a1)
{
  return (a1 - 48) < 0xA || (a1 & 0xFFFFFFDF) - 65 < 0x1A;
}

void *OPENSSL_realloc(void *a1, unint64_t a2)
{
  if (!a1) {
    return OPENSSL_malloc(a2);
  }
  size_t v4 = *(a1 - 1);
  uint64_t v5 = OPENSSL_malloc(a2);
  uint64_t v6 = v5;
  if (v5)
  {
    if (v4 >= a2) {
      size_t v7 = a2;
    }
    else {
      size_t v7 = v4;
    }
    memcpy(v5, a1, v7);
    OPENSSL_free(a1);
  }

  return v6;
}

uint64_t bssl::SSLCipherPreferenceList::Init( uint64_t a1, const EVP_MD_CTX **a2, const void *a3, const EVP_MD *a4)
{
  if (EVP_MD_CTX_md(*a2) == a4)
  {
    __dst = 0LL;
    uint64_t v14 = 0LL;
    uint64_t v8 = bssl::Array<unsigned char>::Init((uint64_t)&__dst, (unint64_t)a4);
    char v9 = v8 ^ 1;
    if (!a4) {
      char v9 = 1;
    }
    if ((v9 & 1) == 0) {
      memmove(__dst, a3, (size_t)a4);
    }
    if ((v8 & 1) != 0)
    {
      int v10 = (EVP_MD_CTX *)*a2;
      *a2 = 0LL;
      std::unique_ptr<stack_st_SSL_CIPHER,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)a1, (BUF_MEM *)v10);
      int v11 = 0LL;
      *(void *)(a1 + _Block_object_dispose(va, 8) = __dst;
      __dst = 0LL;
      uint64_t v14 = 0LL;
    }

    else
    {
      int v11 = __dst;
    }

    OPENSSL_free(v11);
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cipher.cc", 936);
    return 0LL;
  }

  return v8;
}

void sub_18756338C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::Array<unsigned char>::Init(uint64_t a1, unint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  if (a2)
  {
    uint64_t result = (uint64_t)OPENSSL_malloc(a2);
    *(void *)a1 = result;
    if (!result) {
      return result;
    }
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
  }

  return 1LL;
}

uint64_t SSL_CTX_set_max_proto_version(uint64_t a1, int a2)
{
  size_t v4 = *(_BYTE **)(a1 + 8);
  uint64_t v5 = (__int16 *)(a1 + 224);
  if (a2) {
    return bssl::set_version_bound(v4, v5, a2);
  }
  if (*v4) {
    __int16 v7 = -259;
  }
  else {
    __int16 v7 = 772;
  }
  __int16 *v5 = v7;
  return 1LL;
}

uint64_t SSL_CTX_set_min_proto_version(uint64_t a1, int a2)
{
  size_t v4 = *(_BYTE **)(a1 + 8);
  uint64_t v5 = (__int16 *)(a1 + 226);
  if (a2) {
    return bssl::set_version_bound(v4, v5, a2);
  }
  if (*v4) {
    __int16 v7 = -257;
  }
  else {
    __int16 v7 = 769;
  }
  __int16 *v5 = v7;
  return 1LL;
}

uint64_t boringssl_context_configure_defaults(uint64_t a1)
{
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  SSL_CTX_set_allow_unknown_alpn_protos(*(void *)(v1 + 408), 1);
  SSL_CTX_set_info_callback( *(SSL_CTX **)(v1 + 408),  (void (__cdecl *)(const SSL *, int, int))boringssl_context_info_handler);
  SSL_CTX_set_session_cache_mode(*(void *)(v1 + 408), 3);
  int v2 = *(SSL_CTX **)(v1 + 408);
  if ((*(_BYTE *)(v1 + 556) & 0x10) != 0)
  {
    int v3 = 0;
  }

  else
  {
    SSL_CTX_sess_set_new_cb(v2, (int (__cdecl *)(ssl_st *, SSL_SESSION *))boringssl_context_new_session_handler);
    int v2 = *(SSL_CTX **)(v1 + 408);
    int v3 = 3;
  }

  SSL_CTX_set_custom_verify((uint64_t)v2, v3, (uint64_t)boringssl_context_certificate_verify_callback);
  return 1LL;
}

uint64_t SSL_CTX_set_allow_unknown_alpn_protos(uint64_t result, int a2)
{
  *(_WORD *)(result + 832) = *(_WORD *)(result + 832) & 0xFF7F | ((a2 != 0) << 7);
  return result;
}

void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (__cdecl *cb)(const SSL *, int, int))
{
  ctx->param = (X509_VERIFY_PARAM *)cb;
}

uint64_t SSL_CTX_set_session_cache_mode(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 300);
  *(_DWORD *)(a1 + 300) = a2;
  return v2;
}

void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx, int (__cdecl *new_session_cb)(ssl_st *, SSL_SESSION *))
{
  *(void *)&ctx->read_ahead = new_session_cb;
}

uint64_t SSL_CTX_set_custom_verify(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)(result + 456) = a2;
  *(void *)(result + 352) = a3;
  return result;
}

void nw_protocol_boringssl_connected(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = a1[5];
    if (v3)
    {
      if ((*(_BYTE *)(v3 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_connected_cold_3();
      }

      uint64_t v5 = a1[6];
      if (v5 && (uint64_t v6 = *(void *)(v5 + 24)) != 0 && (v7 = *(void (**)(void))(v6 + 40)) != 0LL)
      {
        if (*(void *)(v3 + 336))
        {
          v7();
          if (a1[4] == a2)
          {
            if (boringssl_session_get_state(*(void *)(v3 + 336)) == 2)
            {
              if ((*(_BYTE *)(v3 + 475) & 1) == 0)
              {
                int8x16_t v12 = (os_log_s *)g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
                  {
                    int v13 = 136446978;
                    uint64_t v14 = "nw_protocol_boringssl_connected";
                    __int16 v15 = 1024;
                    int v16 = 1611;
                    __int16 v17 = 2082;
                    uint64_t v18 = v3 + 391;
                    __int16 v19 = 2048;
                    uint64_t v20 = v3;
                    _os_log_impl( &dword_187560000,  v12,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Already connected, reporting.",  (uint8_t *)&v13,  0x26u);
                  }
                }
              }

              (*(void (**)(void))(*(void *)(a1[6] + 24LL) + 40LL))();
            }

            else if ((*(_BYTE *)(v3 + 388) & 4) != 0)
            {
              if ((*(_BYTE *)(v3 + 475) & 1) == 0)
              {
                int v11 = (os_log_s *)g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
                  {
                    int v13 = 136446978;
                    uint64_t v14 = "nw_protocol_boringssl_connected";
                    __int16 v15 = 1024;
                    int v16 = 1618;
                    __int16 v17 = 2082;
                    uint64_t v18 = v3 + 391;
                    __int16 v19 = 2048;
                    uint64_t v20 = v3;
                    _os_log_impl( &dword_187560000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Already started the negotiation. Skipping.",  (uint8_t *)&v13,  0x26u);
                  }
                }
              }
            }

            else
            {
              *(_BYTE *)(v3 + 388) |= 4u;
              uint64_t v8 = a1[4];
              if (v8)
              {
                uint64_t v9 = *(void *)(v8 + 24);
                if (v9)
                {
                  int v10 = *(unsigned int (**)(void))(v9 + 216);
                  if (v10)
                  {
                    if (v10()) {
                      *(_BYTE *)(v3 + 389) |= 0x80u;
                    }
                  }
                }
              }
            }
          }
        }

        else if ((*(_BYTE *)(v3 + 475) & 1) == 0 {
               && g_boringssl_log
        }
               && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          nw_protocol_boringssl_connected_cold_2();
        }
      }

      else if ((*(_BYTE *)(v3 + 475) & 1) == 0 {
             && g_boringssl_log
      }
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_connected_cold_1();
      }
    }
  }

uint64_t boringssl_session_get_state(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(unsigned int *)(v1 + 300);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void nw_protocol_boringssl_begin_connection(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_begin_connection_cold_11();
    }

    (*(void (**)(void))(*(void *)(*(void *)(a1 + 48) + 24LL) + 112LL))();
    uint64_t v3 = (nw_parameters *)objc_claimAutoreleasedReturnValue();
    if (v3)
    {
      else {
        char v4 = 0;
      }
      *(_BYTE *)(v1 + 389) = *(_BYTE *)(v1 + 389) & 0xF7 | v4;
      uint64_t v5 = *(void *)(v1 + 336);
      int is_probe = nw_parameters_get_is_probe();
      boringssl_context_set_is_probe(v5, is_probe);
      boringssl_context_set_protocol_alert_callback(*(void *)(v1 + 336), &__block_literal_global_138);
      uint64_t v7 = *(void *)(v1 + 336);
      v37[0] = MEMORY[0x1895F87A8];
      v37[1] = 3221225472LL;
      v37[2] = __nw_protocol_boringssl_begin_connection_block_invoke_2;
      v37[3] = &__block_descriptor_40_e50_v16__0__boringssl_concrete_nw_protocol_boringssl_8lu32l8;
      v37[4] = v1;
      boringssl_context_set_connected_callback(v7, v37);
      if ((boringssl_session_create(*(SSL_CTX **)(v1 + 336)) & 1) != 0)
      {
        if ((boringssl_session_set_bio(*(void *)(v1 + 336), *(BIO **)(v1 + 344), *(BIO **)(v1 + 344)) & 1) != 0)
        {
          (*(void (**)(void))(*(void *)(*(void *)(a1 + 48) + 24LL) + 136LL))();
          uint64_t v8 = (nw_endpoint *)objc_claimAutoreleasedReturnValue();
          uint64_t v9 = v8;
          if (v8)
          {
            if (nw_endpoint_get_type(v8) == nw_endpoint_type_address)
            {
              address = (sockaddr *)nw_endpoint_get_address(v9);
              boringssl_context_set_remote_address(*(void **)(v1 + 336), &address->sa_len);
            }

            if ((*(_BYTE *)(v1 + 389) & 8) != 0
              || (subject_name = (const char *)nw_protocol_boringssl_get_subject_name((void *)v1, v9),
                  (int8x16_t v12 = (char *)subject_name) == 0LL)
              || (size_t v13 = strlen(subject_name),
                  (boringssl_session_set_peer_hostname(*(void *)(v1 + 336), v12, v13) & 1) != 0))
            {
              if (os_variant_allows_internal_security_policies()
                && nw_parameters_get_enable_tls_keylog())
              {
                boringssl_context_enable_keylog(*(void *)(v1 + 336));
              }

              unint64_t v36 = (void *)nw_parameters_copy_protocol_options_legacy();
              if (v36)
              {
                *(void *)buf = 0LL;
                *(void *)&buf[8] = buf;
                *(void *)&buf[16] = 0x2020000000LL;
                buf[24] = 0;
                nw_protocol_options_access_handle();
                uint64_t v14 = boringssl_context_set_enable_message_mode( *(void **)(v1 + 336),  *(unsigned __int8 *)(*(void *)&buf[8] + 24LL));
                __int16 v15 = *(void **)(v1 + 272);
                *(void *)(v1 + 272) = v14;

                int v16 = nw_parameters_copy_default_protocol_stack(v3);
                __int16 v17 = (nw_protocol_options *)nw_protocol_stack_copy_original_proxied_transport_protocol();
                if (v17 || (__int16 v17 = nw_protocol_stack_copy_transport_protocol(v16)) != 0LL)
                {
                  nw_protocol_definition_t v18 = nw_protocol_options_copy_definition(v17);
                  if (v18)
                  {
                    __int16 v19 = (void *)nw_protocol_copy_quic_connection_definition();
                    if (MEMORY[0x1895A958C](v18, v19))
                    {
                    }

                    else
                    {
                      uint64_t v20 = (void *)nw_protocol_copy_quic_stream_definition();
                      char v21 = MEMORY[0x1895A958C](v18, v20);

                      if ((v21 & 1) == 0)
                      {
                        nw_protocol_definition_t v22 = nw_protocol_copy_tcp_definition();
                        MEMORY[0x1895A958C](v18, v22);
                      }
                    }
                  }
                }

                char v23 = boringssl_session_apply_protocol_options_for_transport(*(void *)(v1 + 336), v36);
                if ((v23 & 1) != 0)
                {
                  int early_data_enabled = boringssl_session_get_early_data_enabled(*(void *)(v1 + 336));
                  char v25 = *(_BYTE *)(v1 + 389);
                  else {
                    char v26 = 0;
                  }
                  *(_BYTE *)(v1 + 389) = v26 | v25 & 0xDF;
                }

                else
                {
                  if ((*(_BYTE *)(v1 + 475) & 1) == 0
                    && g_boringssl_log
                    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    nw_protocol_boringssl_begin_connection_cold_8();
                  }

                  nw_protocol_boringssl_internal_error((void *)v1, -9810);
                  nw_protocol_boringssl_disconnect(a1);
                }

                _Block_object_dispose(buf, 8);
                if ((v23 & 1) != 0)
                {
                  if ((*(_BYTE *)(v1 + 389) & 8) == 0)
                  {
                    if (boringssl_context_get_ech_enabled(*(void *)(v1 + 336)))
                    {
                      int v27 = (void *)nw_endpoint_copy_ech_config();
                      if (boringssl_session_set_ech_config(*(void *)(v1 + 336), v27))
                      {
                        if ((*(_BYTE *)(v1 + 475) & 1) == 0
                          && g_boringssl_log
                          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                        {
                          nw_protocol_boringssl_begin_connection_cold_6();
                        }
                      }

                      else if ((*(_BYTE *)(v1 + 475) & 1) == 0 {
                             && g_boringssl_log
                      }
                             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                      {
                        nw_protocol_boringssl_begin_connection_cold_7();
                      }
                    }

                    if (*(void *)(v1 + 312))
                    {
                      unint64_t v28 = (void *)nw_endpoint_copy_original_endpoint();
                      unint64_t v29 = (void *)nw_parameters_copy_context();
                      if (v29)
                      {
                        id v30 = (void *)nw_context_copy_registered_endpoint();

                        uint64_t v31 = nw_endpoint_copy_association();
                        unsigned int v32 = *(void **)(v1 + 328);
                        *(void *)(v1 + 32_Block_object_dispose(va, 8) = v31;

                        boringssl_session_set_association(*(void *)(v1 + 336), *(void **)(v1 + 328));
                      }

                      else
                      {
                        if ((*(_BYTE *)(v1 + 475) & 1) == 0
                          && g_boringssl_log
                          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                        {
                          nw_protocol_boringssl_begin_connection_cold_5();
                        }

                        id v30 = v28;
                      }
                    }

                    else if ((*(_BYTE *)(v1 + 475) & 1) == 0 {
                           && g_boringssl_log
                    }
                           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      nw_protocol_boringssl_begin_connection_cold_4();
                    }
                  }

                  boringssl_session_clear_eap_metadata(*(void *)(v1 + 336));
                  nw_protocol_boringssl_handshake_negotiate((void *)v1);
                }
              }

              else
              {
                if ((*(_BYTE *)(v1 + 475) & 1) == 0
                  && g_boringssl_log
                  && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                {
                  nw_protocol_boringssl_begin_connection_cold_3();
                }

                ERR_print_errors_cb( (int (__cdecl *)(const char *, size_t, void *))nw_protocol_error_print,  *(void **)(v1 + 336));
                nw_protocol_boringssl_internal_error((void *)v1, -9854);
                nw_protocol_boringssl_disconnect(v1 + 8);
              }
            }

            else
            {
              if ((*(_BYTE *)(v1 + 475) & 1) == 0)
              {
                unsigned int v33 = (os_log_s *)g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    BOOL v34 = (*(_BYTE *)(v1 + 475) & 2) == 0;
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_protocol_boringssl_begin_connection";
                    if (v34) {
                      int v35 = v12;
                    }
                    else {
                      int v35 = "redacted";
                    }
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 457;
                    *(_WORD *)&buf[18] = 2082;
                    *(void *)&buf[20] = v1 + 391;
                    __int16 v39 = 2048;
                    uint64_t v40 = v1;
                    __int16 v41 = 2082;
                    xpc_object_t v42 = v35;
                    _os_log_error_impl( &dword_187560000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] boringssl_session_set_peer_hostname(%{public}s) failed",  buf,  0x30u);
                  }
                }
              }

              nw_protocol_boringssl_internal_error((void *)v1, -9810);
              nw_protocol_boringssl_disconnect(a1);
            }
          }

          else if ((*(_BYTE *)(v1 + 475) & 1) == 0 {
                 && g_boringssl_log
          }
                 && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_begin_connection_cold_2();
          }
        }

        else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          nw_protocol_boringssl_begin_connection_cold_9();
        }
      }

      else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_begin_connection_cold_10();
      }
    }

    else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_begin_connection_cold_1();
    }
  }

void sub_187564050( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t boringssl_context_set_is_probe(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        if (a2) {
          char v3 = 4;
        }
        else {
          char v3 = 0;
        }
        *(_BYTE *)(v2 + 559) = *(_BYTE *)(v2 + 559) & 0xFB | v3;
      }
    }
  }

  return result;
}

void boringssl_context_set_protocol_alert_callback(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        id v7 = v3;
        uint64_t v5 = MEMORY[0x1895A97C0]();
        uint64_t v6 = *(void **)(v4 + 280);
        *(void *)(v4 + 280) = v5;

        id v3 = v7;
      }
    }
  }
}

void boringssl_context_set_connected_callback(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        id v7 = v3;
        uint64_t v5 = MEMORY[0x1895A97C0]();
        uint64_t v6 = *(void **)(v4 + 288);
        *(void *)(v4 + 28_Block_object_dispose(va, 8) = v5;

        id v3 = v7;
      }
    }
  }
}

SSL_CTX *boringssl_session_create(SSL_CTX *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (LODWORD(result->method) != -1252936367) {
      return 0LL;
    }
    cipher_list = result->cipher_list;
    if (!cipher_list) {
      return 0LL;
    }
    uint64_t result = (SSL_CTX *)cipher_list[12].comp;
    if (result)
    {
      *(void *)&cipher_list[12].sorted = SSL_new(result);
      uint64_t result = *(SSL_CTX **)&cipher_list[12].sorted;
      if (result)
      {
        if ((BYTE4(cipher_list[17].data) & 0x10) != 0) {
          SSL_set_accept_state((SSL *)result);
        }
        else {
          SSL_set_connect_state((SSL *)result);
        }
        if (LODWORD(v1->method) == -1252936367)
        {
          id v3 = v1->cipher_list;
          if (v3)
          {
            if ((BYTE4(v3[17].data) & 0x20) != 0) {
              __int16 min_dtls_version_allowed = boringssl_config_get_min_dtls_version_allowed();
            }
            else {
              __int16 min_dtls_version_allowed = boringssl_config_get_min_tls_version_allowed();
            }
            WORD1(v3[1].comp) = min_dtls_version_allowed;
            if ((BYTE4(v3[17].data) & 0x20) != 0) {
              __int16 max_dtls_version_allowed = boringssl_config_get_max_dtls_version_allowed();
            }
            else {
              __int16 max_dtls_version_allowed = boringssl_config_get_max_tls_version_allowed();
            }
            LOWORD(v3[1].comp) = max_dtls_version_allowed;
            boringssl_context_set_min_version((uint64_t)v1, WORD1(v3[1].comp));
            boringssl_context_set_max_version((uint64_t)v1, (unsigned __int16)v3[1].comp);
            SSL_set_msg_callback( *(SSL **)&v3[12].sorted,  (void (__cdecl *)(int, int, int, const void *, size_t, SSL *, void *))boringssl_context_message_handler);
            SSL_set_msg_callback_arg(*(void *)&v3[12].sorted, (uint64_t)v1);
            SSL_set_cert_cb( *(void *)&v3[12].sorted,  (uint64_t)boringssl_context_certificate_request_callback,  (uint64_t)v1);
            unint64_t v8 = 0LL;
            uint64_t v6 = (unsigned __int16 *)boringssl_ciphers_copy_default_ciphersuites(&v8);
            id v7 = v6;
            if (v6 && v8)
            {
              boringssl_context_set_cipher_suites((uint64_t)v1, v6, v8);
            }

            else if (!v6)
            {
              return (SSL_CTX *)(SSL_set_ex_data(*(SSL **)&cipher_list[12].sorted, 0, v1) == 1);
            }

            free(v7);
            return (SSL_CTX *)(SSL_set_ex_data(*(SSL **)&cipher_list[12].sorted, 0, v1) == 1);
          }
        }

        return 0LL;
      }
    }
  }

  return result;
}

SSL *__cdecl SSL_new(SSL_CTX *ctx)
{
  v53 = ctx;
  if (!ctx)
  {
    ERR_put_error(16, 0, 185, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 640);
    return 0LL;
  }

  bssl::New<ssl_st,ssl_ctx_st *&>((ssl2_state_st **)&v53);
  __int16 v52 = v1;
  if (!v1) {
    goto LABEL_40;
  }
  __int16 v50 = v1;
  bssl::New<bssl::SSL_CONFIG,ssl_st *>(&v50);
  int v51 = 0LL;
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM ***)&v52->method, v2);
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM ***)&v51, 0LL);
  method = v52->method;
  if (!method) {
    goto LABEL_40;
  }
  uint64_t v4 = (ssl2_state_st *)v53;
  LODWORD(method->ssl_new) = v53->rsa_md5;
  bssl::ssl_cert_dup(*(bssl **)&v4[1].ract_data_length, &v51);
  uint64_t v5 = (bssl::CERT *)v51;
  p_ssl_accept = &v52->method->ssl_accept;
  int v51 = 0LL;
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)p_ssl_accept, v5);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)&v51, 0LL);
  id v7 = v52;
  unint64_t v8 = v52->method;
  if (!v8->ssl_accept) {
    goto LABEL_40;
  }
  uint64_t v9 = (ssl2_state_st *)v53;
  BYTE4(v8[1].ssl_write) = *(_DWORD *)&v53->tlsext_tick_hmac_key[8];
  v8->ssl_connect = (int (__cdecl *)(SSL *))v9[1].mac_data;
  v7->method->ssl_read = *(int (__cdecl **)(SSL *, void *, int))&v9[1].escape;
  *(_WORD *)((char *)&v7->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_write + 5) & 0xFFDF | (32 * (v9[2].challenge_length & 1));
  *(_WORD *)((char *)&v7->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_write + 5) & 0xFBFF | (16 * LOWORD(v9[2].challenge_length)) & 0x400;
  *(_WORD *)((char *)&v7->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_write + 5) & 0xF7FF | v9[2].challenge_length & 0x800;
  *(_WORD *)((char *)&v7->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v7->method[1].ssl_write + 5) & 0xEFFF | v9[2].challenge_length & 0x1000;
  int v10 = v7->method;
  LODWORD(v10[1].ssl_write) = v9[2].mac_data;
  int v11 = *(const void **)&v9[2].wpend_ret;
  uint64_t v12 = *(void *)&v9[2].rbuf_offs;
  p_ssl_read_bytes = (void **)&v10->ssl_read_bytes;
  int v14 = bssl::Array<unsigned short>::Init((uint64_t)&v10->ssl_read_bytes, v12);
  char v15 = v14 ^ 1;
  if (!v12) {
    char v15 = 1;
  }
  if ((v15 & 1) == 0) {
    memmove(*p_ssl_read_bytes, v11, 2 * v12);
  }
  if (!v14) {
    goto LABEL_40;
  }
  int v16 = *(const void **)&v53[1].stats.sess_accept_renegotiate;
  unint64_t v17 = *(void *)&v53[1].stats.sess_miss;
  p_ssl_ctrl = (void **)&v52->method->ssl_ctrl;
  int v19 = bssl::Array<unsigned char>::Init((uint64_t)p_ssl_ctrl, v17);
  char v20 = v19 ^ 1;
  if (!v17) {
    char v20 = 1;
  }
  if ((v20 & 1) == 0) {
    memmove(*p_ssl_ctrl, v16, v17);
  }
  if (!v19) {
    goto LABEL_40;
  }
  char v21 = *(unsigned __int8 **)&v53[1].read_ahead;
  uint64_t msg_callback = (uint64_t)v53[1].msg_callback;
  p_ssl_free = (void **)&v52->method[1].ssl_free;
  char v24 = bssl::Array<unsigned short>::Init((uint64_t)p_ssl_free, msg_callback);
  char v25 = v24 ^ 1;
  if (!msg_callback) {
    char v25 = 1;
  }
  if ((v25 & 1) == 0) {
    memmove(*p_ssl_free, v21, 2 * msg_callback);
  }
  if ((v24 & 1) == 0) {
    goto LABEL_40;
  }
  char v26 = v52;
  int v27 = (ssl2_state_st *)v53;
  session_cache_size = (const char *)v53[1].session_cache_size;
  unint64_t v29 = v52->method;
  if (session_cache_size)
  {
    id v30 = (char *)OPENSSL_strdup(session_cache_size);
    std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((void **)&v29->ssl_peek, v30);
    char v26 = v52;
    unint64_t v29 = v52->method;
    if (!v29->ssl_peek)
    {
LABEL_40:
      int8x16_t v48 = 0LL;
      goto LABEL_41;
    }

    int v27 = (ssl2_state_st *)v53;
  }

  v29->ssl_write = *(int (__cdecl **)(SSL *, const void *, int))&v27[1].key_material[4];
  v26->method->ssl_shutdown = *(int (__cdecl **)(SSL *))&v27[1].key_material[12];
  v26->method->ssl_renegotiate = *(int (__cdecl **)(SSL *))&v27[1].key_material[20];
  *(_WORD *)((char *)&v26->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v26->method[1].ssl_write + 5) & 0xFFF7 | (LOWORD(v27[2].challenge_length) >> 1) & 8;
  rbuf = (EVP_PKEY *)v27[2].rbuf;
  if (rbuf)
  {
    EVP_PKEY_up_ref((unsigned int *)v27[2].rbuf);
    char v26 = v52;
  }

  p_ssl_dispatch_alert = (EVP_PKEY **)&v26->method->ssl_dispatch_alert;
  int v51 = 0LL;
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](p_ssl_dispatch_alert, rbuf);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)&v51, 0LL);
  BOOL v34 = v52;
  unsigned int v33 = (ssl2_state_st *)v53;
  *(_WORD *)((char *)&v52->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v52->method[1].ssl_write + 5) & 0xFFFD | (LOWORD(v53[1].msg_callback_arg) >> 2) & 2;
  *(_WORD *)((char *)&v34->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v34->method[1].ssl_write + 5) & 0xFFFB | v33[2].challenge_length & 4;
  *(_WORD *)((char *)&v34->method[1].ssl_write + 5) = *(_WORD *)((_BYTE *)&v34->method[1].ssl_write + 5) & 0xFFBF | (LOWORD(v33[2].challenge_length) >> 3) & 0x40;
  *(void *)&v34->hit = *(void *)&v33->key_material[28];
  int v35 = *(const void **)v33[1].tmp.ccl;
  unint64_t v36 = *(void *)&v33[1].tmp.ccl[8];
  p_num_ciphers = (void **)&v34->method->num_ciphers;
  int v38 = bssl::Array<unsigned char>::Init((uint64_t)p_num_ciphers, v36) ^ 1;
  if (!v36) {
    LOBYTE(v3_Block_object_dispose(va, 8) = 1;
  }
  if ((v38 & 1) == 0) {
    memmove(*p_num_ciphers, v35, v36);
  }
  app_verify_callback = (ssl_credential_st *)v53[1].app_verify_callback;
  if (app_verify_callback) {
    SSL_CREDENTIAL_up_ref(v53[1].app_verify_callback);
  }
  p_get_ssl_method = &v52->method->get_ssl_method;
  int v51 = 0LL;
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]( (ssl_credential_st **)p_get_ssl_method,  app_verify_callback);
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_credential_st **)&v51, 0LL);
  app_verify_arg = v53[1].app_verify_arg;
  unint64_t default_passwd_callback = (unint64_t)v53[1].default_passwd_callback;
  p_get_timeout = (void **)&v52->method->get_timeout;
  int v44 = bssl::Array<unsigned char>::Init((uint64_t)p_get_timeout, default_passwd_callback) ^ 1;
  if (!default_passwd_callback) {
    LOBYTE(v44) = 1;
  }
  if ((v44 & 1) == 0) {
    memmove(*p_get_timeout, app_verify_arg, default_passwd_callback);
  }
  default_passwd_callback_userdata = (ssl_credential_st *)v53[1].default_passwd_callback_userdata;
  if (default_passwd_callback_userdata) {
    SSL_CREDENTIAL_up_ref(v53[1].default_passwd_callback_userdata);
  }
  p_ssl_version = &v52->method->ssl_version;
  int v51 = 0LL;
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]( (ssl_credential_st **)p_ssl_version,  default_passwd_callback_userdata);
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_credential_st **)&v51, 0LL);
  uint64_t v47 = v52;
  LOWORD(v52->method->ssl_callback_ctrl) = v53[1].client_cert_cb;
  if (!(*(unsigned int (**)(ssl_st *))(*(void *)&v47->version + 8LL))(v47)
    || ((*(uint64_t (**)(void))(*(void *)&v52->s2->wnum + 88LL))(*((void *)v52->handshake_func + 35)) & 1) == 0)
  {
    goto LABEL_40;
  }

  int8x16_t v48 = v52;
  __int16 v52 = 0LL;
LABEL_41:
  std::unique_ptr<ssl_st,bssl::internal::Deleter>::reset[abi:ne180100](&v52, 0LL);
  return v48;
}

void sub_187564824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void bssl::New<ssl_st,ssl_ctx_st *&>(ssl2_state_st **a1)
{
  uint64_t v2 = (ssl_st *)OPENSSL_malloc(0xB8uLL);
  if (v2) {
    ssl_st::ssl_st(v2, *a1);
  }
}

void ssl_st::ssl_st(ssl_st *this, ssl2_state_st *a2)
{
  *(void *)&this->version = *(void *)&a2->escape;
  this->method = 0LL;
  __int16 v4 = *(_WORD *)&a2[1].challenge[6];
  *(void *)&this->server = 0LL;
  *(_OWORD *)&this->rwstate = 0u;
  *(_OWORD *)&this->wbio = 0u;
  __int128 v5 = *(_OWORD *)&a2[1].wact_data_length;
  this->packet = 0LL;
  LOWORD(this->rbio) = 0;
  WORD1(this->rbio) = v4;
  *(_OWORD *)&this->quiet_shutdown = v5;
  this->init_buf = 0LL;
  this->init_msg = 0LL;
  this->init_num = 1000;
  *(void *)&this->packet_length = 0LL;
  CRYPTO_refcount_inc((unsigned int *)a2);
  this->s2 = a2;
  CRYPTO_refcount_inc((unsigned int *)a2);
  s2 = this->s2;
  *(void *)&this->read_ahead = s2[1].write_ptr;
  unsigned int padding = s2[1].padding;
  this->msg_callback_arg = 0LL;
  this->s3 = (ssl3_state_st *)a2;
  LODWORD(this->msg_callback) = padding;
  *(void *)&this->hit = 0LL;
  LODWORD(this->param) = 0;
  LOBYTE(padding) = BYTE4(this->param);
  BYTE4(this->param) = padding & 0xFE;
  LOBYTE(padding) = s2[2].challenge_length & 2 | padding & 0xFC;
  BYTE4(this->param) = padding;
  BYTE4(this->param) = BYTE1(s2[2].challenge_length) & 4 | padding & 0xFB;
  CRYPTO_new_ex_data((_DWORD)this + 136, v8, v9);
}

void sub_18756498C(_Unwind_Exception *a1)
{
}

double bssl::New<bssl::SSL_CONFIG,ssl_st *>(ssl_st **a1)
{
  uint64_t v2 = (bssl::SSL_CONFIG *)OPENSSL_malloc(0x130uLL);
  if (v2) {
    return bssl::SSL_CONFIG::SSL_CONFIG(v2, *a1);
  }
  return result;
}

double bssl::SSL_CONFIG::SSL_CONFIG(bssl::SSL_CONFIG *this, ssl_st *a2)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + _Block_object_dispose(va, 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 202) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *(_OWORD *)((char *)this + 285) = 0u;
  *(_WORD *)((char *)this + 301) = *(_WORD *)((_BYTE *)this + 301) & 0x1800 | 0xC000;
  if (!a2) {
    __assert_rtn("SSL_CONFIG", "ssl_lib.cc", 746, "ssl");
  }
  return result;
}

void sub_187564AF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _Unwind_Exception *exception_object)
{
}

void bssl::ssl_cert_dup(bssl *this@<X0>, ssl_credential_st ***a2@<X8>)
{
  nw_protocol_definition_t v18 = (ssl_credential_st **)bssl::New<bssl::CERT,bssl::SSL_X509_METHOD const*&>((uint64_t *)this + 4);
  if (!v18)
  {
LABEL_14:
    int v14 = 0LL;
    goto LABEL_15;
  }

  if (*(void *)this)
  {
    __int128 v5 = (ssl_credential_st **)*((void *)this + 1);
    uint64_t v6 = 8LL * *(void *)this;
    do
    {
      id v7 = (unint64_t *)v18;
      unint64_t v8 = *v5;
      if (*v5) {
        SSL_CREDENTIAL_up_ref(*v5);
      }
      uint64_t v17 = v8;
      char v9 = bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Push(v7, &v17);
      int v10 = v17;
      uint64_t v17 = 0LL;
      if (v10) {
        SSL_CREDENTIAL_free(v10);
      }
      if ((v9 & 1) == 0) {
        goto LABEL_14;
      }
      ++v5;
      v6 -= 8LL;
    }

    while (v6);
  }

  ssl_credential_st::Dup(*((ssl_credential_st **)this + 3), &v16);
  int v11 = v16;
  uint64_t v16 = 0LL;
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100](v18 + 3, v11);
  uint64_t v12 = v16;
  uint64_t v16 = 0LL;
  if (v12) {
    SSL_CREDENTIAL_free(v12);
  }
  size_t v13 = v18;
  int v14 = (ssl_credential_st **)v18[3];
  if (v14)
  {
    *((_OWORD *)v18 + 4) = *((_OWORD *)this + 4);
    (*((void (**)(void))v13[4] + 3))();
    int v14 = v18;
    *((_BYTE *)v18 + 8_Block_object_dispose(va, 8) = *((_BYTE *)this + 88);
    __int128 v15 = *(_OWORD *)((char *)this + 89);
    *(_OWORD *)((char *)v14 + 105) = *(_OWORD *)((char *)this + 105);
    *(_OWORD *)((char *)v14 + 89) = v15;
    nw_protocol_definition_t v18 = 0LL;
  }

LABEL_15:
  *a2 = v14;
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)&v18, 0LL);
}

    ++v7;
    v6 -= 2LL;
  }

  while (v6);
  return 1LL;
}

    uint64_t v17 = bssl::ssl_add_message_cbb((uint64_t)v9, (uint64_t)v53);
LABEL_62:
    nw_protocol_definition_t v18 = v17;
    goto LABEL_70;
  }

  if ((v15 & 0x200000) == 0 || *((_BYTE *)this + 730) != 2 || (v7 & 1) != 0)
  {
    if (!bssl::ssl_has_certificate(this, v14))
    {
      if (!a3)
      {
        uint64_t v17 = bssl::ssl_add_message_cbb((uint64_t)v9, (uint64_t)v53);
        goto LABEL_62;
      }

      __int16 v39 = CBB_finish((uint64_t)v53, a3, a4);
      goto LABEL_58;
    }

    if (!ssl_credential_st::UsesX509(*((ssl_credential_st **)this + 188))) {
      __assert_rtn("tls13_add_certificate_in_buffer", "tls13_both.cc", 636, "hs->credential->UsesX509()");
    }
    int v19 = OPENSSL_sk_value(*(unint64_t **)(v10 + 48), 0LL);
    *(void *)&char v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v49 = v20;
    __int16 v50 = v20;
    uint64_t v47 = v20;
    int8x16_t v48 = v20;
    char v45 = v20;
    uint64_t v46 = v20;
    if (!CBB_add_u24_length_prefixed((uint64_t *)v51, (uint64_t)&v48)
      || (char v21 = (const void *)CRYPTO_BUFFER_data((uint64_t)v19),
          nw_protocol_definition_t v22 = CRYPTO_BUFFER_len((uint64_t)v19),
          !CBB_add_bytes((uint64_t)&v48, v21, v22))
      || !CBB_add_u16_length_prefixed((uint64_t *)v51, (uint64_t)&v45))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 643);
      nw_protocol_definition_t v18 = 0LL;
      goto LABEL_70;
    }

    char v23 = *((_DWORD *)this + 396);
    if ((v23 & 4) != 0 && *(void *)(v10 + 72))
    {
      *(void *)&char v24 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v43 = v24;
      int v44 = v24;
      xpc_object_t v42 = v24;
      if (!CBB_add_u16((uint64_t)&v45, 0x12u)
        || !CBB_add_u16_length_prefixed((uint64_t *)&v45, (uint64_t)&v42)
        || (char v25 = (const void *)CRYPTO_BUFFER_data(*(void *)(v10 + 72)),
            char v26 = CRYPTO_BUFFER_len(*(void *)(v10 + 72)),
            !CBB_add_bytes((uint64_t)&v42, v25, v26))
        || !CBB_flush((uint64_t *)&v45))
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 656);
        goto LABEL_69;
      }

      char v23 = *((_DWORD *)this + 396);
    }

    if ((v23 & 0x80) == 0) {
      goto LABEL_79;
    }
    if (!*(void *)(v10 + 80)) {
      goto LABEL_79;
    }
    *(void *)&int v27 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v43 = v27;
    int v44 = v27;
    v41[2] = v27;
    xpc_object_t v42 = v27;
    v41[0] = v27;
    v41[1] = v27;
    if (CBB_add_u16_length_prefixed((uint64_t *)&v45, (uint64_t)&v42)
      && CBB_add_u8((uint64_t)&v42, 1u)
      && CBB_add_u24_length_prefixed((uint64_t *)&v42, (uint64_t)v41)
      && (unint64_t v28 = (const void *)CRYPTO_BUFFER_data(*(void *)(v10 + 80)),
          unint64_t v29 = CRYPTO_BUFFER_len(*(void *)(v10 + 80)),
          CBB_add_bytes((uint64_t)v41, v28, v29))
      && CBB_flush((uint64_t *)&v45))
    {
LABEL_79:
      if (*(_DWORD *)(v10 + 4) != 1
        || (*(void *)&id v30 = 0xAAAAAAAAAAAAAAAALL,
            *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL,
            uint64_t v43 = v30,
            int v44 = v30,
            xpc_object_t v42 = v30,
            CBB_add_u16((uint64_t)&v45, 0x22u))
        && CBB_add_u16_length_prefixed((uint64_t *)&v45, (uint64_t)&v42)
        && (uint64_t v31 = (const void *)CRYPTO_BUFFER_data(*(void *)(v10 + 56)),
            unsigned int v32 = CRYPTO_BUFFER_len(*(void *)(v10 + 56)),
            CBB_add_bytes((uint64_t)&v42, v31, v32))
        && CBB_flush((uint64_t *)&v45))
      {
        for (size_t i = 1LL; i < (unint64_t)EVP_MD_CTX_md(*(const EVP_MD_CTX **)(v10 + 48)); ++i)
        {
          BOOL v34 = OPENSSL_sk_value(*(unint64_t **)(v10 + 48), i);
          *(void *)&int v35 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v43 = v35;
          int v44 = v35;
          xpc_object_t v42 = v35;
          if (CBB_add_u24_length_prefixed((uint64_t *)v51, (uint64_t)&v42))
          {
            unint64_t v36 = (const void *)CRYPTO_BUFFER_data((uint64_t)v34);
            int v37 = CRYPTO_BUFFER_len((uint64_t)v34);
            if (CBB_add_bytes((uint64_t)&v42, v36, v37))
            {
            }
          }

          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 695);
          goto LABEL_69;
        }

        if ((*((_BYTE *)this + 1586) & 0x10) != 0)
        {
          uint64_t v17 = bssl::tls13_add_compressed_certificate(v9, (uint64_t)v53, (uint64_t)this, (uint64_t *)v52, a3, a4);
          goto LABEL_62;
        }

        if (!a3)
        {
          uint64_t v17 = bssl::ssl_add_message_cbb((uint64_t)v9, (uint64_t)v53);
          goto LABEL_62;
        }

        __int16 v39 = CBB_finish((uint64_t)v53, a3, a4);
LABEL_58:
        nw_protocol_definition_t v18 = v39 != 0;
        goto LABEL_70;
      }

      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 683);
    }

    else
    {
LABEL_68:
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 671);
    }

    LOBYTE(a2->version) = v15;
    return result;
  }

  if (!v8)
  {
    if ((a4 & 1) != 0) {
      return 1LL;
    }
    double result = 0LL;
    __int128 v15 = 110;
    goto LABEL_15;
  }

  if (((*(_WORD *)(a1[1] + 301LL) & 0x200) == 0) == a4) {
    return 1LL;
  }
  int v10 = (void **)(*(void *)(v7 + 48) + 584LL);
  int v11 = *(const void **)a3;
  uint64_t v12 = *(void *)(a3 + 8);
  double result = bssl::Array<unsigned char>::Init((uint64_t)v10, v12);
  if (v12 && (_DWORD)result)
  {
    memmove(*v10, v11, v12);
    return 1LL;
  }

  return result;
}

  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = boringssl_context_state_get_ssl_ctx((uint64_t)v6);

  return 0LL;
}

void sub_187564D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t bssl::Array<unsigned short>::Init(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  if (!a2) {
    return 1LL;
  }
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    uint64_t result = (uint64_t)OPENSSL_malloc(2 * a2);
    *(void *)a1 = result;
    if (!result) {
      return result;
    }
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    return 1LL;
  }

  ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 297);
  return 0LL;
}

uint64_t bssl::tls_new(unsigned __int8 **this, ssl_st *a2)
{
  size_t v13 = (bssl::SSLAEADContext **)v3;
  if (!v3) {
    goto LABEL_6;
  }
  BOOL v4 = SSL_is_dtls(this) != 0;
  bssl::SSLAEADContext::CreateNullCipher((bssl::SSLAEADContext *)v4, &v12);
  __int128 v5 = v12;
  uint64_t v12 = 0LL;
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](v13 + 33, v5);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v12, 0LL);
  BOOL v6 = SSL_is_dtls(this) != 0;
  bssl::SSLAEADContext::CreateNullCipher((bssl::SSLAEADContext *)v6, &v12);
  id v7 = v12;
  uint64_t v12 = 0LL;
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](v13 + 34, v7);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v12, 0LL);
  bssl::ssl_handshake_new((ssl_st *)this, &v12);
  unint64_t v8 = v12;
  uint64_t v12 = 0LL;
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100](v13 + 35, v8);
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100](&v12, 0LL);
  char v9 = v13;
  if (!v13[33]) {
    goto LABEL_6;
  }
  if (v13[34] && v13[35])
  {
    size_t v13 = 0LL;
    this[6] = (unsigned __int8 *)v9;
    *((_WORD *)this + _Block_object_dispose(va, 8) = 771;
    uint64_t v10 = 1LL;
  }

  else
  {
LABEL_6:
    uint64_t v10 = 0LL;
  }

  std::unique_ptr<bssl::SSL3_STATE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL3_STATE **)&v13, 0LL);
  return v10;
}

void sub_187564ECC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

double bssl::New<bssl::SSL3_STATE>()
{
  v0 = OPENSSL_malloc(0x260uLL);
  if (v0)
  {
    *((_DWORD *)v0 + 43) = 0;
    *((_DWORD *)v0 + 44) = 0;
    *((_DWORD *)v0 + 54) = 0;
    double result = 0.0;
    *(_OWORD *)v0 = 0u;
    *((_OWORD *)v0 + 1) = 0u;
    *((_OWORD *)v0 + 2) = 0u;
    *((_OWORD *)v0 + 3) = 0u;
    *((_OWORD *)v0 + 4) = 0u;
    *((_OWORD *)v0 + 5) = 0u;
    *((_WORD *)v0 + 4_Block_object_dispose(va, 8) = 0;
    *(void *)((char *)v0 + 111) = 0LL;
    *(void *)((char *)v0 + 103) = 0LL;
    *(_DWORD *)((char *)v0 + 11_Block_object_dispose(va, 8) = 0;
    *(_OWORD *)((char *)v0 + 127) = 0u;
    *(_OWORD *)((char *)v0 + 143) = 0u;
    *(_OWORD *)((char *)v0 + 153) = 0u;
    v0[24] = 0LL;
    v0[25] = 0LL;
    v0[23] = 0LL;
    *(void *)((char *)v0 + 205) = 0LL;
    *((_WORD *)v0 + 110) &= 0x8000u;
    *((_OWORD *)v0 + 14) = 0u;
    *((_OWORD *)v0 + 15) = 0u;
    *((_DWORD *)v0 + 64) = 0;
    *(_OWORD *)(v0 + 33) = 0u;
    *(_OWORD *)(v0 + 35) = 0u;
    *(_OWORD *)(v0 + 37) = 0u;
    *(_OWORD *)(v0 + 39) = 0u;
    *(_OWORD *)(v0 + 41) = 0u;
    *(_OWORD *)(v0 + 43) = 0u;
    *(_OWORD *)(v0 + 45) = 0u;
    *(_OWORD *)(v0 + 47) = 0u;
    *(_OWORD *)(v0 + 49) = 0u;
    *(_OWORD *)(v0 + 51) = 0u;
    *(_OWORD *)(v0 + 53) = 0u;
    *(_OWORD *)(v0 + 55) = 0u;
    *(_OWORD *)((char *)v0 + 455) = 0u;
    *(_OWORD *)(v0 + 59) = 0u;
    *(_OWORD *)(v0 + 61) = 0u;
    *(_OWORD *)(v0 + 63) = 0u;
    *(_OWORD *)(v0 + 65) = 0u;
    *(_OWORD *)(v0 + 67) = 0u;
    *(_OWORD *)(v0 + 69) = 0u;
    *(_OWORD *)(v0 + 71) = 0u;
    *(_OWORD *)(v0 + 73) = 0u;
    v0[75] = 0LL;
  }

  return result;
}

uint64_t SSL_is_dtls(unsigned __int8 **a1)
{
  return **a1;
}

void *bssl::SSLAEADContext::CreateNullCipher@<X0>(bssl::SSLAEADContext *this@<X0>, void *a2@<X8>)
{
  char v5 = (char)this;
  int v4 = 0;
  double result = bssl::New<bssl::SSLAEADContext,int,BOOL &,decltype(nullptr)>(&v4, &v5);
  *a2 = result;
  return result;
}

void *bssl::New<bssl::SSLAEADContext,int,BOOL &,decltype(nullptr)>(int *a1, char *a2)
{
  int v4 = OPENSSL_malloc(0x268uLL);
  char v5 = v4;
  if (v4)
  {
    int v6 = *a1;
    char v7 = *a2;
    void *v4 = 0LL;
    EVP_AEAD_CTX_zero(v4 + 1);
    *((_WORD *)v5 + 302) = 0;
    *((_WORD *)v5 + 303) = v6;
    *((_BYTE *)v5 + 60_Block_object_dispose(va, 8) = v7;
    *((_BYTE *)v5 + 609) &= 0xE0u;
    v5[74] = 0LL;
    *((_DWORD *)v5 + 150) = 0;
  }

  return v5;
}

void EVP_AEAD_CTX_zero(void *a1)
{
}

void bssl::ssl_handshake_new(ssl_st *this@<X0>, bssl::SSL_HANDSHAKE **a2@<X8>)
{
  unint64_t v8 = this;
  int v4 = (BUF_MEM **)bssl::New<bssl::SSL_HANDSHAKE,ssl_st *&>(&v8);
  char v7 = v4;
  if (v4 && bssl::SSLTranscript::Init(v4 + 53))
  {
    method = v8->method;
    int v6 = (bssl::SSL_HANDSHAKE *)v7;
    v7[1] = (BUF_MEM *)method;
    if (!method) {
      __assert_rtn("ssl_handshake_new", "handshake.cc", 209, "hs->config");
    }
    char v7 = 0LL;
  }

  else
  {
    int v6 = 0LL;
  }

  *a2 = v6;
  std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSL_HANDSHAKE **)&v7, 0LL);
}

void sub_1875650F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, bssl::SSL_HANDSHAKE *a9)
{
}

bssl::SSL_HANDSHAKE *bssl::New<bssl::SSL_HANDSHAKE,ssl_st *&>(ssl_st **a1)
{
  double result = (bssl::SSL_HANDSHAKE *)OPENSSL_malloc(0x668uLL);
  if (result) {
    return bssl::SSL_HANDSHAKE::SSL_HANDSHAKE(result, *a1);
  }
  return result;
}

bssl::SSL_HANDSHAKE *bssl::SSL_HANDSHAKE::SSL_HANDSHAKE(bssl::SSL_HANDSHAKE *this, ssl_st *a2)
{
  *(void *)this = a2;
  *((_DWORD *)this + 4) = 1;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *(_OWORD *)((char *)this + 132) = 0u;
  *(_OWORD *)((char *)this + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 164) = 0u;
  *(_OWORD *)((char *)this + 180) = 0u;
  *(_OWORD *)((char *)this + 1bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
  *(_OWORD *)((char *)this + 212) = 0u;
  *(_OWORD *)((char *)this + 22_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 244) = 0u;
  *((_DWORD *)this + 101) = 0;
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(_OWORD *)((char *)this + 276) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(_OWORD *)((char *)this + 30_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 324) = 0u;
  *(_OWORD *)((char *)this + 340) = 0u;
  *(_OWORD *)((char *)this + 356) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *(_OWORD *)((char *)this + 38_Block_object_dispose(va, 8) = 0u;
  bssl::SSLTranscript::SSLTranscript((bssl::SSL_HANDSHAKE *)((char *)this + 424));
  bssl::SSLTranscript::SSLTranscript((bssl::SSL_HANDSHAKE *)((char *)this + 464));
  *((_WORD *)this + 366) = 0;
  *((_BYTE *)this + 734) = 0;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 56_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 64_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + bssl::Array<unsigned short>::~Array(v17 + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 6bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
  *(_OWORD *)((char *)this + bssl::Array<unsigned short>::~Array(v17 + 712) = 0u;
  EVP_HPKE_CTX_zero((uint64_t)this + 736);
  *((void *)this + 197) = 0LL;
  *(_OWORD *)((char *)this + 1544) = 0u;
  *(_OWORD *)((char *)this + 1560) = 0u;
  *(_OWORD *)((char *)this + 1512) = 0u;
  *(_OWORD *)((char *)this + 152_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 1480) = 0u;
  *(_OWORD *)((char *)this + 14bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
  *(_OWORD *)((char *)this + 144_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 1464) = 0u;
  *((_DWORD *)this + 396) &= 0xFC000000;
  *((_BYTE *)this + 1636) = 0;
  *(_OWORD *)((char *)this + 158_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 1604) = 0u;
  *(_OWORD *)((char *)this + 1620) = 0u;
  if (!*(void *)this) {
    __assert_rtn("SSL_HANDSHAKE", "handshake.cc", 160, "ssl");
  }
  RAND_bytes((unsigned __int8 *)this + 1630, 7);
  return this;
}

void sub_1875652E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, bssl::SSLTranscript *a11, bssl::SSLTranscript *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  for (uint64_t i = 0LL; i != -16; i -= 8LL)
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)(v16 + 400 + i), 0LL);
  std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)(v16 + 384), 0LL);
  _Unwind_Resume(a1);
}

bssl::SSLTranscript *bssl::SSLTranscript::SSLTranscript(bssl::SSLTranscript *this)
{
  *(void *)this = 0LL;
  EVP_MD_CTX_init((EVP_MD_CTX *)((char *)this + 8));
  return this;
}

void sub_187565494(_Unwind_Exception *a1)
{
}

void EVP_MD_CTX_init(EVP_MD_CTX *ctx)
{
  *(_OWORD *)&ctx->digest = 0u;
  *(_OWORD *)&ctx->flags = 0u;
}

void EVP_HPKE_CTX_zero(uint64_t a1)
{
}

int RAND_bytes(unsigned __int8 *buf, int num)
{
  return 1;
}

uint64_t CRYPTO_sysrand(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t (**)(void, uint64_t, uint64_t))ccrng();
  if (!v4) {
    abort();
  }
  return (*v4)(v4, a2, a1);
}

BOOL bssl::SSLTranscript::Init(BUF_MEM **this)
{
  uint64_t v2 = BUF_MEM_new();
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](this, v2);
  uint64_t v3 = *this;
  if (*this)
  {
    int v4 = (EVP_MD_CTX *)(this + 1);
    EVP_MD_CTX_cleanup(v4);
    EVP_MD_CTX_init(v4);
  }

  return v3 != 0LL;
}

BUF_MEM *BUF_MEM_new(void)
{
  return (BUF_MEM *)OPENSSL_zalloc(0x18uLL);
}

int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)
{
  md_data = (void (**)(void))ctx->md_data;
  if (ctx->flags)
  {
    if (!md_data) {
      EVP_MD_CTX_cleanup_cold_1();
    }
    goto LABEL_5;
  }

  if (md_data) {
LABEL_5:
  }
    (*md_data)();
  *(_OWORD *)&ctx->digest = 0u;
  *(_OWORD *)&ctx->flags = 0u;
  return 1;
}

uint64_t bssl::ssl_noop_x509_ssl_new()
{
  return 1LL;
}

void SSL_set_connect_state(SSL *s)
{
  BYTE4(s->param) &= ~1u;
  *(void *)&s->rwstate = bssl::ssl_client_handshake;
}

uint64_t boringssl_context_set_min_version(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4 || !*(void *)(v4 + 400)) {
    return 0xFFFFFFFFLL;
  }
  if (os_variant_has_internal_content()
    && boringssl_config_get_restricted_mode_state()
    && (*(_DWORD *)a1 != -1252936367 || (uint64_t v6 = *(void *)(a1 + 8)) == 0 || (*(_BYTE *)(v6 + 556) & 0x20) != 0
      ? (int v7 = boringssl_config_restricted_mode_restrict_dtls_version(a2))
      : (int v7 = boringssl_config_restricted_mode_restrict_tls_version(a2)),
        int v9 = v7,
        v7 != (_DWORD)a2))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
    if (!WeakRetained
      || (nw_protocol_definition_t v18 = WeakRetained,
          int v19 = objc_loadWeakRetained((id *)(v4 + 16)),
          char v20 = v19[475],
          v19,
          v18,
          (v20 & 1) == 0))
    {
      id v21 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v21)
      {
        nw_protocol_definition_t v22 = objc_loadWeakRetained((id *)(v4 + 16));
        BOOL v23 = (v22[475] & 1) == 0;
      }

      else
      {
        BOOL v23 = 1;
      }

      if (v23)
      {
        if (g_boringssl_log)
        {
          char v25 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            id v26 = objc_loadWeakRetained((id *)(v4 + 16));
            if (v26)
            {
              uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
              int v27 = v2 + 391;
            }

            else
            {
              int v27 = &unk_1875F4C23;
            }

            id v28 = objc_loadWeakRetained((id *)(v4 + 16));
            int v29 = 136447490;
            id v30 = "boringssl_context_set_min_version";
            __int16 v31 = 1024;
            int v32 = 182;
            __int16 v33 = 2082;
            BOOL v34 = v27;
            __int16 v35 = 2048;
            id v36 = v28;
            __int16 v37 = 1024;
            int v38 = a2;
            __int16 v39 = 1024;
            int v40 = v9;
            _os_log_debug_impl( &dword_187560000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Restricted mode: Provided minimum version (0x%x) was capped to (0x%x).",  (uint8_t *)&v29,  0x32u);

            if (v26) {
          }
            }
        }
      }
    }
  }

  else
  {
    LOWORD(v9) = a2;
  }

  if (SSL_set_min_proto_version(*(void *)(v4 + 400), (unsigned __int16)v9))
  {
    uint64_t result = 0LL;
    *(_WORD *)(v4 + 5_Block_object_dispose(va, 8) = v9;
    return result;
  }

  id v10 = objc_loadWeakRetained((id *)(v4 + 16));
  if (v10)
  {
    int v11 = v10;
    uint64_t v12 = objc_loadWeakRetained((id *)(v4 + 16));
    char v13 = v12[475];

    if ((v13 & 1) != 0) {
      return 0LL;
    }
  }

  id v14 = objc_loadWeakRetained((id *)(v4 + 16));
  if (v14)
  {
    __int128 v15 = objc_loadWeakRetained((id *)(v4 + 16));
    BOOL v16 = (v15[475] & 1) == 0;
  }

  else
  {
    BOOL v16 = 1;
  }

  uint64_t result = 0LL;
  if (v16 && g_boringssl_log)
  {
    char v24 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      boringssl_context_set_min_version_cold_1(v4 + 16, v24);
    }

    return 0LL;
  }

  return result;
}

uint64_t boringssl_config_get_restricted_mode_state()
{
  uint64_t result = os_variant_has_internal_content();
  if ((_DWORD)result)
  {
    if (check_and_init_restricted_mode_onceToken != -1) {
      dispatch_once(&check_and_init_restricted_mode_onceToken, &__block_literal_global_5_0);
    }
    return boringssl_config_restricted_mode_status;
  }

  return result;
}

uint64_t SSL_set_min_proto_version(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v4 = *(_BYTE **)a1;
  char v5 = (__int16 *)(v2 + 10);
  if (a2) {
    return bssl::set_version_bound(v4, v5, a2);
  }
  if (*v4) {
    __int16 v7 = -257;
  }
  else {
    __int16 v7 = 769;
  }
  __int16 *v5 = v7;
  return 1LL;
}

uint64_t bssl::set_version_bound(_BYTE *a1, _WORD *a2, int a3)
{
  uint64_t v5 = 8LL;
  if (*a1) {
    uint64_t v5 = 4LL;
  }
  uint64_t v6 = (unsigned __int16 *)&bssl::kDTLSVersions;
  if (!*a1) {
    uint64_t v6 = (unsigned __int16 *)&bssl::kTLSVersions;
  }
  uint64_t v7 = v5 - 2;
  do
  {
    int v9 = *v6++;
    int v8 = v9;
    BOOL v10 = v9 == a3 || v7 == 0;
    v7 -= 2LL;
  }

  while (!v10);
  if (v8 == a3)
  {
    *a2 = a3;
    return 1LL;
  }

  else
  {
LABEL_21:
    ERR_put_error(16, 0, 234, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", 133);
    return 0LL;
  }

uint64_t boringssl_context_set_max_version(uint64_t a1, unsigned __int16 a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (SSL_set_max_proto_version(v3, a2))
  {
    uint64_t result = 0LL;
    *(_WORD *)(v2 + 56) = a2;
    return result;
  }

  uint64_t v6 = (id *)(v2 + 16);
  id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  if (WeakRetained)
  {
    int v8 = WeakRetained;
    int v9 = objc_loadWeakRetained(v6);
    char v10 = v9[475];

    if ((v10 & 1) != 0) {
      return 0LL;
    }
  }

  id v11 = objc_loadWeakRetained(v6);
  if (v11)
  {
    uint64_t v12 = objc_loadWeakRetained(v6);
    BOOL v13 = (v12[475] & 1) == 0;
  }

  else
  {
    BOOL v13 = 1;
  }

  uint64_t result = 0LL;
  if (v13 && g_boringssl_log)
  {
    id v14 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      boringssl_context_set_max_version_cold_1(v6, v14);
    }

    return 0LL;
  }

  return result;
}

uint64_t SSL_set_max_proto_version(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v4 = *(_BYTE **)a1;
  uint64_t v5 = (__int16 *)(v2 + 8);
  if (a2) {
    return bssl::set_version_bound(v4, v5, a2);
  }
  if (*v4) {
    __int16 v7 = -259;
  }
  else {
    __int16 v7 = 772;
  }
  __int16 *v5 = v7;
  return 1LL;
}

void SSL_set_msg_callback(SSL *ssl, void (__cdecl *cb)(int, int, int, const void *, size_t, SSL *, void *))
{
  *(void *)&ssl->quiet_shutdown = cb;
}

uint64_t SSL_set_msg_callback_arg(uint64_t result, uint64_t a2)
{
  *(void *)(result + 72) = a2;
  return result;
}

uint64_t SSL_set_cert_cb(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 8);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 32);
    *(void *)(v4 + 64) = a2;
    *(void *)(v4 + 72) = a3;
  }

  return result;
}

void *boringssl_ciphers_copy_default_ciphersuites(unint64_t *a1)
{
  if (os_variant_has_internal_content() && boringssl_config_get_restricted_mode_state())
  {
    __int16 v7 = 0;
    uint64_t v2 = (os_log_s *)g_boringssl_log;
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG)) {
      boringssl_ciphers_copy_default_ciphersuites_cold_1(v2);
    }
    uint64_t v3 = (int *)&v7;
    uint64_t v4 = 1LL;
  }

  else
  {
    int v6 = 0x10000;
    uint64_t v3 = &v6;
    uint64_t v4 = 2LL;
  }

  return boringssl_ciphers_copy_supported_list_for_groups((uint64_t)v3, v4, a1);
}

void *boringssl_ciphers_copy_supported_list_for_groups(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  *a3 = 0LL;
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_ciphers_copy_supported_list_for_groups_cold_1();
    }
    return 0LL;
  }

  int v6 = Mutable;
  if (a2)
  {
    uint64_t v7 = 0LL;
    do
    {
      unint64_t v17 = 0LL;
      uint64_t v8 = sec_protocol_helper_ciphersuite_group_to_ciphersuite_list();
      if (v17)
      {
        uint64_t v9 = v8;
        for (unint64_t i = 0LL; i < v17; ++i)
        {
          *(_WORD *)bytes = -21846;
          *(_WORD *)bytes = *(_WORD *)(v9 + 2 * i);
          CFDataAppendBytes(v6, bytes, 2LL);
        }
      }

      ++v7;
    }

    while (v7 != a2);
  }

  unint64_t Length = CFDataGetLength(v6);
  uint64_t v12 = malloc(Length & 0xFFFFFFFFFFFFFFFELL);
  if (!v12)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_ciphers_copy_supported_list_for_groups_cold_2();
    }
    CFRelease(v6);
    return 0LL;
  }

  BOOL v13 = v12;
  BytePtr = CFDataGetBytePtr(v6);
  memcpy(v13, BytePtr, Length & 0xFFFFFFFFFFFFFFFELL);
  *a3 = Length >> 1;
  CFRelease(v6);
  return v13;
}

uint64_t boringssl_context_set_cipher_suites(uint64_t a1, unsigned __int16 *a2, unsigned int a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a3)
  {
    uint64_t v5 = a2;
    if (a2)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        if (*(void *)(v6 + 408))
        {
          unint64_t v7 = 0LL;
          uint64_t v8 = 2LL * a3;
          uint64_t v9 = a3;
          while (1)
          {
            cipher_by_value = SSL_get_cipher_by_value(v5[v7 / 2]);
            if (cipher_by_value)
            {
              if (SSL_CIPHER_get_auth_nid((uint64_t)cipher_by_value) == 956
                && *(_DWORD *)a1 == -1252936367)
              {
                uint64_t v11 = *(void *)(a1 + 8);
                if (v11)
                {
                  if (*(_WORD *)(v11 + 56) == 772) {
                    break;
                  }
                }
              }
            }

            v7 += 2LL;
            if (v8 == v7) {
              goto LABEL_14;
            }
          }

          boringssl_context_set_max_version(a1, 0x303u);
LABEL_14:
          bzero(v32, 0x400uLL);
          uint64_t v12 = (const char *)boringssl_ciphers_fillout_configuration_string((uint64_t)v5, v9, (uint64_t)v32, 0x400uLL);
          BOOL v13 = *(void **)(v6 + 88);
          if (v13)
          {
            free(v13);
            *(void *)(v6 + 8_Block_object_dispose(va, 8) = 0LL;
          }

          if (v12) {
            configuration_string = strndup(v12, 0x400uLL);
          }
          else {
            configuration_string = boringssl_ciphers_create_configuration_string((uint64_t)v5, v9);
          }
          BOOL v16 = configuration_string;
          *(void *)(v6 + 8_Block_object_dispose(va, 8) = configuration_string;
          if (configuration_string)
          {
            if (*(_DWORD *)a1 != -1252936367) {
              goto LABEL_39;
            }
            uint64_t v17 = *(void *)(a1 + 8);
            if (v17)
            {
              nw_protocol_definition_t v18 = *(ssl_credential_st **)(v17 + 400);
              if (v18)
              {
                if (SSL_set_strict_cipher_list(v18, (uint64_t)v16))
                {
                  uint64_t v4 = 0LL;
LABEL_41:
                  if (*(_DWORD *)a1 == -1252936367 && (uint64_t v28 = *(void *)(a1 + 8)) != 0 && *(_WORD *)(v28 + 56) == 772)
                  {
                    boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 0);
                    boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 0);
                    char v29 = 0;
                    do
                    {
                      int v31 = *v5++;
                      int v30 = v31;
                      if ((v31 - 4865) >= 2)
                      {
                        if (v30 == 4867)
                        {
                          char v29 = 1;
                          boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 1);
                        }
                      }

                      else
                      {
                        char v29 = 1;
                        boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 1);
                      }

                      --v9;
                    }

                    while (v9);
                    if ((v29 & 1) == 0)
                    {
                      boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 1);
                      boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 1);
                    }
                  }

                  else
                  {
                    boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(a1, 0);
                    boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(a1, 0);
                  }

                  return v4;
                }

                int v19 = (id *)(v17 + 16);
                id WeakRetained = objc_loadWeakRetained(v19);
                if (!WeakRetained
                  || (id v21 = WeakRetained,
                      nw_protocol_definition_t v22 = objc_loadWeakRetained(v19),
                      char v23 = v22[475],
                      v22,
                      v21,
                      (v23 & 1) == 0))
                {
                  id v24 = objc_loadWeakRetained(v19);
                  if (v24)
                  {
                    char v25 = objc_loadWeakRetained(v19);
                    BOOL v26 = (v25[475] & 1) == 0;
                  }

                  else
                  {
                    BOOL v26 = 1;
                  }

                  if (v26)
                  {
                    if (g_boringssl_log)
                    {
                      int v27 = (os_log_s *)(id)g_boringssl_log;
                      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                        boringssl_context_set_cipher_suites_cold_1(v19, v27);
                      }
                    }
                  }
                }
              }
            }

            BOOL v16 = *(char **)(v6 + 88);
            if (v16)
            {
LABEL_39:
              free(v16);
              *(void *)(v6 + 8_Block_object_dispose(va, 8) = 0LL;
            }
          }

          uint64_t v4 = 0xFFFFFFFFLL;
          goto LABEL_41;
        }
      }
    }
  }

  return v4;
}

void *SSL_get_cipher_by_value(int a1)
{
  *(void *)&__int128 v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v3 = v1;
  __int128 v4 = v1;
  LODWORD(v4) = a1 | 0x3000000;
  return bsearch( &v3,  bssl::kCiphers,  0x26uLL,  0x28uLL,  (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
}

uint64_t ssl_cipher_id_cmp_void(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2 = a1[4];
  unsigned int v3 = a2[4];
  BOOL v4 = v2 > v3;
  if (v2 >= v3) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = -1;
  }
  if (v4) {
    return 1LL;
  }
  else {
    return v5;
  }
}

uint64_t SSL_CIPHER_get_auth_nid(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if (v1 <= 7)
  {
    if (v1 == 4) {
      return 955LL;
    }
LABEL_11:
    SSL_CIPHER_get_auth_nid_cold_1();
  }

  if (v1 != 8)
  {
    if (v1 == 16) {
      return 958LL;
    }
    goto LABEL_11;
  }

  return 956LL;
}

uint64_t boringssl_ciphers_fillout_configuration_string( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = 0LL;
  if (a1 && a2 && a3 && a4)
  {
    uint64_t v9 = 0LL;
    char v10 = 0;
    size_t v11 = 0LL;
    uint64_t v12 = a2 - 1;
    do
    {
      while (1)
      {
        BOOL v13 = boringssl_ciphers_value_to_string(*(unsigned __int16 *)(a1 + 2 * v9));
        if (!v13) {
          break;
        }
        id v14 = v13;
        if ((v10 & 1) != 0)
        {
          if (v11 + 1 >= a4) {
            return 0LL;
          }
          *(_BYTE *)(a3 + v11++) = 58;
        }

        size_t v15 = strlen(v13);
        size_t v16 = v15 + v11;
        if (v15 + v11 >= a4) {
          return 0LL;
        }
        strncpy((char *)(a3 + v11), v14, v15);
        char v10 = 1;
        size_t v11 = v16;
        if (v12 == v9++) {
          return a3;
        }
      }

      ++v9;
    }

    while (a2 != v9);
    uint64_t result = a3;
    if ((v10 & 1) != 0) {
      return result;
    }
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        boringssl_ciphers_fillout_configuration_string_cold_1();
      }
    }

    return 0LL;
  }

  return result;
}

const char *boringssl_ciphers_value_to_string(int a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    cipher_by_value = (const SSL_CIPHER *)SSL_get_cipher_by_value(a1);
    if (cipher_by_value) {
      return SSL_CIPHER_get_name(cipher_by_value);
    }
    BOOL v4 = (os_log_s *)g_boringssl_log;
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
      {
        int v5 = 136446722;
        uint64_t v6 = "boringssl_ciphers_value_to_string";
        __int16 v7 = 1024;
        int v8 = 31;
        __int16 v9 = 1024;
        int v10 = a1;
        _os_log_impl( &dword_187560000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s(%d) Failed to get boringssl cipher for ciphersuite 0x%04x",  (uint8_t *)&v5,  0x18u);
      }
    }
  }

  return 0LL;
}

const char *__cdecl SSL_CIPHER_get_name(const SSL_CIPHER *c)
{
  int v1 = (const char **)kUnknownCipher;
  if (c) {
    int v1 = (const char **)c;
  }
  return *v1;
}

uint64_t SSL_set_strict_cipher_list(ssl_credential_st *a1, uint64_t a2)
{
  uint64_t v2 = *((void *)a1 + 1);
  if (!v2) {
    return 0LL;
  }
  unsigned int v4 = *(unsigned __int16 *)(v2 + 301);
  if ((v4 & 0x800) != 0)
  {
    int v6 = (v4 >> 12) & 1;
  }

  else
  {
    int v6 = ssl_credential_st::UsesPrivateKey(a1) != 0;
    uint64_t v2 = *((void *)a1 + 1);
  }

  return bssl::ssl_create_cipher_list((bssl::SSLCipherPreferenceList **)(v2 + 24), v6, a2, 1);
}

uint64_t boringssl_context_set_tls13_ciphersuite_aesgcm_enabled(uint64_t result, int a2)
{
  if (*(_DWORD *)result == -1252936367)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      uint64_t result = *(void *)(v2 + 400);
      if (result)
      {
        if (a2) {
          char v3 = 2;
        }
        else {
          char v3 = 0;
        }
        *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xFD | v3;
        return SSL_set_tls13_ciphersuite_aesgcm_enabled(result, a2);
      }
    }
  }

  return result;
}

uint64_t SSL_set_tls13_ciphersuite_aesgcm_enabled(uint64_t result, int a2)
{
  if (a2) {
    char v2 = 2;
  }
  else {
    char v2 = 0;
  }
  *(_BYTE *)(*(void *)(result + 120) + 248LL) = *(_BYTE *)(*(void *)(result + 120) + 248LL) & 0xFD | v2;
  return result;
}

uint64_t boringssl_context_set_tls13_ciphersuite_chacha20poly1305_enabled(uint64_t result, int a2)
{
  if (*(_DWORD *)result == -1252936367)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      uint64_t result = *(void *)(v2 + 400);
      if (result)
      {
        if (a2) {
          char v3 = 4;
        }
        else {
          char v3 = 0;
        }
        *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xFB | v3;
        return SSL_set_tls13_ciphersuite_chacha20poly1305_enabled(result, a2);
      }
    }
  }

  return result;
}

uint64_t SSL_set_tls13_ciphersuite_chacha20poly1305_enabled(uint64_t result, int a2)
{
  if (a2) {
    char v2 = 4;
  }
  else {
    char v2 = 0;
  }
  *(_BYTE *)(*(void *)(result + 120) + 248LL) = *(_BYTE *)(*(void *)(result + 120) + 248LL) & 0xFB | v2;
  return result;
}

int SSL_set_ex_data(SSL *ssl, int idx, void *data)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&ssl->d1, idx, data);
}

int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
{
  if (idx < 0) {
    abort();
  }
  sk = (EVP_MD_CTX *)ad->sk;
  if (sk || (sk = (EVP_MD_CTX *)OPENSSL_sk_new_null(), (ad->sk = (STACK *)sk) != 0LL))
  {
    __int16 v7 = EVP_MD_CTX_md(sk);
    unint64_t v8 = idx;
    if ((unint64_t)v7 > idx)
    {
LABEL_8:
      OPENSSL_sk_set((unint64_t *)ad->sk, v8, (uint64_t)val);
      LODWORD(sk) = 1;
    }

    else
    {
      uint64_t v9 = idx - (void)v7 + 1LL;
      while (1)
      {
        sk = (EVP_MD_CTX *)OPENSSL_sk_push((unint64_t *)ad->sk, 0LL);
        if (!sk) {
          break;
        }
        if (!--v9) {
          goto LABEL_8;
        }
      }
    }
  }

  return (int)sk;
}

uint64_t boringssl_session_set_bio(uint64_t result, BIO *a2, BIO *a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(_DWORD *)result != -1252936367) {
      return 0LL;
    }
    uint64_t result = 0LL;
    if (a3)
    {
      if (a2)
      {
        uint64_t v6 = *(void *)(v3 + 8);
        if (v6)
        {
          if (*(void *)(v6 + 400))
          {
            BIO_up_ref((uint64_t)a2);
            SSL_set_bio(*(SSL **)(v6 + 400), a2, a3);
            return 1LL;
          }

          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t BIO_up_ref(uint64_t a1)
{
  return 1LL;
}

void SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio)
{
  p_wbio = &s->wbio;
  __int16 v7 = s->wbio;
  if (*(_OWORD *)&s->wbio != __PAIR128__((unint64_t)wbio, (unint64_t)rbio))
  {
    if (rbio && rbio == wbio)
    {
      BIO_up_ref((uint64_t)rbio);
      __int16 v7 = *p_wbio;
    }

    p_bbio = &s->bbio;
    if (v7 == rbio
      || ((uint64_t v9 = *p_bbio, std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](p_wbio, rbio), v9 == wbio)
        ? (BOOL v10 = v7 == v9)
        : (BOOL v10 = 1),
          v10))
    {
      std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](p_bbio, wbio);
    }
  }

void *boringssl_context_set_remote_address(void *result, unsigned __int8 *a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      if (a2)
      {
        uint64_t v2 = result[1];
        if (v2)
        {
          int v3 = a2[1];
          if (v3 == 30 || v3 == 2) {
            return memcpy((void *)(v2 + 224), a2, *a2);
          }
        }
      }
    }
  }

  return result;
}

void *nw_protocol_boringssl_get_subject_name(void *a1, void *a2)
{
  int v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3 && v4)
  {
    uint64_t v6 = (void *)nw_endpoint_copy_proxy_original_endpoint();
    __int16 v7 = v6;
    if (v6)
    {
      id v8 = v6;

      id v5 = v8;
    }

    char v16 = 0;
    endpoint_name = (void *)nw_protocol_boringssl_get_endpoint_name(v5, &v16);
    id v5 = v5;
    uint64_t v10 = nw_endpoint_copy_parent_endpoint();
    id v11 = v5;
    if (v10)
    {
      uint64_t v12 = (void *)v10;
      BOOL v13 = v5;
      do
      {
        id v11 = v12;

        uint64_t v12 = (void *)nw_endpoint_copy_parent_endpoint();
        BOOL v13 = v11;
      }

      while (v12);
    }

    if (nw_endpoint_get_type((nw_endpoint_t)v11) == 5)
    {
      char v16 = 0;
      endpoint_name = (void *)nw_protocol_boringssl_get_endpoint_name(v11, &v16);
    }

    if (v16)
    {
      id v14 = (void *)v3[44];
      if (v14) {
        free(v14);
      }
      v3[44] = endpoint_name;
    }
  }

  else
  {
    endpoint_name = 0LL;
  }

  return endpoint_name;
}

uint64_t nw_protocol_boringssl_get_endpoint_name(void *a1, _BYTE *a2)
{
  int v3 = a1;
  if (nw_endpoint_get_type(v3) == nw_endpoint_type_host)
  {
    uint64_t hostname = (uint64_t)nw_endpoint_get_hostname(v3);
LABEL_10:
    uint64_t parent_endpoint_domain = hostname;
    goto LABEL_11;
  }

  if (nw_endpoint_get_type(v3) != nw_endpoint_type_address)
  {
    if (nw_endpoint_get_type(v3) == nw_endpoint_type_bonjour_service)
    {
      uint64_t hostname = nw_endpoint_get_bonjour_fullname();
    }

    else
    {
      if (nw_endpoint_get_type(v3) != 5)
      {
        uint64_t parent_endpoint_domain = 0LL;
        goto LABEL_11;
      }

      uint64_t hostname = nw_endpoint_get_srv_name();
    }

    goto LABEL_10;
  }

  uint64_t parent_endpoint_domain = nw_endpoint_get_parent_endpoint_domain();
  if (!parent_endpoint_domain)
  {
    uint64_t parent_endpoint_domain = (uint64_t)nw_endpoint_copy_address_string(v3);
    *a2 = 1;
  }

LABEL_11:
  return parent_endpoint_domain;
}

          *a4 = v18;
          goto LABEL_12;
        }

        return 0LL;
      }
    }

    *a5 = 1;
    goto LABEL_42;
  }

  return result;
}

  return Mutable;
}

  if (a4) {
    bzero(a2, a4);
  }
  id v14 = 0LL;
  uint64_t result = 0LL;
LABEL_14:
  *a3 = v14;
  return result;
}

  DSA_free(v6);
  return 0LL;
}

    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v16);
    uint64_t result = 0LL;
    id v11 = 50;
    goto LABEL_12;
  }

  id v8 = 267;
  uint64_t v9 = 2016;
LABEL_3:
  ERR_put_error(16, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v9);
  uint64_t result = 0LL;
  id v11 = 47;
LABEL_12:
  *a5 = v11;
  return result;
}

  return v14;
}

uint64_t boringssl_session_set_peer_hostname(uint64_t a1, char *__s1, size_t __n)
{
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  if (__n - 256 < 0xFFFFFFFFFFFFFF01LL) {
    return v4;
  }
  if (!__s1) {
    return v4;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (!v6) {
    return v4;
  }
  uint64_t v4 = *(void *)(v6 + 400);
  if (!v4) {
    return v4;
  }
  __int16 v7 = *(void **)(v6 + 80);
  if (v7)
  {
    free(v7);
    *(void *)(v6 + 80) = 0LL;
  }

  *(void *)(v6 + 80) = strndup(__s1, __n);
  if (!*(void *)(v6 + 80)) {
    return 0LL;
  }
  int is_valid_sni_value = boringssl_helper_is_valid_sni_value((uint64_t)__s1, __n);
  if ((is_valid_sni_value & 1) != 0)
  {
    if (!SSL_set_tlsext_host_name(v4, __s1))
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
      if (!WeakRetained
        || (uint64_t v10 = WeakRetained,
            id v11 = objc_loadWeakRetained((id *)(v6 + 16)),
            char v12 = v11[475],
            v11,
            v10,
            (v12 & 1) == 0))
      {
        id v13 = objc_loadWeakRetained((id *)(v6 + 16));
        if (v13)
        {
          id v14 = objc_loadWeakRetained((id *)(v6 + 16));
          BOOL v15 = (v14[475] & 1) == 0;
        }

        else
        {
          BOOL v15 = 1;
        }

        uint64_t v4 = 0LL;
        if (v15 && g_boringssl_log)
        {
          id v24 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            boringssl_session_set_peer_hostname_cold_1(v6, v24);
          }
LABEL_33:
          uint64_t v4 = is_valid_sni_value ^ 1u;

          return v4;
        }

        return v4;
      }

      return 0LL;
    }

    return 1LL;
  }

  id v17 = objc_loadWeakRetained((id *)(v6 + 16));
  if (v17)
  {
    nw_protocol_definition_t v18 = v17;
    int v19 = objc_loadWeakRetained((id *)(v6 + 16));
    char v20 = v19[475];

    if ((v20 & 1) != 0) {
      return 1LL;
    }
  }

  id v21 = objc_loadWeakRetained((id *)(v6 + 16));
  if (v21)
  {
    nw_protocol_definition_t v22 = objc_loadWeakRetained((id *)(v6 + 16));
    BOOL v23 = (v22[475] & 1) == 0;
  }

  else
  {
    BOOL v23 = 1;
  }

  uint64_t v4 = 1LL;
  if (v23 && g_boringssl_log)
  {
    id v24 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
      boringssl_session_set_peer_hostname_cold_2(v6, v24);
    }
    goto LABEL_33;
  }

  return v4;
}

uint64_t boringssl_helper_is_valid_sni_value(uint64_t a1, uint64_t a2)
{
  uint64_t IsDNSName = 0LL;
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a1 && (unint64_t)(a2 - 1) <= 0xFE)
  {
    memset(v8, 0, sizeof(v8));
    __memcpy_chk();
    uint64_t v4 = 0LL;
    while (*((_BYTE *)v8 + v4) && *((_BYTE *)v8 + v4) != 42)
    {
      if (a2 == ++v4)
      {
        CFStringRef v5 = CFStringCreateWithCString(0LL, (const char *)v8, 0x8000100u);
        if (v5)
        {
          CFStringRef v6 = v5;
          uint64_t IsDNSName = SecFrameworkIsDNSName();
          CFRelease(v6);
          return IsDNSName;
        }

        return 0LL;
      }
    }

    return 0LL;
  }

  return IsDNSName;
}

BOOL SSL_set_tlsext_host_name(uint64_t a1, const char *a2)
{
  int v3 = (void **)(a1 + 160);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((void **)(a1 + 160), 0LL);
  if (!a2) {
    return 1LL;
  }
  if (strlen(a2) - 256 > 0xFFFFFFFFFFFFFF00LL)
  {
    CFStringRef v5 = (char *)OPENSSL_strdup(a2);
    std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v3, v5);
    return *v3 != 0LL;
  }

  else
  {
    ERR_put_error(16, 0, 213, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 2560);
    return 0LL;
  }

const char *OPENSSL_strdup(const char *result)
{
  if (result)
  {
    int v1 = result;
    unint64_t v2 = strlen(result) + 1;
    return (const char *)OPENSSL_memdup(v1, v2);
  }

  return result;
}

void *boringssl_context_set_enable_message_mode(void *a1, int a2)
{
  if (a1)
  {
    if (*(_DWORD *)a1 != -1252936367) {
      goto LABEL_8;
    }
    uint64_t v2 = a1[1];
    if (!v2 || a2 == 0) {
      goto LABEL_8;
    }
    if (SSL_set_quic_method(*(void *)(v2 + 400), (uint64_t)boringssl_quic_method))
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 3221225472LL;
      v15[2] = __boringssl_context_set_enable_message_mode_block_invoke;
      v15[3] = &__block_descriptor_40_e15_B28__0i8r_12Q20lu32l8;
      v15[4] = v2;
      a1 = (void *)MEMORY[0x1895A97C0](v15);
      return a1;
    }

    CFStringRef v6 = (id *)(v2 + 16);
    id WeakRetained = objc_loadWeakRetained(v6);
    if (WeakRetained)
    {
      id v8 = WeakRetained;
      uint64_t v9 = objc_loadWeakRetained(v6);
      char v10 = v9[475];

      if ((v10 & 1) != 0) {
        goto LABEL_8;
      }
    }

    id v11 = objc_loadWeakRetained(v6);
    if (v11)
    {
      char v12 = objc_loadWeakRetained(v6);
      BOOL v13 = (v12[475] & 1) == 0;
    }

    else
    {
      BOOL v13 = 1;
    }

    a1 = 0LL;
    if (v13 && g_boringssl_log)
    {
      id v14 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        boringssl_context_set_enable_message_mode_cold_1(v6, v14);
      }

LABEL_8:
      a1 = 0LL;
    }
  }

  return a1;
}

uint64_t boringssl_session_apply_protocol_options_for_transport(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1 && *(_DWORD *)a1 == -1252936367 && (uint64_t v5 = *(void *)(a1 + 8)) != 0)
  {
    objc_storeStrong((id *)(v5 + 512), a2);
    id v8 = v4;
    uint64_t v6 = nw_protocol_options_access_handle();
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

unsigned __int16 *__boringssl_session_apply_protocol_options_for_transport_block_invoke( uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v253 = *MEMORY[0x1895F89C0];
  id v4 = (sec_protocol_options *)*(id *)(a1 + 32);
  if (!a2) {
    goto LABEL_279;
  }
  if (a2[1]) {
    boringssl_context_set_max_version(*(void *)(a1 + 40), a2[1]);
  }
  if (*a2) {
    boringssl_context_set_min_version(*(void *)(a1 + 40), *a2);
  }
  uint64_t v5 = (unsigned int *)((char *)a2 + 361);
  boringssl_context_set_fallback(*(void *)(a1 + 40), (*(_DWORD *)((char *)a2 + 361) >> 7) & 1);
  uint64_t v6 = *(void *)(a1 + 40);
  if ((*(_DWORD *)((_BYTE *)a2 + 361) & 0x2000) != 0)
  {
    int sct_enabled = 1;
  }

  else if ((*(_DWORD *)((_BYTE *)a2 + 361) & 0x4000) != 0)
  {
    int sct_enabled = 0;
  }

  else
  {
    int sct_enabled = boringssl_config_get_sct_enabled();
  }

  boringssl_context_set_sct_enable(v6, sct_enabled);
  uint64_t v8 = *(void *)(a1 + 40);
  if ((*v5 & 0x8000) != 0)
  {
    int ocsp_enabled = 1;
  }

  else if ((*v5 & 0x10000) != 0)
  {
    int ocsp_enabled = 0;
  }

  else
  {
    int ocsp_enabled = boringssl_config_get_ocsp_enabled();
  }

  boringssl_context_set_ocsp_enable(v8, ocsp_enabled);
  uint64_t v10 = *(void *)(a1 + 40);
  if ((*v5 & 0x200000) != 0)
  {
    int renegotiation_enabled = 1;
  }

  else if ((*v5 & 0x400000) != 0)
  {
    int renegotiation_enabled = 0;
  }

  else
  {
    int renegotiation_enabled = boringssl_config_get_renegotiation_enabled();
  }

  boringssl_context_set_renegotiation(v10, renegotiation_enabled);
  uint64_t v12 = *(void *)(a1 + 40);
  if ((*v5 & 0x80000) != 0)
  {
    char resumption_enabled = 1;
  }

  else if ((*v5 & 0x100000) != 0)
  {
    char resumption_enabled = 0;
  }

  else
  {
    char resumption_enabled = boringssl_config_get_resumption_enabled();
  }

  boringssl_context_set_resumption(v12, resumption_enabled);
  uint64_t v14 = *(void *)(a1 + 40);
  if ((*v5 & 0x800) != 0)
  {
    int tickets_enabled = 1;
  }

  else if ((*v5 & 0x100000) != 0)
  {
    int tickets_enabled = 0;
  }

  else
  {
    int tickets_enabled = boringssl_config_get_tickets_enabled();
  }

  boringssl_context_set_session_ticket_enabled(v14, tickets_enabled);
  uint64_t v16 = *(void *)(a1 + 40);
  if ((*v5 & 0x200) != 0)
  {
    int false_start_enabled = 1;
  }

  else if ((*v5 & 0x400) != 0)
  {
    int false_start_enabled = 0;
  }

  else
  {
    int false_start_enabled = boringssl_config_get_false_start_enabled();
  }

  boringssl_context_set_false_start(v16, false_start_enabled);
  boringssl_session_set_early_data_enabled(*(void *)(a1 + 40), (*v5 >> 23) & 1);
  uint64_t v18 = *v5;
  unint64_t v19 = v18 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
  if ((v18 & 0x800000) != 0 && (*(_BYTE *)(*(void *)(a1 + 48) + 556LL) & 0x10) != 0 && *(_DWORD *)(a1 + 56) == 2)
  {
    boringssl_session_set_quic_early_data_context(*(void *)(a1 + 40), *((const char **)a2 + 42), *((void *)a2 + 44));
    unint64_t v19 = *v5 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
  }

  boringssl_context_set_enforce_ev(*(void *)(a1 + 40), (v19 >> 17) & 1);
  boringssl_context_set_ats_enforced(*(void *)(a1 + 40), *v5 & 1);
  boringssl_context_set_ats_minimum_rsa_key_size(*(void *)(a1 + 40), *((void *)a2 + 38));
  boringssl_context_set_ats_minimum_ecdsa_key_size(*(void *)(a1 + 40), *((void *)a2 + 39));
  boringssl_context_set_ats_minimum_signature_algorithm(*(void *)(a1 + 40), *((_DWORD *)a2 + 80));
  options = v4;
  if (*(_WORD *)(*(void *)(a1 + 48) + 56LL) == 772)
  {
    int v21 = ssl_credential_st::UsesPrivateKey(v20);
    if ((*v5 & 0x40000000) != 0) {
      int v22 = ((*(unsigned int *)((char *)a2 + 361) | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32)) >> 29) & 1;
    }
    else {
      int v22 = v21;
    }
    BOOL v23 = (ssl_credential_st *)boringssl_context_set_certificate_compression(*(void *)(a1 + 40), v22);
    uint64_t v24 = *(void *)(a1 + 40);
    else {
      int v25 = ssl_credential_st::UsesPrivateKey(v23);
    }
    boringssl_context_set_GREASE_enabled(v24, v25);
    BOOL enable_encrypted_client_hello = sec_protocol_options_get_enable_encrypted_client_hello(v4);
    uint64_t v27 = *(void *)(a1 + 48);
    if (!v27) {
      goto LABEL_56;
    }
    id WeakRetained = objc_loadWeakRetained((id *)(v27 + 16));
    if (!WeakRetained
      || (char v29 = WeakRetained,
          int v30 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL)),
          char v31 = v30[475],
          v30,
          v29,
          (v31 & 1) == 0))
    {
      uint64_t v32 = *(void *)(a1 + 48);
      if (!v32) {
        goto LABEL_56;
      }
      id v33 = objc_loadWeakRetained((id *)(v32 + 16));
      if (v33)
      {
        BOOL v34 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
        BOOL v35 = (v34[475] & 1) == 0;
      }

      else
      {
        BOOL v35 = 1;
      }

      if (v35)
      {
LABEL_56:
        if (g_boringssl_log)
        {
          id v36 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v113 = *(void *)(a1 + 48);
            if (v113)
            {
              v133 = (char *)objc_loadWeakRetained((id *)(v113 + 16));
              uint64_t v134 = *(void *)(a1 + 48);
              v215 = v133;
              if (v133)
              {
                BOOL v222 = v134 != 0;
                if (v134)
                {
                  v133 = (char *)objc_loadWeakRetained((id *)(v134 + 16));
                  uint64_t v134 = *(void *)(a1 + 48);
                }

                else
                {
                  v133 = 0LL;
                }

                v116 = v133 + 391;
              }

              else
              {
                BOOL v222 = 0;
                v116 = &unk_1875F4C23;
              }

              v213 = v133;
              if (v134)
              {
                id v114 = objc_loadWeakRetained((id *)(v134 + 16));
                char v115 = 0;
              }

              else
              {
                id v114 = 0LL;
                char v115 = 1;
              }
            }

            else
            {
              BOOL v222 = 0;
              id v114 = 0LL;
              char v115 = 1;
              v116 = &unk_1875F4C23;
            }

            v230 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
            __int16 v231 = 1024;
            v209 = "disabled";
            int v232 = 1787;
            __int16 v233 = 2082;
            *(_DWORD *)buf = 136447234;
            if (enable_encrypted_client_hello) {
              v209 = "enabled";
            }
            v234 = v116;
            __int16 v235 = 2048;
            id v236 = v114;
            __int16 v237 = 2080;
            *(void *)v238 = v209;
            _os_log_debug_impl( &dword_187560000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] ECH is %s",  buf,  0x30u);
            if ((v115 & 1) == 0) {

            }
            if (v222) {
            if (v113)
            }
          }
        }
      }
    }

    boringssl_context_set_ech_grease_enabled(*(void *)(a1 + 40), enable_encrypted_client_hello);
  }

  uint64_t v251 = 0LL;
  uint64_t v252 = 0LL;
  __int16 v37 = (const unsigned __int8 *)(a2 + 12);
  int v38 = (unsigned __int8 *)(*(void *)(a1 + 48) + 252LL);
  if (*(_OWORD *)(a2 + 12) == 0LL) {
    MEMORY[0x1895A9AA8](v38, v37);
  }
  else {
    uuid_copy(v38, v37);
  }
  __int16 v39 = (char *)*((void *)a2 + 2);
  if (v39) {
    int v40 = boringssl_context_set_experiment_identifier(*(void *)(a1 + 40), v39);
  }
  else {
    int v40 = 1;
  }
  if (*((void *)a2 + 30) && *((void *)a2 + 31))
  {
    uint64_t v41 = MEMORY[0x1895A97C0]();
    uint64_t v42 = *(void *)(a1 + 48);
    uint64_t v43 = *(void **)(v42 + 216);
    *(void *)(v42 + 216) = v41;

    objc_storeStrong((id *)(*(void *)(a1 + 48) + 208LL), *((id *)a2 + 31));
  }

  unsigned int v44 = *v5;
  if ((*v5 & 0x10000000) != 0)
  {
    if ((v44 & 0x4000000) != 0) {
      int v46 = 3;
    }
    else {
      int v46 = (v44 >> 27) & ((*(_BYTE *)(*(void *)(a1 + 48) + 556LL) & 0x10) >> 4);
    }
    uint64_t v45 = *(void *)(a1 + 40);
  }

  else
  {
    uint64_t v45 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(*(void *)(a1 + 48) + 556LL) & 0x10) != 0) {
      int v46 = 0;
    }
    else {
      int v46 = 3;
    }
  }

  boringssl_context_set_verify_mode(v45, v46);
  uint64_t v47 = (char *)*((void *)a2 + 1);
  if (v47)
  {
    size_t v48 = strlen(*((const char **)a2 + 1));
    boringssl_session_set_peer_hostname(*(void *)(a1 + 40), v47, v48);
  }

  if ((*v5 & 0x20) != 0)
  {
    uint64_t v49 = *(void *)(a1 + 40);
    if (v49)
    {
      if (*(_DWORD *)v49 == -1252936367)
      {
        uint64_t v50 = *(void *)(v49 + 8);
        if (v50)
        {
          uint64_t v51 = *(void *)(v50 + 400);
          if (v51)
          {
            if (!SSL_set_tlsext_host_name(v51, 0LL))
            {
              id v71 = objc_loadWeakRetained((id *)(v50 + 16));
              if (!v71
                || (uint64_t v72 = v71,
                    v73 = objc_loadWeakRetained((id *)(v50 + 16)),
                    char v74 = v73[475],
                    v73,
                    v72,
                    (v74 & 1) == 0))
              {
                id v75 = objc_loadWeakRetained((id *)(v50 + 16));
                if (v75)
                {
                  v76 = objc_loadWeakRetained((id *)(v50 + 16));
                  BOOL v77 = (v76[475] & 1) == 0;
                }

                else
                {
                  BOOL v77 = 1;
                }

                if (v77)
                {
                  if (g_boringssl_log)
                  {
                    v135 = (os_log_s *)(id)g_boringssl_log;
                    if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR)) {
                      __boringssl_session_apply_protocol_options_for_transport_block_invoke_cold_1(v50, v135);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  __int16 v52 = (void *)*((void *)a2 + 24);
  if (v52)
  {
    v53 = boringssl_session_state_create_from_dispatch_data(*(void **)(a1 + 48), v52);
    int v54 = boringssl_session_set_session_state(*(void *)(a1 + 40), v53);
    uint64_t v55 = *(void *)(a1 + 48);
    if (!v55) {
      goto LABEL_95;
    }
    id v56 = objc_loadWeakRetained((id *)(v55 + 16));
    if (!v56
      || (uint64_t v57 = v56,
          v58 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL)),
          char v59 = v58[475],
          v58,
          v57,
          (v59 & 1) == 0))
    {
      uint64_t v60 = *(void *)(a1 + 48);
      if (!v60) {
        goto LABEL_95;
      }
      id v61 = objc_loadWeakRetained((id *)(v60 + 16));
      if (v61)
      {
        v62 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
        BOOL v63 = (v62[475] & 1) == 0;
      }

      else
      {
        BOOL v63 = 1;
      }

      if (v63)
      {
LABEL_95:
        if (g_boringssl_log)
        {
          uint64_t v64 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
          {
            uint64_t v65 = *(void *)(a1 + 48);
            uint64_t v221 = v65;
            if (v65)
            {
              uint64_t v66 = (char *)objc_loadWeakRetained((id *)(v65 + 16));
              uint64_t v67 = *(void *)(a1 + 48);
              v213 = v66;
              if (v66)
              {
                BOOL v216 = v67 != 0;
                if (v67)
                {
                  uint64_t v66 = (char *)objc_loadWeakRetained((id *)(v67 + 16));
                  uint64_t v67 = *(void *)(a1 + 48);
                }

                else
                {
                  uint64_t v66 = 0LL;
                }

                v70 = v66 + 391;
              }

              else
              {
                BOOL v216 = 0;
                v70 = &unk_1875F4C23;
              }

              v211 = v66;
              if (v67)
              {
                id v68 = objc_loadWeakRetained((id *)(v67 + 16));
                char v69 = 0;
              }

              else
              {
                id v68 = 0LL;
                char v69 = 1;
              }
            }

            else
            {
              BOOL v216 = 0;
              id v68 = 0LL;
              char v69 = 1;
              v70 = &unk_1875F4C23;
            }

            v230 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
            __int16 v231 = 1024;
            uint64_t v78 = "not set";
            int v232 = 1836;
            *(_DWORD *)buf = 136447234;
            __int16 v233 = 2082;
            if (v54) {
              uint64_t v78 = "set";
            }
            v234 = v70;
            __int16 v235 = 2048;
            id v236 = v68;
            __int16 v237 = 2082;
            *(void *)v238 = v78;
            _os_log_impl( &dword_187560000,  v64,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Session state %{public}s.",  buf,  0x30u);
            if ((v69 & 1) == 0) {

            }
            if (v216) {
            if (v221)
            }
          }
        }
      }
    }
  }

  id v79 = *((id *)a2 + 6);
  if (v79) {
    boringssl_context_set_alpn_protocol_list(*(void *)(a1 + 40), v79, *(_DWORD *)(a1 + 56));
  }
  unint64_t v80 = *v5 | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
  if ((v80 & 0x800000000LL) != 0) {
    boringssl_context_set_allow_unknown_alpn_protos(*(void *)(a1 + 40), (v80 >> 34) & 1);
  }
  v81 = (const __CFArray *)*((void *)a2 + 35);
  v82 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (v81)
  {
    *(void *)(*(void *)(a1 + 48) + 368LL) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v81);
    v40 &= boringssl_context_set_raw_public_key_certificate( *(_DWORD **)(a1 + 40),  *((CFArrayRef *)a2 + 35),  1);
  }

  v83 = (const __CFArray *)*((void *)a2 + 36);
  if (v83)
  {
    *(void *)(*(void *)(a1 + 48) + 376LL) = CFArrayCreateCopy(*v82, v83);
    v40 &= boringssl_context_set_raw_public_key_certificate( *(_DWORD **)(a1 + 40),  *((CFArrayRef *)a2 + 36),  0);
  }

  v84 = (void *)*((void *)a2 + 7);
  if (v84) {
    v40 &= boringssl_context_set_identity(*(void *)(a1 + 40), v84);
  }
  v85 = (void *)*((void *)a2 + 8);
  if (v85)
  {
    v86 = (void *)*((void *)a2 + 27);
    if (v86)
    {
      v87 = (void *)*((void *)a2 + 25);
      if (v87)
      {
        v88 = (void *)*((void *)a2 + 26);
        if (v88) {
          v40 &= boringssl_context_set_external_identity(*(void *)(a1 + 40), v85, v87, v88, v86);
        }
      }
    }
  }

  xpc_object_t v89 = xpc_array_create(0LL, 0LL);
  v90 = (void *)*((void *)a2 + 9);
  if (v90)
  {
    id v91 = v90;
    v92 = boringssl_psk_cache_create_with_context(*(void **)(a1 + 48));
    uint64_t v93 = *(void *)(a1 + 48);
    v94 = *(void **)(v93 + 40);
    *(void *)(v93 + 40) = v92;

    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __boringssl_session_apply_protocol_options_for_transport_block_invoke_12;
    applier[3] = &__block_descriptor_40_e36_B24__0Q8__NSObject_OS_xpc_object__16lu32l8;
    applier[4] = *(void *)(a1 + 48);
    xpc_array_apply(v91, applier);
    if (!xpc_array_get_count(v91))
    {
LABEL_216:
      uint64_t v142 = *((void *)a2 + 32);
      if (v142)
      {
        v143 = (void *)*((void *)a2 + 33);
        if (v143) {
          boringssl_psk_cache_set_selection_block_and_queue(*(void **)(*(void *)(a1 + 48) + 40LL), v142, v143);
        }
      }

      goto LABEL_220;
    }

    if (boringssl_context_get_min_protocol_version(*(void *)(a1 + 40)) == 772)
    {
      int tls13_external_psk_enabled = boringssl_config_get_tls13_external_psk_enabled();
      uint64_t v96 = *(void *)(a1 + 48);
      if (tls13_external_psk_enabled)
      {
        if (!v96) {
          goto LABEL_159;
        }
        id v97 = objc_loadWeakRetained((id *)(v96 + 16));
        if (!v97
          || (v98 = v97,
              v99 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL)),
              char v100 = v99[475],
              v99,
              v98,
              (v100 & 1) == 0))
        {
          uint64_t v101 = *(void *)(a1 + 48);
          if (!v101) {
            goto LABEL_159;
          }
          id v102 = objc_loadWeakRetained((id *)(v101 + 16));
          if (v102)
          {
            v103 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
            BOOL v104 = (v103[475] & 1) == 0;
          }

          else
          {
            BOOL v104 = 1;
          }

          if (v104)
          {
LABEL_159:
            if (g_boringssl_log)
            {
              v117 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v117, OS_LOG_TYPE_INFO))
              {
                id v223 = v79;
                uint64_t v118 = *(void *)(a1 + 48);
                if (v118)
                {
                  uint64_t v119 = *(void *)(a1 + 48);
                  v120 = (char *)objc_loadWeakRetained((id *)(v118 + 16));
                  uint64_t v121 = *(void *)(a1 + 48);
                  v213 = v120;
                  if (v120)
                  {
                    BOOL v217 = v121 != 0;
                    if (v121)
                    {
                      v120 = (char *)objc_loadWeakRetained((id *)(v121 + 16));
                      uint64_t v121 = *(void *)(a1 + 48);
                    }

                    else
                    {
                      v120 = 0LL;
                    }

                    v129 = v120 + 391;
                  }

                  else
                  {
                    BOOL v217 = 0;
                    v129 = &unk_1875F4C23;
                  }

                  v211 = v120;
                  if (v121)
                  {
                    v136 = v129;
                    id v137 = objc_loadWeakRetained((id *)(v121 + 16));
                    v129 = v136;
                    v127 = v137;
                    char v128 = 0;
                  }

                  else
                  {
                    v127 = 0LL;
                    char v128 = 1;
                  }
                }

                else
                {
                  uint64_t v119 = 0LL;
                  BOOL v217 = 0;
                  v127 = 0LL;
                  char v128 = 1;
                  v129 = &unk_1875F4C23;
                }

                *(_DWORD *)buf = 136446978;
                v230 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
                __int16 v231 = 1024;
                int v232 = 1923;
                __int16 v233 = 2082;
                v234 = v129;
                __int16 v235 = 2048;
                id v236 = v127;
                _os_log_impl( &dword_187560000,  v117,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Using TLS 1.3 external PSK callback",  buf,  0x26u);
                if ((v128 & 1) == 0) {

                }
                if (v217) {
                id v79 = v223;
                }
                if (v119) {
              }
                }
            }
          }
        }

        SSL_set_psk_client13_ext_callback( *(void *)(*(void *)(a1 + 48) + 400LL),  (uint64_t)boringssl_session_psk_client13_ext_callback_handler);
        goto LABEL_214;
      }

      if (!v96) {
        goto LABEL_167;
      }
      id v105 = objc_loadWeakRetained((id *)(v96 + 16));
      if (!v105
        || (v106 = v105,
            v107 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL)),
            char v108 = v107[475],
            v107,
            v106,
            (v108 & 1) == 0))
      {
        uint64_t v109 = *(void *)(a1 + 48);
        if (!v109) {
          goto LABEL_167;
        }
        id v110 = objc_loadWeakRetained((id *)(v109 + 16));
        if (v110)
        {
          v111 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
          BOOL v112 = (v111[475] & 1) == 0;
        }

        else
        {
          BOOL v112 = 1;
        }

        if (v112)
        {
LABEL_167:
          if (g_boringssl_log)
          {
            v122 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_INFO))
            {
              id v224 = v79;
              uint64_t v123 = *(void *)(a1 + 48);
              if (v123)
              {
                uint64_t v124 = *(void *)(a1 + 48);
                v125 = (char *)objc_loadWeakRetained((id *)(v123 + 16));
                uint64_t v126 = *(void *)(a1 + 48);
                v213 = v125;
                if (v125)
                {
                  BOOL v218 = v126 != 0;
                  if (v126)
                  {
                    v125 = (char *)objc_loadWeakRetained((id *)(v126 + 16));
                    uint64_t v126 = *(void *)(a1 + 48);
                  }

                  else
                  {
                    v125 = 0LL;
                  }

                  v132 = v125 + 391;
                }

                else
                {
                  BOOL v218 = 0;
                  v132 = &unk_1875F4C23;
                }

                v211 = v125;
                if (v126)
                {
                  v138 = v132;
                  id v139 = objc_loadWeakRetained((id *)(v126 + 16));
                  v132 = v138;
                  v130 = v139;
                  char v131 = 0;
                }

                else
                {
                  v130 = 0LL;
                  char v131 = 1;
                }
              }

              else
              {
                uint64_t v124 = 0LL;
                BOOL v218 = 0;
                v130 = 0LL;
                char v131 = 1;
                v132 = &unk_1875F4C23;
              }

              *(_DWORD *)buf = 136446978;
              v230 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
              __int16 v231 = 1024;
              int v232 = 1927;
              __int16 v233 = 2082;
              v234 = v132;
              __int16 v235 = 2048;
              id v236 = v130;
              _os_log_impl( &dword_187560000,  v122,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] TLS 1.3 external PSK callback is not enabled",  buf,  0x26u);
              if ((v131 & 1) == 0) {

              }
              if (v218) {
              id v79 = v224;
              }
              if (v124) {
            }
              }
          }
        }
      }
    }

    SSL_set_psk_server_callback( *(void *)(*(void *)(a1 + 48) + 400LL),  (uint64_t)boringssl_session_server_psk_callback_handler);
    SSL_set_psk_client_callback( *(void *)(*(void *)(a1 + 48) + 400LL),  (uint64_t)boringssl_session_client_psk_callback_handler);
    for (uint64_t i = 0LL; i != 4; ++i)
      xpc_array_set_uint64( v89,  0xFFFFFFFFFFFFFFFFLL,  (unsigned __int16)g_boringssl_private_key_methods_block_invoke_supported_psk_ciphersuites[i]);
LABEL_214:
    uint64_t v141 = *(void *)(*(void *)(a1 + 48) + 400LL);
    if (v141) {
      SSL_set_options(v141, 0x400000u);
    }
    goto LABEL_216;
  }

LABEL_220:
  v144 = (dispatch_data_s *)*((void *)a2 + 10);
  if (v144)
  {
    size_t size = dispatch_data_get_size(*((dispatch_data_t *)a2 + 10));
    v146 = malloc(size + 1);
    bzero(v146, size + 1);
    uint64_t v147 = boringssl_helper_dispatch_data_copyout(v144, (uint64_t)v146, size);
    uint64_t v148 = *(void *)(a1 + 48);
    if (v147 == size)
    {
      SSL_use_psk_identity_hint(*(void *)(v148 + 400), (char *)v146);
    }

    else
    {
      if (!v148) {
        goto LABEL_232;
      }
      id v149 = objc_loadWeakRetained((id *)(v148 + 16));
      if (!v149
        || (v150 = v149,
            v151 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL)),
            char v152 = v151[475],
            v151,
            v150,
            (v152 & 1) == 0))
      {
        uint64_t v153 = *(void *)(a1 + 48);
        if (!v153) {
          goto LABEL_232;
        }
        id v154 = objc_loadWeakRetained((id *)(v153 + 16));
        if (v154)
        {
          v155 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
          BOOL v156 = (v155[475] & 1) == 0;
        }

        else
        {
          BOOL v156 = 1;
        }

        if (v156)
        {
LABEL_232:
          if (g_boringssl_log)
          {
            v157 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
            {
              id v226 = v79;
              uint64_t v203 = *(void *)(a1 + 48);
              if (v203)
              {
                v207 = (char *)objc_loadWeakRetained((id *)(v203 + 16));
                uint64_t v208 = *(void *)(a1 + 48);
                v213 = v207;
                if (v207)
                {
                  BOOL v220 = v208 != 0;
                  if (v208)
                  {
                    v207 = (char *)objc_loadWeakRetained((id *)(v208 + 16));
                    uint64_t v208 = *(void *)(a1 + 48);
                  }

                  else
                  {
                    v207 = 0LL;
                  }

                  v206 = v207 + 391;
                }

                else
                {
                  BOOL v220 = 0;
                  v206 = &unk_1875F4C23;
                }

                v211 = v207;
                if (v208)
                {
                  id v204 = objc_loadWeakRetained((id *)(v208 + 16));
                  char v205 = 0;
                }

                else
                {
                  id v204 = 0LL;
                  char v205 = 1;
                }
              }

              else
              {
                BOOL v220 = 0;
                id v204 = 0LL;
                char v205 = 1;
                v206 = &unk_1875F4C23;
              }

              *(_DWORD *)buf = 136446978;
              v230 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
              __int16 v231 = 1024;
              int v232 = 1974;
              __int16 v233 = 2082;
              v234 = v206;
              __int16 v235 = 2048;
              id v236 = v204;
              _os_log_error_impl( &dword_187560000,  v157,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Failed to copy PSK hint data",  buf,  0x26u);
              if ((v205 & 1) == 0) {

              }
              if (v220) {
              id v79 = v226;
              }
              if (v203) {
            }
              }
          }
        }
      }
    }

    if (v146) {
      free(v146);
    }
  }

  v158 = (void *)*((void *)a2 + 17);
  if (v158)
  {
    v40 &= boringssl_context_set_quic_transport_parameters(*(void *)(a1 + 40), v158);
    uint64_t v159 = *(void *)(*(void *)(a1 + 48) + 400LL);
    BOOL quic_use_legacy_codepoint = sec_protocol_options_get_quic_use_legacy_codepoint(options);
    SSL_set_quic_use_legacy_codepoint(v159, quic_use_legacy_codepoint);
  }

  id v161 = *((id *)a2 + 5);
  if (v161)
  {
    v162 = v161;
    if (v89)
    {
      uint64_t v163 = boringssl_helper_xpc_array_union(v161, v89);

      v162 = (void *)v163;
    }

    boringssl_context_set_ciphersuites_from_list(*(void *)(a1 + 40), v162);
  }

  else
  {
    if (v89) {
      boringssl_context_set_ciphersuites_from_list(*(void *)(a1 + 40), v89);
    }
    v162 = 0LL;
  }

  id v164 = *((id *)a2 + 29);
  if (v164) {
    boringssl_context_set_key_exchange_groups(*(void *)(a1 + 40), v164);
  }
  if (*((void *)a2 + 15))
  {
    uint64_t v165 = MEMORY[0x1895A97C0]();
    uint64_t v166 = *(void *)(a1 + 48);
    v167 = *(void **)(v166 + 120);
    *(void *)(v166 + 120) = v165;

    objc_storeStrong((id *)(*(void *)(a1 + 48) + 128LL), *((id *)a2 + 16));
  }

  if (*((void *)a2 + 13))
  {
    uint64_t v168 = MEMORY[0x1895A97C0]();
    uint64_t v169 = *(void *)(a1 + 48);
    v170 = *(void **)(v169 + 136);
    *(void *)(v169 + 136) = v168;

    objc_storeStrong((id *)(*(void *)(a1 + 48) + 144LL), *((id *)a2 + 14));
  }

  if (*((void *)a2 + 11))
  {
    uint64_t v171 = MEMORY[0x1895A97C0]();
    uint64_t v172 = *(void *)(a1 + 48);
    v173 = *(void **)(v172 + 152);
    *(void *)(v172 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = v171;

    objc_storeStrong((id *)(*(void *)(a1 + 48) + 160LL), *((id *)a2 + 12));
  }

  if (*((void *)a2 + 22))
  {
    uint64_t v174 = MEMORY[0x1895A97C0]();
    uint64_t v175 = *(void *)(a1 + 48);
    v176 = *(void **)(v175 + 168);
    *(void *)(v175 + 16_Block_object_dispose(va, 8) = v174;

    objc_storeStrong((id *)(*(void *)(a1 + 48) + 176LL), *((id *)a2 + 23));
  }

  objc_storeStrong((id *)(*(void *)(a1 + 48) + 512LL), *(id *)(a1 + 32));
  *(_BYTE *)(*(void *)(a1 + 48) + 384LL) = *((_BYTE *)a2 + 296);
  *(_BYTE *)(*(void *)(a1 + 48) + 385LL) = *((_BYTE *)a2 + 297);
  a2 = (unsigned __int16 *)(v40 & boringssl_context_set_ticket_request( *(void *)(a1 + 40),  *(_BYTE *)(*(void *)(a1 + 48) + 384LL),  *(_BYTE *)(*(void *)(a1 + 48) + 385LL)));
  if ((_DWORD)a2 == 1)
  {
    uint64_t v177 = *(void *)(a1 + 48);
    if (!v177) {
      goto LABEL_266;
    }
    id v178 = objc_loadWeakRetained((id *)(v177 + 16));
    if (!v178
      || (v179 = v178,
          v180 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL)),
          char v181 = v180[475],
          v180,
          v179,
          (v181 & 1) == 0))
    {
      uint64_t v182 = *(void *)(a1 + 48);
      if (!v182) {
        goto LABEL_266;
      }
      id v183 = objc_loadWeakRetained((id *)(v182 + 16));
      if (v183)
      {
        v184 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
        BOOL v185 = (v184[475] & 1) == 0;
      }

      else
      {
        BOOL v185 = 1;
      }

      if (v185)
      {
LABEL_266:
        if (g_boringssl_log)
        {
          v186 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
          {
            id v187 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16LL));
            uint64_t v188 = *(void *)(a1 + 48);
            v219 = v187;
            id v225 = v79;
            if (v187)
            {
              BOOL v189 = v188 != 0;
              if (v188)
              {
                v190 = (char *)objc_loadWeakRetained((id *)(v188 + 16));
                uint64_t v188 = *(void *)(a1 + 48);
              }

              else
              {
                v190 = 0LL;
              }

              v210 = v190;
              v212 = v190 + 391;
              BOOL v214 = v189;
            }

            else
            {
              BOOL v214 = 0;
              v212 = &unk_1875F4C23;
            }

            id v191 = objc_loadWeakRetained((id *)(v188 + 16));
            uint64_t v192 = *(void *)(a1 + 48);
            int v193 = *(unsigned __int16 *)(v192 + 58);
            int v194 = *(unsigned __int16 *)(v192 + 56);
            id v195 = objc_loadWeakRetained((id *)(v192 + 16));
            redacted_identity = nw_protocol_boringssl_get_redacted_identity( (uint64_t)v195,  *(const char **)(*(void *)(a1 + 48) + 80LL));
            v197 = *(unsigned __int8 **)(a1 + 48);
            int v198 = (v197[557] >> 4) & 1;
            int v199 = v197[556] >> 7;
            int v200 = (v197[559] >> 1) & 1;
            int v201 = (v197[559] >> 3) & 1;
            LODWORD(v197) = (v197[560] >> 3) & 1;
            *(_DWORD *)buf = 136449026;
            v230 = "boringssl_session_apply_protocol_options_for_transport_block_invoke";
            __int16 v231 = 1024;
            int v232 = 2042;
            __int16 v233 = 2082;
            v234 = v212;
            __int16 v235 = 2048;
            id v236 = v191;
            __int16 v237 = 1024;
            *(_DWORD *)v238 = v193;
            *(_WORD *)&v238[4] = 1024;
            *(_DWORD *)&v238[6] = v194;
            __int16 v239 = 2082;
            v240 = redacted_identity;
            __int16 v241 = 1024;
            int v242 = v198;
            __int16 v243 = 1024;
            int v244 = v199;
            __int16 v245 = 1024;
            int v246 = v200;
            __int16 v247 = 1024;
            int v248 = v201;
            __int16 v249 = 1024;
            int v250 = (int)v197;
            _os_log_impl( &dword_187560000,  v186,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] TLS configured [min_version(0x%04x) max_version(0x%04x) name(%{public}s) tic kets(%{BOOL}d) false_start(%{BOOL}d) enforce_ev(%{BOOL}d) enforce_ats(%{BOOL}d) ech(%{BOOL}d)]",  buf,  0x5Au);

            if (v214) {
            id v79 = v225;
            }
          }
        }
      }
    }
  }

  id v4 = options;
LABEL_279:

  return a2;
}

uint64_t boringssl_context_set_fallback(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    SSL_set_mode(v3, 0x400u);
    char v4 = 64;
  }

  else
  {
    SSL_clear_mode(v3, 1024);
    char v4 = 0;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0xBF | v4;
  return result;
}

uint64_t SSL_clear_mode(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD *)(a1 + 148) & ~a2;
  *(_DWORD *)(a1 + 14_Block_object_dispose(va, 8) = v2;
  return v2;
}

uint64_t boringssl_config_get_sct_enabled()
{
  return 1LL;
}

uint64_t boringssl_context_set_sct_enable(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(v2 + 408);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  uint64_t v5 = *(void *)(v2 + 400);
  if (a2) {
    char v6 = 4;
  }
  else {
    char v6 = 0;
  }
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0xFB | v6;
  if (a2)
  {
    if (v5) {
      SSL_enable_signed_cert_timestamps(v5);
    }
    else {
      SSL_CTX_enable_signed_cert_timestamps(v3);
    }
    return 0LL;
  }

  return result;
}

uint64_t SSL_enable_signed_cert_timestamps(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (v1) {
    *(_WORD *)(v1 + 301) |= 2u;
  }
  return result;
}

uint64_t boringssl_config_get_ocsp_enabled()
{
  return 1LL;
}

uint64_t boringssl_context_set_ocsp_enable(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    SSL_enable_ocsp_stapling(v3);
    char v4 = 8;
  }

  else
  {
    char v4 = 0;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0xF7 | v4;
  return result;
}

uint64_t SSL_enable_ocsp_stapling(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (v1) {
    *(_WORD *)(v1 + 301) |= 4u;
  }
  return result;
}

uint64_t boringssl_config_get_renegotiation_enabled()
{
  return 1LL;
}

uint64_t boringssl_context_set_renegotiation(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(bssl **)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (a2) {
    uint64_t v4 = 2LL;
  }
  else {
    uint64_t v4 = 0LL;
  }
  SSL_set_renegotiate_mode(v3, (ssl_st *)v4);
  return 0LL;
}

void SSL_set_renegotiate_mode(bssl *this, ssl_st *a2)
{
  *((_DWORD *)this + 44) = (_DWORD)a2;
  bssl::ssl_maybe_shed_handshake_config(this, a2);
}

void bssl::ssl_maybe_shed_handshake_config(bssl *this, ssl_st *a2)
{
  if (!*(void *)(*((void *)this + 6) + 280LL))
  {
    uint64_t v3 = (BUF_MEM ***)((char *)this + 8);
    uint64_t v2 = *((void *)this + 1);
    if (v2)
    {
      if ((*(_WORD *)(v2 + 301) & 0x80) != 0 && !bssl::ssl_can_renegotiate(this, a2)) {
        std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100](v3, 0LL);
      }
    }
  }

uint64_t boringssl_context_set_resumption(uint64_t a1, char a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  if (v2)
  {
    if ((a2 & 1) == 0)
    {
      SSL_CTX_set_session_cache_mode(*(void *)(v2 + 408), 0);
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_set_session_ticket_enabled(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    SSL_clear_options(v3, 0x4000);
    char v4 = 16;
  }

  else
  {
    SSL_set_options(v3, 0x4000u);
    char v4 = 0;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v2 + 557) = *(_BYTE *)(v2 + 557) & 0xEF | v4;
  return result;
}

uint64_t SSL_set_options(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(_DWORD *)(a1 + 144) | a2;
  *(_DWORD *)(a1 + 144) = v2;
  return v2;
}

uint64_t boringssl_context_set_false_start(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    char v4 = 0x80;
    SSL_set_mode(v3, 0x80u);
  }

  else
  {
    SSL_clear_mode(v3, 128);
    char v4 = 0;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v2 + 556) = *(_BYTE *)(v2 + 556) & 0x7F | v4;
  return result;
}

uint64_t boringssl_session_set_early_data_enabled(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        uint64_t result = *(void *)(v2 + 400);
        if (result)
        {
          *(_BYTE *)(v2 + 559) = *(_BYTE *)(v2 + 559) & 0xFE | a2;
          return SSL_set_early_data_enabled(result, a2);
        }
      }
    }
  }

  return result;
}

uint64_t SSL_set_early_data_enabled(uint64_t result, int a2)
{
  *(_BYTE *)(result + 180) = *(_BYTE *)(result + 180) & 0xFB | (4 * (a2 != 0));
  return result;
}

uint64_t boringssl_context_set_enforce_ev(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        if (a2) {
          char v3 = 2;
        }
        else {
          char v3 = 0;
        }
        *(_BYTE *)(v2 + 559) = *(_BYTE *)(v2 + 559) & 0xFD | v3;
      }
    }
  }

  return result;
}

void boringssl_context_set_ats_enforced(uint64_t a1, int a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v3 = *(void *)(a1 + 8);
      if (v3)
      {
        id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (char v6 = WeakRetained,
              __int16 v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              uint64_t v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          id v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            uint64_t v9 = objc_loadWeakRetained((id *)(v3 + 16));
            BOOL v10 = (v9[475] & 1) == 0;
          }

          else
          {
            BOOL v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              id v11 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                id v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  BOOL v13 = v2 + 391;
                }

                else
                {
                  BOOL v13 = &unk_1875F4C23;
                }

                id v14 = objc_loadWeakRetained((id *)(v3 + 16));
                BOOL v15 = v14;
                int v18 = 136447234;
                unint64_t v19 = "boringssl_context_set_ats_enforced";
                uint64_t v16 = "false";
                __int16 v20 = 1024;
                int v21 = 652;
                if (a2) {
                  uint64_t v16 = "true";
                }
                __int16 v22 = 2082;
                BOOL v23 = v13;
                __int16 v24 = 2048;
                id v25 = v14;
                __int16 v26 = 2082;
                uint64_t v27 = v16;
                _os_log_impl( &dword_187560000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] set %{public}s",  (uint8_t *)&v18,  0x30u);

                if (v12) {
              }
                }
            }
          }
        }

        if (a2) {
          char v17 = 8;
        }
        else {
          char v17 = 0;
        }
        *(_BYTE *)(v3 + 559) = *(_BYTE *)(v3 + 559) & 0xF7 | v17;
      }
    }
  }

void boringssl_context_set_ats_minimum_rsa_key_size(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v3 = *(void *)(a1 + 8);
      if (v3)
      {
        id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (char v6 = WeakRetained,
              __int16 v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              uint64_t v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          id v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            uint64_t v9 = objc_loadWeakRetained((id *)(v3 + 16));
            BOOL v10 = (v9[475] & 1) == 0;
          }

          else
          {
            BOOL v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              id v11 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                id v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  BOOL v13 = v2 + 391;
                }

                else
                {
                  BOOL v13 = &unk_1875F4C23;
                }

                id v14 = objc_loadWeakRetained((id *)(v3 + 16));
                int v15 = 136447234;
                uint64_t v16 = "boringssl_context_set_ats_minimum_rsa_key_size";
                __int16 v17 = 1024;
                int v18 = 661;
                __int16 v19 = 2082;
                __int16 v20 = v13;
                __int16 v21 = 2048;
                id v22 = v14;
                __int16 v23 = 2050;
                uint64_t v24 = a2;
                _os_log_impl( &dword_187560000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] set %{public}zu",  (uint8_t *)&v15,  0x30u);

                if (v12) {
              }
                }
            }
          }
        }

        *(void *)(v3 + 52_Block_object_dispose(va, 8) = a2;
      }
    }
  }

void boringssl_context_set_ats_minimum_ecdsa_key_size(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v3 = *(void *)(a1 + 8);
      if (v3)
      {
        id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (char v6 = WeakRetained,
              __int16 v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              uint64_t v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          id v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            uint64_t v9 = objc_loadWeakRetained((id *)(v3 + 16));
            BOOL v10 = (v9[475] & 1) == 0;
          }

          else
          {
            BOOL v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              id v11 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                id v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  BOOL v13 = v2 + 391;
                }

                else
                {
                  BOOL v13 = &unk_1875F4C23;
                }

                id v14 = objc_loadWeakRetained((id *)(v3 + 16));
                int v15 = 136447234;
                uint64_t v16 = "boringssl_context_set_ats_minimum_ecdsa_key_size";
                __int16 v17 = 1024;
                int v18 = 670;
                __int16 v19 = 2082;
                __int16 v20 = v13;
                __int16 v21 = 2048;
                id v22 = v14;
                __int16 v23 = 2050;
                uint64_t v24 = a2;
                _os_log_impl( &dword_187560000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] set %{public}zu",  (uint8_t *)&v15,  0x30u);

                if (v12) {
              }
                }
            }
          }
        }

        *(void *)(v3 + bssl::Array<unsigned short>::~Array(v16 + 536) = a2;
      }
    }
  }

void boringssl_context_set_ats_minimum_signature_algorithm(uint64_t a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v3 = *(void *)(a1 + 8);
      if (v3)
      {
        id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
        if (!WeakRetained
          || (char v6 = WeakRetained,
              __int16 v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
              uint64_t v2 = (char *)v7[475],
              v7,
              v6,
              (v2 & 1) == 0))
        {
          id v8 = objc_loadWeakRetained((id *)(v3 + 16));
          if (v8)
          {
            uint64_t v9 = objc_loadWeakRetained((id *)(v3 + 16));
            BOOL v10 = (v9[475] & 1) == 0;
          }

          else
          {
            BOOL v10 = 1;
          }

          if (v10)
          {
            if (g_boringssl_log)
            {
              id v11 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
              {
                id v12 = objc_loadWeakRetained((id *)(v3 + 16));
                if (v12)
                {
                  uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                  BOOL v13 = v2 + 391;
                }

                else
                {
                  BOOL v13 = &unk_1875F4C23;
                }

                id v14 = objc_loadWeakRetained((id *)(v3 + 16));
                int v15 = 136447234;
                uint64_t v16 = "boringssl_context_set_ats_minimum_signature_algorithm";
                __int16 v17 = 1024;
                int v18 = 680;
                __int16 v19 = 2082;
                __int16 v20 = v13;
                __int16 v21 = 2048;
                id v22 = v14;
                __int16 v23 = 1026;
                int v24 = a2;
                _os_log_impl( &dword_187560000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] set %{public}d",  (uint8_t *)&v15,  0x2Cu);

                if (v12) {
              }
                }
            }
          }
        }

        *(_DWORD *)(v3 + 544) = a2;
      }
    }
  }

uint64_t boringssl_context_set_certificate_compression(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v2 = *(void *)(result + 8);
      uint64_t result = v2 != 0;
      if (v2) {
        BOOL v3 = a2 == 0;
      }
      else {
        BOOL v3 = 1;
      }
      if (!v3)
      {
        uint64_t result = *(void *)(v2 + 408);
        if (result)
        {
          *(_BYTE *)(v2 + 559) |= 0x20u;
          return SSL_CTX_add_cert_compression_alg( result,  1,  (uint64_t)boringssl_context_zlib_compress_data,  (uint64_t)boringssl_context_zlib_uncompress_data) == 1;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_CTX_add_cert_compression_alg(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    SSL_CTX_add_cert_compression_alg_cold_1();
  }
  __int16 v6 = a2;
  uint64_t v8 = *(void *)(a1 + 704);
  if (v8)
  {
    uint64_t v9 = 24 * v8;
    BOOL v10 = (unsigned __int16 *)(*(void *)(a1 + 712) + 16LL);
    while (1)
    {
      int v11 = *v10;
      v10 += 12;
      if (v11 == a2) {
        return 0LL;
      }
      v9 -= 24LL;
      if (!v9) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t result = bssl::GrowableArray<bssl::CertCompressionAlg>::MaybeGrow((unint64_t *)(a1 + 704));
    if ((_DWORD)result)
    {
      uint64_t v13 = *(void *)(a1 + 704);
      uint64_t v14 = *(void *)(a1 + 712) + 24 * v13;
      *(void *)uint64_t v14 = a3;
      *(void *)(v14 + _Block_object_dispose(va, 8) = a4;
      *(_WORD *)(v14 + 16) = v6;
      *(void *)(a1 + 704) = v13 + 1;
    }
  }

  return result;
}

uint64_t bssl::GrowableArray<bssl::CertCompressionAlg>::MaybeGrow(unint64_t *a1)
{
  uint64_t v1 = (void **)(a1 + 1);
  unint64_t v2 = a1[2];
  if (!v2) {
    return bssl::Array<bssl::CertCompressionAlg>::Init((uint64_t)(a1 + 1), 0x10uLL);
  }
  if (*a1 < v2) {
    return 1LL;
  }
  if ((v2 & 0x8000000000000000LL) != 0)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 412);
    return 0LL;
  }

  else
  {
    uint64_t v14 = 0LL;
    unint64_t v15 = 0LL;
    uint64_t v4 = bssl::Array<bssl::CertCompressionAlg>::Init((uint64_t)&v14, 2 * v2);
    if ((v4 & 1) != 0)
    {
      if (a1[2])
      {
        uint64_t v6 = 0LL;
        unint64_t v7 = 0LL;
        uint64_t v8 = (char *)v14;
        do
        {
          uint64_t v9 = (__int128 *)(a1[1] + v6);
          BOOL v10 = &v8[v6];
          __int128 v11 = *v9;
          *((_WORD *)v10 + _Block_object_dispose(va, 8) = *((_WORD *)v9 + 8);
          *(_OWORD *)BOOL v10 = v11;
          ++v7;
          v6 += 24LL;
        }

        while (v7 < a1[2]);
      }

      OPENSSL_free(*v1);
      id v12 = 0LL;
      unint64_t v13 = v15;
      a1[1] = (unint64_t)v14;
      a1[2] = v13;
      uint64_t v14 = 0LL;
      unint64_t v15 = 0LL;
    }

    else
    {
      id v12 = v14;
    }

    OPENSSL_free(v12);
  }

  return v4;
}

void sub_187569778( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::Array<bssl::CertCompressionAlg>::Init(uint64_t a1, unint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  if (!a2) {
    return 1LL;
  }
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 297);
    return 0LL;
  }

  uint64_t result = (uint64_t)OPENSSL_malloc(24 * a2);
  *(void *)a1 = result;
  if (result)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    do
    {
      uint64_t v7 = *(void *)a1 + v5;
      *(void *)uint64_t v7 = 0LL;
      *(void *)(v7 + _Block_object_dispose(va, 8) = 0LL;
      *(_WORD *)(v7 + 16) = 0;
      ++v6;
      v5 += 24LL;
    }

    while (v6 < *(void *)(a1 + 8));
    return 1LL;
  }

  return result;
}

uint64_t boringssl_context_set_GREASE_enabled(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        uint64_t result = *(void *)(v2 + 408);
        if (result)
        {
          *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xFE | a2;
          return SSL_CTX_set_grease_enabled(result, a2);
        }
      }
    }
  }

  return result;
}

uint64_t SSL_CTX_set_grease_enabled(uint64_t result, int a2)
{
  *(_WORD *)(result + 832) = *(_WORD *)(result + 832) & 0xFFDF | (32 * (a2 != 0));
  return result;
}

uint64_t boringssl_context_set_ech_grease_enabled(uint64_t result, int a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        uint64_t result = *(void *)(v2 + 400);
        if (result)
        {
          if (a2) {
            char v3 = 8;
          }
          else {
            char v3 = 0;
          }
          *(_BYTE *)(v2 + 560) = *(_BYTE *)(v2 + 560) & 0xF7 | v3;
          return SSL_set_enable_ech_grease(result, a2);
        }
      }
    }
  }

  return result;
}

uint64_t SSL_set_enable_ech_grease(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2) {
    *(_WORD *)(v2 + 301) = *(_WORD *)(v2 + 301) & 0xFFFE | (a2 != 0);
  }
  return result;
}

uint64_t boringssl_context_set_verify_mode(uint64_t a1, int a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3 || !*(void *)(v3 + 408)) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(v3 + 556) & 0x10) != 0)
  {
    if (a2 == 3)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
      if (WeakRetained)
      {
        unint64_t v13 = WeakRetained;
        uint64_t v14 = objc_loadWeakRetained((id *)(v3 + 16));
        char v15 = v14[475];

        if ((v15 & 1) != 0) {
          goto LABEL_51;
        }
      }

      id v16 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v16)
      {
        __int16 v17 = objc_loadWeakRetained((id *)(v3 + 16));
        BOOL v18 = (v17[475] & 1) == 0;
      }

      else
      {
        BOOL v18 = 1;
      }

      if (!v18 || !g_boringssl_log) {
        goto LABEL_51;
      }
      __int16 v26 = (os_log_s *)(id)g_boringssl_log;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      id v27 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v27)
      {
        uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        uint64_t v28 = v2 + 391;
      }

      else
      {
        uint64_t v28 = &unk_1875F4C23;
      }

      id v31 = objc_loadWeakRetained((id *)(v3 + 16));
      int v34 = 136446978;
      BOOL v35 = "boringssl_context_set_verify_mode";
      __int16 v36 = 1024;
      int v37 = 593;
      __int16 v38 = 2082;
      __int16 v39 = v28;
      __int16 v40 = 2048;
      id v41 = v31;
      uint64_t v32 = "%{public}s(%d) %{public}s[%p] Requiring client cert";
    }

    else if (a2 == 1)
    {
      id v19 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v19)
      {
        __int16 v20 = v19;
        __int16 v21 = objc_loadWeakRetained((id *)(v3 + 16));
        char v22 = v21[475];

        if ((v22 & 1) != 0) {
          goto LABEL_51;
        }
      }

      id v23 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v23)
      {
        int v24 = objc_loadWeakRetained((id *)(v3 + 16));
        BOOL v25 = (v24[475] & 1) == 0;
      }

      else
      {
        BOOL v25 = 1;
      }

      if (!v25 || !g_boringssl_log) {
        goto LABEL_51;
      }
      __int16 v26 = (os_log_s *)(id)g_boringssl_log;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      id v27 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v27)
      {
        uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        char v29 = v2 + 391;
      }

      else
      {
        char v29 = &unk_1875F4C23;
      }

      id v31 = objc_loadWeakRetained((id *)(v3 + 16));
      int v34 = 136446978;
      BOOL v35 = "boringssl_context_set_verify_mode";
      __int16 v36 = 1024;
      int v37 = 597;
      __int16 v38 = 2082;
      __int16 v39 = v29;
      __int16 v40 = 2048;
      id v41 = v31;
      uint64_t v32 = "%{public}s(%d) %{public}s[%p] Will request optional client cert";
    }

    else
    {
      if (a2) {
        goto LABEL_51;
      }
      id v5 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v5)
      {
        unint64_t v6 = v5;
        uint64_t v7 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16));
        uint64_t v2 = (char *)v7[475];
      }

      id v8 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v8)
      {
        uint64_t v9 = objc_loadWeakRetained((id *)(v3 + 16));
        BOOL v10 = (v9[475] & 1) == 0;
      }

      else
      {
        BOOL v10 = 1;
      }

      if (!v10 || !g_boringssl_log) {
        goto LABEL_51;
      }
      __int16 v26 = (os_log_s *)(id)g_boringssl_log;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      id v27 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v27)
      {
        uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        int v30 = v2 + 391;
      }

      else
      {
        int v30 = &unk_1875F4C23;
      }

      id v31 = objc_loadWeakRetained((id *)(v3 + 16));
      int v34 = 136446978;
      BOOL v35 = "boringssl_context_set_verify_mode";
      __int16 v36 = 1024;
      int v37 = 589;
      __int16 v38 = 2082;
      __int16 v39 = v30;
      __int16 v40 = 2048;
      id v41 = v31;
      uint64_t v32 = "%{public}s(%d) %{public}s[%p] Not requesting client cert";
    }

    _os_log_impl(&dword_187560000, v26, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&v34, 0x26u);

    if (v27) {
LABEL_50:
    }
  }

LABEL_51:
  uint64_t v33 = *(void *)(v3 + 400);
  if (v33) {
    SSL_set_custom_verify(v33, a2, (uint64_t)boringssl_context_certificate_verify_callback);
  }
  else {
    SSL_CTX_set_custom_verify(*(void *)(v3 + 408), a2, (uint64_t)boringssl_context_certificate_verify_callback);
  }
  return 0LL;
}

            uint64_t result = CBB_flush(a2);
            if ((_DWORD)result)
            {
              uint64_t result = CBB_add_u8((uint64_t)a2, 1u);
              if ((_DWORD)result) {
                return CBB_add_u8((uint64_t)a2, 0) != 0;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

            if (!CBB_flush((uint64_t *)v37))
            {
              BOOL v25 = 245;
              goto LABEL_62;
            }

            id v23 = CBB_data((uint64_t)v37);
            int v24 = CBB_len((uint64_t)v37);
            if (bssl::is_valid_client_hello_inner(a1, a2, (uint64_t)v23, v24))
            {
              if (((*(uint64_t (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 96LL))(a1, v38, a3) & 1) != 0)
              {
                __int128 v11 = 1LL;
                goto LABEL_49;
              }

              BOOL v25 = 255;
LABEL_62:
              ERR_put_error( 16,  0,  68,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/encrypted_client_hello.cc",  v25);
              __int128 v11 = 0LL;
              goto LABEL_49;
            }

uint64_t SSL_set_custom_verify(uint64_t result, char a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 8);
  if (v3)
  {
    *(_BYTE *)(v3 + 300) = a2;
    *(void *)(v3 + 4_Block_object_dispose(va, 8) = a3;
  }

  return result;
}

BOOL boringssl_context_set_alpn_protocol_list(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v123 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  unint64_t v6 = v5;
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    goto LABEL_23;
  }
  BOOL v7 = 0LL;
  if (!v5) {
    goto LABEL_24;
  }
  id v8 = *(void **)(a1 + 8);
  if (!v8) {
    goto LABEL_24;
  }
  if (!xpc_array_get_count(v5) || !v8[50] || !v8[51])
  {
LABEL_23:
    BOOL v7 = 0LL;
    goto LABEL_24;
  }

  uint64_t v107 = v8[50];
  char v108 = v8;
  id v9 = v6;
  xpc_object_t xarray = xpc_array_create(0LL, 0LL);
  size_t count = xpc_array_get_count(v9);
  if (!count)
  {
    size_t v12 = 0LL;
LABEL_26:
    __int16 v26 = xarray;
    id v27 = xarray;
    goto LABEL_74;
  }

  size_t v11 = count;
  size_t v12 = 0LL;
  size_t v13 = 0LL;
  uint64_t v14 = a3;
  id v109 = v9;
  while (1)
  {
    xpc_array_get_value(v9, v13);
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    if (MEMORY[0x1895A9BD4]() != MEMORY[0x1895F92E8])
    {
      if (MEMORY[0x1895A9BD4](v15) == MEMORY[0x1895F9220])
      {
        if (xpc_array_get_count(v15) == 2)
        {
          size_t v16 = v12;
          string = xpc_array_get_string(v15, 0LL);
          uint64_t uint64 = xpc_array_get_uint64(v15, 1uLL);
          if (string)
          {
            uint64_t v19 = uint64;
            size_t v20 = strlen(string);
            size_t v21 = v20;
            if (v20 < 0x100)
            {
              if (v19 == v14)
              {
                size_t v12 = v16 + v20 + 1;
                xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, string);
              }

              else
              {
                size_t v12 = v16;
              }

              id v9 = v109;
              goto LABEL_21;
            }

            __int16 v52 = (id *)(v108 + 16);
            id WeakRetained = objc_loadWeakRetained((id *)v108 + 2);
            size_t v12 = v16;
            if (WeakRetained)
            {
              int v54 = WeakRetained;
              uint64_t v55 = objc_loadWeakRetained(v52);
              char v56 = v55[475];

              if ((v56 & 1) != 0) {
                goto LABEL_73;
              }
            }

            id v57 = objc_loadWeakRetained(v52);
            if (v57)
            {
              v58 = objc_loadWeakRetained(v52);
              BOOL v59 = (v58[475] & 1) == 0;
            }

            else
            {
              BOOL v59 = 1;
            }

            if (!v59 || !g_boringssl_log) {
              goto LABEL_73;
            }
            id v68 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            {
              log = v68;
              id v69 = objc_loadWeakRetained(v52);
              if (v69)
              {
                v103 = (char *)objc_loadWeakRetained(v52);
                v70 = v103 + 391;
              }

              else
              {
                v70 = &unk_1875F4C23;
              }

              id v99 = objc_loadWeakRetained(v52);
              id v100 = v99;
              *(_DWORD *)buf = 136447490;
              BOOL v112 = "boringssl_context_copy_validated_alpn_array";
              __int16 v113 = 1024;
              int v114 = 1129;
              __int16 v115 = 2082;
              v116 = v70;
              __int16 v117 = 2048;
              id v118 = v99;
              __int16 v119 = 2048;
              size_t v120 = v21;
              __int16 v121 = 2082;
              redacted_identity = nw_protocol_boringssl_get_redacted_identity((uint64_t)v100, string);
              id v68 = log;
              _os_log_error_impl( &dword_187560000,  log,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] ALPN protocol exceeds length restrictions (%zu): %{public}s",  buf,  0x3Au);

              if (v69) {
              size_t v12 = v16;
              }
            }
          }

          else
          {
            unsigned int v44 = (id *)(v108 + 16);
            id v45 = objc_loadWeakRetained((id *)v108 + 2);
            if (v45)
            {
              int v46 = v45;
              uint64_t v47 = objc_loadWeakRetained(v44);
              char v48 = v47[475];

              if ((v48 & 1) != 0) {
                goto LABEL_73;
              }
            }

            id v49 = objc_loadWeakRetained(v44);
            if (v49)
            {
              uint64_t v50 = objc_loadWeakRetained(v44);
              BOOL v51 = (v50[475] & 1) == 0;
            }

            else
            {
              BOOL v51 = 1;
            }

            if (!v51 || !g_boringssl_log) {
              goto LABEL_73;
            }
            id v68 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
              boringssl_context_set_alpn_protocol_list_cold_3(v44, v68);
            }
          }
        }

        else
        {
          __int16 v36 = (id *)(v108 + 16);
          id v37 = objc_loadWeakRetained((id *)v108 + 2);
          if (v37)
          {
            __int16 v38 = v37;
            __int16 v39 = objc_loadWeakRetained(v36);
            char v40 = v39[475];

            if ((v40 & 1) != 0) {
              goto LABEL_73;
            }
          }

          id v41 = objc_loadWeakRetained(v36);
          if (v41)
          {
            uint64_t v42 = objc_loadWeakRetained(v36);
            BOOL v43 = (v42[475] & 1) == 0;
          }

          else
          {
            BOOL v43 = 1;
          }

          if (!v43 || !g_boringssl_log) {
            goto LABEL_73;
          }
          id v68 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
            boringssl_context_set_alpn_protocol_list_cold_4(v36, v15, v68);
          }
        }
      }

      else
      {
        uint64_t v28 = (id *)(v108 + 16);
        id v29 = objc_loadWeakRetained((id *)v108 + 2);
        if (v29)
        {
          int v30 = v29;
          id v31 = objc_loadWeakRetained(v28);
          char v32 = v31[475];

          if ((v32 & 1) != 0) {
            goto LABEL_73;
          }
        }

        id v33 = objc_loadWeakRetained(v28);
        if (v33)
        {
          int v34 = objc_loadWeakRetained(v28);
          BOOL v35 = (v34[475] & 1) == 0;
        }

        else
        {
          BOOL v35 = 1;
        }

        if (!v35 || !g_boringssl_log) {
          goto LABEL_73;
        }
        id v68 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
          boringssl_context_set_alpn_protocol_list_cold_5(v28, v15, v68);
        }
      }

LABEL_72:
      goto LABEL_73;
    }

    char v22 = xpc_array_get_string(v9, v13);
    size_t v23 = strlen(v22);
    size_t v24 = v23;
    if (v23 >= 0x100) {
      break;
    }
    v12 += v23 + 1;
    xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, v22);
LABEL_21:

    if (v11 == ++v13) {
      goto LABEL_26;
    }
  }

  uint64_t v60 = (id *)(v108 + 16);
  id v61 = objc_loadWeakRetained((id *)v108 + 2);
  if (!v61
    || (v62 = v61, BOOL v63 = objc_loadWeakRetained(v60),
                   char v64 = v63[475],
                   v63,
                   v62,
                   (v64 & 1) == 0))
  {
    id v65 = objc_loadWeakRetained(v60);
    if (v65)
    {
      uint64_t v66 = objc_loadWeakRetained(v60);
      BOOL v67 = (v66[475] & 1) == 0;
    }

    else
    {
      BOOL v67 = 1;
    }

    if (v67)
    {
      if (g_boringssl_log)
      {
        id v68 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          os_log_t logb = (os_log_t)v12;
          id v97 = objc_loadWeakRetained(v60);
          if (v97)
          {
            v103 = (char *)objc_loadWeakRetained(v60);
            v98 = v103 + 391;
          }

          else
          {
            v98 = &unk_1875F4C23;
          }

          id v101 = objc_loadWeakRetained(v60);
          id v102 = v101;
          *(_DWORD *)buf = 136447490;
          BOOL v112 = "boringssl_context_copy_validated_alpn_array";
          __int16 v113 = 1024;
          int v114 = 1116;
          __int16 v115 = 2082;
          v116 = v98;
          __int16 v117 = 2048;
          id v118 = v101;
          __int16 v119 = 2048;
          size_t v120 = v24;
          __int16 v121 = 2082;
          redacted_identity = nw_protocol_boringssl_get_redacted_identity((uint64_t)v102, v22);
          _os_log_error_impl( &dword_187560000,  v68,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] ALPN protocol exceeds length restrictions (%zu): %{public}s",  buf,  0x3Au);

          if (v97) {
          size_t v12 = (size_t)logb;
          }
        }

        goto LABEL_72;
      }
    }
  }

        CFRelease(v9);
LABEL_73:
        id v9 = 0LL;
        goto LABEL_74;
      }

      if (!v6) {
        break;
      }
      char v15 = objc_loadWeakRetained(v6 + 2);
      if (v15)
      {
        size_t v16 = v15;
        __int16 v17 = (unsigned __int8 *)objc_loadWeakRetained(v6 + 2);
        uint64_t v3 = v17[475];

        if ((v3 & 1) != 0)
        {
          size_t v20 = CFDataCreate(v7, v12, v14);
          if (!v20) {
            goto LABEL_46;
          }
          goto LABEL_19;
        }
      }

      BOOL v18 = objc_loadWeakRetained(v6 + 2);
      if (v18)
      {
        uint64_t v19 = objc_loadWeakRetained(v6 + 2);
        uint64_t v3 = (v19[475] & 1) == 0;
      }

      else
      {
        uint64_t v3 = 1LL;
      }

      if ((_DWORD)v3) {
        goto LABEL_15;
      }
LABEL_18:
      size_t v20 = CFDataCreate(v7, v12, v14);
      if (!v20)
      {
        if (!v6)
        {
          uint64_t v47 = 0;
          __int16 v39 = 1LL;
          goto LABEL_60;
        }

LABEL_73:
  id v27 = 0LL;
  id v9 = v109;
  __int16 v26 = xarray;
LABEL_74:

  if (!v27) {
    goto LABEL_103;
  }
  size_t v71 = xpc_array_get_count(v27);
  if (!v71)
  {
    id v79 = (id *)(v108 + 16);
    id v80 = objc_loadWeakRetained((id *)v108 + 2);
    if (!v80
      || (v81 = v80,
          v82 = objc_loadWeakRetained(v79),
          char v83 = v82[475],
          v82,
          v81,
          (v83 & 1) == 0))
    {
      id v84 = objc_loadWeakRetained(v79);
      if (v84)
      {
        v85 = objc_loadWeakRetained(v79);
        BOOL v86 = (v85[475] & 1) == 0;
      }

      else
      {
        BOOL v86 = 1;
      }

      BOOL v7 = 0LL;
      if (v86 && g_boringssl_log)
      {
        v95 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
          boringssl_context_set_alpn_protocol_list_cold_1(v79, v95);
        }

        goto LABEL_103;
      }

      goto LABEL_104;
    }

LABEL_104:
LABEL_24:
  return v7;
}

uint64_t SSL_set_alpn_protos(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    if (!a3)
    {
      int v8 = bssl::Array<unsigned char>::Init(v3 + 128, 0LL);
      return v8 ^ 1u;
    }

    if ((bssl::ssl_is_valid_alpn_list((unsigned __int8 *)a2, a3) & 1) != 0)
    {
      BOOL v7 = (void **)(*(void *)(a1 + 8) + 128LL);
      int v8 = bssl::Array<unsigned char>::Init((uint64_t)v7, a3);
      if (v8) {
        memmove(*v7, a2, a3);
      }
      return v8 ^ 1u;
    }

    ERR_put_error(16, 0, 315, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 2656);
  }

  return 1LL;
}

uint64_t bssl::ssl_is_valid_alpn_list(unsigned __int8 *a1, uint64_t a2)
{
  BOOL v7 = a1;
  uint64_t v8 = a2;
  if (!a2) {
    return 0LL;
  }
  do
  {
    unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v6 = 0xAAAAAAAAAAAAAAAALL;
    else {
      BOOL v2 = 1;
    }
    uint64_t result = !v2;
  }

  while ((_DWORD)result == 1 && v8 != 0);
  return result;
}

uint64_t CBS_get_u8_length_prefixed(unsigned __int8 **a1, unint64_t *a2)
{
  return cbs_get_length_prefixed(a1, a2, 1uLL);
}

uint64_t cbs_get_length_prefixed(unsigned __int8 **a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3 = (unint64_t)a1[1];
  BOOL v4 = v3 >= a3;
  unint64_t v5 = v3 - a3;
  if (!v4) {
    return 0LL;
  }
  unint64_t v6 = *a1;
  unint64_t v7 = (unint64_t)&(*a1)[a3];
  *a1 = (unsigned __int8 *)v7;
  a1[1] = (unsigned __int8 *)v5;
  unint64_t v8 = 0LL;
  if (a3)
  {
    do
    {
      unsigned int v9 = *v6++;
      unint64_t v8 = v9 | (v8 << 8);
      --a3;
    }

    while (a3);
    if (v5 < v8) {
      return 0LL;
    }
  }

  *a1 = (unsigned __int8 *)(v7 + v8);
  a1[1] = (unsigned __int8 *)(v5 - v8);
  *a2 = v7;
  a2[1] = v8;
  return 1LL;
}

id boringssl_helper_xpc_array_union(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  unint64_t v5 = v4;
  id v6 = 0LL;
  if (v3 && v4)
  {
    uint64_t v12 = 0LL;
    size_t v13 = &v12;
    uint64_t v14 = 0x3032000000LL;
    char v15 = __Block_byref_object_copy__1;
    size_t v16 = __Block_byref_object_dispose__1;
    id v17 = (id)0xAAAAAAAAAAAAAAAALL;
    xpc_object_t v7 = xpc_array_create(0LL, 0LL);
    uint64_t v8 = MEMORY[0x1895F87A8];
    id v17 = v7;
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __boringssl_helper_xpc_array_union_block_invoke;
    applier[3] = &unk_18A071AB0;
    applier[4] = &v12;
    xpc_array_apply(v3, applier);
    v10[0] = v8;
    v10[1] = 3221225472LL;
    v10[2] = __boringssl_helper_xpc_array_union_block_invoke_2;
    v10[3] = &unk_18A071AB0;
    v10[4] = &v12;
    xpc_array_apply(v5, v10);
    id v6 = (id)v13[5];
    _Block_object_dispose(&v12, 8);
  }

  return v6;
}

void sub_18756AA5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __boringssl_helper_xpc_array_union_block_invoke(uint64_t a1, int a2, xpc_object_t value)
{
  return 1LL;
}

void boringssl_context_set_ciphersuites_from_list(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      if (v3)
      {
        if (*(void *)(a1 + 8))
        {
          id v6 = v3;
          size_t count = xpc_array_get_count(v3);
          unint64_t v5 = (unsigned __int16 *)malloc(2 * count);
          id v3 = v6;
          if (v5)
          {
            applier[0] = MEMORY[0x1895F87A8];
            applier[1] = 3221225472LL;
            applier[2] = __boringssl_context_set_ciphersuites_from_list_block_invoke;
            applier[3] = &unk_18A07B9E0;
            id v8 = v6;
            unsigned int v9 = v5;
            xpc_array_apply(v8, applier);
            if (count) {
              boringssl_context_set_cipher_suites(a1, v5, count);
            }
            free(v5);

            id v3 = v6;
          }
        }
      }
    }
  }
}

uint64_t __boringssl_context_set_ciphersuites_from_list_block_invoke(uint64_t a1, size_t a2)
{
  *(_WORD *)(*(void *)(a1 + 40) + 2 * a2) = xpc_array_get_uint64(*(xpc_object_t *)(a1 + 32), a2);
  return 1LL;
}

void bssl::SSLCipherPreferenceList::~SSLCipherPreferenceList(bssl::SSLCipherPreferenceList *this)
{
}

BOOL boringssl_context_set_ticket_request(BOOL result, char a2, char a3)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v3 = *(void *)(result + 8)) != 0)
    {
      uint64_t v4 = *(void *)(v3 + 400);
      if (v4) {
        int v5 = SSL_use_ticket_request(v4, a2, a3);
      }
      else {
        int v5 = SSL_CTX_use_ticket_request(*(void *)(v3 + 408), a2, a3);
      }
      return v5 == 1;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_use_ticket_request(uint64_t a1, char a2, char a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return 0LL;
  }
  *(_BYTE *)(v3 + 216) = a2;
  *(_BYTE *)(v3 + 217) = a3;
  return 1LL;
}

const char *nw_protocol_boringssl_get_redacted_identity(uint64_t a1, const char *a2)
{
  if (!a1) {
    return "redacted";
  }
  BOOL v2 = "nil";
  if (a2) {
    BOOL v2 = a2;
  }
  if ((*(_BYTE *)(a1 + 475) & 2) != 0) {
    return "redacted";
  }
  else {
    return v2;
  }
}

uint64_t boringssl_session_get_early_data_enabled(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(_BYTE *)(v1 + 559) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_ech_enabled(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return (*(unsigned __int8 *)(v1 + 560) >> 3) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void boringssl_session_set_association(uint64_t a1, void *a2)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  int v5 = v4;
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      if (v4)
      {
        uint64_t v6 = *(void *)(a1 + 8);
        if (v6)
        {
          xpc_object_t v7 = boringssl_session_cache_create_with_association(v4);
          id v8 = *(void **)(v6 + 32);
          *(void *)(v6 + 32) = v7;

          if ((boringssl_context_get_is_probe(a1) & 1) == 0)
          {
            id v9 = *(id *)(v6 + 32);
            BOOL v10 = v9;
            if (*(_DWORD *)a1 != -1252936367) {
              goto LABEL_73;
            }
            uint64_t v11 = *(void *)(a1 + 8);
            BOOL v12 = !v9 || v11 == 0;
            if (v12) {
              goto LABEL_73;
            }
            uint64_t v13 = boringssl_session_cache_pop(v9);
            if (v13)
            {
              uint64_t v14 = (void *)v13;
              BOOL is_session_state = boringssl_session_state_is_session_state(v13);
              id WeakRetained = objc_loadWeakRetained((id *)(v11 + 16));
              uint64_t v2 = (uint64_t)WeakRetained;
              if (is_session_state)
              {
                if (!WeakRetained
                  || (id v17 = objc_loadWeakRetained((id *)(v11 + 16)),
                      char v18 = v17[475],
                      v17,
                      (id)v2,
                      (v18 & 1) == 0))
                {
                  id v19 = objc_loadWeakRetained((id *)(v11 + 16));
                  if (v19)
                  {
                    size_t v20 = objc_loadWeakRetained((id *)(v11 + 16));
                    BOOL v21 = (v20[475] & 1) == 0;
                  }

                  else
                  {
                    BOOL v21 = 1;
                  }

                  if (v21)
                  {
                    if (g_boringssl_log)
                    {
                      __int16 v26 = (os_log_s *)(id)g_boringssl_log;
                      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
                      {
                        id v27 = objc_loadWeakRetained((id *)(v11 + 16));
                        if (v27)
                        {
                          id v61 = (char *)objc_loadWeakRetained((id *)(v11 + 16));
                          uint64_t v28 = v61 + 391;
                        }

                        else
                        {
                          uint64_t v28 = &unk_1875F4C23;
                        }

                        id v43 = objc_loadWeakRetained((id *)(v11 + 16));
                        unsigned int v44 = v43;
                        BOOL v12 = (*(_BYTE *)(v11 + 556) & 0x10) == 0;
                        *(_DWORD *)buf = 136447234;
                        BOOL v63 = "boringssl_session_install_association_state";
                        if (v12) {
                          id v45 = "Client";
                        }
                        else {
                          id v45 = "Server";
                        }
                        __int16 v64 = 1024;
                        int v65 = 1416;
                        __int16 v66 = 2082;
                        BOOL v67 = v28;
                        __int16 v68 = 2048;
                        id v69 = v43;
                        __int16 v70 = 2082;
                        size_t v71 = v45;
                        _os_log_impl( &dword_187560000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] %{public}s session cache hit",  buf,  0x30u);

                        if (v27) {
                      }
                        }
                    }
                  }
                }

                int v46 = boringssl_session_set_session_state(a1, v14);
                id v47 = objc_loadWeakRetained((id *)(v11 + 16));
                if (v47)
                {
                  char v48 = v47;
                  id v49 = objc_loadWeakRetained((id *)(v11 + 16));
                  char v50 = v49[475];

                  if ((v50 & 1) != 0) {
                    goto LABEL_72;
                  }
                }

                id v51 = objc_loadWeakRetained((id *)(v11 + 16));
                if (v51)
                {
                  __int16 v52 = objc_loadWeakRetained((id *)(v11 + 16));
                  BOOL v53 = (v52[475] & 1) == 0;
                }

                else
                {
                  BOOL v53 = 1;
                }

                if (!v53 || !g_boringssl_log) {
                  goto LABEL_72;
                }
                id v37 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
                {
                  id v54 = objc_loadWeakRetained((id *)(v11 + 16));
                  if (v54)
                  {
                    id v61 = (char *)objc_loadWeakRetained((id *)(v11 + 16));
                    uint64_t v55 = v61 + 391;
                  }

                  else
                  {
                    uint64_t v55 = &unk_1875F4C23;
                  }

                  id v56 = objc_loadWeakRetained((id *)(v11 + 16));
                  id v57 = v56;
                  char v58 = *(_BYTE *)(v11 + 556);
                  BOOL v59 = "Server";
                  BOOL v63 = "boringssl_session_install_association_state";
                  __int16 v64 = 1024;
                  BOOL v12 = (v58 & 0x10) == 0;
                  int v65 = 1419;
                  uint64_t v60 = "not set";
                  BOOL v67 = v55;
                  *(_DWORD *)buf = 136447490;
                  if (v12) {
                    BOOL v59 = "Client";
                  }
                  __int16 v66 = 2082;
                  __int16 v68 = 2048;
                  if (v46) {
                    uint64_t v60 = "set";
                  }
                  id v69 = v56;
                  __int16 v70 = 2082;
                  size_t v71 = v59;
                  __int16 v72 = 2082;
                  v73 = v60;
                  _os_log_impl( &dword_187560000,  v37,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] %{public}s session state %{public}s.",  buf,  0x3Au);

                  if (v54) {
                }
                  }

                goto LABEL_53;
              }

              if (!WeakRetained
                || (char v22 = objc_loadWeakRetained((id *)(v11 + 16)),
                    char v23 = v22[475],
                    v22,
                    (id)v2,
                    (v23 & 1) == 0))
              {
                id v24 = objc_loadWeakRetained((id *)(v11 + 16));
                if (v24)
                {
                  BOOL v25 = objc_loadWeakRetained((id *)(v11 + 16));
                  uint64_t v2 = (v25[475] & 1) == 0;
                }

                else
                {
                  uint64_t v2 = 1LL;
                }

                if ((_DWORD)v2)
                {
                  if (g_boringssl_log)
                  {
                    id v29 = (os_log_s *)(id)g_boringssl_log;
                    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
                      boringssl_session_set_association_cold_1(v11, v29);
                    }
                  }
                }
              }
            }

            id v30 = objc_loadWeakRetained((id *)(v11 + 16));
            if (v30)
            {
              id v31 = v30;
              char v32 = objc_loadWeakRetained((id *)(v11 + 16));
              char v33 = v32[475];

              if ((v33 & 1) != 0)
              {
                uint64_t v14 = 0LL;
LABEL_72:

LABEL_73:
                goto LABEL_74;
              }
            }

            id v34 = objc_loadWeakRetained((id *)(v11 + 16));
            if (v34)
            {
              BOOL v35 = objc_loadWeakRetained((id *)(v11 + 16));
              BOOL v36 = (v35[475] & 1) == 0;
            }

            else
            {
              BOOL v36 = 1;
            }

            uint64_t v14 = 0LL;
            if (!v36 || !g_boringssl_log) {
              goto LABEL_72;
            }
            id v37 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
            {
              id v38 = objc_loadWeakRetained((id *)(v11 + 16));
              if (v38)
              {
                uint64_t v2 = (uint64_t)objc_loadWeakRetained((id *)(v11 + 16));
                __int16 v39 = (void *)(v2 + 391);
              }

              else
              {
                __int16 v39 = &unk_1875F4C23;
              }

              id v40 = objc_loadWeakRetained((id *)(v11 + 16));
              id v41 = v40;
              BOOL v12 = (*(_BYTE *)(v11 + 556) & 0x10) == 0;
              *(_DWORD *)buf = 136447234;
              BOOL v63 = "boringssl_session_install_association_state";
              if (v12) {
                uint64_t v42 = "Client";
              }
              else {
                uint64_t v42 = "Server";
              }
              __int16 v64 = 1024;
              int v65 = 1421;
              __int16 v66 = 2082;
              BOOL v67 = v39;
              __int16 v68 = 2048;
              id v69 = v40;
              __int16 v70 = 2082;
              size_t v71 = v42;
              _os_log_impl( &dword_187560000,  v37,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] %{public}s session cache miss",  buf,  0x30u);

              if (v38) {
            }
              }

            uint64_t v14 = 0LL;
LABEL_53:

            goto LABEL_72;
          }
        }
      }
    }
  }

LABEL_74:
}

  return v9;
}

boringssl_concrete_boringssl_session_cache *boringssl_session_cache_create_with_association(void *a1)
{
  id v2 = a1;
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___boringssl_concrete_boringssl_session_cache);
  id v4 = v3;
  if (v3) {
    objc_storeStrong((id *)&v3->association, a1);
  }

  return v4;
}

uint64_t boringssl_context_get_is_probe(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return (*(unsigned __int8 *)(v1 + 559) >> 2) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

id boringssl_session_cache_pop(void *a1)
{
  id v1 = a1;
  id v2 = boringssl_session_cache_copy_queue();
  if (v2 || (id v2 = (void *)sec_array_create()) != 0LL)
  {
    uint64_t v8 = 0LL;
    id v9 = &v8;
    uint64_t v10 = 0x3032000000LL;
    uint64_t v11 = __Block_byref_object_copy__0;
    BOOL v12 = __Block_byref_object_dispose__0;
    id v13 = 0LL;
    id v7 = (id)sec_array_create();
    sec_array_apply();
    id v3 = nw_protocol_boringssl_copy_definition();
    id v4 = v7;
    time(0LL);
    nw_association_set_cached_content_for_protocol();

    id v5 = (id)v9[5];
    _Block_object_dispose(&v8, 8);
  }

  else
  {
    id v5 = 0LL;
  }

  return v5;
}

void sub_18756B5D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *boringssl_session_cache_copy_queue()
{
  id v0 = nw_protocol_boringssl_copy_definition();
  cached_content_for_protocol = (void *)nw_association_get_cached_content_for_protocol();

  if (cached_content_for_protocol) {
    id v2 = cached_content_for_protocol;
  }
  return cached_content_for_protocol;
}

uint64_t boringssl_session_clear_eap_metadata(uint64_t result)
{
  if (result && *(_DWORD *)result == -1252936367)
  {
    if (*(void *)(result + 8)) {
      return nw_protocol_metadata_access_handle();
    }
  }

  return result;
}

uint64_t __boringssl_session_clear_eap_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a2 + 320);
  if (v2)
  {
    free(v2);
    *(void *)(a2 + 320) = 0LL;
  }

  return 1LL;
}

uint64_t nw_protocol_boringssl_handshake_negotiate(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1 || (v1[475] & 1) == 0)
  {
    if (datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_handshake_negotiate_cold_2();
    }

    if (!v2) {
      goto LABEL_16;
    }
  }

  if (!*((void *)v2 + 42) || (id v3 = (uint64_t (*)(void))*((void *)v2 + 12)) == 0LL)
  {
LABEL_16:
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_30;
  }

  if ((*((_BYTE *)v2 + 389) & 4) != 0)
  {
    uint64_t v4 = 0LL;
    goto LABEL_30;
  }

  *((_BYTE *)v2 + 389) |= 4u;
  uint64_t v4 = v3();
  *((_BYTE *)v2 + 389) &= ~4u;
  id v5 = v2;
  if ((v5[475] & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_handshake_negotiate_cold_1();
  }

  uint64_t v6 = *((void *)v2 + 42);
  if (v6)
  {
    if ((_DWORD)v4)
    {
      int current_handshake_state = boringssl_session_get_current_handshake_state(v6);
      if (current_handshake_state)
      {
        int v8 = current_handshake_state;
        handshake_state_description = boringssl_helper_get_handshake_state_description(current_handshake_state);
        if ((v5[475] & 1) == 0)
        {
          id v13 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            uint64_t v14 = handshake_state_description;
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            {
              int v15 = 136447490;
              size_t v16 = "nw_protocol_boringssl_handshake_negotiate_proceed";
              __int16 v17 = 1024;
              int v18 = 780;
              __int16 v19 = 2082;
              size_t v20 = v5 + 391;
              __int16 v21 = 2048;
              char v22 = v5;
              __int16 v23 = 1024;
              int v24 = v8;
              __int16 v25 = 2080;
              __int16 v26 = v14;
              _os_log_error_impl( &dword_187560000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] handshake failed at state %d: %s",  (uint8_t *)&v15,  0x36u);
            }
          }
        }
      }

      ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))nw_protocol_error_print, *((void **)v2 + 42));
      if (*((void *)v5 + 40))
      {
        nw_queue_cancel_source();
        *((void *)v5 + 40) = 0LL;
      }

      nw_protocol_boringssl_internal_error(v5, -9858);
      nw_protocol_boringssl_disconnect((uint64_t)(v5 + 8));
      goto LABEL_27;
    }

    if (boringssl_session_in_false_start(*((void *)v2 + 42)))
    {
      if ((v5[475] & 1) != 0) {
        goto LABEL_26;
      }
      uint64_t v10 = (os_log_s *)g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO)) {
        goto LABEL_26;
      }
      int v15 = 136446978;
      size_t v16 = "nw_protocol_boringssl_handshake_negotiate_proceed";
      __int16 v17 = 1024;
      int v18 = 768;
      __int16 v19 = 2082;
      size_t v20 = v5 + 391;
      __int16 v21 = 2048;
      char v22 = v5;
      uint64_t v11 = "%{public}s(%d) %{public}s[%p] Signaling premature connect due to False Start";
LABEL_44:
      _os_log_impl(&dword_187560000, v10, OS_LOG_TYPE_INFO, v11, (uint8_t *)&v15, 0x26u);
LABEL_26:
      nw_protocol_boringssl_signal_connected(v5);
      nw_boringssl_read((uint64_t)(v5 + 8));
      goto LABEL_27;
    }

    if (boringssl_session_in_early_data(*((void *)v2 + 42)))
    {
      if ((v5[475] & 1) != 0) {
        goto LABEL_26;
      }
      uint64_t v10 = (os_log_s *)g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO)) {
        goto LABEL_26;
      }
      int v15 = 136446978;
      size_t v16 = "nw_protocol_boringssl_handshake_negotiate_proceed";
      __int16 v17 = 1024;
      int v18 = 772;
      __int16 v19 = 2082;
      size_t v20 = v5 + 391;
      __int16 v21 = 2048;
      char v22 = v5;
      uint64_t v11 = "%{public}s(%d) %{public}s[%p] Signaling premature connect in early data mode";
      goto LABEL_44;
    }
  }

LABEL_27:
  nw_boringssl_read((uint64_t)(v5 + 8));
LABEL_30:

  return v4;
}

                if (!*((void *)&v34[0] + 1))
                {
                  if (!v17) {
                    break;
                  }
                  char v22 = EVP_hpke_hkdf_sha256();
                  *(void *)&__int16 v23 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  v34[1] = v23;
                  v34[2] = v23;
                  v34[0] = v23;
                  CBB_zero(v34);
                  if (CBB_init((uint64_t)v34, (unint64_t)v36[1] + 8)
                    && CBB_add_bytes((uint64_t)v34, "tls ech", 8uLL)
                    && CBB_add_bytes((uint64_t)v34, v36[0], (size_t)v36[1])
                    && (int v24 = v37,
                        __int16 v25 = CBB_data((uint64_t)v34),
                        __int16 v26 = CBB_len((uint64_t)v34),
                        EVP_HPKE_CTX_setup_sender( (void *)(a1 + 736),  v30,  v32,  v31,  v13,  (uint64_t)v22,  (uint64_t)v17,  v24,  *((uint64_t *)&v24 + 1),  v25,  v26))
                    && bssl::SSLTranscript::Init((BUF_MEM **)(a1 + 464)))
                  {
                    uint64_t v27 = bssl::New<bssl::ECHConfig,bssl::ECHConfig>((uint64_t)v36);
                    char v33 = 0LL;
                    std::unique_ptr<bssl::ECHConfig,bssl::internal::Deleter>::reset[abi:ne180100](v29, (uint64_t)v27);
                    std::unique_ptr<bssl::ECHConfig,bssl::internal::Deleter>::reset[abi:ne180100](&v33, 0LL);
                    uint64_t v10 = *v29 != 0;
                  }

                  else
                  {
                    uint64_t v10 = 0;
                  }

                  CBB_cleanup((uint64_t)v34);
                  BOOL v12 = 0;
                  goto LABEL_42;
                }
              }
            }

            BOOL v12 = 1;
          }
        }

        else
        {
          BOOL v12 = 0;
          uint64_t v10 = 0;
        }

  if ((_BYTE)v11)
  {
    int v18 = v11 - 1LL;
    do
    {
      *(_BYTE *)(*(void *)v3 + *(void *)(v4 + 24) + v1_Block_object_dispose(va, 8) = v10;
      v10 >>= 8;
      --v18;
    }

    while (v18 < *(unsigned __int8 *)(v4 + 32));
  }

  if (v10)
  {
    BOOL v12 = 260;
    goto LABEL_32;
  }

  *(void *)(v4 + 16) = 0LL;
  uint64_t result = 1LL;
LABEL_36:
  *a1 = 0LL;
  return result;
}

#error "18756BBF4: call analysis failed (funcsize=96)"
void boringssl_context_start_handshake_timer(uint64_t a1)
{
  _BYTE *v1;
  id *v2;
  void *WeakRetained;
  uint64_t v4;
  id v5;
  void *v6;
  id *v7;
  uint64_t source;
  void *v9;
  void *v10;
  uint64_t v11;
  char v12;
  id v13;
  int64_t v14;
  os_log_s *v15;
  id v16;
  void *v17;
  _BYTE *v18;
  char v19;
  id v20;
  _BYTE *v21;
  BOOL v22;
  id *v23;
  if (*(_DWORD *)a1 == -1252936367)
  {
    id v1 = *(_BYTE **)(a1 + 8);
    if (v1)
    {
      if ((v1[556] & 0x20) != 0)
      {
        id v2 = v1;
        id WeakRetained = objc_loadWeakRetained(v2 + 2);
        uint64_t v4 = WeakRetained[40];

        if (v4)
        {
          id v5 = objc_loadWeakRetained(v2 + 2);
          nw_queue_cancel_source();

          uint64_t v6 = objc_loadWeakRetained(v2 + 2);
          v6[40] = 0LL;
        }

        __int16 v23 = v2;
        id v7 = v23;
        source = nw_queue_context_create_source();
        id v9 = objc_loadWeakRetained(v7 + 2);
        v9[40] = source;

        uint64_t v10 = objc_loadWeakRetained(v7 + 2);
        uint64_t v11 = v10[40];

        if (v11)
        {
          BOOL v12 = *((_BYTE *)v7 + 556);
          id v13 = objc_loadWeakRetained(v7 + 2);
          if ((v12 & 0x10) != 0) {
            uint64_t v14 = 10000000000LL;
          }
          else {
            uint64_t v14 = 2000000000LL;
          }
          dispatch_time(0LL, v14);
          nw_queue_set_timer_values();

          int v15 = (os_log_s *)objc_loadWeakRetained(v7 + 2);
          nw_queue_activate_source();
        }

        else
        {
          size_t v16 = objc_loadWeakRetained(v7 + 2);
          if (v16)
          {
            __int16 v17 = v16;
            int v18 = objc_loadWeakRetained(v7 + 2);
            __int16 v19 = v18[475];

            if ((v19 & 1) != 0) {
              goto LABEL_12;
            }
          }

          size_t v20 = objc_loadWeakRetained(v7 + 2);
          if (v20)
          {
            __int16 v21 = objc_loadWeakRetained(v7 + 2);
            char v22 = (v21[475] & 1) == 0;
          }

          else
          {
            char v22 = 1;
          }

          if (!v22 || !g_boringssl_log) {
            goto LABEL_12;
          }
          int v15 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
            boringssl_context_start_handshake_timer_cold_1(v7, v15);
          }
        }

LABEL_12:
      }
    }
  }

uint64_t boringssl_session_handshake_start(void *a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a1[1];
  if (!v3 || !*(void *)(v3 + 400)) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(v3 + 424) = boringssl_helper_get_current_time_ms();
  uint64_t v4 = *(SSL **)(v3 + 400);
  if ((*(_BYTE *)(v3 + 556) & 0x10) != 0) {
    int v5 = SSL_accept(v4);
  }
  else {
    int v5 = SSL_connect(v4);
  }
  if (v5 <= 0) {
    return boringssl_session_handshake_incomplete(a1, v5, 0);
  }
  int v7 = SSL_in_early_data(*(void *)(v3 + 400));
  id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    id v9 = WeakRetained;
    uint64_t v10 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16));
    id v1 = (char *)v10[475];
  }

  id v11 = objc_loadWeakRetained((id *)(v3 + 16));
  if (v11)
  {
    BOOL v12 = objc_loadWeakRetained((id *)(v3 + 16));
    BOOL v13 = (v12[475] & 1) == 0;
  }

  else
  {
    BOOL v13 = 1;
  }

  uint64_t result = 0LL;
  if (v13 && g_boringssl_log)
  {
    uint64_t v14 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      id v15 = objc_loadWeakRetained((id *)(v3 + 16));
      if (v15)
      {
        id v1 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
        size_t v16 = v1 + 391;
      }

      else
      {
        size_t v16 = &unk_1875F4C23;
      }

      id v17 = objc_loadWeakRetained((id *)(v3 + 16));
      int v18 = v17;
      int v20 = 136447234;
      __int16 v21 = "boringssl_session_handshake_start";
      __int16 v19 = "true";
      __int16 v22 = 1024;
      int v23 = 288;
      __int16 v24 = 2082;
      if (!v7) {
        __int16 v19 = "false";
      }
      __int16 v25 = v16;
      __int16 v26 = 2048;
      id v27 = v17;
      __int16 v28 = 2082;
      id v29 = v19;
      _os_log_impl( &dword_187560000,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] In early data: %{public}s",  (uint8_t *)&v20,  0x30u);

      if (v15) {
    }
      }

    return 0LL;
  }

  return result;
}

__darwin_time_t boringssl_helper_get_current_time_ms()
{
  v1.tv_sec = 0LL;
  *(void *)&v1.tv_usec = 0LL;
  gettimeofday(&v1, 0LL);
  return 1000 * v1.tv_sec + v1.tv_usec / 1000;
}

int SSL_connect(SSL *ssl)
{
  if (!*(void *)&ssl->rwstate)
  {
    BYTE4(ssl->param) &= ~1u;
    *(void *)&ssl->rwstate = bssl::ssl_client_handshake;
  }

  return SSL_do_handshake(ssl);
}

int SSL_do_handshake(SSL *s)
{
  *((_DWORD *)s->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (!*(void *)&s->rwstate)
  {
    ERR_put_error(16, 0, 134, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 887);
    LODWORD(v4) = -1;
    return v4;
  }

  uint64_t v3 = (bssl *)*((void *)s->handshake_func + 35);
  if (!v3 || (*((_BYTE *)v3 + 1584) & 8) != 0) {
    goto LABEL_13;
  }
  char v11 = 0;
  uint64_t v4 = bssl::ssl_run_handshake(v3, (bssl::SSL_HANDSHAKE *)&v11, v2);
  if ((BYTE4(s->param) & 1) != 0) {
    uint64_t v5 = 8194LL;
  }
  else {
    uint64_t v5 = 4098LL;
  }
  uint64_t v6 = *(void (**)(SSL *, uint64_t, uint64_t))&s->packet_length;
  if ((int)v4 >= 1)
  {
    if (!v11)
    {
      handshake_func = s->handshake_func;
      int v8 = (bssl::SSL_HANDSHAKE *)*((void *)handshake_func + 35);
      *((void *)handshake_func + 35) = 0LL;
      std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]( (bssl::SSL_HANDSHAKE **)handshake_func + 36,  v8);
      std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]( (bssl::SSL_HANDSHAKE **)s->handshake_func + 35,  0LL);
      bssl::ssl_maybe_shed_handshake_config((bssl *)s, v9);
    }

LABEL_13:
    LODWORD(v4) = 1;
  }

  return v4;
}

    ERR_put_error(29, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digest/digest.c", 138);
    goto LABEL_14;
  }

  uint64_t v4 = (uint64_t (**)(void))in->md_data;
  if (!v4) {
    EVP_MD_CTX_copy_ex_cold_3();
  }
  uint64_t v5 = v4[1]();
  if (v5)
  {
    uint64_t v6 = v5;
    digest = in->digest;
    if (!in->digest)
    {
      engine = 0LL;
      goto LABEL_16;
    }

    goto LABEL_9;
  }

  return v5;
}

  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(&v36, 8);

  return 1LL;
}

void ERR_clear_error(void)
{
  state = err_get_state();
  if (state)
  {
    timeval v1 = state;
    for (uint64_t i = 0LL; i != 48; i += 3LL)
    {
      uint64_t v3 = &v1[i];
      free((void *)v1[i + 1]);
      void *v3 = 0LL;
      v3[1] = 0LL;
      v3[2] = 0LL;
    }

    free((void *)v1[49]);
    v1[48] = 0LL;
    v1[49] = 0LL;
  }

void *err_get_state()
{
  thread_local = CRYPTO_get_thread_local(0);
  if (!thread_local)
  {
    id v2 = malloc(0x190uLL);
    thread_local = v2;
    if (v2)
    {
      v2[23] = 0u;
      v2[24] = 0u;
      v2[21] = 0u;
      v2[22] = 0u;
      v2[19] = 0u;
      v2[20] = 0u;
      v2[17] = 0u;
      v2[18] = 0u;
      v2[15] = 0u;
      v2[16] = 0u;
      v2[13] = 0u;
      v2[14] = 0u;
      v2[11] = 0u;
      v2[12] = 0u;
      v2[9] = 0u;
      v2[10] = 0u;
      v2[7] = 0u;
      v2[8] = 0u;
      v2[5] = 0u;
      v2[6] = 0u;
      v2[3] = 0u;
      v2[4] = 0u;
      v2[1] = 0u;
      v2[2] = 0u;
      *id v2 = 0u;
    }
  }

  return thread_local;
}

void *CRYPTO_get_thread_local(int a1)
{
  if (!g_thread_local_key_created) {
    return 0LL;
  }
  uint64_t result = pthread_getspecific(g_thread_local_key);
  if (result) {
    return (void *)result[a1];
  }
  return result;
}

uint64_t CRYPTO_set_thread_local(unsigned int a1, uint64_t a2, void (*a3)(uint64_t))
{
  if (!g_thread_local_key_created) {
    goto LABEL_9;
  }
  uint64_t v6 = pthread_getspecific(g_thread_local_key);
  if (!v6)
  {
    int v8 = malloc(0x28uLL);
    if (!v8) {
      goto LABEL_9;
    }
    uint64_t v6 = v8;
    *((void *)v8 + 4) = 0LL;
    _OWORD *v8 = 0u;
    v8[1] = 0u;
    if (pthread_setspecific(g_thread_local_key, v8))
    {
      free(v6);
      goto LABEL_9;
    }
  }

  if (!pthread_mutex_lock(&g_destructors_lock))
  {
    *((void *)&g_destructors + a1) = a3;
    pthread_mutex_unlock(&g_destructors_lock);
    *((void *)v6 + a1) = a2;
    return 1LL;
  }

LABEL_9:
  a3(a2);
  return 0LL;
}

    ++v2;
  }

  while (v2 < (unint64_t)EVP_MD_CTX_md(a1));
  return v3;
}

      if (v38) {
        continue;
      }
      goto LABEL_10;
    }

    break;
  }

  id v17 = 50;
LABEL_28:
  bssl::ssl_send_alert(v4, (ssl_st *)2, v17);
  return 0LL;
}

    uint64_t v4 = 256;
    LODWORD(c) = 256;
LABEL_10:
    if (alg_bits) {
LABEL_11:
    }
      *alg_unsigned int bits = v4;
  }

  return (int)c;
}

  *a1 = 0;
  return strlen(__s) + v4;
}

int *ERR_clear_system_error()
{
  uint64_t result = __error();
  *uint64_t result = 0;
  return result;
}

uint64_t bssl::ssl_run_handshake(bssl *this, bssl::SSL_HANDSHAKE *a2, BOOL *a3)
{
  uint64_t v5 = *(void *)this;
  while (2)
  {
    int v6 = *((_DWORD *)this + 4);
    switch(v6)
    {
      case 0:
        ERR_restore_state(*((void **)this + 48));
        return 0xFFFFFFFFLL;
      case 2:
      case 3:
      case 15:
        if (!*(void *)(v5 + 168))
        {
          v19[0] = 50;
          int v18 = 0LL;
          if (v6 == 15) {
            int v7 = bssl::ssl_open_change_cipher_spec((void *)v5, &v18, v19);
          }
          else {
            int v7 = bssl::ssl_open_handshake((void *)v5, &v18, v19);
          }
          int v8 = v7;
          if (v7 == 4 && *((_DWORD *)this + 4) == 2 && (ERR_peek_error() & 0xFF000FFF) == 0x10000410) {
            ERR_put_error(16, 0, 154, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 661);
          }
          char v17 = -86;
          uint64_t result = bssl::ssl_handle_open_record((bssl *)v5, &v17, v8, v18, v19[0]);
          if (!v17)
          {
            bssl::SSLBuffer::DiscardConsumed((_WORD *)(*(void *)(v5 + 48) + 80LL));
LABEL_18:
            int v10 = (*(uint64_t (**)(bssl *, bssl::SSL_HANDSHAKE *, BOOL *))(v5 + 40))(this, a2, a3);
            *((_DWORD *)this + 4) = v10;
            if (v10 == 1)
            {
              if ((*(_BYTE *)(v5 + 180) & 1) == 0 && *(_DWORD *)(*(void *)(v5 + 48) + 216LL) == 2) {
                bssl::ssl_run_handshake();
              }
              *(_BYTE *)a2 = 0;
              return 1LL;
            }

            if (!v10)
            {
              char v11 = ERR_save_state();
              std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]( (uint64_t *)this + 48,  (uint64_t)v11);
              return 0xFFFFFFFFLL;
            }
          }

          continue;
        }

        if (v6 == 15) {
          bssl::ssl_run_handshake();
        }
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 2;
LABEL_42:
        *(_DWORD *)(v12 + 1bssl::Array<unsigned short>::~Array(v1 - 96) = v13;
        int v14 = 1;
LABEL_43:
        *((_DWORD *)this + 4) = v14;
        return 0xFFFFFFFFLL;
      case 4:
        uint64_t result = (*(uint64_t (**)(uint64_t, bssl::SSL_HANDSHAKE *, BOOL *))(*(void *)v5 + 120LL))(v5, a2, a3);
        goto LABEL_18;
      case 5:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 12;
        goto LABEL_42;
      case 6:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 17;
        goto LABEL_42;
      case 7:
        uint64_t result = (*(uint64_t (**)(uint64_t, bssl::SSL_HANDSHAKE *, BOOL *))(*(void *)v5 + 120LL))(v5, a2, a3);
        *(_DWORD *)(*(void *)(v5 + 48) + 196LL) = 18;
        int v14 = 7;
        goto LABEL_43;
      case 8:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 4;
        goto LABEL_42;
      case 9:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 13;
        goto LABEL_42;
      case 10:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 11;
        goto LABEL_42;
      case 11:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 14;
        goto LABEL_42;
      case 12:
        if ((*(_BYTE *)(v5 + 180) & 1) == 0 && *(_DWORD *)(*(void *)(v5 + 48) + 216LL) == 2) {
          bssl::ssl_run_handshake();
        }
        uint64_t result = 1LL;
        *(_BYTE *)a2 = 1;
        *((_DWORD *)this + 4) = 1;
        return result;
      case 13:
        uint64_t v15 = *(void *)(v5 + 48);
        if (!*(_DWORD *)(v15 + 256)) {
          bssl::ssl_run_handshake();
        }
        if ((*((_BYTE *)this + 1585) & 0x20) != 0) {
          bssl::ssl_run_handshake();
        }
        int v16 = 15;
        goto LABEL_47;
      case 14:
        if ((*(_BYTE *)(*(void *)(*(void *)(v5 + 48) + 280LL) + 1585LL) & 0x10) != 0)
        {
          uint64_t result = 1LL;
          *(_BYTE *)a2 = 1;
          return result;
        }

        *((_DWORD *)this + 4) = 1;
        goto LABEL_18;
      case 16:
        uint64_t v12 = *(void *)(v5 + 48);
        int v13 = 16;
        goto LABEL_42;
      case 17:
        uint64_t v15 = *(void *)(v5 + 48);
        int v16 = 20;
LABEL_47:
        *(_DWORD *)(v15 + 1bssl::Array<unsigned short>::~Array(v1 - 96) = v16;
        return 0xFFFFFFFFLL;
      default:
        goto LABEL_18;
    }
  }

uint64_t bssl::ssl_client_handshake(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = (SSL_SESSION **)((char *)this + 1520);
  uint64_t v4 = (__int128 *)((char *)__b + 8);
  uint64_t v246 = *MEMORY[0x1895F89C0];
  v213 = (ssl_credential_st **)((char *)this + 1504);
  v210 = (EVP_PKEY **)((char *)this + 1512);
  v211 = (BUF_MEM **)((char *)this + 424);
  uint64_t v203 = (void **)((char *)this + 1488);
  int v200 = (unint64_t **)((char *)this + 1472);
  int v201 = (void **)((char *)this + 696);
  v209 = (void **)((char *)this + 1464);
  id v204 = (void **)((char *)this + 400);
  char v205 = (void **)((char *)this + 392);
  uint64_t v208 = (void **)((char *)this + 552);
  v202 = (SSL_SESSION **)((char *)this + 1528);
  v212 = (char *)this + 88;
  BOOL v214 = (_WORD *)((char *)this + 28);
  v215 = (_WORD *)((char *)this + 30);
  __dst = (char *)this + 1597;
  buf = (unsigned __int8 *)this + 504;
  while (2)
  {
    int v5 = *((_DWORD *)this + 5);
    switch(v5)
    {
      case 0:
        uint64_t v6 = *(void *)this;
        bssl::ssl_do_info_callback(*(void *)this, (const ssl_st *)0x10);
        *(_WORD *)(*(void *)(v6 + 48) + 220LL) &= ~0x40u;
        *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v243 = v7;
        __int128 v244 = v7;
        BOOL v218 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        int is_dtls = SSL_is_dtls(*(unsigned __int8 ***)this);
        unsigned int v10 = *((unsigned __int16 *)this + 15);
        if (v10 >= 0x303) {
          __int16 v11 = 771;
        }
        else {
          __int16 v11 = *((_WORD *)this + 15);
        }
        if (v10 <= 0x302) {
          __int16 v12 = -257;
        }
        else {
          __int16 v12 = -259;
        }
        if (!is_dtls) {
          __int16 v12 = v11;
        }
        *((_WORD *)this + 794) = v12;
        uint64_t v13 = *(void *)(v6 + 104);
        if (v13
          && ((*(_BYTE *)(v13 + 440) & 0x10) != 0
           || !bssl::ssl_supports_version((uint64_t)this, *(unsigned __int16 *)(v13 + 4))
           || *((void *)this + 193)
           && bssl::ssl_session_protocol_version(*(bssl **)(v6 + 104), v14) < 0x304
           || !SSL_SESSION_is_resumable(*(void *)(v6 + 104))
           || !bssl::ssl_session_is_time_valid((bssl *)v6, *(const ssl_st **)(v6 + 104), v9)
           || (*(void *)(v6 + 168) == 0LL) == (*(_BYTE *)(*(void *)(v6 + 104) + 440LL) & 0x20) >> 5
           || (*(_WORD *)(*(void *)(v6 + 48) + 220LL) & 0x20) != 0))
        {
          bssl::ssl_set_session((ssl_st **)v6, 0LL, v9);
        }

        if (!RAND_bytes((unsigned __int8 *)(*(void *)(v6 + 48) + 48LL), 32)
          || *((void *)this + 193) && !RAND_bytes(buf, 32))
        {
          goto LABEL_393;
        }

        if (*(void *)(v6 + 168)) {
          goto LABEL_27;
        }
        uint64_t v145 = *(void *)(v6 + 104);
        if (!v145) {
          goto LABEL_409;
        }
        size_t v146 = *(unsigned __int8 *)(v145 + 59);
        uint64_t v147 = *(void *)(v145 + 240);
        if (*(_BYTE *)(v145 + 59))
        {
          if (!v147)
          {
            *((_BYTE *)this + 1629) = v146;
            memcpy(__dst, (const void *)(v145 + 60), v146);
            goto LABEL_27;
          }
        }

        else if (!v147)
        {
LABEL_409:
        }

        *((_BYTE *)this + 1629) = 32;
LABEL_27:
        uint64_t v15 = *(void *)this;
        if (*((unsigned __int16 *)this + 14) >= 0x304u && !*(void *)(v15 + 104))
        {
          int v16 = *(unsigned int (**)(uint64_t, __int128 *, __int128 *, _BYTE *, __int128 *, _BYTE *, _OWORD *, unsigned int *))(*(void *)(v15 + 8) + 80LL);
          if (v16)
          {
            *(void *)&__int128 v240 = 0LL;
            memset(__b, 170, sizeof(__b));
            *(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __int128 v237 = v17;
            __int128 v238 = v17;
            __int128 __src = v17;
            __int128 v236 = v17;
            __int128 v233 = v17;
            __int128 v234 = v17;
            __int128 v231 = v17;
            __int128 v232 = v17;
            __int128 v229 = v17;
            __int128 v230 = v17;
            __int128 v227 = v17;
            __int128 v228 = v17;
            __int128 v225 = v17;
            __int128 v226 = v17;
            __int128 v223 = v17;
            __int128 v224 = v17;
            __int128 v221 = v17;
            __int128 v222 = v17;
            v220[0] = v17;
            v220[1] = v17;
            unsigned int v216 = 256;
            *(void *)__n = 0x40000000040LL;
            if (!v16(v15, &v240, __b, &__n[4], &__src, __n, v220, &v216) && (void)v240)
            {
              int v18 = SSL_SESSION_new();
              uint64_t v19 = (uint64_t)v18;
              LOWORD(v18->key_arg_length) = 772;
              v18->cipher = (SSL_CIPHER *)v240;
              char v20 = __n[0];
              if (*(_DWORD *)__n <= 0x2Fu)
              {
                memcpy(&v18->key_arg[3], &__src, *(unsigned int *)__n);
                *(_BYTE *)(v19 + 10) = v20;
              }

              size_t v21 = v216;
              SSL_SESSION_set_ticket(v19, __b, *(unsigned int *)&__n[4]);
              *(_DWORD *)(v19 + 380) = ((__int16)(*(unsigned __int8 *)(v15 + 180) << 13) >> 15) & 0x3800;
              *(_BYTE *)(v19 + 440) |= 0x80u;
              SSL_set_session((SSL *)v15, (SSL_SESSION *)v19);
            }

            uint64_t v15 = *(void *)this;
          }
        }

        if ((*(_BYTE *)(v15 + 180) & 1) != 0) {
          bssl::ssl_client_handshake();
        }
        if ((*(_BYTE *)(v15 + 180) & 4) != 0)
        {
          if ((unsigned __int16)*v215 >= 0x304u)
          {
            uint64_t v148 = *(bssl **)(v15 + 104);
            if (v148)
            {
              if (bssl::ssl_session_protocol_version(v148, (const ssl_session_st *)a2) >= 0x304)
              {
                uint64_t v149 = *(void *)(v15 + 104);
                if (*(_DWORD *)(v149 + 380))
                {
                  size_t v150 = *(void *)(v149 + 400);
                  if (v150)
                  {
                    if (!bssl::ssl_is_alpn_protocol_allowed(this, *(const void **)(v149 + 392), v150))
                    {
                      int v22 = 9;
                      goto LABEL_419;
                    }

                    uint64_t v151 = *(void *)(v15 + 104);
                    if ((*(_BYTE *)(v151 + 440) & 0x40) != 0)
                    {
                      __b[0] = 0uLL;
                      if (!bssl::ssl_get_local_application_settings( (uint64_t)this,  __b,  *(void **)(v151 + 392),  *(void *)(v151 + 400))
                        || (uint64_t v186 = *(void *)(v15 + 104),
                            size_t v187 = *(void *)(v186 + 416),
                            *((void *)&__b[0] + 1) != v187)
                        || memcmp(*(const void **)&__b[0], *(const void **)(v186 + 408), v187))
                      {
                        int v22 = 14;
                        goto LABEL_419;
                      }
                    }
                  }

                  *((_DWORD *)this + 396) |= 0x800u;
LABEL_420:
                  if (bssl::ssl_setup_key_shares(this, 0LL)
                    && bssl::ssl_setup_extension_permutation(this, a2)
                    && bssl::ssl_encrypt_client_hello((uint64_t)this, &v243, (size_t)v218)
                    && bssl::ssl_add_client_hello(this, a2))
                  {
                    *((_DWORD *)this + 5) = 1;
                    goto LABEL_48;
                  }

                  goto LABEL_393;
                }
              }

              int v22 = 7;
            }

            else
            {
              int v22 = 5;
            }
          }

          else
          {
            int v22 = 3;
          }
        }

        else
        {
          int v22 = 1;
        }

LABEL_419:
        *(_DWORD *)(*(void *)(v6 + 48) + 256LL) = v22;
        goto LABEL_420;
      case 1:
        uint64_t v63 = *(void *)this;
        if (SSL_is_dtls(*(unsigned __int8 ***)this))
        {
          int v40 = 3;
          goto LABEL_474;
        }

        if ((*((_BYTE *)this + 1585) & 8) == 0)
        {
LABEL_214:
          int v40 = 4;
          goto LABEL_474;
        }

        bssl::SSLAEADContext::SetVersionIfNullCipher( *(void *)(*(void *)(v63 + 48) + 272LL),  *(_WORD *)(*(void *)(v63 + 104) + 4LL));
        if (!(*(unsigned int (**)(uint64_t))(*(void *)v63 + 112LL))(v63)
          || !bssl::tls13_init_early_key_schedule(this, *(ssl_cipher_st ***)(v63 + 104), v122)
          || !bssl::tls13_derive_early_secret(this, a2))
        {
          goto LABEL_393;
        }

        uint64_t v123 = *(SSL_SESSION **)(v63 + 104);
        if (v123) {
          SSL_SESSION_up_ref(*(unsigned int **)(v63 + 104));
        }
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v202, v123);
        int v40 = 2;
        goto LABEL_474;
      case 2:
        uint64_t v50 = *(void *)this;
        if (!*(_BYTE *)(*(void *)(*(void *)this + 120LL) + 496LL)) {
          goto LABEL_244;
        }
        int v51 = bssl::ssl_reverify_peer_cert((bssl **)this, 0LL);
        if (v51 == 1) {
          goto LABEL_393;
        }
        if (v51 == 2)
        {
          uint64_t finished = 16LL;
LABEL_246:
          *((_DWORD *)this + 5) = v51;
          goto LABEL_476;
        }

        uint64_t v50 = *(void *)this;
LABEL_244:
        if (bssl::tls13_set_traffic_key( v50,  (const ssl_session_st *)1,  1LL,  *((bssl **)this + 191),  v212,  *((void *)this + 4)))
        {
          *((_DWORD *)this + 396) |= 0x2400u;
          uint64_t finished = 12LL;
          int v51 = 4;
          goto LABEL_246;
        }

        goto LABEL_393;
      case 3:
        id v38 = *(bssl **)this;
        *(void *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v59 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v59 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v59;
        __b[1] = v59;
        if (BYTE1(__b[0]) != 3) {
          goto LABEL_214;
        }
        v220[0] = *v4;
        *(void *)&__int128 __src = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        LOWORD(v243) = -21846;
        if (!CBS_get_u16((unsigned __int16 **)v220, &v243)
          || !CBS_get_u8_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src)
          || *((void *)&v220[0] + 1))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 706);
          bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
          goto LABEL_393;
        }

        __int128 v60 = __src;
        char v61 = bssl::Array<unsigned char>::Init((uint64_t)v208, *((unint64_t *)&__src + 1));
        char v62 = v61 ^ 1;
        if (!*((void *)&v60 + 1)) {
          char v62 = 1;
        }
        if ((v62 & 1) == 0) {
          memmove(*v208, (const void *)v60, *((size_t *)&v60 + 1));
        }
        if ((v61 & 1) == 0) {
          goto LABEL_430;
        }
        (*(void (**)(bssl *))(*(void *)v38 + 32LL))(v38);
        if (bssl::SSLTranscript::Init(v211) && bssl::ssl_add_client_hello(this, a2))
        {
          uint64_t finished = 4LL;
          *((_DWORD *)this + 5) = 4;
          goto LABEL_476;
        }

        goto LABEL_393;
      case 4:
        uint64_t v41 = *(void *)this;
        *(void *)&__int128 v221 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v42 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[0] = v42;
        v220[1] = v42;
        if (!(*(unsigned int (**)(uint64_t, _OWORD *))(*(void *)v41 + 24LL))(v41, v220))
        {
          uint64_t finished = 2LL;
          goto LABEL_476;
        }

        *(void *)&__int128 v43 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[3] = v43;
        __b[4] = v43;
        __b[1] = v43;
        __b[2] = v43;
        __b[0] = v43;
        LOWORD(__b[1]) = 0;
        WORD4(__b[3]) = 0;
        BYTE10(__b[3]) = 0;
        LOWORD(v21_Block_object_dispose(va, 8) = -21846;
        __n[4] = 50;
        unsigned int v44 = LOWORD(__b[1]);
        if (LOWORD(__b[1]) != 771) {
          goto LABEL_358;
        }
        __int128 __src = 0xAAAAAAAA0001002BLL;
        *(void *)&__int128 v236 = 0LL;
        __int128 v243 = __b[4];
        *(void *)&__int128 v240 = &__src;
        if (BYTE3(__src))
        {
          if (!CBS_get_u16((unsigned __int16 **)&__src + 1, &v218) || (void)v236)
          {
            __n[4] = 50;
LABEL_392:
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, __n[4]);
            goto LABEL_393;
          }

          unsigned int v44 = (unsigned __int16)v218;
        }

        else
        {
          unsigned int v44 = LOWORD(__b[1]);
LABEL_358:
          LOWORD(v21_Block_object_dispose(va, 8) = v44;
        }

        if (!bssl::ssl_supports_version((uint64_t)this, v44))
        {
          ERR_put_error(16, 0, 240, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 780);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 70);
          goto LABEL_393;
        }

        uint64_t v155 = *(void *)(v41 + 48);
        unsigned int v156 = *(unsigned __int16 *)(v155 + 220);
        if ((v156 & 2) != 0)
        {
          if ((unsigned __int16)v218 != *(unsigned __int16 *)(v41 + 16))
          {
            ERR_put_error(16, 0, 246, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 793);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 70);
            goto LABEL_393;
          }
        }

        else
        {
          *(_WORD *)(v41 + 16) = (_WORD)v218;
          *(_WORD *)(v155 + 220) |= 2u;
          bssl::SSLAEADContext::SetVersionIfNullCipher(*(void *)(*(void *)(v41 + 48) + 272LL), *(_WORD *)(v41 + 16));
        }

        if (bssl::ssl_protocol_version((bssl *)v41, v154) >= 0x304)
        {
          int v40 = 5;
          goto LABEL_474;
        }

        std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v205, 0LL);
        std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v204, 0LL);
        bssl::ssl_done_writing_client_hello(this, v157);
        int v158 = *((_DWORD *)this + 396);
        if ((v158 & 0x800) != 0)
        {
          *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v158 & 0xFFFFDFFF;
          ERR_put_error(16, 0, 278, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 818);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 70);
          goto LABEL_393;
        }

        uint64_t v159 = *(void *)(v41 + 48);
        if (*((void *)this + 193)) {
          *(_DWORD *)(v159 + 216) = 2;
        }
        __int128 v160 = *(_OWORD *)(*((void *)&__b[1] + 1) + 16LL);
        *(_OWORD *)(v159 + 16) = **((_OWORD **)&__b[1] + 1);
        *(_OWORD *)(v159 + 32) = v160;
        if ((*(_BYTE *)(*(void *)(v41 + 48) + 220LL) & 0x20) == 0
          && bssl::ssl_supports_version((uint64_t)this, 0x304u))
        {
          uint64_t v161 = *(void *)(v41 + 48);
          if (*(void *)(v161 + 40) == *(void *)"DOWNGRD"
            || *(void *)(v161 + 40) == 0x14452474E574F44LL
            || *(void *)(v161 + 40) == 0xFF1047C2A8B4BFEDLL)
          {
            ERR_put_error(16, 0, 297, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 846);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_393;
          }
        }

        cipher_by_value = SSL_get_cipher_by_value(WORD4(__b[3]));
        uint64_t v163 = (uint64_t)cipher_by_value;
        if (!cipher_by_value
          || (int v164 = 8 * (*(void *)(*((void *)this + 1) + 64LL) == 0LL), (cipher_by_value[5] & v164) != 0)
          || (cipher_by_value[6] & v164) != 0
          || (unsigned int min_version = SSL_CIPHER_get_min_version(cipher_by_value),
              min_version > bssl::ssl_protocol_version((bssl *)v41, v166))
          || (unsigned int max_version = SSL_CIPHER_get_max_version(v163),
              max_version < bssl::ssl_protocol_version((bssl *)v41, v168))
          || (ciphers = SSL_get_ciphers((const SSL *)v41),
              !OPENSSL_sk_find( (uint64_t)ciphers,  0LL,  v163,  (uint64_t (*)(void, uint64_t, void))sk_SSL_CIPHER_call_cmp_func)))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 862);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
          goto LABEL_393;
        }

        *((void *)this + 194) = v163;
        v170 = (ssl_session_st *)*((unsigned __int8 *)this + 1629);
        if (*((_BYTE *)this + 1629) && CBS_mem_equal((uint64_t)&__b[2] + 8, __dst, (uint64_t)v170))
        {
          uint64_t v171 = *(void *)(v41 + 104);
          if (!v171 || *(_DWORD *)(*(void *)(v41 + 48) + 216LL) == 2)
          {
            ERR_put_error(16, 0, 286, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 880);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_393;
          }

          if (*(unsigned __int16 *)(v171 + 4) != *(unsigned __int16 *)(v41 + 16))
          {
            ERR_put_error(16, 0, 188, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 885);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_393;
          }

          if (*(void *)(v171 + 200) != *((void *)this + 194))
          {
            ERR_put_error(16, 0, 187, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 890);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_393;
          }

          if (!bssl::ssl_session_is_context_valid(this, (const bssl::SSL_HANDSHAKE *)v171, v170))
          {
            ERR_put_error(16, 0, 101, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 897);
            bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
            goto LABEL_393;
          }

          uint64_t v196 = *(void *)(v41 + 48);
          __int16 v197 = *(_WORD *)(v196 + 220);
          if ((v197 & 0x20) != 0) {
            bssl::ssl_client_handshake();
          }
          *(_WORD *)(v196 + 220) = v197 | 0x40;
        }

        else
        {
          bssl::ssl_set_session((ssl_st **)v41, 0LL, v170);
          if ((bssl::ssl_get_new_session(this, v188) & 1) == 0) {
            goto LABEL_481;
          }
          size_t v190 = *(void *)&__b[3];
          if (*(void *)&__b[3] >= 0x21uLL) {
            bssl::ssl_client_handshake();
          }
          id v191 = *v3;
          (*v3)->master_key[39] = __b[3];
          if (v190)
          {
            memcpy(&v191->master_key[40], *((const void **)&__b[2] + 1), v190);
            id v191 = *v3;
          }

          v191->cipher = (SSL_CIPHER *)*((void *)this + 194);
        }

        uint64_t v192 = (bssl *)bssl::ssl_protocol_version((bssl *)v41, v189);
        if (!bssl::SSLTranscript::InitHash((size_t **)v211, v192, *((const ssl_cipher_st **)this + 194))
          || (bssl::ssl_hash_message((uint64_t)this, (uint64_t)v220) & 1) == 0)
        {
          goto LABEL_481;
        }

        if (*(void *)(v41 + 104) || !bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 194), v193)) {
          bssl::SSLTranscript::FreeBuffer(v211);
        }
        if (BYTE10(__b[3]))
        {
          ERR_put_error(16, 0, 238, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 944);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 47);
          goto LABEL_393;
        }

        if ((bssl::ssl_parse_serverhello_tlsext((uint64_t)this, &__b[4]) & 1) == 0)
        {
          ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 950);
          goto LABEL_393;
        }

        uint64_t v194 = *(void *)(v41 + 104);
        if (!v194 || (int v195 = *(_BYTE *)(v194 + 440) & 1, (HIWORD(*((_DWORD *)this + 396)) & 1) == v195))
        {
          (*(void (**)(uint64_t))(*(void *)v41 + 32LL))(v41);
          if (*(void *)(v41 + 104))
          {
            if (*(_BYTE *)(*(void *)(v41 + 120) + 496LL)
              && bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 194), (const ssl_cipher_st *)a2))
            {
              int v40 = 9;
            }

            else
            {
              int v40 = 18;
            }
          }

          else
          {
            int v40 = 6;
          }

          goto LABEL_474;
        }

        if (v195) {
          ERR_put_error(16, 0, 204, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 957);
        }
        else {
          ERR_put_error(16, 0, 205, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 959);
        }
        bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 40);
        goto LABEL_393;
      case 5:
        uint64_t finished = bssl::tls13_client_handshake(this, (ssl_st *)a2);
        if ((_DWORD)finished != 1) {
          goto LABEL_476;
        }
        int v49 = 21;
        goto LABEL_199;
      case 6:
        BOOL v67 = *(bssl **)this;
        if (!bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 194), (const ssl_cipher_st *)a2)) {
          goto LABEL_139;
        }
        *(void *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v68 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v68;
        __b[1] = v68;
        if (!bssl::ssl_check_message_type(v67, (uint64_t)__b, 11)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_393;
        }

        v220[0] = *v4;
        LOBYTE(__src) = 50;
        if (!bssl::ssl_parse_cert_chain( (char *)&__src,  (unint64_t **)&(*v3)->sid_ctx[28],  v210,  0LL,  (unsigned __int8 **)v220,  *(void ***)(*((void *)v67 + 15) + 776LL)))
        {
          bssl::ssl_send_alert(v67, (ssl_st *)2, __src);
          goto LABEL_393;
        }

        if (!EVP_MD_CTX_md(*(const EVP_MD_CTX **)&(*v3)->sid_ctx[28])
          || *((void *)&v220[0] + 1)
          || ((*(uint64_t (**)(SSL_SESSION *))(*(void *)(*((void *)v67 + 15) + 16LL) + 48LL))(*v3) & 1) == 0)
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1020);
          bssl::ssl_send_alert(v67, (ssl_st *)2, 50);
          goto LABEL_393;
        }

        id v69 = (ssl_st *)*((void *)this + 189);
        OPENSSL_sk_value(*(unint64_t **)(*((void *)this + 190) + 136LL), 0LL);
        if ((bssl::ssl_check_leaf_certificate((uint64_t)this, v69) & 1) == 0)
        {
          bssl::ssl_send_alert(v67, (ssl_st *)2, 47);
          goto LABEL_393;
        }

        (*(void (**)(bssl *))(*(void *)v67 + 32LL))(v67);
LABEL_139:
        int v40 = 7;
        goto LABEL_474;
      case 7:
        if ((*((_BYTE *)this + 1584) & 0x40) == 0) {
          goto LABEL_114;
        }
        id v38 = *(bssl **)this;
        *(void *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v75 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v75 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v75;
        __b[1] = v75;
        if (BYTE1(__b[0]) != 22) {
          goto LABEL_114;
        }
        v220[0] = *v4;
        *(void *)&__int128 __src = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        LOBYTE(v243) = -86;
        if (!CBS_get_u8(v220, &v243)
          || v243 != 1
          || !CBS_get_u24_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src)
          || !*((void *)&__src + 1)
          || *((void *)&v220[0] + 1))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1069);
          bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
          goto LABEL_393;
        }

        uint64_t v76 = *v3;
        BOOL v77 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&__src, *(void ***)(*((void *)v38 + 15) + 776LL));
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]( (unsigned int **)&v76->tlsext_hostname,  v77);
        if (!(*v3)->tlsext_hostname) {
          goto LABEL_430;
        }
        (*(void (**)(bssl *))(*(void *)v38 + 32LL))(v38);
LABEL_114:
        int v40 = 8;
        goto LABEL_474;
      case 8:
        if (bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 194), (const ssl_cipher_st *)a2))
        {
          int v74 = bssl::ssl_verify_peer_cert(this, a2);
          if (v74 == 1) {
            goto LABEL_393;
          }
          BOOL v48 = v74 == 2;
          if (v74 == 2) {
            int v49 = 8;
          }
          else {
            int v49 = 10;
          }
LABEL_154:
          if (v48) {
            uint64_t finished = 16LL;
          }
          else {
            uint64_t finished = 1LL;
          }
        }

        else
        {
          uint64_t finished = 1LL;
          int v49 = 10;
        }

        int v5 = 0LL;
        goto LABEL_420;
      case 5:
        int v47 = bssl::tls13_add_certificate_verify(this, a2);
        if (v47)
        {
          if (v47 == 2) {
            goto LABEL_280;
          }
          if (v47 != 1) {
            bssl::tls13_server_handshake();
          }
          int v5 = 9LL;
          size_t v21 = 5;
        }

        else
        {
          size_t v21 = 6;
        }

        goto LABEL_211;
      case 6:
        BOOL v48 = *((_DWORD *)this + 396);
        if ((v48 & 0x80000) != 0)
        {
LABEL_103:
          int v5 = 17LL;
          goto LABEL_281;
        }

        int v49 = *(void *)this;
        *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v48 | 0x1000000;
        bssl::SSLTranscript::DigestLen((bssl::SSLTranscript *)v176);
        if (!bssl::tls13_advance_key_schedule((uint64_t)this)
          || !bssl::tls13_derive_application_secrets(this, a2)
          || !bssl::tls13_set_traffic_key( v49,  (const ssl_session_st *)3,  1LL,  *((bssl **)this + 190),  v169,  *((void *)this + 4)))
        {
          goto LABEL_280;
        }

        *((_DWORD *)this + 6) = 7;
        if ((*((_BYTE *)this + 1586) & 4) != 0) {
          int v5 = 7LL;
        }
        else {
          int v5 = 1LL;
        }
        goto LABEL_281;
      case 7:
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x400) == 0) {
          goto LABEL_55;
        }
        if (*(void *)(*(void *)this + 168LL)
          || (bssl::SSLTranscript::Update( v176,  &bssl::do_send_half_rtt_ticket(bssl::SSL_HANDSHAKE *)::kEndOfEarlyData,  4uLL) & 1) != 0)
        {
          *(void *)((char *)&d.version + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (bssl::tls13_finished_mac(this, v174, (unsigned __int8 *)&d.version + 1, 0LL))
          {
            if (*(void *)((char *)&d.version + 1) == *((void *)this + 4))
            {
              id v79 = *((void *)this + 4);
              if (v79 >= 0x100) {
                bssl::tls13_server_handshake();
              }
              *(_WORD *)((char *)&d.ex_data.sk + 1) = 20;
              BYTE3(d.ex_data.sk) = 0;
              BYTE4(d.ex_data.sk) = v79;
              if (bssl::SSLTranscript::Update(v176, (char *)&d.ex_data.sk + 1, 4uLL)
                && bssl::SSLTranscript::Update(v176, v174, *((void *)this + 4))
                && bssl::tls13_derive_resumption_secret(this, a2)
                && (bssl::add_new_session_tickets( (ssl_st **)this,  (bssl::SSL_HANDSHAKE *)((char *)&d.verify_callback + 1),  (BOOL *)a3) & 1) != 0)
              {
LABEL_55:
                *((_DWORD *)this + 6) = 8;
                int v5 = 4LL;
                goto LABEL_281;
              }
            }

            else
            {
              ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1016);
            }
          }
        }

        else
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1005);
        }

        goto LABEL_280;
      case 8:
        __int128 v53 = *(void *)this;
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x400) == 0) {
          goto LABEL_112;
        }
        if (!bssl::tls13_set_traffic_key( *(void *)this,  (const ssl_session_st *)1,  0LL,  *((bssl **)this + 190),  v175,  *((void *)this + 4))) {
          goto LABEL_280;
        }
        *((_DWORD *)this + 396) |= 0x3400u;
LABEL_112:
        if (*(void *)(v53 + 168))
        {
          if (!bssl::tls13_set_traffic_key( v53,  (const ssl_session_st *)2,  0LL,  *((bssl **)this + 190),  v177,  *((void *)this + 4))) {
            goto LABEL_280;
          }
          __int128 v54 = 12;
        }

        else
        {
          __int128 v54 = 14;
        }

        *((_DWORD *)this + 6) = 9;
        if ((*(_WORD *)(*(void *)(v53 + 48) + 220LL) & 0x400) != 0) {
          int v5 = v54;
        }
        else {
          int v5 = 1LL;
        }
        goto LABEL_281;
      case 9:
        uint64_t v30 = *(bssl **)this;
        if (*(void *)(*(void *)this + 168LL)) {
          goto LABEL_53;
        }
        if ((*(_WORD *)(*((void *)v30 + 6) + 220LL) & 0x400) == 0) {
          goto LABEL_189;
        }
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&char v91 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v91 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v91;
        *(_OWORD *)((char *)&d.rbio + 1) = v91;
        if (*(BIO **)((char *)&d.rbio + 1))
        {
          bssl::ssl_send_alert(v30, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1089);
        }

        else
        {
          (*(void (**)(bssl *))(*(void *)v30 + 32LL))(v30);
LABEL_189:
          if (bssl::tls13_set_traffic_key( (uint64_t)v30,  (const ssl_session_st *)2,  0LL,  *((bssl **)this + 190),  v177,  *((void *)this + 4)))
          {
LABEL_53:
            size_t v21 = 10;
            goto LABEL_211;
          }
        }

        goto LABEL_280;
      case 10:
        if ((*(_BYTE *)(*((void *)this + 190) + 440LL) & 0x40) == 0) {
          goto LABEL_51;
        }
        int v22 = *(bssl **)this;
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x400) != 0) {
          goto LABEL_51;
        }
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&int v23 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v23;
        *(_OWORD *)((char *)&d.rbio + 1) = v23;
        *(_OWORD *)((char *)&d.verify_callback + 1) = *(_OWORD *)((char *)&d.method + 1);
        *(void *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16_length_prefixed( (unsigned __int8 **)((char *)&d.verify_callback + 1),  (unint64_t *)&d.sid_ctx[13])
          || *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1122);
          bssl::ssl_send_alert(v22, (ssl_st *)2, 50);
          goto LABEL_280;
        }

        if ((*(_WORD *)(*((void *)this + 1) + 301LL) & 0x2000) != 0) {
          int v24 = 17613;
        }
        else {
          int v24 = 17513;
        }
        *(STACK **)((char *)&d.ex_data.sk + 1) = (STACK *)0xAAAAAAAA0001AAAALL;
        *(_WORD *)((char *)&d.ex_data.sk + 1) = v24;
        *(void *)((char *)&d.ex_data.dummy + 1) = 0LL;
        *(STACK **)((char *)&d.client_CA + 1) = 0LL;
        BYTE1(d.read_hash) = 50;
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.ex_data.sk + 1);
        if ((bssl::ssl_parse_extensions( (__int128 *)&d.sid_ctx[13],  (char *)&d.read_hash + 1,  (uint64_t *)((char *)&d.tlsext_debug_cb + 1),  1LL,  0) & 1) == 0)
        {
          int v94 = BYTE1(d.read_hash);
          goto LABEL_279;
        }

        if (!BYTE4(d.ex_data.sk))
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 1140);
          int v94 = 109;
          goto LABEL_279;
        }

        __int16 v25 = (void **)&(*v172)[1].sid_ctx[28];
        __int16 v26 = *(const void **)((char *)&d.ex_data.dummy + 1);
        __int128 v27 = *(size_t *)((char *)&d.client_CA + 1);
        __int128 v28 = bssl::Array<unsigned char>::Init((uint64_t)v25, *(unint64_t *)((char *)&d.client_CA + 1));
        id v29 = v28 ^ 1;
        if (!v27) {
          id v29 = 1;
        }
        if ((v29 & 1) == 0) {
          memmove(*v25, v26, v27);
        }
        if (!v28 || (bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1) & 1) == 0)
        {
          int v94 = 80;
          goto LABEL_279;
        }

        (*(void (**)(bssl *))(*(void *)v22 + 32LL))(v22);
LABEL_51:
        *((_DWORD *)this + 6) = 11;
        int v5 = 1LL;
        goto LABEL_281;
      case 11:
        int v72 = *(bssl **)this;
        if ((*((_BYTE *)this + 1584) & 0x20) == 0)
        {
          if ((*(_WORD *)(*((void *)v72 + 6) + 220LL) & 0x40) == 0) {
            (*v172)->timeout = 0LL;
          }
          goto LABEL_147;
        }

        id v80 = *(_BYTE *)(*((void *)this + 1) + 300LL);
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&v81 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v81 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v81;
        *(_OWORD *)((char *)&d.rbio + 1) = v81;
        if (!(*(unsigned int (**)(bssl *, char *))(*(void *)v72 + 24LL))(v72, (char *)&d.version + 1))
        {
LABEL_220:
          int v5 = 3LL;
          goto LABEL_281;
        }

        if (bssl::ssl_check_message_type(v72, (uint64_t)&d.version + 1, 11)
          && bssl::tls13_process_certificate((EVP_PKEY **)this, (uint64_t)&d.version + 1, (v80 & 2) == 0)
          && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1))
        {
          (*(void (**)(bssl *))(*(void *)v72 + 32LL))(v72);
          goto LABEL_184;
        }

        goto LABEL_280;
      case 12:
        uint64_t v50 = *(bssl **)this;
        if (!EVP_MD_CTX_md(*(const EVP_MD_CTX **)(*((void *)this + 190) + 136LL))) {
          goto LABEL_147;
        }
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&int v51 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v51 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v51;
        *(_OWORD *)((char *)&d.rbio + 1) = v51;
        __int16 v52 = bssl::ssl_verify_peer_cert(this, a2);
        if (v52 == 1) {
          goto LABEL_280;
        }
        if (v52 == 2)
        {
          int v5 = 16LL;
LABEL_184:
          size_t v21 = 12;
        }

        else
        {
          if (!bssl::ssl_check_message_type(v50, (uint64_t)&d.version + 1, 15)
            || !bssl::tls13_process_certificate_verify((uint64_t)this, (uint64_t)&d.version + 1)
            || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1))
          {
            goto LABEL_280;
          }

          (*(void (**)(bssl *))(*(void *)v50 + 32LL))(v50);
LABEL_147:
          size_t v21 = 13;
        }

LABEL_199:
        *((_DWORD *)this + 5) = v49;
        goto LABEL_476;
      case 9:
        if (!*(_BYTE *)(*(void *)(*(void *)this + 120LL) + 496LL)) {
          bssl::ssl_client_handshake();
        }
        int v47 = bssl::ssl_reverify_peer_cert((bssl **)this, (bssl::SSL_HANDSHAKE *)1);
        if (v47 == 1) {
          goto LABEL_393;
        }
        BOOL v48 = v47 == 2;
        if (v47 == 2) {
          int v49 = 9;
        }
        else {
          int v49 = 18;
        }
        goto LABEL_154;
      case 10:
        uint64_t v41 = *(void *)this;
        *(void *)&__int128 v221 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v70 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v70 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[0] = v70;
        v220[1] = v70;
        if (BYTE1(v220[0]) == 12)
        {
          uint64_t v71 = *((void *)this + 194);
          int v72 = *(_DWORD *)(v71 + 20);
          int v73 = *(_DWORD *)(v71 + 24);
          __int128 __src = *(_OWORD *)((char *)v220 + 8);
          if ((v73 & 8) != 0)
          {
            *((void *)&__b[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&__b[0] = 0xAAAAAAAAAAAAAAAALL;
            if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&__src, (unint64_t *)__b))
            {
              ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1156);
              int v142 = 50;
              goto LABEL_387;
            }

            if (*((void *)&__b[0] + 1) > 0x80uLL || CBS_contains_zero_byte((uint64_t)__b))
            {
              ERR_put_error(16, 0, 136, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1170);
              int v142 = 40;
              goto LABEL_387;
            }

            *(void *)&__int128 v243 = 0LL;
            if (*((void *)&__b[0] + 1))
            {
              if (!CBS_strdup((uint64_t)__b, (void **)&v243))
              {
LABEL_481:
                bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 80);
                goto LABEL_393;
              }

              uint64_t v174 = (void *)v243;
            }

            else
            {
              uint64_t v174 = 0LL;
            }

            std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v209, v174);
            if ((v72 & 2) == 0) {
              goto LABEL_147;
            }
          }

          else if ((v72 & 2) == 0)
          {
LABEL_147:
            if ((v72 & 8) == 0)
            {
              ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1216);
              bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 10);
              goto LABEL_393;
            }

            goto LABEL_446;
          }

          LOBYTE(vbssl::Array<unsigned short>::~Array(v16 + 240) = -86;
          LOWORD(v243) = -21846;
          *((void *)&__b[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&__b[0] = 0xAAAAAAAAAAAAAAAALL;
          if (CBS_get_u8(&__src, &v240)
            && v240 == 3
            && CBS_get_u16((unsigned __int16 **)&__src, &v243)
            && CBS_get_u8_length_prefixed((unsigned __int8 **)&__src, (unint64_t *)__b))
          {
            if (bssl::tls1_check_group_id((bssl **)this, (const ssl_st *)(unsigned __int16)v243))
            {
              HIWORD((*v3)->key_arg_length) = v243;
              __int128 v175 = __b[0];
              char v176 = bssl::Array<unsigned char>::Init((uint64_t)v201, *((unint64_t *)&__b[0] + 1));
              char v177 = v176 ^ 1;
              if (!*((void *)&v175 + 1)) {
                char v177 = 1;
              }
              if ((v177 & 1) == 0) {
                memmove(*v201, (const void *)v175, *((size_t *)&v175 + 1));
              }
              if ((v176 & 1) == 0) {
                goto LABEL_393;
              }
LABEL_446:
              v179 = (const void *)*((void *)&v220[0] + 1);
              uint64_t v178 = *(void *)&v220[1];
              uint64_t v180 = *((void *)&__src + 1);
              if (!bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 194), (const ssl_cipher_st *)a2))
              {
                if (v73 != 8) {
                  bssl::ssl_client_handshake();
                }
                if (*((void *)&__src + 1))
                {
                  ERR_put_error( 16,  0,  151,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1287);
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 50);
LABEL_393:
                  uint64_t finished = 0LL;
                  goto LABEL_476;
                }

                goto LABEL_472;
              }

              LOWORD(v21_Block_object_dispose(va, 8) = 0;
              if (bssl::ssl_protocol_version((bssl *)v41, v181) < 0x303)
              {
                if ((bssl::tls1_get_legacy_signature_algorithm((bssl *)&v218, (unsigned __int16 *)*v210, v182) & 1) == 0)
                {
                  ERR_put_error( 16,  0,  193,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1245);
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 43);
                  goto LABEL_393;
                }
              }

              else
              {
                if (!CBS_get_u16((unsigned __int16 **)&__src, &v218))
                {
                  ERR_put_error( 16,  0,  137,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1233);
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 50);
                  goto LABEL_393;
                }

                LOBYTE(__b[0]) = 50;
                if (!bssl::tls12_check_peer_sigalg( this,  (const bssl::SSL_HANDSHAKE *)__b,  (unsigned __int8 *)(unsigned __int16)v218))
                {
                  bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, LOBYTE(__b[0]));
                  goto LABEL_393;
                }

                *(_WORD *)(*v3)->key_arg = (_WORD)v218;
              }

              *(void *)&__int128 v243 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v243 + 1) = 0xAAAAAAAAAAAAAAAALL;
              if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&__src, (unint64_t *)&v243)
                || *((void *)&__src + 1))
              {
                ERR_put_error( 16,  0,  137,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1254);
                bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 50);
                goto LABEL_393;
              }

              *(void *)&__int128 v183 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v183 + 1) = 0xAAAAAAAAAAAAAAAALL;
              __b[1] = v183;
              __b[2] = v183;
              __b[0] = v183;
              CBB_zero(__b);
              __int128 v240 = 0uLL;
              if (CBB_init((uint64_t)__b, v178 - v180 + 64)
                && CBB_add_bytes((uint64_t)__b, (const void *)(*(void *)(v41 + 48) + 48LL), 0x20uLL)
                && CBB_add_bytes((uint64_t)__b, (const void *)(*(void *)(v41 + 48) + 16LL), 0x20uLL)
                && CBB_add_bytes((uint64_t)__b, v179, v178 - v180)
                && bssl::CBBFinishArray((uint64_t)__b, (uint64_t)&v240))
              {
                if (bssl::ssl_public_key_verify( (bssl *)v41,  v243,  *((uint64_t *)&v243 + 1),  (evp_pkey_st *)(unsigned __int16)v218,  *v210,  (const void *)v240,  *((size_t *)&v240 + 1)))
                {
                  char v184 = 1;
                  goto LABEL_471;
                }

                ERR_put_error( 16,  0,  114,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1278);
                int v185 = 51;
              }

              else
              {
                ERR_put_error( 16,  0,  68,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1270);
                int v185 = 80;
              }

              bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, v185);
              char v184 = 0;
LABEL_471:
              bssl::Array<unsigned short>::~Array((uint64_t)&v240);
              CBB_cleanup((uint64_t)__b);
              if ((v184 & 1) == 0) {
                goto LABEL_393;
              }
LABEL_472:
              (*(void (**)(uint64_t))(*(void *)v41 + 32LL))(v41);
              goto LABEL_473;
            }

            ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1205);
            int v142 = 47;
          }

          else
          {
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1198);
            int v142 = 50;
          }

LABEL_387:
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, v142);
          goto LABEL_393;
        }

        if (bssl::ssl_cipher_requires_server_key_exchange( *((bssl **)this + 194),  (const ssl_cipher_st *)a2))
        {
          ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1134);
          bssl::ssl_send_alert((bssl *)v41, (ssl_st *)2, 10);
          goto LABEL_393;
        }

LABEL_473:
        int v40 = 11;
LABEL_474:
        *((_DWORD *)this + 5) = v40;
LABEL_475:
        uint64_t finished = 1LL;
LABEL_476:
        if (*((_DWORD *)this + 5) != v5) {
          bssl::ssl_do_info_callback(*(void *)this, (const ssl_st *)0x1001);
        }
        if ((_DWORD)finished == 1) {
          continue;
        }
        return finished;
      case 11:
        id v38 = *(bssl **)this;
        if (!bssl::ssl_cipher_uses_certificate_auth(*((bssl **)this + 194), (const ssl_cipher_st *)a2)) {
          goto LABEL_62;
        }
        *(void *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v39;
        __b[1] = v39;
        if (BYTE1(__b[0]) == 14)
        {
          bssl::SSLTranscript::FreeBuffer(v211);
LABEL_62:
          int v40 = 12;
          goto LABEL_474;
        }

        if (!bssl::ssl_check_message_type(v38, (uint64_t)__b, 13)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_393;
        }

        v220[0] = *v4;
        *(void *)&__int128 __src = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u8_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src))
        {
          bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1328);
          goto LABEL_393;
        }

        __int128 v132 = __src;
        char v134 = bssl::Array<unsigned char>::Init((uint64_t)v203, *((unint64_t *)&__src + 1));
        char v135 = v134 ^ 1;
        if (!*((void *)&v132 + 1)) {
          char v135 = 1;
        }
        if ((v135 & 1) == 0) {
          memmove(*v203, (const void *)v132, *((size_t *)&v132 + 1));
        }
        if ((v134 & 1) == 0)
        {
LABEL_430:
          bssl::ssl_send_alert(v38, (ssl_st *)2, 80);
          goto LABEL_393;
        }

        if (bssl::ssl_protocol_version(v38, v133) >= 0x303)
        {
          *(void *)&__int128 v243 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v243 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&v243)
            || (bssl::tls1_parse_peer_sigalgs((bssl **)this, (ssl_st *)&v243) & 1) == 0)
          {
            bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1342);
            goto LABEL_393;
          }
        }

        LOBYTE(vbssl::Array<unsigned short>::~Array(v16 + 240) = 50;
        *(void *)&__int128 v243 = 0xAAAAAAAAAAAAAAAALL;
        bssl::ssl_parse_client_CA_list((uint64_t)v38, &v240, (unsigned __int8 **)v220, (unint64_t **)&v243);
        v136 = (unint64_t *)v243;
        if ((void)v243)
        {
          if (*((void *)&v220[0] + 1))
          {
            bssl::ssl_send_alert(v38, (ssl_st *)2, 50);
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1357);
            uint64_t finished = 0LL;
          }

          else
          {
            *((_DWORD *)this + 396) |= 0x20u;
            *(void *)&__int128 v243 = 0LL;
            std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v200, v136);
            (*(void (**)(bssl *))(*(void *)(*((void *)v38 + 15) + 16LL) + 80LL))(this);
            (*(void (**)(bssl *))(*(void *)v38 + 32LL))(v38);
            *((_DWORD *)this + 5) = 12;
            uint64_t finished = 1LL;
          }
        }

        else
        {
          bssl::ssl_send_alert(v38, (ssl_st *)2, v240);
          uint64_t finished = 0LL;
        }

        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)&v243,  0LL);
        goto LABEL_476;
      case 12:
        id v45 = *(bssl **)this;
        *(void *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v46 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v46 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v46;
        __b[1] = v46;
        if (!bssl::ssl_check_message_type(v45, (uint64_t)__b, 14)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_393;
        }

        if (*(void *)&__b[1])
        {
          bssl::ssl_send_alert(v45, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1385);
          goto LABEL_393;
        }

        if ((*(unsigned int (**)(bssl *))(*(void *)v45 + 40LL))(v45))
        {
          bssl::ssl_send_alert(v45, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1392);
          goto LABEL_393;
        }

        (*(void (**)(bssl *))(*(void *)v45 + 32LL))(v45);
        int v40 = 13;
        goto LABEL_474;
      case 13:
        if ((*((_BYTE *)this + 1584) & 0x20) == 0)
        {
          int v40 = 14;
          goto LABEL_474;
        }

        BOOL v86 = *(bssl **)this;
        if (*(_DWORD *)(*(void *)(*(void *)this + 48LL) + 216LL) == 2)
        {
          SSL_certs_clear(*(void *)this);
        }

        else
        {
          uint64_t v100 = *(void *)(*((void *)this + 1) + 32LL);
          id v101 = *(uint64_t (**)(void, void))(v100 + 64);
          if (v101)
          {
            int v102 = v101(*(void *)this, *(void *)(v100 + 72));
            if (!v102)
            {
              bssl::ssl_send_alert(v86, (ssl_st *)2, 80);
              ERR_put_error(16, 0, 126, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1455);
              goto LABEL_393;
            }

            if (v102 < 0)
            {
              *((_DWORD *)this + 5) = 13;
              uint64_t finished = 8LL;
              goto LABEL_476;
            }
          }
        }

        __b[0] = 0uLL;
        if ((bssl::ssl_get_credential_list(this, (void **)__b) & 1) == 0) {
          goto LABEL_354;
        }
        if (!*((void *)&__b[0] + 1))
        {
          bssl::SSLTranscript::FreeBuffer(v211);
          goto LABEL_351;
        }

        int v199 = v4;
        v103 = *(uint64_t **)&__b[0];
        uint64_t v104 = 8LL * *((void *)&__b[0] + 1);
        while (2)
        {
          uint64_t v105 = *v103;
          ERR_clear_error();
          LOWORD(v220[0]) = -21846;
          if (*(_DWORD *)(v105 + 4))
          {
            int v107 = 1404;
LABEL_225:
            ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", v107);
LABEL_238:
            ++v103;
            v104 -= 8LL;
            if (!v104) {
              goto LABEL_350;
            }
            continue;
          }

          break;
        }

        if ((*(_WORD *)(*((void *)this + 1) + 301LL) & 0x4000) != 0)
        {
          int v109 = EVP_PKEY_id(*(void *)(v105 + 8));
          if (v109 == 6)
          {
            int v110 = 1;
          }

          else
          {
            if (v109 != 949 && v109 != 408)
            {
              int v107 = 1420;
              goto LABEL_225;
            }

            int v110 = 64;
          }

          v111 = (char *)*((void *)this + 186);
          size_t v112 = *((void *)this + 187);
          __int16 v113 = (char *)memchr(v111, v110, v112);
          int v114 = v113 ? v113 : &v111[v112];
          if (v114 - v111 == v112)
          {
            int v107 = 1425;
            goto LABEL_225;
          }
        }

        if (!bssl::tls1_choose_signature_algorithm( this,  (EVP_PKEY **)v105,  (const ssl_credential_st *)v220,  v106)) {
          goto LABEL_238;
        }
        SSL_CREDENTIAL_up_ref(v105);
        std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100](v213, (ssl_credential_st *)v105);
        *((_WORD *)this + 797) = v220[0];
LABEL_350:
        uint64_t v4 = v199;
        if (!*v213)
        {
          bssl::ssl_send_alert(v86, (ssl_st *)2, 40);
          goto LABEL_354;
        }

LABEL_351:
        if (bssl::ssl_send_tls12_certificate(this, v108))
        {
          *((_DWORD *)this + 5) = 14;
          uint64_t finished = 1LL;
          goto LABEL_355;
        }

LABEL_354:
        uint64_t finished = 0LL;
LABEL_355:
        OPENSSL_free(*(void **)&__b[0]);
        goto LABEL_476;
      case 14:
        __int16 v26 = *(bssl **)this;
        *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v236 = v27;
        __int128 v237 = v27;
        __int128 __src = v27;
        CBB_zero(&__src);
        *(void *)&__int128 v28 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v244 = v28;
        __int128 v245 = v28;
        __int128 v243 = v28;
        if (((*(uint64_t (**)(bssl *, __int128 *, __int128 *, uint64_t))(*(void *)v26 + 88LL))( v26,  &__src,  &v243,  16LL) & 1) == 0)
        {
          uint64_t finished = 0LL;
          goto LABEL_417;
        }

        BOOL v218 = 0LL;
        size_t v219 = 0LL;
        uint64_t v30 = (bssl *)*((void *)this + 194);
        int v31 = *((_DWORD *)v30 + 5);
        int v32 = *((_DWORD *)v30 + 6);
        if (!bssl::ssl_cipher_uses_certificate_auth(v30, v29)) {
          goto LABEL_52;
        }
        char v33 = OPENSSL_sk_value(*(unint64_t **)&(*v3)->sid_ctx[28], 0LL);
        *((void *)&__b[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__b[0] = 0xAAAAAAAAAAAAAAAALL;
        CRYPTO_BUFFER_init_CBS((uint64_t)v33, __b);
        if ((bssl::ssl_cert_check_key_usage(__b, 2 * (v31 & 1u)) & 1) != 0) {
          goto LABEL_52;
        }
        ERR_clear_error();
        *(_WORD *)(*((void *)v26 + 6) + 220LL) |= 0x4000u;
LABEL_52:
        *(void *)&__int128 v34 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[14] = v34;
        __b[15] = v34;
        __b[12] = v34;
        __b[13] = v34;
        __b[10] = v34;
        __b[11] = v34;
        __b[8] = v34;
        __b[9] = v34;
        __b[6] = v34;
        __b[7] = v34;
        __b[4] = v34;
        __b[5] = v34;
        __b[2] = v34;
        __b[3] = v34;
        __b[0] = v34;
        __b[1] = v34;
        if ((v32 & 8) == 0)
        {
          unsigned int v35 = 0;
          goto LABEL_54;
        }

        uint64_t v115 = *((void *)this + 1);
        if (!*(void *)(v115 + 64))
        {
          int v36 = 1543;
          int v37 = 196;
          goto LABEL_306;
        }

        v116 = v4;
        LOBYTE(v227) = 0;
        __int128 v225 = 0u;
        __int128 v226 = 0u;
        __int128 v223 = 0u;
        __int128 v224 = 0u;
        __int128 v221 = 0u;
        __int128 v222 = 0u;
        memset(v220, 0, sizeof(v220));
        unsigned int v117 = (*(uint64_t (**)(bssl *, void, _OWORD *, uint64_t, __int128 *, uint64_t))(v115 + 64))( v26,  *v209,  v220,  129LL,  __b,  256LL);
        unsigned int v35 = v117;
        if (v117)
        {
          if (v117 >= 0x101) {
            __assert_rtn("do_send_client_key_exchange", "handshake_client.cc", 1557, "psk_len <= PSK_MAX_PSK_LEN");
          }
          id v118 = *v3;
          __int16 v119 = (char *)OPENSSL_strdup((const char *)v220);
          std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((void **)&v118->sid_ctx[20], v119);
          if (*(void *)&(*v3)->sid_ctx[20])
          {
            *(void *)&__int128 v120 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v120 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __int128 v241 = v120;
            __int128 v242 = v120;
            __int128 v240 = v120;
            uint64_t v4 = v116;
            size_t v121 = OPENSSL_strnlen((uint64_t)v220, 0x81uLL);
LABEL_54:
            if ((v31 & 1) != 0)
            {
              OPENSSL_free(v218);
              BOOL v218 = 0LL;
              size_t v219 = 0LL;
              BOOL v218 = (unsigned __int8 *)OPENSSL_malloc(0x30uLL);
              if (!v218) {
                goto LABEL_415;
              }
              size_t v219 = 48LL;
              id v137 = (const RSA *)EVP_PKEY_get0_RSA((uint64_t)*v210);
              if (!v137)
              {
                ERR_put_error( 16,  0,  68,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  1582);
                uint64_t finished = 0LL;
                goto LABEL_416;
              }

              *BOOL v218 = *((_BYTE *)this + 1589);
              v218[1] = *((_BYTE *)this + 1588);
              if (!RAND_bytes(v218 + 2, 46)) {
                goto LABEL_415;
              }
              *(void *)&__int128 v138 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v138 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v220[1] = v138;
              __int128 v221 = v138;
              v220[0] = v138;
              *(void *)&__int128 v240 = 0xAAAAAAAAAAAAAAAALL;
              *(void *)&__n[4] = 0xAAAAAAAAAAAAAAAALL;
              unsigned int v139 = RSA_size(v137);
              uint64_t v140 = v240;
              unsigned int v141 = RSA_size(v137);
              if (!RSA_encrypt((uint64_t)v137, (uint64_t *)&__n[4], v140, v141, (uint64_t)v218, v219, 1)
                || !CBB_did_write((uint64_t)v220, *(uint64_t *)&__n[4])
                || !CBB_flush((uint64_t *)&v243))
              {
                goto LABEL_415;
              }

              goto LABEL_345;
            }

            if ((v31 & 2) == 0)
            {
              if ((v31 & 8) == 0)
              {
                bssl::ssl_send_alert(v26, (ssl_st *)2, 40);
                int v36 = 1632;
                int v37 = 68;
LABEL_306:
                ERR_put_error( 16,  0,  v37,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  v36);
                uint64_t finished = 0LL;
                goto LABEL_416;
              }

              if (v219) {
                bzero(v218, v219);
              }
              goto LABEL_345;
            }

            *(void *)&__int128 v143 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v143 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v220[1] = v143;
            __int128 v221 = v143;
            v220[0] = v143;
            *(void *)&__int128 v240 = 0xAAAAAAAAAAAAAAAALL;
            bssl::SSLKeyShare::Create((void *)HIWORD((*v3)->key_arg_length), &v240);
            int v144 = 50;
            __n[4] = 50;
            if ((void)v240)
            {
              if (((*(uint64_t (**)(void, _OWORD *, unsigned __int8 **, _BYTE *, void, void))(*(void *)v240 + 32LL))( v240,  v220,  &v218,  &__n[4],  *((void *)this + 87),  *((void *)this + 88)) & 1) != 0)
              {
                if (CBB_flush((uint64_t *)&v243))
                {
                  OPENSSL_free(*v201);
                  *int v201 = 0LL;
                  v201[1] = 0LL;
                  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)&v240, 0LL);
LABEL_345:
                  if ((v32 & 8) == 0)
                  {
LABEL_346:
                    if (bssl::ssl_add_message_cbb((uint64_t)v26, (uint64_t)&__src))
                    {
                      unsigned __int8 master_secret = bssl::tls1_generate_master_secret( (uint64_t *)this,  (_BYTE *)(*((void *)this + 190) + 11LL),  (char *)v218,  v219);
                      uint64_t v153 = *v3;
                      (*v3)->key_arg[2] = master_secret;
                      if (master_secret)
                      {
                        LOBYTE(v153[1].peer) = (uint64_t)v153[1].peer & 0xFE | *((_BYTE *)this + 1586) & 1;
                        *((_DWORD *)this + 5) = 15;
                        uint64_t finished = 1LL;
                        goto LABEL_416;
                      }
                    }

                    goto LABEL_415;
                  }

                  *(void *)&__int128 v172 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v172 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  v220[1] = v172;
                  __int128 v221 = v172;
                  v220[0] = v172;
                  CBB_zero(v220);
                  *(void *)&__int128 v173 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v173 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  __int128 v241 = v173;
                  __int128 v242 = v173;
                  __int128 v240 = v173;
                  if (CBB_init((uint64_t)v220, v219 + v35 + 4)
                    && CBB_add_u16_length_prefixed((uint64_t *)v220, (uint64_t)&v240)
                    && CBB_add_bytes((uint64_t)&v240, v218, v219)
                    && CBB_add_u16_length_prefixed((uint64_t *)v220, (uint64_t)&v240)
                    && CBB_add_bytes((uint64_t)&v240, __b, v35)
                    && bssl::CBBFinishArray((uint64_t)v220, (uint64_t)&v218))
                  {
                    CBB_cleanup((uint64_t)v220);
                    goto LABEL_346;
                  }

                  CBB_cleanup((uint64_t)v220);
LABEL_415:
                  uint64_t finished = 0LL;
LABEL_416:
                  OPENSSL_free(v218);
LABEL_417:
                  CBB_cleanup((uint64_t)&__src);
                  goto LABEL_476;
                }

LABEL_414:
                std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)&v240, 0LL);
                goto LABEL_415;
              }

              int v144 = __n[4];
            }

            bssl::ssl_send_alert(v26, (ssl_st *)2, v144);
            goto LABEL_414;
          }
        }

        else
        {
          ERR_put_error(16, 0, 195, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1553);
          bssl::ssl_send_alert(v26, (ssl_st *)2, 40);
        }

        uint64_t finished = 0LL;
        uint64_t v4 = v116;
        goto LABEL_416;
      case 15:
        if ((*((_BYTE *)this + 1584) & 0x20) == 0 || !*v213)
        {
          int v40 = 16;
          goto LABEL_474;
        }

        __int16 v52 = *(bssl **)this;
        *(void *)&__int128 v53 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[1] = v53;
        __b[2] = v53;
        __b[0] = v53;
        CBB_zero(__b);
        *(void *)&__int128 v54 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v54 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[1] = v54;
        __int128 v221 = v54;
        v220[0] = v54;
        __int128 v236 = v54;
        __int128 v237 = v54;
        __int128 __src = v54;
        if (((*(uint64_t (**)(bssl *, __int128 *, _OWORD *, uint64_t))(*(void *)v52 + 88LL))( v52,  __b,  v220,  15LL) & 1) == 0) {
          goto LABEL_215;
        }
        if (!*((_WORD *)this + 797)) {
          __assert_rtn("do_send_client_certificate_verify", "handshake_client.cc", 1683, "hs->signature_algorithm != 0");
        }
        if (bssl::ssl_protocol_version(v52, v55) < 0x303
          || CBB_add_u16((uint64_t)v220, *((unsigned __int16 *)this + 797)))
        {
          int v56 = EVP_PKEY_size(*((EVP_PKEY **)*v213 + 1));
          *(void *)&__int128 v243 = 0xAAAAAAAAAAAAAAAALL;
          if (!CBB_add_u16_length_prefixed((uint64_t *)v220, (uint64_t)&__src)
            || !CBB_reserve((uint64_t)&__src, &v243, v56))
          {
LABEL_215:
            uint64_t finished = 0LL;
            goto LABEL_216;
          }

          *(void *)&__int128 v240 = v56;
          int v57 = bssl::ssl_private_key_sign( (uint64_t)this,  (void *)v243,  (unint64_t *)&v240,  v56,  (evp_pkey_st *)*((unsigned __int16 *)this + 797),  *(const void **)(*((void *)this + 53) + 8LL),  **((void **)this + 53));
          if (v57 == 1)
          {
            uint64_t finished = 9LL;
            int v58 = 15;
          }

          else
          {
            if (v57 == 2
              || !CBB_did_write((uint64_t)&__src, v240)
              || !bssl::ssl_add_message_cbb((uint64_t)v52, (uint64_t)__b))
            {
              goto LABEL_215;
            }

            bssl::SSLTranscript::FreeBuffer(v211);
            uint64_t finished = 1LL;
            int v58 = 16;
          }

          *((_DWORD *)this + 5) = v58;
        }

        else
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1687);
          uint64_t finished = 0LL;
        }

LABEL_216:
        CBB_cleanup((uint64_t)__b);
        goto LABEL_476;
      case 16:
        int v23 = *(void **)this;
        *((_DWORD *)this + 396) |= 0x1000000u;
        if (!(*(unsigned int (**)(void *, bssl::SSL_HANDSHAKE *))(*v23 + 112LL))(v23, a2)
          || !bssl::tls1_change_cipher_state(this, (const bssl::SSL_HANDSHAKE *)1))
        {
          goto LABEL_393;
        }

        int v24 = *((_DWORD *)this + 396);
        if ((v24 & 0x4000) != 0)
        {
          int v125 = *(_DWORD *)(v23[6] + 488LL);
          *(void *)&__int128 v126 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v126 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __b[1] = v126;
          __b[2] = v126;
          __b[0] = v126;
          CBB_zero(__b);
          *(void *)&__int128 v127 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v127 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v220[1] = v127;
          __int128 v221 = v127;
          v220[0] = v127;
          __int128 v236 = v127;
          __int128 v237 = v127;
          __int128 __src = v127;
          if (!(*(unsigned int (**)(void *, __int128 *, _OWORD *, uint64_t))(*v23 + 88LL))( v23,  __b,  v220,  67LL)
            || !CBB_add_u8_length_prefixed((uint64_t *)v220, (uint64_t)&__src)
            || !CBB_add_bytes( (uint64_t)&__src,  *(const void **)(v23[6] + 480LL),  *(void *)(v23[6] + 488LL))
            || !CBB_add_u8_length_prefixed((uint64_t *)v220, (uint64_t)&__src)
            || !CBB_add_bytes( (uint64_t)&__src,  &bssl::do_send_client_finished(bssl::SSL_HANDSHAKE *)::kZero,  32LL - (((_BYTE)v125 + 2) & 0x1F))
            || (bssl::ssl_add_message_cbb((uint64_t)v23, (uint64_t)__b) & 1) == 0)
          {
            ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1747);
            CBB_cleanup((uint64_t)__b);
            goto LABEL_393;
          }

          CBB_cleanup((uint64_t)__b);
          if ((*((_DWORD *)this + 396) & 0x2000000) == 0) {
            goto LABEL_46;
          }
        }

        else if ((v24 & 0x2000000) == 0)
        {
          goto LABEL_46;
        }

        *(void *)&__int128 v128 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v128 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[1] = v128;
        __b[2] = v128;
        __b[0] = v128;
        CBB_zero(__b);
        *(void *)&__int128 v129 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v129 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v220[1] = v129;
        __int128 v221 = v129;
        v220[0] = v129;
        if (!(*(unsigned int (**)(void *, __int128 *, _OWORD *, uint64_t))(*v23 + 88LL))( v23,  __b,  v220,  203LL)
          || !bssl::tls1_write_channel_id((uint64_t)this, (uint64_t *)v220, v130, v131)
          || (bssl::ssl_add_message_cbb((uint64_t)v23, (uint64_t)__b) & 1) == 0)
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1758);
          CBB_cleanup((uint64_t)__b);
          goto LABEL_393;
        }

        CBB_cleanup((uint64_t)__b);
LABEL_46:
        *((_DWORD *)this + 5) = 17;
LABEL_48:
        uint64_t finished = 4LL;
        goto LABEL_476;
      case 17:
        uint64_t v64 = *(void *)this;
        if (*(void *)(*(void *)this + 104LL))
        {
          int v40 = 21;
          goto LABEL_474;
        }

        *((_DWORD *)this + 5) = 18;
        if ((SSL_get_mode(v64) & 0x80) == 0) {
          goto LABEL_475;
        }
        id v97 = *(const SSL **)this;
        if (SSL_version(v97) != 771) {
          goto LABEL_475;
        }
        uint64_t v98 = *((void *)this + 194);
        if (*(_DWORD *)(v98 + 20) != 2) {
          goto LABEL_475;
        }
        if (*(_DWORD *)(v98 + 32) != 8) {
          goto LABEL_475;
        }
        handshake_func = v97->handshake_func;
        if (*((_DWORD *)handshake_func + 54) == 2
          || (v97->s2[2].challenge_length & 0x100) == 0
          && !*((void *)handshake_func + 63)
          && !*((void *)handshake_func + 61))
        {
          goto LABEL_475;
        }

        if ((*(_WORD *)(*(void *)(v64 + 48) + 220LL) & 0x20) != 0) {
          goto LABEL_475;
        }
        *((_DWORD *)this + 396) |= 0x2200u;
        uint64_t finished = 12LL;
        goto LABEL_476;
      case 18:
        if ((*((_BYTE *)this + 1585) & 0x80) == 0) {
          goto LABEL_141;
        }
        v87 = *(bssl **)this;
        *(void *)&__b[2] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v88 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v88 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[0] = v88;
        __b[1] = v88;
        if (!(*(unsigned int (**)(bssl *, __int128 *))(*(void *)v87 + 24LL))(v87, __b))
        {
LABEL_196:
          uint64_t finished = 3LL;
          goto LABEL_476;
        }

        if (!bssl::ssl_check_message_type(v87, (uint64_t)__b, 4)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)__b))
        {
          goto LABEL_393;
        }

        v220[0] = *v4;
        *(void *)&__int128 __src = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&__src + 1) = 0xAAAAAAAAAAAAAAAALL;
        LODWORD(vbssl::Array<unsigned short>::~Array(v16 + 240) = -1431655766;
        if (!CBS_get_u32((uint64_t *)v220, (int *)&v240)
          || !CBS_get_u16_length_prefixed((unsigned __int8 **)v220, (unint64_t *)&__src)
          || *((void *)&v220[0] + 1))
        {
          bssl::ssl_send_alert(v87, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1862);
          goto LABEL_393;
        }

        if (!*((void *)&__src + 1))
        {
          *((_DWORD *)this + 396) &= ~0x8000u;
          (*(void (**)(bssl *))(*(void *)v87 + 32LL))(v87);
          goto LABEL_141;
        }

        v90 = (bssl *)*((void *)v87 + 13);
        if (!v90) {
          goto LABEL_190;
        }
        if (*v3) {
          bssl::ssl_client_handshake();
        }
        bssl::SSL_SESSION_dup(v90, (ssl_session_st *)2, &v243);
        char v91 = (SSL_SESSION *)v243;
        *(void *)&__int128 v243 = 0LL;
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v3, v91);
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)&v243, 0LL);
        if (*v3)
        {
          (*v3)[1].session_id[24] |= 1u;
LABEL_190:
          bssl::ssl_session_rebase_time(v87, (ssl_st *)*v3, v89);
          p_dummy = (void **)&(*v3)->ex_data.dummy;
          __int128 v93 = __src;
          int v94 = bssl::Array<unsigned char>::Init((uint64_t)p_dummy, *((unint64_t *)&__src + 1));
          char v95 = v94 ^ 1;
          if (!*((void *)&v93 + 1)) {
            char v95 = 1;
          }
          if ((v95 & 1) == 0) {
            memmove(*p_dummy, (const void *)v93, *((size_t *)&v93 + 1));
          }
          if (v94)
          {
            uint64_t v96 = *((void *)this + 190);
            *(_DWORD *)(v96 + 372) = v240;
            SHA256((const unsigned __int8 *)__src, *((size_t *)&__src + 1), (unsigned __int8 *)(v96 + 60));
            *(_BYTE *)(*((void *)this + 190) + 59LL) = 32;
            (*(void (**)(bssl *))(*(void *)v87 + 32LL))(v87);
LABEL_141:
            *((_DWORD *)this + 5) = 19;
            uint64_t finished = 15LL;
            goto LABEL_476;
          }
        }

        goto LABEL_393;
      case 19:
        int v40 = 20;
        goto LABEL_474;
      case 20:
        uint64_t v65 = *(void *)this;
        uint64_t finished = bssl::ssl_get_finished(this, a2);
        if ((_DWORD)finished != 1) {
          goto LABEL_476;
        }
        if (*(void *)(v65 + 104)) {
          int v49 = 16;
        }
        else {
          int v49 = 21;
        }
        goto LABEL_199;
      case 21:
        uint64_t v66 = *(void *)this;
        if (*(_DWORD *)(*(void *)(*(void *)this + 48LL) + 216LL) == 2)
        {
          *((_DWORD *)this + 396) |= 2u;
          bssl::ssl_send_alert((bssl *)v66, (ssl_st *)2, 121);
          ERR_put_error(16, 0, 319, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 1940);
          goto LABEL_393;
        }

        (*(void (**)(void, bssl::SSL_HANDSHAKE *))(*(void *)v66 + 128LL))(*(void *)this, a2);
        size_t v78 = *v3;
        if (!*v3)
        {
          uint64_t v124 = *(SSL_SESSION **)(v66 + 104);
          if (!v124) {
            bssl::ssl_client_handshake();
          }
          SSL_SESSION_up_ref(*(unsigned int **)(v66 + 104));
          id v84 = (SSL_SESSION **)(*(void *)(v66 + 48) + 472LL);
          v85 = v124;
          goto LABEL_263;
        }

        bssl::SSL_SESSION_dup((bssl *)*v3, (ssl_session_st *)3, __b);
        id v79 = (SSL_SESSION **)(*(void *)(v66 + 48) + 472LL);
        id v80 = *(SSL_SESSION **)&__b[0];
        *(void *)&__b[0] = 0LL;
        std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v79, v80);
        v81 = *(SSL_SESSION **)&__b[0];
        *(void *)&__b[0] = 0LL;
        if (v81) {
          SSL_SESSION_free(v81);
        }
        uint64_t v82 = *(void *)(v66 + 48);
        uint64_t v83 = *(void *)(v82 + 472);
        if (v83)
        {
          if ((*(_WORD *)(v82 + 220) & 0x20) == 0) {
            *(_BYTE *)(v83 + 440) &= ~4u;
          }
          id v84 = v3;
          v85 = 0LL;
LABEL_263:
          std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v84, v85);
          *((_DWORD *)this + 396) |= 8u;
          *(_WORD *)(*(void *)(v66 + 48) + 220LL) |= 0x20u;
          if (v78) {
            bssl::ssl_update_cache((bssl *)v66, (ssl_st *)a2);
          }
          int v40 = 22;
          goto LABEL_474;
        }

        goto LABEL_393;
      case 22:
        bssl::ssl_do_info_callback(*(void *)this, (const ssl_st *)0x20);
        return 1LL;
      default:
        goto LABEL_393;
    }
  }

void sub_18756F22C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_do_info_callback(uint64_t this, const ssl_st *a2)
{
  id v2 = *(uint64_t (**)(void))(this + 112);
  if (v2) {
    return v2();
  }
  id v2 = *(uint64_t (**)(void))(*(void *)(this + 120) + 392LL);
  if (v2) {
    return v2();
  }
  return this;
}

const SSL *boringssl_context_info_handler(const SSL *result, int a2, char *a3)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v6 = result;
    uint64_t result = (const SSL *)SSL_get_ex_data(result, 0);
    if (result)
    {
      __int128 v7 = (SSL *)result;
      if (result->version == -1252936367)
      {
        method = result->method;
        if (method)
        {
          if (a2 > 0x2000)
          {
            if (a2 > 16387)
            {
              if (a2 == 16388)
              {
                boringssl_context_alert_callback_handler(v6, 16388LL, (int)a3, 1);
              }

              else if (a2 == 16392)
              {
                boringssl_context_alert_callback_handler(v6, 16392LL, (int)a3, 0);
              }
            }
          }

          else if (a2 > 4096)
          {
            if (a2 == 4097)
            {
              uint64_t v23 = SSL_state(v6);
              LODWORD(method[1].ssl_shutdown) = v23;
              get_ssl_method = method[1].get_ssl_method;
              if (get_ssl_method) {
                (*((void (**)(ssl_method_st *(__cdecl *)(int), uint64_t))get_ssl_method + 2))( get_ssl_method,  v23);
              }
              id WeakRetained = objc_loadWeakRetained((id *)&method->ssl_clear);
              if (!WeakRetained
                || (__int16 v26 = WeakRetained,
                    __int128 v27 = (unsigned __int8 *)objc_loadWeakRetained((id *)&method->ssl_clear),
                    a3 = (char *)v27[475],
                    v27,
                    v26,
                    (a3 & 1) == 0))
              {
                id v28 = objc_loadWeakRetained((id *)&method->ssl_clear);
                if (v28)
                {
                  id v29 = objc_loadWeakRetained((id *)&method->ssl_clear);
                  BOOL v30 = (v29[475] & 1) == 0;
                }

                else
                {
                  BOOL v30 = 1;
                }

                if (v30)
                {
                  if (g_boringssl_log)
                  {
                    int v37 = (os_log_s *)(id)g_boringssl_log;
                    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                    {
                      id v38 = objc_loadWeakRetained((id *)&method->ssl_clear);
                      if (v38)
                      {
                        a3 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
                        __int128 v39 = a3 + 391;
                      }

                      else
                      {
                        __int128 v39 = &unk_1875F4C23;
                      }

                      id v48 = objc_loadWeakRetained((id *)&method->ssl_clear);
                      if ((BYTE4(method[2].ssl_renegotiate_check) & 0x10) != 0) {
                        int v49 = "Server";
                      }
                      else {
                        int v49 = "Client";
                      }
                      int v51 = 136447490;
                      __int16 v52 = "boringssl_context_info_handler";
                      __int16 v53 = 1024;
                      int v54 = 2248;
                      __int16 v55 = 2082;
                      int v56 = v39;
                      __int16 v57 = 2048;
                      id v58 = v48;
                      __int16 v59 = 2082;
                      __int128 v60 = v49;
                      __int16 v61 = 2082;
                      char v62 = SSL_state_string_long(v6);
                      _os_log_impl( &dword_187560000,  v37,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] %{public}s handshake state: %{public}s",  (uint8_t *)&v51,  0x3Au);

                      if (v38) {
                    }
                      }
                  }
                }
              }

              if (nw_settings_get_signposts_enabled() && kdebug_is_enabled())
              {
                SSL_state_int((uint64_t)v6, v50);
                kdebug_trace();
              }
            }
          }

          else if (a2 == 16)
          {
            id v16 = objc_loadWeakRetained((id *)&method->ssl_clear);
            if (!v16
              || (__int128 v17 = v16,
                  int v18 = objc_loadWeakRetained((id *)&method->ssl_clear),
                  char v19 = v18[475],
                  v18,
                  v17,
                  (v19 & 1) == 0))
            {
              id v20 = objc_loadWeakRetained((id *)&method->ssl_clear);
              if (v20)
              {
                size_t v21 = objc_loadWeakRetained((id *)&method->ssl_clear);
                BOOL v22 = (v21[475] & 1) == 0;
              }

              else
              {
                BOOL v22 = 1;
              }

              if (v22)
              {
                if (g_boringssl_log)
                {
                  __int128 v34 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    id v35 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    if (v35)
                    {
                      uint64_t v3 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
                      int v36 = v3 + 391;
                    }

                    else
                    {
                      int v36 = &unk_1875F4C23;
                    }

                    id v44 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    id v45 = v44;
                    char v46 = BYTE4(method[2].ssl_renegotiate_check);
                    __int16 v52 = "boringssl_context_info_handler";
                    __int16 v53 = 1024;
                    int v51 = 136447234;
                    int v54 = 2231;
                    if ((v46 & 0x10) != 0) {
                      int v47 = "Server";
                    }
                    else {
                      int v47 = "Client";
                    }
                    __int16 v55 = 2082;
                    int v56 = v36;
                    __int16 v57 = 2048;
                    id v58 = v44;
                    __int16 v59 = 2082;
                    __int128 v60 = v47;
                    _os_log_impl( &dword_187560000,  v34,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] %{public}s handshake started",  (uint8_t *)&v51,  0x30u);

                    if (v35) {
                  }
                    }
                }
              }
            }

            boringssl_session_set_state((uint64_t)v7, 1);
          }

          else if (a2 == 32)
          {
            id v9 = objc_loadWeakRetained((id *)&method->ssl_clear);
            if (!v9
              || (unsigned int v10 = v9,
                  __int16 v11 = objc_loadWeakRetained((id *)&method->ssl_clear),
                  char v12 = v11[475],
                  v11,
                  v10,
                  (v12 & 1) == 0))
            {
              id v13 = objc_loadWeakRetained((id *)&method->ssl_clear);
              if (v13)
              {
                int v14 = objc_loadWeakRetained((id *)&method->ssl_clear);
                BOOL v15 = (v14[475] & 1) == 0;
              }

              else
              {
                BOOL v15 = 1;
              }

              if (v15)
              {
                if (g_boringssl_log)
                {
                  int v31 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                  {
                    id v32 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    if (v32)
                    {
                      uint64_t v3 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
                      char v33 = v3 + 391;
                    }

                    else
                    {
                      char v33 = &unk_1875F4C23;
                    }

                    id v40 = objc_loadWeakRetained((id *)&method->ssl_clear);
                    uint64_t v41 = v40;
                    char v42 = BYTE4(method[2].ssl_renegotiate_check);
                    __int16 v52 = "boringssl_context_info_handler";
                    __int16 v53 = 1024;
                    int v51 = 136447234;
                    int v54 = 2237;
                    if ((v42 & 0x10) != 0) {
                      __int128 v43 = "Server";
                    }
                    else {
                      __int128 v43 = "Client";
                    }
                    __int16 v55 = 2082;
                    int v56 = v33;
                    __int16 v57 = 2048;
                    id v58 = v40;
                    __int16 v59 = 2082;
                    __int128 v60 = v43;
                    _os_log_impl( &dword_187560000,  v31,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] %{public}s handshake done",  (uint8_t *)&v51,  0x30u);

                    if (v32) {
                  }
                    }
                }
              }
            }

            boringssl_session_finish_handshake(v7);
          }

          uint64_t result = (const SSL *)nw_settings_get_signposts_enabled();
          if ((_DWORD)result)
          {
            uint64_t result = (const SSL *)kdebug_is_enabled();
            if ((_DWORD)result) {
              return (const SSL *)kdebug_trace();
            }
          }
        }
      }
    }
  }

  return result;
}

void *__cdecl SSL_get_ex_data(const SSL *ssl, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&ssl->d1, idx);
}

void *__cdecl CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
{
  if (idx < 0) {
    return 0LL;
  }
  sk = ad->sk;
  else {
    return OPENSSL_sk_value((unint64_t *)ad->sk, idx);
  }
}

uint64_t boringssl_session_set_state(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(v2 + 300) = a2;
  return result;
}

uint64_t bssl::ssl_get_version_range(void *a1, _WORD *a2, _WORD *a3)
{
  uint64_t v6 = *a1;
  unsigned int v7 = *(_DWORD *)(v6 + 144);
  int is_dtls = SSL_is_dtls((unsigned __int8 **)v6);
  unsigned int v9 = v7 & 0xEFFFFFFF | (((v7 >> 26) & 1) << 28);
  if (!is_dtls) {
    unsigned int v9 = v7;
  }
  uint64_t v10 = a1[1];
  unsigned int v11 = *(unsigned __int16 *)(v10 + 10);
  if (v11 - 769 >= 4)
  {
    if (v11 == 65277)
    {
      unsigned int v11 = 771;
    }

    else
    {
      if (v11 != 65279) {
        goto LABEL_12;
      }
      unsigned int v11 = 770;
    }
  }

  unsigned int v12 = *(unsigned __int16 *)(v10 + 8);
  if (v12 - 769 >= 4)
  {
    if (v12 == 65277)
    {
      unsigned int v12 = 771;
      goto LABEL_14;
    }

    if (v12 == 65279)
    {
      unsigned int v12 = 770;
      goto LABEL_14;
    }

LABEL_12:
    int v13 = 68;
    int v14 = 190;
LABEL_30:
    ERR_put_error(16, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", v14);
    return 0LL;
  }

  if (a9) {
    bzero(a2, a9);
  }
  if (a5) {
    bzero(a3, a5);
  }
  uint64_t result = 0LL;
  *a4 = 0LL;
  return result;
}

  BOOL v22 = 1LL;
LABEL_17:

  return v22;
}

  if (block_size >= 33) {
    EVP_EncryptUpdate_cold_1();
  }
  if (app_data_high)
  {
    char v16 = block_size - (uint64_t)app_data_high;
    if ((int)v7 < (int)v16)
    {
      memcpy(&ctx->buf[app_data_high + 12], v12, v7);
      HIDWORD(ctx->app_data) += v7;
      *outl = 0;
      goto LABEL_35;
    }

    if (block_size != app_data_high) {
      memcpy(&ctx->buf[app_data_high + 12], v12, v16);
    }
    uint64_t result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, void))ctx->cipher->do_cipher)( ctx,  v14,  &ctx->buf[12],  block_size);
    if (!result) {
      return result;
    }
    v12 += v16;
    v14 += block_size;
    v7 -= v16;
  }

  else
  {
    block_size_t size = 0;
  }

  *outl = block_size;
  char v19 = block_remainder((uint64_t)ctx, v7);
  id v20 = v7 - v19;
  if ((int)v20 < 1)
  {
LABEL_32:
    if (v19) {
      memcpy(&ctx->buf[12], &v12[(int)v20], v19);
    }
    HIDWORD(ctx->app_data) = v19;
    goto LABEL_35;
  }

  uint64_t result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, uint64_t))ctx->cipher->do_cipher)( ctx,  v14,  v12,  v20);
  if (result)
  {
    *outl += v20;
    goto LABEL_32;
  }

  return result;
}

    int v8 = 101;
    unsigned int v9 = 202;
LABEL_13:
    ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", v9);
    return 0LL;
  }

  if (a2 == 3) {
    return 1LL;
  }
  if (a2 != 4109) {
    goto LABEL_12;
  }
  uint64_t result = (uint64_t)EC_GROUP_new_by_curve_name(nid);
  if (result)
  {
    v4[1] = result;
    return 1LL;
  }

  return result;
}

  return a1;
}

LABEL_14:
  uint64_t v15 = 0LL;
  char v16 = 0;
  if (*(void *)(*a1 + 168LL)) {
    BOOL v17 = v11 >= 0x304;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17) {
    LOWORD(v11) = 772;
  }
  do
  {
    unsigned int v18 = (unsigned __int16)bssl::kProtocolVersions[v15];
    if (v18 >= (unsigned __int16)v11)
    {
      if (v12 < v18) {
        break;
      }
      if ((*(_DWORD *)&bssl::kProtocolVersions[v15 + 2] & v9) != 0)
      {
        if ((v16 & 1) != 0)
        {
          LOWORD(v12) = bssl::kProtocolVersions[v15 - 4];
          goto LABEL_32;
        }

        char v16 = 0;
      }

      else
      {
        if ((v16 & 1) == 0) {
          LOWORD(v11) = bssl::kProtocolVersions[v15];
        }
        char v16 = 1;
      }
    }

    v15 += 4LL;
  }

  while (v15 != 16);
  if ((v16 & 1) == 0)
  {
    int v13 = 280;
    int v14 = 237;
    goto LABEL_30;
  }

    unsigned int v9 = 50;
    goto LABEL_16;
  }

  uint64_t v4 = 0;
LABEL_19:
  id v20 = 0LL;
  size_t v21 = off_18A071390;
  do
  {
    if (((v4 >> v20) & 1) == 0)
    {
      LOBYTE(v43[0]) = 50;
      if ((((uint64_t (*)(uint64_t, unint64_t *, void))*v21)(a1, v43, 0LL) & 1) == 0)
      {
        ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4181);
        ERR_add_error_dataf("extension %u", v23, v24, v25, v26, v27, v28, v29, *((_WORD *)v21 - 8));
        unsigned int v9 = LOBYTE(v43[0]);
        goto LABEL_16;
      }
    }

    ++v20;
    v21 += 5;
  }

  while (v20 != 28);
  BOOL v22 = *(void *)(a1 + 1520);
  if (!v22 || (*(_BYTE *)(v22 + 440) & 0x40) == 0) {
    return 1LL;
  }
  uint64_t v3 = *(bssl **)a1;
  BOOL v30 = *(void *)(*(void *)a1 + 48LL);
  int v31 = *(void *)(v30 + 504);
  if (!v31)
  {
    ERR_put_error(16, 0, 308, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4224);
    unsigned int v18 = v3;
    unsigned int v9 = 47;
    goto LABEL_17;
  }

  id v45 = 0uLL;
  if ((bssl::ssl_get_local_application_settings(a1, &v45, *(void **)(v30 + 496), v31) & 1) != 0)
  {
    id v32 = v45;
    char v33 = bssl::Array<unsigned char>::Init(v22 + 408, *((unint64_t *)&v45 + 1));
    __int128 v34 = v33;
    if (*((void *)&v32 + 1))
    {
      if (v33) {
        memmove(*(void **)(v22 + 408), (const void *)v32, *((size_t *)&v32 + 1));
      }
    }

    if (v34) {
      return 1LL;
    }
    unsigned int v9 = 80;
  }

  else
  {
    ERR_put_error(16, 0, 259, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4233);
    unsigned int v9 = 47;
  }

      uint64_t v10 = *(void *)(v5 + 24);
LABEL_15:
      *(void *)a4 = v10;
      return 1LL;
  }

    if (v8 != ret) {
      BN_free(v8);
    }
    return 0LL;
  }

  if (!BN_is_zero((uint64_t)a) && !BN_is_one((unsigned int *)a))
  {
    BN_CTX_start(ctx);
    unsigned int v11 = BN_CTX_get(ctx);
    unsigned int v12 = BN_CTX_get(ctx);
    int v13 = BN_CTX_get(ctx);
    int v14 = BN_CTX_get(ctx);
    uint64_t v15 = BN_CTX_get(ctx);
    char v16 = BN_CTX_get(ctx);
    if (!v16)
    {
LABEL_64:
      int v8 = 0LL;
      goto LABEL_65;
    }

    BOOL v17 = v16;
    r = v12;
    int v8 = ret;
    if (!ret)
    {
      int v8 = BN_new();
      if (!v8) {
        goto LABEL_62;
      }
    }

    if (!BN_nnmod(v11, a, n, ctx)) {
      goto LABEL_62;
    }
    unsigned int v18 = 0;
    do
      ++v18;
    while (!BN_is_bit_set(n, v18));
    if (v18 == 2)
    {
      if (!BN_rshift(v13, n, 3)) {
        goto LABEL_62;
      }
      v13->neg = 0;
      if (!BN_mod_exp_mont(r, v14, v13, n, ctx, 0LL)
        || !BN_mod_sqr(v17, r, n, ctx)
        || !BN_mod_mul(v14, v14, v17, n, ctx)
        || !BN_sub_word(v14, 1uLL)
        || !BN_mod_mul(v15, v11, r, n, ctx)
        || !BN_mod_mul(v15, v15, v14, n, ctx))
      {
        goto LABEL_62;
      }

      size_t v21 = v8;
LABEL_41:
      if (!BN_copy(v21, v15)) {
        goto LABEL_62;
      }
      goto LABEL_29;
    }

    if (v18 == 1)
    {
      if (BN_rshift(v13, n, 2))
      {
        v13->neg = 0;
        if (BN_add_word(v13, 1uLL))
        {
          if (BN_mod_exp_mont(v8, v11, v13, n, ctx, 0LL))
          {
LABEL_29:
            if (!BN_mod_sqr(v15, v8, n, ctx)) {
              goto LABEL_62;
            }
            if (!BN_cmp(v15, v11))
            {
LABEL_65:
              BN_CTX_end(ctx);
              return v8;
            }

            char v19 = 110;
            id v20 = 409;
            goto LABEL_61;
          }
        }
      }

  ERR_put_error(4, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v15);
  return 0LL;
}

  OPENSSL_free(v14);
  return v12;
}

  int v13 = BN_CTX_new();
  if (!v13) {
    return 0;
  }
  int v14 = v13;
  BN_CTX_start(v13);
  r = BN_CTX_get(v14);
  if (r)
  {
    uint64_t v15 = 0LL;
    a = (BIGNUM *)rem;
    while (1)
    {
LABEL_17:
      if (!add)
      {
        while (BN_rand(ret, bits, 1, 1))
        {
          if (!bn_odd_number_is_obviously_composite((unsigned int *)ret))
          {
            if (cb) {
              goto LABEL_49;
            }
            goto LABEL_50;
          }
        }

        goto LABEL_85;
      }

      BN_CTX_start(v14);
      char v16 = BN_CTX_get(v14);
      BOOL v17 = v16;
      id v38 = cb;
      int v36 = v12;
      int v37 = v11;
      __int128 v39 = v15;
      if (v12) {
        break;
      }
      if (!v16 || !BN_rand(ret, bits, 0, 1) || !BN_div(0LL, v17, ret, add, v14) || !BN_sub(ret, ret, v17)) {
        goto LABEL_84;
      }
      if (a)
      {
        if (!BN_add(ret, ret, a)) {
          goto LABEL_84;
        }
      }

      else if (!BN_add_word(ret, 1uLL))
      {
        goto LABEL_84;
      }

      if (ret->top <= 16) {
        size_t v21 = 512LL;
      }
      else {
        size_t v21 = 1024LL;
      }
      for (uint64_t i = 1LL; i != v21; ++i)
      {
        while (bn_mod_u16_consttime((uint64_t)ret, (unsigned __int16)kPrimes[i]) <= 1)
        {
          uint64_t i = 1LL;
          if (!BN_add(ret, ret, add)) {
            goto LABEL_84;
          }
        }
      }

LABEL_32:
  *a2 = v11;
  *a3 = v12;
  return 1LL;
}

  OPENSSL_free(__s1);
  return v25;
}

  uint64_t v23 = boringssl_psk_cache_lookup_psk_inner(*(void **)(a1 + 32), v4);
  int v24 = *(void *)(*(void *)(a1 + 40) + 8LL);
  __int16 v25 = *(void **)(v24 + 40);
  *(void *)(v24 + 40) = v23;
}

    unsigned int v11 = 0;
    goto LABEL_33;
  }

  unsigned int v9 = (*(uint64_t (**)(void))v8)(*a1);
  uint64_t v10 = v9 + v6;
  if (__CFADD__(v9, v6))
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_session.cc", 546);
    unsigned int v11 = 0;
  }

  else
  {
    *(void *)&ctx.key[36] = 0xAAAAAAAAAAAAAAAALL;
    if (CBB_reserve(a2, &ctx.key[36], v10))
    {
      ctx.md = (const EVP_MD *)0xAAAAAAAAAAAAAAAALL;
      if ((*(unsigned int (**)(uint64_t, void, HMAC_CTX *, uint64_t, unsigned __int8 *, unint64_t))(v8 + 8))( v7,  *(void *)&ctx.key[36],  &ctx,  v10,  v5,  v6))
      {
        unsigned int v11 = CBB_did_write(a2, (uint64_t)ctx.md) != 0;
      }

      else
      {
        ERR_put_error(16, 0, 276, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_session.cc", 558);
        unsigned int v11 = 0;
      }
    }

    else
    {
      unsigned int v11 = 0;
    }
  }

BOOL bssl::ssl_select_ech_config(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 = 0LL;
  if (*(unsigned __int16 *)(a1 + 30) >= 0x304u && (uint64_t v5 = *(void *)(a1 + 8), (v6 = *(void *)(v5 + 288)) != 0))
  {
    __int128 v43 = *(unsigned __int8 **)(v5 + 280);
    uint64_t v44 = v6;
    unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
    BOOL v10 = 0;
    if (CBS_get_u16_length_prefixed(&v43, &v41) && v42 && !v44)
    {
      uint64_t v30 = a2;
      uint64_t v31 = a3;
      uint64_t v32 = (uint64_t)a4;
      id v29 = (uint64_t *)(a1 + 1544);
      while (1)
      {
        *(_OWORD *)int v36 = 0u;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        unint64_t v40 = 0xAAAAAAAA00000000LL;
        char v35 = -86;
        if ((bssl::parse_ech_config((uint64_t)&v41, (uint64_t)v36, &v35, 0) & 1) != 0)
        {
          unsigned int v11 = (ssl_credential_st *)EVP_hpke_x25519_hkdf_sha256();
          char v12 = 1;
          if (v35 && (unsigned __int16)v40 == 32)
          {
            uint64_t v13 = (uint64_t)v11;
            __int128 v14 = v39;
            unsigned int v15 = *(unsigned __int16 *)(*(void *)(*(void *)a1 + 8LL) + 301LL);
            if ((v15 & 0x800) != 0) {
              int v16 = (v15 >> 12) & 1;
            }
            else {
              int v16 = ssl_credential_st::UsesPrivateKey(v11);
            }
            v34[0] = v14;
            if (*((void *)&v14 + 1))
            {
              BOOL v17 = 0LL;
              while (1)
              {
                unsigned int v18 = v17;
                LOWORD(v33) = -21846;
                v45[0] = -21846;
                if (!CBS_get_u16((unsigned __int16 **)v34, &v33)
                  || !CBS_get_u16((unsigned __int16 **)v34, v45))
                {
                  break;
                }

                uint64_t v19 = 0LL;
                int v20 = v45[0];
                while (1)
                {
                  BOOL v17 = (unsigned __int16 *)bssl::kSupportedAEADs[v19]();
                  if (++v19 == 3) {
                    goto LABEL_26;
                  }
                }

                if (v17) {
                  BOOL v21 = (unsigned __int16)v33 == 1;
                }
                else {
                  BOOL v21 = 0;
                }
                if (!v21)
                {
LABEL_26:
                  BOOL v17 = v18;
                  goto LABEL_27;
                }

                if (v18)
                {
                  if (v16) {
                    goto LABEL_26;
                  }
                  if (v45[0] != 3) {
                    BOOL v17 = v18;
                  }
                }

LABEL_42:
        OPENSSL_free((void *)v36[0]);
        if ((v12 & 1) == 0) {
          break;
        }
        if (!v42) {
          return 1;
        }
      }
    }
  }

  else
  {
    return 1;
  }

  return v10;
}

void sub_18756FF88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

BOOL bssl::ssl_setup_key_shares(bssl *this, unint64_t a2)
{
  uint64_t v4 = *(void **)this;
  uint64_t v5 = (void **)((char *)this + 392);
  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)this + 49, 0LL);
  uint64_t v6 = (void **)((char *)this + 400);
  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)this + 50, 0LL);
  unsigned int v7 = (char *)this + 616;
  OPENSSL_free(*((void **)this + 77));
  *(_OWORD *)((char *)this + bssl::Array<unsigned short>::~Array(v16 + 616) = 0u;
  if (*((unsigned __int16 *)this + 15) >= 0x304u)
  {
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22[1] = v9;
    v22[2] = v9;
    v22[0] = v9;
    CBB_zero(v22);
    if ((_DWORD)a2) {
      goto LABEL_5;
    }
    if ((*(_WORD *)(v4[15] + 832LL) & 0x20) != 0)
    {
      unsigned int grease_value = bssl::ssl_get_grease_value((uint64_t)this, 1u);
      if (!CBB_add_u16((uint64_t)v22, grease_value)
        || !CBB_add_u16((uint64_t)v22, 1u)
        || !CBB_add_u8((uint64_t)v22, 0))
      {
        goto LABEL_23;
      }
    }

    uint64_t v14 = *((void *)this + 1);
    unint64_t v15 = *(void *)(v14 + 112);
    if (v15)
    {
      int v16 = *(__int16 **)(v14 + 104);
      a2 = (unsigned __int16)*v16;
      if (v15 == 1)
      {
LABEL_5:
        unint64_t v10 = 0LL;
        goto LABEL_6;
      }
    }

    else
    {
      int v16 = &bssl::kDefaultGroups;
      a2 = 29LL;
      unint64_t v15 = 4LL;
    }

    for (unint64_t i = 1LL; i < v15; ++i)
    {
      unint64_t v10 = (unsigned __int16)v16[i];
      if (((_DWORD)a2 == 25497) == ((_DWORD)v10 == 25497))
      {
        unint64_t v10 = 0LL;
      }

      else if ((_DWORD)v10 == (_DWORD)a2)
      {
        __assert_rtn("ssl_setup_key_shares", "extensions.cc", 2284, "second_group_id != group_id");
      }

      if ((_DWORD)v10) {
        break;
      }
    }

LABEL_6:
    *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[1] = v11;
    v21[2] = v11;
    v21[0] = v11;
    bssl::SSLKeyShare::Create((void *)a2, &v20);
    char v12 = v20;
    int v20 = 0LL;
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v5, v12);
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v20, 0LL);
    if (*v5)
    {
      if (CBB_add_u16((uint64_t)v22, a2))
      {
        if (CBB_add_u16_length_prefixed((uint64_t *)v22, (uint64_t)v21))
        {
          if (((*(uint64_t (**)(void, _OWORD *))(**v5 + 24LL))(*v5, v21) & 1) != 0)
          {
            if (!(_DWORD)v10
              || (bssl::SSLKeyShare::Create((void *)v10, &v20),
                  uint64_t v13 = v20,
                  int v20 = 0LL,
                  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](v6, v13),
                  std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v20, 0LL),
                  *v6)
              && CBB_add_u16((uint64_t)v22, v10)
              && CBB_add_u16_length_prefixed((uint64_t *)v22, (uint64_t)v21)
              && ((*(uint64_t (**)(void, _OWORD *))(**v6 + 24LL))(*v6, v21) & 1) != 0)
            {
              BOOL v8 = bssl::CBBFinishArray((uint64_t)v22, (uint64_t)v7);
LABEL_24:
              CBB_cleanup((uint64_t)v22);
              return v8;
            }
          }
        }
      }
    }

        if (a4) {
          bzero(a2, a4);
        }
        uint64_t v13 = 0LL;
        uint64_t result = 0LL;
        goto LABEL_9;
      }

      __int128 v11 = 103;
      char v12 = 214;
    }

    else
    {
      __int128 v11 = 101;
      char v12 = 208;
    }

  return v6;
}

LABEL_23:
    BOOL v8 = 0LL;
    goto LABEL_24;
  }

  return 1LL;
}

  ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v6);
  return 0LL;
}

    unsigned int v7 = 0LL;
    goto LABEL_24;
  }

  unsigned int v7 = (os_log_s *)g_boringssl_log;
  if (g_boringssl_log)
  {
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_private_key_sign_cold_2(a2, v7, v8);
    }
    goto LABEL_23;
  }

        __int128 v9 = 0LL;
        goto LABEL_24;
      }

      d = v7->d;
      uint64_t v13 = a2->d;
      uint64_t v14 = v10->d;
    }

    else
    {
      *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[14] = v11;
      v16[15] = v11;
      v16[12] = v11;
      v16[13] = v11;
      v16[10] = v11;
      v16[11] = v11;
      v16[8] = v11;
      v16[9] = v11;
      v16[6] = v11;
      v16[7] = v11;
      v16[4] = v11;
      v16[5] = v11;
      v16[2] = v11;
      v16[3] = v11;
      v16[0] = v11;
      v16[1] = v11;
      d = v7->d;
      uint64_t v13 = a2->d;
      uint64_t v14 = (unint64_t *)v16;
    }

    bn_sqr_normal(d, (uint64_t)v13, top, v14);
    goto LABEL_20;
  }

  a1->top = 0;
  a1->neg = 0;
  return 1LL;
}

    int v16 = 0LL;
LABEL_26:
    BN_CTX_free(v18);
    return v16;
  }

  unsigned int v7 = 67;
  BOOL v8 = 738;
LABEL_8:
  ERR_put_error(15, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", v8);
  return 0LL;
}

void sub_187570268( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

double CBB_zero(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t CBB_init(uint64_t a1, unint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t result = (uint64_t)OPENSSL_malloc(a2);
  if (!a2 || result)
  {
    *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
    *(void *)a1 = 0LL;
    *(void *)(a1 + 16) = result;
    *(void *)(a1 + 24) = 0LL;
    *(void *)(a1 + 32) = a2;
    *(_BYTE *)(a1 + 40) = *(_BYTE *)(a1 + 40) & 0xFC | 1;
    return 1LL;
  }

  return result;
}

uint64_t bssl::ssl_get_grease_value(uint64_t a1, unsigned int a2)
{
  int v3 = *(_BYTE *)(a1 + a2 + 1630) & 0xF0 | 0xA;
  uint64_t result = v3 | (v3 << 8);
  if (a2 == 3)
  {
    if (v3 == (*(_BYTE *)(a1 + 1632) & 0xF0 | 0xA)) {
      return result ^ 0x1010;
    }
    else {
      return result;
    }
  }

  return result;
}

uint64_t CBB_add_u16(uint64_t a1, unsigned int a2)
{
  return cbb_add_u(a1, a2, 2uLL);
}

uint64_t cbb_add_u(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBB_add_space(a1, &v9, a3);
  if ((_DWORD)result)
  {
    if (a3)
    {
      unint64_t v7 = a3 - 1;
      do
      {
        *(_BYTE *)(v9 + v7) = a2;
        a2 >>= 8;
        --v7;
      }

      while (v7 < a3);
    }

    if (a2)
    {
      uint64_t v8 = a1 + 16;
      if (*(_BYTE *)(a1 + 8)) {
        uint64_t v8 = *(void *)v8;
      }
      uint64_t result = 0LL;
      *(_BYTE *)(v8 + 24) |= 2u;
      *(void *)a1 = 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t CBB_add_space(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result = CBB_flush((uint64_t *)a1);
  if ((_DWORD)result)
  {
    int v7 = *(unsigned __int8 *)(a1 + 8);
    uint64_t v8 = (void *)(a1 + 16);
    if (v7) {
      uint64_t v8 = (void *)*v8;
    }
    uint64_t result = cbb_buffer_reserve((uint64_t)v8, a2, a3);
    if ((_DWORD)result)
    {
      v8[1] += a3;
      return 1LL;
    }
  }

  return result;
}

uint64_t CBB_flush(uint64_t *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 2);
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (*((_BYTE *)a1 + 8))
  {
    uint64_t v3 = *(void *)v2;
    if (!*(void *)v2) {
      return 0LL;
    }
  }

  if ((*(_BYTE *)(v3 + 24) & 2) != 0) {
    return 0LL;
  }
  uint64_t v4 = *a1;
  if (!*a1) {
    return 1LL;
  }
  if (!*(_BYTE *)(v4 + 8)) {
    CBB_flush_cold_1();
  }
  if (*(void *)(v4 + 16) != v3) {
    CBB_flush_cold_3();
  }
  uint64_t v5 = *(void *)(v4 + 24);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 32);
  unint64_t v7 = v5 + v6;
  unint64_t v8 = *(void *)(v4 + 24);
  if (v5 + v6 < v8) {
    goto LABEL_33;
  }
  unint64_t v9 = *(void *)(v3 + 8);
  size_t v10 = v9 - v7;
  if (v9 < v7) {
    goto LABEL_33;
  }
  LODWORD(v11) = *(unsigned __int8 *)(v4 + 32);
  if ((*(_BYTE *)(v4 + 33) & 1) != 0)
  {
    if ((_DWORD)v11 != 1) {
      CBB_flush_cold_2();
    }
    if (v10 > 0xFFFFFFFE)
    {
      int v12 = 221;
LABEL_32:
      ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bytestring/cbb.c", v12);
      goto LABEL_33;
    }

    if (v10 >> 24)
    {
      char v14 = -124;
      int v15 = 5;
    }

    else if (v10 >> 16)
    {
      char v14 = -125;
      int v15 = 4;
    }

    else if (v10 <= 0xFF)
    {
      if (v10 <= 0x7F)
      {
        LOBYTE(v15) = 1;
        char v14 = v10;
        size_t v10 = 0LL;
LABEL_26:
        uint64_t v11 = *(void *)v3;
        *(void *)(v4 + 24) = v8 + 1;
        *(_BYTE *)(v11 + v_Block_object_dispose(va, 8) = v14;
        LOBYTE(v11) = v15 - 1;
        *(_BYTE *)(v4 + 32) = v15 - 1;
        goto LABEL_27;
      }

      char v14 = -127;
      int v15 = 2;
    }

    else
    {
      char v14 = -126;
      int v15 = 3;
    }

    uint64_t v16 = (v15 - 1);
    if (!cbb_buffer_reserve(v3, 0LL, v16))
    {
LABEL_33:
      if (*((_BYTE *)a1 + 8)) {
        uint64_t v2 = *(void *)v2;
      }
      uint64_t result = 0LL;
      *(_BYTE *)(v2 + 24) |= 2u;
      goto LABEL_36;
    }

    uint64_t v17 = *(void *)v3;
    *(void *)(v3 + 8) += v16;
    memmove((void *)(v17 + v7 + v16), (const void *)(v17 + v7), v10);
    unint64_t v8 = *(void *)(v4 + 24);
    goto LABEL_26;
  }

uint64_t cbb_buffer_reserve(uint64_t result, void *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(result + 8);
    BOOL v5 = __CFADD__(v4, a3);
    unint64_t v6 = v4 + a3;
    if (v5)
    {
      int v7 = 81;
LABEL_5:
      ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bytestring/cbb.c", v7);
LABEL_6:
      uint64_t result = 0LL;
      *(_BYTE *)(v3 + 24) |= 2u;
      return result;
    }

    uint64_t v9 = *(void *)(result + 16);
    if (v6 > v9)
    {
      if ((*(_BYTE *)(result + 24) & 1) == 0)
      {
        int v7 = 87;
        goto LABEL_5;
      }

      if (2 * v9 < v6 || v9 < 0) {
        unint64_t v11 = v6;
      }
      else {
        unint64_t v11 = 2 * v9;
      }
      int v12 = OPENSSL_realloc(*(void **)result, v11);
      if (!v12) {
        goto LABEL_6;
      }
      *(void *)uint64_t v3 = v12;
      *(void *)(v3 + 16) = v11;
    }

    if (a2) {
      *a2 = *(void *)v3 + *(void *)(v3 + 8);
    }
    return 1LL;
  }

  return result;
}

uint64_t CBB_add_u8(uint64_t a1, unsigned int a2)
{
  return cbb_add_u(a1, a2, 1uLL);
}

void *bssl::SSLKeyShare::Create@<X0>(void *this@<X0>, void *a2@<X8>)
{
  switch((int)this)
  {
    case 21:
      uint64_t v3 = EC_group_p224();
      uint64_t v4 = OPENSSL_malloc(0x20uLL);
      if (!v4) {
        goto LABEL_15;
      }
      void *v4 = off_18A071858;
      v4[1] = 0LL;
      v4[2] = v3;
      __int16 v5 = 21;
      goto LABEL_14;
    case 22:
    case 26:
    case 27:
    case 28:
      goto LABEL_7;
    case 23:
      int v7 = EC_group_p256();
      uint64_t v4 = OPENSSL_malloc(0x20uLL);
      if (!v4) {
        goto LABEL_15;
      }
      void *v4 = off_18A071858;
      v4[1] = 0LL;
      v4[2] = v7;
      __int16 v5 = 23;
      goto LABEL_14;
    case 24:
      unint64_t v8 = EC_group_p384();
      uint64_t v4 = OPENSSL_malloc(0x20uLL);
      if (!v4) {
        goto LABEL_15;
      }
      void *v4 = off_18A071858;
      v4[1] = 0LL;
      v4[2] = v8;
      __int16 v5 = 24;
      goto LABEL_14;
    case 25:
      uint64_t v9 = EC_group_p521();
      uint64_t v4 = OPENSSL_malloc(0x20uLL);
      if (!v4) {
        goto LABEL_15;
      }
      void *v4 = off_18A071858;
      v4[1] = 0LL;
      v4[2] = v9;
      __int16 v5 = 25;
LABEL_14:
      *((_WORD *)v4 + 12) = v5;
LABEL_15:
      size_t v10 = 0LL;
      *a2 = v4;
    case 29:
      this = OPENSSL_malloc(0x28uLL);
      if (!this) {
        goto LABEL_19;
      }
      unint64_t v6 = off_18A0718D0;
      goto LABEL_18;
    default:
      if ((_DWORD)this == 25497)
      {
        this = OPENSSL_malloc(0x1E88uLL);
        if (this)
        {
          unint64_t v6 = off_18A071938;
LABEL_18:
          *this = v6;
        }

LABEL_19:
        *a2 = this;
      }

      else
      {
LABEL_7:
        *a2 = 0LL;
      }

      return this;
  }

  return v7;
}

  CBB_cleanup((uint64_t)v26);
  return v18;
}

      CFArrayAppendValue(v9, v20);
      CFRelease(v20);
      unint64_t v11 = &v12[v14];
      v10 -= v14 + 2;
      if (!v10) {
        goto LABEL_37;
      }
    }

    uint64_t v3 = 1LL;
LABEL_15:
    if (g_boringssl_log)
    {
      BOOL v21 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        if (v6)
        {
          __int128 v24 = objc_loadWeakRetained(v6 + 2);
          __int128 v60 = v24 != 0LL;
          __int16 v25 = &unk_1875F4C23;
          char v62 = v24;
          if (v24)
          {
            __int16 v59 = (char *)objc_loadWeakRetained(v6 + 2);
            __int16 v25 = v59 + 391;
          }

          size_t v26 = objc_loadWeakRetained(v6 + 2);
          __int128 v23 = v25;
          __int16 v61 = v26;
          BOOL v22 = v26;
          uint64_t v3 = v60;
        }

        else
        {
          uint64_t v3 = 0LL;
          BOOL v22 = 0LL;
          __int128 v23 = &unk_1875F4C23;
        }

        *(_DWORD *)buf = 136447234;
        uint64_t v64 = "boringssl_context_copy_peer_sct_list_from_extension";
        uint64_t v65 = 1024;
        uint64_t v66 = 978;
        BOOL v67 = 2082;
        __int128 v68 = v23;
        id v69 = 2048;
        __int128 v70 = v22;
        uint64_t v71 = 1024;
        int v72 = v14;
        _os_log_debug_impl( &dword_187560000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] SerializedSCT length %d",  buf,  0x2Cu);
        if (v6) {

        }
        if ((_DWORD)v3) {
        if (v6)
        }
      }
    }

    goto LABEL_18;
  }

  if (v6)
  {
    __int128 v27 = objc_loadWeakRetained(v6 + 2);
    if (v27)
    {
      id v28 = v27;
      id v29 = objc_loadWeakRetained(v6 + 2);
      uint64_t v30 = v29[475];

      if ((v30 & 1) != 0) {
        goto LABEL_73;
      }
    }

    a2 = (unsigned __int16 *)objc_loadWeakRetained(v6 + 2);
    if (a2)
    {
      uint64_t v31 = objc_loadWeakRetained(v6 + 2);
      uint64_t v32 = (v31[475] & 1) == 0;
    }

    else
    {
      uint64_t v32 = 1LL;
    }
  }

  else
  {
    uint64_t v32 = 1LL;
  }

  uint64_t v9 = 0LL;
  if ((_DWORD)v32 && g_boringssl_log)
  {
    char v46 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      if (v6)
      {
        a2 = (unsigned __int16 *)objc_loadWeakRetained(v6 + 2);
        __int16 v52 = a2 != 0LL;
        if (a2)
        {
          uint64_t v32 = (uint64_t)objc_loadWeakRetained(v6 + 2);
          int v54 = (void *)(v32 + 391);
        }

        else
        {
          int v54 = &unk_1875F4C23;
        }

        __int16 v53 = objc_loadWeakRetained(v6 + 2);
      }

      else
      {
        __int16 v52 = 0;
        __int16 v53 = 0LL;
        int v54 = &unk_1875F4C23;
      }

      *(_DWORD *)buf = 136446978;
      uint64_t v64 = "boringssl_context_copy_peer_sct_list_from_extension";
      uint64_t v65 = 1024;
      uint64_t v66 = 961;
      BOOL v67 = 2082;
      __int128 v68 = v54;
      id v69 = 2048;
      __int128 v70 = v53;
      _os_log_error_impl( &dword_187560000,  v46,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] CFArrayCreateMutable failed",  buf,  0x26u);
      if (v6) {

      }
      if (v52) {
      if (v6)
      }
    }

    goto LABEL_73;
  }

uint64_t CBB_add_u16_length_prefixed(uint64_t *a1, uint64_t a2)
{
  return cbb_add_length_prefixed(a1, a2, 2u);
}

uint64_t cbb_add_length_prefixed(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = CBB_flush(a1);
  if ((_DWORD)result) {
    return cbb_add_child((uint64_t)a1, a2, a3, 0);
  }
  return result;
}

uint64_t cbb_add_child(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (*(void *)a1) {
    cbb_add_child_cold_2();
  }
  char v4 = a4;
  if (a3 != 1 && a4) {
    cbb_add_child_cold_1();
  }
  unint64_t v8 = (void *)(a1 + 16);
  if (*(_BYTE *)(a1 + 8)) {
    unint64_t v8 = (void *)*v8;
  }
  uint64_t v9 = v8[1];
  unint64_t v11 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = cbb_buffer_reserve((uint64_t)v8, &v11, a3);
  if ((_DWORD)result)
  {
    v8[1] += a3;
    if (a3) {
      bzero(v11, a3);
    }
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    uint64_t result = 1LL;
    *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = 1;
    *(void *)(a2 + 16) = v8;
    *(void *)(a2 + 24) = v9;
    *(_BYTE *)(a2 + 32) = a3;
    *(_BYTE *)(a2 + 33) = *(_BYTE *)(a2 + 33) & 0xFE | v4 & 1;
    *(void *)a1 = a2;
  }

  return result;
}

_BYTE *X25519_keypair(_BYTE *a1, unsigned __int8 *buf)
{
  *buf |= 7u;
  buf[31] = buf[31] & 0x3F | 0x80;
  return X25519_public_from_private(a1, (uint64_t)buf);
}

_BYTE *X25519_public_from_private(_BYTE *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  __int128 v3 = *(_OWORD *)(a2 + 16);
  int8x16_t v16 = *(int8x16_t *)a2;
  __int128 v17 = v3;
  v16.i8[0] &= 0xF8u;
  HIBYTE(v17) = HIBYTE(v3) & 0x3F | 0x40;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15[3] = (int64x2_t)v4;
  v15[4] = (int64x2_t)v4;
  v15[1] = (int64x2_t)v4;
  v15[2] = (int64x2_t)v4;
  v14[2] = v4;
  v15[0] = (int64x2_t)v4;
  v14[0] = v4;
  v14[1] = v4;
  v13[0] = v4;
  v13[1] = v4;
  x25519_ge_scalarmult_base(v13, &v16);
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v5;
  v11[1] = v5;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v5;
  v9[1] = v5;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = v5;
  v7[1] = v5;
  fe_add(v11, v15, (int64x2_t *)((char *)v14 + 8));
  fe_sub(v9, v15, (int64x2_t *)((char *)v14 + 8));
  fe_loose_invert((uint64_t)v7, (unint64_t *)v9);
  fe_mul_impl((uint64_t)v7, (unint64_t *)v11, (unint64_t *)v7);
  return fe_tobytes(a1, v7);
}

uint64_t x25519_ge_scalarmult_base(__int128 *a1, int8x16_t *a2)
{
  uint64_t v3 = 0LL;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[2] = v4;
  __int128 v27 = v4;
  v26[0] = v4;
  v26[1] = v4;
  v5.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v5.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v6 = *a2++;
    v29.val[0] = vandq_s8(v6, v5);
    v29.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v6, 4uLL);
    int v7 = (char *)&v26[v3];
    vst2q_s8(v7, v29);
    v3 += 2LL;
  }

  while (v3 != 4);
  uint64_t v8 = 0LL;
  int v9 = 0;
  do
  {
    int v10 = *((unsigned __int8 *)v26 + v8) + v9;
    int v9 = (v10 + 8) << 24 >> 28;
    *((_BYTE *)v26 + v8++) = v10 - ((v10 + 8) & 0xF0);
  }

  while (v8 != 63);
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[8] = v11;
  v23[9] = v11;
  v23[6] = v11;
  v23[7] = v11;
  v23[4] = v11;
  v23[5] = v11;
  v23[2] = v11;
  v23[3] = v11;
  v23[0] = v11;
  v23[1] = v11;
  v19[0] = v11;
  v19[1] = v11;
  v19[2] = v11;
  v19[3] = v11;
  v19[4] = v11;
  v19[5] = v11;
  v19[6] = v11;
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  HIBYTE(v27) += v9;
  ge_p3_0((uint64_t)a1);
  int v12 = 0;
  unint64_t v13 = 1LL;
  do
  {
    table_select((uint64_t)v19, v12, *((char *)v26 + v13));
    ge_madd((uint64_t)v23, (uint64_t)a1, (unint64_t *)v19);
    x25519_ge_p1p1_to_p3((uint64_t)a1, (unint64_t *)v23);
    ++v12;
    BOOL v14 = v13 >= 0x3E;
    v13 += 2LL;
  }

  while (!v14);
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[5] = v15;
  v21[6] = v15;
  _OWORD v21[3] = v15;
  v21[4] = v15;
  v21[1] = v15;
  v21[2] = v15;
  v21[0] = v15;
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  v24[5] = v15;
  v24[6] = v15;
  v24[3] = v15;
  v24[4] = v15;
  v24[1] = v15;
  v24[2] = v15;
  v24[0] = v15;
  ge_p3_to_p2((uint64_t)v24, a1);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v24);
  x25519_ge_p1p1_to_p2((uint64_t)v21, (unint64_t *)v23);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v21);
  x25519_ge_p1p1_to_p2((uint64_t)v21, (unint64_t *)v23);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v21);
  x25519_ge_p1p1_to_p2((uint64_t)v21, (unint64_t *)v23);
  ge_p2_dbl((uint64_t)v23, (uint64_t)v21);
  x25519_ge_p1p1_to_p3((uint64_t)a1, (unint64_t *)v23);
  int v16 = 0;
  unint64_t v17 = 0LL;
  do
  {
    table_select((uint64_t)v19, v16, *((char *)v26 + v17));
    ge_madd((uint64_t)v23, (uint64_t)a1, (unint64_t *)v19);
    uint64_t result = x25519_ge_p1p1_to_p3((uint64_t)a1, (unint64_t *)v23);
    ++v16;
    BOOL v14 = v17 >= 0x3E;
    v17 += 2LL;
  }

  while (!v14);
  return result;
}

double ge_p3_0(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + RAND_bytes(buf, 32) = 0LL;
  *(void *)(a1 + 40) = 1LL;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 1LL;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = 0LL;
  return result;
}

uint64_t table_select(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = 0LL;
  uint64_t v41 = *MEMORY[0x1895F89C0];
  memset(v40, 0, sizeof(v40));
  __int128 v39 = 0u;
  char v38 = ((a3 - 1LL) & ~(uint64_t)a3) < 0;
  v40[15] = v38;
  int8x16_t v6 = (char *)&k25519Precomp + 768 * a2;
  do
  {
    int v7 = (char *)&k25519Precomp + 768 * a2 + 96 * v4;
    uint64_t v9 = 0LL;
    int8x16_t v10 = vdupq_n_s8((uint64_t)((++v4 ^ (unint64_t)(a3 - 2 * ((a3 >> 31) & a3))) - 1) >> 63);
    do
    {
      *(int8x16_t *)(&v38 + v9) = veorq_s8(vandq_s8(*(int8x16_t *)&v6[v9], v10), *(int8x16_t *)(&v38 + v9));
      v9 += 16LL;
    }

    while (v9 != 96);
    v6 += 96;
  }

  while (v4 != 8);
  unint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  v11.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v11.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v35 = v11;
  int64x2_t v36 = v11;
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v32 = v11;
  int64x2_t v33 = v11;
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v29 = v11;
  int64x2_t v30 = v11;
  fe_frombytes_strict((unint64_t *)&v35, (unsigned int *)&v38);
  fe_frombytes_strict((unint64_t *)&v32, (unsigned int *)&v40[15]);
  fe_frombytes_strict((unint64_t *)&v29, (unsigned int *)&v40[47]);
  int64x2_t v12 = v36;
  int64x2_t v13 = v35;
  int64x2_t v14 = v36;
  *(int64x2_t *)a1 = v35;
  *(int64x2_t *)(a1 + 16) = v12;
  int64x2_t v15 = v33;
  *(int64x2_t *)(a1 + 40) = v32;
  int64x2_t v16 = v32;
  *(int64x2_t *)(a1 + 56) = v33;
  int64x2_t v17 = v30;
  *(int64x2_t *)(a1 + 80) = v29;
  *(int64x2_t *)(a1 + bssl::Array<unsigned short>::~Array(v1 - 96) = v17;
  v22[0] = v16;
  v22[1] = v15;
  v18.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v18.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v27[0] = v18;
  v27[1] = v18;
  unint64_t v19 = v37;
  *(void *)(a1 + RAND_bytes(buf, 32) = v37;
  unint64_t v20 = v34;
  *(void *)(a1 + 72) = v34;
  *(void *)(a1 + 112) = v31;
  unint64_t v23 = v20;
  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v24 = v13;
  int64x2_t v25 = v14;
  unint64_t v26 = v19;
  fe_neg(v27, &v29);
  return cmov(a1, (uint64_t)v22, (a3 >> 7) & 1);
}

uint64_t cmov(uint64_t result, uint64_t a2, unsigned int a3)
{
  for (uint64_t i = 0LL; i != 40; i += 8LL)
    *(void *)(result + i) = *(void *)(a2 + i) & -(uint64_t)a3 | *(void *)(result + i) & (a3 - 1LL);
  for (uint64_t j = 0LL; j != 40; j += 8LL)
    *(void *)(result + 40 + j) = *(void *)(a2 + 40 + j) & -(uint64_t)a3 | *(void *)(result + 40 + j) & (a3 - 1LL);
  for (uint64_t k = 0LL; k != 40; k += 8LL)
    *(void *)(result + 80 + k) = *(void *)(a2 + 80 + k) & -(uint64_t)a3 | *(void *)(result + 80 + k) & (a3 - 1LL);
  return result;
}

unint64_t *fe_carry(unint64_t *result, void *a2)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665uLL) {
      fe_carry_cold_1();
    }
  }

  uint64_t v3 = 0LL;
  unint64_t v4 = a2[1] + (*a2 >> 51);
  unint64_t v5 = a2[2] + (v4 >> 51);
  unint64_t v6 = a2[3] + (v5 >> 51);
  unint64_t v7 = a2[4] + (v6 >> 51);
  unint64_t v8 = (*a2 & 0x7FFFFFFFFFFFFLL) + 19 * (v7 >> 51);
  unint64_t v9 = (v4 & 0x7FFFFFFFFFFFFLL) + (v8 >> 51);
  *double result = v8 & 0x7FFFFFFFFFFFFLL;
  result[1] = v9 & 0x7FFFFFFFFFFFFLL;
  result[2] = (v5 & 0x7FFFFFFFFFFFFLL) + (v9 >> 51);
  result[3] = v6 & 0x7FFFFFFFFFFFFLL;
  result[4] = v7 & 0x7FFFFFFFFFFFFLL;
  do
  {
    if (result[v3] >= 0x8CCCCCCCCCCCDLL) {
      fe_carry_cold_2();
    }
    ++v3;
  }

  while (v3 != 5);
  return result;
}

int64x2_t *fe_neg(int64x2_t *result, int64x2_t *a2)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2->i64[i] >= 0x8CCCCCCCCCCCDuLL) {
      fe_neg_cold_1();
    }
  }

  uint64_t v3 = 0LL;
  uint64_t v4 = 0xFFFFFFFFFFFFELL - a2[2].i64[0];
  int64x2_t v5 = vsubq_s64(vdupq_n_s64(0xFFFFFFFFFFFFEuLL), a2[1]);
  *double result = vsubq_s64((int64x2_t)xmmword_18760CB10, *a2);
  result[1] = v5;
  result[2].i64[0] = v4;
  do
  {
    if (result->i64[v3] >= 0x1A666666666665uLL) {
      fe_neg_cold_2();
    }
    ++v3;
  }

  while (v3 != 5);
  return result;
}

int64x2_t *ge_madd(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = v6;
  v13[1] = v6;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v6;
  v11[1] = v6;
  unint64_t v7 = (int64x2_t *)(a2 + 40);
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v6;
  v9[1] = v6;
  fe_add((int64x2_t *)a1, (int64x2_t *)(a2 + 40), (int64x2_t *)a2);
  fe_sub((int64x2_t *)(a1 + 40), v7, (int64x2_t *)a2);
  fe_mul_impl((uint64_t)v11, (unint64_t *)a1, a3);
  fe_mul_impl((uint64_t)v13, (unint64_t *)(a1 + 40), a3 + 5);
  fe_mul_impl((uint64_t)v9, a3 + 10, (unint64_t *)(a2 + 120));
  fe_add((int64x2_t *)(a1 + 120), (int64x2_t *)(a2 + 80), (int64x2_t *)(a2 + 80));
  fe_sub((int64x2_t *)a1, v11, v13);
  fe_add((int64x2_t *)(a1 + 40), v11, v13);
  fe_carry((unint64_t *)v11, (void *)(a1 + 120));
  fe_add((int64x2_t *)(a1 + 80), v11, v9);
  return fe_sub((int64x2_t *)(a1 + 120), v11, v9);
}

int64x2_t *fe_add(int64x2_t *result, int64x2_t *a2, int64x2_t *a3)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2->i64[i] >= 0x8CCCCCCCCCCCDuLL) {
      fe_add_cold_1();
    }
  }

  for (uint64_t j = 0LL; j != 5; ++j)
  {
    if (a3->i64[j] >= 0x8CCCCCCCCCCCDuLL) {
      fe_add_cold_2();
    }
  }

  uint64_t v5 = 0LL;
  uint64_t v6 = a3[2].i64[0] + a2[2].i64[0];
  int64x2_t v7 = vaddq_s64(a3[1], a2[1]);
  *double result = vaddq_s64(*a3, *a2);
  result[1] = v7;
  result[2].i64[0] = v6;
  do
  {
    if (result->i64[v5] >= 0x1A666666666665uLL) {
      fe_add_cold_3();
    }
    ++v5;
  }

  while (v5 != 5);
  return result;
}

int64x2_t *fe_sub(int64x2_t *result, int64x2_t *a2, int64x2_t *a3)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2->i64[i] >= 0x8CCCCCCCCCCCDuLL) {
      fe_sub_cold_1();
    }
  }

  for (uint64_t j = 0LL; j != 5; ++j)
  {
    if (a3->i64[j] >= 0x8CCCCCCCCCCCDuLL) {
      fe_sub_cold_2();
    }
  }

  uint64_t v5 = 0LL;
  uint64_t v6 = a2[2].i64[0] - a3[2].i64[0] + 0xFFFFFFFFFFFFELL;
  int64x2_t v7 = vaddq_s64(vsubq_s64(a2[1], a3[1]), vdupq_n_s64(0xFFFFFFFFFFFFEuLL));
  *double result = vaddq_s64(vsubq_s64(*a2, *a3), (int64x2_t)xmmword_18760CB10);
  result[1] = v7;
  result[2].i64[0] = v6;
  do
  {
    if (result->i64[v5] >= 0x1A666666666665uLL) {
      fe_sub_cold_3();
    }
    ++v5;
  }

  while (v5 != 5);
  return result;
}

uint64_t fe_mul_impl(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665LL) {
      fe_mul_impl_cold_1();
    }
  }

  for (uint64_t j = 0LL; j != 5; ++j)
  {
    if (a3[j] >= 0x1A666666666665LL) {
      fe_mul_impl_cold_2();
    }
  }

  uint64_t v5 = 0LL;
  unint64_t v6 = a2[4];
  unint64_t v8 = a3[3];
  unint64_t v7 = a3[4];
  unint64_t v10 = a3[1];
  unint64_t v9 = a3[2];
  unint64_t v11 = *a3;
  unint64_t v12 = a2[2];
  unint64_t v13 = a2[3];
  unint64_t v14 = *a2;
  unint64_t v15 = a2[1];
  signed __int128 v17 = v13 * (unsigned __int128)(19 * v9)
      + 19 * v10 * (unsigned __int128)v6
      + v12 * (unsigned __int128)(19 * v8)
  unsigned __int128 v18 = v13 * (unsigned __int128)(19 * v7) + 19 * v8 * (unsigned __int128)v6;
  uint64_t v19 = (v13 * (unsigned __int128)(19 * v8)
       + 19 * v9 * (unsigned __int128)v6
       + v12 * (unsigned __int128)(19 * v7)
       + v11 * (unsigned __int128)v15
       + v14 * (unsigned __int128)v10) >> 64;
  uint64_t v20 = v13 * 19 * v8 + 19 * v9 * v6 + v12 * 19 * v7 + v11 * v15 + v14 * v10;
  uint64_t v21 = v17 >> 51;
  BOOL v22 = __CFADD__(v20, v21);
  uint64_t v23 = v20 + v21;
  if (v22) {
    ++v19;
  }
  *((void *)&v25 + 1) = v19;
  *(void *)&__int128 v25 = v23;
  uint64_t v24 = v25 >> 51;
  uint64_t v26 = (v18 + v15 * (unsigned __int128)v10 + v11 * (unsigned __int128)v12 + v14 * (unsigned __int128)v9) >> 64;
  uint64_t v27 = v18 + v15 * v10 + v11 * v12 + v14 * v9;
  BOOL v22 = __CFADD__(v27, v24);
  uint64_t v28 = v27 + v24;
  if (v22) {
    ++v26;
  }
  unsigned __int128 v29 = v12 * (unsigned __int128)v10
      + 19 * v7 * (unsigned __int128)v6
      + v15 * (unsigned __int128)v9
      + v11 * (unsigned __int128)v13
      + v14 * (unsigned __int128)v8;
  unsigned __int128 v30 = v12 * (unsigned __int128)v9
      + v13 * (unsigned __int128)v10
      + v15 * (unsigned __int128)v8
      + v11 * (unsigned __int128)v6;
  unsigned __int128 v32 = v30 + v14 * (unsigned __int128)v7;
  uint64_t v31 = *((void *)&v32 + 1);
  *((void *)&v33 + 1) = v26;
  *(void *)&__int128 v33 = v28;
  uint64_t v34 = v29 + (v33 >> 51);
  *((void *)&v33 + 1) = v30;
  *(void *)&__int128 v33 = v34;
  uint64_t v35 = v33 >> 51;
  if (__CFADD__((void)v32, v35)) {
    uint64_t v31 = *((void *)&v32 + 1) + 1LL;
  }
  *((void *)&v36 + 1) = v31;
  *(void *)&__int128 v36 = v32 + v35;
  unint64_t v37 = (v17 & 0x7FFFFFFFFFFFFLL) + 19 * (v36 >> 51);
  v38.i64[0] = v34;
  v38.i64[1] = v32 + v35;
  uint64_t v39 = v37 & 0x7FFFFFFFFFFFFLL;
  unint64_t v40 = (v23 & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  *(void *)double result = v39;
  *(void *)(result + _Block_object_dispose(va, 8) = v40 & 0x7FFFFFFFFFFFFLL;
  *(void *)(result + 16) = (v28 & 0x7FFFFFFFFFFFFLL) + (v40 >> 51);
  *(int8x16_t *)(result + 24) = vandq_s8(v38, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  do
  {
    if (*(void *)(result + v5) >= 0x8CCCCCCCCCCCDuLL) {
      fe_mul_impl_cold_3();
    }
    v5 += 8LL;
  }

  while (v5 != 40);
  return result;
}

uint64_t x25519_ge_p1p1_to_p3(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = a2 + 15;
  fe_mul_impl(a1, a2, a2 + 15);
  fe_mul_impl(a1 + 40, a2 + 5, a2 + 10);
  fe_mul_impl(a1 + 80, a2 + 10, v4);
  return fe_mul_impl(a1 + 120, a2, a2 + 5);
}

__n128 ge_p3_to_p2(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  *(void *)(a1 + RAND_bytes(buf, 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __int128 v4 = *(__int128 *)((char *)a2 + 40);
  __int128 v5 = *(__int128 *)((char *)a2 + 56);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  __n128 result = (__n128)a2[5];
  __int128 v7 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array(v1 - 96) = v7;
  return result;
}

int64x2_t *ge_p2_dbl(uint64_t a1, uint64_t a2)
{
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  v4.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v4.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = v4;
  v13[1] = v4;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v4;
  v11[1] = v4;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = v4;
  v9[1] = v4;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = v4;
  v7[1] = v4;
  fe_sq_tt((uint64_t)v13, (unint64_t *)a2);
  fe_sq_tt((uint64_t)v11, (unint64_t *)(a2 + 40));
  fe_sq_tt((uint64_t)v9, (unint64_t *)(a2 + 80));
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v5.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v15[0] = v5;
  v15[1] = v5;
  fe_add(v15, v9, v9);
  fe_carry((unint64_t *)v9, v15);
  fe_add((int64x2_t *)(a1 + 40), (int64x2_t *)a2, (int64x2_t *)(a2 + 40));
  fe_sq_tl((uint64_t)v7, (unint64_t *)(a1 + 40));
  fe_add((int64x2_t *)(a1 + 40), v11, v13);
  fe_sub((int64x2_t *)(a1 + 80), v11, v13);
  fe_carry((unint64_t *)v11, (void *)(a1 + 40));
  fe_sub((int64x2_t *)a1, v7, v11);
  fe_carry((unint64_t *)v11, (void *)(a1 + 80));
  return fe_sub((int64x2_t *)(a1 + 120), v9, v11);
}

uint64_t fe_sq_tt(uint64_t result, unint64_t *a2)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665LL) {
      fe_sq_tt_cold_1();
    }
  }

  uint64_t v3 = 0LL;
  unint64_t v5 = a2[3];
  unint64_t v4 = a2[4];
  unint64_t v6 = a2[1];
  unint64_t v7 = a2[2];
  uint64_t v8 = 2 * v7;
  unint64_t v9 = *a2;
  unint64_t v10 = (v5 * (unsigned __int128)(38 * v4)) >> 64;
  uint64_t v11 = v5 * 38 * v4;
  unint64_t v12 = (v7 * (unsigned __int128)(38 * v4)) >> 64;
  uint64_t v13 = v7 * 38 * v4;
  signed __int128 v14 = v6 * (unsigned __int128)(38 * v4) + v7 * (unsigned __int128)(38 * v5) + v9 * (unsigned __int128)v9;
  uint64_t v15 = (v6 * (unsigned __int128)(2 * v5) + v7 * (unsigned __int128)v7 + v9 * (unsigned __int128)(2 * v4)) >> 64;
  uint64_t v16 = v6 * 2 * v5 + v7 * v7 + v9 * 2 * v4;
  unsigned __int128 v19 = v6 * (unsigned __int128)(2 * v7) + 19 * v4 * (unsigned __int128)v4 + v9 * (unsigned __int128)(2 * v5);
  uint64_t v18 = v19 >> 64;
  uint64_t v17 = v19;
  uint64_t v21 = v6 * v6 + v11 + v9 * v8;
  uint64_t v20 = (v6 * (unsigned __int128)v6 + __PAIR128__(v10, v11) + v9 * (unsigned __int128)(unint64_t)v8) >> 64;
  unsigned __int128 v23 = __PAIR128__(v12, v13) + 19 * v5 * (unsigned __int128)v5 + v9 * (unsigned __int128)(2 * v6);
  uint64_t v22 = *((void *)&v23 + 1);
  uint64_t v24 = v14 >> 51;
  if (__CFADD__((void)v23, v24)) {
    uint64_t v22 = *((void *)&v23 + 1) + 1LL;
  }
  *((void *)&v26 + 1) = v22;
  *(void *)&__int128 v26 = v23 + v24;
  uint64_t v25 = v26 >> 51;
  BOOL v27 = __CFADD__(v21, v25);
  uint64_t v28 = v21 + v25;
  if (v27) {
    ++v20;
  }
  *((void *)&v30 + 1) = v20;
  *(void *)&__int128 v30 = v28;
  uint64_t v29 = v30 >> 51;
  BOOL v27 = __CFADD__(v17, v29);
  uint64_t v31 = v17 + v29;
  if (v27) {
    uint64_t v32 = v18 + 1;
  }
  else {
    uint64_t v32 = v18;
  }
  *((void *)&v34 + 1) = v32;
  *(void *)&__int128 v34 = v31;
  uint64_t v33 = v34 >> 51;
  BOOL v27 = __CFADD__(v16, v33);
  uint64_t v35 = v16 + v33;
  if (v27) {
    ++v15;
  }
  *((void *)&v36 + 1) = v15;
  *(void *)&__int128 v36 = v35;
  unint64_t v37 = (v14 & 0x7FFFFFFFFFFFFLL) + 19 * (v36 >> 51);
  v38.i64[0] = v31;
  v38.i64[1] = v35;
  unint64_t v39 = ((v23 + v24) & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  *(void *)__n128 result = v37 & 0x7FFFFFFFFFFFFLL;
  *(void *)(result + _Block_object_dispose(va, 8) = v39 & 0x7FFFFFFFFFFFFLL;
  *(void *)(result + 16) = (v28 & 0x7FFFFFFFFFFFFLL) + (v39 >> 51);
  *(int8x16_t *)(result + 24) = vandq_s8(v38, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  do
  {
    if (*(void *)(result + v3) >= 0x8CCCCCCCCCCCDuLL) {
      fe_sq_tt_cold_2();
    }
    v3 += 8LL;
  }

  while (v3 != 40);
  return result;
}

uint64_t fe_sq_tl(uint64_t result, unint64_t *a2)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2[i] >= 0x1A666666666665LL) {
      fe_sq_tl_cold_1();
    }
  }

  uint64_t v3 = 0LL;
  unint64_t v5 = a2[3];
  unint64_t v4 = a2[4];
  unint64_t v6 = a2[1];
  unint64_t v7 = a2[2];
  uint64_t v8 = 2 * v7;
  unint64_t v9 = *a2;
  unint64_t v10 = (v5 * (unsigned __int128)(38 * v4)) >> 64;
  uint64_t v11 = v5 * 38 * v4;
  unint64_t v12 = (v7 * (unsigned __int128)(38 * v4)) >> 64;
  uint64_t v13 = v7 * 38 * v4;
  signed __int128 v14 = v6 * (unsigned __int128)(38 * v4) + v7 * (unsigned __int128)(38 * v5) + v9 * (unsigned __int128)v9;
  uint64_t v15 = (v6 * (unsigned __int128)(2 * v5) + v7 * (unsigned __int128)v7 + v9 * (unsigned __int128)(2 * v4)) >> 64;
  uint64_t v16 = v6 * 2 * v5 + v7 * v7 + v9 * 2 * v4;
  unsigned __int128 v19 = v6 * (unsigned __int128)(2 * v7) + 19 * v4 * (unsigned __int128)v4 + v9 * (unsigned __int128)(2 * v5);
  uint64_t v18 = v19 >> 64;
  uint64_t v17 = v19;
  uint64_t v21 = v6 * v6 + v11 + v9 * v8;
  uint64_t v20 = (v6 * (unsigned __int128)v6 + __PAIR128__(v10, v11) + v9 * (unsigned __int128)(unint64_t)v8) >> 64;
  unsigned __int128 v23 = __PAIR128__(v12, v13) + 19 * v5 * (unsigned __int128)v5 + v9 * (unsigned __int128)(2 * v6);
  uint64_t v22 = *((void *)&v23 + 1);
  uint64_t v24 = v14 >> 51;
  if (__CFADD__((void)v23, v24)) {
    uint64_t v22 = *((void *)&v23 + 1) + 1LL;
  }
  *((void *)&v26 + 1) = v22;
  *(void *)&__int128 v26 = v23 + v24;
  uint64_t v25 = v26 >> 51;
  BOOL v27 = __CFADD__(v21, v25);
  uint64_t v28 = v21 + v25;
  if (v27) {
    ++v20;
  }
  *((void *)&v30 + 1) = v20;
  *(void *)&__int128 v30 = v28;
  uint64_t v29 = v30 >> 51;
  BOOL v27 = __CFADD__(v17, v29);
  uint64_t v31 = v17 + v29;
  if (v27) {
    uint64_t v32 = v18 + 1;
  }
  else {
    uint64_t v32 = v18;
  }
  *((void *)&v34 + 1) = v32;
  *(void *)&__int128 v34 = v31;
  uint64_t v33 = v34 >> 51;
  BOOL v27 = __CFADD__(v16, v33);
  uint64_t v35 = v16 + v33;
  if (v27) {
    ++v15;
  }
  *((void *)&v36 + 1) = v15;
  *(void *)&__int128 v36 = v35;
  unint64_t v37 = (v14 & 0x7FFFFFFFFFFFFLL) + 19 * (v36 >> 51);
  v38.i64[0] = v31;
  v38.i64[1] = v35;
  unint64_t v39 = ((v23 + v24) & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  *(void *)__n128 result = v37 & 0x7FFFFFFFFFFFFLL;
  *(void *)(result + _Block_object_dispose(va, 8) = v39 & 0x7FFFFFFFFFFFFLL;
  *(void *)(result + 16) = (v28 & 0x7FFFFFFFFFFFFLL) + (v39 >> 51);
  *(int8x16_t *)(result + 24) = vandq_s8(v38, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  do
  {
    if (*(void *)(result + v3) >= 0x8CCCCCCCCCCCDuLL) {
      fe_sq_tl_cold_2();
    }
    v3 += 8LL;
  }

  while (v3 != 40);
  return result;
}

uint64_t x25519_ge_p1p1_to_p2(uint64_t a1, unint64_t *a2)
{
  __int128 v2 = a2;
  unint64_t v4 = a2 + 15;
  fe_mul_impl(a1, a2, a2 + 15);
  unint64_t v5 = v2 + 5;
  v2 += 10;
  fe_mul_impl(a1 + 40, v5, v2);
  return fe_mul_impl(a1 + 80, v2, v4);
}

uint64_t fe_loose_invert(uint64_t a1, unint64_t *a2)
{
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = v4;
  v20[1] = v4;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  v18[0] = v4;
  v18[1] = v4;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v4;
  v16[1] = v4;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v4;
  v14[1] = v4;
  fe_sq_tl((uint64_t)v20, a2);
  fe_sq_tt((uint64_t)v18, (unint64_t *)v20);
  fe_sq_tt((uint64_t)v18, (unint64_t *)v18);
  fe_mul_impl((uint64_t)v18, a2, (unint64_t *)v18);
  fe_mul_impl((uint64_t)v20, (unint64_t *)v20, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v20);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v18, (unint64_t *)v16);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v18);
  int v5 = 4;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v5;
  }

  while (v5);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v18);
  int v6 = 9;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v6;
  }

  while (v6);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v14, (unint64_t *)v16);
  int v7 = 19;
  do
  {
    fe_sq_tt((uint64_t)v14, (unint64_t *)v14);
    --v7;
  }

  while (v7);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v14, (unint64_t *)v16);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
  int v8 = 9;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v8;
  }

  while (v8);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v18);
  int v9 = 49;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v9;
  }

  while (v9);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v14, (unint64_t *)v16);
  int v10 = 99;
  do
  {
    fe_sq_tt((uint64_t)v14, (unint64_t *)v14);
    --v10;
  }

  while (v10);
  fe_mul_impl((uint64_t)v16, (unint64_t *)v14, (unint64_t *)v16);
  fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
  int v11 = 49;
  do
  {
    fe_sq_tt((uint64_t)v16, (unint64_t *)v16);
    --v11;
  }

  while (v11);
  fe_mul_impl((uint64_t)v18, (unint64_t *)v16, (unint64_t *)v18);
  fe_sq_tt((uint64_t)v18, (unint64_t *)v18);
  int v12 = 4;
  do
  {
    fe_sq_tt((uint64_t)v18, (unint64_t *)v18);
    --v12;
  }

  while (v12);
  return fe_mul_impl(a1, (unint64_t *)v18, (unint64_t *)v20);
}

_BYTE *fe_tobytes(_BYTE *result, void *a2)
{
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    if (a2[i] >= 0x8CCCCCCCCCCCDuLL) {
      fe_tobytes_cold_1();
    }
  }

  unint64_t v3 = *a2 - 0x7FFFFFFFFFFEDLL;
  unint64_t v4 = a2[1] - -(uint64_t)(v3 >> 51) - 0x7FFFFFFFFFFFFLL;
  unint64_t v5 = a2[2] - -(uint64_t)(v4 >> 51) - 0x7FFFFFFFFFFFFLL;
  unint64_t v6 = a2[3] - -(uint64_t)(v5 >> 51) - 0x7FFFFFFFFFFFFLL;
  uint64_t v7 = v3 & 0x7FFFFFFFFFFFFLL;
  uint64_t v8 = v4 & 0x7FFFFFFFFFFFFLL;
  uint64_t v9 = v5 & 0x7FFFFFFFFFFFFLL;
  uint64_t v10 = v6 & 0x7FFFFFFFFFFFFLL;
  uint64_t v11 = a2[4] - -(uint64_t)(v6 >> 51) - 0x7FFFFFFFFFFFFLL;
  if ((v11 & 0x7F8000000000000LL) != 0) {
    uint64_t v12 = -1LL;
  }
  else {
    uint64_t v12 = 0LL;
  }
  unint64_t v13 = (v12 & 0x7FFFFFFFFFFEDLL) + v7;
  result[1] = BYTE1(v13);
  result[2] = BYTE2(v13);
  result[3] = (unint64_t)((v12 & 0xFFFFFFED) + v7) >> 24;
  result[4] = BYTE4(v13);
  result[5] = BYTE5(v13);
  unint64_t v14 = (v12 & 0x7FFFFFFFFFFFFLL) + v8 + (v13 >> 51);
  *__n128 result = v13;
  result[6] = BYTE6(v13) & 7 | (8 * (v12 + v8 + (v13 >> 51)));
  result[7] = v14 >> 5;
  result[8] = v14 >> 13;
  result[9] = v14 >> 21;
  result[10] = v14 >> 29;
  result[11] = v14 >> 37;
  unint64_t v15 = v9 + (v12 & 0x7FFFFFFFFFFFFLL) + (v14 >> 51);
  result[12] = (v14 >> 45) & 0x3F | (((_BYTE)v9 + (_BYTE)v12 + (v14 >> 51)) << 6);
  result[13] = v15 >> 2;
  result[14] = v15 >> 10;
  result[15] = v15 >> 18;
  result[16] = v15 >> 26;
  result[17] = v15 >> 34;
  result[18] = v15 >> 42;
  unint64_t v16 = v10 + (v12 & 0x7FFFFFFFFFFFFLL) + (v15 >> 51);
  result[19] = ((v15 & 0x4000000000000LL) != 0) | (2 * (v10 + v12 + (v15 >> 51)));
  result[20] = v16 >> 7;
  result[21] = v16 >> 15;
  result[22] = v16 >> 23;
  result[23] = v16 >> 31;
  result[24] = v16 >> 39;
  unint64_t v17 = v11 + v12 + (v16 >> 51);
  result[25] = (v16 >> 47) & 0xF | (16 * v17);
  result[26] = v17 >> 4;
  result[27] = v17 >> 12;
  result[28] = v17 >> 20;
  result[29] = v17 >> 28;
  result[30] = v17 >> 36;
  result[31] = (v17 >> 44) & 0x7F;
  return result;
}

uint64_t CBB_add_bytes(uint64_t a1, const void *a2, size_t a3)
{
  __dst = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBB_add_space(a1, &__dst, a3);
  if ((_DWORD)result)
  {
    if (a3) {
      memcpy(__dst, a2, a3);
    }
    return 1LL;
  }

  return result;
}

BOOL bssl::CBBFinishArray(uint64_t a1, uint64_t a2)
{
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  int v3 = CBB_finish(a1, &v8, &v7);
  if (v3)
  {
    unint64_t v5 = v7;
    unint64_t v4 = v8;
    OPENSSL_free(*(void **)a2);
    *(void *)a2 = v4;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v5;
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 204);
  }

  return v3 != 0;
}

uint64_t CBB_finish(uint64_t a1, void *a2, void *a3)
{
  if (*(_BYTE *)(a1 + 8))
  {
    ERR_put_error(14, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bytestring/cbb.c", 127);
    return 0LL;
  }

  uint64_t result = CBB_flush((uint64_t *)a1);
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 40) & 1) != 0)
    {
      uint64_t result = 0LL;
      if (!a2 || !a3) {
        return result;
      }
    }

    else if (!a2)
    {
      goto LABEL_10;
    }

    *a2 = *(void *)(a1 + 16);
LABEL_10:
    if (a3) {
      *a3 = *(void *)(a1 + 24);
    }
    *(void *)(a1 + 16) = 0LL;
    CBB_cleanup(a1);
    return 1LL;
  }

  return result;
}

void CBB_cleanup(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8)) {
    CBB_cleanup_cold_1();
  }
  if ((*(_BYTE *)(a1 + 40) & 1) != 0) {
    OPENSSL_free(*(void **)(a1 + 16));
  }
}

uint64_t bssl::ssl_setup_extension_permutation(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if ((*(_WORD *)(*((void *)this + 1) + 301LL) & 0x400) == 0) {
    return 1LL;
  }
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v17[12] = v4;
  __int128 v16 = v4;
  *(_OWORD *)unint64_t v17 = v4;
  __int128 v14 = v4;
  __int128 v15 = v4;
  *(_OWORD *)buf = v4;
  __int128 v13 = v4;
  if (RAND_bytes(buf, 108) && (OPENSSL_free(0LL), unint64_t v5 = OPENSSL_malloc(0x1CuLL), (v6 = v5) != 0LL))
  {
    for (uint64_t i = 0LL; i != 28; ++i)
      *((_BYTE *)v5 + i) = i;
    for (uint64_t j = 0LL; j != -27; --j)
    {
      unint64_t v9 = *(unsigned int *)&v17[4 * j + 24] % (unint64_t)(j + 28);
      char v10 = *((_BYTE *)v5 + j + 27);
      *((_BYTE *)v5 + j + 27) = *((_BYTE *)v5 + v9);
      *((_BYTE *)v5 + v9) = v10;
    }

    OPENSSL_free(*((void **)this + 89));
    *((void *)this + 89) = v6;
    *((void *)this + 90) = 28LL;
    uint64_t v2 = 1LL;
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  OPENSSL_free(0LL);
  return v2;
}

void sub_187572410(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_encrypt_client_hello(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  __int128 v4 = *(void **)a1;
  if (*(void *)(a1 + 1544))
  {
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v64 = v7;
    __int128 v65 = v7;
    *(_OWORD *)buf = v7;
    CBB_zero(buf);
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v61 = v8;
    __int128 v62 = v8;
    __int128 v60 = v8;
    CBB_zero(&v60);
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v58 = v9;
    __int128 v59 = v9;
    __int128 v57 = v9;
    char v56 = -86;
    int v54 = 0LL;
    size_t v55 = 0LL;
    if (!(*(unsigned int (**)(void *, unsigned __int8 *, __int128 *, uint64_t))(*v4 + 88LL))( v4,  buf,  &v57,  1LL)
      || !CBB_init((uint64_t)&v60, 0x100uLL)
      || !bssl::ssl_write_client_hello_without_extensions(a1, (uint64_t *)&v57, 1, 0)
      || !bssl::ssl_write_client_hello_without_extensions(a1, (uint64_t *)&v60, 1, 1)
      || (unint64_t v10 = CBB_len((uint64_t)&v57),
          !bssl::ssl_add_clienthello_tlsext(a1, (uint64_t *)&v57, (uint64_t *)&v60, &v56, (const ssl_session_st *)1, v10))
      || ((*(uint64_t (**)(void *, unsigned __int8 *, void **))(*v4 + 96LL))(v4, buf, &v54) & 1) == 0)
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/encrypted_client_hello.cc", 792);
      BOOL v18 = 0LL;
LABEL_20:
      OPENSSL_free(v54);
      CBB_cleanup((uint64_t)&v60);
      CBB_cleanup((uint64_t)buf);
      return v18;
    }

    uint64_t v11 = v55;
    if (v56)
    {
      *(void *)&__int128 v69 = 0xAAAAAAAAAAAAAAAALL;
      if ((bssl::tls13_write_psk_binder((uint64_t *)a1, (ssl_session_st *)(a1 + 464), (char *)v54, v55, (size_t *)&v69) & 1) == 0)
      {
LABEL_42:
        BOOL v18 = 0LL;
        goto LABEL_20;
      }

      uint64_t v12 = CBB_data((uint64_t)&v60);
      unint64_t v13 = CBB_len((uint64_t)&v60);
      uint64_t v11 = v55;
      if ((void)v69)
      {
        memcpy((char *)v12 + v13 - v69, (char *)v54 + v55 - v69, v69);
        uint64_t v11 = v55;
      }
    }

    bssl::ssl_do_msg_callback((uint64_t)v4, 1LL, 257LL, (uint64_t)v54, v11);
    if (bssl::SSLTranscript::Update((void **)(a1 + 464), v54, v55))
    {
      unint64_t v14 = *(unsigned __int8 *)(*(void *)(a1 + 1544) + 66LL);
      __int128 v15 = (const char *)v4[20];
      if (v15)
      {
        size_t v16 = strlen(v15);
        if (v14 >= v16) {
          uint64_t v17 = v14 - v16;
        }
        else {
          uint64_t v17 = 0LL;
        }
      }

      else
      {
        uint64_t v17 = v14 + 9;
      }

      char v32 = CBB_len((uint64_t)&v60);
      __int16 v52 = 0LL;
      size_t v53 = 0LL;
      uint64_t v33 = a1 + 736;
      __int128 v34 = (unsigned __int16 *)EVP_HPKE_CTX_kdf((const EC_KEY *)(a1 + 736));
      uint64_t v35 = (unsigned __int16 *)EVP_HPKE_CTX_aead(a1 + 736);
      size_t v36 = v53;
      uint64_t v37 = EVP_HPKE_AEAD_aead((uint64_t)v35);
      size_t v38 = EVP_AEAD_max_overhead(v37) + v36;
      size_t v51 = v38;
      *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v70 = v39;
      __int128 v71 = v39;
      __int128 v68 = v39;
      __int128 v69 = v39;
      *(_OWORD *)uint64_t v66 = v39;
      __int128 v67 = v39;
      unsigned int v40 = EVP_HPKE_KDF_id(v34);
      if (CBB_add_u16((uint64_t)buf, v40)
        && (unsigned int v41 = EVP_HPKE_KDF_id(v35), CBB_add_u16((uint64_t)buf, v41))
        && CBB_add_u8((uint64_t)buf, *(unsigned __int8 *)(*(void *)(a1 + 1544) + 67LL))
        && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)&v69)
        && CBB_add_bytes((uint64_t)&v69, a2, a3)
        && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)v66)
        && CBB_add_zeros((uint64_t)v66, v38)
        && bssl::CBBFinishArray((uint64_t)buf, a1 + 568))
      {
        *(void *)&__int128 v42 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v49 = v42;
        __int128 v50 = v42;
        *(_OWORD *)id v48 = v42;
        CBB_zero(v48);
        if (CBB_init((uint64_t)v48, 0x100uLL)
          && bssl::ssl_write_client_hello_without_extensions(a1, (uint64_t *)v48, 2, 0)
          && (unint64_t v43 = CBB_len((uint64_t)v48),
              bssl::ssl_add_clienthello_tlsext(a1, (uint64_t *)v48, 0LL, &v56, (const ssl_session_st *)2, v43)))
        {
          if (v56) {
            __assert_rtn("ssl_encrypt_client_hello", "encrypted_client_hello.cc", 876, "!needs_psk_binder");
          }
          size_t v44 = *(void *)(a1 + 576);
          if (v44 < v38) {
            abort();
          }
          uint64_t v45 = *(void *)(a1 + 568);
          char v46 = v52;
          size_t v47 = v53;
          CBB_data((uint64_t)v48);
          CBB_len((uint64_t)v48);
          else {
            BOOL v18 = 0LL;
          }
        }

        else
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/encrypted_client_hello.cc", 870);
          BOOL v18 = 0LL;
        }

        CBB_cleanup((uint64_t)v48);
      }

      else
      {
LABEL_62:
        BOOL v18 = 0LL;
      }

      bssl::Array<unsigned short>::~Array((uint64_t)&v52);
      goto LABEL_20;
    }

    goto LABEL_42;
  }

  unsigned int v19 = *(unsigned __int16 *)(v4[1] + 301LL);
  if ((v19 & 0x800) != 0)
  {
    if (((v19 >> 12) & 1) != 0) {
      goto LABEL_26;
    }
  }

  else if (ssl_credential_st::UsesPrivateKey((ssl_credential_st *)a1))
  {
LABEL_26:
    uint64_t v20 = (unsigned __int16 *)EVP_hpke_aes_128_gcm();
    goto LABEL_29;
  }

  uint64_t v20 = (unsigned __int16 *)EVP_hpke_chacha20_poly1305();
LABEL_29:
  unint64_t v21 = v20;
  unsigned int v22 = *(unsigned __int8 *)(a1 + 1636);
  *(void *)&__int128 v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v69 = v23;
  __int128 v70 = v23;
  *(_OWORD *)uint64_t v66 = v23;
  __int128 v67 = v23;
  X25519_keypair(&v69, v66);
  *(void *)buf = 0xAAAAAAAAAAAAAAAALL;
  RAND_bytes(buf, 8);
  unsigned __int8 v24 = buf[0];
  uint64_t v25 = EVP_HPKE_AEAD_aead((uint64_t)v21);
  uint64_t v26 = EVP_AEAD_max_overhead(v25);
  *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v64 = v27;
  __int128 v65 = v27;
  *(_OWORD *)buf = v27;
  CBB_zero(buf);
  *(void *)&__int128 v28 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v61 = v28;
  __int128 v62 = v28;
  __int128 v59 = v28;
  __int128 v60 = v28;
  __int128 v57 = v28;
  __int128 v58 = v28;
  v48[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  BOOL v18 = CBB_init((uint64_t)buf, 0x100uLL)
     && CBB_add_u16((uint64_t)buf, 1u)
     && (unsigned int v29 = EVP_HPKE_KDF_id(v21), CBB_add_u16((uint64_t)buf, v29))
     && CBB_add_u8((uint64_t)buf, v22)
     && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)&v60)
     && CBB_add_bytes((uint64_t)&v60, &v69, 0x20uLL)
     && CBB_add_u16_length_prefixed((uint64_t *)buf, (uint64_t)&v57)
     && (uint64_t v30 = ((32LL * (v24 & 3)) | 0x80) + v26, CBB_add_space((uint64_t)&v57, v48, v30))
     && RAND_bytes(v48[0], v30)
     && bssl::CBBFinishArray((uint64_t)buf, a1 + 568);
  CBB_cleanup((uint64_t)buf);
  return v18;
}

void sub_187572AAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

uint64_t bssl::ssl_add_client_hello(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *(void *)this;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18[1] = v4;
  _OWORD v18[2] = v4;
  v18[0] = v4;
  CBB_zero(v18);
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[1] = v5;
  v17[2] = v5;
  v17[0] = v5;
  uint64_t v6 = *((void *)this + 193);
  char v16 = -86;
  unint64_t v14 = 0LL;
  size_t v15 = 0LL;
  __int128 v7 = (const ssl_session_st *)(2 * (v6 != 0));
  unint64_t v8 = CBB_len((uint64_t)v17);
  if (!bssl::ssl_add_clienthello_tlsext((uint64_t)this, (uint64_t *)v17, 0LL, &v16, v7, v8)
    || ((*(uint64_t (**)(uint64_t, _OWORD *, void **))(*(void *)v3 + 96LL))(v3, v18, &v14) & 1) == 0)
  {
    goto LABEL_9;
  }

  if (!v16) {
    goto LABEL_8;
  }
  if (v6) {
    __assert_rtn("ssl_add_client_hello", "handshake_client.cc", 384, "type != ssl_client_hello_outer");
  }
  if (bssl::tls13_write_psk_binder( (uint64_t *)this,  (ssl_session_st *)((char *)this + 424),  (char *)v14,  v15,  0LL))
  {
LABEL_8:
    __int128 v9 = *(uint64_t (**)(uint64_t, void **))(*(void *)v3 + 104LL);
    OPENSSL_free(0LL);
    uint64_t v12 = v14;
    size_t v13 = v15;
    unint64_t v14 = 0LL;
    size_t v15 = 0LL;
    uint64_t v10 = v9(v3, &v12);
    OPENSSL_free(v12);
    uint64_t v12 = 0LL;
    size_t v13 = 0LL;
  }

  else
  {
LABEL_9:
    uint64_t v10 = 0LL;
  }

  OPENSSL_free(v14);
  CBB_cleanup((uint64_t)v18);
  return v10;
}

void sub_187572CFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  bssl::Array<unsigned short>::~Array((uint64_t)va);
  bssl::Array<unsigned short>::~Array((uint64_t)va1);
  CBB_cleanup(v2 - 80);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls_init_message(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  if (CBB_init((uint64_t)a2, 0x40uLL)
    && CBB_add_u8((uint64_t)a2, a4)
    && CBB_add_u24_length_prefixed(a2, a3))
  {
    return 1LL;
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 176);
  CBB_cleanup((uint64_t)a2);
  return 0LL;
}

uint64_t CBB_add_u24_length_prefixed(uint64_t *a1, uint64_t a2)
{
  return cbb_add_length_prefixed(a1, a2, 3u);
}

uint64_t bssl::ssl_write_client_hello_without_extensions(uint64_t a1, uint64_t *a2, int a3, char a4)
{
  uint64_t v8 = *(void *)a1;
  uint64_t result = CBB_add_u16((uint64_t)a2, *(unsigned __int16 *)(a1 + 1588));
  if ((_DWORD)result)
  {
    uint64_t v10 = (const void *)(a3 == 1 ? a1 + 504 : *(void *)(v8 + 48) + 48LL);
    uint64_t result = CBB_add_bytes((uint64_t)a2, v10, 0x20uLL);
    if ((_DWORD)result)
    {
      *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v30[1] = v11;
      v30[2] = v11;
      v30[0] = v11;
      uint64_t result = CBB_add_u8_length_prefixed(a2, (uint64_t)v30);
      if ((_DWORD)result)
      {
        if ((*(_WORD *)(*(void *)(v8 + 48) + 220LL) & 0x20) != 0
          || (a4 & 1) != 0
          || (uint64_t result = CBB_add_bytes((uint64_t)v30, (const void *)(a1 + 1597), *(unsigned __int8 *)(a1 + 1629)),
              (_DWORD)result))
        {
          if (!SSL_is_dtls((unsigned __int8 **)v8)
            || (uint64_t result = CBB_add_u8_length_prefixed(a2, (uint64_t)v30), (_DWORD)result)
            && (uint64_t result = CBB_add_bytes((uint64_t)v30, *(const void **)(a1 + 552), *(void *)(a1 + 560)), (_DWORD)result))
          {
            uint64_t v12 = *(void *)a1;
            BOOL v13 = *(void *)(*(void *)(a1 + 8) + 64LL) == 0LL;
            *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v31[1] = v14;
            v31[2] = v14;
            v31[0] = v14;
            size_t v15 = (ssl_credential_st *)CBB_add_u16_length_prefixed(a2, (uint64_t)v31);
            if (!(_DWORD)v15) {
              return 0LL;
            }
            if ((*(_WORD *)(*(void *)(v12 + 120) + 832LL) & 0x20) != 0)
            {
              unsigned int grease_value = bssl::ssl_get_grease_value(a1, 0);
              size_t v15 = (ssl_credential_st *)CBB_add_u16((uint64_t)v31, grease_value);
              if (!(_DWORD)v15) {
                return 0LL;
              }
            }

            if (*(unsigned __int16 *)(a1 + 30) >= 0x304u)
            {
              unsigned int v17 = *(unsigned __int16 *)(*(void *)(v12 + 8) + 301LL);
              int v18 = (v17 & 0x800) != 0 ? (v17 >> 12) & 1 : ssl_credential_st::UsesPrivateKey(v15);
              if (!v18
                && (*(_BYTE *)(*(void *)(**(void **)(a1 + 8) + 120LL) + 248LL) & 4) != 0
                && bssl::ssl_tls13_cipher_meets_policy(4867, *(_DWORD *)(*(void *)(v12 + 8) + 296LL))
                && !CBB_add_u16((uint64_t)v31, 0x1303u)
                || (*(_BYTE *)(*(void *)(**(void **)(a1 + 8) + 120LL) + 248LL) & 2) != 0
                && bssl::ssl_tls13_cipher_meets_policy(4865, *(_DWORD *)(*(void *)(v12 + 8) + 296LL))
                && !CBB_add_u16((uint64_t)v31, 0x1301u)
                || (*(_BYTE *)(*(void *)(**(void **)(a1 + 8) + 120LL) + 248LL) & 2) != 0
                && bssl::ssl_tls13_cipher_meets_policy(4866, *(_DWORD *)(*(void *)(v12 + 8) + 296LL))
                && !CBB_add_u16((uint64_t)v31, 0x1302u)
                || v18
                && (*(_BYTE *)(*(void *)(**(void **)(a1 + 8) + 120LL) + 248LL) & 4) != 0
                && bssl::ssl_tls13_cipher_meets_policy(4867, *(_DWORD *)(*(void *)(v12 + 8) + 296LL))
                && !CBB_add_u16((uint64_t)v31, 0x1303u))
              {
                return 0LL;
              }
            }

            if (a3 != 1 && *(unsigned __int16 *)(a1 + 28) <= 0x303u)
            {
              ciphers = SSL_get_ciphers((const SSL *)v12);
              uint64_t v20 = EVP_MD_CTX_md((const EVP_MD_CTX *)ciphers);
              if (!v20) {
                goto LABEL_49;
              }
              unint64_t v21 = v20;
              char v22 = 0;
              unint64_t v23 = 0LL;
              int v24 = 8 * v13;
              uint64_t v25 = (char *)&v20[-1].ctx_size + 7;
              do
              {
                while (1)
                {
                  uint64_t v26 = OPENSSL_sk_value((unint64_t *)ciphers, v23);
                  if ((*((_DWORD *)v26 + 5) & v24) != 0) {
                    break;
                  }
                  uint64_t v27 = (uint64_t)v26;
                  if (((_DWORD)v26[3] & v24) != 0
                    || SSL_CIPHER_get_min_version(v26) > *(unsigned __int16 *)(a1 + 30)
                    || SSL_CIPHER_get_max_version(v27) < *(unsigned __int16 *)(a1 + 28))
                  {
                    break;
                  }

                  unsigned int protocol_id = SSL_CIPHER_get_protocol_id(v27);
                  char v22 = 1;
                }

                ++v23;
              }

              while (v21 != (const EVP_MD *)v23);
              if ((v22 & 1) == 0)
              {
LABEL_49:
                if (*(unsigned __int16 *)(a1 + 30) <= 0x303u)
                {
                  ERR_put_error( 16,  0,  175,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc",  309);
                  return 0LL;
                }
              }
            }

uint64_t CBB_add_u8_length_prefixed(uint64_t *a1, uint64_t a2)
{
  return cbb_add_length_prefixed(a1, a2, 1u);
}

STACK *__cdecl SSL_get_ciphers(STACK *s)
{
  if (s)
  {
    data = s->data;
    if (!data) {
      SSL_get_ciphers_cold_1();
    }
    uint64_t v2 = (STACK **)data[3];
    if (!v2) {
      uint64_t v2 = (STACK **)*((void *)s[3].comp + 30);
    }
    return *v2;
  }

  return s;
}

uint64_t SSL_CIPHER_get_min_version(_DWORD *a1)
{
  if (a1[5] == 16 || a1[6] == 16) {
    return 772LL;
  }
  if (a1[9] == 1) {
    return 768LL;
  }
  return 771LL;
}

uint64_t SSL_CIPHER_get_max_version(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) == 16)
  {
    return 772;
  }

  else if (*(_DWORD *)(a1 + 24) == 16)
  {
    return 772;
  }

  else
  {
    return 771;
  }

uint64_t SSL_CIPHER_get_protocol_id(uint64_t a1)
{
  if (HIBYTE(*(_DWORD *)(a1 + 16)) != 3) {
    SSL_CIPHER_get_protocol_id_cold_1();
  }
  return (unsigned __int16)*(_DWORD *)(a1 + 16);
}

unint64_t CBB_len(uint64_t a1)
{
  if (*(void *)a1) {
    CBB_len_cold_2();
  }
  if (!*(_BYTE *)(a1 + 8)) {
    return *(void *)(a1 + 24);
  }
  unint64_t v1 = *(void *)(a1 + 24) + *(unsigned __int8 *)(a1 + 32);
  unint64_t v2 = *(void *)(*(void *)(a1 + 16) + 8LL);
  unint64_t result = v2 - v1;
  if (v2 < v1) {
    CBB_len_cold_1();
  }
  return result;
}

BOOL bssl::ssl_add_clienthello_tlsext( uint64_t a1, uint64_t *a2, uint64_t *a3, _BYTE *a4, const ssl_session_st *a5, uint64_t a6)
{
  *a4 = 0;
  if ((_DWORD)a5 != 1)
  {
    if (a3) {
      bssl::ssl_add_clienthello_tlsext();
    }
    uint64_t v38 = *(void *)a1;
    *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v84 = v39;
    __int128 v85 = v39;
    __int128 v83 = v39;
    if (!CBB_add_u16_length_prefixed(a2, (uint64_t)&v83))
    {
      int v47 = 3895;
LABEL_52:
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v47);
      return 0LL;
    }

    *(_DWORD *)(a1 + 376) = 0;
    if ((*(_WORD *)(*(void *)(v38 + 120) + 832LL) & 0x20) != 0)
    {
      unsigned int grease_value = bssl::ssl_get_grease_value(a1, 2u);
    }

    __int128 v75 = a2;
    BOOL v77 = a4;
    for (uint64_t i = 0LL; i != 28; ++i)
    {
      uint64_t v42 = i;
      if (*(void *)(a1 + 720)) {
        uint64_t v42 = *(unsigned __int8 *)(*(void *)(a1 + 712) + i);
      }
      unint64_t v43 = CBB_len((uint64_t)&v83);
      if (!(*(unsigned int (**)(uint64_t, __int128 *, __int128 *, const ssl_session_st *))&bssl::kExtensions[20 * v42 + 4])( a1,  &v83,  &v83,  a5))
      {
        ERR_put_error(16, 0, 147, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3918);
        ERR_add_error_dataf("extension %u", v48, v49, v50, v51, v52, v53, v54, bssl::kExtensions[20 * v42]);
        return 0LL;
      }

      unint64_t v44 = CBB_len((uint64_t)&v83);
      if (v44 != v43) {
        *(_DWORD *)(a1 + 376) |= 1 << v42;
      }
    }

    BOOL v45 = v44 - v43 == 4;
    if ((*(_WORD *)(*(void *)(v38 + 120) + 832LL) & 0x20) != 0)
    {
      unsigned int v56 = bssl::ssl_get_grease_value(a1, 3u);
      BOOL v45 = 0;
      BOOL v35 = 0LL;
      char v46 = v75;
    }

    else
    {
      char v46 = v75;
    }

    uint64_t v57 = *(void *)a1;
    if (bssl::should_offer_psk((uint64_t *)a1, a5))
    {
      digest = bssl::ssl_session_get_digest(*(bssl **)(v57 + 104), v58);
      uint64_t v60 = EVP_MD_size(digest) + *(void *)(*(void *)(v57 + 104) + 240LL) + 15LL;
    }

    else
    {
      uint64_t v60 = 0LL;
    }

    if (SSL_is_dtls((unsigned __int8 **)v38)
      || *(void *)(v38 + 168)
      || (*(_WORD *)(*(void *)(v38 + 48) + 220LL) & 0x2000) != 0)
    {
LABEL_74:
      unint64_t v73 = CBB_len((uint64_t)&v83);
      if ((bssl::ext_pre_shared_key_add_clienthello((uint64_t *)a1, (uint64_t *)&v83, v77, a5) & 1) != 0)
      {
        return CBB_flush(v46) != 0;
      }

      int v47 = 3992;
      goto LABEL_52;
    }

    unint64_t v61 = a6 + v60 + CBB_len((uint64_t)&v83);
    unint64_t v62 = v61 + 6;
    BOOL v63 = v60 == 0;
    unint64_t v64 = v61 + 11;
    size_t v65 = v45 & v63;
    if (!v45 || !v63) {
      unint64_t v64 = v62;
    }
    if ((v64 & 0xFFFFFFFFFFFFFF00LL) == 0x100)
    {
      if (v62 > 0x1FB)
      {
        size_t v65 = 1LL;
        goto LABEL_73;
      }

      size_t v65 = 508 - v62;
    }

    if (!v65) {
      goto LABEL_74;
    }
LABEL_73:
    goto LABEL_74;
  }

  uint64_t v10 = *(void *)a1;
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v84 = v11;
  __int128 v85 = v11;
  __int128 v83 = v11;
  CBB_zero(&v83);
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v82[1] = v12;
  v82[2] = v12;
  v82[0] = v12;
  CBB_zero(v82);
  *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v81[1] = v13;
  v81[2] = v13;
  v80[2] = v13;
  v81[0] = v13;
  v80[0] = v13;
  v80[1] = v13;
  if (CBB_add_u16_length_prefixed(a2, (uint64_t)v81)
    && CBB_add_u16_length_prefixed(a3, (uint64_t)v80)
    && CBB_init((uint64_t)&v83, 0x40uLL)
    && CBB_init((uint64_t)v82, 0x40uLL))
  {
    *(_DWORD *)(a1 + 380) = 0;
    if ((*(_WORD *)(*(void *)(v10 + 120) + 832LL) & 0x20) == 0
      || (unsigned int v14 = bssl::ssl_get_grease_value(a1, 2u), bssl::add_padding_extension((uint64_t *)&v83, v14, 0LL))
      && CBB_add_u16((uint64_t)v82, v14))
    {
      uint64_t v74 = v10;
      uint64_t v76 = a4;
      size_t v15 = a2;
      for (uint64_t j = 0LL; j != 28; ++j)
      {
        uint64_t v17 = j;
        if (*(void *)(a1 + 720)) {
          uint64_t v17 = *(unsigned __int8 *)(*(void *)(a1 + 712) + j);
        }
        unint64_t v18 = CBB_len((uint64_t)v81);
        unint64_t v19 = CBB_len((uint64_t)&v83);
        uint64_t v20 = &bssl::kExtensions[20 * v17];
        if (((*((uint64_t (**)(uint64_t, _OWORD *, __int128 *, uint64_t))v20 + 1))(a1, v81, &v83, 1LL) & 1) == 0)
        {
          ERR_put_error(16, 0, 147, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3811);
          ERR_add_error_dataf("extension %u", v66, v67, v68, v69, v70, v71, v72, *v20);
          goto LABEL_71;
        }

        unint64_t v21 = CBB_len((uint64_t)v81);
        unint64_t v22 = CBB_len((uint64_t)&v83);
        if (v21 != v18 && v22 != v19) {
          __assert_rtn( "ssl_add_clienthello_tlsext_inner",  "extensions.cc",  3820,  "bytes_written == 0 || bytes_written_compressed == 0");
        }
        if (v21 != v18 || v22 != v19) {
          *(_DWORD *)(a1 + 380) |= 1 << v17;
        }
      }

      unint64_t v23 = v15;
      if ((*(_WORD *)(*(void *)(v74 + 120) + 832LL) & 0x20) == 0
        || (unsigned int v24 = bssl::ssl_get_grease_value(a1, 3u), bssl::add_padding_extension((uint64_t *)&v83, v24, 1uLL))
        && CBB_add_u16((uint64_t)v82, v24))
      {
        uint64_t v25 = CBB_data((uint64_t)v81);
        size_t v26 = CBB_len((uint64_t)v81);
        if (CBB_add_bytes((uint64_t)v80, v25, v26))
        {
          *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v79[1] = v27;
          v79[2] = v27;
          v78[2] = v27;
          v79[0] = v27;
          v78[0] = v27;
          v78[1] = v27;
          __int128 v28 = CBB_data((uint64_t)&v83);
          size_t v29 = CBB_len((uint64_t)&v83);
          if (CBB_add_bytes((uint64_t)v81, v28, v29))
          {
            if (CBB_add_u16((uint64_t)v80, 0xFD00u))
            {
              if (CBB_add_u16_length_prefixed((uint64_t *)v80, (uint64_t)v79))
              {
                if (CBB_add_u8_length_prefixed((uint64_t *)v79, (uint64_t)v78))
                {
                  uint64_t v30 = CBB_data((uint64_t)v82);
                  size_t v31 = CBB_len((uint64_t)v82);
                  if (CBB_add_bytes((uint64_t)v78, v30, v31))
                  {
                    if (CBB_flush((uint64_t *)v80))
                    {
LABEL_85:
                      unint64_t v32 = CBB_len((uint64_t)v81);
                      if (bssl::ext_pre_shared_key_add_clienthello( (uint64_t *)a1,  (uint64_t *)v81,  v76,  (const ssl_session_st *)1))
                      {
                        uint64_t v33 = CBB_data((uint64_t)v81);
                        unint64_t v34 = CBB_len((uint64_t)v81);
                        if (CBB_add_bytes((uint64_t)v80, (char *)v33 + v32, v34 - v32))
                        {
                          if (CBB_flush(v23))
                          {
                            BOOL v35 = CBB_flush(a3) != 0;
                            goto LABEL_50;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

LABEL_71:
    BOOL v35 = 0LL;
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3787);
    BOOL v35 = 0LL;
  }
        }

LABEL_50:
  CBB_cleanup((uint64_t)v82);
  CBB_cleanup((uint64_t)&v83);
  return v35;
}

        if (v29 < 0)
        {
          unsigned int v14 = BN_from_montgomery(rr, &r, in_mont, ctx) != 0;
          goto LABEL_60;
        }

        unint64_t v32 = 0;
        uint64_t v33 = 0;
        while (BN_mod_mul_montgomery(&r, &r, &r, in_mont, ctx))
        {
          uint64_t v33 = BN_is_bit_set(p, v29 + v32--) + 2 * v33;
          if (!(v36 + v32))
          {
            v29 += v32;
            size_t v26 = (void *)v38;
            if (BN_mod_mul_montgomery(&r, &r, &b, in_mont, ctx)) {
              goto LABEL_50;
            }
            goto LABEL_56;
          }
        }
      }
    }

    unsigned int v14 = 0;
LABEL_60:
    unint64_t v18 = v37;
    size_t v26 = (void *)v38;
    goto LABEL_64;
  }

  if (BN_abs_is_word((unsigned int *)m, 1LL))
  {
    BN_zero((uint64_t)rr);
    return 1;
  }

  return BN_one((uint64_t)rr);
}

      size_t v15 = (v15 + 1);
      if (v12)
      {
        if (BN_rshift1(r, ret))
        {
          unsigned int v40 = v15;
          unint64_t v23 = 0LL;
          while (1)
          {
            unint64_t v44 = -1431655766;
            unsigned int v24 = BN_primality_test(&v44, ret, 1, v14, 0, 0LL);
            uint64_t v25 = v44;
            if (!v24) {
              uint64_t v25 = -1;
            }
            if (v25 == -1) {
              break;
            }
            if (!v25) {
              goto LABEL_83;
            }
            BOOL v45 = -1431655766;
            size_t v26 = BN_primality_test(&v45, r, 1, v14, 0, 0LL);
            __int128 v27 = v45;
            if (!v26) {
              __int128 v27 = -1;
            }
            if (v27 == -1) {
              goto LABEL_85;
            }
            if (!v27)
            {
LABEL_83:
              size_t v15 = v40;
              goto LABEL_17;
            }

            unint64_t v23 = (v23 + 1);
            __int128 v28 = 1;
            if (v11 == (_DWORD)v23) {
              goto LABEL_86;
            }
          }
        }

        goto LABEL_85;
      }

      unint64_t v43 = -1431655766;
      size_t v29 = BN_primality_test(&v43, ret, v11, v14, 0, (uint64_t)cb);
      uint64_t v30 = v43;
      if (!v29) {
        uint64_t v30 = -1;
      }
      if (v30)
      {
        __int128 v28 = v30 != -1;
        goto LABEL_86;
      }
    }

    unint64_t v18 = BN_CTX_get(v14);
    unint64_t v19 = BN_CTX_get(v14);
    if (v19)
    {
      uint64_t v20 = v19;
      if (BN_rshift1(v19, add))
      {
        if (BN_rand(v18, bits - 1, 0, 1) && BN_div(0LL, v17, v18, v20, v14) && BN_sub(v18, v18, v17))
        {
          if (a)
          {
            if (!BN_rshift1(v17, a) || !BN_add(v18, v18, v17)) {
              goto LABEL_84;
            }
LABEL_70:
            if (BN_lshift1(ret, v18) && BN_add_word(ret, 1uLL))
            {
              if (ret->top <= 16) {
                size_t v31 = 512LL;
              }
              else {
                size_t v31 = 1024LL;
              }
              unint64_t v32 = 1LL;
              do
              {
                while (1)
                {
                  uint64_t v33 = (unsigned __int16)kPrimes[v32];
                  if (!bn_mod_u16_consttime((uint64_t)ret, v33)
                    || !bn_mod_u16_consttime((uint64_t)v18, v33))
                  {
                    break;
                  }

                  if (++v32 == v31) {
                    goto LABEL_48;
                  }
                }

                if (!BN_add(ret, ret, add)) {
                  break;
                }
                unint64_t v32 = 1LL;
              }

              while (BN_add(v18, v18, v20));
            }

            goto LABEL_84;
          }

          if (BN_add_word(v18, 1uLL)) {
            goto LABEL_70;
          }
        }
      }
    }

void sub_18757394C(_Unwind_Exception *a1)
{
}

BOOL bssl::add_padding_extension(uint64_t *a1, unsigned int a2, size_t a3)
{
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v5;
  int64x2_t v7[2] = v5;
  v7[0] = v5;
  if (CBB_add_u16((uint64_t)a1, a2)
    && CBB_add_u16_length_prefixed(a1, (uint64_t)v7)
    && CBB_add_zeros((uint64_t)v7, a3))
  {
    return CBB_flush(a1) != 0;
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3766);
  return 0LL;
}

uint64_t CBB_add_zeros(uint64_t a1, size_t a2)
{
  uint64_t v4 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBB_add_space(a1, &v4, a2);
  if ((_DWORD)result)
  {
    if (a2) {
      bzero(v4, a2);
    }
    return 1LL;
  }

  return result;
}

uint64_t bssl::ext_sni_add_clienthello(void *a1, uint64_t *a2, uint64_t a3, int a4)
{
  if (a4 == 2)
  {
    uint64_t v5 = a1[193];
    uint64_t v6 = *(const void **)(v5 + 32);
    size_t v7 = *(void *)(v5 + 40);
  }

  else
  {
    uint64_t v6 = *(const void **)(*a1 + 160LL);
    if (!v6) {
      return 1LL;
    }
    size_t v7 = strlen(*(const char **)(*a1 + 160LL));
  }

  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[1] = v8;
  v12[2] = v8;
  v12[0] = v8;
  v11[1] = v8;
  int64x2_t v11[2] = v8;
  v10[2] = v8;
  v11[0] = v8;
  v10[0] = v8;
  v10[1] = v8;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v12);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v12, (uint64_t)v11);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8((uint64_t)v11, 0);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v11, (uint64_t)v10);
          if ((_DWORD)result)
          {
            uint64_t result = CBB_add_bytes((uint64_t)v10, v6, v7);
            if ((_DWORD)result) {
              return CBB_flush(a2) != 0;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ech_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  if (a4 == 1)
  {
    uint64_t result = CBB_add_u16((uint64_t)a2, 0xFE0Du);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16((uint64_t)a2, 1u);
      if ((_DWORD)result)
      {
        int v6 = CBB_add_u8((uint64_t)a2, 1u);
        return v6 != 0;
      }
    }
  }

  else if (*(void *)(a1 + 576))
  {
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[1] = v8;
    int64x2_t v9[2] = v8;
    v9[0] = v8;
    uint64_t result = CBB_add_u16((uint64_t)a2, 0xFE0Du);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v9);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8((uint64_t)v9, 0);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_bytes((uint64_t)v9, *(const void **)(a1 + 568), *(void *)(a1 + 576));
          if ((_DWORD)result)
          {
            int v6 = CBB_flush(a2);
            return v6 != 0;
          }
        }
      }
    }
  }

  else
  {
    return 1LL;
  }

  return result;
}

uint64_t bssl::ext_ems_add_clienthello(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = 1LL;
  if (a4 != 1 && *(unsigned __int16 *)(a1 + 28) <= 0x303u)
  {
    uint64_t result = CBB_add_u16(a2, 0x17u);
    if ((_DWORD)result) {
      return CBB_add_u16(a2, 0) != 0;
    }
  }

  return result;
}

uint64_t bssl::ext_ri_add_clienthello(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t result = 1LL;
  if (a4 != 1 && a1[14] <= 0x303u)
  {
    uint64_t v6 = *(void *)a1;
    if ((*(_BYTE *)(*(void *)(*(void *)a1 + 48LL) + 455LL) != 0) != (*(_WORD *)(*(void *)(*(void *)a1 + 48LL)
                                                                                   + 220LL) & 0x20u) >> 5)
      bssl::ext_ri_add_clienthello();
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10[1] = v8;
    v10[2] = v8;
    int64x2_t v9[2] = v8;
    v10[0] = v8;
    v9[0] = v8;
    v9[1] = v8;
    uint64_t result = CBB_add_u16((uint64_t)a2, 0xFF01u);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v10);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v10, (uint64_t)v9);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_bytes( (uint64_t)v9,  (const void *)(*(void *)(v6 + 48) + 443LL),  *(unsigned __int8 *)(*(void *)(v6 + 48) + 455LL));
          if ((_DWORD)result) {
            return CBB_flush(a2) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_supported_groups_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *(void *)a1;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0xAu);
  if ((_DWORD)result)
  {
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v15[1] = v7;
    int64x2_t v15[2] = v7;
    _OWORD v14[2] = v7;
    v15[0] = v7;
    v14[0] = v7;
    v14[1] = v7;
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v15);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v15, (uint64_t)v14);
      if ((_DWORD)result)
      {
        if ((*(_WORD *)(*(void *)(v5 + 120) + 832LL) & 0x20) == 0
          || (unsigned int grease_value = bssl::ssl_get_grease_value(a1, 1u),
              uint64_t result = CBB_add_u16((uint64_t)v14, grease_value),
              (_DWORD)result))
        {
          uint64_t v9 = *(void *)(a1 + 8);
          uint64_t v10 = *(void *)(v9 + 112);
          if (v10)
          {
            __int128 v11 = *(__int16 **)(v9 + 104);
          }

          else
          {
            __int128 v11 = &bssl::kDefaultGroups;
            uint64_t v10 = 4LL;
          }

          uint64_t v12 = 2 * v10;
          while (1)
          {
            unsigned int v13 = (unsigned __int16)*v11;
            if (v13 != 25497 || *(unsigned __int16 *)(a1 + 30) >= 0x304u)
            {
              uint64_t result = CBB_add_u16((uint64_t)v14, v13);
              if (!(_DWORD)result) {
                break;
              }
            }

            ++v11;
            v12 -= 2LL;
            if (!v12) {
              return CBB_flush(a3) != 0;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ec_point_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  else {
    return bssl::ext_ec_point_add_extension(a2);
  }
}

uint64_t bssl::ext_ec_point_add_extension(uint64_t *a1)
{
  uint64_t result = CBB_add_u16((uint64_t)a1, 0xBu);
  if ((_DWORD)result)
  {
    *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v5[1] = v3;
    v5[2] = v3;
    v4[2] = v3;
    v5[0] = v3;
    v4[0] = v3;
    v4[1] = v3;
    uint64_t result = CBB_add_u16_length_prefixed(a1, (uint64_t)v5);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v5, (uint64_t)v4);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8((uint64_t)v4, 0);
        if ((_DWORD)result) {
          return CBB_flush(a1) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ticket_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t result = 1LL;
  if (a4 != 1)
  {
    uint64_t v17 = v4;
    uint64_t v18 = v5;
    if (*(unsigned __int16 *)(a1 + 28) <= 0x303u)
    {
      uint64_t v9 = *(void *)a1;
      if ((SSL_get_options(*(void *)a1) & 0x4000) != 0)
      {
        return 1LL;
      }

      else
      {
        if ((*(_WORD *)(*(void *)(v9 + 48) + 220LL) & 0x20) == 0
          && (__int128 v11 = *(bssl **)(v9 + 104)) != 0LL
          && *((void *)v11 + 30)
          && bssl::ssl_session_protocol_version(v11, v10) <= 0x303)
        {
          uint64_t v12 = *(void *)(v9 + 104);
          unsigned int v14 = *(const void **)(v12 + 232);
          size_t v13 = *(void *)(v12 + 240);
        }

        else
        {
          size_t v13 = 0LL;
          unsigned int v14 = 0LL;
        }

        *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v16[1] = v15;
        _OWORD v16[2] = v15;
        v16[0] = v15;
        uint64_t result = CBB_add_u16((uint64_t)a2, 0x23u);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v16);
          if ((_DWORD)result)
          {
            uint64_t result = CBB_add_bytes((uint64_t)v16, v14, v13);
            if ((_DWORD)result) {
              return CBB_flush(a2) != 0;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t SSL_get_options(uint64_t a1)
{
  return *(unsigned int *)(a1 + 144);
}

uint64_t bssl::ext_alpn_add_clienthello(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  if (!*(void *)(a1[1] + 136))
  {
    if (*(void *)(v3 + 168))
    {
      ERR_put_error(16, 0, 307, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1382);
      return 0LL;
    }

    return 1LL;
  }

  if ((*(_WORD *)(*(void *)(v3 + 48) + 220LL) & 0x20) != 0) {
    return 1LL;
  }
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v6;
  int64x2_t v9[2] = v6;
  v8[2] = v6;
  v9[0] = v6;
  v8[0] = v6;
  v8[1] = v6;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x10u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v9);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v9, (uint64_t)v8);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_bytes((uint64_t)v8, *(const void **)(a1[1] + 128), *(void *)(a1[1] + 136));
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ocsp_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if ((*(_WORD *)(*(void *)(a1 + 8) + 301LL) & 4) == 0) {
    return 1LL;
  }
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v5;
  v6[2] = v5;
  v6[0] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a3, 5u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v6);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8((uint64_t)v6, 1u);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u16((uint64_t)v6, 0);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_u16((uint64_t)v6, 0);
          if ((_DWORD)result) {
            return CBB_flush(a3) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_sigalgs_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  int64x2_t v7[2] = v6;
  v8[0] = v6;
  v7[0] = v6;
  v7[1] = v6;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0xDu);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        uint64_t result = bssl::tls12_add_verify_sigalgs(a1, (uint64_t)v7);
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

BOOL bssl::tls12_add_verify_sigalgs(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(v3 + 264);
  if (v4)
  {
    __int128 v5 = *(__int16 **)(v3 + 256);
  }

  else
  {
    __int128 v5 = &bssl::kVerifySignatureAlgorithms;
    uint64_t v4 = 10LL;
  }

  uint64_t v6 = 2 * v4 - 2;
  do
  {
    unsigned int v7 = (unsigned __int16)*v5++;
    int v8 = CBB_add_u16(a2, v7);
    if (v8) {
      BOOL v9 = v6 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    v6 -= 2LL;
  }

  while (!v9);
  return v8 != 0;
}

uint64_t bssl::ext_npn_add_clienthello(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *a1;
  if (!*(void *)(*(void *)(v5 + 120) + 592LL)
    || (*(_WORD *)(*(void *)(v5 + 48) + 220LL) & 0x20) != 0
    || SSL_is_dtls((unsigned __int8 **)v5))
  {
    return 1LL;
  }

  uint64_t result = 1LL;
  if (a4 != 1 && *((unsigned __int16 *)a1 + 14) <= 0x303u)
  {
    uint64_t result = CBB_add_u16(a2, 0x3374u);
    if ((_DWORD)result) {
      return CBB_add_u16(a2, 0) != 0;
    }
  }

  return result;
}

uint64_t bssl::ext_sct_add_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_WORD *)(*(void *)(a1 + 8) + 301LL) & 2) == 0) {
    return 1LL;
  }
  uint64_t result = CBB_add_u16(a3, 0x12u);
  if ((_DWORD)result) {
    return CBB_add_u16(a3, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_channel_id_add_clienthello(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(void *)(*(void *)(a1 + 8) + 120LL)) {
    return 1LL;
  }
  int is_dtls = SSL_is_dtls(*(unsigned __int8 ***)a1);
  uint64_t result = 1LL;
  if (a4 != 2 && !is_dtls)
  {
    uint64_t result = CBB_add_u16(a2, 0x7550u);
    if ((_DWORD)result) {
      return CBB_add_u16(a2, 0) != 0;
    }
  }

  return result;
}

uint64_t bssl::ext_srtp_add_clienthello(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = (unsigned __int8 **)*a1;
  srtp_profiles = (const EVP_MD_CTX *)SSL_get_srtp_profiles(*a1);
  if (!srtp_profiles) {
    return 1LL;
  }
  uint64_t v6 = (EVP_MD_CTX *)srtp_profiles;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v7;
  _OWORD v14[2] = v7;
  int64x2_t v13[2] = v7;
  v14[0] = v7;
  v13[0] = v7;
  v13[1] = v7;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0xEu);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v14);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v14, (uint64_t)v13);
      if ((_DWORD)result)
      {
        BOOL v9 = EVP_MD_CTX_md(v6);
        if (v9)
        {
          uint64_t v10 = v9;
          unint64_t v11 = 0LL;
          while (1)
          {
            uint64_t v12 = OPENSSL_sk_value((unint64_t *)v6, v11);
            uint64_t result = CBB_add_u16((uint64_t)v13, *((unsigned __int16 *)v12 + 4));
            if (!(_DWORD)result) {
              break;
            }
            if (v10 == (const EVP_MD *)++v11) {
              goto LABEL_11;
            }
          }
        }

        else
        {
LABEL_11:
          uint64_t result = CBB_add_u8((uint64_t)v14, 0);
          if ((_DWORD)result) {
            return CBB_flush(a3) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t SSL_get_srtp_profiles(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    SSL_get_srtp_profiles_cold_1();
  }
  uint64_t v2 = *(void *)(v1 + 272);
  if (!v2) {
    return *(void *)(*(void *)(a1 + 120) + 696LL);
  }
  return v2;
}

uint64_t bssl::ext_key_share_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!*(void *)(a1 + 624)) {
    bssl::ext_key_share_add_clienthello();
  }
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  int64x2_t v7[2] = v6;
  v8[0] = v6;
  v7[0] = v6;
  v7[1] = v6;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x33u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_bytes((uint64_t)v7, *(const void **)(a1 + 616), *(void *)(a1 + 624));
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_psk_key_exchange_modes_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v5;
  int64x2_t v7[2] = v5;
  v6[2] = v5;
  v7[0] = v5;
  v6[0] = v5;
  v6[1] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x2Du);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v7);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v7, (uint64_t)v6);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8((uint64_t)v6, 1u);
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_early_data_add_clienthello(_BYTE *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 48LL);
  if ((*(_WORD *)(v3 + 220) & 0x2000) != 0)
  {
    if (!*(_DWORD *)(v3 + 256)) {
      bssl::ext_early_data_add_clienthello();
    }
    return 1LL;
  }

  if ((a1[1585] & 8) == 0) {
    return 1LL;
  }
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x2Au);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16((uint64_t)a3, 0);
    if ((_DWORD)result) {
      return CBB_flush(a3) != 0;
    }
  }

  return result;
}

uint64_t bssl::ext_supported_versions_add_clienthello(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  __int128 v7 = *(_BYTE ***)a1;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v9;
  _OWORD v14[2] = v9;
  int64x2_t v13[2] = v9;
  v14[0] = v9;
  v13[0] = v9;
  v13[1] = v9;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x2Bu);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v14);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v14, (uint64_t)v13);
      if ((_DWORD)result)
      {
        if ((*((_WORD *)v7[15] + 416) & 0x20) == 0
          || (unsigned int grease_value = bssl::ssl_get_grease_value(a1, 4u),
              uint64_t result = CBB_add_u16((uint64_t)v13, grease_value),
              (_DWORD)result))
        {
          if (a4 == 1) {
            unsigned int v11 = 772;
          }
          else {
            unsigned int v11 = 0;
          }
          int v12 = bssl::ssl_add_supported_versions((_BYTE ***)a1, (uint64_t)v13, v11);
          uint64_t result = 0LL;
          if (v12) {
            return CBB_flush(a3) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ssl_add_supported_versions(_BYTE ***a1, uint64_t a2, unsigned int a3)
{
  if (***a1) {
    uint64_t v6 = 4LL;
  }
  else {
    uint64_t v6 = 8LL;
  }
  if (***a1) {
    __int128 v7 = (unsigned __int16 *)&bssl::kDTLSVersions;
  }
  else {
    __int128 v7 = (unsigned __int16 *)&bssl::kTLSVersions;
  }
  do
  {
    unsigned int v8 = *v7;
    unsigned int v9 = v8;
    if (v8 - 769 >= 4)
    {
      if (v8 == 65277)
      {
        unsigned int v9 = 771;
      }

      else
      {
        if (v8 != 65279) {
          goto LABEL_15;
        }
        unsigned int v9 = 770;
      }
    }

    if (v9 >= a3)
    {
      uint64_t result = CBB_add_u16(a2, v8);
      if (!(_DWORD)result) {
        return result;
      }
    }

BOOL bssl::ssl_supports_version(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 8LL;
  if (***(_BYTE ***)a1) {
    uint64_t v2 = 4LL;
  }
  uint64_t v3 = (unsigned __int16 *)&bssl::kDTLSVersions;
  if (!***(_BYTE ***)a1) {
    uint64_t v3 = (unsigned __int16 *)&bssl::kTLSVersions;
  }
  uint64_t v4 = v2 - 2;
  do
  {
    int v6 = *v3++;
    int v5 = v6;
    BOOL v7 = v6 == a2 || v4 == 0;
    v4 -= 2LL;
  }

  while (!v7);
  if (v5 != a2) {
    return 0LL;
  }
  if (a2 - 769 >= 4)
  {
    if (a2 == 65277)
    {
      a2 = 771;
    }

    else
    {
      if (a2 != 65279) {
        return 0LL;
      }
      a2 = 770;
    }
  }

  return a2 <= *(unsigned __int16 *)(a1 + 30);
}

uint64_t bssl::ext_cookie_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!*(void *)(a1 + 544)) {
    return 1LL;
  }
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  int64x2_t v7[2] = v5;
  v8[0] = v5;
  v7[0] = v5;
  v7[1] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x2Cu);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_bytes((uint64_t)v7, *(const void **)(a1 + 536), *(void *)(a1 + 544));
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_quic_transport_params_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::ext_quic_transport_params_add_clienthello_impl(a1, a3, 0);
}

uint64_t bssl::ext_quic_transport_params_add_clienthello_impl(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 168LL);
  if (!*(void *)(v3 + 232))
  {
    if (!v4) {
      return 1LL;
    }
LABEL_13:
    ERR_put_error(16, 0, 305, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2599);
    return 0LL;
  }

  if (!v4) {
    goto LABEL_13;
  }
  unsigned int v6 = *(_WORD *)(v3 + 301) & 0x200;
  if (a3 != v6 >> 9) {
    return 1LL;
  }
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v8;
  int64x2_t v11[2] = v8;
  v11[0] = v8;
  if (v6) {
    unsigned int v9 = 65445;
  }
  else {
    unsigned int v9 = 57;
  }
  uint64_t result = CBB_add_u16((uint64_t)a2, v9);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v11);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_bytes( (uint64_t)v11,  *(const void **)(*(void *)(a1 + 8) + 224LL),  *(void *)(*(void *)(a1 + 8) + 232LL));
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_quic_transport_params_add_clienthello_legacy(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::ext_quic_transport_params_add_clienthello_impl(a1, a3, 1);
}

uint64_t bssl::cert_compression_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 120LL);
  uint64_t v4 = *(void *)(v3 + 704);
  if (!v4) {
    return 1LL;
  }
  uint64_t v6 = *(void *)(v3 + 712);
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = v7;
  int64x2_t v13[2] = v7;
  uint64_t v8 = v6 + 24 * v4;
  v12[2] = v7;
  v13[0] = v7;
  v12[0] = v7;
  v12[1] = v7;
  char v9 = 1;
  while (2)
  {
    for (v6 += 24LL; !*(void *)(v6 - 16); v6 += 24LL)
    {
      if (v6 == v8)
      {
        if ((v9 & 1) != 0) {
          return 1LL;
        }
        return CBB_flush(a3) != 0;
      }
    }

    if ((v9 & 1) == 0
      || (uint64_t result = CBB_add_u16((uint64_t)a3, 0x1Bu), (_DWORD)result)
      && (uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v13), (_DWORD)result)
      && (uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v13, (uint64_t)v12), (_DWORD)result))
    {
      uint64_t result = CBB_add_u16((uint64_t)v12, *(unsigned __int16 *)(v6 - 8));
      if ((_DWORD)result)
      {
        char v9 = 0;
        if (v6 != v8) {
          continue;
        }
        return CBB_flush(a3) != 0;
      }
    }

    break;
  }

  return result;
}

uint64_t bssl::ext_delegated_credential_add_clienthello()
{
  return 1LL;
}

uint64_t bssl::ext_alps_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::ext_alps_add_clienthello_impl(a1, a3, 1);
}

uint64_t bssl::ext_client_certificate_type_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  int64x2_t v7[2] = v5;
  v8[0] = v5;
  v7[0] = v5;
  v7[1] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x13u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_bytes( (uint64_t)v7,  *(const void **)(*(void *)(a1 + 8) + 192LL),  *(void *)(*(void *)(a1 + 8) + 200LL));
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_server_certificate_type_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  v8[2] = v5;
  int64x2_t v7[2] = v5;
  v8[0] = v5;
  v7[0] = v5;
  v7[1] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x14u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_bytes( (uint64_t)v7,  *(const void **)(*(void *)(a1 + 8) + 168LL),  *(void *)(*(void *)(a1 + 8) + 176LL));
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ticket_request_add_clienthello(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (!*(_BYTE *)(v6 + 216) && !*(_BYTE *)(v6 + 217)) {
    return 1LL;
  }
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v7;
  v8[2] = v7;
  v8[0] = v7;
  uint64_t result = CBB_add_u16((uint64_t)a3, 0x3Au);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a3, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8((uint64_t)v8, *(unsigned __int8 *)(*(void *)(a1 + 8) + 216LL));
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8((uint64_t)v8, *(unsigned __int8 *)(*(void *)(a1 + 8) + 217LL));
        if ((_DWORD)result) {
          return CBB_flush(a3) != 0;
        }
      }
    }
  }

  return result;
}

bssl *bssl::should_offer_psk(uint64_t *a1, const ssl_session_st *a2)
{
  uint64_t v4 = *a1;
  uint64_t result = *(bssl **)(*a1 + 104);
  if (result)
  {
    int v5 = (int)a2;
    unsigned int v6 = bssl::ssl_session_protocol_version(result, a2);
    uint64_t result = 0LL;
    if (v5 != 2 && v6 >= 0x304) {
      return (bssl *)((*(_WORD *)(*(void *)(v4 + 48) + 220LL) & 0x2000) == 0
    }
                   || *(_DWORD *)(*(void *)(*(void *)(v4 + 104) + 200LL) + 36LL) == *(_DWORD *)(a1[194] + 36));
  }

  return result;
}

uint64_t bssl::ext_pre_shared_key_add_clienthello( uint64_t *a1, uint64_t *a2, _BYTE *a3, const ssl_session_st *a4)
{
  uint64_t v6 = *a1;
  *a3 = 0;
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time(v6, (uint64_t)v22);
  int v7 = v22[0];
  uint64_t v8 = *(void *)(v6 + 104);
  int v9 = *(_DWORD *)(v8 + 192);
  int v10 = *(_DWORD *)(v8 + 376);
  int v11 = *(char *)(v8 + 440);
  digest = bssl::ssl_session_get_digest((bssl *)v8, v12);
  size_t v14 = EVP_MD_size(digest);
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[1] = v15;
  v21[2] = v15;
  v21[0] = v15;
  v20[1] = v15;
  _OWORD v20[2] = v15;
  v19[2] = v15;
  v20[0] = v15;
  v19[0] = v15;
  v19[1] = v15;
  v18[1] = v15;
  _OWORD v18[2] = v15;
  v17[2] = v15;
  v18[0] = v15;
  v17[0] = v15;
  v17[1] = v15;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x29u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v21);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v21, (uint64_t)v20);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v20, (uint64_t)v19);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_bytes( (uint64_t)v19,  *(const void **)(*(void *)(v6 + 104) + 232LL),  *(void *)(*(void *)(v6 + 104) + 240LL));
          if ((_DWORD)result)
          {
            uint64_t result = CBB_add_u32((uint64_t)v20, (v10 + 1000 * (v7 - v9)) & ~(v11 >> 31));
            if ((_DWORD)result)
            {
              uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v21, (uint64_t)v18);
              if ((_DWORD)result)
              {
                uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v18, (uint64_t)v17);
                if ((_DWORD)result)
                {
                  uint64_t result = CBB_add_zeros((uint64_t)v17, v14);
                  if ((_DWORD)result)
                  {
                    *a3 = 1;
                    return CBB_flush(a2) != 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

BOOL bssl::tls_finish_message(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return bssl::CBBFinishArray(a2, a3);
}

uint64_t bssl::tls_add_message(bssl *this, unint64_t *a2)
{
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (*((void *)this + 21) || **(void **)(*((void *)this + 6) + 272LL))
  {
    while (1)
    {
      if (!v5) {
        goto LABEL_30;
      }
      uint64_t v6 = *((void *)this + 6);
      uint64_t v9 = *(void *)(v6 + 232);
      uint64_t v8 = (BUF_MEM **)(v6 + 232);
      uint64_t result = v9;
      unint64_t v10 = *((unsigned __int16 *)this + 9);
      if (!v9) {
        break;
      }
      if (*(void *)result < v10) {
        goto LABEL_8;
      }
      uint64_t result = bssl::tls_flush_pending_hs_data(this, (ssl_st *)a2);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v11 = *((void *)this + 6);
      uint64_t v12 = *(void *)(v11 + 232);
      uint64_t v8 = (BUF_MEM **)(v11 + 232);
      uint64_t result = v12;
      if (v12)
      {
LABEL_8:
        int v13 = 0;
        uint64_t v14 = *(void *)result;
      }

      else
      {
        uint64_t v14 = 0LL;
        int v13 = 1;
      }

      size_t v15 = *((unsigned __int16 *)this + 9) - v14;
      if (v5 >= v15) {
        size_t v16 = v15;
      }
      else {
        size_t v16 = v5;
      }
      if (!v16) {
LABEL_35:
      }
        bssl::tls_add_message();
      uint64_t v17 = (char *)(v4 + v16);
      v5 -= v16;
      if (v13) {
        goto LABEL_21;
      }
      if (!result) {
        return result;
      }
LABEL_22:
      uint64_t result = BUF_MEM_append((void *)result, (const void *)v4, v16);
      unint64_t v4 = (unint64_t)v17;
      if (!(_DWORD)result) {
        return result;
      }
    }

    if (v5 >= v10) {
      size_t v16 = *((unsigned __int16 *)this + 9);
    }
    else {
      size_t v16 = v5;
    }
    if (!v16) {
      goto LABEL_35;
    }
    uint64_t v17 = (char *)(v4 + v16);
    v5 -= v16;
LABEL_21:
    uint64_t v18 = BUF_MEM_new();
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, v18);
    uint64_t result = *(void *)(*((void *)this + 6) + 232LL);
    if (!result) {
      return result;
    }
    goto LABEL_22;
  }

  while (v5)
  {
    else {
      unint64_t v19 = v5;
    }
    uint64_t v20 = (const unsigned __int8 *)(v4 + v19);
    v5 -= v19;
    char v21 = bssl::add_record_to_flight(this, (ssl_st *)0x16, v4, (const unsigned __int8 *)v19);
    unint64_t v4 = (unint64_t)v20;
    if ((v21 & 1) == 0) {
      return 0LL;
    }
  }

LABEL_30:
  bssl::ssl_do_msg_callback((uint64_t)this, 1LL, 22LL, *a2, a2[1]);
  uint64_t v22 = *(void *)(*((void *)this + 6) + 280LL);
  if (!v22) {
    return 1LL;
  }
  uint64_t result = bssl::SSLTranscript::Update((void **)(v22 + 424), (const void *)*a2, a2[1]);
  if ((_DWORD)result) {
    return 1LL;
  }
  return result;
}

    unint64_t v32 = bn_add_words(v21, v22, &v22[2 * a4], 2 * a4);
    uint64_t v33 = 4 * v23;
    unint64_t v34 = v23;
    BOOL v35 = v21;
    size_t v36 = &v21[4 * v34];
    uint64_t v37 = v32 - bn_sub_words(v36, v35, v17, 2 * a4);
    uint64_t v38 = bn_add_words(v17, v35, v17, 2 * a4) + v32;
    bn_select_words((uint64_t *)v17, v47, (uint64_t *)v36, (uint64_t *)v17, 2LL * a4);
    __int128 v39 = (v47 & v37 | v38 & ~v47) + bn_add_words(&a1[v49], &a1[v49], v17, 2 * a4);
    unsigned int v40 = 3 * a4;
    if (3 * a4 < (int)v33)
    {
      unsigned int v41 = &a1[v40];
      uint64_t v42 = v33 - v40;
      do
      {
        unint64_t v43 = *v41 + v39;
        __int128 v39 = __CFADD__(*v41, v39);
        *v41++ = v43;
        --v42;
      }

      while (v42);
    }

    if (v39) {
      bn_mul_part_recursive_cold_4();
    }
  }

  else
  {
    bn_mul_normal(a1, a2, (int)(a5 + a4), (unint64_t *)a3, (int)(a6 + a4));
    if (v15 != a6 + a5) {
      bzero(&a1[v15 + a5 + a6], (int)(v15 - (a6 + a5)));
    }
  }

      if (bottom == 1) {
        *(void *)d |= 1uLL;
      }
      v9->neg = 0;
      v9->top = v13;
      goto LABEL_33;
    }
  }

  return (int)rnd;
}

  return v5;
}
}

uint64_t bssl::add_record_to_flight(bssl *a1, ssl_st *a2, unint64_t a3, const unsigned __int8 *a4)
{
  uint64_t v4 = *((void *)a1 + 6);
  if (*(void *)(v4 + 232)) {
    bssl::add_record_to_flight();
  }
  if (*(_DWORD *)(v4 + 248)) {
    bssl::add_record_to_flight();
  }
  uint64_t v10 = *(void *)(v4 + 240);
  uint64_t v9 = (BUF_MEM **)(v4 + 240);
  if (!v10)
  {
    uint64_t v11 = BUF_MEM_new();
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v9, v11);
    if (!*(void *)(*((void *)a1 + 6) + 240LL)) {
      return 0LL;
    }
  }

  uint64_t v12 = SSL_max_seal_overhead((uint64_t)a1);
  int v13 = &a4[v12];
  BOOL v14 = __CFADD__(v12, a4);
  size_t v15 = *(void **)(*((void *)a1 + 6) + 240LL);
  unint64_t v16 = (unint64_t)&v13[*v15];
  BOOL v17 = __CFADD__(*v15, v13);
  if (v14 || v17)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 154);
    return 0LL;
  }

  *(void *)unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = BUF_MEM_reserve((uint64_t)v15, v16);
  if ((_DWORD)result)
  {
    uint64_t result = bssl::tls_seal_record( a1,  (ssl_st *)(*(void *)(*(void *)(*((void *)a1 + 6) + 240LL) + 8LL)
                        + **(void **)(*((void *)a1 + 6) + 240LL)),
               v19,
               v13,
               a2,
               a3,
               a4);
    if ((_DWORD)result)
    {
      **(void **)(*((void *)a1 + 6) + 240LL) += *(void *)v19;
      return 1LL;
    }
  }

  return result;
}

uint64_t SSL_max_seal_overhead(uint64_t a1)
{
  uint64_t v4 = bssl::SSLAEADContext::MaxOverhead(*(bssl::SSLAEADContext **)(*(void *)(a1 + 48) + 272LL));
  uint64_t v5 = v4 + 5;
  uint64_t v6 = *(bssl::SSLAEADContext **)(*(void *)(a1 + 48) + 272LL);
  if (*(void *)v6)
  {
  }

  return v5 << bssl::ssl_needs_record_splitting((bssl *)a1, v3);
}

uint64_t bssl::SSLAEADContext::MaxOverhead(bssl::SSLAEADContext *this)
{
  if ((*((_BYTE *)this + 609) & 1) != 0) {
    uint64_t v1 = *((unsigned __int8 *)this + 605);
  }
  else {
    uint64_t v1 = 0LL;
  }
  if (*(void *)this)
  {
    uint64_t v2 = EVP_AEAD_CTX_aead((uint64_t)this + 8);
    uint64_t v3 = EVP_AEAD_max_overhead(v2);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  return v3 + v1;
}

BOOL bssl::ssl_needs_record_splitting(bssl *this, const ssl_st *a2)
{
  uint64_t v3 = *(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL);
  return *(void *)v3
      && bssl::SSLAEADContext::ProtocolVersion(v3) <= 0x301
      && (*((_BYTE *)this + 149) & 1) != 0
      && SSL_CIPHER_is_block_cipher(**(void **)(*((void *)this + 6) + 272LL));
}

uint64_t BUF_MEM_reserve(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) >= a2) {
    return 1LL;
  }
  if (a2 < 0xFFFFFFFFFFFFFFFDLL)
  {
    if (a2 >= 0xBFFFFFFFFFFFFFFDLL)
    {
      int v2 = 91;
      goto LABEL_9;
    }

    unint64_t v4 = (2 * (((a2 + 3) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t result = (uint64_t)OPENSSL_realloc(*(void **)(a1 + 8), v4);
    if (!result) {
      return result;
    }
    *(void *)(a1 + _Block_object_dispose(va, 8) = result;
    *(void *)(a1 + 16) = v4;
    return 1LL;
  }

  int v2 = 85;
LABEL_9:
  ERR_put_error(7, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/buf/buf.c", v2);
  return 0LL;
}

uint64_t bssl::tls_seal_record( bssl *this, ssl_st *a2, unsigned __int8 *a3, const unsigned __int8 *a4, ssl_st *a5, unint64_t a6, const unsigned __int8 *a7)
{
  if (&a4[(void)a2] > (const unsigned __int8 *)a6 && &a7[a6] > (const unsigned __int8 *)a2)
  {
    int v19 = 189;
    int v20 = 516;
LABEL_22:
    ERR_put_error(16, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v20);
    return 0LL;
  }

  uint64_t v16 = bssl::tls_seal_scatter_prefix_len(this, a5, (unint64_t)a7);
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  BOOL v17 = *(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL);
  if (*(void *)v17) {
    BOOL v18 = bssl::SSLAEADContext::ProtocolVersion(v17) > 0x303;
  }
  else {
    BOOL v18 = 0LL;
  }
  BOOL v22 = (_DWORD)a5 == 23 && (unint64_t)a7 > 1;
  unint64_t v23 = a7;
  if (v22) {
    unint64_t v23 = &a7[-bssl::ssl_needs_record_splitting(this, v15)];
  }
  uint64_t result = bssl::SSLAEADContext::SuffixLen( *(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL),  &v31,  (uint64_t)v23,  v18);
  if (!(_DWORD)result) {
    return result;
  }
  size_t v26 = &a7[v16];
  if (__CFADD__(v16, a7) || __CFADD__(v31, v26))
  {
    int v19 = 200;
    int v20 = 527;
    goto LABEL_22;
  }

  if (&v26[v31] > a4)
  {
    int v19 = 121;
    int v20 = 531;
    goto LABEL_22;
  }

  __int128 v27 = (char *)a2 + v16;
  __int128 v28 = (char *)&a7[(void)a2 + v16];
  if (!v22 || !bssl::ssl_needs_record_splitting(this, v25))
  {
LABEL_37:
    *(void *)a3 = &v26[v31];
    return 1LL;
  }

  if (bssl::SSLAEADContext::ExplicitNonceLen(*(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL))) {
    bssl::tls_seal_record();
  }
  uint64_t result = bssl::do_seal_record( this,  a2,  (char *)&a2->type + 1,  (char *)&a2->type + 2,  (unsigned __int8 *)0x17,  (char *)a6,  (const unsigned __int8 *)1);
  if ((_DWORD)result)
  {
    unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
    if (!bssl::SSLAEADContext::SuffixLen(*(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL), &v34, 1LL, 0LL)) {
      bssl::tls_seal_record();
    }
    unint64_t v30 = v34;
    if (bssl::ssl_cipher_get_record_split_len(**(bssl ***)(*((void *)this + 6) + 272LL), v29) != v30 + 1) {
      bssl::tls_seal_record();
    }
    char v33 = -86;
    int v32 = -1431655766;
    uint64_t result = bssl::do_seal_record(this, (ssl_st *)&v32, v27 + 1, v28, (unsigned __int8 *)0x17, (char *)(a6 + 1), a7 - 1);
    if ((_DWORD)result)
    {
      *(int *)((char *)&a2->type + v30 + 2) = v32;
      char *v27 = v33;
      goto LABEL_37;
    }
  }

  return result;
}

uint64_t bssl::tls_seal_scatter_prefix_len(bssl *this, const ssl_st *a2, unint64_t a3)
{
  if ((_DWORD)a2 == 23 && a3 >= 2 && bssl::ssl_needs_record_splitting(this, a2)) {
    return bssl::ssl_cipher_get_record_split_len(**(bssl ***)(*((void *)this + 6) + 272LL), v4) + 9;
  }
  else {
    return bssl::SSLAEADContext::ExplicitNonceLen(*(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL)) + 5;
  }
}

uint64_t bssl::SSLAEADContext::ExplicitNonceLen(bssl::SSLAEADContext *this)
{
  if ((*((_BYTE *)this + 609) & 1) != 0) {
    return *((unsigned __int8 *)this + 605);
  }
  else {
    return 0LL;
  }
}

BOOL bssl::SSLAEADContext::SuffixLen( bssl::SSLAEADContext *this, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)this) {
    return EVP_AEAD_CTX_tag_len((uint64_t *)this + 1, (uint64_t *)a2, a3, a4) != 0;
  }
  *a2 = a4;
  return 1LL;
}

uint64_t bssl::do_seal_record( bssl *this, ssl_st *a2, char *a3, char *a4, unsigned __int8 *a5, char *a6, const unsigned __int8 *a7)
{
  char v9 = (char)a5;
  char v32 = (char)a5;
  BOOL v14 = *(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL);
  if (*(void *)v14)
  {
    unsigned int v15 = bssl::SSLAEADContext::ProtocolVersion(*(bssl::SSLAEADContext **)(*((void *)this + 6) + 272LL));
    if (v15 < 0x304)
    {
      uint64_t v16 = 0LL;
    }

    else
    {
      char v9 = 23;
      uint64_t v16 = 1LL;
    }

    if (v15 >= 0x304) {
      BOOL v17 = &v32;
    }
    else {
      BOOL v17 = 0LL;
    }
  }

  else
  {
    uint64_t v16 = 0LL;
    BOOL v17 = 0LL;
  }

  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  if (!bssl::SSLAEADContext::SuffixLen(v14, &v31, (uint64_t)a7, v16)
    || (bssl::SSLAEADContext::CiphertextLen(v14, &v30, (unint64_t)a7, v16) & 1) == 0)
  {
    int v25 = 200;
    int v26 = 384;
LABEL_25:
    ERR_put_error(16, 0, v25, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v26);
    return 0LL;
  }

  __int128 v28 = v17;
  size_t v29 = a4;
  BOOL v18 = &a7[(void)a6];
  else {
    uint64_t v19 = 5LL;
  }
  uint64_t v20 = bssl::SSLAEADContext::ExplicitNonceLen(*(bssl::SSLAEADContext **)(*((void *)this + 6) + 264LL));
  LOBYTE(a2->version) = v9;
  unsigned int v21 = bssl::SSLAEADContext::RecordVersion(v14);
  *(_WORD *)((char *)&a2->version + 1) = __rev16(v21);
  *(_WORD *)((char *)&a2->version + 3) = bswap32((unsigned __int16)v30) >> 16;
  unint64_t v23 = *(void *)(*((void *)this + 6) + 8LL);
  if (v23 == -1LL)
  {
    int v25 = 69;
    int v26 = 408;
    goto LABEL_25;
  }

  if (!bssl::SSLAEADContext::SealScatter( (uint64_t)v14,  (char *)&a2->type + 1,  a3,  v29,  a2->version,  v21,  v23,  v22,  (uint64_t)a2,  5LL,  a6,  (uint64_t)a7,  v28,  v16)) {
    return 0LL;
  }
  ++*(void *)(*((void *)this + 6) + 8LL);
  uint64_t v24 = 1LL;
  bssl::ssl_do_msg_callback((uint64_t)this, 1LL, 256LL, (uint64_t)a2, 5LL);
  return v24;
}

uint64_t bssl::SSLAEADContext::CiphertextLen( bssl::SSLAEADContext *this, unint64_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  if (*(void *)this)
  {
    uint64_t result = EVP_AEAD_CTX_tag_len((uint64_t *)this + 1, &v11, a3, a4);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else
  {
    uint64_t v11 = a4;
  }

  if ((*((_BYTE *)this + 609) & 1) != 0) {
    uint64_t v8 = *((unsigned __int8 *)this + 605);
  }
  else {
    uint64_t v8 = 0LL;
  }
  unint64_t v9 = v8 + a3 + v11;
  uint64_t v11 = v9;
  if (v9 < a3 || v9 >= 0xFFFF)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", 207);
    return 0LL;
  }

  else
  {
    *a2 = v9;
    return 1LL;
  }

uint64_t bssl::SSLAEADContext::RecordVersion(bssl::SSLAEADContext *this)
{
  if (*((_WORD *)this + 303))
  {
    else {
      return (unsigned __int16)*((_WORD *)this + 303);
    }
  }

  else
  {
    if (*(void *)this) {
      bssl::SSLAEADContext::RecordVersion();
    }
    if (*((_BYTE *)this + 608)) {
      return (unsigned __int16)-257;
    }
    else {
      return 769;
    }
  }

uint64_t bssl::SSLAEADContext::SealScatter( uint64_t a1, char *a2, char *a3, char *a4, char a5, __int16 a6, unint64_t a7, int a8, uint64_t a9, uint64_t a10, char *__src, uint64_t a12, void *a13, uint64_t a14)
{
  v45[2] = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 609) & 1) != 0) {
    uint64_t v20 = *(unsigned __int8 *)(a1 + 605);
  }
  else {
    uint64_t v20 = 0LL;
  }
  size_t v43 = 0xAAAAAAAAAAAAAAAALL;
  if (*(void *)a1)
  {
    unsigned int v21 = a4;
    int v22 = EVP_AEAD_CTX_tag_len((uint64_t *)(a1 + 8), (uint64_t *)&v43, a12, a14);
    a4 = v21;
    if (!v22)
    {
      int v23 = 200;
      int v24 = 322;
LABEL_16:
      ERR_put_error(16, 0, v23, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", v24);
      return 0LL;
    }
  }

  else
  {
    size_t v43 = a14;
  }

  int v25 = &__src[a12];
  if (__src != a3 && v25 > a3 && &a3[a12] > __src || v25 > a2 && &a2[v20] > __src || v25 > a4 && &a4[v43] > __src)
  {
    int v23 = 189;
    int v24 = 328;
    goto LABEL_16;
  }

  uint64_t v27 = (uint64_t)a13;
  if (!*(void *)a1)
  {
    if (a12)
    {
      size_t v29 = a4;
      memmove(a3, __src, a12);
      a4 = v29;
    }

    if (a14) {
      memmove(a4, a13, a14);
    }
    return 1LL;
  }

  *(void *)((char *)v45 + 5) = 0xAAAAAAAAAAAAAAAALL;
  v45[0] = 0xAAAAAAAAAAAAAAAALL;
  char v28 = *(_BYTE *)(a1 + 609);
  if ((v28 & 0x10) == 0)
  {
    v45[0] = bswap64(a7);
    LOBYTE(v45[1]) = a5;
    BYTE1(v45[1]) = HIBYTE(a6);
    BYTE2(v45[1]) = a6;
    if ((v28 & 8) == 0) {
      *(_WORD *)((char *)&v45[1] + 3) = bswap32(a12) >> 16;
    }
  }

  memset(__dst, 170, sizeof(__dst));
  size_t v30 = *(unsigned __int8 *)(a1 + 604);
  unsigned int v41 = a4;
  if ((v28 & 4) != 0)
  {
    v30 -= *(unsigned __int8 *)(a1 + 605);
    if (!v30) {
      goto LABEL_33;
    }
    uint64_t v40 = (uint64_t)a13;
    char v31 = v28;
    bzero(__dst, v30);
  }

  else
  {
    if (!*(_BYTE *)(a1 + 604))
    {
      size_t v30 = 0LL;
      if ((v28 & 2) == 0)
      {
LABEL_34:
        if (*(_BYTE *)(a1 + 605) != 8) {
          bssl::SSLAEADContext::SealScatter();
        }
        uint64_t v32 = v27;
        *(void *)((char *)__dst + v30) = bswap64(a7);
        unsigned int v33 = 8;
        if ((v28 & 1) == 0) {
          goto LABEL_47;
        }
        goto LABEL_41;
      }

      goto LABEL_38;
    }

    uint64_t v40 = (uint64_t)a13;
    char v31 = v28;
    memcpy(__dst, (const void *)(a1 + 592), v30);
  }

  char v28 = v31;
  uint64_t v27 = v40;
LABEL_33:
  if ((v28 & 2) == 0) {
    goto LABEL_34;
  }
LABEL_38:
  if ((v28 & 1) == 0) {
    bssl::SSLAEADContext::SealScatter();
  }
  uint64_t result = RAND_bytes((unsigned __int8 *)__dst + v30, *(unsigned __int8 *)(a1 + 605));
  if ((_DWORD)result)
  {
    uint64_t v32 = v27;
    unsigned int v33 = *(unsigned __int8 *)(a1 + 605);
    char v28 = *(_BYTE *)(a1 + 609);
    if ((v28 & 1) == 0)
    {
LABEL_47:
      uint64_t v34 = v30 + v33;
      if ((v28 & 4) != 0)
      {
        if (*(_BYTE *)(a1 + 604))
        {
          BOOL v35 = (char *)(a1 + 592);
          size_t v36 = __dst;
          size_t v37 = v30 + v33;
          do
          {
            char v38 = *v35++;
            *v36++ ^= v38;
            --v37;
          }

          while (v37);
        }
      }

      unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
      int v39 = EVP_AEAD_CTX_seal_scatter( (uint64_t *)(a1 + 8),  a3,  v41,  &v42,  v43,  (uint64_t)__dst,  v34,  __src,  a12,  v32,  a14);
      uint64_t result = v39 != 0;
      if (v39)
      {
        if (v42 != v43) {
          bssl::SSLAEADContext::SealScatter();
        }
      }

      return result;
    }

LABEL_41:
    if ((v28 & 4) != 0) {
      bssl::SSLAEADContext::SealScatter();
    }
    if (v25 > a2 && &a2[v33] > __src)
    {
      int v23 = 189;
      int v24 = 374;
      goto LABEL_16;
    }

    if (v33)
    {
      memcpy(a2, (char *)__dst + *(unsigned __int8 *)(a1 + 604), v33);
      char v28 = *(_BYTE *)(a1 + 609);
    }

    goto LABEL_47;
  }

  return result;
}

    int v23 = 0LL;
    goto LABEL_22;
  }

  unsigned int v15 = 138;
  uint64_t v16 = 233;
LABEL_21:
  ERR_put_error(4, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v16);
  int v23 = 0LL;
  int v24 = 0LL;
LABEL_22:
  OPENSSL_free(v24);
  EVP_MD_CTX_cleanup(&ctx);
  return v23;
}

uint64_t bssl::ssl_do_msg_callback(uint64_t ssl, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(ssl + 64);
  if (v5)
  {
    uint64_t v10 = ssl;
    if ((_DWORD)a3)
    {
      if ((_DWORD)a3 == 256)
      {
        uint64_t v11 = 0LL;
      }

      else
      {
        uint64_t v11 = SSL_version((const SSL *)ssl);
        uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(v10 + 64);
      }
    }

    else
    {
      uint64_t v11 = 2LL;
    }

    return v5(a2, v11, a3, a4, a5, v10, *(void *)(v10 + 72));
  }

  return ssl;
}

void boringssl_context_message_handler( int a1, int a2, uint64_t a3, char *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if ((_DWORD)a3 == 256 && a2 == 0 || a7 == 0) {
    return;
  }
  if (*(_DWORD *)a7 != -1252936367) {
    return;
  }
  uint64_t v10 = *(void *)(a7 + 8);
  boringssl_session_update_flight_time(a7, a1, a5);
  if (*(_DWORD *)a7 != -1252936367) {
    goto LABEL_35;
  }
  uint64_t v15 = *(void *)(a7 + 8);
  if (!v15) {
    goto LABEL_35;
  }
  if ((a3 - 20) < 4)
  {
    uint64_t v16 = off_18A07BCE0[(int)a3 - 20];
    BOOL v17 = (id *)(v15 + 16);
    id WeakRetained = objc_loadWeakRetained((id *)(v15 + 16));
    if (WeakRetained)
    {
      uint64_t v19 = WeakRetained;
      uint64_t v20 = objc_loadWeakRetained(v17);
      char v21 = v20[475];

      if ((v21 & 1) != 0) {
        goto LABEL_35;
      }
    }

    id v22 = objc_loadWeakRetained(v17);
    if (v22)
    {
      int v23 = objc_loadWeakRetained(v17);
      BOOL v24 = (v23[475] & 1) == 0;
    }

    else
    {
      BOOL v24 = 1;
    }

    if (!v24 || !g_boringssl_log) {
      goto LABEL_35;
    }
    unsigned int v33 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      id v34 = objc_loadWeakRetained(v17);
      if (v34)
      {
        uint64_t v48 = (char *)objc_loadWeakRetained(v17);
        BOOL v35 = v48 + 391;
      }

      else
      {
        BOOL v35 = &unk_1875F4C23;
      }

      id v45 = objc_loadWeakRetained(v17);
      char v46 = v45;
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "boringssl_context_log_message";
      int v47 = "Writing";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2304;
      *(_WORD *)&buf[18] = 2082;
      if (!a1) {
        int v47 = "Reading";
      }
      *(void *)&buf[20] = v35;
      *(_WORD *)&_BYTE buf[28] = 2048;
      *(void *)&buf[30] = v45;
      *(_WORD *)&buf[38] = 2082;
      uint64_t v57 = v47;
      *(_WORD *)__int128 v58 = 2082;
      *(void *)&v58[2] = v16;
      *(_WORD *)&v58[10] = 2048;
      *(void *)&v58[12] = a5;
      _os_log_debug_impl( &dword_187560000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] %{public}s %{public}s %zu bytes",  buf,  0x44u);

      if (v34) {
    }
      }

LABEL_34:
LABEL_35:
    if ((_DWORD)a3 == 22)
    {
      if (a4)
      {
        if (a5)
        {
          char v41 = *a4;
          *(_BYTE *)(v10 + 30_Block_object_dispose(va, 8) = *a4;
          if (*(void *)(v10 + 208))
          {
            if (*(void *)(v10 + 216))
            {
              dispatch_data_t v42 = dispatch_data_create(a4, a5, 0LL, 0LL);
              size_t v43 = *(dispatch_queue_s **)(v10 + 208);
              blocuint64_t k = MEMORY[0x1895F87A8];
              uint64_t v50 = 3221225472LL;
              uint64_t v51 = __boringssl_context_message_handler_block_invoke;
              uint64_t v52 = &unk_18A07BBC0;
              LOBYTE(v55) = v41;
              dispatch_data_t v53 = v42;
              uint64_t v54 = v10;
              unint64_t v44 = v42;
              dispatch_async(v43, &block);
            }
          }
        }
      }
    }

    return;
  }

  int v25 = (id *)(v15 + 16);
  id v26 = objc_loadWeakRetained((id *)(v15 + 16));
  if (!v26
    || (uint64_t v27 = v26, v28 = objc_loadWeakRetained(v25),
                   char v29 = v28[475],
                   v28,
                   v27,
                   (v29 & 1) == 0))
  {
    id v30 = objc_loadWeakRetained(v25);
    if (v30)
    {
      char v31 = objc_loadWeakRetained(v25);
      BOOL v32 = (v31[475] & 1) == 0;
    }

    else
    {
      BOOL v32 = 1;
    }

    if (v32)
    {
      if (g_boringssl_log)
      {
        unsigned int v33 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
          boringssl_context_message_handler_cold_1( (uint64_t)v25,  a3,  (uint64_t)v33,  v36,  v37,  v38,  v39,  v40,  (int)v48,  block,  v50,  (uint64_t)v51,  (uint64_t)v52,  (uint64_t)v53,  v54,  v55,  *(uint64_t *)buf,  *(uint64_t *)&buf[8],  *(uint64_t *)&buf[16],  *(uint64_t *)&buf[24],  *(uint64_t *)&buf[32],  (uint64_t)v57,  *(uint64_t *)v58,  *(uint64_t *)&v58[8]);
        }
        goto LABEL_34;
      }
    }
  }

    --v15;
  }

  while (v15 != -1LL);
  uint64_t v50 = v58;
  *a2 = v57;
  a2[1] = v50;
  uint64_t v51 = v60;
  *(_OWORD *)((char *)a2 + 72) = v59;
  *(_OWORD *)((char *)a2 + 8_Block_object_dispose(va, 8) = v51;
  uint64_t result = *(double *)&v61;
  dispatch_data_t v53 = v62;
  a2[9] = v61;
  a2[10] = v53;
  return result;
}

  uint64_t result = 1LL;
LABEL_35:
  if (a2) {
    *a2 = v9;
  }
  return result;
}

  uint64_t v12 = v11 != 0;
  if (v5) {
    OPENSSL_free(v5);
  }
  return v12;
}

int SSL_version(const SSL *ssl)
{
  return bssl::ssl_version((bssl *)ssl, v1);
}

uint64_t bssl::ssl_version(bssl *this, const ssl_st *a2)
{
  else {
    uint64_t v3 = (unsigned __int16 *)(*(void *)(*(void *)(*((void *)this + 6) + 280LL) + 1528LL) + 4LL);
  }
  return *v3;
}

uint64_t SSL_in_early_data(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 48) + 280LL);
  if (v1) {
    return (*(_DWORD *)(v1 + 1584) >> 10) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t boringssl_session_update_flight_time(uint64_t result, int a2, uint64_t a3)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t v3 = *(void *)(result + 8);
      if (v3)
      {
        if (*(_DWORD *)(v3 + 300) <= 1u)
        {
          uint64_t result = boringssl_session_in_early_data(result);
          if ((result & 1) == 0)
          {
            if ((*(_BYTE *)(v3 + 556) & 1) != 0 && ((*(unsigned __int8 *)(v3 + 558) >> 1) & 1) != a2)
            {
              if (*(void *)(v3 + 440))
              {
                uint64_t result = boringssl_helper_get_current_time_ms();
                *(void *)(v3 + 448) += result - *(void *)(v3 + 440);
                *(void *)(v3 + 440) = 0LL;
                if (!*(void *)(v3 + 464)) {
                  *(void *)(v3 + 464) = result;
                }
              }
            }

            else
            {
              uint64_t result = boringssl_helper_get_current_time_ms();
              *(void *)(v3 + 440) = result;
              if (!*(void *)(v3 + 456)) {
                *(void *)(v3 + 456) = *(void *)(v3 + 440);
              }
              *(_BYTE *)(v3 + 55_Block_object_dispose(va, 8) = *(_BYTE *)(v3 + 558) & 0xFD | (2 * (a2 & 1));
              *(_BYTE *)(v3 + 556) |= 1u;
            }

            uint64_t v6 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_inbound_byte_count;
            if (a2 == 1) {
              uint64_t v6 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_outbound_byte_count;
            }
            *(void *)(v3 + *v6) += a3;
          }
        }
      }
    }
  }

  return result;
}

uint64_t boringssl_session_in_early_data(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      uint64_t result = *(void *)(v1 + 400);
      if (result) {
        return SSL_in_early_data(result) != 0;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t bssl::SSLTranscript::Update(void **a1, const void *a2, size_t a3)
{
  uint64_t v6 = *a1;
  if (!v6 || (uint64_t result = BUF_MEM_append(v6, a2, a3), (_DWORD)result))
  {
    uint64_t v8 = (EVP_MD_CTX *)(a1 + 1);
    if (EVP_MD_CTX_md(v8)) {
      EVP_DigestUpdate(v8, a2, a3);
    }
    return 1LL;
  }

  return result;
}

uint64_t BUF_MEM_append(void *a1, const void *a2, size_t a3)
{
  if (!a3) {
    return 1LL;
  }
  size_t v5 = *a1 + a3;
  if (__CFADD__(*a1, a3))
  {
    ERR_put_error(7, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/buf/buf.c", 127);
    return 0LL;
  }

  else
  {
    uint64_t result = BUF_MEM_reserve((uint64_t)a1, *a1 + a3);
    if ((_DWORD)result)
    {
      memcpy((void *)(a1[1] + *a1), a2, a3);
      *a1 = v5;
      return 1LL;
    }
  }

  return result;
}

const EVP_MD *__cdecl EVP_MD_CTX_md(const EVP_MD *ctx)
{
  if (ctx) {
    return *(const EVP_MD **)&ctx->type;
  }
  return ctx;
}

int SSL_state(const SSL *ssl)
{
  uint64_t v1 = *((void *)ssl->handshake_func + 35);
  if (!v1 || (*(_DWORD *)(v1 + 1584) & 8) != 0) {
    return 3;
  }
  else {
    return 12288;
  }
}

const char *__cdecl SSL_state_string_long(const SSL *s)
{
  uint64_t v3 = (bssl *)*((void *)s->handshake_func + 35);
  if (!v3) {
    return "SSL negotiation finished successfully";
  }
  if ((BYTE4(s->param) & 1) != 0) {
    return bssl::ssl_server_handshake_state(v3, v1);
  }
  return bssl::ssl_client_handshake_state(v3, v1);
}

const char *bssl::ssl_client_handshake_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  int v2 = *((_DWORD *)this + 5);
  uint64_t result = "TLS client start_connect";
  switch(v2)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = "TLS client enter_early_data";
      break;
    case 2:
      uint64_t result = "TLS client early_reverify_server_certificate";
      break;
    case 3:
      uint64_t result = "TLS client read_hello_verify_request";
      break;
    case 4:
      uint64_t result = "TLS client read_server_hello";
      break;
    case 5:
      uint64_t result = bssl::tls13_client_handshake_state((uint64_t)this);
      break;
    case 6:
      uint64_t result = "TLS client read_server_certificate";
      break;
    case 7:
      uint64_t result = "TLS client read_certificate_status";
      break;
    case 8:
      uint64_t result = "TLS client verify_server_certificate";
      break;
    case 9:
      uint64_t result = "TLS client reverify_server_certificate";
      break;
    case 10:
      uint64_t result = "TLS client read_server_key_exchange";
      break;
    case 11:
      uint64_t result = "TLS client read_certificate_request";
      break;
    case 12:
      uint64_t result = "TLS client read_server_hello_done";
      break;
    case 13:
      uint64_t result = "TLS client send_client_certificate";
      break;
    case 14:
      uint64_t result = "TLS client send_client_key_exchange";
      break;
    case 15:
      uint64_t result = "TLS client send_client_certificate_verify";
      break;
    case 16:
      uint64_t result = "TLS client send_client_finished";
      break;
    case 17:
      uint64_t result = "TLS client finish_flight";
      break;
    case 18:
      uint64_t result = "TLS client read_session_ticket";
      break;
    case 19:
      uint64_t result = "TLS client process_change_cipher_spec";
      break;
    case 20:
      uint64_t result = "TLS client read_server_finished";
      break;
    case 21:
      uint64_t result = "TLS client finish_client_handshake";
      break;
    case 22:
      uint64_t result = "TLS client done";
      break;
    default:
      uint64_t result = "TLS client unknown";
      break;
  }

  return result;
}

uint64_t bssl::tls_flush_flight(BIO **this, ssl_st *a2)
{
  unint64_t v4 = this[21];
  if (v4)
  {
    if (LODWORD(this[6][1].prev_bio))
    {
      int v5 = 194;
      int v6 = 291;
LABEL_12:
      ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v6);
      return 0xFFFFFFFFLL;
    }

    if (!(*(unsigned int (**)(BIO **))&v4->init)(this))
    {
      int v5 = 298;
      int v6 = 296;
      goto LABEL_12;
    }
  }

  int v7 = this[6];
  cb_arg = v7[2].cb_arg;
  if (!cb_arg) {
    return 1LL;
  }
  if (LODWORD(v7[1].prev_bio))
  {
    int v5 = 194;
    int v6 = 306;
    goto LABEL_12;
  }

  if (*(void *)cb_arg >> 31)
  {
    int v5 = 68;
    int v6 = 312;
    goto LABEL_12;
  }

  if (WORD2(v7[1].method))
  {
    uint64_t result = bssl::ssl_write_buffer_flush((bssl *)this, v3);
    if ((int)result <= 0)
    {
      HIDWORD(this[6][1].num_read) = 3;
      return result;
    }
  }

  uint64_t v10 = this[4];
  if (!v10)
  {
    int v5 = 119;
    int v6 = 327;
    goto LABEL_12;
  }

  uint64_t v11 = this[6];
  unint64_t init = v11[2].init;
  int v13 = v11[2].cb_arg;
  uint64_t v14 = *(void *)v13;
  if (*(void *)v13 <= init)
  {
LABEL_21:
    int v16 = BIO_flush(v10);
    BOOL v17 = this[6];
    if (v16 <= 0)
    {
      HIDWORD(v17[1].num_read) = 3;
      return 0xFFFFFFFFLL;
    }

    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)&v17[2].cb_arg, 0LL);
    this[6][2].unint64_t init = 0;
    return 1LL;
  }

  while (1)
  {
    uint64_t result = BIO_write(this[4], (const void *)(*((void *)v13 + 1) + init), v14 - init);
    uint64_t v15 = this[6];
    unint64_t init = (v15[2].init + result);
    v15[2].unint64_t init = init;
    int v13 = v15[2].cb_arg;
    uint64_t v14 = *(void *)v13;
    if (*(void *)v13 <= init)
    {
      uint64_t v10 = this[4];
      goto LABEL_21;
    }
  }

  HIDWORD(v15[1].num_read) = 3;
  return result;
}

uint64_t bssl::tls_flush_pending_hs_data(bssl *this, ssl_st *a2)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = *(void *)(v2 + 232);
  if (!v3) {
    return 1LL;
  }
  unint64_t v4 = *(const unsigned __int8 **)v3;
  if (!*(void *)v3) {
    return 1LL;
  }
  *(void *)(v2 + 2RAND_bytes(buf, 32) = 0LL;
  uint64_t v5 = *((void *)this + 21);
  if (v5)
  {
    uint64_t v6 = *(void *)(*((void *)this + 6) + 280LL);
    if (v6 && (*(_BYTE *)(v6 + 1586) & 8) != 0 || (*(unsigned int (**)(void))(v5 + 16))())
    {
      uint64_t v7 = 1LL;
    }

    else
    {
      ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 257);
      uint64_t v7 = 0LL;
    }
  }

  else
  {
    uint64_t v7 = bssl::add_record_to_flight(this, (ssl_st *)0x16, *(void *)(v3 + 8), v4);
  }

  BUF_MEM_free((BUF_MEM *)v3);
  return v7;
}

void sub_187576B00(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

int BIO_write(BIO *b, const void *data, int len)
{
  if (!b || !b->method || (bwrite = b->method->bwrite) == 0LL)
  {
    int v6 = 115;
    int v7 = 167;
LABEL_9:
    ERR_put_error(17, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", v7);
    return -2;
  }

  if (!LODWORD(b->cb_arg))
  {
    int v6 = 114;
    int v7 = 171;
    goto LABEL_9;
  }

  if (len < 1) {
    return 0;
  }
  int result = ((uint64_t (*)(BIO *, const void *))bwrite)(b, data);
  if (result >= 1) {
    b->prev_bio = (bio_st *)((char *)b->prev_bio + result);
  }
  return result;
}

uint64_t boringssl_bio_write(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    uint64_t result = (*(uint64_t (**)(void))(v3 + 16))(*(void *)v3);
    BIO_set_retry_write(a1);
  }

  return 0xFFFFFFFFLL;
}

uint64_t nw_protocol_boringssl_write_bytes(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = v5;
  uint64_t v7 = 0xFFFFFFFFLL;
  if (!v5
    || !a2
    || !(_DWORD)a3
    || boringssl_session_get_state(v5[42]) > 3
    || (boringssl_session_is_cancelled(v6[42]) & 1) != 0)
  {
    goto LABEL_17;
  }

  if ((*((_BYTE *)v6 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_write_bytes_cold_14();
  }

  uint64_t v8 = v6[5];
  if (!v8 || (uint64_t v9 = *(void *)(v8 + 24)) == 0 || !*(void *)(v9 + 88))
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_1();
    }

    goto LABEL_16;
  }

  if ((*((_BYTE *)v6 + 390) & 2) != 0)
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_bytes_cold_13();
    }
  }

  else if ((*((_BYTE *)v6 + 475) & 1) == 0 {
         && g_boringssl_log
  }
         && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_write_bytes_cold_12();
  }

  nw_frame_array_init();
  memset(v19, 170, sizeof(v19));
  nw_frame_array_init();
  else {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  int v12 = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, void *))(*(void *)(v8 + 24) + 88LL))( v8,  v6 + 1,  1LL,  a3,  v11,  &v19[2]);
  if (nw_frame_array_is_empty())
  {
    if ((*((_BYTE *)v6 + 390) & 2) != 0)
    {
      if ((*((_BYTE *)v6 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_write_bytes_cold_3();
      }
    }

    else if ((*((_BYTE *)v6 + 475) & 1) == 0 {
           && g_boringssl_log
    }
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_bytes_cold_2();
    }

LABEL_16:
    uint64_t v7 = 0LL;
    goto LABEL_17;
  }

  if (!v12)
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_4();
    }

    goto LABEL_16;
  }

  uint64_t v13 = nw_frame_array_first();
  if (v13)
  {
    uint64_t v14 = (void *)v13;
    int v15 = a3;
    while (1)
    {
      nw_frame_array_next();
      int v16 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v17[0]) = 0;
      nw_frame_unclaimed_bytes();
      nw_frame_array_remove();

      if (!v16) {
        break;
      }
      uint64_t v14 = v16;
    }
  }

  else
  {
    int v16 = 0LL;
    int v15 = a3;
  }

  if ((nw_frame_array_is_empty() & 1) != 0)
  {
    if ((*((_BYTE *)v6 + 390) & 2) != 0)
    {
      if ((*((_BYTE *)v6 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_write_bytes_cold_7();
      }
    }

    else if ((*((_BYTE *)v6 + 475) & 1) == 0 {
           && g_boringssl_log
    }
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_bytes_cold_6();
    }
  }

  else
  {
    if (*(void *)(*(void *)(v8 + 24) + 96LL))
    {
      (*(void (**)(void))(*(void *)(v6[5] + 24LL) + 96LL))();
      uint64_t v7 = (a3 - v15);
      if ((*((_BYTE *)v6 + 390) & 2) != 0)
      {
        if ((*((_BYTE *)v6 + 475) & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_write_bytes_cold_10();
        }
      }

      else if ((*((_BYTE *)v6 + 475) & 1) == 0 {
             && g_boringssl_log
      }
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_write_bytes_cold_9();
      }

      goto LABEL_62;
    }

    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_8();
    }
  }

  uint64_t v7 = 0LL;
LABEL_62:
  if ((nw_frame_array_is_empty() & 1) == 0)
  {
    v17[0] = 0LL;
    v17[1] = v17;
    v17[2] = 0x2020000000LL;
    int v18 = 0;
    nw_frame_array_foreach();
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_write_bytes_cold_5();
    }

    _Block_object_dispose(v17, 8);
  }

LABEL_17:
  return v7;
}

  int v18 = v3;
LABEL_17:
  bssl::ssl_send_alert(v18, (ssl_st *)2, v9);
  return 0LL;
}

  return v4;
}

  return v3;
}

  (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
}

  CBB_cleanup((uint64_t)v17);
  return v14;
}

  uint64_t result = *(void *)(v3 + 48);
  if (result)
  {
    int v15 = *(void *)(result + 24);
    if (v15)
    {
      int v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 56);
      if (v16) {
        return v16(result, a2, __errnum, v7, v8, v9, v10);
      }
    }
  }

  return result;
}

  uint64_t v13 = v4 >> 3;
  uint64_t v14 = (void *)*((void *)this + 2);
  if (v4 < 8)
  {
LABEL_23:
    int v18 = v4 & 7;
    if (!v18 || *((unsigned __int8 *)v14 + v13) == ~(-1 << v18))
    {
      OPENSSL_free(v14);
      *((void *)this + 2) = 0LL;
    }
  }

  else
  {
    if (v13 <= 1) {
      int v15 = 1LL;
    }
    else {
      int v15 = v4 >> 3;
    }
    int v16 = (unsigned __int8 *)*((void *)this + 2);
    while (1)
    {
      BOOL v17 = *v16++;
      if (v17 != 255) {
        break;
      }
      if (!--v15) {
        goto LABEL_23;
      }
    }
  }

  block_size_t size = v11->block_size;
  BOOL v17 = block_size > 0x10;
  int v18 = (1 << block_size) & 0x10102;
  if (v17 || v18 == 0) {
    EVP_CipherInit_ex_cold_1();
  }
  flags_high = HIDWORD(v11->flags);
  if ((flags_high & 0x100) == 0)
  {
    switch(flags_high & 0x3F)
    {
      case 0:
      case 1:
        break;
      case 2:
        goto LABEL_30;
      case 3:
        ctx->key_len = 0;
LABEL_30:
        if (iv)
        {
          int v25 = EVP_CIPHER_CTX_iv_length(ctx);
          if (v25) {
            memcpy(&ctx->oiv[12], iv, v25);
          }
        }

        id v26 = EVP_CIPHER_CTX_iv_length(ctx);
        if (!v26) {
          break;
        }
        id v22 = v26;
        BOOL v24 = &ctx->oiv[12];
        int v23 = &ctx->iv[12];
LABEL_36:
        memcpy(v23, v24, v22);
        break;
      case 4:
      case 5:
        ctx->key_len = 0;
        if (!iv) {
          break;
        }
        char v21 = EVP_CIPHER_CTX_iv_length(ctx);
        if (!v21) {
          break;
        }
        id v22 = v21;
        int v23 = &ctx->iv[12];
        BOOL v24 = iv;
        goto LABEL_36;
      default:
        goto LABEL_28;
    }
  }

  uint64_t v27 = ctx->cipher;
  if (!key && (v27->flags & 0x8000000000LL) == 0
    || (LODWORD(v13) = ((uint64_t (*)(EVP_CIPHER_CTX *, const unsigned __int8 *, const unsigned __int8 *, uint64_t))v27->init)( ctx,  key,  iv,  v10),  (_DWORD)v13))
  {
    HIDWORD(ctx->app_data) = 0;
    *(&ctx->key_len + 1) = 0;
    LODWORD(v13) = 1;
    *(_DWORD *)&ctx->final[8] = 0;
  }

  return (int)v13;
}

        if (v7 > 5) {
          break;
        }
        ++v7;
        ++v8;
        ++v6;
      }

      while (v7 + v3 < 0x100);
    }

    ++v3;
    ++v5;
  }

  while (v3 != 256);
  return result;
}

  if (ccchacha20())
  {
    if (!g_boringssl_log) {
      return 0LL;
    }
    uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_chacha20_poly1305_seal_scatter_cold_2();
      return 0LL;
    }
  }

  else
  {
    if (!calc_tag((uint64_t)__src, v21, a6, a12, a13, v19, a9, a3, a11))
    {
      id v26 = *(unsigned __int8 *)(v20 + 40);
      BIO *v17 = v26 + a11;
      memcpy((void *)(a3 + a11), __src, v26);
      return 1LL;
    }

    if (!g_boringssl_log) {
      return 0LL;
    }
    uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_chacha20_poly1305_seal_scatter_cold_1();
      return 0LL;
    }
  }

  return result;
}

  v7(v10);
  *a1 = 0LL;
  *__error() = 12;
  return 0xFFFFFFFFLL;
}

void sub_187577240( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t boringssl_session_is_cancelled(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return (*(unsigned __int8 *)(v1 + 556) >> 1) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_is_dtls(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (uint64_t v1 = *(void *)(a1 + 8)) != 0) {
    return (*(unsigned __int8 *)(v1 + 556) >> 5) & 1;
  }
  else {
    return 1LL;
  }
}

uint64_t BIO_flush(BIO *a1)
{
  return BIO_ctrl(a1, 11, 0LL, 0LL);
}

uint64_t BIO_ctrl(uint64_t bp, int cmd, uint64_t larg, void *parg)
{
  if (bp)
  {
    if (*(void *)bp && (unint64_t v4 = *(uint64_t (**)(void))(*(void *)bp + 48LL)) != 0LL)
    {
      return v4();
    }

    else
    {
      ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", 217);
      return -2LL;
    }
  }

  return bp;
}

uint64_t boringssl_bio_ctrl(uint64_t a1, int a2, int a3)
{
  uint64_t result = 1LL;
  if (a2 > 103)
  {
  }

  else
  {
    switch(a2)
    {
      case 8:
        return *(int *)(a1 + 20);
      case 9:
        *(_DWORD *)(a1 + 20) = a3;
        return 1LL;
      case 11:
        break;
      default:
        return 0LL;
    }
  }

  return result;
}

void BUF_MEM_free(BUF_MEM *a)
{
  if (a)
  {
    OPENSSL_free((void *)a->data);
    OPENSSL_free(a);
  }

uint64_t bssl::tls_get_message(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = bssl::parse_message(a1, a2, &v8);
  if ((_DWORD)v4)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    __int16 v6 = *(_WORD *)(v5 + 220);
    if ((v6 & 0x10) == 0)
    {
      if (!*(_BYTE *)a2)
      {
        bssl::ssl_do_msg_callback(a1, 0LL, 22LL, *(void *)(a2 + 24), *(void *)(a2 + 32));
        uint64_t v5 = *(void *)(a1 + 48);
        __int16 v6 = *(_WORD *)(v5 + 220);
      }

      *(_WORD *)(v5 + 220) = v6 | 0x10;
    }
  }

  return v4;
}

uint64_t bssl::parse_message(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 48) + 224LL);
  if (v4
    && (unsigned int v13 = -1431655766,
        uint64_t v8 = v4,
        uint64_t v7 = *v4,
        v14[0] = v8[1],
        v14[1] = v7,
        CBS_get_u8(v14, (_BYTE *)(a2 + 1)))
    && CBS_get_u24(v14, (int *)&v13))
  {
    uint64_t result = CBS_get_bytes(v14, (void *)(a2 + 8), v13);
    if ((_DWORD)result)
    {
      uint64_t v10 = *(void *)(a1 + 48);
      uint64_t v11 = v13 + 4;
      *(void *)(a2 + 24) = *(void *)(*(void *)(v10 + 224) + 8LL);
      *(void *)(a2 + RAND_bytes(buf, 32) = v11;
      *(_BYTE *)a2 = (*(_BYTE *)(v10 + 220) & 8) != 0;
      return 1LL;
    }

    uint64_t v12 = v13 + 4;
  }

  else
  {
    uint64_t result = 0LL;
    uint64_t v12 = 4LL;
  }

  *a3 = v12;
  return result;
}

uint64_t bssl::ssl_open_handshake(void *a1, void *a2, _BYTE *a3)
{
  *a2 = 0LL;
  uint64_t v4 = a1[6];
  if (*(_DWORD *)(v4 + 172) == 2)
  {
    ERR_restore_state(*(void **)(v4 + 184));
    *a3 = 0;
  }

  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 48LL))(a1);
    if ((_DWORD)result != 4) {
      return result;
    }
    uint64_t v7 = a1[6];
    *(_DWORD *)(v7 + 172) = 2;
    uint64_t v8 = (uint64_t *)(v7 + 184);
    uint64_t v9 = ERR_save_state();
    std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, (uint64_t)v9);
  }

  return 4LL;
}

uint64_t bssl::tls_open_handshake( uint64_t a1, unsigned __int8 **a2, ssl_st *a3, char *__s2, unint64_t a5)
{
  *a2 = 0LL;
  if ((*(_BYTE *)(a1 + 180) & 1) == 0 || (uint64_t v10 = *(void *)(a1 + 48), v11 = *(_WORD *)(v10 + 220), (v11 & 4) != 0))
  {
LABEL_19:
    char v20 = -86;
    int v18 = 0LL;
    size_t v19 = 0LL;
    uint64_t result = bssl::tls_open_record((bssl *)a1, &v20, (uint64_t)&v18, a2, a3, (unsigned __int16 *)__s2, a5);
    if ((_DWORD)result) {
      return result;
    }
    if ((*(_BYTE *)(a1 + 180) & 1) != 0 || v20 != 23)
    {
      if (v20 == 22)
      {
        char v17 = 80;
        goto LABEL_29;
      }
    }

    else if (!**(void **)(*(void *)(a1 + 48) + 264LL))
    {
      int v15 = 281;
      int v16 = 619;
LABEL_28:
      ERR_put_error(16, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v16);
      char v17 = 10;
LABEL_29:
      LOBYTE(a3->version) = v17;
      return 4LL;
    }

    int v15 = 225;
    int v16 = 625;
    goto LABEL_28;
  }

  if (a5 <= 4)
  {
    *a2 = (unsigned __int8 *)5;
    return 2LL;
  }

  if (!strncmp("GET ", __s2, 4uLL)
    || !strncmp("POST ", __s2, 5uLL)
    || !strncmp("HEAD ", __s2, 5uLL)
    || !strncmp("PUT ", __s2, 4uLL))
  {
    int v13 = 156;
    int v14 = 581;
LABEL_17:
    ERR_put_error(16, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v14);
    LOBYTE(a3->version) = 0;
    return 4LL;
  }

  if (!strncmp("CONNE", __s2, 5uLL))
  {
    int v13 = 155;
    int v14 = 586;
    goto LABEL_17;
  }

  if ((*__s2 & 0x80000000) == 0 || __s2[2] != 1 || __s2[3] != 3)
  {
    *(_WORD *)(v10 + 220) = v11 | 4;
    goto LABEL_19;
  }

  uint64_t result = bssl::read_v2_client_hello(a1, (unint64_t *)a2, __s2, a5);
  if ((_DWORD)result)
  {
    if ((_DWORD)result == 4) {
      LOBYTE(a3->version) = 0;
    }
  }

  else
  {
    *(_WORD *)(*(void *)(a1 + 48) + 220LL) |= 4u;
  }

  return result;
}

uint64_t bssl::tls_open_record( bssl *a1, char *a2, uint64_t a3, unsigned __int8 **a4, ssl_st *a5, unsigned __int16 *a6, unint64_t a7)
{
  *a4 = 0LL;
  if (*(_DWORD *)(*((void *)a1 + 6) + 172LL) == 1) {
    return 3LL;
  }
  int v47 = a6;
  unint64_t v48 = a7;
  char v46 = -86;
  unsigned __int16 v45 = -21846;
  unsigned __int16 v44 = -21846;
  if (!CBS_get_u8(&v47, &v46)
    || !CBS_get_u16(&v47, &v45)
    || !CBS_get_u16(&v47, &v44))
  {
    uint64_t v20 = 5LL;
    goto LABEL_13;
  }

  int v15 = *(bssl::SSLAEADContext **)(*((void *)a1 + 6) + 264LL);
  int v16 = v45;
  if (*(void *)v15)
  {
LABEL_15:
    ERR_put_error(16, 0, 247, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 231);
    char v19 = 70;
    goto LABEL_16;
  }

  if ((v45 & 0xFF00) != 0x300) {
    goto LABEL_15;
  }
LABEL_9:
  if (v44 < 0x4141uLL)
  {
    dispatch_data_t v42 = (char *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_bytes((uint64_t *)&v47, &v42, v44))
    {
      if (a7 >= 5) {
        uint64_t v21 = 5LL;
      }
      else {
        uint64_t v21 = a7;
      }
      bssl::ssl_do_msg_callback((uint64_t)a1, 0LL, 256LL, (uint64_t)a6, v21);
      *a4 = (unsigned __int8 *)(a7 - v48);
      if ((*(_WORD *)(*((void *)a1 + 6) + 220LL) & 2) != 0
        && bssl::ssl_protocol_version(a1, v22) >= 0x304
        && SSL_in_init((uint64_t)a1)
        && v46 == 20
        && v44 == 1
        && *v42 == 1)
      {
        uint64_t v24 = *((void *)a1 + 6);
        unsigned int v25 = ++*(_BYTE *)(v24 + 210);
        if (v25 < 0x21) {
          return 1LL;
        }
        int v26 = 219;
        int v27 = 263;
        goto LABEL_67;
      }

      uint64_t v28 = *((void *)a1 + 6);
      if ((*(_WORD *)(v28 + 220) & 1) == 0 || **(void **)(v28 + 264) || v46 != 23)
      {
        if (*(void *)v28 == -1LL)
        {
          ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 280);
          char v19 = 80;
          goto LABEL_16;
        }

        BOOL v29 = bssl::SSLAEADContext::Open( *(bssl::SSLAEADContext **)(v28 + 264),  (char **)a3,  v46,  v45,  *(void *)v28,  (int)a6,  v21,  v23,  v42,  v43);
        uint64_t v31 = *((void *)a1 + 6);
        __int16 v32 = *(_WORD *)(v31 + 220);
        if (v29)
        {
          *(_WORD *)(v31 + 220) = v32 & 0xFFFE;
          unsigned int v33 = (void *)*((void *)a1 + 6);
          ++*v33;
          id v34 = (bssl::SSLAEADContext *)v33[33];
          if (*(void *)v34)
          {
            unsigned int v35 = bssl::SSLAEADContext::ProtocolVersion(v34);
            unint64_t v36 = 0x4000LL;
            if (v35 > 0x303) {
              unint64_t v36 = 16385LL;
            }
            unint64_t v37 = *(void *)(a3 + 8);
            if (v37 <= v36)
            {
              if (v35 >= 0x304)
              {
                if (v46 == 23)
                {
                  while (v37)
                  {
                    int v38 = *(unsigned __int8 *)(*(void *)a3 + v37 - 1);
                    char v46 = *(_BYTE *)(*(void *)a3 + v37 - 1);
                    if (v37 >= v37 - 1) {
                      --v37;
                    }
                    *(void *)(a3 + _Block_object_dispose(va, 8) = v37;
                    if (v38) {
                      goto LABEL_57;
                    }
                  }

                  ERR_put_error(16, 0, 139, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 327);
                  char v19 = 51;
                }

                else
                {
                  ERR_put_error(16, 0, 251, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 320);
                  char v19 = 50;
                }

                goto LABEL_16;
              }

LABEL_57:
              uint64_t v39 = *((void *)a1 + 6);
              if (v37)
              {
                *(_BYTE *)(v39 + 210) = 0;
              }

              else
              {
                unsigned int v40 = ++*(_BYTE *)(v39 + 210);
                if (v40 >= 0x21)
                {
                  int v26 = 219;
                  int v27 = 340;
LABEL_67:
                  ERR_put_error(16, 0, v26, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v27);
                  char v19 = 10;
                  goto LABEL_16;
                }
              }

              char v41 = v46;
              if (v46 != 22)
              {
                if (v46 == 21) {
                  return bssl::ssl_process_alert(a1, a5, *(unsigned __int8 **)a3, v37);
                }
                if (bssl::tls_has_unprocessed_handshake_data(a1, v30))
                {
                  int v26 = 225;
                  int v27 = 357;
                  goto LABEL_67;
                }

                uint64_t v39 = *((void *)a1 + 6);
                char v41 = v46;
              }

              uint64_t result = 0LL;
              *(_BYTE *)(v39 + 211) = 0;
              *a2 = v41;
              return result;
            }
          }

          else
          {
            unint64_t v37 = *(void *)(a3 + 8);
            if (v37 <= 0x4000) {
              goto LABEL_57;
            }
          }

          int v17 = 136;
          int v18 = 312;
          goto LABEL_11;
        }

        if ((v32 & 1) == 0 || !**(void **)(v31 + 264))
        {
          ERR_put_error(16, 0, 139, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 294);
          char v19 = 20;
          goto LABEL_16;
        }

        ERR_clear_error();
      }

      return bssl::skip_early_data(a1, a5, *a4);
    }

    uint64_t v20 = v44 + 5LL;
LABEL_13:
    *a4 = (unsigned __int8 *)v20;
    return 2LL;
  }

  int v17 = 146;
  int v18 = 238;
LABEL_11:
  ERR_put_error(16, 0, v17, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v18);
  char v19 = 22;
LABEL_16:
  LOBYTE(a5->version) = v19;
  return 4LL;
}

        goto LABEL_58;
      }
    }

    if (!v30) {
      goto LABEL_58;
    }
    goto LABEL_57;
  }

    ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", v29);
    int v26 = 10;
    goto LABEL_65;
  }

  unsigned int v33 = v35;
  id v34 = v36;
  if (!v36) {
    return 0LL;
  }
  while (1)
  {
    memset(v32, 170, 20);
    __int128 __src = (void *)0xAAAAAAAAAAAAAAAALL;
    __n = 0xAAAAAAAAAAAAAAAALL;
    if ((bssl::dtls1_parse_fragment((uint64_t *)&v33, (uint64_t)v32, &__src) & 1) == 0)
    {
      ERR_put_error(16, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 352);
      int v26 = 50;
      goto LABEL_65;
    }

    uint64_t v9 = HIDWORD(v32[1]);
    uint64_t v10 = HIDWORD(v32[0]);
    if (HIDWORD(v32[1]) > HIDWORD(v32[0])
      || (__int16 v11 = LODWORD(v32[2]) + (unint64_t)HIDWORD(v32[1]), v11 > HIDWORD(v32[0]))
      || bssl::ssl_max_handshake_message_len((bssl *)a1, v8) < v10)
    {
      int v27 = 150;
      uint64_t v28 = 363;
      goto LABEL_64;
    }

    uint64_t v12 = *(void *)(a1 + 56);
    int v13 = *(unsigned __int16 *)(v12 + 50);
    if (*(_WORD *)(v12 + 2) == 1)
    {
      int v14 = LOWORD(v32[1]) == v13;
      int v13 = LOWORD(v32[1]);
      if (!v14)
      {
        BOOL v29 = 370;
        goto LABEL_57;
      }
    }

    if (LOWORD(v32[1]) >= v13 && v13 + 7 >= LOWORD(v32[1])) {
      break;
    }
LABEL_51:
    if (!v34) {
      return 0LL;
    }
  }

  int v16 = (LOWORD(v32[1]) - 7 * ((613566757 * (unint64_t)LOWORD(v32[1])) >> 32));
  int v17 = *(unsigned __int8 **)(v12 + 8LL * v16 + 72);
  if (!v17)
  {
    *(void *)&char v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v40[1] = v19;
    v40[2] = v19;
    v40[0] = v19;
    CBB_zero(v40);
    uint64_t v20 = (bssl::hm_fragment *)OPENSSL_malloc(0x18uLL);
    if (v20)
    {
      *((void *)v20 + 1) = 0LL;
      *((void *)v20 + 2) = 0LL;
      uint64_t v39 = v20;
      *(_BYTE *)uint64_t v20 = v32[0];
      *((_WORD *)v20 + 1) = v32[1];
      uint64_t v21 = HIDWORD(v32[0]);
      *((_DWORD *)v20 + 1) = HIDWORD(v32[0]);
      id v22 = OPENSSL_malloc((v21 + 12));
      *((void *)v39 + 1) = v22;
      if (!v22
        || !CBB_init_fixed((uint64_t)v40, (uint64_t)v22, 12LL)
        || !CBB_add_u8((uint64_t)v40, LOBYTE(v32[0]))
        || !CBB_add_u24((uint64_t)v40, HIDWORD(v32[0]))
        || !CBB_add_u16((uint64_t)v40, LOWORD(v32[1]))
        || !CBB_add_u24((uint64_t)v40, 0)
        || !CBB_add_u24((uint64_t)v40, HIDWORD(v32[0]))
        || !CBB_finish((uint64_t)v40, 0LL, 0LL))
      {
        goto LABEL_42;
      }

      if (HIDWORD(v32[0]))
      {
        if (HIDWORD(v32[0]) >= 0xFFFFFFF9)
        {
          ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 183);
LABEL_42:
          int v23 = 0LL;
          goto LABEL_43;
        }

        uint64_t v24 = OPENSSL_zalloc(((unint64_t)HIDWORD(v32[0]) + 7) >> 3);
        int v23 = v39;
        *((void *)v39 + 2) = v24;
        if (!v24) {
          goto LABEL_42;
        }
      }

      else
      {
        int v23 = v39;
      }
    }

    else
    {
      int v23 = 0LL;
    }

    uint64_t v39 = 0LL;
LABEL_43:
    int v38 = v23;
    std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](&v39, 0LL);
    CBB_cleanup((uint64_t)v40);
    unsigned int v25 = (bssl::hm_fragment **)(*(void *)(a1 + 56) + 8 * v16 + 72);
    int v38 = 0LL;
    std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](v25, v23);
    std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](&v38, 0LL);
    int v17 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 8 * v16 + 72);
    if (!v17)
    {
LABEL_68:
      int v26 = 80;
      goto LABEL_65;
    }

    int v18 = *((_DWORD *)v17 + 1);
    goto LABEL_45;
  }

  if (*v17 == LOBYTE(v32[0]))
  {
    int v18 = *((_DWORD *)v17 + 1);
    if (v18 == HIDWORD(v32[0]))
    {
LABEL_45:
      if (v18 != (_DWORD)v10) {
        bssl::dtls1_open_handshake();
      }
      if (*((void *)v17 + 2))
      {
        if (!(_DWORD)v10) {
          bssl::dtls1_open_handshake();
        }
        if (__n) {
          memcpy((void *)(*((void *)v17 + 1) + v9 + 12), __src, __n);
        }
        bssl::dtls1_hm_fragment_mark((bssl *)v17, v9, v11);
      }

      goto LABEL_51;
    }
  }

  int v27 = 152;
  uint64_t v28 = 276;
LABEL_64:
  ERR_put_error(16, 0, v27, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", v28);
  int v26 = 47;
LABEL_65:
  *a3 = v26;
  return 4LL;
}
  }

  if (v25 && *(_BYTE *)(v25 + v27))
  {
    if (v30 < v28 || v28 == -1) {
      uint64_t v28 = v30;
    }
    goto LABEL_57;
  }

  char v46 = v28;
  if (v30 < v28) {
    char v46 = v30;
  }
  if (v28 == -1) {
    unsigned __int16 v45 = v30;
  }
  else {
    unsigned __int16 v45 = v46;
  }
LABEL_66:
  int v47 = OPENSSL_sk_value(v24, v45);
  unint64_t v43 = (bssl *)v47;
  return v43;
}

uint64_t bssl::tls_can_accept_handshake_data(bssl *this, const ssl_st *a2, unsigned __int8 *a3)
{
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v5;
  v11[1] = v5;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  if (bssl::parse_message((uint64_t)this, (uint64_t)v11, (uint64_t *)&v10))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 523);
    char v7 = 80;
LABEL_5:
    uint64_t result = 0LL;
    LOBYTE(a2->version) = v7;
    return result;
  }

  unint64_t v8 = v10;
  if (v8 > bssl::ssl_max_handshake_message_len(this, v6) + 4)
  {
    ERR_put_error(16, 0, 150, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 530);
    char v7 = 47;
    goto LABEL_5;
  }

  return 1LL;
}

uint64_t bssl::ssl_max_handshake_message_len(bssl *this, const ssl_st *a2)
{
  if (SSL_in_init((uint64_t)this))
  {
    if ((*((_BYTE *)this + 180) & 1) == 0 || (*(_BYTE *)(*((void *)this + 1) + 300LL) & 1) != 0)
    {
      unsigned int v5 = *((_DWORD *)this + 38);
      if (v5 <= 0x4000) {
        return 0x4000LL;
      }
      else {
        return v5;
      }
    }

    else
    {
      return 0x4000LL;
    }
  }

  else if (bssl::ssl_protocol_version(this, v3) >= 0x304)
  {
    if ((*((_BYTE *)this + 180) & 1) != 0) {
      return 1LL;
    }
    else {
      return 0x4000LL;
    }
  }

  else
  {
    return 0LL;
  }

BOOL SSL_in_init(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 48) + 280LL);
  return v1 && ((*(_DWORD *)(v1 + 1584) >> 3) & 1) == 0;
}

uint64_t CBS_get_u8(void *a1, _BYTE *a2)
{
  uint64_t v2 = a1[1];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = (_BYTE *)(*a1)++;
  a1[1] = v2 - 1;
  *a2 = *v3;
  return 1LL;
}

uint64_t bssl::ssl_handle_open_record(bssl *a1, _BYTE *a2, int a3, ssl_st *a4, int a5)
{
  *a2 = 0;
  uint64_t v6 = *((void *)a1 + 6);
  unint64_t v7 = *(unsigned __int16 *)(v6 + 92);
  if (a3 == 2) {
    goto LABEL_4;
  }
  *(_WORD *)(v6 + 88) += (_WORD)a4;
  LOWORD(v7) = v7 - (_WORD)a4;
  *(_WORD *)(v6 + 92) = v7;
  *(_WORD *)(v6 + 94) -= (_WORD)a4;
  if (!a3) {
    return 1LL;
  }
LABEL_4:
  if (!(_WORD)v7)
  {
    *(_WORD *)(v6 + 8_Block_object_dispose(va, 8) = *(_WORD *)(v6 + 90);
    *(_WORD *)(v6 + 92) = 0;
    *(_WORD *)(v6 + 94) = *(_WORD *)(v6 + 96);
  }

  uint64_t v8 = 1LL;
  switch(a3)
  {
    case 0:
      return v8;
    case 1:
      goto LABEL_9;
    case 2:
      uint64_t buffer_extend_to = bssl::ssl_read_buffer_extend_to(a1, (unint64_t)a4);
      if ((int)buffer_extend_to < 1)
      {
        uint64_t v8 = buffer_extend_to;
      }

      else
      {
        uint64_t v8 = 1LL;
LABEL_9:
        *a2 = 1;
      }

      break;
    case 3:
      uint64_t v8 = 0LL;
      *(_DWORD *)(v6 + 1bssl::Array<unsigned short>::~Array(v1 - 96) = 6;
      return v8;
    case 4:
      if (a5) {
        bssl::ssl_send_alert(a1, (ssl_st *)2, a5);
      }
      return 0xFFFFFFFFLL;
    default:
      bssl::ssl_handle_open_record();
  }

  return v8;
}

uint64_t bssl::ssl_read_buffer_extend_to(bssl *this, unint64_t a2)
{
  uint64_t v4 = (_WORD *)*((void *)this + 6);
  if (!v4[46])
  {
    v4[44] = v4[45];
    v4[46] = 0;
    v4[47] = v4[48];
  }

  uint64_t v6 = (bssl::SSLBuffer *)(*((void *)this + 6) + 80LL);
  int v7 = bssl::ssl_record_prefix_len((unsigned __int8 **)this, v5);
  if (!*((void *)this + 3))
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", 213);
    return 0xFFFFFFFFLL;
  }

  int is_dtls = SSL_is_dtls((unsigned __int8 **)this);
  uint64_t v9 = *((void *)this + 6);
  if (is_dtls)
  {
    if (*(_WORD *)(v9 + 92))
    {
      int v10 = 68;
      int v11 = 156;
LABEL_15:
      ERR_put_error(16, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", v11);
      uint64_t result = 0xFFFFFFFFLL;
      goto LABEL_16;
    }

    uint64_t result = BIO_read( *((BIO **)this + 3),  (void *)(*(void *)(v9 + 80) + *(unsigned __int16 *)(v9 + 88)),  *(unsigned __int16 *)(v9 + 94));
    if ((int)result > 0)
    {
      uint64_t v14 = *(unsigned __int16 *)(v9 + 92);
      if ((unint64_t)*(unsigned __int16 *)(v9 + 94) - v14 < result) {
LABEL_28:
      }
        abort();
      *(_WORD *)(v9 + 92) = v14 + result;
      return 1LL;
    }
  }

  else
  {
    if (a2 > *(unsigned __int16 *)(v9 + 94))
    {
      int v10 = 121;
      int v11 = 175;
      goto LABEL_15;
    }

    unint64_t v15 = *(unsigned __int16 *)(v9 + 92);
    if (a2 <= v15) {
      return 1LL;
    }
    while (1)
    {
      uint64_t result = BIO_read( *((BIO **)this + 3),  (void *)(*(void *)(v9 + 80) + *(unsigned __int16 *)(v9 + 88) + v15),  a2 - v15);
      uint64_t v16 = *(unsigned __int16 *)(v9 + 92);
      unsigned __int16 v17 = v16 + result;
      *(_WORD *)(v9 + 92) = v16 + result;
      unint64_t v15 = (unsigned __int16)(v16 + result);
      uint64_t result = 1LL;
      if (a2 <= v17) {
        return result;
      }
    }
  }

  *(_DWORD *)(*((void *)this + 6) + 196LL) = 2;
LABEL_16:
  int v13 = (_WORD *)*((void *)this + 6);
  if (!v13[46])
  {
    v13[44] = v13[45];
    v13[46] = 0;
    v13[47] = v13[48];
  }

  return result;
}

uint64_t bssl::ssl_record_prefix_len(unsigned __int8 **this, const ssl_st *a2)
{
  else {
    uint64_t v3 = 5LL;
  }
  return bssl::SSLAEADContext::ExplicitNonceLen(*((bssl::SSLAEADContext **)this[6] + 33)) + v3;
}

uint64_t bssl::SSLBuffer::EnsureCap(bssl::SSLBuffer *this, int a2, unint64_t a3)
{
  if (a3 >= 0x10000)
  {
    int v3 = 68;
    int v4 = 68;
LABEL_3:
    ERR_put_error(16, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", v4);
    return 0LL;
  }

  if (*((unsigned __int16 *)this + 7) < a3)
  {
    if (a3 <= 5)
    {
      uint64_t v12 = 0LL;
      int v11 = (char *)this + 18;
      LOWORD(v9) = a3;
    }

    else
    {
      if (a3 <= 0x4145) {
        uint64_t v9 = 16709LL;
      }
      else {
        uint64_t v9 = a3;
      }
      int v10 = (char *)malloc(v9 + 7);
      if (!v10)
      {
        int v3 = 65;
        int v4 = 99;
        goto LABEL_3;
      }

      int v11 = v10;
      uint64_t v12 = (-a2 - (int)v10) & 7LL;
    }

    if (*((_WORD *)this + 6)) {
      memmove( &v11[v12],  (const void *)(*(void *)this + *((unsigned __int16 *)this + 4)),  *((unsigned __int16 *)this + 6));
    }
    if (*((_BYTE *)this + 23)) {
      free(*(void **)this);
    }
    *(void *)this = v11;
    *((_BYTE *)this + 23) = a3 > 5;
    *((_WORD *)this + 4) = v12;
    *((_WORD *)this + 7) = v9;
    *((_WORD *)this + _Block_object_dispose(va, 8) = v9;
    *((_WORD *)this + 5) = v12;
  }

  return 1LL;
}

int BIO_read(BIO *b, void *data, int len)
{
  if (!b || !b->method || (bread = b->method->bread) == 0LL)
  {
    int v6 = 115;
    int v7 = 129;
LABEL_9:
    ERR_put_error(17, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", v7);
    return -2;
  }

  if (!LODWORD(b->cb_arg))
  {
    int v6 = 114;
    int v7 = 133;
    goto LABEL_9;
  }

  if (len < 1) {
    return 0;
  }
  int result = ((uint64_t (*)(BIO *, void *))bread)(b, data);
  if (result >= 1) {
    b->next_bio = (bio_st *)((char *)b->next_bio + result);
  }
  return result;
}

uint64_t boringssl_bio_read(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    uint64_t result = (*(uint64_t (**)(void))(v3 + 8))(*(void *)v3);
    BIO_set_retry_read(a1);
  }

  return 0xFFFFFFFFLL;
}

uint64_t nw_protocol_boringssl_read_bytes(void *a1, uint64_t a2, int a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  unsigned int v5 = a1;
  int v6 = v5;
  if ((!v5 || (v5[475] & 1) == 0)
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_read_bytes_cold_7();
  }

  uint64_t v7 = 0xFFFFFFFFLL;
  if (v6
    && a2
    && a3
    && boringssl_session_get_state(*((void *)v6 + 42)) <= 3
    && (boringssl_session_is_cancelled(*((void *)v6 + 42)) & 1) == 0)
  {
    if ((v6[390] & 2) != 0)
    {
      if ((v6[475] & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_read_bytes_cold_6();
      }
    }

    else if ((v6[475] & 1) == 0 && g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_read_bytes_cold_5();
    }

    if (nw_frame_array_is_empty()
      && (*(_DWORD *)buf = 0, !nw_protocol_boringssl_read_frames(v6, *((void *)v6 + 5), buf)))
    {
      if ((v6[390] & 2) != 0)
      {
        if ((v6[475] & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_read_bytes_cold_2();
        }
      }

      else if ((v6[475] & 1) == 0 {
             && g_boringssl_log
      }
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_read_bytes_cold_1();
      }

      uint64_t v7 = 0LL;
    }

    else
    {
      nw_frame_array_first();
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!*((void *)v6 + 46)) {
        objc_storeStrong((id *)v6 + 46, v8);
      }
      if (v8)
      {
        do
        {
          if (*((void **)v6 + 46) != v8 && (v6[475] & 1) == 0)
          {
            uint64_t v12 = (os_log_s *)g_boringssl_log;
            if (g_boringssl_log)
            {
              if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_FAULT))
              {
                uint64_t v13 = *((void *)v6 + 46);
                *(_DWORD *)buf = 136447490;
                char v19 = "nw_protocol_boringssl_read_bytes";
                __int16 v20 = 1024;
                int v21 = 268;
                __int16 v22 = 2082;
                int v23 = v6 + 391;
                __int16 v24 = 2048;
                unsigned int v25 = v6;
                __int16 v26 = 2048;
                *(void *)int v27 = v13;
                *(_WORD *)&v27[8] = 2048;
                *(void *)&v27[10] = v8;
                _os_log_fault_impl( &dword_187560000,  v12,  OS_LOG_TYPE_FAULT,  "%{public}s(%d) %{public}s[%p] current input frame (%p) does not match frame being processed (%p)",  buf,  0x3Au);
              }
            }
          }

          nw_frame_array_next();
          uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
          uint64_t v10 = nw_frame_unclaimed_bytes();
          boringssl_context_is_dtls(*((void *)v6 + 42));
          v6[389] |= 0x40u;
          char v11 = nw_frame_claim();
          *((_DWORD *)v6 + 94) = *((_DWORD *)v6 + 94);
          if ((nw_frame_unclaim() & 1) == 0 && (v6[475] & 1) == 0)
          {
            if (datapath_logging_enabled)
            {
              oslog = (os_log_s *)g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                {
                  int v15 = *((_DWORD *)v6 + 94);
                  *(_DWORD *)buf = 136447490;
                  char v19 = "nw_protocol_boringssl_read_bytes";
                  __int16 v20 = 1024;
                  int v21 = 290;
                  __int16 v22 = 2082;
                  int v23 = v6 + 391;
                  __int16 v24 = 2048;
                  unsigned int v25 = v6;
                  __int16 v26 = 1024;
                  *(_DWORD *)int v27 = v15;
                  *(_WORD *)&v27[4] = 2048;
                  *(void *)&v27[6] = v8;
                  _os_log_debug_impl( &dword_187560000,  oslog,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] failed to unclaim %d bytes from %p",  buf,  0x36u);
                }
              }
            }
          }

          *((_DWORD *)v6 + 94) = 0;
          objc_storeStrong((id *)v6 + 46, v9);
          nw_frame_array_remove();
          nw_frame_finalize();
          if ((v11 & 1) == 0 && (v6[475] & 1) == 0)
          {
            if (datapath_logging_enabled)
            {
              uint64_t v14 = (os_log_s *)g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136447490;
                  char v19 = "nw_protocol_boringssl_read_bytes";
                  __int16 v20 = 1024;
                  int v21 = 299;
                  __int16 v22 = 2082;
                  int v23 = v6 + 391;
                  __int16 v24 = 2048;
                  unsigned int v25 = v6;
                  __int16 v26 = 1024;
                  *(_DWORD *)int v27 = 0;
                  *(_WORD *)&v27[4] = 2048;
                  *(void *)&v27[6] = v10;
                  _os_log_debug_impl( &dword_187560000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] failed to claim %d bytes from %p",  buf,  0x36u);
                }
              }
            }
          }

          uint64_t v7 = 0LL;
          *((_DWORD *)v6 + 94) = 0;
          objc_storeStrong((id *)v6 + 46, v9);

          uint64_t v8 = v9;
        }

        while (v9);
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      if ((v6[390] & 2) != 0)
      {
        if ((v6[475] & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_read_bytes_cold_4();
        }
      }

      else if ((v6[475] & 1) == 0 {
             && g_boringssl_log
      }
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_read_bytes_cold_3();
      }
    }
  }

  return v7;
}

uint64_t nw_protocol_boringssl_read_frames(void *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  unsigned int v5 = a1;
  int v6 = v5;
  if (!a3)
  {
LABEL_18:
    uint64_t v7 = 0LL;
    goto LABEL_19;
  }

  if (boringssl_session_get_state(v5[42]) > 3 || (boringssl_session_is_cancelled(v6[42]) & 1) != 0)
  {
    uint64_t v7 = 0xFFFFFFFFLL;
    goto LABEL_19;
  }

  if (!a2 || (uint64_t v8 = *(void *)(a2 + 24)) == 0 || !*(void *)(v8 + 80))
  {
    if ((*((_BYTE *)v6 + 475) & 1) == 0
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_read_frames_cold_1();
    }

    goto LABEL_18;
  }

  v14[0] = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = 0xAAAAAAAAAAAAAAAALL;
  nw_frame_array_init();
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, void *))(*(void *)(a2 + 24) + 80LL))( a2,  v6 + 1,  1LL,  0xFFFFFFFFLL,  0xFFFFFFFFLL,  v14);
  *a3 = 0;
  uint64_t v9 = nw_frame_array_first();
  if (v9)
  {
    uint64_t v10 = (void *)v9;
    do
    {
      uint64_t v11 = nw_frame_array_next();
      nw_frame_unclaimed_bytes();
      *a3 = *a3;
      nw_frame_array_remove();
      nw_frame_array_append();
      if (nw_frame_is_wake_packet())
      {
        *((_BYTE *)v6 + 390) |= 0x10u;
        if ((*((_BYTE *)v6 + 475) & 1) == 0)
        {
          if (g_boringssl_log)
          {
            log = (os_log_s *)g_boringssl_log;
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446978;
              uint64_t v16 = "nw_protocol_boringssl_read_frames";
              __int16 v17 = 1024;
              int v18 = 216;
              __int16 v19 = 2082;
              __int16 v20 = (char *)v6 + 391;
              __int16 v21 = 2048;
              __int16 v22 = v6;
              _os_log_impl( &dword_187560000,  log,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Frame with wake flag detected",  buf,  0x26u);
            }
          }
        }
      }

      uint64_t v10 = (void *)v11;
    }

    while (v11);
  }

uint64_t BIO_set_retry_read(uint64_t result)
{
  *(_DWORD *)(result + 24) |= 9u;
  return result;
}

uint64_t boringssl_session_handshake_incomplete(void *a1, int a2, char a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a1[1];
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  unsigned int error = SSL_get_error(*(const SSL **)(v4 + 400), a2);
  unsigned int v7 = error;
  if (error == 2)
  {
    uint64_t v8 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_read_stalls;
  }

  else
  {
    if (error != 3) {
      goto LABEL_8;
    }
    uint64_t v8 = &OBJC_IVAR___boringssl_concrete_boringssl_ctx_write_stalls;
  }

  ++*(void *)(v4 + *v8);
LABEL_8:
  ssl_error_code_description = boringssl_helper_get_ssl_error_code_description(error);
  if (boringssl_helper_error_is_fatal(v7))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
    if (!WeakRetained
      || (uint64_t v11 = WeakRetained,
          uint64_t v12 = objc_loadWeakRetained((id *)(v4 + 16)),
          char v13 = v12[475],
          v12,
          v11,
          (v13 & 1) == 0))
    {
      id v14 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v14)
      {
        int v15 = objc_loadWeakRetained((id *)(v4 + 16));
        BOOL v16 = (v15[475] & 1) == 0;
      }

      else
      {
        BOOL v16 = 1;
      }

      if (v16)
      {
        if (g_boringssl_log)
        {
          uint64_t v23 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            boringssl_session_handshake_incomplete_cold_1(v4, ssl_error_code_description, v23);
          }
        }
      }
    }

    ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))boringssl_session_handshake_error_print, a1);
    return 0xFFFFFFFFLL;
  }

  if (v7 == 15)
  {
    if ((a3 & 1) != 0) {
      return 0LL;
    }
    SSL_reset_early_data_reject(*(void *)(v4 + 400));
  }

  __int16 v17 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
  if (!v17
    || (int v18 = v17,
        __int16 v19 = objc_loadWeakRetained((id *)(v4 + 16)),
        char v20 = v19[475],
        v19,
        v18,
        (v20 & 1) == 0))
  {
    int v18 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
    if (v18)
    {
      __int16 v21 = objc_loadWeakRetained((id *)(v4 + 16));
      BOOL v22 = (v21[475] & 1) == 0;
    }

    else
    {
      BOOL v22 = 1;
    }

    if (v22)
    {
      if (g_boringssl_log)
      {
        int v18 = (char *)(id)g_boringssl_log;
        if (os_log_type_enabled((os_log_t)v18, OS_LOG_TYPE_INFO))
        {
          id v25 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v25)
          {
            uint64_t v39 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
            __int16 v26 = v39 + 391;
          }

          else
          {
            __int16 v26 = &unk_1875F4C23;
          }

          id v27 = objc_loadWeakRetained((id *)(v4 + 16));
          *(_DWORD *)buf = 136447490;
          char v41 = "boringssl_session_handshake_incomplete";
          __int16 v42 = 1024;
          int v43 = 254;
          __int16 v44 = 2082;
          unsigned __int16 v45 = v26;
          __int16 v46 = 2048;
          id v47 = v27;
          __int16 v48 = 2082;
          uint64_t v49 = ssl_error_code_description;
          __int16 v50 = 1024;
          unsigned int v51 = v7;
          _os_log_impl( &dword_187560000,  (os_log_t)v18,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Handshake incomplete: %{public}s [%d]",  buf,  0x36u);

          if (v25) {
        }
          }
      }
    }
  }

  boringssl_context_update_encryption_level((uint64_t)a1);
  if (v7 != 15) {
    return 0LL;
  }
  id v28 = objc_loadWeakRetained((id *)(v4 + 16));
  if (!v28
    || (BOOL v29 = v28,
        id v30 = objc_loadWeakRetained((id *)(v4 + 16)),
        char v31 = v30[475],
        v30,
        v29,
        (v31 & 1) == 0))
  {
    id v32 = objc_loadWeakRetained((id *)(v4 + 16));
    if (v32)
    {
      unsigned int v33 = objc_loadWeakRetained((id *)(v4 + 16));
      BOOL v34 = (v33[475] & 1) == 0;
    }

    else
    {
      BOOL v34 = 1;
    }

    if (v34)
    {
      if (g_boringssl_log)
      {
        unsigned int v35 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          id v36 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v36)
          {
            int v18 = (char *)objc_loadWeakRetained((id *)(v4 + 16));
            unint64_t v37 = v18 + 391;
          }

          else
          {
            unint64_t v37 = &unk_1875F4C23;
          }

          id v38 = objc_loadWeakRetained((id *)(v4 + 16));
          *(_DWORD *)buf = 136446978;
          char v41 = "boringssl_session_handshake_incomplete";
          __int16 v42 = 1024;
          int v43 = 258;
          __int16 v44 = 2082;
          unsigned __int16 v45 = v37;
          __int16 v46 = 2048;
          id v47 = v38;
          _os_log_impl( &dword_187560000,  v35,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Restarting handshake",  buf,  0x26u);

          if (v36) {
        }
          }
      }
    }
  }

  return boringssl_session_handshake_continue_inner(a1, 1LL);
}

int SSL_get_error(const SSL *s, int ret_code)
{
  if (ret_code > 0) {
    return 0;
  }
  unsigned int v5 = ERR_peek_error();
  if (v5)
  {
    if (HIBYTE(v5) == 2) {
      return 5;
    }
    else {
      return 1;
    }
  }

  int result = *((_DWORD *)s->handshake_func + 49);
  if (!ret_code)
  {
    if (result == 6) {
      return 6;
    }
    else {
      return 5;
    }
  }

  if ((result - 11) >= 0xA && result != 4)
  {
    if (result == 3)
    {
      bbio = s->bbio;
    }

    else
    {
      if (result != 2) {
        return 5;
      }
      if (!*(void *)&s->hit)
      {
        bbio = s->wbio;
        if (!BIO_should_read((uint64_t)bbio))
        {
          if (!BIO_should_write((uint64_t)bbio))
          {
LABEL_26:
            if (BIO_should_io_special((uint64_t)bbio))
            {
              int retry_reason = BIO_get_retry_reason(bbio);
              if (retry_reason == 3) {
                int v9 = 8;
              }
              else {
                int v9 = 5;
              }
              if (retry_reason == 2) {
                return 7;
              }
              else {
                return v9;
              }
            }

            return 5;
          }

          return 3;
        }
      }
    }

    return 2;
  }

  return result;
}

unint64_t ERR_peek_error(void)
{
  unint64_t result = (unint64_t)err_get_state();
  if (result)
  {
    int v1 = *(_DWORD *)(result + 388);
    if (v1 == *(_DWORD *)(result + 384)) {
      return 0LL;
    }
    else {
      return *(unsigned int *)(result + 24LL * (((_BYTE)v1 + 1) & 0xF) + 16);
    }
  }

  return result;
}

uint64_t BIO_should_read(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) & 1;
}

const char *boringssl_helper_get_ssl_error_code_description(unsigned int a1)
{
  if (a1 > 0x12) {
    return "unknown error";
  }
  else {
    return off_18A071AF8[a1];
  }
}

uint64_t boringssl_helper_error_is_fatal(unsigned int a1)
{
  return (a1 > 0x10) | (0x5FC3u >> a1) & 1;
}

uint64_t boringssl_context_update_encryption_level(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  int v1 = *(void **)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  id v5 = v1;
  id v2 = v5;
  uint64_t v3 = nw_protocol_options_access_handle();

  return v3;
}

BOOL __boringssl_context_update_encryption_level_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (a2 && *(void *)(a2 + 160) && *(void *)(a2 + 168))
  {
    uint64_t v4 = (void *)MEMORY[0x1895A97C0]();
    int level = SSL_quic_read_level(*(void *)(*(void *)(a1 + 32) + 400LL));
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = MEMORY[0x1895F87A8];
    if (level != *(_DWORD *)(v6 + 548))
    {
      int v8 = level;
      id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
      if (!WeakRetained
        || (uint64_t v10 = WeakRetained,
            uint64_t v11 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL)),
            char v12 = v11[475],
            v11,
            v10,
            (v12 & 1) == 0))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        if (v13)
        {
          id v14 = objc_loadWeakRetained((id *)(v13 + 16));
          if (v14)
          {
            int v15 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
            BOOL v16 = (v15[475] & 1) == 0;
          }

          else
          {
            BOOL v16 = 1;
          }
        }

        else
        {
          BOOL v16 = 1;
        }

        if (v16 && g_boringssl_log)
        {
          __int16 v17 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            id v33 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
            uint64_t v34 = *(void *)(a1 + 32);
            __int16 v50 = v33;
            if (v33)
            {
              BOOL v37 = v34 != 0;
              if (v34)
              {
                id v38 = (char *)objc_loadWeakRetained((id *)(v34 + 16));
                uint64_t v34 = *(void *)(a1 + 32);
              }

              else
              {
                id v38 = 0LL;
              }

              BOOL v48 = v37;
              unsigned __int16 v45 = v38;
              __int16 v46 = v38 + 391;
            }

            else
            {
              BOOL v48 = 0;
              __int16 v46 = &unk_1875F4C23;
            }

            id v41 = objc_loadWeakRetained((id *)(v34 + 16));
            int v42 = *(_DWORD *)(*(void *)(a1 + 32) + 548LL);
            *(_DWORD *)buf = 136447490;
            uint64_t v59 = "boringssl_context_update_encryption_level_block_invoke";
            __int16 v60 = 1024;
            int v61 = 2454;
            __int16 v62 = 2082;
            BOOL v63 = v46;
            __int16 v64 = 2048;
            id v65 = v41;
            __int16 v66 = 1024;
            int v67 = v42;
            __int16 v68 = 1024;
            int v69 = v8;
            _os_log_debug_impl( &dword_187560000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] encryption_read_level %u -> %u",  buf,  0x32u);

            if (v48) {
          }
            }
        }
      }

      *(_DWORD *)(*(void *)(a1 + 32) + 548LL) = v8;
      int v18 = *(dispatch_queue_s **)(a2 + 168);
      block[0] = v7;
      block[1] = 3221225472LL;
      block[2] = __boringssl_context_update_encryption_level_block_invoke_213;
      block[3] = &unk_18A07BBE8;
      id v57 = v4;
      id v56 = *(id *)(a1 + 32);
      dispatch_async(v18, block);

      uint64_t v6 = *(void *)(a1 + 32);
    }

    int v19 = SSL_quic_write_level(*(void *)(v6 + 400));
    uint64_t v20 = *(void *)(a1 + 32);
    if (v19 != *(_DWORD *)(v20 + 552))
    {
      int v21 = v19;
      id v22 = objc_loadWeakRetained((id *)(v20 + 16));
      if (!v22
        || (uint64_t v23 = v22,
            __int16 v24 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL)),
            char v25 = v24[475],
            v24,
            v23,
            (v25 & 1) == 0))
      {
        uint64_t v26 = *(void *)(a1 + 32);
        if (v26)
        {
          id v27 = objc_loadWeakRetained((id *)(v26 + 16));
          if (v27)
          {
            id v28 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
            BOOL v29 = (v28[475] & 1) == 0;
          }

          else
          {
            BOOL v29 = 1;
          }
        }

        else
        {
          BOOL v29 = 1;
        }

        if (v29 && g_boringssl_log)
        {
          id v30 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            id v35 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
            uint64_t v36 = *(void *)(a1 + 32);
            unsigned int v51 = v35;
            if (v35)
            {
              BOOL v39 = v36 != 0;
              if (v36)
              {
                unsigned int v40 = (char *)objc_loadWeakRetained((id *)(v36 + 16));
                uint64_t v36 = *(void *)(a1 + 32);
              }

              else
              {
                unsigned int v40 = 0LL;
              }

              BOOL v49 = v39;
              unsigned __int16 v45 = v40;
              id v47 = v40 + 391;
            }

            else
            {
              BOOL v49 = 0;
              id v47 = &unk_1875F4C23;
            }

            id v43 = objc_loadWeakRetained((id *)(v36 + 16));
            int v44 = *(_DWORD *)(*(void *)(a1 + 32) + 552LL);
            *(_DWORD *)buf = 136447490;
            uint64_t v59 = "boringssl_context_update_encryption_level_block_invoke_2";
            __int16 v60 = 1024;
            int v61 = 2463;
            __int16 v62 = 2082;
            BOOL v63 = v47;
            __int16 v64 = 2048;
            id v65 = v43;
            __int16 v66 = 1024;
            int v67 = v44;
            __int16 v68 = 1024;
            int v69 = v21;
            _os_log_debug_impl( &dword_187560000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] encryption_write_level %u -> %u",  buf,  0x32u);

            if (v49) {
          }
            }
        }
      }

      *(_DWORD *)(*(void *)(a1 + 32) + 552LL) = v21;
      char v31 = *(dispatch_queue_s **)(a2 + 168);
      v52[0] = v7;
      v52[1] = 3221225472LL;
      v52[2] = __boringssl_context_update_encryption_level_block_invoke_215;
      v52[3] = &unk_18A07BBE8;
      id v54 = v4;
      id v53 = *(id *)(a1 + 32);
      dispatch_async(v31, v52);
    }
  }

  return a2 != 0;
}

uint64_t boringssl_session_in_false_start(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      unint64_t result = *(void *)(v1 + 400);
      if (result) {
        return SSL_in_false_start(result) != 0;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_in_false_start(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 48) + 280LL);
  if (v1) {
    return (*(_DWORD *)(v1 + 1584) >> 9) & 1;
  }
  else {
    return 0LL;
  }
}

void nw_boringssl_read(uint64_t a1)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    return;
  }
  if ((*(_BYTE *)(v2 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_boringssl_read_cold_1();
  }

  if ((*(_BYTE *)(v2 + 388) & 1) != 0 || *(void *)(v2 + 272) || (*(_BYTE *)(v2 + 389) & 2) != 0) {
    return;
  }
  *(_BYTE *)(v2 + 389) |= 2u;
  if (boringssl_session_get_state(*(void *)(v2 + 336)) < 2)
  {
    if (*(void *)(v2 + 320))
    {
      nw_queue_cancel_source();
      *(void *)(v2 + 320) = 0LL;
    }

    nw_protocol_boringssl_handshake_negotiate(v2);
    goto LABEL_134;
  }

  char v3 = 0;
  uint64_t v4 = v2 + 391;
  id v5 = "nw_boringssl_read";
  while (1)
  {
    if (*(_DWORD *)(v2 + 380) > 0x800000u)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          unsigned __int16 v45 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              int v48 = *(_DWORD *)(v2 + 380);
              *(_DWORD *)buf = 136447234;
              id v53 = v5;
              __int16 v54 = 1024;
              int v55 = 636;
              __int16 v56 = 2082;
              uint64_t v57 = v4;
              __int16 v58 = 2048;
              uint64_t v59 = v2;
              __int16 v60 = 1024;
              int v61 = v48;
              id v47 = "%{public}s(%d) %{public}s[%p] Above maximum input threshold, skipping read and resuspending (%u bytes)";
LABEL_149:
              _os_log_debug_impl(&dword_187560000, v45, OS_LOG_TYPE_DEBUG, v47, buf, 0x2Cu);
            }
          }
        }
      }

LABEL_127:
      char v19 = *(_BYTE *)(v2 + 388);
      goto LABEL_128;
    }

    uint64_t v6 = *(void *)(a1 + 40);
    if (!v6) {
      goto LABEL_28;
    }
    if ((*(_BYTE *)(v6 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        uint64_t v36 = (os_log_s *)g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            id v53 = "nw_protocol_boringssl_read_one_record";
            __int16 v54 = 1024;
            int v55 = 1306;
            __int16 v56 = 2082;
            uint64_t v57 = v6 + 391;
            __int16 v58 = 2048;
            uint64_t v59 = v6;
            _os_log_debug_impl(&dword_187560000, v36, OS_LOG_TYPE_DEBUG, "%{public}s(%d) %{public}s[%p] ", buf, 0x26u);
          }
        }
      }
    }

    if ((boringssl_session_get_state(*(void *)(v6 + 336)) & 0xFFFFFFFE) != 2)
    {
      if ((*(_BYTE *)(v6 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          id v38 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              id v53 = "nw_protocol_boringssl_read_one_record";
              __int16 v54 = 1024;
              int v55 = 1310;
              __int16 v56 = 2082;
              uint64_t v57 = v6 + 391;
              __int16 v58 = 2048;
              uint64_t v59 = v6;
              _os_log_debug_impl( &dword_187560000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Cannot get any bytes in current state",  buf,  0x26u);
            }
          }
        }
      }

      goto LABEL_28;
    }

    uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(v6 + 80))( *(void *)(v6 + 336),  0LL,  0x7FFFFFFFLL,  1LL);
    if ((*(_BYTE *)(v6 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        BOOL v37 = (os_log_s *)g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            id v53 = "nw_protocol_boringssl_read_one_record";
            __int16 v54 = 1024;
            int v55 = 1319;
            __int16 v56 = 2082;
            uint64_t v57 = v6 + 391;
            __int16 v58 = 2048;
            uint64_t v59 = v6;
            __int16 v60 = 1024;
            int v61 = v7;
            _os_log_debug_impl( &dword_187560000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] peeked %d bytes",  buf,  0x2Cu);
          }
        }
      }
    }

    int v8 = *(void **)(v6 + 336);
    if (v8)
    {
      if (*(_DWORD *)v8 == -1252936367)
      {
        uint64_t v9 = v8[1];
        if (v9)
        {
          if ((int)v7 < 1)
          {
            uint64_t v20 = *(const SSL **)(v9 + 400);
            if (v20)
            {
              int error = SSL_get_error(v20, v7);
              if ((*(_BYTE *)(v6 + 475) & 1) == 0)
              {
                if (datapath_logging_enabled)
                {
                  id v41 = (os_log_s *)g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136447234;
                      id v53 = "nw_protocol_boringssl_read_one_record";
                      __int16 v54 = 1024;
                      int v55 = 1375;
                      __int16 v56 = 2082;
                      uint64_t v57 = v6 + 391;
                      __int16 v58 = 2048;
                      uint64_t v59 = v6;
                      __int16 v60 = 1024;
                      int v61 = error;
                      _os_log_debug_impl( &dword_187560000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] read error code %d",  buf,  0x2Cu);
                    }
                  }
                }
              }

              if (error == 1)
              {
                ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))nw_protocol_error_print, v8);
                nw_protocol_boringssl_internal_error((void *)v6, -9810);
                nw_protocol_boringssl_disconnect(a1);
              }

              else if (error == 6)
              {
                nw_protocol_boringssl_input_finished(a1);
              }
            }

            else if ((*(_BYTE *)(v6 + 475) & 1) == 0)
            {
              uint64_t v35 = g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446978;
                  id v53 = "nw_protocol_boringssl_read_one_record";
                  __int16 v54 = 1024;
                  int v55 = 1371;
                  __int16 v56 = 2082;
                  uint64_t v57 = v6 + 391;
                  __int16 v58 = 2048;
                  uint64_t v59 = v6;
                  int v15 = (os_log_s *)v35;
                  BOOL v16 = "%{public}s(%d) %{public}s[%p] cannot peek into the session";
                  uint32_t v34 = 38;
                  goto LABEL_79;
                }
              }
            }

            goto LABEL_28;
          }

          uint64_t buffer_manager_with_context = nw_frame_get_buffer_manager_with_context();
          if (buffer_manager_with_context)
          {
            uint64_t v11 = buffer_manager_with_context;
            char v12 = (void *)nw_mem_buffer_allocate();
            if (v12)
            {
LABEL_47:
              uint64_t v22 = v4;
              uint64_t v23 = v5;
              int v24 = (*(uint64_t (**)(void, void *, uint64_t, void))(v6 + 80))( *(void *)(v6 + 336),  v12,  v7,  0LL);
              char v25 = *(_BYTE *)(v6 + 475);
              if ((v25 & 1) == 0)
              {
                if (datapath_logging_enabled)
                {
                  oslog = (os_log_s *)g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136447234;
                      id v53 = "nw_protocol_boringssl_read_one_record";
                      __int16 v54 = 1024;
                      int v55 = 1350;
                      __int16 v56 = 2082;
                      uint64_t v57 = v6 + 391;
                      __int16 v58 = 2048;
                      uint64_t v59 = v6;
                      __int16 v60 = 1024;
                      int v61 = v24;
                      _os_log_debug_impl( &dword_187560000,  oslog,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Actually read %d bytes",  buf,  0x2Cu);
                    }

                    char v25 = *(_BYTE *)(v6 + 475);
                  }
                }
              }

              if (v24 != (_DWORD)v7 && (v25 & 1) == 0)
              {
                osos_log_t loga = (os_log_s *)g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136447490;
                    id v53 = "nw_protocol_boringssl_read_one_record";
                    __int16 v54 = 1024;
                    int v55 = 1352;
                    __int16 v56 = 2082;
                    uint64_t v57 = v6 + 391;
                    __int16 v58 = 2048;
                    uint64_t v59 = v6;
                    __int16 v60 = 1024;
                    int v61 = v24;
                    __int16 v62 = 1024;
                    int v63 = v7;
                    _os_log_error_impl( &dword_187560000,  osloga,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Unexpected read result %d != %d",  buf,  0x32u);
                  }

                  char v25 = *(_BYTE *)(v6 + 475);
                }
              }

              if ((v25 & 1) == 0)
              {
                if (datapath_logging_enabled)
                {
                  BOOL v39 = (os_log_s *)g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136447234;
                      id v53 = "nw_protocol_boringssl_read_one_record";
                      __int16 v54 = 1024;
                      int v55 = 1403;
                      __int16 v56 = 2082;
                      uint64_t v57 = v6 + 391;
                      __int16 v58 = 2048;
                      uint64_t v59 = v6;
                      __int16 v60 = 1024;
                      int v61 = v7;
                      _os_log_debug_impl( &dword_187560000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] bytes read: %u",  buf,  0x2Cu);
                    }
                  }
                }
              }

              uint64_t v27 = nw_frame_create();
              id v28 = (void *)v27;
              if (v11)
              {
                if (v27)
                {
                  nw_frame_set_buffer_used_manager();
LABEL_58:
                  id v29 = boringssl_context_copy_metadata(*(void *)(v6 + 336));
                  if (v29)
                  {
                    boringssl_context_is_dtls(*(void *)(v6 + 336));
                    nw_frame_set_metadata();
                  }

                  id v30 = v28;
                  nw_frame_array_append();
                  nw_frame_array_append();

                  *(_DWORD *)(v6 + 380) += v7;
                  id v5 = v23;
                  uint64_t v4 = v22;
                  goto LABEL_61;
                }

                if ((*(_BYTE *)(v6 + 475) & 1) == 0)
                {
                  osos_log_t logb = (os_log_s *)g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136447234;
                      id v53 = "nw_protocol_boringssl_read_one_record";
                      __int16 v54 = 1024;
                      int v55 = 1410;
                      __int16 v56 = 2082;
                      uint64_t v57 = v6 + 391;
                      __int16 v58 = 2048;
                      uint64_t v59 = v6;
                      __int16 v60 = 1024;
                      int v61 = v7;
                      _os_log_error_impl( &dword_187560000,  oslogb,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] nw_frame_create failed for %d bytes",  buf,  0x2Cu);
                    }
                  }
                }

                nw_mem_buffer_free();
              }

              else
              {
                if (v27)
                {
                  nw_frame_set_buffer_used_malloc();
                  goto LABEL_58;
                }

                if ((*(_BYTE *)(v6 + 475) & 1) == 0)
                {
                  int v42 = (os_log_s *)g_boringssl_log;
                  if (g_boringssl_log)
                  {
                    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136447234;
                      id v53 = "nw_protocol_boringssl_read_one_record";
                      __int16 v54 = 1024;
                      int v55 = 1418;
                      __int16 v56 = 2082;
                      uint64_t v57 = v6 + 391;
                      __int16 v58 = 2048;
                      uint64_t v59 = v6;
                      __int16 v60 = 1024;
                      int v61 = v7;
                      _os_log_error_impl( &dword_187560000,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] nw_frame_create failed for %d bytes",  buf,  0x2Cu);
                    }
                  }
                }

                free(v12);
              }

              id v5 = v23;
              uint64_t v4 = v22;
              goto LABEL_28;
            }

            if ((*(_BYTE *)(v6 + 475) & 1) == 0)
            {
              if (datapath_logging_enabled)
              {
                unsigned int v40 = (os_log_s *)g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136447234;
                    id v53 = "nw_protocol_boringssl_read_one_record";
                    __int16 v54 = 1024;
                    int v55 = 1329;
                    __int16 v56 = 2082;
                    uint64_t v57 = v6 + 391;
                    __int16 v58 = 2048;
                    uint64_t v59 = v6;
                    __int16 v60 = 1024;
                    int v61 = v7;
                    _os_log_debug_impl( &dword_187560000,  v40,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Failed to allocate %d bytes for input_buffer from buffer manager",  buf,  0x2Cu);
                  }
                }
              }
            }

            uint64_t v13 = malloc(v7);
            if (!v13)
            {
              if ((*(_BYTE *)(v6 + 475) & 1) == 0)
              {
                uint64_t v14 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136447234;
                    id v53 = "nw_protocol_boringssl_read_one_record";
                    __int16 v54 = 1024;
                    int v55 = 1335;
                    __int16 v56 = 2082;
                    uint64_t v57 = v6 + 391;
                    __int16 v58 = 2048;
                    uint64_t v59 = v6;
                    __int16 v60 = 1024;
                    int v61 = v7;
                    int v15 = (os_log_s *)v14;
                    BOOL v16 = "%{public}s(%d) %{public}s[%p] Failed to allocate %d bytes for input_buffer";
LABEL_74:
                    uint32_t v34 = 44;
LABEL_79:
                    _os_log_error_impl(&dword_187560000, v15, OS_LOG_TYPE_ERROR, v16, buf, v34);
                    goto LABEL_28;
                  }
                }
              }

              goto LABEL_28;
            }
          }

          else
          {
            uint64_t v13 = malloc(v7);
            if (!v13)
            {
              if ((*(_BYTE *)(v6 + 475) & 1) == 0)
              {
                uint64_t v33 = g_boringssl_log;
                if (g_boringssl_log)
                {
                  if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136447234;
                    id v53 = "nw_protocol_boringssl_read_one_record";
                    __int16 v54 = 1024;
                    int v55 = 1342;
                    __int16 v56 = 2082;
                    uint64_t v57 = v6 + 391;
                    __int16 v58 = 2048;
                    uint64_t v59 = v6;
                    __int16 v60 = 1024;
                    int v61 = v7;
                    int v15 = (os_log_s *)v33;
                    BOOL v16 = "%{public}s(%d) %{public}s[%p] Failed to allocate %d bytes for input_buffer";
                    goto LABEL_74;
                  }
                }
              }

LABEL_28:
              if ((v3 & 1) == 0) {
                goto LABEL_129;
              }
              goto LABEL_29;
            }
          }

          char v12 = v13;
          uint64_t v11 = 0LL;
          goto LABEL_47;
        }
      }
    }

  uint64_t v26 = (id *)*(id *)(a1 + 32);
  memset(v72, 170, 17);
  if (a4 && a5)
  {
    uint64_t v27 = 0LL;
    *(void *)&id v28 = 0x2020202020202020LL;
    *((void *)&v28 + 1) = 0x2020202020202020LL;
    *(_OWORD *)&v74[15] = v28;
    unint64_t v73 = v28;
    *(_OWORD *)uint64_t v74 = v28;
    __int128 v75 = 0;
    do
    {
      else {
        id v29 = a5 - (void)v27;
      }
      if (!(_DWORD)v29) {
        goto LABEL_43;
      }
      id v30 = 3LL * (v29 - 1);
      char v31 = (char *)&v73 + 1;
      int v32 = &v27[a4];
      uint64_t v33 = (char *)v72;
      uint32_t v34 = v29;
      do
      {
        uint64_t v36 = *v32++;
        uint64_t v35 = v36;
        if (v36 - 32 >= 0x5F) {
          BOOL v37 = 46;
        }
        else {
          BOOL v37 = v35;
        }
        id v38 = boringssl_helper_dump_buffer_hexChars[v35 >> 4];
        *uint64_t v33 = v37;
        *(v31 - 1) = v38;
        *char v31 = boringssl_helper_dump_buffer_hexChars[v35 & 0xF];
        if (!v30) {
          *((_BYTE *)v72 + (v29 - 1) + 1) = 0;
        }
        v30 -= 3LL;
        v31 += 3;
        ++v33;
        --v34;
      }

      while (v34);
      if (v29 <= 0xF) {
LABEL_43:
      }
        memset(&v74[3 * v29 - 16], 32, (3 * (16 - v29) - 1));
      if (!v26) {
        goto LABEL_53;
      }
      BOOL v39 = objc_loadWeakRetained(v26 + 2);
      if (!v39
        || (unsigned int v40 = v39,
            id v41 = objc_loadWeakRetained(v26 + 2),
            int v42 = v41[475],
            v41,
            v40,
            (v42 & 1) == 0))
      {
        uint64_t v43 = objc_loadWeakRetained(v26 + 2);
        if (v43)
        {
          uint64_t v44 = objc_loadWeakRetained(v26 + 2);
          unsigned __int16 v45 = (v44[475] & 1) == 0;
        }

        else
        {
          unsigned __int16 v45 = 1;
        }

        if (v45)
        {
LABEL_53:
          if (g_boringssl_log)
          {
            int v46 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
            {
              if (v26)
              {
                id v47 = objc_loadWeakRetained(v26 + 2);
                int v55 = v47 != 0LL;
                __int16 v54 = v47;
                if (v47)
                {
                  uint64_t v52 = (char *)objc_loadWeakRetained(v26 + 2);
                  int v48 = v52 + 391;
                }

                else
                {
                  int v48 = &unk_1875F4C23;
                }

                id v53 = objc_loadWeakRetained(v26 + 2);
                BOOL v49 = v53;
              }

              else
              {
                int v55 = 0;
                BOOL v49 = 0LL;
                int v48 = &unk_1875F4C23;
              }

              *(_DWORD *)buf = 136447746;
              uint64_t v59 = "boringssl_helper_dump_buffer";
              __int16 v60 = 1024;
              int v61 = 938;
              __int16 v62 = 2082;
              int v63 = v48;
              uint64_t v64 = 2048;
              id v65 = v49;
              __int16 v66 = 2048;
              int v67 = v27;
              __int16 v68 = 2080;
              int v69 = &v73;
              uint64_t v70 = 2080;
              uint64_t v71 = v72;
              _os_log_impl( &dword_187560000,  v46,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] %4lu   %s   %s",  buf,  0x44u);
              if (v26) {

              }
              if (v55) {
              if (v26)
              }
            }
          }
        }
      }

      v27 += v29;
    }

    while ((unint64_t)v27 < a5);
  }

  return 1LL;
}

    unint64_t result = CBB_flush(a2);
    if (!(_DWORD)result) {
      return result;
    }
  }

  if (a4) {
    *(_DWORD *)(*(void *)(a1 + 32) + 324LL) = CFErrorGetCode(a4);
  }
  if (boringssl_session_get_state(*(void *)(a1 + 48)) <= 3
    && (boringssl_session_is_cancelled(*(void *)(a1 + 48)) & 1) == 0)
  {
    uint64_t v26 = *(id *)(a1 + 32);
    uint64_t v27 = *(id *)(a1 + 40);
    nw_queue_context_async_if_needed();
  }

LABEL_61:
    if (*(_DWORD *)(v2 + 380) <= 0x800000u)
    {
      char v3 = 1;
      goto LABEL_36;
    }

    if ((*(_BYTE *)(v2 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        char v31 = (os_log_s *)g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            int v32 = *(_DWORD *)(v2 + 380);
            *(_DWORD *)buf = 136447234;
            id v53 = v5;
            __int16 v54 = 1024;
            int v55 = 655;
            __int16 v56 = 2082;
            uint64_t v57 = v4;
            __int16 v58 = 2048;
            uint64_t v59 = v2;
            __int16 v60 = 1024;
            int v61 = v32;
            _os_log_debug_impl( &dword_187560000,  v31,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Passed max input threshold, stopping reading to deliver data (%u bytes)",  buf,  0x2Cu);
          }
        }
      }
    }

LABEL_29:
    uint64_t v17 = *(void *)(a1 + 48);
    if (!v17) {
      goto LABEL_35;
    }
    uint64_t v18 = *(void *)(v17 + 24);
    if (!v18 || !*(void *)(v18 + 64)) {
      goto LABEL_35;
    }
    *(_BYTE *)(v2 + 388) |= 0x40u;
    (*(void (**)(void))(*(void *)(*(void *)(a1 + 48) + 24LL) + 64LL))();
    char v19 = *(_BYTE *)(v2 + 388);
    if ((v19 & 0x40) != 0) {
      break;
    }
    char v3 = 0;
LABEL_37:
    if (v19 < 0) {
      goto LABEL_129;
    }
  }

  if (*(_DWORD *)(v2 + 380) <= 0x8000u)
  {
LABEL_35:
    char v3 = 0;
LABEL_36:
    char v19 = *(_BYTE *)(v2 + 388);
    goto LABEL_37;
  }

  if ((*(_BYTE *)(v2 + 475) & 1) == 0)
  {
    if (datapath_logging_enabled)
    {
      unsigned __int16 v45 = (os_log_s *)g_boringssl_log;
      if (g_boringssl_log)
      {
        if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          int v46 = *(_DWORD *)(v2 + 380);
          *(_DWORD *)buf = 136447234;
          id v53 = v5;
          __int16 v54 = 1024;
          int v55 = 683;
          __int16 v56 = 2082;
          uint64_t v57 = v4;
          __int16 v58 = 2048;
          uint64_t v59 = v2;
          __int16 v60 = 1024;
          int v61 = v46;
          id v47 = "%{public}s(%d) %{public}s[%p] input_available unacknowledged, data (%u bytes) over readahead threshold, "
                "suspending reads";
          goto LABEL_149;
        }

        goto LABEL_127;
      }
    }
  }
        }

      case 1:
        id v38 = *(void *)this;
        *(unint64_t *)((char *)&d.options + 1) = 0xAAAAAAAAAAAAAAAALL;
        v39.suint64_t k = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&v39.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.init_buf + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.init_num + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.handshake_func + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.quiet_shutdown + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.rbio + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.bbio + 1) = v39;
        *(CRYPTO_EX_DATA *)((char *)&d.version + 1) = v39;
        if (!bssl::SSL_HANDSHAKE::GetClientHello( (uint64_t *)this,  (uint64_t)&d.ex_data.sk + 1,  (uint64_t)&d.version + 1)) {
          goto LABEL_280;
        }
        LOBYTE(d.version) = 50;
        unsigned int v40 = *(void *)(v38 + 48);
        id v41 = *(void *)this;
        *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
        extension = bssl::ssl_client_hello_get_extension( (uint64_t)&d.version + 1,  (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1),  41);
        if ((extension & 1) == 0) {
          goto LABEL_84;
        }
        *(void *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
        if ((bssl::ssl_client_hello_get_extension((uint64_t)&d.version + 1, &d.sid_ctx[13], 45) & 1) != 0)
        {
          *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))0xAAAAAAAAAAAAAAAALL;
          *(void **)((char *)&d.tlsext_debug_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
          *(const EVP_MD **)((char *)&d.read_hash + 1) = (const EVP_MD *)0xAAAAAAAAAAAAAAAALL;
          *(COMP_CTX **)((char *)&d.expand + 1) = (COMP_CTX *)0xAAAAAAAAAAAAAAAALL;
          *(_DWORD *)((char *)&d.max_cert_list + 1) = -1431655766;
          if ((bssl::ssl_ext_pre_shared_key_parse_clienthello( (uint64_t)this,  (unint64_t *)((char *)&d.tlsext_debug_cb + 1),  (const EVP_MD **)((char *)&d.read_hash + 1),  (int *)((char *)&d.max_cert_list + 1),  (char *)&d,  (uint64_t)&d.version + 1,  (uint64_t)&d.verify_callback + 1) & 1) != 0)
          {
            if ((*((_BYTE *)this + 1584) & 0x10) == 0)
            {
LABEL_84:
              uint64_t v43 = 0LL;
              if ((bssl::ssl_get_new_session(this, a2) & 1) == 0)
              {
LABEL_298:
                version_low = 80;
                goto LABEL_299;
              }

  uint64_t v17 = 50;
LABEL_24:
  *a1 = v17;
LABEL_25:
  pkey = 0LL;
  if (v13) {
    EVP_PKEY_free(v13);
  }
LABEL_27:
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&ctx, 0LL);
  return v12;
}

    uint64_t v23 = 0LL;
    int v21 = 0LL;
    goto LABEL_30;
  }

  uint64_t v27 = cp;
  char v19 = *cp;
  uint64_t v20 = malloc(8LL * *cp);
  if (!v20)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      ECDH_compute_key_cold_7();
    }
    goto LABEL_29;
  }

  int v21 = v20;
  uint64_t v22 = malloc((32 * v19) | 0x10);
  if (v22)
  {
    void *v22 = v27;
    uint64_t v26 = v22;
    if (MEMORY[0x1895A8E90](v27, v15, v17, v21))
    {
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        ECDH_compute_key_cold_8();
      }
    }

    else if (ccn_read_uint() != -1)
    {
      id v28 = 8LL * *v27;
      uint64_t v23 = malloc(v28);
      if (!ccecdh_compute_shared_secret())
      {
        if (!KDF)
        {
          if (v28 < v8)
          {
            id v29 = v28;
            int v8 = v28;
          }

          memcpy(out, v23, v8);
          goto LABEL_55;
        }

        if (((uint64_t (*)(void *, size_t, void *, size_t *))KDF)(v23, v28, out, &v29))
        {
          LODWORD(v_Block_object_dispose(va, 8) = v29;
LABEL_55:
          cc_clear();
          free(v26);
          goto LABEL_31;
        }

        ERR_put_error( 27,  0,  100,  "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_ecdh.m",  124);
      }

    id v5 = 0LL;
    goto LABEL_30;
  }

  uint64_t v11 = (id *)(v6 + 16);
  char v12 = objc_loadWeakRetained((id *)(v6 + 16));
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = objc_loadWeakRetained((id *)(v6 + 16));
    int v15 = v14[475];

    if ((v15 & 1) != 0) {
      goto LABEL_29;
    }
  }

  BOOL v16 = objc_loadWeakRetained(v11);
  if (v16)
  {
    uint64_t v17 = objc_loadWeakRetained(v11);
    uint64_t v18 = (v17[475] & 1) == 0;
  }

  else
  {
    uint64_t v18 = 1;
  }

  id v5 = 0LL;
  if (v18 && g_boringssl_log)
  {
    uint64_t v27 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      boringssl_context_set_signed_cert_timestamp_list_cold_1(v11, v27);
    }
    goto LABEL_28;
  }

LABEL_128:
  *(_BYTE *)(v2 + 38_Block_object_dispose(va, 8) = v19 | 0x80;
LABEL_129:
  if ((*(_BYTE *)(v2 + 389) & 1) != 0)
  {
    uint64_t v43 = *(void *)(a1 + 48);
    if (v43)
    {
      uint64_t v44 = *(void *)(v43 + 24);
      if (v44)
      {
        if (*(void *)(v44 + 184))
        {
          *(_BYTE *)(v2 + 389) &= ~1u;
          (*(void (**)(void))(*(void *)(*(void *)(a1 + 48) + 24LL) + 184LL))();
        }
      }
    }
  }

LABEL_129:
  v118[0] = MEMORY[0x1895F87A8];
  v118[1] = 3221225472LL;
  v118[2] = __boringssl_context_evaluate_trust_async_external_block_invoke_203;
  v118[3] = &unk_18A07BAA8;
  uint64_t v96 = *(void *)(a1 + 64);
  __int128 v120 = *(void *)(a1 + 56);
  id v97 = *(void *)(a1 + 48);
  __int16 v119 = *(id *)(a1 + 40);
  boringssl_context_evaluate_trust_async_internal(v97, v96, v118);
}

LABEL_134:
  *(_BYTE *)(v2 + 389) &= ~2u;
}

uint64_t boringssl_session_handshake_continue(SSL *a1)
{
  return boringssl_session_handshake_continue_inner(a1, 0);
}

void nw_protocol_boringssl_output_available(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[5];
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_output_available_cold_5();
      }

      if (a1[4])
      {
        if ((*(_BYTE *)(v2 + 390) & 2) != 0)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0
            && datapath_logging_enabled
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            nw_protocol_boringssl_output_available_cold_4();
          }
        }

        else if ((*(_BYTE *)(v2 + 475) & 1) == 0 {
               && g_boringssl_log
        }
               && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          nw_protocol_boringssl_output_available_cold_3();
        }

        if ((*(_BYTE *)(v2 + 388) & 0x20) != 0
          && (nw_protocol_boringssl_write_frames((void *)v2), (*(_BYTE *)(v2 + 388) & 0x20) != 0))
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0
            && datapath_logging_enabled
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
          {
            nw_protocol_boringssl_output_available_cold_2();
          }
        }

        else
        {
          int state = boringssl_session_get_state(*(void *)(v2 + 336));
          if (state == 1)
          {
            nw_protocol_boringssl_handshake_negotiate((void *)v2);
          }

          else if (state == 2)
          {
            if ((*(_BYTE *)(v2 + 475) & 1) == 0
              && datapath_logging_enabled
              && g_boringssl_log
              && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              nw_protocol_boringssl_output_available_cold_1();
            }

            (*(void (**)(void))(*(void *)(a1[6] + 24LL) + 72LL))();
          }
        }
      }
    }
  }

void nw_protocol_boringssl_input_available(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          if (g_boringssl_log)
          {
            uint64_t v7 = a2;
            uint64_t v9 = a1;
            BOOL v4 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
            a2 = v7;
            a1 = v9;
            if (v4)
            {
              nw_protocol_boringssl_input_available_cold_3();
              a2 = v7;
              a1 = v9;
            }
          }
        }
      }

      if (*(void *)(a1 + 48))
      {
        if ((*(_BYTE *)(v2 + 390) & 2) != 0)
        {
          if ((*(_BYTE *)(v2 + 475) & 1) == 0)
          {
            if (datapath_logging_enabled)
            {
              if (g_boringssl_log)
              {
                uint64_t v6 = a2;
                uint64_t v8 = a1;
                BOOL v5 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
                a2 = v6;
                a1 = v8;
                if (v5)
                {
                  nw_protocol_boringssl_input_available_cold_2();
                  goto LABEL_10;
                }
              }
            }
          }
        }

        else if ((*(_BYTE *)(v2 + 475) & 1) == 0)
        {
          if (g_boringssl_log)
          {
            uint64_t v6 = a2;
            uint64_t v8 = a1;
            BOOL v3 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
            a2 = v6;
            a1 = v8;
            if (v3)
            {
              nw_protocol_boringssl_input_available_cold_1();
LABEL_10:
              a2 = v6;
              a1 = v8;
            }
          }
        }

        if (*(void *)(v2 + 280) == a2)
        {
          if (!a2) {
            goto LABEL_24;
          }
        }

        else if (*(void *)(v2 + 288) == a2)
        {
          if (!a2) {
            goto LABEL_24;
          }
        }

        else
        {
          if (*(void *)(v2 + 296) != a2)
          {
            if (*(void *)(v2 + 304) != a2 || !a2) {
              goto LABEL_24;
            }
            goto LABEL_21;
          }

          if (!a2)
          {
LABEL_24:
            nw_boringssl_read(a1);
            return;
          }
        }

LABEL_21:
        int v10 = 0;
        if (nw_protocol_boringssl_read_frames((void *)v2, a2, &v10))
        {
          nw_frame_array_foreach();
          nw_protocol_boringssl_handshake_negotiate((void *)v2);
        }
      }
    }
  }

    if (!*((void *)&v22 + 1)) {
      return 1LL;
    }
  }

  int v15 = v9;
  BOOL v16 = a3;
  while (1)
  {
    uint64_t v17 = (_WORD *)*v16;
    if (v21 == *(_WORD *)*v16)
    {
      if (*((_BYTE *)v17 + 2)) {
        break;
      }
    }

    ++v16;
    v15 -= 8LL;
    if (!v15) {
      goto LABEL_17;
    }
  }

  if (!*((_BYTE *)v17 + 3))
  {
    *((_BYTE *)v17 + 3) = 1;
    *(_OWORD *)(v17 + 4) = v20;
    goto LABEL_21;
  }

  ERR_put_error(16, 0, 257, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 317);
  uint64_t v18 = 47;
LABEL_25:
  uint64_t v14 = 0LL;
  *a2 = v18;
  return v14;
}

  return v5;
}

    uint64_t v23 = (uint64_t)v30;
    int v24 = v31;
    for (uint64_t i = v2; i; --i)
    {
      if (v24[v12])
      {
        lookup_precomp(v11, (uint64_t)v32, v23, (char)v24[v12]);
        if (v22)
        {
          ec_GFp_simple_point_copy((uint64_t)v10, (uint64_t)v32);
          uint64_t v22 = 0;
        }

        else
        {
          ec_GFp_mont_add(v11, (uint64_t)v10, (uint64_t)v10, (uint64_t)v32);
        }
      }

      v24 += 529;
      v23 += 1728LL;
    }

    --v12;
  }

  while (v12 < v29);
  if (v22) {
    goto LABEL_29;
  }
LABEL_30:
  BOOL v16 = 1LL;
  uint64_t v14 = v27;
  uint64_t v13 = v28;
LABEL_31:
  OPENSSL_free(v13);
  OPENSSL_free(v14);
  return v16;
}

uint64_t CBS_get_u16(unsigned __int16 **a1, _WORD *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  BOOL v3 = v2 >= 2;
  unint64_t v4 = v2 - 2;
  if (!v3) {
    return 0LL;
  }
  uint64_t v6 = (*a1)++;
  a1[1] = (unsigned __int16 *)v4;
  *a2 = bswap32(*v6) >> 16;
  return 1LL;
}

uint64_t CBS_get_bytes(uint64_t *a1, void *a2, unint64_t a3)
{
  unint64_t v3 = a1[1];
  BOOL v4 = v3 >= a3;
  unint64_t v5 = v3 - a3;
  if (!v4) {
    return 0LL;
  }
  uint64_t v7 = *a1;
  *a1 += a3;
  a1[1] = v5;
  *a2 = v7;
  a2[1] = a3;
  return 1LL;
}

BOOL bssl::SSLAEADContext::Open( bssl::SSLAEADContext *this, char **a2, char a3, __int16 a4, unint64_t a5, int a6, int a7, int a8, char *a9, unint64_t a10)
{
  uint64_t v11 = a9;
  size_t v12 = a10;
  __dst[5] = *MEMORY[0x1895F89C0];
  if (!*(void *)this)
  {
    *a2 = a9;
    a2[1] = (char *)a10;
    return 1LL;
  }

  char v17 = *((_BYTE *)this + 609);
  if ((v17 & 8) != 0)
  {
    unsigned int v19 = 0;
  }

  else
  {
    unint64_t v18 = bssl::SSLAEADContext::MaxOverhead(this);
    unsigned int v19 = a10 - v18;
    if (a10 < v18)
    {
      int v20 = 256;
LABEL_22:
      ERR_put_error(16, 0, 112, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", v20);
      return 0LL;
    }

    char v17 = *((_BYTE *)this + 609);
  }

  memset(&__dst[3], 170, 13);
  if ((v17 & 0x10) == 0)
  {
    void __dst[3] = bswap64(a5);
    LOBYTE(__dst[4]) = a3;
    BYTE1(__dst[4]) = HIBYTE(a4);
    BYTE2(__dst[4]) = a4;
    if ((v17 & 8) == 0) {
      *(_WORD *)((char *)&__dst[4] + 3) = bswap32(v19) >> 16;
    }
  }

  memset(__dst, 170, 24);
  size_t v22 = *((unsigned __int8 *)this + 604);
  int v23 = *((unsigned __int8 *)this + 604);
  if ((v17 & 4) != 0)
  {
    v22 -= *((unsigned __int8 *)this + 605);
    if (v22) {
      bzero(__dst, v22);
    }
  }

  else if (*((_BYTE *)this + 604))
  {
    memcpy(__dst, (char *)this + 592, *((unsigned __int8 *)this + 604));
  }

  else
  {
    size_t v22 = 0LL;
  }

  unint64_t v24 = *((unsigned __int8 *)this + 605);
  if ((v17 & 1) != 0)
  {
    size_t v12 = a10 - v24;
    if (a10 < v24)
    {
      int v20 = 283;
      goto LABEL_22;
    }

    if (*((_BYTE *)this + 605)) {
      memcpy((char *)__dst + v22, a9, *((unsigned __int8 *)this + 605));
    }
    uint64_t v11 = &a9[v24];
  }

  else
  {
    if ((_DWORD)v24 != 8) {
      bssl::SSLAEADContext::Open();
    }
    *(void *)((char *)__dst + v22) = bswap64(a5);
    unint64_t v24 = 8LL;
  }

  uint64_t v25 = v22 + v24;
  if ((v17 & 4) != 0)
  {
    if (v25 != v23) {
      bssl::SSLAEADContext::Open();
    }
    if (v23)
    {
      uint64_t v26 = (char *)this + 592;
      uint64_t v27 = __dst;
      size_t v28 = v22 + v24;
      do
      {
        char v29 = *v26++;
        *v27++ ^= v29;
        --v28;
      }

      while (v28);
    }
  }

  size_t v32 = 0xAAAAAAAAAAAAAAAALL;
  int v30 = EVP_AEAD_CTX_open((unsigned __int8 *)this + 8, v11, &v32, v12, (uint64_t)__dst, v25, v11, v12);
  BOOL result = v30 != 0;
  if (v30)
  {
    size_t v31 = v32;
    if (v12 < v32) {
      size_t v31 = v12;
    }
    *a2 = v11;
    a2[1] = (char *)v31;
  }

  return result;
}

void *bssl::tls_append_handshake_data(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v9 = *(void **)(v6 + 224);
  uint64_t v8 = (BUF_MEM **)(v6 + 224);
  BOOL result = v9;
  if (v9) {
    return (void *)(BUF_MEM_append(result, a2, a3) != 0);
  }
  int v10 = BUF_MEM_new();
  std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v8, v10);
  BOOL result = *(void **)(*(void *)(a1 + 48) + 224LL);
  if (result) {
    return (void *)(BUF_MEM_append(result, a2, a3) != 0);
  }
  return result;
}

_WORD *bssl::SSLBuffer::DiscardConsumed(_WORD *this)
{
  if (!this[6])
  {
    this[4] = this[5];
    this[6] = 0;
    this[7] = this[8];
  }

  return this;
}

uint64_t CBS_get_u24(uint64_t *a1, int *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = v2 - 3;
  if (v2 < 3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  int v6 = 0;
  uint64_t v7 = *a1;
  *a1 += 3LL;
  a1[1] = v3;
  do
    int v6 = *(unsigned __int8 *)(v7 + v5++) | (v6 << 8);
  while (v5 != 3);
  *a2 = v6;
  return 1LL;
}

uint64_t bssl::ssl_parse_server_hello(uint64_t a1, char *a2, uint64_t a3)
{
  if (*(_BYTE *)(a3 + 1) == 2)
  {
    *(_OWORD *)a1 = *(_OWORD *)(a3 + 24);
    __int128 v10 = *(_OWORD *)(a3 + 8);
    if (CBS_get_u16((unsigned __int16 **)&v10, (_WORD *)(a1 + 16))
      && CBS_get_bytes((uint64_t *)&v10, (void *)(a1 + 24), 0x20uLL)
      && CBS_get_u8_length_prefixed((unsigned __int8 **)&v10, (unint64_t *)(a1 + 40))
      && *(void *)(a1 + 48) <= 0x20uLL
      && CBS_get_u16((unsigned __int16 **)&v10, (_WORD *)(a1 + 56))
      && CBS_get_u8(&v10, (_BYTE *)(a1 + 58)))
    {
      *(void *)(a1 + 64) = 0LL;
      *(void *)(a1 + 72) = 0LL;
      uint64_t v5 = (unint64_t *)(a1 + 64);
      if (!*((void *)&v10 + 1)) {
        return 1LL;
      }
      int u16_length_prefixed = CBS_get_u16_length_prefixed((unsigned __int8 **)&v10, v5);
      int v7 = 756;
      if (u16_length_prefixed)
      {
        if (!*((void *)&v10 + 1)) {
          return 1LL;
        }
      }
    }

    else
    {
      int v7 = 746;
    }

    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", v7);
    uint64_t result = 0LL;
    char v9 = 50;
  }

  else
  {
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_client.cc", 734);
    uint64_t result = 0LL;
    char v9 = 10;
  }

  *a2 = v9;
  return result;
}

uint64_t CBS_get_u16_length_prefixed(unsigned __int8 **a1, unint64_t *a2)
{
  return cbs_get_length_prefixed(a1, a2, 2uLL);
}

uint64_t bssl::ssl_parse_extensions(__int128 *a1, char *a2, uint64_t *a3, uint64_t a4, int a5)
{
  char v5 = a5;
  uint64_t v9 = 8 * a4;
  if (a4)
  {
    uint64_t v10 = 8 * a4;
    uint64_t v11 = a3;
    do
    {
      uint64_t v12 = *v11;
      *(_BYTE *)(v12 + 3) = 0;
      *(void *)(v12 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(v12 + 16) = 0LL;
      if (*(_BYTE *)(v12 + 2)) {
        BOOL v13 = 1;
      }
      else {
        BOOL v13 = a5 == 0;
      }
      if (!v13) {
        bssl::ssl_parse_extensions();
      }
      ++v11;
      v10 -= 8LL;
    }

    while (v10);
  }

  __int128 v22 = *a1;
  uint64_t v14 = 1LL;
  if (!*((void *)&v22 + 1)) {
    return v14;
  }
  while (1)
  {
    __int16 v21 = -21846;
    *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_u16((unsigned __int16 **)&v22, &v21)
      || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v22, (unint64_t *)&v20))
    {
      ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 293);
      char v18 = 50;
      goto LABEL_25;
    }

    if (a4) {
      break;
    }
LABEL_17:
    if ((v5 & 1) == 0)
    {
      ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 310);
      char v18 = 110;
      goto LABEL_25;
    }

uint64_t bssl::SSLAEADContext::SetVersionIfNullCipher(uint64_t this, __int16 a2)
{
  if (!*(void *)this) {
    *(_WORD *)(this + 606) = a2;
  }
  return this;
}

uint64_t bssl::ssl_protocol_version(bssl *this, const ssl_st *a2)
{
  if ((*(_WORD *)(*((void *)this + 6) + 220LL) & 2) == 0) {
    bssl::ssl_protocol_version();
  }
  uint64_t result = *((unsigned __int16 *)this + 8);
  if ((result - 769) >= 4)
  {
    if ((_DWORD)result == 65277)
    {
      return 771LL;
    }

    else
    {
      if ((_DWORD)result != 65279) {
        bssl::ssl_protocol_version();
      }
      return 770LL;
    }
  }

  return result;
}

const char *bssl::tls13_client_handshake_state(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 24);
  else {
    return off_18A071240[v1];
  }
}

uint64_t bssl::tls13_client_handshake(bssl *this, ssl_st *a2)
{
  id v137 = (SSL_SESSION **)((char *)this + 1520);
  uint64_t v140 = (char *)this + 232;
  unsigned int v139 = (char *)this + 280;
  uint64_t v163 = *MEMORY[0x1895F89C0];
  unint64_t v3 = (ssl_credential_st **)((char *)this + 1504);
  __int128 v138 = (size_t **)((char *)this + 424);
  __int128 v132 = (size_t **)((char *)this + 464);
  v133 = (unint64_t **)((char *)this + 1472);
  char v135 = (_OWORD *)((char *)this + 472);
  v136 = (char *)this + 432;
  char v134 = (_OWORD *)((char *)this + 504);
  __int128 v129 = (char *)this + 184;
  uint64_t v130 = (char *)this + 136;
  char v131 = (void **)((char *)this + 536);
  while (2)
  {
    int v4 = *((_DWORD *)this + 6);
    uint64_t v5 = 1LL;
    switch(v4)
    {
      case 0:
        uint64_t v6 = *(void *)this;
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 2) == 0) {
          bssl::tls13_client_handshake();
        }
        *(void *)&__int128 v156 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v154 = v7;
        __int128 v155 = v7;
        if ((*((_BYTE *)this + 1585) & 8) == 0
          && !(*(unsigned int (**)(uint64_t))(*(void *)v6 + 112LL))(v6))
        {
          goto LABEL_241;
        }

        *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v149 = v8;
        __int128 v150 = v8;
        *(_OWORD *)&v147[16] = v8;
        __int128 v148 = v8;
        *(_OWORD *)uint64_t v147 = v8;
        *(_WORD *)&v147[16] = 0;
        WORD4(v149) = 0;
        BYTE10(v149) = 0;
        LOBYTE(v159[0]) = 50;
        cipher_by_value = SSL_get_cipher_by_value(WORD4(v149));
        uint64_t v10 = (uint64_t)cipher_by_value;
        if (!cipher_by_value
          || (unsigned int min_version = SSL_CIPHER_get_min_version(cipher_by_value),
              min_version > bssl::ssl_protocol_version((bssl *)v6, v12))
          || (unsigned int max_version = SSL_CIPHER_get_max_version(v10),
              max_version < bssl::ssl_protocol_version((bssl *)v6, v14))
          || (int protocol_id = SSL_CIPHER_get_protocol_id(v10),
              (bssl::ssl_tls13_cipher_meets_policy(protocol_id, *(_DWORD *)(*(void *)(v6 + 8) + 296LL)) & 1) == 0))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 207);
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        *((void *)this + 194) = v10;
        BOOL v20 = (void)v148 == 32LL
           && **(void **)&v147[24] == 0x11619AE574AD21CFLL
           && *(void *)(*(void *)&v147[24] + 8LL) == 0x91B8651E028C1DBELL
           && *(void *)(*(void *)&v147[24] + 16LL) == 0x5E8CBB7A1611A2C2LL
           && *(void *)(*(void *)&v147[24] + 24LL) == 0x9C33A8C8E2099E07LL;
        uint64_t v98 = (bssl *)bssl::ssl_protocol_version((bssl *)v6, v16);
        if (!bssl::SSLTranscript::InitHash(v138, v98, *((const ssl_cipher_st **)this + 194))
          || v20 && !bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v138))
        {
          goto LABEL_241;
        }

        if (*((void *)this + 193))
        {
          id v99 = (bssl *)bssl::ssl_protocol_version((bssl *)v6, a2);
          if (!bssl::SSLTranscript::InitHash(v132, v99, *((const ssl_cipher_st **)this + 194))
            || v20 && !bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v132))
          {
            goto LABEL_241;
          }
        }

        v151[0] = -86;
        uint64_t v100 = *((void *)this + 193);
        if (v100)
        {
          if (v151[0]) {
            int v101 = 1;
          }
          else {
            int v101 = 2;
          }
          *(_DWORD *)(*(void *)(v6 + 48) + 216LL) = v101;
        }

        if (!v20)
        {
          *((_DWORD *)this + 6) = 2;
          goto LABEL_264;
        }

        *(_OWORD *)&v151[1] = 0xAAAAAAAA0001002CLL;
        *(void *)&__int128 v152 = 0LL;
        unint64_t v144 = 0xAAAAAAAA00010033LL;
        uint64_t v145 = 0LL;
        uint64_t v146 = 0LL;
        __int128 v157 = 0xAAAAAAAA0001002BLL;
        int v158 = 0LL;
        unint64_t v141 = 0xAAAAAAAA00AAFE0DLL;
        if (v100) {
          char v102 = 1;
        }
        else {
          char v102 = *(_WORD *)(*((void *)this + 1) + 301LL) & 1;
        }
        BYTE2(v141) = v102;
        unint64_t v142 = 0LL;
        uint64_t v143 = 0LL;
        *(void *)&__int128 v160 = &v151[1];
        *((void *)&v160 + 1) = &v144;
        *(void *)&__int128 v161 = &v157;
        *((void *)&v161 + 1) = &v141;
        int v121 = BYTE3(v144);
        if (!v151[4] && !BYTE3(v144))
        {
          ERR_put_error(16, 0, 282, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 259);
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        if (v151[4])
        {
          *(void *)&__int128 v160 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v160 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v151[9], (unint64_t *)&v160)
            || (size_t v122 = *((void *)&v160 + 1)) == 0
            || (void)v152)
          {
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 268);
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 50);
            goto LABEL_241;
          }

          uint64_t v123 = (const void *)v160;
          memmove(*v131, v123, v122);
          int v121 = BYTE3(v144);
        }

        if (v121)
        {
          LOWORD(v160) = -21846;
          if (!CBS_get_u16(&v145, &v160) || v146)
          {
            ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 282);
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 50);
            goto LABEL_241;
          }

          if (!bssl::tls1_check_group_id((bssl **)this, (const ssl_st *)(unsigned __int16)v160))
          {
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
            ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 290);
            goto LABEL_241;
          }

          int v124 = (*(uint64_t (**)(void))(**((void **)this + 49) + 16LL))(*((void *)this + 49));
          unint64_t v125 = (unsigned __int16)v160;
          if (v124 == (unsigned __int16)v160
            || (uint64_t v126 = *((void *)this + 50)) != 0
            && (int v127 = (*(uint64_t (**)(uint64_t))(*(void *)v126 + 16LL))(v126),
                unint64_t v125 = (unsigned __int16)v160,
                v127 == (unsigned __int16)v160))
          {
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
            ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 299);
            goto LABEL_241;
          }

          if (!bssl::ssl_setup_key_shares(this, v125)) {
            goto LABEL_241;
          }
        }

        if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)&v154)
          || *(_DWORD *)(*(void *)(v6 + 48) + 216LL) == 1
          && !bssl::SSLTranscript::Update(v132, *((const void **)&v155 + 1), v156))
        {
          goto LABEL_241;
        }

        if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 40LL))(v6))
        {
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 323);
          goto LABEL_241;
        }

        (*(void (**)(uint64_t))(*(void *)v6 + 32LL))(v6);
        *(_WORD *)(*(void *)(v6 + 48) + 220LL) |= 0x2000u;
        uint64_t v5 = 1LL;
        *((_DWORD *)this + 6) = 1;
        if ((*((_BYTE *)this + 1585) & 4) == 0) {
          goto LABEL_265;
        }
        *(_DWORD *)(*(void *)(v6 + 48) + 256LL) = 8;
        int v38 = bssl::close_early_data((uint64_t)this, 0);
        goto LABEL_63;
      case 1:
        uint64_t v39 = *(void *)(*(void *)this + 48LL);
        if (*(_DWORD *)(v39 + 204)) {
          bssl::tls13_client_handshake();
        }
        if (*(_DWORD *)(v39 + 216) == 1 && !bssl::ssl_encrypt_client_hello((uint64_t)this, 0LL, 0LL)
          || !bssl::ssl_add_client_hello(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_241;
        }

        bssl::ssl_done_writing_client_hello(this, (bssl::SSL_HANDSHAKE *)a2);
        *((_DWORD *)this + 6) = 2;
        goto LABEL_71;
      case 2:
        uint64_t v6 = *(void *)this;
        *(void *)&__int128 v156 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v47 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v47 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v154 = v47;
        __int128 v155 = v47;
        *(void *)&__int128 v48 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v48 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v149 = v48;
        __int128 v150 = v48;
        *(_OWORD *)&v147[16] = v48;
        __int128 v148 = v48;
        *(_OWORD *)uint64_t v147 = v48;
        *(_WORD *)&v147[16] = 0;
        WORD4(v149) = 0;
        BYTE10(v149) = 0;
        LOBYTE(v159[0]) = 50;
        if ((void)v148 == 32LL)
        {
          BOOL v49 = **(void **)&v147[24] == 0x11619AE574AD21CFLL
             && *(void *)(*(void *)&v147[24] + 8LL) == 0x91B8651E028C1DBELL;
          BOOL v50 = v49 && *(void *)(*(void *)&v147[24] + 16LL) == 0x5E8CBB7A1611A2C2LL;
          if (v50 && *(void *)(*(void *)&v147[24] + 24LL) == 0x9C33A8C8E2099E07LL)
          {
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 10);
            ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 377);
            goto LABEL_241;
          }
        }

        int v52 = SSL_CIPHER_get_protocol_id(*((void *)this + 194));
        if (v52 != WORD4(v149))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 383);
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        uint64_t v53 = *(void *)(v6 + 48);
        if (*(_DWORD *)(v53 + 216) != 1) {
          goto LABEL_108;
        }
        if ((*(_WORD *)(v53 + 220) & 0x2000) == 0) {
          goto LABEL_107;
        }
        LOBYTE(v160) = -86;
        if ((bssl::check_ech_confirmation((uint64_t)this, (ssl_st *)&v160, (char *)v159, (uint64_t)v147) & 1) == 0)
        {
          int v96 = LOBYTE(v159[0]);
LABEL_240:
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, v96);
          goto LABEL_241;
        }

        if (!(_BYTE)v160)
        {
          ERR_put_error(16, 0, 321, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 397);
          int v96 = 47;
          goto LABEL_240;
        }

LABEL_107:
        __int16 v54 = (BUF_MEM *)*((void *)this + 58);
        *((void *)this + 5_Block_object_dispose(va, 8) = 0LL;
        std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)v138, v54);
        EVP_MD_CTX_move((uint64_t)v136, v135);
        *((_DWORD *)this + 94) = *((_DWORD *)this + 95);
        uint64_t v55 = *(void *)(v6 + 48);
        __int128 v56 = v134[1];
        *(_OWORD *)(v55 + 4_Block_object_dispose(va, 8) = *v134;
        *(_OWORD *)(v55 + 64) = v56;
        uint64_t v53 = *(void *)(v6 + 48);
LABEL_108:
        __int128 v57 = *(_OWORD *)(*(void *)&v147[24] + 16LL);
        *(_OWORD *)(v53 + 16) = **(_OWORD **)&v147[24];
        *(_OWORD *)(v53 + RAND_bytes(buf, 32) = v57;
        uint64_t v58 = *(void *)(v6 + 104);
        if (v58) {
          LOBYTE(v5_Block_object_dispose(va, 8) = *(_DWORD *)(*(void *)(v6 + 48) + 216LL) != 2;
        }
        __int128 v160 = 0xAAAAAAAA00010033LL;
        *(void *)&__int128 v161 = 0LL;
        *(void *)&v151[1] = 0xAAAAAAAA00AA0029LL;
        v151[3] = v58;
        *(void *)&v151[9] = 0LL;
        *(void *)&__int128 v152 = 0LL;
        unint64_t v144 = 0xAAAAAAAA0001002BLL;
        uint64_t v145 = 0LL;
        uint64_t v146 = 0LL;
        *(void *)&__int128 v157 = &v160;
        *((void *)&v157 + 1) = &v151[1];
        int v158 = &v144;
        LOWORD(v141) = -21846;
        if (!BYTE3(v144)
          || !CBS_get_u16(&v145, &v141)
          || v146
          || (unsigned __int16)v141 != *(unsigned __int16 *)(v6 + 16))
        {
          ERR_put_error(16, 0, 288, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 432);
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        LOBYTE(v159[0]) = 50;
        if (v151[4])
        {
          if ((bssl::ssl_ext_pre_shared_key_parse_serverhello((uint64_t)this, (char *)v159, (uint64_t)&v151[9]) & 1) == 0)
          {
LABEL_294:
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, LOBYTE(v159[0]));
            goto LABEL_241;
          }

          uint64_t v61 = *(void *)(v6 + 104);
          if (*(unsigned __int16 *)(v61 + 4) != *(unsigned __int16 *)(v6 + 16))
          {
            ERR_put_error(16, 0, 188, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 446);
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
            goto LABEL_241;
          }

          if (*(_DWORD *)(*(void *)(v61 + 200) + 36LL) != *(_DWORD *)(*((void *)this + 194) + 36LL))
          {
            ERR_put_error(16, 0, 268, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 452);
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
            goto LABEL_241;
          }

          if (!bssl::ssl_session_is_context_valid(this, (const bssl::SSL_HANDSHAKE *)v61, v60))
          {
            ERR_put_error(16, 0, 101, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 460);
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 47);
            goto LABEL_241;
          }

          *(_WORD *)(*(void *)(v6 + 48) + 220LL) |= 0x40u;
          *((_DWORD *)this + 396) |= 0x1000000u;
          bssl::SSL_SESSION_dup(*(bssl **)(v6 + 104), 0LL, &v157);
          __int16 v62 = (SSL_SESSION *)v157;
          *(void *)&__int128 v157 = 0LL;
          std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v137, v62);
          uint64_t v64 = (SSL_SESSION *)v157;
          *(void *)&__int128 v157 = 0LL;
          if (v64) {
            SSL_SESSION_free(v64);
          }
          if (!*v137)
          {
LABEL_271:
            bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 80);
LABEL_241:
            uint64_t v5 = 0LL;
            goto LABEL_265;
          }

          bssl::ssl_set_session((ssl_st **)v6, 0LL, v63);
          bssl::ssl_session_renew_timeout( (bssl *)v6,  (ssl_st *)*v137,  (ssl_session_st *)*(unsigned int *)(*(void *)(v6 + 128) + 308LL));
        }

        else if ((bssl::ssl_get_new_session(this, v59) & 1) == 0)
        {
          goto LABEL_271;
        }

        *(void *)(*((void *)this + 190) + 20std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM **)va, 0LL) = *((void *)this + 194);
        v103 = (bssl *)bssl::ssl_protocol_version((bssl *)v6, v65);
        handshake_digest = bssl::ssl_get_handshake_digest(v103, *((void *)this + 194), v104);
        EVP_MD_size(handshake_digest);
        if ((*(_WORD *)(*(void *)(v6 + 48) + 220LL) & 0x40) != 0) {
          v106 = (const ssl_st *)&(*v137)->key_arg[3];
        }
        else {
          v106 = (const ssl_st *)&bssl::kZeroes;
        }
        if (!BYTE3(v160))
        {
          ERR_put_error(16, 0, 258, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 499);
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, 109);
          goto LABEL_241;
        }

        __int128 v157 = 0uLL;
        LOBYTE(v159[0]) = 50;
        if ((bssl::ssl_ext_key_share_parse_serverhello((uint64_t)this, (uint64_t)&v157, (char *)v159, (uint64_t)&v160 + 8) & 1) != 0)
        {
          if (bssl::tls13_advance_key_schedule((uint64_t)this)
            && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&v154)
            && bssl::tls13_derive_handshake_secrets(this, v120)
            && ((*((_BYTE *)this + 1585) & 4) != 0 && !*(void *)(v6 + 168)
             || (bssl::tls13_set_traffic_key( v6,  (const ssl_session_st *)2,  1LL,  *((bssl **)this + 190),  v130,  *((void *)this + 4)) & 1) != 0)
            && (bssl::tls13_set_traffic_key( v6,  (const ssl_session_st *)2,  0LL,  *((bssl **)this + 190),  v129,  *((void *)this + 4)) & 1) != 0)
          {
            (*(void (**)(uint64_t))(*(void *)v6 + 32LL))(v6);
            *((_DWORD *)this + 6) = 3;
            goto LABEL_299;
          }
        }

        else
        {
          bssl::ssl_send_alert((bssl *)v6, (ssl_st *)2, LOBYTE(v159[0]));
        }

        uint64_t v5 = 0LL;
LABEL_299:
        OPENSSL_free((void *)v157);
        goto LABEL_265;
      case 3:
        char v29 = *(bssl **)this;
        *(void *)&__int128 v148 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v30 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uint64_t v147 = v30;
        *(_OWORD *)&v147[16] = v30;
        __int128 v154 = *(_OWORD *)&v147[8];
        *(void *)&__int128 v160 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v160 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v154, (unint64_t *)&v160)
          || *((void *)&v154 + 1))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 555);
          bssl::ssl_send_alert(v29, (ssl_st *)2, 50);
          goto LABEL_241;
        }

        if ((bssl::ssl_parse_serverhello_tlsext((uint64_t)this, &v160) & 1) == 0)
        {
          ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 561);
          goto LABEL_241;
        }

        uint64_t v31 = *((void *)v29 + 6);
        __int16 v32 = *(_WORD *)(v31 + 220);
        if ((v32 & 0x400) == 0) {
          goto LABEL_54;
        }
        if ((v32 & 0x40) == 0) {
          bssl::tls13_client_handshake();
        }
        if (*(_DWORD *)(v31 + 216) == 2) {
          bssl::tls13_client_handshake();
        }
        uint64_t v94 = *((void *)this + 191);
        uint64_t v95 = *((void *)this + 190);
        if (*(void *)(v94 + 200) != *(void *)(v95 + 200))
        {
          ERR_put_error(16, 0, 304, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 574);
          bssl::ssl_send_alert(v29, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        size_t v97 = *(void *)(v94 + 400);
        if (v97 != *(void *)(v31 + 504) || memcmp(*(const void **)(v94 + 392), *(const void **)(v31 + 496), v97))
        {
          ERR_put_error(16, 0, 277, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 580);
          bssl::ssl_send_alert(v29, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        if ((*((_BYTE *)this + 1587) & 2) != 0 || (*(_BYTE *)(v95 + 440) & 0x40) != 0)
        {
          ERR_put_error(16, 0, 279, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 588);
          bssl::ssl_send_alert(v29, (ssl_st *)2, 47);
          goto LABEL_241;
        }

        *(_BYTE *)(v95 + 440) = *(_BYTE *)(v94 + 440) & 0x40 | *(_BYTE *)(v95 + 440) & 0xBF;
        int v107 = (void **)(*((void *)this + 190) + 408LL);
        uint64_t v108 = *((void *)this + 191);
        int v110 = *(const void **)(v108 + 408);
        unint64_t v109 = *(void *)(v108 + 416);
        int v111 = bssl::Array<unsigned char>::Init((uint64_t)v107, v109);
        char v112 = v111 ^ 1;
        if (!v109) {
          char v112 = 1;
        }
        if ((v112 & 1) == 0) {
          memmove(*v107, v110, v109);
        }
        if (!v111) {
          goto LABEL_216;
        }
        __int16 v113 = (void **)(*((void *)this + 190) + 424LL);
        uint64_t v114 = *((void *)this + 191);
        v116 = *(const void **)(v114 + 424);
        unint64_t v115 = *(void *)(v114 + 432);
        int v117 = bssl::Array<unsigned char>::Init((uint64_t)v113, v115);
        char v118 = v117 ^ 1;
        if (!v115) {
          char v118 = 1;
        }
        if ((v118 & 1) == 0) {
          memmove(*v113, v116, v115);
        }
        if (!v117) {
          goto LABEL_216;
        }
        uint64_t v31 = *((void *)v29 + 6);
LABEL_54:
        p_sid_ctx_length = (void **)&(*v137)[1].sid_ctx_length;
        uint32_t v34 = *(const void **)(v31 + 496);
        unint64_t v35 = *(void *)(v31 + 504);
        char v36 = bssl::Array<unsigned char>::Init((uint64_t)p_sid_ctx_length, v35);
        char v37 = v36 ^ 1;
        if (!v35) {
          char v37 = 1;
        }
        if ((v37 & 1) == 0) {
          memmove(*p_sid_ctx_length, v34, v35);
        }
        if ((v36 & 1) == 0) {
          goto LABEL_216;
        }
        (*(void (**)(bssl *))(*(void *)v29 + 32LL))(v29);
        *((_DWORD *)this + 6) = 4;
        if ((*((_BYTE *)this + 1585) & 4) == 0 || (*(_WORD *)(*((void *)v29 + 6) + 220LL) & 0x400) != 0) {
          goto LABEL_264;
        }
        int v38 = bssl::close_early_data((uint64_t)this, 2);
LABEL_63:
        if (v38) {
          uint64_t v5 = 13LL;
        }
        else {
          uint64_t v5 = 0LL;
        }
        goto LABEL_265;
      case 4:
        char v29 = *(bssl **)this;
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x40) != 0)
        {
          if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x400) != 0
            || !*(_BYTE *)(*((void *)v29 + 15) + 496LL))
          {
            int v27 = 8;
          }

          else
          {
            int v27 = 7;
          }

LABEL_263:
          *((_DWORD *)this + 6) = v27;
LABEL_264:
          uint64_t v5 = 1LL;
          goto LABEL_265;
        }

        *(void *)&__int128 v148 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v69 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v69 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uint64_t v147 = v69;
        *(_OWORD *)&v147[16] = v69;
        if (!(*(unsigned int (**)(bssl *, _BYTE *))(*(void *)v29 + 24LL))(v29, v147))
        {
LABEL_153:
          uint64_t v5 = 3LL;
          goto LABEL_265;
        }

        if (v147[1] != 13) {
          goto LABEL_262;
        }
        __int128 v154 = 0xAAAAAAAA0001000DLL;
        *(void *)&__int128 v155 = 0LL;
        __int128 v160 = 0xAAAAAAAA0001002FLL;
        *(void *)&__int128 v161 = 0LL;
        *(_OWORD *)&v151[1] = *(_OWORD *)&v147[8];
        unint64_t v144 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v145 = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v157 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v157 + 1) = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v141 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v142 = 0xAAAAAAAAAAAAAAAALL;
        v151[0] = 50;
        if (!CBS_get_u8_length_prefixed((unsigned __int8 **)&v151[1], &v144)
          || v145
          || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v151[1], (unint64_t *)&v157)
          || *(void *)&v151[9]
          || ((v159[0] = (unint64_t *)&v154,
               v159[1] = (unint64_t *)&v160,
               int v70 = bssl::ssl_parse_extensions(&v157, v151, (uint64_t *)v159, 2LL, 1),
               BYTE3(v154))
            ? (int v71 = v70)
            : (int v71 = 0),
              v71 != 1
           || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v154 + 1, &v141)
           || (bssl::tls1_parse_peer_sigalgs((bssl **)this, (ssl_st *)&v141) & 1) == 0))
        {
          bssl::ssl_send_alert(v29, (ssl_st *)2, v151[0]);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 664);
          goto LABEL_241;
        }

        if (BYTE3(v160))
        {
          bssl::ssl_parse_client_CA_list((uint64_t)v29, v151, (unsigned __int8 **)&v160 + 1, v159);
          uint64_t v72 = v159[0];
          v159[0] = 0LL;
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v133, v72);
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v159, 0LL);
          if (!*v133)
          {
            bssl::ssl_send_alert(v29, (ssl_st *)2, v151[0]);
            goto LABEL_241;
          }
        }

        else
        {
          __int16 v119 = OPENSSL_sk_new_null();
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v133, v119);
          if (!*v133)
          {
LABEL_216:
            bssl::ssl_send_alert(v29, (ssl_st *)2, 80);
            goto LABEL_241;
          }
        }

        *((_DWORD *)this + 396) |= 0x20u;
        (*(void (**)(bssl *))(*(void *)(*((void *)v29 + 15) + 16LL) + 80LL))(this);
        if (bssl::ssl_hash_message((uint64_t)this, (uint64_t)v147))
        {
          (*(void (**)(bssl *))(*(void *)v29 + 32LL))(v29);
LABEL_262:
          int v27 = 5;
          goto LABEL_263;
        }

        goto LABEL_241;
      case 5:
        int v42 = *(bssl **)this;
        *(void *)&__int128 v148 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v43 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uint64_t v147 = v43;
        *(_OWORD *)&v147[16] = v43;
        if (v147[1] != 25 && !bssl::ssl_check_message_type(v42, (uint64_t)v147, 11)
          || !bssl::tls13_process_certificate((EVP_PKEY **)this, (uint64_t)v147, 0)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)v147))
        {
          goto LABEL_241;
        }

        (*(void (**)(bssl *))(*(void *)v42 + 32LL))(v42);
        int v27 = 6;
        goto LABEL_263;
      case 6:
        uint64_t v44 = *(bssl **)this;
        *(void *)&__int128 v148 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v45 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v45 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uint64_t v147 = v45;
        *(_OWORD *)&v147[16] = v45;
        int v46 = bssl::ssl_verify_peer_cert(this, (bssl::SSL_HANDSHAKE *)a2);
        if (v46 == 1) {
          goto LABEL_241;
        }
        if (v46 == 2)
        {
          uint64_t v5 = 16LL;
          int v41 = 6;
          goto LABEL_156;
        }

        if (!bssl::ssl_check_message_type(v44, (uint64_t)v147, 15)
          || !bssl::tls13_process_certificate_verify((uint64_t)this, (uint64_t)v147)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)v147))
        {
          goto LABEL_241;
        }

        (*(void (**)(bssl *))(*(void *)v44 + 32LL))(v44);
        uint64_t v5 = 1LL;
        int v41 = 8;
        goto LABEL_156;
      case 7:
        int v40 = bssl::ssl_reverify_peer_cert((bssl **)this, (bssl::SSL_HANDSHAKE *)1);
        if (v40 == 1) {
          goto LABEL_241;
        }
        if (v40 == 2) {
          int v41 = 7;
        }
        else {
          int v41 = 8;
        }
        if (v40 == 2) {
          uint64_t v5 = 16LL;
        }
        else {
          uint64_t v5 = 1LL;
        }
        goto LABEL_156;
      case 8:
        int v67 = *(bssl **)this;
        *(void *)&__int128 v148 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v68 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uint64_t v147 = v68;
        *(_OWORD *)&v147[16] = v68;
        bssl::SSLTranscript::DigestLen((bssl::SSLTranscript *)v138);
        if (!bssl::tls13_advance_key_schedule((uint64_t)this)
          || !bssl::tls13_derive_application_secrets(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_241;
        }

        if ((*(unsigned int (**)(bssl *))(*(void *)v67 + 40LL))(v67))
        {
          bssl::ssl_send_alert(v67, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 776);
          goto LABEL_241;
        }

        (*(void (**)(bssl *))(*(void *)v67 + 32LL))(v67);
        int v27 = 9;
        goto LABEL_263;
      case 9:
        size_t v28 = *(void **)this;
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x400) == 0) {
          goto LABEL_47;
        }
        if (v28[21]) {
          goto LABEL_46;
        }
        *(void *)&__int128 v92 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v92 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v147[16] = v92;
        __int128 v148 = v92;
        *(_OWORD *)uint64_t v147 = v92;
        CBB_zero(v147);
        *(void *)&__int128 v93 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v93 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v155 = v93;
        __int128 v156 = v93;
        __int128 v154 = v93;
        if (!(*(unsigned int (**)(void *, _BYTE *, __int128 *, uint64_t))(*v28 + 88LL))( v28,  v147,  &v154,  5LL)
          || (bssl::ssl_add_message_cbb((uint64_t)v28, (uint64_t)v147) & 1) == 0)
        {
          goto LABEL_196;
        }

        CBB_cleanup((uint64_t)v147);
LABEL_46:
LABEL_47:
        int v27 = 10;
        goto LABEL_263;
      case 10:
        if ((*(_BYTE *)(*((void *)this + 190) + 440LL) & 0x40) == 0) {
          goto LABEL_43;
        }
        uint64_t v23 = *(void *)this;
        if ((*(_WORD *)(*(void *)(*(void *)this + 48LL) + 220LL) & 0x400) != 0) {
          goto LABEL_43;
        }
        *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v147[16] = v24;
        __int128 v148 = v24;
        *(_OWORD *)uint64_t v147 = v24;
        CBB_zero(v147);
        *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v155 = v25;
        __int128 v156 = v25;
        __int128 v154 = v25;
        __int128 v161 = v25;
        __int128 v162 = v25;
        __int128 v160 = v25;
        __int128 v152 = v25;
        __int128 v153 = v25;
        *(_OWORD *)&v151[1] = v25;
        if ((*(_WORD *)(*((void *)this + 1) + 301LL) & 0x2000) != 0) {
          unsigned int v26 = 17613;
        }
        else {
          unsigned int v26 = 17513;
        }
        if (!(*(unsigned int (**)(uint64_t, _BYTE *, __int128 *, uint64_t))(*(void *)v23 + 88LL))( v23,  v147,  &v154,  8LL)
          || !CBB_add_u16_length_prefixed((uint64_t *)&v154, (uint64_t)&v160)
          || !CBB_add_u16((uint64_t)&v160, v26)
          || !CBB_add_u16_length_prefixed((uint64_t *)&v160, (uint64_t)&v151[1])
          || !CBB_add_bytes( (uint64_t)&v151[1],  *(const void **)&(*v137)[1].sid_ctx[12],  *(void *)&(*v137)[1].sid_ctx[20])
          || (bssl::ssl_add_message_cbb(v23, (uint64_t)v147) & 1) == 0)
        {
          goto LABEL_196;
        }

        CBB_cleanup((uint64_t)v147);
LABEL_43:
        int v27 = 11;
        goto LABEL_263;
      case 11:
        if ((*((_BYTE *)this + 1584) & 0x20) == 0) {
          goto LABEL_155;
        }
        BOOL v77 = *(bssl **)this;
        if (*(_DWORD *)(*(void *)(*(void *)this + 48LL) + 216LL) == 2)
        {
          SSL_certs_clear(*(void *)this);
LABEL_171:
          *(void *)uint64_t v147 = 0LL;
          *(void *)&v147[8] = 0LL;
          if ((bssl::ssl_get_credential_list(this, (void **)v147) & 1) == 0) {
            goto LABEL_208;
          }
          if (!*(void *)&v147[8]) {
            goto LABEL_205;
          }
          __int128 v85 = *(ssl_credential_st ***)v147;
          uint64_t v86 = 8LL * *(void *)&v147[8];
          while (1)
          {
            v87 = *v85;
            ERR_clear_error();
            LOWORD(v154) = -21846;
            int v89 = *((_DWORD *)v87 + 1);
            if (v89)
            {
              if (v89 != 2)
              {
                int v90 = 852;
                int v91 = 228;
LABEL_182:
                ERR_put_error(16, 0, v91, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", v90);
                goto LABEL_183;
              }

              if ((*((_BYTE *)this + 1586) & 0x40) == 0 || *((_BYTE *)this + 731) != 2)
              {
                int v90 = 846;
                int v91 = 253;
                goto LABEL_182;
              }
            }

            if (bssl::tls1_choose_signature_algorithm( this,  (EVP_PKEY **)v87,  (const ssl_credential_st *)&v154,  v88))
            {
              SSL_CREDENTIAL_up_ref(v87);
              std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100](v3, v87);
              *((_WORD *)this + 797) = v154;
LABEL_204:
              if (*v3)
              {
LABEL_205:
                if (bssl::tls13_add_certificate(this, v81, v82, v83, v84))
                {
                  *((_DWORD *)this + 6) = 12;
                  uint64_t v5 = 1LL;
LABEL_209:
                  OPENSSL_free(*(void **)v147);
                  goto LABEL_265;
                }
              }

              else
              {
                bssl::ssl_send_alert(v77, (ssl_st *)2, 40);
              }

LABEL_208:
              uint64_t v5 = 0LL;
              goto LABEL_209;
            }

LABEL_183:
            ++v85;
            v86 -= 8LL;
            if (!v86) {
              goto LABEL_204;
            }
          }
        }

        uint64_t v78 = *(void *)(*((void *)this + 1) + 32LL);
        id v79 = *(uint64_t (**)(void, void))(v78 + 64);
        if (!v79) {
          goto LABEL_171;
        }
        int v80 = v79(*(void *)this, *(void *)(v78 + 72));
        if (!v80)
        {
          bssl::ssl_send_alert(v77, (ssl_st *)2, 80);
          ERR_put_error(16, 0, 126, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 878);
          goto LABEL_241;
        }

        if ((v80 & 0x80000000) == 0) {
          goto LABEL_171;
        }
        *((_DWORD *)this + 6) = 11;
        uint64_t v5 = 8LL;
LABEL_265:
        if (*((_DWORD *)this + 6) != v4) {
          bssl::ssl_do_info_callback(*(void *)this, (const ssl_st *)0x1001);
        }
        if ((_DWORD)v5 == 1) {
          continue;
        }
        return v5;
      case 12:
        if (*v3 && (int v66 = bssl::tls13_add_certificate_verify(this, (bssl::SSL_HANDSHAKE *)a2)) != 0)
        {
          if (v66 == 2) {
            goto LABEL_241;
          }
          if (v66 != 1) {
            bssl::tls13_client_handshake();
          }
          uint64_t v5 = 9LL;
          int v41 = 12;
        }

        else
        {
LABEL_155:
          int v41 = 13;
        }

LABEL_156:
        *((_DWORD *)this + 6) = v41;
        goto LABEL_265;
      case 13:
        uint64_t v21 = *(void *)this;
        int v22 = *((_DWORD *)this + 396);
        *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v22 | 0x1000000;
        if ((v22 & 0x2000000) == 0) {
          goto LABEL_26;
        }
        *(void *)&__int128 v73 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v73 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v147[16] = v73;
        __int128 v148 = v73;
        *(_OWORD *)uint64_t v147 = v73;
        CBB_zero(v147);
        *(void *)&__int128 v74 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v155 = v74;
        __int128 v156 = v74;
        __int128 v154 = v74;
        if (!(*(unsigned int (**)(uint64_t, _BYTE *, __int128 *, uint64_t))(*(void *)v21 + 88LL))( v21,  v147,  &v154,  203LL)
          || !bssl::tls1_write_channel_id((uint64_t)this, (uint64_t *)&v154, v75, v76)
          || (bssl::ssl_add_message_cbb(v21, (uint64_t)v147) & 1) == 0)
        {
LABEL_196:
          CBB_cleanup((uint64_t)v147);
          goto LABEL_241;
        }

        CBB_cleanup((uint64_t)v147);
LABEL_26:
        if (!bssl::tls13_add_finished((bssl **)this, (bssl::SSL_HANDSHAKE *)a2)
          || !bssl::tls13_set_traffic_key( v21,  (const ssl_session_st *)3,  1LL,  *((bssl **)this + 190),  v140,  *((void *)this + 4))
          || !bssl::tls13_set_traffic_key( v21,  (const ssl_session_st *)3,  0LL,  *((bssl **)this + 190),  v139,  *((void *)this + 4))
          || !bssl::tls13_derive_resumption_secret(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_241;
        }

        *((_DWORD *)this + 6) = 14;
LABEL_71:
        uint64_t v5 = 4LL;
        goto LABEL_265;
      case 14:
        return v5;
      default:
        goto LABEL_241;
    }
  }

void sub_18757CB84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35)
{
}

uint64_t bssl::tls_add_change_cipher_spec(bssl *this, ssl_st *a2)
{
  if (!bssl::tls_flush_pending_hs_data(this, a2)
    || !*((void *)this + 21)
    && !bssl::add_record_to_flight( this,  (ssl_st *)0x14,  (unint64_t)&bssl::tls_add_change_cipher_spec(ssl_st *)::kChangeCipherSpec,  (const unsigned __int8 *)1))
  {
    return 0LL;
  }

  uint64_t v3 = 1LL;
  bssl::ssl_do_msg_callback( (uint64_t)this,  1LL,  20LL,  (uint64_t)&bssl::tls_add_change_cipher_spec(ssl_st *)::kChangeCipherSpec,  1LL);
  return v3;
}

uint64_t bssl::SSLAEADContext::ProtocolVersion(bssl::SSLAEADContext *this)
{
  unsigned __int16 v2 = -21846;
  return v2;
}

uint64_t bssl::ssl_protocol_version_from_wire(bssl *this, unsigned __int16 *a2)
{
  if ((_DWORD)a2 == 65277)
  {
    LOWORD(a2) = 771;
    goto LABEL_6;
  }

  if ((_DWORD)a2 == 65279)
  {
    LOWORD(a2) = 770;
LABEL_6:
    *(_WORD *)this = (_WORD)a2;
    return 1LL;
  }

  return 0LL;
}

uint64_t bssl::parse_server_hello_tls13(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t result = bssl::ssl_parse_server_hello(a2, a3, a4);
  if ((_DWORD)result)
  {
    if (*(_WORD *)(a2 + 16) == 771
      && !*(_BYTE *)(a2 + 58)
      && CBS_mem_equal(a2 + 40, (char *)(a1 + 1597), *(unsigned __int8 *)(a1 + 1629))
      && *(void *)(a2 + 72))
    {
      return 1LL;
    }

    else
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 120);
      uint64_t result = 0LL;
      *a3 = 50;
    }
  }

  return result;
}

BOOL CBS_mem_equal(uint64_t a1, char *a2, uint64_t a3)
{
  return *(void *)(a1 + 8) == a3 && CRYPTO_memcmp(*(char **)a1, a2, a3) == 0;
}

uint64_t CRYPTO_memcmp(char *a1, char *a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  unsigned __int8 v3 = 0;
  do
  {
    char v5 = *a1++;
    char v4 = v5;
    char v6 = *a2++;
    v3 |= v6 ^ v4;
    --a3;
  }

  while (a3);
  return v3;
}

uint64_t bssl::SSLTranscript::InitHash(size_t **this, bssl *a2, const ssl_cipher_st *a3)
{
  handshake_digest = bssl::ssl_get_handshake_digest(a2, (uint64_t)a3, a3);
  if (EVP_MD_CTX_md((const EVP_MD_CTX *)(this + 1)) == handshake_digest) {
    return 1LL;
  }
  uint64_t result = EVP_DigestInit_ex((EVP_MD_CTX *)(this + 1), handshake_digest, 0LL);
  if ((_DWORD)result) {
    return EVP_DigestUpdate((EVP_MD_CTX *)(this + 1), (const void *)(*this)[1], **this) != 0;
  }
  return result;
}

const EVP_MD *bssl::ssl_get_handshake_digest(bssl *this, uint64_t a2, const ssl_cipher_st *a3)
{
  int v3 = *(_DWORD *)(a2 + 36);
  if (v3 == 4) {
    return EVP_sha384();
  }
  if (v3 == 2) {
    return EVP_sha256();
  }
  if (v3 != 1) {
    bssl::ssl_get_handshake_digest();
  }
  return (const EVP_MD *)EVP_md5_sha1();
}

const EVP_MD *EVP_sha384(void)
{
  return (const EVP_MD *)&EVP_sha384_storage;
}

uint64_t CRYPTO_once(pthread_once_t *a1, void (*a2)(void))
{
  uint64_t result = pthread_once(a1, a2);
  if ((_DWORD)result) {
    abort();
  }
  return result;
}

int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
{
  if (ctx->digest == type) {
    goto LABEL_5;
  }
  unint64_t final_high = HIDWORD(type->final);
  if (!(_DWORD)final_high) {
    EVP_DigestInit_ex_cold_2();
  }
  char v6 = (ENGINE *)OPENSSL_malloc(final_high);
  if (v6)
  {
    __int128 v7 = v6;
    OPENSSL_free((void *)ctx->engine);
    ctx->digest = type;
    ctx->engine = v7;
LABEL_5:
    if (ctx->flags && !ctx->md_data) {
      EVP_DigestInit_ex_cold_1();
    }
    ((void (*)(EVP_MD_CTX *))type->flags)(ctx);
    LODWORD(v6) = 1;
  }

  return (int)v6;
}

uint64_t sha384_init(uint64_t a1)
{
  return digest_init(*(void *)(a1 + 8));
}

uint64_t digest_init(uint64_t a1)
{
  if (!a1) {
    digest_init_cold_1();
  }
  uint64_t result = CCDigestInit();
  if ((_DWORD)result) {
    digest_init_cold_2();
  }
  return result;
}

int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt)
{
  return 1;
}

uint64_t digest_update_wrapper(uint64_t a1)
{
  return digest_update(*(void *)(a1 + 8));
}

uint64_t digest_update(uint64_t a1)
{
  if (!a1) {
    digest_update_cold_1();
  }
  uint64_t result = CCDigestUpdate();
  if ((_DWORD)result) {
    digest_update_cold_2();
  }
  return result;
}

uint64_t bssl::check_ech_confirmation(uint64_t a1, ssl_st *a2, char *a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (*(void *)(a4 + 32) != 32LL) {
    goto LABEL_12;
  }
  __int128 v8 = *(uint64_t **)(a4 + 24);
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  uint64_t v12 = v8[2];
  uint64_t v11 = v8[3];
  BOOL v13 = v9 == 0x11619AE574AD21CFLL && v10 == 0x91B8651E028C1DBELL;
  BOOL v14 = v13 && v12 == 0x5E8CBB7A1611A2C2LL;
  if (v14 && v11 == 0x9C33A8C8E2099E07LL)
  {
    uint64_t v24 = 0LL;
    unint64_t v23 = 0xAAAAAAAA0001FE0DLL;
    uint64_t v25 = 0LL;
    int v22 = &v23;
    if (!BYTE3(v23)) {
      goto LABEL_22;
    }
    if (v25 != 8)
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 148);
      BOOL v19 = 0LL;
      char v20 = 50;
      goto LABEL_17;
    }

    unint64_t v17 = v24 - *(void *)a4;
    int v18 = 1;
  }

  else
  {
LABEL_12:
    unint64_t v17 = bssl::ssl_ech_confirmation_signal_hello_offset(*(unsigned __int8 ***)a1, a2);
    int v18 = 0;
  }

  if (!*(void *)(a1 + 1544))
  {
LABEL_22:
    LOBYTE(a2->version) = 0;
    return 1LL;
  }

  unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  BOOL v19 = bssl::ssl_ech_accept_confirmation( a1,  (int)&v23,  8LL,  a1 + 504,  32,  (bssl::SSLTranscript *)(a1 + 464),  v18,  v16,  *(char **)a4,  *(void *)(a4 + 8),  v17);
  if (!v19)
  {
    char v20 = 80;
LABEL_17:
    *a3 = v20;
    return v19;
  }

  LOBYTE(a2->version) = CRYPTO_memcmp((char *)(*(void *)a4 + v17), (char *)&v23, 8LL) == 0;
  return v19;
}

uint64_t bssl::ssl_ech_confirmation_signal_hello_offset(unsigned __int8 **this, const ssl_st *a2)
{
  else {
    return 30LL;
  }
}

uint64_t bssl::ssl_get_new_session(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2 = *(void *)this;
  if ((*(_BYTE *)(*(void *)this + 149LL) & 2) != 0)
  {
    ERR_put_error(16, 0, 209, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_session.cc", 358);
    return 0LL;
  }

  v18[0] = *(void **)(*(void *)(v2 + 120) + 16LL);
  uint64_t result = (uint64_t)bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(v18);
  uint64_t v19 = result;
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  char v6 = *(_BYTE *)(result + 440) & 0xEF | (16 * (*(_BYTE *)(v2 + 180) & 1));
  *(_BYTE *)(result + 440) = v6;
  *(_WORD *)(result + 4) = *(_WORD *)(v2 + 16);
  *(_BYTE *)(result + 440) = v6 & 0xDF | (32 * (*(void *)(v2 + 168) != 0LL));
  v18[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  v18[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time(v2, (uint64_t)v18);
  *(void **)(v5 + CBB_cleanup(v1 - 192) = v18[0];
  unsigned int v8 = bssl::ssl_protocol_version((bssl *)v2, v7);
  uint64_t v9 = *(void *)(v2 + 128);
  if (v8 < 0x304)
  {
    int v10 = *(_DWORD *)(v9 + 304);
    int v11 = v10;
  }

  else
  {
    int v10 = *(_DWORD *)(v9 + 308);
    int v11 = 604800;
  }

  *(_DWORD *)(v5 + 184) = v10;
  *(_DWORD *)(v5 + 18_Block_object_dispose(va, 8) = v11;
  uint64_t v12 = *(void *)(*((void *)this + 1) + 32LL);
  size_t v13 = *(unsigned __int8 *)(v12 + 88);
  if (v13 >= 0x21)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_session.cc", 390);
    uint64_t v19 = 0LL;
    bssl::RefCounted<ssl_session_st>::DecRefInternal((ssl_session_st *)v5);
    return 0LL;
  }

  if (*(_BYTE *)(v12 + 88))
  {
    memcpy((void *)(v5 + 93), (const void *)(v12 + 89), v13);
    char v14 = *(_BYTE *)(*(void *)(*((void *)this + 1) + 32LL) + 88LL);
  }

  else
  {
    char v14 = 0;
  }

  *(_BYTE *)(v5 + 92) = v14;
  char v15 = *(_BYTE *)(v5 + 440);
  *(void *)(v5 + 176) = 65LL;
  *(_BYTE *)(v5 + 440) = v15 & 0x7B | 4;
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]( (SSL_SESSION **)this + 190,  (SSL_SESSION *)v5);
  uint64_t v17 = *(void *)(v2 + 104);
  int v16 = (SSL_SESSION **)(v2 + 104);
  if (v17) {
    std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v16, 0LL);
  }
  return 1LL;
}

void sub_18757D3C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(void **a1)
{
  uint64_t result = OPENSSL_malloc(0x1D0uLL);
  if (result) {
    return (void *)ssl_session_st::ssl_session_st((uint64_t)result, *a1, v3);
  }
  return result;
}

uint64_t ssl_session_st::ssl_session_st(uint64_t a1, void *a2, CRYPTO_EX_DATA *a3)
{
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_OWORD *)(a1 + 109) = 0u;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + CBB_cleanup(v1 - 144) = a2;
  *(void *)(a1 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 176) = 65LL;
  *(int32x2_t *)(a1 + 184) = vdup_n_s32(0x1C20u);
  *(_DWORD *)(a1 + 372) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 380) = 0;
  *(void *)(a1 + CBB_cleanup(v1 - 192) = 0LL;
  *(void *)(a1 + 200) = 0LL;
  *(_OWORD *)(a1 + 2RAND_bytes(buf, 32) = 0u;
  *(_OWORD *)(a1 + 24_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array(v16 + 280) = 0u;
  *(_OWORD *)(a1 + 2bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 353) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_BYTE *)(a1 + 440) &= 0x80u;
  *(void *)(a1 + 44_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 456) = 0LL;
  *(_DWORD *)(a1 + 376) = 0;
  CRYPTO_new_ex_data(a1 + 208, a2, a3);
  *(void *)(a1 + CBB_cleanup(v1 - 192) = time(0LL);
  return a1;
}

void sub_18757D50C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
}

uint64_t bssl::ssl_get_current_time(uint64_t a1, uint64_t a2)
{
  return bssl::ssl_ctx_get_current_time(*(void *)(a1 + 120), a2);
}

uint64_t bssl::ssl_ctx_get_current_time(uint64_t a1, uint64_t a2)
{
  int v3 = *(uint64_t (**)(void, timeval *))(a1 + 768);
  if (v3)
  {
    v6.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&v6.tv_usec = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = v3(0LL, &v6);
    __darwin_time_t tv_sec = v6.tv_sec;
    if (v6.tv_sec < 0) {
      bssl::ssl_ctx_get_current_time();
    }
  }

  else
  {
    v6.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&v6.tv_usec = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = gettimeofday(&v6, 0LL);
    __darwin_time_t tv_sec = v6.tv_sec;
    if (v6.tv_sec < 0) {
      bssl::ssl_ctx_get_current_time();
    }
  }

  *(void *)a2 = tv_sec;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v6.tv_usec;
  return result;
}

int EVP_MD_size(const EVP_MD *md)
{
  return md->pkey_type;
}

uint64_t bssl::tls13_init_key_schedule(uint64_t a1, const ssl_st *a2)
{
  int v3 = (size_t **)(a1 + 424);
  char v4 = (bssl::SSLTranscript *)bssl::ssl_protocol_version(*(bssl **)a1, a2);
  uint64_t result = bssl::init_key_schedule((bssl *)a1, v3, v4, *(ssl_cipher_st **)(a1 + 1552), v5);
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 1586) & 4) == 0) {
      bssl::SSLTranscript::FreeBuffer((BUF_MEM **)v3);
    }
    return bssl::hkdf_extract_to_secret(a1, (bssl::SSLTranscript *)v3);
  }

  return result;
}

uint64_t bssl::init_key_schedule( bssl *this, size_t **a2, bssl::SSLTranscript *a3, ssl_cipher_st *a4, const ssl_cipher_st *a5)
{
  uint64_t inited = bssl::SSLTranscript::InitHash(a2, a3, a4);
  if ((_DWORD)inited)
  {
    unint64_t v8 = bssl::SSLTranscript::DigestLen((bssl::SSLTranscript *)a2);
    bssl::SSL_HANDSHAKE::ResizeSecrets((uint64_t)this, v8);
    size_t v9 = *((void *)this + 4);
    if (v9) {
      bzero((char *)this + 40, v9);
    }
  }

  return inited;
}

uint64_t bssl::SSLTranscript::DigestLen(bssl::SSLTranscript *this)
{
  uint64_t v1 = EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
  return EVP_MD_size(v1);
}

uint64_t bssl::SSL_HANDSHAKE::ResizeSecrets(uint64_t this, unint64_t a2)
{
  if (a2 >= 0x31) {
    abort();
  }
  *(void *)(this + RAND_bytes(buf, 32) = a2;
  return this;
}

void bssl::SSLTranscript::FreeBuffer(BUF_MEM **this)
{
}

BOOL bssl::hkdf_extract_to_secret(uint64_t a1, bssl::SSLTranscript *this)
{
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  int v3 = a1 + 40;
  char v4 = (EVP_MD *)bssl::SSLTranscript::Digest(this);
  int v5 = HKDF_extract(v3, &v7, v4);
  if (v5 && v7 != *(void *)(a1 + 32)) {
    bssl::hkdf_extract_to_secret();
  }
  return v5 != 0;
}

const EVP_MD *bssl::SSLTranscript::Digest(bssl::SSLTranscript *this)
{
  return EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
}

uint64_t HKDF_extract(int a1, void *a2, EVP_MD *md)
{
  int v5 = EVP_MD_type(md);
  boringssl_crypto_hash_nid_to_cc_digest(v5);
  *a2 = EVP_MD_size(md);
  return 1LL;
}

int EVP_MD_type(const EVP_MD *md)
{
  return md->type;
}

uint64_t boringssl_crypto_hash_nid_to_cc_digest(int a1)
{
  switch(a1)
  {
    case 672:
      uint64_t result = ccsha256_di();
      break;
    case 673:
      uint64_t result = ccsha384_di();
      break;
    case 674:
      uint64_t result = ccsha512_di();
      break;
    case 675:
      uint64_t result = ccsha224_di();
      break;
    default:
      if (a1 == 64)
      {
        uint64_t result = ccsha1_di();
      }

      else if (a1 == 4)
      {
        uint64_t result = ccmd5_di();
      }

      else
      {
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
            boringssl_crypto_hash_nid_to_cc_digest_cold_1();
          }
        }

        uint64_t result = 0LL;
      }

      break;
  }

  return result;
}

uint64_t bssl::ssl_ext_key_share_parse_serverhello(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  if (CBS_get_u16((unsigned __int16 **)a4, v14)
    && CBS_get_u16_length_prefixed((unsigned __int8 **)a4, (unint64_t *)&v14[1])
    && !*(void *)(a4 + 8))
  {
    uint64_t v10 = *(void *)(a1 + 392);
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16LL))(v10);
    if (v11 != v14[0])
    {
      uint64_t v12 = *(void *)(a1 + 400);
      if (!v12 || (int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16LL))(v12), v13 != v14[0]))
      {
        *a3 = 47;
        ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2349);
        return 0LL;
      }

      uint64_t v10 = *(void *)(a1 + 400);
    }

    if (((*(uint64_t (**)(uint64_t, uint64_t, char *, void, void))(*(void *)v10 + 40LL))( v10,  a2,  a3,  *(void *)&v14[1],  *(void *)&v14[5]) & 1) != 0)
    {
      *(_WORD *)(*(void *)(a1 + 1520) + 6LL) = v14[0];
      std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)(a1 + 392), 0LL);
      std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)(a1 + 400), 0LL);
      return 1LL;
    }

    uint64_t result = 0LL;
    char v9 = 80;
  }

  else
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2340);
    uint64_t result = 0LL;
    char v9 = 50;
  }

  *a3 = v9;
  return result;
}

uint64_t bssl::anonymous namespace'::X25519KeyShare::GroupID( bssl::_anonymous_namespace_::X25519KeyShare *this)
{
  return 29LL;
}

BOOL X25519(char *a1, __int128 *a2, int64x2_t *a3)
{
  uint64_t v93 = *MEMORY[0x1895F89C0];
  unint64_t v87 = 0xAAAAAAAAAAAAAAAALL;
  v3.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v3.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v85 = v3;
  int64x2_t v86 = v3;
  unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
  v72[0] = v3;
  v72[1] = v3;
  unint64_t v71 = 0xAAAAAAAAAAAAAAAALL;
  v70[0] = v3;
  v70[1] = v3;
  unint64_t v69 = 0xAAAAAAAAAAAAAAAALL;
  v68[0] = v3;
  v68[1] = v3;
  unint64_t v67 = 0xAAAAAAAAAAAAAAAALL;
  v66[0] = v3;
  v66[1] = v3;
  unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
  v64[0] = v3;
  v64[1] = v3;
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  v62[0] = v3;
  v62[1] = v3;
  unint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v59 = v3;
  int64x2_t v60 = v3;
  __int128 v4 = a2[1];
  __int128 v88 = *a2;
  __int128 v89 = v4;
  LOBYTE(v8_Block_object_dispose(va, 8) = v88 & 0xF8;
  HIBYTE(v89) = HIBYTE(v4) & 0x3F | 0x40;
  int64x2_t v5 = a3[1];
  int64x2_t v90 = *a3;
  int64x2_t v91 = v5;
  v91.i8[15] = v5.i8[15] & 0x7F;
  fe_frombytes_strict((unint64_t *)&v85, (unsigned int *)&v90);
  unsigned int v6 = 0;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  uint64_t v81 = 0LL;
  unint64_t v82 = 1LL;
  int64x2_t v79 = 0u;
  int64x2_t v80 = 0u;
  v77[0] = v85;
  v77[1] = v86;
  unsigned int v7 = 254;
  unint64_t v78 = v87;
  __int128 v75 = 0u;
  uint64_t v74 = 1LL;
  int8x16_t v58 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL);
  int8x16_t v76 = 0u;
  do
  {
    uint64_t v8 = 0LL;
    unsigned int v9 = v7;
    unsigned int v10 = v6;
    unsigned int v6 = (*((unsigned __int8 *)&v88 + ((unint64_t)v7 >> 3)) >> (v7 & 7)) & 1;
    uint64_t v11 = -(uint64_t)(v6 ^ v10);
    do
    {
      uint64_t v12 = *(unint64_t *)((char *)&v82 + v8 * 8);
      uint64_t v13 = v77[0].i64[v8];
      uint64_t v14 = (v13 ^ v12) & v11;
      *(unint64_t *)((char *)&v82 + v8 * _Block_object_dispose(va, 8) = v14 ^ v12;
      v77[0].i64[v8++] = v14 ^ v13;
    }

    while (v8 != 5);
    for (uint64_t i = 0LL; i != 5; ++i)
    {
      uint64_t v16 = v79.i64[i];
      uint64_t v17 = *(uint64_t *)((char *)&v74 + i * 8);
      uint64_t v18 = (v17 ^ v16) & v11;
      v79.i64[i] = v18 ^ v16;
      *(uint64_t *)((char *)&v74 + i * _Block_object_dispose(va, 8) = v18 ^ v17;
    }

    fe_sub(v62, v77, (int64x2_t *)&v74);
    fe_sub(&v59, (int64x2_t *)&v82, &v79);
    fe_add(v68, (int64x2_t *)&v82, &v79);
    fe_add(v66, v77, (int64x2_t *)&v74);
    fe_mul_impl((uint64_t)&v74, (unint64_t *)v62, (unint64_t *)v68);
    fe_mul_impl((uint64_t)&v79, (unint64_t *)v66, (unint64_t *)&v59);
    fe_sq_tl((uint64_t)v72, (unint64_t *)&v59);
    fe_sq_tl((uint64_t)v70, (unint64_t *)v68);
    fe_add(v64, (int64x2_t *)&v74, &v79);
    fe_sub(v66, (int64x2_t *)&v74, &v79);
    fe_mul_impl((uint64_t)&v82, (unint64_t *)v70, (unint64_t *)v72);
    fe_sub(&v59, v70, v72);
    fe_sq_tl((uint64_t)&v79, (unint64_t *)v66);
    for (uint64_t j = 0LL; j != 5; ++j)
    {
      if (v59.i64[j] >= 0x1A666666666665uLL) {
        X25519_cold_1();
      }
    }

    uint64_t v20 = 0LL;
    uint64_t v21 = (v61 * (unsigned __int128)0x1DB42uLL) >> 64;
    uint64_t v22 = 121666 * v61;
    uint64_t v23 = (v60.u64[1] * (unsigned __int128)0x1DB42uLL) >> 64;
    uint64_t v24 = 121666 * v60.i64[1];
    uint64_t v25 = (__int128)(v59.u64[0] * (unsigned __int128)0x1DB42uLL) >> 51;
    BOOL v26 = __CFADD__(v25, 121666 * v59.i64[1]);
    uint64_t v27 = v25 + 121666 * v59.i64[1];
    uint64_t v28 = 121666 * v60.i64[0];
    uint64_t v29 = (v59.u64[1] * (unsigned __int128)0x1DB42uLL) >> 64;
    if (v26) {
      ++v29;
    }
    *((void *)&v31 + 1) = v29;
    *(void *)&__int128 v31 = v27;
    uint64_t v30 = v31 >> 51;
    uint64_t v32 = v27 & 0x7FFFFFFFFFFFFLL;
    BOOL v26 = __CFADD__(v30, v28);
    uint64_t v33 = v30 + v28;
    if (v26) {
      uint64_t v34 = ((v60.u64[0] * (unsigned __int128)0x1DB42uLL) >> 64) + 1;
    }
    else {
      uint64_t v34 = (v60.u64[0] * (unsigned __int128)0x1DB42uLL) >> 64;
    }
    *((void *)&v36 + 1) = v34;
    *(void *)&__int128 v36 = v33;
    uint64_t v35 = v36 >> 51;
    BOOL v26 = __CFADD__(v35, v24);
    uint64_t v37 = v35 + v24;
    if (v26) {
      ++v23;
    }
    *((void *)&v39 + 1) = v23;
    *(void *)&__int128 v39 = v37;
    uint64_t v38 = v39 >> 51;
    uint64_t v40 = v33 & 0x7FFFFFFFFFFFFLL;
    BOOL v26 = __CFADD__(v38, v22);
    uint64_t v41 = v38 + v22;
    if (v26) {
      ++v21;
    }
    *((void *)&v42 + 1) = v21;
    *(void *)&__int128 v42 = v41;
    v43.i64[0] = v37;
    v43.i64[1] = v41;
    unint64_t v44 = ((121666 * v59.i64[0]) & 0x7FFFFFFFFFFFELL) + 19 * (v42 >> 51);
    uint64_t v45 = v44 & 0x7FFFFFFFFFFFFLL;
    unint64_t v46 = v32 + (v44 >> 51);
    uint64_t v74 = v45;
    *(void *)&__int128 v75 = v46 & 0x7FFFFFFFFFFFFLL;
    *((void *)&v75 + 1) = v40 + (v46 >> 51);
    int8x16_t v76 = vandq_s8(v43, v58);
    do
    {
      v20 += 8LL;
    }

    while (v20 != 40);
    fe_sq_tl((uint64_t)v77, (unint64_t *)v64);
    fe_add(v62, v72, (int64x2_t *)&v74);
    fe_mul_impl((uint64_t)&v74, (unint64_t *)&v85, (unint64_t *)&v79);
    fe_mul_impl((uint64_t)&v79, (unint64_t *)&v59, (unint64_t *)v62);
    unsigned int v7 = v9 - 1;
  }

  while (v9);
  uint64_t v47 = 0LL;
  uint64_t v48 = -(uint64_t)v6;
  do
  {
    uint64_t v49 = *(unint64_t *)((char *)&v82 + v47 * 8);
    uint64_t v50 = v77[0].i64[v47];
    uint64_t v51 = (v50 ^ v49) & v48;
    *(unint64_t *)((char *)&v82 + v47 * _Block_object_dispose(va, 8) = v51 ^ v49;
    v77[0].i64[v47++] = v51 ^ v50;
  }

  while (v47 != 5);
  for (uint64_t k = 0LL; k != 5; ++k)
  {
    uint64_t v53 = v79.i64[k];
    uint64_t v54 = *(uint64_t *)((char *)&v74 + k * 8);
    uint64_t v55 = (v54 ^ v53) & v48;
    v79.i64[k] = v55 ^ v53;
    *(uint64_t *)((char *)&v74 + k * _Block_object_dispose(va, 8) = v55 ^ v54;
  }

  int64x2_t v90 = v79;
  int64x2_t v91 = v80;
  uint64_t v92 = v81;
  fe_loose_invert((uint64_t)&v79, (unint64_t *)&v90);
  fe_mul_impl((uint64_t)&v82, &v82, (unint64_t *)&v79);
  fe_tobytes(a1, &v82);
  return CRYPTO_memcmp(X25519_kZeros, a1, 32LL) != 0;
}

unint64_t *fe_frombytes_strict(unint64_t *result, unsigned int *a2)
{
  uint64_t v2 = *((unsigned __int8 *)a2 + 31);
  uint64_t v3 = 0LL;
  uint64_t v4 = *((unsigned __int8 *)a2 + 30);
  unint64_t v5 = *((unsigned __int8 *)a2 + 6);
  unint64_t v6 = ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40) & 0xFFF8FFFFFFFFFFFFLL | ((v5 & 7) << 48) | *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32);
  unint64_t v7 = *((unsigned __int8 *)a2 + 12);
  uint64_t v8 = *((unsigned __int8 *)a2 + 29);
  uint64_t v9 = *((unsigned __int8 *)a2 + 28);
  uint64_t v10 = *((unsigned __int8 *)a2 + 27);
  uint64_t v11 = *((unsigned __int8 *)a2 + 26);
  unint64_t v12 = *(unsigned int *)((char *)a2 + 22);
  unint64_t v13 = ((v7 & 0x3F) << 45) | ((unint64_t)*((unsigned __int8 *)a2 + 11) << 37) | ((unint64_t)*((unsigned __int8 *)a2 + 10) << 29) | ((unint64_t)*((unsigned __int8 *)a2 + 9) << 21) | ((unint64_t)*((unsigned __int8 *)a2 + 8) << 13) | (32LL * *((unsigned __int8 *)a2 + 7)) | (v5 >> 3);
  unint64_t v14 = a2[4];
  unint64_t v15 = ((v14 & 0x1FFFFFF) << 26) | ((unint64_t)*((unsigned __int8 *)a2 + 15) << 18) | ((unint64_t)*((unsigned __int8 *)a2 + 14) << 10) | (4LL * *((unsigned __int8 *)a2 + 13)) | (v7 >> 6);
  unint64_t v16 = ((v12 & 0xFFFFFFF) << 23) | ((unint64_t)*((unsigned __int8 *)a2 + 21) << 15) | ((unint64_t)*((unsigned __int8 *)a2 + 20) << 7) | (v14 >> 25);
  *uint64_t result = v6;
  result[1] = v13;
  result[2] = v15;
  result[3] = v16;
  result[4] = (v2 << 44) | (v4 << 36) | (v8 << 28) | (v9 << 20) | (v10 << 12) | (16 * v11) | (v12 >> 28);
  do
  {
    if (result[v3] >= 0x8CCCCCCCCCCCDLL) {
      fe_frombytes_strict_cold_2();
    }
    ++v3;
  }

  while (v3 != 5);
  return result;
}

uint64_t bssl::tls13_advance_key_schedule(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v11 = v2;
  __int128 v12 = v2;
  *(_OWORD *)md = v2;
  __int128 v10 = v2;
  unsigned int size = -1431655766;
  uint64_t v3 = (bssl::SSLTranscript *)(a1 + 424);
  uint64_t v4 = bssl::SSLTranscript::Digest((bssl::SSLTranscript *)(a1 + 424));
  uint64_t result = EVP_Digest(0LL, 0LL, md, &size, v4, 0LL);
  if ((_DWORD)result)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    unint64_t v7 = (EVP_MD *)bssl::SSLTranscript::Digest(v3);
    return CRYPTO_tls13_hkdf_expand_label(a1 + 40, v6, v7, a1 + 40, *(void *)(a1 + 32), "derived", 7uLL, md, size)
        && bssl::hkdf_extract_to_secret(a1, v3);
  }

  return result;
}

int EVP_Digest( const void *data, size_t count, unsigned __int8 *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)
{
  int v10 = EVP_DigestInit_ex(&v12, type, (ENGINE *)md);
  if (v10)
  {
    ((void (*)(EVP_MD_CTX *, const void *, size_t))v12.digest->init)(&v12, data, count);
    EVP_DigestFinal_ex(&v12, md, size);
  }

  EVP_MD_CTX_cleanup(&v12);
  return v10;
}

int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  if (ctx->digest->pkey_type >= 0x41u) {
    EVP_DigestFinal_ex_cold_1();
  }
  ((void (*)(void))ctx->digest->update)();
  digest = ctx->digest;
  if (s) {
    *s = digest->pkey_type;
  }
  OPENSSL_cleanse(ctx->engine, HIDWORD(digest->final));
  return 1;
}

uint64_t digest_final_wrapper(uint64_t a1)
{
  return digest_final(*(void *)(a1 + 8));
}

uint64_t digest_final(uint64_t a1)
{
  if (!a1) {
    digest_final_cold_1();
  }
  uint64_t result = CCDigestFinal();
  if ((_DWORD)result) {
    digest_final_cold_2();
  }
  return result;
}

void OPENSSL_cleanse(void *ptr, size_t len)
{
  if (len) {
    bzero(ptr, len);
  }
}

BOOL HKDF_expand(int a1, int a2, EVP_MD *md)
{
  int v3 = EVP_MD_type(md);
  boringssl_crypto_hash_nid_to_cc_digest(v3);
  return cchkdf_expand() == 0;
}

uint64_t bssl::ssl_hash_message(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)a2) {
    return 1LL;
  }
  else {
    return bssl::SSLTranscript::Update((void **)(a1 + 424), *(const void **)(a2 + 24), *(void *)(a2 + 32));
  }
}

uint64_t bssl::tls13_derive_handshake_secrets(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = (unsigned __int8 *)this + 136;
  unint64_t v5 = (bssl *)((char *)this + 424);
  if (bssl::derive_secret_with_transcript( (uint64_t)this,  (int)this + 136,  *((void *)this + 4),  (bssl *)((char *)this + 424),  "c hs traffic",  0xCuLL)
    && bssl::ssl_log_secret(v3, "CLIENT_HANDSHAKE_TRAFFIC_SECRET", v4, *((void *)this + 4))
    && bssl::derive_secret_with_transcript( (uint64_t)this,  (int)this + 184,  *((void *)this + 4),  v5,  "s hs traffic",  0xCuLL))
  {
    return bssl::ssl_log_secret( v3,  "SERVER_HANDSHAKE_TRAFFIC_SECRET",  (unsigned __int8 *)this + 184,  *((void *)this + 4));
  }

  else
  {
    return 0LL;
  }

uint64_t bssl::derive_secret_with_transcript( uint64_t a1, int a2, int a3, bssl::SSLTranscript *this, const void *a5, size_t a6)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v18 = v12;
  __int128 v19 = v12;
  *(_OWORD *)unint64_t v16 = v12;
  __int128 v17 = v12;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = bssl::SSLTranscript::GetHash(this, v16, &v15);
  if ((_DWORD)result)
  {
    unint64_t v14 = (EVP_MD *)bssl::SSLTranscript::Digest(this);
    return CRYPTO_tls13_hkdf_expand_label(a2, a3, v14, a1 + 40, *(void *)(a1 + 32), a5, a6, v16, v15);
  }

  return result;
}

uint64_t bssl::SSLTranscript::GetHash(bssl::SSLTranscript *this, unsigned __int8 *a2, unint64_t *a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.digest = v6;
  *(_OWORD *)&ctx.flagunsigned int s = v6;
  EVP_MD_CTX_init(&ctx);
  unsigned int s = -1431655766;
  if (EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)((char *)this + 8)) && EVP_DigestFinal_ex(&ctx, a2, &s))
  {
    *a3 = s;
    uint64_t v7 = 1LL;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  EVP_MD_CTX_cleanup(&ctx);
  return v7;
}

void sub_18757E580( _Unwind_Exception *a1, uint64_t a2, EVP_MD_CTX *ctx, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t ctxa)
{
}

int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  if (!in) {
    goto LABEL_13;
  }
  if (!in->flags)
  {
    digest = in->digest;
    if (in->digest)
    {
      unint64_t v6 = 0LL;
LABEL_9:
      if (out->digest == digest)
      {
        engine = out->engine;
        out->engine = 0LL;
LABEL_16:
        EVP_MD_CTX_cleanup(out);
        out->digest = in->digest;
        out->engine = engine;
        if (in->digest)
        {
          size_t final_high = HIDWORD(in->digest->final);
          if ((_DWORD)final_high) {
            memcpy(engine, in->engine, final_high);
          }
        }

        md_data = in->md_data;
        out->flagunsigned int s = v6;
        out->md_data = md_data;
        LODWORD(v5) = 1;
        if (v6 && !md_data) {
          EVP_MD_CTX_copy_ex_cold_1();
        }
        return v5;
      }

      unint64_t v9 = HIDWORD(digest->final);
      if (!(_DWORD)v9) {
        EVP_MD_CTX_copy_ex_cold_2();
      }
      int v10 = (ENGINE *)OPENSSL_malloc(v9);
      if (v10)
      {
        engine = v10;
        goto LABEL_16;
      }

      if (v6) {
        (*(void (**)(unint64_t))in->md_data)(v6);
      }
LABEL_14:
      LODWORD(v5) = 0;
      return v5;
    }

uint64_t bssl::ssl_log_secret(uint64_t a1, const char *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (!*(void *)(*(void *)(a1 + 120) + 760LL)) {
    return 1LL;
  }
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[1] = v8;
  _OWORD v16[2] = v8;
  v16[0] = v8;
  CBB_zero(v16);
  v15[0] = 0LL;
  v15[1] = 0LL;
  size_t v9 = strlen(a2);
  if (!CBB_init((uint64_t)v16, v9 + 2 * a4 + 67)
    || (size_t v10 = strlen(a2), !CBB_add_bytes((uint64_t)v16, a2, v10))
    || !CBB_add_u8((uint64_t)v16, 0x20u)
    || !bssl::cbb_add_hex_consttime((uint64_t)v16, (unsigned __int8 *)(*(void *)(a1 + 48) + 48LL), 32LL)
    || !CBB_add_u8((uint64_t)v16, 0x20u)
    || !bssl::cbb_add_hex_consttime((uint64_t)v16, a3, a4)
    || !CBB_add_u8((uint64_t)v16, 0))
  {
    __int128 v12 = 0LL;
    goto LABEL_12;
  }

  BOOL v11 = bssl::CBBFinishArray((uint64_t)v16, (uint64_t)v15);
  __int128 v12 = (void *)v15[0];
  if (!v11)
  {
LABEL_12:
    uint64_t v13 = 0LL;
    goto LABEL_13;
  }

  (*(void (**)(uint64_t, void))(*(void *)(a1 + 120) + 760LL))(a1, v15[0]);
  uint64_t v13 = 1LL;
LABEL_13:
  OPENSSL_free(v12);
  CBB_cleanup((uint64_t)v16);
  return v13;
}

void sub_18757E800( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t bssl::tls13_set_traffic_key( uint64_t a1, const ssl_session_st *a2, uint64_t a3, bssl *this, const void *a5, size_t a6)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  __int128 v12 = (bssl::SSLAEADContext *)bssl::ssl_session_protocol_version(this, a2);
  unsigned int v13 = v12;
  uint64_t v40 = 0LL;
  if (*(void *)(a1 + 168))
  {
    bssl::SSLAEADContext::CreatePlaceholderForQUIC(v12, *((void *)this + 25), v42);
    unint64_t v14 = *(bssl::SSLAEADContext **)&v42[0];
    *(void *)&v42[0] = 0LL;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v40, v14);
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]( (bssl::SSLAEADContext **)v42,  0LL);
    size_t v15 = a6;
    unint64_t v16 = a5;
  }

  else
  {
    uint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
    __int128 v39 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v19 = *((void *)this + 25);
    char v20 = SSL_is_dtls((unsigned __int8 **)a1) != 0;
    digest = (EVP_MD *)bssl::ssl_session_get_digest(this, v21);
    uint64_t v23 = EVP_AEAD_key_length(v39);
    *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v42[3] = v24;
    v42[4] = v24;
    v42[1] = v24;
    v42[2] = v24;
    v42[0] = v24;
    uint64_t v25 = EVP_AEAD_nonce_length((uint64_t)v39);
    memset(v41, 170, sizeof(v41));
    BOOL v26 = (unsigned __int16 *)*((unsigned __int16 *)this + 2);
    char v27 = SSL_is_dtls((unsigned __int8 **)a1) != 0;
    bssl::SSLAEADContext::Create(a3, v26, v27, *((void *)this + 25), v42, v23, 0LL, 0LL, &v37, v41, v25);
    uint64_t v28 = v37;
    uint64_t v37 = 0LL;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v40, v28);
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v37, 0LL);
    size_t v15 = 0LL;
    unint64_t v16 = 0LL;
  }

  __int128 v17 = v40;
  if (!v40)
  {
LABEL_20:
    uint64_t v18 = 0LL;
    goto LABEL_21;
  }

  if (a6 < 0x31)
  {
    uint64_t v29 = *(unsigned __int8 **)a1;
    if ((_DWORD)a3)
    {
      uint64_t v30 = (uint64_t (*)(uint64_t, const ssl_session_st *, bssl::SSLAEADContext **, const void *, size_t))*((void *)v29 + 18);
      uint64_t v40 = 0LL;
      uint64_t v35 = v17;
      char v31 = v30(a1, a2, &v35, v16, v15);
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v35, 0LL);
      if ((v31 & 1) != 0)
      {
        if (a6) {
          memmove((void *)(*(void *)(a1 + 48) + 296LL), a5, a6);
        }
        *(_BYTE *)(*(void *)(a1 + 48) + 44std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](this, 0LL) = a6;
LABEL_19:
        uint64_t v18 = 1LL;
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v32 = (uint64_t (*)(uint64_t, const ssl_session_st *, bssl::SSLAEADContext **, const void *, size_t))*((void *)v29 + 17);
      uint64_t v40 = 0LL;
      __int128 v36 = v17;
      char v33 = v32(a1, a2, &v36, v16, v15);
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v36, 0LL);
      if ((v33 & 1) != 0)
      {
        if (a6) {
          memmove((void *)(*(void *)(a1 + 48) + 344LL), a5, a6);
        }
        *(_BYTE *)(*(void *)(a1 + 48) + 441LL) = a6;
        goto LABEL_19;
      }
    }

    goto LABEL_20;
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 195);
  uint64_t v18 = 0LL;
LABEL_21:
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v40, 0LL);
  return v18;
}

void sub_18757EB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  unint64_t v6 = va_arg(va1, bssl::SSLAEADContext *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va, 0LL);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va1, 0LL);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_session_protocol_version(bssl *this, const ssl_session_st *a2)
{
  unsigned __int16 v3 = -21846;
  return v3;
}

uint64_t bssl::ssl_cipher_get_evp_aead( void **a1, uint64_t *a2, uint64_t *a3, uint64_t a4, unsigned int a5, char a6)
{
  uint64_t result = 0LL;
  *a1 = 0LL;
  *a2 = 0LL;
  *a3 = 0LL;
  if (a5 == 771) {
    char v8 = a6;
  }
  else {
    char v8 = 1;
  }
  if (a5 == 772) {
    char v9 = a6;
  }
  else {
    char v9 = 1;
  }
  switch(*(_DWORD *)(a4 + 32))
  {
    case 1:
      uint64_t result = 0LL;
      int v13 = *(_DWORD *)(a4 + 28);
      if (v13 > 3)
      {
        if (v13 == 4)
        {
          if (a5 == 769)
          {
            unint64_t v14 = EVP_aead_aes_256_cbc_sha1_tls_implicit_iv();
            goto LABEL_35;
          }

          uint64_t v19 = EVP_aead_aes_256_cbc_sha1_tls();
LABEL_42:
          *a1 = v19;
          goto LABEL_43;
        }

        if (v13 == 32)
        {
          uint64_t v19 = EVP_aead_null_sha1_tls();
          goto LABEL_42;
        }
      }

      else
      {
        if (v13 == 1)
        {
          if (a5 == 769)
          {
            *a1 = EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv();
            uint64_t v20 = 8LL;
LABEL_36:
            *a3 = v20;
LABEL_43:
            uint64_t v15 = 20LL;
            goto LABEL_44;
          }

          uint64_t v19 = EVP_aead_des_ede3_cbc_sha1_tls();
          goto LABEL_42;
        }

        if (v13 == 2)
        {
          if (a5 == 769)
          {
            unint64_t v14 = EVP_aead_aes_128_cbc_sha1_tls_implicit_iv();
LABEL_35:
            *a1 = v14;
            uint64_t v20 = 16LL;
            goto LABEL_36;
          }

          uint64_t v19 = EVP_aead_aes_128_cbc_sha1_tls();
          goto LABEL_42;
        }
      }

      return result;
    case 2:
      if (*(_DWORD *)(a4 + 28) != 2) {
        return 0LL;
      }
      *a1 = EVP_aead_aes_128_cbc_sha256_tls();
      uint64_t v15 = 32LL;
      goto LABEL_44;
    case 4:
      if (*(_DWORD *)(a4 + 28) != 4) {
        return 0LL;
      }
      *a1 = EVP_aead_aes_256_cbc_sha384_tls();
      uint64_t v15 = 48LL;
LABEL_44:
      *a2 = v15;
      return 1LL;
    case 8:
      int v16 = *(_DWORD *)(a4 + 28);
      switch(v16)
      {
        case 64:
          uint64_t v17 = 12LL;
          uint64_t v18 = EVP_aead_chacha20_poly1305();
          break;
        case 16:
          uint64_t v17 = 4LL;
          if ((v8 & 1) != 0)
          {
            if ((v9 & 1) != 0) {
              uint64_t v18 = EVP_aead_aes_256_gcm();
            }
            else {
              uint64_t v18 = EVP_aead_aes_256_gcm_tls13();
            }
          }

          else
          {
            uint64_t v18 = EVP_aead_aes_256_gcm_tls12();
          }

          break;
        case 8:
          uint64_t v17 = 4LL;
          if ((v8 & 1) != 0)
          {
            if ((v9 & 1) != 0) {
              uint64_t v18 = EVP_aead_aes_128_gcm();
            }
            else {
              uint64_t v18 = EVP_aead_aes_128_gcm_tls13();
            }
          }

          else
          {
            uint64_t v18 = EVP_aead_aes_128_gcm_tls12();
          }

          break;
        default:
          return 0LL;
      }

      *a1 = v18;
      *a3 = v17;
      if (a5 >= 0x304) {
        *a3 = EVP_AEAD_nonce_length((uint64_t)v18);
      }
      return 1LL;
    default:
      return result;
  }

int *EVP_aead_aes_256_gcm_tls13()
{
  return &EVP_aead_aes_256_gcm_tls13_storage;
}

uint64_t EVP_AEAD_nonce_length(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1);
}

const EVP_MD *bssl::ssl_session_get_digest(bssl *this, const ssl_session_st *a2)
{
  unsigned __int16 v3 = (bssl *)bssl::ssl_session_protocol_version(this, a2);
  return bssl::ssl_get_handshake_digest(v3, *((void *)this + 25), v4);
}

uint64_t EVP_AEAD_key_length(unsigned __int8 *a1)
{
  return *a1;
}

void bssl::SSLAEADContext::Create( uint64_t a1@<X0>, unsigned __int16 *a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, _OWORD *a5@<X4>, size_t a6@<X5>, const void *a7@<X6>, size_t a8@<X7>, bssl::SSLAEADContext **a9@<X8>, const void *a10, size_t a11)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  __int16 v39 = (__int16)a2;
  char v38 = a3;
  __int128 v36 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v37 = a4;
  unsigned __int16 v35 = -21846;
  uint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  if (bssl::ssl_protocol_version_from_wire((bssl *)&v35, a2))
  {
    int evp_aead = bssl::ssl_cipher_get_evp_aead((void **)&v36, &v34, &v33, a4, v35, a3);
    int v20 = v33 == a11 ? evp_aead : 0;
    if (v20 == 1 && v34 == a8)
    {
      *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
      void __dst[3] = v22;
      __dst[4] = v22;
      __dst[1] = v22;
      __dst[2] = v22;
      __dst[0] = v22;
      if (a8)
      {
        if (a8 + a6 + a11 >= 0x51)
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", 80);
          goto LABEL_10;
        }

        memcpy(__dst, a7, a8);
        if (a6) {
          memcpy((char *)__dst + a8, a5, a6);
        }
        if (a11) {
          memcpy((char *)__dst + a8 + a6, a10, a11);
        }
        a5 = __dst;
        a6 += a8 + a11;
      }

      uint64_t v23 = (bssl::SSLAEADContext *)bssl::New<bssl::SSLAEADContext,unsigned short &,BOOL &,ssl_cipher_st const*&>( &v39,  &v38,  &v37);
      __int128 v24 = v23;
      if (!v23)
      {
LABEL_39:
        *a9 = v24;
        return;
      }

      int v25 = bssl::SSLAEADContext::ProtocolVersion(v23);
      if (v25 != v35)
      {
        char v31 = "aead_ctx->ProtocolVersion() == protocol_version";
        int v32 = 97;
        goto LABEL_46;
      }

      if (!EVP_AEAD_CTX_init_with_direction((void *)v24 + 1, v36, (uint64_t)a5, a6, 0LL, a1))
      {
        *a9 = 0LL;
        bssl::Delete<bssl::SSLAEADContext>(v24);
        return;
      }

      if ((unint64_t)EVP_AEAD_nonce_length((uint64_t)v36) > 0x18)
      {
        char v31 = "EVP_AEAD_nonce_length(aead) <= EVP_AEAD_MAX_NONCE_LENGTH";
        int v32 = 105;
        goto LABEL_46;
      }

      *((_BYTE *)v24 + 605) = EVP_AEAD_nonce_length((uint64_t)v36);
      if (a8)
      {
        if (v35 < 0x304u)
        {
          *((_BYTE *)v24 + 609) |= 0xBu;
          goto LABEL_39;
        }

        char v31 = "protocol_version < TLS1_3_VERSION";
        int v32 = 139;
      }

      else
      {
        if (a11 > 0xC)
        {
          char v31 = "fixed_iv.size() <= sizeof(aead_ctx->fixed_nonce_)";
          int v32 = 110;
          goto LABEL_46;
        }

        if (a11) {
          memcpy((char *)v24 + 592, a10, a11);
        }
        *((_BYTE *)v24 + 604) = a11;
        uint64_t v26 = v37;
        int v27 = *(_DWORD *)(v37 + 28);
        if ((v27 & 0x40) != 0)
        {
          *((_BYTE *)v24 + 609) |= 4u;
          int v27 = *(_DWORD *)(v26 + 28);
          char v29 = 8;
        }

        else
        {
          size_t v28 = *((unsigned __int8 *)v24 + 605);
          if (a11 > v28)
          {
            char v31 = "fixed_iv.size() <= aead_ctx->variable_nonce_len_";
            int v32 = 120;
            goto LABEL_46;
          }

          char v29 = v28 - a11;
        }

        *((_BYTE *)v24 + 605) = v29;
        if ((v27 & 0x18) != 0) {
          *((_BYTE *)v24 + 609) |= 1u;
        }
        if (v35 < 0x304u) {
          goto LABEL_39;
        }
        char v30 = *((_BYTE *)v24 + 609);
        *((_BYTE *)v24 + 605) = 8;
        *((_BYTE *)v24 + 609) = v30 & 0xEA | 0x14;
        if (a11 >= 8) {
          goto LABEL_39;
        }
        char v31 = "fixed_iv.size() >= aead_ctx->variable_nonce_len_";
        int v32 = 136;
      }

LABEL_46:
      __assert_rtn("Create", "ssl_aead_ctx.cc", v32, v31);
    }
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_aead_ctx.cc", 70);
LABEL_10:
  *a9 = 0LL;
}

        char v29 = (top << 6) - 1;
        char v30 = 0;
        if (((v29 % v36) & 0x80000000) == 0)
        {
          char v31 = v29 % v36 + 1;
          do
          {
            char v30 = BN_is_bit_set(p, v29--) + 2 * v30;
            --v31;
          }

          while (v31);
        }

        uint64_t v26 = (void *)v38;
        if (!copy_from_prebuf((uint64_t)&r, d, v38, v30, v36))
        {
LABEL_56:
          unint64_t v14 = 0;
LABEL_58:
          uint64_t v18 = v37;
LABEL_64:
          BN_MONT_CTX_free(v18);
          if (!v25)
          {
            if (v26) {
              OPENSSL_cleanse(v26, len);
            }
          }

          OPENSSL_free(v25);
          return v14;
        }

        uint64_t v40 = objc_loadWeakRetained(v6 + 2);
        if (!v40
          || (uint64_t v41 = v40,
              __int128 v42 = objc_loadWeakRetained(v6 + 2),
              uint64_t v43 = v42[475],
              v42,
              v41,
              (v43 & 1) == 0))
        {
          unint64_t v44 = objc_loadWeakRetained(v6 + 2);
          if (v44)
          {
            uint64_t v45 = objc_loadWeakRetained(v6 + 2);
            __int16 v39 = (v45[475] & 1) == 0;
          }

          else
          {
            __int16 v39 = 1LL;
          }

          uint64_t v47 = 1;
LABEL_60:
          if ((_DWORD)v39 && g_boringssl_log)
          {
            uint64_t v48 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              if (v47)
              {
                __int16 v39 = (uint64_t)objc_loadWeakRetained(v6 + 2);
                uint64_t v49 = v39 != 0;
                if (v39)
                {
                  unsigned __int16 v3 = (uint64_t)objc_loadWeakRetained(v6 + 2);
                  uint64_t v50 = (void *)(v3 + 391);
                }

                else
                {
                  uint64_t v50 = &unk_1875F4C23;
                }

                int8x16_t v58 = objc_loadWeakRetained(v6 + 2);
              }

              else
              {
                uint64_t v49 = 0;
                int8x16_t v58 = 0LL;
                uint64_t v50 = &unk_1875F4C23;
              }

              *(_DWORD *)buf = 136446978;
              uint64_t v64 = "boringssl_context_copy_peer_sct_list_from_extension";
              unint64_t v65 = 1024;
              int v66 = 981;
              unint64_t v67 = 2082;
              __int128 v68 = v50;
              unint64_t v69 = 2048;
              int v70 = v58;
              _os_log_error_impl( &dword_187560000,  v48,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] CFDataCreate failed",  buf,  0x26u);
              if (v47) {

              }
              if (v49) {
              if (v47)
              }
                goto LABEL_107;
            }

            goto LABEL_71;
          }
        }

        goto LABEL_72;
      }

void sub_18757F15C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *bssl::New<bssl::SSLAEADContext,unsigned short &,BOOL &,ssl_cipher_st const*&>( __int16 *a1, char *a2, void *a3)
{
  unint64_t v6 = OPENSSL_malloc(0x268uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    __int16 v8 = *a1;
    char v9 = *a2;
    void *v6 = *a3;
    EVP_AEAD_CTX_zero(v6 + 1);
    *((_WORD *)v7 + 302) = 0;
    *((_WORD *)v7 + 303) = v8;
    *((_BYTE *)v7 + 60_Block_object_dispose(va, 8) = v9;
    *((_BYTE *)v7 + 609) &= 0xE0u;
    v7[74] = 0LL;
    *((_DWORD *)v7 + 150) = 0;
  }

  return v7;
}

uint64_t EVP_AEAD_CTX_init_with_direction( void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*a2 != a4)
  {
    ERR_put_error(30, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", 78);
    goto LABEL_6;
  }

  *a1 = a2;
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t, uint64_t))*((void *)a2 + 1);
  if (v7)
  {
    uint64_t result = v7(a1, a3, a4, a5);
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_6;
  }

  uint64_t result = (*((uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))a2 + 2))(a1, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
LABEL_6:
    uint64_t result = 0LL;
    *a1 = 0LL;
  }

  return result;
}

uint64_t aead_aes_gcm_init_with_dir(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  if (8 * a3 != 128 && 8 * a3 != 256)
  {
    int v7 = 102;
    int v8 = 215;
    goto LABEL_9;
  }

  if (a4) {
    unint64_t v6 = a4;
  }
  else {
    unint64_t v6 = 16LL;
  }
  if (v6 >= 0x11)
  {
    int v7 = 116;
    int v8 = 224;
LABEL_9:
    ERR_put_error(30, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m", v8);
    return 0LL;
  }

  if (a5 == 1) {
    char v9 = (size_t *)ccaes_gcm_encrypt_mode();
  }
  else {
    char v9 = (size_t *)ccaes_gcm_decrypt_mode();
  }
  *(void *)(a1 + _Block_object_dispose(va, 8) = v9;
  uint64_t v10 = malloc(*v9);
  *(void *)(a1 + 16) = v10;
  if (!v10 || ccgcm_init())
  {
    free((void *)(a1 + 8));
    return 0LL;
  }

  *(_BYTE *)(a1 + 24) = v6;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  uint64_t result = 1LL;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 576) = v6;
  return result;
}

uint64_t bssl::tls_set_write_state(bssl *a1, ssl_st *a2, bssl::SSLAEADContext **a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = bssl::tls_flush_pending_hs_data(a1, a2);
  if ((_DWORD)result)
  {
    uint64_t v11 = *((void *)a1 + 21);
    if (!v11) {
      goto LABEL_7;
    }
    uint64_t v12 = *(void *)(*((void *)a1 + 6) + 280LL);
    if (v12 && (*(_BYTE *)(v12 + 1586) & 8) != 0
      || (uint64_t result = (*(uint64_t (**)(bssl *, ssl_st *, void, uint64_t, uint64_t))(v11 + 8))( a1,  a2,  *(void *)*a3,  a4,  a5),  (_DWORD)result))
    {
      if ((_DWORD)a2 == 1) {
        return 1LL;
      }
LABEL_7:
      uint64_t v13 = *((void *)a1 + 6);
      *(void *)(v13 + _Block_object_dispose(va, 8) = 0LL;
      unint64_t v14 = *a3;
      *a3 = 0LL;
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]( (bssl::SSLAEADContext **)(v13 + 272),  v14);
      *(_DWORD *)(*((void *)a1 + 6) + 204LL) = (_DWORD)a2;
      return 1LL;
    }
  }

  return result;
}

void bssl::SSLAEADContext::~SSLAEADContext(bssl::SSLAEADContext *this)
{
}

uint64_t EVP_AEAD_CTX_cleanup(uint64_t result)
{
  if (*(void *)result)
  {
    uint64_t v1 = (void *)result;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
    void *v1 = 0LL;
  }

  return result;
}

uint64_t bssl::tls_set_read_state( bssl *a1, const ssl_st *a2, bssl::SSLAEADContext **a3, uint64_t a4, uint64_t a5)
{
  if (bssl::tls_has_unprocessed_handshake_data(a1, a2))
  {
    ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_method.cc", 90);
    bssl::ssl_send_alert(a1, (ssl_st *)2, 10);
    return 0LL;
  }

  uint64_t v11 = (uint64_t (**)(bssl *, const ssl_st *, void, uint64_t, uint64_t))*((void *)a1 + 21);
  if (!v11) {
    goto LABEL_8;
  }
  uint64_t v12 = *(void *)(*((void *)a1 + 6) + 280LL);
  if (v12 && (*(_BYTE *)(v12 + 1586) & 8) != 0 || (uint64_t result = (*v11)(a1, a2, *(void *)*a3, a4, a5), (_DWORD)result))
  {
    if ((_DWORD)a2 == 1) {
      return 1LL;
    }
LABEL_8:
    uint64_t v13 = *((void *)a1 + 6);
    *(void *)uint64_t v13 = 0LL;
    unint64_t v14 = *a3;
    *a3 = 0LL;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]( (bssl::SSLAEADContext **)(v13 + 264),  v14);
    *(_DWORD *)(*((void *)a1 + 6) + 20std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](this, 0LL) = (_DWORD)a2;
    return 1LL;
  }

  return result;
}

BOOL bssl::tls_has_unprocessed_handshake_data(bssl *this, const ssl_st *a2)
{
  uint64_t v2 = *((void *)this + 6);
  if ((*(_WORD *)(v2 + 220) & 0x10) != 0)
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[0] = v5;
    v9[1] = v5;
    else {
      unint64_t v3 = 0LL;
    }
    uint64_t v2 = *((void *)this + 6);
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  unint64_t v6 = *(unint64_t **)(v2 + 224);
  return v6 && *v6 > v3;
}

void bssl::tls_next_message(bssl *this, ssl_st *a2)
{
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v3;
  v11[1] = v3;
  if (!bssl::tls_get_message((uint64_t)this, (uint64_t)v11)
    || (uint64_t v4 = *((void *)this + 6), (v5 = *(void *)(v4 + 224)) == 0)
    || (unint64_t v6 = *(void *)v5, *(void *)v5 < v12))
  {
    bssl::tls_next_message();
  }

  if (*(void *)v5 == v12)
  {
    unint64_t v7 = *(void *)v5;
  }

  else
  {
    memmove(*(void **)(v5 + 8), (const void *)(*(void *)(v5 + 8) + v12), *(void *)v5 - v12);
    unint64_t v7 = v12;
    uint64_t v4 = *((void *)this + 6);
    uint64_t v5 = *(void *)(v4 + 224);
    unint64_t v6 = *(void *)v5;
  }

  *(void *)uint64_t v5 = v6 - v7;
  *(_WORD *)(v4 + 220) &= ~8u;
  *(_WORD *)(*((void *)this + 6) + 220LL) &= ~0x10u;
  if (!SSL_in_init((uint64_t)this))
  {
    uint64_t v8 = *((void *)this + 6);
    unint64_t v10 = *(void **)(v8 + 224);
    char v9 = (BUF_MEM **)(v8 + 224);
    if (!*v10) {
      std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v9, 0LL);
    }
  }

uint64_t EVP_AEAD_CTX_aead(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t EVP_AEAD_max_overhead(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 2);
}

uint64_t EVP_AEAD_CTX_open( unsigned __int8 *a1, char *a2, size_t *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, unint64_t a8)
{
  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    int v11 = 115;
    int v12 = 191;
    goto LABEL_5;
  }

  uint64_t v15 = *(unsigned int (**)(unsigned __int8 *, char *))(*(void *)a1 + 32LL);
  if (!v15)
  {
    unint64_t v16 = a1[576];
    if (!a1[576]) {
      EVP_AEAD_CTX_open_cold_1();
    }
    size_t v13 = a8 - v16;
    if (a8 >= v16)
    {
      if (v13 <= a4)
      {
        if (EVP_AEAD_CTX_open_gather((uint64_t)a1, a2, a5, a6, a7, a8 - v16))
        {
          uint64_t result = 1LL;
LABEL_9:
          *a3 = v13;
          return result;
        }

LABEL_5:
    ERR_put_error(30, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v12);
    goto LABEL_6;
  }

  if (!v15(a1, a2)) {
    goto LABEL_6;
  }
  return 1LL;
}

uint64_t EVP_AEAD_CTX_open_gather(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, char *a5, size_t a6)
{
  if (a5 != a2 && &a5[a6] > a2 && &a2[a6] > a5)
  {
    int v8 = 115;
    int v9 = 238;
LABEL_9:
    ERR_put_error(30, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v9);
    goto LABEL_10;
  }

  unint64_t v10 = *(unsigned int (**)(uint64_t, char *))(*(void *)a1 + 48LL);
  if (!v10)
  {
    int v8 = 104;
    int v9 = 243;
    goto LABEL_9;
  }

  if (v10(a1, a2)) {
    return 1LL;
  }
LABEL_10:
  if (a6) {
    bzero(a2, a6);
  }
  return 0LL;
}

uint64_t aead_aes_gcm_open_gather( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a4)
  {
    int v11 = 111;
    int v12 = 373;
    goto LABEL_10;
  }

  if (*(unsigned __int8 *)(a1 + 576) != a8)
  {
    int v11 = 101;
    int v12 = 377;
    goto LABEL_10;
  }

  if (!*(void *)(a1 + 8) || !*(void *)(a1 + 16))
  {
    int v11 = 112;
    int v12 = 381;
    goto LABEL_10;
  }

  int v10 = ccgcm_reset();
  if (ccgcm_set_iv() | v10)
  {
    int v11 = 107;
    int v12 = 388;
LABEL_10:
    ERR_put_error( 30,  0,  v11,  "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m",  v12);
    return 0LL;
  }

  if (a10 && ccgcm_aad())
  {
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        aead_aes_gcm_open_gather_cold_3();
      }
    }

    int v11 = 101;
    int v12 = 396;
    goto LABEL_10;
  }

  if (ccgcm_update())
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      aead_aes_gcm_open_gather_cold_2();
    }
    int v11 = 101;
    int v12 = 404;
    goto LABEL_10;
  }

  if (ccgcm_finalize())
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      aead_aes_gcm_open_gather_cold_1();
    }
    int v11 = 101;
    int v12 = 411;
    goto LABEL_10;
  }

  return 1LL;
}

BOOL bssl::ssl_check_message_type(bssl *a1, uint64_t a2, int a3)
{
  int v4 = *(unsigned __int8 *)(a2 + 1);
  if (v4 != a3)
  {
    bssl::ssl_send_alert(a1, (ssl_st *)2, 10);
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 218);
    ERR_add_error_dataf("got type %d, wanted type %d", v6, v7, v8, v9, v10, v11, v12, *(_BYTE *)(a2 + 1));
  }

  return v4 == a3;
}

uint64_t bssl::ssl_parse_serverhello_tlsext(uint64_t a1, __int128 *a2)
{
  __int128 v3 = *(bssl **)a1;
  __int128 v45 = *a2;
  if (*((void *)&v45 + 1))
  {
    unsigned int v4 = 0;
    uint64_t v5 = "extension %u";
    while (2)
    {
      unsigned __int16 v44 = -21846;
      v43[0] = 0xAAAAAAAAAAAAAAAALL;
      v43[1] = 0xAAAAAAAAAAAAAAAALL;
      if (CBS_get_u16((unsigned __int16 **)&v45, &v44)
        && CBS_get_u16_length_prefixed((unsigned __int8 **)&v45, v43))
      {
        uint64_t v6 = 0LL;
        uint64_t v7 = off_18A071390;
        while (*((unsigned __int16 *)v7 - 8) != v44)
        {
          ++v6;
          v7 += 5;
          if (v6 == 28)
          {
            int v10 = 4147;
LABEL_15:
            ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v10);
            ERR_add_error_dataf(v5, v11, v12, v13, v14, v15, v16, v17, v44);
            int v9 = 110;
            goto LABEL_16;
          }
        }

        int v8 = 1 << v6;
        if ((*(_DWORD *)(a1 + 376) & (1 << v6)) == 0)
        {
          int v10 = 4158;
          uint64_t v5 = "extension :%u";
          goto LABEL_15;
        }

        unsigned __int8 v42 = 50;
        if ((((uint64_t (*)(uint64_t, unsigned __int8 *, unint64_t *))*v7)(a1, &v42, v43) & 1) == 0)
        {
          ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4168);
          ERR_add_error_dataf("extension %u", v35, v36, v37, v38, v39, v40, v41, v44);
          int v9 = v42;
          goto LABEL_16;
        }

        v4 |= v8;
        if (*((void *)&v45 + 1)) {
          continue;
        }
        goto LABEL_19;
      }

      break;
    }

uint64_t bssl::tls1_check_duplicate_extensions(__int128 *a1)
{
  unint64_t v2 = 0LL;
  __int128 v16 = *a1;
  while (*((void *)&v16 + 1))
  {
    LOWORD(v13[0]) = -21846;
    __base = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u16((unsigned __int16 **)&v16, v13))
    {
      ++v2;
    }

    return 0LL;
  }

  if (v2)
  {
    __base = 0LL;
    unint64_t v15 = 0LL;
    if ((bssl::Array<unsigned short>::Init((uint64_t)&__base, v2) & 1) != 0)
    {
      __int128 v16 = *a1;
      if (v15)
      {
        uint64_t v4 = 0LL;
        unint64_t v5 = 0LL;
        while (1)
        {
          v13[0] = 0xAAAAAAAAAAAAAAAALL;
          v13[1] = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16((unsigned __int16 **)&v16, (char *)__base + v4)
            || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v16, v13))
          {
            break;
          }

          ++v5;
          size_t v6 = v15;
          v4 += 2LL;
          if (v5 >= v15) {
            goto LABEL_16;
          }
        }
      }

      else
      {
        size_t v6 = 0LL;
LABEL_16:
        if (*((void *)&v16 + 1)) {
          __assert_rtn("tls1_check_duplicate_extensions", "extensions.cc", 193, "CBS_len(&extensions) == 0");
        }
        qsort(__base, v6, 2uLL, (int (__cdecl *)(const void *, const void *))bssl::compare_uint16_t);
        if (v2 < 2)
        {
          BOOL v3 = 1LL;
LABEL_21:
          OPENSSL_free(__base);
          return v3;
        }

        int v7 = *((unsigned __int16 *)__base + 1);
        if (*(unsigned __int16 *)__base != v7)
        {
          uint64_t v9 = 2LL;
          do
          {
            unint64_t v10 = v9;
            if (v2 == v9) {
              break;
            }
            int v11 = *((unsigned __int16 *)__base + v9++);
            BOOL v12 = v7 == v11;
            int v7 = *((unsigned __int16 *)__base + v10);
          }

          while (!v12);
          BOOL v3 = v10 >= v2;
          goto LABEL_21;
        }
      }
    }

    BOOL v3 = 0LL;
    goto LABEL_21;
  }

  return 1LL;
}

void sub_18758003C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t bssl::compare_uint16_t(bssl *this, unsigned __int16 *a2, const void *a3)
{
  unsigned int v3 = *(unsigned __int16 *)this;
  unsigned int v4 = *a2;
  BOOL v5 = v3 >= v4;
  BOOL v6 = v3 > v4;
  if (v5) {
    return v6;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL bssl::ext_sni_parse_serverhello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !a3 || *(void *)(a3 + 8) == 0LL;
}

uint64_t bssl::ext_supported_groups_parse_serverhello()
{
  return 1LL;
}

uint64_t bssl::ext_alpn_parse_serverhello(uint64_t *a1, char *a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (!a3)
  {
    if (*(void *)(v4 + 168))
    {
      ERR_put_error(16, 0, 307, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1411);
      uint64_t result = 0LL;
      char v13 = 120;
LABEL_18:
      *a2 = v13;
      return result;
    }

    return 1LL;
  }

  if ((*(_WORD *)(*(void *)(v4 + 48) + 220LL) & 0x20) != 0) {
    bssl::ext_alpn_parse_serverhello();
  }
  if (!*(void *)(a1[1] + 136)) {
    bssl::ext_alpn_parse_serverhello();
  }
  if ((*((_BYTE *)a1 + 1585) & 0x40) != 0)
  {
    *a2 = 47;
    ERR_put_error(16, 0, 170, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1424);
    return 0LL;
  }

  memset(v14, 170, sizeof(v14));
  uint64_t result = CBS_get_u16_length_prefixed((unsigned __int8 **)a3, &v14[2]);
  if (!(_DWORD)result) {
    return result;
  }
  if (*(void *)(a3 + 8)) {
    return 0LL;
  }
  uint64_t result = CBS_get_u8_length_prefixed((unsigned __int8 **)&v14[2], v14);
  if ((_DWORD)result)
  {
    uint64_t result = 0LL;
    if (v14[1])
    {
      if (!v14[3])
      {
        if ((bssl::ssl_is_alpn_protocol_allowed(a1, (const void *)v14[0], v14[1]) & 1) == 0)
        {
          ERR_put_error(16, 0, 259, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1441);
          char v13 = 47;
          goto LABEL_24;
        }

        int v8 = (void **)(*(void *)(v4 + 48) + 496LL);
        uint64_t v9 = (const void *)v14[0];
        size_t v10 = v14[1];
        int v11 = bssl::Array<unsigned char>::Init((uint64_t)v8, v14[1]);
        char v12 = v11;
        if (v10)
        {
          if (v11) {
            memmove(*v8, v9, v10);
          }
        }

        if ((v12 & 1) == 0)
        {
          char v13 = 80;
LABEL_24:
          uint64_t result = 0LL;
          goto LABEL_18;
        }

        return 1LL;
      }
    }
  }

  return result;
}

uint64_t bssl::ssl_is_alpn_protocol_allowed(void *a1, const void *a2, size_t a3)
{
  uint64_t v3 = a1[1];
  uint64_t v4 = *(void *)(v3 + 136);
  if (!v4) {
    return 0LL;
  }
  if ((*(_WORD *)(*(void *)(*a1 + 120LL) + 832LL) & 0x80) != 0) {
    return 1LL;
  }
  size_t v10 = *(unsigned __int8 **)(v3 + 128);
  uint64_t v11 = v4;
  __s1 = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  while (1)
  {
    uint64_t result = CBS_get_u8_length_prefixed(&v10, (unint64_t *)&__s1);
    if (!(_DWORD)result) {
      break;
    }
    if (v9 == a3 && !memcmp(__s1, a2, a3)) {
      return 1LL;
    }
    if (!v11) {
      return 0LL;
    }
  }

  return result;
}

uint64_t bssl::ext_ech_parse_serverhello(bssl **a1, ssl_st *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  BOOL v6 = *a1;
  if (bssl::ssl_protocol_version(*a1, a2) < 0x304 || *(_DWORD *)(*((void *)v6 + 6) + 216LL) == 1)
  {
    LOBYTE(a2->version) = 110;
    ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 629);
    return 0LL;
  }

  if ((bssl::ssl_is_valid_ech_config_list(*(unsigned __int8 **)a3, *(void *)(a3 + 8)) & 1) != 0)
  {
    if (*(_DWORD *)(*((void *)v6 + 6) + 216LL) != 2) {
      return 1LL;
    }
    int v8 = (void **)(a1 + 73);
    size_t v10 = *(unsigned __int8 **)a3;
    unint64_t v9 = *(void *)(a3 + 8);
    int v11 = bssl::Array<unsigned char>::Init((uint64_t)v8, v9);
    char v12 = v11;
    if (v9)
    {
      if (v11) {
        memmove(*v8, v10, v9);
      }
    }

    if ((v12 & 1) != 0) {
      return 1LL;
    }
    uint64_t result = 0LL;
    char v13 = 80;
  }

  else
  {
    uint64_t result = 0LL;
    char v13 = 50;
  }

  LOBYTE(a2->version) = v13;
  return result;
}

uint64_t bssl::ext_ems_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  BOOL v5 = *(bssl **)a1;
  if (a3)
  {
    *(_DWORD *)(a1 + 1584) |= 0x10000u;
  }

  uint64_t v8 = *(void *)(*((void *)v5 + 6) + 472LL);
  if (!v8 || (HIWORD(*(_DWORD *)(a1 + 1584)) & 1) == (*(_BYTE *)(v8 + 440) & 1)) {
    return 1LL;
  }
  ERR_put_error(16, 0, 263, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 903);
  uint64_t result = 0LL;
  LOBYTE(a2->version) = 47;
  return result;
}

uint64_t bssl::ext_ri_parse_serverhello(bssl **a1, ssl_st *a2, uint64_t a3)
{
  BOOL v5 = *a1;
  uint64_t v6 = *((void *)v5 + 6);
  __int16 v7 = *(_WORD *)(v6 + 220);
  if ((v7 & 0x20) != 0 && (a3 != 0) == ((v7 & 0x80) == 0))
  {
    LOBYTE(a2->version) = 40;
    ERR_put_error(16, 0, 202, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 741);
    return 0LL;
  }

  else
  {
    if (a3)
    {
      uint64_t v8 = *(unsigned __int8 *)(v6 + 455);
      uint64_t v9 = *(unsigned __int8 *)(v6 + 456);
      uint64_t v10 = v9 + v8;
      if ((_DWORD)v8) {
        BOOL v11 = 1;
      }
      else {
        BOOL v11 = v10 == 0;
      }
      if (!v11) {
        bssl::ext_ri_parse_serverhello();
      }
      if ((_DWORD)v9) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = v10 == 0;
      }
      if (!v12) {
        bssl::ext_ri_parse_serverhello();
      }
      unsigned int v13 = v7 & 0x20;
      if (((_DWORD)v8 != 0) != v13 >> 5) {
        bssl::ext_ri_parse_serverhello();
      }
      if (((_DWORD)v9 != 0) != v13 >> 5) {
        bssl::ext_ri_parse_serverhello();
      }
      uint64_t v18 = (char *)0xAAAAAAAAAAAAAAAALL;
      unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
      if (!CBS_get_u8_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&v18)
        || *(void *)(a3 + 8))
      {
        ERR_put_error(16, 0, 201, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 771);
LABEL_21:
        uint64_t result = 0LL;
        char v15 = 47;
LABEL_22:
        LOBYTE(a2->version) = v15;
        return result;
      }

      if (v19 != v10)
      {
        int v17 = 778;
        goto LABEL_28;
      }

      __int128 v16 = v18;
      if (CRYPTO_memcmp( v18,  (char *)(*((void *)v5 + 6) + 443LL),  *(unsigned __int8 *)(*((void *)v5 + 6) + 455LL)))
      {
        int v17 = 790;
LABEL_28:
        ERR_put_error(16, 0, 202, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v17);
        uint64_t result = 0LL;
        char v15 = 40;
        goto LABEL_22;
      }

      if (CRYPTO_memcmp( &v16[*(unsigned __int8 *)(*((void *)v5 + 6) + 455LL)],  (char *)(*((void *)v5 + 6) + 457LL),  *(unsigned __int8 *)(*((void *)v5 + 6) + 456LL)))
      {
        int v17 = 802;
        goto LABEL_28;
      }

      *(_WORD *)(*((void *)v5 + 6) + 220LL) |= 0x80u;
    }

    return 1LL;
  }

uint64_t bssl::ext_ec_point_parse_serverhello(bssl **a1, ssl_st *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  __unsigned int s = (void *)0xAAAAAAAAAAAAAAAALL;
  size_t __n = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBS_get_u8_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&__s);
  if (!(_DWORD)result) {
    return result;
  }
  if (*(void *)(a3 + 8)) {
    return 0LL;
  }
  if (__n && memchr(__s, 0, __n)) {
    return 1LL;
  }
  uint64_t result = 0LL;
  LOBYTE(a2->version) = 47;
  return result;
}

uint64_t bssl::ext_ticket_parse_serverhello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  if (a3)
  {
    BOOL v5 = *(bssl **)a1;
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 1584) |= 0x8000u;
  }

  return 1LL;
}

BOOL bssl::ext_ocsp_parse_serverhello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  BOOL result = bssl::ssl_cipher_uses_certificate_auth(*(bssl **)(a1 + 1552), v5);
  if (result)
  {
    *(_DWORD *)(a1 + 1584) |= 0x40u;
    return 1LL;
  }

  return result;
}

BOOL bssl::forbid_parse_serverhello(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  if (a3)
  {
    *a2 = 110;
    ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 504);
  }

  return a3 == 0;
}

uint64_t bssl::ext_npn_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v6 = *(bssl **)a1;
  if ((*(_WORD *)(*((void *)v6 + 6) + 220LL) & 0x20) != 0) {
    bssl::ext_npn_parse_serverhello();
  }
  uint64_t v7 = *((void *)v6 + 15);
  uint64_t v8 = *(unsigned int (**)(bssl *, const void **, unsigned __int8 *, unsigned __int8 *, uint64_t, void))(v7 + 592);
  if (!v8) {
    bssl::ext_npn_parse_serverhello();
  }
  if (*(void *)(*((void *)v6 + 6) + 504LL))
  {
    LOBYTE(a2->version) = 47;
    ERR_put_error(16, 0, 170, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1194);
    return 0LL;
  }

  uint64_t v10 = *(unsigned __int8 **)a3;
  uint64_t v11 = *(void *)(a3 + 8);
  if (!v11)
  {
LABEL_14:
    unint64_t v19 = (const void *)0xAAAAAAAAAAAAAAAALL;
    unsigned __int8 v18 = -86;
    if (v8(v6, &v19, &v18, v10, v11, *(void *)(v7 + 600))) {
      goto LABEL_22;
    }
    unsigned int v13 = (void **)(*((void *)v6 + 6) + 480LL);
    uint64_t v14 = v19;
    size_t v15 = v18;
    int v16 = bssl::Array<unsigned char>::Init((uint64_t)v13, v18);
    char v17 = v16;
    if (v15)
    {
      if (v16) {
        memmove(*v13, v14, v15);
      }
    }

    if ((v17 & 1) == 0)
    {
LABEL_22:
      uint64_t result = 0LL;
      LOBYTE(a2->version) = 80;
      return result;
    }

    *(_DWORD *)(a1 + 1584) |= 0x4000u;
    return 1LL;
  }

  while (1)
  {
    unint64_t v19 = (const void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    int u8_length_prefixed = CBS_get_u8_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&v19);
    uint64_t result = 0LL;
    if (!u8_length_prefixed || !v20) {
      return result;
    }
    if (!*(void *)(a3 + 8))
    {
      uint64_t v7 = *((void *)v6 + 15);
      uint64_t v8 = *(unsigned int (**)(bssl *, const void **, unsigned __int8 *, unsigned __int8 *, uint64_t, void))(v7 + 592);
      goto LABEL_14;
    }
  }

uint64_t bssl::ext_sct_parse_serverhello(uint64_t a1, ssl_st *a2, __int128 *a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v6 = *(bssl **)a1;
  if ((*(_WORD *)(*(void *)(a1 + 8) + 301LL) & 2) == 0) {
    bssl::ext_sct_parse_serverhello();
  }
  if (bssl::ssl_is_sct_list_valid(a3))
  {
    if ((*(_WORD *)(*((void *)v6 + 6) + 220LL) & 0x40) != 0) {
      return 1LL;
    }
    uint64_t v7 = (unsigned int **)(*(void *)(a1 + 1520) + 248LL);
    uint64_t v8 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)a3, *(void ***)(*((void *)v6 + 15) + 776LL));
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](v7, v8);
    if (*(void *)(*(void *)(a1 + 1520) + 248LL)) {
      return 1LL;
    }
    char v10 = 80;
  }

  else
  {
LABEL_8:
    char v10 = 50;
  }

  uint64_t result = 0LL;
  LOBYTE(a2->version) = v10;
  return result;
}

uint64_t bssl::ext_channel_id_parse_serverhello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (!*(void *)(*(void *)(a1 + 8) + 120LL)) {
      bssl::ext_channel_id_parse_serverhello();
    }
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 1584) |= 0x2000000u;
  }

  return 1LL;
}

uint64_t bssl::ext_srtp_parse_serverhello(unsigned __int8 ***a1, _BYTE *a2, uint64_t a3)
{
  if (a3)
  {
    BOOL v5 = *a1;
    memset(v15, 170, sizeof(v15));
    unsigned __int16 v14 = -21846;
    if (!CBS_get_u16_length_prefixed((unsigned __int8 **)a3, &v15[2])
      || !CBS_get_u16((unsigned __int16 **)&v15[2], &v14)
      || v15[3]
      || !CBS_get_u8_length_prefixed((unsigned __int8 **)a3, v15)
      || *(void *)(a3 + 8))
    {
      ERR_put_error(16, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1735);
      return 0LL;
    }

    if (v15[1])
    {
      int v7 = 115;
      int v8 = 1741;
LABEL_16:
      ERR_put_error(16, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v8);
      uint64_t result = 0LL;
      *a2 = 47;
      return result;
    }

    srtp_profileunsigned int s = (EVP_MD_CTX *)SSL_get_srtp_profiles((uint64_t)v5);
    char v10 = EVP_MD_CTX_md(srtp_profiles);
    if (!v10)
    {
LABEL_15:
      int v7 = 116;
      int v8 = 1754;
      goto LABEL_16;
    }

    uint64_t v11 = v10;
    unint64_t v12 = 0LL;
    while (1)
    {
      unsigned int v13 = OPENSSL_sk_value((unint64_t *)srtp_profiles, v12);
      if (v13[1] == v14) {
        break;
      }
      if (v11 == (const EVP_MD *)++v12) {
        goto LABEL_15;
      }
    }

    *((void *)v5[6] + 75) = v13;
  }

  return 1LL;
}

uint64_t bssl::ext_early_data_parse_serverhello(uint64_t *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if (a3)
  {
    uint64_t v4 = *(void *)(v3 + 48);
    __int16 v5 = *(_WORD *)(v4 + 220);
    if ((v5 & 0x2000) != 0) {
      bssl::ext_early_data_parse_serverhello();
    }
    if (*(void *)(a3 + 8))
    {
      uint64_t result = 0LL;
      *a2 = 50;
      return result;
    }

    if ((v5 & 0x40) == 0)
    {
      *a2 = 110;
      ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2198);
      return 0LL;
    }

    *(_DWORD *)(v4 + bssl::Array<unsigned short>::~Array(v16 + 256) = 2;
    *(_WORD *)(v4 + 220) = v5 | 0x400;
  }

  else
  {
    uint64_t v7 = *(void *)(v3 + 48);
    if ((*((_BYTE *)a1 + 1585) & 8) == 0 || (__int16 v8 = *(_WORD *)(v7 + 220), (v8 & 0x2000) != 0))
    {
      if (!*(_DWORD *)(v7 + 256)) {
        bssl::ext_early_data_parse_serverhello();
      }
    }

    else
    {
      if ((v8 & 0x40) != 0) {
        int v9 = 4;
      }
      else {
        int v9 = 6;
      }
      *(_DWORD *)(v7 + bssl::Array<unsigned short>::~Array(v16 + 256) = v9;
    }
  }

  return 1LL;
}

uint64_t bssl::ext_quic_transport_params_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_serverhello_impl(a1, a2, a3, 0);
}

uint64_t bssl::ext_quic_transport_params_parse_serverhello_impl(uint64_t a1, ssl_st *a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(bssl **)a1;
  if (!a3)
  {
    if (((*(_WORD *)(*(void *)(a1 + 8) + 301LL) & 0x200) == 0) != a4 && *((void *)v6 + 21))
    {
      uint64_t result = 0LL;
      LOBYTE(a2->version) = 109;
      return result;
    }

    return 1LL;
  }

  if (!*((void *)v6 + 21)) {
    bssl::ext_quic_transport_params_parse_serverhello_impl();
  }
  __int16 v8 = (void **)(*((void *)v6 + 6) + 584LL);
  int v9 = *(const void **)a3;
  unint64_t v10 = *(void *)(a3 + 8);
  uint64_t result = bssl::Array<unsigned char>::Init((uint64_t)v8, v10);
  if (v10 && (_DWORD)result)
  {
    memmove(*v8, v9, v10);
    return 1LL;
  }

  return result;
}

uint64_t bssl::ext_quic_transport_params_parse_serverhello_legacy(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_serverhello_impl(a1, a2, a3, 1);
}

BOOL bssl::cert_compression_parse_serverhello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 == 0;
}

uint64_t bssl::ext_alps_parse_serverhello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_alps_parse_serverhello_impl(a1, a2, a3, 1);
}

uint64_t bssl::ext_client_certificate_type_parse_serverhello(uint64_t a1, _BYTE *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 200);
  if (!v5) {
    return 1LL;
  }
  if (a3)
  {
    v10[0] = *(void *)(v4 + 192);
    v10[1] = v5;
    unsigned __int8 v9 = -86;
    if (CBS_get_u8(a3, &v9) && bssl::ssl_is_certificate_type_allowed(v10, v9))
    {
      *(_BYTE *)(a1 + 731) = v9;
      *(_DWORD *)(a1 + 1584) |= 0x400000u;
      return 1LL;
    }

    int v8 = 3330;
  }

  else
  {
    int v8 = 3313;
  }

  ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v8);
  uint64_t result = 0LL;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_server_certificate_type_parse_serverhello(uint64_t a1, _BYTE *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 176);
  if (!v5) {
    return 1LL;
  }
  if (a3)
  {
    v10[0] = *(void *)(v4 + 168);
    v10[1] = v5;
    unsigned __int8 v9 = -86;
    if (CBS_get_u8(a3, &v9) && bssl::ssl_is_certificate_type_allowed(v10, v9))
    {
      *(_BYTE *)(a1 + 730) = v9;
      *(_DWORD *)(a1 + 1584) |= 0x200000u;
      return 1LL;
    }

    int v8 = 3210;
  }

  else
  {
    int v8 = 3193;
  }

  ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v8);
  uint64_t result = 0LL;
  *a2 = 47;
  return result;
}

BOOL bssl::ext_ticket_request_parse_serverhello(uint64_t a1, _BYTE *a2, void *a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (!*(_BYTE *)(v6 + 216) && !*(_BYTE *)(v6 + 217)) {
    return 1LL;
  }
  char v8 = -86;
  int u8 = CBS_get_u8(a3, &v8);
  BOOL result = u8 != 0;
  if (u8) {
    *(_BYTE *)(a1 + 734) = v8;
  }
  else {
    *a2 = 47;
  }
  return result;
}

uint64_t bssl::tls13_process_certificate(EVP_PKEY **a1, uint64_t a2, char a3)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *a1;
  __int128 v88 = *(_OWORD *)(a2 + 8);
  unint64_t v87 = 0LL;
  int v6 = *(unsigned __int8 *)(a2 + 1);
  if (v6 == 25)
  {
    v79[0] = (EVP_PKEY *)0xAAAAAAAAAAAAAAAALL;
    v79[1] = (EVP_PKEY *)0xAAAAAAAAAAAAAAAALL;
    LOWORD(v86[0]) = -21846;
    LODWORD(v86[2]) = -1431655766;
    if (!CBS_get_u16((unsigned __int16 **)&v88, v86)
      || !CBS_get_u24((uint64_t *)&v88, (int *)&v86[2])
      || !CBS_get_u24_length_prefixed((unsigned __int8 **)&v88, (unint64_t *)v79)
      || *((void *)&v88 + 1))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 144);
      goto LABEL_18;
    }

    if (LODWORD(v86[2]) > LODWORD(v5[3].attributes))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
      ERR_put_error(16, 0, 293, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 150);
      ERR_add_error_dataf("requested=%u", v7, v8, v9, v10, v11, v12, v13, (char)v86[2]);
LABEL_18:
      uint64_t v15 = 0LL;
      goto LABEL_110;
    }

    uint64_t v16 = *(void *)&v5[3].type;
    uint64_t v17 = *(void *)(v16 + 704);
    if (!v17) {
      goto LABEL_79;
    }
    unsigned __int8 v18 = (unsigned __int16 *)(*(void *)(v16 + 712) + 16LL);
    uint64_t v19 = 24 * v17;
    while (*v18 != LOWORD(v86[0]))
    {
      v18 += 12;
      v19 -= 24LL;
      if (!v19) {
        goto LABEL_79;
      }
    }

    unsigned __int8 v42 = (unsigned int (*)(EVP_PKEY *, unsigned int **))*((void *)v18 - 1);
    if (!v42)
    {
LABEL_79:
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
      ERR_put_error(16, 0, 294, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 166);
      ERR_add_error_dataf("alg=%d", v46, v47, v48, v49, v50, v51, v52, (char)v86[0]);
      goto LABEL_18;
    }

    BOOL v77 = 0LL;
    if (!v42(v5, &v77))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 292, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 175);
      ERR_add_error_dataf("alg=%d", v54, v55, v56, v57, v58, v59, v60, (char)v86[0]);
      goto LABEL_18;
    }

    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v87, v77);
    uint64_t v43 = CRYPTO_BUFFER_len((uint64_t)v77);
    if (v43 != LODWORD(v86[2]))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 292, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 183);
      char v61 = (char)v86[0];
      CRYPTO_BUFFER_len((uint64_t)v77);
      ERR_add_error_dataf("alg=%d got=%u expected=%u", v62, v63, v64, v65, v66, v67, v68, v61);
      goto LABEL_18;
    }

    uint64_t v44 = CRYPTO_BUFFER_data((uint64_t)v77);
    uint64_t v45 = CRYPTO_BUFFER_len((uint64_t)v77);
    *(void *)&__int128 v88 = v44;
    *((void *)&v88 + 1) = v45;
  }

  else if (v6 != 11)
  {
    __assert_rtn("tls13_process_certificate", "tls13_both.cc", 194, "msg.type == SSL3_MT_CERTIFICATE");
  }

  memset(v86, 170, sizeof(v86));
  if (!CBS_get_u8_length_prefixed((unsigned __int8 **)&v88, (unint64_t *)&v86[2])
    || v86[3]
    || !CBS_get_u24_length_prefixed((unsigned __int8 **)&v88, (unint64_t *)v86)
    || *((void *)&v88 + 1))
  {
    bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 203);
    uint64_t v15 = 0LL;
    goto LABEL_110;
  }

  EVP_MD_CTX ctx = (EVP_MD_CTX *)0xAAAAAAAAAAAAAAAALL;
  EVP_MD_CTX ctx = (EVP_MD_CTX *)OPENSSL_sk_new_null();
  if (!ctx)
  {
    bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
    uint64_t v15 = 0LL;
    goto LABEL_109;
  }

  __int128 v84 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
  __int128 v84 = OPENSSL_sk_new_null();
  if (!v84)
  {
    bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
    ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 217);
    uint64_t v15 = 0LL;
    goto LABEL_108;
  }

  if ((BYTE4(v5[4].pkey.dh) & 1) != 0) {
    int v14 = (*(unsigned __int16 *)((char *)&a1[1][7].pkey.ec + 5) >> 5) & 1;
  }
  else {
    int v14 = 0;
  }
  __int128 v83 = 0LL;
  if (!v86[1])
  {
LABEL_67:
    if (!EVP_MD_CTX_md(ctx)) {
      std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)&ctx,  0LL);
    }
    uint64_t v36 = v83;
    __int128 v83 = 0LL;
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](a1 + 189, v36);
    p_pkey = (unint64_t **)&a1[190][3].pkey;
    uint64_t v38 = (unint64_t *)ctx;
    EVP_MD_CTX ctx = 0LL;
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](p_pkey, v38);
    p_save_parameterunsigned int s = (unint64_t **)&a1[190][6].save_parameters;
    uint64_t v40 = v84;
    __int128 v84 = 0LL;
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](p_save_parameters, v40);
    if (((*(uint64_t (**)(EVP_PKEY *))(*(void *)(*(void *)&v5[3].type + 16LL) + 48LL))(a1[190]) & 1) != 0)
    {
      if (EVP_MD_CTX_md((const EVP_MD_CTX *)a1[190][3].pkey.ptr))
      {
        if (v14) {
          char v41 = 2;
        }
        else {
          char v41 = 0;
        }
        LOBYTE(a1[190][11].type) = a1[190][11].type & 0xFD | v41;
        goto LABEL_85;
      }

      if ((a3 & 1) != 0
        || (int v69 = *((_DWORD *)a1 + 396), (v69 & 0x200000) != 0) && *((_BYTE *)a1 + 730) == 2
        || (v69 & 0x400000) != 0 && *((_BYTE *)a1 + 731) == 2)
      {
        a1[190][4].pkey.ptr = 0LL;
LABEL_85:
        uint64_t v15 = 1LL;
        goto LABEL_107;
      }

      ERR_put_error(16, 0, 192, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 380);
      int v29 = 116;
    }

    else
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 365);
      int v29 = 50;
    }

LABEL_81:
    bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, v29);
    goto LABEL_106;
  }

  while (1)
  {
    memset(v82, 170, sizeof(v82));
    if (!CBS_get_u24_length_prefixed(v86, (unint64_t *)&v82[1])
      || !CBS_get_u16_length_prefixed(v86, (unint64_t *)v82)
      || !*((void *)&v82[1] + 1))
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      int v70 = 231;
      int v53 = 127;
      goto LABEL_105;
    }

    int v20 = *((_DWORD *)a1 + 396);
    if ((v20 & 0x200000) != 0 && *((_BYTE *)a1 + 730) == 2)
    {
      uint64_t v21 = EVP_parse_public_key(&v82[1]);
      v79[0] = 0LL;
      std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v83, v21);
      std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v79, 0LL);
      if (!v83)
      {
        bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
        int v70 = 241;
        goto LABEL_104;
      }

      goto LABEL_45;
    }

    if ((v20 & 0x400000) == 0 || *((_BYTE *)a1 + 731) != 2) {
      break;
    }
    uint64_t v22 = EVP_parse_public_key(&v82[1]);
    v79[0] = 0LL;
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v83, v22);
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v79, 0LL);
    if (!v83)
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
      int v70 = 250;
      goto LABEL_104;
    }

  uint64_t v51 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v49 = -1431655766;
  if (v49)
  {
    unsigned int v25 = (_BYTE *)(v64 + 440);
    int v26 = *(_BYTE *)(v64 + 440);
    if (v49)
    {
      int v27 = 8;
      goto LABEL_90;
    }
  }

  else
  {
    if (v52) {
      goto LABEL_18;
    }
    unsigned int v25 = (_BYTE *)(v64 + 440);
    int v26 = *(_BYTE *)(v64 + 440);
  }

  int v27 = 0;
LABEL_90:
  char *v25 = v26 & 0xF7 | v27;
  uint64_t v48 = -1431655766;
  if (!CBS_get_optional_asn1_BOOL(&v63[1], &v48, -1610612714, 1))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 734);
    goto LABEL_18;
  }

  uint64_t v28 = v64;
  *(_BYTE *)(v64 + 440) = *(_BYTE *)(v64 + 440) & 0xEF | (16 * (v48 != 0));
  uint64_t v47 = -1431655766;
  if (!bssl::SSL_SESSION_parse_u16(&v63[1], (_WORD *)(v28 + 8), -1610612713)
    || !bssl::SSL_SESSION_parse_u32(&v63[1], (_DWORD *)(v64 + 380), -1610612712, 0)
    || !bssl::SSL_SESSION_parse_u32(&v63[1], (_DWORD *)(v64 + 188), -1610612711, *(_DWORD *)(v64 + 184))
    || !bssl::SSL_SESSION_parse_octet_string(&v63[1], (void **)(v64 + 392), -1610612710)
    || !CBS_get_optional_asn1_BOOL(&v63[1], &v47, -1610612709, 0)
    || (bssl::SSL_SESSION_parse_octet_string(&v63[1], (void **)(v64 + 448), -1610612708) & 1) == 0)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 755);
    goto LABEL_18;
  }

  memset(v46, 170, sizeof(v46));
  int v29 = v46[1];
  uint64_t v30 = v46[2];
  size_t v31 = (void **)(v64 + 408);
  __int128 v32 = bssl::Array<unsigned char>::Init(v64 + 408, (unint64_t)v46[2]);
  int v33 = v32 ^ 1;
  if (!v30) {
    int v33 = 1;
  }
  if ((v33 & 1) == 0) {
    memmove(*v31, v29, (size_t)v30);
  }
  int v34 = v46[1];
  uint64_t v35 = v46[2];
  uint64_t v36 = (void **)(v64 + 424);
  uint64_t v37 = bssl::Array<unsigned char>::Init(v64 + 424, (unint64_t)v46[2]);
  uint64_t v38 = v37 ^ 1;
  if (!v35) {
    uint64_t v38 = 1;
  }
  if ((v38 & 1) == 0) {
    memmove(*v36, v34, (size_t)v35);
  }
  uint64_t v39 = *((void *)&v63[1] + 1) ? 0 : v37;
  if ((v39 & 1) == 0)
  {
LABEL_126:
    uint64_t v45 = 768;
LABEL_127:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", v45);
    uint64_t v43 = 0LL;
    goto LABEL_128;
  }

  uint64_t v40 = v64;
  char v41 = *(_BYTE *)(v64 + 440) & 0xDF | (32 * (v47 != 0));
  *(_BYTE *)(v64 + 440) = v41;
  unsigned __int8 v42 = BYTE4(v46[0]);
  if (HIDWORD(v46[0]) != LODWORD(v46[0])) {
    goto LABEL_129;
  }
  if (!HIDWORD(v46[0])) {
    goto LABEL_116;
  }
  if (!*(void *)(v40 + 400))
  {
LABEL_129:
    uint64_t v45 = 776;
    goto LABEL_127;
  }

  unsigned __int8 v42 = 64;
LABEL_116:
  *(_BYTE *)(v40 + 440) = v42 | v41 & 0x3F;
  if ((a2[6]() & 1) == 0)
  {
    uint64_t v45 = 785;
    goto LABEL_127;
  }

  uint64_t v43 = v64;
  uint64_t v64 = 0LL;
LABEL_128:
  *a4 = v43;
LABEL_19:
  uint64_t v10 = (SSL_SESSION *)v64;
  uint64_t v64 = 0LL;
  if (v10) {
    SSL_SESSION_free(v10);
  }
}

LABEL_45:
    uint64_t v24 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v82[1], *(void ***)(*(void *)&v5[3].type + 776LL));
    uint64_t v81 = v24;
    if (!v24) {
      goto LABEL_89;
    }
    int64x2_t v80 = v24;
    uint64_t v81 = 0LL;
    if (!OPENSSL_sk_push((unint64_t *)ctx, (uint64_t)v24))
    {
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v80, 0LL);
LABEL_89:
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
      goto LABEL_106;
    }

    int64x2_t v80 = 0LL;
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v80, 0LL);
    memset(v79, 170, sizeof(v79));
    if ((BYTE4(v5[4].pkey.dh) & 1) != 0)
    {
      LOBYTE(v26) = 0;
      LOBYTE(v27) = 0;
      v79[1] = 0LL;
      v79[2] = 0LL;
      BOOL v77 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
    }

    else
    {
      unsigned int v25 = *(unsigned __int16 *)((char *)&a1[1][7].pkey.ec + 5);
      int v26 = (v25 >> 2) & 1;
      v79[1] = 0LL;
      v79[2] = 0LL;
      BOOL v77 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
      int v27 = (v25 >> 1) & 1;
    }

    LOWORD(v79[0]) = 5;
    WORD1(v79[0]) = v26;
    LOWORD(v77) = 18;
    WORD1(v77) = v27;
    __int128 v78 = 0uLL;
    unsigned __int8 v76 = 50;
    __int128 v89 = v79;
    int64x2_t v90 = &v77;
    if ((bssl::ssl_parse_extensions(v82, (char *)&v76, (uint64_t *)&v89, 2LL, 0) & 1) == 0)
    {
      int v29 = v76;
      goto LABEL_81;
    }

    if (BYTE3(v79[0]))
    {
      char v75 = -86;
      __int128 v89 = (EVP_PKEY **)0xAAAAAAAAAAAAAAAALL;
      int64x2_t v90 = (unsigned int **)0xAAAAAAAAAAAAAAAALL;
      int u8 = CBS_get_u8(&v79[1], &v75);
      int v29 = 50;
      if (!u8) {
        goto LABEL_81;
      }
      if (v75 != 1) {
        goto LABEL_81;
      }
      int u24_length_prefixed = CBS_get_u24_length_prefixed((unsigned __int8 **)&v79[1], (unint64_t *)&v89);
      int v29 = 50;
      if (!u24_length_prefixed || !v90 || v79[2]) {
        goto LABEL_81;
      }
      if (EVP_MD_CTX_md(ctx) == (const EVP_MD *)1)
      {
        size_t v31 = a1[190];
        __int128 v32 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v89, *(void ***)(*(void *)&v5[3].type + 776LL));
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]( (unsigned int **)&v31[6].pkey,  v32);
        if (!a1[190][6].pkey.ptr)
        {
          int v29 = 80;
          goto LABEL_81;
        }
      }

      uint64_t v74 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
      int v33 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v89, *(void ***)(*(void *)&v5[3].type + 776LL));
      uint64_t v74 = v33;
      if (!v33) {
        goto LABEL_98;
      }
      unint64_t v73 = v33;
      uint64_t v74 = 0LL;
      if (!OPENSSL_sk_push(v84, (uint64_t)v33))
      {
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v73, 0LL);
LABEL_98:
        bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 80);
        ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 328);
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v74, 0LL);
        goto LABEL_106;
      }

      unint64_t v73 = 0LL;
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v73, 0LL);
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v74, 0LL);
    }

    if (BYTE3(v77))
    {
      if ((bssl::ssl_is_sct_list_valid(&v78) & 1) == 0)
      {
        ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 336);
        int v29 = 50;
        goto LABEL_81;
      }

      if (EVP_MD_CTX_md(ctx) == (const EVP_MD *)1)
      {
        int v34 = a1[190];
        uint64_t v35 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v78, *(void ***)(*(void *)&v5[3].type + 776LL));
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]( (unsigned int **)&v34[6].references,  v35);
        if (!*(void *)&a1[190][6].references)
        {
          int v29 = 80;
          goto LABEL_81;
        }
      }
    }

    if (!v86[1]) {
      goto LABEL_67;
    }
  }

  if (EVP_MD_CTX_md(ctx)) {
    goto LABEL_45;
  }
  bssl::ssl_cert_parse_pubkey(&v82[1], v79);
  uint64_t v23 = v79[0];
  v79[0] = 0LL;
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v83, v23);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](v79, 0LL);
  if (v83)
  {
    if ((bssl::ssl_cert_check_key_usage(&v82[1], 0) & 1) == 0)
    {
      bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 47);
      goto LABEL_106;
    }

    if (v14) {
      SHA256(*(const unsigned __int8 **)&v82[1], *((size_t *)&v82[1] + 1), (unsigned __int8 *)&a1[190][6].attributes);
    }
    goto LABEL_45;
  }

  bssl::ssl_send_alert((bssl *)v5, (ssl_st *)2, 50);
  int v70 = 259;
LABEL_104:
  int v53 = 137;
LABEL_105:
  ERR_put_error(16, 0, v53, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", v70);
LABEL_106:
  uint64_t v15 = 0LL;
LABEL_107:
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](&v83, 0LL);
LABEL_108:
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&v84, 0LL);
LABEL_109:
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)&ctx, 0LL);
LABEL_110:
  unint64_t v71 = v87;
  unint64_t v87 = 0LL;
  if (v71) {
    CRYPTO_BUFFER_free(v71);
  }
  return v15;
}

    uint64_t v8 = 0LL;
    goto LABEL_46;
  }

  BN_zero((uint64_t)a1);
  return 1LL;
}

        goto LABEL_78;
      }
    }

    unsigned int v25 = 0LL;
    int v26 = 1;
    goto LABEL_39;
  }

    if (!*(_BYTE *)(a2 + 26) && (v20 == 1 || *(_DWORD *)(result + 16) == 50380839)) {
      goto LABEL_24;
    }
LABEL_48:
    uint64_t v23 = v16 + 2;
    if (a3 == 4)
    {
      if (*((_BYTE *)v16 + 8))
      {
        uint64_t v11 = v35;
        if (v12 != v16)
        {
          int v26 = v16[2];
          int v27 = v16[3];
          if (v35 == v16) {
            uint64_t v11 = (uint64_t *)v16[2];
          }
          if (v27)
          {
            *(void *)(v27 + 16) = v26;
            int v26 = *v23;
          }

          if (v26) {
            *(void *)(v26 + 24) = v27;
          }
          v12[2] = (uint64_t)v16;
          _OWORD v16[2] = 0LL;
          _OWORD v16[3] = (uint64_t)v12;
          uint64_t v12 = v16;
        }

        *((_BYTE *)v16 + 9) = 0;
        goto LABEL_82;
      }
    }

    else
    {
      if (a3 != 1)
      {
        if (a3 == 3)
        {
          uint64_t v11 = v35;
          if (*((_BYTE *)v16 + 8))
          {
            if (v35 != v16)
            {
              int v29 = v16[2];
              uint64_t v28 = v16[3];
              if (v12 == v16) {
                uint64_t v12 = (uint64_t *)v16[3];
              }
              if (v29)
              {
                *(void *)(v29 + 24) = v28;
                uint64_t v28 = v16[3];
              }

              if (v28) {
                *(void *)(v28 + 16) = v29;
              }
              v35[3] = (uint64_t)v16;
              _OWORD v16[2] = (uint64_t)v35;
              _OWORD v16[3] = 0LL;
              uint64_t v11 = v16;
            }

            *((_WORD *)v16 + 4) = 0;
          }
        }

        else
        {
          uint64_t v11 = v35;
          if (a3 == 2)
          {
            uint64_t v30 = (uint64_t *)v16[3];
            if (v35 == v16) {
              uint64_t v11 = (uint64_t *)v16[2];
            }
            else {
              v30[2] = v16[2];
            }
            if (v12 == v16) {
              uint64_t v12 = v30;
            }
            *((_BYTE *)v16 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0;
            size_t v31 = v16[2];
            if (v31)
            {
              *(void *)(v31 + 24) = v30;
              uint64_t v30 = (uint64_t *)v16[3];
            }

            if (v30) {
              v30[2] = v31;
            }
            EVP_PKEY *v23 = 0LL;
            _OWORD v16[3] = 0LL;
          }
        }

        goto LABEL_82;
      }

      if (!*((_BYTE *)v16 + 8))
      {
        uint64_t v11 = v35;
        if (v12 != v16)
        {
          uint64_t v24 = v16[2];
          unsigned int v25 = v16[3];
          if (v35 == v16) {
            uint64_t v11 = (uint64_t *)v16[2];
          }
          if (v25)
          {
            *(void *)(v25 + 16) = v24;
            uint64_t v24 = *v23;
          }

          if (v24) {
            *(void *)(v24 + 24) = v25;
          }
          v12[2] = (uint64_t)v16;
          _OWORD v16[2] = 0LL;
          _OWORD v16[3] = (uint64_t)v12;
          uint64_t v12 = v16;
        }

        *((_BYTE *)v16 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 1;
        *((_BYTE *)v16 + 9) = a5;
        goto LABEL_82;
      }
    }

    uint64_t v11 = v35;
LABEL_82:
    if (v16 == v14)
    {
      a6 = v33;
      a7 = v34;
    }

    else
    {
      a6 = v33;
      a7 = v34;
      if (v13) {
        continue;
      }
    }

    break;
  }

void sub_187581A24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, unsigned int *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, EVP_PKEY *a27, unint64_t *a28, unint64_t *a29)
{
}

uint64_t CBS_get_u24_length_prefixed(unsigned __int8 **a1, unint64_t *a2)
{
  return cbs_get_length_prefixed(a1, a2, 3uLL);
}

EVP_PKEY *bssl::ssl_cert_parse_pubkey@<X0>(__int128 *a1@<X0>, EVP_PKEY **a2@<X8>)
{
  __int128 v5 = *a1;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if ((bssl::ssl_cert_skip_to_spki(&v5, &v4) & 1) != 0)
  {
    BOOL result = EVP_parse_public_key(&v4);
  }

  else
  {
    ERR_put_error(16, 0, 272, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 358);
    BOOL result = 0LL;
  }

  *a2 = result;
  return result;
}

uint64_t bssl::ssl_cert_skip_to_spki(__int128 *a1, __int128 *a2)
{
  __int128 v6 = *a1;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  int asn1 = CBS_get_asn1(&v6, &v5, 536870928);
  uint64_t result = 0LL;
  if (asn1)
  {
    if (!*((void *)&v6 + 1))
    {
      uint64_t result = CBS_get_asn1(&v5, a2, 536870928);
      if ((_DWORD)result)
      {
        uint64_t result = CBS_get_optional_asn1(a2, 0LL, 0LL, -1610612736);
        if ((_DWORD)result)
        {
          uint64_t result = CBS_get_asn1(a2, 0LL, 2);
          if ((_DWORD)result)
          {
            uint64_t result = CBS_get_asn1(a2, 0LL, 536870928);
            if ((_DWORD)result)
            {
              uint64_t result = CBS_get_asn1(a2, 0LL, 536870928);
              if ((_DWORD)result)
              {
                uint64_t result = CBS_get_asn1(a2, 0LL, 536870928);
                if ((_DWORD)result) {
                  return CBS_get_asn1(a2, 0LL, 536870928) != 0;
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t CBS_get_asn1(__int128 *a1, void *a2, int a3)
{
  return cbs_get_asn1(a1, a2, a3, 1);
}

uint64_t cbs_get_asn1(__int128 *a1, void *a2, int a3, int a4)
{
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  int v15 = -1431655766;
  if (a2) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = v14;
  }
  v14[0] = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = 0xAAAAAAAAAAAAAAAALL;
  int any_asn1_element = cbs_get_any_asn1_element(a1, v7, &v15, &v16, 0LL, 0LL, 0);
  uint64_t result = 0LL;
  if (any_asn1_element && v15 == a3)
  {
    if (a4)
    {
      uint64_t v10 = v14;
      if (a2) {
        uint64_t v10 = a2;
      }
      unint64_t v11 = v10[1];
      BOOL v12 = v11 >= v16;
      uint64_t v13 = v11 - v16;
      if (!v12) {
        cbs_get_asn1_cold_1();
      }
      *v7 += v16;
      v10[1] = v13;
    }

    return 1LL;
  }

  return result;
}

uint64_t cbs_get_any_asn1_element( __int128 *a1, void *a2, _DWORD *a3, unint64_t *a4, _DWORD *a5, _DWORD *a6, int a7)
{
  __int128 v31 = *a1;
  if (a7)
  {
    *a5 = 0;
    *a6 = 0;
  }

  else
  {
    if (a5) {
      cbs_get_any_asn1_element_cold_2();
    }
    if (a6) {
      cbs_get_any_asn1_element_cold_1();
    }
  }

  unsigned int v30 = -1431655766;
  uint64_t result = parse_asn1_tag(&v31, &v30);
  if ((_DWORD)result)
  {
    if (a3) {
      *a3 = v30;
    }
    if (!*((void *)&v31 + 1)) {
      return 0LL;
    }
    int v15 = (unsigned __int8 *)(v31 + 1);
    uint64_t v16 = *(unsigned __int8 *)v31;
    unint64_t v17 = *((void *)a1 + 1);
    unint64_t v18 = v17 - (*((void *)&v31 + 1) - 1LL);
    if ((*(char *)v31 & 0x80000000) == 0)
    {
      unint64_t v19 = v18 + v16;
      if (!a4) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }

    unint64_t v23 = v16 & 0x7F;
    if (a7)
    {
      if (!(_DWORD)v23 && (v30 & 0x20000000) != 0)
      {
        if (a4)
        {
          *a4 = v18;
          unint64_t v17 = *((void *)a1 + 1);
        }

        *a5 = 1;
        *a6 = 1;
        unint64_t v29 = v17 - v18;
        if (v17 < v18) {
          return 0LL;
        }
        uint64_t v22 = *(void *)a1;
        *(void *)a1 += v18;
        *((void *)a1 + 1) = v29;
        if (a2)
        {
LABEL_15:
          *a2 = v22;
          a2[1] = v18;
        }

        return 1LL;
      }
    }

    BOOL v25 = (v23 - 5) >= 0xFFFFFFFC && *((void *)&v31 + 1) - 1LL >= v23;
    if (!v25) {
      return 0LL;
    }
    unint64_t v26 = 0LL;
    unint64_t v27 = v23;
    do
    {
      unsigned int v28 = *v15++;
      unint64_t v26 = v28 | (v26 << 8);
      --v27;
    }

    while (v27);
    if (v26 > 0x7F)
    {
      if (!a7) {
        return 0LL;
      }
    }

    else
    {
      if (!a7) {
        return 0LL;
      }
      *a5 = 1;
      if (v26 >> (8 * v23 - 8))
      {
LABEL_42:
        v18 += v23;
        if (!__CFADD__(v26, v18))
        {
          unint64_t v19 = v26 + v18;
          if (!a4)
          {
LABEL_12:
            unint64_t v20 = *((void *)a1 + 1);
            BOOL v25 = v20 >= v19;
            unint64_t v21 = v20 - v19;
            if (!v25) {
              return 0LL;
            }
            uint64_t v22 = *(void *)a1;
            *(void *)a1 += v19;
            *((void *)a1 + 1) = v21;
            unint64_t v18 = v19;
            if (a2) {
              goto LABEL_15;
            }
            return 1LL;
          }

uint64_t parse_asn1_tag(void *a1, unsigned int *a2)
{
  uint64_t v2 = a1[1];
  if (!v2) {
    return 0LL;
  }
  __int128 v4 = (unsigned __int8 *)(*a1)++;
  a1[1] = v2 - 1;
  int v5 = *v4;
  int v6 = v5 & 0x1F;
  if (v6 != 31
    || (v10 = 0xAAAAAAAAAAAAAAAALL, int v7 = parse_base128_integer(a1, &v10), result = 0LL, v7)
    && (int v6 = v10, !(v10 >> 29))
    && v10 >= 0x1F)
  {
    unsigned int v9 = v6 | (v5 << 24) & 0xE0000000;
    if ((v9 & 0xDFFFFFFF) != 0)
    {
      *a2 = v9;
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t CBS_get_optional_asn1(__int128 *a1, void *a2, int *a3, int a4)
{
  __int128 v11 = *a1;
  unsigned int v10 = -1431655766;
  int v8 = 0;
  if (!parse_asn1_tag(&v11, &v10)
    || v10 != a4
    || (int v8 = 1, result = cbs_get_asn1(a1, a2, a4, 1), (_DWORD)result))
  {
    if (a3) {
      *a3 = v8;
    }
    return 1LL;
  }

  return result;
}

EVP_PKEY *EVP_parse_public_key(__int128 *a1)
{
  if (!CBS_get_asn1(a1, &v10[1], 536870928)
    || !CBS_get_asn1(&v10[1], v10, 536870928)
    || !CBS_get_asn1(&v10[1], &v9[1], 3)
    || *((void *)&v10[1] + 1))
  {
    int v6 = 102;
    int v7 = 106;
LABEL_13:
    ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", v7);
    return 0LL;
  }

  uint64_t v1 = parse_key_type(v10);
  if (!v1)
  {
    int v6 = 128;
    int v7 = 111;
    goto LABEL_13;
  }

  uint64_t v2 = v1;
  if (!CBS_get_u8(&v9[1], v9) || v9[0])
  {
    int v6 = 102;
    int v7 = 118;
    goto LABEL_13;
  }

  uint64_t v3 = EVP_PKEY_new();
  __int128 v4 = v3;
  if (!v3)
  {
LABEL_19:
    EVP_PKEY_free(v4);
    return 0LL;
  }

  evp_pkey_set_method((uint64_t)v3, v2);
  int v5 = (unsigned int (*)(EVP_PKEY *, __int128 *, _BYTE *))*((void *)v4->pkey.ptr + 3);
  if (!v5)
  {
    ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 131);
    goto LABEL_19;
  }

  if (!v5(v4, v10, &v9[1])) {
    goto LABEL_19;
  }
  return v4;
}

int *parse_key_type(__int128 *a1)
{
  unint64_t v6 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v1 = 0LL;
  uint64_t v3 = (const void *)v6;
  size_t v2 = v7;
  while (1)
  {
    __int128 v4 = kASN1Methods[v1];
    if (++v1 == 5) {
      return 0LL;
    }
  }

  return v4;
}

EVP_PKEY *EVP_PKEY_new(void)
{
  uint64_t result = (EVP_PKEY *)OPENSSL_zalloc(0x18uLL);
  if (result) {
    *(void *)&result->type = 1LL;
  }
  return result;
}

uint64_t EVP_PKEY_set_type(uint64_t a1, int a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 8))
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        int v5 = *(void (**)(uint64_t))(v4 + 160);
        if (v5)
        {
          v5(a1);
          *(void *)(a1 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;
          *(_DWORD *)(a1 + 4) = 0;
        }
      }
    }
  }

  if (a2 <= 407)
  {
    if (a2 == 6)
    {
      unint64_t v6 = &rsa_asn1_meth;
      if (!a1) {
        return 1LL;
      }
LABEL_21:
      uint64_t v7 = *(void *)(a1 + 16);
      if (v7)
      {
        int v8 = *(void (**)(uint64_t))(v7 + 160);
        if (v8)
        {
          v8(a1);
          *(void *)(a1 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;
        }
      }

      *(void *)(a1 + 16) = v6;
      *(_DWORD *)(a1 + 4) = *v6;
      return 1LL;
    }

    if (a2 == 116)
    {
      unint64_t v6 = &dsa_asn1_meth;
      if (!a1) {
        return 1LL;
      }
      goto LABEL_21;
    }
  }

  else
  {
    switch(a2)
    {
      case 949:
        unint64_t v6 = &ed25519_asn1_meth;
        if (!a1) {
          return 1LL;
        }
        goto LABEL_21;
      case 948:
        unint64_t v6 = &x25519_asn1_meth;
        if (!a1) {
          return 1LL;
        }
        goto LABEL_21;
      case 408:
        unint64_t v6 = &ec_asn1_meth;
        if (!a1) {
          return 1LL;
        }
        goto LABEL_21;
    }
  }

  ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp.c", 265);
  ERR_add_error_dataf("algorithm %d", v10, v11, v12, v13, v14, v15, v16, a2);
  return 0LL;
}

uint64_t rsa_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_asn1((__int128 *)a2, &v8, 5) || v9 || *(void *)(a2 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 97);
  }

  else
  {
    uint64_t v7 = RSA_parse_public_key((__int128 *)a3);
    if (v7 && !*(void *)(a3 + 8))
    {
      evp_pkey_set_method(a1, &rsa_asn1_meth);
      *(void *)(a1 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v7;
      return 1LL;
    }

    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 103);
    RSA_free(v7);
  }

  return 0LL;
}

RSA *RSA_parse_public_key(__int128 *a1)
{
  size_t v2 = RSA_new();
  if (v2)
  {
    *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_asn1(a1, &v6, 536870928)
      || !parse_integer(&v6, (BIGNUM **)&v2->version)
      || !parse_integer(&v6, (BIGNUM **)&v2->meth)
      || *((void *)&v6 + 1))
    {
      int v3 = 100;
      int v4 = 100;
      goto LABEL_9;
    }

    if (!RSA_check_key(v2))
    {
      int v3 = 104;
      int v4 = 106;
LABEL_9:
      ERR_put_error(4, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", v4);
      RSA_free(v2);
      return 0LL;
    }
  }

  return v2;
}

RSA *__cdecl RSA_new_method(ENGINE *engine)
{
  uint64_t v1 = (uint64_t *)malloc(0x180uLL);
  size_t v2 = v1;
  if (v1)
  {
    *((_OWORD *)v1 + 22) = 0u;
    *((_OWORD *)v1 + 23) = 0u;
    *((_OWORD *)v1 + 20) = 0u;
    *((_OWORD *)v1 + 21) = 0u;
    *((_OWORD *)v1 + 1EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0u;
    *((_OWORD *)v1 + 19) = 0u;
    *((_OWORD *)v1 + 16) = 0u;
    *((_OWORD *)v1 + 17) = 0u;
    *((_OWORD *)v1 + 14) = 0u;
    *((_OWORD *)v1 + 15) = 0u;
    *((_OWORD *)v1 + 12) = 0u;
    *((_OWORD *)v1 + 13) = 0u;
    *((_OWORD *)v1 + 10) = 0u;
    *((_OWORD *)v1 + 11) = 0u;
    *((_OWORD *)v1 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0u;
    *((_OWORD *)v1 + 9) = 0u;
    *((_OWORD *)v1 + 6) = 0u;
    *((_OWORD *)v1 + 7) = 0u;
    *((_OWORD *)v1 + 4) = 0u;
    *((_OWORD *)v1 + 5) = 0u;
    *((_OWORD *)v1 + 2) = 0u;
    *((_OWORD *)v1 + 3) = 0u;
    *(_OWORD *)uint64_t v1 = 0u;
    *((_OWORD *)v1 + 1) = 0u;
    CRYPTO_once(&RSA_default_method_once, (void (*)(void))RSA_default_method_init);
    *size_t v2 = (uint64_t)&RSA_default_method_storage;
    METHOD_ref((uint64_t)&RSA_default_method_storage);
    int v3 = dword_18C4C4E30;
    *((_DWORD *)v2 + 20) = 1;
    *((_DWORD *)v2 + 21) = v3;
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v2 + 11));
    CRYPTO_new_ex_data((_DWORD)v2 + 72, v4, v5);
    __int128 v6 = *(unsigned int (**)(uint64_t *))(*v2 + 16);
    if (v6 && !v6(v2))
    {
      CRYPTO_MUTEX_cleanup((pthread_rwlock_t *)(v2 + 11));
      METHOD_unref(*v2);
      free(v2);
      return 0LL;
    }
  }

  else
  {
    ERR_put_error(4, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 77);
  }

  return (RSA *)v2;
}

uint64_t METHOD_ref(uint64_t result)
{
  if (!*(_BYTE *)(result + 4)) {
    METHOD_ref_cold_1();
  }
  return result;
}

BIGNUM *BN_new(void)
{
  uint64_t result = (BIGNUM *)OPENSSL_malloc(0x18uLL);
  if (result)
  {
    *(void *)&result->top = 0LL;
    *(void *)&result->neg = 0LL;
    result->d = 0LL;
    result->flagunsigned int s = 1;
  }

  return result;
}

BOOL BN_parse_asn1_unsigned(__int128 *a1, BIGNUM *a2)
{
  if (CBS_get_asn1(a1, &v6[1], 2) && CBS_is_valid_asn1_integer((unsigned __int8 **)&v6[1], v6))
  {
    if (!v6[0]) {
      return BN_bin2bn(*(const unsigned __int8 **)&v6[1], v6[3], a2) != 0LL;
    }
    int v3 = 109;
    int v4 = 31;
  }

  else
  {
    int v3 = 117;
    int v4 = 26;
  }

  ERR_put_error(3, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bn_extra/bn_asn1.c", v4);
  return 0LL;
}

BOOL CBS_is_valid_asn1_integer(unsigned __int8 **a1, unsigned int *a2)
{
  size_t v2 = a1[1];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = (uint64_t)*a1;
  unsigned int v4 = **a1;
  if (a2) {
    *a2 = v4 >> 7;
  }
  int v6 = *(char *)(v3 + 1);
  if (!v4 && (v6 & 0x80000000) == 0) {
    return 0LL;
  }
  return v4 != 255 || v6 >= 0;
}

BIGNUM *__cdecl BN_bin2bn(const unsigned __int8 *s, int len, BIGNUM *ret)
{
  unint64_t v3 = *(void *)&len;
  if (ret)
  {
    int v5 = ret;
    int v6 = 0LL;
  }

  else
  {
    int v5 = BN_new();
    int v6 = v5;
    if (!v5) {
      return v5;
    }
  }

  if (v3)
  {
    unint64_t v7 = ((v3 - 1) >> 3) + 1;
    if (bn_wexpand(&v5->d, v7))
    {
      if (v3 >= 0x3FFFFFFF9LL) {
        BN_bin2bn_cold_1();
      }
      v5->top = v7;
      v5->neg = 0;
      bn_big_endian_to_words(v5->d, (int)v7, (unsigned __int8 *)s, v3);
    }

    else
    {
      BN_free(v6);
      return 0LL;
    }
  }

  else
  {
    v5->top = 0;
  }

  return v5;
}

uint64_t bn_wexpand(void **a1, unint64_t a2)
{
  int v2 = a2;
  if (a2 < 0x800000)
  {
    if ((*((_BYTE *)a1 + 20) & 2) != 0)
    {
      int v3 = 106;
      int v4 = 360;
      goto LABEL_11;
    }

    uint64_t result = (uint64_t)OPENSSL_calloc(a2, 8uLL);
    if (!result) {
      return result;
    }
    unint64_t v7 = (void *)result;
    uint64_t v8 = *((int *)a1 + 2);
    if ((_DWORD)v8) {
      memcpy((void *)result, *a1, 8 * v8);
    }
    OPENSSL_free(*a1);
    *a1 = v7;
    *((_DWORD *)a1 + 3) = v2;
    return 1LL;
  }

  int v3 = 102;
  int v4 = 355;
LABEL_11:
  ERR_put_error(3, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/bn.c", v4);
  return 0LL;
}

void bn_big_endian_to_words(unint64_t *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a4 > 8 * a2) {
    abort();
  }
  if (a4 < 8)
  {
    unint64_t v4 = a4;
    if (!a4) {
      goto LABEL_10;
    }
LABEL_7:
    unint64_t v5 = 0LL;
    do
    {
      unsigned int v6 = *a3++;
      unint64_t v5 = v6 | (v5 << 8);
      --v4;
    }

    while (v4);
    *a1++ = v5;
    --a2;
    goto LABEL_10;
  }

  do
  {
    unint64_t v4 = a4 - 8;
    *a1++ = bswap64(*(void *)&a3[a4 - 8]);
    --a2;
    a4 = v4;
  }

  while (v4 > 7);
  if (v4) {
    goto LABEL_7;
  }
LABEL_10:
  size_t v7 = 8 * a2;
  if (v7) {
    bzero(a1, v7);
  }
}

int RSA_check_key(const RSA *a1)
{
  return 1;
}

BOOL EVP_PKEY_assign_RSA(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = a2;
  return a2 != 0;
}

uint64_t bssl::ssl_cert_check_key_usage(__int128 *a1, unsigned int a2)
{
  __int128 v13 = *a1;
  memset(v12, 170, sizeof(v12));
  int v11 = -1431655766;
  if (bssl::ssl_cert_skip_to_spki(&v13, &v12[1])
    && CBS_get_asn1(&v12[1], 0LL, 536870928)
    && CBS_get_optional_asn1(&v12[1], 0LL, 0LL, -2147483647)
    && CBS_get_optional_asn1(&v12[1], 0LL, 0LL, -2147483646)
    && CBS_get_optional_asn1(&v12[1], v12, &v11, -1610612733))
  {
    if (!v11) {
      return 1LL;
    }
    *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_asn1(v12, &v10, 536870928))
    {
      if (*((void *)&v10 + 1))
      {
        while (1)
        {
          memset(v9, 170, sizeof(v9));
          *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_asn1(&v10, &v9[1], 536870928)
            || !CBS_get_asn1(&v9[1], v9, 6)
            || CBS_peek_asn1_tag(&v9[1], 1) && !CBS_get_asn1(&v9[1], 0LL, 1)
            || !CBS_get_asn1(&v9[1], &v8, 4)
            || *((void *)&v9[1] + 1))
          {
            int v5 = 272;
            int v6 = 430;
            goto LABEL_23;
          }

          if (*((void *)&v9[0] + 1) == 3LL && **(_WORD **)&v9[0] == 7509 && *(_BYTE *)(*(void *)&v9[0] + 2LL) == 15) {
            break;
          }
          if (!*((void *)&v10 + 1)) {
            return 1LL;
          }
        }

        v7[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        v7[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        if (!CBS_get_asn1(&v8, v7, 3) || *((void *)&v8 + 1))
        {
          int v5 = 272;
          int v6 = 444;
          goto LABEL_23;
        }

        if (!CBS_is_valid_asn1_bitstring(v7))
        {
          int v5 = 272;
          int v6 = 451;
          goto LABEL_23;
        }

        if (!CBS_asn1_bitstring_has_bit((uint64_t)v7, a2))
        {
          int v5 = 302;
          int v6 = 456;
          goto LABEL_23;
        }
      }

      return 1LL;
    }

    int v5 = 272;
    int v6 = 418;
  }

  else
  {
    int v5 = 272;
    int v6 = 408;
  }

BOOL CBS_peek_asn1_tag(__int128 *a1, int a2)
{
  __int128 v6 = *a1;
  unsigned int v5 = -1431655766;
  return parse_asn1_tag(&v6, &v5) && v5 == a2;
}

BOOL CBS_is_valid_asn1_bitstring(unsigned __int8 **a1)
{
  uint64_t v1 = a1[1];
  if (!v1) {
    return 0LL;
  }
  unsigned int v2 = **a1;
  if (v2 > 7) {
    return 0LL;
  }
  if (!**a1) {
    return 1LL;
  }
  return ((*a1)[(void)v1 - 1] & ~(-1 << v2)) == 0;
}

BOOL CBS_asn1_bitstring_has_bit(uint64_t a1, unsigned int a2)
{
  BOOL result = CBS_is_valid_asn1_bitstring((unsigned __int8 **)a1);
  if (result)
  {
    unint64_t v5 = (a2 >> 3) + 1LL;
    if (*(void *)(a1 + 8) <= v5) {
      return 0LL;
    }
    else {
      return (*(unsigned __int8 *)(*(void *)a1 + v5) >> (~(_BYTE)a2 & 7)) & 1;
    }
  }

  return result;
}

uint64_t CRYPTO_BUFFER_new_from_CBS(uint64_t a1, void **a2)
{
  return crypto_buffer_new(*(const void **)a1, *(void *)(a1 + 8), 0, a2);
}

uint64_t crypto_buffer_new(const void *a1, unint64_t a2, int a3, void **a4)
{
  if (a4)
  {
    _OWORD v18[2] = a2;
    _OWORD v18[3] = 0xAAAAAAAAAAAAAAAALL;
    v18[0] = a4;
    v18[1] = a1;
    CRYPTO_MUTEX_lock_read((pthread_rwlock_t *)(a4 + 1));
    uint64_t v8 = OPENSSL_lh_retrieve( *a4,  (uint64_t)v18,  (uint64_t (*)(void, uint64_t))lh_CRYPTO_BUFFER_call_hash_func,  (unsigned int (*)(void, void, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func);
    uint64_t v9 = v8;
    if (a3 && v8)
    {
      if (*(_DWORD *)(v8 + 28))
      {
LABEL_5:
        CRYPTO_refcount_inc((unsigned int *)(v8 + 24));
        CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(a4 + 1));
        return v9;
      }
    }

    else if (v8)
    {
      goto LABEL_5;
    }

    CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(a4 + 1));
  }

  __int128 v10 = OPENSSL_zalloc(0x20uLL);
  uint64_t v9 = (uint64_t)v10;
  if (v10)
  {
    if (a3)
    {
      v10[1] = a1;
      *((_DWORD *)v10 + 7) = 1;
    }

    else
    {
      uint64_t v14 = OPENSSL_memdup(a1, a2);
      *(void *)(v9 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v14;
      if (a2 && !v14)
      {
        OPENSSL_free((void *)v9);
        return 0LL;
      }
    }

    *(void *)(v9 + 16) = a2;
    *(_DWORD *)(v9 + 24) = 1;
    if (a4)
    {
      *(void *)uint64_t v9 = a4;
      int v11 = (pthread_rwlock_t *)(a4 + 1);
      CRYPTO_MUTEX_lock_write((pthread_rwlock_t *)(a4 + 1));
      uint64_t v12 = OPENSSL_lh_retrieve( *a4,  v9,  (uint64_t (*)(void, uint64_t))lh_CRYPTO_BUFFER_call_hash_func,  (unsigned int (*)(void, void, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func);
      uint64_t v13 = v12;
      if (a3 && v12)
      {
        if (*(_DWORD *)(v12 + 28))
        {
LABEL_15:
          CRYPTO_refcount_inc((unsigned int *)(v12 + 24));
          CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(a4 + 1));
LABEL_16:
          crypto_buffer_free_object((void **)v9);
          return v13;
        }
      }

      else if (v12)
      {
        goto LABEL_15;
      }

      uint64_t v15 = *a4;
      v18[0] = 0LL;
      int v16 = OPENSSL_lh_insert( v15,  v18,  v9,  (uint64_t (*)(void, uint64_t))lh_CRYPTO_BUFFER_call_hash_func,  (unsigned int (*)(void, void, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func);
      CRYPTO_MUTEX_unlock_read(v11);
      if (v16) {
        return v9;
      }
      uint64_t v13 = 0LL;
      goto LABEL_16;
    }
  }

  return v9;
}

void *OPENSSL_memdup(const void *a1, unint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  unint64_t v4 = OPENSSL_malloc(a2);
  unint64_t v5 = v4;
  if (v4) {
    memcpy(v4, a1, a2);
  }
  return v5;
}

uint64_t bssl::ssl_noop_x509_session_cache_objects(bssl *this, ssl_session_st *a2)
{
  return 1LL;
}

uint64_t bssl::ssl_verify_peer_cert(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *(void *)(*(void *)(*(void *)this + 48LL) + 472LL);
  if (!v4)
  {
    unsigned __int8 v24 = 46;
    int v16 = *(uint64_t (**)(uint64_t, unsigned __int8 *))(*((void *)this + 1) + 48LL);
    if (v16)
    {
      uint64_t result = v16(v3, &v24);
      if ((_DWORD)result == 1)
      {
        if (*(_BYTE *)(*((void *)this + 1) + 300LL))
        {
          uint64_t result = 1LL;
        }

        else
        {
          ERR_clear_error();
          uint64_t result = 0LL;
        }

        *(void *)(*((void *)this + 190) + 176LL) = 50LL;
        if (!(_DWORD)result) {
          goto LABEL_32;
        }
        goto LABEL_22;
      }

      if (!(_DWORD)result)
      {
        *(void *)(*((void *)this + 190) + 176LL) = 0LL;
        goto LABEL_32;
      }
    }

    else
    {
      uint64_t result = (*(unsigned int (**)(void, bssl *, unsigned __int8 *))(*(void *)(*(void *)(v3 + 120)
                                                                                             + 16LL)
                                                                                 + 72LL))( *((void *)this + 190),  this,  &v24) ^ 1;
    }

    if (!(_DWORD)result)
    {
LABEL_32:
      if ((*(_BYTE *)(v3 + 180) & 1) != 0) {
        return 0LL;
      }
      if ((*(_WORD *)(*((void *)this + 1) + 301LL) & 4) == 0) {
        return 0LL;
      }
      uint64_t v20 = *(void *)(v3 + 120);
      unint64_t v21 = *(uint64_t (**)(uint64_t, void))(v20 + 792);
      if (!v21) {
        return 0LL;
      }
      int v22 = v21(v3, *(void *)(v20 + 800));
      if (v22 > 0) {
        return 0LL;
      }
      int v23 = v22;
      ERR_put_error(16, 0, 289, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 411);
      if (v23) {
        int v18 = 80;
      }
      else {
        int v18 = 113;
      }
LABEL_24:
      unint64_t v19 = (bssl *)v3;
LABEL_27:
      bssl::ssl_send_alert(v19, (ssl_st *)2, v18);
      return 1LL;
    }

LABEL_22:
    if ((_DWORD)result != 1) {
      return result;
    }
    ERR_put_error(16, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", 399);
    int v18 = v24;
    goto LABEL_24;
  }

  if ((*(_BYTE *)(v3 + 180) & 1) != 0) {
    bssl::ssl_verify_peer_cert();
  }
  unint64_t v5 = EVP_MD_CTX_md(*(const EVP_MD_CTX **)(v4 + 136));
  if (v5 != EVP_MD_CTX_md(*(const EVP_MD_CTX **)(*((void *)this + 190) + 136LL)))
  {
    int v17 = 340;
LABEL_26:
    ERR_put_error(16, 0, 273, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake.cc", v17);
    unint64_t v19 = (bssl *)v3;
    int v18 = 47;
    goto LABEL_27;
  }

  if (EVP_MD_CTX_md(*(const EVP_MD_CTX **)(*((void *)this + 190) + 136LL)))
  {
    unint64_t v6 = 0LL;
    while (1)
    {
      size_t v7 = OPENSSL_sk_value(*(unint64_t **)(v4 + 136), v6);
      uint64_t v8 = OPENSSL_sk_value(*(unint64_t **)(*((void *)this + 190) + 136LL), v6);
      uint64_t v9 = CRYPTO_BUFFER_len((uint64_t)v7);
      __int128 v10 = (const void *)CRYPTO_BUFFER_data((uint64_t)v7);
      int v11 = (const void *)CRYPTO_BUFFER_data((uint64_t)v8);
      size_t v12 = CRYPTO_BUFFER_len((uint64_t)v7);
      if (v12)
      {
        if (memcmp(v10, v11, v12)) {
          break;
        }
      }
    }

    int v17 = 355;
    goto LABEL_26;
  }

  return v5;
}

    unint64_t v5 = 0LL;
    goto LABEL_23;
  }

  uint64_t v9 = buffer_from_dispatch_data;
  __int128 v10 = SSL_set_quic_transport_params(*(void *)(v6 + 400), buffer_from_dispatch_data, size);
  unint64_t v5 = v10 == 1;
  if (v10 != 1)
  {
    int v11 = (id *)(v6 + 16);
    size_t v12 = objc_loadWeakRetained(v11);
    if (!v12
      || (uint64_t v13 = v12,
          uint64_t v14 = objc_loadWeakRetained(v11),
          uint64_t v15 = v14[475],
          v14,
          v13,
          (v15 & 1) == 0))
    {
      int v16 = objc_loadWeakRetained(v11);
      if (v16)
      {
        int v17 = objc_loadWeakRetained(v11);
        int v18 = (v17[475] & 1) == 0;
      }

      else
      {
        int v18 = 1;
      }

      if (v18)
      {
        if (g_boringssl_log)
        {
          unint64_t v29 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            boringssl_context_set_quic_transport_parameters_cold_2(v11, v29);
          }
        }
      }
    }
  }

  free(v9);
LABEL_23:

  return v5;
}

LABEL_10:
  uint64_t v13 = *(unsigned int **)(v4 + 256);
  if (v13) {
    CRYPTO_BUFFER_up_ref(*(void *)(v4 + 256));
  }
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]( (unsigned int **)(*((void *)this + 190) + 256LL),  v13);
  uint64_t v14 = *(unsigned int **)(v4 + 248);
  if (v14) {
    CRYPTO_BUFFER_up_ref(*(void *)(v4 + 248));
  }
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]( (unsigned int **)(*((void *)this + 190) + 248LL),  v14);
  uint64_t result = 0LL;
  *(void *)(*((void *)this + 190) + 176LL) = *(void *)(v4 + 176);
  return result;
}
}

            uint64_t v14 = 0LL;
          }
        }
      }
    }
  }

uint64_t boringssl_context_certificate_verify_callback(const SSL *a1, char *a2)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  unint64_t v5 = SSL_get_ex_data(a1, 0);
  if (!v5) {
    return 1LL;
  }
  uint64_t v6 = (uint64_t)v5;
  if (*(_DWORD *)v5 != -1252936367) {
    return 1LL;
  }
  uint64_t v7 = v5[1];
  if (!v7) {
    return 1LL;
  }
  if (*(void *)(v7 + 368) || *(void *)(v7 + 376))
  {
    uint64_t v8 = SSL_get_ex_data(a1, 0);
    if (!v8) {
      return 1LL;
    }
    if (*(_DWORD *)v8 != -1252936367) {
      return 1LL;
    }
    uint64_t v9 = v8[1];
    if (!v9) {
      return 1LL;
    }
    int is_server = SSL_is_server((uint64_t)a1);
    uint64_t v11 = 376LL;
    if (!is_server) {
      uint64_t v11 = 368LL;
    }
    size_t v12 = *(const __CFArray **)(v9 + v11);
    if (v12)
    {
      uint64_t v13 = SSL_get0_peer_pubkey((uint64_t)a1);
      if (!v13)
      {
        char v23 = 46;
        goto LABEL_34;
      }

      uint64_t v14 = (const EVP_PKEY *)v13;
      if (CFArrayGetCount(v12) < 1)
      {
LABEL_22:
        char v23 = 42;
LABEL_34:
        *a2 = v23;
        return 1LL;
      }

      CFIndex v15 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v12, v15);
        if (!ValueAtIndex) {
          break;
        }
        int v17 = ValueAtIndex;
        CFIndex Length = CFDataGetLength(ValueAtIndex);
        BytePtr = CFDataGetBytePtr(v17);
        if (!Length) {
          break;
        }
        if (!BytePtr) {
          break;
        }
        *(void *)buf = BytePtr;
        *(void *)&buf[8] = Length;
        uint64_t v20 = EVP_parse_public_key((__int128 *)buf);
        if (!v20) {
          break;
        }
        unint64_t v21 = v20;
        int v22 = EVP_PKEY_cmp(v14, v20);
        EVP_PKEY_free(v21);
        if (v22 == 1) {
          return 0LL;
        }
        if (++v15 >= CFArrayGetCount(v12)) {
          goto LABEL_22;
        }
      }
    }

    char v23 = 80;
    goto LABEL_34;
  }

  if ((*(_BYTE *)(v7 + 558) & 0xC) == 8)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
    if (WeakRetained)
    {
      BOOL v25 = WeakRetained;
      unint64_t v26 = objc_loadWeakRetained((id *)(v7 + 16));
      char v27 = v26[475];

      if ((v27 & 1) != 0) {
        return 2LL;
      }
    }

    id v28 = objc_loadWeakRetained((id *)(v7 + 16));
    if (v28)
    {
      unint64_t v29 = objc_loadWeakRetained((id *)(v7 + 16));
      BOOL v30 = (v29[475] & 1) == 0;
    }

    else
    {
      BOOL v30 = 1;
    }

    uint64_t v35 = 2LL;
    if (v30 && g_boringssl_log)
    {
      uint64_t v46 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
        boringssl_context_certificate_verify_callback_cold_1(v7 + 16, v46);
      }

      return 2LL;
    }
  }

  else
  {
    if ((*(_BYTE *)(v7 + 558) & 4) != 0)
    {
      int v37 = *(unsigned __int8 *)(v7 + 320);
      id v38 = objc_loadWeakRetained((id *)(v7 + 16));
      uint64_t v39 = v38;
      if (!v37)
      {
        if (!v38
          || (uint64_t v54 = objc_loadWeakRetained((id *)(v7 + 16)),
              char v55 = v54[475],
              v54,
              v39,
              (v55 & 1) == 0))
        {
          id v56 = objc_loadWeakRetained((id *)(v7 + 16));
          if (v56)
          {
            uint64_t v57 = objc_loadWeakRetained((id *)(v7 + 16));
            BOOL v58 = (v57[475] & 1) == 0;
          }

          else
          {
            BOOL v58 = 1;
          }

          if (v58)
          {
            if (g_boringssl_log)
            {
              uint64_t v63 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                id v64 = objc_loadWeakRetained((id *)(v7 + 16));
                if (v64)
                {
                  unsigned int v2 = (char *)objc_loadWeakRetained((id *)(v7 + 16));
                  uint64_t v65 = v2 + 391;
                }

                else
                {
                  uint64_t v65 = &unk_1875F4C23;
                }

                id v67 = objc_loadWeakRetained((id *)(v7 + 16));
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "boringssl_context_certificate_verify_callback";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 1948;
                __int16 v72 = 2082;
                unint64_t v73 = v65;
                __int16 v74 = 2048;
                id v75 = v67;
                _os_log_impl( &dword_187560000,  v63,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Certificate verification result: FAIL",  buf,  0x26u);

                if (v64) {
              }
                }
            }
          }
        }

        *a2 = boringssl_helper_convert_trusterror_to_alertcode(*(_DWORD *)(v7 + 324));
        return 1LL;
      }

      uint64_t v40 = &OBJC_IVAR___boringssl_concrete_nw_protocol_boringssl_logging_disabled;
      if (!v38
        || (char v41 = objc_loadWeakRetained((id *)(v7 + 16)),
            char v42 = v41[475],
            v41,
            v39,
            (v42 & 1) == 0))
      {
        id v43 = objc_loadWeakRetained((id *)(v7 + 16));
        if (v43)
        {
          uint64_t v44 = objc_loadWeakRetained((id *)(v7 + 16));
          BOOL v45 = (v44[475] & 1) == 0;
        }

        else
        {
          BOOL v45 = 1;
        }

        uint64_t v35 = 0LL;
        if (!v45 || !g_boringssl_log) {
          return v35;
        }
        uint64_t v59 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          id v60 = objc_loadWeakRetained((id *)(v7 + 16));
          if (v60)
          {
            uint64_t v40 = (int *)objc_loadWeakRetained((id *)(v7 + 16));
            char v61 = (char *)v40 + 391;
          }

          else
          {
            char v61 = &unk_1875F4C23;
          }

          id v66 = objc_loadWeakRetained((id *)(v7 + 16));
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "boringssl_context_certificate_verify_callback";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1945;
          __int16 v72 = 2082;
          unint64_t v73 = v61;
          __int16 v74 = 2048;
          id v75 = v66;
          _os_log_impl( &dword_187560000,  v59,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Certificate verification result: OK",  buf,  0x26u);

          if (v60) {
        }
          }
      }

      return 0LL;
    }

    session = SSL_get_session(a1);
    if ((boringssl_session_set_peer_verification_state_from_session(v6, (uint64_t)session) & 1) != 0)
    {
      id v32 = (id)v7;
      v68[0] = MEMORY[0x1895F87A8];
      v68[1] = 3221225472LL;
      int64x2_t v68[2] = __boringssl_context_certificate_verify_callback_block_invoke;
      v68[3] = &unk_18A07BCA0;
      uint64_t v70 = v6;
      int v33 = (__SecTrust **)v32;
      int v69 = v33;
      int v34 = (void *)MEMORY[0x1895A97C0](v68);
      if ((boringssl_context_evaluate_trust_async(v6, v33[45], v34) & 1) != 0)
      {
        uint64_t v35 = 2LL;
      }

      else
      {
        *a2 = 80;
        uint64_t v35 = 1LL;
      }
    }

    else
    {
      id v47 = objc_loadWeakRetained((id *)(v7 + 16));
      if (v47)
      {
        uint64_t v48 = v47;
        uint64_t v49 = objc_loadWeakRetained((id *)(v7 + 16));
        char v50 = v49[475];

        if ((v50 & 1) != 0) {
          return 1LL;
        }
      }

      id v51 = objc_loadWeakRetained((id *)(v7 + 16));
      if (v51)
      {
        uint64_t v52 = objc_loadWeakRetained((id *)(v7 + 16));
        BOOL v53 = (v52[475] & 1) == 0;
      }

      else
      {
        BOOL v53 = 1;
      }

      uint64_t v35 = 1LL;
      if (v53 && g_boringssl_log)
      {
        uint64_t v62 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          boringssl_context_certificate_verify_callback_cold_2(v7 + 16, v62);
        }

        return 1LL;
      }
    }
  }

  return v35;
}

SSL_SESSION *__cdecl SSL_get_session(const SSL *ssl)
{
  handshake_func = ssl->handshake_func;
  uint64_t v3 = (SSL_SESSION *)*((void *)handshake_func + 59);
  if (v3) {
    return v3;
  }
  uint64_t v4 = (bssl *)*((void *)handshake_func + 35);
  if (!v4) {
    SSL_get_session_cold_1();
  }
  if ((*((_WORD *)handshake_func + 110) & 0x20) != 0) {
    SSL_get_session_cold_2();
  }
  uint64_t v3 = (SSL_SESSION *)*((void *)v4 + 191);
  if (v3) {
    return v3;
  }
  else {
    return (SSL_SESSION *)bssl::ssl_handshake_session(v4, v1);
  }
}

uint64_t bssl::ssl_handshake_session(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  uint64_t result = *((void *)this + 190);
  if (!result) {
    return *(void *)(*(void *)this + 104LL);
  }
  return result;
}

uint64_t boringssl_session_set_peer_verification_state_from_session(uint64_t a1, uint64_t a2)
{
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      if (*(void *)(v4 + 368)) {
        return 0LL;
      }
      uint64_t v6 = (unint64_t *)SSL_SESSION_get0_peer_certificates(a2);
      uint64_t v7 = boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs((void *)v4, v6);
      if (v7)
      {
        uint64_t v8 = v7;
        SecKeyRef v9 = boringssl_helper_copy_public_key_from_certificates((void *)v4, v7);
        if (!v9)
        {
          id WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
          if (!WeakRetained
            || (uint64_t v40 = WeakRetained,
                char v41 = objc_loadWeakRetained((id *)(v4 + 16)),
                char v42 = v41[475],
                v41,
                v40,
                (v42 & 1) == 0))
          {
            id v43 = objc_loadWeakRetained((id *)(v4 + 16));
            if (v43)
            {
              uint64_t v44 = objc_loadWeakRetained((id *)(v4 + 16));
              BOOL v45 = (v44[475] & 1) == 0;
            }

            else
            {
              BOOL v45 = 1;
            }

            if (v45)
            {
              if (g_boringssl_log)
              {
                uint64_t v48 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
                  boringssl_session_set_peer_verification_state_from_session_cold_2(v4, v48);
                }
              }
            }
          }

          CFRelease(v8);
          return 0LL;
        }

        SecKeyRef v10 = v9;
        string = boringssl_helper_create_string(*(const char **)(v4 + 80));
        size_t v12 = boringssl_context_copy_ocsp_responses((void *)v4);
        uint64_t v13 = boringssl_context_copy_peer_sct_list((void *)v4);
        sec_trust_with_certificateunsigned int s = (const void *)boringssl_helper_create_sec_trust_with_certificates( a1,  string,  v8,  v12,  v13);
        if (boringssl_session_set_trust_reference(a1, (uint64_t)sec_trust_with_certificates)
          && boringssl_session_set_peer_certificate_chain(a1, (uint64_t)v8)
          && boringssl_session_set_peer_public_key(a1, (uint64_t)v10))
        {
          id v15 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v15)
          {
            int v16 = v15;
            int v17 = objc_loadWeakRetained((id *)(v4 + 16));
            char v18 = v17[475];

            if ((v18 & 1) != 0)
            {
              uint64_t v3 = 1LL;
              goto LABEL_44;
            }
          }

          id v19 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v19)
          {
            uint64_t v20 = objc_loadWeakRetained((id *)(v4 + 16));
            BOOL v21 = (v20[475] & 1) == 0;
          }

          else
          {
            BOOL v21 = 1;
          }

          uint64_t v3 = 1LL;
          if (!v21 || !g_boringssl_log) {
            goto LABEL_44;
          }
          id v47 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG)) {
            boringssl_session_set_peer_verification_state_from_session_cold_3(v4, v47);
          }
          goto LABEL_42;
        }

        cf = v13;
        unint64_t v29 = string;
        BOOL v30 = sec_trust_with_certificates;
        __int128 v31 = v12;
        id v32 = objc_loadWeakRetained((id *)(v4 + 16));
        if (v32
          && (int v33 = v32,
              int v34 = objc_loadWeakRetained((id *)(v4 + 16)),
              char v35 = v34[475],
              v34,
              v33,
              (v35 & 1) != 0))
        {
          uint64_t v3 = 0LL;
        }

        else
        {
          id v36 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v36)
          {
            int v37 = objc_loadWeakRetained((id *)(v4 + 16));
            BOOL v38 = (v37[475] & 1) == 0;
          }

          else
          {
            BOOL v38 = 1;
          }

          uint64_t v3 = 0LL;
          if (v38)
          {
            size_t v12 = v31;
            sec_trust_with_certificateunsigned int s = v30;
            string = v29;
            uint64_t v13 = cf;
            if (!g_boringssl_log)
            {
LABEL_44:
              if (string) {
                CFRelease(string);
              }
              if (v13) {
                CFRelease(v13);
              }
              if (v12) {
                CFRelease(v12);
              }
              if (sec_trust_with_certificates) {
                CFRelease(sec_trust_with_certificates);
              }
              CFRelease(v8);
              CFRelease(v10);
              return v3;
            }

            id v47 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
              boringssl_session_set_peer_verification_state_from_session_cold_4(v4, v47);
            }
            uint64_t v3 = 0LL;
LABEL_42:

            goto LABEL_44;
          }
        }

        size_t v12 = v31;
        sec_trust_with_certificateunsigned int s = v30;
        string = v29;
        uint64_t v13 = cf;
        goto LABEL_44;
      }

      id v22 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v22)
      {
        char v23 = v22;
        unsigned __int8 v24 = objc_loadWeakRetained((id *)(v4 + 16));
        char v25 = v24[475];

        if ((v25 & 1) != 0) {
          return 0LL;
        }
      }

      id v26 = objc_loadWeakRetained((id *)(v4 + 16));
      if (v26)
      {
        char v27 = objc_loadWeakRetained((id *)(v4 + 16));
        BOOL v28 = (v27[475] & 1) == 0;
      }

      else
      {
        BOOL v28 = 1;
      }

      uint64_t v3 = 0LL;
      if (v28 && g_boringssl_log)
      {
        uint64_t v46 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          boringssl_session_set_peer_verification_state_from_session_cold_1(v4, v46);
        }

        return 0LL;
      }
    }
  }

  return v3;
}

uint64_t SSL_SESSION_get0_peer_certificates(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

__CFArray *boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs(void *a1, unint64_t *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = 0LL;
  if (v3 && a2)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
    if (Mutable)
    {
      uint64_t v4 = Mutable;
      if (EVP_MD_CTX_md((const EVP_MD_CTX *)a2))
      {
        unint64_t v6 = 0LL;
        do
        {
          uint64_t v7 = OPENSSL_sk_value(a2, v6);
          CRYPTO_BUFFER_data((uint64_t)v7);
          CRYPTO_BUFFER_len((uint64_t)v7);
          uint64_t v8 = (const void *)SecCertificateCreateWithBytes();
          if (v8)
          {
            SecKeyRef v9 = v8;
            CFArrayAppendValue(v4, v8);
            CFRelease(v9);
          }

          else
          {
            id WeakRetained = objc_loadWeakRetained(v3 + 2);
            if (!WeakRetained
              || (uint64_t v11 = WeakRetained,
                  size_t v12 = objc_loadWeakRetained(v3 + 2),
                  char v13 = v12[475],
                  v12,
                  v11,
                  (v13 & 1) == 0))
            {
              id v14 = objc_loadWeakRetained(v3 + 2);
              if (v14)
              {
                id v15 = objc_loadWeakRetained(v3 + 2);
                BOOL v16 = (v15[475] & 1) == 0;
              }

              else
              {
                BOOL v16 = 1;
              }

              if (v16)
              {
                if (g_boringssl_log)
                {
                  int v17 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  {
                    char v18 = &unk_1875F4C23;
                    id v30 = objc_loadWeakRetained(v3 + 2);
                    if (v30)
                    {
                      unint64_t v29 = (char *)objc_loadWeakRetained(v3 + 2);
                      char v18 = v29 + 391;
                    }

                    id v19 = objc_loadWeakRetained(v3 + 2);
                    *(_DWORD *)buf = 136447234;
                    id v32 = "boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs";
                    __int16 v33 = 1024;
                    int v34 = 153;
                    __int16 v35 = 2082;
                    id v36 = v18;
                    __int16 v37 = 2048;
                    id v38 = v19;
                    __int16 v39 = 2048;
                    unint64_t v40 = v6;
                    _os_log_error_impl( &dword_187560000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Failed to extract certificate #%zu",  buf,  0x30u);

                    if (v30) {
                  }
                    }
                }
              }
            }
          }

          ++v6;
        }

        while (v6 < (unint64_t)EVP_MD_CTX_md((const EVP_MD_CTX *)a2));
      }

      if (CFArrayGetCount(v4) < 1)
      {
        CFRelease(v4);
LABEL_36:
        uint64_t v4 = 0LL;
      }
    }

    else
    {
      id v20 = objc_loadWeakRetained(v3 + 2);
      if (v20)
      {
        BOOL v21 = v20;
        id v22 = objc_loadWeakRetained(v3 + 2);
        char v23 = v22[475];

        if ((v23 & 1) != 0) {
          goto LABEL_36;
        }
      }

      id v24 = objc_loadWeakRetained(v3 + 2);
      if (v24)
      {
        char v25 = objc_loadWeakRetained(v3 + 2);
        BOOL v26 = (v25[475] & 1) == 0;
      }

      else
      {
        BOOL v26 = 1;
      }

      uint64_t v4 = 0LL;
      if (v26 && g_boringssl_log)
      {
        char v27 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs_cold_1(v3, v27);
        }

        goto LABEL_36;
      }
    }
  }

  return v4;
}

uint64_t CRYPTO_BUFFER_data(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t CRYPTO_BUFFER_len(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

SecKeyRef boringssl_helper_copy_public_key_from_certificates(void *a1, const __CFArray *a2)
{
  uint64_t v3 = a1;
  SecKeyRef v4 = 0LL;
  if (v3 && a2)
  {
    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(a2, 0LL);
    if (ValueAtIndex)
    {
      SecKeyRef v4 = SecCertificateCopyKey(ValueAtIndex);
      goto LABEL_16;
    }

    id WeakRetained = objc_loadWeakRetained(v3 + 2);
    if (WeakRetained)
    {
      uint64_t v7 = WeakRetained;
      uint64_t v8 = objc_loadWeakRetained(v3 + 2);
      char v9 = v8[475];

      if ((v9 & 1) != 0)
      {
LABEL_15:
        SecKeyRef v4 = 0LL;
        goto LABEL_16;
      }
    }

    id v10 = objc_loadWeakRetained(v3 + 2);
    if (v10)
    {
      uint64_t v11 = objc_loadWeakRetained(v3 + 2);
      BOOL v12 = (v11[475] & 1) == 0;
    }

    else
    {
      BOOL v12 = 1;
    }

    SecKeyRef v4 = 0LL;
    if (v12 && g_boringssl_log)
    {
      char v13 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        boringssl_helper_copy_public_key_from_certificates_cold_1(v3, v13);
      }

      goto LABEL_15;
    }
  }

const char *boringssl_helper_create_string(const char *cStr)
{
  if (cStr) {
    return (const char *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x8000100u);
  }
  return cStr;
}

__CFArray *boringssl_context_copy_ocsp_responses(void *a1)
{
  uint64_t v1 = a1;
  unsigned int v2 = v1;
  CFMutableArrayRef Mutable = v1[50];
  if (Mutable)
  {
    SecKeyRef v4 = SSL_get0_ocsp_responses((uint64_t)v1[50]);
    if (v4)
    {
      unint64_t v5 = (unint64_t *)v4;
      unint64_t v6 = EVP_MD_CTX_md((const EVP_MD_CTX *)v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], (CFIndex)v6, MEMORY[0x189605228]);
        for (unint64_t i = 0LL; (const EVP_MD *)i != v7; ++i)
        {
          id v10 = OPENSSL_sk_value(v5, i);
          uint64_t v11 = (const UInt8 *)CRYPTO_BUFFER_data((uint64_t)v10);
          CFIndex v12 = CRYPTO_BUFFER_len((uint64_t)v10);
          CFDataRef v13 = CFDataCreate(v8, v11, v12);
          CFArrayAppendValue(Mutable, v13);
          CFRelease(v13);
        }

        goto LABEL_11;
      }
    }

    else
    {
      CFIndex v17 = 0LL;
      char v18 = 0LL;
      SSL_get0_ocsp_response((uint64_t)Mutable, (uint64_t *)&v18, &v17);
      if (v17 && v18)
      {
        id v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 1LL, MEMORY[0x189605228]);
        CFDataRef v15 = CFDataCreate(v14, v18, v17);
        CFArrayAppendValue(Mutable, v15);
        CFRelease(v15);
        goto LABEL_11;
      }
    }

    CFMutableArrayRef Mutable = 0LL;
  }

unsigned __int8 *SSL_get0_ocsp_responses(uint64_t a1)
{
  session = SSL_get_session((const SSL *)a1);
  uint64_t result = 0LL;
  if ((*(_BYTE *)(a1 + 180) & 1) == 0)
  {
    if (session) {
      return session->tlsext_tick;
    }
  }

  return result;
}

CFArrayRef boringssl_context_copy_peer_sct_list(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *((void *)v1 + 50);
  if (!v2) {
    goto LABEL_15;
  }
  uint64_t v13 = 0LL;
  id v14 = 0LL;
  SSL_get0_signed_cert_timestamp_list(v2, (uint64_t *)&v14, &v13);
  if (v13)
  {
    uint64_t v3 = boringssl_context_copy_peer_sct_list_from_extension(v1, v14, v13);
    goto LABEL_16;
  }

  id WeakRetained = objc_loadWeakRetained((id *)v1 + 2);
  if (WeakRetained)
  {
    unint64_t v5 = WeakRetained;
    unint64_t v6 = objc_loadWeakRetained((id *)v1 + 2);
    char v7 = v6[475];

    if ((v7 & 1) != 0)
    {
LABEL_15:
      uint64_t v3 = 0LL;
      goto LABEL_16;
    }
  }

  id v8 = objc_loadWeakRetained((id *)v1 + 2);
  if (v8)
  {
    char v9 = objc_loadWeakRetained((id *)v1 + 2);
    char v10 = v9[475] & 1;
  }

  else
  {
    char v10 = 0;
  }

  uint64_t v3 = 0LL;
  if ((v10 & 1) == 0 && datapath_logging_enabled)
  {
    if (g_boringssl_log)
    {
      uint64_t v11 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
        boringssl_context_copy_peer_sct_list_cold_1(v1 + 16, v11);
      }
    }

    goto LABEL_15;
  }

uint64_t SSL_get0_signed_cert_timestamp_list(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = (uint64_t)SSL_get_session((const SSL *)a1);
  if ((*(_BYTE *)(a1 + 180) & 1) == 0 && (uint64_t v7 = result) != 0 && (result = *(void *)(result + 248)) != 0)
  {
    *a2 = CRYPTO_BUFFER_data(result);
    uint64_t result = CRYPTO_BUFFER_len(*(void *)(v7 + 248));
    *a3 = result;
  }

  else
  {
    *a3 = 0LL;
    *a2 = 0LL;
  }

  return result;
}

#error "187584D80: call analysis failed (funcsize=431)"
const SSL *boringssl_session_get_negotiated_protocol_version(const SSL *result)
{
  SSL_METHOD *method;
  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0LL)
    {
      uint64_t result = (const SSL *)method[1].num_ciphers;
      if (result) {
        LOWORD(result) = SSL_version(result);
      }
    }

    else
    {
      LOWORD(result) = 0;
    }
  }

  return (const SSL *)(unsigned __int16)result;
}

uint64_t boringssl_session_get_negotiated_ciphersuite(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (v1 = *(void *)(result + 8)) != 0 && (uint64_t v2 = *(void *)(v1 + 400)) != 0)
    {
      uint64_t result = (uint64_t)SSL_get_current_cipher(*(const SSL **)(v1 + 400));
      if (result || (uint64_t result = SSL_get_pending_cipher(v2)) != 0) {
        LOWORD(result) = SSL_CIPHER_get_id(result);
      }
    }

    else
    {
      LOWORD(result) = 0;
    }
  }

  return (unsigned __int16)result;
}

SSL_CIPHER *__cdecl SSL_get_current_cipher(const SSL *s)
{
  uint64_t result = (SSL_CIPHER *)SSL_get_session(s);
  if (result) {
    return (SSL_CIPHER *)result[2].mask;
  }
  return result;
}

uint64_t SSL_CIPHER_get_id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t boringssl_helper_ciphersuite_to_key_usage(int a1, int a2)
{
  if (a1 == 772) {
    return 1LL;
  }
  uint64_t result = (uint64_t)SSL_get_cipher_by_value(a2);
  if (result)
  {
    int kx_nid = SSL_CIPHER_get_kx_nid(result);
    if (kx_nid == 951) {
      return 4LL;
    }
    else {
      return kx_nid == 952;
    }
  }

  return result;
}

uint64_t boringssl_session_set_trust_reference(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t result = 0LL;
      if (a2)
      {
        uint64_t v4 = *(void *)(v2 + 8);
        if (v4)
        {
          unint64_t v5 = *(const void **)(v4 + 360);
          if (v5) {
            CFRelease(v5);
          }
          *(void *)(v4 + 360) = 0LL;
          *(void *)(v4 + 360) = a2;
          CFRetain(*(CFTypeRef *)(v4 + 360));
          return 1LL;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_set_peer_certificate_chain(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t result = 0LL;
      if (a2)
      {
        uint64_t v4 = *(void *)(v2 + 8);
        if (v4)
        {
          unint64_t v5 = *(const void **)(v4 + 352);
          if (v5) {
            CFRelease(v5);
          }
          *(void *)(v4 + 352) = 0LL;
          *(void *)(v4 + 352) = a2;
          CFRetain(*(CFTypeRef *)(v4 + 352));
          return 1LL;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_set_peer_public_key(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)result == -1252936367)
    {
      uint64_t result = 0LL;
      if (a2)
      {
        uint64_t v4 = *(void *)(v2 + 8);
        if (v4)
        {
          unint64_t v5 = *(const void **)(v4 + 344);
          if (v5) {
            CFRelease(v5);
          }
          *(void *)(v4 + 344) = 0LL;
          *(void *)(v4 + 344) = a2;
          CFRetain(*(CFTypeRef *)(v4 + 344));
          return 1LL;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_evaluate_trust_async(uint64_t a1, __SecTrust *a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  id v6 = a3;
  uint64_t v7 = v6;
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    uint64_t v8 = 0LL;
    if (v6)
    {
      if (a2)
      {
        uint64_t v9 = *(void *)(a1 + 8);
        if (v9)
        {
          if (*(void *)(v9 + 120) && *(void *)(v9 + 128))
          {
            char v10 = (id *)(v9 + 16);
            id WeakRetained = objc_loadWeakRetained((id *)(v9 + 16));
            if (!WeakRetained
              || (CFIndex v12 = WeakRetained,
                  uint64_t v13 = (unsigned __int8 *)objc_loadWeakRetained(v10),
                  uint64_t v3 = (char *)v13[475],
                  v13,
                  v12,
                  (v3 & 1) == 0))
            {
              id v14 = objc_loadWeakRetained(v10);
              if (v14)
              {
                CFDataRef v15 = objc_loadWeakRetained(v10);
                BOOL v16 = (v15[475] & 1) == 0;
              }

              else
              {
                BOOL v16 = 1;
              }

              if (v16)
              {
                if (g_boringssl_log)
                {
                  unint64_t v29 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                  {
                    id v30 = objc_loadWeakRetained(v10);
                    if (v30)
                    {
                      uint64_t v3 = (char *)objc_loadWeakRetained(v10);
                      __int128 v31 = v3 + 391;
                    }

                    else
                    {
                      __int128 v31 = &unk_1875F4C23;
                    }

                    id v34 = objc_loadWeakRetained(v10);
                    int v35 = 136446978;
                    id v36 = "boringssl_context_evaluate_trust_async";
                    __int16 v37 = 1024;
                    int v38 = 1783;
                    __int16 v39 = 2082;
                    unint64_t v40 = v31;
                    __int16 v41 = 2048;
                    id v42 = v34;
                    _os_log_impl( &dword_187560000,  v29,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Performing external trust evaluation",  (uint8_t *)&v35,  0x26u);

                    if (v30) {
                  }
                    }
                }
              }
            }

            boringssl_session_update_metadata(a1);
            uint64_t v33 = boringssl_context_evaluate_trust_async_external(a1, a2, v7);
          }

          else
          {
            char v18 = (id *)(v9 + 16);
            id v19 = objc_loadWeakRetained((id *)(v9 + 16));
            if (!v19
              || (id v20 = v19,
                  BOOL v21 = objc_loadWeakRetained(v18),
                  char v22 = v21[475],
                  v21,
                  v20,
                  (v22 & 1) == 0))
            {
              id v23 = objc_loadWeakRetained(v18);
              if (v23)
              {
                id v24 = objc_loadWeakRetained(v18);
                BOOL v25 = (v24[475] & 1) == 0;
              }

              else
              {
                BOOL v25 = 1;
              }

              if (v25)
              {
                if (g_boringssl_log)
                {
                  BOOL v26 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                  {
                    id v27 = objc_loadWeakRetained(v18);
                    if (v27)
                    {
                      uint64_t v3 = (char *)objc_loadWeakRetained(v18);
                      BOOL v28 = v3 + 391;
                    }

                    else
                    {
                      BOOL v28 = &unk_1875F4C23;
                    }

                    id v32 = objc_loadWeakRetained(v18);
                    int v35 = 136446978;
                    id v36 = "boringssl_context_evaluate_trust_async";
                    __int16 v37 = 1024;
                    int v38 = 1787;
                    __int16 v39 = 2082;
                    unint64_t v40 = v28;
                    __int16 v41 = 2048;
                    id v42 = v32;
                    _os_log_impl( &dword_187560000,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Performing local trust evaluation",  (uint8_t *)&v35,  0x26u);

                    if (v27) {
                  }
                    }
                }
              }
            }

            uint64_t v33 = boringssl_context_evaluate_trust_async_internal(a1, (uint64_t)a2, v7);
          }

          uint64_t v8 = v33;
        }
      }
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  return v8;
}

void boringssl_session_update_metadata(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    uint64_t v1 = *(void **)(a1 + 8);
    if (v1)
    {
      id v3 = v1;
      id v2 = v3;
      nw_protocol_metadata_access_handle();
    }
  }

BOOL __boringssl_session_update_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return a2 != 0;
  }
  uint64_t v4 = *(void **)(a2 + 88);
  *(void *)(a2 + 8EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;

  unint64_t v5 = *(void **)(a2 + 104);
  *(void *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 104) = 0LL;

  id v6 = *(void **)(a2 + 136);
  *(void *)(a2 + 136) = 0LL;

  uint64_t v7 = *(void **)(a2 + 144);
  *(void *)(a2 + CBB_cleanup(v1 - 144) = 0LL;

  uint64_t v8 = *(void **)(a2 + 152);
  *(void *)(a2 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = 0LL;

  uint64_t v9 = *(void **)(a2 + 168);
  *(void *)(a2 + 16EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;

  char v10 = *(void **)(a2 + 160);
  *(void *)(a2 + 160) = 0LL;

  uint64_t v11 = *(void **)(a2 + 80);
  *(void *)(a2 + 80) = 0LL;

  CFIndex v12 = *(void **)(a2 + 40);
  if (v12)
  {
    free(v12);
    *(void *)(a2 + 40) = 0LL;
  }

  uint64_t v13 = *(void **)(a2 + 176);
  if (v13)
  {
    free(v13);
    *(void *)(a2 + 176) = 0LL;
  }

  id v14 = *(void **)(a2 + 48);
  if (v14)
  {
    free(v14);
    *(void *)(a2 + 4EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;
  }

  *(_WORD *)(a2 + RAND_bytes(buf, 32) = (unsigned __int16)boringssl_session_get_negotiated_protocol_version(*(const SSL **)(a1 + 40));
  *(_WORD *)(a2 + 34) = boringssl_session_get_negotiated_ciphersuite(*(void *)(a1 + 40));
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  *(_OWORD *)__s1 = 0u;
  __int128 v84 = 0u;
  uint64_t v80 = 0LL;
  if (boringssl_session_get_negotiated_protocol(*(void *)(a1 + 40), &v80))
  {
    __memcpy_chk();
    *(void *)(a2 + 40) = strdup(__s1);
  }

  uint64_t v15 = sec_array_create();
  BOOL v16 = *(void **)(a2 + 136);
  *(void *)(a2 + 136) = v15;

  dispatch_data_t v17 = boringssl_context_copy_ocsp_response(*(void *)(a1 + 32));
  sec_array_append();
  uint64_t v18 = *(void *)(a1 + 32);
  if (!*(void *)(v18 + 368))
  {
    id v19 = *(void *)(v18 + 352)
        ? (const __CFArray *)CFRetain(*(CFTypeRef *)(v18 + 352))
        : boringssl_helper_copy_certificates_from_session((void *)v18, *(const SSL **)(v18 + 400));
    id v20 = v19;
    if (v19)
    {
      uint64_t v21 = sec_array_create();
      char v22 = *(void **)(a2 + 88);
      *(void *)(a2 + 8EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v21;

      if (CFArrayGetCount(v20) >= 1)
      {
        CFIndex v23 = 0LL;
        do
        {
          ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v20, v23);
          if (ValueAtIndex)
          {
            sec_certificate_t v25 = sec_certificate_create(ValueAtIndex);
            if (v25) {
              sec_array_append();
            }
          }

          ++v23;
        }

        while (v23 < CFArrayGetCount(v20));
      }

      CFRelease(v20);
    }
  }

  uint64_t v26 = *(void *)(a1 + 40);
  if (v26)
  {
    if (*(_DWORD *)v26 == -1252936367)
    {
      uint64_t v27 = *(void *)(v26 + 8);
      if (v27)
      {
        if (*(void *)(v27 + 344))
        {
          BOOL v28 = (const __CFData *)SecKeyCopySubjectPublicKeyInfo();
          if (v28)
          {
            unint64_t v29 = v28;
            BytePtr = CFDataGetBytePtr(v28);
            size_t Length = CFDataGetLength(v29);
            dispatch_data_t v32 = dispatch_data_create(BytePtr, Length, 0LL, 0LL);
            uint64_t v33 = *(void **)(a2 + 104);
            *(void *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 104) = v32;

            CFRelease(v29);
          }
        }
      }
    }
  }

  uint64_t v79 = 0LL;
  peer_signature_algorithmunsigned int s = boringssl_session_get_peer_signature_algorithms(*(void *)(a1 + 40), &v79);
  if (peer_signature_algorithms && v79)
  {
    unint64_t v35 = peer_signature_algorithms;
    xpc_object_t v36 = xpc_array_create(0LL, 0LL);
    __int16 v37 = *(void **)(a2 + 112);
    *(void *)(a2 + 112) = v36;

    uint64_t v38 = 0LL;
    unsigned int v39 = 1;
    do
    {
      xpc_array_set_uint64(*(xpc_object_t *)(a2 + 112), 0xFFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(v79 + 2 * v38));
      uint64_t v38 = v39;
    }

    while (v35 > v39++);
  }

  boringssl_context_copy_server_requested_CAs(*(void *)(a1 + 40));
  __int16 v41 = (void *)objc_claimAutoreleasedReturnValue();
  if (v41) {
    objc_storeStrong((id *)(a2 + 144), v41);
  }
  uint64_t v42 = *(void *)(a1 + 40);
  if (v42
    && *(_DWORD *)v42 == -1252936367
    && (uint64_t v43 = *(void *)(v42 + 8)) != 0
    && (uint64_t v44 = *(void *)(v43 + 400)) != 0
    && (size_t size = 0LL, buffer = 0LL, SSL_get_peer_quic_transport_params(v44, &buffer, &size), buffer)
    && size)
  {
    dispatch_data_t v45 = dispatch_data_create(buffer, size, 0LL, 0LL);
    if (v45) {
      objc_storeStrong((id *)(a2 + 152), v45);
    }
  }

  else
  {
    dispatch_data_t v45 = 0LL;
  }

  uint64_t v46 = *(void *)(a1 + 32);
  id v47 = *(__SecTrust **)(v46 + 360);
  if (v47)
  {
    sec_trust_t v48 = sec_trust_create(v47);
    uint64_t v49 = *(void **)(a2 + 168);
    *(void *)(a2 + 16EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v48;

    uint64_t v46 = *(void *)(a1 + 32);
  }

  char v50 = *(id **)(v46 + 104);
  if (v50)
  {
    id v51 = boringssl_identity_copy_sec_identity(v50);
    uint64_t v52 = *(void **)(a2 + 160);
    *(void *)(a2 + 160) = v51;

    BOOL v53 = *(id **)(*(void *)(a1 + 32) + 104LL);
    if (v53)
    {
      uint64_t v54 = boringssl_identity_copy_certificate_chain(v53);
      char v55 = *(void **)(a2 + 80);
      *(void *)(a2 + 80) = v54;
    }
  }

  negotiated_group = (const char *)boringssl_session_get_negotiated_group(*(void *)(a1 + 40));
  if (negotiated_group) {
    *(void *)(a2 + 176) = strdup(negotiated_group);
  }
  server_name = (const char *)boringssl_session_get_server_name(*(const SSL **)(a1 + 40));
  if (server_name) {
    *(void *)(a2 + 4EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = strdup(server_name);
  }
  uint64_t v58 = *(void *)(a1 + 40);
  if (v58)
  {
    if (*(_DWORD *)v58 == -1252936367)
    {
      uint64_t v58 = *(void *)(v58 + 8);
      if (v58) {
        LOWORD(v5EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 16 * (*(_BYTE *)(v58 + 557) & 1);
      }
    }

    else
    {
      LOWORD(v5EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0;
    }
  }

  __int16 v59 = *(_WORD *)(a2 + 328) & 0xFFEF | v58;
  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v59;
  uint64_t v60 = *(void *)(a1 + 40);
  if (v60)
  {
    if (*(_DWORD *)v60 == -1252936367)
    {
      uint64_t v60 = *(void *)(v60 + 8);
      if (v60) {
        LODWORD(v60) = (*(unsigned __int8 *)(v60 + 558) >> 2) & 0x20;
      }
    }

    else
    {
      LOWORD(v60) = 0;
    }
  }

  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v60 | v59 & 0xFFDF;
  else {
    __int16 v61 = 0;
  }
  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = *(_WORD *)(a2 + 328) & 0xFFBF | v61;
  else {
    __int16 v62 = 0;
  }
  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = *(_WORD *)(a2 + 328) & 0xFFF7 | v62;
  else {
    __int16 v63 = 0;
  }
  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = *(_WORD *)(a2 + 328) & 0xFF7F | v63;
  else {
    __int16 v64 = 0;
  }
  __int16 v65 = *(_WORD *)(a2 + 328) & 0xFEFF | v64;
  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v65;
  uint64_t v66 = *(void *)(a1 + 40);
  if (v66)
  {
    if (*(_DWORD *)v66 == -1252936367)
    {
      uint64_t v66 = *(void *)(v66 + 8);
      if (v66) {
        LOWORD(v66) = (*(_BYTE *)(v66 + 559) & 0x40) << 7;
      }
    }

    else
    {
      LOWORD(v66) = 0;
    }
  }

  *(_WORD *)(a2 + 32EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v66 | v65 & 0xDFFF;
  uint64_t v67 = *(void *)(a1 + 40);
  if (v67)
  {
    if (*(_DWORD *)v67 == -1252936367)
    {
      uint64_t v68 = *(void *)(v67 + 8);
      if (v68)
      {
        *(_WORD *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 256) = *(_WORD *)(v68 + 336);
        unint64_t v69 = *(void *)(v68 + 464);
        unint64_t v70 = *(void *)(v68 + 456);
        BOOL v71 = v69 >= v70;
        uint64_t v72 = v69 - v70;
        if (!v71) {
          uint64_t v72 = -1LL;
        }
        *(void *)(a2 + 24EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = v72;
        uint64_t v68 = *(void *)(v68 + 432) - *(void *)(v68 + 424);
      }

      else
      {
        *(_WORD *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 256) = 0;
        *(void *)(a2 + 24EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;
      }

      *(void *)(a2 + 264) = v68;
      uint64_t v73 = *(void *)(v67 + 8);
      if (v73)
      {
        *(void *)(a2 + 272) = *(void *)(v73 + 472) + *(void *)(v73 + 480);
        uint64_t v73 = *(void *)(v73 + 472);
      }

      else
      {
        *(void *)(a2 + 272) = 0LL;
      }

      *(void *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 280) = v73;
      uint64_t v74 = *(void *)(v67 + 8);
      if (v74)
      {
        *(void *)(a2 + 28EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = *(void *)(v74 + 480);
        uint64_t v75 = *(void *)(v74 + 496);
      }

      else
      {
        uint64_t v75 = 0LL;
        *(void *)(a2 + 28EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;
      }

      *(void *)(a2 + 2bssl::Array<unsigned short>::~Array(v1 - 96) = v75;
      uint64_t v67 = *(void *)(v67 + 8);
      if (v67)
      {
        *(void *)(a2 + 304) = *(void *)(v67 + 488);
        uint64_t v67 = *(void *)(v67 + 504);
      }

      else
      {
        *(void *)(a2 + 304) = 0LL;
      }

      goto LABEL_98;
    }

    uint64_t v67 = 0LL;
  }

  *(_WORD *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 256) = 0;
  *(void *)(a2 + 24EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = 0LL;
  *(_OWORD *)(a2 + 264) = 0u;
  *(_OWORD *)(a2 + bssl::Array<unsigned short>::~Array(v16 + 280) = 0u;
  *(_OWORD *)(a2 + 2bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
LABEL_98:
  *(void *)(a2 + 312) = v67;
  uuid_copy((unsigned __int8 *)(a2 + 64), (const unsigned __int8 *)(*(void *)(a1 + 32) + 252LL));
  uint64_t v76 = *(const char **)(*(void *)(a1 + 32) + 96LL);
  if (v76)
  {
    if (*(void *)(a2 + 56))
    {
      free(*(void **)(a2 + 56));
      *(void *)(a2 + 56) = 0LL;
      uint64_t v76 = *(const char **)(*(void *)(a1 + 32) + 96LL);
    }

    *(void *)(a2 + 56) = strdup(v76);
  }

  *(void *)a2 = *(void *)(a1 + 40);
  *(void *)(a2 + EVP_AEAD_CTX_cleanup((uint64_t)this + 8) = boringssl_session_export_secret_data;
  *(void *)(a2 + 16) = *(void *)(a1 + 40);
  *(void *)(a2 + 24) = boringssl_session_copy_serialized_session;
  uint64_t v77 = *(void *)(a1 + 40);
  *(void *)(a2 + 336) = boringssl_session_copy_authenticator;
  *(void *)(a2 + 344) = boringssl_session_copy_authenticator_trust;
  *(void *)(a2 + 352) = v77;
  if (boringssl_session_is_eap_configured(*(void *)(a1 + 40))) {
    boringssl_session_update_eap_metadata(*(void *)(a1 + 40));
  }

  return a2 != 0;
}

uint64_t boringssl_session_get_negotiated_protocol(uint64_t result, void *a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v2 = *(void *)(result + 8)) != 0)
    {
      uint64_t v5 = 0LL;
      unsigned int v4 = 0;
      SSL_get0_alpn_selected(*(void *)(v2 + 400), &v5, &v4);
      if (a2) {
        *a2 = v4;
      }
      return v5;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_get0_alpn_selected(uint64_t result, void *a2, _DWORD *a3)
{
  id v3 = *(void **)(result + 48);
  uint64_t v4 = v3[35];
  if (v4 && (*(_BYTE *)(v4 + 1585) & 4) != 0 && (*(_BYTE *)(result + 180) & 1) == 0)
  {
    uint64_t v5 = *(void *)(v4 + 1528);
    id v6 = (void *)(v5 + 392);
    uint64_t v7 = (unint64_t *)(v5 + 400);
  }

  else
  {
    id v6 = v3 + 62;
    uint64_t v7 = v3 + 63;
  }

  unint64_t v8 = *v7;
  if (v8 >= 0xFFFFFFFF) {
    SSL_get0_alpn_selected_cold_1();
  }
  *a2 = *v6;
  *a3 = v8;
  return result;
}

dispatch_data_t boringssl_context_copy_ocsp_response(uint64_t a1)
{
  dispatch_data_t result = *(dispatch_data_t *)(a1 + 400);
  if (result)
  {
    size_t v3 = 0LL;
    uint64_t v4 = 0LL;
    SSL_get0_ocsp_response((uint64_t)result, (uint64_t *)&v4, (uint64_t *)&v3);
    dispatch_data_t result = 0LL;
    if (v3) {
      BOOL v2 = v4 == 0LL;
    }
    else {
      BOOL v2 = 1;
    }
    if (!v2) {
      return dispatch_data_create(v4, v3, 0LL, 0LL);
    }
  }

  return result;
}

uint64_t SSL_get0_ocsp_response(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = (uint64_t)SSL_get_session((const SSL *)a1);
  if ((*(_BYTE *)(a1 + 180) & 1) == 0 && (uint64_t v7 = result) != 0 && (result = *(void *)(result + 256)) != 0)
  {
    *a2 = CRYPTO_BUFFER_data(result);
    uint64_t result = CRYPTO_BUFFER_len(*(void *)(v7 + 256));
    *a3 = result;
  }

  else
  {
    *a3 = 0LL;
    *a2 = 0LL;
  }

  return result;
}

__CFArray *boringssl_helper_copy_certificates_from_session(void *a1, const SSL *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1;
  uint64_t v5 = 0LL;
  if (v4 && a2)
  {
    id v6 = (unint64_t *)SSL_get0_peer_certificates(a2);
    if (v6)
    {
      uint64_t v5 = boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs(v4, v6);
      goto LABEL_21;
    }

    id WeakRetained = objc_loadWeakRetained(v4 + 2);
    if (WeakRetained)
    {
      unint64_t v8 = WeakRetained;
      uint64_t v9 = (unsigned __int8 *)objc_loadWeakRetained(v4 + 2);
      BOOL v2 = (char *)v9[475];

      if ((v2 & 1) != 0)
      {
LABEL_20:
        uint64_t v5 = 0LL;
        goto LABEL_21;
      }
    }

    id v10 = objc_loadWeakRetained(v4 + 2);
    if (v10)
    {
      uint64_t v11 = objc_loadWeakRetained(v4 + 2);
      BOOL v12 = (v11[475] & 1) == 0;
    }

    else
    {
      BOOL v12 = 1;
    }

    uint64_t v5 = 0LL;
    if (v12 && g_boringssl_log)
    {
      uint64_t v13 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        id v14 = objc_loadWeakRetained(v4 + 2);
        if (v14)
        {
          BOOL v2 = (char *)objc_loadWeakRetained(v4 + 2);
          uint64_t v15 = v2 + 391;
        }

        else
        {
          uint64_t v15 = &unk_1875F4C23;
        }

        id v16 = objc_loadWeakRetained(v4 + 2);
        int v18 = 136446978;
        id v19 = "boringssl_helper_copy_certificates_from_session";
        __int16 v20 = 1024;
        int v21 = 188;
        __int16 v22 = 2082;
        CFIndex v23 = v15;
        __int16 v24 = 2048;
        id v25 = v16;
        _os_log_impl( &dword_187560000,  v13,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] SSL_get0_peer_certificates returned no certificates",  (uint8_t *)&v18,  0x26u);

        if (v14) {
      }
        }

      goto LABEL_20;
    }
  }

SSL_SESSION *SSL_get0_peer_certificates(const SSL *a1)
{
  uint64_t result = SSL_get_session(a1);
  if (result) {
    return *(SSL_SESSION **)&result->sid_ctx[28];
  }
  return result;
}

uint64_t boringssl_session_get_peer_signature_algorithms(uint64_t a1, void *a2)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && a2 && (uint64_t v2 = *(void *)(a1 + 8)) != 0 && (v3 = *(void *)(v2 + 400)) != 0) {
    return SSL_get0_peer_verify_algorithms(v3, a2);
  }
  else {
    return 0LL;
  }
}

uint64_t SSL_get0_peer_verify_algorithms(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 280LL);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 648);
    uint64_t result = *(void *)(v2 + 656);
  }

  else
  {
    uint64_t result = 0LL;
    uint64_t v3 = 0LL;
  }

  *a2 = v3;
  return result;
}

id boringssl_context_copy_server_requested_CAs(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(void *)(a1 + 8)) != 0 && (uint64_t v2 = *(void *)(v1 + 400)) != 0)
  {
    uint64_t v3 = (void *)sec_array_create();
    uint64_t v4 = (const EVP_MD_CTX *)SSL_get0_server_requested_CAs(v2);
    if (v4)
    {
      uint64_t v5 = (unint64_t *)v4;
      if (EVP_MD_CTX_md(v4))
      {
        if (EVP_MD_CTX_md((const EVP_MD_CTX *)v5))
        {
          unint64_t v6 = 0LL;
          do
          {
            uint64_t v7 = OPENSSL_sk_value(v5, v6);
            unint64_t v8 = (const void *)CRYPTO_BUFFER_data((uint64_t)v7);
            size_t v9 = CRYPTO_BUFFER_len((uint64_t)v7);
            dispatch_data_t v10 = dispatch_data_create(v8, v9, 0LL, 0LL);
            sec_array_append();

            ++v6;
          }

          while (v6 < (unint64_t)EVP_MD_CTX_md((const EVP_MD_CTX *)v5));
        }
      }
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  return v3;
}

uint64_t SSL_get0_server_requested_CAs(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 48) + 280LL);
  if (v1) {
    return *(void *)(v1 + 1472);
  }
  else {
    return 0LL;
  }
}

uint64_t SSL_get_peer_quic_transport_params(uint64_t result, void *a2, void *a3)
{
  *a2 = *(void *)(*(void *)(result + 48) + 584LL);
  *a3 = *(void *)(*(void *)(result + 48) + 592LL);
  return result;
}

uint64_t boringssl_session_get_negotiated_group(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = *(const SSL **)(v1 + 400);
  if (!v2) {
    return 0LL;
  }
  curve_id = SSL_get_curve_id(v2);
  return SSL_get_curve_name(curve_id);
}

SSL_SESSION *SSL_get_curve_id(const SSL *a1)
{
  uint64_t result = SSL_get_session(a1);
  if (result) {
    return (SSL_SESSION *)HIWORD(result->key_arg_length);
  }
  return result;
}

const SSL *boringssl_session_get_server_name(const SSL *result)
{
  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0LL)
    {
      uint64_t result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        if ((BYTE4(method[2].ssl_renegotiate_check) & 0x10) != 0) {
          return (const SSL *)SSL_get_servername(result, 0);
        }
        else {
          return (const SSL *)method->ssl_renegotiate;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

const SSL *boringssl_session_has_session_ticket(const SSL *result, uint64_t a2)
{
  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0LL)
    {
      if (a2) {
        return (const SSL *)SSL_SESSION_has_ticket(a2);
      }
      uint64_t result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        uint64_t result = (const SSL *)SSL_get_session(result);
        a2 = (uint64_t)result;
        if (result) {
          return (const SSL *)SSL_SESSION_has_ticket(a2);
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL SSL_SESSION_has_ticket(uint64_t a1)
{
  return *(void *)(a1 + 240) != 0LL;
}

uint64_t boringssl_session_early_data_accepted(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      uint64_t result = *(void *)(v1 + 400);
      if (result) {
        return SSL_early_data_accepted(result) != 0;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_early_data_accepted(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(void *)(a1 + 48) + 220LL) >> 10) & 1;
}

uint64_t boringssl_session_was_resumed(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      uint64_t result = *(void *)(v1 + 400);
      if (result) {
        return SSL_session_reused(result) != 0;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_session_reused(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if ((*(_WORD *)(v1 + 220) & 0x40) != 0) {
    return 1LL;
  }
  uint64_t v2 = *(void *)(v1 + 280);
  if (v2) {
    return (*(_DWORD *)(v2 + 1584) >> 10) & 1;
  }
  else {
    return 0LL;
  }
}

const SSL *boringssl_session_was_renewed(const SSL *result, uint64_t a2)
{
  if (result)
  {
    if (result->version == -1252936367 && (method = result->method) != 0LL)
    {
      uint64_t result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        if (a2) {
          return (const SSL *)(SSL_SESSION_was_renewed(a2) != 0);
        }
        uint64_t result = (const SSL *)SSL_get_session(result);
        a2 = (uint64_t)result;
        if (result) {
          return (const SSL *)(SSL_SESSION_was_renewed(a2) != 0);
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_SESSION_was_renewed(uint64_t a1)
{
  return *(_BYTE *)(a1 + 384) & 1;
}

BOOL boringssl_session_is_eap_configured(uint64_t a1)
{
  if (!a1 || *(_DWORD *)a1 != -1252936367 || !*(void *)(a1 + 8)) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  char v6 = 1;
  nw_protocol_options_access_handle();
  BOOL v1 = *((_BYTE *)v4 + 24) != 0;
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_187586600( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __boringssl_session_is_eap_configured_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_BYTE *)(a2 + 360) != 1) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }
  return a2 != 0;
}

uint64_t boringssl_context_evaluate_trust_async_external(uint64_t a1, __SecTrust *a2, void *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  char v6 = v5;
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    uint64_t v7 = 0LL;
    if (v5)
    {
      if (a2)
      {
        unint64_t v8 = *(void **)(a1 + 8);
        if (v8)
        {
          sec_trust_t v9 = sec_trust_create(a2);
          uint64_t v10 = MEMORY[0x1895A97C0](v8[15]);
          uint64_t v11 = (void *)v10;
          if (v9) {
            BOOL v12 = v10 == 0;
          }
          else {
            BOOL v12 = 1;
          }
          uint64_t v7 = !v12;
          if (!v12)
          {
            uint64_t v13 = v8;
            v30[0] = MEMORY[0x1895F87A8];
            v30[1] = 3221225472LL;
            v30[2] = __boringssl_context_evaluate_trust_async_external_block_invoke;
            _OWORD v30[3] = &unk_18A07BB20;
            uint64_t v35 = a1;
            id v36 = v13;
            id v14 = v13;
            __int128 v31 = v14;
            id v33 = v6;
            __int16 v37 = a2;
            id v34 = v11;
            dispatch_data_t v32 = v9;
            uint64_t v15 = (void *)MEMORY[0x1895A97C0](v30);
            *((_BYTE *)v14 + 558) |= 8u;
            id WeakRetained = objc_loadWeakRetained(v14 + 2);
            if (!WeakRetained
              || (dispatch_data_t v17 = WeakRetained,
                  int v18 = objc_loadWeakRetained(v14 + 2),
                  char v19 = v18[475],
                  v18,
                  v17,
                  (v19 & 1) == 0))
            {
              id v20 = objc_loadWeakRetained(v14 + 2);
              if (v20)
              {
                int v21 = objc_loadWeakRetained(v14 + 2);
                BOOL v22 = (v21[475] & 1) == 0;
              }

              else
              {
                BOOL v22 = 1;
              }

              if (v22)
              {
                if (g_boringssl_log)
                {
                  __int16 v24 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                  {
                    id v25 = objc_loadWeakRetained(v14 + 2);
                    if (v25)
                    {
                      unint64_t v29 = (char *)objc_loadWeakRetained(v14 + 2);
                      uint64_t v26 = v29 + 391;
                    }

                    else
                    {
                      uint64_t v26 = &unk_1875F4C23;
                    }

                    id v27 = objc_loadWeakRetained(v14 + 2);
                    *(_DWORD *)buf = 136446978;
                    unsigned int v39 = "boringssl_context_evaluate_trust_async_external";
                    __int16 v40 = 1024;
                    int v41 = 1768;
                    __int16 v42 = 2082;
                    uint64_t v43 = v26;
                    __int16 v44 = 2048;
                    id v45 = v27;
                    _os_log_impl( &dword_187560000,  v24,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Asyncing for external verify block",  buf,  0x26u);

                    if (v25) {
                  }
                    }
                }
              }
            }

            if (v15)
            {
              BOOL v28 = (dispatch_queue_s *)v14[16];
              if (v28)
              {
                v14[63] = (char *)v14[63] + 1;
                dispatch_async(v28, v15);
              }
            }
          }
        }
      }
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  return v7;
}

void __boringssl_context_evaluate_trust_async_external_block_invoke(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (boringssl_session_get_state(*(void *)(a1 + 64)) > 3
    || boringssl_session_is_cancelled(*(void *)(a1 + 64)))
  {
    *(_BYTE *)(*(void *)(a1 + 72) + 558LL) &= ~8u;
    return;
  }

  v22[0] = MEMORY[0x1895F87A8];
  v22[1] = 3221225472LL;
  void v22[2] = __boringssl_context_evaluate_trust_async_external_block_invoke_2;
  _OWORD v22[3] = &unk_18A07BAF8;
  id v23 = *(id *)(a1 + 32);
  __int128 v25 = *(_OWORD *)(a1 + 64);
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 80);
  id v24 = v3;
  uint64_t v26 = v4;
  id v5 = (void *)MEMORY[0x1895A97C0](v22);
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6) {
    goto LABEL_10;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
  if (WeakRetained)
  {
    unint64_t v8 = WeakRetained;
    sec_trust_t v9 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
    char v10 = v9[475];

    if ((v10 & 1) != 0) {
      goto LABEL_16;
    }
  }

  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    id v12 = objc_loadWeakRetained((id *)(v11 + 16));
    if (v12)
    {
      uint64_t v13 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
      uint64_t v14 = (v13[475] & 1) == 0;
    }

    else
    {
      uint64_t v14 = 1LL;
    }

    if (!(_DWORD)v14) {
      goto LABEL_16;
    }
  }

  else
  {
LABEL_10:
    uint64_t v14 = 1LL;
  }

  if (g_boringssl_log)
  {
    id v15 = (id)g_boringssl_log;
    if (!os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG))
    {
LABEL_15:

      goto LABEL_16;
    }

    uint64_t v16 = *(void *)(a1 + 32);
    if (v16)
    {
      uint64_t v14 = (uint64_t)objc_loadWeakRetained((id *)(v16 + 16));
      uint64_t v21 = *(void *)(a1 + 32);
      if (v14)
      {
        BOOL v17 = v21 != 0;
        if (v21)
        {
          BOOL v1 = (char *)objc_loadWeakRetained((id *)(v21 + 16));
          uint64_t v21 = *(void *)(a1 + 32);
        }

        else
        {
          BOOL v1 = 0LL;
        }

        id v20 = v1 + 391;
      }

      else
      {
        BOOL v17 = 0;
        id v20 = &unk_1875F4C23;
      }

      if (v21)
      {
        id v18 = objc_loadWeakRetained((id *)(v21 + 16));
        char v19 = 0;
      }

      else
      {
        id v18 = 0LL;
        char v19 = 1;
      }
    }

    else
    {
      BOOL v17 = 0;
      id v18 = 0LL;
      char v19 = 1;
      id v20 = &unk_1875F4C23;
    }

    *(_DWORD *)buf = 136446978;
    BOOL v28 = "boringssl_context_evaluate_trust_async_external_block_invoke";
    __int16 v29 = 1024;
    int v30 = 1763;
    __int16 v31 = 2082;
    dispatch_data_t v32 = v20;
    __int16 v33 = 2048;
    id v34 = v18;
    _os_log_debug_impl( &dword_187560000,  (os_log_t)v15,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Invoking verify block",  buf,  0x26u);
    if ((v19 & 1) != 0)
    {
      if (!v17) {
        goto LABEL_30;
      }
    }

    else
    {

      if (!v17)
      {
LABEL_30:
        if (!v16) {
          goto LABEL_15;
        }
        goto LABEL_34;
      }
    }

    if (!v16) {
      goto LABEL_15;
    }
LABEL_34:

    goto LABEL_15;
  }

void __boringssl_context_evaluate_trust_async_external_block_invoke_2(uint64_t a1)
{
  id v2 = *(id *)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  nw_queue_context_async_if_needed();
}

void __boringssl_context_evaluate_trust_async_external_block_invoke_3(uint64_t a1)
{
  uint64_t v131 = *MEMORY[0x1895F89C0];
  if (boringssl_session_get_state(*(void *)(a1 + 48)) > 3
    || (boringssl_session_is_cancelled(*(void *)(a1 + 48)) & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (!v4) {
      goto LABEL_9;
    }
    id WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
    if (WeakRetained)
    {
      uint64_t v6 = WeakRetained;
      uint64_t v7 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
      char v8 = v7[475];

      if ((v8 & 1) != 0) {
        goto LABEL_110;
      }
    }

    uint64_t v9 = *(void *)(a1 + 32);
    if (v9)
    {
      id v10 = objc_loadWeakRetained((id *)(v9 + 16));
      if (v10)
      {
        uint64_t v11 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
        uint64_t v12 = (v11[475] & 1) == 0;
      }

      else
      {
        uint64_t v12 = 1LL;
      }

      if (!(_DWORD)v12) {
        goto LABEL_110;
      }
    }

    else
    {
LABEL_9:
      uint64_t v12 = 1LL;
    }

    if (!g_boringssl_log)
    {
LABEL_110:
      *(_BYTE *)(*(void *)(a1 + 56) + 558LL) &= ~8u;
      __int128 v86 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
LABEL_111:
      v86();
      return;
    }

    BOOL v22 = (os_log_s *)(id)g_boringssl_log;
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_43;
    }
    uint64_t v23 = *(void *)(a1 + 32);
    if (!v23)
    {
      BOOL v25 = 0;
      id v26 = 0LL;
      char v27 = 1;
      BOOL v28 = &unk_1875F4C23;
      goto LABEL_39;
    }

    uint64_t v12 = (uint64_t)objc_loadWeakRetained((id *)(v23 + 16));
    uint64_t v24 = *(void *)(a1 + 32);
    if (v12)
    {
      BOOL v25 = v24 != 0;
      if (v24)
      {
        BlockSize = (char *)objc_loadWeakRetained((id *)(v24 + 16));
        uint64_t v24 = *(void *)(a1 + 32);
      }

      else
      {
        BlockSize = 0LL;
      }

      BOOL v28 = BlockSize + 391;
      if (v24) {
        goto LABEL_38;
      }
    }

    else
    {
      BOOL v25 = 0;
      BOOL v28 = &unk_1875F4C23;
      if (v24)
      {
LABEL_38:
        id v26 = objc_loadWeakRetained((id *)(v24 + 16));
        char v27 = 0;
LABEL_39:
        *(_DWORD *)buf = 136446978;
        size_t v122 = "boringssl_context_evaluate_trust_async_external_block_invoke";
        __int16 v123 = 1024;
        int v124 = 1756;
        __int16 v125 = 2082;
        uint64_t v126 = v28;
        __int16 v127 = 2048;
        uint64_t v128 = (uint64_t)v26;
        _os_log_impl( &dword_187560000,  v22,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Cancelled during verify block",  buf,  0x26u);
        if ((v27 & 1) != 0)
        {
          if (!v25) {
            goto LABEL_41;
          }
        }

        else
        {

          if (!v25)
          {
LABEL_41:
            if (v23) {
LABEL_42:
            }

LABEL_43:
            goto LABEL_110;
          }
        }

        if (!v23) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
    }

    id v26 = 0LL;
    char v27 = 1;
    goto LABEL_39;
  }

  uint64_t v13 = *(void *)(a1 + 32);
  if (!v13) {
    goto LABEL_16;
  }
  id v14 = objc_loadWeakRetained((id *)(v13 + 16));
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
    char v17 = v16[475];

    if ((v17 & 1) != 0) {
      goto LABEL_59;
    }
  }

  uint64_t v18 = *(void *)(a1 + 32);
  if (!v18)
  {
LABEL_16:
    uint64_t v21 = 1LL;
    goto LABEL_30;
  }

  id v19 = objc_loadWeakRetained((id *)(v18 + 16));
  if (v19)
  {
    id v20 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
    uint64_t v21 = (v20[475] & 1) == 0;
  }

  else
  {
    uint64_t v21 = 1LL;
  }

  if ((_DWORD)v21)
  {
LABEL_30:
    if (!g_boringssl_log) {
      goto LABEL_59;
    }
    __int16 v29 = (os_log_s *)(id)g_boringssl_log;
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_58;
    }
    uint64_t v30 = *(void *)(a1 + 32);
    if (v30)
    {
      uint64_t v21 = (uint64_t)objc_loadWeakRetained((id *)(v30 + 16));
      uint64_t v31 = *(void *)(a1 + 32);
      if (v21)
      {
        BOOL v32 = v31 != 0;
        if (v31)
        {
          BlockSize = (char *)objc_loadWeakRetained((id *)(v31 + 16));
          uint64_t v31 = *(void *)(a1 + 32);
        }

        else
        {
          BlockSize = 0LL;
        }

        id v34 = BlockSize + 391;
      }

      else
      {
        BOOL v32 = 0;
        id v34 = &unk_1875F4C23;
      }

      if (v31)
      {
        uint64_t v2 = (uint64_t)objc_loadWeakRetained((id *)(v31 + 16));
        char v33 = 0;
      }

      else
      {
        uint64_t v2 = 0LL;
        char v33 = 1;
      }
    }

    else
    {
      BOOL v32 = 0;
      uint64_t v2 = 0LL;
      char v33 = 1;
      id v34 = &unk_1875F4C23;
    }

    int v35 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)buf = 136447234;
    size_t v122 = "boringssl_context_evaluate_trust_async_external_block_invoke_3";
    __int16 v123 = 1024;
    int v124 = 1724;
    __int16 v125 = 2082;
    uint64_t v126 = v34;
    __int16 v127 = 2048;
    uint64_t v128 = v2;
    __int16 v129 = 1024;
    int v130 = v35;
    _os_log_impl( &dword_187560000,  v29,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Returning from external verify block with result: %{BOOL}d",  buf,  0x2Cu);
    if ((v33 & 1) != 0)
    {
      if (!v32) {
        goto LABEL_56;
      }
    }

    else
    {

      if (!v32)
      {
LABEL_56:
        if (!v30)
        {
LABEL_58:

          goto LABEL_59;
        }

LABEL_59:
  if (!*(_BYTE *)(a1 + 72)) {
    goto LABEL_110;
  }
  id v36 = (SecKeyRef *)*(id *)(a1 + 32);
  __int16 v37 = v36;
  if (!v36 || (*((_BYTE *)v36 + 559) & 8) == 0) {
    goto LABEL_62;
  }
  BlockSize = (char *)SecKeyGetBlockSize(v36[43]);
  uint64_t AlgorithmId = SecKeyGetAlgorithmId();
  if (AlgorithmId == 3)
  {
    if (v37[67])
    {
      id v71 = objc_loadWeakRetained((id *)v37 + 2);
      if (!v71
        || (uint64_t v72 = v71,
            uint64_t v73 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2),
            uint64_t v2 = v73[475],
            v73,
            v72,
            (v2 & 1) == 0))
      {
        id v74 = objc_loadWeakRetained((id *)v37 + 2);
        if (v74)
        {
          uint64_t v75 = objc_loadWeakRetained((id *)v37 + 2);
          uint64_t v2 = (v75[475] & 1) == 0;
        }

        else
        {
          uint64_t v2 = 1LL;
        }

        uint64_t v38 = 4294957413LL;
        if ((_DWORD)v2 && g_boringssl_log)
        {
          uint64_t v2 = (uint64_t)(id)g_boringssl_log;
          if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR)) {
            __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_5(v37 + 2, BlockSize, v2);
          }
          goto LABEL_164;
        }

        goto LABEL_63;
      }

      goto LABEL_137;
    }
  }

  else if (AlgorithmId == 1 && BlockSize < (char *)v37[66])
  {
    id v58 = objc_loadWeakRetained((id *)v37 + 2);
    if (!v58
      || (__int16 v59 = v58,
          uint64_t v60 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2),
          uint64_t v2 = v60[475],
          v60,
          v59,
          (v2 & 1) == 0))
    {
      id v61 = objc_loadWeakRetained((id *)v37 + 2);
      if (v61)
      {
        __int16 v62 = objc_loadWeakRetained((id *)v37 + 2);
        uint64_t v2 = (v62[475] & 1) == 0;
      }

      else
      {
        uint64_t v2 = 1LL;
      }

      uint64_t v38 = 4294957413LL;
      if ((_DWORD)v2 && g_boringssl_log)
      {
        uint64_t v2 = (uint64_t)(id)g_boringssl_log;
        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR)) {
          __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_4(v37 + 2, BlockSize, v2);
        }
LABEL_164:

        goto LABEL_63;
      }

      goto LABEL_63;
    }

LABEL_137:
    uint64_t v38 = 4294957413LL;
    goto LABEL_63;
  }

  if (!CFArrayGetValueAtIndex(v37[44], 0LL))
  {
    BlockSize = (char *)(v37 + 2);
    id v87 = objc_loadWeakRetained((id *)v37 + 2);
    if (!v87
      || (__int128 v88 = v87,
          __int128 v89 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2),
          uint64_t v2 = v89[475],
          v89,
          v88,
          (v2 & 1) == 0))
    {
      id v90 = objc_loadWeakRetained((id *)v37 + 2);
      if (v90)
      {
        uint64_t v91 = objc_loadWeakRetained((id *)v37 + 2);
        uint64_t v2 = (v91[475] & 1) == 0;
      }

      else
      {
        uint64_t v2 = 1LL;
      }

      uint64_t v38 = 4294957412LL;
      if ((_DWORD)v2 && g_boringssl_log)
      {
        uint64_t v2 = (uint64_t)(id)g_boringssl_log;
        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR)) {
          __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_1(v37 + 2, v2);
        }
        goto LABEL_164;
      }

      goto LABEL_63;
    }

    goto LABEL_122;
  }

  uint64_t SignatureHashAlgorithm = SecCertificateGetSignatureHashAlgorithm();
  unsigned int v77 = *((_DWORD *)v37 + 136);
  BlockSize = (char *)(v37 + 2);
  id v78 = objc_loadWeakRetained((id *)v37 + 2);
  uint64_t v79 = v78;
  if (SignatureHashAlgorithm >= v77)
  {
    if (v78)
    {
      uint64_t v92 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2);
      uint64_t v2 = v92[475];

      if ((v2 & 1) != 0)
      {
LABEL_62:
        uint64_t v38 = 0LL;
        goto LABEL_63;
      }
    }

    id v93 = objc_loadWeakRetained((id *)v37 + 2);
    if (v93)
    {
      uint64_t v94 = objc_loadWeakRetained((id *)v37 + 2);
      uint64_t v2 = (v94[475] & 1) == 0;
    }

    else
    {
      uint64_t v2 = 1LL;
    }

    uint64_t v38 = 0LL;
    if ((_DWORD)v2 && g_boringssl_log)
    {
      uint64_t v2 = (uint64_t)(id)g_boringssl_log;
      if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEBUG)) {
        __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_3(v37 + 2, v2);
      }
      uint64_t v38 = 0LL;
      goto LABEL_164;
    }

    goto LABEL_63;
  }

  if (v78)
  {
    uint64_t v80 = (unsigned __int8 *)objc_loadWeakRetained((id *)v37 + 2);
    uint64_t v2 = v80[475];

    if ((v2 & 1) != 0)
    {
LABEL_122:
      uint64_t v38 = 4294957412LL;
      goto LABEL_63;
    }
  }

  id v81 = objc_loadWeakRetained((id *)v37 + 2);
  if (v81)
  {
    unint64_t v82 = objc_loadWeakRetained((id *)v37 + 2);
    uint64_t v2 = (v82[475] & 1) == 0;
  }

  else
  {
    uint64_t v2 = 1LL;
  }

  uint64_t v38 = 4294957412LL;
  if ((_DWORD)v2 && g_boringssl_log)
  {
    uint64_t v2 = (uint64_t)(id)g_boringssl_log;
    if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR)) {
      __boringssl_context_evaluate_trust_async_external_block_invoke_3_cold_2(v37 + 2, SignatureHashAlgorithm, v2);
    }
    goto LABEL_164;
  }

LABEL_63:
  uint64_t v39 = *(void *)(a1 + 32);
  if ((_DWORD)v38 && (*(_BYTE *)(v39 + 559) & 8) != 0)
  {
    id v40 = objc_loadWeakRetained((id *)(v39 + 16));
    if (v40)
    {
      int v41 = v40;
      __int16 v42 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
      char v43 = v42[475];

      if ((v43 & 1) != 0) {
        goto LABEL_109;
      }
    }

    uint64_t v44 = *(void *)(a1 + 32);
    if (v44)
    {
      id v45 = objc_loadWeakRetained((id *)(v44 + 16));
      if (v45)
      {
        uint64_t v46 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
        uint64_t v47 = (v46[475] & 1) == 0;
      }

      else
      {
        uint64_t v47 = 1LL;
      }
    }

    else
    {
      uint64_t v47 = 1LL;
    }

    if (!(_DWORD)v47 || !g_boringssl_log) {
      goto LABEL_109;
    }
    id v83 = (id)g_boringssl_log;
    if (!os_log_type_enabled((os_log_t)v83, OS_LOG_TYPE_DEBUG))
    {
LABEL_108:

LABEL_109:
      uint64_t v84 = *(void *)(*(void *)(a1 + 32) + 280LL);
      id v85 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
      (*(void (**)(uint64_t, id, void, uint64_t))(v84 + 16))(v84, v85, 0LL, v38);

      goto LABEL_110;
    }

    uint64_t v99 = *(void *)(a1 + 32);
    if (v99)
    {
      uint64_t v47 = (uint64_t)objc_loadWeakRetained((id *)(v99 + 16));
      uint64_t v114 = *(void *)(a1 + 32);
      if (v47)
      {
        BOOL v100 = v114 != 0;
        if (v114)
        {
          uint64_t v2 = (uint64_t)objc_loadWeakRetained((id *)(v114 + 16));
          uint64_t v114 = *(void *)(a1 + 32);
        }

        else
        {
          uint64_t v2 = 0LL;
        }

        v103 = (void *)(v2 + 391);
      }

      else
      {
        BOOL v100 = 0;
        v103 = &unk_1875F4C23;
      }

      if (v114)
      {
        id v101 = objc_loadWeakRetained((id *)(v114 + 16));
        char v102 = 0;
      }

      else
      {
        id v101 = 0LL;
        char v102 = 1;
      }
    }

    else
    {
      BOOL v100 = 0;
      id v101 = 0LL;
      char v102 = 1;
      v103 = &unk_1875F4C23;
    }

    *(_DWORD *)buf = 136446978;
    size_t v122 = "boringssl_context_evaluate_trust_async_external_block_invoke";
    __int16 v123 = 1024;
    int v124 = 1736;
    __int16 v125 = 2082;
    uint64_t v126 = v103;
    __int16 v127 = 2048;
    uint64_t v128 = (uint64_t)v101;
    _os_log_debug_impl( &dword_187560000,  (os_log_t)v83,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Generating ATS violation error",  buf,  0x26u);
    if ((v102 & 1) != 0)
    {
      if (!v100) {
        goto LABEL_190;
      }
    }

    else
    {

      if (!v100)
      {
LABEL_190:
        if (!v99) {
          goto LABEL_108;
        }
        goto LABEL_194;
      }
    }

    if (!v99) {
      goto LABEL_108;
    }
LABEL_194:

    goto LABEL_108;
  }

  uint64_t v48 = *(void *)(a1 + 56);
  if ((*(_BYTE *)(v48 + 559) & 0x18) != 8)
  {
    id v63 = objc_loadWeakRetained((id *)(v39 + 16));
    if (v63)
    {
      __int16 v64 = v63;
      __int16 v65 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
      char v66 = v65[475];

      if ((v66 & 1) != 0) {
        goto LABEL_136;
      }
    }

    uint64_t v67 = *(void *)(a1 + 32);
    if (v67)
    {
      id v68 = objc_loadWeakRetained((id *)(v67 + 16));
      if (v68)
      {
        unint64_t v69 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
        uint64_t v70 = (v69[475] & 1) == 0;
      }

      else
      {
        uint64_t v70 = 1LL;
      }
    }

    else
    {
      uint64_t v70 = 1LL;
    }

    if (!(_DWORD)v70 || !g_boringssl_log) {
      goto LABEL_136;
    }
    id v98 = (id)g_boringssl_log;
    if (!os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEBUG))
    {
LABEL_135:

LABEL_136:
      *(_BYTE *)(*(void *)(a1 + 56) + 558LL) &= ~8u;
      __int128 v86 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
      goto LABEL_111;
    }

    uint64_t v109 = *(void *)(a1 + 32);
    if (v109)
    {
      uint64_t v70 = (uint64_t)objc_loadWeakRetained((id *)(v109 + 16));
      uint64_t v116 = *(void *)(a1 + 32);
      if (v70)
      {
        BOOL v110 = v116 != 0;
        if (v116)
        {
          BlockSize = (char *)objc_loadWeakRetained((id *)(v116 + 16));
          uint64_t v116 = *(void *)(a1 + 32);
        }

        else
        {
          BlockSize = 0LL;
        }

        __int16 v113 = BlockSize + 391;
      }

      else
      {
        BOOL v110 = 0;
        __int16 v113 = &unk_1875F4C23;
      }

      if (v116)
      {
        id v111 = objc_loadWeakRetained((id *)(v116 + 16));
        char v112 = 0;
      }

      else
      {
        id v111 = 0LL;
        char v112 = 1;
      }
    }

    else
    {
      BOOL v110 = 0;
      id v111 = 0LL;
      char v112 = 1;
      __int16 v113 = &unk_1875F4C23;
    }

    int v117 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)buf = 136447234;
    size_t v122 = "boringssl_context_evaluate_trust_async_external_block_invoke_2";
    __int16 v123 = 1024;
    int v124 = 1751;
    __int16 v125 = 2082;
    uint64_t v126 = v113;
    __int16 v127 = 2048;
    uint64_t v128 = (uint64_t)v111;
    __int16 v129 = 1024;
    int v130 = v117;
    _os_log_debug_impl( &dword_187560000,  (os_log_t)v98,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Setting verify result to %{BOOL}d",  buf,  0x2Cu);
    if ((v112 & 1) != 0)
    {
      if (!v110) {
        goto LABEL_214;
      }
    }

    else
    {

      if (!v110)
      {
LABEL_214:
        if (!v109) {
          goto LABEL_135;
        }
        goto LABEL_218;
      }
    }

    if (!v109) {
      goto LABEL_135;
    }
LABEL_218:

    goto LABEL_135;
  }

  id v49 = objc_loadWeakRetained((id *)(v48 + 16));
  if (v49)
  {
    char v50 = v49;
    id v51 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
    char v52 = v51[475];

    if ((v52 & 1) != 0) {
      goto LABEL_129;
    }
  }

  uint64_t v53 = *(void *)(a1 + 56);
  if (v53)
  {
    id v54 = objc_loadWeakRetained((id *)(v53 + 16));
    if (v54)
    {
      char v55 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
      uint64_t v56 = (v55[475] & 1) == 0;
    }

    else
    {
      uint64_t v56 = 1LL;
    }
  }

  else
  {
    uint64_t v56 = 1LL;
  }

  if (!(_DWORD)v56 || !g_boringssl_log) {
    goto LABEL_129;
  }
  uint64_t v95 = (os_log_s *)(id)g_boringssl_log;
  if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v104 = *(void *)(a1 + 56);
    if (v104)
    {
      uint64_t v56 = (uint64_t)objc_loadWeakRetained((id *)(v104 + 16));
      uint64_t v115 = *(void *)(a1 + 56);
      if (v56)
      {
        BOOL v105 = v115 != 0;
        if (v115)
        {
          BlockSize = (char *)objc_loadWeakRetained((id *)(v115 + 16));
          uint64_t v115 = *(void *)(a1 + 56);
        }

        else
        {
          BlockSize = 0LL;
        }

        uint64_t v108 = BlockSize + 391;
      }

      else
      {
        BOOL v105 = 0;
        uint64_t v108 = &unk_1875F4C23;
      }

      if (v115)
      {
        id v106 = objc_loadWeakRetained((id *)(v115 + 16));
        char v107 = 0;
      }

      else
      {
        id v106 = 0LL;
        char v107 = 1;
      }
    }

    else
    {
      BOOL v105 = 0;
      id v106 = 0LL;
      char v107 = 1;
      uint64_t v108 = &unk_1875F4C23;
    }

    *(_DWORD *)buf = 136446978;
    size_t v122 = "boringssl_context_evaluate_trust_async_external_block_invoke";
    __int16 v123 = 1024;
    int v124 = 1745;
    __int16 v125 = 2082;
    uint64_t v126 = v108;
    __int16 v127 = 2048;
    uint64_t v128 = (uint64_t)v106;
    _os_log_debug_impl( &dword_187560000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Performing local ATS trust evaluation",  buf,  0x26u);
    if ((v107 & 1) != 0)
    {
      if (!v105) {
        goto LABEL_202;
      }
    }

    else
    {

      if (!v105)
      {
LABEL_202:
        if (!v104) {
          goto LABEL_128;
        }
        goto LABEL_206;
      }
    }

    if (!v104) {
      goto LABEL_128;
    }
LABEL_206:
  }

void __boringssl_context_certificate_verify_callback_block_invoke(uint64_t a1, char a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if (*(_DWORD *)v2 == -1252936367)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        *(_BYTE *)(v3 + 320) = a2;
        *(_BYTE *)(v3 + 558) |= 4u;
      }
    }
  }

  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
  nw_protocol_boringssl_handshake_negotiate(WeakRetained);
}

uint64_t bssl::tls13_process_certificate_verify(uint64_t a1, uint64_t a2)
{
  return bssl::tls13_process_certificate_verify_with_transcript(a1, a2, 0, 0LL, 0LL);
}

uint64_t bssl::tls13_process_certificate_verify_with_transcript( uint64_t a1, uint64_t a2, char a3, const void *a4, size_t a5)
{
  if (*(void *)(a1 + 1512))
  {
    uint64_t v9 = *(bssl **)a1;
    __int128 v20 = *(_OWORD *)(a2 + 8);
    memset(v19, 170, sizeof(v19));
    if (CBS_get_u16((unsigned __int16 **)&v20, v19)
      && CBS_get_u16_length_prefixed((unsigned __int8 **)&v20, (unint64_t *)&v19[2])
      && !*((void *)&v20 + 1))
    {
      unsigned __int8 v18 = 50;
      if (bssl::tls12_check_peer_sigalg( (bssl *)a1,  (const bssl::SSL_HANDSHAKE *)&v18,  (unsigned __int8 *)*(unsigned __int16 *)v19))
      {
        *(_WORD *)(*(void *)(a1 + 1520) + 8LL) = *(_WORD *)v19;
        uint64_t v16 = 0LL;
        size_t v17 = 0LL;
        if ((a3 & 1) != 0) {
          unsigned int v10 = 3;
        }
        else {
          unsigned int v10 = *((_BYTE *)v9 + 180) & 1;
        }
        if (bssl::tls13_get_cert_verify_signature_input(a1, (uint64_t)&v16, v10, a4, a5))
        {
          if (bssl::ssl_public_key_verify( v9,  *(uint64_t *)&v19[2],  *(uint64_t *)&v19[10],  (evp_pkey_st *)*(unsigned __int16 *)v19,  *(EVP_PKEY **)(a1 + 1512),  v16,  v17))
          {
            uint64_t v13 = 1LL;
LABEL_21:
            OPENSSL_free(v16);
            return v13;
          }

          ERR_put_error(16, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 441);
          int v15 = 51;
        }

        else
        {
          int v15 = 80;
        }

        bssl::ssl_send_alert(v9, (ssl_st *)2, v15);
        uint64_t v13 = 0LL;
        goto LABEL_21;
      }

      int v12 = v18;
      uint64_t v11 = v9;
    }

    else
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 415);
      uint64_t v11 = v9;
      int v12 = 50;
    }

    bssl::ssl_send_alert(v11, (ssl_st *)2, v12);
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 406);
  }

  return 0LL;
}

void sub_187587E44(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL bssl::tls12_check_peer_sigalg(bssl *this, const bssl::SSL_HANDSHAKE *a2, unsigned __int8 *a3)
{
  int v3 = (int)a3;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *(void *)(v5 + 264);
  if (v6)
  {
    uint64_t v7 = *(__int16 **)(v5 + 256);
  }

  else
  {
    uint64_t v7 = &bssl::kVerifySignatureAlgorithms;
    uint64_t v6 = 10LL;
  }

  uint64_t v8 = 2 * v6;
  while (1)
  {
    int v9 = (unsigned __int16)*v7;
    if (v9 == (_DWORD)a3) {
      break;
    }
    ++v7;
    v8 -= 2LL;
    if (!v8)
    {
      ERR_put_error(16, 0, 245, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 455);
      *(_BYTE *)a2 = 47;
      return v9 == v3;
    }
  }

  return v9 == v3;
}

BOOL bssl::tls13_get_cert_verify_signature_input( uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, size_t a5)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[1] = v10;
  v17[2] = v10;
  v17[0] = v10;
  CBB_zero(v17);
  uint64_t v11 = 64LL;
  do
  {
    --v11;
  }

  while (v11);
  if (a3 < 4 && CBB_add_bytes((uint64_t)v17, off_18A071360[a3], *(void *)&asc_18760A0D8[8 * a3]))
  {
    *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __dst[2] = v12;
    void __dst[3] = v12;
    __dst[0] = v12;
    __dst[1] = v12;
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    if (a4)
    {
      if (a5 - 65 < 0xFFFFFFFFFFFFFFC0LL)
      {
        int v13 = 105;
LABEL_18:
        ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", v13);
        BOOL v14 = 0LL;
        goto LABEL_16;
      }

      memcpy(__dst, a4, a5);
      unint64_t v16 = a5;
    }

    else
    {
      if (!bssl::SSLTranscript::GetHash( (bssl::SSLTranscript *)(a1 + 424),  (unsigned __int8 *)__dst,  &v16))
      {
        int v13 = 112;
        goto LABEL_18;
      }

      a5 = v16;
    }

    BOOL v14 = bssl::CBBFinishArray((uint64_t)v17, a2);
  }

  else
  {
LABEL_15:
    BOOL v14 = 0LL;
  }

void sub_18758807C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

BOOL bssl::ssl_public_key_verify( bssl *a1, uint64_t a2, uint64_t a3, evp_pkey_st *a4, EVP_PKEY *a5, const void *a6, size_t a7)
{
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v17.digest = v14;
  *(_OWORD *)&v17.flagunsigned int s = v14;
  EVP_MD_CTX_init(&v17);
  BOOL v15 = (bssl::setup_ctx(a1, (ssl_st *)&v17, a5, a4, 1) & 1) != 0
     && EVP_DigestVerify((uint64_t)&v17, a2, a3, a6, a7) != 0;
  EVP_MD_CTX_cleanup(&v17);
  return v15;
}

void sub_187588170( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::setup_ctx(bssl *this, ssl_st *a2, EVP_PKEY *a3, evp_pkey_st *a4, int a5)
{
  int v6 = (int)a4;
  if (!bssl::ssl_pkey_supports_algorithm(this, a3, a4))
  {
    ERR_put_error(16, 0, 245, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 185);
    return 0LL;
  }

  if (v6 == 65281)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    uint64_t v11 = 0LL;
    __int128 v12 = &word_18A070A20;
    do
    {
      int v13 = (unsigned __int16)*v12;
      v12 += 16;
      --v11;
    }

    while (v13 != v6);
    if (v11 == -12)
    {
      __int128 v14 = 0LL;
      uint64_t v9 = 12LL;
      goto LABEL_11;
    }

    uint64_t v9 = -v11;
  }

  __int128 v14 = (const EVP_MD *)(*((uint64_t (**)(void))&bssl::kSignatureAlgorithms + 4 * v9 + 2))();
LABEL_11:
  BOOL v15 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  if (a5)
  {
    uint64_t result = EVP_DigestVerifyInit((uint64_t)a2, &v15, v14, 0LL, (uint64_t)a3);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else
  {
    uint64_t result = EVP_DigestSignInit((uint64_t)a2, &v15, v14, 0LL, (uint64_t)a3);
    if (!(_DWORD)result) {
      return result;
    }
  }

  uint64_t result = EVP_PKEY_CTX_set_rsa_padding(v15);
  if ((_DWORD)result)
  {
    uint64_t result = EVP_PKEY_CTX_set_rsa_pss_saltlen(v15);
    if ((_DWORD)result) {
      return 1LL;
    }
  }

  return result;
}

uint64_t EVP_PKEY_id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

const EVP_MD *EVP_sha256(void)
{
  return (const EVP_MD *)&EVP_sha256_storage;
}

uint64_t EVP_DigestVerifyInit(uint64_t a1, void *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5)
{
  return do_sigver_init(a1, a2, a3, a4, a5, 1);
}

uint64_t do_sigver_init(uint64_t a1, void *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5, int a6)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t result = (uint64_t)EVP_PKEY_CTX_new(a5, (uint64_t)a4);
    *(void *)(a1 + 16) = result;
    if (!result) {
      return result;
    }
  }

  CRYPTO_once(&md_pctx_ops_once, md_pctx_ops_init);
  *(void *)(a1 + 24) = &md_pctx_ops_storage;
  __int128 v12 = *(uint64_t **)(a1 + 16);
  if (a6 == 1)
  {
    uint64_t result = EVP_PKEY_verify_init(v12);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else
  {
    uint64_t result = EVP_PKEY_sign_init(v12);
    if (!(_DWORD)result) {
      return result;
    }
  }

  if (!a3)
  {
    uint64_t v14 = 56LL;
    if (!a6) {
      uint64_t v14 = 40LL;
    }
    if (*(void *)(**(void **)(a1 + 16) + v14))
    {
      ERR_put_error( 6,  0,  119,  "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c",  109);
      return 0LL;
    }

    goto LABEL_18;
  }

  uint64_t result = EVP_PKEY_CTX_set_signature_md(*(uint64_t **)(a1 + 16));
  if ((_DWORD)result)
  {
    uint64_t v13 = 56LL;
    if (!a6) {
      uint64_t v13 = 40LL;
    }
    if (!*(void *)(**(void **)(a1 + 16) + v13)
      || (uint64_t result = EVP_DigestInit_ex((EVP_MD_CTX *)a1, a3, a4), (_DWORD)result))
    {
LABEL_18:
      if (a2) {
        *a2 = *(void *)(a1 + 16);
      }
      return 1LL;
    }
  }

  return result;
}

void *EVP_PKEY_CTX_new(uint64_t a1, uint64_t a2)
{
  if (a1 && (uint64_t v3 = *(void *)(a1 + 16)) != 0)
  {
    uint64_t v4 = *(void *)(v3 + 16);
    if (v4) {
      return evp_pkey_ctx_new((unsigned int *)a1, a2, v4);
    }
    ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 122);
    ERR_add_error_dataf("algorithm %d", v6, v7, v8, v9, v10, v11, v12, **(_DWORD **)(a1 + 16));
  }

  else
  {
    ERR_put_error(6, 0, 67, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 116);
  }

  return 0LL;
}

void *evp_pkey_ctx_new(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = OPENSSL_zalloc(0x30uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    void *v6 = a3;
    v6[1] = a2;
    *((_DWORD *)v6 + _Block_object_dispose(va, 8) = 0;
    if (a1)
    {
      EVP_PKEY_up_ref(a1);
      int64x2_t v7[2] = a1;
    }

    uint64_t v8 = *(int (**)(void *))(a3 + 8);
    if (v8 && v8(v7) <= 0)
    {
      EVP_PKEY_free((EVP_PKEY *)v7[2]);
      OPENSSL_free(v7);
      return 0LL;
    }
  }

  return v7;
}

uint64_t EVP_PKEY_up_ref(unsigned int *a1)
{
  return 1LL;
}

uint64_t pkey_rsa_init(uint64_t a1)
{
  uint64_t result = (uint64_t)OPENSSL_zalloc(0x48uLL);
  if (result)
  {
    uint64_t v3 = result;
    *(_DWORD *)uint64_t result = 2048;
    uint64_t result = 1LL;
    *(_DWORD *)(v3 + 16) = 1;
    *(_DWORD *)(v3 + 40) = -2;
    *(void *)(a1 + 40) = v3;
  }

  return result;
}

uint64_t EVP_PKEY_verify_init(uint64_t *a1)
{
  if (a1 && (uint64_t v1 = *a1) != 0 && (*(void *)(v1 + 56) || *(void *)(v1 + 64)))
  {
    *((_DWORD *)a1 + _Block_object_dispose(va, 8) = 16;
    return 1LL;
  }

  else
  {
    ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 240);
    return 0LL;
  }

uint64_t EVP_PKEY_CTX_set_signature_md(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, -1, 56);
}

uint64_t EVP_PKEY_CTX_ctrl(uint64_t *a1, int a2, int a3)
{
  if (!a1 || (v3 = *a1) == 0 || (uint64_t v4 = *(uint64_t (**)(void))(v3 + 112)) == 0LL)
  {
    int v6 = 101;
    int v7 = 192;
    goto LABEL_11;
  }

  if (a2 != -1 && *(_DWORD *)v3 != a2)
  {
    int v6 = 125;
    int v7 = 196;
    goto LABEL_11;
  }

  int v5 = *((_DWORD *)a1 + 8);
  if (!v5)
  {
    int v6 = 123;
    int v7 = 201;
    goto LABEL_11;
  }

  if (a3 != -1 && (v5 & a3) == 0)
  {
    int v6 = 114;
    int v7 = 206;
LABEL_11:
    ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", v7);
    return 0LL;
  }

  return v4();
}

uint64_t pkey_rsa_ctrl(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 40);
  switch(a2)
  {
    case 4097:
      uint64_t v11 = *(void *)(v5 + 24);
      if (a3 == 3 && v11)
      {
        ERR_put_error(6, 0, 115, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", 375);
LABEL_21:
        int v8 = 109;
        int v9 = 403;
        goto LABEL_45;
      }

      if (a3 == 4)
      {
        if ((*(_BYTE *)(a1 + 32) & 0xC0) == 0) {
          goto LABEL_21;
        }
      }

      else
      {
        if (a3 != 6) {
          goto LABEL_54;
        }
        if ((*(_BYTE *)(a1 + 32) & 0x18) == 0) {
          goto LABEL_21;
        }
      }

      if (!v11) {
        *(void *)(v5 + 24) = EVP_sha1();
      }
LABEL_54:
      *(_DWORD *)(v5 + 16) = a3;
      return 1LL;
    case 4098:
      int v7 = *(_DWORD *)(v5 + 16);
      goto LABEL_23;
    case 4099:
    case 4100:
      if (*(_DWORD *)(v5 + 16) != 6)
      {
        int v8 = 116;
        int v9 = 420;
        goto LABEL_45;
      }

      if (a2 == 4100)
      {
        int v7 = *(_DWORD *)(v5 + 40);
LABEL_23:
        *(_DWORD *)a4 = v7;
      }

      else
      {
        if (a3 < -2) {
          return 0LL;
        }
        *(_DWORD *)(v5 + 40) = a3;
      }

      return 1LL;
    case 4101:
      if (a3 <= 255)
      {
        int v8 = 112;
        int v9 = 435;
        goto LABEL_45;
      }

      *(_DWORD *)uint64_t v5 = a3;
      return 1LL;
    case 4102:
      if (!a4) {
        return 0LL;
      }
      BN_free(*(BIGNUM **)(v5 + 8));
      *(void *)(v5 + _Block_object_dispose(va, 8) = a4;
      return 1LL;
    case 4103:
    case 4104:
      if (*(_DWORD *)(v5 + 16) != 4)
      {
        int v8 = 115;
        int v9 = 452;
        goto LABEL_45;
      }

      if (a2 == 4104) {
        goto LABEL_14;
      }
      goto LABEL_37;
    case 4105:
    case 4106:
      if ((*(_DWORD *)(v5 + 16) | 2) != 6)
      {
        int v8 = 113;
        int v9 = 477;
        goto LABEL_45;
      }

      if (a2 != 4106)
      {
        *(void *)(v5 + RAND_bytes(buf, 32) = a4;
        return 1LL;
      }

      uint64_t v10 = *(void *)(v5 + 32);
      if (v10) {
        goto LABEL_15;
      }
      goto LABEL_14;
    case 4107:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        OPENSSL_free(*(void **)(v5 + 56));
        uint64_t v12 = *(void *)(a4 + 8);
        *(void *)(v5 + 56) = *(void *)a4;
        *(void *)(v5 + 64) = v12;
        return 1LL;
      }

      int v8 = 115;
      int v9 = 493;
      goto LABEL_45;
    case 4108:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        uint64_t v13 = *(void *)(v5 + 64);
        *(void *)a4 = *(void *)(v5 + 56);
        *(void *)(a4 + _Block_object_dispose(va, 8) = v13;
        return 1LL;
      }

      int v8 = 115;
      int v9 = 505;
      goto LABEL_45;
    default:
      if (a2 == 1)
      {
        if (!a4 || *(_DWORD *)(v5 + 16) != 3)
        {
LABEL_37:
          *(void *)(v5 + 24) = a4;
          return 1LL;
        }

        int v8 = 115;
        int v9 = 375;
        goto LABEL_45;
      }

      if (a2 != 2)
      {
        int v8 = 101;
        int v9 = 512;
LABEL_45:
        ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa.c", v9);
        return 0LL;
      }

uint64_t sha256_init(uint64_t a1)
{
  return digest_init(*(void *)(a1 + 8));
}

uint64_t EVP_PKEY_CTX_set_rsa_padding(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, -1);
}

uint64_t EVP_PKEY_CTX_set_rsa_pss_saltlen(uint64_t *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 24);
}

uint64_t EVP_DigestVerify(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(*(void *)v6 + 56LL))
  {
  }

  else
  {
    int v8 = *(uint64_t (**)(void))(*(void *)v6 + 64LL);
    if (v8) {
      return v8();
    }
    ERR_put_error( 6,  0,  125,  "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c",  255);
  }

  return 0LL;
}

uint64_t EVP_DigestVerifyUpdate(uint64_t a1, const void *a2, size_t a3)
{
  if (*(void *)(**(void **)(a1 + 16) + 56LL)) {
    return EVP_DigestUpdate((EVP_MD_CTX *)a1, a2, a3);
  }
  ERR_put_error( 6,  0,  125,  "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c",  144);
  return 0LL;
}

BOOL EVP_DigestVerifyFinal(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (*(void *)(**(void **)(a1 + 16) + 56LL))
  {
    *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&ctx.digest = v2;
    *(_OWORD *)&ctx.flagunsigned int s = v2;
    __int128 v9 = v2;
    __int128 v10 = v2;
    *(_OWORD *)md = v2;
    __int128 v8 = v2;
    unsigned int s = -1431655766;
    EVP_MD_CTX_init(&ctx);
    BOOL v3 = EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)a1)
      && EVP_DigestFinal_ex(&ctx, md, &s)
      && EVP_PKEY_verify(*(_DWORD **)(a1 + 16)) != 0;
    EVP_MD_CTX_cleanup(&ctx);
  }

  else
  {
    ERR_put_error( 6,  0,  125,  "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/digestsign/digestsign.c",  186);
    return 0LL;
  }

  return v3;
}

EVP_PKEY **EVP_PKEY_CTX_dup(uint64_t a1)
{
  if (!*(void *)a1 || !*(void *)(*(void *)a1 + 16LL)) {
    return 0LL;
  }
  __int128 v2 = (EVP_PKEY **)OPENSSL_zalloc(0x30uLL);
  BOOL v3 = v2;
  if (v2)
  {
    *(_OWORD *)__int128 v2 = *(_OWORD *)a1;
    *((_DWORD *)v2 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
    uint64_t v4 = *(unsigned int **)(a1 + 16);
    if (v4)
    {
      EVP_PKEY_up_ref(v4);
      v3[2] = *(EVP_PKEY **)(a1 + 16);
    }

    uint64_t v5 = *(unsigned int **)(a1 + 24);
    if (v5)
    {
      EVP_PKEY_up_ref(v5);
      v3[3] = *(EVP_PKEY **)(a1 + 24);
    }

    if ((*(int (**)(EVP_PKEY **, uint64_t))(*(void *)a1 + 16LL))(v3, a1) <= 0)
    {
      void *v3 = 0LL;
      EVP_PKEY_CTX_free(v3);
      ERR_put_error(6, 0, 6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 180);
      return 0LL;
    }
  }

  return v3;
}

BIGNUM *pkey_rsa_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = (BIGNUM *)OPENSSL_zalloc(0x48uLL);
  if (result)
  {
    uint64_t v5 = result;
    LODWORD(result->d) = 2048;
    result->neg = 1;
    result[1].neg = -2;
    *(void *)(a1 + 40) = result;
    uint64_t v6 = *(void *)(a2 + 40);
    LODWORD(result->d) = *(_DWORD *)v6;
    int v7 = *(const BIGNUM **)(v6 + 8);
    if (!v7 || (uint64_t result = BN_dup(v7), (*(void *)&v5->top = result) != 0LL))
    {
      v5->neg = *(_DWORD *)(v6 + 16);
      *(_OWORD *)&v5[1].d = *(_OWORD *)(v6 + 24);
      v5[1].neg = *(_DWORD *)(v6 + 40);
      if (*(void *)(v6 + 56))
      {
        OPENSSL_free(*(void **)&v5[2].top);
        uint64_t result = (BIGNUM *)OPENSSL_memdup(*(const void **)(v6 + 56), *(void *)(v6 + 64));
        *(void *)&v5[2].top = result;
        if (!result) {
          return result;
        }
        *(void *)&v5[2].neg = *(void *)(v6 + 64);
      }

      return (BIGNUM *)1;
    }
  }

  return result;
}

uint64_t EVP_PKEY_verify(_DWORD *a1)
{
  if (a1 && *(void *)a1 && (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 56LL)) != 0LL)
  {
    if (a1[8] == 16) {
      return v1();
    }
    int v3 = 126;
    int v4 = 254;
  }

  else
  {
    int v3 = 125;
    int v4 = 250;
  }

  ERR_put_error(6, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

uint64_t pkey_rsa_verify(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(RSA **)(v11 + 8);
  uint64_t v13 = *(EVP_MD **)(v10 + 24);
  if (v13)
  {
    int v14 = *(_DWORD *)(v10 + 16);
    if (v14 != 6)
    {
      if (v14 == 1)
      {
        int v15 = EVP_MD_type(*(const EVP_MD **)(v10 + 24));
        return RSA_verify(v15, a4, a5, a2, a3, v12);
      }

      return 0LL;
    }

    return RSA_verify_pss_mgf1( *(void *)(v11 + 8),  a4,  a5,  v13,  *(const EVP_MD **)(v10 + 32),  *(_DWORD *)(v10 + 40),  (uint64_t)a2,  a3);
  }

  else
  {
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
    int v17 = EVP_PKEY_size((EVP_PKEY *)v11);
    uint64_t result = setup_tbuf(v10, a1);
    if (!(_DWORD)result) {
      return result;
    }
    if (RSA_verify_raw( (uint64_t)v12,  &v19,  *(unsigned __int8 **)(v10 + 48),  v17,  (uint64_t)a2,  a3,  *(_DWORD *)(v10 + 16))) {
      BOOL v18 = v19 == a5;
    }
    else {
      BOOL v18 = 0;
    }
    if (!v18) {
      return 0LL;
    }
    return CRYPTO_memcmp((char *)a4, *(char **)(v10 + 48), a5) == 0;
  }

uint64_t RSA_verify_pss_mgf1( uint64_t a1, const void *a2, uint64_t a3, EVP_MD *md, const EVP_MD *a5, int a6, uint64_t a7, uint64_t a8)
{
  if (EVP_MD_size(md) == a3)
  {
    if (a1) {
      size_t v15 = BN_num_bytes(*(const BIGNUM **)(a1 + 8));
    }
    else {
      size_t v15 = 0LL;
    }
    size_t v25 = v15;
    BOOL v18 = (unsigned __int8 *)malloc(v15);
    if (v18)
    {
      __int128 v20 = (char *)v18;
      if (RSA_verify_raw(a1, &v25, v18, v19, a7, a8, 3))
      {
        size_t v21 = v25;
        if (a1) {
          uint64_t v22 = BN_num_bytes(*(const BIGNUM **)(a1 + 8));
        }
        else {
          uint64_t v22 = 0LL;
        }
        if (v21 == v22)
        {
          uint64_t v23 = RSA_verify_PKCS1_PSS_mgf1(a1, a2, md, a5, v20, a6);
LABEL_17:
          free(v20);
          return v23;
        }

        ERR_put_error( 4,  0,  68,  "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m",  372);
      }

      uint64_t v23 = 0LL;
      goto LABEL_17;
    }

    int v16 = 65;
    int v17 = 362;
  }

  else
  {
    int v16 = 125;
    int v17 = 355;
  }

  ERR_put_error(4, 0, v16, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v17);
  return 0LL;
}

uint64_t BN_num_bytes(const BIGNUM *a1)
{
  return (BN_num_bits(a1) + 7) >> 3;
}

int BN_num_bits(const BIGNUM *a)
{
  uint64_t top = a->top;
  int v2 = top & ((int)top >> 31);
  uint64_t v3 = 8 * top - 8;
  int v4 = a->top;
  while (1)
  {
    BOOL v5 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v5) {
      break;
    }
    d = a->d;
    uint64_t v7 = *(unint64_t *)((char *)a->d + v3);
    v3 -= 8LL;
    if (v7)
    {
      int v2 = v4 + 1;
      return BN_num_bits_word(d[v2 - 1]) + ((v2 - 1) << 6);
    }
  }

  if ((top & 0x80000000) == 0) {
    return 0;
  }
  d = a->d;
  return BN_num_bits_word(d[v2 - 1]) + ((v2 - 1) << 6);
}

int BN_num_bits_word(unint64_t a1)
{
  unint64_t v1 = HIDWORD(a1);
  if (!HIDWORD(a1)) {
    unint64_t v1 = a1;
  }
  int v2 = (a1 != 0) | (32 * (HIDWORD(a1) != 0)) | (16 * (v1 >> 16 != 0));
  if (v1 >> 16) {
    v1 >>= 16;
  }
  int v3 = v2 | (8 * (v1 > 0xFF));
  if (v1 > 0xFF) {
    v1 >>= 8;
  }
  int v4 = v3 | (4 * (v1 > 0xF));
  if (v1 > 0xF) {
    v1 >>= 4;
  }
  int v5 = v4 | (2 * (v1 > 3));
  if (v1 > 3) {
    v1 >>= 2;
  }
  if (v1 <= 1) {
    return v5;
  }
  else {
    return v5 + 1;
  }
}

uint64_t RSA_verify_raw( uint64_t a1, void *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if (!a1)
  {
    int v11 = 67;
    int v12 = 234;
    goto LABEL_19;
  }

  if (BN_num_bytes(*(const BIGNUM **)(a1 + 8)) >= 0x401)
  {
    int v11 = 500;
    int v12 = 238;
LABEL_19:
    ERR_put_error(4, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v12);
    return 0LL;
  }

  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  BOOL v28 = 0LL;
  uint64_t v13 = *(const BIGNUM **)(a1 + 8);
  if (!v13 || !*(void *)(a1 + 16))
  {
    int v11 = 144;
    int v12 = 247;
    goto LABEL_19;
  }

  unsigned int v14 = BN_num_bytes(v13);
  uint64_t v15 = ccrsa_import_pub_n();
  int v16 = malloc(24 * v15 + 40);
  if (!v16)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      RSA_verify_raw_cold_1();
    }
    return 0LL;
  }

  int v17 = v16;
  void *v16 = v15;
  BOOL v18 = malloc(8 * v15);
  uint64_t v19 = malloc(8 * v15);
  __int128 v20 = v19;
  if (!v18 || !v19)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      RSA_verify_raw_cold_2();
    }
    free(v17);
    if (v18) {
      free(v18);
    }
    if (v20) {
      free(v20);
    }
    return 0LL;
  }

  ccn_zero();
  ccn_zero();
  ccn_read_uint();
  if (a7 == 3)
  {
    *a2 = v14;
    ccn_write_uint_padded();
    uint64_t v23 = a3;
    if ((v14 & 0x80000000) == 0)
    {
LABEL_34:
      *a2 = v14;
      uint64_t v21 = 1LL;
LABEL_43:
      if (v23 != a3 && v23) {
        free(v23);
      }
      goto LABEL_15;
    }

    goto LABEL_39;
  }

  uint64_t v24 = (unsigned __int8 *)malloc(v14);
  if (v24)
  {
    uint64_t v23 = v24;
    *a2 = v14;
    ccn_write_uint_padded();
    if (a7 != 1)
    {
      int v25 = 143;
      int v26 = 314;
      goto LABEL_42;
    }

    if (RSA_padding_check_PKCS1_type_1(a3, (int)a2, (const unsigned __int8 *)v14, (int)v23, v14))
    {
      unsigned int v14 = *(_DWORD *)a2;
      if ((*(_DWORD *)a2 & 0x80000000) == 0) {
        goto LABEL_34;
      }
    }

LABEL_39:
    int v25 = 136;
    int v26 = 319;
LABEL_42:
    ERR_put_error(4, 0, v25, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v26);
    uint64_t v21 = 0LL;
    goto LABEL_43;
  }

  ERR_put_error(4, 0, 65, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 295);
LABEL_14:
  uint64_t v21 = 0LL;
LABEL_15:
  if (v28) {
    OPENSSL_free(v28);
  }
  free(v18);
  free(v20);
  free(v17);
  return v21;
}

    if (v2) {
      return v4;
    }
    else {
      return v3;
    }
  }

  if (a1 <= 85)
  {
    switch(a1)
    {
      case 'F':
        return 4294957460LL;
      case 'G':
        int v2 = a2 == 16388;
        int v3 = -9802;
        int v4 = -9837;
        break;
      case 'P':
        int v2 = a2 == 16388;
        int v3 = -9810;
        int v4 = -9838;
        break;
      default:
        return 4294957494LL;
    }

    goto LABEL_39;
  }

  switch(a1)
  {
    case 'd':
      int v2 = a2 == 16388;
      int v3 = -9800;
      int v4 = -9840;
      goto LABEL_39;
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
      return 4294957494LL;
    case 'n':
    case 'o':
    case 'p':
    case 'q':
      return 4294957496LL;
    case 'r':
      return 4294957488LL;
    case 's':
      return 4294957432LL;
    case 't':
      int v2 = a2 == 16388;
      int v3 = -9863;
      int v4 = -9829;
      goto LABEL_39;
    default:
      if (a1 == 86)
      {
        uint64_t result = 4294957436LL;
      }

      else
      {
        if (a1 != 90) {
          return 4294957494LL;
        }
        uint64_t result = 4294957457LL;
      }

      break;
  }

  return result;
}

uint64_t RSA_public_key_to_bytes(void *a1, void *a2, uint64_t a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  v8[2] = v6;
  v8[0] = v6;
  CBB_zero(v8);
  if (CBB_init((uint64_t)v8, 0LL)
    && RSA_marshal_public_key((uint64_t *)v8, a3)
    && CBB_finish((uint64_t)v8, a1, a2))
  {
    return 1LL;
  }

  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 145);
  CBB_cleanup((uint64_t)v8);
  return 0LL;
}

uint64_t RSA_marshal_public_key(uint64_t *a1, uint64_t a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v4;
  v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v6, 0x20000010u)
    && marshal_integer((uint64_t *)v6, *(const BIGNUM **)(a2 + 8))
    && marshal_integer((uint64_t *)v6, *(const BIGNUM **)(a2 + 16))
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 132);
  return 0LL;
}

uint64_t CBB_add_asn1(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  if ((a3 & 0x1FFFFFFF) < 0x1F)
  {
  }

  else if (!cbb_add_u((uint64_t)a1, HIBYTE(a3) | 0x1F, 1uLL) {
         || !add_base128_integer((uint64_t)a1, a3 & 0x1FFFFFFF))
  }
  {
    return 0LL;
  }

  return cbb_add_child((uint64_t)a1, a2, 1u, 1);
}

uint64_t BN_marshal_asn1(uint64_t *a1, const BIGNUM *a2)
{
  if (BN_is_negative((uint64_t)a2))
  {
    int v4 = 109;
    int v5 = 41;
  }

  else
  {
    *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[1] = v6;
    __int128 v9[2] = v6;
    v9[0] = v6;
    if (CBB_add_asn1(a1, (uint64_t)v9, 2u)
      && ((BN_num_bits(a2) & 7) != 0 || CBB_add_u8((uint64_t)v9, 0)))
    {
      unsigned int v7 = BN_num_bytes(a2);
      if (BN_bn2cbb_padded((uint64_t)v9, v7, (uint64_t)a2))
      {
      }
    }

    int v4 = 118;
    int v5 = 52;
  }

  ERR_put_error(3, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bn_extra/bn_asn1.c", v5);
  return 0LL;
}

BOOL BN_is_negative(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) != 0;
}

uint64_t BN_bn2cbb_padded(uint64_t a1, unint64_t a2, uint64_t a3)
{
  __int128 v6 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBB_add_space(a1, &v6, a2);
  if ((_DWORD)result) {
    return BN_bn2bin_padded(v6, a2, a3) != 0;
  }
  return result;
}

uint64_t BN_bn2bin_padded(char *a1, unint64_t a2, uint64_t a3)
{
  int v4 = *(char **)a3;
  uint64_t v5 = *(int *)(a3 + 8);
  if (a2 < 8 * v5)
  {
    int v6 = 0;
    unint64_t v7 = a2 - 8 * v5;
    __int128 v8 = &v4[a2];
    do
    {
      int v9 = *v8++;
      v6 |= v9;
    }

    while (!__CFADD__(v7++, 1LL));
    if (v6) {
      return 0LL;
    }
  }

  bn_words_to_big_endian(a1, a2, v4, v5);
  return 1LL;
}

void bn_words_to_big_endian(char *a1, unint64_t a2, char *a3, uint64_t a4)
{
  unint64_t v4 = 8 * a4;
  if (a2 >= 8 * a4)
  {
    BOOL v10 = 1;
  }

  else
  {
    int v5 = 0;
    unint64_t v6 = a2 - v4;
    unint64_t v7 = &a3[a2];
    do
    {
      int v8 = *v7++;
      v5 |= v8;
    }

    while (!__CFADD__(v6++, 1LL));
    BOOL v10 = v5 == 0;
  }

  if (!v10) {
    bn_words_to_big_endian_cold_1();
  }
  if (v4 >= a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = 8 * a4;
  }
  if (v11)
  {
    int v12 = &a1[a2 - 1];
    uint64_t v13 = v11;
    do
    {
      char v14 = *a3++;
      *v12-- = v14;
      --v13;
    }

    while (v13);
  }

  if (a2 > v4) {
    bzero(a1, a2 - v11);
  }
}

uint64_t RSA_verify_PKCS1_PSS_mgf1( uint64_t a1, const void *a2, const EVP_MD *a3, const EVP_MD *a4, char *a5, int a6)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (a4) {
    uint64_t v11 = a4;
  }
  else {
    uint64_t v11 = a3;
  }
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.digest = v12;
  *(_OWORD *)&ctx.flagunsigned int s = v12;
  EVP_MD_CTX_init(&ctx);
  size_t v13 = EVP_MD_size(a3);
  size_t v14 = v13;
  if (a6 == -2) {
    goto LABEL_9;
  }
  if (a6 == -1)
  {
    a6 = v13;
    goto LABEL_9;
  }

  if (a6 > -3)
  {
LABEL_9:
    int v17 = (BN_num_bits(*(const BIGNUM **)(a1 + 8)) - 1) & 7;
    unsigned int v18 = RSA_size((const RSA *)a1);
    if (*a5 >> v17)
    {
      int v15 = 122;
      int v16 = 240;
      goto LABEL_21;
    }

    uint64_t v19 = v18;
    if (v17) {
      __int128 v20 = a5;
    }
    else {
      __int128 v20 = a5 + 1;
    }
    if (v17) {
      uint64_t v21 = 0LL;
    }
    else {
      uint64_t v21 = -1LL;
    }
    unint64_t v22 = v18 - (unint64_t)(v17 == 0);
    if (v22 < v14 + 2 || (a6 & 0x80000000) == 0 && v22 < v14 + 2 + a6)
    {
      int v15 = 113;
      int v16 = 250;
      goto LABEL_21;
    }

    if (v20[v22 - 1] != 188)
    {
      int v15 = 127;
      int v16 = 254;
      goto LABEL_21;
    }

    uint64_t v38 = v21;
    unint64_t v26 = v22 + ~v14;
    unint64_t v27 = (unsigned __int8 *)OPENSSL_malloc(v26);
    uint64_t v24 = v27;
    if (v27)
    {
      __s2 = &v20[v26];
      if (PKCS1_MGF1(v27, v26, (const unsigned __int8 *)&v20[v26], v14, v11))
      {
        if (v26)
        {
          BOOL v28 = v24;
          unint64_t v29 = v26;
          do
          {
            char v30 = *v20++;
            *v28++ ^= v30;
            --v29;
          }

          while (v29);
        }

        if (v17) {
          *(_BYTE *)v24 &= 0xFFu >> (8 - v17);
        }
        unint64_t v31 = 0LL;
        do
        {
          int v32 = *((unsigned __int8 *)v24 + v31);
          unint64_t v33 = v31 + 1;
          if (v31 >= v26 - 1) {
            break;
          }
          ++v31;
        }

        while (!v32);
        if (v32 == 1)
        {
          if (a6 < 0 || ~v14 + v38 + v19 - a6 == v33)
          {
            *(void *)&__int128 v36 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __int128 v42 = v36;
            __int128 v43 = v36;
            *(_OWORD *)md = v36;
            __int128 v41 = v36;
            if (!EVP_DigestInit_ex(&ctx, a3, 0LL)
              || !EVP_DigestUpdate(&ctx, &kPSSZeroes, 8uLL)
              || !EVP_DigestUpdate(&ctx, a2, v14)
              || !EVP_DigestUpdate(&ctx, (char *)v24 + v33, v26 - v33)
              || !EVP_DigestFinal_ex(&ctx, md, 0LL))
            {
              goto LABEL_41;
            }

            if (!v14 || !memcmp(md, __s2, v14))
            {
              uint64_t v23 = 1LL;
              goto LABEL_22;
            }

            int v34 = 105;
            int v35 = 299;
          }

          else
          {
            int v34 = 138;
            int v35 = 287;
          }
        }

        else
        {
          int v34 = 139;
          int v35 = 281;
        }

        ERR_put_error(4, 0, v34, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v35);
      }
    }

int RSA_size(const RSA *a1)
{
  if (a1) {
    LODWORD(a1) = BN_num_bytes((const BIGNUM *)a1->version);
  }
  return (int)a1;
}

int PKCS1_MGF1( unsigned __int8 *mask, uint64_t len, const unsigned __int8 *seed, uint64_t seedlen, const EVP_MD *dgst)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.digest = v10;
  *(_OWORD *)&ctx.flagunsigned int s = v10;
  EVP_MD_CTX_init(&ctx);
  unint64_t v11 = EVP_MD_size(dgst);
  if (len)
  {
    unint64_t v12 = v11;
    unsigned int v13 = 0;
    while (1)
    {
      unsigned int d = bswap32(v13);
      if (!EVP_DigestInit_ex(&ctx, dgst, 0LL)
        || !EVP_DigestUpdate(&ctx, seed, seedlen)
        || !EVP_DigestUpdate(&ctx, &d, 4uLL))
      {
        break;
      }

      if (len < v12)
      {
        *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v21 = v14;
        __int128 v22 = v14;
        *(_OWORD *)munsigned int d = v14;
        __int128 v20 = v14;
        if (EVP_DigestFinal_ex(&ctx, md, 0LL))
        {
          memcpy(mask, md, len);
          goto LABEL_12;
        }

        break;
      }

      if (!EVP_DigestFinal_ex(&ctx, mask, 0LL)) {
        break;
      }
      mask += v12;
      ++v13;
      len -= v12;
      if (!len) {
        goto LABEL_12;
      }
    }

    int v15 = 0;
  }

  else
  {
LABEL_12:
    int v15 = 1;
  }

  EVP_MD_CTX_cleanup(&ctx);
  return v15;
}

void EVP_PKEY_CTX_free(EVP_PKEY **a1)
{
  if (a1)
  {
    if (*a1)
    {
      int v2 = *(void (**)(EVP_PKEY **))&(*a1)->save_parameters;
      if (v2) {
        v2(a1);
      }
    }

    EVP_PKEY_free(a1[2]);
    EVP_PKEY_free(a1[3]);
    OPENSSL_free(a1);
  }

void pkey_rsa_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    BN_free(*(BIGNUM **)(v1 + 8));
    OPENSSL_free(*(void **)(v1 + 48));
    OPENSSL_free(*(void **)(v1 + 56));
    OPENSSL_free((void *)v1);
  }

void BN_free(BIGNUM *a)
{
  if (a)
  {
    flagunsigned int s = a->flags;
    if ((flags & 2) == 0)
    {
      OPENSSL_free(a->d);
      flagunsigned int s = a->flags;
    }

    if ((flags & 1) != 0) {
      OPENSSL_free(a);
    }
    else {
      a->unsigned int d = 0LL;
    }
  }

void EVP_PKEY_free(EVP_PKEY *pkey)
{
  if (pkey && CRYPTO_refcount_dec_and_test_zero((unsigned int *)pkey))
  {
    ptr = pkey->pkey.ptr;
    if (ptr)
    {
      int v3 = (void (*)(EVP_PKEY *))*((void *)ptr + 20);
      if (v3)
      {
        v3(pkey);
        *(void *)&pkey->referenceunsigned int s = 0LL;
        pkey->save_type = 0;
      }
    }

    OPENSSL_free(pkey);
  }

BOOL CRYPTO_refcount_dec_and_test_zero(unsigned int *a1)
{
  unsigned int v1 = atomic_load(a1);
  while (v1 != -1)
  {
    if (!v1) {
      abort();
    }
    unsigned int v2 = v1 - 1;
    unsigned int v3 = __ldaxr(a1);
    if (v3 != v1)
    {
      __clrex();
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }

    if (__stlxr(v2, a1)) {
      goto LABEL_8;
    }
    int v4 = 1;
LABEL_9:
    unsigned int v1 = v3;
    if (v4) {
      return v2 == 0;
    }
  }

  return 0LL;
}

uint64_t bssl::tls13_process_finished(char *a1, uint64_t a2, int a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v4 = *(bssl **)a1;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v10[2] = v5;
  _OWORD v10[3] = v5;
  v10[0] = v5;
  v10[1] = v5;
  if (a3)
  {
    if ((*((_BYTE *)v4 + 180) & 1) == 0) {
      bssl::tls13_process_finished();
    }
    unint64_t v6 = a1 + 328;
    uint64_t v7 = *((void *)a1 + 4);
  }

  else
  {
    *(void *)int v9 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = bssl::tls13_finished_mac( (bssl *)a1,  (bssl::SSL_HANDSHAKE *)v10,  v9,  (unint64_t *)((*((_BYTE *)v4 + 180) & 1) == 0));
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v7 = *(void *)v9;
    unint64_t v6 = (char *)v10;
  }

  if (CBS_mem_equal(a2 + 8, v6, v7)) {
    return 1LL;
  }
  bssl::ssl_send_alert(v4, (ssl_st *)2, 51);
  ERR_put_error(16, 0, 142, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 472);
  return 0LL;
}

uint64_t bssl::tls13_finished_mac( bssl *this, bssl::SSL_HANDSHAKE *a2, unsigned __int8 *a3, unint64_t *a4)
{
  int v4 = (int)a4;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *((void *)this + 4);
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v18 = v9;
  __int128 v19 = v9;
  *(_OWORD *)int v16 = v9;
  __int128 v17 = v9;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v10 = (bssl *)((char *)this + 424);
  uint64_t result = bssl::SSLTranscript::GetHash((bssl *)((char *)this + 424), v16, &v15);
  if ((_DWORD)result)
  {
    uint64_t v12 = 136LL;
    if (v4) {
      uint64_t v12 = 184LL;
    }
    unsigned int v13 = (char *)this + v12;
    __int128 v14 = (EVP_MD *)bssl::SSLTranscript::Digest(v10);
    return bssl::tls13_verify_data((unsigned __int8 *)a2, a3, v14, (uint64_t)v13, v8, v16, v15);
  }

  return result;
}

uint64_t bssl::tls13_verify_data( unsigned __int8 *a1, void *a2, EVP_MD *md, uint64_t a4, uint64_t a5, const unsigned __int8 *a6, size_t a7)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  key[2] = v14;
  key[3] = v14;
  key[0] = v14;
  key[1] = v14;
  int v15 = EVP_MD_size(md);
  unsigned int md_len = 0;
  BOOL v16 = CRYPTO_tls13_hkdf_expand_label((int)key, v15, md, a4, a5, "finished", 8uLL, 0LL, 0LL);
  uint64_t result = 0LL;
  if (v16)
  {
    uint64_t result = (uint64_t)HMAC(md, key, v15, a6, a7, a1, &md_len);
    if (result)
    {
      *a2 = md_len;
      return 1LL;
    }
  }

  return result;
}

unsigned __int8 *__cdecl HMAC( const EVP_MD *evp_md, const void *key, int key_len, const unsigned __int8 *d, size_t n, unsigned __int8 *md, unsigned int *md_len)
{
  if (md) {
    __int128 v9 = md;
  }
  else {
    __int128 v9 = (unsigned __int8 *)&HMAC_static_out_buffer;
  }
  int v10 = EVP_MD_type(evp_md);
  uint64_t v11 = boringssl_crypto_hash_nid_to_cc_digest(v10);
  if (v11)
  {
    uint64_t v12 = (unsigned int *)v11;
    unsigned int v13 = malloc(((*(void *)(v11 + 8) + *(void *)(v11 + 16) + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + *(void *)(v11 + 8));
    if (!v13) {
      return 0LL;
    }
    __int128 v14 = v13;
    cchmac_init();
    cchmac_update();
    cchmac_final();
    cc_clear();
    free(v14);
    if (md_len)
    {
      unsigned int v15 = *v12;
LABEL_13:
      *unsigned int md_len = v15;
    }
  }

  else
  {
    BOOL v16 = (void *)g_boringssl_log;
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      HMAC_cold_1(v16, evp_md);
    }
    __int128 v9 = 0LL;
    if (md_len)
    {
      unsigned int v15 = 0;
      goto LABEL_13;
    }
  }

  return v9;
}

uint64_t bssl::tls13_derive_application_secrets(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *(void *)this;
  int v4 = (bssl *)((char *)this + 424);
  *(_BYTE *)(*(void *)(v3 + 48) + 442LL) = bssl::SSLTranscript::DigestLen((bssl *)((char *)this + 424));
  if (bssl::derive_secret_with_transcript( (uint64_t)this,  (int)this + 232,  *((void *)this + 4),  v4,  "c ap traffic",  0xCuLL)
    && bssl::ssl_log_secret( v3,  "CLIENT_TRAFFIC_SECRET_0",  (unsigned __int8 *)this + 232,  *((void *)this + 4))
    && bssl::derive_secret_with_transcript( (uint64_t)this,  (int)this + 280,  *((void *)this + 4),  v4,  "s ap traffic",  0xCuLL)
    && bssl::ssl_log_secret( v3,  "SERVER_TRAFFIC_SECRET_0",  (unsigned __int8 *)this + 280,  *((void *)this + 4))
    && bssl::derive_secret_with_transcript( (uint64_t)this,  *(void *)(v3 + 48) + 392,  *(unsigned __int8 *)(*(void *)(v3 + 48) + 442LL),  v4,  "exp master",  0xAuLL))
  {
    return bssl::ssl_log_secret( v3,  "EXPORTER_SECRET",  (unsigned __int8 *)(*(void *)(v3 + 48) + 392LL),  *(unsigned __int8 *)(*(void *)(v3 + 48) + 442LL));
  }

  else
  {
    return 0LL;
  }

uint64_t bssl::tls13_add_finished(bssl **this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  unsigned int v2 = *this;
  *(void *)int v10 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v11[2] = v3;
  _OWORD v11[3] = v3;
  v11[0] = v3;
  v11[1] = v3;
  if ((bssl::tls13_finished_mac( (bssl *)this,  (bssl::SSL_HANDSHAKE *)v11,  v10,  (unint64_t *)(*((_BYTE *)v2 + 180) & 1)) & 1) != 0)
  {
    *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[1] = v4;
    __int128 v9[2] = v4;
    v9[0] = v4;
    CBB_zero(v9);
    *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v8[1] = v5;
    v8[2] = v5;
    v8[0] = v5;
    if ((*(unsigned int (**)(bssl *, _OWORD *, _OWORD *, uint64_t))(*(void *)v2 + 88LL))(v2, v9, v8, 20LL)
      && CBB_add_bytes((uint64_t)v8, v11, *(size_t *)v10))
    {
      uint64_t v6 = bssl::ssl_add_message_cbb((uint64_t)v2, (uint64_t)v9);
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    CBB_cleanup((uint64_t)v9);
  }

  else
  {
    bssl::ssl_send_alert(v2, (ssl_st *)2, 80);
    ERR_put_error(16, 0, 142, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 854);
    return 0LL;
  }

  return v6;
}

void sub_18758A604( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_add_message_cbb(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  if ((*(unsigned int (**)(uint64_t, uint64_t, void **))(*(void *)a1 + 96LL))(a1, a2, &v8))
  {
    __int128 v3 = *(uint64_t (**)(uint64_t, void **))(*(void *)a1 + 104LL);
    OPENSSL_free(0LL);
    uint64_t v6 = v8;
    uint64_t v7 = v9;
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    uint64_t v4 = v3(a1, &v6);
    OPENSSL_free(v6);
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  OPENSSL_free(v8);
  return v4;
}

void sub_18758A6C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t EVP_AEAD_CTX_tag_len(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  if (a4 && !*(_DWORD *)(v5 + 4)) {
    EVP_AEAD_CTX_tag_len_cold_1();
  }
  uint64_t v6 = *(uint64_t (**)(void))(v5 + 64);
  if (v6)
  {
    uint64_t v7 = v6();
LABEL_8:
    uint64_t v9 = 1LL;
    goto LABEL_9;
  }

  uint64_t v8 = *((unsigned __int8 *)a1 + 576);
  uint64_t v7 = v8 + a4;
  if (!__CFADD__(v8, a4)) {
    goto LABEL_8;
  }
  ERR_put_error(30, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", 281);
  uint64_t v7 = 0LL;
  uint64_t v9 = 0LL;
LABEL_9:
  *a2 = v7;
  return v9;
}

uint64_t EVP_AEAD_CTX_seal_scatter( uint64_t *a1, char *a2, char *a3, void *a4, size_t a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v15 = (unint64_t)&a8[a9];
  BOOL v16 = &a2[a9];
  if (a8 != a2 && (v15 > (unint64_t)a2 ? (BOOL v17 = v16 > a8) : (BOOL v17 = 0), v17)
    || &a3[a5] > a2 && v16 > a3
    || &a3[a5] > a8 && v15 > (unint64_t)a3)
  {
    int v18 = 115;
    int v19 = 162;
LABEL_11:
    ERR_put_error(30, 0, v18, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v19);
    goto LABEL_12;
  }

  uint64_t v21 = *a1;
  if (a11 && !*(_DWORD *)(v21 + 4))
  {
    int v18 = 112;
    int v19 = 167;
    goto LABEL_11;
  }

BOOL aead_aes_gcm_tls13_seal_scatter( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a7 != 12)
  {
    int v15 = 121;
    int v16 = 478;
LABEL_9:
    ERR_put_error( 30,  0,  v15,  "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m",  v16);
    return 0LL;
  }

  unint64_t v13 = bswap64(*(void *)(a6 + 4));
  if (*(_BYTE *)(a1 + 64))
  {
    *(void *)(a1 + 56) = v13;
    *(_BYTE *)(a1 + 64) = 0;
    unint64_t v14 = v13;
  }

  else
  {
    unint64_t v14 = *(void *)(a1 + 56);
  }

  unint64_t v17 = v14 ^ v13;
  if (v17 == -1LL || v17 < *(void *)(a1 + 48))
  {
    int v15 = 125;
    int v16 = 498;
    goto LABEL_9;
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v17 + 1;
  return aead_aes_gcm_seal_scatter(a1, a2, a3, a4, a5, a6, 12LL, a8, a9, a10, a11, a12, a13);
}

BOOL aead_aes_gcm_seal_scatter( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a7)
  {
    int v15 = 111;
    int v16 = 291;
    goto LABEL_15;
  }

  unint64_t v14 = *(unsigned __int8 *)(a1 + 24) + a11;
  if (v14 < *(unsigned __int8 *)(a1 + 576))
  {
    int v15 = 117;
    int v16 = 295;
LABEL_15:
    ERR_put_error( 30,  0,  v15,  "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_aes.m",  v16);
    return 0LL;
  }

  if (v14 > a5)
  {
    int v15 = 103;
    int v16 = 299;
    goto LABEL_15;
  }

  if (!*(void *)(a1 + 8) || !*(void *)(a1 + 16))
  {
    int v15 = 112;
    int v16 = 303;
    goto LABEL_15;
  }

  int v18 = ccgcm_reset();
  if (ccgcm_set_iv() | v18)
  {
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        aead_aes_gcm_seal_scatter_cold_6();
      }
    }

    int v15 = 107;
    int v16 = 311;
    goto LABEL_15;
  }

  if (a13 && ccgcm_aad())
  {
    if (!g_boringssl_log) {
      return 0LL;
    }
    BOOL result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_5();
      return 0LL;
    }
  }

  else if (ccgcm_update())
  {
    if (!g_boringssl_log) {
      return 0LL;
    }
    BOOL result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_4();
      return 0LL;
    }
  }

  else if (a11 && ccgcm_update())
  {
    if (!g_boringssl_log) {
      return 0LL;
    }
    BOOL result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_3();
      return 0LL;
    }
  }

  else
  {
    if (ccgcm_finalize())
    {
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        aead_aes_gcm_seal_scatter_cold_2();
      }
      int v15 = 123;
      int v16 = 340;
      goto LABEL_15;
    }

    *a4 = *(unsigned __int8 *)(a1 + 576) + a11;
    if (!g_boringssl_log) {
      return 0LL;
    }
    BOOL result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      aead_aes_gcm_seal_scatter_cold_1();
      return 0LL;
    }
  }

  return result;
}

void aead_aes_gcm_cleanup(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 16))
  {
    cc_clear();
    unsigned int v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(void *)(a1 + 16) = 0LL;
    }
  }

uint64_t bssl::tls13_derive_resumption_secret(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  __int128 v3 = (bssl *)((char *)this + 424);
  if ((unint64_t)bssl::SSLTranscript::DigestLen((bssl *)((char *)this + 424)) < 0x31)
  {
    unsigned __int8 v5 = bssl::SSLTranscript::DigestLen(v3);
    uint64_t v6 = *((void *)this + 190);
    *(_BYTE *)(v6 + 10) = v5;
    return bssl::derive_secret_with_transcript((uint64_t)this, (int)v6 + 11, v5, v3, "res master", 0xAuLL);
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 309);
    return 0LL;
  }

void bssl::tls_on_handshake_complete(bssl *this, ssl_st *a2)
{
  uint64_t v2 = *((void *)this + 6);
  if ((*(_WORD *)(v2 + 220) & 0x10) != 0) {
    bssl::tls_on_handshake_complete();
  }
  unsigned __int8 v5 = *(void **)(v2 + 224);
  __int128 v3 = (BUF_MEM **)(v2 + 224);
  uint64_t v4 = v5;
  if (v5)
  {
    if (*v4) {
      bssl::tls_on_handshake_complete();
    }
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v3, 0LL);
  }

void bssl::SSL_SESSION_dup(bssl *this@<X0>, ssl_session_st *a2@<X1>, void *a3@<X8>)
{
  char v3 = (char)a2;
  uint64_t v39 = (void *)*((void *)this + 18);
  uint64_t v6 = bssl::New<ssl_session_st,bssl::SSL_X509_METHOD const*&>(&v39);
  uint64_t v7 = v6;
  if (!v6) {
    goto LABEL_23;
  }
  int v8 = v6[55] & 0xEF | (16 * ((*((unsigned __int8 *)this + 440) >> 4) & 1));
  *((_BYTE *)v6 + 440) = v8;
  *((_WORD *)v6 + 2) = *((_WORD *)this + 2);
  *((_BYTE *)v6 + 440) = *((_BYTE *)this + 440) & 0x20 | v8 & 0xDF;
  *((_BYTE *)v6 + 92) = *((_BYTE *)this + 92);
  if (*((_BYTE *)this + 92)) {
    memcpy((char *)v6 + 93, (char *)this + 93, *((unsigned __int8 *)this + 92));
  }
  *((_BYTE *)v7 + 10) = *((_BYTE *)this + 10);
  if (*((_BYTE *)this + 10)) {
    memcpy((char *)v7 + 11, (char *)this + 11, *((unsigned __int8 *)this + 10));
  }
  v7[25] = *((void *)this + 25);
  uint64_t v9 = (const char *)*((void *)this + 16);
  if (!v9
    || (int v10 = (char *)OPENSSL_strdup(v9),
        std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((void **)v7 + 16, v10),
        v7[16]))
  {
    uint64_t v11 = *((void *)this + 17);
    if (!v11
      || (uint64_t v12 = OPENSSL_sk_deep_copy( v11,  (uint64_t (*)(uint64_t))sk_CRYPTO_BUFFER_call_copy_func,  (uint64_t)bssl::SSL_SESSION_dup(ssl_session_st *,int)::$_0::__invoke,  (void (*)(uint64_t))sk_CRYPTO_BUFFER_call_free_func,  (uint64_t)CRYPTO_BUFFER_free),  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)v7 + 17,  v12),  v7[17]))
    {
      if ((*(unsigned int (**)(void *, bssl *))(*((void *)this + 18) + 56LL))(v7, this))
      {
        v7[22] = *((void *)this + 22);
        unint64_t v13 = (unsigned int *)*((void *)this + 32);
        if (v13) {
          CRYPTO_BUFFER_up_ref(*((void *)this + 32));
        }
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v7 + 32, v13);
        unint64_t v14 = (unsigned int *)*((void *)this + 31);
        if (v14) {
          CRYPTO_BUFFER_up_ref(*((void *)this + 31));
        }
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v7 + 31, v14);
        __int128 v15 = *((_OWORD *)this + 18);
        *((_OWORD *)v7 + 17) = *((_OWORD *)this + 17);
        *((_OWORD *)v7 + 1_Block_object_dispose(va, 8) = v15;
        *((_BYTE *)v7 + 440) = v7[55] & 0xFD | *((_BYTE *)this + 440) & 2;
        *((_WORD *)v7 + 4) = *((_WORD *)this + 4);
        v7[23] = *((void *)this + 23);
        v7[24] = *((void *)this + 24);
        if ((v3 & 2) == 0) {
          goto LABEL_21;
        }
        *((_BYTE *)v7 + 59) = *((_BYTE *)this + 59);
        if (*((_BYTE *)this + 59)) {
          memcpy((char *)v7 + 60, (char *)this + 60, *((unsigned __int8 *)this + 59));
        }
        *((_WORD *)v7 + 3) = *((_WORD *)this + 3);
        if (*((_BYTE *)this + 368))
        {
          memcpy(v7 + 38, (char *)this + 304, *((unsigned __int8 *)this + 368));
          char v21 = *((_BYTE *)this + 368);
        }

        else
        {
          char v21 = 0;
        }

        *((_BYTE *)v7 + 36_Block_object_dispose(va, 8) = v21;
        *((_DWORD *)v7 + 93) = *((_DWORD *)this + 93);
        v7[47] = *((void *)this + 47);
        char v22 = v7[55] & 0xFE | *((_BYTE *)this + 440) & 1;
        *((_BYTE *)v7 + 440) = v22;
        *((_BYTE *)v7 + 440) = v22 & 0xBF | *((_BYTE *)this + 440) & 0x40;
        uint64_t v23 = (const void *)*((void *)this + 49);
        unint64_t v24 = *((void *)this + 50);
        int v25 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 49), v24);
        char v26 = v25 ^ 1;
        if (!v24) {
          char v26 = 1;
        }
        if ((v26 & 1) == 0) {
          memmove((void *)v7[49], v23, v24);
        }
        if (v25)
        {
          unint64_t v27 = (const void *)*((void *)this + 56);
          unint64_t v28 = *((void *)this + 57);
          int v29 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 56), v28);
          char v30 = v29 ^ 1;
          if (!v28) {
            char v30 = 1;
          }
          if ((v30 & 1) == 0) {
            memmove((void *)v7[56], v27, v28);
          }
          if (v29)
          {
            unint64_t v31 = (const void *)*((void *)this + 51);
            unint64_t v32 = *((void *)this + 52);
            int v33 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 51), v32);
            char v34 = v33 ^ 1;
            if (!v32) {
              char v34 = 1;
            }
            if ((v34 & 1) == 0) {
              memmove((void *)v7[51], v31, v32);
            }
            if (v33)
            {
              int v35 = (const void *)*((void *)this + 53);
              unint64_t v36 = *((void *)this + 54);
              char v37 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 53), v36);
              char v38 = v37 ^ 1;
              if (!v36) {
                char v38 = 1;
              }
              if ((v38 & 1) == 0) {
                memmove((void *)v7[53], v35, v36);
              }
              if ((v37 & 1) != 0)
              {
LABEL_21:
                if ((v3 & 1) == 0) {
                  goto LABEL_22;
                }
                int v16 = (const void *)*((void *)this + 29);
                unint64_t v17 = *((void *)this + 30);
                int v18 = bssl::Array<unsigned char>::Init((uint64_t)(v7 + 29), v17);
                char v19 = v18 ^ 1;
                if (!v17) {
                  char v19 = 1;
                }
                if ((v19 & 1) == 0) {
                  memmove((void *)v7[29], v16, v17);
                }
                if (v18)
                {
LABEL_22:
                  char v20 = *((_BYTE *)v7 + 440) | 4;
                  *((_BYTE *)v7 + 440) = v20;
                  *((_BYTE *)v7 + 440) = *((_BYTE *)this + 440) & 0x80 | v20 & 0x7F;
LABEL_23:
                  *a3 = v7;
                  return;
                }
              }
            }
          }
        }
      }
    }
  }

  *a3 = 0LL;
  bssl::RefCounted<ssl_session_st>::DecRefInternal((ssl_session_st *)v7);
}

void sub_18758B0E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, SSL_SESSION *a9)
{
}

uint64_t sk_CRYPTO_BUFFER_call_copy_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t bssl::SSL_SESSION_dup(ssl_session_st *,int)::$_0::__invoke(uint64_t a1)
{
  return a1;
}

uint64_t CRYPTO_BUFFER_up_ref(uint64_t a1)
{
  return 1LL;
}

uint64_t bssl::ssl_noop_x509_session_dup(bssl *this, ssl_session_st *a2, const ssl_session_st *a3)
{
  return 1LL;
}

void SSL_SESSION_free(SSL_SESSION *ses)
{
  if (ses) {
    bssl::RefCounted<ssl_session_st>::DecRefInternal(ses);
  }
}

void ssl_session_st::~ssl_session_st(ssl_session_st *this)
{
}

void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  if (ad->sk)
  {
    uint64_t v3 = *(void *)&class_index;
    unint64_t v4 = atomic_load((unsigned int *)(*(void *)&class_index + 216LL));
    if ((_DWORD)v4)
    {
      int v7 = 0;
      int v8 = (void **)(*(void *)&class_index + 200LL);
      do
      {
        uint64_t v9 = *v8;
        if ((*v8)[2])
        {
          int v10 = *(unsigned __int8 *)(v3 + 220);
          uint64_t v11 = (v7 + v10);
          uint64_t v12 = CRYPTO_get_ex_data(ad, v7 + v10);
          ((void (*)(void *, void *, CRYPTO_EX_DATA *, uint64_t, void, void))(*v8)[2])( obj,  v12,  ad,  v11,  **v8,  (*v8)[1]);
          uint64_t v9 = *v8;
        }

        int v8 = (void **)(v9 + 3);
        ++v7;
      }

      while ((_DWORD)v4 != v7);
    }

    BUF_MEM_free((BUF_MEM *)ad->sk);
    ad->suint64_t k = 0LL;
  }

uint64_t bssl::Array<unsigned short>::~Array(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  return a1;
}

void bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke( uint64_t a1, unsigned int *a2)
{
}

void CRYPTO_BUFFER_free(unsigned int *a1)
{
  if (a1)
  {
    uint64_t v2 = *(void ***)a1;
    if (*(void *)a1)
    {
      CRYPTO_MUTEX_lock_write((pthread_rwlock_t *)(v2 + 1));
      if (CRYPTO_refcount_dec_and_test_zero(a1 + 6))
      {
        if ((unsigned int *)OPENSSL_lh_retrieve( *v2,  (uint64_t)a1,  (uint64_t (*)(void, uint64_t))lh_CRYPTO_BUFFER_call_hash_func,  (unsigned int (*)(void, void, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func) == a1 && (unsigned int *)OPENSSL_lh_delete( *v2,  (uint64_t)a1,  (uint64_t (*)(void, uint64_t))lh_CRYPTO_BUFFER_call_hash_func,  (unsigned int (*)(void, void, uint64_t))lh_CRYPTO_BUFFER_call_cmp_func) != a1)
        {
          CRYPTO_BUFFER_free_cold_1();
        }

        CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(*(void *)a1 + 8LL));
        goto LABEL_8;
      }

      CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)(*(void *)a1 + 8LL));
    }

    else if (CRYPTO_refcount_dec_and_test_zero(a1 + 6))
    {
LABEL_8:
      crypto_buffer_free_object((void **)a1);
    }
  }

void crypto_buffer_free_object(void **a1)
{
  if (!*((_DWORD *)a1 + 7)) {
    OPENSSL_free(a1[1]);
  }
  OPENSSL_free(a1);
}

void bssl::ssl_update_cache(bssl *this, ssl_st *a2)
{
  uint64_t v3 = *((void *)this + 16);
  uint64_t v4 = *(void *)(*((void *)this + 6) + 472LL);
  int is_server = SSL_is_server((uint64_t)this);
  if ((*(_BYTE *)(v4 + 440) & 4) == 0 && (*(_BYTE *)(v4 + 59) || *(void *)(v4 + 240)))
  {
    int v6 = is_server ? 2 : 1;
    int v7 = *(_DWORD *)(v3 + 300);
    if ((v7 & v6) != 0)
    {
      if ((v7 & 0x200) == 0 && (*((_BYTE *)this + 180) & 1) != 0)
      {
        CRYPTO_refcount_inc((unsigned int *)v4);
        uint64_t v13 = v4;
        tm[0] = 0xAAAAAAAAAAAAAAAALL;
        bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_write),&(CRYPTO_MUTEX_unlock_write)>::MutexLockBase( (pthread_rwlock_t **)tm,  (pthread_rwlock_t *)(v3 + 24));
        uint64_t v12 = (SSL_SESSION *)v4;
        uint64_t v13 = 0LL;
        bssl::add_session_locked(v3, &v12);
        int v8 = v12;
        uint64_t v12 = 0LL;
        if (v8) {
          bssl::RefCounted<ssl_session_st>::DecRefInternal(v8);
        }
        if ((*(_BYTE *)(v3 + 300) & 0x80) != 0)
        {
          CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)tm[0]);
        }

        else
        {
          int v9 = *(_DWORD *)(v3 + 296);
          if (v9 <= 253) {
            int v10 = v9 + 1;
          }
          else {
            int v10 = 0;
          }
          *(_DWORD *)(v3 + 2bssl::Array<unsigned short>::~Array(v1 - 96) = v10;
          CRYPTO_MUTEX_unlock_read((pthread_rwlock_t *)tm[0]);
          if (v9 > 253)
          {
            tm[0] = 0xAAAAAAAAAAAAAAAALL;
            tm[1] = 0xAAAAAAAAAAAAAAAALL;
            bssl::ssl_get_current_time((uint64_t)this, (uint64_t)tm);
            SSL_CTX_flush_sessions((SSL_CTX *)v3, tm[0]);
          }
        }
      }

      if (*(void *)(v3 + 312))
      {
        CRYPTO_refcount_inc((unsigned int *)v4);
        tm[0] = v4;
        if (!(*(unsigned int (**)(bssl *, uint64_t))(v3 + 312))(this, v4))
        {
          tm[0] = 0LL;
          bssl::RefCounted<ssl_session_st>::DecRefInternal((ssl_session_st *)v4);
        }
      }
    }
  }

void sub_18758B564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t SSL_is_server(uint64_t a1)
{
  return *(_BYTE *)(a1 + 180) & 1;
}

SSL *boringssl_session_finish_handshake(SSL *result)
{
  if (result)
  {
    unsigned int v1 = result;
    if (result->version == -1252936367)
    {
      methounsigned int d = result->method;
      if (method)
      {
        session = SSL_get_session((const SSL *)method[1].num_ciphers);
        boringssl_session_set_peer_verification_state_from_session((uint64_t)v1, (uint64_t)session);
        if ((BYTE4(method[2].ssl_renegotiate_check) & 0x10) != 0)
        {
          id WeakRetained = objc_loadWeakRetained((id *)&method->ssl_clear);
          if (WeakRetained)
          {
            unsigned __int8 v5 = WeakRetained;
            int v6 = objc_loadWeakRetained((id *)&method->ssl_clear);
            uint64_t v7 = v6[40];

            if (v7)
            {
              int v8 = objc_loadWeakRetained((id *)&method->ssl_clear);
              uint64_t v9 = v8[40];

              if (v9)
              {
                id v10 = objc_loadWeakRetained((id *)&method->ssl_clear);
                nw_queue_cancel_source();

                uint64_t v11 = objc_loadWeakRetained((id *)&method->ssl_clear);
                v11[40] = 0LL;
              }
            }
          }
        }

        if (v1->version == -1252936367)
        {
          uint64_t v12 = v1->method;
          if (v12)
          {
            HIDWORD(v12[1].ssl_write) = 2;
            if (v1->version == -1252936367)
            {
              uint64_t v13 = v1->method;
              if (v13) {
                v13[1].ssl3_enc = (ssl3_enc_method *)boringssl_helper_get_current_time_ms();
              }
            }
          }
        }

        boringssl_session_update_metadata((uint64_t)v1);
        boringssl_context_update_encryption_level((uint64_t)v1);
        boringssl_metrics_log_connection(v1);
        return (SSL *)boringssl_metrics_log_ech((uint64_t)v1);
      }
    }
  }

  return result;
}

BOOL boringssl_metrics_log_connection(SSL *a1)
{
  if (!a1 || a1->version != -1252936367 || !a1->method) {
    return 0LL;
  }
  if (metricsQueueToken != -1)
  {
    unsigned __int8 v5 = a1;
    dispatch_once(&metricsQueueToken, &__block_literal_global_3);
    a1 = v5;
  }

  if (!boringssl_context_metrics_queue) {
    return 0LL;
  }
  xpc_object_t connection_event = boringssl_metrics_create_connection_event(a1);
  if (!connection_event) {
    return 0LL;
  }
  uint64_t v2 = connection_event;
  BOOL v3 = boringssl_metrics_log_event( (uint64_t)"TLSConnectionEvent",  connection_event,  (void *)boringssl_context_metrics_queue);

  return v3;
}

xpc_object_t boringssl_metrics_create_connection_event(SSL *a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  if (a1->version != -1252936367) {
    return 0LL;
  }
  methounsigned int d = a1->method;
  if (!method) {
    return 0LL;
  }
  xpc_object_t v3 = xpc_dictionary_create(0LL, 0LL, 0LL);
  if (v3)
  {
    uint64_t v4 = (char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
    if (boringssl_session_get_peer_public_key((uint64_t)a1))
    {
      unint64_t v5 = SecKeyGetAlgorithmId() - 1;
      if (v5 <= 2) {
        uint64_t v4 = off_18A071DF8[v5];
      }
    }

    uint64_t negotiated_group = boringssl_session_get_negotiated_group((uint64_t)a1);
    uint64_t v42 = 0LL;
    uint64_t negotiated_protocol = boringssl_session_get_negotiated_protocol((uint64_t)a1, &v42);
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    *(_OWORD *)string = 0u;
    __int128 v44 = 0u;
    if (!negotiated_protocol) {
      strlen((const char *)TLS_METRIC_DEFAULT_EMPTY_STRING);
    }
    __memcpy_chk();
    signed int v9 = boringssl_session_ticket_lifetime_hint(a1);
    uint64_t v10 = 0LL;
    while (1)
    {
      int v11 = *(_DWORD *)&lifetime_buckets[v10];
      if (v11 <= v9 && *(_DWORD *)&lifetime_buckets[v10 + 4] > v9) {
        break;
      }
      v10 += 4LL;
      if (v10 == 20)
      {
        int v11 = 108000;
        break;
      }
    }

    boringssl_metrics_log_configuration_data((uint64_t)a1, v3);
    boringssl_metrics_log_connection_data((uint64_t)a1, v3);
    uint64_t v12 = (const char *)TLS_METRIC_CIPHERSUITE;
    unsigned int negotiated_ciphersuite = boringssl_session_get_negotiated_ciphersuite((uint64_t)a1);
    xpc_dictionary_set_uint64(v3, v12, negotiated_ciphersuite);
    unsigned int negotiated_protocol_version = boringssl_session_get_negotiated_protocol_version(a1);
    xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_PROTOCOL_VERSION, negotiated_protocol_version);
    xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_TICKET_LIFETIME, v11);
    __int128 v15 = (const char *)TLS_METRIC_HANDSHAKE_TIME;
    handshake_time_munsigned int s = boringssl_session_get_handshake_time_ms((uint64_t)a1);
    xpc_dictionary_set_uint64(v3, v15, handshake_time_ms);
    unint64_t v17 = (const char *)TLS_METRIC_SIGNATURE_ALGORITHM;
    unsigned int peer_signature_algorithm = boringssl_session_get_peer_signature_algorithm((uint64_t)a1);
    xpc_dictionary_set_uint64(v3, v17, peer_signature_algorithm);
    if (negotiated_group)
    {
      char v19 = v3;
      char v20 = (const char *)negotiated_group;
    }

    else
    {
      char v20 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      char v19 = v3;
    }

    xpc_dictionary_set_string(v19, (const char *)TLS_METRIC_GROUP_NAME, v20);
    int has_internal_content = os_variant_has_internal_content();
    if (negotiated_protocol_version - 769 <= 1 && has_internal_content)
    {
      server_name = boringssl_session_get_server_name(a1);
      if (server_name) {
        uint64_t v23 = (const char *)server_name;
      }
      else {
        uint64_t v23 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      }
      xpc_dictionary_set_string(v3, (const char *)TLS_METRIC_SERVER_NAME, v23);
    }

    if (v4)
    {
      unint64_t v24 = v3;
      int v25 = v4;
    }

    else
    {
      int v25 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      unint64_t v24 = v3;
    }

    xpc_dictionary_set_string(v24, (const char *)TLS_METRIC_PEER_PUBLIC_KEY_TYPE, v25);
    xpc_dictionary_set_string(v3, (const char *)TLS_METRIC_NEGOTIATED_PROTOCOL, string);
    char v26 = (const char *)TLS_METRIC_UNKNOWN_NEGOTIATED_PROTOCOL;
    BOOL is_unknown = boringssl_context_negotiated_protocol_is_unknown((uint64_t)a1, string);
    xpc_dictionary_set_BOOL(v3, v26, is_unknown);
    xpc_dictionary_set_BOOL(v3, (const char *)TLS_METRIC_FALSE_START_USED, BYTE5(method[2].ssl_renegotiate_check) & 1);
    unint64_t v28 = (const char *)TLS_METRIC_TICKET_RECEIVED;
    unsigned __int8 v29 = boringssl_session_has_session_ticket(a1, 0LL);
    xpc_dictionary_set_BOOL(v3, v28, v29);
    char v30 = (const char *)TLS_METRIC_SESSION_RENEWED;
    unsigned __int8 v31 = boringssl_session_was_renewed(a1, 0LL);
    xpc_dictionary_set_BOOL(v3, v30, v31);
    unint64_t v32 = (const char *)TLS_METRIC_ALPN_USED;
    BOOL v33 = boringssl_session_get_negotiated_protocol((uint64_t)a1, 0LL) != 0;
    xpc_dictionary_set_BOOL(v3, v32, v33);
    char v34 = (const char *)TLS_METRIC_OCSP_RECEIVED;
    ocsp_response_receiveunsigned int d = boringssl_session_get_ocsp_response_received((uint64_t)a1);
    xpc_dictionary_set_BOOL(v3, v34, ocsp_response_received);
    unint64_t v36 = (const char *)TLS_METRIC_SCT_RECEIVED;
    sct_receiveunsigned int d = boringssl_session_get_sct_received((uint64_t)a1);
    xpc_dictionary_set_BOOL(v3, v36, sct_received);
    xpc_dictionary_set_BOOL( v3,  (const char *)TLS_METRIC_FALLBACK_ATTEMPTED,  (BYTE4(method[2].ssl_renegotiate_check) & 0x40) != 0);
    xpc_dictionary_set_BOOL( v3,  (const char *)TLS_METRIC_HANDSHAKE_CANCELLED,  (BYTE4(method[2].ssl_renegotiate_check) & 2) != 0);
    xpc_dictionary_set_BOOL( v3,  (const char *)TLS_METRIC_CERTIFICATE_REQUESTED,  (BYTE6(method[2].ssl_renegotiate_check) & 0x10) != 0);
    xpc_dictionary_set_BOOL( v3,  (const char *)TLS_METRIC_CERTIFICATE_COMPRESSION_ENABLED,  (HIBYTE(method[2].ssl_renegotiate_check) & 0x20) != 0);
    xpc_dictionary_set_BOOL( v3,  (const char *)TLS_METRIC_CERTIFICATE_COMPRESSION_USED,  (HIBYTE(method[2].ssl_renegotiate_check) & 0x40) != 0);
    xpc_dictionary_set_uint64( v3,  (const char *)TLS_METRIC_CERTIFICATE_COMPRESSION_ALGORITHM,  LOWORD(method[1].ssl_read_bytes));
    char v38 = (const char *)TLS_METRIC_EXTENDED_MASTER_SECRET_NEGOTIATED;
    ems_useunsigned int d = boringssl_session_get_ems_used((bssl *)a1, v39);
    xpc_dictionary_set_uint64(v3, v38, ems_used);
    xpc_dictionary_set_uuid( v3,  (const char *)TLS_METRIC_CONNECTION_ID,  (const unsigned __int8 *)&method[1].ssl_clear + 4);
    id v41 = v3;
  }

  else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    boringssl_metrics_create_connection_event_cold_1();
  }

  return v3;
}

uint64_t boringssl_session_get_peer_public_key(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 344);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

const SSL *boringssl_session_ticket_lifetime_hint(const SSL *result)
{
  if (result)
  {
    if (result->version == -1252936367 && (methounsigned int d = result->method) != 0LL)
    {
      BOOL result = (const SSL *)method[1].num_ciphers;
      if (result)
      {
        BOOL result = (const SSL *)SSL_get_session(result);
        if (result) {
          return (const SSL *)SSL_SESSION_get_ticket_lifetime_hint((uint64_t)result);
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_SESSION_get_ticket_lifetime_hint(uint64_t a1)
{
  return *(unsigned int *)(a1 + 372);
}

void boringssl_metrics_log_configuration_data(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(_DWORD *)a1 == -1252936367)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      unint64_t v5 = (const char *)TLS_METRIC_MIN_PROTOCOL_VERSION;
      xpc_object_t xdict = v3;
      unsigned int min_protocol_version = boringssl_context_get_min_protocol_version(a1);
      xpc_dictionary_set_uint64(xdict, v5, min_protocol_version);
      uint64_t v7 = (const char *)TLS_METRIC_MAX_PROTOCOL_VERSION;
      unsigned int max_protocol_version = boringssl_context_get_max_protocol_version(a1);
      xpc_dictionary_set_uint64(xdict, v7, max_protocol_version);
      signed int v9 = (const char *)TLS_METRIC_CONFIGURED_CIPHERSUITE_SET;
      uint64_t configured_ciphersuite_set = boringssl_context_get_configured_ciphersuite_set(a1);
      xpc_dictionary_set_uint64(xdict, v9, configured_ciphersuite_set);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_FALSE_START_ENABLED, *(_BYTE *)(v4 + 556) >> 7);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_SESSION_RESUMED, *(_BYTE *)(v4 + 557) >> 7);
      int v11 = (const char *)TLS_METRIC_TICKET_ENABLED;
      session_ticket_enableunsigned int d = boringssl_context_get_session_ticket_enabled(a1);
      xpc_dictionary_set_BOOL(xdict, v11, session_ticket_enabled);
      uint64_t v13 = (const char *)TLS_METRIC_TICKET_OFFERED;
      ticket_offereunsigned int d = boringssl_session_get_ticket_offered(a1);
      xpc_dictionary_set_BOOL(xdict, v13, ticket_offered);
      __int128 v15 = (const char *)TLS_METRIC_RESUMPTION_ATTEMPTED;
      char v16 = boringssl_session_attempted_resumption(a1);
      xpc_dictionary_set_BOOL(xdict, v15, v16);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_OCSP_ENABLED, (*(_BYTE *)(v4 + 556) & 8) != 0);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_SCT_ENABLED, (*(_BYTE *)(v4 + 556) & 4) != 0);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_VERIFY_BLOCK_USED, *(void *)(v4 + 120) != 0LL);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_CHALLENGE_BLOCK_USED, *(void *)(v4 + 136) != 0LL);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_DTLS, (*(_BYTE *)(v4 + 556) & 0x20) != 0);
      unint64_t v17 = (const char *)TLS_METRIC_PSK_USED;
      psk_was_negotiateunsigned int d = boringssl_session_get_psk_was_negotiated(a1);
      xpc_dictionary_set_BOOL(xdict, v17, psk_was_negotiated);
      char v19 = (const char *)TLS_METRIC_PSK_CONFIGURED;
      BOOL v20 = boringssl_psk_cache_get_count(*(void *)(v4 + 40)) != 0;
      xpc_dictionary_set_BOOL(xdict, v19, v20);
      xpc_dictionary_set_BOOL(xdict, (const char *)TLS_METRIC_CLIENT_MODE, (*(_BYTE *)(v4 + 556) & 0x10) == 0);
      char v21 = (const char *)TLS_METRIC_IS_PROBE;
      char is_probe = boringssl_context_get_is_probe(a1);
      xpc_dictionary_set_BOOL(xdict, v21, is_probe);
      uint64_t v23 = (const char *)TLS_METRIC_GREASE_ENABLED;
      GREASE_enableunsigned int d = boringssl_context_get_GREASE_enabled(a1);
      xpc_dictionary_set_BOOL(xdict, v23, GREASE_enabled);
      int v25 = (const char *)TLS_METRIC_ATS_ENFORCED;
      ats_enforceunsigned int d = boringssl_context_get_ats_enforced(a1);
      xpc_dictionary_set_BOOL(xdict, v25, ats_enforced);
      unint64_t v27 = (const char *)TLS_METRIC_ATS_MINIMUM_RSA_KEY_SIZE;
      ats_minimum_rsa_key_size_t size = boringssl_context_get_ats_minimum_rsa_key_size(a1);
      xpc_dictionary_set_uint64(xdict, v27, ats_minimum_rsa_key_size);
      unsigned __int8 v29 = (const char *)TLS_METRIC_ATS_MINIMUM_ECDSA_KEY_SIZE;
      ats_minimum_ecdsa_key_size_t size = boringssl_context_get_ats_minimum_ecdsa_key_size(a1);
      xpc_dictionary_set_uint64(xdict, v29, ats_minimum_ecdsa_key_size);
      unsigned __int8 v31 = (const char *)TLS_METRIC_ATS_MINIMUM_SIGNATURE_ALGORITHM;
      unsigned int ats_minimum_signature_algorithm = boringssl_context_get_ats_minimum_signature_algorithm(a1);
      xpc_dictionary_set_uint64(xdict, v31, ats_minimum_signature_algorithm);
      uint64_t experiment_identifer = boringssl_context_get_experiment_identifer(a1);
      char v34 = (const char *)TLS_METRIC_EXPERIMENT_IDENTIFIER;
      if (experiment_identifer) {
        int v35 = (const char *)boringssl_context_get_experiment_identifer(a1);
      }
      else {
        int v35 = (const char *)TLS_METRIC_DEFAULT_EMPTY_STRING;
      }
      xpc_dictionary_set_string(xdict, v34, v35);
      id v3 = xdict;
    }
  }
}

uint64_t boringssl_context_get_min_protocol_version(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(unsigned __int16 *)(v1 + 58);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_max_protocol_version(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(unsigned __int16 *)(v1 + 56);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_configured_ciphersuite_set(uint64_t a1)
{
  if (a1
    && *(_DWORD *)a1 == -1252936367
    && (uint64_t v1 = *(void *)(a1 + 8)) != 0
    && (uint64_t v2 = *(const SSL **)(v1 + 400)) != 0LL
    && (cipherunsigned int s = (EVP_MD_CTX *)SSL_get_ciphers(v2)) != 0LL)
  {
    return boringssl_ciphers_create_set_bitmask(ciphers);
  }

  else
  {
    return 0LL;
  }

uint64_t boringssl_ciphers_create_set_bitmask(EVP_MD_CTX *a1)
{
  if (!EVP_MD_CTX_md(a1)) {
    return 0LL;
  }
  unint64_t v2 = 0LL;
  uint64_t v3 = 0LL;
  do
  {
    uint64_t v4 = OPENSSL_sk_value((unint64_t *)a1, v2);
    if (v4)
    {
      iunsigned int d = SSL_CIPHER_get_id((uint64_t)v4);
      uint64_t v6 = 0LL;
      while (supported_bitmasks[v6] != id)
      {
        v6 += 8LL;
        if (v6 == 304) {
          goto LABEL_9;
        }
      }

      v3 |= *(void *)&supported_bitmasks[v6 + 4];
    }

uint64_t boringssl_context_get_session_ticket_enabled(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (uint64_t v1 = *(void *)(a1 + 8)) != 0) {
    return (*(unsigned __int8 *)(v1 + 557) >> 4) & 1;
  }
  else {
    return 1LL;
  }
}

BOOL boringssl_session_get_ticket_offered(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0 && *(char *)(v1 + 558) < 0;
  }
  return result;
}

uint64_t boringssl_session_attempted_resumption(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return (*(unsigned __int8 *)(v1 + 558) >> 6) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

BOOL boringssl_session_get_psk_was_negotiated(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0 && *(char *)(v1 + 559) < 0;
  }
  return result;
}

uint64_t boringssl_psk_cache_get_count(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 8)) {
    return sec_array_get_count();
  }
  else {
    return 0LL;
  }
}

uint64_t boringssl_context_get_GREASE_enabled(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(_BYTE *)(v1 + 560) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_ats_enforced(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return (*(unsigned __int8 *)(v1 + 559) >> 3) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_ats_minimum_rsa_key_size(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 528);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_ats_minimum_ecdsa_key_size(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 536);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_ats_minimum_signature_algorithm(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(unsigned int *)(v1 + 544);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_context_get_experiment_identifer(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 96);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void boringssl_metrics_log_connection_data(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(_DWORD *)a1 == -1252936367)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      xpc_object_t xdict = v3;
      xpc_dictionary_set_uint64(v3, (const char *)TLS_METRIC_HANDSHAKE_TIMER_FIRES, *(void *)(v4 + 328));
      unint64_t v5 = (const char *)TLS_METRIC_HANDSHAKE_RTT;
      handshake_rtt_munsigned int s = boringssl_session_get_handshake_rtt_ms(a1);
      xpc_dictionary_set_uint64(xdict, v5, handshake_rtt_ms);
      uint64_t v7 = (const char *)TLS_METRIC_HANDSHAKE_INBOUND_BYTE_COUNT;
      handshake_inbound_byte_size_t count = boringssl_session_get_handshake_inbound_byte_count(a1);
      xpc_dictionary_set_uint64(xdict, v7, handshake_inbound_byte_count);
      signed int v9 = (const char *)TLS_METRIC_HANDSHAKE_OUTBOUND_BYTE_COUNT;
      handshake_outbound_byte_size_t count = boringssl_session_get_handshake_outbound_byte_count(a1);
      xpc_dictionary_set_uint64(xdict, v9, handshake_outbound_byte_count);
      int v11 = (const char *)TLS_METRIC_HANDSHAKE_BYTE_COUNT;
      handshake_byte_size_t count = boringssl_session_get_handshake_byte_count(a1);
      xpc_dictionary_set_uint64(xdict, v11, handshake_byte_count);
      uint64_t v13 = (const char *)TLS_METRIC_HANDSHAKE_READ_STALLS;
      stall_size_t count = boringssl_session_get_handshake_read_stall_count(a1);
      xpc_dictionary_set_uint64(xdict, v13, stall_count);
      __int128 v15 = (const char *)TLS_METRIC_HANDSHAKE_WRITE_STALLS;
      uint64_t v16 = boringssl_session_get_handshake_write_stall_count(a1);
      xpc_dictionary_set_uint64(xdict, v15, v16);
      unint64_t v17 = (const char *)TLS_METRIC_HANDSHAKE_ASYNC_CALLS;
      handshake_async_size_t count = boringssl_session_get_handshake_async_count(a1);
      xpc_dictionary_set_uint64(xdict, v17, handshake_async_count);
      char v19 = (const char *)TLS_METRIC_ADDRESS_FAMILY;
      unsigned int address_family = boringssl_session_get_address_family(a1);
      xpc_dictionary_set_uint64(xdict, v19, address_family);
      id v3 = xdict;
    }
  }
}

uint64_t boringssl_session_get_handshake_rtt_ms(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      unint64_t v2 = *(void *)(v1 + 464);
      unint64_t v3 = *(void *)(v1 + 456);
      BOOL v4 = v2 >= v3;
      unint64_t v5 = v2 - v3;
      if (v4) {
        return v5;
      }
      else {
        return -1LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_inbound_byte_count(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 480);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_outbound_byte_count(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 472);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_byte_count(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 472) + *(void *)(v1 + 480);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_read_stall_count(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 496);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_write_stall_count(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 488);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_async_count(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 504);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_address_family(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(unsigned __int8 *)(v1 + 225);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_time_ms(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 432) - *(void *)(v1 + 424);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

SSL_SESSION *boringssl_session_get_peer_signature_algorithm(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(void *)(a1 + 8)) != 0 && (unint64_t v2 = *(const SSL **)(v1 + 400)) != 0LL) {
    return SSL_get_peer_signature_algorithm(v2);
  }
  else {
    return 0LL;
  }
}

SSL_SESSION *SSL_get_peer_signature_algorithm(const SSL *a1)
{
  BOOL result = SSL_get_session(a1);
  if (result) {
    return (SSL_SESSION *)*(unsigned __int16 *)result->key_arg;
  }
  return result;
}

BOOL boringssl_context_negotiated_protocol_is_unknown(uint64_t a1, char *__s)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (uint64_t v2 = *(void *)(a1 + 8)) != 0 && (*(_BYTE *)(v2 + 557) & 0x40) != 0)
  {
    if (__s)
    {
      size_t v6 = strlen(__s);
      id v7 = *(id *)(v2 + 64);
      size_t count = xpc_array_get_count(v7);
      if (count)
      {
        size_t v9 = count;
        BOOL v3 = 0;
        for (i = 0LL; i != v9; BOOL v3 = i >= v9)
        {
          string = xpc_array_get_string(v7, i);
          if (v6 == strlen(string) && !strncmp(__s, string, v6)) {
            break;
          }
          ++i;
        }
      }

      else
      {
        BOOL v3 = 1;
      }
    }

    else
    {
      return 1;
    }
  }

  else
  {
    return 0;
  }

  return v3;
}

uint64_t boringssl_session_get_ocsp_response_received(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      BOOL result = *(void *)(v1 + 400);
      if (result)
      {
        uint64_t v2 = 0LL;
        uint64_t v3 = 0LL;
        SSL_get0_ocsp_response(result, &v3, &v2);
        return v2 != 0;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_sct_received(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      BOOL result = *(void *)(v1 + 400);
      if (result)
      {
        uint64_t v2 = 0LL;
        uint64_t v3 = 0LL;
        SSL_get0_signed_cert_timestamp_list(result, &v3, &v2);
        return v2 != 0;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

bssl *boringssl_session_get_ems_used(bssl *result, const ssl_st *a2)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v2 = *((void *)result + 1)) != 0)
    {
      BOOL result = *(bssl **)(v2 + 400);
      if (result) {
        return (bssl *)(SSL_get_extms_support(result, a2) != 0);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t SSL_get_extms_support(bssl *a1, const ssl_st *a2)
{
  if ((*(_WORD *)(*((void *)a1 + 6) + 220LL) & 2) == 0) {
    return 0LL;
  }
  uint64_t v4 = *((void *)a1 + 6);
  uint64_t v5 = *(void *)(v4 + 472);
  if (v5) {
    return *(_BYTE *)(v5 + 440) & 1;
  }
  uint64_t v6 = *(void *)(v4 + 280);
  if (!v6) {
    SSL_get_extms_support_cold_1();
  }
  return HIWORD(*(_DWORD *)(v6 + 1584)) & 1;
}

BOOL boringssl_metrics_log_event(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = a3;
  if (a1)
  {
    xpc_object_t v6 = xpc_copy(a2);
    BOOL v7 = v6 != 0LL;
    if (v6)
    {
      int v8 = (const char *)TLS_METRIC_PROCESS_IDENTIFIER;
      whitelisted_bundle_identifier = (const char *)boringssl_config_get_whitelisted_bundle_identifier();
      xpc_dictionary_set_string(v6, v8, whitelisted_bundle_identifier);
      id v10 = v6;
      v12[0] = MEMORY[0x1895F87A8];
      v12[1] = 3221225472LL;
      __int128 v12[2] = __boringssl_metrics_log_metric_block_invoke;
      _OWORD v12[3] = &unk_18A0703D8;
      id v13 = v10;
      uint64_t v14 = a1;
      dispatch_async(v5, v12);
    }

    else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      boringssl_metrics_log_event_cold_1();
    }
  }

  else
  {
    BOOL v7 = 0LL;
  }

  return v7;
}

uint64_t boringssl_config_get_whitelisted_bundle_identifier()
{
  if (boringssl_config_get_whitelisted_bundle_identifier_onceToken != -1) {
    dispatch_once(&boringssl_config_get_whitelisted_bundle_identifier_onceToken, &__block_literal_global_2);
  }
  return global_bundle_identifier;
}

BOOL boringssl_metrics_log_ech(uint64_t a1)
{
  if (!a1 || *(_DWORD *)a1 != -1252936367 || !*(void *)(a1 + 8)) {
    return 0LL;
  }
  if (metricsQueueToken != -1)
  {
    uint64_t v5 = a1;
    dispatch_once(&metricsQueueToken, &__block_literal_global_78);
    a1 = v5;
  }

  if (!boringssl_context_metrics_queue) {
    return 0LL;
  }
  xpc_object_t ech_event = boringssl_metrics_create_ech_event(a1);
  if (!ech_event) {
    return 0LL;
  }
  uint64_t v2 = ech_event;
  BOOL v3 = boringssl_metrics_log_event( (uint64_t)"TLSExperimentECHConnectionEvent",  ech_event,  (void *)boringssl_context_metrics_queue);

  return v3;
}

xpc_object_t boringssl_metrics_create_ech_event(uint64_t a1)
{
  if (!a1
    || *(_DWORD *)a1 != -1252936367
    || !*(void *)(a1 + 8)
    || !boringssl_context_get_ech_enabled(a1))
  {
    return 0LL;
  }

  xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
  if (v2)
  {
    BOOL v3 = (const char *)TLS_METRIC_ECH_USED;
    ech_was_useunsigned int d = boringssl_session_get_ech_was_used(a1);
    xpc_dictionary_set_BOOL(v2, v3, ech_was_used);
    id v5 = v2;
  }

  else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    boringssl_metrics_create_ech_event_cold_1();
  }

  return v2;
}

void nw_protocol_boringssl_signal_connected(void *a1)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if ((v1[475] & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_signal_connected_cold_1();
  }

  uint64_t v2 = *((void *)v1 + 42);
  if (v2)
  {
    if (*((void *)v1 + 40))
    {
      nw_queue_cancel_source();
      *((void *)v1 + 40) = 0LL;
      uint64_t v2 = *((void *)v1 + 42);
    }

    uint64_t v26 = 0LL;
    uint64_t negotiated_protocol = boringssl_session_get_negotiated_protocol(v2, &v26);
    memset(v65, 0, 128);
    if (negotiated_protocol) {
      __memcpy_chk();
    }
    negotiated_ciphersuite_name = (const char *)boringssl_session_get_negotiated_ciphersuite_name(*((void *)v1 + 42));
    if ((v1[475] & 1) == 0)
    {
      id v5 = (void *)g_boringssl_log;
      if (g_boringssl_log)
      {
        xpc_object_t v6 = negotiated_ciphersuite_name;
        if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v7 = (const SSL *)*((void *)v1 + 42);
          log = v5;
          unsigned int negotiated_protocol_version = boringssl_session_get_negotiated_protocol_version(v7);
          if (v6) {
            int v8 = v6;
          }
          else {
            int v8 = "nil";
          }
          uint64_t v23 = v8;
          negotiated_group_iunsigned int d = boringssl_session_get_negotiated_group_id(*((void *)v1 + 42));
          unsigned int peer_signature_algorithm = boringssl_session_get_peer_signature_algorithm(*((void *)v1 + 42));
          size_t v9 = v65;
          if (!negotiated_protocol) {
            size_t v9 = "nil";
          }
          BOOL v20 = v9;
          int v19 = boringssl_session_was_resumed(*((void *)v1 + 42));
          ticket_offereunsigned int d = boringssl_session_get_ticket_offered(*((void *)v1 + 42));
          false_start_useunsigned int d = boringssl_session_get_false_start_used(*((void *)v1 + 42));
          ocsp_response_receiveunsigned int d = boringssl_session_get_ocsp_response_received(*((void *)v1 + 42));
          sct_receiveunsigned int d = boringssl_session_get_sct_received(*((void *)v1 + 42));
          handshake_time_munsigned int s = boringssl_session_get_handshake_time_ms(*((void *)v1 + 42));
          handshake_flight_time_munsigned int s = boringssl_session_get_handshake_flight_time_ms(*((void *)v1 + 42));
          handshake_rtt_munsigned int s = boringssl_session_get_handshake_rtt_ms(*((void *)v1 + 42));
          uint64_t v17 = boringssl_session_get_handshake_write_stall_count(*((void *)v1 + 42));
          stall_size_t count = boringssl_session_get_handshake_read_stall_count(*((void *)v1 + 42));
          *(_DWORD *)buf = 136450818;
          unint64_t v28 = "nw_protocol_boringssl_signal_connected";
          __int16 v29 = 1024;
          int v30 = 747;
          __int16 v31 = 2082;
          unint64_t v32 = v1 + 391;
          __int16 v33 = 2048;
          char v34 = v1;
          __int16 v35 = 1024;
          unsigned int v36 = negotiated_protocol_version;
          __int16 v37 = 2080;
          char v38 = v23;
          __int16 v39 = 1024;
          unsigned int v40 = negotiated_group_id;
          __int16 v41 = 1024;
          unsigned int v42 = peer_signature_algorithm;
          __int16 v43 = 2082;
          __int128 v44 = v20;
          __int16 v45 = 1024;
          int v46 = v19;
          __int16 v47 = 1024;
          BOOL v48 = ticket_offered;
          __int16 v49 = 1024;
          int v50 = false_start_used;
          __int16 v51 = 1024;
          int v52 = ocsp_response_received;
          __int16 v53 = 1024;
          int v54 = sct_received;
          __int16 v55 = 2048;
          uint64_t v56 = handshake_time_ms;
          __int16 v57 = 2048;
          uint64_t v58 = handshake_flight_time_ms;
          __int16 v59 = 2048;
          uint64_t v60 = handshake_rtt_ms;
          __int16 v61 = 2048;
          uint64_t v62 = v17;
          __int16 v63 = 2048;
          uint64_t v64 = stall_count;
          _os_log_impl( &dword_187560000,  log,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] TLS connected [version(0x%04x) ciphersuite(%s) group(0x%04x) signature_alg(0x% 04x) alpn(%{public}s) resumed(%d) offered_ticket(%d) false_started(%d) ocsp_received(%d) sct_received(%d) co nnect_time(%llums) flight_time(%llums) rtt(%llums) write_stalls(%zu) read_stalls(%zu)]",  buf,  0x9Cu);
        }
      }
    }

    (*(void (**)(void))(*(void *)(*((void *)v1 + 7) + 24LL) + 40LL))();
    v1[390] |= 2u;
  }
}

void *boringssl_session_get_negotiated_ciphersuite_name(uint64_t a1)
{
  int negotiated_ciphersuite = boringssl_session_get_negotiated_ciphersuite(a1);
  BOOL result = SSL_get_cipher_by_value(negotiated_ciphersuite);
  if (result) {
    return (void *)EVP_HPKE_CTX_aead((uint64_t)result);
  }
  return result;
}

uint64_t EVP_HPKE_CTX_aead(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

SSL_SESSION *boringssl_session_get_negotiated_group_id(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (v1 = *(void *)(a1 + 8)) != 0 && (uint64_t v2 = *(const SSL **)(v1 + 400)) != 0LL) {
    return SSL_get_curve_id(v2);
  }
  else {
    return 0LL;
  }
}

uint64_t boringssl_session_get_false_start_used(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(_BYTE *)(v1 + 557) & 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_handshake_flight_time_ms(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(void *)(v1 + 448);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t nw_protocol_boringssl_waiting_for_output(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 40);
    if (v1)
    {
      if ((*(_BYTE *)(v1 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_waiting_for_output_cold_2();
      }

      BOOL result = boringssl_session_in_early_data(*(void *)(v1 + 336));
      if ((_DWORD)result) {
        BOOL result = boringssl_session_get_state(*(void *)(v1 + 336)) < 2;
      }
      if ((*(_BYTE *)(v1 + 475) & 1) == 0)
      {
        uint64_t v2 = (os_log_s *)g_boringssl_log;
        if (g_boringssl_log)
        {
          unsigned int v3 = result;
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG)) {
            nw_protocol_boringssl_waiting_for_output_cold_1(v1, v3, v2);
          }
          return v3;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t nw_protocol_boringssl_copy_info(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    return 0LL;
  }
  if ((*(_BYTE *)(v2 + 475) & 1) == 0)
  {
    if (datapath_logging_enabled)
    {
      if (g_boringssl_log)
      {
        uint64_t v19 = a1;
        int v16 = a2;
        BOOL v17 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
        a2 = v16;
        BOOL v18 = v17;
        a1 = v19;
        if (v18)
        {
          nw_protocol_boringssl_copy_info_cold_1();
          a1 = v19;
          a2 = v16;
        }
      }
    }
  }

  if (a2 == 254)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    else {
      uint64_t v6 = 0LL;
    }
    boringssl_session_get_handshake_time_ms(*(void *)(v2 + 336));
    boringssl_session_get_handshake_rtt_ms(*(void *)(v2 + 336));
    uint64_t v14 = (void *)MEMORY[0x1895A9574]();
    id v13 = (void *)nw_protocol_establishment_report_create();

    if (!v13) {
      goto LABEL_27;
    }
LABEL_24:
    if (!v6) {
      uint64_t v6 = nw_array_create();
    }
    nw_array_append();
LABEL_27:

    return v6;
  }

  if (a2 == 255)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    else {
      uint64_t v6 = 0LL;
    }
    id v13 = boringssl_context_copy_metadata(*(void *)(v2 + 336));
    if (!v13) {
      goto LABEL_27;
    }
    goto LABEL_24;
  }

  uint64_t v10 = *(void *)(a1 + 32);
  else {
    return 0LL;
  }
}

id boringssl_context_copy_metadata(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == -1252936367 && (uint64_t v1 = *(void *)(a1 + 8)) != 0) {
    return *(id *)(v1 + 520);
  }
  else {
    return 0LL;
  }
}

void __boringssl_metrics_log_metric_block_invoke()
{
  if ((SecTrustReportNetworkingAnalytics() & 1) == 0
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    __boringssl_metrics_log_metric_block_invoke_cold_1();
  }

uint64_t boringssl_session_read(void *a1, void *a2, int a3, int a4)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v5 = a1[1];
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  if (a3)
  {
    uint64_t v7 = *(SSL **)(v5 + 400);
    if (v7)
    {
      if (a2 || (a4 & 1) != 0)
      {
        if (a4) {
          uint64_t v16 = SSL_peek(v7, a2, a3);
        }
        else {
          uint64_t v16 = SSL_read(v7, a2, a3);
        }
        uint64_t v6 = v16;
        if ((int)v16 <= 0)
        {
          uint64_t error = SSL_get_error(*(const SSL **)(v5 + 400), v16);
          uint64_t v18 = error;
          if ((error - 5) >= 2)
          {
            if ((_DWORD)error == 2)
            {
              ++*(void *)(v5 + 496);
              id WeakRetained = objc_loadWeakRetained((id *)(v5 + 16));
              if (!WeakRetained
                || (unint64_t v28 = WeakRetained,
                    __int16 v29 = objc_loadWeakRetained((id *)(v5 + 16)),
                    char v30 = v29[475],
                    v29,
                    v28,
                    (v30 & 1) == 0))
              {
                id v31 = objc_loadWeakRetained((id *)(v5 + 16));
                if (v31)
                {
                  unint64_t v32 = objc_loadWeakRetained((id *)(v5 + 16));
                  char v33 = v32[475] & 1;
                }

                else
                {
                  char v33 = 0;
                }

                if ((v33 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
                {
                  __int16 v35 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
                    boringssl_session_read_cold_2();
                  }
                }
              }
            }

            else
            {
              ERR_print_errors_cb( (int (__cdecl *)(const char *, size_t, void *))boringssl_session_handshake_error_print,  a1);
            }
          }

          else
          {
            id v19 = objc_loadWeakRetained((id *)(v5 + 16));
            if (!v19
              || (BOOL v20 = v19,
                  char v21 = objc_loadWeakRetained((id *)(v5 + 16)),
                  char v22 = v21[475],
                  v21,
                  v20,
                  (v22 & 1) == 0))
            {
              id v23 = objc_loadWeakRetained((id *)(v5 + 16));
              if (v23)
              {
                unint64_t v24 = objc_loadWeakRetained((id *)(v5 + 16));
                char v25 = v24[475] & 1;
              }

              else
              {
                char v25 = 0;
              }

              if ((v25 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
              {
                char v34 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
                  boringssl_session_read_cold_1(v5, v18, v34);
                }
              }
            }
          }
        }
      }

      else
      {
        id v8 = objc_loadWeakRetained((id *)(v5 + 16));
        if (v8)
        {
          size_t v9 = v8;
          uint64_t v10 = objc_loadWeakRetained((id *)(v5 + 16));
          char v11 = v10[475];

          if ((v11 & 1) != 0) {
            return 0xFFFFFFFFLL;
          }
        }

        id v12 = objc_loadWeakRetained((id *)(v5 + 16));
        if (v12)
        {
          id v13 = objc_loadWeakRetained((id *)(v5 + 16));
          BOOL v14 = (v13[475] & 1) == 0;
        }

        else
        {
          BOOL v14 = 1;
        }

        uint64_t v6 = 0xFFFFFFFFLL;
        if (v14 && g_boringssl_log)
        {
          uint64_t v26 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            boringssl_session_read_cold_3(v5, v26);
          }

          return 0xFFFFFFFFLL;
        }
      }
    }
  }

  return v6;
}

int SSL_peek(SSL *ssl, void *buf, int num)
{
  if (*(void *)&ssl->hit)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1313);
    LODWORD(v3) = -1;
  }

  else
  {
    LODWORD(v3) = num;
    int impl = ssl_read_impl(ssl);
    if (impl < 1)
    {
      LODWORD(v3) = impl;
    }

    else if ((int)v3 >= 1)
    {
      handshake_func = ssl->handshake_func;
      else {
        size_t v3 = *((void *)handshake_func + 17);
      }
      if (buf && v3) {
        memcpy(buf, *((const void **)handshake_func + 16), v3);
      }
    }
  }

  return v3;
}

uint64_t ssl_read_impl(ssl_st *a1)
{
  *((_DWORD *)a1->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (!*(void *)&a1->rwstate)
  {
    int v4 = 226;
    int v5 = 1230;
LABEL_28:
    ERR_put_error(16, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v5);
    return 0xFFFFFFFFLL;
  }

  handshake_func = a1->handshake_func;
  if (*((_DWORD *)handshake_func + 43) == 2)
  {
    ERR_restore_state(*((void **)handshake_func + 23));
    return 0xFFFFFFFFLL;
  }

  while (2)
  {
    uint64_t v6 = a1->handshake_func;
    if (*((void *)v6 + 17)) {
      return 1LL;
    }
    if ((*((_WORD *)v6 + 110) & 0x1000) != 0)
    {
      *((_DWORD *)v6 + 49) = 19;
      return 0xFFFFFFFFLL;
    }

    while (1)
    {
      uint64_t v7 = *((void *)a1->handshake_func + 35);
      if (!v7 || (*(_WORD *)(v7 + 1584) & 0x1008) != 0) {
        break;
      }
      uint64_t v8 = SSL_do_handshake(a1);
      if ((v8 & 0x80000000) != 0) {
        return v8;
      }
      if (!(_DWORD)v8)
      {
        int v4 = 215;
        int v5 = 1254;
        goto LABEL_28;
      }
    }

    unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[0] = v9;
    v21[1] = v9;
    if ((*(unsigned int (**)(ssl_st *, _OWORD *))(*(void *)&a1->version + 24LL))(a1, v21))
    {
      uint64_t v10 = *((void *)a1->handshake_func + 35);
      if (!v10 || (int v11 = *(_DWORD *)(v10 + 1584), (v11 & 8) != 0))
      {
        if (!ssl_do_post_handshake((uint64_t)a1, (uint64_t)v21))
        {
          bssl::ssl_set_read_error((bssl *)a1, v15);
          return 0xFFFFFFFFLL;
        }

        (*(void (**)(ssl_st *))(*(void *)&a1->version + 32LL))(a1);
      }

      else
      {
        *(_DWORD *)(v10 + 1bssl::Array<unsigned short>::~Array(v16 + 584) = v11 & 0xFFFFEFFF;
      }

      int v14 = 2;
    }

    else
    {
      unsigned __int8 v20 = 50;
      id v19 = 0LL;
      int v12 = bssl::ssl_open_app_data(a1, (uint64_t)a1->handshake_func + 128, &v19, &v20);
      char v18 = -86;
      uint64_t v13 = bssl::ssl_handle_open_record((bssl *)a1, &v18, v12, v19, v20);
      if ((int)v13 < 1)
      {
        int v14 = 1;
        uint64_t v1 = v13;
      }

      else if (v18)
      {
        int v14 = 0;
      }

      else
      {
        uint64_t v16 = a1->handshake_func;
        if (!*((void *)v16 + 17)) {
          ssl_read_impl();
        }
        int v14 = 0;
        *((_BYTE *)v16 + 212) = 0;
      }
    }

    if (v14 != 1) {
      continue;
    }
    return v1;
  }

uint64_t bssl::ssl_open_app_data(void *a1, uint64_t a2, void *a3, _BYTE *a4)
{
  *a3 = 0LL;
  uint64_t v5 = a1[6];
  if (*(_DWORD *)(v5 + 172) == 2)
  {
    ERR_restore_state(*(void **)(v5 + 184));
    *a4 = 0;
  }

  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 64LL))(a1);
    if ((_DWORD)result != 4) {
      return result;
    }
    uint64_t v8 = a1[6];
    *(_DWORD *)(v8 + 172) = 2;
    __int128 v9 = (uint64_t *)(v8 + 184);
    uint64_t v10 = ERR_save_state();
    std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100](v9, (uint64_t)v10);
  }

  return 4LL;
}

uint64_t bssl::tls_open_app_data( uint64_t a1, ssl_st *a2, unsigned __int8 **a3, ssl_st *a4, unsigned __int16 *a5, unint64_t a6)
{
  if ((bssl::ssl_can_read((bssl *)a1, a2) & 1) == 0) {
    bssl::tls_open_app_data();
  }
  if (!**(void **)(*(void *)(a1 + 48) + 264LL)) {
    bssl::tls_open_app_data();
  }
  char v22 = -86;
  __int128 v21 = 0uLL;
  uint64_t result = bssl::tls_open_record((bssl *)a1, &v22, (uint64_t)&v21, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
    BOOL v14 = (*(_BYTE *)(a1 + 180) & 1) != 0 && SSL_in_early_data(a1) != 0;
    if (v22 != 23)
    {
      if (v22 == 22)
      {
        if ((*(_BYTE *)(a1 + 180) & 1) != 0 && bssl::ssl_protocol_version((bssl *)a1, v13) <= 0x303)
        {
          ERR_put_error(16, 0, 182, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 330);
          char v15 = 100;
LABEL_19:
          LOBYTE(a4->version) = v15;
          return 4LL;
        }

        if ((bssl::tls_append_handshake_data(a1, (const void *)v21, *((size_t *)&v21 + 1)) & 1) == 0)
        {
          char v15 = 80;
          goto LABEL_19;
        }

        return 1LL;
      }

      int v19 = 225;
      int v20 = 343;
LABEL_16:
      ERR_put_error(16, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", v20);
      char v15 = 10;
      goto LABEL_19;
    }

    uint64_t v16 = *((void *)&v21 + 1);
    if (v14)
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 280LL);
      uint64_t v18 = *(unsigned __int16 *)(v17 + 1590);
      if (*((void *)&v21 + 1) > (unint64_t)(14336 - v18))
      {
        int v19 = 300;
        int v20 = 350;
        goto LABEL_16;
      }

      *(_WORD *)(v17 + 1590) = v18 + WORD4(v21);
    }

    if (v16)
    {
      uint64_t result = 0LL;
      *(_OWORD *)&a2->version = v21;
      return result;
    }

    return 1LL;
  }

  return result;
}

uint64_t bssl::ssl_can_read(bssl *this, const ssl_st *a2)
{
  uint64_t v2 = *(void *)(*((void *)this + 6) + 280LL);
  if (!v2) {
    return 1LL;
  }
  unsigned int v3 = *(_DWORD *)(v2 + 1584);
  if ((v3 & 8) != 0) {
    return 1LL;
  }
  else {
    return (v3 >> 12) & 1;
  }
}

uint64_t ssl_do_post_handshake(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 180) & 1) != 0)
  {
    ERR_put_error(16, 0, 182, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1171);
  }

  else
  {
    if (*(_BYTE *)(a2 + 1) || *(void *)(a2 + 16))
    {
      bssl::ssl_send_alert((bssl *)a1, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 110, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", 1178);
      return 0LL;
    }

    if (*(_DWORD *)(a1 + 176) == 3) {
      return 1LL;
    }
    *(_WORD *)(*(void *)(a1 + 48) + 220LL) |= 0x1000u;
    if (*(_DWORD *)(a1 + 176) == 4 || SSL_renegotiate((SSL *)a1)) {
      return 1LL;
    }
  }

  bssl::ssl_send_alert((bssl *)a1, (ssl_st *)2, 100);
  return 0LL;
}

uint64_t bssl::tls13_post_handshake(bssl *this, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a2 + 1);
  uint64_t v4 = *((void *)this + 6);
  if (v3 != 24)
  {
    *(_BYTE *)(v4 + 212) = 0;
    if (v3 == 4 && (*((_BYTE *)this + 180) & 1) == 0) {
      return bssl::tls13_process_new_session_ticket(this, a2);
    }
    bssl::ssl_send_alert(this, (ssl_st *)2, 10);
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 934);
    return 0LL;
  }

  unsigned __int8 v5 = *(_BYTE *)(v4 + 212) + 1;
  *(_BYTE *)(v4 + 212) = v5;
  if (*((void *)this + 21) || v5 >= 0x21u)
  {
    ERR_put_error(16, 0, 260, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 919);
    __int128 v9 = this;
    int v10 = 10;
LABEL_18:
    bssl::ssl_send_alert(v9, (ssl_st *)2, v10);
    return 0LL;
  }

  __int128 v12 = *(_OWORD *)(a2 + 8);
  unsigned __int8 v11 = -86;
  if (!CBS_get_u8(&v12, &v11) || *((void *)&v12 + 1) || v11 >= 2u)
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 895);
    __int128 v9 = this;
    int v10 = 50;
    goto LABEL_18;
  }

  int v6 = bssl::tls13_rotate_traffic_key((const SSL *)this, 0LL);
  uint64_t result = 0LL;
  if (v6)
  {
    if (v11 != 1) {
      return 1LL;
    }
    if ((*(_WORD *)(*((void *)this + 6) + 220LL) & 0x200) != 0) {
      return 1LL;
    }
    int v8 = bssl::tls13_add_key_update(this, 0LL);
    uint64_t result = 0LL;
    if (v8) {
      return 1LL;
    }
  }

  return result;
}

uint64_t bssl::tls13_process_new_session_ticket(bssl *a1, uint64_t a2)
{
  if (*(_DWORD *)(*((void *)a1 + 6) + 176LL)) {
    return 1LL;
  }
  __int128 v9 = *(_OWORD *)(a2 + 8);
  seunsigned int s = (SSL_SESSION *)0xAAAAAAAAAAAAAAAALL;
  bssl::tls13_create_session_with_ticket(a1, (uint64_t *)&v9, &ses);
  uint64_t v4 = ses;
  BOOL v2 = ses != 0LL;
  if (ses)
  {
    uint64_t v5 = *((void *)a1 + 16);
    if ((*(_BYTE *)(v5 + 300) & 1) == 0
      || (int v6 = *(unsigned int (**)(bssl *, SSL_SESSION *))(v5 + 312)) == 0LL
      || !v6(a1, ses))
    {
      seunsigned int s = 0LL;
      SSL_SESSION_free(v4);
    }
  }

  return v2;
}

void sub_18758E144(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void bssl::tls13_create_session_with_ticket(bssl *a1@<X0>, uint64_t *a2@<X1>, SSL_SESSION **a3@<X8>)
{
  v25[1] = *MEMORY[0x1895F89C0];
  seunsigned int s = (SSL_SESSION *)0xAAAAAAAAAAAAAAAALL;
  bssl::SSL_SESSION_dup(*(bssl **)(*((void *)a1 + 6) + 472LL), (ssl_session_st *)2, &ses);
  if (!ses)
  {
    *a3 = 0LL;
    return;
  }

  bssl::ssl_session_rebase_time(a1, (ssl_st *)ses, v6);
  unsigned int v23 = -1431655766;
  memset(v22, 170, sizeof(v22));
  *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u32(a2, (int *)&v23)
    || !CBS_get_u32(a2, (int *)&ses[1].session_id[16])
    || !CBS_get_u8_length_prefixed((unsigned __int8 **)a2, &v22[2])
    || !CBS_get_u16_length_prefixed((unsigned __int8 **)a2, v22))
  {
    goto LABEL_13;
  }

  uint64_t v7 = (const void *)v22[0];
  size_t v8 = v22[1];
  p_dummy = &ses->ex_data.dummy;
  int v10 = bssl::Array<unsigned char>::Init((uint64_t)&ses->ex_data.dummy, v22[1]);
  char v11 = v10 ^ 1;
  if (!v8) {
    char v11 = 1;
  }
  if ((v11 & 1) == 0) {
    memmove(*(void **)p_dummy, v7, v8);
  }
  if (!v10 || !CBS_get_u16_length_prefixed((unsigned __int8 **)a2, (unint64_t *)&v21) || a2[1])
  {
LABEL_13:
    bssl::ssl_send_alert(a1, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", 1133);
LABEL_14:
    *a3 = 0LL;
    goto LABEL_15;
  }

  uint64_t v13 = (unsigned __int8 *)ses;
  if (LODWORD(ses->time) > v23) {
    LODWORD(ses->time) = v23;
  }
  if (!bssl::tls13_derive_session_psk(v13, (const ssl_session_st *)v22[2], v22[3])) {
    goto LABEL_14;
  }
  v18[1] = -1431655766;
  uint64_t v19 = 0LL;
  v18[0] = 65578;
  uint64_t v20 = 0LL;
  unsigned __int8 v17 = 50;
  v25[0] = (uint64_t)v18;
  if ((bssl::ssl_parse_extensions(&v21, (char *)&v17, v25, 1LL, 1) & 1) == 0)
  {
    bssl::ssl_send_alert(a1, (ssl_st *)2, v17);
LABEL_33:
    uint64_t v16 = 0LL;
    goto LABEL_34;
  }

  BOOL v14 = ses;
  if (HIBYTE(v18[0]))
  {
    if (!CBS_get_u32(&v19, (int *)&ses[1].session_id[20]) || v20)
    {
      bssl::ssl_send_alert(a1, (ssl_st *)2, 50);
      int v15 = 1159;
      goto LABEL_32;
    }

    BOOL v14 = ses;
    if (*((void *)a1 + 21) && *(_DWORD *)&ses[1].session_id[20] != -1)
    {
      bssl::ssl_send_alert(a1, (ssl_st *)2, 47);
      int v15 = 1168;
LABEL_32:
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_client.cc", v15);
      goto LABEL_33;
    }
  }

  SHA256((const unsigned __int8 *)v22[0], v22[1], &v14->master_key[40]);
  uint64_t v16 = ses;
  ses->master_key[39] = 32;
  LOBYTE(v16[1].peer) = (uint64_t)v16[1].peer & 0xF3 | 8;
  seunsigned int s = 0LL;
LABEL_34:
  *a3 = v16;
LABEL_15:
  __int128 v12 = ses;
  seunsigned int s = 0LL;
  if (v12) {
    SSL_SESSION_free(v12);
  }
}

void sub_18758E430( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

int8x8_t bssl::ssl_session_rebase_time(bssl *this, ssl_st *a2, ssl_session_st *a3)
{
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_get_current_time((uint64_t)this, (uint64_t)v11);
  cipher_list_by_iunsigned int d = a2->cipher_list_by_id;
  int v6 = (STACK *)v11[0];
  BOOL v7 = v11[0] >= (unint64_t)cipher_list_by_id;
  unint64_t v8 = v11[0] - (void)cipher_list_by_id;
  if (v7)
  {
    a2->cipher_list_by_iunsigned int d = (STACK *)v11[0];
    cipher_list = a2->cipher_list;
    v10.i64[0] = cipher_list;
    v10.i64[1] = HIDWORD(cipher_list);
    int8x8_t result = vbic_s8( (int8x8_t)vsub_s32((int32x2_t)cipher_list, vdup_n_s32(v8)),  (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(v8), v10)));
    a2->cipher_list = (STACK *)result;
  }

  else
  {
    a2->cipher_list = 0LL;
    a2->cipher_list_by_iunsigned int d = v6;
  }

  return result;
}

uint64_t CBS_get_u32(uint64_t *a1, int *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = v2 - 4;
  if (v2 < 4) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  int v6 = 0;
  uint64_t v7 = *a1;
  *a1 += 4LL;
  a1[1] = v3;
  do
    int v6 = *(unsigned __int8 *)(v7 + v5++) | (v6 << 8);
  while (v5 != 4);
  *a2 = v6;
  return 1LL;
}

BOOL bssl::tls13_derive_session_psk(unsigned __int8 *a1, const ssl_session_st *a2, size_t a3)
{
  digest = (EVP_MD *)bssl::ssl_session_get_digest((bssl *)a1, a2);
  return CRYPTO_tls13_hkdf_expand_label( (_DWORD)a1 + 11,  a1[10],  digest,  (uint64_t)(a1 + 11),  a1[10],  "resumption",  0xAuLL,  a2,  a3);
}

unsigned __int8 *__cdecl SHA256(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_187604310;
  *(_OWORD *)&v5.h[4] = xmmword_187604320;
  v5.unsigned int md_len = 32;
  SHA256_Update(&v5, d, n);
  sha256_final_impl(md, v5.md_len, (uint64_t)&v5);
  OPENSSL_cleanse(&v5, 0x70uLL);
  return md;
}

int SHA256_Update(SHA256_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    uint64_t v4 = (unsigned int *)data;
    uint64_t v6 = c->data;
    size_t v7 = *(void *)&c->Nl + 8 * len;
    *(void *)&c->Nl = v7;
    uint64_t num = c->num;
    if ((_DWORD)num)
    {
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy((char *)v6 + num, data, len);
        c->num += v3;
        return 1;
      }

      uint64_t v9 = 64 - num;
      if ((_DWORD)num != 64) {
        memcpy((char *)v6 + num, data, 64 - num);
      }
      sha256_block_data_order((unint64_t)c, v6, 1LL);
      uint64_t v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->uint64_t num = 0;
      *(_OWORD *)uint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *((_OWORD *)v6 + 2) = 0u;
      *((_OWORD *)v6 + 3) = 0u;
    }

    if (v3 >= 0x40)
    {
      sha256_block_data_order((unint64_t)c, v4, v3 >> 6);
      uint64_t v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0LL));
      v3 &= 0x3Fu;
    }

    if (v3)
    {
      c->uint64_t num = v3;
      memcpy(v6, v4, v3);
    }
  }

  return 1;
}

unint64_t sha256_block_data_order(unint64_t result, unsigned int *a2, uint64_t a3)
{
  BOOL v217 = (_DWORD *)result;
  uint64_t v229 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    unsigned int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v6 = *(_DWORD *)(result + 8);
    int v5 = *(_DWORD *)(result + 12);
    int v8 = *(_DWORD *)(result + 16);
    int v7 = *(_DWORD *)(result + 20);
    int v9 = *(_DWORD *)(result + 24);
    LODWORD(result) = *(_DWORD *)(result + 28);
    do
    {
      uint64_t v227 = a3;
      unsigned int v10 = bswap32(*a2);
      HIDWORD(v11) = v8;
      LODWORD(v11) = v8;
      int v12 = (v11 >> 6) ^ __ROR4__(v8, 11);
      unint64_t v13 = __PAIR64__(v3, __ROR4__(v8, 25));
      int v218 = result;
      int v14 = result + (v8 & v7) + (v9 & ~v8) + v10 + (v12 ^ v13) + 1116352408;
      LODWORD(v13) = v3;
      int v222 = v5;
      int v15 = v14 + v5;
      unsigned int v16 = ((v13 >> 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + ((v4 ^ v6) & v3 ^ v4 & v6) + v14;
      unsigned int v17 = bswap32(a2[1]);
      HIDWORD(v13) = v15;
      LODWORD(v13) = v15;
      v228[0] = v10;
      v228[1] = v17;
      int v18 = (v13 >> 6) ^ __ROR4__(v15, 11);
      unint64_t v19 = __PAIR64__(v16, __ROR4__(v15, 25));
      int v219 = v9;
      int v20 = v9 + v17 + (v7 & ~v15) + (v15 & v8) + 1899447441 + (v18 ^ v19);
      LODWORD(v19) = v16;
      int v223 = v6;
      int v21 = v20 + v6;
      unsigned int v22 = ((v19 >> 2) ^ __ROR4__(v16, 13) ^ __ROR4__(v16, 22)) + (v16 & (v3 ^ v4) ^ v3 & v4) + v20;
      unsigned int v23 = bswap32(a2[2]);
      HIDWORD(v19) = v21;
      LODWORD(v19) = v21;
      int v24 = (v19 >> 6) ^ __ROR4__(v21, 11);
      unint64_t v26 = __PAIR64__(v22, __ROR4__(v21, 25));
      int v25 = v24 ^ v26;
      int v220 = v7;
      LODWORD(v26) = v22;
      int v27 = v7 + v23 + (v8 & ~v21) + (v21 & v15) - 1245643825 + v25;
      int v224 = v4;
      int v28 = v27 + v4;
      unsigned int v29 = ((v26 >> 2) ^ __ROR4__(v22, 13) ^ __ROR4__(v22, 22)) + (v22 & (v16 ^ v3) ^ v16 & v3) + v27;
      unsigned int v30 = bswap32(a2[3]);
      v228[2] = v23;
      v228[3] = v30;
      HIDWORD(v26) = v28;
      LODWORD(v26) = v28;
      int v31 = (v26 >> 6) ^ __ROR4__(v28, 11);
      unint64_t v32 = __PAIR64__(v29, __ROR4__(v28, 25));
      int v221 = v8;
      int v33 = v8 + v30 + (v15 & ~v28) + (v28 & v21) - 373957723 + (v31 ^ v32);
      LODWORD(vRAND_bytes(buf, 32) = v29;
      unsigned int v225 = v3;
      int v34 = v33 + v3;
      unsigned int v35 = ((v32 >> 2) ^ __ROR4__(v29, 13) ^ __ROR4__(v29, 22)) + (v29 & (v22 ^ v16) ^ v22 & v16) + v33;
      unsigned int v36 = bswap32(a2[4]);
      HIDWORD(vRAND_bytes(buf, 32) = v34;
      LODWORD(vRAND_bytes(buf, 32) = v34;
      int v37 = (v32 >> 6) ^ __ROR4__(v34, 11);
      unint64_t v38 = __PAIR64__(v35, __ROR4__(v34, 25));
      int v39 = v15 + v36 + (v21 & ~v34) + (v34 & v28) + 961987163 + (v37 ^ v38);
      LODWORD(v3_Block_object_dispose(va, 8) = v35;
      int v40 = v39 + v16;
      unsigned int v41 = ((v38 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + (v35 & (v29 ^ v22) ^ v29 & v22) + v39;
      unsigned int v42 = bswap32(a2[5]);
      v228[4] = v36;
      v228[5] = v42;
      HIDWORD(v3_Block_object_dispose(va, 8) = v40;
      LODWORD(v3_Block_object_dispose(va, 8) = v40;
      int v43 = (v38 >> 6) ^ __ROR4__(v40, 11);
      unint64_t v44 = __PAIR64__(v41, __ROR4__(v40, 25));
      int v45 = v21 + v42 + (v28 & ~v40) + (v40 & v34) + 1508970993 + (v43 ^ v44);
      LODWORD(v44) = v41;
      int v46 = v45 + v22;
      unsigned int v47 = ((v44 >> 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v35 ^ v29) ^ v35 & v29) + v45;
      unsigned int v48 = bswap32(a2[6]);
      int v49 = v48 + v28 + (v34 & ~v46) + (v46 & v40);
      HIDWORD(v44) = v46;
      LODWORD(v44) = v46;
      int v50 = (v44 >> 6) ^ __ROR4__(v46, 11);
      unint64_t v51 = __PAIR64__(v47, __ROR4__(v46, 25));
      int v52 = v49 - 1841331548 + (v50 ^ v51);
      LODWORD(v51) = v47;
      int v53 = v52 + v29;
      unsigned int v54 = ((v51 >> 2) ^ __ROR4__(v47, 13) ^ __ROR4__(v47, 22)) + (v47 & (v41 ^ v35) ^ v41 & v35) + v52;
      unsigned int v55 = bswap32(a2[7]);
      HIDWORD(v51) = v53;
      LODWORD(v51) = v53;
      v228[6] = v48;
      v228[7] = v55;
      int v56 = (v51 >> 6) ^ __ROR4__(v53, 11);
      unint64_t v57 = __PAIR64__(v54, __ROR4__(v53, 25));
      int v58 = v55 + v34 + (v40 & ~v53) + (v53 & v46) - 1424204075 + (v56 ^ v57);
      LODWORD(v57) = v54;
      int v59 = v58 + v35;
      unsigned int v60 = ((v57 >> 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + (v54 & (v47 ^ v41) ^ v47 & v41) + v58;
      HIDWORD(v57) = v59;
      LODWORD(v57) = v59;
      unsigned int v61 = bswap32(a2[8]);
      int v62 = (v57 >> 6) ^ __ROR4__(v59, 11);
      unint64_t v63 = __PAIR64__(v60, __ROR4__(v59, 25));
      int v64 = v61 + v40 + (v46 & ~v59) + (v59 & v53) - 670586216 + (v62 ^ v63);
      LODWORD(v63) = v60;
      int v65 = v64 + v41;
      unsigned int v66 = ((v63 >> 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + (v60 & (v54 ^ v47) ^ v54 & v47) + v64;
      unsigned int v67 = bswap32(a2[9]);
      v228[8] = v61;
      v228[9] = v67;
      HIDWORD(v63) = v65;
      LODWORD(v63) = v65;
      int v68 = (v63 >> 6) ^ __ROR4__(v65, 11);
      unint64_t v69 = __PAIR64__(v66, __ROR4__(v65, 25));
      int v70 = v67 + v46 + (v53 & ~v65) + (v65 & v59) + 310598401 + (v68 ^ v69);
      LODWORD(v69) = v66;
      int v71 = v70 + v47;
      unsigned int v72 = ((v69 >> 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + (v66 & (v60 ^ v54) ^ v60 & v54) + v70;
      unsigned int v73 = bswap32(a2[10]);
      int v74 = v73 + v53 + (v59 & ~v71) + (v71 & v65);
      HIDWORD(v69) = v71;
      LODWORD(v69) = v71;
      int v75 = (v69 >> 6) ^ __ROR4__(v71, 11);
      unint64_t v76 = __PAIR64__(v72, __ROR4__(v71, 25));
      int v77 = v74 + 607225278 + (v75 ^ v76);
      LODWORD(v76) = v72;
      int v78 = v77 + v54;
      unsigned int v79 = ((v76 >> 2) ^ __ROR4__(v72, 13) ^ __ROR4__(v72, 22)) + (v72 & (v66 ^ v60) ^ v66 & v60) + v77;
      unsigned int v80 = bswap32(a2[11]);
      v228[10] = v73;
      v228[11] = v80;
      HIDWORD(v76) = v78;
      LODWORD(v76) = v78;
      int v81 = (v76 >> 6) ^ __ROR4__(v78, 11);
      unint64_t v82 = __PAIR64__(v79, __ROR4__(v78, 25));
      int v83 = v80 + v59 + (v65 & ~v78) + (v78 & v71) + 1426881987 + (v81 ^ v82);
      LODWORD(v82) = v79;
      int v84 = v83 + v60;
      unsigned int v85 = ((v82 >> 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v72 ^ v66) ^ v72 & v66) + v83;
      unsigned int v86 = bswap32(a2[12]);
      HIDWORD(v82) = v84;
      LODWORD(v82) = v84;
      int v87 = (v82 >> 6) ^ __ROR4__(v84, 11);
      unint64_t v88 = __PAIR64__(v85, __ROR4__(v84, 25));
      int v89 = v86 + v65 + (v71 & ~v84) + (v84 & v78) + 1925078388 + (v87 ^ v88);
      LODWORD(v8_Block_object_dispose(va, 8) = v85;
      unsigned int v90 = v89 + v66;
      unsigned int v91 = ((v88 >> 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v79 ^ v72) ^ v79 & v72) + v89;
      unsigned int v92 = bswap32(a2[13]);
      HIDWORD(v8_Block_object_dispose(va, 8) = v90;
      LODWORD(v8_Block_object_dispose(va, 8) = v90;
      v228[12] = v86;
      v228[13] = v92;
      int v93 = (v88 >> 6) ^ __ROR4__(v90, 11);
      unint64_t v94 = __PAIR64__(v91, __ROR4__(v90, 25));
      int v95 = v92 + v71 + (v78 & ~v90) + (v90 & v84) - 2132889090 + (v93 ^ v94);
      LODWORD(v94) = v91;
      unsigned int v96 = v95 + v72;
      unsigned int v97 = ((v94 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v85 ^ v79) ^ v85 & v79) + v95;
      HIDWORD(v94) = v96;
      LODWORD(v94) = v95 + v72;
      __int128 v226 = a2;
      unsigned int v98 = bswap32(a2[14]);
      int v99 = (v94 >> 6) ^ __ROR4__(v96, 11);
      unint64_t v100 = __PAIR64__(v97, __ROR4__(v96, 25));
      int v101 = v98 + v78 + (v84 & ~v96) + (v96 & v90) - 1680079193 + (v99 ^ v100);
      LODWORD(v100) = v97;
      unsigned int v102 = v101 + v79;
      unsigned int v103 = ((v100 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v85) ^ v91 & v85) + v101;
      unsigned int v104 = bswap32(a2[15]);
      v228[14] = v98;
      v228[15] = v104;
      HIDWORD(v100) = v102;
      LODWORD(v100) = v102;
      int v105 = (v100 >> 6) ^ __ROR4__(v102, 11);
      unint64_t v106 = __PAIR64__(v103, __ROR4__(v102, 25));
      int v107 = v104 + v84 + (v90 & ~v102) + (v102 & v96) - 1046744716 + (v105 ^ v106);
      LODWORD(v106) = v103;
      unsigned int v108 = v107 + v85;
      unsigned int v109 = ((v106 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v107;
      BOOL v110 = &dword_18760438C;
      uint64_t v111 = 31LL;
      do
      {
        unint64_t v112 = v111 - 15;
        uint64_t v113 = ((int)v111 - 14) & 9LL;
        unsigned int v114 = v228[v113];
        unsigned int v115 = v228[((_BYTE)v111 - 1) & 0xE];
        HIDWORD(v117) = v114;
        LODWORD(v117) = v114;
        int v116 = v117 >> 7;
        unint64_t v119 = __PAIR64__(v115, __ROR4__(v114, 18));
        int v118 = v116 ^ v119;
        LODWORD(v119) = v115;
        int v120 = v119 >> 17;
        unint64_t v121 = __PAIR64__(v108, __ROR4__(v115, 19));
        uint64_t v122 = (v111 - 15) & 8;
        int v123 = v120 ^ v121 ^ (v115 >> 10);
        LODWORD(v121) = v108;
        int v124 = (v111 - 15) & 8;
        unsigned int v125 = (v118 ^ (v114 >> 3)) + v228[((int)v111 - 6) & 9LL] + v228[v122] + v123;
        int v126 = (v121 >> 6) ^ __ROR4__(v108, 11);
        unint64_t v128 = __PAIR64__(v109, __ROR4__(v108, 25));
        int v127 = v126 ^ v128;
        LODWORD(v12_Block_object_dispose(va, 8) = v109;
        int v129 = *(v110 - 6);
        int v130 = (v108 & v102) + v90 + (v96 & ~v108) + *(v110 - 7) + v127;
        v228[v122] = v125;
        LODWORD(v122) = ((v128 >> 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + ((v103 ^ v97) & v109 ^ v103 & v97);
        int v131 = v130 + v125;
        unsigned int v132 = v131 + v91;
        HIDWORD(v12_Block_object_dispose(va, 8) = v228[v124 | 2];
        LODWORD(v12_Block_object_dispose(va, 8) = HIDWORD(v128);
        unsigned int v133 = v122 + v131;
        unsigned int v134 = v228[v111 & 0xF];
        int v135 = (v128 >> 7) ^ __ROR4__(HIDWORD(v128), 18) ^ (HIDWORD(v128) >> 3);
        HIDWORD(v12_Block_object_dispose(va, 8) = v134;
        LODWORD(v12_Block_object_dispose(va, 8) = v134;
        int v136 = v128 >> 17;
        unint64_t v137 = __PAIR64__(v132, __ROR4__(v134, 19));
        int v138 = v228[((int)v111 - 5) & 0xALL] + v114 + (v136 ^ v137 ^ (v134 >> 10));
        LODWORD(v137) = v132;
        int v139 = v138 + v135;
        int v140 = (v137 >> 6) ^ __ROR4__(v132, 11);
        unint64_t v142 = __PAIR64__(v133, __ROR4__(v132, 25));
        int v141 = v140 ^ v142;
        LODWORD(v142) = v133;
        v228[v113] = v139;
        LODWORD(v113) = (v142 >> 2) ^ __ROR4__(v133, 13);
        unint64_t v143 = __PAIR64__(v125, __ROR4__(v133, 22));
        int v144 = (v102 & ~v132) + v96 + (v132 & v108) + v129 + v139 + v141;
        int v145 = (v113 ^ v143) + (v133 & (v109 ^ v103) ^ v109 & v103);
        unsigned int v146 = v144 + v97;
        unsigned int v147 = v228[v124 | 3];
        LODWORD(v143) = v125;
        int v148 = v143 >> 17;
        HIDWORD(v143) = v147;
        LODWORD(v143) = v147;
        LODWORD(v122) = (v143 >> 7) ^ __ROR4__(v147, 18);
        unint64_t v149 = __PAIR64__(v146, __ROR4__(v125, 19));
        int v150 = v148 ^ v149 ^ (v125 >> 10);
        uint64_t v151 = ((int)v111 - 13) & 0xALL;
        unsigned int v152 = v145 + v144;
        int v153 = v228[((int)v111 - 4) & 0xBLL] + v228[v151] + (v122 ^ (v147 >> 3)) + v150;
        LODWORD(v149) = v146;
        int v154 = (v149 >> 6) ^ __ROR4__(v146, 11);
        unint64_t v156 = __PAIR64__(v152, __ROR4__(v146, 25));
        int v155 = v154 ^ v156;
        v228[v151] = v153;
        LODWORD(v151) = *(v110 - 4);
        int v157 = *(v110 - 5) + v102 + v153;
        LODWORD(v156) = v152;
        int v158 = ((v156 >> 2) ^ __ROR4__(v152, 13) ^ __ROR4__(v152, 22)) + (v152 & (v133 ^ v109) ^ v133 & v109);
        unsigned int v159 = v228[v124 | 4];
        int v160 = v157 + (v108 & ~v146) + (v146 & v132) + v155;
        HIDWORD(v156) = v159;
        LODWORD(v156) = v159;
        int v161 = v156 >> 7;
        LODWORD(v122) = v228[v124 | 1];
        unint64_t v163 = __PAIR64__(v122, __ROR4__(v159, 18));
        int v162 = v161 ^ v163;
        LODWORD(v163) = v122;
        int v164 = v162 ^ (v159 >> 3);
        uint64_t v165 = ((int)v111 - 12) & 0xBLL;
        int v166 = v160 + v103;
        int v167 = v164
             + v228[((_BYTE)v111 - 3) & 0xC]
             + v228[v165]
             + ((v163 >> 17) ^ __ROR4__(v122, 19) ^ (v122 >> 10));
        unsigned int v168 = v158 + v160;
        HIDWORD(v163) = v166;
        LODWORD(v163) = v166;
        int v169 = (v163 >> 6) ^ __ROR4__(v166, 11);
        unint64_t v171 = __PAIR64__(v168, __ROR4__(v166, 25));
        int v170 = v169 ^ v171;
        v228[v165] = v167;
        LODWORD(v171) = v168;
        int v172 = v151 + v108 + v167 + (v132 & ~v166) + (v166 & v146) + v170;
        int v173 = ((v171 >> 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v168 & (v152 ^ v133) ^ v152 & v133);
        unsigned int v174 = v172 + v109;
        unsigned int v175 = v228[v124 | 5];
        HIDWORD(v171) = v175;
        LODWORD(v171) = v175;
        int v176 = (v171 >> 7) ^ __ROR4__(v175, 18);
        unsigned int v177 = v228[v124 | 2];
        HIDWORD(v171) = v177;
        LODWORD(v171) = v177;
        LODWORD(v165) = v171 >> 17;
        unint64_t v178 = __PAIR64__(v174, __ROR4__(v177, 19));
        uint64_t v179 = ((_BYTE)v111 - 11) & 0xC;
        int v180 = (v176 ^ (v175 >> 3)) + v228[((int)v111 - 2) & 0xDLL] + v228[v179] + (v165 ^ v178 ^ (v177 >> 10));
        unsigned int v181 = v173 + v172;
        LODWORD(v17_Block_object_dispose(va, 8) = v174;
        int v182 = (v178 >> 6) ^ __ROR4__(v174, 11);
        unint64_t v184 = __PAIR64__(v181, __ROR4__(v174, 25));
        int v183 = v182 ^ v184;
        v228[v179] = v180;
        LODWORD(v165) = *(v110 - 2);
        LODWORD(v184) = v181;
        LODWORD(v151) = ((v184 >> 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v168 ^ v152) ^ v168 & v152);
        int v185 = *(v110 - 3) + v180 + v132 + (v146 & ~v174) + (v174 & v166) + v183;
        unsigned int v90 = v185 + v133;
        unsigned int v186 = v228[v124 | 6];
        HIDWORD(v184) = v186;
        LODWORD(v184) = v186;
        int v187 = v184 >> 7;
        LODWORD(v113) = v228[v124 | 3];
        HIDWORD(v184) = v113;
        LODWORD(v184) = v113;
        int v188 = v184 >> 17;
        int v189 = v187 ^ __ROR4__(v186, 18) ^ (v186 >> 3);
        unint64_t v191 = __PAIR64__(v90, __ROR4__(v113, 19));
        int v190 = v188 ^ v191;
        uint64_t v192 = ((int)v111 - 10) & 0xDLL;
        unsigned int v91 = v151 + v185;
        unsigned int v193 = v228[v192] + v115 + v189 + (v190 ^ (v113 >> 10));
        LODWORD(v191) = v90;
        int v194 = (v191 >> 6) ^ __ROR4__(v90, 11);
        unint64_t v196 = __PAIR64__(v91, __ROR4__(v90, 25));
        int v195 = v194 ^ v196;
        v228[v192] = v193;
        LODWORD(v1bssl::Array<unsigned short>::~Array(v1 - 96) = v91;
        int v197 = v165 + v193 + v146 + (v166 & ~v90) + (v90 & v174) + v195;
        int v198 = ((v196 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v181 ^ v168) ^ v181 & v168);
        LODWORD(v179) = v228[v124 | 7];
        unsigned int v96 = v197 + v152;
        HIDWORD(v1bssl::Array<unsigned short>::~Array(v1 - 96) = v179;
        LODWORD(v1bssl::Array<unsigned short>::~Array(v1 - 96) = v179;
        LODWORD(v113) = v196 >> 7;
        unsigned int v199 = v228[v124 | 4];
        unint64_t v200 = __PAIR64__(v199, __ROR4__(v179, 18));
        LODWORD(v179) = v113 ^ v200 ^ (v179 >> 3);
        LODWORD(v200) = v199;
        LODWORD(v113) = v200 >> 17;
        unint64_t v201 = __PAIR64__(v96, __ROR4__(v199, 19));
        uint64_t v202 = ((_BYTE)v111 - 9) & 0xE;
        LODWORD(v179) = v228[v202] + v134 + v179 + (v113 ^ v201 ^ (v199 >> 10));
        unsigned int v97 = v198 + v197;
        LODWORD(v201) = v96;
        int v203 = (v201 >> 6) ^ __ROR4__(v96, 11);
        unint64_t v205 = __PAIR64__(v97, __ROR4__(v96, 25));
        int v204 = v203 ^ v205;
        v228[v202] = v179;
        LODWORD(v205) = v97;
        int v206 = *(v110 - 1) + v179 + v166 + (v174 & ~v96) + (v96 & v90) + v204;
        unsigned int v102 = v206 + v168;
        unsigned int v103 = ((v205 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v181) ^ v91 & v181) + v206;
        unsigned int v207 = v228[v124 ^ 8];
        HIDWORD(v205) = v207;
        LODWORD(v205) = v207;
        LODWORD(v179) = v205 >> 7;
        unsigned int v208 = v228[v124 | 5];
        HIDWORD(v205) = v208;
        LODWORD(v205) = v208;
        LODWORD(v113) = v205 >> 17;
        int v209 = v179 ^ __ROR4__(v207, 18) ^ (v207 >> 3);
        unint64_t v210 = __PAIR64__(v102, __ROR4__(v208, 19));
        uint64_t v211 = ((_BYTE)v111 - 8) & 0xF;
        LODWORD(v179) = v113 ^ v210 ^ (v208 >> 10);
        LODWORD(v210) = v102;
        int v212 = (v210 >> 6) ^ __ROR4__(v102, 11);
        int v213 = v228[v211] + v209 + v125 + v179;
        unint64_t v214 = __PAIR64__(v103, __ROR4__(v102, 25));
        LODWORD(v179) = v212 ^ v214;
        int v215 = *v110;
        v110 += 8;
        v228[v211] = v213;
        LODWORD(v214) = v103;
        int v216 = v215 + v213 + v174 + (v90 & ~v102) + (v102 & v96) + v179;
        unsigned int v108 = v216 + v181;
        unsigned int v109 = ((v214 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v216;
        v111 += 8LL;
      }

      while (v112 < 0x38);
      a2 = v226 + 16;
      unsigned int v3 = v109 + v225;
      int v4 = v103 + v224;
      *BOOL v217 = v109 + v225;
      v217[1] = v103 + v224;
      int v6 = v97 + v223;
      int v5 = v91 + v222;
      v217[2] = v97 + v223;
      v217[3] = v91 + v222;
      int v8 = v108 + v221;
      int v7 = v102 + v220;
      v217[4] = v108 + v221;
      v217[5] = v102 + v220;
      int v9 = v96 + v219;
      int8x8_t result = v90 + v218;
      v217[6] = v96 + v219;
      v217[7] = result;
      a3 = v227 - 1;
    }

    while (v227 != 1);
  }

  return result;
}

uint64_t sha256_final_impl(_DWORD *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a3 + 104);
  int v4 = (int32x2_t *)a3;
  uint64_t v7 = a3 + 40;
  int8x8_t v8 = *(int8x8_t *)(a3 + 32);
  *(_BYTE *)(a3 + 40 + v3) = 0x80;
  uint64_t v9 = v3 + 1;
  if (v3 < 0x38)
  {
    if (v3 == 55) {
      goto LABEL_8;
    }
  }

  else
  {
    if ((_DWORD)v3 != 63) {
      bzero((void *)(v7 + v9), 63 - v3);
    }
    sha256_block_data_order((unint64_t)v4, (unsigned int *)v7, 1LL);
    uint64_t v9 = 0LL;
  }

  bzero((void *)(v7 + v9), 56 - v9);
LABEL_8:
  v4[12] = vrev64_s32((int32x2_t)vrev32_s8(v8));
  sha256_block_data_order((unint64_t)v4, (unsigned int *)v7, 1LL);
  uint64_t result = 0LL;
  v4[13].i32[0] = 0;
  *(_OWORD *)uint64_t v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_OWORD *)(v7 + RAND_bytes(buf, 32) = 0u;
  *(_OWORD *)(v7 + 4_Block_object_dispose(va, 8) = 0u;
  if (a2 <= 0x20)
  {
    if ((a2 & 3) != 0) {
      sha256_final_impl_cold_2();
    }
    if (a2 >= 4)
    {
      unint64_t v11 = a2 >> 2;
      do
      {
        unsigned int v12 = v4->i32[0];
        int v4 = (int32x2_t *)((char *)v4 + 4);
        *a1++ = bswap32(v12);
        --v11;
      }

      while (v11);
    }

    return 1LL;
  }

  return result;
}

uint64_t boringssl_context_new_session_handler(const SSL *a1, uint64_t a2)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      int v4 = (char *)a1;
      int v5 = SSL_get_ex_data(a1, 0);
      if (v5)
      {
        uint64_t v6 = (uint64_t)v5;
        if (*(_DWORD *)v5 == -1252936367)
        {
          uint64_t v7 = v5[1];
          if (v7)
          {
            id WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
            if (!WeakRetained
              || (uint64_t v9 = WeakRetained,
                  unsigned int v10 = objc_loadWeakRetained((id *)(v7 + 16)),
                  char v11 = v10[475],
                  v10,
                  v9,
                  (v11 & 1) == 0))
            {
              id v12 = objc_loadWeakRetained((id *)(v7 + 16));
              if (v12)
              {
                unint64_t v13 = objc_loadWeakRetained((id *)(v7 + 16));
                BOOL v14 = (v13[475] & 1) == 0;
              }

              else
              {
                BOOL v14 = 1;
              }

              if (v14)
              {
                if (g_boringssl_log)
                {
                  int v15 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
                  {
                    id v16 = objc_loadWeakRetained((id *)(v7 + 16));
                    if (v16)
                    {
                      unint64_t v2 = (unint64_t)objc_loadWeakRetained((id *)(v7 + 16));
                      unsigned int v17 = (void *)(v2 + 391);
                    }

                    else
                    {
                      unsigned int v17 = &unk_1875F4C23;
                    }

                    id v18 = objc_loadWeakRetained((id *)(v7 + 16));
                    *(_DWORD *)buf = 136446978;
                    int v68 = "boringssl_context_new_session_handler";
                    __int16 v69 = 1024;
                    int v70 = 1473;
                    __int16 v71 = 2082;
                    unsigned int v72 = v17;
                    __int16 v73 = 2048;
                    id v74 = v18;
                    _os_log_impl( &dword_187560000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] New session available",  buf,  0x26u);

                    if (v16) {
                  }
                    }
                }
              }
            }

            unint64_t v19 = boringssl_session_state_create(a2, (unsigned __int8 *)(v7 + 224));
            if (v19)
            {
              objc_storeStrong((id *)(v7 + 392), v19);
              if (*(void *)(v7 + 168))
              {
                boringssl_session_update_metadata(v6);
                int v20 = (id)v7;
                id v21 = objc_loadWeakRetained((id *)(v7 + 16));
                if (!v21
                  || (unsigned int v22 = v21,
                      unsigned int v23 = objc_loadWeakRetained((id *)(v7 + 16)),
                      char v24 = v23[475],
                      v23,
                      v22,
                      (v24 & 1) == 0))
                {
                  id v25 = objc_loadWeakRetained((id *)(v7 + 16));
                  if (v25)
                  {
                    unint64_t v26 = objc_loadWeakRetained((id *)(v7 + 16));
                    BOOL v27 = (v26[475] & 1) == 0;
                  }

                  else
                  {
                    BOOL v27 = 1;
                  }

                  if (v27)
                  {
                    if (g_boringssl_log)
                    {
                      unsigned int v35 = (os_log_s *)(id)g_boringssl_log;
                      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                      {
                        id v36 = objc_loadWeakRetained((id *)(v7 + 16));
                        if (v36)
                        {
                          unint64_t v63 = (char *)objc_loadWeakRetained((id *)(v7 + 16));
                          int v64 = v63 + 391;
                        }

                        else
                        {
                          int v64 = &unk_1875F4C23;
                        }

                        id v40 = objc_loadWeakRetained((id *)(v7 + 16));
                        *(_DWORD *)buf = 136446978;
                        int v68 = "boringssl_context_new_session_handler";
                        __int16 v69 = 1024;
                        int v70 = 1486;
                        __int16 v71 = 2082;
                        unsigned int v72 = v64;
                        __int16 v73 = 2048;
                        id v74 = v40;
                        _os_log_impl( &dword_187560000,  v35,  OS_LOG_TYPE_DEFAULT,  "%{public}s(%d) %{public}s[%p] Asyncing for session update block",  buf,  0x26u);

                        if (v36) {
                      }
                        }
                    }
                  }
                }

                unint64_t v2 = v20[22];
                block[0] = MEMORY[0x1895F87A8];
                block[1] = 3221225472LL;
                block[2] = __boringssl_context_new_session_handler_block_invoke;
                block[3] = &unk_18A070400;
                unsigned int v41 = v20;
                unsigned int v42 = v41;
                id v66 = v41;
                int v43 = v41;
                if (v2)
                {
                  ++v41[63];
                  dispatch_async((dispatch_queue_t)v2, block);
                  int v43 = v66;
                }
              }

              if (*(void *)(v7 + 32))
              {
                id v44 = objc_loadWeakRetained((id *)(v7 + 16));
                if (!v44
                  || (int v45 = v44,
                      int v46 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v7 + 16)),
                      unint64_t v2 = v46[475],
                      v46,
                      v45,
                      (v2 & 1) == 0))
                {
                  id v47 = objc_loadWeakRetained((id *)(v7 + 16));
                  if (v47)
                  {
                    unsigned int v48 = objc_loadWeakRetained((id *)(v7 + 16));
                    unint64_t v2 = (v48[475] & 1) == 0;
                  }

                  else
                  {
                    unint64_t v2 = 1LL;
                  }

                  if ((_DWORD)v2)
                  {
                    if (g_boringssl_log)
                    {
                      int v49 = (os_log_s *)(id)g_boringssl_log;
                      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG)) {
                        boringssl_context_new_session_handler_cold_1(v7 + 16, v49);
                      }
                    }
                  }
                }

                boringssl_session_cache_push(*(void **)(v7 + 32), v19);
              }

              if (SSL_session_reused((uint64_t)v4) && *(void *)(v7 + 360))
              {
                id v50 = objc_loadWeakRetained((id *)(v7 + 16));
                if (!v50
                  || (unint64_t v51 = v50,
                      int v52 = objc_loadWeakRetained((id *)(v7 + 16)),
                      char v53 = v52[475],
                      v52,
                      v51,
                      (v53 & 1) == 0))
                {
                  id v54 = objc_loadWeakRetained((id *)(v7 + 16));
                  if (v54)
                  {
                    unsigned int v55 = objc_loadWeakRetained((id *)(v7 + 16));
                    BOOL v56 = (v55[475] & 1) == 0;
                  }

                  else
                  {
                    BOOL v56 = 1;
                  }

                  if (v56)
                  {
                    if (g_boringssl_log)
                    {
                      unint64_t v57 = (os_log_s *)(id)g_boringssl_log;
                      if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
                      {
                        id v58 = objc_loadWeakRetained((id *)(v7 + 16));
                        if (v58)
                        {
                          unint64_t v2 = (unint64_t)objc_loadWeakRetained((id *)(v7 + 16));
                          int v59 = (void *)(v2 + 391);
                        }

                        else
                        {
                          int v59 = &unk_1875F4C23;
                        }

                        id v61 = objc_loadWeakRetained((id *)(v7 + 16));
                        *(_DWORD *)buf = 136446978;
                        int v68 = "boringssl_context_new_session_handler";
                        __int16 v69 = 1024;
                        int v70 = 1502;
                        __int16 v71 = 2082;
                        unsigned int v72 = v59;
                        __int16 v73 = 2048;
                        id v74 = v61;
                        _os_log_impl( &dword_187560000,  v57,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Rebuilding session state for resumed session",  buf,  0x26u);

                        if (v58) {
                      }
                        }
                    }
                  }
                }

                boringssl_session_set_peer_verification_state_from_session(v6, a2);
              }
            }

            else
            {
              id v28 = objc_loadWeakRetained((id *)(v7 + 16));
              if (!v28
                || (unsigned int v29 = v28,
                    unsigned int v30 = objc_loadWeakRetained((id *)(v7 + 16)),
                    char v31 = v30[475],
                    v30,
                    v29,
                    (v31 & 1) == 0))
              {
                id v32 = objc_loadWeakRetained((id *)(v7 + 16));
                if (v32)
                {
                  int v33 = objc_loadWeakRetained((id *)(v7 + 16));
                  BOOL v34 = (v33[475] & 1) == 0;
                }

                else
                {
                  BOOL v34 = 1;
                }

                if (v34)
                {
                  if (g_boringssl_log)
                  {
                    int v37 = (os_log_s *)(id)g_boringssl_log;
                    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
                    {
                      id v38 = objc_loadWeakRetained((id *)(v7 + 16));
                      if (v38)
                      {
                        int v4 = (char *)objc_loadWeakRetained((id *)(v7 + 16));
                        int v39 = v4 + 391;
                      }

                      else
                      {
                        int v39 = &unk_1875F4C23;
                      }

                      id v60 = objc_loadWeakRetained((id *)(v7 + 16));
                      *(_DWORD *)buf = 136446978;
                      int v68 = "boringssl_context_new_session_handler";
                      __int16 v69 = 1024;
                      int v70 = 1477;
                      __int16 v71 = 2082;
                      unsigned int v72 = v39;
                      __int16 v73 = 2048;
                      id v74 = v60;
                      _os_log_impl( &dword_187560000,  v37,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] boringssl_session_state_create failed",  buf,  0x26u);

                      if (v38) {
                    }
                      }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return 0LL;
}

boringssl_concrete_boringssl_session_state *boringssl_session_state_create(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = 0LL;
  if (a1 && a2)
  {
    int v5 = objc_alloc_init(&OBJC_CLASS___boringssl_concrete_boringssl_session_state);
    uint64_t v6 = v5;
    if (v5)
    {
      v5->cached_content_type = 1;
      v5->used_extended_unsigned __int8 master_secret = SSL_SESSION_used_extended_master_secret(a1);
      memcpy(&v6->remote_address, a2, *a2);
      if (SSL_SESSION_to_bytes(a1, &v6->serialized_session, &v6->serialized_session_length))
      {
        unint64_t v2 = v6;
LABEL_13:

        return v2;
      }

      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        boringssl_session_state_create_cold_2();
      }
    }

    else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      boringssl_session_state_create_cold_1();
    }

    unint64_t v2 = 0LL;
    goto LABEL_13;
  }

  return v2;
}

uint64_t SSL_SESSION_used_extended_master_secret(uint64_t a1)
{
  else {
    return 1LL;
  }
}

BOOL SSL_SESSION_to_bytes(uint64_t a1, void *a2, void *a3)
{
  if ((*(_BYTE *)(a1 + 440) & 4) != 0)
  {
    *a3 = 13LL;
    int8x8_t v8 = OPENSSL_memdup("NOT RESUMABLE", 0xDuLL);
    *a2 = v8;
    return v8 != 0LL;
  }

  else
  {
    *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10[1] = v6;
    __int128 v10[2] = v6;
    v10[0] = v6;
    CBB_zero(v10);
    BOOL v7 = CBB_init((uint64_t)v10, 0x100uLL)
    CBB_cleanup((uint64_t)v10);
  }

  return v7;
}

void sub_18758FDD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::SSL_SESSION_to_bytes_full(uint64_t result, uint64_t *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (!*(void *)(result + 200)) {
      return 0LL;
    }
    *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v23[1] = v6;
    v23[2] = v6;
    void v22[2] = v6;
    v23[0] = v6;
    v22[0] = v6;
    v22[1] = v6;
    v21[1] = v6;
    _OWORD v21[2] = v6;
    v21[0] = v6;
    uint64_t result = CBB_add_asn1(a2, (uint64_t)v23, 0x20000010u);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_asn1_uint64((uint64_t)v23, 1uLL);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_asn1_uint64((uint64_t)v23, *(unsigned __int16 *)(v3 + 4));
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 4u);
          if ((_DWORD)result)
          {
            uint64_t result = CBB_add_u16((uint64_t)v22, *(unsigned __int16 *)(*(void *)(v3 + 200) + 16LL));
            if ((_DWORD)result)
            {
              size_t v7 = a3 ? 0LL : *(unsigned __int8 *)(v3 + 59);
              uint64_t result = CBB_add_asn1_octet_string((uint64_t)v23, (const void *)(v3 + 60), v7);
              if ((_DWORD)result)
              {
                uint64_t result = CBB_add_asn1_octet_string((uint64_t)v23, (const void *)(v3 + 11), *(unsigned __int8 *)(v3 + 10));
                if ((_DWORD)result)
                {
                  uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000001);
                  if ((_DWORD)result)
                  {
                    uint64_t result = CBB_add_asn1_uint64((uint64_t)v22, *(void *)(v3 + 192));
                    if ((_DWORD)result)
                    {
                      uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000002);
                      if ((_DWORD)result)
                      {
                        uint64_t result = CBB_add_asn1_uint64((uint64_t)v22, *(unsigned int *)(v3 + 184));
                        if ((_DWORD)result)
                        {
                          if (!EVP_MD_CTX_md(*(const EVP_MD_CTX **)(v3 + 136))
                            || (*(_BYTE *)(v3 + 440) & 2) != 0
                            || (int8x8_t v8 = OPENSSL_sk_value(*(unint64_t **)(v3 + 136), 0LL),
                                uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000003),
                                (_DWORD)result)
                            && (uint64_t v9 = (const void *)CRYPTO_BUFFER_data((uint64_t)v8),
                                size_t v10 = CRYPTO_BUFFER_len((uint64_t)v8),
                                uint64_t result = CBB_add_bytes((uint64_t)v22, v9, v10),
                                (_DWORD)result))
                          {
                            uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000004);
                            if ((_DWORD)result)
                            {
                              uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  (const void *)(v3 + 93),  *(unsigned __int8 *)(v3 + 92));
                              if ((_DWORD)result)
                              {
                                if (!*(void *)(v3 + 176)
                                  || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000005), (_DWORD)result)
                                  && (uint64_t result = CBB_add_asn1_uint64((uint64_t)v22, *(void *)(v3 + 176)), (_DWORD)result))
                                {
                                  if (!*(void *)(v3 + 128)
                                    || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000008), (_DWORD)result)
                                    && (size_t v11 = strlen(*(const char **)(v3 + 128)),
                                        uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  *(const void **)(v3 + 128),  v11),  (_DWORD)result))
                                  {
                                    if (!*(_DWORD *)(v3 + 372)
                                      || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000009), (_DWORD)result)
                                      && (uint64_t result = CBB_add_asn1_uint64((uint64_t)v22, *(unsigned int *)(v3 + 372)),
                                          (_DWORD)result))
                                    {
                                      if (a3
                                        || !*(void *)(v3 + 240)
                                        || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000A),
                                            (_DWORD)result)
                                        && (uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  *(const void **)(v3 + 232),  *(void *)(v3 + 240)),  (_DWORD)result))
                                      {
                                        if ((*(_BYTE *)(v3 + 440) & 2) == 0
                                          || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000D),
                                              (_DWORD)result)
                                          && (uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  (const void *)(v3 + 272),  0x20uLL),  (_DWORD)result))
                                        {
                                          if (!*(_BYTE *)(v3 + 368)
                                            || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000E),
                                                (_DWORD)result)
                                            && (uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  (const void *)(v3 + 304),  *(unsigned __int8 *)(v3 + 368)),  (_DWORD)result))
                                          {
                                            if (!*(void *)(v3 + 248)
                                              || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA000000F),
                                                  (_DWORD)result)
                                              && (id v12 = (const void *)CRYPTO_BUFFER_data(*(void *)(v3 + 248)),
                                                  size_t v13 = CRYPTO_BUFFER_len(*(void *)(v3 + 248)),
                                                  uint64_t result = CBB_add_asn1_octet_string((uint64_t)v22, v12, v13),
                                                  (_DWORD)result))
                                            {
                                              if (!*(void *)(v3 + 256)
                                                || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000010),
                                                    (_DWORD)result)
                                                && (BOOL v14 = (const void *)CRYPTO_BUFFER_data(*(void *)(v3 + 256)),
                                                    size_t v15 = CRYPTO_BUFFER_len(*(void *)(v3 + 256)),
                                                    uint64_t result = CBB_add_asn1_octet_string((uint64_t)v22, v14, v15),
                                                    (_DWORD)result))
                                              {
                                                if ((*(_BYTE *)(v3 + 440) & 1) == 0
                                                  || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000011),
                                                      (_DWORD)result)
                                                  && (uint64_t result = CBB_add_asn1_BOOL((uint64_t)v22, 1), (_DWORD)result))
                                                {
                                                  if (!*(_WORD *)(v3 + 6)
                                                    || (uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000012),
                                                        (_DWORD)result)
                                                    && (uint64_t result = CBB_add_asn1_uint64( (uint64_t)v22,  *(unsigned __int16 *)(v3 + 6)),  (_DWORD)result))
                                                  {
                                                    id v16 = *(const EVP_MD_CTX **)(v3 + 136);
                                                    if (v16
                                                      && (*(_BYTE *)(v3 + 440) & 2) == 0
                                                      && (unint64_t)EVP_MD_CTX_md(v16) >= 2)
                                                    {
                                                      uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000013);
                                                      if (!(_DWORD)result) {
                                                        return result;
                                                      }
                                                      if ((unint64_t)EVP_MD_CTX_md(*(const EVP_MD_CTX **)(v3 + 136)) >= 2)
                                                      {
                                                        unint64_t v17 = 1LL;
                                                        do
                                                        {
                                                          id v18 = OPENSSL_sk_value(*(unint64_t **)(v3 + 136), v17);
                                                          unint64_t v19 = (const void *)CRYPTO_BUFFER_data((uint64_t)v18);
                                                          size_t v20 = CRYPTO_BUFFER_len((uint64_t)v18);
                                                          uint64_t result = CBB_add_bytes((uint64_t)v22, v19, v20);
                                                          if (!(_DWORD)result) {
                                                            return result;
                                                          }
                                                        }

                                                        while (++v17 < (unint64_t)EVP_MD_CTX_md(*(const EVP_MD_CTX **)(v3 + 136)));
                                                      }
                                                    }

                                                    if ((*(_BYTE *)(v3 + 440) & 8) != 0)
                                                    {
                                                      uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000015);
                                                      if (!(_DWORD)result) {
                                                        return result;
                                                      }
                                                      uint64_t result = CBB_add_asn1((uint64_t *)v22, (uint64_t)v21, 4u);
                                                      if (!(_DWORD)result) {
                                                        return result;
                                                      }
                                                      uint64_t result = CBB_add_u32((uint64_t)v21, *(_DWORD *)(v3 + 376));
                                                      if (!(_DWORD)result) {
                                                        return result;
                                                      }
                                                      if ((*(_BYTE *)(v3 + 440) & 0x10) != 0) {
                                                        goto LABEL_73;
                                                      }
                                                    }

                                                    else if ((*(_BYTE *)(v3 + 440) & 0x10) != 0)
                                                    {
LABEL_73:
                                                      if (!*(_WORD *)(v3 + 8)
                                                        || (uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA0000017),  (_DWORD)result)
                                                        && (uint64_t result = CBB_add_asn1_uint64( (uint64_t)v22,  *(unsigned __int16 *)(v3 + 8)),  (_DWORD)result))
                                                      {
                                                        if (!*(_DWORD *)(v3 + 380)
                                                          || (uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA0000018),  (_DWORD)result)
                                                          && (uint64_t result = CBB_add_asn1_uint64( (uint64_t)v22,  *(unsigned int *)(v3 + 380)),  (_DWORD)result))
                                                        {
                                                          if (*(_DWORD *)(v3 + 184) == *(_DWORD *)(v3 + 188)
                                                            || (uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA0000019),  (_DWORD)result)
                                                            && (uint64_t result = CBB_add_asn1_uint64( (uint64_t)v22,  *(unsigned int *)(v3 + 188)),  (_DWORD)result))
                                                          {
                                                            if (!*(void *)(v3 + 400)
                                                              || (uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA000001A),  (_DWORD)result)
                                                              && (uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  *(const void **)(v3 + 392),  *(void *)(v3 + 400)),  (_DWORD)result))
                                                            {
                                                              if ((*(_BYTE *)(v3 + 440) & 0x20) == 0
                                                                || (uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA000001B),  (_DWORD)result)
                                                                && (uint64_t result = CBB_add_asn1_BOOL((uint64_t)v22, 1),
                                                                    (_DWORD)result))
                                                              {
                                                                if (!*(void *)(v3 + 456)
                                                                  || (uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA000001C),  (_DWORD)result)
                                                                  && (uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  *(const void **)(v3 + 448),  *(void *)(v3 + 456)),  (_DWORD)result))
                                                                {
                                                                  if ((*(_BYTE *)(v3 + 440) & 0x40) == 0) {
                                                                    return CBB_flush(a2);
                                                                  }
                                                                  uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA000001D);
                                                                  if ((_DWORD)result)
                                                                  {
                                                                    uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  *(const void **)(v3 + 408),  *(void *)(v3 + 416));
                                                                    if ((_DWORD)result)
                                                                    {
                                                                      uint64_t result = CBB_add_asn1( (uint64_t *)v23,  (uint64_t)v22,  0xA000001E);
                                                                      if ((_DWORD)result)
                                                                      {
                                                                        uint64_t result = CBB_add_asn1_octet_string( (uint64_t)v22,  *(const void **)(v3 + 424),  *(void *)(v3 + 432));
                                                                        if ((_DWORD)result) {
                                                                          return CBB_flush(a2);
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }

                                                      return result;
                                                    }

                                                    uint64_t result = CBB_add_asn1((uint64_t *)v23, (uint64_t)v22, 0xA0000016);
                                                    if (!(_DWORD)result) {
                                                      return result;
                                                    }
                                                    uint64_t result = CBB_add_asn1_BOOL((uint64_t)v22, 0);
                                                    if (!(_DWORD)result) {
                                                      return result;
                                                    }
                                                    goto LABEL_73;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t CBB_add_asn1_uint64(uint64_t a1, unint64_t a2)
{
  return CBB_add_asn1_uint64_with_tag(a1, a2, 2u);
}

uint64_t CBB_add_asn1_uint64_with_tag(uint64_t a1, unint64_t a2, unsigned int a3)
{
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v5;
  __int128 v10[2] = v5;
  v10[0] = v5;
  if (!CBB_add_asn1((uint64_t *)a1, (uint64_t)v10, a3))
  {
LABEL_13:
    uint64_t v9 = (uint64_t *)(a1 + 16);
    if (*(_BYTE *)(a1 + 8)) {
      uint64_t v9 = (uint64_t *)*v9;
    }
    uint64_t result = 0LL;
    *((_BYTE *)v9 + 24) |= 2u;
    *(void *)a1 = 0LL;
    return result;
  }

  uint64_t v6 = 0LL;
  char v7 = 1;
  do
  {
    while ((v7 & 1) == 0)
    {
LABEL_7:
      char v7 = 0;
      if (++v6 == 8) {
        return CBB_flush((uint64_t *)a1);
      }
    }

    if ((a2 >> (56 - 8 * v6)))
    {
      goto LABEL_7;
    }

    ++v6;
    char v7 = 1;
  }

  while (v6 != 8);
  return CBB_flush((uint64_t *)a1);
}

uint64_t CBB_add_asn1_octet_string(uint64_t a1, const void *a2, size_t a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v6;
  __int128 v9[2] = v6;
  v9[0] = v6;
  if (CBB_add_asn1((uint64_t *)a1, (uint64_t)v9, 4u)
    && CBB_add_bytes((uint64_t)v9, a2, a3)
    && CBB_flush((uint64_t *)a1))
  {
    return 1LL;
  }

  int8x8_t v8 = (uint64_t *)(a1 + 16);
  if (*(_BYTE *)(a1 + 8)) {
    int8x8_t v8 = (uint64_t *)*v8;
  }
  uint64_t result = 0LL;
  *((_BYTE *)v8 + 24) |= 2u;
  *(void *)a1 = 0LL;
  return result;
}

uint64_t CBB_add_u32(uint64_t a1, unsigned int a2)
{
  return cbb_add_u(a1, a2, 4uLL);
}

uint64_t CBB_add_asn1_BOOL(uint64_t a1, int a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v4;
  v8[2] = v4;
  v8[0] = v4;
  if (CBB_add_asn1((uint64_t *)a1, (uint64_t)v8, 1u))
  {
    unint64_t v5 = a2 ? 255LL : 0LL;
  }

  char v7 = (uint64_t *)(a1 + 16);
  if (*(_BYTE *)(a1 + 8)) {
    char v7 = (uint64_t *)*v7;
  }
  uint64_t result = 0LL;
  *((_BYTE *)v7 + 24) |= 2u;
  *(void *)a1 = 0LL;
  return result;
}

void boringssl_session_cache_push(void *a1, void *a2)
{
  id v8 = a1;
  id v3 = a2;
  if (v8 && v3)
  {
    id v4 = boringssl_session_cache_copy_queue();
    if (!v4)
    {
      unint64_t v5 = (void *)sec_array_create();
      if (!v5)
      {
        id v4 = 0LL;
LABEL_9:

        goto LABEL_10;
      }

      id v4 = v5;
    }

    sec_array_append();
    id v6 = nw_protocol_boringssl_copy_definition();
    time(0LL);
    nw_association_set_cached_content_for_protocol();

    goto LABEL_9;
  }

uint64_t __boringssl_session_cache_pop_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  if (a2) {
    sec_array_append();
  }
  else {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
  }

  return 1LL;
}

void nw_protocol_boringssl_cache_entry_deallocator(uint64_t a1, void *a2)
{
  if (a2) {
}
  }

uint64_t nw_protocol_boringssl_get_output_frames(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    return 0LL;
  }
  LODWORD(v_Block_object_dispose(va, 8) = a4;
  if ((*(_BYTE *)(v6 + 475) & 1) == 0)
  {
    if (datapath_logging_enabled)
    {
      if (g_boringssl_log)
      {
        int v18 = a5;
        BOOL v16 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
        a5 = v18;
        if (v16)
        {
          nw_protocol_boringssl_get_output_frames_cold_6();
          a5 = v18;
        }
      }
    }
  }

  uint64_t v10 = 0LL;
  if (a5 && a6)
  {
    if ((*(_BYTE *)(v6 + 388) & 0x20) != 0)
    {
      if ((*(_BYTE *)(v6 + 475) & 1) == 0
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_get_output_frames_cold_5();
      }

      return 0LL;
    }

    int state = boringssl_session_get_state(*(void *)(v6 + 336));
    char v12 = boringssl_session_in_early_data(*(void *)(v6 + 336));
    if (state == 2 || (v12 & 1) != 0)
    {
      if ((*(_BYTE *)(v6 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          unint64_t v17 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136447490;
              size_t v20 = "nw_protocol_boringssl_get_output_frames";
              __int16 v21 = 1024;
              int v22 = 1717;
              __int16 v23 = 2082;
              uint64_t v24 = v6 + 391;
              __int16 v25 = 2048;
              uint64_t v26 = v6;
              __int16 v27 = 1024;
              int v28 = a3;
              __int16 v29 = 1024;
              int v30 = v8;
              _os_log_debug_impl( &dword_187560000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] get output frames min bytes %u max bytes %u",  buf,  0x32u);
            }
          }
        }
      }

      nw_frame_array_init();
      else {
        size_t v8 = v8;
      }
      if ((*(_BYTE *)(v6 + 389) & 0x10) != 0)
      {
        external = (void *)nw_frame_create_external();
        if (!external)
        {
          if ((*(_BYTE *)(v6 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_get_output_frames_cold_3();
          }

          return 0LL;
        }
      }

      else
      {
        if ((_DWORD)v8 && !malloc(v8))
        {
          if ((*(_BYTE *)(v6 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_get_output_frames_cold_2();
          }

          return 0LL;
        }

        external = (void *)nw_frame_create();
        if (!external)
        {
          if ((*(_BYTE *)(v6 + 475) & 1) == 0
            && g_boringssl_log
            && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            nw_protocol_boringssl_get_output_frames_cold_1();
          }

          return 0LL;
        }
      }

      id v15 = external;
      nw_frame_array_append();
      uint64_t v10 = 1LL;
      nw_frame_array_append();

      return v10;
    }

    if ((*(_BYTE *)(v6 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_get_output_frames_cold_4();
    }

    return 0LL;
  }

  return v10;
}

uint64_t nw_protocol_boringssl_finalize_output_frames(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *(_BYTE **)(a1 + 40);
  if (!v1) {
    return 0LL;
  }
  char v2 = v1[475];
  if ((v2 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
  {
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG)) {
      nw_protocol_boringssl_finalize_output_frames_cold_2();
    }
    char v2 = v1[475];
  }

  if ((v2 & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_finalize_output_frames_cold_1();
  }

  uint64_t v3 = 1LL;
  nw_frame_array_append_array();
  nw_protocol_boringssl_write_frames(v1);
  return v3;
}

void nw_protocol_boringssl_write_frames(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if ((v1[475] & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_write_frames_cold_3();
  }

  if ((nw_frame_array_is_empty() & 1) == 0)
  {
    if ((v1[390] & 8) == 0)
    {
      v1[390] |= 8u;
      nw_frame_array_first();
      char v2 = (void *)objc_claimAutoreleasedReturnValue();
      nw_frame_array_next();
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v4 = v3 == 0LL;

      if (!v4)
      {
        unsigned int v5 = nw_frame_array_unclaimed_length();
        if (*((void *)v1 + 22))
        {
          unsigned int v6 = nw_frame_unclaimed_length();
          unsigned int v7 = v5 - v6;
          if (v5 < v6)
          {
            if ((v1[475] & 1) == 0
              && g_boringssl_log
              && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_FAULT))
            {
              nw_protocol_boringssl_write_frames_cold_1();
            }

            goto LABEL_24;
          }

          int v8 = *((_DWORD *)v1 + 46);
          unsigned int v5 = v7 + v8;
          if (__CFADD__(v7, v8))
          {
            if ((v1[475] & 1) == 0)
            {
              uint64_t v9 = (os_log_s *)g_boringssl_log;
              if (g_boringssl_log)
              {
                if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_FAULT))
                {
                  int v10 = *((_DWORD *)v1 + 46);
                  *(_DWORD *)buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_protocol_boringssl_write_frames";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 970;
                  *(_WORD *)&_BYTE buf[18] = 2082;
                  *(void *)&buf[20] = v1 + 391;
                  __int16 v18 = 2048;
                  unint64_t v19 = v1;
                  __int16 v20 = 1024;
                  unsigned int v21 = v5;
                  __int16 v22 = 1024;
                  int v23 = v10;
                  _os_log_fault_impl( &dword_187560000,  v9,  OS_LOG_TYPE_FAULT,  "%{public}s(%d) %{public}s[%p] unable to write frame array of length %u and pending buffer %u",  buf,  0x32u);
                }
              }
            }

            goto LABEL_24;
          }
        }

        alloc = (void *)dispatch_data_create_alloc();
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&unsigned __int8 buf[16] = 0x2020000000LL;
        *(_DWORD *)&buf[24] = 0;
        id v15 = v1;
        id v16 = v2;
        nw_frame_array_foreach();
        char v12 = (void *)v15[21];
        v15[21] = alloc;
        id v13 = alloc;

        *((void *)v1 + 22) = 0LL;
        *((_DWORD *)v15 + 46) = v5;

        _Block_object_dispose(buf, 8);
      }

      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&unsigned __int8 buf[16] = 0x2020000000LL;
      buf[24] = 1;
      BOOL v14 = v1;
      nw_frame_array_foreach();
      v1[390] &= ~8u;
      v14[388] = (v14[388] & 0xDF | (32 * *(_BYTE *)(*(void *)&buf[8] + 24LL))) ^ 0x20;

      _Block_object_dispose(buf, 8);
LABEL_24:

      goto LABEL_25;
    }

    if ((v1[475] & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_write_frames_cold_2();
    }
  }

LABEL_25:
}

      uint64_t result = 0LL;
      break;
  }

  return result;
}

  OPENSSL_free(__s2);
  return v16;
}

  return v10;
}

            goto LABEL_26;
          }
        }

        if (!v13) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }

    id v16 = 0LL;
    unint64_t v17 = 1;
    goto LABEL_22;
  }

        *(void *)&int v28 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[1] = v28;
        __b[0] = v28;
        x25519_ge_tobytes(__b, (uint64_t)v29);
        return CRYPTO_memcmp((char *)__b, (char *)v62, 32LL) == 0;
      }
    }

    while (v11 != -32);
  }

  return 0LL;
}

void sub_187591050( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t __nw_protocol_boringssl_write_frames_block_invoke(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  int v4 = nw_frame_uses_external_data();
  uint64_t v5 = a1[4];
  unsigned int v6 = *(const void **)(v5 + 176);
  if (v6)
  {
    memcpy((void *)(a1[7] + *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL)), v6, *(unsigned int *)(v5 + 184));
    *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) += *(_DWORD *)(a1[4] + 184LL);
    uint64_t v7 = a1[4];
    int v8 = *(void **)(v7 + 168);
    *(void *)(v7 + 16_Block_object_dispose(va, 8) = 0LL;

    *(void *)(a1[4] + 176LL) = 0LL;
    *(_DWORD *)(a1[4] + 184LL) = 0;
  }

  else if (v4)
  {
    __int128 __src = 0LL;
    nw_frame_get_external_data();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    int v10 = v9;
    if (v9)
    {
      id v11 = nw_dispatch_data_create_subrange_map(v9, 0LL, 0LL, &__src);
      if (v11)
      {
        *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) = *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
      }

      else
      {
        uint64_t v12 = a1[4];
        if (!v12 || (*(_BYTE *)(v12 + 475) & 1) == 0)
        {
          id v13 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            {
              uint64_t v15 = a1[4];
              id v16 = (void *)(v15 + 391);
              if (!v15) {
                id v16 = &unk_1875F4C23;
              }
              v18[0] = 136447746;
              *(void *)&v18[1] = "nw_protocol_boringssl_write_frames_block_invoke";
              __int16 v19 = 1024;
              int v20 = 1002;
              __int16 v21 = 2082;
              __int16 v22 = v16;
              __int16 v23 = 2048;
              uint64_t v24 = v15;
              __int16 v25 = 2112;
              uint64_t v26 = v10;
              __int16 v27 = 1024;
              int v28 = 0;
              __int16 v29 = 1024;
              int v30 = 0;
              _os_log_error_impl( &dword_187560000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Failed to flatten external data %@ (offset %u, unclaimed %u)",  (uint8_t *)v18,  0x3Cu);
            }
          }
        }
      }
    }
  }

  else
  {
    v18[0] = 0;
    nw_frame_unclaimed_bytes();
    *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) = *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
  }

  if ((id)a1[5] != v3)
  {
    nw_frame_array_remove();
    nw_frame_finalize();
  }

  return 1LL;
}

uint64_t __nw_dispatch_data_create_subrange_map_block_invoke( void *a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  id v10 = a2;
  unint64_t v11 = a1[8];
  if (a5 + a3 > v11)
  {
    size_t v12 = a1[9];
    size_t v13 = v12 + v11;
    if (v12 + v11 > a3)
    {
      BOOL v14 = v11 >= a3;
      unint64_t v15 = v11 - a3;
      if (v11 > a3) {
        a3 = a1[8];
      }
      if (!v14) {
        unint64_t v15 = 0LL;
      }
      id v16 = (const void *)(a4 + v15);
      size_t v17 = a5 - v15;
      uint64_t v18 = *(void *)(a1[4] + 8LL);
      uint64_t v20 = *(void *)(v18 + 40);
      __int16 v19 = (id *)(v18 + 40);
      if (v20) {
        goto LABEL_8;
      }
      if (v17 >= v12)
      {
        objc_storeStrong(v19, a2);
        uint64_t v22 = 0LL;
        *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = a1[9];
        *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = v16;
        goto LABEL_17;
      }

      uint64_t alloc = dispatch_data_create_alloc();
      uint64_t v24 = *(void *)(a1[4] + 8LL);
      __int16 v25 = *(void **)(v24 + 40);
      *(void *)(v24 + 40) = alloc;

      if (*(void *)(*(void *)(a1[4] + 8LL) + 40LL))
      {
        *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
        unint64_t v11 = a1[8];
        size_t v13 = a1[9] + v11;
LABEL_8:
        if (v17 + a3 <= v13) {
          size_t v21 = v17;
        }
        else {
          size_t v21 = v13 - a3;
        }
        memcpy((void *)(*(void *)(*(void *)(a1[7] + 8LL) + 24LL) + a3 - v11), v16, v21);
        *(void *)(*(void *)(a1[5] + 8LL) + 24LL) += v21;
        goto LABEL_12;
      }
    }

    uint64_t v22 = 0LL;
    goto LABEL_17;
  }

uint64_t boringssl_session_write(void *a1, const void *a2, int a3)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v4 = a1[1];
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  if (a3)
  {
    if (a2)
    {
      unsigned int v6 = *(SSL **)(v4 + 400);
      if (v6)
      {
        uint64_t v5 = SSL_write(v6, a2, a3);
        if ((int)v5 <= 0)
        {
          uint64_t error = SSL_get_error(*(const SSL **)(v4 + 400), v5);
          id WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
          if (!WeakRetained
            || (uint64_t v9 = WeakRetained,
                id v10 = objc_loadWeakRetained((id *)(v4 + 16)),
                char v11 = v10[475],
                v10,
                v9,
                (v11 & 1) == 0))
          {
            id v12 = objc_loadWeakRetained((id *)(v4 + 16));
            if (v12)
            {
              size_t v13 = objc_loadWeakRetained((id *)(v4 + 16));
              char v14 = v13[475] & 1;
            }

            else
            {
              char v14 = 0;
            }

            if ((v14 & 1) == 0 && datapath_logging_enabled && g_boringssl_log)
            {
              id v16 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
                boringssl_session_write_cold_1(v4, error, v16);
              }
            }
          }

          if ((_DWORD)error == 3) {
            ++*(void *)(v4 + 488);
          }
          else {
            ERR_print_errors_cb( (int (__cdecl *)(const char *, size_t, void *))boringssl_session_handshake_error_print,  a1);
          }
        }
      }
    }
  }

  return v5;
}

int SSL_write(SSL *ssl, const void *buf, int num)
{
  *((_DWORD *)ssl->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (*(void *)&ssl->hit)
  {
    int v6 = 66;
    int v7 = 1340;
LABEL_3:
    ERR_put_error(16, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v7);
    return -1;
  }

  if (!*(void *)&ssl->rwstate)
  {
    int v6 = 226;
    int v7 = 1345;
    goto LABEL_3;
  }

  uint64_t v11 = 0LL;
  char v10 = 0;
  do
  {
    uint64_t v9 = *((void *)ssl->handshake_func + 35);
    if (v9 && (*(_WORD *)(v9 + 1584) & 0x2008) == 0)
    {
      int result = SSL_do_handshake(ssl);
      if (result < 0) {
        return result;
      }
      if (!result)
      {
        int v6 = 215;
        int v7 = 1360;
        goto LABEL_3;
      }
    }

    if (num < 0)
    {
      int v6 = 111;
      int v7 = 1366;
      goto LABEL_3;
    }

    int result = (*(uint64_t (**)(SSL *, char *, uint64_t *, const void *, void))(*(void *)&ssl->version + 72LL))( ssl,  &v10,  &v11,  buf,  num);
  }

  while (v10);
  if (result >= 1) {
    return v11;
  }
  return result;
}

uint64_t bssl::tls_write_app_data( uint64_t a1, ssl_st *a2, unint64_t *a3, uint64_t a4, unint64_t a5)
{
  if ((bssl::ssl_can_write((bssl *)a1, a2) & 1) == 0) {
    bssl::tls_write_app_data();
  }
  uint64_t v10 = *(void *)(a1 + 48);
  if (!**(void **)(v10 + 272)) {
    bssl::tls_write_app_data();
  }
  LOBYTE(a2->version) = 0;
  if (*(_DWORD *)(v10 + 176))
  {
    int v11 = 194;
    int v12 = 140;
    goto LABEL_7;
  }

  unint64_t v13 = *(void *)(v10 + 144);
  unint64_t v14 = a5 - v13;
  if (a5 < v13)
  {
    int v11 = 111;
    int v12 = 152;
LABEL_7:
    ERR_put_error(16, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", v12);
    return 0xFFFFFFFFLL;
  }

  unint64_t v16 = a4 + v13;
  else {
    int v17 = (*(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 280LL) + 1585LL) >> 5) & 1;
  }
  while (1)
  {
    unint64_t v18 = *(unsigned __int16 *)(a1 + 18);
    if (v17)
    {
      uint64_t v19 = *(void *)(a1 + 48);
      uint64_t v20 = *(void *)(v19 + 280);
      unsigned int v21 = *(unsigned __int16 *)(v20 + 1592);
      unsigned int v22 = *(_DWORD *)(*(void *)(v20 + 1528) + 380LL);
      BOOL v23 = v22 >= v21;
      unint64_t v24 = v22 - v21;
      if ((_DWORD)v24 == 0 || !v23)
      {
        *(void *)(v19 + CBB_cleanup(v1 - 144) = v13;
        *(_DWORD *)(v20 + 1584) &= ~0x2000u;
        LOBYTE(a2->version) = 1;
        return 0xFFFFFFFFLL;
      }

      if (v24 < v18) {
        unint64_t v18 = v24;
      }
    }

    __int16 v25 = (const unsigned __int8 *)(v14 >= v18 ? v18 : v14);
    unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = bssl::do_tls_write((bssl *)a1, (ssl_st *)&v27, (ssl_st *)0x17, v16, v25);
    unint64_t v26 = v27;
    if (v17) {
      *(_WORD *)(*(void *)(*(void *)(a1 + 48) + 280LL) + 1592LL) += v27;
    }
    v13 += v26;
    v14 -= v26;
    if (!v14 || (*(_BYTE *)(a1 + 148) & 1) != 0)
    {
      *(void *)(*(void *)(a1 + 48) + 144LL) = 0LL;
      *a3 = v13;
      return result;
    }

    v16 += v26;
  }

  *(void *)(*(void *)(a1 + 48) + 144LL) = v13;
  return result;
}

uint64_t bssl::ssl_can_write(bssl *this, const ssl_st *a2)
{
  uint64_t v2 = *(void *)(*((void *)this + 6) + 280LL);
  if (!v2) {
    return 1LL;
  }
  unsigned int v3 = *(_DWORD *)(v2 + 1584);
  if ((v3 & 8) != 0) {
    return 1LL;
  }
  else {
    return (v3 >> 13) & 1;
  }
}

uint64_t bssl::do_tls_write( bssl *this, ssl_st *a2, ssl_st *a3, unint64_t a4, const unsigned __int8 *a5)
{
  uint64_t v10 = *((void *)this + 6);
  unint64_t v11 = *(void *)(v10 + 160);
  if (v11
    && (v11 > (unint64_t)a5
     || (*((_BYTE *)this + 148) & 2) == 0 && *(void *)(v10 + 152) != a4
     || *(unsigned __int8 *)(v10 + 168) != (_DWORD)a3))
  {
    int v16 = 118;
    int v17 = 212;
LABEL_10:
    ERR_put_error(16, 0, v16, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", v17);
    return 0xFFFFFFFFLL;
  }

  uint64_t result = bssl::ssl_write_buffer_flush(this, a2);
  uint64_t v14 = *((void *)this + 6);
  uint64_t v15 = *(void *)(v14 + 160);
  if (v15)
  {
    *(void *)&a2->version = v15;
    uint64_t result = 1LL;
    *(void *)(v14 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = 0LL;
    *(void *)(v14 + 160) = 0LL;
    return result;
  }

  if ((unint64_t)a5 > 0x4000 || *(_WORD *)(v14 + 116))
  {
    int v16 = 68;
    int v17 = 232;
    goto LABEL_10;
  }

  uint64_t v19 = *((void *)this + 6);
  uint64_t v20 = *(void **)(v19 + 240);
  if (v20)
  {
    unint64_t v21 = *(unsigned int *)(v19 + 248);
    size_t v22 = *v20 - v21;
    if (*v20 < v21) {
      abort();
    }
    BOOL v23 = (const void *)(v20[1] + v21);
  }

  else
  {
    size_t v22 = 0LL;
    BOOL v23 = 0LL;
  }

  unint64_t v24 = v22;
  if (a5)
  {
    uint64_t v25 = SSL_max_seal_overhead((uint64_t)this);
    unint64_t v26 = &a5[v25];
    BOOL v27 = __CFADD__(v25, a5);
    unint64_t v24 = (unint64_t)&v26[v22];
    BOOL v28 = __CFADD__(v26, v22);
    if (v27 || v28)
    {
      int v16 = 69;
      int v17 = 256;
      goto LABEL_10;
    }
  }

  if (!v24)
  {
    *(void *)&a2->version = 0LL;
    return 1LL;
  }

  int v29 = bssl::ssl_seal_align_prefix_len((unsigned __int8 **)this, v18);
  if (v22)
  {
    memcpy( (void *)(*(void *)(v14 + 104) + *(unsigned __int16 *)(v14 + 112) + *(unsigned __int16 *)(v14 + 116)),  v23,  v22);
    std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100]( (BUF_MEM **)(*((void *)this + 6) + 240LL),  0LL);
    *(_DWORD *)(*((void *)this + 6) + 248LL) = 0;
    bssl::SSLBuffer::DidWrite(v14 + 104, v22);
  }

  if (a5)
  {
    *(void *)id v32 = 0xAAAAAAAAAAAAAAAALL;
    if (!bssl::tls_seal_record( this,  (ssl_st *)(*(void *)(v14 + 104)
                                   + *(unsigned __int16 *)(v14 + 112)
                                   + *(unsigned __int16 *)(v14 + 116)),
                          v32,
                          (const unsigned __int8 *)(*(unsigned __int16 *)(v14 + 118)
                                                  - (unint64_t)*(unsigned __int16 *)(v14 + 116)),
                          a3,
                          a4,
                          a5))
      return 0xFFFFFFFFLL;
    bssl::SSLBuffer::DidWrite(v14 + 104, *(unint64_t *)v32);
  }

  *(_WORD *)(*((void *)this + 6) + 220LL) &= ~0x200u;
  uint64_t result = bssl::ssl_write_buffer_flush(this, v30);
  if ((int)result > 0)
  {
    *(void *)&a2->version = a5;
    return 1LL;
  }

  if (a5)
  {
    uint64_t v31 = *((void *)this + 6);
    *(void *)(v31 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = a4;
    *(void *)(v31 + 160) = a5;
    *(_BYTE *)(*((void *)this + 6) + 168LL) = (_BYTE)a3;
  }

  return result;
}

uint64_t bssl::ssl_write_buffer_flush(bssl *this, ssl_st *a2)
{
  if (!*((void *)this + 4))
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_buffer.cc", 322);
    return 0xFFFFFFFFLL;
  }

  int is_dtls = SSL_is_dtls((unsigned __int8 **)this);
  uint64_t v4 = *((void *)this + 6);
  if (is_dtls)
  {
    if (*(_WORD *)(v4 + 116))
    {
      uint64_t result = BIO_write( *((BIO **)this + 4),  (const void *)(*(void *)(v4 + 104) + *(unsigned __int16 *)(v4 + 112)),  *(unsigned __int16 *)(v4 + 116));
      else {
        uint64_t result = 1LL;
      }
      *(_WORD *)(v4 + 112) = *(_WORD *)(v4 + 114);
      *(_WORD *)(v4 + 116) = 0;
      *(_WORD *)(v4 + 11_Block_object_dispose(va, 8) = *(_WORD *)(v4 + 120);
      return result;
    }

    return 1LL;
  }

  unsigned __int16 v6 = *(_WORD *)(v4 + 116);
  if (!v6)
  {
LABEL_12:
    *(_WORD *)(v4 + 112) = *(_WORD *)(v4 + 114);
    *(_WORD *)(v4 + 116) = 0;
    *(_WORD *)(v4 + 11_Block_object_dispose(va, 8) = *(_WORD *)(v4 + 120);
    return 1LL;
  }

  unsigned __int16 v7 = *(_WORD *)(v4 + 112);
  while (1)
  {
    uint64_t result = BIO_write(*((BIO **)this + 4), (const void *)(*(void *)(v4 + 104) + v7), v6);
    unsigned int v8 = *(unsigned __int16 *)(v4 + 116);
    unsigned __int16 v7 = *(_WORD *)(v4 + 112) + result;
    *(_WORD *)(v4 + 112) = v7;
    unsigned __int16 v6 = v8 - result;
    *(_WORD *)(v4 + 116) = v6;
    *(_WORD *)(v4 + 118) -= result;
    if (!v6) {
      goto LABEL_12;
    }
  }

  *(_DWORD *)(*((void *)this + 6) + 196LL) = 3;
  return result;
}

uint64_t bssl::ssl_seal_align_prefix_len(unsigned __int8 **this, const ssl_st *a2)
{
  int is_dtls = SSL_is_dtls(this);
  uint64_t v4 = bssl::SSLAEADContext::ExplicitNonceLen(*((bssl::SSLAEADContext **)this[6] + 34));
  uint64_t v6 = v4;
  if (is_dtls) {
    return v4 + 13;
  }
  if (bssl::ssl_needs_record_splitting((bssl *)this, v5)) {
    return v6 + bssl::ssl_cipher_get_record_split_len(**((bssl ***)this[6] + 34), v8) + 10;
  }
  return v6 + 5;
}

uint64_t bssl::SSLBuffer::DidWrite(uint64_t this, unint64_t a2)
{
  uint64_t v2 = *(unsigned __int16 *)(this + 12);
  *(_WORD *)(this + 12) = v2 + a2;
  return this;
}

void nw_protocol_boringssl_frame_output_finalizer(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  id v5 = a3;
  uint64_t v6 = v5;
  if ((!v5 || (*((_BYTE *)v5 + 475) & 1) == 0)
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_frame_output_finalizer_cold_1();
  }

  if (v4 && v6)
  {
    nw_frame_array_remove();
    if (nw_frame_uses_external_data())
    {
      nw_frame_set_external_data();
    }

    else
    {
      buffer = (void *)nw_frame_get_buffer();
      if (buffer) {
        free(buffer);
      }
    }

    nw_frame_reset();
  }
}

uint64_t nw_protocol_boringssl_get_input_frames( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  uint64_t v35 = 0LL;
  id v36 = &v35;
  uint64_t v37 = 0x2020000000LL;
  int v38 = 0;
  if (!a1) {
    goto LABEL_17;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    goto LABEL_17;
  }
  if ((*(_BYTE *)(v6 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_get_input_frames_cold_2();
  }

  uint64_t v11 = 0LL;
  if (a4 && a5 && a6)
  {
    if ((boringssl_session_get_state(*(void *)(v6 + 336)) & 0xFFFFFFFE) == 2)
    {
      nw_frame_array_init();
      if ((*(_BYTE *)(v6 + 475) & 1) == 0)
      {
        if (datapath_logging_enabled)
        {
          uint64_t v20 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136447490;
              id v40 = "nw_protocol_boringssl_get_input_frames";
              __int16 v41 = 1024;
              int v42 = 1823;
              __int16 v43 = 2082;
              uint64_t v44 = v6 + 391;
              __int16 v45 = 2048;
              uint64_t v46 = v6;
              __int16 v47 = 1024;
              unsigned int v48 = a3;
              __int16 v49 = 1024;
              unsigned int v50 = a4;
              _os_log_debug_impl( &dword_187560000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] get input frames expected min bytes %u expected max bytes %u",  buf,  0x32u);
            }
          }
        }
      }

      int v12 = *(char *)(v6 + 388);
      *(_BYTE *)(v6 + 388) &= ~0x40u;
      uint64_t v13 = MEMORY[0x1895F87A8];
      if (v12 < 0)
      {
        *(_BYTE *)(v6 + 38_Block_object_dispose(va, 8) = v12 & 0x3F;
        id v14 = *(id *)(*(void *)(v6 + 336) + 8LL);
        uint64_t v30 = v13;
        uint64_t v31 = 3221225472LL;
        id v32 = __nw_protocol_boringssl_get_input_frames_block_invoke;
        int v33 = &unk_18A070400;
        id v34 = (id)v6;
        nw_queue_context_async();
      }

      uint64_t v26 = 0LL;
      BOOL v27 = &v26;
      uint64_t v28 = 0x2020000000LL;
      int v29 = 0;
      nw_frame_array_foreach();
      unsigned int v15 = *((_DWORD *)v27 + 6);
      if (v15 >= a3)
      {
        if ((*(_BYTE *)(v6 + 475) & 1) == 0)
        {
          if (datapath_logging_enabled)
          {
            unint64_t v21 = (os_log_s *)g_boringssl_log;
            if (g_boringssl_log)
            {
              if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
              {
                unsigned int v24 = *((_DWORD *)v36 + 6);
                unsigned int v25 = *((_DWORD *)v27 + 6);
                *(_DWORD *)buf = 136447490;
                id v40 = "nw_protocol_boringssl_get_input_frames";
                __int16 v41 = 1024;
                int v42 = 1908;
                __int16 v43 = 2082;
                uint64_t v44 = v6 + 391;
                __int16 v45 = 2048;
                uint64_t v46 = v6;
                __int16 v47 = 1024;
                unsigned int v48 = v24;
                __int16 v49 = 1024;
                unsigned int v50 = v25;
                _os_log_debug_impl( &dword_187560000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Returning %u frames (%u bytes) to input handler",  buf,  0x32u);
              }

              unsigned int v15 = *((_DWORD *)v27 + 6);
            }
          }
        }

        unsigned int v17 = *(_DWORD *)(v6 + 380);
        BOOL v18 = v17 >= v15;
        unsigned int v19 = v17 - v15;
        if (!v18) {
          unsigned int v19 = 0;
        }
        *(_DWORD *)(v6 + 380) = v19;
        uint64_t v11 = *((unsigned int *)v36 + 6);
      }

      else
      {
        if (*((_DWORD *)v36 + 6)) {
          nw_protocol_boringssl_prepend_frame_array();
        }
        nw_frame_array_init();
        if ((*(_BYTE *)(v6 + 475) & 1) == 0)
        {
          if (datapath_logging_enabled)
          {
            size_t v22 = (os_log_s *)g_boringssl_log;
            if (g_boringssl_log)
            {
              if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
              {
                unsigned int v23 = *((_DWORD *)v27 + 6);
                *(_DWORD *)buf = 136447490;
                id v40 = "nw_protocol_boringssl_get_input_frames";
                __int16 v41 = 1024;
                int v42 = 1904;
                __int16 v43 = 2082;
                uint64_t v44 = v6 + 391;
                __int16 v45 = 2048;
                uint64_t v46 = v6;
                __int16 v47 = 1024;
                unsigned int v48 = v23;
                __int16 v49 = 1024;
                unsigned int v50 = a3;
                _os_log_debug_impl( &dword_187560000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Not enough bytes in record to satisfy request (%u < %u)",  buf,  0x32u);
              }
            }
          }
        }

        uint64_t v11 = 0LL;
      }

      _Block_object_dispose(&v26, 8);
      goto LABEL_18;
    }

    if ((*(_BYTE *)(v6 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_get_input_frames_cold_1();
    }

LABEL_17:
    uint64_t v11 = 0LL;
  }

void sub_1875923D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

int SSL_read(SSL *ssl, void *buf, int num)
{
  unsigned int v4 = SSL_peek(ssl, buf, num);
  int v5 = v4;
  if ((int)v4 >= 1)
  {
    handshake_func = ssl->handshake_func;
    unint64_t v7 = *((void *)handshake_func + 17);
    if (v7 < v4) {
      abort();
    }
    *((void *)handshake_func + 16) += v4;
    *((void *)handshake_func + 17) = v7 - v4;
    unsigned int v8 = ssl->handshake_func;
    if (!*((void *)v8 + 17)) {
      bssl::SSLBuffer::DiscardConsumed((_WORD *)v8 + 40);
    }
  }

  return v5;
}

void nw_protocol_boringssl_frame_input_finalizer(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  id v5 = a3;
  uint64_t v6 = v5;
  if ((!v5 || (*((_BYTE *)v5 + 475) & 1) == 0)
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_frame_input_finalizer_cold_1();
  }

  if (v4 && v6)
  {
    nw_frame_array_remove();
    uint64_t buffer = nw_frame_get_buffer();
    if (buffer)
    {
      unsigned int v8 = (void *)buffer;
      if (nw_frame_buffer_get_manager()) {
        nw_mem_buffer_free();
      }
      else {
        free(v8);
      }
    }
  }
}

uint64_t nw_protocol_boringssl_disconnect(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 40);
    if (v2)
    {
      if ((*(_BYTE *)(v2 + 475) & 1) == 0
        && datapath_logging_enabled
        && g_boringssl_log
        && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        nw_protocol_boringssl_disconnect_cold_1();
      }

      uint64_t result = *(void *)(v2 + 336);
      if (result)
      {
        *(_BYTE *)(v2 + 388) &= ~0x20u;
        if (boringssl_session_get_state(result) <= 3)
        {
          boringssl_session_set_state(*(void *)(v2 + 336), 3);
          boringssl_session_disconnect(*(void *)(v2 + 336));
        }

        boringssl_session_set_state(*(void *)(v2 + 336), 4);
        uint64_t result = *(void *)(v1 + 32);
        if (result)
        {
          uint64_t v3 = *(void *)(result + 24);
          if (v3)
          {
            id v4 = *(uint64_t (**)(void))(v3 + 32);
            if (v4) {
              return v4();
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t boringssl_session_disconnect(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(SSL **)(v2 + 400);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  int v4 = SSL_shutdown(v3);
  if (*(_DWORD *)a1 == -1252936367)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (v5) {
      *(_DWORD *)(v5 + 300) = 3;
    }
  }

  return (v4 >> 31);
}

int SSL_shutdown(SSL *s)
{
  *((_DWORD *)s->handshake_func + 49) = 0;
  ERR_clear_error();
  ERR_clear_system_error();
  if (!*(void *)&s->rwstate)
  {
    int v5 = 226;
    int v6 = 1412;
LABEL_12:
    ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_lib.cc", v6);
    return -1;
  }

  handshake_func = s->handshake_func;
  uint64_t v3 = *((void *)handshake_func + 35);
  if (v3 && (*(_BYTE *)(v3 + 1584) & 8) == 0) {
    return 1;
  }
  if ((BYTE4(s->param) & 2) != 0)
  {
    *(void *)((char *)handshake_func + 172) = 0x100000001LL;
    return 1;
  }

  if (*((_DWORD *)handshake_func + 44) != 1)
  {
    int v8 = bssl::ssl_send_alert_impl((bssl *)s, (ssl_st *)1, 0);
    goto LABEL_18;
  }

  if ((*((_WORD *)handshake_func + 110) & 0x800) != 0)
  {
    int v8 = (*(uint64_t (**)(SSL *))(*(void *)&s->version + 80LL))(s);
LABEL_18:
    if (v8 < 1) {
      return -1;
    }
    return *((_DWORD *)s->handshake_func + 43) == 1;
  }

  int v4 = *((_DWORD *)handshake_func + 43);
  if (v4 != 1)
  {
    if (**(_BYTE **)&s->version)
    {
      if (v4 == 2)
      {
        ERR_restore_state(*((void **)handshake_func + 23));
        return -1;
      }

      *((_DWORD *)handshake_func + 43) = 1;
      return *((_DWORD *)s->handshake_func + 43) == 1;
    }

    if ((int)ssl_read_impl(s) >= 1)
    {
      int v5 = 291;
      int v6 = 1459;
      goto LABEL_12;
    }

    if (*((_DWORD *)s->handshake_func + 43) != 1) {
      return -1;
    }
  }

  return *((_DWORD *)s->handshake_func + 43) == 1;
}

uint64_t bssl::ssl_send_alert_impl(bssl *this, ssl_st *a2, int a3)
{
  uint64_t v3 = *((void *)this + 6);
  if (*(_DWORD *)(v3 + 176))
  {
    ERR_put_error(16, 0, 194, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 412);
    return 0xFFFFFFFFLL;
  }

  if ((_DWORD)a2 != 1 || a3)
  {
    if ((_DWORD)a2 != 2) {
      bssl::ssl_send_alert_impl();
    }
    if (!a3) {
      bssl::ssl_send_alert_impl();
    }
    int v4 = 2;
  }

  else
  {
    int v4 = 1;
  }

  *(_DWORD *)(v3 + 176) = v4;
  *(_WORD *)(v3 + 220) |= 0x800u;
  *(_BYTE *)(*((void *)this + 6) + 469LL) = (_BYTE)a2;
  *(_BYTE *)(*((void *)this + 6) + 47std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va, 0LL) = a3;
  if (*(_WORD *)(*((void *)this + 6) + 116LL)) {
    return 0xFFFFFFFFLL;
  }
  return (*(uint64_t (**)(bssl *))(*(void *)this + 80LL))(this);
}

uint64_t bssl::tls_dispatch_alert(bssl *this, ssl_st *a2)
{
  uint64_t v3 = *((void *)this + 21);
  if (v3)
  {
    if (!(*(unsigned int (**)(bssl *, void, void))(v3 + 32))( this,  *(unsigned int *)(*((void *)this + 6) + 204LL),  *(unsigned __int8 *)(*((void *)this + 6) + 470LL)))
    {
      ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 441);
      return 0LL;
    }

    goto LABEL_10;
  }

  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = bssl::do_tls_write( this,  (ssl_st *)&v9,  (ssl_st *)0x15,  *((void *)this + 6) + 469LL,  (const unsigned __int8 *)2);
  uint64_t v4 = v5;
  if ((int)v5 >= 1)
  {
LABEL_10:
    *(_WORD *)(*((void *)this + 6) + 220LL) &= ~0x800u;
    uint64_t v7 = *((void *)this + 6);
    if (*(_BYTE *)(v7 + 469) == 2)
    {
      BIO_flush(*((BIO **)this + 4));
      uint64_t v7 = *((void *)this + 6);
    }

    uint64_t v4 = 1LL;
    bssl::ssl_do_msg_callback((uint64_t)this, 1LL, 21LL, v7 + 469, 2LL);
    bssl::ssl_do_info_callback((uint64_t)this, (const ssl_st *)0x4008);
  }

  return v4;
}

void boringssl_context_alert_callback_handler(const SSL *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  int v8 = SSL_get_ex_data(a1, 0);
  if (v8)
  {
    unint64_t v9 = v8;
    if (*v8 == -1252936367)
    {
      uint64_t v10 = *((void *)v8 + 1);
      if (v10)
      {
        uint64_t v11 = (char *)BYTE1(a3);
        if (BYTE1(a3) == 1)
        {
          id WeakRetained = objc_loadWeakRetained((id *)(v10 + 16));
          if (!WeakRetained
            || (uint64_t v20 = WeakRetained,
                unint64_t v21 = objc_loadWeakRetained((id *)(v10 + 16)),
                char v22 = v21[475],
                v21,
                v20,
                (v22 & 1) == 0))
          {
            id v23 = objc_loadWeakRetained((id *)(v10 + 16));
            if (v23)
            {
              unsigned int v24 = objc_loadWeakRetained((id *)(v10 + 16));
              BOOL v25 = (v24[475] & 1) == 0;
            }

            else
            {
              BOOL v25 = 1;
            }

            if (v25)
            {
              if (g_boringssl_log)
              {
                id v36 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
                {
                  id v37 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (v37)
                  {
                    uint64_t v11 = (char *)objc_loadWeakRetained((id *)(v10 + 16));
                    int v38 = v11 + 391;
                  }

                  else
                  {
                    int v38 = &unk_1875F4C23;
                  }

                  id v40 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (a4) {
                    __int16 v41 = "read";
                  }
                  else {
                    __int16 v41 = "write";
                  }
                  *(_DWORD *)buf = 136447746;
                  char v53 = "boringssl_context_handle_warning_alert";
                  __int16 v54 = 1024;
                  int v55 = 2189;
                  __int16 v56 = 2082;
                  unint64_t v57 = v38;
                  __int16 v58 = 2048;
                  id v59 = v40;
                  __int16 v60 = 2082;
                  id v61 = v41;
                  __int16 v62 = 2082;
                  unint64_t v63 = SSL_alert_type_string_long(a3);
                  __int16 v64 = 2082;
                  int v65 = SSL_alert_desc_string_long(a3);
                  _os_log_impl( &dword_187560000,  v36,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] %{public}s alert, level: %{public}s, description: %{public}s",  buf,  0x44u);

                  if (v37) {
                }
                  }
              }
            }
          }

          ++*(_BYTE *)(v10 + 318);
        }

        else if (BYTE1(a3) == 2)
        {
          id v12 = objc_loadWeakRetained((id *)(v10 + 16));
          if (!v12
            || (uint64_t v13 = v12,
                id v14 = objc_loadWeakRetained((id *)(v10 + 16)),
                char v15 = v14[475],
                v14,
                v13,
                (v15 & 1) == 0))
          {
            id v16 = objc_loadWeakRetained((id *)(v10 + 16));
            if (v16)
            {
              unsigned int v17 = objc_loadWeakRetained((id *)(v10 + 16));
              BOOL v18 = (v17[475] & 1) == 0;
            }

            else
            {
              BOOL v18 = 1;
            }

            if (v18)
            {
              if (g_boringssl_log)
              {
                id v32 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  id v42 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (v42)
                  {
                    unsigned int v50 = (char *)objc_loadWeakRetained((id *)(v10 + 16));
                    uint64_t v51 = v50 + 391;
                  }

                  else
                  {
                    uint64_t v51 = &unk_1875F4C23;
                  }

                  id v45 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (a4) {
                    uint64_t v46 = "read";
                  }
                  else {
                    uint64_t v46 = "write";
                  }
                  *(_DWORD *)buf = 136447746;
                  char v53 = "boringssl_context_handle_fatal_alert";
                  __int16 v54 = 1024;
                  int v55 = 2170;
                  __int16 v56 = 2082;
                  unint64_t v57 = v51;
                  __int16 v58 = 2048;
                  id v59 = v45;
                  __int16 v60 = 2082;
                  id v61 = v46;
                  __int16 v62 = 2082;
                  unint64_t v63 = SSL_alert_type_string_long(a3);
                  __int16 v64 = 2082;
                  int v65 = SSL_alert_desc_string_long(a3);
                  _os_log_error_impl( &dword_187560000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] %{public}s alert, level: %{public}s, description: %{public}s",  buf,  0x44u);

                  if (v42) {
                }
                  }
              }
            }
          }

          ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))boringssl_context_error_print, v9);
          *(_DWORD *)(v10 + 312) = a2;
          *(_BYTE *)(v10 + 316) = 2;
          *(_BYTE *)(v10 + 317) = a3;
          uint64_t v33 = boringssl_helper_convert_alert_code(a3, a2);
          uint64_t v34 = *(void *)(v10 + 280);
          id v35 = objc_loadWeakRetained((id *)(v10 + 16));
          (*(void (**)(uint64_t, id, uint64_t, uint64_t))(v34 + 16))(v34, v35, a2, v33);
        }

        else
        {
          id v26 = objc_loadWeakRetained((id *)(v10 + 16));
          if (!v26
            || (BOOL v27 = v26,
                uint64_t v28 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v10 + 16)),
                uint64_t v4 = (char *)v28[475],
                v28,
                v27,
                (v4 & 1) == 0))
          {
            id v29 = objc_loadWeakRetained((id *)(v10 + 16));
            if (v29)
            {
              uint64_t v30 = objc_loadWeakRetained((id *)(v10 + 16));
              BOOL v31 = (v30[475] & 1) == 0;
            }

            else
            {
              BOOL v31 = 1;
            }

            if (v31)
            {
              if (g_boringssl_log)
              {
                int v39 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  id v43 = objc_loadWeakRetained((id *)(v10 + 16));
                  if (v43)
                  {
                    uint64_t v4 = (char *)objc_loadWeakRetained((id *)(v10 + 16));
                    uint64_t v44 = v4 + 391;
                  }

                  else
                  {
                    uint64_t v44 = &unk_1875F4C23;
                  }

                  id v47 = objc_loadWeakRetained((id *)(v10 + 16));
                  unsigned int v48 = v47;
                  *(_DWORD *)buf = 136447490;
                  char v53 = "boringssl_context_alert_callback_handler";
                  __int16 v49 = "write";
                  int v55 = 2212;
                  __int16 v54 = 1024;
                  if (a4) {
                    __int16 v49 = "read";
                  }
                  __int16 v56 = 2082;
                  unint64_t v57 = v44;
                  __int16 v58 = 2048;
                  id v59 = v47;
                  __int16 v60 = 2082;
                  id v61 = v49;
                  __int16 v62 = 1024;
                  LODWORD(v63) = (_DWORD)v11;
                  _os_log_error_impl( &dword_187560000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Unhandled %{public}s alert level: %d",  buf,  0x36u);

                  if (v43) {
                }
                  }
              }
            }
          }
        }
      }
    }
  }

const char *__cdecl SSL_alert_type_string_long(int value)
{
  uint64_t v1 = "unknown";
  if (value >> 8 == 2) {
    uint64_t v1 = "fatal";
  }
  if (value >> 8 == 1) {
    return "warning";
  }
  else {
    return v1;
  }
}

const char *__cdecl SSL_alert_desc_string_long(int value)
{
  if (value > 0x45u)
  {
    if (value <= 0x55u)
    {
      switch(value)
      {
        case 'F':
          return "protocol version";
        case 'G':
          return "insufficient security";
        case 'P':
          return "internal error";
        default:
          return "unknown";
      }
    }

    else
    {
      switch((char)value)
      {
        case 'd':
          return "no renegotiation";
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'u':
        case 'v':
        case 'w':
          return "unknown";
        case 'm':
          return "missing extension";
        case 'n':
          return "unsupported extension";
        case 'o':
          return "certificate unobtainable";
        case 'p':
          return "unrecognized name";
        case 'q':
          return "bad certificate status response";
        case 'r':
          return "bad certificate hash value";
        case 's':
          return "unknown PSK identity";
        case 't':
          return "certificate required";
        case 'x':
          return "no application protocol";
        case 'y':
          return "ECH required";
        default:
          if (value == 86)
          {
            uint64_t result = "inappropriate fallback";
          }

          else
          {
            uint64_t result = "user canceled";
          }

          break;
      }
    }
  }

  else
  {
    switch((char)value)
    {
      case 20:
        return "bad record mac";
      case 21:
        return "decryption failed";
      case 22:
        return "record overflow";
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
        return "unknown";
      case 30:
        return "decompression failure";
      case 40:
        return "handshake failure";
      case 41:
        return "no certificate";
      case 42:
        return "bad certificate";
      case 43:
        return "unsupported certificate";
      case 44:
        return "certificate revoked";
      case 45:
        return "certificate expired";
      case 46:
        return "certificate unknown";
      case 47:
        return "illegal parameter";
      case 48:
        return "unknown CA";
      case 49:
        return "access denied";
      case 50:
        return "decode error";
      case 51:
        return "decrypt error";
      case 60:
        return "export restriction";
      default:
        if ((_BYTE)value)
        {
          uint64_t result = "unexpected_message";
        }

        else
        {
          uint64_t result = "close notify";
        }

        break;
    }
  }

  return result;
}

uint64_t nw_protocol_boringssl_remove_input_handler(uint64_t result, uint64_t a2, int a3)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = *(void *)(result + 40);
    if (!v4) {
      return 0LL;
    }
    if ((*(_BYTE *)(v4 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        if (g_boringssl_log)
        {
          uint64_t v12 = a2;
          BOOL v11 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
          a2 = v12;
          if (v11)
          {
            nw_protocol_boringssl_remove_input_handler_cold_1();
            a2 = v12;
          }
        }
      }
    }

    *(void *)(a2 + RAND_bytes(buf, 32) = 0LL;
    if (v3[6] == a2)
    {
      v3[6] = 0LL;
      *(_DWORD *)(v4 + 376) = 0;
      int v6 = *(void **)(v4 + 368);
      *(void *)(v4 + 36_Block_object_dispose(va, 8) = 0LL;

      nw_frame_array_foreach();
      nw_frame_array_foreach();
      nw_frame_array_foreach();
      nw_frame_array_foreach();
      nw_frame_array_foreach();
      uint64_t v7 = v3[4];
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 24);
        if (v8)
        {
          unint64_t v9 = *(void (**)(void))(v8 + 8);
          if (v9) {
            v9();
          }
        }
      }

      if (a3)
      {
        uint64_t v10 = (void *)v3[5];
        v3[5] = 0LL;
      }

      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void nw_protocol_boringssl_cleanup(void *a1)
{
  uint64_t v1 = a1;
  if (v1)
  {
    uint64_t v12 = v1;
    uint64_t v2 = (void *)MEMORY[0x1895A96B8]();
    uint64_t v3 = v12;
    uint64_t v4 = v12[42];
    if (v4)
    {
      uint64_t v5 = *(void **)(v4 + 8);
      int v6 = (SSL *)v5[50];
      if (v6)
      {
        SSL_set_msg_callback(v6, 0LL);
        SSL_set_msg_callback_arg(v5[50], 0LL);
      }

      uint64_t v7 = v5[5];
      if (v7) {
        boringssl_psk_cache_clear_context(v7);
      }

      uint64_t v3 = v12;
    }

    v3[42] = 0LL;
    objc_autoreleasePoolPop(v2);
    uint64_t v13 = v12;
    nw_frame_array_foreach();
    uint64_t v8 = v13;
    nw_frame_array_foreach();
    unint64_t v9 = (BIO *)v8[43];
    if (v9)
    {
      boringssl_bio_destroy(v9);
      v8[43] = 0LL;
    }

    uint64_t v10 = (void *)v8[21];
    if (v10)
    {
      v8[21] = 0LL;

      v8[22] = 0LL;
      *((_DWORD *)v8 + 46) = 0;
    }

    if (v8[40])
    {
      nw_queue_cancel_source();
      v8[40] = 0LL;
    }

    BOOL v11 = (void *)v8[44];
    if (v11)
    {
      free(v11);
      v8[44] = 0LL;
    }

    uint64_t v1 = v12;
  }
}

void boringssl_session_destroy(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v1 = *(void *)(a1 + 8);
      if (v1)
      {
        uint64_t v2 = *(SSL **)(v1 + 400);
        if (v2)
        {
          SSL_free(v2);
          *(void *)(v1 + 400) = 0LL;
          *(_DWORD *)(v1 + 300) = 5;
        }
      }
    }
  }

void SSL_free(SSL *ssl)
{
  if (ssl)
  {
    ssl_st::~ssl_st(ssl);
    OPENSSL_free(v1);
  }

void ssl_st::~ssl_st(ssl_st *this)
{
  if (*(void *)&this->version) {
    (*(void (**)(ssl_st *))(*(void *)&this->version + 16LL))(this);
  }
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((void **)&this->msg_callback_arg, 0LL);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_ctx_st **)&this->s3, 0LL);
  std::unique_ptr<ssl_ctx_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_ctx_st **)&this->s2, 0LL);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)&this->packet, 0LL);
  std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](&this->bbio, 0LL);
  std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](&this->wbio, 0LL);
  std::unique_ptr<bssl::SSL_CONFIG,bssl::internal::Deleter>::reset[abi:ne180100]((BUF_MEM ***)&this->method, 0LL);
}

uint64_t CRYPTO_MUTEX_lock_read(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_rdlock(a1);
  if ((_DWORD)result) {
    abort();
  }
  return result;
}

uint64_t CRYPTO_MUTEX_unlock_read(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_unlock(a1);
  if ((_DWORD)result) {
    abort();
  }
  return result;
}

void bssl::SSL_CONFIG::~SSL_CONFIG(BUF_MEM **this)
{
  uint64_t v2 = *(void *)&(*this)[5].length;
  if (v2) {
    (*(void (**)(BUF_MEM **))(*(void *)(v2 + 16) + 96LL))(this);
  }
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 35));
  std::unique_ptr<stack_st_SRTP_PROTECTION_PROFILE,bssl::internal::Deleter>::reset[abi:ne180100](this + 34, 0LL);
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 32));
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 30));
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 28));
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_credential_st **)this + 26, 0LL);
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 24));
  std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]((ssl_credential_st **)this + 23, 0LL);
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 21));
  bssl::Array<bssl::ALPSConfig>::~Array((uint64_t)(this + 19));
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 16));
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)this + 15, 0LL);
  bssl::Array<unsigned short>::~Array((uint64_t)(this + 13));
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)this + 11,  0LL);
  std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100]((void **)this + 7, 0LL);
  std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::CERT **)this + 4, 0LL);
  std::unique_ptr<bssl::SSLCipherPreferenceList,bssl::internal::Deleter>::reset[abi:ne180100]( (bssl::SSLCipherPreferenceList **)this + 3,  0LL);
}

uint64_t bssl::Array<bssl::ALPSConfig>::~Array(uint64_t a1)
{
  return a1;
}

void bssl::Array<bssl::ALPSConfig>::Reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v6 = 0LL;
    unint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = *(void *)a1 + v6;
      bssl::Array<unsigned short>::~Array(v8 + 16);
      bssl::Array<unsigned short>::~Array(v8);
      ++v7;
      v6 += 32LL;
    }

    while (v7 < *(void *)(a1 + 8));
  }

  OPENSSL_free(*(void **)a1);
  *(void *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a3;
}

void bssl::CERT::~CERT(bssl::CERT *this)
{
}

void bssl::tls_free(bssl *this, ssl_st *a2)
{
  if (this)
  {
    uint64_t v3 = (bssl::SSL3_STATE *)*((void *)this + 6);
    if (v3)
    {
      bssl::SSL3_STATE::~SSL3_STATE(v3);
      OPENSSL_free(v4);
      *((void *)this + 6) = 0LL;
    }
  }

void bssl::SSL3_STATE::~SSL3_STATE(bssl::SSL3_STATE *this)
{
}

void bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(bssl::SSL_HANDSHAKE *this)
{
  for (uint64_t i = 400LL; i != 384; i -= 8LL)
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]((void **)((char *)this + i), 0LL);
  std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]((uint64_t *)this + 48, 0LL);
}

void int_rsa_free(uint64_t a1)
{
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)this + 8) = 0LL;
}

void RSA_free(RSA *r)
{
  if (r && CRYPTO_refcount_dec_and_test_zero((unsigned int *)&r->dmq1))
  {
    CRYPTO_free_ex_data((int)&g_ex_data_class_0, r, (CRYPTO_EX_DATA *)&r->dmp1);
    BN_clear_free((BIGNUM *)r->version);
    BN_clear_free((BIGNUM *)r->meth);
    BN_clear_free((BIGNUM *)r->engine);
    BN_clear_free(r->n);
    BN_clear_free(r->e);
    BN_clear_free(r->d);
    BN_clear_free(r->p);
    BN_clear_free(r->q);
    BN_MONT_CTX_free(r[1]._method_mod_n);
    BN_MONT_CTX_free(r[1]._method_mod_p);
    BN_MONT_CTX_free(r[1]._method_mod_q);
    if (r[2].version)
    {
      uint64_t v2 = 0LL;
      unsigned int v3 = 1;
      do
      {
        BN_BLINDING_free(*((BN_BLINDING **)&r[2].meth->name + v2));
        uint64_t v2 = v3;
      }

      while (r[2].version > (unint64_t)v3++);
    }

    meth = (RSA_METHOD *)r[2].meth;
    if (meth)
    {
      free(meth);
      r[2].meth = 0LL;
    }

    engine = r[2].engine;
    if (engine)
    {
      free(engine);
      r[2].engine = 0LL;
    }

    CRYPTO_MUTEX_cleanup((pthread_rwlock_t *)&r->iqmp);
    free(r);
  }

void BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
  if (mont)
  {
    BN_free((BIGNUM *)mont);
    BN_free((BIGNUM *)&mont->RR.neg);
    OPENSSL_free(mont);
  }

uint64_t EVP_HPKE_CTX_cleanup(uint64_t a1)
{
  return EVP_AEAD_CTX_cleanup(a1 + 24);
}

void bssl::SSLTranscript::~SSLTranscript(bssl::SSLTranscript *this)
{
}

void bssl::SSLBuffer::~SSLBuffer(bssl::SSLBuffer *this)
{
  *((_WORD *)this + 4) = *((_WORD *)this + 5);
  *((_WORD *)this + 6) = 0;
  *((_WORD *)this + 7) = *((_WORD *)this + 8);
  if (*((_BYTE *)this + 23)) {
    free(*(void **)this);
  }
}

void SSL_CTX_free(SSL_CTX *a1)
{
  if (a1) {
    bssl::RefCounted<ssl_ctx_st>::DecRefInternal(a1);
  }
}

int BIO_free(BIO *a)
{
  if (!a) {
    return 1;
  }
  uint64_t v1 = a;
  while (1)
  {
    uint64_t v2 = v1;
    int result = CRYPTO_refcount_dec_and_test_zero((unsigned int *)&v1->retry_reason);
    if (!result) {
      break;
    }
    uint64_t v1 = (BIO *)v1->ptr;
    v2->ptr = 0LL;
    if (v2->method)
    {
      destroy = v2->method->destroy;
      if (destroy) {
        ((void (*)(BIO *))destroy)(v2);
      }
    }

    CRYPTO_free_ex_data((int)&g_ex_data_class, v2, (CRYPTO_EX_DATA *)&v2->callback);
    OPENSSL_free(v2);
    if (!v1) {
      return 1;
    }
  }

  return result;
}

void boringssl_context_ssl_context_destroy(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v1 = *(void *)(a1 + 8);
      if (v1)
      {
        uint64_t v2 = *(SSL_CTX **)(v1 + 408);
        if (v2)
        {
          SSL_CTX_free(v2);
          *(void *)(v1 + 40bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)this + 8) = 0LL;
        }
      }
    }
  }

void ssl_ctx_st::~ssl_ctx_st(ssl_ctx_st *this)
{
}

void SSL_CTX_flush_sessions(SSL_CTX *ctx, uint64_t tm)
{
  info_callbacuint64_t k = ctx->info_callback;
  v4[0] = ctx;
  v4[2] = info_callback;
  if (info_callback)
  {
    v4[1] = tm;
    unsigned int v3 = (pthread_rwlock_t *)0xAAAAAAAAAAAAAAAALL;
    bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_write),&(CRYPTO_MUTEX_unlock_write)>::MutexLockBase( &v3,  (pthread_rwlock_t *)&ctx->cert_store);
    v5[0] = timeout_doall_arg;
    v5[1] = v4;
    OPENSSL_lh_doall_arg( (uint64_t)info_callback,  (void (*)(void, uint64_t))lh_SSL_SESSION_call_doall_arg,  (uint64_t)v5);
    CRYPTO_MUTEX_unlock_read(v3);
  }

void sub_187594100( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9)
{
}

uint64_t CRYPTO_MUTEX_lock_write(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_wrlock(a1);
  if ((_DWORD)result) {
    abort();
  }
  return result;
}

void OPENSSL_lh_doall_arg(uint64_t a1, void (*a2)(void, uint64_t), uint64_t a3)
{
  if (a1)
  {
    int v6 = *(_DWORD *)(a1 + 24);
    if (v6 == -1)
    {
      int v7 = -1;
    }

    else
    {
      int v7 = v6 + 1;
      *(_DWORD *)(a1 + 24) = v6 + 1;
    }

    unint64_t v8 = *(void *)(a1 + 16);
    if (v8)
    {
      for (unint64_t i = 0LL; i < v8; ++i)
      {
        uint64_t v10 = *(void **)(*(void *)(a1 + 8) + 8 * i);
        if (v10)
        {
          do
          {
            BOOL v11 = (void *)v10[1];
            a2(*v10, a3);
            uint64_t v10 = v11;
          }

          while (v11);
          unint64_t v8 = *(void *)(a1 + 16);
        }
      }

      int v7 = *(_DWORD *)(a1 + 24);
    }

    if (v7 != -1) {
      *(_DWORD *)(a1 + 24) = v7 - 1;
    }
    lh_maybe_resize(a1);
  }

void lh_maybe_resize(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v1 = *(void *)(a1 + 16);
    if (v1 <= 0xF) {
      lh_maybe_resize_cold_1();
    }
    if (*(void *)a1 / v1 < 3)
    {
      if (v1 < 0x11 || v1 <= *(void *)a1) {
        return;
      }
      unint64_t v3 = v1 >> 1;
      if (v3 <= 0x10) {
        unint64_t v2 = 16LL;
      }
      else {
        unint64_t v2 = v3;
      }
    }

    else
    {
      unint64_t v2 = 2 * v1;
    }

    lh_rebucket(a1, v2);
  }

void OPENSSL_lh_free(void *a1)
{
  if (a1)
  {
    unint64_t v2 = a1[2];
    if (v2)
    {
      for (unint64_t i = 0LL; i < v2; ++i)
      {
        uint64_t v4 = *(void **)(a1[1] + 8 * i);
        if (v4)
        {
          do
          {
            uint64_t v5 = (void *)v4[1];
            OPENSSL_free(v4);
            uint64_t v4 = v5;
          }

          while (v5);
          unint64_t v2 = a1[2];
        }
      }
    }

    OPENSSL_free((void *)a1[1]);
    OPENSSL_free(a1);
  }

void boringssl_bio_destroy(BIO *a)
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    boringssl_bio_destroy_cold_1();
    if (!a) {
      return;
    }
  }

  else if (!a)
  {
    return;
  }

  unint64_t v2 = *(void **)&a->num;
  if (v2) {
    free(v2);
  }
  BIO_free(a);
}

uint64_t boringssl_bio_free(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 20))
    {
      *(_DWORD *)(result + 16) = 0;
      *(_DWORD *)(result + 24) = 0;
    }

    return 1LL;
  }

  return result;
}

void nw_protocol_boringssl_deallocate_metadata(void *a1, void *a2)
{
  id v3 = a1;
  if (a2)
  {
    id v21 = v3;
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      free(v4);
      a2[5] = 0LL;
    }

    uint64_t v5 = (void *)a2[22];
    if (v5)
    {
      free(v5);
      a2[22] = 0LL;
    }

    int v6 = (void *)a2[6];
    if (v6)
    {
      free(v6);
      a2[6] = 0LL;
    }

    int v7 = (void *)a2[7];
    if (v7)
    {
      free(v7);
      a2[7] = 0LL;
    }

    unint64_t v8 = (void *)a2[40];
    if (v8)
    {
      free(v8);
      a2[40] = 0LL;
    }

    unint64_t v9 = (void *)a2[10];
    a2[10] = 0LL;

    uint64_t v10 = (void *)a2[11];
    a2[11] = 0LL;

    BOOL v11 = (void *)a2[12];
    a2[12] = 0LL;

    uint64_t v12 = (void *)a2[13];
    a2[13] = 0LL;

    uint64_t v13 = (void *)a2[14];
    a2[14] = 0LL;

    id v14 = (void *)a2[15];
    a2[15] = 0LL;

    char v15 = (void *)a2[16];
    a2[16] = 0LL;

    id v16 = (void *)a2[17];
    a2[17] = 0LL;

    unsigned int v17 = (void *)a2[18];
    a2[18] = 0LL;

    BOOL v18 = (void *)a2[19];
    a2[19] = 0LL;

    unsigned int v19 = (void *)a2[20];
    a2[20] = 0LL;

    uint64_t v20 = (void *)a2[21];
    a2[21] = 0LL;

    free(a2);
    id v3 = v21;
  }
}

uint64_t bssl::ssl_process_alert(bssl *a1, _BYTE *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a4 != 2)
  {
    *a2 = 50;
    int v12 = 102;
    int v13 = 551;
    goto LABEL_12;
  }

  bssl::ssl_do_msg_callback((uint64_t)a1, 0LL, 21LL, (uint64_t)a3, 2LL);
  int v7 = *a3;
  int v8 = a3[1];
  bssl::ssl_do_info_callback((uint64_t)a1, (const ssl_st *)0x4004);
  if (v7 == 2)
  {
    ERR_put_error(16, 0, v8 + 1000, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 592);
    ERR_add_error_dataf("SSL alert number %d", v14, v15, v16, v17, v18, v19, v20, v8);
    *a2 = 0;
    return 4LL;
  }

  if (v7 != 1)
  {
    *a2 = 47;
    int v12 = 227;
    int v13 = 599;
    goto LABEL_12;
  }

  uint64_t v10 = *((void *)a1 + 6);
  if (v8)
  {
    if ((*(_WORD *)(v10 + 220) & 2) != 0)
    {
      unsigned int v11 = bssl::ssl_protocol_version(a1, v9);
      if (v8 != 90 && v11 > 0x303)
      {
        *a2 = 50;
        int v12 = 102;
        int v13 = 578;
LABEL_12:
        ERR_put_error(16, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", v13);
        return 4LL;
      }

      uint64_t v10 = *((void *)a1 + 6);
    }

    unsigned int v22 = ++*(_BYTE *)(v10 + 211);
    if (v22 >= 5)
    {
      *a2 = 10;
      int v12 = 220;
      int v13 = 585;
      goto LABEL_12;
    }

    return 1LL;
  }

  else
  {
    *(_DWORD *)(v10 + 172) = 1;
    return 3LL;
  }

void nw_protocol_boringssl_input_finished(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    return;
  }
  if ((*(_BYTE *)(v2 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_input_finished_cold_2();
  }

  if (!*(void *)(a1 + 48))
  {
    if ((*(_BYTE *)(v2 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_input_finished_cold_1();
    }

    return;
  }

  unsigned int state = boringssl_session_get_state(*(void *)(v2 + 336));
  session_state_description = boringssl_helper_get_session_state_description(state);
  if ((*(_BYTE *)(v2 + 475) & 1) == 0)
  {
    if (g_boringssl_log)
    {
      uint64_t v10 = (os_log_s *)g_boringssl_log;
      unsigned int v11 = session_state_description;
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447490;
        int v13 = "nw_protocol_boringssl_input_finished";
        __int16 v14 = 1024;
        int v15 = 1996;
        __int16 v16 = 2082;
        uint64_t v17 = v2 + 391;
        __int16 v18 = 2048;
        uint64_t v19 = v2;
        __int16 v20 = 2080;
        id v21 = v11;
        __int16 v22 = 1024;
        unsigned int v23 = state;
        _os_log_debug_impl( &dword_187560000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] session state: %s [%d]",  buf,  0x36u);
      }
    }
  }

  if (state < 2)
  {
    nw_protocol_boringssl_internal_error((void *)v2, -9816);
    uint64_t v8 = *(void *)(a1 + 48);
    if (!v8) {
      return;
    }
    uint64_t v9 = *(void *)(v8 + 24);
    if (!v9) {
      return;
    }
    int v7 = *(void (**)(void))(v9 + 48);
    if (!v7) {
      return;
    }
LABEL_20:
    v7();
    return;
  }

  if ((*(_BYTE *)(v2 + 389) & 2) != 0)
  {
    *(_BYTE *)(v2 + 389) |= 1u;
    return;
  }

  *(_BYTE *)(v2 + 388) &= ~0x80u;
  nw_boringssl_read(a1);
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 24);
    if (v6)
    {
      int v7 = *(void (**)(void))(v6 + 184);
      if (v7) {
        goto LABEL_20;
      }
    }
  }

const char *boringssl_helper_get_session_state_description(int a1)
{
  else {
    return off_18A071B90[a1 - 1];
  }
}

uint64_t nw_protocol_boringssl_error(uint64_t result, uint64_t a2, uint64_t __errnum)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 40);
  if (!v4) {
    return result;
  }
  if ((*(_BYTE *)(v4 + 475) & 1) == 0
    && datapath_logging_enabled
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
  {
    nw_protocol_boringssl_error_cold_1();
  }

  *(_DWORD *)(v4 + 384) = __errnum;
  __int128 v33 = 0u;
  memset(v34, 0, sizeof(v34));
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  *(_OWORD *)__strerrbuf = 0u;
  __int128 v30 = 0u;
  strerror_r(__errnum, __strerrbuf, 0x64uLL);
  if (boringssl_session_get_state(*(void *)(v4 + 336)) < 2)
  {
    if ((*(_BYTE *)(v4 + 388) & 4) != 0)
    {
      if ((*(_BYTE *)(v4 + 389) & 0xC0) == 0x80) {
        goto LABEL_16;
      }
      if ((*(_BYTE *)(v4 + 475) & 1) != 0) {
        goto LABEL_16;
      }
      uint64_t v14 = g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      int v17 = 136447490;
      __int16 v18 = "nw_protocol_boringssl_error";
      __int16 v19 = 1024;
      int v20 = 1971;
      __int16 v21 = 2082;
      uint64_t v22 = v4 + 391;
      __int16 v23 = 2048;
      uint64_t v24 = v4;
      __int16 v25 = 1024;
      int v26 = __errnum;
      __int16 v27 = 2080;
      uint64_t v28 = __strerrbuf;
      int v13 = "%{public}s(%d) %{public}s[%p] Lower protocol stack error during TLS handshake. [%d: %s]";
    }

    else
    {
      if ((*(_BYTE *)(v4 + 475) & 1) != 0) {
        goto LABEL_16;
      }
      uint64_t v14 = g_boringssl_log;
      if (!g_boringssl_log || !os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      int v17 = 136447490;
      __int16 v18 = "nw_protocol_boringssl_error";
      __int16 v19 = 1024;
      int v20 = 1973;
      __int16 v21 = 2082;
      uint64_t v22 = v4 + 391;
      __int16 v23 = 2048;
      uint64_t v24 = v4;
      __int16 v25 = 1024;
      int v26 = __errnum;
      __int16 v27 = 2080;
      uint64_t v28 = __strerrbuf;
      int v13 = "%{public}s(%d) %{public}s[%p] Lower protocol stack error pre TLS handshake. [%d: %s]";
    }

    int v12 = (os_log_s *)v14;
    goto LABEL_29;
  }

  if ((*(_BYTE *)(v4 + 475) & 1) == 0)
  {
    if (g_boringssl_log)
    {
      uint64_t v11 = g_boringssl_log;
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = (os_log_s *)v11;
        int v17 = 136447490;
        __int16 v18 = "nw_protocol_boringssl_error";
        __int16 v19 = 1024;
        int v20 = 1968;
        __int16 v21 = 2082;
        uint64_t v22 = v4 + 391;
        __int16 v23 = 2048;
        uint64_t v24 = v4;
        __int16 v25 = 1024;
        int v26 = __errnum;
        __int16 v27 = 2080;
        uint64_t v28 = __strerrbuf;
        int v13 = "%{public}s(%d) %{public}s[%p] Lower protocol stack error post TLS handshake. [%d: %s]";
LABEL_29:
        _os_log_impl(&dword_187560000, v12, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v17, 0x36u);
      }
    }
  }

void thread_local_destructor(char *a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a1 && !pthread_mutex_lock(&g_destructors_lock))
  {
    v4[0] = g_destructors;
    v4[1] = *(_OWORD *)algn_18C4C54D0;
    uint64_t v5 = qword_18C4C54E0;
    pthread_mutex_unlock(&g_destructors_lock);
    for (uint64_t i = 0LL; i != 40; i += 8LL)
    {
      uint64_t v3 = *(void (**)(void))((char *)v4 + i);
      if (v3) {
        v3(*(void *)&a1[i]);
      }
    }

    free(a1);
  }

void err_state_free(void **a1)
{
  if (a1)
  {
    for (uint64_t i = 0LL; i != 48; i += 3LL)
    {
      uint64_t v3 = &a1[i];
      free(a1[i + 1]);
      pthread_rwlock_t *v3 = 0LL;
      v3[1] = 0LL;
      v3[2] = 0LL;
    }

    free(a1[49]);
    free(a1);
  }

EC_KEY *EC_KEY_parse_private_key(__int128 *a1, const EC_GROUP *a2)
{
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_asn1(a1, &v15[1], 536870928)
    && CBS_get_asn1_uint64(&v15[1], &v14)
    && v14 == 1
    && CBS_get_asn1(&v15[1], v15, 4))
  {
    if (CBS_peek_asn1_tag(&v15[1], -1610612736))
    {
      buf[2] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
      buf[3] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
      if (!CBS_get_asn1(&v15[1], &buf[2], -1610612736))
      {
        int v4 = 128;
        int v5 = 106;
        goto LABEL_34;
      }

      uint64_t v3 = (const EC_GROUP *)EC_KEY_parse_parameters((__int128 *)&buf[2]);
      if (!v3)
      {
LABEL_35:
        uint64_t v6 = 0LL;
LABEL_36:
        uint64_t v9 = 0LL;
LABEL_37:
        EC_KEY_free(v6);
        BN_free(v9);
        return 0LL;
      }

      if (a2)
      {
        if (EC_GROUP_cmp(a2, v3, 0LL))
        {
          int v4 = 130;
          int v5 = 117;
LABEL_34:
          ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v5);
          goto LABEL_35;
        }
      }

      else
      {
        a2 = v3;
      }

      if (buf[3])
      {
        int v4 = 128;
        int v5 = 121;
        goto LABEL_34;
      }
    }

    else if (!a2)
    {
      int v4 = 114;
      int v5 = 127;
      goto LABEL_34;
    }

    uint64_t v8 = EC_KEY_new();
    uint64_t v6 = v8;
    if (!v8 || !EC_KEY_set_group(v8, a2)) {
      goto LABEL_36;
    }
    uint64_t v9 = BN_bin2bn(*(const unsigned __int8 **)&v15[0], SDWORD2(v15[0]), 0LL);
    uint64_t v10 = EC_POINT_new(a2);
    *((void *)v6 + 1) = v10;
    if (!v9 || !v10 || !EC_KEY_set_private_key(v6, v9)) {
      goto LABEL_37;
    }
    if (CBS_peek_asn1_tag(&v15[1], -1610612735))
    {
      memset(buf, 170, sizeof(buf));
      char v12 = -86;
      if (!CBS_get_asn1(&v15[1], &buf[2], -1610612735)
        || !CBS_get_asn1((__int128 *)&buf[2], buf, 3)
        || !CBS_get_u8(buf, &v12)
        || v12
        || !buf[1]
        || !EC_POINT_oct2point(a2, *((EC_POINT **)v6 + 1), buf[0], (size_t)buf[1], 0LL)
        || buf[3])
      {
        int v11 = 161;
LABEL_43:
        ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v11);
        goto LABEL_37;
      }

      *((_DWORD *)v6 + 7) = *buf[0] & 0xFE;
    }

    else
    {
      *((_DWORD *)v6 + 6) |= 2u;
    }

    if (!*((void *)&v15[1] + 1))
    {
      if (EC_KEY_check_key(v6))
      {
        BN_free(v9);
        return v6;
      }

      goto LABEL_37;
    }

    int v11 = 181;
    goto LABEL_43;
  }

  ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 92);
  return 0LL;
}

uint64_t EC_KEY_parse_parameters(__int128 *a1)
{
  if (!CBS_peek_asn1_tag(a1, 536870928)) {
    return EC_KEY_parse_curve_name(a1);
  }
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v22 = v2;
  __int128 v23 = v2;
  __int128 v20 = v2;
  __int128 v21 = v2;
  __int128 v18 = v2;
  __int128 v19 = v2;
  memset(v29, 170, sizeof(v29));
  memset(v28, 170, sizeof(v28));
  memset(v27, 170, sizeof(v27));
  int v26 = -1431655766;
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_asn1(a1, &v29[1], 536870928)
    || !CBS_get_asn1_uint64(&v29[1], &v25)
    || v25 != 1
    || !CBS_get_asn1(&v29[1], v29, 536870928)
    || !CBS_get_asn1(v29, &v28[1], 6)
    || *((void *)&v28[1] + 1) != 7LL
    || (**(_DWORD **)&v28[1] == -834107862 ? (BOOL v3 = *(_DWORD *)(*(void *)&v28[1] + 3LL) == 16858574) : (BOOL v3 = 0),
        !v3
     || !CBS_get_asn1(v29, &v18, 2)
     || !CBS_is_unsigned_asn1_integer((unsigned __int8 **)&v18)
     || *((void *)&v29[0] + 1)
     || !CBS_get_asn1(&v29[1], v28, 536870928)
     || !CBS_get_asn1(v28, &v19, 4)
     || !CBS_get_asn1(v28, &v20, 4)
     || !CBS_get_optional_asn1(v28, 0LL, 0LL, 3)
     || *((void *)&v28[0] + 1)
     || !CBS_get_asn1(&v29[1], &v27[2], 4)
     || !CBS_get_asn1(&v29[1], &v23, 2)
     || !CBS_is_unsigned_asn1_integer((unsigned __int8 **)&v23)
     || !CBS_get_optional_asn1(&v29[1], v27, &v26, 2)
     || *((void *)&v29[1] + 1)))
  {
    int v4 = 128;
    int v5 = 288;
LABEL_13:
    ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v5);
    return 0LL;
  }

  if (v26 && (v27[1] != 1LL || *(_BYTE *)v27[0] != 1))
  {
    int v4 = 123;
    int v5 = 296;
    goto LABEL_13;
  }

  char v24 = -86;
  if (!CBS_get_u8(&v27[2], &v24) || v24 != 4)
  {
    int v4 = 111;
    int v5 = 304;
    goto LABEL_13;
  }

  if ((v27[3] & 1) != 0)
  {
    int v4 = 128;
    int v5 = 309;
    goto LABEL_13;
  }

  *(void *)&__int128 v21 = v27[2];
  *((void *)&v21 + 1) = v27[3] >> 1;
  *(void *)&__int128 v22 = v27[2] + (v27[3] >> 1);
  *((void *)&v22 + 1) = v27[3] >> 1;
  uint64_t v7 = BN_new();
  uint64_t v8 = BN_new();
  uint64_t v9 = BN_new();
  uint64_t v10 = BN_new();
  a = BN_new();
  int v11 = 0LL;
  if (v7 && v8 && v9 && v10 && a)
  {
    uint64_t v12 = 0LL;
    while (1)
    {
      int v11 = (const EC_GROUP *)kAllGroups[v12]();
      uint64_t v15 = EC_GROUP_get0_order((uint64_t)v11, v13, v14);
      if (++v12 == 4) {
        goto LABEL_42;
      }
    }

    if (!EC_GROUP_get_curve_GFp(v11, v7, v8, v9, 0LL))
    {
LABEL_43:
      int v11 = 0LL;
      goto LABEL_44;
    }

    __int16 v16 = EC_GROUP_get0_generator(v11);
    if (!EC_POINT_get_affine_coordinates_GFp(v11, v16, v10, a, 0LL)) {
      goto LABEL_43;
    }
    if (!integers_equal(&v21, (uint64_t)v10) || !integers_equal(&v22, (uint64_t)a) || !v11)
    {
LABEL_42:
      ERR_put_error(15, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 422);
      goto LABEL_43;
    }
  }

LABEL_44:
  BN_free(v7);
  BN_free(v8);
  BN_free(v9);
  BN_free(v10);
  BN_free(a);
  return (uint64_t)v11;
}

  int v38 = objc_loadWeakRetained((id *)(v5 + 16));
  if (!v38
    || (int v39 = v38,
        id v40 = objc_loadWeakRetained((id *)(v5 + 16)),
        __int16 v41 = v40[475],
        v40,
        v39,
        (v41 & 1) == 0))
  {
    id v42 = objc_loadWeakRetained((id *)(v5 + 16));
    if (v42)
    {
      id v43 = objc_loadWeakRetained((id *)(v5 + 16));
      uint64_t v44 = (v43[475] & 1) == 0;
    }

    else
    {
      uint64_t v44 = 1;
    }

    if (v44)
    {
      if (g_boringssl_log)
      {
        id v45 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v46 = objc_loadWeakRetained((id *)(v5 + 16));
          if (v46)
          {
            BOOL v3 = (CFTypeID)objc_loadWeakRetained((id *)(v5 + 16));
            id v47 = (void *)(v3 + 391);
          }

          else
          {
            id v47 = &unk_1875F4C23;
          }

          unsigned int v48 = objc_loadWeakRetained((id *)(v5 + 16));
          __int16 v49 = *(const char **)(v5 + 80);
          unsigned int v50 = v48;
          redacted_identity = nw_protocol_boringssl_get_redacted_identity((uint64_t)v50, v49);
          int v55 = 136447490;
          __int16 v56 = "boringssl_context_process_trust_result";
          unint64_t v57 = 1024;
          __int16 v58 = 1543;
          id v59 = 2082;
          __int16 v60 = v47;
          id v61 = 2048;
          __int16 v62 = v48;
          unint64_t v63 = 2082;
          __int16 v64 = redacted_identity;
          int v65 = 1024;
          uint64_t v66 = a3;
          _os_log_debug_impl( &dword_187560000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Subject name: %{public}s, tls_handshake_trust: %{BOOL}d",  (uint8_t *)&v55,  0x36u);

          if (v46) {
        }
          }
      }
    }
  }

  return a3;
}

uint64_t EC_KEY_marshal_private_key(uint64_t *a1, uint64_t a2, char a3)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 16))
  {
    *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22[1] = v6;
    void v22[2] = v6;
    v22[0] = v6;
    v21[1] = v6;
    _OWORD v21[2] = v6;
    v21[0] = v6;
    if (CBB_add_asn1(a1, (uint64_t)v22, 0x20000010u)
      && CBB_add_asn1_uint64((uint64_t)v22, 1uLL)
      && CBB_add_asn1((uint64_t *)v22, (uint64_t)v21, 4u)
      && (uint64_t v9 = (const BIGNUM *)EC_GROUP_get0_order(*(void *)a2, v7, v8),
          unint64_t v10 = BN_num_bytes(v9),
          int v11 = EVP_HPKE_CTX_kdf((const EC_KEY *)a2),
          BN_bn2cbb_padded((uint64_t)v21, v10, (uint64_t)v11)))
    {
      if ((a3 & 1) != 0
        || (*(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL,
            *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL,
            __int128 v19 = v12,
            __int128 v20 = v12,
            __int128 v18 = v12,
            CBB_add_asn1((uint64_t *)v22, (uint64_t)&v18, 0xA0000000))
        && EC_KEY_marshal_curve_name((uint64_t *)&v18, *(void *)a2)
        && CBB_flush((uint64_t *)v22))
      {
        if ((a3 & 2) != 0) {
          goto LABEL_30;
        }
        if (!*(void *)(a2 + 8)) {
          goto LABEL_30;
        }
        *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v19 = v13;
        __int128 v20 = v13;
        v17[2] = v13;
        __int128 v18 = v13;
        v17[0] = v13;
        v17[1] = v13;
        if (CBB_add_asn1((uint64_t *)&v18, (uint64_t)v17, 3u)
          && CBB_add_u8((uint64_t)v17, 0)
          && EC_POINT_point2cbb( (uint64_t)v17,  *(EC_GROUP **)a2,  *(EC_POINT **)(a2 + 8),  (point_conversion_form_t)*(_DWORD *)(a2 + 28),  0LL)
          && CBB_flush((uint64_t *)v22))
        {
LABEL_30:
          int v15 = 129;
          int v16 = 244;
        }

        else
        {
LABEL_26:
          int v15 = 129;
          int v16 = 238;
        }
      }

      else
      {
        int v15 = 129;
        int v16 = 222;
      }
    }

    else
    {
      int v15 = 129;
      int v16 = 213;
    }
  }

  else
  {
    int v15 = 67;
    int v16 = 202;
  }

  ERR_put_error(15, 0, v15, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v16);
  return 0LL;
}

uint64_t EC_KEY_marshal_curve_name(uint64_t *a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 525))
  {
    *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v6[1] = v4;
    v6[2] = v4;
    v6[0] = v4;
    uint64_t result = CBB_add_asn1(a1, (uint64_t)v6, 6u);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_bytes((uint64_t)v6, (const void *)(a2 + 516), *(unsigned __int8 *)(a2 + 525));
      if ((_DWORD)result) {
        return CBB_flush(a1) != 0;
      }
    }
  }

  else
  {
    ERR_put_error(15, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 363);
    return 0LL;
  }

  return result;
}

uint64_t EC_POINT_point2cbb(uint64_t a1, EC_GROUP *a2, EC_POINT *a3, point_conversion_form_t form, BN_CTX *a5)
{
  uint64_t result = EC_POINT_point2oct(a2, a3, form, 0LL, 0LL, a5);
  if (result)
  {
    size_t v11 = result;
    buf = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    uint64_t result = CBB_add_space(a1, &buf, result);
    if ((_DWORD)result) {
      return EC_POINT_point2oct(a2, a3, form, buf, v11, a5) == v11;
    }
  }

  return result;
}

uint64_t EC_KEY_parse_curve_name(__int128 *a1)
{
  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_asn1(a1, v6, 6))
  {
    uint64_t v1 = 0LL;
    while (1)
    {
      uint64_t v2 = kAllGroups[v1]();
      if (++v1 == 4)
      {
        int v3 = 123;
        int v4 = 357;
        goto LABEL_7;
      }
    }
  }

  else
  {
    int v3 = 128;
    int v4 = 345;
LABEL_7:
    ERR_put_error(15, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", v4);
    return 0LL;
  }

  return v2;
}

BOOL integers_equal(__int128 *a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  for (__int128 i = *a1; *((void *)&i + 1); CBS_skip(&i, 1uLL))
  {
    if (*(_BYTE *)i)
    {
      if (*((void *)&i + 1) > 0x42uLL) {
        return 0LL;
      }
      break;
    }
  }

  __int16 v7 = -21846;
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v6[2] = v3;
  _OWORD v6[3] = v3;
  v6[0] = v3;
  v6[1] = v3;
  ERR_clear_error();
  return 0LL;
}

EC_KEY *__cdecl d2i_ECPrivateKey(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  if (a && (__int128 v6 = *a) != 0LL)
  {
    __int16 v7 = EC_KEY_get0_group(v6);
    if (len < 0)
    {
LABEL_4:
      ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 454);
      return 0LL;
    }
  }

  else
  {
    __int16 v7 = 0LL;
    if (len < 0) {
      goto LABEL_4;
    }
  }

  *(void *)&__int128 v10 = *in;
  *((void *)&v10 + 1) = len;
  uint64_t v8 = EC_KEY_parse_private_key(&v10, v7);
  if (v8)
  {
    if (a)
    {
      EC_KEY_free(*a);
      BIGNUM *a = v8;
    }

    *in = (const unsigned __int8 *)v10;
  }

  return v8;
}

int i2d_ECPrivateKey(EC_KEY *a, unsigned __int8 **out)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v4;
  int64x2_t v7[2] = v4;
  v7[0] = v4;
  if (CBB_init((uint64_t)v7, 0LL))
  {
    enc_flagunsigned int s = EC_KEY_get_enc_flags(a);
  }

  CBB_cleanup((uint64_t)v7);
  return -1;
}

int i2o_ECPublicKey(EC_KEY *a, unsigned __int8 **out)
{
  if (a)
  {
    *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = v4;
    int64x2_t v7[2] = v4;
    v7[0] = v4;
    if (CBB_init((uint64_t)v7, 0LL)
      && EC_POINT_point2cbb( (uint64_t)v7,  *(EC_GROUP **)a,  *((EC_POINT **)a + 1),  (point_conversion_form_t)*((_DWORD *)a + 7),  0LL))
    {
      int v5 = CBB_finish_i2d((uint64_t)v7, (void **)out);
      return v5 & ~(v5 >> 31);
    }

    else
    {
      CBB_cleanup((uint64_t)v7);
      return -1;
    }
  }

  else
  {
    ERR_put_error(15, 0, 67, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/ec_extra/ec_asn1.c", 546);
    return 0;
  }

void OUTLINED_FUNCTION_1( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t ed25519_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a2 + 8)) {
    return ed25519_set_pub_raw(a1, *(_OWORD **)a3, *(void *)(a3 + 8));
  }
  ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 119);
  return 0LL;
}

uint64_t ed25519_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v4;
  __int128 v9[2] = v4;
  v9[0] = v4;
  v8[1] = v4;
  v8[2] = v4;
  int64x2_t v7[2] = v4;
  v8[0] = v4;
  v7[0] = v4;
  v7[1] = v4;
  v6[1] = v4;
  void v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v8, (uint64_t)v7, 6u)
    && CBB_add_bytes((uint64_t)v7, &unk_18A0701C4, 3uLL)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v6, 3u)
    && CBB_add_u8((uint64_t)v6, 0)
    && CBB_add_bytes((uint64_t)v6, (const void *)(v3 + 32), 0x20uLL)
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 140);
  return 0LL;
}

BOOL ed25519_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a2 + 8);
  uint64_t v4 = v2[4];
  uint64_t v5 = v2[5];
  uint64_t v6 = v3[4];
  uint64_t v7 = v3[5];
  uint64_t v9 = v2[6];
  uint64_t v8 = v2[7];
  uint64_t v11 = v3[6];
  uint64_t v10 = v3[7];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t ed25519_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 163);
  return 0LL;
}

uint64_t ed25519_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(_BYTE **)(a2 + 8);
  if (v2[64])
  {
    *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v12[1] = v4;
    __int128 v12[2] = v4;
    void v11[2] = v4;
    v12[0] = v4;
    v11[0] = v4;
    v11[1] = v4;
    v10[1] = v4;
    __int128 v10[2] = v4;
    __int128 v9[2] = v4;
    v10[0] = v4;
    v9[0] = v4;
    v9[1] = v4;
    v8[1] = v4;
    v8[2] = v4;
    v8[0] = v4;
    if (CBB_add_asn1(a1, (uint64_t)v12, 0x20000010u)
      && CBB_add_asn1_uint64((uint64_t)v12, 0LL)
      && CBB_add_asn1((uint64_t *)v12, (uint64_t)v11, 0x20000010u)
      && CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 6u)
      && CBB_add_bytes((uint64_t)v10, &unk_18A0701C4, 3uLL)
      && CBB_add_asn1((uint64_t *)v12, (uint64_t)v9, 4u)
      && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 4u)
      && CBB_add_bytes((uint64_t)v8, v2, 0x20uLL)
      && CBB_flush(a1))
    {
      return 1LL;
    }

    int v6 = 105;
    int v7 = 190;
  }

  else
  {
    int v6 = 130;
    int v7 = 173;
  }

  ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", v7);
  return 0LL;
}

uint64_t ed25519_set_priv_raw(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a3 != 32)
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 33);
    return 0LL;
  }

  uint64_t v5 = OPENSSL_malloc(0x41uLL);
  if (!v5) {
    return 0LL;
  }
  int v6 = v5;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v7;
  v10[1] = v7;
  ED25519_keypair_from_seed((uint64_t)v10, v5, a2);
  uint64_t v8 = 1LL;
  *((_BYTE *)v6 + 64) = 1;
  OPENSSL_free(*(void **)(a1 + 8));
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)this + 8) = v6;
  return v8;
}

uint64_t ed25519_set_pub_raw(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if (a3 == 32)
  {
    uint64_t result = (uint64_t)OPENSSL_malloc(0x41uLL);
    if (result)
    {
      uint64_t v6 = result;
      __int128 v7 = a2[1];
      *(_OWORD *)(result + RAND_bytes(buf, 32) = *a2;
      *(_OWORD *)(result + 4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)this + 8) = v7;
      *(_BYTE *)(result + 64) = 0;
      OPENSSL_free(*(void **)(a1 + 8));
      *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)this + 8) = v6;
      return 1LL;
    }
  }

  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 55);
    return 0LL;
  }

  return result;
}

uint64_t ed25519_get_priv_raw(uint64_t a1, _OWORD *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!*(_BYTE *)(v3 + 64))
  {
    int v4 = 130;
    int v5 = 76;
    goto LABEL_6;
  }

  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      int v4 = 100;
      int v5 = 86;
LABEL_6:
      ERR_put_error(6, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", v5);
      return 0LL;
    }

    __int128 v7 = *(_OWORD *)(v3 + 16);
    *a2 = *(_OWORD *)v3;
    a2[1] = v7;
  }

  *a3 = 32LL;
  return 1LL;
}

uint64_t ed25519_get_pub_raw(uint64_t a1, _OWORD *a2, void *a3)
{
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ed25519_asn1.c", 105);
      return 0LL;
    }

    uint64_t v4 = *(void *)(a1 + 8);
    __int128 v5 = *(_OWORD *)(v4 + 48);
    *a2 = *(_OWORD *)(v4 + 32);
    a2[1] = v5;
  }

  *a3 = 32LL;
  return 1LL;
}

uint64_t ed25519_size()
{
  return 64LL;
}

uint64_t ed25519_bits()
{
  return 253LL;
}

void ed25519_free(uint64_t a1)
{
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)this + 8) = 0LL;
}

char *boringssl_ciphers_create_configuration_string(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    if (Mutable)
    {
      uint64_t v6 = Mutable;
      uint64_t v7 = 0LL;
      char v8 = 0;
      do
      {
        uint64_t v9 = v7;
        while (1)
        {
          uint64_t v10 = boringssl_ciphers_value_to_string(*(unsigned __int16 *)(a1 + 2 * v9));
          if (v10) {
            break;
          }
          if (a2 == ++v9)
          {
            if ((v8 & 1) != 0) {
              goto LABEL_14;
            }
            if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
              boringssl_ciphers_create_configuration_string_cold_3();
            }
LABEL_23:
            CFRelease(v6);
            return 0LL;
          }
        }

        uint64_t v11 = v10;
        if ((v8 & 1) != 0) {
          CFStringAppend(v6, @":");
        }
        CFStringAppendCString(v6, v11, 0x8000100u);
        uint64_t v7 = v9 + 1;
        char v8 = 1;
      }

      while (a2 - 1 != v9);
LABEL_14:
      CFIndex v12 = CFStringGetLength(v6) + 1;
      __int128 v13 = (char *)malloc(v12);
      if (!v13)
      {
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
          boringssl_ciphers_create_configuration_string_cold_1();
        }
        goto LABEL_23;
      }

      uint64_t v2 = v13;
      if (CFStringGetCString(v6, v13, v12, 0x8000100u))
      {
        CFRelease(v6);
        return v2;
      }

      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        boringssl_ciphers_create_configuration_string_cold_2();
      }
      CFRelease(v6);
      free(v2);
    }

    return 0LL;
  }

  return v2;
}

  ;
}

void OUTLINED_FUNCTION_2_0( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void boringssl_session_update_eap_metadata(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == -1252936367)
    {
      uint64_t v2 = *(void *)(a1 + 8);
      if (v2)
      {
        if (*(void *)(v2 + 400) && *(_DWORD *)(v2 + 300) == 2)
        {
          uint64_t v9 = 0LL;
          uint64_t v10 = &v9;
          uint64_t v11 = 0x2020000000LL;
          uint64_t v12 = 0LL;
          uint64_t v5 = 0LL;
          uint64_t v6 = &v5;
          uint64_t v7 = 0x2020000000LL;
          uint64_t v8 = 0LL;
          v3[0] = 0LL;
          v3[1] = v3;
          v3[2] = 0x2020000000LL;
          char v4 = 0;
          nw_protocol_options_access_handle();
          if (v6[3] && v10[3])
          {
            if (*(_DWORD *)a1 == -1252936367)
            {
              if (*(void *)(a1 + 8)) {
                nw_protocol_metadata_access_handle();
              }
            }

            nw_protocol_metadata_access_handle();
          }

          _Block_object_dispose(v3, 8);
          _Block_object_dispose(&v5, 8);
          _Block_object_dispose(&v9, 8);
        }
      }
    }
  }

void sub_18759662C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

BOOL __boringssl_session_update_eap_metadata_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return a2 != 0;
  }
  int negotiated_tls_protocol_version = sec_protocol_metadata_get_negotiated_tls_protocol_version(*(sec_protocol_metadata_t *)(a1[7] + 520LL));
  if (*(_BYTE *)(a2 + 360) == 1)
  {
    uint64_t v6 = a1[7];
    if (negotiated_tls_protocol_version == 772)
    {
      if (!v6) {
        goto LABEL_23;
      }
      id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
      if (WeakRetained)
      {
        uint64_t v8 = WeakRetained;
        uint64_t v9 = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1[7] + 16LL));
        uint64_t v2 = (char *)v9[475];
      }

      uint64_t v10 = a1[7];
      if (v10)
      {
        id v11 = objc_loadWeakRetained((id *)(v10 + 16));
        if (v11)
        {
          uint64_t v12 = objc_loadWeakRetained((id *)(a1[7] + 16LL));
          uint64_t v13 = (v12[475] & 1) == 0;
        }

        else
        {
          uint64_t v13 = 1LL;
        }

        if (!(_DWORD)v13) {
          goto LABEL_62;
        }
      }

      else
      {
LABEL_23:
        uint64_t v13 = 1LL;
      }

      if (!g_boringssl_log)
      {
LABEL_62:
        *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = "EXPORTER_EAP_TLS_Key_Material";
        *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = 29LL;
        *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
        return a2 != 0;
      }

      __int128 v30 = (os_log_s *)(id)g_boringssl_log;
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_INFO)) {
        goto LABEL_61;
      }
      uint64_t v31 = a1[7];
      if (v31)
      {
        uint64_t v13 = (uint64_t)objc_loadWeakRetained((id *)(v31 + 16));
        uint64_t v32 = a1[7];
        if (v13)
        {
          BOOL v33 = v32 != 0;
          if (v32)
          {
            uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v32 + 16));
            uint64_t v32 = a1[7];
          }

          else
          {
            uint64_t v2 = 0LL;
          }

          id v40 = v2 + 391;
        }

        else
        {
          BOOL v33 = 0;
          id v40 = &unk_1875F4C23;
        }

        if (v32)
        {
          id v38 = objc_loadWeakRetained((id *)(v32 + 16));
          char v39 = 0;
        }

        else
        {
          id v38 = 0LL;
          char v39 = 1;
        }
      }

      else
      {
        BOOL v33 = 0;
        id v38 = 0LL;
        char v39 = 1;
        id v40 = &unk_1875F4C23;
      }

      int v51 = 136446978;
      int v52 = "boringssl_session_update_eap_metadata_block_invoke";
      __int16 v53 = 1024;
      int v54 = 101;
      __int16 v55 = 2082;
      __int16 v56 = v40;
      __int16 v57 = 2048;
      id v58 = v38;
      _os_log_impl( &dword_187560000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] TLS handshake is complete using TLS 1.3 version",  (uint8_t *)&v51,  0x26u);
      if ((v39 & 1) != 0)
      {
        if (!v33) {
          goto LABEL_59;
        }
      }

      else
      {

        if (!v33)
        {
LABEL_59:
          if (v31) {
LABEL_60:
          }

LABEL_61:
          goto LABEL_62;
        }
      }

      if (!v31) {
        goto LABEL_61;
      }
      goto LABEL_60;
    }

    if (!v6) {
      goto LABEL_24;
    }
    id v22 = objc_loadWeakRetained((id *)(v6 + 16));
    if (v22)
    {
      __int128 v23 = v22;
      char v24 = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1[7] + 16LL));
      uint64_t v2 = (char *)v24[475];
    }

    uint64_t v25 = a1[7];
    if (v25)
    {
      id v26 = objc_loadWeakRetained((id *)(v25 + 16));
      if (v26)
      {
        __int16 v27 = objc_loadWeakRetained((id *)(a1[7] + 16LL));
        uint64_t v28 = (v27[475] & 1) == 0;
      }

      else
      {
        uint64_t v28 = 1LL;
      }

      if (!(_DWORD)v28) {
        goto LABEL_76;
      }
    }

    else
    {
LABEL_24:
      uint64_t v28 = 1LL;
    }

    if (!g_boringssl_log)
    {
LABEL_76:
      *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = "client EAP encryption";
      *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = 21LL;
      return a2 != 0;
    }

    uint64_t v34 = (os_log_s *)(id)g_boringssl_log;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_INFO)) {
      goto LABEL_75;
    }
    uint64_t v35 = a1[7];
    if (v35)
    {
      uint64_t v28 = (uint64_t)objc_loadWeakRetained((id *)(v35 + 16));
      uint64_t v36 = a1[7];
      if (v28)
      {
        BOOL v37 = v36 != 0;
        if (v36)
        {
          uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v36 + 16));
          uint64_t v36 = a1[7];
        }

        else
        {
          uint64_t v2 = 0LL;
        }

        id v43 = v2 + 391;
      }

      else
      {
        BOOL v37 = 0;
        id v43 = &unk_1875F4C23;
      }

      if (v36)
      {
        id v41 = objc_loadWeakRetained((id *)(v36 + 16));
        char v42 = 0;
      }

      else
      {
        id v41 = 0LL;
        char v42 = 1;
      }
    }

    else
    {
      BOOL v37 = 0;
      id v41 = 0LL;
      char v42 = 1;
      id v43 = &unk_1875F4C23;
    }

    int v51 = 136446978;
    int v52 = "boringssl_session_update_eap_metadata_block_invoke";
    __int16 v53 = 1024;
    int v54 = 106;
    __int16 v55 = 2082;
    __int16 v56 = v43;
    __int16 v57 = 2048;
    id v58 = v41;
    _os_log_impl( &dword_187560000,  v34,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] TLS handshake is complete using legacy TLS version",  (uint8_t *)&v51,  0x26u);
    if ((v42 & 1) != 0)
    {
      if (!v37) {
        goto LABEL_73;
      }
    }

    else
    {

      if (!v37)
      {
LABEL_73:
        if (v35) {
LABEL_74:
        }

LABEL_75:
        goto LABEL_76;
      }
    }

    if (!v35) {
      goto LABEL_75;
    }
    goto LABEL_74;
  }

  uint64_t v14 = a1[7];
  if (!v14) {
    goto LABEL_16;
  }
  id v15 = objc_loadWeakRetained((id *)(v14 + 16));
  if (v15)
  {
    int v16 = v15;
    int v17 = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1[7] + 16LL));
    uint64_t v2 = (char *)v17[475];
  }

  uint64_t v18 = a1[7];
  if (v18)
  {
    id v19 = objc_loadWeakRetained((id *)(v18 + 16));
    if (v19)
    {
      __int128 v20 = objc_loadWeakRetained((id *)(a1[7] + 16LL));
      uint64_t v21 = (v20[475] & 1) == 0;
    }

    else
    {
      uint64_t v21 = 1LL;
    }

    if (!(_DWORD)v21) {
      return a2 != 0;
    }
  }

  else
  {
LABEL_16:
    uint64_t v21 = 1LL;
  }

  if (g_boringssl_log)
  {
    id v29 = (id)g_boringssl_log;
    if (!os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_ERROR))
    {
LABEL_29:

      return a2 != 0;
    }

    uint64_t v44 = a1[7];
    if (v44)
    {
      uint64_t v21 = (uint64_t)objc_loadWeakRetained((id *)(v44 + 16));
      uint64_t v50 = a1[7];
      if (v21)
      {
        BOOL v45 = v50 != 0;
        if (v50)
        {
          uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v50 + 16));
          uint64_t v50 = a1[7];
        }

        else
        {
          uint64_t v2 = 0LL;
        }

        unsigned int v48 = v2 + 391;
      }

      else
      {
        BOOL v45 = 0;
        unsigned int v48 = &unk_1875F4C23;
      }

      if (v50)
      {
        id v46 = objc_loadWeakRetained((id *)(v50 + 16));
        char v47 = 0;
      }

      else
      {
        id v46 = 0LL;
        char v47 = 1;
      }
    }

    else
    {
      BOOL v45 = 0;
      id v46 = 0LL;
      char v47 = 1;
      unsigned int v48 = &unk_1875F4C23;
    }

    int v51 = 136446978;
    int v52 = "boringssl_session_update_eap_metadata_block_invoke";
    __int16 v53 = 1024;
    int v54 = 112;
    __int16 v55 = 2082;
    __int16 v56 = v48;
    __int16 v57 = 2048;
    id v58 = v46;
    _os_log_error_impl( &dword_187560000,  (os_log_t)v29,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Unexpected EAP method",  (uint8_t *)&v51,  0x26u);
    if ((v47 & 1) != 0)
    {
      if (!v45) {
        goto LABEL_92;
      }
    }

    else
    {

      if (!v45)
      {
LABEL_92:
        if (!v44) {
          goto LABEL_29;
        }
        goto LABEL_96;
      }
    }

    if (!v44) {
      goto LABEL_29;
    }
LABEL_96:

    goto LABEL_29;
  }

  return a2 != 0;
}

uint64_t __boringssl_session_update_eap_metadata_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v5 = (ssl_st *)malloc(0x80uLL);
  *(void *)(a2 + 320) = v5;
  if (v5)
  {
    if (SSL_export_keying_material( *(bssl **)(*(void *)(a1 + 64) + 400LL),  v5,  0x80uLL,  *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(const void **)(a1 + 72),  *(void *)(a1 + 80),  *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))) {
      return 1LL;
    }
    uint64_t v6 = *(void **)(a2 + 320);
    if (v6) {
      free(v6);
    }
    *(void *)(a2 + 320) = 0LL;
    uint64_t v7 = *(void *)(a1 + 56);
    if (!v7) {
      goto LABEL_18;
    }
    id WeakRetained = objc_loadWeakRetained((id *)(v7 + 16));
    if (WeakRetained)
    {
      uint64_t v9 = WeakRetained;
      uint64_t v10 = (unsigned __int8 *)objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
      uint64_t v2 = (char *)v10[475];
    }

    uint64_t v11 = *(void *)(a1 + 56);
    if (v11)
    {
      id v12 = objc_loadWeakRetained((id *)(v11 + 16));
      if (v12)
      {
        uint64_t v13 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
        uint64_t v14 = (v13[475] & 1) == 0;
      }

      else
      {
        uint64_t v14 = 1LL;
      }

      if (!(_DWORD)v14) {
        return 1LL;
      }
    }

    else
    {
LABEL_18:
      uint64_t v14 = 1LL;
    }

    if (g_boringssl_log)
    {
      id v22 = (os_log_s *)(id)g_boringssl_log;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_29;
      }
      uint64_t v23 = *(void *)(a1 + 56);
      if (v23)
      {
        uint64_t v14 = (uint64_t)objc_loadWeakRetained((id *)(v23 + 16));
        uint64_t v31 = *(void *)(a1 + 56);
        if (v14)
        {
          BOOL v24 = v31 != 0;
          if (v31)
          {
            uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v31 + 16));
            uint64_t v31 = *(void *)(a1 + 56);
          }

          else
          {
            uint64_t v2 = 0LL;
          }

          id v29 = v2 + 391;
        }

        else
        {
          BOOL v24 = 0;
          id v29 = &unk_1875F4C23;
        }

        if (v31)
        {
          id v25 = objc_loadWeakRetained((id *)(v31 + 16));
          char v26 = 0;
        }

        else
        {
          id v25 = 0LL;
          char v26 = 1;
        }
      }

      else
      {
        BOOL v24 = 0;
        id v25 = 0LL;
        char v26 = 1;
        id v29 = &unk_1875F4C23;
      }

      int v33 = 136446978;
      uint64_t v34 = "boringssl_session_update_eap_metadata_block_invoke";
      __int16 v35 = 1024;
      int v36 = 142;
      __int16 v37 = 2082;
      id v38 = v29;
      __int16 v39 = 2048;
      id v40 = v25;
      uint64_t v32 = "%{public}s(%d) %{public}s[%p] EAP key material computation failed";
      goto LABEL_53;
    }
  }

  else
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (!v15) {
      goto LABEL_17;
    }
    id v16 = objc_loadWeakRetained((id *)(v15 + 16));
    if (v16)
    {
      int v17 = v16;
      uint64_t v18 = (unsigned __int8 *)objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
      uint64_t v2 = (char *)v18[475];
    }

    uint64_t v19 = *(void *)(a1 + 56);
    if (v19)
    {
      id v20 = objc_loadWeakRetained((id *)(v19 + 16));
      if (v20)
      {
        uint64_t v21 = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 16LL));
        uint64_t v14 = (v21[475] & 1) == 0;
      }

      else
      {
        uint64_t v14 = 1LL;
      }

      if (!(_DWORD)v14) {
        return 1LL;
      }
    }

    else
    {
LABEL_17:
      uint64_t v14 = 1LL;
    }

    if (g_boringssl_log)
    {
      id v22 = (os_log_s *)(id)g_boringssl_log;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
LABEL_29:

        return 1LL;
      }

      uint64_t v23 = *(void *)(a1 + 56);
      if (v23)
      {
        uint64_t v14 = (uint64_t)objc_loadWeakRetained((id *)(v23 + 16));
        uint64_t v30 = *(void *)(a1 + 56);
        if (v14)
        {
          BOOL v24 = v30 != 0;
          if (v30)
          {
            uint64_t v2 = (char *)objc_loadWeakRetained((id *)(v30 + 16));
            uint64_t v30 = *(void *)(a1 + 56);
          }

          else
          {
            uint64_t v2 = 0LL;
          }

          __int16 v27 = v2 + 391;
        }

        else
        {
          BOOL v24 = 0;
          __int16 v27 = &unk_1875F4C23;
        }

        if (v30)
        {
          id v25 = objc_loadWeakRetained((id *)(v30 + 16));
          char v26 = 0;
        }

        else
        {
          id v25 = 0LL;
          char v26 = 1;
        }
      }

      else
      {
        BOOL v24 = 0;
        id v25 = 0LL;
        char v26 = 1;
        __int16 v27 = &unk_1875F4C23;
      }

      int v33 = 136446978;
      uint64_t v34 = "boringssl_session_update_eap_metadata_block_invoke";
      __int16 v35 = 1024;
      int v36 = 131;
      __int16 v37 = 2082;
      id v38 = v27;
      __int16 v39 = 2048;
      id v40 = v25;
      uint64_t v32 = "%{public}s(%d) %{public}s[%p] EAP key material allocation failed";
LABEL_53:
      _os_log_error_impl(&dword_187560000, v22, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&v33, 0x26u);
      if ((v26 & 1) != 0)
      {
        if (!v24) {
          goto LABEL_55;
        }
      }

      else
      {

        if (!v24)
        {
LABEL_55:
          if (!v23) {
            goto LABEL_29;
          }
          goto LABEL_59;
        }
      }

      if (!v23) {
        goto LABEL_29;
      }
LABEL_59:

      goto LABEL_29;
    }
  }

  return 1LL;
}

uint64_t boringssl_session_handshake_continue_inner(SSL *a1, char a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a1->version != -1252936367) {
    return 0xFFFFFFFFLL;
  }
  methounsigned int d = a1->method;
  if (!method) {
    return 0xFFFFFFFFLL;
  }
  num_cipherunsigned int s = (SSL *)method[1].num_ciphers;
  if (!num_ciphers) {
    return 0xFFFFFFFFLL;
  }
  int v7 = SSL_do_handshake(num_ciphers);
  if (v7 != 1) {
    return boringssl_session_handshake_incomplete(a1, v7, a2);
  }
  uint64_t result = SSL_in_false_start((uint64_t)method[1].num_ciphers);
  if ((_DWORD)result)
  {
    id WeakRetained = objc_loadWeakRetained((id *)&method->ssl_clear);
    if (!WeakRetained
      || (uint64_t v10 = WeakRetained,
          uint64_t v11 = (unsigned __int8 *)objc_loadWeakRetained((id *)&method->ssl_clear),
          uint64_t v2 = (char *)v11[475],
          v11,
          v10,
          (v2 & 1) == 0))
    {
      id v12 = objc_loadWeakRetained((id *)&method->ssl_clear);
      if (v12)
      {
        uint64_t v13 = objc_loadWeakRetained((id *)&method->ssl_clear);
        BOOL v14 = (v13[475] & 1) == 0;
      }

      else
      {
        BOOL v14 = 1;
      }

      if (v14)
      {
        if (g_boringssl_log)
        {
          uint64_t v15 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
          {
            id v16 = objc_loadWeakRetained((id *)&method->ssl_clear);
            if (v16)
            {
              uint64_t v2 = (char *)objc_loadWeakRetained((id *)&method->ssl_clear);
              int v17 = v2 + 391;
            }

            else
            {
              int v17 = &unk_1875F4C23;
            }

            id v18 = objc_loadWeakRetained((id *)&method->ssl_clear);
            int v20 = 136446978;
            uint64_t v21 = "boringssl_session_handshake_continue_inner";
            __int16 v22 = 1024;
            int v23 = 210;
            __int16 v24 = 2082;
            id v25 = v17;
            __int16 v26 = 2048;
            id v27 = v18;
            _os_log_impl( &dword_187560000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Connected in False Start.",  (uint8_t *)&v20,  0x26u);

            if (v16) {
          }
            }
        }
      }
    }

    BYTE5(method[2].ssl_renegotiate_check) |= 1u;
    session = SSL_get_session((const SSL *)method[1].num_ciphers);
    boringssl_session_set_peer_verification_state_from_session((uint64_t)a1, (uint64_t)session);
    boringssl_session_finish_handshake(a1);
    return 0LL;
  }

  return result;
}

uint64_t boringssl_session_handshake_error_print(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  if (*(_DWORD *)a3 != -1252936367) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a3 + 8);
  if (!v3) {
    return 0LL;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    uint64_t v6 = WeakRetained;
    int v7 = objc_loadWeakRetained((id *)(v3 + 16));
    char v8 = v7[475];

    if ((v8 & 1) != 0) {
      return 1LL;
    }
  }

  id v9 = objc_loadWeakRetained((id *)(v3 + 16));
  if (v9)
  {
    uint64_t v10 = objc_loadWeakRetained((id *)(v3 + 16));
    BOOL v11 = (v10[475] & 1) == 0;
  }

  else
  {
    BOOL v11 = 1;
  }

  uint64_t result = 1LL;
  if (v11 && g_boringssl_log)
  {
    uint64_t v13 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      boringssl_session_handshake_error_print_cold_1(v3, a1, v13);
    }

    return 1LL;
  }

  return result;
}

void *boringssl_session_export_secret_with_context( uint64_t a1, size_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (!v6) {
    return 0LL;
  }
  int v7 = *(bssl **)(v6 + 400);
  if (!v7) {
    return 0LL;
  }
  uint64_t v13 = malloc(0x10uLL);
  BOOL v14 = v13;
  if (v13)
  {
    void *v13 = a6;
    uint64_t v15 = (ssl_st *)malloc(a6);
    v14[1] = v15;
    if (!v15)
    {
LABEL_9:
      free(v14);
      return 0LL;
    }

    id v16 = v15;
    if (!SSL_export_keying_material(v7, v15, a6, a3, a2, a5, a4, 1))
    {
      free(v16);
      goto LABEL_9;
    }
  }

  return v14;
}

void *boringssl_session_export_secret(uint64_t a1, size_t a2, const void *a3, size_t a4)
{
  return boringssl_session_export_secret_with_context(a1, a2, a3, 0LL, 0LL, a4);
}

dispatch_data_t boringssl_session_export_secret_data( uint64_t a1, size_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  if (!*(void *)(a1 + 8)) {
    return 0LL;
  }
  uint64_t v6 = boringssl_session_export_secret_with_context(a1, a2, a3, a4, a5, a6);
  if (!v6) {
    return 0LL;
  }
  int v7 = v6;
  char v8 = (void *)v6[1];
  dispatch_data_t v9 = dispatch_data_create(v8, *v6, 0LL, 0LL);
  if (v8) {
    free(v8);
  }
  free(v7);
  return v9;
}

uint64_t boringssl_session_copy_serialized_session(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      boringssl_session_state_copy_serialized_session_state(*(void **)(v1 + 392));
      return objc_claimAutoreleasedReturnValue();
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

dispatch_data_t boringssl_session_copy_authenticator(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  char v8 = v7;
  if (a1 && *(_DWORD *)a1 == -1252936367)
  {
    dispatch_data_t v9 = 0LL;
    if (v7)
    {
      uint64_t v10 = *(void *)(a1 + 8);
      if (v10)
      {
        BOOL v11 = boringssl_identity_create_from_identity(v7);
        if (v11
          && boringssl_context_set_temporary_identity(a1, v8)
          && (BOOL v14 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL,
              uint64_t v15 = 0LL,
              int v12 = SSL_generate_authenticator(*(void *)(v10 + 400), a3, a4, &v15, &v14),
              boringssl_context_set_temporary_identity(a1, 0LL),
              v12))
        {
          dispatch_data_t v9 = dispatch_data_create(v15, (size_t)v14, 0LL, 0LL);
          OPENSSL_free(v15);
        }

        else
        {
          dispatch_data_t v9 = 0LL;
        }
      }
    }
  }

  else
  {
    dispatch_data_t v9 = 0LL;
  }

  return v9;
}

sec_trust_t boringssl_session_copy_authenticator_trust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  sec_trust_t v3 = 0LL;
  if (a3)
  {
    if (a2)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        if (SSL_validate_authenticator(*(void *)(v4 + 400), a2, a3))
        {
          session = SSL_get_session(*(const SSL **)(v4 + 400));
          uint64_t v6 = (unint64_t *)SSL_SESSION_get0_peer_certificates((uint64_t)session);
          id v7 = boringssl_helper_copy_certificates_from_CRYPTO_BUFFERs((void *)v4, v6);
          if (v7)
          {
            char v8 = v7;
            SSLWithKeyUsage = (const void *)SecPolicyCreateSSLWithKeyUsage();
            if (SSLWithKeyUsage)
            {
              uint64_t v10 = SSLWithKeyUsage;
              SecTrustRef trust = 0LL;
              SecTrustCreateWithCertificates(v8, SSLWithKeyUsage, &trust);
              CFRelease(v10);
              CFRelease(v8);
              if (trust)
              {
                sec_trust_t v3 = sec_trust_create(trust);
                CFRelease(trust);
                return v3;
              }
            }

            else
            {
              CFRelease(v8);
            }

            return 0LL;
          }

          id WeakRetained = objc_loadWeakRetained((id *)(v4 + 16));
          if (WeakRetained)
          {
            uint64_t v19 = WeakRetained;
            int v20 = objc_loadWeakRetained((id *)(v4 + 16));
            char v21 = v20[475];

            if ((v21 & 1) != 0) {
              return 0LL;
            }
          }

          id v22 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v22)
          {
            int v23 = objc_loadWeakRetained((id *)(v4 + 16));
            BOOL v24 = (v23[475] & 1) == 0;
          }

          else
          {
            BOOL v24 = 1;
          }

          sec_trust_t v3 = 0LL;
          if (v24 && g_boringssl_log)
          {
            id v25 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              boringssl_session_copy_authenticator_trust_cold_2(v4, v25);
            }
LABEL_30:

            return 0LL;
          }
        }

        else
        {
          id v11 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v11)
          {
            int v12 = v11;
            uint64_t v13 = objc_loadWeakRetained((id *)(v4 + 16));
            char v14 = v13[475];

            if ((v14 & 1) != 0) {
              return 0LL;
            }
          }

          id v15 = objc_loadWeakRetained((id *)(v4 + 16));
          if (v15)
          {
            id v16 = objc_loadWeakRetained((id *)(v4 + 16));
            BOOL v17 = (v16[475] & 1) == 0;
          }

          else
          {
            BOOL v17 = 1;
          }

          sec_trust_t v3 = 0LL;
          if (v17 && g_boringssl_log)
          {
            id v25 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              boringssl_session_copy_authenticator_trust_cold_1(v4, v25);
            }
            goto LABEL_30;
          }
        }
      }
    }
  }

  return v3;
}

uint64_t boringssl_session_get_stack_error(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_DWORD *)a1 != -1252936367) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(v1 + 16));

  if (!WeakRetained) {
    return 0LL;
  }
  id v3 = objc_loadWeakRetained((id *)(v1 + 16));
  uint64_t error = nw_protocol_boringssl_get_error((uint64_t)v3);

  return error;
}

uint64_t boringssl_session_get_current_handshake_state(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0) {
      return *(unsigned int *)(v1 + 304);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_get_ech_was_used(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == -1252936367 && (uint64_t v1 = *(void *)(result + 8)) != 0)
    {
      uint64_t result = *(void *)(v1 + 400);
      if (result) {
        return SSL_ech_accepted(result);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_session_set_ech_config(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    goto LABEL_21;
  }
  uint64_t v5 = 0LL;
  if (v3)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 + 400);
      if (!v7) {
        goto LABEL_21;
      }
      size_t size = dispatch_data_get_size(v3);
      if (!size) {
        goto LABEL_21;
      }
      unint64_t v9 = size;
      uint64_t v5 = (uint64_t)malloc(size);
      if (v5)
      {
        boringssl_helper_dispatch_data_copyout(v4, v5, v9);
        if (SSL_set1_ech_config_list(v7, (unsigned __int8 *)v5, v9))
        {
          free((void *)v5);
          uint64_t v5 = 1LL;
          goto LABEL_22;
        }

        id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
        if (!WeakRetained
          || (id v11 = WeakRetained,
              int v12 = objc_loadWeakRetained((id *)(v6 + 16)),
              char v13 = v12[475],
              v12,
              v11,
              (v13 & 1) == 0))
        {
          id v14 = objc_loadWeakRetained((id *)(v6 + 16));
          if (v14)
          {
            id v15 = objc_loadWeakRetained((id *)(v6 + 16));
            BOOL v16 = (v15[475] & 1) == 0;
          }

          else
          {
            BOOL v16 = 1;
          }

          if (v16)
          {
            if (g_boringssl_log)
            {
              BOOL v17 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                boringssl_session_set_ech_config_cold_1(v6, v17);
              }
            }
          }
        }

        free((void *)v5);
LABEL_21:
        uint64_t v5 = 0LL;
      }
    }
  }

BOOL boringssl_session_can_resume_with_state(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = v3;
  BOOL v5 = 0LL;
  if (v3 && a2) {
    BOOL v5 = (*((_BYTE *)v3 + 559) & 1) != 0 || SSL_SESSION_get_protocol_version(a2) != 772;
  }

  return v5;
}

uint64_t boringssl_session_set_session_state(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1 || *(_DWORD *)a1 != -1252936367) {
    goto LABEL_40;
  }
  uint64_t v5 = 0LL;
  if (v3)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      used_extended_unsigned __int8 master_secret = boringssl_session_state_get_used_extended_master_secret((uint64_t)v3);
      has_remote_addresunsigned int s = boringssl_session_state_has_remote_address(v4, (unsigned __int8 *)(v6 + 224));
      if (used_extended_master_secret || has_remote_address)
      {
        inner_session = boringssl_session_state_create_inner_session((uint64_t)v4, v6);
        if (inner_session)
        {
          BOOL v17 = inner_session;
          if (!boringssl_session_can_resume_with_state((void *)v6, (uint64_t)inner_session))
          {
            id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
            if (!WeakRetained
              || (__int16 v26 = WeakRetained,
                  id v27 = objc_loadWeakRetained((id *)(v6 + 16)),
                  char v28 = v27[475],
                  v27,
                  v26,
                  (v28 & 1) == 0))
            {
              id v29 = objc_loadWeakRetained((id *)(v6 + 16));
              if (v29)
              {
                uint64_t v30 = objc_loadWeakRetained((id *)(v6 + 16));
                BOOL v31 = (v30[475] & 1) == 0;
              }

              else
              {
                BOOL v31 = 1;
              }

              if (v31)
              {
                if (g_boringssl_log)
                {
                  int v33 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
                    boringssl_session_set_session_state_cold_2(v6, v33);
                  }
                }
              }
            }

            SSL_SESSION_free(v17);
            goto LABEL_40;
          }

          SSL_set_session(*(SSL **)(v6 + 400), v17);
          *(_BYTE *)(v6 + 558) |= 0x40u;
          *(_BYTE *)(v6 + 55_Block_object_dispose((const void *)(v29 - 112), 8) = *(_BYTE *)(v6 + 558) & 0x7F | (SSL_SESSION_has_ticket((uint64_t)v17) << 7);
          SSL_SESSION_free(v17);
          uint64_t v5 = 1LL;
        }

        else
        {
          id v18 = objc_loadWeakRetained((id *)(v6 + 16));
          if (v18)
          {
            uint64_t v19 = v18;
            int v20 = objc_loadWeakRetained((id *)(v6 + 16));
            char v21 = v20[475];

            if ((v21 & 1) != 0) {
              goto LABEL_40;
            }
          }

          id v22 = objc_loadWeakRetained((id *)(v6 + 16));
          if (v22)
          {
            int v23 = objc_loadWeakRetained((id *)(v6 + 16));
            BOOL v24 = (v23[475] & 1) == 0;
          }

          else
          {
            BOOL v24 = 1;
          }

          uint64_t v5 = 0LL;
          if (v24 && g_boringssl_log)
          {
            uint64_t v32 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
              boringssl_session_set_session_state_cold_1(v6, v32);
            }
            goto LABEL_32;
          }
        }
      }

      else
      {
        id v9 = objc_loadWeakRetained((id *)(v6 + 16));
        if (v9)
        {
          uint64_t v10 = v9;
          id v11 = objc_loadWeakRetained((id *)(v6 + 16));
          char v12 = v11[475];

          if ((v12 & 1) != 0) {
            goto LABEL_40;
          }
        }

        id v13 = objc_loadWeakRetained((id *)(v6 + 16));
        if (v13)
        {
          id v14 = objc_loadWeakRetained((id *)(v6 + 16));
          BOOL v15 = (v14[475] & 1) == 0;
        }

        else
        {
          BOOL v15 = 1;
        }

        uint64_t v5 = 0LL;
        if (v15 && g_boringssl_log)
        {
          uint64_t v32 = (os_log_s *)(id)g_boringssl_log;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
            boringssl_session_set_session_state_cold_3(v6, v32);
          }
LABEL_32:

LABEL_40:
          uint64_t v5 = 0LL;
        }
      }
    }
  }

  return v5;
}

uint64_t boringssl_private_key_sign_callback( const SSL *a1, uint64_t a2, unint64_t *a3, unint64_t a4, int a5, const void *a6, size_t a7)
{
  id v13 = SSL_get_ex_data(a1, 0);
  if (!v13) {
    return 2LL;
  }
  id v14 = v13;
  if (*(_DWORD *)v13 != -1252936367) {
    return 2LL;
  }
  BOOL v15 = (void *)v13[1];
  if (!v15) {
    return 2LL;
  }
  boringssl_session_update_metadata((uint64_t)v13);
  dispatch_data_t v16 = dispatch_data_create(a6, a7, 0LL, 0LL);
  BOOL v17 = (void *)v15[13];
  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 3221225472LL;
  _OWORD v21[2] = __boringssl_private_key_sign_callback_block_invoke;
  _OWORD v21[3] = &__block_descriptor_40_e45_v20__0__boringssl_concrete_boringssl_ctx_8B16l;
  v21[4] = v14;
  unsigned int v18 = boringssl_identity_private_key_sign(v17, a2, a3, a4, a5, v16, v15, v21);
  if (v18 > 2) {
    uint64_t v19 = 2LL;
  }
  else {
    uint64_t v19 = dword_187603A18[v18];
  }

  return v19;
}

uint64_t boringssl_private_key_decrypt_callback( const SSL *a1, void *a2, size_t *a3, size_t a4, const void *a5, size_t a6)
{
  id v11 = SSL_get_ex_data(a1, 0);
  if (!v11) {
    return 2LL;
  }
  char v12 = v11;
  if (*(_DWORD *)v11 != -1252936367) {
    return 2LL;
  }
  id v13 = (void *)v11[1];
  if (!v13) {
    return 2LL;
  }
  boringssl_session_update_metadata((uint64_t)v11);
  dispatch_data_t v14 = dispatch_data_create(a5, a6, 0LL, 0LL);
  BOOL v15 = (void *)v13[13];
  v19[0] = MEMORY[0x1895F87A8];
  v19[1] = 3221225472LL;
  v19[2] = __boringssl_private_key_decrypt_callback_block_invoke;
  _OWORD v19[3] = &__block_descriptor_40_e45_v20__0__boringssl_concrete_boringssl_ctx_8B16l;
  void v19[4] = v12;
  unsigned int v16 = boringssl_identity_private_key_decrypt(v15, a2, a3, a4, v14, v13, v19);
  if (v16 > 2) {
    uint64_t v17 = 2LL;
  }
  else {
    uint64_t v17 = dword_187603A18[v16];
  }

  return v17;
}

uint64_t boringssl_private_key_complete(const SSL *a1, uint64_t a2, size_t *a3, uint64_t a4)
{
  uint64_t v7 = SSL_get_ex_data(a1, 0);
  if (v7
    && *(_DWORD *)v7 == -1252936367
    && (uint64_t v8 = v7[1]) != 0
    && (unsigned int v9 = boringssl_identity_private_key_complete(*(void **)(v8 + 104), a2, a3, a4), v9 <= 2))
  {
    return dword_187603A18[v9];
  }

  else
  {
    return 2LL;
  }

uint64_t __boringssl_session_apply_protocol_options_for_transport_block_invoke_12( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  xpc_array_get_value(v4, 0LL);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_array_get_value(v4, 1uLL);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v36 = 0LL;
  __int16 v37 = &v36;
  uint64_t v38 = 0x2020000000LL;
  size_t length = 0xAAAAAAAAAAAAAAAALL;
  size_t length = xpc_data_get_length(v5);
  uint64_t v32 = 0LL;
  int v33 = &v32;
  uint64_t v34 = 0x2020000000LL;
  __int16 v35 = (void *)0xAAAAAAAAAAAAAAAALL;
  __int16 v35 = malloc(v37[3]);
  uint64_t v28 = 0LL;
  id v29 = &v28;
  uint64_t v30 = 0x2020000000LL;
  size_t v31 = 0xAAAAAAAAAAAAAAAALL;
  size_t v31 = xpc_data_get_length(v6);
  uint64_t v24 = 0LL;
  id v25 = &v24;
  uint64_t v26 = 0x2020000000LL;
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = malloc(v29[3]);
  unint64_t v27 = (unint64_t)v7;
  uint64_t v8 = (void *)v33[3];
  if (v8)
  {
    if (v7)
    {
      byteunsigned int s = xpc_data_get_bytes(v5, v8, 0LL, v37[3]);
      size_t v10 = xpc_data_get_bytes(v6, (void *)v25[3], 0LL, v29[3]);
      if (bytes == v37[3] && v10 == v29[3])
      {
        id v11 = (const void *)v33[3];
        char v12 = (dispatch_queue_s *)dispatch_workloop_copy_current();
        uint64_t v13 = MEMORY[0x1895F87A8];
        destructor[0] = MEMORY[0x1895F87A8];
        destructor[1] = 3221225472LL;
        destructor[2] = __boringssl_session_apply_protocol_options_for_transport_block_invoke_2;
        destructor[3] = &unk_18A070340;
        destructor[4] = &v36;
        destructor[5] = &v32;
        dispatch_data_t v14 = dispatch_data_create(v11, bytes, v12, destructor);

        BOOL v15 = (const void *)v25[3];
        size_t v16 = v29[3];
        uint64_t v17 = (dispatch_queue_s *)dispatch_workloop_copy_current();
        v22[0] = v13;
        v22[1] = 3221225472LL;
        void v22[2] = __boringssl_session_apply_protocol_options_for_transport_block_invoke_14;
        _OWORD v22[3] = &unk_18A070340;
        unint64_t v22[4] = &v28;
        v22[5] = &v24;
        dispatch_data_t v18 = dispatch_data_create(v15, v16, v17, v22);

        uint64_t v19 = boringssl_psk_create(v14, v18);
        boringssl_psk_cache_add_psk(*(void **)(*(void *)(a1 + 32) + 40LL), v19);

        goto LABEL_13;
      }

      cc_clear();
      int v20 = (void *)v33[3];
      if (v20)
      {
        free(v20);
        v33[3] = 0LL;
      }

      cc_clear();
    }

    else
    {
      free((void *)v33[3]);
      v33[3] = 0LL;
    }

    uint64_t v7 = (void *)v25[3];
  }

  if (v7)
  {
    free(v7);
    v25[3] = 0LL;
  }

void sub_18759881C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void __boringssl_session_apply_protocol_options_for_transport_block_invoke_2(uint64_t a1)
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    __boringssl_session_apply_protocol_options_for_transport_block_invoke_2_cold_1();
  }
  cc_clear();
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v2)
  {
    free(v2);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

void __boringssl_session_apply_protocol_options_for_transport_block_invoke_14(uint64_t a1)
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    __boringssl_session_apply_protocol_options_for_transport_block_invoke_14_cold_1();
  }
  cc_clear();
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v2)
  {
    free(v2);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

const SSL *boringssl_session_psk_client13_ext_callback_handler(const SSL *result)
{
  if (result)
  {
    uint64_t result = (const SSL *)SSL_get_ex_data(result, 0);
    if (result)
    {
      if (result->version == -1252936367 && result->method) {
        return (const SSL *)(nw_protocol_options_access_handle() ^ 1);
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

size_t boringssl_session_server_psk_callback_handler( const SSL *a1, const char *a2, uint64_t a3, unsigned int a4)
{
  if (a1)
  {
    uint64_t v7 = SSL_get_ex_data(a1, 0);
    if (v7)
    {
      if (*(_DWORD *)v7 == -1252936367)
      {
        uint64_t v8 = v7[1];
        if (v8)
        {
          nw_protocol_metadata_access_handle();
          if (a2 && *a2)
          {
            id WeakRetained = objc_loadWeakRetained((id *)(v8 + 16));
            if (!WeakRetained
              || (size_t v10 = WeakRetained,
                  id v11 = objc_loadWeakRetained((id *)(v8 + 16)),
                  char v12 = v11[475],
                  v11,
                  v10,
                  (v12 & 1) == 0))
            {
              id v13 = objc_loadWeakRetained((id *)(v8 + 16));
              if (v13)
              {
                dispatch_data_t v14 = objc_loadWeakRetained((id *)(v8 + 16));
                BOOL v15 = (v14[475] & 1) == 0;
              }

              else
              {
                BOOL v15 = 1;
              }

              if (v15)
              {
                if (g_boringssl_log)
                {
                  uint64_t v28 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
                    boringssl_session_server_psk_callback_handler_cold_3(v8, v28);
                  }
                }
              }
            }

            size_t v29 = strlen(a2);
            dispatch_data_t v30 = dispatch_data_create(a2, v29, 0LL, 0LL);
            psuint64_t k = boringssl_psk_cache_lookup_psk(*(void **)(v8 + 40), v30, *(void **)(v8 + 520));

            if (!psk) {
              goto LABEL_34;
            }
          }

          else
          {
            id v18 = objc_loadWeakRetained((id *)(v8 + 16));
            if (!v18
              || (uint64_t v19 = v18,
                  int v20 = objc_loadWeakRetained((id *)(v8 + 16)),
                  char v21 = v20[475],
                  v20,
                  v19,
                  (v21 & 1) == 0))
            {
              id v22 = objc_loadWeakRetained((id *)(v8 + 16));
              if (v22)
              {
                int v23 = objc_loadWeakRetained((id *)(v8 + 16));
                BOOL v24 = (v23[475] & 1) == 0;
              }

              else
              {
                BOOL v24 = 1;
              }

              if (v24)
              {
                if (g_boringssl_log)
                {
                  id v25 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
                    boringssl_session_server_psk_callback_handler_cold_2(v8, v25);
                  }
                }
              }
            }

            psuint64_t k = boringssl_psk_cache_copy_first_psk(*(void **)(v8 + 40));
            if (!psk)
            {
LABEL_34:
              id v31 = objc_loadWeakRetained((id *)(v8 + 16));
              if (!v31
                || (uint64_t v32 = v31,
                    int v33 = objc_loadWeakRetained((id *)(v8 + 16)),
                    char v34 = v33[475],
                    v33,
                    v32,
                    (v34 & 1) == 0))
              {
                id v35 = objc_loadWeakRetained((id *)(v8 + 16));
                if (v35)
                {
                  uint64_t v36 = objc_loadWeakRetained((id *)(v8 + 16));
                  BOOL v37 = (v36[475] & 1) == 0;
                }

                else
                {
                  BOOL v37 = 1;
                }

                size_t size = 0LL;
                if (!v37 || !g_boringssl_log) {
                  goto LABEL_45;
                }
                uint64_t v38 = (os_log_s *)(id)g_boringssl_log;
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
                  boringssl_session_server_psk_callback_handler_cold_1(v8, v38);
                }
              }

              size_t size = 0LL;
LABEL_45:

              return size;
            }
          }

          unint64_t v27 = (dispatch_data_s *)boringssl_psk_copy_key((id *)psk);
          size_t size = dispatch_data_get_size(v27);
          if (size)
          {
            *(_BYTE *)(v8 + 559) |= 0x80u;
            boringssl_helper_dispatch_data_copyout(v27, a3, a4);
          }

          goto LABEL_45;
        }
      }
    }
  }

  return 0LL;
}

size_t boringssl_session_client_psk_callback_handler( const SSL *a1, const char *a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  if (a1)
  {
    LODWORD(v6) = a6;
    id v11 = SSL_get_ex_data(a1, 0);
    if (v11)
    {
      if (*(_DWORD *)v11 == -1252936367)
      {
        uint64_t v12 = v11[1];
        if (v12)
        {
          nw_protocol_metadata_access_handle();
          id WeakRetained = objc_loadWeakRetained((id *)(v12 + 16));
          dispatch_data_t v14 = WeakRetained;
          if (a2)
          {
            if (!WeakRetained
              || (BOOL v15 = objc_loadWeakRetained((id *)(v12 + 16)),
                  char v16 = v15[475],
                  v15,
                  v14,
                  (v16 & 1) == 0))
            {
              id v17 = objc_loadWeakRetained((id *)(v12 + 16));
              if (v17)
              {
                id v18 = objc_loadWeakRetained((id *)(v12 + 16));
                BOOL v19 = (v18[475] & 1) == 0;
              }

              else
              {
                BOOL v19 = 1;
              }

              if (v19)
              {
                if (g_boringssl_log)
                {
                  uint64_t v26 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
                    boringssl_session_client_psk_callback_handler_cold_3(v12, v26);
                  }
                }
              }
            }

            size_t v27 = strlen(a2);
            dispatch_data_t v28 = dispatch_data_create(a2, v27, 0LL, 0LL);
LABEL_30:
            dispatch_data_t v30 = (id *)boringssl_psk_cache_lookup_psk(*(void **)(v12 + 40), v28, *(void **)(v12 + 520));
            id v31 = v30;
            if (v30)
            {
              uint64_t v32 = (dispatch_data_s *)boringssl_psk_copy_identity(v30);
              int v33 = v32;
              if (v32 && dispatch_data_get_size(v32)) {
                boringssl_helper_dispatch_data_copyout(v33, a3, a4);
              }
              char v34 = (dispatch_data_s *)boringssl_psk_copy_key(v31);
              id v35 = v34;
              if (v34)
              {
                size_t size = dispatch_data_get_size(v34);
                uint64_t v37 = v6;
                else {
                  size_t v6 = size;
                }
                boringssl_helper_dispatch_data_copyout(v35, a5, v37);
              }

              else
              {
                size_t v6 = 0LL;
              }

              *(_BYTE *)(v12 + 559) |= 0x80u;
            }

            else
            {
              id v38 = objc_loadWeakRetained((id *)(v12 + 16));
              if (v38)
              {
                __int16 v39 = v38;
                id v40 = objc_loadWeakRetained((id *)(v12 + 16));
                char v41 = v40[475];

                if ((v41 & 1) != 0)
                {
                  size_t v6 = 0LL;
                  goto LABEL_46;
                }
              }

              id v42 = objc_loadWeakRetained((id *)(v12 + 16));
              if (v42)
              {
                id v43 = objc_loadWeakRetained((id *)(v12 + 16));
                BOOL v44 = (v43[475] & 1) == 0;
              }

              else
              {
                BOOL v44 = 1;
              }

              size_t v6 = 0LL;
              if (!v44 || !g_boringssl_log) {
                goto LABEL_46;
              }
              int v33 = (dispatch_data_s *)(id)g_boringssl_log;
              if (os_log_type_enabled((os_log_t)v33, OS_LOG_TYPE_DEBUG)) {
                boringssl_session_client_psk_callback_handler_cold_1(v12, v33);
              }
              size_t v6 = 0LL;
            }

LABEL_46:
            return v6;
          }

          if (!WeakRetained
            || (char v21 = objc_loadWeakRetained((id *)(v12 + 16)),
                char v22 = v21[475],
                v21,
                v14,
                (v22 & 1) == 0))
          {
            id v23 = objc_loadWeakRetained((id *)(v12 + 16));
            if (v23)
            {
              BOOL v24 = objc_loadWeakRetained((id *)(v12 + 16));
              BOOL v25 = (v24[475] & 1) == 0;
            }

            else
            {
              BOOL v25 = 1;
            }

            dispatch_data_t v28 = 0LL;
            if (!v25 || !g_boringssl_log) {
              goto LABEL_30;
            }
            size_t v29 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
              boringssl_session_client_psk_callback_handler_cold_2(v12, v29);
            }
          }

          dispatch_data_t v28 = 0LL;
          goto LABEL_30;
        }
      }
    }
  }

  return 0LL;
}

void __boringssl_context_start_handshake_timer_block_invoke(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  ++*(void *)(*(void *)(a1 + 32) + 328LL);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if (*(_DWORD *)v2 == -1252936367)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        if ((*(_BYTE *)(v3 + 556) & 0x20) != 0)
        {
          uint64_t v4 = *(void *)(v3 + 400);
          if (!v4
            || (memset(v23, 170, 16), !DTLSv1_get_timeout(v4, (unint64_t *)v23))
            || *(void *)v23
            || *(_DWORD *)&v23[8]
            || (size_t v6 = *(bssl **)(v3 + 400)) != 0LL && DTLSv1_handle_timeout(v6, v5) == 1)
          {
            boringssl_context_start_handshake_timer(v2);
          }

          else
          {
            id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
            if (!WeakRetained
              || (uint64_t v8 = WeakRetained,
                  unsigned int v9 = (unsigned __int8 *)objc_loadWeakRetained((id *)(v3 + 16)),
                  uint64_t v1 = (char *)v9[475],
                  v9,
                  v8,
                  (v1 & 1) == 0))
            {
              id v10 = objc_loadWeakRetained((id *)(v3 + 16));
              if (v10)
              {
                id v11 = objc_loadWeakRetained((id *)(v3 + 16));
                BOOL v12 = (v11[475] & 1) == 0;
              }

              else
              {
                BOOL v12 = 1;
              }

              if (v12)
              {
                if (g_boringssl_log)
                {
                  id v13 = (os_log_s *)(id)g_boringssl_log;
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
                  {
                    id v14 = objc_loadWeakRetained((id *)(v3 + 16));
                    if (v14)
                    {
                      uint64_t v1 = (char *)objc_loadWeakRetained((id *)(v3 + 16));
                      BOOL v15 = v1 + 391;
                    }

                    else
                    {
                      BOOL v15 = &unk_1875F4C23;
                    }

                    id v16 = objc_loadWeakRetained((id *)(v3 + 16));
                    *(_DWORD *)id v23 = 136447234;
                    *(void *)&v23[4] = "boringssl_context_handle_handshake_timer";
                    *(_WORD *)&v23[12] = 1024;
                    *(_DWORD *)&v23[14] = 342;
                    __int16 v24 = 2082;
                    BOOL v25 = v15;
                    __int16 v26 = 2048;
                    id v27 = v16;
                    __int16 v28 = 1024;
                    int v29 = 10;
                    _os_log_impl( &dword_187560000,  v13,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] Handshake took more than %d seconds to complete, closing this session",  v23,  0x2Cu);

                    if (v14) {
                  }
                    }
                }
              }
            }

            id v17 = objc_loadWeakRetained((id *)(v3 + 16));
            uint64_t v18 = v17[40];

            if (v18)
            {
              id v19 = objc_loadWeakRetained((id *)(v3 + 16));
              nw_queue_cancel_source();

              int v20 = objc_loadWeakRetained((id *)(v3 + 16));
              v20[40] = 0LL;
            }

            id v21 = objc_loadWeakRetained((id *)(v3 + 16));
            nw_protocol_boringssl_internal_error(v21, 60);

            id v22 = objc_loadWeakRetained((id *)(v3 + 16));
            nw_protocol_boringssl_disconnect((uint64_t)v22 + 8);
          }
        }
      }
    }
  }

void __boringssl_context_start_handshake_timer_block_invoke_2(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    goto LABEL_7;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(v3 + 16));
  if (WeakRetained)
  {
    uint64_t v5 = WeakRetained;
    size_t v6 = (unsigned __int8 *)objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
    uint64_t v1 = (char *)v6[475];
  }

  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7)
  {
LABEL_7:
    uint64_t v10 = 1LL;
    goto LABEL_10;
  }

  id v8 = objc_loadWeakRetained((id *)(v7 + 16));
  if (v8)
  {
    unsigned int v9 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
    uint64_t v10 = (v9[475] & 1) == 0;
  }

  else
  {
    uint64_t v10 = 1LL;
  }

  if ((_DWORD)v10)
  {
LABEL_10:
    if (!g_boringssl_log) {
      return;
    }
    id v11 = (os_log_s *)(id)g_boringssl_log;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_12;
    }
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12)
    {
      uint64_t v10 = (uint64_t)objc_loadWeakRetained((id *)(v12 + 16));
      uint64_t v17 = *(void *)(a1 + 32);
      if (v10)
      {
        BOOL v13 = v17 != 0;
        if (v17)
        {
          uint64_t v1 = (char *)objc_loadWeakRetained((id *)(v17 + 16));
          uint64_t v17 = *(void *)(a1 + 32);
        }

        else
        {
          uint64_t v1 = 0LL;
        }

        id v16 = v1 + 391;
      }

      else
      {
        BOOL v13 = 0;
        id v16 = &unk_1875F4C23;
      }

      if (v17)
      {
        id v14 = objc_loadWeakRetained((id *)(v17 + 16));
        char v15 = 0;
      }

      else
      {
        id v14 = 0LL;
        char v15 = 1;
      }
    }

    else
    {
      BOOL v13 = 0;
      id v14 = 0LL;
      char v15 = 1;
      id v16 = &unk_1875F4C23;
    }

    int v18 = 136446978;
    id v19 = "boringssl_context_start_handshake_timer_block_invoke_2";
    __int16 v20 = 1024;
    int v21 = 374;
    __int16 v22 = 2082;
    id v23 = v16;
    __int16 v24 = 2048;
    id v25 = v14;
    _os_log_debug_impl( &dword_187560000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Cancelling TLS handshake timer",  (uint8_t *)&v18,  0x26u);
    if ((v15 & 1) != 0)
    {
      if (!v13) {
        goto LABEL_27;
      }
    }

    else
    {

      if (!v13)
      {
LABEL_27:
        if (!v12) {
          goto LABEL_12;
        }
        goto LABEL_31;
      }
    }

    if (!v12)
    {
LABEL_12:

      return;
    }

LABEL_31:
    goto LABEL_12;
  }

    id v25 = 2LL;
  }

  return v10;
}

void __boringssl_private_key_sign_callback_block_invoke(uint64_t a1, void *a2, int a3)
{
  uint64_t v5 = a2;
  if (a3)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (!v6
      || *(_DWORD *)v6 != -1252936367
      || (uint64_t v7 = *(void *)(v6 + 8)) == 0
      || *(_DWORD *)(v7 + 300) <= 3u && (*(_BYTE *)(v7 + 556) & 2) == 0)
    {
      unsigned int v9 = v5;
      id WeakRetained = objc_loadWeakRetained(v5 + 2);
      nw_protocol_boringssl_handshake_negotiate(WeakRetained);

      uint64_t v5 = v9;
    }
  }
}

void __boringssl_private_key_decrypt_callback_block_invoke(uint64_t a1, void *a2, int a3)
{
  uint64_t v5 = a2;
  if (a3)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (!v6
      || *(_DWORD *)v6 != -1252936367
      || (uint64_t v7 = *(void *)(v6 + 8)) == 0
      || *(_DWORD *)(v7 + 300) <= 3u && (*(_BYTE *)(v7 + 556) & 2) == 0)
    {
      unsigned int v9 = v5;
      id WeakRetained = objc_loadWeakRetained(v5 + 2);
      nw_protocol_boringssl_handshake_negotiate(WeakRetained);

      uint64_t v5 = v9;
    }
  }
}

uint64_t __boringssl_session_psk_client13_ext_callback_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  id v4 = *(id *)(a2 + 72);
  uint64_t v5 = v4;
  if (v4 && xpc_array_get_count(v4))
  {
    xpc_array_get_array(v5, 0LL);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v7 = v6;
    if (!v6 || xpc_array_get_count(v6) != 2)
    {
      uint64_t v18 = 0LL;
LABEL_27:

      goto LABEL_28;
    }

    xpc_array_get_value(v7, 0LL);
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t length = xpc_data_get_length(v8);
    xpc_array_get_value(v7, 1uLL);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    size_t v11 = xpc_data_get_length(v10);
    id v12 = *(id *)(a2 + 48);
    BOOL v13 = v12;
    uint64_t v50 = v12;
    if (!v12)
    {
      uint64_t v17 = 0LL;
      goto LABEL_20;
    }

    if (!xpc_array_get_count(v12))
    {
      uint64_t v17 = 0LL;
      BOOL v13 = 0LL;
      goto LABEL_20;
    }

    unsigned int v48 = v10;
    xpc_array_get_value(v13, 0LL);
    id v14 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v15 = MEMORY[0x1895A9BD4]();
    uint64_t v16 = MEMORY[0x1895F92E8];
    if (v15 == MEMORY[0x1895F92E8])
    {
      id v19 = v14;
    }

    else
    {
      if (MEMORY[0x1895A9BD4](v14) != MEMORY[0x1895F9220])
      {
        uint64_t v17 = 0LL;
        goto LABEL_18;
      }

      xpc_array_get_value(v14, 0LL);
      id v19 = (id)objc_claimAutoreleasedReturnValue();
    }

    uint64_t v17 = v19;
    if (v19 && MEMORY[0x1895A9BD4](v19) == v16)
    {
      BOOL v13 = (void *)xpc_string_get_length(v17);
      goto LABEL_19;
    }

BOOL __boringssl_session_server_psk_callback_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = boringssl_psk_cache_copy_psk_object_array(*(void **)(*(void *)(a1 + 32) + 40LL));
    id v4 = *(void **)(a2 + 96);
    *(void *)(a2 + bssl::Array<unsigned short>::~Array(v1 - 96) = v3;
  }

  return a2 != 0;
}

BOOL __boringssl_session_client_psk_callback_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = boringssl_psk_cache_copy_psk_object_array(*(void **)(*(void *)(a1 + 32) + 40LL));
    id v4 = *(void **)(a2 + 96);
    *(void *)(a2 + bssl::Array<unsigned short>::~Array(v1 - 96) = v3;
  }

  return a2 != 0;
}

  ;
}

id OUTLINED_FUNCTION_1_1()
{
  return objc_loadWeakRetained((id *)(v0 + *v1));
}

  ;
}

id OUTLINED_FUNCTION_5(uint64_t a1)
{
  return objc_loadWeakRetained((id *)(a1 + *v1));
}

void OUTLINED_FUNCTION_6( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_7( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

id OUTLINED_FUNCTION_8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return objc_loadWeakRetained((id *)(a1 + a2));
}

  ;
}

  ;
}

  ;
}

id OUTLINED_FUNCTION_12()
{
  return objc_loadWeakRetained((id *)(v0 + *v1));
}

id OUTLINED_FUNCTION_13@<X0>(uint64_t a1@<X8>)
{
  return objc_loadWeakRetained((id *)(v1 + a1));
}

void OUTLINED_FUNCTION_14( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_18( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

id OUTLINED_FUNCTION_20()
{
  return objc_loadWeakRetained((id *)(v0 + *v1));
}

const char *OUTLINED_FUNCTION_21()
{
  return boringssl_helper_get_ssl_error_code_description(v0);
}

double KYBER_generate_key(uint64_t *a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v6[2] = v4;
  _OWORD v6[3] = v4;
  v6[0] = v4;
  v6[1] = v4;
  RAND_bytes((unsigned __int8 *)v6, 64);
  *(void *)&double result = KYBER_generate_key_external_entropy(a1, a2, (uint64_t)v6).n128_u64[0];
  return result;
}

__n128 KYBER_generate_key_external_entropy(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v28 = v5;
  __int128 v27 = v5;
  __int128 v26 = v5;
  __int128 v25 = v5;
  BORINGSSL_keccak((char *)&v25, 0x40uLL, (uint64_t *)a3, 0x20uLL, 1);
  __int128 v6 = v26;
  *(_OWORD *)(a2 + 1bssl::Array<unsigned short>::~Array((uint64_t)this + 536) = v25;
  *(_OWORD *)(a2 + 1bssl::Array<unsigned short>::~Array((uint64_t)this + 552) = v6;
  matrix_expand(a2 + 1600, &v25);
  uint64_t v7 = 0LL;
  __b[0] = v27;
  __b[1] = v28;
  uint64_t v8 = a2 + 6208;
  do
  {
    uint64_t v9 = v7 + 1;
    LOBYTE(__b[2]) = v7;
    scalar_centered_binomial_distribution_eta_2_with_prf(v8, (uint64_t *)__b);
    v8 += 512LL;
    uint64_t v7 = v9;
  }

  while (v9 != 3);
  vector_ntt(a2 + 6208);
  memset(__b, 170, sizeof(__b));
  uint64_t v10 = 0LL;
  __int128 v29 = v27;
  __int128 v30 = v28;
  int v11 = 3;
  do
  {
    int v12 = v11 + 1;
    LOBYTE(v31) = v11;
    scalar_centered_binomial_distribution_eta_2_with_prf((uint64_t)&__b[v10], (uint64_t *)&v29);
    v10 += 32LL;
    int v11 = v12;
  }

  while (v10 != 96);
  vector_ntt((uint64_t)__b);
  bzero((void *)a2, 0x600uLL);
  uint64_t v13 = 0LL;
  uint64_t v14 = a2;
  do
  {
    for (uint64_t i = 0LL; i != 3; ++i)
    {
      *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v60 = v16;
      __int128 v59 = v16;
      __int128 v58 = v16;
      __int128 v57 = v16;
      __int128 v56 = v16;
      __int128 v55 = v16;
      __int128 v54 = v16;
      __int128 v53 = v16;
      __int128 v52 = v16;
      __int128 v51 = v16;
      __int128 v50 = v16;
      __int128 v49 = v16;
      __int128 v48 = v16;
      __int128 v47 = v16;
      __int128 v46 = v16;
      __int128 v45 = v16;
      __int128 v44 = v16;
      __int128 v43 = v16;
      __int128 v42 = v16;
      __int128 v41 = v16;
      __int128 v40 = v16;
      __int128 v39 = v16;
      __int128 v38 = v16;
      __int128 v37 = v16;
      __int128 v36 = v16;
      __int128 v35 = v16;
      __int128 v34 = v16;
      __int128 v33 = v16;
      __int128 v32 = v16;
      __int128 v31 = v16;
      __int128 v30 = v16;
      __int128 v29 = v16;
      scalar_mult((uint64_t)&v29, a2 + 1600 + 1536 * i + (v13 << 9), a2 + 6208 + (i << 9));
      for (uint64_t j = 0LL; j != 512; j += 2LL)
        *(_WORD *)(v14 + j) = reduce_once((unsigned __int16)(*(_WORD *)((char *)&v29 + j) + *(_WORD *)(v14 + j)));
    }

    ++v13;
    v14 += 512LL;
  }

  while (v13 != 3);
  uint64_t v18 = 0LL;
  for (uint64_t k = 0LL; k != 3; ++k)
  {
    for (uint64_t m = 0LL; m != 512; m += 2LL)
    v18 += 32LL;
  }

  *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v31 = v21;
  __int128 v30 = v21;
  __int128 v29 = v21;
  CBB_init_fixed((uint64_t)&v29, (uint64_t)a1, 1184LL);
  BORINGSSL_keccak((char *)(a2 + 1568), 0x20uLL, a1, 0x4A0uLL, 0);
  __n128 result = *(__n128 *)(a3 + 32);
  *(_OWORD *)(a2 + 7760) = *(_OWORD *)(a3 + 48);
  *(__n128 *)(a2 + 7744) = result;
  return result;
}

_DWORD *matrix_expand(uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = 0LL;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  __int128 v4 = a2[1];
  v19[0] = *a2;
  v19[1] = v4;
  do
  {
    for (uint64_t i = 0LL; i != 3; ++i)
    {
      char v20 = v3;
      char v21 = i;
      unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[12] = v6;
      __int128 v17 = v6;
      v16[10] = v6;
      v16[11] = v6;
      v16[8] = v6;
      v16[9] = v6;
      v16[6] = v6;
      v16[7] = v6;
      v16[4] = v6;
      v16[5] = v6;
      _OWORD v16[2] = v6;
      _OWORD v16[3] = v6;
      v16[0] = v6;
      v16[1] = v6;
      BORINGSSL_keccak_init((uint64_t)v16, 2);
      BORINGSSL_keccak_absorb((uint64_t)v16, (uint64_t *)v19, 0x22uLL);
      if (v18) {
        matrix_expand_cold_2();
      }
      if ((void)v17 != 168LL) {
        matrix_expand_cold_1();
      }
      int v7 = 0;
      uint64_t v8 = a1 + 1536 * v3 + (i << 9);
      do
      {
        unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __dst[8] = v9;
        __dst[9] = v9;
        void __dst[6] = v9;
        __dst[7] = v9;
        _OWORD __dst[4] = v9;
        _OWORD __dst[5] = v9;
        __dst[2] = v9;
        void __dst[3] = v9;
        __dst[0] = v9;
        __dst[1] = v9;
        __n128 result = BORINGSSL_keccak_squeeze(v16, (char *)__dst, 0xA8uLL);
        unint64_t v11 = 0LL;
        do
        {
          unsigned int v12 = *((unsigned __int8 *)__dst + v11 + 1);
          unsigned int v13 = *((unsigned __int8 *)__dst + v11) | ((v12 & 0xF) << 8);
          int v14 = *((unsigned __int8 *)__dst + v11 + 2);
          if (v13 <= 0xD00) {
            *(_WORD *)(v8 + 2LL * v7++) = v13;
          }
          unsigned int v15 = (v12 >> 4) | (16 * v14);
          if (v15 <= 0xD00 && v7 <= 255) {
            *(_WORD *)(v8 + 2LL * v7++) = v15;
          }
          if (v11 > 0xA4) {
            break;
          }
          v11 += 3LL;
        }

        while (v7 < 256);
      }

      while (v7 < 256);
    }

    ++v3;
  }

  while (v3 != 3);
  return result;
}

uint64_t vector_ntt(uint64_t result)
{
  uint64_t v16 = result;
  uint64_t v1 = 0LL;
  do
  {
    uint64_t v15 = v1;
    int v2 = 1;
    unsigned int v3 = 256;
    do
    {
      uint64_t v18 = v3 >> 1;
      unsigned int v17 = v2;
      if (v2 >= 1)
      {
        uint64_t v4 = 0LL;
        uint64_t v5 = 0LL;
        uint64_t v6 = v3 & 0x1FE;
        uint64_t v7 = v16;
        uint64_t v8 = v2;
        do
        {
          uint64_t v9 = 0LL;
          int v10 = kNTTRoots[v4 + v8];
          uint64_t v11 = v6;
          uint64_t v12 = v7 + v6;
          do
          {
            __int16 v13 = reduce(*(unsigned __int16 *)(v12 + 2 * v9) * v10);
            __int16 v14 = *(_WORD *)(v7 + 2 * v9);
            *(_WORD *)(v7 + 2 * v9) = reduce_once((unsigned __int16)(v14 + v13));
            __n128 result = reduce_once((unsigned __int16)(v14 - v13 + 3329));
            *(_WORD *)(v12 + 2 * v9++) = result;
          }

          while (v5 + v9 < (unint64_t)(v5 + v18));
          uint64_t v6 = v11;
          v5 += v11;
          ++v4;
          v7 += 4LL * v18;
          uint64_t v8 = v17;
        }

        while (v4 != v17);
      }

      int v2 = 2 * v17;
      unsigned int v3 = v18;
    }

    while ((int)(2 * v17) < 128);
    uint64_t v1 = v15 + 1;
    v16 += 512LL;
  }

  while (v15 != 2);
  return result;
}

uint64_t kyber_marshal_public_key(uint64_t a1, uint64_t a2)
{
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBB_add_space(a1, &v7, 1152LL);
  if ((_DWORD)result)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = (_BYTE *)v7;
    do
    {
      scalar_encode(v6, a2 + v5, 12);
      v6 += 384;
      v5 += 512LL;
    }

    while (v5 != 1536);
    return CBB_add_bytes(a1, (const void *)(a2 + 1536), 0x20uLL) != 0;
  }

  return result;
}

_DWORD *KYBER_encap(uint64_t *a1, char *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[0] = v6;
  v8[1] = v6;
  RAND_bytes((unsigned __int8 *)v8, 32);
  return KYBER_encap_external_entropy(a1, a2, a3, v8);
}

_DWORD *KYBER_encap_external_entropy(uint64_t *a1, char *a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  __int128 v6 = a4[1];
  v12[0] = *a4;
  v12[1] = v6;
  __int128 v7 = *(_OWORD *)(a3 + 1584);
  __int128 v12[2] = *(_OWORD *)(a3 + 1568);
  _OWORD v12[3] = v7;
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = v8;
  v11[1] = v8;
  v10[0] = v8;
  v10[1] = v8;
  BORINGSSL_keccak((char *)v10, 0x40uLL, (uint64_t *)v12, 0x40uLL, 1);
  encrypt_cpa();
  BORINGSSL_keccak((char *)v11, 0x20uLL, a1, 0x440uLL, 0);
  return BORINGSSL_keccak(a2, 0x20uLL, (uint64_t *)v10, 0x40uLL, 3);
}

_BYTE *encrypt_cpa()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  int v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  __int128 v45 = (_BYTE *)v0;
  uint64_t v86 = *MEMORY[0x1895F89C0];
  __int128 v7 = __b;
  memset(__b, 170, sizeof(__b));
  uint64_t v8 = 0LL;
  __int128 v9 = v2[1];
  v85[0] = *v2;
  v85[1] = v9;
  do
  {
    uint64_t v10 = v8 + 1;
    LOBYTE(v85[2]) = v8;
    scalar_centered_binomial_distribution_eta_2_with_prf((uint64_t)v7, (uint64_t *)v85);
    v7 += 512;
    uint64_t v8 = v10;
  }

  while (v10 != 3);
  vector_ntt((uint64_t)__b);
  memset(v85, 170, sizeof(v85));
  uint64_t v11 = 0LL;
  __int128 v12 = v2[1];
  v81[0] = *v2;
  v81[1] = v12;
  int v13 = 3;
  do
  {
    int v14 = v13 + 1;
    char v82 = v13;
    scalar_centered_binomial_distribution_eta_2_with_prf((uint64_t)&v85[v11], (uint64_t *)v81);
    v11 += 32LL;
    int v13 = v14;
  }

  while (v11 != 96);
  __int128 v15 = v2[1];
  v83[0] = *v2;
  v83[1] = v15;
  char v84 = 6;
  *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v47[30] = v16;
  v47[31] = v16;
  v47[28] = v16;
  v47[29] = v16;
  v47[26] = v16;
  v47[27] = v16;
  v47[24] = v16;
  v47[25] = v16;
  v47[22] = v16;
  v47[23] = v16;
  v47[20] = v16;
  v47[21] = v16;
  v47[18] = v16;
  v47[19] = v16;
  v47[16] = v16;
  v47[17] = v16;
  v47[14] = v16;
  v47[15] = v16;
  v47[12] = v16;
  v47[13] = v16;
  v47[10] = v16;
  v47[11] = v16;
  v47[8] = v16;
  v47[9] = v16;
  v47[6] = v16;
  v47[7] = v16;
  v47[4] = v16;
  v47[5] = v16;
  v47[2] = v16;
  v47[3] = v16;
  v47[0] = v16;
  v47[1] = v16;
  scalar_centered_binomial_distribution_eta_2_with_prf((uint64_t)v47, (uint64_t *)v83);
  unsigned int v17 = v81;
  bzero(v81, 0x600uLL);
  for (uint64_t i = 0LL; i != 3; ++i)
  {
    for (uint64_t j = 0LL; j != 3; ++j)
    {
      *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v80 = v20;
      __int128 v79 = v20;
      __int128 v78 = v20;
      __int128 v77 = v20;
      __int128 v76 = v20;
      __int128 v75 = v20;
      __int128 v74 = v20;
      __int128 v73 = v20;
      __int128 v72 = v20;
      __int128 v71 = v20;
      __int128 v70 = v20;
      __int128 v69 = v20;
      __int128 v68 = v20;
      __int128 v67 = v20;
      __int128 v66 = v20;
      __int128 v65 = v20;
      __int128 v64 = v20;
      __int128 v63 = v20;
      __int128 v62 = v20;
      __int128 v61 = v20;
      __int128 v60 = v20;
      __int128 v59 = v20;
      __int128 v58 = v20;
      __int128 v57 = v20;
      __int128 v56 = v20;
      __int128 v55 = v20;
      __int128 v54 = v20;
      __int128 v53 = v20;
      __int128 v52 = v20;
      __int128 v51 = v20;
      __int128 v50 = v20;
      __int128 v49 = v20;
      scalar_mult((uint64_t)&v49, v6 + 1600 + 1536 * i + (j << 9), (uint64_t)&__b[512 * j]);
      for (uint64_t k = 0LL; k != 512; k += 2LL)
    }

    v17 += 32;
  }

  for (uint64_t m = 0LL; m != 96; m += 32LL)
    scalar_inverse_ntt((uint64_t)&v81[m]);
  uint64_t v23 = 0LL;
  for (uint64_t n = 0LL; n != 3; ++n)
  {
    for (iuint64_t i = 0LL; ii != 512; ii += 2LL)
    v23 += 32LL;
  }

  *(void *)&__int128 v26 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v80 = v26;
  __int128 v79 = v26;
  __int128 v78 = v26;
  __int128 v77 = v26;
  __int128 v76 = v26;
  __int128 v75 = v26;
  __int128 v74 = v26;
  __int128 v73 = v26;
  __int128 v72 = v26;
  __int128 v71 = v26;
  __int128 v70 = v26;
  __int128 v69 = v26;
  __int128 v68 = v26;
  __int128 v67 = v26;
  __int128 v66 = v26;
  __int128 v65 = v26;
  __int128 v64 = v26;
  __int128 v63 = v26;
  __int128 v62 = v26;
  __int128 v61 = v26;
  __int128 v60 = v26;
  __int128 v59 = v26;
  __int128 v58 = v26;
  __int128 v57 = v26;
  __int128 v56 = v26;
  __int128 v55 = v26;
  __int128 v54 = v26;
  __int128 v53 = v26;
  __int128 v52 = v26;
  __int128 v51 = v26;
  __int128 v50 = v26;
  __int128 v49 = v26;
  scalar_inner_product(&v49, v6, (uint64_t)__b);
  scalar_inverse_ntt((uint64_t)&v49);
  for (juint64_t j = 0LL; jj != 512; jj += 2LL)
  unint64_t v28 = 0LL;
  *(void *)&__int128 v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v46[30] = v29;
  v46[31] = v29;
  v46[28] = v29;
  v46[29] = v29;
  v46[26] = v29;
  v46[27] = v29;
  v46[24] = v29;
  v46[25] = v29;
  v46[22] = v29;
  v46[23] = v29;
  v46[20] = v29;
  v46[21] = v29;
  v46[18] = v29;
  v46[19] = v29;
  v46[16] = v29;
  v46[17] = v29;
  v46[14] = v29;
  v46[15] = v29;
  v46[12] = v29;
  v46[13] = v29;
  v46[10] = v29;
  v46[11] = v29;
  v46[8] = v29;
  v46[9] = v29;
  v46[6] = v29;
  v46[7] = v29;
  v46[4] = v29;
  v46[5] = v29;
  v46[2] = v29;
  v46[3] = v29;
  __int128 v30 = v46;
  v46[0] = v29;
  v46[1] = v29;
  do
  {
    uint64_t v31 = 0LL;
    unsigned __int8 v32 = *v4;
    do
    {
      *(_WORD *)((char *)v30 + v31) = v32 & 1;
      v32 >>= 1;
      v31 += 2LL;
    }

    while (v31 != 16);
    ++v4;
    ++v30;
    BOOL v33 = v28 >= 0xF8;
    v28 += 8LL;
  }

  while (!v33);
  uint64_t v34 = 0LL;
  uint16x8_t v35 = (uint16x8_t)vdupq_n_s16(0xD01u);
  v36.i64[0] = 0x100000001LL;
  v36.i64[1] = 0x100000001LL;
  do
  {
    uint16x8_t v37 = (uint16x8_t)v46[v34];
    int8x16_t v38 = (int8x16_t)vmull_high_u16(v37, v35);
    int8x16_t v39 = (int8x16_t)vmull_u16(*(uint16x4_t *)v37.i8, *(uint16x4_t *)v35.i8);
    v46[v34++] = vuzp1q_s16( (int16x8_t)vsraq_n_u32((uint32x4_t)vandq_s8(v39, v36), (uint32x4_t)v39, 1uLL),  (int16x8_t)vsraq_n_u32((uint32x4_t)vandq_s8(v38, v36), (uint32x4_t)v38, 1uLL));
  }

  while (v34 != 32);
  for (kuint64_t k = 0LL; kk != 512; kk += 2LL)
  for (muint64_t m = 0LL; mm != 96; mm += 32LL)
    scalar_compress((uint64_t)&v81[mm], 10);
  uint64_t v42 = 0LL;
  __int128 v43 = v45;
  do
  {
    scalar_encode(v43, (uint64_t)&v81[v42], 10);
    v43 += 320;
    v42 += 32LL;
  }

  while (v42 != 96);
  scalar_compress((uint64_t)&v49, 4);
  return scalar_encode(v45 + 960, (uint64_t)&v49, 4);
}

_DWORD *KYBER_decap(char *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v106 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v39 = v6;
  __int128 v40 = v6;
  v38[0] = v6;
  v38[1] = v6;
  memset(__b, 170, sizeof(__b));
  uint64_t v7 = 0LL;
  uint64_t v8 = a2;
  do
  {
    v8 += 320;
    BOOL v9 = v7 == 1024;
    v7 += 512LL;
  }

  while (!v9);
  uint64_t v10 = 0LL;
  uint64_t v11 = __b;
  uint16x8_t v12 = (uint16x8_t)vdupq_n_s16(0xD01u);
  v13.i64[0] = 0x100000001LL;
  v13.i64[1] = 0x100000001LL;
  do
  {
    for (uint64_t i = 0LL; i != 512; i += 16LL)
    {
      uint16x8_t v15 = *(uint16x8_t *)&v11[i];
      uint32x4_t v16 = vmull_u16(*(uint16x4_t *)v15.i8, *(uint16x4_t *)v12.i8);
      uint32x4_t v17 = vmull_high_u16(v15, v12);
      *(int16x8_t *)&v11[i] = vuzp1q_s16( (int16x8_t)vsraq_n_u32( (uint32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v16, 9uLL), v13),  v16,  0xAuLL),  (int16x8_t)vsraq_n_u32( (uint32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v17, 9uLL), v13),  v17,  0xAuLL));
    }

    ++v10;
    v11 += 512;
  }

  while (v10 != 3);
  vector_ntt((uint64_t)__b);
  *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v104 = v18;
  __int128 v103 = v18;
  __int128 v102 = v18;
  __int128 v100 = v18;
  __int128 v101 = v18;
  __int128 v98 = v18;
  __int128 v99 = v18;
  __int128 v96 = v18;
  __int128 v97 = v18;
  __int128 v94 = v18;
  __int128 v95 = v18;
  __int128 v92 = v18;
  __int128 v93 = v18;
  __int128 v90 = v18;
  __int128 v91 = v18;
  __int128 v88 = v18;
  __int128 v89 = v18;
  __int128 v86 = v18;
  __int128 v87 = v18;
  __int128 v84 = v18;
  __int128 v85 = v18;
  __int128 v82 = v18;
  __int128 v83 = v18;
  __int128 v80 = v18;
  __int128 v81 = v18;
  __int128 v78 = v18;
  __int128 v79 = v18;
  __int128 v76 = v18;
  __int128 v77 = v18;
  __int128 v74 = v18;
  __int128 v75 = v18;
  __int128 v73 = v18;
  scalar_decode((uint64_t)&v73, a2 + 960, 4);
  uint64_t v19 = 0LL;
  uint16x8_t v20 = (uint16x8_t)vdupq_n_s16(0xD01u);
  v21.i64[0] = 0x100000001LL;
  v21.i64[1] = 0x100000001LL;
  do
  {
    uint16x8_t v22 = *(uint16x8_t *)((char *)&v73 + v19);
    uint32x4_t v23 = vmull_u16(*(uint16x4_t *)v22.i8, *(uint16x4_t *)v20.i8);
    uint32x4_t v24 = vmull_high_u16(v22, v20);
    *(__int128 *)((char *)&v73 + v19) = (__int128)vuzp1q_s16( (int16x8_t)vsraq_n_u32( (uint32x4_t)vandq_s8( (int8x16_t)vshrq_n_u32(v23, 3uLL),  v21),  v23,  4uLL),  (int16x8_t)vsraq_n_u32( (uint32x4_t)vandq_s8( (int8x16_t)vshrq_n_u32(v24, 3uLL),  v21),  v24,  4uLL));
    v19 += 16LL;
  }

  while (v19 != 512);
  *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v71 = v25;
  __int128 v72 = v25;
  __int128 v69 = v25;
  __int128 v70 = v25;
  __int128 v67 = v25;
  __int128 v68 = v25;
  __int128 v65 = v25;
  __int128 v66 = v25;
  __int128 v63 = v25;
  __int128 v64 = v25;
  __int128 v61 = v25;
  __int128 v62 = v25;
  __int128 v59 = v25;
  __int128 v60 = v25;
  __int128 v57 = v25;
  __int128 v58 = v25;
  __int128 v55 = v25;
  __int128 v56 = v25;
  __int128 v53 = v25;
  __int128 v54 = v25;
  __int128 v51 = v25;
  __int128 v52 = v25;
  __int128 v49 = v25;
  __int128 v50 = v25;
  __int128 v47 = v25;
  __int128 v48 = v25;
  __int128 v45 = v25;
  __int128 v46 = v25;
  __int128 v43 = v25;
  __int128 v44 = v25;
  __int128 v41 = v25;
  __int128 v42 = v25;
  scalar_inner_product(&v41, a3 + 6208, (uint64_t)__b);
  scalar_inverse_ntt((uint64_t)&v41);
  for (uint64_t j = 0LL; j != 512; j += 2LL)
    *(_WORD *)((char *)&v73 + j) = reduce_once((unsigned __int16)(*(_WORD *)((char *)&v73 + j)
  scalar_compress((uint64_t)&v73, 1);
  for (uint64_t k = 0LL; k != 32; ++k)
  {
    uint8x8_t v28 = vshl_u8( (uint8x8_t)vand_s8(vmovn_s16(*((int16x8_t *)&v73 + k)), (int8x8_t)0x101010101010101LL),  (uint8x8_t)0x706050403020100LL);
    *((_BYTE *)v38 + k) = v28.i8[0] | v28.i8[4] | ((v28.i32[0] | v28.i32[1]) >> 16) | ((unsigned __int16)(v28.i16[0] | v28.i16[2] | ((v28.i32[0] | v28.i32[1]) >> 16)) >> 8);
  }

  __int128 v29 = *(_OWORD *)(a3 + 1584);
  __int128 v39 = *(_OWORD *)(a3 + 1568);
  __int128 v40 = v29;
  *(void *)&__int128 v30 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v75 = v30;
  __int128 v76 = v30;
  __int128 v73 = v30;
  __int128 v74 = v30;
  BORINGSSL_keccak((char *)&v73, 0x40uLL, (uint64_t *)v38, 0x40uLL, 1);
  memset(__b, 170, 0x440uLL);
  encrypt_cpa();
  int v31 = CRYPTO_memcmp((char *)a2, __b, 1088LL);
  uint64_t v32 = 0LL;
  *(void *)&__int128 v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v43 = v33;
  __int128 v44 = v33;
  __int128 v41 = v33;
  __int128 v42 = v33;
  unsigned int v34 = 255;
  if (v31) {
    unsigned int v34 = 0;
  }
  int8x16_t v35 = vdupq_n_s8(v34);
  int8x16_t v36 = vdupq_n_s8(~v34);
  do
  {
    *(__int128 *)((char *)&v41 + vRAND_bytes(buf, 32) = (__int128)vorrq_s8( vandq_s8(v35, *(int8x16_t *)((char *)&v73 + v32)),  vandq_s8(v36, *(int8x16_t *)(a3 + 7744 + v32)));
    v32 += 16LL;
  }

  while (v32 != 32);
  BORINGSSL_keccak((char *)&v43, 0x20uLL, (uint64_t *)a2, 0x440uLL, 0);
  return BORINGSSL_keccak(a1, 0x20uLL, (uint64_t *)&v41, 0x40uLL, 3);
}

uint64_t KYBER_parse_public_key(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)*a2;
  unint64_t v5 = a2[1];
  uint64_t result = kyber_parse_public_key_no_hash(a1, a2);
  if ((_DWORD)result)
  {
    if (a2[1])
    {
      return 0LL;
    }

    else
    {
      BORINGSSL_keccak((char *)(a1 + 1568), 0x20uLL, v4, v5, 0);
      return 1LL;
    }
  }

  return result;
}

uint64_t kyber_parse_public_key_no_hash(uint64_t a1, uint64_t *a2)
{
  v10[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  v10[1] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBS_get_bytes(a2, v10, 0x480uLL);
  if ((_DWORD)result)
  {
    unint64_t v5 = v10[0];
    uint64_t result = scalar_decode(a1, v10[0], 12);
    if ((_DWORD)result)
    {
      __int128 v6 = v5 + 384;
      uint64_t v7 = a1 + 512;
      unint64_t v8 = -1LL;
      while (v8 != 1)
      {
        BOOL v9 = scalar_decode(v7, v6, 12);
        ++v8;
        v6 += 384;
        v7 += 512LL;
        if (!v9)
        {
          if (v8 < 2) {
            return 0LL;
          }
          break;
        }
      }

      uint64_t result = CBS_copy_bytes((uint64_t)a2, (void *)(a1 + 1536), 0x20uLL);
      if ((_DWORD)result)
      {
        matrix_expand(a1 + 1600, (_OWORD *)(a1 + 1536));
        return 1LL;
      }
    }
  }

  return result;
}

uint64_t scalar_centered_binomial_distribution_eta_2_with_prf(uint64_t a1, uint64_t *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[6] = v3;
  v10[7] = v3;
  _OWORD v10[4] = v3;
  void v10[5] = v3;
  _OWORD v10[2] = v3;
  _OWORD v10[3] = v3;
  v10[0] = v3;
  v10[1] = v3;
  uint64_t v4 = (unsigned __int8 *)v10;
  BORINGSSL_keccak((char *)v10, 0x80uLL, a2, 0x21uLL, 3);
  unint64_t v5 = 0LL;
  do
  {
    unsigned int v6 = *v4++;
    uint64_t v7 = (_WORD *)(a1 + 2 * v5);
    _WORD *v7 = reduce_once((unsigned __int16)((v6 & 1)
                                       + ((__int16)((_WORD)v6 << 12) >> 15)
                                       + ((__int16)((_WORD)v6 << 13) >> 15)
                                       + ((v6 >> 1) & 1)
                                       + 3329));
    uint64_t result = reduce_once((unsigned __int16)(((v6 >> 4) & 1)
                                          - (v6 >> 7)
                                          + ((v6 >> 5) & 1)
    v7[1] = result;
    BOOL v9 = v5 >= 0xFE;
    v5 += 2LL;
  }

  while (!v9);
  return result;
}

uint64_t reduce_once(unsigned int a1)
{
  if (a1 >> 1 >= 0xD01) {
    reduce_once_cold_1();
  }
  __int16 v1 = a1;
  if (a1 >= 0xD01) {
    __int16 v2 = 0;
  }
  else {
    __int16 v2 = a1;
  }
  return (unsigned __int16)((v1 - 3329) | v2);
}

uint64_t reduce(unsigned int a1)
{
  if (a1 >= 0x1524103) {
    reduce_cold_1();
  }
  return reduce_once((unsigned __int16)(a1 - 3329 * ((5039 * (unint64_t)a1) >> 24)));
}

uint64_t scalar_mult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &kModRoots;
  do
  {
    int v8 = *(unsigned __int16 *)(a2 + v6);
    int v9 = *(unsigned __int16 *)(a3 + v6);
    int v10 = v9 * v8;
    int v11 = *(unsigned __int16 *)(a2 + v6 + 2);
    int v12 = *(unsigned __int16 *)(a3 + v6 + 2);
    int v13 = v11 * v9;
    int v14 = reduce(v12 * v11);
    int v15 = (unsigned __int16)*v7++;
    *(_WORD *)(a1 + v6) = reduce(v10 + v15 * v14);
    uint64_t result = reduce(v13 + v12 * v8);
    *(_WORD *)(a1 + v6 + 2) = result;
    v6 += 4LL;
  }

  while (v6 != 512);
  return result;
}

uint64_t scalar_inner_product(_OWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  do
  {
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10[30] = v7;
    v10[31] = v7;
    v10[28] = v7;
    v10[29] = v7;
    v10[26] = v7;
    v10[27] = v7;
    v10[24] = v7;
    v10[25] = v7;
    v10[22] = v7;
    v10[23] = v7;
    v10[20] = v7;
    v10[21] = v7;
    v10[18] = v7;
    v10[19] = v7;
    v10[16] = v7;
    v10[17] = v7;
    v10[14] = v7;
    v10[15] = v7;
    v10[12] = v7;
    v10[13] = v7;
    v10[10] = v7;
    v10[11] = v7;
    _OWORD v10[8] = v7;
    v10[9] = v7;
    v10[6] = v7;
    v10[7] = v7;
    _OWORD v10[4] = v7;
    void v10[5] = v7;
    _OWORD v10[2] = v7;
    _OWORD v10[3] = v7;
    v10[0] = v7;
    v10[1] = v7;
    scalar_mult((uint64_t)v10, a2 + (v6 << 9), a3 + (v6 << 9));
    for (uint64_t i = 0LL; i != 512; i += 2LL)
    {
      uint64_t result = reduce_once((unsigned __int16)(*(_WORD *)((char *)v10 + i) + *(_WORD *)((char *)a1 + i)));
      *(_WORD *)((char *)a1 + i) = result;
    }

    ++v6;
  }

  while (v6 != 3);
  return result;
}

uint64_t scalar_inverse_ntt(uint64_t a1)
{
  int v2 = 2;
  LODWORD(v3) = 128;
  do
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
    uint64_t v3 = v3 >> 1;
    uint64_t v6 = a1 + 2LL * v2;
    int v13 = 2 * v2;
    uint64_t v14 = v2;
    int v15 = 2 * v2;
    do
    {
      int v7 = kInverseNTTRoots[v4 + v3];
      uint64_t v8 = v5;
      do
      {
        int v9 = *(unsigned __int16 *)(v6 + 2 * v8);
        int v10 = *(unsigned __int16 *)(a1 + 2 * v8);
        *(_WORD *)(a1 + 2 * v_Block_object_dispose((const void *)(v30 - 136), 8) = reduce_once((unsigned __int16)(v10 + v9));
        *(_WORD *)(v6 + 2 * v8++) = reduce((v10 - v9 + 3329) * v7);
      }

      while (v8 < v5 + v14);
      v5 += v13;
      ++v4;
    }

    while (v4 != v3);
    int v2 = v13;
  }

  while (v15 < 256);
  for (uint64_t i = 0LL; i != 512; i += 2LL)
  {
    uint64_t result = reduce(3303 * *(unsigned __int16 *)(a1 + i));
    *(_WORD *)(a1 + i) = result;
  }

  return result;
}

uint64_t scalar_compress(uint64_t result, char a2)
{
  for (uint64_t i = 0LL; i != 512; i += 2LL)
  {
    unsigned int v3 = *(unsigned __int16 *)(result + i) << a2;
    unint64_t v4 = (5039 * (unint64_t)v3) >> 24;
    unsigned int v5 = v3 - 3329 * v4;
    if (v5 >> 1 >= 0xD01) {
      scalar_compress_cold_1();
    }
    if (v5 > 0x680) {
      LOWORD(v4) = v4 + 1;
    }
    if (v5 >> 1 > 0x9C0) {
      LOWORD(v4) = v4 + 1;
    }
    *(_WORD *)(result + i) = v4 & ~(-1 << a2);
  }

  return result;
}

_BYTE *scalar_encode(_BYTE *result, uint64_t a2, int a3)
{
  uint64_t v3 = 0LL;
  int v4 = 0;
  int v5 = 0;
  do
  {
    if (a3 >= 1)
    {
      int v6 = 0;
      unsigned int v7 = *(unsigned __int16 *)(a2 + 2 * v3);
      do
      {
        int v8 = a3 - v6;
        int v9 = 8 - v4;
        if (a3 - v6 >= 8 - v4)
        {
          int v10 = (v7 & kMasks[7 - v4]) << v4;
          int v4 = 0;
          *result++ = v5 | v10;
          int v5 = 0;
        }

        else
        {
          v5 |= (v7 & kMasks[v8 - 1]) << v4;
          v4 += v8;
          int v9 = a3 - v6;
        }

        v6 += v9;
        LOBYTE(v7) = v7 >> v9;
      }

      while (v6 < a3);
    }

    ++v3;
  }

  while (v3 != 256);
  if (v4 > 0) {
    *uint64_t result = v5;
  }
  return result;
}

BOOL scalar_decode(uint64_t a1, unsigned __int8 *a2, int a3)
{
  unint64_t v3 = 0LL;
  BOOL v4 = 0;
  int v5 = 0;
  unsigned int v6 = 0;
  while (a3 < 1)
  {
    LOWORD(v_Block_object_dispose((const void *)(v30 - 136), 8) = 0;
LABEL_12:
    *(_WORD *)(a1 + 2 * v3) = v8;
    BOOL v4 = v3++ > 0xFE;
    if (v3 == 256) {
      return v4;
    }
  }

  int v7 = 0;
  unsigned int v8 = 0;
  do
  {
    if (!v5)
    {
      unsigned int v9 = *a2++;
      unsigned int v6 = v9;
      int v5 = 8;
    }

    int v10 = a3 - v7;
    if (a3 - v7 >= v5) {
      int v10 = v5;
    }
    v8 |= (unsigned __int16)((kMasks[v10 - 1] & v6) << v7);
    v5 -= v10;
    unsigned int v6 = (v6 >> v10);
    v7 += v10;
  }

  while (v7 < a3);
  if (v8 <= 0xD00) {
    goto LABEL_12;
  }
  return v4;
}

uint64_t __nw_protocol_boringssl_write_bytes_block_invoke(uint64_t a1)
{
  return 1LL;
}

void nw_protocol_boringssl_internal_error(void *a1, int a2)
{
  unint64_t v3 = a1;
  BOOL v4 = v3;
  if (v3 && (*((_BYTE *)v3 + 390) & 4) == 0)
  {
    *((_BYTE *)v3 + 390) |= 4u;
    uint64_t v5 = v3[42];
    int v7 = v4;
    if (v5)
    {
      boringssl_context_set_internal_error(v5, a2);
      boringssl_metrics_log_connection_failure(v7[42]);
      boringssl_metrics_log_ech(v7[42]);
      BOOL v4 = v7;
    }

    uint64_t v6 = v4[7];
    if (v6 && (*((_BYTE *)v4 + 388) & 4) != 0)
    {
      (*(void (**)(void))(*(void *)(v6 + 24) + 56LL))();
      BOOL v4 = v7;
    }
  }
}

__int128 *nw_protocol_boringssl_identifier()
{
  if (nw_protocol_boringssl_identifier_onceToken != -1) {
    dispatch_once(&nw_protocol_boringssl_identifier_onceToken, &__block_literal_global_0);
  }
  return &g_boringssl_protocol_identifier;
}

void __nw_protocol_boringssl_identifier_block_invoke()
{
  qword_18C4C5648 = 0LL;
  g_boringssl_protocol_identifier = 0u;
  unk_18C4C5638 = 0u;
  g_boringssl_protocol_callbackunsigned int s = 0u;
  *(_OWORD *)&qword_18C4C5528 = 0u;
  xmmword_18C4C5538 = 0u;
  unk_18C4C5548 = 0u;
  xmmword_18C4C5558 = 0u;
  unk_18C4C5568 = 0u;
  xmmword_18C4C5578 = 0u;
  unk_18C4C5588 = 0u;
  xmmword_18C4C5598 = 0u;
  unk_18C4C55A8 = 0u;
  xmmword_18C4C55B8 = 0u;
  unk_18C4C55C8 = 0u;
  xmmword_18C4C55D8 = 0u;
  unk_18C4C55E8 = 0u;
  xmmword_18C4C55F8 = 0u;
  unk_18C4C5608 = 0u;
  xmmword_18C4C5618 = 0u;
  __strlcpy_chk();
  qword_18C4C5648 = 0x100000004LL;
  nw_protocol_set_default_one_to_one_callbacks();
  *(void *)&g_boringssl_protocol_callbackunsigned int s = nw_protocol_boringssl_add_input_handler;
  *((void *)&g_boringssl_protocol_callbacks + 1) = nw_protocol_boringssl_remove_input_handler;
  *((void *)&xmmword_18C4C5558 + 1) = nw_protocol_boringssl_output_available;
  unk_18C4C5568 = nw_protocol_boringssl_get_input_frames;
  qword_18C4C55D0 = (uint64_t)nw_protocol_boringssl_input_finished;
  *(void *)&xmmword_18C4C55D8 = nw_protocol_boringssl_output_finished;
  qword_18C4C5570 = (uint64_t)nw_protocol_boringssl_get_output_frames;
  *(void *)&xmmword_18C4C5578 = nw_protocol_boringssl_finalize_output_frames;
  qword_18C4C5528 = (uint64_t)nw_protocol_boringssl_replace_input_handler;
  unk_18C4C5530 = nw_protocol_boringssl_connect;
  *(void *)&xmmword_18C4C5538 = nw_protocol_boringssl_disconnect;
  *((void *)&xmmword_18C4C5538 + 1) = nw_protocol_boringssl_connected;
  *(void *)&xmmword_18C4C5618 = nw_protocol_boringssl_reset;
  qword_18C4C55F0 = (uint64_t)nw_protocol_boringssl_waiting_for_output;
  *(void *)&xmmword_18C4C55F8 = nw_protocol_boringssl_copy_info;
  qword_18C4C5550 = (uint64_t)nw_protocol_boringssl_error;
  *(void *)&xmmword_18C4C5558 = nw_protocol_boringssl_input_available;
  nw_protocol_register();
  boringssl_log_open();
}

uint64_t nw_protocol_boringssl_replace_input_handler(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v3 = *(void *)(result + 40);
    if (!v3) {
      return 0LL;
    }
    if ((*(_BYTE *)(v3 + 475) & 1) == 0)
    {
      if (datapath_logging_enabled)
      {
        if (g_boringssl_log)
        {
          uint64_t v12 = result;
          uint64_t v14 = a2;
          uint64_t v11 = a3;
          BOOL v7 = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG);
          a2 = v14;
          BOOL v8 = v7;
          a3 = v11;
          uint64_t result = v12;
          if (v8)
          {
            nw_protocol_boringssl_replace_input_handler_cold_1();
            a3 = v11;
            uint64_t result = v12;
            a2 = v14;
          }
        }
      }
    }

    if (*(void *)(result + 48) == a2)
    {
      *(void *)(result + 4_Block_object_dispose((const void *)(v30 - 136), 8) = a3;
      *(void *)(a3 + RAND_bytes(buf, 32) = result;
      uint64_t v4 = *(void *)(a3 + 24);
      else {
        char v6 = *(_BYTE *)(v3 + 389) & 0xEF;
      }
      *(_BYTE *)(v3 + 389) = v6;
      return 1LL;
    }

    else
    {
      if ((*(_BYTE *)(v3 + 475) & 1) != 0) {
        return 0LL;
      }
      uint64_t v9 = result;
      uint64_t v15 = a2;
      uint64_t result = g_boringssl_log;
      if (g_boringssl_log)
      {
        int v13 = (os_log_s *)g_boringssl_log;
        uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          uint64_t v10 = *(void *)(v9 + 48);
          *(_DWORD *)buf = 136447490;
          uint32x4_t v17 = "nw_protocol_boringssl_replace_input_handler";
          __int16 v18 = 1024;
          int v19 = 1193;
          __int16 v20 = 2082;
          uint64_t v21 = v3 + 391;
          __int16 v22 = 2048;
          uint64_t v23 = v3;
          __int16 v24 = 2048;
          uint64_t v25 = v10;
          __int16 v26 = 2048;
          uint64_t v27 = v15;
          _os_log_error_impl( &dword_187560000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] old input handler does not match (%p != %p)",  buf,  0x3Au);
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t nw_protocol_boringssl_reset(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 475) & 1) == 0
      && datapath_logging_enabled
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
    {
      nw_protocol_boringssl_reset_cold_4();
    }

    nw_protocol_boringssl_cleanup((void *)v2);
    uint64_t v3 = (void *)nw_parameters_copy_context();
    if (v3)
    {
      uint64_t v4 = boringssl_context_create_with_nw_context((void *)v2, v3);
      *(void *)(v2 + 336) = v4;
      if (v4)
      {
        uint64_t v5 = boringssl_bio_create( v2,  (uint64_t)nw_protocol_boringssl_read_bytes,  (uint64_t)nw_protocol_boringssl_write_bytes);
        *(void *)(v2 + 344) = v5;
        if (v5)
        {
          *(_OWORD *)(v2 + bssl::Array<unsigned short>::~Array(v16 + 280) = 0u;
          *(_OWORD *)(v2 + 2bssl::Array<unsigned short>::~Array(v1 - 96) = 0u;
          char v6 = *(void **)(v2 + 368);
          *(void *)(v2 + 36_Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;

          *(void *)(v2 + 376) = 0LL;
          *(_BYTE *)(v2 + 388) &= 0x1Au;
          *(_BYTE *)(v2 + 389) &= 0x18u;
          *(_BYTE *)(v2 + 390) &= 0xF8u;
          uint64_t v7 = *(void *)(a1 + 32);
          else {
            uint64_t v2 = 1LL;
          }
          goto LABEL_23;
        }

        if ((*(_BYTE *)(v2 + 475) & 1) == 0
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          nw_protocol_boringssl_reset_cold_3();
        }
      }

      else if ((*(_BYTE *)(v2 + 475) & 1) == 0 {
             && g_boringssl_log
      }
             && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        nw_protocol_boringssl_reset_cold_2();
      }
    }

    else if ((*(_BYTE *)(v2 + 475) & 1) == 0 {
           && g_boringssl_log
    }
           && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      nw_protocol_boringssl_reset_cold_1();
    }

    uint64_t v2 = 0LL;
LABEL_23:
  }

  return v2;
}

uint64_t __nw_protocol_boringssl_copy_definition_block_invoke()
{
  if (nw_protocol_boringssl_identifier_onceToken != -1) {
    dispatch_once(&nw_protocol_boringssl_identifier_onceToken, &__block_literal_global_0);
  }
  uint64_t v0 = nw_protocol_definition_create_with_identifier();
  __int16 v1 = (void *)nw_protocol_boringssl_copy_definition_definition;
  nw_protocol_boringssl_copy_definition_definitiouint64_t n = v0;

  nw_protocol_definition_set_options_allocator();
  nw_protocol_definition_set_metadata_allocator();
  nw_protocol_definition_set_options_equality_check();
  nw_protocol_definition_set_options_comparator();
  return nw_protocol_definition_set_cache_entry_deallocator();
}

uint64_t nw_protocol_boringssl_get_error(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 384);
  }
  return result;
}

uint64_t nw_protocol_boringssl_write_message(void *a1, unsigned int a2, const void *a3, size_t a4)
{
  id v7 = a1;
  uint64_t v8 = v7;
  if (a2 > 3) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *((void *)v7 + a2 + 35);
  }
  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = 0xAAAAAAAAAAAAAAAALL;
  nw_frame_array_init();
  if ((*(unsigned int (**)(uint64_t, uint64_t, size_t, size_t, uint64_t, void *))(*(void *)(v9 + 24) + 88LL))( v9,  (uint64_t)v8 + 8,  a4,  a4,  1LL,  v15) == 1)
  {
    nw_frame_array_first();
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    if (nw_frame_uses_external_data())
    {
      dispatch_data_t v11 = dispatch_data_create(a3, a4, 0LL, 0LL);
      nw_frame_set_external_data();
    }

    else
    {
      int v13 = (void *)nw_frame_unclaimed_bytes();
      memcpy(v13, a3, a4);
    }

    uint64_t v12 = 0LL;
    if (nw_frame_claim())
    {
      nw_frame_collapse();
      nw_frame_unclaim();
      uint64_t v12 = 1LL;
      nw_frame_array_remove();
      nw_frame_array_append();
    }
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  return v12;
}

uint64_t nw_protocol_boringssl_flush_flight(void *a1)
{
  __int16 v1 = a1;
  if ((nw_frame_array_is_empty() & 1) == 0) {
    (*(void (**)(void))(*(void *)(v1[35] + 24LL) + 96LL))();
  }
  if ((nw_frame_array_is_empty() & 1) == 0) {
    (*(void (**)(void))(*(void *)(v1[36] + 24LL) + 96LL))();
  }
  if ((nw_frame_array_is_empty() & 1) == 0) {
    (*(void (**)(void))(*(void *)(v1[37] + 24LL) + 96LL))();
  }
  if ((nw_frame_array_is_empty() & 1) == 0) {
    (*(void (**)(void))(*(void *)(v1[38] + 24LL) + 96LL))();
  }

  return 1LL;
}

uint64_t nw_protocol_boringssl_send_alert(void *a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  char v6 = v5;
  switch(a2)
  {
    case 0:
      uint64_t v7 = v5[35];
      uint64_t v8 = *(void *)(v7 + 24);
      goto LABEL_4;
    case 1:
      uint64_t v7 = v5[35];
      uint64_t v8 = *(void *)(v6[36] + 24LL);
LABEL_4:
      uint64_t v9 = (void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
      goto LABEL_8;
    case 2:
      uint64_t v10 = v5[37];
      goto LABEL_7;
    case 3:
      uint64_t v10 = v5[38];
LABEL_7:
      uint64_t v9 = (void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 24) + 56LL);
      uint64_t v7 = v5[35];
LABEL_8:
      (*v9)(v7, (uint64_t)(v6 + 1), a3);
      break;
    default:
      break;
  }

  return 1LL;
}

uint64_t nw_protocol_error_print()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    nw_protocol_error_print_cold_1();
  }
  return 1LL;
}

id nw_dispatch_data_create_subrange_map(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = a1;
  uint64_t v8 = v7;
  if (a4)
  {
    if (a3)
    {
      uint64_t v22 = 0LL;
      uint64_t v23 = &v22;
      uint64_t v24 = 0x3032000000LL;
      uint64_t v25 = __Block_byref_object_copy_;
      __int16 v26 = __Block_byref_object_dispose_;
      id v27 = 0LL;
      uint64_t v18 = 0LL;
      int v19 = &v18;
      uint64_t v20 = 0x2020000000LL;
      uint64_t v21 = 0LL;
      uint64_t v14 = 0LL;
      uint64_t v15 = &v14;
      uint64_t v16 = 0x2020000000LL;
      uint64_t v17 = 0LL;
      v13[0] = 0LL;
      v13[1] = v13;
      unint64_t v13[2] = 0x2020000000LL;
      _OWORD v13[3] = 0LL;
      v12[0] = MEMORY[0x1895F87A8];
      v12[1] = 3221225472LL;
      __int128 v12[2] = __nw_dispatch_data_create_subrange_map_block_invoke;
      _OWORD v12[3] = &unk_18A070560;
      v12[8] = a2;
      v12[9] = a3;
      _OWORD v12[4] = &v22;
      v12[5] = &v18;
      v12[6] = &v14;
      v12[7] = v13;
      dispatch_data_apply(v7, v12);
      id v9 = 0LL;
      if (v19[3] == a3)
      {
        *a4 = v15[3];
        id v9 = (id)v23[5];
      }

      _Block_object_dispose(v13, 8);
      _Block_object_dispose(&v14, 8);
      _Block_object_dispose(&v18, 8);
      _Block_object_dispose(&v22, 8);
    }

    else
    {
      id v9 = (id)MEMORY[0x1895F8AA8];
      id v10 = MEMORY[0x1895F8AA8];
    }
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

BOOL __nw_protocol_boringssl_write_frames_block_invoke_129(uint64_t a1, void *a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  uint64_t v25 = 0LL;
  int v24 = 0;
  uint64_t v5 = (uint64_t *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(v4 + 176);
  if (v6)
  {
    uint64_t v25 = *(void *)(v4 + 176);
    int v24 = *(_DWORD *)(v4 + 184);
  }

  else if (nw_frame_uses_external_data())
  {
    nw_frame_get_external_data();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v8 = v7;
    if (v7)
    {
      id v9 = nw_dispatch_data_create_subrange_map(v7, 0LL, 0LL, &v25);
      id v10 = *(void **)(*v5 + 168);
      *(void *)(*v5 + 16_Block_object_dispose((const void *)(v30 - 136), 8) = v9;

      uint64_t v11 = *v5;
      if (*(void *)(*v5 + 168))
      {
        *(void *)(v11 + 176) = v25;
        *(_DWORD *)(*v5 + 184) = 0;
      }

      else if ((*(_BYTE *)(v11 + 475) & 1) == 0)
      {
        uint64_t v21 = (os_log_s *)g_boringssl_log;
        if (g_boringssl_log)
        {
          if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v22 = *v5;
            uint64_t v23 = (void *)(*v5 + 391);
            if (!*v5) {
              uint64_t v23 = &unk_1875F4C23;
            }
            *(_DWORD *)buf = 136447746;
            id v27 = "nw_protocol_boringssl_write_frames_block_invoke";
            __int16 v28 = 1024;
            int v29 = 1046;
            __int16 v30 = 2082;
            int v31 = v23;
            __int16 v32 = 2048;
            uint64_t v33 = v22;
            __int16 v34 = 2112;
            int8x16_t v35 = v8;
            __int16 v36 = 1024;
            int v37 = 0;
            __int16 v38 = 1024;
            int v39 = 0;
            _os_log_error_impl( &dword_187560000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Failed to flatten external data %@ (offset %u, unclaimed %u)",  buf,  0x3Cu);
          }
        }
      }
    }

    uint64_t v6 = v25;
  }

  else
  {
    uint64_t v6 = nw_frame_unclaimed_bytes();
    uint64_t v25 = v6;
  }

  if (v6) {
    BOOL v12 = v24 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    int v13 = (*(uint64_t (**)(void))(*v5 + 88))(*(void *)(*v5 + 336));
    int v14 = v13;
    if (v13 >= 1)
    {
      uint64_t v15 = *(void *)(*v5 + 176);
      if (v15)
      {
        *(void *)(*v5 + 176) = v15 + v13;
        *(_DWORD *)(*v5 + 184) -= v13;
      }

      else
      {
        nw_frame_claim();
      }
    }

    int v16 = v24;
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_19;
    }
    if ((!*v5 || (*(_BYTE *)(*v5 + 475) & 1) == 0) && g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        __nw_protocol_boringssl_write_frames_block_invoke_129_cold_1();
      }
      int v16 = v24;
      if ((v24 & 0x80000000) == 0)
      {
LABEL_19:
        if (v14 < v16) {
          *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
        }
      }
    }
  }

  uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8LL);
  int v18 = *(unsigned __int8 *)(v17 + 24);
  if (*(_BYTE *)(v17 + 24))
  {
    int v19 = *(void **)(*v5 + 168);
    *(void *)(*v5 + 16_Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;

    *(void *)(*v5 + 176) = 0LL;
    *(_DWORD *)(*v5 + 184) = 0;
    nw_frame_array_remove();
    nw_frame_finalize();
  }

  return v18 != 0;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

uint64_t __nw_protocol_boringssl_input_available_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  nw_frame_unclaimed_bytes();
  char v4 = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 272LL) + 16LL))();
  uint64_t v5 = *(void *)(a1 + 32);
  if ((v4 & 1) == 0
    && (!v5 || (*(_BYTE *)(v5 + 475) & 1) == 0)
    && g_boringssl_log
    && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
  {
    __nw_protocol_boringssl_input_available_block_invoke_cold_1();
  }

  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_2(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_3(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_4(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

uint64_t __nw_protocol_boringssl_remove_input_handler_block_invoke_5(uint64_t a1, void *a2)
{
  id v2 = a2;
  nw_frame_array_remove();
  nw_frame_finalize();

  return 1LL;
}

void __nw_protocol_boringssl_get_input_frames_block_invoke(uint64_t a1)
{
  __int16 v1 = (uint64_t *)(a1 + 32);
  if ((boringssl_session_get_state(*(void *)(*(void *)(a1 + 32) + 336LL)) & 0xFFFFFFFE) == 2)
  {
    uint64_t v2 = *v1;
    if ((!*v1 || (*(_BYTE *)(v2 + 475) & 1) == 0) && datapath_logging_enabled && g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG)) {
        __nw_protocol_boringssl_get_input_frames_block_invoke_cold_1();
      }
      uint64_t v2 = *v1;
    }

    *(_BYTE *)(v2 + 388) &= ~0x80u;
    nw_boringssl_read(*v1 + 8);
  }

BOOL __nw_protocol_boringssl_get_input_frames_block_invoke_133(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) >= *(_DWORD *)(a1 + 72)
    || *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) >= *(_DWORD *)(a1 + 76))
  {
LABEL_19:
    BOOL v8 = 0LL;
    goto LABEL_20;
  }

  int v4 = nw_frame_unclaimed_length();
  unsigned int v5 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) + v4;
  unsigned int v6 = *(_DWORD *)(a1 + 76);
  int v7 = v4;
  BOOL v8 = v5 <= v6;
  if (v5 > v6)
  {
    uint64_t v9 = *(void *)(a1 + 48);
    id v10 = v3;
    if (v9)
    {
      uint64_t v11 = *(void *)(v9 + 40);
      if (v11)
      {
        if ((*(_BYTE *)(v11 + 475) & 1) == 0
          && datapath_logging_enabled
          && g_boringssl_log
          && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_DEBUG))
        {
          __nw_protocol_boringssl_get_input_frames_block_invoke_133_cold_3();
        }

        uint64_t v12 = nw_frame_unclaimed_bytes();
        if ((*(_BYTE *)(v11 + 475) & 1) == 0)
        {
          int v13 = (os_log_s *)g_boringssl_log;
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136447490;
              uint64_t v17 = "nw_protocol_boringssl_create_trimmed_input_frame";
              __int16 v18 = 1024;
              int v19 = 1768;
              __int16 v20 = 2082;
              uint64_t v21 = v11 + 391;
              __int16 v22 = 2048;
              uint64_t v23 = v11;
              __int16 v24 = 2048;
              uint64_t v25 = v12;
              __int16 v26 = 1024;
              int v27 = 0;
              _os_log_error_impl( &dword_187560000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Cannot copy frame, buffer=%p length=%u",  buf,  0x36u);
            }
          }
        }
      }
    }

    uint64_t v14 = *(void *)(a1 + 56);
    if ((!v14 || (*(_BYTE *)(v14 + 475) & 1) == 0)
      && g_boringssl_log
      && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
    {
      __nw_protocol_boringssl_get_input_frames_block_invoke_133_cold_1();
    }

    goto LABEL_19;
  }

  if ((*(_BYTE *)(*(void *)(a1 + 56) + 390LL) & 0x10) != 0)
  {
    nw_frame_set_is_wake_packet();
    *(_BYTE *)(*(void *)(a1 + 56) + 390LL) &= ~0x10u;
  }

  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v7;
  nw_frame_array_remove();
  nw_frame_array_append();
LABEL_20:

  return v8;
}

void __nw_protocol_boringssl_begin_connection_block_invoke(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  id v5 = a2;
  nw_protocol_boringssl_internal_error(v5, a4);
  nw_protocol_boringssl_disconnect((uint64_t)v5 + 8);
}

void __nw_protocol_boringssl_begin_connection_block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = a2;
}

BOOL __nw_protocol_boringssl_begin_connection_block_invoke_142(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a2 + 328);
    if (v4)
    {
      *(void *)(*(void *)(a1 + 40) + 28std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)&this->quiet_shutdown, 0LL) = (*(uint64_t (**)(uint64_t, void))(v4 + 16))(v4, 0LL);
      *(void *)(*(void *)(a1 + 40) + 288LL) = (*(uint64_t (**)(void))(*(void *)(a2 + 328) + 16LL))();
      *(void *)(*(void *)(a1 + 40) + 296LL) = (*(uint64_t (**)(void))(*(void *)(a2 + 328) + 16LL))();
      *(void *)(*(void *)(a1 + 40) + 304LL) = (*(uint64_t (**)(void))(*(void *)(a2 + 328) + 16LL))();
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    }
  }

  return a2 != 0;
}

uint64_t __nw_protocol_boringssl_cleanup_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t buffer = (void *)nw_frame_get_buffer();
  if (nw_frame_buffer_get_manager()) {
    nw_mem_buffer_free();
  }
  else {
    free(buffer);
  }
  nw_frame_reset();
  nw_frame_array_remove();

  return 1LL;
}

uint64_t __nw_protocol_boringssl_cleanup_block_invoke_2(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (nw_frame_uses_external_data())
  {
    nw_frame_set_external_data();
  }

  else
  {
    uint64_t buffer = (void *)nw_frame_get_buffer();
    free(buffer);
  }

  nw_frame_reset();
  nw_frame_array_remove();

  return 1LL;
}

  ;
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_4_0( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_5_0(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

void OUTLINED_FUNCTION_7_0( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_10_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_16_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_17_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_19(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

void OUTLINED_FUNCTION_21_0(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose((const void *)(v30 - 136), 8) = a1;
}

const EVP_MD *EVP_md5(void)
{
  return (const EVP_MD *)&EVP_md5_storage;
}

double EVP_md5_init()
{
  EVP_md5_storage = 0x1000000004LL;
  dword_18C6D90B0 = 0;
  qword_18C6D90B8 = (uint64_t)md5_init;
  unk_18C6D90C0 = digest_update_wrapper;
  qword_18C6D90C8 = (uint64_t)digest_final_wrapper;
  *(void *)&double result = 0x40800000040LL;
  qword_18C6D90D0 = 0x40800000040LL;
  return result;
}

const EVP_MD *EVP_sha1(void)
{
  return (const EVP_MD *)&EVP_sha1_storage;
}

double EVP_sha1_init()
{
  EVP_sha1_storage = 0x1400000040LL;
  dword_18C6D90E0 = 0;
  qword_18C6D90E8 = (uint64_t)sha1_init;
  unk_18C6D90F0 = digest_update_wrapper;
  qword_18C6D90F8 = (uint64_t)digest_final_wrapper;
  *(void *)&double result = 0x40800000040LL;
  qword_18C6D9100 = 0x40800000040LL;
  return result;
}

const EVP_MD *EVP_sha224(void)
{
  return (const EVP_MD *)&EVP_sha224_storage;
}

double EVP_sha224_init()
{
  EVP_sha224_storage = 0x1C000002A3LL;
  dword_18C6D9110 = 0;
  qword_18C6D9118 = (uint64_t)sha224_init;
  unk_18C6D9120 = digest_update_wrapper;
  qword_18C6D9128 = (uint64_t)digest_final_wrapper;
  *(void *)&double result = 0x40800000040LL;
  qword_18C6D9130 = 0x40800000040LL;
  return result;
}

double EVP_sha256_init()
{
  EVP_sha256_storage = 0x20000002A0LL;
  dword_18C4C5078 = 0;
  qword_18C4C5080 = (uint64_t)sha256_init;
  unk_18C4C5088 = digest_update_wrapper;
  qword_18C4C5090 = (uint64_t)digest_final_wrapper;
  *(void *)&double result = 0x40800000040LL;
  qword_18C4C5098 = 0x40800000040LL;
  return result;
}

double EVP_sha384_init()
{
  EVP_sha384_storage = 0x30000002A1LL;
  dword_18C4C5038 = 0;
  qword_18C4C5040 = (uint64_t)sha384_init;
  unk_18C4C5048 = digest_update_wrapper;
  qword_18C4C5050 = (uint64_t)digest_final_wrapper;
  *(void *)&double result = 0x40800000080LL;
  qword_18C4C5058 = 0x40800000080LL;
  return result;
}

const EVP_MD *EVP_sha512(void)
{
  return (const EVP_MD *)&EVP_sha512_storage;
}

double EVP_sha512_init()
{
  EVP_sha512_storage = 0x40000002A2LL;
  dword_18C4C48C0 = 0;
  qword_18C4C48C8 = (uint64_t)sha512_init;
  unk_18C4C48D0 = digest_update_wrapper;
  qword_18C4C48D8 = (uint64_t)digest_final_wrapper;
  *(void *)&double result = 0x40800000080LL;
  qword_18C4C48E0 = 0x40800000080LL;
  return result;
}

uint64_t *EVP_md5_sha1()
{
  return &EVP_md5_sha1_storage;
}

double EVP_md5_sha1_init()
{
  EVP_md5_sha1_storage = 0x2400000072LL;
  dword_18C4C48F0 = 0;
  qword_18C4C48F8 = (uint64_t)md5_sha1_init;
  unk_18C4C4900 = md5_sha1_update;
  qword_18C4C4908 = (uint64_t)md5_sha1_final;
  *(void *)&double result = 0x81000000040LL;
  qword_18C4C4910 = 0x81000000040LL;
  return result;
}

uint64_t md5_init(uint64_t a1)
{
  return digest_init(*(void *)(a1 + 8));
}

uint64_t sha1_init(uint64_t a1)
{
  return digest_init(*(void *)(a1 + 8));
}

uint64_t sha224_init(uint64_t a1)
{
  return digest_init(*(void *)(a1 + 8));
}

uint64_t sha512_init(uint64_t a1)
{
  return digest_init(*(void *)(a1 + 8));
}

uint64_t md5_sha1_init(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  digest_init(v1);
  return digest_init(v1 + 1032);
}

uint64_t md5_sha1_update(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  digest_update(v1);
  return digest_update(v1 + 1032);
}

uint64_t md5_sha1_final(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  digest_final(v1);
  return digest_final(v1 + 1032);
}

void OUTLINED_FUNCTION_0_2( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

uint64_t CRYPTO_BUFFER_new(const void *a1, unint64_t a2, void **a3)
{
  return crypto_buffer_new(a1, a2, 0, a3);
}

uint64_t CRYPTO_BUFFER_init_CBS(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  return result;
}

uint64_t lh_CRYPTO_BUFFER_call_hash_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t lh_CRYPTO_BUFFER_call_cmp_func(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t bssl::ssl_get_credential_list(void *a1, void **a2)
{
  uint64_t v4 = a1[1];
  if ((*(_BYTE *)(*a1 + 180LL) & 1) != 0)
  {
    if (*(void *)(v4 + 176) == 1LL && **(_BYTE **)(v4 + 168) == 2 && *(void *)(v4 + 184))
    {
      uint64_t result = bssl::Array<ssl_credential_st *>::Init((uint64_t)a2, 1uLL);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v6 = *(void *)(a1[1] + 184LL);
      goto LABEL_12;
    }
  }

  else if (*(void *)(v4 + 200) == 1LL && **(_BYTE **)(v4 + 192) == 2 && *(void *)(v4 + 208))
  {
    uint64_t result = bssl::Array<ssl_credential_st *>::Init((uint64_t)a2, 1uLL);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v6 = *(void *)(a1[1] + 208LL);
LABEL_12:
    **a2 = v6;
    return 1LL;
  }

  int v7 = *(uint64_t **)(v4 + 32);
  uint64_t result = (*(uint64_t (**)(void *))(v7[4] + 112))(a1);
  if ((_DWORD)result)
  {
    uint64_t v8 = *v7;
    unsigned int v9 = ssl_credential_st::IsComplete((ssl_credential_st *)v7[3]);
    char v10 = v9;
    uint64_t result = bssl::Array<ssl_credential_st *>::Init((uint64_t)a2, v8 + v9);
    if ((_DWORD)result)
    {
      uint64_t v11 = *v7;
      if (*v7)
      {
        uint64_t v12 = 0LL;
        do
        {
          (*a2)[v12] = *(void *)(v7[1] + 8 * v12);
          ++v12;
        }

        while (v11 != v12);
      }

      if ((v10 & 1) != 0) {
        (*a2)[v8] = v7[3];
      }
      return 1LL;
    }
  }

  return result;
}

uint64_t bssl::Array<ssl_credential_st *>::Init(uint64_t a1, unint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
  if (!a2) {
    return 1LL;
  }
  if (a2 >> 61)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 297);
    return 0LL;
  }

  uint64_t result = (uint64_t)OPENSSL_malloc(8 * a2);
  *(void *)a1 = result;
  if (result)
  {
    *(void *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = a2;
    return 1LL;
  }

  return result;
}

void *ssl_credential_st::IsComplete(ssl_credential_st *this)
{
  if (*((_DWORD *)this + 1) == 2) {
    return (void *)(*((void *)this + 1)
  }
                 && (*((void *)this + 2) || *((void *)this + 3))
                 && (*((_DWORD *)this + 1) != 1 || *((void *)this + 7)));
  uint64_t result = (void *)EVP_MD_CTX_md(*((const EVP_MD_CTX **)this + 6));
  if (result)
  {
    uint64_t result = OPENSSL_sk_value(*((unint64_t **)this + 6), 0LL);
    if (result) {
      return (void *)(*((void *)this + 1)
    }
                   && (*((void *)this + 2) || *((void *)this + 3))
                   && (*((_DWORD *)this + 1) != 1 || *((void *)this + 7)));
  }

  return result;
}

uint64_t ssl_credential_st::ssl_credential_st(uint64_t a1, void *a2, CRYPTO_EX_DATA *a3)
{
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0u;
  *(void *)(a1 + 72) = 0LL;
  *(_DWORD *)a1 = 1;
  *(_DWORD *)(a1 + 4) = (_DWORD)a2;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 50) = 0u;
  *(void *)(a1 + 80) = 0LL;
  CRYPTO_new_ex_data(a1 + 88, a2, a3);
  return a1;
}

void sub_18759D9B8(_Unwind_Exception *a1)
{
}

void ssl_credential_st::~ssl_credential_st(ssl_credential_st *this)
{
}

void __clang_call_terminate(void *a1)
{
}

void ssl_credential_st::Dup(ssl_credential_st *this@<X0>, void *a2@<X8>)
{
  int v5 = *((_DWORD *)this + 1);
  uint64_t v4 = (unsigned int *)((char *)this + 4);
  if (v5) {
    ssl_credential_st::Dup();
  }
  uint64_t v6 = bssl::New<ssl_credential_st,bssl::SSLCredentialType>(v4);
  if (!v6) {
    goto LABEL_21;
  }
  int v7 = (EVP_PKEY *)*((void *)this + 1);
  if (v7) {
    EVP_PKEY_up_ref(*((unsigned int **)this + 1));
  }
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)v6 + 1, v7);
  uint64_t v8 = (EVP_PKEY *)*((void *)this + 2);
  if (v8) {
    EVP_PKEY_up_ref(*((unsigned int **)this + 2));
  }
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)v6 + 2, v8);
  unsigned int v9 = (const void *)*((void *)this + 4);
  _OWORD v6[3] = *((void *)this + 3);
  uint64_t v10 = *((void *)this + 5);
  char v11 = bssl::Array<unsigned short>::Init((uint64_t)(v6 + 4), v10);
  char v12 = v11 ^ 1;
  if (!v10) {
    char v12 = 1;
  }
  if ((v12 & 1) == 0) {
    memmove((void *)v6[4], v9, 2 * v10);
  }
  if ((v11 & 1) != 0)
  {
    uint64_t v13 = *((void *)this + 6);
    if (!v13
      || (uint64_t v14 = OPENSSL_sk_deep_copy( v13,  (uint64_t (*)(uint64_t))sk_CRYPTO_BUFFER_call_copy_func,  (uint64_t)buffer_up_ref,  (void (*)(uint64_t))sk_CRYPTO_BUFFER_call_free_func,  (uint64_t)CRYPTO_BUFFER_free),  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)v6 + 6,  v14),  v6[6]))
    {
      uint64_t v15 = (unsigned int *)*((void *)this + 7);
      if (v15) {
        CRYPTO_BUFFER_up_ref(*((void *)this + 7));
      }
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v6 + 7, v15);
      int v16 = (unsigned int *)*((void *)this + 9);
      if (v16) {
        CRYPTO_BUFFER_up_ref(*((void *)this + 9));
      }
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v6 + 9, v16);
      uint64_t v17 = (unsigned int *)*((void *)this + 10);
      if (v17) {
        CRYPTO_BUFFER_up_ref(*((void *)this + 10));
      }
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)v6 + 10, v17);
      *((_WORD *)v6 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = *((_WORD *)this + 32);
LABEL_21:
      *a2 = v6;
      return;
    }
  }

  *a2 = 0LL;
  bssl::RefCounted<ssl_credential_st>::DecRefInternal((ssl_credential_st *)v6);
}

void sub_18759DC44(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( unint64_t **a1, unint64_t *a2)
{
  id v3 = *a1;
  *a1 = a2;
  if (v3) {
    OPENSSL_sk_pop_free_ex( v3,  (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke,  0LL);
  }
}

uint64_t buffer_up_ref(uint64_t a1)
{
  return a1;
}

void ssl_credential_st::ClearCertAndKey(ssl_credential_st *this)
{
  *((void *)this + 3) = 0LL;
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)this + 6,  0LL);
}

BOOL ssl_credential_st::UsesX509(ssl_credential_st *this)
{
  return *((_DWORD *)this + 1) != 2;
}

uint64_t ssl_credential_st::SetLeafCert(uint64_t a1, uint64_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 4);
  if (v3 == 2)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", 188);
    return 0LL;
  }

  *(void *)&__int128 v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CRYPTO_BUFFER_init_CBS(*a2, &v23);
  pkey = (EVP_PKEY *)0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_cert_parse_pubkey(&v23, &pkey);
  if (!pkey) {
    return 0LL;
  }
  int v7 = (bssl *)EVP_PKEY_id((uint64_t)pkey);
  if (!bssl::ssl_is_key_type_supported(v7))
  {
    int v18 = 202;
LABEL_19:
    ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", v18);
    uint64_t v17 = 0LL;
    goto LABEL_20;
  }

  if (EVP_PKEY_id((uint64_t)pkey) == 408 && (bssl::ssl_cert_check_key_usage(&v23, 0) & 1) == 0)
  {
    int v18 = 210;
    goto LABEL_19;
  }

  if (v3 == 1
    || (unsigned int v9 = *(const evp_pkey_st **)(a1 + 16)) == 0LL
    || (bssl::ssl_compare_public_and_private_key(pkey, v9, v8) & 1) != 0)
  {
LABEL_12:
    char v11 = (unint64_t **)(a1 + 48);
    uint64_t v10 = *(unint64_t **)(a1 + 48);
    if (v10
      || (bssl::new_leafless_chain(&v21),
          char v12 = v21,
          uint64_t v21 = 0LL,
          std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)(a1 + 48),  v12),  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&v21, 0LL),  (uint64_t v10 = *v11) != 0LL))
    {
      uint64_t v13 = OPENSSL_sk_value(v10, 0LL);
      CRYPTO_BUFFER_free((unsigned int *)v13);
      uint64_t v14 = *v11;
      uint64_t v15 = *a2;
      *a2 = 0LL;
      OPENSSL_sk_set(v14, 0LL, v15);
      if (v3 != 1)
      {
        int v16 = pkey;
        pkey = 0LL;
        std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(a1 + 8), v16);
      }

      uint64_t v17 = 1LL;
      goto LABEL_20;
    }

    goto LABEL_24;
  }

  if (a3)
  {
    ERR_clear_error();
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(a1 + 16), 0LL);
    goto LABEL_12;
  }

LABEL_24:
  uint64_t v17 = 0LL;
LABEL_20:
  int v19 = pkey;
  pkey = 0LL;
  if (v19) {
    EVP_PKEY_free(v19);
  }
  return v17;
}

  return v7;
}

          ++v11;
          if (!v28) {
            goto LABEL_27;
          }
        }
      }

      else
      {
        uint64_t v13 = __base;
        char v12 = v6;
LABEL_27:
        qsort(v13, __nel, 2uLL, (int (__cdecl *)(const void *, const void *))bssl::compare_uint16_t);
        if (v9 < 4)
        {
LABEL_33:
          if (v12 < v6 && bssl::ssl_protocol_version(*a1, v17) >= 0x304)
          {
            *((_DWORD *)a1 + 396) |= 0x100000u;
            *((_WORD *)a1 + 364) = *(_WORD *)(*(void *)(v5 + 712) + 24 * v12 + 16);
          }

          int v7 = 1LL;
          goto LABEL_38;
        }

        int v18 = 2LL;
        if (v10 > 2) {
          int v18 = v9 >> 1;
        }
        int v19 = (unsigned __int16 *)((char *)__base + 2);
        __int16 v20 = *(unsigned __int16 *)__base;
        uint64_t v21 = v18 - 1;
        while (1)
        {
          __int128 v23 = *v19++;
          __int16 v22 = v23;
          if (v20 == v23) {
            break;
          }
          __int16 v20 = v22;
          if (!--v21) {
            goto LABEL_33;
          }
        }
      }
    }

    int v7 = 0LL;
LABEL_38:
    OPENSSL_free(__base);
  }

  return v7;
}

  *(void *)(v5 + 216) = v3;
  return result;
}

void sub_18759DED4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void bssl::new_leafless_chain(unint64_t **a1@<X8>)
{
  int v3 = OPENSSL_sk_new_null();
  int v5 = v3;
  if (v3 && OPENSSL_sk_push(v3, 0LL))
  {
    uint64_t v4 = v5;
    int v5 = 0LL;
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *a1 = v4;
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&v5, 0LL);
}

void sub_18759DF50(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const EVP_MD_CTX *ssl_credential_st::ClearIntermediateCerts(ssl_credential_st *this)
{
  uint64_t result = (const EVP_MD_CTX *)*((void *)this + 6);
  if (result)
  {
    uint64_t result = (const EVP_MD_CTX *)EVP_MD_CTX_md(result);
    if ((unint64_t)result >= 2)
    {
      do
      {
        int v3 = (unsigned int *)OPENSSL_sk_pop(*((uint64_t **)this + 6));
        CRYPTO_BUFFER_free(v3);
        uint64_t result = (const EVP_MD_CTX *)EVP_MD_CTX_md(*((const EVP_MD_CTX **)this + 6));
      }

      while ((unint64_t)result > 1);
    }
  }

  return result;
}

unint64_t *ssl_credential_st::AppendIntermediateCert(uint64_t a1, unsigned int **a2)
{
  if (*(_DWORD *)(a1 + 4) == 2)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", 250);
    return 0LL;
  }

  uint64_t v4 = (unint64_t **)(a1 + 48);
  uint64_t result = *(unint64_t **)(a1 + 48);
  if (result
    || (bssl::new_leafless_chain(&v7),
        int v5 = v7,
        int v7 = 0LL,
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](v4, v5),
        std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&v7, 0LL),
        (uint64_t result = *v4) != 0LL))
  {
    uint64_t v6 = *a2;
    *a2 = 0LL;
    if (!OPENSSL_sk_push(result, (uint64_t)v6))
    {
      if (v6) {
        CRYPTO_BUFFER_free(v6);
      }
      return 0LL;
    }

    return (unint64_t *)1;
  }

  return result;
}

void sub_18759E074( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
}

void *bssl::New<ssl_credential_st,bssl::SSLCredentialType>(unsigned int *a1)
{
  uint64_t result = OPENSSL_malloc(0x60uLL);
  if (result) {
    return (void *)ssl_credential_st::ssl_credential_st((uint64_t)result, (void *)*a1, v3);
  }
  return result;
}

void *SSL_CREDENTIAL_new_raw_public_key()
{
  unsigned int v1 = 2;
  return bssl::New<ssl_credential_st,bssl::SSLCredentialType>(&v1);
}

void SSL_CREDENTIAL_free(ssl_credential_st *a1)
{
  if (a1) {
    bssl::RefCounted<ssl_credential_st>::DecRefInternal(a1);
  }
}

void bssl::RefCounted<ssl_credential_st>::DecRefInternal(ssl_credential_st *a1)
{
  if (CRYPTO_refcount_dec_and_test_zero((unsigned int *)a1))
  {
    ssl_credential_st::~ssl_credential_st(a1);
    OPENSSL_free(v2);
  }

uint64_t SSL_CREDENTIAL_set1_private_key(uint64_t a1, evp_pkey_st *a2, const evp_pkey_st *a3)
{
  int v5 = *(const EVP_PKEY **)(a1 + 8);
  if (!v5 || (uint64_t result = bssl::ssl_compare_public_and_private_key(v5, a2, a3), (_DWORD)result))
  {
    if (a2) {
      EVP_PKEY_up_ref((unsigned int *)a2);
    }
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(a1 + 16), a2);
    *(void *)(a1 + 24) = 0LL;
    return 1LL;
  }

  return result;
}

uint64_t SSL_CREDENTIAL_set_private_key_method(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = a2;
  return 1LL;
}

BOOL SSL_CREDENTIAL_set1_cert_chain(ssl_credential_st *a1, uint64_t *a2, unint64_t a3)
{
  if (!a3 || *((_DWORD *)a1 + 1) == 2)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", 320);
    return 0LL;
  }

  uint64_t v6 = (unsigned int *)*a2;
  if (*a2) {
    CRYPTO_BUFFER_up_ref(*a2);
  }
  uint64_t v15 = v6;
  char v7 = ssl_credential_st::SetLeafCert((uint64_t)a1, (uint64_t *)&v15, 0);
  if (v15) {
    CRYPTO_BUFFER_free(v15);
  }
  if ((v7 & 1) == 0) {
    return 0LL;
  }
  ssl_credential_st::ClearIntermediateCerts(a1);
  if (a3 >= 2)
  {
    BOOL v8 = 0;
    uint64_t v10 = 1LL;
    do
    {
      char v11 = (unsigned int *)a2[v10];
      if (v11) {
        CRYPTO_BUFFER_up_ref(a2[v10]);
      }
      uint64_t v14 = v11;
      appendeunsigned int d = ssl_credential_st::AppendIntermediateCert((uint64_t)a1, &v14);
      uint64_t v13 = v14;
      uint64_t v14 = 0LL;
      if (v13) {
        CRYPTO_BUFFER_free(v13);
      }
      if ((appended & 1) == 0) {
        break;
      }
      BOOL v8 = ++v10 >= a3;
    }

    while (a3 != v10);
  }

  else
  {
    return 1;
  }

  return v8;
}

void sub_18759E2D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t SSL_CREDENTIAL_set1_raw_public_key(uint64_t a1, EVP_PKEY *this, const evp_pkey_st *a3)
{
  if (*(_DWORD *)(a1 + 4) != 2)
  {
    int v9 = 66;
    int v10 = 395;
LABEL_8:
    ERR_put_error(16, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", v10);
    return 0LL;
  }

  if (!this)
  {
    int v9 = 137;
    int v10 = 400;
    goto LABEL_8;
  }

  int v5 = *(const evp_pkey_st **)(a1 + 16);
  if (!v5 || (uint64_t result = bssl::ssl_compare_public_and_private_key(this, v5, a3), (_DWORD)result))
  {
    EVP_PKEY_up_ref((unsigned int *)this);
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)(a1 + 8), this);
    BOOL v8 = *(void **)(a1 + 32);
    char v7 = (void *)(a1 + 32);
    OPENSSL_free(v8);
    void *v7 = 0LL;
    v7[1] = 0LL;
    OPENSSL_free(0LL);
    return 1LL;
  }

  return result;
}

void sub_18759E3B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t SSL_CREDENTIAL_set1_ocsp_response(uint64_t a1, unsigned int *a2)
{
  if (*(_DWORD *)(a1 + 4) == 2)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", 418);
    return 0LL;
  }

  else
  {
    if (a2) {
      CRYPTO_BUFFER_up_ref((uint64_t)a2);
    }
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(a1 + 80), a2);
    return 1LL;
  }

uint64_t SSL_CREDENTIAL_set1_signed_cert_timestamp_list(uint64_t a1, unsigned int *a2)
{
  if (*(_DWORD *)(a1 + 4) == 2)
  {
    int v2 = 66;
    int v3 = 429;
LABEL_8:
    ERR_put_error(16, 0, v2, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_credential.cc", v3);
    return 0LL;
  }

  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  CRYPTO_BUFFER_init_CBS((uint64_t)a2, &v7);
  if ((bssl::ssl_is_sct_list_valid(&v7) & 1) == 0)
  {
    int v2 = 269;
    int v3 = 436;
    goto LABEL_8;
  }

  if (a2) {
    CRYPTO_BUFFER_up_ref((uint64_t)a2);
  }
  std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)(a1 + 72), a2);
  return 1LL;
}

uint64_t bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Push( unint64_t *a1, ssl_credential_st **a2)
{
  uint64_t v4 = bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::MaybeGrow(a1);
  if ((_DWORD)v4)
  {
    int v5 = (ssl_credential_st **)(a1[1] + 8 * *a1);
    uint64_t v6 = *a2;
    *a2 = 0LL;
    std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100](v5, v6);
    ++*a1;
  }

  return v4;
}

uint64_t sk_CRYPTO_BUFFER_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](EVP_PKEY **a1, EVP_PKEY *a2)
{
  int v3 = *a1;
  *a1 = a2;
  if (v3) {
    EVP_PKEY_free(v3);
  }
}

void std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]( unsigned int **a1, unsigned int *a2)
{
  int v3 = *a1;
  *a1 = a2;
  if (v3) {
    CRYPTO_BUFFER_free(v3);
  }
}

void std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]( ssl_credential_st **a1, ssl_credential_st *a2)
{
  int v3 = *a1;
  *a1 = a2;
  if (v3) {
    bssl::RefCounted<ssl_credential_st>::DecRefInternal(v3);
  }
}

uint64_t bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::MaybeGrow( unint64_t *a1)
{
  uint64_t v1 = (uint64_t)(a1 + 1);
  unint64_t v2 = a1[2];
  if (!v2) {
    return bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Init((uint64_t *)a1 + 1, 0x10uLL);
  }
  if (*a1 < v2) {
    return 1LL;
  }
  if ((v2 & 0x8000000000000000LL) != 0)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 412);
    return 0LL;
  }

  else
  {
    unint64_t v12 = 0LL;
    unint64_t v13 = 0LL;
    uint64_t v4 = bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Init((uint64_t *)&v12, 2 * v2);
    if ((_DWORD)v4)
    {
      if (a1[2])
      {
        uint64_t v6 = 0LL;
        unint64_t v7 = 0LL;
        do
        {
          unint64_t v8 = a1[1];
          int v9 = (ssl_credential_st **)(v12 + v6);
          int v10 = *(ssl_credential_st **)(v8 + 8 * v7);
          *(void *)(v8 + 8 * v7) = 0LL;
          std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100](v9, v10);
          ++v7;
          v6 += 8LL;
        }

        while (v7 < a1[2]);
      }

      bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Reset(v1, 0LL, 0LL);
      unint64_t v11 = v13;
      a1[1] = v12;
      a1[2] = v11;
      unint64_t v12 = 0LL;
      unint64_t v13 = 0LL;
    }

    bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array((uint64_t)&v12);
  }

  return v4;
}

void sub_18759E6DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Init( uint64_t *a1, unint64_t a2)
{
  if (!a2) {
    return 1LL;
  }
  if (a2 >> 61)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/internal.h", 297);
    return 0LL;
  }

  uint64_t result = (uint64_t)OPENSSL_malloc(8 * a2);
  *a1 = result;
  if (result)
  {
    a1[1] = a2;
    bzero((void *)result, 8 * a2);
    return 1LL;
  }

  return result;
}

void bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Reset( uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v6 = 0LL;
    unint64_t v7 = 0LL;
    do
    {
      std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]( (ssl_credential_st **)(*(void *)a1 + v6),  0LL);
      ++v7;
      v6 += 8LL;
    }

    while (v7 < *(void *)(a1 + 8));
  }

  OPENSSL_free(*(void **)a1);
  *(void *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = a3;
}

uint64_t bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(uint64_t a1)
{
  return a1;
}

void std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]( SSL_SESSION **a1, SSL_SESSION *a2)
{
  int v3 = *a1;
  *a1 = a2;
  if (v3) {
    SSL_SESSION_free(v3);
  }
}

void std::unique_ptr<err_save_state_st,bssl::internal::Deleter>::reset[abi:ne180100]( uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    ERR_SAVE_STATE_free(v3);
  }
}

void std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](BUF_MEM **a1, BUF_MEM *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    BUF_MEM_free(v3);
  }
}

void std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]( bssl::SSLAEADContext **a1, bssl::SSLAEADContext *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::SSLAEADContext::~SSLAEADContext(v3);
    OPENSSL_free(v4);
  }

void std::unique_ptr<bssl::SSL_HANDSHAKE,bssl::internal::Deleter>::reset[abi:ne180100]( bssl::SSL_HANDSHAKE **a1, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(v3);
    OPENSSL_free(v4);
  }

void std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](void **a1, void *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    OPENSSL_free(v3);
  }
}

void std::unique_ptr<bssl::SSL3_STATE,bssl::internal::Deleter>::reset[abi:ne180100]( bssl::SSL3_STATE **a1, bssl::SSL3_STATE *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::SSL3_STATE::~SSL3_STATE(v3);
    OPENSSL_free(v4);
  }

void bssl::hm_fragment::~hm_fragment(bssl::hm_fragment *this)
{
}

uint64_t bssl::dtls1_open_handshake( uint64_t a1, unint64_t *a2, char *a3, unsigned __int8 *a4, unint64_t a5)
{
  char v37 = -86;
  int8x16_t v35 = 0LL;
  uint64_t v36 = 0LL;
  uint64_t result = bssl::dtls_open_record((bssl *)a1, &v37, (uint64_t)&v35, a2, a3, a4, a5);
  if ((_DWORD)result) {
    return result;
  }
  if (v37 == 20)
  {
    if (**(void **)(*(void *)(a1 + 48) + 264LL))
    {
      int v29 = 318;
      goto LABEL_57;
    }

    if (v36 != 1 || *v35 != 1)
    {
      int v27 = 103;
      int v28 = 324;
      goto LABEL_64;
    }

    **(_BYTE **)(a1 + 56) |= 1u;
    bssl::ssl_do_msg_callback(a1, 0LL, 20LL, (uint64_t)v35, v36);
    return 0LL;
  }

  if (v37 != 22)
  {
    if (v37 == 23)
    {
      if (**(void **)(*(void *)(a1 + 48) + 264LL)) {
        return 1LL;
      }
      int v29 = 305;
    }

    else
    {
      int v29 = 340;
    }

void sub_18759EE44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  unsigned int v13 = va_arg(va1, bssl::hm_fragment *);
  std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::hm_fragment **)va, 0LL);
  CBB_cleanup((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t bssl::dtls1_parse_fragment(uint64_t *a1, uint64_t a2, void *a3)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  uint64_t result = CBS_get_u8(a1, (_BYTE *)a2);
  if ((_DWORD)result)
  {
    uint64_t result = CBS_get_u24(a1, (int *)(a2 + 4));
    if ((_DWORD)result)
    {
      uint64_t result = CBS_get_u16((unsigned __int16 **)a1, (_WORD *)(a2 + 8));
      if ((_DWORD)result)
      {
        uint64_t result = CBS_get_u24(a1, (int *)(a2 + 12));
        if ((_DWORD)result)
        {
          unint64_t v7 = (int *)(a2 + 16);
          uint64_t result = CBS_get_u24(a1, v7);
          if ((_DWORD)result) {
            return CBS_get_bytes(a1, a3, *v7) != 0;
          }
        }
      }
    }
  }

  return result;
}

void bssl::dtls1_hm_fragment_mark(bssl *this, unint64_t a2, unint64_t a3)
{
  if (a2 > a3
    || ((unint64_t v4 = *((unsigned int *)this + 1), (v5 = *((void *)this + 2)) != 0) ? (v6 = v4 >= a3) : (v6 = 0), !v6))
  {
    bssl::dtls1_hm_fragment_mark();
  }

  if (!(_DWORD)v4) {
    bssl::dtls1_hm_fragment_mark();
  }
  if (a2 == a3) {
    return;
  }
  unint64_t v7 = a2 >> 3;
  int v8 = -1 << (a2 & 7);
  if (a2 >> 3 == a3 >> 3)
  {
    int v9 = v8 & ~(-1 << (a3 & 7));
    unint64_t v10 = (_BYTE *)(v5 + v7);
LABEL_15:
    *v10 |= v9;
    goto LABEL_16;
  }

  unint64_t v11 = a3 >> 3;
  *(_BYTE *)(v5 + v7) |= v8;
  unint64_t v12 = v7 + 1;
  if (v7 + 1 < a3 >> 3)
  {
    do
      *(_BYTE *)(*((void *)this + 2) + v12++) = -1;
    while (v11 != v12);
  }

  if ((a3 & 7) != 0)
  {
    int v9 = ~(-1 << (a3 & 7));
    unint64_t v10 = (_BYTE *)(*((void *)this + 2) + v11);
    goto LABEL_15;
  }

uint64_t bssl::dtls1_get_message(SSL *ssl, uint64_t a2)
{
  uint64_t v2 = *(void *)&ssl->server;
  uint64_t v3 = *(void *)(v2
                 + 8LL
                 * (unsigned __int16)(*(_WORD *)(v2 + 50)
                                    - 7
                                    * ((((unsigned __int16)(*(_WORD *)(v2 + 50)
                                                          - ((9363 * *(unsigned __int16 *)(v2 + 50)) >> 16)) >> 1)
  if (!v3 || *(void *)(v3 + 16)) {
    return 0LL;
  }
  *(_BYTE *)(a2 + 1) = *(_BYTE *)v3;
  uint64_t v6 = *(void *)(v3 + 8);
  uint64_t v7 = *(unsigned int *)(v3 + 4);
  *(void *)(a2 + _Block_object_dispose((const void *)(v30 - 136), 8) = v6 + 12;
  *(void *)(a2 + 16) = v7;
  uint64_t v8 = (v7 + 12);
  *(void *)(a2 + 24) = v6;
  *(void *)(a2 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v8;
  *(_BYTE *)a2 = 0;
  if ((*((_BYTE *)ssl->handshake_func + 220) & 0x10) == 0)
  {
    bssl::ssl_do_msg_callback((uint64_t)ssl, 0LL, 22LL, v6, v8);
    *((_WORD *)ssl->handshake_func + 110) |= 0x10u;
  }

  return 1LL;
}

void bssl::dtls1_next_message(bssl *this, ssl_st *a2)
{
  if ((*(_WORD *)(*((void *)this + 6) + 220LL) & 0x10) == 0) {
    bssl::dtls1_next_message();
  }
  uint64_t v3 = *((void *)this + 7);
  uint64_t v4 = v3
     + 8LL
     * (unsigned __int16)(*(_WORD *)(v3 + 50)
                        - 7
                        * ((((unsigned __int16)(*(_WORD *)(v3 + 50)
  uint64_t v7 = *(void *)(v4 + 72);
  uint64_t v5 = (bssl::hm_fragment **)(v4 + 72);
  uint64_t v6 = v7;
  if (!v7 || *(void *)(v6 + 16)) {
    bssl::dtls1_next_message();
  }
  std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100](v5, 0LL);
  uint64_t v8 = *((void *)this + 6);
  ++*(_WORD *)(*((void *)this + 7) + 50LL);
  *(_WORD *)(v8 + 220) &= ~0x10u;
  int v9 = (_BYTE *)*((void *)this + 7);
  if ((*v9 & 2) != 0) {
    *v9 |= 4u;
  }
}

void std::unique_ptr<bssl::hm_fragment,bssl::internal::Deleter>::reset[abi:ne180100]( bssl::hm_fragment **a1, bssl::hm_fragment *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::hm_fragment::~hm_fragment(v3);
    OPENSSL_free(v4);
  }

BOOL bssl::dtls_has_unprocessed_handshake_data(bssl *this, const ssl_st *a2)
{
  unint64_t v2 = 0LL;
  uint64_t v3 = *((void *)this + 7);
  unsigned __int16 v4 = *(_WORD *)(v3 + 50)
     - 7
  uint64_t v5 = v4;
  uint64_t v6 = v3 + 72;
  uint64_t v7 = v6 + 8LL * v4;
  BOOL v8 = 1;
  do
  {
    if ((*(_WORD *)(*((void *)this + 6) + 220LL) & 0x10) != 0 && v5 == v2)
    {
      if (!*(void *)v7 || *(void *)(*(void *)v7 + 16LL)) {
        bssl::dtls_has_unprocessed_handshake_data();
      }
    }

    else if (*(void *)(v6 + 8 * v2))
    {
      return v8;
    }

    BOOL v8 = v2++ < 6;
  }

  while (v2 != 7);
  return v8;
}

uint64_t bssl::dtls1_open_change_cipher_spec( uint64_t a1, unint64_t *a2, char *a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v5 = *(char **)(a1 + 56);
  char v6 = *v5;
  if ((*v5 & 1) != 0) {
    goto LABEL_5;
  }
  uint64_t result = bssl::dtls1_open_handshake(a1, a2, a3, a4, a5);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v5 = *(char **)(a1 + 56);
  char v6 = *v5;
  if ((*v5 & 1) == 0) {
    return 1LL;
  }
LABEL_5:
  uint64_t result = 0LL;
  char *v5 = v6 & 0xFE;
  return result;
}

void bssl::dtls_clear_outgoing_messages(bssl *this, ssl_st *a2)
{
  uint64_t v3 = *((void *)this + 7);
  if (*(_BYTE *)(v3 + 296))
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 128LL;
    do
    {
      char v6 = (void *)(v3 + v5);
      OPENSSL_free(*(void **)(v3 + v5));
      void *v6 = 0LL;
      v6[1] = 0LL;
      ++v4;
      uint64_t v3 = *((void *)this + 7);
      v5 += 24LL;
    }

    while (v4 < *(unsigned __int8 *)(v3 + 296));
  }

  *(_WORD *)(v3 + 2bssl::Array<unsigned short>::~Array(v1 - 96) = 0;
  *(_DWORD *)(v3 + 300) = 0;
  *(_BYTE *)v3 &= ~2u;
  **((_BYTE **)this + 7) &= ~4u;
}

uint64_t bssl::dtls1_init_message(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  uint64_t result = CBB_init((uint64_t)a2, 0x40uLL);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u8((uint64_t)a2, a4);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u24((uint64_t)a2, 0);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u16((uint64_t)a2, *(unsigned __int16 *)(*(void *)(a1 + 56) + 48LL));
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_u24((uint64_t)a2, 0);
          if ((_DWORD)result) {
            return CBB_add_u24_length_prefixed(a2, a3) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::dtls1_finish_message(uint64_t a1, uint64_t a2, void *a3)
{
  if (bssl::CBBFinishArray(a2, (uint64_t)a3) && a3[1] > 0xBuLL)
  {
    uint64_t v5 = *a3;
    *(_WORD *)(v5 + 1) = *(_WORD *)(*a3 + 9LL);
    *(_BYTE *)(v5 + 3) = *(_BYTE *)(v5 + 11);
    return 1LL;
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 516);
    return 0LL;
  }

uint64_t bssl::dtls1_add_message(bssl *a1, uint64_t a2)
{
  unint64_t v4 = *(void **)(a2 + 8);
  v7[0] = *(void **)a2;
  v7[1] = v4;
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
  uint64_t v5 = bssl::add_outgoing(a1, 0LL, (uint64_t)v7);
  OPENSSL_free((void *)v7[0]);
  return v5;
}

void sub_18759F498( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::add_outgoing(bssl *this, ssl_st *a2, uint64_t a3)
{
  char v4 = (char)a2;
  uint64_t v6 = *((void *)this + 7);
  if ((*(_BYTE *)v6 & 2) != 0)
  {
    bssl::dtls1_stop_timer((uint64_t)this, a2);
    bssl::dtls_clear_outgoing_messages(this, v7);
    uint64_t v6 = *((void *)this + 7);
  }

  unsigned int v8 = *(unsigned __int8 *)(v6 + 296);
  if (v8 > 6 || (size_t v9 = *(void *)(a3 + 8), HIDWORD(v9))) {
    bssl::add_outgoing();
  }
  if ((v4 & 1) != 0) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void *)(*((void *)this + 6) + 280LL);
  if (!v10)
  {
LABEL_9:
    ++*(_WORD *)(v6 + 48);
LABEL_10:
    uint64_t v11 = v6 + 24LL * v8;
    OPENSSL_free(*(void **)(v11 + 128));
    *(void *)(v11 + 12_Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
    *(void *)(v11 + 136) = 0LL;
    uint64_t v12 = *(void *)(a3 + 8);
    *(void *)(v11 + 12_Block_object_dispose((const void *)(v30 - 136), 8) = *(void *)a3;
    *(void *)(v11 + 136) = v12;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
    uint64_t v13 = *((void *)this + 7);
    *(_WORD *)(v11 + CBB_cleanup(v1 - 144) = *(_WORD *)(v13 + 4);
    *(_BYTE *)(v11 + 146) = v4;
    ++*(_BYTE *)(v13 + 296);
    return 1LL;
  }

  if (bssl::SSLTranscript::Update((void **)(v10 + 424), *(const void **)a3, v9))
  {
    uint64_t v6 = *((void *)this + 7);
    unsigned int v8 = *(unsigned __int8 *)(v6 + 296);
    goto LABEL_9;
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 566);
  return 0LL;
}

uint64_t bssl::dtls1_add_change_cipher_spec(bssl *this, ssl_st *a2)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  uint64_t v2 = bssl::add_outgoing(this, (ssl_st *)1, (uint64_t)v4);
  OPENSSL_free((void *)v4[0]);
  return v2;
}

void sub_18759F5F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::dtls1_flush_flight(bssl *this, ssl_st *a2)
{
  **((_BYTE **)this + 7) |= 2u;
  bssl::dtls1_start_timer(this, a2);
  return bssl::send_flight(this, v3);
}

uint64_t bssl::send_flight(bssl *this, ssl_st *a2)
{
  if (*(_DWORD *)(*((void *)this + 6) + 176LL))
  {
    int v2 = 194;
    int v3 = 762;
LABEL_3:
    ERR_put_error(16, 0, v2, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", v3);
    return 0xFFFFFFFFLL;
  }

  if (!*((void *)this + 4))
  {
    int v2 = 119;
    int v3 = 767;
    goto LABEL_3;
  }

  if (*(_DWORD *)(*((void *)this + 7) + 304LL) <= 0xE3u && (SSL_get_options((uint64_t)this) & 0x1000) == 0)
  {
    unint64_t v6 = BIO_ctrl(*((BIO **)this + 4), 40, 0LL, 0LL);
    if (v6 > 0x40000000 || v6 < 0xE4)
    {
      *(_DWORD *)(*((void *)this + 7) + 304LL) = 1472;
      BIO_ctrl(*((BIO **)this + 4), 42, 1472LL, 0LL);
    }

    else
    {
      *(_DWORD *)(*((void *)this + 7) + 304LL) = v6;
    }
  }

  unint64_t v7 = *(unsigned int *)(*((void *)this + 7) + 304LL);
  uint64_t v36 = 0LL;
  unint64_t v37 = 0LL;
  if (!bssl::Array<unsigned char>::Init((uint64_t)&v36, v7))
  {
LABEL_64:
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_65;
  }

  while (2)
  {
    uint64_t v8 = *((void *)this + 7);
    if (*(unsigned __int8 *)(v8 + 297) >= *(unsigned __int8 *)(v8 + 296))
    {
      if ((int)BIO_flush(*((BIO **)this + 4)) > 0)
      {
        uint64_t v4 = 1LL;
        goto LABEL_65;
      }

      *(_DWORD *)(*((void *)this + 6) + 196LL) = 3;
      goto LABEL_64;
    }

    *(_DWORD *)&v35[8] = 0;
    char v9 = 0;
    int v34 = *(_DWORD *)(v8 + 300);
    *(void *)int8x16_t v35 = *(unsigned __int8 *)(v8 + 297);
    unsigned __int8 v10 = *(_BYTE *)(v8 + 297);
    uint64_t v11 = (char *)v36;
    unint64_t v12 = v37;
    while (1)
    {
      unsigned int v13 = v10;
      unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
      int v14 = *(unsigned __int16 *)(v8 + 4);
      if (*(_WORD *)(v8 + 4))
      {
        int v15 = *(unsigned __int16 *)(v8 + 24LL * v13 + 144);
        if (v14 - 1 == v15)
        {
          int v16 = 0;
          goto LABEL_22;
        }
      }

      else
      {
        int v15 = *(unsigned __int16 *)(v8 + 24LL * v13 + 144);
      }

      if (v15 != v14)
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 631);
        goto LABEL_64;
      }

      int v16 = 1;
LABEL_22:
      uint64_t v17 = bssl::dtls_max_seal_overhead((uint64_t)this, v16);
      uint64_t v18 = bssl::dtls_seal_prefix_len((uint64_t)this, v16);
      if (!*(_BYTE *)(v8 + 24LL * v13 + 146)) {
        break;
      }
      if (v17 + 1 > v12) {
        goto LABEL_59;
      }
      if (!bssl::dtls_seal_record( (uint64_t)this,  (unint64_t)v11,  &v38,  v12,  20,  (char *)&bssl::seal_next_message(ssl_st *,unsigned char *,unsigned long *,unsigned long,bssl::DTLS_OUTGOING_MESSAGE const*)::kChangeCipherSpec,  1uLL,  v16)) {
        goto LABEL_64;
      }
      bssl::ssl_do_msg_callback( (uint64_t)this,  1LL,  20LL,  (uint64_t)&bssl::seal_next_message(ssl_st *,unsigned char *,unsigned long *,unsigned long,bssl::DTLS_OUTGOING_MESSAGE const*)::kChangeCipherSpec,  1LL);
      unint64_t v19 = v38;
      *(void *)&v35[4] += v38;
LABEL_53:
      v12 -= v19;
      v11 += v19;
      uint64_t v8 = *((void *)this + 7);
      unsigned __int8 v10 = *(_BYTE *)(v8 + 297) + 1;
      *(_BYTE *)(v8 + 297) = v10;
      char v9 = 1;
    }

    unint64_t v20 = v18;
    __int128 v43 = (const void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
    memset(v42, 170, 20);
    uint64_t v21 = *(void *)(v8 + 24LL * v13 + 136);
    uint64_t v45 = *(void *)(v8 + 24LL * v13 + 128);
    uint64_t v46 = v21;
    int v22 = bssl::dtls1_parse_fragment(&v45, (uint64_t)v42, &v43);
    if (HIDWORD(v42[1])) {
      int v23 = 0;
    }
    else {
      int v23 = v22;
    }
    if (v23 != 1
      || v44 != LODWORD(v42[2])
      || LODWORD(v42[2]) != HIDWORD(v42[0])
      || !CBS_skip(&v43, *(unsigned int *)(*((void *)this + 7) + 300LL))
      || v46)
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 666);
      goto LABEL_64;
    }

    if (v17 + 13 > v12) {
      goto LABEL_59;
    }
    uint64_t v24 = v12 - v20;
    if (v12 < v20) {
      goto LABEL_59;
    }
    *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v41[1] = v25;
    v41[2] = v25;
    if (v44 >= v12 - v17 - 12) {
      size_t v26 = v12 - v17 - 12;
    }
    else {
      size_t v26 = v44;
    }
    v41[0] = v25;
    CBB_zero(v41);
    *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v40[1] = v27;
    v40[2] = v27;
    v40[0] = v27;
    int v28 = &v11[v20];
    uint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
    if (CBB_init_fixed((uint64_t)v41, (uint64_t)v28, v24)
      && CBB_add_u8((uint64_t)v41, LOBYTE(v42[0]))
      && CBB_add_u24((uint64_t)v41, HIDWORD(v42[0]))
      && CBB_add_u16((uint64_t)v41, LOWORD(v42[1]))
      && CBB_add_u24((uint64_t)v41, *(_DWORD *)(*((void *)this + 7) + 300LL))
      && CBB_add_u24_length_prefixed((uint64_t *)v41, (uint64_t)v40)
      && CBB_add_bytes((uint64_t)v40, v43, v26)
      && CBB_finish((uint64_t)v41, 0LL, &v39))
    {
      bssl::ssl_do_msg_callback((uint64_t)this, 1LL, 22LL, (uint64_t)v28, v39);
      if ((bssl::dtls_seal_record((uint64_t)this, (unint64_t)v11, &v38, v12, 22, v28, v39, v16) & 1) != 0)
      {
        uint64_t v29 = *((void *)this + 7);
        if (v26 == v44)
        {
          int v30 = 0;
          int v31 = 3;
        }

        else
        {
          int v30 = *(_DWORD *)(v29 + 300) + v26;
          int v31 = 2;
        }

        *(_DWORD *)(v29 + 300) = v30;
      }

      else
      {
        int v31 = 0;
      }
    }

    else
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 692);
      int v31 = 0;
    }

    CBB_cleanup((uint64_t)v41);
    if ((v31 - 2) < 2)
    {
      unint64_t v19 = v38;
      *(void *)&v35[4] += v38;
      if (v31 == 2) {
        goto LABEL_60;
      }
      goto LABEL_53;
    }

    if (!v31) {
      goto LABEL_64;
    }
LABEL_59:
    if ((v9 & 1) == 0)
    {
      ERR_put_error(16, 0, 169, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_both.cc", 752);
      goto LABEL_64;
    }

LABEL_60:
    uint64_t v4 = BIO_write(*((BIO **)this + 4), v36, *(int *)&v35[4]);
    break;
  }

  uint64_t v32 = *((void *)this + 7);
  *(_BYTE *)(v32 + 297) = v35[0];
  *(_DWORD *)(v32 + 300) = v34;
  *(_DWORD *)(*((void *)this + 6) + 196LL) = 3;
LABEL_65:
  OPENSSL_free(v36);
  return v4;
}

      unint64_t v19 = 115;
      unint64_t v20 = 267;
      goto LABEL_61;
    }

    if (!BN_rshift(v13, v13, v18) || !BN_mod_exp_mont(v17, v17, v13, n, ctx, 0LL)) {
      goto LABEL_62;
    }
    if (BN_is_one((unsigned int *)v17))
    {
      unint64_t v19 = 114;
      unint64_t v20 = 282;
LABEL_61:
      ERR_put_error(3, 0, v19, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/sqrt.c", v20);
      goto LABEL_62;
    }

    if (!BN_rshift1(v14, v13)) {
      goto LABEL_62;
    }
    if (BN_is_zero((uint64_t)v14))
    {
      if (!BN_nnmod(v14, v11, n, ctx)) {
        goto LABEL_62;
      }
      if (!BN_is_zero((uint64_t)v14))
      {
LABEL_79:
        if (BN_mod_sqr(r, aa, n, ctx) && BN_mod_mul(r, r, v11, n, ctx))
        {
          size_t v26 = aa;
          __int128 v27 = aa;
          for (uint64_t i = v11; BN_mod_mul(v26, v27, i, n, ctx); uint64_t i = v17)
          {
            if (BN_is_one((unsigned int *)r))
            {
              uint64_t v21 = v8;
              int v15 = aa;
              goto LABEL_41;
            }

            uint64_t v29 = v18 - 2;
            if (v18 < 2)
            {
LABEL_100:
              unint64_t v19 = 110;
              unint64_t v20 = 377;
              goto LABEL_61;
            }

            int v30 = v18 - 1;
            uint64_t v18 = 1;
            while (1)
            {
              if (v18 == 1)
              {
                if (!BN_mod_sqr(v14, r, n, ctx)) {
                  goto LABEL_62;
                }
              }

              else if (!BN_mod_mul(v14, v14, v14, n, ctx))
              {
                goto LABEL_62;
              }

              ++v18;
              --v29;
              --v30;
              if (v29 == -1) {
                goto LABEL_100;
              }
            }

            if (!BN_copy(v14, v17)) {
              goto LABEL_62;
            }
            if (v29 >= 1)
            {
              while (BN_mod_sqr(v14, v14, n, ctx))
              {
              }

              goto LABEL_62;
            }

void sub_18759FBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  CBB_cleanup((uint64_t)va1);
  bssl::Array<unsigned short>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::dtls1_retransmit_outgoing_messages(bssl *this, ssl_st *a2)
{
  uint64_t v2 = *((void *)this + 7);
  *(_BYTE *)(v2 + 297) = 0;
  *(_DWORD *)(v2 + 300) = 0;
  return bssl::send_flight(this, a2);
}

uint64_t bssl::dtls1_min_mtu(bssl *this)
{
  return 228LL;
}

uint64_t SSL_state_int(uint64_t a1, bssl::SSL_HANDSHAKE *a2)
{
  int v3 = *(bssl **)(*(void *)(a1 + 48) + 280LL);
  if (!v3) {
    return 724109320LL;
  }
  if ((*(_BYTE *)(a1 + 180) & 1) != 0) {
    return bssl::ssl_server_handshake_int_state(v3, a2);
  }
  return bssl::ssl_client_handshake_int_state(v3, a2);
}

void *EVP_hpke_x25519_hkdf_sha256()
{
  return &EVP_hpke_x25519_hkdf_sha256_kKEM;
}

uint64_t x25519_init_key(uint64_t a1, __int128 *a2, uint64_t a3)
{
  if (a3 == 32)
  {
    __int128 v3 = *a2;
    *(_OWORD *)(a1 + 24) = a2[1];
    *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = v3;
    X25519_public_from_private((_BYTE *)(a1 + 40), (uint64_t)a2);
    return 1LL;
  }

  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/hpke/hpke.c", 156);
    return 0LL;
  }

uint64_t x25519_generate_key(uint64_t a1)
{
  return 1LL;
}

uint64_t x25519_encap_with_seed( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, unint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a6 <= 0x1F)
  {
    int v10 = 137;
    int v11 = 310;
LABEL_11:
    ERR_put_error(6, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/hpke/hpke.c", v11);
    return 0LL;
  }

  if (a10 != 32)
  {
    int v10 = 102;
    int v11 = 314;
    goto LABEL_11;
  }

  uint64_t result = ccrng();
  if (!result) {
    return result;
  }
  if (!cccurve25519_make_pub_with_rng())
  {
    if (a8 == 32)
    {
      cchpke_params_x25519_AESGCM128_HKDF_SHA256();
      if (!cchpke_initiator_setup() && !cchpke_initiator_export())
      {
        *a5 = 32LL;
        *a3 = 32LL;
        return 1LL;
      }

      return 0LL;
    }

    int v10 = 134;
    int v11 = 327;
    goto LABEL_11;
  }

  return 0LL;
}

uint64_t x25519_decap(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (a5 == 32)
  {
    cchpke_params_x25519_AESGCM128_HKDF_SHA256();
    if (!cchpke_responder_setup() && !cchpke_responder_export())
    {
      *a3 = 32LL;
      return 1LL;
    }
  }

  else
  {
    ERR_put_error(6, 0, 134, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/hpke/hpke.c", 354);
  }

  return 0LL;
}

uint64_t x25519_auth_encap_with_seed()
{
  return 0LL;
}

uint64_t x25519_auth_decap()
{
  return 0LL;
}

void *EVP_hpke_hkdf_sha256()
{
  return &EVP_hpke_hkdf_sha256_kKDF;
}

uint64_t EVP_HPKE_KDF_id(unsigned __int16 *a1)
{
  return *a1;
}

void *EVP_hpke_aes_128_gcm()
{
  return &EVP_hpke_aes_128_gcm_kAEAD;
}

void *EVP_hpke_aes_256_gcm()
{
  return &EVP_hpke_aes_256_gcm_kAEAD;
}

void *EVP_hpke_chacha20_poly1305()
{
  return &EVP_hpke_chacha20_poly1305_kAEAD;
}

uint64_t EVP_HPKE_AEAD_aead(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

uint64_t EVP_HPKE_CTX_setup_sender( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, size_t a11)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)buf = v19;
  __int128 v22 = v19;
  RAND_bytes(buf, *(void *)(a5 + 24));
  return EVP_HPKE_CTX_setup_sender_with_seed_for_testing( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a11,  (uint64_t)buf,  *(void *)(a5 + 24));
}

uint64_t EVP_HPKE_CTX_setup_sender_with_seed_for_testing( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, size_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  bzero(a1, 0x2C8uLL);
  EVP_AEAD_CTX_zero(a1 + 3);
  *((_DWORD *)a1 + 176) = 1;
  a1[1] = a7;
  a1[2] = a6;
  *a1 = a5;
  *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[0] = v19;
  v24[1] = v19;
  uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  if ((*(unsigned int (**)(uint64_t, _OWORD *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 56))( a5,  v24,  &v23,  a2,  a3,  a4,  a8,  a9,  a12,  a13)
    && hpke_key_schedule((uint64_t)a1, 0, (uint64_t)v24, v23, a10, a11))
  {
    return 1LL;
  }

  EVP_AEAD_CTX_cleanup((uint64_t)(a1 + 3));
  return 0LL;
}

uint64_t hpke_key_schedule(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, const void *a5, size_t a6)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  __int16 v35 = -21846;
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = hpke_build_suite_id((unsigned __int16 **)a1, (uint64_t)&v34);
  if ((_DWORD)result)
  {
    uint64_t v13 = (EVP_MD *)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 8LL))();
    *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v33[2] = v14;
    v33[3] = v14;
    v33[0] = v14;
    v33[1] = v14;
    size_t v27 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = hpke_labeled_extract(v13, (int)v33, &v27, 0LL, 0LL, &v34, "psk_id_hash", 0LL, 0LL);
    if ((_DWORD)result)
    {
      *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v32[2] = v15;
      void v32[3] = v15;
      v32[0] = v15;
      v32[1] = v15;
      size_t v26 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t result = hpke_labeled_extract(v13, (int)v32, &v26, 0LL, 0LL, &v34, "info_hash", a5, a6);
      if ((_DWORD)result)
      {
        char v31 = -86;
        *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v30[6] = v16;
        v30[7] = v16;
        void v30[4] = v16;
        v30[5] = v16;
        v30[2] = v16;
        _OWORD v30[3] = v16;
        v30[0] = v16;
        v30[1] = v16;
        size_t v25 = 0xAAAAAAAAAAAAAAAALL;
        v24[1] = v16;
        _OWORD v24[2] = v16;
        v24[0] = v16;
        CBB_init_fixed((uint64_t)v24, (uint64_t)v30, 129LL);
        uint64_t result = CBB_add_u8((uint64_t)v24, a2);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_bytes((uint64_t)v24, v33, v27);
          if ((_DWORD)result)
          {
            uint64_t result = CBB_add_bytes((uint64_t)v24, v32, v26);
            if ((_DWORD)result)
            {
              uint64_t result = CBB_finish((uint64_t)v24, 0LL, &v25);
              if ((_DWORD)result)
              {
                *(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
                __int128 v29[2] = v17;
                v29[3] = v17;
                v29[0] = v17;
                v29[1] = v17;
                uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
                uint64_t result = hpke_labeled_extract(v13, (int)v29, &v23, a3, a4, &v34, "secret", 0LL, 0LL);
                if ((_DWORD)result)
                {
                  uint64_t v18 = (unsigned __int8 *)(*(uint64_t (**)(void))(*(void *)(a1 + 8) + 8LL))();
                  *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  v28[3] = v19;
                  v28[4] = v19;
                  v28[1] = v19;
                  __int128 v28[2] = v19;
                  v28[0] = v19;
                  uint64_t v20 = EVP_AEAD_key_length(v18);
                  uint64_t result = hpke_labeled_expand(v13, (int)v28, v20, (uint64_t)v29, v23, &v34, "key", v30, v25);
                  if ((_DWORD)result)
                  {
                    uint64_t result = EVP_AEAD_CTX_init((void *)(a1 + 24), (uint64_t)v18, (uint64_t)v28, v20, 0LL);
                    if ((_DWORD)result)
                    {
                      int v21 = EVP_AEAD_nonce_length((uint64_t)v18);
                      uint64_t result = hpke_labeled_expand(v13, a1 + 608, v21, (uint64_t)v29, v23, &v34, "base_nonce", v30, v25);
                      if ((_DWORD)result)
                      {
                        int v22 = EVP_MD_size(v13);
                        return hpke_labeled_expand(v13, a1 + 632, v22, (uint64_t)v29, v23, &v34, "exp", v30, v25);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t EVP_HPKE_CTX_setup_recipient( void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  bzero(a1, 0x2C8uLL);
  EVP_AEAD_CTX_zero(a1 + 3);
  *((_DWORD *)a1 + 176) = 0;
  uint64_t v16 = *a2;
  a1[1] = a4;
  a1[2] = a3;
  *a1 = v16;
  *(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = v17;
  v20[1] = v17;
  uint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  if ((*(unsigned int (**)(uint64_t *, _OWORD *, uint64_t *, uint64_t, uint64_t))(v16 + 64))( a2,  v20,  &v19,  a5,  a6)
    && hpke_key_schedule((uint64_t)a1, 0, (uint64_t)v20, v19, a7, a8))
  {
    return 1LL;
  }

  EVP_AEAD_CTX_cleanup((uint64_t)(a1 + 3));
  return 0LL;
}

uint64_t EVP_HPKE_CTX_open(uint64_t a1, char *a2, size_t *a3, size_t a4, char *a5, unint64_t a6)
{
  _OWORD v16[3] = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 704))
  {
    int v6 = 66;
    int v7 = 827;
LABEL_3:
    ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/hpke/hpke.c", v7);
    return 0LL;
  }

  if (*(void *)(a1 + 696) == -1LL)
  {
    int v6 = 69;
    int v7 = 831;
    goto LABEL_3;
  }

  memset(v16, 170, 24);
  uint64_t v15 = EVP_AEAD_nonce_length(*(void *)(a1 + 24));
  hpke_nonce(a1, v16, v15);
  uint64_t result = EVP_AEAD_CTX_open((unsigned __int8 *)(a1 + 24), a2, a3, a4, (uint64_t)v16, v15, a5, a6);
  if ((_DWORD)result)
  {
    ++*(void *)(a1 + 696);
    return 1LL;
  }

  return result;
}

void hpke_nonce(uint64_t a1, _BYTE *a2, size_t a3)
{
  if (a3 <= 7) {
    hpke_nonce_cold_1();
  }
  size_t v3 = a3;
  uint64_t v4 = a2;
  bzero(a2, a3);
  unint64_t v6 = *(void *)(a1 + 696);
  for (uint64_t i = -1LL; i != -9; --i)
  {
    v4[v3 + i] = v6;
    v6 >>= 8;
  }

  uint64_t v8 = (char *)(a1 + 608);
  do
  {
    char v9 = *v8++;
    *v4++ ^= v9;
    --v3;
  }

  while (v3);
}

uint64_t EVP_HPKE_CTX_seal(uint64_t a1, char *a2, unint64_t *a3, size_t a4, char *a5, size_t a6)
{
  _OWORD v16[3] = *MEMORY[0x1895F89C0];
  if (!*(_DWORD *)(a1 + 704))
  {
    int v14 = 66;
    int v15 = 851;
LABEL_7:
    ERR_put_error(6, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/hpke/hpke.c", v15);
    return 0LL;
  }

  if (*(void *)(a1 + 696) == -1LL)
  {
    int v14 = 69;
    int v15 = 855;
    goto LABEL_7;
  }

  memset(v16, 170, 24);
  uint64_t v12 = EVP_AEAD_nonce_length(*(void *)(a1 + 24));
  hpke_nonce(a1, v16, v12);
  uint64_t result = EVP_AEAD_CTX_seal(a1 + 24, a2, a3, a4, (uint64_t)v16, v12, a5, a6);
  if ((_DWORD)result)
  {
    ++*(void *)(a1 + 696);
    return 1LL;
  }

  return result;
}

uint64_t hpke_build_suite_id(unsigned __int16 **a1, uint64_t a2)
{
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[1] = v3;
  void v5[2] = v3;
  v5[0] = v3;
  CBB_init_fixed((uint64_t)v5, a2, 10LL);
  uint64_t result = CBB_add_bytes((uint64_t)v5, "HPKE", 4uLL);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16((uint64_t)v5, **a1);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16((uint64_t)v5, *a1[2]);
      if ((_DWORD)result) {
        return CBB_add_u16((uint64_t)v5, *a1[1]) != 0;
      }
    }
  }

  return result;
}

BOOL hpke_labeled_expand( EVP_MD *a1, int a2, int a3, uint64_t a4, uint64_t a5, const void *a6, const char *a7, const void *a8, size_t a9)
{
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[1] = v15;
  _OWORD v19[2] = v15;
  v19[0] = v15;
  if (CBB_init((uint64_t)v19, 0LL)
    && CBB_add_u16((uint64_t)v19, (unsigned __int16)a3)
    && CBB_add_bytes((uint64_t)v19, "HPKE-v1", 7uLL)
    && CBB_add_bytes((uint64_t)v19, a6, 0xAuLL)
    && (size_t v16 = strlen(a7), CBB_add_bytes((uint64_t)v19, a7, v16))
    && CBB_add_bytes((uint64_t)v19, a8, a9))
  {
    CBB_data((uint64_t)v19);
    CBB_len((uint64_t)v19);
    BOOL v17 = HKDF_expand(a2, a3, a1);
  }

  else
  {
    BOOL v17 = 0LL;
  }

  CBB_cleanup((uint64_t)v19);
  return v17;
}

const BIGNUM *__cdecl EVP_HPKE_CTX_kdf(const EC_KEY *a1)
{
  return (const BIGNUM *)*((void *)a1 + 2);
}

BOOL hpke_labeled_extract( EVP_MD *a1, int a2, void *a3, uint64_t a4, uint64_t a5, const void *a6, const char *a7, const void *a8, size_t a9)
{
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[1] = v15;
  _OWORD v19[2] = v15;
  v19[0] = v15;
  if (CBB_init((uint64_t)v19, 0LL)
    && CBB_add_bytes((uint64_t)v19, "HPKE-v1", 7uLL)
    && CBB_add_bytes((uint64_t)v19, a6, 0xAuLL)
    && (size_t v16 = strlen(a7), CBB_add_bytes((uint64_t)v19, a7, v16))
    && CBB_add_bytes((uint64_t)v19, a8, a9))
  {
    CBB_data((uint64_t)v19);
    CBB_len((uint64_t)v19);
    BOOL v17 = HKDF_extract(a2, a3, a1) != 0;
  }

  else
  {
    BOOL v17 = 0LL;
  }

  CBB_cleanup((uint64_t)v19);
  return v17;
}

uint64_t bssl::tls13_init_early_key_schedule(bssl *this, ssl_cipher_st **a2, const ssl_session_st *a3)
{
  if ((*(_BYTE *)(*(void *)this + 180LL) & 1) != 0) {
    bssl::tls13_init_early_key_schedule();
  }
  if (*((void *)this + 193)) {
    uint64_t v5 = (size_t **)((char *)this + 464);
  }
  else {
    uint64_t v5 = (size_t **)((char *)this + 424);
  }
  unint64_t v6 = (bssl::SSLTranscript *)bssl::ssl_session_protocol_version((bssl *)a2, (const ssl_session_st *)a2);
  uint64_t result = bssl::init_key_schedule(this, v5, v6, a2[25], v7);
  if ((_DWORD)result) {
    return bssl::hkdf_extract_to_secret((uint64_t)this, (bssl::SSLTranscript *)v5);
  }
  return result;
}

uint64_t bssl::tls13_derive_early_secret(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *(void *)this;
  if ((*(_BYTE *)(*(void *)this + 180LL) & 1) != 0 || !*((void *)this + 193)) {
    uint64_t v4 = (bssl *)((char *)this + 424);
  }
  else {
    uint64_t v4 = (bssl *)((char *)this + 464);
  }
  uint64_t result = bssl::derive_secret_with_transcript( (uint64_t)this,  (int)this + 88,  *((void *)this + 4),  v4,  "c e traffic",  0xBuLL);
  if ((_DWORD)result) {
    return bssl::ssl_log_secret(v3, "CLIENT_EARLY_TRAFFIC_SECRET", (unsigned __int8 *)this + 88, *((void *)this + 4));
  }
  return result;
}

uint64_t bssl::tls13_rotate_traffic_key(const SSL *a1, uint64_t a2)
{
  handshake_func = a1->handshake_func;
  uint64_t v5 = 440LL;
  if ((_DWORD)a2)
  {
    unint64_t v6 = (char *)handshake_func + 296;
  }

  else
  {
    uint64_t v5 = 441LL;
    unint64_t v6 = (char *)handshake_func + 344;
  }

  size_t v7 = *((unsigned __int8 *)handshake_func + v5);
  sessiouint64_t n = (bssl *)SSL_get_session(a1);
  digest = (EVP_MD *)bssl::ssl_session_get_digest(session, v9);
  else {
    return 0LL;
  }
}

uint64_t bssl::tls13_export_keying_material( const SSL *a1, int a2, int a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7, uint64_t a8, const void *a9, size_t a10)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a5) {
    bssl::tls13_export_keying_material();
  }
  sessiouint64_t n = (bssl *)SSL_get_session(a1);
  digest = (EVP_MD *)bssl::ssl_session_get_digest(session, v17);
  *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  md[2] = v19;
  md[3] = v19;
  md[0] = v19;
  md[1] = v19;
  __int128 v30 = v19;
  __int128 v31 = v19;
  *(_OWORD *)int v28 = v19;
  __int128 v29 = v19;
  unsigned int v25 = -1431655766;
  unsigned int size = -1431655766;
  uint64_t result = EVP_Digest(a9, a10, (unsigned __int8 *)md, &size, digest, 0LL);
  if ((_DWORD)result)
  {
    uint64_t result = EVP_Digest(0LL, 0LL, v28, &v25, digest, 0LL);
    if ((_DWORD)result)
    {
      size_t v22 = v25;
      size_t v21 = size;
      *(void *)&__int128 v23 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      int64x2_t v27[2] = v23;
      v27[3] = v23;
      v27[0] = v23;
      v27[1] = v23;
      uint64_t v24 = EVP_MD_size(digest);
    }
  }

  return result;
}

uint64_t bssl::tls13_write_psk_binder(uint64_t *a1, ssl_session_st *a2, char *a3, size_t a4, size_t *a5)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *a1;
  digest = bssl::ssl_session_get_digest(*(bssl **)(*a1 + 104), a2);
  size_t v11 = EVP_MD_size(digest);
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __src[2] = v12;
  __src[3] = v12;
  __src[0] = v12;
  __src[1] = v12;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v13 = bssl::tls13_psk_binder( (unsigned __int8 *)__src,  (ssl_session_st *)&v16,  *(bssl **)(v9 + 104),  (size_t **)a2,  a3,  a4,  v11 + 3,  *(unsigned __int8 *)(*(void *)(v9 + 104) + 440LL) >> 7);
  if (v16 == v11) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0LL;
  }
  if ((v14 & 1) != 0)
  {
    if (a4 < v11) {
      abort();
    }
    if (v11) {
      memcpy(&a3[a4 - v11], __src, v11);
    }
    if (a5) {
      *a5 = v11;
    }
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 481);
  }

  return v14;
}

uint64_t bssl::tls13_psk_binder( unsigned __int8 *a1, ssl_session_st *a2, bssl *this, size_t **a4, const void *a5, size_t a6, size_t a7, int a8)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  digest = (EVP_MD *)bssl::ssl_session_get_digest(this, a2);
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v35 = v15;
  __int128 v36 = v15;
  *(_OWORD *)munsigned int d = v15;
  __int128 v34 = v15;
  unsigned int size = -1431655766;
  memset(v32, 0, sizeof(v32));
  uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  memset(v31, 0, sizeof(v31));
  uint64_t v16 = EVP_MD_size(digest);
  BOOL v17 = a8 ? "ext binder" : "res binder";
  if (a6 < a7)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 437);
    return 0LL;
  }

  if (a6 >= a6 - a7) {
    a6 -= a7;
  }
  *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v29 = v20;
  __int128 v30 = v20;
  *(_OWORD *)size_t v27 = v20;
  __int128 v28 = v20;
  unsigned int s = -1431655766;
  *(_OWORD *)&ctx.digest = v20;
  *(_OWORD *)&ctx.flagunsigned int s = v20;
  EVP_MD_CTX_init(&ctx);
  if (bssl::SSLTranscript::CopyToHashContext(a4, &ctx, digest)
    && EVP_DigestUpdate(&ctx, a5, a6)
    && EVP_DigestFinal_ex(&ctx, v27, &s)
    && bssl::tls13_verify_data(a1, a2, digest, (uint64_t)v31, v16, v27, s))
  {
    uint64_t v21 = *(void *)&a2->ssl_version;
    if (v21 != EVP_MD_size(digest)) {
      __assert_rtn("tls13_psk_binder", "tls13_enc.cc", 456, "*out_len == EVP_MD_size(digest)");
    }
    uint64_t v18 = 1LL;
  }

  else
  {
    uint64_t v18 = 0LL;
  }

  EVP_MD_CTX_cleanup(&ctx);
  return v18;
}

void sub_1875A1258( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, EVP_MD_CTX *ctx)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t bssl::tls13_verify_psk_binder(uint64_t a1, bssl *this, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v12[2] = v5;
  _OWORD v12[3] = v5;
  v12[0] = v5;
  v12[1] = v5;
  uint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = 0LL;
  uint64_t v9 = (char *)0xAAAAAAAAAAAAAAAALL;
  if (bssl::tls13_psk_binder( (unsigned __int8 *)v12,  (ssl_session_st *)&v11,  this,  (size_t **)(a1 + 424),  *(const void **)(a3 + 24),  *(void *)(a3 + 32),  *(void *)(a4 + 8) + 2LL,  0)
    && CBS_get_u8_length_prefixed((unsigned __int8 **)a4, (unint64_t *)&v9))
  {
    int v6 = 142;
    int v7 = 517;
  }

  else
  {
    int v6 = 68;
    int v7 = 506;
  }

  ERR_put_error(16, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", v7);
  return 0LL;
}

BOOL bssl::ssl_ech_accept_confirmation( int a1, int a2, uint64_t a3, int a4, int a5, bssl::SSLTranscript *a6, int a7, int a8, char *d, unint64_t a10, unint64_t a11)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a10 >= a11 + 8)
  {
    *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v31 = v16;
    __int128 v32 = v16;
    if (a10 >= a11) {
      size_t v17 = a11;
    }
    else {
      size_t v17 = a10;
    }
    __int128 v30 = v16;
    *(_OWORD *)munsigned int d = v16;
    unsigned int s = -1431655766;
    *(_OWORD *)&ctx.digest = v16;
    *(_OWORD *)&ctx.flagunsigned int s = v16;
    EVP_MD_CTX_init(&ctx);
    uint64_t v18 = bssl::SSLTranscript::Digest(a6);
    if (!EVP_DigestUpdate(&ctx, d, v17)) {
      goto LABEL_20;
    }
    if (!EVP_DigestUpdate( &ctx,  &bssl::ssl_ech_accept_confirmation(bssl::SSL_HANDSHAKE const*,bssl::Span<unsigned char>,bssl::Span<unsigned char const>,bssl::SSLTranscript const&,BOOL,bssl::Span<unsigned char const>,unsigned long)::kZeros,  8uLL)) {
      goto LABEL_20;
    }
    if (!EVP_DigestUpdate(&ctx, &d[a11 + 8], a10 - (a11 + 8))) {
      goto LABEL_20;
    }
    if (!EVP_DigestFinal_ex(&ctx, md, &s)) {
      goto LABEL_20;
    }
    *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v28[2] = v19;
    v28[3] = v19;
    v28[0] = v19;
    v28[1] = v19;
    uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    __int128 v20 = (EVP_MD *)bssl::SSLTranscript::Digest(a6);
    bssl::SSLTranscript::DigestLen(a6);
    if (HKDF_extract((int)v28, &v25, v20))
    {
      if (a3 != 8) {
        __assert_rtn("ssl_ech_accept_confirmation", "tls13_enc.cc", 567, "out.size() == ECH_CONFIRMATION_SIGNAL_LEN");
      }
      uint64_t v21 = (EVP_MD *)bssl::SSLTranscript::Digest(a6);
      if (a7) {
        size_t v22 = "hrr ech accept confirmation";
      }
      else {
        size_t v22 = "ech accept confirmation";
      }
      if (a7) {
        size_t v23 = 27LL;
      }
      else {
        size_t v23 = 23LL;
      }
      BOOL v11 = CRYPTO_tls13_hkdf_expand_label(a2, 8, v21, (uint64_t)v28, v25, v22, v23, md, s);
    }

    else
    {
LABEL_20:
      BOOL v11 = 0LL;
    }

    EVP_MD_CTX_cleanup(&ctx);
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_enc.cc", 542);
    return 0LL;
  }

  return v11;
}

void sub_1875A15D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, EVP_MD_CTX *ctx)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a)
{
  *(void *)&a->final[8] = 0LL;
  *(_OWORD *)&a->flagunsigned int s = 0u;
  *(_OWORD *)&a->final_useunsigned int d = 0u;
  *(_OWORD *)&a->buf[24] = 0u;
  *(_OWORD *)&a->app_data = 0u;
  *(_OWORD *)&a->iv[8] = 0u;
  *(_OWORD *)&a->buf[8] = 0u;
  *(_OWORD *)&a->encrypt = 0u;
  *(_OWORD *)&a->oiv[8] = 0u;
  *(_OWORD *)&a->cipher = 0u;
}

int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a)
{
  if (a->cipher)
  {
    cleanup = a->cipher->cleanup;
    if (cleanup) {
      ((void (*)(EVP_CIPHER_CTX *))cleanup)(a);
    }
  }

  OPENSSL_free(*(void **)&a->encrypt);
  *(void *)&a->final[8] = 0LL;
  *(_OWORD *)&a->flagunsigned int s = 0u;
  *(_OWORD *)&a->final_useunsigned int d = 0u;
  *(_OWORD *)&a->buf[24] = 0u;
  *(_OWORD *)&a->app_data = 0u;
  *(_OWORD *)&a->iv[8] = 0u;
  *(_OWORD *)&a->buf[8] = 0u;
  *(_OWORD *)&a->encrypt = 0u;
  *(_OWORD *)&a->oiv[8] = 0u;
  *(_OWORD *)&a->cipher = 0u;
  return 1;
}

int EVP_CipherInit_ex( EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  if (enc == -1)
  {
    uint64_t v10 = *(unsigned int *)&ctx->oiv[4];
  }

  else
  {
    uint64_t v10 = enc != 0;
    *(_DWORD *)&ctx->oiv[4] = v10;
  }

  BOOL v11 = ctx->cipher;
  if (cipher)
  {
    if (v11)
    {
      EVP_CIPHER_CTX_cleanup(ctx);
      *(_DWORD *)&ctx->oiv[4] = v10;
    }

    ctx->cipher = cipher;
    unint64_t flags_low = LODWORD(cipher->flags);
    if ((_DWORD)flags_low)
    {
      uint64_t v13 = OPENSSL_malloc(flags_low);
      *(void *)&ctx->encrypt = v13;
      if (!v13)
      {
        ctx->cipher = 0LL;
        return (int)v13;
      }

      BOOL v11 = ctx->cipher;
    }

    else
    {
      *(void *)&ctx->encrypt = 0LL;
      BOOL v11 = cipher;
    }

    *(_DWORD *)ctx->oiv = cipher->key_len;
    *(_DWORD *)&ctx->oiv[8] = 0;
    if ((v11->flags & 0x20000000000LL) == 0) {
      goto LABEL_16;
    }
    if (EVP_CIPHER_CTX_ctrl(ctx, 0, 0, 0LL))
    {
      BOOL v11 = ctx->cipher;
      goto LABEL_16;
    }

    ctx->cipher = 0LL;
    int v14 = 107;
    int v15 = 178;
LABEL_27:
    ERR_put_error(30, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v15);
LABEL_28:
    LODWORD(v13) = 0;
    return (int)v13;
  }

  if (!v11)
  {
    int v14 = 114;
    int v15 = 183;
    goto LABEL_27;
  }

int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
  if (ctx->cipher)
  {
    uint64_t v4 = *(uint64_t (**)(void))&ctx->cipher->ctx_size;
    if (v4)
    {
      int result = v4();
      if (result != -1) {
        return result;
      }
      int v6 = 105;
      int v7 = 631;
    }

    else
    {
      int v6 = 104;
      int v7 = 625;
    }
  }

  else
  {
    int v6 = 114;
    int v7 = 620;
  }

  ERR_put_error(30, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v7);
  return 0;
}

uint64_t EVP_CIPHER_CTX_mode(uint64_t a1)
{
  return *(_DWORD *)(*(void *)a1 + 20LL) & 0x3F;
}

int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
{
  cipher = ctx->cipher;
  if ((HIDWORD(ctx->cipher->flags) & 0x3F) == 6)
  {
    int ptr = -1431655766;
    if (EVP_CIPHER_CTX_ctrl((EVP_CIPHER_CTX *)ctx, 25, 0, &ptr) == 1) {
      return ptr;
    }
    cipher = ctx->cipher;
  }

  return cipher->iv_len;
}

int EVP_EncryptInit_ex( EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
}

int EVP_DecryptInit_ex( EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (*(_DWORD *)&ctx->final[8])
  {
    int v5 = 66;
    int v6 = 259;
LABEL_17:
    ERR_put_error(30, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v6);
    return 0;
  }

  unsigned int v7 = inl;
  *(_DWORD *)&ctx->final[8] = 1;
  cipher = ctx->cipher;
  block_unsigned int size = ctx->cipher->block_size;
  if (block_size >= 2 && (block_size ^ 0x7FFFFFFF) < inl)
  {
    int v5 = 69;
    int v6 = 271;
    goto LABEL_17;
  }

  __int128 v12 = in;
  int v14 = out;
  if ((cipher->flags & 0x40000000000LL) != 0)
  {
    int v18 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))cipher->do_cipher)( ctx,  out,  in,  inl);
    if (v18 < 0) {
      return 0;
    }
    *outl = v18;
    goto LABEL_35;
  }

  if (inl <= 0)
  {
    int result = 0;
    *outl = 0;
    if (!inl) {
      goto LABEL_35;
    }
    return result;
  }

  int app_data_high = HIDWORD(ctx->app_data);
  if (!app_data_high)
  {
    if (block_remainder((uint64_t)ctx, inl))
    {
      int app_data_high = HIDWORD(ctx->app_data);
      goto LABEL_12;
    }

    int result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))ctx->cipher->do_cipher)( ctx,  v14,  v12,  v7);
    if (!result)
    {
      *outl = 0;
      return result;
    }

    *outl = v7;
LABEL_35:
    *(_DWORD *)&ctx->final[8] = 0;
    return 1;
  }

uint64_t block_remainder(uint64_t a1, unsigned int a2)
{
  int v2 = *(_DWORD *)(*(void *)a1 + 4LL);
  if (!v2) {
    block_remainder_cold_1();
  }
  if ((v2 & (v2 - 1)) != 0) {
    block_remainder_cold_2();
  }
  return (v2 - 1) & a2;
}

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl)
{
  if (*(_DWORD *)&ctx->final[8])
  {
    int v3 = 66;
    int v4 = 352;
LABEL_3:
    ERR_put_error(30, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }

  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x40000000000LL) != 0)
  {
    int v11 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, void, void))cipher->do_cipher)( ctx,  out,  0LL,  0LL);
    if (v11 < 0) {
      return 0;
    }
    *outl = v11;
    return 1;
  }

  block_unsigned int size = cipher->block_size;
  if ((_DWORD)block_size == 1) {
    goto LABEL_8;
  }
  uint64_t app_data_high = HIDWORD(ctx->app_data);
  if ((ctx->oiv[9] & 8) != 0)
  {
    if ((_DWORD)app_data_high)
    {
      int v3 = 106;
      int v4 = 378;
      goto LABEL_3;
    }

LABEL_8:
    *outl = 0;
    return 1;
  }

  if (block_size > app_data_high) {
    memset( &ctx->buf[app_data_high + 12],  block_size - app_data_high,  (block_size + ~(_DWORD)app_data_high) + 1LL);
  }
  int result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, uint64_t))cipher->do_cipher)( ctx,  out,  &ctx->buf[12],  block_size);
  if (result)
  {
    *outl = block_size;
    return 1;
  }

  return result;
}

  if (((**(uint64_t (***)(unint64_t *))(*(void *)(a1 + 120) + 16LL))(v14) & 1) == 0)
  {
    *a2 = 50;
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 504);
    goto LABEL_15;
  }

  uint64_t v10 = v14;
  int v14 = 0LL;
  *a4 = v10;
LABEL_16:
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](&v14, 0LL);
}

      ERR_put_error(15, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec.c", 342);
      return 0LL;
    }

    CRYPTO_once(&EC_group_p256_once, (void (*)(void))EC_group_p256_init);
    return (EC_GROUP *)&EC_group_p256_storage;
  }

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (*(_DWORD *)&ctx->final[8])
  {
    int v5 = 66;
    int v6 = 402;
LABEL_22:
    ERR_put_error(30, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v6);
    return 0;
  }

  cipher = ctx->cipher;
  block_unsigned int size = ctx->cipher->block_size;
  if (block_size >= 2 && (int)(block_size ^ 0x7FFFFFFF) < inl)
  {
    int v5 = 69;
    int v6 = 410;
    goto LABEL_22;
  }

  int v14 = out;
  if ((cipher->flags & 0x40000000000LL) != 0)
  {
    int v17 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))cipher->do_cipher)( ctx,  out,  in,  inl);
    int v18 = v17 & ~(v17 >> 31);
    int result = v17 >= 0;
    *outl = v18;
    return result;
  }

  if (inl <= 0)
  {
    *outl = 0;
    return inl == 0;
  }

  if ((ctx->oiv[9] & 8) != 0) {
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  }
  int v15 = *(&ctx->key_len + 1);
  if (v15)
  {
    if ((_DWORD)block_size) {
      memcpy(out, &ctx->flags, block_size);
    }
    v14 += block_size;
  }

  int result = EVP_EncryptUpdate(ctx, v14, outl, in, inl);
  if (result)
  {
    if (block_size < 2 || HIDWORD(ctx->app_data))
    {
      *(&ctx->key_len + 1) = 0;
      if (!v15) {
        return 1;
      }
    }

    else
    {
      *outl -= block_size;
      *(&ctx->key_len + 1) = 1;
      memcpy(&ctx->flags, &v14[*outl], block_size);
      if (!v15) {
        return 1;
      }
    }

    *outl += block_size;
    return 1;
  }

  return result;
}

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  *outl = 0;
  if (*(_DWORD *)&ctx->final[8])
  {
    int v3 = 66;
    int v4 = 469;
LABEL_3:
    ERR_put_error(30, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }

  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x40000000000LL) != 0)
  {
    int v9 = ((uint64_t (*)(void))cipher->do_cipher)();
    if (v9 < 0) {
      return 0;
    }
    *outl = v9;
  }

  else if ((ctx->oiv[9] & 8) != 0)
  {
    if (HIDWORD(ctx->app_data))
    {
      int v3 = 106;
      int v4 = 486;
      goto LABEL_3;
    }
  }

  else
  {
    block_unsigned int size = cipher->block_size;
    if (block_size >= 2)
    {
      if (HIDWORD(ctx->app_data) || !*(&ctx->key_len + 1))
      {
        int v3 = 123;
        int v4 = 495;
        goto LABEL_3;
      }

      if (block_size >= 0x21) {
        EVP_DecryptFinal_ex_cold_1();
      }
      uint64_t v10 = block_size - 1;
      unsigned int v11 = *((unsigned __int8 *)&ctx->flags + v10);
      if (*((_BYTE *)&ctx->flags + v10)) {
        BOOL v12 = block_size >= v11;
      }
      else {
        BOOL v12 = 0;
      }
      if (!v12)
      {
        int v3 = 101;
        int v4 = 504;
        goto LABEL_3;
      }

      int v13 = *((unsigned __int8 *)&ctx->flags + v10);
      do
      {
        if (*((unsigned __int8 *)&ctx->flags + v10) != v11)
        {
          int v3 = 101;
          int v4 = 510;
          goto LABEL_3;
        }

        LODWORD(v10) = v10 - 1;
        --v13;
      }

      while (v13);
      uint64_t v14 = block_size - v11;
      if ((int)v14 >= 1)
      {
        p_flagunsigned int s = &ctx->flags;
        uint64_t v16 = v14;
        do
        {
          unsigned __int8 v17 = *(_BYTE *)p_flags;
          p_flagunsigned int s = (unint64_t *)((char *)p_flags + 1);
          *outm++ = v17;
          --v16;
        }

        while (v16);
      }

      *outl = v14;
    }
  }

  return 1;
}

int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->block_size;
}

int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad)
{
  *(_DWORD *)&c->oiv[8] = *(_DWORD *)&c->oiv[8] & 0xFFFFF7FF | ((pad == 0) << 11);
  return 1;
}

int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
{
  return cipher->key_len;
}

int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
{
  return cipher->iv_len;
}

uint64_t ec_GFp_simple_group_get_curve(uint64_t a1, BIGNUM *a, BIGNUM *a3, BIGNUM *a4)
{
  if (!a || (uint64_t result = (uint64_t)BN_copy(a, (const BIGNUM *)(a1 + 320))) != 0)
  {
    if (!a3 || (uint64_t result = ec_felem_to_bignum(a1, a3, a1 + 360), (_DWORD)result))
    {
      if (!a4) {
        return 1LL;
      }
      uint64_t result = ec_felem_to_bignum(a1, a4, a1 + 432);
      if ((_DWORD)result) {
        return 1LL;
      }
    }
  }

  return result;
}

double ec_GFp_simple_point_init(uint64_t a1)
{
  *(void *)(a1 + 64) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v30 - 136), 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v30 - 136), 8) = 0u;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array(v16 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 136) = 0LL;
  *(_OWORD *)(a1 + CBB_cleanup(v1 - 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + CBB_cleanup(v1 - 192) = 0u;
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
  return result;
}

__n128 ec_GFp_simple_point_copy(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __int128 v2 = *(_OWORD *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v3;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v30 - 136), 8) = v4;
  *(_OWORD *)(a1 + 16) = v2;
  __int128 v5 = *(_OWORD *)(a2 + 104);
  __int128 v6 = *(_OWORD *)(a2 + 120);
  uint64_t v7 = *(void *)(a2 + 136);
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v30 - 136), 8) = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 136) = v7;
  *(_OWORD *)(a1 + 120) = v6;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array(v16 + 104) = v5;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  __int128 v9 = *(_OWORD *)(a2 + 176);
  __int128 v8 = *(_OWORD *)(a2 + 192);
  __int128 v10 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v30 - 136), 8) = *(void *)(a2 + 208);
  *(_OWORD *)(a1 + 176) = v9;
  *(_OWORD *)(a1 + CBB_cleanup(v1 - 192) = v8;
  *(_OWORD *)(a1 + 160) = v10;
  __n128 result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + CBB_cleanup(v1 - 144) = result;
  return result;
}

double ec_GFp_simple_point_set_to_infinity(uint64_t a1, uint64_t a2)
{
  return ec_GFp_simple_point_init(a2);
}

unint64_t ec_GFp_simple_invert(uint64_t a1, uint64_t a2)
{
  return ec_felem_neg(a1, (unint64_t *)(a2 + 72), (const unint64_t *)(a2 + 72));
}

BOOL ec_GFp_simple_is_at_infinity(uint64_t a1, uint64_t a2)
{
  return ec_felem_non_zero_mask(a1, (uint64_t *)(a2 + 144)) == 0;
}

BOOL ec_GFp_simple_is_on_curve(_DWORD *a1, uint64_t a2)
{
  __int128 v5 = *(void (**)(_DWORD *, _OWORD *, _OWORD *, _OWORD *))(*(void *)a1 + 88LL);
  __int128 v4 = *(void (**)(_DWORD *, _OWORD *, uint64_t))(*(void *)a1 + 96LL);
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v6;
  _OWORD v17[3] = v6;
  v17[0] = v6;
  v17[1] = v6;
  v4(a1, v17, a2);
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v15[2] = v7;
  _OWORD v15[3] = v7;
  v15[0] = v7;
  v15[1] = v7;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v13[2] = v7;
  _OWORD v13[3] = v7;
  v13[0] = v7;
  v13[1] = v7;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v11[2] = v7;
  _OWORD v11[3] = v7;
  __int128 v8 = (uint64_t *)(a2 + 144);
  v11[0] = v7;
  v11[1] = v7;
  v4(a1, v15, a2 + 144);
  v4(a1, v13, (uint64_t)v15);
  v5(a1, v11, v13, v15);
  if (a1[132])
  {
    ec_felem_add((uint64_t)a1, (unint64_t *)v15, (const unint64_t *)v13, (const unint64_t *)v13);
    ec_felem_add((uint64_t)a1, (unint64_t *)v15, (const unint64_t *)v15, (const unint64_t *)v13);
    ec_felem_sub((uint64_t)a1, (unint64_t *)v17, (const unint64_t *)v17, (const unint64_t *)v15);
  }

  else
  {
    v5(a1, v15, v13, a1 + 90);
    ec_felem_add((uint64_t)a1, (unint64_t *)v17, (const unint64_t *)v17, (const unint64_t *)v15);
  }

  v5(a1, v17, v17, (_OWORD *)a2);
  v5(a1, v15, (_OWORD *)a1 + 27, v11);
  ec_felem_add((uint64_t)a1, (unint64_t *)v17, (const unint64_t *)v17, (const unint64_t *)v15);
  v4(a1, v15, a2 + 72);
  ec_felem_sub((uint64_t)a1, (unint64_t *)v15, (const unint64_t *)v15, (const unint64_t *)v17);
  int v9 = ec_felem_non_zero_mask((uint64_t)a1, (uint64_t *)v15);
  return (ec_felem_non_zero_mask((uint64_t)a1, v8) & v9 & 1) == 0;
}

uint64_t ec_GFp_simple_points_equal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  __int128 v7 = *(void (**)(uint64_t, _OWORD *, _OWORD *, uint64_t *))(*(void *)a1 + 88LL);
  __int128 v6 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 96LL);
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v19[2] = v8;
  _OWORD v19[3] = v8;
  v19[0] = v8;
  v19[1] = v8;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v8;
  _OWORD v17[3] = v8;
  v17[0] = v8;
  v17[1] = v8;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  void v15[2] = v8;
  _OWORD v15[3] = v8;
  v15[0] = v8;
  v15[1] = v8;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v13[2] = v8;
  _OWORD v13[3] = v8;
  int v9 = (uint64_t *)(a3 + 144);
  v13[0] = v8;
  v13[1] = v8;
  v6(a1, v13, a3 + 144);
  v7(a1, v19, (_OWORD *)a2, (uint64_t *)v13);
  __int128 v10 = (uint64_t *)(a2 + 144);
  v6(a1, v15, a2 + 144);
  v7(a1, v17, (_OWORD *)v3, (uint64_t *)v15);
  ec_felem_sub(a1, (unint64_t *)v19, (const unint64_t *)v19, (const unint64_t *)v17);
  LODWORD(v6) = ec_felem_non_zero_mask(a1, (uint64_t *)v19);
  v7(a1, v13, v13, v9);
  v7(a1, v19, (_OWORD *)(a2 + 72), (uint64_t *)v13);
  v7(a1, v15, v15, (uint64_t *)(a2 + 144));
  v7(a1, v17, (_OWORD *)(v3 + 72), (uint64_t *)v15);
  ec_felem_sub(a1, (unint64_t *)v19, (const unint64_t *)v19, (const unint64_t *)v17);
  LODWORD(a2) = ec_felem_non_zero_mask(a1, (uint64_t *)v19) | v6;
  LODWORD(v3) = ec_felem_non_zero_mask(a1, v10);
  int v11 = ec_felem_non_zero_mask(a1, v9);
  return (v3 & ~(_BYTE)a2) & v11 & 1 | (((v11 | v3) & 1) == 0);
}

uint64_t ec_GFp_simple_cmp_x_coordinate(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = ec_felem_non_zero_mask(a1, (uint64_t *)(a2 + 144));
  if (result)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    _OWORD v8[2] = v7;
    _OWORD v8[3] = v7;
    v8[0] = v7;
    v8[1] = v7;
    uint64_t result = ec_get_x_coordinate_as_scalar(a1, (unint64_t *)v8, a2);
    if ((_DWORD)result) {
      return ec_scalar_equal_vartime(a1, v8, a3);
    }
  }

  return result;
}

void ec_GFp_simple_felem_to_bytes(uint64_t a1, char *a2, unint64_t *a3, char *a4)
{
  unint64_t v8 = BN_num_bytes((const BIGNUM *)(a1 + 320));
  bn_words_to_big_endian(a2, v8, a4, *(int *)(a1 + 328));
  *a3 = v8;
}

uint64_t ec_GFp_simple_felem_from_bytes( uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unint64_t a4)
{
  if (BN_num_bytes((const BIGNUM *)(a1 + 320)) == a4)
  {
    bn_big_endian_to_words(a2, *(int *)(a1 + 328), a3, a4);
    int v9 = 331;
  }

  else
  {
    int v9 = 324;
  }

  ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/simple.c", v9);
  return 0LL;
}

void bn_mont_ctx_init(uint64_t a1)
{
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v30 - 136), 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  BN_init((BIGNUM *)a1);
  BN_init((BIGNUM *)(a1 + 24));
}

void bn_mont_ctx_cleanup(BIGNUM *a1)
{
}

BN_MONT_CTX *BN_MONT_CTX_new(void)
{
  uint64_t v0 = (BN_MONT_CTX *)OPENSSL_malloc(0x40uLL);
  uint64_t v1 = v0;
  if (v0) {
    bn_mont_ctx_init((uint64_t)v0);
  }
  return v1;
}

uint64_t bn_mont_ctx_set_N_and_n0(uint64_t a1, const BIGNUM *a2)
{
  if (BN_is_zero((uint64_t)a2))
  {
    int v4 = 105;
    int v5 = 170;
LABEL_3:
    ERR_put_error(3, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", v5);
    return 0LL;
  }

  if (!BN_is_odd((uint64_t)a2))
  {
    int v4 = 104;
    int v5 = 174;
    goto LABEL_3;
  }

  if (BN_is_negative((uint64_t)a2))
  {
    int v4 = 109;
    int v5 = 178;
    goto LABEL_3;
  }

  if (!bn_fits_in_words((uint64_t)a2, 0x400uLL))
  {
    int v4 = 102;
    int v5 = 182;
    goto LABEL_3;
  }

  if (!BN_copy((BIGNUM *)(a1 + 24), a2))
  {
    int v4 = 68;
    int v5 = 188;
    goto LABEL_3;
  }

  bn_set_minimal_width(a1 + 24);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v30 - 136), 8) = bn_mont_n0((unint64_t **)(a1 + 24));
  *(void *)(a1 + 56) = 0LL;
  return 1LL;
}

BN_MONT_CTX *BN_MONT_CTX_new_consttime(const BIGNUM *a1, BN_CTX *a2)
{
  int v4 = BN_MONT_CTX_new();
  int v5 = v4;
  if (!v4
    || !bn_mont_ctx_set_N_and_n0((uint64_t)v4, a1)
    || !bn_mont_ctx_set_RR_consttime((BIGNUM *)v5, a2))
  {
    BN_MONT_CTX_free(v5);
    return 0LL;
  }

  return v5;
}

uint64_t BN_to_montgomery(BIGNUM *a1, const BIGNUM *a2, BIGNUM *mont, BN_CTX *ctx)
{
  return BN_mod_mul_montgomery(a1, a2, mont, (BN_MONT_CTX *)mont, ctx);
}

int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_MONT_CTX *mont, BN_CTX *ctx)
{
  if (!a->neg && !b->neg)
  {
    BN_CTX_start(ctx);
    unint64_t v12 = BN_CTX_get(ctx);
    if (v12)
    {
      uint64_t v13 = (uint64_t)v12;
      if (a == b)
      {
      }

      else if (bn_mul_consttime(v12, (BIGNUM *)a, (BIGNUM *)b, ctx))
      {
LABEL_8:
        int v6 = BN_from_montgomery_word((uint64_t)r, v13, (uint64_t)mont);
LABEL_11:
        BN_CTX_end(ctx);
        return v6;
      }
    }

    int v6 = 0;
    goto LABEL_11;
  }

  ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", 421);
  return 0;
}

int BN_from_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx)
{
  unint64_t v8 = BN_CTX_get(ctx);
  else {
    int v10 = 0;
  }
  BN_CTX_end(ctx);
  return v10;
}

uint64_t BN_from_montgomery_word(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 16))
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", 323);
    return 0LL;
  }

  else
  {
    uint64_t v6 = *(int *)(a3 + 32);
    if ((_DWORD)v6)
    {
      uint64_t result = bn_resize_words(a2, 2 * v6);
      if ((_DWORD)result)
      {
        uint64_t result = bn_wexpand((void **)a1, *(int *)(a3 + 32));
        if ((_DWORD)result)
        {
          unint64_t v8 = *(int *)(a3 + 32);
          *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = v8;
          *(_DWORD *)(a1 + 16) = 0;
          return bn_from_montgomery_in_place( *(unint64_t **)a1,  v8,  *(unint64_t **)a2,  *(int *)(a2 + 8),  a3);
        }
      }
    }

    else
    {
      *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0;
      return 1LL;
    }
  }

  return result;
}

uint64_t bn_one_to_montgomery(BIGNUM *r, BIGNUM *a, BN_CTX *ctx)
{
  unint64_t top = a[1].top;
  uint64_t result = bn_wexpand(&r->d, top);
  if ((_DWORD)result)
  {
    unsigned int d = a[1].d;
    unint64_t v8 = r->d;
    *r->unsigned int d = -(uint64_t)*d;
    uint64_t v9 = a[1].top;
    if ((int)v9 >= 2)
    {
      int v10 = (uint64_t *)(v8 + 1);
      int v11 = (uint64_t *)(d + 1);
      uint64_t v12 = v9 - 1;
      do
      {
        uint64_t v13 = *v11++;
        *v10++ = ~v13;
        --v12;
      }

      while (v12);
    }

    r->unint64_t top = v9;
    r->neg = 0;
    return 1LL;
  }

  return result;
}

void bn_to_montgomery_small( unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t **a4)
{
}

void bn_mod_mul_montgomery_small( unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a4 > 9 || *(_DWORD *)(a5 + 32) != a4) {
    goto LABEL_8;
  }
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[7] = v10;
  v12[8] = v10;
  v12[5] = v10;
  v12[6] = v10;
  _OWORD v12[3] = v10;
  _OWORD v12[4] = v10;
  v12[1] = v10;
  __int128 v12[2] = v10;
  v12[0] = v10;
  uint64_t v11 = 2 * a4;
  if (a2 == a3) {
    bn_sqr_small((unint64_t *)v12, v11, a2, a4);
  }
  else {
    bn_mul_small((unint64_t *)v12, v11, a2, a4, a3, a4);
  }
  if (!bn_from_montgomery_in_place(a1, a4, (unint64_t *)v12, 2 * a4, a5)) {
LABEL_8:
  }
    abort();
  OPENSSL_cleanse(v12, 16 * a4);
}

void bn_from_montgomery_small( unint64_t *a1, unint64_t num, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (num > 9) {
    goto LABEL_11;
  }
  unint64_t v7 = 2 * num;
  if (*(_DWORD *)(a5 + 32) != num || v7 < a4) {
    goto LABEL_11;
  }
  memset(v10, 0, sizeof(v10));
  if (a4) {
    __memcpy_chk();
  }
  if (!bn_from_montgomery_in_place(a1, num, (unint64_t *)v10, v7, a5)) {
LABEL_11:
  }
    abort();
  OPENSSL_cleanse(v10, 16 * num);
}

uint64_t bn_from_montgomery_in_place( unint64_t *a1, unint64_t num, unint64_t *rp, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(int *)(a5 + 32);
  if (v5 == num && 2 * v5 == a4)
  {
    uint64_t v11 = *(unint64_t **)(a5 + 24);
    unint64_t v12 = 0LL;
    if ((_DWORD)v5)
    {
      uint64_t v13 = *(void *)(a5 + 48);
      if (num <= 1) {
        uint64_t v14 = 1LL;
      }
      else {
        uint64_t v14 = num;
      }
      int v15 = rp;
      do
      {
        unint64_t v16 = bn_mul_add_words(v15, v11, num, *v15 * v13);
        unint64_t v17 = v15[num];
        unint64_t v18 = v16 + v12 + v17;
        unint64_t v12 = (v12 | (v16 + v12 != 0)) & (unint64_t)(v18 <= v17);
        v15[num] = v18;
        ++v15;
        --v14;
      }

      while (v14);
    }

    bn_reduce_once(a1, &rp[num], v12, v11, num);
    return 1LL;
  }

  else
  {
    ERR_put_error(3, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/montgomery.c", 294);
    return 0LL;
  }

int SHA384_Init(SHA512_CTX *c)
{
  *(_OWORD *)c->h = xmmword_187603EE0;
  *(_OWORD *)&c->h[2] = xmmword_187603EF0;
  *(_OWORD *)&c->h[4] = xmmword_187603F00;
  *(_OWORD *)&c->h[6] = xmmword_187603F10;
  c->Nl = 0LL;
  c->Nh = 0LL;
  *(void *)&c->uint64_t num = 0x3000000000LL;
  return 1;
}

int SHA512_Init(SHA512_CTX *c)
{
  *(_OWORD *)c->h = xmmword_187603F20;
  *(_OWORD *)&c->h[2] = xmmword_187603F30;
  *(_OWORD *)&c->h[4] = xmmword_187603F40;
  *(_OWORD *)&c->h[6] = xmmword_187603F50;
  c->Nl = 0LL;
  c->Nh = 0LL;
  *(void *)&c->uint64_t num = 0x4000000000LL;
  return 1;
}

unsigned __int8 *__cdecl SHA512(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v6.u.p[96] = v4;
  *(_OWORD *)&v6.u.p[112] = v4;
  *(_OWORD *)&v6.u.p[64] = v4;
  *(_OWORD *)&v6.u.p[80] = v4;
  *(_OWORD *)&v6.u.p[32] = v4;
  *(_OWORD *)&v6.u.p[48] = v4;
  *(_OWORD *)v6.u.unsigned int d = v4;
  *(_OWORD *)&v6.u.p[16] = v4;
  *(_OWORD *)v6.h = xmmword_187603F20;
  *(_OWORD *)&v6.h[2] = xmmword_187603F30;
  *(_OWORD *)&v6.h[4] = xmmword_187603F40;
  *(_OWORD *)&v6.h[6] = xmmword_187603F50;
  v6.Nl = 0LL;
  v6.Nh = 0LL;
  *(void *)&v6.uint64_t num = 0x4000000000LL;
  SHA512_Update(&v6, d, n);
  sha512_final_impl(md, v6.md_len, (int8x16_t *)&v6);
  OPENSSL_cleanse(&v6, 0xD8uLL);
  return md;
}

int SHA512_Update(SHA512_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    __int128 v4 = (unint64_t *)data;
    p_u = &c->u;
    *(_OWORD *)&c->Nl += __PAIR128__(len >> 61, 8 * len);
    uint64_t num = c->num;
    if ((_DWORD)num)
    {
      uint64_t v8 = 128 - num;
      size_t v9 = len - (128 - num);
      if (len < 128 - num)
      {
        memcpy((char *)p_u + num, data, len);
        LODWORD(v3) = c->num + v3;
LABEL_12:
        c->uint64_t num = v3;
        return 1;
      }

      if ((_DWORD)num != 128) {
        memcpy((char *)p_u + num, data, 128 - num);
      }
      c->uint64_t num = 0;
      __int128 v4 = (unint64_t *)((char *)v4 + v8);
      sha512_block_data_order((unint64_t)c, p_u->d, 1LL);
      size_t v3 = v9;
    }

    if (v3 >= 0x80)
    {
      sha512_block_data_order((unint64_t)c, v4, v3 >> 7);
      __int128 v10 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      __int128 v4 = (unint64_t *)&v10[-v3];
    }

    if (v3)
    {
      memcpy(p_u, v4, v3);
      goto LABEL_12;
    }
  }

  return 1;
}

int SHA512_Final(unsigned __int8 *md, SHA512_CTX *c)
{
  return sha512_final_impl(md, c->md_len, (int8x16_t *)c);
}

uint64_t sha512_final_impl(void *a1, unint64_t a2, int8x16_t *a3)
{
  size_t v3 = a3;
  SHA512_CTX v6 = (unint64_t *)&a3[5];
  uint64_t v7 = a3[13].u32[0];
  a3[5].i8[v7] = 0x80;
  uint64_t v8 = v7 + 1;
  if (v7 < 0x70)
  {
    if (v7 == 111) {
      goto LABEL_7;
    }
  }

  else
  {
    if ((_DWORD)v7 != 127) {
      bzero((char *)v6 + v8, 127 - v7);
    }
    sha512_block_data_order((unint64_t)v3, v6, 1LL);
    uint64_t v8 = 0LL;
  }

  bzero((char *)v6 + v8, 112 - v8);
LABEL_7:
  int8x16_t v9 = vrev64q_s8(v3[4]);
  v3[12] = vextq_s8(v9, v9, 8uLL);
  sha512_block_data_order((unint64_t)v3, v6, 1LL);
  if (!a1) {
    return 0LL;
  }
  if ((a2 & 7) != 0) {
    sha512_final_impl_cold_1();
  }
  if (a2 >= 8)
  {
    unint64_t v10 = a2 >> 3;
    do
    {
      unint64_t v11 = v3->i64[0];
      size_t v3 = (int8x16_t *)((char *)v3 + 8);
      *a1++ = bswap64(v11);
      --v10;
    }

    while (v10);
  }

  return 1LL;
}

void SHA512_Transform(SHA512_CTX *c, const unsigned __int8 *data)
{
}

unint64_t sha512_block_data_order(unint64_t result, unint64_t *a2, uint64_t a3)
{
  int v123 = (void *)result;
  if (a3)
  {
    uint64_t v4 = *(void *)result;
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v5 = *(void *)(result + 24);
    uint64_t v8 = *(void *)(result + 32);
    unint64_t v7 = *(void *)(result + 40);
    uint64_t v10 = *(void *)(result + 48);
    uint64_t v9 = *(void *)(result + 56);
    do
    {
      uint64_t v132 = a3;
      unint64_t v138 = 0LL;
      unint64_t v139 = bswap64(*a2);
      uint64_t v124 = v9;
      uint64_t v11 = v9
          + (v8 & v7)
          + (v10 & ~v8)
          + v139
          + (__ROR8__(v8, 14) ^ __ROR8__(v8, 18) ^ __ROR8__(v8, 41))
          + 0x428A2F98D728AE22LL;
      uint64_t v128 = v5;
      uint64_t v12 = v11 + v5;
      uint64_t v13 = (__ROR8__(v4, 28) ^ __ROR8__(v4, 34) ^ __ROR8__(v4, 39)) + ((v3 ^ v6) & v4 ^ v3 & v6) + v11;
      unint64_t v14 = bswap64(a2[1]);
      uint64_t v125 = v10;
      uint64_t v15 = v10
          + v14
          + (v7 & ~v12)
          + (v12 & v8)
          + 0x7137449123EF65CDLL
          + (__ROR8__(v12, 14) ^ __ROR8__(v12, 18) ^ __ROR8__(v12, 41));
      uint64_t v129 = v6;
      uint64_t v16 = v15 + v6;
      uint64_t v17 = (__ROR8__(v13, 28) ^ __ROR8__(v13, 34) ^ __ROR8__(v13, 39)) + (v13 & (v4 ^ v3) ^ v4 & v3) + v15;
      unint64_t v18 = bswap64(a2[2]);
      unint64_t v126 = v7;
      uint64_t v19 = v7
          + v18
          + (v8 & ~v16)
          + (v16 & v12)
          - 0x4A3F043013B2C4D1LL
          + (__ROR8__(v15 + v6, 14) ^ __ROR8__(v15 + v6, 18) ^ __ROR8__(v16, 41));
      uint64_t v130 = v3;
      uint64_t v20 = v19 + v3;
      uint64_t v21 = (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + (v17 & (v13 ^ v4) ^ v13 & v4) + v19;
      unint64_t v22 = bswap64(a2[3]);
      uint64_t v127 = v8;
      uint64_t v23 = v8
          + v22
          + (v12 & ~v20)
          + (v20 & v16)
          - 0x164A245A7E762444LL
          + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41));
      uint64_t v131 = v4;
      uint64_t v24 = v23 + v4;
      uint64_t v25 = (__ROR8__(v21, 28) ^ __ROR8__(v21, 34) ^ __ROR8__(v21, 39)) + (v21 & (v17 ^ v13) ^ v17 & v13) + v23;
      unint64_t v26 = bswap64(a2[4]);
      uint64_t v27 = v12
          + v26
          + (v16 & ~v24)
          + (v24 & v20)
          + 0x3956C25BF348B538LL
          + (__ROR8__(v24, 14) ^ __ROR8__(v24, 18) ^ __ROR8__(v24, 41));
      uint64_t v28 = v27 + v13;
      uint64_t v29 = (__ROR8__(v25, 28) ^ __ROR8__(v25, 34) ^ __ROR8__(v25, 39)) + (v25 & (v21 ^ v17) ^ v21 & v17) + v27;
      unint64_t v30 = bswap64(a2[5]);
      uint64_t v31 = v30
          + v16
          + (v20 & ~v28)
          + (v28 & v24)
          + 0x59F111F1B605D019LL
          + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
      uint64_t v32 = v31 + v17;
      uint64_t v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v25 ^ v21) ^ v25 & v21) + v31;
      unint64_t v34 = bswap64(a2[6]);
      uint64_t v35 = v34
          + v20
          + (v24 & ~v32)
          + (v32 & v28)
          - 0x6DC07D5B50E6B065LL
          + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
      uint64_t v36 = v35 + v21;
      uint64_t v37 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 ^ v25) ^ v29 & v25) + v35;
      unint64_t v137 = bswap64(a2[7]);
      uint64_t v38 = v137
          + v24
          + (v28 & ~v36)
          + (v36 & v32)
          - 0x54E3A12A25927EE8LL
          + (__ROR8__(v36, 14) ^ __ROR8__(v36, 18) ^ __ROR8__(v36, 41));
      uint64_t v39 = v38 + v25;
      uint64_t v40 = (__ROR8__(v37, 28) ^ __ROR8__(v37, 34) ^ __ROR8__(v37, 39)) + (v37 & (v33 ^ v29) ^ v33 & v29) + v38;
      unint64_t v136 = bswap64(a2[8]);
      uint64_t v41 = v136
          + v28
          + (v32 & ~v39)
          + (v39 & v36)
          - 0x27F855675CFCFDBELL
          + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
      uint64_t v42 = v41 + v29;
      uint64_t v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v37 ^ v33) ^ v37 & v33) + v41;
      unint64_t v135 = bswap64(a2[9]);
      uint64_t v44 = v135
          + v32
          + (v36 & ~v42)
          + (v42 & v39)
          + 0x12835B0145706FBELL
          + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
      uint64_t v45 = v44 + v33;
      uint64_t v46 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 ^ v37) ^ v40 & v37) + v44;
      unint64_t v134 = bswap64(a2[10]);
      uint64_t v47 = v134
          + v36
          + (v39 & ~v45)
          + (v45 & v42)
          + 0x243185BE4EE4B28CLL
          + (__ROR8__(v45, 14) ^ __ROR8__(v45, 18) ^ __ROR8__(v45, 41));
      uint64_t v48 = v47 + v37;
      uint64_t v49 = (__ROR8__(v46, 28) ^ __ROR8__(v46, 34) ^ __ROR8__(v46, 39)) + (v46 & (v43 ^ v40) ^ v43 & v40) + v47;
      unint64_t v50 = bswap64(a2[11]);
      uint64_t v51 = v50
          + v39
          + (v42 & ~v48)
          + (v48 & v45)
          + 0x550C7DC3D5FFB4E2LL
          + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41));
      uint64_t v52 = v51 + v40;
      uint64_t v53 = (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + (v49 & (v46 ^ v43) ^ v46 & v43) + v51;
      unint64_t v54 = bswap64(a2[12]);
      uint64_t v55 = v54
          + v42
          + (v45 & ~v52)
          + (v52 & v48)
          + 0x72BE5D74F27B896FLL
          + (__ROR8__(v52, 14) ^ __ROR8__(v52, 18) ^ __ROR8__(v52, 41));
      uint64_t v56 = v55 + v43;
      uint64_t v57 = (__ROR8__(v53, 28) ^ __ROR8__(v53, 34) ^ __ROR8__(v53, 39)) + (v53 & (v49 ^ v46) ^ v49 & v46) + v55;
      unint64_t v58 = bswap64(a2[13]);
      uint64_t v59 = v58
          + v45
          + (v48 & ~v56)
          + (v56 & v52)
          - 0x7F214E01C4E9694FLL
          + (__ROR8__(v55 + v43, 14) ^ __ROR8__(v55 + v43, 18) ^ __ROR8__(v56, 41));
      uint64_t v60 = v59 + v46;
      uint64_t v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v53 ^ v49) ^ v53 & v49) + v59;
      unint64_t v62 = bswap64(a2[14]);
      uint64_t v63 = v62
          + v48
          + (v52 & ~v60)
          + (v60 & v56)
          - 0x6423F958DA38EDCBLL
          + (__ROR8__(v59 + v46, 14) ^ __ROR8__(v59 + v46, 18) ^ __ROR8__(v60, 41));
      uint64_t result = v63 + v49;
      uint64_t v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v53) ^ v57 & v53) + v63;
      unint64_t v65 = bswap64(a2[15]);
      uint64_t v66 = v65
          + v52
          + (v56 & ~result)
          + (result & v60)
          - 0x3E640E8B3096D96CLL
          + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
      unint64_t v67 = v139;
      uint64_t v68 = v66 + v53;
      uint64_t v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v66;
      __int128 v70 = &qword_187604068;
      do
      {
        unint64_t v133 = v50;
        unint64_t v71 = v135
            + v67
            + (__ROR8__(v62, 19) ^ __ROR8__(v62, 61) ^ (v62 >> 6))
            + (__ROR8__(v14, 1) ^ __ROR8__(v14, 8) ^ (v14 >> 7));
        unint64_t v72 = (v68 & result)
            + v56
            + (v60 & ~v68)
            + (__ROR8__(v68, 14) ^ __ROR8__(v68, 18) ^ __ROR8__(v68, 41))
            + *(v70 - 15)
            + v71;
        unint64_t v73 = v72 + v57;
        unint64_t v74 = (__ROR8__(v69, 28) ^ __ROR8__(v69, 34) ^ __ROR8__(v69, 39)) + ((v64 ^ v61) & v69 ^ v64 & v61) + v72;
        unint64_t v75 = v54;
        unint64_t v76 = v134
            + v14
            + (__ROR8__(v65, 19) ^ __ROR8__(v65, 61) ^ (v65 >> 6))
            + (__ROR8__(v18, 1) ^ __ROR8__(v18, 8) ^ (v18 >> 7));
        unint64_t v77 = v76
            + v60
            + *(v70 - 14)
            + (result & ~v73)
            + (v73 & v68)
            + (__ROR8__(v73, 14) ^ __ROR8__(v73, 18) ^ __ROR8__(v73, 41));
        unint64_t v78 = v77 + v61;
        unint64_t v79 = (__ROR8__(v74, 28) ^ __ROR8__(v74, 34) ^ __ROR8__(v74, 39)) + (v74 & (v69 ^ v64) ^ v69 & v64) + v77;
        unint64_t v140 = v71;
        unint64_t v80 = v18
            + v50
            + (__ROR8__(v22, 1) ^ __ROR8__(v22, 8) ^ (v22 >> 7))
            + (__ROR8__(v71, 19) ^ __ROR8__(v71, 61) ^ (v71 >> 6));
        __int128 v81 = (char *)(v80
                     + result
                     + *(v70 - 13)
                     + (v68 & ~v78)
                     + (v78 & v73)
                     + (__ROR8__(v77 + v61, 14) ^ __ROR8__(v77 + v61, 18) ^ __ROR8__(v78, 41)));
        __int128 v82 = &v81[v64];
        __int128 v83 = &v81[(__ROR8__(v79, 28) ^ __ROR8__(v79, 34) ^ __ROR8__(v79, 39)) + (v79 & (v74 ^ v69) ^ v74 & v69)];
        unint64_t v84 = v22
            + v54
            + (__ROR8__(v26, 1) ^ __ROR8__(v26, 8) ^ (v26 >> 7))
            + (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6));
        uint64_t v85 = v84
            + v68
            + *(v70 - 12)
            + (v73 & ~(unint64_t)v82)
        uint64_t v86 = v85 + v69;
        uint64_t v87 = (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39))
        v26 += v58
             + (__ROR8__(v30, 1) ^ __ROR8__(v30, 8) ^ (v30 >> 7))
             + (__ROR8__(v80, 19) ^ __ROR8__(v80, 61) ^ (v80 >> 6));
        unint64_t v88 = v73
            + *(v70 - 11)
            + v26
            + (v78 & ~v86)
        unint64_t v89 = v88 + v74;
        unint64_t v90 = (__ROR8__(v87, 28) ^ __ROR8__(v87, 34) ^ __ROR8__(v87, 39))
        v30 += v62
             + (__ROR8__(v34, 1) ^ __ROR8__(v34, 8) ^ (v34 >> 7))
             + (__ROR8__(v84, 19) ^ __ROR8__(v84, 61) ^ (v84 >> 6));
        unint64_t v91 = *(v70 - 10)
            + v78
            + v30
            + ((unint64_t)v82 & ~v89)
            + (v89 & v86)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        unint64_t v92 = v91 + v79;
        unint64_t v93 = (__ROR8__(v90, 28) ^ __ROR8__(v90, 34) ^ __ROR8__(v90, 39))
        v34 += v65
             + (__ROR8__(v137, 1) ^ __ROR8__(v137, 8) ^ (v137 >> 7))
             + (__ROR8__(v26, 19) ^ __ROR8__(v26, 61) ^ (v26 >> 6));
        unint64_t v94 = (unint64_t)&v82[*(v70 - 9)
                                   + v34
                                   + (v86 & ~v92)
                                   + (v92 & v89)
                                   + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41))];
        __int128 v95 = &v83[v94];
        unint64_t v96 = (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39)) + (v93 & (v90 ^ v87) ^ v90 & v87) + v94;
        unint64_t v97 = (__ROR8__(v136, 1) ^ __ROR8__(v136, 8) ^ (v136 >> 7))
            + v137
            + v140
            + (__ROR8__(v30, 19) ^ __ROR8__(v30, 61) ^ (v30 >> 6));
        uint64_t v98 = *(v70 - 8)
            + v97
            + v86
            + (v89 & ~(unint64_t)v95)
        uint64_t v99 = v98 + v87;
        uint64_t v100 = (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + (v96 & (v93 ^ v90) ^ v93 & v90) + v98;
        unint64_t v101 = (__ROR8__(v135, 1) ^ __ROR8__(v135, 8) ^ (v135 >> 7))
             + v136
             + v76
             + (__ROR8__(v34, 19) ^ __ROR8__(v34, 61) ^ (v34 >> 6));
        uint64_t v102 = v101
             + *(v70 - 7)
             + v89
             + (v92 & ~v99)
        unint64_t v103 = v102 + v90;
        uint64_t v104 = (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39)) + (v100 & (v96 ^ v93) ^ v96 & v93) + v102;
        unint64_t v105 = (__ROR8__(v134, 1) ^ __ROR8__(v134, 8) ^ (v134 >> 7))
             + v135
             + v80
             + (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6));
        uint64_t v106 = v105
             + *(v70 - 6)
             + v92
             + ((unint64_t)v95 & ~v103)
             + (v103 & v99)
             + (__ROR8__(v103, 14) ^ __ROR8__(v103, 18) ^ __ROR8__(v103, 41));
        unint64_t v107 = v106 + v93;
        uint64_t v108 = (__ROR8__(v104, 28) ^ __ROR8__(v104, 34) ^ __ROR8__(v104, 39))
             + (v104 & (v100 ^ v96) ^ v100 & v96)
             + v106;
        unint64_t v109 = (__ROR8__(v133, 1) ^ __ROR8__(v133, 8) ^ (v133 >> 7))
             + v134
             + v84
             + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6));
        uint64_t v110 = (uint64_t)&v95[v109
                           + *(v70 - 5)
                           + (v99 & ~v107)
                           + (v107 & v103)
                           + (__ROR8__(v107, 14) ^ __ROR8__(v107, 18) ^ __ROR8__(v107, 41))];
        unint64_t v111 = v110 + v96;
        uint64_t v112 = (__ROR8__(v108, 28) ^ __ROR8__(v108, 34) ^ __ROR8__(v108, 39))
             + (v108 & (v104 ^ v100) ^ v104 & v100)
             + v110;
        unint64_t v135 = v105;
        unint64_t v50 = (__ROR8__(v75, 1) ^ __ROR8__(v75, 8) ^ (v75 >> 7))
            + v133
            + v26
            + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6));
        unint64_t v113 = v50
             + *(v70 - 4)
             + v99
             + (v103 & ~v111)
             + (v111 & v107)
             + (__ROR8__(v110 + v96, 14) ^ __ROR8__(v110 + v96, 18) ^ __ROR8__(v111, 41));
        unint64_t v114 = v113 + v100;
        unint64_t v115 = (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39))
             + (v112 & (v108 ^ v104) ^ v108 & v104)
             + v113;
        unint64_t v134 = v109;
        unint64_t v54 = (__ROR8__(v58, 1) ^ __ROR8__(v58, 8) ^ (v58 >> 7))
            + v75
            + v30
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
        unint64_t v116 = v54
             + *(v70 - 3)
             + v103
             + (v107 & ~v114)
             + (v114 & v111)
             + (__ROR8__(v114, 14) ^ __ROR8__(v114, 18) ^ __ROR8__(v114, 41));
        uint64_t v56 = v116 + v104;
        uint64_t v57 = (__ROR8__(v115, 28) ^ __ROR8__(v115, 34) ^ __ROR8__(v115, 39))
            + (v115 & (v112 ^ v108) ^ v112 & v108)
            + v116;
        v58 += (__ROR8__(v62, 1) ^ __ROR8__(v62, 8) ^ (v62 >> 7))
             + v34
             + (__ROR8__(v50, 19) ^ __ROR8__(v50, 61) ^ (v50 >> 6));
        unint64_t v117 = v58
             + *(v70 - 2)
             + v107
             + (v111 & ~v56)
             + (v56 & v114)
             + (__ROR8__(v116 + v104, 14) ^ __ROR8__(v116 + v104, 18) ^ __ROR8__(v56, 41));
        uint64_t v60 = v117 + v108;
        uint64_t v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v115 ^ v112) ^ v115 & v112) + v117;
        unint64_t v137 = v97;
        unint64_t v118 = (__ROR8__(v65, 1) ^ __ROR8__(v65, 8) ^ (v65 >> 7)) + v62 + v97;
        unint64_t v18 = v80;
        unint64_t v62 = v118 + (__ROR8__(v54, 19) ^ __ROR8__(v54, 61) ^ (v54 >> 6));
        unint64_t v67 = v140;
        unint64_t v119 = v62
             + *(v70 - 1)
             + v111
             + (v114 & ~v60)
             + (v60 & v56)
             + (__ROR8__(v60, 14) ^ __ROR8__(v60, 18) ^ __ROR8__(v60, 41));
        uint64_t result = v119 + v112;
        uint64_t v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v115) ^ v57 & v115) + v119;
        unint64_t v136 = v101;
        unint64_t v120 = (__ROR8__(v140, 1) ^ __ROR8__(v140, 8) ^ (v140 >> 7)) + v65 + v101;
        unint64_t v22 = v84;
        unint64_t v65 = v120 + (__ROR8__(v58, 19) ^ __ROR8__(v58, 61) ^ (v58 >> 6));
        uint64_t v121 = *v70;
        v70 += 16;
        unint64_t v122 = v65
             + v121
             + v114
             + (v56 & ~result)
             + (result & v60)
             + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
        uint64_t v68 = v122 + v115;
        uint64_t v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v122;
        unint64_t v14 = v76;
        v138 += 16LL;
      }

      while (v138 < 0x40);
      uint64_t v4 = v69 + v131;
      uint64_t v3 = v64 + v130;
      *int v123 = v69 + v131;
      v123[1] = v64 + v130;
      uint64_t v6 = v61 + v129;
      uint64_t v5 = v57 + v128;
      v123[2] = v61 + v129;
      v123[3] = v57 + v128;
      uint64_t v8 = v68 + v127;
      unint64_t v7 = result + v126;
      v123[4] = v68 + v127;
      v123[5] = result + v126;
      uint64_t v10 = v60 + v125;
      uint64_t v9 = v56 + v124;
      a2 += 16;
      v123[6] = v60 + v125;
      v123[7] = v56 + v124;
      a3 = v132 - 1;
    }

    while (v132 != 1);
  }

  return result;
}

uint64_t bssl::tls13_server_handshake(bssl *this, bssl::SSL_HANDSHAKE *a2, ssl_session_st *a3)
{
  unint64_t v171 = (char *)this + 232;
  int v172 = (SSL_SESSION **)((char *)this + 1520);
  *(unsigned __int8 **)((char *)&d.tlsext_ocsp_resp + 1) = (unsigned __int8 *)*MEMORY[0x1895F89C0];
  unsigned int v175 = (char *)this + 88;
  int v176 = (size_t **)((char *)this + 424);
  unsigned int v177 = (char *)this + 136;
  int v169 = (char *)this + 280;
  __dst = (char *)this + 1597;
  unsigned int v174 = (bssl *)((char *)this + 328);
  uint64_t v165 = (char *)this + 184;
  int v166 = (char *)this + 632;
  int v167 = (bssl *)((char *)this + 736);
  unsigned int v168 = (uint64_t *)((char *)this + 600);
  int v170 = (ssl_credential_st **)((char *)this + 1504);
  while (2)
  {
    int v4 = *((_DWORD *)this + 6);
    uint64_t v5 = 1LL;
    switch(v4)
    {
      case 0:
        uint64_t v6 = *(bssl **)this;
        *(unint64_t *)((char *)&d.options + 1) = 0xAAAAAAAAAAAAAAAALL;
        v7.suint64_t k = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&v7.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.init_buf + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.init_num + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.handshake_func + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.quiet_shutdown + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.rbio + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.bbio + 1) = v7;
        *(CRYPTO_EX_DATA *)((char *)&d.version + 1) = v7;
        if (!bssl::SSL_HANDSHAKE::GetClientHello( (uint64_t *)this,  (uint64_t)&d.ex_data.sk + 1,  (uint64_t)&d.version + 1)) {
          goto LABEL_280;
        }
        char v8 = BYTE1(d.server);
        if (*((void *)v6 + 21)) {
          BOOL v9 = *(void *)((char *)&d.server + 1) == 0LL;
        }
        else {
          BOOL v9 = 1;
        }
        if (!v9)
        {
          ERR_put_error(16, 0, 306, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 273);
          bssl::ssl_send_alert(v6, (ssl_st *)2, 47);
          goto LABEL_280;
        }

        *((_BYTE *)this + 1629) = v8;
        *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = 0LL;
        *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = 0LL;
        if (!*(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1))
        {
          ERR_put_error(16, 0, 174, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 286);
          int v93 = 80;
          goto LABEL_258;
        }

        uint64_t v10 = *(uint64_t **)((char *)&d.verify_callback + 1);
        uint64_t v11 = *(char **)((char *)&d.verify_callback + 1) + 8 * *(uint64_t *)((char *)&d.info_callback + 1);
        while (1)
        {
          uint64_t v12 = *v10;
          ERR_clear_error();
          *(_WORD *)&d.sid_ctx[13] = -21846;
          int v14 = *(_DWORD *)(v12 + 4);
          if (v14 == 2)
          {
            if ((*((_BYTE *)this + 1586) & 0x20) == 0 || *((_BYTE *)this + 730) != 2)
            {
              int v19 = 249;
LABEL_27:
              ERR_put_error(16, 0, 253, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", v19);
              goto LABEL_29;
            }
          }

          else if (v14 == 1)
          {
            uint64_t v15 = *((void *)this + 81);
            uint64_t v16 = *((void *)this + 82);
            if (v16)
            {
              uint64_t v17 = 2 * v16;
              unint64_t v18 = (unsigned __int16 *)*((void *)this + 81);
              while (*v18 != *(unsigned __int16 *)(v12 + 64))
              {
                ++v18;
                v17 -= 2LL;
                if (!v17)
                {
                  unint64_t v18 = (unsigned __int16 *)(v15 + 2 * v16);
                  break;
                }
              }
            }

            else
            {
              unint64_t v18 = (unsigned __int16 *)*((void *)this + 81);
            }

            if (v16 == ((uint64_t)v18 - v15) >> 1)
            {
              int v19 = 240;
              goto LABEL_27;
            }
          }

          if (bssl::tls1_choose_signature_algorithm( this,  (EVP_PKEY **)v12,  (const ssl_credential_st *)&d.sid_ctx[13],  v13))
          {
            if (v12) {
              SSL_CREDENTIAL_up_ref(v12);
            }
            std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100]( v170,  (ssl_credential_st *)v12);
            *((_WORD *)this + 797) = *(_WORD *)&d.sid_ctx[13];
LABEL_247:
            if (!*v170)
            {
              bssl::ssl_send_alert(v6, (ssl_st *)2, 40);
              goto LABEL_259;
            }

            __int128 v97 = *(_OWORD *)((char *)&d.quiet_shutdown + 1);
            uint64_t v98 = (ssl_credential_st *)bssl::ssl_protocol_version(v6, v20);
            unsigned int v99 = v98;
            uint64_t v100 = *((void *)v6 + 1);
            unsigned int v101 = *(unsigned __int16 *)(v100 + 301);
            if ((v101 & 0x800) != 0)
            {
              int v102 = (v101 >> 12) & 1;
            }

            else
            {
              LOBYTE(v102) = ssl_credential_st::UsesPrivateKey(v98) != 0;
              uint64_t v100 = *((void *)v6 + 1);
            }

            uint64_t v103 = bssl::ssl_choose_tls13_cipher( (unsigned __int16 *)v97,  *((uint64_t *)&v97 + 1),  v102,  v99,  *(_DWORD *)(v100 + 296));
            *((void *)this + 194) = v103;
            if (v103)
            {
              d.sid_ctx[13] = 50;
              if ((bssl::ssl_negotiate_alpn((uint64_t)this, (char *)&d.sid_ctx[13], (uint64_t)&d.version + 1) & 1) != 0)
              {
                unint64_t v105 = (bssl *)bssl::ssl_protocol_version(v6, v104);
                if (bssl::SSLTranscript::InitHash(v176, v105, *((const ssl_cipher_st **)this + 194)))
                {
                  uint64_t v5 = 1LL;
                  *((_DWORD *)this + 6) = 1;
                  goto LABEL_260;
                }
              }

              else
              {
                bssl::ssl_send_alert(v6, (ssl_st *)2, d.sid_ctx[13]);
              }

LABEL_259:
              uint64_t v5 = 0LL;
LABEL_260:
              OPENSSL_free(*(void **)((char *)&d.verify_callback + 1));
              goto LABEL_281;
            }

            ERR_put_error(16, 0, 184, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 310);
            int v93 = 40;
LABEL_258:
            bssl::ssl_send_alert(v6, (ssl_st *)2, v93);
            goto LABEL_259;
          }

LABEL_85:
              if ((bssl::ssl_negotiate_alps((bssl **)this, &d, (uint64_t)&d.version + 1) & 1) != 0)
              {
                *(void *)(*((void *)this + 190) + 20std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100]((unsigned int **)va, 0LL) = *((void *)this + 194);
                if ((bssl::tls1_get_shared_group(this, (const ssl_st *)(*((void *)this + 190) + 6LL), v44) & 1) == 0)
                {
                  ERR_put_error(16, 0, 266, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 496);
                  int version_low = 40;
                  goto LABEL_299;
                }

                BYTE1(d.verify_callback) = -86;
                if ((bssl::ssl_ext_key_share_parse_clienthello( (uint64_t)this,  (BOOL *)&d.verify_callback + 1,  0LL,  &d,  (uint64_t)&d.version + 1) & 1) == 0)
                {
                  int version_low = LOBYTE(d.version);
                  goto LABEL_299;
                }

                if ((*(_BYTE *)(v38 + 180) & 4) == 0)
                {
                  uint64_t v45 = *(void *)(v38 + 48);
                  int v46 = 1;
LABEL_90:
                  *(_DWORD *)(v45 + bssl::Array<unsigned short>::~Array(v16 + 256) = v46;
LABEL_318:
                  unint64_t v114 = *(const void **)(v45 + 496);
                  unint64_t v115 = *(void *)(v45 + 504);
                  p_sid_ctx_unint64_t length = (void **)&(*v172)[1].sid_ctx_length;
                  int v118 = bssl::Array<unsigned char>::Init((uint64_t)p_sid_ctx_length, v115);
                  char v119 = v118 ^ 1;
                  if (!v115) {
                    char v119 = 1;
                  }
                  if ((v119 & 1) == 0) {
                    memmove(*p_sid_ctx_length, v114, v115);
                  }
                  if (v118)
                  {
                    if ((*(_WORD *)(*(void *)(v38 + 48) + 220LL) & 0x400) == 0) {
                      goto LABEL_434;
                    }
                    unint64_t v120 = *v172;
                    uint64_t v121 = *(const void **)(v43 + 424);
                    unint64_t v122 = *(void *)(v43 + 432);
                    int v123 = (void **)&v120[1].sid_ctx[28];
                    int v124 = bssl::Array<unsigned char>::Init((uint64_t)&v120[1].sid_ctx[28], v122);
                    char v125 = v124 ^ 1;
                    if (!v122) {
                      char v125 = 1;
                    }
                    if ((v125 & 1) == 0) {
                      memmove(*v123, v121, v122);
                    }
                    if (v124)
                    {
LABEL_434:
                      if ((*(_BYTE *)(v38 + 180) & 4) == 0 || !*(void *)(v38 + 168)) {
                        goto LABEL_337;
                      }
                      uint64_t v126 = *((void *)this + 1);
                      uint64_t v127 = *(const void **)(v126 + 240);
                      unint64_t v128 = *(void *)(v126 + 248);
                      uint64_t v129 = (void **)(*((void *)this + 190) + 448LL);
                      int v130 = bssl::Array<unsigned char>::Init((uint64_t)v129, v128);
                      char v131 = v130 ^ 1;
                      if (!v128) {
                        char v131 = 1;
                      }
                      if ((v131 & 1) == 0) {
                        memmove(*v129, v127, v128);
                      }
                      if (v130)
                      {
LABEL_337:
                        uint64_t v132 = *(unsigned int (**)(char *))(*(void *)(v38 + 120) + 488LL);
                        if (!v132 || v132((char *)&d.version + 1))
                        {
                          unint64_t v133 = (bssl *)bssl::ssl_protocol_version((bssl *)v38, v117);
                          handshake_digest = bssl::ssl_get_handshake_digest(v133, *((void *)this + 194), v134);
                          EVP_MD_size(handshake_digest);
                          if ((*(_WORD *)(*(void *)(v38 + 48) + 220LL) & 0x40) != 0) {
                            unint64_t v136 = (const ssl_st *)&(*v172)->key_arg[3];
                          }
                          else {
                            unint64_t v136 = (const ssl_st *)&bssl::kZeroes;
                          }
                          if (!bssl::tls13_init_key_schedule((uint64_t)this, v136)
                            || (bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.ex_data.sk + 1) & 1) == 0)
                          {
                            goto LABEL_300;
                          }

                          uint64_t v137 = *(void *)(v38 + 48);
                          if ((*(_WORD *)(v137 + 220) & 0x400) != 0)
                          {
                            if ((bssl::tls13_derive_early_secret(this, a2) & 1) == 0) {
                              goto LABEL_300;
                            }
                          }

                          else if ((*((_BYTE *)this + 1585) & 8) != 0)
                          {
                            *(_WORD *)(v137 + 220) |= 1u;
                          }

                          if (BYTE1(d.verify_callback))
                          {
                            if (bssl::resolve_ecdhe_secret((uint64_t)this, (uint64_t)&d.version + 1))
                            {
                              (*(void (**)(uint64_t))(*(void *)v38 + 32LL))(v38);
                              OPENSSL_free((void *)*v168);
                              *unsigned int v168 = 0LL;
                              v168[1] = 0LL;
                              int v138 = 4;
LABEL_355:
                              *((_DWORD *)this + 6) = v138;
                              uint64_t v5 = 1LL;
LABEL_301:
                              if (v43) {
                                SSL_SESSION_free((SSL_SESSION *)v43);
                              }
                              goto LABEL_281;
                            }
                          }

                          else
                          {
                            (*(void (**)(uint64_t))(*(void *)v38 + 32LL))(v38);
                            if ((bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v176) & 1) != 0)
                            {
                              int v138 = 2;
                              goto LABEL_355;
                            }
                          }

  int v28 = 0;
LABEL_86:
  BN_CTX_end(v14);
  BN_CTX_free(v14);
  return v28;
}

LABEL_300:
                          uint64_t v5 = 0LL;
                          goto LABEL_301;
                        }

                        ERR_put_error( 16,  0,  133,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc",  579);
                      }
                    }
                  }

                  int version_low = 80;
LABEL_299:
                  bssl::ssl_send_alert((bssl *)v38, (ssl_st *)2, version_low);
                  goto LABEL_300;
                }

                if ((extension & 1) != 0)
                {
                  if (v43)
                  {
                    if (*(_DWORD *)(v43 + 380))
                    {
                      int v107 = *((_DWORD *)this + 396);
                      if ((v107 & 0x800) == 0)
                      {
                        uint64_t v45 = *(void *)(v38 + 48);
                        int v46 = 4;
                        goto LABEL_90;
                      }

                      uint64_t v45 = *(void *)(v38 + 48);
                      if ((v107 & 0x2000000) != 0)
                      {
                        int v108 = 10;
                        goto LABEL_317;
                      }

                      size_t v113 = *(void *)(v45 + 504);
                      if (v113 != *(void *)(v43 + 400)
                        || memcmp(*(const void **)(v45 + 496), *(const void **)(v43 + 392), v113))
                      {
                        int v108 = 9;
                        goto LABEL_317;
                      }

                      int v155 = *v172;
                      int v156 = *(unsigned __int8 *)(v43 + 440);
                      if (((v156 ^ LOBYTE((*v172)[1].peer)) & 0x40) != 0
                        || (size_t v157 = *(void *)&v155[1].sid_ctx[20], v157 != *(void *)(v43 + 416))
                        || memcmp(*(const void **)&v155[1].sid_ctx[12], *(const void **)(v43 + 408), v157))
                      {
                        int v108 = 14;
                        goto LABEL_317;
                      }

                      if ((*(_DWORD *)(v45 + 252) - 61) <= 0xFFFFFF86)
                      {
                        int v108 = 12;
                        goto LABEL_317;
                      }

                      if ((v156 & 0x20) == 0)
                      {
LABEL_398:
                        if (BYTE1(d.verify_callback))
                        {
                          if (*((void *)this + 194) != *(void *)(v43 + 200)) {
                            __assert_rtn( "do_select_session",  "tls13_server.cc",  542,  "hs->new_cipher == session->cipher");
                          }
                          uint64_t v158 = *(void *)(v38 + 48);
                          *(_DWORD *)(v158 + bssl::Array<unsigned short>::~Array(v16 + 256) = 2;
                          *(_WORD *)(v158 + 220) |= 0x400u;
                          uint64_t v45 = *(void *)(v38 + 48);
                          goto LABEL_318;
                        }

                        uint64_t v45 = *(void *)(v38 + 48);
                        int v46 = 8;
                        goto LABEL_90;
                      }

                      uint64_t v159 = *(void *)(v43 + 456);
                      if (v159)
                      {
                        uint64_t v160 = *((void *)this + 1);
                        if (*(void *)(v160 + 248) == v159)
                        {
                          uint64_t v45 = *(void *)(v38 + 48);
                        }
                      }

                      int v108 = 13;
                      goto LABEL_317;
                    }

                    uint64_t v45 = *(void *)(v38 + 48);
                    int v108 = 7;
                  }

                  else
                  {
                    uint64_t v45 = *(void *)(v38 + 48);
                    int v108 = 6;
                  }
                }

                else
                {
                  uint64_t v45 = *(void *)(v38 + 48);
                  int v108 = 5;
                }

LABEL_317:
                *(_DWORD *)(v45 + bssl::Array<unsigned short>::~Array(v16 + 256) = v108;
                goto LABEL_318;
              }

LABEL_223:
              int version_low = LOBYTE(d.version);
              goto LABEL_299;
            }

            BYTE1(d.sid_ctx_length) = -86;
            *(void *)((char *)&d.packet_length + 1) = 0LL;
            int v95 = bssl::ssl_process_ticket( (uint64_t *)this,  (SSL_SESSION **)((char *)&d.packet_length + 1),  (_BYTE *)&d.sid_ctx_length + 1,  *(const unsigned __int8 **)((char *)&d.tlsext_debug_cb + 1),  *(unint64_t *)((char *)&d.tlsext_debug_arg + 1),  0LL,  0LL);
            int v96 = v95;
            if (v95)
            {
              uint64_t v43 = 0LL;
              if (v95 == 3) {
                LOBYTE(d.version) = 80;
              }
            }

            else
            {
              if (!bssl::ssl_session_is_resumable( this,  *(const EVP_MD_CTX ***)((char *)&d.packet_length + 1),  a3)) {
                goto LABEL_290;
              }
              uint64_t v106 = *(SSL_SESSION **)((char *)&d.packet_length + 1);
              if ((*(_BYTE *)(*(void *)((char *)&d.packet_length + 1) + 440LL) & 8) == 0)
              {
                uint64_t v43 = 0LL;
                *(void *)((char *)&d.packet_length + 1) = 0LL;
                int v96 = 2;
                goto LABEL_292;
              }

              *(_DWORD *)((char *)&d.max_cert_list + 1) = (*(_DWORD *)((char *)&d.max_cert_list + 1)
              *(void **)((char *)&d.msg_callback_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
              *(void *)((char *)&d.hit + 1) = 0xAAAAAAAAAAAAAAAALL;
              bssl::ssl_get_current_time(v41, (uint64_t)&d.msg_callback_arg + 1);
              a2 = *(bssl::SSL_HANDSHAKE **)((char *)&d.packet_length + 1);
              unint64_t v109 = *(void **)(*(void *)((char *)&d.packet_length + 1) + 192LL);
              unint64_t v110 = (char *)*(void **)((char *)&d.msg_callback_arg + 1) - (char *)v109;
              if (!(v110 >> 31))
              {
                *(_DWORD *)(v40 + 252) = *(_DWORD *)((char *)&d.max_cert_list + 1) - v110;
                if ((bssl::tls13_verify_psk_binder( (uint64_t)this,  a2,  (uint64_t)&d.ex_data.sk + 1,  (uint64_t)&d.read_hash + 1) & 1) != 0)
                {
                  int v96 = 0;
                  uint64_t v43 = *(void *)((char *)&d.packet_length + 1);
                  *(void *)((char *)&d.packet_length + 1) = 0LL;
                }

                else
                {
                  uint64_t v43 = 0LL;
                  LOBYTE(d.version) = 51;
                  int v96 = 3;
                }
              }

              else
              {
LABEL_290:
                uint64_t v43 = 0LL;
                int v96 = 2;
              }
            }

            uint64_t v106 = *(SSL_SESSION **)((char *)&d.packet_length + 1);
            *(void *)((char *)&d.packet_length + 1) = 0LL;
            if (!v106)
            {
LABEL_293:
              switch(v96)
              {
                case 0:
                  bssl::SSL_SESSION_dup( (bssl *)v43,  0LL,  (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1));
                  unint64_t v111 = *(SSL_SESSION **)((char *)&d.verify_callback + 1);
                  *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = 0LL;
                  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](v172, v111);
                  uint64_t v112 = *(SSL_SESSION **)((char *)&d.verify_callback + 1);
                  *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = 0LL;
                  if (v112) {
                    SSL_SESSION_free(v112);
                  }
                  if (!*v172) {
                    goto LABEL_298;
                  }
                  *(_WORD *)(*(void *)(v38 + 48) + 220LL) |= 0x40u;
                  *((_DWORD *)this + 396) |= 0x1000000u;
                  bssl::ssl_session_renew_timeout( (bssl *)v38,  *((ssl_st **)this + 190),  (ssl_session_st *)*(unsigned int *)(*(void *)(v38 + 128) + 308LL));
                  goto LABEL_85;
                case 1:
                  *((_DWORD *)this + 6) = 1;
                  uint64_t v5 = 11LL;
                  goto LABEL_301;
                case 2:
                  if (v43) {
                    __assert_rtn("do_select_session", "tls13_server.cc", 452, "!session");
                  }
                  goto LABEL_84;
                case 3:
                  goto LABEL_223;
                default:
                  goto LABEL_85;
              }
            }

LABEL_292:
            SSL_SESSION_free(v106);
            goto LABEL_293;
          }
        }

        else
        {
          LOBYTE(d.version) = 109;
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 352);
        }

        uint64_t v43 = 0LL;
        goto LABEL_223;
      case 2:
        if ((*((_BYTE *)this + 1586) & 8) != 0) {
          goto LABEL_103;
        }
        uint64_t v31 = *(void *)this;
        *(void *)&__int128 v32 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.rbio + 1) = v32;
        *(_OWORD *)((char *)&d.bbio + 1) = v32;
        *(_OWORD *)((char *)&d.version + 1) = v32;
        CBB_zero((int *)((char *)&d.version + 1));
        v33.suint64_t k = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&v33.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v33;
        *(CRYPTO_EX_DATA *)((char *)&d.options + 1) = v33;
        *(CRYPTO_EX_DATA *)((char *)&d.debug + 1) = v33;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v33;
        *(CRYPTO_EX_DATA *)((char *)&d.verify_callback + 1) = v33;
        *(CRYPTO_EX_DATA *)((char *)&d.error + 1) = v33;
        *(CRYPTO_EX_DATA *)&d.sid_ctx[29] = v33;
        *(CRYPTO_EX_DATA *)((char *)&d.generate_session_id + 1) = v33;
        *(CRYPTO_EX_DATA *)&d.sid_ctx[13] = v33;
        if (!(*(unsigned int (**)(uint64_t, char *, char *, uint64_t))(*(void *)v31 + 88LL))( v31,  (char *)&d.version + 1,  (char *)&d.ex_data.sk + 1,  2LL)
          || !CBB_add_u16((uint64_t)&d.ex_data.sk + 1, 0x303u)
          || !CBB_add_bytes((uint64_t)&d.ex_data.sk + 1, &bssl::kHelloRetryRequest, 0x20uLL)
          || !CBB_add_u8_length_prefixed( (uint64_t *)((char *)&d.ex_data.sk + 1),  (uint64_t)&d.verify_callback + 1)
          || !CBB_add_bytes((uint64_t)&d.verify_callback + 1, __dst, *((unsigned __int8 *)this + 1629))
          || (unsigned int protocol_id = SSL_CIPHER_get_protocol_id(*((void *)this + 194)),
              !CBB_add_u16((uint64_t)&d.ex_data.sk + 1, protocol_id))
          || !CBB_add_u8((uint64_t)&d.ex_data.sk + 1, 0)
          || !CBB_add_u16_length_prefixed((uint64_t *)((char *)&d.ex_data.sk + 1), (uint64_t)&d.sid_ctx[13])
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 0x2Bu)
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 2u)
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], *(unsigned __int16 *)(v31 + 16))
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 0x33u)
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 2u)
          || !CBB_add_u16((uint64_t)&d.sid_ctx[13], HIWORD((*v172)->key_arg_length))
          || (*((_BYTE *)this + 1584) & 1) != 0
          && (!CBB_add_u16((uint64_t)&d.sid_ctx[13], 0xFE0Du)
           || !CBB_add_u16((uint64_t)&d.sid_ctx[13], 8u)
           || !CBB_add_zeros((uint64_t)&d.sid_ctx[13], 8uLL)))
        {
          uint64_t v5 = 0LL;
          goto LABEL_360;
        }

        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = 0LL;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = 0LL;
        if (((*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v31 + 96LL))( v31,  (char *)&d.version + 1,  (char *)&d.tlsext_debug_cb + 1) & 1) == 0) {
          goto LABEL_361;
        }
        if ((*((_BYTE *)this + 1584) & 1) != 0)
        {
          if (!bssl::ssl_ech_accept_confirmation( (int)this,  *(_DWORD *)((char *)&d.tlsext_debug_arg + 1) - 8 + *(_DWORD *)((char *)&d.tlsext_debug_cb + 1),  8LL,  *(void *)(v31 + 48) + 48,  32,  (bssl::SSLTranscript *)v176,  1,  v35,  *(char **)((char *)&d.tlsext_debug_cb + 1),  *(unint64_t *)((char *)&d.tlsext_debug_arg + 1),  *(unint64_t *)((char *)&d.tlsext_debug_arg + 1) - 8)) {
            goto LABEL_361;
          }
        }

        uint64_t v36 = *(unsigned int (**)(uint64_t, char *))(*(void *)v31 + 104LL);
        *(const EVP_MD **)((char *)&d.read_hash + 1) = 0LL;
        *(COMP_CTX **)((char *)&d.expand + 1) = 0LL;
        OPENSSL_free(0LL);
        *(const EVP_MD **)((char *)&d.read_hash + 1) = *(const EVP_MD **)((char *)&d.tlsext_debug_cb + 1);
        *(COMP_CTX **)((char *)&d.expand + 1) = *(COMP_CTX **)((char *)&d.tlsext_debug_arg + 1);
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = 0LL;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = 0LL;
        if (v36(v31, (char *)&d.read_hash + 1))
        {
          char v37 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 112LL))(v31);
          OPENSSL_free(*(void **)((char *)&d.read_hash + 1));
          *(const EVP_MD **)((char *)&d.read_hash + 1) = 0LL;
          *(COMP_CTX **)((char *)&d.expand + 1) = 0LL;
          if ((v37 & 1) != 0)
          {
            *(_WORD *)(*(void *)(v31 + 48) + 220LL) |= 0x2000u;
            *((_DWORD *)this + 6) = 3;
            uint64_t v5 = 4LL;
          }

          else
          {
LABEL_361:
            uint64_t v5 = 0LL;
          }
        }

        else
        {
          OPENSSL_free(*(void **)((char *)&d.read_hash + 1));
          uint64_t v5 = 0LL;
          *(const EVP_MD **)((char *)&d.read_hash + 1) = 0LL;
          *(COMP_CTX **)((char *)&d.expand + 1) = 0LL;
        }

        OPENSSL_free(*(void **)((char *)&d.tlsext_debug_cb + 1));
LABEL_360:
        CBB_cleanup((uint64_t)&d.version + 1);
        goto LABEL_281;
      case 3:
        unint64_t v22 = *(bssl **)this;
        *(unint64_t *)((char *)&d.options + 1) = 0xAAAAAAAAAAAAAAAALL;
        v61.suint64_t k = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&v61.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v61;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v61;
        *(void *)&__int128 v62 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.init_buf + 1) = v62;
        *(_OWORD *)((char *)&d.init_num + 1) = v62;
        *(_OWORD *)((char *)&d.handshake_func + 1) = v62;
        *(_OWORD *)((char *)&d.quiet_shutdown + 1) = v62;
        *(_OWORD *)((char *)&d.rbio + 1) = v62;
        *(_OWORD *)((char *)&d.bbio + 1) = v62;
        *(_OWORD *)((char *)&d.version + 1) = v62;
        if ((bssl::ssl_client_hello_init( (uint64_t)v22,  (uint64_t)&d.version + 1,  *(uint64_t *)((char *)&d.ex_data.dummy + 1),  *(uint64_t *)((char *)&d.client_CA + 1)) & 1) == 0)
        {
          ERR_put_error(16, 0, 131, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 692);
          bssl::ssl_send_alert(v22, (ssl_st *)2, 50);
          goto LABEL_280;
        }

        uint64_t v63 = *((void *)v22 + 6);
        if (*(_DWORD *)(v63 + 216) != 1) {
          goto LABEL_139;
        }
        *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
        if ((bssl::ssl_client_hello_get_extension( (uint64_t)&d.version + 1,  (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1),  65037) & 1) == 0)
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 703);
          bssl::ssl_send_alert(v22, (ssl_st *)2, 109);
          goto LABEL_280;
        }

        *(_WORD *)((char *)&d.read_hash + 1) = -21846;
        *(_WORD *)((char *)&d.msg_callback_arg + 1) = -21846;
        BYTE1(d.packet_length) = -86;
        BYTE1(d.max_cert_list) = -86;
        *(void *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
        *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))0xAAAAAAAAAAAAAAAALL;
        *(void **)((char *)&d.tlsext_debug_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
        int u8 = CBS_get_u8( (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1),  (_BYTE *)&d.packet_length + 1);
        int v65 = 50;
        int v66 = 718;
        if (!u8 || BYTE1(d.packet_length)) {
          goto LABEL_266;
        }
        if (!CBS_get_u16( (unsigned __int16 **)((char *)&d.verify_callback + 1),  (const EVP_MD **)((char *)&d.read_hash + 1))
          || !CBS_get_u16( (unsigned __int16 **)((char *)&d.verify_callback + 1),  (void **)((char *)&d.msg_callback_arg + 1))
          || !CBS_get_u8( (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1),  (_BYTE *)&d.max_cert_list + 1)
          || !CBS_get_u16_length_prefixed( (unsigned __int8 **)((char *)&d.verify_callback + 1),  (unint64_t *)&d.sid_ctx[13]))
        {
          int v66 = 718;
LABEL_266:
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", v66);
          bssl::ssl_send_alert(v22, (ssl_st *)2, v65);
          goto LABEL_280;
        }

        int u16_length_prefixed = CBS_get_u16_length_prefixed( (unsigned __int8 **)((char *)&d.verify_callback + 1),  (unint64_t *)((char *)&d.tlsext_debug_cb + 1));
        int v66 = 718;
        int v68 = *(unsigned __int16 *)((char *)&d.read_hash + 1);
        uint64_t v69 = (unsigned __int16 *)EVP_HPKE_CTX_kdf(v167);
        if (v68 != EVP_HPKE_KDF_id(v69)
          || (int v70 = *(unsigned __int16 *)((char *)&d.msg_callback_arg + 1),
              unint64_t v71 = (unsigned __int16 *)EVP_HPKE_CTX_aead((uint64_t)v167),
              v70 != EVP_HPKE_KDF_id(v71)))
        {
          int v65 = 47;
          int v66 = 727;
          goto LABEL_266;
        }

        int v65 = 47;
        int v66 = 727;
        BYTE1(d.sid_ctx_length) = 50;
        LOBYTE(d.version) = -86;
        if ((bssl::ssl_client_hello_decrypt( (uint64_t *)this,  (_BYTE *)&d.sid_ctx_length + 1,  &d,  v168,  (int *)((char *)&d.version + 1),  *(char **)((char *)&d.tlsext_debug_cb + 1),  *(unint64_t *)((char *)&d.tlsext_debug_arg + 1)) & 1) == 0)
        {
          ERR_put_error(16, 0, 138, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 739);
          bssl::ssl_send_alert(v22, (ssl_st *)2, BYTE1(d.sid_ctx_length));
LABEL_280:
          uint64_t v5 = 0LL;
          goto LABEL_281;
        }

        if ((bssl::SSL_HANDSHAKE::GetClientHello((uint64_t *)this, (uint64_t)&d.ex_data.sk + 1, (uint64_t)&d.version + 1) & 1) == 0)
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 746);
          goto LABEL_280;
        }

        uint64_t v63 = *((void *)v22 + 6);
LABEL_139:
        if ((*(_WORD *)(v63 + 220) & 0x40) != 0)
        {
          *(int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1) = (int (__cdecl *)(int, X509_STORE_CTX *))0xAAAAAAAAAAAAAAAALL;
          *(void (__cdecl **)(const SSL *, int, int))((char *)&d.info_callback + 1) = (void (__cdecl *)(const SSL *, int, int))0xAAAAAAAAAAAAAAAALL;
          if ((bssl::ssl_client_hello_get_extension( (uint64_t)&d.version + 1,  (int (__cdecl **)(int, X509_STORE_CTX *))((char *)&d.verify_callback + 1),  41) & 1) == 0)
          {
            ERR_put_error(16, 0, 303, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 762);
            bssl::ssl_send_alert(v22, (ssl_st *)2, 47);
            goto LABEL_280;
          }

          *(void *)&d.sid_ctx[13] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&d.sid_ctx[21] = 0xAAAAAAAAAAAAAAAALL;
          *(void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1) = (void (__cdecl *)(SSL *, int, int, unsigned __int8 *, int, void *))0xAAAAAAAAAAAAAAAALL;
          *(void **)((char *)&d.tlsext_debug_arg + 1) = (void *)0xAAAAAAAAAAAAAAAALL;
          *(_DWORD *)((char *)&d.read_hash + 1) = -1431655766;
          BYTE1(d.msg_callback_arg) = 50;
          if ((bssl::ssl_ext_pre_shared_key_parse_clienthello( (uint64_t)this,  (unint64_t *)&d.sid_ctx[13],  (void (__cdecl **)(SSL *, int, int, unsigned __int8 *, int, void *))((char *)&d.tlsext_debug_cb + 1),  (int *)((char *)&d.read_hash + 1),  (char *)&d.msg_callback_arg + 1,  (uint64_t)&d.version + 1,  (uint64_t)&d.verify_callback + 1) & 1) == 0)
          {
            int v94 = BYTE1(d.msg_callback_arg);
LABEL_279:
            bssl::ssl_send_alert(v22, (ssl_st *)2, v94);
            goto LABEL_280;
          }

          if ((bssl::tls13_verify_psk_binder( (uint64_t)this,  *((bssl **)this + 190),  (uint64_t)&d.ex_data.sk + 1,  (uint64_t)&d.tlsext_debug_cb + 1) & 1) == 0)
          {
            int v94 = 51;
            goto LABEL_279;
          }
        }

        if (!bssl::resolve_ecdhe_secret((uint64_t)this, (uint64_t)&d.version + 1)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.ex_data.sk + 1))
        {
          goto LABEL_280;
        }

        if ((*(unsigned int (**)(bssl *))(*(void *)v22 + 40LL))(v22))
        {
          bssl::ssl_send_alert(v22, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 797);
          goto LABEL_280;
        }

        (*(void (**)(bssl *))(*(void *)v22 + 32LL))(v22);
        OPENSSL_free(*((void **)this + 75));
        *unsigned int v168 = 0LL;
        v168[1] = 0LL;
        *((_DWORD *)this + 6) = 4;
LABEL_281:
        if (*((_DWORD *)this + 6) != v4) {
          bssl::ssl_do_info_callback(*(void *)this, (const ssl_st *)0x2001);
        }
        if ((_DWORD)v5 == 1) {
          continue;
        }
        return v5;
      case 4:
        uint64_t v55 = *(unsigned __int8 ***)this;
        uint64_t v56 = *(void *)(*(void *)this + 48LL);
        uint64_t v57 = (_OWORD *)(v56 + 16);
        uint64_t v58 = *((void *)this + 197);
        if (v58)
        {
          if ((*((_BYTE *)this + 1586) & 8) != 0 || *(void *)(v58 + 24) != 32LL)
          {
            RAND_bytes((unsigned __int8 *)(v56 + 16), 32);
            if ((*((_BYTE *)this + 1586) & 8) != 0)
            {
              __int128 v82 = (void *)(v58 + 16);
              __int128 v83 = (_OWORD *)*v82;
              __int128 v84 = *(_OWORD *)(v56 + 32);
              _OWORD *v83 = *v57;
              v83[1] = v84;
            }
          }

          else
          {
            uint64_t v59 = *(_OWORD **)(v58 + 16);
            __int128 v60 = v59[1];
            *uint64_t v57 = *v59;
            *(_OWORD *)(v56 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v60;
          }
        }

        else
        {
          RAND_bytes((unsigned __int8 *)(v56 + 16), 32);
        }

        *(uint64_t *)((char *)&d.max_cert_list + 1) = 0LL;
        *(void *)((char *)&d.first_packet + 1) = 0LL;
        v85.suint64_t k = (STACK *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&v85.dummy = 0xAAAAAAAAAAAAAAAALL;
        *(CRYPTO_EX_DATA *)((char *)&d.client_CA + 1) = v85;
        *(CRYPTO_EX_DATA *)((char *)&d.options + 1) = v85;
        *(CRYPTO_EX_DATA *)((char *)&d.ex_data + 1) = v85;
        CBB_zero((STACK **)((char *)&d.ex_data.sk + 1));
        *(void *)&__int128 v86 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v86 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.error + 1) = v86;
        *(_OWORD *)((char *)&d.debug + 1) = v86;
        *(_OWORD *)((char *)&d.generate_session_id + 1) = v86;
        *(_OWORD *)((char *)&d.verify_callback + 1) = v86;
        *(_OWORD *)&d.sid_ctx[13] = v86;
        *(_OWORD *)&d.sid_ctx[29] = v86;
        *(_OWORD *)((char *)&d.tlsext_hostname + 1) = v86;
        *(_OWORD *)((char *)&d.tlsext_status_expected + 1) = v86;
        *(_OWORD *)((char *)&d.tlsext_debug_cb + 1) = v86;
        if (!(*((unsigned int (**)(unsigned __int8 **, char *, char *, uint64_t))*v55 + 11))( v55,  (char *)&d.ex_data.sk + 1,  (char *)&d.verify_callback + 1,  2LL)) {
          goto LABEL_419;
        }
        if (!CBB_add_u8_length_prefixed( (uint64_t *)((char *)&d.verify_callback + 1),  (uint64_t)&d.tlsext_debug_cb + 1)) {
          goto LABEL_419;
        }
        unsigned int v87 = SSL_CIPHER_get_protocol_id(*((void *)this + 194));
        if (!CBB_add_u16_length_prefixed( (uint64_t *)((char *)&d.verify_callback + 1),  (uint64_t)&d.sid_ctx[13])) {
          goto LABEL_419;
        }
        *(void *)&__int128 v88 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v88 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.rbio + 1) = v88;
        *(_OWORD *)((char *)&d.bbio + 1) = v88;
        *(_OWORD *)((char *)&d.version + 1) = v88;
        if (!CBB_add_u16_length_prefixed((uint64_t *)&d.sid_ctx[13], (uint64_t)&d.version + 1)
          || !CBB_add_u16((uint64_t)&d.version + 1, *(unsigned __int16 *)(*(void *)this + 16LL))
          || !CBB_flush((uint64_t *)&d.sid_ctx[13])
          || ((*((uint64_t (**)(unsigned __int8 **, char *, char *))*v55 + 12))( v55,  (char *)&d.ex_data.sk + 1,  (char *)&d.max_cert_list + 1) & 1) == 0)
        {
          goto LABEL_419;
        }

        int v90 = *((_DWORD *)this + 396);
        if (*((_DWORD *)v55[6] + 54) == 1)
        {
          if ((v90 & 1) == 0) {
            __assert_rtn( "do_send_server_hello",  "tls13_server.cc",  844,  "ssl->s3->ech_status != ssl_ech_accepted || hs->ech_is_inner");
          }
        }

        else if ((v90 & 1) == 0)
        {
          goto LABEL_366;
        }

        unint64_t v139 = bssl::ssl_ech_confirmation_signal_hello_offset(v55, v89);
        unint64_t v140 = (void *)(v56 + 40);
        if (!bssl::ssl_ech_accept_confirmation( (int)this,  (int)v140,  8LL,  *((_DWORD *)v55 + 12) + 48,  32,  (bssl::SSLTranscript *)v176,  0,  v141,  *(char **)((char *)&d.max_cert_list + 1),  *(unint64_t *)((char *)&d.first_packet + 1),  v139)) {
          goto LABEL_419;
        }
        *(void *)(*(uint64_t *)((char *)&d.max_cert_list + 1) + v139) = *v140;
LABEL_366:
        unint64_t v142 = (uint64_t (*)(unsigned __int8 **, char *))*((void *)*v55 + 13);
        *(void *)((char *)&d.sid_ctx_length + 1) = 0LL;
        *(void *)&d.sid_ctx[5] = 0LL;
        OPENSSL_free(0LL);
        *(void *)((char *)&d.sid_ctx_length + 1) = *(uint64_t *)((char *)&d.max_cert_list + 1);
        *(void *)&d.sid_ctx[5] = *(void *)((char *)&d.first_packet + 1);
        *(uint64_t *)((char *)&d.max_cert_list + 1) = 0LL;
        *(void *)((char *)&d.first_packet + 1) = 0LL;
        LOBYTE(v142) = v142(v55, (char *)&d.sid_ctx_length + 1);
        OPENSSL_free(*(void **)((char *)&d.sid_ctx_length + 1));
        *(void *)((char *)&d.sid_ctx_length + 1) = 0LL;
        *(void *)&d.sid_ctx[5] = 0LL;
        OPENSSL_free(*(void **)v166);
        *(void *)int v166 = 0LL;
        *((void *)v166 + 1) = 0LL;
        if (!bssl::tls13_derive_handshake_secrets(this, v143)
          || (bssl::tls13_set_traffic_key( (uint64_t)v55,  (const ssl_session_st *)2,  1LL,  *((bssl **)this + 190),  v165,  *((void *)this + 4)) & 1) == 0 || !(*((unsigned int (**)(unsigned __int8 **, char *, char *, uint64_t))*v55 + 11))( v55,  (char *)&d.ex_data.sk + 1,  (char *)&d.verify_callback + 1,  8LL)
          || !bssl::ssl_add_serverhello_tlsext((uint64_t)this, (uint64_t *)((char *)&d.verify_callback + 1))
          || !bssl::ssl_add_message_cbb((uint64_t)v55, (uint64_t)&d.ex_data.sk + 1))
        {
          goto LABEL_419;
        }

        unsigned int v145 = *((_DWORD *)this + 396);
        if ((*((_WORD *)v55[6] + 110) & 0x40) == 0)
        {
          uint64_t v146 = *((void *)this + 1);
          unsigned int v147 = v145 & 0xFFFFFFDF;
          BOOL v9 = (v145 & 0x2000000) == 0;
          unsigned int v145 = v145 & 0xFFFFFFDF | (32 * (*(_BYTE *)(v146 + 300) & 1));
          *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v145;
          int v148 = *(_BYTE *)(v146 + 300) & 4;
          if (!v9 && v148 != 0) {
            unsigned int v145 = v147;
          }
          *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v145;
        }

        if ((v145 & 0x20) != 0)
        {
          *(void *)&__int128 v161 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v161 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)((char *)&d.rbio + 1) = v161;
          *(_OWORD *)((char *)&d.bbio + 1) = v161;
          *(_OWORD *)((char *)&d.version + 1) = v161;
          *(_OWORD *)((char *)&d.enc_write_ctx + 1) = v161;
          *(_OWORD *)((char *)&d.compress + 1) = v161;
          *(_OWORD *)((char *)&d.cipher_list_by_id + 1) = v161;
          *(_OWORD *)((char *)&d.read_hash + 1) = v161;
          *(_OWORD *)((char *)&d.msg_callback_arg + 1) = v161;
          *(_OWORD *)((char *)&d.param + 1) = v161;
          if (!(*((unsigned int (**)(unsigned __int8 **, char *, char *, uint64_t))*v55 + 11))( v55,  (char *)&d.ex_data.sk + 1,  (char *)&d.verify_callback + 1,  13LL)) {
            goto LABEL_419;
          }
          if (!CBB_add_u16_length_prefixed( (uint64_t *)((char *)&d.verify_callback + 1),  (uint64_t)&d.version + 1)) {
            goto LABEL_419;
          }
          if (!CBB_add_u16_length_prefixed( (uint64_t *)((char *)&d.version + 1),  (uint64_t)&d.read_hash + 1)) {
            goto LABEL_419;
          }
          if (!CBB_add_u16_length_prefixed( (uint64_t *)((char *)&d.read_hash + 1),  (uint64_t)&d.msg_callback_arg + 1)) {
            goto LABEL_419;
          }
          if (bssl::ssl_has_client_CAs(*((bssl **)this + 1), v162))
          {
            *(void *)&__int128 v163 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v163 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)((char *)&d.s3 + 1) = v163;
            *(_OWORD *)((char *)&d.read_ahead + 1) = v163;
            *(_OWORD *)((char *)&d.packet_length + 1) = v163;
            if (!CBB_add_u16((uint64_t)&d.version + 1, 0x2Fu)
              || !CBB_add_u16_length_prefixed( (uint64_t *)((char *)&d.version + 1),  (uint64_t)&d.packet_length + 1)
              || !bssl::ssl_add_client_CA_list(this, (uint64_t *)((char *)&d.packet_length + 1))
              || !CBB_flush((uint64_t *)((char *)&d.version + 1)))
            {
              goto LABEL_419;
            }
          }
        }

        if ((*((_WORD *)v55[6] + 110) & 0x40) != 0)
        {
          int v154 = 6;
          goto LABEL_423;
        }

        if (!bssl::ssl_has_certificate(this, v144) && !bssl::ssl_has_server_raw_public_key_certificate(this, v150))
        {
          ERR_put_error(16, 0, 174, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 936);
          uint64_t v5 = 0LL;
          goto LABEL_420;
        }

        if (bssl::tls13_add_certificate(this, v150, v151, v152, v153))
        {
          int v154 = 5;
LABEL_423:
          *((_DWORD *)this + 6) = v154;
LABEL_420:
          CBB_cleanup((uint64_t)&d.ex_data.sk + 1);
          OPENSSL_free(*(void **)((char *)&d.max_cert_list + 1));
          goto LABEL_281;
        }

LABEL_211:
        *((_DWORD *)this + 6) = v21;
        goto LABEL_281;
      case 13:
        if ((*((_BYTE *)this + 1587) & 2) == 0) {
          goto LABEL_32;
        }
        unint64_t v77 = *(bssl **)this;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v78 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v78 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v78;
        *(_OWORD *)((char *)&d.rbio + 1) = v78;
        if (!bssl::ssl_check_message_type(v77, (uint64_t)&d.version + 1, 203)
          || !bssl::tls1_verify_channel_id((bssl **)this, (uint64_t)&d.version + 1)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1))
        {
          goto LABEL_280;
        }

        (*(void (**)(bssl *))(*(void *)v77 + 32LL))(v77);
LABEL_32:
        int v21 = 14;
        goto LABEL_211;
      case 14:
        unint64_t v74 = *(bssl **)this;
        *(BIO **)((char *)&d.bbio + 1) = (BIO *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v75 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v75 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&d.version + 1) = v75;
        *(_OWORD *)((char *)&d.rbio + 1) = v75;
        if (!bssl::ssl_check_message_type(v74, (uint64_t)&d.version + 1, 20)
          || !bssl::tls13_process_finished( (char *)this,  (uint64_t)&d.version + 1,  (*(unsigned __int16 *)(*((void *)v74 + 6) + 220LL) >> 10) & 1)
          || !bssl::tls13_set_traffic_key( (uint64_t)v74,  (const ssl_session_st *)3,  0LL,  *((bssl **)this + 190),  v171,  *((void *)this + 4)))
        {
          goto LABEL_280;
        }

        if ((*(_WORD *)(*((void *)v74 + 6) + 220LL) & 0x400) != 0)
        {
          int v76 = 16;
        }

        else
        {
          if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)&d.version + 1)
            || !bssl::tls13_derive_resumption_secret(this, a2))
          {
            goto LABEL_280;
          }

          int v76 = 15;
        }

        *((_DWORD *)this + 6) = v76;
        (*(void (**)(bssl *))(*(void *)v74 + 32LL))(v74);
        goto LABEL_281;
      case 15:
        BYTE1(d.version) = -86;
        if (!bssl::add_new_session_tickets( (ssl_st **)this,  (bssl::SSL_HANDSHAKE *)((char *)&d.version + 1),  (BOOL *)a3)) {
          goto LABEL_280;
        }
        *((_DWORD *)this + 6) = 16;
        if (BYTE1(d.version)) {
          BOOL v73 = *(void *)(*(void *)this + 168LL) == 0LL;
        }
        else {
          BOOL v73 = 1;
        }
        if (v73) {
          uint64_t v5 = 1LL;
        }
        else {
          uint64_t v5 = 4LL;
        }
        goto LABEL_281;
      case 16:
        return v5;
      default:
        goto LABEL_280;
    }
  }

void sub_1875A603C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, SSL_SESSION *ses)
{
}

uint64_t bssl::tls13_server_handshake_int_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return (4 * *((_DWORD *)this + 6)) | 0x2B291800u;
}

const char *bssl::tls13_server_handshake_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2 = *((int *)this + 6);
  else {
    return off_18A070758[v2];
  }
}

uint64_t bssl::resolve_ecdhe_secret(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(bssl **)a1;
  int v4 = (void *)*(unsigned __int16 *)(*(void *)(a1 + 1520) + 6LL);
  char v32 = -86;
  v30[2] = 0;
  *(_WORD *)&_OWORD v30[3] = 0;
  *(_DWORD *)&v30[5] = 0;
  uint64_t v31 = 0LL;
  strcpy(v30, "2");
  if ((bssl::ssl_ext_key_share_parse_clienthello(a1, (BOOL *)&v32, (unint64_t *)&v30[1], v30, a2) & 1) == 0)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, v30[0]);
    return 0LL;
  }

  if (!v32)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, 47);
    ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_server.cc", 67);
    return 0LL;
  }

  __dst = 0LL;
  size_t v29 = 0LL;
  uint64_t v5 = *(void *)(a1 + 1576);
  if (!v5 || (*(_BYTE *)(a1 + 1586) & 8) != 0 || *(unsigned __int16 *)(v5 + 32) != (_DWORD)v4 || !*(void *)(v5 + 64))
  {
    *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v27[1] = v14;
    int64x2_t v27[2] = v14;
    v27[0] = v14;
    CBB_zero(v27);
    unint64_t v26 = (void *)0xAAAAAAAAAAAAAAAALL;
    bssl::SSLKeyShare::Create(v4, &v26);
    if (v26
      && CBB_init((uint64_t)v27, 0x20uLL)
      && (*(unsigned int (**)(void *, _OWORD *, void **, char *, void, uint64_t))(*v26 + 32LL))( v26,  v27,  &__dst,  v30,  *(void *)&v30[1],  v31)
      && bssl::CBBFinishArray((uint64_t)v27, a1 + 632))
    {
      if (!v5 || (*(_BYTE *)(a1 + 1586) & 8) == 0) {
        goto LABEL_25;
      }
      *(_WORD *)(v5 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = (_WORD)v4;
      unint64_t v18 = *(const void **)(a1 + 632);
      unint64_t v19 = *(void *)(a1 + 640);
      int v20 = bssl::Array<unsigned char>::Init(v5 + 40, v19);
      char v21 = v20 ^ 1;
      if (!v19) {
        char v21 = 1;
      }
      if ((v21 & 1) == 0) {
        memmove(*(void **)(v5 + 40), v18, v19);
      }
      if (v20)
      {
        unint64_t v22 = __dst;
        size_t v23 = v29;
        char v24 = bssl::Array<unsigned char>::Init(v5 + 56, v29);
        char v25 = v24 ^ 1;
        if (!v23) {
          char v25 = 1;
        }
        if ((v25 & 1) == 0) {
          memmove(*(void **)(v5 + 56), v22, v23);
        }
        if ((v24 & 1) != 0)
        {
LABEL_25:
          std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v26, 0LL);
          CBB_cleanup((uint64_t)v27);
          goto LABEL_26;
        }
      }

      int v16 = 80;
    }

    else
    {
      int v16 = v30[0];
    }

    bssl::ssl_send_alert(v3, (ssl_st *)2, v16);
    std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100](&v26, 0LL);
    CBB_cleanup((uint64_t)v27);
    goto LABEL_29;
  }

  uint64_t v6 = *(const void **)(v5 + 40);
  unint64_t v7 = *(void *)(v5 + 48);
  int v8 = bssl::Array<unsigned char>::Init(a1 + 632, v7);
  char v9 = v8 ^ 1;
  if (!v7) {
    char v9 = 1;
  }
  if ((v9 & 1) == 0) {
    memmove(*(void **)(a1 + 632), v6, v7);
  }
  if (!v8) {
    goto LABEL_17;
  }
  uint64_t v10 = *(const void **)(v5 + 56);
  unint64_t v11 = *(void *)(v5 + 64);
  char v12 = bssl::Array<unsigned char>::Init((uint64_t)&__dst, v11);
  char v13 = v12 ^ 1;
  if (!v11) {
    char v13 = 1;
  }
  if ((v13 & 1) == 0) {
    memmove(__dst, v10, v11);
  }
  if ((v12 & 1) == 0)
  {
LABEL_17:
    bssl::ssl_send_alert(v3, (ssl_st *)2, 80);
LABEL_29:
    uint64_t v15 = 0LL;
    goto LABEL_30;
  }

LABEL_26:
  uint64_t v15 = bssl::tls13_advance_key_schedule(a1);
LABEL_30:
  OPENSSL_free(__dst);
  return v15;
}
    }
  }

  return v5 != 0;
}
    }
  }

  else
  {
    memcpy((void *)(a1[7] + v6), a2, __n);
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += __n;
    int v8 = a1[6];
    if (!v8) {
      goto LABEL_14;
    }
    char v9 = objc_loadWeakRetained((id *)(v8 + 16));
    if (v9)
    {
      uint64_t v10 = v9;
      unint64_t v11 = objc_loadWeakRetained((id *)(a1[6] + 16LL));
      char v12 = v11[475];

      if ((v12 & 1) != 0) {
        return v7 >= __n;
      }
    }

    char v13 = a1[6];
    if (v13)
    {
      __int128 v14 = objc_loadWeakRetained((id *)(v13 + 16));
      if (v14)
      {
        uint64_t v15 = objc_loadWeakRetained((id *)(a1[6] + 16LL));
        int v16 = (v15[475] & 1) == 0;
      }

      else
      {
        int v16 = 1LL;
      }

      if (!(_DWORD)v16) {
        return v7 >= __n;
      }
    }

    else
    {
LABEL_14:
      int v16 = 1LL;
    }

    if (g_boringssl_log)
    {
      char v25 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v26 = a1[6];
        if (v26)
        {
          int v16 = (uint64_t)objc_loadWeakRetained((id *)(v26 + 16));
          unint64_t v34 = a1[6];
          if (v16)
          {
            size_t v27 = v34 != 0;
            if (v34)
            {
              uint64_t v3 = (char *)objc_loadWeakRetained((id *)(v34 + 16));
              unint64_t v34 = a1[6];
            }

            else
            {
              uint64_t v3 = 0LL;
            }

            unint64_t v30 = v3 + 391;
          }

          else
          {
            size_t v27 = 0;
            unint64_t v30 = &unk_1875F4C23;
          }

          if (v34)
          {
            int v28 = objc_loadWeakRetained((id *)(v34 + 16));
            size_t v29 = 0;
          }

          else
          {
            int v28 = 0LL;
            size_t v29 = 1;
          }
        }

        else
        {
          size_t v27 = 0;
          int v28 = 0LL;
          size_t v29 = 1;
          unint64_t v30 = &unk_1875F4C23;
        }

        uint64_t v36 = 136446978;
        char v37 = "boringssl_context_zlib_uncompress_data_block_invoke";
        uint64_t v38 = 1024;
        CRYPTO_EX_DATA v39 = 775;
        uint64_t v40 = 2082;
        uint64_t v41 = v30;
        uint64_t v42 = 2048;
        uint64_t v43 = v28;
        _os_log_debug_impl( &dword_187560000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s(%d) %{public}s[%p] Wrote decompressed certificate data",  (uint8_t *)&v36,  0x26u);
        if ((v29 & 1) != 0) {
          goto LABEL_52;
        }
        goto LABEL_51;
      }

      goto LABEL_26;
    }
  }

  return v7 >= __n;
}

    v50 |= bssl::ssl_cipher_auth_mask_for_key(*((bssl **)a2 + 1), (const evp_pkey_st *)v10);
    v51 |= v12 == 6;
    unint64_t v7 = *((void *)this + 1);
  }

  unint64_t v22 = *(void *)this;
  size_t v23 = *(void *)(v7 + 24);
  if (!v23) {
    size_t v23 = *(void *)(*(void *)(v22 + 120) + 240LL);
  }
  char v24 = *(unint64_t **)v23;
  if ((*(_BYTE *)(v22 + 146) & 0x40) != 0)
  {
    char v25 = *(void *)(v23 + 8);
    unint64_t v26 = *(EVP_MD_CTX **)v23;
    char v24 = (unint64_t *)ctx;
  }

  else
  {
    char v25 = 0LL;
    unint64_t v26 = ctx;
  }

  if (!EVP_MD_CTX_md(v26))
  {
LABEL_58:
    uint64_t v41 = 184;
    uint64_t v42 = 369;
LABEL_59:
    ERR_put_error(16, 0, v41, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_server.cc", v42);
    return 0LL;
  }

  size_t v27 = 0LL;
  int v28 = -1;
  while (1)
  {
    size_t v29 = OPENSSL_sk_value((unint64_t *)v26, v27);
    unint64_t v30 = 0LL;
    if (EVP_MD_CTX_md((const EVP_MD_CTX *)v24))
    {
      while (1)
      {
        uint64_t v31 = OPENSSL_sk_value(v24, v30);
        char v32 = *((_DWORD *)v29 + 4);
        CRYPTO_EX_DATA v33 = *((_DWORD *)v31 + 4);
        unint64_t v34 = v32 != v33;
        if (v32 == v33) {
          break;
        }
        if (++v30 >= (unint64_t)EVP_MD_CTX_md((const EVP_MD_CTX *)v24))
        {
          unint64_t v30 = 0LL;
          break;
        }
      }
    }

    else
    {
      unint64_t v34 = 1;
    }

    unsigned int min_version = SSL_CIPHER_get_min_version(v29);
    if (min_version <= bssl::ssl_protocol_version((bssl *)v22, v36))
    {
      uint64_t v38 = bssl::ssl_protocol_version((bssl *)v22, v37);
      if (v38 <= SSL_CIPHER_get_max_version((uint64_t)v29)
        && (*((_DWORD *)v29 + 5) & v51) != 0
        && ((_DWORD)v29[3] & v50) != 0
        && !v34)
      {
        break;
      }
    }

    if (v25 && !*(_BYTE *)(v25 + v27) && v28 != -1)
    {
      uint64_t v45 = v28;
      goto LABEL_66;
    }

void sub_1875A64BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void std::unique_ptr<bssl::SSLKeyShare,bssl::internal::Deleter>::reset[abi:ne180100]( void **a1, void *a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    (*(void (**)(void *))*v2)(v2);
    OPENSSL_free(v2);
  }

uint64_t bssl::add_new_session_tickets(ssl_st **this, bssl::SSL_HANDSHAKE *a2, BOOL *a3)
{
  if (((_BYTE)this[198] & 0x10) != 0)
  {
    uint64_t v5 = *this;
    if ((SSL_get_options((uint64_t)*this) & 0x4000) == 0)
    {
      unsigned int v6 = *((unsigned __int8 *)&v5->s3->empty_fragment_done + 4);
      unsigned int v7 = *((unsigned __int8 *)this + 732);
      if (v6 <= v7) {
        char v9 = v7;
      }
      else {
        char v9 = v6;
      }
      *((_BYTE *)&v5->s3->empty_fragment_done + 4) = v9;
      bssl::ssl_session_rebase_time((bssl *)v5, this[190], v8);
      if (!*((_BYTE *)&v5->s3->empty_fragment_done + 4))
      {
LABEL_44:
        uint64_t result = 1LL;
        *(_BYTE *)a2 = 1;
        return result;
      }

      uint64_t v10 = 0LL;
      while (1)
      {
        int v28 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
        bssl::SSL_SESSION_dup((bssl *)this[190], (ssl_session_st *)2, &v28);
        if (!v28) {
          return 0LL;
        }
        if (!RAND_bytes(v28 + 376, 4))
        {
          int v13 = 1;
          goto LABEL_40;
        }

        unint64_t v11 = v28;
        v28[440] |= 8u;
        if ((BYTE4(v5->param) & 4) != 0)
        {
          if (!*(void *)&v5->hit)
          {
            int v14 = 14336;
            goto LABEL_20;
          }

          if (v5->method[1].ssl_clear)
          {
            int v14 = -1;
LABEL_20:
            *((_DWORD *)v11 + 95) = v14;
            int v12 = 1;
            goto LABEL_21;
          }
        }

        int v12 = 0;
LABEL_21:
        char v27 = v10;
        *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v26[1] = v15;
        v26[2] = v15;
        v26[0] = v15;
        CBB_zero(v26);
        *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v25[1] = v16;
        uint64_t v25[2] = v16;
        v25[0] = v16;
        v24[1] = v16;
        _OWORD v24[2] = v16;
        v23[2] = v16;
        v24[0] = v16;
        v23[0] = v16;
        v23[1] = v16;
        v22[1] = v16;
        void v22[2] = v16;
        v22[0] = v16;
        if ((*(unsigned int (**)(ssl_st *, _OWORD *, _OWORD *, uint64_t))(*(void *)&v5->version + 88LL))( v5,  v26,  v25,  4LL)
          && CBB_add_u32((uint64_t)v25, *((_DWORD *)v28 + 46))
          && CBB_add_u32((uint64_t)v25, *((_DWORD *)v28 + 94))
          && CBB_add_u8_length_prefixed((uint64_t *)v25, (uint64_t)v24)
          && CBB_add_bytes((uint64_t)v24, &v27, 1uLL)
          && CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v23)
          && bssl::tls13_derive_session_psk(v28, (const ssl_session_st *)&v27, 1uLL)
          && bssl::ssl_encrypt_ticket(this, (uint64_t)v23, (uint64_t)v28)
          && CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v22)
          && (!v12
           || (*(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL,
               *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL,
               v21[1] = v17,
               _OWORD v21[2] = v17,
               v21[0] = v17,
               CBB_add_u16((uint64_t)v22, 0x2Au))
           && CBB_add_u16_length_prefixed((uint64_t *)v22, (uint64_t)v21)
           && CBB_add_u32((uint64_t)v21, *((_DWORD *)v28 + 95))
           && CBB_flush((uint64_t *)v22))
          && (unsigned int grease_value = bssl::ssl_get_grease_value((uint64_t)this, 5u),
              CBB_add_u16((uint64_t)v22, grease_value))
          && CBB_add_u16((uint64_t)v22, 0))
        {
          int v13 = bssl::ssl_add_message_cbb((uint64_t)v5, (uint64_t)v26) ^ 1;
        }

        else
        {
          int v13 = 1;
        }

        CBB_cleanup((uint64_t)v26);
LABEL_40:
        unint64_t v19 = (SSL_SESSION *)v28;
        int v28 = 0LL;
        if (v19) {
          SSL_SESSION_free(v19);
        }
        if (v13) {
          return 0LL;
        }
      }
    }
  }

  *(_BYTE *)a2 = 0;
  return 1LL;
}

void sub_1875A683C(_Unwind_Exception *a1)
{
}

boringssl_concrete_boringssl_psk *boringssl_psk_create(void *a1, void *a2)
{
  id v4 = a1;
  id v5 = a2;
  unsigned int v6 = objc_alloc_init(&OBJC_CLASS___boringssl_concrete_boringssl_psk);
  unsigned int v7 = v6;
  if (v6)
  {
    objc_storeStrong((id *)&v6->key, a1);
    objc_storeStrong((id *)&v7->identity, a2);
  }

  return v7;
}

id *boringssl_psk_copy_key(id *result)
{
  if (result) {
    return (id *)result[1];
  }
  return result;
}

id *boringssl_psk_copy_identity(id *result)
{
  if (result) {
    return (id *)result[2];
  }
  return result;
}

BOOL boringssl_psk_matches_identity_hint(void *a1, void *a2)
{
  if (!a1 || !a2) {
    return 0LL;
  }
  uint64_t v3 = (dispatch_data_s *)a1[2];
  id v4 = a2;
  id v5 = a1;
  boringssl_helper_dump_dispatch_data(0LL, v3);
  boringssl_helper_dump_dispatch_data(0LL, v4);
  unsigned int v6 = (void *)a1[2];

  BOOL v7 = boringssl_helper_dispatch_data_equal(v6, v4);
  return v7;
}

xpc_object_t boringssl_psk_copy_xpc_object(void *a1)
{
  uint64_t v1 = (dispatch_data_s *)a1[1];
  uint64_t v2 = a1;
  xpc_object_t v3 = xpc_data_create_with_dispatch_data(v1);
  id v4 = (dispatch_data_s *)v2[2];

  xpc_object_t v5 = xpc_data_create_with_dispatch_data(v4);
  xpc_object_t v6 = xpc_array_create(0LL, 0LL);
  xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v3);
  xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v5);

  return v6;
}

void __boringssl_log_open_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.network", "boringssl");
  uint64_t v1 = (void *)g_boringssl_log;
  g_boringssl_log = (uint64_t)v0;

  if (boringssl_logging_register_debug_log_updates_onceToken != -1) {
    dispatch_once(&boringssl_logging_register_debug_log_updates_onceToken, &__block_literal_global_3);
  }
}

uint64_t __boringssl_logging_register_debug_log_updates_block_invoke()
{
  uint64_t result = network_config_register_boringssl_log_debug_updates();
  datapath_logging_enablessl_st d = result;
  return result;
}

void __boringssl_logging_register_debug_log_updates_block_invoke_2(uint64_t a1, char a2)
{
  datapath_logging_enablessl_st d = a2;
}

uint64_t EVP_PKEY_sign_init(uint64_t *a1)
{
  if (a1 && (uint64_t v1 = *a1) != 0 && (*(void *)(v1 + 40) || *(void *)(v1 + 48)))
  {
    *((_DWORD *)a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = 8;
    return 1LL;
  }

  else
  {
    ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", 216);
    return 0LL;
  }

uint64_t EVP_PKEY_sign(_DWORD *a1)
{
  if (a1 && *(void *)a1 && (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 40LL)) != 0LL)
  {
    if (a1[8] == 8) {
      return v1();
    }
    int v3 = 126;
    int v4 = 231;
  }

  else
  {
    int v3 = 125;
    int v4 = 227;
  }

  ERR_put_error(6, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

EC_KEY *EC_KEY_new(void)
{
  return (EC_KEY *)EC_KEY_new_method(0LL);
}

void *EC_KEY_new_method(uint64_t a1)
{
  uint64_t v2 = OPENSSL_zalloc(0x38uLL);
  xpc_object_t v5 = v2;
  if (!v2) {
    return v5;
  }
  if (!a1)
  {
    ECDSA_methossl_st d = v2[5];
    if (!ECDSA_method) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  ECDSA_methossl_st d = ENGINE_get_ECDSA_method(a1);
  v5[5] = ECDSA_method;
  if (ECDSA_method) {
LABEL_4:
  }
    METHOD_ref(ECDSA_method);
LABEL_5:
  *(void *)((char *)v5 + 2_Block_object_dispose((const void *)(v30 - 136), 8) = 0x100000004LL;
  CRYPTO_new_ex_data((_DWORD)v5 + 48, v3, v4);
  uint64_t v7 = v5[5];
  if (v7)
  {
    int v8 = *(unsigned int (**)(void *))(v7 + 16);
    if (v8)
    {
      if (!v8(v5))
      {
        CRYPTO_free_ex_data((int)&g_ec_ex_data_class, v5, (CRYPTO_EX_DATA *)v5 + 3);
        uint64_t v9 = v5[5];
        if (v9) {
          METHOD_unref(v9);
        }
        OPENSSL_free(v5);
        return 0LL;
      }
    }
  }

  return v5;
}

EC_KEY *__cdecl EC_KEY_new_by_curve_name(int nid)
{
  uint64_t v2 = (EC_KEY *)EC_KEY_new_method(0LL);
  if (v2)
  {
    int v3 = EC_GROUP_new_by_curve_name(nid);
    *(void *)uint64_t v2 = v3;
    if (!v3)
    {
      EC_KEY_free(v2);
      return 0LL;
    }
  }

  return v2;
}

void EC_KEY_free(EC_KEY *a1)
{
  if (a1 && CRYPTO_refcount_dec_and_test_zero((unsigned int *)a1 + 8))
  {
    uint64_t v2 = *((void *)a1 + 5);
    if (v2)
    {
      int v3 = *(void (**)(EC_KEY *))(v2 + 24);
      if (v3)
      {
        v3(a1);
        uint64_t v2 = *((void *)a1 + 5);
      }

      METHOD_unref(v2);
    }

    CRYPTO_free_ex_data((int)&g_ec_ex_data_class, a1, (CRYPTO_EX_DATA *)a1 + 3);
    EC_GROUP_free(*(EC_GROUP **)a1);
    EC_POINT_free(*((EC_POINT **)a1 + 1));
    OPENSSL_free(*((void **)a1 + 2));
    OPENSSL_free(a1);
  }

int EC_KEY_set_group(EC_KEY *a1, const EC_GROUP *a2)
{
  int v4 = *(const EC_GROUP **)a1;
  if (v4)
  {
    if (EC_GROUP_cmp(v4, a2, 0LL))
    {
      ERR_put_error(15, 0, 130, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 216);
      return 0;
    }

    else
    {
      return 1;
    }
  }

  else
  {
    if (*((void *)a1 + 2)) {
      EC_KEY_set_group_cold_2();
    }
    if (*((void *)a1 + 1)) {
      EC_KEY_set_group_cold_1();
    }
    EC_GROUP_free(0LL);
    xpc_object_t v6 = EC_GROUP_dup(a2);
    *(void *)a1 = v6;
    return v6 != 0LL;
  }

int EC_KEY_set_public_key(EC_KEY *a1, const EC_POINT *a2)
{
  int v3 = *(const EC_GROUP **)a1;
  if (!v3)
  {
    int v5 = 114;
    int v6 = 264;
    goto LABEL_6;
  }

  if (a2 && EC_GROUP_cmp(v3, *(const EC_GROUP **)a2, 0LL))
  {
    int v5 = 130;
    int v6 = 269;
LABEL_6:
    ERR_put_error(15, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", v6);
    return 0;
  }

  EC_POINT_free(*((EC_POINT **)a1 + 1));
  int v8 = EC_POINT_dup(a2, *(const EC_GROUP **)a1);
  *((void *)a1 + 1) = v8;
  return v8 != 0LL;
}

int EC_KEY_set_private_key(EC_KEY *a1, const BIGNUM *a2)
{
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1)
  {
    ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 236);
    goto LABEL_7;
  }

  int v5 = OPENSSL_zalloc(0x60uLL);
  if (v5)
  {
    int v6 = v5;
    uint64_t v7 = v5 + 3;
    void *v5 = v5 + 3;
    int v8 = *(_DWORD *)(v2 + 264);
    *((_DWORD *)v5 + 2) = v8;
    *((_DWORD *)v5 + 3) = v8;
    *((_DWORD *)v5 + 5) = 2;
    if (!ec_bignum_to_scalar(*(void *)a1, v5 + 3, (uint64_t)a2) || ec_scalar_is_zero(*(void *)a1, v7))
    {
      ERR_put_error(15, 0, 113, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 249);
      OPENSSL_free(v6);
LABEL_7:
      LODWORD(v5) = 0;
      return (int)v5;
    }

    OPENSSL_free(*((void **)a1 + 2));
    *((void *)a1 + 2) = v6;
    LODWORD(v5) = 1;
  }

  return (int)v5;
}

uint64_t EC_KEY_is_opaque(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1) {
    return *(_DWORD *)(v1 + 48) & 1;
  }
  else {
    return 0LL;
  }
}

const EC_GROUP *__cdecl EC_KEY_get0_group(const EC_KEY *a1)
{
  return *(const EC_GROUP **)a1;
}

const EC_POINT *__cdecl EC_KEY_get0_public_key(const EC_KEY *a1)
{
  return (const EC_POINT *)*((void *)a1 + 1);
}

unsigned int EC_KEY_get_enc_flags(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 6);
}

point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 7);
}

int EC_KEY_check_key(const EC_KEY *a1)
{
  if (a1 && (uint64_t v2 = *(const EC_GROUP **)a1) != 0LL && (v3 = (const EC_POINT *)*((void *)a1 + 1)) != 0LL)
  {
    if (EC_POINT_is_at_infinity(v2, v3))
    {
      int v4 = 119;
      int v5 = 299;
    }

    else
    {
      if (EC_POINT_is_on_curve(*(const EC_GROUP **)a1, *((const EC_POINT **)a1 + 1), 0LL))
      {
        uint64_t v7 = *((void *)a1 + 2);
        if (v7)
        {
          unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v9[11] = v8;
          v9[12] = v8;
          v9[9] = v8;
          v9[10] = v8;
          v9[7] = v8;
          unsigned __int8 v9[8] = v8;
          v9[5] = v8;
          v9[6] = v8;
          _OWORD v9[3] = v8;
          v9[4] = v8;
          v9[1] = v8;
          __int128 v9[2] = v8;
          v9[0] = v8;
          if (!ec_point_mul_scalar_base(*(_DWORD **)a1, (uint64_t)v9, v7 + 24))
          {
            int v4 = 15;
            int v5 = 317;
            goto LABEL_7;
          }

          if (!ec_GFp_simple_points_equal(*(void *)a1, (uint64_t)v9, *((void *)a1 + 1) + 8LL))
          {
            int v4 = 113;
            int v5 = 324;
            goto LABEL_7;
          }
        }

        return 1;
      }

      int v4 = 120;
      int v5 = 305;
    }
  }

  else
  {
    int v4 = 67;
    int v5 = 294;
  }

LABEL_7:
  ERR_put_error(15, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", v5);
  return 0;
}

  uint64_t result = BIO_new(&mem_method);
  if (result)
  {
    int v6 = *(size_t **)&result->num;
    void *v6 = v4;
    v6[1] = (size_t)buf;
    void v6[2] = v4;
    result->init |= 0x200u;
    result->flagunsigned int s = 0;
  }

  return result;
}

uint64_t EC_KEY_oct2key(EC_KEY *a1, const unsigned __int8 *a2, size_t a3, BN_CTX *a4)
{
  int v5 = *(const EC_GROUP **)a1;
  if (v5)
  {
    uint64_t v9 = EC_POINT_new(v5);
    else {
      uint64_t v10 = 0LL;
    }
    EC_POINT_free(v9);
  }

  else
  {
    ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 399);
    return 0LL;
  }

  return v10;
}

unsigned __int8 *EC_KEY_key2buf( const EC_GROUP **a1, point_conversion_form_t a2, unsigned __int8 **a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  if (a1)
  {
    uint64_t v9 = a1[1];
    if (v9)
    {
      uint64_t v10 = *a1;
      if (v10) {
        return EC_POINT_point2buf(v10, v9, a2, a3, a4, a6);
      }
    }
  }

  ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", 414);
  return 0LL;
}

int EC_KEY_generate_key(EC_KEY *a1)
{
  if (!a1 || (uint64_t v2 = *(const EC_GROUP **)a1) == 0LL)
  {
    int v3 = 67;
    int v4 = 485;
    goto LABEL_6;
  }

  if ((int)EC_GROUP_order_bits((uint64_t)v2) <= 159)
  {
    int v3 = 112;
    int v4 = 491;
LABEL_6:
    ERR_put_error(15, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/ec_key.c", v4);
    return 0;
  }

  int v6 = *(const EC_GROUP **)a1;
  uint64_t v7 = OPENSSL_zalloc(0x60uLL);
  __int128 v8 = v7;
  if (v7)
  {
    void *v7 = v7 + 3;
    int v9 = *((_DWORD *)v6 + 66);
    *((_DWORD *)v7 + 2) = v9;
    *((_DWORD *)v7 + 3) = v9;
    *((_DWORD *)v7 + 5) = 2;
  }

  uint64_t v10 = EC_POINT_new(*(const EC_GROUP **)a1);
  unint64_t v11 = v10;
  if (!v8
    || !v10
    || !ec_random_nonzero_scalar( *(void *)a1,  v8 + 3,  (uint64_t)&EC_KEY_generate_key_kDefaultAdditionalData)
    || !ec_point_mul_scalar_base(*(_DWORD **)a1, (uint64_t)v11 + 8, (uint64_t)(v8 + 3)))
  {
    EC_POINT_free(v11);
    OPENSSL_free(v8);
    return 0;
  }

  OPENSSL_free(*((void **)a1 + 2));
  *((void *)a1 + 2) = v8;
  EC_POINT_free(*((EC_POINT **)a1 + 1));
  *((void *)a1 + 1) = v11;
  return 1;
}

os_log_s *boringssl_private_key_sign(__SecKey *a1, int a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  int v5 = a3;
  int v6 = (const __CFString *)boringssl_helper_SecKeyAlgorithm_from_signature_algorithm(a2);
  if (!CFEqual(v6, (CFTypeRef)*MEMORY[0x18960BD48]))
  {
    size_t v9 = dispatch_data_get_size(v5);
    uint64_t v10 = (UInt8 *)malloc(v9);
    if (v10)
    {
      unint64_t v11 = v10;
      boringssl_helper_dispatch_data_copyout(v5, (uint64_t)v10, v9);
      if (v6 != (const __CFString *)*MEMORY[0x18960BD00])
      {
        int v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v11, v9);
        free(v11);
        error[0] = 0LL;
        Signature = SecKeyCreateSignature(a1, v6, v12, error);
        if (Signature)
        {
          int v14 = Signature;
          size_t Length = CFDataGetLength(Signature);
          BytePtr = CFDataGetBytePtr(v14);
          dispatch_data_t v17 = dispatch_data_create(BytePtr, Length, 0LL, 0LL);
          if (v12) {
            CFRelease(v12);
          }
        }

        else
        {
          if (g_boringssl_log)
          {
            char v25 = (os_log_s *)(id)g_boringssl_log;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              boringssl_private_key_sign_cold_1(error, v25, v26);
            }
          }

          if (v12) {
            CFRelease(v12);
          }
          dispatch_data_t v17 = 0LL;
          uint64_t v7 = 0LL;
          int v14 = error[0];
          if (!error[0]) {
            goto LABEL_24;
          }
        }

        CFRelease(v14);
        uint64_t v7 = (os_log_s *)v17;
        goto LABEL_24;
      }

      unint64_t v18 = EVP_MD_CTX_create();
      if (v18)
      {
        unint64_t v19 = v18;
        int v20 = EVP_md5_sha1();
        int v32 = -1431655766;
        *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uint64_t error = v21;
        __int128 v31 = v21;
        EVP_DigestInit_ex(v19, (const EVP_MD *)v20, 0LL);
        EVP_DigestUpdate(v19, v11, v9);
        unsigned int s = 0;
        EVP_DigestFinal_ex(v19, (unsigned __int8 *)error, &s);
        EVP_MD_CTX_destroy(v19);
        size_t BlockSize = SecKeyGetBlockSize(a1);
        size_t v23 = (uint8_t *)malloc(BlockSize);
        if (v23)
        {
          char v24 = v23;
          size_t size = BlockSize;
          else {
            uint64_t v7 = (os_log_s *)dispatch_data_create(v24, size, 0LL, 0LL);
          }
          free(v24);
          free(v11);
          goto LABEL_24;
        }
      }

      free(v11);
    }

dispatch_data_t boringssl_private_key_decrypt(__SecKey *a1, void *a2)
{
  int v3 = a2;
  size_t size = dispatch_data_get_size(v3);
  int v5 = (uint8_t *)malloc(size);
  if (!v5)
  {
    dispatch_data_t v10 = 0LL;
    goto LABEL_8;
  }

  int v6 = v5;
  boringssl_helper_dispatch_data_copyout(v3, (uint64_t)v5, size);
  uint64_t v7 = (char *)malloc(size);
  bzero(v7, size);
  plainTextLeuint64_t n = size;
  if (!SecKeyDecrypt(a1, 0, v6, size, (uint8_t *)v7, &plainTextLen))
  {
    size_t v8 = plainTextLen;
    size_t v9 = size - plainTextLen;
    if (size >= plainTextLen)
    {
      unint64_t v11 = (char *)malloc(size);
      bzero(v11, size);
      memcpy(&v11[v9], v7, v8);
      dispatch_data_t v10 = dispatch_data_create(v11, size, 0LL, 0LL);
      if (v7) {
        free(v7);
      }
      if (!v11) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
  }

  dispatch_data_t v10 = 0LL;
  unint64_t v11 = v7;
  if (v7) {
LABEL_5:
  }
    free(v11);
LABEL_6:
  free(v6);
LABEL_8:

  return v10;
}

void OUTLINED_FUNCTION_0_3(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

uint64_t bssl::dtls1_open_app_data( bssl *a1, _OWORD *a2, unint64_t *a3, char *a4, unsigned __int8 *a5, unint64_t a6)
{
  unsigned __int8 v21 = -86;
  __int128 v20 = 0uLL;
  uint64_t result = bssl::dtls_open_record(a1, (char *)&v21, (uint64_t)&v20, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
    int v13 = v21;
    if (v21 == 22)
    {
      v18[0] = 0xAAAAAAAAAAAAAAAALL;
      v18[1] = 0xAAAAAAAAAAAAAAAALL;
      memset(v17, 170, 20);
      __int128 v19 = v20;
      if ((bssl::dtls1_parse_fragment((uint64_t *)&v19, (uint64_t)v17, v18) & 1) == 0)
      {
        ERR_put_error(16, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_pkt.cc", 150);
        char v16 = 50;
LABEL_16:
        *a4 = v16;
        return 4LL;
      }

      if (LOBYTE(v17[0]) == 20 && *(unsigned __int16 *)(*((void *)a1 + 7) + 50LL) - 1 == LOWORD(v17[1]))
      {
        if (HIDWORD(v17[1])) {
          return 1LL;
        }
        if (bssl::dtls1_check_timeout_num(a1, v14))
        {
          bssl::dtls1_retransmit_outgoing_messages(a1, v15);
          return 1LL;
        }

        *a4 = 0;
        return 4LL;
      }

      int v13 = v21;
    }

    if (v13 == 23)
    {
      if (*((void *)&v20 + 1))
      {
        uint64_t result = 0LL;
        *a2 = v20;
        return result;
      }

      return 1LL;
    }

    ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_pkt.cc", 176);
    char v16 = 10;
    goto LABEL_16;
  }

  return result;
}

uint64_t bssl::dtls1_write_app_data(bssl *a1, _BYTE *a2, unint64_t *a3, char *a4, unint64_t a5)
{
  *a2 = 0;
  if (*(_DWORD *)(*((void *)a1 + 6) + 176LL))
  {
    int v10 = 194;
    int v11 = 195;
LABEL_6:
    ERR_put_error(16, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/d1_pkt.cc", v11);
    return 0xFFFFFFFFLL;
  }

  if (a5 > 0x4000)
  {
    int v10 = 143;
    int v11 = 201;
    goto LABEL_6;
  }

  if (!a5)
  {
    *a3 = 0LL;
    return 1LL;
  }

  uint64_t result = bssl::dtls1_write_record(a1, (const ssl_st *)0x17, a4, a5, 1);
  if ((int)result >= 1)
  {
    *a3 = a5;
    return 1LL;
  }

  return result;
}

uint64_t bssl::dtls1_write_record(bssl *this, const ssl_st *a2, char *a3, unint64_t a4, int a5)
{
  if (a4 > 0x4000) {
    bssl::dtls1_write_record();
  }
  int v6 = (_WORD *)*((void *)this + 6);
  if (v6[58]) {
    bssl::dtls1_write_record();
  }
  char v10 = (char)a2;
  unint64_t v15 = 0LL;
  int v11 = bssl::ssl_seal_align_prefix_len((unsigned __int8 **)this, a2);
  uint64_t v12 = SSL_max_seal_overhead((uint64_t)this);
  if (bssl::SSLBuffer::EnsureCap((bssl::SSLBuffer *)(v6 + 52), v11, v12 + a4)
    && (bssl::dtls_seal_record( (uint64_t)this,  *((void *)v6 + 13) + (unsigned __int16)v6[56] + (unsigned __int16)v6[58],  &v15,  (unsigned __int16)v6[59] - (unint64_t)(unsigned __int16)v6[58],  v10,  a3,  a4,  a5) & 1) != 0)
  {
    bssl::SSLBuffer::DidWrite((uint64_t)(v6 + 52), v15);
    LODWORD(result) = bssl::ssl_write_buffer_flush(this, v13);
    else {
      return result;
    }
  }

  else
  {
    bssl::SSLBuffer::Clear(v6 + 52);
    return 0xFFFFFFFFLL;
  }

uint64_t bssl::dtls1_dispatch_alert(BIO **this, ssl_st *a2)
{
  uint64_t v3 = bssl::dtls1_write_record((bssl *)this, (const ssl_st *)0x15, (char *)&this[6][4].cb_arg + 5, 2uLL, 1);
  if ((int)v3 >= 1)
  {
    *((_WORD *)&this[6][1].ex_data.dummy + 2) &= ~0x800u;
    int v4 = this[6];
    if (BYTE5(v4[4].cb_arg) == 2)
    {
      BIO_flush(this[4]);
      int v4 = this[6];
    }

    bssl::ssl_do_msg_callback((uint64_t)this, 1LL, 21LL, (uint64_t)&v4[4].cb_arg + 5, 2LL);
    bssl::ssl_do_info_callback((uint64_t)this, (const ssl_st *)0x4008);
  }

  return v3;
}

BOOL bssl::tls1_prf( uint64_t *a1, _BYTE *a2, size_t a3, char *a4, unint64_t a5, const unsigned __int8 *a6, size_t a7, uint64_t a8, const unsigned __int8 *a9, size_t a10, const unsigned __int8 *a11, size_t a12)
{
  return CRYPTO_tls1_prf(a1, a2, a3, a4, a5, a6, a7, a9, a10, a11, a12) == 1;
}

uint64_t bssl::tls1_configure_aead( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t **a4, char *a5, const ssl_cipher_st *a6)
{
  size_t v6 = (size_t)a6;
  memset(var68, 170, 24);
  size_t v12 = var68[1];
  unint64_t v13 = 2 * (var68[1] + var68[2] + var68[0]);
  uint64_t v14 = *(void *)(a3 + 8);
  if (!v14)
  {
    if (!bssl::Array<unsigned char>::Init(a3, 2 * (var68[1] + var68[2] + var68[0]))
      || !bssl::generate_key_block(a1, *(ssl_session_st **)a3, *(void *)(a3 + 8), (bssl *)a4))
    {
      return 0LL;
    }

    uint64_t v14 = *(void *)(a3 + 8);
  }

  if (v14 != v13) {
    bssl::tls1_configure_aead();
  }
  unint64_t v15 = *(ssl_session_st **)a3;
  if (((*(_BYTE *)(a1 + 180) & 1) == 0) == (_DWORD)a2)
  {
    if (v13 >= var68[2]) {
      size_t v16 = var68[2];
    }
    else {
      size_t v16 = v13;
    }
    if (v13 >= 2 * var68[2] && v13 >= 2 * (var68[2] + v12))
    {
      unint64_t v17 = 2 * var68[2];
      unint64_t v18 = 2 * (var68[2] + v12);
      unint64_t v19 = var68[0];
      __int128 v20 = v15;
      goto LABEL_21;
    }

LABEL_38:
    abort();
  }

  if (v13 < var68[2]) {
    goto LABEL_38;
  }
  unint64_t v17 = v12 + 2 * var68[2];
  if (v13 < v17) {
    goto LABEL_38;
  }
  size_t v16 = v13 - var68[2] >= var68[2] ? var68[2] : v13 - var68[2];
  unint64_t v19 = var68[0];
  unint64_t v18 = var68[0] + 2 * (var68[2] + v12);
  if (v13 < v18) {
    goto LABEL_38;
  }
  __int128 v20 = (ssl_session_st *)((char *)v15 + var68[2]);
LABEL_21:
  if (v13 - v17 < v12) {
    size_t v12 = v13 - v17;
  }
  size_t v21 = v13 - v18;
  if (v13 - v18 >= v19) {
    size_t v21 = v19;
  }
  if (v6)
  {
    if (v6 != v19) {
      return 0LL;
    }
  }

  else
  {
    a5 = (char *)v15 + v18;
    size_t v6 = v21;
  }

  size_t v23 = (_OWORD *)((char *)&v15->ssl_version + v17);
  int v35 = (bssl::SSLAEADContext *)0xAAAAAAAAAAAAAAAALL;
  char v24 = (unsigned __int16 *)*(unsigned __int16 *)(a1 + 16);
  char v25 = SSL_is_dtls((unsigned __int8 **)a1) != 0;
  bssl::SSLAEADContext::Create(a2, v24, v25, (uint64_t)a4[25], v23, v12, v20, v16, &v35, a5, v6);
  uint64_t v26 = v35;
  if (v35)
  {
    uint64_t v27 = *(void *)a1;
    if ((_DWORD)a2)
    {
      int v28 = *(uint64_t (**)(uint64_t, uint64_t, bssl::SSLAEADContext **, void, void))(v27 + 144);
      int v35 = 0LL;
      size_t v29 = &v33;
      uint64_t v33 = v26;
      uint64_t v30 = v28(a1, 3LL, &v33, 0LL, 0LL);
    }

    else
    {
      __int128 v31 = *(uint64_t (**)(uint64_t, uint64_t, bssl::SSLAEADContext **, void, void))(v27 + 136);
      unint64_t v34 = v35;
      int v35 = 0LL;
      size_t v29 = &v34;
      uint64_t v30 = v31(a1, 3LL, &v34, 0LL, 0LL);
    }

    uint64_t v22 = v30;
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](v29, 0LL);
  }

  else
  {
    uint64_t v22 = 0LL;
  }

  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v35, 0LL);
  return v22;
}

  return v10;
}

        if ((*((_BYTE *)this + 1584) & 0x80) == 0) {
          goto LABEL_43;
        }
        char v25 = *((void *)v21 + 15);
        uint64_t v26 = *(uint64_t (**)(bssl *, void))(v25 + 792);
        if (!v26) {
          goto LABEL_43;
        }
        uint64_t v27 = v26(v21, *(void *)(v25 + 800));
        if (!v27) {
          goto LABEL_43;
        }
        if (v27 != 3)
        {
          ERR_put_error(16, 0, 289, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_server.cc", 823);
          bssl::ssl_send_alert(v21, (ssl_st *)2, 80);
          goto LABEL_403;
        }

        *((_DWORD *)this + 396) &= ~0x80u;
LABEL_43:
        if (bssl::ssl_protocol_version(v21, cipher_by_value) >= 0x304)
        {
          *((_DWORD *)this + 5) = 4;
          goto LABEL_226;
        }

        uint64_t v112 = *((void *)v21 + 6);
        if (*(_DWORD *)(v112 + 216) == 1) {
          bssl::ssl_server_handshake();
        }
        *(_DWORD *)(v112 + bssl::Array<unsigned short>::~Array(v16 + 256) = 3;
        uint64_t v7 = 5;
        goto LABEL_225;
      case 4:
        prev_sessiouint64_t n = bssl::tls13_server_handshake(this, (bssl::SSL_HANDSHAKE *)cipher_by_value, a3);
        if ((_DWORD)prev_session == 1) {
          *((_DWORD *)this + 5) = 20;
        }
        goto LABEL_404;
      case 5:
        uint64_t v44 = *(void *)this;
        *(void **)((char *)&v219.msg_callback_arg + 2) = (void *)0xAAAAAAAAAAAAAAAALL;
        *(void *)&uint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v45 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&v219.s3 + 2) = v45;
        *(_OWORD *)((char *)&v219.read_ahead + 2) = v45;
        *(_OWORD *)((char *)&v219.sid_ctx_length + 2) = v45;
        *(_OWORD *)&v219.sid_ctx[14] = v45;
        *(_OWORD *)((char *)&v219.enc_write_ctx + 2) = v45;
        *(_OWORD *)((char *)&v219.compress + 2) = v45;
        *(_OWORD *)((char *)&v219.cipher_list_by_id + 2) = v45;
        *(_OWORD *)((char *)&v219.read_hash + 2) = v45;
        *(_OWORD *)((char *)&v219.param + 2) = v45;
        if (!bssl::SSL_HANDSHAKE::GetClientHello( (uint64_t *)this,  (uint64_t)&v219.s3 + 2,  (uint64_t)&v219.param + 2)) {
          goto LABEL_403;
        }
        LOWORD(v219.version) = 0;
        shared_group = bssl::tls1_get_shared_group(this, &v219, (unsigned __int16 *)a3);
        int v47 = *(uint64_t *)((char *)&v219.cert + 2);
        *(BUF_MEM **)((char *)&v219.init_buf + 2) = *(BUF_MEM **)((char *)&v219.compress + 2);
        *(void **)((char *)&v219.init_msg + 2) = *(cert_st **)((char *)&v219.cert + 2);
        int v48 = (BUF_MEM *)OPENSSL_sk_new_null();
        *(void *)((char *)&v219.version + 2) = v48;
        if (!v48 || !v47) {
          goto LABEL_78;
        }
        do
        {
          WORD1(v219.handshake_func) = -21846;
          if (!CBS_get_u16( (unsigned __int16 **)((char *)&v219.init_buf + 2),  (_WORD *)&v219.handshake_func + 1))
          {
            ERR_put_error(16, 0, 148, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_server.cc", 285);
LABEL_263:
            *(void *)((char *)&v219.quiet_shutdown + 2) = 0LL;
            *(void *)((char *)&v219.version + 2) = 0LL;
            BUF_MEM_free(v48);
            goto LABEL_403;
          }

          cipher_by_value = (ssl_st *)SSL_get_cipher_by_value(WORD1(v219.handshake_func));
        }

        while (*(void **)((char *)&v219.init_msg + 2));
LABEL_78:
        *(void *)((char *)&v219.quiet_shutdown + 2) = v48;
        if (!v48) {
          goto LABEL_403;
        }
        *(BUF_MEM **)((char *)&v219.init_buf + 2) = 0LL;
        *(void **)((char *)&v219.init_msg + 2) = 0LL;
        if ((bssl::ssl_get_credential_list(this, (void **)((char *)&v219.init_buf + 2)) & 1) != 0)
        {
          unint64_t v200 = v4;
          if (*(void **)((char *)&v219.init_msg + 2))
          {
            uint64_t v49 = *(bssl::SSL_HANDSHAKE ***)((char *)&v219.init_buf + 2);
            unint64_t v50 = 8 * *(uint64_t *)((char *)&v219.init_msg + 2);
            while (1)
            {
              __int128 v51 = *v49;
              ERR_clear_error();
              uint64_t v53 = bssl::choose_params(this, v51, (EVP_MD_CTX *)v48, (unsigned __int16 *)shared_group);
              if (v53) {
                break;
              }
              ++v49;
              v50 -= 8LL;
              if (!v50) {
                goto LABEL_285;
              }
            }

            int v130 = v52;
            if (v51) {
              SSL_CREDENTIAL_up_ref(v51);
            }
            std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>::reset[abi:ne180100](v212, v51);
LABEL_298:
            int v4 = v200;
            *((void *)this + 194) = v53;
            *((_WORD *)this + 797) = v130;
            char v131 = BYTE2(v219.write_hash);
            *((_BYTE *)this + 1629) = BYTE2(v219.write_hash);
            if (v131 >= 0x21) {
              __assert_rtn( "do_select_parameters",  "handshake_server.cc",  909,  "hs->session_id_len <= sizeof(hs->session_id)");
            }
            if (v131) {
              memcpy(__dst, *(const void **)((char *)&v219.enc_write_ctx + 2), v131);
            }
            *(void *)((char *)&v219.version + 2) = 0LL;
            BYTE2(v219.handshake_func) = 0;
            LOBYTE(v216) = 0;
            prev_sessiouint64_t n = bssl::ssl_get_prev_session( (uint64_t *)this,  (SSL_SESSION **)((char *)&v219.version + 2),  (char *)&v219.handshake_func + 2,  &v216,  (uint64_t)&v219.param + 2);
            if ((_DWORD)prev_session != 1) {
              goto LABEL_442;
            }
            if (*(void *)((char *)&v219.version + 2))
            {
              if ((*(_BYTE *)(*(void *)((char *)&v219.version + 2) + 440LL) & 1) != 0
                && (*((_BYTE *)this + 1586) & 1) == 0)
              {
                ERR_put_error( 16,  0,  204,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_server.cc",  925);
                bssl::ssl_send_alert((bssl *)v44, (ssl_st *)2, 40);
                goto LABEL_441;
              }

              if (bssl::ssl_session_is_resumable( this,  *(const EVP_MD_CTX ***)((char *)&v219.version + 2),  v132))
              {
                unint64_t v142 = *((_DWORD *)this + 396);
                unint64_t v143 = *(SSL_SESSION **)((char *)&v219.version + 2);
              }

              std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]( (SSL_SESSION **)((char *)&v219.version + 2),  0LL);
              unint64_t v143 = *(SSL_SESSION **)((char *)&v219.version + 2);
              if (*(void *)((char *)&v219.version + 2))
              {
                unint64_t v142 = *((_DWORD *)this + 396);
LABEL_365:
                *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v142 & 0xFFFF7FFF | (v216 << 15);
                *(void *)((char *)&v219.version + 2) = 0LL;
                std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]( (SSL_SESSION **)(v44 + 104),  v143);
                *(_WORD *)(*(void *)(v44 + 48) + 220LL) |= 0x40u;
                *((_DWORD *)this + 396) |= 0x1000000u;
LABEL_370:
                unsigned int v147 = *(unsigned int (**)(char *))(*(void *)(v44 + 120) + 488LL);
                if (v147 && !v147((char *)&v219.param + 2))
                {
                  ERR_put_error( 16,  0,  133,  "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/handshake_server.cc",  963);
                  bssl::ssl_send_alert((bssl *)v44, (ssl_st *)2, 80);
                }

                else
                {
                  if (!*(void *)(v44 + 104))
                  {
                    int v148 = (bssl *)*((void *)this + 194);
                    *(void *)(*((void *)this + 190) + 20std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)(v1 - 72), 0LL) = v148;
                    unint64_t v149 = *((void *)this + 190);
                    if ((*(_BYTE *)(*(void *)(v149 + 200) + 20LL) & 2) != 0)
                    {
                      if ((shared_group & 1) == 0) {
                        __assert_rtn("do_select_parameters", "handshake_server.cc", 971, "has_ecdhe_group");
                      }
                      *(_WORD *)(v149 + 6) = v219.version;
                    }

                    int v150 = *((void *)this + 1);
                    uint64_t v151 = *((_DWORD *)this + 396);
                    uint64_t v152 = v151 & 0xFFFFFFDF;
                    int v155 = (v151 & 0x2000000) == 0;
                    int v153 = v151 & 0xFFFFFFDF | (32 * (*(_BYTE *)(v150 + 300) & 1));
                    *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v153;
                    int v154 = *(_BYTE *)(v150 + 300) & 4;
                    int v155 = v155 || v154 == 0;
                    if (v155) {
                      int v156 = v153;
                    }
                    else {
                      int v156 = v152;
                    }
                    *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v156;
                    size_t v157 = bssl::ssl_cipher_uses_certificate_auth(v148, v144);
                    uint64_t v158 = *((_DWORD *)this + 396);
                    if (!v157)
                    {
                      v158 &= ~0x20u;
                      *((_DWORD *)this + 3bssl::Array<unsigned short>::~Array(v1 - 96) = v158;
                    }

                    if ((v158 & 0x20) == 0) {
                      *(void *)(*((void *)this + 190) + 176LL) = 0LL;
                    }
                  }

                  int v218 = 50;
                  if ((bssl::ssl_negotiate_alpn((uint64_t)this, (char *)&v218, (uint64_t)&v219.param + 2) & 1) != 0)
                  {
                    uint64_t v160 = (bssl *)bssl::ssl_protocol_version((bssl *)v44, v159);
                    if (bssl::SSLTranscript::InitHash( (size_t **)v211,  v160,  *((const ssl_cipher_st **)this + 194))
                      && (bssl::ssl_hash_message((uint64_t)this, (uint64_t)&v219.s3 + 2) & 1) != 0)
                    {
                      if ((*((_DWORD *)this + 396) & 0x40020) == 0) {
                        bssl::SSLTranscript::FreeBuffer(v211);
                      }
                      (*(void (**)(uint64_t))(*(void *)v44 + 32LL))(v44);
                      *((_DWORD *)this + 5) = 6;
                      prev_sessiouint64_t n = 1LL;
                      goto LABEL_442;
                    }

                    uint64_t v165 = 80;
                  }

                  else
                  {
                    uint64_t v165 = v218;
                  }

                  bssl::ssl_send_alert((bssl *)v44, (ssl_st *)2, v165);
                }

void sub_1875A7D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  int v5 = va_arg(va1, bssl::SSLAEADContext *);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va, 0LL);
  std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100]((bssl::SSLAEADContext **)va1, 0LL);
  _Unwind_Resume(a1);
}

uint64_t bssl::get_key_block_lengths( bssl *this, const ssl_st *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, const ssl_cipher_st *a6)
{
  __int128 v20 = 0LL;
  unsigned int v11 = bssl::ssl_protocol_version(this, a2);
  char v12 = SSL_is_dtls((unsigned __int8 **)this) != 0;
  if ((bssl::ssl_cipher_get_evp_aead((void **)&v20, (uint64_t *)&a2->version, (uint64_t *)a4, (uint64_t)a5, v11, v12) & 1) == 0)
  {
    int v17 = 130;
    int v18 = 173;
    goto LABEL_6;
  }

  unint64_t v13 = EVP_AEAD_key_length(v20);
  *a3 = v13;
  if (*(void *)&a2->version)
  {
    unint64_t v14 = *a4 + *(void *)&a2->version;
    BOOL v15 = v13 >= v14;
    unint64_t v16 = v13 - v14;
    if (!v15)
    {
      int v17 = 68;
      int v18 = 183;
LABEL_6:
      ERR_put_error(16, 0, v17, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/t1_enc.cc", v18);
      return 0LL;
    }

    *a3 = v16;
  }

  return 1LL;
}

BOOL bssl::generate_key_block(uint64_t a1, ssl_session_st *a2, size_t a3, bssl *this)
{
  uint64_t v7 = (char *)this + 11;
  unint64_t v8 = *((unsigned __int8 *)this + 10);
  digest = (uint64_t *)bssl::ssl_session_get_digest(this, a2);
  return CRYPTO_tls1_prf( digest,  a2,  a3,  v7,  v8,  "key expansion",  0xDuLL,  (const unsigned __int8 *)(*(void *)(a1 + 48) + 16LL),  0x20uLL,  (const unsigned __int8 *)(*(void *)(a1 + 48) + 48LL),  0x20uLL) == 1;
}

uint64_t bssl::tls1_change_cipher_state(bssl *a1, const bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = (uint64_t)a1 + 1560;
  int v5 = (unint64_t **)bssl::ssl_handshake_session(a1, a2);
  return bssl::tls1_configure_aead(v3, (uint64_t)a2, v4, v5, 0LL, 0LL);
}

uint64_t bssl::tls1_generate_master_secret(uint64_t *a1, _BYTE *a2, char *a3, unint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if ((*((_BYTE *)a1 + 1586) & 1) != 0)
  {
    *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v17 = v10;
    __int128 v18 = v10;
    *(_OWORD *)BOOL v15 = v10;
    __int128 v16 = v10;
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v11 = (bssl::SSLTranscript *)(a1 + 53);
    char v12 = (uint64_t *)bssl::SSLTranscript::Digest(v11);
    int v9 = CRYPTO_tls1_prf(v12, a2, 0x30uLL, a3, a4, "extended master secret", 0x16uLL, v15, v14, 0LL, 0LL);
  }

  else
  {
    uint64_t v7 = *a1;
    unint64_t v8 = (uint64_t *)bssl::SSLTranscript::Digest((bssl::SSLTranscript *)(a1 + 53));
    int v9 = CRYPTO_tls1_prf( v8,  a2,  0x30uLL,  a3,  a4,  "master secret",  0xDuLL,  (const unsigned __int8 *)(*(void *)(v7 + 48) + 48LL),  0x20uLL,  (const unsigned __int8 *)(*(void *)(v7 + 48) + 16LL),  0x20uLL);
  }

  if (v9 == 1) {
    return 48LL;
  }
  return 0LL;
}

BOOL SSL_generate_key_block(SSL *a1, ssl_session_st *a2, size_t a3)
{
  if (SSL_in_init((uint64_t)a1) || bssl::ssl_protocol_version((bssl *)a1, v6) >= 0x304)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/t1_enc.cc", 325);
    return 0LL;
  }

  else
  {
    sessiouint64_t n = (bssl *)SSL_get_session(a1);
    return bssl::generate_key_block((uint64_t)a1, a2, a3, session);
  }

uint64_t SSL_export_keying_material( bssl *this, ssl_st *a2, size_t a3, const void *a4, size_t a5, const void *a6, size_t a7, int a8)
{
  if ((*(_WORD *)(*((void *)this + 6) + 220LL) & 2) != 0
    && bssl::ssl_protocol_version(this, a2) >= 0x304)
  {
    uint64_t v17 = *((void *)this + 6);
    uint64_t v18 = *(unsigned __int8 *)(v17 + 442);
    if (*(_BYTE *)(v17 + 442))
    {
      if (a8) {
        size_t v19 = a7;
      }
      else {
        size_t v19 = 0LL;
      }
      uint64_t v20 = v17 + 392;
      if (a8) {
        size_t v21 = a6;
      }
      else {
        size_t v21 = 0LL;
      }
      return bssl::tls13_export_keying_material((const SSL *)this, (int)a2, a3, v20, v18, a4, a5, v16, v21, v19);
    }

    int v23 = 284;
    int v24 = 339;
LABEL_27:
    ERR_put_error(16, 0, v23, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/t1_enc.cc", v24);
    return 0LL;
  }

  if (SSL_in_init((uint64_t)this) && !SSL_in_false_start((uint64_t)this))
  {
    int v23 = 284;
    int v24 = 355;
    goto LABEL_27;
  }

  if (a8)
  {
    if (a7 >= 0x10000)
    {
      int v23 = 69;
      int v24 = 362;
      goto LABEL_27;
    }

    unint64_t v25 = a7 + 66;
  }

  else
  {
    unint64_t v25 = 64LL;
  }

  int v35 = 0LL;
  size_t v36 = 0LL;
  if ((bssl::Array<unsigned char>::Init((uint64_t)&v35, v25) & 1) != 0)
  {
    uint64_t v26 = v35;
    uint64_t v27 = *((void *)this + 6);
    __int128 v28 = *(_OWORD *)(v27 + 64);
    *(_OWORD *)int v35 = *(_OWORD *)(v27 + 48);
    v26[1] = v28;
    uint64_t v29 = *((void *)this + 6);
    __int128 v30 = *(_OWORD *)(v29 + 32);
    v26[2] = *(_OWORD *)(v29 + 16);
    _OWORD v26[3] = v30;
    if (a8)
    {
      *((_WORD *)v26 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = bswap32(a7) >> 16;
      if (a7) {
        memcpy((char *)v26 + 66, a6, a7);
      }
    }

    sessiouint64_t n = SSL_get_session((const SSL *)this);
    digest = (uint64_t *)bssl::ssl_session_get_digest((bssl *)session, v32);
    BOOL v22 = CRYPTO_tls1_prf( digest,  a2,  a3,  (char *)&session->key_arg[3],  session->key_arg[2],  (const unsigned __int8 *)a4,  a5,  (const unsigned __int8 *)v35,  v36,  0LL,  0LL) == 1;
  }

  else
  {
    BOOL v22 = 0LL;
  }

  OPENSSL_free(v35);
  return v22;
}

void sub_1875A82CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t bssl::CERT::CERT(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  unsigned int v5 = 0;
  *(void *)(a1 + 24) = bssl::New<ssl_credential_st,bssl::SSLCredentialType>(&v5);
  *(void *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = a2;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v30 - 136), 8) = 0u;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array(v16 + 104) = 0u;
  *(_BYTE *)(a1 + 120) = 0;
  return a1;
}

void sub_1875A834C(_Unwind_Exception *a1)
{
}

BOOL bssl::ssl_has_certificate(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2 = *((void *)this + 188);
  return v2 && *(_DWORD *)(v2 + 4) <= 1u && bssl::ssl_has_private_key(this, a2);
}

BOOL bssl::ssl_has_server_raw_public_key_certificate(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  if ((*((_BYTE *)this + 1586) & 0x20) == 0 || *((_BYTE *)this + 730) != 2) {
    return 0LL;
  }
  BOOL result = bssl::ssl_has_private_key(this, a2);
  if (!result) {
    return result;
  }
  uint64_t v4 = *((void *)this + 188);
  return v4 && *(_DWORD *)(v4 + 4) == 2;
}

BOOL bssl::ssl_parse_cert_chain( char *a1, unint64_t **a2, EVP_PKEY **a3, unsigned __int8 *a4, unsigned __int8 **a5, void **a6)
{
  int v23 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u24_length_prefixed(a5, (unint64_t *)&v23))
  {
    *a1 = 50;
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 259);
    return 0;
  }

  if (!v24) {
    return 1;
  }
  EVP_MD_CTX ctx = (EVP_MD_CTX *)OPENSSL_sk_new_null();
  if (!ctx)
  {
    BOOL v12 = 0;
    *a1 = 80;
    goto LABEL_27;
  }

  pkey = 0LL;
  BOOL v12 = v24 == 0;
  unint64_t v13 = 0LL;
  if (!v24)
  {
LABEL_17:
    uint64_t v16 = (unint64_t *)ctx;
    EVP_MD_CTX ctx = 0LL;
    std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100](a2, v16);
    pkey = 0LL;
    std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100](a3, v13);
    unint64_t v13 = pkey;
    goto LABEL_25;
  }

  while (1)
  {
    *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_u24_length_prefixed(&v23, (unint64_t *)&v20) || !*((void *)&v20 + 1))
    {
      *a1 = 50;
      ERR_put_error(16, 0, 127, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 279);
      goto LABEL_25;
    }

    if (!EVP_MD_CTX_md(ctx)) {
      break;
    }
LABEL_14:
    BOOL v15 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v20, a6);
    if (!v15) {
      goto LABEL_23;
    }
    size_t v19 = 0LL;
    if (!OPENSSL_sk_push((unint64_t *)ctx, (uint64_t)v15))
    {
      CRYPTO_BUFFER_free(v15);
LABEL_23:
      char v17 = 80;
      goto LABEL_24;
    }

    BOOL v12 = v24 == 0;
    if (!v24) {
      goto LABEL_17;
    }
  }

  bssl::ssl_cert_parse_pubkey(&v20, &v19);
  unint64_t v14 = v19;
  size_t v19 = 0LL;
  pkey = v14;
  if (v13)
  {
    EVP_PKEY_free(v13);
    unint64_t v13 = pkey;
    if (!pkey) {
      goto LABEL_29;
    }
    goto LABEL_12;
  }

  unint64_t v13 = v14;
  if (v14)
  {
LABEL_12:
    if (a4) {
      SHA256((const unsigned __int8 *)v20, *((size_t *)&v20 + 1), a4);
    }
    goto LABEL_14;
  }

void sub_1875A860C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  size_t v6 = va_arg(va1, EVP_PKEY *);
  std::unique_ptr<evp_pkey_st,bssl::internal::Deleter>::reset[abi:ne180100]((EVP_PKEY **)va, 0LL);
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]((unint64_t **)va1, 0LL);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_compare_public_and_private_key( const EVP_PKEY *this, const evp_pkey_st *a2, const evp_pkey_st *a3)
{
  int v6 = EVP_PKEY_cmp(this, a2) + 2;
  uint64_t result = 1LL;
  switch(v6)
  {
    case 0:
      int v7 = 128;
      int v8 = 383;
      goto LABEL_7;
    case 1:
      int v7 = 115;
      int v8 = 380;
      goto LABEL_7;
    case 2:
      int v7 = 116;
      int v8 = 377;
LABEL_7:
      ERR_put_error(11, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v8);
      uint64_t result = 0LL;
      break;
    case 3:
      return result;
    default:
      bssl::ssl_compare_public_and_private_key();
  }

  return result;
}

void bssl::ssl_parse_client_CA_list( uint64_t a1@<X0>, _BYTE *a2@<X1>, unsigned __int8 **a3@<X2>, unint64_t **a4@<X8>)
{
  int v8 = *(void ***)(*(void *)(a1 + 120) + 776LL);
  unint64_t v14 = OPENSSL_sk_new_null();
  if (!v14)
  {
LABEL_14:
    *a2 = 80;
    goto LABEL_15;
  }

  BOOL v12 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u16_length_prefixed(a3, (unint64_t *)&v12))
  {
    *a2 = 50;
    ERR_put_error(16, 0, 162, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 481);
LABEL_15:
    *a4 = 0LL;
    goto LABEL_16;
  }

  if (v13)
  {
    while (1)
    {
      v11[0] = 0xAAAAAAAAAAAAAAAALL;
      v11[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!CBS_get_u16_length_prefixed(&v12, v11))
      {
        *a2 = 50;
        ERR_put_error(16, 0, 123, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", 489);
        goto LABEL_15;
      }

      int v9 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)v11, v8);
      if (!v9) {
        goto LABEL_14;
      }
      if (!v13) {
        goto LABEL_8;
      }
    }

    CRYPTO_BUFFER_free(v9);
    goto LABEL_14;
  }

void sub_1875A88AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

const EVP_MD_CTX *bssl::ssl_has_client_CAs(bssl *this, const bssl::SSL_CONFIG *a2)
{
  uint64_t result = (const EVP_MD_CTX *)*((void *)this + 11);
  if (result) {
    return (const EVP_MD_CTX *)(EVP_MD_CTX_md(result) != 0LL);
  }
  uint64_t result = *(const EVP_MD_CTX **)(*(void *)(*(void *)this + 120LL) + 400LL);
  if (result) {
    return (const EVP_MD_CTX *)(EVP_MD_CTX_md(result) != 0LL);
  }
  return result;
}

uint64_t bssl::ssl_add_client_CA_list(void *a1, uint64_t *a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[1] = v4;
  void v14[2] = v4;
  unint64_t v13[2] = v4;
  v14[0] = v4;
  v13[0] = v4;
  v13[1] = v4;
  uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v14);
  if ((_DWORD)result)
  {
    int v6 = *(unint64_t **)(a1[1] + 88LL);
    if ((v6 || (int v6 = *(unint64_t **)(*(void *)(*a1 + 120LL) + 400LL)) != 0LL)
      && (int v7 = EVP_MD_CTX_md((const EVP_MD_CTX *)v6)) != 0LL)
    {
      int v8 = v7;
      unint64_t v9 = 0LL;
      while (1)
      {
        __int128 v10 = OPENSSL_sk_value(v6, v9);
        uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v14, (uint64_t)v13);
        if (!(_DWORD)result) {
          break;
        }
        unsigned int v11 = (const void *)CRYPTO_BUFFER_data((uint64_t)v10);
        size_t v12 = CRYPTO_BUFFER_len((uint64_t)v10);
        uint64_t result = CBB_add_bytes((uint64_t)v13, v11, v12);
        if (!(_DWORD)result) {
          break;
        }
        if (v8 == (const EVP_MD *)++v9) {
          return CBB_flush(a2) != 0;
        }
      }
    }

    else
    {
      return CBB_flush(a2) != 0;
    }
  }

  return result;
}

uint64_t bssl::ssl_check_leaf_certificate(uint64_t a1, ssl_st *a2)
{
  int v4 = *(_DWORD *)(*(void *)(a1 + 1552) + 24LL);
  if ((bssl::ssl_cipher_auth_mask_for_key((bssl *)a2, (const evp_pkey_st *)1) & v4) != 0)
  {
    unsigned int v5 = (const EC_KEY *)EVP_PKEY_get0_EC_KEY((uint64_t)a2);
    LOWORD(v11) = -21846;
    int v6 = EC_KEY_get0_group(v5);
    curve_name = (unsigned __int16 *)EC_GROUP_get_curve_name(v6);
    if (bssl::ssl_nid_to_group_id((bssl *)&v11, curve_name)
      && bssl::tls1_check_group_id((bssl **)a1, (const ssl_st *)(unsigned __int16)v11)
      && EC_KEY_get_conv_form(v5) == POINT_CONVERSION_UNCOMPRESSED)
    {
      return 1LL;
    }

    int v9 = 107;
    int v10 = 569;
  }

  else
  {
    int v9 = 241;
    int v10 = 557;
  }

  ERR_put_error(16, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v10);
  return 0LL;
}

uint64_t SSL_set_chain_and_key(uint64_t a1, uint64_t *a2, unint64_t a3, evp_pkey_st *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    return bssl::cert_set_chain_and_key(*(void *)(v5 + 32), a2, a3, a4, a5);
  }
  else {
    return 0LL;
  }
}

uint64_t bssl::cert_set_chain_and_key( uint64_t a1, uint64_t *a2, unint64_t a3, evp_pkey_st *a4, uint64_t a5)
{
  if (!a3 || !((unint64_t)a4 | a5))
  {
    int v7 = 67;
    int v8 = 185;
LABEL_4:
    ERR_put_error(16, 0, v7, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_cert.cc", v8);
    return 0LL;
  }

  if (a4 && a5)
  {
    int v7 = 275;
    int v8 = 190;
    goto LABEL_4;
  }

  ssl_credential_st::ClearCertAndKey(*(ssl_credential_st **)(a1 + 24));
  if (!SSL_CREDENTIAL_set1_cert_chain(*(ssl_credential_st **)(a1 + 24), a2, a3)) {
    return 0LL;
  }
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 40LL))(a1);
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 32LL))(a1);
  uint64_t v14 = *(void *)(a1 + 24);
  if (a4) {
    return SSL_CREDENTIAL_set1_private_key(v14, a4, v13);
  }
  else {
    return SSL_CREDENTIAL_set_private_key_method(v14, a5);
  }
}

void SSL_certs_clear(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 32);
    (*(void (**)(uint64_t))(*(void *)(v2 + 32) + 8LL))(v2);
    *(void *)uint64_t v2 = 0LL;
    bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::Reset(v2 + 8, 0LL, 0LL);
    ssl_credential_st::ClearCertAndKey(*(ssl_credential_st **)(v2 + 24));
  }

uint64_t SSL_CTX_set_cert_cb(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 432);
  *(void *)(v3 + 64) = a2;
  *(void *)(v3 + 72) = a3;
  return result;
}

uint64_t SSL_get0_peer_pubkey(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 48) + 280LL);
  if (v1) {
    return *(void *)(v1 + 1512);
  }
  else {
    return 0LL;
  }
}

BOOL SSL_set_signed_cert_timestamp_list(uint64_t a1, const void *a2, unint64_t a3)
{
  if (!*(void *)(a1 + 8)) {
    return 0LL;
  }
  int v4 = (unsigned int *)CRYPTO_BUFFER_new(a2, a3, 0LL);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = SSL_CREDENTIAL_set1_signed_cert_timestamp_list( *(void *)(*(void *)(*(void *)(a1 + 8) + 32LL) + 24LL),  v4) != 0;
  CRYPTO_BUFFER_free(v5);
  return v6;
}

void sub_1875A8D28(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL SSL_CTX_set_ocsp_response(uint64_t a1, const void *a2, unint64_t a3)
{
  int v4 = (unsigned int *)CRYPTO_BUFFER_new(a2, a3, 0LL);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = SSL_CREDENTIAL_set1_ocsp_response(*(void *)(*(void *)(a1 + 432) + 24LL), v4) != 0;
  CRYPTO_BUFFER_free(v5);
  return v6;
}

void sub_1875A8DB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL SSL_set_ocsp_response(uint64_t a1, const void *a2, unint64_t a3)
{
  if (!*(void *)(a1 + 8)) {
    return 0LL;
  }
  int v4 = (unsigned int *)CRYPTO_BUFFER_new(a2, a3, 0LL);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = SSL_CREDENTIAL_set1_ocsp_response(*(void *)(*(void *)(*(void *)(a1 + 8) + 32LL) + 24LL), v4) != 0;
  CRYPTO_BUFFER_free(v5);
  return v6;
}

void sub_1875A8E44(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *bssl::New<bssl::CERT,bssl::SSL_X509_METHOD const*&>(uint64_t *a1)
{
  uint64_t result = OPENSSL_malloc(0x80uLL);
  if (result) {
    return (void *)bssl::CERT::CERT((uint64_t)result, *a1);
  }
  return result;
}

void std::unique_ptr<bssl::CERT,bssl::internal::Deleter>::reset[abi:ne180100]( bssl::CERT **a1, bssl::CERT *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    bssl::CERT::~CERT(v3);
    OPENSSL_free(v4);
  }

uint64_t CBB_finish_i2d(uint64_t a1, void **a2)
{
  if (*(_BYTE *)(a1 + 8)) {
    CBB_finish_i2d_cold_2();
  }
  if ((*(_BYTE *)(a1 + 40) & 1) == 0) {
    CBB_finish_i2d_cold_1();
  }
  size_t __n = 0xAAAAAAAAAAAAAAAALL;
  __int128 __src = (void *)0xAAAAAAAAAAAAAAAALL;
  if (!CBB_finish(a1, &__src, &__n))
  {
    CBB_cleanup(a1);
    return 0xFFFFFFFFLL;
  }

  if (__n >> 31)
  {
    OPENSSL_free(__src);
    return 0xFFFFFFFFLL;
  }

  if (a2)
  {
    uint64_t v5 = (char *)*a2;
    if (*a2)
    {
      if (__n)
      {
        memcpy(v5, __src, __n);
        size_t v6 = __n;
        uint64_t v5 = (char *)*a2;
      }

      else
      {
        size_t v6 = 0LL;
      }

      *a2 = &v5[v6];
    }

    else
    {
      *a2 = __src;
      __int128 __src = 0LL;
    }
  }

  OPENSSL_free(__src);
  return __n;
}

BOOL bssl::ssl_negotiate_version(uint64_t a1, char *a2, _WORD *a3, __int128 *a4)
{
  uint64_t v8 = 2LL;
  if (***(_BYTE ***)a1)
  {
    int v9 = (unsigned __int16 *)&bssl::kDTLSVersions;
  }

  else
  {
    uint64_t v8 = 4LL;
    int v9 = (unsigned __int16 *)&bssl::kTLSVersions;
  }

  int v10 = &v9[v8];
  do
  {
    unsigned int v11 = *v9;
    if (bssl::ssl_supports_version(a1, v11) && (v11 != 772 || (*(_BYTE *)(a1 + 1586) & 0x80) == 0))
    {
      __int128 v17 = *a4;
      while (*((void *)&v17 + 1))
      {
        unsigned __int16 v16 = -21846;
        int u16 = CBS_get_u16((unsigned __int16 **)&v17, &v16);
        BOOL v13 = u16 != 0;
        if (!u16)
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", 316);
          char v14 = 50;
          goto LABEL_16;
        }

        if (v16 == v11)
        {
          *a3 = v11;
          return v13;
        }
      }
    }

    ++v9;
  }

  while (v9 != v10);
  ERR_put_error(16, 0, 240, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_versions.cc", 328);
  BOOL v13 = 0LL;
  char v14 = 70;
LABEL_16:
  *a2 = v14;
  return v13;
}

uint64_t SSL_CTX_get_min_proto_version(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 226);
}

uint64_t SSL_CTX_get_max_proto_version(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 224);
}

const char *SSL_SESSION_get_version(uint64_t a1)
{
  uint64_t v1 = 0LL;
  int v2 = *(unsigned __int16 *)(a1 + 4);
  uint64_t result = "unknown";
  while ((unsigned __int16)bssl::kVersionNames[v1] != v2)
  {
    v1 += 8LL;
    if (v1 == 48) {
      return result;
    }
  }

  return *(const char **)&bssl::kVersionNames[v1 + 4];
}

uint64_t SSL_SESSION_get_protocol_version(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 4);
}

uint64_t bssl::SSLTranscript::UpdateForHelloRetryRequest(bssl::SSLTranscript *this)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (*(void *)this) {
    **(void **)thiunsigned int s = 0LL;
  }
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v12 = v2;
  __int128 v13 = v2;
  *(_OWORD *)int v10 = v2;
  __int128 v11 = v2;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = bssl::SSLTranscript::GetHash(this, v10, &v9);
  if ((_DWORD)result)
  {
    __int16 v6 = 254;
    char v7 = 0;
    size_t v4 = v9;
    char v8 = v9;
    uint64_t v5 = EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
    uint64_t result = EVP_DigestInit_ex((EVP_MD_CTX *)((char *)this + 8), v5, 0LL);
    if ((_DWORD)result)
    {
      uint64_t result = bssl::SSLTranscript::Update((void **)this, &v6, 4uLL);
      if ((_DWORD)result) {
        return bssl::SSLTranscript::Update((void **)this, v10, v4);
      }
    }
  }

  return result;
}

uint64_t bssl::SSLTranscript::CopyToHashContext(size_t **this, env_md_ctx_st *a2, const env_md_st *a3)
{
  __int16 v6 = (const EVP_MD_CTX *)(this + 1);
  char v7 = EVP_MD_CTX_md((const EVP_MD_CTX *)(this + 1));
  if (v7)
  {
    int v8 = EVP_MD_type(v7);
    if (v8 == EVP_MD_type(a3))
    {
      int v9 = EVP_MD_CTX_copy_ex(a2, v6);
      return v9 != 0;
    }
  }

  if (*this)
  {
    uint64_t result = EVP_DigestInit_ex(a2, a3, 0LL);
    if (!(_DWORD)result) {
      return result;
    }
    int v9 = EVP_DigestUpdate(a2, (const void *)(*this)[1], **this);
    return v9 != 0;
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_transcript.cc", 216);
  return 0LL;
}

uint64_t bssl::SSLTranscript::GetFinishedMAC( bssl::SSLTranscript *this, unsigned __int8 *a2, unint64_t *a3, const ssl_session_st *a4, int a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v18 = v10;
  __int128 v19 = v10;
  *(_OWORD *)unsigned __int16 v16 = v10;
  __int128 v17 = v10;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = bssl::SSLTranscript::GetHash(this, v16, &v15);
  if ((_DWORD)result)
  {
    if (a5) {
      __int128 v12 = "server finished";
    }
    else {
      __int128 v12 = "client finished";
    }
    __int128 v13 = (uint64_t *)EVP_MD_CTX_md((const EVP_MD_CTX *)((char *)this + 8));
    uint64_t result = bssl::tls1_prf( v13,  a2,  0xCuLL,  (char *)&a4->key_arg[3],  a4->key_arg[2],  (const unsigned __int8 *)v12,  0xFuLL,  v14,  v16,  v15,  0LL,  0LL);
    if ((_DWORD)result)
    {
      *a3 = 12LL;
      return 1LL;
    }
  }

  return result;
}

uint64_t bssl::ssl_noop_x509_check_client_CA_names()
{
  return 1LL;
}

uint64_t bssl::ssl_noop_x509_session_verify_cert_chain( bssl *this, ssl_session_st *a2, bssl::SSL_HANDSHAKE *a3, unsigned __int8 *a4)
{
  return 0LL;
}

uint64_t bssl::ssl_noop_x509_ssl_auto_chain_if_needed(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return 1LL;
}

uint64_t bssl::skip_early_data(bssl *this, ssl_st *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *((void *)this + 6);
  unsigned __int16 v5 = *(_WORD *)(v4 + 208) + (_WORD)a3;
  *(_WORD *)(v4 + 20bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v5;
  if ((unint64_t)a3 > v5)
  {
    *(_WORD *)(v4 + 20bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 16385;
LABEL_4:
    ERR_put_error(16, 0, 270, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls_record.cc", 187);
    LOBYTE(a2->version) = 10;
    return 4LL;
  }

  if (v5 > 0x4000u) {
    goto LABEL_4;
  }
  return 1LL;
}

BOOL bssl::ssl_is_key_type_supported(bssl *this)
{
  BOOL v1 = (_DWORD)this == 949;
  if ((_DWORD)this == 408) {
    BOOL v1 = 1;
  }
  return (_DWORD)this == 6 || v1;
}

BOOL bssl::ssl_has_private_key(bssl *this, const bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2 = *((void *)this + 188);
  return *(_OWORD *)(v2 + 16) != 0LL || *(_DWORD *)(v2 + 4) == 1;
}

BOOL bssl::ssl_pkey_supports_algorithm(bssl *this, EVP_PKEY *a2, evp_pkey_st *a3)
{
  int v3 = (int)a3;
  uint64_t v6 = -13LL;
  for (uint64_t i = &dword_18A070A08; *((unsigned __int16 *)i - 4) != (_DWORD)a3; i += 8)
  {
    if (__CFADD__(v6++, 1LL)) {
      return 0LL;
    }
  }

  int v9 = EVP_PKEY_id((uint64_t)a2);
  if (v9 != *(i - 1)) {
    return 0LL;
  }
  int v11 = v9;
  if ((unint64_t)(v6 + 5) >= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v12 = EVP_PKEY_size(a2);
    __int128 v13 = (const EVP_MD *)(*((uint64_t (**)(void))i + 1))();
  }

  if (bssl::ssl_protocol_version(this, v10) > 0x302)
  {
    if (v3 != 65281)
    {
      if (bssl::ssl_protocol_version(this, v14) >= 0x304)
      {
        if (v11 == 408)
        {
          __int128 v17 = (const EC_KEY *)EVP_PKEY_get0_EC_KEY((uint64_t)a2);
          __int128 v18 = EC_KEY_get0_group(v17);
          if (EC_GROUP_get_curve_name(v18) != *i) {
            return 0LL;
          }
        }

        else if (v11 == 6 && (unint64_t)(v6 + 5) < 0xFFFFFFFFFFFFFFFDLL)
        {
          return 0LL;
        }
      }

      return 1LL;
    }

    return 0LL;
  }

  return v3 == 65281 || v3 == 515;
}

uint64_t bssl::ssl_private_key_sign( uint64_t a1, void *a2, unint64_t *a3, unint64_t a4, evp_pkey_st *a5, const void *a6, size_t a7)
{
  __int128 v13 = *(bssl **)a1;
  uint64_t v14 = *(uint64_t **)(a1 + 1504);
  uint64_t v15 = *(void *)(a1 + 1576);
  __s1 = 0LL;
  size_t __n = 0LL;
  if (v15)
  {
    *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&ctx.flagunsigned int s = v16;
    __int128 v36 = v16;
    *(_OWORD *)&ctx.digest = v16;
    CBB_zero(&ctx);
    if (!CBB_init((uint64_t)&ctx, 0x40uLL)
      || !EVP_marshal_public_key((uint64_t)&ctx, v14[1])
      || !bssl::CBBFinishArray((uint64_t)&ctx, (uint64_t)&__s1))
    {
      bssl::ssl_send_alert(v13, (ssl_st *)2, 80);
      CBB_cleanup((uint64_t)&ctx);
      goto LABEL_31;
    }

    CBB_cleanup((uint64_t)&ctx);
    int v17 = *(_DWORD *)(a1 + 1584);
    if ((v17 & 0x80000) == 0 && *(unsigned __int16 *)(v15 + 72) == (_DWORD)a5)
    {
      size_t v18 = *(void *)(v15 + 88);
      if (a7 == v18
        && !memcmp(a6, *(const void **)(v15 + 80), v18)
        && __n == *(void *)(v15 + 104)
        && !memcmp(__s1, *(const void **)(v15 + 96), __n))
      {
        unint64_t v19 = *(void *)(v15 + 120);
        if (v19 - 1 < a4)
        {
          *a3 = v19;
          size_t v20 = *(void *)(v15 + 120);
          if (v20) {
            memcpy(a2, *(const void **)(v15 + 112), v20);
          }
LABEL_29:
          uint64_t v25 = 0LL;
          goto LABEL_32;
        }
      }
    }
  }

  else
  {
    int v17 = *(_DWORD *)(a1 + 1584);
  }

  if ((v17 & 0x1000000) != 0) {
    __assert_rtn("ssl_private_key_sign", "ssl_privkey.cc", 242, "!hs->can_release_private_key");
  }
  uint64_t v21 = v14[3];
  if (!v21)
  {
    int v23 = (EVP_PKEY *)v14[2];
    *a3 = a4;
    *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&ctx.digest = v24;
    *(_OWORD *)&ctx.flagunsigned int s = v24;
    EVP_MD_CTX_init(&ctx);
    if (!bssl::setup_ctx(v13, (ssl_st *)&ctx, v23, a5, 0)
      || !EVP_DigestSign((uint64_t)&ctx, (uint64_t)a2, (uint64_t)a3, a6, a7))
    {
      EVP_MD_CTX_cleanup(&ctx);
      goto LABEL_31;
    }

    EVP_MD_CTX_cleanup(&ctx);
    goto LABEL_27;
  }

  if ((v17 & 0x20000) != 0) {
    uint64_t v22 = (*(uint64_t (**)(bssl *, void *, unint64_t *, unint64_t))(v21 + 16))(v13, a2, a3, a4);
  }
  else {
    uint64_t v22 = (*(uint64_t (**)(bssl *, void *, unint64_t *, unint64_t, evp_pkey_st *, const void *, size_t))v21)( v13,  a2,  a3,  a4,  a5,  a6,  a7);
  }
  uint64_t v25 = v22;
  if ((_DWORD)v22 == 2) {
    ERR_put_error(16, 0, 287, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 253);
  }
  *(_DWORD *)(a1 + 1bssl::Array<unsigned short>::~Array((uint64_t)this + 584) = *(_DWORD *)(a1 + 1584) & 0xFFFDFFFF | (((_DWORD)v25 == 1) << 17);
  if (!(_DWORD)v25)
  {
LABEL_27:
    if (!v15 || (*(_BYTE *)(a1 + 1586) & 8) == 0) {
      goto LABEL_29;
    }
    uint64_t v27 = a2;
    *(_WORD *)(v15 + 72) = (_WORD)a5;
    OPENSSL_free(*(void **)(v15 + 96));
    size_t v28 = __n;
    *(void *)(v15 + bssl::Array<unsigned short>::~Array(v1 - 96) = __s1;
    *(void *)(v15 + bssl::Array<unsigned short>::~Array(v16 + 104) = v28;
    __s1 = 0LL;
    size_t __n = 0LL;
    int v29 = bssl::Array<unsigned char>::Init(v15 + 80, a7);
    char v30 = v29 ^ 1;
    if (!a7) {
      char v30 = 1;
    }
    if ((v30 & 1) == 0) {
      memmove(*(void **)(v15 + 80), a6, a7);
    }
    if (v29)
    {
      size_t v31 = *a3;
      int v32 = bssl::Array<unsigned char>::Init(v15 + 112, *a3);
      char v33 = v32 ^ 1;
      if (!v31) {
        char v33 = 1;
      }
      if ((v33 & 1) == 0) {
        memmove(*(void **)(v15 + 112), v27, v31);
      }
      if (v32) {
        goto LABEL_29;
      }
    }

void sub_1875A9934( _Unwind_Exception *a1, uint64_t a2, EVP_MD_CTX *ctx, uint64_t a4, uint64_t a5, uint64_t ctxa, uint64_t ctx_8, uint64_t ctx_16, uint64_t ctx_24, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t bssl::ssl_private_key_decrypt( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6 = *((_DWORD *)a1 + 396);
  if ((v6 & 0x1000000) != 0) {
    bssl::ssl_private_key_decrypt();
  }
  uint64_t v8 = a1[188];
  uint64_t v9 = *(void *)(v8 + 24);
  if (v9)
  {
    uint64_t v10 = *a1;
    if ((v6 & 0x20000) != 0) {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 16))(v10, a2, a3, a4);
    }
    else {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 8))( v10,  a2,  a3,  a4,  a5,  a6);
    }
    uint64_t v12 = v11;
    if ((_DWORD)v11 == 2) {
      ERR_put_error(16, 0, 287, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 313);
    }
    *((_DWORD *)a1 + 3bssl::Array<unsigned short>::~Array(v1 - 96) = a1[198] & 0xFFFDFFFF | (((_DWORD)v12 == 1) << 17);
  }

  else if (EVP_PKEY_get0_RSA(*(void *)(v8 + 16)))
  {
    return 2 * (RSA_decrypt() == 0);
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_privkey.cc", 322);
    return 2LL;
  }

  return v12;
}

uint64_t SSL_set_private_key_method(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(*(void *)(v2 + 32) + 24LL);
    uint64_t v4 = 184LL;
    if ((*(_BYTE *)(result + 180) & 1) == 0) {
      uint64_t v4 = 208LL;
    }
    uint64_t v5 = *(void *)(v2 + v4);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v3;
    }
    uint64_t result = SSL_CREDENTIAL_set_private_key_method(v6, a2);
    if (!(_DWORD)result) {
      abort();
    }
  }

  return result;
}

void *EVP_aead_null_sha1_tls()
{
  return &aead_null_sha1_tls;
}

void *EVP_aead_aes_128_cbc_sha1_tls()
{
  return &aead_aes_128_cbc_sha1_tls;
}

void *EVP_aead_aes_128_cbc_sha1_tls_implicit_iv()
{
  return &aead_aes_128_cbc_sha1_tls_implicit_iv;
}

void *EVP_aead_aes_128_cbc_sha256_tls()
{
  return &aead_aes_128_cbc_sha256_tls;
}

void *EVP_aead_aes_256_cbc_sha384_tls()
{
  return &aead_aes_256_cbc_sha384_tls;
}

void *EVP_aead_aes_256_cbc_sha1_tls()
{
  return &aead_aes_256_cbc_sha1_tls;
}

void *EVP_aead_aes_256_cbc_sha1_tls_implicit_iv()
{
  return &aead_aes_256_cbc_sha1_tls_implicit_iv;
}

void *EVP_aead_des_ede3_cbc_sha1_tls()
{
  return &aead_des_ede3_cbc_sha1_tls;
}

void *EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv()
{
  return &aead_des_ede3_cbc_sha1_tls_implicit_iv;
}

uint64_t aead_null_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v10 = EVP_enc_null();
  uint64_t v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

void aead_tls_cleanup(uint64_t a1)
{
}

uint64_t aead_tls_open( uint64_t a1, unsigned __int8 *a2, size_t *a3, unint64_t a4, const unsigned __int8 *a5, uint64_t a6, const unsigned __int8 *a7, unint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 36))
  {
    int v10 = 112;
    int v11 = 244;
LABEL_13:
    ERR_put_error(30, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/cipher_extra/e_tls.c", v11);
    return 0LL;
  }

  size_t v20 = (HMAC_CTX *)(a1 + 160);
  if (HMAC_size((const EVP_MD **)(a1 + 160)) > a8)
  {
    int v10 = 101;
    int v11 = 249;
    goto LABEL_13;
  }

  if (a4 < a8)
  {
    int v10 = 103;
    int v11 = 256;
    goto LABEL_13;
  }

  if (EVP_AEAD_nonce_length(*(void *)a1) != a6)
  {
    int v10 = 111;
    int v11 = 261;
    goto LABEL_13;
  }

  if (a10 != 11)
  {
    int v10 = 109;
    int v11 = 266;
    goto LABEL_13;
  }

  if (a8 >> 31)
  {
    int v10 = 117;
    int v11 = 272;
    goto LABEL_13;
  }

  if (EVP_CIPHER_CTX_mode(a1 + 8) != 2
    || *(_BYTE *)(a1 + 329)
    || (uint64_t result = EVP_DecryptInit_ex((EVP_CIPHER_CTX *)(a1 + 8), 0LL, 0LL, 0LL, a5), (_DWORD)result))
  {
    int outl = -1431655766;
    uint64_t result = EVP_DecryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), a2, &outl, a7, a8);
    if ((_DWORD)result)
    {
      uint64_t v22 = outl;
      uint64_t result = EVP_DecryptFinal_ex((EVP_CIPHER_CTX *)(a1 + 8), &a2[outl], &outl);
      if ((_DWORD)result)
      {
        if (outl + v22 != a8) {
          aead_tls_open_cold_5();
        }
        uint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
        size_t v38 = 0xAAAAAAAAAAAAAAAALL;
        if (EVP_CIPHER_CTX_mode(a1 + 8) == 2)
        {
          uint64_t v23 = EVP_CIPHER_CTX_block_size((const EVP_CIPHER_CTX *)(a1 + 8));
          uint64_t v24 = HMAC_size(&v20->md);
          if (!EVP_tls_cbc_remove_padding(&v37, &v38, (uint64_t)a2, a8, v23, v24))
          {
            int v10 = 101;
            int v11 = 308;
            goto LABEL_13;
          }

          size_t v25 = v38;
        }

        else
        {
          uint64_t v37 = -1LL;
          size_t v38 = a8;
          size_t v25 = a8;
          if (HMAC_size(&v20->md) > a8) {
            aead_tls_open_cold_4();
          }
        }

        size_t v26 = v25 - HMAC_size(&v20->md);
        *(void *)data = *(void *)a9;
        *(_DWORD *)&data[7] = *(_DWORD *)(a9 + 7);
        __int16 v46 = bswap32(v26) >> 16;
        *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v43 = v27;
        __int128 v44 = v27;
        *(_OWORD *)mssl_st d = v27;
        __int128 v42 = v27;
        size_t v36 = 0xAAAAAAAAAAAAAAAALL;
        v40[2] = v27;
        _OWORD v40[3] = v27;
        v40[0] = v27;
        v40[1] = v27;
        if (EVP_CIPHER_CTX_mode(a1 + 8) == 2 && EVP_tls_cbc_record_digest_supported(v20->md))
        {
          if (!EVP_tls_cbc_digest_record( *(const EVP_MD **)(a1 + 160),  md,  &v36,  data,  (uint64_t)a2,  v38,  a8,  a1 + 264,  *(unsigned __int8 *)(a1 + 328)))
          {
            int v10 = 101;
            int v11 = 346;
            goto LABEL_13;
          }

          size_t v28 = v36;
          if (v28 != HMAC_size(&v20->md)) {
            aead_tls_open_cold_3();
          }
          int v29 = (char *)v40;
          EVP_tls_cbc_copy_mac(v40, v36, (uint64_t)a2, v38, a8);
          uint64_t v30 = v36;
        }

        else
        {
          leuint64_t n = -1431655766;
          HMAC_Init_ex(v20, 0LL, 0, 0LL, 0LL);
          if (!v31) {
            return 0LL;
          }
          HMAC_Update(v20, data, 0xDuLL);
          if (!v32) {
            return 0LL;
          }
          HMAC_Update(v20, a2, v26);
          if (!v33) {
            return 0LL;
          }
          HMAC_Final(v20, md, &len);
          if (!v34) {
            return 0LL;
          }
          uint64_t v30 = len;
          size_t v36 = len;
          if (HMAC_size(&v20->md) != v30) {
            aead_tls_open_cold_2();
          }
          int v29 = (char *)&a2[v26];
        }

        if (!CRYPTO_memcmp(v29, (char *)md, v30) && v37)
        {
          *a3 = v26;
          return 1LL;
        }

        int v10 = 101;
        int v11 = 380;
        goto LABEL_13;
      }
    }
  }

  return result;
}

void aead_tls_seal_scatter( uint64_t a1, unsigned __int8 *a2, void *a3, unint64_t *a4, unint64_t a5, const unsigned __int8 *a6, uint64_t a7, const unsigned __int8 *a8, unint64_t a9, uint64_t a10, uint64_t a11, unsigned __int8 *data, uint64_t a13)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (!*(_DWORD *)(a1 + 36))
  {
    int v13 = 112;
    int v14 = 128;
    goto LABEL_25;
  }

  if (a9 >> 31)
  {
    int v13 = 117;
    int v14 = 134;
LABEL_25:
    ERR_put_error(30, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/cipher_extra/e_tls.c", v14);
    return;
  }

  if (aead_tls_tag_len(a1, a9, a11) > a5)
  {
    int v13 = 103;
    int v14 = 139;
    goto LABEL_25;
  }

  if (EVP_AEAD_nonce_length(*(void *)a1) != a7)
  {
    int v13 = 111;
    int v14 = 144;
    goto LABEL_25;
  }

  if (a13 != 11)
  {
    int v13 = 109;
    int v14 = 149;
    goto LABEL_25;
  }

  *(_WORD *)uint64_t v40 = bswap32(a9) >> 16;
  *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v59 = v22;
  __int128 v60 = v22;
  *(_OWORD *)mssl_st d = v22;
  __int128 v58 = v22;
  leuint64_t n = -1431655766;
  HMAC_Init_ex((HMAC_CTX *)(a1 + 160), 0LL, 0, 0LL, 0LL);
  if (v23)
  {
    HMAC_Update((HMAC_CTX *)(a1 + 160), data, 0xBuLL);
    if (v24)
    {
      HMAC_Update((HMAC_CTX *)(a1 + 160), v40, 2uLL);
      if (v25)
      {
        HMAC_Update((HMAC_CTX *)(a1 + 160), a8, a9);
        if (v26)
        {
          HMAC_Final((HMAC_CTX *)(a1 + 160), md, &len);
          if (v27)
          {
            if (EVP_CIPHER_CTX_mode(a1 + 8) != 2
              || *(_BYTE *)(a1 + 329)
              || EVP_EncryptInit_ex((EVP_CIPHER_CTX *)(a1 + 8), 0LL, 0LL, 0LL, a6))
            {
              int outl = -1431655766;
              if (EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), a2, &outl, a8, a9))
              {
                unsigned int v28 = EVP_CIPHER_CTX_block_size((const EVP_CIPHER_CTX *)(a1 + 8));
                unint64_t v29 = v28;
                unint64_t v30 = (v28 - (unint64_t)(a9 % v28)) % v28;
                if (v30)
                {
                  if (outl + v28 - v30 != a9) {
                    aead_tls_seal_scatter_cold_6();
                  }
                  *(void *)&__int128 v31 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  *(_OWORD *)out = v31;
                  __int128 v42 = v31;
                  int v37 = -1431655766;
                  if (!EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), out, &v37, md, v30)) {
                    return;
                  }
                  if (v37 != (_DWORD)v29) {
                    aead_tls_seal_scatter_cold_5();
                  }
                  memcpy(&a2[outl], out, v29 - v30);
                  memcpy(a3, &out[v29 - v30], v30);
                  int v32 = v30;
                }

                else
                {
                  int v32 = 0;
                }

                if (!EVP_EncryptUpdate( (EVP_CIPHER_CTX *)(a1 + 8),  (unsigned __int8 *)a3 + v30,  &outl,  &md[v30],  len - v32)) {
                  return;
                }
                unint64_t v33 = v30 + outl;
                *(void *)&__int128 v34 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
                __int128 v55 = v34;
                __int128 v56 = v34;
                __int128 v53 = v34;
                __int128 v54 = v34;
                __int128 v51 = v34;
                __int128 v52 = v34;
                __int128 v49 = v34;
                __int128 v50 = v34;
                __int128 v47 = v34;
                __int128 v48 = v34;
                __int128 v45 = v34;
                __int128 v46 = v34;
                __int128 v43 = v34;
                __int128 v44 = v34;
                *(_OWORD *)out = v34;
                __int128 v42 = v34;
                int v35 = (len + a9) % v29;
                int v36 = v29 - v35;
                if ((_DWORD)v29 != v35) {
                  __memset_chk();
                }
                if (EVP_EncryptUpdate((EVP_CIPHER_CTX *)(a1 + 8), (unsigned __int8 *)a3 + v33, &outl, out, v36))
                {
                  v33 += outl;
LABEL_36:
                  if (EVP_EncryptFinal_ex((EVP_CIPHER_CTX *)(a1 + 8), (unsigned __int8 *)a3 + v33, &outl))
                  {
                    if (outl) {
                      aead_tls_seal_scatter_cold_3();
                    }
                    if (v33 != aead_tls_tag_len(a1, a9, a11)) {
                      aead_tls_seal_scatter_cold_2();
                    }
                    *a4 = v33;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

unint64_t aead_tls_tag_len(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    aead_tls_tag_len_cold_2();
  }
  uint64_t v4 = (const EVP_CIPHER_CTX *)(a1 + 8);
  uint64_t v5 = HMAC_size((const EVP_MD **)(a1 + 160));
  if (EVP_CIPHER_CTX_mode((uint64_t)v4) == 2)
  {
    unsigned int v6 = EVP_CIPHER_CTX_block_size(v4);
    if (!v6 || ((v6 - 1) & v6) != 0) {
      aead_tls_tag_len_cold_1();
    }
    return v6 + (v5 + a2) / (unint64_t)v6 * v6 - a2;
  }

  return v5;
}

uint64_t aead_tls_init( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5, const EVP_CIPHER *a6, EVP_MD *md, int a8)
{
  if (a4 && EVP_MD_size(md) != a4)
  {
    int v18 = 122;
    int v19 = 63;
    goto LABEL_8;
  }

  if (EVP_AEAD_key_length(*(unsigned __int8 **)a1) != a3)
  {
    int v18 = 102;
    int v19 = 68;
LABEL_8:
    ERR_put_error(30, 0, v18, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/cipher_extra/e_tls.c", v19);
    return 0LL;
  }

  size_t v15 = EVP_MD_size(md);
  size_t v16 = v15 + EVP_CIPHER_key_length(a6);
  if (a8) {
    uint64_t v17 = EVP_CIPHER_iv_length(a6);
  }
  else {
    uint64_t v17 = 0LL;
  }
  if (v17 + v16 != a3) {
    aead_tls_init_cold_2();
  }
  EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)(a1 + 8));
  HMAC_CTX_init((HMAC_CTX *)(a1 + 160));
  if (v15 >= 0x41) {
    aead_tls_init_cold_1();
  }
  if (v15) {
    memcpy((void *)(a1 + 264), a2, v15);
  }
  *(_BYTE *)(a1 + 32bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v15;
  *(_BYTE *)(a1 + 329) = a8;
  if (a8) {
    size_t v20 = (const unsigned __int8 *)&a2[v16];
  }
  else {
    size_t v20 = 0LL;
  }
  if (EVP_CipherInit_ex((EVP_CIPHER_CTX *)(a1 + 8), a6, 0LL, (const unsigned __int8 *)&a2[v15], v20, a5 == 1))
  {
    HMAC_Init_ex((HMAC_CTX *)(a1 + 160), a2, v15, md, 0LL);
    if (v21)
    {
      EVP_CIPHER_CTX_set_padding((EVP_CIPHER_CTX *)(a1 + 8), 0);
      return 1LL;
    }
  }

  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)(a1 + 8));
  HMAC_CTX_cleanup((HMAC_CTX *)(a1 + 160));
  return 0LL;
}

uint64_t aead_aes_128_cbc_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_aes_128_cbc();
  int v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_128_cbc_sha1_tls_implicit_iv_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_aes_128_cbc();
  int v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

uint64_t aead_tls_get_iv(uint64_t a1, void *a2, void *a3)
{
  unsigned int v6 = EVP_CIPHER_CTX_iv_length((const EVP_CIPHER_CTX *)(a1 + 8));
  if (v6 < 2) {
    return 0LL;
  }
  *a2 = a1 + 60;
  *a3 = v6;
  return 1LL;
}

uint64_t aead_aes_128_cbc_sha256_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_aes_128_cbc();
  int v11 = (EVP_MD *)EVP_sha256();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_256_cbc_sha384_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_aes_256_cbc();
  int v11 = (EVP_MD *)EVP_sha384();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_256_cbc_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_aes_256_cbc();
  int v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_aes_256_cbc_sha1_tls_implicit_iv_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_aes_256_cbc();
  int v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

uint64_t aead_des_ede3_cbc_sha1_tls_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_des_ede3_cbc();
  int v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 0);
}

uint64_t aead_des_ede3_cbc_sha1_tls_implicit_iv_init(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v10 = EVP_des_ede3_cbc();
  int v11 = (EVP_MD *)EVP_sha1();
  return aead_tls_init(a1, a2, a3, a4, a5, v10, v11, 1);
}

int BN_mod_exp_mont( BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (!BN_is_odd((uint64_t)m))
  {
    int v12 = 104;
    int v13 = 590;
    goto LABEL_8;
  }

  if (m->neg)
  {
    int v12 = 109;
    int v13 = 594;
LABEL_8:
    ERR_put_error( 3,  0,  v12,  "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/exponentiation.c",  v13);
    LODWORD(v14) = 0;
    return (int)v14;
  }

  if (a->neg || (BN_ucmp(a, m) & 0x80000000) == 0)
  {
    int v12 = 107;
    int v13 = 599;
    goto LABEL_8;
  }

  int v16 = BN_num_bits(p);
  if (v16)
  {
    unsigned int v17 = v16;
    unint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v59 = v18;
    __int128 v58 = v18;
    __int128 v57 = v18;
    __int128 v56 = v18;
    __int128 v55 = v18;
    __int128 v54 = v18;
    __int128 v53 = v18;
    __int128 v52 = v18;
    __int128 v51 = v18;
    __int128 v50 = v18;
    __int128 v49 = v18;
    __int128 v48 = v18;
    __int128 v47 = v18;
    __int128 v46 = v18;
    __int128 v45 = v18;
    BN_CTX_start(ctx);
    int v19 = BN_CTX_get(ctx);
    size_t v20 = BN_CTX_get(ctx);
    int v21 = 0LL;
    LODWORD(v14) = 0;
    __int128 v44 = v20;
    if (!v19 || !v20) {
      goto LABEL_67;
    }
    if (m_ctx)
    {
      __int128 v22 = 0LL;
    }

    else
    {
      int v21 = BN_MONT_CTX_new_consttime(m, ctx);
      m_EVP_MD_CTX ctx = v21;
      __int128 v22 = v21;
      if (!v21)
      {
        LODWORD(v14) = 0;
LABEL_67:
        BN_MONT_CTX_free(v21);
        BN_CTX_end(ctx);
        return (int)v14;
      }
    }

    mont = v22;
    b = v19;
    if (v17 <= 0x29F)
    {
      if (v17 <= 0xEF)
      {
        if (v17 <= 0x4F)
        {
          if (v17 <= 0x17) {
            unsigned int v23 = 1;
          }
          else {
            unsigned int v23 = 3;
          }
        }

        else
        {
          unsigned int v23 = 4;
        }
      }

      else
      {
        unsigned int v23 = 5;
      }
    }

    else
    {
      unsigned int v23 = 6;
    }

    if (BN_to_montgomery(v20, a, (BIGNUM *)m_ctx, ctx))
    {
      unsigned int v41 = v23;
      unsigned int v39 = v23 - 2;
      if (v23 < 2)
      {
LABEL_37:
        char v28 = 0;
        int v29 = v17 - 1;
        unsigned int v30 = v41;
        __int128 v31 = b;
        while (1)
        {
          while (!BN_is_bit_set(p, v29))
          {
            if ((v28 & 1) != 0)
            {
              if (!BN_mod_mul_montgomery(v31, v31, v31, m_ctx, ctx)) {
                goto LABEL_65;
              }
              if (!v29) {
                goto LABEL_68;
              }
            }

            else if (!v29)
            {
              BN_mod_exp_mont_cold_3();
            }

            --v29;
          }

          char v40 = v28;
          int v32 = 0;
          int v33 = 1;
          if (v30 >= 2)
          {
            unsigned int v34 = v29 - 1;
            if (v29 >= 1)
            {
              int v32 = 0;
              int v35 = v39;
              if (v34 < v39) {
                int v35 = v29 - 1;
              }
              int v36 = -v35;
              int v37 = 1;
              do
              {
                if (BN_is_bit_set(p, v34))
                {
                  int v33 = (v33 << (v37 - v32)) | 1;
                  int v32 = v37;
                }

                ++v37;
                --v34;
              }

              while (v36 + v37 != 2);
            }
          }

          __int128 v31 = b;
LABEL_57:
          if ((v33 & 1) == 0) {
            BN_mod_exp_mont_cold_1();
          }
          unsigned int v30 = v41;
          if (v33 >= 1 << v41) {
            BN_mod_exp_mont_cold_2();
          }
          if ((v40 & 1) != 0)
          {
            if (!BN_mod_mul_montgomery(b, b, *(&v44 + (v33 >> 1)), m_ctx, ctx)) {
              goto LABEL_65;
            }
          }

          else if (!BN_copy(b, *(&v44 + (v33 >> 1))))
          {
            goto LABEL_65;
          }

          if (v29 == v32)
          {
LABEL_68:
            LODWORD(v14) = BN_from_montgomery(r, v31, m_ctx, ctx) != 0;
            goto LABEL_66;
          }

          v29 += ~v32;
          char v28 = 1;
        }

        int v38 = v32 + 1;
        while (BN_mod_mul_montgomery(b, b, b, m_ctx, ctx))
        {
          if (!--v38) {
            goto LABEL_57;
          }
        }
      }

      else
      {
        int v24 = BN_CTX_get(ctx);
        int v14 = v24;
        if (!v24)
        {
LABEL_66:
          int v21 = mont;
          goto LABEL_67;
        }

        if (BN_mod_mul_montgomery(v24, v20, v20, m_ctx, ctx))
        {
          uint64_t v25 = 0LL;
          while (1)
          {
            int v26 = BN_CTX_get(ctx);
            *(&v44 + v25 + 1) = v26;
            if (!v26 || !BN_mod_mul_montgomery(v26, *(&v44 + v25), v14, m_ctx, ctx)) {
              break;
            }
          }
        }
      }
    }

LABEL_65:
    LODWORD(v14) = 0;
    goto LABEL_66;
  }

  if (BN_abs_is_word((unsigned int *)m, 1LL))
  {
    BN_zero((uint64_t)r);
    LODWORD(v14) = 1;
    return (int)v14;
  }

  return BN_one((uint64_t)r);
}

            int v11 = 0LL;
            goto LABEL_49;
          }

          *a2 = 47;
          int v26 = 209;
          int v27 = 320;
        }

        else
        {
          int v26 = 203;
          int v27 = 137;
        }

        break;
      }

void bn_mod_exp_mont_small( unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  __b[144] = *MEMORY[0x1895F89C0];
  unint64_t num = a3;
  unint64_t v11 = a5 - 1;
  uint64_t v12 = a5 << 6;
  do
  {
    if (v11 == -1LL)
    {
      bn_from_montgomery_small(a1, a3, *v7, a3, (uint64_t)v7);
      return;
    }

    unint64_t v13 = *(void *)(a4 + 8 * v11--);
    v12 -= 64LL;
  }

  while (!v13);
  unsigned int v14 = BN_num_bits_word(v13);
  unint64_t v15 = v12 + v14;
  if (!v15) {
    bn_mod_exp_mont_small_cold_2();
  }
  if (v15 <= 0x29F)
  {
    if (v15 <= 0xEF)
    {
      if (v15 <= 0x17) {
        int v17 = 1;
      }
      else {
        int v17 = 3;
      }
      if (v15 <= 0x4F) {
        unsigned int v16 = v17;
      }
      else {
        unsigned int v16 = 4;
      }
    }

    else
    {
      unsigned int v16 = 5;
    }
  }

  else
  {
    unsigned int v16 = 6;
  }

  uint64_t v18 = v14;
  if (v16 >= 5) {
    unsigned int v19 = 5;
  }
  else {
    unsigned int v19 = v16;
  }
  memset(__b, 170, 0x480uLL);
  if (num) {
    __memcpy_chk();
  }
  unint64_t v20 = v11 + 2;
  unint64_t v37 = v19 - 2;
  unsigned int v39 = v19;
  if (v19 >= 2)
  {
    unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v41[2] = v21;
    _OWORD v41[3] = v21;
    v41[0] = v21;
    v41[1] = v21;
    bn_mod_mul_montgomery_small((unint64_t *)v41, __b, __b, num, (uint64_t)v7);
    unsigned int v22 = 2;
    do
      bn_mod_mul_montgomery_small(&__b[9 * v22 - 9], &__b[9 * v22 - 18], (unint64_t *)v41, num, (uint64_t)v7);
    while (!(v22++ >> (v19 - 1)));
  }

  char v24 = 0;
  uint64_t v25 = v18 + v12 - 1;
  int v38 = v7;
  do
  {
    for (unint64_t i = v25; !bn_is_bit_set_words(a4, v20, i); --i)
    {
      if ((v24 & 1) != 0)
      {
        bn_mod_mul_montgomery_small(a1, a1, a1, num, (uint64_t)v7);
        if (!i) {
          goto LABEL_59;
        }
      }

      else if (!i)
      {
        bn_mod_exp_mont_small_cold_5();
      }
    }

    if (v19 < 2 || !i)
    {
      int v28 = 0;
      unsigned int v32 = 1;
      unint64_t v35 = num;
      if ((v24 & 1) == 0) {
        goto LABEL_56;
      }
LABEL_47:
      for (int j = -1; j != v28; ++j)
        bn_mod_mul_montgomery_small(a1, a1, a1, v35, (uint64_t)v7);
LABEL_51:
      unsigned int v19 = v39;
      goto LABEL_52;
    }

    uint64_t v27 = 0LL;
    int v28 = 0;
    unint64_t v29 = i - 1;
    unint64_t v30 = v37;
    if (i - 1 < v37) {
      unint64_t v30 = i - 1;
    }
    unint64_t v31 = v30 + 1;
    unsigned int v32 = 1;
    do
    {
      is_bit_set_wordunsigned int s = bn_is_bit_set_words(a4, v20, v29);
      uint64_t v34 = v27 + 1;
      if (is_bit_set_words)
      {
        unsigned int v32 = (v32 << (v27 - v28 + 1)) | 1;
        int v28 = v27 + 1;
      }

      --v29;
      ++v27;
    }

    while (v31 != v34);
    char v7 = v38;
    if ((v24 & 1) == 0)
    {
      unint64_t v35 = num;
      goto LABEL_51;
    }

    unint64_t v35 = num;
    unsigned int v19 = v39;
    if (v28 != -1) {
      goto LABEL_47;
    }
LABEL_52:
    if ((v32 & 1) == 0) {
      bn_mod_exp_mont_small_cold_3();
    }
    if (v32 >> v19) {
      bn_mod_exp_mont_small_cold_4();
    }
    if ((v24 & 1) != 0)
    {
      bn_mod_mul_montgomery_small(a1, a1, &__b[9 * (v32 >> 1)], v35, (uint64_t)v7);
      goto LABEL_58;
    }

LABEL_56:
    if (v35) {
      memcpy(a1, &__b[9 * (v32 >> 1)], 8 * num);
    }
LABEL_58:
    uint64_t v25 = i - (v28 + 1);
    char v24 = 1;
  }

  while (i != v28);
LABEL_59:
  OPENSSL_cleanse(__b, 0x480uLL);
}

              goto LABEL_57;
            }
          }

          if (!v29) {
            goto LABEL_57;
          }
          goto LABEL_56;
        }

void bn_mod_inverse0_prime_mont_small(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a3 > 9 || *(_DWORD *)(a4 + 32) != a3) {
    abort();
  }
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v14[2] = v9;
  _OWORD v14[3] = v9;
  v14[0] = v9;
  v14[1] = v9;
  if (a3 && (__memcpy_chk(), unint64_t v8 = *(void *)&v14[0], *(void *)&v14[0] < 2uLL))
  {
    *(void *)&v14[0] -= 2LL;
    unint64_t v10 = a3 - 2;
    if (a3 >= 2)
    {
      unint64_t v11 = (void *)v14 + 1;
      do
      {
        unint64_t v12 = v10;
        if ((*v11++)-- != 0LL) {
          break;
        }
        --v10;
      }

      while (v12);
    }
  }

  else
  {
    *(void *)&v14[0] = v8 - 2;
  }

  bn_mod_exp_mont_small(a1, a2, a3, (uint64_t)v14, a3, a4);
}

int BN_mod_exp_mont_consttime( BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
  if (!BN_is_odd((uint64_t)m))
  {
    int v12 = 104;
    int v13 = 894;
    goto LABEL_8;
  }

  if (m->neg)
  {
    int v12 = 109;
    int v13 = 898;
LABEL_8:
    ERR_put_error( 3,  0,  v12,  "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/exponentiation.c",  v13);
    return 0;
  }

  if (a->neg || BN_ucmp(a, m) >= 0)
  {
    int v12 = 107;
    int v13 = 904;
    goto LABEL_8;
  }

  int top = p->top;
  if (top)
  {
    if (in_mont)
    {
      int v17 = 0LL;
    }

    else
    {
      uint64_t v18 = BN_MONT_CTX_new_consttime(m, ctx);
      in_mont = v18;
      int v17 = v18;
      if (!v18)
      {
        BOOL v14 = 0;
        uint64_t v25 = 0LL;
        leuint64_t n = 0LL;
        int v26 = 0LL;
        goto LABEL_64;
      }
    }

    unint64_t v37 = v17;
    int d = (int)in_mont->N.d;
    if (top == 1) {
      int v20 = 3;
    }
    else {
      int v20 = 1;
    }
    if (top <= 1) {
      int v21 = v20;
    }
    else {
      int v21 = 4;
    }
    if (top <= 4) {
      int v22 = v21;
    }
    else {
      int v22 = 5;
    }
    if (top > 14) {
      int v22 = 6;
    }
    signed int v36 = v22;
    int v23 = 1 << v22;
    leuint64_t n = 8 * d * (uint64_t)((1 << v22) + 2);
    char v24 = OPENSSL_malloc(len + 64);
    if (!v24)
    {
      BOOL v14 = 0;
      uint64_t v25 = 0LL;
      int v26 = 0LL;
      goto LABEL_58;
    }

    unsigned int v34 = v23;
    unint64_t v35 = v24;
    uint64_t v38 = (uint64_t)v24 + (-(int)v24 & 0x3FLL);
    if ((v38 & 0x3F) != 0) {
      BN_mod_exp_mont_consttime_cold_4();
    }
    if (d) {
      bzero((void *)v38, len);
    }
    r.int d = (unint64_t *)(v38 + 8LL * (d << v36));
    b.int d = &r.d[d];
    b.int top = 0;
    b.dmax = d;
    r.int top = 0;
    r.dmax = d;
    *(void *)&b.neg = 0x200000000LL;
    *(void *)&r.neg = 0x200000000LL;
    if (!bn_one_to_montgomery(&r, (BIGNUM *)in_mont, ctx))
    {
      BOOL v14 = 0;
      uint64_t v18 = v37;
      int v26 = (void *)v38;
      uint64_t v25 = v35;
      goto LABEL_64;
    }

    uint64_t v25 = v35;
    if (bn_resize_words((uint64_t)&r, d))
    {
      if (a->neg) {
        BN_mod_exp_mont_consttime_cold_3();
      }
      if (BN_ucmp(a, m) >= 0) {
        BN_mod_exp_mont_consttime_cold_2();
      }
      if (BN_to_montgomery(&b, a, (BIGNUM *)in_mont, ctx)
        && bn_resize_words((uint64_t)&b, d))
      {
        int v26 = (void *)v38;
        copy_to_prebuf((uint64_t)&r, d, v38, 0);
        copy_to_prebuf((uint64_t)&b, d, v38, 1);
        if (v36 >= 2)
        {
          if (BN_mod_mul_montgomery(&r, &b, &b, in_mont, ctx))
          {
            copy_to_prebuf((uint64_t)&r, d, v38, 2);
            if (v34 <= 4) {
              int v27 = 4;
            }
            else {
              int v27 = v34;
            }
            int v28 = 3;
            while (BN_mod_mul_montgomery(&r, &b, &r, in_mont, ctx))
            {
              copy_to_prebuf((uint64_t)&r, d, v38, v28++);
              if (v27 == v28) {
                goto LABEL_46;
              }
            }
          }

          goto LABEL_56;
        }

uint64_t copy_to_prebuf(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t result = bn_copy_words((void *)(a3 + 8LL * a4 * a2), a2, a1);
  if (!(_DWORD)result) {
    copy_to_prebuf_cold_1();
  }
  return result;
}

uint64_t copy_from_prebuf(uint64_t a1, int a2, uint64_t a3, int a4, char a5)
{
  uint64_t v10 = a2;
  uint64_t result = bn_wexpand((void **)a1, a2);
  if ((_DWORD)result)
  {
    size_t v12 = 8 * v10;
    if (a2) {
      bzero(*(void **)a1, v12);
    }
    unsigned int v13 = 0;
    do
    {
      if (a2 >= 1)
      {
        uint64_t v14 = 0LL;
        unint64_t v15 = *(void **)a1;
        do
        {
          v15[v14] |= *(void *)(a3 + v14 * 8) & ((((int)(v13 ^ a4) - 1LL) & ~(uint64_t)(int)(v13 ^ a4)) >> 63);
          ++v14;
        }

        while (a2 != v14);
      }

      ++v13;
      a3 += v12;
    }

    while (!(v13 >> a5));
    *(_DWORD *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = a2;
    return 1LL;
  }

  return result;
}

int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int neg = a->neg;
  if (neg == b->neg)
  {
    int result = bn_uadd_consttime((uint64_t)r, (uint64_t)a, (uint64_t)b);
    if (!result) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  BOOL v6 = neg == 0;
  if (neg) {
    char v7 = b;
  }
  else {
    char v7 = a;
  }
  if (v6) {
    unint64_t v8 = b;
  }
  else {
    unint64_t v8 = a;
  }
  if (BN_ucmp(v7, v8) < 0)
  {
    int result = bn_usub_consttime((uint64_t)r, (uint64_t)v8, (uint64_t)v7);
    if (!result) {
      return result;
    }
    int neg = 1;
    goto LABEL_15;
  }

  int v9 = bn_usub_consttime((uint64_t)r, (uint64_t)v7, (uint64_t)v8);
  int neg = 0;
  int result = 0;
  if (v9)
  {
LABEL_15:
    bn_set_minimal_width((uint64_t)r);
    int result = 1;
LABEL_16:
    r->int neg = neg;
  }

  return result;
}

int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int result = bn_usub_consttime((uint64_t)r, (uint64_t)a, (uint64_t)b);
  if (result)
  {
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }

  return result;
}

uint64_t bn_uadd_consttime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a2 + 8);
  int v5 = *(_DWORD *)(a3 + 8);
  if (v4 >= v5) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a3;
  }
  if (v4 >= v5) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a2;
  }
  uint64_t v8 = *(int *)(v6 + 8);
  uint64_t v9 = *(int *)(v7 + 8);
  uint64_t result = bn_wexpand((void **)a1, v8 + 1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v8 + 1;
    unint64_t v11 = bn_add_words(*(unint64_t **)a1, *(const unint64_t **)v6, *(const unint64_t **)v7, v9);
    if ((int)v9 >= (int)v8)
    {
      uint64_t v16 = *(void **)a1;
    }

    else
    {
      uint64_t v12 = 8 * v9;
      int v13 = v8 - v9;
      do
      {
        if (v11 >= 2) {
          bn_uadd_consttime_cold_1();
        }
        uint64_t v14 = *(void *)(*(void *)v6 + v12);
        uint64_t v15 = v14 + v11;
        unint64_t v11 = __CFADD__(v14, v11);
        uint64_t v16 = *(void **)a1;
        *(void *)(*(void *)a1 + v12) = v15;
        v12 += 8LL;
        --v13;
      }

      while (v13);
    }

    v16[v8] = v11;
    return 1LL;
  }

  return result;
}

int BN_add_word(BIGNUM *a, unint64_t w)
{
  if (w)
  {
    unint64_t v2 = w;
    if (a->neg)
    {
      a->int neg = 0;
      LODWORD(v2) = BN_sub_word(a, v2);
      return v2;
    }

    uint64_t v5 = 0LL;
    uint64_t top = a->top;
    while ((top & ~((int)top >> 31)) != v5)
    {
      unint64_t v7 = a->d[v5];
      BOOL v8 = __CFADD__(v7, v2);
      a->d[v5++] = v7 + v2;
      unint64_t v2 = 1LL;
      if (!v8) {
        return v2;
      }
    }

    if ((top & 0x80000000) == 0)
    {
      if (!bn_wexpand(&a->d, top + 1))
      {
        LODWORD(v2) = 0;
        return v2;
      }

      ++a->top;
      a->d[top] = v2;
    }
  }

  LODWORD(v2) = 1;
  return v2;
}

int BN_sub_word(BIGNUM *a, unint64_t w)
{
  if (!w) {
    return 1;
  }
  unint64_t v2 = w;
  if (BN_is_zero((uint64_t)a))
  {
    int v4 = BN_set_word(a, v2);
    if (v4) {
      BN_set_negative(a, 1);
    }
    return v4;
  }

  if (a->neg)
  {
    a->int neg = 0;
    int result = BN_add_word(a, v2);
    a->int neg = 1;
    return result;
  }

  int v6 = bn_minimal_width((uint64_t)a);
  int d = a->d;
  unint64_t v8 = *a->d;
  if (v6 != 1 || v8 >= v2)
  {
    int v9 = 0;
    uint64_t v10 = v8 - v2;
    if (v8 < v2)
    {
      unint64_t v2 = 1LL;
      do
      {
        unint64_t *d = v10;
        unint64_t v11 = d[1];
        ++d;
        unint64_t v8 = v11;
        ++v9;
        uint64_t v10 = -1LL;
      }

      while (!v11);
    }

    unint64_t v12 = v8 - v2;
    unint64_t *d = v12;
    if (!v12 && v9 == a->top - 1) {
      a->uint64_t top = v9;
    }
    return 1;
  }

  unint64_t *d = v2 - v8;
  int v4 = 1;
  a->int neg = 1;
  return v4;
}

int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  uint64_t v3 = b;
  int neg = b->neg;
  if (a->neg)
  {
    if (neg)
    {
      int v6 = a;
      goto LABEL_10;
    }

    int v7 = 1;
LABEL_7:
    int result = bn_uadd_consttime((uint64_t)r, (uint64_t)a, (uint64_t)b);
    if (!result) {
      return result;
    }
    goto LABEL_15;
  }

  if (neg)
  {
    int v7 = 0;
    goto LABEL_7;
  }

  int v6 = b;
  uint64_t v3 = a;
LABEL_10:
  if (BN_ucmp(v3, v6) < 0)
  {
    int result = bn_usub_consttime((uint64_t)r, (uint64_t)v6, (uint64_t)v3);
    if (!result) {
      return result;
    }
    int v7 = 1;
    goto LABEL_15;
  }

  int v9 = bn_usub_consttime((uint64_t)r, (uint64_t)v3, (uint64_t)v6);
  int v7 = 0;
  int result = 0;
  if (v9)
  {
LABEL_15:
    bn_set_minimal_width((uint64_t)r);
    r->int neg = v7;
    return 1;
  }

  return result;
}

uint64_t bn_usub_consttime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  int v7 = *(_DWORD *)(a2 + 8);
  if (v6 > v7)
  {
    if (!bn_fits_in_words(a3, v7))
    {
      int v16 = 229;
      goto LABEL_16;
    }

    int v7 = *(_DWORD *)(a2 + 8);
    int v6 = v7;
  }

  uint64_t result = bn_wexpand((void **)a1, v7);
  if (!(_DWORD)result) {
    return result;
  }
  unint64_t v9 = bn_sub_words(*(unint64_t **)a1, *(const unint64_t **)a2, *(const unint64_t **)a3, v6);
  int v10 = *(_DWORD *)(a2 + 8);
  int v11 = v10 - v6;
  if (v10 > v6)
  {
    uint64_t v12 = 8LL * v6;
    do
    {
      if (v9 >= 2) {
        bn_usub_consttime_cold_1();
      }
      unint64_t v13 = *(void *)(*(void *)a2 + v12);
      BOOL v14 = v13 >= v9;
      unint64_t v15 = v13 - v9;
      unint64_t v9 = !v14;
      *(void *)(*(void *)a1 + v12) = v15;
      v12 += 8LL;
      --v11;
    }

    while (v11);
  }

  if (!v9)
  {
    *(_DWORD *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v10;
    *(_DWORD *)(a1 + 16) = 0;
    return 1LL;
  }

  int v16 = 245;
LABEL_16:
  ERR_put_error(3, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/add.c", v16);
  return 0LL;
}

BIGNUM *__cdecl BN_mod_sqrt(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  if (!BN_is_odd((uint64_t)n) || BN_abs_is_word((unsigned int *)n, 1LL))
  {
    if (!BN_abs_is_word((unsigned int *)n, 2LL))
    {
      ERR_put_error(3, 0, 114, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/sqrt.c", 88);
      return 0LL;
    }

    unint64_t v8 = ret;
    if (ret || (unint64_t v8 = BN_new()) != 0LL)
    {
      int is_bit_set = BN_is_bit_set(a, 0);
      goto LABEL_13;
    }

LABEL_62:
      if (v8 != ret) {
        BN_clear_free(v8);
      }
      goto LABEL_64;
    }

    if (!BN_copy(v13, n)) {
      goto LABEL_62;
    }
    aa = v15;
    v13->int neg = 0;
    unint64_t v22 = 2LL;
    while (1)
    {
      if (v22 <= 0x15) {
        goto LABEL_52;
      }
      int v23 = BN_num_bits(n);
      if (!BN_pseudo_rand(v17, v23, 0, 0)) {
        goto LABEL_62;
      }
      if ((BN_ucmp(v17, n) & 0x80000000) == 0)
      {
        char v24 = BN_add;
        if (!n->neg) {
          char v24 = BN_sub;
        }
      }

      if (BN_is_zero((uint64_t)v17))
      {
LABEL_52:
        if (!BN_set_word(v17, v22)) {
          goto LABEL_62;
        }
      }

      int v25 = bn_jacobi(v17, v13, ctx);
      if (v25 < -1) {
        goto LABEL_62;
      }
      if (v25 != 1) {
        break;
      }
      if (++v22 == 82) {
        goto LABEL_60;
      }
    }

    if (v25 != -1)
    {
      if (!v25)
      {
        int v19 = 114;
        int v20 = 257;
        goto LABEL_61;
      }

LABEL_97:
            if (!BN_mod_mul(v17, v14, v14, n, ctx) || !BN_mod_mul(aa, aa, v14, n, ctx)) {
              goto LABEL_62;
            }
            int v26 = r;
            int v27 = r;
          }
        }

        goto LABEL_62;
      }
    }

    else
    {
      if (!BN_mod_exp_mont(aa, v11, v14, n, ctx, 0LL)) {
        goto LABEL_62;
      }
    }

    BN_zero((uint64_t)v8);
    goto LABEL_65;
  }

  unint64_t v8 = ret;
  if (!ret)
  {
    unint64_t v8 = BN_new();
    if (!v8) {
      goto LABEL_14;
    }
  }

  int is_bit_set = BN_is_one((unsigned int *)a);
LABEL_13:
  if (!BN_set_word(v8, is_bit_set)) {
    goto LABEL_14;
  }
  return v8;
}

  *a6 = v11;
  *a7 = v12;
  return result;
}

int SHA256_Init(SHA256_CTX *c)
{
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->data[14] = 0u;
  *(_OWORD *)&c->data[2] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)c->h = xmmword_187604310;
  *(_OWORD *)&c->h[4] = xmmword_187604320;
  *(_OWORD *)&c->Nl = 0u;
  c->unsigned int md_len = 32;
  return 1;
}

int SHA256_Final(unsigned __int8 *md, SHA256_CTX *c)
{
  return sha256_final_impl(md, c->md_len, (uint64_t)c);
}

void SHA256_Transform(SHA256_CTX *c, const unsigned __int8 *data)
{
}

unint64_t bn_mul_add_words( unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  if (!*(void *)&num) {
    return 0LL;
  }
  if (*(void *)&num < 4uLL)
  {
    uint64_t v4 = 0LL;
    do
    {
LABEL_25:
      unint64_t v27 = *ap++;
      unint64_t v28 = (v27 * (unsigned __int128)w) >> 64;
      unint64_t v29 = v27 * w;
      BOOL v6 = __CFADD__(*rp, v4);
      unint64_t v30 = *rp + v4;
      uint64_t v31 = v6;
      unsigned __int128 v32 = __PAIR128__(v31, v30) + __PAIR128__(v28, v29);
      uint64_t v4 = (__PAIR128__(v31, v30) + __PAIR128__(v28, v29)) >> 64;
      *rp++ = v32;
      --*(void *)&num;
    }

    while (*(void *)&num);
    return v4;
  }

  uint64_t v4 = 0LL;
  do
  {
    unint64_t v5 = rp[1];
    BOOL v6 = __CFADD__(*rp, v4);
    unint64_t v7 = *rp + v4;
    uint64_t v8 = v6;
    unsigned __int128 v9 = __PAIR128__(v8, v7) + *ap * (unsigned __int128)w;
    *rp = v9;
    unint64_t v10 = ap[1];
    uint64_t v11 = (v10 * (unsigned __int128)w) >> 64;
    unint64_t v12 = v10 * w;
    BOOL v6 = __CFADD__(v12, v5);
    unint64_t v13 = v12 + v5;
    if (v6) {
      ++v11;
    }
    BOOL v6 = __CFADD__(v13, *((void *)&v9 + 1));
    unint64_t v14 = v13 + *((void *)&v9 + 1);
    if (v6) {
      uint64_t v15 = v11 + 1;
    }
    else {
      uint64_t v15 = v11;
    }
    rp[1] = v14;
    unint64_t v16 = ap[2];
    unint64_t v17 = rp[2];
    unint64_t v18 = rp[3];
    BOOL v6 = __CFADD__(v16 * w, v17);
    unint64_t v19 = v16 * w + v17;
    uint64_t v20 = (v16 * (unsigned __int128)w) >> 64;
    if (v6) {
      ++v20;
    }
    BOOL v6 = __CFADD__(v19, v15);
    unint64_t v21 = v19 + v15;
    if (v6) {
      ++v20;
    }
    rp[2] = v21;
    unint64_t v22 = ap[3];
    uint64_t v23 = (v22 * (unsigned __int128)w) >> 64;
    unint64_t v24 = v22 * w;
    BOOL v6 = __CFADD__(v24, v18);
    unint64_t v25 = v24 + v18;
    if (v6) {
      ++v23;
    }
    BOOL v6 = __CFADD__(v25, v20);
    unint64_t v26 = v25 + v20;
    if (v6) {
      uint64_t v4 = v23 + 1;
    }
    else {
      uint64_t v4 = v23;
    }
    rp[3] = v26;
    ap += 4;
    rp += 4;
    *(void *)&num -= 4LL;
  }

  while (*(void *)&num >= 4uLL);
  if (*(void *)&num) {
    goto LABEL_25;
  }
  return v4;
}

unint64_t bn_mul_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  if (!*(void *)&num) {
    return 0LL;
  }
  if (*(void *)&num < 4uLL)
  {
    unint64_t v4 = 0LL;
    do
    {
LABEL_20:
      unint64_t v23 = *ap++;
      unint64_t v24 = (v23 * (unsigned __int128)w) >> 64;
      unint64_t v25 = v23 * w + v4;
      if (__CFADD__(v23 * w, v4)) {
        unint64_t v4 = v24 + 1;
      }
      else {
        unint64_t v4 = v24;
      }
      *rp++ = v25;
      --*(void *)&num;
    }

    while (*(void *)&num);
    return v4;
  }

  unint64_t v4 = 0LL;
  do
  {
    unint64_t v5 = *ap * w;
    BOOL v6 = __CFADD__(v5, v4);
    unint64_t v7 = v5 + v4;
    if (v6) {
      uint64_t v8 = ((*ap * (unsigned __int128)w) >> 64) + 1;
    }
    else {
      uint64_t v8 = (*ap * (unsigned __int128)w) >> 64;
    }
    *rp = v7;
    unint64_t v9 = ap[1];
    uint64_t v10 = (v9 * (unsigned __int128)w) >> 64;
    unint64_t v11 = v9 * w;
    BOOL v6 = __CFADD__(v11, v8);
    unint64_t v12 = v11 + v8;
    if (v6) {
      uint64_t v13 = v10 + 1;
    }
    else {
      uint64_t v13 = v10;
    }
    rp[1] = v12;
    unint64_t v14 = ap[2];
    uint64_t v15 = (v14 * (unsigned __int128)w) >> 64;
    unint64_t v16 = v14 * w;
    BOOL v6 = __CFADD__(v16, v13);
    unint64_t v17 = v16 + v13;
    if (v6) {
      uint64_t v18 = v15 + 1;
    }
    else {
      uint64_t v18 = v15;
    }
    rp[2] = v17;
    unint64_t v19 = ap[3];
    unint64_t v20 = (v19 * (unsigned __int128)w) >> 64;
    unint64_t v21 = v19 * w;
    BOOL v6 = __CFADD__(v21, v18);
    unint64_t v22 = v21 + v18;
    if (v6) {
      unint64_t v4 = v20 + 1;
    }
    else {
      unint64_t v4 = v20;
    }
    rp[3] = v22;
    ap += 4;
    rp += 4;
    *(void *)&num -= 4LL;
  }

  while (*(void *)&num >= 4uLL);
  if (*(void *)&num) {
    goto LABEL_20;
  }
  return v4;
}

void bn_sqr_words(unint64_t *rp, const unint64_t *ap, int num)
{
  if (*(void *)&num)
  {
    if (*(void *)&num < 4uLL) {
      goto LABEL_8;
    }
    do
    {
      *(_OWORD *)rp = *ap * (unsigned __int128)*ap;
      *((_OWORD *)rp + 1) = ap[1] * (unsigned __int128)ap[1];
      *((_OWORD *)rp + 2) = ap[2] * (unsigned __int128)ap[2];
      *((_OWORD *)rp + 3) = ap[3] * (unsigned __int128)ap[3];
      ap += 4;
      rp += 8;
      *(void *)&num -= 4LL;
    }

    while (*(void *)&num >= 4uLL);
    if (*(void *)&num)
    {
LABEL_8:
      do
      {
        unint64_t v3 = *ap++;
        *(_OWORD *)rp = v3 * (unsigned __int128)v3;
        rp += 2;
        --*(void *)&num;
      }

      while (*(void *)&num);
    }
  }

void *bn_mul_comba8(void *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a3;
  __int128 v5 = *a2;
  unint64_t v3 = ((unsigned __int128)*a3 * v5) >> 64;
  *uint64_t result = *a3 * *a2;
  unint64_t v6 = a2[1];
  unint64_t v8 = *a3;
  unint64_t v7 = a3[1];
  uint64_t v9 = (__PAIR128__(v7, v4) * v5) >> 64;
  if (__CFADD__(v7 * *a2, v3)) {
    uint64_t v10 = ((v7 * (unsigned __int128)*a2) >> 64) + 1;
  }
  else {
    uint64_t v10 = (v7 * (unsigned __int128)*a2) >> 64;
  }
  uint64_t v11 = (v8 * (unsigned __int128)v6) >> 64;
  unint64_t v12 = v8 * v6;
  BOOL v13 = __CFADD__(v12, v9);
  uint64_t v14 = v12 + v9;
  if (v13) {
    uint64_t v15 = v11 + 1;
  }
  else {
    uint64_t v15 = v11;
  }
  result[1] = v14;
  unint64_t v16 = a2[2];
  unint64_t v17 = a3[1];
  uint64_t v18 = (*a3 * (unsigned __int128)v16) >> 64;
  unint64_t v19 = *a3 * v16;
  BOOL v13 = __CFADD__(v19, v15 + v10);
  unint64_t v20 = v19 + v15 + v10;
  if (v13) {
    uint64_t v21 = v18 + 1;
  }
  else {
    uint64_t v21 = v18;
  }
  BOOL v13 = __CFADD__(__CFADD__(v15, v10), v21);
  uint64_t v22 = __CFADD__(v15, v10) + v21;
  uint64_t v23 = v13;
  unint64_t v25 = *a2;
  unint64_t v24 = a2[1];
  uint64_t v26 = (v17 * (unsigned __int128)v24) >> 64;
  unint64_t v27 = v17 * v24;
  BOOL v13 = __CFADD__(v20, v27);
  unint64_t v28 = v20 + v27;
  if (v13) {
    uint64_t v29 = v26 + 1;
  }
  else {
    uint64_t v29 = v26;
  }
  BOOL v13 = __CFADD__(v22, v29);
  uint64_t v30 = v22 + v29;
  uint64_t v31 = v13;
  unint64_t v32 = a3[2];
  uint64_t v33 = (v32 * (unsigned __int128)v25) >> 64;
  unint64_t v34 = v32 * v25;
  BOOL v13 = __CFADD__(v28, v34);
  unint64_t v35 = v28 + v34;
  if (v13) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  BOOL v13 = __CFADD__(v30, v36);
  uint64_t v37 = v30 + v36;
  uint64_t v38 = v23 + v13 + v31;
  result[2] = v35;
  unint64_t v39 = a2[1];
  unint64_t v41 = a3[2];
  unint64_t v40 = a3[3];
  unint64_t v42 = v40 * *a2;
  BOOL v13 = __CFADD__(v42, v37);
  uint64_t v43 = v42 + v37;
  if (v13) {
    uint64_t v44 = ((v40 * (unsigned __int128)*a2) >> 64) + 1;
  }
  else {
    uint64_t v44 = (v40 * (unsigned __int128)*a2) >> 64;
  }
  uint64_t v45 = v38 + v44;
  uint64_t v46 = (v41 * (unsigned __int128)v39) >> 64;
  unint64_t v47 = v41 * v39;
  BOOL v13 = __CFADD__(v43, v47);
  uint64_t v48 = v43 + v47;
  if (v13) {
    uint64_t v49 = v46 + 1;
  }
  else {
    uint64_t v49 = v46;
  }
  BOOL v13 = __CFADD__(v45, v49);
  uint64_t v50 = v45 + v49;
  uint64_t v51 = v13;
  if (__CFADD__(v38, v44)) {
    uint64_t v52 = v51 + 1;
  }
  else {
    uint64_t v52 = v51;
  }
  unint64_t v53 = a2[2];
  unint64_t v54 = a2[3];
  unint64_t v56 = *a3;
  unint64_t v55 = a3[1];
  uint64_t v57 = (v55 * (unsigned __int128)v53) >> 64;
  unint64_t v58 = v55 * v53;
  BOOL v13 = __CFADD__(v48, v58);
  uint64_t v59 = v48 + v58;
  if (v13) {
    uint64_t v60 = v57 + 1;
  }
  else {
    uint64_t v60 = v57;
  }
  BOOL v13 = __CFADD__(v50, v60);
  unint64_t v61 = v50 + v60;
  uint64_t v62 = v13;
  unint64_t v63 = (v56 * (unsigned __int128)v54) >> 64;
  unint64_t v64 = v56 * v54;
  BOOL v13 = __CFADD__(v59, v64);
  uint64_t v65 = v59 + v64;
  if (v13) {
    unint64_t v66 = v63 + 1;
  }
  else {
    unint64_t v66 = v63;
  }
  unsigned __int128 v67 = __PAIR128__(v52, v61) + __PAIR128__(v62, v66);
  result[3] = v65;
  unint64_t v68 = a3[1];
  uint64_t v69 = *a3 * a2[4] + v67;
  uint64_t v70 = *((void *)&v67 + 1) + v67;
  BOOL v71 = __CFADD__(*((void *)&v67 + 1), (void)v67);
  unint64_t v73 = a2[2];
  unint64_t v72 = a2[3];
  uint64_t v74 = (v68 * (unsigned __int128)v72) >> 64;
  unint64_t v75 = v68 * v72;
  BOOL v13 = __CFADD__(v69, v75);
  uint64_t v76 = v69 + v75;
  if (v13) {
    uint64_t v77 = v74 + 1;
  }
  else {
    uint64_t v77 = v74;
  }
  BOOL v13 = __CFADD__(v70, v77);
  uint64_t v78 = v70 + v77;
  uint64_t v79 = v13;
  unint64_t v80 = a3[2];
  unint64_t v81 = a3[3];
  uint64_t v82 = (v80 * (unsigned __int128)v73) >> 64;
  unint64_t v83 = v80 * v73;
  BOOL v13 = __CFADD__(v76, v83);
  uint64_t v84 = v76 + v83;
  if (v13) {
    uint64_t v85 = v82 + 1;
  }
  else {
    uint64_t v85 = v82;
  }
  BOOL v13 = __CFADD__(v78, v85);
  uint64_t v86 = v78 + v85;
  uint64_t v87 = v71 + v13 + v79;
  unint64_t v89 = *a2;
  unint64_t v88 = a2[1];
  uint64_t v90 = (v81 * (unsigned __int128)v88) >> 64;
  unint64_t v91 = v81 * v88;
  BOOL v13 = __CFADD__(v84, v91);
  uint64_t v92 = v84 + v91;
  if (v13) {
    uint64_t v93 = v90 + 1;
  }
  else {
    uint64_t v93 = v90;
  }
  BOOL v13 = __CFADD__(v86, v93);
  unint64_t v94 = v86 + v93;
  uint64_t v95 = v13;
  unint64_t v96 = a3[4];
  unint64_t v97 = (v96 * (unsigned __int128)v89) >> 64;
  unint64_t v98 = v96 * v89;
  BOOL v13 = __CFADD__(v92, v98);
  uint64_t v99 = v92 + v98;
  if (v13) {
    unint64_t v100 = v97 + 1;
  }
  else {
    unint64_t v100 = v97;
  }
  unsigned __int128 v101 = __PAIR128__(v87, v94) + __PAIR128__(v95, v100);
  result[4] = v99;
  unint64_t v102 = a2[1];
  unint64_t v103 = a3[4];
  uint64_t v104 = a3[5] * *a2 + v101;
  uint64_t v105 = *((void *)&v101 + 1) + v101;
  uint64_t v106 = (v103 * (unsigned __int128)v102) >> 64;
  unint64_t v107 = v103 * v102;
  BOOL v13 = __CFADD__(v104, v107);
  uint64_t v108 = v104 + v107;
  if (v13) {
    uint64_t v109 = v106 + 1;
  }
  else {
    uint64_t v109 = v106;
  }
  BOOL v13 = __CFADD__(v105, v109);
  uint64_t v110 = v105 + v109;
  uint64_t v111 = v13;
  if (__CFADD__(*((void *)&v101 + 1), (void)v101)) {
    uint64_t v112 = v111 + 1;
  }
  else {
    uint64_t v112 = v111;
  }
  unint64_t v113 = a2[2];
  unint64_t v114 = a2[3];
  unint64_t v116 = a3[2];
  unint64_t v115 = a3[3];
  uint64_t v117 = (v115 * (unsigned __int128)v113) >> 64;
  unint64_t v118 = v115 * v113;
  BOOL v13 = __CFADD__(v108, v118);
  uint64_t v119 = v108 + v118;
  if (v13) {
    uint64_t v120 = v117 + 1;
  }
  else {
    uint64_t v120 = v117;
  }
  BOOL v13 = __CFADD__(v110, v120);
  unint64_t v121 = v110 + v120;
  uint64_t v122 = v13;
  unint64_t v123 = (v116 * (unsigned __int128)v114) >> 64;
  unint64_t v124 = v116 * v114;
  BOOL v13 = __CFADD__(v119, v124);
  uint64_t v125 = v119 + v124;
  if (v13) {
    unint64_t v126 = v123 + 1;
  }
  else {
    unint64_t v126 = v123;
  }
  unsigned __int128 v127 = __PAIR128__(v112, v121) + __PAIR128__(v122, v126);
  unint64_t v128 = a2[4];
  unint64_t v129 = a2[5];
  unint64_t v131 = *a3;
  unint64_t v130 = a3[1];
  uint64_t v132 = (v130 * (unsigned __int128)v128) >> 64;
  unint64_t v133 = v130 * v128;
  BOOL v13 = __CFADD__(v125, v133);
  uint64_t v134 = v125 + v133;
  if (v13) {
    uint64_t v135 = v132 + 1;
  }
  else {
    uint64_t v135 = v132;
  }
  BOOL v136 = __CFADD__((void)v127, v135);
  unint64_t v137 = (v131 * (unsigned __int128)v129) >> 64;
  unint64_t v138 = v131 * v129;
  BOOL v13 = __CFADD__(v134, v138);
  uint64_t v139 = v134 + v138;
  if (v13) {
    unint64_t v140 = v137 + 1;
  }
  else {
    unint64_t v140 = v137;
  }
  unsigned __int128 v141 = v127 + __PAIR128__(v136, v140);
  result[5] = v139;
  unint64_t v142 = a3[1];
  uint64_t v143 = *a3 * a2[6] + v141;
  uint64_t v144 = *((void *)&v141 + 1) + v141;
  BOOL v145 = __CFADD__(*((void *)&v141 + 1), (void)v141);
  unint64_t v147 = a2[4];
  unint64_t v146 = a2[5];
  uint64_t v148 = (v142 * (unsigned __int128)v146) >> 64;
  unint64_t v149 = v142 * v146;
  BOOL v13 = __CFADD__(v143, v149);
  uint64_t v150 = v143 + v149;
  if (v13) {
    uint64_t v151 = v148 + 1;
  }
  else {
    uint64_t v151 = v148;
  }
  BOOL v13 = __CFADD__(v144, v151);
  uint64_t v152 = v144 + v151;
  uint64_t v153 = v13;
  unint64_t v154 = a3[2];
  unint64_t v155 = a3[3];
  uint64_t v156 = (v154 * (unsigned __int128)v147) >> 64;
  unint64_t v157 = v154 * v147;
  BOOL v13 = __CFADD__(v150, v157);
  uint64_t v158 = v150 + v157;
  if (v13) {
    uint64_t v159 = v156 + 1;
  }
  else {
    uint64_t v159 = v156;
  }
  BOOL v13 = __CFADD__(v152, v159);
  uint64_t v160 = v152 + v159;
  uint64_t v161 = v145 + v13 + v153;
  unint64_t v163 = a2[2];
  unint64_t v162 = a2[3];
  uint64_t v164 = (v155 * (unsigned __int128)v162) >> 64;
  unint64_t v165 = v155 * v162;
  BOOL v13 = __CFADD__(v158, v165);
  uint64_t v166 = v158 + v165;
  if (v13) {
    uint64_t v167 = v164 + 1;
  }
  else {
    uint64_t v167 = v164;
  }
  BOOL v13 = __CFADD__(v160, v167);
  unint64_t v168 = v160 + v167;
  uint64_t v169 = v13;
  unint64_t v170 = a3[4];
  unint64_t v171 = a3[5];
  unint64_t v172 = (v170 * (unsigned __int128)v163) >> 64;
  unint64_t v173 = v170 * v163;
  BOOL v13 = __CFADD__(v166, v173);
  uint64_t v174 = v166 + v173;
  if (v13) {
    unint64_t v175 = v172 + 1;
  }
  else {
    unint64_t v175 = v172;
  }
  unsigned __int128 v176 = __PAIR128__(v161, v168) + __PAIR128__(v169, v175);
  unint64_t v178 = *a2;
  unint64_t v177 = a2[1];
  uint64_t v179 = (v171 * (unsigned __int128)v177) >> 64;
  unint64_t v180 = v171 * v177;
  BOOL v13 = __CFADD__(v174, v180);
  uint64_t v181 = v174 + v180;
  if (v13) {
    uint64_t v182 = v179 + 1;
  }
  else {
    uint64_t v182 = v179;
  }
  BOOL v183 = __CFADD__((void)v176, v182);
  unint64_t v184 = a3[6];
  unint64_t v185 = (v184 * (unsigned __int128)v178) >> 64;
  unint64_t v186 = v184 * v178;
  BOOL v13 = __CFADD__(v181, v186);
  uint64_t v187 = v181 + v186;
  if (v13) {
    unint64_t v188 = v185 + 1;
  }
  else {
    unint64_t v188 = v185;
  }
  unsigned __int128 v189 = v176 + __PAIR128__(v183, v188);
  result[6] = v187;
  unint64_t v190 = a2[1];
  unint64_t v191 = a3[6];
  uint64_t v192 = a3[7] * *a2 + v189;
  uint64_t v193 = *((void *)&v189 + 1) + v189;
  uint64_t v194 = (v191 * (unsigned __int128)v190) >> 64;
  unint64_t v195 = v191 * v190;
  BOOL v13 = __CFADD__(v192, v195);
  uint64_t v196 = v192 + v195;
  if (v13) {
    uint64_t v197 = v194 + 1;
  }
  else {
    uint64_t v197 = v194;
  }
  BOOL v13 = __CFADD__(v193, v197);
  uint64_t v198 = v193 + v197;
  uint64_t v199 = v13;
  if (__CFADD__(*((void *)&v189 + 1), (void)v189)) {
    uint64_t v200 = v199 + 1;
  }
  else {
    uint64_t v200 = v199;
  }
  unint64_t v201 = a2[2];
  unint64_t v202 = a2[3];
  unint64_t v204 = a3[4];
  unint64_t v203 = a3[5];
  uint64_t v205 = (v203 * (unsigned __int128)v201) >> 64;
  unint64_t v206 = v203 * v201;
  BOOL v13 = __CFADD__(v196, v206);
  uint64_t v207 = v196 + v206;
  if (v13) {
    uint64_t v208 = v205 + 1;
  }
  else {
    uint64_t v208 = v205;
  }
  BOOL v13 = __CFADD__(v198, v208);
  unint64_t v209 = v198 + v208;
  uint64_t v210 = v13;
  unint64_t v211 = (v204 * (unsigned __int128)v202) >> 64;
  unint64_t v212 = v204 * v202;
  BOOL v13 = __CFADD__(v207, v212);
  uint64_t v213 = v207 + v212;
  if (v13) {
    unint64_t v214 = v211 + 1;
  }
  else {
    unint64_t v214 = v211;
  }
  unsigned __int128 v215 = __PAIR128__(v200, v209) + __PAIR128__(v210, v214);
  unint64_t v216 = a2[4];
  unint64_t v217 = a2[5];
  unint64_t v219 = a3[2];
  unint64_t v218 = a3[3];
  uint64_t v220 = (v218 * (unsigned __int128)v216) >> 64;
  unint64_t v221 = v218 * v216;
  BOOL v13 = __CFADD__(v213, v221);
  uint64_t v222 = v213 + v221;
  if (v13) {
    uint64_t v223 = v220 + 1;
  }
  else {
    uint64_t v223 = v220;
  }
  BOOL v224 = __CFADD__((void)v215, v223);
  unint64_t v225 = (v219 * (unsigned __int128)v217) >> 64;
  unint64_t v226 = v219 * v217;
  BOOL v13 = __CFADD__(v222, v226);
  uint64_t v227 = v222 + v226;
  if (v13) {
    unint64_t v228 = v225 + 1;
  }
  else {
    unint64_t v228 = v225;
  }
  unsigned __int128 v229 = v215 + __PAIR128__(v224, v228);
  unint64_t v230 = a2[6];
  unint64_t v231 = a2[7];
  unint64_t v233 = *a3;
  unint64_t v232 = a3[1];
  uint64_t v234 = (v232 * (unsigned __int128)v230) >> 64;
  unint64_t v235 = v232 * v230;
  BOOL v13 = __CFADD__(v227, v235);
  uint64_t v236 = v227 + v235;
  if (v13) {
    uint64_t v237 = v234 + 1;
  }
  else {
    uint64_t v237 = v234;
  }
  BOOL v238 = __CFADD__((void)v229, v237);
  unint64_t v239 = (v233 * (unsigned __int128)v231) >> 64;
  unint64_t v240 = v233 * v231;
  BOOL v13 = __CFADD__(v236, v240);
  uint64_t v241 = v236 + v240;
  if (v13) {
    unint64_t v242 = v239 + 1;
  }
  else {
    unint64_t v242 = v239;
  }
  unsigned __int128 v243 = v229 + __PAIR128__(v238, v242);
  result[7] = v241;
  unint64_t v244 = a3[2];
  uint64_t v245 = a3[1] * a2[7] + v243;
  uint64_t v246 = *((void *)&v243 + 1) + v243;
  BOOL v247 = __CFADD__(*((void *)&v243 + 1), (void)v243);
  unint64_t v249 = a2[5];
  unint64_t v248 = a2[6];
  uint64_t v250 = (v244 * (unsigned __int128)v248) >> 64;
  unint64_t v251 = v244 * v248;
  BOOL v13 = __CFADD__(v245, v251);
  uint64_t v252 = v245 + v251;
  if (v13) {
    uint64_t v253 = v250 + 1;
  }
  else {
    uint64_t v253 = v250;
  }
  BOOL v13 = __CFADD__(v246, v253);
  uint64_t v254 = v246 + v253;
  uint64_t v255 = v13;
  unint64_t v256 = a3[3];
  unint64_t v257 = a3[4];
  uint64_t v258 = (v256 * (unsigned __int128)v249) >> 64;
  unint64_t v259 = v256 * v249;
  BOOL v13 = __CFADD__(v252, v259);
  uint64_t v260 = v252 + v259;
  if (v13) {
    uint64_t v261 = v258 + 1;
  }
  else {
    uint64_t v261 = v258;
  }
  BOOL v13 = __CFADD__(v254, v261);
  uint64_t v262 = v254 + v261;
  uint64_t v263 = v247 + v13 + v255;
  unint64_t v265 = a2[3];
  unint64_t v264 = a2[4];
  uint64_t v266 = (v257 * (unsigned __int128)v264) >> 64;
  unint64_t v267 = v257 * v264;
  BOOL v13 = __CFADD__(v260, v267);
  uint64_t v268 = v260 + v267;
  if (v13) {
    uint64_t v269 = v266 + 1;
  }
  else {
    uint64_t v269 = v266;
  }
  BOOL v13 = __CFADD__(v262, v269);
  unint64_t v270 = v262 + v269;
  uint64_t v271 = v13;
  unint64_t v272 = a3[5];
  unint64_t v273 = a3[6];
  unint64_t v274 = (v272 * (unsigned __int128)v265) >> 64;
  unint64_t v275 = v272 * v265;
  BOOL v13 = __CFADD__(v268, v275);
  uint64_t v276 = v268 + v275;
  if (v13) {
    unint64_t v277 = v274 + 1;
  }
  else {
    unint64_t v277 = v274;
  }
  unsigned __int128 v278 = __PAIR128__(v263, v270) + __PAIR128__(v271, v277);
  unint64_t v280 = a2[1];
  unint64_t v279 = a2[2];
  uint64_t v281 = (v273 * (unsigned __int128)v279) >> 64;
  unint64_t v282 = v273 * v279;
  BOOL v13 = __CFADD__(v276, v282);
  uint64_t v283 = v276 + v282;
  if (v13) {
    uint64_t v284 = v281 + 1;
  }
  else {
    uint64_t v284 = v281;
  }
  BOOL v285 = __CFADD__((void)v278, v284);
  unint64_t v286 = a3[7];
  unint64_t v287 = (v286 * (unsigned __int128)v280) >> 64;
  unint64_t v288 = v286 * v280;
  BOOL v13 = __CFADD__(v283, v288);
  uint64_t v289 = v283 + v288;
  if (v13) {
    unint64_t v290 = v287 + 1;
  }
  else {
    unint64_t v290 = v287;
  }
  unsigned __int128 v291 = v278 + __PAIR128__(v285, v290);
  result[8] = v289;
  unint64_t v292 = a2[3];
  unint64_t v293 = a3[6];
  uint64_t v294 = a3[7] * a2[2] + v291;
  uint64_t v295 = *((void *)&v291 + 1) + v291;
  uint64_t v296 = (v293 * (unsigned __int128)v292) >> 64;
  unint64_t v297 = v293 * v292;
  BOOL v13 = __CFADD__(v294, v297);
  uint64_t v298 = v294 + v297;
  if (v13) {
    uint64_t v299 = v296 + 1;
  }
  else {
    uint64_t v299 = v296;
  }
  BOOL v13 = __CFADD__(v295, v299);
  uint64_t v300 = v295 + v299;
  uint64_t v301 = v13;
  if (__CFADD__(*((void *)&v291 + 1), (void)v291)) {
    uint64_t v302 = v301 + 1;
  }
  else {
    uint64_t v302 = v301;
  }
  unint64_t v303 = a2[4];
  unint64_t v304 = a2[5];
  unint64_t v306 = a3[4];
  unint64_t v305 = a3[5];
  uint64_t v307 = (v305 * (unsigned __int128)v303) >> 64;
  unint64_t v308 = v305 * v303;
  BOOL v13 = __CFADD__(v298, v308);
  uint64_t v309 = v298 + v308;
  if (v13) {
    uint64_t v310 = v307 + 1;
  }
  else {
    uint64_t v310 = v307;
  }
  BOOL v13 = __CFADD__(v300, v310);
  unint64_t v311 = v300 + v310;
  uint64_t v312 = v13;
  unint64_t v313 = (v306 * (unsigned __int128)v304) >> 64;
  unint64_t v314 = v306 * v304;
  BOOL v13 = __CFADD__(v309, v314);
  uint64_t v315 = v309 + v314;
  if (v13) {
    unint64_t v316 = v313 + 1;
  }
  else {
    unint64_t v316 = v313;
  }
  unsigned __int128 v317 = __PAIR128__(v302, v311) + __PAIR128__(v312, v316);
  unint64_t v318 = a2[6];
  unint64_t v319 = a2[7];
  unint64_t v321 = a3[2];
  unint64_t v320 = a3[3];
  uint64_t v322 = (v320 * (unsigned __int128)v318) >> 64;
  unint64_t v323 = v320 * v318;
  BOOL v13 = __CFADD__(v315, v323);
  uint64_t v324 = v315 + v323;
  if (v13) {
    uint64_t v325 = v322 + 1;
  }
  else {
    uint64_t v325 = v322;
  }
  BOOL v326 = __CFADD__((void)v317, v325);
  unint64_t v327 = (v321 * (unsigned __int128)v319) >> 64;
  unint64_t v328 = v321 * v319;
  BOOL v13 = __CFADD__(v324, v328);
  uint64_t v329 = v324 + v328;
  if (v13) {
    unint64_t v330 = v327 + 1;
  }
  else {
    unint64_t v330 = v327;
  }
  unsigned __int128 v331 = v317 + __PAIR128__(v326, v330);
  result[9] = v329;
  unint64_t v332 = a3[4];
  uint64_t v333 = a3[3] * a2[7] + v331;
  uint64_t v334 = *((void *)&v331 + 1) + v331;
  BOOL v335 = __CFADD__(*((void *)&v331 + 1), (void)v331);
  unint64_t v337 = a2[5];
  unint64_t v336 = a2[6];
  uint64_t v338 = (v332 * (unsigned __int128)v336) >> 64;
  unint64_t v339 = v332 * v336;
  BOOL v13 = __CFADD__(v333, v339);
  uint64_t v340 = v333 + v339;
  if (v13) {
    uint64_t v341 = v338 + 1;
  }
  else {
    uint64_t v341 = v338;
  }
  BOOL v13 = __CFADD__(v334, v341);
  uint64_t v342 = v334 + v341;
  uint64_t v343 = v13;
  unint64_t v344 = a3[5];
  unint64_t v345 = a3[6];
  uint64_t v346 = (v344 * (unsigned __int128)v337) >> 64;
  unint64_t v347 = v344 * v337;
  BOOL v13 = __CFADD__(v340, v347);
  uint64_t v348 = v340 + v347;
  if (v13) {
    uint64_t v349 = v346 + 1;
  }
  else {
    uint64_t v349 = v346;
  }
  BOOL v13 = __CFADD__(v342, v349);
  uint64_t v350 = v342 + v349;
  uint64_t v351 = v335 + v13 + v343;
  unint64_t v353 = a2[3];
  unint64_t v352 = a2[4];
  uint64_t v354 = (v345 * (unsigned __int128)v352) >> 64;
  unint64_t v355 = v345 * v352;
  BOOL v13 = __CFADD__(v348, v355);
  uint64_t v356 = v348 + v355;
  if (v13) {
    uint64_t v357 = v354 + 1;
  }
  else {
    uint64_t v357 = v354;
  }
  BOOL v13 = __CFADD__(v350, v357);
  unint64_t v358 = v350 + v357;
  uint64_t v359 = v13;
  unint64_t v360 = a3[7];
  unint64_t v361 = (v360 * (unsigned __int128)v353) >> 64;
  unint64_t v362 = v360 * v353;
  BOOL v13 = __CFADD__(v356, v362);
  uint64_t v363 = v356 + v362;
  if (v13) {
    unint64_t v364 = v361 + 1;
  }
  else {
    unint64_t v364 = v361;
  }
  unsigned __int128 v365 = __PAIR128__(v351, v358) + __PAIR128__(v359, v364);
  result[10] = v363;
  unint64_t v366 = a2[5];
  unint64_t v367 = a3[6];
  uint64_t v368 = a3[7] * a2[4] + v365;
  uint64_t v369 = *((void *)&v365 + 1) + v365;
  uint64_t v370 = (v367 * (unsigned __int128)v366) >> 64;
  unint64_t v371 = v367 * v366;
  BOOL v13 = __CFADD__(v368, v371);
  uint64_t v372 = v368 + v371;
  if (v13) {
    uint64_t v373 = v370 + 1;
  }
  else {
    uint64_t v373 = v370;
  }
  BOOL v13 = __CFADD__(v369, v373);
  uint64_t v374 = v369 + v373;
  uint64_t v375 = v13;
  unint64_t v376 = a2[6];
  unint64_t v377 = a2[7];
  unint64_t v379 = a3[4];
  unint64_t v378 = a3[5];
  uint64_t v380 = (v378 * (unsigned __int128)v376) >> 64;
  unint64_t v381 = v378 * v376;
  if (__CFADD__(*((void *)&v365 + 1), (void)v365)) {
    ++v375;
  }
  BOOL v13 = __CFADD__(v372, v381);
  uint64_t v382 = v372 + v381;
  if (v13) {
    uint64_t v383 = v380 + 1;
  }
  else {
    uint64_t v383 = v380;
  }
  BOOL v13 = __CFADD__(v374, v383);
  unint64_t v384 = v374 + v383;
  uint64_t v385 = v13;
  unint64_t v386 = (v379 * (unsigned __int128)v377) >> 64;
  unint64_t v387 = v379 * v377;
  BOOL v13 = __CFADD__(v382, v387);
  uint64_t v388 = v382 + v387;
  if (v13) {
    unint64_t v389 = v386 + 1;
  }
  else {
    unint64_t v389 = v386;
  }
  unsigned __int128 v390 = __PAIR128__(v375, v384) + __PAIR128__(v385, v389);
  result[11] = v388;
  unint64_t v391 = a3[6];
  uint64_t v392 = a3[5] * a2[7] + v390;
  uint64_t v393 = *((void *)&v390 + 1) + v390;
  BOOL v394 = __CFADD__(*((void *)&v390 + 1), (void)v390);
  unint64_t v396 = a2[5];
  unint64_t v395 = a2[6];
  uint64_t v397 = (v391 * (unsigned __int128)v395) >> 64;
  unint64_t v398 = v391 * v395;
  BOOL v13 = __CFADD__(v392, v398);
  uint64_t v399 = v392 + v398;
  if (v13) {
    uint64_t v400 = v397 + 1;
  }
  else {
    uint64_t v400 = v397;
  }
  BOOL v13 = __CFADD__(v393, v400);
  uint64_t v401 = v393 + v400;
  uint64_t v402 = v13;
  unint64_t v403 = a3[7];
  uint64_t v404 = (v403 * (unsigned __int128)v396) >> 64;
  unint64_t v405 = v403 * v396;
  BOOL v13 = __CFADD__(v399, v405);
  uint64_t v406 = v399 + v405;
  if (v13) {
    uint64_t v407 = v404 + 1;
  }
  else {
    uint64_t v407 = v404;
  }
  BOOL v13 = __CFADD__(v401, v407);
  uint64_t v408 = v401 + v407;
  uint64_t v409 = v394 + v13 + v402;
  result[12] = v406;
  unint64_t v410 = a2[6];
  unint64_t v411 = a2[7];
  unint64_t v413 = a3[6];
  unint64_t v412 = a3[7];
  uint64_t v414 = (v412 * (unsigned __int128)v410) >> 64;
  unint64_t v415 = v412 * v410;
  BOOL v13 = __CFADD__(v415, v408);
  uint64_t v416 = v415 + v408;
  if (v13) {
    uint64_t v417 = v414 + 1;
  }
  else {
    uint64_t v417 = v414;
  }
  uint64_t v418 = v409 + v417;
  uint64_t v419 = (v413 * (unsigned __int128)v411) >> 64;
  unint64_t v420 = v413 * v411;
  BOOL v13 = __CFADD__(v416, v420);
  uint64_t v421 = v416 + v420;
  if (v13) {
    uint64_t v422 = v419 + 1;
  }
  else {
    uint64_t v422 = v419;
  }
  BOOL v13 = __CFADD__(v418, v422);
  uint64_t v423 = v418 + v422;
  uint64_t v424 = v13;
  result[13] = v421;
  unint64_t v425 = a2[7];
  unint64_t v426 = a3[7];
  uint64_t v427 = (v426 * (unsigned __int128)v425) >> 64;
  unint64_t v428 = v426 * v425;
  BOOL v13 = __CFADD__(v428, v423);
  uint64_t v429 = v428 + v423;
  if (v13) {
    uint64_t v430 = v427 + 1;
  }
  else {
    uint64_t v430 = v427;
  }
  result[14] = v429;
  result[15] = v424 + __CFADD__(v409, v417) + v430;
  return result;
}

void *bn_sqr_comba8(void *result, unint64_t *a2)
{
  uint64_t v2 = (*a2 * (unsigned __int128)*a2) >> 64;
  *uint64_t result = *a2 * *a2;
  unint64_t v3 = a2[1];
  uint64_t v4 = (*a2 * (unsigned __int128)v3) >> 64;
  unint64_t v5 = *a2 * v3;
  BOOL v6 = __CFADD__(v5, v2);
  uint64_t v7 = v5 + v2;
  if (v6) {
    uint64_t v8 = v4 + 1;
  }
  else {
    uint64_t v8 = v4;
  }
  BOOL v6 = __CFADD__(v7, v5);
  uint64_t v9 = v7 + v5;
  if (v6) {
    uint64_t v10 = v4 + 1;
  }
  else {
    uint64_t v10 = v4;
  }
  result[1] = v9;
  unint64_t v12 = *a2;
  unint64_t v11 = a2[1];
  uint64_t v13 = (v11 * (unsigned __int128)v11) >> 64;
  unint64_t v14 = v11 * v11;
  BOOL v6 = __CFADD__(v14, v10 + v8);
  unint64_t v15 = v14 + v10 + v8;
  if (v6) {
    uint64_t v16 = v13 + 1;
  }
  else {
    uint64_t v16 = v13;
  }
  BOOL v6 = __CFADD__(__CFADD__(v10, v8), v16);
  uint64_t v17 = __CFADD__(v10, v8) + v16;
  uint64_t v18 = v6;
  unint64_t v19 = a2[2];
  uint64_t v20 = (v12 * (unsigned __int128)v19) >> 64;
  unint64_t v21 = v12 * v19;
  BOOL v6 = __CFADD__(v15, v21);
  unint64_t v22 = v15 + v21;
  if (v6) {
    uint64_t v23 = v20 + 1;
  }
  else {
    uint64_t v23 = v20;
  }
  BOOL v6 = __CFADD__(v17, v23);
  uint64_t v24 = v17 + v23;
  uint64_t v25 = v6;
  BOOL v6 = __CFADD__(v22, v21);
  unint64_t v26 = v22 + v21;
  if (v6) {
    uint64_t v27 = v20 + 1;
  }
  else {
    uint64_t v27 = v20;
  }
  BOOL v6 = __CFADD__(v24, v27);
  uint64_t v28 = v24 + v27;
  uint64_t v29 = v18 + v6 + v25;
  result[2] = v26;
  unint64_t v31 = a2[2];
  unint64_t v30 = a2[3];
  unint64_t v32 = a2[1];
  uint64_t v33 = (*a2 * (unsigned __int128)v30) >> 64;
  unint64_t v34 = *a2 * v30;
  BOOL v6 = __CFADD__(v34, v28);
  uint64_t v35 = v34 + v28;
  if (v6) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  uint64_t v37 = v29 + v36;
  BOOL v6 = __CFADD__(v35, v34);
  uint64_t v38 = v35 + v34;
  if (v6) {
    uint64_t v39 = v33 + 1;
  }
  else {
    uint64_t v39 = v33;
  }
  BOOL v6 = __CFADD__(v37, v39);
  uint64_t v40 = v37 + v39;
  uint64_t v41 = v6;
  if (__CFADD__(v29, v36)) {
    uint64_t v42 = v41 + 1;
  }
  else {
    uint64_t v42 = v41;
  }
  unint64_t v43 = (v32 * (unsigned __int128)v31) >> 64;
  unint64_t v44 = v32 * v31;
  BOOL v6 = __CFADD__(v38, v44);
  uint64_t v45 = v38 + v44;
  if (v6) {
    unint64_t v46 = v43 + 1;
  }
  else {
    unint64_t v46 = v43;
  }
  BOOL v6 = __CFADD__(v40, v46);
  unint64_t v47 = v40 + v46;
  uint64_t v48 = v6;
  BOOL v6 = __CFADD__(v45, v44);
  uint64_t v49 = v45 + v44;
  if (v6) {
    unint64_t v50 = v43 + 1;
  }
  else {
    unint64_t v50 = v43;
  }
  unsigned __int128 v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  unint64_t v52 = a2[3];
  uint64_t v53 = a2[2] * a2[2] + v51;
  uint64_t v54 = *((void *)&v51 + 1) + v51;
  BOOL v55 = __CFADD__(*((void *)&v51 + 1), (void)v51);
  unint64_t v57 = *a2;
  unint64_t v56 = a2[1];
  uint64_t v58 = (v56 * (unsigned __int128)v52) >> 64;
  unint64_t v59 = v56 * v52;
  BOOL v6 = __CFADD__(v53, v59);
  uint64_t v60 = v53 + v59;
  if (v6) {
    uint64_t v61 = v58 + 1;
  }
  else {
    uint64_t v61 = v58;
  }
  BOOL v6 = __CFADD__(v54, v61);
  uint64_t v62 = v54 + v61;
  uint64_t v63 = v6;
  BOOL v6 = __CFADD__(v60, v59);
  uint64_t v64 = v60 + v59;
  if (v6) {
    uint64_t v65 = v58 + 1;
  }
  else {
    uint64_t v65 = v58;
  }
  BOOL v6 = __CFADD__(v62, v65);
  uint64_t v66 = v62 + v65;
  uint64_t v67 = v55 + v6 + v63;
  unint64_t v68 = a2[4];
  unint64_t v69 = (v57 * (unsigned __int128)v68) >> 64;
  unint64_t v70 = v57 * v68;
  BOOL v6 = __CFADD__(v64, v70);
  uint64_t v71 = v64 + v70;
  if (v6) {
    unint64_t v72 = v69 + 1;
  }
  else {
    unint64_t v72 = v69;
  }
  BOOL v6 = __CFADD__(v66, v72);
  unint64_t v73 = v66 + v72;
  uint64_t v74 = v6;
  BOOL v6 = __CFADD__(v71, v70);
  uint64_t v75 = v71 + v70;
  if (v6) {
    unint64_t v76 = v69 + 1;
  }
  else {
    unint64_t v76 = v69;
  }
  unsigned __int128 v77 = __PAIR128__(v67, v73) + __PAIR128__(v74, v76);
  result[4] = v75;
  unint64_t v79 = a2[4];
  unint64_t v78 = a2[5];
  unint64_t v80 = a2[1];
  uint64_t v81 = (*a2 * (unsigned __int128)v78) >> 64;
  unint64_t v82 = *a2 * v78;
  uint64_t v83 = v82 + v77;
  if (__CFADD__(v82, (void)v77)) {
    uint64_t v84 = v81 + 1;
  }
  else {
    uint64_t v84 = v81;
  }
  uint64_t v85 = *((void *)&v77 + 1) + v84;
  BOOL v6 = __CFADD__(v83, v82);
  uint64_t v86 = v83 + v82;
  if (v6) {
    uint64_t v87 = v81 + 1;
  }
  else {
    uint64_t v87 = v81;
  }
  BOOL v6 = __CFADD__(v85, v87);
  uint64_t v88 = v85 + v87;
  uint64_t v89 = v6;
  if (__CFADD__(*((void *)&v77 + 1), v84)) {
    uint64_t v90 = v89 + 1;
  }
  else {
    uint64_t v90 = v89;
  }
  unint64_t v91 = (v80 * (unsigned __int128)v79) >> 64;
  unint64_t v92 = v80 * v79;
  BOOL v6 = __CFADD__(v86, v92);
  uint64_t v93 = v86 + v92;
  if (v6) {
    unint64_t v94 = v91 + 1;
  }
  else {
    unint64_t v94 = v91;
  }
  BOOL v6 = __CFADD__(v88, v94);
  unint64_t v95 = v88 + v94;
  uint64_t v96 = v6;
  BOOL v6 = __CFADD__(v93, v92);
  uint64_t v97 = v93 + v92;
  if (v6) {
    unint64_t v98 = v91 + 1;
  }
  else {
    unint64_t v98 = v91;
  }
  unsigned __int128 v99 = __PAIR128__(v90, v95) + __PAIR128__(v96, v98);
  unint64_t v101 = a2[2];
  unint64_t v100 = a2[3];
  unint64_t v102 = (v101 * (unsigned __int128)v100) >> 64;
  unint64_t v103 = v101 * v100;
  BOOL v6 = __CFADD__(v97, v103);
  uint64_t v104 = v97 + v103;
  if (v6) {
    unint64_t v105 = v102 + 1;
  }
  else {
    unint64_t v105 = v102;
  }
  BOOL v106 = __CFADD__((void)v99, v105);
  BOOL v6 = __CFADD__(v104, v103);
  uint64_t v107 = v104 + v103;
  if (v6) {
    unint64_t v108 = v102 + 1;
  }
  else {
    unint64_t v108 = v102;
  }
  unsigned __int128 v109 = v99 + __PAIR128__(v106, v108);
  result[5] = v107;
  unint64_t v110 = a2[2];
  uint64_t v111 = a2[3] * a2[3] + v109;
  uint64_t v112 = *((void *)&v109 + 1) + v109;
  BOOL v113 = __CFADD__(*((void *)&v109 + 1), (void)v109);
  unint64_t v114 = a2[4];
  unint64_t v115 = a2[5];
  uint64_t v116 = (v110 * (unsigned __int128)v114) >> 64;
  unint64_t v117 = v110 * v114;
  BOOL v6 = __CFADD__(v111, v117);
  uint64_t v118 = v111 + v117;
  if (v6) {
    uint64_t v119 = v116 + 1;
  }
  else {
    uint64_t v119 = v116;
  }
  BOOL v6 = __CFADD__(v112, v119);
  uint64_t v120 = v112 + v119;
  uint64_t v121 = v6;
  BOOL v6 = __CFADD__(v118, v117);
  uint64_t v122 = v118 + v117;
  if (v6) {
    uint64_t v123 = v116 + 1;
  }
  else {
    uint64_t v123 = v116;
  }
  BOOL v6 = __CFADD__(v120, v123);
  uint64_t v124 = v120 + v123;
  uint64_t v125 = v113 + v6 + v121;
  unint64_t v127 = *a2;
  unint64_t v126 = a2[1];
  unint64_t v128 = (v126 * (unsigned __int128)v115) >> 64;
  unint64_t v129 = v126 * v115;
  BOOL v6 = __CFADD__(v122, v129);
  uint64_t v130 = v122 + v129;
  if (v6) {
    unint64_t v131 = v128 + 1;
  }
  else {
    unint64_t v131 = v128;
  }
  BOOL v6 = __CFADD__(v124, v131);
  unint64_t v132 = v124 + v131;
  uint64_t v133 = v6;
  BOOL v6 = __CFADD__(v130, v129);
  uint64_t v134 = v130 + v129;
  if (v6) {
    unint64_t v135 = v128 + 1;
  }
  else {
    unint64_t v135 = v128;
  }
  unsigned __int128 v136 = __PAIR128__(v125, v132) + __PAIR128__(v133, v135);
  unint64_t v137 = a2[6];
  unint64_t v138 = (v127 * (unsigned __int128)v137) >> 64;
  unint64_t v139 = v127 * v137;
  BOOL v6 = __CFADD__(v134, v139);
  uint64_t v140 = v134 + v139;
  if (v6) {
    unint64_t v141 = v138 + 1;
  }
  else {
    unint64_t v141 = v138;
  }
  BOOL v142 = __CFADD__((void)v136, v141);
  BOOL v6 = __CFADD__(v140, v139);
  uint64_t v143 = v140 + v139;
  if (v6) {
    unint64_t v144 = v138 + 1;
  }
  else {
    unint64_t v144 = v138;
  }
  unsigned __int128 v145 = v136 + __PAIR128__(v142, v144);
  result[6] = v143;
  unint64_t v147 = a2[6];
  unint64_t v146 = a2[7];
  unint64_t v148 = a2[1];
  uint64_t v149 = (*a2 * (unsigned __int128)v146) >> 64;
  unint64_t v150 = *a2 * v146;
  uint64_t v151 = v150 + v145;
  if (__CFADD__(v150, (void)v145)) {
    uint64_t v152 = v149 + 1;
  }
  else {
    uint64_t v152 = v149;
  }
  uint64_t v153 = *((void *)&v145 + 1) + v152;
  BOOL v6 = __CFADD__(v151, v150);
  uint64_t v154 = v151 + v150;
  if (v6) {
    uint64_t v155 = v149 + 1;
  }
  else {
    uint64_t v155 = v149;
  }
  BOOL v6 = __CFADD__(v153, v155);
  uint64_t v156 = v153 + v155;
  uint64_t v157 = v6;
  if (__CFADD__(*((void *)&v145 + 1), v152)) {
    uint64_t v158 = v157 + 1;
  }
  else {
    uint64_t v158 = v157;
  }
  unint64_t v159 = (v148 * (unsigned __int128)v147) >> 64;
  unint64_t v160 = v148 * v147;
  BOOL v6 = __CFADD__(v154, v160);
  uint64_t v161 = v154 + v160;
  if (v6) {
    unint64_t v162 = v159 + 1;
  }
  else {
    unint64_t v162 = v159;
  }
  BOOL v6 = __CFADD__(v156, v162);
  unint64_t v163 = v156 + v162;
  uint64_t v164 = v6;
  BOOL v6 = __CFADD__(v161, v160);
  uint64_t v165 = v161 + v160;
  if (v6) {
    unint64_t v166 = v159 + 1;
  }
  else {
    unint64_t v166 = v159;
  }
  unsigned __int128 v167 = __PAIR128__(v158, v163) + __PAIR128__(v164, v166);
  unint64_t v169 = a2[4];
  unint64_t v168 = a2[5];
  unint64_t v170 = a2[2];
  unint64_t v171 = a2[3];
  unint64_t v172 = (v170 * (unsigned __int128)v168) >> 64;
  unint64_t v173 = v170 * v168;
  BOOL v6 = __CFADD__(v165, v173);
  uint64_t v174 = v165 + v173;
  if (v6) {
    unint64_t v175 = v172 + 1;
  }
  else {
    unint64_t v175 = v172;
  }
  BOOL v176 = __CFADD__((void)v167, v175);
  BOOL v6 = __CFADD__(v174, v173);
  uint64_t v177 = v174 + v173;
  if (v6) {
    unint64_t v178 = v172 + 1;
  }
  else {
    unint64_t v178 = v172;
  }
  unsigned __int128 v179 = v167 + __PAIR128__(v176, v178);
  unint64_t v180 = (v171 * (unsigned __int128)v169) >> 64;
  unint64_t v181 = v171 * v169;
  BOOL v6 = __CFADD__(v177, v181);
  uint64_t v182 = v177 + v181;
  if (v6) {
    unint64_t v183 = v180 + 1;
  }
  else {
    unint64_t v183 = v180;
  }
  BOOL v184 = __CFADD__((void)v179, v183);
  BOOL v6 = __CFADD__(v182, v181);
  uint64_t v185 = v182 + v181;
  if (v6) {
    ++v180;
  }
  unsigned __int128 v186 = v179 + __PAIR128__(v184, v180);
  result[7] = v185;
  unint64_t v187 = a2[3];
  uint64_t v188 = a2[4] * a2[4] + v186;
  uint64_t v189 = *((void *)&v186 + 1) + v186;
  BOOL v190 = __CFADD__(*((void *)&v186 + 1), (void)v186);
  unint64_t v191 = a2[5];
  unint64_t v192 = a2[6];
  uint64_t v193 = (v187 * (unsigned __int128)v191) >> 64;
  unint64_t v194 = v187 * v191;
  BOOL v6 = __CFADD__(v188, v194);
  uint64_t v195 = v188 + v194;
  if (v6) {
    uint64_t v196 = v193 + 1;
  }
  else {
    uint64_t v196 = v193;
  }
  BOOL v6 = __CFADD__(v189, v196);
  uint64_t v197 = v189 + v196;
  uint64_t v198 = v6;
  BOOL v6 = __CFADD__(v195, v194);
  uint64_t v199 = v195 + v194;
  if (v6) {
    uint64_t v200 = v193 + 1;
  }
  else {
    uint64_t v200 = v193;
  }
  BOOL v6 = __CFADD__(v197, v200);
  uint64_t v201 = v197 + v200;
  uint64_t v202 = v190 + v6 + v198;
  unint64_t v204 = a2[1];
  unint64_t v203 = a2[2];
  unint64_t v205 = (v203 * (unsigned __int128)v192) >> 64;
  unint64_t v206 = v203 * v192;
  BOOL v6 = __CFADD__(v199, v206);
  uint64_t v207 = v199 + v206;
  if (v6) {
    unint64_t v208 = v205 + 1;
  }
  else {
    unint64_t v208 = v205;
  }
  BOOL v6 = __CFADD__(v201, v208);
  unint64_t v209 = v201 + v208;
  uint64_t v210 = v6;
  BOOL v6 = __CFADD__(v207, v206);
  uint64_t v211 = v207 + v206;
  if (v6) {
    unint64_t v212 = v205 + 1;
  }
  else {
    unint64_t v212 = v205;
  }
  unsigned __int128 v213 = __PAIR128__(v202, v209) + __PAIR128__(v210, v212);
  unint64_t v214 = a2[7];
  unint64_t v215 = (v204 * (unsigned __int128)v214) >> 64;
  unint64_t v216 = v204 * v214;
  BOOL v6 = __CFADD__(v211, v216);
  uint64_t v217 = v211 + v216;
  if (v6) {
    unint64_t v218 = v215 + 1;
  }
  else {
    unint64_t v218 = v215;
  }
  BOOL v219 = __CFADD__((void)v213, v218);
  BOOL v6 = __CFADD__(v217, v216);
  uint64_t v220 = v217 + v216;
  if (v6) {
    unint64_t v221 = v215 + 1;
  }
  else {
    unint64_t v221 = v215;
  }
  unsigned __int128 v222 = v213 + __PAIR128__(v219, v221);
  result[8] = v220;
  unint64_t v224 = a2[6];
  unint64_t v223 = a2[7];
  unint64_t v225 = a2[2];
  unint64_t v226 = a2[3];
  uint64_t v227 = (v225 * (unsigned __int128)v223) >> 64;
  unint64_t v228 = v225 * v223;
  uint64_t v229 = v228 + v222;
  if (__CFADD__(v228, (void)v222)) {
    uint64_t v230 = v227 + 1;
  }
  else {
    uint64_t v230 = v227;
  }
  uint64_t v231 = *((void *)&v222 + 1) + v230;
  BOOL v6 = __CFADD__(v229, v228);
  uint64_t v232 = v229 + v228;
  if (v6) {
    uint64_t v233 = v227 + 1;
  }
  else {
    uint64_t v233 = v227;
  }
  BOOL v6 = __CFADD__(v231, v233);
  uint64_t v234 = v231 + v233;
  uint64_t v235 = v6;
  if (__CFADD__(*((void *)&v222 + 1), v230)) {
    uint64_t v236 = v235 + 1;
  }
  else {
    uint64_t v236 = v235;
  }
  unint64_t v237 = (v226 * (unsigned __int128)v224) >> 64;
  unint64_t v238 = v226 * v224;
  BOOL v6 = __CFADD__(v232, v238);
  uint64_t v239 = v232 + v238;
  if (v6) {
    unint64_t v240 = v237 + 1;
  }
  else {
    unint64_t v240 = v237;
  }
  BOOL v6 = __CFADD__(v234, v240);
  unint64_t v241 = v234 + v240;
  uint64_t v242 = v6;
  BOOL v6 = __CFADD__(v239, v238);
  uint64_t v243 = v239 + v238;
  if (v6) {
    unint64_t v244 = v237 + 1;
  }
  else {
    unint64_t v244 = v237;
  }
  unsigned __int128 v245 = __PAIR128__(v236, v241) + __PAIR128__(v242, v244);
  unint64_t v247 = a2[4];
  unint64_t v246 = a2[5];
  unint64_t v248 = (v247 * (unsigned __int128)v246) >> 64;
  unint64_t v249 = v247 * v246;
  BOOL v6 = __CFADD__(v243, v249);
  uint64_t v250 = v243 + v249;
  if (v6) {
    unint64_t v251 = v248 + 1;
  }
  else {
    unint64_t v251 = v248;
  }
  BOOL v252 = __CFADD__((void)v245, v251);
  BOOL v6 = __CFADD__(v250, v249);
  uint64_t v253 = v250 + v249;
  if (v6) {
    unint64_t v254 = v248 + 1;
  }
  else {
    unint64_t v254 = v248;
  }
  unsigned __int128 v255 = v245 + __PAIR128__(v252, v254);
  result[9] = v253;
  unint64_t v256 = a2[6];
  uint64_t v257 = a2[5] * a2[5] + v255;
  uint64_t v258 = *((void *)&v255 + 1) + v255;
  BOOL v259 = __CFADD__(*((void *)&v255 + 1), (void)v255);
  unint64_t v261 = a2[3];
  unint64_t v260 = a2[4];
  uint64_t v262 = (v260 * (unsigned __int128)v256) >> 64;
  unint64_t v263 = v260 * v256;
  BOOL v6 = __CFADD__(v257, v263);
  uint64_t v264 = v257 + v263;
  if (v6) {
    uint64_t v265 = v262 + 1;
  }
  else {
    uint64_t v265 = v262;
  }
  BOOL v6 = __CFADD__(v258, v265);
  uint64_t v266 = v258 + v265;
  uint64_t v267 = v6;
  BOOL v6 = __CFADD__(v264, v263);
  uint64_t v268 = v264 + v263;
  if (v6) {
    uint64_t v269 = v262 + 1;
  }
  else {
    uint64_t v269 = v262;
  }
  BOOL v6 = __CFADD__(v266, v269);
  uint64_t v270 = v266 + v269;
  uint64_t v271 = v259 + v6 + v267;
  unint64_t v272 = a2[7];
  unint64_t v273 = (v261 * (unsigned __int128)v272) >> 64;
  unint64_t v274 = v261 * v272;
  BOOL v6 = __CFADD__(v268, v274);
  uint64_t v275 = v268 + v274;
  if (v6) {
    unint64_t v276 = v273 + 1;
  }
  else {
    unint64_t v276 = v273;
  }
  BOOL v6 = __CFADD__(v270, v276);
  unint64_t v277 = v270 + v276;
  uint64_t v278 = v6;
  BOOL v6 = __CFADD__(v275, v274);
  uint64_t v279 = v275 + v274;
  if (v6) {
    unint64_t v280 = v273 + 1;
  }
  else {
    unint64_t v280 = v273;
  }
  unsigned __int128 v281 = __PAIR128__(v271, v277) + __PAIR128__(v278, v280);
  result[10] = v279;
  unint64_t v283 = a2[6];
  unint64_t v282 = a2[7];
  unint64_t v284 = a2[4];
  unint64_t v285 = a2[5];
  uint64_t v286 = (v284 * (unsigned __int128)v282) >> 64;
  unint64_t v287 = v284 * v282;
  uint64_t v288 = v287 + v281;
  if (__CFADD__(v287, (void)v281)) {
    uint64_t v289 = v286 + 1;
  }
  else {
    uint64_t v289 = v286;
  }
  uint64_t v290 = *((void *)&v281 + 1) + v289;
  BOOL v6 = __CFADD__(v288, v287);
  uint64_t v291 = v288 + v287;
  if (v6) {
    uint64_t v292 = v286 + 1;
  }
  else {
    uint64_t v292 = v286;
  }
  BOOL v6 = __CFADD__(v290, v292);
  uint64_t v293 = v290 + v292;
  uint64_t v294 = v6;
  if (__CFADD__(*((void *)&v281 + 1), v289)) {
    uint64_t v295 = v294 + 1;
  }
  else {
    uint64_t v295 = v294;
  }
  unint64_t v296 = (v285 * (unsigned __int128)v283) >> 64;
  unint64_t v297 = v285 * v283;
  BOOL v6 = __CFADD__(v291, v297);
  uint64_t v298 = v291 + v297;
  if (v6) {
    unint64_t v299 = v296 + 1;
  }
  else {
    unint64_t v299 = v296;
  }
  BOOL v6 = __CFADD__(v293, v299);
  unint64_t v300 = v293 + v299;
  uint64_t v301 = v6;
  BOOL v6 = __CFADD__(v298, v297);
  uint64_t v302 = v298 + v297;
  if (v6) {
    unint64_t v303 = v296 + 1;
  }
  else {
    unint64_t v303 = v296;
  }
  unsigned __int128 v304 = __PAIR128__(v295, v300) + __PAIR128__(v301, v303);
  result[11] = v302;
  unint64_t v305 = a2[5];
  uint64_t v306 = a2[6] * a2[6] + v304;
  uint64_t v307 = *((void *)&v304 + 1) + v304;
  BOOL v308 = __CFADD__(*((void *)&v304 + 1), (void)v304);
  unint64_t v309 = a2[7];
  uint64_t v310 = (v305 * (unsigned __int128)v309) >> 64;
  unint64_t v311 = v305 * v309;
  BOOL v6 = __CFADD__(v306, v311);
  uint64_t v312 = v306 + v311;
  if (v6) {
    uint64_t v313 = v310 + 1;
  }
  else {
    uint64_t v313 = v310;
  }
  BOOL v6 = __CFADD__(v307, v313);
  uint64_t v314 = v307 + v313;
  uint64_t v315 = v6;
  BOOL v6 = __CFADD__(v312, v311);
  uint64_t v316 = v312 + v311;
  if (v6) {
    uint64_t v317 = v310 + 1;
  }
  else {
    uint64_t v317 = v310;
  }
  BOOL v6 = __CFADD__(v314, v317);
  uint64_t v318 = v314 + v317;
  uint64_t v319 = v308 + v6 + v315;
  result[12] = v316;
  unint64_t v321 = a2[6];
  unint64_t v320 = a2[7];
  uint64_t v322 = (v321 * (unsigned __int128)v320) >> 64;
  unint64_t v323 = v321 * v320;
  BOOL v6 = __CFADD__(v323, v318);
  uint64_t v324 = v323 + v318;
  if (v6) {
    uint64_t v325 = v322 + 1;
  }
  else {
    uint64_t v325 = v322;
  }
  uint64_t v326 = v319 + v325;
  BOOL v6 = __CFADD__(v324, v323);
  uint64_t v327 = v324 + v323;
  if (v6) {
    uint64_t v328 = v322 + 1;
  }
  else {
    uint64_t v328 = v322;
  }
  BOOL v6 = __CFADD__(v326, v328);
  uint64_t v329 = v326 + v328;
  uint64_t v330 = v6;
  result[13] = v327;
  unint64_t v331 = a2[7];
  uint64_t v332 = (v331 * (unsigned __int128)v331) >> 64;
  unint64_t v333 = v331 * v331;
  BOOL v6 = __CFADD__(v333, v329);
  uint64_t v334 = v333 + v329;
  if (v6) {
    uint64_t v335 = v332 + 1;
  }
  else {
    uint64_t v335 = v332;
  }
  result[14] = v334;
  result[15] = v330 + __CFADD__(v319, v325) + v335;
  return result;
}

void *bn_sqr_comba4(void *result, unint64_t *a2)
{
  uint64_t v2 = (*a2 * (unsigned __int128)*a2) >> 64;
  *uint64_t result = *a2 * *a2;
  unint64_t v3 = a2[1];
  uint64_t v4 = (*a2 * (unsigned __int128)v3) >> 64;
  unint64_t v5 = *a2 * v3;
  BOOL v6 = __CFADD__(v5, v2);
  uint64_t v7 = v5 + v2;
  if (v6) {
    uint64_t v8 = v4 + 1;
  }
  else {
    uint64_t v8 = v4;
  }
  BOOL v6 = __CFADD__(v7, v5);
  uint64_t v9 = v7 + v5;
  if (v6) {
    uint64_t v10 = v4 + 1;
  }
  else {
    uint64_t v10 = v4;
  }
  result[1] = v9;
  unint64_t v12 = *a2;
  unint64_t v11 = a2[1];
  uint64_t v13 = (v11 * (unsigned __int128)v11) >> 64;
  unint64_t v14 = v11 * v11;
  BOOL v6 = __CFADD__(v14, v10 + v8);
  unint64_t v15 = v14 + v10 + v8;
  if (v6) {
    uint64_t v16 = v13 + 1;
  }
  else {
    uint64_t v16 = v13;
  }
  BOOL v6 = __CFADD__(__CFADD__(v10, v8), v16);
  uint64_t v17 = __CFADD__(v10, v8) + v16;
  uint64_t v18 = v6;
  unint64_t v19 = a2[2];
  uint64_t v20 = (v12 * (unsigned __int128)v19) >> 64;
  unint64_t v21 = v12 * v19;
  BOOL v6 = __CFADD__(v15, v21);
  unint64_t v22 = v15 + v21;
  if (v6) {
    uint64_t v23 = v20 + 1;
  }
  else {
    uint64_t v23 = v20;
  }
  BOOL v6 = __CFADD__(v17, v23);
  uint64_t v24 = v17 + v23;
  uint64_t v25 = v6;
  BOOL v6 = __CFADD__(v22, v21);
  unint64_t v26 = v22 + v21;
  if (v6) {
    uint64_t v27 = v20 + 1;
  }
  else {
    uint64_t v27 = v20;
  }
  BOOL v6 = __CFADD__(v24, v27);
  uint64_t v28 = v24 + v27;
  uint64_t v29 = v18 + v6 + v25;
  result[2] = v26;
  unint64_t v31 = a2[2];
  unint64_t v30 = a2[3];
  unint64_t v32 = a2[1];
  uint64_t v33 = (*a2 * (unsigned __int128)v30) >> 64;
  unint64_t v34 = *a2 * v30;
  BOOL v6 = __CFADD__(v34, v28);
  uint64_t v35 = v34 + v28;
  if (v6) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  uint64_t v37 = v29 + v36;
  BOOL v6 = __CFADD__(v35, v34);
  uint64_t v38 = v35 + v34;
  if (v6) {
    uint64_t v39 = v33 + 1;
  }
  else {
    uint64_t v39 = v33;
  }
  BOOL v6 = __CFADD__(v37, v39);
  uint64_t v40 = v37 + v39;
  uint64_t v41 = v6;
  if (__CFADD__(v29, v36)) {
    uint64_t v42 = v41 + 1;
  }
  else {
    uint64_t v42 = v41;
  }
  unint64_t v43 = (v32 * (unsigned __int128)v31) >> 64;
  unint64_t v44 = v32 * v31;
  BOOL v6 = __CFADD__(v38, v44);
  uint64_t v45 = v38 + v44;
  if (v6) {
    unint64_t v46 = v43 + 1;
  }
  else {
    unint64_t v46 = v43;
  }
  BOOL v6 = __CFADD__(v40, v46);
  unint64_t v47 = v40 + v46;
  uint64_t v48 = v6;
  BOOL v6 = __CFADD__(v45, v44);
  uint64_t v49 = v45 + v44;
  if (v6) {
    unint64_t v50 = v43 + 1;
  }
  else {
    unint64_t v50 = v43;
  }
  unsigned __int128 v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  unint64_t v52 = a2[1];
  uint64_t v53 = a2[2] * a2[2] + v51;
  uint64_t v54 = *((void *)&v51 + 1) + v51;
  BOOL v55 = __CFADD__(*((void *)&v51 + 1), (void)v51);
  unint64_t v56 = a2[3];
  uint64_t v57 = (v52 * (unsigned __int128)v56) >> 64;
  unint64_t v58 = v52 * v56;
  BOOL v6 = __CFADD__(v53, v58);
  uint64_t v59 = v53 + v58;
  if (v6) {
    uint64_t v60 = v57 + 1;
  }
  else {
    uint64_t v60 = v57;
  }
  BOOL v6 = __CFADD__(v54, v60);
  uint64_t v61 = v54 + v60;
  uint64_t v62 = v6;
  BOOL v6 = __CFADD__(v59, v58);
  uint64_t v63 = v59 + v58;
  if (v6) {
    uint64_t v64 = v57 + 1;
  }
  else {
    uint64_t v64 = v57;
  }
  BOOL v6 = __CFADD__(v61, v64);
  uint64_t v65 = v61 + v64;
  uint64_t v66 = v55 + v6 + v62;
  result[4] = v63;
  unint64_t v68 = a2[2];
  unint64_t v67 = a2[3];
  uint64_t v69 = (v68 * (unsigned __int128)v67) >> 64;
  unint64_t v70 = v68 * v67;
  BOOL v6 = __CFADD__(v70, v65);
  uint64_t v71 = v70 + v65;
  if (v6) {
    uint64_t v72 = v69 + 1;
  }
  else {
    uint64_t v72 = v69;
  }
  uint64_t v73 = v66 + v72;
  BOOL v6 = __CFADD__(v71, v70);
  uint64_t v74 = v71 + v70;
  if (v6) {
    uint64_t v75 = v69 + 1;
  }
  else {
    uint64_t v75 = v69;
  }
  BOOL v6 = __CFADD__(v73, v75);
  uint64_t v76 = v73 + v75;
  uint64_t v77 = v6;
  result[5] = v74;
  unint64_t v78 = a2[3];
  uint64_t v79 = (v78 * (unsigned __int128)v78) >> 64;
  unint64_t v80 = v78 * v78;
  BOOL v6 = __CFADD__(v80, v76);
  uint64_t v81 = v80 + v76;
  if (v6) {
    uint64_t v82 = v79 + 1;
  }
  else {
    uint64_t v82 = v79;
  }
  result[6] = v81;
  result[7] = v77 + __CFADD__(v66, v72) + v82;
  return result;
}

unint64_t bn_add_words( unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  if (!*(void *)&num) {
    return 0LL;
  }
  if (*(void *)&num < 4uLL)
  {
    unint64_t v4 = 0LL;
    do
    {
LABEL_17:
      uint64_t v23 = *bp++;
      uint64_t v22 = v23;
      uint64_t v24 = *ap++;
      BOOL v7 = __CFADD__(v24, v22);
      uint64_t v25 = v24 + v22;
      unsigned int v26 = v7;
      BOOL v7 = __CFADD__(v25, v4);
      unint64_t v27 = v25 + v4;
      if (v7) {
        unint64_t v4 = 1LL;
      }
      else {
        unint64_t v4 = v26;
      }
      *rp++ = v27;
      --*(void *)&num;
    }

    while (*(void *)&num);
    return v4;
  }

  unint64_t v4 = 0LL;
  do
  {
    unint64_t v5 = *ap + *bp;
    BOOL v6 = __CFADD__(*ap, *bp);
    BOOL v7 = __CFADD__(v5, v4);
    unint64_t v8 = v5 + v4;
    int v9 = v7 || v6;
    BOOL v7 = v9 != 0;
    *rp = v8;
    unint64_t v10 = ap[1];
    unint64_t v11 = bp[1];
    BOOL v13 = v7;
    BOOL v7 = __CFADD__(v7, v10);
    unint64_t v12 = v13 + v10;
    v7 |= __CFADD__(v11, v12);
    rp[1] = v11 + v12;
    unint64_t v14 = ap[2];
    unint64_t v15 = bp[2];
    BOOL v17 = v7;
    BOOL v7 = __CFADD__(v7, v14);
    unint64_t v16 = v17 + v14;
    v7 |= __CFADD__(v15, v16);
    rp[2] = v15 + v16;
    unint64_t v18 = ap[3];
    unint64_t v19 = bp[3];
    unint64_t v21 = v7 + v18;
    BOOL v7 = __CFADD__(v7, v18) | __CFADD__(v19, v21);
    unint64_t v20 = v19 + v21;
    unint64_t v4 = v7;
    rp[3] = v20;
    ap += 4;
    bp += 4;
    rp += 4;
    *(void *)&num -= 4LL;
  }

  while (*(void *)&num >= 4uLL);
  if (*(void *)&num) {
    goto LABEL_17;
  }
  return v4;
}

unint64_t bn_sub_words( unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  if (!*(void *)&num) {
    return 0LL;
  }
  if (*(void *)&num < 4uLL)
  {
    unint64_t v4 = 0LL;
    do
    {
LABEL_14:
      unint64_t v20 = *bp++;
      unint64_t v19 = v20;
      unint64_t v21 = *ap++;
      _BOOL1 v6 = v21 >= v19;
      unint64_t v22 = v21 - v19;
      unsigned int v23 = !v6;
      _BOOL1 v6 = v22 >= v4;
      unint64_t v24 = v22 - v4;
      if (v6) {
        unint64_t v4 = v23;
      }
      else {
        unint64_t v4 = 1LL;
      }
      *rp++ = v24;
      --*(void *)&num;
    }

    while (*(void *)&num);
    return v4;
  }

  unint64_t v4 = 0LL;
  do
  {
    unint64_t v5 = *ap - *bp;
    _BOOL1 v6 = v5 >= v4;
    unint64_t v7 = v5 - v4;
    BOOL v8 = !v6 || *ap < *bp;
    _BOOL1 v6 = !v8;
    *rp = v7;
    unint64_t v9 = ap[1];
    unint64_t v10 = bp[1];
    _BOOL1 v11 = v6;
    _BOOL1 v6 = __CFSUB__(v9, v10, v6);
    rp[1] = v9 - (v10 + !v11);
    unint64_t v12 = ap[2];
    unint64_t v13 = bp[2];
    _BOOL1 v14 = v6;
    _BOOL1 v6 = __CFSUB__(v12, v13, v6);
    rp[2] = v12 - (v13 + !v14);
    unint64_t v15 = ap[3];
    unint64_t v16 = bp[3];
    _BOOL1 v18 = v6;
    _BOOL1 v6 = __CFSUB__(v15, v16, v6);
    unint64_t v17 = v15 - (v16 + !v18);
    unint64_t v4 = !v6;
    rp[3] = v17;
    ap += 4;
    bp += 4;
    rp += 4;
    *(void *)&num -= 4LL;
  }

  while (*(void *)&num >= 4uLL);
  if (*(void *)&num) {
    goto LABEL_14;
  }
  return v4;
}

int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
  if (n < 0)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/shift.c", 73);
    return 0;
  }

  else
  {
    r->int neg = a->neg;
    unsigned int v6 = n >> 6;
    unsigned int v7 = (n >> 6) + 1;
    int result = bn_wexpand(&r->d, (int)(v7 + a->top));
    if (result)
    {
      int d = a->d;
      unint64_t v10 = r->d;
      unint64_t top = a->top;
      r->d[(int)(top + v6)] = 0LL;
      char v12 = n & 0x3F;
      if ((n & 0x3F) != 0)
      {
        if ((int)top >= 1)
        {
          unint64_t v13 = d - 1;
          unint64_t v14 = top;
          do
          {
            unint64_t v15 = v13[v14];
            v10[(int)(v6 + v14)] |= v15 >> (64 - v12);
            v10[v6 - 1 + v14] = v15 << v12;
            BOOL v16 = v14-- > 1;
          }

          while (v16);
        }
      }

      else if ((int)top >= 1)
      {
        unint64_t v17 = d - 1;
        unint64_t v18 = top;
        do
        {
          v10[v6 - 1 + v18] = v17[v18];
          BOOL v16 = v18-- > 1;
        }

        while (v16);
      }

      if (n >= 0x40)
      {
        bzero(v10, 8 * v6);
        LODWORD(top) = a->top;
      }

      r->unint64_t top = v7 + top;
      bn_set_minimal_width((uint64_t)r);
      return 1;
    }
  }

  return result;
}

int BN_lshift1(BIGNUM *r, const BIGNUM *a)
{
  if (r == a)
  {
    int result = bn_wexpand(&r->d, r->top + 1LL);
    if (!result) {
      return result;
    }
  }

  else
  {
    r->int neg = a->neg;
    int result = bn_wexpand(&r->d, a->top + 1LL);
    if (!result) {
      return result;
    }
    r->int top = a->top;
  }

  int top = a->top;
  if (top < 1) {
    return 1;
  }
  unint64_t v6 = 0LL;
  int d = r->d;
  BOOL v8 = a->d;
  do
  {
    unint64_t v10 = *v8++;
    unint64_t v9 = v10;
    *d++ = v6 | (2 * v10);
    unint64_t v6 = v10 >> 63;
    --top;
  }

  while (top);
  if ((v9 & 0x8000000000000000LL) == 0) {
    return 1;
  }
  int result = 1;
  unint64_t *d = 1LL;
  ++r->top;
  return result;
}

void bn_rshift_words(char *__dst, uint64_t a2, unsigned int a3, unint64_t a4)
{
  unint64_t v5 = __dst;
  unint64_t v6 = a3 >> 6;
  uint64_t v7 = a4 - v6;
  if (a4 <= v6)
  {
    if (!a4) {
      return;
    }
    size_t v13 = 8 * a4;
LABEL_14:
    bzero(__dst, v13);
    return;
  }

  char v9 = a3 & 0x3F;
  if ((a3 & 0x3F) != 0)
  {
    if (a4 - 1 > v6)
    {
      uint64_t v10 = ~v6 + a4;
      _BOOL1 v11 = (void *)(a2 + 8 * v6 + 8);
      char v12 = __dst;
      do
      {
        *(void *)char v12 = (*v11 << (64 - v9)) | (*(v11 - 1) >> v9);
        v12 += 8;
        ++v11;
        --v10;
      }

      while (v10);
    }

    *(void *)&__dst[8 * (a4 - 1 - v6)] = *(void *)(a2 + 8 * (a4 - 1)) >> v9;
  }

  else if (8 * v7)
  {
    memmove(__dst, (const void *)(a2 + 8 * v6), 8 * v7);
  }

  if (a3 >= 0x40)
  {
    size_t v13 = 8 * v6;
    __dst = &v5[8 * a4 + -8 * v6];
    goto LABEL_14;
  }

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
{
  if (n < 0)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/shift.c", 158);
    return 0;
  }

  else
  {
    int result = bn_wexpand(&r->d, a->top);
    if (result)
    {
      bn_rshift_words((char *)r->d, (uint64_t)a->d, n, a->top);
      r->int neg = a->neg;
      r->int top = a->top;
      bn_set_minimal_width((uint64_t)r);
      return 1;
    }
  }

  return result;
}

uint64_t bn_rshift_secret_shift(uint64_t a1, const BIGNUM *a2, unsigned int a3, BN_CTX *ctx)
{
  BOOL v8 = BN_CTX_get(ctx);
  if (v8 && (char v9 = (char **)v8, BN_copy((BIGNUM *)a1, a2)) && bn_wexpand((void **)v9, *(int *)(a1 + 8)))
  {
    int v10 = *(_DWORD *)(a1 + 8);
    if (v10)
    {
      int v11 = 0;
      unsigned int v12 = v10 << 6;
      uint64_t v13 = 1LL;
      do
      {
        bn_rshift_words(*v9, *(void *)a1, 1 << v11, *(int *)(a1 + 8));
        bn_select_words( *(uint64_t **)a1,  -(uint64_t)((a3 >> v11++) & 1),  (uint64_t *)*v9,  *(uint64_t **)a1,  *(int *)(a1 + 8));
      }

      while (v12 >> v11);
    }

    else
    {
      uint64_t v13 = 1LL;
    }
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  BN_CTX_end(ctx);
  return v13;
}

int BN_rshift1(BIGNUM *r, const BIGNUM *a)
{
  int result = bn_wexpand(&r->d, a->top);
  if (result)
  {
    int top = a->top;
    if (top)
    {
      int d = r->d;
      uint64_t v7 = a->d;
      if (top != 1LL)
      {
        BOOL v8 = v7 + 1;
        uint64_t v9 = top - 1LL;
        int v10 = r->d;
        do
        {
          *v10++ = *(__int128 *)(v8++ - 1) >> 1;
          --v9;
        }

        while (v9);
      }

      d[top - 1] = v7[top - 1] >> 1;
    }

    r->int top = top;
    r->int neg = a->neg;
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }

  return result;
}

int BN_set_bit(BIGNUM *a, int n)
{
  if (n < 0) {
    return 0;
  }
  char v2 = n;
  signed int v4 = n >> 6;
  if (a->top <= (signed int)(n >> 6))
  {
    int result = bn_wexpand(&a->d, (v4 + 1));
    if (!result) {
      return result;
    }
    uint64_t top = a->top;
    a->uint64_t top = v4 + 1;
  }

  int result = 1;
  a->d[v4] |= 1LL << (v2 & 0x3F);
  return result;
}

uint64_t bn_is_bit_set_words(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a3 >> 6 >= a2) {
    return 0LL;
  }
  else {
    return (*(void *)(a1 + 8 * (a3 >> 6)) >> a3) & 1LL;
  }
}

int BN_is_bit_set(const BIGNUM *a, int n)
{
  else {
    return (a->d[v2] >> n) & 1;
  }
  return v3;
}

unint64_t BN_count_low_zero_bits(unint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  unint64_t v2 = (unint64_t **)result;
  uint64_t v3 = 0LL;
  LODWORD(result) = 0;
  uint64_t v4 = 0LL;
  unint64_t v5 = *v2;
  uint64_t v6 = v1 << 6;
  do
  {
    unint64_t v7 = *v5++;
    uint64_t v8 = (uint64_t)(((v7 << 32) - 1) & ~(v7 << 32)) >> 63;
    int v9 = v8 & 0x20;
    unint64_t v10 = v8 & HIDWORD(v7) | v7 & ~v8;
    uint64_t v11 = (uint64_t)(((v10 << 48) - 1) & ~(v10 << 48)) >> 63;
    int v12 = v11 & 0x10;
    unint64_t v13 = v11 & (v10 >> 16) | v10 & ~v11;
    uint64_t v14 = (v7 - 1) & ~v7;
    uint64_t v15 = (uint64_t)(((v13 << 56) - 1) & ~(v13 << 56)) >> 63;
    int v16 = v15 & 8;
    int v17 = v12 | v9;
    unint64_t v18 = v15 & (v13 >> 8) | v13 & ~v15;
    uint64_t v19 = (uint64_t)(((v18 << 60) - 1) & ~(v18 << 60)) >> 63;
    int v20 = v19 & 4;
    uint64_t v21 = v19 & (v18 >> 4) | v18 & ~v19;
    int v22 = v17 | v16;
    uint64_t v23 = (((v21 << 62) - 1) & ~(v21 << 62)) >> 63;
    int v24 = v23 & 2;
    uint64_t v25 = v23 & (v21 >> 2) | v21 & ~(_DWORD)v23;
    LODWORD(v23) = (v14 >> 63) | v4;
    v4 |= ~(v14 >> 63);
    int result = (v3 | v22 | v20 | v24 | ((((v25 << 63) - 1) & (unint64_t)~(v25 << 63)) >> 63)) & ~(_DWORD)v23 | result;
    v3 += 64LL;
  }

  while (v6 != v3);
  return result;
}

uint64_t bn_jacobi(const BIGNUM *a1, const BIGNUM *a2, BN_CTX *a3)
{
  if (!BN_is_odd((uint64_t)a2))
  {
    int v6 = 104;
    int v7 = 73;
    goto LABEL_5;
  }

  if (!BN_is_negative((uint64_t)a2))
  {
    BN_CTX_start(a3);
    int v9 = BN_CTX_get(a3);
    unint64_t v10 = BN_CTX_get(a3);
    if (v10)
    {
      uint64_t v11 = v10;
      if (BN_copy(v9, a1))
      {
        if (BN_copy(v11, a2))
        {
          unsigned int v12 = 1;
          if (BN_is_zero((uint64_t)v9))
          {
LABEL_10:
            else {
              uint64_t v8 = 0LL;
            }
            goto LABEL_39;
          }

          unint64_t v13 = v11;
          while (1)
          {
            uint64_t v11 = v9;
            int v9 = v13;
            int v14 = -1;
            do
              ++v14;
            while (!BN_is_bit_set(v11, v14));
            if (!BN_rshift(v11, v11, v14)) {
              break;
            }
            if ((v14 & 1) != 0)
            {
              if (v9->top) {
                unint64_t v15 = *v9->d;
              }
              else {
                LOBYTE(v15) = 0;
              }
              v12 *= bn_jacobi_tab[v15 & 7];
            }

            int top = v11->top;
            if (v11->neg)
            {
              if (top) {
                unint64_t v17 = *v11->d;
              }
              else {
                LOBYTE(v17) = 0;
              }
              LOBYTE(v1bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = ~(_BYTE)v17;
            }

            else if (top)
            {
              unint64_t v18 = *v11->d;
            }

            else
            {
              LOBYTE(v1bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 0;
            }

            if (v9->top) {
              unint64_t v19 = *v9->d;
            }
            else {
              LOBYTE(v19) = 0;
            }
            if (!BN_nnmod(v9, v9, v11, a3)) {
              break;
            }
            v11->int neg = 0;
            BOOL is_zero = BN_is_zero((uint64_t)v9);
            unint64_t v13 = v11;
            if (is_zero) {
              goto LABEL_10;
            }
          }
        }
      }
    }

    uint64_t v8 = 4294967294LL;
LABEL_39:
    BN_CTX_end(a3);
    return v8;
  }

  int v6 = 109;
  int v7 = 79;
LABEL_5:
  ERR_put_error(3, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/jacobi.c", v7);
  return 4294967294LL;
}

int BIO_puts(BIO *bp, const char *buf)
{
  size_t v4 = strlen(buf);
  if (!(v4 >> 31)) {
    return BIO_write(bp, buf, v4);
  }
  ERR_put_error(17, 0, 69, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio.c", 201);
  return -1;
}

uint64_t BIO_int_ctrl(BIO *bp, int cmd, uint64_t larg, int iarg)
{
  int parg = iarg;
  return BIO_ctrl(bp, cmd, larg, &parg);
}

void BIO_set_flags(BIO *b, int flags)
{
  b->init |= flags;
}

uint64_t BIO_should_write(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) & 2;
}

uint64_t BIO_should_io_special(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) & 4;
}

int BIO_get_retry_reason(BIO *bio)
{
  return bio->shutdown;
}

uint64_t BIO_set_retry_write(uint64_t result)
{
  *(_DWORD *)(result + 24) |= 0xAu;
  return result;
}

uint64_t BIO_clear_retry_flags(uint64_t result)
{
  *(void *)(result + 24) = *(_DWORD *)(result + 24) & 0xFFFFFFF0;
  return result;
}

int BIO_method_type(const BIO *b)
{
  return b->method->type;
}

BIO *__cdecl BIO_find_type(BIO *b, int bio_type)
{
  for (; b; BIGNUM b = (BIO *)b->ptr)
  {
    if (b->method)
    {
      int type = b->method->type;
      if ((_BYTE)bio_type)
      {
        if (type == bio_type) {
          return b;
        }
      }

      else if ((type & bio_type) != 0)
      {
        return b;
      }
    }
  }

  return b;
}

int BIO_indent(BIO *b, int indent, int max)
{
  else {
    int v4 = indent;
  }
  int v5 = v4 + 1;
  while (--v5)
  {
    if (BIO_puts(b, " ") != 1) {
      return 0;
    }
  }

  return 1;
}

void *EVP_AEAD_CTX_new(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = OPENSSL_malloc(0x248uLL);
  bzero(v8, 0x248uLL);
  if (!EVP_AEAD_CTX_init(v8, a1, a2, a3, a4) && v8)
  {
    if (*v8)
    {
      (*(void (**)(void *))(*v8 + 24LL))(v8);
      void *v8 = 0LL;
    }

    OPENSSL_free(v8);
    return 0LL;
  }

  return v8;
}

uint64_t EVP_AEAD_CTX_init(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a2 + 8)) {
    return EVP_AEAD_CTX_init_with_direction(a1, (unsigned __int8 *)a2, a3, a4, a5, 0LL);
  }
  ERR_put_error(30, 0, 124, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", 65);
  *a1 = 0LL;
  return 0LL;
}

uint64_t EVP_AEAD_CTX_seal( uint64_t a1, char *a2, unint64_t *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, size_t a8)
{
  if (__CFADD__(a8, *(unsigned __int8 *)(*(void *)a1 + 2LL)))
  {
    int v12 = 117;
    int v13 = 123;
LABEL_10:
    ERR_put_error(30, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/cipher/aead.c", v13);
    goto LABEL_11;
  }

  if (a4 < a8)
  {
    int v12 = 103;
    int v13 = 128;
    goto LABEL_10;
  }

  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    int v12 = 115;
    int v13 = 133;
    goto LABEL_10;
  }

  int v16 = *(unsigned int (**)(uint64_t, char *, char *, unint64_t *, size_t))(*(void *)a1 + 40LL);
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  if (v16(a1, a2, &a2[a8], &v17, a4 - a8))
  {
    unint64_t v14 = v17 + a8;
    uint64_t result = 1LL;
    goto LABEL_14;
  }

int RSA_up_ref(RSA *r)
{
  return 1;
}

int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb)
{
  return 0;
}

uint64_t RSA_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 8));
}

uint64_t rsa_default_size(uint64_t a1)
{
  return BN_num_bytes(*(const BIGNUM **)(a1 + 8));
}

BOOL RSA_encrypt(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if (!a1)
  {
    int v10 = 67;
    int v11 = 125;
    goto LABEL_7;
  }

  if (!a2)
  {
    int v10 = 67;
    int v11 = 129;
    goto LABEL_7;
  }

  if (BN_num_bytes(*(const BIGNUM **)(a1 + 8)) < 0x401)
  {
    uint64_t v18 = 0LL;
    unint64_t v19 = 0LL;
    uint64_t v14 = ccrsa_import_pub_n();
    unint64_t v15 = malloc(24 * v14 + 40);
    if (!v15)
    {
      if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        RSA_encrypt_cold_1();
      }
      return 0LL;
    }

    int v16 = v15;
    void *v15 = v14;
    if (ccrsa_import_pub())
    {
      OPENSSL_free(v19);
      free(v16);
      return 0LL;
    }

    *a2 = ccrsa_block_size();
    switch(a7)
    {
      case 4:
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
          RSA_encrypt_cold_2();
        }
        int v17 = 175;
        break;
      case 3:
        if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
          RSA_encrypt_cold_3();
        }
        int v17 = 180;
        break;
      case 1:
        ccrng();
        BOOL v12 = ccrsa_encrypt_eme_pkcs1v15() == 0;
LABEL_32:
        OPENSSL_free(v19);
        free(v16);
        return v12;
      default:
LABEL_31:
        BOOL v12 = 0LL;
        goto LABEL_32;
    }

    ERR_put_error(4, 0, 143, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v17);
    goto LABEL_31;
  }

  int v10 = 500;
  int v11 = 133;
LABEL_7:
  ERR_put_error(4, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v11);
  return 0LL;
}

uint64_t RSA_padding_check_PKCS1_OAEP_mgf1()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    RSA_padding_check_PKCS1_OAEP_mgf1_cold_1();
  }
  return 0LL;
}

uint64_t RSA_padding_add_PKCS1_OAEP_mgf1()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    RSA_padding_add_PKCS1_OAEP_mgf1_cold_1();
  }
  return 0LL;
}

int RSA_verify( int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigbuf, unsigned int siglen, RSA *rsa)
{
  if (!rsa)
  {
    int v12 = 67;
    int v13 = 391;
    goto LABEL_11;
  }

  uint64_t v7 = *(void *)&siglen;
  size_t v9 = *(void *)&m_length;
  if (BN_num_bytes((const BIGNUM *)rsa->version) >= 0x401)
  {
    int v12 = 500;
    int v13 = 395;
LABEL_11:
    ERR_put_error(4, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", v13);
    return 0;
  }

  unsigned int v14 = BN_num_bytes((const BIGNUM *)rsa->version);
  size_t v22 = 0xAAAAAAAAAAAAAAAALL;
  __s2 = 0LL;
  size_t v21 = 0xAAAAAAAAAAAAAAAALL;
  int v20 = 0;
  if (!rsa->version || !rsa->meth)
  {
    int v12 = 144;
    int v13 = 404;
    goto LABEL_11;
  }

  if (type == 114 && v9 != 36)
  {
    int v12 = 125;
    int v13 = 409;
    goto LABEL_11;
  }

  int v17 = (unsigned __int8 *)malloc(v14);
  if (!v17)
  {
    int v12 = 65;
    int v13 = 415;
    goto LABEL_11;
  }

  unint64_t v19 = v17;
  if (RSA_verify_raw((uint64_t)rsa, &v21, v17, v18, (uint64_t)sigbuf, v7, 1)
    && RSA_add_pkcs1_prefix(&__s2, &v22, &v20, type, m, v9))
  {
    if (v21 == v22 && !memcmp(v19, __s2, v21))
    {
      int v15 = 1;
      goto LABEL_20;
    }

    ERR_put_error(4, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/apple/crypto/boringssl_crypto_rsa.m", 428);
  }

  int v15 = 0;
LABEL_20:
  free(v19);
  if (v20 && __s2) {
    free(__s2);
  }
  return v15;
}

uint64_t RSA_add_pkcs1_prefix(void *a1, size_t *a2, _DWORD *a3, int a4, const void *a5, size_t a6)
{
  if (a4 == 114)
  {
    if (a6 == 36)
    {
      *a1 = a5;
      *a2 = 36LL;
      *a3 = 0;
      return 1LL;
    }

    int v14 = 125;
    int v15 = 516;
  }

  else
  {
    uint64_t v12 = 0LL;
    int v13 = 4;
    while (v13 != a4)
    {
      int v13 = *(_DWORD *)&kPKCS1SigPrefixes[v12 + 24];
      v12 += 24LL;
      if (v12 == 144)
      {
        int v14 = 142;
        int v15 = 559;
        goto LABEL_14;
      }
    }

    int v16 = (char *)&kPKCS1SigPrefixes[v12];
    size_t v17 = kPKCS1SigPrefixes[v12 + 4];
    if ((int)v17 + (int)a6 >= v17)
    {
      size_t v18 = (v17 + a6);
      unint64_t v19 = (char *)malloc(v18);
      if (v19)
      {
        int v20 = v19;
        memcpy(v19, v16 + 5, v17);
        memcpy(&v20[v17], a5, a6);
        *a1 = v20;
        *a2 = v18;
        uint64_t result = 1LL;
        *a3 = 1;
        return result;
      }

      int v14 = 65;
      int v15 = 545;
    }

    else
    {
      int v14 = 140;
      int v15 = 539;
    }
  }

double RSA_default_method_init()
{
  double result = 0.0;
  xmmword_18C4C4E18 = 0u;
  unk_18C4C4E28 = 0u;
  xmmword_18C4C4DF8 = 0u;
  unk_18C4C4E08 = 0u;
  RSA_default_method_storage = 0u;
  BYTE4(RSA_default_method_storage) = 1;
  return result;
}

uint64_t RSA_decrypt()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    RSA_decrypt_cold_1();
  }
  return 0LL;
}

uint64_t rsa_default_sign_raw()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    rsa_default_sign_raw_cold_1();
  }
  return 0LL;
}

uint64_t RSA_sign_raw()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    RSA_sign_raw_cold_1();
  }
  return 0LL;
}

int RSA_sign( int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigret, unsigned int *siglen, RSA *rsa)
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    RSA_sign_cold_1();
  }
  return 0;
}

uint64_t RSA_sign_pss_mgf1()
{
  if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
    RSA_sign_pss_mgf1_cold_1();
  }
  return 0LL;
}

uint64_t *EC_GFp_nistp224_method()
{
  return &EC_GFp_nistp224_method_storage;
}

void EC_GFp_nistp224_method_init()
{
  EC_GFp_nistp224_method_storage = (uint64_t)ec_GFp_nistp224_point_get_affine_coordinates;
  qword_18C4C4F00 = (uint64_t)ec_GFp_nistp224_add;
  unk_18C4C4F08 = ec_GFp_nistp224_dbl;
  qword_18C4C4F10 = (uint64_t)ec_GFp_nistp224_point_mul;
  unk_18C4C4F18 = ec_GFp_nistp224_point_mul_base;
  qword_18C4C4F28 = (uint64_t)ec_GFp_nistp224_point_mul_public;
  qword_18C4C4F48 = (uint64_t)ec_GFp_nistp224_felem_mul;
  unk_18C4C4F50 = ec_GFp_nistp224_felem_sqr;
  qword_18C4C4F58 = (uint64_t)ec_GFp_simple_felem_to_bytes;
  unk_18C4C4F60 = ec_GFp_simple_felem_from_bytes;
  qword_18C4C4F78 = (uint64_t)ec_simple_scalar_inv0_montgomery;
  unk_18C4C4F80 = ec_simple_scalar_to_montgomery_inv_vartime;
  qword_18C4C4F88 = (uint64_t)ec_GFp_simple_cmp_x_coordinate;
}

uint64_t ec_GFp_nistp224_point_get_affine_coordinates(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (ec_GFp_simple_is_at_infinity(a1, a2))
  {
    ERR_put_error(15, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/p224-64.c", 868);
    return 0LL;
  }

  else
  {
    uint64_t v8 = *(__int128 *)(a2 + 152) >> 48;
    uint64_t v9 = *(__int128 *)(a2 + 160) >> 40;
    __int128 v10 = *(_OWORD *)(a2 + 144);
    v31.i64[0] = v10 & 0xFFFFFFFFFFFFFFLL;
    v31.i64[1] = (v10 >> 56) & 0xFFFFFFFFFFFFFFLL;
    v11.i64[0] = 0xAAAAAAAAAAAAAAAALL;
    v11.i64[1] = 0xAAAAAAAAAAAAAAAALL;
    v30[0] = v11;
    v30[1] = v11;
    v29[5] = v11;
    v29[6] = v11;
    v29[3] = v11;
    _OWORD v29[4] = v11;
    v29[1] = v11;
    __int128 v29[2] = v11;
    v29[0] = v11;
    uint64_t v32 = v8 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v33 = v9 & 0xFFFFFFFFFFFFFFLL;
    int8x16_t v44 = v11;
    int8x16_t v45 = v11;
    v43[0] = v11;
    v43[1] = v11;
    v42[0] = v11;
    v42[1] = v11;
    v41[0] = v11;
    v41[1] = v11;
    int8x16_t v39 = v11;
    int8x16_t v40 = v11;
    int8x16_t v37 = v11;
    int8x16_t v38 = v11;
    int8x16_t v35 = v11;
    int8x16_t v36 = v11;
    int8x16_t v34 = v11;
    p224_felem_square(&v34, (unint64_t *)&v31);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v31, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v31, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    uint64_t v12 = 5LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v43);
      p224_felem_reduce(v43, (unint64_t *)&v34);
      --v12;
    }

    while (v12);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)&v44);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    uint64_t v13 = 11LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v42);
      p224_felem_reduce(v42, (unint64_t *)&v34);
      --v13;
    }

    while (v13);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v42, (unint64_t *)v43);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v43);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    uint64_t v14 = 23LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v42);
      p224_felem_reduce(v42, (unint64_t *)&v34);
      --v14;
    }

    while (v14);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v42, (unint64_t *)v43);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v42);
    p224_felem_reduce(v41, (unint64_t *)&v34);
    uint64_t v15 = 47LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v41);
      p224_felem_reduce(v41, (unint64_t *)&v34);
      --v15;
    }

    while (v15);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v42, (unint64_t *)v41);
    p224_felem_reduce(v42, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)v42);
    p224_felem_reduce(v41, (unint64_t *)&v34);
    uint64_t v16 = 23LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v41);
      p224_felem_reduce(v41, (unint64_t *)&v34);
      --v16;
    }

    while (v16);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)v41);
    p224_felem_reduce(v43, (unint64_t *)&v34);
    uint64_t v17 = 6LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)v43);
      p224_felem_reduce(v43, (unint64_t *)&v34);
      --v17;
    }

    while (v17);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)v43, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_square(&v34, (unint64_t *)&v44);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v44, (unint64_t *)&v31);
    p224_felem_reduce(&v44, (unint64_t *)&v34);
    uint64_t v18 = 97LL;
    do
    {
      p224_felem_square(&v34, (unint64_t *)&v44);
      p224_felem_reduce(&v44, (unint64_t *)&v34);
      --v18;
    }

    while (v18);
    p224_felem_mul((uint64_t)&v34, (unint64_t *)&v44, (unint64_t *)v42);
    p224_felem_reduce(v30, (unint64_t *)&v34);
    p224_felem_square(v29, (unint64_t *)v30);
    p224_felem_reduce(&v31, (unint64_t *)v29);
    if (a3)
    {
      uint64_t v19 = *(void *)(a2 + 8);
      *((void *)&v20 + 1) = v19;
      *(void *)&__int128 v20 = *(void *)a2;
      v34.i64[0] = *(void *)a2 & 0xFFFFFFFFFFFFFFLL;
      v34.i64[1] = (v20 >> 56) & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v20 + 1) = *(void *)(a2 + 16);
      *(void *)&__int128 v20 = v19;
      uint64_t v21 = v20 >> 48;
      __int128 v22 = *(_OWORD *)(a2 + 16);
      v23.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v23.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      int8x16_t v44 = v23;
      int8x16_t v45 = v23;
      v35.i64[0] = v21 & 0xFFFFFFFFFFFFFFLL;
      v35.i64[1] = (v22 >> 40) & 0xFFFFFFFFFFFFFFLL;
      p224_felem_mul((uint64_t)v29, (unint64_t *)&v34, (unint64_t *)&v31);
      p224_felem_reduce(&v44, (unint64_t *)v29);
      p224_felem_to_generic(a3, &v44);
    }

    if (a4)
    {
      v24.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v24.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      int8x16_t v44 = v24;
      int8x16_t v45 = v24;
      uint64_t v25 = *(void *)(a2 + 80);
      *((void *)&v26 + 1) = v25;
      *(void *)&__int128 v26 = *(void *)(a2 + 72);
      v34.i64[0] = v26 & 0xFFFFFFFFFFFFFFLL;
      v34.i64[1] = (v26 >> 56) & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v26 + 1) = *(void *)(a2 + 88);
      *(void *)&__int128 v26 = v25;
      uint64_t v27 = (v26 >> 48) & 0xFFFFFFFFFFFFFFLL;
      __int128 v28 = *(_OWORD *)(a2 + 88);
      v35.i64[0] = v27;
      v35.i64[1] = (v28 >> 40) & 0xFFFFFFFFFFFFFFLL;
      p224_felem_mul((uint64_t)v29, (unint64_t *)&v31, (unint64_t *)v30);
      p224_felem_reduce(&v31, (unint64_t *)v29);
      p224_felem_mul((uint64_t)v29, (unint64_t *)&v34, (unint64_t *)&v31);
      p224_felem_reduce(&v44, (unint64_t *)v29);
      p224_felem_to_generic(a4, &v44);
    }

    return 1LL;
  }

uint64_t *ec_GFp_nistp224_add(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3[1];
  *((void *)&v6 + 1) = v5;
  *(void *)&__int128 v6 = *a3;
  v34.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v34.i64[1] = (v6 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v6 + 1) = a3[2];
  *(void *)&__int128 v6 = v5;
  uint64_t v7 = (v6 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v8 = *((_OWORD *)a3 + 1);
  uint64_t v35 = v7;
  uint64_t v36 = (v8 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v9 = a3[10];
  *((void *)&v8 + 1) = v9;
  *(void *)&__int128 v8 = a3[9];
  v31.i64[0] = v8 & 0xFFFFFFFFFFFFFFLL;
  v31.i64[1] = (v8 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v8 + 1) = a3[11];
  *(void *)&__int128 v8 = v9;
  uint64_t v10 = (v8 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v11 = *(_OWORD *)(a3 + 11);
  uint64_t v32 = v10;
  uint64_t v33 = (v11 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v12 = a3[19];
  *((void *)&v11 + 1) = v12;
  *(void *)&__int128 v11 = a3[18];
  v28.i64[0] = v11 & 0xFFFFFFFFFFFFFFLL;
  v28.i64[1] = (v11 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v11 + 1) = a3[20];
  *(void *)&__int128 v11 = v12;
  uint64_t v13 = (v11 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v14 = *((_OWORD *)a3 + 10);
  uint64_t v29 = v13;
  uint64_t v30 = (v14 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v15 = a4[1];
  *((void *)&v14 + 1) = v15;
  *(void *)&__int128 v14 = *a4;
  v27[0] = *a4 & 0xFFFFFFFFFFFFFFLL;
  v27[1] = (v14 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v14 + 1) = a4[2];
  *(void *)&__int128 v14 = v15;
  unint64_t v16 = (v14 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v17 = *((_OWORD *)a4 + 1);
  int64x2_t v27[2] = v16;
  _OWORD v27[3] = (v17 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v18 = a4[10];
  *((void *)&v17 + 1) = v18;
  *(void *)&__int128 v17 = a4[9];
  v26[0] = v17 & 0xFFFFFFFFFFFFFFLL;
  v26[1] = (v17 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v17 + 1) = a4[11];
  *(void *)&__int128 v17 = v18;
  unint64_t v19 = (v17 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v20 = *(_OWORD *)(a4 + 11);
  v26[2] = v19;
  _OWORD v26[3] = (v20 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v21 = a4[19];
  *((void *)&v20 + 1) = v21;
  *(void *)&__int128 v20 = a4[18];
  v25[0] = v20 & 0xFFFFFFFFFFFFFFLL;
  v25[1] = (v20 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v20 + 1) = a4[20];
  *(void *)&__int128 v20 = v21;
  unint64_t v22 = (v20 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v23 = *((_OWORD *)a4 + 10);
  uint64_t v25[2] = v22;
  _OWORD v25[3] = (v23 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_point_add(&v34, (int8x16_t *)&v31, &v28, &v34, &v31, (uint64_t)&v28, 0, v27, v26, v25);
  p224_felem_to_generic(a2, &v34);
  p224_felem_to_generic(a2 + 9, &v31);
  return p224_felem_to_generic(a2 + 18, &v28);
}

uint64_t *ec_GFp_nistp224_dbl(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3[1];
  *((void *)&v5 + 1) = v4;
  *(void *)&__int128 v5 = *a3;
  v21.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v21.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v5 + 1) = a3[2];
  *(void *)&__int128 v5 = v4;
  uint64_t v6 = (v5 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v7 = *((_OWORD *)a3 + 1);
  uint64_t v22 = v6;
  uint64_t v23 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v8 = a3[10];
  *((void *)&v7 + 1) = v8;
  *(void *)&__int128 v7 = a3[9];
  v18.i64[0] = v7 & 0xFFFFFFFFFFFFFFLL;
  v18.i64[1] = (v7 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v7 + 1) = a3[11];
  *(void *)&__int128 v7 = v8;
  uint64_t v9 = (v7 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v10 = *(_OWORD *)(a3 + 11);
  uint64_t v19 = v9;
  uint64_t v20 = (v10 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v11 = a3[19];
  *((void *)&v10 + 1) = v11;
  *(void *)&__int128 v10 = a3[18];
  v15.i64[0] = v10 & 0xFFFFFFFFFFFFFFLL;
  v15.i64[1] = (v10 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v10 + 1) = a3[20];
  *(void *)&__int128 v10 = v11;
  uint64_t v12 = (v10 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v13 = *((_OWORD *)a3 + 10);
  uint64_t v16 = v12;
  uint64_t v17 = (v13 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_point_double(&v21, (int8x16_t *)&v18, (int8x16_t *)&v15, (unint64_t *)&v21, &v18, &v15);
  p224_felem_to_generic(a2, &v21);
  p224_felem_to_generic(a2 + 9, &v18);
  return p224_felem_to_generic(a2 + 18, &v15);
}

uint64_t *ec_GFp_nistp224_point_mul(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  memset(__b, 170, sizeof(__b));
  ec_GFp_nistp224_make_precomp((uint64_t)__b, a3);
  v6.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v25[0] = v6;
  v25[1] = v6;
  int64x2_t v23 = (int64x2_t)v6;
  int8x16_t v24 = v6;
  int64x2_t v21 = (int64x2_t)v6;
  int8x16_t v22 = v6;
  int8x16_t v19 = v6;
  int8x16_t v20 = v6;
  int8x16_t v26 = 0u;
  int8x16_t v27 = 0u;
  int64x2_t v28 = 0u;
  int8x16_t v29 = 0u;
  int v7 = 1;
  unint64_t v8 = 220LL;
  int64x2_t v30 = 0u;
  int8x16_t v31 = 0u;
  do
  {
    if (!v7) {
      p224_point_double(&v26, (int8x16_t *)&v28, (int8x16_t *)&v30, (unint64_t *)&v26, &v28, &v30);
    }
    if (-858993459 * v8 < 0x33333334)
    {
      if (v8 <= 0xDB) {
        uint64_t v10 = (*(void *)(a4 + (((v8 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v8 + 4)) & 1LL;
      }
      else {
        uint64_t v10 = 0LL;
      }
      unint64_t v9 = v8 - 1;
      if (v8 - 1 <= 0xDF) {
        uint64_t v11 = (*(void *)(a4 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v9) & 1LL;
      }
      else {
        uint64_t v11 = 0LL;
      }
      unint64_t v12 = v11 | (32 * v10) | (16
                              * ((*(void *)(a4 + (((v8 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v8 + 3)) & 1LL)) | (8 * ((*(void *)(a4 + (((v8 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v8 + 2)) & 1LL)) | (4 * ((*(void *)(a4 + (((v8 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v8 + 1)) & 1LL)) | (2 * ((*(void *)(a4 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v8) & 1LL));
      uint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
      ec_GFp_nistp_recode_scalar_bits(&v18, &v17, v12);
      p224_select_point(v17, 17LL, (uint64_t)__b, &v19);
      p224_felem_neg(v25, &v21);
      uint64_t v13 = 0LL;
      int8x16_t v14 = (int8x16_t)vdupq_n_s64(-v18);
      do
      {
        *(int8x16_t *)((char *)&v21 + v13 * 16) = vbslq_s8(v14, v25[v13], *(int8x16_t *)((char *)&v21 + v13 * 16));
        ++v13;
      }

      while (v13 != 2);
      if (v7)
      {
        int64x2_t v28 = v21;
        int8x16_t v29 = v22;
        int64x2_t v30 = v23;
        int8x16_t v31 = v24;
        int8x16_t v26 = v19;
        int8x16_t v27 = v20;
      }

      else
      {
        p224_point_add( &v26,  (int8x16_t *)&v28,  (int8x16_t *)&v30,  &v26,  &v28,  (uint64_t)&v30,  0,  (unint64_t *)&v19,  (unint64_t *)&v21,  (unint64_t *)&v23);
      }

      int v7 = 0;
    }

    else
    {
      unint64_t v9 = v8 - 1;
    }

    unint64_t v8 = v9;
  }

  while (v9 < 0xDD);
  p224_felem_to_generic(a2, &v26);
  p224_felem_to_generic(a2 + 9, &v28);
  return p224_felem_to_generic(a2 + 18, &v30);
}

uint64_t *ec_GFp_nistp224_point_mul_base(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  char v5 = 0;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  v6.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  int64x2_t v14 = v6;
  int64x2_t v15 = v6;
  int64x2_t v12 = v6;
  int64x2_t v13 = v6;
  int8x16_t v10 = (int8x16_t)v6;
  int64x2_t v11 = v6;
  int8x16_t v16 = 0u;
  int64x2_t v17 = 0u;
  int64x2_t v18 = 0u;
  int64x2_t v19 = 0u;
  unint64_t v7 = 111LL;
  int64x2_t v20 = 0u;
  int64x2_t v21 = 0u;
  do
  {
    if ((v5 & 1) != 0) {
      p224_point_double(&v16, (int8x16_t *)&v18, (int8x16_t *)&v20, (unint64_t *)&v16, &v18, &v20);
    }
    p224_select_point( (8 * ((*(void *)(a3 + (((v7 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 - 80)) & 1LL)) | (4 * ((*(void *)(a3 + (((v7 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 - 72)) & 1LL)) | (2 * ((*(void *)(a3 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v7) & 1LL)) | (*(void *)(a3 + (((v7 - 56) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 - 56)) & 1LL,  16LL,  (uint64_t)&unk_187604AF8,  &v10);
    if ((v5 & 1) != 0)
    {
      p224_point_add( &v16,  (int8x16_t *)&v18,  (int8x16_t *)&v20,  &v16,  &v18,  (uint64_t)&v20,  1,  (unint64_t *)&v10,  (unint64_t *)&v12,  (unint64_t *)&v14);
    }

    else
    {
      int64x2_t v18 = v12;
      int64x2_t v19 = v13;
      int64x2_t v20 = v14;
      int64x2_t v21 = v15;
      int8x16_t v16 = v10;
      int64x2_t v17 = v11;
    }

    p224_select_point( (8 * ((*(void *)(a3 + (((v7 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 + 84)) & 1LL)) | (4 * ((*(void *)(a3 + (((v7 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 + 28)) & 1LL)) | (2 * ((*(void *)(a3 + (((v7 - 28) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 - 28)) & 1LL)) | (*(void *)(a3 + (((v7 - 84) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v7 - 84)) & 1LL,  16LL,  (uint64_t)&g_p224_pre_comp,  &v10);
    char v5 = 1;
    p224_point_add( &v16,  (int8x16_t *)&v18,  (int8x16_t *)&v20,  &v16,  &v18,  (uint64_t)&v20,  1,  (unint64_t *)&v10,  (unint64_t *)&v12,  (unint64_t *)&v14);
    unint64_t v8 = v7 - 85;
    --v7;
  }

  while (v8 < 0x1C);
  p224_felem_to_generic(a2, &v16);
  p224_felem_to_generic(a2 + 9, &v18);
  return p224_felem_to_generic(a2 + 18, &v20);
}

uint64_t *ec_GFp_nistp224_point_mul_public(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  memset(__b, 170, sizeof(__b));
  ec_GFp_nistp224_make_precomp((uint64_t)__b, a4);
  int8x16_t v29 = 0u;
  int64x2_t v30 = 0u;
  int64x2_t v31 = 0u;
  int64x2_t v32 = 0u;
  int64x2_t v33 = 0u;
  int64x2_t v34 = 0u;
  int v8 = 1;
  unint64_t v9 = 220LL;
  do
  {
    if (!v8) {
      p224_point_double(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, (unint64_t *)&v29, &v31, &v33);
    }
    if (v9 <= 0x1B)
    {
      int8x16_t v10 = (unint64_t *)((char *)&g_p224_pre_comp
                               + 96
                               * ((8
                                 * ((*(void *)(a3 + (((v9 + 196) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 - 60)) & 1)) | (4 * ((*(void *)(a3 + (((v9 + 140) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 - 116)) & 1)) | (2 * ((*(void *)(a3 + (((v9 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 84)) & 1)) | (*(void *)(a3 + (((v9 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 28)) & 1));
      p224_point_add( &v29,  (int8x16_t *)&v31,  (int8x16_t *)&v33,  &v29,  &v31,  (uint64_t)&v33,  1,  v10 + 192,  v10 + 196,  v10 + 200);
      if (v8) {
        ec_GFp_nistp224_point_mul_public_cold_1();
      }
      int64x2_t v11 = (unint64_t *)((char *)&g_p224_pre_comp
                               + 96
                               * ((8
                                 * ((*(void *)(a3 + (((v9 + 168) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 - 88)) & 1)) | (4 * ((*(void *)(a3 + (((v9 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 112)) & 1)) | (2 * ((*(void *)(a3 + (((v9 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 56)) & 1)) | (*(void *)(a3 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v9) & 1));
      p224_point_add(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, &v29, &v31, (uint64_t)&v33, 1, v11, v11 + 4, v11 + 8);
    }

    if (-858993459 * v9 < 0x33333334)
    {
      if (v9 <= 0xDB) {
        uint64_t v12 = (*(void *)(a5 + (((v9 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 4)) & 1LL;
      }
      else {
        uint64_t v12 = 0LL;
      }
      if (v9 - 1 <= 0xDF) {
        uint64_t v13 = (*(void *)(a5 + (((v9 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 - 1)) & 1LL;
      }
      else {
        uint64_t v13 = 0LL;
      }
      unint64_t v14 = v13 | (32 * v12) | (16
                              * ((*(void *)(a5 + (((v9 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 3)) & 1LL)) | (8 * ((*(void *)(a5 + (((v9 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 2)) & 1LL)) | (4 * ((*(void *)(a5 + (((v9 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v9 + 1)) & 1LL)) | (2 * ((*(void *)(a5 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v9) & 1LL));
      unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
      ec_GFp_nistp_recode_scalar_bits(&v22, &v21, v14);
      int64x2_t v15 = (int64x2_t *)&__b[6 * v21];
      int64x2_t v16 = v15[3];
      int64x2_t v25 = v15[2];
      int64x2_t v26 = v16;
      int64x2_t v17 = v15[5];
      int64x2_t v27 = v15[4];
      int64x2_t v28 = v17;
      int64x2_t v18 = v15[1];
      int8x16_t v23 = *(int8x16_t *)v15;
      int64x2_t v24 = v18;
      if (v22) {
        p224_felem_neg((int8x16_t *)&v25, &v25);
      }
      if (v8)
      {
        int64x2_t v31 = v25;
        int64x2_t v32 = v26;
        int64x2_t v33 = v27;
        int64x2_t v34 = v28;
        int8x16_t v29 = v23;
        int64x2_t v30 = v24;
      }

      else
      {
        p224_point_add( &v29,  (int8x16_t *)&v31,  (int8x16_t *)&v33,  &v29,  &v31,  (uint64_t)&v33,  0,  (unint64_t *)&v23,  (unint64_t *)&v25,  (unint64_t *)&v27);
      }

      int v8 = 0;
      --v9;
    }

    else
    {
      --v9;
    }
  }

  while (v9 < 0xDD);
  p224_felem_to_generic(a2, &v29);
  p224_felem_to_generic(a2 + 9, &v31);
  return p224_felem_to_generic(a2 + 18, &v33);
}

uint64_t *ec_GFp_nistp224_felem_mul(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[5] = v5;
  v14[6] = v5;
  _OWORD v14[3] = v5;
  _OWORD v14[4] = v5;
  v14[1] = v5;
  void v14[2] = v5;
  v14[0] = v5;
  uint64_t v6 = a3[1];
  *((void *)&v7 + 1) = v6;
  *(void *)&__int128 v7 = *a3;
  v16.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v16.i64[1] = (v7 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v7 + 1) = a3[2];
  *(void *)&__int128 v7 = v6;
  uint64_t v8 = (v7 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v9 = *((_OWORD *)a3 + 1);
  uint64_t v17 = v8;
  uint64_t v18 = (v9 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v10 = a4[1];
  *((void *)&v9 + 1) = v10;
  *(void *)&__int128 v9 = *a4;
  v15[0] = *a4 & 0xFFFFFFFFFFFFFFLL;
  v15[1] = (v9 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v9 + 1) = a4[2];
  *(void *)&__int128 v9 = v10;
  unint64_t v11 = (v9 >> 48) & 0xFFFFFFFFFFFFFFLL;
  __int128 v12 = *((_OWORD *)a4 + 1);
  void v15[2] = v11;
  _OWORD v15[3] = (v12 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_felem_mul((uint64_t)v14, (unint64_t *)&v16, v15);
  p224_felem_reduce(&v16, (unint64_t *)v14);
  return p224_felem_to_generic(a2, &v16);
}

uint64_t *ec_GFp_nistp224_felem_sqr(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3[1];
  *((void *)&v5 + 1) = v4;
  *(void *)&__int128 v5 = *a3;
  v11.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v11.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v5 + 1) = a3[2];
  *(void *)&__int128 v5 = v4;
  uint64_t v6 = v5 >> 48;
  __int128 v7 = *((_OWORD *)a3 + 1);
  uint64_t v12 = v6 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v13 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v10[5] = v8;
  v10[6] = v8;
  _OWORD v10[3] = v8;
  _OWORD v10[4] = v8;
  v10[1] = v8;
  _OWORD v10[2] = v8;
  v10[0] = v8;
  p224_felem_square(v10, (unint64_t *)&v11);
  p224_felem_reduce(&v11, (unint64_t *)v10);
  return p224_felem_to_generic(a2, &v11);
}

_OWORD *p224_felem_square(_OWORD *result, unint64_t *a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = a2[1];
  uint64_t v4 = 2 * *a2;
  unint64_t v5 = a2[2];
  unint64_t v6 = a2[3];
  *double result = *a2 * (unsigned __int128)*a2;
  result[1] = 2 * v3 * (unsigned __int128)v2;
  result[2] = 2 * v5 * (unsigned __int128)v2 + v3 * (unsigned __int128)v3;
  result[3] = v6 * (unsigned __int128)(unint64_t)v4 + 2 * v5 * (unsigned __int128)v3;
  result[4] = v6 * (unsigned __int128)(2 * v3) + v5 * (unsigned __int128)v5;
  result[5] = v6 * (unsigned __int128)(2 * v5);
  result[6] = v6 * (unsigned __int128)v6;
  return result;
}

int8x16_t p224_felem_reduce(int8x16_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v2 = a2[1];
  unint64_t v5 = a2[2];
  unint64_t v4 = a2[3];
  unint64_t v7 = a2[6];
  unint64_t v6 = a2[7];
  unsigned __int128 v8 = *((_OWORD *)a2 + 6);
  unsigned __int128 v9 = (v8 >> 16) + *((_OWORD *)a2 + 4);
  unint64_t v10 = (unint64_t)(unsigned __int16)v8 << 40;
  BOOL v11 = __CFADD__(v10, v7);
  unint64_t v12 = v10 + v7;
  if (v11) {
    ++v6;
  }
  unint64_t v13 = (*((_OWORD *)a2 + 2) - *((_OWORD *)a2 + 6)) >> 64;
  unint64_t v14 = a2[4] - a2[12];
  unint64_t v16 = a2[10];
  unint64_t v15 = a2[11];
  unint64_t v17 = (unint64_t)(unsigned __int16)v16 << 40;
  BOOL v11 = __CFADD__(v14, v17);
  unint64_t v18 = v14 + v17;
  if (v11) {
    ++v13;
  }
  *((void *)&v19 + 1) = v15;
  *(void *)&unsigned __int128 v19 = v16;
  unsigned __int128 v20 = __PAIR128__(v6, v12) + (v19 >> 16);
  unsigned __int128 v21 = __PAIR128__(v13, v18) + (v9 >> 16);
  unint64_t v23 = v5 - v16;
  uint64_t v22 = (__PAIR128__(v4, v5) - __PAIR128__(v15, v16)) >> 64;
  unint64_t v24 = (unint64_t)(unsigned __int16)v9 << 40;
  unint64_t v25 = v5 - v16 + v24;
  if (__CFADD__(v23, v24)) {
    ++v22;
  }
  *((void *)&v26 + 1) = *((void *)&v21 + 1) + 0x7FFFFFFFFFFFFF80LL;
  *(void *)&unsigned __int128 v26 = v21;
  __int128 v27 = v20 + (v26 >> 56);
  uint64_t v28 = (v27 >> 16) & 0xFFFF0000000000LL;
  BOOL v11 = __CFADD__(v25, v28);
  uint64_t v29 = v25 + v28;
  if (v11) {
    ++v22;
  }
  uint64_t v30 = (v21 & 0xFFFFFFFFFFFFFFLL) + (*((void *)&v27 + 1) >> 8);
  signed __int128 v31 = __PAIR128__(v2, v3) - (v9 + ((unsigned __int128)v27 >> 56)) + __PAIR128__(0x8000000000000000LL, 0x8000LL);
  signed __int128 v32 = __PAIR128__( HIBYTE(*((void *)&v31 + 1)) + (unint64_t)__CFADD__(v29, (unint64_t)(v31 >> 56)) + v22,  v29 + (unint64_t)(v31 >> 56))
      + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000LL);
  unint64_t v33 = (unint64_t)((__PAIR128__( HIBYTE(*((void *)&v31 + 1))
                            + (unint64_t)__CFADD__(v29, (unint64_t)(v31 >> 56))
                            + v22,
  uint64_t v34 = v32 >> 56;
  BOOL v11 = __CFADD__(v30, v34);
  uint64_t v35 = v30 + v34;
  if (v11) {
    ++v33;
  }
  v36.i64[0] = v31;
  v36.i64[1] = v32;
  v37.i64[0] = 0xFFFFFFFFFFFFFFLL;
  v37.i64[1] = 0xFFFFFFFFFFFFFFLL;
  int8x16_t result = vandq_s8(v36, v37);
  *a1 = result;
  *((void *)&v39 + 1) = v33;
  *(void *)&__int128 v39 = v35;
  a1[1].i64[0] = v35 & 0xFFFFFFFFFFFFFFLL;
  a1[1].i64[1] = (v39 >> 56) + (v27 & 0xFFFFFFFFFFFFFFLL);
  return result;
}

uint64_t p224_felem_mul(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a3;
  unint64_t v4 = a3[1];
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  uint64_t v7 = (*a3 * (unsigned __int128)*a2) >> 64;
  *(void *)int8x16_t result = *a3 * *a2;
  *(void *)(result + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v7;
  *(_OWORD *)(result + 16) = v6 * (unsigned __int128)v3 + v4 * (unsigned __int128)v5;
  unint64_t v8 = a3[2];
  unint64_t v9 = a3[3];
  unint64_t v10 = a2[2];
  unint64_t v11 = a2[3];
  *(_OWORD *)(result + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v8 * (unsigned __int128)v5 + v6 * (unsigned __int128)v4 + v10 * (unsigned __int128)v3;
  *(_OWORD *)(result + 4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v10 * (unsigned __int128)v4
                           + v8 * (unsigned __int128)v6
                           + v9 * (unsigned __int128)v5
                           + v11 * (unsigned __int128)v3;
  *(_OWORD *)(result + 64) = v9 * (unsigned __int128)v6 + v10 * (unsigned __int128)v8 + v11 * (unsigned __int128)v4;
  *(_OWORD *)(result + 80) = v11 * (unsigned __int128)v8 + v9 * (unsigned __int128)v10;
  *(_OWORD *)(result + bssl::Array<unsigned short>::~Array(v1 - 96) = v11 * (unsigned __int128)v9;
  return result;
}

uint64_t *p224_felem_to_generic(uint64_t *result, void *a2)
{
  uint64_t v2 = a2[1];
  uint64_t v3 = a2[2];
  unint64_t v4 = a2[3];
  unint64_t v5 = *a2 - HIBYTE(v4);
  uint64_t v6 = v2 + (HIBYTE(v4) << 40);
  uint64_t v7 = (((v3 & v4 & (v2 | 0xFFFFFFFFFFLL)) + 1) | ((*a2 + (v2 & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  BOOL v8 = v7 != 0;
  uint64_t v9 = v7 - 1;
  uint64_t v10 = v8;
  uint64_t v11 = v10 << 63 >> 63;
  uint64_t v12 = v4 & v11;
  uint64_t v13 = v3 & v11;
  uint64_t v14 = 0xFFFFFFFFFFLL;
  if (v8) {
    uint64_t v14 = -1LL;
  }
  uint64_t v15 = v5 + (v9 >> 63);
  uint64_t v16 = v14 & v6;
  unint64_t v17 = v15 + ((unint64_t)v15 >> 63 << 56);
  uint64_t v18 = v16 + (v15 >> 63);
  uint64_t v19 = v13 + (v18 >> 56);
  *int8x16_t result = v17 | (v18 << 56);
  result[1] = ((unint64_t)v18 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v19 << 48);
  result[2] = ((unint64_t)v19 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)(v12
                                                                                 + (v19 >> 56)) << 40);
  result[3] = ((v12 & 0xFFFFFFFFFFFFFFuLL) + (v19 >> 56)) >> 24;
  return result;
}

double p224_point_add( int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, int8x16_t *a4, int64x2_t *a5, uint64_t a6, int a7, unint64_t *a8, unint64_t *a9, unint64_t *a10)
{
  uint64_t v96 = *MEMORY[0x1895F89C0];
  v14.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v14.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  int8x16_t v94 = v14;
  int8x16_t v95 = v14;
  int8x16_t v92 = v14;
  int8x16_t v93 = v14;
  v91[0] = v14;
  v91[1] = v14;
  int8x16_t v89 = v14;
  int8x16_t v90 = v14;
  int8x16_t v87 = v14;
  int8x16_t v88 = v14;
  int8x16_t v85 = v14;
  int8x16_t v86 = v14;
  int8x16_t v83 = v14;
  int8x16_t v84 = v14;
  int8x16_t v81 = v14;
  int8x16_t v82 = v14;
  int8x16_t v79 = v14;
  int8x16_t v80 = v14;
  int8x16_t v77 = v14;
  int8x16_t v78 = v14;
  int8x16_t v75 = v14;
  int8x16_t v76 = v14;
  int8x16_t v73 = v14;
  unsigned __int128 v74 = (unsigned __int128)v14;
  int8x16_t v71 = v14;
  int8x16_t v72 = v14;
  int8x16_t v69 = v14;
  int8x16_t v70 = v14;
  unsigned __int128 v67 = (unsigned __int128)v14;
  unsigned __int128 v68 = (unsigned __int128)v14;
  if (a7)
  {
    uint64_t v16 = a5->i64[0];
    uint64_t v15 = a5->i64[1];
    v89.i64[0] = a5->i64[0];
    v89.i64[1] = v15;
    uint64_t v18 = a5[1].i64[0];
    uint64_t v17 = a5[1].i64[1];
    v90.i64[0] = v18;
    v90.i64[1] = v17;
    int8x16_t v62 = *a4;
    v92.i64[0] = a4->i64[0];
    v92.i64[1] = v62.i64[1];
    int8x16_t v64 = a4[1];
    int8x16_t v93 = v64;
  }

  else
  {
    p224_felem_square(&v74, a10);
    p224_felem_reduce(&v92, (unint64_t *)&v74);
    p224_felem_mul((uint64_t)&v74, (unint64_t *)&v92, a10);
    p224_felem_reduce(&v89, (unint64_t *)&v74);
    p224_felem_mul((uint64_t)&v67, (unint64_t *)&v89, (unint64_t *)a5);
    p224_felem_reduce(&v89, (unint64_t *)&v67);
    p224_felem_mul((uint64_t)&v67, (unint64_t *)&v92, (unint64_t *)a4);
    p224_felem_reduce(&v92, (unint64_t *)&v67);
    uint64_t v15 = v89.i64[1];
    uint64_t v16 = v89.i64[0];
    uint64_t v17 = v90.i64[1];
    uint64_t v18 = v90.i64[0];
    int8x16_t v62 = v92;
    int8x16_t v64 = v93;
  }

  p224_felem_square(&v74, (unint64_t *)a6);
  p224_felem_reduce(&v94, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, (unint64_t *)a6);
  p224_felem_reduce(v91, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)v91, a9);
  unsigned __int128 v74 = v74 - (unint64_t)v16 + __PAIR128__(1LL, 256LL);
  unint64_t v19 = (unint64_t)(*(_OWORD *)&v75 - v15) >> 64;
  v75.i64[0] = v75.i64[0] - v15 - 0x1000000000100LL;
  v75.i64[1] = v19;
  unint64_t v20 = (unint64_t)(*(_OWORD *)&v76 - v18) >> 64;
  v76.i64[0] = v76.i64[0] - v18 - 256;
  v76.i64[1] = v20;
  unint64_t v21 = (unint64_t)(*(_OWORD *)&v77 - v17) >> 64;
  v77.i64[0] = v77.i64[0] - v17 - 256;
  v77.i64[1] = v21;
  p224_felem_reduce(v91, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, a8);
  unsigned __int128 v74 = v74 - v62.u64[0] + __PAIR128__(1LL, 256LL);
  unint64_t v22 = (*(_OWORD *)&v75 - v62.u64[1]) >> 64;
  if (v75.i64[0] - v62.i64[1] >= 0x1000000000100uLL) {
    ++v22;
  }
  v75.i64[0] = v75.i64[0] - v62.i64[1] - 0x1000000000100LL;
  v75.i64[1] = v22;
  unint64_t v23 = (*(_OWORD *)&v76 - v64.u64[0]) >> 64;
  if (v76.i64[0] - v64.i64[0] >= 0x100uLL) {
    ++v23;
  }
  v76.i64[0] = v76.i64[0] - v64.i64[0] - 256;
  v76.i64[1] = v23;
  unint64_t v24 = (*(_OWORD *)&v77 - v64.u64[1]) >> 64;
  if (v77.i64[0] - v64.i64[1] >= 0x100uLL) {
    ++v24;
  }
  v77.i64[0] = v77.i64[0] - v64.i64[1] - 256;
  v77.i64[1] = v24;
  p224_felem_reduce(&v94, (unint64_t *)&v74);
  unint64_t is_zero = p224_felem_is_zero(&v94);
  unint64_t v26 = p224_felem_is_zero(v91);
  unint64_t v27 = p224_felem_is_zero((void *)a6);
  unint64_t v28 = p224_felem_is_zero(a10);
  if ((v26 & is_zero & ~v27 & (v28 ^ 1)) != 0) {
    return p224_point_double(a1, a2, a3, (unint64_t *)a4, a5, (int64x2_t *)a6);
  }
  unint64_t v65 = v27;
  unint64_t v66 = v28;
  if (a7)
  {
    int8x16_t v30 = *(int8x16_t *)(a6 + 16);
    int8x16_t v87 = *(int8x16_t *)a6;
    int8x16_t v88 = v30;
  }

  else
  {
    p224_felem_mul((uint64_t)&v74, (unint64_t *)a6, a10);
    p224_felem_reduce(&v87, (unint64_t *)&v74);
  }

  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, (unint64_t *)&v87);
  p224_felem_reduce(&v81, (unint64_t *)&v74);
  int8x16_t v87 = v94;
  int8x16_t v88 = v95;
  p224_felem_square(&v74, (unint64_t *)&v94);
  p224_felem_reduce(&v94, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v94, (unint64_t *)&v87);
  p224_felem_reduce(&v87, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v92, (unint64_t *)&v94);
  p224_felem_reduce(&v92, (unint64_t *)&v74);
  p224_felem_mul((uint64_t)&v74, (unint64_t *)&v89, (unint64_t *)&v87);
  p224_felem_square(&v67, (unint64_t *)v91);
  int8x16_t v31 = v92;
  uint64_t v32 = v93.i64[1];
  uint64_t v63 = v93.i64[0];
  BOOL v33 = __CFADD__(v87.i64[0], 2 * v92.i64[0]);
  unsigned __int128 v67 = v67 - __PAIR128__(v33, v87.i64[0] + 2 * v92.i64[0]) + __PAIR128__(2LL, 512LL);
  BOOL v34 = __CFADD__(v87.i64[1], 2 * v92.i64[1]);
  unsigned __int128 v68 = v68 - __PAIR128__(v34, v87.i64[1] + 2 * v92.i64[1]) + __PAIR128__(1LL, 0xFFFDFFFFFFFFFE00LL);
  BOOL v35 = __CFADD__(v88.i64[0], 2 * v93.i64[0]);
  unsigned __int128 v36 = *(_OWORD *)&v69 - __PAIR128__(v35, v88.i64[0] + 2 * v93.i64[0]);
  v69.i64[0] = v69.i64[0] - (v88.i64[0] + 2 * v93.i64[0]) - 512;
  v69.i64[1] = ((unint64_t)v36 >= 0x200) + *((void *)&v36 + 1) + 1LL;
  BOOL v37 = __CFADD__(v88.i64[1], 2 * v93.i64[1]);
  unint64_t v39 = v70.i64[0] - (v88.i64[1] + 2 * v93.i64[1]);
  uint64_t v38 = (*(_OWORD *)&v70 - __PAIR128__(v37, v88.i64[1] + 2 * v93.i64[1])) >> 64;
  v70.i64[0] = v39 - 512;
  v70.i64[1] = (v39 >= 0x200) + v38 + 1;
  p224_felem_reduce(&v85, (unint64_t *)&v67);
  v92.i64[0] = v31.i64[0] - v85.i64[0] + 0x400000000000004LL;
  v92.i64[1] = v31.i64[1] - v85.i64[1] + 0x3FFFBFFFFFFFFFCLL;
  v93.i64[0] = v63 - v86.i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v93.i64[1] = v32 - v86.i64[1] + 0x3FFFFFFFFFFFFFCLL;
  p224_felem_mul((uint64_t)&v67, (unint64_t *)v91, (unint64_t *)&v92);
  uint64_t v40 = ((v67 - v74) >> 64) + 0x100000000000000LL;
  *(void *)&unsigned __int128 v67 = v67 - v74;
  *((void *)&v67 + 1) = v40;
  uint64_t v41 = ((v68 - *(_OWORD *)&v75) >> 64) + 0xFFFFFFFFFFFFFFLL;
  *(void *)&unsigned __int128 v68 = v68 - v75.i64[0];
  *((void *)&v68 + 1) = v41;
  uint64_t v42 = ((*(_OWORD *)&v69 - *(_OWORD *)&v76) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v69.i64[0] -= v76.i64[0];
  v69.i64[1] = v42;
  uint64_t v43 = ((*(_OWORD *)&v70 - *(_OWORD *)&v77) >> 64) + 0x100000000000000LL;
  v70.i64[0] -= v77.i64[0];
  v70.i64[1] = v43;
  uint64_t v44 = ((*(_OWORD *)&v71 - *(_OWORD *)&v78) >> 64) + 0xFFFEFFFFFFFFFFLL;
  v71.i64[0] -= v78.i64[0];
  v71.i64[1] = v44;
  uint64_t v45 = ((*(_OWORD *)&v72 - *(_OWORD *)&v79) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v72.i64[0] -= v79.i64[0];
  v72.i64[1] = v45;
  uint64_t v46 = ((*(_OWORD *)&v73 - *(_OWORD *)&v80) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v73.i64[0] -= v80.i64[0];
  v73.i64[1] = v46;
  p224_felem_reduce(&v83, (unint64_t *)&v67);
  uint64_t v47 = 0LL;
  int8x16_t v48 = (int8x16_t)vdupq_n_s64(-(uint64_t)v65);
  do
  {
    *(int8x16_t *)((char *)&v85 + v47 * bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = vbslq_s8( v48,  *(int8x16_t *)&a8[v47],  *(int8x16_t *)((char *)&v85 + v47 * 8));
    v47 += 2LL;
  }

  while (v47 != 4);
  uint64_t v49 = 0LL;
  int8x16_t v50 = (int8x16_t)vdupq_n_s64(-(uint64_t)v66);
  do
  {
    *(int8x16_t *)((char *)&v85 + v49 * 16) = vbslq_s8(v50, a4[v49], *(int8x16_t *)((char *)&v85 + v49 * 16));
    ++v49;
  }

  while (v49 != 2);
  for (uint64_t i = 0LL; i != 4; i += 2LL)
    *(int8x16_t *)((char *)&v83 + i * bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = vbslq_s8(v48, *(int8x16_t *)&a9[i], *(int8x16_t *)((char *)&v83 + i * 8));
  for (uint64_t j = 0LL; j != 2; ++j)
    *(int8x16_t *)((char *)&v83 + j * 16) = vbslq_s8(v50, (int8x16_t)a5[j], *(int8x16_t *)((char *)&v83 + j * 16));
  for (uint64_t k = 0LL; k != 4; k += 2LL)
    *(int8x16_t *)((char *)&v81 + k * bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = vbslq_s8(v48, *(int8x16_t *)&a10[k], *(int8x16_t *)((char *)&v81 + k * 8));
  for (uint64_t m = 0LL; m != 32; m += 16LL)
    *(int8x16_t *)((char *)&v81 + m) = vbslq_s8(v50, *(int8x16_t *)(a6 + m), *(int8x16_t *)((char *)&v81 + m));
  int8x16_t v55 = v86;
  *a1 = v85;
  a1[1] = v55;
  int8x16_t v56 = v84;
  *a2 = v83;
  a2[1] = v56;
  double result = *(double *)v81.i64;
  int8x16_t v57 = v82;
  *a3 = v81;
  a3[1] = v57;
  return result;
}

unint64_t p224_felem_is_zero(void *a1)
{
  uint64_t v1 = a1[1];
  return (((v1 ^ 0xFFFF0000000000LL | *a1 ^ 1LL | a1[3] ^ 0xFFFFFFFFFFFFFFLL | a1[2] ^ 0xFFFFFFFFFFFFFFLL) - 1) | ((v1 | *a1 | a1[2] | a1[3]) - 1) | ((v1 ^ 0xFFFE0000000000LL | *a1 ^ 2LL | a1[3] ^ 0x1FFFFFFFFFFFFFFLL | a1[2] ^ 0xFFFFFFFFFFFFFFuLL) - 1)) >> 63;
}

double p224_point_double( int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, int64x2_t *a5, int64x2_t *a6)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  v9.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int128 v68 = (unsigned __int128)v9;
  int8x16_t v69 = v9;
  unsigned __int128 v66 = (unsigned __int128)v9;
  unsigned __int128 v67 = (unsigned __int128)v9;
  int8x16_t v64 = v9;
  unsigned __int128 v65 = (unsigned __int128)v9;
  unsigned __int128 v63 = (unsigned __int128)v9;
  int8x16_t v61 = v9;
  int8x16_t v62 = v9;
  int8x16_t v59 = v9;
  int8x16_t v60 = v9;
  int8x16_t v57 = v9;
  int8x16_t v58 = v9;
  int8x16_t v55 = v9;
  int8x16_t v56 = v9;
  int8x16_t v53 = v9;
  int8x16_t v54 = v9;
  int8x16_t v51 = v9;
  int8x16_t v52 = v9;
  v49[1] = v9;
  int8x16_t v50 = v9;
  v49[0] = v9;
  unint64_t v10 = *a4;
  unint64_t v11 = a4[1];
  unint64_t v13 = a4[2];
  unint64_t v12 = a4[3];
  p224_felem_square(&v63, (unint64_t *)a6);
  p224_felem_reduce(&v54, (unint64_t *)&v63);
  p224_felem_square(&v63, (unint64_t *)a5);
  p224_felem_reduce(&v52, (unint64_t *)&v63);
  p224_felem_mul((uint64_t)&v63, a4, (unint64_t *)&v52);
  p224_felem_reduce(&v50, (unint64_t *)&v63);
  int8x16_t v14 = v54;
  v47.i64[0] = v10 + 0x400000000000004LL - v54.i64[0];
  v47.i64[1] = v11 + 0x3FFFBFFFFFFFFFCLL - v54.i64[1];
  int8x16_t v15 = v55;
  v48.i64[0] = v13 - v55.i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v48.i64[1] = v12 - v55.i64[1] + 0x3FFFFFFFFFFFFFCLL;
  v46[0] = 3 * (v54.i64[0] + v10);
  v46[1] = 3 * (v54.i64[1] + v11);
  v46[2] = 3 * (v55.i64[0] + v13);
  v46[3] = 3 * (v55.i64[1] + v12);
  p224_felem_mul((uint64_t)&v63, (unint64_t *)&v47, v46);
  p224_felem_reduce(v49, (unint64_t *)&v63);
  p224_felem_square(&v63, (unint64_t *)v49);
  int8x16_t v16 = v50;
  int8x16_t v17 = v51;
  unsigned __int128 v63 = v63 - (unint64_t)(8 * v50.i64[0]) + __PAIR128__(1LL, 256LL);
  unint64_t v19 = (unint64_t)(*(_OWORD *)&v64 - 8 * v50.i64[1]) >> 64;
  uint64_t v18 = v64.i64[0] - 8 * v50.i64[1];
  BOOL v20 = __CFADD__(v18, 0xFFFEFFFFFFFFFF00LL);
  uint64_t v21 = v18 - 0x1000000000100LL;
  if (v20) {
    ++v19;
  }
  v64.i64[0] = v21;
  v64.i64[1] = v19;
  unint64_t v23 = (v65 - (unint64_t)(8 * v51.i64[0])) >> 64;
  unint64_t v22 = v65 - 8 * v51.i64[0];
  BOOL v20 = v22 >= 0x100;
  unint64_t v24 = v22 - 256;
  if (v20) {
    ++v23;
  }
  *(void *)&unsigned __int128 v65 = v24;
  *((void *)&v65 + 1) = v23;
  unint64_t v26 = (v66 - (unint64_t)(8 * v51.i64[1])) >> 64;
  unint64_t v25 = v66 - 8 * v51.i64[1];
  BOOL v20 = v25 >= 0x100;
  unint64_t v27 = v25 - 256;
  if (v20) {
    ++v26;
  }
  *(void *)&unsigned __int128 v66 = v27;
  *((void *)&v66 + 1) = v26;
  p224_felem_reduce(a1, (unint64_t *)&v63);
  int64x2_t v28 = vaddq_s64(*a6, *a5);
  int64x2_t v29 = vaddq_s64(a6[1], a5[1]);
  uint64_t v30 = v52.i64[0] + v14.i64[0];
  uint64_t v31 = v52.i64[1] + v14.i64[1];
  uint64_t v32 = v53.i64[0] + v15.i64[0];
  uint64_t v33 = v53.i64[1] + v15.i64[1];
  int64x2_t v47 = v28;
  int64x2_t v48 = v29;
  p224_felem_square(&v63, (unint64_t *)&v47);
  unsigned __int128 v63 = v63 - (unint64_t)v30 + __PAIR128__(1LL, 256LL);
  unint64_t v34 = (unint64_t)(*(_OWORD *)&v64 - v31) >> 64;
  v64.i64[0] = v64.i64[0] - v31 - 0x1000000000100LL;
  v64.i64[1] = v34;
  uint64_t v35 = (v65 - (unint64_t)v32) >> 64;
  *(void *)&unsigned __int128 v65 = v65 - v32 - 256;
  *((void *)&v65 + 1) = v35;
  uint64_t v36 = (v66 - (unint64_t)v33) >> 64;
  *(void *)&unsigned __int128 v66 = v66 - v33 - 256;
  *((void *)&v66 + 1) = v36;
  p224_felem_reduce(a3, (unint64_t *)&v63);
  uint64_t v37 = a1->i64[1];
  v50.i64[0] = 4 * v16.i64[0] + 0x400000000000004LL - a1->i64[0];
  v50.i64[1] = 4 * v16.i64[1] + 0x3FFFBFFFFFFFFFCLL - v37;
  uint64_t v38 = 4 * v17.i64[1] - a1[1].i64[1] + 0x3FFFFFFFFFFFFFCLL;
  v51.i64[0] = 4 * v17.i64[0] - a1[1].i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v51.i64[1] = v38;
  p224_felem_mul((uint64_t)&v63, (unint64_t *)v49, (unint64_t *)&v50);
  p224_felem_square(&v56, (unint64_t *)&v52);
  uint64_t v39 = ((v63 - *(_OWORD *)&v56 * 8LL) >> 64) + 0x100000000000000LL;
  *(void *)&unsigned __int128 v63 = v63 - 8 * v56.i64[0];
  *((void *)&v63 + 1) = v39;
  __int128 v40 = *(_OWORD *)&v64 - *(_OWORD *)&v57 * 8LL;
  v64.i64[0] -= 8 * v57.i64[0];
  v64.i64[1] = *((void *)&v40 + 1) + 0xFFFFFFFFFFFFFFLL;
  unsigned __int128 v65 = v65 - *(_OWORD *)&v58 * 8LL + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0LL);
  unsigned __int128 v66 = v66 - *(_OWORD *)&v59 * 8LL + __PAIR128__(0x100000000000000LL, 0LL);
  unsigned __int128 v67 = v67 - *(_OWORD *)&v60 * 8LL + __PAIR128__(0xFFFEFFFFFFFFFFLL, 0LL);
  unsigned __int128 v68 = v68 - *(_OWORD *)&v61 * 8LL + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0LL);
  uint64_t v41 = ((unsigned __int128)(*(_OWORD *)&v69 - *(_OWORD *)&v62 * 8LL) >> 64) + 0xFFFFFFFFFFFFFFLL;
  v69.i64[0] -= 8 * v62.i64[0];
  v69.i64[1] = v41;
  *(void *)&double result = p224_felem_reduce(a2, (unint64_t *)&v63).u64[0];
  return result;
}

void ec_GFp_nistp224_make_precomp(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = 0u;
  *(_OWORD *)(a1 + 4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + bssl::Array<unsigned short>::~Array(v1 - 96) = *(void *)a2 & 0xFFFFFFFFFFFFFFLL;
  unint64_t v4 = (int8x16_t *)(a1 + 96);
  *(void *)(a1 + bssl::Array<unsigned short>::~Array(v16 + 104) = (*(__int128 *)a2 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 112) = (*(__int128 *)(a2 + 8) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 120) = (*(__int128 *)(a2 + 16) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 12bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = *(void *)(a2 + 72) & 0xFFFFFFFFFFFFFFLL;
  unint64_t v5 = (int64x2_t *)(a1 + 128);
  *(void *)(a1 + 136) = (*(__int128 *)(a2 + 72) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + CBB_cleanup(v1 - 144) = (*(__int128 *)(a2 + 80) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + bssl::Array<bssl::ALPSConfig>::~Array(v16 + 152) = (*(__int128 *)(a2 + 88) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 160) = *(void *)(a2 + 144) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v6 = a1 + 160;
  *(void *)(a1 + 16bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = (*(__int128 *)(a2 + 144) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 176) = (*(__int128 *)(a2 + 152) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 184) = (*(__int128 *)(a2 + 160) >> 40) & 0xFFFFFFFFFFFFFFLL;
  unint64_t v7 = 2LL;
  do
  {
    BOOL v8 = (int8x16_t *)(a1 + v3 + 192);
    int8x16_t v9 = (int8x16_t *)(a1 + v3 + 224);
    unint64_t v10 = (int8x16_t *)(a1 + v3 + 256);
    if ((v7 & 1) != 0) {
      p224_point_add( v8,  v9,  v10,  v4,  v5,  v6,  0,  (unint64_t *)(a1 + v3 + 96),  (unint64_t *)(a1 + v3 + 128),  (unint64_t *)(a1 + v3 + 160));
    }
    else {
      p224_point_double( v8,  v9,  v10,  (unint64_t *)(a1 + 96 * (v7 >> 1)),  (int64x2_t *)(a1 + 96 * (v7 >> 1) + 32),  (int64x2_t *)(a1 + 96 * (v7 >> 1) + 64));
    }
    ++v7;
    v3 += 96LL;
  }

  while (v3 != 1440);
}

uint64_t p224_select_point(uint64_t result, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
    {
      for (uint64_t j = 0LL; j != 96; j += 8LL)
        *(void *)((char *)a4 + j) |= *(void *)(a3 + j) & ((((i ^ result) - 1) & ~result) >> 63);
      a3 += 96LL;
    }
  }

  return result;
}

double p224_felem_neg(int8x16_t *a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v11 = 0u;
  unint64_t v3 = a2[1];
  BOOL v4 = *a2 <= 0x100uLL;
  v7[0] = 256LL - *a2;
  v7[1] = v4;
  unsigned __int128 v8 = 0xFFFEFFFFFFFFFF00LL - __PAIR128__(v4, v3);
  unint64_t v5 = a2[3];
  unsigned __int128 v9 = 0xFFFFFFFFFFFFFF00LL - __PAIR128__(v2, a2[2]);
  unsigned __int128 v10 = 0xFFFFFFFFFFFFFF00LL - __PAIR128__(v9, v5);
  *(void *)&double result = p224_felem_reduce(a1, v7).u64[0];
  return result;
}

uint64_t bn_mod_u16_consttime(uint64_t a1, unsigned int a2)
{
  if (a2 < 2) {
    return 0LL;
  }
  unsigned int v4 = BN_num_bits_word(a2 - 1);
  if (v4 >= 0x11) {
    bn_mod_u16_consttime_cold_1();
  }
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  char v6 = v4;
  LODWORD(result) = 0;
  unint64_t v8 = v5 + 1;
  unsigned int v9 = v5 - 1;
  unint64_t v10 = ((unint64_t)a2 + (1LL << (v6 + 32)) - 1) / a2;
  do
  {
    unsigned int v11 = *(_DWORD *)(*(void *)a1 + 8LL * v9 + 4);
    unsigned __int16 v12 = mod_u16(__PAIR64__(result, v11) >> 16, a2, v6, v10);
    HIDWORD(v13) = mod_u16((unsigned __int16)v11 | (v12 << 16), a2, v6, v10);
    LODWORD(v13) = *(_DWORD *)(*(void *)a1 + 8LL * v9);
    unsigned __int16 v14 = mod_u16(v13 >> 16, a2, v6, v10);
    uint64_t result = mod_u16((unsigned __int16)v13 | (v14 << 16), a2, v6, v10);
    --v8;
    --v9;
  }

  while (v8 > 1);
  return result;
}

uint64_t mod_u16(unsigned int a1, unsigned int a2, char a3, unsigned int a4)
{
  if (a1
     - ((((a4 * (unint64_t)a1) >> 32)
                     + ((a1 - ((a4 * (unint64_t)a1) >> 32)) >> 1)) >> (a3 - 1))
     * a2 >= a2)
    mod_u16_cold_1();
  return (unsigned __int16)(a1
                          - ((((a4 * (unint64_t)a1) >> 32)
}

BIO *__cdecl BIO_new_mem_buf(void *buf, int len)
{
  uint64_t v2 = *(void *)&len;
  size_t v4 = *(void *)&len;
  if ((*(void *)&len & 0x8000000000000000LL) != 0)
  {
    size_t v4 = strlen((const char *)buf);
    if (buf) {
      goto LABEL_7;
    }
  }

  else if (buf)
  {
    goto LABEL_7;
  }

  if (v2)
  {
    ERR_put_error(17, 0, 111, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio_mem.c", 75);
    return 0LL;
  }

uint64_t mem_write(uint64_t a1, const void *a2, int a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  if ((*(_BYTE *)(a1 + 25) & 2) != 0)
  {
    ERR_put_error(17, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/bio_mem.c", 168);
    return 0xFFFFFFFFLL;
  }

  else if (BUF_MEM_append(*(void **)(a1 + 40), a2, a3))
  {
    return a3;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }

size_t mem_read(uint64_t a1, void *a2, int a3)
{
  LODWORD(v3) = a3;
  BIO_clear_retry_flags(a1);
  char v6 = *(size_t **)(a1 + 40);
  size_t v7 = *v6;
  else {
    size_t v3 = v7;
  }
  if ((int)v3 >= 1)
  {
    memcpy(a2, (const void *)v6[1], v3);
    size_t v8 = *v6;
    size_t v9 = *v6 - v3;
    size_t *v6 = v9;
    if ((*(_BYTE *)(a1 + 25) & 2) != 0)
    {
      v6[1] += v3;
    }

    else if (v8 != v3)
    {
      memmove((void *)v6[1], (const void *)(v6[1] + v3), v9);
    }

    return v3;
  }

  if (v7) {
    return 0LL;
  }
  size_t v3 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v3) {
    BIO_set_retry_read(a1);
  }
  return v3;
}

size_t mem_gets(uint64_t a1, void *a2, int a3)
{
  unint64_t v6 = (a3 - 1);
  if (a3 < 1) {
    return 0LL;
  }
  size_t v7 = *(unint64_t **)(a1 + 40);
  if (*v7 >= v6) {
    size_t v8 = v6;
  }
  else {
    size_t v8 = *v7;
  }
  if ((_DWORD)v8)
  {
    size_t v9 = (const void *)v7[1];
    unint64_t v10 = memchr(v9, 10, v8);
    if (v10) {
      LODWORD(vbssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = (_DWORD)v10 - (_DWORD)v9 + 1;
    }
  }

  size_t result = mem_read(a1, a2, v8);
  if ((result & 0x80000000) == 0) {
    *((_BYTE *)a2 + result) = 0;
  }
  return result;
}

uint64_t mem_ctrl(uint64_t a1, int a2, int a3, uint64_t **a4)
{
  uint64_t result = 0LL;
  size_t v8 = *(uint64_t **)(a1 + 40);
  if (a2 > 113)
  {
    switch(a2)
    {
      case 114:
        mem_free(a1);
        *(_DWORD *)(a1 + 20) = a3;
        *(void *)(a1 + 40) = a4;
        break;
      case 115:
        if (a4) {
          *a4 = v8;
        }
        break;
      case 130:
        *(_DWORD *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = a3;
        break;
      default:
        return result;
    }

    return 1LL;
  }

  else
  {
    switch(a2)
    {
      case 1:
        size_t v9 = (char *)v8[1];
        if (v9)
        {
          size_t v10 = v8[2];
          if ((*(_BYTE *)(a1 + 25) & 2) != 0)
          {
            unsigned int v11 = &v9[*v8 - v10];
            uint64_t *v8 = v10;
            v8[1] = (uint64_t)v11;
          }

          else
          {
            if (v10) {
              bzero(v9, v10);
            }
            uint64_t *v8 = 0LL;
          }
        }

        return 1LL;
      case 2:
        uint64_t result = *v8 == 0;
        break;
      case 3:
        uint64_t result = *v8;
        if (a4) {
          *a4 = (uint64_t *)v8[1];
        }
        break;
      case 8:
        uint64_t result = *(int *)(a1 + 20);
        break;
      case 9:
        *(_DWORD *)(a1 + 20) = a3;
        return 1LL;
      case 10:
        uint64_t result = *v8;
        break;
      case 11:
        return 1LL;
      default:
        return result;
    }
  }

  return result;
}

BUF_MEM *mem_new(uint64_t a1)
{
  uint64_t result = BUF_MEM_new();
  if (result)
  {
    *(void *)(a1 + 16) = 0x100000001LL;
    *(_DWORD *)(a1 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = -1;
    *(void *)(a1 + 40) = result;
    return (BUF_MEM *)1;
  }

  return result;
}

uint64_t mem_free(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20))
  {
    if (*(_DWORD *)(a1 + 16))
    {
      uint64_t v2 = *(BUF_MEM **)(a1 + 40);
      if (v2)
      {
        if ((*(_BYTE *)(a1 + 25) & 2) != 0) {
          v2->data = 0LL;
        }
        BUF_MEM_free(v2);
        *(void *)(a1 + 40) = 0LL;
      }
    }
  }

  return 1LL;
}

const EVP_CIPHER *EVP_enc_null(void)
{
  return (const EVP_CIPHER *)&n_cipher;
}

uint64_t null_init_key()
{
  return 1LL;
}

uint64_t null_cipher(int a1, void *__dst, void *__src, size_t __n)
{
  if (__src != __dst && __n) {
    memcpy(__dst, __src, __n);
  }
  return 1LL;
}

uint64_t ec_point_byte_len(uint64_t a1, int a2)
{
  if (a2 == 2 || a2 == 4)
  {
    unsigned int v3 = BN_num_bytes((const BIGNUM *)(a1 + 320));
    uint64_t v4 = v3;
    if (a2 != 4) {
      uint64_t v4 = 0LL;
    }
    return v4 + v3 + 1;
  }

  else
  {
    ERR_put_error(15, 0, 111, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 79);
    return 0LL;
  }

unint64_t ec_point_to_bytes(uint64_t a1, uint64_t a2, int a3, char *a4, unint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  unint64_t v9 = ec_point_byte_len(a1, a3);
  if (v9 <= a5)
  {
    unint64_t v10 = v9;
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    ec_felem_to_bytes(a1);
    if (a3 == 4)
    {
      ec_felem_to_bytes(a1);
      char v11 = 4;
    }

    else
    {
      __int16 v16 = -21846;
      *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      void v15[2] = v12;
      _OWORD v15[3] = v12;
      v15[0] = v12;
      v15[1] = v12;
      ec_felem_to_bytes(a1);
      char v11 = (*((_BYTE *)v15 + v14 - 1) & 1) + a3;
    }

    *a4 = v11;
  }

  else
  {
    ERR_put_error(15, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 97);
    return 0LL;
  }

  return v10;
}

uint64_t ec_point_from_uncompressed(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  if (((2LL * BN_num_bytes((const BIGNUM *)(a1 + 320))) | 1) == a4 && *a3 == 4)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v11[2] = v7;
    _OWORD v11[3] = v7;
    v11[0] = v7;
    v11[1] = v7;
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
    __int128 v9[2] = v7;
    _OWORD v9[3] = v7;
    v9[0] = v7;
    v9[1] = v7;
    uint64_t result = ec_felem_from_bytes(a1);
    if ((_DWORD)result)
    {
      uint64_t result = ec_felem_from_bytes(a1);
      if ((_DWORD)result) {
        return ec_point_set_affine_coordinates(a1, a2, (uint64_t)v11, (uint64_t)v9) != 0;
      }
    }
  }

  else
  {
    ERR_put_error(15, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 122);
    return 0LL;
  }

  return result;
}

int EC_POINT_oct2point(const EC_GROUP *a1, EC_POINT *a2, const unsigned __int8 *buf, size_t len, BN_CTX *a5)
{
  if (EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, 0LL))
  {
    int v10 = 106;
    int v11 = 205;
LABEL_3:
    ERR_put_error(15, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v11);
    return 0;
  }

  if (!len)
  {
    int v10 = 100;
    int v11 = 140;
    goto LABEL_3;
  }

  int v14 = *buf;
  if (v14 != 4)
  {
    unsigned int v18 = BN_num_bytes((const BIGNUM *)((char *)a1 + 320));
    if ((v14 & 0xFE) != 2 || v18 + 1LL != len)
    {
      int v10 = 109;
      int v11 = 162;
      goto LABEL_3;
    }

    if (a5)
    {
      BOOL v20 = 0LL;
    }

    else
    {
      a5 = BN_CTX_new();
      BOOL v20 = a5;
      if (!a5) {
        return 0;
      }
    }

    BN_CTX_start(a5);
    uint64_t v21 = BN_CTX_get(a5);
    if (v21)
    {
      unint64_t v22 = v21;
      if (BN_bin2bn(buf + 1, v18, v21))
      {
        if (BN_ucmp(v22, (const BIGNUM *)((char *)a1 + 320)) < 0)
        {
          int v12 = EC_POINT_set_compressed_coordinates_GFp(a1, a2, v22, v14 & 1, a5);
          goto LABEL_25;
        }

        ERR_put_error(15, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", 186);
      }
    }

    int v12 = 0;
LABEL_25:
    BN_CTX_end(a5);
    BN_CTX_free(v20);
    return v12;
  }

  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[7] = v15;
  v23[8] = v15;
  v23[5] = v15;
  v23[6] = v15;
  _OWORD v23[3] = v15;
  v23[4] = v15;
  v23[1] = v15;
  v23[2] = v15;
  v23[0] = v15;
  int v16 = ec_point_from_uncompressed((uint64_t)a1, (uint64_t)v23, buf, len);
  uint64_t v17 = (char *)a2 + 8;
  if (v16)
  {
    ec_affine_to_jacobian((uint64_t)a1, (uint64_t)v17, (uint64_t)v23);
    return 1;
  }

  ec_set_to_safe_point((uint64_t)a1, (uint64_t)v17);
  return 0;
}

size_t EC_POINT_point2oct( const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, unsigned __int8 *buf, size_t len, BN_CTX *a6)
{
  if (EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, 0LL))
  {
    int v11 = 106;
    int v12 = 215;
  }

  else
  {
    if (buf)
    {
      *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v15[7] = v14;
      v15[8] = v14;
      int64x2_t v15[5] = v14;
      v15[6] = v14;
      _OWORD v15[3] = v14;
      _OWORD v15[4] = v14;
      v15[1] = v14;
      void v15[2] = v14;
      v15[0] = v14;
      if (ec_jacobian_to_affine( (uint64_t (***)(void, uint64_t, uint64_t, uint64_t))a1,  (uint64_t)v15,  (uint64_t)a2 + 8)) {
        return ec_point_to_bytes((uint64_t)a1, (uint64_t)v15, form, (char *)buf, len);
      }
      return 0LL;
    }

    int v11 = 119;
    int v12 = 222;
  }

  ERR_put_error(15, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v12);
  return 0LL;
}

unsigned __int8 *EC_POINT_point2buf( const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t a3, unsigned __int8 **a4, uint64_t a5, BN_CTX *a6)
{
  *a4 = 0LL;
  uint64_t result = (unsigned __int8 *)EC_POINT_point2oct(a1, a2, a3, 0LL, 0LL, a6);
  if (result)
  {
    size_t v11 = (size_t)result;
    uint64_t result = (unsigned __int8 *)OPENSSL_malloc((unint64_t)result);
    if (result)
    {
      unint64_t v13 = result;
      uint64_t result = (unsigned __int8 *)EC_POINT_point2oct(a1, a2, a3, result, v11, v12);
      if (result)
      {
        *a4 = v13;
      }

      else
      {
        OPENSSL_free(v13);
        return 0LL;
      }
    }
  }

  return result;
}

int EC_POINT_set_compressed_coordinates_GFp( const EC_GROUP *a1, EC_POINT *a2, const BIGNUM *x, int y_bit, BN_CTX *a5)
{
  if (!EC_GROUP_cmp(a1, *(const EC_GROUP **)a2, 0LL))
  {
    if (BN_is_negative((uint64_t)x) || (BN_cmp(x, (const BIGNUM *)((char *)a1 + 320)) & 0x80000000) == 0)
    {
      int v10 = 107;
      int v11 = 265;
      goto LABEL_6;
    }

    ERR_clear_error();
    if (a5)
    {
      __int128 v14 = 0LL;
    }

    else
    {
      a5 = BN_CTX_new();
      __int128 v14 = a5;
      if (!a5) {
        return 0;
      }
    }

    unint64_t v25 = v14;
    int v24 = y_bit != 0;
    BN_CTX_start(a5);
    __int128 v15 = BN_CTX_get(a5);
    int v16 = BN_CTX_get(a5);
    uint64_t v17 = BN_CTX_get(a5);
    unsigned int v18 = BN_CTX_get(a5);
    unint64_t v19 = BN_CTX_get(a5);
    if (!v19) {
      goto LABEL_28;
    }
    BOOL v20 = v19;
    if (!EC_GROUP_get_curve_GFp(a1, 0LL, v17, v18, a5)
      || !BN_mod_sqr(v16, x, (const BIGNUM *)((char *)a1 + 320), a5)
      || !BN_mod_mul(v15, v16, x, (const BIGNUM *)((char *)a1 + 320), a5))
    {
      goto LABEL_28;
    }

    if (*((_DWORD *)a1 + 132))
    {
      if (!bn_mod_lshift1_consttime((uint64_t)v16, (uint64_t)x, (uint64_t)a1 + 320, a5)
        || !bn_mod_add_consttime((uint64_t)v16, (uint64_t)v16, (uint64_t)x, (uint64_t)a1 + 320, a5)
        || !bn_mod_sub_consttime((uint64_t)v15, (uint64_t)v15, (uint64_t)v16, (uint64_t)a1 + 320, a5))
      {
        goto LABEL_28;
      }
    }

    else if (!BN_mod_mul(v16, v17, x, (const BIGNUM *)((char *)a1 + 320), a5) {
           || !bn_mod_add_consttime((uint64_t)v15, (uint64_t)v15, (uint64_t)v16, (uint64_t)a1 + 320, a5))
    }
    {
      goto LABEL_28;
    }

    if (!bn_mod_add_consttime((uint64_t)v15, (uint64_t)v15, (uint64_t)v18, (uint64_t)a1 + 320, a5))
    {
LABEL_28:
      BOOL v12 = 0;
      uint64_t v21 = v25;
      goto LABEL_29;
    }

    if (BN_mod_sqrt(v20, v15, (const BIGNUM *)((char *)a1 + 320), a5))
    {
      uint64_t v21 = v25;
      if (BN_is_odd((uint64_t)v20) == v24)
      {
LABEL_26:
        if (BN_is_odd((uint64_t)v20) == v24)
        {
          BOOL v12 = EC_POINT_set_affine_coordinates_GFp(a1, a2, x, v20, a5) != 0;
LABEL_29:
          BN_CTX_end(a5);
          BN_CTX_free(v21);
          return v12;
        }

        int v22 = 68;
        int v23 = 345;
        goto LABEL_36;
      }

      if (!BN_is_zero((uint64_t)v20))
      {
        goto LABEL_26;
      }

      int v22 = 108;
      int v23 = 337;
    }

    else
    {
      uint64_t v21 = v25;
      if ((ERR_peek_last_error() & 0xFF000FFF) == 0x300006E)
      {
        ERR_clear_error();
        int v22 = 107;
        int v23 = 328;
      }

      else
      {
        int v22 = 3;
        int v23 = 330;
      }
    }

LABEL_36:
    ERR_put_error(15, 0, v22, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v23);
LABEL_37:
    BOOL v12 = 0;
    goto LABEL_29;
  }

  int v10 = 106;
  int v11 = 259;
LABEL_6:
  ERR_put_error(15, 0, v10, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/oct.c", v11);
  return 0;
}

    if ((_DWORD)v15)
    {
LABEL_60:
      OPENSSL_free(__dst);
      return v15;
    }

    goto LABEL_37;
  }

  return v15;
}

            int v10 = 0LL;
            goto LABEL_37;
          }
        }

        while (!v31.avail_out);
        if (v19 < a3) {
          continue;
        }
        break;
      }

      int v10 = 1LL;
LABEL_37:
      deflateEnd(&v31);
    }
  }

      *a3 = 0;
      return 1LL;
    }

    BOOL v20 = 444;
  }

  else
  {
    BOOL v20 = 413;
  }

uint64_t *EC_GFp_nistp256_method()
{
  return &EC_GFp_nistp256_method_storage;
}

void EC_GFp_nistp256_method_init()
{
  EC_GFp_nistp256_method_storage = (uint64_t)ec_GFp_nistp256_point_get_affine_coordinates;
  qword_18C4C4FA0 = (uint64_t)ec_GFp_nistp256_add;
  unk_18C4C4FA8 = ec_GFp_nistp256_dbl;
  qword_18C4C4FB0 = (uint64_t)ec_GFp_nistp256_point_mul;
  unk_18C4C4FB8 = ec_GFp_nistp256_point_mul_base;
  qword_18C4C4FC8 = (uint64_t)ec_GFp_nistp256_point_mul_public;
  qword_18C4C4FE8 = (uint64_t)ec_GFp_mont_felem_mul;
  unk_18C4C4FF0 = ec_GFp_mont_felem_sqr;
  qword_18C4C4FF8 = (uint64_t)ec_GFp_mont_felem_to_bytes;
  unk_18C4C5000 = ec_GFp_mont_felem_from_bytes;
  qword_18C4C5008 = (uint64_t)ec_GFp_mont_felem_reduce;
  unk_18C4C5010 = ec_GFp_mont_felem_exp;
  qword_18C4C5018 = (uint64_t)ec_simple_scalar_inv0_montgomery;
  unk_18C4C5020 = ec_simple_scalar_to_montgomery_inv_vartime;
  qword_18C4C5028 = (uint64_t)ec_GFp_nistp256_cmp_x_coordinate;
}

uint64_t ec_GFp_nistp256_point_get_affine_coordinates(uint64_t a1, __int128 *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (ec_GFp_simple_is_at_infinity(a1, (uint64_t)a2))
  {
    ERR_put_error(15, 0, 119, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/ec/p256.c", 421);
    return 0LL;
  }

  else
  {
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v23[0] = v8;
    v23[1] = v8;
    __int128 v9 = a2[10];
    v24[0] = a2[9];
    v24[1] = v9;
    __int128 v32 = v8;
    __int128 v33 = v8;
    v31[0] = v8;
    v31[1] = v8;
    v30[0] = v8;
    v30[1] = v8;
    v29[0] = v8;
    v29[1] = v8;
    v28[0] = v8;
    v28[1] = v8;
    v27[0] = v8;
    v27[1] = v8;
    v26[0] = v8;
    v26[1] = v8;
    fiat_p256_square((uint64_t *)&v32, (unint64_t *)v24);
    fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v24);
    fiat_p256_square((uint64_t *)v31, (unint64_t *)&v32);
    fiat_p256_mul((uint64_t *)v31, (unint64_t *)v31, (unint64_t *)v24);
    fiat_p256_square((uint64_t *)v30, (unint64_t *)v31);
    int v10 = 2;
    do
    {
      fiat_p256_square((uint64_t *)v30, (unint64_t *)v30);
      --v10;
    }

    while (v10);
    fiat_p256_mul((uint64_t *)v30, (unint64_t *)v30, (unint64_t *)v31);
    fiat_p256_square((uint64_t *)v29, (unint64_t *)v30);
    int v11 = 5;
    do
    {
      fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
      --v11;
    }

    while (v11);
    fiat_p256_mul((uint64_t *)v29, (unint64_t *)v29, (unint64_t *)v30);
    fiat_p256_square((uint64_t *)v28, (unint64_t *)v29);
    int v12 = 2;
    do
    {
      fiat_p256_square((uint64_t *)v28, (unint64_t *)v28);
      --v12;
    }

    while (v12);
    fiat_p256_mul((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)v31);
    fiat_p256_square((uint64_t *)v27, (unint64_t *)v28);
    int v13 = 14;
    do
    {
      fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
      --v13;
    }

    while (v13);
    fiat_p256_mul((uint64_t *)v27, (unint64_t *)v27, (unint64_t *)v28);
    fiat_p256_square((uint64_t *)v26, (unint64_t *)v27);
    fiat_p256_square((uint64_t *)v26, (unint64_t *)v26);
    fiat_p256_mul((uint64_t *)v26, (unint64_t *)v26, (unint64_t *)&v32);
    *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25[0] = v14;
    v25[1] = v14;
    fiat_p256_square((uint64_t *)v25, (unint64_t *)v26);
    int v15 = 31;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v15;
    }

    while (v15);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v24);
    int v16 = 128;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v16;
    }

    while (v16);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v26);
    int v17 = 32;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v17;
    }

    while (v17);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v26);
    int v18 = 30;
    do
    {
      fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
      --v18;
    }

    while (v18);
    fiat_p256_mul((uint64_t *)v25, (unint64_t *)v25, (unint64_t *)v27);
    fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
    fiat_p256_square((uint64_t *)v23, (unint64_t *)v25);
    if (a3)
    {
      __int128 v19 = a2[1];
      __int128 v32 = *a2;
      __int128 v33 = v19;
      fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v23);
      __int128 v20 = v33;
      *a3 = v32;
      a3[1] = v20;
    }

    if (a4)
    {
      __int128 v21 = *(__int128 *)((char *)a2 + 88);
      __int128 v32 = *(__int128 *)((char *)a2 + 72);
      __int128 v33 = v21;
      fiat_p256_square((uint64_t *)v23, (unint64_t *)v23);
      fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v24);
      fiat_p256_mul((uint64_t *)&v32, (unint64_t *)&v32, (unint64_t *)v23);
      __int128 v22 = v33;
      *a4 = v32;
      a4[1] = v22;
    }

    return 1LL;
  }

double ec_GFp_nistp256_add(uint64_t a1, _OWORD *a2, __int128 *a3, _OWORD *a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  __int128 v5 = a3[1];
  __int128 v22 = *a3;
  __int128 v23 = v5;
  __int128 v6 = *(__int128 *)((char *)a3 + 88);
  __int128 v20 = *(__int128 *)((char *)a3 + 72);
  __int128 v21 = v6;
  __int128 v7 = a3[10];
  __int128 v18 = a3[9];
  __int128 v19 = v7;
  __int128 v8 = a4[1];
  v17[0] = *a4;
  v17[1] = v8;
  __int128 v9 = *(_OWORD *)((char *)a4 + 88);
  v16[0] = *(_OWORD *)((char *)a4 + 72);
  v16[1] = v9;
  __int128 v10 = a4[10];
  v15[0] = a4[9];
  v15[1] = v10;
  fiat_p256_point_add( (uint64_t *)&v22,  (uint64_t *)&v20,  (uint64_t *)&v18,  (uint64_t)&v22,  (uint64_t)&v20,  (unint64_t *)&v18,  0,  (unint64_t *)v17,  (unint64_t *)v16,  (unint64_t *)v15);
  __int128 v11 = v23;
  *a2 = v22;
  a2[1] = v11;
  __int128 v12 = v21;
  *(_OWORD *)((char *)a2 + 72) = v20;
  *(_OWORD *)((char *)a2 + 8bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v12;
  double result = *(double *)&v18;
  __int128 v14 = v19;
  a2[9] = v18;
  a2[10] = v14;
  return result;
}

double ec_GFp_nistp256_dbl(uint64_t a1, _OWORD *a2, __int128 *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  __int128 v4 = a3[1];
  __int128 v15 = *a3;
  __int128 v16 = v4;
  __int128 v5 = *(__int128 *)((char *)a3 + 88);
  __int128 v13 = *(__int128 *)((char *)a3 + 72);
  __int128 v14 = v5;
  __int128 v6 = a3[10];
  __int128 v11 = a3[9];
  __int128 v12 = v6;
  fiat_p256_point_double( (uint64_t *)&v15,  (uint64_t *)&v13,  (uint64_t *)&v11,  (unint64_t *)&v15,  (unint64_t *)&v13,  (unint64_t *)&v11);
  __int128 v7 = v16;
  *a2 = v15;
  a2[1] = v7;
  __int128 v8 = v14;
  *(_OWORD *)((char *)a2 + 72) = v13;
  *(_OWORD *)((char *)a2 + 8bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v8;
  double result = *(double *)&v11;
  __int128 v10 = v12;
  a2[9] = v11;
  a2[10] = v10;
  return result;
}

double ec_GFp_nistp256_point_mul(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t a4)
{
  v86[0] = *MEMORY[0x1895F89C0];
  bzero(v81, 0x660uLL);
  __int128 v6 = a3[1];
  v83[0] = *a3;
  v83[1] = v6;
  __int128 v7 = *(_OWORD *)((char *)a3 + 88);
  v84[0] = *(_OWORD *)((char *)a3 + 72);
  v84[1] = v7;
  __int128 v8 = a3[9];
  __int128 v9 = a3[10];
  unint64_t v10 = -1440LL;
  unint64_t v11 = 2LL;
  v85[0] = v8;
  v85[1] = v9;
  do
  {
    __int128 v12 = &v86[v10 / 8];
    __int128 v13 = &v86[v10 / 8 + 4];
    __int128 v14 = &v86[v10 / 8 + 8];
    if ((v11 & 1) != 0) {
      fiat_p256_point_add( v12,  v13,  v14,  (uint64_t)v83,  (uint64_t)v84,  (unint64_t *)v85,  0,  (unint64_t *)&v85[v10 / 0x10 + 86],  (unint64_t *)&v85[v10 / 0x10 + 88],  (unint64_t *)&v85[v10 / 0x10 + 90]);
    }
    else {
      fiat_p256_point_double( v12,  v13,  v14,  (unint64_t *)&v81[6 * (v11 >> 1)],  (unint64_t *)&v81[6 * (v11 >> 1) + 2],  (unint64_t *)&v82[96 * (v11 >> 1) + 16]);
    }
    ++v11;
    v10 += 96LL;
  }

  while (v10);
  __int128 v79 = 0u;
  __int128 v80 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  int v15 = 1;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  for (unint64_t i = 255LL; i < 0x100; --i)
  {
    if (!v15) {
      fiat_p256_point_double( (uint64_t *)&v75,  (uint64_t *)&v77,  (uint64_t *)&v79,  (unint64_t *)&v75,  (unint64_t *)&v77,  (unint64_t *)&v79);
    }
    if (-858993459 * i <= 0x33333333)
    {
      if (i <= 0xFB)
      {
        uint64_t v17 = 32 * ((*(void *)(a4 + 8LL * ((i + 4) >> 6)) >> (i + 4)) & 1LL);
        unsigned int v18 = i + 3;
      }

      else
      {
        if ((_DWORD)i != 252)
        {
          if (i > 0xFD)
          {
            uint64_t v21 = 0LL;
            if ((_DWORD)i != 254)
            {
              uint64_t v23 = 0LL;
LABEL_17:
              else {
                uint64_t v24 = 0LL;
              }
              unint64_t v25 = v21 | (4 * v23) | (2 * ((*(void *)(a4 + 8LL * (i >> 6)) >> i) & 1LL)) | v24;
              unint64_t v67 = 0xAAAAAAAAAAAAAAAALL;
              uint64_t v68 = 0xAAAAAAAAAAAAAAAALL;
              ec_GFp_nistp_recode_scalar_bits(&v68, &v67, v25);
              uint64_t v26 = 0LL;
              uint64_t v27 = 0LL;
              uint64_t v28 = 0LL;
              uint64_t v29 = 0LL;
              uint64_t v30 = 0LL;
              uint64_t v31 = 0LL;
              uint64_t v32 = 0LL;
              uint64_t v33 = 0LL;
              uint64_t v34 = 0LL;
              uint64_t v35 = 0LL;
              uint64_t v36 = 0LL;
              uint64_t v37 = 0LL;
              uint64_t v38 = 0LL;
              uint64_t v39 = v82;
              do
              {
                if (v67 == v38) {
                  uint64_t v40 = -1LL;
                }
                else {
                  uint64_t v40 = 0LL;
                }
                if (v67 == v38) {
                  uint64_t v41 = 0LL;
                }
                else {
                  uint64_t v41 = -1LL;
                }
                uint64_t v37 = v40 & *(v39 - 6) | v41 & v37;
                uint64_t v34 = v34 & v41 | *(v39 - 5) & v40;
                uint64_t v33 = v33 & v41 | *(v39 - 4) & v40;
                uint64_t v32 = v32 & v41 | *(v39 - 3) & v40;
                uint64_t v36 = v36 & v41 | *(v39 - 2) & v40;
                uint64_t v31 = v31 & v41 | *(v39 - 1) & v40;
                uint64_t v30 = v30 & v41 | *v39 & v40;
                uint64_t v29 = v29 & v41 | v39[1] & v40;
                uint64_t v35 = v35 & v41 | v39[2] & v40;
                uint64_t v28 = v28 & v41 | v39[3] & v40;
                uint64_t v27 = v27 & v41 | v39[4] & v40;
                uint64_t v26 = v26 & v41 | v39[5] & v40;
                ++v38;
                v39 += 12;
              }

              while (v38 != 17);
              *(void *)&__int128 v70 = v33;
              *((void *)&v70 + 1) = v32;
              *(void *)&__int128 v74 = v27;
              *((void *)&v74 + 1) = v26;
              *(void *)&__int128 v69 = v37;
              *((void *)&v69 + 1) = v34;
              *(void *)&__int128 v73 = v35;
              *((void *)&v73 + 1) = v28;
              BOOL v42 = __CFADD__( v31,  -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v26, v36) >> 64));
              uint64_t v43 = v31 + -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v26, v36) >> 64);
              char v44 = v42;
              BOOL v42 = v43 == 0;
              uint64_t v45 = -v43;
              uint64_t v47 = (v44 + !v42);
              uint64_t v46 = v30 + v47;
              BOOL v48 = __CFADD__(v30, v47);
              BOOL v42 = v46 == 0;
              uint64_t v49 = -v46;
              uint64_t v51 = (v48 + !v42);
              uint64_t v50 = v29 + v51;
              BOOL v52 = __CFADD__(v29, v51);
              BOOL v42 = v50 == 0;
              uint64_t v53 = -v50;
              if (v52 + !v42) {
                uint64_t v54 = -1LL;
              }
              else {
                uint64_t v54 = 0LL;
              }
              uint64_t v55 = v54 - v36;
              BOOL v42 = __CFADD__(__CFADD__(-v36, v54), v45);
              uint64_t v56 = __CFADD__(-v36, v54) + v45;
              v42 |= __CFADD__(v54, v56);
              v56 += v54;
              BOOL v58 = v42;
              BOOL v42 = __CFADD__(v42, v49);
              uint64_t v57 = v58 + v49;
              unint64_t v59 = v53 + v42 + (v54 & 0xFFFFFFFF00000001LL);
              if (v68) {
                uint64_t v60 = 0LL;
              }
              else {
                uint64_t v60 = -1LL;
              }
              if (v68) {
                uint64_t v61 = -1LL;
              }
              else {
                uint64_t v61 = 0LL;
              }
              *(void *)&__int128 v71 = v60 & v36 | v61 & v55;
              *((void *)&v71 + 1) = v61 & v56 | v60 & v31;
              *(void *)&__int128 v72 = v61 & v57 | v60 & v30;
              *((void *)&v72 + 1) = v59 & v61 | v60 & v29;
              if (v15)
              {
                __int128 v75 = v69;
                __int128 v76 = v70;
                __int128 v77 = v71;
                __int128 v78 = v72;
                __int128 v79 = v73;
                __int128 v80 = v74;
              }

              else
              {
                fiat_p256_point_add( (uint64_t *)&v75,  (uint64_t *)&v77,  (uint64_t *)&v79,  (uint64_t)&v75,  (uint64_t)&v77,  (unint64_t *)&v79,  0,  (unint64_t *)&v69,  (unint64_t *)&v71,  (unint64_t *)&v73);
              }

              int v15 = 0;
              continue;
            }

            unsigned int v22 = 255;
LABEL_16:
            uint64_t v23 = (*(void *)(a4 + 8LL * (v22 >> 6)) >> v22) & 1LL;
            goto LABEL_17;
          }

          uint64_t v19 = 0LL;
          unsigned int v20 = 255;
LABEL_15:
          uint64_t v21 = (8 * ((*(void *)(a4 + 8LL * (v20 >> 6)) >> v20) & 1LL)) | v19;
          unsigned int v22 = i + 1;
          goto LABEL_16;
        }

        uint64_t v17 = 0LL;
        unsigned int v18 = 255;
      }

      uint64_t v19 = (16 * ((*(void *)(a4 + 8LL * (v18 >> 6)) >> v18) & 1LL)) | v17;
      unsigned int v20 = i + 2;
      goto LABEL_15;
    }
  }

  __int128 v62 = v76;
  *a2 = v75;
  a2[1] = v62;
  __int128 v63 = v78;
  *(_OWORD *)((char *)a2 + 72) = v77;
  *(_OWORD *)((char *)a2 + 8bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v63;
  double result = *(double *)&v79;
  __int128 v65 = v80;
  a2[9] = v79;
  a2[10] = v65;
  return result;
}

double ec_GFp_nistp256_point_mul_base(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  char v5 = 0;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v17 = v6;
  __int128 v18 = v6;
  __int128 v15 = v6;
  __int128 v16 = v6;
  uint64_t v7 = 223LL;
  __int128 v13 = v6;
  __int128 v14 = v6;
  do
  {
    if ((v5 & 1) != 0) {
      fiat_p256_point_double( (uint64_t *)&v19,  (uint64_t *)&v21,  (uint64_t *)&v23,  (unint64_t *)&v19,  (unint64_t *)&v21,  (unint64_t *)&v23);
    }
    fiat_p256_select_point_affine( (8 * ((*(void *)(a3 + 8LL * ((v7 + 32) >> 6)) >> (v7 + 96)) & 1LL)) | (4 * ((*(void *)(a3 + 8LL * ((v7 - 32) >> 6)) >> (v7 + 96)) & 1LL)) | (2 * ((*(void *)(a3 + 8LL * ((v7 - 96) >> 6)) >> (v7 + 96)) & 1LL)) | (*(void *)(a3 + 8LL * ((v7 - 160) >> 6)) >> (v7 + 96)) & 1LL,  (uint64_t)&unk_187609BB0,  &v13);
    if ((v5 & 1) != 0)
    {
      fiat_p256_point_add( (uint64_t *)&v19,  (uint64_t *)&v21,  (uint64_t *)&v23,  (uint64_t)&v19,  (uint64_t)&v21,  (unint64_t *)&v23,  1,  (unint64_t *)&v13,  (unint64_t *)&v15,  (unint64_t *)&v17);
    }

    else
    {
      __int128 v19 = v13;
      __int128 v20 = v14;
      __int128 v21 = v15;
      __int128 v22 = v16;
      __int128 v23 = v17;
      __int128 v24 = v18;
    }

    fiat_p256_select_point_affine( (8 * ((*(void *)(a3 + 8LL * (v7 >> 6)) >> v7) & 1LL)) | (4 * ((*(void *)(a3 + 8LL * ((v7 - 64) >> 6)) >> (v7 + 64)) & 1LL)) | (2 * ((*(void *)(a3 + 8LL * ((v7 - 128) >> 6)) >> (v7 + 64)) & 1LL)) | (*(void *)(a3 + 8LL * ((v7 - 192) >> 6)) >> (v7 + 64)) & 1LL,  (uint64_t)&fiat_p256_g_pre_comp,  &v13);
    char v5 = 1;
    fiat_p256_point_add( (uint64_t *)&v19,  (uint64_t *)&v21,  (uint64_t *)&v23,  (uint64_t)&v19,  (uint64_t)&v21,  (unint64_t *)&v23,  1,  (unint64_t *)&v13,  (unint64_t *)&v15,  (unint64_t *)&v17);
    unint64_t v8 = v7 - 193;
    --v7;
  }

  while (v8 < 0x20);
  __int128 v9 = v20;
  *a2 = v19;
  a2[1] = v9;
  __int128 v10 = v22;
  *(_OWORD *)((char *)a2 + 72) = v21;
  *(_OWORD *)((char *)a2 + 8bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v10;
  double result = *(double *)&v23;
  __int128 v12 = v24;
  a2[9] = v23;
  a2[10] = v12;
  return result;
}

double ec_GFp_nistp256_point_mul_public(uint64_t a1, _OWORD *a2, uint64_t a3, _OWORD *a4, _DWORD *a5)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  __int128 v9 = a4[1];
  v68[0] = *a4;
  v68[1] = v9;
  __int128 v10 = *(_OWORD *)((char *)a4 + 88);
  v69[0] = *(_OWORD *)((char *)a4 + 72);
  v69[1] = v10;
  memset(v71, 170, sizeof(v71));
  __int128 v11 = a4[10];
  v70[0] = a4[9];
  v70[1] = v11;
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v67[0] = v12;
  v67[1] = v12;
  v66[0] = v12;
  v66[1] = v12;
  v65[0] = v12;
  v65[1] = v12;
  fiat_p256_point_double( (uint64_t *)v65,  (uint64_t *)v66,  (uint64_t *)v67,  (unint64_t *)v68,  (unint64_t *)v69,  (unint64_t *)v70);
  for (uint64_t i = 0LL; i != 42; i += 6LL)
    fiat_p256_point_add( (uint64_t *)&v71[i * 16],  (uint64_t *)&v71[i * 16 + 32],  (uint64_t *)&v71[i * 16 + 64],  (uint64_t)&v68[i],  (uint64_t)&v68[i + 2],  (unint64_t *)&v70[i],  0,  (unint64_t *)v65,  (unint64_t *)v66,  (unint64_t *)v67);
  char v64 = -86;
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v63[14] = v14;
  v63[15] = v14;
  v63[12] = v14;
  v63[13] = v14;
  v63[10] = v14;
  v63[11] = v14;
  v63[8] = v14;
  v63[9] = v14;
  v63[6] = v14;
  v63[7] = v14;
  v63[4] = v14;
  v63[5] = v14;
  v63[2] = v14;
  v63[3] = v14;
  v63[0] = v14;
  v63[1] = v14;
  unint64_t v15 = 256LL;
  ec_compute_wNAF(a1, v63, a5, 0x100uLL, 4u);
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  int v17 = 1;
  do
  {
    if (!v17) {
      fiat_p256_point_double( (uint64_t *)&v57,  (uint64_t *)&v59,  (uint64_t *)&v61,  (unint64_t *)&v57,  (unint64_t *)&v59,  (unint64_t *)&v61);
    }
    if (v15 <= 0x1F)
    {
      uint64_t v18 = (8 * ((*(void *)(a3 + 8LL * ((v15 + 224) >> 6)) >> (v15 - 32)) & 1LL)) | (4 * ((*(void *)(a3 + 8LL * ((v15 + 160) >> 6)) >> (v15 - 96)) & 1LL)) | (2 * ((*(void *)(a3 + 8LL * ((v15 + 96) >> 6)) >> (v15 + 96)) & 1LL)) | (*(void *)(a3 + (((v15 + 32) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v15 + 32)) & 1LL;
      if (v18)
      {
        fiat_p256_point_add( (uint64_t *)&v57,  (uint64_t *)&v59,  (uint64_t *)&v61,  (uint64_t)&v57,  (uint64_t)&v59,  (unint64_t *)&v61,  1,  &fiat_p256_g_pre_comp[8 * v18 + 112],  &fiat_p256_g_pre_comp[8 * v18 + 116],  fiat_p256_one);
        int v17 = 0;
      }

      uint64_t v19 = (8 * ((*(void *)(a3 + (((v15 + 192) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v15) & 1LL)) | (4
                                                                                                  * ((*(void *)(a3 + (((v15 + 128) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v15) & 1LL)) | (2 * ((*(void *)(a3 + (((v15 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v15) & 1LL)) | (*(void *)(a3 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v15) & 1LL;
      if (v19)
      {
        fiat_p256_point_add( (uint64_t *)&v57,  (uint64_t *)&v59,  (uint64_t *)&v61,  (uint64_t)&v57,  (uint64_t)&v59,  (unint64_t *)&v61,  1,  &fiat_p256_g_pre_comp[8 * v19 - 8],  &fiat_p256_g_pre_comp[8 * v19 - 4],  fiat_p256_one);
        int v17 = 0;
      }
    }

    int v20 = *((char *)v63 + v15);
    if (*((_BYTE *)v63 + v15))
    {
      if ((v20 & 1) == 0) {
        ec_GFp_nistp256_point_mul_public_cold_1();
      }
      if (v20 >= 0) {
        unsigned int v21 = *((char *)v63 + v15);
      }
      else {
        unsigned int v21 = -v20;
      }
      unsigned int v22 = v21 >> 1;
      __int128 v23 = &v68[6 * v22];
      __int128 v24 = (unint64_t *)(v23 + 2);
      *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v55 = v25;
      __int128 v56 = v25;
      if (v20 < 0)
      {
        uint64_t v30 = *((void *)v23 + 5);
        uint64_t v31 = -(uint64_t)*v24;
        unsigned __int8 v32 = -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v16, *v24) >> 64);
        BOOL v33 = __CFADD__(v30, v32);
        uint64_t v34 = v30 + v32;
        char v35 = v33;
        BOOL v33 = v34 == 0;
        uint64_t v36 = -v34;
        uint64_t v38 = *((void *)v23 + 6);
        uint64_t v37 = *((void *)v23 + 7);
        uint64_t v40 = (v35 + !v33);
        uint64_t v39 = v38 + v40;
        BOOL v41 = __CFADD__(v38, v40);
        BOOL v33 = v39 == 0;
        uint64_t v42 = -v39;
        unsigned __int8 v43 = v41 + !v33;
        BOOL v33 = __CFADD__(v37, v43);
        uint64_t v44 = v37 + v43;
        char v45 = v33;
        BOOL v33 = v44 == 0;
        uint64_t v46 = -v44;
        if (v45 + !v33) {
          uint64_t v47 = -1LL;
        }
        else {
          uint64_t v47 = 0LL;
        }
        BOOL v33 = __CFADD__(__CFADD__(v31, v47), v36);
        uint64_t v48 = __CFADD__(v31, v47) + v36;
        uint64_t v49 = v33 | __CFADD__(v47, v48);
        BOOL v33 = __CFADD__(v49, v42);
        unint64_t v16 = v49 + v42;
        *(void *)&__int128 v55 = v31 + v47;
        *((void *)&v55 + 1) = v47 + v48;
        *(void *)&__int128 v56 = v16;
        *((void *)&v56 + 1) = v46 + v33 + (v47 & 0xFFFFFFFF00000001LL);
        __int128 v24 = (unint64_t *)&v55;
        if (v17) {
          goto LABEL_18;
        }
      }

      else if (v17)
      {
LABEL_18:
        __int128 v26 = v23[1];
        __int128 v57 = *v23;
        __int128 v58 = v26;
        __int128 v27 = *((_OWORD *)v24 + 1);
        __int128 v59 = *(_OWORD *)v24;
        __int128 v60 = v27;
        uint64_t v28 = &v68[6 * v22];
        __int128 v29 = v28[5];
        __int128 v61 = v28[4];
        __int128 v62 = v29;
LABEL_33:
        int v17 = 0;
        goto LABEL_34;
      }

      fiat_p256_point_add( (uint64_t *)&v57,  (uint64_t *)&v59,  (uint64_t *)&v61,  (uint64_t)&v57,  (uint64_t)&v59,  (unint64_t *)&v61,  0,  (unint64_t *)v23,  v24,  (unint64_t *)&v70[6 * v22]);
      goto LABEL_33;
    }

BOOL ec_GFp_nistp256_cmp_x_coordinate(uint64_t a1, __int128 *a2, const unint64_t *a3)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  __int128 v7 = a2[10];
  v89[0] = a2[9];
  v89[1] = v7;
  fiat_p256_mul((uint64_t *)v89, (unint64_t *)v89, (unint64_t *)v89);
  __int128 v8 = *((_OWORD *)a3 + 1);
  __int128 v87 = *(_OWORD *)a3;
  __int128 v88 = v8;
  fiat_p256_mul((uint64_t *)&v87, (unint64_t *)&v87, (unint64_t *)v89);
  __int128 v9 = a2[1];
  __int128 v85 = *a2;
  uint64_t v10 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v11 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v12 = 0xFFFFFFFFLL * v85 + __CFADD__(-(uint64_t)v85, (void)v85) + v11;
  uint64_t v13 = __CFADD__(__CFADD__(-(uint64_t)v85, (void)v85), v11) | __CFADD__( 0xFFFFFFFFLL * v85,  __CFADD__(-(uint64_t)v85, (void)v85)
                                                                                 + v11)
      ? (((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1
      : ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v30 = __CFADD__(v12, *((void *)&v85 + 1));
  uint64_t v14 = v12 + *((void *)&v85 + 1);
  BOOL v15 = v30;
  unint64_t v16 = 0xFFFFFFFF00000001LL * v14;
  uint64_t v17 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * (unint64_t)v14) >> 64;
  BOOL v18 = v15 + __CFADD__(-v14, v14) + v13;
  BOOL v30 = __CFADD__(v18, v17);
  uint64_t v19 = v18 + v17;
  uint64_t v20 = v30 - 0xFFFFFFFFLL * v85;
  BOOL v21 = __CFADD__(v30, 0xFFFFFFFF00000001LL * v85);
  BOOL v30 = __CFADD__(v16, v10);
  uint64_t v22 = v16 + v10;
  BOOL v23 = v30;
  BOOL v30 = __CFADD__(((unint64_t)v14 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFFLL * v14);
  __int128 v86 = v9;
  unint64_t v24 = ((unint64_t)v14 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v25 = ((unint64_t)v14 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  uint64_t v27 = v30 + v20;
  BOOL v30 = __CFADD__(v30, v20) | __CFADD__(v25, v27);
  uint64_t v26 = v25 + v27;
  BOOL v28 = v21 + v30 + v22;
  uint64_t v29 = __CFADD__(v30, v22) | __CFADD__(v21, v30 + v22) ? v23 + 1 : v23;
  BOOL v30 = __CFADD__(v19, (void)v86);
  unint64_t v31 = v19 + v86;
  BOOL v32 = v30;
  uint64_t v33 = v30 + v26;
  unint64_t v34 = (v31 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  unsigned __int128 v35 = __PAIR128__(v29, __CFADD__(v30, v26)) + __PAIR128__(v24, v28);
  uint64_t v36 = 0xFFFFFFFF * v31;
  uint64_t v37 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * v31) >> 64;
  BOOL v38 = v32 + __CFADD__(-(uint64_t)v31, v31) + v26;
  unint64_t v39 = (__CFADD__(__CFADD__(-(uint64_t)v31, v31), v33) | __CFADD__( v37,  __CFADD__(-(uint64_t)v31, v31) + v33))
      + (void)v35;
  BOOL v40 = __CFADD__( __CFADD__(__CFADD__(-(uint64_t)v31, v31), v33) | __CFADD__( v37,  __CFADD__(-(uint64_t)v31, v31) + v33),  (void)v35);
  BOOL v41 = __CFADD__(0xFFFFFFFF00000001LL * v31, *((void *)&v35 + 1));
  uint64_t v42 = 0xFFFFFFFF * v31;
  unint64_t v43 = (v31 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v44 = (v31 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  uint64_t v45 = v38 + v34 + v36;
  BOOL v30 = __CFADD__(__CFADD__(v34, v36), v39) | __CFADD__(v44, (__PAIR128__(v39, v34) + (unint64_t)v42) >> 64);
  uint64_t v46 = v44 + ((__PAIR128__(v39, v34) + (unint64_t)v42) >> 64);
  BOOL v47 = v40 + v30 + *((void *)&v35 + 1);
  uint64_t v48 = __CFADD__(v30, *((void *)&v35 + 1)) | __CFADD__(v40, v30 + *((void *)&v35 + 1))
      ? v41 + 1
      : v41;
  BOOL v49 = __CFADD__(v45, *((void *)&v86 + 1));
  unint64_t v50 = v45 + *((void *)&v86 + 1);
  BOOL v51 = v49;
  uint64_t v52 = v49 + v46;
  unint64_t v53 = (v50 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  unsigned __int128 v54 = __PAIR128__(v48, __CFADD__(v49, v46)) + __PAIR128__(v43, v47);
  unint64_t v55 = 0xFFFFFFFF00000001LL * v50;
  uint64_t v56 = -(uint64_t)v50;
  unint64_t v57 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * v50) >> 64;
  uint64_t v58 = __CFADD__((v50 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v50)
      ? ((v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1
      : (v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v30 = __CFADD__(v56, v50);
  unint64_t v59 = v51 + __CFADD__(v56, v50) + v46 + v57;
  unint64_t v60 = v58 + (__CFADD__(v30, v52) | __CFADD__(v57, v30 + v52)) + (void)v54;
  uint64_t v62 = __CFADD__(__CFADD__(v30, v52) | __CFADD__(v57, v30 + v52), (void)v54) | __CFADD__(v58, (__CFADD__(v30, v52) | __CFADD__(v57, v30 + v52)) + (void)v54);
  unint64_t v61 = *((void *)&v54 + 1) + v62 + v55;
  uint64_t v63 = __CFADD__(v62, v55) | __CFADD__(*((void *)&v54 + 1), v62 + v55) ? v53 + 1 : v53;
  unint64_t v65 = v60 - (1 - __CFADD__(v59, 1LL));
  unint64_t v64 = (v60 - __PAIR128__(v53, (1 - __CFADD__(v59, 1LL)))) >> 64;
  unsigned __int128 v66 = (unint64_t)v63
      - __PAIR128__( v57,  -(uint64_t)((v61 - __PAIR128__( v64,  (1 - (__CFADD__(v65, 0xFFFFFFFF00000001LL) + v64)))) >> 64));
  uint64_t v67 = __CFADD__((void)v66, 0xFFFFFFFFLL) + BYTE8(v66) == 1 ? -1LL : 0LL;
  uint64_t v68 = v67 & (v59 + 1) | *((void *)&v66 + 1) & v59;
  uint64_t v69 = v67 & (v65 - 0xFFFFFFFF) | *((void *)&v66 + 1) & v60;
  uint64_t v70 = v67 & (v61 - (1 - (__CFADD__(v65, 0xFFFFFFFF00000001LL) + v64))) | *((void *)&v66 + 1) & v61;
  uint64_t v71 = v67 & (v66 + 0xFFFFFFFF) | v63 & *((void *)&v66 + 1);
  *(void *)&__int128 v85 = v68;
  *((void *)&v85 + 1) = v69;
  *(void *)&__int128 v86 = v70;
  *((void *)&v86 + 1) = v71;
  BOOL v72 = (void)v87 == v68 && *((void *)&v87 + 1) == v69;
  BOOL v73 = v72 && (void)v88 == v70;
  if (v73 && *((void *)&v88 + 1) == v71) {
    return 1LL;
  }
  int v75 = *(_DWORD *)(a1 + 328);
  if (v75 != *(_DWORD *)(a1 + 264)) {
    ec_GFp_nistp256_cmp_x_coordinate_cold_1();
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v76 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v76 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v82 = v76;
  __int128 v83 = v76;
  __int128 v80 = v76;
  __int128 v81 = v76;
  if (bn_add_words((unint64_t *)&v80, a3, *(const unint64_t **)(a1 + 256), v75)
    || !bn_less_than_words((uint64_t *)&v80, *(uint64_t **)(a1 + 320), *(int *)(a1 + 328)))
  {
    return 0LL;
  }

  __int128 v87 = v80;
  __int128 v88 = v81;
  fiat_p256_mul((uint64_t *)&v87, (unint64_t *)&v87, (unint64_t *)v89);
  BOOL v77 = (void)v87 == (void)v85 && *((void *)&v87 + 1) == *((void *)&v85 + 1);
  BOOL v78 = v77 && (void)v88 == (void)v86;
  return v78 && *((void *)&v88 + 1) == *((void *)&v86 + 1);
}

uint64_t *fiat_p256_mul(uint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a2;
  unint64_t v3 = a2[1];
  unint64_t v6 = a3[2];
  unint64_t v5 = a3[3];
  unint64_t v7 = v5 * *a2;
  unint64_t v8 = v6 * *a2;
  uint64_t v9 = (v6 * (unsigned __int128)*a2) >> 64;
  unint64_t v11 = *a3;
  unint64_t v10 = a3[1];
  uint64_t v12 = (v10 * (unsigned __int128)*a2) >> 64;
  unint64_t v13 = v10 * *a2;
  uint64_t v14 = (v11 * (unsigned __int128)*a2) >> 64;
  unint64_t v15 = v11 * *a2;
  uint64_t v16 = (v15 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  uint64_t v17 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * v15) >> 64;
  uint64_t v18 = v14 + v13;
  BOOL v30 = __CFADD__(__CFADD__(v14, v13), v12) | __CFADD__(v8, __CFADD__(v14, v13) + v12);
  unint64_t v19 = v8 + __CFADD__(v14, v13) + v12;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v21 = v9 + v7 + v30 - 0xFFFFFFFF * v15;
  unint64_t v22 = v13 + __CFADD__(-(uint64_t)(v11 * v4), v15) + v14 + v17;
  uint64_t v23 = v16
      + (__CFADD__(__CFADD__(-(uint64_t)(v11 * v4), v15), v18) | __CFADD__( v17,  __CFADD__(-(uint64_t)(v11 * v4), v15)
                                                                                 + v18))
      + v19;
  unint64_t v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v26 = (v11 * (unsigned __int128)v3) >> 64;
  uint64_t v27 = v6 * v3 + __CFADD__(v26, v10 * v3) + ((v10 * (unsigned __int128)v3) >> 64);
  unint64_t v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unsigned __int128 v29 = __PAIR128__(v10 * v3, v22) + v11 * (unsigned __int128)v3;
  BOOL v30 = __CFADD__(__CFADD__(v22, v11 * v3), (__PAIR128__(v10, v11) * v3) >> 64) | __CFADD__( v23,  __CFADD__(v22, v11 * v3)
                                                                                  + ((__PAIR128__(v10, v11) * v3) >> 64));
  unint64_t v31 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  if (v30) {
    uint64_t v32 = v27 + 1;
  }
  else {
    uint64_t v32 = v6 * v3 + __CFADD__(v26, v10 * v3) + ((v10 * (unsigned __int128)v3) >> 64);
  }
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v25);
  uint64_t v33 = v21
  uint64_t v34 = (v5 * (unsigned __int128)v3) >> 64;
  unint64_t v35 = v5 * v3;
  uint64_t v36 = (v6 * (unsigned __int128)v3) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v28);
  BOOL v39 = v30;
  char v37 = __CFADD__(v30, v36) | __CFADD__(v35, v30 + v36);
  unint64_t v38 = v35 + v39 + v36;
  if (v37) {
    ++v34;
  }
  uint64_t v40 = (v5 * (unsigned __int128)v4) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  uint64_t v43 = v37;
  char v41 = __CFADD__(v37, v9) | __CFADD__(v7, v37 + v9);
  unint64_t v42 = v7 + v43 + v9;
  if (v41) {
    uint64_t v44 = v40 + 1;
  }
  else {
    uint64_t v44 = v40;
  }
  uint64_t v45 = (v15 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v24);
  if (v41) {
    uint64_t v46 = v21 + 1;
  }
  else {
    uint64_t v46 = v21;
  }
  uint64_t v48 = __CFADD__(v41, v42) | __CFADD__(0xFFFFFFFF00000001LL * v15, v41 + v42);
  uint64_t v47 = v44 + v48 + v45;
  uint64_t v51 = __CFADD__(v48, v45) | __CFADD__(v44, v48 + v45);
  BOOL v49 = __CFADD__(v51, v34);
  uint64_t v50 = v51 + v34;
  BOOL v52 = __CFADD__(v51, v34);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v31);
  uint64_t v54 = __CFADD__(v49, v27) | __CFADD__(v46, v49 + v27);
  unint64_t v53 = v47 + v54 + v38;
  uint64_t v55 = (__CFADD__(v54, v38) | __CFADD__(v47, v54 + v38)) + v50;
  unint64_t v56 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v57 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v58 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * (unint64_t)v29) >> 64;
  uint64_t v59 = v23 + __CFADD__(-(uint64_t)v29, (void)v29) + *((void *)&v29 + 1);
  BOOL v30 = __CFADD__( __CFADD__(__CFADD__(-(uint64_t)v29, (void)v29), *((void *)&v29 + 1) + v23) | __CFADD__(v58, __CFADD__(-(uint64_t)v29, (void)v29) + *((void *)&v29 + 1) + v23),  v33);
  uint64_t v61 = v30;
  unint64_t v62 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v63 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v30 = __CFADD__(__CFADD__(v57, 0xFFFFFFFF * v29), v60) | __CFADD__( v63,  (__PAIR128__(v60, v57)
                                                            + (unint64_t)(0xFFFFFFFF * v29)) >> 64);
  uint64_t v64 = v63 + ((__PAIR128__(v60, v57) + (unint64_t)(0xFFFFFFFF * v29)) >> 64);
  unint64_t v65 = v61 + v30 - 0xFFFFFFFF * v29;
  if (__CFADD__(v30, 0xFFFFFFFF00000001LL * v29) | __CFADD__(v61, v30 - 0xFFFFFFFF * v29)) {
    uint64_t v66 = 1LL;
  }
  else {
    uint64_t v66 = 0LL;
  }
  BOOL v30 = __CFADD__(v65, v53);
  uint64_t v69 = (__PAIR128__(v62, v65) + v53) >> 64;
  unint64_t v67 = v65 + v53;
  BOOL v30 = __CFADD__(v30, v62) | __CFADD__(v66, v69);
  uint64_t v68 = v66 + v69;
  uint64_t v70 = v30;
  BOOL v71 = __CFADD__(v68, v55);
  uint64_t v72 = v68 + v55;
  if (v71) {
    ++v70;
  }
  unint64_t v73 = v59 + ((__PAIR128__(0xFFFFFFFFLL, -1LL) * (unint64_t)v29) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v56);
  uint64_t v74 = v52 + v71 + v70;
  unint64_t v76 = a2[2];
  unint64_t v75 = a2[3];
  uint64_t v77 = (v5 * (unsigned __int128)v76) >> 64;
  unint64_t v78 = v5 * v76;
  uint64_t v79 = (v6 * (unsigned __int128)v76) >> 64;
  unint64_t v80 = v6 * v76;
  uint64_t v81 = (v10 * (unsigned __int128)v76) >> 64;
  unint64_t v82 = v10 * v76;
  unint64_t v83 = v11 * v76;
  unint64_t v84 = (v11 * (unsigned __int128)v76) >> 64;
  unint64_t v85 = v84 + v82;
  BOOL v30 = __CFADD__(__CFADD__(v84, v82), v81) | __CFADD__(v80, __CFADD__(v84, v82) + v81);
  unint64_t v86 = v80 + __CFADD__(v84, v82) + v81;
  uint64_t v88 = v30 + v79;
  BOOL v30 = __CFADD__(v30, v79) | __CFADD__(v78, v88);
  uint64_t v87 = v78 + v88;
  if (v30) {
    ++v77;
  }
  unsigned __int128 v89 = __PAIR128__(v84, v73) + __PAIR128__(v82, v83);
  uint64_t v90 = ((__PAIR128__(v84, v73) + __PAIR128__(v82, v83)) >> 64) + v64;
  unint64_t v92 = (__CFADD__(__CFADD__(v73, v83), v85) | __CFADD__(v64, __CFADD__(v73, v83) + v85)) + v86;
  BOOL v30 = __CFADD__(__CFADD__(__CFADD__(v73, v83), v85) | __CFADD__(v64, __CFADD__(v73, v83) + v85), v86) | __CFADD__(v67, v92);
  unint64_t v91 = v67 + v92;
  uint64_t v94 = v30 + v87;
  BOOL v30 = __CFADD__(v30, v87) | __CFADD__(v72, v94);
  uint64_t v93 = v72 + v94;
  uint64_t v95 = v77 + v30 + v74;
  unint64_t v96 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v97 = 0xFFFFFFFF00000001LL * (v73 + v83);
  uint64_t v98 = v64 + __CFADD__(-(uint64_t)v89, (void)v89) + *((void *)&v89 + 1);
  unint64_t v99 = (__CFADD__(__CFADD__(-(uint64_t)v89, (void)v89), v90) | __CFADD__( (__PAIR128__(0xFFFFFFFFLL, -1LL)
                                                                                   * (v73 + v83)) >> 64,
                                                                                    __CFADD__( -(uint64_t)v89,  (void)v89)
                                                                                  + v90))
      + v91;
  BOOL v30 = __CFADD__(((v73 + v83) * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * (v73 + v83));
  uint64_t v100 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * (v73 + v83)) >> 64;
  uint64_t v101 = ((v73 + v83) * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v102 = ((v73 + v83) * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v104 = v30;
  BOOL v30 = __CFADD__(v30, v99);
  unint64_t v103 = v104 + v99;
  v30 |= __CFADD__(v102, v103);
  v103 += v102;
  unint64_t v106 = v30 + v97;
  unint64_t v105 = *((void *)&v89 + 1) + v106;
  if (__CFADD__(v30, v97) | __CFADD__(*((void *)&v89 + 1), v106)) {
    uint64_t v107 = 1LL;
  }
  else {
    uint64_t v107 = 0LL;
  }
  BOOL v30 = __CFADD__(v105, v93);
  uint64_t v108 = v105 + v93;
  uint64_t v109 = v107 + v30 + v101;
  if (__CFADD__(v30, v101) | __CFADD__(v107, v30 + v101)) {
    uint64_t v110 = 1LL;
  }
  else {
    uint64_t v110 = 0LL;
  }
  BOOL v111 = __CFADD__(v109, v95);
  uint64_t v112 = v109 + v95;
  if (v111) {
    uint64_t v113 = v110 + 1;
  }
  else {
    uint64_t v113 = v110;
  }
  uint64_t v114 = v98 + v100;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v96);
  if (v111) {
    ++v113;
  }
  uint64_t v115 = (v5 * (unsigned __int128)v75) >> 64;
  unint64_t v116 = v5 * v75;
  uint64_t v117 = (v6 * (unsigned __int128)v75) >> 64;
  unint64_t v118 = v6 * v75;
  uint64_t v119 = (v10 * (unsigned __int128)v75) >> 64;
  unint64_t v120 = v10 * v75;
  unint64_t v121 = v11 * v75;
  uint64_t v122 = (v11 * (unsigned __int128)v75) >> 64;
  uint64_t v123 = v122 + v120;
  BOOL v30 = __CFADD__(__CFADD__(v122, v120), v119) | __CFADD__(v118, __CFADD__(v122, v120) + v119);
  unint64_t v124 = v118 + __CFADD__(v122, v120) + v119;
  uint64_t v126 = v30 + v117;
  BOOL v30 = __CFADD__(v30, v117) | __CFADD__(v116, v126);
  uint64_t v125 = v116 + v126;
  if (v30) {
    ++v115;
  }
  BOOL v30 = __CFADD__(v114, v121);
  unint64_t v127 = v114 + v121;
  unint64_t v128 = v120 + v30 + v122;
  unint64_t v129 = v128 + v103;
  uint64_t v131 = __CFADD__(v30, v123) | __CFADD__(v103, v30 + v123);
  BOOL v30 = __CFADD__(v131, v124);
  uint64_t v130 = v131 + v124;
  v30 |= __CFADD__(v108, v130);
  v130 += v108;
  BOOL v133 = v30;
  BOOL v30 = __CFADD__(v30, v125);
  uint64_t v132 = v133 + v125;
  v30 |= __CFADD__(v112, v132);
  v132 += v112;
  uint64_t v134 = (v127 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  unint64_t v135 = v115 + v30 + v113;
  unint64_t v136 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v137 = 0xFFFFFFFF00000001LL * v127;
  uint64_t v138 = 0xFFFFFFFF * v127;
  uint64_t v139 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * v127) >> 64;
  unint64_t v140 = v103 + __CFADD__(-(uint64_t)v127, v127) + v128;
  BOOL v30 = __CFADD__( __CFADD__(__CFADD__(-(uint64_t)v127, v127), v129) | __CFADD__( v139,  __CFADD__(-(uint64_t)v127, v127) + v129),  v130);
  uint64_t v141 = (__CFADD__(__CFADD__(-(uint64_t)v127, v127), v129) | __CFADD__( v139,  __CFADD__(-(uint64_t)v127, v127) + v129))
       + v130;
  uint64_t v142 = v30;
  BOOL v30 = __CFADD__(v134, v138);
  uint64_t v143 = v134 + v138;
  uint64_t v144 = (v127 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v145 = (v127 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v147 = v30;
  BOOL v30 = __CFADD__(v30, v141);
  unint64_t v146 = v147 + v141;
  v30 |= __CFADD__(v145, v146);
  v146 += v145;
  unint64_t v149 = v30 + v137;
  BOOL v30 = __CFADD__(v30, v137) | __CFADD__(v142, v149);
  unint64_t v148 = v142 + v149;
  uint64_t v150 = v30;
  BOOL v30 = __CFADD__(v148, v132);
  unint64_t v151 = v148 + v132;
  uint64_t v152 = v150 + v30 + v144;
  if (__CFADD__(v30, v144) | __CFADD__(v150, v30 + v144)) {
    uint64_t v153 = 1LL;
  }
  else {
    uint64_t v153 = 0LL;
  }
  BOOL v154 = __CFADD__(v152, v135);
  unint64_t v155 = v152 + v135;
  if (v154) {
    ++v153;
  }
  uint64_t v156 = v140 + v143;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v136);
  if (v154) {
    unint64_t v157 = v153 + 1;
  }
  else {
    unint64_t v157 = v153;
  }
  unint64_t v159 = v146 - (1 - __CFADD__(v156, 1LL));
  unint64_t v158 = (v146 - __PAIR128__(v138, (1 - __CFADD__(v156, 1LL)))) >> 64;
  unsigned __int128 v160 = v155
       - __PAIR128__( v135,  -(uint64_t)((v151 - __PAIR128__( v158,  (1 - (__CFADD__(v159, 0xFFFFFFFF00000001LL) + v158)))) >> 64));
  if (1
     - (__CFADD__((void)v160, 0xFFFFFFFFLL)
      + BYTE8(v160))
     + (v157 < (1 - (__CFADD__((void)v160, 0xFFFFFFFFLL) + BYTE8(v160)))))
  {
    uint64_t v161 = 0LL;
  }

  else
  {
    uint64_t v161 = -1LL;
  }

  if (1
     - (__CFADD__((void)v160, 0xFFFFFFFFLL)
      + BYTE8(v160))
     + (v157 < (1 - (__CFADD__((void)v160, 0xFFFFFFFFLL) + BYTE8(v160)))))
  {
    uint64_t v162 = -1LL;
  }

  else
  {
    uint64_t v162 = 0LL;
  }

  *double result = v161 & (v156 + 1) | v162 & v156;
  result[1] = v161 & (v159 - 0xFFFFFFFF) | v162 & v146;
  result[2] = v161 & (v151 - (1 - (__CFADD__(v159, 0xFFFFFFFF00000001LL) + v158))) | v162 & v151;
  result[3] = v161 & (v160 + 0xFFFFFFFF) | v162 & v155;
  return result;
}

uint64_t *fiat_p256_square(uint64_t *result, unint64_t *a2)
{
  unint64_t v3 = a2[2];
  unint64_t v2 = a2[3];
  unint64_t v5 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v6 = (*a2 * (unsigned __int128)v2) >> 64;
  unint64_t v7 = *a2 * v2;
  unint64_t v8 = (*a2 * (unsigned __int128)v3) >> 64;
  unint64_t v9 = *a2 * v3;
  unint64_t v10 = (v5 * (unsigned __int128)v4) >> 64;
  unint64_t v11 = v5 * v4;
  uint64_t v12 = v5 * v5;
  uint64_t v13 = (v5 * (unsigned __int128)v5) >> 64;
  uint64_t v14 = (__PAIR128__(v4, v5) * v5) >> 64;
  unint64_t v15 = v10 + __CFADD__(v13, v5 * v4) + v9;
  unint64_t v16 = v8
  if (__CFADD__( __CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9),  v7) | __CFADD__( v8,  (__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9))
               + v7))
    unint64_t v17 = v6 + 1;
  else {
    unint64_t v17 = v6;
  }
  uint64_t v18 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v19 = 0xFFFFFFFFLL * v12;
  uint64_t v20 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v21 = -(uint64_t)(v5 * v5);
  unint64_t v22 = v11 + __CFADD__(v21, v12) + v13;
  unint64_t v23 = (__CFADD__(__CFADD__(v21, v12), v14) | __CFADD__( (__PAIR128__(0xFFFFFFFFLL, -1LL)
                                                                 * (unint64_t)v12) >> 64,
                                                                  __CFADD__(v21, v12) + v14))
      + v15;
  uint64_t v24 = __CFADD__( __CFADD__(__CFADD__(v21, v12), v14) | __CFADD__( (__PAIR128__(0xFFFFFFFFLL, -1LL)
                                                                  * (unint64_t)v12) >> 64,
                                                                   __CFADD__(v21, v12) + v14),
          v15);
  BOOL v72 = __CFADD__(v16, 0xFFFFFFFF00000001LL * v12);
  unint64_t v25 = v16 - 0xFFFFFFFFLL * v12;
  uint64_t v26 = v72;
  BOOL v72 = __CFADD__(v18, v17);
  uint64_t v27 = v18 + v17;
  uint64_t v28 = v72;
  uint64_t v29 = (v2 * (unsigned __int128)v4) >> 64;
  unint64_t v30 = v2 * v4;
  uint64_t v31 = (v3 * (unsigned __int128)v4) >> 64;
  unint64_t v32 = v3 * v4;
  unint64_t v33 = v4 * v4;
  unsigned __int128 v34 = __PAIR128__(v3 * v4, v10) + v4 * (unsigned __int128)v4;
  uint64_t v36 = __CFADD__(__CFADD__(v10, v4 * v4), v3 * v4) | __CFADD__( (v4 * (unsigned __int128)v4) >> 64,  __CFADD__(v10, v4 * v4) + v3 * v4);
  uint64_t v35 = v31 + v36 + v2 * v4;
  if (__CFADD__(v36, v2 * v4) | __CFADD__(v31, v36 + v2 * v4)) {
    uint64_t v37 = v29 + 1;
  }
  else {
    uint64_t v37 = (v2 * (unsigned __int128)v4) >> 64;
  }
  BOOL v72 = __CFADD__(v20, v19);
  unint64_t v38 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v39 = 0xFFFFFFFFLL * v12;
  uint64_t v40 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  unint64_t v41 = v22 + v20 + v19;
  BOOL v72 = __CFADD__(v72, v23) | __CFADD__(v40, (__PAIR128__(v23, v38) + (unint64_t)v39) >> 64);
  uint64_t v42 = v40 + ((__PAIR128__(v23, v38) + (unint64_t)v39) >> 64);
  BOOL v44 = v72;
  BOOL v72 = __CFADD__(v72, v25);
  unint64_t v43 = v44 + v25;
  v72 |= __CFADD__(v24, v43);
  v43 += v24;
  BOOL v46 = v72;
  BOOL v72 = __CFADD__(v72, v27);
  uint64_t v45 = v46 + v27;
  v72 |= __CFADD__(v26, v45);
  v45 += v26;
  BOOL v48 = v72;
  BOOL v72 = __CFADD__(v72, v37);
  uint64_t v47 = v48 + v37;
  v72 |= __CFADD__(v28, v47);
  v47 += v28;
  uint64_t v49 = v72;
  unsigned __int128 v50 = __PAIR128__(v10, v41) + __PAIR128__(v33, v11);
  uint64_t v51 = ((__PAIR128__(v10, v41) + __PAIR128__(v33, v11)) >> 64) + v42;
  uint64_t v53 = (__CFADD__(__CFADD__(v41, v11), (void)v34) | __CFADD__( v42,  __CFADD__(v41, v11) + (void)v34))
      + *((void *)&v34 + 1);
  BOOL v72 = __CFADD__( __CFADD__(__CFADD__(v41, v11), (void)v34) | __CFADD__( v42,  __CFADD__(v41, v11) + (void)v34),  *((void *)&v34 + 1)) | __CFADD__(v43, v53);
  uint64_t v52 = v43 + v53;
  BOOL v55 = v72;
  BOOL v72 = __CFADD__(v72, v35);
  uint64_t v54 = v55 + v35;
  v72 |= __CFADD__(v45, v54);
  v54 += v45;
  uint64_t v56 = v72 + v47;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v58 = 0xFFFFFFFF00000001LL * (v41 + v11);
  uint64_t v59 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * (v41 + v11)) >> 64;
  uint64_t v60 = v42 + __CFADD__(-(uint64_t)v50, (void)v50) + *((void *)&v50 + 1);
  unint64_t v61 = (__CFADD__(__CFADD__(-(uint64_t)v50, (void)v50), v51) | __CFADD__( v59,  __CFADD__( -(uint64_t)v50,  (void)v50)
                                                                                  + v51))
      + v52;
  BOOL v62 = __CFADD__( __CFADD__(__CFADD__(-(uint64_t)v50, (void)v50), v51) | __CFADD__( v59,  __CFADD__( -(uint64_t)v50,  (void)v50)
                                                                                   + v51),
          v52);
  unint64_t v63 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v64 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v65 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v72 = __CFADD__(__CFADD__(v63, 0xFFFFFFFF * v50), v61) | __CFADD__( v65,  (__PAIR128__(v61, v63)
                                                            + (unint64_t)(0xFFFFFFFF * v50)) >> 64);
  uint64_t v66 = v65 + ((__PAIR128__(v61, v63) + (unint64_t)(0xFFFFFFFF * v50)) >> 64);
  unint64_t v67 = v62 + v72 + v58;
  if (__CFADD__(v72, v58) | __CFADD__(v62, v72 + v58)) {
    uint64_t v68 = 1LL;
  }
  else {
    uint64_t v68 = 0LL;
  }
  BOOL v72 = __CFADD__(v67, v54);
  uint64_t v69 = v67 + v54;
  uint64_t v70 = v68 + v72 + v64;
  if (__CFADD__(v72, v64) | __CFADD__(v68, v72 + v64)) {
    uint64_t v71 = 1LL;
  }
  else {
    uint64_t v71 = 0LL;
  }
  BOOL v72 = __CFADD__(v70, v56);
  uint64_t v73 = v70 + v56;
  if (v72) {
    uint64_t v74 = v71 + 1;
  }
  else {
    uint64_t v74 = v71;
  }
  unint64_t v75 = v60 + v63 + 0xFFFFFFFF * v50;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  uint64_t v76 = v49 + v72 + v74;
  uint64_t v77 = (v2 * (unsigned __int128)v3) >> 64;
  unint64_t v78 = v2 * v3;
  uint64_t v79 = (v3 * (unsigned __int128)v3) >> 64;
  unint64_t v80 = v3 * v3;
  unint64_t v81 = v8 + v32;
  BOOL v72 = __CFADD__(__CFADD__(v8, v32), v80);
  unint64_t v82 = __CFADD__(v8, v32) + v80;
  v72 |= __CFADD__(v31, v82);
  v82 += v31;
  uint64_t v83 = v79 + v72 + v78;
  if (__CFADD__(v72, v78) | __CFADD__(v79, v72 + v78)) {
    uint64_t v84 = v77 + 1;
  }
  else {
    uint64_t v84 = v77;
  }
  unsigned __int128 v85 = __PAIR128__(v8, v75) + __PAIR128__(v32, v9);
  uint64_t v86 = ((__PAIR128__(v8, v75) + __PAIR128__(v32, v9)) >> 64) + v66;
  unint64_t v88 = (__CFADD__(__CFADD__(v75, v9), v81) | __CFADD__(v66, __CFADD__(v75, v9) + v81)) + v82;
  BOOL v72 = __CFADD__(__CFADD__(__CFADD__(v75, v9), v81) | __CFADD__(v66, __CFADD__(v75, v9) + v81), v82) | __CFADD__(v69, v88);
  uint64_t v87 = v69 + v88;
  uint64_t v90 = v72 + v83;
  BOOL v72 = __CFADD__(v72, v83) | __CFADD__(v73, v90);
  uint64_t v89 = v73 + v90;
  uint64_t v91 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v92 = v84 + v72 + v76;
  unint64_t v93 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v94 = 0xFFFFFFFF * v85;
  uint64_t v95 = (__PAIR128__(0xFFFFFFFFLL, -1LL) * (unint64_t)v85) >> 64;
  BOOL v72 = __CFADD__( __CFADD__(__CFADD__(-(uint64_t)v85, (void)v85), v86) | __CFADD__( v95,  __CFADD__( -(uint64_t)v85,  (void)v85)
                                                                                   + v86),
          v87);
  uint64_t v96 = (__CFADD__(__CFADD__(-(uint64_t)v85, (void)v85), v86) | __CFADD__( v95,  __CFADD__( -(uint64_t)v85,  (void)v85)
                                                                                  + v86))
      + v87;
  uint64_t v97 = v72;
  BOOL v72 = __CFADD__(v91, v94);
  uint64_t v98 = v91 + v94;
  uint64_t v99 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v100 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v102 = v72;
  BOOL v72 = __CFADD__(v72, v96);
  uint64_t v101 = v102 + v96;
  v72 |= __CFADD__(v100, v101);
  v101 += v100;
  uint64_t v103 = v97 + v72 - 0xFFFFFFFF * v85;
  if (__CFADD__(v72, 0xFFFFFFFF00000001LL * v85) | __CFADD__(v97, v72 - 0xFFFFFFFF * v85)) {
    uint64_t v104 = 1LL;
  }
  else {
    uint64_t v104 = 0LL;
  }
  BOOL v72 = __CFADD__(v103, v89);
  uint64_t v105 = v103 + v89;
  uint64_t v106 = v104 + v72 + v99;
  if (__CFADD__(v72, v99) | __CFADD__(v104, v72 + v99)) {
    uint64_t v107 = 1LL;
  }
  else {
    uint64_t v107 = 0LL;
  }
  BOOL v108 = __CFADD__(v106, v92);
  uint64_t v109 = v106 + v92;
  if (v108) {
    ++v107;
  }
  unint64_t v110 = v66 + __CFADD__(-(uint64_t)v85, (void)v85) + *((void *)&v85 + 1) + v98;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v93);
  if (v108) {
    uint64_t v111 = v107 + 1;
  }
  else {
    uint64_t v111 = v107;
  }
  uint64_t v112 = (v2 * (unsigned __int128)v2) >> 64;
  unint64_t v113 = v2 * v2;
  unint64_t v114 = v6 + v30;
  BOOL v72 = __CFADD__(__CFADD__(v6, v30), v78) | __CFADD__(v29, __CFADD__(v6, v30) + v78);
  uint64_t v115 = v29 + __CFADD__(v6, v30) + v78;
  BOOL v117 = v72;
  BOOL v72 = __CFADD__(v72, v113);
  unint64_t v116 = v117 + v113;
  v72 |= __CFADD__(v77, v116);
  v116 += v77;
  if (v72) {
    ++v112;
  }
  unsigned __int128 v118 = __PAIR128__(v6, v110) + __PAIR128__(v30, v7);
  uint64_t v119 = ((__PAIR128__(v6, v110) + __PAIR128__(v30, v7)) >> 64) + v101;
  uint64_t v121 = (__CFADD__(__CFADD__(v110, v7), v114) | __CFADD__(v101, __CFADD__(v110, v7) + v114)) + v115;
  BOOL v72 = __CFADD__( __CFADD__(__CFADD__(v110, v7), v114) | __CFADD__(v101, __CFADD__(v110, v7) + v114),  v115) | __CFADD__(v105, v121);
  uint64_t v120 = v105 + v121;
  BOOL v123 = v72;
  BOOL v72 = __CFADD__(v72, v116);
  unint64_t v122 = v123 + v116;
  v72 |= __CFADD__(v109, v122);
  v122 += v109;
  unint64_t v124 = v112 + v72 + v111;
  unint64_t v125 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v126 = v101 + __CFADD__(-(uint64_t)v118, (void)v118) + *((void *)&v118 + 1);
  uint64_t v127 = (__CFADD__(__CFADD__(-(uint64_t)v118, (void)v118), v119) | __CFADD__( (__PAIR128__(0xFFFFFFFFLL, -1LL)
                                                                                       * (unint64_t)v118) >> 64,
                                                                                        __CFADD__( -(uint64_t)v118,  (void)v118)
                                                                                      + v119))
       + v120;
  unint64_t v128 = ((unint64_t)v118 * (unsigned __int128)0xFFFFFFFF00000001LL) >> 64;
  uint64_t v129 = ((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v72 = __CFADD__( __CFADD__(((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v118),  v127);
  unint64_t v130 = __CFADD__(((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v118) + v127;
  v72 |= __CFADD__(v129, v130);
  v130 += v129;
  uint64_t v132 = v72 - 0xFFFFFFFF * v118;
  unint64_t v131 = *((void *)&v118 + 1) + v132;
  if (__CFADD__(v72, 0xFFFFFFFF00000001LL * v118) | __CFADD__(*((void *)&v118 + 1), v132)) {
    uint64_t v133 = 1LL;
  }
  else {
    uint64_t v133 = 0LL;
  }
  unint64_t v135 = v131 + v122;
  BOOL v72 = __CFADD__(__CFADD__(v131, v122), v128) | __CFADD__(v133, (__PAIR128__(v128, v131) + v122) >> 64);
  uint64_t v134 = v133 + ((__PAIR128__(v128, v131) + v122) >> 64);
  unint64_t v136 = v72;
  BOOL v137 = __CFADD__(v134, v124);
  unint64_t v138 = v134 + v124;
  if (v137) {
    ++v136;
  }
  uint64_t v139 = v126 + ((__PAIR128__(0xFFFFFFFFLL, -1LL) * (unint64_t)v118) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v125);
  if (v137) {
    ++v136;
  }
  unsigned __int128 v140 = v130 - __PAIR128__(0xFFFFFFFFLL * (uint64_t)v118, (1 - __CFADD__(v139, 1LL)));
  unint64_t v141 = v138
       - -(uint64_t)((v135
                                    - __PAIR128__( v124,  (1 - (__CFADD__((void)v140, 0xFFFFFFFF00000001LL)
                                                         + BYTE8(v140))))) >> 64);
  uint64_t v142 = -(uint64_t)(v136
                  + (v136 < (1
                                            - (__CFADD__(v141, 0xFFFFFFFFLL)
                                             + ((v138
                                               - __PAIR128__( v125,  -(uint64_t)((v135 - __PAIR128__( v124,  (1 - (__CFADD__((void)v140, 0xFFFFFFFF00000001LL)
                                                                                                   + BYTE8(v140))))) >> 64))) >> 64)))));
  BOOL v143 = v142 == 0;
  if ((_BYTE)v142) {
    uint64_t v144 = 0LL;
  }
  else {
    uint64_t v144 = -1LL;
  }
  if (v143) {
    uint64_t v145 = 0LL;
  }
  else {
    uint64_t v145 = -1LL;
  }
  *double result = v144 & (v139 + 1) | v145 & v139;
  result[1] = v144 & (v140 - 0xFFFFFFFF) | v145 & v130;
  result[2] = v144 & (v135 - (1 - (__CFADD__((void)v140, 0xFFFFFFFF00000001LL) + BYTE8(v140)))) | v145 & v135;
  result[3] = v144 & (v141 + 0xFFFFFFFF) | v145 & v138;
  return result;
}

double fiat_p256_point_add( uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, unint64_t *a6, int a7, unint64_t *a8, unint64_t *a9, unint64_t *a10)
{
  uint64_t v235 = *MEMORY[0x1895F89C0];
  v12.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v12.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  int8x16_t v233 = v12;
  int8x16_t v234 = v12;
  int8x16_t v231 = v12;
  unsigned __int128 v232 = (unsigned __int128)v12;
  int8x16_t v229 = v12;
  int8x16_t v230 = v12;
  unint64_t v13 = *a6;
  unint64_t v14 = a6[1];
  unint64_t v15 = a6[2];
  uint64_t v16 = a6[3];
  unint64_t v200 = v14 | *a6 | v15 | v16;
  unint64_t v17 = *a10;
  unint64_t v18 = a10[1];
  unint64_t v20 = a10[2];
  unint64_t v19 = a10[3];
  uint64_t v201 = v18 | *a10 | v20 | v19;
  int8x16_t v227 = v12;
  int8x16_t v228 = v12;
  fiat_p256_square(v227.i64, a6);
  *(void *)&unsigned __int128 v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int128 v225 = v23;
  unsigned __int128 v226 = v23;
  unsigned __int128 v223 = v23;
  unsigned __int128 v224 = v23;
  unsigned __int128 v221 = v23;
  unsigned __int128 v222 = v23;
  if (a7)
  {
    unsigned __int128 v24 = *(_OWORD *)(a4 + 16);
    *((void *)&v26 + 1) = v14;
    *(void *)&__int128 v26 = v13;
    uint64_t v25 = v26 >> 63;
    unsigned __int128 v225 = *(_OWORD *)a4;
    unsigned __int128 v226 = v24;
    *((void *)&v26 + 1) = v15;
    *(void *)&__int128 v26 = v14;
    unint64_t v27 = v26 >> 63;
    *((void *)&v26 + 1) = v16;
    *(void *)&__int128 v26 = v15;
    unint64_t v28 = v26 >> 63;
    unsigned __int128 v29 = v28
        - __PAIR128__( v22,  -(uint64_t)((v27 - __PAIR128__(v21, (1 - __CFADD__(v25, 0xFFFFFFFF00000000LL)))) >> 64));
    if ((v16 < 0)
       + ((unint64_t)v16 >> 63 < (1 - (__CFADD__((void)v29, 0xFFFFFFFFLL) + BYTE8(v29)))))
    {
      uint64_t v30 = 0LL;
    }

    else
    {
      uint64_t v30 = -1LL;
    }

    if ((v16 < 0)
       + ((unint64_t)v16 >> 63 < (1 - (__CFADD__((void)v29, 0xFFFFFFFFLL) + BYTE8(v29)))))
    {
      uint64_t v31 = -1LL;
    }

    else
    {
      uint64_t v31 = 0LL;
    }

    *(void *)&unsigned __int128 v221 = v30 & ((2 * v13) | 1) | v31 & (2 * v13);
    *((void *)&v221 + 1) = v30 & (v25 - 0x100000000LL) | v31 & v25;
    *(void *)&unsigned __int128 v222 = v30 & (v27 - (1 - __CFADD__(v25, 0xFFFFFFFF00000000LL))) | v31 & v27;
    *((void *)&v222 + 1) = v30 & (v29 + 0xFFFFFFFF) | v31 & v28;
    unint64_t v33 = (int8x16_t *)a10;
    unint64_t v32 = (unint64_t *)a5;
    unsigned __int128 v34 = *(_OWORD *)(a5 + 16);
    unsigned __int128 v223 = *(_OWORD *)a5;
    unsigned __int128 v224 = v34;
  }

  else
  {
    unsigned __int128 v219 = v23;
    unsigned __int128 v220 = v23;
    fiat_p256_square((uint64_t *)&v219, a10);
    uint64_t v35 = fiat_p256_mul((uint64_t *)&v225, (unint64_t *)a4, (unint64_t *)&v219);
    unint64_t v37 = v17 + v13;
    unint64_t v38 = v14 + __CFADD__(v17, v13) + v18;
    unint64_t v39 = v15 + (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18)) + v20;
    uint64_t v40 = v16
        + (__CFADD__( __CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18),  v20) | __CFADD__( v15,  (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__( v14,  __CFADD__(v17, v13)
                                                                                               + v18))
                                     + v20))
        + v19;
    if (__CFADD__( __CFADD__( __CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18),  v20) | __CFADD__( v15,  (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__( v14,  __CFADD__(v17, v13)
                                                                                               + v18))
                                     + v20),
           v19) | __CFADD__( v16,  (__CFADD__( __CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18),  v20) | __CFADD__( v15,  (__CFADD__(__CFADD__(v17, v13), v18) | __CFADD__(v14, __CFADD__(v17, v13) + v18))
                                               + v20))
                  + v19))
      unint64_t v41 = 1LL;
    else {
      unint64_t v41 = 0LL;
    }
    unsigned __int128 v42 = v38 - __PAIR128__(v36, (1 - __CFADD__(v37, 1LL)));
    unsigned __int128 v43 = (unint64_t)v40
        - __PAIR128__( (unint64_t)v35,  -(uint64_t)((v39 - __PAIR128__( 0xFFFFFFFF00000001LL,  (1 - (__CFADD__((void)v42, 0xFFFFFFFF00000001LL)
                                                            + BYTE8(v42))))) >> 64));
    uint64_t v44 = -(uint64_t)(v41 + (v41 < (1 - (__CFADD__((void)v43, 0xFFFFFFFFLL) + BYTE8(v43)))));
    BOOL v45 = v44 == 0;
    if ((_BYTE)v44) {
      uint64_t v46 = 0LL;
    }
    else {
      uint64_t v46 = -1LL;
    }
    if (v45) {
      uint64_t v47 = 0LL;
    }
    else {
      uint64_t v47 = -1LL;
    }
    *(void *)&unsigned __int128 v221 = v46 & (v37 + 1) | v47 & v37;
    *((void *)&v221 + 1) = v46 & (v42 - 0xFFFFFFFF) | v47 & v38;
    *(void *)&unsigned __int128 v222 = v46 & (v39 - (1 - (__CFADD__((void)v42, 0xFFFFFFFF00000001LL) + BYTE8(v42)))) | v47 & v39;
    *((void *)&v222 + 1) = v46 & (v43 + 0xFFFFFFFF) | v47 & v40;
    fiat_p256_square((uint64_t *)&v221, (unint64_t *)&v221);
    uint64_t v48 = v221 - v227.i64[0];
    uint64_t v49 = v227.i64[1]
        + -(uint64_t)(((unint64_t)v221 - __PAIR128__(v227.u64[0], v227.u64[0])) >> 64);
    uint64_t v50 = *((void *)&v221 + 1) - v49;
    BOOL v57 = __CFADD__( v228.i64[0],  -(uint64_t)((*((unint64_t *)&v221 + 1) - __PAIR128__(v49, v49)) >> 64));
    uint64_t v51 = v228.i64[0] + -(uint64_t)((*((unint64_t *)&v221 + 1) - __PAIR128__(v49, v49)) >> 64);
    uint64_t v52 = v57;
    uint64_t v53 = v222 - v51;
    BOOL v57 = __CFADD__(v228.i64[1], -(uint64_t)(((unint64_t)v222 - __PAIR128__(v52, v51)) >> 64));
    uint64_t v54 = v228.i64[1] + -(uint64_t)(((unint64_t)v222 - __PAIR128__(v52, v51)) >> 64);
    uint64_t v55 = v57;
    unsigned __int128 v56 = *((unint64_t *)&v222 + 1) - __PAIR128__(v55, v54);
    BOOL v57 = __CFADD__(__CFADD__(v48, *((void *)&v56 + 1)), v50) | __CFADD__( DWORD2(v56),  __CFADD__(v48, *((void *)&v56 + 1)) + v50);
    uint64_t v58 = DWORD2(v56) + __CFADD__(v48, *((void *)&v56 + 1)) + v50;
    unint64_t v59 = v56 + __CFADD__(v57, v53) + (*((void *)&v56 + 1) & 0xFFFFFFFF00000001LL);
    char v61 = ((unint64_t)(v48 + *((void *)&v56 + 1)) - __PAIR128__(v219, v219)) >> 64;
    uint64_t v60 = v48 + *((void *)&v56 + 1) - v219;
    unsigned __int128 v62 = (unint64_t)v58
        - __PAIR128__( *((void *)&v219 + 1) + (unint64_t)-v61,  *((void *)&v219 + 1) + (unint64_t)-v61);
    char v63 = ((unint64_t)v57
         + v53
         - __PAIR128__( (unint64_t)v220 + -BYTE8(v62),  (unint64_t)v220 + -BYTE8(v62))) >> 64;
    if (((v59
                          - __PAIR128__( *((void *)&v220 + 1) + (unint64_t)-v63,  *((void *)&v220 + 1) + (unint64_t)-v63)) >> 64))
      uint64_t v64 = -1LL;
    else {
      uint64_t v64 = 0LL;
    }
    uint64_t v65 = __CFADD__(v60, v64) + (void)v62;
    *(void *)&unsigned __int128 v221 = v60 + v64;
    *((void *)&v221 + 1) = v64 + v65;
    unsigned __int128 v222 = __PAIR128__( v64 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v60, v64), (void)v62) | __CFADD__(v64, v65))
         + __PAIR128__( v59 - (*((void *)&v220 + 1)
            + -(uint64_t)(((unint64_t)v57
                                         + v53
                                         - __PAIR128__( (unint64_t)v220 + -BYTE8(v62),  (unint64_t)v220 + -BYTE8(v62))) >> 64)),  v57 + v53 - ((unint64_t)v220 + -BYTE8(v62)));
    fiat_p256_mul((uint64_t *)&v223, a10, (unint64_t *)&v219);
    unint64_t v32 = (unint64_t *)a5;
    fiat_p256_mul((uint64_t *)&v223, (unint64_t *)&v223, (unint64_t *)a5);
    unint64_t v33 = (int8x16_t *)a10;
  }

  uint64_t v66 = a4;
  *(void *)&unsigned __int128 v67 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v67 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int128 v219 = v67;
  unsigned __int128 v220 = v67;
  fiat_p256_mul((uint64_t *)&v219, a8, (unint64_t *)&v227);
  uint64_t v68 = v219 - v225;
  unint64_t v69 = *((void *)&v225 + 1) + -(uint64_t)(((unint64_t)v219 - __PAIR128__(v225, v225)) >> 64);
  unint64_t v70 = *((void *)&v219 + 1) - v69;
  BOOL v57 = __CFADD__( (void)v226,  -(uint64_t)((*((unint64_t *)&v219 + 1) - __PAIR128__(v69, v69)) >> 64));
  unint64_t v71 = v226 + -(uint64_t)((*((unint64_t *)&v219 + 1) - __PAIR128__(v69, v69)) >> 64);
  uint64_t v72 = v57;
  unint64_t v74 = v220 - v71;
  char v73 = ((unint64_t)v220 - __PAIR128__(v72, v71)) >> 64;
  BOOL v57 = __CFADD__(*((void *)&v226 + 1), -v73);
  unint64_t v75 = *((void *)&v226 + 1) + -v73;
  uint64_t v76 = v57;
  unint64_t v77 = *((void *)&v220 + 1) - v75;
  else {
    uint64_t v78 = 0LL;
  }
  uint64_t v79 = v68 + v78;
  unint64_t v80 = v78 + __CFADD__(v68, v78) + v70;
  v217[0] = v68 + v78;
  v217[1] = v80;
  signed __int128 v81 = __PAIR128__( v78 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v68, v78), v70) | __CFADD__(v78, __CFADD__(v68, v78) + v70))
      + __PAIR128__(v77, v74);
  unsigned __int128 v218 = __PAIR128__( v78 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v68, v78), v70) | __CFADD__( v78,  __CFADD__(v68, v78) + v70))
       + __PAIR128__(v77, v74);
  fiat_p256_mul(v229.i64, v217, (unint64_t *)&v221);
  *(void *)&__int128 v82 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v82 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v216[0] = v82;
  v216[1] = v82;
  fiat_p256_mul((uint64_t *)v216, a6, (unint64_t *)&v227);
  *(void *)&__int128 v83 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v83 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v214 = v83;
  __int128 v215 = v83;
  uint64_t v84 = fiat_p256_mul((uint64_t *)&v214, a9, (unint64_t *)v216);
  uint64_t v86 = v214 - v223;
  unint64_t v87 = *((void *)&v223 + 1) + -(uint64_t)(((unint64_t)v214 - __PAIR128__(v223, v223)) >> 64);
  unint64_t v88 = *((void *)&v214 + 1) - v87;
  BOOL v57 = __CFADD__( (void)v224,  -(uint64_t)((*((unint64_t *)&v214 + 1) - __PAIR128__(v87, v87)) >> 64));
  unint64_t v89 = v224 + -(uint64_t)((*((unint64_t *)&v214 + 1) - __PAIR128__(v87, v87)) >> 64);
  uint64_t v90 = v57;
  unint64_t v91 = v215 - v89;
  BOOL v57 = __CFADD__( *((void *)&v224 + 1),  -(uint64_t)(((unint64_t)v215 - __PAIR128__(v90, v89)) >> 64));
  unint64_t v92 = *((void *)&v224 + 1) + -(uint64_t)(((unint64_t)v215 - __PAIR128__(v90, v89)) >> 64);
  uint64_t v93 = v57;
  unint64_t v94 = *((void *)&v215 + 1) - v92;
  else {
    uint64_t v95 = 0LL;
  }
  BOOL v57 = __CFADD__(v86, v95);
  uint64_t v96 = v86 + v95;
  unint64_t v98 = __CFADD__(v86, v95) + v88;
  unint64_t v97 = v95 + v98;
  unint64_t v99 = __CFADD__(v57, v88) | __CFADD__(v95, v98);
  unint64_t v100 = v95 & 0xFFFFFFFF00000001LL;
  *((void *)&v102 + 1) = v97;
  *(void *)&__int128 v102 = v96;
  uint64_t v101 = v102 >> 63;
  *((void *)&v102 + 1) = v99 + v91;
  *(void *)&__int128 v102 = v97;
  unint64_t v103 = v102 >> 63;
  unint64_t v104 = (__int128)(__PAIR128__(v100, v99) + __PAIR128__(v94, v91)) >> 63;
  unint64_t v105 = v101 - 0x100000000LL;
  unint64_t v106 = v103 - (1 - __CFADD__(v101, 0xFFFFFFFF00000000LL));
  unsigned __int128 v107 = v104
       - __PAIR128__( v85,  -(uint64_t)((v103 - __PAIR128__( (unint64_t)v84,  (1 - __CFADD__(v101, 0xFFFFFFFF00000000LL)))) >> 64));
  if (((((__PAIR128__(v100, v99) + __PAIR128__(v94, v91)) >> 64) & 0x8000000000000000LL) != 0LL)
     + ((unint64_t)((__PAIR128__(v100, v99) + __PAIR128__(v94, v91)) >> 64) >> 63 < (1 - (__CFADD__((void)v107, 0xFFFFFFFFLL) + BYTE8(v107)))))
  {
    uint64_t v108 = 0LL;
  }

  else
  {
    uint64_t v108 = -1LL;
  }

  uint64_t v210 = v108 & ((2 * v96) | 1) | *((void *)&v107 + 1) & (2 * v96);
  uint64_t v211 = v108 & v105 | *((void *)&v107 + 1) & v101;
  uint64_t v212 = v108 & v106 | *((void *)&v107 + 1) & v103;
  uint64_t v213 = v108 & (v107 + 0xFFFFFFFF) | *((void *)&v107 + 1) & v104;
  unint64_t v109 = v80 | v79 | v81 | *((void *)&v81 + 1) | v211 | v210 | v212 | v213;
  uint64_t v110 = (uint64_t)((v109 - 1) & ~v109) >> 63;
  if ((((v201 - 1) & ~v201 | (v200 - 1) & ~v200) & 0x8000000000000000LL) != 0LL) {
    uint64_t v110 = 0LL;
  }
  if (v110)
  {
    fiat_p256_point_double(a1, a2, a3, (unint64_t *)a4, v32, a6);
  }

  else
  {
    *((void *)&v113 + 1) = v80;
    *(void *)&__int128 v113 = v79;
    uint64_t v112 = v113 >> 63;
    *((void *)&v113 + 1) = v81;
    *(void *)&__int128 v113 = v80;
    unint64_t v114 = v113 >> 63;
    unint64_t v115 = v81 >> 63;
    unsigned __int128 v116 = v115
         - __PAIR128__( v106,  -(uint64_t)((v114 - __PAIR128__( v105,  (1 - __CFADD__(v112, 0xFFFFFFFF00000000LL)))) >> 64));
    if (1
       - (__CFADD__((void)v116, 0xFFFFFFFFLL)
        + BYTE8(v116))
       + (*((void *)&v81 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((void)v116, 0xFFFFFFFFLL)
                                                                           + BYTE8(v116)))))
    {
      uint64_t v117 = 0LL;
    }

    else
    {
      uint64_t v117 = -1LL;
    }

    if (1
       - (__CFADD__((void)v116, 0xFFFFFFFFLL)
        + BYTE8(v116))
       + (*((void *)&v81 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((void)v116, 0xFFFFFFFFLL)
                                                                           + BYTE8(v116)))))
    {
      uint64_t v118 = -1LL;
    }

    else
    {
      uint64_t v118 = 0LL;
    }

    v209[0] = v117 & ((2 * v79) | 1) | v118 & (2 * v79);
    v209[1] = v117 & (v112 - 0x100000000LL) | v118 & v112;
    v209[2] = v117 & (v114 - (1 - __CFADD__(v112, 0xFFFFFFFF00000000LL))) | v118 & v114;
    v209[3] = v117 & (v116 + 0xFFFFFFFF) | v118 & v115;
    fiat_p256_square(v209, (unint64_t *)v209);
    *(void *)&__int128 v119 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v119 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v207 = v119;
    __int128 v208 = v119;
    fiat_p256_mul((uint64_t *)&v207, v217, (unint64_t *)v209);
    *(void *)&__int128 v120 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v120 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v205 = v120;
    __int128 v206 = v120;
    fiat_p256_mul((uint64_t *)&v205, (unint64_t *)&v225, (unint64_t *)v209);
    fiat_p256_square(v233.i64, (unint64_t *)&v210);
    uint64_t v121 = v233.i64[0] - v207;
    unint64_t v122 = *((void *)&v207 + 1) + -(uint64_t)((v233.u64[0] - __PAIR128__(v207, v207)) >> 64);
    unint64_t v123 = v233.i64[1] - v122;
    BOOL v57 = __CFADD__((void)v208, -(uint64_t)((v233.u64[1] - __PAIR128__(v122, v122)) >> 64));
    unint64_t v124 = v208 + -(uint64_t)((v233.u64[1] - __PAIR128__(v122, v122)) >> 64);
    uint64_t v125 = v57;
    unint64_t v127 = v234.i64[0] - v124;
    char v126 = (v234.u64[0] - __PAIR128__(v125, v124)) >> 64;
    BOOL v57 = __CFADD__(*((void *)&v208 + 1), -v126);
    unint64_t v128 = *((void *)&v208 + 1) + -v126;
    uint64_t v129 = v57;
    else {
      uint64_t v130 = 0LL;
    }
    unint64_t v131 = v130 + __CFADD__(v121, v130) + v123;
    uint64_t v132 = v121 + v130 - v205;
    unsigned __int128 v133 = v131
         - __PAIR128__( v131,  *((void *)&v205 + 1)
           + (unint64_t)-(uint64_t)(((unint64_t)(v121 + v130) - __PAIR128__(v127, v205)) >> 64));
    uint64_t v135 = ((__CFADD__(__CFADD__(v121, v130), v123) | __CFADD__( v130,  __CFADD__(v121, v130) + v123))
          + v127
          - __PAIR128__( (unint64_t)v206 + -BYTE8(v133),  (unint64_t)v206 + -BYTE8(v133))) >> 64;
    uint64_t v134 = (__CFADD__(__CFADD__(v121, v130), v123) | __CFADD__( v130,  __CFADD__(v121, v130) + v123))
         + v127
         - (v206
          + -BYTE8(v133));
    unsigned __int128 v136 = ((__PAIR128__( v130 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v121, v130), v123) | __CFADD__( v130,  __CFADD__(v121, v130) + v123))
           + __PAIR128__(v234.i64[1] - v128, v127)) >> 64)
         - __PAIR128__( *((void *)&v206 + 1) + (unint64_t)-(char)v135,  *((void *)&v206 + 1) + (unint64_t)-(char)v135);
    unint64_t v137 = DWORD2(v136) + __CFADD__(v132, *((void *)&v136 + 1)) + (void)v133;
    unint64_t v138 = v136
         + __CFADD__( __CFADD__(__CFADD__(v132, *((void *)&v136 + 1)), (void)v133) | __CFADD__( DWORD2(v136),  __CFADD__( v132,  *((void *)&v136 + 1))
                                                                                                 + (void)v133),
             v134)
         + (*((void *)&v136 + 1) & 0xFFFFFFFF00000001LL);
    uint64_t v139 = v132 + *((void *)&v136 + 1) - v205;
    unsigned __int128 v140 = v137
         - __PAIR128__( v137,  *((void *)&v205 + 1)
           + (unint64_t)-(uint64_t)(((unint64_t)(v132 + *((void *)&v136 + 1))
                                                          - __PAIR128__( *((void *)&v136 + 1) & 0xFFFFFFFF00000001LL,  v205)) >> 64));
    LOBYTE(v137) = ((unint64_t)(__CFADD__(__CFADD__(v132, *((void *)&v136 + 1)), (void)v133) | __CFADD__(DWORD2(v136), __CFADD__(v132, *((void *)&v136 + 1)) + (void)v133))
                  + v134
                  - __PAIR128__( (unint64_t)v206 + -BYTE8(v140),  (unint64_t)v206 + -BYTE8(v140))) >> 64;
    unint64_t v141 = (__CFADD__(__CFADD__(v132, *((void *)&v136 + 1)), (void)v133) | __CFADD__( DWORD2(v136),  __CFADD__( v132,  *((void *)&v136 + 1))
                                                                                                + (void)v133))
         + v134
         - (v206
          + -BYTE8(v140));
    unint64_t v142 = v138 - (*((void *)&v206 + 1) + -(char)v137);
    if (((v138
                          - __PAIR128__( *((void *)&v206 + 1) + (unint64_t)-(char)v137,  *((void *)&v206 + 1) + (unint64_t)-(char)v137)) >> 64))
      uint64_t v143 = -1LL;
    else {
      uint64_t v143 = 0LL;
    }
    uint64_t v196 = v139 + v143;
    uint64_t v198 = v143 + __CFADD__(v139, v143) + (void)v140;
    unint64_t v192 = (__CFADD__(__CFADD__(v139, v143), (void)v140) | __CFADD__( v143,  __CFADD__(v139, v143) + (void)v140))
         + v141;
    unsigned __int128 v144 = __PAIR128__( v143 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v139, v143), (void)v140) | __CFADD__( v143,  __CFADD__(v139, v143) + (void)v140))
         + __PAIR128__(v142, v141);
    uint64_t v146 = v205 - (v139 + v143);
    char v145 = ((unint64_t)v205 - __PAIR128__(v142, v139 + v143)) >> 64;
    char v148 = ((unint64_t)v206
          - __PAIR128__( (unint64_t)v144 + -BYTE8(v147),  (unint64_t)v144 + -BYTE8(v147))) >> 64;
    if (((*((unint64_t *)&v206 + 1)
                          - __PAIR128__( *((void *)&v144 + 1) + (unint64_t)-v148,  *((void *)&v144 + 1) + (unint64_t)-v148)) >> 64))
      uint64_t v149 = -1LL;
    else {
      uint64_t v149 = 0LL;
    }
    uint64_t v150 = __CFADD__(v146, v149) + (void)v147;
    v231.i64[0] = v146 + v149;
    v231.i64[1] = v149 + v150;
    unsigned __int128 v232 = __PAIR128__( v149 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v146, v149), (void)v147) | __CFADD__(v149, v150))
         + __PAIR128__( *((void *)&v206 + 1)
           - (*((void *)&v144 + 1)
            + (unint64_t)-(uint64_t)(((unint64_t)v206
                                                           - __PAIR128__( (unint64_t)v144 + -BYTE8(v147),  (unint64_t)v144 + -BYTE8(v147))) >> 64)),  v206 - (v144 + -BYTE8(v147)));
    fiat_p256_mul(v231.i64, (unint64_t *)&v231, (unint64_t *)&v210);
    *(void *)&__int128 v151 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v151 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v203 = v151;
    __int128 v204 = v151;
    fiat_p256_mul((uint64_t *)&v203, (unint64_t *)&v223, (unint64_t *)&v207);
    uint64_t v153 = v231.i64[0] - v203;
    uint64_t v154 = v231.i64[1]
         - (*((void *)&v203 + 1)
          + -(uint64_t)((v231.u64[0] - __PAIR128__(v152, v203)) >> 64));
    BOOL v57 = __CFADD__( (void)v204,  -(uint64_t)((v231.u64[1] - __PAIR128__( *((void *)&v203 + 1)
                                         + (unint64_t)-(uint64_t)((v231.u64[0]
                                                                                        - __PAIR128__(v152, v203)) >> 64),
                                           *((void *)&v203 + 1)
                                         + (unint64_t)-(uint64_t)((v231.u64[0]
                                                                                        - __PAIR128__(v152, v203)) >> 64))) >> 64));
    unint64_t v155 = v204
         + -(uint64_t)((v231.u64[1]
                                      - __PAIR128__( *((void *)&v203 + 1)
                                        + (unint64_t)-(uint64_t)((v231.u64[0]
                                                                                       - __PAIR128__(v152, v203)) >> 64),
                                          *((void *)&v203 + 1)
                                        + (unint64_t)-(uint64_t)((v231.u64[0]
                                                                                       - __PAIR128__(v152, v203)) >> 64))) >> 64);
    uint64_t v156 = v57;
    uint64_t v157 = v232 - v155;
    BOOL v57 = __CFADD__( *((void *)&v204 + 1),  -(uint64_t)(((unint64_t)v232 - __PAIR128__(v156, v155)) >> 64));
    unint64_t v158 = *((void *)&v204 + 1)
         + -(uint64_t)(((unint64_t)v232 - __PAIR128__(v156, v155)) >> 64);
    uint64_t v159 = v57;
    unsigned __int128 v160 = *((unint64_t *)&v232 + 1) - __PAIR128__(v159, v158);
    uint64_t v161 = __CFADD__(v153, *((void *)&v160 + 1)) + v154;
    uint64_t v163 = __CFADD__(__CFADD__(v153, *((void *)&v160 + 1)), v154) | __CFADD__(DWORD2(v160), v161);
    unint64_t v162 = v163 + v157;
    unint64_t v164 = v160 + __CFADD__(v163, v157) + (*((void *)&v160 + 1) & 0xFFFFFFFF00000001LL);
    uint64_t v165 = v153 + *((void *)&v160 + 1) - v203;
    uint64_t v166 = DWORD2(v160)
         + v161
         - (*((void *)&v203 + 1)
          + -(uint64_t)(((unint64_t)(v153 + *((void *)&v160 + 1)) - __PAIR128__(v203, v203)) >> 64));
    unint64_t v167 = v204
         + -(uint64_t)(((unint64_t)DWORD2(v160)
                                      + v161
                                      - __PAIR128__( *((void *)&v203 + 1)
                                        + (unint64_t)-(uint64_t)(((unint64_t)(v153 + *((void *)&v160 + 1))
                                                                                       - __PAIR128__(v203, v203)) >> 64),
                                          *((void *)&v203 + 1)
    BOOL v168 = __CFADD__( (void)v204,  -(uint64_t)(((unint64_t)DWORD2(v160)
                                        + v161
                                        - __PAIR128__( *((void *)&v203 + 1)
                                          + (unint64_t)-(uint64_t)(((unint64_t)(v153 + *((void *)&v160 + 1))
                                                                                         - __PAIR128__(v203, v203)) >> 64),
                                            *((void *)&v203 + 1)
    unint64_t v170 = v162 - v167;
    char v169 = (v162 - __PAIR128__(v168, v167)) >> 64;
    BOOL v57 = __CFADD__(*((void *)&v204 + 1), -v169);
    unint64_t v171 = *((void *)&v204 + 1) + -v169;
    uint64_t v172 = v57;
    else {
      uint64_t v173 = 0LL;
    }
    uint64_t v174 = (uint64_t)v32;
    uint64_t v175 = v165 + v173;
    uint64_t v176 = v66;
    uint64_t v177 = v173 + __CFADD__(v165, v173) + v166;
    unsigned __int128 v178 = __PAIR128__( v173 & 0xFFFFFFFF00000001LL,  __CFADD__(__CFADD__(v165, v173), v166) | __CFADD__( v173,  __CFADD__(v165, v173) + v166))
         + __PAIR128__(v164 - v171, v170);
    unsigned __int128 v179 = v33;
    if (v200) {
      unint64_t v180 = 0LL;
    }
    else {
      unint64_t v180 = -1LL;
    }
    if (v200) {
      unint64_t v181 = -1LL;
    }
    else {
      unint64_t v181 = 0LL;
    }
    unint64_t v182 = a8[1] & v180 | v181 & v198;
    unint64_t v183 = a8[2] & v180 | v181 & v192;
    unint64_t v184 = a8[3] & v180;
    v233.i64[0] = v180 & *a8 | v181 & v196;
    v233.i64[1] = v182;
    v234.i64[0] = v183;
    v234.i64[1] = v184 | v181 & *((void *)&v144 + 1);
    fiat_p256_cmovznz((uint64_t)a1, v201, v176, (uint64_t)&v233);
    unint64_t v185 = a9[1] & v180 | v181 & v177;
    uint64_t v186 = a9[2] & v180 | v181 & v178;
    unint64_t v187 = a9[3] & v180;
    v231.i64[0] = *a9 & v180 | v181 & v175;
    v231.i64[1] = v185;
    *(void *)&unsigned __int128 v232 = v186;
    *((void *)&v232 + 1) = v187 | *((void *)&v178 + 1) & v181;
    fiat_p256_cmovznz((uint64_t)a2, v201, v174, (uint64_t)&v231);
    int8x16_t v188 = (int8x16_t)vdupq_n_s64(v181);
    int8x16_t v189 = (int8x16_t)vdupq_n_s64(v180);
    int8x16_t v190 = vorrq_s8(vandq_s8(v229, v188), vandq_s8(*v179, v189));
    int8x16_t v191 = vorrq_s8(vandq_s8(v230, v188), vandq_s8(v179[1], v189));
    int8x16_t v229 = v190;
    int8x16_t v230 = v191;
    *(void *)&double result = fiat_p256_cmovznz((uint64_t)a3, v201, (uint64_t)a6, (uint64_t)&v229).u64[0];
  }

  return result;
}

uint64_t *fiat_p256_point_double( uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v253 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v251 = v10;
  __int128 v252 = v10;
  *(_OWORD *)uint64_t v250 = v10;
  *(_OWORD *)&v250[16] = v10;
  *(_OWORD *)unint64_t v249 = v10;
  *(_OWORD *)&v249[16] = v10;
  v243[0] = v10;
  v243[1] = v10;
  fiat_p256_square((uint64_t *)&v251, a6);
  fiat_p256_square((uint64_t *)v250, a5);
  fiat_p256_mul((uint64_t *)v249, a4, (unint64_t *)v250);
  unint64_t v13 = *a4;
  unint64_t v14 = a4[1];
  __int128 v15 = v251;
  uint64_t v17 = *a4 - v251;
  BOOL v18 = __CFADD__(*((void *)&v251 + 1), -(uint64_t)((*a4 - __PAIR128__(v16, v251)) >> 64));
  uint64_t v19 = *((void *)&v251 + 1) + -(uint64_t)((*a4 - __PAIR128__(v16, v251)) >> 64);
  uint64_t v20 = v18;
  uint64_t v21 = v14 - v19;
  __int128 v22 = v252;
  BOOL v18 = __CFADD__((void)v252, -(uint64_t)((v14 - __PAIR128__(v20, v19)) >> 64));
  uint64_t v23 = v252 + -(uint64_t)((v14 - __PAIR128__(v20, v19)) >> 64);
  uint64_t v24 = v18;
  unint64_t v25 = a4[2];
  unint64_t v26 = a4[3];
  uint64_t v27 = v25 - v23;
  BOOL v18 = __CFADD__(*((void *)&v252 + 1), -(uint64_t)((v25 - __PAIR128__(v24, v23)) >> 64));
  unint64_t v28 = *((void *)&v252 + 1) + -(uint64_t)((v25 - __PAIR128__(v24, v23)) >> 64);
  uint64_t v29 = v18;
  unsigned __int128 v30 = v26 - __PAIR128__(v29, v28);
  uint64_t v31 = __CFADD__(v17, *((void *)&v30 + 1)) + v21;
  uint64_t v32 = __CFADD__(__CFADD__(v17, *((void *)&v30 + 1)), v21) | __CFADD__(DWORD2(v30), v31);
  uint64_t v245 = v17 + *((void *)&v30 + 1);
  uint64_t v246 = DWORD2(v30) + v31;
  uint64_t v247 = v32 + v27;
  uint64_t v248 = v30 + __CFADD__(v32, v27) + (*((void *)&v30 + 1) & 0xFFFFFFFF00000001LL);
  BOOL v18 = __CFADD__((void)v251, v13);
  uint64_t v33 = v251 + v13;
  BOOL v35 = v18;
  BOOL v18 = __CFADD__(v18, v14);
  unint64_t v34 = v35 + v14;
  uint64_t v36 = v18;
  unint64_t v37 = v252 + v25;
  BOOL v38 = __CFADD__((void)v252, v25);
  unint64_t v39 = *((void *)&v252 + 1) + v26;
  BOOL v40 = __CFADD__(*((void *)&v252 + 1), v26);
  unint64_t v42 = v34 + *((void *)&v251 + 1);
  BOOL v18 = __CFADD__(__CFADD__(v34, *((void *)&v251 + 1)), v37) | __CFADD__( v36,  (__PAIR128__(v37, v34)
                                                                  + *((unint64_t *)&v251 + 1)) >> 64);
  unint64_t v41 = v36 + ((__PAIR128__(v37, v34) + *((unint64_t *)&v251 + 1)) >> 64);
  unint64_t v44 = v18 + v39;
  BOOL v18 = __CFADD__(v18, v39) | __CFADD__(v38, v44);
  unint64_t v43 = v38 + v44;
  if (v18) {
    unint64_t v45 = v40 + 1;
  }
  else {
    unint64_t v45 = v40;
  }
  unsigned __int128 v46 = v42 - __PAIR128__(v26, (1 - __CFADD__(v33, 1LL)));
  unint64_t v47 = v43
      - -(uint64_t)((v41
                                   - __PAIR128__( 0xFFFFFFFF00000001LL,  (1 - (__CFADD__((void)v46, 0xFFFFFFFF00000001LL) + BYTE8(v46))))) >> 64);
  uint64_t v48 = -(uint64_t)(v45
                 + (v45 < (1
                                          - (__CFADD__(v47, 0xFFFFFFFFLL)
                                           + ((v43
                                             - __PAIR128__( DWORD2(v30),  -(uint64_t)((v41 - __PAIR128__( 0xFFFFFFFF00000001LL,  (1 - (__CFADD__( (void)v46,  0xFFFFFFFF00000001LL)
                                                                                                 + BYTE8(v46))))) >> 64))) >> 64)))));
  if ((_BYTE)v48) {
    uint64_t v49 = 0LL;
  }
  else {
    uint64_t v49 = -1LL;
  }
  if ((_BYTE)v48) {
    uint64_t v50 = -1LL;
  }
  else {
    uint64_t v50 = 0LL;
  }
  uint64_t v51 = v49 & (v33 + 1) | v50 & v33;
  uint64_t v52 = v49 & (v46 - 0xFFFFFFFF) | v50 & v42;
  uint64_t v53 = v49 & (v41 - (1 - (__CFADD__((void)v46, 0xFFFFFFFF00000001LL) + BYTE8(v46)))) | v50 & v41;
  uint64_t v54 = v49 & (v47 + 0xFFFFFFFF) | v50 & v43;
  *((void *)&v56 + 1) = v52;
  *(void *)&__int128 v56 = v51;
  uint64_t v55 = v56 >> 63;
  *((void *)&v56 + 1) = v53;
  *(void *)&__int128 v56 = v52;
  unint64_t v57 = v56 >> 63;
  *((void *)&v56 + 1) = v54;
  *(void *)&__int128 v56 = v53;
  unint64_t v58 = v56 >> 63;
  unint64_t v59 = v57 - (1 - __CFADD__(v55, 0xFFFFFFFF00000000LL));
  unint64_t v60 = v58
      - -(uint64_t)((v57 - __PAIR128__(v11, (1 - __CFADD__(v55, 0xFFFFFFFF00000000LL)))) >> 64);
  unsigned __int8 v61 = 1
      - (__CFADD__(v60, 0xFFFFFFFFLL)
       + ((v58
         - __PAIR128__( v12,  -(uint64_t)((v57 - __PAIR128__(v11, (1 - __CFADD__(v55, 0xFFFFFFFF00000000LL)))) >> 64))) >> 64));
  else {
    uint64_t v62 = -1LL;
  }
  else {
    uint64_t v63 = 0LL;
  }
  uint64_t v64 = v62 & ((2 * v51) | 1) | v63 & (2 * v51);
  uint64_t v65 = v62 & (v55 - 0x100000000LL) | v63 & v55;
  uint64_t v66 = v62 & v59;
  uint64_t v67 = v62 & v59 | v63 & v57;
  uint64_t v68 = v62 & (v60 + 0xFFFFFFFF) | v63 & v58;
  BOOL v18 = __CFADD__(v64, v51);
  uint64_t v69 = v64 + v51;
  BOOL v71 = v18;
  BOOL v18 = __CFADD__(v18, v52);
  uint64_t v70 = v71 + v52;
  uint64_t v72 = v18;
  BOOL v18 = __CFADD__(v70, v65);
  uint64_t v73 = v70 + v65;
  BOOL v75 = v18;
  BOOL v18 = __CFADD__(v18, v53);
  uint64_t v74 = v75 + v53;
  v18 |= __CFADD__(v72, v74);
  v74 += v72;
  uint64_t v76 = v18;
  BOOL v18 = __CFADD__(v74, v67);
  uint64_t v77 = v74 + v67;
  BOOL v79 = v18;
  BOOL v18 = __CFADD__(v18, v54);
  uint64_t v78 = v79 + v54;
  v18 |= __CFADD__(v76, v78);
  v78 += v76;
  unint64_t v80 = v18;
  BOOL v18 = __CFADD__(v78, v68);
  uint64_t v81 = v78 + v68;
  if (v18) {
    ++v80;
  }
  unsigned __int128 v82 = (unint64_t)v73 - __PAIR128__(v72, (1 - __CFADD__(v69, 1LL)));
  unsigned __int128 v83 = (unint64_t)v81
      - __PAIR128__( v66,  -(uint64_t)(((unint64_t)v77 - __PAIR128__( v64,  (1 - (__CFADD__((void)v82, 0xFFFFFFFF00000001LL)
                                                          + BYTE8(v82))))) >> 64));
  else {
    uint64_t v84 = -1LL;
  }
  v244[0] = v84 & (v69 + 1) | v69 & *((void *)&v83 + 1);
  v244[1] = v84 & (v82 - 0xFFFFFFFF) | *((void *)&v83 + 1) & v73;
  v244[2] = v84 & (v77 - (1 - (__CFADD__((void)v82, 0xFFFFFFFF00000001LL) + BYTE8(v82)))) | *((void *)&v83 + 1) & v77;
  v244[3] = v84 & (v83 + 0xFFFFFFFF) | *((void *)&v83 + 1) & v81;
  fiat_p256_mul((uint64_t *)v243, (unint64_t *)&v245, v244);
  fiat_p256_square(a1, (unint64_t *)v243);
  uint64_t v85 = *(__int128 *)v249 >> 63;
  unint64_t v86 = *(__int128 *)&v249[8] >> 63;
  unint64_t v87 = *(__int128 *)&v249[16] >> 63;
  unint64_t v89 = v86 - (1 - __CFADD__(v85, 0xFFFFFFFF00000000LL));
  unint64_t v92 = v87
      - -(uint64_t)((v86 - __PAIR128__(v88, (1 - __CFADD__(v85, 0xFFFFFFFF00000000LL)))) >> 64);
  uint64_t v91 = (v87
       - __PAIR128__( v90,  -(uint64_t)((v86 - __PAIR128__(v88, (1 - __CFADD__(v85, 0xFFFFFFFF00000000LL)))) >> 64))) >> 64;
  unint64_t v93 = v92 + 0xFFFFFFFF;
  unsigned __int8 v94 = 1 - (__CFADD__(v92, 0xFFFFFFFFLL) + v91);
  else {
    uint64_t v95 = -1LL;
  }
  else {
    uint64_t v96 = 0LL;
  }
  uint64_t v97 = v95 & ((2LL * *(void *)v249) | 1) | v96 & (2LL * *(void *)v249);
  uint64_t v98 = v95 & (v85 - 0x100000000LL) | v96 & v85;
  uint64_t v99 = v95 & v89 | v96 & v86;
  uint64_t v100 = v95 & v93 | v96 & v87;
  *((void *)&v102 + 1) = v98;
  *(void *)&__int128 v102 = v97;
  uint64_t v101 = v102 >> 63;
  *((void *)&v102 + 1) = v99;
  *(void *)&__int128 v102 = v98;
  unint64_t v103 = v102 >> 63;
  *((void *)&v102 + 1) = v100;
  *(void *)&__int128 v102 = v99;
  unint64_t v104 = v102 >> 63;
  unint64_t v105 = v103 - (1 - __CFADD__(v101, 0xFFFFFFFF00000000LL));
  unsigned __int128 v106 = v104
       - __PAIR128__( v96,  -(uint64_t)((v103 - __PAIR128__(v93, (1 - __CFADD__(v101, 0xFFFFFFFF00000000LL)))) >> 64));
  unint64_t v107 = v106 + 0xFFFFFFFF;
  if ((v100 < 0)
     + ((unint64_t)v100 >> 63 < (1 - (__CFADD__((void)v106, 0xFFFFFFFFLL) + BYTE8(v106)))))
  {
    uint64_t v108 = 0LL;
  }

  else
  {
    uint64_t v108 = -1LL;
  }

  uint64_t v109 = ((2 * v97) | 1) & v108 | *((void *)&v106 + 1) & (2 * v97);
  *(void *)&v239[8] = v108 & v105 | *((void *)&v106 + 1) & v103;
  *(void *)&v239[16] = v108 & v107 | *((void *)&v106 + 1) & v104;
  *(void *)uint64_t v239 = v108 & (v101 - 0x100000000LL) | *((void *)&v106 + 1) & v101;
  *((void *)&v111 + 1) = *(void *)v239;
  *(void *)&__int128 v111 = v109;
  uint64_t v110 = v111 >> 63;
  unint64_t v112 = *(__int128 *)v239 >> 63;
  unint64_t v113 = *(__int128 *)&v239[8] >> 63;
  unint64_t v114 = v112 - (1 - __CFADD__(v110, 0xFFFFFFFF00000000LL));
  unint64_t v116 = v113
       - -(uint64_t)((v112
                                    - __PAIR128__(v105, (1 - __CFADD__(v110, 0xFFFFFFFF00000000LL)))) >> 64);
  uint64_t v115 = (v113
        - __PAIR128__( v107,  -(uint64_t)((v112 - __PAIR128__(v105, (1 - __CFADD__(v110, 0xFFFFFFFF00000000LL)))) >> 64))) >> 64;
  unint64_t v117 = v116 + 0xFFFFFFFF;
  unsigned __int8 v118 = 1 - (__CFADD__(v116, 0xFFFFFFFFLL) + v115);
  else {
    uint64_t v119 = -1LL;
  }
  else {
    uint64_t v120 = 0LL;
  }
  uint64_t v121 = v120 & (2 * v109);
  uint64_t v122 = v119 & (v110 - 0x100000000LL) | v120 & v110;
  uint64_t v123 = v119 & v114 | v120 & v112;
  uint64_t v124 = v119 & v117 | v120 & v113;
  uint64_t v126 = ((unint64_t)*a1
        - __PAIR128__( ((2 * v109) | 1) & v119 | (unint64_t)v121,  ((2 * v109) | 1) & v119 | (unint64_t)v121)) >> 64;
  uint64_t v125 = *a1 - (((2 * v109) | 1) & v119 | v121);
  LODWORD(v126) = -(int)v126;
  BOOL v18 = __CFADD__(v122, v126);
  uint64_t v127 = v122 + v126;
  uint64_t v128 = v18;
  uint64_t v129 = a1[1] - v127;
  int v130 = -(int)(((unint64_t)a1[1] - __PAIR128__(v128, v127)) >> 64);
  BOOL v18 = __CFADD__(v123, v130);
  uint64_t v131 = v123 + v130;
  uint64_t v132 = v18;
  uint64_t v133 = a1[2] - v131;
  int v134 = -(int)(((unint64_t)a1[2] - __PAIR128__(v132, v131)) >> 64);
  BOOL v18 = __CFADD__(v124, v134);
  uint64_t v135 = v124 + v134;
  uint64_t v136 = v18;
  unsigned __int128 v137 = (unint64_t)a1[3] - __PAIR128__(v136, v135);
  *a1 = v125 + *((void *)&v137 + 1);
  a1[1] = DWORD2(v137) + __CFADD__(v125, *((void *)&v137 + 1)) + v129;
  a1[2] = (__CFADD__(__CFADD__(v125, *((void *)&v137 + 1)), v129) | __CFADD__( DWORD2(v137),  __CFADD__( v125,  *((void *)&v137 + 1))
                                                                                       + v129))
        + v133;
  a1[3] = v137
        + __CFADD__( __CFADD__(__CFADD__(v125, *((void *)&v137 + 1)), v129) | __CFADD__( DWORD2(v137),  __CFADD__( v125,  *((void *)&v137 + 1))
                                                                                        + v129),
            v133)
        + (*((void *)&v137 + 1) & 0xFFFFFFFF00000001LL);
  __int128 v138 = *(_OWORD *)v250;
  __int128 v139 = *(_OWORD *)v250 + v15;
  __int128 v140 = *(_OWORD *)&v250[16];
  unint64_t v141 = v22
  unint64_t v142 = *((void *)&v22 + 1)
       + (__CFADD__( __CFADD__(__CFADD__(*(void *)v250, (void)v15), *(void *)&v250[8]) | __CFADD__(*((void *)&v15 + 1), __CFADD__(*(void *)v250, (void)v15) + *(void *)&v250[8]),  (void)v140) | __CFADD__( (void)v22,  (__CFADD__(__CFADD__(*(void *)v250, (void)v15), *(void *)&v250[8]) | __CFADD__(*((void *)&v15 + 1), __CFADD__(*(void *)v250, (void)v15) + *(void *)&v250[8]))
                                             + (void)v140))
       + *(void *)&v250[24];
  if (__CFADD__( __CFADD__( __CFADD__(__CFADD__(*(void *)v250, (void)v15), *(void *)&v250[8]) | __CFADD__(*((void *)&v15 + 1), __CFADD__(*(void *)v250, (void)v15) + *(void *)&v250[8]),  *(void *)&v250[16]) | __CFADD__( (void)v22,  (__CFADD__( __CFADD__(*(void *)v250, (void)v15),  *(void *)&v250[8]) | __CFADD__( *((void *)&v15 + 1),  __CFADD__( *(void *)v250,  (void)v15)
                                                                                                 + *(void *)&v250[8]))
                                                    + *(void *)&v250[16]),
         *(void *)&v250[24]) | __CFADD__( *((void *)&v22 + 1),  (__CFADD__( __CFADD__(__CFADD__(*(void *)v250, (void)v15), *(void *)&v250[8]) | __CFADD__(*((void *)&v15 + 1), __CFADD__(*(void *)v250, (void)v15) + *(void *)&v250[8]),  *(void *)&v250[16]) | __CFADD__( (void)v22,  (__CFADD__( __CFADD__( *(void *)v250,  (void)v15),  *(void *)&v250[8]) | __CFADD__(*((void *)&v15 + 1), __CFADD__(*(void *)v250, (void)v15) + *(void *)&v250[8]))
                                                                               + *(void *)&v250[16]))
                                 + *(void *)&v250[24]))
    unint64_t v143 = 1LL;
  else {
    unint64_t v143 = 0LL;
  }
  unsigned __int128 v144 = *((unint64_t *)&v139 + 1) - __PAIR128__(v117, (1 - __CFADD__((void)v139, 1LL)));
  unint64_t v146 = v142
       - -(uint64_t)((v141
                                    - __PAIR128__( v120,  (1 - (__CFADD__((void)v144, 0xFFFFFFFF00000001LL)
                                                         + BYTE8(v144))))) >> 64);
  uint64_t v145 = (v142
        - __PAIR128__( v121,  -(uint64_t)((v141 - __PAIR128__( v120,  (1 - (__CFADD__((void)v144, 0xFFFFFFFF00000001LL)
                                                            + BYTE8(v144))))) >> 64))) >> 64;
  unint64_t v147 = v146 + 0xFFFFFFFF;
  uint64_t v148 = -(uint64_t)(v143 + (v143 < (1 - (__CFADD__(v146, 0xFFFFFFFFLL) + v145))));
  BOOL v149 = v148 == 0;
  if ((_BYTE)v148) {
    uint64_t v150 = 0LL;
  }
  else {
    uint64_t v150 = -1LL;
  }
  if (v149) {
    uint64_t v151 = 0LL;
  }
  else {
    uint64_t v151 = -1LL;
  }
  uint64_t v152 = v150 & (v139 + 1) | v151 & v139;
  uint64_t v153 = v150 & (v144 - 0xFFFFFFFF) | v151 & *((void *)&v139 + 1);
  uint64_t v154 = v150 & (v141 - (1 - (__CFADD__((void)v144, 0xFFFFFFFF00000001LL) + BYTE8(v144)))) | v151 & v141;
  uint64_t v238 = v150 & v147 | v151 & v142;
  unint64_t v155 = a6[1];
  unint64_t v157 = (*a6 + *(_OWORD *)a5) >> 64;
  unint64_t v156 = *a6 + *a5;
  BOOL v158 = __CFADD__(__CFADD__(*a6, *a5), a5[1]);
  unint64_t v159 = a5[2];
  unint64_t v160 = a5[3];
  unint64_t v161 = a6[2];
  unint64_t v162 = a6[3];
  BOOL v18 = __CFADD__(v161, v159);
  unint64_t v163 = v161 + v159;
  uint64_t v164 = v18;
  BOOL v18 = __CFADD__(v162, v160);
  unint64_t v165 = v162 + v160;
  uint64_t v166 = v18;
  unint64_t v168 = v157 + v155;
  BOOL v18 = __CFADD__(__CFADD__(v157, v155), v163) | __CFADD__(v158, (__PAIR128__(v163, v157) + v155) >> 64);
  unint64_t v167 = v158 + ((__PAIR128__(v163, v157) + v155) >> 64);
  uint64_t v169 = v164 + v18 + v165;
  if (__CFADD__(v18, v165) | __CFADD__(v164, v18 + v165)) {
    unint64_t v170 = v166 + 1;
  }
  else {
    unint64_t v170 = v166;
  }
  unsigned __int128 v171 = v168 - __PAIR128__(v166, (1 - __CFADD__(v156, 1LL)));
  unsigned __int128 v172 = (unint64_t)v169
       - __PAIR128__( v151,  -(uint64_t)((v167 - __PAIR128__( v147,  (1 - (__CFADD__((void)v171, 0xFFFFFFFF00000001LL)
                                                           + BYTE8(v171))))) >> 64));
  else {
    uint64_t v173 = -1LL;
  }
  uint64_t v245 = v173 & (v156 + 1) | *((void *)&v172 + 1) & v156;
  uint64_t v246 = v173 & (v171 - 0xFFFFFFFF) | *((void *)&v172 + 1) & v168;
  uint64_t v247 = v173 & (v167 - (1 - (__CFADD__((void)v171, 0xFFFFFFFF00000001LL) + BYTE8(v171)))) | *((void *)&v172 + 1) & v167;
  uint64_t v248 = v173 & (v172 + 0xFFFFFFFF) | *((void *)&v172 + 1) & v169;
  fiat_p256_square(a3, (unint64_t *)&v245);
  unint64_t v177 = *a3 - v152;
  unint64_t v178 = a3[1] - (v153 + -(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64));
  BOOL v18 = __CFADD__( v154,  -(uint64_t)(((unint64_t)a3[1] - __PAIR128__( v153 + (unint64_t)-(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64),  v153 + (unint64_t)-(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64))) >> 64));
  uint64_t v179 = v154
       + -(uint64_t)(((unint64_t)a3[1]
                                    - __PAIR128__( v153 + (unint64_t)-(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64),  v153 + (unint64_t)-(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64))) >> 64);
  uint64_t v180 = v18;
  uint64_t v181 = a3[2] - v179;
  BOOL v18 = __CFADD__(v238, -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v180, v179)) >> 64));
  uint64_t v182 = v238 + -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v180, v179)) >> 64);
  uint64_t v183 = v18;
  unsigned __int128 v184 = (unint64_t)a3[3] - __PAIR128__(v183, v182);
  unint64_t v185 = __CFADD__(v177, *((void *)&v184 + 1)) + v178;
  uint64_t v186 = __CFADD__(__CFADD__(v177, *((void *)&v184 + 1)), v178) | __CFADD__(DWORD2(v184), v185);
  *a3 = v177 + *((void *)&v184 + 1);
  a3[1] = DWORD2(v184) + v185;
  a3[2] = v186 + v181;
  a3[3] = v184 + __CFADD__(v186, v181) + (*((void *)&v184 + 1) & 0xFFFFFFFF00000001LL);
  unint64_t v187 = a1[1];
  unint64_t v188 = v109 - *a1;
  BOOL v18 = __CFADD__(v187, -(uint64_t)(((unint64_t)v109 - __PAIR128__(v186 + v181, *a1)) >> 64));
  unint64_t v189 = v187 + -(uint64_t)(((unint64_t)v109 - __PAIR128__(v186 + v181, *a1)) >> 64);
  uint64_t v190 = v18;
  unint64_t v191 = *(void *)v239 - v189;
  unint64_t v192 = a1[2];
  unint64_t v193 = a1[3];
  BOOL v18 = __CFADD__(v192, -(uint64_t)((*(unint64_t *)v239 - __PAIR128__(v190, v189)) >> 64));
  unint64_t v194 = v192 + -(uint64_t)((*(unint64_t *)v239 - __PAIR128__(v190, v189)) >> 64);
  uint64_t v195 = v18;
  unint64_t v197 = *(void *)&v239[8] - v194;
  char v196 = (*(unint64_t *)&v239[8] - __PAIR128__(v195, v194)) >> 64;
  BOOL v18 = __CFADD__(v193, -v196);
  unint64_t v198 = v193 + -v196;
  uint64_t v199 = v18;
  unsigned __int128 v200 = *(unint64_t *)&v239[16] - __PAIR128__(v199, v198);
  unint64_t v201 = __CFADD__(v188, *((void *)&v200 + 1)) + v191;
  uint64_t v202 = __CFADD__(__CFADD__(v188, *((void *)&v200 + 1)), v191) | __CFADD__(DWORD2(v200), v201);
  *a2 = v188 + *((void *)&v200 + 1);
  a2[1] = DWORD2(v200) + v201;
  a2[2] = v202 + v197;
  a2[3] = v200 + __CFADD__(v202, v197) + (*((void *)&v200 + 1) & 0xFFFFFFFF00000001LL);
  uint64_t v203 = v138 >> 63;
  *((void *)&v205 + 1) = v140;
  *(void *)&__int128 v205 = *((void *)&v138 + 1);
  unint64_t v204 = v205 >> 63;
  unint64_t v206 = v140 >> 63;
  unint64_t v207 = v206
       - -(uint64_t)((v204
                                    - __PAIR128__(v174, (1 - __CFADD__(v203, 0xFFFFFFFF00000000LL)))) >> 64);
  unsigned __int8 v208 = 1
       - (__CFADD__(v207, 0xFFFFFFFFLL)
        + ((v206
          - __PAIR128__( v175,  -(uint64_t)((v204 - __PAIR128__( v174,  (1 - __CFADD__(v203, 0xFFFFFFFF00000000LL)))) >> 64))) >> 64));
  else {
    uint64_t v209 = -1LL;
  }
  else {
    uint64_t v210 = 0LL;
  }
  *(void *)uint64_t v250 = v209 & ((2 * v138) | 1) | v210 & (2 * v138);
  *(void *)&v250[8] = v209 & (v203 - 0x100000000LL) | v210 & v203;
  *(void *)&v250[16] = v209 & (v204 - (1 - __CFADD__(v203, 0xFFFFFFFF00000000LL))) | v210 & v204;
  *(void *)&v250[24] = v209 & (v207 + 0xFFFFFFFF) | v210 & v206;
  fiat_p256_square((uint64_t *)v250, (unint64_t *)v250);
  double result = fiat_p256_mul(a2, (unint64_t *)v243, (unint64_t *)a2);
  uint64_t v212 = *(__int128 *)v250 >> 63;
  unint64_t v213 = *(__int128 *)&v250[8] >> 63;
  unint64_t v214 = *(__int128 *)&v250[16] >> 63;
  unint64_t v216 = v213 - (1 - __CFADD__(v212, 0xFFFFFFFF00000000LL));
  unint64_t v218 = v214
       - -(uint64_t)((v213
                                    - __PAIR128__(v215, (1 - __CFADD__(v212, 0xFFFFFFFF00000000LL)))) >> 64);
  unsigned __int8 v219 = 1
       - (__CFADD__(v218, 0xFFFFFFFFLL)
        + ((v214
          - __PAIR128__( v217,  -(uint64_t)((v213 - __PAIR128__( v215,  (1 - __CFADD__(v212, 0xFFFFFFFF00000000LL)))) >> 64))) >> 64));
  else {
    uint64_t v220 = -1LL;
  }
  else {
    uint64_t v221 = 0LL;
  }
  uint64_t v222 = v220 & (v212 - 0x100000000LL) | v221 & v212;
  uint64_t v223 = v220 & v216 | v221 & v213;
  uint64_t v224 = v220 & (v218 + 0xFFFFFFFF) | v221 & v214;
  uint64_t v225 = *a2 - (v220 & ((2LL * *(void *)v250) | 1) | v221 & (2LL * *(void *)v250));
  int v226 = -(int)(((unint64_t)*a2
               - __PAIR128__( *a2,  v220 & ((2LL * *(void *)v250) | 1) | v221 & (unint64_t)(2LL * *(void *)v250))) >> 64);
  BOOL v18 = __CFADD__(v222, v226);
  uint64_t v227 = v222 + v226;
  uint64_t v228 = v18;
  uint64_t v229 = a2[1] - v227;
  int v230 = -(int)(((unint64_t)a2[1] - __PAIR128__(v228, v227)) >> 64);
  BOOL v18 = __CFADD__(v223, v230);
  uint64_t v231 = v223 + v230;
  uint64_t v232 = v18;
  uint64_t v233 = a2[2] - v231;
  int v234 = -(int)(((unint64_t)a2[2] - __PAIR128__(v232, v231)) >> 64);
  BOOL v18 = __CFADD__(v224, v234);
  uint64_t v235 = v224 + v234;
  uint64_t v236 = v18;
  unsigned __int128 v237 = (unint64_t)a2[3] - __PAIR128__(v236, v235);
  *a2 = v225 + *((void *)&v237 + 1);
  a2[1] = DWORD2(v237) + __CFADD__(v225, *((void *)&v237 + 1)) + v229;
  a2[2] = (__CFADD__(__CFADD__(v225, *((void *)&v237 + 1)), v229) | __CFADD__( DWORD2(v237),  __CFADD__( v225,  *((void *)&v237 + 1))
                                                                                       + v229))
        + v233;
  a2[3] = v237
        + __CFADD__( __CFADD__(__CFADD__(v225, *((void *)&v237 + 1)), v229) | __CFADD__( DWORD2(v237),  __CFADD__( v225,  *((void *)&v237 + 1))
                                                                                        + v229),
            v233)
        + (*((void *)&v237 + 1) & 0xFFFFFFFF00000001LL);
  return result;
}

int8x16_t fiat_p256_cmovznz(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2) {
    unint64_t v4 = 0LL;
  }
  else {
    unint64_t v4 = -1LL;
  }
  if (a2) {
    unint64_t v5 = -1LL;
  }
  else {
    unint64_t v5 = 0LL;
  }
  unint64_t v6 = *(void *)(a4 + 24) & v5 | *(void *)(a3 + 24) & v4;
  int8x16_t v7 = vandq_s8(*(int8x16_t *)(a4 + 8), (int8x16_t)vdupq_n_s64(v5));
  int8x16_t v8 = vandq_s8(*(int8x16_t *)(a3 + 8), (int8x16_t)vdupq_n_s64(v4));
  *(void *)a1 = v4 & *(void *)a3 | v5 & *(void *)a4;
  int8x16_t result = vorrq_s8(v7, v8);
  *(int8x16_t *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = result;
  *(void *)(a1 + 24) = v6;
  return result;
}

double fiat_p256_select_point_affine(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v6 = 0LL;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  uint64_t v7 = (uint64_t)(a3 + 2);
  uint64_t v8 = a1 - 1;
  do
  {
    fiat_p256_cmovznz((uint64_t)a3, v6 ^ v8, a2, (uint64_t)a3);
    fiat_p256_cmovznz(v7, v6++ ^ v8, a2 + 32, v7);
    a2 += 64LL;
  }

  while (v6 != 15);
  *(void *)&double result = fiat_p256_cmovznz((uint64_t)(a3 + 4), a1, (uint64_t)(a3 + 4), (uint64_t)&fiat_p256_one).u64[0];
  return result;
}

uint64_t BIO_set_fd(BIO *a1, int iarg, int a3)
{
  return BIO_int_ctrl(a1, 104, a3, iarg);
}

uint64_t BIO_get_fd(BIO *a1, void *parg)
{
  return BIO_ctrl(a1, 105, 0LL, parg);
}

BIO *__cdecl BIO_new_fp(FILE *stream, int close_flag)
{
  unint64_t v4 = BIO_new(&methods_filep);
  unint64_t v5 = v4;
  if (v4) {
    BIO_ctrl(v4, 106, close_flag, stream);
  }
  return v5;
}

BIO_METHOD *BIO_s_file(void)
{
  return (BIO_METHOD *)&methods_filep;
}

uint64_t BIO_set_fp(BIO *a1, void *parg, int a3)
{
  return BIO_ctrl(a1, 106, a3, parg);
}

uint64_t file_write(uint64_t a1, void *__ptr, unsigned int a3)
{
  if (!*(_DWORD *)(a1 + 16)) {
    return 0LL;
  }
  LODWORD(result) = fwrite(__ptr, (int)a3, 1uLL, *(FILE **)(a1 + 40));
  else {
    return a3;
  }
}

size_t file_read(uint64_t a1, void *__ptr, int a3)
{
  if (!*(_DWORD *)(a1 + 16)) {
    return 0LL;
  }
  size_t v4 = fread(__ptr, 1uLL, a3, *(FILE **)(a1 + 40));
  if (!v4 && ferror(*(FILE **)(a1 + 40)))
  {
    ERR_put_error(2, 0, 0, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", 161);
    ERR_put_error(17, 0, 2, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", 162);
    return 0xFFFFFFFFLL;
  }

  return v4;
}

char *file_gets(uint64_t a1, char *a2, int a3)
{
  if (!a3) {
    return 0LL;
  }
  uint64_t result = fgets(a2, a3, *(FILE **)(a1 + 40));
  if (result) {
    return (char *)strlen(a2);
  }
  *a2 = 0;
  return result;
}

uint64_t file_ctrl(uint64_t a1, int a2, uint64_t a3, char *a4)
{
  uint64_t v4 = a3;
  uint64_t result = 0LL;
  if (a2 <= 105)
  {
    switch(a2)
    {
      case 1:
        uint64_t v4 = 0LL;
        goto LABEL_12;
      case 2:
        LODWORD(result) = feof(*(FILE **)(a1 + 40));
        return (int)result;
      case 3:
        goto LABEL_36;
      case 8:
        return *(int *)(a1 + 20);
      case 9:
        *(_DWORD *)(a1 + 20) = a3;
        return 1LL;
      case 11:
        return fflush(*(FILE **)(a1 + 40)) == 0;
      default:
        return result;
    }
  }

  if (a2 > 107)
  {
    if (a2 != 108)
    {
      if (a2 == 128)
      {
LABEL_12:
        LODWORD(result) = fseek(*(FILE **)(a1 + 40), v4, 0);
        return (int)result;
      }

      else if (a2 == 133)
      {
LABEL_36:
        JUMPOUT(0x1895A91C0LL);
      }

      return result;
    }

    file_free(a1);
    *(_DWORD *)(a1 + 20) = v4 & 1;
    if ((v4 & 8) != 0)
    {
      if ((v4 & 2) != 0) {
        unint64_t v9 = "ab+";
      }
      else {
        unint64_t v9 = "ab";
      }
    }

    else
    {
      uint64_t v8 = v4 & 6;
      if (v8 == 6)
      {
        unint64_t v9 = "rb+";
      }

      else
      {
        if ((v4 & 4) != 0) {
          unint64_t v9 = "wb";
        }
        else {
          unint64_t v9 = "rb";
        }
        if (!v8)
        {
          int v11 = 100;
          int v12 = 235;
LABEL_34:
          ERR_put_error(17, 0, v11, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", v12);
          return 0LL;
        }
      }
    }

    __int128 v10 = fopen(a4, v9);
    if (v10)
    {
      *(void *)(a1 + 40) = v10;
      uint64_t result = 1LL;
      *(_DWORD *)(a1 + 16) = 1;
      return result;
    }

    ERR_put_error(2, 0, 0, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/bio/file.c", 241);
    ERR_add_error_data(5, "fopen('", a4, "','", v9, "')");
    int v11 = 2;
    int v12 = 243;
    goto LABEL_34;
  }

  if (a2 == 106)
  {
    file_free(a1);
    *(void *)(a1 + 40) = a4;
    uint64_t result = 1LL;
    *(_DWORD *)(a1 + 16) = 1;
    *(_DWORD *)(a1 + 20) = v4 & 1;
  }

  else
  {
    if (a4) {
      *(void *)a4 = *(void *)(a1 + 40);
    }
    return 1LL;
  }

  return result;
}

uint64_t file_free(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20))
  {
    if (*(_DWORD *)(a1 + 16))
    {
      unint64_t v2 = *(FILE **)(a1 + 40);
      if (v2)
      {
        fclose(v2);
        *(void *)(a1 + 40) = 0LL;
      }
    }

    *(_DWORD *)(a1 + 16) = 0;
  }

  return 1LL;
}

BOOL BIO_hexdump(BIO *a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  indent[1] = 0;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  BIGNUM b = a1;
  indent[0] = a4;
  __int16 v22 = -21846;
  unint64_t data = 0xAAAAAAAAAAAAAAAALL;
  if (!a3) {
    return 1LL;
  }
  int v6 = 0;
  BOOL v7 = 0;
  for (i = 0LL; i != a3; BOOL v7 = i >= a3)
  {
    if (!v6)
    {
      BIO_indent(b, indent[0], -1);
      LOBYTE(data) = hexbyte_hextable[DWORD2(v19) >> 28];
      BYTE1(data) = hexbyte_hextable[(*((void *)&v19 + 1) >> 24) & 0xFLL];
      BYTE2(data) = hexbyte_hextable[(*((void *)&v19 + 1) >> 20) & 0xFLL];
      BYTE3(data) = hexbyte_hextable[(*((void *)&v19 + 1) >> 16) & 0xFLL];
      BYTE4(data) = hexbyte_hextable[WORD4(v19) >> 12];
      BYTE5(data) = hexbyte_hextable[(*((void *)&v19 + 1) >> 8) & 0xFLL];
      BYTE6(data) = hexbyte_hextable[BYTE8(v19) >> 4];
      HIBYTE(data) = hexbyte_hextable[BYTE8(v19) & 0xF];
      __int16 v22 = 8224;
      if (BIO_write(b, &data, 10) < 0) {
        break;
      }
      int v6 = DWORD1(v19);
    }

    unint64_t v9 = *(unsigned __int8 *)(a2 + i);
    LOBYTE(data) = hexbyte_hextable[v9 >> 4];
    BYTE1(data) = hexbyte_hextable[v9 & 0xF];
    BYTE2(data) = 32;
    if (v6 == 15)
    {
      *(_WORD *)((char *)&data + 3) = 31776;
      int v10 = 5;
    }

    else if (v6 == 7)
    {
      BYTE3(data) = 32;
      int v10 = 4;
    }

    else
    {
      int v10 = 3;
    }

    if (BIO_write(b, &data, v10) < 0) {
      break;
    }
    int v11 = *(unsigned __int8 *)(a2 + i);
    *((_BYTE *)&b + DWORD1(v19) + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v11;
    int v6 = DWORD1(v19) + 1;
    DWORD1(v19) = v6;
    ++*((void *)&v19 + 1);
    if (v6 == 16)
    {
      LOWORD(v19) = 2684;
      if (BIO_write(b, &v18, 18) < 0) {
        break;
      }
      int v6 = 0;
      DWORD1(v19) = 0;
    }

    ++i;
  }

  if (!v7) {
    return 0LL;
  }
  uint64_t v12 = DWORD1(v19);
  if (!DWORD1(v19)) {
    return 1LL;
  }
  qmemcpy(&data, "    |", 5);
  if (DWORD1(v19) <= 0xF)
  {
    for (unsigned int j = DWORD1(v19); j < 0x10; DWORD1(v19) = j)
    {
      int v14 = j == 15 ? 5 : 3;
      int v15 = j == 7 ? 4 : v14;
      if (BIO_write(b, &data, v15) < 0) {
        return 0LL;
      }
      unsigned int j = DWORD1(v19) + 1;
    }
  }

  *((_BYTE *)&v18 + v12) = 124;
  *((_BYTE *)&v18 + (v12 + OPENSSL_free(*((void **)this + 1)) = 10;
  return (BIO_write(b, &v18, v12 + 2) & 0x80000000) == 0;
}

void HMAC_CTX_init(HMAC_CTX *ctx)
{
  ctx->mint d = 0LL;
  p_md_EVP_MD_CTX ctx = &ctx->md_ctx;
  EVP_MD_CTX_init(&ctx->i_ctx);
  EVP_MD_CTX_init(&ctx->o_ctx);
  EVP_MD_CTX_init(p_md_ctx);
}

void HMAC_CTX_cleanup(HMAC_CTX *ctx)
{
}

void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl)
{
  size_t v6 = *(void *)&len;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (md) {
    unint64_t v9 = md;
  }
  else {
    unint64_t v9 = ctx->md;
  }
  if (!key && v9 == ctx->md) {
    goto LABEL_6;
  }
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  d[6] = v10;
  d[7] = v10;
  d[4] = v10;
  d[5] = v10;
  d[2] = v10;
  d[3] = v10;
  d[0] = v10;
  d[1] = v10;
  __int128 v25 = v10;
  __int128 v26 = v10;
  __int128 v23 = v10;
  __int128 v24 = v10;
  __int128 v21 = v10;
  __int128 v22 = v10;
  *(_OWORD *)mda = v10;
  __int128 v20 = v10;
  unsigned int s = -1431655766;
  unint64_t v11 = EVP_MD_block_size(v9);
  if (v11 >= 0x81) {
    HMAC_Init_ex_cold_1();
  }
  if (v11 >= v6)
  {
    if (v6) {
      __memcpy_chk();
    }
    unsigned int s = v6;
  }

  else
  {
    if (!EVP_DigestInit_ex(&ctx->md_ctx, v9, impl)
      || !EVP_DigestUpdate(&ctx->md_ctx, key, v6)
      || !EVP_DigestFinal_ex(&ctx->md_ctx, mda, &s))
    {
      return;
    }

    LODWORD(v6) = s;
  }

  if ((_DWORD)v6 != 128) {
    bzero(&mda[v6], 128LL - v6);
  }
  uint64_t v12 = 0LL;
  v13.i64[0] = 0x3636363636363636LL;
  v13.i64[1] = 0x3636363636363636LL;
  do
  {
    d[v12] = veorq_s8(*(int8x16_t *)&mda[v12 * 16], v13);
    ++v12;
  }

  while (v12 != 8);
  if (EVP_DigestInit_ex(&ctx->i_ctx, v9, impl))
  {
    size_t v14 = EVP_MD_block_size(v9);
    if (EVP_DigestUpdate(&ctx->i_ctx, d, v14))
    {
      uint64_t v15 = 0LL;
      v16.i64[0] = 0x5C5C5C5C5C5C5C5CLL;
      v16.i64[1] = 0x5C5C5C5C5C5C5C5CLL;
      do
      {
        d[v15] = veorq_s8(*(int8x16_t *)&mda[v15 * 16], v16);
        ++v15;
      }

      while (v15 != 8);
      if (EVP_DigestInit_ex(&ctx->o_ctx, v9, impl))
      {
        size_t v17 = EVP_MD_block_size(v9);
        if (EVP_DigestUpdate(&ctx->o_ctx, d, v17))
        {
          ctx->mint d = v9;
LABEL_6:
          EVP_MD_CTX_copy_ex(&ctx->md_ctx, &ctx->i_ctx);
        }
      }
    }
  }

void HMAC_Update(HMAC_CTX *ctx, const unsigned __int8 *data, size_t len)
{
}

void HMAC_Final(HMAC_CTX *ctx, unsigned __int8 *md, unsigned int *len)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  unsigned int s = -1431655766;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v11 = v6;
  __int128 v12 = v6;
  *(_OWORD *)mda = v6;
  __int128 v10 = v6;
  p_md_EVP_MD_CTX ctx = &ctx->md_ctx;
  if (!EVP_DigestFinal_ex(&ctx->md_ctx, mda, &s)
    || !EVP_MD_CTX_copy_ex(p_md_ctx, &ctx->o_ctx)
    || !EVP_DigestUpdate(p_md_ctx, mda, s)
    || !EVP_DigestFinal_ex(p_md_ctx, md, len))
  {
    *leuint64_t n = 0;
  }

uint64_t HMAC_size(const EVP_MD **a1)
{
  return EVP_MD_size(*a1);
}

uint64_t HMAC_CTX_copy_ex(uint64_t a1, uint64_t a2)
{
  uint64_t result = EVP_MD_CTX_copy_ex((EVP_MD_CTX *)(a1 + 40), (const EVP_MD_CTX *)(a2 + 40));
  if ((_DWORD)result)
  {
    uint64_t result = EVP_MD_CTX_copy_ex((EVP_MD_CTX *)(a1 + 72), (const EVP_MD_CTX *)(a2 + 72));
    if ((_DWORD)result)
    {
      uint64_t result = EVP_MD_CTX_copy_ex((EVP_MD_CTX *)(a1 + 8), (const EVP_MD_CTX *)(a2 + 8));
      if ((_DWORD)result)
      {
        *(void *)a1 = *(void *)a2;
        return 1LL;
      }
    }
  }

  return result;
}

void bssl::SSL_SESSION_parse( __int128 *a1@<X0>, uint64_t (**a2)(void)@<X1>, void **a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t v64 = 0xAAAAAAAAAAAAAAAALL;
  bssl::ssl_session_new(a2, &v64);
  if (!v64)
  {
    *a4 = 0LL;
    return;
  }

  memset(v63, 170, sizeof(v63));
  __int16 v62 = -21846;
  if (!CBS_get_asn1(a1, &v63[1], 536870928)
    || !CBS_get_asn1_uint64(&v63[1], (unint64_t *)v63 + 1)
    || *((void *)&v63[0] + 1) != 1LL
    || !CBS_get_asn1_uint64(&v63[1], (unint64_t *)v63)
    || *(void *)&v63[0] >> 16
    || (bssl::ssl_protocol_version_from_wire((bssl *)&v62, (unsigned __int16 *)LOWORD(v63[0])) & 1) == 0)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 553);
    goto LABEL_18;
  }

  *(_WORD *)(v64 + 4) = v63[0];
  memset(v61, 170, 18);
  if (!CBS_get_asn1(&v63[1], &v61[1], 4)
    || !CBS_get_u16((unsigned __int16 **)&v61[1], v61)
    || *(void *)&v61[5])
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 563);
    goto LABEL_18;
  }

  cipher_by_value = SSL_get_cipher_by_value(v61[0]);
  *(void *)(v64 + 200) = cipher_by_value;
  if (!cipher_by_value)
  {
    ERR_put_error(16, 0, 237, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 568);
    goto LABEL_18;
  }

  memset(__src, 170, sizeof(__src));
  if (!CBS_get_asn1(&v63[1], &__src[2], 4)
    || __src[3] > (void *)0x20
    || !CBS_get_asn1(&v63[1], __src, 4)
    || (unint64_t v9 = __src[1], __src[1] >= (void *)0x31))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 577);
LABEL_18:
    *a4 = 0LL;
    goto LABEL_19;
  }

  __int128 v11 = (_BYTE *)v64;
  char v12 = (char)__src[3];
  if (__src[3]) {
    memcpy((void *)(v64 + 60), __src[2], (size_t)__src[3]);
  }
  v11[59] = v12;
  if (v9)
  {
    memcpy(v11 + 11, __src[0], (size_t)v9);
    char v13 = (char)__src[1];
  }

  else
  {
    char v13 = 0;
  }

  v11[10] = v13;
  memset(v59, 170, sizeof(v59));
  if (!CBS_get_asn1(&v63[1], &v59[1], -1610612735)
    || !CBS_get_asn1_uint64((__int128 *)&v59[1], (unint64_t *)(v64 + 192))
    || !CBS_get_asn1(&v63[1], &v59[1], -1610612734)
    || !CBS_get_asn1_uint64((__int128 *)&v59[1], v59)
    || HIDWORD(v59[0]))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 596);
    goto LABEL_18;
  }

  *(_DWORD *)(v64 + 184) = v59[0];
  memset(v58, 170, sizeof(v58));
  if (!CBS_get_optional_asn1(&v63[1], &v58[1], v58, -1610612733) || v58[0] && !*(void *)&v58[3])
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 606);
    goto LABEL_18;
  }

  if (!bssl::SSL_SESSION_parse_bounded_octet_string( &v63[1],  (void *)(v64 + 93),  (_BYTE *)(v64 + 92),  0x20u,  -1610612732)
    || !bssl::SSL_SESSION_parse_long(&v63[1], (void *)(v64 + 176)))
  {
    goto LABEL_18;
  }

  v57[0] = 0xAAAAAAAAAAAAAAAALL;
  v57[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_optional_asn1(&v63[1], v57, 0LL, -1610612730))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 623);
    goto LABEL_18;
  }

  if (!bssl::SSL_SESSION_parse_string(&v63[1], (void **)(v64 + 128))
    || !bssl::SSL_SESSION_parse_u32(&v63[1], (_DWORD *)(v64 + 372), -1610612727, 0)
    || (bssl::SSL_SESSION_parse_octet_string(&v63[1], (void **)(v64 + 232), -1610612726) & 1) == 0)
  {
    goto LABEL_18;
  }

  if (CBS_peek_asn1_tag(&v63[1], -1610612723))
  {
    *(void *)&__int128 v56 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v56 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_asn1(&v63[1], &v59[1], -1610612723)
      || !CBS_get_asn1((__int128 *)&v59[1], &v56, 4)
      || *((void *)&v56 + 1) != 32LL
      || v59[2])
    {
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 641);
      goto LABEL_18;
    }

    unint64_t v14 = v64;
    __int128 v15 = *(_OWORD *)(v56 + 16);
    *(_OWORD *)(v64 + 272) = *(_OWORD *)v56;
    *(_OWORD *)(v14 + 28bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v15;
    char v16 = *(_BYTE *)(v14 + 440) | 2;
  }

  else
  {
    unint64_t v14 = v64;
    char v16 = *(_BYTE *)(v64 + 440) & 0xFD;
  }

  *(_BYTE *)(v14 + 440) = v16;
  if (!bssl::SSL_SESSION_parse_bounded_octet_string( &v63[1],  (void *)(v14 + 304),  (_BYTE *)(v14 + 368),  0x40u,  -1610612722)
    || !bssl::SSL_SESSION_parse_crypto_buffer(&v63[1], (unsigned int **)(v64 + 248), -1610612721, a3)
    || !bssl::SSL_SESSION_parse_crypto_buffer(&v63[1], (unsigned int **)(v64 + 256), -1610612720, a3))
  {
    goto LABEL_18;
  }

  int v55 = -1431655766;
  if (!CBS_get_optional_asn1_BOOL(&v63[1], &v55, -1610612719, 0))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 667);
    goto LABEL_18;
  }

  unint64_t v17 = v64;
  *(_BYTE *)(v64 + 440) = *(_BYTE *)(v64 + 440) & 0xFE | (v55 != 0);
  if (!bssl::SSL_SESSION_parse_u16(&v63[1], (_WORD *)(v17 + 6), -1610612718))
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 673);
    goto LABEL_18;
  }

  __int128 v56 = 0uLL;
  int v54 = -1431655766;
  if (!v54)
  {
    int v18 = v58[0];
    goto LABEL_69;
  }

  if (!*((void *)&v56 + 1))
  {
LABEL_67:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 683);
    goto LABEL_18;
  }

  int v18 = v58[0];
  if (!v58[0])
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 687);
    goto LABEL_18;
  }

LABEL_69:
  if (!(v18 | v54)) {
    goto LABEL_81;
  }
  unint64_t v19 = v64;
  __int128 v20 = OPENSSL_sk_new_null();
  std::unique_ptr<stack_st_CRYPTO_BUFFER,bssl::internal::Deleter>::reset[abi:ne180100]( (unint64_t **)(v19 + 136),  v20);
  if (!*(void *)(v64 + 136)) {
    goto LABEL_18;
  }
  if (v58[0])
  {
    __int128 v21 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v58[1], a3);
    uint64_t v51 = v21;
    if (v21)
    {
      __int128 v22 = *(unint64_t **)(v64 + 136);
      uint64_t v51 = 0LL;
      uint64_t v53 = v21;
      if (OPENSSL_sk_push(v22, (uint64_t)v21))
      {
        uint64_t v53 = 0LL;
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v53, 0LL);
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v51, 0LL);
        goto LABEL_75;
      }

      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v53, 0LL);
    }

    *a4 = 0LL;
    unint64_t v44 = &v51;
LABEL_125:
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](v44, 0LL);
    goto LABEL_19;
  }

    int v18 = 0LL;
    goto LABEL_70;
  }

  *(void *)&char v38 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
  int v49 = v38;
  uint64_t v50 = v38;
  int v47 = v38;
  int v48 = v38;
  int v45 = v38;
  unsigned __int128 v46 = v38;
  if (CBB_add_u24_length_prefixed((uint64_t *)v51, (uint64_t)&v48)
    && EVP_marshal_public_key((uint64_t)&v48, *(void *)(v10 + 8))
    && CBB_add_u16_length_prefixed((uint64_t *)v51, (uint64_t)&v45))
  {
    if ((*((_BYTE *)this + 1586) & 0x10) != 0)
    {
      unint64_t v17 = bssl::tls13_add_compressed_certificate(v9, (uint64_t)v53, (uint64_t)this, (uint64_t *)v52, a3, a4);
      goto LABEL_62;
    }

    goto LABEL_15;
  }

  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 611);
  int v18 = 0LL;
LABEL_70:
  CBB_cleanup((uint64_t)v53);
  return v18;
}

LABEL_75:
  if (*((void *)&v56 + 1))
  {
    while (1)
    {
      uint64_t v51 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
      unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
      if (!CBS_get_any_asn1_element(&v56, &v51, 0LL, 0LL) || !v52)
      {
        ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 708);
        goto LABEL_18;
      }

      v46[1] = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
      __int128 v23 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)&v51, a3);
      v46[1] = v23;
      if (!v23) {
        break;
      }
      __int128 v24 = *(unint64_t **)(v64 + 136);
      v46[1] = 0LL;
      uint64_t v50 = v23;
      if (!OPENSSL_sk_push(v24, (uint64_t)v23))
      {
        std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v50, 0LL);
        break;
      }

      uint64_t v50 = 0LL;
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v50, 0LL);
      std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](&v46[1], 0LL);
      if (!*((void *)&v56 + 1)) {
        goto LABEL_81;
      }
    }

    *a4 = 0LL;
    unint64_t v44 = &v46[1];
    goto LABEL_125;
  }

void sub_1875B675C(_Unwind_Exception *a1)
{
}

uint64_t bssl::SSL_SESSION_parse_bounded_octet_string( __int128 *a1, void *a2, _BYTE *a3, unsigned int a4, int a5)
{
  __int128 __src = (void *)0xAAAAAAAAAAAAAAAALL;
  size_t __n = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_octet_string(a1, &__src, 0LL, a5) && (char v8 = __n, __n <= a4))
  {
    if (__n) {
      memcpy(a2, __src, __n);
    }
    *a3 = v8;
    return 1LL;
  }

  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 485);
    return 0LL;
  }

uint64_t bssl::SSL_SESSION_parse_long(__int128 *a1, void *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_optional_asn1_uint64(a1, &v4, -1610612731, 0LL) || (v4 & 0x8000000000000000LL) != 0)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 499);
    return 0LL;
  }

  else
  {
    *a2 = v4;
    return 1LL;
  }

BOOL bssl::SSL_SESSION_parse_string(__int128 *a1, void **a2)
{
  if (!CBS_get_optional_asn1_octet_string(a1, &v8[1], v8, -1610612728))
  {
    int v3 = 422;
    goto LABEL_6;
  }

  if (!v8[0])
  {
    unint64_t v5 = a2;
    __int128 v6 = 0LL;
LABEL_10:
    std::unique_ptr<char,bssl::internal::Deleter>::reset[abi:ne180100](v5, v6);
    return 1LL;
  }

  if (CBS_contains_zero_byte((uint64_t)&v8[1]))
  {
    int v3 = 427;
LABEL_6:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", v3);
    return 0LL;
  }

  BOOL v7 = 0LL;
  BOOL result = CBS_strdup((uint64_t)&v8[1], &v7);
  if (result)
  {
    __int128 v6 = v7;
    unint64_t v5 = a2;
    goto LABEL_10;
  }

  return result;
}

uint64_t bssl::SSL_SESSION_parse_u32(__int128 *a1, _DWORD *a2, int a3, unsigned int a4)
{
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    *a2 = v7;
    return 1LL;
  }

  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 512);
    return 0LL;
  }

uint64_t bssl::SSL_SESSION_parse_octet_string(__int128 *a1, void **a2, int a3)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  size_t v9 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_octet_string(a1, &v8, 0LL, a3))
  {
    unint64_t v4 = (const void *)v8;
    size_t v5 = v9;
    uint64_t result = bssl::Array<unsigned char>::Init((uint64_t)a2, v9);
    if (v5) {
      BOOL v7 = (_DWORD)result == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7)
    {
      memmove(*a2, v4, v5);
      return 1LL;
    }
  }

  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 448);
    return 0LL;
  }

  return result;
}

BOOL bssl::SSL_SESSION_parse_crypto_buffer(__int128 *a1, unsigned int **a2, int a3, void **a4)
{
  if (!CBS_peek_asn1_tag(a1, a3)) {
    return 1LL;
  }
  memset(v10, 170, sizeof(v10));
  if (CBS_get_asn1(a1, &v10[1], a3)
    && CBS_get_asn1(&v10[1], v10, 4)
    && !*((void *)&v10[1] + 1))
  {
    unint64_t v8 = (unsigned int *)CRYPTO_BUFFER_new_from_CBS((uint64_t)v10, a4);
    std::unique_ptr<crypto_buffer_st,bssl::internal::Deleter>::reset[abi:ne180100](a2, v8);
    return *a2 != 0LL;
  }

  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 466);
    return 0LL;
  }

uint64_t bssl::SSL_SESSION_parse_u16(__int128 *a1, _WORD *a2, int a3)
{
  unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_optional_asn1_uint64(a1, &v5, a3, 0LL) && v5 < 0x10000)
  {
    *a2 = v5;
    return 1LL;
  }

  else
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 525);
    return 0LL;
  }

BOOL SSL_SESSION_to_bytes_for_ticket(uint64_t a1, void *a2, void *a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v6;
  __int128 v9[2] = v6;
  v9[0] = v6;
  CBB_zero(v9);
  BOOL v7 = CBB_init((uint64_t)v9, 0x100uLL)
  CBB_cleanup((uint64_t)v9);
  return v7;
}

void sub_1875B6CC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

SSL_SESSION *SSL_SESSION_from_bytes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&__int128 v7 = a1;
  *((void *)&v7 + 1) = a2;
  __int128 v6 = (SSL_SESSION *)0xAAAAAAAAAAAAAAAALL;
  bssl::SSL_SESSION_parse(&v7, *(uint64_t (***)(void))(a3 + 16), *(void ***)(a3 + 776), (unint64_t *)&v6);
  int v3 = v6;
  if (v6) {
    BOOL v4 = *((void *)&v7 + 1) == 0LL;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_asn1.cc", 873);
    __int128 v6 = 0LL;
    SSL_SESSION_free(v3);
    return 0LL;
  }

  return v3;
}

void sub_1875B6D68(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BIO_METHOD *BIO_s_socket(void)
{
  return (BIO_METHOD *)&methods_sockp;
}

ssize_t sock_write(uint64_t a1, const void *a2, int a3)
{
  ssize_t v6 = write(*(_DWORD *)(a1 + 32), a2, a3);
  BIO_clear_retry_flags(a1);
  return v6;
}

void *sock_read(uint64_t a1, void *a2, int a3)
{
  int v3 = a2;
  if (a2)
  {
    EVP_HPKE_KEY_cleanup(a1);
    int v3 = (void *)read(*(_DWORD *)(a1 + 32), v3, a3);
    BIO_clear_retry_flags(a1);
    if ((int)v3 <= 0)
    {
    }
  }

  return v3;
}

uint64_t sock_ctrl(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  if (a2 <= 10)
  {
    if (a2 == 8) {
      return (int)a1[5];
    }
    if (a2 != 9) {
      return 0LL;
    }
    a1[5] = a3;
    return 1LL;
  }

  if (a2 == 11) {
    return 1LL;
  }
  if (a2 != 105)
  {
    if (a2 == 104)
    {
      if (a1[5])
      {
        if (a1[4]) {
          close(a1[8]);
        }
        a1[4] = 0;
        a1[6] = 0;
      }

      a1[8] = *a4;
      uint64_t result = 1LL;
      a1[4] = 1;
      a1[5] = a3;
      return result;
    }

    return 0LL;
  }

  if (!a1[4]) {
    return -1LL;
  }
  if (a4) {
    *a4 = a1[8];
  }
  return (int)a1[8];
}

uint64_t sock_free(_DWORD *a1)
{
  if (a1[5])
  {
    if (a1[4]) {
      close(a1[8]);
    }
    a1[4] = 0;
    a1[6] = 0;
  }

  return 1LL;
}

unint64_t bn_mont_n0(unint64_t **a1)
{
  unint64_t v2 = **a1;
  if ((v2 & 1) == 0) {
    bn_mont_n0_cold_2();
  }
  unint64_t v3 = 0LL;
  uint64_t v4 = 64LL;
  uint64_t v5 = 1LL;
  do
  {
    uint64_t v6 = 1LL << v4;
    if ((v4 & 0x40) != 0) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = 1LL << v4;
    }
    if ((v4 & 0x40) == 0) {
      uint64_t v6 = 0LL;
    }
    uint64_t v9 = -(v5 & 1);
    uint64_t v5 = (v2 & v9 & v5) + ((v2 & v9 ^ v5) >> 1);
    unint64_t result = v9 & 0x8000000000000000LL | (v3 >> 1);
    unint64_t v3 = result;
    --v4;
  }

  while (v4);
  if (-(uint64_t)(result * v2) ^ 1 | (unint64_t)(v5
                                                      - (((result * (unsigned __int128)v2) >> 64)
                                                       + (result * v2 != 0))))
    bn_mont_n0_cold_3();
  return result;
}

uint64_t bn_mont_ctx_set_RR_consttime(BIGNUM *a1, BN_CTX *a2)
{
  uint64_t v4 = a1 + 1;
  unsigned int v5 = BN_num_bits(v4);
  if (v5 == 1)
  {
    BN_zero((uint64_t)a1);
    return bn_resize_words((uint64_t)a1, a1[1].top);
  }

  else
  {
    unsigned int v6 = v5;
    if (!v5) {
      bn_mont_ctx_set_RR_consttime_cold_4();
    }
    int top = a1[1].top;
    if (top << 6 < v5) {
      bn_mont_ctx_set_RR_consttime_cold_2();
    }
    if (BN_set_bit(a1, v5 - 1) && bn_mod_lshift_consttime(a1, a1, top - v6 + (top << 6) + 1, (uint64_t)v4, a2))
    {
      if (top != a1[1].top) {
        bn_mont_ctx_set_RR_consttime_cold_3();
      }
      int v8 = 6;
      while (BN_mod_mul_montgomery(a1, a1, a1, (BN_MONT_CTX *)a1, a2))
      {
        if (!--v8) {
          return bn_resize_words((uint64_t)a1, a1[1].top);
        }
      }
    }

    return 0LL;
  }

int RSA_padding_add_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  if (*(void *)&tlen <= 0xAuLL)
  {
    int v4 = 126;
    int v5 = 78;
LABEL_5:
    ERR_put_error(4, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v5);
    return 0;
  }

  size_t v6 = *(void *)&fl;
  uint64_t v7 = *(void *)&tlen;
  if ((unint64_t)(*(void *)&tlen - 11LL) < *(void *)&fl)
  {
    int v4 = 118;
    int v5 = 83;
    goto LABEL_5;
  }

  *(_WORD *)to = 256;
  if (*(void *)&tlen - 3LL != *(void *)&fl) {
    memset(to + 2, 255, *(void *)&tlen - 3LL - *(void *)&fl);
  }
  to[~v6 + v7] = 0;
  if (v6) {
    memcpy(&to[v7 - v6], f, v6);
  }
  return 1;
}

int RSA_padding_check_PKCS1_type_1( unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  if (*(void *)&rsa_len <= 1uLL)
  {
    int v5 = 116;
    int v6 = 101;
LABEL_11:
    ERR_put_error(4, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v6);
    return 0;
  }

  if (**(_BYTE **)&fl || *(_BYTE *)(*(void *)&fl + 1LL) != 1)
  {
    int v5 = 107;
    int v6 = 107;
    goto LABEL_11;
  }

  if (*(void *)&rsa_len < 3uLL) {
    goto LABEL_14;
  }
  uint64_t v7 = *(size_t **)&tlen;
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void *)&rsa_len - 2LL;
  while (*(unsigned __int8 *)(*(void *)&fl + v8 + 2) == 255)
  {
    if (v9 == ++v8) {
      goto LABEL_14;
    }
  }

  if (*(_BYTE *)(*(void *)&fl + v8 + 2))
  {
    int v5 = 102;
    int v6 = 119;
    goto LABEL_11;
  }

  if (v9 == v8)
  {
LABEL_14:
    int v5 = 131;
    int v6 = 125;
    goto LABEL_11;
  }

  if ((unint64_t)(v8 + 2) <= 9)
  {
    int v5 = 103;
    int v6 = 130;
    goto LABEL_11;
  }

  size_t v11 = *(void *)&rsa_len - v8 - 3;
  if (v11 > (unint64_t)f)
  {
    int v5 = 113;
    int v6 = 138;
    goto LABEL_11;
  }

  if (*(void *)&rsa_len - 3LL != v8) {
    memcpy(to, (const void *)(*(void *)&fl + v8 + 3), v11);
  }
  size_t *v7 = v11;
  return 1;
}

int RSA_padding_add_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  if (*(void *)&fl > *(void *)&tlen)
  {
    int v4 = 114;
    int v5 = 150;
LABEL_5:
    ERR_put_error(4, 0, v4, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v5);
    return 0;
  }

  if (*(void *)&fl < *(void *)&tlen)
  {
    int v4 = 116;
    int v5 = 155;
    goto LABEL_5;
  }

  if (*(void *)&fl) {
    memcpy(to, f, *(size_t *)&fl);
  }
  return 1;
}

uint64_t RSA_padding_add_PKCS1_PSS_mgf1( const RSA *a1, unsigned __int8 *a2, const void *a3, EVP_MD *md, const EVP_MD *a5, unsigned int a6)
{
  if (a5) {
    size_t v11 = a5;
  }
  else {
    size_t v11 = md;
  }
  size_t v12 = EVP_MD_size(md);
  if (BN_is_zero(a1->version))
  {
    int v13 = 120;
    int v14 = 329;
LABEL_38:
    ERR_put_error(4, 0, v13, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/rsa/padding.c", v14);
    uint64_t v29 = 0LL;
    __int128 v21 = 0LL;
    goto LABEL_39;
  }

  int v15 = (BN_num_bits((const BIGNUM *)a1->version) - 1) & 7;
  unsigned int v16 = RSA_size(a1);
  unint64_t v17 = v16;
  if (!v15)
  {
    if (!v16) {
      RSA_padding_add_PKCS1_PSS_mgf1_cold_1();
    }
    *a2++ = 0;
    unint64_t v17 = v16 - 1LL;
  }

  if (v17 < v12 + 2)
  {
    int v13 = 114;
    int v14 = 342;
    goto LABEL_38;
  }

  unint64_t v18 = v12;
  if (a6 != -1)
  {
    if (a6 == -2)
    {
      unint64_t v18 = v17 - v12 - 2;
    }

    else
    {
      if ((a6 & 0x80000000) != 0)
      {
        int v13 = 138;
        int v14 = 356;
        goto LABEL_38;
      }

      unint64_t v18 = a6;
    }
  }

  unint64_t v19 = v17 - v12;
  if (v17 - v12 - 2 < v18)
  {
    int v13 = 114;
    int v14 = 363;
    goto LABEL_38;
  }

  if (v18)
  {
    __int128 v20 = (unsigned __int8 *)OPENSSL_malloc(v18);
    __int128 v21 = v20;
    if (!v20 || !RAND_bytes(v20, v18)) {
      goto LABEL_36;
    }
  }

  else
  {
    __int128 v21 = 0LL;
  }

  *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v31.digest = v22;
  *(_OWORD *)&v31.flagunsigned int s = v22;
  EVP_MD_CTX_init(&v31);
  if (!EVP_DigestInit_ex(&v31, md, 0LL)
    || !EVP_DigestUpdate(&v31, &kPSSZeroes, 8uLL)
    || !EVP_DigestUpdate(&v31, a3, v12)
    || !EVP_DigestUpdate(&v31, v21, v18))
  {
    EVP_MD_CTX_cleanup(&v31);
LABEL_36:
    uint64_t v29 = 0LL;
    goto LABEL_39;
  }

  uint64_t v23 = v19 - 1;
  __int128 v24 = &a2[v19 - 1];
  int v25 = EVP_DigestFinal_ex(&v31, v24, 0LL);
  EVP_MD_CTX_cleanup(&v31);
  if (!v25 || !PKCS1_MGF1(a2, v23, v24, v12, v11)) {
    goto LABEL_36;
  }
  a2[v17 - (v12 + v18) - 2] ^= 1u;
  if (v18)
  {
    char v26 = &a2[v17 + ~(v12 + v18)];
    char v27 = v21;
    do
    {
      char v28 = *v27++;
      *v26++ ^= v28;
      --v18;
    }

    while (v18);
  }

  if (v15) {
    *a2 &= 0xFFu >> (8 - v15);
  }
  a2[v17 - 1] = -68;
  uint64_t v29 = 1LL;
LABEL_39:
  OPENSSL_free(v21);
  return v29;
}

uint64_t EVP_marshal_public_key(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    unint64_t v3 = *(uint64_t (**)(void))(v2 + 32);
    if (v3) {
      return v3();
    }
  }

  ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 147);
  return 0LL;
}

EVP_PKEY *EVP_parse_private_key(__int128 *a1)
{
  if (!CBS_get_asn1(a1, &v10[1], 536870928)
    || !CBS_get_asn1_uint64(&v10[1], v9)
    || v9[0]
    || !CBS_get_asn1(&v10[1], v10, 536870928)
    || !CBS_get_asn1(&v10[1], &v9[1], 4))
  {
    int v6 = 102;
    int v7 = 163;
LABEL_12:
    ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", v7);
    return 0LL;
  }

  uint64_t v1 = parse_key_type(v10);
  if (!v1)
  {
    int v6 = 128;
    int v7 = 168;
    goto LABEL_12;
  }

  uint64_t v2 = v1;
  unint64_t v3 = EVP_PKEY_new();
  int v4 = v3;
  if (!v3)
  {
LABEL_17:
    EVP_PKEY_free(v4);
    return 0LL;
  }

  evp_pkey_set_method((uint64_t)v3, v2);
  int v5 = (unsigned int (*)(EVP_PKEY *, __int128 *, unint64_t *))*((void *)v4->pkey.ptr + 6);
  if (!v5)
  {
    ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 183);
    goto LABEL_17;
  }

  if (!v5(v4, v10, &v9[1])) {
    goto LABEL_17;
  }
  return v4;
}

uint64_t EVP_marshal_private_key(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    unint64_t v3 = *(uint64_t (**)(void))(v2 + 56);
    if (v3) {
      return v3();
    }
  }

  ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 199);
  return 0LL;
}

EVP_PKEY *__cdecl d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  if (length < 0)
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 250);
    return 0LL;
  }

  *(void *)&__int128 v15 = *pp;
  *((void *)&v15 + 1) = length;
  uint64_t v8 = EVP_PKEY_new();
  if (v8)
  {
    uint64_t v9 = v8;
    switch(type)
    {
      case 6:
        size_t v11 = RSA_parse_private_key(&v15);
        RSA_free(v11);
        break;
      case 116:
        size_t v12 = DSA_parse_private_key(&v15);
        DSA_free(v12);
        break;
      case 408:
        __int128 v10 = EC_KEY_parse_private_key(&v15, 0LL);
        EC_KEY_free(v10);
        break;
      default:
        ERR_put_error(6, 0, 127, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 238);
        break;
    }

    EVP_PKEY_free(v9);
  }

  ERR_clear_error();
  *(void *)&__int128 v15 = *pp;
  *((void *)&v15 + 1) = length;
  int v13 = EVP_parse_private_key(&v15);
  uint64_t v9 = v13;
  if (!v13) {
    return v9;
  }
  if (v13->save_type != type)
  {
    ERR_put_error(6, 0, 103, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/evp_asn1.c", 267);
    EVP_PKEY_free(v9);
    return 0LL;
  }

LABEL_20:
  if (a)
  {
    EVP_PKEY_free(*a);
    BIGNUM *a = v9;
  }

  *pp = (const unsigned __int8 *)v15;
  return v9;
}

  ERR_put_error(16, 0, v9, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/encrypted_client_hello.cc", v10);
  return 0LL;
}

DSA *dsa_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8))
  {
    int v6 = DSA_parse_parameters((__int128 *)a2);
    if (!v6 || *(void *)(a2 + 8))
    {
      int v7 = 81;
LABEL_10:
      ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", v7);
      goto LABEL_11;
    }
  }

  else
  {
    unint64_t result = DSA_new();
    int v6 = result;
    if (!result) {
      return result;
    }
  }

  uint64_t v9 = BN_new();
  v6->p = v9;
  if (v9)
  {
    if (BN_parse_asn1_unsigned((__int128 *)a3, v9) && !*(void *)(a3 + 8))
    {
      evp_pkey_set_method(a1, &dsa_asn1_meth);
      *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v6;
      return (DSA *)1;
    }

    int v7 = 93;
    goto LABEL_10;
  }

uint64_t dsa_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = *(void *)v3 && *(void *)(v3 + 8) && *(void *)(v3 + 16) != 0LL;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v5;
  __int128 v10[2] = v5;
  v10[0] = v5;
  v9[1] = v5;
  __int128 v9[2] = v5;
  _OWORD v8[2] = v5;
  v9[0] = v5;
  v8[0] = v5;
  v8[1] = v5;
  v7[1] = v5;
  unint64_t v7[2] = v5;
  v7[0] = v5;
  if (CBB_add_asn1(a1, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 6u)
    && CBB_add_bytes((uint64_t)v8, &unk_18A070F7C, 7uLL)
    && (!v4 || DSA_marshal_parameters((uint64_t *)v9, (const BIGNUM **)v3))
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v7, 3u)
    && CBB_add_u8((uint64_t)v7, 0)
    && BN_marshal_asn1((uint64_t *)v7, *(const BIGNUM **)(v3 + 24))
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", 121);
  return 0LL;
}

BOOL dsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = (const BIGNUM *)DSA_get0_pub_key(*(void *)(a2 + 8));
  BOOL v4 = (const BIGNUM *)DSA_get0_pub_key(v2);
  return BN_cmp(v3, v4) == 0;
}

uint64_t dsa_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = DSA_parse_parameters((__int128 *)a2);
  if (!v6 || *(void *)(a2 + 8))
  {
    int v7 = 135;
LABEL_4:
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", v7);
LABEL_5:
    uint64_t v8 = 0LL;
LABEL_6:
    BN_CTX_free(v8);
    DSA_free(v6);
    return 0LL;
  }

  __int128 v10 = BN_new();
  v6->q = v10;
  if (!v10) {
    goto LABEL_5;
  }
  if (!BN_parse_asn1_unsigned((__int128 *)a3, v10) || *(void *)(a3 + 8))
  {
    int v7 = 145;
    goto LABEL_4;
  }

  if (!dsa_check_key((uint64_t *)&v6->pad))
  {
    int v7 = 153;
    goto LABEL_4;
  }

  uint64_t v8 = BN_CTX_new();
  size_t v11 = BN_new();
  v6->p = v11;
  if (!v8
    || !v11
    || !BN_mod_exp_mont_consttime(v11, *(const BIGNUM **)&v6->write_params, v6->q, *(const BIGNUM **)&v6->pad, v8, 0LL))
  {
    goto LABEL_6;
  }

  BN_CTX_free(v8);
  evp_pkey_set_method(a1, &dsa_asn1_meth);
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v6;
  return 1LL;
}

uint64_t dsa_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(const BIGNUM ***)(a2 + 8);
  if (v2 && v2[4])
  {
    *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v11[1] = v4;
    unint64_t v11[2] = v4;
    v11[0] = v4;
    v10[1] = v4;
    __int128 v10[2] = v4;
    __int128 v9[2] = v4;
    v10[0] = v4;
    v9[0] = v4;
    v9[1] = v4;
    v8[1] = v4;
    _OWORD v8[2] = v4;
    v8[0] = v4;
    if (CBB_add_asn1(a1, (uint64_t)v11, 0x20000010u)
      && CBB_add_asn1_uint64((uint64_t)v11, 0LL)
      && CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 0x20000010u)
      && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 6u)
      && CBB_add_bytes((uint64_t)v9, &unk_18A070F7C, 7uLL)
      && DSA_marshal_parameters((uint64_t *)v10, v2)
      && CBB_add_asn1((uint64_t *)v11, (uint64_t)v8, 4u)
      && BN_marshal_asn1((uint64_t *)v8, v2[4])
      && CBB_flush(a1))
    {
      return 1LL;
    }

    int v6 = 105;
    int v7 = 194;
  }

  else
  {
    int v6 = 118;
    int v7 = 179;
  }

  ERR_put_error(6, 0, v6, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_dsa_asn1.c", v7);
  return 0LL;
}

uint64_t int_dsa_size(uint64_t a1)
{
  return DSA_size(*(const DSA **)(a1 + 8));
}

uint64_t dsa_bits(uint64_t a1)
{
  uint64_t v1 = (const BIGNUM *)EVP_AEAD_CTX_aead(*(void *)(a1 + 8));
  return BN_num_bits(v1);
}

BOOL dsa_missing_parameters(uint64_t a1)
{
  uint64_t v1 = *(const EC_KEY **)(a1 + 8);
  return !EVP_AEAD_CTX_aead((uint64_t)v1) || !EVP_HPKE_CTX_aead((uint64_t)v1) || EVP_HPKE_CTX_kdf(v1) == 0LL;
}

uint64_t dsa_copy_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(BIGNUM ***)(a1 + 8);
  uint64_t v3 = *(BIGNUM ***)(a2 + 8);
  else {
    return 0LL;
  }
}

BOOL dsa_cmp_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const EC_KEY **)(a1 + 8);
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  __int128 v4 = (const BIGNUM *)EVP_AEAD_CTX_aead((uint64_t)v2);
  __int128 v5 = (const BIGNUM *)EVP_AEAD_CTX_aead((uint64_t)v3);
  if (BN_cmp(v4, v5)) {
    return 0LL;
  }
  int v6 = (const BIGNUM *)EVP_HPKE_CTX_aead((uint64_t)v2);
  int v7 = (const BIGNUM *)EVP_HPKE_CTX_aead((uint64_t)v3);
  if (BN_cmp(v6, v7)) {
    return 0LL;
  }
  uint64_t v9 = EVP_HPKE_CTX_kdf(v2);
  __int128 v10 = EVP_HPKE_CTX_kdf(v3);
  return BN_cmp(v9, v10) == 0;
}

void int_dsa_free(uint64_t a1)
{
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 0LL;
}

BOOL EVP_PKEY_assign_DSA(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = a2;
  return a2 != 0;
}

uint64_t dup_bn_into(BIGNUM **a1, BIGNUM *a)
{
  uint64_t result = (uint64_t)BN_dup(a);
  if (result)
  {
    uint64_t v4 = result;
    BN_free(*a1);
    *a1 = (BIGNUM *)v4;
    return 1LL;
  }

  return result;
}

const EVP_CIPHER *EVP_aes_128_cbc(void)
{
  return (const EVP_CIPHER *)&aes_128_cbc;
}

const EVP_CIPHER *EVP_aes_256_cbc(void)
{
  return (const EVP_CIPHER *)&aes_256_cbc;
}

void *EVP_aead_aes_128_gcm()
{
  return &aead_aes_128_gcm;
}

void *EVP_aead_aes_256_gcm()
{
  return &aead_aes_256_gcm;
}

void *EVP_aead_aes_128_gcm_tls12()
{
  return &aead_aes_128_gcm;
}

void *EVP_aead_aes_256_gcm_tls12()
{
  return &aead_aes_256_gcm;
}

int *EVP_aead_aes_128_gcm_tls13()
{
  return &EVP_aead_aes_128_gcm_tls13_storage;
}

double EVP_aead_aes_128_gcm_tls13_init()
{
  unk_18C4C4D60 = 0u;
  xmmword_18C4C4D70 = 0u;
  unk_18C4C4D90 = 0u;
  *(void *)&double result = 269487120LL;
  EVP_aead_aes_128_gcm_tls13_storage = 269487120;
  dword_18C4C4D5C = 1;
  qword_18C4C4D68 = (uint64_t)aead_aes_gcm_init_with_dir;
  *(void *)&xmmword_18C4C4D70 = aead_aes_gcm_cleanup;
  qword_18C4C4D80 = (uint64_t)aead_aes_gcm_tls13_seal_scatter;
  unk_18C4C4D88 = aead_aes_gcm_open_gather;
  return result;
}

double EVP_aead_aes_256_gcm_tls13_init()
{
  *(_OWORD *)algn_18C4C4DA8 = 0u;
  xmmword_18C4C4DB8 = 0u;
  unk_18C4C4DD8 = 0u;
  *(void *)&double result = 269487136LL;
  EVP_aead_aes_256_gcm_tls13_storage = 269487136;
  dword_18C4C4DA4 = 1;
  qword_18C4C4DB0 = (uint64_t)aead_aes_gcm_init_with_dir;
  *(void *)&xmmword_18C4C4DB8 = aead_aes_gcm_cleanup;
  qword_18C4C4DC8 = (uint64_t)aead_aes_gcm_tls13_seal_scatter;
  unk_18C4C4DD0 = aead_aes_gcm_open_gather;
  return result;
}

uint64_t aes_init_key(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(*(void *)a1 + 20LL) & 0x3F;
  switch(v4)
  {
    case 1:
      if (!g_boringssl_log) {
        goto LABEL_25;
      }
      uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_3();
        goto LABEL_25;
      }

      break;
    case 2:
      if (a4) {
        uint64_t v8 = (void *)ccaes_cbc_encrypt_mode();
      }
      else {
        uint64_t v8 = (void *)ccaes_cbc_decrypt_mode();
      }
      uint64_t v9 = v8;
      uint64_t result = (uint64_t)malloc(((v8[1] + ((*v8 + 15LL) & 0xFFFFFFFFFFFFFFF0LL) + 15) & 0xFFFFFFFFFFFFFFF0LL) + 16);
      if (result)
      {
        __int128 v10 = (void *)result;
        *(void *)uint64_t result = v9;
        if (cccbc_init() || cccbc_set_iv())
        {
          free(v10);
          goto LABEL_25;
        }

        *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v10;
        uint64_t result = 1LL;
      }

      break;
    case 3:
      if (!g_boringssl_log) {
        goto LABEL_25;
      }
      uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_4();
        goto LABEL_25;
      }

      break;
    case 4:
      if (!g_boringssl_log) {
        goto LABEL_25;
      }
      uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_5();
        goto LABEL_25;
      }

      break;
    case 5:
      if (!g_boringssl_log) {
        goto LABEL_25;
      }
      uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        aes_init_key_cold_2();
        goto LABEL_25;
      }

      break;
    default:
      int v6 = (os_log_s *)g_boringssl_log;
      if (g_boringssl_log)
      {
        uint64_t result = os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result) {
          return result;
        }
        aes_init_key_cold_1(v4, v6);
      }

uint64_t aes_cipher(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((*(_BYTE *)(*a1 + 20LL) & 2) == 0) {
    return 0LL;
  }
  uint64_t v5 = a1[1];
  if (!v5 || !*(void *)v5) {
    return 0xFFFFFFFFLL;
  }
  if (a4 && (!a2 || !a3)) {
    aes_cipher_cold_1();
  }
  if (a4 % *(void *)(*(void *)v5 + 8LL)) {
    return 0xFFFFFFFFLL;
  }
  int v6 = (_OWORD *)((char *)a1 + 52);
  int v7 = cccbc_set_iv();
  _OWORD *v6 = *(_OWORD *)(v5 + ((**(void **)v5 + 15LL) & 0xFFFFFFFFFFFFFFF0LL) + 16);
  return 1LL;
}

void aes_cleanup(void *a1)
{
  if ((*(_BYTE *)(*a1 + 20LL) & 2) != 0)
  {
    uint64_t v2 = (void *)a1[1];
    if (v2)
    {
      cc_clear();
      free(v2);
    }
  }

  a1[1] = 0LL;
}

uint64_t pkey_ec_init(uint64_t a1)
{
  uint64_t result = (uint64_t)OPENSSL_zalloc(0x10uLL);
  if (result)
  {
    *(void *)(a1 + 40) = result;
    return 1LL;
  }

  return result;
}

uint64_t pkey_ec_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)OPENSSL_zalloc(0x10uLL);
  if (result)
  {
    *(void *)(a1 + 40) = result;
    *(_OWORD *)uint64_t result = *(_OWORD *)*(void *)(a2 + 40);
    return 1LL;
  }

  return result;
}

void pkey_ec_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  if (v1) {
    OPENSSL_free(v1);
  }
}

uint64_t pkey_ec_keygen(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const EC_GROUP **)(*(void *)(a1 + 40) + 8LL);
  if (!v3)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (!v4)
    {
      ERR_put_error(6, 0, 124, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 212);
      return 0LL;
    }

    uint64_t v3 = EC_KEY_get0_group(*(const EC_KEY **)(v4 + 8));
  }

  uint64_t v5 = EC_KEY_new();
  int v6 = v5;
  if (v5 && EC_KEY_set_group(v5, v3) && EC_KEY_generate_key(v6))
  {
    EVP_PKEY_assign_EC_KEY(a2, (uint64_t)v6);
    return 1LL;
  }

  EC_KEY_free(v6);
  return 0LL;
}

uint64_t pkey_ec_sign( uint64_t a1, unsigned __int8 *a2, unint64_t *a3, const unsigned __int8 *a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 16);
  int v7 = *(EC_KEY **)(v6 + 8);
  if (!a2)
  {
    *a3 = ECDSA_size(*(const EC_KEY **)(v6 + 8));
    return 1LL;
  }

  unint64_t v11 = *a3;
  if (v11 < ECDSA_size(*(const EC_KEY **)(v6 + 8)))
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 120);
    return 0LL;
  }

  sigleuint64_t n = -1431655766;
  uint64_t result = ECDSA_sign(0, a4, a5, a2, &siglen, v7);
  if ((_DWORD)result)
  {
    *a3 = siglen;
    return 1LL;
  }

  return result;
}

uint64_t pkey_ec_verify(uint64_t a1, unsigned __int8 *sig, int siglen, unsigned __int8 *dgst, int dgstlen)
{
  return ECDSA_verify(0, dgst, dgstlen, sig, siglen, *(EC_KEY **)(*(void *)(a1 + 16) + 8LL));
}

uint64_t pkey_ec_derive(uint64_t a1, void *a2, size_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 24)) == 0)
  {
    ERR_put_error(6, 0, 117, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 141);
    return 0LL;
  }

  int v7 = *(EC_KEY **)(v3 + 8);
  if (!a2)
  {
    size_t v12 = EC_KEY_get0_group(*(const EC_KEY **)(v3 + 8));
    size_t v10 = (EC_GROUP_get_degree(v12) + 7) >> 3;
    goto LABEL_9;
  }

  uint64_t v8 = EC_KEY_get0_public_key(*(const EC_KEY **)(v4 + 8));
  unsigned int v9 = ECDH_compute_key(a2, *a3, v8, v7, 0LL);
  if ((v9 & 0x80000000) != 0) {
    return 0LL;
  }
  size_t v10 = v9;
LABEL_9:
  *a3 = v10;
  return 1LL;
}

uint64_t pkey_ec_paramgen(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 8))
  {
    uint64_t v4 = EC_KEY_new();
    uint64_t v5 = v4;
    if (v4 && EC_KEY_set_group(v4, *(const EC_GROUP **)(v2 + 8)))
    {
      EVP_PKEY_assign_EC_KEY(a2, (uint64_t)v5);
      return 1LL;
    }

    EC_KEY_free(v5);
  }

  else
  {
    ERR_put_error(6, 0, 124, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec.c", 231);
  }

  return 0LL;
}

uint64_t pkey_ec_ctrl(uint64_t a1, int a2, int nid, EVP_MD *md)
{
  uint64_t v4 = *(void **)(a1 + 40);
  if (a2 <= 2)
  {
    if (a2 == 1)
    {
      int v7 = EVP_MD_type(md);
      if ((v7 - 672) < 4 || v7 == 64)
      {
        void *v4 = md;
        return 1LL;
      }

      int v8 = 111;
      int v9 = 177;
      goto LABEL_13;
    }

    if (a2 == 2)
    {
      *(void *)&md->int type = *v4;
      return 1LL;
    }

uint64_t EVP_MD_nid(unsigned int *a1)
{
  return *a1;
}

int EVP_MD_block_size(const EVP_MD *md)
{
  return (int)md->final;
}

double EVP_MD_CTX_new()
{
  os_log_t v0 = OPENSSL_malloc(0x20uLL);
  if (v0)
  {
    double result = 0.0;
    _OWORD *v0 = 0u;
    v0[1] = 0u;
  }

  return result;
}

void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)
{
  if (ctx)
  {
    EVP_MD_CTX_cleanup(ctx);
    OPENSSL_free(ctx);
  }

double EVP_MD_CTX_move(uint64_t a1, _OWORD *a2)
{
  __int128 v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  double result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  return 1;
}

uint64_t eckey_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = EC_KEY_parse_curve_name((__int128 *)a2);
  if (!v6 || *(void *)(a2 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 99);
    int v7 = 0LL;
LABEL_4:
    EC_KEY_free(v7);
    return 0LL;
  }

  int v9 = (const EC_GROUP *)v6;
  size_t v10 = EC_KEY_new();
  int v7 = v10;
  if (!v10
    || !EC_KEY_set_group(v10, v9)
    || !EC_KEY_oct2key(v7, *(const unsigned __int8 **)a3, *(void *)(a3 + 8), 0LL))
  {
    goto LABEL_4;
  }

  evp_pkey_set_method(a1, &ec_asn1_meth);
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v7;
  return 1LL;
}

uint64_t eckey_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  __int128 v4 = EC_KEY_get0_group(v3);
  uint64_t v5 = EC_KEY_get0_public_key(v3);
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v6;
  unint64_t v11[2] = v6;
  v11[0] = v6;
  v10[1] = v6;
  __int128 v10[2] = v6;
  __int128 v9[2] = v6;
  v10[0] = v6;
  v9[0] = v6;
  v9[1] = v6;
  v8[1] = v6;
  _OWORD v8[2] = v6;
  v8[0] = v6;
  if (CBB_add_asn1(a1, (uint64_t)v11, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 6u)
    && CBB_add_bytes((uint64_t)v9, &unk_18A07119C, 7uLL)
    && EC_KEY_marshal_curve_name((uint64_t *)v10, (uint64_t)v4)
    && CBB_add_asn1((uint64_t *)v11, (uint64_t)v8, 3u)
    && CBB_add_u8((uint64_t)v8, 0)
    && EC_POINT_point2cbb((uint64_t)v8, v4, v5, POINT_CONVERSION_UNCOMPRESSED, 0LL)
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 85);
  return 0LL;
}

uint64_t eckey_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const EC_KEY **)(a1 + 8);
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  __int128 v4 = EC_KEY_get0_group(v3);
  uint64_t v5 = EC_KEY_get0_public_key(v2);
  __int128 v6 = EC_KEY_get0_public_key(v3);
  int v7 = EC_POINT_cmp(v4, v5, v6, 0LL);
  if (v7 == 1) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = -2;
  }
  if (v7) {
    return v8;
  }
  else {
    return 1LL;
  }
}

uint64_t eckey_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v6 = (const EC_GROUP *)EC_KEY_parse_parameters((__int128 *)a2);
  if (!v6 || *(void *)(a2 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 138);
    return 0LL;
  }

  unsigned int v8 = EC_KEY_parse_private_key((__int128 *)a3, v6);
  if (!v8 || *(void *)(a3 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 144);
    EC_KEY_free(v8);
    return 0LL;
  }

  evp_pkey_set_method(a1, &ec_asn1_meth);
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v8;
  return 1LL;
}

uint64_t eckey_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  enc_flagunsigned int s = EC_KEY_get_enc_flags(v3);
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v5;
  unint64_t v11[2] = v5;
  v11[0] = v5;
  v10[1] = v5;
  __int128 v10[2] = v5;
  __int128 v9[2] = v5;
  v10[0] = v5;
  v9[0] = v5;
  v9[1] = v5;
  v8[1] = v5;
  _OWORD v8[2] = v5;
  v8[0] = v5;
  if (CBB_add_asn1(a1, (uint64_t)v11, 0x20000010u))
  {
    if (CBB_add_asn1_uint64((uint64_t)v11, 0LL))
    {
      if (CBB_add_asn1((uint64_t *)v11, (uint64_t)v10, 0x20000010u))
      {
        if (CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 6u))
        {
          if (CBB_add_bytes((uint64_t)v9, &unk_18A07119C, 7uLL))
          {
            __int128 v6 = EC_KEY_get0_group(v3);
            if (EC_KEY_marshal_curve_name((uint64_t *)v10, (uint64_t)v6))
            {
              if (CBB_add_asn1((uint64_t *)v11, (uint64_t)v8, 4u)
                && EC_KEY_marshal_private_key((uint64_t *)v8, (uint64_t)v3, enc_flags | 1u)
                && CBB_flush(a1))
              {
                return 1LL;
              }
            }
          }
        }
      }
    }
  }

  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 173);
  return 0LL;
}

uint64_t eckey_set1_tls_encodedpoint(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  uint64_t v3 = *(EC_KEY **)(a1 + 8);
  if (v3) {
    return EC_KEY_oct2key(v3, a2, a3, 0LL);
  }
  ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 184);
  return 0LL;
}

unsigned __int8 *eckey_get1_tls_encodedpoint( uint64_t a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  __int128 v6 = *(const EC_GROUP ***)(a1 + 8);
  if (v6) {
    return EC_KEY_key2buf(v6, POINT_CONVERSION_UNCOMPRESSED, a2, 0LL, a5, a6);
  }
  ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 195);
  return 0LL;
}

uint64_t eckey_opaque(uint64_t a1)
{
  return EC_KEY_is_opaque(*(void *)(a1 + 8));
}

uint64_t int_ec_size(uint64_t a1)
{
  return ECDSA_size(*(const EC_KEY **)(a1 + 8));
}

uint64_t ec_bits(uint64_t a1)
{
  uint64_t v1 = EC_KEY_get0_group(*(const EC_KEY **)(a1 + 8));
  if (v1) {
    return EC_GROUP_order_bits((uint64_t)v1);
  }
  ERR_clear_error();
  return 0LL;
}

BOOL ec_missing_parameters(uint64_t a1)
{
  uint64_t v1 = *(const EC_KEY **)(a1 + 8);
  return !v1 || EC_KEY_get0_group(v1) == 0LL;
}

uint64_t ec_copy_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  if (!v3)
  {
    int v8 = 120;
    int v9 = 225;
LABEL_8:
    ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", v9);
    return 0LL;
  }

  __int128 v4 = EC_KEY_get0_group(v3);
  if (!v4)
  {
    int v8 = 118;
    int v9 = 230;
    goto LABEL_8;
  }

  __int128 v5 = v4;
  __int128 v6 = *(EC_KEY **)(a1 + 8);
  if (v6) {
    return EC_KEY_set_group(v6, v5);
  }
  __int128 v6 = EC_KEY_new();
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v6;
  if (v6) {
    return EC_KEY_set_group(v6, v5);
  }
  return 0LL;
}

uint64_t ec_cmp_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const EC_KEY **)(a1 + 8);
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  if (v2) {
    BOOL v4 = v3 == 0LL;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 4294967294LL;
  }
  __int128 v5 = EC_KEY_get0_group(v2);
  __int128 v6 = EC_KEY_get0_group(v3);
  if (!v5 || v6 == 0LL) {
    return 4294967294LL;
  }
  else {
    return EC_GROUP_cmp(v5, v6, 0LL) == 0;
  }
}

void int_ec_free(uint64_t a1)
{
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 0LL;
}

BOOL EVP_PKEY_assign_EC_KEY(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = a2;
  return a2 != 0;
}

uint64_t EVP_PKEY_get0_EC_KEY(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 408) {
    return *(void *)(a1 + 8);
  }
  ERR_put_error(6, 0, 106, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_ec_asn1.c", 320);
  return 0LL;
}

uint64_t bssl::tls13_client_handshake_int_state(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return (4 * *((_DWORD *)this + 6)) | 0x2B291400u;
}

uint64_t bssl::close_early_data(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 1584);
  if ((v2 & 0x400) == 0) {
    bssl::close_early_data();
  }
  uint64_t v4 = *(void *)a1;
  *(_DWORD *)(a1 + 1bssl::Array<unsigned short>::~Array((uint64_t)this + 584) = v2 & 0xFFFFDFFF;
  if (*(void *)(v4 + 168)) {
    goto LABEL_3;
  }
  if (!a2)
  {
    size_t v10 = (bssl::SSLAEADContext *)0xAAAAAAAAAAAAAAAALL;
    BOOL v6 = SSL_is_dtls((unsigned __int8 **)v4) != 0;
    bssl::SSLAEADContext::CreateNullCipher((bssl::SSLAEADContext *)v6, &v10);
    if (!v10
      || (int v7 = *(uint64_t (**)(uint64_t, void, bssl::SSLAEADContext **, void, void))(*(void *)v4 + 144LL),
          int v9 = v10,
          size_t v10 = 0LL,
          char v8 = v7(v4, 0LL, &v9, 0LL, 0LL),
          std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v9, 0LL),
          (v8 & 1) == 0))
    {
      std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v10, 0LL);
      return 0LL;
    }

    bssl::SSLAEADContext::SetVersionIfNullCipher(*(void *)(*(void *)(v4 + 48) + 272LL), *(_WORD *)(v4 + 16));
    std::unique_ptr<bssl::SSLAEADContext,bssl::internal::Deleter>::reset[abi:ne180100](&v10, 0LL);
    goto LABEL_3;
  }

  if (a2 != 2) {
    bssl::close_early_data();
  }
  uint64_t result = bssl::tls13_set_traffic_key( v4,  (const ssl_session_st *)2,  1LL,  *(bssl **)(a1 + 1520),  (const void *)(a1 + 136),  *(void *)(a1 + 32));
  if ((_DWORD)result)
  {
LABEL_3:
    if (*(_DWORD *)(*(void *)(v4 + 48) + 204LL) != a2) {
      bssl::close_early_data();
    }
    return 1LL;
  }

  return result;
}

void sub_1875B92C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t rsa_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v4;
  __int128 v10[2] = v4;
  __int128 v9[2] = v4;
  v10[0] = v4;
  v9[0] = v4;
  v9[1] = v4;
  v8[1] = v4;
  _OWORD v8[2] = v4;
  unint64_t v7[2] = v4;
  v8[0] = v4;
  v7[0] = v4;
  v7[1] = v4;
  v6[1] = v4;
  void v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 6u)
    && CBB_add_bytes((uint64_t)v8, &unk_18A0712BC, 9uLL)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v7, 5u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v6, 3u)
    && CBB_add_u8((uint64_t)v6, 0)
    && RSA_marshal_public_key((uint64_t *)v6, v3)
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 82);
  return 0LL;
}

BOOL rsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  int v2 = *(const EC_KEY **)(a1 + 8);
  uint64_t v3 = *(const EC_KEY **)(a2 + 8);
  __int128 v4 = (const BIGNUM *)EVP_HPKE_CTX_aead((uint64_t)v3);
  __int128 v5 = (const BIGNUM *)EVP_HPKE_CTX_aead((uint64_t)v2);
  if (BN_cmp(v4, v5)) {
    return 0LL;
  }
  int v7 = EVP_HPKE_CTX_kdf(v3);
  char v8 = EVP_HPKE_CTX_kdf(v2);
  return BN_cmp(v7, v8) == 0;
}

uint64_t rsa_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_asn1((__int128 *)a2, &v8, 5) || v9 || *(void *)(a2 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 144);
  }

  else
  {
    int v7 = RSA_parse_private_key((__int128 *)a3);
    if (v7 && !*(void *)(a3 + 8))
    {
      evp_pkey_set_method(a1, &rsa_asn1_meth);
      *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v7;
      return 1LL;
    }

    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 150);
    RSA_free(v7);
  }

  return 0LL;
}

uint64_t rsa_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(const BIGNUM ***)(a2 + 8);
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v4;
  __int128 v10[2] = v4;
  __int128 v9[2] = v4;
  v10[0] = v4;
  v9[0] = v4;
  v9[1] = v4;
  v8[1] = v4;
  _OWORD v8[2] = v4;
  unint64_t v7[2] = v4;
  v8[0] = v4;
  v7[0] = v4;
  v7[1] = v4;
  v6[1] = v4;
  void v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v10, 0x20000010u)
    && CBB_add_asn1_uint64((uint64_t)v10, 0LL)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v8, 6u)
    && CBB_add_bytes((uint64_t)v8, &unk_18A0712BC, 9uLL)
    && CBB_add_asn1((uint64_t *)v9, (uint64_t)v7, 5u)
    && CBB_add_asn1((uint64_t *)v10, (uint64_t)v6, 4u)
    && RSA_marshal_private_key((uint64_t *)v6, v3)
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 131);
  return 0LL;
}

uint64_t rsa_opaque(uint64_t a1)
{
  return ssl_credential_st::UsesPrivateKey(*(ssl_credential_st **)(a1 + 8));
}

uint64_t int_rsa_size(uint64_t a1)
{
  return RSA_size(*(const RSA **)(a1 + 8));
}

uint64_t rsa_bits(uint64_t a1)
{
  return RSA_bits(*(void *)(a1 + 8));
}

int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, rsa_st *key)
{
  *(void *)&pkey->referenceunsigned int s = key;
  if (!key) {
    return 0;
  }
  RSA_up_ref(key);
  return 1;
}

uint64_t EVP_PKEY_get0_RSA(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 6) {
    return *(void *)(a1 + 8);
  }
  ERR_put_error(6, 0, 107, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/evp/p_rsa_asn1.c", 229);
  return 0LL;
}

BOOL PKCS5_PBKDF2_HMAC( const void *a1, int a2, const unsigned __int8 *a3, size_t a4, unsigned int a5, EVP_MD *md, size_t a7, char *a8)
{
  *(void *)&ctx.key[76] = *MEMORY[0x1895F89C0];
  size_t v16 = EVP_MD_size(md);
  ctx.o_ctx.md_unint64_t data = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.i_ctx.md_unint64_t data = v17;
  *(_OWORD *)&ctx.o_ctx.engine = v17;
  *(_OWORD *)&ctx.md_ctx.md_unint64_t data = v17;
  *(_OWORD *)&ctx.i_ctx.engine = v17;
  *(_OWORD *)&ctx.mint d = v17;
  *(_OWORD *)&ctx.md_ctx.engine = v17;
  HMAC_CTX_init(&ctx);
  HMAC_Init_ex(&ctx, a1, a2, md, 0LL);
  if (!v18)
  {
LABEL_24:
    BOOL v34 = 0LL;
    goto LABEL_25;
  }

  if (a7)
  {
    unsigned int v19 = 1;
    *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    do
    {
      *(_DWORD *)unint64_t data = bswap32(v19);
      size_t v21 = v16 >= a7 ? a7 : v16;
      *(_OWORD *)&ctx.key[36] = v20;
      *(_OWORD *)&ctx.key[52] = v20;
      *(_OWORD *)&ctx.key[20] = v20;
      *(_OWORD *)&ctx._OWORD key[4] = v20;
      HMAC_Init_ex(&ctx, 0LL, 0, 0LL, 0LL);
      if (!v22) {
        goto LABEL_24;
      }
      HMAC_Update(&ctx, a3, a4);
      if (!v23) {
        goto LABEL_24;
      }
      HMAC_Update(&ctx, data, 4uLL);
      if (!v24) {
        goto LABEL_24;
      }
      HMAC_Final(&ctx, &ctx.key[4], 0LL);
      if (!v25) {
        goto LABEL_24;
      }
      if (v21) {
        memcpy(a8, &ctx.key[4], v21);
      }
      if (a5 >= 2)
      {
        int v26 = 1;
        do
        {
          HMAC_Init_ex(&ctx, 0LL, 0, 0LL, 0LL);
          if (!v27) {
            goto LABEL_24;
          }
          HMAC_Update(&ctx, &ctx.key[4], v16);
          if (!v28) {
            goto LABEL_24;
          }
          HMAC_Final(&ctx, &ctx.key[4], 0LL);
          if (!v29) {
            goto LABEL_24;
          }
          if (v21)
          {
            unsigned __int128 v30 = &ctx.key[4];
            EVP_MD_CTX v31 = a8;
            size_t v32 = v21;
            do
            {
              char v33 = *v30++;
              *v31++ ^= v33;
              --v32;
            }

            while (v32);
          }
        }

        while (++v26 != a5);
      }

      a8 += v21;
      ++v19;
      a7 -= v21;
      *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    }

    while (a7);
  }

  BOOL v34 = a5 != 0;
LABEL_25:
  HMAC_CTX_cleanup(&ctx);
  return v34;
}

int PKCS5_PBKDF2_HMAC_SHA1( const char *pass, int passlen, const unsigned __int8 *salt, int saltlen, int iter, int keylen, unsigned __int8 *out)
{
  size_t v8 = *(void *)&keylen;
  size_t v10 = *(void *)&saltlen;
  int v14 = (EVP_MD *)EVP_sha1();
  return PKCS5_PBKDF2_HMAC(pass, passlen, salt, v10, iter, v14, v8, (char *)out);
}

BN_CTX *BN_CTX_new(void)
{
  uint64_t result = (BN_CTX *)OPENSSL_malloc(0x30uLL);
  if (result)
  {
    *(_OWORD *)((char *)result + 26) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *((_OWORD *)result + 1) = 0u;
  }

  return result;
}

void BN_CTX_free(BN_CTX *c)
{
  if (c)
  {
    if (*((void *)c + 4))
    {
      if (!*((_BYTE *)c + 40)) {
        BN_CTX_free_cold_1();
      }
    }

    OPENSSL_sk_pop_free_ex( *(unint64_t **)c,  (void (*)(uint64_t))sk_BIGNUM_call_free_func,  (uint64_t)BN_free);
    OPENSSL_free(*((void **)c + 1));
    OPENSSL_free(c);
  }

void BN_CTX_start(BN_CTX *ctx)
{
  if (!*((_BYTE *)ctx + 40))
  {
    uint64_t v2 = *((void *)ctx + 4);
    unint64_t v3 = *((void *)ctx + 2);
    if (v3 != *((void *)ctx + 3))
    {
      BOOL v6 = (void *)*((void *)ctx + 1);
      goto LABEL_14;
    }

    if (v3) {
      unint64_t v4 = (3 * v3) >> 1;
    }
    else {
      unint64_t v4 = 32LL;
    }
    if (v4 > v3 && v4 >> 61 == 0)
    {
      BOOL v6 = OPENSSL_realloc(*((void **)ctx + 1), 8 * v4);
      if (v6)
      {
        *((void *)ctx + 1) = v6;
        *((void *)ctx + 3) = v4;
        unint64_t v3 = *((void *)ctx + 2);
LABEL_14:
        v6[v3] = v2;
        ++*((void *)ctx + 2);
        return;
      }
    }

    *((_WORD *)ctx + 20) = 257;
  }

BIGNUM *__cdecl BN_CTX_get(BN_CTX *ctx)
{
  if (!*((_BYTE *)ctx + 40))
  {
    unint64_t v3 = *(unint64_t **)ctx;
    if (*(void *)ctx || (unint64_t v3 = OPENSSL_sk_new_null(), (*(void *)ctx = v3) != 0LL))
    {
      unint64_t v4 = (const EVP_MD *)*((void *)ctx + 4);
      if (v4 != EVP_MD_CTX_md((const EVP_MD_CTX *)v3)
        || (__int128 v5 = BN_new()) != 0LL && OPENSSL_sk_push(*(unint64_t **)ctx, (uint64_t)v5))
      {
        uint64_t v2 = OPENSSL_sk_value(*(unint64_t **)ctx, *((void *)ctx + 4));
        BN_zero((uint64_t)v2);
        ++*((void *)ctx + 4);
        return (BIGNUM *)v2;
      }

      ERR_put_error(3, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/ctx.c", 172);
      BN_free(v5);
    }

    uint64_t v2 = 0LL;
    *((_BYTE *)ctx + 40) = 1;
    return (BIGNUM *)v2;
  }

  if (!*((_BYTE *)ctx + 41)) {
    return 0LL;
  }
  ERR_put_error(3, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/ctx.c", 155);
  uint64_t v2 = 0LL;
  *((_BYTE *)ctx + 41) = 0;
  return (BIGNUM *)v2;
}

void BN_CTX_end(BN_CTX *ctx)
{
  if (!*((_BYTE *)ctx + 40))
  {
    uint64_t v1 = *((void *)ctx + 2);
    if (!v1) {
      BN_CTX_end_cold_1();
    }
    uint64_t v2 = v1 - 1;
    *((void *)ctx + 2) = v2;
    *((void *)ctx + 4) = *(void *)(*((void *)ctx + 1) + 8 * v2);
  }

uint64_t sk_BIGNUM_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

BOOL bio_errno_should_retry(int a1)
{
  if (a1 != -1) {
    return 0LL;
  }
  if (*__error() == 35
    || *__error() == 57
    || *__error() == 4
    || *__error() == 35
    || *__error() == 100
    || *__error() == 36)
  {
    return 1LL;
  }

  return *__error() == 37;
}

BOOL bssl::tls13_add_certificate( bssl *this, bssl::SSL_HANDSHAKE *a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  return bssl::tls13_add_certificate_in_buffer(this, 0LL, 0LL, 0LL, a5);
}

BOOL bssl::tls13_add_certificate_in_buffer( bssl *this, bssl::SSL_HANDSHAKE *a2, void *a3, unsigned __int8 **a4, unint64_t *a5)
{
  char v7 = (char)a2;
  unint64_t v9 = *(_BYTE **)this;
  uint64_t v10 = *((void *)this + 188);
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[1] = v11;
  v53[2] = v11;
  v53[0] = v11;
  CBB_zero(v53);
  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v52[1] = v12;
  v52[2] = v12;
  v52[0] = v12;
  v51[1] = v12;
  v51[2] = v12;
  v51[0] = v12;
  if ((*((_BYTE *)this + 1586) & 0x10) != 0)
  {
    int v13 = (uint64_t *)v53;
  }

  else
  {
    if (!(*(unsigned int (**)(_BYTE *, _OWORD *, _OWORD *, uint64_t))(*(void *)v9 + 88LL))( v9,  v53,  v52,  11LL)) {
      goto LABEL_69;
    }
    int v13 = (uint64_t *)v52;
  }

  if (!CBB_add_u8((uint64_t)v13, 0) || !CBB_add_u24_length_prefixed(v13, (uint64_t)v51))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 583);
    BOOL v18 = 0LL;
    goto LABEL_70;
  }

  int v15 = *((_DWORD *)this + 396);
  if ((v15 & 0x400000) != 0 && *((_BYTE *)this + 731) == 2 && (v9[180] & 1) == 0 && (v7 & 1) == 0)
  {
    *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v49 = v16;
    __int128 v50 = v16;
    __int128 v47 = v16;
    __int128 v48 = v16;
    __int128 v45 = v16;
    __int128 v46 = v16;
    if (!CBB_add_u24_length_prefixed((uint64_t *)v51, (uint64_t)&v48)
      || !EVP_marshal_public_key((uint64_t)&v48, *(void *)(v10 + 8))
      || !CBB_add_u16_length_prefixed((uint64_t *)v51, (uint64_t)&v45))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 596);
      BOOL v18 = 0LL;
      goto LABEL_70;
    }

void sub_1875BA2EC(_Unwind_Exception *a1)
{
}

uint64_t bssl::tls13_add_compressed_certificate( void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, void *a5, void *a6)
{
  __s2 = 0LL;
  unint64_t v33 = 0LL;
  if (bssl::CBBFinishArray(a2, (uint64_t)&__s2))
  {
    uint64_t v12 = a1[15];
    uint64_t v13 = *(void *)(v12 + 704);
    if (!v13) {
      goto LABEL_24;
    }
    uint64_t v14 = *(void *)(v12 + 712);
    uint64_t v15 = 24 * v13;
    while (*(unsigned __int16 *)(v14 + 16) != *(unsigned __int16 *)(a3 + 728))
    {
      v14 += 24LL;
      v15 -= 24LL;
      if (!v15) {
        goto LABEL_24;
      }
    }

    if (*(void *)v14)
    {
      *(void *)&__int128 v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v31[1] = v17;
      _OWORD v31[2] = v17;
      v31[0] = v17;
      if ((*(unsigned int (**)(void *, uint64_t, uint64_t *, uint64_t))(*a1 + 88LL))(a1, a2, a4, 25LL)
        && CBB_add_u16((uint64_t)a4, *(unsigned __int16 *)(a3 + 728))
        && CBB_add_u24((uint64_t)a4, v33)
        && CBB_add_u24_length_prefixed(a4, (uint64_t)v31))
      {
        uint64_t v18 = *(void *)(a3 + 1576);
        if (v18
          && (*(_BYTE *)(a3 + 1586) & 8) == 0
          && *(unsigned __int16 *)(v18 + 146) == *(unsigned __int16 *)(a3 + 728)
          && (size_t v19 = *(void *)(v18 + 160), v19 == v33)
          && !memcmp(*(const void **)(v18 + 152), __s2, v19)
          && (size_t v30 = *(void *)(v18 + 176)) != 0)
        {
          if (!CBB_add_bytes((uint64_t)v31, *(const void **)(v18 + 168), v30))
          {
            int v20 = 521;
            goto LABEL_28;
          }
        }

        else
        {
          if (!(*(unsigned int (**)(void *, _OWORD *, void *, unint64_t))v14)(a1, v31, __s2, v33))
          {
            int v20 = 526;
            goto LABEL_28;
          }

          if (v18 && (*(_BYTE *)(a3 + 1586) & 8) != 0)
          {
            *(_WORD *)(v18 + 146) = *(_WORD *)(a3 + 728);
            size_t v22 = __s2;
            size_t v23 = v33;
            int v24 = bssl::Array<unsigned char>::Init(v18 + 152, v33);
            char v25 = v24 ^ 1;
            if (!v23) {
              char v25 = 1;
            }
            if ((v25 & 1) == 0) {
              memmove(*(void **)(v18 + 152), v22, v23);
            }
            if (!v24) {
              goto LABEL_39;
            }
            size_t v26 = CBB_data((uint64_t)v31);
            unint64_t v27 = CBB_len((uint64_t)v31);
            int v28 = bssl::Array<unsigned char>::Init(v18 + 168, v27);
            char v29 = v28 ^ 1;
            if (!v27) {
              char v29 = 1;
            }
            if ((v29 & 1) == 0) {
              memmove(*(void **)(v18 + 168), v26, v27);
            }
            if (!v28)
            {
LABEL_39:
              uint64_t v16 = 0LL;
              goto LABEL_25;
            }
          }
        }

        if (a5)
        {
          if (!CBB_finish(a2, a5, a6))
          {
            int v20 = 546;
LABEL_28:
            ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", v20);
            uint64_t v16 = 0LL;
            goto LABEL_25;
          }
        }

        else if ((bssl::ssl_add_message_cbb((uint64_t)a1, a2) & 1) == 0)
        {
          int v20 = 541;
          goto LABEL_28;
        }

        uint64_t v16 = 1LL;
        goto LABEL_25;
      }

      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 510);
      uint64_t v16 = 0LL;
    }

    else
    {
LABEL_24:
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 499);
      uint64_t v16 = 0LL;
    }
  }

  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/tls13_both.cc", 486);
    uint64_t v16 = 0LL;
  }

void sub_1875BA634( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t bssl::tls13_add_certificate_verify(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  return bssl::tls13_add_certificate_verify_in_buffer(this, 0LL, 0LL, 0LL, 0LL, 0LL);
}

uint64_t bssl::tls13_add_certificate_verify_in_buffer( bssl *this, bssl::SSL_HANDSHAKE *a2, void *a3, unsigned __int8 **a4, unint64_t *a5, const unsigned __int8 *a6)
{
  if (!*((_WORD *)this + 797)) {
    bssl::tls13_add_certificate_verify_in_buffer();
  }
  char v10 = (char)a2;
  uint64_t v12 = *(bssl **)this;
  *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[1] = v13;
  _OWORD v26[2] = v13;
  v26[0] = v13;
  CBB_zero(v26);
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[1] = v14;
  _OWORD v25[2] = v14;
  v25[0] = v14;
  if ((*(unsigned int (**)(bssl *, _OWORD *, _OWORD *, uint64_t))(*(void *)v12 + 88LL))( v12,  v26,  v25,  15LL)
    && CBB_add_u16((uint64_t)v25, *((unsigned __int16 *)this + 797)))
  {
    *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v24[1] = v15;
    _OWORD v24[2] = v15;
    v24[0] = v15;
    int v16 = EVP_PKEY_size(*(EVP_PKEY **)(*((void *)this + 188) + 8LL));
    uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
    size_t v23 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CBB_add_u16_length_prefixed((uint64_t *)v25, (uint64_t)v24)
      && CBB_reserve((uint64_t)v24, &v23, v16))
    {
      int v20 = 0LL;
      size_t v21 = 0LL;
      if ((v10 & 1) != 0) {
        unsigned int v17 = 3;
      }
      else {
        unsigned int v17 = (*((_BYTE *)v12 + 180) & 1) == 0;
      }
      if (bssl::tls13_get_cert_verify_signature_input((uint64_t)this, (uint64_t)&v20, v17, a5, (size_t)a6))
      {
        uint64_t v18 = bssl::ssl_private_key_sign( (uint64_t)this,  v23,  (unint64_t *)&v22,  v16,  (evp_pkey_st *)*((unsigned __int16 *)this + 797),  v20,  v21);
        if (!(_DWORD)v18)
        {
          if (a3)
          {
            if (!CBB_did_write((uint64_t)v24, v22) || !CBB_finish((uint64_t)v26, a3, a4))
            {
LABEL_23:
              uint64_t v18 = 2LL;
              goto LABEL_18;
            }
          }

          else if (!CBB_did_write((uint64_t)v24, v22) {
                 || (bssl::ssl_add_message_cbb((uint64_t)v12, (uint64_t)v26) & 1) == 0)
          }
          {
            goto LABEL_23;
          }

          uint64_t v18 = 0LL;
        }
      }

      else
      {
        uint64_t v18 = 2LL;
        bssl::ssl_send_alert(v12, (ssl_st *)2, 80);
      }

void sub_1875BA888( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
}

uint64_t bssl::tls13_add_key_update(bssl *this, ssl_st *a2)
{
  unsigned __int8 v2 = a2;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v4;
  __int128 v9[2] = v4;
  v9[0] = v4;
  CBB_zero(v9);
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v5;
  _OWORD v8[2] = v5;
  v8[0] = v5;
  if ((*(unsigned int (**)(bssl *, _OWORD *, _OWORD *, uint64_t))(*(void *)this + 88LL))( this,  v9,  v8,  24LL)
    && CBB_add_u8((uint64_t)v8, v2)
    && bssl::ssl_add_message_cbb((uint64_t)this, (uint64_t)v9)
    && (bssl::tls13_rotate_traffic_key((const SSL *)this, 1LL) & 1) != 0)
  {
    *(_WORD *)(*((void *)this + 6) + 220LL) |= 0x200u;
    uint64_t v6 = 1LL;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  CBB_cleanup((uint64_t)v9);
  return v6;
}

void sub_1875BA988( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t bssl::ssl_client_hello_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = a4;
  LODWORD(result) = bssl::ssl_parse_client_hello_with_trailing_data(a1, (uint64_t)&v5, a2);
  if (v6) {
    return 0LL;
  }
  else {
    return result;
  }
}

uint64_t bssl::ssl_parse_client_hello_with_trailing_data(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + bssl::Array<unsigned short>::~Array(v16 + 104) = 0LL;
  *(_OWORD *)(a3 + 8bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = a1;
  uint64_t v5 = *(unsigned __int16 **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  memset(v16, 170, sizeof(v16));
  uint64_t result = CBS_get_u16((unsigned __int16 **)a2, (_WORD *)(a3 + 24));
  if ((_DWORD)result)
  {
    uint64_t result = CBS_get_bytes((uint64_t *)a2, &v16[2], 0x20uLL);
    if ((_DWORD)result)
    {
      uint64_t result = CBS_get_u8_length_prefixed((unsigned __int8 **)a2, v16);
      if ((_DWORD)result)
      {
        unint64_t v8 = v16[1];
        if (v16[1] > 0x20) {
          return 0LL;
        }
        unint64_t v9 = v16[3];
        *(void *)(a3 + bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v16[2];
        *(void *)(a3 + 40) = v9;
        *(void *)(a3 + 4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v16[0];
        *(void *)(a3 + 56) = v8;
        if (!SSL_is_dtls(*(unsigned __int8 ***)a3)
          || (_OWORD v15[2] = 0xAAAAAAAAAAAAAAAALL,
              _OWORD v15[3] = 0xAAAAAAAAAAAAAAAALL,
              uint64_t result = CBS_get_u8_length_prefixed((unsigned __int8 **)a2, &v15[2]),
              (_DWORD)result))
        {
          memset(v15, 170, sizeof(v15));
          uint64_t result = CBS_get_u16_length_prefixed((unsigned __int8 **)a2, &v15[2]);
          if ((_DWORD)result)
          {
            uint64_t result = 0LL;
            if (v15[3] >= 2 && (v15[3] & 1) == 0)
            {
              uint64_t result = CBS_get_u8_length_prefixed((unsigned __int8 **)a2, v15);
              if ((_DWORD)result)
              {
                unint64_t v10 = v15[1];
                if (!v15[1]) {
                  return 0LL;
                }
                unint64_t v11 = v15[3];
                *(void *)(a3 + 64) = v15[2];
                *(void *)(a3 + 72) = v11;
                *(void *)(a3 + 80) = v15[0];
                *(void *)(a3 + 8bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v10;
                uint64_t v12 = *(void *)(a2 + 8);
                if (v12)
                {
                  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  if (!CBS_get_u16_length_prefixed((unsigned __int8 **)a2, (unint64_t *)&v14)
                    || !bssl::tls1_check_duplicate_extensions(&v14))
                  {
                    return 0LL;
                  }

                  uint64_t v13 = *((void *)&v14 + 1);
                  *(void *)(a3 + bssl::Array<unsigned short>::~Array(v1 - 96) = v14;
                  *(void *)(a3 + bssl::Array<unsigned short>::~Array(v16 + 104) = v13;
                  uint64_t v12 = *(void *)(a2 + 8);
                }

                else
                {
                  *(void *)(a3 + bssl::Array<unsigned short>::~Array(v1 - 96) = 0LL;
                  *(void *)(a3 + bssl::Array<unsigned short>::~Array(v16 + 104) = 0LL;
                }

                *(void *)(a3 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v5;
                *(void *)(a3 + 16) = v6 - v12;
                return 1LL;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ssl_client_hello_get_extension(uint64_t a1, _OWORD *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 104);
  unint64_t v9 = *(unsigned __int8 **)(a1 + 96);
  uint64_t v10 = v3;
  if (!v3) {
    return 0LL;
  }
  while (1)
  {
    unsigned __int16 v8 = -21846;
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = CBS_get_u16((unsigned __int16 **)&v9, &v8);
    if (!(_DWORD)result) {
      break;
    }
    uint64_t result = CBS_get_u16_length_prefixed(&v9, (unint64_t *)&v7);
    if (!(_DWORD)result) {
      break;
    }
    if (v8 == a3)
    {
      *a2 = v7;
      return 1LL;
    }

    if (!v10) {
      return 0LL;
    }
  }

  return result;
}

uint64_t bssl::tls1_get_shared_group(bssl *this, const ssl_st *a2, unsigned __int16 *a3)
{
  uint64_t v3 = *(bssl **)this;
  if ((*(_BYTE *)(*(void *)this + 180LL) & 1) == 0) {
    bssl::tls1_get_shared_group();
  }
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)(v4 + 112);
  if (v5)
  {
    uint64_t v6 = *(__int16 **)(v4 + 104);
  }

  else
  {
    uint64_t v6 = &bssl::kDefaultGroups;
    uint64_t v5 = 4LL;
  }

  __int128 v7 = (__int16 *)*((void *)this + 83);
  uint64_t v8 = *((void *)this + 84);
  if ((*((_BYTE *)v3 + 146) & 0x40) != 0)
  {
    __int128 v15 = (ssl_st *)a2;
    unint64_t v9 = (unsigned __int16 *)&v6[v5];
    uint64_t v10 = v6;
LABEL_9:
    while (!v8)
    {
LABEL_15:
    }

    int v11 = (unsigned __int16)*v10;
    uint64_t v12 = 2 * v8;
    uint64_t v13 = v7;
    while (v11 != (unsigned __int16)*v13 || bssl::ssl_protocol_version(v3, a2) <= 0x303 && v11 == 25497)
    {
      ++v13;
      v12 -= 2LL;
      if (!v12) {
        goto LABEL_15;
      }
    }

    LOWORD(v15->version) = v11;
    return 1LL;
  }

  else
  {
    if (v8)
    {
      __int128 v15 = (ssl_st *)a2;
      unint64_t v9 = (unsigned __int16 *)&v7[v8];
      uint64_t v10 = (__int16 *)*((void *)this + 83);
      __int128 v7 = v6;
      uint64_t v8 = v5;
      goto LABEL_9;
    }

    return 0LL;
  }

BOOL bssl::tls1_check_group_id(bssl **this, const ssl_st *a2)
{
  if (!(_DWORD)a2) {
    return 0LL;
  }
  int v2 = (int)a2;
  uint64_t v5 = this[1];
  uint64_t v6 = *((void *)v5 + 14);
  if (v6)
  {
    __int128 v7 = (__int16 *)*((void *)v5 + 13);
  }

  else
  {
    __int128 v7 = &bssl::kDefaultGroups;
    uint64_t v6 = 4LL;
  }

  uint64_t v8 = 2 * v6 - 2;
  do
  {
    int v9 = (unsigned __int16)*v7++;
    BOOL result = v9 == v2;
    BOOL v10 = v9 == v2 || v8 == 0;
    v8 -= 2LL;
  }

  while (!v10);
  return result;
}

uint64_t bssl::ssl_negotiate_alpn(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v4 = *(void **)a1;
  *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!v4[10] || (bssl::ssl_client_hello_get_extension(a3, &v20, 16) & 1) == 0)
  {
    if (!v4[21]) {
      return 1LL;
    }
    ERR_put_error(16, 0, 307, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1512);
    uint64_t result = 0LL;
    char v13 = 120;
    goto LABEL_20;
  }

  *(_DWORD *)(a1 + 1584) &= ~0x4000u;
  uint64_t v18 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v20, (unint64_t *)&v18)
    || *((void *)&v20 + 1)
    || (bssl::ssl_is_valid_alpn_list(v18, v19) & 1) == 0)
  {
    ERR_put_error(16, 0, 190, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1527);
    uint64_t result = 0LL;
    char v13 = 50;
LABEL_20:
    *a2 = v13;
    return result;
  }

  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int8 v16 = -86;
  int v6 = ((uint64_t (*)(void *, unint64_t *, unsigned __int8 *, unsigned __int8 *, void, void))v4[10])( v4,  &v17,  &v16,  v18,  v19,  v4[11]);
  if ((v6 & 0xFFFFFFFD) == 1) {
    int v7 = 2;
  }
  else {
    int v7 = v6;
  }
  if (v4[21]) {
    int v8 = v7;
  }
  else {
    int v8 = v6;
  }
  uint64_t result = 1LL;
  switch(v8)
  {
    case 0:
      size_t v10 = v16;
      if (v16)
      {
        int v11 = (void **)(v4[6] + 496LL);
        uint64_t v12 = (const void *)v17;
        uint64_t result = bssl::Array<unsigned char>::Init((uint64_t)v11, v16);
        if ((_DWORD)result)
        {
          memmove(*v11, v12, v10);
          return 1LL;
        }
      }

      else
      {
        ERR_put_error(16, 0, 259, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1554);
        uint64_t result = 0LL;
      }

      char v13 = 80;
      goto LABEL_20;
    case 1:
    case 3:
      return result;
    case 2:
      *a2 = 120;
      int v14 = 307;
      int v15 = 1569;
      goto LABEL_24;
    default:
      *a2 = 80;
      int v14 = 68;
      int v15 = 1574;
LABEL_24:
      ERR_put_error(16, 0, v14, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v15);
      uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t bssl::ssl_ext_pre_shared_key_parse_serverhello(uint64_t a1, char *a2, uint64_t a3)
{
  __int16 v7 = -21846;
  if (CBS_get_u16((unsigned __int16 **)a3, &v7) && !*(void *)(a3 + 8))
  {
    if (!v7) {
      return 1LL;
    }
    ERR_put_error(16, 0, 195, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2000);
    char v5 = 115;
  }

  else
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1993);
    char v5 = 50;
  }

  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

uint64_t bssl::ssl_ext_pre_shared_key_parse_clienthello( uint64_t a1, unint64_t *a2, _OWORD *a3, int *a4, char *a5, uint64_t a6, uint64_t a7)
{
  if (*(void *)a7 + *(void *)(a7 + 8) == *(void *)(a6 + 96) + *(void *)(a6 + 104))
  {
    memset(v20, 170, sizeof(v20));
    if (CBS_get_u16_length_prefixed((unsigned __int8 **)a7, (unint64_t *)&v20[1])
      && CBS_get_u16_length_prefixed((unsigned __int8 **)&v20[1], a2)
      && CBS_get_u32((uint64_t *)&v20[1], a4)
      && CBS_get_u16_length_prefixed((unsigned __int8 **)a7, (unint64_t *)v20)
      && *((void *)&v20[0] + 1)
      && !*(void *)(a7 + 8))
    {
      *a3 = v20[0];
      if (*((void *)&v20[1] + 1))
      {
        uint64_t v17 = 1LL;
        do
        {
          memset(v19, 170, sizeof(v19));
          if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v20[1], (unint64_t *)&v19[1])
            || !CBS_get_u32((uint64_t *)&v20[1], v19))
          {
            int v16 = 2043;
            goto LABEL_11;
          }

          ++v17;
        }

        while (*((void *)&v20[1] + 1));
        if (*((void *)&v20[0] + 1)) {
          goto LABEL_23;
        }
        uint64_t v18 = 0LL;
LABEL_26:
        if (v17 == v18) {
          return 1LL;
        }
        int v8 = 271;
        int v9 = 2066;
        goto LABEL_3;
      }

      uint64_t v17 = 1LL;
LABEL_23:
      uint64_t v18 = 0LL;
      while (1)
      {
        *(void *)&v19[1] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&_OWORD v19[3] = 0xAAAAAAAAAAAAAAAALL;
        ++v18;
        if (!*((void *)&v20[0] + 1)) {
          goto LABEL_26;
        }
      }

      int v16 = 2057;
    }

    else
    {
      int v16 = 2029;
    }

uint64_t bssl::ssl_ext_pre_shared_key_add_serverhello(uint64_t a1, uint64_t *a2)
{
  if ((*(_WORD *)(*(void *)(*(void *)a1 + 48LL) + 220LL) & 0x40) == 0) {
    return 1LL;
  }
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[1] = v4;
  void v5[2] = v4;
  v5[0] = v4;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x29u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v5);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16((uint64_t)v5, 0);
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ssl_ext_key_share_parse_clienthello( uint64_t a1, BOOL *a2, unint64_t *a3, _BYTE *a4, uint64_t a5)
{
  *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if ((bssl::ssl_client_hello_get_extension(a5, &v20, 51) & 1) != 0)
  {
    uint64_t v18 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_u16_length_prefixed((unsigned __int8 **)&v20, (unint64_t *)&v18)
      || *((void *)&v20 + 1))
    {
      int v14 = 2382;
LABEL_22:
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v14);
      return 0LL;
    }

    else
    {
      unint64_t v9 = v19;
      if (v19)
      {
        unint64_t v10 = 0LL;
        unint64_t v11 = 0LL;
        int v12 = *(unsigned __int16 *)(*(void *)(a1 + 1520) + 6LL);
        while (1)
        {
          unsigned __int16 v17 = -21846;
          unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u16((unsigned __int16 **)&v18, &v17)
            || !CBS_get_u16_length_prefixed(&v18, &v15)
            || (unint64_t v9 = v16) == 0)
          {
            int v14 = 2396;
            goto LABEL_22;
          }

          if (v17 == v12)
          {
            if (v11)
            {
              ERR_put_error(16, 0, 264, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2402);
              *a4 = 47;
              return 0LL;
            }

            unint64_t v10 = v15;
            unint64_t v11 = v16;
          }

          else
          {
            unint64_t v9 = v11;
          }

          if (!v19) {
            goto LABEL_18;
          }
        }
      }

      unint64_t v10 = 0LL;
LABEL_18:
      if (a3)
      {
        *a3 = v10;
        a3[1] = v9;
      }

      *a2 = v9 != 0;
      return 1LL;
    }
  }

  else
  {
    ERR_put_error(16, 0, 258, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2374);
    uint64_t result = 0LL;
    *a4 = 109;
  }

  return result;
}

uint64_t bssl::ssl_ext_key_share_add_serverhello(uint64_t a1, uint64_t *a2)
{
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x33u);
  if ((_DWORD)result)
  {
    *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = v5;
    unint64_t v7[2] = v5;
    void v6[2] = v5;
    v7[0] = v5;
    v6[0] = v5;
    v6[1] = v5;
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16((uint64_t)v7, *(unsigned __int16 *)(*(void *)(a1 + 1520) + 6LL));
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v7, (uint64_t)v6);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_bytes((uint64_t)v6, *(const void **)(a1 + 632), *(void *)(a1 + 640));
          if ((_DWORD)result) {
            return CBB_flush(a2) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ssl_get_local_application_settings(uint64_t a1, void *a2, void *__s1, size_t __n)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 144);
  if (!v5) {
    return 0LL;
  }
  unint64_t v9 = (void *)(*(void *)(v4 + 152) + 16LL);
  uint64_t v10 = 32 * v5;
  while (__n != *(v9 - 1) || memcmp(__s1, (const void *)*(v9 - 2), __n))
  {
    v9 += 4;
    v10 -= 32LL;
    if (!v10) {
      return 0LL;
    }
  }

  uint64_t v12 = v9[1];
  *a2 = *v9;
  a2[1] = v12;
  return 1LL;
}

uint64_t bssl::ssl_negotiate_alps(bssl **a1, ssl_st *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if (*(void *)(*((void *)*a1 + 6) + 504LL))
  {
    *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
    size_t v23 = 0LL;
    size_t v24 = 0LL;
    int v7 = (*(_WORD *)((_BYTE *)a1[1] + 301) & 0x2000) != 0 ? 17613 : 17513;
    if (bssl::ssl_protocol_version(v3, a2) >= 0x304
      && bssl::ssl_get_local_application_settings( (uint64_t)a1,  &v23,  *(void **)(*((void *)v3 + 6) + 496LL),  *(void *)(*((void *)v3 + 6) + 504LL))
      && bssl::ssl_client_hello_get_extension(a3, &v25, v7))
    {
      size_t v21 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
      unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
      if (CBS_get_u16_length_prefixed((unsigned __int8 **)&v25, (unint64_t *)&v21)
        && !*((void *)&v25 + 1)
        && v22)
      {
        char v8 = 0;
        do
        {
          __s1 = (void *)0xAAAAAAAAAAAAAAAALL;
          size_t __n = 0xAAAAAAAAAAAAAAAALL;
          if (!CBS_get_u8_length_prefixed(&v21, (unint64_t *)&__s1) || !__n)
          {
            int v17 = 3110;
            goto LABEL_27;
          }

          uint64_t v9 = *((void *)v3 + 6);
          BOOL v10 = __n == *(void *)(v9 + 504) && memcmp(__s1, *(const void **)(v9 + 496), __n) == 0;
          v8 |= v10;
        }

        while (v22);
        if ((v8 & 1) == 0) {
          return 1LL;
        }
        *((_BYTE *)a1[190] + 440) |= 0x40u;
        unint64_t v11 = (void **)((char *)a1[190] + 408);
        uint64_t v12 = v23;
        size_t v13 = v24;
        int v14 = bssl::Array<unsigned char>::Init((uint64_t)v11, v24);
        char v15 = v14;
        if (v13)
        {
          if (v14) {
            memmove(*v11, v12, v13);
          }
        }

        if ((v15 & 1) != 0) {
          return 1LL;
        }
        char v18 = 80;
      }

      else
      {
        int v17 = 3101;
LABEL_27:
        ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v17);
        char v18 = 50;
      }

      LOBYTE(a2->version) = v18;
      return 0LL;
    }
  }

  return 1LL;
}

BOOL bssl::ssl_add_serverhello_tlsext(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(bssl **)a1;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[1] = v5;
  _OWORD v17[2] = v5;
  v17[0] = v5;
  if (CBB_add_u16_length_prefixed(a2, (uint64_t)v17))
  {
    uint64_t v7 = 0LL;
    char v8 = &off_18A0713A0;
    do
    {
      if (((*(_DWORD *)(a1 + 376) >> v7) & 1) != 0 && !((unsigned int (*)(uint64_t, _OWORD *))*v8)(a1, v17))
      {
        ERR_put_error(16, 0, 147, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4020);
        ERR_add_error_dataf("extension %u", v10, v11, v12, v13, v14, v15, v16, *((_WORD *)v8 - 16));
        goto LABEL_11;
      }

      ++v7;
      v8 += 5;
    }

    while (v7 != 28);
    return CBB_flush(a2) != 0;
  }

  else
  {
LABEL_11:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4035);
    return 0LL;
  }

uint64_t bssl::ssl_parse_clienthello_tlsext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(bssl **)a1;
  *(_DWORD *)(a1 + 376) = 0;
  uint64_t v5 = *(void *)(a2 + 104);
  *(void *)size_t v37 = *(void *)(a2 + 96);
  uint64_t v38 = v5;
  if (!v5)
  {
LABEL_10:
    size_t v32 = v4;
    uint64_t v8 = 0LL;
    uint64_t v9 = bssl::kExtensions;
    do
    {
      if (((1 << v8) & *(_DWORD *)(a1 + 376)) == 0)
      {
        BOOL v34 = (void *)0xAAAAAAAAAAAAAAAALL;
        unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
        int v10 = (unsigned __int16)*v9;
        if (v10 == 65281 && bssl::ssl_client_cipher_list_contains_cipher(a2, 255))
        {
          BOOL v34 = &bssl::ssl_scan_clienthello_tlsext(bssl::SSL_HANDSHAKE *,ssl_early_callback_ctx const*,int *)::kFakeRenegotiateExtension;
          unint64_t v35 = 1LL;
          *(_DWORD *)(a1 + 376) |= 1 << v8;
          uint64_t v11 = &v34;
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        LOBYTE(v36) = 50;
        if (((*((uint64_t (**)(uint64_t, unsigned __int16 *, void **))v9 + 3))(a1, &v36, v11) & 1) == 0)
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4095);
          ERR_add_error_dataf("extension %u", v18, v19, v20, v21, v22, v23, v24, v10);
          int v17 = v36;
          uint64_t v4 = v32;
          goto LABEL_28;
        }
      }

      ++v8;
      v9 += 20;
    }

    while (v8 != 28);
    uint64_t v12 = *(bssl **)a1;
    v37[0] = 112;
    uint64_t v13 = *((void *)v12 + 15);
    uint64_t v14 = *(uint64_t (**)(bssl *, int *, void))(v13 + 504);
    if (!v14)
    {
      uint64_t v13 = *((void *)v12 + 16);
      uint64_t v14 = *(uint64_t (**)(bssl *, int *, void))(v13 + 504);
      if (!v14)
      {
LABEL_22:
        *(_DWORD *)(a1 + 1584) &= ~0x100u;
        return 1LL;
      }
    }

    int v15 = v14(v12, v37, *(void *)(v13 + 512));
    if (v15 != 2)
    {
      if (v15 == 3) {
        goto LABEL_22;
      }
      return 1LL;
    }

    bssl::ssl_send_alert(v12, (ssl_st *)2, v37[0]);
    ERR_put_error(16, 0, 132, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4115);
    return 0LL;
  }

  while (2)
  {
    unsigned __int16 v36 = -21846;
    BOOL v34 = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u16((unsigned __int16 **)v37, &v36)
      && CBS_get_u16_length_prefixed((unsigned __int8 **)v37, (unint64_t *)&v34))
    {
      uint64_t v6 = 0LL;
      uint64_t v7 = bssl::kExtensions;
      while ((unsigned __int16)*v7 != v36)
      {
        ++v6;
        v7 += 20;
        if (v6 == 28) {
          goto LABEL_9;
        }
      }

      *(_DWORD *)(a1 + 376) |= 1 << v6;
      unsigned __int8 v33 = 50;
      if (((*((uint64_t (**)(uint64_t, unsigned __int8 *, void **))v7 + 3))(a1, &v33, &v34) & 1) == 0)
      {
        int v17 = v33;
        ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4067);
        ERR_add_error_dataf("extension %u", v25, v26, v27, v28, v29, v30, v31, v36);
        goto LABEL_28;
      }

uint64_t bssl::ssl_process_ticket( uint64_t *a1, SSL_SESSION **a2, _BYTE *a3, const unsigned __int8 *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  uint64_t v13 = (uint64_t *)*a1;
  *a3 = 0;
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](a2, 0LL);
  uint64_t v15 = 2LL;
  if ((SSL_get_options(*a1) & 0x4000) == 0 && a7 <= 0x20)
  {
    unsigned int v16 = bssl::ssl_protocol_version((bssl *)v13, v14);
    unsigned int v17 = v16;
    __dst = 0LL;
    unint64_t v38 = 0LL;
    uint64_t v18 = a1[197];
    if (v16 < 0x304 || v18 == 0)
    {
      if (v16 <= 0x303 && v18 && (*((_BYTE *)a1 + 1586) & 8) == 0)
      {
        size_t v20 = *(void *)(v18 + 232);
        if (v20)
        {
          uint64_t v21 = *(const void **)(v18 + 224);
          if (bssl::Array<unsigned char>::Init((uint64_t)&__dst, *(void *)(v18 + 232)))
          {
            memmove(__dst, v21, v20);
            uint64_t v15 = 0LL;
            *a3 = *(_BYTE *)(v18 + 240);
            goto LABEL_35;
          }

LABEL_37:
        uint64_t v28 = SSL_SESSION_from_bytes((uint64_t)__dst, v38, v13[15]);
        uint64_t v29 = v28;
        unint64_t v40 = v28;
        if (v28)
        {
          SHA256(a4, a5, &v28->master_key[40]);
          v29->master_key[39] = 32;
          std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100](a2, v29);
          uint64_t v15 = 0LL;
          goto LABEL_60;
        }

        ERR_clear_error();
LABEL_52:
        uint64_t v15 = 2LL;
        goto LABEL_60;
      }
    }

    else if (a5 >= 0x20)
    {
      if (*(void *)(v24 + 536)) {
        uint64_t v27 = bssl::ssl_decrypt_ticket_with_cb((uint64_t)a1, (uint64_t)&__dst, a3, a4, a5);
      }
      else {
        uint64_t v27 = bssl::ssl_decrypt_ticket_with_ticket_keys((uint64_t)a1, (ssl_ctx_st *)&__dst, (uint64_t)a4, a5);
      }
      uint64_t v15 = v27;
      if (v18) {
        goto LABEL_35;
      }
    }

    else
    {
      uint64_t v15 = 2LL;
      if (v18) {
        goto LABEL_35;
      }
    }

void sub_1875BBEA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  std::unique_ptr<ssl_session_st,bssl::internal::Deleter>::reset[abi:ne180100]((SSL_SESSION **)va1, 0LL);
  bssl::Array<unsigned short>::~Array((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t bssl::ssl_decrypt_ticket_with_cb( uint64_t a1, uint64_t a2, _BYTE *a3, const unsigned __int8 *a4, unint64_t a5)
{
  *(void *)&a.final[16] = *MEMORY[0x1895F89C0];
  if (a5 <= 0x1F) {
    bssl::ssl_decrypt_ticket_with_cb();
  }
  *(void *)&a.final[8] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&a.flagunsigned int s = v10;
  *(_OWORD *)&a.final_useint d = v10;
  *(_OWORD *)&a.buf[24] = v10;
  *(_OWORD *)&a.app_unint64_t data = v10;
  *(_OWORD *)&a.iv[8] = v10;
  *(_OWORD *)&a.buf[8] = v10;
  *(_OWORD *)&a.encrypt = v10;
  *(_OWORD *)&a.oiv[8] = v10;
  *(_OWORD *)&a.cipheBIGNUM r = v10;
  EVP_CIPHER_CTX_init(&a);
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15[4] = v11;
  int64x2_t v15[5] = v11;
  _OWORD v15[2] = v11;
  _OWORD v15[3] = v11;
  v15[0] = v11;
  v15[1] = v11;
  HMAC_CTX_init((HMAC_CTX *)v15);
  int v12 = (*(uint64_t (**)(void))(*(void *)(*(void *)a1 + 128LL) + 536LL))();
  if (v12 < 0)
  {
    uint64_t v13 = 3LL;
  }

  else if (v12)
  {
    if (v12 == 2)
    {
      *a3 = 1;
    }

    else if (v12 != 1)
    {
      __assert_rtn("ssl_decrypt_ticket_with_cb", "extensions.cc", 4338, "cb_ret == 1");
    }

    uint64_t v13 = bssl::decrypt_ticket_with_cipher_ctx(a2, &a, (HMAC_CTX *)v15, a4, a5);
  }

  else
  {
    uint64_t v13 = 2LL;
  }

  HMAC_CTX_cleanup((HMAC_CTX *)v15);
  EVP_CIPHER_CTX_cleanup(&a);
  return v13;
}

void sub_1875BC060( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, EVP_CIPHER_CTX *a)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t bssl::ssl_decrypt_ticket_with_ticket_keys( uint64_t a1, ssl_ctx_st *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a4 <= 0x1F) {
    bssl::ssl_decrypt_ticket_with_ticket_keys();
  }
  uint64_t v7 = *(void *)(*(void *)a1 + 128LL);
  uint64_t v8 = EVP_aes_128_cbc();
  EVP_CIPHER_iv_length(v8);
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.key[116] = v9;
  __int128 v21 = v9;
  *(_OWORD *)&ctx.key[84] = v9;
  *(_OWORD *)&ctx.key[100] = v9;
  *(_OWORD *)&ctx.key[52] = v9;
  *(_OWORD *)&ctx.key[68] = v9;
  *(_OWORD *)&ctx.key[20] = v9;
  *(_OWORD *)&ctx.key[36] = v9;
  *(_OWORD *)&ctx._OWORD key[4] = v9;
  EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)&ctx.key[4]);
  ctx.o_ctx.md_unint64_t data = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&ctx.i_ctx.md_unint64_t data = v10;
  *(_OWORD *)&ctx.o_ctx.engine = v10;
  *(_OWORD *)&ctx.md_ctx.md_unint64_t data = v10;
  *(_OWORD *)&ctx.i_ctx.engine = v10;
  *(_OWORD *)&ctx.mint d = v10;
  *(_OWORD *)&ctx.md_ctx.engine = v10;
  HMAC_CTX_init(&ctx);
  uint64_t v19 = (pthread_rwlock_t *)0xAAAAAAAAAAAAAAAALL;
  bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase( &v19,  (pthread_rwlock_t *)(v7 + 24));
  uint64_t v11 = *(void *)(v7 + 520);
  if (v11 && (*(void *)a3 == *(void *)v11 ? (BOOL v12 = *(void *)(a3 + 8) == *(void *)(v11 + 8)) : (BOOL v12 = 0), v12)
    || (uint64_t v11 = *(void *)(v7 + 528)) != 0
    && (*(void *)a3 == *(void *)v11 ? (BOOL v13 = *(void *)(a3 + 8) == *(void *)(v11 + 8)) : (BOOL v13 = 0), v13))
  {
    unint64_t v16 = EVP_sha256();
    HMAC_Init_ex(&ctx, (const void *)(v11 + 16), 16, v16, 0LL);
    if (v17) {
      BOOL v14 = EVP_DecryptInit_ex( (EVP_CIPHER_CTX *)&ctx.key[4],  v8,  0LL,  (const unsigned __int8 *)(v11 + 32),  (const unsigned __int8 *)(a3 + 16)) != 0;
    }
    else {
      BOOL v14 = 0;
    }
    uint64_t v15 = 3LL;
  }

  else
  {
    BOOL v14 = 0;
    uint64_t v15 = 2LL;
  }

  CRYPTO_MUTEX_unlock_read(v19);
  if (v14) {
    uint64_t v15 = bssl::decrypt_ticket_with_cipher_ctx( (uint64_t)a2,  (EVP_CIPHER_CTX *)&ctx.key[4],  &ctx,  (const unsigned __int8 *)a3,  a4);
  }
  HMAC_CTX_cleanup(&ctx);
  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)&ctx.key[4]);
  return v15;
}

void sub_1875BC290( _Unwind_Exception *a1, uint64_t a2, HMAC_CTX *ctx, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t ctxa, uint64_t ctx_8, uint64_t ctx_16, uint64_t ctx_24, uint64_t ctx_32, uint64_t ctx_40, uint64_t ctx_48, uint64_t ctx_56, uint64_t ctx_64, uint64_t ctx_72, uint64_t ctx_80, uint64_t ctx_88, uint64_t ctx_96, uint64_t ctx_104, uint64_t ctx_112)
{
}

uint64_t bssl::tls1_parse_peer_sigalgs(bssl **a1, ssl_st *a2)
{
  if (a2->method) {
    return bssl::parse_u16_array((__int128 *)&a2->version, (uint64_t)(a1 + 81));
  }
  return 0LL;
}

uint64_t bssl::parse_u16_array(__int128 *a1, uint64_t a2)
{
  __int128 v11 = *a1;
  uint64_t v2 = *((void *)&v11 + 1);
  if ((BYTE8(v11) & 1) != 0)
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2549);
    return 0LL;
  }

  else
  {
    __int128 v9 = 0LL;
    unint64_t v10 = 0LL;
    if (bssl::Array<unsigned short>::Init((uint64_t)&v9, *((void *)&v11 + 1) >> 1))
    {
      if (v10)
      {
        uint64_t v4 = 0LL;
        unint64_t v5 = 0LL;
        while (CBS_get_u16((unsigned __int16 **)&v11, (char *)v9 + v4))
        {
          ++v5;
          v4 += 2LL;
          if (v5 >= v10)
          {
            uint64_t v2 = *((void *)&v11 + 1);
            goto LABEL_8;
          }
        }

        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2559);
        uint64_t v7 = 0LL;
      }

      else
      {
LABEL_8:
        if (v2) {
          __assert_rtn("parse_u16_array", "extensions.cc", 2564, "CBS_len(&copy) == 0");
        }
        OPENSSL_free(*(void **)a2);
        unint64_t v6 = v10;
        *(void *)a2 = v9;
        *(void *)(a2 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v6;
        __int128 v9 = 0LL;
        unint64_t v10 = 0LL;
        uint64_t v7 = 1LL;
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    OPENSSL_free(v9);
  }

  return v7;
}

void sub_1875BC474( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t bssl::tls1_get_legacy_signature_algorithm(bssl *this, unsigned __int16 *a2, const evp_pkey_st *a3)
{
  int v4 = EVP_PKEY_id((uint64_t)a2);
  if (v4 == 6)
  {
    __int16 v5 = -255;
    goto LABEL_5;
  }

  if (v4 == 408)
  {
    __int16 v5 = 515;
LABEL_5:
    *(_WORD *)thiunsigned int s = v5;
    return 1LL;
  }

  return 0LL;
}

uint64_t bssl::tls1_choose_signature_algorithm( bssl *this, EVP_PKEY **a2, const ssl_credential_st *a3, unsigned __int16 *a4)
{
  uint64_t v7 = *(bssl **)this;
  if ((ssl_credential_st::UsesPrivateKey((ssl_credential_st *)a2) & 1) == 0)
  {
    int v12 = 228;
    int v13 = 4534;
LABEL_32:
    ERR_put_error(16, 0, v12, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", v13);
    return 0LL;
  }

  unsigned int v9 = bssl::ssl_protocol_version(v7, v8);
  if (v9 > 0x302)
  {
    if (*((_DWORD *)a2 + 1) == 1)
    {
      BOOL v14 = (char *)*((void *)this + 85);
      uint64_t v15 = *((void *)this + 86);
    }

    else
    {
      BOOL v16 = *((void *)this + 82) == 0LL;
      BOOL v17 = v9 == 771;
      if (v17 && v16) {
        uint64_t v15 = 2LL;
      }
      else {
        uint64_t v15 = *((void *)this + 82);
      }
      if (v17 && v16) {
        BOOL v14 = (char *)&bssl::tls1_choose_signature_algorithm(bssl::SSL_HANDSHAKE *,ssl_credential_st const*,unsigned short *)::kTLS12Default;
      }
      else {
        BOOL v14 = (char *)*((void *)this + 81);
      }
    }

    uint64_t v18 = (uint64_t)a2[5];
    if (v18)
    {
      uint64_t v19 = (__int16 *)a2[4];
    }

    else
    {
      uint64_t v19 = &bssl::kSignSignatureAlgorithms;
      uint64_t v18 = 12LL;
    }

    size_t v20 = &v19[v18];
    while (1)
    {
      int v21 = (unsigned __int16)*v19;
      if (bssl::ssl_pkey_supports_algorithm(v7, a2[1], (evp_pkey_st *)(unsigned __int16)*v19))
      {
        if (v15)
        {
          uint64_t v22 = 2 * v15;
          uint64_t v23 = v14;
          while (*(unsigned __int16 *)v23 != v21)
          {
            v23 += 2;
            v22 -= 2LL;
            if (!v22)
            {
              uint64_t v23 = &v14[2 * v15];
              break;
            }
          }
        }

        else
        {
          uint64_t v23 = v14;
        }

        if (v15 != (v23 - v14) >> 1) {
          break;
        }
      }

      if (++v19 == v20)
      {
        int v12 = 253;
        int v13 = 4579;
        goto LABEL_32;
      }
    }

    *(_WORD *)a3 = v21;
    return 1LL;
  }

  int v10 = EVP_PKEY_id((uint64_t)a2[1]);
  if (v10 == 6)
  {
    __int16 v11 = -255;
    goto LABEL_30;
  }

  if (v10 != 408)
  {
    int v12 = 253;
    int v13 = 4543;
    goto LABEL_32;
  }

  __int16 v11 = 515;
LABEL_30:
  *(_WORD *)a3 = v11;
  return 1LL;
}

uint64_t bssl::tls1_verify_channel_id(bssl **a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *a1;
  __int16 v29 = -21846;
  __int128 v28 = *(_OWORD *)(a2 + 8);
  unsigned int s = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u16((unsigned __int16 **)&v28, &v29)
    || !CBS_get_u16_length_prefixed((unsigned __int8 **)&v28, (unint64_t *)&s)
    || *((void *)&v28 + 1)
    || v29 != 30032
    || v27 != 128)
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4594);
    bssl::ssl_send_alert(v3, (ssl_st *)2, 50);
    return 0LL;
  }

  int v4 = EC_group_p256();
  __int16 v5 = ECDSA_SIG_new();
  char v25 = v5;
  unint64_t v6 = BN_new();
  uint64_t v24 = v6;
  uint64_t v7 = BN_new();
  uint64_t v8 = v7;
  uint64_t v23 = v7;
  if (!v5 || !v6 || !v7)
  {
    uint64_t v11 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v23 = 0LL;
    if (!v7) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  unsigned int v9 = s;
  if (BN_bin2bn(s, 32, v6)
    && BN_bin2bn(v9 + 32, 32, v8)
    && BN_bin2bn(v9 + 64, 32, v5->r)
    && BN_bin2bn(v9 + 96, 32, v5->s))
  {
    eckey = EC_KEY_new();
    int v10 = EC_POINT_new((const EC_GROUP *)v4);
    uint64_t v11 = 0LL;
    int v21 = v10;
    if (!eckey || !v10) {
      goto LABEL_34;
    }
    if (EC_POINT_set_affine_coordinates_GFp((const EC_GROUP *)v4, v10, v6, v8, 0LL))
    {
      if (EC_KEY_set_group(eckey, (const EC_GROUP *)v4))
      {
        if (EC_KEY_set_public_key(eckey, v21))
        {
          *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __int128 v32 = v13;
          __int128 v33 = v13;
          *(_OWORD *)dgst = v13;
          __int128 v31 = v13;
          *(void *)dgst_leuint64_t n = 0xAAAAAAAAAAAAAAAALL;
          if ((bssl::tls1_channel_id_hash(a1, (bssl::SSL_HANDSHAKE *)dgst, (unsigned __int8 *)dgst_len, v12) & 1) != 0)
          {
            if (ECDSA_do_verify(dgst, dgst_len[0], v5, eckey))
            {
              BOOL v14 = (_OWORD *)(*((void *)v3 + 6) + 520LL);
              __int128 v15 = *(_OWORD *)v9;
              __int128 v16 = *((_OWORD *)v9 + 1);
              __int128 v17 = *((_OWORD *)v9 + 3);
              void v14[2] = *((_OWORD *)v9 + 2);
              _OWORD v14[3] = v17;
              _OWORD *v14 = v15;
              v14[1] = v16;
              *(_WORD *)(*((void *)v3 + 6) + 220LL) |= 0x100u;
              uint64_t v11 = 1LL;
LABEL_34:
              std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100](&v21, 0LL);
              std::unique_ptr<ec_key_st,bssl::internal::Deleter>::reset[abi:ne180100](&eckey, 0LL);
              goto LABEL_26;
            }

            ERR_put_error(16, 0, 129, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4636);
            bssl::ssl_send_alert(v3, (ssl_st *)2, 51);
          }
        }
      }
    }

    uint64_t v11 = 0LL;
    goto LABEL_34;
  }

  uint64_t v11 = 0LL;
LABEL_26:
  uint64_t v23 = 0LL;
LABEL_27:
  BN_free(v8);
  uint64_t v18 = v11;
LABEL_28:
  uint64_t v24 = 0LL;
  if (v6) {
    BN_free(v6);
  }
  char v25 = 0LL;
  if (v5) {
    ECDSA_SIG_free(v5);
  }
  return v18;
}

void sub_1875BC9A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, EC_POINT *);
  va_copy(va2, va1);
  __int16 v5 = va_arg(va2, EC_KEY *);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, BIGNUM *);
  va_copy(va4, va3);
  unsigned int v9 = va_arg(va4, BIGNUM *);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va, 0LL);
  std::unique_ptr<ec_key_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_KEY **)va1, 0LL);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIGNUM **)va2, 0LL);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIGNUM **)va3, 0LL);
  std::unique_ptr<ecdsa_sig_st,bssl::internal::Deleter>::reset[abi:ne180100]((ECDSA_SIG **)va4, 0LL);
  _Unwind_Resume(a1);
}

uint64_t bssl::tls1_channel_id_hash( bssl **this, bssl::SSL_HANDSHAKE *a2, unsigned __int8 *a3, unint64_t *a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v7 = *this;
  if (bssl::ssl_protocol_version(*this, (const ssl_st *)a2) < 0x304)
  {
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&c.data[10] = v9;
    *(_OWORD *)&c.data[14] = v9;
    *(_OWORD *)&c.data[6] = v9;
    *(_OWORD *)&c.Nl = v9;
    *(_OWORD *)&c.data[2] = v9;
    *(_OWORD *)c.h = v9;
    *(_OWORD *)&c.h[4] = v9;
    SHA256_Init(&c);
    SHA256_Update(&c, "TLS Channel ID signature", 0x19uLL);
    if (*((void *)v7 + 13))
    {
      SHA256_Update(&c, "Resumption", 0xBuLL);
      uint64_t v10 = *((void *)v7 + 13);
      if (!*(_BYTE *)(v10 + 368))
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4713);
        return 0LL;
      }

      SHA256_Update(&c, (const void *)(v10 + 304), *(unsigned __int8 *)(v10 + 368));
    }

    *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    data[2] = v11;
    data[3] = v11;
    data[0] = v11;
    data[1] = v11;
    leuint64_t n = 0xAAAAAAAAAAAAAAAALL;
    uint64_t Hash = bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(this + 53), (unsigned __int8 *)data, &len);
    if ((_DWORD)Hash)
    {
      SHA256_Update(&c, data, len);
      SHA256_Final((unsigned __int8 *)a2, &c);
      *(void *)a3 = 32LL;
    }
  }

  else
  {
    *(void *)c.h = 0LL;
    *(void *)&c.h[2] = 0LL;
    uint64_t Hash = bssl::tls13_get_cert_verify_signature_input((uint64_t)this, (uint64_t)&c, 2u, 0LL, 0LL);
    if ((Hash & 1) != 0)
    {
      SHA256(*(const unsigned __int8 **)c.h, *(size_t *)&c.h[2], (unsigned __int8 *)a2);
      *(void *)a3 = 32LL;
    }

    OPENSSL_free(*(void **)c.h);
  }

  return Hash;
}

void sub_1875BCBD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL bssl::tls1_write_channel_id(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v24 = v6;
  __int128 v25 = v6;
  *(_OWORD *)dgst = v6;
  __int128 v23 = v6;
  *(void *)dgst_leuint64_t n = 0xAAAAAAAAAAAAAAAALL;
  if (!bssl::tls1_channel_id_hash( (bssl **)a1,  (bssl::SSL_HANDSHAKE *)dgst,  (unsigned __int8 *)dgst_len,  a4)) {
    return 0LL;
  }
  uint64_t v7 = (const EC_KEY *)EVP_PKEY_get0_EC_KEY(*(void *)(*(void *)(a1 + 8) + 120LL));
  if (!v7)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 4655);
    return 0LL;
  }

  uint64_t v8 = BN_new();
  size_t v20 = v8;
  __int128 v9 = BN_new();
  uint64_t v10 = v9;
  uint64_t v19 = v9;
  if (v8)
  {
    if (!v9)
    {
      BOOL v15 = 0LL;
      size_t v20 = 0LL;
LABEL_24:
      BN_free(v8);
      return v15;
    }

    __int128 v11 = EC_KEY_get0_group(v7);
    int v12 = EC_KEY_get0_public_key(v7);
    if (EC_POINT_get_affine_coordinates_GFp(v11, v12, v8, v10, 0LL)
      && (__int128 v13 = (uint64_t *)ECDSA_do_sign(dgst, dgst_len[0], v7), (v18 = v13) != 0LL))
    {
      *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v17[1] = v14;
      _OWORD v17[2] = v14;
      v17[0] = v14;
      BOOL v15 = CBB_add_u16((uint64_t)a2, 0x7550u)
         && CBB_add_u16_length_prefixed(a2, (uint64_t)v17)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, (uint64_t)v8)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, (uint64_t)v10)
         && BN_bn2cbb_padded((uint64_t)v17, 0x20uLL, *v13)
      uint64_t v18 = 0LL;
      ECDSA_SIG_free((ECDSA_SIG *)v13);
    }

    else
    {
      BOOL v15 = 0LL;
    }

    uint64_t v19 = 0LL;
  }

  else
  {
    uint64_t v19 = 0LL;
    BOOL v15 = 0LL;
    if (!v9) {
      return v15;
    }
  }

  BN_free(v10);
  size_t v20 = 0LL;
  if (v8) {
    goto LABEL_24;
  }
  return v15;
}

void sub_1875BCE14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19, int a20, __int16 a21, char a22, char a23)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t bssl::tls1_record_handshake_hashes_for_channel_id(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  if (*(void *)(*(void *)this + 104LL)) {
    return 0LL;
  }
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = bssl::SSLTranscript::GetHash( (bssl *)((char *)this + 424),  (unsigned __int8 *)(*((void *)this + 190) + 304LL),  &v4);
  if ((_DWORD)result) {
    *(_BYTE *)(*((void *)this + 190) + 368LL) = v4;
  }
  return result;
}

uint64_t bssl::ssl_is_sct_list_valid(__int128 *a1)
{
  __int128 v10 = *a1;
  uint64_t v8 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  int u16_length_prefixed = CBS_get_u16_length_prefixed((unsigned __int8 **)&v10, (unint64_t *)&v8);
  uint64_t result = 0LL;
  if (u16_length_prefixed)
  {
    if (!*((void *)&v10 + 1) && v9 != 0)
    {
      do
      {
        unint64_t v6 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
        else {
          BOOL v4 = 1;
        }
        uint64_t result = !v4;
      }

      while ((_DWORD)result == 1 && v9 != 0);
    }
  }

  return result;
}

uint64_t bssl::ext_sni_parse_clienthello()
{
  return 1LL;
}

uint64_t bssl::ext_sni_add_serverhello(_BYTE *a1, uint64_t a2)
{
  if ((*(_WORD *)(*(void *)(*(void *)a1 + 48LL) + 220LL) & 0x40) != 0 || (a1[1585] & 1) == 0) {
    return 1LL;
  }
  uint64_t result = CBB_add_u16(a2, 0);
  if ((_DWORD)result) {
    return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_ech_parse_clienthello(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a3) {
    return 1LL;
  }
  char v6 = -86;
  uint64_t result = CBS_get_u8(a3, &v6);
  if (!(_DWORD)result) {
    return result;
  }
  if (v6)
  {
    if (v6 != 1 || a3[1]) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 1584) |= 1u;
  }

  return 1LL;
}

uint64_t bssl::ext_ech_add_serverhello(uint64_t a1, ssl_st *a2)
{
  BOOL v4 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) < 0x304
    || *(_DWORD *)(*((void *)v4 + 6) + 216LL) == 1
    || !*(void *)(a1 + 1536))
  {
    return 1LL;
  }

  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[1] = v5;
  __int128 v12[2] = v5;
  unint64_t v11[2] = v5;
  v12[0] = v5;
  v11[0] = v5;
  v11[1] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0xFE0Du);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)&a2->version, (uint64_t)v12);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v12, (uint64_t)v11);
      if ((_DWORD)result)
      {
        uint64_t v7 = *(void *)(a1 + 1536);
        uint64_t v8 = *(void *)(v7 + 8);
        if (v8)
        {
          unint64_t v9 = *(const void ****)(v7 + 16);
          uint64_t v10 = 8 * v8;
          while (1)
          {
            if (*((_BYTE *)*v9 + 144))
            {
              uint64_t result = CBB_add_bytes((uint64_t)v11, **v9, (size_t)(*v9)[1]);
              if (!(_DWORD)result) {
                break;
              }
            }

            ++v9;
            v10 -= 8LL;
            if (!v10) {
              return CBB_flush((uint64_t *)&a2->version) != 0;
            }
          }
        }

        else
        {
          return CBB_flush((uint64_t *)&a2->version) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ems_parse_clienthello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  unsigned int v5 = bssl::ssl_protocol_version(*(bssl **)a1, a2);
  uint64_t result = 1LL;
  if (a3 && v5 <= 0x303)
  {
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    else {
      *(_DWORD *)(a1 + 1584) |= 0x10000u;
    }
  }

  return result;
}

uint64_t bssl::ext_ems_add_serverhello(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 1586) & 1) == 0) {
    return 1LL;
  }
  uint64_t result = CBB_add_u16(a2, 0x17u);
  if ((_DWORD)result) {
    return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_ri_parse_clienthello(bssl **a1, ssl_st *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if ((*(_WORD *)(*((void *)*a1 + 6) + 220LL) & 0x20) != 0) {
    bssl::ext_ri_parse_clienthello();
  }
  unsigned int v6 = bssl::ssl_protocol_version(*a1, a2);
  uint64_t result = 1LL;
  if (a3 && v6 <= 0x303)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    if (CBS_get_u8_length_prefixed((unsigned __int8 **)a3, &v8) && !*(void *)(a3 + 8))
    {
      if (v9)
      {
        ERR_put_error(16, 0, 202, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 836);
        uint64_t result = 0LL;
        LOBYTE(a2->version) = 40;
      }

      else
      {
        *(_WORD *)(*((void *)v3 + 6) + 220LL) |= 0x80u;
        return 1LL;
      }
    }

    else
    {
      ERR_put_error(16, 0, 201, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 829);
      return 0LL;
    }
  }

  return result;
}

uint64_t bssl::ext_ri_add_serverhello(bssl **a1, const ssl_st *a2)
{
  uint64_t v2 = *a1;
  if ((*(_WORD *)(*((void *)v2 + 6) + 220LL) & 0x20) != 0) {
    bssl::ext_ri_add_serverhello();
  }
  uint64_t result = CBB_add_u16((uint64_t)a2, 0xFF01u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16((uint64_t)a2, 1u);
    if ((_DWORD)result) {
      return CBB_add_u8((uint64_t)a2, 0) != 0;
    }
  }

  return result;
}

uint64_t bssl::ext_supported_groups_parse_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  int u16_length_prefixed = CBS_get_u16_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&v7);
  uint64_t result = 0LL;
  if (u16_length_prefixed && *((void *)&v7 + 1))
  {
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    else {
      return bssl::parse_u16_array(&v7, a1 + 664);
    }
  }

  return result;
}

uint64_t bssl::dont_add_serverhello()
{
  return 1LL;
}

uint64_t bssl::ext_ec_point_parse_clienthello(bssl **a1, ssl_st *a2, uint64_t a3)
{
  else {
    return 1LL;
  }
}

uint64_t bssl::ext_ec_point_add_serverhello(uint64_t a1, uint64_t *a2)
{
  if (bssl::ssl_protocol_version(*(bssl **)a1, (const ssl_st *)a2) <= 0x303
    && *(_DWORD *)(*(void *)(a1 + 1552) + 20LL) & 2 | *(_DWORD *)(*(void *)(a1 + 1552) + 24LL) & 4)
  {
    return bssl::ext_ec_point_add_extension(a2);
  }

  else
  {
    return 1LL;
  }

uint64_t bssl::ignore_parse_clienthello()
{
  return 1LL;
}

uint64_t bssl::ext_ticket_add_serverhello(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 1585) & 0x80) == 0) {
    return 1LL;
  }
  if ((SSL_get_options(*(void *)a1) & 0x4000) != 0) {
    bssl::ext_ticket_add_serverhello();
  }
  uint64_t result = CBB_add_u16(a2, 0x23u);
  if ((_DWORD)result) {
    return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_alpn_add_serverhello(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  if (!*(void *)(*(void *)(*a1 + 48) + 504LL)) {
    return 1LL;
  }
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v4;
  _OWORD v8[2] = v4;
  v8[0] = v4;
  v7[1] = v4;
  unint64_t v7[2] = v4;
  void v6[2] = v4;
  v7[0] = v4;
  v6[0] = v4;
  v6[1] = v4;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x10u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v8);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v8, (uint64_t)v7);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v7, (uint64_t)v6);
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_bytes( (uint64_t)v6,  *(const void **)(*(void *)(v2 + 48) + 496LL),  *(void *)(*(void *)(v2 + 48) + 504LL));
          if ((_DWORD)result) {
            return CBB_flush(a2) != 0;
          }
        }
      }
    }
  }

  return result;
}

BOOL bssl::ext_ocsp_parse_clienthello(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a3) {
    return 1LL;
  }
  char v6 = -86;
  int u8 = CBS_get_u8(a3, &v6);
  BOOL result = u8 != 0;
  if (u8) {
    *(_DWORD *)(a1 + 1bssl::Array<unsigned short>::~Array((uint64_t)this + 584) = *(_DWORD *)(a1 + 1584) & 0xFFFFFF7F | ((v6 == 1) << 7);
  }
  return result;
}

uint64_t bssl::ext_ocsp_add_serverhello(uint64_t a1, const ssl_st *a2)
{
  __int128 v4 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303
    || (*(_BYTE *)(a1 + 1584) & 0x80) == 0
    || (*(_WORD *)(*((void *)v4 + 6) + 220LL) & 0x40) != 0
    || !bssl::ssl_cipher_uses_certificate_auth(*(bssl **)(a1 + 1552), v5)
    || !*(void *)(*(void *)(a1 + 1504) + 80LL))
  {
    return 1LL;
  }

  *(_DWORD *)(a1 + 1584) |= 0x40u;
  uint64_t result = CBB_add_u16((uint64_t)a2, 5u);
  if ((_DWORD)result) {
    return CBB_add_u16((uint64_t)a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_sigalgs_parse_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = (_OWORD *)(a1 + 648);
  OPENSSL_free(*(void **)(a1 + 648));
  _OWORD *v5 = 0u;
  if (!a3) {
    return 1LL;
  }
  v7[0] = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CBS_get_u16_length_prefixed((unsigned __int8 **)a3, v7);
  if ((_DWORD)result)
  {
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    else {
      return bssl::tls1_parse_peer_sigalgs((bssl **)a1, (ssl_st *)v7);
    }
  }

  return result;
}

uint64_t bssl::ext_npn_parse_clienthello(uint64_t a1, const ssl_st *a2, uint64_t a3)
{
  unsigned int v5 = *(bssl **)a1;
  unsigned int v6 = bssl::ssl_protocol_version(*(bssl **)a1, a2);
  uint64_t result = 1LL;
  if (a3 && v6 <= 0x303)
  {
    if (*(void *)(a3 + 8))
    {
      return 0LL;
    }

    else if ((*(_WORD *)(*((void *)v5 + 6) + 220LL) & 0x20) == 0 && *(void *)(*((void *)v5 + 15) + 576LL))
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t bssl::ext_npn_add_serverhello(uint64_t *a1, uint64_t *a2)
{
  if ((*((_BYTE *)a1 + 1585) & 0x40) == 0) {
    return 1LL;
  }
  uint64_t v4 = *a1;
  unint64_t v9 = (const void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v8 = -1431655766;
  if ((*(unsigned int (**)(void))(*(void *)(v4 + 120) + 576LL))())
  {
    *((_DWORD *)a1 + 396) &= ~0x4000u;
    return 1LL;
  }

  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v6;
  unint64_t v7[2] = v6;
  v7[0] = v6;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x3374u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_bytes((uint64_t)v7, v9, v8);
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_sct_parse_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 1584) |= 4u;
  }

  return 1LL;
}

uint64_t bssl::ext_sct_add_serverhello(uint64_t a1, ssl_st *a2)
{
  if ((*(_BYTE *)(a1 + 1584) & 4) == 0) {
    bssl::ext_sct_add_serverhello();
  }
  uint64_t v4 = *(bssl **)a1;
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) > 0x303
    || (*(_WORD *)(*((void *)v4 + 6) + 220LL) & 0x40) != 0
    || !bssl::ssl_cipher_uses_certificate_auth(*(bssl **)(a1 + 1552), v5)
    || !*(void *)(*(void *)(a1 + 1504) + 72LL))
  {
    return 1LL;
  }

  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v6;
  __int128 v10[2] = v6;
  v10[0] = v6;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x12u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)&a2->version, (uint64_t)v10);
    if ((_DWORD)result)
    {
      unsigned int v8 = (const void *)CRYPTO_BUFFER_data(*(void *)(*(void *)(a1 + 1504) + 72LL));
      size_t v9 = CRYPTO_BUFFER_len(*(void *)(*(void *)(a1 + 1504) + 72LL));
      uint64_t result = CBB_add_bytes((uint64_t)v10, v8, v9);
      if ((_DWORD)result) {
        return CBB_flush((uint64_t *)&a2->version) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_channel_id_parse_clienthello(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  if (!*(void *)(a3 + 8))
  {
    *(_DWORD *)(a1 + 1584) |= 0x2000000u;
    return 1LL;
  }

  return 0LL;
}

uint64_t bssl::ext_channel_id_add_serverhello(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 1587) & 2) == 0) {
    return 1LL;
  }
  uint64_t result = CBB_add_u16(a2, 0x7550u);
  if ((_DWORD)result) {
    return CBB_add_u16(a2, 0) != 0;
  }
  return result;
}

uint64_t bssl::ext_srtp_parse_clienthello(unsigned __int8 ***a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = *a1;
    if (SSL_is_dtls(*a1))
    {
      memset(v19, 170, sizeof(v19));
      if (CBS_get_u16_length_prefixed((unsigned __int8 **)a3, &v19[2])
        && v19[3] >= 2
        && CBS_get_u8_length_prefixed((unsigned __int8 **)a3, v19)
        && !*(void *)(a3 + 8))
      {
        srtp_profileunsigned int s = (EVP_MD_CTX *)SSL_get_srtp_profiles((uint64_t)v4);
        unsigned int v8 = EVP_MD_CTX_md(srtp_profiles);
        if (v8)
        {
          uint64_t v10 = v8;
          unint64_t v11 = 0LL;
          while (1)
          {
            int v12 = OPENSSL_sk_value((unint64_t *)srtp_profiles, v11);
            char v9 = v19[2];
            __int128 v17 = (unsigned __int16 *)v19[2];
            unint64_t v18 = v19[3];
            if (v19[3]) {
              break;
            }
LABEL_18:
            if ((const EVP_MD *)++v11 == v10) {
              goto LABEL_19;
            }
          }

          __int128 v13 = v12;
          while (1)
          {
            unsigned __int16 v16 = -21846;
            int u16 = CBS_get_u16(&v17, &v16);
            char v9 = u16 != 0;
            if (!u16) {
              break;
            }
            if (v13[1] == v16)
            {
              *((void *)v4[6] + 75) = v13;
              break;
            }

            char v9 = v18;
            if (!v18) {
              goto LABEL_18;
            }
          }

          char v15 = 0;
        }

        else
        {
LABEL_19:
          char v15 = 1;
        }

        char v5 = v15 | v9;
      }

      else
      {
        ERR_put_error(16, 0, 116, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 1772);
        char v5 = 0;
      }
    }

    else
    {
      char v5 = 1;
    }
  }

  else
  {
    char v5 = 1;
  }

  return v5 & 1;
}

uint64_t bssl::ext_srtp_add_serverhello(unsigned __int8 ***a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  if (!*((void *)(*a1)[6] + 75)) {
    return 1LL;
  }
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v4;
  unint64_t v7[2] = v4;
  void v6[2] = v4;
  v7[0] = v4;
  v6[0] = v4;
  v6[1] = v4;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0xEu);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v7);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v7, (uint64_t)v6);
      if ((_DWORD)result)
      {
        uint64_t result = CBB_add_u16((uint64_t)v6, *(unsigned __int16 *)(*((void *)v2[6] + 75) + 8LL));
        if ((_DWORD)result)
        {
          uint64_t result = CBB_add_u8((uint64_t)v7, 0);
          if ((_DWORD)result) {
            return CBB_flush(a2) != 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_psk_key_exchange_modes_parse_clienthello(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  __unsigned int s = (void *)0xAAAAAAAAAAAAAAAALL;
  size_t __n = 0xAAAAAAAAAAAAAAAALL;
  if (CBS_get_u8_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&__s)
    && __n
    && !*(void *)(a3 + 8))
  {
    uint64_t v6 = 1LL;
    *(_DWORD *)(a1 + 1bssl::Array<unsigned short>::~Array((uint64_t)this + 584) = *(_DWORD *)(a1 + 1584) & 0xFFFFFFEF | (16 * (memchr(__s, 1, __n) != 0LL));
  }

  else
  {
    uint64_t v6 = 0LL;
    *a2 = 50;
  }

  return v6;
}

uint64_t bssl::ext_early_data_parse_clienthello(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  if (bssl::ssl_protocol_version(*(bssl **)a1, a2) >= 0x304)
  {
    if (*(void *)(a3 + 8))
    {
      uint64_t result = 0LL;
      LOBYTE(a2->version) = 50;
      return result;
    }

    *(_DWORD *)(a1 + 1584) |= 0x800u;
  }

  return 1LL;
}

uint64_t bssl::ext_early_data_add_serverhello(uint64_t a1, uint64_t *a2)
{
  if ((*(_WORD *)(*(void *)(*(void *)a1 + 48LL) + 220LL) & 0x400) == 0) {
    return 1LL;
  }
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x2Au);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16((uint64_t)a2, 0);
    if ((_DWORD)result) {
      return CBB_flush(a2) != 0;
    }
  }

  return result;
}

uint64_t bssl::ext_quic_transport_params_parse_clienthello(void *a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_clienthello_impl(a1, a2, a3, 0);
}

uint64_t bssl::ext_quic_transport_params_add_serverhello(void *a1, uint64_t *a2)
{
  return bssl::ext_quic_transport_params_add_serverhello_impl(a1, a2, 0);
}

uint64_t bssl::ext_quic_transport_params_parse_clienthello_legacy(void *a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_quic_transport_params_parse_clienthello_impl(a1, a2, a3, 1);
}

uint64_t bssl::ext_quic_transport_params_add_serverhello_legacy(void *a1, uint64_t *a2)
{
  return bssl::ext_quic_transport_params_add_serverhello_impl(a1, a2, 1);
}

uint64_t bssl::cert_compression_parse_clienthello(bssl **a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v5 = *((void *)*a1 + 15);
  unint64_t v6 = *(void *)(v5 + 704);
  unint64_t v27 = (unsigned __int16 *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  if (!CBS_get_u8_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&v27)
    || *(void *)(a3 + 8))
  {
    return 0LL;
  }

  uint64_t v7 = 0LL;
  unint64_t v9 = v28;
  if (v28 && (v28 & 1) == 0)
  {
    unint64_t v10 = v28 >> 1;
    __base = 0LL;
    size_t __nel = 0LL;
    if (bssl::Array<unsigned short>::Init((uint64_t)&__base, v28 >> 1))
    {
      if (v28)
      {
        uint64_t v11 = 0LL;
        unint64_t v12 = v6;
        while (1)
        {
          unsigned __int16 v24 = -21846;
          __int128 v13 = __base;
          *((_WORD *)__base + v11) = v24;
          if (v6)
          {
            unint64_t v14 = 0LL;
            char v15 = (unsigned __int16 *)(*(void *)(v5 + 712) + 16LL);
            while (*v15 != v24 || *((void *)v15 - 2) == 0LL)
            {
              ++v14;
              v15 += 12;
              if (v6 == v14) {
                goto LABEL_24;
              }
            }

            if (v14 < v12) {
              unint64_t v12 = v14;
            }
          }

void sub_1875BDFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t bssl::cert_compression_add_serverhello()
{
  return 1LL;
}

uint64_t bssl::ext_delegated_credential_parse_clienthello(bssl **a1, const ssl_st *a2, uint64_t a3)
{
  if (!a3) {
    return 1LL;
  }
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  int u16_length_prefixed = CBS_get_u16_length_prefixed((unsigned __int8 **)a3, (unint64_t *)&v7);
  uint64_t result = 0LL;
  if (u16_length_prefixed && *((void *)&v7 + 1))
  {
    if (*(void *)(a3 + 8)) {
      return 0LL;
    }
    else {
      return bssl::parse_u16_array(&v7, (uint64_t)(a1 + 85));
    }
  }

  return result;
}

uint64_t bssl::ext_alps_add_serverhello(void *a1, uint64_t *a2)
{
  return bssl::ext_alps_add_serverhello_impl(a1, a2, 1);
}

uint64_t bssl::ext_client_certificate_type_parse_clienthello(uint64_t a1, _BYTE *a2, unsigned __int8 **a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 200);
  if (!v5) {
    return 1LL;
  }
  v11[0] = *(void *)(v4 + 192);
  v11[1] = v5;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int8 v8 = -86;
  while (v10 && CBS_get_u8(&v9, &v8))
  {
    if (bssl::ssl_is_certificate_type_allowed(v11, v8))
    {
      *(_BYTE *)(a1 + 731) = v8;
      *(_DWORD *)(a1 + 1584) |= 0x400000u;
      return 1LL;
    }
  }

  uint64_t result = 0LL;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_client_certificate_type_add_serverhello(uint64_t a1, uint64_t *a2)
{
  if ((*(_BYTE *)(a1 + 1586) & 0x40) == 0) {
    return 1LL;
  }
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v5;
  void v6[2] = v5;
  v6[0] = v5;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x13u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v6);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8((uint64_t)v6, *(unsigned __int8 *)(a1 + 731));
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_server_certificate_type_parse_clienthello(uint64_t a1, _BYTE *a2, unsigned __int8 **a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 176);
  if (!v5) {
    return 1LL;
  }
  v11[0] = *(void *)(v4 + 168);
  v11[1] = v5;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int8 v8 = -86;
  while (v10 && CBS_get_u8(&v9, &v8))
  {
    if (bssl::ssl_is_certificate_type_allowed(v11, v8))
    {
      *(_BYTE *)(a1 + 730) = v8;
      *(_DWORD *)(a1 + 1584) |= 0x200000u;
      return 1LL;
    }
  }

  uint64_t result = 0LL;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_server_certificate_type_add_serverhello(unsigned __int8 *a1, uint64_t *a2)
{
  if ((a1[1586] & 0x20) == 0 || (*(_WORD *)(*(void *)(*(void *)a1 + 48LL) + 220LL) & 0x40) != 0) {
    return 1LL;
  }
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v4;
  void v6[2] = v4;
  v6[0] = v4;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x14u);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v6);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8((uint64_t)v6, a1[730]);
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_ticket_request_parse_clienthello(uint64_t a1, _BYTE *a2, void *a3)
{
  if (!a3) {
    return 1LL;
  }
  char v8 = -86;
  char v7 = -86;
  if (CBS_get_u8(a3, &v8) && CBS_get_u8(a3, &v7))
  {
    *(_BYTE *)(a1 + 7bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v8;
    *(_BYTE *)(a1 + 733) = v7;
    return 1LL;
  }

  uint64_t result = 0LL;
  *a2 = 47;
  return result;
}

uint64_t bssl::ext_ticket_request_add_serverhello(uint64_t a1, uint64_t *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 732);
  int v3 = *(unsigned __int8 *)(a1 + 733);
  if (!(v2 | v3)) {
    return 1LL;
  }
  unsigned int v6 = v3 + v2;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = v7;
  __int128 v9[2] = v7;
  if (v6 >= 0xFF) {
    unsigned __int8 v8 = -1;
  }
  else {
    unsigned __int8 v8 = v6;
  }
  v9[0] = v7;
  uint64_t result = CBB_add_u16((uint64_t)a2, 0x3Au);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v9);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u8((uint64_t)v9, v8);
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_alps_add_clienthello_old(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::ext_alps_add_clienthello_impl(a1, a3, 0);
}

uint64_t bssl::ext_alps_parse_serverhello_old(uint64_t a1, ssl_st *a2, uint64_t a3)
{
  return bssl::ext_alps_parse_serverhello_impl(a1, a2, a3, 0);
}

uint64_t bssl::ext_alps_add_serverhello_old(void *a1, uint64_t *a2)
{
  return bssl::ext_alps_add_serverhello_impl(a1, a2, 0);
}

uint64_t bssl::ext_quic_transport_params_parse_clienthello_impl(void *a1, ssl_st *a2, uint64_t a3, int a4)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *(void *)(*a1 + 168LL);
  if (!a3)
  {
    uint64_t v14 = a1[1];
    if (v8)
    {
      if (((*(_WORD *)(v14 + 301) & 0x200) == 0) == a4) {
        return 1LL;
      }
      uint64_t result = 0LL;
      char v15 = 109;
    }

    else
    {
      if (!*(void *)(v14 + 232)) {
        return 1LL;
      }
      ERR_put_error(16, 0, 305, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2685);
      uint64_t result = 0LL;
      char v15 = 80;
    }

uint64_t bssl::ext_quic_transport_params_add_serverhello_impl(void *a1, uint64_t *a2, int a3)
{
  uint64_t v5 = *(void *)(*a1 + 168LL);
  if (!v5 && (a3 & 1) != 0) {
    return 1LL;
  }
  if (!v5) {
    bssl::ext_quic_transport_params_add_serverhello_impl();
  }
  uint64_t v6 = a1[1];
  if (!*(void *)(v6 + 232))
  {
    ERR_put_error(16, 0, 305, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 2738);
    return 0LL;
  }

  unsigned int v7 = *(_WORD *)(v6 + 301) & 0x200;
  if (a3 != v7 >> 9) {
    return 1LL;
  }
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = v8;
  void v11[2] = v8;
  v11[0] = v8;
  if (v7) {
    unsigned int v9 = 65445;
  }
  else {
    unsigned int v9 = 57;
  }
  uint64_t result = CBB_add_u16((uint64_t)a2, v9);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v11);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_bytes((uint64_t)v11, *(const void **)(a1[1] + 224LL), *(void *)(a1[1] + 232LL));
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ext_alps_add_clienthello_impl(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (!*(void *)(v4 + 136)) {
    return 1LL;
  }
  if (!*(void *)(v4 + 144)) {
    return 1LL;
  }
  if ((*(_WORD *)(*(void *)(*(void *)a1 + 48LL) + 220LL) & 0x20) != 0) {
    return 1LL;
  }
  unsigned int v5 = *(_WORD *)(v4 + 301) & 0x2000;
  if (a3 != v5 >> 13) {
    return 1LL;
  }
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[1] = v7;
  _OWORD v16[2] = v7;
  v16[0] = v7;
  v15[1] = v7;
  _OWORD v15[2] = v7;
  void v14[2] = v7;
  v15[0] = v7;
  if (v5) {
    unsigned int v8 = 17613;
  }
  else {
    unsigned int v8 = 17513;
  }
  v14[0] = v7;
  v14[1] = v7;
  uint64_t result = CBB_add_u16((uint64_t)a2, v8);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v16);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_u16_length_prefixed((uint64_t *)v16, (uint64_t)v15);
      if ((_DWORD)result)
      {
        uint64_t v10 = *(void *)(a1 + 8);
        uint64_t v11 = *(void *)(v10 + 144);
        if (v11)
        {
          uint64_t v12 = *(void *)(v10 + 152);
          uint64_t v13 = v12 + 32 * v11;
          while (1)
          {
            uint64_t result = CBB_add_u8_length_prefixed((uint64_t *)v15, (uint64_t)v14);
            if (!(_DWORD)result) {
              break;
            }
            uint64_t result = CBB_add_bytes((uint64_t)v14, *(const void **)v12, *(void *)(v12 + 8));
            if (!(_DWORD)result) {
              break;
            }
            v12 += 32LL;
            if (v12 == v13) {
              return CBB_flush(a2) != 0;
            }
          }
        }

        else
        {
          return CBB_flush(a2) != 0;
        }
      }
    }
  }

  return result;
}

uint64_t bssl::ext_alps_parse_serverhello_impl(uint64_t a1, ssl_st *a2, uint64_t a3, int a4)
{
  if (!a3) {
    return 1LL;
  }
  unsigned int v5 = *(bssl **)a1;
  if ((*(_WORD *)(*((void *)v5 + 6) + 220LL) & 0x20) != 0) {
    bssl::ext_alps_parse_serverhello_impl();
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (!*(void *)(v6 + 136)) {
    bssl::ext_alps_parse_serverhello_impl();
  }
  if (!*(void *)(v6 + 144)) {
    bssl::ext_alps_parse_serverhello_impl();
  }
  if (bssl::ssl_protocol_version(v5, a2) <= 0x303)
  {
    LOBYTE(a2->version) = 110;
    ERR_put_error(16, 0, 222, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/extensions.cc", 3005);
    return 0LL;
  }

  uint64_t v10 = (void **)(*(void *)(a1 + 1520) + 424LL);
  uint64_t v12 = *(const void **)a3;
  unint64_t v11 = *(void *)(a3 + 8);
  int v13 = bssl::Array<unsigned char>::Init((uint64_t)v10, v11);
  char v14 = v13;
  if (v11)
  {
    if (v13) {
      memmove(*v10, v12, v11);
    }
  }

  if ((v14 & 1) != 0)
  {
    *(_BYTE *)(*(void *)(a1 + 1520) + 440LL) |= 0x40u;
    return 1LL;
  }

  uint64_t result = 0LL;
  LOBYTE(a2->version) = 80;
  return result;
}

uint64_t bssl::ext_alps_add_serverhello_impl(void *a1, uint64_t *a2, int a3)
{
  uint64_t v3 = a1[190];
  if (!v3) {
    return 1LL;
  }
  if ((*(_BYTE *)(v3 + 440) & 0x40) == 0) {
    return 1LL;
  }
  if ((*(_WORD *)(*(void *)(*a1 + 48LL) + 220LL) & 0x400) != 0) {
    return 1LL;
  }
  unsigned int v5 = *(_WORD *)(a1[1] + 301LL) & 0x2000;
  if (a3 != v5 >> 13) {
    return 1LL;
  }
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[1] = v7;
  __int128 v10[2] = v7;
  v10[0] = v7;
  if (v5) {
    unsigned int v8 = 17613;
  }
  else {
    unsigned int v8 = 17513;
  }
  uint64_t result = CBB_add_u16((uint64_t)a2, v8);
  if ((_DWORD)result)
  {
    uint64_t result = CBB_add_u16_length_prefixed(a2, (uint64_t)v10);
    if ((_DWORD)result)
    {
      uint64_t result = CBB_add_bytes((uint64_t)v10, *(const void **)(a1[190] + 408LL), *(void *)(a1[190] + 416LL));
      if ((_DWORD)result) {
        return CBB_flush(a2) != 0;
      }
    }
  }

  return result;
}

uint64_t bssl::ssl_is_certificate_type_allowed(void *a1, int a2)
{
  unsigned __int8 v5 = -86;
  while (a1[1])
  {
    uint64_t result = CBS_get_u8(a1, &v5);
    if (!(_DWORD)result) {
      return result;
    }
    if (v5 == a2) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t bssl::decrypt_ticket_with_cipher_ctx( uint64_t a1, EVP_CIPHER_CTX *ctx, HMAC_CTX *a3, const unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  unsigned int v10 = EVP_CIPHER_CTX_iv_length(ctx);
  unint64_t v11 = HMAC_size(&a3->md);
  if (a5 < v11 + v10 + 17) {
    return 2LL;
  }
  uint64_t v12 = v11;
  size_t v13 = a5 - v11;
  if (a5 < v11) {
    abort();
  }
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v27 = v14;
  __int128 v28 = v14;
  *(_OWORD *)mint d = v14;
  __int128 v26 = v14;
  HMAC_Update(a3, a4, v13);
  HMAC_Final(a3, md, 0LL);
  unint64_t v17 = v10 + 16LL;
  if (v13 < v17) {
    abort();
  }
  out = 0LL;
  unint64_t v24 = 0LL;
  if (v13 - v17 <= 0x7FFFFFFE)
  {
    char v19 = bssl::Array<unsigned char>::Init((uint64_t)&out, v13 - v17);
    uint64_t v18 = out;
    if ((v19 & 1) != 0)
    {
      int v21 = -1431655766;
      int outl = -1431655766;
      if (EVP_DecryptUpdate(ctx, out, &outl, &a4[v17], v13 - v17) && EVP_DecryptFinal_ex(ctx, &out[outl], &v21))
      {
        unint64_t v24 = v21 + (uint64_t)outl;
        OPENSSL_free(*(void **)a1);
        uint64_t v18 = 0LL;
        uint64_t v15 = 0LL;
        unint64_t v20 = v24;
        *(void *)a1 = out;
        *(void *)(a1 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v20;
        out = 0LL;
        unint64_t v24 = 0LL;
      }

      else
      {
        ERR_clear_error();
        uint64_t v15 = 2LL;
        uint64_t v18 = out;
      }
    }

    else
    {
      uint64_t v15 = 3LL;
    }
  }

  else
  {
    uint64_t v18 = 0LL;
    uint64_t v15 = 2LL;
  }

  OPENSSL_free(v18);
  return v15;
}

void sub_1875BEBD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

pthread_rwlock_t **bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase( pthread_rwlock_t **a1, pthread_rwlock_t *a2)
{
  *a1 = a2;
  if (!a2) {
    bssl::internal::MutexLockBase<&(CRYPTO_MUTEX_lock_read),&(CRYPTO_MUTEX_unlock_read)>::MutexLockBase();
  }
  CRYPTO_MUTEX_lock_read(a2);
  return a1;
}

void std::unique_ptr<ec_key_st,bssl::internal::Deleter>::reset[abi:ne180100](EC_KEY **a1, EC_KEY *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    EC_KEY_free(v3);
  }
}

void std::unique_ptr<ecdsa_sig_st,bssl::internal::Deleter>::reset[abi:ne180100]( ECDSA_SIG **a1, ECDSA_SIG *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    ECDSA_SIG_free(v3);
  }
}

void std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](BIGNUM **a1, BIGNUM *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    BN_free(v3);
  }
}

void std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100](EC_POINT **a1, EC_POINT *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    EC_POINT_free(v3);
  }
}

uint64_t bssl::read_v2_client_hello(uint64_t a1, unint64_t *a2, _BYTE *a3, unint64_t a4)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  *a2 = 0LL;
  if (a4 <= 4) {
    bssl::read_v2_client_hello();
  }
  unint64_t v4 = a3[1] | ((unint64_t)(*a3 & 0x7F) << 8);
  if (v4 > 0x1000)
  {
    int v5 = 200;
    int v6 = 362;
LABEL_6:
    ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v6);
    return 4LL;
  }

  if (v4 <= 2)
  {
    int v5 = 199;
    int v6 = 369;
    goto LABEL_6;
  }

  unint64_t v10 = v4 + 2;
  if (a4 < v4 + 2)
  {
    *a2 = v10;
    return 2LL;
  }

  uint64_t v12 = *(void *)(a1 + 48);
  unint64_t v13 = *(unsigned __int16 *)(v12 + 92);
  if (v13 <= 1) {
    abort();
  }
  __int128 v14 = (const void *)(*(void *)(v12 + 80) + *(unsigned __int16 *)(v12 + 88) + 2LL);
  unint64_t v15 = v13 - 2;
  if (v15 >= v4) {
    unint64_t v16 = a3[1] | ((unint64_t)(*a3 & 0x7F) << 8);
  }
  else {
    unint64_t v16 = v15;
  }
  unint64_t v40 = (unsigned __int16 *)(*(void *)(v12 + 80) + *(unsigned __int16 *)(v12 + 88) + 2LL);
  unint64_t v41 = v16;
  if (bssl::SSLTranscript::Update((void **)(*(void *)(v12 + 280) + 424LL), v14, v16))
  {
    bssl::ssl_do_msg_callback(a1, 0LL, 0LL, (uint64_t)v14, v16);
    char v39 = -86;
    unsigned __int16 v38 = -21846;
    unsigned __int16 v37 = -21846;
    unsigned __int16 v36 = -21846;
    unsigned __int16 v35 = -21846;
    memset(v34, 170, sizeof(v34));
    __int128 v32 = (const void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
    if (!CBS_get_u8(&v40, &v39)
      || !CBS_get_u16(&v40, &v38)
      || !CBS_get_u16(&v40, &v37)
      || !CBS_get_u16(&v40, &v36)
      || !CBS_get_u16(&v40, &v35)
      || !CBS_get_bytes((uint64_t *)&v40, &v34[2], v37)
      || !CBS_get_bytes((uint64_t *)&v40, v34, v36)
      || !CBS_get_bytes((uint64_t *)&v40, &v32, v35)
      || v41)
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 402);
      return 4LL;
    }

    if (v39 != 1) {
      bssl::read_v2_client_hello();
    }
    if (v33 >= 0x20) {
      size_t v17 = 32LL;
    }
    else {
      size_t v17 = v33;
    }
    memset(v42, 0, 32);
    if (v17) {
      memcpy(&v42[-v17 + 32], v32, v17);
    }
    uint64_t v18 = v34[3];
    *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    _OWORD v31[2] = v19;
    v31[0] = v19;
    v31[1] = v19;
    CBB_zero(v31);
    *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v30[1] = v20;
    _OWORD v30[2] = v20;
    _OWORD v29[2] = v20;
    v30[0] = v20;
    v29[0] = v20;
    v29[1] = v20;
    uint64_t v21 = *(void *)(a1 + 48);
    uint64_t v24 = *(void *)(v21 + 224);
    int v23 = (BUF_MEM **)(v21 + 224);
    uint64_t v22 = v24;
    if (v24
      || (__int128 v25 = BUF_MEM_new(),
          std::unique_ptr<buf_mem_st,bssl::internal::Deleter>::reset[abi:ne180100](v23, v25),
          (uint64_t v22 = *(void *)(*(void *)(a1 + 48) + 224LL)) != 0))
    {
      if (BUF_MEM_reserve( v22,  ((((unint64_t)v18 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) & 0xFFFFFFFFFFFFFFFELL)
                         + 43)
        && CBB_init_fixed( (uint64_t)v31,  *(void *)(*(void *)(*(void *)(a1 + 48) + 224LL) + 8LL),  *(void *)(*(void *)(*(void *)(a1 + 48) + 224LL) + 16LL))
        && CBB_add_u8((uint64_t)v31, 1u)
        && CBB_add_u24_length_prefixed((uint64_t *)v31, (uint64_t)v30)
        && CBB_add_u16((uint64_t)v30, v38)
        && CBB_add_bytes((uint64_t)v30, v42, 0x20uLL)
        && CBB_add_u8((uint64_t)v30, 0)
        && CBB_add_u16_length_prefixed((uint64_t *)v30, (uint64_t)v29))
      {
        if (v34[3])
        {
          while (1)
          {
            int v28 = -1431655766;
            if (!CBS_get_u24(&v34[2], &v28))
            {
              int v26 = 449;
              int v27 = 137;
              goto LABEL_55;
            }

            if (!v34[3]) {
              goto LABEL_46;
            }
          }

          int v26 = 458;
          int v27 = 68;
LABEL_55:
          ERR_put_error(16, 0, v27, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", v26);
        }

        else
        {
LABEL_46:
          if (CBB_add_u8((uint64_t)v30, 1u)
            && CBB_add_u8((uint64_t)v30, 0)
            && CBB_finish((uint64_t)v31, 0LL, *(void **)(*(void *)(a1 + 48) + 224LL)))
          {
            *a2 = v10;
            uint64_t v7 = 0LL;
            *(_WORD *)(*(void *)(a1 + 48) + 220LL) |= 8u;
LABEL_57:
            CBB_cleanup((uint64_t)v31);
            return v7;
          }

          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_both.cc", 467);
        }
      }
    }

    uint64_t v7 = 4LL;
    goto LABEL_57;
  }

  return 4LL;
}

void sub_1875BF130( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

uint64_t bssl::ssl_tls13_cipher_meets_policy(int a1, int a2)
{
  switch(a2)
  {
    case 0:
      return 1LL;
    case 2:
      LOBYTE(v2) = a1 - 1;
      break;
    case 1:
      unsigned int v2 = 3u >> ((a1 - 1) & 7);
      break;
    default:
      bssl::ssl_tls13_cipher_meets_policy();
  }

  return v2 & 1;
}

uint64_t bssl::ssl_choose_tls13_cipher(unsigned __int16 *a1, uint64_t a2, char a3, unsigned int a4, int a5)
{
  uint64_t v5 = 0LL;
  size_t v17 = a1;
  uint64_t v18 = a2;
  if ((a2 & 1) == 0 && a2)
  {
    uint64_t v5 = 0LL;
    int v9 = 0;
    unsigned __int8 v10 = 0;
    do
    {
      unsigned __int16 v16 = -21846;
      cipher_by_value = SSL_get_cipher_by_value(v16);
      if (cipher_by_value)
      {
        uint64_t v12 = (uint64_t)cipher_by_value;
        if (SSL_CIPHER_get_min_version(cipher_by_value) <= a4
          && SSL_CIPHER_get_max_version(v12) >= a4)
        {
          int protocol_id = SSL_CIPHER_get_protocol_id(v12);
          if (bssl::ssl_tls13_cipher_meets_policy(protocol_id, a5))
          {
            if ((a3 & 1) != 0)
            {
              unsigned int v14 = 1;
              if (!v9) {
                goto LABEL_14;
              }
            }

            else
            {
              unsigned int v14 = *(_DWORD *)(v12 + 28) == 64;
              if (!v9) {
                goto LABEL_14;
              }
            }

            if (v14 > v10)
            {
LABEL_14:
              int v9 = 1;
              unsigned __int8 v10 = v14;
              uint64_t v5 = v12;
            }
          }
        }
      }
    }

    while (v18);
  }

  return v5;
}

uint64_t bn_abs_sub_part_words( unint64_t *a1, const unint64_t *a2, const unint64_t *a3, unsigned int a4, signed int a5, unint64_t *a6)
{
  unint64_t v12 = bn_sub_part_words(a6, a2, a3, a4, a5);
  bn_sub_part_words(a1, a3, a2, a4, -a5);
  if (a5 >= 0) {
    int v13 = a5;
  }
  else {
    int v13 = -a5;
  }
  bn_select_words((uint64_t *)a1, -(uint64_t)v12, (uint64_t *)a1, (uint64_t *)a6, (int)(v13 + a4));
  return -(uint64_t)v12;
}

int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  int result = bn_mul_impl(r, (BIGNUM *)a, (BIGNUM *)b, ctx);
  if (result)
  {
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }

  return result;
}

uint64_t bn_mul_impl(BIGNUM *a1, BIGNUM *a2, BIGNUM *a3, BN_CTX *ctx)
{
  unint64_t top = a2->top;
  int v6 = a3->top;
  if ((_DWORD)top) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    BN_CTX_start(ctx);
    if (a1 == a2 || (unint64_t v12 = a1, a1 == a3))
    {
      unint64_t v12 = BN_CTX_get(ctx);
      if (!v12) {
        goto LABEL_45;
      }
    }

    v12->int neg = a3->neg ^ a2->neg;
    if ((_DWORD)top == 8 && v6 == 8)
    {
      v12->unint64_t top = 16;
      bn_mul_comba8(v12->d, a2->d, a3->d);
    }

    else
    {
      int v13 = v6 + top;
      if ((int)top < 16 || v6 < 16 || (top - v6 + 1) > 2)
      {
        v12->unint64_t top = v13;
        bn_mul_normal(v12->d, a2->d, top, a3->d, v6);
      }

      else
      {
        else {
          unint64_t v14 = v6;
        }
        char v15 = BN_num_bits_word(v14) - 1;
        int v16 = 1 << v15;
        uint64_t v18 = BN_CTX_get(ctx);
        if (!v18) {
          goto LABEL_45;
        }
        p_int d = &v18->d;
        if ((int)top <= v16 && v6 <= v16)
        {
          bn_mul_recursive(v12->d, a2->d, a3->d, v16, (top - v16), (v6 - v16), *p_d, v23);
        }

        else
        {
          bn_mul_part_recursive(v12->d, a2->d, (uint64_t)a3->d, v16, top - v16, v6 - v16, *p_d, v22);
        }

        v12->unint64_t top = v6 + top;
      }
    }

    if (v12 == a1 || BN_copy(a1, v12))
    {
      uint64_t v8 = 1LL;
LABEL_46:
      BN_CTX_end(ctx);
      return v8;
    }

uint64_t bn_mul_consttime(BIGNUM *a1, BIGNUM *a2, BIGNUM *a3, BN_CTX *a4)
{
  if (!a2->neg && !a3->neg) {
    return bn_mul_impl(a1, a2, a3, a4);
  }
  ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/fipsmodule/bn/mul.c", 524);
  return 0LL;
}

void bn_mul_small( unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t a4, unint64_t *a5, unint64_t a6)
{
  if (a6 + a4 != a2) {
    abort();
  }
  if (a4 == 8 && a6 == 8) {
    bn_mul_comba8(a1, a3, a5);
  }
  else {
    bn_mul_normal(a1, a3, a4, a5, a6);
  }
}

void bn_mul_normal( unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  if (a3 < a5) {
    unint64_t v6 = a5;
  }
  else {
    unint64_t v6 = a3;
  }
  if (a3 < a5) {
    BOOL v7 = a2;
  }
  else {
    BOOL v7 = a4;
  }
  if (a3 < a5) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a5;
  }
  if (a3 < a5) {
    int v9 = a4;
  }
  else {
    int v9 = a2;
  }
  if (v8)
  {
    a1[v6] = bn_mul_words(a1, v9, v6, *v7);
    if (v8 != 1)
    {
      uint64_t v10 = 0LL;
      unint64_t v11 = v7 + 2;
      unint64_t v12 = 4 - v8;
      int v13 = &a1[v6 + 4];
      do
      {
        v13[v10 - 3] = bn_mul_add_words(&a1[v10 + 1], v9, v6, v11[v10 - 1]);
        if (v12 == 2) {
          break;
        }
        v13[v10 - 2] = bn_mul_add_words(&a1[v10 + 2], v9, v6, v11[v10]);
        if (v12 == 1) {
          break;
        }
        v13[v10 - 1] = bn_mul_add_words(&a1[v10 + 3], v9, v6, v11[v10 + 1]);
        if (!v12) {
          break;
        }
        v13[v10] = bn_mul_add_words(&a1[v10 + 4], v9, v6, v11[v10 + 2]);
        v12 += 4LL;
        v10 += 4LL;
      }

      while (v12 != 3);
    }
  }

  else if (8 * v6)
  {
    bzero(a1, 8 * v6);
  }

uint64_t bn_sqr_consttime(BIGNUM *a1, BIGNUM *a2, BN_CTX *ctx)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  unint64_t top = a2->top;
  if ((int)top > 0)
  {
    BN_CTX_start(ctx);
    BOOL v7 = a1;
    if (a2 == a1) {
      BOOL v7 = BN_CTX_get(ctx);
    }
    unint64_t v8 = BN_CTX_get(ctx);
    uint64_t v9 = 0LL;
    if (!v7) {
      goto LABEL_24;
    }
    uint64_t v10 = v8;
    if (!v8) {
      goto LABEL_24;
    }
    if ((_DWORD)top == 8)
    {
      bn_sqr_comba8(v7->d, a2->d);
      goto LABEL_20;
    }

    if ((_DWORD)top == 4)
    {
      bn_sqr_comba4(v7->d, a2->d);
      goto LABEL_20;
    }

    if (top > 0xF)
    {
      if ((top & ((_DWORD)top - 1)) == 0)
      {
        bn_sqr_recursive(v7->d, a2->d, top, v10->d);
LABEL_20:
        v7->int neg = 0;
        v7->unint64_t top = 2 * top;
        if (v7 == a1 || BN_copy(a1, v7))
        {
          uint64_t v9 = 1LL;
LABEL_24:
          BN_CTX_end(ctx);
          return v9;
        }

unint64_t *bn_sqr_normal(unint64_t *rp, uint64_t a2, unint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    BOOL v7 = rp;
    int v8 = 2 * a3;
    rp[2 * a3 - 1] = 0LL;
    *rp = 0LL;
    unint64_t v9 = a3 - 1;
    if (v9)
    {
      rp[a3] = bn_mul_words(rp + 1, (const unint64_t *)(a2 + 8), v9, *(void *)a2);
      if (a3 >= 3)
      {
        unint64_t v10 = a3 - 2;
        __int128 v11 = v7 + 3;
        unint64_t v12 = &v7[a3 + 1];
        int v13 = (const unint64_t *)(a2 + 16);
        do
        {
          *v12++ = bn_mul_add_words(v11, v13, v10, *(v13 - 1));
          v11 += 2;
          ++v13;
          --v10;
        }

        while (v10);
      }
    }

    bn_add_words(v7, v7, v7, v8);
    bn_sqr_words(a4, (const unint64_t *)a2, a3);
    return (unint64_t *)bn_add_words(v7, v7, a4, v8);
  }

  return rp;
}

unint64_t *bn_sqr_recursive( unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t *a4)
{
  if ((a3 & (a3 - 1)) != 0) {
    bn_sqr_recursive_cold_1();
  }
  if (a3 == 8) {
    return bn_sqr_comba8(a1, a2);
  }
  if (a3 <= 0xF) {
    return bn_sqr_normal(a1, (uint64_t)a2, a3, a4);
  }
  unint64_t v9 = a3 >> 1;
  unint64_t v10 = bn_sub_words(&a4[a3 >> 1], a2, &a2[a3 >> 1], a3 >> 1);
  bn_sub_words(a4, &a2[a3 >> 1], a2, a3 >> 1);
  bn_select_words((uint64_t *)a4, -(uint64_t)v10, (uint64_t *)a4, (uint64_t *)&a4[a3 >> 1], a3 >> 1);
  __int128 v11 = &a4[a3];
  bn_sqr_recursive(v11, a4, a3 >> 1, &a4[2 * a3]);
  bn_sqr_recursive(a1, a2, a3 >> 1, &a4[2 * a3]);
  bn_sqr_recursive(&a1[a3], &a2[a3 >> 1], a3 >> 1, &a4[2 * a3]);
  unint64_t v12 = bn_add_words(a4, a1, &a1[a3], a3);
  unint64_t v13 = v12 - bn_sub_words(v11, a4, v11, a3);
  int result = (unint64_t *)bn_add_words(&a1[v9], &a1[v9], v11, a3);
  unint64_t v14 = (char *)result + v13;
  unint64_t v15 = a3 + (a3 >> 1);
  if (v15 < 2 * a3)
  {
    unint64_t v16 = a3 - v9;
    uint64_t v17 = &a1[v15];
    do
    {
      uint64_t v18 = &v14[*v17];
      unint64_t v14 = (char *)__CFADD__(*v17, v14);
      *v17++ = (unint64_t)v18;
      --v16;
    }

    while (v16);
  }

  if (v14) {
    bn_sqr_recursive_cold_2();
  }
  return result;
}

int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
{
  int result = bn_sqr_consttime(r, (BIGNUM *)a, ctx);
  if (result)
  {
    bn_set_minimal_width((uint64_t)r);
    return 1;
  }

  return result;
}

void bn_sqr_small(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a4 > 9 || 2 * a4 != a2) {
    abort();
  }
  if (a4 == 8)
  {
    bn_sqr_comba8(a1, a3);
  }

  else if (a4 == 4)
  {
    bn_sqr_comba4(a1, a3);
  }

  else
  {
    *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v6[7] = v5;
    v6[8] = v5;
    unsigned int v6[5] = v5;
    v6[6] = v5;
    _OWORD v6[3] = v5;
    _OWORD v6[4] = v5;
    v6[1] = v5;
    void v6[2] = v5;
    v6[0] = v5;
    bn_sqr_normal(a1, (uint64_t)a3, a4, (unint64_t *)v6);
    OPENSSL_cleanse(v6, 16 * a4);
  }

unint64_t bn_sub_part_words( unint64_t *a1, const unint64_t *a2, const unint64_t *a3, unsigned int num, unsigned int a5)
{
  if ((num & 0x80000000) != 0) {
    bn_sub_part_words_cold_1();
  }
  uint64_t v9 = num;
  unint64_t result = bn_sub_words(a1, a2, a3, num);
  if (a5)
  {
    __int128 v11 = &a1[v9];
    if ((a5 & 0x80000000) != 0)
    {
      unint64_t v16 = &a3[v9];
      else {
        uint64_t v17 = 1LL;
      }
      do
      {
        if (result >= 2) {
          bn_usub_consttime_cold_1();
        }
        uint64_t v18 = *v16++;
        BOOL v19 = v18 != 0;
        unint64_t v20 = -v18 - result;
        unint64_t result = -v18 < result || v19;
        *v11++ = v20;
        --v17;
      }

      while (v17);
    }

    else
    {
      unint64_t v12 = &a2[v9];
      uint64_t v13 = a5;
      do
      {
        if (result >= 2) {
          bn_usub_consttime_cold_1();
        }
        unint64_t v14 = *v12++;
        unint64_t v15 = v14 - result;
        unint64_t result = v14 < result;
        *v11++ = v15;
        --v13;
      }

      while (v13);
    }
  }

  return result;
}

void bn_mul_part_recursive( void *a1, unint64_t *a2, uint64_t a3, signed int a4, unsigned int a5, unsigned int a6, unint64_t *a7, int8x8_t a8)
{
  a8.i32[0] = a4;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(a8);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.i32[0] != 1) {
    bn_mul_part_recursive_cold_5();
  }
  if (a5 - a6 - 2 <= 0xFFFFFFFC) {
    bn_mul_part_recursive_cold_3();
  }
  int v15 = 2 * a4;
  if (a4 > 7)
  {
    uint64_t v50 = a4;
    uint64_t v17 = &a7[2 * a4];
    __int128 v48 = &a2[a4];
    uint64_t v49 = a4;
    uint64_t v18 = bn_abs_sub_part_words(a7, a2, v48, a5, v11, v17);
    __int128 v46 = a7;
    BOOL v19 = &a7[a4];
    uint64_t v47 = bn_abs_sub_part_words( v19,  (const unint64_t *)(a3 + 8LL * a4),  (const unint64_t *)a3,  a6,  a6 - a4,  v17) ^ v18;
    if (a4 == 8)
    {
      uint64_t v21 = a7;
      bn_mul_comba8(v17, a7, v19);
      int8x8_t v22 = a1;
      bn_mul_comba8(a1, a2, (unint64_t *)a3);
      bn_mul_normal(a1 + 16, v48, a5, (unint64_t *)(a3 + 64), a6);
      uint64_t v23 = v50;
      if (v15 != a6 + a5) {
        bzero(&a1[v15 + a5 + a6], 8LL * (int)(v15 - (a6 + a5)));
      }
    }

    else
    {
      __int128 v44 = (unint64_t *)(a3 + 8LL * a4);
      uint64_t v21 = a7;
      uint64_t v24 = &a7[4 * v50];
      bn_mul_recursive(v17, v46, v19, a4, 0LL, 0LL, &v46[4 * v50], v20);
      int8x8_t v22 = a1;
      bn_mul_recursive(a1, a2, (unint64_t *)a3, a4, 0LL, 0LL, v24, v25);
      bzero(&a1[2 * a4], 16LL * a4);
      if ((a6 | a5) >= 0x10)
      {
        int v27 = v24;
        else {
          int v28 = a5;
        }
        LODWORD(v29) = a4;
        uint64_t v23 = v50;
        while (1)
        {
          int v30 = (int)v29 >= 0 ? v29 : (int)v29 + 1;
          uint64_t v29 = (v30 >> 1);
          if (a5 == (_DWORD)v29 || a6 == (_DWORD)v29)
          {
            bn_mul_recursive(&a1[2 * a4], v48, v44, v29, a5 - v29, a6 - v29, v27, v26);
            goto LABEL_30;
          }
        }

        bn_mul_part_recursive(&a1[2 * a4], v48, v44, v29, a5 - v29, a6 - v29, v27);
      }

      else
      {
        bn_mul_normal(&a1[2 * a4], v48, a5, v44, a6);
        uint64_t v23 = v50;
      }
    }

void bn_mul_recursive( unint64_t *a1, unint64_t *a2, unint64_t *a3, unsigned int a4, uint64_t a5, uint64_t a6, unint64_t *a7, int8x8_t a8)
{
  a8.i32[0] = a4;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(a8);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.i32[0] != 1) {
    bn_mul_recursive_cold_4();
  }
  int v16 = a6 | a5;
  if (a4 != 8 || v16)
  {
    if ((int)a4 > 15)
    {
      unsigned int v17 = a4 >> 1;
      unsigned int v39 = a6 + (a4 >> 1);
      uint64_t v18 = &a7[a4];
      unsigned __int16 v36 = &a2[a4 >> 1];
      uint64_t v37 = bn_abs_sub_part_words(a7, a2, v36, a5 + (a4 >> 1), -(int)a5, v18);
      uint64_t v34 = &a7[v17];
      unsigned __int16 v35 = &a3[v17];
      uint64_t v38 = bn_abs_sub_part_words(v34, v35, a3, v39, a6, &a7[a4]) ^ v37;
      *(void *)int v40 = a4 >> 1;
      if (v17 != 8 || v16)
      {
        int8x8_t v22 = &a7[2 * a4];
        bn_mul_recursive(&a7[a4], a7, v34, *(void *)v40, 0LL, 0LL, v22);
        uint64_t v23 = a3;
        uint64_t v21 = a4 >> 1;
        bn_mul_recursive(a1, a2, v23, *(void *)v40, 0LL, 0LL, v22);
        uint64_t v19 = a4;
        uint64_t v24 = a5;
        uint64_t v20 = 2 * a4;
        bn_mul_recursive(&a1[a4], v36, v35, *(void *)v40, v24, a6, v22);
      }

      else
      {
        bn_mul_comba8(&a7[a4], a7, v34);
        bn_mul_comba8(a1, a2, a3);
        uint64_t v19 = a4;
        bn_mul_comba8(&a1[a4], v36, v35);
        uint64_t v20 = 2 * a4;
        uint64_t v21 = a4 >> 1;
      }

      unint64_t v25 = bn_add_words(a7, a1, &a1[v19], v19);
      int8x8_t v26 = &a7[v20];
      unint64_t v27 = v25 - bn_sub_words(v26, a7, &a7[a4], v19);
      unint64_t v28 = bn_add_words(&a7[a4], a7, &a7[a4], v19) + v25;
      bn_select_words((uint64_t *)v18, v38, (uint64_t *)v26, (uint64_t *)v18, v19);
      unint64_t v29 = (v38 & v27 | v28 & ~v38) + bn_add_words(&a1[v21], &a1[v21], v18, v19);
      unsigned int v30 = v21 + a4;
      if ((int)(v21 + a4) < (int)v20)
      {
        __int128 v31 = &a1[v30];
        unint64_t v32 = v20 - (unint64_t)v30;
        do
        {
          unint64_t v33 = *v31 + v29;
          unint64_t v29 = __CFADD__(*v31, v29);
          *v31++ = v33;
          --v32;
        }

        while (v32);
      }

      if (v29) {
        bn_mul_recursive_cold_3();
      }
    }

    else
    {
      bn_mul_normal(a1, a2, (int)(a5 + a4), a3, (int)(a6 + a4));
    }
  }

  else
  {
    bn_mul_comba8(a1, a2, a3);
  }

BIO *std::unique_ptr<bio_st,bssl::internal::Deleter>::reset[abi:ne180100](BIO **a1, BIO *a2)
{
  unint64_t result = *a1;
  *a1 = a2;
  if (result) {
    return (BIO *)BIO_free(result);
  }
  return result;
}

BIGNUM *parse_integer(__int128 *a1, BIGNUM **a2)
{
  if (*a2) {
    parse_integer_cold_1();
  }
  unint64_t result = BN_new();
  *a2 = result;
  if (result) {
    return (BIGNUM *)BN_parse_asn1_unsigned(a1, result);
  }
  return result;
}

uint64_t marshal_integer(uint64_t *a1, const BIGNUM *a2)
{
  if (a2) {
    return BN_marshal_asn1(a1, a2);
  }
  ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 84);
  return 0LL;
}

RSA *RSA_parse_private_key(__int128 *a1)
{
  unsigned int v2 = RSA_new();
  if (v2)
  {
    memset(v6, 170, sizeof(v6));
    if (CBS_get_asn1(a1, &v6[1], 536870928) && CBS_get_asn1_uint64((__int128 *)&v6[1], v6))
    {
      if (v6[0])
      {
        int v3 = 106;
        int v4 = 171;
      }

      else
      {
        if (!parse_integer((__int128 *)&v6[1], (BIGNUM **)&v2->version)
          || !parse_integer((__int128 *)&v6[1], (BIGNUM **)&v2->meth)
          || !parse_integer((__int128 *)&v6[1], (BIGNUM **)&v2->engine)
          || !parse_integer((__int128 *)&v6[1], &v2->n)
          || !parse_integer((__int128 *)&v6[1], &v2->e)
          || !parse_integer((__int128 *)&v6[1], &v2->d)
          || !parse_integer((__int128 *)&v6[1], &v2->p)
          || !parse_integer((__int128 *)&v6[1], &v2->q))
        {
          goto LABEL_8;
        }

        if (v6[2])
        {
          int v3 = 100;
          int v4 = 187;
        }

        else
        {
          if (RSA_check_key(v2)) {
            return v2;
          }
          int v3 = 104;
          int v4 = 192;
        }
      }
    }

    else
    {
      int v3 = 100;
      int v4 = 166;
    }

    ERR_put_error(4, 0, v3, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", v4);
LABEL_8:
    RSA_free(v2);
    return 0LL;
  }

  return v2;
}

RSA *RSA_private_key_from_bytes(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v4 = a1;
  *((void *)&v4 + 1) = a2;
  unsigned int v2 = RSA_parse_private_key(&v4);
  if (!v2 || *((void *)&v4 + 1))
  {
    ERR_put_error(4, 0, 100, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 208);
    RSA_free(v2);
    return 0LL;
  }

  return v2;
}

uint64_t RSA_marshal_private_key(uint64_t *a1, const BIGNUM **a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = v4;
  void v6[2] = v4;
  v6[0] = v4;
  if (CBB_add_asn1(a1, (uint64_t)v6, 0x20000010u)
    && CBB_add_asn1_uint64((uint64_t)v6, 0LL)
    && marshal_integer((uint64_t *)v6, a2[1])
    && marshal_integer((uint64_t *)v6, a2[2])
    && marshal_integer((uint64_t *)v6, a2[3])
    && marshal_integer((uint64_t *)v6, a2[4])
    && marshal_integer((uint64_t *)v6, a2[5])
    && marshal_integer((uint64_t *)v6, a2[6])
    && marshal_integer((uint64_t *)v6, a2[7])
    && marshal_integer((uint64_t *)v6, a2[8])
    && CBB_flush(a1))
  {
    return 1LL;
  }

  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 228);
  return 0LL;
}

uint64_t RSA_private_key_to_bytes(void *a1, void *a2, const BIGNUM **a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = v6;
  _OWORD v8[2] = v6;
  v8[0] = v6;
  CBB_zero(v8);
  if (CBB_init((uint64_t)v8, 0LL)
    && RSA_marshal_private_key((uint64_t *)v8, a3)
    && CBB_finish((uint64_t)v8, a1, a2))
  {
    return 1LL;
  }

  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/boringssl/crypto/rsa_extra/rsa_asn1.c", 241);
  CBB_cleanup((uint64_t)v8);
  return 0LL;
}

dispatch_data_t boringssl_session_state_copy_serialized_session_state(void *a1)
{
  uint64_t v1 = a1;
  unsigned int v2 = v1;
  if (!v1)
  {
LABEL_14:
    dispatch_data_t v5 = 0LL;
    goto LABEL_15;
  }

  size_t v3 = *((unsigned __int8 *)v1 + 12);
  size_t v4 = v1[6];
  if (~v4 < v3)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_session_state_copy_serialized_session_state_cold_1();
    }
    goto LABEL_14;
  }

  if (~v4 == v3)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_session_state_copy_serialized_session_state_cold_2();
    }
    goto LABEL_14;
  }

  if (v4 + 1 == ~v3)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_session_state_copy_serialized_session_state_cold_3();
    }
    goto LABEL_14;
  }

  char v7 = *((_BYTE *)v1 + 8);
  v12[0] = 0LL;
  v12[1] = v12;
  __int128 v12[2] = 0x2020000000LL;
  uint8x8_t v8 = (char *)malloc(v3 + 2 + v4);
  _OWORD v12[3] = v8;
  if (v8)
  {
    uint64_t v9 = v8;
    unint64_t v10 = (const void *)v2[5];
    char *v8 = v7;
    v8[1] = *((_BYTE *)v2 + 12);
    memcpy(v8 + 2, (char *)v2 + 12, v3);
    memcpy(&v9[v3 + 2], v10, v4);
    destructor[0] = MEMORY[0x1895F87A8];
    destructor[1] = 3221225472LL;
    destructor[2] = __boringssl_session_state_copy_serialized_session_state_block_invoke;
    destructor[3] = &unk_18A0717E8;
    destructor[4] = v12;
    dispatch_data_t v5 = dispatch_data_create(v9, v3 + 2 + v4, 0LL, destructor);
  }

  else
  {
    dispatch_data_t v5 = (dispatch_data_t)g_boringssl_log;
    if (g_boringssl_log)
    {
      if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
        boringssl_session_state_copy_serialized_session_state_cold_4();
      }
      dispatch_data_t v5 = 0LL;
    }
  }

  _Block_object_dispose(v12, 8);
LABEL_15:

  return v5;
}

void __boringssl_session_state_copy_serialized_session_state_block_invoke(uint64_t a1)
{
  unsigned int v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2)
  {
    free(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

boringssl_concrete_boringssl_session_state *boringssl_session_state_create_from_dispatch_data( void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v4 = a1;
  dispatch_data_t v5 = a2;
  __int128 v6 = v5;
  if (!v5) {
    goto LABEL_24;
  }
  size_t size = dispatch_data_get_size(v5);
  if (!size) {
    goto LABEL_24;
  }
  size_t v8 = size;
  buffer_from_dispatch_unint64_t data = (boringssl_concrete_boringssl_session_state *)boringssl_helper_create_buffer_from_dispatch_data(v6);
  unint64_t v10 = buffer_from_dispatch_data;
  if (!buffer_from_dispatch_data) {
    goto LABEL_25;
  }
  if (LOBYTE(buffer_from_dispatch_data->super.isa) != 1)
  {
    if (v4)
    {
      id WeakRetained = objc_loadWeakRetained((id *)v4 + 2);
      unsigned int v2 = &OBJC_IVAR___boringssl_concrete_nw_protocol_boringssl_logging_disabled;
      if (WeakRetained)
      {
        int v15 = WeakRetained;
        int v16 = objc_loadWeakRetained((id *)v4 + 2);
        char v17 = v16[475];

        if ((v17 & 1) != 0) {
          goto LABEL_23;
        }
      }

      id v18 = objc_loadWeakRetained((id *)v4 + 2);
      if (v18)
      {
        uint64_t v19 = objc_loadWeakRetained((id *)v4 + 2);
        uint64_t v20 = (v19[475] & 1) == 0;
      }

      else
      {
        uint64_t v20 = 1LL;
      }
    }

    else
    {
      uint64_t v20 = 1LL;
    }

    if ((_DWORD)v20 && g_boringssl_log)
    {
      uint64_t v21 = (os_log_s *)(id)g_boringssl_log;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        if (v4)
        {
          uint64_t v20 = (uint64_t)objc_loadWeakRetained((id *)v4 + 2);
          BOOL v23 = v20 != 0;
          if (v20)
          {
            unsigned int v2 = (int *)objc_loadWeakRetained((id *)v4 + 2);
            unint64_t v25 = (char *)v2 + 391;
          }

          else
          {
            unint64_t v25 = &unk_1875F4C23;
          }

          id v24 = objc_loadWeakRetained((id *)v4 + 2);
        }

        else
        {
          BOOL v23 = 0;
          id v24 = 0LL;
          unint64_t v25 = &unk_1875F4C23;
        }

        *(_DWORD *)uint64_t v34 = 136446978;
        *(void *)&uint64_t v34[4] = "boringssl_session_state_create_from_dispatch_data";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = 150;
        *(_WORD *)&v34[18] = 2082;
        *(void *)&v34[20] = v25;
        __int16 v35 = 2048;
        id v36 = v24;
        _os_log_error_impl( &dword_187560000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s(%d) %{public}s[%p] Serialized data is not of the correct content type.",  v34,  0x26u);
        if (v4) {

        }
        if (v23) {
        if (v4)
        }
      }
    }

    goto LABEL_23;
  }

  if (v8 == 1
    || (size_t v11 = BYTE1(buffer_from_dispatch_data->super.isa), v12 = v8 - 2, v12 < v11)
    || v11 >= 0x1D
    || (*(_OWORD *)uint64_t v34 = xmmword_18760A15C,
        *(_OWORD *)&v34[12] = *(__int128 *)((char *)&xmmword_18760A15C + 12),
        __memcpy_chk(),
        v12 == v11))
  {
LABEL_23:
    free(v10);
    goto LABEL_24;
  }

  uint64_t v13 = SSL_SESSION_from_bytes((uint64_t)&v10->super.isa + v11 + 2, v12 - v11, *((void *)v4 + 51));
  free(v10);
  if (v13)
  {
    unint64_t v10 = boringssl_session_state_create((uint64_t)v13, v34);
    SSL_SESSION_free(v13);
    goto LABEL_25;
  }

  id v26 = objc_loadWeakRetained((id *)v4 + 2);
  if (v26)
  {
    unint64_t v27 = v26;
    unint64_t v28 = objc_loadWeakRetained((id *)v4 + 2);
    char v29 = v28[475];

    if ((v29 & 1) != 0)
    {
LABEL_24:
      unint64_t v10 = 0LL;
      goto LABEL_25;
    }
  }

  id v30 = objc_loadWeakRetained((id *)v4 + 2);
  if (v30)
  {
    __int128 v31 = objc_loadWeakRetained((id *)v4 + 2);
    BOOL v32 = (v31[475] & 1) == 0;
  }

  else
  {
    BOOL v32 = 1;
  }

  unint64_t v10 = 0LL;
  if (v32 && g_boringssl_log)
  {
    unint64_t v33 = (os_log_s *)(id)g_boringssl_log;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      boringssl_session_state_create_from_dispatch_data_cold_1((uint64_t)v4, v33);
    }

    goto LABEL_24;
  }

uint64_t boringssl_session_state_get_used_extended_master_secret(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 9);
  }
  return result;
}

BOOL boringssl_session_state_has_remote_address(void *a1, unsigned __int8 *a2)
{
  size_t v3 = a1;
  id v4 = v3;
  BOOL v5 = 0LL;
  if (v3 && a2)
  {
    __int128 v6 = v3 + 12;
    size_t v7 = v4[12];
    BOOL v5 = (_DWORD)v7 == *a2 && memcmp(v6, a2, v7) == 0;
  }

  return v5;
}

SSL_SESSION *boringssl_session_state_create_inner_session(uint64_t a1, uint64_t a2)
{
  if (a1 && a2) {
    return SSL_SESSION_from_bytes(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a2 + 408));
  }
  else {
    return 0LL;
  }
}

BOOL boringssl_session_state_is_session_state(BOOL result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 8) == 1;
  }
  return result;
}

  ;
}

  ;
}

  ;
}

_WORD *bssl::SSLBuffer::Clear(_WORD *this)
{
  this[4] = this[5];
  this[6] = 0;
  this[7] = this[8];
  return this;
}

int SHA1_Init(SHA_CTX *c)
{
  *(_OWORD *)&c->data[9] = 0u;
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[1] = 0u;
  *(_OWORD *)&c->data[5] = 0u;
  *(_OWORD *)&c->h0 = xmmword_1876097D0;
  *(_OWORD *)&c->h4 = 0u;
  c->h4 = -1009589776;
  return 1;
}

void SHA1_Transform(SHA_CTX *c, const unsigned __int8 *data)
{
}

uint64_t sha1_block_data_order(int *a1, unsigned int *a2, uint64_t a3)
{
  int v3 = a1[3];
  int v4 = a1[4];
  int v5 = a1[1];
  int v6 = a1[2];
  int v7 = *a1;
  do
  {
    int v522 = v3;
    int v523 = v5;
    int v521 = v6;
    int v517 = v7;
    int v518 = v4;
    v519 = a2;
    uint64_t v520 = a3;
    int v8 = v7;
    HIDWORD(v10) = v7;
    LODWORD(v10) = v7;
    int v9 = v10 >> 27;
    int v11 = v3 & ~v5;
    unsigned int v12 = bswap32(*a2);
    int v13 = v6 & v523;
    HIDWORD(v10) = v523;
    LODWORD(v10) = v523;
    int v14 = v10 >> 2;
    unsigned int v501 = bswap32(a2[1]);
    unsigned int v15 = v9 + v4 + 1518500249 + (v13 | v11) + v12;
    HIDWORD(v10) = v15;
    LODWORD(v10) = v15;
    int v16 = v10 >> 27;
    HIDWORD(v10) = v8;
    LODWORD(v10) = v8;
    int v17 = v10 >> 2;
    unsigned int v18 = v522 + 1518500249 + (v8 & __ROR4__(v523, 2) | v521 & ~v8) + v501 + v16;
    HIDWORD(v10) = v18;
    LODWORD(v10) = v18;
    int v19 = v10 >> 27;
    HIDWORD(v10) = v15;
    LODWORD(v10) = v15;
    int v20 = v10 >> 2;
    unsigned int v21 = bswap32(a2[2]);
    unsigned int v505 = bswap32(a2[3]);
    unint64_t v23 = __PAIR64__(v18, __ROR4__(v15, 2));
    int v22 = v18 & v23;
    LODWORD(v23) = v18;
    int v24 = v23 >> 2;
    unsigned int v25 = v521 + 1518500249 + v21 + (v15 & __ROR4__(v8, 2) | v14 & ~v15) + v19;
    HIDWORD(v23) = v25;
    LODWORD(v23) = v25;
    int v26 = v23 >> 27;
    unint64_t v28 = __PAIR64__(v25, __ROR4__(v18, 2));
    int v27 = v25 & v28;
    unsigned int v29 = bswap32(a2[4]);
    LODWORD(v2bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v25;
    int v30 = v28 >> 2;
    unsigned int v31 = v14 + 1518500249 + v505 + (v22 | v17 & ~v18) + v26;
    HIDWORD(v2bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v31;
    LODWORD(v2bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v31;
    unsigned int v32 = v17 + 1518500249 + v29 + (v27 | v20 & ~v25) + (v28 >> 27);
    HIDWORD(v2bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v32;
    LODWORD(v2bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v32;
    int v33 = v28 >> 27;
    unint64_t v35 = __PAIR64__(v31, __ROR4__(v25, 2));
    int v34 = v31 & v35;
    LODWORD(v35) = v31;
    int v36 = v35 >> 2;
    unint64_t v38 = __PAIR64__(v32, __ROR4__(v31, 2));
    int v37 = v32 & v38;
    unsigned int v39 = bswap32(a2[5]);
    int v40 = v34 | v24 & ~v31;
    LODWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v32;
    int v41 = v38 >> 2;
    int v42 = v20 + v39 + 1518500249 + v40 + v33;
    HIDWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v42;
    LODWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v42;
    int v43 = v38 >> 27;
    unsigned int v513 = bswap32(a2[6]);
    int v44 = v37 | v30 & ~v32;
    HIDWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v42;
    LODWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v42;
    int v45 = v38 >> 2;
    unsigned int v46 = v24 + v513 + 1518500249 + v44 + v43;
    HIDWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v46;
    LODWORD(v3bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v46;
    int v47 = v38 >> 27;
    unint64_t v48 = __PAIR64__(v46, __ROR4__(v32, 2));
    unsigned int v509 = bswap32(a2[7]);
    int v49 = v42 & v48 | v36 & ~v42;
    LODWORD(v4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v46;
    int v50 = v48 >> 2;
    unsigned int v51 = v509 + 1518500249 + v30 + v49 + v47;
    HIDWORD(v4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v51;
    LODWORD(v4bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v51;
    int v52 = v48 >> 27;
    unint64_t v54 = __PAIR64__(v51, __ROR4__(v46, 2));
    int v53 = v51 & v54;
    LODWORD(v54) = v51;
    int v55 = v54 >> 2;
    unsigned int v497 = bswap32(a2[8]);
    unsigned int v56 = v497 + 1518500249 + v36 + (v46 & __ROR4__(v42, 2) | v41 & ~v46) + v52;
    unsigned int v57 = bswap32(a2[13]);
    HIDWORD(v54) = v56;
    LODWORD(v54) = v56;
    int v58 = v54 >> 27;
    HIDWORD(v54) = v21 ^ v12 ^ v497 ^ v57;
    LODWORD(v54) = HIDWORD(v54);
    int v59 = v54 >> 31;
    int v60 = HIDWORD(v54);
    int v466 = HIDWORD(v54);
    unint64_t v62 = __PAIR64__(v56, __ROR4__(v51, 2));
    int v61 = v56 & v62;
    unsigned int v63 = bswap32(a2[9]);
    LODWORD(v62) = v56;
    int v64 = v62 >> 2;
    int v65 = v63 + 1518500249 + v41 + (v53 | v45 & ~v51) + v58;
    HIDWORD(v62) = v65;
    LODWORD(v62) = v65;
    int v66 = v62 >> 27;
    unsigned int v67 = bswap32(a2[10]);
    HIDWORD(v62) = v65;
    LODWORD(v62) = v65;
    int v68 = v62 >> 2;
    unsigned int v69 = v67 + 1518500249 + v45 + (v61 | v50 & ~v56) + v66;
    HIDWORD(v62) = v69;
    LODWORD(v62) = v69;
    int v70 = v62 >> 27;
    unint64_t v71 = __PAIR64__(v69, __ROR4__(v56, 2));
    unsigned int v72 = bswap32(a2[11]);
    int v73 = v65 & v71 | v55 & ~v65;
    LODWORD(v71) = v69;
    int v74 = v71 >> 2;
    unsigned int v75 = v72 + 1518500249 + v50 + v73 + v70;
    HIDWORD(v71) = v75;
    LODWORD(v71) = v75;
    int v76 = v71 >> 27;
    unint64_t v77 = __PAIR64__(v75, __ROR4__(v65, 2));
    unsigned int v78 = bswap32(a2[12]);
    int v79 = v69 & v77 | v64 & ~v69;
    LODWORD(v77) = v75;
    int v80 = v77 >> 2;
    unsigned int v81 = v78 + 1518500249 + v55 + v79 + v76;
    HIDWORD(v77) = v81;
    LODWORD(v77) = v81;
    int v82 = v77 >> 27;
    int v83 = v75 & __ROR4__(v69, 2);
    unsigned int v84 = bswap32(a2[14]);
    int v85 = v68 & ~v75;
    unint64_t v87 = __PAIR64__(v81, __ROR4__(v75, 2));
    int v86 = v81 & v87;
    unsigned int v493 = v57;
    LODWORD(v87) = v81;
    int v88 = v87 >> 2;
    int v89 = v57 + 1518500249 + v64 + (v83 | v85) + v82;
    int v90 = v505 ^ v501 ^ v63 ^ v84;
    HIDWORD(v87) = v89;
    LODWORD(v87) = v89;
    int v91 = v87 >> 27;
    HIDWORD(v87) = v90;
    LODWORD(v87) = v90;
    int v92 = v87 >> 31;
    HIDWORD(v87) = v89;
    LODWORD(v87) = v89;
    int v93 = v87 >> 2;
    int v94 = v84 + 1518500249 + v68 + (v86 | v74 & ~v81) + v91;
    HIDWORD(v87) = v94;
    LODWORD(v87) = v94;
    int v95 = v87 >> 27;
    unsigned int v96 = bswap32(a2[15]);
    int v97 = v29 ^ v21 ^ v67 ^ v96;
    unint64_t v99 = __PAIR64__(v97, __ROR4__(v89, 2));
    int v98 = v94 & v99;
    LODWORD(v99) = v97;
    int v468 = v97;
    int v471 = v99 >> 31;
    int v100 = v89 & __ROR4__(v81, 2) | v80 & ~v89;
    HIDWORD(v99) = v94;
    LODWORD(v99) = v94;
    int v101 = v99 >> 2;
    unsigned int v102 = v96 + 1518500249 + v74 + v100 + v95;
    HIDWORD(v99) = v102;
    LODWORD(v99) = v102;
    int v103 = v99 >> 27;
    unint64_t v105 = __PAIR64__(v102, __ROR4__(v94, 2));
    int v104 = v102 & v105;
    LODWORD(v105) = v102;
    int v106 = v105 >> 2;
    unsigned int v107 = v59 + 1518500249 + v80 + (v98 | v88 & ~v94) + v103;
    HIDWORD(v105) = v107;
    LODWORD(v105) = v107;
    int v108 = v105 >> 27;
    LODWORD(v105) = v39 ^ v505 ^ v72 ^ __ROR4__(v60, 31);
    int v109 = v105;
    HIDWORD(v105) = v105;
    int v110 = v105 >> 31;
    unint64_t v112 = __PAIR64__(v107, __ROR4__(v90, 31));
    int v111 = v513 ^ v29 ^ v78 ^ v112;
    LODWORD(v112) = v107;
    int v113 = v112 >> 2;
    unsigned int v114 = v92 + 1518500249 + v88 + (v104 | v93 & ~v102) + v108;
    HIDWORD(v112) = v114;
    LODWORD(v112) = v114;
    int v115 = v112 >> 27;
    HIDWORD(v112) = v111;
    LODWORD(v112) = v111;
    int v480 = v112 >> 31;
    int v116 = v509 ^ v39 ^ v57 ^ __ROR4__(v97, 31);
    unint64_t v118 = __PAIR64__(v114, __ROR4__(v107, 2));
    int v117 = v114 & v118;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v114;
    int v119 = v118 >> 2;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v116;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v116;
    int v477 = v118 >> 31;
    int v120 = v471 + 1518500249 + v93 + (v107 & __ROR4__(v102, 2) | v101 & ~v107) + v115;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v120;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v120;
    int v121 = v118 >> 27;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v120;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v120;
    int v122 = v118 >> 2;
    int v123 = v122 ^ __ROR4__(v114, 2);
    int v124 = v110 + 1518500249 + v101 + (v117 | v106 & ~v114) + v121;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v124;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v124;
    int v125 = v118 >> 27;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v124;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v124;
    int v126 = v118 >> 2;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v497 ^ v513 ^ v84 ^ __ROR4__(v109, 31);
    int v127 = v118;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v118;
    int v474 = v118 >> 31;
    int v128 = v126 ^ __ROR4__(v120, 2);
    unsigned int v129 = v480 + 1859775393 + v106 + (v119 ^ __ROR4__(v107, 2) ^ v120) + v125;
    HIDWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v129;
    LODWORD(v11bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v129;
    int v130 = v118 >> 27;
    unint64_t v132 = __PAIR64__(v129, __ROR4__(v111, 31));
    int v131 = v63 ^ v509 ^ v96 ^ v132;
    int v133 = v477 + 1859775393 + v113 + (v123 ^ v124);
    LODWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v129;
    int v134 = v132 >> 2;
    int v135 = v133 + v130;
    HIDWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v135;
    LODWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v135;
    int v136 = v132 >> 27;
    int v137 = v474 + 1859775393 + v119 + (v128 ^ v129);
    HIDWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v131;
    LODWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v131;
    int v487 = v132 >> 31;
    int v138 = v134 ^ __ROR4__(v124, 2);
    int v139 = v67 ^ v497 ^ __ROR4__(v466, 31) ^ __ROR4__(v116, 31);
    int v140 = v137 + v136;
    HIDWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v140;
    LODWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v140;
    int v141 = v132 >> 27;
    HIDWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v139;
    LODWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v139;
    int v510 = v132 >> 31;
    unsigned int v142 = v487 + 1859775393 + v122 + (v138 ^ v135) + v141;
    HIDWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v135;
    LODWORD(v1bssl::Array<unsigned short>::~Array((uint64_t)this + 32) = v135;
    int v143 = v132 >> 2;
    unint64_t v144 = __PAIR64__(v142, __ROR4__(v129, 2));
    int v145 = v510 + 1859775393 + v126 + (v143 ^ v144 ^ v140);
    LODWORD(vCBB_cleanup(v1 - 144) = v142;
    unsigned int v147 = v145 + (v144 >> 27);
    LODWORD(vCBB_cleanup(v1 - 144) = v72 ^ v63 ^ __ROR4__(v90, 31) ^ __ROR4__(v127, 31);
    int v146 = v144;
    HIDWORD(vCBB_cleanup(v1 - 144) = v144;
    int v148 = v144 >> 31;
    HIDWORD(vCBB_cleanup(v1 - 144) = v140;
    LODWORD(vCBB_cleanup(v1 - 144) = v140;
    int v149 = v144 >> 2;
    unint64_t v150 = __PAIR64__(v147, __ROR4__(v135, 2));
    int v151 = v148 + 1859775393 + v134 + (v149 ^ v150 ^ v142);
    LODWORD(v150) = v147;
    unsigned int v152 = v151 + (v150 >> 27);
    LODWORD(v150) = v78 ^ v67 ^ __ROR4__(v468, 31) ^ __ROR4__(v131, 31);
    int v153 = v150;
    HIDWORD(v150) = v150;
    int v506 = v150 >> 31;
    int v154 = v506 + 1859775393 + v143;
    HIDWORD(v150) = v142;
    LODWORD(v150) = v142;
    int v155 = v150 >> 2;
    unint64_t v156 = __PAIR64__(v152, __ROR4__(v140, 2));
    int v157 = v154 + (v155 ^ v156 ^ v147);
    LODWORD(v156) = v152;
    unsigned int v158 = v157 + (v156 >> 27);
    int v159 = v493 ^ v72 ^ __ROR4__(v109, 31) ^ __ROR4__(v139, 31);
    HIDWORD(v156) = v159;
    LODWORD(v156) = v159;
    int v502 = v156 >> 31;
    HIDWORD(v156) = v147;
    LODWORD(v156) = v147;
    int v160 = v156 >> 2;
    unint64_t v161 = __PAIR64__(v158, __ROR4__(v142, 2));
    int v162 = v502 + 1859775393 + v149 + (v160 ^ v161 ^ v152);
    LODWORD(v161) = v158;
    unsigned int v163 = v162 + (v161 >> 27);
    LODWORD(v161) = v84 ^ v78 ^ __ROR4__(v111, 31) ^ __ROR4__(v146, 31);
    int v164 = v161;
    HIDWORD(v161) = v161;
    int v498 = v161 >> 31;
    int v165 = v498 + 1859775393 + v155;
    HIDWORD(v161) = v152;
    LODWORD(v161) = v152;
    int v166 = v161 >> 2;
    unint64_t v167 = __PAIR64__(v163, __ROR4__(v147, 2));
    int v168 = v165 + (v166 ^ v167 ^ v158);
    LODWORD(v167) = v163;
    unsigned int v169 = v168 + (v167 >> 27);
    LODWORD(v167) = v96 ^ v493 ^ __ROR4__(v116, 31) ^ __ROR4__(v153, 31);
    int v170 = v167;
    HIDWORD(v167) = v167;
    int v514 = v167 >> 31;
    HIDWORD(v167) = v158;
    LODWORD(v167) = v158;
    int v171 = v167 >> 2;
    unint64_t v172 = __PAIR64__(v169, __ROR4__(v152, 2));
    int v173 = v514 + 1859775393 + v160 + (v171 ^ v172 ^ v163);
    LODWORD(v172) = v169;
    unsigned int v174 = v173 + (v172 >> 27);
    LODWORD(v172) = v84 ^ __ROR4__(v466, 31) ^ __ROR4__(v127, 31) ^ __ROR4__(v159, 31);
    int v175 = v172;
    HIDWORD(v172) = v172;
    int v494 = v172 >> 31;
    HIDWORD(v172) = v163;
    LODWORD(v172) = v163;
    int v176 = v172 >> 2;
    unint64_t v177 = __PAIR64__(v174, __ROR4__(v158, 2));
    int v178 = v494 + 1859775393 + v166 + (v176 ^ v177 ^ v169);
    LODWORD(v177) = v174;
    unsigned int v179 = v178 + (v177 >> 27);
    LODWORD(v177) = v96 ^ __ROR4__(v90, 31) ^ __ROR4__(v131, 31) ^ __ROR4__(v164, 31);
    int v180 = v177;
    HIDWORD(v177) = v177;
    int v490 = v177 >> 31;
    int v181 = v490 + 1859775393 + v171;
    HIDWORD(v177) = v169;
    LODWORD(v177) = v169;
    int v182 = v177 >> 2;
    unint64_t v183 = __PAIR64__(v179, __ROR4__(v163, 2));
    int v184 = v181 + (v182 ^ v183 ^ v174);
    LODWORD(v183) = v179;
    unsigned int v185 = v184 + (v183 >> 27);
    LODWORD(v183) = v471 ^ __ROR4__(v466, 31) ^ __ROR4__(v139, 31) ^ __ROR4__(v170, 31);
    int v186 = v183;
    HIDWORD(v183) = v183;
    int v472 = v183 >> 31;
    HIDWORD(v183) = v174;
    LODWORD(v183) = v174;
    int v187 = v183 >> 2;
    unint64_t v188 = __PAIR64__(v185, __ROR4__(v169, 2));
    int v189 = v472 + 1859775393 + v176 + (v187 ^ v188 ^ v179);
    LODWORD(v18bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v185;
    unsigned int v190 = v189 + (v188 >> 27);
    LODWORD(v18bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v110 ^ __ROR4__(v90, 31) ^ __ROR4__(v146, 31) ^ __ROR4__(v175, 31);
    int v191 = v188;
    HIDWORD(v18bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v188;
    int v484 = v188 >> 31;
    int v192 = v484 + 1859775393 + v182;
    HIDWORD(v18bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v179;
    LODWORD(v18bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v179;
    int v193 = v188 >> 2;
    unint64_t v194 = __PAIR64__(v190, __ROR4__(v174, 2));
    int v195 = v192 + (v193 ^ v194 ^ v185);
    LODWORD(v194) = v190;
    unsigned int v196 = v195 + (v194 >> 27);
    LODWORD(v194) = v480 ^ __ROR4__(v468, 31) ^ __ROR4__(v153, 31) ^ __ROR4__(v180, 31);
    int v197 = v194;
    HIDWORD(v194) = v194;
    int v481 = v194 >> 31;
    int v198 = v481 + 1859775393 + v187;
    HIDWORD(v194) = v185;
    LODWORD(v194) = v185;
    int v199 = v194 >> 2;
    unint64_t v200 = __PAIR64__(v196, __ROR4__(v179, 2));
    int v201 = v198 + (v199 ^ v200 ^ v190);
    LODWORD(v200) = v196;
    unsigned int v202 = v201 + (v200 >> 27);
    LODWORD(v200) = v477 ^ __ROR4__(v109, 31) ^ __ROR4__(v159, 31) ^ __ROR4__(v186, 31);
    HIDWORD(v200) = v200;
    int v478 = v200 >> 31;
    int v203 = v200;
    int v204 = v478 + 1859775393 + v193;
    HIDWORD(v200) = v190;
    LODWORD(v200) = v190;
    int v205 = v200 >> 2;
    unint64_t v206 = __PAIR64__(v202, __ROR4__(v185, 2));
    int v207 = v204 + (v205 ^ v206 ^ v196);
    LODWORD(v206) = v202;
    unsigned int v208 = v207 + (v206 >> 27);
    LODWORD(v206) = v474 ^ __ROR4__(v111, 31) ^ __ROR4__(v164, 31) ^ __ROR4__(v191, 31);
    int v209 = v206;
    HIDWORD(v206) = v206;
    int v210 = v206 >> 31;
    HIDWORD(v206) = v196;
    LODWORD(v206) = v196;
    int v211 = v206 >> 2;
    unint64_t v212 = __PAIR64__(v208, __ROR4__(v190, 2));
    int v213 = v210 + 1859775393 + v199 + (v211 ^ v212 ^ v202);
    LODWORD(v212) = v208;
    unsigned int v214 = v213 + (v212 >> 27);
    LODWORD(v212) = v487 ^ __ROR4__(v116, 31) ^ __ROR4__(v170, 31) ^ __ROR4__(v197, 31);
    int v215 = v212;
    HIDWORD(v212) = v212;
    int v475 = v212 >> 31;
    HIDWORD(v212) = v202;
    LODWORD(v212) = v202;
    int v216 = v212 >> 2;
    unint64_t v217 = __PAIR64__(v214, __ROR4__(v196, 2));
    int v218 = v475 + 1859775393 + v205 + (v216 ^ v217 ^ v208);
    LODWORD(v217) = v214;
    unsigned int v219 = v218 + (v217 >> 27);
    int v221 = v203;
    LODWORD(v217) = v510 ^ __ROR4__(v127, 31) ^ __ROR4__(v175, 31) ^ __ROR4__(v203, 31);
    int v220 = v217;
    HIDWORD(v217) = v217;
    int v488 = v217 >> 31;
    HIDWORD(v217) = v208;
    LODWORD(v217) = v208;
    int v222 = v217 >> 2;
    unint64_t v223 = __PAIR64__(v219, __ROR4__(v202, 2));
    int v224 = v488 + 1859775393 + v211 + (v222 ^ v223 ^ v214);
    LODWORD(v223) = v219;
    unsigned int v225 = v224 + (v223 >> 27);
    int v226 = v209;
    LODWORD(v223) = v148 ^ __ROR4__(v131, 31) ^ __ROR4__(v180, 31) ^ __ROR4__(v209, 31);
    HIDWORD(v223) = v223;
    int v511 = v223 >> 31;
    int v227 = v223;
    HIDWORD(v223) = v214;
    LODWORD(v223) = v214;
    int v228 = v223 >> 2;
    unint64_t v229 = __PAIR64__(v225, __ROR4__(v208, 2));
    int v230 = v511 + 1859775393 + v216 + (v228 ^ v229 ^ v219);
    LODWORD(v229) = v225;
    unsigned int v231 = v230 + (v229 >> 27);
    LODWORD(v229) = v506 ^ __ROR4__(v139, 31) ^ __ROR4__(v186, 31) ^ __ROR4__(v215, 31);
    int v232 = v229;
    HIDWORD(v229) = v229;
    int v507 = v229 >> 31;
    HIDWORD(v229) = v231;
    LODWORD(v229) = v231;
    unsigned int v233 = v507
         - 1894007588
         + v222
         + ((v225 | __ROR4__(v219, 2)) & __ROR4__(v214, 2) | v225 & __ROR4__(v219, 2))
         + (v229 >> 27);
    LODWORD(v229) = v502 ^ __ROR4__(v146, 31) ^ __ROR4__(v191, 31) ^ __ROR4__(v220, 31);
    HIDWORD(v229) = v229;
    int v503 = v229 >> 31;
    int v234 = v229;
    HIDWORD(v229) = v233;
    LODWORD(v229) = v233;
    unsigned int v235 = v503
         - 1894007588
         + v228
         + ((v231 | __ROR4__(v225, 2)) & __ROR4__(v219, 2) | v231 & __ROR4__(v225, 2))
         + (v229 >> 27);
    unint64_t v237 = __PAIR64__(v219, __ROR4__(v153, 31));
    int v236 = v498 ^ v237;
    LODWORD(v237) = v219;
    int v238 = v237 >> 2;
    int v240 = v227;
    LODWORD(v237) = v236 ^ __ROR4__(v197, 31) ^ __ROR4__(v227, 31);
    int v239 = v237;
    HIDWORD(v237) = v237;
    int v499 = v237 >> 31;
    unint64_t v242 = __PAIR64__(v235, __ROR4__(v159, 31));
    int v241 = v514 ^ v242;
    LODWORD(v242) = v235;
    unsigned int v243 = v499
         - 1894007588
         + v238
         + ((v233 | __ROR4__(v231, 2)) & __ROR4__(v225, 2) | v233 & __ROR4__(v231, 2))
         + (v242 >> 27);
    HIDWORD(v242) = v225;
    LODWORD(v242) = v225;
    int v244 = v242 >> 2;
    LODWORD(v242) = v241 ^ __ROR4__(v221, 31) ^ __ROR4__(v232, 31);
    int v245 = v242;
    HIDWORD(v242) = v242;
    int v515 = v242 >> 31;
    unint64_t v246 = __PAIR64__(v243, __ROR4__(v233, 2));
    int v247 = v515 - 1894007588 + v244 + ((v235 | __ROR4__(v233, 2)) & __ROR4__(v231, 2) | v235 & v246);
    LODWORD(v246) = v243;
    unsigned int v248 = v247 + (v246 >> 27);
    unint64_t v250 = __PAIR64__(v231, __ROR4__(v226, 31));
    int v249 = v494 ^ __ROR4__(v164, 31) ^ v250;
    int v251 = v226;
    LODWORD(v250) = v231;
    int v252 = v250 >> 2;
    int v254 = v234;
    LODWORD(v250) = v249 ^ __ROR4__(v234, 31);
    int v253 = v250;
    HIDWORD(v250) = v250;
    int v495 = v250 >> 31;
    HIDWORD(v250) = v248;
    LODWORD(v250) = v248;
    int v255 = v495
         - 1894007588
         + v252
         + ((v243 | __ROR4__(v235, 2)) & __ROR4__(v233, 2) | v243 & __ROR4__(v235, 2))
         + (v250 >> 27);
    unint64_t v257 = __PAIR64__(v233, __ROR4__(v239, 31));
    int v256 = v490 ^ __ROR4__(v170, 31) ^ __ROR4__(v215, 31) ^ v257;
    LODWORD(v257) = v233;
    int v258 = v257 >> 2;
    HIDWORD(v257) = v256;
    LODWORD(v257) = v256;
    int v491 = v257 >> 31;
    HIDWORD(v257) = v255;
    LODWORD(v257) = v255;
    unsigned int v259 = v491
         - 1894007588
         + v258
         + ((v248 | __ROR4__(v243, 2)) & __ROR4__(v235, 2) | v248 & __ROR4__(v243, 2))
         + (v257 >> 27);
    unint64_t v261 = __PAIR64__(v235, __ROR4__(v220, 31));
    int v260 = v472 ^ __ROR4__(v175, 31) ^ v261;
    LODWORD(v261) = v235;
    int v262 = v261 >> 2;
    int v263 = v260 ^ __ROR4__(v245, 31);
    unint64_t v265 = __PAIR64__(v263, __ROR4__(v243, 2));
    int v264 = (v255 | __ROR4__(v248, 2)) & v265;
    LODWORD(v265) = v263;
    int v469 = v265 >> 31;
    unint64_t v266 = __PAIR64__(v259, __ROR4__(v248, 2));
    int v267 = v469 - 1894007588 + v262 + (v264 | v255 & v266);
    LODWORD(v266) = v259;
    unsigned int v268 = v267 + (v266 >> 27);
    unint64_t v269 = __PAIR64__(v243, __ROR4__(v255, 2));
    int v270 = (v259 | __ROR4__(v255, 2)) & __ROR4__(v248, 2) | v259 & v269;
    LODWORD(v269) = v243;
    int v271 = v269 >> 2;
    LODWORD(v269) = v484 ^ __ROR4__(v180, 31) ^ __ROR4__(v240, 31) ^ __ROR4__(v253, 31);
    int v272 = v269;
    HIDWORD(v269) = v269;
    int v485 = v269 >> 31;
    HIDWORD(v269) = v268;
    LODWORD(v269) = v268;
    unsigned int v273 = v485 - 1894007588 + v271 + v270 + (v269 >> 27);
    unint64_t v275 = __PAIR64__(v248, __ROR4__(v186, 31));
    int v274 = v481 ^ v275;
    LODWORD(v275) = v248;
    int v276 = v275 >> 2;
    LODWORD(v275) = v274 ^ __ROR4__(v232, 31) ^ __ROR4__(v256, 31);
    int v277 = v275;
    HIDWORD(v275) = v275;
    int v482 = v275 >> 31;
    int v278 = v482 - 1894007588 + v276 + ((v268 | __ROR4__(v259, 2)) & __ROR4__(v255, 2) | v268 & __ROR4__(v259, 2));
    unint64_t v280 = __PAIR64__(v273, __ROR4__(v191, 31));
    int v279 = v478 ^ v280;
    LODWORD(vbssl::Array<unsigned short>::~Array(v16 + 280) = v273;
    unsigned int v281 = v278 + (v280 >> 27);
    HIDWORD(vbssl::Array<unsigned short>::~Array(v16 + 280) = v255;
    LODWORD(vbssl::Array<unsigned short>::~Array(v16 + 280) = v255;
    int v282 = v280 >> 2;
    LODWORD(vbssl::Array<unsigned short>::~Array(v16 + 280) = v279 ^ __ROR4__(v234, 31) ^ __ROR4__(v263, 31);
    int v283 = v280;
    HIDWORD(vbssl::Array<unsigned short>::~Array(v16 + 280) = v280;
    int v479 = v280 >> 31;
    unint64_t v284 = __PAIR64__(v281, __ROR4__(v268, 2));
    int v285 = v479 - 1894007588 + v282 + ((v273 | __ROR4__(v268, 2)) & __ROR4__(v259, 2) | v273 & v284);
    LODWORD(v284) = v281;
    unsigned int v286 = v285 + (v284 >> 27);
    unint64_t v288 = __PAIR64__(v259, __ROR4__(v239, 31));
    int v287 = v210 ^ __ROR4__(v197, 31) ^ v288;
    LODWORD(v28bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v259;
    int v289 = v288 >> 2;
    LODWORD(v28bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v287 ^ __ROR4__(v272, 31);
    int v290 = v288;
    HIDWORD(v28bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v288;
    int v473 = v288 >> 31;
    HIDWORD(v28bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v286;
    LODWORD(v28bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v286;
    int v291 = v473
         - 1894007588
         + v289
         + ((v281 | __ROR4__(v273, 2)) & __ROR4__(v268, 2) | v281 & __ROR4__(v273, 2))
         + (v288 >> 27);
    unint64_t v293 = __PAIR64__(v268, __ROR4__(v277, 31));
    int v292 = v475 ^ __ROR4__(v221, 31) ^ __ROR4__(v245, 31) ^ v293;
    LODWORD(v293) = v268;
    int v294 = v293 >> 2;
    HIDWORD(v293) = v292;
    LODWORD(v293) = v292;
    int v476 = v293 >> 31;
    HIDWORD(v293) = v291;
    LODWORD(v293) = v291;
    unsigned int v295 = v476
         - 1894007588
         + v294
         + ((v286 | __ROR4__(v281, 2)) & __ROR4__(v273, 2) | v286 & __ROR4__(v281, 2))
         + (v293 >> 27);
    unint64_t v297 = __PAIR64__(v273, __ROR4__(v253, 31));
    int v296 = v488 ^ __ROR4__(v251, 31) ^ v297;
    LODWORD(v297) = v273;
    int v298 = v297 >> 2;
    int v299 = v296 ^ __ROR4__(v283, 31);
    unint64_t v301 = __PAIR64__(v299, __ROR4__(v281, 2));
    int v300 = (v291 | __ROR4__(v286, 2)) & v301;
    LODWORD(v301) = v299;
    int v489 = v301 >> 31;
    unint64_t v302 = __PAIR64__(v295, __ROR4__(v286, 2));
    int v303 = v489 - 1894007588 + v298 + (v300 | v291 & v302);
    LODWORD(v302) = v295;
    unsigned int v304 = v303 + (v302 >> 27);
    unint64_t v305 = __PAIR64__(v281, __ROR4__(v291, 2));
    int v306 = (v295 | __ROR4__(v291, 2)) & __ROR4__(v286, 2) | v295 & v305;
    LODWORD(v305) = v281;
    int v307 = v305 >> 2;
    LODWORD(v305) = v511 ^ __ROR4__(v215, 31) ^ __ROR4__(v256, 31) ^ __ROR4__(v290, 31);
    int v308 = v305;
    HIDWORD(v305) = v305;
    int v512 = v305 >> 31;
    HIDWORD(v305) = v304;
    LODWORD(v305) = v304;
    unsigned int v309 = v512 - 1894007588 + v307 + v306 + (v305 >> 27);
    unint64_t v311 = __PAIR64__(v286, __ROR4__(v220, 31));
    int v310 = v507 ^ v311;
    LODWORD(v311) = v286;
    int v312 = v311 >> 2;
    int v313 = v263;
    LODWORD(v311) = v310 ^ __ROR4__(v263, 31) ^ __ROR4__(v292, 31);
    int v314 = v311;
    HIDWORD(v311) = v311;
    int v508 = v311 >> 31;
    unint64_t v316 = __PAIR64__(v309, __ROR4__(v240, 31));
    int v315 = v503 ^ v316;
    LODWORD(v316) = v309;
    unsigned int v317 = v508
         - 1894007588
         + v312
         + ((v304 | __ROR4__(v295, 2)) & __ROR4__(v291, 2) | v304 & __ROR4__(v295, 2))
         + (v316 >> 27);
    HIDWORD(v316) = v291;
    LODWORD(v316) = v291;
    int v318 = v316 >> 2;
    LODWORD(v316) = v315 ^ __ROR4__(v272, 31) ^ __ROR4__(v299, 31);
    int v319 = v316;
    HIDWORD(v316) = v316;
    int v504 = v316 >> 31;
    unint64_t v320 = __PAIR64__(v317, __ROR4__(v304, 2));
    int v321 = v504 - 1894007588 + v318 + ((v309 | __ROR4__(v304, 2)) & __ROR4__(v295, 2) | v309 & v320);
    LODWORD(v320) = v317;
    unsigned int v322 = v321 + (v320 >> 27);
    unint64_t v324 = __PAIR64__(v295, __ROR4__(v277, 31));
    int v323 = v499 ^ __ROR4__(v232, 31) ^ v324;
    LODWORD(v324) = v295;
    int v325 = v324 >> 2;
    LODWORD(v324) = v323 ^ __ROR4__(v308, 31);
    int v326 = v324;
    HIDWORD(v324) = v324;
    int v500 = v324 >> 31;
    HIDWORD(v324) = v322;
    LODWORD(v324) = v322;
    int v327 = v500
         - 1894007588
         + v325
         + ((v317 | __ROR4__(v309, 2)) & __ROR4__(v304, 2) | v317 & __ROR4__(v309, 2))
         + (v324 >> 27);
    unint64_t v329 = __PAIR64__(v304, __ROR4__(v314, 31));
    int v328 = v515 ^ __ROR4__(v254, 31) ^ __ROR4__(v283, 31) ^ v329;
    LODWORD(v329) = v304;
    int v330 = v329 >> 2;
    HIDWORD(v329) = v328;
    LODWORD(v329) = v328;
    int v516 = v329 >> 31;
    HIDWORD(v329) = v327;
    LODWORD(v329) = v327;
    unsigned int v331 = v516
         - 1894007588
         + v330
         + ((v322 | __ROR4__(v317, 2)) & __ROR4__(v309, 2) | v322 & __ROR4__(v317, 2))
         + (v329 >> 27);
    unint64_t v333 = __PAIR64__(v309, __ROR4__(v290, 31));
    int v332 = v495 ^ __ROR4__(v239, 31) ^ v333;
    LODWORD(v333) = v309;
    int v334 = v333 >> 2;
    int v335 = v332 ^ __ROR4__(v319, 31);
    unint64_t v337 = __PAIR64__(v335, __ROR4__(v317, 2));
    int v336 = (v327 | __ROR4__(v322, 2)) & v337;
    LODWORD(v337) = v335;
    int v496 = v337 >> 31;
    unint64_t v338 = __PAIR64__(v331, __ROR4__(v322, 2));
    int v339 = v496 - 1894007588 + v334 + (v336 | v327 & v338);
    LODWORD(v33bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v331;
    int v340 = v339 + (v338 >> 27);
    int v341 = v491 ^ __ROR4__(v245, 31);
    unint64_t v342 = __PAIR64__(v317, __ROR4__(v327, 2));
    int v343 = (v331 | __ROR4__(v327, 2)) & __ROR4__(v322, 2) | v331 & v342;
    LODWORD(v342) = v317;
    int v344 = v342 >> 2;
    LODWORD(v342) = v341 ^ __ROR4__(v292, 31) ^ __ROR4__(v326, 31);
    int v345 = v342;
    HIDWORD(v342) = v342;
    int v467 = v342 >> 31;
    int v346 = v467 - 1894007588 + v344 + v343;
    unint64_t v348 = __PAIR64__(v322, __ROR4__(v253, 31));
    int v347 = v469 ^ v348;
    LODWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v322;
    int v349 = v348 >> 2;
    int v350 = v347 ^ __ROR4__(v299, 31) ^ __ROR4__(v328, 31);
    HIDWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v350;
    LODWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v350;
    int v470 = v348 >> 31;
    HIDWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v340;
    LODWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v340;
    unsigned int v351 = v346 + (v348 >> 27);
    HIDWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v331;
    LODWORD(v34bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v331;
    int v352 = v348 >> 2;
    unint64_t v354 = __PAIR64__(v351, __ROR4__(v256, 31));
    int v353 = v485 ^ v354;
    LODWORD(v354) = v351;
    unsigned int v355 = v470 - 899497514 + v349 + (v352 ^ __ROR4__(v327, 2) ^ v340) + (v354 >> 27);
    HIDWORD(v354) = v327;
    LODWORD(v354) = v327;
    int v356 = v354 >> 2;
    int v357 = v353 ^ __ROR4__(v308, 31) ^ __ROR4__(v335, 31);
    HIDWORD(v354) = v357;
    LODWORD(v354) = v357;
    int v358 = v354 >> 31;
    HIDWORD(v354) = v340;
    LODWORD(v354) = v340;
    int v359 = v354 >> 2;
    unint64_t v360 = __PAIR64__(v355, __ROR4__(v331, 2));
    int v361 = v358 - 899497514 + v356 + (v359 ^ v360 ^ v351);
    LODWORD(v360) = v355;
    unsigned int v362 = v361 + (v360 >> 27);
    LODWORD(v360) = v482 ^ __ROR4__(v313, 31) ^ __ROR4__(v314, 31) ^ __ROR4__(v345, 31);
    int v363 = v360;
    HIDWORD(v360) = v360;
    int v492 = v360 >> 31;
    HIDWORD(v360) = v351;
    LODWORD(v360) = v351;
    int v364 = v360 >> 2;
    unint64_t v365 = __PAIR64__(v362, __ROR4__(v340, 2));
    int v366 = v492 - 899497514 + v352 + (v364 ^ v365 ^ v355);
    LODWORD(v365) = v362;
    unsigned int v367 = v366 + (v365 >> 27);
    LODWORD(v365) = v479 ^ __ROR4__(v272, 31) ^ __ROR4__(v319, 31) ^ __ROR4__(v350, 31);
    int v368 = v365;
    HIDWORD(v365) = v365;
    int v483 = v365 >> 31;
    HIDWORD(v365) = v355;
    LODWORD(v365) = v355;
    int v369 = v365 >> 2;
    unint64_t v370 = __PAIR64__(v367, __ROR4__(v351, 2));
    int v371 = v483 - 899497514 + v359 + (v369 ^ v370 ^ v362);
    LODWORD(v370) = v367;
    unsigned int v372 = v371 + (v370 >> 27);
    LODWORD(v370) = v473 ^ __ROR4__(v277, 31) ^ __ROR4__(v326, 31) ^ __ROR4__(v357, 31);
    int v373 = v370;
    HIDWORD(v370) = v370;
    int v486 = v370 >> 31;
    HIDWORD(v370) = v362;
    LODWORD(v370) = v362;
    int v374 = v370 >> 2;
    unint64_t v375 = __PAIR64__(v372, __ROR4__(v355, 2));
    int v376 = v486 - 899497514 + v364 + (v374 ^ v375 ^ v367);
    LODWORD(v375) = v372;
    unsigned int v377 = v376 + (v375 >> 27);
    LODWORD(v375) = v476 ^ __ROR4__(v283, 31) ^ __ROR4__(v328, 31) ^ __ROR4__(v363, 31);
    int v378 = v375;
    HIDWORD(v375) = v375;
    int v379 = v375 >> 31;
    HIDWORD(v375) = v367;
    LODWORD(v375) = v367;
    int v380 = v375 >> 2;
    unint64_t v381 = __PAIR64__(v377, __ROR4__(v362, 2));
    int v382 = v379 - 899497514 + v369 + (v380 ^ v381 ^ v372);
    LODWORD(v381) = v377;
    unsigned int v383 = v382 + (v381 >> 27);
    LODWORD(v381) = v489 ^ __ROR4__(v290, 31) ^ __ROR4__(v335, 31) ^ __ROR4__(v368, 31);
    int v384 = v381;
    HIDWORD(v381) = v381;
    int v385 = (v381 >> 31) - 899497514;
    HIDWORD(v381) = v372;
    LODWORD(v381) = v372;
    int v386 = v381 >> 2;
    unint64_t v387 = __PAIR64__(v383, __ROR4__(v367, 2));
    int v388 = v385 + v374 + (v386 ^ v387 ^ v377);
    LODWORD(v387) = v383;
    unsigned int v389 = v388 + (v387 >> 27);
    LODWORD(v387) = v512 ^ __ROR4__(v292, 31) ^ __ROR4__(v345, 31) ^ __ROR4__(v373, 31);
    int v390 = v387;
    HIDWORD(v387) = v387;
    int v391 = (v387 >> 31) - 899497514 + v380;
    HIDWORD(v387) = v377;
    LODWORD(v387) = v377;
    int v392 = v387 >> 2;
    unint64_t v393 = __PAIR64__(v389, __ROR4__(v372, 2));
    int v394 = v391 + (v392 ^ v393 ^ v383);
    LODWORD(v393) = v389;
    unsigned int v395 = v394 + (v393 >> 27);
    int v396 = v508 ^ __ROR4__(v299, 31) ^ __ROR4__(v350, 31) ^ __ROR4__(v378, 31);
    HIDWORD(v393) = v396;
    LODWORD(v393) = v396;
    int v397 = (v393 >> 31) - 899497514;
    HIDWORD(v393) = v383;
    LODWORD(v393) = v383;
    int v398 = v393 >> 2;
    unint64_t v399 = __PAIR64__(v395, __ROR4__(v377, 2));
    int v400 = v397 + v386 + (v398 ^ v399 ^ v389);
    LODWORD(v399) = v395;
    unsigned int v401 = v400 + (v399 >> 27);
    LODWORD(v399) = v504 ^ __ROR4__(v308, 31) ^ __ROR4__(v357, 31) ^ __ROR4__(v384, 31);
    int v402 = v399;
    HIDWORD(v399) = v399;
    int v403 = (v399 >> 31) - 899497514 + v392;
    HIDWORD(v399) = v389;
    LODWORD(v399) = v389;
    int v404 = v399 >> 2;
    unint64_t v405 = __PAIR64__(v401, __ROR4__(v383, 2));
    int v406 = v403 + (v404 ^ v405 ^ v395);
    LODWORD(v405) = v401;
    unsigned int v407 = v406 + (v405 >> 27);
    LODWORD(v405) = v500 ^ __ROR4__(v314, 31) ^ __ROR4__(v363, 31) ^ __ROR4__(v390, 31);
    int v408 = v405;
    HIDWORD(v405) = v405;
    int v409 = (v405 >> 31) - 899497514;
    HIDWORD(v405) = v395;
    LODWORD(v405) = v395;
    int v410 = v405 >> 2;
    unint64_t v411 = __PAIR64__(v407, __ROR4__(v389, 2));
    int v412 = v409 + v398 + (v410 ^ v411 ^ v401);
    LODWORD(v411) = v407;
    unsigned int v413 = v412 + (v411 >> 27);
    int v414 = v516 ^ __ROR4__(v319, 31) ^ __ROR4__(v368, 31) ^ __ROR4__(v396, 31);
    HIDWORD(v411) = v414;
    LODWORD(v411) = v414;
    int v415 = (v411 >> 31) - 899497514 + v404;
    HIDWORD(v411) = v401;
    LODWORD(v411) = v401;
    int v416 = v411 >> 2;
    unint64_t v418 = __PAIR64__(v413, __ROR4__(v326, 31));
    int v417 = v496 ^ v418;
    LODWORD(v41bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v413;
    unsigned int v419 = v415 + (v416 ^ __ROR4__(v395, 2) ^ v407) + (v418 >> 27);
    int v420 = v417 ^ __ROR4__(v373, 31) ^ __ROR4__(v402, 31);
    HIDWORD(v41bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v420;
    LODWORD(v41bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v420;
    int v421 = (v418 >> 31) - 899497514;
    HIDWORD(v41bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v407;
    LODWORD(v41bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v407;
    int v422 = v418 >> 2;
    unint64_t v423 = __PAIR64__(v419, __ROR4__(v401, 2));
    int v424 = v421 + v410 + (v422 ^ v423 ^ v413);
    LODWORD(v423) = v419;
    unsigned int v425 = v424 + (v423 >> 27);
    int v426 = v467 ^ __ROR4__(v328, 31) ^ __ROR4__(v378, 31) ^ __ROR4__(v408, 31);
    HIDWORD(v423) = v426;
    LODWORD(v423) = v426;
    int v427 = (v423 >> 31) - 899497514 + v416;
    HIDWORD(v423) = v413;
    LODWORD(v423) = v413;
    int v428 = v423 >> 2;
    int v429 = v427 + (v428 ^ __ROR4__(v407, 2) ^ v419);
    unint64_t v431 = __PAIR64__(v425, __ROR4__(v335, 31));
    int v430 = v470 ^ v431;
    LODWORD(v431) = v425;
    unsigned int v432 = v429 + (v431 >> 27);
    int v433 = v430 ^ __ROR4__(v384, 31) ^ __ROR4__(v414, 31);
    HIDWORD(v431) = v433;
    LODWORD(v431) = v433;
    int v434 = (v431 >> 31) - 899497514;
    HIDWORD(v431) = v419;
    LODWORD(v431) = v419;
    int v435 = v431 >> 2;
    unint64_t v436 = __PAIR64__(v432, __ROR4__(v413, 2));
    int v437 = v434 + v422 + (v435 ^ v436 ^ v425);
    LODWORD(v436) = v432;
    unsigned int v438 = v437 + (v436 >> 27);
    int v439 = v358 ^ __ROR4__(v345, 31) ^ __ROR4__(v390, 31) ^ __ROR4__(v420, 31);
    HIDWORD(v436) = v439;
    LODWORD(v436) = v439;
    int v440 = (v436 >> 31) - 899497514 + v428;
    HIDWORD(v436) = v425;
    LODWORD(v436) = v425;
    int v441 = v436 >> 2;
    unint64_t v443 = __PAIR64__(v438, __ROR4__(v396, 31));
    int v442 = v492 ^ __ROR4__(v350, 31) ^ v443;
    LODWORD(v443) = v438;
    unsigned int v444 = v440 + (v441 ^ __ROR4__(v419, 2) ^ v432) + (v443 >> 27);
    int v445 = v442 ^ __ROR4__(v426, 31);
    HIDWORD(v443) = v445;
    LODWORD(v443) = v445;
    int v446 = (v443 >> 31) - 899497514;
    HIDWORD(v443) = v432;
    LODWORD(v443) = v432;
    int v447 = v443 >> 2;
    unint64_t v448 = __PAIR64__(v444, __ROR4__(v425, 2));
    int v449 = v446 + v435 + (v447 ^ v448 ^ v438);
    LODWORD(v44bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v444;
    unsigned int v450 = v449 + (v448 >> 27);
    LODWORD(v44bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v483 ^ __ROR4__(v357, 31) ^ __ROR4__(v402, 31) ^ __ROR4__(v433, 31);
    HIDWORD(v44bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v448;
    int v451 = (v448 >> 31) - 899497514 + v441;
    HIDWORD(v44bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v438;
    LODWORD(v44bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v438;
    uint64_t result = (v448 >> 2);
    unint64_t v454 = __PAIR64__(v450, __ROR4__(v408, 31));
    int v453 = v486 ^ __ROR4__(v363, 31) ^ v454;
    LODWORD(v454) = v450;
    unsigned int v455 = v451 + (result ^ __ROR4__(v432, 2) ^ v444) + (v454 >> 27);
    LODWORD(v454) = v453 ^ __ROR4__(v439, 31);
    HIDWORD(v454) = v454;
    int v456 = (v454 >> 31) - 899497514;
    HIDWORD(v454) = v444;
    LODWORD(v454) = v444;
    int v457 = v454 >> 2;
    unint64_t v458 = __PAIR64__(v455, __ROR4__(v438, 2));
    int v459 = v456 + v447 + (v457 ^ v458 ^ v450);
    LODWORD(v45bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v455;
    unsigned int v460 = v459 + (v458 >> 27);
    LODWORD(v45bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v379 ^ __ROR4__(v368, 31) ^ __ROR4__(v414, 31) ^ __ROR4__(v445, 31);
    HIDWORD(v45bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v458;
    int v461 = v517 - 899497514 + (v458 >> 31) + result;
    HIDWORD(v45bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v450;
    LODWORD(v45bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v450;
    int v462 = v458 >> 2;
    unint64_t v463 = __PAIR64__(v460, __ROR4__(v444, 2));
    int v464 = v461 + (v462 ^ v463 ^ v455);
    int v5 = v460 + v523;
    LODWORD(v463) = v460;
    int v7 = v464 + (v463 >> 27);
    HIDWORD(v463) = v455;
    LODWORD(v463) = v455;
    int v6 = (v463 >> 2) + v521;
    int v3 = v462 + v522;
    int v4 = v457 + v518;
    *a1 = v7;
    a1[1] = v5;
    a1[2] = v6;
    a1[3] = v3;
    a1[4] = v457 + v518;
    a2 = v519 + 16;
    a3 = v520 - 1;
  }

  while (v520 != 1);
  return result;
}

uint64_t bssl::tls_open_change_cipher_spec( bssl *a1, unsigned __int8 **a2, ssl_st *a3, unsigned __int16 *a4, unint64_t a5)
{
  char v11 = -86;
  int v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t result = bssl::tls_open_record(a1, &v11, (uint64_t)&v9, a2, a3, a4, a5);
  if (!(_DWORD)result)
  {
    if (v11 == 20)
    {
      if (v10 == 1 && *v9 == 1)
      {
        bssl::ssl_do_msg_callback((uint64_t)a1, 0LL, 20LL, (uint64_t)v9, 1LL);
        return 0LL;
      }

      ERR_put_error(16, 0, 103, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 383);
      char v8 = 47;
    }

    else
    {
      ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/s3_pkt.cc", 377);
      char v8 = 10;
    }

    LOBYTE(a3->version) = v8;
    return 4LL;
  }

  return result;
}

void bssl::ssl_send_alert(bssl *this, ssl_st *a2, int a3)
{
  int v6 = ERR_save_state();
  bssl::ssl_send_alert_impl(this, a2, a3);
  ERR_restore_state(v6);
  if (v6) {
    ERR_SAVE_STATE_free((uint64_t)v6);
  }
}

void sub_1875C2498(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

char *__boringssl_config_get_whitelisted_bundle_identifier_block_invoke()
{
  if (csops() == -1
    && *__error() == 34
    && (uint64_t v0 = bswap32(0xAAAAAAAA), (v0 - 1025) >= 0xFFFFFC07)
    && (getpid(), !csops()))
  {
    csops_identifier_data_csops_data[v0] = 0;
    if (qword_18C4C50C4 == 0x6C7070612E6D6F63LL && word_18C4C50CC == 11877) {
      uint64_t result = strdup((const char *)&qword_18C4C50C4);
    }
    else {
      uint64_t result = "redacted_bundle_id";
    }
  }

  else
  {
    uint64_t result = "no_bundle_id";
  }

  global_bundle_identifieBIGNUM r = (uint64_t)result;
  return result;
}

uint64_t boringssl_config_get_tickets_enabled()
{
  return 0LL;
}

uint64_t boringssl_config_get_resumption_enabled()
{
  return 1LL;
}

uint64_t boringssl_config_get_false_start_enabled()
{
  return 1LL;
}

uint64_t boringssl_config_get_tls13_external_psk_enabled()
{
  if (boringssl_config_get_whitelisted_bundle_identifier_onceToken != -1) {
    dispatch_once(&boringssl_config_get_whitelisted_bundle_identifier_onceToken, &__block_literal_global_2);
  }
  uint64_t v0 = (const char *)global_bundle_identifier;
  uint64_t result = strcmp((const char *)global_bundle_identifier, "redacted_bundle_id");
  if ((_DWORD)result) {
    return strcmp(v0, "no_bundle_id") != 0;
  }
  return result;
}

uint64_t boringssl_config_restricted_mode_restrict_tls_version(uint64_t result)
{
  else {
    return result;
  }
}

uint64_t boringssl_config_restricted_mode_restrict_dtls_version(uint64_t result)
{
  else {
    return result;
  }
}

void __check_and_init_restricted_mode_block_invoke()
{
  uint64_t v0 = (const __CFNumber *)MGCopyAnswer();
  if (v0)
  {
    uint64_t v1 = v0;
    CFNumberGetValue(v0, kCFNumberIntType, &boringssl_config_restricted_mode_status);
    CFRelease(v1);
  }

void **std::unique_ptr<bssl::anonymous namespace'::ECKeyShare,bssl::internal::Deleter>::~unique_ptr[abi:ne180100]( void **a1)
{
  unsigned int v2 = *a1;
  *a1 = 0LL;
  if (v2)
  {
    (*(void (**)(void *))*v2)(v2);
    OPENSSL_free(v2);
  }

  return a1;
}

BOOL bssl::ssl_nid_to_group_id(bssl *this, unsigned __int16 *a2)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    if (v3 == (_DWORD)a2) {
      break;
    }
    v2 += 18LL;
    if (v2 == 108) {
      return v3 == (_DWORD)a2;
    }
  }

  return v3 == (_DWORD)a2;
}

uint64_t bssl::ssl_name_to_group_id(bssl *this, const char *a2, const char *a3)
{
  uint64_t v6 = 0LL;
  while (1)
  {
    {
      break;
    }

    char v8 = (const char *)strlen((const char *)v7 + 38);
    BOOL v9 = v8 && v8 == a3;
    v6 += 18LL;
    if (v6 == 108) {
      return 0LL;
    }
  }

  return 1LL;
}

char *SSL_get_group_name(int a1)
{
  uint64_t v1 = 0LL;
  {
    v1 += 18LL;
    if (v1 == 108) {
      return 0LL;
    }
  }
}

void bssl::anonymous namespace'::ECKeyShare::~ECKeyShare(BIGNUM **this)
{
  *thiunsigned int s = (BIGNUM *)off_18A071858;
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](this + 1, 0LL);
}

{
  *thiunsigned int s = (BIGNUM *)off_18A071858;
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](this + 1, 0LL);
  operator delete(this);
}

uint64_t bssl::anonymous namespace'::ECKeyShare::GroupID(bssl::_anonymous_namespace_::ECKeyShare *this)
{
  return *((unsigned __int16 *)this + 12);
}

BOOL bssl::anonymous namespace'::ECKeyShare::Generate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (BIGNUM **)(a1 + 8);
  if (*(void *)(a1 + 8)) {
  int v5 = BN_new();
  }
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](v2, v5);
  char v8 = *v2;
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = EC_GROUP_get0_order(*(void *)(a1 + 16), v6, v7);
  uint64_t v10 = EC_POINT_new(*(const EC_GROUP **)(a1 + 16));
  if (!v10) {
    return 0LL;
  }
  char v11 = v10;
  if (EC_POINT_mul(*(const EC_GROUP **)(a1 + 16), v10, *(const BIGNUM **)(a1 + 8), 0LL, 0LL, 0LL)) {
    BOOL v12 = EC_POINT_point2cbb(a2, *(EC_GROUP **)(a1 + 16), v11, POINT_CONVERSION_UNCOMPRESSED, 0LL) != 0;
  }
  else {
    BOOL v12 = 0LL;
  }
  EC_POINT_free(v11);
  return v12;
}

void sub_1875C2964(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t bssl::anonymous namespace'::ECKeyShare::Encap( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  *a4 = 80;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))(*(void *)a1 + 40LL))( a1,  a3,  a4,  a5,  a6);
  }
  return result;
}

uint64_t bssl::anonymous namespace'::ECKeyShare::Decap( uint64_t a1, uint64_t a2, _BYTE *a3, const unsigned __int8 *a4, size_t a5)
{
  if (!*(void *)(a1 + 16)) {
  if (!*(void *)(a1 + 8))
  }
  *a3 = 80;
  uint64_t v10 = EC_POINT_new(*(const EC_GROUP **)(a1 + 16));
  unint64_t v23 = v10;
  char v11 = EC_POINT_new(*(const EC_GROUP **)(a1 + 16));
  int v22 = v11;
  BOOL v12 = BN_new();
  int v13 = v12;
  unsigned int v21 = v12;
  if (v10 && v11 && v12)
  {
    if (a5 && *a4 == 4 && EC_POINT_oct2point(*(const EC_GROUP **)(a1 + 16), v10, a4, a5, 0LL))
    {
      if (EC_POINT_mul(*(const EC_GROUP **)(a1 + 16), v11, 0LL, v10, *(const BIGNUM **)(a1 + 8), 0LL)
        && EC_POINT_get_affine_coordinates_GFp(*(const EC_GROUP **)(a1 + 16), v11, v13, 0LL, 0LL))
      {
        int v19 = 0LL;
        unint64_t v20 = 0LL;
        int degree = EC_GROUP_get_degree(*(const EC_GROUP **)(a1 + 16));
        if (bssl::Array<unsigned char>::Init((uint64_t)&v19, (degree + 7) >> 3)
          && BN_bn2bin_padded(v19, v20, (uint64_t)v13))
        {
          OPENSSL_free(*(void **)a2);
          unint64_t v15 = v20;
          *(void *)a2 = v19;
          *(void *)(a2 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = v15;
          int v19 = 0LL;
          unint64_t v20 = 0LL;
          uint64_t v16 = 1LL;
        }

        else
        {
          uint64_t v16 = 0LL;
        }

        bssl::Array<unsigned short>::~Array((uint64_t)&v19);
      }

      else
      {
        uint64_t v16 = 0LL;
      }
    }

    else
    {
      ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 94);
      uint64_t v16 = 0LL;
      *a3 = 50;
    }

    unsigned int v21 = 0LL;
    goto LABEL_18;
  }

  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  unsigned int v21 = 0LL;
  if (v12)
  {
LABEL_18:
    BN_free(v13);
    uint64_t v17 = v16;
  }

  int v22 = 0LL;
  if (v11) {
    EC_POINT_free(v11);
  }
  unint64_t v23 = 0LL;
  if (v10) {
    EC_POINT_free(v10);
  }
  return v17;
}

void sub_1875C2BDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, BIGNUM *);
  va_copy(va3, va2);
  char v8 = va_arg(va3, EC_POINT *);
  bssl::Array<unsigned short>::~Array((uint64_t)va);
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100]((BIGNUM **)va1, 0LL);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va2, 0LL);
  std::unique_ptr<ec_point_st,bssl::internal::Deleter>::reset[abi:ne180100]((EC_POINT **)va3, 0LL);
  _Unwind_Resume(a1);
}

BOOL bssl::anonymous namespace'::ECKeyShare::SerializePrivateKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4) {
  if (!*(void *)(a1 + 8))
  }
  uint64_t v6 = (const BIGNUM *)EC_GROUP_get0_order(v4, a2, a3);
  unsigned int v7 = BN_num_bytes(v6);
  return BN_bn2cbb_padded(a2, v7, *(void *)(a1 + 8)) != 0;
}

BOOL bssl::anonymous namespace'::ECKeyShare::DeserializePrivateKey(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (BIGNUM **)(a1 + 8);
  if (*(void *)(a1 + 8)) {
  uint64_t v3 = BN_bin2bn(*(const unsigned __int8 **)a2, *(void *)(a2 + 8), 0LL);
  }
  std::unique_ptr<bignum_st,bssl::internal::Deleter>::reset[abi:ne180100](v2, v3);
  return *v2 != 0LL;
}

BOOL bssl::anonymous namespace'::X25519KeyShare::Generate(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[0] = v3;
  v5[1] = v3;
  X25519_keypair(v5, (unsigned __int8 *)(a1 + 8));
  return CBB_add_bytes(a2, v5, 0x20uLL) != 0;
}

uint64_t bssl::anonymous namespace'::X25519KeyShare::Encap( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  *a4 = 80;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))(*(void *)a1 + 40LL))( a1,  a3,  a4,  a5,  a6);
  }
  return result;
}

uint64_t bssl::anonymous namespace'::X25519KeyShare::Decap( uint64_t a1, uint64_t a2, _BYTE *a3, int64x2_t *a4, uint64_t a5)
{
  *a3 = 80;
  OPENSSL_free(0LL);
  uint64_t v10 = (char *)OPENSSL_malloc(0x20uLL);
  char v11 = v10;
  if (v10)
  {
    if (a5 == 32 && X25519(v10, (__int128 *)(a1 + 8), a4))
    {
      OPENSSL_free(*(void **)a2);
      *(void *)a2 = v11;
      *(void *)(a2 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 32LL;
      uint64_t v12 = 1LL;
      char v11 = 0LL;
    }

    else
    {
      *a3 = 50;
      ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 170);
      uint64_t v12 = 0LL;
    }
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  OPENSSL_free(v11);
  return v12;
}

void sub_1875C2ED0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL bssl::anonymous namespace'::X25519KeyShare::SerializePrivateKey(uint64_t a1, uint64_t a2)
{
  return CBB_add_bytes(a2, (const void *)(a1 + 8), 0x20uLL) != 0;
}

BOOL bssl::anonymous namespace'::X25519KeyShare::DeserializePrivateKey(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8) == 32LL && CBS_copy_bytes(a2, (void *)(a1 + 8), 0x20uLL) != 0;
}

uint64_t bssl::anonymous namespace'::X25519Kyber768KeyShare::GroupID( bssl::_anonymous_namespace_::X25519Kyber768KeyShare *this)
{
  return 25497LL;
}

uint64_t bssl::anonymous namespace'::X25519Kyber768KeyShare::Generate(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = v4;
  v7[1] = v4;
  X25519_keypair(v7, (unsigned __int8 *)(a1 + 8));
  memset(v6, 170, sizeof(v6));
  KYBER_generate_key(v6, a1 + 40);
  uint64_t result = CBB_add_bytes(a2, v7, 0x20uLL);
  if ((_DWORD)result) {
    return CBB_add_bytes(a2, v6, 0x4A0uLL) != 0;
  }
  return result;
}

uint64_t bssl::anonymous namespace'::X25519Kyber768KeyShare::Encap()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v0;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  OPENSSL_free(0LL);
  uint64_t v21 = 0LL;
  uint64_t v12 = (char *)OPENSSL_malloc(0x40uLL);
  unint64_t v20 = v12;
  if (!v12) {
    goto LABEL_11;
  }
  uint64_t v21 = 64LL;
  int v13 = (unsigned __int8 *)(v11 + 8);
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[0] = v14;
  v24[1] = v14;
  X25519_keypair(v24, v13);
  memset(__b, 170, sizeof(__b));
  memset(v17, 170, sizeof(v17));
  uint64_t v18 = v4;
  uint64_t v19 = v2;
  if (!CBS_get_bytes(&v18, &v17[2], 0x20uLL)
    || !CBS_get_bytes(&v18, v17, 0x4A0uLL)
    || v19
    || !X25519(v12, (__int128 *)v13, (int64x2_t *)v17[2])
    || !KYBER_parse_public_key((uint64_t)__b, v17))
  {
    _BYTE *v6 = 50;
    ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 239);
    uint64_t v15 = 0LL;
    goto LABEL_12;
  }

  memset(v22, 170, sizeof(v22));
  KYBER_encap(v22, v12 + 32, (uint64_t)__b);
  if (!CBB_add_bytes(v10, v24, 0x20uLL) || !CBB_add_bytes(v10, v22, 0x440uLL))
  {
LABEL_11:
    uint64_t v15 = 0LL;
    goto LABEL_12;
  }

  OPENSSL_free(*(void **)v8);
  *(void *)uint64_t v8 = v12;
  *(void *)(v8 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 64LL;
  unint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v15 = 1LL;
  uint64_t v12 = 0LL;
LABEL_12:
  OPENSSL_free(v12);
  return v15;
}

void sub_1875C3208( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t bssl::anonymous namespace'::X25519Kyber768KeyShare::Decap( uint64_t a1, uint64_t a2, _BYTE *a3, int64x2_t *a4, uint64_t a5)
{
  *a3 = 80;
  OPENSSL_free(0LL);
  uint64_t v10 = (char *)OPENSSL_malloc(0x40uLL);
  uint64_t v11 = v10;
  if (v10)
  {
    if (a5 == 1120 && X25519(v10, (__int128 *)(a1 + 8), a4))
    {
      KYBER_decap(v11 + 32, (unsigned __int8 *)&a4[2], a1 + 40);
      OPENSSL_free(*(void **)a2);
      *(void *)a2 = v11;
      *(void *)(a2 + bssl::Array<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::~Array(v1 + 8) = 64LL;
      uint64_t v12 = 1LL;
      uint64_t v11 = 0LL;
    }

    else
    {
      *a3 = 50;
      ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/boringssl/ssl/ssl_key_share.cc", 269);
      uint64_t v12 = 0LL;
    }
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  OPENSSL_free(v11);
  return v12;
}

void sub_1875C3338( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boringssl_helper_dispatch_data_copyout(dispatch_data_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000LL;
  uint64_t v10 = 0LL;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2020000000LL;
  _OWORD v6[3] = a2;
  if (a1)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __boringssl_helper_dispatch_data_copyout_block_invoke;
    applier[3] = &unk_18A071998;
    void applier[5] = v6;
    applier[6] = a3;
    void applier[4] = &v7;
    dispatch_data_apply(a1, applier);
    uint64_t v3 = v8[3];
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v7, 8);
  return v3;
}

BOOL __boringssl_helper_dispatch_data_copyout_block_invoke( void *a1, int a2, int a3, void *__src, size_t a5)
{
  unint64_t v5 = a1[6];
  unint64_t v6 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v5 - v6 >= a5) {
    size_t v7 = a5;
  }
  else {
    size_t v7 = v5 - v6;
  }
  if (v7)
  {
    memcpy((void *)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + v6), __src, v7);
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += v7;
    unint64_t v6 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
    unint64_t v5 = a1[6];
  }

  return v6 < v5;
}

uint64_t boringssl_helper_convert_trusterror_to_alertcode(int a1)
{
  if (a1 <= -67736)
  {
    if (a1 > -67820)
    {
      return 46LL;
    }

    if (a1 != -67880 && a1 != -67843)
    {
      if (a1 == -67820) {
        return 44LL;
      }
      return 46LL;
    }

    return 42LL;
  }

  if (a1 <= -67613)
  {
    if (a1 == -67735 || a1 == -67655) {
      return 42LL;
    }
  }

  else
  {
    switch(a1)
    {
      case -67612:
        return 48LL;
      case -67602:
        return 42LL;
      case -25318:
        return 48LL;
    }
  }

  return 46LL;
}

uint64_t boringssl_helper_convert_alert_code(int a1, int a2)
{
  if (a1 <= 69)
  {
    switch(a1)
    {
      case 20:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9846;
        unsigned int v4 = -9820;
        break;
      case 21:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9845;
        unsigned int v4 = -9821;
        break;
      case 22:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9847;
        unsigned int v4 = -9822;
        break;
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
        return 4294957494LL;
      case 30:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9857;
        unsigned int v4 = -9823;
        break;
      case 40:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9858;
        unsigned int v4 = -9824;
        break;
      case 41:
      case 46:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9808;
        unsigned int v4 = -9825;
        break;
      case 42:
        return 4294957488LL;
      case 43:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9808;
        unsigned int v4 = -9826;
        break;
      case 44:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9808;
        unsigned int v4 = -9827;
        break;
      case 45:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9814;
        unsigned int v4 = -9828;
        break;
      case 47:
        return 4294957466LL;
      case 48:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9813;
        unsigned int v4 = -9831;
        break;
      case 49:
        return 4294957464LL;
      case 50:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9859;
        unsigned int v4 = -9833;
        break;
      case 51:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9845;
        unsigned int v4 = -9834;
        break;
      case 60:
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9802;
        unsigned int v4 = -9835;
        break;
      default:
        if (!a1) {
          return 4294957491LL;
        }
        if (a1 != 10) {
          return 4294957494LL;
        }
        BOOL v2 = a2 == 16388;
        unsigned int v3 = -9856;
        unsigned int v4 = -9819;
        break;
    }

BOOL boringssl_helper_dispatch_data_equal(void *a1, void *a2)
{
  unsigned int v3 = a1;
  unsigned int v4 = a2;
  unint64_t v5 = v4;
  BOOL v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
  {
    size_t size = dispatch_data_get_size(v3);
    if (size == dispatch_data_get_size(v5))
    {
      uint64_t v12 = 0LL;
      int v13 = &v12;
      uint64_t v14 = 0x2020000000LL;
      char v15 = 1;
      v9[0] = MEMORY[0x1895F87A8];
      v9[1] = 3221225472LL;
      __int128 v9[2] = __boringssl_helper_dispatch_data_equal_block_invoke;
      _OWORD v9[3] = &unk_18A0719E8;
      uint64_t v10 = v5;
      uint64_t v11 = &v12;
      dispatch_data_apply(v3, v9);
      BOOL v6 = *((_BYTE *)v13 + 24) != 0;

      _Block_object_dispose(&v12, 8);
    }

    else
    {
      BOOL v6 = 0LL;
    }
  }

  return v6;
}

uint64_t __boringssl_helper_dispatch_data_equal_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _OWORD v8[2] = __boringssl_helper_dispatch_data_equal_block_invoke_2;
  _OWORD v8[3] = &unk_18A0719C0;
  BOOL v6 = *(dispatch_data_s **)(a1 + 32);
  _OWORD v8[4] = *(void *)(a1 + 40);
  _DWORD v8[5] = a3;
  v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

BOOL __boringssl_helper_dispatch_data_equal_block_invoke_2( void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = a1[5];
  uint64_t v6 = a1[6];
  if (v7 <= a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a1[5];
  }
  unint64_t v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3) {
    unint64_t v10 = a5 + a3;
  }
  else {
    unint64_t v10 = v6 + v7;
  }
  BOOL v11 = v10 > v8;
  size_t v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = memcmp( (const void *)(a4 + v8 - a3),  (const void *)(a1[7] + v8 - v7),  v12) == 0;
  }

  else
  {
    if (v9 < a3) {
      return 0LL;
    }
    if (a5 + a3 < v7) {
      return 1LL;
    }
  }

  return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
}

id boringssl_helper_create_protocol_list_from_encoded_list(uint64_t a1, size_t a2)
{
  id v2 = 0LL;
  if (a1 && a2)
  {
    xpc_object_t v5 = xpc_array_create(0LL, 0LL);
    if (v5)
    {
      size_t v6 = 0LL;
      while (1)
      {
        size_t v7 = *(unsigned __int8 *)(a1 + v6);
        if (v6 + v7 >= a2) {
          break;
        }
        size_t v8 = v7 + 1;
        unint64_t v9 = (char *)malloc(v7 + 1);
        if (!v9) {
          break;
        }
        unint64_t v10 = v9;
        memcpy(v9, (const void *)(a1 + v6 + 1), v7);
        v10[v7] = 0;
        xpc_object_t v11 = xpc_string_create(v10);
        if (!v11)
        {
          free(v10);
          break;
        }

        size_t v12 = v11;
        xpc_array_append_value(v5, v11);
        free(v10);
        v6 += v8;

        if (v6 >= a2)
        {
          id v2 = v5;
          goto LABEL_12;
        }
      }
    }

    id v2 = 0LL;
LABEL_12:
  }

  return v2;
}

BOOL boringssl_helper_find_first_overlapping_protocol(void *a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7 = a2;
  size_t v8 = v7;
  BOOL v9 = 0LL;
  *a4 = 0;
  if (a1 && v7 && a3)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __boringssl_helper_find_first_overlapping_protocol_block_invoke;
    applier[3] = &unk_18A071A38;
    id v12 = v7;
    int v13 = a4;
    uint64_t v14 = a3;
    BOOL v9 = !xpc_array_apply(a1, applier);
  }

  return v9;
}

BOOL __boringssl_helper_find_first_overlapping_protocol_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  size_t length = xpc_string_get_length(v4);
  v11[0] = 0LL;
  v11[1] = v11;
  void v11[2] = 0x2020000000LL;
  string_int ptr = (const char *)0xAAAAAAAAAAAAAAAALL;
  string_int ptr = xpc_string_get_string_ptr(v4);
  size_t v6 = *(void **)(a1 + 32);
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  __int128 v9[2] = __boringssl_helper_find_first_overlapping_protocol_block_invoke_2;
  _OWORD v9[3] = &unk_18A071A10;
  void v9[4] = v11;
  v9[5] = length;
  __int128 v10 = *(_OWORD *)(a1 + 40);
  BOOL v7 = xpc_array_apply(v6, v9);
  _Block_object_dispose(v11, 8);

  return v7;
}

void sub_1875C3C24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t __boringssl_helper_find_first_overlapping_protocol_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  size_t length = xpc_string_get_length(v4);
  string_int ptr = xpc_string_get_string_ptr(v4);

  if (*(void *)(a1 + 40) != length) {
    return 1LL;
  }
  uint64_t result = strncmp(*(const char **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), string_ptr, length);
  if ((_DWORD)result) {
    return 1LL;
  }
  **(_BYTE **)(a1 + 4_Block_object_dispose(va, 8) = length;
  **(void **)(a1 + 56) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  return result;
}

void *boringssl_helper_create_certificate_sec_array_from_CFArray(const __CFArray *a1)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = (void *)sec_array_create();
  if (v2)
  {
    if (CFArrayGetCount(a1) >= 1)
    {
      CFIndex v3 = 0LL;
      do
      {
        ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(a1, v3);
        if (ValueAtIndex)
        {
          sec_certificate_t v5 = sec_certificate_create(ValueAtIndex);
          sec_array_append();
        }

        ++v3;
      }

      while (v3 < CFArrayGetCount(a1));
    }

    id v6 = v2;
  }

  return v2;
}

uint64_t boringssl_helper_SecKeyAlgorithm_from_signature_algorithm(int a1)
{
  uint64_t v1 = MEMORY[0x18960BD48];
  uint64_t v2 = MEMORY[0x18960BD38];
  uint64_t v3 = MEMORY[0x18960BD40];
  uint64_t v4 = MEMORY[0x18960BD00];
  if (a1 != 65281) {
    uint64_t v4 = MEMORY[0x18960BD48];
  }
  if (a1 != 2054) {
    uint64_t v3 = v4;
  }
  if (a1 != 2053) {
    uint64_t v2 = v3;
  }
  uint64_t v5 = MEMORY[0x18960BD28];
  uint64_t v6 = MEMORY[0x18960BC80];
  uint64_t v7 = MEMORY[0x18960BD30];
  if (a1 != 2052) {
    uint64_t v7 = MEMORY[0x18960BD48];
  }
  if (a1 != 1539) {
    uint64_t v6 = v7;
  }
  if (a1 != 1537) {
    uint64_t v5 = v6;
  }
  if (a1 <= 2052) {
    uint64_t v2 = v5;
  }
  uint64_t v8 = MEMORY[0x18960BC80];
  uint64_t v9 = MEMORY[0x18960BD20];
  uint64_t v10 = MEMORY[0x18960BC88];
  if (a1 != 1283) {
    uint64_t v10 = MEMORY[0x18960BD48];
  }
  if (a1 != 1281) {
    uint64_t v9 = v10;
  }
  if (a1 != 1027) {
    uint64_t v8 = v9;
  }
  if (a1 == 1025) {
    uint64_t v1 = MEMORY[0x18960BD18];
  }
  if (a1 == 515) {
    uint64_t v1 = MEMORY[0x18960BC70];
  }
  if (a1 == 513) {
    uint64_t v1 = MEMORY[0x18960BD08];
  }
  if (a1 > 1026) {
    uint64_t v1 = v8;
  }
  if (a1 > 1536) {
    uint64_t v1 = v2;
  }
  return *(void *)v1;
}

uint64_t boringssl_helper_zlib_compress_data(void *a1, uint64_t a2, uLong a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = a4;
  uint64_t v9 = (unsigned int (**)(void, void, void))v8;
  uint64_t v10 = 0LL;
  if (v7 && a2 && a3 && v8)
  {
    memset(&v31, 0, sizeof(v31));
    if (deflateInit_(&v31, -1, "1.2.12", 112))
    {
      id WeakRetained = objc_loadWeakRetained(v7 + 2);
      if (WeakRetained)
      {
        id v12 = WeakRetained;
        int v13 = objc_loadWeakRetained(v7 + 2);
        char v14 = v13[475];

        if ((v14 & 1) != 0)
        {
LABEL_29:
          uint64_t v10 = 0LL;
          goto LABEL_38;
        }
      }

      id v15 = objc_loadWeakRetained(v7 + 2);
      if (v15)
      {
        uint64_t v16 = objc_loadWeakRetained(v7 + 2);
        BOOL v17 = (v16[475] & 1) == 0;
      }

      else
      {
        BOOL v17 = 1;
      }

      uint64_t v10 = 0LL;
      if (v17 && g_boringssl_log)
      {
        unint64_t v28 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          boringssl_helper_zlib_compress_data_cold_2(v7, v28);
        }

        goto LABEL_29;
      }
    }

    else
    {
      memset(__b, 170, sizeof(__b));
      while (2)
      {
        uInt v18 = a3 - LODWORD(v31.total_in);
        if (a3 - v31.total_in >= 0x400) {
          uInt v18 = 1024;
        }
        v31.avail_iuint64_t n = v18;
        v31.next_iuint64_t n = (Bytef *)(a2 + v31.total_in);
        uLong v19 = v31.total_in + 1024;
        int v20 = 4 * (v31.total_in + 1024 >= a3);
        do
        {
          v31.avail_out = 1024;
          v31.next_out = __b;
          if (deflate(&v31, v20) == -2)
          {
            id v21 = objc_loadWeakRetained(v7 + 2);
            if (!v21
              || (int v22 = v21,
                  unint64_t v23 = objc_loadWeakRetained(v7 + 2),
                  char v24 = v23[475],
                  v23,
                  v22,
                  (v24 & 1) == 0))
            {
              id v25 = objc_loadWeakRetained(v7 + 2);
              if (v25)
              {
                int v26 = objc_loadWeakRetained(v7 + 2);
                BOOL v27 = (v26[475] & 1) == 0;
              }

              else
              {
                BOOL v27 = 1;
              }

              uint64_t v10 = 0LL;
              if (!v27 || !g_boringssl_log) {
                goto LABEL_37;
              }
              unsigned int v29 = (os_log_s *)(id)g_boringssl_log;
              if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
                boringssl_helper_zlib_compress_data_cold_1(v7, v29);
              }
            }

uint64_t boringssl_helper_zlib_decompress_data(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = a4;
  uint64_t v9 = (unsigned int (**)(void, void, void))v8;
  uint64_t v10 = 0LL;
  if (v7 && a2 && a3 && v8)
  {
    memset(&v22, 0, sizeof(v22));
    if (inflateInit_(&v22, "1.2.12", 112))
    {
      id WeakRetained = objc_loadWeakRetained(v7 + 2);
      if (WeakRetained)
      {
        id v12 = WeakRetained;
        int v13 = objc_loadWeakRetained(v7 + 2);
        char v14 = v13[475];

        if ((v14 & 1) != 0)
        {
LABEL_28:
          uint64_t v10 = 0LL;
          goto LABEL_31;
        }
      }

      id v15 = objc_loadWeakRetained(v7 + 2);
      if (v15)
      {
        uint64_t v16 = objc_loadWeakRetained(v7 + 2);
        BOOL v17 = (v16[475] & 1) == 0;
      }

      else
      {
        BOOL v17 = 1;
      }

      uint64_t v10 = 0LL;
      if (v17 && g_boringssl_log)
      {
        int v20 = (os_log_s *)(id)g_boringssl_log;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          boringssl_helper_zlib_decompress_data_cold_1(v7, v20);
        }

        goto LABEL_28;
      }
    }

    else
    {
      memset(__b, 170, sizeof(__b));
      while (1)
      {
        uInt v18 = a3 - LODWORD(v22.total_in);
        if (a3 - v22.total_in >= 0x400) {
          uInt v18 = 1024;
        }
        v22.avail_iuint64_t n = v18;
        if (!v18) {
          break;
        }
        v22.avail_out = 1024;
        v22.next_iuint64_t n = (Bytef *)(a2 + v22.total_in);
        v22.next_out = __b;
        uint64_t v19 = inflate(&v22, 0);
        if ((_DWORD)v19 == 2)
        {
          uint64_t v10 = 4294967293LL;
        }

        else
        {
          uint64_t v10 = v19;
        }

        if (!((unsigned int (**)(void, _BYTE *, uint64_t))v9)[2](v9, __b, 1024LL - v22.avail_out))
        {
LABEL_21:
          uint64_t v10 = 0LL;
          goto LABEL_30;
        }

        if ((_DWORD)v10 == 1) {
          goto LABEL_30;
        }
      }

      uint64_t v10 = 1LL;
LABEL_30:
      inflateEnd(&v22);
    }
  }

__CFArray *boringssl_helper_copy_identity_certificate_chain_from_identity_array(const __CFArray *a1)
{
  if (!a1) {
    return 0LL;
  }
  unsigned int Count = CFArrayGetCount(a1);
  uint64_t v3 = Count;
  if (!Count) {
    return 0LL;
  }
  int v4 = Count;
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (!Mutable)
  {
    uint64_t v6 = (__CFArray *)g_boringssl_log;
    if (!g_boringssl_log) {
      return v6;
    }
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_1();
    }
    return 0LL;
  }

  uint64_t v6 = Mutable;
  ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(a1, 0LL);
  if (!ValueAtIndex)
  {
    uint64_t v6 = (__CFArray *)g_boringssl_log;
    if (!g_boringssl_log) {
      return v6;
    }
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_2();
    }
    return 0LL;
  }

  id v8 = ValueAtIndex;
  CFTypeID v9 = CFGetTypeID(ValueAtIndex);
  if (v9 != SecIdentityGetTypeID())
  {
    uint64_t v6 = (__CFArray *)g_boringssl_log;
    if (!g_boringssl_log) {
      return v6;
    }
    if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_4();
    }
    return 0LL;
  }

  SecCertificateRef certificateRef = 0LL;
  if (SecIdentityCopyCertificate(v8, &certificateRef) || (SecCertificateRef v10 = certificateRef) == 0LL)
  {
    if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
      boringssl_helper_copy_identity_certificate_chain_from_identity_array_cold_3();
    }
    return 0LL;
  }

  CFArrayAppendValue(v6, certificateRef);
  CFRelease(v10);
  if (v4 >= 2)
  {
    if (v3 <= 2) {
      uint64_t v11 = 2LL;
    }
    else {
      uint64_t v11 = v3;
    }
    for (CFIndex i = 1LL; i != v11; ++i)
    {
      int v13 = CFArrayGetValueAtIndex(a1, i);
      CFArrayAppendValue(v6, v13);
    }
  }

  return v6;
}

CFArrayRef boringssl_helper_copy_leaf_private_key_from_identity_array(const __CFArray *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (const __CFArray *)CFArrayGetCount(result);
    if (result)
    {
      ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(v1, 0LL);
      if (ValueAtIndex)
      {
        uint64_t v3 = ValueAtIndex;
        CFTypeID v4 = CFGetTypeID(ValueAtIndex);
        if (v4 == SecIdentityGetTypeID())
        {
          SecKeyRef privateKeyRef = 0LL;
          if (!SecIdentityCopyPrivateKey(v3, &privateKeyRef)) {
            return privateKeyRef;
          }
          if (g_boringssl_log)
          {
            if (os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR)) {
              boringssl_helper_copy_leaf_private_key_from_identity_array_cold_2();
            }
          }
        }

        else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
        {
          boringssl_helper_copy_leaf_private_key_from_identity_array_cold_3();
        }
      }

      else if (g_boringssl_log && os_log_type_enabled((os_log_t)g_boringssl_log, OS_LOG_TYPE_ERROR))
      {
        boringssl_helper_copy_leaf_private_key_from_identity_array_cold_1();
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t boringssl_helper_create_certificate_buffer_chain_from_certificate_chain(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = &v4;
    uint64_t v6 = 0x2020000000LL;
    uint64_t v7 = (void *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v7 = OPENSSL_sk_new_null();
    sec_array_apply();
    uint64_t v2 = v5[3];
    _Block_object_dispose(&v4, 8);
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  return v2;
}

void sub_1875C4708( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __boringssl_helper_create_certificate_buffer_chain_from_certificate_chain_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = sec_certificate_copy_ref(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      id v8 = SecCertificateCopyData(v6);
      if (v8)
      {
        CFTypeID v9 = v8;
        BytePtBIGNUM r = CFDataGetBytePtr(v8);
        CFIndex Length = CFDataGetLength(v9);
        uint64_t v12 = CRYPTO_BUFFER_new(BytePtr, Length, 0LL);
        if (v12) {
          OPENSSL_sk_push(*(unint64_t **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v12);
        }
        CFRelease(v9);
      }

      CFRelease(v7);
    }
  }

  return 1LL;
}

void boringssl_helper_dump_dispatch_data(void *a1, dispatch_data_s *a2)
{
  id v3 = a1;
  if (a2)
  {
    applier[1] = 3221225472LL;
    applier[2] = __boringssl_helper_dump_dispatch_data_block_invoke;
    applier[3] = &unk_18A071A88;
    id v4 = v3;
    applier[0] = MEMORY[0x1895F87A8];
    id v6 = v3;
    dispatch_data_apply(a2, applier);

    id v3 = v4;
  }
}

uint64_t __boringssl_helper_dump_dispatch_data_block_invoke( uint64_t a1, void *a2, __int128 *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  id v51 = a2;
  uint64_t v9 = *(void *)(a1 + 32);
  if (!v9) {
    goto LABEL_10;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(v9 + 16));
  if (!WeakRetained
    || (uint64_t v11 = WeakRetained,
        uint64_t v12 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL)),
        char v13 = v12[475],
        v12,
        v11,
        (v13 & 1) == 0))
  {
    uint64_t v14 = *(void *)(a1 + 32);
    if (!v14) {
      goto LABEL_10;
    }
    id v15 = objc_loadWeakRetained((id *)(v14 + 16));
    if (v15)
    {
      uint64_t v16 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16LL));
      BOOL v17 = (v16[475] & 1) == 0;
    }

    else
    {
      BOOL v17 = 1;
    }

    if (v17)
    {
LABEL_10:
      if (g_boringssl_log)
      {
        uInt v18 = (os_log_s *)(id)g_boringssl_log;
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_INFO)) {
          goto LABEL_27;
        }
        uint64_t v19 = *(void *)(a1 + 32);
        if (v19)
        {
          int v20 = (char *)objc_loadWeakRetained((id *)(v19 + 16));
          uint64_t v5 = v20;
          uint64_t v21 = *(void *)(a1 + 32);
          if (v20)
          {
            BOOL v22 = v21 != 0;
            if (v21)
            {
              int v20 = (char *)objc_loadWeakRetained((id *)(v21 + 16));
              uint64_t v21 = *(void *)(a1 + 32);
            }

            else
            {
              int v20 = 0LL;
            }

            id v25 = v20 + 391;
          }

          else
          {
            BOOL v22 = 0;
            id v25 = &unk_1875F4C23;
          }

          unsigned int v56 = v20;
          if (v21)
          {
            id v23 = objc_loadWeakRetained((id *)(v21 + 16));
            char v24 = 0;
          }

          else
          {
            id v23 = 0LL;
            char v24 = 1;
          }
        }

        else
        {
          BOOL v22 = 0;
          id v23 = 0LL;
          char v24 = 1;
          id v25 = &unk_1875F4C23;
        }

        *(_DWORD *)buf = 136447490;
        int v59 = "boringssl_helper_dump_dispatch_data_block_invoke";
        __int16 v60 = 1024;
        int v61 = 949;
        __int16 v62 = 2082;
        unsigned int v63 = v25;
        __int16 v64 = 2048;
        id v65 = v23;
        __int16 v66 = 2048;
        id v67 = v51;
        __int16 v68 = 2048;
        unsigned int v69 = a3;
        _os_log_impl( &dword_187560000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s(%d) %{public}s[%p] data region %p, offset %zu",  buf,  0x3Au);
        if ((v24 & 1) != 0)
        {
          if (!v22) {
            goto LABEL_25;
          }
        }

        else
        {

          if (!v22)
          {
LABEL_25:
            if (v19) {
LABEL_26:
            }

LABEL_27:
            goto LABEL_28;
          }
        }

        if (!v19) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }
  }

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

uint64_t __boringssl_helper_xpc_array_union_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000LL;
  char v14 = 0;
  uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _OWORD v8[2] = __boringssl_helper_xpc_array_union_block_invoke_3;
  _OWORD v8[3] = &unk_18A071AD8;
  id v6 = v4;
  id v9 = v6;
  SecCertificateRef v10 = &v11;
  xpc_array_apply(v5, v8);
  if (!*((_BYTE *)v12 + 24)) {
    xpc_array_append_value(*(xpc_object_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), v6);
  }

  _Block_object_dispose(&v11, 8);
  return 1LL;
}

void sub_1875C4EF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __boringssl_helper_xpc_array_union_block_invoke_3(uint64_t a1, int a2, xpc_object_t object2)
{
  BOOL v4 = xpc_equal(*(xpc_object_t *)(a1 + 32), object2);
  if (v4) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return !v4;
}

void *boringssl_helper_create_buffer_from_dispatch_data(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    goto LABEL_5;
  }
  size_t size = dispatch_data_get_size(v1);
  BOOL v4 = malloc(size);
  if (v4 && boringssl_helper_dispatch_data_copyout(v2, (uint64_t)v4, size) != size)
  {
    free(v4);
LABEL_5:
    BOOL v4 = 0LL;
  }

  return v4;
}

const char *boringssl_helper_get_handshake_state_description(int a1)
{
  id v1 = "unknown state";
  if (a1 == 3) {
    id v1 = "connection established";
  }
  if (a1 == 12288) {
    return "not completed";
  }
  else {
    return v1;
  }
}

  ;
}

void OUTLINED_FUNCTION_12_1( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  int v10 = bn_minimal_width((uint64_t)m);
  int v11 = bn_minimal_width((uint64_t)d);
  if (v10 >= 1 && !m->d[v10 - 1] || v11 >= 1 && !d->d[v11 - 1])
  {
    int v12 = 111;
    int v13 = 212;
    goto LABEL_8;
  }

  if (!BN_is_zero((uint64_t)d))
  {
    BN_CTX_start(ctx);
    unint64_t v54 = BN_CTX_get(ctx);
    id v53 = BN_CTX_get(ctx);
    char v14 = BN_CTX_get(ctx);
    if (!dv) {
      dv = BN_CTX_get(ctx);
    }
    BIGNUM r = v14;
    if (!v14) {
      goto LABEL_47;
    }
    if (!dv) {
      goto LABEL_47;
    }
    int v15 = BN_num_bits(d) & 0x3F;
    if (!BN_lshift(r, d, 64 - v15)) {
      goto LABEL_47;
    }
    bn_set_minimal_width((uint64_t)r);
    r->int neg = 0;
    int n = 128 - v15;
    if (!BN_lshift(v53, m, 128 - v15)) {
      goto LABEL_47;
    }
    bn_set_minimal_width((uint64_t)v53);
    v53->int neg = 0;
    uint64_t top = v53->top;
    uint64_t v17 = r->top;
    if ((int)top <= (int)v17 + 1)
    {
      uInt v18 = v53;
      uint64_t v22 = v53->top;
      uint64_t v21 = r;
      int v23 = r->top;
      int v20 = v23 + 2;
      id v49 = v53->d;
    }

    else
    {
      uInt v18 = v53;
      uint64_t v19 = v53->top;
      id v49 = v53->d;
      v53->d[v19] = 0LL;
      int v20 = v19 + 1;
      uint64_t v21 = r;
    }

    v18->uint64_t top = v20;
    int v24 = v21->top;
    int v25 = v20 - v24;
    int v26 = v21->d;
    *(void *)unint64_t num = v24;
    if (v24 == 1) {
      unint64_t v27 = 0LL;
    }
    else {
      unint64_t v27 = v26[v24 - 2];
    }
    unint64_t v51 = v26[v24 - 1];
    int neg = m->neg;
    dv->int neg = d->neg ^ neg;
    if (bn_wexpand(&dv->d, v25 + 1))
    {
      dv->uint64_t top = v25 - 1;
      uint64_t v29 = dv->d;
      if (bn_wexpand(&v54->d, *(void *)num + 1LL))
      {
        uint64_t v30 = &v29[v25 - 1];
        unsigned int v46 = rem;
        int v45 = neg;
        if (dv->top) {
          --v30;
        }
        else {
          dv->int neg = 0;
        }
        unint64_t v31 = v51;
        if (v25 >= 2)
        {
          int v32 = 0;
          uint64_t v33 = &v49[v25];
          uint64_t v34 = &v49[v20 - 1];
          int v50 = v25 - 1;
          unint64_t v48 = v27;
          do
          {
            if (*v34 == v31)
            {
              unint64_t v35 = -1LL;
            }

            else
            {
              uint64_t v38 = *(v34 - 1);
              unint64_t v35 = __udivti3();
              unint64_t v39 = v38 - v31 * v35;
              unint64_t v40 = (v35 * (unsigned __int128)v27) >> 64;
              for (unint64_t i = v35 * v27; __PAIR128__(v39, *(v34 - 2)) < __PAIR128__(v40, i); unint64_t i = v43)
              {
                --v35;
                BOOL v42 = __CFADD__(v39, v31);
                v39 += v31;
                if (v42) {
                  break;
                }
                unsigned __int128 v43 = __PAIR128__(v40, i) - v27;
                unint64_t v40 = *((void *)&v43 + 1);
              }
            }

            unint64_t v36 = bn_mul_words(v54->d, r->d, num[0], v35);
            char v37 = v54->d;
            v54->d[*(void *)num] = v36;
            --v33;
            if (bn_sub_words(v33, v33, v37, num[0] + 1))
            {
              --v35;
              if (bn_add_words(v33, v33, r->d, num[0])) {
                ++*v34;
              }
            }

            unint64_t v27 = v48;
            unint64_t v31 = v51;
            *v30-- = v35;
            ++v32;
            --v34;
          }

          while (v32 != v50);
        }

        bn_set_minimal_width((uint64_t)v53);
        if (!v46) {
          goto LABEL_46;
        }
        if (BN_rshift(v46, v53, n))
        {
LABEL_46:
          bn_set_minimal_width((uint64_t)dv);
          BN_CTX_end(ctx);
          return 1;
        }
      }
    }