void *xmlBufCreate()
{
  void *v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  v0 = xmlMalloc(0x40uLL);
  v1 = v0;
  if (v0)
  {
    v0[4] = 0LL;
    *((_DWORD *)v0 + 14) = 0;
    v0[6] = 0LL;
    v2 = *__xmlDefaultBufferSize();
    v1[5] = v2;
    LODWORD(v3) = 0x7FFFFFFF;
    if (v1[4] < 0x7FFFFFFFuLL) {
      v3 = v1[4];
    }
    *((_DWORD *)v1 + 2) = v3;
    *((_DWORD *)v1 + 3) = v2;
    *((xmlBufferAllocationScheme *)v1 + 4) = *__xmlBufferAllocScheme();
    v4 = xmlMallocAtomic(v1[5]);
    *v1 = v4;
    if (v4)
    {
      bzero(v4, v1[5]);
      v1[3] = 0LL;
    }

    else
    {
      __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)"creating buffer");
      if (!*((_DWORD *)v1 + 14)) {
        *((_DWORD *)v1 + 14) = 2;
      }
      xmlFree(v1);
      return 0LL;
    }
  }

  else
  {
    __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)"creating buffer");
  }

  return v1;
}

uint64_t xmlBufMemoryError(uint64_t a1, uint64_t a2)
{
  uint64_t result = __xmlSimpleError(29, 2, 0, 0LL, a2);
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 56)) {
      *(_DWORD *)(a1 + 56) = 2;
    }
  }

  return result;
}

void *xmlBufCreateSize(uint64_t a1)
{
  if (a1 == -1) {
    return 0LL;
  }
  v2 = xmlMalloc(0x40uLL);
  v3 = v2;
  if (v2)
  {
    v2[4] = 0LL;
    *((_DWORD *)v2 + 14) = 0;
    v2[6] = 0LL;
    xmlBufferAllocationScheme v4 = *__xmlBufferAllocScheme();
    if (a1) {
      unint64_t v5 = a1 + 1;
    }
    else {
      unint64_t v5 = 0LL;
    }
    v3[5] = v5;
    LODWORD(v6) = 0x7FFFFFFF;
    if (v5 >= 0x7FFFFFFF) {
      LODWORD(v5) = 0x7FFFFFFF;
    }
    if (v3[4] < 0x7FFFFFFFuLL) {
      uint64_t v6 = v3[4];
    }
    *((_DWORD *)v3 + 3) = v5;
    *((_DWORD *)v3 + 4) = v4;
    *((_DWORD *)v3 + 2) = v6;
    if (!a1)
    {
      void *v3 = 0LL;
      goto LABEL_15;
    }

    v7 = xmlMallocAtomic(a1 + 1);
    void *v3 = v7;
    if (v7)
    {
      bzero(v7, v3[5]);
LABEL_15:
      v3[3] = 0LL;
      return v3;
    }

    __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)"creating buffer");
    if (!*((_DWORD *)v3 + 14)) {
      *((_DWORD *)v3 + 14) = 2;
    }
    xmlFree(v3);
    return 0LL;
  }

  __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)"creating buffer");
  return v3;
}

uint64_t xmlBufDetach(uint64_t *a1)
{
  if (!a1 || *((_DWORD *)a1 + 4) == 2 || a1[6] || *((_DWORD *)a1 + 14)) {
    return 0LL;
  }
  uint64_t v1 = *a1;
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  return v1;
}

void *xmlBufCreateStatic(void *result, unint64_t a2)
{
  if (result)
  {
    v3 = result;
    uint64_t result = xmlMalloc(0x40uLL);
    if (result)
    {
      result[4] = a2;
      result[5] = a2;
      int v4 = 0x7FFFFFFF;
      if (a2 < 0x7FFFFFFF) {
        int v4 = a2;
      }
      *((_DWORD *)result + 2) = v4;
      *((_DWORD *)result + 3) = v4;
      *((_DWORD *)result + 4) = 2;
      *uint64_t result = v3;
      *((_DWORD *)result + 14) = 0;
      result[6] = 0LL;
    }

    else
    {
      __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)"creating buffer");
      return 0LL;
    }
  }

  return result;
}

uint64_t xmlBufGetAllocationScheme(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 16);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t xmlBufSetAllocationScheme(uint64_t a1, unsigned int a2)
{
  if (!a1 || *(_DWORD *)(a1 + 56) || (*(_DWORD *)(a1 + 16) & 0xFFFFFFFE) == 2 || a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  if (a2 == 3)
  {
    *(_DWORD *)(a1 + 16) = 3;
    *(void *)(a1 + 24) = *(void *)a1;
    return 0xFFFFFFFFLL;
  }

  *(_DWORD *)(a1 + 16) = a2;
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t result = 0LL;
  if (v3) {
    *(_DWORD *)(v3 + 16) = a2;
  }
  return result;
}

void xmlBufFree(_DWORD *a1)
{
  if (a1)
  {
    int v2 = a1[4];
    if (v2 == 3)
    {
      uint64_t v3 = (void *)*((void *)a1 + 3);
      if (!v3)
      {
        uint64_t v3 = *(void **)a1;
        if (!*(void *)a1) {
          goto LABEL_12;
        }
      }
    }

    else
    {
      uint64_t v3 = *(void **)a1;
      if (v2 == 2 || v3 == 0LL) {
        goto LABEL_12;
      }
    }

    xmlFree(v3);
LABEL_12:
    xmlFree(a1);
  }
}

uint64_t xmlBufEmpty(uint64_t result)
{
  if (result)
  {
    if (!*(_DWORD *)(result + 56))
    {
      uint64_t v1 = *(_BYTE **)result;
      if (*(void *)result)
      {
        unint64_t v2 = *(void *)(result + 40);
        unint64_t v3 = *(unsigned int *)(result + 12);
        if (v3 <= 0x7FFFFFFE && v2 != v3)
        {
          *(void *)(result + 40) = v3;
          unint64_t v2 = v3;
        }

        *(void *)(result + 32) = 0LL;
        int v5 = *(_DWORD *)(result + 16);
        if (v5 == 3)
        {
          v7 = *(_BYTE **)(result + 24);
          if (v7)
          {
            *(void *)(result + 40) = v1 - v7 + v2;
            *(void *)uint64_t result = v7;
            uint64_t v1 = v7;
          }
        }

        else if (v5 == 2)
        {
          LODWORD(v6) = 0;
          *(void *)uint64_t result = &byte_181A3ACBA;
          if (v2 >= 0x7FFFFFFF) {
            LODWORD(v2) = 0x7FFFFFFF;
          }
          *(_DWORD *)(result + 12) = v2;
LABEL_20:
          int v9 = v6;
LABEL_21:
          *(_DWORD *)(result + 8) = v9;
          return result;
        }

        *uint64_t v1 = 0;
        unint64_t v6 = *(void *)(result + 32);
        unint64_t v8 = *(void *)(result + 40);
        int v9 = 0x7FFFFFFF;
        if (v8 >= 0x7FFFFFFF) {
          LODWORD(v8) = 0x7FFFFFFF;
        }
        *(_DWORD *)(result + 12) = v8;
        if (v6 > 0x7FFFFFFE) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
  }

  return result;
}

size_t xmlBufShrink(xmlBufPtr buf, size_t len)
{
  if (!buf || *((_DWORD *)buf + 14)) {
    return 0LL;
  }
  size_t v3 = len;
  uint64_t v4 = *((void *)buf + 5);
  uint64_t v5 = *((unsigned int *)buf + 3);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *((void *)buf + 5) = v5;
    uint64_t v4 = v5;
  }

  size_t v7 = *((void *)buf + 4);
  size_t v8 = *((unsigned int *)buf + 2);
  if (v8 <= 0x7FFFFFFE && v7 != v8)
  {
    *((void *)buf + 4) = v8;
    size_t v7 = v8;
  }

  if (len - 1 >= v7) {
    return 0LL;
  }
  size_t v10 = v7 - len;
  *((void *)buf + 4) = v7 - len;
  int v11 = *((_DWORD *)buf + 4);
  if (v11 == 2)
  {
    *(void *)buf += len;
    unint64_t v14 = v4 - len;
    goto LABEL_23;
  }

  if (v11 == 3 && (v12 = (_BYTE *)*((void *)buf + 3)) != 0LL)
  {
    v13 = (_BYTE *)(*(void *)buf + len);
    *(void *)buf = v13;
    unint64_t v14 = v4 - v3;
    *((void *)buf + 5) = v14;
    int64_t v15 = v13 - v12;
    if (v13 - v12 >= v14)
    {
      memmove(v12, v13, v10);
      uint64_t v16 = *((void *)buf + 3);
      uint64_t v17 = *((void *)buf + 4);
      *(void *)buf = v16;
      *(_BYTE *)(v16 + v17) = 0;
      unint64_t v14 = *((void *)buf + 5) + v15;
LABEL_23:
      *((void *)buf + 5) = v14;
    }
  }

  else
  {
    memmove(*(void **)buf, (const void *)(*(void *)buf + len), v10);
    *(_BYTE *)(*(void *)buf + *((void *)buf + 4)) = 0;
    unint64_t v14 = *((void *)buf + 5);
  }

  LODWORD(v19) = 0x7FFFFFFF;
  if (v14 >= 0x7FFFFFFF) {
    LODWORD(v14) = 0x7FFFFFFF;
  }
  if (*((void *)buf + 4) < 0x7FFFFFFFuLL) {
    uint64_t v19 = *((void *)buf + 4);
  }
  *((_DWORD *)buf + 2) = v19;
  *((_DWORD *)buf + 3) = v14;
  return v3;
}

uint64_t xmlBufGrow(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a2)
    {
      LODWORD(result) = xmlBufGrowInternal(a1, a2);
      if (*(_DWORD *)(a1 + 56)) {
        return 0xFFFFFFFFLL;
      }
      else {
        return result;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

unint64_t xmlBufGrowInternal(uint64_t a1, unint64_t a2)
{
  if (*(_DWORD *)(a1 + 56)) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *(void *)(a1 + 40) = v5;
    uint64_t v4 = v5;
  }

  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  if (v8 <= 0x7FFFFFFE && v7 != v8)
  {
    *(void *)(a1 + 32) = v8;
    uint64_t v7 = v8;
  }

  int v10 = *(_DWORD *)(a1 + 16);
  if (v10 == 2) {
    return 0LL;
  }
  if (v4 - v7 > a2)
  {
    *(_BYTE *)(*(void *)a1 + v7 + a2) = 0;
    return *(void *)(a1 + 40) + ~*(void *)(a1 + 32);
  }

  if (-2 - v7 < a2)
  {
    v12 = "growing buffer past SIZE_MAX";
    goto LABEL_44;
  }

  uint64_t v13 = v7 + a2 + 100;
  if (v7 + a2 >= 0xFFFFFFFFFFFFFF9CLL) {
    uint64_t v13 = -1LL;
  }
  uint64_t v14 = 2 * v4;
  if (v4 < 0) {
    uint64_t v14 = -1LL;
  }
  if (v4 > a2) {
    size_t v15 = v14;
  }
  else {
    size_t v15 = v13;
  }
  if (v10 != 3)
  {
    if (v10 == 5)
    {
      if ((unint64_t)v4 > 0x98967F || a2 + v7 - 9999999 < 0xFFFFFFFFFF676980LL)
      {
        xmlBufMemoryError(a1, (uint64_t)"buffer error: text too long\n");
        return 0LL;
      }

      if (v15 >= 0x989680) {
        size_t v15 = 10000000LL;
      }
    }

LABEL_36:
    uint64_t v19 = (char *)xmlRealloc(*(void **)a1, v15);
    if (v19) {
      goto LABEL_37;
    }
LABEL_43:
    v12 = "growing buffer";
LABEL_44:
    __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)v12);
    unint64_t result = 0LL;
    if (!*(_DWORD *)(a1 + 56))
    {
      unint64_t result = 0LL;
      *(_DWORD *)(a1 + 56) = 2;
    }

    return result;
  }

  uint64_t v16 = *(void **)(a1 + 24);
  if (!v16) {
    goto LABEL_36;
  }
  uint64_t v17 = *(void *)a1 - (void)v16;
  v18 = (char *)xmlRealloc(v16, v17 + v15);
  if (!v18) {
    goto LABEL_43;
  }
  *(void *)(a1 + 24) = v18;
  uint64_t v19 = &v18[v17];
LABEL_37:
  *(void *)a1 = v19;
  *(void *)(a1 + 40) = v15;
  v19[*(void *)(a1 + 32)] = 0;
  *(_BYTE *)(*(void *)a1 + *(void *)(a1 + 32) + a2) = 0;
  LODWORD(v20) = 0x7FFFFFFF;
  unint64_t v22 = *(void *)(a1 + 32);
  unint64_t v21 = *(void *)(a1 + 40);
  if (v21 >= 0x7FFFFFFF) {
    LODWORD(v23) = 0x7FFFFFFF;
  }
  else {
    uint64_t v23 = *(void *)(a1 + 40);
  }
  if (v22 < 0x7FFFFFFF) {
    uint64_t v20 = *(void *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 12) = v23;
  return v21 + ~v22;
}

    uint64_t v1 = *(void *)(v1 + 48);
    if (!v1) {
      return 0LL;
    }
  }

  unint64_t v6 = 0;
  uint64_t v7 = 0LL;
  while (2)
  {
    uint64_t v8 = *(void *)(v5 + 24);
    if (!v8 || *(_DWORD *)(v8 + 8) != 3 || *(void *)(v8 + 48)) {
      goto LABEL_33;
    }
    int v9 = *(const xmlChar **)(v8 + 80);
    if (!xmlStrcasecmp(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http-equiv")
      && !xmlStrcasecmp(v9, (const xmlChar *)"Content-Type"))
    {
      unint64_t v6 = 1;
      break;
    }

    if (v9 && !xmlStrcasecmp(*(const xmlChar **)(v5 + 16), (const xmlChar *)"content")) {
      uint64_t v7 = v9;
    }
    if (!v6)
    {
LABEL_33:
      uint64_t v5 = *(void *)(v5 + 48);
      if (!v5) {
        goto LABEL_36;
      }
      continue;
    }

    break;
  }

  if (!v7) {
    goto LABEL_33;
  }
  int v10 = xmlStrstr(v7, (const xmlChar *)"charset=");
  if (v10
    || (int v10 = xmlStrstr(v7, (const xmlChar *)"Charset=")) != 0LL
    || (int v10 = xmlStrstr(v7, (const xmlChar *)"CHARSET=")) != 0LL)
  {
    doc = v10 + 8;
LABEL_48:
    while (1)
    {
      int v11 = *doc;
      if (v11 != 32 && v11 != 9) {
        break;
      }
      ++doc;
    }
  }

  else
  {
    doc = xmlStrstr(v7, (const xmlChar *)"charset =");
    if (doc
      || (doc = xmlStrstr(v7, (const xmlChar *)"Charset =")) != 0LL
      || (doc = xmlStrstr(v7, (const xmlChar *)"CHARSET =")) != 0LL)
    {
      doc += 9;
      goto LABEL_48;
    }
  }

  return doc;
}

      uint64_t v8 = xmlParseAttValueInternal((uint64_t)ctxt, 0LL, 0LL, 0LL);
      ctxt->instate = XML_PARSER_DTD;
      if (v8)
      {
        *value = v8;
        return v7;
      }

            if (*((_DWORD *)ctxt + 17)) {
              size_t v15 = -1;
            }
            else {
              size_t v15 = 0;
            }
            goto LABEL_39;
          }
        }

        xmlRelaxNGAddValidError((uint64_t)ctxt, 35, 0LL, 0LL, 0);
        uint64_t v8 = -1;
        goto LABEL_25;
      }

      xmlRelaxNGAddValidError((uint64_t)ctxt, 34, 0LL, 0LL, 0);
    }

    size_t v15 = -1;
    goto LABEL_39;
  }

  return result;
}

        children = v6->next;
        if (children) {
          break;
        }
        unint64_t v6 = v6->parent;
      }
    }
  }

  while (1)
  {
    v12 = properties->ns;
    uint64_t v13 = v12 ? v12->href : 0LL;
    uint64_t v14 = *(_DWORD *)(v4 + 16);
    name = properties->name;
    String = xmlNodeListGetString(properties->doc, properties->children, 1);
    if (xmlSchemaValidatorPushAttribute( (_DWORD *)a1,  (const xmlChar *)properties,  v14,  name,  v13,  String) == -1) {
      break;
    }
    properties = properties->next;
    if (!properties) {
      goto LABEL_27;
    }
  }

  unint64_t v22 = "xmlSchemaDocWalk";
  uint64_t v23 = "calling xmlSchemaValidatorPushAttribute()";
LABEL_53:
  xmlSchemaInternalErr2((_DWORD *)a1, (const xmlChar *)v22, (const xmlChar *)v23, 0LL);
LABEL_54:
  uint64_t v20 = 0xFFFFFFFFLL;
LABEL_55:
  xmlSchemaPostRun(a1);
  return v20;
}

        v27 = 1;
      }

      v26 = *(void *)(v16 + 56);
      if (v26 && *(void *)(v15 + 48))
      {
        v27 = (void *)(v16 + 48);
        if (!*(void *)(v16 + 48))
        {
          v30 = *(void *)(v26 + 8);
          unint64_t result = xmlSchemaCloneWildcardNsConstraints(a1, v16, v15);
          if ((_DWORD)result == -1) {
            return result;
          }
LABEL_57:
          v36 = 0LL;
          v37 = v27;
          while (1)
          {
            v37 = (void *)*v37;
            if (!v37) {
              break;
            }
            v38 = v36;
            v36 = v37;
            if (!v37[1])
            {
              if (!v38) {
                v38 = v27;
              }
              *v38 = *v37;
              xmlFree(v37);
              break;
            }
          }

          if (v30)
          {
            v39 = 0LL;
            v40 = v27;
            while (1)
            {
              v40 = (void *)*v40;
              if (!v40) {
                break;
              }
              v41 = v39;
              v39 = v40;
              if (v40[1] == v30)
              {
                if (!v41) {
                  v41 = v27;
                }
                *v41 = *v40;
                xmlFree(v40);
                goto LABEL_82;
              }
            }
          }

          goto LABEL_82;
        }

        v28 = *(void *)(v15 + 56);
      }

      else
      {
        v28 = *(void *)(v15 + 56);
        v27 = (void *)(v16 + 48);
        v29 = *(void **)(v16 + 48);
        if (!v28)
        {
          if (v29)
          {
            v32 = *(void *)(v15 + 48);
            v31 = (void *)(v15 + 48);
            if (v32)
            {
              v33 = 0LL;
LABEL_46:
              while (2)
              {
                v34 = v31;
                while (1)
                {
                  v34 = (void *)*v34;
                  if (!v34) {
                    break;
                  }
                  if (v29[1] == v34[1])
                  {
                    int v9 = 1;
                    v33 = v29;
                    v29 = (void *)*v29;
                    if (v29) {
                      goto LABEL_46;
                    }
                    goto LABEL_83;
                  }
                }

                v35 = (void *)*v29;
                if (v33)
                {
                  *v33 = v35;
                  v35 = (void *)*v29;
                }

                else
                {
                  *v27 = v35;
                }

                xmlFree(v29);
                int v9 = 1;
                v29 = v35;
                if (v35) {
                  continue;
                }
                goto LABEL_83;
              }
            }
          }

          goto LABEL_82;
        }

        if (!v29)
        {
          if (v26)
          {
            v42 = *(void *)(v26 + 8);
            v43 = *(void *)(v28 + 8);
            if (v42) {
              v44 = v42 == v43;
            }
            else {
              v44 = 1;
            }
            if (v44 || v43 == 0)
            {
              int v9 = 1;
              if (!v42 && v43) {
                *(void *)(v26 + 8) = v43;
              }
              goto LABEL_83;
            }

            xmlSchemaPErr( a1,  *(void *)(v16 + 24),  1793,  "The intersection of the wildcard is not expressible.\n",  0LL,  0LL);
          }

          goto LABEL_82;
        }
      }

      v30 = *(void *)(v28 + 8);
      goto LABEL_57;
    }

    if (*(_DWORD *)v12 == 2001) {
      break;
    }
LABEL_102:
    ++v11;
    int v10 = *(_DWORD *)(a4 + 8);
    if (v11 >= v10) {
      goto LABEL_103;
    }
  }

  if (!a5)
  {
    xmlSchemaInternalErr2( (_DWORD *)v8,  (const xmlChar *)"xmlSchemaExpandAttributeGroupRefs",  (const xmlChar *)"unexpected attr prohibition found",  0LL);
    return 0xFFFFFFFFLL;
  }

  unint64_t result = xmlSchemaItemListRemove(a4, v11);
  if ((_DWORD)result != -1)
  {
    --v11;
    xmlSchemaItemListAddSize(a5, 2, v12);
    goto LABEL_102;
  }

  return result;
}

  uint64_t v4 = 0LL;
LABEL_37:
  xmlFreeStreamCtxt(v22);
  return v4;
}

              xmlXPtrLocationSetAdd(v10, v15);
              if (++v12 >= *user) {
                goto LABEL_60;
              }
            }
          }

          xmlXPathFreeObject(v7);
        }

        ctxt = v2;
        v36 = 15;
        goto LABEL_63;
      }

      v36 = 23;
    }

    else
    {
      v36 = 12;
    }

xmlChar *__cdecl xmlBufContent(xmlChar *buf)
{
  if (buf)
  {
    if (*((_DWORD *)buf + 14)) {
      return 0LL;
    }
    else {
      return *(xmlChar **)buf;
    }
  }

  return buf;
}

xmlChar *__cdecl xmlBufEnd(xmlChar *buf)
{
  if (buf)
  {
    if (*((_DWORD *)buf + 14))
    {
      return 0LL;
    }

    else
    {
      uint64_t v1 = *((unsigned int *)buf + 3);
      uint64_t v3 = *((void *)buf + 4);
      uint64_t v4 = *((unsigned int *)buf + 2);
      if (v4 <= 0x7FFFFFFE && v3 != v4)
      {
        *((void *)buf + 4) = v4;
        uint64_t v3 = v4;
      }

      return (xmlChar *)(*(void *)buf + v3);
    }
  }

  return buf;
}

uint64_t xmlBufAddLen(uint64x2_t *a1, unint64_t a2)
{
  if (!a1 || a1[3].i32[2]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a1[2].i64[1];
  uint64_t v3 = a1->u32[3];
  if (v3 <= 0x7FFFFFFE && v2 != v3)
  {
    a1[2].i64[1] = v3;
    uint64_t v2 = v3;
  }

  uint64_t v5 = a1[2].i64[0];
  uint64_t v6 = a1->u32[2];
  if (v6 <= 0x7FFFFFFE && v5 != v6)
  {
    a1[2].i64[0] = v6;
    uint64_t v5 = v6;
  }

  if (v2 - v5 <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = v5 + a2;
  a1[2].i64[0] = v9;
  *(_BYTE *)(a1->i64[0] + v9) = 0;
  int8x16_t v10 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
  a1->u64[1] = (unint64_t)vmovn_s64((int64x2_t)vbslq_s8( (int8x16_t)vcgtq_u64((uint64x2_t)v10, a1[2]),  (int8x16_t)a1[2],  v10));
  return v8;
}

uint64_t xmlBufLength(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 56)) {
    return 0LL;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 <= 0x7FFFFFFE && v1 != v5)
  {
    *(void *)(a1 + 32) = v5;
    return v5;
  }

  return v1;
}

size_t xmlBufUse(const xmlBufPtr buf)
{
  if (!buf || *((_DWORD *)buf + 14)) {
    return 0LL;
  }
  uint64_t v3 = *((unsigned int *)buf + 3);
  size_t v1 = *((void *)buf + 4);
  size_t v5 = *((unsigned int *)buf + 2);
  if (v5 <= 0x7FFFFFFE && v1 != v5)
  {
    *((void *)buf + 4) = v5;
    return v5;
  }

  return v1;
}

unint64_t xmlBufAvail(unint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 56))
    {
      return 0LL;
    }

    else
    {
      unint64_t v1 = *(void *)(result + 40);
      unint64_t v2 = *(unsigned int *)(result + 12);
      if (v2 <= 0x7FFFFFFE && v1 != v2)
      {
        *(void *)(result + 40) = v2;
        unint64_t v1 = v2;
      }

      unint64_t v4 = *(void *)(result + 32);
      unint64_t v5 = *(unsigned int *)(result + 8);
      if (v5 <= 0x7FFFFFFE && v4 != v5)
      {
        *(void *)(result + 32) = v5;
        unint64_t v4 = v5;
      }

      if (v1 <= v4) {
        return 0LL;
      }
      else {
        return v1 + ~v4;
      }
    }
  }

  return result;
}

uint64_t xmlBufIsEmpty(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 56)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 12);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 <= 0x7FFFFFFE && v4 != v5)
  {
    *(void *)(a1 + 32) = v5;
    uint64_t v4 = v5;
  }

  return v4 == 0;
}

uint64_t xmlBufResize(uint64_t result, size_t __size)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)(result + 56)) {
      return 0LL;
    }
    size_t v3 = *(void *)(result + 40);
    size_t v4 = *(unsigned int *)(result + 12);
    if (v4 <= 0x7FFFFFFE && v3 != v4)
    {
      *(void *)(result + 40) = v4;
      size_t v3 = v4;
    }

    size_t v6 = *(void *)(result + 32);
    size_t v7 = *(unsigned int *)(result + 8);
    if (v7 <= 0x7FFFFFFE && v6 != v7)
    {
      *(void *)(result + 32) = v7;
      size_t v6 = v7;
    }

    int v9 = *(_DWORD *)(result + 16);
    if (v9 == 2) {
      return 0LL;
    }
    if (__size >= 0x989680 && v9 == 5)
    {
      int8x16_t v10 = "buffer error: text too long\n";
      goto LABEL_17;
    }

    if (v3 > __size) {
      return 1LL;
    }
    switch(v9)
    {
      case 0:
      case 3:
        uint64_t v11 = __size + 10;
        if (__size >= 0xFFFFFFFFFFFFFFF6LL) {
          uint64_t v11 = -1LL;
        }
        if (v3) {
          size_t v12 = v3;
        }
        else {
          size_t v12 = v11;
        }
        while (1)
        {
          if (v12 >= __size) {
            goto LABEL_39;
          }
          if ((v12 & 0x8000000000000000LL) != 0) {
            goto LABEL_56;
          }
          v12 *= 2LL;
        }

      case 1:
        if (__size >= 0xFFFFFFFFFFFFFFF6LL) {
          size_t v12 = -1LL;
        }
        else {
          size_t v12 = __size + 10;
        }
        goto LABEL_48;
      case 4:
        if (v6 >= 0x1000)
        {
          size_t v12 = v3;
          if (v3 < __size)
          {
            size_t v12 = v3;
            do
            {
              if ((v12 & 0x8000000000000000LL) != 0)
              {
LABEL_56:
                xmlBufMemoryError(result, (uint64_t)"growing buffer");
                return 0LL;
              }

              v12 *= 2LL;
            }

            while (v12 < __size);
LABEL_39:
            if (v9 == 3)
            {
              uint64_t v13 = *(void **)(result + 24);
              if (v13)
              {
                size_t v14 = *(void *)v2 - (void)v13;
                if (v14 > v12)
                {
                  memmove(v13, *(const void **)v2, v6);
                  size_t v15 = *(char **)(v2 + 24);
                  goto LABEL_59;
                }

                v18 = (char *)xmlRealloc(v13, v14 + v12);
                if (v18)
                {
                  *(void *)(v2 + 24) = v18;
                  size_t v15 = &v18[v14];
                  goto LABEL_59;
                }

                goto LABEL_61;
              }
            }
          }
        }

        else
        {
          size_t v12 = __size;
        }

LABEL_48:
        if (!*(void *)v2)
        {
          uint64_t v16 = (char *)xmlMallocAtomic(v12);
LABEL_52:
          size_t v15 = v16;
          if (!v16) {
            goto LABEL_61;
          }
LABEL_59:
          *(void *)uint64_t v2 = v15;
          *(void *)(v2 + 40) = v12;
          v15[*(void *)(v2 + 32)] = 0;
          int8x16_t v19 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
          *(int32x2_t *)(v2 + 8) = vmovn_s64((int64x2_t)vbslq_s8( (int8x16_t)vcgtq_u64( (uint64x2_t)v19,  *(uint64x2_t *)(v2 + 32)),  *(int8x16_t *)(v2 + 32),  v19));
          return 1LL;
        }

        if (v3 - v6 <= 0x63)
        {
          uint64_t v16 = (char *)xmlRealloc(*(void **)v2, v12);
          goto LABEL_52;
        }

        uint64_t v17 = (char *)xmlMallocAtomic(v12);
        if (v17)
        {
          size_t v15 = v17;
          memcpy(v17, *(const void **)v2, *(void *)(v2 + 32));
          xmlFree(*(void **)v2);
          goto LABEL_59;
        }

  uint64_t v20 = v17 > 0x10;
  unint64_t v21 = (1 << v17) & 0x1E206;
  if (v20 || v21 == 0)
  {
    v29 = *(void *)(a2 + 80);
    if (v29)
    {
      if (*(_DWORD *)(v3 + 144))
      {
        unint64_t result = xmlCheckUTF8(*(const unsigned __int8 **)(a2 + 80));
        if (!(_DWORD)result) {
          unint64_t result = (uint64_t)xmlDebugErr3(v3, 5032, "String is not UTF-8 %s", v29);
        }
      }
    }
  }

  switch(*(_DWORD *)(a2 + 8))
  {
    case 1:
    case 2:
    case 7:
      return xmlCtxtCheckName(v3, *(xmlChar **)(a2 + 16));
    case 3:
      uint64_t v23 = *(const xmlChar **)(a2 + 16);
      if (v23 == "text" || v23 == "textnoenc") {
        return result;
      }
      v24 = *(xmlDict **)(v3 + 136);
      if (!v24) {
        goto LABEL_59;
      }
      unint64_t result = (uint64_t)xmlDictLookup(v24, (const xmlChar *)"nbktext", 7);
      if (v23 != (const xmlChar *)result)
      {
        uint64_t v23 = *(const xmlChar **)(a2 + 16);
LABEL_59:
        v25 = "Text node has wrong name '%s'";
        v26 = v3;
        v27 = 5036;
        LOBYTE(v28) = (_BYTE)v23;
LABEL_64:
        unint64_t result = (uint64_t)xmlDebugErr3(v26, v27, v25, (char)v28);
      }

      break;
    case 4:
      v28 = *(const xmlChar **)(a2 + 16);
      if (!v28) {
        return result;
      }
      v25 = "CData section has non NULL name '%s'";
      v26 = v3;
      v27 = 5037;
      goto LABEL_64;
    case 8:
      v28 = *(const xmlChar **)(a2 + 16);
      if (v28 == "comment") {
        return result;
      }
      v25 = "Comment node has wrong name '%s'";
      v26 = v3;
      v27 = 5036;
      goto LABEL_64;
    default:
      return result;
  }

  return result;
}

  uint64_t v16 = 0LL;
LABEL_49:
  uint64_t v17 = 0LL;
LABEL_97:
  if (ctxt->instate == XML_PARSER_EOF) {
    goto LABEL_116;
  }
  xmlSkipBlankChars(ctxt);
  v30 = ctxt->input;
  if (*v30->cur == 62)
  {
    if (id != v30->id) {
      xmlFatalErrMsg(ctxt, 90);
    }
    xmlNextChar(ctxt);
  }

  else
  {
    xmlFatalErrMsgStr(ctxt, 37, (uint64_t)"xmlParseEntityDecl: entity %s not terminated\n", (uint64_t)v9);
    xmlHaltParser(ctxt);
  }

  if (!v36) {
    goto LABEL_116;
  }
  sax = ctxt->sax;
  if (v7 == 37)
  {
    if (!sax) {
      goto LABEL_116;
    }
    getParameterEntity = (uint64_t (*)(void *, const xmlChar *))sax->getParameterEntity;
    if (!getParameterEntity) {
      goto LABEL_116;
    }
    Entity = (xmlEntityPtr)getParameterEntity(ctxt->userData, v9);
    goto LABEL_113;
  }

  if (sax)
  {
    getEntity = (uint64_t (*)(void *, const xmlChar *))sax->getEntity;
    if (getEntity)
    {
      Entity = (xmlEntityPtr)getEntity(ctxt->userData, v9);
      if (Entity)
      {
LABEL_114:
        if (!Entity->orig)
        {
          Entity->orig = v36;
          v36 = 0LL;
        }

        goto LABEL_116;
      }
    }
  }

  if (ctxt->userData == ctxt)
  {
    Entity = xmlSAX2GetEntity(ctxt, v9);
LABEL_113:
    if (Entity) {
      goto LABEL_114;
    }
  }

    uint64_t v16 = ctxt;
    uint64_t v17 = 54;
    goto LABEL_49;
  }

  if (v9 == 65)
  {
    if (v8[1] != 78 || v8[2] != 89) {
      goto LABEL_48;
    }
    int8x16_t v19 = v6;
    v7->cur = v8 + 3;
    v7->col += 3;
    if (!v8[3]) {
      xmlParserInputGrow(v7, 250);
    }
    int8x16_t v10 = 2LL;
  }

  else
  {
    if (v9 != 69 || v8[1] != 77 || v8[2] != 80 || v8[3] != 84 || v8[4] != 89) {
      goto LABEL_48;
    }
    int8x16_t v19 = v6;
    v7->cur = v8 + 5;
    v7->col += 5;
    if (!v8[5]) {
      xmlParserInputGrow(v7, 250);
    }
    int8x16_t v10 = 1LL;
  }

            xmlFatalErr(ctxt, 34, 0LL);
            return v8;
          }
        }

        else if (v7 == 110 && v6[1] == 111)
        {
          v5->cur = v6 + 2;
          v5->col += 2;
          if (!v6[2]) {
            xmlParserInputGrow(v5, 250);
          }
          uint64_t v8 = 0;
          goto LABEL_39;
        }

        xmlFatalErr(ctxt, 78, 0LL);
        uint64_t v8 = -2;
        goto LABEL_39;
      }

      int v9 = ctxt;
      int8x16_t v10 = 33;
      goto LABEL_30;
    }

    xmlNextChar(ctxt);
    uint64_t v11 = ctxt->input;
    size_t v12 = v11->cur;
    uint64_t v13 = *v12;
    if (v13 == 121)
    {
      if (v12[1] == 101 && v12[2] == 115)
      {
        v11->cur = v12 + 3;
        v11->col += 3;
        if (!v12[3]) {
          xmlParserInputGrow(v11, 250);
        }
        uint64_t v8 = 1;
LABEL_47:
        if (*ctxt->input->cur == 34) {
          goto LABEL_40;
        }
        goto LABEL_48;
      }
    }

    else if (v13 == 110 && v12[1] == 111)
    {
      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2]) {
        xmlParserInputGrow(v11, 250);
      }
      uint64_t v8 = 0;
      goto LABEL_47;
    }

    xmlFatalErr(ctxt, 78, 0LL);
    uint64_t v8 = -2;
    goto LABEL_47;
  }

  int v9 = ctxt;
  int8x16_t v10 = 75;
LABEL_30:
  xmlFatalErr(v9, v10, 0LL);
  return -2;
}

        size_t v7 = 0;
        size_t v6 = 0;
        int v9 = 0LL;
        *((_DWORD *)reader + 6) = 1;
        *((_DWORD *)reader + 32) = 0;
        *(_DWORD *)(v15 + 688) = 5;
        goto LABEL_125;
      }
    }

    v18 = *(void *)(v15 + 16);
    if (v18)
    {
      int8x16_t v19 = *(void *)(v18 + 24);
      *((void *)reader + 14) = v19;
    }

    else
    {
      int8x16_t v19 = *((void *)reader + 14);
    }

    if (!v19) {
      *((void *)reader + 14) = **(void **)(v15 + 96);
    }
    goto LABEL_48;
  }

  size_t v6 = *((_DWORD *)reader + 6);
  size_t v7 = *(_DWORD *)(v5 + 88);
  uint64_t v8 = *((void *)reader + 14);
  int v9 = v8;
  if (!v8)
  {
LABEL_164:
    if (*(_DWORD *)reader == 3) {
      return 0;
    }
    else {
      return -1;
    }
  }

  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v20 = *(void *)(v8 + 48);
        if (v20) {
          break;
        }
        unint64_t v21 = *((void *)reader + 4);
        if (*(_DWORD *)(v21 + 88) != v7) {
          goto LABEL_69;
        }
        if (v6 != 4)
        {
          unint64_t v22 = *(void *)(v8 + 24);
          if (v22)
          {
            uint64_t v23 = *(_DWORD *)(v8 + 8);
            if (v23 != 5
              && (*(_DWORD *)(v22 + 8) != 3 || *(void *)(v22 + 48))
              && (v23 > 0xE || ((1 << v23) & 0x6200) == 0))
            {
LABEL_88:
              v35 = *(_DWORD *)(v8 + 8);
              v34 = 1;
              v30 = v35 > 0x13;
              v36 = (1 << v35) & 0x84020;
              if (v30 || v36 == 0)
              {
                *((void *)reader + 14) = v22;
                ++*((_DWORD *)reader + 32);
                *((_DWORD *)reader + 6) = 1;
                goto LABEL_125;
              }

              goto LABEL_92;
            }
          }
        }

        v24 = *(void *)(v21 + 80);
        v25 = !v24 || v24 == v8;
        if (!v25 && v24 != *(void *)(v8 + 40) || *(_DWORD *)(v21 + 272) == -1)
        {
LABEL_69:
          if (v6 == 4) {
            goto LABEL_70;
          }
          goto LABEL_87;
        }

        uint64_t v8 = *((void *)reader + 14);
        if (!v8) {
          goto LABEL_67;
        }
      }

      if (v6 == 4) {
        goto LABEL_100;
      }
LABEL_87:
      v34 = 0;
      unint64_t v22 = *(void *)(v8 + 24);
      if (v22) {
        goto LABEL_88;
      }
LABEL_92:
      if (!v20)
      {
        if (v6 == 1)
        {
          v40 = *(_DWORD *)(v8 + 8) == 1 ? v34 : 1;
          if ((v40 & 1) == 0 && (*(_WORD *)(v8 + 114) & 1) == 0)
          {
LABEL_113:
            *((_DWORD *)reader + 6) = 2;
            size_t v6 = 1;
            goto LABEL_125;
          }
        }

                NthChild = xmlXPtrAdvanceNode(NthChild, 0LL);
                if (!NthChild) {
                  return v3;
                }
                goto LABEL_30;
              }

              if (v16->type - 3 <= 1)
              {
                content = v16->content;
                if (content) {
                  v26 = xmlNewText(&content[v24]);
                }
                else {
                  v26 = xmlNewTextLen(0LL, 0);
                }
                size_t v3 = v26;
                goto LABEL_45;
              }

              if (index < 2)
              {
                v26 = xmlCopyNode(v16, 1);
                size_t v3 = v26;
                unint64_t v22 = 0LL;
LABEL_45:
                uint64_t v23 = v26;
                goto LABEL_46;
              }

              unint64_t v22 = xmlCopyNode(v16, 0);
              NthChild = xmlXPtrGetNthChild((uint64_t)v16, index - 1);
              index = 0;
              size_t v3 = v22;
              if (!NthChild) {
                return v3;
              }
            }

            if (*(_DWORD *)(v21 + 8) == 3)
            {
              v43 = *(void *)(v21 + 80);
              if (v43)
              {
                v44 = index > 1;
                v45 = v21 == (void)v16;
                v46 = !v45 || !v44;
                if (v45 && v44) {
                  v47 = (index - 1);
                }
                else {
                  v47 = 0LL;
                }
                v48 = (const xmlChar *)(v43 + v47);
                if (v46) {
                  v49 = 0;
                }
                else {
                  v49 = index - 1;
                }
                v50 = index2 - v49;
              }

              else
              {
                v48 = 0LL;
                v50 = 0;
              }

              v51 = xmlNewTextLen(v48, v50);
              if (!v3) {
                return v51;
              }
              if (v23) {
                xmlAddNextSibling(v23, v51);
              }
              else {
                xmlAddChild(v22, v51);
              }
              return v3;
            }

            v32 = xmlCopyNode((xmlNodePtr)v21, 0);
            v18 = v32;
            if (v3)
            {
              if (v23) {
                Sibling = xmlAddNextSibling(v23, v32);
              }
              else {
                Sibling = xmlAddChild(v22, v32);
              }
              v18 = Sibling;
            }

            else
            {
              size_t v3 = v32;
            }

            if (index2 >= 2)
            {
              user2 = xmlXPtrGetNthChild(v21, index2 - 1);
              index2 = 0;
            }

            else
            {
              user2 = v21;
            }

            if ((xmlNode *)v21 == v16 && index >= 2)
            {
              NthChild = xmlXPtrGetNthChild((uint64_t)v16, index - 1);
              index = 0;
            }

            else
            {
              NthChild = *(void *)(v21 + 24);
            }

            if (!NthChild) {
              return v3;
            }
          }
        }

        user = (xmlNode *)obj->user;
        size_t v14 = 1;
        return xmlCopyNode(user, v14);
      case XPATH_LOCATIONSET:
        v34 = (int *)obj->user;
        if (!v34 || *v34 < 1) {
          return 0LL;
        }
        v35 = 0LL;
        v36 = 0LL;
        size_t v3 = 0LL;
        break;
      default:
        return v3;
    }

    while (1)
    {
      v37 = xmlXPtrBuildNodeList(*(xmlXPathObjectPtr *)(*((void *)v34 + 1) + 8 * v35));
      v38 = v37;
      if (v36) {
        break;
      }
      size_t v3 = v37;
      if (v37) {
        goto LABEL_82;
      }
      v36 = 0LL;
LABEL_83:
      if (++v35 >= *v34) {
        return v3;
      }
    }

    xmlAddNextSibling(v36, v37);
    v38 = v36;
    do
    {
LABEL_82:
      v36 = v38;
      v38 = v38->next;
    }

    while (v38);
    goto LABEL_83;
  }

  return v3;
}

LABEL_61:
        int8x16_t v10 = "growing buffer";
LABEL_17:
        __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)v10);
        if (!*(_DWORD *)(v2 + 56))
        {
          unint64_t result = 0LL;
          *(_DWORD *)(v2 + 56) = 2;
          return result;
        }

        return 0LL;
      default:
        if (__size >= 0xFFFFFFFFFFFFFFF6LL) {
          size_t v12 = -1LL;
        }
        else {
          size_t v12 = __size + 10;
        }
        goto LABEL_39;
    }
  }

  return result;
}

      uint64_t v2 = next;
      if (!next)
      {
        if (!v29 || !context) {
          return;
        }
        --v29;
        context->prefix = 0LL;
        uint64_t v2 = context;
      }
    }

    if (v5)
    {
      if (xmlDictOwns(v5, v20))
      {
LABEL_41:
        unint64_t v21 = v2->type;
        goto LABEL_42;
      }

      uint64_t v20 = (xmlChar *)v2[1]._private;
    }

    xmlFree(v20);
    goto LABEL_41;
  }

  xmlFreeNsList((xmlNsPtr)cur);
}

  v70 = a4;
  v25 = 0LL;
  while (v13->ns)
  {
    v26 = xmlStrEqual(v13->name, (const xmlChar *)"minInclusive");
    v27 = v13->ns;
    if (v26)
    {
      if (xmlStrEqual(v27->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v27 = v13->ns;
    }

    if (!v27) {
      break;
    }
    v28 = xmlStrEqual(v13->name, (const xmlChar *)"minExclusive");
    v29 = v13->ns;
    if (v28)
    {
      if (xmlStrEqual(v29->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v29 = v13->ns;
    }

    if (!v29) {
      break;
    }
    v30 = xmlStrEqual(v13->name, (const xmlChar *)"maxInclusive");
    v31 = v13->ns;
    if (v30)
    {
      if (xmlStrEqual(v31->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v31 = v13->ns;
    }

    if (!v31) {
      break;
    }
    v32 = xmlStrEqual(v13->name, (const xmlChar *)"maxExclusive");
    v33 = v13->ns;
    if (v32)
    {
      if (xmlStrEqual(v33->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v33 = v13->ns;
    }

    if (!v33) {
      break;
    }
    v34 = xmlStrEqual(v13->name, (const xmlChar *)"totalDigits");
    v35 = v13->ns;
    if (v34)
    {
      if (xmlStrEqual(v35->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v35 = v13->ns;
    }

    if (!v35) {
      break;
    }
    v36 = xmlStrEqual(v13->name, (const xmlChar *)"fractionDigits");
    v37 = v13->ns;
    if (v36)
    {
      if (xmlStrEqual(v37->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v37 = v13->ns;
    }

    if (!v37) {
      break;
    }
    v38 = xmlStrEqual(v13->name, (const xmlChar *)"pattern");
    v39 = v13->ns;
    if (v38)
    {
      if (xmlStrEqual(v39->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v39 = v13->ns;
    }

    if (!v39) {
      break;
    }
    v40 = xmlStrEqual(v13->name, (const xmlChar *)"enumeration");
    v41 = v13->ns;
    if (v40)
    {
      if (xmlStrEqual(v41->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v41 = v13->ns;
    }

    if (!v41) {
      break;
    }
    v42 = xmlStrEqual(v13->name, (const xmlChar *)"whiteSpace");
    v43 = v13->ns;
    if (v42)
    {
      if (xmlStrEqual(v43->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v43 = v13->ns;
    }

    if (!v43) {
      break;
    }
    v44 = xmlStrEqual(v13->name, (const xmlChar *)"length");
    v45 = v13->ns;
    if (v44)
    {
      if (xmlStrEqual(v45->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v45 = v13->ns;
    }

    if (!v45) {
      break;
    }
    v46 = xmlStrEqual(v13->name, (const xmlChar *)"maxLength");
    v47 = v13->ns;
    if (v46)
    {
      if (xmlStrEqual(v47->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_109;
      }
      v47 = v13->ns;
    }

    if (!v47
      || !xmlStrEqual(v13->name, (const xmlChar *)"minLength")
      || !xmlStrEqual(v13->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      break;
    }

uint64_t xmlBufAdd(uint64x2_t *a1, const xmlChar *__src, size_t __len)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && __src && !a1[3].i32[2])
  {
    uint64_t v6 = a1->u32[3];
    uint64_t v8 = a1->u32[2];
    if ((int)__len >= -1 && a1[1].i32[0] != 2)
    {
      if (!(_DWORD)__len) {
        return 0LL;
      }
      if ((__len & 0x80000000) != 0)
      {
        LODWORD(__len) = xmlStrlen(__src);
        if ((__len & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
      }

      if (!(_DWORD)__len) {
        return 0LL;
      }
      size_t v9 = __len;
      uint64_t v10 = a1[2].i64[0];
      if (a1[2].i64[1] - v10 > (unint64_t)__len)
      {
LABEL_20:
        memmove((void *)(a1->i64[0] + v10), __src, v9);
        uint64_t result = 0LL;
        size_t v11 = a1[2].i64[0] + v9;
        a1[2].i64[0] = v11;
        *(_BYTE *)(a1->i64[0] + v11) = 0;
        int8x16_t v12 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFuLL);
        a1->u64[1] = (unint64_t)vmovn_s64((int64x2_t)vbslq_s8( (int8x16_t)vcgtq_u64((uint64x2_t)v12, a1[2]),  (int8x16_t)a1[2],  v12));
        return result;
      }

      if (__len >= (unint64_t)~v10)
      {
        size_t v14 = "growing buffer past SIZE_MAX";
        goto LABEL_27;
      }

      size_t v13 = __len + v10 + 1;
      if (v13 >= 0x989680 && a1[1].i32[0] == 5)
      {
        size_t v14 = "buffer error: text too long\n";
LABEL_27:
        xmlBufMemoryError((uint64_t)a1, (uint64_t)v14);
        return 0xFFFFFFFFLL;
      }

      if (xmlBufResize((uint64_t)a1, v13))
      {
        uint64_t v10 = a1[2].i64[0];
        goto LABEL_20;
      }

      xmlBufMemoryError((uint64_t)a1, (uint64_t)"growing buffer");
      return 2LL;
    }
  }

  return result;
}

uint64_t xmlBufCat(uint64x2_t *a1, const xmlChar *a2)
{
  if (!a1 || a1[3].i32[2]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a1->u32[3];
  uint64_t v5 = a1->u32[2];
  if (!a2 || a1[1].i32[0] == 2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return xmlBufAdd(a1, a2, 0xFFFFFFFFuLL);
  }
}

uint64_t xmlBufWriteQuotedString(uint64x2_t *a1, xmlChar *str)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a1[3].i32[2]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = str;
  uint64_t v4 = a1->u32[3];
  uint64_t v6 = a1->u32[2];
  if (a1[1].i32[0] == 2) {
    return 0xFFFFFFFFLL;
  }
  if (xmlStrchr(str, 0x22u))
  {
    if (xmlStrchr(v3, 0x27u))
    {
      xmlBufCat(a1, (const xmlChar *)"");
LABEL_19:
      for (size_t i = 0LL; v3[i]; ++i)
      {
        if (v3[i] == 34)
        {
          if (i) {
            xmlBufAdd(a1, v3, i);
          }
          xmlBufAdd(a1, (const xmlChar *)"&quot;", 6uLL);
          v3 += i + 1;
          goto LABEL_19;
        }
      }

      if (i) {
        xmlBufAdd(a1, v3, i);
      }
      uint64_t v10 = "";
      goto LABEL_32;
    }

    uint64_t v10 = "'";
  }

  else
  {
    uint64_t v10 = "";
  }

  xmlBufCat(a1, (const xmlChar *)v10);
  xmlBufCat(a1, v3);
LABEL_32:
  xmlBufCat(a1, (const xmlChar *)v10);
  return 0LL;
}

uint32x2_t *xmlBufFromBuffer(uint32x2_t *result)
{
  if (result)
  {
    unint64_t v1 = result;
    uint64_t result = (uint32x2_t *)xmlMalloc(0x40uLL);
    if (result)
    {
      uint32x2_t v2 = v1[1];
      result[1] = vmin_u32(v2, (uint32x2_t)0x8000000080000000LL);
      result[2].i32[0] = v1[2].i32[0];
      *uint64_t result = *v1;
      result[7].i32[0] = 0;
      result[5] = (uint32x2_t)v2.u32[1];
      result[6] = (uint32x2_t)v1;
      result[3] = v1[3];
      result[4] = (uint32x2_t)v2.u32[0];
    }

    else
    {
      __xmlSimpleError(29, 2, 0, 0LL, (uint64_t)"creating buffer");
      return 0LL;
    }
  }

  return result;
}

uint64_t xmlBufBackToBuffer(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 <= 0x7FFFFFFE && v2 != v3)
  {
    *(void *)(a1 + 40) = v3;
    unint64_t v2 = v3;
  }

  unint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6 <= 0x7FFFFFFE && v5 != v6)
  {
    *(void *)(a1 + 32) = v6;
    unint64_t v5 = v6;
  }

  uint64_t v8 = *(void *)(a1 + 48);
  if (*(_DWORD *)(a1 + 56) || !v8)
  {
    xmlBufFree((_DWORD *)a1);
    if (!v8) {
      return v8;
    }
    *(void *)(v8 + 24) = 0LL;
    *(void *)uint64_t v8 = 0LL;
    *(void *)(v8 + 8) = 0LL;
    return 0LL;
  }

  if (v5 >> 31)
  {
    __xmlSimpleError(29, 7000, 0, 0LL, (uint64_t)"Used size too big for xmlBuffer");
    if (!*(_DWORD *)(a1 + 56)) {
      *(_DWORD *)(a1 + 56) = 7000;
    }
    LODWORD(v2) = 0x7FFFFFFF;
    *(_DWORD *)(v8 + 8) = 0x7FFFFFFF;
  }

  else if (v2 >> 31)
  {
    __xmlSimpleError(29, 7000, 0, 0LL, (uint64_t)"Allocated size too big for xmlBuffer");
    if (!*(_DWORD *)(a1 + 56)) {
      *(_DWORD *)(a1 + 56) = 7000;
    }
    *(_DWORD *)(v8 + 8) = *(void *)(a1 + 32);
    LODWORD(v2) = 0x7FFFFFFF;
  }

  else
  {
    *(_DWORD *)(v8 + 8) = v5;
  }

  int v9 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v8 + 12) = v2;
  *(_DWORD *)(v8 + 16) = v9;
  *(void *)uint64_t v8 = *(void *)a1;
  *(void *)(v8 + 24) = *(void *)(a1 + 24);
  xmlFree((void *)a1);
  return v8;
}

uint64_t xmlBufMergeBuffer(uint64x2_t *a1, xmlBufferPtr buf)
{
  if (a1 && !a1[3].i32[2])
  {
    uint64_t v5 = a1->u32[3];
    uint64_t v7 = a1->u32[2];
    if (buf && (content = buf->content) != 0LL && (size_t use = buf->use, (_DWORD)use)) {
      uint64_t v3 = xmlBufAdd(a1, content, use);
    }
    else {
      uint64_t v3 = 0LL;
    }
  }

  else
  {
    uint64_t v3 = 0xFFFFFFFFLL;
  }

  xmlBufferFree(buf);
  return v3;
}

uint64_t xmlBufResetInput(uint64_t *a1, void *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a1 || *((_DWORD *)a1 + 14))
  {
    a2[4] = &byte_181A3ACBA;
    a2[5] = &byte_181A3ACBA;
    a2[3] = &byte_181A3ACBA;
    return 0xFFFFFFFFLL;
  }

  uint64_t v4 = *((unsigned int *)a1 + 3);
  uint64_t v6 = a1[4];
  uint64_t v7 = *((unsigned int *)a1 + 2);
  if (v7 <= 0x7FFFFFFE && v6 != v7)
  {
    a1[4] = v7;
    uint64_t v6 = v7;
  }

  uint64_t v2 = 0LL;
  uint64_t v8 = *a1;
  a2[3] = *a1;
  a2[4] = v8;
  a2[5] = v8 + v6;
  return v2;
}

unint64_t xmlBufGetInputBase(uint64_t a1, uint64_t a2)
{
  unint64_t result = 0LL;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      return 0LL;
    }

    else
    {
      unint64_t v4 = *(void *)(a1 + 40);
      unint64_t v5 = *(unsigned int *)(a1 + 12);
      if (v5 <= 0x7FFFFFFE && v4 != v5)
      {
        *(void *)(a1 + 40) = v5;
        unint64_t v4 = v5;
      }

      uint64_t v7 = *(unsigned int *)(a1 + 8);
      unint64_t result = *(void *)(a2 + 24) - *(void *)a1;
      if (result > v4)
      {
        __xmlSimpleError(29, 7000, 0, 0LL, (uint64_t)"Input reference outside of the buffer");
        unint64_t result = 0LL;
        if (!*(_DWORD *)(a1 + 56))
        {
          unint64_t result = 0LL;
          *(_DWORD *)(a1 + 56) = 7000;
        }
      }
    }
  }

  return result;
}

uint64_t xmlBufSetInputBaseCur(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a1 || *((_DWORD *)a1 + 14))
  {
    a2[4] = &byte_181A3ACBA;
    a2[5] = &byte_181A3ACBA;
    a2[3] = &byte_181A3ACBA;
    return 0xFFFFFFFFLL;
  }

  uint64_t v6 = *((unsigned int *)a1 + 3);
  uint64_t v8 = a1[4];
  uint64_t v9 = *((unsigned int *)a1 + 2);
  if (v9 <= 0x7FFFFFFE && v8 != v9)
  {
    a1[4] = v9;
    uint64_t v8 = v9;
  }

  uint64_t v4 = 0LL;
  uint64_t v10 = *a1;
  uint64_t v11 = *a1 + a3;
  a2[3] = v11;
  a2[4] = v11 + a4;
  a2[5] = v10 + v8;
  return v4;
}

int xmlC14NExecute( xmlDocPtr doc, xmlC14NIsVisibleCallback is_visible_callback, void *user_data, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlOutputBufferPtr buf)
{
  if (!doc || !buf)
  {
    uint64_t v10 = "executing c14n";
LABEL_8:
    xmlC14NErrParam((const xmlChar *)v10);
    return -1;
  }

  if (mode > 2)
  {
    uint64_t v10 = "invalid mode for executing c14n";
    goto LABEL_8;
  }

  if (buf->encoder)
  {
    __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)doc,  0x15u,  1951,  2,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "%s",  (char)"xmlC14NExecute: output buffer encoder != NULL but C14N requires UTF8 output\n");
    return -1;
  }

  size_t v15 = xmlMalloc(0x50uLL);
  if (!v15)
  {
    xmlC14NErrMemory((const xmlChar *)"creating context");
LABEL_19:
    __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)doc,  0x15u,  1950,  2,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "%s",  (char)"xmlC14NExecute: unable to create C14N context\n");
    return -1;
  }

  uint64_t v16 = v15;
  *size_t v15 = 0u;
  v15[1] = 0u;
  v15[3] = 0u;
  v15[4] = 0u;
  v15[2] = 0u;
  *((_DWORD *)v15 + 6) = with_comments;
  *(void *)size_t v15 = doc;
  *((void *)v15 + 1) = is_visible_callback;
  *((void *)v15 + 2) = user_data;
  *((void *)v15 + 4) = buf;
  *((void *)v15 + 5) = 0x100000000LL;
  uint64_t v17 = xmlMalloc(0x20uLL);
  if (!v17)
  {
    xmlC14NErrMemory((const xmlChar *)"creating namespaces stack");
    *((void *)v16 + 6) = 0LL;
    *((_DWORD *)v16 + 18) = 1952;
    __xmlRaiseError( 0LL,  0LL,  0LL,  v16,  (uint64_t)doc,  0x15u,  1952,  2,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "%s",  (char)"xmlC14NNewCtx: xmlC14NVisibleNsStackCreate failed\n");
    xmlC14NFreeCtx(v16);
    goto LABEL_19;
  }

  *uint64_t v17 = 0u;
  v17[1] = 0u;
  *((void *)v16 + 6) = v17;
  *((_DWORD *)v16 + 14) = mode;
  if (mode == 1) {
    *((void *)v16 + 8) = inclusive_ns_prefixes;
  }
  children = doc->children;
  if (children && (xmlC14NProcessNodeList((xmlDocPtr *)v16, (uint64_t)children, (__n128)0LL) & 0x80000000) != 0)
  {
    unint64_t v22 = "processing docs children list";
    goto LABEL_24;
  }

  int v19 = xmlOutputBufferFlush(buf);
  if (v19 < 0)
  {
    unint64_t v22 = "flushing output buffer";
LABEL_24:
    xmlC14NErrInternal((const xmlChar *)v22);
    xmlC14NFreeCtx(v16);
    return -1;
  }

  int v20 = v19;
  xmlC14NFreeCtx(v16);
  return v20;
}

_DWORD *xmlC14NErrParam(const xmlChar *a1)
{
  return __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x15u,  1,  2,  0LL,  0,  a1,  0LL,  0LL,  0,  0,  "Invalid parameter : %s\n",  (char)a1);
}

uint64_t xmlC14NProcessNodeList(xmlDocPtr *a1, uint64_t a2, __n128 a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = a2;
  unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
  while (2)
  {
    uint64_t v6 = (uint64_t (*)(void, void, void))a1[1];
    if (v6) {
      int v7 = v6(a1[2], v3, *(void *)(v3 + 40));
    }
    else {
      int v7 = 1;
    }
    uint64_t result = 0LL;
    switch(*(_DWORD *)(v3 + 8))
    {
      case 1:
        uint64_t v11 = *(uint64_t ***)(v3 + 96);
        if (!v11) {
          goto LABEL_19;
        }
        do
        {
          if (xmlStrlen((const xmlChar *)v11[2]) < 1) {
            goto LABEL_18;
          }
          xmlURIPtr v12 = xmlParseURI((const char *)v11[2]);
          if (!v12)
          {
            xmlC14NErrInternal((const xmlChar *)"parsing namespace uri");
LABEL_255:
            v89 = "checking for relative namespaces";
            goto LABEL_256;
          }

          size_t v13 = v12;
          if (!xmlStrlen((const xmlChar *)v12->scheme))
          {
            __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x15u,  1955,  2,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "Relative namespace UR is invalid here : %s\n",  (char)v13->scheme);
            xmlFreeURI(v13);
            goto LABEL_255;
          }

          xmlFreeURI(v13);
LABEL_18:
          uint64_t v11 = (uint64_t **)*v11;
        }

        while (v11);
LABEL_19:
        xmlDocPtr v14 = a1[6];
        if (v14)
        {
          a3.n128_u64[0] = (unint64_t)v14->_private;
          __n128 v93 = a3;
          xmlElementType type = v14->type;
          if (v7) {
            goto LABEL_21;
          }
LABEL_48:
          int v95 = 0;
        }

        else
        {
          xmlC14NErrParam((const xmlChar *)"saving namespaces stack");
          xmlElementType type = 0;
          __n128 v93 = 0u;
          if (!v7) {
            goto LABEL_48;
          }
LABEL_21:
          int v95 = *((_DWORD *)a1 + 11);
          if (v95) {
            a1[5] = (xmlDocPtr)1;
          }
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], "<");
          uint64_t v16 = *(void *)(v3 + 72);
          if (v16 && xmlStrlen(*(const xmlChar **)(v16 + 24)) >= 1)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(*(void *)(v3 + 72) + 24LL));
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ":");
          }

          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
        }

        int v27 = *(_DWORD *)(v3 + 8);
        xmlElementType v94 = type;
        if (*((_DWORD *)a1 + 14) != 1)
        {
          if (v27 == 1)
          {
            xmlListPtr v39 = xmlListCreate(0LL, (xmlListDataCompare)xmlC14NNsCompare);
            if (v39)
            {
              v29 = v39;
              v40 = v5;
              int v41 = 0;
              uint64_t v42 = v3;
              do
              {
                for (size_t i = *(xmlNs **)(v42 + 96); i; size_t i = i->next)
                {
                  if (xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, i->prefix) == i
                    && !xmlC14NIsXmlNs((uint64_t)i))
                  {
                    v44 = (unsigned int (*)(xmlDocPtr, xmlNs *, uint64_t))a1[1];
                    if (!v44 || v44(a1[2], i, v3))
                    {
                      BOOL v45 = xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)i);
                      if (v7) {
                        xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)i, v3);
                      }
                      if (!v45) {
                        xmlListInsert(v29, i);
                      }
                      if (!xmlStrlen(i->prefix)) {
                        int v41 = 1;
                      }
                    }
                  }
                }

                uint64_t v42 = *(void *)(v42 + 40);
              }

              while (v42);
              unint64_t v5 = v40;
              if (v7)
              {
                if (!v41)
                {
                  xmmword_18C57F8E8 = 0u;
                  unk_18C57F8F8 = 0u;
                  xmlC14NProcessNamespacesAxis_ns_default = 0u;
                  if (!xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)&xmlC14NProcessNamespacesAxis_ns_default))
                  {
                    v46 = &xmlC14NProcessNamespacesAxis_ns_default;
                    goto LABEL_139;
                  }
                }
              }

              goto LABEL_140;
            }

            v92 = "creating namespaces list (c14n)";
            goto LABEL_275;
          }

          v91 = "processing namespaces axis (c14n)";
LABEL_272:
          xmlC14NErrParam((const xmlChar *)v91);
LABEL_276:
          v89 = "processing namespaces axis";
          break;
        }

        if (v27 != 1)
        {
          v91 = "processing namespaces axis (exc c14n)";
          goto LABEL_272;
        }

        xmlListPtr v28 = xmlListCreate(0LL, (xmlListDataCompare)xmlC14NNsCompare);
        if (!v28)
        {
          v92 = "creating namespaces list (exc c14n)";
LABEL_275:
          xmlC14NErrInternal((const xmlChar *)v92);
          goto LABEL_276;
        }

        v29 = v28;
        v30 = (const xmlChar **)a1[8];
        if (v30 && (v31 = *v30) != 0LL)
        {
          int v32 = 0;
          int v33 = 0;
          uint64_t v34 = 8LL;
          do
          {
            if (xmlStrEqual(v31, (const xmlChar *)"#default") || xmlStrEqual(v31, (const xmlChar *)&byte_181A3ACBA))
            {
              v31 = 0LL;
              int v32 = 1;
            }

            xmlNsPtr v35 = xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, v31);
            if (v35)
            {
              v36 = (const xmlChar **)v35;
              if (!xmlC14NIsXmlNs((uint64_t)v35))
              {
                v37 = (unsigned int (*)(xmlDocPtr, const xmlChar **, uint64_t))a1[1];
                if (!v37 || v37(a1[2], v36, v3))
                {
                  BOOL v38 = xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)v36);
                  if (v7) {
                    xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)v36, v3);
                  }
                  if (!v38) {
                    xmlListInsert(v29, v36);
                  }
                  if (!xmlStrlen(v36[3])) {
                    int v33 = 1;
                  }
                }
              }
            }

            v31 = *(const xmlChar **)((char *)&a1[8]->_private + v34);
            v34 += 8LL;
          }

          while (v31);
        }

        else
        {
          int v33 = 0;
          int v32 = 0;
        }

        xmlNsPtr v47 = *(xmlNsPtr *)(v3 + 72);
        if (v47)
        {
          int v48 = 0;
LABEL_101:
          if (!xmlC14NIsXmlNs((uint64_t)v47))
          {
            if (v7)
            {
              v49 = (unsigned int (*)(xmlDocPtr, xmlNsPtr, uint64_t))a1[1];
              if ((!v49 || v49(a1[2], v47, v3))
                && !xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], (uint64_t)v47, (uint64_t)a1))
              {
                xmlListInsert(v29, v47);
              }

              xmlC14NVisibleNsStackAdd((int *)a1[6], (uint64_t)v47, v3);
            }

            if (!xmlStrlen(v47->prefix)) {
              int v33 = 1;
            }
          }
        }

        else
        {
          xmlNsPtr v47 = xmlSearchNs(*(xmlDocPtr *)(v3 + 64), (xmlNodePtr)v3, 0LL);
          int v48 = 1;
          if (v47) {
            goto LABEL_101;
          }
        }

        for (uint64_t j = *(void *)(v3 + 88); j; uint64_t j = *(void *)(j + 48))
        {
          uint64_t v51 = *(void *)(j + 72);
          if (v51)
          {
            if (xmlC14NIsXmlNs(v51)
              || (v53 = (unsigned int (*)(xmlDocPtr, uint64_t, uint64_t))a1[1]) != 0LL && !v53(a1[2], j, v3))
            {
              uint64_t v52 = *(void *)(j + 72);
              if (v52
                && !xmlStrlen(*(const xmlChar **)(v52 + 24))
                && !xmlStrlen(*(const xmlChar **)(*(void *)(j + 72) + 16LL)))
              {
                int v48 = 1;
              }
            }

            else
            {
              int v54 = xmlExcC14NVisibleNsStackFind((unsigned int *)a1[6], *(void *)(j + 72), (uint64_t)a1);
              xmlC14NVisibleNsStackAdd((int *)a1[6], *(void *)(j + 72), v3);
              if (v7 && !v54) {
                xmlListInsert(v29, *(void **)(j + 72));
              }
              if (!xmlStrlen(*(const xmlChar **)(*(void *)(j + 72) + 24LL))) {
                int v33 = 1;
              }
            }
          }
        }

        if (!v7 || !v48 || v33 || v32)
        {
          if (!v7 || v33)
          {
            unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
          }

          else if (v32 {
                 && (xmmword_18C57F948 = 0u,
          }
                     unk_18C57F958 = 0u,
                     xmlExcC14NProcessNamespacesAxis_ns_default_66 = 0u,
                     !xmlC14NVisibleNsStackFind((uint64_t)a1[6], (uint64_t)&xmlExcC14NProcessNamespacesAxis_ns_default_66)))
          {
            v46 = &xmlExcC14NProcessNamespacesAxis_ns_default_66;
            unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
LABEL_139:
            xmlC14NPrintNamespaces((uint64_t)v46, (uint64_t)a1);
          }

          else
          {
            unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
          }
        }

        else
        {
          xmmword_18C57F918 = 0u;
          unk_18C57F928 = 0u;
          xmlExcC14NProcessNamespacesAxis_ns_default = 0u;
          unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
          if (!xmlExcC14NVisibleNsStackFind( (unsigned int *)a1[6],  (uint64_t)&xmlExcC14NProcessNamespacesAxis_ns_default,  (uint64_t)a1))
          {
            v46 = &xmlExcC14NProcessNamespacesAxis_ns_default;
            goto LABEL_139;
          }
        }

LABEL_140:
        xmlListWalk(v29, v5, a1);
        xmlListDelete(v29);
        if (v7)
        {
          v55 = (int *)a1[6];
          if (v55)
          {
            int v56 = *v55;
            v55[1] = v55[2];
            v55[2] = v56;
          }

          else
          {
            xmlC14NErrParam((const xmlChar *)"shifting namespaces stack");
          }
        }

        if (*(_DWORD *)(v3 + 8) != 1)
        {
          xmlC14NErrParam((const xmlChar *)"processing attributes axis");
LABEL_268:
          v89 = "processing attributes axis";
          break;
        }

        xmlListPtr v57 = xmlListCreate(0LL, (xmlListDataCompare)xmlC14NAttrsCompare);
        if (!v57)
        {
          xmlC14NErrInternal((const xmlChar *)"creating attributes list");
          goto LABEL_268;
        }

        v58 = v57;
        int v59 = *((_DWORD *)a1 + 14);
        if (v59 != 2)
        {
          if (v59 == 1)
          {
            for (k = *(void **)(v3 + 88); k; k = (void *)k[6])
            {
              v75 = (unsigned int (*)(void, void, void))a1[1];
              if (!v75 || v75(a1[2], k, v3)) {
                xmlListInsert(v58, k);
              }
            }

            goto LABEL_231;
          }

          if (v59) {
            goto LABEL_167;
          }
          for (m = *(void **)(v3 + 88); m; m = (void *)m[6])
          {
            v61 = (unsigned int (*)(void, void, void))a1[1];
            if (!v61 || v61(a1[2], m, v3)) {
              xmlListInsert(v58, m);
            }
          }

          if (v7)
          {
            uint64_t v62 = *(void *)(v3 + 40);
            if (v62)
            {
              v63 = (unsigned int (*)(void, void, void))a1[1];
              if (v63)
              {
                if (!v63(a1[2], v62, *(void *)(v62 + 40)))
                {
                  uint64_t v64 = *(void *)(v3 + 40);
                  if (v64)
                  {
                    do
                    {
                      for (n = *(void **)(v64 + 88); n; n = (void *)n[6])
                      {
                        uint64_t v66 = n[9];
                      }

                      xmlAttrPtr v67 = 0LL;
                      uint64_t v64 = *(void *)(v64 + 40);
                    }

                    while (v64);
                    goto LABEL_232;
                  }
                }
              }

              goto LABEL_231;
            }

      v43 = "Name";
      v44 = ctxt;
      BOOL v45 = 110;
      goto LABEL_141;
    }

    if (v14 > 255)
    {
      if (!xmlCharInRange(v14, &xmlIsBaseCharGroup)
        && (v15 - 12321) >= 9
        && v15 != 12295
        && (v15 - 19968) >= 0x51A6)
      {
        return 0LL;
      }
    }

    else if ((v14 & 0xFFFFFFDF) - 65 >= 0x1A {
           && (v14 - 192) >= 0x17
    }
           && v14 <= 247
           && (v14 - 216) >= 0x1F
           && v14 != 95
           && v14 != 58)
    {
      return 0LL;
    }

    int v20 = len;
    v24 = ctxt->input;
    v25 = v24->cur;
    v26 = &v25[len];
    if (v26 <= v24->end)
    {
      if (*v25 == 10)
      {
        ++v24->line;
        v24->col = 1;
      }

      else
      {
        ++v24->col;
      }

      v24->cur = v26;
    }

    uint64_t v34 = 0;
    while (1)
    {
      xmlNsPtr v35 = xmlCurrentChar(ctxt, &len);
      v37 = v35;
      if (v35 > 255)
      {
        if (xmlCharInRange(v35, &xmlIsBaseCharGroup)
          || (v37 - 12321) < 9
          || v37 == 12295
          || (v37 - 19968) < 0x51A6
          || xmlCharInRange(v37, &xmlIsDigitGroup))
        {
          goto LABEL_119;
        }
      }

      else if ((v35 - 192) < 0x17 {
             || (v35 & 0xFFFFFFDF) - 65 < 0x1A
      }
             || (v35 - 48) < 0xA
             || v35 > 247
             || (v35 - 216) < 0x1F)
      {
        goto LABEL_119;
      }

      if ((v37 - 45) > 0x32 || ((1LL << (v37 - 45)) & 0x4000000002003LL) == 0)
      {
        if (v37 >= 256)
        {
          if (xmlCharInRange(v37, &xmlIsCombiningGroup)) {
            goto LABEL_119;
          }
          uint64_t v42 = xmlCharInRange(v37, &xmlIsExtenderGroup);
        }

        else
        {
          uint64_t v42 = v37 == 183;
        }

        if (!v42) {
          goto LABEL_139;
        }
      }

LABEL_167:
            xmlAttrPtr v67 = 0LL;
            goto LABEL_232;
          }

      v74 = *(void *)(v7 + 56);
      v75 = *(_BYTE **)(v74 + 32);
      v76 = &v75[len];
      if ((unint64_t)v76 <= *(void *)(v74 + 40))
      {
        if (*v75 == 10)
        {
          ++*(_DWORD *)(v74 + 52);
          *(_DWORD *)(v74 + 56) = 1;
        }

        else
        {
          ++*(_DWORD *)(v74 + 56);
        }

        *(void *)(v74 + 32) = v76;
      }

      goto LABEL_172;
    }

    if (v64 != 38LL) {
      goto LABEL_147;
    }
    if (v68[1] == 35)
    {
      xmlAttrPtr v69 = xmlParseCharRef((xmlParserCtxtPtr)v7);
      LODWORD(v66) = v69;
      if (!v69) {
        goto LABEL_172;
      }
      if (v69 == 38)
      {
        if (!*(_DWORD *)(v7 + 28))
        {
          if (v65 + 10 > v67)
          {
            if (2 * v67 + 10 < v67) {
              goto LABEL_258;
            }
            int v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
            xmlAttrPtr v67 = 2 * v67 + 10;
            if (!v95) {
              goto LABEL_258;
            }
          }

          else
          {
            int v95 = i;
          }

          goto LABEL_220;
        }

        if (v65 + 10 > v67)
        {
          if (2 * v67 + 10 < v67) {
            goto LABEL_258;
          }
          int v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
          xmlAttrPtr v67 = 2 * v67 + 10;
          if (!v95) {
            goto LABEL_258;
          }
        }

        else
        {
          int v95 = i;
        }

        LODWORD(v66) = 0;
        LOBYTE(v85) = 38;
LABEL_218:
        v95[v65++] = v85;
LABEL_221:
        size_t i = v95;
        goto LABEL_172;
      }

      if (v65 + 10 <= v67)
      {
        v77 = i;
      }

      else
      {
        if (2 * v67 + 10 < v67)
        {
          uint64_t v66 = 0LL;
          int v72 = i;
          goto LABEL_246;
        }

        v77 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        xmlAttrPtr v67 = 2 * v67 + 10;
        if (!v77) {
          goto LABEL_258;
        }
      }

      v84 = xmlCopyChar(0, &v77[v65], (int)v66);
      LODWORD(v66) = 0;
      v65 += v84;
      size_t i = v77;
      goto LABEL_172;
    }

    xmlAttrPtr v70 = xmlParseEntityRef((xmlParserCtxtPtr)v7);
    uint64_t v66 = (unsigned __int8 **)v70;
    uint64_t v71 = *(void *)(v7 + 696) + 1LL;
    *(void *)(v7 + 696) = v71;
    if (!v70) {
      goto LABEL_172;
    }
    *(void *)(v7 + 696) = v71 + v70->owner;
    if (v70->etype == XML_INTERNAL_PREDEFINED_ENTITY)
    {
      if (v65 + 10 <= v67)
      {
        int v95 = i;
      }

      else
      {
        if (2 * v67 + 10 < v67) {
          goto LABEL_258;
        }
        int v95 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        xmlAttrPtr v67 = 2 * v67 + 10;
        if (!v95) {
          goto LABEL_258;
        }
      }

      v85 = *v66[10];
      if (*(_DWORD *)(v7 + 28) || v85 != 38)
      {
        LODWORD(v66) = 0;
        goto LABEL_218;
      }

              uint64_t v8 = 0LL;
              int v27 = 1;
              goto LABEL_168;
            }

LABEL_228:
          xmlListWalk(v58, (xmlListWalker)xmlC14NPrintAttrs, a1);
          xmlFreePropList(0LL);
          xmlListDelete(v58);
          goto LABEL_234;
        }

        uint64_t v68 = *(void *)(v3 + 88);
        if (!v68)
        {
          unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
          if (v7)
          {
            xmlAttrPtr v67 = 0LL;
            xmlAttrPtr v69 = 0LL;
            goto LABEL_205;
          }

          goto LABEL_228;
        }

        xmlAttrPtr v69 = 0LL;
        xmlAttrPtr v70 = 0LL;
        xmlAttrPtr v67 = 0LL;
        while (2)
        {
          if (!v7) {
            goto LABEL_190;
          }
          uint64_t v71 = *(void *)(v68 + 72);
          if (!v70 && xmlStrEqual(*(const xmlChar **)(v68 + 16), (const xmlChar *)"lang"))
          {
            xmlAttrPtr v70 = (xmlAttrPtr)v68;
            goto LABEL_193;
          }

          if (v69)
          {
            if (!v67) {
              goto LABEL_184;
            }
LABEL_190:
            v73 = (unsigned int (*)(xmlDocPtr, uint64_t, uint64_t))a1[1];
            if (!v73 || v73(a1[2], v68, v3)) {
              xmlListInsert(v58, (void *)v68);
            }
          }

          else
          {
            int v72 = xmlStrEqual(*(const xmlChar **)(v68 + 16), (const xmlChar *)"space");
            if (v72) {
              xmlAttrPtr v69 = (xmlAttrPtr)v68;
            }
            else {
              xmlAttrPtr v69 = 0LL;
            }
            if (v72 || v67)
            {
              if (!v72)
              {
                xmlAttrPtr v69 = 0LL;
                goto LABEL_190;
              }

              xmlAttrPtr v69 = (xmlAttrPtr)v68;
            }

            else
            {
LABEL_184:
              if (!xmlStrEqual(*(const xmlChar **)(v68 + 16), (const xmlChar *)"base"))
              {
                xmlAttrPtr v67 = 0LL;
                goto LABEL_190;
              }

              xmlAttrPtr v67 = (xmlAttrPtr)v68;
            }
          }

LABEL_193:
          uint64_t v68 = *(void *)(v68 + 48);
          if (v68) {
            continue;
          }
          break;
        }

        unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
        if (!v7) {
          goto LABEL_228;
        }
        if (v70) {
          goto LABEL_206;
        }
LABEL_205:
        xmlAttrPtr v70 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"lang");
        if (v70) {
LABEL_206:
        }
          xmlListInsert(v58, v70);
        if (v69
          || (xmlAttrPtr v69 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"space")) != 0LL)
        {
          xmlListInsert(v58, v69);
        }

        if (v67
          || (xmlAttrPtr v67 = xmlC14NFindHiddenParentAttr((uint64_t)a1, *(const xmlNode **)(v3 + 40), (const xmlChar *)"base")) != 0LL)
        {
          if (v67->parent)
          {
            String = xmlNodeListGetString(*a1, v67->children, 1);
            if (String)
            {
              v77 = String;
              for (isize_t i = v67->parent->parent; ii; isize_t i = ii->parent)
              {
                v79 = (unsigned int (*)(xmlDocPtr, const xmlNode *, _xmlNode *))a1[1];
                if (!v79 || v79(a1[2], ii, ii->parent)) {
                  break;
                }
                xmlAttrPtr v80 = xmlHasNsProp(ii, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
                if (v80)
                {
                  v81 = xmlNodeListGetString(*a1, v80->children, 1);
                  if (!v81)
                  {
                    xmlFree(v77);
                    v88 = "processing xml:base attribute - can't get attr value";
LABEL_250:
                    xmlC14NErrInternal((const xmlChar *)v88);
                    goto LABEL_251;
                  }

                  v82 = v81;
                  int v83 = xmlStrlen(v81);
                  if (v83 >= 2 && v82[v83 - 2] == 46)
                  {
                    v84 = xmlStrcat(v82, (const xmlChar *)"/");
                    if (!v84)
                    {
                      xmlFree(v82);
                      xmlFree(v77);
                      xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't modify uri");
                      xmlAttrPtr v67 = 0LL;
                      unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
                      goto LABEL_232;
                    }
                  }

                  else
                  {
                    v84 = v82;
                  }

                  v85 = xmlBuildURI(v77, v84);
                  xmlFree(v84);
                  xmlFree(v77);
                  v77 = v85;
                  if (!v85)
                  {
                    v88 = "processing xml:base attribute - can't construct uri";
                    goto LABEL_250;
                  }
                }
              }

              if (xmlStrEqual(v77, (const xmlChar *)&byte_181A3ACBA))
              {
                xmlFree(v77);
LABEL_251:
                xmlAttrPtr v67 = 0LL;
                unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
              }

              else
              {
                xmlAttrPtr v67 = xmlNewNsProp(0LL, v67->ns, (const xmlChar *)"base", v77);
                xmlFree(v77);
                unint64_t v5 = (int (__cdecl *)(const void *, const void *))xmlC14NPrintNamespacesWalker;
                if (v67)
                {
                  xmlListInsert(v58, v67);
                  v67->next = 0LL;
                }

                else
                {
                  xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't construct attribute");
                }
              }

              goto LABEL_232;
            }

            xmlC14NErrInternal((const xmlChar *)"processing xml:base attribute - can't get attr value");
          }

          else
          {
            xmlC14NErrParam((const xmlChar *)"processing xml:base attribute");
          }

LABEL_231:
          xmlAttrPtr v67 = 0LL;
        }

LABEL_232:
        xmlListWalk(v58, (xmlListWalker)xmlC14NPrintAttrs, a1);
        xmlFreePropList(v67);
        xmlListDelete(v58);
        if (v7) {
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ">");
        }
LABEL_234:
        if (*(void *)(v3 + 24) && (xmlC14NProcessNodeList(a1) & 0x80000000) != 0)
        {
          v89 = "processing childrens list";
          break;
        }

        if (v7)
        {
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], "</");
          uint64_t v86 = *(void *)(v3 + 72);
          if (v86 && xmlStrlen(*(const xmlChar **)(v86 + 24)) >= 1)
          {
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(*(void *)(v3 + 72) + 24LL));
            xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ":");
          }

          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], ">");
          if (v95)
          {
            *((_DWORD *)a1 + 10) = 2;
            *((_DWORD *)a1 + 11) = v95;
          }
        }

        xmlDocPtr v87 = a1[6];
        if (v87)
        {
          uint64_t result = 0LL;
          a3.n128_u64[1] = v93.n128_u64[1];
          v87->_private = (void *)v93.n128_u64[0];
          v87->xmlElementType type = v94;
        }

        else
        {
          xmlC14NErrParam((const xmlChar *)"restoring namespaces stack");
          uint64_t result = 0LL;
        }

        if (*(_DWORD *)(a1 + 376))
        {
          if (**(_DWORD **)(a1 + 368) == -2) {
            v101 = -1;
          }
          else {
            v101 = **(_DWORD **)(a1 + 368);
          }
        }

        else
        {
          v101 = -1;
        }

        spacePush(a1, v101);
        if (*(_DWORD *)(a1 + 504)) {
          started = xmlParseStartTag2(a1, (const xmlChar **)in, &v158, &v161);
        }
        else {
          started = (void *)xmlParseStartTag((xmlParserCtxtPtr)a1);
        }
        v103 = (uint64_t)started;
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        if (started)
        {
          if (*(_DWORD *)(a1 + 156))
          {
            if (*(_DWORD *)(a1 + 24))
            {
              v104 = *(xmlDoc **)(a1 + 16);
              if (v104)
              {
                v105 = *(_xmlNode **)(a1 + 80);
                if (v105)
                {
                  if (v105 == v104->children) {
                    *(_DWORD *)(a1 + 152) &= xmlValidateRoot((xmlValidCtxtPtr)(a1 + 160), v104);
                  }
                }
              }
            }
          }

          v106 = *(xmlParserInput **)(a1 + 56);
          v107 = v106->cur;
          v108 = *v107;
          if (v108 == 62)
          {
            xmlNextChar((xmlParserCtxtPtr)a1);
          }

          else
          {
            if (v108 == 47 && v107[1] == 62)
            {
              v106->cur = v107 + 2;
              v106->col += 2;
              if (!v107[2]) {
                xmlParserInputGrow(v106, 250);
              }
              v109 = *(void *)a1;
              if (*(_DWORD *)(a1 + 504))
              {
                if (v109)
                {
                  v110 = *(void (**)(void, uint64_t, void, uint64_t))(v109 + 240);
                  if (v110)
                  {
                    if (!*(_DWORD *)(a1 + 332)) {
                      v110(*(void *)(a1 + 8), v103, *(void *)in, v158);
                    }
                  }
                }

                v111 = *(_DWORD *)(a1 + 508) - v49;
                if (v111 >= 1) {
                  nsPop(a1, v111);
                }
              }

              else if (v109)
              {
                v121 = *(void (**)(void, uint64_t))(v109 + 120);
                if (v121)
                {
                  if (!*(_DWORD *)(a1 + 332)) {
                    v121(*(void *)(a1 + 8), v103);
                  }
                }
              }

              if (*(_DWORD *)(a1 + 272) == -1) {
                return;
              }
              v122 = *(_DWORD *)(a1 + 376);
              if (v122 >= 1)
              {
                v123 = v122 - 2;
                v124 = v122 - 1;
                *(_DWORD *)(a1 + 376) = v124;
                v125 = *(void *)(a1 + 384);
                if (!v124) {
                  v123 = 0;
                }
                *(void *)(a1 + 368) = v125 + 4LL * v123;
                *(_DWORD *)(v125 + 4LL * v124) = -1;
              }

              if (*(_DWORD *)(a1 + 296)) {
                unint64_t v5 = 7;
              }
              else {
                unint64_t v5 = 14;
              }
LABEL_271:
              uint64_t v6 = v47;
              *(_DWORD *)(a1 + 272) = v5;
              *(_DWORD *)(a1 + 452) = 1;
              goto LABEL_341;
            }

            xmlFatalErrMsgStr((_DWORD *)a1, 73, (uint64_t)"Couldn't find end of Start Tag %s\n", v103);
            v112 = *(_DWORD *)(a1 + 88);
            v113 = v112 - 1;
            if (v112 >= 1)
            {
              *(_DWORD *)(a1 + 88) = v113;
              v114 = *(void *)(a1 + 96);
              if (v112 == 1) {
                v115 = 0LL;
              }
              else {
                v115 = *(void *)(v114 + 8LL * (v112 - 2));
              }
              *(void *)(a1 + 80) = v115;
              *(void *)(v114 + 8LL * v113) = 0LL;
            }

            v116 = *(_DWORD *)(a1 + 376);
            if (v116 >= 1)
            {
              v117 = v116 - 2;
              v118 = v116 - 1;
              *(_DWORD *)(a1 + 376) = v118;
              v119 = *(void *)(a1 + 384);
              if (!v118) {
                v117 = 0;
              }
              *(void *)(a1 + 368) = v119 + 4LL * v117;
              *(_DWORD *)(v119 + 4LL * v118) = -1;
            }
          }

          nameNsPush((_DWORD *)a1, v103, *(uint64_t *)in, v158, line, *(_DWORD *)(a1 + 508) - v49);
          unint64_t v5 = 7;
          goto LABEL_271;
        }

        v148 = *(_DWORD *)(a1 + 376);
        if (v148 >= 1)
        {
          v149 = v148 - 2;
          v150 = v148 - 1;
          *(_DWORD *)(a1 + 376) = v150;
          v151 = *(void *)(a1 + 384);
          if (!v150) {
            v149 = 0;
          }
          *(void *)(a1 + 368) = v151 + 4LL * v149;
          *(_DWORD *)(v151 + 4LL * v150) = -1;
        }

        goto LABEL_393;
      case 7:
        if (v16 <= 1 && *(_DWORD *)(a1 + 64) == 1) {
          return;
        }
        v50 = *cur;
        uint64_t v51 = cur[1];
        consumed_low = LODWORD(v7->consumed);
        if (v50 == 60 && v51 == 47)
        {
          unint64_t v5 = 9;
          goto LABEL_340;
        }

        if (v50 == 60 && v51 == 63)
        {
          if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
          {
            xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_131:
            *(_DWORD *)(a1 + 272) = 7;
            *(_DWORD *)(a1 + 452) = 1;
LABEL_355:
            v132 = *(void *)(a1 + 56);
            if (consumed_low == *(void *)(v132 + 64) && cur == *(const xmlChar **)(v132 + 32))
            {
              xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"detected an error in element content\n");
              xmlHaltParser((xmlParserCtxtPtr)a1);
            }

            goto LABEL_291;
          }

          xmlCompileStepPattern((uint64_t *)v10);
          if (*((_DWORD *)v10 + 4)) {
            goto LABEL_109;
          }
          m = *(unsigned __int8 **)v10;
          LODWORD(v35) = **(unsigned __int8 **)v10;
          if ((_DWORD)v35 != 47) {
            goto LABEL_234;
          }
        }
      }

      goto LABEL_234;
    }

    *(void *)uint64_t v10 = v30 + 1;
    xmlCompileAttributeTest((uint64_t *)v10);
    for (n = *(unsigned __int8 **)v10; ; *(void *)uint64_t v10 = n)
    {
      uint64_t v34 = *n++;
      if (v34 > 0x20) {
        break;
      }
      if (((1LL << v34) & 0x100002600LL) == 0)
      {
        if (!*(n - 1)) {
          goto LABEL_109;
        }
        break;
      }
    }

    xmlCompileStepPattern((uint64_t *)v10);
    if (*((_DWORD *)v10 + 4)) {
      goto LABEL_109;
    }
    LODWORD(v35) = **(unsigned __int8 **)v10;
LABEL_234:
    if ((_DWORD)v35) {
      goto LABEL_107;
    }
LABEL_109:
    if (*((_DWORD *)v10 + 4))
    {
      uint64_t v9 = v7;
LABEL_238:
      *(void *)&v89 = -1LL;
      *((void *)&v89 + 1) = -1LL;
      v10[2] = v89;
      v10[3] = v89;
      *uint64_t v10 = v89;
      v10[1] = v89;
      xmlFree(v10);
LABEL_239:
      int v7 = v9;
      if (v9) {
LABEL_240:
      }
        xmlFreePatternList(v7);
      if (v11) {
        xmlFree(v11);
      }
      return 0LL;
    }

    *(void *)&int v41 = -1LL;
    *((void *)&v41 + 1) = -1LL;
    v10[2] = v41;
    v10[3] = v41;
    *uint64_t v10 = v41;
    v10[1] = v41;
    xmlFree(v10);
    if (v101)
    {
      if (v98 == 512)
      {
        v61 = *(_DWORD *)(v14 + 32);
        v101 = !(v61 & 0x100);
        v98 = 512;
        if ((v61 & 0x100) != 0) {
          goto LABEL_168;
        }
      }

      else if (v98 == 256)
      {
        v101 = (*(_DWORD *)(v14 + 32) & 0x200) == 0;
        v98 = 256;
        if ((*(_DWORD *)(v14 + 32) & 0x200) != 0) {
          goto LABEL_168;
        }
      }

      else
      {
        if (!v98) {
          v98 = *(_DWORD *)(v14 + 32) & 0x300;
        }
        v101 = 1;
      }

      uint64_t v42 = *(void *)(v14 + 48);
      if (v42)
      {
        v43 = *(_DWORD *)(v14 + 36);
        if (v43 == 1 && *(_DWORD *)v42 == 2 && !*(void *)(v42 + 8) && !*(void *)(v42 + 16))
        {
          v79 = xmlNewStreamComp(0);
          if (v79)
          {
            *((_DWORD *)v79 + 6) |= 0x4000u;
            *(void *)(v14 + 56) = v79;
          }
        }

        else
        {
          v44 = xmlNewStreamComp(v43 / 2 + 1);
          if (v44)
          {
            BOOL v45 = (uint64_t)v44;
            v46 = *(xmlDict **)(v14 + 8);
            if (v46)
            {
              *(void *)BOOL v45 = v46;
              xmlDictReference(v46);
            }

            xmlNsPtr v47 = *(_DWORD *)(v14 + 32);
            if ((v47 & 0x100) != 0) {
              *(_DWORD *)(v45 + 24) |= 0x8000u;
            }
            LODWORD(v48) = *(_DWORD *)(v14 + 36);
            if ((int)v48 < 1)
            {
              uint64_t v52 = 0;
LABEL_162:
              if ((v47 & 7) != 0)
              {
                uint64_t v62 = *(_DWORD *)(v45 + 8);
              }

              else
              {
                v77 = *(_DWORD *)(v45 + 24);
                if ((v77 & 0x10000) == 0) {
                  *(_DWORD *)(v45 + 24) = v77 | 0x10000;
                }
                uint64_t v62 = *(_DWORD *)(v45 + 8);
                if (v62 >= 1)
                {
                  v78 = *(_DWORD **)(v45 + 16);
                  if ((*v78 & 1) == 0) {
                    *v78 |= 1u;
                  }
                }
              }

              if (v62 <= v52)
              {
LABEL_167:
                xmlFreeStreamComp(v45);
                goto LABEL_168;
              }

              int v59 = (_DWORD *)(*(void *)(v45 + 16) + 32LL * v52);
              v60 = 2;
            }

            else
            {
              v49 = 0LL;
              v50 = 0;
              uint64_t v51 = 0;
              uint64_t v52 = 0;
              v53 = -1;
              do
              {
                while (2)
                {
                  int v54 = *(void *)(v14 + 48) + 24 * v49;
                  if (*(_DWORD *)v54 != 1)
                  {
                    switch(*(_DWORD *)v54)
                    {
                      case 2:
                        v55 = *(void *)(v54 + 8);
                        int v56 = *(void *)(v54 + 16);
                        if (*(_OWORD *)(v54 + 8) != 0LL) {
                          goto LABEL_140;
                        }
                        *(_DWORD *)(v45 + 24) |= 0x4000u;
                        __n128 v93 = v53;
                        uint64_t v52 = xmlStreamCompAddStep(v45, 0LL, 0LL, 100, v50 | 0x10u);
                        if (v52 < 0) {
                          goto LABEL_167;
                        }
                        if (v93 == -1) {
                          goto LABEL_142;
                        }
                        v50 = 0;
                        *(_DWORD *)(*(void *)(v45 + 16) + 32LL * v93) |= 0x20u;
                        goto LABEL_143;
                      case 3:
                        v55 = *(void *)(v54 + 8);
                        int v56 = *(void *)(v54 + 16);
LABEL_140:
                        xmlListPtr v57 = v45;
                        goto LABEL_150;
                      case 4:
                        uint64_t v52 = xmlStreamCompAddStep(v45, *(void *)(v54 + 8), *(void *)(v54 + 16), 2, v50 | 8u);
                        if (v52 < 0) {
                          goto LABEL_167;
                        }
LABEL_142:
                        v50 = 0;
LABEL_143:
                        v53 = -1;
                        goto LABEL_152;
                      case 6:
                        if ((v50 & 1) == 0)
                        {
                          v58 = *(_DWORD *)(v45 + 24);
                          if ((v58 & 0x10000) == 0) {
                            *(_DWORD *)(v45 + 24) = v58 | 0x10000;
                          }
                          v50 = 1;
                        }

                        goto LABEL_152;
                      case 7:
                        int v56 = *(void *)(v54 + 8);
                        xmlListPtr v57 = v45;
                        v55 = 0LL;
                        goto LABEL_150;
                      case 8:
                        xmlListPtr v57 = v45;
                        v55 = 0LL;
                        int v56 = 0LL;
LABEL_150:
                        uint64_t v52 = xmlStreamCompAddStep(v57, v55, v56, 1, v50);
                        if (v52 < 0) {
                          goto LABEL_167;
                        }
                        v50 = 0;
                        v53 = v52;
LABEL_152:
                        ++v49;
                        int v48 = *(int *)(v14 + 36);
                        if (v49 < v48) {
                          continue;
                        }
                        if (v51) {
                          goto LABEL_154;
                        }
                        xmlNsPtr v47 = *(_DWORD *)(v14 + 32);
                        break;
                      default:
                        goto LABEL_152;
                    }

                    goto LABEL_162;
                  }

                  break;
                }

                if (v49) {
                  goto LABEL_167;
                }
                v49 = 1LL;
                uint64_t v51 = 1;
              }

              while ((int)v48 > 1);
LABEL_154:
              if (*(_DWORD *)(v45 + 8) <= v52) {
                goto LABEL_167;
              }
              int v59 = *(_DWORD **)(v45 + 16);
              v59[8 * v52] |= 2u;
              v60 = 4;
            }

            *v59 |= v60;
            *(void *)(v14 + 56) = v45;
          }
        }
      }
    }

    else
    {
      v101 = 0;
    }

LABEL_97:
        uint64_t v3 = *(void *)(v3 + 48);
        if (v3 && (result & 0x80000000) == 0) {
          continue;
        }
        return result;
      case 2:
        v90 = "XML_ATTRIBUTE_NODE";
        goto LABEL_262;
      case 3:
      case 4:
        if (!v7) {
          goto LABEL_96;
        }
        uint64_t result = *(void *)(v3 + 80);
        if (!result) {
          goto LABEL_97;
        }
        uint64_t v9 = xmlC11NNormalizeString((_BYTE *)result, 3u);
        if (!v9)
        {
          v89 = "normalizing text node";
          goto LABEL_256;
        }

        uint64_t v10 = v9;
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v9);
        xmlFree(v10);
        goto LABEL_96;
      case 5:
        v90 = "XML_ENTITY_REF_NODE";
        goto LABEL_262;
      case 6:
        v90 = "XML_ENTITY_NODE";
        goto LABEL_262;
      case 7:
        if (!v7) {
          goto LABEL_96;
        }
        if (*((_DWORD *)a1 + 10) == 2) {
          uint64_t v17 = "\n<?";
        }
        else {
          uint64_t v17 = "<?";
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v17);
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], *(const char **)(v3 + 16));
        v18 = *(_BYTE **)(v3 + 80);
        if (!v18 || !*v18) {
          goto LABEL_35;
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], " ");
        int v19 = xmlC11NNormalizeString(*(_BYTE **)(v3 + 80), 2u);
        if (v19)
        {
          int v20 = v19;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v19);
          xmlFree(v20);
LABEL_35:
          unint64_t v21 = (xmlOutputBuffer *)a1[4];
          if (*((_DWORD *)a1 + 10)) {
            unint64_t v22 = "?>";
          }
          else {
            unint64_t v22 = "?>\n";
          }
LABEL_95:
          xmlOutputBufferWriteString(v21, v22);
LABEL_96:
          uint64_t result = 0LL;
          goto LABEL_97;
        }

        v89 = "normalizing pi node";
        break;
      case 8:
        if (!v7 || !*((_DWORD *)a1 + 6)) {
          goto LABEL_96;
        }
        if (*((_DWORD *)a1 + 10) == 2) {
          uint64_t v23 = "\n<!--";
        }
        else {
          uint64_t v23 = "<!--";
        }
        xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v23);
        v24 = *(_BYTE **)(v3 + 80);
        if (!v24) {
          goto LABEL_45;
        }
        v25 = xmlC11NNormalizeString(v24, 1u);
        if (v25)
        {
          v26 = v25;
          xmlOutputBufferWriteString((xmlOutputBufferPtr)a1[4], v25);
          xmlFree(v26);
LABEL_45:
          unint64_t v21 = (xmlOutputBuffer *)a1[4];
          if (*((_DWORD *)a1 + 10)) {
            unint64_t v22 = "-->";
          }
          else {
            unint64_t v22 = "-->\n";
          }
          goto LABEL_95;
        }

        v89 = "normalizing comment node";
        break;
      case 9:
      case 0xB:
      case 0xD:
      case 0x15:
        if (!*(void *)(v3 + 24)) {
          goto LABEL_96;
        }
        a1[5] = (xmlDocPtr)0x100000000LL;
        uint64_t result = xmlC14NProcessNodeList(a1);
        goto LABEL_97;
      case 0xA:
      case 0xC:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        goto LABEL_97;
      case 0x12:
        v90 = "XML_NAMESPACE_DECL";
LABEL_262:
        xmlC14NErrInvalidNode((char)v90);
        return 0xFFFFFFFFLL;
      default:
        __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x15u,  1954,  2,  0LL,  0,  (const xmlChar *)"processing node",  0LL,  0LL,  0,  0,  "Unknown node type %d found : %s\n",  *(_DWORD *)(v3 + 8));
        return 0xFFFFFFFFLL;
    }

    break;
  }

                  xmlSchemaPIllegalAttrErr((_DWORD *)a1, properties);
                  goto LABEL_103;
                }

            if (v5->error) {
              goto LABEL_184;
            }
            goto LABEL_69;
          }

          BOOL v45 = v46;
          if (*(_DWORD *)(v43 + 8) != 18) {
            goto LABEL_97;
          }
          v58 = *(const xmlChar **)(v43 + 24);
          if (!v58 || !str1) {
            goto LABEL_97;
          }
          if (!xmlStrEqual(v58, str1))
          {
LABEL_96:
            BOOL v45 = v46;
            goto LABEL_97;
          }

LABEL_256:
  xmlC14NErrInternal((const xmlChar *)v89);
  return 0xFFFFFFFFLL;
}

_DWORD *xmlC14NErrInternal(const xmlChar *a1)
{
  return __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x15u,  1,  2,  0LL,  0,  a1,  0LL,  0LL,  0,  0,  "Internal error : %s\n",  (char)a1);
}

void xmlC14NFreeCtx(void *a1)
{
  uint64_t v2 = (int *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)v2 + 2);
    if (v3)
    {
      bzero(v3, 8LL * v2[3]);
      xmlFree(*((void **)v2 + 2));
    }

    uint64_t v4 = (void *)*((void *)v2 + 3);
    if (v4)
    {
      bzero(v4, 8LL * v2[3]);
      xmlFree(*((void **)v2 + 3));
    }

    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    xmlFree(v2);
  }

  xmlFree(a1);
}

int xmlC14NDocSaveTo( xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlOutputBufferPtr buf)
{
  return xmlC14NExecute( doc,  (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset,  nodes,  mode,  inclusive_ns_prefixes,  with_comments,  buf);
}

uint64_t xmlC14NIsNodeInNodeset(xmlNodeSet *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 1LL;
  if (!a1 || !a2) {
    return v3;
  }
  if (*(_DWORD *)(a2 + 8) == 18)
  {
    __int128 v4 = *(_OWORD *)(a2 + 16);
    v6[0] = *(_OWORD *)a2;
    v6[1] = v4;
    v6[2] = *(_OWORD *)(a2 + 32);
    if (a3)
    {
      if (*(_DWORD *)(a3 + 8) == 2) {
        a3 = *(void *)(a3 + 40);
      }
    }

    *(void *)&v6[0] = a3;
    return xmlXPathNodeSetContains(a1, (xmlNodePtr)v6);
  }

  return xmlXPathNodeSetContains(a1, (xmlNodePtr)a2);
}

int xmlC14NDocDumpMemory( xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, xmlChar **doc_txt_ptr)
{
  if (!doc_txt_ptr)
  {
    xmlC14NErrParam((const xmlChar *)"dumping doc to memory");
    return -1;
  }

  *doc_txt_ptr = 0LL;
  xmlURIPtr v12 = xmlAllocOutputBuffer(0LL);
  if (!v12)
  {
    uint64_t v16 = "creating output buffer";
    goto LABEL_11;
  }

  size_t v13 = v12;
  if (xmlC14NExecute( doc,  (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset,  nodes,  mode,  inclusive_ns_prefixes,  with_comments,  v12) < 0)
  {
    xmlC14NErrInternal((const xmlChar *)"saving doc to output buffer");
    xmlOutputBufferClose(v13);
    return -1;
  }

  int v14 = xmlBufUse(v13->buffer);
  if ((v14 & 0x80000000) == 0)
  {
    size_t v15 = xmlBufContent(v13->buffer);
    *doc_txt_ptr = xmlStrndup(v15, v14);
  }

  xmlOutputBufferClose(v13);
  if ((v14 & 0x80000000) == 0 && !*doc_txt_ptr)
  {
    uint64_t v16 = "copying canonicalized document";
LABEL_11:
    xmlC14NErrMemory((const xmlChar *)v16);
    return -1;
  }

  return v14;
}

_DWORD *xmlC14NErrMemory(const xmlChar *a1)
{
  return __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x15u,  2,  2,  0LL,  0,  a1,  0LL,  0LL,  0,  0,  "Memory allocation failed : %s\n",  (char)a1);
}

int xmlC14NDocSave( xmlDocPtr doc, xmlNodeSetPtr nodes, int mode, xmlChar **inclusive_ns_prefixes, int with_comments, const char *filename, int compression)
{
  if (filename)
  {
    if (compression < 0) {
      compression = xmlGetCompressMode();
    }
    size_t v13 = xmlOutputBufferCreateFilename(filename, 0LL, compression);
    if (v13)
    {
      int v14 = v13;
      if ((xmlC14NExecute( doc,  (xmlC14NIsVisibleCallback)xmlC14NIsNodeInNodeset,  nodes,  mode,  inclusive_ns_prefixes,  with_comments,  v13) & 0x80000000) == 0) {
        return xmlOutputBufferClose(v14);
      }
      xmlC14NErrInternal((const xmlChar *)"canonize document to buffer");
      xmlOutputBufferClose(v14);
    }

    else
    {
      xmlC14NErrInternal((const xmlChar *)"creating temporary filename");
    }
  }

  else
  {
    xmlC14NErrParam((const xmlChar *)"saving doc");
  }

  return -1;
}

char *xmlC11NNormalizeString(_BYTE *a1, unsigned int a2)
{
  if (!a1) {
    return 0LL;
  }
  __int128 v4 = (char *)xmlMallocAtomic(0x3E8uLL);
  if (!v4)
  {
    int v14 = "allocating buffer";
    goto LABEL_41;
  }

  int v5 = *a1;
  if (!*a1)
  {
    uint64_t v8 = v4;
LABEL_39:
    *__int128 v4 = 0;
    return v8;
  }

  uint64_t v6 = a1 + 1;
  int v7 = 1000;
  uint64_t v8 = v4;
  while (1)
  {
    int v9 = (_DWORD)v4 - (_DWORD)v8;
    if (v4 - v8 <= v7 - 10) {
      goto LABEL_8;
    }
    v7 *= 2;
    uint64_t v10 = (char *)xmlRealloc(v8, v7);
    if (!v10) {
      break;
    }
    uint64_t v8 = v10;
    __int128 v4 = &v10[v9];
    int v5 = *(v6 - 1);
LABEL_8:
    if (v5 == 60)
    {
      if (a2 != 3 && a2) {
        goto LABEL_33;
      }
      int v11 = 997485606;
      goto LABEL_15;
    }

    if (a2 == 3 && v5 == 62)
    {
      int v11 = 997484326;
LABEL_15:
      *(_DWORD *)__int128 v4 = v11;
      v4 += 4;
      goto LABEL_34;
    }

    if (v5 == 38)
    {
      if (a2 != 3 && a2) {
        goto LABEL_33;
      }
      int v12 = 1886216486;
LABEL_32:
      *(_DWORD *)__int128 v4 = v12;
      v4[4] = 59;
      v4 += 5;
      goto LABEL_34;
    }

    if (a2 || v5 != 34)
    {
      if (a2 || v5 != 9)
      {
        if (a2 || v5 != 10)
        {
          if (a2 > 3 || v5 != 13)
          {
LABEL_33:
            *v4++ = v5;
            goto LABEL_34;
          }

          int v12 = 1148724006;
        }

        else
        {
          int v12 = 1098392358;
        }
      }

      else
      {
        int v12 = 964174630;
      }

      goto LABEL_32;
    }

    *(_DWORD *)__int128 v4 = 1869967654;
    *((_WORD *)v4 + 2) = 15220;
    v4 += 6;
LABEL_34:
    int v13 = *v6++;
    int v5 = v13;
    if (!v13) {
      goto LABEL_39;
    }
  }

  int v14 = "growing buffer";
LABEL_41:
  xmlC14NErrMemory((const xmlChar *)v14);
  return 0LL;
}

_DWORD *xmlC14NErrInvalidNode(char a1)
{
  return __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x15u,  1953,  2,  0LL,  0,  (const xmlChar *)"processing node",  0LL,  0LL,  0,  0,  "Node %s is invalid here : %s\n",  a1);
}

uint64_t xmlC14NNsCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 0LL;
  }
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a2) {
    return xmlStrcmp(*(const xmlChar **)(a1 + 24), *(const xmlChar **)(a2 + 24));
  }
  return 1LL;
}

uint64_t xmlC14NIsXmlNs(uint64_t a1)
{
  uint64_t result = xmlStrEqual(*(const xmlChar **)(a1 + 24), (const xmlChar *)"xml");
  if ((_DWORD)result) {
    return xmlStrEqual(*(const xmlChar **)(a1 + 16), (const xmlChar *)"http://www.w3.org/XML/1998/namespace") != 0;
  }
  return result;
}

BOOL xmlC14NVisibleNsStackFind(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    xmlC14NErrParam((const xmlChar *)"searching namespaces stack (c14n)");
    return 0LL;
  }

  uint64_t v2 = a1;
  uint64_t v3 = &byte_181A3ACBA;
  if (a2)
  {
    if (*(void *)(a2 + 24)) {
      __int128 v4 = *(char **)(a2 + 24);
    }
    else {
      __int128 v4 = &byte_181A3ACBA;
    }
    if (*(void *)(a2 + 16)) {
      int v5 = *(char **)(a2 + 16);
    }
    else {
      int v5 = &byte_181A3ACBA;
    }
    uint64_t v3 = v4;
  }

  else
  {
    int v5 = &byte_181A3ACBA;
  }

  if (*v3)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (!v6) {
      return 0LL;
    }
  }

  else
  {
    int v8 = *v5;
    BOOL result = *v5 == 0;
    uint64_t v6 = *(void *)(v2 + 16);
    if (!v6) {
      return result;
    }
    if (!*v5)
    {
      BOOL result = 1LL;
      goto LABEL_18;
    }
  }

  BOOL result = 0LL;
  int v8 = *(_DWORD *)(v2 + 4);
LABEL_18:
  LODWORD(v2) = *(_DWORD *)v2;
  while (2)
  {
    if ((int)v2 > v8)
    {
      uint64_t v2 = (int)v2;
      while (1)
      {
        --v2;
        uint64_t v9 = *(void *)(v6 + 8 * v2);
        if (!v9) {
          break;
        }
        uint64_t v10 = *(char **)(v9 + 24);
        if (v3 == v10) {
          goto LABEL_32;
        }
        if (!v10) {
          break;
        }
        int v11 = v3;
        while (1)
        {
          int v12 = *v11;
          ++v11;
          ++v10;
          if (!v12) {
            goto LABEL_32;
          }
        }

        if (v2 <= v8) {
          return result;
        }
      }

      if (*v3) {
        continue;
      }
      if (v9)
      {
LABEL_32:
        int v13 = *(char **)(v9 + 16);
        if (v5 == v13) {
          return 1LL;
        }
        if (v13)
        {
          while (1)
          {
            int v14 = *v5;
            ++v5;
            ++v13;
            if (!v14) {
              return 1LL;
            }
          }

          return 0LL;
        }
      }

      return *v5 == 0;
    }

    return result;
  }

_DWORD *xmlC14NVisibleNsStackAdd(int *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
  }
  BOOL result = (_DWORD *)*((void *)a1 + 2);
  uint64_t v7 = *((void *)a1 + 3);
  if (result)
  {
    if (v7)
    {
      uint64_t v8 = a1[3];
      if ((_DWORD)v8 != *a1)
      {
LABEL_14:
        uint64_t v13 = *a1;
        *(void *)(*((void *)a1 + 2) + 8 * v13) = a2;
        *(void *)(*((void *)a1 + 3) + 8 * v13) = a3;
        *a1 = v13 + 1;
        return result;
      }

      uint64_t v9 = xmlRealloc(result, 16 * v8);
      if (v9)
      {
        *((void *)a1 + 2) = v9;
        BOOL result = xmlRealloc(*((void **)a1 + 3), 16 * v8);
        if (result)
        {
          int v10 = 2 * v8;
          *((void *)a1 + 3) = result;
LABEL_13:
          a1[3] = v10;
          goto LABEL_14;
        }
      }

      return xmlC14NErrMemory((const xmlChar *)"adding node to stack");
    }

    return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
  }

  if (v7) {
    return xmlC14NErrParam((const xmlChar *)"adding namespace to stack");
  }
  *((void *)a1 + 2) = xmlMalloc(0x80uLL);
  BOOL result = xmlMalloc(0x80uLL);
  *((void *)a1 + 3) = result;
  int v11 = (_OWORD *)*((void *)a1 + 2);
  if (v11 && result)
  {
    v11[6] = 0u;
    v11[7] = 0u;
    v11[4] = 0u;
    v11[5] = 0u;
    v11[2] = 0u;
    v11[3] = 0u;
    *int v11 = 0u;
    v11[1] = 0u;
    int v12 = (_OWORD *)*((void *)a1 + 3);
    v12[6] = 0u;
    v12[7] = 0u;
    v12[4] = 0u;
    v12[5] = 0u;
    v12[2] = 0u;
    v12[3] = 0u;
    _OWORD *v12 = 0u;
    v12[1] = 0u;
    int v10 = 16;
    goto LABEL_13;
  }

  return xmlC14NErrMemory((const xmlChar *)"adding node to stack");
}

uint64_t xmlC14NPrintNamespaces(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    int v5 = *(xmlOutputBuffer **)(a2 + 32);
    if (v4)
    {
      xmlOutputBufferWriteString(v5, " xmlns:");
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(a1 + 24));
      int v5 = *(xmlOutputBuffer **)(a2 + 32);
      uint64_t v6 = "=";
    }

    else
    {
      uint64_t v6 = " xmlns=";
    }

    xmlOutputBufferWriteString(v5, v6);
    uint64_t v8 = *(xmlChar **)(a1 + 16);
    uint64_t v9 = *(void *)(a2 + 32);
    if (v8) {
      xmlBufWriteQuotedString(*(uint64x2_t **)(v9 + 32), v8);
    }
    else {
      xmlOutputBufferWriteString((xmlOutputBufferPtr)v9, "");
    }
    return 1LL;
  }

  else
  {
    xmlC14NErrParam((const xmlChar *)"writing namespaces");
    return 0LL;
  }

uint64_t xmlExcC14NVisibleNsStackFind(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = &byte_181A3ACBA;
    if (a2)
    {
      int v5 = *(char **)(a2 + 16);
      uint64_t v4 = *(char **)(a2 + 24);
      if (!v4) {
        uint64_t v4 = &byte_181A3ACBA;
      }
      if (!v5) {
        int v5 = &byte_181A3ACBA;
      }
      uint64_t v3 = v4;
    }

    else
    {
      int v5 = &byte_181A3ACBA;
    }

    if (*v3) {
      BOOL v6 = 0LL;
    }
    else {
      BOOL v6 = *v5 == 0;
    }
    uint64_t v7 = *((void *)a1 + 2);
    if (v7)
    {
      uint64_t v8 = *a1;
      while (2)
      {
        if ((int)v8 >= 1)
        {
          while (1)
          {
            uint64_t v9 = *(void *)(v7 + 8LL * (v8 - 1));
            if (!v9) {
              break;
            }
            int v10 = *(char **)(v9 + 24);
            if (v3 == v10) {
              goto LABEL_29;
            }
            if (!v10) {
              break;
            }
            int v11 = v3;
            while (1)
            {
              int v12 = *v11;
              ++v11;
              ++v10;
              if (!v12) {
                goto LABEL_29;
              }
            }

            if (v8-- < 2) {
              return v6;
            }
          }

          uint64_t v8 = (v8 - 1);
          if (*v3) {
            continue;
          }
          if (!v9) {
            goto LABEL_34;
          }
LABEL_29:
          int v14 = *(char **)(v9 + 16);
          if (v5 == v14) {
            goto LABEL_35;
          }
          if (v14)
          {
            while (1)
            {
              int v15 = *v5;
              ++v5;
              ++v14;
              if (!v15) {
                goto LABEL_35;
              }
            }
          }

LABEL_34:
          if (*v5) {
            return 0LL;
          }
LABEL_35:
          uint64_t v16 = *(uint64_t (**)(void))(a3 + 8);
          if (v16) {
            return v16(*(void *)(a3 + 16));
          }
          return 1LL;
        }

        break;
      }
    }
  }

  else
  {
    xmlC14NErrParam((const xmlChar *)"searching namespaces stack (exc c14n)");
    return 0LL;
  }

  return v6;
}

  htmlSkipBlankChars((uint64_t)a1);
  if (*a1->input->cur == 62)
  {
LABEL_35:
    xmlNextChar(a1);
  }

  else
  {
    htmlParseErr(a1, 61, "DOCTYPE improperly terminated\n", 0LL, 0LL);
    while (*a1->input->cur)
    {
      if (*a1->input->cur == 62) {
        goto LABEL_35;
      }
      xmlNextChar(a1);
    }
  }

  if (a1->sax)
  {
    internalSubset = (void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))a1->sax->internalSubset;
    if (internalSubset)
    {
      if (!a1->disableSAX) {

      }
        internalSubset(a1->userData, v3, v11, v10);
    }
  }

  if (v10) {
    xmlFree(v10);
  }
  if (v11) {
    xmlFree(v11);
  }
}

    int v11 = *(xmlParserInput **)(a1 + 56);
    uint64_t v13 = v11->cur;
    end = v11->end;
    int v14 = &v13[v8];
    if (v14 <= end)
    {
      if (*v13 == 10)
      {
        ++v11->line;
        v11->col = 1;
      }

      else
      {
        ++v11->col;
      }

      *(_DWORD *)(a1 + 276) = 0;
      v11->cur = v14;
      ++*(void *)(a1 + 312);
      v13 += v8;
    }

    if (v7 < 100)
    {
      ++v7;
    }

    else
    {
      if (end - v13 <= 499 && v13 - v11->base >= 501) {
        xmlParserInputShrink(v11);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        int v15 = *(xmlParserInput **)(a1 + 56);
        if (v15->end - v15->cur <= 249) {
          xmlParserInputGrow(v15, 250);
        }
      }

      uint64_t v7 = 0;
    }

    BOOL result = htmlCurrentChar(a1, &len);
    int v5 = result;
    if (!(_DWORD)result)
    {
      uint64_t v16 = *(xmlParserInput **)(a1 + 56);
      uint64_t v17 = v16->cur;
      if (v17 - v16->base >= 501 && v16->end - v17 <= 499) {
        xmlParserInputShrink(v16);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        v18 = *(xmlParserInput **)(a1 + 56);
        if (v18->end - v18->cur <= 249) {
          xmlParserInputGrow(v18, 250);
        }
      }

      BOOL result = htmlCurrentChar(a1, &len);
      int v5 = result;
    }
  }

  if (!(_DWORD)v6)
  {
    *(_DWORD *)(a1 + 272) = -1;
    return result;
  }

  ctxt->instate = instate;
}

      *((_DWORD *)v10 + 6) = v5;
      return v10;
    }
  }

  else
  {
    else {
      int v14 = v5;
    }
    *((_DWORD *)v10 + 5) = v14;
    uint64_t v13 = xmlMalloc(8LL * v14);
    v10[6] = v13;
    if (v13) {
      goto LABEL_28;
    }
  }

  *(_DWORD *)(a1 + 16) = 1450;
  xmlRegexpErrCompile(a1, (uint64_t)"internal: no atom generated");
LABEL_35:
  v18 = *(unsigned __int8 **)(a1 + 8);
  int v19 = *v18;
  if (v19 == 123)
  {
    *(void *)(a1 + 8) = v18 + 1;
    unint64_t v22 = xmlFAParseQuantExact(a1);
    if (v22 < 0)
    {
      *(_DWORD *)(a1 + 16) = 1450;
      xmlRegexpErrCompile(a1, (uint64_t)"Improper quantifier");
      unint64_t v22 = 0;
    }

    uint64_t v23 = *(_BYTE **)(a1 + 8);
    if (*v23 == 44)
    {
      *(void *)(a1 + 8) = v23 + 1;
      if (v23[1] == 125)
      {
        v24 = 0x7FFFFFFF;
        goto LABEL_56;
      }

      v24 = xmlFAParseQuantExact(a1);
      if ((v24 & 0x80000000) == 0)
      {
LABEL_56:
        v25 = *(_BYTE **)(a1 + 8);
        if (*v25 == 125)
        {
          *(void *)(a1 + 8) = v25 + 1;
        }

        else
        {
          *(_DWORD *)(a1 + 16) = 1450;
          xmlRegexpErrCompile(a1, (uint64_t)"Unterminated quantifier");
        }

        v26 = *(_DWORD **)(a1 + 48);
        if (v26)
        {
          if (v24) {
            int v27 = v24;
          }
          else {
            int v27 = v22;
          }
          v26[2] = 8;
          v26[3] = v22;
          v26[4] = v27;
        }

        return 1LL;
      }

      *(_DWORD *)(a1 + 16) = 1450;
      xmlRegexpErrCompile(a1, (uint64_t)"Improper quantifier");
    }

    v24 = 0;
    goto LABEL_56;
  }

  if (v19 == 63)
  {
LABEL_38:
    int v20 = *(void *)(a1 + 48);
    if (v20)
    {
      switch(v19)
      {
        case '?':
          unint64_t v21 = 3;
          goto LABEL_50;
        case '+':
          unint64_t v21 = 5;
          goto LABEL_50;
        case '*':
          unint64_t v21 = 4;
LABEL_50:
          *(_DWORD *)(v20 + 8) = v21;
          break;
      }
    }

    *(void *)(a1 + 8) = v18 + 1;
  }

  return 1LL;
}

uint64_t xmlC14NAttrsCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 0LL;
  }
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 72);
    uint64_t v5 = *(void *)(a2 + 72);
    if (v4 == v5) {
      return xmlStrcmp(*(const xmlChar **)(a1 + 16), *(const xmlChar **)(a2 + 16));
    }
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    if (v5)
    {
      if (*(void *)(v4 + 24))
      {
        if (*(void *)(v5 + 24))
        {
          uint64_t result = xmlStrcmp(*(const xmlChar **)(v4 + 16), *(const xmlChar **)(v5 + 16));
          if ((_DWORD)result) {
            return result;
          }
          return xmlStrcmp(*(const xmlChar **)(a1 + 16), *(const xmlChar **)(a2 + 16));
        }

        return 1LL;
      }

      return 0xFFFFFFFFLL;
    }
  }

  return 1LL;
}

xmlAttrPtr xmlC14NFindHiddenParentAttr(uint64_t a1, const xmlNode *a2, const xmlChar *a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = a2;
  do
  {
    BOOL v6 = *(unsigned int (**)(void, const xmlNode *, _xmlNode *))(a1 + 8);
    if (!v6 || v6(*(void *)(a1 + 16), v4, v4->parent)) {
      break;
    }
    xmlAttrPtr result = xmlHasNsProp(v4, a3, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    if (result) {
      return result;
    }
    uint64_t v4 = v4->parent;
  }

  while (v4);
  return 0LL;
}

uint64_t xmlC14NPrintAttrs(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), " ");
    uint64_t v4 = *(void *)(a1 + 72);
    if (v4)
    {
      if (xmlStrlen(*(const xmlChar **)(v4 + 24)) >= 1)
      {
        xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(*(void *)(a1 + 72) + 24LL));
        xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), ":");
      }
    }

    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), *(const char **)(a1 + 16));
    xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), "=");
    String = xmlNodeListGetString(*(xmlDocPtr *)a2, *(const xmlNode **)(a1 + 24), 1);
    if (!String) {
      goto LABEL_9;
    }
    BOOL v6 = String;
    uint64_t v7 = xmlC11NNormalizeString(String, 0);
    xmlFree(v6);
    if (v7)
    {
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), v7);
      xmlFree(v7);
LABEL_9:
      xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)(a2 + 32), "");
      return 1LL;
    }

    xmlC14NErrInternal((const xmlChar *)"normalizing attributes axis");
  }

  else
  {
    xmlC14NErrParam((const xmlChar *)"writing attributes");
  }

  return 0LL;
}

void xmlFreeCatalog(xmlCatalogPtr catal)
{
  if (catal)
  {
    uint64_t v2 = (void *)*((void *)catal + 14);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        xmlFreeCatalogEntry((uint64_t)v2);
        uint64_t v2 = v3;
      }

      while (v3);
    }

    uint64_t v4 = (xmlHashTable *)*((void *)catal + 12);
    if (v4) {
      xmlHashFree(v4, (xmlHashDeallocator)xmlFreeCatalogEntry);
    }
    xmlFree(catal);
  }

void xmlFreeCatalogEntry(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 60) == 1) {
    return;
  }
  if (xmlDebugCatalogs)
  {
    if (*(void *)(a1 + 32))
    {
      xmlGenericErrorFunc v2 = *__xmlGenericError();
      uint64_t v3 = *__xmlGenericErrorContext();
    }

    else
    {
      uint64_t v4 = *(void *)(a1 + 40);
      xmlGenericErrorFunc v2 = *__xmlGenericError();
      uint64_t v3 = *__xmlGenericErrorContext();
      if (!v4)
      {
        uint64_t v5 = "Free catalog entry\n";
        goto LABEL_9;
      }
    }

    uint64_t v5 = "Free catalog entry %s\n";
LABEL_9:
    v2(v3, v5);
  }

  BOOL v6 = *(void **)(a1 + 32);
  if (v6) {
    xmlFree(v6);
  }
  uint64_t v7 = *(void **)(a1 + 40);
  if (v7) {
    xmlFree(v7);
  }
  uint64_t v8 = *(void **)(a1 + 48);
  if (v8) {
    xmlFree(v8);
  }
  xmlFree((void *)a1);
}

int xmlConvertSGMLCatalog(xmlCatalogPtr catal)
{
  xmlCatalogPtr data = catal;
  if (!catal || *(_DWORD *)catal != 2) {
    return -1;
  }
  if (xmlDebugCatalogs)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    uint64_t v3 = __xmlGenericErrorContext();
    v2(*v3, "Converting SGML catalog to XML\n");
  }

  xmlHashScan(*((xmlHashTablePtr *)catal + 12), (xmlHashScanner)xmlCatalogConvertEntry, &data);
  return 0;
}

xmlHashTable *xmlCatalogConvertEntry(xmlHashTable *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      uint64_t v3 = result;
      xmlAttrPtr result = *(xmlHashTable **)(a2 + 96);
      if (result)
      {
        if (*(void *)(a2 + 112))
        {
          int v4 = *((_DWORD *)v3 + 6) - 13;
          if (v4 < 0xA && ((0x2FFu >> v4) & 1) != 0)
          {
            *((_DWORD *)v3 + 6) = dword_181A36914[v4];
            xmlAttrPtr result = (xmlHashTable *)xmlHashRemoveEntry(result, *((const xmlChar **)v3 + 4), 0LL);
            uint64_t v5 = *(void *)(a2 + 112);
            *(void *)uint64_t v3 = 0LL;
            *((void *)v3 + 1) = v5;
            BOOL v6 = *(xmlHashTable **)(v5 + 16);
            if (v6)
            {
              do
              {
                uint64_t v7 = (xmlHashTable **)v6;
                BOOL v6 = *(xmlHashTable **)v6;
              }

              while (v6);
              void *v7 = v3;
            }

            else
            {
              *(void *)(v5 + 16) = v3;
            }
          }

          else
          {
            return (xmlHashTable *)xmlHashRemoveEntry( result,  *((const xmlChar **)v3 + 4),  (xmlHashDeallocator)xmlFreeCatalogEntry);
          }
        }
      }
    }
  }

  return result;
}

xmlDocPtr xmlParseCatalogFile(const char *filename)
{
  xmlParserCtxtPtr v2 = xmlNewParserCtxt();
  if (!v2)
  {
    if (__xmlDefaultSAXHandler()->error)
    {
      int v11 = __xmlDefaultSAXHandler();
      v11->error(0LL, "out of memory\n");
    }

    return 0LL;
  }

  xmlParserCtxtPtr v3 = v2;
  xmlParserInputBufferPtr v4 = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
  if (!v4)
  {
LABEL_14:
    xmlFreeParserCtxt(v3);
    return 0LL;
  }

  xmlParserInputBufferPtr v5 = v4;
  xmlParserInputPtr v6 = xmlNewInputStream(v3);
  if (!v6)
  {
    xmlFreeParserInputBuffer(v5);
    goto LABEL_14;
  }

  uint64_t v7 = v6;
  uint64_t v8 = xmlCanonicPath((const xmlChar *)filename);
  v7->buf = v5;
  v7->filename = (const char *)v8;
  xmlBufResetInput((uint64_t *)v5->buffer, v7);
  inputPush(v3, v7);
  if (!v3->directory)
  {
    Directory = xmlParserGetDirectory(filename);
    if (!v3->directory)
    {
      if (Directory) {
        v3->directory = Directory;
      }
    }
  }

  *(void *)&v3->valid = 0LL;
  v3->loadsubset = 0;
  v3->pedantic = 0;
  v3->dictNames = 1;
  xmlParseDocument(v3);
  myDoc = v3->myDoc;
  if (!v3->wellFormed)
  {
    xmlFreeDoc(v3->myDoc);
    myDoc = 0LL;
    v3->myDoc = 0LL;
  }

  xmlFreeParserCtxt(v3);
  return myDoc;
}

xmlCatalogPtr xmlLoadSGMLSuperCatalog(const char *filename)
{
  FileContent = xmlLoadFileContent((char *)filename);
  if (!FileContent) {
    return 0LL;
  }
  xmlParserCtxtPtr v3 = FileContent;
  NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
  xmlParserInputBufferPtr v5 = NewCatalog;
  if (!NewCatalog)
  {
    xmlFree(v3);
    return v5;
  }

  int v6 = xmlParseSGMLCatalog((uint64_t)NewCatalog, (unsigned __int8 *)v3, (xmlChar *)filename, 1);
  xmlFree(v3);
  if (v6 < 0)
  {
    xmlFreeCatalog(v5);
    return 0LL;
  }

  return v5;
}

char *xmlLoadFileContent(char *a1)
{
  unint64_t v1 = a1;
  if (a1)
  {
    memset(&v7, 0, sizeof(v7));
    if ((stat(a1, &v7) & 0x80000000) == 0)
    {
      int v2 = open(v1, 0);
      if ((v2 & 0x80000000) == 0)
      {
        int v3 = v2;
        size_t st_size = v7.st_size;
        unint64_t v1 = (char *)xmlMallocAtomic(v7.st_size + 10);
        if (!v1)
        {
          xmlCatalogErrMemory((uint64_t)"allocating catalog data");
          close(v3);
          return v1;
        }

        int v5 = read(v3, v1, st_size);
        close(v3);
        if ((v5 & 0x80000000) == 0)
        {
          v1[v5] = 0;
          return v1;
        }

        xmlFree(v1);
      }
    }

    return 0LL;
  }

  return v1;
}

_OWORD *xmlCreateNewCatalog(int a1, int a2)
{
  xmlParserInputBufferPtr v4 = xmlMalloc(0x78uLL);
  int v5 = v4;
  if (v4)
  {
    v4[5] = 0u;
    v4[6] = 0u;
    *((void *)v4 + 14) = 0LL;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    *xmlParserInputBufferPtr v4 = 0u;
    *(_DWORD *)xmlParserInputBufferPtr v4 = a1;
    *((void *)v4 + 11) = 0xA00000000LL;
    *((_DWORD *)v4 + 26) = a2;
    if (a1 == 2) {
      *((void *)v4 + 12) = xmlHashCreate(10);
    }
  }

  else
  {
    xmlCatalogErrMemory((uint64_t)"allocating catalog");
  }

  return v5;
}

uint64_t xmlParseSGMLCatalog(uint64_t a1, unsigned __int8 *a2, xmlChar *cur, int a4)
{
  if (!cur) {
    return 0xFFFFFFFFLL;
  }
  stat v7 = xmlStrdup(cur);
  if (!a2) {
    goto LABEL_100;
  }
  while (1)
  {
LABEL_3:
    unsigned int v8 = *a2;
    if (!*a2) {
      break;
    }
    uint64_t v9 = a2 + 2;
    a2 += 4;
    while (v8 <= 0x2D)
    {
      if (((1LL << v8) & 0x100002600LL) == 0)
      {
        if (!v8)
        {
          a2 = v9 - 2;
          goto LABEL_100;
        }

        if (v8 == 45LL && *(v9 - 1) == 45)
        {
          while (1)
          {
            if (*(a2 - 2) == 45)
            {
              if (*(a2 - 1) == 45) {
                goto LABEL_3;
              }
            }

            else if (!*(a2 - 2))
            {
              a2 = 0LL;
              goto LABEL_100;
            }

            ++a2;
          }
        }

        break;
      }

      unsigned int v8 = *(v9++ - 1);
      ++a2;
    }

    str1 = 0LL;
    cura = 0LL;
    int v10 = xmlParseSGMLCatalogName(v9 - 2, &str1);
    a2 = v10;
    if (!v10) {
      break;
    }
    int v11 = str1;
    if (!str1) {
      break;
    }
    unsigned int v12 = *v10;
    if (v12 > 0x20 || ((1LL << v12) & 0x100002600LL) == 0) {
      goto LABEL_108;
    }
    while (v12 <= 0x20u && ((1LL << v12) & 0x100002600LL) != 0)
    {
      char v14 = *++a2;
      LOBYTE(v12) = v14;
    }

    int v15 = xmlStrEqual(str1, (const xmlChar *)"SYSTEM");
    if (v15)
    {
      int v17 = 13;
LABEL_43:
      int v42 = v17;
      xmlFree(v11);
      str1 = 0LL;
      v18 = xmlParseSGMLCatalogPubid(a2, &str1);
      if (!v18) {
        goto LABEL_105;
      }
      a2 = v18;
      if (!v15)
      {
        unint64_t v22 = str1;
        uint64_t v23 = xmlCatalogNormalizePublic(str1);
        if (v23)
        {
          v24 = v23;
          if (v22) {
            xmlFree(v22);
          }
          if (*v24)
          {
            str1 = v24;
          }

          else
          {
            xmlFree(v24);
            str1 = 0LL;
          }
        }
      }

      unsigned int v19 = *a2;
      if (v19 > 0x20 || ((1LL << v19) & 0x100002600LL) == 0)
      {
LABEL_71:
        int v30 = v42;
LABEL_82:
        if ((v30 - 13) > 1)
        {
          if (v30 == 22)
          {
            v37 = cura;
            if (a4)
            {
              BOOL v38 = xmlNewCatalogEntry(22, cura, 0LL, 0LL, 0, 0LL);
              if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 96), v37, v38) < 0) {
                xmlFreeCatalogEntry((uint64_t)v38);
              }
            }

            else
            {
              xmlListPtr v39 = (char *)xmlBuildURI(cura, v7);
              if (v39)
              {
                v40 = v39;
                xmlExpandCatalog(a1, v39);
                xmlFree(v40);
              }
            }
          }
        }

        else
        {
          int v33 = xmlBuildURI(cura, v7);
          if (v33)
          {
            uint64_t v34 = v33;
            xmlNsPtr v35 = str1;
            v36 = xmlNewCatalogEntry(v30, str1, v33, 0LL, 0, 0LL);
            if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 96), v35, v36) < 0) {
              xmlFreeCatalogEntry((uint64_t)v36);
            }
            xmlFree(v34);
          }
        }

        goto LABEL_93;
      }

      while (v19 <= 0x20u && ((1LL << v19) & 0x100002600LL) != 0)
      {
        char v21 = *++a2;
        LOBYTE(v19) = v21;
      }

LABEL_77:
      int v32 = xmlParseSGMLCatalogPubid(a2, &cura);
      if (!v32)
      {
LABEL_105:
        if (str1) {
          xmlFree(str1);
        }
        a2 = 0LL;
        int v11 = cura;
        if (cura)
        {
LABEL_108:
          xmlFree(v11);
          break;
        }

        break;
      }

      a2 = v32;
      int v30 = v42;
      if (v42 != 21) {
        goto LABEL_82;
      }
      if (v7) {
        xmlFree(v7);
      }
      stat v7 = xmlStrdup(cura);
LABEL_93:
      if (str1) {
        xmlFree(str1);
      }
LABEL_95:
      if (cura) {
        xmlFree(cura);
      }
    }

    else
    {
      if (xmlStrEqual(v11, (const xmlChar *)"PUBLIC"))
      {
        int v17 = 14;
        goto LABEL_43;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"DELEGATE"))
      {
        int v17 = 20;
        goto LABEL_43;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"ENTITY"))
      {
        xmlFree(v11);
        str1 = 0LL;
        if (*a2 == 37) {
          int v25 = 16;
        }
        else {
          int v25 = 15;
        }
        int v42 = v25;
        goto LABEL_65;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"DOCTYPE"))
      {
        int v26 = 17;
        goto LABEL_64;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"LINKTYPE"))
      {
        int v26 = 18;
        goto LABEL_64;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"NOTATION"))
      {
        int v26 = 19;
LABEL_64:
        int v42 = v26;
        xmlFree(v11);
        str1 = 0LL;
LABEL_65:
        int v27 = xmlParseSGMLCatalogName(a2, &str1);
        if (!v27) {
          goto LABEL_105;
        }
        a2 = v27;
        unsigned int v28 = *v27;
        if (v28 > 0x20 || ((1LL << v28) & 0x100002600LL) == 0) {
          goto LABEL_71;
        }
        while (v28 <= 0x20u && ((1LL << v28) & 0x100002600LL) != 0)
        {
          char v29 = *++a2;
          LOBYTE(v28) = v29;
        }

        goto LABEL_77;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"SGMLDECL"))
      {
        int v31 = 24;
LABEL_76:
        int v42 = v31;
        xmlFree(v11);
        str1 = 0LL;
        goto LABEL_77;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"DOCUMENT"))
      {
        int v31 = 23;
        goto LABEL_76;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"CATALOG"))
      {
        int v31 = 22;
        goto LABEL_76;
      }

      if (xmlStrEqual(v11, (const xmlChar *)"BASE"))
      {
        int v31 = 21;
        goto LABEL_76;
      }

      int v16 = xmlStrEqual(v11, (const xmlChar *)"OVERRIDE");
      xmlFree(v11);
      if (!v16) {
        goto LABEL_95;
      }
      a2 = xmlParseSGMLCatalogName(a2, &str1);
      if (!str1) {
        break;
      }
      xmlFree(str1);
      if (!a2) {
        break;
      }
    }
  }

    htmlSkipBlankChars(a1);
  }

  if (v38)
  {
    if ((_DWORD)v12)
    {
      if (v3)
      {
        unsigned int v28 = *v3;
        if (*v3)
        {
          char v29 = 0LL;
          xmlListPtr v39 = 0;
          int v30 = v3 + 2;
          do
          {
            int v31 = (xmlChar *)*(v30 - 1);
            if (v31)
            {
              if (xmlStrcasecmp(v28, (const xmlChar *)"http-equiv")
                || xmlStrcasecmp(v31, (const xmlChar *)"Content-Type"))
              {
                if (xmlStrcasecmp(v28, (const xmlChar *)"charset"))
                {
                  if (!xmlStrcasecmp(v28, (const xmlChar *)"content")) {
                    char v29 = v31;
                  }
                }

                else
                {
                  htmlCheckEncodingDirect(a1, v31);
                }
              }

              else
              {
                xmlListPtr v39 = 1;
              }
            }

            int v32 = *v30;
            v30 += 2;
            unsigned int v28 = v32;
          }

          while (v32);
          if (v39 && v29) {
            htmlCheckEncoding(a1, v29);
          }
        }
      }
    }
  }

  if (!(_DWORD)v9
    && (htmlnamePush(a1, str1), *(void *)a1)
    && (xmlNsPtr v35 = *(void (**)(uint64_t, xmlChar *, const xmlChar **))(*(void *)a1 + 112LL)) != 0LL)
  {
    v36 = *(void *)(a1 + 8);
    if ((_DWORD)v12)
    {
      v35(v36, str1, v3);
      goto LABEL_100;
    }

    v35(v36, str1, 0LL);
    return 0LL;
  }

  else
  {
LABEL_100:
    if (v3 && (int)v12 >= 2)
    {
      int v33 = 1LL;
      do
      {
        uint64_t v34 = (xmlChar *)v3[v33];
        if (v34) {
          xmlFree(v34);
        }
        v33 += 2LL;
      }

      while ((int)v12 > (int)v33);
    }
  }

  return v9;
}

LABEL_100:
  if (v7) {
    xmlFree(v7);
  }
  if (a2) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

                    __xmlSimpleError(2, 9, 0, (uint64_t)"xmlEncodeEntities: char out of range\n", 0LL);
                    if (a1) {
                      *(void *)(a1 + 112) = xmlStrdup((const xmlChar *)"ISO-8859-1");
                    }
                    snprintf(__str, 0xBuLL, "&#%d;", *v4);
                    __str[10] = 0;
                    v40 = __str[0];
                    if (__str[0])
                    {
                      int v41 = &__str[1];
                      do
                      {
                        *v8++ = v40;
                        int v42 = *v41++;
                        v40 = v42;
                      }

                      while (v42);
                    }

                    goto LABEL_88;
                  }
                }
              }
            }

            __xmlSimpleError(2, 5032, 0, (uint64_t)"xmlEncodeEntities: input not UTF-8", 0LL);
            if (a1) {
              *(void *)(a1 + 112) = xmlStrdup((const xmlChar *)"ISO-8859-1");
            }
            snprintf(__str, 0xBuLL, "&#%d;", *v4);
            __str[10] = 0;
            xmlNsPtr v35 = __str[0];
            if (__str[0])
            {
              v36 = &__str[1];
              do
              {
                *v8++ = v35;
                v37 = *v36++;
                xmlNsPtr v35 = v37;
              }

              while (v37);
            }

            int v31 = v4 + 1;
            goto LABEL_88;
          }
        }

        else if (!v6)
        {
          goto LABEL_67;
        }
      }

      *v8++ = v9;
LABEL_78:
      ++v4;
LABEL_79:
      uint64_t v9 = *v4;
      if (!*v4) {
        goto LABEL_114;
      }
    }

    uint64_t v23 = 997484326;
LABEL_62:
    *(_DWORD *)unsigned int v8 = v23;
    v8 += 4;
    goto LABEL_78;
  }

  uint64_t v13 = v7;
LABEL_114:
  *unsigned int v8 = 0;
  return v13;
}

      if (*((_DWORD *)reader + 4) && *(_DWORD *)(v8 + 8) == 1)
      {
        xmlTextReaderValidatePop((uint64_t)reader);
        unsigned int v8 = *((void *)reader + 14);
      }

      xmlListPtr v39 = *((_DWORD *)reader + 80);
      if (v39 >= 1)
      {
        if ((*(_WORD *)(v8 + 114) & 4) == 0)
        {
          *((void *)reader + 14) = *(void *)(v8 + 48);
          int v33 = 1;
          goto LABEL_106;
        }

        *((_DWORD *)reader + 80) = --v39;
      }

      int v41 = *(void *)(v8 + 48);
      *((void *)reader + 14) = v41;
      *((_DWORD *)reader + 6) = 1;
      if (!v39 && !*((_DWORD *)reader + 74) && !*((_DWORD *)reader + 44))
      {
        int v42 = *(void *)(v41 + 56);
        if (v42)
        {
          if (*(_DWORD *)(v42 + 8) != 14 && (*(_WORD *)(v42 + 114) & 2) == 0)
          {
            if (v9 == v42) {
              uint64_t v9 = 0LL;
            }
            xmlUnlinkNode((xmlNodePtr)v42);
            xmlTextReaderFreeNode((uint64_t)reader, (xmlAttr *)v42);
          }
        }
      }

  if (v38)
  {
    xmlNsPtr v47 = 0LL;
    do
    {
      int v48 = *(void *)(*(void *)(a1 + 80) + 8 * v47);
      if (v48 && !*(_DWORD *)(v48 + 12))
      {
        v49 = *(void **)(v48 + 32);
        if (v49) {
          xmlFree(v49);
        }
        v50 = *(void **)(v48 + 48);
        if (v50) {
          xmlFree(v50);
        }
        xmlFree((void *)v48);
        *(void *)(*(void *)(a1 + 80) + 8 * v47) = 0LL;
        LODWORD(v2) = *(_DWORD *)(a1 + 76);
      }

      ++v47;
    }

    while (v47 < (int)v2);
  }

xmlCatalogPtr xmlLoadACatalog(const char *filename)
{
  FileContent = xmlLoadFileContent((char *)filename);
  if (!FileContent) {
    return 0LL;
  }
  int v3 = (unsigned __int8 *)FileContent;
  xmlParserInputBufferPtr v4 = FileContent;
  while (1)
  {
    int v5 = *v4;
    if (!*v4 || v5 == 45)
    {
LABEL_7:
      NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
      stat v7 = NewCatalog;
      if (NewCatalog && (xmlParseSGMLCatalog((uint64_t)NewCatalog, v3, (xmlChar *)filename, 0) & 0x80000000) != 0)
      {
        xmlFreeCatalog(v7);
        stat v7 = 0LL;
      }

      goto LABEL_13;
    }

    if (v5 == 60) {
      break;
    }
    ++v4;
    if ((v5 & 0xFFFFFFDF) - 65 <= 0x19) {
      goto LABEL_7;
    }
  }

  stat v7 = (xmlCatalog *)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  if (v7) {
    *((void *)v7 + 14) = xmlNewCatalogEntry(1, 0LL, 0LL, (xmlChar *)filename, xmlCatalogDefaultPrefer, 0LL);
  }
LABEL_13:
  xmlFree(v3);
  return v7;
}

void *xmlNewCatalogEntry(int a1, xmlChar *a2, const xmlChar *a3, xmlChar *a4, int a5, uint64_t a6)
{
  unsigned int v12 = xmlMalloc(0x50uLL);
  uint64_t v13 = v12;
  if (!v12)
  {
    xmlCatalogErrMemory((uint64_t)"allocating catalog entry");
    return v13;
  }

  void *v12 = 0LL;
  v12[1] = 0LL;
  v12[2] = 0LL;
  *((_DWORD *)v12 + 6) = a1;
  if (a1 == 8 || a1 == 5)
  {
    char v14 = xmlCatalogNormalizePublic(a2);
    if (v14)
    {
      int v15 = v14;
      if (!*v14)
      {
        int v16 = 0LL;
        goto LABEL_11;
      }

      a2 = v14;
      goto LABEL_9;
    }
  }

  int v15 = 0LL;
  int v16 = 0LL;
  if (a2) {
LABEL_9:
  }
    int v16 = xmlStrdup(a2);
LABEL_11:
  v13[4] = v16;
  if (v15) {
    xmlFree(v15);
  }
  if (a3) {
    int v17 = xmlStrdup(a3);
  }
  else {
    int v17 = 0LL;
  }
  v13[5] = v17;
  if (a4) {
    v18 = a4;
  }
  else {
    v18 = (xmlChar *)a3;
  }
  if (v18) {
    v18 = xmlStrdup(v18);
  }
  v13[6] = v18;
  *((_DWORD *)v13 + 15) = 0;
  *((_DWORD *)v13 + 16) = 0;
  *((_DWORD *)v13 + 14) = a5;
  v13[9] = a6;
  return v13;
}

xmlChar *__cdecl xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID)
{
  xmlAttrPtr result = 0LL;
  if (catal && sysID)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      int v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve sysID %s\n", (const char *)sysID);
    }

    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolve(*((void *)catal + 14), 0LL, (uint64_t)sysID);
      if (result == (xmlChar *)-1LL) {
        return 0LL;
      }
    }

    else
    {
      xmlAttrPtr result = (xmlChar *)*((void *)catal + 12);
      if (result)
      {
        xmlAttrPtr result = (xmlChar *)xmlHashLookup((xmlHashTablePtr)result, sysID);
        if (result)
        {
          if (*((_DWORD *)result + 6) == 13)
          {
            xmlAttrPtr result = (xmlChar *)*((void *)result + 6);
            if (result) {
              return xmlStrdup(result);
            }
          }

          else
          {
            return 0LL;
          }
        }
      }
    }
  }

  return result;
}

uint64_t xmlCatalogListXMLResolve(uint64_t a1, xmlChar *a2, uint64_t a3)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  xmlParserInputBufferPtr v4 = (const char *)a2;
  uint64_t v6 = a1;
  stat v7 = xmlCatalogNormalizePublic(a2);
  unsigned int v8 = v7;
  if (v7)
  {
    if (*v7) {
      xmlParserInputBufferPtr v4 = (const char *)v7;
    }
    else {
      xmlParserInputBufferPtr v4 = 0LL;
    }
  }

  if (!xmlStrncmp((const xmlChar *)v4, (const xmlChar *)"urn:publicid:", 13))
  {
    v58 = xmlCatalogUnWrapURN((uint64_t)v4);
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v59 = *__xmlGenericError();
      v60 = *__xmlGenericErrorContext();
      if (!v58)
      {
        v59(v60, "Public URN ID %s expanded to NULL\n", v4);
        uint64_t v5 = xmlCatalogListXMLResolve(v6, 0LL, a3);
        goto LABEL_135;
      }

      v59(v60, "Public URN ID expanded to %s\n", (const char *)v58);
      uint64_t v5 = xmlCatalogListXMLResolve(v6, v58, a3);
LABEL_134:
      xmlFree(v58);
      goto LABEL_135;
    }

    uint64_t v64 = v6;
    v65 = v58;
    uint64_t v66 = a3;
    goto LABEL_133;
  }

  if (!xmlStrncmp((const xmlChar *)a3, (const xmlChar *)"urn:publicid:", 13))
  {
    v58 = xmlCatalogUnWrapURN(a3);
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v61 = *__xmlGenericError();
      uint64_t v62 = *__xmlGenericErrorContext();
      if (v58) {
        v63 = "System URN ID expanded to %s\n";
      }
      else {
        v63 = "System URN ID %s expanded to NULL\n";
      }
      v61(v62, v63);
    }

    if (!v4)
    {
      uint64_t v64 = v6;
      v65 = v58;
      goto LABEL_131;
    }

    if (xmlStrEqual((const xmlChar *)v4, v58))
    {
      uint64_t v64 = v6;
      v65 = (void *)v4;
LABEL_131:
      uint64_t v66 = 0LL;
      goto LABEL_133;
    }

    uint64_t v64 = v6;
    v65 = (void *)v4;
    uint64_t v66 = (uint64_t)v58;
LABEL_133:
    uint64_t v5 = xmlCatalogListXMLResolve(v64, v65, v66);
    if (!v58) {
      goto LABEL_135;
    }
    goto LABEL_134;
  }

  uint64_t v68 = v8;
  while (1)
  {
    if (*(_DWORD *)(v6 + 24) == 1)
    {
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        break;
      }
      xmlFetchXMLCatalogFile(v6);
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        break;
      }
    }

LABEL_114:
    uint64_t v6 = *(void *)v6;
    if (!v6)
    {
LABEL_115:
      uint64_t v5 = 0LL;
      goto LABEL_116;
    }
  }

  int v10 = *(_DWORD *)(v9 + 64);
  if (v10 >= 51)
  {
    __xmlRaiseError( 0LL,  0LL,  0LL,  (void *)v9,  0LL,  0x14u,  1654,  2,  0LL,  0,  *(const xmlChar **)(v9 + 32),  0LL,  0LL,  0,  0,  "Detected recursion in catalog %s\n",  *(void *)(v9 + 32));
    goto LABEL_113;
  }

  *(_DWORD *)(v9 + 64) = v10 + 1;
  if (a3)
  {
    int v11 = 0;
    uint64_t v12 = 0LL;
    int v13 = 0;
    int v14 = 0;
    uint64_t v15 = v9;
    while (2)
    {
      switch(*(_DWORD *)(v15 + 24))
      {
        case 3:
          ++v13;
          goto LABEL_28;
        case 6:
          if (!xmlStrEqual((const xmlChar *)a3, *(const xmlChar **)(v15 + 32))) {
            goto LABEL_28;
          }
          if (xmlDebugCatalogs)
          {
            xmlGenericErrorFunc v53 = *__xmlGenericError();
            int v54 = __xmlGenericErrorContext();
            v53(*v54, "Found system match %s, using %s\n", *(const char **)(v15 + 32), *(const char **)(v15 + 48));
          }

          --*(_DWORD *)(v9 + 64);
          v55 = *(const xmlChar **)(v15 + 48);
          goto LABEL_111;
        case 7:
          int v16 = xmlStrlen(*(const xmlChar **)(v15 + 32));
          if (v16 > v11)
          {
            int v17 = v16;
            if (!xmlStrncmp((const xmlChar *)a3, *(const xmlChar **)(v15 + 32), v16))
            {
              uint64_t v12 = v15;
              int v11 = v17;
            }
          }

          goto LABEL_28;
        case 9:
          v18 = *(const xmlChar **)(v15 + 32);
          int v19 = xmlStrlen(v18);
          if (!xmlStrncmp((const xmlChar *)a3, v18, v19)) {
            ++v14;
          }
          goto LABEL_28;
        default:
LABEL_28:
          uint64_t v15 = *(void *)v15;
          if (v15) {
            continue;
          }
          if (v12)
          {
            if (xmlDebugCatalogs)
            {
              xmlGenericErrorFunc v20 = *__xmlGenericError();
              char v21 = __xmlGenericErrorContext();
              v20(*v21, "Using rewriting rule %s\n", *(const char **)(v12 + 32));
            }

            unint64_t v22 = xmlStrdup(*(const xmlChar **)(v12 + 48));
            if (!v22)
            {
              uint64_t v5 = 0LL;
LABEL_104:
              --*(_DWORD *)(v9 + 64);
LABEL_112:
              if (v5) {
                goto LABEL_116;
              }
LABEL_113:
              goto LABEL_114;
            }

            uint64_t v23 = xmlStrcat(v22, (const xmlChar *)(a3 + v11));
LABEL_34:
            uint64_t v5 = (uint64_t)v23;
            goto LABEL_104;
          }

          if (v14)
          {
            int v43 = 0;
            __int128 v92 = 0u;
            __int128 v93 = 0u;
            __int128 v90 = 0u;
            __int128 v91 = 0u;
            __int128 v88 = 0u;
            __int128 v89 = 0u;
            __int128 v86 = 0u;
            __int128 v87 = 0u;
            __int128 v84 = 0u;
            __int128 v85 = 0u;
            __int128 v82 = 0u;
            __int128 v83 = 0u;
            __int128 v80 = 0u;
            __int128 v81 = 0u;
            __int128 v78 = 0u;
            __int128 v79 = 0u;
            __int128 v76 = 0u;
            __int128 v77 = 0u;
            __int128 v74 = 0u;
            __int128 v75 = 0u;
            __int128 v72 = 0u;
            __int128 v73 = 0u;
            __int128 v70 = 0u;
            __int128 v71 = 0u;
            uint64_t v44 = v9;
            __int128 v69 = 0u;
            while (1)
            {
              uint64_t v45 = v44;
LABEL_83:
              if (*(_DWORD *)(v45 + 24) == 9)
              {
                v46 = *(const xmlChar **)(v45 + 32);
                int v47 = xmlStrlen(v46);
                if (!xmlStrncmp((const xmlChar *)a3, v46, v47))
                {
                  if (v43 < 1)
                  {
                    uint64_t v45 = v44;
                  }

                  else
                  {
                    int v48 = (const xmlChar **)&v69;
                    uint64_t v49 = v43;
                    do
                    {
                      if (xmlStrEqual(*(const xmlChar **)(v45 + 48), *v48))
                      {
                        uint64_t v45 = *(void *)v45;
                        if (v45) {
                          goto LABEL_83;
                        }
                        goto LABEL_102;
                      }

                      ++v48;
                      --v49;
                    }

                    while (v49);
                    if (v43 > 49) {
                      goto LABEL_94;
                    }
                  }

                  *((void *)&v69 + v43++) = *(void *)(v45 + 48);
LABEL_94:
                  uint64_t v50 = *(void *)(v45 + 16);
                  if (v50 || (xmlFetchXMLCatalogFile(v45), (uint64_t v50 = *(void *)(v45 + 16)) != 0))
                  {
                    if (xmlDebugCatalogs)
                    {
                      xmlGenericErrorFunc v51 = *__xmlGenericError();
                      uint64_t v52 = __xmlGenericErrorContext();
                      v51(*v52, "Trying system delegate %s\n", *(const char **)(v45 + 48));
                      uint64_t v50 = *(void *)(v45 + 16);
                    }

                    uint64_t v23 = (xmlChar *)xmlCatalogListXMLResolve(v50, 0LL, a3);
                    if (v23) {
                      goto LABEL_34;
                    }
                  }
                }
              }

              uint64_t v44 = *(void *)v45;
              if (!*(void *)v45) {
                goto LABEL_102;
              }
            }
          }

          break;
      }

      break;
    }
  }

  else
  {
    int v13 = 0;
  }

  if (v4)
  {
    int v24 = 0;
    uint64_t v25 = v9;
    do
    {
      int v26 = *(_DWORD *)(v25 + 24);
      if (v26 == 3)
      {
        v13 += a3 == 0;
      }

      else if (v26 == 8)
      {
        int v27 = *(const xmlChar **)(v25 + 32);
        int v28 = xmlStrlen(v27);
        if (!xmlStrncmp((const xmlChar *)v4, v27, v28) && *(_DWORD *)(v25 + 56) == 1) {
          ++v24;
        }
      }

      else if (v26 == 5 && xmlStrEqual((const xmlChar *)v4, *(const xmlChar **)(v25 + 32)))
      {
        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v56 = *__xmlGenericError();
          xmlListPtr v57 = __xmlGenericErrorContext();
          v56(*v57, "Found public match %s\n", *(const char **)(v25 + 32));
        }

        --*(_DWORD *)(v9 + 64);
        v55 = *(const xmlChar **)(v25 + 48);
LABEL_111:
        uint64_t v5 = (uint64_t)xmlStrdup(v55);
        goto LABEL_112;
      }

      uint64_t v25 = *(void *)v25;
    }

    while (v25);
    if (v24)
    {
      __int128 v92 = 0u;
      __int128 v93 = 0u;
      __int128 v90 = 0u;
      __int128 v91 = 0u;
      __int128 v88 = 0u;
      __int128 v89 = 0u;
      __int128 v86 = 0u;
      __int128 v87 = 0u;
      __int128 v84 = 0u;
      __int128 v85 = 0u;
      __int128 v82 = 0u;
      __int128 v83 = 0u;
      __int128 v80 = 0u;
      __int128 v81 = 0u;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      __int128 v76 = 0u;
      __int128 v77 = 0u;
      __int128 v74 = 0u;
      __int128 v75 = 0u;
      __int128 v72 = 0u;
      __int128 v73 = 0u;
      __int128 v70 = 0u;
      __int128 v71 = 0u;
      __int128 v69 = 0u;
      int v29 = 0;
      uint64_t v30 = v9;
      while (1)
      {
        uint64_t v31 = v30;
LABEL_51:
        if (*(_DWORD *)(v31 + 24) == 8 && *(_DWORD *)(v31 + 56) == 1)
        {
          int v32 = *(const xmlChar **)(v31 + 32);
          int v33 = xmlStrlen(v32);
          if (!xmlStrncmp((const xmlChar *)v4, v32, v33))
          {
            if (v29 < 1)
            {
              uint64_t v31 = v30;
            }

            else
            {
              uint64_t v34 = (const xmlChar **)&v69;
              uint64_t v35 = v29;
              do
              {
                if (xmlStrEqual(*(const xmlChar **)(v31 + 48), *v34))
                {
                  uint64_t v31 = *(void *)v31;
                  if (v31) {
                    goto LABEL_51;
                  }
                  goto LABEL_102;
                }

                ++v34;
                --v35;
              }

              while (v35);
              if (v29 > 49) {
                goto LABEL_63;
              }
            }

            *((void *)&v69 + v29++) = *(void *)(v31 + 48);
LABEL_63:
            uint64_t v36 = *(void *)(v31 + 16);
            if (v36 || (xmlFetchXMLCatalogFile(v31), (uint64_t v36 = *(void *)(v31 + 16)) != 0))
            {
              if (xmlDebugCatalogs)
              {
                xmlGenericErrorFunc v37 = *__xmlGenericError();
                BOOL v38 = __xmlGenericErrorContext();
                v37(*v38, "Trying public delegate %s\n", *(const char **)(v31 + 48));
                uint64_t v36 = *(void *)(v31 + 16);
              }

              uint64_t v23 = (xmlChar *)xmlCatalogListXMLResolve(v36, v4, 0LL);
              if (v23) {
                goto LABEL_34;
              }
            }
          }
        }

        uint64_t v30 = *(void *)v31;
        if (!*(void *)v31)
        {
LABEL_102:
          uint64_t v5 = -1LL;
          goto LABEL_104;
        }
      }
    }
  }

  if (!v13)
  {
LABEL_79:
    --*(_DWORD *)(v9 + 64);
    goto LABEL_113;
  }

  uint64_t v39 = v9;
  while (1)
  {
    if (*(_DWORD *)(v39 + 24) == 3)
    {
      uint64_t v40 = *(void *)(v39 + 16);
      if (v40) {
        break;
      }
      xmlFetchXMLCatalogFile(v39);
      uint64_t v40 = *(void *)(v39 + 16);
      if (v40) {
        break;
      }
    }

                attributes = attributes->nexth;
                if (!attributes) {
                  goto LABEL_115;
                }
              }
            }
          }

LABEL_78:
    uint64_t v39 = *(void *)v39;
    if (!v39) {
      goto LABEL_79;
    }
  }

  uint64_t v41 = xmlCatalogListXMLResolve(v40, v4, a3);
  int v42 = *(_DWORD *)(v9 + 64);
  if (!v41)
  {
    if (v42 > 50) {
      goto LABEL_113;
    }
    goto LABEL_78;
  }

  uint64_t v5 = v41;
  *(_DWORD *)(v9 + 64) = v42 - 1;
LABEL_116:
  unsigned int v8 = v68;
LABEL_135:
  if (v8) {
    xmlFree(v8);
  }
  return v5;
}

      if (i->type != XML_ELEMENT_NODE) {
        goto LABEL_81;
      }
      properties = (xmlNode *)i->properties;
      if (!properties)
      {
LABEL_98:
        properties = i->children;
        if (!properties)
        {
LABEL_81:
          while (i != elem)
          {
            uint64_t v36 = i->type;
            if (v36 == XML_ELEMENT_NODE)
            {
              xmlGenericErrorFunc v37 = v50;
              if (v50)
              {
                BOOL v38 = *v50;
                if (*v50)
                {
                  uint64_t v40 = v50 + 1;
                  uint64_t v39 = v50[1];
                  if (!v39) {
                    goto LABEL_111;
                  }
                  do
                  {
                    if (*(_DWORD *)(v39 + 36) < v9) {
                      break;
                    }
                    uint64_t v41 = *(uint64_t **)(v39 + 8);
                    char *v40 = (uint64_t)v41;
                    if (v41) {
                      xmlGenericErrorFunc v37 = v41;
                    }
                    xmlChar *v37 = 0LL;
                    *(void *)uint64_t v39 = v50[2];
                    xmlGenericErrorFunc v37 = v50;
                    v50[2] = v39;
                    uint64_t v40 = v37 + 1;
                    uint64_t v39 = v37[1];
                  }

                  while (v39);
                  BOOL v38 = *v37;
                  if (*v37)
                  {
LABEL_111:
                    do
                    {
                      if (*(_DWORD *)(v38 + 32) >= v9) {
                        *(_DWORD *)(v38 + 32) = -1;
                      }
                      BOOL v38 = *(void *)v38;
                    }

                    while (v38);
                  }
                }
              }

              --v9;
            }

            properties = i->next;
            if (properties) {
              goto LABEL_80;
            }
            size_t i = i->parent;
            if (v36 == XML_ATTRIBUTE_NODE && i->type == XML_ELEMENT_NODE) {
              goto LABEL_98;
            }
          }

          int v43 = v49;
          if (v49)
          {
            uint64_t v44 = v48;
            if ((int)v48 >= 1)
            {
              uint64_t v45 = v49;
              do
              {
                v46 = *v45;
                v45 += 2;
                xmlFreeNs(v46);
                --v44;
              }

              while (v44);
            }

            xmlFree(v43);
          }

          if (v50) {
            xmlDOMWrapNsMapFree(v50);
          }
          return v5;
        }
      }

  BOOL v38 = 0;
LABEL_79:
  uint64_t v39 = *v31;
  if (*v31)
  {
    *(_DWORD *)(v39 + 12) = 1;
    while (1)
    {
      *(_DWORD *)(v39 + 12) = 2;
      uint64_t v40 = *(unsigned int *)(v39 + 24);
      uint64_t v41 = *(void *)(v39 + 32);
      uint64_t v39 = 0LL;
      int v42 = (_DWORD *)(v41 + 16);
      do
      {
        int v43 = *(v42 - 2);
        if ((v43 & 0x80000000) == 0 && (*((void *)v42 - 2) || (*v42 & 0x80000000) == 0))
        {
          uint64_t v44 = v31[v43];
          if (v44)
          {
            if (!*(_DWORD *)(v44 + 12))
            {
              *(_DWORD *)(v44 + 12) = 1;
              uint64_t v39 = v44;
            }
          }
        }

        v42 += 6;
        --v40;
      }

      while (v40);
      if (!v39) {
        goto LABEL_93;
      }
LABEL_99:
      if (!v39) {
        goto LABEL_100;
      }
    }

    uint64_t v39 = 0LL;
LABEL_93:
    if ((int)v2 >= 2)
    {
      uint64_t v45 = v2 - 1LL;
      v46 = v31 + 1;
      while (1)
      {
        uint64_t v39 = *v46;
        if (*v46)
        {
          if (*(_DWORD *)(v39 + 12) == 1) {
            break;
          }
        }

        ++v46;
        if (!--v45) {
          goto LABEL_100;
        }
      }
    }

    goto LABEL_99;
  }

      HIDWORD(v59) = 0;
      xmlFARegExecRollBack((int *)&v59);
      continue;
    }

    while (1)
    {
      int v10 = *(void *)(v6 + 32);
      int v11 = v10 + 24LL * v7;
      uint64_t v12 = (int *)(v11 + 8);
      if ((*(_DWORD *)(v11 + 8) & 0x80000000) != 0) {
        goto LABEL_59;
      }
      int v13 = v7;
      int v14 = v10 + 24LL * v7;
      int v17 = *(_DWORD *)(v14 + 16);
      int v16 = (_DWORD *)(v14 + 16);
      uint64_t v15 = v17;
      if ((v17 & 0x80000000) != 0)
      {
        uint64_t v23 = *(void *)v11;
        if (!*(void *)v11)
        {
          fwrite("epsilon transition left at runtime\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
          uint64_t v49 = -2;
          goto LABEL_82;
        }

        int v24 = (const xmlChar *)(v66 + (int)v65);
        if (!*v24 || (uint64_t v25 = xmlStringCurrentChar(0LL, v24, &len), (v26 = xmlRegCheckCharacter(v23, v25)) == 0))
        {
          unint64_t v22 = 1;
          HIDWORD(v62) = 1;
          len = 0;
          goto LABEL_49;
        }

        if (v26 != 1)
        {
          if ((v26 & 0x80000000) == 0) {
            goto LABEL_59;
          }
          uint64_t v49 = -4;
LABEL_82:
          LODWORD(v59) = v49;
          if (DWORD2(v62)) {
            goto LABEL_78;
          }
          goto LABEL_83;
        }

        if ((*(_DWORD *)(v23 + 12) & 0x80000000) != 0 || *(int *)(v23 + 16) < 1)
        {
          unint64_t v22 = 1;
        }

        else
        {
          xmlListPtr v57 = *(void *)(*((void *)comp + 2) + 8LL * *v12);
          int v27 = v10 + 24LL * v13;
          uint64_t v30 = *(_DWORD *)(v27 + 12);
          int v29 = (unsigned int *)(v27 + 12);
          int v28 = v30;
          if ((v30 & 0x80000000) == 0)
          {
            if (!(void)v64) {
              goto LABEL_91;
            }
            if (!v60) {
              goto LABEL_91;
            }
            uint64_t v31 = *((void *)v60 + 6);
            if (!v31) {
              goto LABEL_91;
            }
            int v32 = *(_DWORD *)(v64 + 4 * v28);
            if (v32 >= *(_DWORD *)(v31 + 8 * v28 + 4)) {
              goto LABEL_59;
            }
            *(_DWORD *)(v64 + 4 * v28) = v32 + 1;
          }

          xmlGenericErrorFunc v56 = v29;
          if (*(_DWORD *)(v62 + 24) > DWORD2(v62) + 1) {
            xmlFARegExecSave((uint64_t)&v59);
          }
          int v33 = 1;
          HIDWORD(v62) = 1;
          while (v33 != *(_DWORD *)(v23 + 16))
          {
            uint64_t v34 = v65;
            uint64_t v35 = (int)v65 + (uint64_t)len;
            LODWORD(v65) = v65 + len;
            uint64_t v36 = v66;
            if (!*(_BYTE *)(v66 + v35))
            {
              LODWORD(v65) = v34;
              break;
            }

            if (v33 >= *(_DWORD *)(v23 + 12))
            {
              xmlGenericErrorFunc v37 = DWORD2(v62);
              BOOL v38 = v62;
              DWORD2(v62) = -1;
              *(void *)&uint64_t v62 = v57;
              xmlFARegExecSave((uint64_t)&v59);
              DWORD2(v62) = v37;
              *(void *)&uint64_t v62 = v38;
              uint64_t v36 = v66;
              uint64_t v35 = (int)v65;
            }

            uint64_t v39 = xmlStringCurrentChar(0LL, (const xmlChar *)(v36 + v35), &len);
            uint64_t v40 = xmlRegCheckCharacter(v23, v39);
            int v33 = ++HIDWORD(v62);
            if (v40 != 1) {
              goto LABEL_63;
            }
          }

          uint64_t v40 = 1;
LABEL_63:
          if (v33 >= *(_DWORD *)(v23 + 12)) {
            uint64_t v44 = v40;
          }
          else {
            uint64_t v44 = 0;
          }
          if (v44 < 1) {
            goto LABEL_78;
          }
          uint64_t v45 = *v56;
          if ((v45 & 0x80000000) == 0)
          {
            if (!(void)v64) {
              goto LABEL_91;
            }
            --*(_DWORD *)(v64 + 4 * v45);
          }

          unint64_t v22 = v44 & ~(v44 >> 31);
          if (v22 != 1) {
            goto LABEL_59;
          }
        }
      }

      else
      {
        if (!(void)v64) {
          goto LABEL_91;
        }
        v18 = *(_DWORD *)(v64 + 4 * v15);
        int v19 = *((void *)v60 + 6);
        xmlGenericErrorFunc v20 = *(_DWORD *)(v19 + 8 * v15);
        if (v18 < v20) {
          goto LABEL_59;
        }
        char v21 = *(_DWORD *)(v19 + 8 * v15 + 4);
        if (v18 > v21) {
          goto LABEL_59;
        }
        unint64_t v22 = v20 == v21;
      }

          fwrite(v36, v37, 1uLL, output);
          return;
        default:
          return;
      }
    }

    uint64_t v9 = "Object is empty (NULL)\n";
LABEL_12:
    int v10 = 23LL;
LABEL_13:
    fwrite(v9, v10, 1uLL, output);
  }

xmlChar *__cdecl xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID)
{
  xmlAttrPtr result = 0LL;
  if (catal && pubID)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve pubID %s\n", (const char *)pubID);
    }

    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolve(*((void *)catal + 14), (xmlChar *)pubID, 0LL);
      if (result == (xmlChar *)-1LL) {
        return 0LL;
      }
    }

    else
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogGetSGMLPublic(*((xmlHashTable **)catal + 12), (xmlChar *)pubID);
      if (result) {
        return xmlStrdup(result);
      }
    }
  }

  return result;
}

xmlHashTable *xmlCatalogGetSGMLPublic(xmlHashTable *result, xmlChar *cur)
{
  if (result)
  {
    int v3 = result;
    xmlParserInputBufferPtr v4 = xmlCatalogNormalizePublic(cur);
    if (v4)
    {
      xmlGenericErrorFunc v5 = v4;
      if (*v4) {
        uint64_t v6 = v4;
      }
      else {
        uint64_t v6 = 0LL;
      }
      stat v7 = (xmlHashTable *)xmlHashLookup(v3, v6);
      if (!v7)
      {
        xmlFree(v5);
        return 0LL;
      }

      unsigned int v8 = v7;
      int v9 = *((_DWORD *)v7 + 6);
      xmlFree(v5);
      if (v9 != 14) {
        return 0LL;
      }
    }

    else
    {
      xmlAttrPtr result = (xmlHashTable *)xmlHashLookup(v3, cur);
      if (!result) {
        return result;
      }
      unsigned int v8 = result;
      if (*((_DWORD *)result + 6) != 14) {
        return 0LL;
      }
    }

    return (xmlHashTable *)*((void *)v8 + 6);
  }

  return result;
}

xmlChar *__cdecl xmlACatalogResolve(xmlCatalogPtr catal, const xmlChar *pubID, const xmlChar *sysID)
{
  xmlAttrPtr result = 0LL;
  if (catal && (unint64_t)pubID | (unint64_t)sysID)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v7 = *__xmlGenericError();
      unsigned int v8 = *__xmlGenericErrorContext();
      if (pubID && sysID)
      {
        int v9 = "Resolve: pubID %s sysID %s\n";
      }

      else if (pubID)
      {
        int v9 = "Resolve: pubID %s\n";
      }

      else
      {
        int v9 = "Resolve: sysID %s\n";
      }

      v7(v8, v9);
    }

    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolve(*((void *)catal + 14), (xmlChar *)pubID, (uint64_t)sysID);
      if (result == (xmlChar *)-1LL) {
        return 0LL;
      }
    }

    else
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogSGMLResolve((uint64_t)catal, (xmlChar *)pubID, (xmlChar *)sysID);
      if (result) {
        return xmlStrdup(result);
      }
    }
  }

  return result;
}

xmlHashTable *xmlCatalogSGMLResolve(uint64_t a1, xmlChar *a2, xmlChar *name)
{
  xmlAttrPtr result = *(xmlHashTable **)(a1 + 96);
  if (result)
  {
    if (!a2 || (xmlAttrPtr result = xmlCatalogGetSGMLPublic(result, a2)) == 0LL)
    {
      if (!name) {
        return 0LL;
      }
      xmlAttrPtr result = *(xmlHashTable **)(a1 + 96);
      if (result)
      {
        xmlAttrPtr result = (xmlHashTable *)xmlHashLookup(result, name);
        if (result)
        {
          if (*((_DWORD *)result + 6) == 13) {
            return (xmlHashTable *)*((void *)result + 6);
          }
          return 0LL;
        }
      }
    }
  }

  return result;
}

xmlChar *__cdecl xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI)
{
  xmlAttrPtr result = 0LL;
  if (catal && URI)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      v5(*v6, "Resolve URI %s\n", (const char *)URI);
    }

    if (*(_DWORD *)catal == 1)
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogListXMLResolveURI(*((void *)catal + 14), (const char *)URI);
      if (result == (xmlChar *)-1LL) {
        return 0LL;
      }
    }

    else
    {
      xmlAttrPtr result = (xmlChar *)xmlCatalogSGMLResolve((uint64_t)catal, 0LL, (xmlChar *)URI);
      if (result) {
        return xmlStrdup(result);
      }
    }
  }

  return result;
}

uint64_t xmlCatalogListXMLResolveURI(uint64_t a1, const char *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = a1;
  if (!xmlStrncmp((const xmlChar *)a2, (const xmlChar *)"urn:publicid:", 13))
  {
    uint64_t v34 = xmlCatalogUnWrapURN((uint64_t)a2);
    if (!xmlDebugCatalogs)
    {
      uint64_t v31 = xmlCatalogListXMLResolve(v3, v34, 0LL);
      if (!v34) {
        return v31;
      }
LABEL_70:
      xmlFree(v34);
      return v31;
    }

    xmlGenericErrorFunc v35 = *__xmlGenericError();
    uint64_t v36 = *__xmlGenericErrorContext();
    if (v34)
    {
      v35(v36, "URN ID expanded to %s\n", (const char *)v34);
      uint64_t v31 = xmlCatalogListXMLResolve(v3, v34, 0LL);
      goto LABEL_70;
    }

    v35(v36, "URN ID %s expanded to NULL\n", a2);
    return 0LL;
  }

LABEL_3:
  if (*(_DWORD *)(v3 + 24) != 1) {
    goto LABEL_56;
  }
  uint64_t v4 = *(void *)(v3 + 16);
  if (!v4)
  {
    xmlFetchXMLCatalogFile(v3);
    uint64_t v4 = *(void *)(v3 + 16);
    if (!v4) {
      goto LABEL_56;
    }
  }

  if (*(int *)(v4 + 64) > 50)
  {
    __xmlRaiseError( 0LL,  0LL,  0LL,  (void *)v4,  0LL,  0x14u,  1654,  2,  0LL,  0,  *(const xmlChar **)(v4 + 32),  0LL,  0LL,  0,  0,  "Detected recursion in catalog %s\n",  *(void *)(v4 + 32));
    goto LABEL_56;
  }

  int v5 = 0;
  uint64_t v6 = 0LL;
  int v7 = 0;
  int v8 = 0;
  uint64_t v9 = v4;
  while (2)
  {
    switch(*(_DWORD *)(v9 + 24))
    {
      case 3:
        ++v7;
        goto LABEL_19;
      case 0xA:
        if (!xmlStrEqual((const xmlChar *)a2, *(const xmlChar **)(v9 + 32))) {
          goto LABEL_19;
        }
        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v29 = *__xmlGenericError();
          uint64_t v30 = __xmlGenericErrorContext();
          v29(*v30, "Found URI match %s\n", *(const char **)(v9 + 32));
        }

        int v17 = xmlStrdup(*(const xmlChar **)(v9 + 48));
        goto LABEL_54;
      case 0xB:
        int v10 = xmlStrlen(*(const xmlChar **)(v9 + 32));
        if (v10 > v5)
        {
          int v11 = v10;
          if (!xmlStrncmp((const xmlChar *)a2, *(const xmlChar **)(v9 + 32), v10))
          {
            uint64_t v6 = v9;
            int v5 = v11;
          }
        }

        goto LABEL_19;
      case 0xC:
        uint64_t v12 = *(const xmlChar **)(v9 + 32);
        int v13 = xmlStrlen(v12);
        if (!xmlStrncmp((const xmlChar *)a2, v12, v13)) {
          ++v8;
        }
        goto LABEL_19;
      default:
LABEL_19:
        uint64_t v9 = *(void *)v9;
        if (v9) {
          continue;
        }
        if (v6)
        {
          if (xmlDebugCatalogs)
          {
            xmlGenericErrorFunc v14 = *__xmlGenericError();
            uint64_t v15 = __xmlGenericErrorContext();
            v14(*v15, "Using rewriting rule %s\n", *(const char **)(v6 + 32));
          }

          int v16 = xmlStrdup(*(const xmlChar **)(v6 + 48));
          if (!v16) {
            goto LABEL_56;
          }
          int v17 = xmlStrcat(v16, (const xmlChar *)&a2[v5]);
          goto LABEL_54;
        }

        if (v8)
        {
          int v18 = 0;
          memset(v38, 0, sizeof(v38));
          while (1)
          {
            uint64_t v19 = v4;
LABEL_28:
            int v20 = *(_DWORD *)(v19 + 24);
            if (v20 == 12 || v20 == 9)
            {
              unint64_t v22 = *(const xmlChar **)(v19 + 32);
              int v23 = xmlStrlen(v22);
              if (!xmlStrncmp((const xmlChar *)a2, v22, v23))
              {
                if (v18 < 1)
                {
                  uint64_t v19 = v4;
                }

                else
                {
                  int v24 = (const xmlChar **)v38;
                  uint64_t v25 = v18;
                  do
                  {
                    if (xmlStrEqual(*(const xmlChar **)(v19 + 48), *v24))
                    {
                      uint64_t v19 = *(void *)v19;
                      if (v19) {
                        goto LABEL_28;
                      }
                      goto LABEL_58;
                    }

                    ++v24;
                    --v25;
                  }

                  while (v25);
                  if (v18 > 49) {
                    goto LABEL_43;
                  }
                }

                *((void *)v38 + v18++) = *(void *)(v19 + 48);
LABEL_43:
                uint64_t v26 = *(void *)(v19 + 16);
                if (v26 || (xmlFetchXMLCatalogFile(v19), (uint64_t v26 = *(void *)(v19 + 16)) != 0))
                {
                  if (xmlDebugCatalogs)
                  {
                    xmlGenericErrorFunc v27 = *__xmlGenericError();
                    int v28 = __xmlGenericErrorContext();
                    v27(*v28, "Trying URI delegate %s\n", *(const char **)(v19 + 48));
                    uint64_t v26 = *(void *)(v19 + 16);
                  }

                  int v17 = (xmlChar *)xmlCatalogListXMLResolveURI(v26, a2);
                  if (v17) {
                    break;
                  }
                }
              }
            }

            uint64_t v4 = *(void *)v19;
            if (!*(void *)v19)
            {
LABEL_58:
              uint64_t v31 = -1LL;
              goto LABEL_55;
            }
          }

LABEL_54:
          uint64_t v31 = (uint64_t)v17;
LABEL_55:
          if (v31) {
            return v31;
          }
LABEL_56:
          uint64_t v3 = *(void *)v3;
          if (!v3) {
            return 0LL;
          }
          goto LABEL_3;
        }

        if (!v7) {
          goto LABEL_56;
        }
        while (1)
        {
          if (*(_DWORD *)(v4 + 24) == 3)
          {
            uint64_t v32 = *(void *)(v4 + 16);
            if (v32 || (xmlFetchXMLCatalogFile(v4), (uint64_t v32 = *(void *)(v4 + 16)) != 0))
            {
              uint64_t v33 = xmlCatalogListXMLResolveURI(v32, a2);
              if (v33) {
                return v33;
              }
            }
          }

          uint64_t v4 = *(void *)v4;
          if (!v4) {
            goto LABEL_56;
          }
        }
    }
  }

      uint64_t v4 = 0LL;
      goto LABEL_55;
    }

          uint64_t v19 = (xmlChar *)cur->name;
          if (v19)
          {
            int v20 = cur->type;
            if (v20 == XML_TEXT_NODE || v20 == XML_COMMENT_NODE) {
              goto LABEL_62;
            }
            if (!dict) {
              goto LABEL_60;
            }
            if (!xmlDictOwns(dict, v19))
            {
              uint64_t v19 = (xmlChar *)cur->name;
LABEL_60:
              xmlFree(v19);
            }
          }

          int v20 = cur->type;
LABEL_62:
          if (v20 <= XML_XINCLUDE_END && ((1 << v20) & 0x180002) != 0)
          {
            nsDef = cur->nsDef;
            if (nsDef) {
              xmlFreeNsList(nsDef);
            }
          }

          int v5 = xmlFree;
LABEL_67:
          ((void (*)(xmlNodePtr))v5)(cur);
          return;
        }

        xmlFreeNodeList(v12);
        uint64_t v9 = cur->type;
      }

      if (v9 <= XML_XINCLUDE_END && ((1 << v9) & 0x180002) != 0)
      {
        properties = cur->properties;
        if (properties)
        {
          do
          {
            next = properties->next;
            xmlFreeProp(properties);
            properties = next;
          }

          while (next);
          uint64_t v9 = cur->type;
        }
      }

      if (v9 == XML_ELEMENT_NODE) {
        goto LABEL_54;
      }
      goto LABEL_40;
    }

    psvsize_t i = (xmlChar *)cur->psvi;
    if (psvi)
    {
      if (dict)
      {
        if (xmlDictOwns(dict, psvi)) {
          goto LABEL_25;
        }
        psvsize_t i = (xmlChar *)cur->psvi;
      }

      xmlFree(psvi);
    }

      xmlAttrPtr result = xmlRegexpErrCompile(v7, (uint64_t)v8);
      goto LABEL_55;
    }

    xmlAttrPtr result = xmlFAParseCharClassEsc(v1);
LABEL_55:
    int v2 = *(const xmlChar **)(v1 + 8);
    uint64_t v3 = *v2;
  }

  while (*v2 && v3 != 45 && v3 != 93 && !*(_DWORD *)(v1 + 16));
  return result;
}

    xmlSchemaPIllegalAttrErr((_DWORD *)a1, v25);
    goto LABEL_57;
  }

  if (!v9 && !*(void *)(v5 + 56)) {
    xmlSchemaPCustomErrExt( a1,  3007,  0LL,  a3,  (const xmlChar *)"Either the attribute 'memberTypes' or at least one <simpleType> child must be present");
  }
}

  uint64_t v30 = *v4;
  if ((int)*v4 >= 1)
  {
    uint64_t v31 = 0LL;
    do
    {
      uint64_t v32 = (void *)*((void *)v13 + v31);
      if (v32)
      {
        xmlFree(v32);
        uint64_t v30 = *v4;
      }

      ++v31;
    }

    while (v31 < v30);
  }

  xmlFree(v9);
  xmlFree(v13);
  xmlFree(v11);
  xmlFree(v15);
  return v21;
}

void xmlACatalogDump(xmlCatalogPtr catal, FILE *out)
{
  if (catal && out)
  {
    if (*(_DWORD *)catal == 1)
    {
      uint64_t v3 = (xmlNode *)*((void *)catal + 14);
      uint64_t v4 = xmlNewDoc(0LL);
      if (v4)
      {
        int v5 = (xmlNode *)v4;
        uint64_t v6 = (xmlNode *)xmlNewDtd( v4,  (const xmlChar *)"catalog",  (const xmlChar *)"-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN",  (const xmlChar *)"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd");
        xmlAddChild(v5, v6);
        int v7 = xmlNewNs(0LL, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog", 0LL);
        if (v7)
        {
          int v8 = v7;
          xmlNodePtr v9 = xmlNewDocNode((xmlDocPtr)v5, v7, (const xmlChar *)"catalog", 0LL);
          if (v9)
          {
            int v10 = v9;
            v9->nsDef = v8;
            xmlAddChild(v5, v9);
            xmlDumpXMLCatalogNode(v3, v10, (xmlDoc *)v5, v8, 0LL);
            File = xmlOutputBufferCreateFile(out, 0LL);
            if (File) {
              xmlSaveFormatFileTo(File, (xmlDocPtr)v5, 0LL, 1);
            }
          }

          else
          {
            xmlFreeNs(v8);
          }
        }

        xmlFreeDoc((xmlDocPtr)v5);
      }
    }

    else
    {
      xmlHashScan(*((xmlHashTablePtr *)catal + 12), (xmlHashScanner)xmlCatalogDumpEntry, out);
    }
  }

uint64_t xmlCatalogDumpEntry(uint64_t result, FILE *__stream)
{
  if (result && __stream)
  {
    uint64_t v3 = result;
    switch(*(_DWORD *)(result + 24))
    {
      case 0xD:
        uint64_t v4 = "SYSTEM ";
        goto LABEL_8;
      case 0xE:
        uint64_t v4 = "PUBLIC ";
        goto LABEL_8;
      case 0xF:
        uint64_t v4 = "ENTITY ";
LABEL_8:
        size_t v5 = 7LL;
        goto LABEL_20;
      case 0x10:
        fprintf(__stream, "ENTITY %%");
        goto LABEL_21;
      case 0x11:
        uint64_t v4 = "DOCTYPE ";
        goto LABEL_16;
      case 0x12:
        uint64_t v4 = "LINKTYPE ";
        goto LABEL_19;
      case 0x13:
        uint64_t v4 = "NOTATION ";
        goto LABEL_19;
      case 0x14:
        uint64_t v4 = "DELEGATE ";
        goto LABEL_19;
      case 0x15:
        uint64_t v4 = "BASE ";
        size_t v5 = 5LL;
        goto LABEL_20;
      case 0x16:
        uint64_t v4 = "CATALOG ";
LABEL_16:
        size_t v5 = 8LL;
        goto LABEL_20;
      case 0x17:
        uint64_t v4 = "DOCUMENT ";
        goto LABEL_19;
      case 0x18:
        uint64_t v4 = "SGMLDECL ";
LABEL_19:
        size_t v5 = 9LL;
LABEL_20:
        fwrite(v4, v5, 1uLL, __stream);
LABEL_21:
        unsigned int v6 = *(_DWORD *)(v3 + 24);
        if (v6 <= 0x18)
        {
          int v7 = 1 << v6;
          if ((v7 & 0x1F06000) != 0)
          {
            fprintf(__stream, "%s", *(const char **)(v3 + 32));
          }

          else if ((v7 & 0xF8000) != 0)
          {
            fputs(*(const char **)(v3 + 32), __stream);
          }
        }

        xmlAttrPtr result = fputc(10, __stream);
        break;
      default:
        return result;
    }
  }

  return result;
}

int xmlACatalogAdd(xmlCatalogPtr catal, const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
{
  if (!catal) {
    goto LABEL_77;
  }
  if (*(_DWORD *)catal != 1)
  {
    if (xmlStrEqual(type, (const xmlChar *)"SYSTEM"))
    {
      int v12 = 13;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"PUBLIC"))
    {
      int v12 = 14;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"DELEGATE"))
    {
      int v12 = 20;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"ENTITY"))
    {
      int v12 = 15;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"DOCTYPE"))
    {
      int v12 = 17;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"LINKTYPE"))
    {
      int v12 = 18;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"NOTATION"))
    {
      int v12 = 19;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"SGMLDECL"))
    {
      int v12 = 24;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"DOCUMENT"))
    {
      int v12 = 23;
    }

    else if (xmlStrEqual(type, (const xmlChar *)"CATALOG"))
    {
      int v12 = 22;
    }

    else
    {
      if (!xmlStrEqual(type, (const xmlChar *)"BASE"))
      {
LABEL_77:
        LODWORD(v15) = -1;
        return (int)v15;
      }

      int v12 = 21;
    }

    int v13 = xmlNewCatalogEntry(v12, (xmlChar *)orig, replace, 0LL, 0, 0LL);
    xmlGenericErrorFunc v14 = (xmlHashTable *)*((void *)catal + 12);
    if (!v14)
    {
      xmlGenericErrorFunc v14 = xmlHashCreate(10);
      *((void *)catal + 12) = v14;
    }

    LODWORD(v15) = xmlHashAddEntry(v14, orig, v13);
    return (int)v15;
  }

  uint64_t v8 = *((void *)catal + 14);
  xmlNodePtr v9 = (uint64_t *)(v8 + 16);
  uint64_t v10 = *(void *)(v8 + 16);
  if (!v10)
  {
    xmlFetchXMLCatalogFile(v8);
    uint64_t v10 = *(void *)(v8 + 16);
  }

  if (xmlStrEqual(type, (const xmlChar *)"system"))
  {
    int v11 = 6;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"public"))
  {
    int v11 = 5;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"rewriteSystem"))
  {
    int v11 = 7;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"delegatePublic"))
  {
    int v11 = 8;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"delegateSystem"))
  {
    int v11 = 9;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"uri"))
  {
    int v11 = 10;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"rewriteURI"))
  {
    int v11 = 11;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"delegateURI"))
  {
    int v11 = 12;
    goto LABEL_52;
  }

  if (xmlStrEqual(type, (const xmlChar *)"nextCatalog"))
  {
    int v11 = 3;
    goto LABEL_52;
  }

  if (!xmlStrEqual(type, (const xmlChar *)"catalog"))
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v28 = *__xmlGenericError();
      xmlGenericErrorFunc v29 = __xmlGenericErrorContext();
      v28(*v29, "Failed to add unknown element %s to catalog\n", (const char *)type);
    }

    goto LABEL_77;
  }

  int v11 = 1;
LABEL_52:
  uint64_t v16 = *v9;
  if (*v9)
  {
    while (1)
    {
      int v17 = (void *)v16;
      if (orig)
      {
        if (*(_DWORD *)(v16 + 24) == v11 && xmlStrEqual(orig, *(const xmlChar **)(v16 + 32))) {
          break;
        }
      }

      uint64_t v16 = *v17;
      if (!*v17) {
        goto LABEL_59;
      }
    }

    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v23 = *__xmlGenericError();
      int v24 = __xmlGenericErrorContext();
      v23(*v24, "Updating element %s to catalog\n", (const char *)type);
    }

    uint64_t v25 = (void *)v17[5];
    if (v25) {
      xmlFree(v25);
    }
    uint64_t v26 = (void *)v17[6];
    if (v26) {
      xmlFree(v26);
    }
    v17[5] = xmlStrdup(replace);
    xmlGenericErrorFunc v27 = xmlStrdup(replace);
    LODWORD(v15) = 0;
    v17[6] = v27;
  }

  else
  {
    int v17 = 0LL;
LABEL_59:
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v18 = *__xmlGenericError();
      uint64_t v19 = __xmlGenericErrorContext();
      v18(*v19, "Adding element %s to catalog\n", (const char *)type);
    }

    int v20 = xmlNewCatalogEntry(v11, (xmlChar *)orig, replace, 0LL, *(_DWORD *)(v8 + 56), 0LL);
    if (v17) {
      char v21 = v17;
    }
    else {
      char v21 = (void *)(v8 + 16);
    }
    *char v21 = v20;
    if (v10)
    {
      LODWORD(v15) = 0;
    }

    else
    {
      *(_DWORD *)(v8 + 24) = 1;
      uint64_t v15 = xmlHashLookup((xmlHashTablePtr)xmlCatalogXMLFiles, *(const xmlChar **)(v8 + 48));
      if (v15)
      {
        unint64_t v22 = v15;
        LODWORD(v15) = 0;
        v22[2] = *v9;
      }
    }
  }

  return (int)v15;
}

int xmlACatalogRemove(xmlCatalogPtr catal, const xmlChar *value)
{
  int result = -1;
  if (catal && value)
  {
    if (*(_DWORD *)catal == 1)
    {
      uint64_t v5 = *((void *)catal + 14);
      if (v5 && (*(_DWORD *)(v5 + 24) - 1) <= 1)
      {
        unsigned int v6 = *(uint64_t **)(v5 + 16);
        if (v6 || (xmlFetchXMLCatalogFile(v5), (unsigned int v6 = *(uint64_t **)(v5 + 16)) != 0LL))
        {
          do
          {
            int v7 = (const xmlChar *)v6[4];
            if (v7 && xmlStrEqual(value, v7) || xmlStrEqual(value, (const xmlChar *)v6[5]))
            {
              if (xmlDebugCatalogs)
              {
                uint64_t v8 = v6[4];
                xmlGenericErrorFunc v9 = *__xmlGenericError();
                uint64_t v10 = *__xmlGenericErrorContext();
                if (v8) {
                  uint64_t v11 = 4LL;
                }
                else {
                  uint64_t v11 = 5LL;
                }
                v9(v10, "Removing element %s from catalog\n", (const char *)v6[v11]);
              }

              *((_DWORD *)v6 + 6) = -1;
            }

            unsigned int v6 = (uint64_t *)*v6;
          }

          while (v6);
        }

        return 0;
      }
    }

    else
    {
      int result = xmlHashRemoveEntry(*((xmlHashTablePtr *)catal + 12), value, (xmlHashDeallocator)xmlFreeCatalogEntry);
    }
  }

  return result;
}

xmlCatalogPtr xmlNewCatalog(int sgml)
{
  if (!sgml) {
    return (xmlCatalogPtr)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  }
  NewCatalog = (xmlCatalog *)xmlCreateNewCatalog(2, xmlCatalogDefaultPrefer);
  int v2 = NewCatalog;
  if (NewCatalog)
  {
    if (!*((void *)NewCatalog + 12)) {
      *((void *)NewCatalog + 12) = xmlHashCreate(10);
    }
  }

  return v2;
}

int xmlCatalogIsEmpty(xmlCatalogPtr catal)
{
  if (!catal) {
    return -1;
  }
  if (*(_DWORD *)catal == 1)
  {
    uint64_t v1 = *((void *)catal + 14);
    if (v1)
    {
      else {
        return *(void *)(v1 + 16) == 0LL;
      }
    }

    return 1;
  }

  uint64_t v3 = (xmlHashTable *)*((void *)catal + 12);
  if (!v3) {
    return 1;
  }
  int v4 = xmlHashSize(v3);
  if (v4) {
    return v4 >> 31;
  }
  else {
    return 1;
  }
}

void xmlInitializeCatalog(void)
{
  v0 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    v0 = (xmlRMutex *)xmlCatalogMutex;
  }

  xmlRMutexLock(v0);
  if (getenv("XML_DEBUG_CATALOG")) {
    xmlDebugCatalogs = 1;
  }
  if (!xmlDefaultCatalog)
  {
    uint64_t v1 = getenv("XML_CATALOG_FILES");
    NewCatalog = xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
    if (NewCatalog)
    {
      uint64_t v3 = (uint64_t)NewCatalog;
      if (!v1) {
        uint64_t v1 = "file:///etc/xml/catalog";
      }
      unsigned int v4 = *v1;
      if (*v1)
      {
        uint64_t v5 = NewCatalog + 7;
        do
        {
          unsigned int v6 = v1;
          while (v4 <= 0x20)
          {
            if (((1LL << v4) & 0x100002600LL) == 0)
            {
              if (!v4) {
                goto LABEL_24;
              }
              break;
            }

            unsigned int v7 = *++v1;
            unsigned int v4 = v7;
            ++v6;
          }

          uint64_t v8 = 0LL;
          while (v4 > 0x20 || ((1LL << v4) & 0x100002601LL) == 0)
            unsigned int v4 = v1[++v8];
          xmlGenericErrorFunc v9 = xmlStrndup((const xmlChar *)v1, v8);
          v1 += v8;
          if (v9)
          {
            uint64_t v10 = v9;
            uint64_t v11 = xmlNewCatalogEntry(1, 0LL, 0LL, v9, xmlCatalogDefaultPrefer, 0LL);
            *uint64_t v5 = v11;
            if (v11) {
              uint64_t v5 = v11;
            }
            xmlFree(v10);
          }

LABEL_24:
          unsigned int v4 = *v1;
        }

        while (*v1);
      }

      xmlDefaultCatalog = v3;
    }
  }

  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
}

  ctxt->dictNames = 0;
  return result;
}

    int v12 = *(void *)(a1 + 56);
    int v13 = *(_BYTE **)(v12 + 32);
    xmlGenericErrorFunc v14 = &v13[v11];
    if ((unint64_t)v14 <= *(void *)(v12 + 40))
    {
      if (*v13 == 10)
      {
        ++*(_DWORD *)(v12 + 52);
        *(_DWORD *)(v12 + 56) = 1;
      }

      else
      {
        ++*(_DWORD *)(v12 + 56);
      }

      *(_DWORD *)(a1 + 276) = 0;
      *(void *)(v12 + 32) = v14;
      ++*(void *)(a1 + 312);
    }

    if ((int)v6 >= 1000)
    {
      v20[v6] = 0;
      uint64_t v15 = *(void (**)(void, xmlChar *, uint64_t))(*(void *)a1 + 200LL);
      unsigned int v6 = 0LL;
    }

    if (!*(_DWORD *)(a1 + 452))
    {
      uint64_t v16 = *(xmlParserInput **)(a1 + 56);
      if (v16->end - v16->cur <= 249) {
        xmlParserInputGrow(v16, 250);
      }
    }

    int result = htmlCurrentChar(a1, &len);
    uint64_t v5 = result;
  }

  if ((_DWORD)v6)
  {
    int v17 = *(void *)a1;
    if (*(void *)a1)
    {
      if (!*(_DWORD *)(a1 + 332))
      {
        v20[(int)v6] = 0;
        xmlGenericErrorFunc v18 = *(uint64_t (**)(void, xmlChar *, uint64_t))(v17 + 200);
        if (v18) {
          return v18(*(void *)(a1 + 8), v20, v6);
        }
        xmlGenericErrorFunc v18 = *(uint64_t (**)(void, xmlChar *, uint64_t))(v17 + 136);
        if (v18) {
          return v18(*(void *)(a1 + 8), v20, v6);
        }
      }
    }
  }

  return result;
}

  v5->ns = v9;
LABEL_25:
  int v17 = *(xmlDtd **)(a3 + 24);
  if (v17)
  {
    xmlGenericErrorFunc v18 = xmlStaticCopyNodeList(v17, (uint64_t)v5->doc, (xmlNodePtr)v5);
    v5->children = v18;
    v5->last = 0LL;
    if (v18)
    {
      do
      {
        uint64_t v19 = v18;
        xmlGenericErrorFunc v18 = v18->next;
      }

      while (v18);
      v5->last = v19;
    }
  }

  if (a2)
  {
    if (*(void *)(a2 + 64))
    {
      int v20 = *(xmlDoc **)(a3 + 64);
      if (v20)
      {
        if (v20->ids)
        {
          char v21 = *(xmlNode **)(a3 + 40);
          if (v21)
          {
            if (xmlIsID(v20, v21, (xmlAttrPtr)a3))
            {
              StringInternal = xmlNodeListGetStringInternal(*(xmlDoc **)(a3 + 64), *(void *)(a3 + 24), 1, 0);
              if (StringInternal)
              {
                xmlGenericErrorFunc v23 = StringInternal;
                xmlAddID(0LL, *(xmlDocPtr *)(a2 + 64), StringInternal, v5);
                xmlFree(v23);
              }
            }
          }
        }
      }
    }
  }

  return v5;
}

        DtdAttrDesc = 0LL;
      }
    }

      DtdAttrDesc = 0LL;
    }
  }

  if ((v7 & 0xFFFFFFFD) == 1)
  {
    xmlGenericErrorFunc v14 = xmlCatalogResolveURI(v8);
    if (v14)
    {
LABEL_26:
      xmlFree(v8);
      return v14;
    }
  }

  return v8;
}

          *((void *)reader + 15) = v9;
          return 1;
        }
      }
    }
  }

  return result;
}

    xmlSchemaPIllegalAttrErr((_DWORD *)a1, v15);
    goto LABEL_28;
  }

    if (*a3)
    {
      if (v13)
      {
        int v17 = xmlStrcat(*a3, (const xmlChar *)" ");
        *a3 = v17;
        xmlGenericErrorFunc v18 = xmlStrcat(v17, v13);
        goto LABEL_32;
      }
    }

    else
    {
      if (v13)
      {
        uint64_t v19 = v13;
        goto LABEL_31;
      }

      if (!Next) {
        goto LABEL_30;
      }
    }

  uint64_t v10 = *__xmlGenericError();
  uint64_t v11 = __xmlGenericErrorContext();
  v10(*v11, "xmlXPathRunEval: last is less than zero\n");
  return 0xFFFFFFFFLL;
}

    if (++v12 >= *user) {
      goto LABEL_25;
    }
  }

  xmlGenericErrorFunc v14 = *(void *)(v13 + 40);
  if (!v14) {
    goto LABEL_24;
  }
  if ((*(_DWORD *)(v14 + 8) | 0x10) != 0x12)
  {
LABEL_22:
    uint64_t v15 = (xmlXPathObject *)xmlXPtrNewPoint(v14, *(_DWORD *)(v13 + 48));
    if (v15) {
      xmlXPtrLocationSetAdd(v10, v15);
    }
    goto LABEL_24;
  }

  xmlXPathFreeObject(v7);
  xmlXPtrFreeLocationSet(v10);
  ctxt = v2;
  int v17 = 16;
LABEL_32:
  xmlXPathErr(ctxt, v17);
}

int xmlLoadCatalog(const char *filename)
{
  int v2 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    int v2 = (xmlRMutex *)xmlCatalogMutex;
  }

  xmlRMutexLock(v2);
  if (xmlDefaultCatalog)
  {
    int v3 = xmlExpandCatalog(xmlDefaultCatalog, (char *)filename);
  }

  else
  {
    xmlCatalogPtr ACatalog = xmlLoadACatalog(filename);
    if (ACatalog)
    {
      int v3 = 0;
      xmlDefaultCatalog = (uint64_t)ACatalog;
    }

    else
    {
      int v3 = -1;
    }
  }

  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v3;
}

uint64_t xmlExpandCatalog(uint64_t a1, char *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 == 2)
  {
    FileContent = xmlLoadFileContent(a2);
    if (FileContent)
    {
      uint64_t v5 = FileContent;
      int v6 = xmlParseSGMLCatalog(a1, (int)FileContent, (xmlChar *)a2);
      xmlFree(v5);
      return (v6 >> 31);
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    uint64_t v8 = xmlNewCatalogEntry(1, 0LL, 0LL, (xmlChar *)a2, xmlCatalogDefaultPrefer, 0LL);
    xmlGenericErrorFunc v9 = *(void **)(a1 + 112);
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        xmlGenericErrorFunc v9 = (void *)*v9;
      }

      while (v9);
      uint64_t result = 0LL;
      *uint64_t v10 = v8;
    }

    else
    {
      uint64_t result = 0LL;
      *(void *)(a1 + 112) = v8;
    }
  }

  return result;
}

void xmlLoadCatalogs(const char *paths)
{
  if (paths)
  {
    uint64_t v1 = paths;
    unsigned int v2 = *(unsigned __int8 *)paths;
    if (*paths)
    {
      while (v2 <= 0x20)
      {
        if (((1LL << v2) & 0x100002600LL) != 0)
        {
          unsigned int v3 = *(unsigned __int8 *)++v1;
          unsigned int v2 = v3;
        }

        else
        {
          if (v2) {
            break;
          }
LABEL_13:
          --v1;
          do
          {
            unsigned int v7 = *(unsigned __int8 *)++v1;
            unsigned int v2 = v7;
          }

          while (v7 == 58);
          if (!v2) {
            return;
          }
        }
      }

      uint64_t v4 = 0LL;
      while (v2 > 0x3A || ((1LL << v2) & 0x400000100002601LL) == 0)
        unsigned int v2 = v1[++v4];
      uint64_t v5 = xmlStrndup((const xmlChar *)v1, v4);
      v1 += v4;
      if (v5)
      {
        int v6 = v5;
        xmlLoadCatalog((const char *)v5);
        xmlFree(v6);
      }

      goto LABEL_13;
    }
  }

void xmlCatalogCleanup(void)
{
  if (xmlCatalogMutex)
  {
    xmlRMutexLock((xmlRMutexPtr)xmlCatalogMutex);
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v0 = *__xmlGenericError();
      uint64_t v1 = __xmlGenericErrorContext();
      v0(*v1, "Catalogs cleanup\n");
    }

    if (xmlCatalogXMLFiles) {
      xmlHashFree((xmlHashTablePtr)xmlCatalogXMLFiles, (xmlHashDeallocator)xmlFreeCatalogHashEntryList);
    }
    xmlCatalogXMLFiles = 0LL;
    if (xmlDefaultCatalog) {
      xmlFreeCatalog((xmlCatalogPtr)xmlDefaultCatalog);
    }
    xmlDefaultCatalog = 0LL;
    xmlDebugCatalogs = 0;
    xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  }

void xmlFreeCatalogHashEntryList(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2)
    {
      do
      {
        uint64_t v3 = *(void *)v2;
        *(_DWORD *)(v2 + 60) = 0;
        *(void *)(v2 + 16) = 0LL;
        xmlFreeCatalogEntry(v2);
        uint64_t v2 = v3;
      }

      while (v3);
    }

    *(_DWORD *)(a1 + 60) = 0;
    xmlFreeCatalogEntry(a1);
  }

xmlChar *__cdecl xmlCatalogResolveSystem(const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  return xmlACatalogResolveSystem((xmlCatalogPtr)xmlDefaultCatalog, sysID);
}

xmlChar *__cdecl xmlCatalogResolvePublic(const xmlChar *pubID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  return xmlACatalogResolvePublic((xmlCatalogPtr)xmlDefaultCatalog, pubID);
}

xmlChar *__cdecl xmlCatalogResolve(const xmlChar *pubID, const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  return xmlACatalogResolve((xmlCatalogPtr)xmlDefaultCatalog, pubID, sysID);
}

xmlChar *__cdecl xmlCatalogResolveURI(const xmlChar *URI)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  return xmlACatalogResolveURI((xmlCatalogPtr)xmlDefaultCatalog, URI);
}

void xmlCatalogDump(FILE *out)
{
  if (out)
  {
    if (!xmlCatalogMutex) {
      xmlInitializeCatalog();
    }
    xmlACatalogDump((xmlCatalogPtr)xmlDefaultCatalog, out);
  }

int xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
{
  int v6 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    pthread_once(&once_control, (void (*)(void))_xmlInitializeCatalogData);
    int v6 = (xmlRMutex *)xmlCatalogMutex;
  }

  xmlRMutexLock(v6);
  unsigned int v7 = (xmlCatalog *)xmlDefaultCatalog;
  if (xmlDefaultCatalog) {
    goto LABEL_4;
  }
  if (!xmlStrEqual(type, (const xmlChar *)"catalog"))
  {
    unsigned int v7 = (xmlCatalog *)xmlDefaultCatalog;
LABEL_4:
    int v8 = xmlACatalogAdd(v7, type, orig, replace);
    goto LABEL_5;
  }

  xmlDefaultCatalog = (uint64_t)xmlCreateNewCatalog(1, xmlCatalogDefaultPrefer);
  if (xmlDefaultCatalog)
  {
    uint64_t v10 = xmlNewCatalogEntry(1, 0LL, orig, 0LL, xmlCatalogDefaultPrefer, 0LL);
    int v8 = 0;
    *(void *)(xmlDefaultCatalog + 112) = v10;
  }

  else
  {
    int v8 = 0;
  }

LABEL_5:
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v8;
}
  }

  xmlGenericErrorFunc v9 = (xmlDtd *)xmlMalloc(0x80uLL);
  uint64_t v10 = v9;
  if (!v9)
  {
    __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"building internal subset");
    return v10;
  }

  *(_OWORD *)&v9->entities = 0u;
  *(_OWORD *)&v9->SystemID = 0u;
  *(_OWORD *)&v9->doc = 0u;
  *(_OWORD *)&v9->elements = 0u;
  *(_OWORD *)&v9->last = 0u;
  *(_OWORD *)&v9->next = 0u;
  *(_OWORD *)&v9->_private = 0u;
  *(_OWORD *)&v9->name = 0u;
  v9->xmlElementType type = XML_DTD_NODE;
  if (name)
  {
    uint64_t v11 = xmlStrdup(name);
    v10->name = v11;
    if (!v11)
    {
      __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"building internal subset");
      goto LABEL_24;
    }
  }

  if (ExternalID)
  {
    int v12 = xmlStrdup(ExternalID);
    v10->ExternalID = v12;
    if (!v12)
    {
      __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"building internal subset");
      int v17 = (xmlChar *)v10->name;
      if (v17) {
LABEL_23:
      }
        xmlFree(v17);
LABEL_24:
      xmlFree(v10);
      return 0LL;
    }
  }

  if (SystemID)
  {
    int v13 = xmlStrdup(SystemID);
    v10->SystemID = v13;
    if (!v13)
    {
      __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"building internal subset");
      uint64_t v19 = (xmlChar *)v10->name;
      if (v19) {
        xmlFree(v19);
      }
      int v17 = (xmlChar *)v10->ExternalID;
      if (!v17) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }

  if (doc)
  {
    doc->intSubset = v10;
    v10->parent = doc;
    v10->doc = doc;
    p_children = &doc->children;
    uint64_t v15 = doc->children;
    if (v15)
    {
      if (doc->type == XML_HTML_DOCUMENT_NODE)
      {
        v15->prev = (_xmlNode *)v10;
        v10->next = v15;
      }

      else
      {
        while (v15->type != XML_ELEMENT_NODE)
        {
          uint64_t v15 = v15->next;
          if (!v15)
          {
            last = doc->last;
            last->next = (_xmlNode *)v10;
            v10->next = 0LL;
            v10->prev = last;
            p_children = &doc->last;
            goto LABEL_35;
          }
        }

        v10->next = v15;
        prev = v15->prev;
        p_prev = &v15->prev;
        v10->prev = prev;
        p_next = &prev->next;
        if (prev) {
          p_children = p_next;
        }
        *p_children = (_xmlNode *)v10;
        p_children = p_prev;
      }
    }

    else
    {
      doc->children = (_xmlNode *)v10;
      p_children = &doc->last;
    }

int xmlCatalogRemove(const xmlChar *value)
{
  uint64_t v2 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    xmlInitializeCatalog();
    uint64_t v2 = (xmlRMutex *)xmlCatalogMutex;
  }

  xmlRMutexLock(v2);
  int v3 = xmlACatalogRemove((xmlCatalogPtr)xmlDefaultCatalog, value);
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v3;
}

int xmlCatalogConvert(void)
{
  xmlGenericErrorFunc v0 = (xmlRMutex *)xmlCatalogMutex;
  if (!xmlCatalogMutex)
  {
    xmlInitializeCatalog();
    xmlGenericErrorFunc v0 = (xmlRMutex *)xmlCatalogMutex;
  }

  xmlRMutexLock(v0);
  int v1 = xmlConvertSGMLCatalog((xmlCatalogPtr)xmlDefaultCatalog);
  xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  return v1;
}

xmlCatalogAllow xmlCatalogGetDefaults(void)
{
  return xmlCatalogDefaultAllow;
}

void xmlCatalogSetDefaults(xmlCatalogAllow allow)
{
  if (xmlDebugCatalogs) {
    BOOL v2 = allow > XML_CATA_ALLOW_ALL;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    int v3 = (&off_189B9B780)[allow];
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, v3);
  }

  xmlCatalogDefaultAllow = allow;
}

xmlCatalogPrefer xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer)
{
  xmlCatalogPrefer v1 = xmlCatalogDefaultPrefer;
  if (prefer)
  {
    if (!xmlDebugCatalogs)
    {
LABEL_8:
      xmlCatalogDefaultPrefer = prefer;
      return v1;
    }

    if (prefer == XML_CATA_PREFER_PUBLIC)
    {
      int v3 = "Setting catalog preference to PUBLIC\n";
      goto LABEL_7;
    }

    if (prefer == XML_CATA_PREFER_SYSTEM)
    {
      int v3 = "Setting catalog preference to SYSTEM\n";
LABEL_7:
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      uint64_t v5 = __xmlGenericErrorContext();
      v4(*v5, v3);
      goto LABEL_8;
    }
  }

  return v1;
}

int xmlCatalogSetDebug(int level)
{
  int v1 = xmlDebugCatalogs;
  xmlDebugCatalogs = level & ~(level >> 31);
  return v1;
}

void xmlCatalogFreeLocal(void *catalogs)
{
  int v1 = catalogs;
  if (xmlCatalogMutex)
  {
    if (!catalogs) {
      return;
    }
  }

  else
  {
    xmlInitializeCatalog();
    if (!v1) {
      return;
    }
  }

  do
  {
    BOOL v2 = (void *)*v1;
    xmlFreeCatalogEntry((uint64_t)v1);
    int v1 = v2;
  }

  while (v2);
}

void *__cdecl xmlCatalogAddLocal(void *catalogs, const xmlChar *URL)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (URL)
  {
    if (xmlDebugCatalogs)
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      uint64_t v5 = __xmlGenericErrorContext();
      v4(*v5, "Adding document catalog %s\n", (const char *)URL);
    }

    int v6 = xmlNewCatalogEntry(1, 0LL, URL, 0LL, xmlCatalogDefaultPrefer, 0LL);
    if (v6)
    {
      if (catalogs)
      {
        unsigned int v7 = catalogs;
        do
        {
          int v8 = v7;
          unsigned int v7 = (void *)*v7;
        }

        while (v7);
        *int v8 = v6;
      }

      else
      {
        return v6;
      }
    }
  }

  return catalogs;
}

xmlChar *__cdecl xmlCatalogLocalResolve(void *catalogs, const xmlChar *pubID, const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (xmlDebugCatalogs)
  {
    xmlGenericErrorFunc v6 = *__xmlGenericError();
    unsigned int v7 = *__xmlGenericErrorContext();
    if (pubID && sysID)
    {
      int v8 = "Local Resolve: pubID %s sysID %s\n";
    }

    else if (pubID)
    {
      int v8 = "Local Resolve: pubID %s\n";
    }

    else
    {
      int v8 = "Local Resolve: sysID %s\n";
    }

    v6(v7, v8);
  }

  if (!catalogs) {
    return 0LL;
  }
  uint64_t result = (xmlChar *)xmlCatalogListXMLResolve((uint64_t)catalogs, (xmlChar *)pubID, (uint64_t)sysID);
  return result;
}

xmlChar *__cdecl xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI)
{
  if (xmlCatalogMutex)
  {
    if (!URI) {
      return 0LL;
    }
  }

  else
  {
    xmlInitializeCatalog();
    if (!URI) {
      return 0LL;
    }
  }

  if (xmlDebugCatalogs)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "Resolve URI %s\n", (const char *)URI);
  }

  if (!catalogs) {
    return 0LL;
  }
  uint64_t result = (xmlChar *)xmlCatalogListXMLResolveURI((uint64_t)catalogs, (const char *)URI);
  return result;
}

const xmlChar *__cdecl xmlCatalogGetSystem(const xmlChar *sysID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (!xmlCatalogGetSystem_msg)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated xmlCatalogGetSystem() call\n");
    ++xmlCatalogGetSystem_msg;
  }

  if (sysID)
  {
    if (!xmlDefaultCatalog) {
      return 0LL;
    }
    xmlGenericErrorFunc v4 = (const char *)xmlCatalogListXMLResolve(*(void *)(xmlDefaultCatalog + 112), 0LL, (uint64_t)sysID);
    if ((unint64_t)(v4 + 1) >= 2)
    {
      sysID = (const xmlChar *)xmlCatalogGetSystem_result;
      snprintf(xmlCatalogGetSystem_result, 0x3E7uLL, "%s", v4);
      byte_18C57FD6F = 0;
      return sysID;
    }

    if (xmlDefaultCatalog
      && (uint64_t v5 = *(xmlHashTable **)(xmlDefaultCatalog + 96)) != 0LL
      && (xmlGenericErrorFunc v6 = xmlHashLookup(v5, sysID)) != 0LL
      && *((_DWORD *)v6 + 6) == 13)
    {
      return (const xmlChar *)*((void *)v6 + 6);
    }

    else
    {
      return 0LL;
    }
  }

  return sysID;
}

const xmlChar *__cdecl xmlCatalogGetPublic(const xmlChar *pubID)
{
  if (!xmlCatalogMutex) {
    xmlInitializeCatalog();
  }
  if (xmlCatalogGetPublic_msg)
  {
    if (!pubID) {
      return pubID;
    }
  }

  else
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated xmlCatalogGetPublic() call\n");
    ++xmlCatalogGetPublic_msg;
    if (!pubID) {
      return pubID;
    }
  }

  if (xmlDefaultCatalog)
  {
    xmlGenericErrorFunc v4 = (const char *)xmlCatalogListXMLResolve(*(void *)(xmlDefaultCatalog + 112), (xmlChar *)pubID, 0LL);
    if ((unint64_t)(v4 + 1) >= 2)
    {
      pubID = (const xmlChar *)xmlCatalogGetPublic_result;
      snprintf(xmlCatalogGetPublic_result, 0x3E7uLL, "%s", v4);
      byte_18C58015B = 0;
      return pubID;
    }

    if (xmlDefaultCatalog) {
      return (const xmlChar *)xmlCatalogGetSGMLPublic(*(xmlHashTable **)(xmlDefaultCatalog + 96), (xmlChar *)pubID);
    }
  }

  return 0LL;
}

uint64_t xmlCatalogErrMemory(uint64_t a1)
{
  return __xmlRaiseError( 0,  0,  0,  0,  0,  20,  2,  2,  0LL,  0,  a1,  0LL,  0LL,  0,  0,  (uint64_t)"Memory allocation failed : %s\n");
}

unsigned __int8 *xmlParseSGMLCatalogName(unsigned __int8 *a1, xmlChar **a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  *a2 = 0LL;
  unsigned __int8 v3 = *a1;
  if ((*a1 + 40) >= 0x1Fu
    && (*a1 + 64) >= 0x17u
    && ((*a1 & 0xDF) - 65) >= 0x1Au)
  {
    int v6 = *a1;
  }

  uint64_t v7 = 0LL;
  memset(v10, 0, 105);
  while (1)
  {
    BOOL v8 = (v3 & 0xDFu) - 65 >= 0x1A && v3 - 192 >= 0x17;
    if (v8
      && v3 <= 0xF7u
      && v3 - 216 >= 0x1F
      && v3 - 48 >= 0xA
      && v3 - 45 >= 2
      && v3 != 95
      && v3 != 58)
    {
      break;
    }

    *((_BYTE *)v10 + v7) = v3;
    unsigned __int8 v3 = a1[++v7];
    if (v7 == 100) {
      return 0LL;
    }
  }

  *a2 = xmlStrndup((const xmlChar *)v10, v7);
  return &a1[v7];
}

unsigned __int8 *xmlParseSGMLCatalogPubid(unsigned __int8 *a1, void *a2)
{
  xmlGenericErrorFunc v2 = a2;
  *a2 = 0LL;
  int v3 = *a1;
  if (v3 == 34) {
    xmlGenericErrorFunc v4 = a1 + 1;
  }
  else {
    xmlGenericErrorFunc v4 = a1;
  }
  if (v3 == 34) {
    int v5 = 34;
  }
  else {
    int v5 = 32;
  }
  if (v3 == 39) {
    int v6 = a1 + 1;
  }
  else {
    int v6 = v4;
  }
  BOOL v7 = v3 != 39 && v3 != 34;
  BOOL v8 = v3 == 39 || v3 == 34;
  if (v3 == 39) {
    int v9 = 39;
  }
  else {
    int v9 = v5;
  }
  uint64_t v10 = xmlMallocAtomic(0x32uLL);
  if (!v10)
  {
    xmlCatalogErrMemory((uint64_t)"allocating public ID");
    return 0LL;
  }

  uint64_t v11 = v10;
  uint64_t v12 = 0LL;
  unsigned int v13 = *v6;
  BOOL v14 = v9 == v13 && v8;
  if (xmlIsPubidChar_tab[*v6]) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = v13 == 63;
  }
  if (v15 && !v14)
  {
    xmlGenericErrorFunc v27 = v2;
    uint64_t v16 = 0LL;
    int v17 = 50;
    while (1)
    {
      if (v7 && v13 <= 0x20 && ((1LL << v13) & 0x100002600LL) != 0)
      {
        v11[v16] = 0;
        v6 += v16;
        xmlGenericErrorFunc v2 = v27;
        goto LABEL_51;
      }

      uint64_t v18 = v16 + 1;
      if (v17 <= (int)v16 + 1)
      {
        v17 *= 2;
        uint64_t v19 = xmlRealloc(v11, v17);
        if (!v19)
        {
          xmlCatalogErrMemory((uint64_t)"allocating public ID");
          goto LABEL_57;
        }

        LOBYTE(v13) = v6[v16];
        uint64_t v11 = v19;
      }

      v11[v16] = v13;
      unsigned int v13 = v6[v16 + 1];
      BOOL v20 = v9 == v13 && v8;
      if (xmlIsPubidChar_tab[v6[v16 + 1]]) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = v13 == 63;
      }
      if (v21)
      {
        ++v16;
        if (!v20) {
          continue;
        }
      }

      uint64_t v12 = v18;
      v6 += v18;
      xmlGenericErrorFunc v2 = v27;
      break;
    }
  }

  v11[v12] = 0;
  if (!v7)
  {
    if (v9 != *v6) {
      goto LABEL_57;
    }
    ++v6;
    goto LABEL_55;
  }

LABEL_51:
  unsigned int v22 = *v6;
  BOOL v23 = v22 > 0x20;
  uint64_t v24 = (1LL << v22) & 0x100002600LL;
  if (v23 || v24 == 0)
  {
LABEL_57:
    xmlFree(v11);
    return 0LL;
  }

            *((_DWORD *)a1 + 141) |= 0x10000u;
            a2 = (a2 - 0x10000);
            if ((a2 & 0x20000) == 0)
            {
LABEL_45:
              if ((a2 & 0x40000) == 0) {
                goto LABEL_46;
              }
              goto LABEL_53;
            }

    xmlGenericErrorFunc v28 = *(void *)(v6 + 40);
    xmlGenericErrorFunc v4 = (xmlNode *)v6;
    if (!v28) {
      goto LABEL_257;
    }
    xmlGenericErrorFunc v4 = (xmlNode *)v6;
    if (*(_DWORD *)(v28 + 8) != 1) {
      goto LABEL_257;
    }
    if (xmlStrEqual(*(const xmlChar **)(v28 + 16), (const xmlChar *)"value")) {
      goto LABEL_54;
    }
    if (xmlStrEqual(*(const xmlChar **)(*(void *)(v6 + 40) + 16LL), (const xmlChar *)"param")) {
      xmlGenericErrorFunc v4 = 0LL;
    }
    else {
      xmlGenericErrorFunc v4 = (xmlNode *)v6;
    }
LABEL_55:
    int v5 = *(void *)(v6 + 24);
    if (v5)
    {
      xmlGenericErrorFunc v29 = *(_DWORD *)(v5 + 8);
      uint64_t v30 = v29 > 0x11;
      uint64_t v31 = (1 << v29) & 0x20060;
      if (v30 || v31 == 0) {
        continue;
      }
    }

    goto LABEL_257;
  }

  xmlGenericErrorFunc v4 = (xmlNode *)v6;
  if (v7 != 1) {
    goto LABEL_257;
  }
  uint64_t v10 = *(void *)(v6 + 72);
  if (!v10 || !xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v33 = *(void *)(v6 + 40);
    xmlGenericErrorFunc v4 = (xmlNode *)v6;
    if (!v33) {
      goto LABEL_257;
    }
    xmlGenericErrorFunc v4 = (xmlNode *)v6;
    if (*(_DWORD *)(v33 + 8) != 1) {
      goto LABEL_257;
    }
    if (!xmlStrEqual(*(const xmlChar **)(v33 + 16), (const xmlChar *)"name")
      && !xmlStrEqual(*(const xmlChar **)(*(void *)(v6 + 40) + 16LL), (const xmlChar *)"value"))
    {
      xmlGenericErrorFunc v4 = (xmlNode *)v6;
      if (!xmlStrEqual(*(const xmlChar **)(*(void *)(v6 + 40) + 16LL), (const xmlChar *)"param")) {
        goto LABEL_257;
      }
    }

    uint64_t v34 = *(const xmlChar **)(*(void *)(v6 + 40) + 16LL);
    xmlGenericErrorFunc v35 = a1;
    uint64_t v36 = v6;
    xmlGenericErrorFunc v37 = 1035;
    BOOL v38 = "element %s doesn't allow foreign elements\n";
    goto LABEL_68;
  }

  uint64_t v11 = *(void *)(v6 + 88);
  if (v11)
  {
    while (1)
    {
      uint64_t v12 = v11;
      uint64_t v11 = *(void *)(v11 + 48);
      unsigned int v13 = *(void *)(v12 + 72);
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"name")) {
        break;
      }
      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"type"))
      {
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"value")) {
          goto LABEL_35;
        }
        uint64_t v16 = *(const xmlChar **)(v6 + 16);
        int v17 = "data";
        goto LABEL_32;
      }

      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"href"))
      {
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"externalRef")) {
          goto LABEL_35;
        }
        uint64_t v16 = *(const xmlChar **)(v6 + 16);
        int v17 = "include";
        goto LABEL_32;
      }

      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"combine"))
      {
        BOOL v14 = *(const xmlChar **)(v6 + 16);
        BOOL v15 = "start";
        goto LABEL_30;
      }

      if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"datatypeLibrary"))
      {
        String = xmlNodeListGetString(*(xmlDocPtr *)(v6 + 64), *(const xmlNode **)(v12 + 24), 1);
        if (String)
        {
          uint64_t v25 = String;
          if (*String)
          {
            uint64_t v26 = xmlParseURI((const char *)String);
            if (v26)
            {
              xmlGenericErrorFunc v27 = v26;
              if (!v26->scheme) {
                xmlRngPErr(a1, v6, 1118, "Attribute %s URI %s is not absolute\n", *(const xmlChar **)(v12 + 16), v25);
              }
              if (v27->fragment) {
                xmlRngPErr(a1, v6, 1117, "Attribute %s URI %s has a fragment ID\n", *(const xmlChar **)(v12 + 16), v25);
              }
              xmlFreeURI(v27);
            }

            else
            {
              xmlRngPErr(a1, v6, 1050, "Attribute %s contains invalid URI %s\n", *(const xmlChar **)(v12 + 16), v25);
            }
          }

          xmlFree(v25);
        }

        goto LABEL_35;
      }

      if (!xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"ns"))
      {
        uint64_t v18 = *(const xmlChar **)(v12 + 16);
        uint64_t v19 = *(xmlChar **)(v6 + 16);
        BOOL v20 = a1;
        BOOL v21 = v6;
        unsigned int v22 = 1113;
        BOOL v23 = "Unknown attribute %s on %s\n";
        goto LABEL_34;
      }

        if (v7)
        {
          xmlGenericErrorFunc v35 = *(const xmlChar **)(v15 + 80);
          if (v35)
          {
            uint64_t v36 = v7->dict;
            if (v36)
            {
              v97 = v8;
              xmlGenericErrorFunc v37 = v7;
              BOOL v38 = v5;
              if (xmlDictOwns(v36, v35))
              {
                uint64_t v39 = v38->dict;
                if (v39) {
                  uint64_t v40 = (void *)xmlDictLookup(v39, *(const xmlChar **)(v15 + 80), -1);
                }
                else {
                  uint64_t v40 = xmlStrdup(*(const xmlChar **)(v15 + 80));
                }
                int v5 = v38;
                *(void *)(v15 + 80) = v40;
              }

              else
              {
                int v5 = v38;
              }

              BOOL v7 = v37;
              BOOL v8 = v97;
            }
          }
        }

        goto LABEL_118;
      case 8:
        goto LABEL_118;
      case 19:
      case 20:
        goto LABEL_135;
      default:
        uint64_t v10 = 0xFFFFFFFFLL;
        goto LABEL_118;
    }
  }

            int v17 = *(xmlChar **)(i + 104);
            uint64_t v16 = elem->name;
            uint64_t v30 = *(xmlChar **)(i + 16);
            uint64_t v18 = (uint64_t *)v5;
            uint64_t v19 = (int)elem;
            BOOL v20 = 518;
            if (v17)
            {
              BOOL v21 = "Element %s does not carry attribute %s:%s\n";
            }

            else
            {
              BOOL v21 = "Element %s does not carry attribute %s\n";
              int v17 = *(xmlChar **)(i + 16);
LABEL_54:
              uint64_t v30 = 0LL;
            }

            xmlErrValidNode(v18, v19, v20, (uint64_t)v21, (uint64_t)v16, v17, v30);
            int v6 = 0;
            continue;
          }

          properties = elem->properties;
          if (!properties) {
            goto LABEL_51;
          }
          xmlGenericErrorFunc v27 = -1;
          do
          {
            if (xmlStrEqual(properties->name, *(const xmlChar **)(i + 16)))
            {
              xmlGenericErrorFunc v28 = *(const xmlChar **)(i + 104);
              if (!v28) {
                goto LABEL_56;
              }
              xmlGenericErrorFunc v29 = properties->ns;
              if (v29 || (xmlGenericErrorFunc v29 = elem->ns) != 0LL)
              {
                if (xmlStrEqual(v29->prefix, v28)) {
                  goto LABEL_56;
                }
                xmlGenericErrorFunc v27 = 1;
              }

              else
              {
                v27 &= ~(v27 >> 31);
              }
            }

            properties = properties->next;
          }

          while (properties);
          if (v27)
          {
            if (v27 == -1) {
              goto LABEL_51;
            }
            uint64_t v31 = elem->name;
            uint64_t v32 = *(xmlChar **)(i + 104);
            uint64_t v33 = *(xmlChar **)(i + 16);
            uint64_t v34 = (uint64_t *)v5;
            xmlGenericErrorFunc v35 = (int)elem;
            uint64_t v36 = 506;
            xmlGenericErrorFunc v37 = "Element %s required attribute %s:%s has different prefix\n";
          }

          else
          {
            uint64_t v31 = elem->name;
            uint64_t v32 = *(xmlChar **)(i + 104);
            uint64_t v33 = *(xmlChar **)(i + 16);
            uint64_t v34 = (uint64_t *)v5;
            xmlGenericErrorFunc v35 = (int)elem;
            uint64_t v36 = 524;
            xmlGenericErrorFunc v37 = "Element %s required attribute %s:%s has no prefix\n";
          }

          xmlErrValidWarning(v34, v35, v36, (uint64_t)v37, (uint64_t)v31, v32, v33);
        }

    if (v86)
    {
      xmlGenericErrorFunc v37 = &val;
      BOOL v38 = v28;
      uint64_t v39 = v15;
    }

    else
    {
      BOOL v38 = v28;
      uint64_t v39 = v15;
      xmlGenericErrorFunc v37 = 0LL;
    }

    uint64_t v34 = xmlSchemaValPredefTypeNodeNoNorm(v38, v39, v37, a2);
    goto LABEL_59;
  }

  if (*(_DWORD *)a1 != 2)
  {
    xmlGenericErrorFunc v35 = *__xmlGenericError();
    uint64_t v36 = __xmlGenericErrorContext();
    v35( *v36,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xmlschemas.c",  24895);
    if (!v21) {
      goto LABEL_78;
    }
    goto LABEL_77;
  }

  builtInType = v28->builtInType;
  if (builtInType != 21)
  {
    if (builtInType == 28)
    {
      uint64_t v30 = *(void *)(a1 + 40);
      uint64_t v31 = a1;
      uint64_t v32 = 0LL;
LABEL_48:
      uint64_t v34 = xmlSchemaValidateNotation(v31, v30, v32, v15, &val, v86);
LABEL_59:
      uint64_t v41 = v34;
      goto LABEL_60;
    }

    goto LABEL_51;
  }

  __int128 v89 = 0LL;
  uint64_t v50 = xmlValidateQName(v15, 1);
  if (v50)
  {
    if (v50 == -1)
    {
      xmlSchemaInternalErr2( (_DWORD *)a1,  (const xmlChar *)"xmlSchemaValidateQName",  (const xmlChar *)"calling xmlValidateQName()",  0LL);
      uint64_t v41 = -1;
    }

    else
    {
      uint64_t v41 = 1824;
    }
  }

  else
  {
    __int128 v72 = xmlSplitQName2(v15, (xmlChar **)&v89);
    if (!v72) {
      __int128 v72 = xmlStrdup(v15);
    }
    __int128 v73 = xmlSchemaLookupNamespace(a1, (xmlChar *)v89);
    if (v89 && (xmlFree(v89), !v73))
    {
      __int128 v76 = xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME);
      uint64_t v41 = 1824;
      xmlSchemaCustomErr4( (_DWORD *)a1,  1824,  0LL,  v76,  (const xmlChar *)"The QName value '%s' has no corresponding namespace declaration in scope",  v15,  0LL,  0LL,  0LL);
      if (v72) {
        xmlFree(v72);
      }
    }

    else if (v86)
    {
      if (v73) {
        __int128 v74 = xmlStrdup(v73);
      }
      else {
        __int128 v74 = 0LL;
      }
      uint64_t v41 = 0;
      val = xmlSchemaNewQNameValue(v74, v72);
    }

    else
    {
      xmlFree(v72);
      uint64_t v41 = 0;
    }
  }

LABEL_55:
  void *v2 = v11;
  return v6;
}

              close(*((_DWORD *)ctx + 45));
              BOOL v21 = -1;
              *((_DWORD *)ctx + 45) = -1;
              return v21;
            }

            uint64_t v25 = "send failed";
LABEL_53:
            uint64_t v26 = 0;
LABEL_54:
            __xmlIOErr(9, v26, (uint64_t)v25);
            goto LABEL_55;
          }

          v55 = 0u;
          xmlGenericErrorFunc v56 = 0u;
          xmlGenericErrorFunc v53 = 0u;
          int v54 = 0u;
          xmlGenericErrorFunc v51 = 0u;
          uint64_t v52 = 0u;
          uint64_t v49 = 0u;
          uint64_t v50 = 0u;
          int v47 = 0u;
          int v48 = 0u;
          uint64_t v45 = 0u;
          v46 = 0u;
          memset(v44, 0, sizeof(v44));
          int v42 = 0u;
          int v43 = 0u;
          uint64_t v41 = 0u;
          uint64_t v39 = 0u;
          uint64_t v40 = 0u;
          xmlGenericErrorFunc v37 = 0u;
          BOOL v38 = 0u;
          uint64_t v36 = 0u;
          memset(&v35, 0, sizeof(v35));
          if (!proxyUser) {
            goto LABEL_62;
          }
          snprintf((char *)&v35, 0x190uLL, "USER %s\r\n", (const char *)proxyUser);
          HIBYTE(v56) = 0;
          BOOL v20 = strlen((const char *)&v35);
          BOOL v21 = send(*((_DWORD *)ctx + 45), &v35, v20, 0);
          if (v21 < 0) {
            goto LABEL_56;
          }
          unsigned int v22 = xmlNanoFTPReadResponse((int *)ctx);
          switch(v22)
          {
            case 1:
LABEL_62:
              if (proxyType >= 2)
              {
                if (proxyType != 2) {
                  goto LABEL_55;
                }
              }

              else
              {
                snprintf((char *)&v35, 0x190uLL, "SITE %s\r\n", *((const char **)ctx + 1));
                HIBYTE(v56) = 0;
                xmlGenericErrorFunc v28 = strlen((const char *)&v35);
                BOOL v21 = send(*((_DWORD *)ctx + 45), &v35, v28, 0);
                if (v21 < 0) {
                  goto LABEL_56;
                }
                if (xmlNanoFTPReadResponse((int *)ctx) == 2)
                {
                  proxyType = 1;
                  goto LABEL_66;
                }

                if (proxyType == 1) {
                  goto LABEL_55;
                }
              }

              if (*((void *)ctx + 4)) {
                snprintf((char *)&v35, 0x190uLL, "USER %s@%s\r\n");
              }
              else {
                snprintf((char *)&v35, 0x190uLL, "USER anonymous@%s\r\n");
              }
              HIBYTE(v56) = 0;
              uint64_t v32 = strlen((const char *)&v35);
              BOOL v21 = send(*((_DWORD *)ctx + 45), &v35, v32, 0);
              if ((v21 & 0x80000000) == 0)
              {
                if (*((void *)ctx + 5)) {
                  snprintf((char *)&v35, 0x190uLL, "PASS %s\r\n", *((const char **)ctx + 5));
                }
                else {
                  strcpy((char *)&v35, "PASS anonymous@\r\n");
                }
                HIBYTE(v56) = 0;
                uint64_t v33 = strlen((const char *)&v35);
                BOOL v21 = send(*((_DWORD *)ctx + 45), &v35, v33, 0);
                if ((v21 & 0x80000000) == 0)
                {
LABEL_91:
                  BOOL v21 = 0;
                  proxyType = 2;
                  return v21;
                }
              }

    if (v12 == 45 && v17 == 45) {
      xmlFatalErr((_DWORD *)a1, 80, 0LL);
    }
    if (a3 + 5 >= a4)
    {
      a4 *= 2LL;
      uint64_t v26 = xmlRealloc(v6, a4);
      if (!v26)
      {
        xmlFree(v6);
        htmlErrMemory((_DWORD *)a1, 0LL);
        return;
      }

      int v6 = v26;
    }

    if (len[1] == 1) {
      v6[a3++] = v12;
    }
    else {
      a3 += xmlCopyCharMultiByte(&v6[a3], v12);
    }
    xmlGenericErrorFunc v28 = v42;
    xmlGenericErrorFunc v27 = len[0];
    len[0] = v42;
    len[1] = v27;
    if (v25 < 0x32)
    {
      ++v25;
    }

    else
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        xmlGenericErrorFunc v29 = *(void **)(a1 + 56);
        uint64_t v30 = v29[4];
        if (v30 - v29[3] < 501 || v29[5] - v30 > 499 || (xmlSHRINK(a1), !*(_DWORD *)(a1 + 452)))
        {
        }
      }

      if (*(_DWORD *)(a1 + 272) == -1) {
        goto LABEL_92;
      }
      uint64_t v25 = 0LL;
      xmlGenericErrorFunc v28 = v42;
    }

    uint64_t v31 = *(void *)(a1 + 56);
    uint64_t v32 = *(_BYTE **)(v31 + 32);
    uint64_t v33 = &v32[v28];
    if ((unint64_t)v33 <= *(void *)(v31 + 40))
    {
      if (*v32 == 10)
      {
        ++*(_DWORD *)(v31 + 52);
        uint64_t v34 = 1;
      }

      else
      {
        uint64_t v34 = *(_DWORD *)(v31 + 56) + 1;
      }

      *(_DWORD *)(v31 + 56) = v34;
      *(void *)(v31 + 32) = v33;
    }

    xmlGenericErrorFunc v35 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
    if (!v35)
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        uint64_t v36 = *(void **)(a1 + 56);
        xmlGenericErrorFunc v37 = v36[4];
        if (v37 - v36[3] < 501 || v36[5] - v37 > 499 || (xmlSHRINK(a1), !*(_DWORD *)(a1 + 452)))
        {
        }
      }

      xmlGenericErrorFunc v35 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
    }

    uint64_t v12 = v17;
    int v17 = v24;
    uint64_t v24 = v35;
    if (a3 > v8)
    {
      BOOL v38 = "Comment too big found";
      goto LABEL_90;
    }
  }

  v6[a3] = 0;
  if (v24) {
    goto LABEL_93;
  }
  BOOL v38 = "Comment not terminated \n<!--%.50s\n";
  uint64_t v39 = (_DWORD *)a1;
  uint64_t v40 = (uint64_t)v6;
LABEL_91:
  xmlFatalErrMsgStr(v39, 45, (uint64_t)v38, v40);
LABEL_92:
  xmlFree(v6);
}

        xmlGenericErrorFunc v28 = "(annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?)))";
        goto LABEL_56;
      }
    }
  }

xmlChar *xmlCatalogNormalizePublic(xmlChar *cur)
{
  if (cur)
  {
    int v1 = cur;
    unsigned int v2 = *cur;
    if (*cur)
    {
      int v3 = cur + 1;
      int v4 = 1;
      do
      {
        uint64_t v5 = 1LL << v2;
        BOOL v6 = v2 == 32 && v4 == 0;
        if (v2 == 32 && v4 == 0) {
          int v4 = 1;
        }
        BOOL v7 = (v5 & 0x100002600LL) == 0;
        int v8 = (v5 & 0x100002600LL) == 0 || v6;
        if (v7) {
          int v4 = 0;
        }
        if (v2 > 0x20)
        {
          int v8 = 1;
          int v4 = 0;
        }

        if (!v8) {
          break;
        }
        unsigned int v9 = *v3++;
        unsigned int v2 = v9;
      }

      while (v9);
      if (v8 && !v4) {
        return 0LL;
      }
    }

    cur = xmlStrdup(cur);
    int v10 = 0;
    uint64_t v11 = cur;
    while (1)
    {
      unsigned int v12 = *v1;
      if (v12 <= 0x20)
      {
        if (((1LL << v12) & 0x100002600LL) != 0)
        {
          if (v11 != cur) {
            int v10 = 1;
          }
          goto LABEL_24;
        }

        if (!*v1)
        {
          *uint64_t v11 = 0;
          return cur;
        }
      }

      if (v10)
      {
        *v11++ = 32;
        LOBYTE(v12) = *v1;
      }

      int v10 = 0;
      *v11++ = v12;
LABEL_24:
      ++v1;
    }
  }

  return cur;
}

xmlChar *xmlCatalogUnWrapURN(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (xmlStrncmp((const xmlChar *)a1, (const xmlChar *)"urn:publicid:", 13)) {
    return 0LL;
  }
  bzero(cur, 0x7D0uLL);
  int v5 = *(unsigned __int8 *)(a1 + 13);
  int v4 = (unsigned __int8 *)(a1 + 13);
  int v3 = v5;
  if (v5)
  {
    uint64_t v6 = 0LL;
    LODWORD(v7) = 0;
    while (1)
    {
      if (v3 > 57)
      {
        if (v3 == 58)
        {
          uint64_t v7 = v7 + 1LL;
          cur[v6] = 47;
          cur[v7] = 47;
          goto LABEL_21;
        }

        if (v3 == 59)
        {
          uint64_t v7 = v7 + 1LL;
          cur[v6] = 58;
          cur[v7] = 58;
          ++v4;
          goto LABEL_22;
        }

LABEL_20:
        cur[v6] = v3;
        goto LABEL_21;
      }

      if (v3 != 37)
      {
        if (v3 == 43)
        {
          cur[v6] = 32;
LABEL_21:
          ++v4;
          goto LABEL_22;
        }

        goto LABEL_20;
      }

      int v8 = v4[1];
      if (v8 == 51)
      {
        int v12 = v4[2];
        switch(v12)
        {
          case 'A':
            xmlChar v10 = 58;
            break;
          case 'B':
            xmlChar v10 = 59;
            break;
          case 'F':
            xmlChar v10 = 63;
            break;
          default:
            goto LABEL_33;
        }
      }

      else
      {
        if (v8 != 50) {
          goto LABEL_33;
        }
        unsigned int v9 = v4[2];
        if (v9 <= 0x36)
        {
          if (v9 == 51)
          {
            xmlChar v10 = 35;
          }

          else
          {
            if (v9 != 53)
            {
LABEL_33:
              cur[v6] = 37;
              ++v4;
              goto LABEL_22;
            }

            xmlChar v10 = 37;
          }
        }

        else
        {
          switch(v9)
          {
            case '7':
              xmlChar v10 = 39;
              break;
            case 'B':
              xmlChar v10 = 43;
              break;
            case 'F':
              xmlChar v10 = 47;
              break;
            default:
              goto LABEL_33;
          }
        }
      }

      cur[v6] = v10;
      v4 += 3;
LABEL_22:
      uint64_t v6 = (v7 + 1);
      int v3 = *v4;
      if (*v4)
      {
        BOOL v11 = v7 > 0x7CB;
        LODWORD(v7) = v7 + 1;
        if (!v11) {
          continue;
        }
      }

      goto LABEL_41;
    }
  }

  uint64_t v6 = 0LL;
LABEL_41:
  cur[v6] = 0;
  return xmlStrdup(cur);
}

  xmlSkipBlankChars(ctxt);
  BOOL v11 = ctxt->input;
  if (*v11->cur == 62)
  {
    if (id != v11->id) {
      xmlFatalErrMsg(ctxt, 90);
    }
    xmlNextChar(ctxt);
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        elementDecl = ctxt->sax->elementDecl;
        if (elementDecl)
        {
          unsigned int v13 = result;
          if (!result)
          {
            ((void (*)(void *, const xmlChar *, uint64_t, void))elementDecl)(ctxt->userData, v19, v10, 0LL);
            return v10;
          }

          result->parent = 0LL;
          ((void (*)(void *, const xmlChar *, uint64_t, xmlElementContentPtr))elementDecl)( ctxt->userData,  v19,  v10,  v13);
          if (!v13->parent)
          {
            myDoc = ctxt->myDoc;
            BOOL v15 = v13;
LABEL_55:
            xmlFreeDocElementContent(myDoc, v15);
            return v10;
          }

          return v10;
        }
      }
    }
  }

  else
  {
    xmlFatalErr(ctxt, 73, 0LL);
  }

  BOOL v15 = result;
  if (result)
  {
    myDoc = ctxt->myDoc;
    goto LABEL_55;
  }

  return v10;
}

  int v8 = URL;
  return xmlStrdup(v8);
}

      xmlSchemaPIllegalAttrErr((_DWORD *)a1, v23);
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  return v20;
}

      memberTypes = memberTypes->next;
      if (!memberTypes) {
        goto LABEL_21;
      }
    }

    next = memberTypes->next;
    p_next = &memberTypes->next;
    while (1)
    {
      uint64_t v16 = xmlMalloc(0x10uLL);
      if (!v16) {
        break;
      }
      v16[1] = v13[1];
      *p_next = v16;
      *uint64_t v16 = next;
      unsigned int v13 = (void *)*v13;
      p_next = v16;
      if (!v13) {
        goto LABEL_20;
      }
    }

    if (ctxt) {
      ++*((_DWORD *)ctxt + 9);
    }
    __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"allocating a type link");
    return 0xFFFFFFFFLL;
  }

void xmlFetchXMLCatalogFile(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    xmlRMutexLock((xmlRMutexPtr)xmlCatalogMutex);
    if (!*(void *)(a1 + 16))
    {
      if (xmlCatalogXMLFiles)
      {
        unsigned int v2 = xmlHashLookup((xmlHashTablePtr)xmlCatalogXMLFiles, *(const xmlChar **)(a1 + 48));
        if (v2)
        {
          int v3 = v2;
          if (xmlDebugCatalogs)
          {
            xmlGenericErrorFunc v4 = *__xmlGenericError();
            int v5 = __xmlGenericErrorContext();
            v4(*v5, "Found %s in file hash\n", *(const char **)(a1 + 48));
          }

          if (*(_DWORD *)(a1 + 24) == 1) {
            int v3 = (void *)v3[2];
          }
          *(void *)(a1 + 16) = v3;
          *(_DWORD *)(a1 + 60) = 0;
          goto LABEL_31;
        }

        if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v6 = *__xmlGenericError();
          uint64_t v7 = __xmlGenericErrorContext();
          v6(*v7, "%s not found in file hash\n", *(const char **)(a1 + 48));
        }
      }

      int v8 = *(const char **)(a1 + 48);
      if (v8)
      {
        uint64_t v9 = *(unsigned int *)(a1 + 56);
        xmlDocPtr v10 = xmlParseCatalogFile(*(const char **)(a1 + 48));
        if (v10)
        {
          BOOL v11 = v10;
          if (xmlDebugCatalogs)
          {
            xmlGenericErrorFunc v12 = *__xmlGenericError();
            unsigned int v13 = *__xmlGenericErrorContext();
            int ThreadId = xmlGetThreadId();
            v12(v13, "%d Parsing catalog %s\n", ThreadId, v8);
          }

          xmlNodePtr RootElement = xmlDocGetRootElement(v11);
          if (RootElement
            && (uint64_t v16 = RootElement, xmlStrEqual(RootElement->name, (const xmlChar *)"catalog"))
            && (ns = v16->ns) != 0LL
            && (href = ns->href) != 0LL
            && xmlStrEqual(href, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog"))
          {
            uint64_t v19 = xmlNewCatalogEntry(1, 0LL, (const xmlChar *)v8, 0LL, v9, 0LL);
            if (v19)
            {
              BOOL v20 = v19;
              Prop = xmlGetProp(v16, (const xmlChar *)"prefer");
              if (Prop)
              {
                unsigned int v22 = Prop;
                if (xmlStrEqual(Prop, (const xmlChar *)"system"))
                {
                  uint64_t v9 = 2LL;
                }

                else if (xmlStrEqual(v22, (const xmlChar *)"public"))
                {
                  uint64_t v9 = 1LL;
                }

                else
                {
                  xmlCatalogErr(0LL, (uint64_t)v16, 1652, "Invalid value for prefer: '%s'\n", v22, 0LL, 0LL);
                }

                xmlFree(v22);
              }

              xmlParseXMLCatalogNodeList(v16->children, v9, v20, 0LL);
              xmlFreeDoc(v11);
              uint64_t v25 = v20;
              if (*(_DWORD *)(a1 + 24) == 1) {
                uint64_t v25 = (void *)v20[2];
              }
              *(void *)(a1 + 16) = v25;
              *((_DWORD *)v20 + 15) = 1;
              uint64_t v26 = (xmlHashTable *)xmlCatalogXMLFiles;
              if (xmlCatalogXMLFiles || (uint64_t v26 = xmlHashCreate(10), (xmlCatalogXMLFiles = (uint64_t)v26) != 0))
              {
                if (xmlDebugCatalogs)
                {
                  xmlGenericErrorFunc v27 = *__xmlGenericError();
                  xmlGenericErrorFunc v28 = __xmlGenericErrorContext();
                  v27(*v28, "%s added to file hash\n", *(const char **)(a1 + 48));
                  uint64_t v26 = (xmlHashTable *)xmlCatalogXMLFiles;
                }

                xmlHashAddEntry(v26, *(const xmlChar **)(a1 + 48), v20);
              }

              goto LABEL_31;
            }
          }

          else
          {
            __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)v11,  0x14u,  1653,  2,  0LL,  0,  (const xmlChar *)v8,  0LL,  0LL,  0,  0,  "File %s is not an XML Catalog\n",  (char)v8);
          }

          xmlFreeDoc(v11);
        }

        else if (xmlDebugCatalogs)
        {
          xmlGenericErrorFunc v23 = *__xmlGenericError();
          uint64_t v24 = __xmlGenericErrorContext();
          v23(*v24, "Failed to parse catalog %s\n", v8);
        }
      }

      *(_DWORD *)(a1 + 24) = 2;
    }

LABEL_31:
    xmlRMutexUnlock((xmlRMutexPtr)xmlCatalogMutex);
  }

            *outlen = (_DWORD)v6 - (_DWORD)out;
            *inlen = v10 - (_DWORD)in;
            return -2;
          }

          LOBYTE(v17) = v14;
LABEL_27:
          if (v6 >= v9) {
            break;
          }
          *v6++ = v17;
          xmlDocPtr v10 = (int)v7;
          if (v7 >= v8) {
            goto LABEL_33;
          }
        }

        LODWORD(v7) = v10;
      }

      int v3 = a1[306];
LABEL_33:
      ;
    }

    while (a1[45] != -1);
  }

  return 0xFFFFFFFFLL;
}

  if ((_DWORD)result == 1)
  {
LABEL_34:
    int v3 = *((_WORD *)a1 + 49);
LABEL_35:
    *((_WORD *)a1 + 49) = v3 | 0x40;
    return 1LL;
  }

  if (!(_DWORD)result)
  {
    int v3 = *((_WORD *)a1 + 49);
LABEL_10:
    uint64_t result = 0LL;
    *((_WORD *)a1 + 49) = v3 | 0x80;
  }

  return result;
}

          xmlGenericErrorFunc v12 = 0LL;
          BOOL v20 = String;
          goto LABEL_32;
        }

  next = cur->next;
  if (next) {
    next->prev = cur->prev;
  }
  prev = cur->prev;
  if (prev) {
    prev->next = next;
  }
  cur->next = 0LL;
  cur->prev = 0LL;
}

    BOOL v38 = &a2[i + 2];
    for (k = 0; !xmlParse3986Segment(&v38, 0, k); k = 1)
    {
      unsigned int v13 = v38;
      if (*v38 != 47)
      {
        if (a1)
        {
          uint64_t v14 = *(void **)(a1 + 48);
          if (v14) {
            xmlFree(v14);
          }
          if (v10 == v13)
          {
            uint64_t v16 = 0LL;
          }

          else
          {
            BOOL v15 = (_DWORD)v13 + -2 - (_DWORD)a2 - i;
            if ((*(_BYTE *)(a1 + 72) & 2) != 0) {
              uint64_t v16 = xmlStrndup(&a2[i + 2], v15);
            }
            else {
              uint64_t v16 = xmlURIUnescapeString((const char *)&a2[i + 2], v15, 0LL);
            }
          }

          *(void *)(a1 + 48) = v16;
        }

        xmlDocPtr v10 = v13;
        goto LABEL_60;
      }

      ++v38;
    }

    goto LABEL_68;
  }

  return 0xFFFFFFFFLL;
}

    if (*(_DWORD *)(a1 + 24) != 5)
    {
      uint64_t v19 = xmlBufUse(v3) - *(_DWORD *)(a1 + 108);
      BOOL v20 = *(xmlParserCtxt **)(a1 + 32);
      BOOL v21 = xmlBufContent(v3);
      unsigned int v22 = xmlParseChunk(v20, (const char *)&v21[*(unsigned int *)(a1 + 108)], v19, 1);
      *(_DWORD *)(a1 + 108) = xmlBufUse(v3);
      *(_DWORD *)(a1 + 24) = 5;
      if (v22)
      {
        xmlGenericErrorFunc v23 = *(void *)(a1 + 32);
        if (!*(_DWORD *)(v23 + 24)) {
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(v23 + 24) = 0;
      }
    }

  uint64_t v24 = *(void *)(a1 + 32);
  if (v24 && (uint64_t v25 = *(_DWORD *)(v24 + 584), v25 <= 99))
  {
    attr->next = *(_xmlAttr **)(v24 + 592);
    *(void *)(v24 + 592) = attr;
    *(_DWORD *)(v24 + 584) = v25 + 1;
  }

  else
  {
    xmlFree(attr);
  }

        xmlGenericErrorFunc v12 = &i[v18];
        xmlFree(v19);
      }

      while (*v12);
    }
  }

  else
  {
    *(_DWORD *)(a2 + 44) = 1;
  }

  return v8;
}

    ctxt = v2;
    int v3 = 11;
    goto LABEL_32;
  }

  if (ctxt)
  {
LABEL_3:
    int v3 = 12;
LABEL_32:
    xmlXPathErr(ctxt, v3);
  }

_DWORD *xmlCatalogErr( void *a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5, xmlChar *a6, xmlChar *a7)
{
  return __xmlRaiseError(0LL, 0LL, 0LL, a1, a2, 0x14u, a3, 2, 0LL, 0, a5, a6, a7, 0, 0, a4, (char)a5);
}

void xmlParseXMLCatalogNodeList(const xmlNode *a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v7 = a1;
    xmlGenericErrorFunc v23 = a3 + 2;
    while (1)
    {
      ns = v7->ns;
      if (!ns) {
        goto LABEL_29;
      }
      href = ns->href;
      if (!href || !xmlStrEqual(href, (const xmlChar *)"urn:oasis:names:tc:entity:xmlns:xml:catalog")) {
        goto LABEL_29;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"group"))
      {
        Prop = xmlGetProp(v7, (const xmlChar *)"prefer");
        BOOL v11 = Prop;
        if (Prop)
        {
          if (xmlStrEqual(Prop, (const xmlChar *)"system"))
          {
            uint64_t v12 = 2LL;
          }

          else if (xmlStrEqual(v11, (const xmlChar *)"public"))
          {
            uint64_t v12 = 1LL;
          }

          else
          {
            __xmlRaiseError( 0LL,  0LL,  0LL,  a3,  (uint64_t)v7,  0x14u,  1652,  2,  0LL,  0,  v11,  0LL,  0LL,  0,  0,  "Invalid value for prefer: '%s'\n",  (char)v11);
            uint64_t v12 = a2;
          }

          xmlFree(v11);
          LODWORD(v11) = v12;
        }

        else
        {
          uint64_t v12 = a2;
        }

        BOOL v20 = xmlGetProp(v7, (const xmlChar *)"id");
        NsProp = xmlGetNsProp(v7, (const xmlChar *)"base", (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        uint64_t v18 = xmlNewCatalogEntry(4, v20, NsProp, 0LL, (int)v11, a4);
        xmlFree(v20);
        if (!v18) {
          goto LABEL_27;
        }
        goto LABEL_23;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"public"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 5;
        BOOL v15 = "public";
        uint64_t v16 = "publicId";
        goto LABEL_17;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"system"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 6;
        BOOL v15 = "system";
        uint64_t v16 = "systemId";
        goto LABEL_17;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"rewriteSystem"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 7;
        BOOL v15 = "rewriteSystem";
        uint64_t v16 = "systemIdStartString";
        goto LABEL_33;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"delegatePublic"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 8;
        BOOL v15 = "delegatePublic";
        uint64_t v16 = "publicIdStartString";
        goto LABEL_38;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"delegateSystem"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 9;
        BOOL v15 = "delegateSystem";
        uint64_t v16 = "systemIdStartString";
        goto LABEL_38;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"uri"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 10;
        BOOL v15 = "uri";
        uint64_t v16 = "name";
LABEL_17:
        int v17 = "uri";
        goto LABEL_18;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"rewriteURI"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 11;
        BOOL v15 = "rewriteURI";
        uint64_t v16 = "uriStartString";
LABEL_33:
        int v17 = "rewritePrefix";
LABEL_18:
        uint64_t v18 = xmlParseXMLCatalogOneNode(v13, v14, (const xmlChar *)v15, (xmlChar *)v16, (xmlChar *)v17, a2, a4);
        NsProp = 0LL;
        uint64_t v12 = a2;
        if (!v18)
        {
LABEL_27:
          if (NsProp) {
            xmlFree(NsProp);
          }
          goto LABEL_29;
        }

LABEL_23:
        v18[1] = a3;
        BOOL v21 = (void *)a3[2];
        for (i = v23; v21; BOOL v21 = (void *)*v21)
          size_t i = v21;
        *size_t i = v18;
        if (*((_DWORD *)v18 + 6) == 4) {
          xmlParseXMLCatalogNodeList(v7->children, v12, a3, v18);
        }
        goto LABEL_27;
      }

      if (xmlStrEqual(v7->name, (const xmlChar *)"delegateURI")) {
        break;
      }
      if (xmlStrEqual(v7->name, (const xmlChar *)"nextCatalog"))
      {
        unsigned int v13 = (xmlNode *)v7;
        int v14 = 3;
        BOOL v15 = "nextCatalog";
        uint64_t v16 = 0LL;
        goto LABEL_38;
      }

    ++v16;
    --v15;
    if (!--v17) {
      goto LABEL_26;
    }
  }

  if (v18 != a2 || a3 && *v16 != a3) {
    goto LABEL_23;
  }
  *(void *)(a1 + 320) = 0LL;
  return (*(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 32) - v15);
}

  if (!*(_DWORD *)(a1 + 52))
  {
    if (*(_DWORD *)(a1 + 156))
    {
      if (*(_DWORD *)(a1 + 24))
      {
        BOOL v20 = *(void *)(a1 + 16);
        if (v20)
        {
          if (*(void *)(v20 + 80))
          {
            if (!*(_DWORD *)(a1 + 28))
            {
              uint64_t v25 = xmlSAX2DecodeAttrEntities((xmlParserCtxtPtr)a1, (const xmlChar *)a4, (unint64_t)a5);
              if (v25)
              {
                BOOL v21 = v25;
                if (*(void *)(a1 + 552))
                {
                  uint64_t v30 = 0;
                  memset(v29, 0, sizeof(v29));
                  uint64_t v26 = xmlBuildQName(a2, nameSpace, (xmlChar *)v29, 50);
                  if (!v26) {
                    goto LABEL_67;
                  }
                  xmlGenericErrorFunc v27 = v26;
                  *(_DWORD *)(a1 + 224) = 1;
                  xmlGenericErrorFunc v28 = xmlValidCtxtNormalizeAttributeValue( (xmlValidCtxtPtr)(a1 + 160),  *(xmlDocPtr *)(a1 + 16),  *(xmlNodePtr *)(a1 + 80),  v26,  v21);
                  if (*(_DWORD *)(a1 + 224) != 1) {
                    *(_DWORD *)(a1 + 152) = 0;
                  }
                  if (v27 != (xmlChar *)v29 && v27 != a2) {
                    xmlFree(v27);
                  }
                  if (v28) {
                    xmlFree(v21);
                  }
                  else {
LABEL_67:
                  }
                    xmlGenericErrorFunc v28 = v21;
                  BOOL v21 = v28;
                }

                *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute( (xmlValidCtxtPtr)(a1 + 160),  *(xmlDocPtr *)(a1 + 16),  *(xmlNodePtr *)(a1 + 80),  v11,  v21);
                goto LABEL_70;
              }

              if (!*a5)
              {
                *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute( (xmlValidCtxtPtr)(a1 + 160),  *(xmlDocPtr *)(a1 + 16),  *(xmlNodePtr *)(a1 + 80),  v11,  (const xmlChar *)a4);
                return;
              }
            }

            BOOL v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
            *(_DWORD *)(a1 + 152) &= xmlValidateOneAttribute( (xmlValidCtxtPtr)(a1 + 160),  *(xmlDocPtr *)(a1 + 16),  *(xmlNodePtr *)(a1 + 80),  v11,  v21);
            if (!v21) {
              return;
            }
LABEL_70:
            xmlFree(v21);
            return;
          }
        }
      }
    }
  }

  if ((*(_BYTE *)(a1 + 432) & 8) != 0) {
    return;
  }
  if (*(_DWORD *)(a1 + 28))
  {
    if (*(_DWORD *)(a1 + 336)) {
      return;
    }
  }

  else if (*(_DWORD *)(a1 + 148) == 2)
  {
    return;
  }

  if (*(xmlChar **)(a1 + 480) == nameSpace && *a2 == 105 && a2[1] == 100 && !a2[2])
  {
    BOOL v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
    if (xmlValidateNCName(v21, 1)) {
      xmlErrValid((uint64_t *)a1, 539, (uint64_t)"xml:id : attribute value %s is not an NCName\n", (uint64_t)v21, 0LL);
    }
  }

  else
  {
    if (!xmlIsID(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11))
    {
      if (xmlIsRef(*(xmlDocPtr *)(a1 + 16), *(xmlNodePtr *)(a1 + 80), v11))
      {
        BOOL v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
        xmlAddRef((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), v21, v11);
        if (v21) {
          goto LABEL_70;
        }
      }

      return;
    }

    BOOL v21 = xmlStrndup((const xmlChar *)a4, (int)a5 - (int)a4);
  }

  xmlAddID((xmlValidCtxtPtr)(a1 + 160), *(xmlDocPtr *)(a1 + 16), v21, v11);
  if (v21) {
    goto LABEL_70;
  }
}

    name = cur->name;
    if (!name) {
      goto LABEL_28;
    }
    if (dict)
    {
      if (xmlDictOwns(dict, (const xmlChar *)name)) {
        goto LABEL_28;
      }
      name = cur->name;
    }

    xmlFree(name);
LABEL_28:
    encoding = (xmlChar *)cur->encoding;
    if (!encoding) {
      goto LABEL_33;
    }
    if (dict)
    {
      if (xmlDictOwns(dict, encoding)) {
        goto LABEL_33;
      }
      encoding = (xmlChar *)cur->encoding;
    }

    xmlFree(encoding);
LABEL_33:
    URL = (xmlChar *)cur->URL;
    if (URL)
    {
      if (dict)
      {
        if (xmlDictOwns(dict, URL))
        {
          xmlFree(cur);
LABEL_40:
          xmlDictFree(dict);
          return;
        }

        URL = (xmlChar *)cur->URL;
      }

      xmlFree(URL);
    }

    xmlFree(cur);
    if (!dict) {
      return;
    }
    goto LABEL_40;
  }

      xmlGenericErrorFunc v6 = *(void *)(v6 + 48);
      if (!v6) {
        return v4;
      }
    }

    uint64_t v12 = *(xmlChar **)(v6 + 80);
    if (!a3)
    {
      if (v9) {
        int v17 = xmlEncodeEntitiesReentrant(a1, v12);
      }
      else {
        int v17 = (xmlChar *)xmlEncodeAttributeEntities((uint64_t)a1, v12);
      }
      uint64_t v16 = v17;
      if (!v17) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }

      ((void (*)(xmlChar *))xmlFree)(v8);
    }
  }

  return 1LL;
}

            unsigned int v2 = 0xFFFFFFFFLL;
LABEL_24:
            xmlFreeHTTPWriteCtxt(a1);
            return v2;
          }
        }
      }

      else
      {
        xmlGenericErrorFunc v51 = 0;
        uint64_t v49 = 0u;
        uint64_t v50 = 0u;
        int v47 = 0u;
        int v48 = 0u;
        uint64_t v45 = 0u;
        v46 = 0u;
        int v43 = 0u;
        uint64_t v44 = 0u;
        uint64_t v41 = 0u;
        int v42 = 0u;
        uint64_t v39 = 0u;
        uint64_t v40 = 0u;
        xmlGenericErrorFunc v37 = 0u;
        BOOL v38 = 0u;
        xmlGenericErrorFunc v35 = 0u;
        uint64_t v36 = 0u;
        uint64_t v33 = 0u;
        uint64_t v34 = 0u;
        uint64_t v31 = 0u;
        uint64_t v32 = 0u;
        xmlGenericErrorFunc v29 = 0u;
        uint64_t v30 = 0u;
        xmlGenericErrorFunc v28 = 0u;
        uint64_t v26 = 0u;
        xmlGenericErrorFunc v27 = 0u;
        uint64_t v24 = 0u;
        uint64_t v25 = 0u;
        unsigned int v22 = 0u;
        xmlGenericErrorFunc v23 = 0u;
        *(_OWORD *)buf = 0u;
        BOOL v21 = 0u;
        xmlStrPrintf(buf, 500, "xmlZMemBuffGetContent:  %s - %d\n", "Error flushing zlib buffers.  Error code", v6);
        __xmlSimpleError(8, 1546, 0, (uint64_t)"write error", (uint64_t)buf);
      }
    }

        BOOL v11 = "growing nodeset\n";
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v12 = (xmlNodePtr *)xmlMalloc(0x50uLL);
      cur->nodeTab = v12;
      if (!v12) {
        goto LABEL_23;
      }
      *((_OWORD *)v12 + 3) = 0u;
      *((_OWORD *)v12 + 4) = 0u;
      *((_OWORD *)v12 + 1) = 0u;
      *((_OWORD *)v12 + 2) = 0u;
      *(_OWORD *)uint64_t v12 = 0u;
      cur->nodeMax = 10;
    }

  BOOL v20 = v17->type;
  if ((v17->type | 8) == 9) {
    return xmlXPathCompareNodeSets(inf, strict, v17, v7);
  }
LABEL_29:
  if ((v20 | 8) == 9)
  {
    BOOL v21 = v17;
    unsigned int v22 = v7;
  }

  else
  {
    inf = inf == 0;
    BOOL v21 = v7;
    unsigned int v22 = v17;
  }

  return xmlXPathCompareNodeSetValue(ctxt, inf, strict, v21, v22);
}

LABEL_29:
      uint64_t v7 = v7->next;
      if (!v7) {
        return;
      }
    }

    unsigned int v13 = (xmlNode *)v7;
    int v14 = 12;
    BOOL v15 = "delegateURI";
    uint64_t v16 = "uriStartString";
LABEL_38:
    int v17 = "catalog";
    goto LABEL_18;
  }

  Entity = xmlCreateEntity(v13, name, a3, a4, a5, a6);
  BOOL v21 = (uint64_t)Entity;
  if (Entity)
  {
    Entity[8] = a1[8];
    if (xmlHashAddEntry(Dict, name, Entity))
    {
      xmlFreeEntity(v21);
      return 0LL;
    }
  }

  return v21;
}

    if (v9 + 5 >= v11)
    {
      v11 *= 2;
      BOOL v15 = (xmlChar *)xmlRealloc(v7, v11);
      if (!v15)
      {
        xmlFree(v7);
        htmlErrMemory(ctxt, 0LL);
        goto LABEL_66;
      }

      uint64_t v7 = v15;
    }

    if (v10 < 50)
    {
      ++v10;
      goto LABEL_42;
    }

    if (!ctxt->progressive)
    {
      uint64_t v16 = ctxt->input;
      int v17 = v16->cur;
      if (v17 - v16->base < 501 || v16->end - v17 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }

    if (ctxt->instate == XML_PARSER_EOF) {
      break;
    }
    xmlDocPtr v10 = 0;
LABEL_42:
    if (len == 1) {
      v7[v9++] = v8;
    }
    else {
      v9 += xmlCopyCharMultiByte(&v7[v9], v8);
    }
    uint64_t v18 = ctxt->input;
    uint64_t v19 = v18->cur;
    BOOL v20 = &v19[len];
    if (v20 <= v18->end)
    {
      if (*v19 == 10)
      {
        ++v18->line;
        BOOL v21 = 1;
      }

      else
      {
        BOOL v21 = v18->col + 1;
      }

      v18->col = v21;
      v18->cur = v20;
    }

    int v8 = xmlCurrentChar(ctxt, &len);
    if (!v8)
    {
      if (!ctxt->progressive)
      {
        if (ctxt->input->end - ctxt->input->cur > 249 || (xmlGROW((uint64_t)ctxt), !ctxt->progressive))
        {
          unsigned int v22 = ctxt->input;
          xmlGenericErrorFunc v23 = v22->cur;
          if (v23 - v22->base >= 501 && v22->end - v23 <= 499) {
            xmlSHRINK((uint64_t)ctxt);
          }
        }
      }

      int v8 = xmlCurrentChar(ctxt, &len);
    }

    if (v9 > v2)
    {
      xmlFatalErr(ctxt, 110, (uint64_t)"SystemLiteral");
      xmlFree(v7);
LABEL_66:
      uint64_t v7 = 0LL;
      ctxt->instate = v25;
      return v7;
    }
  }

  xmlFree(v7);
  return 0LL;
}

        maxatts *= 2;
        uint64_t v16 = (const xmlChar **)xmlRealloc(atts, 8LL * maxatts);
        if (v16) {
          goto LABEL_37;
        }
        htmlErrMemory(ctxt, 0LL);
      }

      else
      {
        BOOL v15 = 0LL;
        while (!xmlStrEqual(atts[v15], v13))
        {
          v15 += 2LL;
        }

        xmlErrAttributeDup(ctxt, 0LL, v13);
      }
    }

    else if (!value)
    {
      goto LABEL_39;
    }

    xmlFree(v14);
LABEL_39:
    uint64_t v18 = ctxt->input;
    if (!ctxt->progressive && v18->end - v18->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      uint64_t v18 = ctxt->input;
    }

    uint64_t v19 = v18->cur;
    BOOL v20 = *v19;
    if (v20 == 47)
    {
      if (v19[1] == 62) {
        goto LABEL_62;
      }
    }

    else if (v20 == 62)
    {
      goto LABEL_62;
    }

    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65);
    }
    BOOL v21 = ctxt->input;
    if (consumed_low == v21->consumed && !v13 && v9 == v21->cur && !value) {
      break;
    }
    if (!ctxt->progressive)
    {
      unsigned int v22 = v21->cur;
      if (v22 - v21->base < 501 || v21->end - v22 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }
  }

  xmlFatalErrMsg(ctxt, 1);
LABEL_62:
  if (ctxt->sax && (startElement = ctxt->sax->startElement) != 0LL && !ctxt->disableSAX)
  {
    userData = ctxt->userData;
    if ((int)v7 >= 1)
    {
      ((void (*)(void *, const xmlChar *, const xmlChar **))startElement)(userData, v6, atts);
      goto LABEL_67;
    }

    ((void (*)(void *, const xmlChar *, void))startElement)(userData, v6, 0LL);
  }

  else
  {
LABEL_67:
    if (atts && (int)v7 >= 2)
    {
      uint64_t v25 = 1LL;
      do
      {
        uint64_t v26 = (xmlChar *)atts[v25];
        if (v26) {
          xmlFree(v26);
        }
        v25 += 2LL;
      }

      while ((int)v7 > (int)v25);
    }
  }

  return v6;
}

      int v3 = *(void *)(a1 + 56);
      if (!*(_DWORD *)(a1 + 452))
      {
        if ((uint64_t)(*(void *)(v3 + 40) - *(void *)(v3 + 32)) > 249
          || (xmlGROW(a1), int v3 = *(void *)(a1 + 56), !*(_DWORD *)(a1 + 452)))
        {
          xmlDocPtr v10 = *(void *)(v3 + 32);
          if (v10 - *(void *)(v3 + 24) >= 501 && *(void *)(v3 + 40) - v10 <= 499)
          {
            xmlSHRINK(a1);
            int v3 = *(void *)(a1 + 56);
          }
        }
      }

      int v8 = *(unsigned __int8 **)(v3 + 32);
      if (v6 == *(void *)(v3 + 64) && v4 == v8)
      {
        xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"detected an error in element content\n");
        xmlHaltParser((xmlParserCtxtPtr)a1);
        return;
      }

      int v5 = *v8;
      xmlGenericErrorFunc v4 = *(unsigned __int8 **)(v3 + 32);
    }

    while (*v8);
  }

      content = content->c2;
    }

    while (content);
    intSubset = doc->intSubset;
  }

  else
  {
    int v8 = 1;
  }

  DtdElementDesc = xmlGetDtdElementDesc(intSubset, elem->name);
  if (DtdElementDesc) {
    BOOL v20 = DtdElementDesc == elem;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    BOOL v21 = DtdElementDesc;
    unsigned int v22 = DtdElementDesc->prefix;
    xmlGenericErrorFunc v23 = elem->prefix;
    if (v22 == v23 || xmlStrEqual(v22, v23))
    {
      if (v21->etype)
      {
        xmlErrValidNode( (uint64_t *)ctxt,  (int)elem,  509,  (uint64_t)"Redefinition of element %s\n",  (uint64_t)elem->name,  0LL,  0LL);
        int v8 = 0;
      }
    }
  }

  uint64_t v24 = xmlGetDtdElementDesc(doc->extSubset, elem->name);
  if (v24) {
    uint64_t v25 = v24 == elem;
  }
  else {
    uint64_t v25 = 1;
  }
  if (!v25)
  {
    uint64_t v26 = v24;
    xmlGenericErrorFunc v27 = v24->prefix;
    xmlGenericErrorFunc v28 = elem->prefix;
    if (v27 == v28 || xmlStrEqual(v27, v28))
    {
      if (v26->etype)
      {
        xmlErrValidNode( (uint64_t *)ctxt,  (int)elem,  509,  (uint64_t)"Redefinition of element %s\n",  (uint64_t)elem->name,  0LL,  0LL);
        return 0;
      }
    }
  }

  return v8;
}

  int v17 = xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"final");
  if (v17)
  {
    uint64_t v18 = v17;
    name = xmlSchemaGetProp(a1, a3, (xmlChar *)"final");
    goto LABEL_36;
  }

  uint64_t v19 = *(_DWORD *)(a2 + 48);
  if ((v19 & 8) == 0)
  {
    if ((v19 & 0x10) == 0) {
      goto LABEL_34;
    }
LABEL_78:
    *v14 |= 0x800u;
    if ((v19 & 0x20) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }

  *v14 |= 0x400u;
  if ((v19 & 0x10) != 0) {
    goto LABEL_78;
  }
LABEL_34:
  if ((v19 & 0x20) != 0) {
LABEL_35:
  }
    *v14 |= 0x1000u;
LABEL_36:
  *(void *)(PropNode + 208) = *(void *)(a1 + 200);
  BOOL v20 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"id");
  if (v20) {
    xmlSchemaPValAttrNodeID(a1, v20);
  }
  BOOL v21 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = PropNode;
  children = (uint64_t)a3->children;
  if (!children
    || *(void *)(children + 72)
    && xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"annotation")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
    && (*(void *)(PropNode + 48) = xmlSchemaParseAnnotation((_DWORD *)a1, children, 1),
        (children = *(void *)(children + 48)) == 0))
  {
    xmlSchemaPContentErr(a1, 3034, (uint64_t)a3, 0LL, 0LL, (xmlChar *)"(annotation?, (restriction | list | union))");
    xmlGenericErrorFunc v23 = 0;
    goto LABEL_91;
  }

  if (!*(void *)(children + 72)) {
    goto LABEL_74;
  }
  if (xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"restriction")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    xmlSchemaParseRestriction(a1, a2, children, 4);
    xmlGenericErrorFunc v23 = 1;
    goto LABEL_89;
  }

  if (!*(void *)(children + 72)) {
    goto LABEL_74;
  }
  if (!xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"list")
    || !xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    if (*(void *)(children + 72)
      && xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"union")
      && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      xmlSchemaParseUnion(a1, a2, children);
      goto LABEL_88;
    }

  __int128 v80 = *(void **)(v16 + 56);
  if (!v80)
  {
    __int128 v80 = xmlSchemaItemListCreate();
    *(void *)(v16 + 56) = v80;
  }

  if (*(_DWORD *)v17 == 24 || !*((_DWORD *)v80 + 2) || !*(void *)(v16 + 64)) {
    goto LABEL_44;
  }
  name = 0LL;
  xmlSchemaFormatIDCKeySequence_1((_DWORD *)a1, &name, *v81, v79, 1);
  unsigned int v22 = name;
  __int128 v75 = (void **)xmlHashLookup(*(xmlHashTablePtr *)(v16 + 64), name);
  if (v22) {
    xmlFree(v22);
  }
  if (!v75)
  {
LABEL_44:
    uint64_t v26 = xmlMalloc(0x18uLL);
    if (v26)
    {
      xmlGenericErrorFunc v27 = (uint64_t)v26;
      xmlHashTable *v26 = 0LL;
      v26[1] = 0LL;
      v26[2] = 0LL;
      if (*(_DWORD *)v17 != 24)
      {
        int v54 = *(void **)(a1 + 232);
        if (v54)
        {
          v55 = *(int *)(a1 + 244);
          if ((int)v55 <= *(_DWORD *)(a1 + 240))
          {
            *(_DWORD *)(a1 + 244) = 2 * v55;
            __int128 v77 = v27;
            int v54 = xmlRealloc(v54, 16 * v55);
            xmlGenericErrorFunc v27 = v77;
            *(void *)(a1 + 232) = v54;
            if (!v54)
            {
              xmlListPtr v57 = "re-allocating the IDC node table item list";
LABEL_143:
              __int128 v74 = *(_DWORD *)(a1 + 108) + 1;
              *(_DWORD *)(a1 + 104) = 1818;
              *(_DWORD *)(a1 + 108) = v74;
              __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)v57);
              ((void (*)(uint64_t))xmlFree)(v77);
              goto LABEL_144;
            }
          }
        }

        else
        {
          __int128 v77 = v27;
          int v54 = xmlMalloc(0xA0uLL);
          *(void *)(a1 + 232) = v54;
          xmlListPtr v57 = "allocating the IDC node table item list";
          if (!v54) {
            goto LABEL_143;
          }
          *(_DWORD *)(a1 + 244) = 20;
          xmlGenericErrorFunc v27 = v77;
        }

        uint64_t v34 = *(int *)(a1 + 240);
        *(_DWORD *)(a1 + 240) = v34 + 1;
        *((void *)v54 + v34) = v27;
        LODWORD(v34) = -1;
        goto LABEL_98;
      }

      __int128 v76 = v26;
      xmlGenericErrorFunc v28 = *(void *)(a1 + 192);
      xmlGenericErrorFunc v29 = *(const xmlChar **)(v28 + 32);
      uint64_t v30 = xmlDictLookup(*(xmlDictPtr *)(a1 + 272), *(const xmlChar **)(v28 + 24), -1);
      if (v30)
      {
        uint64_t v31 = (uint64_t)v30;
        if (!v29 || (xmlGenericErrorFunc v29 = xmlDictLookup(*(xmlDictPtr *)(a1 + 272), v29, -1)) != 0LL)
        {
          uint64_t v32 = *(void *)(a1 + 312);
          uint64_t v33 = *(_DWORD *)(v32 + 8);
          if (v33 < 1)
          {
LABEL_54:
            xmlSchemaItemListAdd(v32, v31);
            xmlSchemaItemListAdd(*(void *)(a1 + 312), (uint64_t)v29);
            xmlGenericErrorFunc v27 = (uint64_t)v76;
            *((_DWORD *)v76 + 5) = v33;
            if (v33 == -1) {
              goto LABEL_137;
            }
            goto LABEL_99;
          }

          uint64_t v34 = 0LL;
          xmlGenericErrorFunc v35 = *(void *)v32;
          while (*(void *)(v35 + 8 * v34) != v31 || *(const xmlChar **)(v35 + 8 * v34 + 8) != v29)
          {
            v34 += 2LL;
          }

          xmlGenericErrorFunc v27 = (uint64_t)v76;
LABEL_98:
          *(_DWORD *)(v27 + 20) = v34;
LABEL_99:
          *(void *)xmlGenericErrorFunc v27 = *(void *)(a1 + 112);
          *(_DWORD *)(v27 + 16) = *(_DWORD *)(*(void *)(a1 + 192) + 16LL);
          *(void *)(v27 + 8) = *v81;
          xmlChar *v81 = 0LL;
          __int128 v78 = (int *)v17;
          v58 = v27;
          xmlGenericErrorFunc v59 = xmlSchemaItemListAdd((uint64_t)v80, v27);
          v60 = *v78;
          if (v59 == -1)
          {
            if (v60 == 24)
            {
              xmlFree(*(void **)(v58 + 8));
              ((void (*)(uint64_t))xmlFree)(v58);
            }

            return 0xFFFFFFFFLL;
          }

          if (v60 != 24)
          {
            name = 0LL;
            if (!*(void *)(v16 + 64)) {
              *(void *)(v16 + 64) = xmlHashCreate(4);
            }
            xmlSchemaFormatIDCKeySequence_1((_DWORD *)a1, &name, *(void *)(v58 + 8), v79, 1);
            xmlGenericErrorFunc v61 = xmlMalloc(0x10uLL);
            v61[2] = *((_DWORD *)v80 + 2) - 1;
            uint64_t v62 = name;
            v63 = xmlHashLookup(*(xmlHashTablePtr *)(v16 + 64), name);
            if (v63)
            {
              *(void *)xmlGenericErrorFunc v61 = *v63;
              const char *v63 = v61;
            }

            else
            {
              *(void *)xmlGenericErrorFunc v61 = 0LL;
              xmlHashAddEntry(*(xmlHashTablePtr *)(v16 + 64), v62, v61);
            }

            if (v62) {
              xmlFree(v62);
            }
          }

      ++v4;
      ++v6;
      ++v7;
    }

    while (v4 != a3);
  }

  return result;
}

    int v17 = 4;
    goto LABEL_30;
  }

  if (*i == 46)
  {
    for (mm = i + 1; ; ++mm)
    {
      ctxt->cur = mm;
      int v5 = *mm;
      xmlGenericErrorFunc v6 = v5 > 0x20;
      uint64_t v7 = (1LL << v5) & 0x100002600LL;
      if (v6 || v7 == 0) {
        break;
      }
    }

    xmlXPathCompExprAdd((uint64_t)ctxt, *((_DWORD *)ctxt->comp + 4), 0xFFFFFFFF, 0xAu, 0xAu, 1u, 0, 0LL, 0LL);
  }

  else
  {
    do
    {
      ctxt->cur = i;
      int v14 = *i++;
      BOOL v15 = (1LL << v14) & 0x100002600LL;
    }

    while (v14 <= 0x20 && v15 != 0);
  }

void *xmlParseXMLCatalogOneNode( xmlNode *node, int a2, const xmlChar *a3, xmlChar *name, xmlChar *a5, int a6, uint64_t a7)
{
  if (name)
  {
    Prop = xmlGetProp(node, name);
    if (!Prop)
    {
      __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)node,  0x14u,  1650,  2,  0LL,  0,  a3,  name,  0LL,  0,  0,  "%s entry lacks '%s'\n",  (char)a3);
      BOOL v15 = xmlGetProp(node, a5);
      if (v15) {
        ((void (*)(xmlChar *))xmlFree)(v15);
      }
      else {
        __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)node,  0x14u,  1650,  2,  0LL,  0,  a3,  a5,  0LL,  0,  0,  "%s entry lacks '%s'\n",  (char)a3);
      }
      return 0LL;
    }
  }

  else
  {
    Prop = 0LL;
  }

  uint64_t v16 = xmlGetProp(node, a5);
  if (!v16)
  {
    __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)node,  0x14u,  1650,  2,  0LL,  0,  a3,  a5,  0LL,  0,  0,  "%s entry lacks '%s'\n",  (char)a3);
    if (Prop) {
      ((void (*)(xmlChar *))xmlFree)(Prop);
    }
    return 0LL;
  }

  int v17 = v16;
  Base = xmlNodeGetBase(node->doc, node);
  uint64_t v19 = xmlBuildURI(v17, Base);
  if (v19)
  {
    if (xmlDebugCatalogs >= 2)
    {
      xmlGenericErrorFunc v20 = *__xmlGenericError();
      BOOL v21 = *__xmlGenericErrorContext();
      if (Prop) {
        unsigned int v22 = "Found %s: '%s' '%s'\n";
      }
      else {
        unsigned int v22 = "Found %s: '%s'\n";
      }
      v20(v21, v22);
    }

    xmlGenericErrorFunc v23 = xmlNewCatalogEntry(a2, Prop, v17, v19, a6, a7);
    if (!Prop) {
      goto LABEL_21;
    }
  }

  else
  {
    __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  (uint64_t)node,  0x14u,  1651,  2,  0LL,  0,  a3,  a5,  v17,  0,  0,  "%s entry '%s' broken ?: %s\n",  (char)a3);
    xmlGenericErrorFunc v23 = 0LL;
    if (!Prop) {
      goto LABEL_21;
    }
  }

  xmlFree(Prop);
LABEL_21:
  xmlFree(v17);
  if (Base) {
    xmlFree(Base);
  }
  if (v19) {
    xmlFree(v19);
  }
  return v23;
}

xmlNodePtr xmlDumpXMLCatalogNode(xmlNodePtr result, xmlNode *a2, xmlDoc *a3, xmlNs *a4, xmlNs *a5)
{
  if (result)
  {
    xmlNodePtr v9 = result;
    p_name = &result->name;
    xmlNodePtr v11 = result;
    do
    {
      if (v11->ns == a5)
      {
        switch(LODWORD(v11->children))
        {
          case 1:
          case 2:
            if (v11 == v9) {
              xmlNodePtr v11 = (xmlNodePtr)p_name;
            }
            break;
          case 3:
            unsigned int v22 = xmlNewDocNode(a3, a4, (const xmlChar *)"nextCatalog", 0LL);
            unsigned int v13 = v22;
            parent = (const xmlChar *)v11->parent;
            goto LABEL_22;
          case 4:
            unsigned int v13 = xmlNewDocNode(a3, a4, (const xmlChar *)"group", 0LL);
            xmlSetProp(v13, (const xmlChar *)"id", (const xmlChar *)v11->last);
            if (v11->parent)
            {
              uint64_t v24 = xmlSearchNsByHref(a3, v13, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
              if (v24) {
                xmlSetNsProp(v13, v24, (const xmlChar *)"base", (const xmlChar *)v11->parent);
              }
            }

            int prev = (int)v11->prev;
            if (prev == 1)
            {
              uint64_t v26 = "public";
            }

            else
            {
              if (prev != 2) {
                goto LABEL_33;
              }
              uint64_t v26 = "system";
            }

            xmlSetProp(v13, (const xmlChar *)"prefer", (const xmlChar *)v26);
LABEL_33:
            xmlDumpXMLCatalogNode(v11->_private, v13, a3, a4, v11);
LABEL_28:
            uint64_t result = xmlAddChild(a2, v13);
            break;
          case 5:
            uint64_t v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"public", 0LL);
            unsigned int v13 = v12;
            last = (const xmlChar *)v11->last;
            BOOL v15 = "publicId";
            goto LABEL_24;
          case 6:
            uint64_t v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"system", 0LL);
            unsigned int v13 = v12;
            last = (const xmlChar *)v11->last;
            BOOL v15 = "systemId";
            goto LABEL_24;
          case 7:
            uint64_t v16 = xmlNewDocNode(a3, a4, (const xmlChar *)"rewriteSystem", 0LL);
            unsigned int v13 = v16;
            int v17 = (const xmlChar *)v11->last;
            uint64_t v18 = "systemIdStartString";
            goto LABEL_26;
          case 8:
            uint64_t v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegatePublic", 0LL);
            unsigned int v13 = v19;
            xmlGenericErrorFunc v20 = (const xmlChar *)v11->last;
            BOOL v21 = "publicIdStartString";
            goto LABEL_21;
          case 9:
            uint64_t v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegateSystem", 0LL);
            unsigned int v13 = v19;
            xmlGenericErrorFunc v20 = (const xmlChar *)v11->last;
            BOOL v21 = "systemIdStartString";
            goto LABEL_21;
          case 0xA:
            uint64_t v12 = xmlNewDocNode(a3, a4, (const xmlChar *)"uri", 0LL);
            unsigned int v13 = v12;
            last = (const xmlChar *)v11->last;
            BOOL v15 = "name";
LABEL_24:
            xmlSetProp(v12, (const xmlChar *)v15, last);
            parent = (const xmlChar *)v11->parent;
            unsigned int v22 = v13;
            xmlGenericErrorFunc v27 = "uri";
            goto LABEL_27;
          case 0xB:
            uint64_t v16 = xmlNewDocNode(a3, a4, (const xmlChar *)"rewriteURI", 0LL);
            unsigned int v13 = v16;
            int v17 = (const xmlChar *)v11->last;
            uint64_t v18 = "uriStartString";
LABEL_26:
            xmlSetProp(v16, (const xmlChar *)v18, v17);
            parent = (const xmlChar *)v11->parent;
            unsigned int v22 = v13;
            xmlGenericErrorFunc v27 = "rewritePrefix";
            goto LABEL_27;
          case 0xC:
            uint64_t v19 = xmlNewDocNode(a3, a4, (const xmlChar *)"delegateURI", 0LL);
            unsigned int v13 = v19;
            xmlGenericErrorFunc v20 = (const xmlChar *)v11->last;
            BOOL v21 = "uriStartString";
LABEL_21:
            xmlSetProp(v19, (const xmlChar *)v21, v20);
            parent = (const xmlChar *)v11->parent;
            unsigned int v22 = v13;
LABEL_22:
            xmlGenericErrorFunc v27 = "catalog";
LABEL_27:
            xmlSetProp(v22, (const xmlChar *)v27, parent);
            goto LABEL_28;
          default:
            break;
        }
      }

      xmlNodePtr v11 = (xmlNodePtr)v11->_private;
    }

    while (v11);
  }

  return result;
}

xmlRMutexPtr _xmlInitializeCatalogData()
{
  if (getenv("XML_DEBUG_CATALOG")) {
    xmlDebugCatalogs = 1;
  }
  xmlRMutexPtr result = xmlNewRMutex();
  xmlCatalogMutex = (uint64_t)result;
  return result;
}

int xmlCharInRange(unsigned int val, const xmlChRangeGroup *group)
{
  if (!group) {
    return 0;
  }
  if (!HIWORD(val))
  {
    int nbShortRange = group->nbShortRange;
    if (group->nbShortRange)
    {
      BOOL v3 = __OFSUB__(nbShortRange, 1);
      int v4 = nbShortRange - 1;
      if (v4 < 0 == v3)
      {
        int v5 = 0;
        shortRange = group->shortRange;
        do
        {
          int v7 = v4 + v5;
          if (v4 + v5 < 0 != __OFADD__(v4, v5)) {
            ++v7;
          }
          int v8 = v7 >> 1;
          uint64_t v9 = (uint64_t)v7 >> 1;
          if (shortRange[v8].low <= val)
          {
            int v5 = v9 + 1;
          }

          else
          {
            int v4 = v9 - 1;
          }
        }

        while (v5 <= v4);
      }
    }

    return 0;
  }

  int nbLongRange = group->nbLongRange;
  if (!nbLongRange) {
    return 0;
  }
  BOOL v3 = __OFSUB__(nbLongRange, 1);
  int v11 = nbLongRange - 1;
  if (v11 < 0 != v3) {
    return 0;
  }
  int v12 = 0;
  longRange = group->longRange;
  while (1)
  {
    int v14 = v11 + v12;
    if (v11 + v12 < 0 != __OFADD__(v11, v12)) {
      ++v14;
    }
    int v15 = v14 >> 1;
    uint64_t v16 = (uint64_t)v14 >> 1;
    if (longRange[v15].low <= val) {
      break;
    }
    int v11 = v16 - 1;
LABEL_23:
    if (v12 > v11) {
      return 0;
    }
  }

  if (longRange[v16].high < val)
  {
    int v12 = v16 + 1;
    goto LABEL_23;
  }

  return 1;
}

int xmlIsBaseChar(unsigned int ch)
{
  if (ch > 0xFF) {
    return xmlCharInRange(ch, &xmlIsBaseCharGroup);
  }
  return ch - 192 < 0x17 || (ch & 0xFFFFFFDF) - 65 < 0x1A || ch - 216 < 0x1F || ch > 0xF7;
}

int xmlIsBlank(unsigned int ch)
{
  BOOL v3 = ch == 32 || ch - 9 < 2 || ch == 13;
  return ch <= 0xFF && v3;
}

int xmlIsChar(unsigned int ch)
{
  if (ch > 0xFF) {
    return ch >> 11 < 0x1B || (ch - 57344) >> 1 < 0xFFF || ch - 0x10000 < 0x100000;
  }
  if (ch > 0xD) {
    return ch > 0x1F;
  }
  int v1 = 1;
  if (((1 << ch) & 0x2600) == 0) {
    return ch > 0x1F;
  }
  return v1;
}

int xmlIsCombining(unsigned int ch)
{
  if (ch >= 0x100) {
    return xmlCharInRange(ch, &xmlIsCombiningGroup);
  }
  else {
    return 0;
  }
}

int xmlIsDigit(unsigned int ch)
{
  if (ch > 0xFF) {
    return xmlCharInRange(ch, &xmlIsDigitGroup);
  }
  else {
    return ch - 48 < 0xA;
  }
}

int xmlIsExtender(unsigned int ch)
{
  if (ch > 0xFF) {
    return xmlCharInRange(ch, &xmlIsExtenderGroup);
  }
  else {
    return ch == 183;
  }
}

int xmlIsIdeographic(unsigned int ch)
{
  BOOL v3 = ch == 12295 || ch - 19968 < 0x51A6 || ch - 12321 < 9;
  return ch >= 0x100 && v3;
}

int xmlIsPubidChar(unsigned int ch)
{
  if (ch > 0xFF) {
    return 0;
  }
  else {
    return xmlIsPubidChar_tab[ch];
  }
}

void xmlDebugDumpString(FILE *output, const xmlChar *str)
{
  if (output) {
    unsigned int v2 = output;
  }
  else {
    unsigned int v2 = (FILE *)*MEMORY[0x1895F89E0];
  }
  if (!str)
  {
    int v7 = "(NULL)";
    size_t v8 = 6LL;
    goto LABEL_20;
  }

  for (uint64_t i = 0LL; i != 40; ++i)
  {
    int v5 = str[i];
    if (v5 == 32) {
      goto LABEL_13;
    }
    if (!str[i]) {
      return;
    }
    if ((v5 - 9) < 2 || v5 == 13)
    {
LABEL_13:
      int v5 = 32;
LABEL_14:
      fputc(v5, v2);
      continue;
    }

    if ((v5 & 0x80) == 0) {
      goto LABEL_14;
    }
    fprintf(v2, "#%X", str[i]);
  }

  int v7 = "...";
  size_t v8 = 3LL;
LABEL_20:
  fwrite(v7, v8, 1uLL, v2);
}

void xmlDebugDumpAttr(FILE *output, xmlAttrPtr attr, int depth)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (output)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v13 = 0LL;
    *(void *)&__int128 v3 = 0x2020202020202020LL;
    *((void *)&v3 + 1) = 0x2020202020202020LL;
    __int128 v5 = v3;
    __int128 v6 = v3;
    __int128 v7 = v3;
    __int128 v8 = v3;
    __int128 v9 = v3;
    __int128 v10 = v3;
    int v4 = output;
    uint64_t v11 = 538976288LL;
    uint64_t v12 = depth;
    xmlCtxtDumpAttr((size_t)&v4, (uint64_t)attr);
  }

size_t xmlCtxtDumpAttr(size_t a1, uint64_t a2)
{
  size_t result = xmlCtxtDumpSpaces(a1);
  int v5 = *(_DWORD *)(a1 + 144);
  if (a2)
  {
    if (!v5)
    {
      fwrite("ATTRIBUTE ", 0xAuLL, 1uLL, *(FILE **)a1);
      xmlCtxtDumpString(a1, *(void *)(a2 + 16));
      fputc(10, *(FILE **)a1);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v6)
      {
        ++*(_DWORD *)(a1 + 112);
        do
        {
          xmlCtxtDumpNode(a1, v6);
          uint64_t v6 = *(void *)(v6 + 48);
        }

        while (v6);
        --*(_DWORD *)(a1 + 112);
      }
    }

    if (!*(void *)(a2 + 16)) {
      xmlDebugErr(a1, 5015, (char)"Attribute has no name");
    }
    return xmlCtxtGenericNodeCheck(a1, a2);
  }

  else if (!v5)
  {
    return fwrite("Attr is NULL", 0xCuLL, 1uLL, *(FILE **)a1);
  }

  return result;
}

void xmlDebugDumpEntities(FILE *output, xmlDocPtr doc)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (output)
  {
    uint64_t v16 = 0LL;
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    uint64_t v17 = 0LL;
    *(void *)&__int128 v3 = 0x2020202020202020LL;
    *((void *)&v3 + 1) = 0x2020202020202020LL;
    __int128 v9 = v3;
    __int128 v10 = v3;
    __int128 v11 = v3;
    __int128 v12 = v3;
    __int128 v13 = v3;
    __int128 v14 = v3;
    uint64_t v15 = 538976288LL;
    __stream = output;
    if (doc)
    {
      xmlCtxtDumpDocHead(&__stream, (uint64_t)doc);
      intSubset = doc->intSubset;
      if (intSubset && (entities = (xmlHashTable *)intSubset->entities) != 0LL)
      {
        if (!(_DWORD)v20) {
          fwrite("Entities in internal subset\n", 0x1CuLL, 1uLL, __stream);
        }
        xmlHashScan(entities, (xmlHashScanner)xmlCtxtDumpEntityCallback, &__stream);
      }

      else
      {
        fwrite("No entities in internal subset\n", 0x1FuLL, 1uLL, __stream);
      }

      extSubset = doc->extSubset;
      if (extSubset && (__int128 v7 = (xmlHashTable *)extSubset->entities) != 0LL)
      {
        if (!(_DWORD)v20) {
          fwrite("Entities in external subset\n", 0x1CuLL, 1uLL, __stream);
        }
        xmlHashScan(v7, (xmlHashScanner)xmlCtxtDumpEntityCallback, &__stream);
      }

      else if (!(_DWORD)v20)
      {
        fwrite("No entities in external subset\n", 0x1FuLL, 1uLL, __stream);
      }
    }
  }

void xmlDebugDumpAttrList(FILE *output, xmlAttrPtr attr, int depth)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (output)
  {
    xmlAttrPtr v3 = attr;
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    uint64_t v14 = 0LL;
    *(void *)&__int128 v4 = 0x2020202020202020LL;
    *((void *)&v4 + 1) = 0x2020202020202020LL;
    __int128 v6 = v4;
    __int128 v7 = v4;
    __int128 v8 = v4;
    __int128 v9 = v4;
    __int128 v10 = v4;
    __int128 v11 = v4;
    int v5 = output;
    uint64_t v12 = 538976288LL;
  }

void xmlDebugDumpOneNode(FILE *output, xmlNodePtr node, int depth)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (output)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v13 = 0LL;
    *(void *)&__int128 v3 = 0x2020202020202020LL;
    *((void *)&v3 + 1) = 0x2020202020202020LL;
    __int128 v5 = v3;
    __int128 v6 = v3;
    __int128 v7 = v3;
    __int128 v8 = v3;
    __int128 v9 = v3;
    __int128 v10 = v3;
    __int128 v4 = output;
    uint64_t v11 = 538976288LL;
    uint64_t v12 = depth;
    xmlCtxtDumpOneNode((uint64_t)&v4, (uint64_t)node);
  }

_DWORD *xmlCtxtDumpOneNode(uint64_t a1, uint64_t a2)
{
  size_t result = (_DWORD *)MEMORY[0x1895F8858](a1, a2);
  size_t v4 = (size_t)result;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!v3)
  {
    if (!result[36])
    {
      xmlCtxtDumpSpaces((uint64_t)result);
      __int128 v10 = *(FILE **)v4;
      uint64_t v11 = "node is NULL\n";
      size_t v12 = 13LL;
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    }

    return result;
  }

  uint64_t v5 = v3;
  *((void *)result + 16) = v3;
  int v6 = *(_DWORD *)(v3 + 8);
  switch(v6)
  {
    case 1:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      fwrite("ELEMENT ", 8uLL, 1uLL, *(FILE **)v4);
      uint64_t v13 = *(void *)(v5 + 72);
      if (v13)
      {
        uint64_t v14 = *(void *)(v13 + 24);
        if (v14)
        {
          xmlCtxtDumpString(v4, v14);
          fputc(58, *(FILE **)v4);
        }
      }

      xmlCtxtDumpString(v4, *(void *)(v5 + 16));
      goto LABEL_83;
    case 2:
      if (!result[36]) {
        xmlCtxtDumpSpaces((uint64_t)result);
      }
      __int128 v7 = *(FILE **)v4;
      __int128 v8 = "Error, ATTRIBUTE found here\n";
      size_t v9 = 28LL;
      goto LABEL_21;
    case 3:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(const xmlChar **)(v5 + 16) == "textnoenc")
      {
        uint64_t v15 = "TEXT no enc";
        size_t v16 = 11LL;
      }

      else
      {
        uint64_t v15 = "TEXT";
        size_t v16 = 4LL;
      }

      fwrite(v15, v16, 1uLL, *(FILE **)v4);
      if ((*(_BYTE *)(v4 + 156) & 1) != 0)
      {
        xmlGenericErrorFunc v37 = *(const xmlChar **)(v5 + 80);
        if (v37 == (const xmlChar *)(v5 + 88))
        {
          uint64_t v17 = *(FILE **)v4;
          uint64_t v18 = " compact\n";
LABEL_42:
          size_t v19 = 9LL;
        }

        else
        {
          int v38 = xmlDictOwns(*(xmlDictPtr *)(v4 + 136), v37);
          uint64_t v17 = *(FILE **)v4;
          if (v38 != 1)
          {
            xmlGenericErrorFunc v27 = *(FILE **)v4;
            goto LABEL_84;
          }

          uint64_t v18 = " interned\n";
          size_t v19 = 10LL;
        }

LABEL_43:
        fwrite(v18, v19, 1uLL, v17);
        goto LABEL_85;
      }

    uint64_t v15 = xmlNewDoc((const xmlChar *)"SAX compatibility mode document");
    ctxt->myDoc = v15;
    if (!v15)
    {
      htmlErrMemory(ctxt, (uint64_t)"New Doc failed");
      return;
    }

    v15->properties = 64;
    goto LABEL_45;
  }

    ++v18;
  }

  while (v18 != v4);
  uint64_t v5 = *(_DWORD *)(a1 + 296);
  if (!v5) {
    return 0LL;
  }
LABEL_54:
  if ((*(_BYTE *)(a1 + 148) & 1) != 0
    && (uint64_t v31 = *(void *)(*(void *)(a1 + 176) + 8LL * *(int *)(a1 + 172))) != 0
    && (xmlEntityPtr v32 = *(xmlNode **)(v31 + 8)) != 0LL)
  {
    if (v32->doc) {
      uint64_t v33 = v32;
    }
    else {
      uint64_t v33 = 0LL;
    }
  }

  else
  {
    uint64_t v33 = 0LL;
  }

  if (v5 < 1) {
    goto LABEL_149;
  }
  size_t v35 = 0LL;
  uint64_t v36 = &xmlFree;
  while (2)
  {
    xmlGenericErrorFunc v37 = *(void *)(*(void *)(a1 + 288) + 8 * v35);
    int v38 = *(_DWORD *)(v37 + 88);
    if (v38 == 8 || v38 == 2)
    {
      if (!*(void *)(v37 + 56))
      {
        *(_DWORD *)(v37 + 88) = 6;
        goto LABEL_127;
      }

      *(void *)(a1 + 192) = v37;
      if (*(void *)(a1 + 208))
      {
        uint64_t v40 = xmlSchemaXPathEvaluate(a1, 2);
        if (v40 == -1) {
          goto LABEL_151;
        }
        size_t v41 = v40;
        int v38 = *(_DWORD *)(v37 + 88);
      }

      else
      {
        size_t v41 = 0;
      }

      if (v38 == 8)
      {
        if (!v33 && !v41) {
          goto LABEL_124;
        }
        size_t v42 = *(void *)(v37 + 80);
        int v43 = *(void *)(v42 + 56);
        if (v43)
        {
          int v44 = (xmlSchemaVal **)(v42 + 64);
        }

        else
        {
          size_t v49 = *(void *)(v37 + 72);
          int v43 = *(void *)(v49 + 88);
          int v44 = (xmlSchemaVal **)(v49 + 136);
        }

        uint64_t v50 = *v44;
        *(void *)(v37 + 40) = v43;
        *(void *)(v37 + 48) = v50;
        if (!v50)
        {
          __int128 v82 = "default/fixed value on an attribute use was not precomputed";
          goto LABEL_152;
        }

        uint64_t v51 = xmlSchemaCopyValue(v50);
        *(void *)(v37 + 48) = v51;
        if (!v51)
        {
          __int128 v82 = "calling xmlSchemaCopyValue()";
LABEL_152:
          xmlSchemaInternalErr2((_DWORD *)a1, (const xmlChar *)"xmlSchemaVAttributesComplex", (const xmlChar *)v82, 0LL);
LABEL_153:
          *(void *)(a1 + 192) = *(void *)(*(void *)(a1 + 176) + 8LL * *(int *)(a1 + 172));
          return 0xFFFFFFFFLL;
        }

        if (v33)
        {
          uint64_t v52 = *(const xmlChar **)(v37 + 40);
          xmlGenericErrorFunc v53 = xmlSchemaNormalizeValue(*(_DWORD **)(v37 + 56), v52);
          int v54 = v53;
          if (v53) {
            uint64_t v52 = v53;
          }
          v55 = *(const xmlChar **)(v37 + 32);
          if (v55)
          {
            xmlGenericErrorFunc v56 = xmlSearchNsByHref(v33->doc, v33, v55);
            if (!v56)
            {
              xmlListPtr v57 = v36;
              v58 = 0;
              __int128 v85 = 0;
              *(void *)__str = 0LL;
              while (1)
              {
                snprintf(__str, 0xCuLL, "p%d", v58);
                xmlGenericErrorFunc v59 = xmlSearchNs(v33->doc, v33, (const xmlChar *)__str);
                if (v58 == 1000) {
                  break;
                }
                ++v58;
                if (!v59)
                {
                  xmlGenericErrorFunc v56 = xmlNewNs(*(xmlNodePtr *)(a1 + 152), *(const xmlChar **)(v37 + 32), (const xmlChar *)__str);
                  uint64_t v36 = v57;
                  goto LABEL_103;
                }
              }

              xmlSchemaInternalErr2( (_DWORD *)a1,  (const xmlChar *)"xmlSchemaVAttributesComplex",  (const xmlChar *)"could not compute a ns prefix for a default/fixed attribute",  0LL);
              if (v54) {
                ((void (*)(xmlChar *))*v57)(v54);
              }
              goto LABEL_153;
            }

LABEL_83:
      xmlGenericErrorFunc v27 = *(FILE **)v4;
LABEL_84:
      fputc(10, v27);
LABEL_85:
      if (!*(void *)(v5 + 64))
      {
        if (!*(_DWORD *)(v4 + 144)) {
          xmlCtxtDumpSpaces(v4);
        }
        fwrite("PBM: doc == NULL !!!\n", 0x15uLL, 1uLL, *(FILE **)v4);
      }

      ++*(_DWORD *)(v4 + 112);
      int v28 = *(_DWORD *)(v5 + 8);
      if (v28 == 1)
      {
        xmlGenericErrorFunc v29 = *(void **)(v5 + 96);
        if (!v29) {
          goto LABEL_93;
        }
        do
        {
          xmlCtxtDumpNamespace(v4, (uint64_t)v29);
          xmlGenericErrorFunc v29 = (void *)*v29;
        }

        while (v29);
        int v28 = *(_DWORD *)(v5 + 8);
        if (v28 == 1)
        {
LABEL_93:
          uint64_t v30 = *(void *)(v5 + 88);
          if (!v30) {
            goto LABEL_105;
          }
          do
          {
            xmlCtxtDumpAttr(v4, v30);
            uint64_t v30 = *(void *)(v30 + 48);
          }

          while (v30);
          int v28 = *(_DWORD *)(v5 + 8);
        }
      }

      if (v28 != 1)
      {
        if (v28 == 5)
        {
          xmlEntityPtr DocEntity = xmlGetDocEntity(*(const xmlDoc **)(v5 + 64), *(const xmlChar **)(v5 + 16));
          if (!DocEntity) {
            goto LABEL_105;
          }
          xmlEntityPtr v32 = DocEntity;
          xmlCtxtDumpSpaces(v4);
          if (*(_DWORD *)(v4 + 144)) {
            goto LABEL_105;
          }
          switch(v32->etype)
          {
            case XML_INTERNAL_GENERAL_ENTITY:
              uint64_t v33 = *(FILE **)v4;
              uint64_t v34 = "INTERNAL_GENERAL_ENTITY ";
              size_t v35 = 24LL;
              goto LABEL_116;
            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
              uint64_t v33 = *(FILE **)v4;
              uint64_t v34 = "EXTERNAL_GENERAL_PARSED_ENTITY ";
              size_t v35 = 31LL;
              goto LABEL_116;
            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
              uint64_t v33 = *(FILE **)v4;
              uint64_t v34 = "EXTERNAL_GENERAL_UNPARSED_ENTITY ";
              size_t v35 = 33LL;
              goto LABEL_116;
            case XML_INTERNAL_PARAMETER_ENTITY:
              uint64_t v33 = *(FILE **)v4;
              uint64_t v34 = "INTERNAL_PARAMETER_ENTITY ";
              goto LABEL_115;
            case XML_EXTERNAL_PARAMETER_ENTITY:
              uint64_t v33 = *(FILE **)v4;
              uint64_t v34 = "EXTERNAL_PARAMETER_ENTITY ";
LABEL_115:
              size_t v35 = 26LL;
LABEL_116:
              fwrite(v34, v35, 1uLL, v33);
              break;
            default:
              fprintf(*(FILE **)v4, "ENTITY_%d ! ", v32->etype);
              break;
          }

          fprintf(*(FILE **)v4, "%s\n", (const char *)v32->name);
          if (v32->ExternalID)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "ExternalID=%s\n", (const char *)v32->ExternalID);
          }

          if (v32->SystemID)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "SystemID=%s\n", (const char *)v32->SystemID);
          }

          if (v32->URI)
          {
            xmlCtxtDumpSpaces(v4);
            fprintf(*(FILE **)v4, "URI=%s\n", (const char *)v32->URI);
          }

          content = v32->content;
          p_content = (uint64_t *)&v32->content;
          if (!content) {
            goto LABEL_105;
          }
        }

        else
        {
          p_content = (uint64_t *)(v5 + 80);
          if (!*(void *)(v5 + 80) || *(_DWORD *)(v4 + 144)) {
            goto LABEL_105;
          }
        }

        xmlCtxtDumpSpaces(v4);
        fwrite("content=", 8uLL, 1uLL, *(FILE **)v4);
        xmlCtxtDumpString(v4, *p_content);
        fputc(10, *(FILE **)v4);
      }

    xmlRngPErr(a1, a2, 1006, "expecting name, anyName, nsName or choice : got %s\n", *(const xmlChar **)(a2 + 16), 0LL);
    return 0LL;
  }

  Content = xmlNodeGetContent((const xmlNode *)a2);
  xmlRelaxNGNormExtSpace(Content);
  if (xmlValidateNCName(Content, 0))
  {
    size_t v16 = *(void *)(a2 + 40);
    if (v16)
    {
      uint64_t v17 = *(const xmlChar **)(v16 + 16);
      uint64_t v18 = "Element %s name '%s' is not an NCName\n";
      size_t v19 = a1;
      uint64_t v20 = a2;
      uint64_t v21 = Content;
    }

    else
    {
      uint64_t v18 = "name '%s' is not an NCName\n";
      size_t v19 = a1;
      uint64_t v20 = a2;
      uint64_t v17 = Content;
      uint64_t v21 = 0LL;
    }

    xmlRngPErr(v19, v20, 1019, v18, v17, v21);
  }

  *((void *)v6 + 2) = Content;
  uint64_t v25 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"ns");
  uint64_t v26 = v25;
  *((void *)v6 + 3) = v25;
  if ((*(_BYTE *)(a1 + 64) & 1) != 0 && v25 && xmlStrEqual(v25, (const xmlChar *)"http://www.w3.org/2000/xmlns")) {
    xmlRngPErr(a1, a2, 1122, "Attribute with namespace '%s' is not allowed\n", v26, 0LL);
  }
  if ((*(_BYTE *)(a1 + 64) & 1) == 0
    || !v26
    || *v26
    || !xmlStrEqual(*((const xmlChar **)v6 + 2), (const xmlChar *)"xmlns"))
  {
    goto LABEL_49;
  }

  xmlGenericErrorFunc v27 = "Attribute with QName 'xmlns' is not allowed\n";
  int v28 = a1;
  xmlGenericErrorFunc v29 = a2;
  uint64_t v30 = 1121;
  uint64_t v31 = v26;
LABEL_48:
  xmlRngPErr(v28, v29, v30, v27, v31, 0LL);
LABEL_49:
  if (v6 == (_OWORD *)a3) {
    return (_OWORD *)a3;
  }
  xmlEntityPtr v32 = *(void *)(a3 + 80);
  if (v32)
  {
    do
    {
      uint64_t v33 = v32;
      xmlEntityPtr v32 = *(void *)(v32 + 64);
    }

    while (v32);
    *(void *)(v33 + 64) = v6;
  }

  else
  {
    *(void *)(a3 + 80) = v6;
  }

  return v6;
}

LABEL_105:
      --*(_DWORD *)(v4 + 112);
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 4:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "CDATA_SECTION\n";
      goto LABEL_39;
    case 5:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        fprintf(*(FILE **)v4, "ENTITY_REF(%s)\n");
      }

      goto LABEL_85;
    case 6:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "ENTITY\n";
      size_t v19 = 7LL;
      goto LABEL_43;
    case 7:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        fprintf(*(FILE **)v4, "PI %s\n");
      }

      goto LABEL_85;
    case 8:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "COMMENT\n";
      size_t v19 = 8LL;
      goto LABEL_43;
    case 9:
    case 13:
      if (!result[36]) {
        xmlCtxtDumpSpaces((uint64_t)result);
      }
      __int128 v7 = *(FILE **)v4;
      __int128 v8 = "Error, DOCUMENT found here\n";
      size_t v9 = 27LL;
LABEL_21:
      fwrite(v8, v9, 1uLL, v7);
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 10:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "DOCUMENT_TYPE\n";
      goto LABEL_39;
    case 11:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "DOCUMENT_FRAG\n";
LABEL_39:
      size_t v19 = 14LL;
      goto LABEL_43;
    case 12:
      if (result[36]) {
        goto LABEL_85;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      uint64_t v17 = *(FILE **)v4;
      uint64_t v18 = "NOTATION\n";
      goto LABEL_42;
    case 14:
      return xmlCtxtDumpDtdNode((uint64_t)result, v3);
    case 15:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 15) {
        return xmlDebugErr(v4, 5025, (char)"Node is not an element declaration");
      }
      if (*(void *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
        {
          fwrite("ELEMDECL(", 9uLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(void *)(v5 + 16));
          fputc(41, *(FILE **)v4);
        }
      }

      else
      {
        xmlDebugErr(v4, 5015, (char)"Element declaration has no name");
      }

      if (!*(_DWORD *)(v4 + 144))
      {
        switch(*(_DWORD *)(v5 + 72))
        {
          case 0:
            uint64_t v20 = *(FILE **)v4;
            uint64_t v21 = ", UNDEFINED";
            size_t v22 = 11LL;
            goto LABEL_130;
          case 1:
            uint64_t v20 = *(FILE **)v4;
            uint64_t v21 = ", EMPTY";
            size_t v22 = 7LL;
            goto LABEL_130;
          case 2:
            uint64_t v20 = *(FILE **)v4;
            uint64_t v21 = ", ANY";
            size_t v22 = 5LL;
            goto LABEL_130;
          case 3:
          case 4:
            uint64_t v20 = *(FILE **)v4;
            uint64_t v21 = ", MIXED ";
            size_t v22 = 8LL;
LABEL_130:
            fwrite(v21, v22, 1uLL, v20);
            break;
          default:
            break;
        }

        if (*(_DWORD *)(v5 + 8) != 1)
        {
          uint64_t v40 = *(xmlElementContent **)(v5 + 80);
          if (v40)
          {
            bzero(buf, 0x1389uLL);
            xmlSnprintfElementContent(buf, 5000, v40, 1);
            buf[5000] = 0;
            fputs(buf, *(FILE **)v4);
          }
        }

        fputc(10, *(FILE **)v4);
      }

      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 16:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 16) {
        return xmlDebugErr(v4, 5024, (char)"Node is not an attribute declaration");
      }
      if (*(void *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144)) {
          fprintf(*(FILE **)v4, "ATTRDECL(%s)", *(const char **)(v5 + 16));
        }
      }

      else
      {
        xmlDebugErr(v4, 5015, (char)"Node attribute declaration has no name");
      }

      if (*(void *)(v5 + 112))
      {
        if (!*(_DWORD *)(v4 + 144)) {
          fprintf(*(FILE **)v4, " for %s", *(const char **)(v5 + 112));
        }
      }

      else
      {
        xmlDebugErr(v4, 5016, (char)"Node attribute declaration has no element name");
      }

      if (*(_DWORD *)(v4 + 144)) {
        return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
      }
      switch(*(_DWORD *)(v5 + 80))
      {
        case 1:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " CDATA";
          goto LABEL_153;
        case 2:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " ID";
          size_t v42 = 3LL;
          goto LABEL_163;
        case 3:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " IDREF";
LABEL_153:
          size_t v42 = 6LL;
          goto LABEL_163;
        case 4:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " IDREFS";
          goto LABEL_156;
        case 5:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " ENTITY";
LABEL_156:
          size_t v42 = 7LL;
          goto LABEL_163;
        case 6:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " ENTITIES";
          goto LABEL_160;
        case 7:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " NMTOKEN";
          size_t v42 = 8LL;
          goto LABEL_163;
        case 8:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " NMTOKENS";
LABEL_160:
          size_t v42 = 9LL;
          goto LABEL_163;
        case 9:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " ENUMERATION";
          size_t v42 = 12LL;
          goto LABEL_163;
        case 0xA:
          uint64_t v25 = *(FILE **)v4;
          uint64_t v26 = " NOTATION ";
          size_t v42 = 10LL;
LABEL_163:
          fwrite(v26, v42, 1uLL, v25);
          break;
        default:
          break;
      }

      int v43 = *(void **)(v5 + 96);
      if (!v43) {
        goto LABEL_173;
      }
      int v44 = 5;
      while (1)
      {
        uint64_t v45 = *(FILE **)v4;
        if (v44 == 5) {
          fprintf(v45, " (%s");
        }
        else {
          fprintf(v45, "|%s");
        }
        int v43 = (void *)*v43;
        if (!v43) {
          break;
        }
        if (!--v44)
        {
          fwrite("...)", 4uLL, 1uLL, *(FILE **)v4);
          goto LABEL_173;
        }
      }

      fputc(41, *(FILE **)v4);
LABEL_173:
      int v46 = *(_DWORD *)(v5 + 84);
      switch(v46)
      {
        case 4:
          int v47 = *(FILE **)v4;
          int v48 = " FIXED";
          size_t v49 = 6LL;
          break;
        case 3:
          int v47 = *(FILE **)v4;
          int v48 = " IMPLIED";
          size_t v49 = 8LL;
          break;
        case 2:
          int v47 = *(FILE **)v4;
          int v48 = " REQUIRED";
          size_t v49 = 9LL;
          break;
        default:
          goto LABEL_180;
      }

      fwrite(v48, v49, 1uLL, v47);
LABEL_180:
      if (*(void *)(v5 + 88))
      {
        fputc(34, *(FILE **)v4);
        xmlCtxtDumpString(v4, *(void *)(v5 + 88));
        fputc(34, *(FILE **)v4);
      }

    a3 = v27;
    goto LABEL_106;
  }

  size_t result = __xmlStructuredError();
  if (*(void *)result || !*v27)
  {
    size_t result = __xmlGenericError();
    a2 = *(void (**)(void *, const char *, ...))result;
    goto LABEL_105;
  }

  uint64_t v62 = 176LL;
  if (a8 == 1) {
    uint64_t v62 = 168LL;
  }
  a2 = *(void (**)(void *, const char *, ...))(*v27 + v62);
  a3 = (void *)v27[1];
LABEL_106:
  if (a2)
  {
LABEL_107:
    if (a2 == xmlParserValidityWarning
      || a2 == xmlParserValidityError
      || a2 == xmlParserError
      || a2 == xmlParserWarning)
    {
      xmlListPtr v57 = v26;
      v58 = (uint64_t)v27;
      xmlGenericErrorFunc v59 = v33;
      v60 = 0LL;
      xmlGenericErrorFunc v61 = 0LL;
    }

    else
    {
      xmlListPtr v57 = v26;
      v58 = (uint64_t)v27;
      xmlGenericErrorFunc v59 = v33;
      v60 = a2;
      xmlGenericErrorFunc v61 = (uint64_t)a3;
    }

    return (_DWORD *)xmlReportError(v57, v58, v59, v60, v61);
  }

  return result;
}

      if (!v47) {
        goto LABEL_121;
      }
      v60 = *(xmlSchemaVal **)(v37 + 48);
      if (!v60)
      {
        uint64_t v68 = *__xmlGenericError();
        __int128 v69 = *__xmlGenericErrorContext();
        v68( v69,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xmlschemas.c",  25980);
        goto LABEL_121;
      }

      xmlGenericErrorFunc v61 = *(void *)(v37 + 80);
      if (v61 && (uint64_t v62 = *(void *)(v61 + 56)) != 0)
      {
        v63 = *(xmlSchemaVal **)(v61 + 64);
        if (!v63)
        {
          uint64_t v64 = *__xmlGenericError();
          v65 = *__xmlGenericErrorContext();
          uint64_t v66 = 25987;
LABEL_120:
          v64( v65,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xmlschemas.c",  v66);
          goto LABEL_121;
        }
      }

      else
      {
        xmlAttrPtr v67 = *(void *)(v37 + 72);
        v63 = *(xmlSchemaVal **)(v67 + 136);
        if (!v63)
        {
          uint64_t v64 = *__xmlGenericError();
          v65 = *__xmlGenericErrorContext();
          uint64_t v66 = 26002;
          goto LABEL_120;
        }

        uint64_t v62 = *(void *)(v67 + 88);
      }

      *(void *)(v37 + 96) = v62;
      goto LABEL_121;
    }

  v58 = *(int **)(v6 + 32);
  if (!v58 || ((xmlGenericErrorFunc v59 = *v58, v59 != 1) ? (v60 = v59 == 7) : (v60 = 1), v60))
  {
    size_t v4 = valuePop((xmlXPathParserContextPtr)v6);
  }

  else
  {
    xmlXPtrErr(v6, 1902, "xmlXPtrEval: evaluation failed to return a node set\n", 0LL);
    size_t v4 = 0LL;
  }

  xmlGenericErrorFunc v61 = valuePop((xmlXPathParserContextPtr)v6);
  if (v61)
  {
    uint64_t v62 = 0;
    do
    {
      if (v61->type != XPATH_NODESET
        || (nodesetval = v61->nodesetval) == 0LL
        || nodesetval->nodeNr != 1
        || *nodesetval->nodeTab != (xmlNodePtr)ctx->doc)
      {
        ++v62;
      }

      xmlXPathFreeObject(v61);
      xmlGenericErrorFunc v61 = valuePop((xmlXPathParserContextPtr)v6);
    }

    while (v61);
    if (v62) {
      xmlXPtrErr(v6, 1903, "xmlXPtrEval: object(s) left on the eval stack\n", 0LL);
    }
  }

  if (*(_DWORD *)(v6 + 16))
  {
    xmlXPathFreeObject(v4);
    size_t v4 = 0LL;
  }

  xmlXPathFreeParserContext((xmlXPathParserContextPtr)v6);
  return v4;
}

LABEL_182:
      fputc(10, *(FILE **)v4);
      return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
    case 17:
      xmlCtxtDumpSpaces((uint64_t)result);
      if (*(_DWORD *)(v5 + 8) != 17) {
        return xmlDebugErr(v4, 5026, (char)"Node is not an entity declaration");
      }
      if (*(void *)(v5 + 16))
      {
        if (!*(_DWORD *)(v4 + 144))
        {
          fwrite("ENTITYDECL(", 0xBuLL, 1uLL, *(FILE **)v4);
          xmlCtxtDumpString(v4, *(void *)(v5 + 16));
          fputc(41, *(FILE **)v4);
        }
      }

      else
      {
        xmlDebugErr(v4, 5015, (char)"Entity declaration has no name");
      }

      if (*(_DWORD *)(v4 + 144)) {
        return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
      }
      switch(*(_DWORD *)(v5 + 92))
      {
        case 1:
          xmlGenericErrorFunc v23 = *(FILE **)v4;
          uint64_t v24 = ", internal\n";
          goto LABEL_138;
        case 2:
          xmlGenericErrorFunc v23 = *(FILE **)v4;
          uint64_t v24 = ", external parsed\n";
          size_t v41 = 18LL;
          goto LABEL_142;
        case 3:
          xmlGenericErrorFunc v23 = *(FILE **)v4;
          uint64_t v24 = ", unparsed\n";
LABEL_138:
          size_t v41 = 11LL;
          goto LABEL_142;
        case 4:
          xmlGenericErrorFunc v23 = *(FILE **)v4;
          uint64_t v24 = ", parameter\n";
          size_t v41 = 12LL;
          goto LABEL_142;
        case 5:
          xmlGenericErrorFunc v23 = *(FILE **)v4;
          uint64_t v24 = ", external parameter\n";
          size_t v41 = 21LL;
          goto LABEL_142;
        case 6:
          xmlGenericErrorFunc v23 = *(FILE **)v4;
          uint64_t v24 = ", predefined\n";
          size_t v41 = 13LL;
LABEL_142:
          fwrite(v24, v41, 1uLL, v23);
          break;
        default:
          break;
      }

      if (*(void *)(v5 + 96))
      {
        xmlCtxtDumpSpaces(v4);
        fprintf(*(FILE **)v4, " ExternalID=%s\n", *(const char **)(v5 + 96));
      }

      if (*(void *)(v5 + 104))
      {
        xmlCtxtDumpSpaces(v4);
        fprintf(*(FILE **)v4, " SystemID=%s\n", *(const char **)(v5 + 104));
      }

      if (*(void *)(v5 + 120))
      {
        xmlCtxtDumpSpaces(v4);
        fprintf(*(FILE **)v4, " URI=%s\n", *(const char **)(v5 + 120));
      }

      if (!*(void *)(v5 + 80)) {
        return (_DWORD *)xmlCtxtGenericNodeCheck(v4, v5);
      }
      xmlCtxtDumpSpaces(v4);
      fwrite(" content=", 9uLL, 1uLL, *(FILE **)v4);
      xmlCtxtDumpString(v4, *(void *)(v5 + 80));
      goto LABEL_182;
    case 18:
      return xmlCtxtDumpNamespace((size_t)result, v3);
    case 19:
      if (result[36]) {
        return result;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      __int128 v10 = *(FILE **)v4;
      uint64_t v11 = "INCLUDE START\n";
      size_t v12 = 14LL;
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    case 20:
      if (result[36]) {
        return result;
      }
      xmlCtxtDumpSpaces((uint64_t)result);
      __int128 v10 = *(FILE **)v4;
      uint64_t v11 = "INCLUDE END\n";
      size_t v12 = 12LL;
      return (_DWORD *)fwrite(v11, v12, 1uLL, v10);
    default:
      if (!result[36])
      {
        xmlCtxtDumpSpaces((uint64_t)result);
        int v6 = *(_DWORD *)(v5 + 8);
      }

      return xmlDebugErr3(v4, 5011, "Unknown node type %d\n", v6);
  }

            uint64_t v17 = (v82 + 5);
            if (!v10 || (int)v17 > v132)
            {
              if ((xmlCtxtGrowAttrs(a1, (int)v82 + 5) & 0x80000000) != 0)
              {
                size_t v16 = 0LL;
                uint64_t v18 = &xmlFree;
                goto LABEL_270;
              }

              v132 = *(_DWORD *)(a1 + 472);
              __int128 v10 = *(void *)(a1 + 464);
            }

            __int128 v90 = (uint64_t *)(v10 + 8LL * (int)v82);
            const char *v90 = v85;
            v90[1] = (uint64_t)name2;
            __int128 v91 = name2;
            if (name2)
            {
              __int128 v92 = (xmlChar **)(a1 + 496);
              if (*(xmlChar **)(a1 + 480) == name2)
              {
LABEL_192:
                __int128 v91 = *v92;
              }

              else
              {
                __int128 v93 = *(_DWORD *)(a1 + 508);
                while (1)
                {
                  uint64_t v94 = __OFSUB__(v93, 2);
                  v93 -= 2;
                  if (v93 < 0 != v94) {
                    break;
                  }
                  int v95 = *(void *)(a1 + 520);
                  if (*(xmlChar **)(v95 + 8LL * v93) == name2)
                  {
                    __int128 v92 = (xmlChar **)(v95 + 8LL * (v93 + 1));
                    goto LABEL_192;
                  }
                }

                __int128 v91 = 0LL;
              }
            }

            *(void *)(v10 + 8 * ((int)v82 + 2LL)) = v91;
            v106 = &v79[10 * v80];
            v107 = v10 + 8LL * (int)v82;
            *(void *)(v107 + 24) = *((void *)v106 + 3);
            *(void *)(v107 + 32) = *((void *)v106 + 4);
            if (*(_DWORD *)(a1 + 48) == 1 && *((void *)v106 + 5)) {
              xmlValidityError( (uint64_t *)a1,  538,  (uint64_t)"standalone: attribute %s on %s defaulted from external subset\n",  v85,  v16);
            }
            __int128 v81 = (v81 + 1);
LABEL_221:
            ++v80;
            __int128 v82 = v17;
            if (v80 >= *v79) {
              goto LABEL_225;
            }
          }

          __int128 v88 = v134;
          if (v134 >= 1)
          {
            v96 = (void *)(*(void *)(a1 + 520) + 8LL * *(int *)(a1 + 508) - 16);
            v97 = (v134 + 1) - 1LL;
            while (*v96)
            {
              v96 -= 2;
              if (!--v97) {
                goto LABEL_197;
              }
            }

            goto LABEL_215;
          }

  if (*((int *)reader + 75) >= 1)
  {
    v60 = *((_DWORD *)reader + 6);
    if (v60 != 2 && v60 != 4)
    {
      xmlGenericErrorFunc v61 = 0LL;
      while (xmlPatternMatch(*(xmlPatternPtr *)(*((void *)reader + 39) + 8 * v61), *((xmlNodePtr *)reader + 14)) != 1)
      {
      }

      xmlTextReaderPreserve(reader);
    }
  }

void xmlDebugDumpNode(FILE *output, xmlNodePtr node, int depth)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v3 = (FILE *)*MEMORY[0x1895F89E0];
  if (output) {
    uint64_t v3 = output;
  }
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v14 = 0LL;
  *(void *)&__int128 v4 = 0x2020202020202020LL;
  *((void *)&v4 + 1) = 0x2020202020202020LL;
  __int128 v6 = v4;
  __int128 v7 = v4;
  __int128 v8 = v4;
  __int128 v9 = v4;
  __int128 v10 = v4;
  __int128 v11 = v4;
  uint64_t v5 = v3;
  LODWORD(v12) = 538976288;
  LODWORD(v13) = depth;
  xmlCtxtDumpNode(&v5, (uint64_t)node);
}

FILE **xmlCtxtDumpNode(FILE **result, uint64_t a2)
{
  unsigned int v2 = result;
  if (a2)
  {
    size_t result = (FILE **)xmlCtxtDumpOneNode((uint64_t)result, a2);
    int v4 = *(_DWORD *)(a2 + 8);
    if (v4 != 18)
    {
      uint64_t v5 = *(void *)(a2 + 24);
      if (v4 != 5 && v5 != 0)
      {
        ++*((_DWORD *)v2 + 28);
        do
        {
          size_t result = (FILE **)xmlCtxtDumpNode(v2, v5);
          uint64_t v5 = *(void *)(v5 + 48);
        }

        while (v5);
        --*((_DWORD *)v2 + 28);
      }
    }
  }

  else if (!*((_DWORD *)result + 36))
  {
    xmlCtxtDumpSpaces((uint64_t)result);
    return (FILE **)fwrite("node is NULL\n", 0xDuLL, 1uLL, *v2);
  }

  return result;
}

void xmlDebugDumpNodeList(FILE *output, xmlNodePtr node, int depth)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v3 = (FILE *)*MEMORY[0x1895F89E0];
  if (output) {
    uint64_t v3 = output;
  }
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v15 = 0LL;
  *(void *)&__int128 v4 = 0x2020202020202020LL;
  *((void *)&v4 + 1) = 0x2020202020202020LL;
  __int128 v7 = v4;
  __int128 v8 = v4;
  __int128 v9 = v4;
  __int128 v10 = v4;
  __int128 v11 = v4;
  __int128 v12 = v4;
  __int128 v6 = v3;
  LODWORD(v13) = 538976288;
  LODWORD(v14) = depth;
  if (node)
  {
    xmlNodePtr v5 = node;
    do
    {
      xmlCtxtDumpNode(&v6, (uint64_t)v5);
      xmlNodePtr v5 = v5->next;
    }

    while (v5);
  }

void xmlDebugDumpDocumentHead(FILE *output, xmlDocPtr doc)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  unsigned int v2 = (FILE *)*MEMORY[0x1895F89E0];
  if (output) {
    unsigned int v2 = output;
  }
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v13 = 0LL;
  *(void *)&__int128 v3 = 0x2020202020202020LL;
  *((void *)&v3 + 1) = 0x2020202020202020LL;
  __int128 v5 = v3;
  __int128 v6 = v3;
  __int128 v7 = v3;
  __int128 v8 = v3;
  __int128 v9 = v3;
  __int128 v10 = v3;
  LODWORD(v11) = 538976288;
  __int128 v16 = xmmword_181A37060;
  __int128 v4 = v2;
  xmlCtxtDumpDocumentHead((size_t)&v4, (uint64_t)doc);
}

size_t xmlCtxtDumpDocumentHead(size_t result, uint64_t a2)
{
  if (a2)
  {
    size_t v3 = result;
    size_t result = (size_t)xmlCtxtDumpDocHead((_DWORD *)result, a2);
    if (!*(_DWORD *)(v3 + 144))
    {
      if (*(void *)(a2 + 16))
      {
        fwrite("name=", 5uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 16));
        size_t result = fputc(10, *(FILE **)v3);
      }

      if (*(void *)(a2 + 104))
      {
        fwrite("version=", 8uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 104));
        size_t result = fputc(10, *(FILE **)v3);
      }

      if (*(void *)(a2 + 112))
      {
        fwrite("encoding=", 9uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 112));
        size_t result = fputc(10, *(FILE **)v3);
      }

      if (*(void *)(a2 + 136))
      {
        fwrite("URL=", 4uLL, 1uLL, *(FILE **)v3);
        xmlCtxtDumpString(v3, *(void *)(a2 + 136));
        size_t result = fputc(10, *(FILE **)v3);
      }

      if (*(_DWORD *)(a2 + 76)) {
        size_t result = fwrite("standalone=true\n", 0x10uLL, 1uLL, *(FILE **)v3);
      }
    }

    for (uint64_t i = *(void **)(a2 + 96); i; uint64_t i = (void *)*i)
      size_t result = (size_t)xmlCtxtDumpNamespace(v3, (uint64_t)i);
  }

  return result;
}

void xmlDebugDumpDocument(FILE *output, xmlDocPtr doc)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  unsigned int v2 = (FILE *)*MEMORY[0x1895F89E0];
  if (output) {
    unsigned int v2 = output;
  }
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v13 = 0LL;
  *(void *)&__int128 v3 = 0x2020202020202020LL;
  *((void *)&v3 + 1) = 0x2020202020202020LL;
  __int128 v5 = v3;
  __int128 v6 = v3;
  __int128 v7 = v3;
  __int128 v8 = v3;
  __int128 v9 = v3;
  __int128 v10 = v3;
  LODWORD(v11) = 538976288;
  __int128 v16 = xmmword_181A37060;
  __int128 v4 = v2;
  xmlCtxtDumpDocument((size_t)&v4, (uint64_t)doc);
}

size_t xmlCtxtDumpDocument(size_t result, uint64_t a2)
{
  size_t v2 = result;
  if (a2)
  {
    size_t result = xmlCtxtDumpDocumentHead(result, a2);
    if ((*(_DWORD *)(a2 + 8) | 4) == 0xD)
    {
      uint64_t v4 = *(void *)(a2 + 24);
      if (v4)
      {
        ++*(_DWORD *)(v2 + 112);
        do
        {
          size_t result = (size_t)xmlCtxtDumpNode((FILE **)v2, v4);
          uint64_t v4 = *(void *)(v4 + 48);
        }

        while (v4);
        --*(_DWORD *)(v2 + 112);
      }
    }
  }

  else if (!*(_DWORD *)(result + 144))
  {
    return fwrite("DOCUMENT == NULL !\n", 0x13uLL, 1uLL, *(FILE **)result);
  }

  return result;
}

void xmlDebugDumpDTD(FILE *output, xmlDtdPtr dtd)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  if (output) {
    size_t v2 = output;
  }
  else {
    size_t v2 = (FILE *)*MEMORY[0x1895F89E0];
  }
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v17 = 0LL;
  *(void *)&__int128 v3 = 0x2020202020202020LL;
  *((void *)&v3 + 1) = 0x2020202020202020LL;
  __int128 v9 = v3;
  __int128 v10 = v3;
  __int128 v11 = v3;
  __int128 v12 = v3;
  __int128 v13 = v3;
  __int128 v14 = v3;
  LODWORD(v15) = 538976288;
  __int128 v20 = xmmword_181A37060;
  __stream = v2;
  if (!dtd)
  {
    __int128 v6 = "DTD is NULL\n";
    size_t v7 = 12LL;
LABEL_11:
    fwrite(v6, v7, 1uLL, v2);
    return;
  }

  xmlCtxtDumpDtdNode((uint64_t)&__stream, (uint64_t)dtd);
  children = dtd->children;
  if (!children)
  {
    size_t v2 = __stream;
    __int128 v6 = "    DTD is empty\n";
    size_t v7 = 17LL;
    goto LABEL_11;
  }

  LODWORD(v16) = v16 + 1;
  do
  {
    xmlCtxtDumpNode(&__stream, (uint64_t)children);
    children = children->next;
  }

  while (children);
}

int xmlDebugCheckDocument(FILE *output, xmlDocPtr doc)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  size_t v2 = (FILE *)*MEMORY[0x1895F89E0];
  if (output) {
    size_t v2 = output;
  }
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v14 = 0LL;
  *(void *)&__int128 v3 = 0x2020202020202020LL;
  *((void *)&v3 + 1) = 0x2020202020202020LL;
  __int128 v6 = v3;
  __int128 v7 = v3;
  __int128 v8 = v3;
  __int128 v9 = v3;
  __int128 v10 = v3;
  __int128 v11 = v3;
  LODWORD(v12) = 538976288;
  __int128 v5 = v2;
  __int128 v17 = xmmword_181A37070;
  xmlCtxtDumpDocument((size_t)&v5, (uint64_t)doc);
  return DWORD1(v17);
}

int xmlLsCountNode(xmlNodePtr node)
{
  if (node)
  {
    switch(node->type)
    {
      case XML_ELEMENT_NODE:
      case XML_ATTRIBUTE_NODE:
      case XML_DOCUMENT_NODE:
      case XML_HTML_DOCUMENT_NODE:
      case XML_DOCB_DOCUMENT_NODE:
        children = node->children;
        if (!children) {
          goto LABEL_11;
        }
        LODWORD(node) = 0;
        do
        {
          children = children->next;
          LODWORD(node) = (_DWORD)node + 1;
        }

        while (children);
        break;
      case XML_TEXT_NODE:
      case XML_CDATA_SECTION_NODE:
      case XML_PI_NODE:
      case XML_COMMENT_NODE:
        node = (xmlNodePtr)node->content;
        if (node) {
          LODWORD(node) = xmlStrlen((const xmlChar *)node);
        }
        break;
      case XML_ENTITY_REF_NODE:
      case XML_ENTITY_NODE:
      case XML_DOCUMENT_TYPE_NODE:
      case XML_DOCUMENT_FRAG_NODE:
      case XML_NOTATION_NODE:
      case XML_DTD_NODE:
      case XML_ELEMENT_DECL:
      case XML_ATTRIBUTE_DECL:
      case XML_ENTITY_DECL:
      case XML_NAMESPACE_DECL:
      case XML_XINCLUDE_START:
      case XML_XINCLUDE_END:
        LODWORD(node) = 1;
        break;
      default:
LABEL_11:
        LODWORD(node) = 0;
        break;
    }
  }

  return (int)node;
}

void xmlLsOneNode(FILE *output, xmlNodePtr node)
{
  if (output)
  {
    if (node)
    {
      unsigned __int32 v4 = node->type - 1;
      if (v4 > 0x11) {
        int v5 = 63;
      }
      else {
        int v5 = dword_181A37014[v4];
      }
      fputc(v5, output);
      if (node->type != XML_NAMESPACE_DECL)
      {
        if (node->properties) {
          int v6 = 97;
        }
        else {
          int v6 = 45;
        }
        fputc(v6, output);
        if (node->nsDef) {
          int v7 = 110;
        }
        else {
          int v7 = 45;
        }
        fputc(v7, output);
      }

      int v8 = xmlLsCountNode(node);
      fprintf(output, " %8d ", v8);
      switch(node->type)
      {
        case XML_ELEMENT_NODE:
          name = (const char *)node->name;
          if (name)
          {
            ns = node->ns;
            if (ns)
            {
              prefix = (const char *)ns->prefix;
              if (prefix)
              {
                fprintf(output, "%s:", prefix);
                name = (const char *)node->name;
              }
            }

            goto LABEL_18;
          }

          break;
        case XML_TEXT_NODE:
          content = node->content;
          if (content) {
            xmlDebugDumpString(output, content);
          }
          break;
        case XML_CDATA_SECTION_NODE:
        case XML_COMMENT_NODE:
        case XML_DOCUMENT_NODE:
        case XML_DOCUMENT_TYPE_NODE:
        case XML_DOCUMENT_FRAG_NODE:
        case XML_NOTATION_NODE:
        case XML_HTML_DOCUMENT_NODE:
          break;
        case XML_NAMESPACE_DECL:
          if (node->children) {
            fprintf(output, "%s -> %s");
          }
          else {
            fprintf(output, "default -> %s");
          }
          break;
        default:
          name = (const char *)node->name;
          if (name) {
LABEL_18:
          }
            fputs(name, output);
          break;
      }

      fputc(10, output);
    }

    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, output);
    }
  }

const char *__cdecl xmlBoolToText(int BOOLval)
{
  if (BOOLval) {
    return "True";
  }
  else {
    return "False";
  }
}

void xmlShellPrintXPathError(int errorType, const char *arg)
{
  if (errorType <= 9 && ((0x3FDu >> errorType) & 1) != 0)
  {
    size_t v2 = off_189B9B830[errorType];
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    unsigned __int32 v4 = __xmlGenericErrorContext();
    v3(*v4, v2);
  }

void xmlShellPrintNode(xmlNodePtr node)
{
  if (node)
  {
    int v1 = (FILE *)*MEMORY[0x1895F89E0];
    xmlElementType type = node->type;
    if (type == XML_ATTRIBUTE_NODE)
    {
      xmlDebugDumpAttrList((FILE *)*MEMORY[0x1895F89E0], (xmlAttrPtr)node, 0);
    }

    else if (type == XML_DOCUMENT_NODE)
    {
      xmlDocDump((FILE *)*MEMORY[0x1895F89E0], (xmlDocPtr)node);
    }

    else
    {
      xmlElemDump((FILE *)*MEMORY[0x1895F89E0], node->doc, node);
    }

    fputc(10, v1);
  }

int xmlShellList(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  if (ctxt)
  {
    if (node)
    {
      xmlElementType type = node->type;
      if (type == XML_DOCUMENT_NODE || type == XML_HTML_DOCUMENT_NODE)
      {
        children = node->children;
        if (!children) {
          return 0;
        }
      }

      else if (type == XML_NAMESPACE_DECL || (children = node->children) == 0LL)
      {
        xmlLsOneNode(ctxt->output, node);
        return 0;
      }

      do
      {
        xmlLsOneNode(ctxt->output, children);
        children = children->next;
      }

      while (children);
    }

    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }

  return 0;
}

int xmlShellBase(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  if (ctxt)
  {
    if (node)
    {
      Base = xmlNodeGetBase(node->doc, node);
      output = ctxt->output;
      if (Base)
      {
        int v7 = Base;
        fprintf(output, "%s\n", (const char *)Base);
        xmlFree(v7);
        return 0;
      }

      int v8 = " No base found !!!\n";
      size_t v9 = 19LL;
    }

    else
    {
      output = ctxt->output;
      int v8 = "NULL\n";
      size_t v9 = 5LL;
    }

    fwrite(v8, v9, 1uLL, output);
  }

  return 0;
}

int xmlShellDir(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (ctxt)
  {
    if (node)
    {
      xmlElementType type = node->type;
      if (type == XML_ATTRIBUTE_NODE)
      {
        xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr)node, 0);
      }

      else if (type == XML_HTML_DOCUMENT_NODE || type == XML_DOCUMENT_NODE)
      {
        output = ctxt->output;
        uint64_t v16 = 0LL;
        uint64_t v17 = 0LL;
        if (!output) {
          output = (FILE *)*MEMORY[0x1895F89E0];
        }
        __int128 v18 = 0u;
        __int128 v19 = 0u;
        uint64_t v20 = 0x100000000LL;
        *(void *)&__int128 v7 = 0x2020202020202020LL;
        *((void *)&v7 + 1) = 0x2020202020202020LL;
        __int128 v10 = v7;
        __int128 v11 = v7;
        __int128 v12 = v7;
        __int128 v13 = v7;
        __int128 v14 = v7;
        __int128 v15 = v7;
        LODWORD(v16) = 538976288;
        size_t v9 = output;
        xmlCtxtDumpDocumentHead((size_t)&v9, (uint64_t)node);
      }

      else
      {
        xmlDebugDumpOneNode(ctxt->output, node, 0);
      }
    }

    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }

  return 0;
}

int xmlShellCat(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr node, xmlNodePtr node2)
{
  if (ctxt)
  {
    if (node)
    {
      xmlDocPtr doc = ctxt->doc;
      xmlElementType type = node->type;
      output = ctxt->output;
      if (doc->type == XML_HTML_DOCUMENT_NODE)
      {
        if (type == XML_HTML_DOCUMENT_NODE) {
          htmlDocDump(output, (xmlDocPtr)node);
        }
        else {
          htmlNodeDumpFile(output, doc, node);
        }
      }

      else if (type == XML_DOCUMENT_NODE)
      {
        xmlDocDump(output, (xmlDocPtr)node);
      }

      else
      {
        xmlElemDump(output, doc, node);
      }

      fputc(10, ctxt->output);
    }

    else
    {
      fwrite("NULL\n", 5uLL, 1uLL, ctxt->output);
    }
  }

  return 0;
}

int xmlShellLoad(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  int result = -1;
  if (ctxt && filename)
  {
    xmlDocPtr doc = ctxt->doc;
    if (doc && doc->type == XML_HTML_DOCUMENT_NODE) {
      htmlDocPtr File = htmlParseFile(filename, 0LL);
    }
    else {
      htmlDocPtr File = xmlReadFile(filename, 0LL, 0);
    }
    size_t v9 = File;
    if (File)
    {
      if (ctxt->loaded == 1) {
        xmlFreeDoc(ctxt->doc);
      }
      ctxt->loaded = 1;
      xmlXPathFreeContext(ctxt->pctxt);
      xmlFree(ctxt->filename);
      ctxt->xmlDocPtr doc = v9;
      ctxt->node = (xmlNodePtr)v9;
      ctxt->pctxt = xmlXPathNewContext(v9);
      __int128 v10 = (char *)xmlCanonicPath((const xmlChar *)filename);
      int result = 0;
      ctxt->filename = v10;
    }

    else
    {
      return -1;
    }
  }

  return result;
}

int xmlShellWrite(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  int result = -1;
  if (filename && node && *filename)
  {
    xmlElementType type = node->type;
    if (type == XML_HTML_DOCUMENT_NODE)
    {
      if (htmlSaveFile(filename, ctxt->doc) < 0) {
        goto LABEL_13;
      }
    }

    else if (type == XML_DOCUMENT_NODE)
    {
      if (xmlSaveFile(filename, ctxt->doc) <= -2) {
        goto LABEL_13;
      }
    }

    else
    {
      size_t v9 = fopen(filename, "w");
      if (!v9)
      {
LABEL_13:
        xmlGenericErrorFunc v11 = *__xmlGenericError();
        __int128 v12 = __xmlGenericErrorContext();
        v11(*v12, "Failed to write to %s\n", filename);
        return -1;
      }

      __int128 v10 = v9;
      xmlElemDump(v9, ctxt->doc, node);
      fclose(v10);
    }

    return 0;
  }

  return result;
}

int xmlShellSave(xmlShellCtxtPtr ctxt, char *filename, xmlNodePtr node, xmlNodePtr node2)
{
  if (!ctxt) {
    return -1;
  }
  xmlDocPtr doc = ctxt->doc;
  if (doc)
  {
    if (filename && *filename || (filename = ctxt->filename) != 0LL)
    {
      xmlElementType type = doc->type;
      if (type == XML_HTML_DOCUMENT_NODE)
      {
        if ((htmlSaveFile(filename, doc) & 0x80000000) == 0) {
          return 0;
        }
        goto LABEL_9;
      }

      if (type == XML_DOCUMENT_NODE)
      {
        if ((xmlSaveFile(filename, doc) & 0x80000000) == 0) {
          return 0;
        }
LABEL_9:
        xmlGenericErrorFunc v7 = *__xmlGenericError();
        int v8 = __xmlGenericErrorContext();
        v7(*v8, "Failed to save to %s\n", filename);
        return 0;
      }

      xmlGenericErrorFunc v10 = *__xmlGenericError();
      xmlGenericErrorFunc v11 = __xmlGenericErrorContext();
      v10(*v11, "To save to subparts of a document use the 'write' command\n");
    }
  }

  return -1;
}

int xmlShellValidate(xmlShellCtxtPtr ctxt, char *dtd, xmlNodePtr node, xmlNodePtr node2)
{
  if (!ctxt || !ctxt->doc) {
    return -1;
  }
  memset(&v10, 0, sizeof(v10));
  v10.error = *__xmlGenericError();
  v10.warning = *__xmlGenericError();
  if (!dtd || !*dtd) {
    return xmlValidateDocument(&v10, ctxt->doc);
  }
  int v6 = xmlParseDTD(0LL, (const xmlChar *)dtd);
  if (!v6) {
    return -1;
  }
  xmlGenericErrorFunc v7 = v6;
  int v8 = xmlValidateDtd(&v10, ctxt->doc, v6);
  xmlFreeDtd(v7);
  return v8;
}

int xmlShellDu(xmlShellCtxtPtr ctxt, char *arg, xmlNodePtr tree, xmlNodePtr node2)
{
  int result = -1;
  if (!ctxt || !tree) {
    return result;
  }
  int v7 = 0;
  xmlNodePtr v8 = tree;
  while (1)
  {
    xmlElementType type = v8->type;
    if (type == XML_HTML_DOCUMENT_NODE || type == XML_DOCUMENT_NODE)
    {
      fwrite("/\n", 2uLL, 1uLL, ctxt->output);
    }

    else
    {
      if (type != XML_ELEMENT_NODE) {
        goto LABEL_18;
      }
      int v11 = v7;
      if (v7 >= 1)
      {
        do
        {
          fwrite("  ", 2uLL, 1uLL, ctxt->output);
          --v11;
        }

        while (v11);
      }

      ns = v8->ns;
      if (ns)
      {
        prefix = (const char *)ns->prefix;
        if (prefix) {
          fprintf(ctxt->output, "%s:", prefix);
        }
      }

      fprintf(ctxt->output, "%s\n", (const char *)v8->name);
    }

    xmlElementType type = v8->type;
LABEL_18:
    if ((type | 4) == 0xD)
    {
      children = v8->children;
      goto LABEL_20;
    }

    children = v8->children;
    if (type != XML_ENTITY_REF_NODE && children != 0LL)
    {
      ++v7;
      goto LABEL_20;
    }

    if (v8 == tree) {
      return 0;
    }
    children = v8->next;
    if (!children) {
      break;
    }
LABEL_20:
    xmlNodePtr v8 = children;
    if (!children) {
      return 0;
    }
  }

  while (v8 != tree)
  {
    parent = v8->parent;
    if (parent) {
      xmlNodePtr v8 = v8->parent;
    }
    v7 -= parent != 0LL;
    if (v8 == tree)
    {
      children = 0LL;
LABEL_37:
      if (children != tree) {
        goto LABEL_20;
      }
      return 0;
    }

    children = v8->next;
    if (!children)
    {
      children = v8->parent;
      if (children) {
        continue;
      }
    }

    goto LABEL_37;
  }

  return 0;
}

int xmlShellPwd(xmlShellCtxtPtr ctxt, char *buffer, xmlNodePtr node, xmlNodePtr node2)
{
  int result = -1;
  if (buffer && node)
  {
    NodePath = xmlGetNodePath(node);
    if (NodePath)
    {
      int v7 = NodePath;
      snprintf(buffer, 0x1F3uLL, "%s", (const char *)NodePath);
      buffer[499] = 48;
      xmlFree(v7);
      return 0;
    }

    else
    {
      return -1;
    }
  }

  return result;
}

void xmlShell(xmlDocPtr doc, char *filename, xmlShellReadlineFunc input, FILE *output)
{
  uint64_t v228 = *MEMORY[0x1895F89C0];
  __int128 v226 = 0u;
  __int128 v227 = 0u;
  __int128 v224 = 0u;
  __int128 v225 = 0u;
  __int128 v222 = 0u;
  __int128 v223 = 0u;
  __int128 v220 = 0u;
  __int128 v221 = 0u;
  __int128 v218 = 0u;
  __int128 v219 = 0u;
  __int128 v216 = 0u;
  __int128 v217 = 0u;
  __int128 v214 = 0u;
  __int128 v215 = 0u;
  __int128 v213 = 0u;
  __int128 v212 = 0u;
  __int128 v211 = 0u;
  __int128 v210 = 0u;
  __int128 v209 = 0u;
  __int128 v208 = 0u;
  __int128 v207 = 0u;
  __int128 v206 = 0u;
  __int128 v205 = 0u;
  __int128 v204 = 0u;
  __int128 v203 = 0u;
  __int128 v202 = 0u;
  __int128 v201 = 0u;
  __int128 v200 = 0u;
  __int128 v199 = 0u;
  __int128 v198 = 0u;
  *(_OWORD *)&__str[4] = 0u;
  *(_DWORD *)__str = 540942383;
  if (!doc) {
    return;
  }
  if (!filename) {
    return;
  }
  if (!input) {
    return;
  }
  xmlNodePtr v8 = (FILE *)*MEMORY[0x1895F89E0];
  size_t v9 = xmlMalloc(0x38uLL);
  if (!v9) {
    return;
  }
  uint64_t v10 = (uint64_t)v9;
  int v196 = 0;
  memset(v195, 0, sizeof(v195));
  *(_OWORD *)dtd = 0u;
  __int128 v171 = 0u;
  __int128 v172 = 0u;
  __int128 v173 = 0u;
  __int128 v174 = 0u;
  __int128 v175 = 0u;
  __int128 v176 = 0u;
  __int128 v177 = 0u;
  __int128 v178 = 0u;
  __int128 v179 = 0u;
  __int128 v180 = 0u;
  __int128 v181 = 0u;
  __int128 v182 = 0u;
  __int128 v183 = 0u;
  __int128 v184 = 0u;
  __int128 v185 = 0u;
  __int128 v186 = 0u;
  __int128 v187 = 0u;
  __int128 v188 = 0u;
  __int128 v189 = 0u;
  __int128 v190 = 0u;
  __int128 v191 = 0u;
  __int128 v192 = 0u;
  __int128 v193 = 0u;
  __int128 v194 = 0u;
  if (output) {
    int v11 = output;
  }
  else {
    int v11 = v8;
  }
  v9[8] = 0;
  *((void *)v9 + 1) = doc;
  *((void *)v9 + 5) = v11;
  *((void *)v9 + 6) = input;
  *(void *)size_t v9 = xmlStrdup((const xmlChar *)filename);
  __int128 v12 = *(xmlDoc **)(v10 + 8);
  *(void *)(v10 + 16) = v12;
  xmlXPathContextPtr v13 = xmlXPathNewContext(v12);
  *(void *)(v10 + 24) = v13;
  if (!v13)
  {
    xmlFree((void *)v10);
    return;
  }

  while (1)
  {
    do
    {
      uint64_t v14 = *(void *)(v10 + 16);
      if (v14 != *(void *)(v10 + 8))
      {
        if (!v14 || !*(void *)(v14 + 16))
        {
          strcpy(__str, "? > ");
          goto LABEL_17;
        }

        uint64_t v15 = *(void *)(v14 + 72);
        if (v15 && *(void *)(v15 + 24))
        {
          snprintf(__str, 0x1F4uLL, "%s:%s > ");
          goto LABEL_17;
        }
      }

      snprintf(__str, 0x1F4uLL, "%s > ");
LABEL_17:
      HIBYTE(v227) = 0;
      uint64_t v16 = (xmlShellCtxt *)(*(uint64_t (**)(_BYTE *))(v10 + 48))(__str);
      uint64_t v20 = v16;
      if (!v16) {
        goto LABEL_229;
      }
      for (uint64_t i = v16; ; uint64_t i = (xmlShellCtxt *)((char *)i + 1))
      {
        int filename_low = LOBYTE(i->filename);
        if (filename_low != 9 && filename_low != 32) {
          break;
        }
      }

      uint64_t v23 = 0LL;
      while (filename_low > 0x20u || ((1LL << filename_low) & 0x100002601LL) == 0)
      {
        uint64_t v24 = (unsigned __int8 *)i + v23;
        *((_BYTE *)v195 + v23++) = filename_low;
        LOBYTE(filename_low) = v24[1];
      }

      *((_BYTE *)v195 + v23) = 0;
    }

    while (!(_DWORD)v23);
    for (uint64_t j = (unsigned __int8 *)i + v23; ; ++j)
    {
      int v26 = *j;
      if (v26 != 9 && v26 != 32) {
        break;
      }
    }

    for (uint64_t k = 0LL; v26 > 0xDu || ((1 << v26) & 0x2401) == 0; ++k)
    {
      xmlGenericErrorFunc v29 = &j[k];
      dtd[k] = v26;
      LOBYTE(v26) = v29[1];
    }

    dtd[k] = 0;
    if (!(LODWORD(v195[0]) ^ 0x74697865 | BYTE4(v195[0]))
      || !(LODWORD(v195[0]) ^ 0x74697571 | BYTE4(v195[0]))
      || LODWORD(v195[0]) == 6650210)
    {
      break;
    }

    if (!(LODWORD(v195[0]) ^ 0x706C6568 | BYTE4(v195[0])))
    {
      fwrite("\tbase         display XML base of the node\n", 0x2BuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tsetbase URI  change the XML base of the node\n", 0x2EuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tbye          leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tcat [node]   display node or current node\n", 0x2BuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tcd [path]    change directory to path or to root\n", 0x32uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite( "\tdir [path]   dumps information about the node (namespace, attributes, content)\n",  0x50uLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite( "\tdu [path]    show the structure of the subtree under path or the current node\n",  0x4FuLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite("\texit         leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\thelp         display this help\n", 0x20uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tfree         display memory usage\n", 0x23uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tload [name]  load a new document with name\n", 0x2CuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tls [path]    list contents of path or the current directory\n", 0x3DuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite( "\tset xml_fragment replace the current node content with the fragment parsed in context\n",  0x57uLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite( "\txpath expr   evaluate the XPath expression in that context and print the result\n",  0x51uLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite( "\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n",  0x4FuLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite( "\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n",  0x51uLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite("\tsetrootns    register all namespace found on the root element\n", 0x3FuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite( "\t             the default namespace if any uses 'defaultns' prefix\n",  0x43uLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite("\tpwd          display current working directory\n", 0x30uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite( "\twhereis      display absolute path of [path] or current working directory\n",  0x4BuLL,  1uLL,  *(FILE **)(v10 + 40));
      fwrite("\tquit         leave shell\n", 0x1AuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tsave [name]  save this document to name or the original name\n", 0x3EuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\twrite [name] write the current node to the filename\n", 0x35uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tvalidate     check the document for errors\n", 0x2CuLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\trelaxng rng  validate the document against the Relax-NG schemas\n", 0x41uLL, 1uLL, *(FILE **)(v10 + 40));
      fwrite("\tgrep string  search for a string in the subtree\n", 0x31uLL, 1uLL, *(FILE **)(v10 + 40));
      goto LABEL_120;
    }

    if (!(*(void *)&v195[0] ^ 0x65746164696C6176LL | BYTE8(v195[0])))
    {
      xmlShellValidate((xmlShellCtxtPtr)v10, dtd, v18, v19);
      goto LABEL_120;
    }

    if (!(LODWORD(v195[0]) ^ 0x64616F6C | BYTE4(v195[0])))
    {
      xmlShellLoad((xmlShellCtxtPtr)v10, dtd, v18, v19);
      goto LABEL_120;
    }

    if (*(void *)&v195[0] == 0x676E78616C6572LL)
    {
      xmlGenericErrorFunc v37 = xmlRelaxNGNewParserCtxt(dtd);
      int v38 = *__xmlGenericError();
      uint64_t v39 = __xmlGenericError();
      xmlRelaxNGSetParserErrors(v37, v38, *v39, 0LL);
      uint64_t v40 = xmlRelaxNGParse(v37);
      xmlRelaxNGFreeParserCtxt(v37);
      if (v40)
      {
        size_t v41 = xmlRelaxNGNewValidCtxt(v40);
        size_t v42 = *__xmlGenericError();
        int v43 = __xmlGenericError();
        xmlRelaxNGSetValidErrors(v41, v42, *v43, 0LL);
        int v44 = xmlRelaxNGValidateDoc(v41, *(xmlDocPtr *)(v10 + 8));
        if (v44)
        {
          int v45 = v44;
          int v46 = (FILE *)*MEMORY[0x1895F89D0];
          if (v45 < 1) {
            fprintf(v46, "%s validation generated an internal error\n");
          }
          else {
            fprintf(v46, "%s fails to validate\n");
          }
        }

        else
        {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "%s validates\n");
        }

        xmlRelaxNGFreeValidCtxt(v41);
        xmlRelaxNGFree(v40);
      }

      else
      {
        xmlGenericErrorFunc v47 = *__xmlGenericError();
        int v48 = __xmlGenericErrorContext();
        v47(*v48, "Relax-NG schema %s failed to compile\n", dtd);
      }
    }

    else
    {
      if (!(LODWORD(v195[0]) ^ 0x65766173 | BYTE4(v195[0])))
      {
        xmlShellSave((xmlShellCtxtPtr)v10, dtd, v18, v19);
        goto LABEL_120;
      }

      if (LODWORD(v195[0]) == 1953067639 && WORD2(v195[0]) == 101)
      {
        if (dtd[0])
        {
          xmlShellWrite((xmlShellCtxtPtr)v10, dtd, *(xmlNodePtr *)(v10 + 16), v19);
          goto LABEL_120;
        }

        xmlGenericErrorFunc v34 = *__xmlGenericError();
        size_t v35 = *__xmlGenericErrorContext();
        uint64_t v36 = "Write command requires a filename argument\n";
        goto LABEL_122;
      }

      if (!(LODWORD(v195[0]) ^ 0x70657267 | BYTE4(v195[0])))
      {
        uint64_t v49 = *(void *)(v10 + 16);
        if (!v49) {
          goto LABEL_120;
        }
        if (!xmlStrchr((const xmlChar *)dtd, 0x3Fu)
          && !xmlStrchr((const xmlChar *)dtd, 0x2Au)
          && !xmlStrchr((const xmlChar *)dtd, 0x2Eu))
        {
          xmlStrchr((const xmlChar *)dtd, 0x5Bu);
        }

        while (2)
        {
          int v50 = *(_DWORD *)(v49 + 8);
          if (v50 == 3)
          {
            if (xmlStrstr(*(const xmlChar **)(v49 + 80), (const xmlChar *)dtd))
            {
              xmlListPtr v57 = *(FILE **)(v10 + 40);
              NodePath = xmlGetNodePath(*(const xmlNode **)(v49 + 40));
              fprintf(v57, "%s : ", (const char *)NodePath);
              xmlGenericErrorFunc v56 = *(xmlNode **)(v49 + 40);
              v55 = (xmlShellCtxt *)v10;
LABEL_97:
              xmlShellList(v55, v53, v56, v54);
            }

LABEL_98:
            int v50 = *(_DWORD *)(v49 + 8);
          }

          else if (v50 == 8)
          {
            if (xmlStrstr(*(const xmlChar **)(v49 + 80), (const xmlChar *)dtd))
            {
              uint64_t v51 = *(FILE **)(v10 + 40);
              uint64_t v52 = xmlGetNodePath((const xmlNode *)v49);
              fprintf(v51, "%s : ", (const char *)v52);
              v55 = (xmlShellCtxt *)v10;
              xmlGenericErrorFunc v56 = (xmlNode *)v49;
              goto LABEL_97;
            }

            goto LABEL_98;
          }

          if ((v50 | 4) == 0xD)
          {
            uint64_t v59 = *(void *)(v49 + 24);
          }

          else
          {
            uint64_t v59 = *(void *)(v49 + 24);
            if (v50 == 5 || v59 == 0)
            {
              uint64_t v59 = *(void *)(v49 + 48);
              if (!v59)
              {
                uint64_t v61 = *(void *)(v49 + 40);
                while (1)
                {
                  if (v61) {
                    uint64_t v49 = v61;
                  }
                  uint64_t v59 = *(void *)(v49 + 48);
                  if (v59) {
                    break;
                  }
                  uint64_t v61 = *(void *)(v49 + 40);
                  if (!v61) {
                    goto LABEL_120;
                  }
                }
              }
            }
          }

          uint64_t v49 = v59;
          if (!v59) {
            goto LABEL_120;
          }
          continue;
        }
      }

      if (LODWORD(v195[0]) ^ 0x65657266 | BYTE4(v195[0]))
      {
        if (LODWORD(v195[0]) == 6584176)
        {
          int v169 = 0;
          __int128 v167 = 0u;
          __int128 v168 = 0u;
          __int128 v165 = 0u;
          __int128 v166 = 0u;
          __int128 v163 = 0u;
          __int128 v164 = 0u;
          __int128 v161 = 0u;
          __int128 v162 = 0u;
          __int128 v159 = 0u;
          __int128 v160 = 0u;
          __int128 v157 = 0u;
          __int128 v158 = 0u;
          __int128 v155 = 0u;
          __int128 v156 = 0u;
          __int128 v153 = 0u;
          __int128 v154 = 0u;
          __int128 v151 = 0u;
          __int128 v152 = 0u;
          __int128 v149 = 0u;
          __int128 v150 = 0u;
          __int128 v147 = 0u;
          __int128 v148 = 0u;
          __int128 v145 = 0u;
          __int128 v146 = 0u;
          __int128 v143 = 0u;
          __int128 v144 = 0u;
          __int128 v141 = 0u;
          __int128 v142 = 0u;
          __int128 v139 = 0u;
          __int128 v140 = 0u;
          *(_OWORD *)buffer = 0u;
          if (xmlShellPwd(v16, buffer, *(xmlNodePtr *)(v10 + 16), v19)) {
            goto LABEL_120;
          }
LABEL_124:
          fprintf(*(FILE **)(v10 + 40), "%s\n", buffer);
          goto LABEL_120;
        }

        if (!(LOWORD(v195[0]) ^ 0x7564 | BYTE2(v195[0])))
        {
          uint64_t v64 = *(xmlNode **)(v10 + 16);
          if (!dtd[0])
          {
            xmlShellDu((xmlShellCtxtPtr)v10, v17, v64, v19);
            goto LABEL_120;
          }

          v65 = *(xmlXPathContext **)(v10 + 24);
          v65->node = v64;
          xmlXPathObjectPtr v66 = xmlXPathEval((const xmlChar *)dtd, v65);
          if (v66)
          {
            __int128 v69 = v66;
            __int128 v70 = "%s: no such node\n";
            switch(v66->type)
            {
              case XPATH_UNDEFINED:
                goto LABEL_159;
              case XPATH_NODESET:
                p_nodeNr = &v66->nodesetval->nodeNr;
                if (p_nodeNr && *p_nodeNr >= 1)
                {
                  uint64_t v88 = 0LL;
                  do
                  {
                    xmlShellDu((xmlShellCtxtPtr)v10, v67, *(xmlNodePtr *)(*((void *)p_nodeNr + 1) + 8 * v88++), v68);
                    p_nodeNr = &v69->nodesetval->nodeNr;
                  }

                  while (v88 < *p_nodeNr);
                }

                break;
              case XPATH_BOOLEAN:
LABEL_153:
                __int128 v70 = "%s is a Boolean\n";
                goto LABEL_159;
              case XPATH_NUMBER:
LABEL_154:
                __int128 v70 = "%s is a number\n";
                goto LABEL_159;
              case XPATH_STRING:
LABEL_155:
                __int128 v70 = "%s is a string\n";
                goto LABEL_159;
              case XPATH_POINT:
LABEL_156:
                __int128 v70 = "%s is a point\n";
                goto LABEL_159;
              case XPATH_RANGE:
              case XPATH_LOCATIONSET:
LABEL_128:
                __int128 v70 = "%s is a range\n";
                goto LABEL_159;
              case XPATH_USERS:
LABEL_157:
                __int128 v70 = "%s is user-defined\n";
                goto LABEL_159;
              case XPATH_XSLT_TREE:
LABEL_158:
                __int128 v70 = "%s is an XSLT value tree\n";
LABEL_159:
                xmlGenericErrorFunc v85 = *__xmlGenericError();
                __int128 v86 = __xmlGenericErrorContext();
                v85(*v86, v70);
                break;
              default:
                break;
            }

          if ((_DWORD)v24 == -1)
          {
LABEL_221:
            int v7 = v102;
            goto LABEL_45;
          }

          goto LABEL_99;
        }
      }

LABEL_160:
            xmlXPathFreeObject(v69);
LABEL_161:
            *(void *)(*(void *)(v10 + 24) + 8LL) = 0LL;
            goto LABEL_120;
          }

LABEL_151:
          xmlGenericErrorFunc v83 = *__xmlGenericError();
          __int128 v84 = __xmlGenericErrorContext();
          v83(*v84, "%s: no such node\n", dtd);
          goto LABEL_161;
        }

        if (!(LODWORD(v195[0]) ^ 0x65736162 | BYTE4(v195[0])))
        {
          xmlShellBase((xmlShellCtxtPtr)v10, v17, *(xmlNodePtr *)(v10 + 16), v19);
          goto LABEL_120;
        }

        if (LODWORD(v195[0]) == 7628147)
        {
          xmlShellSetContent(v10, dtd, *(xmlNode **)(v10 + 16));
          goto LABEL_120;
        }

        if (LODWORD(v195[0]) == 1853121907 && WORD2(v195[0]) == 115)
        {
          if (!dtd[0])
          {
            xmlGenericErrorFunc v34 = *__xmlGenericError();
            size_t v35 = *__xmlGenericErrorContext();
            uint64_t v36 = "setns: prefix=[nsuri] required\n";
            goto LABEL_122;
          }

          xmlShellRegisterNamespace(v10, (xmlChar *)dtd);
        }

        else
        {
          if (*(void *)&v195[0] == 0x6E746F6F72746573LL && WORD4(v195[0]) == 115)
          {
            xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v10 + 8));
            xmlShellRegisterRootNamespaces(v10, (uint64_t)RootElement);
            goto LABEL_120;
          }

          if (LODWORD(v195[0]) == 1952542840 && WORD2(v195[0]) == 104)
          {
            if (!dtd[0])
            {
              xmlGenericErrorFunc v34 = *__xmlGenericError();
              size_t v35 = *__xmlGenericErrorContext();
              uint64_t v36 = "xpath: expression required\n";
              goto LABEL_122;
            }

            __int128 v72 = *(xmlXPathContext **)(v10 + 24);
            v72->node = *(xmlNodePtr *)(v10 + 16);
            __int128 v73 = xmlXPathEval((const xmlChar *)dtd, v72);
            xmlXPathDebugDumpObject(*(FILE **)(v10 + 40), v73, 0);
            xmlXPathFreeObject(v73);
          }

          else
          {
            if (*(void *)&v195[0] == 0x65736162746573LL)
            {
              xmlNodeSetBase(*(xmlNodePtr *)(v10 + 16), (const xmlChar *)dtd);
              goto LABEL_120;
            }

            if (!(LOWORD(v195[0]) ^ 0x736C | BYTE2(v195[0])) || LODWORD(v195[0]) == 7498084)
            {
              BOOL v74 = LODWORD(v195[0]) != 7498084;
              __int128 v75 = *(xmlNode **)(v10 + 16);
              if (dtd[0])
              {
                __int128 v76 = *(xmlXPathContext **)(v10 + 24);
                v76->node = v75;
                xmlXPathObjectPtr v77 = xmlXPathEval((const xmlChar *)dtd, v76);
                if (v77)
                {
                  __int128 v69 = v77;
                  __int128 v70 = "%s: no such node\n";
                  switch(v77->type)
                  {
                    case XPATH_UNDEFINED:
                      goto LABEL_159;
                    case XPATH_NODESET:
                      __int128 v80 = &v77->nodesetval->nodeNr;
                      if (v80 && *v80 >= 1)
                      {
                        uint64_t v81 = 0LL;
                        do
                        {
                          __int128 v82 = *(xmlNode **)(*((void *)v80 + 1) + 8 * v81);
                          if (v74) {
                            xmlShellList((xmlShellCtxtPtr)v10, v78, v82, v79);
                          }
                          else {
                            xmlShellDir((xmlShellCtxtPtr)v10, v78, v82, v79);
                          }
                          ++v81;
                          __int128 v80 = &v69->nodesetval->nodeNr;
                        }

                        while (v81 < *v80);
                      }

                      break;
                    case XPATH_BOOLEAN:
                      goto LABEL_153;
                    case XPATH_NUMBER:
                      goto LABEL_154;
                    case XPATH_STRING:
                      goto LABEL_155;
                    case XPATH_POINT:
                      goto LABEL_156;
                    case XPATH_RANGE:
                    case XPATH_LOCATIONSET:
                      goto LABEL_128;
                    case XPATH_USERS:
                      goto LABEL_157;
                    case XPATH_XSLT_TREE:
                      goto LABEL_158;
                    default:
                      goto LABEL_160;
                  }

                  goto LABEL_160;
                }

                goto LABEL_151;
              }

              if (LODWORD(v195[0]) == 7498084) {
                xmlShellDir((xmlShellCtxtPtr)v10, v17, v75, v19);
              }
              else {
                xmlShellList((xmlShellCtxtPtr)v10, v17, v75, v19);
              }
            }

            else
            {
              if (*(void *)&v195[0] != 0x73696572656877LL)
              {
                if (LOWORD(v195[0]) ^ 0x6463 | BYTE2(v195[0]))
                {
                  if (LODWORD(v195[0]) != 7627107)
                  {
                    xmlGenericErrorFunc v34 = *__xmlGenericError();
                    size_t v35 = *__xmlGenericErrorContext();
                    uint64_t v36 = "Unknown command %s\n";
LABEL_122:
                    v34(v35, v36);
                    goto LABEL_120;
                  }

                  v104 = *(xmlNode **)(v10 + 16);
                  if (!dtd[0])
                  {
                    xmlShellCat((xmlShellCtxtPtr)v10, v17, v104, v19);
                    goto LABEL_120;
                  }

                  v105 = *(xmlXPathContext **)(v10 + 24);
                  v105->node = v104;
                  xmlXPathObjectPtr v106 = xmlXPathEval((const xmlChar *)dtd, v105);
                  if (v106)
                  {
                    xmlXPathObjectPtr v93 = v106;
                    uint64_t v94 = "%s: no such node\n";
                    switch(v106->type)
                    {
                      case XPATH_UNDEFINED:
                        goto LABEL_203;
                      case XPATH_NODESET:
                        v132 = &v106->nodesetval->nodeNr;
                        if (v132 && *v132 >= 1)
                        {
                          uint64_t v133 = 0LL;
                          do
                          {
                            if ((_DWORD)k)
                            {
                              fwrite(" -------\n", 9uLL, 1uLL, *(FILE **)(v10 + 40));
                              v132 = &v93->nodesetval->nodeNr;
                            }

                            xmlShellCat( (xmlShellCtxtPtr)v10,  v107,  *(xmlNodePtr *)(*((void *)v132 + 1) + 8 * v133++),  v108);
                            v132 = &v93->nodesetval->nodeNr;
                          }

                          while (v133 < *v132);
                        }

                        break;
                      case XPATH_BOOLEAN:
                        goto LABEL_197;
                      case XPATH_NUMBER:
                        goto LABEL_198;
                      case XPATH_STRING:
                        goto LABEL_199;
                      case XPATH_POINT:
                        goto LABEL_200;
                      case XPATH_RANGE:
                      case XPATH_LOCATIONSET:
                        goto LABEL_191;
                      case XPATH_USERS:
                        goto LABEL_201;
                      case XPATH_XSLT_TREE:
                        goto LABEL_202;
                      default:
                        break;
                    }

      size_t v42 = 0LL;
      goto LABEL_152;
    }
  }

  if (!a8 && (a7 || (*(_BYTE *)(a3 + 91) & 0x10) != 0))
  {
    xmlGenericErrorFunc v27 = xmlSchemaNormalizeValue((_DWORD *)a3, v15);
    uint64_t v21 = v27;
    if (v27) {
      uint64_t v15 = v27;
    }
    uint64_t v16 = *(_DWORD *)a3;
  }

  else
  {
    uint64_t v21 = 0LL;
  }

  int v28 = (xmlSchemaType *)a3;
  if (v16 != 1)
  {
    int v28 = (xmlSchemaType *)a3;
    while (1)
    {
      int v28 = v28->baseType;
      if (!v28) {
        break;
      }
      if (v28->type == XML_SCHEMA_TYPE_BASIC) {
        goto LABEL_38;
      }
    }

    uint64_t v33 = "could not get the built-in type";
    goto LABEL_75;
  }

          xmlSchemaPValAttrQName( a1,  a2,  (uint64_t)children,  (xmlChar *)"type",  (const xmlChar **)(v78 + 56),  (const xmlChar **)(v78 + 48));
          uint64_t v81 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)children, (xmlChar *)"id");
          if (v81) {
            xmlSchemaPValAttrNodeID(a1, v81);
          }
          Prop = xmlSchemaGetProp(a1, children, (xmlChar *)"fixed");
          *(void *)(v78 + 88) = Prop;
          if (Prop) {
            *(_DWORD *)(v78 + 120) |= 0x200u;
          }
          xmlGenericErrorFunc v83 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)children, (xmlChar *)"default");
          if (v83)
          {
            if ((*(_BYTE *)(v78 + 121) & 2) != 0) {
              xmlSchemaPMutualExclAttrErr(a1, 3051, v78, (uint64_t)v83);
            }
            else {
              *(void *)(v78 + 88) = xmlSchemaGetNodeContent(a1, v83);
            }
          }

          __int128 v84 = children->children;
          if (v84)
          {
            if (!v84->ns
              || !xmlStrEqual(v84->name, (const xmlChar *)"annotation")
              || !xmlStrEqual(v84->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
              || (*(void *)(v78 + 64) = xmlSchemaParseAnnotation((_DWORD *)a1, (uint64_t)v84, 1),
                  (__int128 v84 = v84->next) != 0LL))
            {
              if (!v84->ns
                || !xmlStrEqual(v84->name, (const xmlChar *)"simpleType")
                || !xmlStrEqual(v84->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
              {
                goto LABEL_173;
              }

              if (*(void *)(v78 + 48)) {
                xmlSchemaPContentErr( a1,  3055,  (uint64_t)children,  (uint64_t)v84,  (xmlChar *)"The attribute 'type' and the <simpleType> child are mutually exclusive",  0LL);
              }
              else {
                *(void *)(v78 + 96) = xmlSchemaParseSimpleType(a1, a2, v84, 0);
              }
              __int128 v84 = v84->next;
              if (v84)
              {
LABEL_173:
                xmlGenericErrorFunc v85 = "(annotation?, simpleType?)";
                __int128 v86 = a1;
                parent = (uint64_t)children;
                uint64_t v88 = (uint64_t)v84;
LABEL_216:
                xmlSchemaPContentErr(v86, 3033, parent, v88, 0LL, (xmlChar *)v85);
              }
            }
          }
        }
      }

      else
      {
        if (!children->ns) {
          goto LABEL_215;
        }
        if (xmlStrEqual(children->name, (const xmlChar *)"attributeGroup")
          && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          xmlSchemaParseAttributeGroupDefinition(a1, a2, (uint64_t)children);
          goto LABEL_217;
        }

        if (!children->ns) {
          goto LABEL_215;
        }
        if (xmlStrEqual(children->name, (const xmlChar *)"group")
          && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          xmlSchemaParseModelGroupDefinition(a1, a2, (uint64_t)children);
          goto LABEL_217;
        }

        if (!children->ns
          || !xmlStrEqual(children->name, (const xmlChar *)"notation")
          || !xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          goto LABEL_215;
        }

        xmlXPathObjectPtr v93 = xmlSchemaGetProp(a1, children, (xmlChar *)"name");
        if (!v93)
        {
          xmlSchemaPErr(a1, (uint64_t)children, 1723, "Notation has no name\n", 0LL, 0LL);
          goto LABEL_217;
        }

        uint64_t v94 = v93;
        int v95 = *(void *)(a1 + 200);
        uint64_t v96 = xmlMalloc(0x28uLL);
        if (!v96)
        {
          ++*(_DWORD *)(a1 + 36);
          __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"add annotation");
          goto LABEL_217;
        }

        v97 = v96;
        v96[4] = 0LL;
        *(_OWORD *)uint64_t v96 = 0u;
        *((_OWORD *)v96 + 1) = 0u;
        *(_DWORD *)uint64_t v96 = 18;
        v96[1] = v94;
        v96[4] = v95;
        xmlSchemaAddItemSize((void **)(*(void *)(*(void *)(a1 + 48) + 32LL) + 64LL), 5, (uint64_t)v96);
        int v98 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)children, (xmlChar *)"id");
        if (v98) {
          xmlSchemaPValAttrNodeID(a1, v98);
        }
        uint64_t v99 = (uint64_t)children->children;
        if (v99)
        {
          if (!*(void *)(v99 + 72)
            || !xmlStrEqual(*(const xmlChar **)(v99 + 16), (const xmlChar *)"annotation")
            || !xmlStrEqual( *(const xmlChar **)(*(void *)(v99 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
            || (v97[2] = xmlSchemaParseAnnotation((_DWORD *)a1, v99, 1), (uint64_t v99 = *(void *)(v99 + 48)) != 0))
          {
            xmlGenericErrorFunc v85 = "(annotation?)";
            __int128 v86 = a1;
            parent = (uint64_t)children;
            uint64_t v88 = v99;
            goto LABEL_216;
          }
        }
      }

LABEL_204:
                    v113 = v93;
LABEL_227:
                    xmlXPathFreeObject(v113);
                    goto LABEL_228;
                  }
                }

                else
                {
                  if (!dtd[0])
                  {
                    *(void *)(v10 + 16) = *(void *)(v10 + 8);
                    goto LABEL_120;
                  }

                  v97 = *(xmlXPathContext **)(v10 + 24);
                  v97->node = *(xmlNodePtr *)(v10 + 16);
                  int v98 = strlen(dtd);
                  if (v98 >= 2)
                  {
                    uint64_t v99 = (v98 - 1);
                    if (dtd[v99] == 47)
                    {
                      dtd[v99] = 0;
                      v97 = *(xmlXPathContext **)(v10 + 24);
                    }
                  }

                  xmlXPathObjectPtr v100 = xmlXPathEval((const xmlChar *)dtd, v97);
                  if (v100)
                  {
                    v101 = v100;
                    switch(v100->type)
                    {
                      case XPATH_UNDEFINED:
                        xmlGenericErrorFunc v114 = *__xmlGenericError();
                        v115 = *__xmlGenericErrorContext();
                        v114(v115, "%s: no such node\n");
                        break;
                      case XPATH_NODESET:
                        xmlNodeSetPtr nodesetval = v100->nodesetval;
                        if (nodesetval)
                        {
                          if (nodesetval->nodeNr == 1)
                          {
                            xmlNodePtr v117 = *nodesetval->nodeTab;
                            *(void *)(v10 + 16) = v117;
                            if (v117 && v117->type == XML_NAMESPACE_DECL)
                            {
                              xmlGenericErrorFunc v118 = *__xmlGenericError();
                              v119 = __xmlGenericErrorContext();
                              v118(*v119, "cannot cd to namespace\n");
                              *(void *)(v10 + 16) = 0LL;
                            }
                          }

                          else
                          {
                            xmlGenericErrorFunc v136 = *__xmlGenericError();
                            v137 = *__xmlGenericErrorContext();
                            v136(v137, "%s is a %d Node Set\n");
                          }
                        }

                        else
                        {
                          xmlGenericErrorFunc v134 = *__xmlGenericError();
                          v135 = *__xmlGenericErrorContext();
                          v134(v135, "%s is an empty Node Set\n");
                        }

                        break;
                      case XPATH_BOOLEAN:
                        xmlGenericErrorFunc v120 = *__xmlGenericError();
                        v121 = *__xmlGenericErrorContext();
                        v120(v121, "%s is a Boolean\n");
                        break;
                      case XPATH_NUMBER:
                        xmlGenericErrorFunc v122 = *__xmlGenericError();
                        v123 = *__xmlGenericErrorContext();
                        v122(v123, "%s is a number\n");
                        break;
                      case XPATH_STRING:
                        xmlGenericErrorFunc v124 = *__xmlGenericError();
                        v125 = *__xmlGenericErrorContext();
                        v124(v125, "%s is a string\n");
                        break;
                      case XPATH_POINT:
                        xmlGenericErrorFunc v126 = *__xmlGenericError();
                        v127 = *__xmlGenericErrorContext();
                        v126(v127, "%s is a point\n");
                        break;
                      case XPATH_RANGE:
                      case XPATH_LOCATIONSET:
                        xmlGenericErrorFunc v102 = *__xmlGenericError();
                        v103 = *__xmlGenericErrorContext();
                        v102(v103, "%s is a range\n");
                        break;
                      case XPATH_USERS:
                        xmlGenericErrorFunc v128 = *__xmlGenericError();
                        v129 = *__xmlGenericErrorContext();
                        v128(v129, "%s is user-defined\n");
                        break;
                      case XPATH_XSLT_TREE:
                        xmlGenericErrorFunc v130 = *__xmlGenericError();
                        v131 = *__xmlGenericErrorContext();
                        v130(v131, "%s is an XSLT value tree\n");
                        break;
                      default:
                        break;
                    }

                    v113 = v101;
                    goto LABEL_227;
                  }
                }

                goto LABEL_192;
              }

              int v169 = 0;
              __int128 v167 = 0u;
              __int128 v168 = 0u;
              __int128 v165 = 0u;
              __int128 v166 = 0u;
              __int128 v163 = 0u;
              __int128 v164 = 0u;
              __int128 v161 = 0u;
              __int128 v162 = 0u;
              __int128 v159 = 0u;
              __int128 v160 = 0u;
              __int128 v157 = 0u;
              __int128 v158 = 0u;
              __int128 v155 = 0u;
              __int128 v156 = 0u;
              __int128 v153 = 0u;
              __int128 v154 = 0u;
              __int128 v151 = 0u;
              __int128 v152 = 0u;
              __int128 v149 = 0u;
              __int128 v150 = 0u;
              __int128 v147 = 0u;
              __int128 v148 = 0u;
              __int128 v145 = 0u;
              __int128 v146 = 0u;
              __int128 v143 = 0u;
              __int128 v144 = 0u;
              __int128 v141 = 0u;
              __int128 v142 = 0u;
              __int128 v139 = 0u;
              __int128 v140 = 0u;
              *(_OWORD *)buffer = 0u;
              __int128 v89 = *(xmlNode **)(v10 + 16);
              if (dtd[0])
              {
                __int128 v90 = *(xmlXPathContext **)(v10 + 24);
                v90->node = v89;
                xmlXPathObjectPtr v91 = xmlXPathEval((const xmlChar *)dtd, v90);
                if (v91)
                {
                  xmlXPathObjectPtr v93 = v91;
                  uint64_t v94 = "%s: no such node\n";
                  switch(v91->type)
                  {
                    case XPATH_UNDEFINED:
                      goto LABEL_203;
                    case XPATH_NODESET:
                      int v95 = &v91->nodesetval->nodeNr;
                      if (v95 && *v95 >= 1)
                      {
                        uint64_t v96 = 0LL;
                        do
                        {
                          LODWORD(v91) = xmlShellPwd( (xmlShellCtxtPtr)v91,  buffer,  *(xmlNodePtr *)(*((void *)v95 + 1) + 8 * v96),  v92);
                          if (!(_DWORD)v91) {
                            xmlXPathObjectPtr v91 = (xmlXPathObjectPtr)fprintf(*(FILE **)(v10 + 40), "%s\n", buffer);
                          }
                          ++v96;
                          int v95 = &v93->nodesetval->nodeNr;
                        }

                        while (v96 < *v95);
                      }

                      goto LABEL_204;
                    case XPATH_BOOLEAN:
LABEL_197:
                      uint64_t v94 = "%s is a Boolean\n";
                      goto LABEL_203;
                    case XPATH_NUMBER:
LABEL_198:
                      uint64_t v94 = "%s is a number\n";
                      goto LABEL_203;
                    case XPATH_STRING:
LABEL_199:
                      uint64_t v94 = "%s is a string\n";
                      goto LABEL_203;
                    case XPATH_POINT:
LABEL_200:
                      uint64_t v94 = "%s is a point\n";
                      goto LABEL_203;
                    case XPATH_RANGE:
                    case XPATH_LOCATIONSET:
LABEL_191:
                      uint64_t v94 = "%s is a range\n";
                      goto LABEL_203;
                    case XPATH_USERS:
LABEL_201:
                      uint64_t v94 = "%s is user-defined\n";
                      goto LABEL_203;
                    case XPATH_XSLT_TREE:
LABEL_202:
                      uint64_t v94 = "%s is an XSLT value tree\n";
LABEL_203:
                      xmlGenericErrorFunc v111 = *__xmlGenericError();
                      v112 = __xmlGenericErrorContext();
                      v111(*v112, v94);
                      break;
                    default:
                      goto LABEL_204;
                  }

                  goto LABEL_204;
                }

                      int v7 = v16;
LABEL_205:
                      if (v31 >= v96) {
                        uint64_t v17 = 0;
                      }
                      else {
                        uint64_t v17 = xmlStringCurrentChar(v14, v31, &lena);
                      }
                      if (v17 == v10 || v17 == v11 || !v17 || (v16 = v7, xmlNodePtr v8 = v31, v17 == v12))
                      {
LABEL_260:
                        v7[v18] = 0;
                        return v7;
                      }

                      goto LABEL_17;
                    }

  uint64_t v64 = *(void **)(v73 + 176);
  if (v64)
  {
    while (1)
    {
      v65 = (int *)v64[1];
      xmlXPathObjectPtr v66 = *v65;
      if ((*v65 & 0xFFFFFFFE) != 0x3EE) {
        break;
      }
LABEL_220:
      int result = 0LL;
      uint64_t v64 = (void *)*v64;
      if (!v64) {
        return result;
      }
    }

    xmlAttrPtr v67 = v61;
    while (1)
    {
      xmlAttrPtr v67 = (void *)*v67;
      if (!v67) {
        break;
      }
      uint64_t v68 = v67[1];
      if (*(_DWORD *)v68 == v66)
      {
        if (v66 == 1008)
        {
          if (*(_DWORD *)(v68 + 52) < v65[13]) {
            xmlSchemaPCustomErrExt( (uint64_t)a1,  1717,  (_DWORD *)v68,  *(void *)(v68 + 40),  (const xmlChar *)"The 'whitespace' value has to be equal to or stronger than the 'whitespace' value of the base type");
          }
          if (v65[12])
          {
            if (*(_DWORD *)(v68 + 52) != v65[13]) {
              xmlSchemaPCustomErrExt( (uint64_t)a1,  1717,  (_DWORD *)v68,  *(void *)(v68 + 40),  (const xmlChar *)"The base type's facet is 'fixed', thus the value must not differ");
            }
          }
        }

        goto LABEL_220;
      }
    }

    __int128 v69 = xmlMalloc(0x10uLL);
    if (v69)
    {
      __int128 v70 = v64[1];
      *__int128 v69 = 0LL;
      v69[1] = v70;
      if (v8) {
        *xmlNodePtr v8 = v69;
      }
      else {
        *uint64_t v61 = v69;
      }
      xmlNodePtr v8 = v69;
      goto LABEL_220;
    }

    if (a1) {
      ++a1[9];
    }
    __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"deriving facets, creating a facet link");
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

LABEL_192:
                xmlGenericErrorFunc v109 = *__xmlGenericError();
                v110 = __xmlGenericErrorContext();
                v109(*v110, "%s: no such node\n", dtd);
LABEL_228:
                *(void *)(*(void *)(v10 + 24) + 8LL) = 0LL;
                goto LABEL_120;
              }

              if (!xmlShellPwd(v16, buffer, v89, v19)) {
                goto LABEL_124;
              }
            }
          }
        }
      }

      else
      {
        if (dtd[0])
        {
          *(_DWORD *)buffer = 0;
          sscanf(dtd, "%d", buffer);
          uint64_t v62 = *(FILE **)(v10 + 40);
          int v63 = *(_DWORD *)buffer;
        }

        else
        {
          uint64_t v62 = *(FILE **)(v10 + 40);
          int v63 = 0;
        }

        xmlMemShow(v62, v63);
      }
    }

LABEL_120:
    free(v20);
  }

          if (atts)
          {
            int v48 = (xmlChar *)*atts;
            if (*atts)
            {
              uint64_t v49 = (xmlChar *)atts[1];
              if (v49)
              {
                int v50 = (xmlChar **)(atts + 3);
                do
                {
                  if (*v48 == 120 && v48[1] == 109 && v48[2] == 108 && v48[3] == 110 && v48[4] == 115) {
                    xmlSAX2AttributeInternal((uint64_t *)ctx, v48, v49, prefix);
                  }
                  int v48 = *(v50 - 1);
                  uint64_t v49 = *v50;
                  v50 += 2;
                  if (v48) {
                    uint64_t v51 = v49 == 0LL;
                  }
                  else {
                    uint64_t v51 = 1;
                  }
                }

                while (!v51);
              }
            }
          }

          uint64_t v52 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), v10, prefix);
          xmlGenericErrorFunc v53 = v52;
          if (node && !v52) {
            xmlGenericErrorFunc v53 = xmlSearchNs(*((xmlDocPtr *)ctx + 2), node, prefix);
          }
          if (prefix && !v53)
          {
            xmlGenericErrorFunc v53 = xmlNewNs(v10, 0LL, prefix);
            xmlNsWarnMsg(ctx, 201, (uint64_t)"Namespace prefix %s is not defined\n", (uint64_t)prefix, 0LL);
          }

          if (v53)
          {
            href = v53->href;
            if (href)
            {
              if (*href || v53->prefix) {
                xmlSetNs(v10, v53);
              }
            }
          }

          goto LABEL_33;
        }

        if (prefix) {
          xmlFree(prefix);
        }
        xmlSAX2ErrMemory((uint64_t *)ctx, (uint64_t)"xmlSAX2StartElement");
      }
    }
  }

            xmlGenericErrorFunc v27 = 0;
            xmlNodePtr v8 = 1LL;
            goto LABEL_168;
          }

LABEL_229:
  xmlXPathFreeContext(*(xmlXPathContextPtr *)(v10 + 24));
  if (*(_DWORD *)(v10 + 32)) {
    xmlFreeDoc(*(xmlDocPtr *)(v10 + 8));
  }
  if (*(void *)v10) {
    xmlFree(*(void **)v10);
  }
  xmlFree((void *)v10);
  if (v20) {
    free(v20);
  }
}

xmlNodePtr xmlShellSetContent(uint64_t a1, char *__s, xmlNode *a3)
{
  if (!a3 || !__s) {
    return (xmlNodePtr)fwrite("NULL\n", 5uLL, 1uLL, *(FILE **)(a1 + 40));
  }
  xmlNodePtr lst = 0LL;
  int v6 = strlen(__s);
  if (xmlParseInNodeContext(a3, __s, v6, 0, &lst)) {
    return (xmlNodePtr)fwrite("failed to parse content\n", 0x18uLL, 1uLL, *(FILE **)(a1 + 40));
  }
  children = a3->children;
  if (children)
  {
    xmlFreeNodeList(children);
    a3->children = 0LL;
    a3->last = 0LL;
  }

  return xmlAddChildList(a3, lst);
}

void xmlShellRegisterNamespace(uint64_t a1, xmlChar *cur)
{
  xmlGenericErrorFunc v3 = xmlStrdup(cur);
  unsigned __int32 v4 = v3;
  while (v4)
  {
    int v5 = (const char *)v4;
    if (!*v4) {
      break;
    }
    int v6 = xmlStrchr(v4, 0x3Du);
    if (!v6)
    {
      fwrite("setns: prefix=[nsuri] required\n", 0x1FuLL, 1uLL, *(FILE **)(a1 + 40));
      break;
    }

    *int v6 = 0;
    int v7 = (const char *)(v6 + 1);
    xmlNodePtr v8 = xmlStrchr(v6 + 1, 0x20u);
    unsigned __int32 v4 = v8;
    if (v8)
    {
      *xmlNodePtr v8 = 0;
      unsigned __int32 v4 = v8 + 1;
    }

    if (xmlXPathRegisterNs(*(xmlXPathContextPtr *)(a1 + 24), (const xmlChar *)v5, (const xmlChar *)v7))
    {
      fprintf(*(FILE **)(a1 + 40), "Error: unable to register NS with prefix=%s and href=%s\n", v5, v7);
      break;
    }
  }

  xmlFree(v3);
}

uint64_t xmlShellRegisterRootNamespaces(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      size_t v2 = *(uint64_t ***)(a2 + 96);
      if (v2)
      {
        uint64_t v3 = result;
        if (*(void *)(result + 24))
        {
          do
          {
            if (v2[3]) {
              unsigned __int32 v4 = (const xmlChar *)v2[3];
            }
            else {
              unsigned __int32 v4 = (const xmlChar *)"defaultns";
            }
            int result = xmlXPathRegisterNs(*(xmlXPathContextPtr *)(v3 + 24), v4, (const xmlChar *)v2[2]);
            size_t v2 = (uint64_t **)*v2;
          }

          while (v2);
        }
      }
    }
  }

  return result;
}

uint64_t xmlCtxtDumpSpaces(uint64_t result)
{
  if (!*(_DWORD *)(result + 144))
  {
    int v1 = *(FILE **)result;
    if (*(void *)result)
    {
      uint64_t v2 = *(unsigned int *)(result + 112);
      if ((int)v2 >= 1)
      {
        else {
          uint64_t v3 = (const char *)(result + 8 - 2 * v2 + 100);
        }
        return fputs(v3, v1);
      }
    }
  }

  return result;
}

size_t xmlCtxtDumpString(size_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 144)) {
    return result;
  }
  uint64_t v3 = (FILE **)result;
  if (a2)
  {
    uint64_t v4 = 0LL;
    while (1)
    {
      int result = *(unsigned __int8 *)(a2 + v4);
      if ((_DWORD)result == 32) {
        goto LABEL_12;
      }
      if (!*(_BYTE *)(a2 + v4)) {
        return result;
      }
      if ((result - 9) < 2 || (_DWORD)result == 13)
      {
LABEL_12:
        int v6 = *v3;
        LODWORD(result) = 32;
      }

      else
      {
        int v6 = *v3;
        if ((result & 0x80) != 0)
        {
          fprintf(v6, "#%X", *(unsigned __int8 *)(a2 + v4));
          goto LABEL_14;
        }
      }

      fputc(result, v6);
LABEL_14:
      if (++v4 == 40)
      {
        int v7 = *v3;
        xmlNodePtr v8 = "...";
        size_t v9 = 3LL;
        return fwrite(v8, v9, 1uLL, v7);
      }
    }
  }

  int v7 = *(FILE **)result;
  xmlNodePtr v8 = "(NULL)";
  size_t v9 = 6LL;
  return fwrite(v8, v9, 1uLL, v7);
}

_DWORD *xmlDebugErr(uint64_t a1, int a2, char a3)
{
  return __xmlRaiseError(0LL, 0LL, 0LL, 0LL, *(void *)(a1 + 128), 0x18u, a2, 2, 0LL, 0, 0LL, 0LL, 0LL, 0, 0, "%s", a3);
}

uint64_t xmlCtxtGenericNodeCheck(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 64);
  if (*(void *)(a2 + 40))
  {
    if (*(void *)(a2 + 64)) {
      goto LABEL_3;
    }
LABEL_11:
    int result = (uint64_t)xmlDebugErr(v3, 5014, (char)"Node has no doc\n");
    goto LABEL_12;
  }

  int result = (uint64_t)xmlDebugErr(result, 5013, (char)"Node has no parent\n");
  if (!*(void *)(a2 + 64)) {
    goto LABEL_11;
  }
LABEL_3:
  uint64_t v5 = *(void *)(v4 + 152);
  if (!v5 && !*(_DWORD *)(v3 + 152)) {
    *(_DWORD *)(v3 + 152) = 1;
  }
  if (!*(void *)(v3 + 120)) {
    *(void *)(v3 + 120) = v4;
  }
  if (!*(void *)(v3 + 136)) {
    *(void *)(v3 + 136) = v5;
  }
LABEL_12:
  uint64_t v6 = *(void *)(a2 + 40);
  if (v6)
  {
    if (*(void *)(a2 + 64) != *(void *)(v6 + 64))
    {
      int result = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"pseudoroot");
      if (!(_DWORD)result) {
        int result = (uint64_t)xmlDebugErr(v3, 5017, (char)"Node doc differs from parent's one\n");
      }
    }
  }

  uint64_t v7 = *(void *)(a2 + 56);
  if (v7)
  {
    if (*(void *)(v7 + 48) == a2) {
      goto LABEL_28;
    }
    xmlNodePtr v8 = "Node prev->next : back link wrong\n";
    uint64_t v9 = v3;
    int v10 = 5019;
    goto LABEL_27;
  }

  uint64_t v11 = *(void *)(a2 + 40);
  if (*(_DWORD *)(a2 + 8) == 2)
  {
    if (v11 && *(void *)(v11 + 88) != a2)
    {
      xmlNodePtr v8 = "Attr has no prev and not first of attr list\n";
LABEL_26:
      uint64_t v9 = v3;
      int v10 = 5018;
LABEL_27:
      int result = (uint64_t)xmlDebugErr(v9, v10, (char)v8);
    }
  }

  else if (v11 && *(void *)(v11 + 24) != a2)
  {
    xmlNodePtr v8 = "Node has no prev and not first of parent list\n";
    goto LABEL_26;
  }

LABEL_28:
  uint64_t v12 = *(void *)(a2 + 48);
  if (v12)
  {
    if (*(void *)(v12 + 56) != a2)
    {
      int result = (uint64_t)xmlDebugErr(v3, 5021, (char)"Node next->prev : forward link wrong\n");
      uint64_t v12 = *(void *)(a2 + 48);
    }

    if (*(void *)(v12 + 40) != *(void *)(a2 + 40))
    {
      xmlXPathContextPtr v13 = "Node next->prev : forward link wrong\n";
      uint64_t v14 = v3;
      int v15 = 5029;
LABEL_33:
      int result = (uint64_t)xmlDebugErr(v14, v15, (char)v13);
    }
  }

  else
  {
    uint64_t v16 = *(void *)(a2 + 40);
    if (v16 && *(_DWORD *)(a2 + 8) != 2 && *(void *)(v16 + 32) != a2 && *(_DWORD *)(v16 + 8) == 1)
    {
      xmlXPathContextPtr v13 = "Node has no next and not last of parent list\n";
      uint64_t v14 = v3;
      int v15 = 5020;
      goto LABEL_33;
    }
  }

  unsigned int v17 = *(_DWORD *)(a2 + 8);
  if (v17 == 2)
  {
    uint64_t v19 = *(void *)(a2 + 72);
    if (!v19) {
      return xmlCtxtCheckName(v3, *(xmlChar **)(a2 + 16));
    }
LABEL_46:
    int result = xmlCtxtNsCheckScope(v3, a2, v19);
LABEL_47:
    unsigned int v17 = *(_DWORD *)(a2 + 8);
    goto LABEL_48;
  }

  if (v17 == 1)
  {
    for (uint64_t i = *(void **)(a2 + 96); i; uint64_t i = (void *)*i)
      int result = xmlCtxtNsCheckScope(v3, a2, (uint64_t)i);
    uint64_t v19 = *(void *)(a2 + 72);
    if (!v19) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }

        if (v12) {
          v6((void *)a5, "element %s: ", v12);
        }
        size_t v22 = v13 - 1;
        if (v13 - 1 <= 0x1D && ((0x3E7FBCFDu >> v22) & 1) != 0) {
          v6((void *)a5, off_189B9B928[v22]);
        }
        if (a3 && ((uint64_t v23 = xmlStrlen(a3), v23 < 1) || a3[v23 - 1] == 10)) {
          uint64_t v24 = "%s";
        }
        else {
          uint64_t v24 = "%s\n";
        }
        int result = ((uint64_t (*)(uint64_t, const char *))v6)(a5, v24);
        if (!a2) {
          goto LABEL_49;
        }
        int result = xmlParserPrintFileContextInternal(v16, (void (*)(uint64_t, const char *, ...))v6, a5);
        if (!v15) {
          goto LABEL_49;
        }
        if (*(void *)(v15 + 8))
        {
          uint64_t v25 = "%s:%d: \n";
        }

        else
        {
          if (!v28 || v13 != 1) {
            goto LABEL_48;
          }
          uint64_t v25 = "Entity: line %d: \n";
        }

        v6((void *)a5, v25);
LABEL_48:
        int result = xmlParserPrintFileContextInternal(v15, (void (*)(uint64_t, const char *, ...))v6, a5);
LABEL_49:
        if (v13 == 12)
        {
          int result = *(void *)(v9 + 40);
          if (result)
          {
            uint64_t v26 = *(_DWORD *)(v9 + 64);
            if (v26 <= 99)
            {
              int result = xmlStrlen((const xmlChar *)result);
              if (v26 < (int)result)
              {
                memset(__b, 0, 150);
                v6((void *)a5, "%s\n", *(const char **)(v9 + 40));
                int v27 = *(unsigned int *)(v9 + 64);
                else {
                  memset(__b, 32, v27);
                }
                *(_WORD *)((char *)__b + v27) = 94;
                return ((uint64_t (*)(uint64_t, const char *, ...))v6)(a5, "%s\n", (const char *)__b);
              }
            }
          }
        }

        return result;
      }

      if (*(void *)(v9 + 24))
      {
        __int128 v18 = "%s:%d: ";
      }

      else
      {
        if (!v10)
        {
LABEL_27:
          uint64_t v16 = 0LL;
          int v15 = 0LL;
          goto LABEL_28;
        }

        uint64_t v16 = 0LL;
        if (v13 > 0x13)
        {
          int v15 = 0LL;
          goto LABEL_28;
        }

        int v15 = 0LL;
        if (((1 << v13) & 0xF0012) == 0) {
          goto LABEL_28;
        }
        __int128 v18 = "Entity: line %d: ";
      }

      v6((void *)a5, v18);
      goto LABEL_27;
    }
  }

  return result;
}

  if (a5)
  {
    size_t v35 = xmlCharStrdup(a5);
    uint64_t v29 = xmlStrcat(cur, (const xmlChar *)" Expected is '");
    cur = v29;
    uint64_t v30 = xmlEscapeFormatString((void **)&v35);
    uint64_t v31 = xmlStrcat(v29, v30);
    cur = v31;
    if (v35)
    {
      xmlFree(v35);
      size_t v35 = 0LL;
      uint64_t v31 = cur;
    }

    xmlEntityPtr v32 = "'.\n";
  }

  else
  {
    uint64_t v31 = cur;
    xmlEntityPtr v32 = "\n";
  }

  uint64_t v33 = xmlStrcat(v31, (const xmlChar *)v32);
  cur = v33;
  if (*(_DWORD *)(a3 + 8) == 2) {
    xmlGenericErrorFunc v34 = a6;
  }
  else {
    xmlGenericErrorFunc v34 = 0LL;
  }
  xmlSchemaPErr(a1, a3, a2, (const char *)v33, v34, 0LL);
LABEL_37:
  if (cur) {
    xmlFree(cur);
  }
}

  xmlXPathContextPtr v13 = a3 == 0;
  uint64_t v14 = -1;
LABEL_39:
  if (v13) {
    return v14;
  }
  else {
    return -v14;
  }
}

  uint64_t v23 = v17;
LABEL_23:
  xmlXPathReleaseObject((uint64_t)ctxt->context, obj);
  xmlXPathReleaseObject((uint64_t)ctxt->context, a5);
  return v23;
}

uint64_t xmlCtxtNsCheckScope(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  unsigned int v5 = *(_DWORD *)(a2 + 8);
  BOOL v6 = v5 > 0x13;
  int v7 = (1 << v5) & 0x8220E;
  if (!v6 && v7 != 0)
  {
    uint64_t v9 = a2;
    do
    {
      unsigned int v10 = *(_DWORD *)(v9 + 8);
      if (v10 > 0x13) {
        break;
      }
      if (((1 << v10) & 0xC) == 0)
      {
        if (((1 << v10) & 0x80002) == 0)
        {
          if (((1 << v10) & 0x2200) != 0 && *(void *)(v9 + 96) == a3) {
            return result;
          }
          break;
        }

        uint64_t v11 = (uint64_t *)(v9 + 96);
        while (1)
        {
          uint64_t v11 = (uint64_t *)*v11;
          if (!v11) {
            break;
          }
          int result = xmlStrEqual((const xmlChar *)v11[3], *(const xmlChar **)(a3 + 24));
          if ((_DWORD)result) {
            goto LABEL_16;
          }
        }
      }

      uint64_t v9 = *(void *)(v9 + 40);
    }

    while (v9);
    uint64_t v12 = *(void *)(a3 + 24);
    if (v12)
    {
      xmlXPathContextPtr v13 = "Reference to namespace '%s' not on ancestor\n";
      uint64_t v14 = v4;
      int v15 = 5031;
      return (uint64_t)xmlDebugErr3(v14, v15, v13, v12);
    }

    uint64_t v16 = "Reference to default namespace not on ancestor\n";
    uint64_t v17 = v4;
    int v18 = 5031;
    return (uint64_t)xmlDebugErr(v17, v18, (char)v16);
  }

LABEL_16:
  uint64_t v12 = *(void *)(a3 + 24);
  if (!v12)
  {
    uint64_t v16 = "Reference to default namespace not in scope\n";
    uint64_t v17 = v4;
    int v18 = 5030;
    return (uint64_t)xmlDebugErr(v17, v18, (char)v16);
  }

  xmlXPathContextPtr v13 = "Reference to namespace '%s' not in scope\n";
  uint64_t v14 = v4;
  int v15 = 5030;
  return (uint64_t)xmlDebugErr3(v14, v15, v13, v12);
}

    LODWORD(use) = out->use;
    xmlNodePtr v8 = out->size - use - ((signed int)(out->size - use) > 0);
    uint64_t v9 = in->use;
    len = v9;
    uint64_t v23 = v8;
    if (!v9) {
      return 0;
    }
  }

  *(void *)__str = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0;
  int v21 = in->use;
  UTF8Char = xmlGetUTF8Char(in->content, (int *)&v21);
  if (UTF8Char < 1)
  {
    uint64_t v11 = -2;
    goto LABEL_24;
  }

  int v15 = snprintf(__str, 0x14uLL, "&#%d;", UTF8Char);
  xmlBufferShrink(in, v21);
  xmlBufferGrow(out, 4 * v15);
  uint64_t v16 = out->use;
  uint64_t v17 = out->size + ~(_DWORD)v16;
  len = v15;
  uint64_t v23 = v17;
  uint64_t v11 = xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[v16], &v23, (uint64_t)__str, &len);
  if ((v11 & 0x80000000) == 0 && len == v15)
  {
    int v18 = v23;
    uint64_t v19 = out->use + v23;
    out->size_t use = v19;
    v10 += v18;
    out->content[v19] = 0;
    goto LABEL_16;
  }

  int v27 = 0;
  uint64_t v25 = 0u;
  uint64_t v26 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  snprintf(v24, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *in->content, in->content[1], in->content[2], in->content[3]);
  int v28 = 0;
  __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x1Bu,  6003,  3,  0LL,  0,  (const xmlChar *)v24,  0LL,  0LL,  0,  0,  "output conversion failed due to conv error, bytes %s\n",  (char)v24);
  if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
    *in->content = 32;
  }
LABEL_24:
  if (v10) {
    return v10;
  }
  else {
    return v11;
  }
}

  LineNo = a10;
  v65 = (uint64_t (*)(void *, uint64_t))a1;
  xmlXPathObjectPtr v66 = a4;
  uint64_t v64 = a6;
  if (a16)
  {
    uint64_t v30 = (char *)xmlMalloc(0x96uLL);
    if (v30)
    {
      uint64_t v31 = -1;
      xmlEntityPtr v32 = 150;
      do
      {
        uint64_t v33 = (xmlChar *)v30;
        if (v32 > 63999) {
          break;
        }
        xmlGenericErrorFunc v34 = vsnprintf(v30, v32, a16, &a17);
        if ((v34 & 0x80000000) == 0 && v34 < v32)
        {
          v55 = v31 == v34;
          uint64_t v31 = v34;
          if (v55) {
            break;
          }
        }

        size_t v35 = v34 >= 0 ? v34 + 1 : 100;
        v32 += v35;
        uint64_t v30 = (char *)xmlRealloc(v33, v32);
      }

      while (v30);
    }

    else
    {
      uint64_t v33 = 0LL;
    }
  }

  else
  {
    uint64_t v33 = xmlStrdup((const xmlChar *)"No error message provided");
  }

  uint64_t v36 = a9;
  if (v27)
  {
    if (!a9)
    {
      xmlGenericErrorFunc v37 = v27[7];
      if (v37)
      {
        uint64_t v36 = *(void *)(v37 + 8);
        if (v36)
        {
LABEL_67:
          LineNo = *(_DWORD *)(v37 + 52);
          a15 = *(_DWORD *)(v37 + 56);
          goto LABEL_68;
        }

        int v38 = *((_DWORD *)v27 + 16);
        uint64_t v39 = __OFSUB__(v38, 2);
        uint64_t v40 = v38 - 2;
        if (v40 < 0 != v39)
        {
          uint64_t v36 = 0LL;
          goto LABEL_67;
        }

        xmlGenericErrorFunc v37 = *(void *)(v27[9] + 8LL * v40);
        if (v37)
        {
          uint64_t v36 = *(void *)(v37 + 8);
          goto LABEL_67;
        }
      }

      uint64_t v36 = 0LL;
    }

    xmlXPathContextPtr v13 = "Unsupported encoding %s\n";
    uint64_t v14 = v6;
    uint64_t v12 = 32;
LABEL_17:
    htmlParseErr(v14, v12, v13, a2, 0LL);
    return v6;
  }

  CharEncodingHandler = xmlFindCharEncodingHandler((const char *)a2);
  if (!CharEncodingHandler) {
    goto LABEL_16;
  }
  if (xmlSwitchToEncoding(v6, CharEncodingHandler) < 0)
  {
    errNo = v6->errNo;
LABEL_12:
    if (errNo) {
      uint64_t v12 = errNo;
    }
    else {
      uint64_t v12 = 6003;
    }
    xmlXPathContextPtr v13 = "htmlCheckEncoding: error switching to encoding '%s'\n";
    uint64_t v14 = v6;
    goto LABEL_17;
  }

  return v6;
}

    xmlNodePtr v8 = len;
    if (len == 1)
    {
      v22[(int)v6] = v5;
      BOOL v6 = (v6 + 1);
    }

    else
    {
      BOOL v6 = (xmlCopyChar(len, &v22[(int)v6], v5) + v6);
    }

    if ((int)v6 >= 1000)
    {
      v22[v6] = 0;
      if (!*(void *)a1 || *(_DWORD *)(a1 + 332)) {
        goto LABEL_33;
      }
      if (areBlanks(a1, v22, v6))
      {
        uint64_t v9 = *(void *)a1;
        if (!*(_DWORD *)(a1 + 328))
        {
          unsigned int v10 = *(void (**)(void, unsigned __int8 *, uint64_t))(v9 + 144);
          if (!v10) {
            goto LABEL_33;
          }
LABEL_32:
          v10(*(void *)(a1 + 8), v22, v6);
LABEL_33:
          BOOL v6 = 0LL;
          goto LABEL_34;
        }
      }

      else
      {
        htmlCheckParagraph(a1);
        uint64_t v9 = *(void *)a1;
      }

      unsigned int v10 = *(void (**)(void, unsigned __int8 *, uint64_t))(v9 + 136);
      if (v10) {
        goto LABEL_32;
      }
      goto LABEL_33;
    }

      uint64_t v19 = *(void **)(a1 + 96);
      if (v19 && *((void *)v14 + 1) == *v19 && *(_DWORD *)v14 == a2) {
        return;
      }
      goto LABEL_19;
    }

  xmlXPathContextPtr v13 = a2[10];
  if (!v13) {
    return 1LL;
  }
  if (*(_DWORD *)v13 == 17)
  {
    if (a1)
    {
      uint64_t v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v14 | 1;
    }

    else
    {
      uint64_t v14 = 0;
    }

    BOOL v20 = *(void *)(v13 + 80);
    if (!v20)
    {
LABEL_41:
      if (!a1) {
        return 0LL;
      }
      goto LABEL_48;
    }

    while (1)
    {
      int v21 = xmlRelaxNGElementMatch(a1, v20, a3);
      if (v21 == 1) {
        goto LABEL_33;
      }
      if (v21 < 0)
      {
LABEL_44:
        if (a1) {
          *(_DWORD *)(a1 + 56) = v14;
        }
        return 0xFFFFFFFFLL;
      }

      BOOL v20 = *(void *)(v20 + 64);
      if (!v20) {
        goto LABEL_41;
      }
    }
  }

  if (*(_DWORD *)v13 == 2)
  {
    if (a1)
    {
      uint64_t v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v14 | 1;
    }

    else
    {
      uint64_t v14 = 0;
    }

    int v18 = *(void *)(v13 + 48);
    if (v18)
    {
      while (1)
      {
        uint64_t v19 = xmlRelaxNGElementMatch(a1, v18, a3);
        if (v19 == 1) {
          break;
        }
        if (v19 < 0) {
          goto LABEL_44;
        }
        int v18 = *(void *)(v18 + 64);
        if (!v18) {
          goto LABEL_33;
        }
      }

      if (!a1) {
        return 0LL;
      }
LABEL_48:
      int result = 0LL;
      *(_DWORD *)(a1 + 56) = v14;
      return result;
    }

    int result = (uint64_t)xmlSAX2TextNode(result, __src, len);
LABEL_20:
    if (!result) {
      return result;
    }
    int result = (uint64_t)xmlAddChild(*(xmlNodePtr *)(v4 + 80), (xmlNodePtr)result);
    if (!*(void *)(*(void *)(v4 + 80) + 24LL)) {
      return result;
    }
LABEL_22:
    *(_DWORD *)(v4 + 412) = len;
    xmlXPathContextPtr v13 = len + 1;
LABEL_23:
    *(_DWORD *)(v4 + 416) = v13;
    return result;
  }

  if (a4 == 3 && *(const xmlChar **)(v8 + 16) != "text") {
    goto LABEL_16;
  }
  uint64_t v9 = *(_DWORD *)(result + 416);
  if (v9)
  {
    unsigned int v10 = *(xmlChar **)(v8 + 80);
    if (v10 == (xmlChar *)(v8 + 88))
    {
      uint64_t v14 = xmlStrdup(*(const xmlChar **)(v8 + 80));
      *(void *)unsigned int v10 = 0LL;
      *(void *)(v8 + 80) = v14;
      unsigned int v10 = v14;
    }

    else if (v9 == *(_DWORD *)(result + 412) + 1)
    {
      uint64_t v11 = xmlDictOwns(*(xmlDictPtr *)(result + 456), *(const xmlChar **)(v8 + 80));
      unsigned int v10 = *(xmlChar **)(v8 + 80);
      if (v11)
      {
        unsigned int v10 = xmlStrdup(*(const xmlChar **)(v8 + 80));
        *(void *)(v8 + 80) = v10;
      }
    }

    if (!v10)
    {
      uint64_t v16 = "xmlSAX2Characters: xmlStrdup returned NULL";
      return xmlSAX2ErrMemory((uint64_t *)v4, (uint64_t)v16);
    }

    int v15 = *(_DWORD *)(v4 + 412);
    if (v15 > (len ^ 0x7FFFFFFF))
    {
      uint64_t v16 = "xmlSAX2Characters overflow prevented";
      return xmlSAX2ErrMemory((uint64_t *)v4, (uint64_t)v16);
    }

    if (v15 + len >= 10000001 && (*(_BYTE *)(v4 + 566) & 8) == 0)
    {
      uint64_t v16 = "xmlSAX2Characters: huge text node";
      return xmlSAX2ErrMemory((uint64_t *)v4, (uint64_t)v16);
    }

    uint64_t v17 = *(_DWORD *)(v4 + 416);
    if (v15 + len < v17)
    {
LABEL_45:
      int result = (uint64_t)memcpy(&v10[v15], __src, len);
      int v21 = *(int *)(v4 + 412) + (uint64_t)len;
      *(_DWORD *)(v4 + 412) = v21;
      *(_BYTE *)(*(void *)(v8 + 80) + v21) = 0;
      return result;
    }

    int v18 = v17 + len;
    if (v17 > (len ^ 0x7FFFFFFF)) {
      int v18 = 0x7FFFFFFF;
    }
    if (v18 <= 0x3FFFFFFF) {
      uint64_t v19 = 2 * v18;
    }
    else {
      uint64_t v19 = 0x7FFFFFFF;
    }
    BOOL v20 = (xmlChar *)xmlRealloc(v10, v19);
    if (v20)
    {
      unsigned int v10 = v20;
      *(_DWORD *)(v4 + 416) = v19;
      *(void *)(v8 + 80) = v20;
      int v15 = *(_DWORD *)(v4 + 412);
      goto LABEL_45;
    }

  if (a4)
  {
    __int128 v73 = v17;
    URL = a4->URL;
    if (URL) {
      uint64_t v14 = (uint64_t)xmlDictLookup(*(xmlDictPtr *)(a1 + 152), URL, -1);
    }
    else {
      uint64_t v14 = (uint64_t)"in_memory_buffer";
    }
    htmlDocPtr File = a4;
    goto LABEL_29;
  }

  if (!((unint64_t)a5 | v14))
  {
    xmlSchemaPErr( a1,  0LL,  1758,  "No information for parsing was provided with the given schema parser context.\n",  0LL,  0LL);
    return 0xFFFFFFFFLL;
  }

  __int128 v73 = v17;
  uint64_t v25 = xmlNewParserCtxt();
  if (!v25)
  {
    int v54 = "xmlSchemaGetDoc, allocating a parser context";
    goto LABEL_94;
  }

  uint64_t v26 = v25;
  if (*(void *)(a1 + 152))
  {
    dict = v25->dict;
    if (dict)
    {
      xmlDictFree(dict);
      int v28 = *(xmlDict **)(a1 + 152);
      v26->dict = v28;
      xmlDictReference(v28);
    }
  }

  if (v14)
  {
    htmlDocPtr File = xmlCtxtReadFile(v26, (const char *)v14, 0LL, 2);
    if (!File)
    {
LABEL_122:
      LastError = xmlGetLastError();
      if (LastError && LastError->domain == 8)
      {
        xmlFreeParserCtxt(v26);
        if (v18)
        {
          v18[1] = (const xmlChar *)v14;
          *((_DWORD *)v18 + 12) = 0;
          goto LABEL_126;
        }

  unsigned int v10 = 0LL;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *(_OWORD *)BOOL v6 = 0u;
  *(_DWORD *)BOOL v6 = 1;
  *((_DWORD *)v6 + 22) = *(_DWORD *)(a1 + 172);
  *(void *)(a1 + 192) = v6;
  *(_DWORD *)(a1 + 296) = 0;
  return v10;
}

    xmlXPathContextPtr v13 = xmlMalloc(0x10uLL);
    if (v13)
    {
      uint64_t v14 = v13;
      int v15 = xmlStrdup(name);
      *(void *)uint64_t v14 = v15;
      if (v15)
      {
        v14[2] = 1;
        xmlListPushFront(*((xmlListPtr *)writer + 1), v14);
        if (*((_DWORD *)writer + 7)) {
          v9 += xmlTextWriterWriteIndent((uint64_t)writer);
        }
        uint64_t v16 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, "<");
        if ((v16 & 0x80000000) == 0)
        {
          uint64_t v17 = v16;
          int v18 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, *(const char **)v14);
          if ((v18 & 0x80000000) == 0) {
            return v17 + v9 + v18;
          }
        }
      }

      else
      {
        xmlWriterErrMsg((uint64_t)writer, 2, (char)"xmlTextWriterStartElement : out of memory!\n");
        xmlFree(v14);
      }
    }

    else
    {
      xmlWriterErrMsg((uint64_t)writer, 2, (char)"xmlTextWriterStartElement : out of memory!\n");
    }

    return -1;
  }

  return result;
}

  xmlListPopFront(*((xmlListPtr *)writer + 1));
  return v8;
}

uint64_t xmlCtxtCheckName(uint64_t result, xmlChar *value)
{
  if (*(_DWORD *)(result + 144))
  {
    uint64_t v3 = result;
    if (value)
    {
      if (xmlValidateName(value, 0)) {
        xmlDebugErr3(v3, 5034, "Name is not an NCName '%s'", (char)value);
      }
      int result = *(void *)(v3 + 136);
      if (result)
      {
        int result = xmlDictOwns((xmlDictPtr)result, value);
        if (!(_DWORD)result)
        {
          uint64_t v4 = *(void *)(v3 + 120);
          if (!v4 || (*(_BYTE *)(v4 + 169) & 0x12) == 0) {
            return (uint64_t)xmlDebugErr3(v3, 5035, "Name is not from the document dictionary '%s'", (char)value);
          }
        }
      }
    }

    else
    {
      return (uint64_t)xmlDebugErr(result, 5015, (char)"Name is NULL");
    }
  }

  return result;
}

_DWORD *xmlDebugErr3(uint64_t a1, int a2, const char *a3, char a4)
{
  return __xmlRaiseError(0LL, 0LL, 0LL, 0LL, *(void *)(a1 + 128), 0x18u, a2, 2, 0LL, 0, 0LL, 0LL, 0LL, 0, 0, a3, a4);
}

_DWORD *xmlCtxtDumpDocHead(_DWORD *result, uint64_t a2)
{
  *((void *)result + 16) = a2;
  int v2 = *(_DWORD *)(a2 + 8);
  switch(v2)
  {
    case 1:
      uint64_t v3 = "Misplaced ELEMENT node\n";
      int v4 = 5000;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 2:
      uint64_t v3 = "Misplaced ATTRIBUTE node\n";
      int v4 = 5001;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 3:
      uint64_t v3 = "Misplaced TEXT node\n";
      int v4 = 5002;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 4:
      uint64_t v3 = "Misplaced CDATA node\n";
      int v4 = 5003;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 5:
      uint64_t v3 = "Misplaced ENTITYREF node\n";
      int v4 = 5004;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 6:
      uint64_t v3 = "Misplaced ENTITY node\n";
      int v4 = 5005;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 7:
      uint64_t v3 = "Misplaced PI node\n";
      int v4 = 5006;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 8:
      uint64_t v3 = "Misplaced COMMENT node\n";
      int v4 = 5007;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 9:
      if (result[36]) {
        return result;
      }
      unsigned int v5 = *(FILE **)result;
      BOOL v6 = "DOCUMENT\n";
      size_t v7 = 9LL;
      return (_DWORD *)fwrite(v6, v7, 1uLL, v5);
    case 10:
      uint64_t v3 = "Misplaced DOCTYPE node\n";
      int v4 = 5008;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 11:
      uint64_t v3 = "Misplaced FRAGMENT node\n";
      int v4 = 5009;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 12:
      uint64_t v3 = "Misplaced NOTATION node\n";
      int v4 = 5010;
      return xmlDebugErr((uint64_t)result, v4, (char)v3);
    case 13:
      if (result[36]) {
        return result;
      }
      unsigned int v5 = *(FILE **)result;
      BOOL v6 = "HTML DOCUMENT\n";
      size_t v7 = 14LL;
      return (_DWORD *)fwrite(v6, v7, 1uLL, v5);
    default:
      return xmlDebugErr3((uint64_t)result, 5011, "Unknown node type %d\n", v2);
  }

size_t xmlCtxtDumpEntityCallback(size_t result, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 144);
  if (result)
  {
    if (!v3)
    {
      size_t v4 = result;
      fprintf(*(FILE **)a2, "%s : ", *(const char **)(result + 16));
      int v5 = *(_DWORD *)(v4 + 92);
      switch(v5)
      {
        case 1:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "INTERNAL GENERAL, ";
          size_t v8 = 18LL;
          goto LABEL_14;
        case 2:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "EXTERNAL PARSED, ";
          size_t v8 = 17LL;
          goto LABEL_14;
        case 3:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "EXTERNAL UNPARSED, ";
          size_t v8 = 19LL;
          goto LABEL_14;
        case 4:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "INTERNAL PARAMETER, ";
          goto LABEL_13;
        case 5:
          BOOL v6 = *(FILE **)a2;
          size_t v7 = "EXTERNAL PARAMETER, ";
LABEL_13:
          size_t v8 = 20LL;
LABEL_14:
          fwrite(v7, v8, 1uLL, v6);
          break;
        default:
          xmlDebugErr3(a2, 5012, "Unknown entity type %d\n", v5);
          break;
      }

      if (*(void *)(v4 + 96)) {
        fprintf(*(FILE **)a2, "ID %s", *(const char **)(v4 + 96));
      }
      if (*(void *)(v4 + 104)) {
        fprintf(*(FILE **)a2, "SYSTEM %s", *(const char **)(v4 + 104));
      }
      if (*(void *)(v4 + 72)) {
        fprintf(*(FILE **)a2, "\n orig %s", *(const char **)(v4 + 72));
      }
      if (*(_DWORD *)(v4 + 8) != 1)
      {
        if (*(void *)(v4 + 80)) {
          fprintf(*(FILE **)a2, "\n content %s", *(const char **)(v4 + 80));
        }
      }

      return fputc(10, *(FILE **)a2);
    }
  }

  else if (!v3)
  {
    return fwrite("Entity is NULL", 0xEuLL, 1uLL, *(FILE **)a2);
  }

  return result;
}

_DWORD *xmlCtxtDumpDtdNode(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) != 14) {
    return xmlDebugErr(a1, 5022, (char)"Node is not a DTD");
  }
  if (!*(_DWORD *)(a1 + 144))
  {
    size_t v4 = *(FILE **)a1;
    if (*(void *)(a2 + 16)) {
      fprintf(v4, "DTD(%s)", *(const char **)(a2 + 16));
    }
    else {
      fwrite("DTD", 3uLL, 1uLL, v4);
    }
    if (*(void *)(a2 + 104)) {
      fprintf(*(FILE **)a1, ", PUBLIC %s", *(const char **)(a2 + 104));
    }
    if (*(void *)(a2 + 112)) {
      fprintf(*(FILE **)a1, ", SYSTEM %s", *(const char **)(a2 + 112));
    }
    fputc(10, *(FILE **)a1);
  }

  return (_DWORD *)xmlCtxtGenericNodeCheck(a1, a2);
}

_DWORD *xmlCtxtDumpNamespace(size_t a1, uint64_t a2)
{
  int result = (_DWORD *)xmlCtxtDumpSpaces(a1);
  if (*(_DWORD *)(a2 + 8) != 18)
  {
    int v5 = "Node is not a namespace declaration";
    uint64_t v6 = a1;
    int v7 = 5027;
    return xmlDebugErr(v6, v7, (char)v5);
  }

  if (!*(void *)(a2 + 16))
  {
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8) {
      return xmlDebugErr3(a1, 5028, "Incomplete namespace %s href=NULL\n", v8);
    }
    int v5 = "Incomplete default namespace href=NULL\n";
    uint64_t v6 = a1;
    int v7 = 5028;
    return xmlDebugErr(v6, v7, (char)v5);
  }

  if (!*(_DWORD *)(a1 + 144))
  {
    uint64_t v9 = *(FILE **)a1;
    if (*(void *)(a2 + 24)) {
      fprintf(v9, "namespace %s href=", *(const char **)(a2 + 24));
    }
    else {
      fwrite("default namespace href=", 0x17uLL, 1uLL, v9);
    }
    xmlCtxtDumpString(a1, *(void *)(a2 + 16));
    return (_DWORD *)fputc(10, *(FILE **)a1);
  }

  return result;
}

int xmlInitializeDict(void)
{
  return 0;
}

BOOL __xmlInitializeDict()
{
  if (xmlDictMutex) {
    return 1LL;
  }
  pthread_once(&once_control_0, _xmlInitializeDictMutex);
  return xmlDictMutex != 0;
}

void _xmlInitializeDictMutex()
{
  xmlDictMutex = (uint64_t)xmlNewRMutex();
  xmlRMutexLock((xmlRMutexPtr)xmlDictMutex);
  rand_seed = time(0LL);
  rand_r((unsigned int *)&rand_seed);
  xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
}

uint64_t __xmlRandom()
{
  xmlGenericErrorFunc v0 = (xmlRMutex *)xmlDictMutex;
  if (!xmlDictMutex)
  {
    pthread_once(&once_control_0, _xmlInitializeDictMutex);
    xmlGenericErrorFunc v0 = (xmlRMutex *)xmlDictMutex;
  }

  xmlRMutexLock(v0);
  uint64_t v1 = rand_r((unsigned int *)&rand_seed);
  xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
  return v1;
}

xmlDictPtr xmlDictCreate(void)
{
  if (!xmlDictMutex)
  {
    pthread_once(&once_control_0, _xmlInitializeDictMutex);
    if (!xmlDictMutex) {
      return 0LL;
    }
  }

  xmlGenericErrorFunc v0 = xmlMalloc(0x40uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    *(_DWORD *)xmlGenericErrorFunc v0 = 1;
    v0[7] = 0LL;
    v0[2] = 128LL;
    *((_DWORD *)v0 + 6) = 0;
    int v2 = xmlMalloc(0x1000uLL);
    v1[1] = v2;
    v1[4] = 0LL;
    v1[5] = 0LL;
    if (v2)
    {
      bzero(v2, 0x1000uLL);
      *((_DWORD *)v1 + 12) = __xmlRandom();
      return (xmlDictPtr)v1;
    }

    xmlFree(v1);
    return 0LL;
  }

  return (xmlDictPtr)v1;
}

xmlDictPtr xmlDictCreateSub(xmlDictPtr sub)
{
  xmlDictPtr v2 = xmlDictCreate();
  int v3 = v2;
  if (sub && v2)
  {
    *((_DWORD *)v2 + 12) = *((_DWORD *)sub + 12);
    *((void *)v2 + 5) = sub;
    xmlDictReference(sub);
  }

  return v3;
}

int xmlDictReference(xmlDictPtr dict)
{
  xmlDictPtr v2 = (xmlRMutex *)xmlDictMutex;
  if (xmlDictMutex)
  {
    if (!dict) {
      return -1;
    }
    goto LABEL_6;
  }

  pthread_once(&once_control_0, _xmlInitializeDictMutex);
  int result = -1;
  if (dict)
  {
    xmlDictPtr v2 = (xmlRMutex *)xmlDictMutex;
    if (xmlDictMutex)
    {
LABEL_6:
      xmlRMutexLock(v2);
      ++*(_DWORD *)dict;
      xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
      return 0;
    }
  }

  return result;
}

void xmlDictFree(xmlDictPtr dict)
{
  if (dict)
  {
    xmlDictPtr v2 = (xmlRMutex *)xmlDictMutex;
    if (xmlDictMutex
      || (pthread_once(&once_control_0, _xmlInitializeDictMutex), (xmlDictPtr v2 = (xmlRMutex *)xmlDictMutex) != 0LL))
    {
      xmlRMutexLock(v2);
      int v3 = (*(_DWORD *)dict)--;
      xmlRMutexUnlock((xmlRMutexPtr)xmlDictMutex);
      if (v3 <= 1)
      {
        size_t v4 = (xmlDict *)*((void *)dict + 5);
        if (v4) {
          xmlDictFree(v4);
        }
        int v5 = (char *)*((void *)dict + 1);
        if (v5)
        {
          unint64_t v6 = *((void *)dict + 2);
          if (v6)
          {
            uint64_t v7 = 0LL;
            int v8 = *((_DWORD *)dict + 6);
            while (1)
            {
              int v5 = (char *)*((void *)dict + 1);
              if (!v8) {
                break;
              }
              uint64_t v9 = &v5[32 * v7];
              if (*((_DWORD *)v9 + 5)) {
                BOOL v10 = v5 == 0LL;
              }
              else {
                BOOL v10 = 1;
              }
              if (!v10)
              {
                char v11 = 0;
                do
                {
                  uint64_t v12 = *(char **)v9;
                  if ((v11 & 1) != 0)
                  {
                    xmlFree(v9);
                    int v8 = *((_DWORD *)dict + 6);
                  }

                  *((_DWORD *)dict + 6) = --v8;
                  char v11 = 1;
                  uint64_t v9 = v12;
                }

                while (v12);
                unint64_t v6 = *((void *)dict + 2);
              }

              if (++v7 >= v6)
              {
                int v5 = (char *)*((void *)dict + 1);
                break;
              }
            }
          }

          xmlFree(v5);
        }

        xmlXPathContextPtr v13 = (void *)*((void *)dict + 4);
        if (v13)
        {
          do
          {
            uint64_t v14 = (void *)*v13;
            xmlFree(v13);
            xmlXPathContextPtr v13 = v14;
          }

          while (v14);
        }

        xmlFree(dict);
      }
    }
  }

const xmlChar *__cdecl xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len)
{
  int v3 = 0LL;
  if (!dict || !name) {
    return v3;
  }
  if (len < 0) {
    size_t v6 = strlen((const char *)name);
  }
  else {
    size_t v6 = len;
  }
  size_t v7 = *((void *)dict + 7);
  if (v7)
  {
    int v3 = 0LL;
    if (v6 >> 30 || v6 >= v7) {
      return v3;
    }
  }

  else if (v6 >> 30)
  {
    return 0LL;
  }

  unint64_t v8 = *((void *)dict + 2);
  if (v8 == 128)
  {
    unint64_t v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *((_DWORD *)dict + 12));
  }

  else
  {
    if (v6)
    {
      unsigned int v10 = *((_DWORD *)dict + 12);
      char v11 = name;
      size_t v12 = v6;
      do
      {
        int v13 = *v11++;
        unsigned int v10 = (1025 * (v10 + v13)) ^ ((1025 * (v10 + v13)) >> 6);
        --v12;
      }

      while (v12);
      unsigned int v14 = 32769 * ((9 * v10) ^ ((9 * v10) >> 11));
    }

    else
    {
      unsigned int v14 = 0;
    }

    unint64_t v9 = v14;
  }

  uint64_t v15 = *((void *)dict + 1) + 32 * (v9 % v8);
  unint64_t v41 = v9 % v8;
  if (!*(_DWORD *)(v15 + 20))
  {
    unint64_t v17 = 0LL;
    uint64_t v15 = 0LL;
LABEL_32:
    uint64_t v19 = *((void *)dict + 5);
    if (v19)
    {
      unint64_t v20 = *(void *)(v19 + 16);
      if (v8 == 128)
      {
        if (v20 == 128)
        {
          unint64_t v21 = v9;
        }

        else if ((int)v6 < 1)
        {
          unint64_t v21 = 0LL;
        }

        else
        {
          unsigned int v22 = *(_DWORD *)(v19 + 48);
          uint64_t v23 = v6;
          uint64_t v24 = name;
          do
          {
            int v25 = *v24++;
            unsigned int v22 = (1025 * (v22 + v25)) ^ ((1025 * (v22 + v25)) >> 6);
            --v23;
          }

          while (v23);
          unint64_t v21 = 32769 * ((9 * v22) ^ ((9 * v22) >> 11));
        }
      }

      else
      {
        unint64_t v21 = v9;
        if (v20 == 128)
        {
          unint64_t v21 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *(_DWORD *)(v19 + 48));
          unint64_t v20 = 128LL;
        }
      }

      uint64_t v26 = *(void *)(v19 + 8) + 32 * (v21 % v20);
      if (*(_DWORD *)(v26 + 20))
      {
        while (*(void *)v26)
        {
          uint64_t v27 = v26;
          uint64_t v26 = *(void *)v26;
          if (*(void *)(v27 + 24) == v21 && v6 == *(_DWORD *)(v27 + 16))
          {
            int v3 = *(xmlChar **)(v27 + 8);
            if (!memcmp(v3, name, v6)) {
              return v3;
            }
          }

          ++v17;
        }

        if (*(void *)(v26 + 24) == v21 && v6 == *(_DWORD *)(v26 + 16))
        {
          int v3 = *(xmlChar **)(v26 + 8);
          if (!memcmp(v3, name, v6)) {
            return v3;
          }
        }
      }
    }

    int v28 = (void *)*((void *)dict + 4);
    if (v28)
    {
      size_t v29 = 0LL;
      unint64_t v30 = 0LL;
      size_t v31 = v6;
      while (1)
      {
        int v3 = (xmlChar *)v28[1];
        unint64_t v32 = v28[3];
        if (v32 > v30) {
          unint64_t v30 = v28[3];
        }
        v29 += v32;
        int v28 = (void *)*v28;
        if (!v28)
        {
          if (v7 && v29 > v7) {
            return 0LL;
          }
          if (!v30) {
            goto LABEL_62;
          }
          unint64_t v33 = 4 * v30;
          goto LABEL_63;
        }
      }
    }

    else
    {
LABEL_62:
      unint64_t v33 = 1000LL;
LABEL_63:
      else {
        unint64_t v34 = v33;
      }
      size_t v35 = xmlMalloc(v34 + 48);
      if (!v35) {
        return 0LL;
      }
      int v28 = v35;
      v35[3] = v34;
      v35[4] = 0LL;
      int v3 = (xmlChar *)(v35 + 5);
      v35[2] = (char *)v35 + v34 + 40;
      *size_t v35 = *((void *)dict + 4);
      v35[1] = v35 + 5;
      *((void *)dict + 4) = v35;
      size_t v31 = v6;
    }

    memcpy(v3, name, v31);
    uint64_t v36 = (_BYTE *)(v28[1] + v31);
    v28[1] = v36 + 1;
    _BYTE *v36 = 0;
    ++v28[4];
    if (!v3) {
      return v3;
    }
    if (v15)
    {
      xmlGenericErrorFunc v37 = xmlMalloc(0x20uLL);
      if (!v37) {
        return 0LL;
      }
      void *v37 = 0LL;
      v37[1] = v3;
      *((_DWORD *)v37 + 4) = v6;
      *((_DWORD *)v37 + 5) = 1;
      v37[3] = v9;
      *(void *)uint64_t v15 = v37;
    }

    else
    {
      uint64_t v38 = *((void *)dict + 1) + 32 * v41;
      *(void *)uint64_t v38 = 0LL;
      *(void *)(v38 + 8) = v3;
      *(_DWORD *)(v38 + 16) = v6;
      *(_DWORD *)(v38 + 20) = 1;
      *(void *)(v38 + 24) = v9;
    }

    ++*((_DWORD *)dict + 6);
    if (v17 < 4) {
      return v3;
    }
    unint64_t v39 = *((void *)dict + 2);
    return 0LL;
  }

  uint64_t v16 = *(void *)v15;
  if (*(void *)v15)
  {
    unint64_t v17 = 0LL;
    while (1)
    {
      uint64_t v18 = v15;
      uint64_t v15 = v16;
      if (*(void *)(v18 + 24) == v9 && v6 == *(_DWORD *)(v18 + 16))
      {
        int v3 = *(xmlChar **)(v18 + 8);
        if (!memcmp(v3, name, v6)) {
          return v3;
        }
      }

      ++v17;
      uint64_t v16 = *(void *)v15;
      if (!*(void *)v15) {
        goto LABEL_29;
      }
    }
  }

  unint64_t v17 = 0LL;
LABEL_29:
  if (*(void *)(v15 + 24) != v9) {
    goto LABEL_32;
  }
  if (v6 != *(_DWORD *)(v15 + 16)) {
    goto LABEL_32;
  }
  int v3 = *(xmlChar **)(v15 + 8);
  if (memcmp(v3, name, v6)) {
    goto LABEL_32;
  }
  return v3;
}

uint64_t xmlDictComputeFastKey(unsigned __int8 *a1, int a2, int a3)
{
  uint64_t result = a3;
  if (a1 && a2 >= 1)
  {
    uint64_t result = 32 * (*a1 + (uint64_t)a3);
    if (a2 < 0xB)
    {
      switch(a2)
      {
        case 2:
          goto LABEL_13;
        case 3:
          goto LABEL_12;
        case 4:
          goto LABEL_11;
        case 5:
          goto LABEL_10;
        case 6:
          goto LABEL_9;
        case 7:
          goto LABEL_8;
        case 8:
          goto LABEL_7;
        case 9:
          goto LABEL_6;
        case 10:
          goto LABEL_5;
        default:
          return result;
      }
    }

    else
    {
      result += a1[a2 - 1];
LABEL_5:
      result += a1[9];
LABEL_6:
      result += a1[8];
LABEL_7:
      result += a1[7];
LABEL_8:
      result += a1[6];
LABEL_9:
      result += a1[5];
LABEL_10:
      result += a1[4];
LABEL_11:
      result += a1[3];
LABEL_12:
      result += a1[2];
LABEL_13:
      result += a1[1];
    }
  }

  return result;
}

uint64_t xmlDictGrow(uint64_t a1, unint64_t a2)
{
  if (a2 < 8) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *(void **)(a1 + 8);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  size_t v6 = 32 * a2;
  size_t v7 = xmlMalloc(32 * a2);
  *(void *)(a1 + 8) = v7;
  if (!v7)
  {
    *(void *)(a1 + 8) = v3;
    return 0xFFFFFFFFLL;
  }

  bzero(v7, v6);
  *(void *)(a1 + 16) = a2;
  uint64_t v8 = 0LL;
  if (v5)
  {
    for (uint64_t i = 0LL; i != v5; ++i)
    {
      unsigned int v10 = (char *)&v3[4 * i];
      if (*((_DWORD *)v10 + 5))
      {
        if (v5 == 128)
        {
          unint64_t v11 = *(void *)(a1 + 16);
          size_t v12 = (char *)&v3[4 * i];
          int v13 = (unsigned __int8 *)*((void *)v12 + 1);
          uint64_t v14 = *((unsigned int *)v12 + 4);
          if (v11 == 128)
          {
            unint64_t v15 = xmlDictComputeFastKey(v13, v14, *(_DWORD *)(a1 + 48));
            unint64_t v11 = 128LL;
          }

          else
          {
            if (v13) {
              BOOL v16 = (int)v14 < 1;
            }
            else {
              BOOL v16 = 1;
            }
            if (v16)
            {
              unsigned int v17 = 0;
            }

            else
            {
              unsigned int v18 = *(_DWORD *)(a1 + 48);
              do
              {
                int v19 = *v13++;
                unsigned int v18 = (1025 * (v18 + v19)) ^ ((1025 * (v18 + v19)) >> 6);
                --v14;
              }

              while (v14);
              unsigned int v17 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
            }

            unint64_t v15 = v17;
          }
        }

        else
        {
          unint64_t v15 = v3[4 * i + 3];
          unint64_t v11 = *(void *)(a1 + 16);
        }

        unint64_t v20 = v15 % v11;
        uint64_t v21 = *(void *)(a1 + 8) + 32 * (v15 % v11);
        if (*(_DWORD *)(v21 + 20))
        {
          unsigned int v22 = xmlMalloc(0x20uLL);
          if (v22)
          {
            uint64_t v23 = (char *)&v3[4 * i];
            uint64_t v24 = *((void *)v23 + 1);
            LODWORD(v23) = *((_DWORD *)v23 + 4);
            v22[3] = v15;
            uint64_t v25 = *(void *)(a1 + 8);
            *unsigned int v22 = *(void *)(v25 + 32 * v20);
            v22[1] = v24;
            *((_DWORD *)v22 + 4) = (_DWORD)v23;
            *((_DWORD *)v22 + 5) = 1;
            *(void *)(v25 + 32 * v20) = v22;
          }

          else
          {
            uint64_t v8 = 0xFFFFFFFFLL;
          }
        }

        else
        {
          __int128 v26 = *((_OWORD *)v10 + 1);
          *(_OWORD *)uint64_t v21 = *(_OWORD *)v10;
          *(_OWORD *)(v21 + 16) = v26;
          uint64_t v27 = (void *)(*(void *)(a1 + 8) + 32 * v20);
          *uint64_t v27 = 0LL;
          v27[3] = v15;
        }
      }
    }

    for (uint64_t j = 0LL; j != v5; ++j)
    {
      size_t v29 = (unsigned int *)v3[4 * j];
      if (v29)
      {
        do
        {
          unint64_t v30 = *(unsigned int **)v29;
          if (v5 == 128)
          {
            unint64_t v31 = *(void *)(a1 + 16);
            unint64_t v32 = (unsigned __int8 *)*((void *)v29 + 1);
            uint64_t v33 = v29[4];
            if (v31 == 128)
            {
              unint64_t v34 = xmlDictComputeFastKey(v32, v33, *(_DWORD *)(a1 + 48));
              unint64_t v31 = 128LL;
            }

            else
            {
              if (v32) {
                BOOL v35 = (int)v33 < 1;
              }
              else {
                BOOL v35 = 1;
              }
              if (v35)
              {
                unsigned int v36 = 0;
              }

              else
              {
                unsigned int v37 = *(_DWORD *)(a1 + 48);
                do
                {
                  int v38 = *v32++;
                  unsigned int v37 = (1025 * (v37 + v38)) ^ ((1025 * (v37 + v38)) >> 6);
                  --v33;
                }

                while (v33);
                unsigned int v36 = 32769 * ((9 * v37) ^ ((9 * v37) >> 11));
              }

              unint64_t v34 = v36;
            }
          }

          else
          {
            unint64_t v34 = *((void *)v29 + 3);
            unint64_t v31 = *(void *)(a1 + 16);
          }

          unint64_t v39 = v34 % v31;
          uint64_t v40 = *(void *)(a1 + 8) + 32 * (v34 % v31);
          if (*(_DWORD *)(v40 + 20))
          {
            *(void *)size_t v29 = *(void *)v40;
            *((void *)v29 + 3) = v34;
            *(void *)uint64_t v40 = v29;
          }

          else
          {
            __int128 v41 = *((_OWORD *)v29 + 1);
            *(_OWORD *)uint64_t v40 = *(_OWORD *)v29;
            *(_OWORD *)(v40 + 16) = v41;
            uint64_t v42 = *(void *)(a1 + 8) + 32 * v39;
            *(void *)uint64_t v42 = 0LL;
            *(_DWORD *)(v42 + 20) = 1;
            *(void *)(v42 + 24) = v34;
            xmlFree(v29);
          }

          size_t v29 = v30;
        }

        while (v30);
      }
    }
  }

  xmlFree(v3);
  return v8;
}

const xmlChar *__cdecl xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len)
{
  int v3 = 0LL;
  if (dict && name)
  {
    if (len < 0) {
      size_t v6 = strlen((const char *)name);
    }
    else {
      size_t v6 = len;
    }
    size_t v7 = *((void *)dict + 7);
    if (v7)
    {
      int v3 = 0LL;
      if (v6 >> 30 || v6 >= v7) {
        return v3;
      }
    }

    else if (v6 >> 30)
    {
      return 0LL;
    }

    unint64_t v8 = *((void *)dict + 2);
    if (v8 == 128)
    {
      unint64_t v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *((_DWORD *)dict + 12));
    }

    else if (v6)
    {
      unsigned int v10 = *((_DWORD *)dict + 12);
      unint64_t v11 = name;
      size_t v12 = v6;
      do
      {
        int v13 = *v11++;
        unsigned int v10 = (1025 * (v10 + v13)) ^ ((1025 * (v10 + v13)) >> 6);
        --v12;
      }

      while (v12);
      unint64_t v9 = 32769 * ((9 * v10) ^ ((9 * v10) >> 11));
    }

    else
    {
      unint64_t v9 = 0LL;
    }

    uint64_t v14 = *((void *)dict + 1) + 32 * (v9 % v8);
    if (!*(_DWORD *)(v14 + 20)) {
      goto LABEL_50;
    }
    while (*(void *)v14)
    {
      uint64_t v15 = v14;
      uint64_t v14 = *(void *)v14;
      if (*(void *)(v15 + 24) == v9 && v6 == *(_DWORD *)(v15 + 16))
      {
        int v3 = *(const xmlChar **)(v15 + 8);
        if (!memcmp(v3, name, v6)) {
          return v3;
        }
      }
    }

    if (*(void *)(v14 + 24) != v9
      || v6 != *(_DWORD *)(v14 + 16)
      || (int v3 = *(const xmlChar **)(v14 + 8), memcmp(v3, name, v6)))
    {
LABEL_50:
      uint64_t v16 = *((void *)dict + 5);
      if (!v16) {
        return 0LL;
      }
      unint64_t v17 = *(void *)(v16 + 16);
      if (v8 == 128)
      {
        if (v17 != 128)
        {
          if ((int)v6 < 1)
          {
            unint64_t v9 = 0LL;
          }

          else
          {
            unsigned int v18 = *(_DWORD *)(v16 + 48);
            uint64_t v19 = v6;
            unint64_t v20 = name;
            do
            {
              int v21 = *v20++;
              unsigned int v18 = (1025 * (v18 + v21)) ^ ((1025 * (v18 + v21)) >> 6);
              --v19;
            }

            while (v19);
            unint64_t v9 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
          }
        }
      }

      else if (v17 == 128)
      {
        unint64_t v9 = xmlDictComputeFastKey((unsigned __int8 *)name, v6, *(_DWORD *)(v16 + 48));
        unint64_t v17 = 128LL;
      }

      uint64_t v22 = *(void *)(v16 + 8) + 32 * (v9 % v17);
      if (!*(_DWORD *)(v22 + 20)) {
        return 0LL;
      }
      while (*(void *)v22)
      {
        uint64_t v23 = v22;
        uint64_t v22 = *(void *)v22;
        if (*(void *)(v23 + 24) == v9 && v6 == *(_DWORD *)(v23 + 16))
        {
          int v3 = *(const xmlChar **)(v23 + 8);
          if (!memcmp(v3, name, v6)) {
            return v3;
          }
        }
      }

      if (*(void *)(v22 + 24) != v9) {
        return 0LL;
      }
      if (v6 != *(_DWORD *)(v22 + 16)) {
        return 0LL;
      }
      int v3 = *(const xmlChar **)(v22 + 8);
      if (memcmp(v3, name, v6)) {
        return 0LL;
      }
    }
  }

  return v3;
}

const xmlChar *__cdecl xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name)
{
  int v3 = 0LL;
  if (dict && name)
  {
    if (!prefix) {
      return xmlDictLookup(dict, name, -1);
    }
    size_t v7 = strlen((const char *)name);
    size_t v8 = strlen((const char *)prefix);
    int v3 = 0LL;
    if (!(v7 >> 30) && !(v8 >> 30))
    {
      size_t v9 = v8 + v7;
      unint64_t v10 = *((void *)dict + 2);
      unsigned int v11 = *((_DWORD *)dict + 12);
      unsigned int v42 = v8;
      if (v10 == 128) {
        unint64_t v12 = xmlDictComputeFastQKey((unsigned __int8 *)prefix, v8, (unsigned __int8 *)name, v7, v11);
      }
      else {
        unint64_t v12 = xmlDictComputeBigQKey((unsigned __int8 *)prefix, v8, (unsigned __int8 *)name, v7, v11);
      }
      unint64_t v14 = v12;
      int v41 = v9;
      size_t v15 = v9 + 1;
      unint64_t v16 = v12 % v10;
      uint64_t v17 = *((void *)dict + 1) + 32 * v16;
      unsigned int v43 = v7;
      if (*(_DWORD *)(v17 + 20))
      {
        unsigned int v18 = *(void **)v17;
        if (*(void *)v17)
        {
          unint64_t v19 = 0LL;
          do
          {
            if (*(void *)(v17 + 24) == v14 && v15 == *(_DWORD *)(v17 + 16))
            {
              if (xmlStrQEqual(prefix, name, *(const xmlChar **)(v17 + 8))) {
                return *(const xmlChar **)(v17 + 8);
              }
              unsigned int v18 = *(void **)v17;
            }

            uint64_t v17 = (uint64_t)v18;
            ++v19;
            unsigned int v18 = (void *)*v18;
          }

          while (v18);
        }

        else
        {
          unint64_t v19 = 0LL;
        }

        if (*(void *)(v17 + 24) == v14
          && v15 == *(_DWORD *)(v17 + 16)
          && xmlStrQEqual(prefix, name, *(const xmlChar **)(v17 + 8)))
        {
          return *(const xmlChar **)(v17 + 8);
        }
      }

      else
      {
        unint64_t v19 = 0LL;
        uint64_t v17 = 0LL;
      }

      uint64_t v20 = *((void *)dict + 5);
      if (!v20)
      {
LABEL_45:
        __int128 v26 = (void *)*((void *)dict + 4);
        if (v26)
        {
          unint64_t v27 = 0LL;
          unint64_t v28 = 0LL;
          do
          {
            int v3 = (void *)v26[1];
            if (v26[2] - (void)v3 > (unint64_t)v15)
            {
              unint64_t v40 = v16;
              goto LABEL_64;
            }

            unint64_t v29 = v26[3];
            if (v29 > v28) {
              unint64_t v28 = v26[3];
            }
            v27 += v29;
            __int128 v26 = (void *)*v26;
          }

          while (v26);
          unint64_t v30 = *((void *)dict + 7);
          if (v30) {
            BOOL v31 = v27 > v30;
          }
          else {
            BOOL v31 = 0;
          }
          if (v31) {
            return 0LL;
          }
          if (!v28) {
            goto LABEL_57;
          }
          unint64_t v40 = v16;
          unint64_t v32 = 4 * v28;
        }

        else
        {
LABEL_57:
          unint64_t v40 = v16;
          unint64_t v32 = 1000LL;
        }

        else {
          unint64_t v33 = v32;
        }
        unint64_t v34 = xmlMalloc(v33 + 48);
        if (v34)
        {
          __int128 v26 = v34;
          v34[3] = v33;
          v34[4] = 0LL;
          int v3 = v34 + 5;
          v34[2] = (char *)v34 + v33 + 40;
          *unint64_t v34 = *((void *)dict + 4);
          v34[1] = v34 + 5;
          *((void *)dict + 4) = v34;
LABEL_64:
          memcpy(v3, prefix, v42);
          BOOL v35 = (_BYTE *)(v26[1] + v42);
          v26[1] = v35 + 1;
          *BOOL v35 = 58;
          memcpy((void *)v26[1], name, v43);
          unsigned int v36 = (_BYTE *)(v26[1] + v43);
          v26[1] = v36 + 1;
          _BYTE *v36 = 0;
          ++v26[4];
          if (!v3) {
            return (const xmlChar *)v3;
          }
          if (!v17)
          {
            uint64_t v38 = *((void *)dict + 1) + 32 * v40;
            *(void *)uint64_t v38 = 0LL;
            *(void *)(v38 + 8) = v3;
            *(_DWORD *)(v38 + 16) = v15;
            *(_DWORD *)(v38 + 20) = 1;
            *(void *)(v38 + 24) = v14;
LABEL_70:
            ++*((_DWORD *)dict + 6);
            if (v19 >= 4)
            {
              unint64_t v39 = *((void *)dict + 2);
              if (v39 <= 0xAAA) {
                xmlDictGrow((uint64_t)dict, 6 * v39);
              }
            }

            return (const xmlChar *)v3;
          }

          unsigned int v37 = xmlMalloc(0x20uLL);
          if (v37)
          {
            void *v37 = 0LL;
            v37[1] = v3;
            *((_DWORD *)v37 + 4) = v15;
            *((_DWORD *)v37 + 5) = 1;
            v37[3] = v14;
            *(void *)uint64_t v17 = v37;
            goto LABEL_70;
          }
        }

        return 0LL;
      }

      unint64_t v21 = *(void *)(v20 + 16);
      if (*((void *)dict + 2) == 128LL)
      {
        if (v21 == 128)
        {
          unint64_t v22 = v14;
          goto LABEL_33;
        }

        uint64_t v23 = xmlDictComputeBigQKey((unsigned __int8 *)prefix, v42, (unsigned __int8 *)name, v43, *(_DWORD *)(v20 + 48));
      }

      else
      {
        unint64_t v22 = v14;
        if (v21 != 128) {
          goto LABEL_33;
        }
        uint64_t v23 = xmlDictComputeFastQKey( (unsigned __int8 *)prefix,  v42,  (unsigned __int8 *)name,  v43,  *(_DWORD *)(v20 + 48));
      }

      unint64_t v22 = v23;
LABEL_33:
      uint64_t v24 = *(void *)(v20 + 8) + 32 * (v22 % v21);
      if (*(_DWORD *)(v24 + 20))
      {
        uint64_t v25 = *(void **)v24;
        if (*(void *)v24)
        {
          do
          {
            if (*(void *)(v24 + 24) == v22 && v15 == *(_DWORD *)(v24 + 16))
            {
              if (xmlStrQEqual(prefix, name, *(const xmlChar **)(v24 + 8))) {
                return *(const xmlChar **)(v24 + 8);
              }
              uint64_t v25 = *(void **)v24;
            }

            uint64_t v24 = (uint64_t)v25;
            ++v19;
            uint64_t v25 = (void *)*v25;
          }

          while (v25);
        }

        if (*(void *)(v24 + 24) == v22
          && v15 == *(_DWORD *)(v24 + 16)
          && xmlStrQEqual(prefix, name, *(const xmlChar **)(v24 + 8)))
        {
          return *(const xmlChar **)(v24 + 8);
        }
      }

      unint64_t v16 = v14 % *((void *)dict + 2);
      goto LABEL_45;
    }
  }

  return (const xmlChar *)v3;
}

uint64_t xmlDictComputeFastQKey(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  if (a2) {
    uint64_t v5 = a5 + 30LL * *a1;
  }
  else {
    uint64_t v5 = a5 + 1740LL;
  }
  unsigned int v6 = a4 - 11;
  if (a4 >= 11)
  {
    if (a4 - a2 - 2 >= 0) {
      unsigned int v6 = a4 - a2 - 2;
    }
    v5 += a3[v6];
    a4 = 10;
    if (a2 >= 10) {
      a2 = 10;
    }
  }

  switch(a2)
  {
    case 1:
      goto LABEL_19;
    case 2:
      goto LABEL_18;
    case 3:
      goto LABEL_17;
    case 4:
      goto LABEL_16;
    case 5:
      goto LABEL_15;
    case 6:
      goto LABEL_14;
    case 7:
      goto LABEL_13;
    case 8:
      goto LABEL_12;
    case 9:
      goto LABEL_11;
    case 10:
      v5 += a1[9];
LABEL_11:
      v5 += a1[8];
LABEL_12:
      v5 += a1[7];
LABEL_13:
      v5 += a1[6];
LABEL_14:
      v5 += a1[5];
LABEL_15:
      v5 += a1[4];
LABEL_16:
      v5 += a1[3];
LABEL_17:
      v5 += a1[2];
LABEL_18:
      v5 += a1[1];
LABEL_19:
      v5 += *a1;
      break;
    default:
      break;
  }

  if (a4 <= a2) {
    uint64_t result = v5;
  }
  else {
    uint64_t result = v5 + 58;
  }
  switch(~(a4 > a2) + a4 - a2)
  {
    case 0:
      goto LABEL_32;
    case 1:
      goto LABEL_31;
    case 2:
      goto LABEL_30;
    case 3:
      goto LABEL_29;
    case 4:
      goto LABEL_28;
    case 5:
      goto LABEL_27;
    case 6:
      goto LABEL_26;
    case 7:
      goto LABEL_25;
    case 8:
      result += a3[8];
LABEL_25:
      result += a3[7];
LABEL_26:
      result += a3[6];
LABEL_27:
      result += a3[5];
LABEL_28:
      result += a3[4];
LABEL_29:
      result += a3[3];
LABEL_30:
      result += a3[2];
LABEL_31:
      result += a3[1];
LABEL_32:
      result += *a3;
      break;
    default:
      return result;
  }

  return result;
}

uint64_t xmlDictComputeBigQKey(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    do
    {
      int v6 = *a1++;
      a5 = (1025 * (a5 + v6)) ^ ((1025 * (a5 + v6)) >> 6);
      --v5;
    }

    while (v5);
  }

  unsigned int v7 = (1025 * a5 + 59450) ^ ((1025 * a5 + 59450) >> 6);
  if (a4 >= 1)
  {
    uint64_t v8 = a4;
    do
    {
      int v9 = *a3++;
      unsigned int v7 = (1025 * (v7 + v9)) ^ ((1025 * (v7 + v9)) >> 6);
      --v8;
    }

    while (v8);
  }

  return 32769 * ((9 * v7) ^ ((9 * v7) >> 11));
}

int xmlDictOwns(xmlDictPtr dict, const xmlChar *str)
{
  if (str)
  {
    while (dict)
    {
      xmlDictPtr v2 = (void *)*((void *)dict + 4);
      if (v2)
      {
        while (v2 + 5 > (void *)str || v2[1] < (unint64_t)str)
        {
          xmlDictPtr v2 = (void *)*v2;
          if (!v2) {
            goto LABEL_7;
          }
        }

        LODWORD(dict) = 1;
        return (int)dict;
      }

LABEL_7:
      dict = (xmlDictPtr)*((void *)dict + 5);
      if (!dict) {
        return (int)dict;
      }
    }
  }

  LODWORD(dict) = -1;
  return (int)dict;
}

  uconv_out = handler->uconv_out;
  if (uconv_out)
  {
    ucnv_close();
    ucnv_close();
    xmlFree(uconv_out);
    handler->uconv_out = 0LL;
    uconv_in = handler->uconv_in;
    if (!uconv_in) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  uconv_in = handler->uconv_in;
  if (uconv_in)
  {
LABEL_13:
    ucnv_close();
    ucnv_close();
    xmlFree(uconv_in);
    handler->uconv_in = 0LL;
LABEL_14:
    if (handler->name) {
      xmlFree(handler->name);
    }
    handler->name = 0LL;
    xmlFree(handler);
  }

  return 0;
}

  if (*v3 == 47)
  {
LABEL_8:
    if (v3 == &__dst) {
      int v3 = v6;
    }
    goto LABEL_14;
  }

  uint64_t result = getcwd(&__dst, 0x400uLL);
  if (!result) {
    return result;
  }
  int v3 = &v7;
LABEL_14:
  void *v3 = 0;
  return xmlMemStrdup(&__dst);
}

      if (*(_DWORD *)(v2 + 88) < *(_DWORD *)(a1 + 128) || *(_DWORD *)a1 == 3) {
        return 1LL;
      }
      if ((xmlTextReaderPushData(a1) & 0x80000000) != 0) {
        break;
      }
      uint64_t result = 1LL;
      if (*(_DWORD *)a1 == 3) {
        return result;
      }
    }

    *(_DWORD *)a1 = 2;
  }

  return 0xFFFFFFFFLL;
}

    xmlSchemaPIllegalAttrErr(a1, v12);
    goto LABEL_12;
  }

    ++a2;
    uint64_t v5 = *v3++;
    xmlDictPtr v2 = v5;
    if (!v5) {
      goto LABEL_15;
    }
  }

  if (v2 > 0x20 || ((1LL << v2) & 0x100002600LL) == 0)
  {
    if (v2 < v4) {
      return 0xFFFFFFFFLL;
    }
    if (v2 != v4) {
      return 1LL;
    }
    goto LABEL_7;
  }

  if (v4 > 0x20) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1LL;
  }
}

  int v6 = v5 + 1;
  for (n = v6; ; ++n)
  {
    uint64_t v8 = *(n - 1);
    if (((1LL << v8) & 0x100002600LL) == 0) {
      break;
    }
    a1->cur = n;
    LODWORD(v6) = (_DWORD)v6 + 1;
  }

  if (v8 == 36)
  {
    xmlGenericErrorFunc v126 = 0LL;
    a1->cur = n;
    unint64_t v16 = xmlXPathParseQName(a1, (xmlChar **)&v126);
    if (v16)
    {
      uint64_t v17 = v16;
      *((_DWORD *)a1->comp + 4) = -1;
      unsigned int v18 = (void *)v126;
      if (xmlXPathCompExprAdd((uint64_t)a1, 0xFFFFFFFF, 0xFFFFFFFF, 0xCu, 0, 0, 0, v16, (xmlChar *)v126) == -1)
      {
        xmlFree(v18);
        xmlFree(v17);
      }

      for (iuint64_t i = (uint64_t)(a1->cur + 1); ; ++ii)
      {
        uint64_t v20 = *(unsigned __int8 *)(ii - 1);
        unint64_t v21 = v20 > 0x20;
        unint64_t v22 = (1LL << v20) & 0x100002600LL;
        if (v21 || v22 == 0) {
          break;
        }
        a1->cur = (const xmlChar *)ii;
      }

      context = (unsigned __int8 *)a1->context;
      if (!context || (context[336] & 2) == 0)
      {
LABEL_60:
        for (juint64_t j = (uint64_t)(a1->cur + 1); ; ++jj)
        {
          unint64_t v33 = *(unsigned __int8 *)(jj - 1);
          unint64_t v21 = v33 > 0x20;
          unint64_t v34 = (1LL << v33) & 0x100002600LL;
          if (v21 || v34 == 0) {
            break;
          }
          a1->cur = (const xmlChar *)jj;
        }

        goto LABEL_101;
      }

      __int128 v26 = 24;
    }

    else
    {
      xmlFree((void *)v126);
      __int128 v26 = 4;
    }

    uint64_t v25 = a1;
    goto LABEL_59;
  }

  if (v8 != 40)
  {
LABEL_40:
    uint64_t v24 = v8 - 48;
    if ((v8 - 48) >= 0xA)
    {
      if ((_DWORD)v8 == 34)
      {
        for (kuint64_t k = n; ; ++kk)
        {
          a1->cur = kk;
          uint64_t v62 = *kk;
          if (v62 <= 0x1F)
          {
            if (v62 > 0xD || ((1 << v62) & 0x2600) == 0)
            {
LABEL_291:
              uint64_t v25 = a1;
              __int128 v26 = 2;
              goto LABEL_59;
            }
          }

          else if (v62 == 34)
          {
LABEL_150:
            uint64_t v64 = xmlStrndup(n, (int)kk - (int)v6);
            v65 = v64;
            if (*a1->cur) {
              ++a1->cur;
            }
            if (v64)
            {
              xmlXPathObjectPtr v66 = (xmlChar *)xmlXPathCacheNewString((uint64_t)a1->context, v64);
              if (v66)
              {
                uint64_t v68 = (xmlXPathObject *)v66;
                if (xmlXPathCompExprAdd( (uint64_t)a1,  *((_DWORD *)a1->comp + 4),  0xFFFFFFFF,  0xBu,  4u,  0,  0,  v66,  0LL) == -1) {
                  v67.n128_f64[0] = xmlXPathReleaseObject((uint64_t)a1->context, v68);
                }
              }

              else
              {
                a1->error = 15;
              }

              ((void (*)(xmlChar *, __n128))xmlFree)(v65, v67);
            }

            else
            {
              a1->error = 15;
              xmlXPathErrMemory((uint64_t)a1->context, 0LL);
            }

            goto LABEL_60;
          }
        }
      }

      if ((_DWORD)v8 == 39)
      {
        for (kuint64_t k = n; ; ++kk)
        {
          a1->cur = kk;
          int v63 = *kk;
          if (v63 <= 0x1F)
          {
            if (v63 > 0xD || ((1 << v63) & 0x2600) == 0) {
              goto LABEL_291;
            }
          }

          else if (v63 == 39)
          {
            goto LABEL_150;
          }
        }
      }

      if ((_DWORD)v8 != 46 || *n - 48 > 9)
      {
        xmlGenericErrorFunc v126 = 0LL;
        unint64_t v28 = xmlXPathParseQName(a1, (xmlChar **)&v126);
        if (v28)
        {
          unint64_t v29 = v28;
          for (mm = a1->cur + 1; ; ++mm)
          {
            BOOL v31 = *(mm - 1);
            if (((1LL << v31) & 0x100002600LL) == 0) {
              break;
            }
            a1->cur = mm;
          }

          if (v31 != 40)
          {
LABEL_171:
            xmlFree(v28);
            goto LABEL_172;
          }

          while (1)
          {
            a1->cur = mm;
            BOOL v74 = *mm;
            unint64_t v21 = v74 > 0x20;
            __int128 v75 = (1LL << v74) & 0x100002600LL;
            if (v21 || v75 == 0) {
              break;
            }
            ++mm;
          }

          xmlXPathObjectPtr v77 = (void *)v126;
          if (v126 || *v28 != 99)
          {
            __int128 v78 = 1LL;
          }

          else
          {
            __int128 v78 = xmlStrEqual(v28, (const xmlChar *)"count") == 0;
            mm = a1->cur;
          }

          uint64_t v81 = 0;
          __int128 v82 = -1;
          *((_DWORD *)a1->comp + 4) = -1;
          xmlGenericErrorFunc v83 = *mm;
          if (!v83 || v83 == 41) {
            goto LABEL_300;
          }
          xmlXPathCompileExpr(a1, v78);
          if (a1->error)
          {
LABEL_188:
            xmlFree(v29);
            ((void (*)(void *, __n128))xmlFree)(v77, v84);
            goto LABEL_60;
          }

          uint64_t v81 = 0;
          v110 = -1;
          while (1)
          {
            xmlXPathCompExprAdd((uint64_t)a1, v110, *((_DWORD *)a1->comp + 4), 0xEu, 0, 0, 0, 0LL, 0LL);
            ++v81;
            xmlGenericErrorFunc v111 = *a1->cur;
            if (v111 != 44) {
              break;
            }
            v112 = a1->cur + 1;
            while (1)
            {
              a1->cur = v112;
              xmlGenericErrorFunc v114 = *v112++;
              v113 = v114;
              if (v114 > 0x20) {
                break;
              }
              if (((1LL << v113) & 0x100002600LL) == 0)
              {
                if (!v113) {
                  goto LABEL_299;
                }
                break;
              }
            }

            comp = (unsigned __int8 *)a1->comp;
            v110 = *((_DWORD *)comp + 4);
            *((_DWORD *)comp + 4) = -1;
            xmlXPathCompileExpr(a1, v78);
            if (a1->error) {
              goto LABEL_188;
            }
          }

          if (v111 == 41)
          {
LABEL_299:
            __int128 v82 = *((_DWORD *)a1->comp + 4);
LABEL_300:
            if (xmlXPathCompExprAdd((uint64_t)a1, v82, 0xFFFFFFFF, 0xDu, v81, 0, 0, v29, (xmlChar *)v77) == -1)
            {
              xmlFree(v77);
              xmlFree(v29);
            }

            v121 = a1->cur;
            if (*a1->cur) {
              goto LABEL_308;
            }
            while (1)
            {
              xmlGenericErrorFunc v122 = *v121;
              unint64_t v21 = v122 > 0x20;
              v123 = (1LL << v122) & 0x100002600LL;
              if (v21 || v123 == 0) {
                break;
              }
LABEL_308:
              a1->cur = ++v121;
            }

            goto LABEL_60;
          }

          xmlFree(v29);
          ((void (*)(void *))xmlFree)(v77);
        }

        else
        {
LABEL_172:
          ((void (*)(uint64_t))xmlFree)(v126);
        }

        uint64_t v25 = a1;
        __int128 v26 = 7;
LABEL_59:
        xmlXPathErr(v25, v26);
        goto LABEL_60;
      }
    }

    if (a1->error) {
      goto LABEL_60;
    }
    if ((_DWORD)v8 != 46 && v8 < 0x30)
    {
LABEL_44:
      uint64_t v25 = a1;
      __int128 v26 = 1;
      goto LABEL_59;
    }

    if (v24 > 9)
    {
      __int128 v71 = (unsigned __int8 *)(n - 1);
      __int128 v69 = 0.0;
    }

    else
    {
      __int128 v69 = 0.0;
      do
      {
        a1->cur = n;
        __int128 v69 = v69 * 10.0 + (double)(v8 - 48);
        __int128 v70 = *n++;
        LODWORD(v8) = v70;
      }

      while ((v70 - 48) < 0xA);
      __int128 v71 = (unsigned __int8 *)(n - 1);
    }

    if ((_DWORD)v8 != 46)
    {
LABEL_215:
      if ((v8 | 0x20) == 0x65)
      {
        uint64_t v94 = v71 + 1;
        a1->cur = v71 + 1;
        int v95 = v71[1];
        if (v95 == 45 || v95 == 43)
        {
          uint64_t v94 = v71 + 2;
          a1->cur = v71 + 2;
          uint64_t v96 = v71[2];
        }

        else
        {
          uint64_t v96 = v71[1];
        }

        if ((v96 - 48) > 9)
        {
          v97 = 0;
        }

        else
        {
          v97 = 0;
          int v98 = v94 + 1;
          do
          {
            uint64_t v99 = v96 + 10 * v97 - 48;
            if (v97 < 1000000) {
              v97 = v99;
            }
            a1->cur = v98;
            xmlXPathObjectPtr v100 = *v98++;
            uint64_t v96 = v100;
          }

          while ((v100 - 48) < 0xA);
        }

        if (v95 == 45) {
          v101 = -v97;
        }
        else {
          v101 = v97;
        }
        __int128 v69 = v69 * __exp10((double)v101);
      }

      xmlGenericErrorFunc v102 = (xmlChar *)xmlXPathCacheNewFloat(v69, (uint64_t)a1->context);
      if (v102)
      {
        v103 = (xmlXPathObject *)v102;
        if (xmlXPathCompExprAdd( (uint64_t)a1,  *((_DWORD *)a1->comp + 4),  0xFFFFFFFF,  0xBu,  3u,  0,  0,  v102,  0LL) == -1) {
          xmlXPathReleaseObject((uint64_t)a1->context, v103);
        }
      }

      else
      {
        a1->error = 15;
      }

      goto LABEL_60;
    }

    __int128 v79 = (uint64_t)(v71 + 1);
    a1->cur = v71 + 1;
    __int128 v80 = v71[1];
    if (v80 >= 0x30)
    {
      if (v24 >= 0xA && v80 >= 0x3A) {
        goto LABEL_44;
      }
      if (v80 == 48)
      {
        xmlGenericErrorFunc v85 = 0LL;
        do
        {
          __int128 v86 = &v71[v85 + 2];
          a1->cur = v86;
          __int128 v80 = *v86;
          ++v85;
        }

        while (v80 == 48);
        __int128 v79 = (uint64_t)&v71[v85 + 1];
        goto LABEL_204;
      }
    }

    else if (v24 >= 0xA)
    {
      goto LABEL_44;
    }

    LODWORD(v85) = 0;
LABEL_204:
    __int128 v87 = 0.0;
    if (v80 - 48 <= 9)
    {
      uint64_t v88 = v85 + 20;
      __int128 v89 = (const xmlChar *)(v79 + 1);
      do
      {
        __int128 v87 = (double)(int)(v80 - 48) + v87 * 10.0;
        LODWORD(v85) = v85 + 1;
        a1->cur = v89;
        __int128 v90 = *v89++;
        __int128 v80 = v90;
      }

      while (v90 - 48 <= 9 && v85 < v88);
    }

    __int128 v69 = v69 + v87 / __exp10((double)(int)v85);
    __int128 v71 = (unsigned __int8 *)a1->cur;
    LODWORD(v8) = *a1->cur;
    if ((v8 - 48) <= 9)
    {
      __int128 v92 = v71 + 1;
      do
      {
        a1->cur = v92;
        xmlXPathObjectPtr v93 = *v92++;
        LODWORD(v8) = v93;
      }

      while ((v93 - 48) < 0xA);
      __int128 v71 = (unsigned __int8 *)(v92 - 1);
    }

    goto LABEL_215;
  }

  do
  {
    a1->cur = n;
    int v9 = *n++;
    unint64_t v10 = (1LL << v9) & 0x100002600LL;
  }

  while (v9 <= 0x20 && v10 != 0);
  xmlXPathCompileExpr(a1, 1LL);
  if (!a1->error)
  {
    if (*a1->cur == 41)
    {
      unint64_t v12 = a1->cur + 1;
      do
      {
        a1->cur = v12;
        int v13 = *v12++;
        unint64_t v14 = (1LL << v13) & 0x100002600LL;
      }

      while (v13 <= 0x20 && v14 != 0);
      goto LABEL_60;
    }

    xmlXPathErr(a1, 7);
  }

int xmlDictSize(xmlDictPtr dict)
{
  if (!dict) {
    return -1;
  }
  uint64_t v1 = *((void *)dict + 5);
  int result = *((_DWORD *)dict + 6);
  if (v1) {
    result += *(_DWORD *)(v1 + 24);
  }
  return result;
}

size_t xmlDictSetLimit(size_t dict, size_t limit)
{
  if (dict)
  {
    size_t v2 = dict;
    dict = *(void *)(dict + 56);
    *(void *)(v2 + 56) = limit;
  }

  return dict;
}

size_t xmlDictGetUsage(size_t dict)
{
  if (dict)
  {
    uint64_t v1 = *(void **)(dict + 32);
    if (v1)
    {
      dict = 0LL;
      do
      {
        dict += v1[3];
        uint64_t v1 = (void *)*v1;
      }

      while (v1);
    }

    else
    {
      return 0LL;
    }
  }

  return dict;
}

int docbEncodeEntities(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen, int quoteChar)
{
  if ((docbEncodeEntities_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "docbEncodeEntities() deprecated function reached\n");
    docbEncodeEntities_deprecated = 1;
  }

  return -1;
}

int docbParseDocument(docbParserCtxtPtr ctxt)
{
  if ((docbParseDocument_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "docbParseDocument() deprecated function reached\n");
    docbParseDocument_deprecated = 1;
  }

  return xmlParseDocument(ctxt);
}

void docbFreeParserCtxt(docbParserCtxtPtr ctxt)
{
  if ((docbFreeParserCtxt_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "docbFreeParserCtxt() deprecated function reached\n");
    docbFreeParserCtxt_deprecated = 1;
  }

  xmlFreeParserCtxt(ctxt);
}

int docbParseChunk(docbParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  if ((docbParseChunk_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v8 = *__xmlGenericError();
    int v9 = __xmlGenericErrorContext();
    v8(*v9, "docbParseChunk() deprecated function reached\n");
    docbParseChunk_deprecated = 1;
  }

  return xmlParseChunk(ctxt, chunk, size, terminate);
}

docbParserCtxtPtr docbCreatePushParserCtxt( docbSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename, xmlCharEncoding enc)
{
  if ((docbCreatePushParserCtxt_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v11 = *__xmlGenericError();
    unint64_t v12 = __xmlGenericErrorContext();
    v11(*v12, "docbParseChunk() deprecated function reached\n");
    docbCreatePushParserCtxt_deprecated = 1;
  }

  return xmlCreatePushParserCtxt(sax, user_data, chunk, size, filename);
}

docbDocPtr docbSAXParseDoc(xmlChar *cur, const char *encoding, docbSAXHandlerPtr sax, void *userData)
{
  if ((docbSAXParseDoc_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    xmlGenericErrorFunc v8 = __xmlGenericErrorContext();
    v7(*v8, "docbParseChunk() deprecated function reached\n");
    docbSAXParseDoc_deprecated = 1;
  }

  int v9 = xmlStrlen(cur);
  return xmlSAXParseMemoryWithData(sax, (const char *)cur, v9, 0, userData);
}

docbDocPtr docbParseDoc(xmlChar *cur, const char *encoding)
{
  if ((docbParseDoc_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    size_t v4 = __xmlGenericErrorContext();
    v3(*v4, "docbParseChunk() deprecated function reached\n");
    docbParseDoc_deprecated = 1;
  }

  return xmlParseDoc(cur);
}

docbParserCtxtPtr docbCreateFileParserCtxt(const char *filename, const char *encoding)
{
  if ((docbCreateFileParserCtxt_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    size_t v4 = __xmlGenericErrorContext();
    v3(*v4, "docbCreateFileParserCtxt() deprecated function reached\n");
    docbCreateFileParserCtxt_deprecated = 1;
  }

  return xmlCreateFileParserCtxt(filename);
}

docbDocPtr docbSAXParseFile(const char *filename, const char *encoding, docbSAXHandlerPtr sax, void *userData)
{
  if ((docbSAXParseFile_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    xmlGenericErrorFunc v8 = __xmlGenericErrorContext();
    v7(*v8, "docbSAXParseFile() deprecated function reached\n");
    docbSAXParseFile_deprecated = 1;
  }

  return xmlSAXParseFileWithData(sax, filename, 0, userData);
}

docbDocPtr docbParseFile(const char *filename, const char *encoding)
{
  if ((docbParseFile_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    size_t v4 = __xmlGenericErrorContext();
    v3(*v4, "docbParseFile() deprecated function reached\n");
    docbParseFile_deprecated = 1;
  }

  return xmlParseFile(filename);
}

int isolat1ToUTF8(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int v4 = -1;
  if (inlen && outlen && out && in)
  {
    xmlGenericErrorFunc v5 = &out[*outlen];
    uint64_t v6 = *inlen;
    BOOL v7 = v6 > 0;
    if ((int)v6 < 1)
    {
      xmlGenericErrorFunc v8 = out;
      int v9 = in;
    }

    else
    {
      xmlGenericErrorFunc v8 = out;
      int v9 = in;
      if (v5 - 1 > out)
      {
        unint64_t v10 = &in[v6];
        xmlGenericErrorFunc v11 = v10;
        int v9 = in;
        xmlGenericErrorFunc v8 = out;
        do
        {
          int v12 = *(char *)v9;
          if (v12 < 0)
          {
            *xmlGenericErrorFunc v8 = (v12 >> 6) | 0xC0;
            char v13 = *v9++;
            v8[1] = v13 & 0x3F | 0x80;
            v8 += 2;
          }

          if (v11 - v9 > v5 - v8) {
            xmlGenericErrorFunc v11 = &v9[v5 - v8];
          }
          if (v9 < v11)
          {
            int64_t v14 = v11 - v9;
            while (1)
            {
              int v15 = *(char *)v9;
              if (v15 < 0) {
                break;
              }
              ++v9;
              *v8++ = v15;
              if (!--v14)
              {
                int v9 = v11;
                break;
              }
            }
          }

          BOOL v7 = v9 < v10;
        }

        while (v9 < v10 && v8 < v5 - 1);
      }
    }

    if (v7 && v8 < v5)
    {
      int v16 = *(char *)v9;
      if ((v16 & 0x80000000) == 0)
      {
        LODWORD(v9) = (_DWORD)v9 + 1;
        *xmlGenericErrorFunc v8 = v16;
        LODWORD(v8) = (_DWORD)v8 + 1;
      }
    }

    *outlen = (_DWORD)v8 - (_DWORD)out;
    *inlen = (_DWORD)v9 - (_DWORD)in;
    return *outlen;
  }

  return v4;
}

int UTF8Toisolat1(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  int v4 = -1;
  if (out && outlen && inlen)
  {
    if (in)
    {
      uint64_t v5 = *inlen;
      LODWORD(v6) = (_DWORD)out;
      LODWORD(v7) = (_DWORD)in;
      if ((int)v5 >= 1)
      {
        xmlGenericErrorFunc v8 = &in[v5];
        int v9 = &out[*outlen];
        int v10 = (int)in;
        uint64_t v6 = out;
        BOOL v7 = in;
        while (1)
        {
          int v11 = *(char *)v7++;
          unsigned int v12 = v11;
          if (v11 < 0)
          {
            if (v12 <= 0xBF) {
              goto LABEL_31;
            }
            if (v12 > 0xDF)
            {
              if (v12 > 0xEF)
              {
                if (v12 > 0xF7) {
                  goto LABEL_31;
                }
                int v14 = v12 & 7;
                unsigned int v13 = 3;
              }

              else
              {
                int v14 = v12 & 0xF;
                unsigned int v13 = 2;
              }
            }

            else
            {
              int v14 = v12 & 0x1F;
              unsigned int v13 = 1;
            }
          }

          else
          {
            unsigned int v13 = 0;
            int v14 = v12;
          }

          if (v8 - v7 < v13) {
            break;
          }
          if ((v12 & 0x80) != 0 && v7 < v8)
          {
            unsigned int v15 = v13 - 1;
            while (1)
            {
              unsigned __int8 v16 = *v7;
              if ((*v7 & 0xC0) != 0x80) {
                break;
              }
              ++v7;
              unsigned int v17 = v16 & 0x3F | (v14 << 6);
              if (v15-- != 0)
              {
                int v14 = v17;
                if (v7 < v8) {
                  continue;
                }
              }

              if (v17 <= 0xFF) {
                goto LABEL_27;
              }
              break;
            }

LABEL_33:
      *outlen = (_DWORD)v6 - (_DWORD)out;
      *inlen = (_DWORD)v7 - (_DWORD)in;
      return *outlen;
    }

    else
    {
      int v4 = 0;
      *outlen = 0;
      *inlen = 0;
    }
  }

  return v4;
}

      uint64_t v24 = __str;
      snprintf(__str, 0x10uLL, "#%u", v17);
LABEL_34:
      uint64_t v25 = strlen(v24);
      if (&v9[v25 + 2] >= v12)
      {
LABEL_39:
        LODWORD(v10) = (_DWORD)v13;
        goto LABEL_40;
      }

      __int128 v26 = v25;
      *int v9 = 38;
      unint64_t v27 = (char *)(v9 + 1);
      memcpy(v27, v24, v25);
      unint64_t v28 = &v27[v26];
      *unint64_t v28 = 59;
      int v9 = (unsigned __int8 *)(v28 + 1);
    }

    else
    {
      if (v9 + 1 >= v12) {
        goto LABEL_39;
      }
      *v9++ = v17;
    }

    unsigned int v13 = v10;
    if (v10 >= v11) {
      goto LABEL_40;
    }
  }

  *outlen = (_DWORD)v9 - (_DWORD)out;
  unint64_t v29 = (_DWORD)v13 - v7;
  int result = -2;
LABEL_41:
  inlen = v30;
LABEL_42:
  *inlen = v29;
  return result;
}

    if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
      xmlGROW((uint64_t)ctxt);
    }
    xmlSkipBlankChars(ctxt);
    ctxt->input->standalone = xmlParseSDDecl(ctxt);
    xmlSkipBlankChars(ctxt);
    int v11 = ctxt->input;
    unsigned int v12 = v11->cur;
    unsigned int v15 = *v12;
    if (v15 == 62)
    {
      xmlFatalErr(ctxt, 57, 0LL);
    }

    else
    {
      if (v15 == 63 && v12[1] == 62)
      {
LABEL_39:
        v11->cur = v12 + 2;
        v11->col += 2;
        if (!v12[2]) {
          xmlParserInputGrow(v11, 250);
        }
        return;
      }

      xmlFatalErr(ctxt, 57, 0LL);
      unsigned __int8 v16 = ctxt->input;
      for (uint64_t i = v16->cur; *i++ && *(i - 1) != 62; v16->cur = i)
        ;
    }

    xmlNextChar(ctxt);
  }

    if (a1) {
      *(_DWORD *)(a1 + 56) = v14;
    }
    return 1LL;
  }

  unsigned __int8 v16 = *__xmlGenericError();
  unsigned int v17 = __xmlGenericErrorContext();
  v16(*v17, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 9768);
  return 0xFFFFFFFFLL;
}

  *((void *)v6 + 10) = v9;
LABEL_34:
  if (*(_DWORD *)(a1 + 436))
  {
    unsigned __int8 v16 = *(void *)(a1 + 56);
    if (v16)
    {
      unsigned int v17 = *(unsigned int *)(v16 + 52);
      if ((int)v17 > 65534)
      {
        *((_WORD *)v6 + 56) = -1;
        if ((*(_BYTE *)(a1 + 566) & 0x40) != 0) {
          *((void *)v6 + 13) = v17;
        }
      }

      else
      {
        *((_WORD *)v6 + 56) = v17;
      }
    }
  }

  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    unsigned int v18 = __xmlRegisterNodeDefaultValue();
    ((void (*)(char *))*v18)(v6);
  }

  return v6;
}

  unint64_t v34 = (xmlDict *)*((void *)reader + 20);
  BOOL v35 = *((void *)reader + 4);
  unsigned int v36 = *(xmlDictPtr *)(v35 + 456);
  if (v34)
  {
    if (v36)
    {
      if (v34 != v36)
      {
        xmlDictFree(*((xmlDictPtr *)reader + 20));
        BOOL v35 = *((void *)reader + 4);
        *((void *)reader + 20) = *(void *)(v35 + 456);
      }
    }

    else
    {
      *(void *)(v35 + 456) = v34;
    }
  }

  else
  {
    if (!v36)
    {
      unsigned int v36 = xmlDictCreate();
      BOOL v35 = *((void *)reader + 4);
      *(void *)(v35 + 456) = v36;
    }

    *((void *)reader + 20) = v36;
  }

  *(void *)(v35 + 424) = reader;
  *(_DWORD *)(v35 + 436) = 1;
  *(_DWORD *)(v35 + 568) = 1;
  *(_DWORD *)(v35 + 476) = 1;
  *(_DWORD *)(v35 + 688) = 5;
  unsigned int v37 = (xmlXIncludeCtxt *)*((void *)reader + 36);
  if (v37)
  {
    xmlXIncludeFreeContext(v37);
    *((void *)reader + 36) = 0LL;
  }

  if ((v6 & 0x400) != 0)
  {
    *((_DWORD *)reader + 68) = 1;
    *((void *)reader + 35) = xmlDictLookup(*((xmlDictPtr *)reader + 20), (const xmlChar *)"include", -1);
    v10 -= 1024;
  }

  else
  {
    *((_DWORD *)reader + 68) = 0;
  }

  *((_DWORD *)reader + 74) = 0;
  if (*((void *)reader + 39))
  {
    LODWORD(v38) = *((_DWORD *)reader + 75);
    if ((int)v38 >= 1)
    {
      do
      {
        LODWORD(v38) = v38 - 1;
        *((_DWORD *)reader + 75) = v38;
        unint64_t v39 = *(xmlPattern **)(*((void *)reader + 39) + 8LL * v38);
        if (v39)
        {
          xmlFreePattern(v39);
          uint64_t v38 = *((int *)reader + 75);
          *(void *)(*((void *)reader + 39) + 8 * v38) = 0LL;
        }
      }

      while ((int)v38 > 0);
    }

    if ((v10 & 0x10) == 0) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }

  *(void *)((char *)reader + 300) = 0LL;
  if ((v10 & 0x10) != 0) {
LABEL_52:
  }
    *((_DWORD *)reader + 4) = 1;
LABEL_53:
  xmlCtxtUseOptions(*((xmlParserCtxtPtr *)reader + 4), v10);
  if (encoding)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
    if (CharEncodingHandler) {
      xmlSwitchToEncoding(*((xmlParserCtxtPtr *)reader + 4), CharEncodingHandler);
    }
  }

  if (URL)
  {
    int v41 = *(void *)(*((void *)reader + 4) + 56LL);
    if (v41)
    {
      if (!*(void *)(v41 + 8)) {
        *(void *)(*(void *)(*((void *)reader + 4) + 56LL) + 8LL) = xmlStrdup((const xmlChar *)URL);
      }
    }
  }

  int result = 0;
  *((void *)reader + 1) = 0LL;
  return result;
}

            v16 += 24LL;
            if (v8 == v16)
            {
              BOOL v7 = *(_DWORD *)(v6 + 24);
              goto LABEL_35;
            }
          }
        }
      }

    if (retValue)
    {
      xmlFree(retValue);
      retValue = 0LL;
    }

    int result = (uint64_t)xmlSchemaValueGetNext(cur);
    cur = (xmlSchemaValPtr)result;
    if (!result) {
      return result;
    }
  }

  if (retValue) {
    xmlFree(retValue);
  }
  if (*a3) {
    xmlFree(*a3);
  }
  if (retValue) {
    xmlFree(retValue);
  }
  return 0xFFFFFFFFLL;
}

  unsigned int v13 = &value[i + v5];
  int v14 = v13 - 1;
  unsigned int v15 = v13;
  if (v13 - 1 > v6)
  {
    do
    {
      unsigned __int8 v16 = *v14;
      unsigned int v17 = v16 > 0x20;
      unsigned int v18 = (1LL << v16) & 0x100002600LL;
      if (v17 || v18 == 0) {
        break;
      }
      --v14;
    }

    while (v14 > v6);
    unsigned int v15 = v14 + 1;
  }

  if (i || v13 != v15) {
    return xmlStrndup(&value[i], (int)v15 - (int)value - (int)i);
  }
  else {
    return 0LL;
  }
}

xmlCharEncoding xmlDetectCharEncoding(const unsigned __int8 *in, int len)
{
  if (in)
  {
    if (len < 4)
    {
      if (len != 3)
      {
        if (len < 2) {
          goto LABEL_46;
        }
        int v2 = *in;
LABEL_19:
        if (v2 != 255)
        {
          if (v2 != 254 || in[1] != 255) {
            goto LABEL_46;
          }
          goto LABEL_22;
        }

        if (in[1] != 254) {
          goto LABEL_46;
        }
        goto LABEL_35;
      }

      int v2 = *in;
    }

    else
    {
      int v2 = *in;
      if (v2 == 76)
      {
        if (in[1] == 111 && in[2] == 167 && in[3] == 148)
        {
          LODWORD(in) = 6;
          return (int)in;
        }

        goto LABEL_46;
      }

      if (v2 == 60)
      {
        if (in[1] == 63)
        {
          if (in[2] != 120 || in[3] != 109) {
            goto LABEL_46;
          }
          goto LABEL_16;
        }

        if (in[1]) {
          goto LABEL_46;
        }
        if (!in[2] && !in[3])
        {
          LODWORD(in) = 4;
          return (int)in;
        }

        if (in[2] != 63 || in[3]) {
          goto LABEL_46;
        }
LABEL_35:
        LODWORD(in) = 2;
        return (int)in;
      }

      if (!*in)
      {
        if (in[1] != 60)
        {
          if (!in[1])
          {
            if (!in[2] && in[3] == 60)
            {
              LODWORD(in) = 5;
              return (int)in;
            }

            if (in[2] == 60 && !in[3])
            {
              LODWORD(in) = 7;
              return (int)in;
            }
          }

LABEL_46:
          LODWORD(in) = 0;
          return (int)in;
        }

        if (!in[2] && !in[3])
        {
          LODWORD(in) = 8;
          return (int)in;
        }

        if (in[2] || in[3] != 63) {
          goto LABEL_46;
        }
LABEL_22:
        LODWORD(in) = 3;
        return (int)in;
      }
    }

    if (v2 == 239)
    {
      if (in[1] != 187 || in[2] != 191) {
        goto LABEL_46;
      }
LABEL_16:
      LODWORD(in) = 1;
      return (int)in;
    }

    goto LABEL_19;
  }

  return (int)in;
}

          unint64_t v32 = ctxt->input;
          if (v32)
          {
            unint64_t v33 = v32->buf;
            if (v33) {
              int v11 = xmlBufUse(v33->buffer);
            }
          }
        }
      }

      if (terminate
        || v11 > 0x989680
        || !v10
        || !v11
        || (_DWORD)v11 - (_DWORD)v10 < 0
        || (base = ctxt->input->base) == 0LL
        || (BOOL v35 = ctxt->instate, v35 != XML_PARSER_START_TAG)
        && v35 != XML_PARSER_END_TAG
        && (progressive = ctxt->progressive, progressive != 2)
        && v35 != XML_PARSER_CDATA_SECTION
        && progressive != 5
        && v35 != XML_PARSER_DTD
        && progressive != 3
        || memchr(&base[v10], 62, (v11 - v10)))
      {
        xmlParseTryOrFinish((uint64_t)ctxt, terminate);
      }

      unsigned int v18 = 0;
      unint64_t v21 = 1;
LABEL_59:
      if (ctxt->instate == XML_PARSER_EOF) {
        return ctxt->errNo;
      }
      unsigned int v36 = ctxt->input;
      if (v36)
      {
        cur = v36->cur;
        if ((v36->end - cur > 10000000 || cur - v36->base > 10000000) && (ctxt->options & 0x80000) == 0)
        {
          xmlFatalErr(ctxt, 1, (uint64_t)"Huge input lookup");
          xmlHaltParser(ctxt);
        }
      }

      if (ctxt->wellFormed != 1 && ctxt->disableSAX == 1) {
        return ctxt->errNo;
      }
      if ((v21 & 1) != 0)
      {
        if (v55)
        {
          unint64_t v39 = ctxt->input;
          if (v39)
          {
            if (v39->buf)
            {
              unint64_t v40 = xmlBufGetInputBase((uint64_t)v39->buf->buffer, (uint64_t)v39);
              int v41 = ctxt->input;
              unsigned int v42 = v41->cur - v41->base;
              xmlParserInputBufferPush(v41->buf, 1, "\r");
              xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, v40, v42);
            }
          }
        }

        if (terminate)
        {
          unsigned int v43 = ctxt->input;
          if (v43)
          {
            if (v43->buf)
            {
              int v44 = xmlBufUse(v43->buf->buffer);
              int v45 = ctxt->input;
              int v46 = (int)v45->cur;
              xmlGenericErrorFunc v47 = (int)v45->base;
              length = v44 - v46;
            }

            else
            {
              length = v43->length;
              xmlGenericErrorFunc v47 = LODWORD(v43->base) - LODWORD(v43->cur);
            }

            uint64_t v49 = length + v47;
          }

          else
          {
            uint64_t v49 = 0;
          }

          int v50 = ctxt->instate;
          if (v50 != XML_PARSER_EOF && v50 != XML_PARSER_EPILOG)
          {
            xmlFatalErr(ctxt, 5, 0LL);
            int v50 = ctxt->instate;
          }

          if (v50 == XML_PARSER_EPILOG && v49 >= 1)
          {
            xmlFatalErr(ctxt, 5, 0LL);
            int v50 = ctxt->instate;
          }

          if (v50 != XML_PARSER_EOF)
          {
            if (ctxt->sax)
            {
              endDocument = ctxt->sax->endDocument;
              if (endDocument) {
                ((void (*)(void *))endDocument)(ctxt->userData);
              }
            }
          }

          ctxt->instate = XML_PARSER_EOF;
        }

        if (ctxt->wellFormed) {
          return 0;
        }
        return ctxt->errNo;
      }

      chunk += size;
      size = v18;
    }

    if (ctxt->instate != XML_PARSER_EOF)
    {
      unsigned int v13 = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
      int v14 = ctxt->input;
      unsigned __int8 v16 = v14->base;
      unsigned int v15 = v14->cur;
      int v10 = xmlBufUse(v14->buf->buffer);
      unsigned int v17 = ctxt->input;
      if (ctxt->instate == XML_PARSER_START && v17->buf && (encoder = (const xmlChar **)v17->buf->encoder) != 0LL)
      {
        if (xmlStrcasestr(*encoder, (const xmlChar *)"UTF-16")
          || xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UTF16"))
        {
          unint64_t v29 = 90;
        }

        else if (xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UCS-4") {
               || xmlStrcasestr((const xmlChar *)ctxt->input->buf->encoder->name, (const xmlChar *)"UCS4"))
        }
        {
          unint64_t v29 = 180;
        }

        else
        {
          unint64_t v29 = 45;
        }

        unsigned int v17 = ctxt->input;
        rawconsumed = v17->buf->rawconsumed;
        if (rawconsumed >= v29) {
          LODWORD(rawconsumed) = 0;
        }
        BOOL v31 = v29 - rawconsumed;
        if (size >= v31) {
          unsigned int v18 = size - v31;
        }
        else {
          unsigned int v18 = 0;
        }
        if (size >= v31) {
          size = v31;
        }
      }

      else
      {
        unsigned int v18 = 0;
      }

      unint64_t v19 = v15 - v16;
      uint64_t v20 = xmlParserInputBufferPush(v17->buf, size, chunk);
      xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, v13, v19);
      if (v20 < 0)
      {
        instate = XML_PARSER_EOF;
        ctxt->errNo = -1;
        xmlHaltParser(ctxt);
        return instate;
      }

      if (v18)
      {
        xmlParseTryOrFinish((uint64_t)ctxt, 0);
        unint64_t v21 = 0;
        goto LABEL_59;
      }
    }

    goto LABEL_46;
  }

  return instate;
}

    unsigned __int8 v16 = "xmlSAX2Characters";
    return xmlSAX2ErrMemory((uint64_t *)v4, (uint64_t)v16);
  }

  int result = xmlTextConcat((xmlNodePtr)v8, (const xmlChar *)__src, len);
  if ((_DWORD)result) {
    int result = xmlSAX2ErrMemory((uint64_t *)v4, (uint64_t)"xmlSAX2Characters");
  }
  if (*(void *)(*(void *)(v4 + 80) + 24LL))
  {
    int result = xmlStrlen(*(const xmlChar **)(v8 + 80));
    *(_DWORD *)(v4 + 412) = result;
    unsigned int v13 = result + 1;
    goto LABEL_23;
  }

  return result;
}

    unint64_t v27 = *(void *)(a1 + 200);
    goto LABEL_47;
  }

  if ((*(_BYTE *)(a2 + 48) & 1) != 0) {
    goto LABEL_46;
  }
LABEL_95:
  unint64_t v27 = 0LL;
LABEL_47:
  unint64_t v28 = v98;
  if (!v98) {
    goto LABEL_42;
  }
  unint64_t v29 = xmlMalloc(0xC8uLL);
  if (!v29)
  {
    if (a1) {
      ++*(_DWORD *)(a1 + 36);
    }
    __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"allocating element");
    goto LABEL_42;
  }

  unint64_t v30 = (uint64_t)v29;
  unsigned int *v29 = 0u;
  v29[1] = 0u;
  *((void *)v29 + 24) = 0LL;
  v29[10] = 0u;
  v29[11] = 0u;
  v29[8] = 0u;
  v29[9] = 0u;
  v29[6] = 0u;
  v29[7] = 0u;
  v29[4] = 0u;
  v29[5] = 0u;
  v29[2] = 0u;
  v29[3] = 0u;
  *(_DWORD *)unint64_t v29 = 14;
  *((void *)v29 + 2) = v28;
  *((void *)v29 + 12) = v27;
  *((void *)v29 + 9) = a3;
  BOOL v31 = *(void *)(*(void *)(a1 + 48) + 32LL);
  v97 = v17;
  if (a5)
  {
    unint64_t v32 = (void **)(v31 + 64);
    unint64_t v33 = 5;
  }

  else
  {
    unint64_t v32 = (void **)(v31 + 72);
    unint64_t v33 = 10;
  }

  xmlSchemaAddItemSize(v32, v33, v30);
  xmlSchemaAddItemSize((void **)(*(void *)(a1 + 48) + 40LL), 10, v30);
  for (uint64_t i = (uint64_t)a3->properties; i; uint64_t i = *(void *)(i + 48))
  {
    int v41 = *(void *)(i + 72);
    if (v41)
    {
      if (xmlStrEqual(*(const xmlChar **)(v41 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_69;
      }
    }

    else
    {
      if (xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"name")
        || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"type")
        || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"id")
        || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"default")
        || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"fixed")
        || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"block")
        || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"nillable"))
      {
        continue;
      }

      unsigned int v42 = *(const xmlChar **)(i + 16);
      if (a5)
      {
        if (xmlStrEqual(v42, (const xmlChar *)"final")
          || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"abstract"))
        {
          continue;
        }

        unsigned int v43 = *(const xmlChar **)(i + 16);
        int v44 = "substitutionGroup";
      }

      else
      {
        if (xmlStrEqual(v42, (const xmlChar *)"maxOccurs")
          || xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"minOccurs"))
        {
          continue;
        }

        unsigned int v43 = *(const xmlChar **)(i + 16);
        int v44 = "form";
      }

      if (!xmlStrEqual(v43, (const xmlChar *)v44)) {
LABEL_69:
      }
        xmlSchemaPIllegalAttrErr((_DWORD *)a1, i);
    }
  }

  if (a5)
  {
    int v45 = (_DWORD *)(v30 + 88);
    *(_DWORD *)(v30 + 88) |= 0x22u;
    xmlSchemaPValAttrQName( a1,  a2,  (uint64_t)a3,  (xmlChar *)"substitutionGroup",  (const xmlChar **)(v30 + 128),  (const xmlChar **)(v30 + 120));
    int v46 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"final");
    if (v46)
    {
      xmlGenericErrorFunc v47 = (uint64_t)v46;
      int v48 = (xmlChar *)xmlSchemaGetNodeContent(a1, v46);
    }

    else
    {
      uint64_t v49 = *(_DWORD *)(a2 + 48);
      if ((v49 & 4) != 0) {
        *v45 |= 0x8000u;
      }
      if ((v49 & 8) != 0) {
        *v45 |= 0x10000u;
      }
    }
  }

  int v50 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"block");
  if (!v50)
  {
    xmlGenericErrorFunc v53 = *(_DWORD *)(a2 + 48);
    if ((v53 & 0x80) != 0)
    {
      *(_DWORD *)(v30 + 88) |= 0x1000u;
      if ((v53 & 0x40) == 0)
      {
LABEL_105:
        if ((v53 & 0x100) == 0) {
          goto LABEL_107;
        }
        goto LABEL_106;
      }
    }

    else if ((v53 & 0x40) == 0)
    {
      goto LABEL_105;
    }

    *(_DWORD *)(v30 + 88) |= 0x800u;
    if ((v53 & 0x100) == 0) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)(v30 + 88) |= 0x2000u;
    goto LABEL_107;
  }

  uint64_t v51 = (uint64_t)v50;
  uint64_t v52 = (xmlChar *)xmlSchemaGetNodeContent(a1, v50);
  if (xmlSchemaPValAttrBlockFinal(v52, (int *)(v30 + 88), 2048, 4096, 0x2000, -1, -1)) {
    xmlSchemaPSimpleTypeErr( a1,  3037,  v51,  0LL,  "(#all | List of (extension | restriction | substitution))",  v52,  0LL,  0);
  }
LABEL_107:
  int v54 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"type");
  if (v54)
  {
    v55 = (uint64_t)v54;
    xmlGenericErrorFunc v56 = (xmlChar *)xmlSchemaGetNodeContent(a1, v54);
    xmlSchemaPValAttrNodeQNameValue(a1, a2, v55, v56, (const xmlChar **)(v30 + 112), (const xmlChar **)(v30 + 104));
    xmlSchemaCheckReference(a1, (uint64_t)a3, v55, *(xmlChar **)(v30 + 112));
  }

  *(void *)(v30 + 144) = xmlSchemaGetProp(a1, a3, (xmlChar *)"default");
  xmlListPtr v57 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"fixed");
  if (v57)
  {
    v58 = (uint64_t)v57;
    uint64_t v59 = xmlSchemaGetNodeContent(a1, v57);
    if (*(void *)(v30 + 144))
    {
      xmlSchemaPMutualExclAttrErr(a1, 3038, 0LL, v58);
    }

    else
    {
      *(_DWORD *)(v30 + 88) |= 8u;
      *(void *)(v30 + 144) = v59;
    }
  }

  if (!children) {
    goto LABEL_220;
  }
  if (children->ns)
  {
    if (xmlStrEqual(children->name, (const xmlChar *)"complexType")
      && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      if (*(void *)(v30 + 104))
      {
        v60 = "The attribute 'type' and the <complexType> child are mutually exclusive";
LABEL_126:
        xmlSchemaPContentErr(a1, 3041, (uint64_t)a3, (uint64_t)children, (xmlChar *)v60, 0LL);
        goto LABEL_133;
      }

      uint64_t v61 = xmlSchemaParseComplexType(a1, a2, (int)children);
      goto LABEL_132;
    }

    if (children->ns
      && xmlStrEqual(children->name, (const xmlChar *)"simpleType")
      && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      if (*(void *)(v30 + 104))
      {
        v60 = "The attribute 'type' and the <simpleType> child are mutually exclusive";
        goto LABEL_126;
      }

      uint64_t v61 = xmlSchemaParseSimpleType(a1, a2, children, 0);
LABEL_132:
      *(void *)(v30 + 56) = v61;
LABEL_133:
      children = children->next;
      if (!children) {
        goto LABEL_220;
      }
    }
  }

  uint64_t v62 = 0LL;
  while (children->ns
       && (xmlStrEqual(children->name, (const xmlChar *)"unique")
        && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
        || children->ns
        && (xmlStrEqual(children->name, (const xmlChar *)"key")
         && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
         || children->ns
         && xmlStrEqual(children->name, (const xmlChar *)"keyref")
         && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))))
  {
    int v63 = v62;
    if (!children->ns) {
      goto LABEL_182;
    }
    if (xmlStrEqual(children->name, (const xmlChar *)"unique")
      && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      xmlXPathObjectPtr v91 = 0;
      uint64_t v64 = 22;
    }

    else
    {
      int v63 = v62;
      if (!children->ns) {
        goto LABEL_182;
      }
      if (!xmlStrEqual(children->name, (const xmlChar *)"key")
        || !xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        int v63 = v62;
        if (!children->ns) {
          goto LABEL_182;
        }
        int v63 = v62;
        if (!xmlStrEqual(children->name, (const xmlChar *)"keyref")) {
          goto LABEL_182;
        }
        int v63 = v62;
        if (!xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
          goto LABEL_182;
        }
        uint64_t v88 = 24;
        xmlXPathObjectPtr v91 = 1;
        goto LABEL_153;
      }

      xmlXPathObjectPtr v91 = 0;
      uint64_t v64 = 23;
    }

    uint64_t v88 = v64;
LABEL_153:
    __int128 v89 = *(void *)(v30 + 96);
    str2 = 0LL;
    v65 = (uint64_t)children->properties;
    if (v65)
    {
      while (1)
      {
        xmlXPathObjectPtr v66 = *(void *)(v65 + 72);
        if (!v66) {
          break;
        }
        if (xmlStrEqual(*(const xmlChar **)(v66 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
          goto LABEL_156;
        }
LABEL_159:
        v65 = *(void *)(v65 + 48);
        if (!v65) {
          goto LABEL_164;
        }
      }

      if (xmlStrEqual(*(const xmlChar **)(v65 + 16), (const xmlChar *)"id")
        || xmlStrEqual(*(const xmlChar **)(v65 + 16), (const xmlChar *)"name")
        || v91 && xmlStrEqual(*(const xmlChar **)(v65 + 16), (const xmlChar *)"refer"))
      {
        goto LABEL_159;
      }

  xmlSchemaErr4Line(a1, 2, 1871, 0LL, 0, (const char *)v36, 0LL, 0LL, 0LL, 0LL);
  xmlFree(cur);
}

void xmlCleanupEncodingAliases(void)
{
  xmlGenericErrorFunc v0 = (char *)xmlCharEncodingAliases;
  if (xmlCharEncodingAliases)
  {
    if (xmlCharEncodingAliasesNb >= 1)
    {
      uint64_t v1 = 0LL;
      uint64_t v2 = 0LL;
      do
      {
        if (*(void *)&v0[v1])
        {
          xmlFree(*(void **)&v0[v1]);
          xmlGenericErrorFunc v0 = (char *)xmlCharEncodingAliases;
        }

        if (*(void *)&v0[v1 + 8])
        {
          xmlFree(*(void **)&v0[v1 + 8]);
          xmlGenericErrorFunc v0 = (char *)xmlCharEncodingAliases;
        }

        ++v2;
        v1 += 16LL;
      }

      while (v2 < xmlCharEncodingAliasesNb);
    }

    xmlCharEncodingAliasesNb = 0;
    xmlCharEncodingAliasesMax = 0;
    xmlFree(v0);
    xmlCharEncodingAliases = 0LL;
  }

const char *__cdecl xmlGetEncodingAlias(const char *alias)
{
  int result = 0LL;
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (alias && xmlCharEncodingAliases)
  {
    uint64_t v3 = 0LL;
    int v8 = 0;
    memset(v7, 0, sizeof(v7));
    do
    {
      char v4 = __toupper(alias[v3]);
      *((_BYTE *)v7 + v3) = v4;
      if (!v4) {
        break;
      }
      ++v3;
    }

    while (v3 != 99);
    *((_BYTE *)v7 + v3) = 0;
    uint64_t v5 = xmlCharEncodingAliasesNb;
    if (xmlCharEncodingAliasesNb < 1)
    {
      return 0LL;
    }

    else
    {
      for (uint64_t i = (const char **)(xmlCharEncodingAliases + 8); strcmp(*i, (const char *)v7); i += 2)
      {
        if (!--v5) {
          return 0LL;
        }
      }

      return *(i - 1);
    }
  }

  return result;
}

int xmlAddEncodingAlias(const char *name, const char *alias)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int result = -1;
  if (!name || !alias) {
    return result;
  }
  uint64_t v5 = 0LL;
  int v16 = 0;
  memset(v15, 0, sizeof(v15));
  do
  {
    char v6 = __toupper(alias[v5]);
    *((_BYTE *)v15 + v5) = v6;
    if (!v6) {
      break;
    }
    ++v5;
  }

  while (v5 != 99);
  *((_BYTE *)v15 + v5) = 0;
  BOOL v7 = (char *)xmlCharEncodingAliases;
  if (xmlCharEncodingAliases)
  {
    int v8 = xmlCharEncodingAliasesNb;
    uint64_t v9 = xmlCharEncodingAliasesMax;
    if (xmlCharEncodingAliasesNb < xmlCharEncodingAliasesMax) {
      goto LABEL_11;
    }
    xmlCharEncodingAliasesMax *= 2;
    BOOL v7 = (char *)xmlRealloc((void *)xmlCharEncodingAliases, 32 * v9);
    xmlCharEncodingAliases = (uint64_t)v7;
  }

  else
  {
    xmlCharEncodingAliasesNb = 0;
    xmlCharEncodingAliasesMax = 20;
    BOOL v7 = (char *)xmlMalloc(0x140uLL);
    xmlCharEncodingAliases = (uint64_t)v7;
    if (!v7) {
      return -1;
    }
  }

  int v8 = xmlCharEncodingAliasesNb;
LABEL_11:
  if (v8 < 1)
  {
LABEL_15:
    *(void *)(xmlCharEncodingAliases + 16LL * xmlCharEncodingAliasesNb) = xmlMemStrdup(name);
    unsigned int v12 = xmlMemStrdup((const char *)v15);
    int result = 0;
    int v13 = xmlCharEncodingAliasesNb;
    *(void *)(xmlCharEncodingAliases + 16LL * xmlCharEncodingAliasesNb + 8) = v12;
    xmlCharEncodingAliasesNb = v13 + 1;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = 16LL * v8;
    while (strcmp(*(const char **)&v7[v10 + 8], (const char *)v15))
    {
      v10 += 16LL;
      if (v11 == v10) {
        goto LABEL_15;
      }
    }

    xmlFree(*(void **)&v7[v10]);
    int v14 = xmlMemStrdup(name);
    int result = 0;
    *(void *)(xmlCharEncodingAliases + v10) = v14;
  }

  return result;
}

int xmlDelEncodingAlias(const char *alias)
{
  int result = -1;
  if (alias)
  {
    uint64_t v3 = xmlCharEncodingAliases;
    if (xmlCharEncodingAliases)
    {
      uint64_t v4 = xmlCharEncodingAliasesNb;
      if (xmlCharEncodingAliasesNb >= 1)
      {
        uint64_t v5 = 0LL;
        for (uint64_t i = 8LL; strcmp(*(const char **)(v3 + i), alias); i += 16LL)
        {
          if (v4 == ++v5) {
            return -1;
          }
        }

        xmlFree(*(void **)(v3 + i - 8));
        xmlFree(*(void **)(xmlCharEncodingAliases + i));
        uint64_t v7 = xmlCharEncodingAliasesNb--;
        memmove( (void *)(xmlCharEncodingAliases + i - 8),  (const void *)(xmlCharEncodingAliases + i + 8),  16 * (v7 - v5) - 16);
        return 0;
      }
    }
  }

  return result;
}

xmlCharEncoding xmlParseCharEncoding(const char *name)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (name)
  {
    uint64_t v1 = name;
    int v29 = 0;
    memset(v28, 0, sizeof(v28));
    EncodingAlias = xmlGetEncodingAlias(name);
    uint64_t v3 = 0LL;
    if (EncodingAlias) {
      uint64_t v1 = EncodingAlias;
    }
    do
    {
      char v4 = __toupper(v1[v3]);
      *((_BYTE *)v28 + v3) = v4;
      if (!v4) {
        break;
      }
      ++v3;
    }

    while (v3 != 499);
    *((_BYTE *)v28 + v3) = 0;
    if (LOBYTE(v28[0]))
    {
      BOOL v5 = LODWORD(v28[0]) == 759583829 && WORD2(v28[0]) == 56;
      if (v5 || !(LODWORD(v28[0]) ^ 0x38465455 | BYTE4(v28[0])))
      {
        LODWORD(name) = 1;
      }

      else
      {
        BOOL v6 = LODWORD(v28[0]) == 759583829 && *(_DWORD *)((char *)v28 + 3) == 3551533;
        if (v6 || (LODWORD(v28[0]) == 826692693 ? (BOOL v7 = WORD2(v28[0]) == 54) : (BOOL v7 = 0), v7))
        {
          LODWORD(name) = 2;
        }

        else
        {
          BOOL v8 = *(void *)&v28[0] == 0x343630312D4F5349LL && *((void *)&v28[0] + 1) == 0x322D5343552D36LL;
          if (v8
            || (LODWORD(v28[0]) == 760431445 ? (BOOL v9 = WORD2(v28[0]) == 50) : (BOOL v9 = 0),
                v9 || !(LODWORD(v28[0]) ^ 0x32534355 | BYTE4(v28[0]))))
          {
            LODWORD(name) = 9;
          }

          else
          {
            BOOL v10 = *(void *)&v28[0] == 0x343630312D4F5349LL && *((void *)&v28[0] + 1) == 0x342D5343552D36LL;
            if (v10
              || (LODWORD(v28[0]) == 760431445 ? (BOOL v11 = WORD2(v28[0]) == 52) : (BOOL v11 = 0),
                  v11 || !(LODWORD(v28[0]) ^ 0x34534355 | BYTE4(v28[0]))))
            {
              LODWORD(name) = 4;
            }

            else
            {
              BOOL v12 = *(void *)&v28[0] == 0x393538382D4F5349LL && *(void *)((char *)v28 + 3) == 0x312D393538382DLL;
              if (v12
                || (*(void *)&v28[0] == 0x4954414C2D4F5349LL ? (BOOL v13 = DWORD2(v28[0]) == 3222862LL) : (BOOL v13 = 0),
                    v13
                 || (*(void *)&v28[0] == 0x4954414C204F5349LL ? (BOOL v14 = DWORD2(v28[0]) == 3219534LL) : (BOOL v14 = 0), v14)))
              {
                LODWORD(name) = 10;
              }

              else
              {
                BOOL v15 = *(void *)&v28[0] == 0x393538382D4F5349LL && *(void *)((char *)v28 + 3) == 0x322D393538382DLL;
                if (v15
                  || (*(void *)&v28[0] == 0x4954414C2D4F5349LL ? (BOOL v16 = DWORD2(v28[0]) == 3288398) : (BOOL v16 = 0),
                      v16
                   || (*(void *)&v28[0] == 0x4954414C204F5349LL ? (BOOL v17 = DWORD2(v28[0]) == 3285070LL) : (BOOL v17 = 0), v17)))
                {
                  LODWORD(name) = 11;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x332D393538382DLL)
                }
                {
                  LODWORD(name) = 12;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x342D393538382DLL)
                }
                {
                  LODWORD(name) = 13;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x352D393538382DLL)
                }
                {
                  LODWORD(name) = 14;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x362D393538382DLL)
                }
                {
                  LODWORD(name) = 15;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x372D393538382DLL)
                }
                {
                  LODWORD(name) = 16;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x382D393538382DLL)
                }
                {
                  LODWORD(name) = 17;
                }

                else if (*(void *)&v28[0] == 0x393538382D4F5349LL {
                       && *(void *)((char *)v28 + 3) == 0x392D393538382DLL)
                }
                {
                  LODWORD(name) = 18;
                }

                else if (*(void *)&v28[0] == 0x323230322D4F5349LL && DWORD2(v28[0]) == 5261869)
                {
                  LODWORD(name) = 19;
                }

                else if (*(void *)&v28[0] == 0x494A5F5446494853LL && WORD4(v28[0]) == 83)
                {
                  LODWORD(name) = 20;
                }

                else if (LODWORD(v28[0]) ^ 0x2D435545 | *(_DWORD *)((char *)v28 + 3) ^ 0x504A2D)
                {
                  LODWORD(name) = -1;
                }

                else
                {
                  LODWORD(name) = 21;
                }
              }
            }
          }
        }
      }
    }

    else
    {
      LODWORD(name) = 0;
    }
  }

  return (int)name;
}

const char *__cdecl xmlGetCharEncodingName(xmlCharEncoding enc)
{
  else {
    return off_189B9B880[enc - 1];
  }
}

xmlCharEncodingHandlerPtr xmlNewCharEncodingHandler( const char *name, xmlCharEncodingInputFunc input, xmlCharEncodingOutputFunc output)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  EncodingAlias = xmlGetEncodingAlias(name);
  if (EncodingAlias) {
    BOOL v7 = EncodingAlias;
  }
  else {
    BOOL v7 = name;
  }
  if (!v7)
  {
    __xmlRaiseError( 0,  0,  0,  0,  0,  27,  6000,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  (uint64_t)"xmlNewCharEncodingHandler : no name !\n");
    return 0LL;
  }

  uint64_t v8 = 0LL;
  int v46 = 0;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  *(_OWORD *)cur = 0u;
  do
  {
    char v9 = __toupper(v7[v8]);
    cur[v8] = v9;
    if (!v9) {
      break;
    }
    ++v8;
  }

  while (v8 != 499);
  cur[v8] = 0;
  BOOL v10 = xmlMemStrdup(cur);
  if (!v10)
  {
    __xmlSimpleError(27, 2, 0, 0LL, (uint64_t)"xmlNewCharEncodingHandler : out of memory !\n");
    return 0LL;
  }

  BOOL v11 = v10;
  BOOL v12 = (xmlCharEncodingHandler *)xmlMalloc(0x28uLL);
  BOOL v13 = v12;
  if (v12)
  {
    *(_OWORD *)&v12->name = 0u;
    *(_OWORD *)&v12->output = 0u;
    v12->uconv_in = 0LL;
    v12->uconv_out = 0LL;
    v12->name = v11;
    v12->input = input;
    v12->output = output;
    xmlRegisterCharEncodingHandler(v12);
  }

  else
  {
    xmlFree(v11);
    __xmlSimpleError(27, 2, 0, 0LL, (uint64_t)"xmlNewCharEncodingHandler : out of memory !\n");
  }

  return v13;
}

void xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler)
{
  uint64_t v2 = handlers;
  if (handlers)
  {
    if (!handler)
    {
LABEL_8:
      __xmlRaiseError( 0,  0,  0,  0,  0,  27,  6001,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  (uint64_t)"xmlRegisterCharEncodingHandler: NULL handler !\n");
      if (!handler) {
        return;
      }
      goto LABEL_9;
    }
  }

  else
  {
    xmlInitCharEncodingHandlers();
    uint64_t v2 = handlers;
    if (!handler) {
      goto LABEL_8;
    }
  }

  if (!v2) {
    goto LABEL_8;
  }
  uint64_t v3 = nbCharEncodingHandler;
  if (nbCharEncodingHandler < 50)
  {
    ++nbCharEncodingHandler;
    *(void *)(v2 + 8 * v3) = handler;
    return;
  }

  __xmlRaiseError( 0,  0,  0,  0,  0,  27,  6002,  3,  0LL,  0,  (uint64_t)"MAX_ENCODING_HANDLERS",  0LL,  0LL,  0,  0,  (uint64_t)"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n");
LABEL_9:
  if (handler->name) {
    xmlFree(handler->name);
  }
  xmlFree(handler);
}

void xmlInitCharEncodingHandlers(void)
{
  if (!handlers)
  {
    handlers = (uint64_t)xmlMalloc(0x190uLL);
    if (handlers)
    {
      xmlNewCharEncodingHandler("UTF-8", (xmlCharEncodingInputFunc)UTF8ToUTF8, (xmlCharEncodingOutputFunc)UTF8ToUTF8);
      xmlUTF16LEHandler = (uint64_t)xmlNewCharEncodingHandler( "UTF-16LE",  (xmlCharEncodingInputFunc)UTF16LEToUTF8,  (xmlCharEncodingOutputFunc)UTF8ToUTF16LE);
      xmlUTF16BEHandler = (uint64_t)xmlNewCharEncodingHandler( "UTF-16BE",  (xmlCharEncodingInputFunc)UTF16BEToUTF8,  (xmlCharEncodingOutputFunc)UTF8ToUTF16BE);
      xmlNewCharEncodingHandler( "UTF-16",  (xmlCharEncodingInputFunc)UTF16LEToUTF8,  (xmlCharEncodingOutputFunc)UTF8ToUTF16);
      xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, UTF8Toisolat1);
      xmlNewCharEncodingHandler("ASCII", (xmlCharEncodingInputFunc)asciiToUTF8, (xmlCharEncodingOutputFunc)UTF8Toascii);
      xmlNewCharEncodingHandler( "US-ASCII",  (xmlCharEncodingInputFunc)asciiToUTF8,  (xmlCharEncodingOutputFunc)UTF8Toascii);
      xmlNewCharEncodingHandler("HTML", 0LL, UTF8ToHtml);
    }

    else
    {
      __xmlSimpleError(27, 2, 0, 0LL, (uint64_t)"xmlInitCharEncodingHandlers : out of memory !\n");
    }
  }

uint64_t UTF8ToUTF8(void *__dst, unsigned int *a2, void *__src, _DWORD *a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (__dst && a2 && a4)
  {
    if (__src)
    {
      else {
        size_t v8 = *a2;
      }
      if ((v8 & 0x80000000) != 0)
      {
        return 0xFFFFFFFFLL;
      }

      else
      {
        memcpy(__dst, __src, v8);
        *a2 = v8;
        *a4 = v8;
        return *a2;
      }
    }

    else
    {
      uint64_t result = 0LL;
      *a2 = 0;
      *a4 = 0;
    }
  }

  return result;
}

uint64_t UTF16LEToUTF8(_BYTE *a1, unsigned int *a2, unsigned __int16 *a3, int *a4)
{
  uint64_t v4 = (int)*a2;
  if (!(_DWORD)v4)
  {
    uint64_t result = 0LL;
    *a4 = 0;
    return result;
  }

  int v5 = *a4;
  if ((*a4 & 0x80000001) == 1) {
    *a4 = --v5;
  }
  if (v5 >= 0) {
    int v6 = v5;
  }
  else {
    int v6 = v5 + 1;
  }
  unsigned int v7 = v5 + 1;
  LODWORD(v8) = (_DWORD)a1;
  LODWORD(v9) = (_DWORD)a3;
  if (v7 < 3)
  {
LABEL_39:
    *a2 = (_DWORD)v8 - (_DWORD)a1;
    *a4 = (_DWORD)v9 - (_DWORD)a3;
    return *a2;
  }

  unint64_t v10 = (unint64_t)&a1[v4];
  char v9 = a3;
  size_t v8 = a1;
  unint64_t v11 = (unint64_t)&a3[v6 >> 1];
  while (1)
  {
    BOOL v12 = v9;
    if (v8 - a1 + 5 >= (int)*a2)
    {
LABEL_38:
      LODWORD(v9) = (_DWORD)v12;
      goto LABEL_39;
    }

    ++v9;
    unsigned int v13 = *v12;
    if ((v13 & 0xFC00) == 0xD800) {
      break;
    }
LABEL_14:
    if (v13 <= 0x7F)
    {
      *v8++ = v13;
    }

    else
    {
      if (v13 >= 0x10000) {
        char v15 = 18;
      }
      else {
        char v15 = 12;
      }
      if (v13 >= 0x10000) {
        char v16 = -16;
      }
      else {
        char v16 = -32;
      }
      if (v13 < 0x800)
      {
        char v15 = 6;
        char v16 = -64;
      }

      *v8++ = v16 | (v13 >> v15);
      if ((unint64_t)v8 < v10)
      {
        if (v13 >= 0x10000) {
          unsigned int v17 = 12;
        }
        else {
          unsigned int v17 = 6;
        }
        if (v13 < 0x800) {
          unsigned int v17 = 0;
        }
        do
        {
          *v8++ = (v13 >> v17) & 0x3F | 0x80;
          BOOL v18 = v17 >= 6;
          v17 -= 6;
        }

        while (v18 && (unint64_t)v8 < v10);
      }
    }
  }

  unsigned __int16 v14 = *v9;
  if ((*v9 & 0xFC00) == 0xDC00)
  {
    char v9 = v12 + 2;
    unsigned int v13 = (v14 & 0x3FF | ((v13 & 0x3FF) << 10)) + 0x10000;
    goto LABEL_14;
  }

  *a2 = (_DWORD)v8 - (_DWORD)a1;
  *a4 = (_DWORD)v12 - (_DWORD)a3;
  return 4294967294LL;
}

uint64_t UTF8ToUTF16LE(_WORD *a1, int *a2, char *a3, int *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      uint64_t v5 = *a4;
      if (*a2 >= 0) {
        int v6 = *a2;
      }
      else {
        int v6 = *a2 + 1;
      }
      LODWORD(v7) = (_DWORD)a1;
      LODWORD(v8) = (_DWORD)a3;
      if ((int)v5 >= 1)
      {
        unint64_t v9 = (unint64_t)&a3[v5];
        unint64_t v10 = (unint64_t)&a1[v6 >> 1];
        unint64_t v11 = a3;
        unsigned int v7 = a1;
        size_t v8 = a3;
        do
        {
          int v12 = *v8++;
          unsigned int v13 = v12;
          if (v12 < 0)
          {
            if (v13 <= 0xBF) {
              goto LABEL_38;
            }
            if (v13 > 0xDF)
            {
              if (v13 > 0xEF)
              {
                if (v13 > 0xF7)
                {
LABEL_38:
                  *a2 = (_DWORD)v7 - (_DWORD)a1;
                  *a4 = (_DWORD)v11 - (_DWORD)a3;
                  return 4294967294LL;
                }

                unsigned int v15 = v13 & 7;
                uint64_t v14 = 3LL;
              }

              else
              {
                unsigned int v15 = v13 & 0xF;
                uint64_t v14 = 2LL;
              }
            }

            else
            {
              unsigned int v15 = v13 & 0x1F;
              uint64_t v14 = 1LL;
            }
          }

          else
          {
            uint64_t v14 = 0LL;
            unsigned int v15 = v13;
          }

          uint64_t v16 = 0LL;
          int v17 = v14 - 1;
          do
          {
            size_t v8 = &v11[v16 + 2];
            char v18 = v11[v16 + 1];
            if ((v18 & 0xC0) != 0x80) {
              break;
            }
            unsigned int v15 = v18 & 0x3F | (v15 << 6);
            if (v17 == (_DWORD)v16) {
              break;
            }
            ++v16;
          }

          while ((unint64_t)v8 < v9);
          if (HIWORD(v15))
          {
            if (HIWORD(v15) > 0x10u || (unint64_t)(v7 + 1) >= v10)
            {
LABEL_35:
              LODWORD(v8) = (_DWORD)v11;
              break;
            }

            _WORD *v7 = ((v15 + 16711680) >> 10) | 0xD800;
            v7[1] = v15 & 0x3FF | 0xDC00;
            v7 += 2;
          }

          else
          {
LABEL_27:
            *v7++ = v15;
          }

          unint64_t v11 = v8;
        }

        while ((unint64_t)v8 < v9);
      }

      *a2 = (_DWORD)v7 - (_DWORD)a1;
      *a4 = (_DWORD)v8 - (_DWORD)a3;
      return *a2;
    }

    else
    {
      uint64_t v4 = 0LL;
      *a2 = 0;
      *a4 = 0;
    }
  }

  return v4;
}

uint64_t UTF16BEToUTF8(_BYTE *a1, unsigned int *a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v4 = (int)*a2;
  if (!(_DWORD)v4)
  {
    uint64_t result = 0LL;
    *a4 = 0;
    return result;
  }

  int v5 = *a4;
  if ((*a4 & 0x80000001) == 1) {
    *a4 = --v5;
  }
  if (v5 >= 0) {
    int v6 = v5;
  }
  else {
    int v6 = v5 + 1;
  }
  unsigned int v7 = v5 + 1;
  LODWORD(v8) = (_DWORD)a1;
  LODWORD(v9) = (_DWORD)a3;
  if (v7 < 3)
  {
LABEL_39:
    *a2 = (_DWORD)v8 - (_DWORD)a1;
    *a4 = (_DWORD)v9 - (_DWORD)a3;
    return *a2;
  }

  unint64_t v10 = (unint64_t)&a1[v4];
  unint64_t v9 = a3;
  size_t v8 = a1;
  unint64_t v11 = (unint64_t)&a3[2 * (v6 >> 1)];
  while (1)
  {
    int v12 = v9;
    if (v8 - a1 + 5 >= (int)*a2)
    {
LABEL_38:
      LODWORD(v9) = (_DWORD)v12;
      goto LABEL_39;
    }

    int v13 = *v9;
    unsigned int v14 = v9[1] | (v13 << 8);
    v9 += 2;
    if ((v13 & 0xFC) == 0xD8) {
      break;
    }
LABEL_14:
    if (v14 <= 0x7F)
    {
      *v8++ = v14;
    }

    else
    {
      if (v14 >= 0x10000) {
        char v16 = 18;
      }
      else {
        char v16 = 12;
      }
      if (v14 >= 0x10000) {
        char v17 = -16;
      }
      else {
        char v17 = -32;
      }
      if (v14 < 0x800)
      {
        char v16 = 6;
        char v17 = -64;
      }

      *v8++ = v17 | (v14 >> v16);
      if ((unint64_t)v8 < v10)
      {
        if (v14 >= 0x10000) {
          unsigned int v18 = 12;
        }
        else {
          unsigned int v18 = 6;
        }
        if (v14 < 0x800) {
          unsigned int v18 = 0;
        }
        do
        {
          *v8++ = (v14 >> v18) & 0x3F | 0x80;
          BOOL v19 = v18 >= 6;
          v18 -= 6;
        }

        while (v19 && (unint64_t)v8 < v10);
      }
    }
  }

  unsigned __int8 v15 = *v9;
  if ((*v9 & 0xFC) == 0xDC)
  {
    unint64_t v9 = v12 + 4;
    unsigned int v14 = (v12[3] | ((v15 & 3) << 8) & 0x3FF | ((v14 & 0x3FF) << 10)) + 0x10000;
    goto LABEL_14;
  }

  *a2 = (_DWORD)v8 - (_DWORD)a1;
  *a4 = (_DWORD)v12 - (_DWORD)a3;
  return 4294967294LL;
}

uint64_t UTF8ToUTF16BE(_BYTE *a1, int *a2, char *a3, int *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      uint64_t v5 = *a4;
      if (*a2 >= 0) {
        int v6 = *a2;
      }
      else {
        int v6 = *a2 + 1;
      }
      LODWORD(v7) = (_DWORD)a1;
      LODWORD(v8) = (_DWORD)a3;
      if ((int)v5 >= 1)
      {
        unint64_t v9 = (unint64_t)&a3[v5];
        unint64_t v10 = (unint64_t)&a1[2 * (v6 >> 1)];
        unint64_t v11 = a3;
        unsigned int v7 = a1;
        size_t v8 = a3;
        do
        {
          int v12 = *v8++;
          unsigned int v13 = v12;
          if (v12 < 0)
          {
            if (v13 <= 0xBF) {
              goto LABEL_38;
            }
            if (v13 > 0xDF)
            {
              if (v13 > 0xEF)
              {
                if (v13 > 0xF7)
                {
LABEL_38:
                  *a2 = (unint64_t)(v7 - a1) >> 1;
                  *a4 = (_DWORD)v11 - (_DWORD)a3;
                  return 4294967294LL;
                }

                unsigned int v15 = v13 & 7;
                uint64_t v14 = 3LL;
              }

              else
              {
                unsigned int v15 = v13 & 0xF;
                uint64_t v14 = 2LL;
              }
            }

            else
            {
              unsigned int v15 = v13 & 0x1F;
              uint64_t v14 = 1LL;
            }
          }

          else
          {
            uint64_t v14 = 0LL;
            unsigned int v15 = v13;
          }

          uint64_t v16 = 0LL;
          int v17 = v14 - 1;
          do
          {
            size_t v8 = &v11[v16 + 2];
            char v18 = v11[v16 + 1];
            if ((v18 & 0xC0) != 0x80) {
              break;
            }
            unsigned int v15 = v18 & 0x3F | (v15 << 6);
            if (v17 == (_DWORD)v16) {
              break;
            }
            ++v16;
          }

          while ((unint64_t)v8 < v9);
          if (HIWORD(v15))
          {
            if (HIWORD(v15) > 0x10u || (unint64_t)(v7 + 2) >= v10)
            {
LABEL_35:
              LODWORD(v8) = (_DWORD)v11;
              break;
            }

            _BYTE *v7 = ((v15 - 0x10000) >> 18) | 0xD8;
            v7[1] = (v15 - 0x10000) >> 10;
            v7[2] = BYTE1(v15) & 3 | 0xDC;
            uint64_t v19 = 3LL;
            uint64_t v20 = 2LL;
          }

          else
          {
LABEL_27:
            _BYTE *v7 = BYTE1(v15);
            uint64_t v19 = 1LL;
            uint64_t v20 = 1LL;
          }

          v7[v19] = v15;
          unint64_t v11 = v8;
          v7 += 2 * v20;
        }

        while ((unint64_t)v8 < v9);
      }

      *a2 = (_DWORD)v7 - (_DWORD)a1;
      *a4 = (_DWORD)v8 - (_DWORD)a3;
      return *a2;
    }

    else
    {
      uint64_t v4 = 0LL;
      *a2 = 0;
      *a4 = 0;
    }
  }

  return v4;
}

uint64_t UTF8ToUTF16(_WORD *a1, int *a2, char *a3, int *a4)
{
  if (a3) {
    return UTF8ToUTF16LE(a1, a2, a3, a4);
  }
  if (*a2 < 2)
  {
    uint64_t result = 0LL;
    *a2 = 0;
  }

  else
  {
    *a1 = -257;
    uint64_t result = 2LL;
    *a2 = 2;
  }

  *a4 = 0;
  return result;
}

uint64_t asciiToUTF8(uint64_t a1, unsigned int *a2, uint64_t a3, int *a4)
{
  uint64_t v4 = *a4;
  if ((int)v4 < 1)
  {
    LODWORD(v8) = a1;
    int v10 = a3;
LABEL_10:
    *a2 = (_DWORD)v8 - a1;
    *a4 = v10 - a3;
    return *a2;
  }

  else
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = a1 + (int)*a2;
    unint64_t v7 = a3 + v4;
    while (1)
    {
      size_t v8 = (_BYTE *)(a1 + v5);
      if (v5 + 5 >= (int)*a2 || (unint64_t)v8 >= v6)
      {
        int v10 = a3 + v5;
        goto LABEL_10;
      }

      int v9 = *(char *)(a3 + v5);
      if (v9 < 0) {
        break;
      }
      *size_t v8 = v9;
      int v10 = a3 + ++v5;
      if (a3 + v5 >= v7)
      {
        LODWORD(v8) = a1 + v5;
        goto LABEL_10;
      }
    }

    *a2 = v5;
    *a4 = v5;
    return 4294967294LL;
  }

uint64_t UTF8Toascii(_BYTE *a1, unsigned int *a2, char *a3, int *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2 && a4)
  {
    if (a3)
    {
      uint64_t v5 = *a4;
      LODWORD(v6) = (_DWORD)a1;
      LODWORD(v7) = (_DWORD)a3;
      if ((int)v5 < 1)
      {
LABEL_30:
        *a2 = (_DWORD)v6 - (_DWORD)a1;
        *a4 = (_DWORD)v7 - (_DWORD)a3;
        return *a2;
      }

      else
      {
        unint64_t v8 = (unint64_t)&a3[v5];
        unint64_t v9 = (unint64_t)&a1[*a2];
        int v10 = a3;
        unint64_t v6 = a1;
        unint64_t v7 = a3;
        while (1)
        {
          int v11 = *v7++;
          unsigned int v12 = v11;
          if (v11 < 0)
          {
            if (v12 <= 0xBF) {
              break;
            }
            if (v12 > 0xDF)
            {
              if (v12 > 0xEF)
              {
                if (v12 > 0xF7) {
                  break;
                }
                unsigned int v14 = v12 & 7;
                unsigned int v13 = 3;
              }

              else
              {
                unsigned int v14 = v12 & 0xF;
                unsigned int v13 = 2;
              }
            }

            else
            {
              unsigned int v14 = v12 & 0x1F;
              unsigned int v13 = 1;
            }
          }

          else
          {
            unsigned int v13 = 0;
            unsigned int v14 = v12;
          }

          if ((uint64_t)(v8 - (void)v7) < v13)
          {
LABEL_29:
            LODWORD(v7) = (_DWORD)v10;
            goto LABEL_30;
          }

          if ((v12 & 0x80) != 0 && (unint64_t)v7 < v8)
          {
            unsigned int v15 = v13 - 1;
            uint64_t v16 = v10 + 2;
            do
            {
              unint64_t v7 = v16;
              char v17 = *(v16 - 1);
              if ((v17 & 0xC0) != 0x80) {
                break;
              }
              unsigned int v14 = v17 & 0x3F | (v14 << 6);
              if (v15-- == 0) {
                break;
              }
              uint64_t v16 = v7 + 1;
            }

            while ((unint64_t)v7 < v8);
          }

          if (v14 > 0x7F) {
            break;
          }
          *v6++ = v14;
          int v10 = v7;
        }

        *a2 = (_DWORD)v6 - (_DWORD)a1;
        *a4 = (_DWORD)v10 - (_DWORD)a3;
        return 4294967294LL;
      }
    }

    else
    {
      uint64_t v4 = 0LL;
      *a2 = 0;
      *a4 = 0;
    }
  }

  return v4;
}

void xmlCleanupCharEncodingHandlers(void)
{
  xmlGenericErrorFunc v0 = (void *)handlers;
  if (handlers)
  {
    int v1 = nbCharEncodingHandler;
    if (nbCharEncodingHandler >= 1)
    {
      do
      {
        nbCharEncodingHandler = --v1;
        uint64_t v2 = (void **)v0[v1];
        if (v2)
        {
          uint64_t v3 = *v2;
          if (v3)
          {
            xmlFree(v3);
            xmlGenericErrorFunc v0 = (void *)handlers;
            int v1 = nbCharEncodingHandler;
          }

          xmlFree((void *)v0[v1]);
          xmlGenericErrorFunc v0 = (void *)handlers;
          int v1 = nbCharEncodingHandler;
        }
      }

      while (v1 > 0);
    }

    xmlFree(v0);
    handlers = 0LL;
    nbCharEncodingHandler = 0;
  }

xmlCharEncodingHandlerPtr xmlGetCharEncodingHandler(xmlCharEncoding enc)
{
  if (!handlers) {
    xmlInitCharEncodingHandlers();
  }
  xmlCharEncodingHandlerPtr result = 0LL;
  switch(enc)
  {
    case XML_CHAR_ENCODING_ERROR:
    case XML_CHAR_ENCODING_NONE:
    case XML_CHAR_ENCODING_UTF8:
      return result;
    case XML_CHAR_ENCODING_UTF16LE:
      return (xmlCharEncodingHandlerPtr)xmlUTF16LEHandler;
    case XML_CHAR_ENCODING_UTF16BE:
      return (xmlCharEncodingHandlerPtr)xmlUTF16BEHandler;
    case XML_CHAR_ENCODING_UCS4LE:
    case XML_CHAR_ENCODING_UCS4BE:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
      if (!result)
      {
        xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("UCS-4");
        if (!result)
        {
          uint64_t v3 = "UCS4";
          goto LABEL_30;
        }
      }

      return result;
    case XML_CHAR_ENCODING_EBCDIC:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("EBCDIC");
      if (!result)
      {
        xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("ebcdic");
        if (!result)
        {
          xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("EBCDIC-US");
          if (!result)
          {
            uint64_t v3 = "IBM-037";
            goto LABEL_30;
          }
        }
      }

      return result;
    case XML_CHAR_ENCODING_UCS2:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
      if (!result)
      {
        xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("UCS-2");
        if (!result)
        {
          uint64_t v3 = "UCS2";
          goto LABEL_30;
        }
      }

      return result;
    case XML_CHAR_ENCODING_8859_1:
      uint64_t v3 = "ISO-8859-1";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_2:
      uint64_t v3 = "ISO-8859-2";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_3:
      uint64_t v3 = "ISO-8859-3";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_4:
      uint64_t v3 = "ISO-8859-4";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_5:
      uint64_t v3 = "ISO-8859-5";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_6:
      uint64_t v3 = "ISO-8859-6";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_7:
      uint64_t v3 = "ISO-8859-7";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_8:
      uint64_t v3 = "ISO-8859-8";
      goto LABEL_30;
    case XML_CHAR_ENCODING_8859_9:
      uint64_t v3 = "ISO-8859-9";
      goto LABEL_30;
    case XML_CHAR_ENCODING_2022_JP:
      uint64_t v3 = "ISO-2022-JP";
      goto LABEL_30;
    case XML_CHAR_ENCODING_SHIFT_JIS:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("SHIFT-JIS");
      if (result) {
        return result;
      }
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler("SHIFT_JIS");
      if (result) {
        return result;
      }
      uint64_t v3 = "Shift_JIS";
LABEL_30:
      xmlCharEncodingHandlerPtr result = xmlFindCharEncodingHandler(v3);
      if (!result) {
        return 0LL;
      }
      return result;
    case XML_CHAR_ENCODING_EUC_JP:
      uint64_t v3 = "EUC-JP";
      goto LABEL_30;
    default:
      return 0LL;
  }

xmlCharEncodingHandlerPtr xmlFindCharEncodingHandler(const char *name)
{
  while (1)
  {
    int v1 = name;
    uint64_t v24 = *MEMORY[0x1895F89C0];
    if (handlers)
    {
      if (!name) {
        return 0LL;
      }
    }

    else
    {
      xmlInitCharEncodingHandlers();
      if (!v1) {
        return 0LL;
      }
    }

    if (!*v1) {
      return 0LL;
    }
    int v23 = 0;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    *(_OWORD *)__s1 = 0u;
    __int128 v18 = 0u;
    EncodingAlias = xmlGetEncodingAlias(v1);
    uint64_t v3 = 0LL;
    uint64_t v4 = EncodingAlias ? EncodingAlias : v1;
    do
    {
      char v5 = __toupper(v4[v3]);
      __s1[v3] = v5;
      if (!v5) {
        break;
      }
      ++v3;
    }

    while (v3 != 99);
    __s1[v3] = 0;
    unint64_t v6 = (const char ***)handlers;
    if (handlers)
    {
      uint64_t v7 = nbCharEncodingHandler;
      if (nbCharEncodingHandler >= 1) {
        break;
      }
    }

LABEL_15:
    unint64_t v9 = (uconv_t *)openIcuConverter((uint64_t)v4, 1);
    unint64_t v10 = (unint64_t)openIcuConverter((uint64_t)v4, 0);
    int v11 = (uconv_t *)v10;
    if (v9 && v10)
    {
      unsigned int v12 = (xmlCharEncodingHandler *)xmlMalloc(0x28uLL);
      unint64_t v8 = v12;
      if (v12)
      {
        v12->uconv_out = 0LL;
        *(_OWORD *)&v12->name = 0u;
        *(_OWORD *)&v12->output = 0u;
        v12->name = xmlMemStrdup(v4);
        v8->input = 0LL;
        v8->output = 0LL;
        v8->uconv_in = v9;
        v8->uconv_out = v11;
      }

      else
      {
        ucnv_close();
        ucnv_close();
        xmlFree(v9);
        ucnv_close();
        ucnv_close();
        xmlFree(v11);
      }

      return v8;
    }

    if ((unint64_t)v9 | v10)
    {
      closeIcuConverter(v9);
      closeIcuConverter(v11);
      __xmlRaiseError( 0,  0,  0,  0,  0,  27,  1,  3,  0LL,  0,  (uint64_t)v4,  0LL,  0LL,  0,  0,  (uint64_t)"ICU converter : problems with filters for '%s'\n");
    }

    xmlCharEncoding v13 = xmlParseCharEncoding(v1);
    if (v13 == XML_CHAR_ENCODING_ERROR) {
      return 0LL;
    }
    CharEncodingName = xmlGetCharEncodingName(v13);
    if (!CharEncodingName) {
      return 0LL;
    }
    unsigned int v15 = CharEncodingName;
    if (!strcmp(v4, CharEncodingName)) {
      return 0LL;
    }
    name = v15;
  }

  while (1)
  {
    unint64_t v8 = (xmlCharEncodingHandler *)*v6;
    if (!strcmp(__s1, **v6)) {
      return v8;
    }
    ++v6;
    if (!--v7) {
      goto LABEL_15;
    }
  }

  len = 0;
  unint64_t v9 = xmlCurrentChar(ctxt, &len);
  unint64_t v10 = 0LL;
  int v11 = 0;
  while (v9 != 38 && v9 != 60)
  {
    if (v9 > 255)
    {
      if (v9 >> 11 >= 0x1B
        && (v9 - 57344) >> 1 >= 0xFFF
        && (v9 - 0x10000) >= 0x100000)
      {
        break;
      }
    }

    else if (v9 > 0xD || ((1 << v9) & 0x2600) == 0)
    {
      if (v9 <= 31) {
        break;
      }
      if (v9 == 93)
      {
        unsigned int v12 = ctxt->input->cur;
        if (v12[1] == 93 && v12[2] == 62)
        {
          if (cdata) {
            break;
          }
          xmlFatalErr(ctxt, 62, 0LL);
        }
      }
    }

    if (len == 1)
    {
      *((_BYTE *)v64 + (int)v10) = v9;
      unint64_t v10 = (v10 + 1);
      xmlCharEncoding v13 = 1;
    }

    else
    {
      unint64_t v10 = (xmlCopyCharMultiByte((xmlChar *)v64 + (int)v10, v9) + v10);
      xmlCharEncoding v13 = len;
    }

    unsigned int v14 = ctxt->input;
    unsigned int v15 = v14->cur;
    uint64_t v16 = &v15[v13];
    if (v16 <= v14->end)
    {
      if (*v15 == 10)
      {
        ++v14->line;
        v14->col = 1;
      }

      else
      {
        ++v14->col;
      }

      v14->cur = v16;
    }

    unint64_t v9 = xmlCurrentChar(ctxt, &len);
    if ((int)v10 >= 300)
    {
      *((_BYTE *)v64 + v10) = 0;
      if (ctxt->sax && !ctxt->disableSAX)
      {
        __int128 v20 = areBlanks_0(ctxt, (unsigned __int8 *)v64, v10, 0);
        __int128 v21 = ctxt->sax;
        if (v20)
        {
          __int128 v22 = (void (*)(void, void, void))v21->ignorableWhitespace;
          if (v22) {
            v22(ctxt->userData, v64, v10);
          }
        }

        else
        {
          int v23 = v21->characters;
          if (v23)
          {
            ((void (*)(void *, _OWORD *, uint64_t))v23)(ctxt->userData, v64, v10);
            __int128 v21 = ctxt->sax;
            int v23 = ctxt->sax->characters;
          }

          if (v23 != v21->ignorableWhitespace)
          {
            uint64_t v24 = ctxt->space;
            if (*v24 == -1) {
              const xmlChar *v24 = -2;
            }
          }
        }
      }

      if (ctxt->instate != XML_PARSER_CONTENT) {
        return;
      }
      unint64_t v10 = 0LL;
    }

    char v17 = v11++ < 50;
    if (!v17)
    {
      if (!ctxt->progressive)
      {
        __int128 v18 = ctxt->input;
        __int128 v19 = v18->cur;
        if (v19 - v18->base < 501 || v18->end - v19 > 499) {
          goto LABEL_49;
        }
        xmlSHRINK((uint64_t)ctxt);
        if (!ctxt->progressive)
        {
          __int128 v18 = ctxt->input;
          __int128 v19 = v18->cur;
LABEL_49:
          if (v18->end - v19 <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
        }
      }

      int v11 = 0;
      if (ctxt->instate == XML_PARSER_EOF) {
        return;
      }
    }
  }

  if ((_DWORD)v10)
  {
    *((_BYTE *)v64 + (int)v10) = 0;
    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        xmlGenericErrorFunc v56 = areBlanks_0(ctxt, (unsigned __int8 *)v64, v10, 0);
        xmlListPtr v57 = ctxt->sax;
        if (v56)
        {
          v58 = (void (*)(void, void, void))v57->ignorableWhitespace;
          if (v58) {
            v58(ctxt->userData, v64, v10);
          }
        }

        else
        {
          uint64_t v59 = v57->characters;
          if (v59)
          {
            ((void (*)(void *, _OWORD *, uint64_t))v59)(ctxt->userData, v64, v10);
            xmlListPtr v57 = ctxt->sax;
            uint64_t v59 = ctxt->sax->characters;
          }

          if (v59 != v57->ignorableWhitespace)
          {
            v60 = ctxt->space;
            if (*v60 == -1) {
              void *v60 = -2;
            }
          }
        }
      }
    }
  }

  if (v9)
  {
    if (v9 > 255)
    {
    }

    else if (v9 <= 31 && (v9 > 0xD || ((1 << v9) & 0x2600) == 0))
    {
LABEL_137:
      xmlFatalErrMsgInt(ctxt, 9, (uint64_t)"PCDATA invalid Char value %d\n", v9);
      xmlGenericErrorFunc v53 = ctxt->input;
      int v54 = v53->cur;
      v55 = &v54[len];
      if (v55 <= v53->end)
      {
        if (*v54 == 10)
        {
          ++v53->line;
          v53->col = 1;
        }

        else
        {
          ++v53->col;
        }

        v53->cur = v55;
      }
    }
  }

  __int128 v20 = xmlSplitQName3(name2, &len);
  __int128 v21 = *(xmlDict **)(a1 + 456);
  if (v20)
  {
    __int128 v22 = xmlDictLookup(v21, v20, -1);
    int v23 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), name2, len);
  }

  else
  {
    __int128 v22 = xmlDictLookup(v21, name2, -1);
    int v23 = 0LL;
  }

  uint64_t v24 = 5 * *v16;
  __int128 v25 = v16 + 2;
  *(void *)&v16[10 * *v16 + 2] = v22;
  *(void *)&v16[2 * v24 + 4] = v23;
  len = xmlStrlen(a4);
  xmlCharEncodingHandlerPtr result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), a4, len);
  __int128 v26 = *v16;
  *(void *)&v25[10 * v26 + 4] = result;
  *(void *)&v25[10 * v26 + 6] = (char *)result + len;
  if (*(_DWORD *)(a1 + 148)) {
    __int128 v27 = "external";
  }
  else {
    __int128 v27 = 0LL;
  }
  *(void *)&v25[10 * v26 + 8] = v27;
  *uint64_t v16 = v26 + 1;
  return result;
}

  ctxt->version = 0LL;
  encoding = (xmlChar *)ctxt->encoding;
  if (!encoding) {
    goto LABEL_20;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, encoding)) {
      goto LABEL_20;
    }
    encoding = (xmlChar *)ctxt->encoding;
  }

  xmlFree(encoding);
LABEL_20:
  ctxt->encoding = 0LL;
  directory = ctxt->directory;
  if (!directory) {
    goto LABEL_25;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)directory)) {
      goto LABEL_25;
    }
    directory = ctxt->directory;
  }

  xmlFree(directory);
LABEL_25:
  ctxt->directory = 0LL;
  extSubURI = ctxt->extSubURI;
  if (!extSubURI) {
    goto LABEL_30;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, extSubURI)) {
      goto LABEL_30;
    }
    extSubURI = ctxt->extSubURI;
  }

  xmlFree(extSubURI);
LABEL_30:
  ctxt->extSubURI = 0LL;
  extSubSystem = ctxt->extSubSystem;
  if (extSubSystem)
  {
    if (!dict)
    {
LABEL_34:
      xmlFree(extSubSystem);
      goto LABEL_35;
    }

    if (!xmlDictOwns(dict, extSubSystem))
    {
      extSubSystem = ctxt->extSubSystem;
      goto LABEL_34;
    }
  }

        ++v10;
        uint64_t v7 = *a2;
        if (v10 >= *a2)
        {
          char v17 = v7;
          goto LABEL_26;
        }
      }
    }

    char v17 = v7;
LABEL_26:
    __int128 v18 = *((void *)a2 + 1);
    *a2 = v7 + 1;
    *(void *)(v18 + 8 * v17) = a3;
    return 1LL;
  }

  return result;
}

      uint64_t v4 = v4->next;
      if (!v4) {
        return v6;
      }
    }
  }

  return 0LL;
}

  uint64_t v7 = 0LL;
  *(_DWORD *)(a1 + 88) = v1 | v6;
  return v7;
}

    for (i = 0LL; v16; uint64_t v16 = v15[++i])
    {
      if (v16 == 124) {
        break;
      }
    }

    __int128 v18 = xmlStrncat(0LL, v15, i);
    __int128 v19 = &v15[i];
LABEL_19:
    if (*v19)
    {
      __int128 v22 = v19[1];
      __int128 v21 = v19 + 1;
      int v23 = v22 == 42;
      if (a4)
      {
        if (!v23) {
          goto LABEL_29;
        }
        if (*v18 == 42)
        {
          xmlFree(v18);
          goto LABEL_41;
        }
      }

      else if (!v23)
      {
LABEL_29:
        __int128 v26 = -1;
        __int128 v27 = v21;
        do
        {
          __int128 v28 = *v27++;
          ++v26;
        }

        while (v28);
        else {
          __int128 v29 = "{";
        }
        __int128 v30 = xmlStrdup((const xmlChar *)v29);
        __int128 v31 = xmlStrncat(v30, v21, v26);
        __int128 v25 = xmlStrcat(v31, (const xmlChar *)"}");
LABEL_35:
        __int128 v32 = v25;
        uint64_t v24 = xmlStrcat(v38, v25);
        if (v32) {
          xmlFree(v32);
        }
        goto LABEL_37;
      }

      __int128 v25 = xmlStrdup((const xmlChar *)"{*}");
      goto LABEL_35;
    }

    uint64_t v24 = v38;
LABEL_37:
    __int128 v33 = xmlStrcat(v24, v18);
    __int128 v38 = v33;
    if (v18) {
      xmlFree(v18);
    }
LABEL_41:
    ++v13;
  }

  while (v13 != v11);
  __int128 v38 = xmlStrcat(v38, (const xmlChar *)").\n");
  __int128 v34 = cur;
  __int128 v35 = xmlEscapeFormatString((void **)&v38);
  __int128 v36 = xmlStrcat(v34, v35);
  cur = v36;
  if (v38)
  {
    xmlFree(v38);
    __int128 v38 = 0LL;
    __int128 v36 = cur;
  }

    if (!v5 && !*(void *)(*(void *)(a1 + 192) + 48LL))
    {
      xmlSchemaCustomErr4( (_DWORD *)a1,  1877,  0LL,  *(_DWORD **)(*(void *)(*(void *)(v2 + 40) + 24LL) + 8LL),  (const xmlChar *)"Warning: No precomputed value available, the value was either invalid or something strange happened",  0LL,  0LL,  0LL,  0LL);
      char v5 = 0LL;
      __int128 v41 = *(_DWORD *)(v2 + 32) - 1;
      *(_DWORD *)(v2 + 32) = v41;
      goto LABEL_112;
    }

    unint64_t v9 = *(void *)(v2 + 40);
    unint64_t v10 = *(_DWORD *)(v2 + 16) - *(_DWORD *)(v9 + 4);
    int v11 = *(int *)(*(void *)(v2 + 48) + 16LL);
    unsigned int v12 = *(void **)(v9 + 40);
    if (v12)
    {
      xmlCharEncoding v13 = *(int *)(v9 + 48);
      if (v10 >= (int)v13)
      {
        *(_DWORD *)(v9 + 48) = 2 * v10;
        unsigned int v14 = xmlRealloc(v12, 16LL * v10);
        *(void *)(v9 + 40) = v14;
        if (!v14)
        {
          __int128 v70 = "reallocating an array of key-sequences";
          goto LABEL_131;
        }

        unsigned int v15 = *(int *)(v9 + 48);
        if ((int)v13 < (int)v15)
        {
          do
            *(void *)(*(void *)(v9 + 40) + 8 * v13++) = 0LL;
          while (v15 != v13);
        }
      }
    }

    else
    {
      __int128 v42 = 2 * v10;
      if (v10 < 10) {
        __int128 v42 = 10;
      }
      *(_DWORD *)(v9 + 48) = v42;
      __int128 v43 = xmlMalloc(8LL * v42);
      *(void *)(v9 + 40) = v43;
      if (!v43)
      {
        __int128 v70 = "allocating an array of key-sequences";
        goto LABEL_131;
      }

      bzero(v43, 8LL * *(int *)(v9 + 48));
    }

    __int128 v44 = v10;
    __int128 v45 = *(void **)(*(void *)(v9 + 40) + 8LL * v10);
    if (v45)
    {
      if (v45[v11])
      {
        name = 0LL;
        int v46 = *(int **)(*(void *)(v9 + 24) + 8LL);
        uint64_t v47 = *(const xmlChar **)(*(void *)(v2 + 48) + 24LL);
        int v48 = xmlSchemaGetComponentDesignation(&name, v46);
        xmlSchemaCustomErr4( (_DWORD *)a1,  1877,  0LL,  v46,  (const xmlChar *)"The XPath '%s' of a field of %s evaluates to a node-set with more than one member",  v47,  v48,  0LL,  0LL);
        if (name) {
          xmlFree(name);
        }
        __int128 v41 = *(_DWORD *)(v2 + 32) - 1;
        *(_DWORD *)(v2 + 32) = v41;
        goto LABEL_112;
      }

      goto LABEL_76;
    }

    uint64_t v49 = xmlMalloc(8LL * *(int *)(*(void *)(*(void *)(v9 + 24) + 8LL) + 64LL));
    if (v49)
    {
      __int128 v45 = v49;
      bzero(v49, 8LL * *(int *)(*(void *)(*(void *)(v9 + 24) + 8LL) + 64LL));
      *(void *)(*(void *)(v9 + 40) + 8 * v44) = v45;
LABEL_76:
      if (!v5)
      {
        int v50 = xmlMalloc(0x10uLL);
        if (!v50)
        {
          __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)"allocating a IDC key");
          xmlFree(v45);
          *(void *)(*(void *)(v9 + 40) + 8 * v44) = 0LL;
          return 0xFFFFFFFFLL;
        }

        char v5 = v50;
        *int v50 = v8;
        uint64_t v51 = *(void *)(a1 + 192);
        v50[1] = *(void *)(v51 + 48);
        *(void *)(v51 + 48) = 0LL;
        uint64_t v52 = *(void **)(a1 + 248);
        if (v52)
        {
          xmlGenericErrorFunc v53 = *(int *)(a1 + 260);
          if ((int)v53 <= *(_DWORD *)(a1 + 256))
          {
            *(_DWORD *)(a1 + 260) = 2 * v53;
            uint64_t v52 = xmlRealloc(v52, 16 * v53);
            *(void *)(a1 + 248) = v52;
            if (!v52)
            {
              __int128 v71 = "re-allocating the IDC key storage list";
LABEL_139:
              __int128 v72 = *(_DWORD *)(a1 + 108) + 1;
              *(_DWORD *)(a1 + 104) = 1818;
              *(_DWORD *)(a1 + 108) = v72;
              __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)v71);
              __int128 v73 = (xmlSchemaVal *)v5[1];
              if (v73) {
                xmlSchemaFreeValue(v73);
              }
              ((void (*)(void *))xmlFree)(v5);
              return 0xFFFFFFFFLL;
            }
          }
        }

        else
        {
          uint64_t v52 = xmlMalloc(0x140uLL);
          *(void *)(a1 + 248) = v52;
          if (!v52)
          {
            __int128 v71 = "allocating the IDC key storage list";
            goto LABEL_139;
          }

          *(_DWORD *)(a1 + 260) = 40;
        }

        xmlGenericErrorFunc v56 = *(int *)(a1 + 256);
        *(_DWORD *)(a1 + 256) = v56 + 1;
        *((void *)v52 + v56) = v5;
      }

      v45[v11] = v5;
LABEL_111:
      __int128 v41 = *(_DWORD *)(v2 + 32) - 1;
      *(_DWORD *)(v2 + 32) = v41;
      goto LABEL_112;
    }

    __int128 v70 = "allocating an IDC key-sequence";
LABEL_131:
    __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)v70);
    return 0xFFFFFFFFLL;
  }

  uint64_t v16 = *(void *)(v2 + 40);
  char v17 = *(void *)(*(void *)(v16 + 24) + 8LL);
  __int128 v18 = *(void *)(v16 + 40);
  if (!v18 || (__int128 v19 = a2 - *(_DWORD *)(v16 + 4), *(_DWORD *)(v16 + 48) <= v19))
  {
    if (*(_DWORD *)v17 != 23) {
      goto LABEL_111;
    }
    uint64_t v81 = 0LL;
    goto LABEL_58;
  }

  uint64_t v81 = (uint64_t *)(v18 + 8LL * v19);
  __int128 v20 = (void *)*v81;
  if (!*v81)
  {
    if (*(_DWORD *)v17 != 23) {
      goto LABEL_111;
    }
    goto LABEL_58;
  }

  __int128 v21 = *(unsigned int *)(v17 + 64);
  __int128 v79 = v21;
  if ((int)v21 >= 1)
  {
    while (*v20)
    {
      ++v20;
      if (!--v21) {
        goto LABEL_29;
      }
    }

    if (*(_DWORD *)v17 != 23)
    {
LABEL_60:
      __int128 v37 = (void **)v81;
      if (!v81) {
        goto LABEL_111;
      }
LABEL_109:
      if (*v37)
      {
        __int128 v82 = v6;
        uint64_t v64 = v5;
        v65 = v37;
        xmlFree(*v37);
        xmlXPathContext *v65 = 0LL;
        char v5 = v64;
        unint64_t v6 = v82;
      }

      goto LABEL_111;
    }

void *openIcuConverter(uint64_t a1, int a2)
{
  uint64_t v3 = xmlMalloc(0x820uLL);
  if (v3)
  {
    if (linkedOnOrAfterFall2022OSVersions())
    {
      v3[258] = v3 + 2;
      v3[259] = v3 + 2;
    }

    void *v3 = ucnv_open();
    if (a2) {
      ucnv_setToUCallBack();
    }
    else {
      ucnv_setFromUCallBack();
    }
    v3[1] = ucnv_open();
  }

  return v3;
}

void closeIcuConverter(void *a1)
{
  if (a1)
  {
    ucnv_close();
    ucnv_close();
    xmlFree(a1);
  }

uint64_t xmlCharEncFirstLineInt(uint64_t a1, xmlBufferPtr buf, uint64_t a3, signed int a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && buf && a3)
  {
    unsigned int use = buf->use;
    signed int v9 = buf->size + ~use;
    signed int v10 = *(_DWORD *)(a3 + 8);
    unsigned int len = v10;
    unsigned int v15 = v9;
    if (a4 < 0)
    {
      if (v10 >= 181)
      {
        signed int v10 = 180;
        unsigned int len = 180;
      }
    }

    else if (v10 > a4)
    {
      unsigned int len = a4;
      signed int v10 = a4;
    }

    if (2 * v10 >= v9)
    {
      xmlBufferGrow(buf, 2 * v10);
      unsigned int use = buf->use;
      unsigned int v15 = buf->size + ~use;
    }

    unsigned int v11 = xmlEncInputChunk(a1, (uint64_t)&buf->content[use], &v15, *(void *)a3, &len, 0);
    xmlBufferShrink((xmlBufferPtr)a3, len);
    unsigned int v12 = buf->use + v15;
    buf->unsigned int use = v12;
    buf->content[v12] = 0;
    if (v11 == -1) {
      unsigned int v13 = -3;
    }
    else {
      unsigned int v13 = v11;
    }
    if (v13 == -3) {
      unsigned int v13 = 0;
    }
    if (v15) {
      return v15;
    }
    else {
      return v13;
    }
  }

  return result;
}

uint64_t xmlEncInputChunk(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _DWORD *a5, int a6)
{
  unint64_t v6 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t, _DWORD *))(a1 + 8);
  if (v6)
  {
    int v7 = v6(a2, a3, a4, a5);
    return v7 & (v7 >> 31);
  }

  else
  {
    uint64_t v9 = *(void *)(a1 + 24);
    if (v9)
    {
      return xmlUconvWrapper(v9, 1LL, a2, a3, a4, a5, a6);
    }

    else
    {
      *a3 = 0;
      *a5 = 0;
      return 4294967294LL;
    }
  }

int xmlCharEncFirstLine(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  return xmlCharEncFirstLineInt((uint64_t)handler, out, (uint64_t)in, -1);
}

size_t xmlCharEncFirstLineInput(uint64_t a1, int a2)
{
  *(void *)&len[60] = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(xmlBuf **)(a1 + 32);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(const xmlBuf **)(a1 + 40);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  size_t result = xmlBufUse(*(const xmlBufPtr *)(a1 + 40));
  if (result)
  {
    size_t v7 = result;
    unint64_t v8 = xmlBufAvail((unint64_t)v3);
    if (a2 >= 0) {
      unint64_t v9 = a2;
    }
    else {
      unint64_t v9 = 180LL;
    }
    if (v9 >= v7) {
      unint64_t v10 = v7;
    }
    else {
      unint64_t v10 = v9;
    }
    if (2 * v10 >= v8)
    {
      xmlBufGrow((uint64_t)v3, 2 * v10);
      unint64_t v8 = xmlBufAvail((unint64_t)v3);
    }

    int v11 = 360;
    if (v8 < 0x168) {
      int v11 = v8;
    }
    int v19 = v11;
    *(_DWORD *)unsigned int len = v10;
    uint64_t v12 = *(void *)(a1 + 24);
    unsigned int v13 = xmlBufEnd(v3);
    unsigned int v14 = xmlBufContent(v4);
    int v15 = xmlEncInputChunk(v12, (uint64_t)v13, &v19, (uint64_t)v14, len, 0);
    xmlBufShrink(v4, *(int *)len);
    xmlBufAddLen((uint64x2_t *)v3, v19);
    if (v15 == -1) {
      int v16 = -3;
    }
    else {
      int v16 = v15;
    }
    if (v16 == -2)
    {
      memset(&len[4], 0, 49);
      char v17 = xmlBufContent(v4);
      snprintf(&len[4], 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v17, v17[1], v17[2], v17[3]);
      len[53] = 0;
      __xmlRaiseError( 0,  0,  0,  0,  0,  27,  6003,  3,  0LL,  0,  (uint64_t)&len[4],  0LL,  0LL,  0,  0,  (uint64_t)"input conversion failed due to input error, bytes %s\n");
    }

    if (v16 == -3) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = v16;
    }
    if (v19) {
      return v19;
    }
    else {
      return v18;
    }
  }

  return result;
}

size_t xmlCharEncInput(uint64_t a1, int a2)
{
  *(void *)&len[60] = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(xmlBuf **)(a1 + 32);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(const xmlBuf **)(a1 + 40);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  size_t result = xmlBufUse(*(const xmlBufPtr *)(a1 + 40));
  if (result)
  {
    if (result > 0x10000 && a2 == 0) {
      uint64_t v8 = 0x10000LL;
    }
    else {
      uint64_t v8 = result;
    }
    unint64_t v9 = xmlBufAvail((unint64_t)v3);
    if (2 * v8 >= v9)
    {
      xmlBufGrow((uint64_t)v3, 2 * v8);
      unint64_t v9 = xmlBufAvail((unint64_t)v3);
    }

    if (v9 > 0x20000 && a2 == 0) {
      int v11 = 0x20000;
    }
    else {
      int v11 = v9;
    }
    int v19 = v11;
    *(_DWORD *)unsigned int len = v8;
    uint64_t v12 = *(void *)(a1 + 24);
    unsigned int v13 = xmlBufEnd(v3);
    unsigned int v14 = xmlBufContent(v4);
    int v15 = xmlEncInputChunk(v12, (uint64_t)v13, &v19, (uint64_t)v14, len, a2);
    xmlBufShrink(v4, *(int *)len);
    xmlBufAddLen((uint64x2_t *)v3, v19);
    if (v15 == -1) {
      int v16 = -3;
    }
    else {
      int v16 = v15;
    }
    if (v16 == -2)
    {
      memset(&len[4], 0, 49);
      char v17 = xmlBufContent(v4);
      snprintf(&len[4], 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v17, v17[1], v17[2], v17[3]);
      len[53] = 0;
      __xmlRaiseError( 0,  0,  0,  0,  0,  27,  6003,  3,  0LL,  0,  (uint64_t)&len[4],  0LL,  0LL,  0,  0,  (uint64_t)"input conversion failed due to input error, bytes %s\n");
    }

    if (v16 == -3) {
      int v18 = 0;
    }
    else {
      int v18 = v16;
    }
    if (v18 >= 0) {
      return v19;
    }
    else {
      return v18;
    }
  }

  return result;
}

int xmlCharEncInFunc(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int result = -1;
  if (handler && out && in)
  {
    unsigned int use = in->use;
    unsigned int len = use;
    if (use)
    {
      unsigned int v8 = out->use;
      unsigned int size = out->size;
      int v16 = size + ~v8;
      int v10 = 2 * use;
      if (v10 >= v16)
      {
        xmlBufferGrow(out, size + v10);
        unsigned int v8 = out->use;
        int v16 = out->size + ~v8;
      }

      int v11 = xmlEncInputChunk((uint64_t)handler, (uint64_t)&out->content[v8], &v16, (uint64_t)in->content, &len, 1);
      xmlBufferShrink(in, len);
      unsigned int v12 = out->use + v16;
      out->unsigned int use = v12;
      out->content[v12] = 0;
      if (v11 == -1) {
        int v13 = -3;
      }
      else {
        int v13 = v11;
      }
      if (v13 == -2)
      {
        char v20 = 0;
        __int128 v18 = 0u;
        __int128 v19 = 0u;
        *(_OWORD *)__str = 0u;
        snprintf( __str,  0x31uLL,  "0x%02X 0x%02X 0x%02X 0x%02X",  *in->content,  in->content[1],  in->content[2],  in->content[3]);
        char v21 = 0;
        __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x1Bu,  6003,  3,  0LL,  0,  (const xmlChar *)__str,  0LL,  0LL,  0,  0,  "input conversion failed due to input error, bytes %s\n",  (char)__str);
      }

      if (v13 == -3) {
        int v14 = 0;
      }
      else {
        int v14 = v13;
      }
      if (v16) {
        return v16;
      }
      else {
        return v14;
      }
    }

    else
    {
      return 0;
    }
  }

  return result;
}

uint64_t xmlCharEncOutput(void *a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a1[3]) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = (xmlBuf *)a1[4];
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = (xmlBuf *)a1[5];
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  *(void *)&len[1] = 0LL;
  unint64_t v6 = xmlBufAvail((unint64_t)v4);
  unint64_t v7 = v6;
  if (a2)
  {
    *(void *)&len[1] = v6;
    uint64_t v8 = a1[3];
    unint64_t v9 = xmlBufEnd(v4);
    xmlEncOutputChunk(v8, (uint64_t)v9, &len[1], 0LL, &len[2]);
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    return len[1];
  }

  size_t v12 = xmlBufUse(v3);
  uint64_t v10 = 0LL;
  if (!v12) {
    return v10;
  }
  while (1)
  {
    if (v12 >= 0x10000) {
      uint64_t v13 = 0x10000LL;
    }
    else {
      uint64_t v13 = v12;
    }
    if (4 * v13 >= v7)
    {
      xmlBufGrow((uint64_t)v4, 4 * v13);
      unint64_t v7 = xmlBufAvail((unint64_t)v4);
    }

    unsigned int v14 = v7 >= 0x40000 ? 0x40000 : v7;
    *(void *)&len[1] = __PAIR64__(v13, v14);
    uint64_t v15 = a1[3];
    int v16 = xmlBufEnd(v4);
    char v17 = xmlBufContent(v3);
    unsigned int v18 = xmlEncOutputChunk(v15, (uint64_t)v16, &len[1], (uint64_t)v17, &len[2]);
    xmlBufShrink(v3, len[2]);
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    uint64_t v10 = (len[1] + v10);
    if (v18 == -2) {
      break;
    }
    if (v18 != -1)
    {
      if (v18 == -4)
      {
        __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x1Bu,  6004,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "xmlCharEncOutFunc: no output function !\n",  0);
        unsigned int v18 = -1;
      }

      goto LABEL_33;
    }

    if (len[1] < 1)
    {
      unsigned int v18 = -3;
      goto LABEL_33;
    }

LABEL_26:
    unint64_t v7 = xmlBufAvail((unint64_t)v4);
    size_t v12 = xmlBufUse(v3);
    if (!v12) {
      return v10;
    }
  }

  *(void *)__str = 0LL;
  uint64_t v31 = 0LL;
  int v32 = 0;
  len[0] = 0;
  len[0] = xmlBufUse(v3);
  __int128 v19 = xmlBufContent(v3);
  int UTF8Char = xmlGetUTF8Char(v19, len);
  if (UTF8Char < 1)
  {
    unsigned int v18 = -2;
    goto LABEL_33;
  }

  int v21 = snprintf(__str, 0x14uLL, "&#%d;", UTF8Char);
  xmlBufShrink(v3, len[0]);
  xmlBufGrow((uint64_t)v4, 4 * v21);
  len[1] = xmlBufAvail((unint64_t)v4);
  len[2] = v21;
  uint64_t v22 = a1[3];
  int v23 = xmlBufEnd(v4);
  unsigned int v18 = xmlEncOutputChunk(v22, (uint64_t)v23, &len[1], (uint64_t)__str, &len[2]);
  if ((v18 & 0x80000000) == 0 && len[2] == v21)
  {
    xmlBufAddLen((uint64x2_t *)v4, len[1]);
    uint64_t v10 = (len[1] + v10);
    goto LABEL_26;
  }

  char v28 = 0;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  *(_OWORD *)__int128 v25 = 0u;
  snprintf(v25, 0x31uLL, "0x%02X 0x%02X 0x%02X 0x%02X", *v19, v19[1], v19[2], v19[3]);
  char v29 = 0;
  __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x1Bu,  6003,  3,  0LL,  0,  (const xmlChar *)v25,  0LL,  0LL,  0,  0,  "output conversion failed due to conv error, bytes %s\n",  (char)v25);
LABEL_33:
  if ((_DWORD)v10) {
    return v10;
  }
  else {
    return v18;
  }
}

  *(_DWORD *)(v2 + 408) = 1;
LABEL_27:
  uint64_t v13 = *(void **)(v2 + 56);
  unsigned int v14 = (void *)*v13;
  if (*v13)
  {
    if (v14[3])
    {
      if (v14[5])
      {
        int result = v14[4];
        if (result)
        {
          xmlBufShrink((xmlBufPtr)result, v13[4] - v13[3]);
          uint64_t v15 = xmlCharEncInput(**(void **)(v2 + 56), 1);
          int result = xmlBufResetInput(*(uint64_t **)(**(void **)(v2 + 56) + 32LL), *(void **)(v2 + 56));
          if (v15 < 0) {
            return (uint64_t)htmlParseErr((_DWORD *)v2, 81, "htmlCheckEncoding: encoder error\n", 0LL, 0LL);
          }
        }
      }
    }
  }

  return result;
}

        uint64_t v15 = xmlStrndup(&input->base[v6], v12);
        goto LABEL_27;
      }
    }

    unint64_t v9 = "Unfinished PubidLiteral\n";
    ctxt = v1;
    uint64_t v10 = 44;
    goto LABEL_23;
  }

  return 0LL;
}

  *a3 = 0LL;
  return result;
}

    if ((v13 & 4) != 0)
    {
      __int128 v38 = *__xmlGenericError();
      __int128 v39 = __xmlGenericErrorContext();
      v38( *v39,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/schematron.c",  1383);
      return;
    }

      uint64_t v13 = v12;
LABEL_27:
      LineNoInternal = xmlGetLineNoInternal(v13, v3);
      goto LABEL_28;
    }
  }

  return v2;
}

        __int128 v26 = xmlMalloc(0x78uLL);
        if (!v26)
        {
          xmlXPathObjectPtr v77 = v20;
          __int128 v69 = "xmlDOMWrapCloneNode(): allocating a node";
LABEL_170:
          __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)v69);
          goto LABEL_171;
        }

        __int128 v19 = v26;
        v26[14] = 0LL;
        *((_OWORD *)v26 + 5) = 0u;
        *((_OWORD *)v26 + 6) = 0u;
        *((_OWORD *)v26 + 3) = 0u;
        *((_OWORD *)v26 + 4) = 0u;
        *((_OWORD *)v26 + 1) = 0u;
        *((_OWORD *)v26 + 2) = 0u;
        *(_OWORD *)__int128 v26 = 0u;
        if (!v20) {
          goto LABEL_38;
        }
        __int128 v27 = v75;
        v26[5] = v75;
        if (v18) {
          goto LABEL_29;
        }
        *((void *)v75 + 3) = v26;
        goto LABEL_39;
      }
    }
  }

  return v8;
}

  extSubset = doc->extSubset;
  if (!extSubset) {
    goto LABEL_38;
  }
  int v16 = xmlGetDtdElementDesc(extSubset, attr->elem);
  if (v16 && (char v17 = v16->attributes) != 0LL)
  {
    uint64_t v10 = 0;
    do
    {
      if (v17->atype == XML_ATTRIBUTE_ID) {
        ++v10;
      }
      char v17 = v17->nexth;
    }

    while (v17);
    if (v10 >= 2)
    {
      elem = attr->elem;
      name = (xmlChar *)attr->name;
      unsigned int v14 = "Element %s has %d ID attribute defined in the external subset : %s\n";
      goto LABEL_25;
    }
  }

  else
  {
    uint64_t v10 = 0;
  }

  if (data + v10 >= 2) {
    xmlErrValidNode( (uint64_t *)ctxt,  (int)attr,  514,  (uint64_t)"Element %s has ID attributes defined in the internal and external subset : %s\n",  (uint64_t)attr->elem,  (xmlChar *)attr->name,  0LL);
  }
LABEL_38:
  if (attr->defaultValue)
  {
    tree = attr->tree;
    if (tree)
    {
      while (!xmlStrEqual(tree->name, attr->defaultValue))
      {
        tree = tree->next;
        if (!tree)
        {
          xmlErrValidNode( (uint64_t *)ctxt,  (int)attr,  502,  (uint64_t)"Default value %s for attribute %s of %s is not among the enumerated set\n",  (uint64_t)attr->defaultValue,  (xmlChar *)attr->name,  (xmlChar *)attr->elem);
          return 0;
        }
      }
    }
  }

  return v7;
}

        __int128 v25 = (void *)(v15 + 48);
        while (1)
        {
          __int128 v25 = (void *)*v25;
          if (!v25) {
            break;
          }
          if (v22[1] == v25[1])
          {
            uint64_t v22 = (void *)*v22;
            unint64_t v9 = 1;
            if (v22) {
              goto LABEL_26;
            }
            goto LABEL_83;
          }
        }
      }

      if (v20 && v20 != v21)
      {
        int result = xmlSchemaCloneWildcardNsConstraints(a1, v16, v15);
        if ((_DWORD)result == -1) {
          return result;
        }
        goto LABEL_82;
      }

              xmlXPtrLocationSetAdd(v11, v22);
              if (++v12 >= *user) {
                goto LABEL_70;
              }
            }

            if (*(_DWORD *)v13 == 5)
            {
              int v16 = *(void *)(v13 + 40);
              char v17 = *(_DWORD *)(v13 + 48);
              unsigned int v18 = (xmlNode *)v16;
              __int128 v19 = v17;
              goto LABEL_63;
            }

            char v20 = *__xmlGenericError();
            int v21 = __xmlGenericErrorContext();
            v20( *v21,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xpointer.c",  2105);
LABEL_25:
            uint64_t v22 = 0LL;
            goto LABEL_26;
          }

          xmlXPathFreeObject(v7);
        }

        ctxt = v2;
        __int128 v38 = 15;
        goto LABEL_73;
      }

      __int128 v38 = 23;
    }

    else
    {
      __int128 v38 = 12;
    }

uint64_t xmlEncOutputChunk(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _DWORD *a5)
{
  char v5 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t, _DWORD *))(a1 + 16);
  if (v5)
  {
    int v6 = v5(a2, a3, a4, a5);
    return v6 & (v6 >> 31);
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
      return xmlUconvWrapper(v8, 0LL, a2, a3, a4, a5, 1);
    }

    else
    {
      *a3 = 0;
      *a5 = 0;
      return 4294967292LL;
    }
  }

int xmlCharEncOutFunc(xmlCharEncodingHandler *handler, xmlBufferPtr out, xmlBufferPtr in)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int result = -1;
  if (!handler || !out) {
    return result;
  }
  uint64_t use = out->use;
  int v8 = out->size - use - ((signed int)(out->size - use) > 0);
  signed int v23 = v8;
  if (!in)
  {
    unsigned int len = 0;
    xmlEncOutputChunk((uint64_t)handler, (uint64_t)&out->content[use], &v23, 0LL, &len);
    int result = 0;
    unsigned int v20 = out->use + v23;
    out->uint64_t use = v20;
    out->content[v20] = 0;
    return result;
  }

  unsigned int v9 = in->use;
  unsigned int len = v9;
  if (!v9) {
    return 0;
  }
  int v10 = 0;
  while (1)
  {
    if ((int)(4 * v9) >= v8)
    {
      xmlBufferGrow(out, 4 * v9);
      LODWORD(use) = out->use;
      signed int v23 = out->size + ~(_DWORD)use;
    }

    int v11 = xmlEncOutputChunk( (uint64_t)handler,  (uint64_t)&out->content[use],  &v23,  (uint64_t)in->content,  &len);
    xmlBufferShrink(in, len);
    signed int v12 = v23;
    unsigned int v13 = out->use + v23;
    out->uint64_t use = v13;
    v10 += v12;
    out->content[v13] = 0;
    if (v11 == -2) {
      break;
    }
    if (v11 != -1)
    {
      if (v11 == -4)
      {
        __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x1Bu,  6004,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "xmlCharEncOutFunc: no output function !\n",  0);
        int v11 = -1;
      }

      goto LABEL_24;
    }

    if (v23 < 1)
    {
      int v11 = -3;
      goto LABEL_24;
    }

int xmlCharEncCloseFunc(xmlCharEncodingHandler *handler)
{
  if (!handler) {
    return -1;
  }
  if (!handler->name) {
    return -1;
  }
  uint64_t v2 = (xmlCharEncodingHandler **)handlers;
  if (handlers)
  {
    uint64_t v3 = nbCharEncodingHandler;
    if (nbCharEncodingHandler >= 1)
    {
      while (*v2 != handler)
      {
        ++v2;
        if (!--v3) {
          goto LABEL_7;
        }
      }

      return 0;
    }
  }

uint64_t xmlByteConsumed(xmlParserCtxtPtr ctxt)
{
  uint64_t v1 = ((uint64_t (*)(xmlParserCtxtPtr))MEMORY[0x1895F8858])(ctxt);
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!v1) {
    return -1LL;
  }
  uint64_t v2 = *(void **)(v1 + 56);
  if (!v2) {
    return -1LL;
  }
  uint64_t v3 = *v2;
  if (!*v2) {
    return v2[8] + v2[4] - v2[3];
  }
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4) {
    return v2[8] + v2[4] - v2[3];
  }
  uint64_t v6 = v2[4];
  uint64_t v5 = v2[5];
  int v7 = v5 - v6;
  if (v5 - v6 >= 1)
  {
    bzero(v17, 0x7D00uLL);
    int v15 = 32000;
    int v16 = v7;
    int v8 = 0;
    if ((xmlEncOutputChunk(v4, (uint64_t)v17, &v15, v6, &v16) & 0x80000000) == 0)
    {
LABEL_7:
      unint64_t v9 = (v15 + v8);
      uint64_t v3 = *v2;
      goto LABEL_13;
    }

    while (v15 >= 1)
    {
      v8 += v15;
      v6 += v16;
      int v10 = *((_DWORD *)v2 + 10) - v6;
      int v15 = 32000;
      int v16 = v10;
    }

    return -1LL;
  }

  unint64_t v9 = 0LL;
LABEL_13:
  unint64_t v12 = *(void *)(v3 + 56);
  BOOL v13 = v12 >= v9;
  uint64_t v14 = v12 - v9;
  if (v13) {
    return v14;
  }
  else {
    return -1LL;
  }
}

uint64_t xmlUconvWrapper(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, _DWORD *a6, int a7)
{
  int v15 = a3;
  int v16 = a5;
  if (a4 && (int v8 = a5, a5) && (v9 = a3, a3) && a6)
  {
    linkedOnOrAfterFall2022OSVersions();
    ucnv_convertEx();
    *a6 = v16 - v8;
    *a4 = v15 - v9;
    int v14 = linkedOnOrAfterFall2022OSVersions();
    uint64_t result = 0LL;
    if (a7)
    {
      if (v14)
      {
        uint64_t result = 0LL;
        *(void *)(a1 + 2072) = a1 + 16;
        *(void *)(a1 + 2064) = a1 + 16;
      }
    }
  }

  else
  {
    if (a4) {
      *a4 = 0;
    }
    return 0xFFFFFFFFLL;
  }

  return result;
}

xmlEntityPtr xmlGetPredefinedEntity(xmlEntityPtr name)
{
  if (name)
  {
    uint64_t v1 = (const xmlChar *)name;
    unsigned int private_low = LOBYTE(name->_private);
    if (private_low > 0x6B)
    {
      if (private_low == 113)
      {
        if (xmlStrEqual((const xmlChar *)name, (const xmlChar *)"quot")) {
          return (xmlEntityPtr)&xmlEntityQuot;
        }
      }

      else if (private_low == 108 && xmlStrEqual((const xmlChar *)name, (const xmlChar *)"lt"))
      {
        return (xmlEntityPtr)&xmlEntityLt;
      }
    }

    else if (private_low == 97)
    {
      if (xmlStrEqual((const xmlChar *)name, (const xmlChar *)"amp")) {
        return (xmlEntityPtr)&xmlEntityAmp;
      }
      if (xmlStrEqual(v1, (const xmlChar *)"apos")) {
        return (xmlEntityPtr)&xmlEntityApos;
      }
    }

    else if (private_low == 103 && xmlStrEqual((const xmlChar *)name, (const xmlChar *)"gt"))
    {
      return (xmlEntityPtr)&xmlEntityGt;
    }

    return 0LL;
  }

  return name;
}

xmlEntityPtr xmlAddDtdEntity( xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  if (!doc)
  {
    int v9 = "xmlAddDtdEntity: document is NULL";
    int v10 = 521;
LABEL_9:
    __xmlSimpleError(2, v10, 0, (uint64_t)v9, 0LL);
    return 0LL;
  }

  extSubset = doc->extSubset;
  if (!extSubset)
  {
    int v9 = "xmlAddDtdEntity: document without external subset";
    int v10 = 522;
    goto LABEL_9;
  }

  xmlEntityPtr result = (xmlEntityPtr)xmlAddEntity(&doc->extSubset->_private, (xmlChar *)name, type, ExternalID, SystemID, content);
  if (result)
  {
    result->parent = extSubset;
    result->xmlDocPtr doc = extSubset->doc;
    last = extSubset->last;
    if (last)
    {
      last->next = (_xmlNode *)result;
      result->int prev = last;
    }

    else
    {
      extSubset->children = (_xmlNode *)result;
    }

    extSubset->last = (_xmlNode *)result;
  }

  return result;
}

uint64_t xmlAddEntity( void *a1, xmlChar *name, int a3, const xmlChar *a4, const xmlChar *a5, const xmlChar *a6)
{
  if (!name) {
    return 0LL;
  }
  uint64_t v12 = a1[8];
  if (v12) {
    BOOL v13 = *(xmlDict **)(v12 + 152);
  }
  else {
    BOOL v13 = 0LL;
  }
  if ((a3 - 1) >= 3)
  {
    Dict = (xmlHashTable *)a1[15];
    if (!Dict)
    {
      Dict = xmlHashCreateDict(0, v13);
      a1[15] = Dict;
      if (!Dict) {
        return 0LL;
      }
    }

    goto LABEL_29;
  }

  xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(name);
  if (PredefinedEntity)
  {
    if (a3 == 1 && a6)
    {
      unint64_t v15 = *PredefinedEntity->content;
      int v16 = *a6;
      if (v16 == 38 && a6[1] == 35)
      {
        if (a6[2] == 120)
        {
          strcpy((char *)&v23[4], "00;");
          v23[4] = a0123456789abcd[v15 >> 4];
          v23[5] = a0123456789abcd[v15 & 0xF];
          if (!xmlStrcasecmp(a6 + 3, &v23[4])) {
            goto LABEL_27;
          }
        }

        else
        {
          strcpy((char *)&v23[2], ";");
          unsigned int v19 = (205 * v15) >> 11;
          v23[0] = (v19 - 10 * ((unsigned __int16)(26 * v19) >> 8)) | 0x30;
          v23[1] = (v15 - 10 * v19) | 0x30;
          if (xmlStrEqual(a6 + 2, v23)) {
            goto LABEL_27;
          }
        }
      }
    }

    __xmlSimpleError(2, 104, 0, (uint64_t)"xmlAddEntity: invalid redeclaration of predefined entity", 0LL);
    return 0LL;
  }

LABEL_27:
  Dict = (xmlHashTable *)a1[12];
  if (!Dict)
  {
    Dict = xmlHashCreateDict(0, v13);
    a1[12] = Dict;
    if (!Dict) {
      return 0LL;
    }
  }

  ctxt->options |= 4u;
  result -= 4;
  if ((result & 0x200000) != 0) {
    goto LABEL_28;
  }
LABEL_22:
  if ((result & 0x2000) != 0)
  {
LABEL_23:
    ctxt->options |= 0x2000u;
    result -= 0x2000;
  }

  if ((v2 & 0x80000) != 0) {
    unsigned int v17 = 10000000;
  }
  else {
    unsigned int v17 = 50000;
  }
  if (!*(_DWORD *)(a1 + 452) && (uint64_t)(v5 - (void)v6) <= 249)
  {
    xmlGROW(a1);
    uint64_t v4 = *(void **)(a1 + 56);
    uint64_t v6 = (const xmlChar *)v4[4];
  }

  unsigned int len = 0;
  uint64_t v18 = v4[3];
  unsigned int v19 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
  unsigned int v20 = v19;
  if (v19 <= 0x3E && ((1LL << v19) & 0x4000800100000000LL) != 0) {
    return 0LL;
  }
  xmlIsNameStartChar(a1, v19);
  uint64_t v22 = v21;
  xmlEntityPtr result = 0LL;
  if (v20 != 58 && v22)
  {
    signed int v23 = 0;
    uint64_t v24 = 0;
    __int128 v25 = &v6[-v18];
    while (v20 > 0x3E || ((1LL << v20) & 0x4000800100000000LL) == 0)
    {
      xmlIsNameChar(a1, v20);
      if (v20 == 58 || !v26) {
        break;
      }
      if (v24 < 101)
      {
        ++v24;
      }

      else
      {
        if (!*(_DWORD *)(a1 + 452)
          && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
        {
          xmlGROW(a1);
        }

        if (*(_DWORD *)(a1 + 272) == -1) {
          return 0LL;
        }
        uint64_t v24 = 0;
      }

      if (v23 <= (len ^ 0x7FFFFFFF)) {
        char v27 = len;
      }
      else {
        char v27 = 0;
      }
      char v28 = *(void *)(a1 + 56);
      char v29 = *(_BYTE **)(v28 + 32);
      uint64_t v30 = &v29[len];
      if ((unint64_t)v30 <= *(void *)(v28 + 40))
      {
        if (*v29 == 10)
        {
          ++*(_DWORD *)(v28 + 52);
          *(_DWORD *)(v28 + 56) = 1;
        }

        else
        {
          ++*(_DWORD *)(v28 + 56);
        }

        *(void *)(v28 + 32) = v30;
      }

      v23 += v27;
      unsigned int v20 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
      if (!v20)
      {
        if (*(_DWORD *)(a1 + 272) == -1) {
          return 0LL;
        }
        int v31 = len;
        uint64_t v32 = *(void *)(a1 + 56);
        uint64_t v33 = *(void *)(v32 + 32) - len;
        *(void *)(v32 + 32) = v33;
        if (!*(_DWORD *)(a1 + 452) && *(void *)(v32 + 40) - v33 <= 249)
        {
          xmlGROW(a1);
          if (*(_DWORD *)(a1 + 272) == -1) {
            return 0LL;
          }
          int v31 = len;
          uint64_t v32 = *(void *)(a1 + 56);
          uint64_t v33 = *(void *)(v32 + 32);
        }

        *(void *)(v32 + 32) = v33 + v31;
        unsigned int v20 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len);
        uint64_t v24 = 0;
      }
    }

    if (v23 <= v17) {
      return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), &v25[*(void *)(*(void *)(a1 + 56) + 24LL)], v23);
    }
LABEL_65:
    xmlFatalErr((_DWORD *)a1, 110, (uint64_t)"NCName");
    return 0LL;
  }

  return result;
}

  *(void *)(a1 + 320) = 0LL;
  return (v15 + *(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 32));
}

    bzero(__str, 0x3E8uLL);
    if (v12 == v15) {
      return;
    }
    goto LABEL_28;
  }

  int v14 = (_BYTE *)(a1 + 4);
  BOOL v13 = *(_DWORD *)(a1 + 4);
  ++*(_DWORD *)(a1 + 16);
  if ((v13 & 5) != 1)
  {
    uint64_t v12 = 1;
    unint64_t v15 = 2;
    goto LABEL_26;
  }

  bzero(__str, 0x3E8uLL);
LABEL_28:
  LineNo = xmlGetLineNo(a4);
  NodePath = xmlGetNodePath(a4);
  if (!NodePath) {
    NodePath = (xmlChar *)a4->name;
  }
  uint64_t v21 = *(void *)(a2 + 16);
  if (!v21 || (uint64_t v22 = *(void *)(v21 + 24)) == 0)
  {
LABEL_72:
    if (*(_DWORD *)(a2 + 8) == 1) {
      __int128 v40 = "node failed assert";
    }
    else {
      __int128 v40 = "node failed report";
    }
    signed int v23 = xmlStrdup((const xmlChar *)v40);
    goto LABEL_76;
  }

  signed int v23 = 0LL;
  do
  {
    uint64_t v24 = *(_DWORD *)(v22 + 8);
    if (v24 == 1)
    {
      if (!*(void *)(v22 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v22 + 16), (const xmlChar *)"name")
        || !xmlStrEqual( *(const xmlChar **)(*(void *)(v22 + 72) + 16LL),  (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
        && !xmlStrEqual( *(const xmlChar **)(*(void *)(v22 + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
      {
        goto LABEL_40;
      }

      int v46 = a5;
      NoNsProp = xmlGetNoNsProp((const xmlNode *)v22, (const xmlChar *)"path");
      char v27 = a4;
      if (NoNsProp)
      {
        char v28 = *(xmlXPathContext **)(a1 + 32);
        v28->xmlDocPtr doc = a4->doc;
        v28->node = (xmlNodePtr)a4;
        __int128 v45 = NoNsProp;
        char v29 = xmlXPathEval(NoNsProp, v28);
        if (v29)
        {
          if (v29->type == XPATH_NODESET && (xmlNodeSetPtr nodesetval = v29->nodesetval) != 0LL && nodesetval->nodeNr >= 1) {
            char v27 = *nodesetval->nodeTab;
          }
          else {
            char v27 = 0LL;
          }
          xmlXPathFreeObject(v29);
        }

        else
        {
          char v27 = 0LL;
        }

        if (!v27) {
          char v27 = a4;
        }
        xmlFree(v45);
      }

      ns = v27->ns;
      if (ns)
      {
        prefix = ns->prefix;
        if (prefix)
        {
          uint64_t v33 = xmlStrcat(v23, prefix);
          signed int v23 = xmlStrcat(v33, (const xmlChar *)":");
        }
      }

      p_name = &v27->name;
      a5 = v46;
    }

    else
    {
      p_name = (const xmlChar **)(v22 + 80);
    }

    __int128 v34 = xmlStrcat(v23, *p_name);
    signed int v23 = v34;
    if (v34)
    {
      __int128 v35 = xmlStrlen(v34);
      if (v35 >= 1)
      {
        __int128 v36 = v23[v35 - 1];
        if (v36 <= 0x20 && ((1LL << v36) & 0x100002600LL) != 0)
        {
          while (v36 <= 0x20u && ((1LL << v36) & 0x100002600LL) != 0)
          {
            if (v35 == 1)
            {
              __int128 v35 = 0;
              break;
            }

            LOBYTE(v36) = v23[v35 - 2];
            --v35;
          }

          v23[v35] = 32;
          v23[v35 + 1] = 0;
        }
      }
    }

          BOOL v13 = *(void *)(v13 + 40);
        }

        while (v13 && *(void *)(v13 + 64) != v13);
      }
    }
  }

  xmlEntityPtr result = xmlNewNs(0LL, href, (const xmlChar *)v10);
  if (result)
  {
    unsigned int v19 = *v9;
    if (*v9)
    {
      do
      {
        int v9 = (xmlNsPtr *)v19;
        unsigned int v19 = (void *)*v19;
      }

      while (v19);
    }

    *int v9 = result;
  }

  return result;
}

    xmlFree(v10);
    goto LABEL_28;
  }

  uint64_t v12 = v11;
  BOOL v13 = (xmlOutputBuffer *)xmlAllocOutputBufferInternal((uint64_t)encoder);
  int v14 = v13;
  if (v13)
  {
    v13->context = v12;
    v13->writecallbacuint64_t k = (xmlOutputWriteCallback)xmlGzfileWrite;
    v13->closecallbacuint64_t k = (xmlOutputCloseCallback)xmlGzfileClose;
  }

  xmlFree(v10);
  return v14;
}

      *((_DWORD *)reader + 6) = v3;
    }
  }

  uint64_t v5 = *((void *)reader + 4);
  if (!v5) {
    return -1;
  }
  if (!*(_DWORD *)reader)
  {
    *(_DWORD *)reader = 1;
    while (1)
    {
      unint64_t v15 = *((void *)reader + 4);
      if (*(void *)(v15 + 80)) {
        break;
      }
      if (*(_DWORD *)reader == 3 || *((_DWORD *)reader + 6) == 5)
      {
        int v16 = *(void *)(v15 + 16);
        if (v16)
        {
          unsigned int v17 = *(void *)(v16 + 24);
          *((void *)reader + 14) = v17;
        }

        else
        {
          unsigned int v17 = *((void *)reader + 14);
        }

        if (!v17)
        {
LABEL_43:
          *(_DWORD *)reader = 2;
          *((_DWORD *)reader + 6) = 6;
          return -1;
        }

    int v14 = v21 - v12;
LABEL_28:
    a4 = v44;
LABEL_29:
    BOOL v13 = v43;
    goto LABEL_30;
  }

  __int128 v26 = *(void *)(a1 + 8 * v16);
  char v27 = a2 - 1;
  char v28 = *(void *)(a1 + 8 * (a2 - 1));
  char v29 = xmlXPathCmpNodesExt(v26, v28);
  int v14 = 2LL;
  if (v29 == -2) {
    goto LABEL_28;
  }
  BOOL v13 = v43;
  a4 = v44;
  if (v29 < 0)
  {
    *(void *)(a1 + 8 * v16) = v28;
    *(void *)(a1 + 8 * v27) = v26;
    int v14 = 2LL;
  }

    unint64_t v15 = 0LL;
LABEL_28:
    xmlXPathReleaseObject((uint64_t)v2->context, v15);
    xmlXPathReleaseObject((uint64_t)v2->context, v9);
    goto LABEL_29;
  }

    unint64_t v15 = 0LL;
LABEL_28:
    xmlXPathReleaseObject((uint64_t)v2->context, v15);
    xmlXPathReleaseObject((uint64_t)v2->context, v9);
    goto LABEL_29;
  }

  uint64_t v5 = (unsigned __int8 *)(i - 1);
  if (v4 - 48 < 0xA) {
    goto LABEL_7;
  }
  switch(*(i - 1))
  {
    case '\'':
      goto LABEL_7;
    case '(':
    case ')':
    case '+':
    case ',':
    case '-':
      goto LABEL_68;
    case '*':
    case '/':
      goto LABEL_71;
    case '.':
      goto LABEL_30;
    default:
      if (v4 == 64) {
        goto LABEL_71;
      }
      if (v4 == 34) {
        goto LABEL_7;
      }
LABEL_68:
      while (v4 <= 0x20 && ((1LL << v4) & 0x100002600LL) != 0)
      {
        a1->cur = i;
        __int128 v36 = *i++;
        uint64_t v4 = v36;
        LODWORD(v2) = (_DWORD)v2 + 1;
      }

      LODWORD(v126) = 0;
      __int128 v72 = xmlXPathCurrentChar(a1, &v126);
      __int128 v73 = v72;
      if (v72 <= 0x3E && ((1LL << v72) & 0x4000800100000000LL) != 0) {
        goto LABEL_162;
      }
      if (v72 > 0xFF)
      {
        if (!xmlCharInRange(v72, &xmlIsBaseCharGroup) && v73 != 12295 && v73 - 19968 >= 0x51A6 && v73 - 12321 >= 9) {
          goto LABEL_162;
        }
      }

      else if ((v72 & 0x1FFFDF) - 65 >= 0x1A {
             && v72 - 192 >= 0x17
      }
             && v72 <= 0xF7
             && v72 - 216 >= 0x1F
             && v72 != 95
             && v72 != 58)
      {
        goto LABEL_162;
      }

      cur = (xmlChar *)(i - 1);
      break;
  }

  while (v73 > 0x3E || ((1LL << v73) & 0x4000800100000000LL) == 0)
  {
    if (v73 > 0xFF)
    {
      if (xmlCharInRange(v73, &xmlIsBaseCharGroup)) {
        v104 = 1;
      }
      else {
        v104 = v73 == 12295;
      }
      xmlXPathObjectPtr v106 = !v104 && v73 - 19968 >= 0x51A6 && v73 - 12321 >= 9;
      if (!v106 || xmlCharInRange(v73, &xmlIsDigitGroup)) {
        goto LABEL_260;
      }
    }

    else if ((v73 & 0x1FFFDF) - 65 < 0x1A || v73 - 192 < 0x17 || v73 > 0xF7 || v73 - 216 < 0x1F || v73 - 48 < 0xA)
    {
      goto LABEL_260;
    }

    if (v73 - 45 > 0x32 || ((1LL << (v73 - 45)) & 0x4000000002003LL) == 0)
    {
      if (v73 >= 0x100)
      {
        if (xmlCharInRange(v73, &xmlIsCombiningGroup)) {
          goto LABEL_260;
        }
        v107 = xmlCharInRange(v73, &xmlIsExtenderGroup);
      }

      else
      {
        v107 = v73 == 183;
      }

      if (!v107) {
        break;
      }
    }

xmlEntityPtr xmlAddDocEntity( xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  if (!doc)
  {
    int v9 = "xmlAddDocEntity: document is NULL";
    int v10 = 521;
LABEL_9:
    __xmlSimpleError(2, v10, 0, (uint64_t)v9, 0LL);
    return 0LL;
  }

  intSubset = doc->intSubset;
  if (!intSubset)
  {
    int v9 = "xmlAddDocEntity: document without internal subset";
    int v10 = 522;
    goto LABEL_9;
  }

  xmlEntityPtr result = (xmlEntityPtr)xmlAddEntity(&doc->intSubset->_private, (xmlChar *)name, type, ExternalID, SystemID, content);
  if (result)
  {
    result->parent = intSubset;
    result->xmlDocPtr doc = intSubset->doc;
    last = intSubset->last;
    if (last)
    {
      last->next = (_xmlNode *)result;
      result->int prev = last;
    }

    else
    {
      intSubset->children = (_xmlNode *)result;
    }

    intSubset->last = (_xmlNode *)result;
  }

  return result;
}

xmlEntityPtr xmlNewEntity( xmlDocPtr doc, const xmlChar *name, int type, const xmlChar *ExternalID, const xmlChar *SystemID, const xmlChar *content)
{
  uint64_t v6 = doc;
  if (doc)
  {
    xmlDocPtr doc = (xmlDocPtr)doc->dict;
  }

  xmlEntityPtr result = (xmlEntityPtr)xmlCreateEntity((xmlDict *)doc, name, type, ExternalID, SystemID, content);
  if (result) {
    result->xmlDocPtr doc = v6;
  }
  return result;
}

void *xmlCreateEntity( xmlDict *a1, const xmlChar *a2, int a3, const xmlChar *a4, const xmlChar *a5, const xmlChar *a6)
{
  uint64_t v12 = xmlMalloc(0x88uLL);
  BOOL v13 = v12;
  if (!v12)
  {
    __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"xmlCreateEntity: malloc failed");
    return v13;
  }

  v12[16] = 0LL;
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  *((_OWORD *)v12 + 1) = 0u;
  *((_DWORD *)v12 + 2) = 17;
  *((_DWORD *)v12 + 33) = 0;
  *((_DWORD *)v12 + 23) = a3;
  if (a1)
  {
    v12[2] = xmlDictLookup(a1, a2, -1);
    v13[12] = xmlStrdup(a4);
  }

  else
  {
    v12[2] = xmlStrdup(a2);
    if (a4) {
      v13[12] = xmlStrdup(a4);
    }
    if (!a5) {
      goto LABEL_9;
    }
  }

  v13[13] = xmlStrdup(a5);
LABEL_9:
  if (a6)
  {
    int v14 = xmlStrlen(a6);
    *((_DWORD *)v13 + 22) = v14;
    unint64_t v15 = xmlStrndup(a6, v14);
  }

  else
  {
    unint64_t v15 = 0LL;
    *((_DWORD *)v13 + 22) = 0;
  }

  v13[15] = 0LL;
  v13[9] = 0LL;
  v13[10] = v15;
  *((_DWORD *)v13 + 32) = 0;
  return v13;
}

xmlEntityPtr xmlGetParameterEntity(xmlEntityPtr doc, const xmlChar *name)
{
  if (doc)
  {
    xmlEntityPtr v3 = doc;
    content = doc->content;
    if (!content
      || (uint64_t v5 = (xmlHashTable *)*((void *)content + 15)) == 0LL
      || (xmlDocPtr doc = (xmlEntityPtr)xmlHashLookup(v5, name)) == 0LL)
    {
      uint64_t v6 = *(void *)&v3->length;
      if (v6)
      {
        xmlDocPtr doc = *(xmlEntityPtr *)(v6 + 120);
        if (doc) {
          return (xmlEntityPtr)xmlHashLookup((xmlHashTablePtr)doc, name);
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  return doc;
}

xmlEntityPtr xmlGetDtdEntity(xmlDocPtr doc, const xmlChar *name)
{
  if (doc && (extSubset = doc->extSubset) != 0LL && (entities = (xmlHashTable *)extSubset->entities) != 0LL) {
    return (xmlEntityPtr)xmlHashLookup(entities, name);
  }
  else {
    return 0LL;
  }
}

xmlEntityPtr xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name)
{
  if (!doc) {
    return xmlGetPredefinedEntity(name);
  }
  intSubset = doc->intSubset;
  if (!intSubset
    || (uint64_t v5 = (xmlHashTable *)intSubset->entities) == 0LL
    || (xmlEntityPtr result = (xmlEntityPtr)xmlHashLookup(v5, name)) == 0LL)
  {
    if (doc->standalone == 1) {
      return xmlGetPredefinedEntity(name);
    }
    extSubset = doc->extSubset;
    if (!extSubset) {
      return xmlGetPredefinedEntity(name);
    }
    entities = (xmlHashTable *)extSubset->entities;
    if (!entities) {
      return xmlGetPredefinedEntity(name);
    }
    xmlEntityPtr result = (xmlEntityPtr)xmlHashLookup(entities, name);
    if (!result) {
      return xmlGetPredefinedEntity(name);
    }
  }

  return result;
}

char *xmlEncodeAttributeEntities(uint64_t a1, unsigned __int8 *a2)
{
  return xmlEncodeEntitiesInternal(a1, a2, 1);
}

char *xmlEncodeEntitiesInternal(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = a2;
  if (a1) {
    BOOL v6 = *(_DWORD *)(a1 + 8) == 13;
  }
  else {
    BOOL v6 = 0;
  }
  int v7 = (char *)xmlMalloc(0x3E8uLL);
  if (!v7)
  {
    __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"xmlEncodeEntities: malloc failed");
    return 0LL;
  }

  int v8 = v7;
  unsigned int v9 = *v4;
  if (*v4)
  {
    if (a3) {
      BOOL v10 = !v6;
    }
    else {
      BOOL v10 = 1;
    }
    int v11 = !v10;
    size_t v12 = 1000LL;
    BOOL v13 = v7;
    while (1)
    {
      if (v8 - v13 + 100 > v12)
      {
        if ((v12 & 0x8000000000000000LL) != 0 || (v12 *= 2LL, (int v14 = (char *)xmlRealloc(v13, v12)) == 0LL))
        {
LABEL_111:
          __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"xmlEncodeEntities: realloc failed");
          xmlFree(v13);
          return 0LL;
        }

        int v8 = &v14[v8 - v13];
        unsigned int v9 = *v4;
        BOOL v13 = v14;
      }

      if (v9 == 38)
      {
        if (v11 && v4[1] == 123 && strchr((const char *)v4, 125))
        {
          ++v4;
          char v20 = 38;
          do
          {
            *v8++ = v20;
            if (v8 - v13 + 100 > v12)
            {
              if ((v12 & 0x8000000000000000LL) != 0) {
                goto LABEL_111;
              }
              v12 *= 2LL;
              uint64_t v21 = (char *)xmlRealloc(v13, v12);
              if (!v21) {
                goto LABEL_111;
              }
              int v8 = &v21[v8 - v13];
              BOOL v13 = v21;
            }

            int v22 = *v4++;
            char v20 = v22;
          }

          while (v22 != 125);
          *v8++ = v20;
          goto LABEL_79;
        }

        *(_DWORD *)int v8 = 1886216486;
        v8[4] = 59;
        v8 += 5;
        goto LABEL_78;
      }

      if (v9 == 62) {
        break;
      }
      if (v9 == 60)
      {
        if (v11)
        {
          if (v4[1] == 33 && v4[2] == 45 && v4[3] == 45)
          {
            unint64_t v15 = xmlStrstr(v4, (const xmlChar *)"-->");
            if (v15)
            {
              int v16 = (unsigned __int8 *)v15;
              if (v4 != v15)
              {
                do
                {
                  char v17 = *v4++;
                  *v8++ = v17;
                  if (v8 - v13 + 100 > v12)
                  {
                    if ((v12 & 0x8000000000000000LL) != 0) {
                      goto LABEL_111;
                    }
                    v12 *= 2LL;
                    uint64_t v18 = (char *)xmlRealloc(v13, v12);
                    if (!v18) {
                      goto LABEL_111;
                    }
                    int v8 = &v18[v8 - v13];
                    BOOL v13 = v18;
                  }
                }

                while (v4 != v16);
                uint64_t v4 = v16;
              }

              *int v8 = *v4;
              v8[1] = v4[1];
              unsigned __int8 v19 = v4[2];
              v4 += 3;
              v8[2] = v19;
              v8 += 3;
              goto LABEL_79;
            }
          }
        }

        int v23 = 997485606;
        goto LABEL_62;
      }

      int v25 = v6 && v9 == 13;
      if ((char)v9 <= 31 && v9 - 9 >= 2 && !v25)
      {
        if ((v9 & 0x80) == 0)
        {
          if (v9 <= 0xD && ((1 << v9) & 0x2600) != 0)
          {
            memset(__str, 0, 11);
            snprintf(__str, 0xBuLL, "&#%d;", *v4);
            __str[10] = 0;
            char v26 = __str[0];
            if (__str[0])
            {
              char v27 = &__str[1];
              do
              {
                *v8++ = v26;
                int v28 = *v27++;
                char v26 = v28;
              }

              while (v28);
            }
          }

          goto LABEL_78;
        }

        if (a1)
        {
          if (!v6 && !*(void *)(a1 + 112))
          {
LABEL_67:
            memset(__str, 0, 11);
            unsigned int v29 = *v4;
            if ((~v29 & 0xC0) == 0)
            {
              int v31 = v4 + 1;
              unsigned __int8 v30 = v4[1];
              if ((v30 & 0xC0) == 0x80 && ((~v29 & 0xE0) != 0 || (v4[2] & 0xC0) == 0x80))
              {
                if (v29 < 0xF0)
                {
                  if ((~v29 & 0xF8) != 0)
                  {
                    __int16 v38 = (_WORD)v29 << 6;
                    int v39 = v30 & 0x3F;
                    if (v29 > 0xDF)
                    {
                      unsigned int v33 = v4[2] & 0x3F | ((v38 & 0x3C0 | v39) << 6);
                      uint64_t v34 = 3LL;
                    }

                    else
                    {
                      unsigned int v33 = v38 & 0x7C0 | v39;
                      uint64_t v34 = 2LL;
                    }

LABEL_92:
                    if (v33 > 0xFF)
                    {
                      if (v33 >> 11 >= 0x1B && (v33 - 57344) >> 1 >= 0xFFF && v33 - 0x10000 >= 0x100000) {
                        goto LABEL_100;
                      }
                    }

                    else if (v33 <= 0x1F && (v33 > 0xD || ((1 << v33) & 0x2600) == 0))
                    {
                      goto LABEL_100;
                    }

                    snprintf(__str, 0xBuLL, "&#x%X;", v33);
                    __str[10] = 0;
                    char v43 = __str[0];
                    if (__str[0])
                    {
                      __int128 v44 = &__str[1];
                      do
                      {
                        *v8++ = v43;
                        int v45 = *v44++;
                        char v43 = v45;
                      }

                      while (v45);
                    }

                    int v31 = &v4[v34];
LABEL_88:
                    uint64_t v4 = v31;
                    goto LABEL_79;
                  }
                }

                else if ((~v29 & 0xF8) != 0)
                {
                  unsigned __int8 v32 = v4[3];
                  if ((v32 & 0xC0) == 0x80)
                  {
                    if (v29 <= 0xF7)
                    {
                      unsigned int v33 = ((v30 & 0x3F | ((v29 & 7) << 6)) << 12) | ((v4[2] & 0x3F) << 6) | v32 & 0x3F;
                      uint64_t v34 = 4LL;
                      goto LABEL_92;
                    }

  if (*(_DWORD *)(v15 + 8) != 1
    || !*(void *)(v15 + 72)
    || !xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"pattern")
    || !xmlStrEqual( *(const xmlChar **)(*(void *)(v15 + 72) + 16LL),  (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
    && !xmlStrEqual( *(const xmlChar **)(*(void *)(v15 + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr( (uint64_t)ctxt,  v15,  1759,  "Expecting a pattern element instead of %s",  *(const xmlChar **)(v15 + 16));
    goto LABEL_112;
  }

  char v35 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"id");
  if (!v35) {
    char v35 = xmlGetNoNsProp((const xmlNode *)v15, (const xmlChar *)"name");
  }
  if (!v35 || (__int128 v36 = *((void *)ctxt + 9)) == 0)
  {
    if (!v35) {
      goto LABEL_122;
    }
    goto LABEL_121;
  }

  int v37 = xmlMalloc(0x18uLL);
  if (!v37)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(16, 2, v15, 0LL, (uint64_t)"allocating schema pattern");
LABEL_121:
    xmlFree(v35);
    goto LABEL_122;
  }

  __int16 v38 = v37;
  v37[1] = 0LL;
  v37[2] = 0LL;
  void *v37 = 0LL;
  v37[2] = v35;
  __int128 v41 = *(void **)(v36 + 64);
  char v40 = (void *)(v36 + 64);
  for (uint64_t i = v41; i; uint64_t i = (void *)*i)
    char v40 = i;
  xmlRelaxNG *v40 = v37;
  uint64_t k = *(void *)(v15 + 24);
  if (!k) {
    goto LABEL_110;
  }
  while (1)
  {
    if (*(_DWORD *)(k + 8) == 1)
    {
      char v43 = *(void *)(k + 72);
      if (v43)
      {
        if (xmlStrEqual(*(const xmlChar **)(v43 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual( *(const xmlChar **)(*(void *)(k + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }

    uint64_t k = *(void *)(k + 48);
    if (!k) {
      goto LABEL_110;
    }
  }

  __int128 v76 = 0;
  __int128 v75 = v38 + 1;
LABEL_124:
  if (*(_DWORD *)(k + 8) != 1
    || !*(void *)(k + 72)
    || !xmlStrEqual(*(const xmlChar **)(k + 16), (const xmlChar *)"rule")
    || !xmlStrEqual( *(const xmlChar **)(*(void *)(k + 72) + 16LL),  (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
    && !xmlStrEqual( *(const xmlChar **)(*(void *)(k + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
  {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "Expecting a rule element instead of %s", *(const xmlChar **)(k + 16));
    goto LABEL_149;
  }

  int v45 = xmlGetNoNsProp((const xmlNode *)k, (const xmlChar *)"context");
  if (!v45)
  {
    xmlGenericErrorFunc v56 = ctxt;
    xmlListPtr v57 = k;
    v58 = "rule has no context attribute";
    goto LABEL_157;
  }

  int v46 = v45;
  if (!*v45)
  {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "rule has an empty context attribute", 0LL);
LABEL_160:
    xmlFree(v46);
    goto LABEL_161;
  }

  uint64_t v47 = *((void *)ctxt + 9);
  if (!v47) {
    goto LABEL_160;
  }
  __int128 v72 = xmlPatterncompile(v45, *((xmlDict **)ctxt + 6), 1, *((const xmlChar ***)ctxt + 11));
  if (!v72) {
    xmlSchematronPErr((uint64_t)ctxt, k, 1759, "Failed to compile context expression %s", v46);
  }
  BOOL v74 = xmlMalloc(0x38uLL);
  if (!v74)
  {
    ++*((_DWORD *)ctxt + 14);
    __xmlSimpleError(16, 2, k, 0LL, (uint64_t)"allocating schema rule");
    goto LABEL_160;
  }

  v74[1] = 0u;
  v74[2] = 0u;
  *BOOL v74 = 0u;
  *((void *)v74 + 2) = k;
  *((void *)v74 + 3) = v46;
  *((void *)v74 + 5) = v72;
  *((void *)v74 + 6) = 0LL;
  *(void *)BOOL v74 = 0LL;
  int v50 = *(void **)(v47 + 72);
  uint64_t v49 = (void *)(v47 + 72);
  for (uint64_t j = v50; j; uint64_t j = (void *)*j)
    uint64_t v49 = j;
  uint64_t v51 = v75;
  *uint64_t v49 = v74;
  *((void *)v74 + 1) = 0LL;
  uint64_t v52 = *v75;
  if (*v75)
  {
    do
    {
      xmlGenericErrorFunc v53 = v52;
      uint64_t v52 = *(void *)(v52 + 8);
    }

    while (v52);
    uint64_t v51 = (void *)(v53 + 8);
  }

  *uint64_t v51 = v74;
  if (!*(void *)(k + 24))
  {
LABEL_147:
    xmlGenericErrorFunc v56 = ctxt;
    xmlListPtr v57 = k;
    v58 = "rule has no assert nor report element";
LABEL_157:
    xmlSchematronPErr((uint64_t)v56, v57, 1759, v58, 0LL);
    goto LABEL_161;
  }

  int v54 = *(void *)(k + 24);
  while (1)
  {
    if (*(_DWORD *)(v54 + 8) == 1)
    {
      v55 = *(void *)(v54 + 72);
      if (v55)
      {
        if (xmlStrEqual(*(const xmlChar **)(v55 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
          || xmlStrEqual( *(const xmlChar **)(*(void *)(v54 + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
        {
          break;
        }
      }
    }

    int v54 = *(void *)(v54 + 48);
    if (!v54) {
      goto LABEL_147;
    }
  }

  __int128 v73 = 0;
  while (1)
  {
    if (*(_DWORD *)(v54 + 8) != 1)
    {
LABEL_181:
      xmlXPathObjectPtr v66 = v54;
      xmlAttrPtr v67 = *(const xmlChar **)(v54 + 16);
      uint64_t v68 = ctxt;
      __int128 v69 = "Expecting an assert or a report element instead of %s";
LABEL_182:
      xmlSchematronPErr((uint64_t)v68, v66, 1759, v69, v67);
      goto LABEL_183;
    }

    if (*(void *)(v54 + 72)
      && xmlStrEqual(*(const xmlChar **)(v54 + 16), (const xmlChar *)"assert")
      && (xmlStrEqual( *(const xmlChar **)(*(void *)(v54 + 72) + 16LL),  (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
       || xmlStrEqual( *(const xmlChar **)(*(void *)(v54 + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron")))
    {
      ++v73;
      v60 = xmlGetNoNsProp((const xmlNode *)v54, (const xmlChar *)"test");
      if (!v60) {
        goto LABEL_191;
      }
      uint64_t v61 = v60;
      if (*v60)
      {
        __int128 v71 = v54;
        uint64_t v62 = xmlNodeGetContent((const xmlNode *)v54);
        int v63 = ctxt;
        uint64_t v64 = 1;
        goto LABEL_179;
      }
    }

    else
    {
      if (*(_DWORD *)(v54 + 8) != 1
        || !*(void *)(v54 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v54 + 16), (const xmlChar *)"report")
        || !xmlStrEqual( *(const xmlChar **)(*(void *)(v54 + 72) + 16LL),  (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
        && !xmlStrEqual( *(const xmlChar **)(*(void *)(v54 + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
      {
        goto LABEL_181;
      }

      ++v73;
      v65 = xmlGetNoNsProp((const xmlNode *)v54, (const xmlChar *)"test");
      if (!v65)
      {
LABEL_191:
        uint64_t v68 = ctxt;
        xmlXPathObjectPtr v66 = v54;
        __int128 v69 = "assert has no test attribute";
        xmlAttrPtr v67 = 0LL;
        goto LABEL_182;
      }

      uint64_t v61 = v65;
      if (*v65)
      {
        __int128 v71 = v54;
        uint64_t v62 = xmlNodeGetContent((const xmlNode *)v54);
        int v63 = ctxt;
        uint64_t v64 = 2;
LABEL_179:
        goto LABEL_193;
      }
    }

    xmlSchematronPErr((uint64_t)ctxt, v54, 1759, "assert has an empty test attribute", 0LL);
LABEL_193:
    xmlFree(v61);
LABEL_183:
    if (!*(void *)(v54 + 48)) {
      break;
    }
    int v54 = *(void *)(v54 + 48);
    while (1)
    {
      if (*(_DWORD *)(v54 + 8) == 1)
      {
        __int128 v70 = *(void *)(v54 + 72);
        if (v70)
        {
          if (xmlStrEqual(*(const xmlChar **)(v70 + 16), (const xmlChar *)"http://purl.oclc.org/dsdl/schematron")
            || xmlStrEqual( *(const xmlChar **)(*(void *)(v54 + 72) + 16LL),  (const xmlChar *)"http://www.ascc.net/xml/schematron"))
          {
            break;
          }
        }
      }

      int v54 = *(void *)(v54 + 48);
      if (!v54) {
        goto LABEL_194;
      }
    }
  }

        __int16 v38 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)v24, (xmlChar *)"id");
        if (v38) {
          xmlSchemaPValAttrNodeID(a1, v38);
        }
        if (xmlGetBooleanProp(a1, v24, (xmlChar *)"mixed"))
        {
          int v39 = *(_DWORD *)(v35 + 88);
          if ((v39 & 1) == 0) {
            *(_DWORD *)(v35 + 88) = v39 | 1;
          }
        }

        char v40 = (uint64_t)v24->children;
        if (!v40
          || *(void *)(v40 + 72)
          && xmlStrEqual(*(const xmlChar **)(v40 + 16), (const xmlChar *)"annotation")
          && xmlStrEqual( *(const xmlChar **)(*(void *)(v40 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
          && (__int128 v41 = xmlSchemaParseAnnotation((_DWORD *)a1, v40, 1),
              xmlSchemaAddAnnotation(v35, (uint64_t)v41),
              (char v40 = *(void *)(v40 + 48)) == 0))
        {
          xmlSchemaPContentErr(a1, 3034, (uint64_t)v24, 0LL, 0LL, (xmlChar *)"(annotation?, (restriction | extension))");
          xmlSchemaPContentErr(a1, 3034, (uint64_t)v24, 0LL, 0LL, (xmlChar *)"(annotation?, (restriction | extension))");
          uint64_t v48 = 0;
          goto LABEL_162;
        }

        if (!*(void *)(v40 + 72)) {
          goto LABEL_160;
        }
        if (xmlStrEqual(*(const xmlChar **)(v40 + 16), (const xmlChar *)"restriction")
          && xmlStrEqual( *(const xmlChar **)(*(void *)(v40 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          xmlSchemaParseRestriction(a1, a2, v40, 10);
          goto LABEL_158;
        }

        if (*(void *)(v40 + 72)
          && xmlStrEqual(*(const xmlChar **)(v40 + 16), (const xmlChar *)"extension")
          && xmlStrEqual( *(const xmlChar **)(*(void *)(v40 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          xmlSchemaParseExtension(a1, a2, v40, 10);
LABEL_158:
          char v40 = *(void *)(v40 + 48);
          uint64_t v48 = 1;
          if (!v40)
          {
LABEL_162:
            uint64_t v24 = v24->next;
            next = v24;
            int v8 = v60;
            if (!v24) {
              goto LABEL_148;
            }
            goto LABEL_146;
          }
        }

        else
        {
LABEL_160:
          uint64_t v48 = 0;
        }

        xmlSchemaPContentErr(a1, 3033, (uint64_t)v24, v40, 0LL, (xmlChar *)"(annotation?, (restriction | extension))");
        uint64_t v24 = next;
        goto LABEL_162;
      }
    }

    int v25 = 0;
  }

  else
  {
    *(void *)(a1 + 160) = PropNode;
    int v25 = 1;
  }

      return v3;
    case 17:
      int v31 = a2[1];
      if (v31 == -1) {
        xmlEntityPtr v3 = 0LL;
      }
      else {
        xmlEntityPtr v3 = xmlXPathCompOpEvalFirst(a1, *(void *)(v12 + 8) + 56LL * v31, a3);
      }
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      __int128 v36 = *(void *)(a1 + 32);
      if (v36)
      {
        if (*(_DWORD *)v36 == 1)
        {
          int v37 = *(unsigned int **)(v36 + 8);
          if (v37)
          {
            __int16 v38 = *v37;
          }
        }
      }

      goto LABEL_92;
    default:
      xmlEntityPtr v3 = xmlXPathCompOpEval(a1, a2);
      goto LABEL_92;
  }

xmlChar *__cdecl xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input)
{
  return (xmlChar *)xmlEncodeEntitiesInternal((uint64_t)doc, (unsigned __int8 *)input, 0);
}

xmlChar *__cdecl xmlEncodeSpecialChars(const xmlDoc *doc, const xmlChar *input)
{
  if (!input) {
    return 0LL;
  }
  uint64_t v2 = input;
  xmlEntityPtr v3 = (xmlChar *)xmlMalloc(0x3E8uLL);
  uint64_t v4 = v3;
  if (v3)
  {
    unint64_t v5 = 1000LL;
    BOOL v6 = v3;
    while (1)
    {
      int v7 = *v2;
      if (!*v2)
      {
        *BOOL v6 = 0;
        return v4;
      }

      if (v6 - v4 + 10 > v5)
      {
        if ((v5 & 0x8000000000000000LL) != 0 || (int v8 = (xmlChar *)xmlRealloc(v4, 2 * v5)) == 0LL)
        {
          __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"xmlEncodeSpecialChars: realloc failed");
          xmlFree(v4);
          return 0LL;
        }

        BOOL v6 = &v8[v6 - v4];
        int v7 = *v2;
        uint64_t v4 = v8;
        v5 *= 2LL;
      }

      if (v7 <= 37)
      {
        if (v7 == 13)
        {
          int v10 = 858858278;
          goto LABEL_22;
        }

        if (v7 == 34)
        {
          *(_DWORD *)BOOL v6 = 1869967654;
          *((_WORD *)v6 + 2) = 15220;
          v6 += 6;
          goto LABEL_24;
        }
      }

      else
      {
        switch(v7)
        {
          case '&':
            int v10 = 1886216486;
LABEL_22:
            *(_DWORD *)BOOL v6 = v10;
            v6[4] = 59;
            v6 += 5;
            goto LABEL_24;
          case '>':
            int v9 = 997484326;
            goto LABEL_20;
          case '<':
            int v9 = 997485606;
LABEL_20:
            *(_DWORD *)BOOL v6 = v9;
            v6 += 4;
            goto LABEL_24;
        }
      }

      *v6++ = v7;
LABEL_24:
      ++v2;
    }
  }

  __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"xmlEncodeSpecialChars: malloc failed");
  return v4;
}

xmlEntitiesTablePtr xmlCreateEntitiesTable(void)
{
  return xmlHashCreate(0);
}

void xmlFreeEntitiesTable(xmlEntitiesTablePtr table)
{
}

void xmlFreeEntityWrapper(uint64_t a1)
{
  if (a1) {
    xmlFreeEntity(a1);
  }
}

xmlEntitiesTablePtr xmlCopyEntitiesTable(xmlEntitiesTablePtr table)
{
  return xmlHashCopy(table, (xmlHashCopier)xmlCopyEntity);
}

void *xmlCopyEntity(uint64_t a1)
{
  uint64_t v2 = xmlMalloc(0x88uLL);
  xmlEntityPtr v3 = v2;
  if (v2)
  {
    v2[16] = 0LL;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_DWORD *)v2 + 2) = 17;
    *((_DWORD *)v2 + 23) = *(_DWORD *)(a1 + 92);
    uint64_t v4 = *(const xmlChar **)(a1 + 16);
    if (v4) {
      v3[2] = xmlStrdup(v4);
    }
    unint64_t v5 = *(const xmlChar **)(a1 + 96);
    if (v5) {
      v3[12] = xmlStrdup(v5);
    }
    BOOL v6 = *(const xmlChar **)(a1 + 104);
    if (v6) {
      v3[13] = xmlStrdup(v6);
    }
    int v7 = *(const xmlChar **)(a1 + 80);
    if (v7) {
      v3[10] = xmlStrdup(v7);
    }
    int v8 = *(const xmlChar **)(a1 + 72);
    if (v8) {
      v3[9] = xmlStrdup(v8);
    }
    int v9 = *(const xmlChar **)(a1 + 120);
    if (v9) {
      v3[15] = xmlStrdup(v9);
    }
  }

  else
  {
    __xmlSimpleError(2, 2, 0, 0LL, (uint64_t)"xmlCopyEntity:: malloc failed");
  }

  return v3;
}

void xmlDumpEntityDecl(xmlBufferPtr buf, xmlEntityPtr ent)
{
  if (buf && ent)
  {
    switch(ent->etype)
    {
      case XML_INTERNAL_GENERAL_ENTITY:
        uint64_t v4 = "<!ENTITY ";
        goto LABEL_11;
      case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
        unint64_t v5 = "<!ENTITY ";
        goto LABEL_14;
      case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
        xmlBufferWriteChar(buf, "<!ENTITY ");
        xmlBufferWriteCHAR(buf, ent->name);
        if (ent->ExternalID)
        {
          xmlBufferWriteChar(buf, " PUBLIC ");
          xmlBufferWriteQuotedString(buf, ent->ExternalID);
          BOOL v6 = " ";
        }

        else
        {
          BOOL v6 = " SYSTEM ";
        }

        xmlBufferWriteChar(buf, v6);
        xmlBufferWriteQuotedString(buf, ent->SystemID);
        if (ent->content)
        {
          xmlBufferWriteChar(buf, " NDATA ");
          orig = ent->orig;
          if (!orig) {
            orig = ent->content;
          }
          xmlBufferWriteCHAR(buf, orig);
        }

        goto LABEL_19;
      case XML_INTERNAL_PARAMETER_ENTITY:
        uint64_t v4 = "<!ENTITY % ";
LABEL_11:
        xmlBufferWriteChar(buf, v4);
        xmlBufferWriteCHAR(buf, ent->name);
        xmlBufferWriteChar(buf, " ");
        SystemID = ent->orig;
        if (SystemID) {
          goto LABEL_18;
        }
        xmlDumpEntityContent((uint64_t)buf, ent->content);
        goto LABEL_19;
      case XML_EXTERNAL_PARAMETER_ENTITY:
        unint64_t v5 = "<!ENTITY % ";
LABEL_14:
        xmlBufferWriteChar(buf, v5);
        xmlBufferWriteCHAR(buf, ent->name);
        if (ent->ExternalID)
        {
          xmlBufferWriteChar(buf, " PUBLIC ");
          xmlBufferWriteQuotedString(buf, ent->ExternalID);
          int v8 = " ";
        }

        else
        {
          int v8 = " SYSTEM ";
        }

        xmlBufferWriteChar(buf, v8);
        SystemID = ent->SystemID;
LABEL_18:
        xmlBufferWriteQuotedString(buf, SystemID);
LABEL_19:
        xmlBufferWriteChar(buf, ">\n");
        break;
      default:
        __xmlSimpleError(2, 535, 0, (uint64_t)"xmlDumpEntitiesDecl: internal: unknown type entity type", 0LL);
        break;
    }
  }

void xmlDumpEntityContent(uint64_t a1, xmlChar *str)
{
  if (*(_DWORD *)(a1 + 16) != 2)
  {
    uint64_t v2 = str;
    if (xmlStrchr(str, 0x25u))
    {
      xmlBufferCCat((xmlBufferPtr)a1, "");
LABEL_4:
      for (uint64_t i = 0LL; ; ++i)
      {
        int v5 = v2[i];
        if (!v2[i]) {
          break;
        }
        if (v5 == 37)
        {
          BOOL v6 = "&#x25;";
          if (i) {
            goto LABEL_10;
          }
          goto LABEL_11;
        }

        if (v5 == 34)
        {
          BOOL v6 = "&quot;";
          if (!i) {
            goto LABEL_11;
          }
LABEL_10:
          xmlBufferAdd((xmlBufferPtr)a1, v2, i);
LABEL_11:
          xmlBufferAdd((xmlBufferPtr)a1, (const xmlChar *)v6, 6);
          v2 += i + 1;
          goto LABEL_4;
        }
      }

      if (i) {
        xmlBufferAdd((xmlBufferPtr)a1, v2, i);
      }
      xmlBufferCCat((xmlBufferPtr)a1, "");
    }

    else
    {
      xmlBufferWriteQuotedString((xmlBufferPtr)a1, v2);
    }
  }

void xmlDumpEntitiesTable(xmlBufferPtr buf, xmlEntitiesTablePtr table)
{
}

void xmlDumpEntityDeclScan(xmlEntityPtr ent, xmlBufferPtr buf)
{
}

void xmlFreeEntity(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2) {
    xmlEntityPtr v3 = *(xmlDict **)(v2 + 152);
  }
  else {
    xmlEntityPtr v3 = 0LL;
  }
  uint64_t v4 = *(xmlNode **)(a1 + 24);
  if (v4 && *(_DWORD *)(a1 + 128) == 1 && v4->parent == (_xmlNode *)a1) {
    xmlFreeNodeList(v4);
  }
  int v5 = *(xmlChar **)(a1 + 16);
  if (v5)
  {
    if (v3)
    {
      if (xmlDictOwns(v3, v5)) {
        goto LABEL_13;
      }
      int v5 = *(xmlChar **)(a1 + 16);
    }

    xmlFree(v5);
  }

LABEL_13:
  BOOL v6 = *(void **)(a1 + 96);
  if (v6) {
    xmlFree(v6);
  }
  int v7 = *(void **)(a1 + 104);
  if (v7) {
    xmlFree(v7);
  }
  int v8 = *(void **)(a1 + 120);
  if (v8) {
    xmlFree(v8);
  }
  int v9 = *(void **)(a1 + 80);
  if (v9) {
    xmlFree(v9);
  }
  int v10 = *(void **)(a1 + 72);
  if (v10) {
    xmlFree(v10);
  }
  xmlFree((void *)a1);
}

    ++input->col;
    goto LABEL_14;
  }

  xmlEntityPtr v3 = 0;
LABEL_22:
  uint64_t v4 = 0LL;
  do
  {
    int v10 = ctxt->input->cur;
    int v11 = *v10;
    if (((1LL << v11) & 0x100002600LL) != 0)
    {
      xmlNextChar(ctxt);
    }

    else if (*v10)
    {
      if (v11 != 37 || v3) {
        break;
      }
      size_t v12 = v10[1];
      BOOL v13 = v12 > 0x20;
      int v14 = (1LL << v12) & 0x100002601LL;
      if (!v13 && v14 != 0) {
        break;
      }
      xmlParsePEReference(ctxt);
    }

    else
    {
      if (ctxt->inputNr < 2) {
        break;
      }
      xmlPopInput(ctxt);
    }

    ++v4;
  }

  while (ctxt->instate != XML_PARSER_EOF);
LABEL_18:
  if (v4 >= 0x7FFFFFFF) {
    return 0x7FFFFFFF;
  }
  else {
    return v4;
  }
}

  if (length > v7)
  {
    int v14 = length;
    do
    {
      unint64_t v15 = &ctxt->node_seq.buffer[v14];
      --length;
      int v16 = *(_OWORD *)&v15[-1].begin_line;
      *(_OWORD *)&v15->node = *(_OWORD *)&v15[-1].node;
      *(_OWORD *)&v15->begin_line = v16;
      v15->end_line = v15[-1].end_line;
      --v14;
    }

    while (length > v7);
    size_t v12 = ctxt->node_seq.buffer;
  }

  char v17 = &v12[v7];
  uint64_t v18 = *(_OWORD *)&info->node;
  unsigned __int8 v19 = *(_OWORD *)&info->begin_line;
  v17->end_line = info->end_line;
  *(_OWORD *)&v17->node = v18;
  *(_OWORD *)&v17->begin_line = v19;
  ++ctxt->node_seq.length;
}

        uint64_t v2 = *(void *)(a1 + 96);
      }
    }

    return 0xFFFFFFFFLL;
  }

  if (v5 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t i = 0LL;
  while (1)
  {
    int v10 = *(void *)(v2 + 48);
    int v11 = *(void *)(v10 + 8 * i);
    if (v11) {
      break;
    }
LABEL_20:
  }

  if (xmlRelaxNGAttributeMatch((void *)a2, *(void *)(v10 + 8 * i)) != 1)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    goto LABEL_20;
  }

  String = xmlNodeListGetString(*(xmlDocPtr *)(v11 + 64), *(const xmlNode **)(v11 + 24), 1);
  unint64_t v15 = *(void **)(a1 + 96);
  int v16 = v15[4];
  char v17 = v15[1];
  v15[1] = v11;
  v15[4] = String;
  unsigned __int8 v19 = *(void *)(a2 + 48);
  if (!v19) {
    goto LABEL_31;
  }
  do
  {
    size_t v12 = xmlRelaxNGValidateValue(a1, v19);
    if ((_DWORD)v12) {
      break;
    }
    unsigned __int8 v19 = *(void *)(v19 + 64);
  }

  while (v19);
LABEL_30:
  unint64_t v15 = *(void **)(a1 + 96);
  char v20 = (xmlChar *)v15[4];
LABEL_32:
  if (v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = String;
  }
  if (v21)
  {
    xmlFree(v21);
    unint64_t v15 = *(void **)(a1 + 96);
  }

  v15[4] = v16;
  v15[1] = v17;
  if (!(_DWORD)v12)
  {
    size_t v12 = 0LL;
    *(void *)(v15[6] + 8LL * i) = 0LL;
    --*(_DWORD *)(*(void *)(a1 + 96) + 24LL);
  }

  return v12;
}

  xmlFreeProp(cur);
  return 0;
}

            memmove(&buf->content[use], str, v5);
            xmlEntityPtr v3 = 0;
            int v8 = buf->use + v5;
            buf->uint64_t use = v8;
            buf->content[v8] = 0;
            return v3;
          }

          return 0;
        }
      }
    }
  }

  return v3;
}

  int v7 = 0;
  *(void *)(a1 + 112) = v5;
  xmlEntityPtr result = 1LL;
LABEL_16:
  *(_DWORD *)(a1 + 24) = v7;
  return result;
}

          xmlRegFreeAtom((uint64_t)v13);
          return 0LL;
        }
      }
    }
  }

  return result;
}

          xmlRegFreeAtom((uint64_t)v13);
          return 0LL;
        }
      }
    }
  }

  return result;
}

  if (*(void *)(a1 + 144)) {
    fprintf(__stream, "  value: '%s'\n", *(const char **)(a1 + 144));
  }
  if (*(void *)(a1 + 104))
  {
    fprintf(__stream, "  type: '%s' ", *(const char **)(a1 + 104));
    if (*(void *)(a1 + 112)) {
      fprintf(__stream, "ns '%s'\n", *(const char **)(a1 + 112));
    }
    else {
      fputc(10, __stream);
    }
  }

  else
  {
    int v8 = *(void *)(a1 + 56);
    if (v8) {
      xmlSchemaTypeDump(v8, __stream);
    }
  }

  if (*(void *)(a1 + 120))
  {
    fprintf(__stream, "  substitutionGroup: '%s' ", *(const char **)(a1 + 120));
    if (*(void *)(a1 + 128)) {
      fprintf(__stream, "ns '%s'\n", *(const char **)(a1 + 128));
    }
    else {
      fputc(10, __stream);
    }
  }

  BOOL v6 = (void *)*((void *)ctxt + 6);
  if (v6)
  {
    xmlSchemaConstructionCtxtFree(v6);
    *((void *)ctxt + 6) = 0LL;
    *((_DWORD *)ctxt + 14) = 0;
  }

  xmlSchemaInternalErr2(ctxt, (const xmlChar *)"xmlSchemaParse", (const xmlChar *)"An internal error occurred", 0LL);
LABEL_16:
  xmlEntityPtr v3 = 0LL;
LABEL_17:
  *((void *)ctxt + 8) = 0LL;
  return v3;
}

        xmlSchemaPIllegalAttrErr((_DWORD *)a1, v14);
        goto LABEL_16;
      }

    xmlSchemaPIllegalAttrErr((_DWORD *)a1, v14);
    goto LABEL_16;
  }

  int v14 = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
  if (v14) {
    xmlSchemaPValAttrNodeID((uint64_t)a1, v14);
  }
  xmlEntityPtr result = xmlSchemaAddParticle((uint64_t)a1, a3, MinOccurs, MaxOccurs);
  if (result)
  {
    int v16 = (uint64_t)result;
    result[3] = xmlSchemaNewQNameRef((uint64_t)a1, 17, (uint64_t)v19, (uint64_t)v9);
    xmlSchemaPCheckParticleCorrect_2((uint64_t)a1, a3, MinOccurs, MaxOccurs);
    char v17 = *(void *)(a3 + 24);
    if (v17)
    {
      if (!*(void *)(v17 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"annotation")
        || !xmlStrEqual( *(const xmlChar **)(*(void *)(v17 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
        || (*(void *)(v16 + 8) = xmlSchemaParseAnnotation(a1, v17, 1), (char v17 = *(void *)(v17 + 48)) != 0))
      {
        xmlSchemaPContentErr((uint64_t)a1, 3033, a3, v17, 0LL, (xmlChar *)"(annotation?)");
      }
    }

    if (MinOccurs | MaxOccurs) {
      return (void *)v16;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

    ++a2;
    int v7 = *v4++;
    xmlEntityPtr v3 = v7;
    if (!v7) {
      goto LABEL_14;
    }
  }

  if (v3 == 32) {
    goto LABEL_13;
  }
  if (a3) {
    int v10 = -1;
  }
  else {
    int v10 = 1;
  }
  if (a3) {
    int v11 = 1;
  }
  else {
    int v11 = -1;
  }
  if (v3 <= 0x1F) {
    return v11;
  }
  else {
    return v10;
  }
}

  if (pubid)
  {
    if (!sysid)
    {
      int v11 = "xmlTextWriterWriteDTDExternalEntityContents: system identifier needed!\n";
      goto LABEL_10;
    }

    BOOL v13 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, " PUBLIC ");
    if (v13 < 0) {
      goto LABEL_11;
    }
    int v14 = v13;
    unint64_t v15 = xmlOutputBufferWrite(*(xmlOutputBufferPtr *)writer, 1, (const char *)writer + 48);
    if (v15 < 0) {
      goto LABEL_11;
    }
    int v16 = v15;
    char v17 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, (const char *)pubid);
    if (v17 < 0) {
      goto LABEL_11;
    }
    uint64_t v18 = v17;
    unsigned __int8 v19 = xmlOutputBufferWrite(*(xmlOutputBufferPtr *)writer, 1, (const char *)writer + 48);
    if (v19 < 0) {
      goto LABEL_11;
    }
    char v20 = v16 + v14 + v18 + v19;
  }

  else
  {
    if (!sysid) {
      goto LABEL_27;
    }
    char v20 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, " SYSTEM");
    if (v20 < 0) {
      goto LABEL_11;
    }
  }

  uint64_t v21 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, " ");
  if (v21 < 0) {
    goto LABEL_11;
  }
  int v22 = v21;
  int v23 = xmlOutputBufferWrite(*(xmlOutputBufferPtr *)writer, 1, (const char *)writer + 48);
  if (v23 < 0) {
    goto LABEL_11;
  }
  uint64_t v24 = v23;
  int v25 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, (const char *)sysid);
  if (v25 < 0) {
    goto LABEL_11;
  }
  char v26 = v25;
  char v27 = xmlOutputBufferWrite(*(xmlOutputBufferPtr *)writer, 1, (const char *)writer + 48);
  if (v27 < 0) {
    goto LABEL_11;
  }
  LODWORD(sysid) = v22 + v20 + v24 + v26 + v27;
LABEL_27:
  if (!ndataid) {
    return (int)sysid;
  }
  int v28 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, " NDATA ");
  if (v28 < 0) {
    goto LABEL_11;
  }
  unsigned int v29 = v28;
  unsigned __int8 v30 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, (const char *)ndataid);
  if (v30 >= 0) {
    LODWORD(sysid) = v29 + (_DWORD)sysid + v30;
  }
  else {
    LODWORD(sysid) = -1;
  }
  return (int)sysid;
}

  while (1)
  {
    ctxt = cur->next;
    if (ctxt) {
      break;
    }
    cur = cur->parent;
    if (!cur || cur == *children) {
      return 0LL;
    }
  }

  return ctxt;
}

  valueTab = v2->valueTab;
  int v10 = valueNr - 1;
  v2->valueNr = valueNr - 1;
  if (valueNr == 1) {
    int v11 = 0LL;
  }
  else {
    int v11 = valueTab[valueNr - 2];
  }
  __src = 0;
  v2->value = v11;
  BOOL v13 = valueTab[v10];
  valueTab[v10] = 0LL;
  stringval = v13->stringval;
  unint64_t v15 = (const xmlBuf *)xmlBufCreate();
  if (v15 && stringval)
  {
    int v16 = v15;
    while (1)
    {
      char v17 = *stringval;
      if (v17 > 0x20 || ((1LL << v17) & 0x100002600LL) == 0) {
        break;
      }
      ++stringval;
    }

    __src = 0;
    while (1)
    {
      if (v17 <= 0x20u)
      {
        if (((1LL << v17) & 0x100002600LL) != 0)
        {
          __src = 32;
          goto LABEL_33;
        }

        if (!(_BYTE)v17)
        {
          char v20 = (uint64_t)v2->context;
          uint64_t v21 = xmlBufContent(v16);
          int v22 = xmlXPathCacheNewString(v20, v21);
          valuePush(v2, v22);
          xmlBufFree(v16);
          break;
        }
      }

      if (__src)
      {
        xmlBufAdd((uint64x2_t *)v16, &__src, 1uLL);
        __src = 0;
      }

      xmlBufAdd((uint64x2_t *)v16, stringval, 1uLL);
LABEL_33:
      unsigned __int8 v19 = *++stringval;
      LOBYTE(v17) = v19;
    }
  }

  xmlXPathReleaseObject((uint64_t)v2->context, v13);
}

uint64_t xmlGenericErrorDefaultFunc( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*__xmlGenericErrorContext())
  {
    int v10 = (void *)*MEMORY[0x1895F89D0];
    *__xmlGenericErrorContext() = v10;
  }

  int v11 = __xmlGenericErrorContext();
  return vfprintf((FILE *)*v11, a2, &a9);
}

void initGenericErrorDefaultFunc(xmlGenericErrorFunc *handler)
{
  if (handler) {
    uint64_t v1 = *handler;
  }
  else {
    uint64_t v1 = (void (*)(void *, const char *, ...))xmlGenericErrorDefaultFunc;
  }
  *__xmlGenericError() = v1;
}

void xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler)
{
  *__xmlGenericErrorContext() = ctx;
  xmlEntityPtr v3 = __xmlGenericError();
  uint64_t v4 = (void (*)(void *, const char *, ...))xmlGenericErrorDefaultFunc;
  if (handler) {
    uint64_t v4 = handler;
  }
  xmlGenericErrorFunc *v3 = v4;
}

void xmlSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler)
{
  *__xmlStructuredErrorContext() = ctx;
  *__xmlStructuredError() = handler;
}

void xmlParserPrintFileInfo(xmlParserInputPtr input)
{
  if (input)
  {
    filename = input->filename;
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    xmlEntityPtr v3 = *__xmlGenericErrorContext();
    if (filename) {
      uint64_t v4 = "%s:%d: ";
    }
    else {
      uint64_t v4 = "Entity: line %d: ";
    }
    v2(v3, v4);
  }

void xmlParserPrintFileContext(xmlParserInputPtr input)
{
  xmlGenericErrorFunc v2 = (void (*)(uint64_t, const char *, ...))*__xmlGenericError();
  xmlEntityPtr v3 = *__xmlGenericErrorContext();
  xmlParserPrintFileContextInternal((uint64_t)input, v2, (uint64_t)v3);
}

uint64_t xmlParserPrintFileContextInternal( uint64_t result, void (*a2)(uint64_t, const char *, ...), uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (result)
  {
    xmlEntityPtr v3 = *(unsigned __int8 **)(result + 32);
    if (v3)
    {
      char v22 = 0;
      memset(v21, 0, sizeof(v21));
      unint64_t v6 = *(void *)(result + 24);
      int v7 = v3;
      if ((unint64_t)v3 > v6)
      {
        int v7 = v3;
        while (1)
        {
          int v8 = *v7;
          if (v8 != 13 && v8 != 10) {
            break;
          }
          if ((unint64_t)--v7 <= v6)
          {
            int v7 = *(unsigned __int8 **)(result + 24);
            break;
          }
        }
      }

      if ((unint64_t)v7 <= v6)
      {
LABEL_20:
        int v11 = *v7;
      }

      else
      {
        unsigned int v10 = 1;
        while (1)
        {
          int v11 = *v7;
          if (v11 == 10 || v11 == 13) {
            break;
          }
          --v7;
          if (v10 <= 0x4F)
          {
            ++v10;
          }

          goto LABEL_20;
        }
      }

      uint64_t v13 = 0LL;
      if (v11 == 13 || v11 == 10) {
        ++v7;
      }
      int v15 = (_DWORD)v3 - (_DWORD)v7;
      while (1)
      {
        int v16 = v7[v13];
        BOOL v17 = !v7[v13] || v16 == 10;
        BOOL v18 = v17 || v16 == 13;
        *((_BYTE *)v21 + v13++) = v16;
      }

      *((_BYTE *)v21 + v13) = 0;
      a2(a3, "%s\n", (const char *)v21);
      if (v15)
      {
        uint64_t v19 = 0LL;
        char v20 = v21;
        do
        {
          if ((_DWORD)v19 == 79) {
            break;
          }
          if (*((_BYTE *)v21 + v19) != 9)
          {
            if (!*((_BYTE *)v21 + v19)) {
              goto LABEL_45;
            }
            *((_BYTE *)v21 + v19) = 32;
          }

          char v20 = (_WORD *)((char *)v20 + 1);
          ++v19;
        }

        while (v15 != (_DWORD)v19);
        char v20 = (_WORD *)((char *)v21 + v19);
      }

      else
      {
        char v20 = v21;
      }

LABEL_45:
      *char v20 = 94;
      return ((uint64_t (*)(uint64_t, const char *, ...))a2)(a3, "%s\n", (const char *)v21);
    }
  }

  return result;
}

  if (xmlCharInRange(v16, &xmlIsBaseCharGroup)) {
    BOOL v17 = 1;
  }
  else {
    BOOL v17 = (v16 - 12330) > 0xFFFFFFF6;
  }
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_56:
          while (1)
          {
            v3 += len;
            char v20 = xmlStringCurrentChar(0LL, v3, &len);
            uint64_t v21 = v20;
            if (v20 > 255) {
              break;
            }
            char v22 = (v20 - 192) >= 0x17 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A;
          }

          if (xmlCharInRange(v20, &xmlIsBaseCharGroup)) {
            uint64_t v24 = 0;
          }
          else {
            uint64_t v24 = (v21 - 12321) >= 9;
          }
          char v26 = v24 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
        }

        while (!v26 || xmlCharInRange(v21, &xmlIsDigitGroup));
LABEL_80:
        ;
      }

      while ((v21 - 45) <= 0x32 && ((1LL << (v21 - 45)) & 0x4000000002003LL) != 0);
      if (v21 >= 256) {
        break;
      }
      if (v21 != 183) {
        goto LABEL_90;
      }
    }
  }

  while (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup));
LABEL_90:
  if (space && v21 <= 255)
  {
    do
    {
      if (((1LL << v21) & 0x100002600LL) == 0) {
        break;
      }
      v3 += len;
      uint64_t v21 = xmlStringCurrentChar(0LL, v3, &len);
    }

    while (v21 < 256);
  }

  return v21 != 0;
}

  *(void *)(*(void *)(a1 + 48) + 32LL) = v7;
  *(void *)(a2 + 32) = v103;
  *(_DWORD *)(a2 + 48) = v9;
  return v24;
}

      if (v23) {
        xmlFree(v23);
      }
      if (!v27) {
        return 1LL;
      }
      str1 += v22;
      if (!*str1) {
        return 0LL;
      }
    }

    if (a3 != -1)
    {
      if ((*a2 & a3) == 0)
      {
        uint64_t v24 = *a2 | a3;
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    goto LABEL_44;
  }

  return result;
}

_DWORD *__xmlRaiseError( xmlStructuredErrorFunc a1, void (*a2)(void *, const char *, ...), void *a3, void *a4, uint64_t a5, unsigned int a6, int a7, int a8, uint64_t a9, int a10, const xmlChar *a11, xmlChar *cur, xmlChar *a13, int a14, int a15, const char *a16, char a17)
{
  xmlEntityPtr result = __xmlLastError();
  if (!a7) {
    return result;
  }
  uint64_t v26 = (uint64_t)result;
  xmlEntityPtr result = __xmlGetWarningsDefaultValue();
  if (a8 == 1 && !*result) {
    return result;
  }
  char v27 = 0LL;
  if (a6 <= 0x17 && ((1 << a6) & 0x80013A) != 0 && (char v27 = a4, !a1) && (char v27 = a4) != 0LL)
  {
    uint64_t v28 = *a4;
    char v27 = a4;
    if (*a4)
    {
      char v27 = a4;
      if (*(_DWORD *)(v28 + 216) == -554844497)
      {
        a1 = *(xmlStructuredErrorFunc *)(v28 + 248);
        char v27 = a4;
        if (a1)
        {
          unsigned int v29 = (void **)(a4 + 1);
          char v27 = a4;
LABEL_15:
          a3 = *v29;
          goto LABEL_16;
        }
      }
    }
  }

  else if (a1)
  {
    goto LABEL_16;
  }

  a1 = *__xmlStructuredError();
  if (a1)
  {
    unsigned int v29 = __xmlStructuredErrorContext();
    goto LABEL_15;
  }

LABEL_68:
    uint64_t v41 = 0LL;
    uint64_t v26 = (uint64_t)(v27 + 75);
    goto LABEL_69;
  }

  uint64_t v41 = 0LL;
  if (!a5 || a9) {
    goto LABEL_69;
  }
  uint64_t v42 = *(void *)(a5 + 64);
  if (v42)
  {
    if (*(void *)(v42 + 136)) {
      uint64_t v41 = a5;
    }
    else {
      uint64_t v41 = 0LL;
    }
  }

  else
  {
    uint64_t v41 = 0LL;
  }

  unsigned int v43 = 0;
  do
  {
    if (*(_DWORD *)(a5 + 8) == 1)
    {
      int v44 = a10;
      if (v41) {
        goto LABEL_59;
      }
      goto LABEL_54;
    }

    a5 = *(void *)(a5 + 40);
    if (v43 > 8) {
      break;
    }
    ++v43;
  }

  while (a5);
  int v44 = a10;
  if (!v41 && a5)
  {
LABEL_54:
    uint64_t v45 = *(void *)(a5 + 64);
    if (v45)
    {
      if (*(void *)(v45 + 136)) {
        uint64_t v41 = a5;
      }
      else {
        uint64_t v41 = 0LL;
      }
    }

    else
    {
      uint64_t v41 = 0LL;
    }

    goto LABEL_59;
  }

  if (!a5) {
    goto LABEL_61;
  }
LABEL_59:
  if (*(_DWORD *)(a5 + 8) == 1) {
    int v44 = *(unsigned __int16 *)(a5 + 112);
  }
LABEL_61:
  if (v44 != 0xFFFF && v44) {
    int LineNo = v44;
  }
  else {
    int LineNo = xmlGetLineNo((const xmlNode *)a5);
  }
  uint64_t v36 = 0LL;
LABEL_69:
  xmlResetError((xmlErrorPtr)v26);
  *(_DWORD *)uint64_t v26 = v64;
  *(_DWORD *)(v26 + 4) = a7;
  *(void *)(v26 + 8) = v33;
  *(_DWORD *)(v26 + 16) = a8;
  if (v36)
  {
    int v46 = (const xmlChar *)v36;
LABEL_71:
    *(void *)(v26 + 24) = xmlStrdup(v46);
  }

  else if (v41)
  {
    int v63 = a8;
    uint64_t v48 = a3;
    int v49 = 0;
    uint64_t v50 = v41;
    do
    {
      uint64_t v51 = *(void *)(v50 + 56);
      if (v51)
      {
        int v52 = *(_DWORD *)(v51 + 8);
        if (v52 == 20)
        {
          ++v49;
        }

        else if (v52 == 19)
        {
          if (v49 < 1)
          {
            Prop = xmlGetProp((const xmlNode *)v51, (const xmlChar *)"href");
            if (Prop)
            {
              *(void *)(v26 + 24) = Prop;
              a3 = v48;
              a8 = v63;
              goto LABEL_72;
            }
          }

          else
          {
            --v49;
          }
        }
      }

      else
      {
        uint64_t v51 = *(void *)(v50 + 40);
      }

      uint64_t v50 = v51;
    }

    while (v51);
    int v54 = xmlStrdup(*(const xmlChar **)(*(void *)(v41 + 64) + 136LL));
    *(void *)(v26 + 24) = v54;
    if (v54) {
      BOOL v55 = 1;
    }
    else {
      BOOL v55 = a5 == 0;
    }
    a3 = v48;
    a8 = v63;
    if (!v55)
    {
      uint64_t v56 = *(void *)(a5 + 64);
      if (v56)
      {
        int v46 = *(const xmlChar **)(v56 + 136);
        goto LABEL_71;
      }
    }
  }

      int v38 = (int)elem;
      BOOL v39 = 1;
      name = 0LL;
LABEL_69:
      xmlErrValidNode((uint64_t *)ctxt, v38, v39, (uint64_t)v7, (uint64_t)name, 0LL, 0LL);
      return 0;
    case XML_CDATA_SECTION_NODE:
    case XML_ENTITY_REF_NODE:
    case XML_PI_NODE:
    case XML_COMMENT_NODE:
    case XML_XINCLUDE_START:
    case XML_XINCLUDE_END:
      return v6;
    case XML_ENTITY_NODE:
      int v7 = "Entity element not expected\n";
      goto LABEL_68;
    case XML_DOCUMENT_NODE:
    case XML_DOCUMENT_TYPE_NODE:
    case XML_DOCUMENT_FRAG_NODE:
      int v7 = "Document element not expected\n";
      goto LABEL_68;
    case XML_NOTATION_NODE:
      int v7 = "Notation element not expected\n";
      goto LABEL_68;
    case XML_HTML_DOCUMENT_NODE:
      int v7 = "HTML Document not expected\n";
      goto LABEL_68;
    default:
      int v7 = "unknown element type\n";
      goto LABEL_68;
  }

  switch(*((_DWORD *)ElemDecl + 18))
  {
    case 0:
      name = elem->name;
      int v7 = "No declaration for element %s\n";
      ctxt = v5;
      int v38 = (int)elem;
      BOOL v39 = 534;
      goto LABEL_69;
    case 1:
      if (!elem->children) {
        goto LABEL_11;
      }
      uint64_t v42 = elem->name;
      unsigned int v43 = "Element %s was declared EMPTY this one has content\n";
      int v44 = (uint64_t *)v5;
      uint64_t v45 = (int)elem;
      int v46 = 528;
      goto LABEL_80;
    case 3:
      uint64_t v47 = (_DWORD *)ElemDecl[10];
      if (!v47 || *v47 != 1)
      {
        children = elem->children;
        if (!children) {
          goto LABEL_11;
        }
LABEL_97:
        if (children->type != XML_ELEMENT_NODE) {
          goto LABEL_130;
        }
        int v52 = children->name;
        ns = children->ns;
        if (!ns || !ns->prefix) {
          goto LABEL_118;
        }
        uint64_t v68 = 0;
        xmlXPathObjectPtr v66 = 0u;
        xmlAttrPtr v67 = 0u;
        *(_OWORD *)memory = 0u;
        int v54 = xmlBuildQName(children->name, ns->prefix, memory, 50);
        if (!v54) {
          return 0;
        }
        BOOL v55 = v54;
        uint64_t v56 = v9[10];
        if (!v56)
        {
LABEL_111:
          uint64_t v59 = 1;
          goto LABEL_114;
        }

        while (*(_DWORD *)v56 == 4)
        {
          uint64_t v58 = *(void *)(v56 + 16);
          if (!v58) {
            goto LABEL_112;
          }
          if (*(_DWORD *)v58 != 1)
          {
            if (*(_DWORD *)v58 != 2)
            {
LABEL_112:
              xmlErrValid_0(0LL, 519, (uint64_t)"Internal: MIXED struct corrupted\n", 0LL);
LABEL_113:
              uint64_t v59 = 0;
LABEL_114:
              if (v55 != memory && v55 != children->name) {
                xmlFree(v55);
              }
              if (!v59) {
                goto LABEL_130;
              }
LABEL_118:
              v60 = v9[10];
              if (v60)
              {
                while (2)
                {
                  if (*(_DWORD *)v60 != 4)
                  {
                    if (*(_DWORD *)v60 != 2) {
                      goto LABEL_129;
                    }
                    uint64_t v61 = *(const xmlChar **)(v60 + 8);
                    goto LABEL_126;
                  }

                  uint64_t v62 = *(void *)(v60 + 16);
                  if (!v62) {
                    goto LABEL_129;
                  }
                  if (*(_DWORD *)v62 != 1)
                  {
                    if (*(_DWORD *)v62 != 2)
                    {
LABEL_129:
                      xmlErrValid_0((uint64_t *)v5, 519, (uint64_t)"Internal: MIXED struct corrupted\n", 0LL);
                      goto LABEL_130;
                    }

                    uint64_t v61 = *(const xmlChar **)(v62 + 8);
LABEL_126:
                    if (xmlStrEqual(v61, v52)) {
                      goto LABEL_130;
                    }
                  }

                  v60 = *(void *)(v60 + 24);
                  if (!v60) {
                    break;
                  }
                  continue;
                }
              }

              xmlErrValidNode( (uint64_t *)v5,  (int)elem,  515,  (uint64_t)"Element %s is not declared in %s list of possible children\n",  (uint64_t)v52,  (xmlChar *)elem->name,  0LL);
              unint64_t v6 = 0;
LABEL_130:
              children = children->next;
              if (!children) {
                goto LABEL_11;
              }
              goto LABEL_97;
            }

            uint64_t v57 = *(const xmlChar **)(v58 + 8);
            goto LABEL_109;
          }

      xmlSchemaPIllegalAttrErr((_DWORD *)a1, v37);
      goto LABEL_71;
    }

    int v16 = *a4;
    uint64_t v88 = 0LL;
    __int128 v86 = 0LL;
    str2 = 0LL;
    if (!v13) {
      goto LABEL_157;
    }
    BOOL v17 = (xmlNode *)xmlSchemaGetPropNode(v13, (xmlChar *)"ref");
    if (v17)
    {
      BOOL v18 = (xmlChar *)xmlSchemaGetNodeContent(a1, v17);
      if (xmlSchemaPValAttrNodeQNameValue( a1,  a2,  (uint64_t)v17,  v18,  (const xmlChar **)&str2,  (const xmlChar **)&v86)
        || xmlSchemaCheckReference(a1, v13, (uint64_t)v17, str2))
      {
        goto LABEL_157;
      }
    }

    __int128 v78 = *(_DWORD *)(a1 + 36);
    uint64_t v19 = *(xmlNode **)(v13 + 88);
    if (!v19)
    {
      __int128 v75 = 0;
      str1 = 0LL;
      xmlXPathObjectPtr v77 = 0LL;
      __int128 v79 = 0;
      __int128 v80 = 2;
LABEL_95:
      unsigned int v29 = v78;
      goto LABEL_96;
    }

    __int128 v75 = 0;
    str1 = 0LL;
    xmlXPathObjectPtr v77 = 0LL;
    __int128 v79 = 0;
    __int128 v80 = 2;
    do
    {
      ns = v19->ns;
      if (ns)
      {
        if (!xmlStrEqual(ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
          goto LABEL_56;
        }
LABEL_23:
        xmlSchemaPIllegalAttrErr((_DWORD *)a1, (uint64_t)v19);
        goto LABEL_56;
      }

      name = v19->name;
      if (v17)
      {
        if (xmlStrEqual(name, (const xmlChar *)"id")) {
          goto LABEL_26;
        }
        if (xmlStrEqual(v19->name, (const xmlChar *)"ref")) {
          goto LABEL_56;
        }
      }

      else
      {
        if (xmlStrEqual(name, v10)) {
          goto LABEL_56;
        }
        if (xmlStrEqual(v19->name, (const xmlChar *)"id"))
        {
LABEL_26:
          xmlSchemaPValAttrNodeID(a1, v19);
          goto LABEL_56;
        }

        if (xmlStrEqual(v19->name, (const xmlChar *)"type"))
        {
          char v22 = (xmlChar *)xmlSchemaGetNodeContent(a1, v19);
          xmlSchemaPValAttrNodeQNameValue(a1, a2, (uint64_t)v19, v22, (const xmlChar **)&str2, (const xmlChar **)&v86);
          goto LABEL_56;
        }

        if (xmlStrEqual(v19->name, (const xmlChar *)"form"))
        {
          uint64_t v23 = v16;
          uint64_t v24 = v10;
          uint64_t v28 = xmlSchemaGetNodeContent(a1, v19);
          if (xmlStrEqual(v28, (const xmlChar *)"qualified"))
          {
            str1 = *(xmlChar **)(a1 + 200);
          }

          else if (!xmlStrEqual(v28, (const xmlChar *)"unqualified"))
          {
            xmlSchemaPSimpleTypeErr(a1, 3037, (uint64_t)v19, 0LL, "(qualified | unqualified)", v28, 0LL, 0);
          }

          __int128 v75 = 1;
          goto LABEL_55;
        }
      }

      if (xmlStrEqual(v19->name, (const xmlChar *)"use"))
      {
        uint64_t v23 = v16;
        uint64_t v24 = v10;
        int v25 = xmlSchemaGetNodeContent(a1, v19);
        if (xmlStrEqual(v25, (const xmlChar *)"optional"))
        {
          uint64_t v26 = 2;
        }

        else
        {
          if (xmlStrEqual(v25, (const xmlChar *)"prohibited"))
          {
            __int128 v80 = 0;
            goto LABEL_55;
          }

          if (!xmlStrEqual(v25, (const xmlChar *)"required"))
          {
            xmlSchemaPSimpleTypeErr(a1, 1774, (uint64_t)v19, 0LL, "(optional | prohibited | required)", v25, 0LL, 0);
            goto LABEL_55;
          }

          uint64_t v26 = 1;
        }

        __int128 v80 = v26;
LABEL_55:
        unsigned int v10 = v24;
        int v16 = v23;
        goto LABEL_56;
      }

      if (xmlStrEqual(v19->name, (const xmlChar *)"default"))
      {
        if (v77) {
          goto LABEL_46;
        }
        xmlXPathObjectPtr v77 = xmlSchemaGetNodeContent(a1, v19);
        char v27 = 1;
      }

      else
      {
        if (!xmlStrEqual(v19->name, (const xmlChar *)"fixed")) {
          goto LABEL_23;
        }
        if (v77)
        {
LABEL_46:
          xmlSchemaPMutualExclAttrErr(a1, 3051, 0LL, (uint64_t)v19);
          goto LABEL_56;
        }

        xmlXPathObjectPtr v77 = xmlSchemaGetNodeContent(a1, v19);
        char v27 = 2;
      }

      __int128 v79 = v27;
LABEL_56:
      uint64_t v19 = v19->next;
    }

    while (v19);
    if (v79 != 1) {
      goto LABEL_95;
    }
    unsigned int v29 = v78;
    if (v80 != 2)
    {
      xmlSchemaPSimpleTypeErr( a1,  3052,  v13,  0LL,  "(optional | prohibited | required)",  0LL,  (const xmlChar *)"The value of the attribute 'use' must be 'optional' if the attribute 'default' is present",  0);
      __int128 v79 = 1;
    }

  xmlHashScan(*(xmlHashTablePtr *)(*((void *)v1 + 5) + 96LL), (xmlHashScanner)xmlSchemaAugmentImportedIDC, v1);
LABEL_69:
  int v34 = v1[43];
  int v35 = __OFSUB__(v34, 1);
  uint64_t v36 = v34 - 1;
  if (v36 < 0 != v35)
  {
    Elem = xmlSchemaGetElem( *((void *)v1 + 5),  *(const xmlChar **)(*((void *)v1 + 24) + 24LL),  *(xmlChar **)(*((void *)v1 + 24) + 32LL));
    uint64_t v45 = *((void *)v1 + 24);
    *(void *)(v45 + 80) = Elem;
    if (!Elem)
    {
      int v8 = 1845LL;
      xmlSchemaCustomErr4( v1,  1845,  0LL,  0LL,  (const xmlChar *)"No matching global declaration available for the validation root",  0LL,  0LL,  0LL,  0LL);
LABEL_207:
      v1[76] = v1[43];
      return v8;
    }

    int v46 = (uint64_t)Elem;
    goto LABEL_117;
  }

  uint64_t v37 = *(void *)(*((void *)v1 + 22) + 8LL * v36);
  int v38 = *(_DWORD *)(v37 + 64);
  if ((v38 & 0x20) != 0)
  {
    v38 ^= 0x20u;
    *(_DWORD *)(v37 + 64) = v38;
  }

  if ((v38 & 4) != 0)
  {
    *((void *)v1 + 24) = v37;
    int v8 = 1848LL;
    xmlSchemaCustomErr4( v1,  1848,  0LL,  0LL,  (const xmlChar *)"Neither character nor element content is allowed, because the element was 'nilled'",  0LL,  0LL,  0LL,  0LL);
LABEL_83:
    uint64_t v47 = v1[43];
    uint64_t v48 = *(void *)(*((void *)v1 + 22) + 8 * v47);
    *((void *)v1 + 24) = v48;
LABEL_84:
    v1[76] = v47;
    *(_DWORD *)(v48 + 64) |= 0x200u;
    *(_DWORD *)(v37 + 64) |= 0x100u;
    if ((_DWORD)v8)
    {
LABEL_85:
      if ((v8 & 0x80000000) != 0) {
        goto LABEL_112;
      }
      goto LABEL_207;
    }

    goto LABEL_114;
  }

  BOOL v39 = *(void *)(v37 + 56);
  if (*(_DWORD *)(v39 + 160) != 45)
  {
    switch(*(_DWORD *)(v39 + 92))
    {
      case 1:
        *((void *)v1 + 24) = v37;
        int v8 = 1841LL;
        xmlSchemaCustomErr4( v1,  1841,  0LL,  0LL,  (const xmlChar *)"Element content is not allowed, because the content type is empty",  0LL,  0LL,  0LL,  0LL);
        goto LABEL_83;
      case 2:
      case 3:
        uint64_t v96 = 0u;
        v97 = 0u;
        uint64_t v94 = 0u;
        int v95 = 0u;
        *(_OWORD *)values = 0u;
        nbval = 10;
        terminal = 0;
        nbneg = 0;
        int v49 = *(xmlRegexp **)(v39 + 200);
        if (!v49)
        {
          xmlGenericErrorFunc v53 = "type has elem content but no content model";
          goto LABEL_111;
        }

        if ((v38 & 0x100) != 0)
        {
          xmlGenericErrorFunc v53 = "validating elem, but elem content is already invalid";
          goto LABEL_111;
        }

        uint64_t v50 = *(xmlRegExecCtxt **)(v37 + 112);
        if (v50) {
          goto LABEL_93;
        }
        uint64_t v51 = xmlRegNewExecCtxt(v49, (xmlRegExecCallbacks)xmlSchemaVContentModelCallback, v1);
        if (!v51)
        {
          xmlGenericErrorFunc v53 = "failed to create a regex context";
          goto LABEL_111;
        }

        uint64_t v50 = v51;
        *(void *)(v37 + 112) = v51;
LABEL_93:
        int v52 = xmlRegExecPushString2( v50,  *(const xmlChar **)(*((void *)v1 + 24) + 24LL),  *(const xmlChar **)(*((void *)v1 + 24) + 32LL),  *((void **)v1 + 24));
        if (v1[26] == 1818)
        {
          xmlGenericErrorFunc v53 = "calling xmlRegExecPushString2()";
          goto LABEL_111;
        }

        if (v52 < 0)
        {
          xmlRegExecErrInfo(v50, 0LL, &nbval, &nbneg, values, &terminal);
          xmlSchemaComplexTypeErr(v1, (const xmlChar *)"This element is not expected", nbval, nbneg, (uint64_t)values);
          int v8 = v1[26];
          LODWORD(v47) = v1[43];
          uint64_t v48 = *((void *)v1 + 24);
          goto LABEL_84;
        }

        break;
      case 4:
      case 6:
        *((void *)v1 + 24) = v37;
        if (*(_DWORD *)v39 == 5) {
          xmlSchemaCustomErr4( v1,  1842,  0LL,  0LL,  (const xmlChar *)"Element content is not allowed, because the content type is a simple type definition",  0LL,  0LL,  0LL,  0LL);
        }
        else {
          xmlSchemaCustomErr4( v1,  1828,  0LL,  0LL,  (const xmlChar *)"Element content is not allowed, because the type definition is simple",  0LL,  0LL,  0LL,  0LL);
        }
        uint64_t v47 = v1[43];
        uint64_t v48 = *(void *)(*((void *)v1 + 22) + 8 * v47);
        *((void *)v1 + 24) = v48;
        int v8 = v1[26];
        goto LABEL_84;
      default:
        goto LABEL_114;
    }

    goto LABEL_114;
  }

  int v40 = xmlSchemaGetElem( *((void *)v1 + 5),  *(const xmlChar **)(*((void *)v1 + 24) + 24LL),  *(xmlChar **)(*((void *)v1 + 24) + 32LL));
  uint64_t v41 = *((void *)v1 + 24);
  *(void *)(v41 + 80) = v40;
  if (v40) {
    goto LABEL_114;
  }
  uint64_t v42 = v1[74];
  if ((int)v42 < 1)
  {
LABEL_79:
    *(void *)(*((void *)v1 + 24) + 56LL) = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    goto LABEL_114;
  }

  unsigned int v43 = (uint64_t *)*((void *)v1 + 36);
  while (*(_DWORD *)(*v43 + 92) != 1)
  {
    ++v43;
    if (!--v42) {
      goto LABEL_79;
    }
  }

  uint64_t v56 = xmlSchemaProcessXSIType((uint64_t)v1, *v43, v41 + 56, 0LL);
  if (!(_DWORD)v56)
  {
LABEL_114:
    if (v1[43] == v1[76]) {
      return 0LL;
    }
    uint64_t v45 = *((void *)v1 + 24);
    int v46 = *(void *)(v45 + 80);
    if (!v46)
    {
      if (!*(void *)(v45 + 56))
      {
        int v32 = "xmlSchemaValidateElem";
        unsigned int v33 = "the child element was valid but neither the declaration nor the type was set";
        goto LABEL_227;
      }

      goto LABEL_199;
    }

LABEL_72:
  *(_DWORD *)(v26 + 32) = LineNo;
  if (a11) {
    *(void *)(v26 + 40) = xmlStrdup(a11);
  }
  if (cur) {
    *(void *)(v26 + 48) = xmlStrdup(cur);
  }
  if (a13) {
    *(void *)(v26 + 56) = xmlStrdup(a13);
  }
  *(_DWORD *)(v26 + 64) = a14;
  *(_DWORD *)(v26 + 68) = a15;
  *(void *)(v26 + 72) = v66;
  *(void *)(v26 + 80) = a5;
  if ((xmlError *)v26 != __xmlLastError())
  {
    Error = __xmlLastError();
    xmlCopyError((xmlErrorPtr)v26, Error);
  }

  if (v65) {
    return (_DWORD *)v65(a3, v26);
  }
  if (a2 || !v27)
  {
    if (a2) {
      goto LABEL_107;
    }
    xmlEntityPtr result = __xmlGenericError();
    a2 = *(void (**)(void *, const char *, ...))result;
    if (!v27)
    {
      xmlEntityPtr result = __xmlGenericErrorContext();
      a3 = *(void **)result;
      goto LABEL_106;
    }

    if (v4 >> 11 >= 0x1B
      && (v4 - 57344) >> 1 >= 0xFFF
      && (v4 - 0x10000) >= 0x100000)
    {
      htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", v4);
    }

    return v4;
  }

  int v5 = *(void **)(a1 + 56);
  unint64_t v6 = (const xmlChar *)v5[4];
  if (*(char *)v6 < 0)
  {
    if (v5[10]) {
      goto LABEL_11;
    }
    if (!*v5) {
      goto LABEL_11;
    }
    if (*(void *)(*v5 + 24LL)) {
      goto LABEL_11;
    }
    int v16 = (_BYTE *)v5[5];
    if (!v16) {
      goto LABEL_11;
    }
    if (*v16) {
      goto LABEL_11;
    }
    BOOL v17 = xmlStrcasestr(v6, (const xmlChar *)"HTTP-EQUIV");
    if (!v17) {
      goto LABEL_11;
    }
    BOOL v18 = xmlStrcasestr(v17, (const xmlChar *)"CONTENT");
    if (!v18) {
      goto LABEL_11;
    }
    uint64_t v19 = xmlStrcasestr(v18, (const xmlChar *)"CHARSET=");
    if (!v19) {
      goto LABEL_11;
    }
    for (uint64_t i = 0LL; ; ++i)
    {
      uint64_t v21 = v19[i + 8];
      if ((v21 - 48) >= 0xA && (v21 & 0xFFFFFFDF) - 65 >= 0x1A)
      {
        uint64_t v23 = v21 - 45;
        uint64_t v24 = v23 > 0x32;
        int v25 = (1LL << v23) & 0x4000000002005LL;
        if (v24 || v25 == 0) {
          break;
        }
      }
    }

    if (i && (unsigned int v29 = xmlStrndup(v19 + 8, i)) != 0LL)
    {
      unsigned __int8 v30 = (const char *)v29;
      int v31 = *(void *)(a1 + 56);
      int v32 = *(void **)(v31 + 80);
      if (v32)
      {
        xmlFree(v32);
        int v31 = *(void *)(a1 + 56);
      }

      *(void *)(v31 + 80) = v30;
      CharEncodingHandler = xmlFindCharEncodingHandler(v30);
      if (CharEncodingHandler)
      {
        handler = CharEncodingHandler;
        if (xmlStrEqual((const xmlChar *)CharEncodingHandler->name, (const xmlChar *)"UTF-8")
          || (xmlSwitchToEncoding((xmlParserCtxtPtr)a1, handler) & 0x80000000) == 0)
        {
          goto LABEL_17;
        }

        if (*(_DWORD *)(a1 + 136)) {
          int v7 = *(_DWORD *)(a1 + 136);
        }
        else {
          int v7 = 6003;
        }
        int v8 = "htmlCheckEncoding: error switching to encoding '%s'\n";
        int v9 = (_DWORD *)a1;
      }

      else
      {
        int v8 = "Unsupported encoding %s";
        int v9 = (_DWORD *)a1;
        int v7 = 81;
      }

      unsigned int v10 = (const xmlChar *)v30;
    }

    else
    {
LABEL_11:
      if ((xmlSwitchEncoding((xmlParserCtxtPtr)a1, XML_CHAR_ENCODING_8859_1) & 0x80000000) == 0)
      {
LABEL_17:
        *(_DWORD *)(a1 + 408) = 1;
        goto LABEL_18;
      }

      if (*(_DWORD *)(a1 + 136)) {
        int v7 = *(_DWORD *)(a1 + 136);
      }
      else {
        int v7 = 6003;
      }
      int v8 = "htmlCheckEncoding: error switching to encoding 'ISO-8859-1'\n";
      int v9 = (_DWORD *)a1;
      unsigned int v10 = 0LL;
    }

    htmlParseErr(v9, v7, v8, v10, 0LL);
    goto LABEL_17;
  }

  *a2 = 1;
  uint64_t v4 = *v6;
  if (!*v6 && (unint64_t)v6 < v5[5])
  {
    htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", 0);
    return 32LL;
  }

  return v4;
}

            if (a3) {
              *(void *)int v16 = sax;
            }
            if (v31)
            {
              *(void *)(v16 + 456) = 0LL;
              *(_OWORD *)(v16 + 544) = 0u;
              *(void *)(a2 + 152) = *(void *)(v16 + 152);
              *(_OWORD *)(a2 + 112) = *(_OWORD *)(v16 + 112);
              *(void *)(a2 + 128) = *(void *)(v16 + 128);
            }

            *(void *)(v16 + 112) = 0LL;
            *(void *)(v16 + 120) = 0LL;
            *(void *)(v16 + 128) = 0LL;
LABEL_77:
            xmlFreeParserCtxt((xmlParserCtxtPtr)v16);
            *p_intSubset = 0LL;
            p_intSubset[1] = 0LL;
            xmlFreeDoc(v19);
            return v14;
          }

          xmlFreeParserCtxt((xmlParserCtxtPtr)v16);
        }

        else
        {
          return 27LL;
        }
      }
    }
  }

  return v14;
}

    uint64_t v23 = xmlNewNsPropEatName((xmlNodePtr)ctxt[10], v20, v8, 0LL);
    if (v23)
    {
      if (*((_DWORD *)ctxt + 7) || *((_DWORD *)ctxt + 13))
      {
        if (a3)
        {
          uint64_t v24 = xmlNewDocText((const xmlDoc *)ctxt[2], a3);
          v23->children = v24;
          v23->last = v24;
          if (v24) {
            v24->parent = (_xmlNode *)v23;
          }
        }
      }

      else
      {
        NodeList = xmlStringGetNodeList((const xmlDoc *)ctxt[2], a3);
        v23->children = NodeList;
        if (NodeList)
        {
          do
          {
            uint64_t v26 = NodeList;
            NodeList->parent = (_xmlNode *)v23;
            NodeList = NodeList->next;
          }

          while (NodeList);
          v23->last = v26;
        }
      }
    }

    if (!*((_DWORD *)ctxt + 13)
      && *((_DWORD *)ctxt + 39)
      && *((_DWORD *)ctxt + 6)
      && (char v27 = (xmlDocPtr)ctxt[2]) != 0LL
      && v27->intSubset)
    {
      if (*((_DWORD *)ctxt + 7))
      {
        uint64_t v28 = (xmlValidCtxt *)(ctxt + 20);
      }

      else
      {
        ++*((_DWORD *)ctxt + 98);
        unsigned int v29 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0);
        --*((_DWORD *)ctxt + 98);
        if (v29)
        {
          unsigned __int8 v30 = v29;
          int v31 = xmlValidNormalizeAttributeValue((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], cur, v29);
          if (v31)
          {
            int v32 = v31;
            xmlFree(v30);
            unsigned __int8 v30 = v32;
          }

          *((_DWORD *)ctxt + 38) &= xmlValidateOneAttribute( (xmlValidCtxtPtr)(ctxt + 20),  (xmlDocPtr)ctxt[2],  (xmlNodePtr)ctxt[10],  v23,  v30);
          ((void (*)(xmlChar *))xmlFree)(v30);
          goto LABEL_102;
        }

        uint64_t v28 = (xmlValidCtxt *)(ctxt + 20);
        char v27 = (xmlDocPtr)ctxt[2];
      }

      *((_DWORD *)ctxt + 38) &= xmlValidateOneAttribute(v28, v27, (xmlNodePtr)ctxt[10], v23, a3);
    }

    else
    {
      if ((ctxt[54] & 8) != 0) {
        goto LABEL_102;
      }
      if (*((_DWORD *)ctxt + 7))
      {
        if (*((_DWORD *)ctxt + 84)) {
          goto LABEL_102;
        }
      }

      else if (*((_DWORD *)ctxt + 37) == 2)
      {
        goto LABEL_102;
      }

      if (xmlStrEqual(cur, (const xmlChar *)"xml:id"))
      {
        if (xmlValidateNCName(a3, 1)) {
          xmlErrValid(ctxt, 539, (uint64_t)"xml:id : attribute value %s is not an NCName\n", (uint64_t)a3, 0LL);
        }
      }

      else if (!xmlIsID((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23))
      {
        if (xmlIsRef((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], v23)) {
          xmlAddRef((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], a3, v23);
        }
        goto LABEL_102;
      }

      xmlAddID((xmlValidCtxtPtr)(ctxt + 20), (xmlDocPtr)ctxt[2], a3, v23);
    }

void xmlResetError(xmlErrorPtr err)
{
  if (err && err->code)
  {
    message = err->message;
    if (message) {
      xmlFree(message);
    }
    file = err->file;
    if (file) {
      xmlFree(file);
    }
    str1 = err->str1;
    if (str1) {
      xmlFree(str1);
    }
    str2 = err->str2;
    if (str2) {
      xmlFree(str2);
    }
    str3 = err->str3;
    if (str3) {
      xmlFree(str3);
    }
    err->node = 0LL;
    *(_OWORD *)&err->str2 = 0u;
    *(_OWORD *)&err->int1 = 0u;
    *(_OWORD *)&err->level = 0u;
    *(_OWORD *)&err->line = 0u;
    *(_OWORD *)&err->domain = 0u;
    err->code = 0;
  }

int xmlCopyError(xmlErrorPtr from, xmlErrorPtr to)
{
  int result = -1;
  if (from && to)
  {
    int v5 = (char *)xmlStrdup((const xmlChar *)from->message);
    unint64_t v6 = (char *)xmlStrdup((const xmlChar *)from->file);
    int v7 = (char *)xmlStrdup((const xmlChar *)from->str1);
    int v8 = (char *)xmlStrdup((const xmlChar *)from->str2);
    int v9 = (char *)xmlStrdup((const xmlChar *)from->str3);
    message = to->message;
    if (message) {
      xmlFree(message);
    }
    file = to->file;
    if (file) {
      xmlFree(file);
    }
    str1 = to->str1;
    if (str1) {
      xmlFree(str1);
    }
    str2 = to->str2;
    if (str2) {
      xmlFree(str2);
    }
    str3 = to->str3;
    if (str3) {
      xmlFree(str3);
    }
    int result = 0;
    *(void *)&to->domain = *(void *)&from->domain;
    to->level = from->level;
    to->line = from->line;
    to->node = from->node;
    *(void *)&to->int1 = *(void *)&from->int1;
    *(_OWORD *)&to->ctxt = *(_OWORD *)&from->ctxt;
    to->message = v5;
    to->file = v6;
    to->str1 = v7;
    to->str2 = v8;
    to->str3 = v9;
  }

  return result;
}

void xmlParserError(void *ctx, const char *msg, ...)
{
  if (ctx)
  {
    uint64_t v4 = (xmlParserInput *)*((void *)ctx + 7);
    if (v4)
    {
      if (v4->filename || (int v5 = *((_DWORD *)ctx + 16), v6 = __OFSUB__(v5, 2), v7 = v5 - 2, (v7 < 0) ^ v6))
      {
        int v8 = (xmlParserInput *)*((void *)ctx + 7);
        uint64_t v4 = 0LL;
      }

      else
      {
        int v8 = *(xmlParserInput **)(*((void *)ctx + 9) + 8LL * v7);
      }
    }

    else
    {
      int v8 = 0LL;
    }

    input = v8;
    xmlParserPrintFileInfo(v8);
  }

  else
  {
    input = 0LL;
    uint64_t v4 = 0LL;
  }

  xmlGenericErrorFunc v9 = *__xmlGenericError();
  unsigned int v10 = __xmlGenericErrorContext();
  v9(*v10, "error: ");
  int v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    int v12 = -1;
    int v13 = 150;
    do
    {
      int v14 = v11;
      if (v13 > 63999) {
        break;
      }
      int v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        BOOL v16 = v12 == v15;
        int v12 = v15;
        if (v16) {
          break;
        }
      }

      int v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      int v11 = (char *)xmlRealloc(v14, v13);
    }

    while (v11);
  }

  else
  {
    int v14 = 0LL;
  }

  xmlGenericErrorFunc v18 = *__xmlGenericError();
  uint64_t v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14) {
    xmlFree(v14);
  }
  if (ctx)
  {
    xmlParserPrintFileContext(input);
    if (v4)
    {
      xmlParserPrintFileInfo(v4);
      xmlGenericErrorFunc v20 = *__xmlGenericError();
      uint64_t v21 = __xmlGenericErrorContext();
      v20(*v21, "\n");
      xmlParserPrintFileContext(v4);
    }
  }

void xmlParserWarning(void *ctx, const char *msg, ...)
{
  if (ctx)
  {
    uint64_t v4 = (xmlParserInput *)*((void *)ctx + 7);
    if (v4)
    {
      if (v4->filename || (int v5 = *((_DWORD *)ctx + 16), v6 = __OFSUB__(v5, 2), v7 = v5 - 2, (v7 < 0) ^ v6))
      {
        int v8 = (xmlParserInput *)*((void *)ctx + 7);
        uint64_t v4 = 0LL;
      }

      else
      {
        int v8 = *(xmlParserInput **)(*((void *)ctx + 9) + 8LL * v7);
      }
    }

    else
    {
      int v8 = 0LL;
    }

    input = v8;
    xmlParserPrintFileInfo(v8);
  }

  else
  {
    input = 0LL;
    uint64_t v4 = 0LL;
  }

  xmlGenericErrorFunc v9 = *__xmlGenericError();
  unsigned int v10 = __xmlGenericErrorContext();
  v9(*v10, "warning: ");
  int v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    int v12 = -1;
    int v13 = 150;
    do
    {
      int v14 = v11;
      if (v13 > 63999) {
        break;
      }
      int v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        BOOL v16 = v12 == v15;
        int v12 = v15;
        if (v16) {
          break;
        }
      }

      int v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      int v11 = (char *)xmlRealloc(v14, v13);
    }

    while (v11);
  }

  else
  {
    int v14 = 0LL;
  }

  xmlGenericErrorFunc v18 = *__xmlGenericError();
  uint64_t v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14) {
    xmlFree(v14);
  }
  if (ctx)
  {
    xmlParserPrintFileContext(input);
    if (v4)
    {
      xmlParserPrintFileInfo(v4);
      xmlGenericErrorFunc v20 = *__xmlGenericError();
      uint64_t v21 = __xmlGenericErrorContext();
      v20(*v21, "\n");
      xmlParserPrintFileContext(v4);
    }
  }

void xmlParserValidityError(void *ctx, const char *msg, ...)
{
  int v4 = xmlStrlen((const xmlChar *)msg);
  if (v4 < 2 || msg[v4 - 2] == 58)
  {
    int v5 = 0LL;
    char v6 = 1;
  }

  else
  {
    if (ctx)
    {
      int v5 = (xmlParserInput *)*((void *)ctx + 7);
      if (!v5->filename)
      {
        int v7 = *((_DWORD *)ctx + 16);
        BOOL v8 = __OFSUB__(v7, 2);
        int v9 = v7 - 2;
        if (v9 < 0 == v8) {
          int v5 = *(xmlParserInput **)(*((void *)ctx + 9) + 8LL * v9);
        }
      }

      if ((xmlParserValidityError_had_info & 1) == 0) {
        xmlParserPrintFileInfo(v5);
      }
    }

    else
    {
      int v5 = 0LL;
    }

    xmlGenericErrorFunc v10 = *__xmlGenericError();
    int v11 = __xmlGenericErrorContext();
    v10(*v11, "validity error: ");
    char v6 = 0;
  }

  xmlParserValidityError_had_info = v6;
  int v12 = (char *)xmlMalloc(0x96uLL);
  if (v12)
  {
    int v13 = -1;
    int v14 = 150;
    do
    {
      int v15 = v12;
      if (v14 > 63999) {
        break;
      }
      int v16 = vsnprintf(v12, v14, msg, va);
      if ((v16 & 0x80000000) == 0 && v16 < v14)
      {
        BOOL v17 = v13 == v16;
        int v13 = v16;
        if (v17) {
          break;
        }
      }

      int v18 = v16 >= 0 ? v16 + 1 : 100;
      v14 += v18;
      int v12 = (char *)xmlRealloc(v15, v14);
    }

    while (v12);
  }

  else
  {
    int v15 = 0LL;
  }

  xmlGenericErrorFunc v19 = *__xmlGenericError();
  xmlGenericErrorFunc v20 = __xmlGenericErrorContext();
  v19(*v20, "%s", v15);
  if (v15) {
    xmlFree(v15);
  }
  if (ctx)
  {
    if (v5) {
      xmlParserPrintFileContext(v5);
    }
  }

void xmlParserValidityWarning(void *ctx, const char *msg, ...)
{
  int v4 = xmlStrlen((const xmlChar *)msg);
  int v5 = 0LL;
  if (ctx && v4)
  {
    if (msg[v4 - 1] == 58)
    {
      int v5 = 0LL;
    }

    else
    {
      int v5 = (xmlParserInput *)*((void *)ctx + 7);
      if (!v5->filename)
      {
        int v6 = *((_DWORD *)ctx + 16);
        BOOL v7 = __OFSUB__(v6, 2);
        int v8 = v6 - 2;
        if (v8 < 0 == v7) {
          int v5 = *(xmlParserInput **)(*((void *)ctx + 9) + 8LL * v8);
        }
      }

      xmlParserPrintFileInfo(v5);
    }
  }

  xmlGenericErrorFunc v9 = *__xmlGenericError();
  xmlGenericErrorFunc v10 = __xmlGenericErrorContext();
  v9(*v10, "validity warning: ");
  int v11 = (char *)xmlMalloc(0x96uLL);
  if (v11)
  {
    int v12 = -1;
    int v13 = 150;
    do
    {
      int v14 = v11;
      if (v13 > 63999) {
        break;
      }
      int v15 = vsnprintf(v11, v13, msg, va);
      if ((v15 & 0x80000000) == 0 && v15 < v13)
      {
        BOOL v16 = v12 == v15;
        int v12 = v15;
        if (v16) {
          break;
        }
      }

      int v17 = v15 >= 0 ? v15 + 1 : 100;
      v13 += v17;
      int v11 = (char *)xmlRealloc(v14, v13);
    }

    while (v11);
  }

  else
  {
    int v14 = 0LL;
  }

  xmlGenericErrorFunc v18 = *__xmlGenericError();
  xmlGenericErrorFunc v19 = __xmlGenericErrorContext();
  v18(*v19, "%s", v14);
  if (v14) {
    xmlFree(v14);
  }
  if (ctx) {
    xmlParserPrintFileContext(v5);
  }
}

uint64_t xmlReportError( uint64_t result, uint64_t a2, const xmlChar *a3, void (*a4)(void *, const char *, ...), uint64_t a5)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (result)
  {
    xmlGenericErrorFunc v6 = a4;
    uint64_t v9 = result;
    if (!a4)
    {
      xmlGenericErrorFunc v6 = *__xmlGenericError();
      int result = (uint64_t)__xmlGenericErrorContext();
      a5 = *(void *)result;
    }

    if (*(_DWORD *)(v9 + 4))
    {
      int v10 = *(_DWORD *)(v9 + 32);
      uint64_t v11 = *(void *)(v9 + 80);
      if (v11 && *(_DWORD *)(v11 + 8) == 1) {
        int v12 = *(const char **)(v11 + 16);
      }
      else {
        int v12 = 0LL;
      }
      unsigned int v13 = *(_DWORD *)v9;
      uint64_t v14 = *(int *)(v9 + 16);
      int v28 = *(_DWORD *)(v9 + 32);
      if (a2)
      {
        uint64_t v15 = *(void *)(a2 + 56);
        if (!v15)
        {
          uint64_t v16 = 0LL;
          goto LABEL_28;
        }

        if (*(void *)(v15 + 8))
        {
          uint64_t v16 = *(void *)(a2 + 56);
          uint64_t v15 = 0LL;
LABEL_13:
          int v17 = "%s:%d: ";
LABEL_14:
          v6((void *)a5, v17);
          goto LABEL_28;
        }

        int v19 = *(_DWORD *)(a2 + 64);
        BOOL v20 = __OFSUB__(v19, 2);
        int v21 = v19 - 2;
        if (v21 < 0 != v20)
        {
          uint64_t v16 = *(void *)(a2 + 56);
          uint64_t v15 = 0LL;
        }

        else
        {
          uint64_t v16 = *(void *)(*(void *)(a2 + 72) + 8LL * v21);
          if (!v16) {
            goto LABEL_28;
          }
          if (*(void *)(v16 + 8)) {
            goto LABEL_13;
          }
        }

        if (v10 && v13 == 1)
        {
          int v17 = "Entity: line %d: ";
          goto LABEL_14;
        }

uint64_t __xmlSimpleError(int a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 != 2) {
    return __xmlRaiseError(0, 0, 0, 0, a3, a1, a2, 2, 0LL, 0, a5, 0LL, 0LL, 0, (unsigned __int128)0LL >> 96, a4);
  }
  if (a5)
  {
    int v8 = "Memory allocation failed : %s\n";
    __int128 v7 = 0uLL;
    *(_OWORD *)xmlGenericErrorFunc v6 = (unint64_t)a5;
  }

  else
  {
    int v8 = "Memory allocation failed\n";
    *(_OWORD *)xmlGenericErrorFunc v6 = 0u;
    __int128 v7 = 0u;
  }

  return __xmlRaiseError( 0,  0,  0,  0,  a3,  a1,  2,  3,  0LL,  0,  v6[0],  (xmlChar *)v6[1],  (xmlChar *)v7,  SDWORD2(v7),  SHIDWORD(v7),  (uint64_t)v8);
}

xmlErrorPtr xmlGetLastError(void)
{
  if (__xmlLastError()->code) {
    return __xmlLastError();
  }
  else {
    return 0LL;
  }
}

void xmlResetLastError(void)
{
  if (__xmlLastError()->code)
  {
    Error = __xmlLastError();
    xmlResetError(Error);
  }

xmlErrorPtr xmlCtxtGetLastError(xmlErrorPtr ctx)
{
  if (ctx)
  {
    if (HIDWORD(ctx[6].ctxt)) {
      return (xmlErrorPtr)((char *)ctx + 600);
    }
    else {
      return 0LL;
    }
  }

  return ctx;
}

void xmlCtxtResetLastError(void *ctx)
{
  if (ctx)
  {
    *((_DWORD *)ctx + 34) = 0;
    if (*((_DWORD *)ctx + 151)) {
      xmlResetError((xmlErrorPtr)((char *)ctx + 600));
    }
  }

void xmlInitGlobals(void)
{
}

xmlMutexPtr _xmlInitGlobalsOnce()
{
  xmlMutexPtr result = xmlNewMutex();
  xmlThrDefMutex = (uint64_t)result;
  return result;
}

void xmlCleanupGlobals(void)
{
  if (xmlThrDefMutex)
  {
    xmlFreeMutex((xmlMutexPtr)xmlThrDefMutex);
    xmlThrDefMutex = 0LL;
  }

  __xmlGlobalInitMutexDestroy();
}

void *xmlMallocZero(size_t __size)
{
  xmlMutexPtr result = calloc(1uLL, __size);
  if (!result) {
    abort();
  }
  return result;
}

void *xmlReallocChecked(void *a1, size_t a2)
{
  xmlMutexPtr result = realloc(a1, a2);
  if (!result) {
    abort();
  }
  return result;
}

void xmlInitializeGlobalState(xmlGlobalStatePtr gs)
{
  xmlGenericErrorFunc v2 = (xmlMutex *)xmlThrDefMutex;
  if (!xmlThrDefMutex)
  {
    pthread_once(&once_control_1, (void (*)(void))_xmlInitGlobalsOnce);
    xmlGenericErrorFunc v2 = (xmlMutex *)xmlThrDefMutex;
  }

  xmlMutexLock(v2);
  initdocbDefaultSAXHandler(&gs->docbDefaultSAXHandler);
  inithtmlDefaultSAXHandler(&gs->htmlDefaultSAXHandler);
  gs->oldXMLWDcompatibility = 0;
  gs->xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;
  gs->xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;
  initxmlDefaultSAXHandler(&gs->xmlDefaultSAXHandler, 1);
  gs->xmlDefaultSAXLocator.getSystemId = xmlSAX2GetSystemId;
  gs->xmlDefaultSAXLocator.getLineNumber = xmlSAX2GetLineNumber;
  gs->xmlDefaultSAXLocator.getColumnNumber = xmlSAX2GetColumnNumber;
  gs->xmlDoValidityCheckingDefaultValue = xmlDoValidityCheckingDefaultValueThrDef;
  gs->xmlFree = (xmlFreeFunc)MEMORY[0x1895FB398];
  gs->xmlMalloc = (xmlMallocFunc)xmlMallocZero;
  gs->xmlMallocAtomic = (xmlMallocFunc)xmlMallocZero;
  gs->xmlRealloc = (xmlReallocFunc)xmlReallocChecked;
  gs->xmlMemStrdup = (xmlStrdupFunc)xmlStrdup;
  gs->xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;
  gs->xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;
  gs->xmlTreeIndentString = (const char *)xmlTreeIndentStringThrDef;
  gs->xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;
  gs->xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;
  gs->xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;
  gs->xmlParserDebugEntities = xmlParserDebugEntitiesThrDef;
  gs->xmlParserVersion = "20913";
  gs->xmlDefaultSAXLocator.getPublicId = xmlSAX2GetPublicId;
  gs->xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;
  gs->xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;
  gs->xmlSubstituteEntitiesDefaultValue = xmlSubstituteEntitiesDefaultValueThrDef;
  gs->xmlGenericError = (xmlGenericErrorFunc)xmlGenericErrorThrDef;
  gs->xmlStructuredError = (xmlStructuredErrorFunc)xmlStructuredErrorThrDef;
  gs->xmlGenericErrorContext = (void *)xmlGenericErrorContextThrDef;
  gs->xmlStructuredErrorContext = (void *)xmlStructuredErrorContextThrDef;
  gs->xmlRegisterNodeDefaultValue = (xmlRegisterNodeFunc)xmlRegisterNodeDefaultValueThrDef;
  gs->xmlDeregisterNodeDefaultValue = (xmlDeregisterNodeFunc)xmlDeregisterNodeDefaultValueThrDef;
  gs->xmlParserInputBufferCreateFilenameValue = (xmlParserInputBufferCreateFilenameFunc)xmlParserInputBufferCreateFilenameValueThrDef;
  gs->xmlOutputBufferCreateFilenameValue = (xmlOutputBufferCreateFilenameFunc)xmlOutputBufferCreateFilenameValueThrDef;
  gs->xmlLastError.node = 0LL;
  *(_OWORD *)&gs->xmlLastError.str2 = 0u;
  *(_OWORD *)&gs->xmlLastError.int1 = 0u;
  *(_OWORD *)&gs->xmlLastError.level = 0u;
  *(_OWORD *)&gs->xmlLastError.line = 0u;
  *(_OWORD *)&gs->xmlLastError.domain = 0u;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
}

void xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler)
{
  xmlGenericErrorContextThrDef = (uint64_t)ctx;
  int v4 = xmlGenericErrorDefaultFunc;
  if (handler) {
    int v4 = handler;
  }
  xmlGenericErrorThrDef = (uint64_t)v4;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
}

void xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler)
{
  xmlStructuredErrorContextThrDef = (uint64_t)ctx;
  xmlStructuredErrorThrDef = (uint64_t)handler;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
}

xmlRegisterNodeFunc xmlRegisterNodeDefault(xmlRegisterNodeFunc func)
{
  uint64_t v1 = (void (__cdecl *)(xmlNodePtr))xmlRegisterNodeDefaultValue;
  __xmlRegisterCallbacks = 1;
  xmlRegisterNodeDefaultValue = (uint64_t)func;
  return v1;
}

xmlRegisterNodeFunc xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func)
{
  xmlGenericErrorFunc v2 = (void (__cdecl *)(xmlNodePtr))xmlRegisterNodeDefaultValueThrDef;
  __xmlRegisterCallbacks = 1;
  xmlRegisterNodeDefaultValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlDeregisterNodeFunc xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)
{
  uint64_t v1 = (void (__cdecl *)(xmlNodePtr))xmlDeregisterNodeDefaultValue;
  __xmlRegisterCallbacks = 1;
  xmlDeregisterNodeDefaultValue = (uint64_t)func;
  return v1;
}

xmlDeregisterNodeFunc xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func)
{
  xmlGenericErrorFunc v2 = (void (__cdecl *)(xmlNodePtr))xmlDeregisterNodeDefaultValueThrDef;
  __xmlRegisterCallbacks = 1;
  xmlDeregisterNodeDefaultValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlParserInputBufferCreateFilenameFunc xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func)
{
  if (xmlParserInputBufferCreateFilenameValueThrDef) {
    xmlGenericErrorFunc v2 = (xmlParserInputBufferPtr (__cdecl *)(const char *, xmlCharEncoding))xmlParserInputBufferCreateFilenameValueThrDef;
  }
  else {
    xmlGenericErrorFunc v2 = __xmlParserInputBufferCreateFilename;
  }
  xmlParserInputBufferCreateFilenameValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlOutputBufferCreateFilenameFunc xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)
{
  if (xmlOutputBufferCreateFilenameValueThrDef) {
    xmlGenericErrorFunc v2 = (xmlOutputBufferPtr (__cdecl *)(const char *, xmlCharEncodingHandlerPtr, int))xmlOutputBufferCreateFilenameValueThrDef;
  }
  else {
    xmlGenericErrorFunc v2 = __xmlOutputBufferCreateFilename;
  }
  xmlOutputBufferCreateFilenameValueThrDef = (uint64_t)func;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlSAXHandlerV1 *__docbDefaultSAXHandler(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXHandlerV1 *)docbDefaultSAXHandler;
  }
  else {
    return &xmlGetGlobalState()->docbDefaultSAXHandler;
  }
}

xmlSAXHandlerV1 *__htmlDefaultSAXHandler(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXHandlerV1 *)&htmlDefaultSAXHandler;
  }
  else {
    return &xmlGetGlobalState()->htmlDefaultSAXHandler;
  }
}

xmlError *__xmlLastError(void)
{
  if (xmlIsMainThread()) {
    return (xmlError *)&xmlLastError;
  }
  else {
    return &xmlGetGlobalState()->xmlLastError;
  }
}

int *__oldXMLWDcompatibility(void)
{
  if (xmlIsMainThread()) {
    return (int *)&oldXMLWDcompatibility;
  }
  else {
    return &xmlGetGlobalState()->oldXMLWDcompatibility;
  }
}

xmlBufferAllocationScheme *__xmlBufferAllocScheme(void)
{
  if (xmlIsMainThread()) {
    return (xmlBufferAllocationScheme *)&xmlBufferAllocScheme;
  }
  else {
    return &xmlGetGlobalState()->xmlBufferAllocScheme;
  }
}

xmlBufferAllocationScheme xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v)
{
  xmlBufferAllocationScheme v2 = xmlBufferAllocSchemeThrDef;
  xmlBufferAllocSchemeThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlDefaultBufferSize(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlDefaultBufferSize;
  }
  else {
    return &xmlGetGlobalState()->xmlDefaultBufferSize;
  }
}

int xmlThrDefDefaultBufferSize(int v)
{
  int v2 = xmlDefaultBufferSizeThrDef;
  xmlDefaultBufferSizeThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlSAXHandlerV1 *__xmlDefaultSAXHandler(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXHandlerV1 *)xmlDefaultSAXHandler;
  }
  else {
    return &xmlGetGlobalState()->xmlDefaultSAXHandler;
  }
}

xmlSAXLocator *__xmlDefaultSAXLocator(void)
{
  if (xmlIsMainThread()) {
    return (xmlSAXLocator *)xmlDefaultSAXLocator;
  }
  else {
    return &xmlGetGlobalState()->xmlDefaultSAXLocator;
  }
}

int *__xmlDoValidityCheckingDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlDoValidityCheckingDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlDoValidityCheckingDefaultValue;
  }
}

int xmlThrDefDoValidityCheckingDefaultValue(int v)
{
  int v2 = xmlDoValidityCheckingDefaultValueThrDef;
  xmlDoValidityCheckingDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlGenericErrorFunc *__xmlGenericError(void)
{
  if (xmlIsMainThread()) {
    return (xmlGenericErrorFunc *)xmlGenericError;
  }
  else {
    return &xmlGetGlobalState()->xmlGenericError;
  }
}

xmlStructuredErrorFunc *__xmlStructuredError(void)
{
  if (xmlIsMainThread()) {
    return (xmlStructuredErrorFunc *)&xmlStructuredError;
  }
  else {
    return &xmlGetGlobalState()->xmlStructuredError;
  }
}

void **__xmlGenericErrorContext(void)
{
  if (xmlIsMainThread()) {
    return (void **)&xmlGenericErrorContext;
  }
  else {
    return &xmlGetGlobalState()->xmlGenericErrorContext;
  }
}

void **__xmlStructuredErrorContext(void)
{
  if (xmlIsMainThread()) {
    return (void **)&xmlStructuredErrorContext;
  }
  else {
    return &xmlGetGlobalState()->xmlStructuredErrorContext;
  }
}

int *__xmlGetWarningsDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlGetWarningsDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlGetWarningsDefaultValue;
  }
}

int xmlThrDefGetWarningsDefaultValue(int v)
{
  int v2 = xmlGetWarningsDefaultValueThrDef;
  xmlGetWarningsDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlIndentTreeOutput(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlIndentTreeOutput;
  }
  else {
    return &xmlGetGlobalState()->xmlIndentTreeOutput;
  }
}

int xmlThrDefIndentTreeOutput(int v)
{
  int v2 = xmlIndentTreeOutputThrDef;
  xmlIndentTreeOutputThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

const char **__xmlTreeIndentString(void)
{
  if (xmlIsMainThread()) {
    return (const char **)&xmlTreeIndentString;
  }
  else {
    return &xmlGetGlobalState()->xmlTreeIndentString;
  }
}

const char *__cdecl xmlThrDefTreeIndentString(const char *v)
{
  int v2 = (const char *)xmlTreeIndentStringThrDef;
  xmlTreeIndentStringThrDef = (uint64_t)v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlKeepBlanksDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlKeepBlanksDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlKeepBlanksDefaultValue;
  }
}

int xmlThrDefKeepBlanksDefaultValue(int v)
{
  int v2 = xmlKeepBlanksDefaultValueThrDef;
  xmlKeepBlanksDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlLineNumbersDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlLineNumbersDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlLineNumbersDefaultValue;
  }
}

int xmlThrDefLineNumbersDefaultValue(int v)
{
  int v2 = xmlLineNumbersDefaultValueThrDef;
  xmlLineNumbersDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlLoadExtDtdDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlLoadExtDtdDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlLoadExtDtdDefaultValue;
  }
}

int xmlThrDefLoadExtDtdDefaultValue(int v)
{
  int v2 = xmlLoadExtDtdDefaultValueThrDef;
  xmlLoadExtDtdDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlParserDebugEntities(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlParserDebugEntities;
  }
  else {
    return &xmlGetGlobalState()->xmlParserDebugEntities;
  }
}

int xmlThrDefParserDebugEntities(int v)
{
  int v2 = xmlParserDebugEntitiesThrDef;
  xmlParserDebugEntitiesThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

const char **__xmlParserVersion(void)
{
  if (xmlIsMainThread()) {
    return (const char **)&xmlParserVersion;
  }
  else {
    return (const char **)xmlGetGlobalState();
  }
}

int *__xmlPedanticParserDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlPedanticParserDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlPedanticParserDefaultValue;
  }
}

int xmlThrDefPedanticParserDefaultValue(int v)
{
  int v2 = xmlPedanticParserDefaultValueThrDef;
  xmlPedanticParserDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlSaveNoEmptyTags(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlSaveNoEmptyTags;
  }
  else {
    return &xmlGetGlobalState()->xmlSaveNoEmptyTags;
  }
}

int xmlThrDefSaveNoEmptyTags(int v)
{
  int v2 = xmlSaveNoEmptyTagsThrDef;
  xmlSaveNoEmptyTagsThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

int *__xmlSubstituteEntitiesDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (int *)&xmlSubstituteEntitiesDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlSubstituteEntitiesDefaultValue;
  }
}

int xmlThrDefSubstituteEntitiesDefaultValue(int v)
{
  int v2 = xmlSubstituteEntitiesDefaultValueThrDef;
  xmlSubstituteEntitiesDefaultValueThrDef = v;
  xmlMutexUnlock((xmlMutexPtr)xmlThrDefMutex);
  return v2;
}

xmlRegisterNodeFunc *__xmlRegisterNodeDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlRegisterNodeFunc *)&xmlRegisterNodeDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlRegisterNodeDefaultValue;
  }
}

xmlDeregisterNodeFunc *__xmlDeregisterNodeDefaultValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlDeregisterNodeFunc *)&xmlDeregisterNodeDefaultValue;
  }
  else {
    return &xmlGetGlobalState()->xmlDeregisterNodeDefaultValue;
  }
}

xmlParserInputBufferCreateFilenameFunc *__xmlParserInputBufferCreateFilenameValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlParserInputBufferCreateFilenameFunc *)&xmlParserInputBufferCreateFilenameValue;
  }
  else {
    return &xmlGetGlobalState()->xmlParserInputBufferCreateFilenameValue;
  }
}

xmlOutputBufferCreateFilenameFunc *__xmlOutputBufferCreateFilenameValue(void)
{
  if (xmlIsMainThread()) {
    return (xmlOutputBufferCreateFilenameFunc *)&xmlOutputBufferCreateFilenameValue;
  }
  else {
    return &xmlGetGlobalState()->xmlOutputBufferCreateFilenameValue;
  }
}

xmlHashTablePtr xmlHashCreate(int size)
{
  int v2 = xmlMalloc(0x20uLL);
  xmlEntityPtr v3 = v2;
  if (v2)
  {
    if (size >= 1) {
      unsigned int v4 = size;
    }
    else {
      unsigned int v4 = 256;
    }
    *((void *)v2 + 2) = 0LL;
    v2[2] = v4;
    v2[3] = 0;
    size_t v5 = 48LL * v4;
    xmlGenericErrorFunc v6 = xmlMalloc(v5);
    *(void *)xmlEntityPtr v3 = v6;
    if (v6)
    {
      bzero(v6, v5);
      v3[6] = __xmlRandom();
    }

    else
    {
      xmlFree(v3);
      return 0LL;
    }
  }

  return (xmlHashTablePtr)v3;
}

xmlHashTablePtr xmlHashCreateDict(int size, xmlDictPtr dict)
{
  xmlHashTablePtr v3 = xmlHashCreate(size);
  unsigned int v4 = v3;
  if (v3)
  {
    *((void *)v3 + 2) = dict;
    xmlDictReference(dict);
  }

  return v4;
}

void xmlHashFree(xmlHashTablePtr table, xmlHashDeallocator f)
{
  if (table)
  {
    xmlHashTablePtr v3 = *(char **)table;
    if (v3)
    {
      int v4 = *((_DWORD *)table + 2);
      int v5 = *((_DWORD *)table + 3);
      if (v4 >= 1 && v5 >= 1)
      {
        uint64_t v8 = 0LL;
        do
        {
          uint64_t v9 = *(char **)table;
          if (*(_DWORD *)(*(void *)table + 48 * v8 + 40)) {
            BOOL v10 = v9 == 0LL;
          }
          else {
            BOOL v10 = 1;
          }
          if (!v10)
          {
            char v11 = 0;
            int v12 = &v9[48 * v8];
            do
            {
              unsigned int v13 = *(char **)v12;
              if (f)
              {
                uint64_t v14 = *((void *)v12 + 4);
                if (v14) {
                  ((void (*)(uint64_t, void))f)(v14, *((void *)v12 + 1));
                }
              }

              if (!*((void *)table + 2))
              {
                uint64_t v15 = (void *)*((void *)v12 + 1);
                if (v15) {
                  xmlFree(v15);
                }
                uint64_t v16 = (void *)*((void *)v12 + 2);
                if (v16) {
                  xmlFree(v16);
                }
                int v17 = (void *)*((void *)v12 + 3);
                if (v17) {
                  xmlFree(v17);
                }
              }

              *((void *)v12 + 4) = 0LL;
              if ((v11 & 1) != 0) {
                xmlFree(v12);
              }
              --v5;
              char v11 = 1;
              int v12 = v13;
            }

            while (v13);
            int v4 = *((_DWORD *)table + 2);
          }

          ++v8;
        }

        while (v8 < v4 && v5 > 0);
        xmlHashTablePtr v3 = *(char **)table;
      }

      xmlFree(v3);
    }

    xmlGenericErrorFunc v18 = (xmlDict *)*((void *)table + 2);
    if (v18) {
      xmlDictFree(v18);
    }
    xmlFree(table);
  }

void xmlHashDefaultDeallocator(void *entry, const xmlChar *name)
{
}

int xmlHashAddEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata)
{
  return xmlHashAddEntry3(table, name, 0LL, 0LL, userdata);
}

int xmlHashAddEntry3( xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, void *userdata)
{
  int v5 = -1;
  if (table)
  {
    xmlGenericErrorFunc v6 = (xmlChar *)name;
    if (name)
    {
      if (*((_DWORD *)table + 3) != 0x7FFFFFFF)
      {
        char v11 = (xmlDict *)*((void *)table + 2);
        if (!v11
          || (xmlDictOwns(v11, name) || (xmlGenericErrorFunc v6 = (xmlChar *)xmlDictLookup(*((xmlDictPtr *)table + 2), v6, -1)) != 0LL)
          && (!name2
           || xmlDictOwns(*((xmlDictPtr *)table + 2), name2)
           || (name2 = xmlDictLookup(*((xmlDictPtr *)table + 2), name2, -1)) != 0LL)
          && (!name3
           || xmlDictOwns(*((xmlDictPtr *)table + 2), name3)
           || (name3 = xmlDictLookup(*((xmlDictPtr *)table + 2), name3, -1)) != 0LL))
        {
          int v12 = (void *)(*(void *)table + 48 * xmlHashComputeKey((uint64_t)table, v6, name2, name3));
          int v13 = *((_DWORD *)v12 + 10);
          if (v13)
          {
            uint64_t v14 = *(void **)v12;
            unint64_t v15 = 0LL;
            if (*((void *)table + 2))
            {
              if (v14)
              {
                do
                {
                  uint64_t v16 = (xmlChar **)v12;
                  int v12 = v14;
                  if (v16[1] == v6 && v16[2] == name2 && v16[3] == name3) {
                    return -1;
                  }
                  ++v15;
                  uint64_t v14 = (void *)*v14;
                }

                while (*(void *)v12);
              }

              if (*((xmlChar **)v12 + 1) == v6
                && *((const xmlChar **)v12 + 2) == name2
                && *((const xmlChar **)v12 + 3) == name3)
              {
                return -1;
              }
            }

            else
            {
              if (v14)
              {
                while (!xmlStrEqual(*((const xmlChar **)v12 + 1), v6)
                     || !xmlStrEqual(*((const xmlChar **)v12 + 2), name2)
                     || !xmlStrEqual(*((const xmlChar **)v12 + 3), name3))
                {
                  ++v15;
                  int v12 = *(void **)v12;
                  if (!*(void *)v12) {
                    goto LABEL_30;
                  }
                }

                return -1;
              }

LABEL_30:
              if (xmlStrEqual(*((const xmlChar **)v12 + 1), v6)
                && xmlStrEqual(*((const xmlChar **)v12 + 2), name2)
                && xmlStrEqual(*((const xmlChar **)v12 + 3), name3))
              {
                return -1;
              }
            }

            int v17 = v12;
            int v12 = xmlMalloc(0x30uLL);
            if (!v12) {
              return -1;
            }
          }

          else
          {
            int v17 = 0LL;
            unint64_t v15 = 0LL;
          }

          if (*((void *)table + 2))
          {
            *((void *)v12 + 1) = v6;
            *((void *)v12 + 2) = name2;
          }

          else
          {
            *((void *)v12 + 1) = xmlStrdup(v6);
            *((void *)v12 + 2) = xmlStrdup(name2);
            name3 = xmlStrdup(name3);
          }

          *((void *)v12 + 3) = name3;
          *((void *)v12 + 4) = userdata;
          *(void *)int v12 = 0LL;
          *((_DWORD *)v12 + 10) = 1;
          if (v13) {
            *int v17 = v12;
          }
          ++*((_DWORD *)table + 3);
          if (v15 >= 9)
          {
            uint64_t v18 = *((unsigned int *)table + 2);
            if ((8 * v18 - 16385) >= 0xFFFFC007)
            {
              int v19 = *(char **)table;
              if (*(void *)table)
              {
                unsigned int v20 = 8 * v18;
                int v21 = xmlMalloc(48LL * (8 * v18));
                *(void *)table = v21;
                if (!v21)
                {
                  int v5 = 0;
                  *(void *)table = v19;
                  return v5;
                }

                bzero(v21, 48LL * v20);
                *((_DWORD *)table + 2) = v20;
                if ((int)v18 >= 1)
                {
                  unsigned int v22 = v19 + 24;
                  uint64_t v23 = v18;
                  do
                  {
                    if (*((_DWORD *)v22 + 4))
                    {
                      unint64_t v24 = xmlHashComputeKey( (uint64_t)table,  *((_BYTE **)v22 - 2),  *((_BYTE **)v22 - 1),  *(_BYTE **)v22);
                      int v25 = (_OWORD *)(*(void *)table + 48 * v24);
                      __int128 v26 = *(_OWORD *)(v22 - 24);
                      __int128 v27 = *(_OWORD *)(v22 + 8);
                      v25[1] = *(_OWORD *)(v22 - 8);
                      v25[2] = v27;
                      _OWORD *v25 = v26;
                      *(void *)(*(void *)table + 48 * v24) = 0LL;
                    }

                    v22 += 48;
                    --v23;
                  }

                  while (v23);
                  do
                  {
                    int v28 = *(_BYTE ***)&v19[48 * v23];
                    if (v28)
                    {
                      do
                      {
                        unsigned int v29 = *v28;
                        unint64_t v30 = xmlHashComputeKey((uint64_t)table, v28[1], v28[2], v28[3]);
                        uint64_t v31 = *(void *)table + 48 * v30;
                        if (*(_DWORD *)(v31 + 40))
                        {
                          *int v28 = *(_BYTE **)v31;
                          *(void *)uint64_t v31 = v28;
                        }

                        else
                        {
                          __int128 v32 = *(_OWORD *)v28;
                          __int128 v33 = *((_OWORD *)v28 + 2);
                          *(_OWORD *)(v31 + 16) = *((_OWORD *)v28 + 1);
                          *(_OWORD *)(v31 + 32) = v33;
                          *(_OWORD *)uint64_t v31 = v32;
                          *(void *)(*(void *)table + 48 * v30) = 0LL;
                          xmlFree(v28);
                        }

                        int v28 = (_BYTE **)v29;
                      }

                      while (v29);
                    }

                    ++v23;
                  }

                  while (v23 != v18);
                }

                xmlFree(v19);
              }
            }
          }

          return 0;
        }
      }
    }
  }

  return v5;
}

    children = children->next;
    if (children) {
      continue;
    }
    break;
  }

  char v11 = xmlParseSystemLiteral(ctxt);
  if (!v11)
  {
    xmlFatalErr(ctxt, 70, 0LL);
    return 0LL;
  }

  return v11;
}

  xmlGROW(a1);
LABEL_31:
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  int v13 = *(void *)(a1 + 56);
  if (!*(_DWORD *)(a1 + 452))
  {
    uint64_t v14 = *(void *)(v13 + 32);
    if (v14 - *(void *)(v13 + 24) >= 501 && *(void *)(v13 + 40) - v14 <= 499)
    {
      xmlSHRINK(a1);
      int v13 = *(void *)(a1 + 56);
    }
  }

  unint64_t v15 = **(unsigned __int8 **)(v13 + 32);
  if (v15 == 41)
  {
    uint64_t v16 = v8;
    goto LABEL_80;
  }

  if (*(_DWORD *)(a1 + 272) == -1)
  {
    int v17 = 0LL;
    uint64_t v16 = v8;
LABEL_78:
    if (v17)
    {
LABEL_79:
      v16->c2 = v17;
      v17->parent = v16;
    }

  xmlRngVErrMemory(a1, (const xmlChar *)"allocating states\n");
  return v10;
}

      if (!v3) {
        return v4;
      }
    }
  }

  return 0LL;
}

  *xmlMutexPtr result = 0;
  return result;
}

    uint64_t v9 = cur->type;
    goto LABEL_31;
  }

    oldNs = 0LL;
    uint64_t v9 = v9->parent;
    if (!v9) {
      return oldNs;
    }
  }

  while (1)
  {
    int v12 = oldNs->href;
    if (v12)
    {
      if (xmlStrEqual(v12, href))
      {
        int v13 = (xmlChar *)oldNs->prefix;
      }
    }

    oldNs = oldNs->next;
    if (!oldNs) {
      goto LABEL_23;
    }
  }

            unint64_t v15 = *(void *)(v15 + 24);
            if (!v15) {
              goto LABEL_65;
            }
          }

          if (*(_DWORD *)v15 != 2) {
            goto LABEL_63;
          }
          unsigned int v20 = *(const xmlChar **)(v15 + 40);
          if (!v20 || xmlStrncmp(v20, qname, len)) {
            goto LABEL_30;
          }
          int v21 = *(const xmlChar **)(v15 + 8);
          goto LABEL_29;
        }

        while (1)
        {
          if (*(_DWORD *)v15 == 4)
          {
            int v25 = *(void *)(v15 + 16);
            if (!v25) {
              goto LABEL_64;
            }
            if (*(_DWORD *)v25 != 1)
            {
              if (*(_DWORD *)v25 != 2)
              {
LABEL_64:
                __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0x17u,  519,  2,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "%s",  (char)"Internal: MIXED struct corrupted\n");
                goto LABEL_65;
              }

              if (!*(void *)(v25 + 40))
              {
                unint64_t v24 = *(const xmlChar **)(v25 + 8);
LABEL_41:
                if (xmlStrEqual(v24, qname)) {
                  goto LABEL_44;
                }
              }
            }
          }

          else
          {
            if (*(_DWORD *)v15 != 2) {
              goto LABEL_64;
            }
            if (!*(void *)(v15 + 40))
            {
              unint64_t v24 = *(const xmlChar **)(v15 + 8);
              goto LABEL_41;
            }
          }

          unint64_t v15 = *(void *)(v15 + 24);
          if (!v15) {
            goto LABEL_65;
          }
        }
      }

      char v11 = *((void *)vstate + 1);
      int v12 = *(const xmlChar **)(v11 + 16);
      int v13 = "Element %s was declared #PCDATA but contains non text nodes\n";
      uint64_t v14 = 529;
LABEL_11:
      uint64_t v16 = 0LL;
LABEL_66:
      xmlErrValidNode((uint64_t *)ctxt, v11, v14, (uint64_t)v13, (uint64_t)v12, v16, 0LL);
LABEL_67:
      uint64_t v9 = 0;
LABEL_45:
      ElemDecl = (xmlElement *)xmlValidGetElemDecl((uint64_t *)v6, (uint64_t)doc, (uint64_t)elem, &v35);
      vstateMax = v6->vstateMax;
      if (!vstateMax || (vstateTab = v6->vstateTab) == 0LL)
      {
        v6->vstateMax = 10;
        vstateTab = (xmlValidState *)xmlMalloc(0xF0uLL);
        v6->vstateTab = vstateTab;
        if (!vstateTab)
        {
          __int128 v33 = "malloc failed";
LABEL_60:
          xmlVErrMemory((uint64_t *)v6, (uint64_t)v33);
          return v9;
        }

        vstateMax = v6->vstateMax;
      }

      vstateNr = v6->vstateNr;
      if (vstateNr < vstateMax) {
        goto LABEL_52;
      }
      vstateTab = (xmlValidState *)xmlRealloc(vstateTab, 48LL * vstateMax);
      if (!vstateTab)
      {
        __int128 v33 = "realloc failed";
        goto LABEL_60;
      }

      vstateNr = v6->vstateNr;
      v6->vstateMax *= 2;
      v6->vstateTab = vstateTab;
LABEL_52:
      unint64_t v30 = (xmlValidState *)((char *)vstateTab + 24 * vstateNr);
      v6->vstate = v30;
      *(void *)unint64_t v30 = ElemDecl;
      *((void *)v30 + 1) = elem;
      if (ElemDecl && ElemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)
      {
        contModel = ElemDecl->contModel;
        if (contModel || (xmlValidBuildContentModel(v6, ElemDecl), (contModel = ElemDecl->contModel) != 0LL))
        {
          __int128 v32 = xmlRegNewExecCtxt(contModel, 0LL, 0LL);
          vstateNr = v6->vstateNr;
          *((void *)v6->vstateTab + 3 * vstateNr + 2) = v32;
        }

        else
        {
          *((void *)v6->vstateTab + 3 * v6->vstateNr + 2) = 0LL;
          xmlErrValidNode( (uint64_t *)v6,  (int)ElemDecl,  1,  (uint64_t)"Failed to build content model regexp for %s\n",  (uint64_t)elem->name,  0LL,  0LL);
          vstateNr = v6->vstateNr;
        }
      }

      v6->vstateNr = vstateNr + 1;
      return v9;
    case 4:
      int v17 = (xmlRegExecCtxt *)*((void *)vstate + 2);
      if (!v17 || (xmlRegExecPushString(v17, qname, 0LL) & 0x80000000) == 0) {
        goto LABEL_45;
      }
      char v11 = *((void *)vstate + 1);
      int v12 = *(const xmlChar **)(v11 + 16);
      int v13 = "Element %s content does not follow the DTD, Misplaced %s\n";
      ctxt = v6;
      uint64_t v14 = 504;
      uint64_t v16 = (xmlChar *)qname;
      goto LABEL_66;
    default:
      goto LABEL_45;
  }

    valid = xmlRegExecPushString(v15, 0LL, 0LL);
LABEL_31:
    xmlRegFreeExecCtxt(v15);
  }

  int v25 = 1LL;
  if (valid == -3 || valid == 1) {
    goto LABEL_71;
  }
  bzero(&v51[1], 0x1387uLL);
  bzero(v50, 0x1387uLL);
  v51[0] = 0;
  xmlSnprintfElementContent((char *)v51, 5000, content, 1);
  __s = 0;
  if (v8)
  {
    __int128 v26 = strlen(&__s);
    if (v26 < 4998)
    {
      __strncat_chk();
      __int128 v33 = v26 + 1;
      while (v33 < 4951)
      {
        int v34 = 5000 - v33;
        switch(*(_DWORD *)(v8 + 8))
        {
          case 1:
            uint64_t v37 = *(void *)(v8 + 48);
            int v38 = *(void *)(v8 + 72);
            if (v38)
            {
              BOOL v39 = *(const xmlChar **)(v38 + 24);
              if (v39)
              {
                int v40 = xmlStrlen(v39);
                if (v37) {
                  uint64_t v41 = 4;
                }
                else {
                  uint64_t v41 = 3;
                }
                if (v34 < v40 + v41) {
                  goto LABEL_67;
                }
                uint64_t v42 = v40;
                __strncat_chk();
                unsigned int v43 = v42 + v33;
                __strncat_chk();
                v33 += v42 + 1;
                int v34 = 4999 - v43;
              }
            }

            int v44 = xmlStrlen(*(const xmlChar **)(v8 + 16));
            if (v37) {
              uint64_t v45 = 3;
            }
            else {
              uint64_t v45 = 2;
            }
            if (v34 < v44 + v45) {
              goto LABEL_67;
            }
            int v46 = v44;
            __strncat_chk();
            v33 += v46;
            if (*(void *)(v8 + 48))
            {
              __strncat_chk();
              v33 += v37 != 0;
            }

            break;
          case 2:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
          case 0xD:
          case 0x12:
          case 0x15:
            int v35 = *(void *)(v8 + 48);
            __strncat_chk();
            uint64_t v36 = v33 + 3;
            if (!*(void *)(v8 + 48)) {
              goto LABEL_64;
            }
            goto LABEL_61;
          case 3:
            if (!xmlIsBlankNode((const xmlNode *)v8)) {
              goto LABEL_60;
            }
            break;
          case 4:
          case 5:
LABEL_60:
            int v35 = *(void *)(v8 + 48);
            __strncat_chk();
            uint64_t v36 = v33 + 5;
            if (*(void *)(v8 + 48))
            {
LABEL_61:
              __strncat_chk();
              if (v35) {
                __int128 v33 = v36 + 1;
              }
              else {
                __int128 v33 = v36;
              }
            }

            else
            {
LABEL_64:
              __int128 v33 = v36;
            }

            break;
          default:
            break;
        }

        uint64_t v8 = *(void *)(v8 + 48);
        if (!v8)
        {
          __strncat_chk();
          v50[4998] = 0;
          goto LABEL_68;
        }
      }

  if (v13 >= a4) {
    uint64_t v36 = a4;
  }
  else {
    uint64_t v36 = v13;
  }
  if (v36 > v14)
  {
    libxml_domnode_binary_insertion_sort_start(a1 + 8 * v12, v14, v36);
    int v12 = *v7;
    uint64_t v14 = v36;
  }

  *(void *)(a5 + 16 * *a6) = v12;
  *(void *)(a5 + 16 * (*a6)++ + 8) = v14;
  uint64_t v37 = *v7 + v14;
  char *v7 = v37;
  if (v37 != a2) {
    return 1LL;
  }
  int v38 = *a6;
  if (*a6 >= 2)
  {
    do
    {
      libxml_domnode_tim_sort_merge(a1, a5, v38, a3);
      *(void *)(a5 + 16 * *a6 - 24) += *(void *)(a5 + 16 * *a6 - 8);
      int v38 = *a6 - 1;
      *a6 = v38;
    }

    while (v38 > 1);
  }

  xmlMutexPtr result = *(void *)(a3 + 8);
  if (result)
  {
    free((void *)result);
    xmlMutexPtr result = 0LL;
    *(void *)(a3 + 8) = 0LL;
  }

  return result;
}

        if (ctxt->error)
        {
          uint64_t v18 = xmlFree;
          goto LABEL_32;
        }

        for (m = ctxt->cur; ; ctxt->cur = m)
        {
          int v21 = *m;
          if (v21 > 0x20 || ((1LL << v21) & 0x100002600LL) == 0) {
            break;
          }
          ++m;
        }

        if (!v10 && v21 == 42)
        {
          uint64_t v23 = 0LL;
          unint64_t v24 = 0;
          BOOL v10 = 0LL;
          ctxt->cur = m + 1;
          char v11 = -1;
          int v25 = 1;
          __int128 v26 = 3;
LABEL_162:
          comp = ctxt->comp;
          int v49 = *((_DWORD *)comp + 4);
          *((_DWORD *)comp + 4) = -1;
          for (n = ctxt->cur + 1; ; ++n)
          {
            uint64_t v51 = *(n - 1);
            if (v51 > 0x20 || ((1LL << v51) & 0x100002600LL) == 0) {
              break;
            }
            ctxt->cur = n;
          }

          if (v51 == 91)
          {
            do
              xmlXPathCompPredicate(ctxt, 0);
            while (*ctxt->cur == 91);
          }

          if ((v25 & 1) == 0)
          {
            xmlXPathCompExprAdd((uint64_t)ctxt, v11, v49, 0x12u, 0, 0, 0, 0LL, 0LL);
            return;
          }

          if (xmlXPathCompExprAdd( (uint64_t)ctxt,  v49,  *((_DWORD *)ctxt->comp + 4),  0xAu,  v17,  v26,  v24,  v23,  v10) != -1) {
            return;
          }
          xmlFree(v23);
          uint64_t v18 = xmlFree;
LABEL_32:
          ((void (*)(xmlChar *))v18)(v10);
          return;
        }

        if (!v10)
        {
          __int128 v32 = xmlXPathParseNCName(ctxt);
          if (!v32) {
            goto LABEL_177;
          }
          BOOL v10 = v32;
          m = ctxt->cur;
          int v21 = *ctxt->cur;
        }

        int v34 = v21 == 13 || v21 - 9 < 2;
        if (v21 == 32) {
          int v34 = 1;
        }
        for (iuint64_t i = m + 1; ; ++ii)
        {
          if (v21 > 0x28) {
            goto LABEL_84;
          }
          if (((1LL << v21) & 0x100002600LL) == 0) {
            break;
          }
          ctxt->cur = ii;
          uint64_t v36 = *ii;
          int v21 = v36;
        }

        if (v21 != 40LL)
        {
LABEL_84:
          int v38 = v21 != 58 || v34;
          if ((v38 & 1) != 0)
          {
            uint64_t v23 = 0LL;
            unint64_t v24 = 0;
            char v11 = -1;
            int v25 = 1;
            __int128 v26 = 5;
          }

          else
          {
            ctxt->cur = ii;
            if (*ii == 42)
            {
              uint64_t v41 = 0LL;
              ctxt->cur = ii + 1;
              __int128 v26 = 3;
            }

            else
            {
              uint64_t v41 = xmlXPathParseNCName(ctxt);
              if (!v41) {
                xmlXPathErr(ctxt, 7);
              }
              __int128 v26 = 5;
            }

            context = ctxt->context;
            if (context && (context->flags & 1) != 0 && !xmlXPathNsLookup(context, v10)) {
              xmlXPathErr(ctxt, 19);
            }
            unint64_t v24 = 0;
            char v11 = -1;
            int v25 = 1;
            uint64_t v23 = v10;
            BOOL v10 = v41;
          }

          goto LABEL_162;
        }

        ctxt->cur = ii;
        if (xmlStrEqual(v10, (const xmlChar *)"comment"))
        {
          uint64_t v37 = 0;
          unint64_t v24 = 8;
LABEL_139:
          for (juint64_t j = ctxt->cur; ; ctxt->cur = jj)
          {
            int v44 = *jj;
            if (v44 > 0x20 || ((1LL << v44) & 0x100002600LL) == 0) {
              break;
            }
            ++jj;
          }

          if (v37)
          {
            xmlFree(v10);
            juint64_t j = ctxt->cur;
            if (*ctxt->cur == 41)
            {
              BOOL v10 = 0LL;
              __int128 v26 = 1;
              goto LABEL_158;
            }

            BOOL v10 = xmlXPathParseLiteral(ctxt);
            if (!v10)
            {
              unint64_t v24 = 7;
              xmlXPathErr(ctxt, 7);
              uint64_t v23 = 0LL;
              char v11 = -1;
              __int128 v26 = 1;
              goto LABEL_161;
            }

            for (juint64_t j = ctxt->cur; ; ctxt->cur = jj)
            {
              int v46 = *jj;
              if (v46 > 0x20 || ((1LL << v46) & 0x100002600LL) == 0) {
                break;
              }
              ++jj;
            }

            __int128 v26 = 2;
            int v44 = *jj;
          }

          else
          {
            __int128 v26 = 1;
          }

          if (v44 != 41)
          {
            xmlFree(v10);
            xmlXPathErr(ctxt, 8);
            uint64_t v23 = 0LL;
            BOOL v10 = 0LL;
            goto LABEL_160;
          }

      return v3;
    case 8:
      xmlXPathRoot((xmlXPathParserContextPtr)a1);
      goto LABEL_29;
    case 9:
      uint64_t v18 = a2[1];
      if (v18 == -1) {
        xmlHashTablePtr v3 = 0LL;
      }
      else {
        xmlHashTablePtr v3 = xmlXPathCompOpEval(a1, *(void *)(v12 + 8) + 56LL * v18);
      }
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v23 = a2[2];
      if (v23 == -1) {
        goto LABEL_39;
      }
      unint64_t v24 = xmlXPathCompOpEval(a1, *(void *)(v12 + 8) + 56LL * v23);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      xmlHashTablePtr v3 = (v24 + v3);
LABEL_39:
      int v25 = xmlXPathCacheNewNodeSet(*(void *)(a1 + 24), *(xmlNodePtr *)(*(void *)(a1 + 24) + 8LL));
      valuePush((xmlXPathParserContextPtr)a1, v25);
      goto LABEL_30;
    case 10:
      int v19 = a2[1];
      if (v19 == -1) {
        goto LABEL_29;
      }
      unsigned int v20 = xmlXPathCompOpEval(a1, *(void *)(v12 + 8) + 56LL * v19);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      xmlHashTablePtr v3 = xmlXPathNodeCollectAndTest((xmlXPathParserContextPtr)a1, (uint64_t)a2, 0LL, a3, 0) + v20;
      goto LABEL_30;
    case 11:
      int v21 = xmlXPathCacheObjectCopy(*(void *)(a1 + 24), *((xmlXPathObjectPtr *)a2 + 3));
      valuePush((xmlXPathParserContextPtr)a1, v21);
LABEL_29:
      xmlHashTablePtr v3 = 0LL;
      goto LABEL_30;
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      goto LABEL_21;
    case 17:
      unsigned int v22 = a2[1];
      if (v22 == -1) {
        xmlHashTablePtr v3 = 0LL;
      }
      else {
        xmlHashTablePtr v3 = xmlXPathCompOpEvalLast(a1, *(void *)(v12 + 8) + 56LL * v22, a3);
      }
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      __int128 v26 = *(void *)(a1 + 32);
      if (v26)
      {
        if (*(_DWORD *)v26 == 1)
        {
          __int128 v27 = *(unsigned int **)(v26 + 8);
          if (v27)
          {
            int v28 = *v27;
          }
        }
      }

      goto LABEL_30;
    default:
      if ((_DWORD)v3) {
LABEL_21:
      }
        xmlHashTablePtr v3 = xmlXPathCompOpEval(a1, a2);
      goto LABEL_30;
  }

int xmlHashAddEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, void *userdata)
{
  return xmlHashAddEntry3(table, name, name2, 0LL, userdata);
}

int xmlHashUpdateEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata, xmlHashDeallocator f)
{
  return xmlHashUpdateEntry3(table, name, 0LL, 0LL, userdata, f);
}

int xmlHashUpdateEntry3( xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, void *userdata, xmlHashDeallocator f)
{
  int v6 = -1;
  if (!table) {
    return v6;
  }
  __int128 v7 = (xmlChar *)name;
  if (!name || *((_DWORD *)table + 3) == 0x7FFFFFFF) {
    return v6;
  }
  int v13 = (xmlDict *)*((void *)table + 2);
  if (v13)
  {
    if (!xmlDictOwns(v13, name))
    {
      __int128 v7 = (xmlChar *)xmlDictLookup(*((xmlDictPtr *)table + 2), v7, -1);
      if (!v7) {
        return v6;
      }
    }

    if (name2)
    {
      if (!xmlDictOwns(*((xmlDictPtr *)table + 2), name2))
      {
        name2 = xmlDictLookup(*((xmlDictPtr *)table + 2), name2, -1);
        if (!name2) {
          return v6;
        }
      }
    }

    if (name3)
    {
      if (!xmlDictOwns(*((xmlDictPtr *)table + 2), name3))
      {
        name3 = xmlDictLookup(*((xmlDictPtr *)table + 2), name3, -1);
        if (!name3) {
          return v6;
        }
      }
    }
  }

  uint64_t v14 = (void *)(*(void *)table + 48 * xmlHashComputeKey((uint64_t)table, v7, name2, name3));
  int v6 = *((_DWORD *)v14 + 10);
  if (!v6)
  {
    int v19 = 0LL;
LABEL_39:
    if (*((void *)table + 2))
    {
      *((void *)v14 + 1) = v7;
      *((void *)v14 + 2) = name2;
    }

    else
    {
      *((void *)v14 + 1) = xmlStrdup(v7);
      *((void *)v14 + 2) = xmlStrdup(name2);
      name3 = xmlStrdup(name3);
    }

    *((void *)v14 + 3) = name3;
    *((void *)v14 + 4) = userdata;
    *(void *)uint64_t v14 = 0LL;
    *((_DWORD *)v14 + 10) = 1;
    ++*((_DWORD *)table + 3);
    if (v6)
    {
      int v6 = 0;
      *int v19 = v14;
    }

    return v6;
  }

  unint64_t v15 = *(void **)v14;
  if (!*((void *)table + 2))
  {
    if (v15)
    {
      while (!xmlStrEqual(*((const xmlChar **)v14 + 1), v7)
           || !xmlStrEqual(*((const xmlChar **)v14 + 2), name2)
           || !xmlStrEqual(*((const xmlChar **)v14 + 3), name3))
      {
        uint64_t v14 = *(void **)v14;
        if (!*(void *)v14) {
          goto LABEL_31;
        }
      }
    }

    else
    {
LABEL_31:
      if (!xmlStrEqual(*((const xmlChar **)v14 + 1), v7)
        || !xmlStrEqual(*((const xmlChar **)v14 + 2), name2)
        || !xmlStrEqual(*((const xmlChar **)v14 + 3), name3))
      {
LABEL_38:
        int v19 = v14;
        uint64_t v14 = xmlMalloc(0x30uLL);
        if (!v14) {
          return -1;
        }
        goto LABEL_39;
      }
    }

    if (f)
    {
      uint64_t v17 = *((void *)v14 + 4);
      uint64_t v18 = (xmlChar *)*((void *)v14 + 1);
      goto LABEL_36;
    }

LABEL_37:
    int v6 = 0;
    *((void *)v14 + 4) = userdata;
    return v6;
  }

  if (!v15)
  {
LABEL_20:
    if (*((xmlChar **)v14 + 1) == v7 && *((const xmlChar **)v14 + 2) == name2 && *((const xmlChar **)v14 + 3) == name3)
    {
      if (f)
      {
        uint64_t v17 = *((void *)v14 + 4);
        uint64_t v18 = v7;
LABEL_36:
        ((void (*)(uint64_t, xmlChar *))f)(v17, v18);
        goto LABEL_37;
      }

      goto LABEL_37;
    }

    goto LABEL_38;
  }

  while (1)
  {
    uint64_t v16 = (xmlChar **)v14;
    uint64_t v14 = v15;
    if (v16[1] == v7 && v16[2] == name2 && v16[3] == name3) {
      break;
    }
    unint64_t v15 = (void *)*v15;
    if (!*(void *)v14) {
      goto LABEL_20;
    }
  }

  if (f) {
    ((void (*)(xmlChar *, xmlChar *))f)(v16[4], v7);
  }
  int v6 = 0;
  v16[4] = (xmlChar *)userdata;
  return v6;
}

      xmlHashTablePtr v3 = *(void *)(v3 + 48);
      if (!v3) {
        return v4;
      }
    }

    char v11 = *(void *)(v3 + 72);
LABEL_24:
    if (v11
      && *(_DWORD *)(v3 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(v3 + 16), v6)
      && xmlStrEqual( *(const xmlChar **)(*(void *)(v3 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      unsigned int v20 = *(void *)(v3 + 104);
      if (v20)
      {
        xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v20 + 16));
        if (RootElement)
        {
          unsigned int v22 = RootElement;
          if (xmlStrEqual(RootElement->name, (const xmlChar *)"grammar"))
          {
            if (v22->children)
            {
              else {
                uint64_t v23 = 0;
              }
            }

            else
            {
              uint64_t v23 = 0;
            }

            if (!*(void *)(v3 + 24) || !xmlRelaxNGParseGrammarContent(a1))
            {
              if (v23) {
                int v4 = 0xFFFFFFFFLL;
              }
              else {
                int v4 = v4;
              }
              goto LABEL_37;
            }

            goto LABEL_60;
          }

          uint64_t v36 = a1;
          uint64_t v37 = v3;
          int v38 = 1038;
          BOOL v39 = "Include document root is not a grammar\n";
        }

        else
        {
          uint64_t v36 = a1;
          uint64_t v37 = v3;
          int v38 = 1022;
          BOOL v39 = "Include document is empty\n";
        }

        xmlRngPErr(v36, v37, v38, v39, 0LL, 0LL);
LABEL_60:
        int v4 = 0xFFFFFFFFLL;
        goto LABEL_37;
      }

      int v25 = a1;
      __int128 v26 = v3;
      __int128 v27 = 1042;
      int v28 = "Include node has no data\n";
      unint64_t v24 = 0LL;
    }

    else
    {
LABEL_35:
      unint64_t v24 = *(const xmlChar **)(v3 + 16);
      int v25 = a1;
      __int128 v26 = v3;
      __int128 v27 = 1036;
      int v28 = "grammar has unexpected child %s\n";
    }

    xmlRngPErr(v25, v26, v27, v28, v24, 0LL);
    int v4 = 0xFFFFFFFFLL;
    goto LABEL_37;
  }

  xmlRngPErr(a1, 0LL, 1037, "grammar has no children\n", 0LL, 0LL);
  return 0xFFFFFFFFLL;
}

          int v5 = "growing buffer";
          goto LABEL_38;
        default:
          int v6 = size + 10;
          goto LABEL_15;
      }
    }

    LODWORD(xmlHashScan(table, (xmlHashScanner)xmlDumpEntityDeclScan, buf) = 1;
  }

  return (int)buf;
}

            if (xmlBufAvail(*p_buffer) <= 0xF9F) {
              xmlBufGrow(*p_buffer, 0xFA0u);
            }
LABEL_44:
            uint64_t v14 = (v18 + v10);
            goto LABEL_45;
          }
        }
      }
    }
  }

  return v4;
}

      ++v4;
      int v2 = (uint64_t)a1;
    }

    while (v4 < v3);
    if (v3 < 1)
    {
LABEL_239:
      uint64_t v1 = 1LL;
      goto LABEL_240;
    }

    unint64_t v30 = 0LL;
    uint64_t v1 = 1LL;
LABEL_40:
    uint64_t v31 = *(void *)(*(void *)(v2 + 80) + 8 * v30);
    if (!v31) {
      goto LABEL_237;
    }
    __int128 v32 = *(_DWORD *)(v31 + 24);
    if (v32 < 2) {
      goto LABEL_237;
    }
    int v98 = v30;
    __int128 v33 = 0LL;
    xmlGenericErrorFunc v114 = 0LL;
    while (1)
    {
      int v34 = *(void *)(v31 + 32);
      int v35 = (uint64_t *)(v34 + 24 * v33);
      if (*v35)
      {
        uint64_t v36 = v34 + 24 * v33;
        int v38 = *(_DWORD *)(v36 + 8);
        uint64_t v37 = (int *)(v36 + 8);
        if (v38 != -1 && v33 != 0) {
          break;
        }
      }

int xmlHashUpdateEntry2( xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, void *userdata, xmlHashDeallocator f)
{
  return xmlHashUpdateEntry3(table, name, name2, 0LL, userdata, f);
}

void *__cdecl xmlHashLookup(xmlHashTablePtr table, const xmlChar *name)
{
  return xmlHashLookup3(table, name, 0LL, 0LL);
}

void *__cdecl xmlHashLookup3(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3)
{
  xmlMutexPtr result = 0LL;
  if (table && name)
  {
    unint64_t v9 = xmlHashComputeKey((uint64_t)table, name, name2, name3);
    uint64_t v10 = *(void *)table + 48 * v9;
    if (*(_DWORD *)(v10 + 40))
    {
      if (*((void *)table + 2))
      {
        uint64_t v11 = *(void *)table + 48 * v9;
        while (*(const xmlChar **)(v11 + 8) != name
             || *(const xmlChar **)(v11 + 16) != name2
             || *(const xmlChar **)(v11 + 24) != name3)
        {
          uint64_t v11 = *(void *)v11;
          if (!v11)
          {
            if (*(void *)table) {
              goto LABEL_11;
            }
            return 0LL;
          }
        }
      }

      else
      {
LABEL_11:
        while (!xmlStrEqual(*(const xmlChar **)(v10 + 8), name)
             || !xmlStrEqual(*(const xmlChar **)(v10 + 16), name2)
             || !xmlStrEqual(*(const xmlChar **)(v10 + 24), name3))
        {
          uint64_t v10 = *(void *)v10;
          if (!v10) {
            return 0LL;
          }
        }

        uint64_t v11 = v10;
      }

      return *(void **)(v11 + 32);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void *__cdecl xmlHashLookup2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2)
{
  return xmlHashLookup3(table, name, name2, 0LL);
}

void *__cdecl xmlHashQLookup(xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix)
{
  return xmlHashQLookup3(table, name, prefix, 0LL, 0LL, 0LL, 0LL);
}

void *__cdecl xmlHashQLookup3( xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix, const xmlChar *name2, const xmlChar *prefix2, const xmlChar *name3, const xmlChar *prefix3)
{
  __int128 v7 = 0LL;
  if (table && prefix)
  {
    if (name) {
      uint64_t v14 = name;
    }
    else {
      uint64_t v14 = prefix;
    }
    unint64_t v15 = *((int *)table + 6) + 30LL * *v14;
    if (name)
    {
      unsigned int v16 = *name;
      if (*name)
      {
        uint64_t v17 = name + 1;
        do
        {
          v15 ^= (v15 >> 3) + v16 + 32 * v15;
          unsigned int v18 = *v17++;
          unsigned int v16 = v18;
        }

        while (v18);
      }

      v15 ^= (v15 >> 3) + 32 * v15 + 58;
    }

    unsigned int v19 = *prefix;
    if (*prefix)
    {
      unsigned int v20 = prefix + 1;
      do
      {
        v15 ^= (v15 >> 3) + v19 + 32 * v15;
        unsigned int v21 = *v20++;
        unsigned int v19 = v21;
      }

      while (v21);
    }

    unint64_t v22 = (32 * v15 + (v15 >> 3)) ^ v15;
    if (name2)
    {
      unsigned int v23 = *name2;
      if (*name2)
      {
        unint64_t v24 = name2 + 1;
        do
        {
          v22 ^= (v22 >> 3) + v23 + 32 * v22;
          unsigned int v25 = *v24++;
          unsigned int v23 = v25;
        }

        while (v25);
      }

      v22 ^= (v22 >> 3) + 32 * v22 + 58;
    }

    if (prefix2)
    {
      unsigned int v26 = *prefix2;
      if (*prefix2)
      {
        __int128 v27 = prefix2 + 1;
        do
        {
          v22 ^= (v22 >> 3) + v26 + 32 * v22;
          unsigned int v28 = *v27++;
          unsigned int v26 = v28;
        }

        while (v28);
      }
    }

    unint64_t v29 = (32 * v22 + (v22 >> 3)) ^ v22;
    if (name3)
    {
      unsigned int v30 = *name3;
      if (*name3)
      {
        uint64_t v31 = name3 + 1;
        do
        {
          v29 ^= (v29 >> 3) + v30 + 32 * v29;
          unsigned int v32 = *v31++;
          unsigned int v30 = v32;
        }

        while (v32);
      }

      v29 ^= (v29 >> 3) + 32 * v29 + 58;
    }

    if (prefix3)
    {
      unsigned int v33 = *prefix3;
      if (*prefix3)
      {
        int v34 = prefix3 + 1;
        do
        {
          v29 ^= (v29 >> 3) + v33 + 32 * v29;
          unsigned int v35 = *v34++;
          unsigned int v33 = v35;
        }

        while (v35);
      }
    }

    unint64_t v36 = v29 % *((int *)table + 2);
    uint64_t v37 = *(void *)table;
    if (*(_DWORD *)(*(void *)table + 48 * v36 + 40)) {
      BOOL v38 = v37 == 0;
    }
    else {
      BOOL v38 = 1;
    }
    if (v38)
    {
      return 0LL;
    }

    else
    {
      BOOL v39 = (uint64_t **)(v37 + 48 * v36);
      while (!xmlStrQEqual(name, prefix, (const xmlChar *)v39[1])
           || !xmlStrQEqual(name2, prefix2, (const xmlChar *)v39[2])
           || !xmlStrQEqual(name3, prefix3, (const xmlChar *)v39[3]))
      {
        BOOL v39 = (uint64_t **)*v39;
        if (!v39) {
          return 0LL;
        }
      }

      return v39[4];
    }
  }

  return v7;
}

void *__cdecl xmlHashQLookup2( xmlHashTablePtr table, const xmlChar *name, const xmlChar *prefix, const xmlChar *name2, const xmlChar *prefix2)
{
  return xmlHashQLookup3(table, name, prefix, name2, prefix2, 0LL, 0LL);
}

unint64_t xmlHashComputeKey(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  unint64_t v4 = *(int *)(a1 + 24);
  if (a2)
  {
    unsigned int v5 = *a2;
    v4 += 30LL * *a2;
    if (*a2)
    {
      int v6 = a2 + 1;
      do
      {
        v4 ^= (v4 >> 3) + v5 + 32 * v4;
        unsigned int v7 = *v6++;
        unsigned int v5 = v7;
      }

      while (v7);
    }
  }

  unint64_t v8 = (32 * v4 + (v4 >> 3)) ^ v4;
  if (a3)
  {
    unsigned int v9 = *a3;
    if (*a3)
    {
      uint64_t v10 = a3 + 1;
      do
      {
        v8 ^= 32 * v8 + (v8 >> 3) + v9;
        unsigned int v11 = *v10++;
        unsigned int v9 = v11;
      }

      while (v11);
    }
  }

  unint64_t v12 = (32 * v8 + (v8 >> 3)) ^ v8;
  if (a4)
  {
    unsigned int v13 = *a4;
    if (*a4)
    {
      uint64_t v14 = a4 + 1;
      do
      {
        v12 ^= 32 * v12 + (v12 >> 3) + v13;
        unsigned int v15 = *v14++;
        unsigned int v13 = v15;
      }

      while (v15);
    }
  }

  return v12 % *(int *)(a1 + 8);
}

void xmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data)
{
  v3[0] = f;
  v3[1] = data;
  xmlHashScanFull(table, (xmlHashScannerFull)stubHashScannerFull, v3);
}

void xmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data)
{
  if (table)
  {
    if (f)
    {
      if (*(void *)table)
      {
        int v5 = *((_DWORD *)table + 2);
        if (v5 >= 1)
        {
          for (uint64_t i = 0LL; i < v5; ++i)
          {
            uint64_t v8 = *(void *)table;
            if (*(_DWORD *)(*(void *)table + 48 * i + 40)) {
              BOOL v9 = v8 == 0;
            }
            else {
              BOOL v9 = 1;
            }
            if (!v9)
            {
              uint64_t v10 = (void *)(v8 + 48 * i);
              int v11 = *((_DWORD *)table + 3);
              do
              {
                int v12 = v11;
                unsigned int v13 = (void *)*v10;
                uint64_t v14 = v10[4];
                if (v14)
                {
                  ((void (*)(uint64_t, void *, void, void, void))f)(v14, data, v10[1], v10[2], v10[3]);
                  int v11 = *((_DWORD *)table + 3);
                }

                if (v12 != v11 && v10 == (void *)(*(void *)table + 48 * i))
                {
                  if ((void *)*v10 == v13)
                  {
                    unsigned int v13 = v10;
                    if (!*(_DWORD *)(*(void *)table + 48 * i + 40)) {
                      break;
                    }
                  }

                  else
                  {
                    unsigned int v13 = v10;
                  }
                }

                uint64_t v10 = v13;
              }

              while (v13);
              int v5 = *((_DWORD *)table + 2);
            }
          }
        }
      }
    }
  }

uint64_t stubHashScannerFull(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))a2)(a1, *(void *)(a2 + 8));
}

void xmlHashScan3( xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashScanner f, void *data)
{
  v6[0] = f;
  v6[1] = data;
  xmlHashScanFull3(table, name, name2, name3, (xmlHashScannerFull)stubHashScannerFull, v6);
}

void xmlHashScanFull3( xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashScannerFull f, void *data)
{
  if (table)
  {
    if (f)
    {
      if (*(void *)table)
      {
        int v8 = *((_DWORD *)table + 2);
        if (v8 >= 1)
        {
          for (uint64_t i = 0LL; i < v8; ++i)
          {
            uint64_t v14 = *(void *)table;
            if (*(_DWORD *)(*(void *)table + 48 * i + 40)) {
              BOOL v15 = v14 == 0;
            }
            else {
              BOOL v15 = 1;
            }
            if (!v15)
            {
              unsigned int v16 = (void *)(v14 + 48 * i);
              do
              {
                uint64_t v17 = v16;
                unsigned int v16 = (void *)*v16;
                if ((!name || xmlStrEqual(name, (const xmlChar *)v17[1]))
                  && (!name2 || xmlStrEqual(name2, (const xmlChar *)v17[2]))
                  && (!name3 || xmlStrEqual(name3, (const xmlChar *)v17[3])))
                {
                  uint64_t v18 = v17[4];
                  if (v18) {
                    ((void (*)(uint64_t, void *, void, void, void))f)(v18, data, v17[1], v17[2], v17[3]);
                  }
                }
              }

              while (v16);
              int v8 = *((_DWORD *)table + 2);
            }
          }
        }
      }
    }
  }

xmlHashTablePtr xmlHashCopy(xmlHashTablePtr table, xmlHashCopier f)
{
  xmlHashTablePtr v2 = 0LL;
  if (table)
  {
    if (f)
    {
      xmlHashTablePtr v2 = xmlHashCreate(*((_DWORD *)table + 2));
      if (v2)
      {
        if (*(void *)table)
        {
          int v5 = *((_DWORD *)table + 2);
          if (v5 >= 1)
          {
            for (uint64_t i = 0LL; i < v5; ++i)
            {
              uint64_t v7 = *(void *)table;
              if (*(_DWORD *)(*(void *)table + 48 * i + 40)) {
                BOOL v8 = v7 == 0;
              }
              else {
                BOOL v8 = 1;
              }
              if (!v8)
              {
                BOOL v9 = (void *)(v7 + 48 * i);
                do
                {
                  int v11 = (void *)*v9;
                  uint64_t v10 = (const xmlChar *)v9[1];
                  int v12 = (const xmlChar *)v9[2];
                  unsigned int v13 = (const xmlChar *)v9[3];
                  uint64_t v14 = (void *)((uint64_t (*)(void, const xmlChar *))f)(v9[4], v10);
                  xmlHashAddEntry3(v2, v10, v12, v13, v14);
                  BOOL v9 = v11;
                }

                while (v11);
                int v5 = *((_DWORD *)table + 2);
              }
            }
          }
        }

        *((_DWORD *)v2 + 3) = *((_DWORD *)table + 3);
      }
    }
  }

  return v2;
}

int xmlHashSize(xmlHashTablePtr table)
{
  if (table) {
    return *((_DWORD *)table + 3);
  }
  else {
    return -1;
  }
}

int xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name, xmlHashDeallocator f)
{
  return xmlHashRemoveEntry3(table, name, 0LL, 0LL, f);
}

int xmlHashRemoveEntry3( xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, const xmlChar *name3, xmlHashDeallocator f)
{
  int result = -1;
  if (table && name)
  {
    unint64_t v11 = xmlHashComputeKey((uint64_t)table, name, name2, name3);
    uint64_t v12 = *(void *)table;
    if (*(_DWORD *)(*(void *)table + 48 * v11 + 40)) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      return -1;
    }

    else
    {
      unint64_t v14 = v11;
      BOOL v15 = 0LL;
      unsigned int v16 = (__int128 *)(v12 + 48 * v11);
      while (!xmlStrEqual(*((const xmlChar **)v16 + 1), name)
           || !xmlStrEqual(*((const xmlChar **)v16 + 2), name2)
           || !xmlStrEqual(*((const xmlChar **)v16 + 3), name3))
      {
        BOOL v15 = (__int128 **)v16;
        unsigned int v16 = *(__int128 **)v16;
        if (!v16) {
          return -1;
        }
      }

      if (f)
      {
        uint64_t v17 = *((void *)v16 + 4);
        if (v17) {
          ((void (*)(uint64_t, void))f)(v17, *((void *)v16 + 1));
        }
      }

      *((void *)v16 + 4) = 0LL;
      if (!*((void *)table + 2))
      {
        uint64_t v18 = (void *)*((void *)v16 + 1);
        if (v18) {
          xmlFree(v18);
        }
        unsigned int v19 = (void *)*((void *)v16 + 2);
        if (v19) {
          xmlFree(v19);
        }
        unsigned int v20 = (void *)*((void *)v16 + 3);
        if (v20) {
          xmlFree(v20);
        }
      }

      unsigned int v21 = *(__int128 **)v16;
      if (v15)
      {
        *BOOL v15 = v21;
        ((void (*)(__int128 *))xmlFree)(v16);
      }

      else if (v21)
      {
        unint64_t v22 = (_OWORD *)(*(void *)table + 48 * v14);
        __int128 v23 = *v21;
        __int128 v24 = v21[2];
        v22[1] = v21[1];
        v22[2] = v24;
        *unint64_t v22 = v23;
        ((void (*)(__int128 *))xmlFree)(v21);
      }

      else
      {
        *((_DWORD *)v16 + 10) = 0;
      }

      int result = 0;
      --*((_DWORD *)table + 3);
    }
  }

  return result;
}

int xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name, const xmlChar *name2, xmlHashDeallocator f)
{
  return xmlHashRemoveEntry3(table, name, name2, 0LL, f);
}

const htmlElemDesc *__cdecl htmlTagLookup(const htmlElemDesc *tag)
{
  if (tag) {
    return (const htmlElemDesc *)bsearch( tag,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
  }
  return tag;
}

uint64_t htmlCompareTags(const xmlChar *a1, const xmlChar **a2)
{
  return xmlStrcasecmp(a1, *a2);
}

int htmlAutoCloseTag(htmlDocPtr doc, const xmlChar *name, htmlNodePtr elem)
{
  if (!elem) {
    return 1;
  }
  if (xmlStrEqual(name, elem->name)) {
    return 0;
  }
  uint64_t v7 = elem->name;
  v9[0] = name;
  v9[1] = v7;
  if (!bsearch( v9,  htmlStartClose,  0xFBuLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareStartClose))
  {
    children = elem->children;
    if (!children) {
      return 0;
    }
    while (1)
    {
      int result = htmlAutoCloseTag(doc, name, children);
      if (result) {
        break;
      }
      children = children->next;
      if (!children) {
        return result;
      }
    }
  }

  return 1;
}

int htmlIsAutoClosed(htmlDocPtr doc, htmlNodePtr elem)
{
  if (!elem) {
    return 1;
  }
  children = elem->children;
  if (!children) {
    return 0;
  }
  while (!htmlAutoCloseTag(doc, elem->name, children))
  {
    children = children->next;
    if (!children) {
      return 0;
    }
  }

  return 1;
}

int htmlIsScriptAttribute(const xmlChar *name)
{
  if (name)
  {
    uint64_t v1 = name;
    if (*name == 111 && name[1] == 110)
    {
      uint64_t v2 = 0LL;
      while (!xmlStrEqual(v1, (const xmlChar *)htmlScriptAttributes[v2]))
      {
        if (++v2 == 18) {
          goto LABEL_7;
        }
      }

      LODWORD(name) = 1;
    }

    else
    {
LABEL_7:
      LODWORD(name) = 0;
    }
  }

  return (int)name;
}

const htmlEntityDesc *__cdecl htmlEntityLookup(const xmlChar *name)
{
  uint64_t v2 = (const htmlEntityDesc *)html40EntitiesTable;
  uint64_t v3 = 253LL;
  while (!xmlStrEqual(name, (const xmlChar *)v2->name))
  {
    ++v2;
    if (!--v3) {
      return 0LL;
    }
  }

  return v2;
}

const htmlEntityDesc *__cdecl htmlEntityValueLookup(unsigned int value)
{
  int result = (const htmlEntityDesc *)&html40EntitiesTable;
  uint64_t v3 = 253LL;
  while (result->value < value)
  {
    ++result;
    if (!--v3) {
      return 0LL;
    }
  }

  if (result->value <= value) {
    return result;
  }
  return 0LL;
}

int UTF8ToHtml(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  int result = -1;
  if (!out || !outlen || !inlen) {
    return result;
  }
  int v7 = (int)in;
  if (!in)
  {
    int v29 = 0;
    int result = 0;
    *outunsigned int len = 0;
    goto LABEL_42;
  }

  unsigned int v30 = inlen;
  uint64_t v8 = *inlen;
  LODWORD(v9) = (_DWORD)out;
  LODWORD(v10) = (_DWORD)in;
  if ((int)v8 < 1)
  {
LABEL_40:
    int result = 0;
    *outunsigned int len = (_DWORD)v9 - (_DWORD)out;
    int v29 = (_DWORD)v10 - v7;
    goto LABEL_41;
  }

  unint64_t v11 = &in[v8];
  uint64_t v12 = &out[*outlen];
  BOOL v13 = in;
  BOOL v9 = out;
  uint64_t v10 = in;
  while (1)
  {
    int v14 = *(char *)v10++;
    unsigned int v15 = v14;
    if ((v14 & 0x80000000) == 0)
    {
      unsigned int v16 = 0;
      unsigned int v17 = v15;
      goto LABEL_16;
    }

    if (v15 <= 0xBF) {
      break;
    }
    if (v15 <= 0xDF)
    {
      unsigned int v17 = v15 & 0x1F;
      unsigned int v16 = 1;
      goto LABEL_16;
    }

    if (v15 <= 0xEF)
    {
      unsigned int v17 = v15 & 0xF;
      unsigned int v16 = 2;
      goto LABEL_16;
    }

    if (v15 > 0xF7) {
      break;
    }
    unsigned int v17 = v15 & 7;
    unsigned int v16 = 3;
LABEL_16:
    if (v11 - v10 < v16) {
      goto LABEL_39;
    }
    if ((v15 & 0x80) != 0 && v10 < v11)
    {
      unsigned int v18 = v16 - 1;
      unsigned int v19 = v13 + 2;
      do
      {
        uint64_t v10 = v19;
        char v20 = *(v19 - 1);
        if ((v20 & 0xC0) != 0x80) {
          break;
        }
        unsigned int v17 = v20 & 0x3F | (v17 << 6);
        if (v18-- == 0) {
          break;
        }
        unsigned int v19 = v10 + 1;
      }

      while (v10 < v11);
    }

    if (v17 > 0x7F)
    {
      *(void *)__str = 0LL;
      uint64_t v32 = 0LL;
      unint64_t v22 = 0x3FFFFFFFFFFFFA12uLL;
      while (1)
      {
        unsigned int v23 = html40EntitiesTable[v22 + 1518];
        if (v23 >= v17) {
          break;
        }
        v22 += 6LL;
        if (!(v22 * 4)) {
          goto LABEL_33;
        }
      }

      if (v23 <= v17)
      {
        __int128 v24 = *(char **)&html40EntitiesTable[v22 + 1520];
        goto LABEL_34;
      }

int htmlEncodeEntities(unsigned __int8 *out, int *outlen, const unsigned __int8 *in, int *inlen, int quoteChar)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  int result = -1;
  if (in && out && outlen && inlen)
  {
    int v8 = (int)in;
    uint64_t v9 = *inlen;
    if ((int)v9 < 1)
    {
      int result = 0;
      LODWORD(v13) = (_DWORD)out;
      LODWORD(v12) = (_DWORD)in;
LABEL_46:
      *outunsigned int len = (_DWORD)v13 - (_DWORD)out;
      *inunsigned int len = (_DWORD)v12 - v8;
      return result;
    }

    int v29 = outlen;
    unsigned int v30 = &out[*outlen];
    unint64_t v11 = &in[v9];
    uint64_t v12 = in;
    BOOL v13 = out;
    int v14 = in;
    while (1)
    {
      unsigned __int8 v15 = *v14++;
      unsigned int v16 = v15;
      if ((v15 & 0x80) != 0) {
        break;
      }
      if (v11 - v14 < 0) {
        goto LABEL_44;
      }
LABEL_21:
      BOOL v21 = v16 > 0x7F || v16 == quoteChar;
      if (!v21 && (v16 <= 0x3E ? (BOOL v22 = ((1LL << v16) & 0x5000004000000000LL) == 0) : (BOOL v22 = 1), v22))
      {
        if (v13 >= v30) {
          goto LABEL_44;
        }
        unsigned __int8 *v13 = v16;
      }

      else
      {
        *(void *)__str = 0LL;
        uint64_t v32 = 0LL;
        unint64_t v23 = 0x3FFFFFFFFFFFFA12uLL;
        while (1)
        {
          unsigned int v24 = html40EntitiesTable[v23 + 1518];
          if (v24 >= v16) {
            break;
          }
          v23 += 6LL;
          if (!(v23 * 4)) {
            goto LABEL_35;
          }
        }

        if (v24 <= v16)
        {
          int v25 = *(char **)&html40EntitiesTable[v23 + 1520];
          goto LABEL_36;
        }

LABEL_35:
        int v25 = __str;
        snprintf(__str, 0x10uLL, "#%u", v16);
LABEL_36:
        size_t v26 = strlen(v25);
        uint64_t v27 = v26 << 32;
        unsigned __int8 *v13 = 38;
        unsigned int v28 = (char *)(v13 + 1);
        memcpy(v28, v25, (int)v26);
        BOOL v13 = (unsigned __int8 *)&v28[v27 >> 32];
        unsigned __int8 *v13 = 59;
      }

      ++v13;
      uint64_t v12 = v14;
      if (v14 >= v11)
      {
        int result = 0;
        LODWORD(v12) = (_DWORD)v14;
        goto LABEL_45;
      }
    }

    if (v16 >= 0xC0)
    {
      if (v16 < 0xE0)
      {
        unsigned int v17 = 1;
        int v18 = 31;
LABEL_17:
        if (v11 - v14 >= v17)
        {
          uint64_t v19 = 0LL;
          v16 &= v18;
          int v14 = &v12[v17 + 1];
          while (1)
          {
            unsigned __int8 v20 = v12[v19 + 1];
            if ((v20 & 0xC0) != 0x80) {
              goto LABEL_42;
            }
            unsigned int v16 = v20 & 0x3F | (v16 << 6);
            if (v17 == (_DWORD)++v19) {
              goto LABEL_21;
            }
          }
        }

  ctxt->extSubSystem = 0LL;
  myDoc = ctxt->myDoc;
  if (myDoc) {
    xmlFreeDoc(myDoc);
  }
  ctxt->myDoc = 0LL;
  *(void *)&ctxt->standalone = 0xFFFFFFFFLL;
  *(void *)&ctxt->instate = 0LL;
  ctxt->wellFormed = 1;
  ctxt->nsWellFormed = 1;
  *(void *)&ctxt->disableSAX = 0LL;
  ctxt->valid = 1;
  ctxt->record_info = 0;
  ctxt->checkIndex = 0LL;
  *(void *)&ctxt->errNo = 0LL;
  *(void *)&ctxt->hasPErefs = 0LL;
  ctxt->depth = 0;
  ctxt->charset = 1;
  ctxt->catalogs = 0LL;
  ctxt->sizeentcopy = 0LL;
  *(_OWORD *)&ctxt->nbentities = 0u;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  attsDefault = ctxt->attsDefault;
  if (attsDefault)
  {
    xmlHashFree(attsDefault, (xmlHashDeallocator)xmlHashDefaultDeallocator);
    ctxt->attsDefault = 0LL;
  }

  attsSpecial = ctxt->attsSpecial;
  if (attsSpecial)
  {
    xmlHashFree(attsSpecial, 0LL);
    ctxt->attsSpecial = 0LL;
  }

  catalogs = ctxt->catalogs;
  if (catalogs) {
    xmlCatalogFreeLocal(catalogs);
  }
  if (ctxt->lastError.code) {
    xmlResetError(&ctxt->lastError);
  }
}

      if (++v15 >= *v7)
      {
        *(_DWORD *)(a1 + 56) = v33;
        if (v17)
        {
          xmlRelaxNGFreeStates(a1, (void **)v7);
          uint64_t v10 = 0LL;
          *(void *)(a1 + 104) = v17;
          goto LABEL_54;
        }

        if (v16 >= 2)
        {
          uint64_t v10 = 0LL;
          const xmlChar *v7 = v16;
          *int v8 = v7;
          goto LABEL_54;
        }

        if (v16 == 1)
        {
          *(void *)(a1 + 96) = **((void **)v7 + 1);
          xmlRelaxNGFreeStates(a1, (void **)v7);
          uint64_t v10 = 0LL;
          goto LABEL_54;
        }

      if (!v11) {
        goto LABEL_69;
      }
    }

    if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"element")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"ref")
      || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"parentRef"))
    {
      goto LABEL_35;
    }

    int v14 = *(const xmlChar **)(v6 + 16);
    unsigned __int8 v15 = "param";
LABEL_30:
    if (xmlStrEqual(v14, (const xmlChar *)v15)) {
      goto LABEL_35;
    }
    unsigned int v16 = *(const xmlChar **)(v6 + 16);
    unsigned int v17 = "define";
LABEL_32:
    if (!xmlStrEqual(v16, (const xmlChar *)v17))
    {
      int v18 = *(const xmlChar **)(v12 + 16);
      uint64_t v19 = *(xmlChar **)(v6 + 16);
      unsigned __int8 v20 = a1;
      BOOL v21 = v6;
      BOOL v22 = 1034;
      unint64_t v23 = "Attribute %s is not allowed on %s\n";
LABEL_34:
      xmlRngPErr(v20, v21, v22, v23, v18, v19);
      goto LABEL_35;
    }

    goto LABEL_35;
  }

    *p_children = (_xmlNode *)v10;
  }

  if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
  {
    unint64_t v23 = __xmlRegisterNodeDefaultValue();
    ((void (*)(xmlDtd *))*v23)(v10);
  }

  return v10;
}

    *(_DWORD *)(a1 + 24) = v5;
    if (*(_DWORD *)(*(void *)(a1 + 32) + 24LL)) {
      return 0LL;
    }
    *(_DWORD *)a1 = 3;
  }

  return 0xFFFFFFFFLL;
}

  if (v13 <= XML_XINCLUDE_END && ((1 << v13) & 0x180002) != 0)
  {
    unsigned int v17 = (_xmlNs *)cur[1]._private;
    if (v17)
    {
      xmlFreeNsList(v17);
      BOOL v13 = cur->type;
    }
  }

  if (v13 == XML_TEXT_NODE) {
    goto LABEL_49;
  }
  if (v13 == XML_COMMENT_NODE) {
    goto LABEL_49;
  }
  name = (xmlChar *)cur->name;
  if (!name) {
    goto LABEL_49;
  }
  if (!v5) {
    goto LABEL_47;
  }
  if (!xmlDictOwns(v5, name))
  {
    name = (xmlChar *)cur->name;
LABEL_47:
    xmlFree(name);
  }

  BOOL v13 = cur->type;
LABEL_49:
  if ((v13 | 2) == 3 && (uint64_t v19 = *(void *)(a1 + 32)) != 0 && (v20 = *(_DWORD *)(v19 + 572), v20 <= 99))
  {
    cur->next = *(_xmlAttr **)(v19 + 576);
    *(void *)(v19 + 576) = cur;
    *(_DWORD *)(v19 + 572) = v20 + 1;
  }

  else
  {
    xmlFree(cur);
  }

            ++v9;
            v8 += 24LL;
            if (v9 >= v7)
            {
              unint64_t v4 = v111;
              uint64_t v3 = a1[19];
              goto LABEL_37;
            }
          }

          unsigned int v16 = 0LL;
          unsigned int v17 = v10 + 24 * v9;
          int v18 = (_DWORD *)(v17 + 12);
          uint64_t v19 = (_DWORD *)(v17 + 16);
          while (1)
          {
            unsigned __int8 v20 = *(void *)(v6 + 32);
            BOOL v21 = *(_DWORD *)(v20 + v16 + 8);
            if (v21 == -1) {
              goto LABEL_33;
            }
            BOOL v22 = *(void *)(v20 + v16);
            if (!v22 || *v13 != v21) {
              goto LABEL_33;
            }
            unint64_t v23 = *v11;
            if (*v11 == v22) {
              goto LABEL_30;
            }
            if (!v23) {
              goto LABEL_33;
            }
            unsigned int v24 = *(_DWORD *)(v23 + 4);
            if (v24 != *(_DWORD *)(v22 + 4)) {
              goto LABEL_33;
            }
            if (v24 == 2)
            {
              unsigned int v28 = *(_DWORD *)(v23 + 44) == *(_DWORD *)(v22 + 44);
            }

            else
            {
              if (v24 != 5) {
                goto LABEL_33;
              }
              int v25 = *(const xmlChar **)(v23 + 24);
              size_t v26 = *(const xmlChar **)(v22 + 24);
              if ((v5 & 1) == 0)
              {
                uint64_t v27 = xmlStrEqual(v25, v26);
                LOBYTE(v5) = v113;
                if (v27) {
                  goto LABEL_30;
                }
                goto LABEL_33;
              }

              unsigned int v28 = v25 == v26;
            }

            if (v28)
            {
LABEL_30:
              if (*v18 == *(_DWORD *)(v20 + v16 + 12) && *v19 == *(_DWORD *)(v20 + v16 + 16)) {
                *(_DWORD *)(v20 + v16 + 8) = -1;
              }
            }

          if (xmlPointerListAddSize((uint64_t)v7, (uint64_t)obj, 0) == -1)
          {
LABEL_44:
            unsigned int v16 = obj->nodesetval;
            if (v16) {
              xmlXPathFreeNodeSet(v16);
            }
            xmlFree(obj);
            return result;
          }

          uint64_t v12 = obj->nodesetval;
          if (v12)
          {
            nodeNr = v12->nodeNr;
            if (v12->nodeNr < 2)
            {
              if (nodeNr == 1)
              {
                unsigned int v17 = *v12->nodeTab;
                if (v17)
                {
                  if (v17->type == XML_NAMESPACE_DECL) {
                    xmlXPathNodeSetFreeNs((xmlNsPtr)v17);
                  }
                }
              }
            }

            else
            {
              int v14 = 0LL;
              do
              {
                unsigned __int8 v15 = v12->nodeTab[v14];
                if (v15 && v15->type == XML_NAMESPACE_DECL)
                {
                  xmlXPathNodeSetFreeNs((xmlNsPtr)v15);
                  nodeNr = v12->nodeNr;
                }

                ++v14;
              }

              while (v14 < nodeNr);
            }

            v12->nodeNr = 0;
            int result = 0.0;
            *(void *)&obj->index2 = 0LL;
            *(_OWORD *)&obj->stringval = 0u;
            *(_OWORD *)&obj->index = 0u;
            *(_OWORD *)&obj->xmlElementType type = 0u;
            *(_OWORD *)&obj->BOOLval = 0u;
            obj->xmlNodeSetPtr nodesetval = v12;
          }

          else
          {
            *(void *)&obj->index2 = 0LL;
            int result = 0.0;
            *(_OWORD *)&obj->stringval = 0u;
            *(_OWORD *)&obj->index = 0u;
            *(_OWORD *)&obj->xmlElementType type = 0u;
            *(_OWORD *)&obj->BOOLval = 0u;
          }

          break;
        case XPATH_LOCATIONSET:
          user = (xmlLocationSet *)obj->user;
          if (user) {
            xmlXPtrFreeLocationSet(user);
          }
          goto LABEL_44;
        default:
          goto LABEL_44;
      }
    }

    else
    {
      xmlXPathFreeObject(obj);
    }
  }

  return result;
}

    *a2 = v14;
    unint64_t v23 = a2[1];
    if (v23 >= 11 && v14 < (int)(v23 >> 1))
    {
      if (v14 <= 10) {
        int v25 = 10;
      }
      else {
        int v25 = v14;
      }
      size_t v26 = xmlRealloc(*((void **)a2 + 1), 8LL * v25);
      if (v26)
      {
        *((void *)a2 + 1) = v26;
        a2[1] = v25;
      }

      else
      {
        if (a1)
        {
          a1->error = 15;
          uint64_t v27 = (uint64_t)a1->context;
        }

        else
        {
          uint64_t v27 = 0LL;
        }

        xmlXPathErrMemory(v27, "shrinking nodeset\n");
      }
    }

    *(_OWORD *)&context->xmlDocPtr doc = v29;
    *(void *)&context->contextSize = v10;
  }

      void *k = v22;
      uint64_t v19 = *(unsigned __int8 **)v6;
      if (**(_BYTE **)v6) {
        *(void *)int v6 = ++v19;
      }
    }

    if (v22 == 40)
    {
      ++v20;
      LOBYTE(v22) = 40;
      goto LABEL_35;
    }

    if (*v19) {
      goto LABEL_35;
    }
    void *k = 0;
    if (!v20 || **(_BYTE **)v6) {
      goto LABEL_45;
    }
    xmlFree(v13);
    ((void (*)(_BYTE *))xmlFree)(v18);
LABEL_43:
    uint64_t v27 = (xmlXPathParserContext *)v6;
    unsigned int v28 = 16;
LABEL_38:
    xmlXPathErr(v27, v28);
LABEL_73:
    uint64_t v47 = *(_DWORD *)(v6 + 16);
    if (v47 == 1900 || v47 == 0)
    {
      int v49 = *(void *)(v6 + 32);
      if (!v49)
      {
LABEL_88:
        for (n = *(unsigned __int8 **)v6; ; *(void *)int v6 = n)
        {
          xmlGenericErrorFunc v53 = *n++;
          unsigned int v43 = v53 > 0x20;
          int v54 = (1LL << v53) & 0x100002600LL;
          if (v43 || v54 == 0) {
            break;
          }
        }

        BOOL v13 = xmlXPathParseName((xmlXPathParserContextPtr)v6);
        if (!v13) {
          break;
        }
        continue;
      }

      if (*(_DWORD *)v49 == 1)
      {
        uint64_t v50 = *(int **)(v49 + 8);
        if (!v50)
        {
LABEL_87:
          while (1)
          {
            uint64_t v51 = valuePop((xmlXPathParserContextPtr)v6);
            if (!v51) {
              break;
            }
            xmlXPathFreeObject(v51);
          }

          goto LABEL_88;
        }
      }

      else
      {
        if (*(_DWORD *)v49 != 7) {
          goto LABEL_87;
        }
        uint64_t v50 = *(int **)(v49 + 40);
        if (!v50) {
          goto LABEL_87;
        }
      }

      if (*v50 > 0) {
        break;
      }
      goto LABEL_87;
    }

    break;
  }

LABEL_44:
        int result = 0;
LABEL_45:
        outunsigned int len = v29;
        goto LABEL_46;
      }

      if (v16 < 0xF0)
      {
        unsigned int v17 = 2;
        int v18 = 15;
        goto LABEL_17;
      }

      if (v16 <= 0xF7)
      {
        unsigned int v17 = 3;
        int v18 = 7;
        goto LABEL_17;
      }
    }

  if (xmlCharInRange(v16, &xmlIsBaseCharGroup)) {
    unsigned int v17 = 1;
  }
  else {
    unsigned int v17 = (v16 - 12330) > 0xFFFFFFF6;
  }
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_55:
          while (1)
          {
            v3 += len;
            unsigned __int8 v20 = xmlStringCurrentChar(0LL, v3, &len);
            BOOL v21 = v20;
            if (v20 > 255) {
              break;
            }
            BOOL v22 = (v20 - 192) >= 0x17 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A;
          }

          if (xmlCharInRange(v20, &xmlIsBaseCharGroup)) {
            unsigned int v24 = 0;
          }
          else {
            unsigned int v24 = (v21 - 12321) >= 9;
          }
          size_t v26 = v24 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
        }

        while (!v26 || xmlCharInRange(v21, &xmlIsDigitGroup));
LABEL_79:
        ;
      }

      while ((v21 - 45) <= 0x32 && ((1LL << (v21 - 45)) & 0x4000000000003LL) != 0);
      if (v21 >= 256) {
        break;
      }
      if (v21 != 183) {
        goto LABEL_89;
      }
    }
  }

  while (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup));
LABEL_89:
  if (space && v21 <= 255)
  {
    do
    {
      if (((1LL << v21) & 0x100002600LL) == 0) {
        break;
      }
      v3 += len;
      BOOL v21 = xmlStringCurrentChar(0LL, v3, &len);
    }

    while (v21 < 256);
  }

  return v21 != 0;
}

        uint64_t v27 = 0;
        goto LABEL_45;
      }

      unsigned int v28 = xmlStrEqual(v23, (const xmlChar *)"union");
      uint64_t v27 = 0;
      if (a7 != -1 && v28)
      {
        int v25 = *a2;
        size_t v26 = a7;
LABEL_33:
        if ((v25 & v26) == 0)
        {
          unsigned int v24 = v25 | v26;
          goto LABEL_35;
        }

    unsigned __int8 v15 = 1;
    goto LABEL_45;
  }

  if (!xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    unsigned int v17 = *(void *)(v12 + 72);
    goto LABEL_26;
  }

  int v18 = a1;
  uint64_t v19 = a2;
  unsigned __int8 v20 = v12;
  BOOL v21 = 8;
LABEL_35:
  size_t v26 = xmlSchemaParseModelGroup(v18, v19, v20, v21, 1);
LABEL_36:
  *(void *)(v8 + 56) = v26;
  uint64_t v12 = *(void *)(v12 + 48);
  int v29 = (xmlNode *)v12;
LABEL_37:
  if (!v12) {
    return;
  }
LABEL_45:
  if (xmlSchemaParseLocalAttributes(a1, a2, (uint64_t *)&v29, (void *****)(v8 + 216), 13, 0LL) != -1)
  {
    uint64_t v27 = v29;
    if (v29)
    {
      if (!v29->ns
        || !xmlStrEqual(v29->name, (const xmlChar *)"anyAttribute")
        || !xmlStrEqual(v27->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        if (!v15) {
          goto LABEL_52;
        }
        goto LABEL_55;
      }

      *(void *)(*(void *)(a1 + 160) + 152LL) = xmlSchemaParseAnyAttribute((_DWORD *)a1, a2, v27);
      uint64_t v27 = v27->next;
      if (v27)
      {
        if (!v15)
        {
LABEL_52:
          unsigned int v28 = "(annotation?, ((attribute | attributeGroup)*, anyAttribute?))";
LABEL_56:
          xmlSchemaPContentErr(a1, 3033, a3, (uint64_t)v27, 0LL, (xmlChar *)v28);
          return;
        }

LABEL_42:
    int result = -2;
    goto LABEL_45;
  }

  return result;
}

          close(*((_DWORD *)ctx + 46));
          int v5 = -1;
LABEL_43:
          *((_DWORD *)ctx + 46) = -1;
          return v5;
        }
      }

      else
      {
        getsockname(v2, v23, &v20);
        *(_WORD *)v23[0].sa_xmlCatalogPtr data = 0;
        if (bind(*((_DWORD *)ctx + 46), v23, v20) < 0)
        {
          BOOL v13 = "bind failed";
LABEL_41:
          __xmlIOErr(9, 0, (uint64_t)v13);
          goto LABEL_42;
        }

        getsockname(*((_DWORD *)ctx + 46), v23, &v20);
        if (listen(*((_DWORD *)ctx + 46), 1) < 0)
        {
          BOOL v13 = "listen failed";
          goto LABEL_41;
        }

        if (*((_BYTE *)ctx + 49) == 30)
        {
          *(_OWORD *)BOOL v21 = 0u;
          memset(v22, 0, sizeof(v22));
          inet_ntop(30, &v23[0].sa_data[6], v21, 0x2Eu);
          snprintf((char *)__s, 0xC8uLL, "EPRT |2|%s|%s|\r\n");
        }

        else
        {
          snprintf((char *)__s, 0xC8uLL, "PORT %d,%d,%d,%d,%d,%d\r\n", v23[0].sa_data[2]);
        }

        HIBYTE(v28) = 0;
        unsigned __int8 v15 = strlen((const char *)__s);
        if ((send(*((_DWORD *)ctx + 45), __s, v15, 0) & 0x80000000) == 0)
        {
          goto LABEL_42;
        }
      }

      BOOL v13 = "send failed";
      goto LABEL_41;
    }

    __xmlIOErr(9, 0, (uint64_t)"socket failed");
  }

  return -1;
}

  uint64_t v33 = (xmlHashTable *)v5[6];
  if (v33) {
    xmlHashScan(v33, (xmlHashScanner)xmlRelaxNGCheckCombine, (void *)a1);
  }
  int v34 = (xmlHashTable *)v5[7];
  if (v34) {
    xmlHashScan(v34, (xmlHashScanner)xmlRelaxNGCheckReference, (void *)a1);
  }
  *(void *)(a1 + 48) = v6;
  return v5;
}

            if (xmlDOMWrapNsMapAddItem(a5, -1, a3, v24, a6))
            {
              int result = 0LL;
              *a4 = v24;
              return result;
            }

            uint64_t v33 = *(void **)(v24 + 16);
            if (v33) {
              xmlFree(v33);
            }
            int v34 = *(void **)(v24 + 24);
            if (v34) {
              xmlFree(v34);
            }
            ((void (*)(uint64_t))xmlFree)(v24);
          }
        }

        else
        {
          int v29 = xmlDOMWrapStoreNs(a1, v21, v22);
          if (v29)
          {
            unsigned int v30 = v29;
            if (xmlDOMWrapNsMapAddItem(a5, -1, a3, (uint64_t)v29, -3))
            {
              int result = 0LL;
              *a4 = (uint64_t)v30;
              return result;
            }

            href = (xmlChar *)v30->href;
            if (href) {
              xmlFree(href);
            }
            prefix = (xmlChar *)v30->prefix;
            if (prefix) {
              xmlFree(prefix);
            }
            ((void (*)(xmlNsPtr))xmlFree)(v30);
          }
        }

        return 0xFFFFFFFFLL;
      }
    }
  }

  return result;
}

      xmlErrValidNode( (uint64_t *)ctxt,  (int)elem,  533,  (uint64_t)"No declaration for attribute %s of element %s\n",  (uint64_t)attr->name,  (xmlChar *)elem->name,  0LL);
      goto LABEL_43;
    }
  }

      *(_DWORD *)(result + 16) = 1450;
      uint64_t v12 = "Wrong escape sequence, misuse of character '\\'";
      return xmlRegexpErrCompile(v1, (uint64_t)v12);
    }
  }

  else if (v9 - 40 >= 4)
  {
    goto LABEL_42;
  }

htmlDocPtr htmlNewDocNoDtD(const xmlChar *URI, const xmlChar *ExternalID)
{
  unint64_t v4 = (char *)xmlMalloc(0xB0uLL);
  int v5 = (xmlDoc *)v4;
  if (v4)
  {
    *(_OWORD *)unint64_t v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *((_OWORD *)v4 + 6) = 0u;
    *((_OWORD *)v4 + 7) = 0u;
    *((_OWORD *)v4 + 9) = 0u;
    *((_OWORD *)v4 + 10) = 0u;
    *((_OWORD *)v4 + 8) = 0u;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_DWORD *)v4 + 2) = 13;
    *((_OWORD *)v4 + 4) = 0u;
    *((_OWORD *)v4 + 5) = 0u;
    *((void *)v4 + 8) = v4;
    *(_OWORD *)(v4 + 104) = 0u;
    *((void *)v4 + 12) = 0LL;
    *((void *)v4 + 9) = 0x100000000LL;
    *(void *)unint64_t v4 = 0LL;
    *(_OWORD *)(v4 + 120) = 0u;
    *((_DWORD *)v4 + 36) = 1;
    *((_DWORD *)v4 + 43) = 160;
    if (__xmlRegisterCallbacks && *__xmlRegisterNodeDefaultValue())
    {
      int v6 = __xmlRegisterNodeDefaultValue();
      ((void (*)(xmlDoc *))*v6)(v5);
    }
  }

  else
  {
    htmlErrMemory(0LL, (uint64_t)"HTML document creation failed\n");
  }

  return v5;
}

_DWORD *htmlErrMemory(_DWORD *result, uint64_t a2)
{
  if (!result) {
    goto LABEL_5;
  }
  if (!result[83] || result[68] != -1)
  {
    result[34] = 2;
    result[68] = -1;
    result[83] = 1;
LABEL_5:
    if (a2) {
      return (_DWORD *)__xmlRaiseError( 0,  0,  0,  (int)result,  0,  1,  2,  3,  0LL,  0,  a2,  0LL,  0LL,  0,  (unsigned __int128)0LL >> 96,  (uint64_t)"Memory allocation failed : %s\n");
    }
    else {
      return (_DWORD *)__xmlRaiseError( 0,  0,  0,  (int)result,  0,  1,  2,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  (uint64_t)"Memory allocation failed\n");
    }
  }

  return result;
}

htmlDocPtr htmlNewDoc(const xmlChar *URI, const xmlChar *ExternalID)
{
  if (!((unint64_t)URI | (unint64_t)ExternalID))
  {
    URI = (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd";
    ExternalID = (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN";
  }

  return htmlNewDocNoDtD(URI, ExternalID);
}

const htmlEntityDesc *__cdecl htmlParseEntityRef(htmlParserCtxtPtr ctxt, const xmlChar **str)
{
  if (str) {
    *str = 0LL;
  }
  if (!ctxt) {
    return 0LL;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input || *input->cur != 38) {
    return 0LL;
  }
  xmlNextChar(ctxt);
  int v5 = htmlParseName((uint64_t)ctxt);
  if (!v5)
  {
    htmlParseErr(ctxt, 68, "htmlParseEntityRef: no name\n", 0LL, 0LL);
    return 0LL;
  }

  int v6 = v5;
  xmlParserInputPtr v7 = ctxt->input;
  if (!ctxt->progressive && v7->end - v7->cur <= 249)
  {
    xmlParserInputGrow(v7, 250);
    xmlParserInputPtr v7 = ctxt->input;
  }

  if (*v7->cur != 59)
  {
    htmlParseErr(ctxt, 23, "htmlParseEntityRef: expecting ';'\n", 0LL, 0LL);
    if (str)
    {
      int result = 0LL;
      *str = v6;
      return result;
    }

    return 0LL;
  }

  if (str) {
    *str = v6;
  }
  int v8 = (const htmlEntityDesc *)html40EntitiesTable;
  uint64_t v9 = 253LL;
  while (!xmlStrEqual(v6, (const xmlChar *)v8->name))
  {
    int result = 0LL;
    ++v8;
    if (!--v9) {
      return result;
    }
  }

  xmlNextChar(ctxt);
  return v8;
}

const xmlChar *htmlParseName(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 452))
  {
    uint64_t v2 = *(xmlParserInput **)(a1 + 56);
    if (v2->end - v2->cur <= 249) {
      xmlParserInputGrow(v2, 250);
    }
  }

  uint64_t v3 = *(void *)(a1 + 56);
  unint64_t v4 = *(const xmlChar **)(v3 + 32);
  int v5 = *v4;
  if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A && v5 != 95 && v5 != 58) {
    return htmlParseNameComplex(a1);
  }
  for (uint64_t i = 1LL; ; ++i)
  {
    int v7 = v4[i];
    if ((v7 - 48) >= 0xA
      && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v7 - 45) > 0x32 || ((1LL << (v7 - 45)) & 0x4000000002003LL) == 0))
    {
      break;
    }
  }

  uint64_t v10 = &v4[i];
  if (&v4[i] != *(const xmlChar **)(v3 + 40))
  {
    if ((char)v7 >= 1)
    {
      int result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v4, i);
      uint64_t v12 = *(void *)(a1 + 56);
      *(void *)(v12 + 32) = v10;
      *(_DWORD *)(v12 + 56) += i;
      return result;
    }

    return htmlParseNameComplex(a1);
  }

  return 0LL;
}

_DWORD *htmlParseErr(_DWORD *result, int a2, const char *a3, const xmlChar *a4, xmlChar *a5)
{
  if (!result) {
    return __xmlRaiseError(0LL, 0LL, 0LL, 0LL, 0LL, 5u, a2, 2, 0LL, 0, a4, a5, 0LL, 0, 0, a3, (char)a4);
  }
  int v5 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    int result = __xmlRaiseError(0LL, 0LL, 0LL, result, 0LL, 5u, a2, 2, 0LL, 0, a4, a5, 0LL, 0, 0, a3, (char)a4);
    v5[6] = 0;
  }

  return result;
}

int htmlParseCharRef(htmlParserCtxtPtr ctxt)
{
  htmlParserCtxtPtr v1 = ctxt;
  if (!ctxt || (xmlParserInputPtr input = ctxt->input) == 0LL)
  {
    int v8 = "htmlParseCharRef: context error\n";
    int v9 = 1;
    goto LABEL_19;
  }

  cur = input->cur;
  if (*cur != 38 || cur[1] != 35)
  {
    htmlParseErr(ctxt, 8, "htmlParseCharRef: invalid value\n", 0LL, 0LL);
    int v6 = 0;
    goto LABEL_21;
  }

  unint64_t v4 = cur + 2;
  if ((cur[2] | 0x20) != 0x78)
  {
    input->cur = v4;
    input->col += 2;
    int v11 = *v4;
    if (v11 != 59)
    {
      int v6 = 0;
      do
      {
        if ((v11 - 48) > 9)
        {
          BOOL v13 = v1;
          int v14 = 7;
          goto LABEL_45;
        }

        int v12 = v11 + 10 * v6 - 48;
        if (v6 < 1114112) {
          int v6 = v12;
        }
        xmlNextChar(v1);
        int v11 = *v1->input->cur;
      }

      while (v11 != 59);
      goto LABEL_26;
    }

    goto LABEL_25;
  }

  input->cur = cur + 3;
  input->col += 3;
  int v5 = cur[3];
  if (v5 == 59)
  {
LABEL_25:
    int v6 = 0;
    goto LABEL_26;
  }

  int v6 = 0;
  while ((v5 - 48) <= 9)
  {
    int v7 = v5 + 16 * v6 - 48;
LABEL_14:
    if (v6 < 1114112) {
      int v6 = v7;
    }
    xmlNextChar(v1);
    int v5 = *v1->input->cur;
    if (v5 == 59) {
      goto LABEL_26;
    }
  }

  if ((v5 - 97) <= 5)
  {
    int v7 = v5 + 16 * v6 - 87;
    goto LABEL_14;
  }

  if ((v5 - 65) <= 5)
  {
    int v7 = v5 + 16 * v6 - 55;
    goto LABEL_14;
  }

  BOOL v13 = v1;
  int v14 = 6;
LABEL_45:
  htmlParseErr(v13, v14, "htmlParseCharRef: missing semicolon\n", 0LL, 0LL);
  if (*v1->input->cur == 59) {
LABEL_26:
  }
    xmlNextChar(v1);
  if (v6 > 255)
  {
    if ((v6 - 0x10000) < 0x100000
      || v6 >> 11 < 0x1B
      || (v6 - 57344) >> 1 < 0xFFF)
    {
      return v6;
    }

    int v8 = "htmlParseCharRef: value too large\n";
    ctxt = v1;
    int v9 = 9;
LABEL_19:
    htmlParseErr(ctxt, v9, v8, 0LL, 0LL);
    return 0;
  }

  if (v6 <= 31 && (v6 > 0xD || ((1 << v6) & 0x2600) == 0))
  {
LABEL_21:
    htmlParseErrInt(v1, "htmlParseCharRef: invalid xmlChar value %d\n", v6);
    return 0;
  }

  return v6;
}

_DWORD *htmlParseErrInt(_DWORD *result, const char *a2, int a3)
{
  uint64_t v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 9;
    int result = __xmlRaiseError(0LL, 0LL, 0LL, result, 0LL, 5u, 9, 2, 0LL, 0, 0LL, 0LL, 0LL, a3, 0, a2, a3);
    v3[6] = 0;
  }

  return result;
}

void htmlParseElement(htmlParserCtxtPtr ctxt)
{
  if (!ctxt || (xmlParserInputPtr input = ctxt->input) == 0LL)
  {
    htmlParseErr(ctxt, 1, "htmlParseElement: context error\n", 0LL, 0LL);
    return;
  }

  if (ctxt->instate == XML_PARSER_EOF) {
    return;
  }
  memset(&info, 0, sizeof(info));
  if (ctxt->record_info)
  {
    unint64_t v3 = &input->cur[input->consumed] - input->base;
    unint64_t line = input->line;
    info.begin_pos = v3;
    info.begin_unint64_t line = line;
  }

  if (htmlParseStartTag((uint64_t)ctxt) != -1)
  {
    name = ctxt->name;
    if (name)
    {
      int v6 = bsearch( ctxt->name,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      if (!v6) {
        htmlParseErr(ctxt, 801, "Tag %s invalid\n", name, 0LL);
      }
      xmlParserInputPtr v7 = ctxt->input;
      cur = v7->cur;
      int v9 = *cur;
      if (v9 != 62)
      {
        if (v9 != 47 || cur[1] != 62)
        {
          htmlParseErr(ctxt, 73, "Couldn't find end of Start Tag %s\n", name, 0LL);
          if (xmlStrEqual(name, ctxt->name))
          {
            nodePop(ctxt);
            int nameNr = ctxt->nameNr;
            unsigned int v11 = nameNr - 1;
            if (nameNr >= 1)
            {
              ctxt->int nameNr = v11;
              nameTab = ctxt->nameTab;
              if (nameNr == 1) {
                unint64_t v36 = 0LL;
              }
              else {
                unint64_t v36 = nameTab[nameNr - 2];
              }
              ctxt->name = v36;
              nameTab[v11] = 0LL;
            }
          }

          if (ctxt->record_info)
          {
            xmlParserInputPtr v37 = ctxt->input;
            unint64_t v38 = &v37->cur[v37->consumed] - v37->base;
            unint64_t v39 = v37->line;
            info.end_pos = v38;
            info.end_unint64_t line = v39;
            info.node = ctxt->node;
            xmlParserAddNodeInfo(ctxt, &info);
          }

          return;
        }

        v7->cur = cur + 2;
        v7->col += 2;
LABEL_24:
        if (ctxt->sax)
        {
          endElementSAXFunc endElement = ctxt->sax->endElement;
          if (endElement) {
            ((void (*)(void *, const xmlChar *))endElement)(ctxt->userData, name);
          }
        }

        int v14 = ctxt->nameNr;
        unsigned int v15 = v14 - 1;
        if (v14 >= 1)
        {
          ctxt->int nameNr = v15;
          unsigned int v16 = ctxt->nameTab;
          if (v14 == 1) {
            int v40 = 0LL;
          }
          else {
            int v40 = v16[v14 - 2];
          }
          ctxt->name = v40;
          v16[v15] = 0LL;
        }

        return;
      }

      xmlNextChar(ctxt);
      if (v6 && v6[11]) {
        goto LABEL_24;
      }
      uint64_t v41 = xmlStrdup(ctxt->name);
      xmlParserInputPtr v17 = ctxt->input;
      int v18 = v17->cur;
      if (!*v18) {
        goto LABEL_95;
      }
      int v19 = ctxt->nameNr;
LABEL_33:
      unsigned __int8 v20 = xmlStrdup(ctxt->name);
      int v21 = ctxt->nameNr;
      while (1)
      {
        while (1)
        {
          if (!ctxt->progressive)
          {
            xmlParserInputPtr v22 = ctxt->input;
            if (v22->end - v22->cur <= 249) {
              xmlParserInputGrow(v22, 250);
            }
          }

          if (ctxt->instate == XML_PARSER_EOF)
          {
LABEL_90:
            if (!v20) {
              goto LABEL_92;
            }
LABEL_91:
            xmlFree(v20);
LABEL_92:
            xmlParserInputPtr v17 = ctxt->input;
            if (v18 == v17->cur || (int v18 = v17->cur, ctxt->nameNr < v19) || !*v18)
            {
LABEL_95:
              if (v41 && ctxt->record_info)
              {
                unint64_t v34 = &v18[v17->consumed] - v17->base;
                unint64_t v35 = v17->line;
                info.end_pos = v34;
                info.end_unint64_t line = v35;
                info.node = ctxt->node;
                xmlParserAddNodeInfo(ctxt, &info);
                xmlParserInputPtr v17 = ctxt->input;
              }

              if (!*v17->cur) {
                htmlAutoCloseOnEnd((uint64_t)ctxt);
              }
              if (v41) {
                xmlFree(v41);
              }
              return;
            }

            goto LABEL_33;
          }

          unint64_t v23 = ctxt->input->cur;
          if (*v23 == 60) {
            break;
          }
LABEL_51:
          int v27 = ctxt->nameNr;
          BOOL v28 = v27 < 1 || v21 < v27;
          if (!v28 && !xmlStrEqual(v20, ctxt->name)) {
            goto LABEL_90;
          }
          if (*ctxt->input->cur)
          {
            if (xmlStrEqual(v20, (const xmlChar *)"script") || xmlStrEqual(v20, (const xmlChar *)"style"))
            {
              htmlParseScript((uint64_t)ctxt);
              goto LABEL_82;
            }

            int v29 = ctxt->input->cur;
            if (*v29 == 60
              && v29[1] == 33
              && __toupper(v29[2]) == 68
              && __toupper(v29[3]) == 79
              && __toupper(v29[4]) == 67
              && __toupper(v29[5]) == 84
              && __toupper(v29[6]) == 89
              && __toupper(v29[7]) == 80
              && __toupper(v29[8]) == 69)
            {
              htmlParseErr(ctxt, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0LL);
              htmlParseDocTypeDecl(ctxt);
            }
          }

          unsigned int v30 = ctxt->input->cur;
          int v31 = *v30;
          if (v31 == 38)
          {
            htmlParseReference((uint64_t)ctxt);
          }

          else if (v31 == 60)
          {
            int v32 = v30[1];
            if (v32 == 63)
            {
              htmlParsePI((uint64_t)ctxt);
            }

            else if (v32 == 33 && v30[2] == 45 && v30[3] == 45)
            {
              htmlParseComment((uint64_t)ctxt);
            }

            else
            {
              htmlParseElement(ctxt);
            }
          }

          else
          {
            if (!*v30)
            {
              htmlAutoCloseOnEnd((uint64_t)ctxt);
              goto LABEL_90;
            }

            htmlParseCharData((uint64_t)ctxt);
          }

LABEL_82:
          if (!ctxt->progressive)
          {
            xmlParserInputPtr v33 = ctxt->input;
            if (v33->end - v33->cur <= 249) {
              xmlParserInputGrow(v33, 250);
            }
          }
        }

        int v24 = v23[1];
        if (v24 == 47)
        {
          if (htmlParseEndTag(ctxt))
          {
            if (v20) {
              goto LABEL_91;
            }
            if (!ctxt->nameNr) {
              goto LABEL_92;
            }
          }
        }

        else
        {
          if ((v24 & 0xFFFFFFDF) - 65 >= 0x1A && v24 != 95 && v24 != 58) {
            goto LABEL_51;
          }
          int v25 = htmlParseHTMLName_nonInvasive((uint64_t)ctxt);
          if (!v25)
          {
            htmlParseErr(ctxt, 68, "htmlParseStartTag: invalid element name\n", 0LL, 0LL);
            while (*ctxt->input->cur && *ctxt->input->cur != 62)
              xmlNextChar(ctxt);
            goto LABEL_90;
          }

          if (!ctxt->name) {
            goto LABEL_51;
          }
          uint64_t v26 = (uint64_t)v25;
          __key[0] = ctxt->name;
          __key[1] = v25;
          if (!bsearch( __key,  htmlStartClose,  0xFBuLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareStartClose)) {
            goto LABEL_51;
          }
          htmlAutoClose((int *)ctxt, v26);
        }
      }
    }
  }

  if (*ctxt->input->cur == 62) {
    xmlNextChar(ctxt);
  }
}

        int v6 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
        xmlParserInputPtr v7 = *v6;
        if (*v6) {
          unint64_t v36 = v7 == a2;
        }
        else {
          unint64_t v36 = 1;
        }
        if (v36) {
          goto LABEL_8;
        }
      }
    }

    uint64_t v10 = v4;
LABEL_8:
    *int v5 = 0;
  }

  else
  {
    htmlErrMemory((_DWORD *)a1, (uint64_t)"buffer allocation failed\n");
    return 0LL;
  }

  return v10;
}

              if (!(_DWORD)v23) {
                break;
              }
              goto LABEL_83;
            }

            goto LABEL_109;
          }

          ++i;
        }
      }

      else
      {
LABEL_83:
        xmlCompileStepPattern((uint64_t *)v10);
        unint64_t v36 = v10 + 1;
        if (!*((_DWORD *)v10 + 4))
        {
LABEL_91:
          for (j = *(unsigned __int8 **)v10; ; *(void *)uint64_t v10 = j)
          {
            int v40 = *j++;
            if (((1LL << v40) & 0x100002600LL) == 0)
            {
              if (!*(j - 1)) {
                goto LABEL_109;
              }
              if (v40 != 47) {
                goto LABEL_108;
              }
              xmlParserInputPtr v37 = *(_BYTE **)v10;
              if (**(_BYTE **)v10) {
                goto LABEL_85;
              }
              while (1)
              {
                unint64_t v38 = *v37;
                if (((1LL << v38) & 0x100002600LL) == 0) {
                  break;
                }
LABEL_85:
                *(void *)uint64_t v10 = ++v37;
              }

              if (!*v37 || v38 == 47) {
                goto LABEL_107;
              }
LABEL_100:
              xmlCompileStepPattern((uint64_t *)v10);
              if (!*((_DWORD *)v10 + 4)) {
                goto LABEL_91;
              }
              goto LABEL_107;
            }
          }

          goto LABEL_108;
        }
      }

    *(void *)(a1 + 208) = 0LL;
    *(_DWORD *)(a1 + 188) = 0;
  }

  else if (children)
  {
    if (!children->ns
      || !xmlStrEqual(children->name, (const xmlChar *)"annotation")
      || !xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
      || (children = children->next) != 0LL)
    {
      BOOL v28 = "(annotation?)";
LABEL_90:
      int v21 = 3033LL;
      xmlSchemaPContentErr(a1, 3033, (uint64_t)a3, (uint64_t)children, 0LL, (xmlChar *)v28);
    }
  }

  return v21;
}

uint64_t htmlParseStartTag(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2)
  {
    htmlParseErr((_DWORD *)a1, 1, "htmlParseStartTag: context error\n", 0LL, 0LL);
    return 0xFFFFFFFFLL;
  }

  if (*(_DWORD *)(a1 + 272) == -1 || **(_BYTE **)(v2 + 32) != 60) {
    return 0xFFFFFFFFLL;
  }
  xmlNextChar((xmlParserCtxtPtr)a1);
  unint64_t v3 = *(const xmlChar ***)(a1 + 464);
  int v4 = *(_DWORD *)(a1 + 472);
  if (!*(_DWORD *)(a1 + 452))
  {
    int v5 = *(xmlParserInput **)(a1 + 56);
    if (v5->end - v5->cur <= 249) {
      xmlParserInputGrow(v5, 250);
    }
  }

  int v6 = htmlParseHTMLName((xmlParserCtxtPtr)a1);
  if (!v6)
  {
    htmlParseErr((_DWORD *)a1, 68, "htmlParseStartTag: invalid element name\n", 0LL, 0LL);
    uint64_t v9 = 0xFFFFFFFFLL;
    while (1)
    {
      if (!**(_BYTE **)(*(void *)(a1 + 56) + 32LL) || **(_BYTE **)(*(void *)(a1 + 56) + 32LL) == 62) {
        return v9;
      }
      if (*(_DWORD *)(a1 + 272) == -1) {
        break;
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
    }

    return 0xFFFFFFFFLL;
  }

  xmlParserInputPtr v7 = (xmlChar *)v6;
  int v8 = xmlStrEqual(v6, (const xmlChar *)"meta");
  htmlAutoClose((int *)a1, (uint64_t)v7);
  htmlCheckImplied(a1, v7);
  if (*(int *)(a1 + 296) < 1)
  {
    uint64_t v9 = 0LL;
    goto LABEL_22;
  }

  if (xmlStrEqual(v7, (const xmlChar *)"html"))
  {
    htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <html> tag\n", v7, 0LL);
    ++*(_DWORD *)(a1 + 392);
    uint64_t v9 = 1LL;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  if (*(_DWORD *)(a1 + 296) != 1)
  {
LABEL_22:
    if (xmlStrEqual(v7, (const xmlChar *)"head"))
    {
      htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <head> tag\n", v7, 0LL);
      ++*(_DWORD *)(a1 + 392);
      uint64_t v9 = 1LL;
    }
  }

  int v38 = v8;
  if (xmlStrEqual(v7, (const xmlChar *)"body") && *(int *)(a1 + 296) >= 1)
  {
    uint64_t v11 = 0LL;
    do
    {
      if (xmlStrEqual(*(const xmlChar **)(*(void *)(a1 + 304) + 8 * v11), (const xmlChar *)"body"))
      {
        htmlParseErr((_DWORD *)a1, 800, "htmlParseStartTag: misplaced <body> tag\n", v7, 0LL);
        ++*(_DWORD *)(a1 + 392);
        uint64_t v9 = 1LL;
      }

      ++v11;
    }

    while (v11 < *(int *)(a1 + 296));
  }

  str1 = v7;
  htmlSkipBlankChars(a1);
  LODWORD(v12) = 0;
  while (1)
  {
    BOOL v13 = *(xmlParserInput **)(a1 + 56);
    cur = v13->cur;
    int v15 = *cur;
    if (v15 == 47)
    {
      int v15 = cur[1];
    }

    else if (!*cur)
    {
      break;
    }

    if (v15 == 62) {
      break;
    }
    if (!*(_DWORD *)(a1 + 452) && v13->end - cur <= 249) {
      xmlParserInputGrow(v13, 250);
    }
    unsigned int v16 = htmlParseHTMLName((xmlParserCtxtPtr)a1);
    if (!v16)
    {
      htmlParseErr((_DWORD *)a1, 68, "error parsing attribute name\n", 0LL, 0LL);
      while (1)
      {
        unint64_t v23 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
        int v24 = *v23;
        switch(v24)
        {
          case 47:
            int v24 = v23[1];
            break;
          case 13:
            goto LABEL_77;
          case 62:
            goto LABEL_77;
        }

        xmlNextChar((xmlParserCtxtPtr)a1);
      }
    }

    xmlParserInputPtr v17 = v16;
    htmlSkipBlankChars(a1);
    if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) != 61)
    {
      int v19 = 0LL;
      goto LABEL_61;
    }

    xmlNextChar((xmlParserCtxtPtr)a1);
    htmlSkipBlankChars(a1);
    int v18 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
    if (v18 == 39)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      int v19 = htmlParseHTMLAttribute(a1, 39);
      if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) == 39)
      {
LABEL_56:
        xmlNextChar((xmlParserCtxtPtr)a1);
        goto LABEL_61;
      }

      unsigned __int8 v20 = (_DWORD *)a1;
      int v21 = 40;
      xmlParserInputPtr v22 = "AttValue: ' expected\n";
    }

    else if (v18 == 34)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      int v19 = htmlParseHTMLAttribute(a1, 34);
      if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) == 34) {
        goto LABEL_56;
      }
      unsigned __int8 v20 = (_DWORD *)a1;
      int v21 = 40;
      xmlParserInputPtr v22 = "AttValue:  expected\n";
    }

    else
    {
      int v19 = htmlParseHTMLAttribute(a1, 0);
      if (v19) {
        goto LABEL_61;
      }
      unsigned __int8 v20 = (_DWORD *)a1;
      int v21 = 41;
      xmlParserInputPtr v22 = "AttValue: no value found\n";
    }

    htmlParseErr(v20, v21, v22, 0LL, 0LL);
LABEL_61:
    if ((int)v12 < 1)
    {
      if (v3)
      {
LABEL_67:
        v4 *= 2;
        uint64_t v26 = (const xmlChar **)xmlRealloc(v3, 8LL * v4);
        if (v26) {
          goto LABEL_75;
        }
        htmlErrMemory((_DWORD *)a1, 0LL);
        if (v19) {
          goto LABEL_72;
        }
      }

      else
      {
        uint64_t v26 = (const xmlChar **)xmlMalloc(0xB0uLL);
        if (v26)
        {
          int v4 = 22;
LABEL_75:
          *(void *)(a1 + 464) = v26;
          *(_DWORD *)(a1 + 472) = v4;
          unint64_t v3 = v26;
LABEL_76:
          int v27 = &v3[(int)v12];
          *int v27 = v17;
          v27[1] = v19;
          uint64_t v12 = (int)v12 + 2LL;
          v3[v12] = 0LL;
          v27[3] = 0LL;
          goto LABEL_77;
        }

        htmlErrMemory((_DWORD *)a1, 0LL);
        if (v19) {
          xmlFree(v19);
        }
        unint64_t v3 = 0LL;
        int v4 = 22;
      }
    }

    else
    {
      uint64_t v25 = 0LL;
      while (!xmlStrEqual(v3[v25], v17))
      {
        v25 += 2LL;
      }

      htmlParseErr((_DWORD *)a1, 42, "Attribute %s redefined\n", v17, 0LL);
      if (v19) {
LABEL_72:
      }
        xmlFree(v19);
    }

uint64_t htmlAutoCloseOnEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 296);
  if (v1 >= 1)
  {
    uint64_t v2 = result;
    unsigned int v3 = v1 + 1;
    do
    {
      if (*(void *)v2)
      {
        int v4 = *(uint64_t (**)(void, void))(*(void *)v2 + 120LL);
        if (v4)
        {
          int result = v4(*(void *)(v2 + 8), *(void *)(v2 + 288));
          int v1 = *(_DWORD *)(v2 + 296);
        }
      }

      unsigned int v5 = v1 - 1;
      if (v1 >= 1)
      {
        *(_DWORD *)(v2 + 296) = v5;
        uint64_t v6 = *(void *)(v2 + 304);
        if (v1 == 1) {
          uint64_t v7 = 0LL;
        }
        else {
          uint64_t v7 = *(void *)(v6 + 8LL * (v1 - 2));
        }
        *(void *)(v2 + 288) = v7;
        *(void *)(v6 + 8LL * v5) = 0LL;
        int v1 = v5;
      }

      --v3;
    }

    while (v3 > 1);
  }

  return result;
}

void __htmlParseContent(uint64_t a1)
{
  if (a1) {
    htmlParseContentInternal(a1);
  }
}

void htmlParseContentInternal(uint64_t a1)
{
  uint64_t v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
  int v3 = *(_DWORD *)(a1 + 296);
  while (1)
  {
    if (!*(_DWORD *)(a1 + 452))
    {
      int v4 = *(xmlParserInput **)(a1 + 56);
      if (v4->end - v4->cur <= 249) {
        xmlParserInputGrow(v4, 250);
      }
    }

    if (*(_DWORD *)(a1 + 272) == -1) {
      break;
    }
    unsigned int v5 = *(_BYTE **)(*(void *)(a1 + 56) + 32LL);
    if (*v5 != 60) {
      goto LABEL_15;
    }
    int v6 = v5[1];
    if (v6 == 47)
    {
      if (htmlParseEndTag((xmlParserCtxt *)a1))
      {
        if (v2) {
          goto LABEL_32;
        }
        if (!*(_DWORD *)(a1 + 296))
        {
LABEL_33:
          uint64_t v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
          int v3 = *(_DWORD *)(a1 + 296);
        }
      }
    }

    else
    {
      if ((v6 & 0xFFFFFFDF) - 65 >= 0x1A && v6 != 95 && v6 != 58) {
        goto LABEL_15;
      }
      uint64_t v7 = htmlParseHTMLName_nonInvasive(a1);
      if (!v7)
      {
        htmlParseErr((_DWORD *)a1, 68, "htmlParseStartTag: invalid element name\n", 0LL, 0LL);
        while (!**(_BYTE **)(*(void *)(a1 + 56) + 32LL))
          xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_31:
        htmlParserFinishElementParsing((xmlParserCtxtPtr)a1);
        if (!v2) {
          goto LABEL_33;
        }
LABEL_32:
        xmlFree(v2);
        goto LABEL_33;
      }

      if (*(void *)(a1 + 288)
        && (uint64_t v8 = (uint64_t)v7,
            *(void *)&__int128 v33 = *(void *)(a1 + 288),
            *((void *)&v33 + 1) = v7,
            bsearch( &v33,  htmlStartClose,  0xFBuLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareStartClose)))
      {
        htmlAutoClose((int *)a1, v8);
      }

      else
      {
LABEL_15:
        int v9 = *(_DWORD *)(a1 + 296);
        BOOL v10 = v9 < 1 || v3 < v9;
        if (!v10 && !xmlStrEqual(v2, *(const xmlChar **)(a1 + 288))) {
          goto LABEL_31;
        }
        if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL))
        {
          if (xmlStrEqual(v2, (const xmlChar *)"script") || xmlStrEqual(v2, (const xmlChar *)"style"))
          {
            htmlParseScript(a1);
            goto LABEL_93;
          }

          uint64_t v11 = *(_BYTE **)(*(void *)(a1 + 56) + 32LL);
          if (*v11 == 60
            && v11[1] == 33
            && __toupper(v11[2]) == 68
            && __toupper(v11[3]) == 79
            && __toupper(v11[4]) == 67
            && __toupper(v11[5]) == 84
            && __toupper(v11[6]) == 89
            && __toupper(v11[7]) == 80
            && __toupper(v11[8]) == 69)
          {
            htmlParseErr((_DWORD *)a1, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0LL);
            htmlParseDocTypeDecl((xmlParserCtxt *)a1);
          }
        }

        uint64_t v12 = *(void *)(a1 + 56);
        BOOL v13 = *(unsigned __int8 **)(v12 + 32);
        int v14 = *v13;
        if (v14 == 38)
        {
          htmlParseReference(a1);
        }

        else if (v14 == 60)
        {
          int v15 = v13[1];
          if (v15 == 63)
          {
            htmlParsePI(a1);
          }

          else
          {
            if (v15 != 33 || v13[2] != 45 || v13[3] != 45)
            {
              uint64_t v35 = 0LL;
              __int128 v33 = 0u;
              __int128 v34 = 0u;
              if (*(_DWORD *)(a1 + 272) == -1) {
                goto LABEL_90;
              }
              if (*(_DWORD *)(a1 + 104))
              {
                unsigned int v16 = &v13[*(void *)(v12 + 64) - *(void *)(v12 + 24)];
                uint64_t v17 = *(int *)(v12 + 52);
                *((void *)&v33 + 1) = v16;
                *(void *)&__int128 v34 = v17;
              }

              if (htmlParseStartTag(a1) == -1 || (int v18 = *(const xmlChar **)(a1 + 288)) == 0LL)
              {
                if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) != 62) {
                  goto LABEL_90;
                }
                xmlNextChar((xmlParserCtxtPtr)a1);
                if (v2) {
                  goto LABEL_91;
                }
              }

              else
              {
                int v19 = bsearch( *(const void **)(a1 + 288),  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
                if (!v19) {
                  htmlParseErr((_DWORD *)a1, 801, "Tag %s invalid\n", v18, 0LL);
                }
                uint64_t v20 = *(void *)(a1 + 56);
                int v21 = *(unsigned __int8 **)(v20 + 32);
                int v22 = *v21;
                if (v22 == 62)
                {
                  xmlNextChar((xmlParserCtxtPtr)a1);
                  if (v19 && v19[11])
                  {
LABEL_76:
                    if (*(void *)a1)
                    {
                      uint64_t v26 = *(void (**)(void, const xmlChar *))(*(void *)a1 + 120LL);
                      if (v26) {
                        v26(*(void *)(a1 + 8), v18);
                      }
                    }

                    int v27 = *(_DWORD *)(a1 + 296);
                    unsigned int v28 = v27 - 1;
                    if (v27 < 1) {
                      goto LABEL_90;
                    }
                    *(_DWORD *)(a1 + 296) = v28;
                    uint64_t v29 = *(void *)(a1 + 304);
                    if (v27 == 1) {
                      uint64_t v32 = 0LL;
                    }
                    else {
                      uint64_t v32 = *(void *)(v29 + 8LL * (v27 - 2));
                    }
                    *(void *)(a1 + 288) = v32;
                    *(void *)(v29 + 8LL * v28) = 0LL;
                    if (v2) {
LABEL_91:
                    }
                      xmlFree(v2);
                  }

                  else
                  {
                    if (!*(_DWORD *)(a1 + 104)) {
                      goto LABEL_90;
                    }
                    htmlNodeInfoPush(a1, &v33);
                    if (v2) {
                      goto LABEL_91;
                    }
                  }
                }

                else
                {
                  if (v22 == 47 && v21[1] == 62)
                  {
                    *(void *)(v20 + 32) = v21 + 2;
                    *(_DWORD *)(v20 + 56) += 2;
                    goto LABEL_76;
                  }

                  htmlParseErr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s\n", v18, 0LL);
                  if (xmlStrEqual(v18, *(const xmlChar **)(a1 + 288)))
                  {
                    nodePop((xmlParserCtxtPtr)a1);
                    int v23 = *(_DWORD *)(a1 + 296);
                    unsigned int v24 = v23 - 1;
                    if (v23 >= 1)
                    {
                      *(_DWORD *)(a1 + 296) = v24;
                      uint64_t v25 = *(void *)(a1 + 304);
                      if (v23 == 1) {
                        uint64_t v30 = 0LL;
                      }
                      else {
                        uint64_t v30 = *(void *)(v25 + 8LL * (v23 - 2));
                      }
                      *(void *)(a1 + 288) = v30;
                      *(void *)(v25 + 8LL * v24) = 0LL;
                    }
                  }

                  if (*(_DWORD *)(a1 + 104)) {
                    htmlNodeInfoPush(a1, &v33);
                  }
                  htmlParserFinishElementParsing((xmlParserCtxtPtr)a1);
LABEL_90:
                  if (v2) {
                    goto LABEL_91;
                  }
                }
              }

              uint64_t v2 = xmlStrdup(*(const xmlChar **)(a1 + 288));
              int v3 = *(_DWORD *)(a1 + 296);
              goto LABEL_93;
            }

            htmlParseComment(a1);
          }
        }

        else
        {
          if (!*v13)
          {
            htmlAutoCloseOnEnd(a1);
            break;
          }

          htmlParseCharData(a1);
        }

LABEL_93:
        if (!*(_DWORD *)(a1 + 452))
        {
          int v31 = *(xmlParserInput **)(a1 + 56);
          if (v31->end - v31->cur <= 249) {
            xmlParserInputGrow(v31, 250);
          }
        }
      }
    }
  }

  if (v2) {
    xmlFree(v2);
  }
}

        xmlRngPErr(a1, *((void *)v6 + 1), 1086, "Found forbidden pattern oneOrMore//group//attribute\n", 0LL, 0LL);
        if ((a3 & 0x40) == 0)
        {
LABEL_56:
          if ((a3 & 8) == 0) {
            goto LABEL_57;
          }
          goto LABEL_95;
        }

    if (v12 + 10 <= v18)
    {
LABEL_97:
      if (len == 1) {
        v6[v12++] = v5;
      }
      else {
        v12 += xmlCopyChar(len, &v6[v12], v5);
      }
      a1->cur += len;
      unsigned int v5 = xmlXPathCurrentChar(a1, &len);
      continue;
    }

    break;
  }

  if (v18 >= 50001)
  {
    xmlFree(v6);
    goto LABEL_111;
  }

  v18 *= 2;
  unsigned int v24 = xmlRealloc(v6, v18);
  if (v24)
  {
    int v6 = v24;
    goto LABEL_97;
  }

  xmlFree(v6);
  uint64_t v26 = a1;
  int v27 = 15;
LABEL_112:
  xmlXPathErr(v26, v27);
  return 0LL;
}

int htmlParseDocument(htmlParserCtxtPtr ctxt)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  xmlInitParser();
  htmlDefaultSAXHandlerInit();
  if (ctxt && (xmlParserInputPtr input = ctxt->input) != 0LL)
  {
    ctxt->html = 1;
    ctxt->linenumbers = 1;
    if (!ctxt->progressive && input->end - input->cur <= 249) {
      xmlParserInputGrow(input, 250);
    }
    if (ctxt->sax)
    {
      setDocumentLocatorSAXFunc setDocumentLocator = ctxt->sax->setDocumentLocator;
      if (setDocumentLocator)
      {
        userData = ctxt->userData;
        unsigned int v5 = __xmlDefaultSAXLocator();
        ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v5);
      }
    }

    *(_DWORD *)in = 0;
    if (!ctxt->encoding)
    {
      cur = ctxt->input->cur;
      if (ctxt->input->end - cur >= 4)
      {
        char v7 = ctxt->token ? -1 : *cur;
        in[0] = v7;
        in[1] = cur[1];
        in[2] = cur[2];
        in[3] = cur[3];
        xmlCharEncoding v9 = xmlDetectCharEncoding(in, 4);
        if (v9)
        {
          if (xmlSwitchEncoding(ctxt, v9) < 0)
          {
            *(void *)__str = 0LL;
            memset(v21, 0, 11);
            snprintf(__str, 0x14uLL, "0x%02X 0x%02X 0x%02X 0x%02X", in[0], in[1], in[2], in[3]);
            v21[11] = 0;
            if (ctxt->errNo) {
              int errNo = ctxt->errNo;
            }
            else {
              int errNo = 6003;
            }
            htmlParseErr( ctxt,  errNo,  "htmlCheckEncoding: error switching to encoding, bytes %s\n",  (const xmlChar *)__str,  0LL);
          }
        }
      }
    }

    htmlSkipBlankChars((uint64_t)ctxt);
    if (!*ctxt->input->cur) {
      htmlParseErr(ctxt, 4, "Document is empty\n", 0LL, 0LL);
    }
    if (ctxt->sax)
    {
      startDocumentSAXFunc startDocument = ctxt->sax->startDocument;
      if (startDocument)
      {
        if (!ctxt->disableSAX) {
          ((void (*)(void *))startDocument)(ctxt->userData);
        }
      }
    }

    while (1)
    {
      uint64_t v12 = ctxt->input->cur;
      if (*v12 != 60) {
        break;
      }
      int v13 = v12[1];
      if (v13 != 63)
      {
        if (v13 != 33) {
          break;
        }
        if (v12[2] != 45 || v12[3] != 45)
        {
          if (__toupper(v12[2]) == 68
            && __toupper(v12[3]) == 79
            && __toupper(v12[4]) == 67
            && __toupper(v12[5]) == 84
            && __toupper(v12[6]) == 89
            && __toupper(v12[7]) == 80
            && __toupper(v12[8]) == 69)
          {
            htmlParseDocTypeDecl(ctxt);
          }

          break;
        }
      }

      htmlParseComment((uint64_t)ctxt);
      htmlParsePI((uint64_t)ctxt);
      htmlSkipBlankChars((uint64_t)ctxt);
    }

    while (1)
    {
      htmlSkipBlankChars((uint64_t)ctxt);
      int v15 = ctxt->input->cur;
      if (*v15 != 60) {
        break;
      }
      int v14 = v15[1];
      if (v14 != 63 && (v14 != 33 || v15[2] != 45 || v15[3] != 45)) {
        break;
      }
      htmlParseComment((uint64_t)ctxt);
      htmlParsePI((uint64_t)ctxt);
    }

    htmlParseContentInternal((uint64_t)ctxt);
    if (!*ctxt->input->cur) {
      htmlAutoCloseOnEnd((uint64_t)ctxt);
    }
    if (ctxt->sax)
    {
      endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
      if (endDocument) {
        ((void (*)(void *))endDocument)(ctxt->userData);
      }
    }

    if ((ctxt->options & 4) == 0)
    {
      myDoc = ctxt->myDoc;
      if (myDoc)
      {
        if (!xmlGetIntSubset(myDoc)) {
          ctxt->myDoc->intSubset = xmlCreateIntSubset( ctxt->myDoc,  (const xmlChar *)"html",  (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN",  (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd");
        }
      }
    }

    if (ctxt->wellFormed) {
      return 0;
    }
    else {
      return -1;
    }
  }

  else
  {
    int v8 = 1;
    htmlParseErr(ctxt, 1, "htmlParseDocument: context error\n", 0LL, 0LL);
  }

  return v8;
}

xmlParserInput *htmlSkipBlankChars(uint64_t a1)
{
  while (1)
  {
    int result = *(xmlParserInput **)(a1 + 56);
    cur = result->cur;
    unsigned int v4 = *cur;
    if (v4 > 0xC) {
      break;
    }
    if (v4 == 9) {
      goto LABEL_7;
    }
    if (v4 != 10) {
      return result;
    }
    ++result->line;
    result->col = 1;
LABEL_8:
    result->cur = cur + 1;
    if (!cur[1]) {
      xmlParserInputGrow(result, 250);
    }
  }

  if (v4 == 13 || v4 == 32)
  {
LABEL_7:
    ++result->col;
    goto LABEL_8;
  }

  return result;
}

void htmlParseComment(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 276)) {
    return;
  }
  uint64_t v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (*cur != 60 || cur[1] != 33 || cur[2] != 45 || cur[3] != 45) {
    return;
  }
  int v4 = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = 5;
  unsigned int v5 = cur + 4;
  v2->cur = v5;
  v2->col += 4;
  if (v5 - v2->base >= 501 && v2->end - v5 <= 499) {
    xmlParserInputShrink(v2);
  }
  int v6 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v6)
  {
    htmlErrMemory((_DWORD *)a1, (uint64_t)"buffer allocation failed\n");
    *(_DWORD *)(a1 + 272) = v4;
    return;
  }

  char v7 = v6;
  int v37 = 0;
  *int v6 = 0;
  int v8 = htmlCurrentChar(a1, &v37);
  if (!v8) {
    goto LABEL_64;
  }
  int v9 = v8;
  uint64_t v10 = *(void *)(a1 + 56);
  int v11 = v37;
  uint64_t v12 = *(_BYTE **)(v10 + 32);
  int v13 = &v12[v37];
  if ((unint64_t)v13 <= *(void *)(v10 + 40))
  {
    if (*v12 == 10)
    {
      ++*(_DWORD *)(v10 + 52);
      *(_DWORD *)(v10 + 56) = 1;
    }

    else
    {
      ++*(_DWORD *)(v10 + 56);
    }

    *(_DWORD *)(a1 + 276) = 0;
    *(void *)(v10 + 32) = v13;
    ++*(void *)(a1 + 312);
  }

  int v36 = 0;
  int v34 = htmlCurrentChar(a1, &v36);
  if (!v34)
  {
LABEL_64:
    htmlParseErr((_DWORD *)a1, 45, "Comment not terminated \n<!--%.50s\n", v7, 0LL);
    xmlFree(v7);
    return;
  }

  uint64_t v14 = *(void *)(a1 + 56);
  int v15 = v36;
  unsigned int v16 = *(_BYTE **)(v14 + 32);
  uint64_t v17 = &v16[v36];
  if ((unint64_t)v17 <= *(void *)(v14 + 40))
  {
    if (*v16 == 10)
    {
      ++*(_DWORD *)(v14 + 52);
      *(_DWORD *)(v14 + 56) = 1;
    }

    else
    {
      ++*(_DWORD *)(v14 + 56);
    }

    *(_DWORD *)(a1 + 276) = 0;
    *(void *)(v14 + 32) = v17;
    ++*(void *)(a1 + 312);
  }

  uint64_t v35 = 0LL;
  int v18 = htmlCurrentChar(a1, (_DWORD *)&v35 + 1);
  if (!v18)
  {
    int v20 = 0;
LABEL_63:
    v7[v20] = 0;
    goto LABEL_64;
  }

  int v19 = v18;
  int v33 = v4;
  int v20 = 0;
  int v21 = 100;
  while (1)
  {
    int v22 = v34;
    int v34 = v19;
    if (v9 == 45 && v22 == 45 && v19 == 62) {
      break;
    }
    uint64_t v23 = *(void *)(a1 + 56);
    int v24 = HIDWORD(v35);
    uint64_t v25 = *(_BYTE **)(v23 + 32);
    uint64_t v26 = &v25[SHIDWORD(v35)];
    if ((unint64_t)v26 <= *(void *)(v23 + 40))
    {
      if (*v25 == 10)
      {
        ++*(_DWORD *)(v23 + 52);
        int v27 = 1;
      }

      else
      {
        int v27 = *(_DWORD *)(v23 + 56) + 1;
      }

      *(_DWORD *)(v23 + 56) = v27;
      *(_DWORD *)(a1 + 276) = 0;
      *(void *)(v23 + 32) = v26;
      ++*(void *)(a1 + 312);
    }

    int v19 = htmlCurrentChar(a1, &v35);
    if (!v19)
    {
      unsigned int v28 = *(xmlParserInput **)(a1 + 56);
      uint64_t v29 = v28->cur;
      if (v29 - v28->base >= 501 && v28->end - v29 <= 499) {
        xmlParserInputShrink(v28);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        uint64_t v30 = *(xmlParserInput **)(a1 + 56);
        if (v30->end - v30->cur <= 249) {
          xmlParserInputGrow(v30, 250);
        }
      }

      int v19 = htmlCurrentChar(a1, &v35);
    }

    if (v9 == 45 && v22 == 45 && v34 == 33 && v19 == 62)
    {
      htmlParseErr((_DWORD *)a1, 45, "Comment incorrectly closed by '--!>'", 0LL, 0LL);
      break;
    }

    if (v20 + 5 >= v21)
    {
      v21 *= 2;
      int v31 = (xmlChar *)xmlRealloc(v7, v21);
      if (!v31)
      {
        xmlFree(v7);
        htmlErrMemory((_DWORD *)a1, (uint64_t)"growing buffer failed\n");
        goto LABEL_72;
      }

      char v7 = v31;
    }

    if (v9 > 255)
    {
      if ((v9 - 0x10000) < 0x100000
        || v9 >> 11 < 0x1B
        || (v9 - 57344) >> 1 <= 0xFFE)
      {
LABEL_57:
        if (v11 == 1)
        {
          v7[v20++] = v9;
          int v24 = HIDWORD(v35);
          int v15 = v36;
        }

        else
        {
          v20 += xmlCopyChar(v11, &v7[v20], v9);
        }

        goto LABEL_60;
      }
    }

    else if (v9 > 31 || v9 <= 0xD && ((1 << v9) & 0x2600) != 0)
    {
      goto LABEL_57;
    }

    htmlParseErrInt((_DWORD *)a1, "Invalid char in comment 0x%X\n", v9);
LABEL_60:
    int v11 = v15;
    HIDWORD(v35) = v35;
    int v36 = v24;
    int v15 = v24;
    int v9 = v22;
    if (!v19) {
      goto LABEL_63;
    }
  }

  v7[v20] = 0;
  xmlNextChar((xmlParserCtxtPtr)a1);
  if (*(void *)a1)
  {
    uint64_t v32 = *(void (**)(void, xmlChar *))(*(void *)a1 + 160LL);
    if (v32)
    {
      if (!*(_DWORD *)(a1 + 332)) {
        v32(*(void *)(a1 + 8), v7);
      }
    }
  }

  xmlFree(v7);
LABEL_72:
  *(_DWORD *)(a1 + 272) = v33;
}

void htmlParsePI(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 276)) {
    return;
  }
  uint64_t v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (*cur != 60 || cur[1] != 63) {
    return;
  }
  int v4 = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = 2;
  unsigned int v5 = cur + 2;
  v2->cur = v5;
  v2->col += 2;
  if (v5 - v2->base >= 501 && v2->end - v5 <= 499) {
    xmlParserInputShrink(v2);
  }
  int v6 = htmlParseName(a1);
  if (!v6)
  {
    htmlParseErr((_DWORD *)a1, 46, "PI is not started correctly", 0LL, 0LL);
    goto LABEL_68;
  }

  char v7 = v6;
  if (!*(_DWORD *)(a1 + 276))
  {
    uint64_t v8 = *(void *)(a1 + 56);
    int v9 = *(_BYTE **)(v8 + 32);
    if (*v9 == 62)
    {
      *(void *)(v8 + 32) = v9 + 1;
      ++*(_DWORD *)(v8 + 56);
      if (*(void *)a1 && !*(_DWORD *)(a1 + 332))
      {
        uint64_t v10 = *(void (**)(void, const xmlChar *, void))(*(void *)a1 + 152LL);
        if (v10) {
          v10(*(void *)(a1 + 8), v6, 0LL);
        }
      }

      goto LABEL_68;
    }
  }

  int v11 = xmlMallocAtomic(0x64uLL);
  if (!v11)
  {
    htmlErrMemory((_DWORD *)a1, 0LL);
    goto LABEL_68;
  }

  uint64_t v12 = v11;
  unsigned int v13 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
  BOOL v14 = v13 > 0x20;
  uint64_t v15 = (1LL << v13) & 0x100002600LL;
  if (v14 || v15 == 0) {
    htmlParseErr((_DWORD *)a1, 65, "ParsePI: PI %s space expected\n", v7, 0LL);
  }
  int len = 0;
  htmlSkipBlankChars(a1);
  int v17 = htmlCurrentChar(a1, &len);
  int v18 = 0;
  int v19 = 0;
  int v20 = 100;
  while (v17 && v17 != 62)
  {
    if (v18 + 5 >= v20)
    {
      v20 *= 2;
      int v21 = xmlRealloc(v12, v20);
      if (!v21)
      {
        htmlErrMemory((_DWORD *)a1, 0LL);
        goto LABEL_67;
      }

      uint64_t v12 = v21;
    }

    if (v19 >= 50)
    {
      if (!*(_DWORD *)(a1 + 452))
      {
        int v22 = *(xmlParserInput **)(a1 + 56);
        if (v22->end - v22->cur <= 249) {
          xmlParserInputGrow(v22, 250);
        }
      }

      int v19 = 0;
    }

    else
    {
      ++v19;
    }

    if (v17 > 255)
    {
      if ((v17 - 0x10000) >= 0x100000
        && v17 >> 11 >= 0x1B
        && (v17 - 57344) >> 1 > 0xFFE)
      {
LABEL_41:
        htmlParseErrInt((_DWORD *)a1, "Invalid char in processing instruction 0x%X\n", v17);
        goto LABEL_45;
      }
    }

    else if (v17 <= 31 && (v17 > 0xD || ((1 << v17) & 0x2600) == 0))
    {
      goto LABEL_41;
    }

    if (len == 1) {
      *((_BYTE *)v12 + v18++) = v17;
    }
    else {
      v18 += xmlCopyChar(len, (xmlChar *)v12 + v18, v17);
    }
LABEL_45:
    uint64_t v23 = *(void *)(a1 + 56);
    int v24 = *(_BYTE **)(v23 + 32);
    uint64_t v25 = &v24[len];
    if ((unint64_t)v25 <= *(void *)(v23 + 40))
    {
      if (*v24 == 10)
      {
        ++*(_DWORD *)(v23 + 52);
        *(_DWORD *)(v23 + 56) = 1;
      }

      else
      {
        ++*(_DWORD *)(v23 + 56);
      }

      *(_DWORD *)(a1 + 276) = 0;
      *(void *)(v23 + 32) = v25;
      ++*(void *)(a1 + 312);
    }

    int v17 = htmlCurrentChar(a1, &len);
    if (!v17)
    {
      uint64_t v26 = *(xmlParserInput **)(a1 + 56);
      int v27 = v26->cur;
      if (v27 - v26->base >= 501 && v26->end - v27 <= 499) {
        xmlParserInputShrink(v26);
      }
      if (!*(_DWORD *)(a1 + 452))
      {
        unsigned int v28 = *(xmlParserInput **)(a1 + 56);
        if (v28->end - v28->cur <= 249) {
          xmlParserInputGrow(v28, 250);
        }
      }

      int v17 = htmlCurrentChar(a1, &len);
    }
  }

  *((_BYTE *)v12 + v18) = 0;
  if (v17 == 62)
  {
    uint64_t v29 = *(void *)(a1 + 56);
    ++*(void *)(v29 + 32);
    ++*(_DWORD *)(v29 + 56);
    if (*(void *)a1)
    {
      if (!*(_DWORD *)(a1 + 332))
      {
        uint64_t v30 = *(void (**)(void, const xmlChar *, void *))(*(void *)a1 + 152LL);
        if (v30) {
          v30(*(void *)(a1 + 8), v7, v12);
        }
      }
    }
  }

  else
  {
    htmlParseErr((_DWORD *)a1, 47, "ParsePI: PI %s never end ...\n", v7, 0LL);
  }

LABEL_67:
  xmlFree(v12);
LABEL_68:
  *(_DWORD *)(a1 + 272) = v4;
}

              ++v20;
            }

            while (v20 < v19);
          }

          int v40 = *(_DWORD *)(v16 + 24);
          *(_DWORD *)(v16 + 24) = v40 + 1;
          uint64_t v41 = *(int **)(v17 + 16);
          uint64_t v42 = *v41;
          if ((*v41 & 4) != 0)
          {
            int v9 = v61;
            char v7 = v63;
          }

          else
          {
            unsigned int v43 = (const xmlChar *)*((void *)v41 + 1);
            int v44 = (const xmlChar *)*((void *)v41 + 2);
            uint64_t v45 = v41[6];
            int v46 = *(_DWORD *)(v16 + 40);
            char v7 = v63;
            if ((v46 & 7) != 0)
            {
              if (v40)
              {
                if ((v42 & 1) == 0 && (v40 != 1 || (v46 & 6) == 0)) {
                  goto LABEL_96;
                }
              }

              else if ((v46 & 6) != 0)
              {
                goto LABEL_96;
              }
            }

            if (v45 == a4)
            {
              if (a4 == 100) {
                goto LABEL_94;
              }
              if (v43)
              {
                if (!str2
                  || (v63 != 0LL) == (v44 == 0LL)
                  || *v43 != *str2
                  || (v47 = v15, v48 = xmlStrEqual(v43, str2), uint64_t v15 = v47, !v48)
                  || v44 != v63 && (v49 = xmlStrEqual(v44, v63), uint64_t v15 = v47, !v49))
                {
LABEL_105:
                  BOOL v14 = v42 & 2;
                  uint64_t v50 = 1;
                  goto LABEL_106;
                }

    if ((_DWORD)v21 != 64)
    {
      if ((_DWORD)v21 == 47)
      {
        uint64_t v29 = *((void *)v10 + 4);
LABEL_70:
        uint64_t v32 = *(_BYTE **)v10;
        if (**(_BYTE **)v10) {
          goto LABEL_203;
        }
        while (1)
        {
          __int128 v80 = *v32;
          if (v80 > 0x20) {
            goto LABEL_207;
          }
          if (((1LL << v80) & 0x100002600LL) == 0) {
            break;
          }
LABEL_203:
          *(void *)uint64_t v10 = ++v32;
        }

        if (!*v32) {
          goto LABEL_107;
        }
      }

      terminateBufferTooSmall(&__s, 5000);
LABEL_68:
      if (name) {
        goto LABEL_38;
      }
LABEL_69:
      int v27 = "Element content does not follow the DTD, expecting %s, got %s\n";
      uint64_t v32 = v51;
      p_s = (xmlChar *)&__s;
      uint64_t v30 = (uint64_t *)v9;
      int v31 = v6;
      uint64_t v29 = 0LL;
      goto LABEL_70;
    }

    terminateBufferTooSmall(&__s, 5000);
  }

  if (!name) {
    goto LABEL_69;
  }
LABEL_38:
  int v27 = "Element %s content does not follow the DTD, expecting %s, got %s\n";
  p_s = v51;
  uint64_t v29 = &__s;
  uint64_t v30 = (uint64_t *)v9;
  int v31 = v6;
  uint64_t v32 = name;
LABEL_70:
  xmlErrValidNode(v30, v31, 504, (uint64_t)v27, (uint64_t)v32, p_s, (xmlChar *)v29);
  uint64_t v25 = 0LL;
LABEL_71:
  *(void *)(v9 + 32) = 0LL;
  uint64_t v47 = *(void **)(v9 + 40);
  if (v47)
  {
    xmlFree(v47);
    *(void *)(v9 + 40) = 0LL;
  }

  return v25;
}

          int result = 0;
          BOOL v14 = 5;
LABEL_68:
          *((_DWORD *)reader + 6) = v14;
          return result;
        }

        if (!v26 && !*((_DWORD *)reader + 74) && !*((_DWORD *)reader + 44))
        {
          uint64_t v62 = *(void *)(v28 + 32);
          if (v62)
          {
            if ((*(_WORD *)(v62 + 114) & 2) == 0)
            {
              xmlUnlinkNode(*(xmlNodePtr *)(v28 + 32));
              xmlTextReaderFreeNode((uint64_t)reader, (xmlAttr *)v62);
            }
          }
        }

        --*((_DWORD *)reader + 32);
        int v33 = 4;
LABEL_106:
        *((_DWORD *)reader + 6) = v33;
        goto LABEL_125;
      }

      if (v6 == 1)
      {
        int v38 = *(_DWORD *)(v8 + 8) == 1 ? v34 : 1;
      }

          if (++v36 == v162) {
            goto LABEL_78;
          }
        }

        int v37 = xmlSchemaAreValuesEqual( *(xmlSchemaValPtr *)(*(void *)v29 + 8LL),  *(xmlSchemaVal **)(**(void **)(*(void *)(v15[2] + 8 * v36) + 8LL) + 8LL));
        if (!v37) {
          goto LABEL_67;
        }
        if (v37 == -1) {
          goto LABEL_304;
        }
LABEL_74:
        uint64_t v42 = (void *)v15[4];
        if (!v42)
        {
          uint64_t v42 = xmlSchemaItemListCreate();
          v15[4] = v42;
          if (!v42) {
            goto LABEL_304;
          }
        }

        unsigned int v43 = *((int *)v15 + 6) - 1LL;
        *(void *)(v15[2] + 8LL * v36) = *(void *)(v15[2] + 8 * v43);
        *((_DWORD *)v15 + 6) = v43;
LABEL_84:
        ++v22;
        int v24 = v166;
        uint64_t v8 = v176;
      }

      while (v22 != v164);
LABEL_90:
      int v9 = *(void *)(v9 + 8);
      if (!v9) {
        goto LABEL_91;
      }
    }

    int v19 = 0;
LABEL_35:
    __int128 v172 = 0LL;
    goto LABEL_36;
  }

  if (v9 != a2)
  {
    if (v6 >= 2 && v17 == 3)
    {
      uint64_t v23 = v9;
      uint64_t v2 = 1LL;
      while (1)
      {
        uint64_t v23 = *(void *)(v23 + 40);
        if (!v23) {
          break;
        }
        if (v23 == a2) {
          return v2;
        }
      }
    }

    if (v6 == 3 && v17 >= 2)
    {
      int v24 = a2;
      uint64_t v2 = 0xFFFFFFFFLL;
      while (1)
      {
        int v24 = *(void *)(v24 + 40);
        if (!v24) {
          break;
        }
        if (v24 == v9) {
          return v2;
        }
      }
    }

void htmlParseDocTypeDecl(xmlParserCtxt *a1)
{
  xmlParserInputPtr input = a1->input;
  input->cur += 9;
  input->col += 9;
  htmlSkipBlankChars((uint64_t)a1);
  int v3 = htmlParseName((uint64_t)a1);
  if (!v3) {
    htmlParseErr(a1, 68, "htmlParseDocTypeDecl : no DOCTYPE name !\n", 0LL, 0LL);
  }
  htmlSkipBlankChars((uint64_t)a1);
  xmlParserInputPtr v4 = a1->input;
  cur = (unsigned __int8 *)v4->cur;
  if (__toupper(*cur) == 83
    && __toupper(cur[1]) == 89
    && __toupper(cur[2]) == 83
    && __toupper(cur[3]) == 84
    && __toupper(cur[4]) == 69
    && __toupper(cur[5]) == 77)
  {
    v4->cur = cur + 6;
    xmlParserInputPtr v6 = a1->input;
    v6->col += 6;
    LODWORD(v6) = *v6->cur;
    BOOL v7 = v6 > 0x20;
    uint64_t v8 = (1LL << (char)v6) & 0x100002600LL;
    if (v7 || v8 == 0) {
      htmlParseErr(a1, 65, "Space required after 'SYSTEM'\n", 0LL, 0LL);
    }
    htmlSkipBlankChars((uint64_t)a1);
    uint64_t v10 = htmlParseSystemLiteral(a1);
    if (!v10) {
      htmlParseErr(a1, 70, "htmlParseExternalID: SYSTEM, no URI\n", 0LL, 0LL);
    }
    int v11 = 0LL;
  }

  else
  {
    xmlParserInputPtr v12 = a1->input;
    unsigned int v13 = (unsigned __int8 *)v12->cur;
    if (__toupper(*v13) == 80
      && __toupper(v13[1]) == 85
      && __toupper(v13[2]) == 66
      && __toupper(v13[3]) == 76
      && __toupper(v13[4]) == 73
      && __toupper(v13[5]) == 67)
    {
      v12->cur = v13 + 6;
      xmlParserInputPtr v14 = a1->input;
      v14->col += 6;
      unsigned int v15 = *v14->cur;
      if (v15 > 0x20 || ((1LL << v15) & 0x100002600LL) == 0) {
        htmlParseErr(a1, 65, "Space required after 'PUBLIC'\n", 0LL, 0LL);
      }
      htmlSkipBlankChars((uint64_t)a1);
      int v11 = htmlParsePubidLiteral(a1);
      if (!v11) {
        htmlParseErr(a1, 71, "htmlParseExternalID: PUBLIC, no Public Identifier\n", 0LL, 0LL);
      }
      htmlSkipBlankChars((uint64_t)a1);
      int v16 = *a1->input->cur;
      if (v16 == 39 || v16 == 34)
      {
        uint64_t v10 = htmlParseSystemLiteral(a1);
        goto LABEL_34;
      }
    }

    else
    {
      int v11 = 0LL;
    }

    uint64_t v10 = 0LL;
  }

htmlParserCtxtPtr htmlNewParserCtxt(void)
{
  xmlGenericErrorFunc v0 = (xmlParserCtxt *)xmlMalloc(0x2F0uLL);
  int v1 = v0;
  if (!v0)
  {
    htmlErrMemory(0LL, (uint64_t)"NewParserCtxt: out of memory\n");
    return v1;
  }

  bzero(v0, 0x2F0uLL);
  bzero(v1, 0x2F0uLL);
  uint64_t v2 = xmlDictCreate();
  v1->dict = v2;
  if (!v2 || (uint64_t v2 = (xmlDict *)xmlMalloc(0x100uLL)) == 0LL)
  {
    htmlErrMemory(v2, (uint64_t)"htmlInitParserCtxt: out of memory\n");
LABEL_9:
    xmlFreeParserCtxt(v1);
    return 0LL;
  }

  int v3 = (_xmlSAXHandler *)v2;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 11) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  xmlParserInputPtr v4 = (xmlParserInputPtr *)xmlMalloc(0x28uLL);
  v1->inputTab = v4;
  if (!v4)
  {
    htmlErrMemory(0LL, (uint64_t)"htmlInitParserCtxt: out of memory\n");
    v1->xmlParserInputPtr input = 0LL;
    *(void *)&v1->inputNr = 0LL;
    goto LABEL_9;
  }

  v1->xmlParserInputPtr input = 0LL;
  p_xmlParserInputPtr input = &v1->input;
  *(void *)&v1->inputNr = 0x500000000LL;
  v1->version = 0LL;
  v1->encoding = 0LL;
  v1->standalone = -1;
  v1->instate = XML_PARSER_START;
  xmlParserInputPtr v6 = (xmlNodePtr *)xmlMalloc(0x50uLL);
  v1->nodeTab = v6;
  if (!v6)
  {
    htmlErrMemory(0LL, (uint64_t)"htmlInitParserCtxt: out of memory\n");
    *p_xmlParserInputPtr input = 0LL;
    *(void *)&v1->inputNr = 0LL;
    v1->node = 0LL;
    *(void *)&v1->nodeNr = 0LL;
    goto LABEL_9;
  }

  v1->node = 0LL;
  *(void *)&v1->nodeNr = 0xA00000000LL;
  BOOL v7 = (const xmlChar **)xmlMalloc(0x50uLL);
  v1->nameTab = v7;
  if (!v7)
  {
    htmlErrMemory(0LL, (uint64_t)"htmlInitParserCtxt: out of memory\n");
    *p_xmlParserInputPtr input = 0LL;
    *(void *)&v1->inputNr = 0LL;
    v1->node = 0LL;
    *(void *)&v1->nodeNr = 0LL;
    v1->name = 0LL;
    *(void *)&v1->int nameNr = 0LL;
    goto LABEL_9;
  }

  *(void *)&v1->int nameNr = 0xA00000000LL;
  v1->name = 0LL;
  *(_OWORD *)&v1->nodeInfoNr = 0u;
  v1->sax = v3;
  uint64_t v8 = __htmlDefaultSAXHandler();
  __int128 v9 = *(_OWORD *)&v8->hasInternalSubset;
  *(_OWORD *)&v3->internalSubset = *(_OWORD *)&v8->internalSubset;
  *(_OWORD *)&v3->hasInternalSubset = v9;
  __int128 v10 = *(_OWORD *)&v8->unparsedEntityDecl;
  __int128 v12 = *(_OWORD *)&v8->resolveEntity;
  __int128 v11 = *(_OWORD *)&v8->entityDecl;
  *(_OWORD *)&v3->attributeDecl = *(_OWORD *)&v8->attributeDecl;
  *(_OWORD *)&v3->unparsedEntityDecl = v10;
  *(_OWORD *)&v3->resolveEntity = v12;
  *(_OWORD *)&v3->entityDecl = v11;
  __int128 v13 = *(_OWORD *)&v8->ignorableWhitespace;
  __int128 v15 = *(_OWORD *)&v8->startDocument;
  __int128 v14 = *(_OWORD *)&v8->startElement;
  *(_OWORD *)&v3->reference = *(_OWORD *)&v8->reference;
  *(_OWORD *)&v3->ignorableWhitespace = v13;
  *(_OWORD *)&v3->startDocumentSAXFunc startDocument = v15;
  *(_OWORD *)&v3->startElement = v14;
  __int128 v16 = *(_OWORD *)&v8->externalSubset;
  __int128 v18 = *(_OWORD *)&v8->comment;
  __int128 v17 = *(_OWORD *)&v8->error;
  *(_OWORD *)&v3->getParameterEntity = *(_OWORD *)&v8->getParameterEntity;
  *(_OWORD *)&v3->externalSubset = v16;
  *(_OWORD *)&v3->comment = v18;
  *(_OWORD *)&v3->error = v17;
  v1->userData = v1;
  v1->myDoc = 0LL;
  *(void *)&v1->wellFormed = 1LL;
  v1->linenumbers = *__xmlLineNumbersDefaultValue();
  v1->keepBlanks = *__xmlKeepBlanksDefaultValue();
  v1->html = 1;
  v1->vctxt.finishDtd = -1412623820;
  v1->vctxt.userData = v1;
  v1->vctxt.error = xmlParserValidityError;
  v1->vctxt.warning = xmlParserValidityWarning;
  v1->record_xmlParserNodeInfo info = 0;
  v1->validate = 0;
  v1->checkIndex = 0LL;
  v1->catalogs = 0LL;
  xmlInitNodeInfoSeq(&v1->node_seq);
  return v1;
}

htmlParserCtxtPtr htmlCreateMemoryParserCtxt(const char *buffer, int size)
{
  uint64_t v2 = 0LL;
  if (buffer)
  {
    if (size >= 1)
    {
      uint64_t v2 = htmlNewParserCtxt();
      if (v2)
      {
        xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
        if (Mem)
        {
          xmlParserInputBufferPtr v6 = Mem;
          xmlParserInputPtr v7 = xmlNewInputStream(v2);
          if (v7)
          {
            uint64_t v8 = v7;
            v7->buf = v6;
            v7->filename = 0LL;
            xmlBufResetInput((uint64_t *)v6->buffer, v7);
            inputPush(v2, v8);
            return v2;
          }

          xmlFreeParserInputBuffer(v6);
          xmlFreeParserCtxt(v2);
        }

        return 0LL;
      }
    }
  }

  return v2;
}

int htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  htmlParserCtxtPtr v4 = ctxt;
  if (!ctxt || (xmlParserInputPtr input = ctxt->input) == 0LL)
  {
    __int128 v14 = "htmlParseChunk: context error\n";
    int v13 = 1;
    int v15 = 1;
LABEL_10:
    htmlParseErr(ctxt, v15, v14, 0LL, 0LL);
    return v13;
  }

  if (chunk && size >= 1 && input->buf && ctxt->instate != XML_PARSER_EOF)
  {
    unint64_t InputBase = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
    xmlParserInputPtr v10 = v4->input;
    uint64_t v11 = v10->cur - v10->base;
    int v12 = xmlParserInputBufferPush(v10->buf, size, chunk);
    xmlBufSetInputBaseCur((uint64_t *)v4->input->buf->buffer, &v4->input->buf, InputBase, v11);
    if (v12 < 0)
    {
      int v13 = -1;
      v4->int errNo = -1;
      v4->disableSAX = 1;
      return v13;
    }

    goto LABEL_17;
  }

  if (ctxt->instate != XML_PARSER_EOF)
  {
    uint64_t buf = (uint64_t)input->buf;
    if (input->buf)
    {
      if (*(void *)(buf + 24))
      {
        uint64_t v17 = *(void *)(buf + 32);
        if (v17)
        {
          if (*(void *)(buf + 40))
          {
            unint64_t v18 = xmlBufGetInputBase(v17, (uint64_t)input);
            uint64_t v19 = v4->input->cur - v4->input->base;
            int v20 = xmlCharEncInput(buf, terminate);
            xmlBufSetInputBaseCur(*(uint64_t **)(buf + 32), &v4->input->buf, v18, v19);
            if (v20 < 0)
            {
              __int128 v14 = "encoder error\n";
              int v13 = 81;
              ctxt = v4;
              int v15 = 81;
              goto LABEL_10;
            }
          }
        }
      }
    }
  }

LABEL_17:
  uint64_t v99 = 0LL;
  __int128 v97 = 0u;
  __int128 v98 = 0u;
  xmlParserInputPtr v21 = v4->input;
  if (!v21) {
    goto LABEL_269;
  }
  BOOL v22 = terminate != 0;
  while (1)
  {
LABEL_19:
    if (v21->buf) {
      size_t length = xmlBufUse(v21->buf->buffer);
    }
    else {
      size_t length = v21->length;
    }
    base = v21->base;
    cur = v21->cur;
    uint64_t v26 = (uint64_t)&base[length - (void)cur];
    if (terminate && !v26)
    {
      htmlAutoCloseOnEnd((uint64_t)v4);
      if (!v4->nameNr && v4->instate != XML_PARSER_EOF)
      {
        v4->xmlParserInputState instate = XML_PARSER_EOF;
        if (v4->sax)
        {
          endDocumentSAXFunc endDocument = (void (*)(void *))v4->sax->endDocument;
          if (endDocument) {
            endDocument(v4->userData);
          }
        }
      }

        __int128 v16 = *(void *)v16;
        if (!v16)
        {
          LODWORD(v10) = v15;
LABEL_124:
          if (v9 > 0) {
            return 0xFFFFFFFFLL;
          }
          else {
            return v10;
          }
        }
      }

      *(_DWORD *)(v4 + 16) = 0;
      *(_DWORD *)(v4 + 24) = 0;
      *(_DWORD *)(v4 + 44) = -1;
      if ((*(_BYTE *)(v17 + 25) & 0x80) != 0)
      {
        int v53 = *(_DWORD *)(v17 + 8);
        if (v53)
        {
          if (v53 != 1)
          {
            int v54 = *(void *)(v17 + 16);
LABEL_119:
            if ((*(_BYTE *)v54 & 4) != 0) {
              v9 += xmlStreamCtxtAddState(v4, 0, 0) >> 31;
            }
            goto LABEL_121;
          }

          int v54 = *(void *)(v17 + 16);
          if (*(_DWORD *)(v54 + 24) != 100 || (*(_BYTE *)v54 & 1) == 0) {
            goto LABEL_119;
          }
        }

        xmlParserInputPtr v10 = 1LL;
      }

    unsigned int v5 = (xmlDtdPtr)v5->next;
    if (v5) {
      continue;
    }
    break;
  }

  if (a2 && v6) {
    *(void *)(a2 + 80) = v6;
  }
  return v8;
}

    xmlFree(a1);
  }

    xmlFree(a1);
  }

      __int128 v16 = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
      if (v16) {
        xmlSchemaPValAttrNodeID(a1, v16);
      }
      uint64_t v17 = *(void *)(a3 + 24);
      int v20 = (xmlNode *)v17;
      if (v17
        && *(void *)(v17 + 72)
        && xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"annotation")
        && xmlStrEqual( *(const xmlChar **)(*(void *)(v17 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        *(void *)(v12 + 48) = xmlSchemaParseAnnotation((_DWORD *)a1, v17, 1);
        int v20 = *(xmlNode **)(v17 + 48);
      }

      if (xmlSchemaParseLocalAttributes(a1, a2, (uint64_t *)&v20, (void *****)(v12 + 112), 16, &v19) != -1)
      {
        if (v19) {
          *(_DWORD *)(v12 + 72) |= 0x10u;
        }
        unint64_t v18 = v20;
        if (v20)
        {
          if (!v20->ns
            || !xmlStrEqual(v20->name, (const xmlChar *)"anyAttribute")
            || !xmlStrEqual(v18->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
            || (*(void *)(v12 + 80) = xmlSchemaParseAnyAttribute((_DWORD *)a1, a2, v18), (unint64_t v18 = v18->next) != 0LL))
          {
            xmlSchemaPContentErr( a1,  3033,  a3,  (uint64_t)v18,  0LL,  (xmlChar *)"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))");
          }
        }
      }
    }
  }

  __int128 v16 = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
  if (v16) {
    xmlSchemaPValAttrNodeID(a1, v16);
  }
  uint64_t v17 = *(void *)(a3 + 24);
  if (!v17) {
    return;
  }
  if (*(void *)(v17 + 72))
  {
    if (xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"annotation"))
    {
      if (xmlStrEqual( *(const xmlChar **)(*(void *)(v17 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        v12[1] = xmlSchemaParseAnnotation((_DWORD *)a1, v17, 1);
        uint64_t v17 = *(void *)(v17 + 48);
        if (!v17) {
          return;
        }
      }
    }
  }

  if (!*(void *)(v17 + 72)) {
    goto LABEL_39;
  }
  if (xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"all")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(v17 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    unint64_t v18 = 8;
    goto LABEL_38;
  }

  if (!*(void *)(v17 + 72))
  {
LABEL_39:
    xmlSchemaPContentErr(a1, 3033, a3, v17, 0LL, (xmlChar *)"(annotation?, (all | choice | sequence)?)");
    return;
  }

  if (xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"choice")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(v17 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    unint64_t v18 = 7;
  }

  else
  {
    if (!*(void *)(v17 + 72)
      || !xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"sequence")
      || !xmlStrEqual( *(const xmlChar **)(*(void *)(v17 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      goto LABEL_39;
    }

    unint64_t v18 = 6;
  }

LABEL_269:
      uint64_t v26 = 0LL;
LABEL_270:
      BOOL v22 = terminate != 0;
      if (terminate && !v26)
      {
        htmlAutoCloseOnEnd((uint64_t)v4);
        if (!v4->nameNr && v4->instate != XML_PARSER_EOF)
        {
          v4->xmlParserInputState instate = XML_PARSER_EOF;
          if (v4->sax)
          {
            xmlXPathObjectPtr v93 = (void (*)(void *))v4->sax->endDocument;
            if (v93) {
              v93(v4->userData);
            }
          }
        }

        BOOL v22 = 1;
      }

      goto LABEL_274;
    }

    if (v26 < 1) {
      goto LABEL_270;
    }
    unsigned int v27 = *cur;
    if (*cur) {
      break;
    }
    xmlParserInputPtr v30 = v4->input;
    ++v30->cur;
    ++v30->col;
LABEL_78:
    xmlParserInputPtr v21 = v4->input;
    if (!v21) {
      goto LABEL_270;
    }
  }

  switch(v4->instate)
  {
    case XML_PARSER_EOF:
      goto LABEL_274;
    case XML_PARSER_START:
      if (v27 <= 0x20 && ((1LL << v27) & 0x100002600LL) != 0)
      {
        htmlSkipBlankChars((uint64_t)v4);
        if (v21->buf) {
          size_t v29 = xmlBufUse(v21->buf->buffer);
        }
        else {
          size_t v29 = v21->length;
        }
        uint64_t v26 = (uint64_t)&v21->base[v29 - (unint64_t)v21->cur];
      }

      sax = v4->sax;
      if (v4->sax)
      {
        setDocumentLocatorSAXFunc setDocumentLocator = (void (*)(void *, xmlSAXLocator *))sax->setDocumentLocator;
        if (!setDocumentLocator
          || (userData = v4->userData,
              uint64_t v57 = __xmlDefaultSAXLocator(),
              setDocumentLocator(userData, v57),
              (sax = v4->sax) != 0LL))
        {
          startDocumentSAXFunc startDocument = (void (*)(void *))sax->startDocument;
          if (startDocument)
          {
            if (!v4->disableSAX) {
              startDocument(v4->userData);
            }
          }
        }
      }

      uint64_t v59 = v21->cur;
      if (*v59 == 60 && v59[1] == 33)
      {
        v60 = (unsigned __int8 *)v4->input->cur;
        if (__toupper(v60[2]) == 68
          && __toupper(v60[3]) == 79
          && __toupper(v60[4]) == 67
          && __toupper(v60[5]) == 84
          && __toupper(v60[6]) == 89
          && __toupper(v60[7]) == 80
          && __toupper(v60[8]) == 69)
        {
          goto LABEL_171;
        }
      }

      v4->xmlParserInputState instate = XML_PARSER_MISC;
      goto LABEL_78;
    case XML_PARSER_MISC:
      htmlSkipBlankChars((uint64_t)v4);
      if (v21->buf) {
        size_t v31 = xmlBufUse(v21->buf->buffer);
      }
      else {
        size_t v31 = v21->length;
      }
      int v46 = (unsigned __int8 *)v21->cur;
      uint64_t v26 = (uint64_t)&v21->base[v31 - (void)v46];
      if (v26 < 1) {
        goto LABEL_270;
      }
      if (v26 == 1)
      {
        if (!terminate) {
          goto LABEL_302;
        }
        goto LABEL_252;
      }

      int v47 = v46[1];
      int v48 = *v46;
      if (v48 != 60 || v47 != 33)
      {
        if (v48 == 60 && v47 == 63)
        {
          htmlParsePI((uint64_t)v4);
          goto LABEL_163;
        }

  htmlParserCtxtPtr v4 = 0;
LABEL_322:
  xmlParserInputBufferPtr v6 = *(_DWORD *)(*(void *)(v2 + 56) + 92LL);
LABEL_271:
  if (v6 == 2) {
    goto LABEL_10;
  }
LABEL_272:
  v135 = (xmlSchemaVal *)*((void *)data + 17);
  if (v135)
  {
    xmlSchemaFreeValue(v135);
    *((void *)data + 17) = 0LL;
  }

  xmlGenericErrorFunc v136 = *(void *)(v2 + 80);
  if (!v136)
  {
    __int128 v140 = *(void *)(v2 + 56);
    if (*(_DWORD *)v140 != 4 && (*(_DWORD *)v140 != 1 || *(_DWORD *)(v140 + 160) == 45))
    {
      if ((*(_DWORD *)(v140 + 92) | 2) != 6) {
        goto LABEL_10;
      }
      __int128 v140 = *(void *)(v140 + 192);
    }

    htmlParserCtxtPtr v4 = xmlSchemaVCheckINodeDataType((uint64_t)data, v2, v140, *(xmlChar **)(v2 + 40));
    goto LABEL_301;
  }

  v137 = *(xmlChar **)(v136 + 144);
  v138 = *(_DWORD *)(v2 + 64);
  if (!v137 || (*(_DWORD *)(v2 + 64) & 0x24) != 0x20)
  {
    if ((v138 & 4) != 0) {
      goto LABEL_10;
    }
    __int128 v141 = *(void *)(v2 + 56);
    if (*(_DWORD *)v141 != 4 && (*(_DWORD *)v141 != 1 || *(_DWORD *)(v141 + 160) == 45))
    {
      if ((*(_DWORD *)(v141 + 92) | 2) != 6) {
        goto LABEL_300;
      }
      __int128 v141 = *(void *)(v141 + 192);
    }

    htmlParserCtxtPtr v4 = xmlSchemaVCheckINodeDataType((uint64_t)data, v2, v141, *(xmlChar **)(v2 + 40));
LABEL_300:
    if (!v4)
    {
      __int128 v147 = *(void *)(v2 + 80);
      __int128 v148 = *(const xmlChar **)(v147 + 144);
      if (!v148 || (*(_BYTE *)(v147 + 88) & 8) == 0) {
        goto LABEL_327;
      }
      if ((*(_BYTE *)(v2 + 64) & 0x80) != 0)
      {
        htmlParserCtxtPtr v4 = 1856;
        xmlSchemaCustomErr4( data,  1856,  0LL,  0LL,  (const xmlChar *)"The content must not contain element nodes since there is a fixed value constraint",  0LL,  0LL,  0LL,  0LL);
        goto LABEL_10;
      }

      __int128 v149 = *(_DWORD *)(*(void *)(v2 + 56) + 92LL);
      if (v149 == 6 || v149 == 4)
      {
        if (xmlStrEqual(*(const xmlChar **)(v2 + 40), v148)) {
          goto LABEL_327;
        }
        __int128 v150 = *(const xmlChar **)(v2 + 40);
        __int128 v151 = *(xmlChar **)(*(void *)(v2 + 80) + 144LL);
        __int128 v152 = "The actual value '%s' does not match the fixed value constraint '%s'";
        htmlParserCtxtPtr v4 = 1858;
        __int128 v153 = data;
        __int128 v154 = 1858;
      }

      else
      {
        if (v149 != 3 || xmlStrEqual(*(const xmlChar **)(v2 + 40), v148)) {
          goto LABEL_327;
        }
        __int128 v150 = *(const xmlChar **)(v2 + 40);
        __int128 v151 = *(xmlChar **)(*(void *)(v2 + 80) + 144LL);
        __int128 v152 = "The initial value '%s' does not match the fixed value constraint '%s'";
        htmlParserCtxtPtr v4 = 1857;
        __int128 v153 = data;
        __int128 v154 = 1857;
      }

      xmlSchemaCustomErr4(v153, v154, 0LL, 0LL, (const xmlChar *)v152, v150, v151, 0LL, 0LL);
      goto LABEL_10;
    }

LABEL_252:
        v4->xmlParserInputState instate = XML_PARSER_CONTENT;
        goto LABEL_78;
      }

      if (v46[2] == 45 && v46[3] == 45)
      {
        htmlParseComment((uint64_t)v4);
LABEL_163:
        v4->xmlParserInputState instate = XML_PARSER_MISC;
        goto LABEL_78;
      }

      uint64_t v61 = (unsigned __int8 *)v4->input->cur;
      if (__toupper(v61[2]) != 68
        || __toupper(v61[3]) != 79
        || __toupper(v61[4]) != 67
        || __toupper(v61[5]) != 84
        || __toupper(v61[6]) != 89
        || __toupper(v61[7]) != 80
        || __toupper(v61[8]) != 69)
      {
        goto LABEL_252;
      }

LABEL_171:
      htmlParseDocTypeDecl(v4);
      v4->xmlParserInputState instate = XML_PARSER_PROLOG;
      goto LABEL_78;
    case XML_PARSER_PI:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == PI\n";
      goto LABEL_76;
    case XML_PARSER_DTD:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == DTD\n";
      goto LABEL_76;
    case XML_PARSER_PROLOG:
      htmlSkipBlankChars((uint64_t)v4);
      if (v21->buf) {
        size_t v34 = xmlBufUse(v21->buf->buffer);
      }
      else {
        size_t v34 = v21->length;
      }
      int v49 = (unsigned __int8 *)v21->cur;
      uint64_t v26 = (uint64_t)&v21->base[v34 - (void)v49];
      if (v26 < 2) {
        goto LABEL_270;
      }
      int v50 = *v49;
      int v51 = v49[1];
      if (v50 == 60 && v51 == 33)
      {
        if (v49[2] != 45 || v49[3] != 45)
        {
          goto LABEL_252;
        }

        htmlParseComment((uint64_t)v4);
      }

      else
      {
        if (v50 != 60 || v51 != 63) {
          goto LABEL_252;
        }
        htmlParsePI((uint64_t)v4);
      }

      v4->xmlParserInputState instate = XML_PARSER_PROLOG;
      goto LABEL_78;
    case XML_PARSER_COMMENT:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == COMMENT\n";
      goto LABEL_76;
    case XML_PARSER_START_TAG:
      if ((unint64_t)v26 > 1)
      {
        if (v27 != 60) {
          goto LABEL_252;
        }
        if (cur[1] == 47)
        {
          int v39 = 9;
LABEL_70:
          v4->xmlParserInputState instate = v39;
LABEL_77:
          v4->checkIndex = 0LL;
          goto LABEL_78;
        }
      }

      else
      {
        if (!terminate) {
          goto LABEL_302;
        }
        if (v27 != 60) {
          goto LABEL_252;
        }
      }

      if (v4->record_info)
      {
        xmlParserInputPtr v62 = v4->input;
        int64_t v63 = &v62->cur[v62->consumed] - v62->base;
        uint64_t line = v62->line;
        *((void *)&v97 + 1) = v63;
        *(void *)&__int128 v98 = line;
      }

      int started = htmlParseStartTag((uint64_t)v4);
      if (v4->instate == XML_PARSER_EOF) {
        goto LABEL_305;
      }
      if (started == -1 || (name = v4->name) == 0LL)
      {
        xmlParserInputPtr v21 = v4->input;
        if (*v21->cur == 62)
        {
          xmlNextChar(v4);
          goto LABEL_78;
        }

        if (!v21) {
          goto LABEL_270;
        }
        goto LABEL_19;
      }

      xmlAttrPtr v67 = bsearch( v4->name,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      if (!v67) {
        htmlParseErr(v4, 801, "Tag %s invalid\n", name, 0LL);
      }
      xmlParserInputPtr v68 = v4->input;
      __int128 v69 = v68->cur;
      int v70 = *v69;
      if (v70 != 62)
      {
        if (v70 == 47 && v69[1] == 62)
        {
          v68->cur = v69 + 2;
          v68->col += 2;
          if (v4->sax)
          {
            endElementSAXFunc endElement = (void (*)(void *, const xmlChar *))v4->sax->endElement;
            if (endElement) {
              endElement(v4->userData, name);
            }
          }

          int nameNr = v4->nameNr;
          unsigned int v73 = nameNr - 1;
          if (nameNr >= 1)
          {
            v4->int nameNr = v73;
            nameTab = v4->nameTab;
            if (nameNr == 1) {
              xmlGenericErrorFunc v85 = 0LL;
            }
            else {
              xmlGenericErrorFunc v85 = nameTab[nameNr - 2];
            }
            v4->name = v85;
            nameTab[v73] = 0LL;
          }
        }

        else
        {
          htmlParseErr(v4, 73, "Couldn't find end of Start Tag %s\n", name, 0LL);
          if (xmlStrEqual(name, v4->name))
          {
            nodePop(v4);
            int v75 = v4->nameNr;
            unsigned int v76 = v75 - 1;
            if (v75 >= 1)
            {
              v4->int nameNr = v76;
              xmlXPathObjectPtr v77 = v4->nameTab;
              if (v75 == 1) {
                __int128 v84 = 0LL;
              }
              else {
                __int128 v84 = v77[v75 - 2];
              }
              v4->name = v84;
              v77[v76] = 0LL;
            }
          }

          if (v4->record_info) {
            htmlNodeInfoPush((uint64_t)v4, &v97);
          }
        }

        goto LABEL_252;
      }

      xmlNextChar(v4);
      if (v67 && v67[11])
      {
        if (v4->sax)
        {
          __int128 v79 = (void (*)(void *, const xmlChar *))v4->sax->endElement;
          if (v79) {
            v79(v4->userData, name);
          }
        }

        int v80 = v4->nameNr;
        unsigned int v81 = v80 - 1;
        if (v80 >= 1)
        {
          v4->int nameNr = v81;
          __int128 v82 = v4->nameTab;
          if (v80 == 1) {
            __int128 v86 = 0LL;
          }
          else {
            __int128 v86 = v82[v80 - 2];
          }
          v4->name = v86;
          v82[v81] = 0LL;
        }
      }

      if (v4->record_info) {
        htmlNodeInfoPush((uint64_t)v4, &v97);
      }
      v4->xmlParserInputState instate = XML_PARSER_CONTENT;
      goto LABEL_78;
    case XML_PARSER_CONTENT:
      __int16 v96 = 0;
      if (v4->token)
      {
        LOBYTE(v96) = v4->token;
        htmlCheckParagraph((uint64_t)v4);
        if (v4->sax)
        {
          characters = (void (*)(void *, __int16 *, uint64_t))v4->sax->characters;
        }

        v4->token = 0;
        v4->checkIndex = 0LL;
      }

      if (terminate && v26 == 1)
      {
        unsigned int v36 = *v21->cur;
        if (v36 == 38 || v36 == 60) {
          goto LABEL_274;
        }
        int v37 = v4->sax;
        if (!v4->sax) {
          goto LABEL_228;
        }
        LOBYTE(v96) = *v21->cur;
        if (v36 <= 0x20 && ((1LL << v36) & 0x100002600LL) != 0)
        {
          if (!v4->keepBlanks)
          {
            ignorableWhitespace = (void (*)(void *, __int16 *, uint64_t))v37->ignorableWhitespace;
            if (!ignorableWhitespace) {
              goto LABEL_228;
            }
LABEL_227:
            ignorableWhitespace(v4->userData, &v96, 1LL);
LABEL_228:
            v4->token = 0;
            v4->checkIndex = 0LL;
            ++v21->cur;
            goto LABEL_78;
          }
        }

        else
        {
          htmlCheckParagraph((uint64_t)v4);
          int v37 = v4->sax;
        }

        ignorableWhitespace = (void (*)(void *, __int16 *, uint64_t))v37->characters;
        if (ignorableWhitespace) {
          goto LABEL_227;
        }
        goto LABEL_228;
      }

      uint64_t v41 = v21->cur;
      int v42 = *v41;
      int v43 = v41[1];
      if (xmlStrEqual(v4->name, (const xmlChar *)"script") || xmlStrEqual(v4->name, (const xmlChar *)"style"))
      {
        if (!terminate)
        {
          int v44 = htmlParseLookupSequence((uint64_t)v4, 60, 47, 0);
          if (v44 < 0) {
            goto LABEL_274;
          }
          if (!v21->cur[v44 + 2])
          {
LABEL_302:
            BOOL v22 = 0;
            goto LABEL_274;
          }
        }

        htmlParseScript((uint64_t)v4);
        if (v42 == 60 && v43 == 47)
        {
LABEL_91:
          int v45 = 9;
          goto LABEL_92;
        }
      }

      else if (v42 == 60 && v43 == 33)
      {
        __int128 v78 = (unsigned __int8 *)v4->input->cur;
        if (__toupper(v78[2]) != 68
          || __toupper(v78[3]) != 79
          || __toupper(v78[4]) != 67
          || __toupper(v78[5]) != 84
          || __toupper(v78[6]) != 89
          || __toupper(v78[7]) != 80
          || __toupper(v78[8]) != 69)
        {
          xmlGenericErrorFunc v83 = v21->cur;
          if (v83[2] != 45 || v83[3] != 45)
          {
            goto LABEL_242;
          }

          htmlParseComment((uint64_t)v4);
          goto LABEL_240;
        }

        htmlParseErr(v4, 800, "Misplaced DOCTYPE declaration\n", (const xmlChar *)"DOCTYPE", 0LL);
        htmlParseDocTypeDecl(v4);
      }

      else
      {
        if (v42 == 60 && v43 == 63)
        {
          htmlParsePI((uint64_t)v4);
LABEL_240:
          v4->xmlParserInputState instate = XML_PARSER_CONTENT;
          goto LABEL_78;
        }

        if (v42 == 60 && v43 == 47) {
          goto LABEL_91;
        }
        if (v42 == 60)
        {
          if (!(terminate | v43)) {
            goto LABEL_274;
          }
LABEL_242:
          int v45 = 6;
LABEL_92:
          v4->xmlParserInputState instate = v45;
          v4->checkIndex = 0LL;
          goto LABEL_78;
        }

        v4->checkIndex = 0LL;
        if (v4->instate != XML_PARSER_EOF)
        {
          __int128 v87 = v21->cur;
          do
          {
            if (v87 >= v21->end) {
              break;
            }
            if (v42 == 38) {
              htmlParseReference((uint64_t)v4);
            }
            else {
              htmlParseCharData((uint64_t)v4);
            }
            if (v4->instate == XML_PARSER_EOF) {
              break;
            }
            __int128 v87 = v21->cur;
            int v42 = *v87;
          }

          while (v42 != 60);
        }
      }

      goto LABEL_78;
    case XML_PARSER_CDATA_SECTION:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == CDATA\n";
      goto LABEL_76;
    case XML_PARSER_END_TAG:
      htmlParseEndTag(v4);
      if (v4->nameNr) {
        int v39 = 7;
      }
      else {
        int v39 = 14;
      }
      goto LABEL_70;
    case XML_PARSER_ENTITY_DECL:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == ENTITY_DECL\n";
      goto LABEL_76;
    case XML_PARSER_ENTITY_VALUE:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == ENTITY_VALUE\n";
      goto LABEL_76;
    case XML_PARSER_ATTRIBUTE_VALUE:
      htmlParseErr(v4, 1, "HPP: internal error, state == ATTRIBUTE_VALUE\n", 0LL, 0LL);
      int v39 = 6;
      goto LABEL_70;
    case XML_PARSER_SYSTEM_LITERAL:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\n";
      goto LABEL_76;
    case XML_PARSER_EPILOG:
      if (v21->buf)
      {
        size_t v40 = xmlBufUse(v21->buf->buffer);
        base = v21->base;
        cur = v21->cur;
      }

      else
      {
        size_t v40 = v21->length;
      }

      uint64_t v26 = (uint64_t)&base[v40 - (void)cur];
      if (v26 < 1) {
        goto LABEL_270;
      }
      unsigned int v52 = *cur;
      if (v52 <= 0x20 && ((1LL << v52) & 0x100002600LL) != 0)
      {
        htmlParseCharData((uint64_t)v4);
        goto LABEL_274;
      }

      int v53 = cur[1];
      if (v52 != 60 || v53 != 33)
      {
        if (v52 != 60 || v53 != 63) {
          goto LABEL_304;
        }
        htmlParsePI((uint64_t)v4);
        goto LABEL_137;
      }

      if (cur[2] == 45 && cur[3] == 45)
      {
        htmlParseComment((uint64_t)v4);
LABEL_137:
        v4->xmlParserInputState instate = XML_PARSER_EPILOG;
        goto LABEL_78;
      }

      if ((unint64_t)v26 >= 4)
      {
LABEL_304:
        v4->int errNo = 5;
        v4->wellFormed = 0;
        v4->xmlParserInputState instate = XML_PARSER_EOF;
LABEL_305:
        if (v4->sax)
        {
          int v95 = (void (*)(void *))v4->sax->endDocument;
          if (v95) {
            v95(v4->userData);
          }
        }
      }

LABEL_274:
      if ((v4->options & 4) == 0)
      {
        myDoc = v4->myDoc;
        if (myDoc)
        {
          if (v22 || (xmlParserInputState instate = v4->instate, instate == XML_PARSER_EPILOG) || instate == XML_PARSER_EOF)
          {
            if (!xmlGetIntSubset(myDoc)) {
              v4->myDoc->intSubset = xmlCreateIntSubset( v4->myDoc,  (const xmlChar *)"html",  (const xmlChar *)"-//W3C//DTD HTML 4.0 Transitional//EN",  (const xmlChar *)"http://www.w3.org/TR/REC-html40/loose.dtd");
            }
          }
        }
      }

      if (terminate)
      {
        xmlParserInputState v90 = v4->instate;
        if (v90 != XML_PARSER_EOF)
        {
          if (v90 != XML_PARSER_MISC && v90 != XML_PARSER_EPILOG)
          {
            v4->int errNo = 5;
            v4->wellFormed = 0;
          }

          if (v4->sax)
          {
            xmlXPathObjectPtr v91 = (void (*)(void *))v4->sax->endDocument;
            if (v91) {
              v91(v4->userData);
            }
          }
        }

        v4->xmlParserInputState instate = XML_PARSER_EOF;
      }

      return v4->errNo;
    case XML_PARSER_IGNORE:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == XML_PARSER_IGNORE\n";
      goto LABEL_76;
    case XML_PARSER_PUBLIC_LITERAL:
      uint64_t v32 = v4;
      int v33 = "HPP: internal error, state == XML_PARSER_LITERAL\n";
LABEL_76:
      htmlParseErr(v32, 1, v33, 0LL, 0LL);
      v4->xmlParserInputState instate = XML_PARSER_CONTENT;
      goto LABEL_77;
    default:
      goto LABEL_78;
  }

htmlParserCtxtPtr htmlCreatePushParserCtxt( htmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename, xmlCharEncoding enc)
{
  xmlParserInputBufferPtr v12 = xmlAllocParserInputBuffer(enc);
  if (!v12) {
    return 0LL;
  }
  xmlParserInputBufferPtr v13 = v12;
  htmlParserCtxtPtr v14 = htmlNewParserCtxt();
  int v15 = v14;
  if (!v14)
  {
    xmlFreeParserInputBuffer(v13);
    return v15;
  }

  if (enc == XML_CHAR_ENCODING_UTF8 || v13->encoder) {
    v14->charset = 1;
  }
  if (sax)
  {
    __int128 v16 = (xmlSAXHandlerV1 *)v14->sax;
    if (v16 != __htmlDefaultSAXHandler()) {
      xmlFree(v15->sax);
    }
    uint64_t v17 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
    v15->sax = v17;
    if (!v17)
    {
      xmlFree(v13);
      ((void (*)(xmlParserCtxt *))xmlFree)(v15);
      return 0LL;
    }

    __int128 v18 = *(_OWORD *)&sax->internalSubset;
    __int128 v19 = *(_OWORD *)&sax->hasInternalSubset;
    __int128 v20 = *(_OWORD *)&sax->entityDecl;
    *(_OWORD *)&v17->resolveEntity = *(_OWORD *)&sax->resolveEntity;
    *(_OWORD *)&v17->entityDecl = v20;
    *(_OWORD *)&v17->internalSubset = v18;
    *(_OWORD *)&v17->hasInternalSubset = v19;
    __int128 v21 = *(_OWORD *)&sax->attributeDecl;
    __int128 v22 = *(_OWORD *)&sax->unparsedEntityDecl;
    __int128 v23 = *(_OWORD *)&sax->startElement;
    *(_OWORD *)&v17->startDocumentSAXFunc startDocument = *(_OWORD *)&sax->startDocument;
    *(_OWORD *)&v17->startElement = v23;
    *(_OWORD *)&v17->attributeDecl = v21;
    *(_OWORD *)&v17->unparsedEntityDecl = v22;
    __int128 v24 = *(_OWORD *)&sax->reference;
    __int128 v25 = *(_OWORD *)&sax->ignorableWhitespace;
    __int128 v26 = *(_OWORD *)&sax->error;
    *(_OWORD *)&v17->comment = *(_OWORD *)&sax->comment;
    *(_OWORD *)&v17->error = v26;
    *(_OWORD *)&v17->reference = v24;
    *(_OWORD *)&v17->ignorableWhitespace = v25;
    __int128 v27 = *(_OWORD *)&sax->getParameterEntity;
    __int128 v28 = *(_OWORD *)&sax->externalSubset;
    __int128 v29 = *(_OWORD *)&sax->endElementNs;
    *(_OWORD *)&v17->_private = *(_OWORD *)&sax->_private;
    *(_OWORD *)&v17->endElementNs = v29;
    *(_OWORD *)&v17->getParameterEntity = v27;
    *(_OWORD *)&v17->externalSubset = v28;
    if (user_data) {
      v15->userData = user_data;
    }
  }

  if (filename) {
    Directory = xmlParserGetDirectory(filename);
  }
  else {
    Directory = 0LL;
  }
  v15->directory = Directory;
  size_t v31 = (char *)xmlMalloc(0x68uLL);
  if (!v31)
  {
    htmlErrMemory(v15, (uint64_t)"couldn't allocate a new input stream\n");
    xmlFreeParserCtxt(v15);
    ((void (*)(xmlParserInputBufferPtr))xmlFree)(v13);
    return 0LL;
  }

  uint64_t v32 = (xmlParserInput *)v31;
  *(_OWORD *)size_t v31 = 0u;
  *((_OWORD *)v31 + 1) = 0u;
  *((_OWORD *)v31 + 2) = 0u;
  *((_OWORD *)v31 + 3) = 0u;
  *((_OWORD *)v31 + 4) = 0u;
  *((_OWORD *)v31 + 5) = 0u;
  *(_OWORD *)(v31 + 8) = 0u;
  *(_OWORD *)(v31 + 24) = 0u;
  *((_DWORD *)v31 + 14) = 1;
  *(void *)size_t v31 = 0LL;
  *((void *)v31 + 11) = 0LL;
  *((void *)v31 + 12) = 0LL;
  *((void *)v31 + 6) = 0x100000000LL;
  *((void *)v31 + 8) = 0LL;
  *((void *)v31 + 9) = 0LL;
  if (filename) {
    int v33 = xmlCanonicPath((const xmlChar *)filename);
  }
  else {
    int v33 = 0LL;
  }
  v32->uint64_t buf = v13;
  v32->filename = (const char *)v33;
  xmlBufResetInput((uint64_t *)v13->buffer, v32);
  inputPush(v15, v32);
  if (chunk)
  {
    if (size >= 1)
    {
      uint64_t input = (uint64_t)v15->input;
      if (input)
      {
        if (*(void *)input)
        {
          unint64_t InputBase = xmlBufGetInputBase(*(void *)(*(void *)input + 32LL), input);
          xmlParserInputPtr v36 = v15->input;
          uint64_t v37 = v36->cur - v36->base;
          xmlParserInputBufferPush(v36->buf, size, chunk);
          xmlBufSetInputBaseCur((uint64_t *)v15->input->buf->buffer, &v15->input->buf, InputBase, v37);
        }
      }
    }
  }

  v15->progressive = 1;
  return v15;
}

htmlDocPtr htmlSAXParseDoc(const xmlChar *cur, const char *encoding, htmlSAXHandlerPtr sax, void *userData)
{
  if (!cur) {
    return 0LL;
  }
  DocParserCtxt = htmlCreateDocParserCtxt(cur, (const xmlChar *)encoding);
  if (!DocParserCtxt) {
    return 0LL;
  }
  __int128 v9 = DocParserCtxt;
  if (sax)
  {
    xmlParserInputPtr v10 = DocParserCtxt->sax;
    if (v9->sax) {
      xmlFree(v10);
    }
    v9->sax = sax;
    v9->userData = userData;
    htmlParseDocument(v9);
    myDoc = v9->myDoc;
    v9->sax = 0LL;
    v9->userData = 0LL;
  }

  else
  {
    htmlParseDocument(DocParserCtxt);
    myDoc = v9->myDoc;
  }

  xmlFreeParserCtxt(v9);
  return myDoc;
}

xmlParserCtxt *htmlCreateDocParserCtxt(const xmlChar *a1, const xmlChar *a2)
{
  int v4 = xmlStrlen(a1);
  htmlParserCtxtPtr MemoryParserCtxt = htmlCreateMemoryParserCtxt((const char *)a1, v4);
  xmlParserInputBufferPtr v6 = MemoryParserCtxt;
  if (!a2 || !MemoryParserCtxt) {
    return v6;
  }
  encoding = (xmlChar *)MemoryParserCtxt->input->encoding;
  if (encoding) {
    xmlFree(encoding);
  }
  v6->input->encoding = xmlStrdup(a2);
  xmlCharEncoding v8 = xmlParseCharEncoding((const char *)a2);
  if (v8 != XML_CHAR_ENCODING_ERROR)
  {
    int v9 = xmlSwitchEncoding(v6, v8);
    int errNo = v6->errNo;
    if (errNo != 32)
    {
      if (v9 < 0) {
        goto LABEL_12;
      }
      return v6;
    }

htmlDocPtr htmlParseDoc(const xmlChar *cur, const char *encoding)
{
  return htmlSAXParseDoc(cur, encoding, 0LL, 0LL);
}

htmlParserCtxtPtr htmlCreateFileParserCtxt(const char *filename, const char *encoding)
{
  if (!filename) {
    return 0LL;
  }
  int v4 = htmlNewParserCtxt();
  if (!v4) {
    return v4;
  }
  unsigned int v5 = xmlCanonicPath((const xmlChar *)filename);
  if (!v5)
  {
    if (__xmlDefaultSAXHandler()->error)
    {
      int v12 = __xmlDefaultSAXHandler();
      v12->error(0LL, "out of memory\n");
    }

    goto LABEL_11;
  }

  xmlParserInputBufferPtr v6 = v5;
  ExternalEntity = xmlLoadExternalEntity((const char *)v5, 0LL, v4);
  xmlFree(v6);
  if (!ExternalEntity)
  {
LABEL_11:
    xmlFreeParserCtxt(v4);
    return 0LL;
  }

  inputPush(v4, ExternalEntity);
  if (encoding)
  {
    size_t v8 = strlen(encoding);
    if (v8 <= 0x3E7)
    {
      size_t v9 = v8 + xmlStrlen((const xmlChar *)"charset=") + 1;
      xmlParserInputPtr v10 = (char *)xmlMallocAtomic(v9);
      if (v10)
      {
        uint64_t v11 = (xmlChar *)v10;
        snprintf(v10, v9, "%s%s", "charset=", encoding);
        htmlCheckEncoding((uint64_t)v4, v11);
        xmlFree(v11);
      }
    }
  }

  return v4;
}

const xmlChar *htmlCheckEncoding(uint64_t a1, xmlChar *str)
{
  int result = xmlStrcasestr(str, (const xmlChar *)"charset");
  if (result)
  {
    unsigned int v6 = result[7];
    result += 7;
    unsigned int v5 = v6;
    uint64_t v7 = (1LL << v6) & 0x100002600LL;
    if (v6 <= 0x20 && v7 != 0)
    {
      int result = xmlStrcasestr(str, (const xmlChar *)"=");
      if (!result) {
        return result;
      }
      unsigned int v5 = *result;
    }

    if (v5 == 61) {
      return (const xmlChar *)htmlCheckEncodingDirect(a1, (xmlChar *)result + 1);
    }
  }

  return result;
}

htmlDocPtr htmlSAXParseFile(const char *filename, const char *encoding, htmlSAXHandlerPtr sax, void *userData)
{
  htmlParserCtxtPtr FileParserCtxt = htmlCreateFileParserCtxt(filename, encoding);
  if (!FileParserCtxt) {
    return 0LL;
  }
  size_t v9 = FileParserCtxt;
  if (sax)
  {
    xmlParserInputPtr v10 = FileParserCtxt->sax;
    FileParserCtxt->sax = sax;
    FileParserCtxt->userData = userData;
    htmlParseDocument(FileParserCtxt);
    myDoc = v9->myDoc;
    v9->sax = v10;
    v9->userData = 0LL;
  }

  else
  {
    htmlParseDocument(FileParserCtxt);
    myDoc = v9->myDoc;
  }

  xmlFreeParserCtxt(v9);
  return myDoc;
}

htmlDocPtr htmlParseFile(const char *filename, const char *encoding)
{
  return htmlSAXParseFile(filename, encoding, 0LL, 0LL);
}

int htmlHandleOmittedElem(int val)
{
  int v1 = htmlOmittedDefaultValue;
  htmlOmittedDefaultValue = val;
  return v1;
}

int htmlElementAllowedHere(const htmlElemDesc *a1, const xmlChar *a2)
{
  uint64_t v2 = a1;
  LODWORD(a1) = 0;
  if (v2 && a2)
  {
    subelts = (const htmlElemDesc **)v2->subelts;
    if (subelts)
    {
      a1 = *subelts;
      if (*subelts)
      {
        unsigned int v5 = subelts + 1;
        while (xmlStrcmp((const xmlChar *)a1, a2))
        {
          unsigned int v6 = *v5++;
          a1 = v6;
          if (!v6) {
            return (int)a1;
          }
        }

        LODWORD(a1) = 1;
      }
    }

    else
    {
      LODWORD(a1) = 0;
    }
  }

  return (int)a1;
}

htmlStatus htmlElementStatusHere(const htmlElemDesc *a1, const htmlElemDesc *a2)
{
  htmlStatus result = HTML_INVALID;
  if (a1 && a2)
  {
    if (htmlElementAllowedHere(a1, (const xmlChar *)a2->name))
    {
      if (a2->dtd) {
        return 2;
      }
      else {
        return 4;
      }
    }

    else
    {
      return 1;
    }
  }

  return result;
}

htmlStatus htmlAttrAllowed(const htmlElemDesc *a1, const xmlChar *a2, int a3)
{
  htmlStatus result = HTML_INVALID;
  if (a1 && a2)
  {
    attrs_req = a1->attrs_req;
    if (attrs_req && (size_t v8 = (const xmlChar *)*attrs_req) != 0LL)
    {
      size_t v9 = (const xmlChar **)(attrs_req + 1);
      while (xmlStrcmp(v8, a2))
      {
        xmlParserInputPtr v10 = *v9++;
        size_t v8 = v10;
        if (!v10) {
          goto LABEL_8;
        }
      }

      return 12;
    }

    else
    {
LABEL_8:
      attrs_opt = a1->attrs_opt;
      if (attrs_opt && (int v12 = (const xmlChar *)*attrs_opt) != 0LL)
      {
        xmlParserInputBufferPtr v13 = (const xmlChar **)(attrs_opt + 1);
        while (xmlStrcmp(v12, a2))
        {
          htmlParserCtxtPtr v14 = *v13++;
          int v12 = v14;
          if (!v14) {
            goto LABEL_13;
          }
        }

        return 4;
      }

      else
      {
LABEL_13:
        if (a3 && (attrs_depr = a1->attrs_depr) != 0LL && (__int128 v16 = (const xmlChar *)*attrs_depr) != 0LL)
        {
          uint64_t v17 = (const xmlChar **)(attrs_depr + 1);
          while (xmlStrcmp(v16, a2))
          {
            __int128 v18 = *v17++;
            __int128 v16 = v18;
            if (!v18) {
              return 1;
            }
          }

          return 2;
        }

        else
        {
          return 1;
        }
      }
    }
  }

  return result;
}

htmlStatus htmlNodeStatus(const htmlNodePtr a1, int a2)
{
  if (!a1) {
    return 1;
  }
  xmlElementType type = a1->type;
  if (type == XML_ATTRIBUTE_NODE)
  {
    name = (const htmlElemDesc *)a1->parent->name;
    if (name) {
      name = (const htmlElemDesc *)bsearch( name,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
    }
    return htmlAttrAllowed(name, a1->name, a2);
  }

  else if (type == XML_ELEMENT_NODE)
  {
    unsigned int v5 = (const htmlElemDesc *)a1->parent->name;
    if (a2)
    {
      if (v5) {
        unsigned int v5 = (const htmlElemDesc *)bsearch( v5,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      }
      if (htmlElementAllowedHere(v5, a1->name)) {
        return 4;
      }
      else {
        return 1;
      }
    }

    else
    {
      if (v5) {
        size_t v8 = (const htmlElemDesc *)bsearch( v5,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      }
      else {
        size_t v8 = 0LL;
      }
      size_t v9 = a1->name;
      if (v9) {
        xmlParserInputPtr v10 = (const htmlElemDesc *)bsearch( v9,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
      }
      else {
        xmlParserInputPtr v10 = 0LL;
      }
      return htmlElementStatusHere(v8, v10);
    }
  }

  else
  {
    return 0;
  }

void htmlCtxtReset(htmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return;
  }
  xmlInitParser();
  dict = ctxt->dict;
  while (1)
  {
    int v3 = inputPop(ctxt);
    if (!v3) {
      break;
    }
    xmlFreeInputStream(v3);
  }

  ctxt->inputNr = 0;
  ctxt->uint64_t input = 0LL;
  ctxt->spaceNr = 0;
  spaceTab = ctxt->spaceTab;
  if (spaceTab) {
    int *spaceTab = -1;
  }
  ctxt->space = spaceTab;
  ctxt->nodeNr = 0;
  ctxt->node = 0LL;
  ctxt->int nameNr = 0;
  ctxt->name = 0LL;
  ctxt->nsNr = 0;
  version = (xmlChar *)ctxt->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version)) {
        goto LABEL_12;
      }
      version = (xmlChar *)ctxt->version;
    }

    xmlFree(version);
  }

LABEL_12:
  ctxt->version = 0LL;
  encoding = (xmlChar *)ctxt->encoding;
  if (!encoding) {
    goto LABEL_17;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, encoding)) {
      goto LABEL_17;
    }
    encoding = (xmlChar *)ctxt->encoding;
  }

  xmlFree(encoding);
LABEL_17:
  ctxt->encoding = 0LL;
  directory = ctxt->directory;
  if (!directory) {
    goto LABEL_22;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, (const xmlChar *)directory)) {
      goto LABEL_22;
    }
    directory = ctxt->directory;
  }

  xmlFree(directory);
LABEL_22:
  ctxt->directory = 0LL;
  extSubURI = ctxt->extSubURI;
  if (!extSubURI) {
    goto LABEL_27;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, extSubURI)) {
      goto LABEL_27;
    }
    extSubURI = ctxt->extSubURI;
  }

  xmlFree(extSubURI);
LABEL_27:
  ctxt->extSubURI = 0LL;
  extSubSystem = ctxt->extSubSystem;
  if (extSubSystem)
  {
    if (!dict)
    {
LABEL_31:
      xmlFree(extSubSystem);
      goto LABEL_32;
    }

    if (!xmlDictOwns(dict, extSubSystem))
    {
      extSubSystem = ctxt->extSubSystem;
      goto LABEL_31;
    }
  }

  unsigned int v6 = (const xmlChar *)xmlPatScanNCName((const xmlChar **)a1);
  uint64_t v7 = *a1;
  size_t v8 = *(unsigned __int8 *)*a1;
  if (!v6)
  {
    if (v8 == 42)
    {
      htmlParserCtxtPtr v14 = (unsigned __int8 *)(v7 + 1);
LABEL_24:
      *a1 = (uint64_t)v14;
      int v4 = a1[4];
      unsigned int v5 = 8;
      goto LABEL_11;
    }

      prefix = 0LL;
      int v12 = xmlSplitQName2(name, &prefix);
      xmlParserInputBufferPtr v13 = v12;
      if (v12) {
        unsigned int v6 = v12;
      }
      elements = dtd->elements;
      if (!elements)
      {
        xmlDocPtr doc = dtd->doc;
        __int128 v16 = doc ? doc->dict : 0LL;
        elements = xmlHashCreateDict(0, v16);
        dtd->elements = elements;
        if (!elements)
        {
          __int128 v27 = "xmlAddElementDecl: Table creation failed!\n";
LABEL_41:
          xmlVErrMemory((uint64_t *)ctxt, (uint64_t)v27);
          if (v13) {
            xmlFree(v13);
          }
          if (!prefix) {
            return 0LL;
          }
          __int128 v23 = (void (*)(void))xmlFree;
          goto LABEL_51;
        }
      }

      uint64_t v17 = dtd->doc;
      if (v17
        && (intSubset = v17->intSubset) != 0LL
        && (__int128 v19 = xmlHashLookup2((xmlHashTablePtr)intSubset->elements, v6, prefix)) != 0LL
        && (__int128 v20 = (uint64_t)v19, !*((_DWORD *)v19 + 18)))
      {
        __int128 v21 = v19[11];
        v19[11] = 0LL;
        xmlHashRemoveEntry2((xmlHashTablePtr)dtd->doc->intSubset->elements, v6, prefix, 0LL);
        xmlFreeElement(v20);
      }

      else
      {
        __int128 v21 = 0LL;
      }

      __int128 v22 = xmlHashLookup2((xmlHashTablePtr)elements, v6, prefix);
      if (v22)
      {
        unsigned int v5 = (uint64_t)v22;
        if (v22[18])
        {
          xmlErrValidNode( (uint64_t *)ctxt,  (int)dtd,  509,  (uint64_t)"Redefinition of element %s\n",  (uint64_t)v6,  0LL,  0LL);
          if (v13) {
            xmlFree(v13);
          }
          if (!prefix) {
            return 0LL;
          }
          __int128 v23 = (void (*)(void))xmlFree;
          goto LABEL_51;
        }

        if (prefix)
        {
          xmlFree(prefix);
          prefix = 0LL;
        }

        goto LABEL_55;
      }

      __int128 v24 = xmlMalloc(0x70uLL);
      if (!v24)
      {
        __int128 v27 = "malloc failed";
        goto LABEL_41;
      }

      unsigned int v5 = (uint64_t)v24;
      v24[5] = 0u;
      v24[6] = 0u;
      v24[3] = 0u;
      v24[4] = 0u;
      v24[1] = 0u;
      v24[2] = 0u;
      _BYTE *v24 = 0u;
      *((_DWORD *)v24 + 2) = 15;
      __int128 v25 = xmlStrdup(v6);
      *(void *)(v5 + 16) = v25;
      if (!v25)
      {
        xmlVErrMemory((uint64_t *)ctxt, (uint64_t)"malloc failed");
        if (v13) {
          xmlFree(v13);
        }
        if (prefix) {
          xmlFree(prefix);
        }
        __int128 v23 = (void (*)(void))xmlFree;
        goto LABEL_51;
      }

      __int128 v26 = prefix;
      *(void *)(v5 + 96) = prefix;
      if (xmlHashAddEntry2((xmlHashTablePtr)elements, v6, v26, (void *)v5))
      {
        xmlErrValidNode((uint64_t *)ctxt, (int)dtd, 509, (uint64_t)"Redefinition of element %s\n", (uint64_t)v6, 0LL, 0LL);
        xmlFreeElement(v5);
        if (!v13) {
          return 0LL;
        }
        __int128 v23 = (void (*)(void))xmlFree;
LABEL_51:
        v23();
        return 0LL;
      }

      *(void *)(v5 + 88) = v21;
LABEL_55:
      *(_DWORD *)(v5 + 72) = type;
      if (ctxt && ctxt->finishDtd >> 1 == 1441171738)
      {
        *(void *)(v5 + 80) = content;
        if (content) {
          content->parent = (_xmlElementContent *)1;
        }
      }

      else
      {
        *(void *)(v5 + 80) = xmlCopyDocElementContent(dtd->doc, content);
      }

      *(void *)(v5 + 40) = dtd;
      *(void *)(v5 + 64) = dtd->doc;
      last = dtd->last;
      if (last)
      {
        last->next = (_xmlNode *)v5;
        *(void *)(v5 + 56) = last;
      }

      else
      {
        dtd->children = (_xmlNode *)v5;
      }

      dtd->last = (_xmlNode *)v5;
      if (v13) {
        xmlFree(v13);
      }
      return (xmlElementPtr)v5;
    default:
      uint64_t v11 = "Internal: ELEMENT decl corrupted invalid type\n";
      goto LABEL_18;
  }

  unsigned int v6 = xmlRegCheckCharacterRange(v5, code, 0, 0, *(char **)(a1 + 24));
  if (*(_DWORD *)(a1 + 40)) {
    return v6 == 0;
  }
  else {
    return v6;
  }
}

      xmlSchemaFree(v3);
      goto LABEL_13;
    }

    return 0LL;
  }

      int v12 = *__xmlGenericError();
      xmlParserInputBufferPtr v13 = __xmlGenericErrorContext();
      v12(*v13, "xmlXPathCompiledEval: No result on the stack.\n");
      goto LABEL_13;
    }
  }

  else
  {
    __xmlRaiseError( 0LL,  0LL,  0LL,  0LL,  0LL,  0xCu,  1,  3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xpath.c",  14528,  0LL,  0LL,  0LL,  0,  0,  "NULL context pointer\n",  v15);
  }

  return 0LL;
}

LABEL_32:
  ctxt->extSubSystem = 0LL;
  myDoc = ctxt->myDoc;
  if (myDoc) {
    xmlFreeDoc(myDoc);
  }
  ctxt->myDoc = 0LL;
  *(void *)&ctxt->standalone = 0x1FFFFFFFFLL;
  *(void *)&ctxt->xmlParserInputState instate = 0LL;
  ctxt->wellFormed = 1;
  ctxt->nsWellFormed = 1;
  *(void *)&ctxt->disableSAX = 0LL;
  ctxt->valid = 1;
  ctxt->vctxt.finishDtd = -1412623820;
  ctxt->vctxt.userData = ctxt;
  ctxt->vctxt.error = xmlParserValidityError;
  ctxt->vctxt.warning = xmlParserValidityWarning;
  ctxt->record_xmlParserNodeInfo info = 0;
  ctxt->checkIndex = 0LL;
  *(void *)&ctxt->int errNo = 0LL;
  *(void *)&ctxt->hasPErefs = 0LL;
  ctxt->depth = 0;
  ctxt->charset = 0;
  ctxt->catalogs = 0LL;
  xmlInitNodeInfoSeq(&ctxt->node_seq);
  attsDefault = ctxt->attsDefault;
  if (attsDefault)
  {
    xmlHashFree(attsDefault, (xmlHashDeallocator)xmlHashDefaultDeallocator);
    ctxt->attsDefault = 0LL;
  }

  attsSpecial = ctxt->attsSpecial;
  if (attsSpecial)
  {
    xmlHashFree(attsSpecial, 0LL);
    ctxt->attsSpecial = 0LL;
  }

        uint64_t v17 = xmlStrndup(&input->base[v6], v12);
        goto LABEL_33;
      }
    }

    size_t v9 = "Unfinished SystemLiteral\n";
    ctxt = v1;
    xmlParserInputPtr v10 = 44;
    goto LABEL_29;
  }

  return 0LL;
}

  if (v24)
  {
    __int128 v22 = (void (*)(void))v5[6];
    if (v22) {
      v22(v5[1]);
    }
  }

  return v16;
}

  notations = (xmlNotationTable *)cur->notations;
  if (notations) {
    xmlFreeNotationTable(notations);
  }
  elements = (xmlElementTable *)cur->elements;
  if (elements) {
    xmlFreeElementTable(elements);
  }
  attributes = (xmlAttributeTable *)cur->attributes;
  if (attributes) {
    xmlFreeAttributeTable(attributes);
  }
  entities = (xmlEntitiesTable *)cur->entities;
  if (entities) {
    xmlFreeEntitiesTable(entities);
  }
  pentities = (xmlEntitiesTable *)cur->pentities;
  if (pentities) {
    xmlFreeEntitiesTable(pentities);
  }
  xmlFree(cur);
}

            *((void *)reader + 15) = i;
            xmlFree(v7);
            if (prefix) {
              xmlFree(prefix);
            }
            return 1;
          }
        }

        else
        {
          for (uint64_t i = *(uint64_t ***)(v9 + 88); i; uint64_t i = (uint64_t **)i[6])
          {
            if (xmlStrEqual((const xmlChar *)i[2], v7))
            {
              int v15 = i[9];
              if (v15)
              {
                if (xmlStrEqual((const xmlChar *)v15[3], prefix)) {
                  goto LABEL_32;
                }
              }
            }
          }
        }

int htmlCtxtUseOptions(htmlParserCtxtPtr ctxt, int options)
{
  if (!ctxt) {
    return -1;
  }
  if (htmlParserNeedsNoBlankQuirk_hasEvaluatedQuirk != -1) {
    dispatch_once(&htmlParserNeedsNoBlankQuirk_hasEvaluatedQuirk, &__block_literal_global);
  }
  if (htmlParserNeedsNoBlankQuirk_needsQuirk) {
    int v4 = options | 0x100;
  }
  else {
    int v4 = options;
  }
  if ((v4 & 0x40) == 0)
  {
    if ((v4 & 0x20) == 0) {
      goto LABEL_9;
    }
LABEL_13:
    sax = ctxt->sax;
    ctxt->vctxt.error = 0LL;
    sax->error = 0LL;
    sax->fatalError = 0LL;
    v4 -= 32;
    ctxt->options |= 0x20u;
    if ((v4 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }

  ctxt->sax->warning = 0LL;
  ctxt->vctxt.warning = 0LL;
  v4 -= 64;
  ctxt->options |= 0x40u;
  if ((v4 & 0x20) != 0) {
    goto LABEL_13;
  }
LABEL_9:
  if ((v4 & 0x80) == 0)
  {
LABEL_10:
    int v5 = 0;
    goto LABEL_15;
  }

LABEL_14:
  v4 -= 128;
  ctxt->options |= 0x80u;
  int v5 = 1;
LABEL_15:
  ctxt->pedantic = v5;
  if ((v4 & 0x100) != 0)
  {
    int v8 = 0;
    ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
    v4 -= 256;
    ctxt->options |= 0x100u;
  }

  else
  {
    int v8 = 1;
  }

  ctxt->keepBlanks = v8;
  int result = v4 & 0xFFFFFFFE;
  ctxt->recovery = v4 & 1;
  if ((v4 & 0x10000) != 0)
  {
    ctxt->options |= 0x10000u;
    result -= 0x10000;
    if ((result & 0x80000) == 0)
    {
LABEL_20:
      if ((result & 4) == 0) {
        goto LABEL_21;
      }
      goto LABEL_27;
    }
  }

  else if ((v4 & 0x80000) == 0)
  {
    goto LABEL_20;
  }

  ctxt->options |= 0x80000u;
  result -= 0x80000;
  if ((result & 4) == 0)
  {
LABEL_21:
    if ((result & 0x200000) == 0) {
      goto LABEL_22;
    }
LABEL_28:
    ctxt->options |= 0x200000u;
    result -= 0x200000;
    if ((result & 0x2000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

    int result = recv(*(_DWORD *)(a1 + 40), v4, 0x1000uLL, 0);
    *(_DWORD *)(a1 + 100) = result;
    if ((int)result >= 1)
    {
      *(void *)(a1 + 80) += result;
      return result;
    }

    if ((_DWORD)result != -1)
    {
      if (!(_DWORD)result) {
        return result;
      }
      goto LABEL_19;
    }

    uint64_t v11 = *__error();
LABEL_19:
    v12.fd = *(_DWORD *)(a1 + 40);
    v12.events = 1;
    if (poll(&v12, 1u, 60000) <= 0 && *__error() != 4 || (*(_BYTE *)(a1 + 44) & 2) == 0) {
      return 0LL;
    }
  }

  int result = 0LL;
  if (v11 != 54 && v11 != 58)
  {
    __xmlIOErr(10, 0, (uint64_t)"recv failed\n");
    return 0xFFFFFFFFLL;
  }

  return result;
}

    uint64_t v7 = inputTab[inputNr - 2];
    goto LABEL_15;
  }

  int v8 = 0LL;
LABEL_17:
  xmlFreeInputStream(v8);
  LOBYTE(ctxt) = *v1->input->cur;
  if (!(_BYTE)ctxt)
  {
    xmlParserInputGrow(v1->input, 250);
    LOBYTE(ctxt) = *v1->input->cur;
  }

  return ctxt;
}

        unsigned int v6 = 0LL;
        goto LABEL_15;
      }
    }
  }

  return 0LL;
}

    if (v6) {
      size_t v9 = v6 == v2;
    }
    else {
      size_t v9 = 1;
    }
    int v3 = v6;
    if (v9) {
      goto LABEL_38;
    }
  }

  if (v4 != 5) {
    goto LABEL_11;
  }
  int v5 = *(void *)(v3 + 24);
  if (v5 && *(_DWORD *)(v5 + 8) == 17 && *(void *)(v5 + 24))
  {
    xmlTextReaderEntPush(a1, v3);
    unsigned int v6 = *(void *)(*(void *)(v3 + 24) + 24LL);
    goto LABEL_14;
  }

  while (v3 != v2)
  {
LABEL_20:
    unsigned int v6 = *(void *)(v3 + 48);
    if (v6) {
      goto LABEL_14;
    }
    int v3 = *(void *)(v3 + 40);
    xmlParserInputPtr v10 = *(_DWORD *)(v3 + 8);
    if (v10 == 1)
    {
      if (!*(_DWORD *)(a1 + 176))
      {
        while (1)
        {
          int v15 = *(void *)(v3 + 32);
          if (!v15 || (*(_WORD *)(v15 + 114) & 2) != 0) {
            break;
          }
          xmlUnlinkNode(*(xmlNodePtr *)(v3 + 32));
          xmlTextReaderFreeNode(a1, (xmlAttr *)v15);
        }
      }

      *(void *)(a1 + 112) = v3;
      xmlTextReaderValidatePop(a1);
      xmlParserInputPtr v10 = *(_DWORD *)(v3 + 8);
    }

    if (v10 == 17)
    {
      uint64_t v11 = *(void *)(a1 + 168);
      if (v11)
      {
        if (*(void *)(v11 + 24) == v3)
        {
          int v12 = *(_DWORD *)(a1 + 176);
          xmlParserInputBufferPtr v13 = v12 - 1;
          if (v12 < 1)
          {
            int v3 = 0LL;
          }

          else
          {
            *(_DWORD *)(a1 + 176) = v13;
            htmlParserCtxtPtr v14 = *(void *)(a1 + 184);
            if (v12 == 1) {
              __int128 v16 = 0LL;
            }
            else {
              __int128 v16 = *(void *)(v14 + 8LL * (v12 - 2));
            }
            *(void *)(a1 + 168) = v16;
            int v3 = *(void *)(v14 + 8LL * v13);
            *(void *)(v14 + 8LL * v13) = 0LL;
          }
        }
      }
    }
  }

      int result = 0LL;
      goto LABEL_15;
    }
  }

  else
  {
    int v5 = *(void *)(*(void *)(a1 + 8) + 24LL);
    if (!v5) {
      goto LABEL_14;
    }
  }

            v10 += 24LL;
          }
        }

        *(_DWORD *)(v6 + 4) = 0;
      }
    }
  }

  return result;
}

    xmlXPathErr(ctxt, v9);
  }

    xmlXPathErr(ctxt, v9);
  }

  int v12 = xmlXPathParseName((xmlXPathParserContextPtr)v6);
  if (!v12)
  {
LABEL_104:
    xmlXPathErr((xmlXPathParserContextPtr)v6, 7);
    goto LABEL_105;
  }

  xmlParserInputBufferPtr v13 = v12;
  if (**(_BYTE **)v6 != 40)
  {
    xmlParserInputPtr v10 = (xmlXPathParserContext *)v6;
    uint64_t v11 = v13;
LABEL_99:
    xmlXPtrEvalChildSeq(v10, v11);
    for (uint64_t j = *(void *)v6 + 1LL; ; ++j)
    {
      uint64_t v57 = *(unsigned __int8 *)(j - 1);
      if (v57 > 0x20) {
        break;
      }
      if (((1LL << v57) & 0x100002600LL) == 0)
      {
        if (!*(_BYTE *)(j - 1)) {
          goto LABEL_105;
        }
        goto LABEL_104;
      }

      *(void *)unsigned int v6 = j;
    }

    goto LABEL_104;
  }

  htmlParserCtxtPtr v14 = &xmlMallocAtomic;
  while (2)
  {
    *(_DWORD *)(v6 + 16) = 0;
    int v15 = *(unsigned __int8 **)v6;
    if (**(_BYTE **)v6 != 40)
    {
      xmlFree(v13);
      __int128 v27 = (xmlXPathParserContext *)v6;
      __int128 v28 = 7;
      goto LABEL_38;
    }

    *(void *)unsigned int v6 = v15 + 1;
    __int128 v16 = xmlStrlen(v15 + 1);
    uint64_t v17 = ((uint64_t (*)(void))*v14)(v16 + 1);
    if (!v17)
    {
      xmlXPtrErrMemory((const xmlChar *)"allocating buffer");
LABEL_72:
      xmlFree(v13);
      goto LABEL_73;
    }

    __int128 v18 = (_BYTE *)v17;
    __int128 v19 = *(unsigned __int8 **)v6;
    __int128 v20 = 1;
    for (uint64_t k = (_BYTE *)v17; ; ++k)
    {
      __int128 v22 = *v19;
      if (v22 <= 0x28) {
        break;
      }
      if (v22 == 94)
      {
        __int128 v24 = v19[1];
        __int128 v23 = v19 + 1;
        __int128 v25 = (1LL << (v24 - 40)) & 0x40000000000003LL;
        if ((v24 - 40) > 0x36 || v25 == 0)
        {
          LOBYTE(v22) = 94;
        }

        else
        {
          *(void *)unsigned int v6 = v23;
          LOBYTE(v22) = *v23;
        }
      }

      else if (v22 == 41)
      {
        if (!--v20)
        {
          *(void *)unsigned int v6 = v19 + 1;
          void *k = 0;
LABEL_45:
          if (xmlStrEqual(v13, (const xmlChar *)"xpointer"))
          {
            __int128 v29 = *(void **)(v6 + 24);
            v29[1] = *v29;
            v29[13] = 0x100000001LL;
            v65 = *(_OWORD *)v6;
            *(void *)unsigned int v6 = v18;
            *(void *)(v6 + 8) = v18;
            xmlXPathEvalExpr((xmlXPathParserContextPtr)v6);
            *(_OWORD *)unsigned int v6 = v65;
          }

          else if (xmlStrEqual(v13, (const xmlChar *)"element"))
          {
            xmlParserInputPtr v30 = v14;
            uint64_t v32 = *(unsigned __int8 **)v6;
            size_t v31 = *(void *)(v6 + 8);
            *(void *)unsigned int v6 = v18;
            *(void *)(v6 + 8) = v18;
            if (*v18 == 47)
            {
              xmlXPathRoot((xmlXPathParserContextPtr)v6);
              int v33 = (xmlXPathParserContext *)v6;
              size_t v34 = 0LL;
            }

            else
            {
              uint64_t v41 = xmlXPathParseName((xmlXPathParserContextPtr)v6);
              if (!v41)
              {
                *(void *)unsigned int v6 = v32;
                *(void *)(v6 + 8) = v31;
                xmlFree(v18);
                xmlFree(v13);
                xmlXPathErr((xmlXPathParserContextPtr)v6, 7);
                htmlParserCtxtPtr v14 = v30;
                goto LABEL_73;
              }

              size_t v34 = v41;
              int v33 = (xmlXPathParserContext *)v6;
            }

            xmlXPtrEvalChildSeq(v33, v34);
            *(void *)unsigned int v6 = v32;
            *(void *)(v6 + 8) = v31;
            htmlParserCtxtPtr v14 = v30;
          }

          else if (xmlStrEqual(v13, (const xmlChar *)"xmlns"))
          {
            xmlParserInputPtr v36 = *(unsigned __int8 **)v6;
            uint64_t v35 = *(void *)(v6 + 8);
            *(void *)unsigned int v6 = v18;
            *(void *)(v6 + 8) = v18;
            uint64_t v37 = xmlXPathParseNCName((xmlXPathParserContextPtr)v6);
            if (!v37)
            {
              *(void *)unsigned int v6 = v36;
              *(void *)(v6 + 8) = v35;
              xmlFree(v18);
              xmlFree(v13);
              xmlXPathErr((xmlXPathParserContextPtr)v6, 16);
              goto LABEL_73;
            }

            int v38 = *(unsigned __int8 **)v6;
            for (m = (const xmlChar *)(*(void *)v6 + 1LL); ; ++m)
            {
              size_t v40 = *v38;
              if (((1LL << v40) & 0x100002600LL) == 0) {
                break;
              }
              *(void *)unsigned int v6 = ++v38;
            }

            if (v40 != 61)
            {
LABEL_62:
              *(void *)unsigned int v6 = v36;
              *(void *)(v6 + 8) = v35;
              xmlFree(v37);
              xmlFree(v18);
              ((void (*)(xmlChar *))xmlFree)(v13);
              goto LABEL_43;
            }

            while (1)
            {
              *(void *)unsigned int v6 = m;
              int v42 = *m;
              int v43 = v42 > 0x20;
              int v44 = (1LL << v42) & 0x100002600LL;
              if (v43 || v44 == 0) {
                break;
              }
              ++m;
            }

            xmlXPathObjectPtr v66 = v36;
            int v46 = v37;
            if (xmlXPathRegisterNs(*(xmlXPathContextPtr *)(v6 + 24), v37, m) < 0) {
              xmlXPathPErrMemory(v6, 0LL);
            }
            *(void *)unsigned int v6 = v66;
            *(void *)(v6 + 8) = v35;
            xmlFree(v46);
          }

          else
          {
            xmlXPtrErr(v6, 1900, "unsupported scheme '%s'\n", v13);
          }

          xmlFree(v18);
          goto LABEL_72;
        }

        LOBYTE(v22) = 41;
      }

htmlDocPtr htmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (cur
    && (xmlInitParser(),
        int v8 = xmlStrlen(cur),
        (htmlParserCtxtPtr MemoryParserCtxt = htmlCreateMemoryParserCtxt((const char *)cur, v8)) != 0LL))
  {
    return htmlDoRead(MemoryParserCtxt, (const xmlChar *)URL, encoding, options, 0);
  }

  else
  {
    return 0LL;
  }

xmlDocPtr htmlDoRead(xmlParserCtxt *a1, const xmlChar *a2, const char *a3, int options, int a5)
{
  a1->html = 1;
  if (a3)
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(a3);
    if (CharEncodingHandler)
    {
      if (xmlSwitchToEncoding(a1, CharEncodingHandler) < 0)
      {
        if (a1->errNo) {
          int errNo = a1->errNo;
        }
        else {
          int errNo = 6003;
        }
        htmlParseErr(a1, errNo, "htmlCheckEncoding: error switching to encoding '%s'\n", (const xmlChar *)a3, 0LL);
        if (!a2) {
          goto LABEL_15;
        }
        goto LABEL_8;
      }

      encoding = (xmlChar *)a1->input->encoding;
      if (encoding) {
        xmlFree(encoding);
      }
      a1->input->encoding = xmlStrdup((const xmlChar *)a3);
    }
  }

  if (!a2) {
    goto LABEL_15;
  }
LABEL_8:
  xmlParserInputPtr input = a1->input;
  if (input && !input->filename) {
    a1->input->filename = (const char *)xmlStrdup(a2);
  }
LABEL_15:
  htmlParseDocument(a1);
  xmlDocPtr myDoc = a1->myDoc;
  a1->xmlDocPtr myDoc = 0LL;
  if (!a5)
  {
    if (a1->dictNames && myDoc && myDoc->dict == a1->dict) {
      a1->dict = 0LL;
    }
    xmlFreeParserCtxt(a1);
  }

  return myDoc;
}

htmlDocPtr htmlReadFile(const char *URL, const char *encoding, int options)
{
  htmlDocPtr result = (htmlDocPtr)htmlCreateFileParserCtxt(URL, encoding);
  if (result) {
    return htmlDoRead((xmlParserCtxt *)result, 0LL, 0LL, options, 0);
  }
  return result;
}

htmlDocPtr htmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  htmlDocPtr result = (htmlDocPtr)xmlCreateMemoryParserCtxt(buffer, size);
  if (result)
  {
    uint64_t v11 = (xmlParserCtxt *)result;
    htmlDefaultSAXHandlerInit();
    sax = v11->sax;
    if (v11->sax)
    {
      xmlParserInputBufferPtr v13 = __htmlDefaultSAXHandler();
      __int128 v14 = *(_OWORD *)&v13->hasInternalSubset;
      *(_OWORD *)&sax->internalSubset = *(_OWORD *)&v13->internalSubset;
      *(_OWORD *)&sax->hasInternalSubset = v14;
      __int128 v15 = *(_OWORD *)&v13->unparsedEntityDecl;
      __int128 v17 = *(_OWORD *)&v13->resolveEntity;
      __int128 v16 = *(_OWORD *)&v13->entityDecl;
      *(_OWORD *)&sax->attributeDecl = *(_OWORD *)&v13->attributeDecl;
      *(_OWORD *)&sax->unparsedEntityDecl = v15;
      *(_OWORD *)&sax->resolveEntity = v17;
      *(_OWORD *)&sax->entityDecl = v16;
      __int128 v18 = *(_OWORD *)&v13->ignorableWhitespace;
      __int128 v20 = *(_OWORD *)&v13->startDocument;
      __int128 v19 = *(_OWORD *)&v13->startElement;
      *(_OWORD *)&sax->reference = *(_OWORD *)&v13->reference;
      *(_OWORD *)&sax->ignorableWhitespace = v18;
      *(_OWORD *)&sax->startDocumentSAXFunc startDocument = v20;
      *(_OWORD *)&sax->startElement = v19;
      __int128 v21 = *(_OWORD *)&v13->externalSubset;
      __int128 v23 = *(_OWORD *)&v13->comment;
      __int128 v22 = *(_OWORD *)&v13->error;
      *(_OWORD *)&sax->getParameterEntity = *(_OWORD *)&v13->getParameterEntity;
      *(_OWORD *)&sax->externalSubset = v21;
      *(_OWORD *)&sax->comment = v23;
      *(_OWORD *)&sax->error = v22;
    }

    return htmlDoRead(v11, (const xmlChar *)URL, encoding, options, 0);
  }

  return result;
}

htmlDocPtr htmlReadFd(int fd, const char *URL, const char *encoding, int options)
{
  if ((fd & 0x80000000) == 0)
  {
    xmlInitParser();
    xmlParserInputBufferPtr v8 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if (v8)
    {
      size_t v9 = v8;
      v8->closecallbacuint64_t k = 0LL;
      xmlParserInputPtr v10 = htmlNewParserCtxt();
      if (v10)
      {
        uint64_t v11 = v10;
        int v12 = xmlNewIOInputStream(v10, v9, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(v11, v12);
          return htmlDoRead(v11, (const xmlChar *)URL, encoding, options, 0);
        }

        xmlFreeParserInputBuffer(v9);
        xmlFreeParserCtxt(v11);
      }

      else
      {
        xmlFreeParserInputBuffer(v9);
      }
    }
  }

  return 0LL;
}

htmlDocPtr htmlReadIO( xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (ioread)
  {
    xmlInitParser();
    xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      xmlParserInputBufferPtr v13 = IO;
      __int128 v14 = htmlNewParserCtxt();
      if (v14)
      {
        __int128 v15 = v14;
        __int128 v16 = xmlNewIOInputStream(v14, v13, XML_CHAR_ENCODING_NONE);
        if (v16)
        {
          inputPush(v15, v16);
          return htmlDoRead(v15, (const xmlChar *)URL, encoding, options, 0);
        }

        xmlFreeParserInputBuffer(v13);
        xmlFreeParserCtxt(v15);
      }

      else
      {
        xmlFreeParserInputBuffer(v13);
      }
    }

    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }

  return 0LL;
}

htmlDocPtr htmlCtxtReadDoc( xmlParserCtxtPtr ctxt, const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0LL;
  }
  if (!cur) {
    return 0LL;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  xmlParserInputPtr v10 = xmlNewStringInputStream(ctxt, cur);
  if (!v10) {
    return 0LL;
  }
  inputPush(ctxt, v10);
  return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  if (!ctxt) {
    return 0LL;
  }
  if (!filename) {
    return 0LL;
  }
  xmlInitParser();
  htmlCtxtReset(ctxt);
  ExternalEntity = xmlLoadExternalEntity(filename, 0LL, ctxt);
  if (!ExternalEntity) {
    return 0LL;
  }
  inputPush(ctxt, ExternalEntity);
  return htmlDoRead(ctxt, 0LL, encoding, options, 1);
}

htmlDocPtr htmlCtxtReadMemory( xmlParserCtxtPtr ctxt, const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  if (ctxt)
  {
    if (buffer)
    {
      xmlInitParser();
      htmlCtxtReset(ctxt);
      xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
      if (Mem)
      {
        xmlParserInputBufferPtr v13 = Mem;
        __int128 v14 = xmlNewIOInputStream(ctxt, Mem, XML_CHAR_ENCODING_NONE);
        if (v14)
        {
          inputPush(ctxt, v14);
          return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
        }

        xmlFreeParserInputBuffer(v13);
      }
    }
  }

  return 0LL;
}

htmlDocPtr htmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd, const char *URL, const char *encoding, int options)
{
  if (ctxt)
  {
    if ((fd & 0x80000000) == 0)
    {
      xmlInitParser();
      htmlCtxtReset(ctxt);
      xmlParserInputPtr v10 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
      if (v10)
      {
        uint64_t v11 = v10;
        int v12 = xmlNewIOInputStream(ctxt, v10, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(ctxt, v12);
          return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
        }

        xmlFreeParserInputBuffer(v11);
      }
    }
  }

  return 0LL;
}

htmlDocPtr htmlCtxtReadIO( xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (ctxt && ioread)
  {
    xmlInitParser();
    htmlCtxtReset(ctxt);
    xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      __int128 v15 = IO;
      __int128 v16 = xmlNewIOInputStream(ctxt, IO, XML_CHAR_ENCODING_NONE);
      if (v16)
      {
        inputPush(ctxt, v16);
        return htmlDoRead(ctxt, (const xmlChar *)URL, encoding, options, 1);
      }

      xmlFreeParserInputBuffer(v15);
    }

    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }

  return 0LL;
}

uint64_t htmlCompareStartClose(const char **a1, const char **a2)
{
  uint64_t result = strcmp(*a1, *a2);
  if (!(_DWORD)result) {
    return strcmp(a1[1], a2[1]);
  }
  return result;
}

const xmlChar *htmlParseNameComplex(uint64_t a1)
{
_htmlParseNameComplex:
  uint64_t v1 = a1;
  uint64_t v2 = *(xmlParserInput **)(a1 + 56);
  base = v2->base;
  if (!*(_DWORD *)(v1 + 452) && v2->end - v2->cur <= 249) {
    xmlParserInputGrow(v2, 250);
  }
  int v21 = 0;
  signed int v4 = htmlCurrentChar(v1, &v21);
  signed int v5 = v4;
  if (v4 > 255)
  {
    if (xmlCharInRange(v4, &xmlIsBaseCharGroup)) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = (v5 - 12330) > 0xFFFFFFF6;
    }
  }

  else if ((v4 - 192) >= 0x17 {
         && (v4 & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && v4 <= 247
         && (v4 - 216) >= 0x1F
         && v4 != 95
         && v4 != 58)
  {
    return 0LL;
  }

  int v10 = 0;
  int v11 = 0;
  while (v5 > 0x3E || ((1LL << v5) & 0x4000800100000000LL) == 0)
  {
    if (v5 > 255)
    {
      if (xmlCharInRange(v5, &xmlIsBaseCharGroup)) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = (v5 - 12321) >= 9;
      }
      BOOL v14 = v12 && v5 != 12295 && (v5 - 19968) >= 0x51A6;
      if (!v14 || xmlCharInRange(v5, &xmlIsDigitGroup)) {
        goto LABEL_50;
      }
    }

    else if ((v5 - 192) < 0x17 {
           || (v5 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (v5 - 48) < 0xA
           || v5 > 247
           || (v5 - 216) < 0x1F)
    {
      goto LABEL_50;
    }

    if ((v5 - 45) > 0x32 || ((1LL << (v5 - 45)) & 0x4000000002003LL) == 0)
    {
      if (v5 >= 256)
      {
        if (!xmlCharInRange(v5, &xmlIsCombiningGroup) && !xmlCharInRange(v5, &xmlIsExtenderGroup)) {
          break;
        }
      }

      else if (v5 != 183)
      {
        break;
      }
    }

LABEL_50:
    if (v11 >= 101)
    {
      if (!*(_DWORD *)(v1 + 452))
      {
        __int128 v15 = *(xmlParserInput **)(v1 + 56);
        if (v15->end - v15->cur <= 249) {
          xmlParserInputGrow(v15, 250);
        }
      }

      int v11 = 0;
    }

    else
    {
      ++v11;
    }

    int v16 = v21;
    uint64_t v17 = *(void *)(v1 + 56);
    __int128 v18 = *(_BYTE **)(v17 + 32);
    __int128 v19 = &v18[v21];
    if ((unint64_t)v19 <= *(void *)(v17 + 40))
    {
      if (*v18 == 10)
      {
        ++*(_DWORD *)(v17 + 52);
        *(_DWORD *)(v17 + 56) = 1;
      }

      else
      {
        ++*(_DWORD *)(v17 + 56);
      }

      *(_DWORD *)(v1 + 276) = 0;
      *(void *)(v17 + 32) = v19;
      ++*(void *)(v1 + 312);
    }

    v10 += v16;
    signed int v5 = htmlCurrentChar(v1, &v21);
    if (*(const xmlChar **)(*(void *)(v1 + 56) + 24LL) != base)
    {
      a1 = v1;
      goto _htmlParseNameComplex;
    }
  }

  uint64_t v20 = *(void *)(*(void *)(v1 + 56) + 32LL);
  if (v20 - *(void *)(*(void *)(v1 + 56) + 24LL) < v10)
  {
    htmlParseErr((_DWORD *)v1, 1, "unexpected change of input buffer", 0LL, 0LL);
    return 0LL;
  }

  return xmlDictLookup(*(xmlDictPtr *)(v1 + 456), (const xmlChar *)(v20 - v10), v10);
}

    BOOL v7 = 0;
    goto LABEL_51;
  }

  input->cur = v4;
  input->col += 2;
  if (!*v4)
  {
    xmlParserInputGrow(input, 250);
    xmlParserInputPtr input = ctxt->input;
  }

  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr input = ctxt->input;
  }

  signed int v5 = input->cur;
  if (*v5 == 59) {
    goto LABEL_50;
  }
  int v16 = 0;
  BOOL v7 = 0;
  do
  {
    if (v16 < 21)
    {
      uint64_t v17 = v16 + 1;
    }

    else
    {
      if (!ctxt->progressive && input->end - v5 <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        return 0;
      }
      uint64_t v17 = 0;
      xmlParserInputPtr input = ctxt->input;
    }

    __int128 v18 = *input->cur;
    if ((v18 - 48) > 9)
    {
      uint64_t v20 = ctxt;
      int v21 = 7;
      goto LABEL_77;
    }

    __int128 v19 = v18 + 10 * v7 - 48;
    if (v19 >= 1114112) {
      BOOL v7 = 1114112;
    }
    else {
      BOOL v7 = v19;
    }
    xmlNextChar(ctxt);
    int v16 = v17 + 1;
    xmlParserInputPtr input = ctxt->input;
    signed int v5 = input->cur;
  }

  while (*v5 != 59);
LABEL_51:
  ++input->col;
  input->cur = v5 + 1;
  if (v7 >= 1114112)
  {
    BOOL v14 = "xmlParseCharRef: character reference out of bounds\n";
    goto LABEL_41;
  }

  if (v7 > 255)
  {
  }

  else if (v7 <= 31 && (v7 > 0xD || ((1 << v7) & 0x2600) == 0))
  {
    goto LABEL_40;
  }

  return v7;
}

            *((_DWORD *)a1 + 141) |= 0x800u;
            a2 = (a2 - 2048);
            if ((a2 & 0x10000) == 0)
            {
LABEL_44:
              if ((a2 & 0x20000) == 0) {
                goto LABEL_45;
              }
              goto LABEL_52;
            }

        xmlRngPErr(a1, *((void *)v6 + 1), 1093, "Found forbidden pattern start//list\n", 0LL, 0LL);
        goto LABEL_51;
      case 9:
        if ((a3 & 1) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1067, "Found forbidden pattern attribute//attribute\n", 0LL, 0LL);
          if ((a3 & 4) == 0)
          {
LABEL_54:
            if ((a3 & 0x20) == 0) {
              goto LABEL_55;
            }
            goto LABEL_93;
          }
        }

        else if ((a3 & 4) == 0)
        {
          goto LABEL_54;
        }

        xmlRngPErr(a1, *((void *)v6 + 1), 1078, "Found forbidden pattern list//attribute\n", 0LL, 0LL);
        if ((a3 & 0x20) == 0)
        {
LABEL_55:
          if ((a3 & 0x40) == 0) {
            goto LABEL_56;
          }
          goto LABEL_94;
        }

  if (xmlCharInRange(v21, &xmlIsBaseCharGroup)) {
    __int128 v23 = 0;
  }
  else {
    __int128 v23 = (v21 - 12321) >= 9;
  }
  __int128 v25 = v23 && v21 != 12295 && (v21 - 19968) >= 0x51A6;
  if (!v25 || xmlCharInRange(v21, &xmlIsDigitGroup))
  {
    while (1)
    {
LABEL_60:
      while (1)
      {
        v3 += len;
        __int128 v26 = xmlStringCurrentChar(0LL, v3, &len);
        __int128 v27 = v26;
        if (v26 <= 255) {
          break;
        }
        if (xmlCharInRange(v26, &xmlIsBaseCharGroup)) {
          xmlParserInputPtr v30 = 0;
        }
        else {
          xmlParserInputPtr v30 = (v27 - 12321) >= 9;
        }
        uint64_t v32 = v30 && v27 != 12295 && (v27 - 19968) >= 0x51A6;
        if (v32 && !xmlCharInRange(v27, &xmlIsDigitGroup)) {
          goto LABEL_84;
        }
      }

      __int128 v28 = (v26 - 192) >= 0x17 && (v26 & 0xFFFFFFDF) - 65 >= 0x1A;
      if (v28 && (v26 - 48) >= 0xA && v26 <= 247 && (v26 - 216) >= 0x1F)
      {
LABEL_84:
        if ((v27 - 45) > 0x32 || ((1LL << (v27 - 45)) & 0x4000000002003LL) == 0)
        {
          if (v27 >= 256)
          {
            if (!xmlCharInRange(v27, &xmlIsCombiningGroup) && !xmlCharInRange(v27, &xmlIsExtenderGroup))
            {
LABEL_94:
              if (space && v27 <= 255)
              {
                do
                {
                  if (((1LL << v27) & 0x100002600LL) == 0) {
                    break;
                  }
                  v3 += len;
                  __int128 v27 = xmlStringCurrentChar(0LL, v3, &len);
                }

                while (v27 < 256);
              }

              return v27 != 0;
            }
          }

          else if (v27 != 183)
          {
            goto LABEL_94;
          }
        }
      }
    }
  }

  __int128 v22 = 0;
LABEL_102:
  if ((v22 & 1) != 0)
  {
    if (v21 == 183) {
      goto LABEL_60;
    }
  }

  else if (xmlCharInRange(v21, &xmlIsCombiningGroup) || xmlCharInRange(v21, &xmlIsExtenderGroup))
  {
    goto LABEL_60;
  }

  return 1;
}

      if (v14 == 37) {
        i += 3;
      }
      else {
        ++i;
      }
    }
  }

            uint64_t v32 = *(void *)(v32 + 16);
            if (!v32) {
              goto LABEL_148;
            }
          }

          *(void *)(v32 + 24) = v34;
          goto LABEL_50;
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x19:
          goto LABEL_149;
        case 0xE:
          xmlSchemaResolveElementReferences((xmlSchemaTypePtr)v29[v28], a1);
          goto LABEL_148;
        case 0xF:
          int v50 = *(_DWORD *)(v30 + 120);
          if ((v50 & 0x100) != 0) {
            goto LABEL_148;
          }
          *(_DWORD *)(v30 + 120) = v50 | 0x100;
          if (*(void *)(v30 + 96)) {
            goto LABEL_148;
          }
          int v51 = *(const xmlChar **)(v30 + 48);
          if (v51)
          {
            BuiltInType = xmlSchemaGetType(*(void *)(a1 + 64), v51, *(xmlChar **)(v30 + 56));
            if (!BuiltInType || *BuiltInType != 4 && (*BuiltInType != 1 || BuiltInType[40] == 45))
            {
              int v38 = *(void *)(v30 + 104);
              int v39 = *(xmlChar **)(v30 + 48);
              size_t v40 = *(const xmlChar **)(v30 + 56);
              uint64_t v41 = a1;
              int v42 = v30;
              int v53 = "type";
              int v54 = 4;
              goto LABEL_147;
            }
          }

          else
          {
            BuiltInType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
          }

          *(void *)(v30 + 96) = BuiltInType;
          goto LABEL_148;
        case 0x16:
        case 0x17:
          goto LABEL_148;
        case 0x18:
          BOOL v55 = *(void *)(v30 + 72);
          uint64_t v56 = *(const xmlChar **)(v55 + 24);
          if (!v56) {
            goto LABEL_148;
          }
          uint64_t v57 = *(void *)(a1 + 64);
          if (!v57) {
            goto LABEL_135;
          }
          uint64_t v58 = *(const xmlChar **)(v55 + 32);
          if (xmlStrEqual(v58, *(const xmlChar **)(v57 + 8))
            && (uint64_t v59 = xmlHashLookup(*(xmlHashTablePtr *)(v57 + 144), v56)) != 0LL)
          {
            *(void *)(*(void *)(v30 + 72) + 8LL) = v59;
          }

          else
          {
            if (xmlHashSize(*(xmlHashTablePtr *)(v57 + 96)) < 2
              || (v58 ? (xmlGenericErrorFunc v85 = v58) : (xmlGenericErrorFunc v85 = (const xmlChar *)"##"),
                  (__int128 v86 = xmlHashLookup(*(xmlHashTablePtr *)(v57 + 96), v85)) == 0LL))
            {
LABEL_135:
              __int128 v87 = *(void **)(v30 + 72);
              v87[1] = 0LL;
LABEL_136:
              int v38 = *(void *)(v30 + 24);
              int v39 = (xmlChar *)v87[3];
              size_t v40 = (const xmlChar *)v87[4];
              uint64_t v41 = a1;
              int v42 = v30;
              int v53 = "refer";
              int v54 = 23;
              goto LABEL_147;
            }

            uint64_t v59 = xmlHashLookup(*(xmlHashTablePtr *)(v86[10] + 144LL), v56);
            __int128 v87 = *(void **)(v30 + 72);
            v87[1] = v59;
            if (!v59) {
              goto LABEL_136;
            }
          }

          if (*(_DWORD *)v59 == 24)
          {
            xmlSchemaCustomErr4( (_DWORD *)a1,  3080,  0LL,  (_DWORD *)v30,  (const xmlChar *)"The keyref references a keyref",  0LL,  0LL,  0LL,  0LL);
            *(void *)(*(void *)(v30 + 72) + 8LL) = 0LL;
          }

          else if (*(_DWORD *)(v30 + 64) != *((_DWORD *)v59 + 16))
          {
            __int128 v150 = 0LL;
            xmlXPathObjectPtr v91 = xmlSchemaFormatQName(&v150, *((const xmlChar **)v59 + 5), *((xmlChar **)v59 + 4));
            xmlSchemaCustomErr4( (_DWORD *)a1,  3080,  0LL,  (_DWORD *)v30,  (const xmlChar *)"The cardinality of the keyref differs from the cardinality of the referenced key/unique '%s'",  v91,  0LL,  0LL,  0LL);
            if (v150) {
              xmlFree(v150);
            }
          }

          goto LABEL_148;
        case 0x1A:
          v60 = *(void *)(v30 + 24);
          if (!v60) {
            goto LABEL_148;
          }
          if (*(_DWORD *)v60 != 2000) {
            goto LABEL_148;
          }
          AttributeDecl = xmlSchemaGetAttributeDecl( *(void *)(a1 + 64),  *(const xmlChar **)(v60 + 24),  *(xmlChar **)(v60 + 32));
          *(void *)(v30 + 24) = AttributeDecl;
          if (AttributeDecl) {
            goto LABEL_148;
          }
          int v38 = *(void *)(v30 + 40);
          int v39 = *(xmlChar **)(v60 + 24);
          size_t v40 = *(const xmlChar **)(v60 + 32);
          uint64_t v41 = a1;
          int v42 = v30;
          goto LABEL_89;
        default:
          if (v31 == 2000)
          {
            if (*(_DWORD *)(v30 + 16) == 16 && !*(void *)(v30 + 8))
            {
              __int128 v71 = *(void *)(a1 + 64);
              if (v71)
              {
                __int128 v72 = *(const xmlChar **)(v30 + 24);
                if (v72)
                {
                  if ((unsigned int v73 = *(const xmlChar **)(v30 + 32), xmlStrEqual(v73, *(const xmlChar **)(v71 + 8)))
                    && (BOOL v74 = xmlHashLookup(*(xmlHashTablePtr *)(v71 + 72), v72)) != 0LL
                    || xmlHashSize(*(xmlHashTablePtr *)(v71 + 96)) >= 2
                    && (v73 ? (int v75 = v73) : (int v75 = (const xmlChar *)"##"),
                        (unsigned int v76 = xmlHashLookup(*(xmlHashTablePtr *)(v71 + 96), v75)) != 0LL
                     && (BOOL v74 = xmlHashLookup(*(xmlHashTablePtr *)(v76[10] + 72LL), v72)) != 0LL))
                  {
                    *(void *)(v30 + 8) = v74;
                    goto LABEL_148;
                  }
                }
              }

              size_t v40 = *(const xmlChar **)(v30 + 32);
              int v38 = *(void *)(v30 + 40);
              int v39 = *(xmlChar **)(v30 + 24);
              int v54 = *(_DWORD *)(v30 + 16);
              uint64_t v41 = a1;
              int v42 = 0LL;
              int v53 = "ref";
              goto LABEL_147;
            }
          }

          else
          {
            if (v31 != 2001) {
              goto LABEL_149;
            }
            if (!xmlSchemaGetAttributeDecl( *(void *)(a1 + 64),  *(const xmlChar **)(v30 + 16),  *(xmlChar **)(v30 + 24)))
            {
              int v38 = *(void *)(v30 + 8);
              int v39 = *(xmlChar **)(v30 + 16);
              size_t v40 = *(const xmlChar **)(v30 + 24);
              uint64_t v41 = a1;
              int v42 = 0LL;
LABEL_89:
              int v53 = "ref";
              int v54 = 15;
LABEL_147:
              xmlSchemaPResCompAttrErr(v41, v42, v38, (uint64_t)v53, v39, v40, v54, 0LL);
            }
          }

  size_t v40 = *a4;
  if (*a4 != 1)
  {
    if (*(_DWORD *)(a7 + 40) < *(_DWORD *)(a8 + 40))
    {
      v65 = 0LL;
      if (a2) {
        uint64_t v41 = "redefined";
      }
      else {
        uint64_t v41 = "base";
      }
      int v42 = (char *)xmlSchemaItemTypeToStr(v40);
      goto LABEL_76;
    }

    return 0LL;
  }

  if (a4[40] == 45 || *(_DWORD *)(a7 + 40) >= *(_DWORD *)(a8 + 40)) {
    return 0LL;
  }
  v65 = 0LL;
  if (a2) {
    uint64_t v41 = "redefined";
  }
  else {
    uint64_t v41 = "base";
  }
  int v42 = "simple type definition";
LABEL_76:
  int v48 = xmlSchemaGetComponentQName(&v65, a4);
  xmlSchemaCustomErr4( a1,  1799,  0LL,  a4,  (const xmlChar *)"The {process contents} of the attribute wildcard is weaker than the one in the %s %s '%s'",  (const xmlChar *)v41,  (xmlChar *)v42,  v48,  0LL);
LABEL_102:
  if (v65) {
    xmlFree(v65);
  }
  return *((unsigned int *)v39 + 8);
}

uint64_t htmlCurrentChar(uint64_t a1, _DWORD *a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 272) == -1) {
    return 0LL;
  }
  if (*(_DWORD *)(a1 + 276))
  {
    *a2 = 0;
    return *(unsigned int *)(a1 + 276);
  }

  if (*(_DWORD *)(a1 + 408) == 1)
  {
LABEL_18:
    int v11 = *(xmlParserInput **)(a1 + 56);
    cur = v11->cur;
    int v13 = *cur;
    if ((*(char *)cur & 0x80000000) == 0)
    {
      if (!*cur && cur < v11->end)
      {
        htmlParseErrInt((_DWORD *)a1, "Char 0x%X out of allowed range\n", 0);
        *a2 = 1;
        return 32LL;
      }

      *a2 = 1;
      return *cur;
    }

    if ((v13 & 0x40) == 0) {
      goto LABEL_62;
    }
    unint64_t v14 = v11->end - cur;
    if (v14 <= 1)
    {
      xmlParserInputGrow(v11, 250);
      int v11 = *(xmlParserInput **)(a1 + 56);
      cur = v11->cur;
      unint64_t v14 = v11->end - cur;
      if (v14 < 2) {
        goto LABEL_62;
      }
    }

    if ((cur[1] & 0xC0) != 0x80) {
      goto LABEL_62;
    }
    if ((~v13 & 0xE0) != 0)
    {
      *a2 = 2;
      uint64_t v4 = cur[1] & 0x3F | ((*cur & 0x1F) << 6);
    }

    else
    {
      if (v14 <= 2)
      {
        xmlParserInputGrow(v11, 250);
        int v11 = *(xmlParserInput **)(a1 + 56);
        cur = v11->cur;
        unint64_t v14 = v11->end - cur;
        if (v14 < 3) {
          goto LABEL_62;
        }
      }

      if ((cur[2] & 0xC0) != 0x80) {
        goto LABEL_62;
      }
      if ((~v13 & 0xF0) == 0)
      {
        if (v14 <= 3)
        {
          xmlParserInputGrow(v11, 250);
          int v11 = *(xmlParserInput **)(a1 + 56);
          cur = v11->cur;
          unint64_t v14 = v11->end - cur;
        }

        if ((v13 & 0xF8) == 0xF0 && v14 >= 4 && (cur[3] & 0xC0) == 0x80)
        {
          *a2 = 4;
          uint64_t v4 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12) | ((cur[2] & 0x3F) << 6) | cur[3] & 0x3Fu;
        }

LABEL_62:
        __int128 v42 = 0u;
        memset(v43, 0, sizeof(v43));
        __int128 v40 = 0u;
        __int128 v41 = 0u;
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        __int128 v36 = 0u;
        __int128 v37 = 0u;
        *(_OWORD *)__str = 0u;
        if (v11->end - v11->cur < 4) {
          snprintf(__str, 0x95uLL, "Bytes: 0x%02X\n");
        }
        else {
          snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n");
        }
        htmlParseErr((_DWORD *)a1, 81, "Input is not proper UTF-8, indicate encoding !\n", (const xmlChar *)__str, 0LL);
        __int128 v27 = *(void **)(a1 + 56);
        if (*v27 && !*(void *)(*v27 + 24LL))
        {
          xmlSwitchEncoding((xmlParserCtxtPtr)a1, XML_CHAR_ENCODING_8859_1);
          __int128 v27 = *(void **)(a1 + 56);
        }

        *a2 = 1;
        cur = (const xmlChar *)v27[4];
        return *cur;
      }

      *a2 = 3;
      uint64_t v4 = ((*cur & 0xF) << 12) | ((cur[1] & 0x3F) << 6) | cur[2] & 0x3Fu;
    }

    uint64_t v20 = xmlSearchNs((xmlDocPtr)ctxt[2], (xmlNodePtr)ctxt[10], prefix);
    if (v20)
    {
      int v21 = *(_xmlAttr **)(ctxt[10] + 88);
      if (v21)
      {
        while (1)
        {
          if (v21->ns)
          {
            if (xmlStrEqual(v8, v21->name))
            {
              ns = v21->ns;
              if (v20 == ns || xmlStrEqual(v20->href, ns->href)) {
                break;
              }
            }
          }

          int v21 = v21->next;
          if (!v21) {
            goto LABEL_72;
          }
        }

        xmlNsErrMsg(ctxt, 42, (uint64_t)"Attribute %s in %s redefined\n", (uint64_t)v8, (xmlChar *)v20->href);
        *((_DWORD *)ctxt + 6) = 0;
        if (!*((_DWORD *)ctxt + 112)) {
          *((_DWORD *)ctxt + 83) = 1;
        }
        ((void (*)(xmlChar *))xmlFree)(v8);
        goto LABEL_102;
      }
    }

    else
    {
      xmlNsErrMsg(ctxt, 201, (uint64_t)"Namespace prefix %s of attribute %s is not defined\n", (uint64_t)prefix, v8);
    }

const xmlChar *htmlParseHTMLName(xmlParserCtxtPtr ctxt)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v13 = 0;
  memset(v12, 0, sizeof(v12));
  int v2 = *ctxt->input->cur;
  if ((v2 & 0xFFFFFFDF) - 65 < 0x1A
    || ((v3 = v2 - 46, BOOL v4 = v3 > 0x31, v5 = (1LL << v3) & 0x2000000001001LL, !v4) ? (v6 = v5 == 0) : (v6 = 1), !v6))
  {
    uint64_t v7 = 0LL;
    while (1)
    {
      int v8 = *ctxt->input->cur;
      if ((v8 - 65) >= 0x1A)
      {
        if ((v8 - 97) >= 0x1A
          && (v8 - 48) >= 0xA
          && ((v8 - 45) > 0x32 || ((1LL << (v8 - 45)) & 0x4000000002003LL) == 0))
        {
          return xmlDictLookup(ctxt->dict, (const xmlChar *)v12, v7);
        }
      }

      else
      {
        LOBYTE(v8) = v8 + 32;
      }

      *((_BYTE *)v12 + v7++) = v8;
      xmlNextChar(ctxt);
      if (v7 == 100) {
        return xmlDictLookup(ctxt->dict, (const xmlChar *)v12, v7);
      }
    }
  }

  return 0LL;
}

int *htmlAutoClose(int *result, uint64_t a2)
{
  int v2 = result;
  if (!a2) {
    return (int *)htmlAutoCloseOnEnd((uint64_t)result);
  }
  for (uint64_t i = *((void *)result + 36); i; uint64_t i = *((void *)v2 + 36))
  {
    v10[0] = i;
    v10[1] = a2;
    uint64_t result = (int *)bsearch( v10,  htmlStartClose,  0xFBuLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareStartClose);
    if (!result) {
      break;
    }
    if (*(void *)v2)
    {
      uint64_t v5 = *(uint64_t (**)(void, void))(*(void *)v2 + 120LL);
      if (v5) {
        uint64_t result = (int *)v5(*((void *)v2 + 1), *((void *)v2 + 36));
      }
    }

    int v6 = v2[74];
    unsigned int v7 = v6 - 1;
    if (v6 >= 1)
    {
      v2[74] = v7;
      uint64_t v8 = *((void *)v2 + 38);
      if (v6 == 1) {
        uint64_t v9 = 0LL;
      }
      else {
        uint64_t v9 = *(void *)(v8 + 8LL * (v6 - 2));
      }
      *((void *)v2 + 36) = v9;
      *(void *)(v8 + 8LL * v7) = 0LL;
    }
  }

  return result;
}

uint64_t htmlCheckImplied(uint64_t result, xmlChar *str1)
{
  if ((*(_BYTE *)(result + 565) & 0x20) != 0) {
    return result;
  }
  if (!htmlOmittedDefaultValue) {
    return result;
  }
  uint64_t v3 = result;
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"html");
  if ((_DWORD)result) {
    return result;
  }
  if (*(int *)(v3 + 296) <= 0)
  {
    htmlnamePush(v3, (xmlChar *)"html");
    if (*(void *)v3)
    {
      BOOL v4 = *(void (**)(void, const char *, void))(*(void *)v3 + 112LL);
      if (v4) {
        v4(*(void *)(v3 + 8), "html", 0LL);
      }
    }
  }

  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"body");
  if ((_DWORD)result) {
    return result;
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"head");
  if ((_DWORD)result) {
    return result;
  }
  if (*(int *)(v3 + 296) <= 1)
  {
    uint64_t result = xmlStrEqual(str1, (const xmlChar *)"script");
    if ((_DWORD)result
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"style"), (_DWORD)result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"meta"), (_DWORD)result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"link"), (_DWORD)result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"title"), (_DWORD)result)
      || (uint64_t result = xmlStrEqual(str1, (const xmlChar *)"base"), (_DWORD)result))
    {
      uint64_t result = (uint64_t)htmlnamePush(v3, (xmlChar *)"head");
      if (!*(void *)v3) {
        return result;
      }
      uint64_t v5 = *(uint64_t (**)(uint64_t, const char *, void))(*(void *)v3 + 112LL);
      if (!v5) {
        return result;
      }
      uint64_t v6 = *(void *)(v3 + 8);
      unsigned int v7 = "head";
      return v5(v6, v7, 0LL);
    }
  }

  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"noframes");
  if ((_DWORD)result) {
    return result;
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"frame");
  if ((_DWORD)result) {
    return result;
  }
  uint64_t result = xmlStrEqual(str1, (const xmlChar *)"frameset");
  if (*(int *)(v3 + 296) < 1)
  {
LABEL_32:
    uint64_t result = (uint64_t)htmlnamePush(v3, (xmlChar *)"body");
    if (!*(void *)v3) {
      return result;
    }
    uint64_t v5 = *(uint64_t (**)(uint64_t, const char *, void))(*(void *)v3 + 112LL);
    if (!v5) {
      return result;
    }
    uint64_t v6 = *(void *)(v3 + 8);
    unsigned int v7 = "body";
    return v5(v6, v7, 0LL);
  }

  uint64_t v8 = 0LL;
  while (1)
  {
    uint64_t result = xmlStrEqual(*(const xmlChar **)(*(void *)(v3 + 304) + 8 * v8), (const xmlChar *)"body");
    if ((_DWORD)result) {
      return result;
    }
    uint64_t result = xmlStrEqual(*(const xmlChar **)(*(void *)(v3 + 304) + 8 * v8), (const xmlChar *)"head");
    if ((_DWORD)result) {
      return result;
    }
  }

_DWORD *htmlnamePush(uint64_t a1, xmlChar *str1)
{
  int v4 = *(_DWORD *)(a1 + 52);
  if (v4 > 2)
  {
LABEL_5:
    if (v4 > 9) {
      goto LABEL_8;
    }
    goto LABEL_6;
  }

  if (!xmlStrEqual(str1, (const xmlChar *)"head"))
  {
    int v4 = *(_DWORD *)(a1 + 52);
    goto LABEL_5;
  }

  *(_DWORD *)(a1 + 52) = 3;
LABEL_6:
  if (xmlStrEqual(str1, (const xmlChar *)"body")) {
    *(_DWORD *)(a1 + 52) = 10;
  }
LABEL_8:
  int v5 = *(_DWORD *)(a1 + 296);
  uint64_t v6 = *(int *)(a1 + 300);
  if (v5 < (int)v6)
  {
    uint64_t result = *(_DWORD **)(a1 + 304);
LABEL_12:
    *(void *)&result[2 * v5] = str1;
    *(void *)(a1 + 288) = str1;
    *(_DWORD *)(a1 + 296) = v5 + 1;
    return result;
  }

  *(_DWORD *)(a1 + 300) = 2 * v6;
  uint64_t result = xmlRealloc(*(void **)(a1 + 304), 16 * v6);
  *(void *)(a1 + 304) = result;
  if (result)
  {
    int v5 = *(_DWORD *)(a1 + 296);
    goto LABEL_12;
  }

  return htmlErrMemory((_DWORD *)a1, 0LL);
}

xmlChar *htmlParseHTMLAttribute(uint64_t a1, int a2)
{
  str = 0LL;
  int v4 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (v4)
  {
    int v5 = v4;
    uint64_t v6 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
    unsigned int v7 = *v6;
    if (*v6) {
      BOOL v8 = v7 == a2;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      int v9 = 100;
      int v10 = v4;
      while (1)
      {
        if (!a2 && v7 == 62) {
          goto LABEL_8;
        }
        if (a2)
        {
          if (v7 != 38) {
            goto LABEL_51;
          }
        }

        else
        {
          if (v7 > 0x26) {
            goto LABEL_51;
          }
          if (v7 != 38LL)
          {
            if (((1LL << v7) & 0x100002600LL) != 0) {
              goto LABEL_8;
            }
LABEL_51:
            int v38 = 0;
            if (v5 - v10 > v9 - 100)
            {
              v9 *= 2;
              uint64_t v25 = (xmlChar *)xmlRealloc(v10, v9);
              if (!v25) {
                goto LABEL_88;
              }
              int v5 = &v25[(int)v5 - (int)v10];
              int v10 = v25;
            }

            unsigned int v26 = htmlCurrentChar(a1, &v38);
            if (*(_DWORD *)(a1 + 272) == -1) {
              goto LABEL_89;
            }
            if (v26 < 0x80)
            {
              *v5++ = v26;
            }

            else
            {
              if (HIWORD(v26)) {
                char v27 = (v26 >> 18) & 7 | 0xF0;
              }
              else {
                char v27 = (v26 >> 12) | 0xE0;
              }
              if (HIWORD(v26)) {
                int v28 = 12;
              }
              else {
                int v28 = 6;
              }
              unsigned int v29 = (v26 >> 6) | 0xFFFFFFC0;
              if (v26 <= 0x7FF)
              {
                unsigned int v30 = 0;
              }

              else
              {
                LOBYTE(v29) = v27;
                unsigned int v30 = v28;
              }

              *v5++ = v29;
              do
              {
                *v5++ = (v26 >> v30) & 0x3F | 0x80;
                BOOL v16 = v30 > 5;
                v30 -= 6;
              }

              while (v16);
            }

            xmlNextChar((xmlParserCtxtPtr)a1);
            goto LABEL_82;
          }
        }

        if (v6[1] == 35)
        {
          unsigned int v11 = htmlParseCharRef((htmlParserCtxtPtr)a1);
          if (v11 < 0x80)
          {
            *v5++ = v11;
          }

          else
          {
            if (HIWORD(v11)) {
              char v12 = (v11 >> 18) & 7 | 0xF0;
            }
            else {
              char v12 = (v11 >> 12) | 0xE0;
            }
            if (HIWORD(v11)) {
              int v13 = 12;
            }
            else {
              int v13 = 6;
            }
            unsigned int v14 = (v11 >> 6) | 0xFFFFFFC0;
            if (v11 <= 0x7FF)
            {
              unsigned int v15 = 0;
            }

            else
            {
              LOBYTE(v14) = v12;
              unsigned int v15 = v13;
            }

            *v5++ = v14;
            do
            {
              *v5++ = (v11 >> v15) & 0x3F | 0x80;
              BOOL v16 = v15 > 5;
              v15 -= 6;
            }

            while (v16);
          }
        }

        else
        {
          uint64_t v17 = htmlParseEntityRef((htmlParserCtxtPtr)a1, (const xmlChar **)&str);
          if (str)
          {
            __int128 v18 = v17;
            if (v17)
            {
              if (v5 - v10 > v9 - 100)
              {
                v9 *= 2;
                __int128 v19 = (xmlChar *)xmlRealloc(v10, v9);
                if (!v19) {
                  goto LABEL_88;
                }
                int v5 = &v19[(int)v5 - (int)v10];
                int v10 = v19;
              }

              unsigned int value = v18->value;
              if (v18->value < 0x80)
              {
                *v5++ = value;
              }

              else
              {
                if (HIWORD(value)) {
                  char v21 = (value >> 18) & 7 | 0xF0;
                }
                else {
                  char v21 = (value >> 12) | 0xE0;
                }
                if (HIWORD(value)) {
                  int v22 = 12;
                }
                else {
                  int v22 = 6;
                }
                unsigned int v23 = (value >> 6) | 0xFFFFFFC0;
                if (value <= 0x7FF)
                {
                  unsigned int v24 = 0;
                }

                else
                {
                  LOBYTE(v23) = v21;
                  unsigned int v24 = v22;
                }

                *v5++ = v23;
                do
                {
                  *v5++ = (value >> v24) & 0x3F | 0x80;
                  BOOL v16 = v24 > 5;
                  v24 -= 6;
                }

                while (v16);
              }
            }

            else
            {
              *v5++ = 38;
              xmlChar v32 = *str;
              if (*str)
              {
                int v33 = str + 1;
                do
                {
                  if (v5 - v10 > v9 - 100)
                  {
                    v9 *= 2;
                    size_t v34 = (xmlChar *)xmlRealloc(v10, v9);
                    if (!v34) {
                      goto LABEL_88;
                    }
                    int v5 = &v34[(int)v5 - (int)v10];
                    xmlChar v32 = *(v33 - 1);
                    int v10 = v34;
                  }

                  *v5++ = v32;
                  int v35 = *v33++;
                  xmlChar v32 = v35;
                }

                while (v35);
              }
            }

            goto LABEL_82;
          }

          *v5++ = 38;
        }

        if (v5 - v10 > v9 - 100)
        {
          v9 *= 2;
          uint64_t v31 = (xmlChar *)xmlRealloc(v10, v9);
          if (!v31)
          {
LABEL_88:
            htmlErrMemory((_DWORD *)a1, (uint64_t)"growing buffer\n");
LABEL_89:
            xmlFree(v10);
            return 0LL;
          }

          int v5 = &v31[(int)v5 - (int)v10];
          int v10 = v31;
        }

uint64_t htmlCheckEncodingDirect(uint64_t result, xmlChar *cur)
{
  if (!cur) {
    return result;
  }
  uint64_t v2 = result;
  if ((*(_BYTE *)(result + 566) & 0x20) != 0 || *(void *)(*(void *)(result + 56) + 80LL)) {
    return result;
  }
  for (uint64_t i = cur; ; ++i)
  {
    int v4 = *i;
    if (v4 != 32 && v4 != 9) {
      break;
    }
  }

  *(void *)(*(void *)(result + 56) + 80LL) = xmlStrdup(i);
  xmlCharEncoding v6 = xmlParseCharEncoding((const char *)i);
  if ((v6 - 2) >= 4)
  {
    if (v6 == XML_CHAR_ENCODING_ERROR)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)i);
      if (!CharEncodingHandler)
      {
        uint64_t result = (uint64_t)htmlParseErr((_DWORD *)v2, 32, "htmlCheckEncoding: unknown encoding %s\n", i, 0LL);
        goto LABEL_27;
      }

      uint64_t result = xmlSwitchToEncoding((xmlParserCtxtPtr)v2, CharEncodingHandler);
      if ((result & 0x80000000) != 0) {
        goto LABEL_21;
      }
      goto LABEL_26;
    }
  }

  else
  {
    uint64_t v7 = **(void **)(v2 + 56);
    if (v7 && !*(void *)(v7 + 24))
    {
      BOOL v8 = "htmlCheckEncoding: wrong encoding meta\n";
      int v9 = (_DWORD *)v2;
      int v10 = 81;
      unsigned int v11 = 0LL;
LABEL_25:
      uint64_t result = (uint64_t)htmlParseErr(v9, v10, v8, v11, 0LL);
      goto LABEL_26;
    }
  }

  uint64_t result = xmlSwitchEncoding((xmlParserCtxtPtr)v2, v6);
  if ((result & 0x80000000) != 0)
  {
LABEL_21:
    if (*(_DWORD *)(v2 + 136)) {
      int v10 = *(_DWORD *)(v2 + 136);
    }
    else {
      int v10 = 6003;
    }
    BOOL v8 = "htmlCheckEncoding: error switching to encoding '%s'\n";
    int v9 = (_DWORD *)v2;
    unsigned int v11 = i;
    goto LABEL_25;
  }

xmlChar *htmlParseEndTag(xmlParserCtxt *a1)
{
  uint64_t v1 = a1;
  xmlParserInputPtr input = a1->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    input->cur = cur + 2;
    input->col += 2;
    uint64_t result = (xmlChar *)htmlParseHTMLName(a1);
    if (result)
    {
      int v5 = result;
      htmlSkipBlankChars((uint64_t)v1);
      if (*v1->input->cur == 62)
      {
LABEL_5:
        xmlNextChar(v1);
      }

      else
      {
        htmlParseErr(v1, 73, "End tag : expected '>'\n", 0LL, 0LL);
        while (*v1->input->cur)
        {
          if (*v1->input->cur == 62) {
            goto LABEL_5;
          }
          xmlNextChar(v1);
        }
      }

      if (v1->depth >= 1
        && (xmlStrEqual(v5, (const xmlChar *)"html")
         || xmlStrEqual(v5, (const xmlChar *)"body")
         || xmlStrEqual(v5, (const xmlChar *)"head")))
      {
        uint64_t result = 0LL;
        --v1->depth;
      }

      else
      {
        uint64_t nameNr = v1->nameNr;
        do
        {
          if ((int)nameNr < 1)
          {
            xmlCharEncoding v6 = "Unexpected end tag : %s\n";
            a1 = v1;
            int v7 = 76;
            BOOL v8 = v5;
            goto LABEL_12;
          }

          uint64_t v10 = nameNr - 1;
          int v11 = xmlStrEqual(v5, v1->nameTab[nameNr - 1]);
          uint64_t nameNr = v10;
        }

        while (!v11);
        int EndPriority = htmlGetEndPriority(v5);
        uint64_t v13 = v1->nameNr - 1LL;
        while ((int)v13 + 1 >= 1)
        {
          if (xmlStrEqual(v5, v1->nameTab[v13]))
          {
            while (!xmlStrEqual(v5, v1->name))
            {
              name = v1->name;
              if (name)
              {
                BOOL v16 = bsearch( name,  &html40ElementTable,  0x5CuLL,  0x40uLL,  (int (__cdecl *)(const void *, const void *))htmlCompareTags);
                if (v16)
                {
                  if (v16[9] == 3) {
                    htmlParseErr(v1, 76, "Opening and ending tag mismatch: %s and %s\n", v5, (xmlChar *)v1->name);
                  }
                }
              }

              if (v1->sax)
              {
                endElementSAXFunc endElement = (void (*)(void *, const xmlChar *))v1->sax->endElement;
                if (endElement) {
                  endElement(v1->userData, v1->name);
                }
              }

              int v18 = v1->nameNr;
              unsigned int v19 = v18 - 1;
              if (v18 >= 1)
              {
                v1->uint64_t nameNr = v19;
                nameTab = v1->nameTab;
                if (v18 == 1) {
                  char v21 = 0LL;
                }
                else {
                  char v21 = nameTab[v18 - 2];
                }
                v1->name = v21;
                nameTab[v19] = 0LL;
              }
            }

            break;
          }

          int v14 = htmlGetEndPriority((xmlChar *)v1->nameTab[v13--]);
          if (v14 > EndPriority) {
            break;
          }
        }

        uint64_t result = (xmlChar *)v1->name;
        if (result)
        {
          if (!xmlStrEqual(result, v5)) {
            htmlParseErr(v1, 76, "Opening and ending tag mismatch: %s and %s\n", v5, (xmlChar *)v1->name);
          }
          uint64_t result = (xmlChar *)v1->name;
          if (result)
          {
            uint64_t result = (xmlChar *)xmlStrEqual(result, v5);
            if ((_DWORD)result)
            {
              if (v1->sax)
              {
                int v22 = (void (*)(void *, xmlChar *))v1->sax->endElement;
                if (v22) {
                  v22(v1->userData, v5);
                }
              }

              int nodeInfoNr = v1->nodeInfoNr;
              if (nodeInfoNr >= 1)
              {
                int v24 = nodeInfoNr - 2;
                int v26 = nodeInfoNr - 1;
                BOOL v25 = v26 == 0;
                v1->int nodeInfoNr = v26;
                uint64_t v27 = (uint64_t)&v1->nodeInfoTab[v24];
                if (v25) {
                  uint64_t v27 = 0LL;
                }
                v1->nodeInfo = (xmlParserNodeInfo *)v27;
              }

              int v28 = v1->nameNr;
              unsigned int v29 = v28 - 1;
              if (v28 >= 1)
              {
                v1->uint64_t nameNr = v29;
                unsigned int v30 = v1->nameTab;
                if (v28 == 1) {
                  uint64_t v31 = 0LL;
                }
                else {
                  uint64_t v31 = v30[v28 - 2];
                }
                v1->name = v31;
                v30[v29] = 0LL;
              }

              return (xmlChar *)1;
            }
          }
        }
      }
    }
  }

  else
  {
    xmlCharEncoding v6 = "htmlParseEndTag: '</' not found\n";
    int v7 = 74;
    BOOL v8 = 0LL;
LABEL_12:
    htmlParseErr(a1, v7, v6, v8, 0LL);
    return 0LL;
  }

  return result;
}

const xmlChar *htmlParseHTMLName_nonInvasive(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v1 = *(void *)(*(void *)(a1 + 56) + 32LL);
  int v2 = *(unsigned __int8 *)(v1 + 1);
  if ((v2 & 0xFFFFFFDF) - 65 < 0x1A || v2 == 95 || v2 == 58)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = v1 + 1;
    while (1)
    {
      int v5 = *(unsigned __int8 *)(v4 + v3);
      if ((v5 - 65) >= 0x1A)
      {
        if ((v5 - 97) >= 0x1A
          && (v5 - 48) >= 0xA
          && ((v5 - 45) > 0x32 || ((1LL << (v5 - 45)) & 0x4000000002001LL) == 0))
        {
          return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)v9, v3);
        }
      }

      else
      {
        LOBYTE(v5) = v5 + 32;
      }

      *((_BYTE *)v9 + v3++) = v5;
      if (v3 == 100) {
        return xmlDictLookup(*(xmlDictPtr *)(a1 + 456), (const xmlChar *)v9, v3);
      }
    }
  }

  return 0LL;
}

uint64_t htmlParseScript(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  bzero(v20, 0x3EDuLL);
  int v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (cur - v2->base >= 501 && v2->end - cur <= 499) {
    xmlParserInputShrink(v2);
  }
  int len = 0;
  uint64_t result = htmlCurrentChar(a1, &len);
  int v5 = result;
  uint64_t v6 = 0LL;
  while (1)
  {
    if (v5 != 60)
    {
      if (!v5) {
        break;
      }
      if (v5 > 255)
      {
        if ((v5 - 0x10000) >= 0x100000
          && v5 >> 11 >= 0x1B
          && (v5 - 57344) >> 1 > 0xFFE)
        {
LABEL_19:
          htmlParseErrInt((_DWORD *)a1, "Invalid char in CDATA 0x%X\n", v5);
          int v11 = len;
          goto LABEL_24;
        }
      }

      else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
      {
        goto LABEL_19;
      }

      goto LABEL_21;
    }

    uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 32LL);
    if (*(_BYTE *)(v7 + 1) == 47)
    {
      if (*(_DWORD *)(a1 + 448))
      {
        BOOL v8 = *(const xmlChar **)(a1 + 288);
        int v9 = (const xmlChar *)(v7 + 2);
        int v10 = xmlStrlen(v8);
        uint64_t result = xmlStrncasecmp(v8, v9, v10);
        if (!(_DWORD)result) {
          break;
        }
        htmlParseErr((_DWORD *)a1, 76, "Element %s embeds close tag\n", *(const xmlChar **)(a1 + 288), 0LL);
        goto LABEL_21;
      }

      if ((*(_BYTE *)(v7 + 2) & 0xDFu) - 65 < 0x1A) {
        break;
      }
    }

LABEL_21:
    int v11 = len;
    if (len == 1)
    {
      v20[(int)v6] = v5;
      uint64_t v6 = (v6 + 1);
    }

    else
    {
      uint64_t v6 = (xmlCopyChar(len, &v20[(int)v6], v5) + v6);
    }

  parent = children;
  children = children->children;
  if (!children) {
    goto LABEL_22;
  }
LABEL_27:
  while (2)
  {
    if (children->type != XML_ELEMENT_NODE) {
      goto LABEL_30;
    }
    int v11 = children->name;
    if (!v11) {
      goto LABEL_30;
    }
    if (xmlStrcasecmp(v11, (const xmlChar *)"meta")) {
      goto LABEL_30;
    }
    properties = children->properties;
    if (!properties) {
      goto LABEL_30;
    }
    uint64_t v13 = 0;
    int v14 = 0LL;
    while (2)
    {
      int v15 = properties->children;
      if (!v15 || v15->type != XML_TEXT_NODE || v15->next) {
        goto LABEL_44;
      }
      content = v15->content;
      if (!xmlStrcasecmp(properties->name, (const xmlChar *)"http-equiv")
        && !xmlStrcasecmp(content, (const xmlChar *)"Content-Type"))
      {
        uint64_t v13 = 1;
        break;
      }

      if (content && !xmlStrcasecmp(properties->name, (const xmlChar *)"content")) {
        int v14 = content;
      }
      if (!v13)
      {
LABEL_44:
        properties = properties->next;
        if (!properties) {
          goto LABEL_48;
        }
        continue;
      }

      break;
    }

    if (!v14) {
      goto LABEL_44;
    }
    uint64_t v13 = 1;
LABEL_48:
    if (v13 && v14)
    {
      if (encoding)
      {
        if (!xmlStrcasestr(v14, encoding)) {
          xmlSetProp(children, (const xmlChar *)"content", (const xmlChar *)__str);
        }
      }

      else
      {
        xmlUnlinkNode(children);
        xmlFreeNode(children);
      }

      return 0;
    }

      v4[108] = v7;
      break;
    case 3:
      BOOL v8 = v4[141];
      uint64_t result = 0;
      if (value)
      {
        v4[141] = v8 | 0x10;
        v4[39] = 1;
        *((_DWORD *)reader + 4) = 1;
      }

      else
      {
        v4[141] = v8 & 0xFFFFFFEF;
        v4[39] = 0;
      }

      return result;
    case 4:
      int v9 = v4[141];
      uint64_t result = 0;
      if (value)
      {
        v4[141] = v9 | 2;
        v4[7] = 1;
      }

      else
      {
        v4[141] = v9 & 0xFFFFFFFD;
        v4[7] = 0;
      }

      return result;
    default:
      return -1;
  }

  return result;
}

  uint64_t v4 = *(void *)(result + 48);
  if (v4)
  {
    if (*(_DWORD *)(v4 + 4) != 3) {
      goto LABEL_39;
    }
    switch(v9)
    {
      case 't':
        int v9 = 9;
        break;
      case 'r':
        int v9 = 13;
        break;
      case 'n':
        int v9 = 10;
        break;
    }

    int v5 = *(_DWORD *)(result + 20);
    uint64_t v6 = 2;
    uint64_t v7 = v9;
    BOOL v8 = v9;
    goto LABEL_38;
  }

  uint64_t result = (uint64_t)xmlRegNewAtom(result, 2);
  *(void *)(v1 + 48) = result;
  if (!result) {
    goto LABEL_39;
  }
  switch(v9)
  {
    case 't':
      uint64_t v13 = 9;
      goto LABEL_45;
    case 'r':
      uint64_t v13 = 13;
      goto LABEL_45;
    case 'n':
      uint64_t v13 = 10;
LABEL_45:
      *(_DWORD *)(result + 44) = v13;
      goto LABEL_39;
  }

  *(_DWORD *)(result + 44) = v9;
LABEL_39:
  int v14 = *(_BYTE **)(v1 + 8);
LABEL_40:
  *(void *)(v1 + 8) = v14 + 1;
  return result;
}

  uint64_t v17 = (int *)typeDecl->baseType;
  uint64_t v58 = 0LL;
  if (!v17)
  {
    unsigned int v23 = "No base type existent";
LABEL_33:
    int v24 = ctxt;
    BOOL v25 = 3008;
LABEL_34:
    xmlSchemaPCustomErrExt((uint64_t)v24, v25, typeDecl, 0LL, (const xmlChar *)v23);
    goto LABEL_58;
  }

  int v18 = *v17;
  if (*v17 != 4 && (v18 != 1 || v17[40] == 45))
  {
    xmlSchemaGetComponentQName(&v58, v17);
    unsigned int v19 = "The base type '%s' is not a simple type";
LABEL_55:
    unsigned int v30 = ctxt;
    uint64_t v31 = 3008;
    goto LABEL_56;
  }

  int v26 = typeDecl->flags;
  if ((v26 & 0xC0) != 0 && (v26 & 4) == 0 && v18 != 4 && (v18 != 1 || v17[40] != 46))
  {
    xmlSchemaGetComponentQName(&v58, v17);
    unsigned int v19 = "A type, derived by list or union, must have the simple ur-type definition as base type, not '%s'";
    goto LABEL_55;
  }

  if ((v26 & 0x1C0) == 0)
  {
    unsigned int v23 = "The variety is absent";
    goto LABEL_33;
  }

  uint64_t v27 = v17[22];
  if ((v27 & 0x400) != 0)
  {
    xmlSchemaGetComponentQName(&v58, v17);
    unsigned int v19 = "The 'final' of its base type '%s' must not contain 'restriction'";
    unsigned int v30 = ctxt;
    uint64_t v31 = 3010;
    goto LABEL_56;
  }

  uint64_t v58 = 0LL;
  if (typeDecl->type != XML_SCHEMA_TYPE_SIMPLE)
  {
    uint64_t v20 = "xmlSchemaCheckCOSSTRestricts";
    uint64_t v21 = "given type is not a user-derived simpleType";
    goto LABEL_27;
  }

  if ((v26 & 0x100) != 0)
  {
    if ((v27 & 0x100) != 0)
    {
      facets = typeDecl->facets;
      if (facets)
      {
        uint64_t v21 = "failed to get primitive type";
        int v35 = typeDecl;
        while (v35->builtInType != 46 && (v35->flags & 0x4000) == 0)
        {
          int v35 = v35->baseType;
          if (!v35) {
            goto LABEL_76;
          }
        }

        BOOL v36 = 0;
        do
        {
          while (!xmlSchemaIsBuiltInTypeFacet(v35, facets->type))
          {
            xmlSchemaPIllegalFacetAtomicErr((uint64_t)ctxt, (uint64_t)typeDecl, (uint64_t)v35, (int *)facets);
            facets = facets->next;
            BOOL v36 = 1;
            if (!facets) {
              goto LABEL_58;
            }
          }

          facets = facets->next;
        }

        while (facets);
        if ((v36 & 1) != 0) {
          goto LABEL_58;
        }
      }

      goto LABEL_84;
    }

    xmlSchemaGetComponentQName(&v58, v17);
    unsigned int v19 = "The base type '%s' is not an atomic simple type";
    unsigned int v30 = ctxt;
    uint64_t v31 = 3011;
LABEL_56:
    xmlSchemaPCustomErrExt((uint64_t)v30, v31, typeDecl, 0LL, (const xmlChar *)v19);
    xmlChar v32 = v58;
    if (!v58) {
      goto LABEL_58;
    }
    goto LABEL_57;
  }

  if ((v26 & 0x40) != 0)
  {
    subtypes = typeDecl->subtypes;
    if (subtypes)
    {
      if (subtypes->type == XML_SCHEMA_TYPE_SIMPLE)
      {
        if ((subtypes->flags & 0x400000) == 0) {
          xmlSchemaTypeFixup((uint64_t)typeDecl->subtypes, ctxt);
        }
      }

      else if (subtypes->type != XML_SCHEMA_TYPE_BASIC || subtypes->builtInType == 45)
      {
        goto LABEL_70;
      }

      __int128 v40 = subtypes->flags;
      if ((v40 & 0x180) != 0)
      {
        if ((v40 & 0x80) == 0)
        {
LABEL_104:
          __int128 v41 = typeDecl->baseType;
          if (v41->type == XML_SCHEMA_TYPE_BASIC && v41->builtInType == 46)
          {
            if ((v40 & 0x800) == 0)
            {
              for (uint64_t i = typeDecl->facets; i; uint64_t i = i->next)
              {
                if (i->type != XML_SCHEMA_FACET_WHITESPACE)
                {
                  xmlSchemaPIllegalFacetListUnionErr((uint64_t)ctxt, 3017, (uint64_t)typeDecl, (int *)i);
                  goto LABEL_58;
                }
              }

              goto LABEL_84;
            }

            xmlSchemaGetComponentQName(&v58, (int *)subtypes);
            unsigned int v19 = "The final of its item type '%s' must not contain 'list'";
            unsigned int v30 = ctxt;
            uint64_t v31 = 3016;
            goto LABEL_56;
          }

          int v43 = v41->flags;
          if ((v43 & 0x40) == 0)
          {
            xmlSchemaGetComponentQName(&v58, (int *)v41);
            unsigned int v19 = "The base type '%s' must be a list type";
            unsigned int v30 = ctxt;
            uint64_t v31 = 3018;
            goto LABEL_56;
          }

          if ((v43 & 0x400) != 0)
          {
            xmlSchemaGetComponentQName(&v58, (int *)v41);
            unsigned int v19 = "The 'final' of the base type '%s' must not contain 'restriction'";
            unsigned int v30 = ctxt;
            uint64_t v31 = 3019;
            goto LABEL_56;
          }

          int v51 = (int *)v41->subtypes;
          if (v51 && (*v51 == 4 || *v51 == 1 && v51[40] != 45))
          {
            if (subtypes != (xmlSchemaTypePtr)v51
              && xmlSchemaCheckCOSSTDerivedOK(ctxt, (uint64_t)subtypes, (uint64_t)v51, 0))
            {
              uint64_t v56 = 0LL;
              uint64_t v57 = 0LL;
              xmlSchemaGetComponentQName(&v58, (int *)subtypes);
              xmlSchemaGetComponentQName(&v57, v51);
              xmlSchemaGetComponentQName(&v56, (int *)typeDecl->baseType);
              unsigned int v52 = "The item type '%s' is not validly derived from the item type '%s' of the base type '%s'";
              int v53 = ctxt;
              int v54 = 3020;
              goto LABEL_156;
            }

            BOOL v55 = typeDecl->facets;
            if (v55)
            {
              int v50 = 0;
              do
              {
                while (v55->type - 1006 > 5)
                {
                  xmlSchemaPIllegalFacetListUnionErr((uint64_t)ctxt, 3021, (uint64_t)typeDecl, (int *)v55);
                  BOOL v55 = v55->next;
                  int v50 = 1;
                  if (!v55) {
                    goto LABEL_58;
                  }
                }

                BOOL v55 = v55->next;
              }

              while (v55);
LABEL_169:
              if ((v50 & 1) != 0) {
                goto LABEL_58;
              }
            }

            goto LABEL_84;
          }

          uint64_t v21 = "failed to eval the item type of a base type";
          goto LABEL_76;
        }

        uint64_t v44 = &subtypes->memberTypes;
        do
        {
          uint64_t v44 = (xmlSchemaTypeLinkPtr *)*v44;
          if (!v44) {
            goto LABEL_104;
          }
          int v45 = v44[1];
        }

        while ((BYTE1(v45[5].type) & 1) != 0);
        xmlSchemaGetComponentQName(&v58, (int *)v45);
        unsigned int v19 = "The item type is a union type, but the member type '%s' of this item type is not atomic";
      }

      else
      {
        xmlSchemaGetComponentQName(&v58, (int *)subtypes);
        unsigned int v19 = "The item type '%s' does not have a variety of atomic or union";
      }

      unsigned int v30 = ctxt;
      uint64_t v31 = 3015;
      goto LABEL_56;
    }

  if (!v3) {
    return 0LL;
  }
  int v10 = a2 + 1;
  while (v3 <= 0x20)
  {
    if (((1LL << v3) & 0x100002600LL) == 0)
    {
      if (v3) {
        break;
      }
      return 0LL;
    }

    int v11 = *v10++;
    uint64_t v3 = v11;
  }

uint64_t htmlParseReference(uint64_t ctxt)
{
  __int16 v21 = 0;
  int v20 = 0;
  str = 0LL;
  uint64_t v1 = *(_BYTE **)(*(void *)(ctxt + 56) + 32LL);
  if (*v1 != 38) {
    return ctxt;
  }
  int v2 = (void *)ctxt;
  if (v1[1] == 35)
  {
    ctxt = htmlParseCharRef((htmlParserCtxtPtr)ctxt);
    if (!(_DWORD)ctxt) {
      return ctxt;
    }
    if (ctxt >= 0x80)
    {
      if (ctxt > 0x7FF)
      {
        if (WORD1(ctxt))
        {
          LOBYTE(v20) = (ctxt >> 18) & 7 | 0xF0;
          unsigned int v3 = 12;
        }

        else
        {
          LOBYTE(v20) = (ctxt >> 12) | 0xE0;
          unsigned int v3 = 6;
        }
      }

      else
      {
        unsigned int v3 = 0;
        LOBYTE(v20) = (ctxt >> 6) | 0xC0;
      }

      uint64_t v17 = 1LL;
      do
      {
        *((_BYTE *)&v20 + v17++) = (ctxt >> v3) & 0x3F | 0x80;
        BOOL v18 = v3 > 5;
        v3 -= 6;
      }

      while (v18);
      goto LABEL_33;
    }

    LOBYTE(v20) = ctxt;
    goto LABEL_23;
  }

  uint64_t v4 = htmlParseEntityRef((htmlParserCtxtPtr)ctxt, (const xmlChar **)&str);
  if (str)
  {
    if (!v4 || (unsigned int value = v4->value) == 0)
    {
      ctxt = htmlCheckParagraph((uint64_t)v2);
      if (*v2)
      {
        uint64_t v7 = *(void (**)(void, const char *, uint64_t))(*v2 + 136LL);
        if (v7)
        {
          v7(v2[1], "&", 1LL);
          uint64_t v8 = *v2;
          uint64_t v9 = v2[1];
          int v10 = *(uint64_t (**)(uint64_t, xmlChar *, uint64_t))(v8 + 136);
          int v11 = str;
          uint64_t v12 = xmlStrlen(str);
          return v10(v9, v11, v12);
        }
      }

      return ctxt;
    }

    if (value >= 0x80)
    {
      if (value > 0x7FF)
      {
        if (HIWORD(value))
        {
          LOBYTE(v20) = (value >> 18) & 7 | 0xF0;
          unsigned int v6 = 12;
        }

        else
        {
          LOBYTE(v20) = (value >> 12) | 0xE0;
          unsigned int v6 = 6;
        }
      }

      else
      {
        unsigned int v6 = 0;
        LOBYTE(v20) = (value >> 6) | 0xC0;
      }

      uint64_t v17 = 1LL;
      do
      {
        *((_BYTE *)&v20 + v17++) = (value >> v6) & 0x3F | 0x80;
        BOOL v18 = v6 > 5;
        v6 -= 6;
      }

      while (v18);
LABEL_33:
      *((_BYTE *)&v20 + v17) = 0;
      ctxt = htmlCheckParagraph((uint64_t)v2);
      if (*v2)
      {
        uint64_t v13 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(*v2 + 136LL);
        if (v13)
        {
          uint64_t v14 = v2[1];
          int v15 = (const char *)&v20;
          uint64_t v16 = v17;
          return v13(v14, v15, v16);
        }
      }

      return ctxt;
    }

    LOBYTE(v20) = v4->value;
LABEL_23:
    uint64_t v17 = 1LL;
    goto LABEL_33;
  }

  ctxt = htmlCheckParagraph((uint64_t)v2);
  if (*v2)
  {
    uint64_t v13 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(*v2 + 136LL);
    if (v13)
    {
      uint64_t v14 = v2[1];
      int v15 = "&";
      uint64_t v16 = 1LL;
      return v13(v14, v15, v16);
    }
  }

  return ctxt;
}

uint64_t htmlParseCharData(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  bzero(v22, 0x3EEuLL);
  int v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  if (cur - v2->base >= 501 && v2->end - cur <= 499) {
    xmlParserInputShrink(v2);
  }
  int len = 0;
  uint64_t result = htmlCurrentChar(a1, &len);
  int v5 = result;
  uint64_t v6 = 0LL;
  int v7 = 0;
  while (1)
  {
    if (v5 == 38)
    {
      if (*(_DWORD *)(a1 + 276) != 38) {
        goto LABEL_56;
      }
      goto LABEL_16;
    }

    if (v5 == 60)
    {
      if (*(_DWORD *)(a1 + 276) != 60)
      {
LABEL_56:
        if (!(_DWORD)v6) {
          return result;
        }
        goto LABEL_59;
      }

      goto LABEL_16;
    }

    if (!v5) {
      break;
    }
    if (v5 > 255)
    {
      if ((v5 - 0x10000) >= 0x100000
        && v5 >> 11 >= 0x1B
        && (v5 - 57344) >> 1 >= 0xFFF)
      {
LABEL_29:
        htmlParseErrInt((_DWORD *)a1, "Invalid char in CDATA 0x%X\n", v5);
        int v8 = len;
        goto LABEL_34;
      }
    }

    else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
    {
      goto LABEL_29;
    }

LABEL_59:
  v22[(int)v6] = 0;
  if (!*(void *)a1 || *(_DWORD *)(a1 + 332)) {
    return result;
  }
  uint64_t result = areBlanks(a1, v22, v6);
  if (!(_DWORD)result)
  {
    uint64_t result = htmlCheckParagraph(a1);
    uint64_t v19 = *(void *)a1;
LABEL_67:
    int v20 = *(uint64_t (**)(void, unsigned __int8 *, uint64_t))(v19 + 136);
    if (v20) {
      return v20(*(void *)(a1 + 8), v22, v6);
    }
    return result;
  }

  uint64_t v19 = *(void *)a1;
  if (*(_DWORD *)(a1 + 328)) {
    goto LABEL_67;
  }
  int v20 = *(uint64_t (**)(void, unsigned __int8 *, uint64_t))(v19 + 144);
  if (!v20) {
    return result;
  }
  return v20(*(void *)(a1 + 8), v22, v6);
}

                    LODWORD(lang) = 1;
                    return (int)lang;
                  }

                  uint64_t v16 = 0LL;
                  do
                    int v10 = v9[++v16];
                  while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
                  if (v16 == 3)
                  {
                    v9 += 3;
                    goto LABEL_53;
                  }
                }
              }
            }
          }
        }
      }

                *((_DWORD *)a1 + 141) |= 0x400000u;
                a2 = (a2 - 0x400000);
                goto LABEL_60;
              }
            }

            else if ((a2 & 0x200000) == 0)
            {
              goto LABEL_58;
            }

            *((_DWORD *)a1 + 141) |= 0x200000u;
            a2 = (a2 - 0x200000);
            if ((a2 & 0x400000) == 0) {
              goto LABEL_60;
            }
            goto LABEL_59;
          }
        }

        else if ((a2 & 0x200) == 0)
        {
          goto LABEL_35;
        }

        uint64_t v14 = *a1;
        *(void *)(v14 + 112) = xmlSAX2StartElement;
        *(void *)(v14 + 120) = xmlSAX2EndElement;
        *(void *)(v14 + 232) = 0LL;
        *(void *)(v14 + 240) = 0LL;
        *(_DWORD *)(v14 + 216) = 1;
        a2 = (a2 - 512);
        *((_DWORD *)a1 + 141) |= 0x200u;
        if ((a2 & 0x1000) == 0) {
          goto LABEL_36;
        }
        goto LABEL_39;
      }
    }

    else
    {
      *((_DWORD *)a1 + 39) = 0;
      if ((a2 & 0x40) == 0) {
        goto LABEL_33;
      }
    }

    *(void *)(*a1 + 168) = 0LL;
    a2 = (a2 - 64);
    goto LABEL_33;
  }

  return 0xFFFFFFFFLL;
}

        __int128 v41 = *(_DWORD *)v9 != 6;
        if (v6 && v47 > 0)
        {
          if (v47 <= v5)
          {
            __int128 v42 = (char *)xmlRealloc(v6, 16LL * (2 * v47));
            if (!v42) {
              goto LABEL_89;
            }
            v47 *= 2;
            uint64_t v6 = v42;
          }
        }

        else
        {
          uint64_t v6 = (char *)xmlMalloc(0x40uLL);
          int v5 = 0;
          int v47 = 4;
        }

        int v46 = &v6[16 * v5];
        *(_DWORD *)int v46 = v7 - v41;
        ++v5;
        *((void *)v46 + 1) = v4;
LABEL_89:
        LODWORD(v7) = v7 + 1;
LABEL_94:
        if (v6) {
LABEL_95:
        }
          xmlFree(v6);
        return 1;
      case 7:
        if (v4->type != XML_ELEMENT_NODE) {
          goto LABEL_71;
        }
        int v43 = v4->ns;
        if (v43)
        {
          href = v43->href;
          if (!href) {
            goto LABEL_89;
          }
          uint64_t v19 = *(const xmlChar **)(v8 + 24LL * (int)v7 + 8);
          if (!v19) {
            goto LABEL_71;
          }
          goto LABEL_68;
        }

        goto LABEL_89;
      case 8:
        if (v4->type != XML_ELEMENT_NODE) {
          goto LABEL_71;
        }
        goto LABEL_89;
      default:
        goto LABEL_89;
    }
  }

      uint64_t v9 = children;
      if (!children) {
        goto LABEL_60;
      }
    }
  }

  return result;
}

    stringval = v26->stringval;
    if (!stringval) {
      goto LABEL_115;
    }
    int v33 = (uint64_t)v77;
    if (!v77) {
      goto LABEL_115;
    }
LABEL_61:
    if (*(_DWORD *)(v33 + 8) == 18) {
      goto LABEL_115;
    }
    size_t v34 = v78 - 1;
    int v35 = *stringval;
    BOOL v36 = v33;
    while (1)
    {
      if (*(_DWORD *)(v36 + 8) != 1)
      {
        __int128 v37 = *(const xmlChar **)(v36 + 80);
        if (v37)
        {
          int v38 = xmlStrlen(v37);
          if (v34 <= v38)
          {
            if (!v35)
            {
              xmlXPathObjectPtr v77 = (xmlNode *)v36;
              int v47 = ++v34;
              int v33 = v36;
              goto LABEL_95;
            }

            __int128 v39 = v38;
            xmlParserInputPtr v68 = v38 + 1;
            unsigned int v73 = stringval;
            __int128 v72 = v35;
LABEL_72:
            __int128 v40 = xmlStrchr((const xmlChar *)(*(void *)(v36 + 80) + v34), v35);
            if (v40)
            {
              __int128 v41 = (_DWORD)v40 - *(_DWORD *)(v36 + 80);
              size_t v34 = v41 + 1;
              __int128 v42 = *(_DWORD *)(v36 + 8);
              if (v42 == 18 || v21 == 0)
              {
                if (v42 == 18) {
                  int v33 = v21;
                }
                else {
                  int v33 = 0LL;
                }
                int v47 = v74;
              }

              else
              {
                if (*(_DWORD *)(v21 + 8) != 18)
                {
                  uint64_t v44 = xmlStrlen(stringval);
                  int v45 = stringval;
                  int v33 = v36;
                  int v46 = v41;
                  while (v44 >= 1)
                  {
                    int v47 = v44 + v46;
                    if (v33 == v21 && v47 > v74) {
                      goto LABEL_90;
                    }
                    if (*(_DWORD *)(v33 + 8) != 1)
                    {
                      int v48 = *(const xmlChar **)(v33 + 80);
                      if (v48)
                      {
                        int v49 = xmlStrlen(v48);
                        if (v49 >= v47)
                        {
                          if (!xmlStrncmp((const xmlChar *)(*(void *)(v33 + 80) + v46), v45, v44)) {
                            goto LABEL_94;
                          }
LABEL_90:
                          stringval = v73;
                          int v35 = v72;
                          if (v39 > v41) {
                            goto LABEL_72;
                          }
                          goto LABEL_66;
                        }

                        int v50 = v49 - (uint64_t)v46;
                        if (xmlStrncmp((const xmlChar *)(*(void *)(v33 + 80) + v46), v45, v50)) {
                          goto LABEL_90;
                        }
                        v45 += v50;
                        v44 -= v50;
                      }
                    }

                    int v33 = xmlXPtrAdvanceNode(v33, 0LL);
                    int v46 = 0;
                    if (!v33) {
                      goto LABEL_90;
                    }
                  }
                }

                int v47 = v74;
                int v33 = v21;
              }

uint64_t htmlGetEndPriority(xmlChar *str2)
{
  uint64_t v2 = 0LL;
  unsigned int v3 = (const xmlChar *)"div";
  uint64_t v4 = &off_189BA2398;
  do
  {
    if (xmlStrEqual(v3, str2)) {
      break;
    }
    ++v2;
    int v5 = *v4;
    v4 += 2;
    unsigned int v3 = (const xmlChar *)v5;
  }

  while (v2 != 11);
  return LODWORD((&htmlEndPriority)[2 * v2 + 1]);
}

uint64_t htmlCheckParagraph(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(const xmlChar **)(result + 288);
  if (v2)
  {
    if (!htmlOmittedDefaultValue) {
      return result;
    }
    uint64_t v3 = 0LL;
    while (1)
    {
      uint64_t result = xmlStrEqual(v2, (const xmlChar *)htmlNoContentElements[v3]);
      if ((_DWORD)result) {
        break;
      }
      if (++v3 == 2) {
        return result;
      }
    }
  }

  htmlAutoClose((int *)v1, (uint64_t)"p");
  htmlCheckImplied(v1, (xmlChar *)"p");
  uint64_t result = (uint64_t)htmlnamePush(v1, (xmlChar *)"p");
  if (*(void *)v1)
  {
    uint64_t v4 = *(uint64_t (**)(void, const char *, void))(*(void *)v1 + 112LL);
    if (v4) {
      return v4(*(void *)(v1 + 8), "p", 0LL);
    }
  }

  return result;
}

uint64_t areBlanks(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v4 = a3;
    do
    {
      unsigned int v5 = *a2++;
      uint64_t v6 = (1LL << v5) & 0x100002600LL;
      if (v5 > 0x20 || v6 == 0) {
        return 0LL;
      }
    }

    while (--v4);
  }

  if (!**(_BYTE **)(*(void *)(a1 + 56) + 32LL)) {
    return 1LL;
  }
  if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) != 60) {
    return 0LL;
  }
  int v8 = *(const xmlChar **)(a1 + 288);
  if (!v8) {
    return 1LL;
  }
  if (xmlStrEqual(v8, (const xmlChar *)"html")) {
    return 1LL;
  }
  if (xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)"head")) {
    return 1LL;
  }
  if (xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)"body"))
  {
    int v10 = *(const xmlDoc **)(a1 + 16);
    if (v10)
    {
      xmlDtdPtr IntSubset = xmlGetIntSubset(v10);
      if (IntSubset)
      {
        xmlDtdPtr v12 = IntSubset;
        ExternalID = IntSubset->ExternalID;
        if (ExternalID)
        {
          if (!xmlStrcasecmp(ExternalID, (const xmlChar *)"-//W3C//DTD HTML 4.01//EN")
            || !xmlStrcasecmp(v12->ExternalID, (const xmlChar *)"-//W3C//DTD HTML 4//EN"))
          {
            return 1LL;
          }
        }
      }
    }
  }

  uint64_t result = *(void *)(a1 + 80);
  if (!result) {
    return result;
  }
  xmlNodePtr LastChild = xmlGetLastChild((const xmlNode *)result);
  if (LastChild)
  {
    xmlNodePtr v15 = LastChild;
    while (v15->type == XML_COMMENT_NODE)
    {
      xmlNodePtr v15 = v15->prev;
      if (!v15) {
        goto LABEL_25;
      }
    }

    if (!xmlNodeIsText(v15))
    {
      uint64_t v18 = 0LL;
      while (!xmlStrEqual(v15->name, (const xmlChar *)allowPCData[v18]))
      {
        ++v18;
        uint64_t result = 1LL;
        if (v18 == 53) {
          return result;
        }
      }
    }
  }

  else
  {
LABEL_25:
    uint64_t v16 = *(void *)(a1 + 80);
    if (*(_DWORD *)(v16 + 8) == 1 || !*(void *)(v16 + 80))
    {
      uint64_t v17 = 0LL;
      while (!xmlStrEqual(*(const xmlChar **)(a1 + 288), (const xmlChar *)allowPCData[v17]))
      {
        ++v17;
        uint64_t result = 1LL;
        if (v17 == 53) {
          return result;
        }
      }
    }
  }

  return 0LL;
}

void htmlParserFinishElementParsing(xmlParserCtxtPtr ctxt)
{
  xmlNodePtr node = ctxt->node;
  if (node)
  {
    if (ctxt->record_info)
    {
      xmlParserInputPtr input = ctxt->input;
      unint64_t v4 = &input->cur[input->consumed] - input->base;
      nodeInfo = ctxt->nodeInfo;
      unint64_t line = input->line;
      nodeInfo->end_pos = v4;
      nodeInfo->end_unint64_t line = line;
      nodeInfo->xmlNodePtr node = node;
      xmlParserAddNodeInfo(ctxt, nodeInfo);
      int nodeInfoNr = ctxt->nodeInfoNr;
      if (nodeInfoNr >= 1)
      {
        int v8 = nodeInfoNr - 2;
        int v10 = nodeInfoNr - 1;
        BOOL v9 = v10 == 0;
        ctxt->int nodeInfoNr = v10;
        int v11 = &ctxt->nodeInfoTab[v8];
        if (v9) {
          int v11 = 0LL;
        }
        ctxt->nodeInfo = v11;
      }
    }
  }

  if (!*ctxt->input->cur) {
    htmlAutoCloseOnEnd((uint64_t)ctxt);
  }
}

_DWORD *htmlNodeInfoPush(uint64_t a1, __int128 *a2)
{
  int v4 = *(_DWORD *)(a1 + 720);
  int v5 = *(_DWORD *)(a1 + 724);
  if (v4 < v5)
  {
    uint64_t result = *(_DWORD **)(a1 + 728);
LABEL_7:
    int v8 = &result[10 * v4];
    __int128 v9 = *a2;
    __int128 v10 = a2[1];
    *((void *)v8 + 4) = *((void *)a2 + 4);
    *(_OWORD *)int v8 = v9;
    *((_OWORD *)v8 + 1) = v10;
    int v11 = *(_DWORD *)(a1 + 720);
    *(void *)(a1 + 712) = *(void *)(a1 + 728) + 40LL * v11;
    *(_DWORD *)(a1 + 720) = v11 + 1;
    return result;
  }

  int v7 = 2 * v5;
  if (!v5) {
    int v7 = 10;
  }
  *(_DWORD *)(a1 + 724) = v7;
  uint64_t result = xmlRealloc(*(void **)(a1 + 728), 40LL * v7);
  *(void *)(a1 + 728) = result;
  if (result)
  {
    int v4 = *(_DWORD *)(a1 + 720);
    goto LABEL_7;
  }

  return htmlErrMemory((_DWORD *)a1, 0LL);
}

xmlChar *htmlParseSystemLiteral(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1 = ctxt;
  int v2 = *ctxt->input->cur;
  if (v2 != 34 && v2 != 39)
  {
    __int128 v9 = "SystemLiteral  or ' expected\n";
    int v10 = 43;
LABEL_29:
    htmlParseErr(ctxt, v10, v9, 0LL, 0LL);
    return 0LL;
  }

  xmlNextChar(ctxt);
  xmlParserInputPtr input = v1->input;
  unint64_t base = (unint64_t)input->base;
  cur = input->cur;
  unint64_t v6 = (unint64_t)&cur[-base];
  if ((unint64_t)cur >= base)
  {
    unsigned int v7 = *cur;
    if (*cur) {
      BOOL v8 = v7 == v2;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8)
    {
      if (v7 == v2)
      {
        int v12 = 0;
        goto LABEL_32;
      }
    }

    else
    {
      int v11 = 0;
      int v12 = 0;
      do
      {
        if (v7 - 9 >= 2 && v7 != 13 && v7 <= 0x1F)
        {
          htmlParseErrInt(v1, "Invalid char in SystemLiteral 0x%X\n", v7);
          int v11 = 1;
        }

        xmlNextChar(v1);
        ++v12;
        xmlParserInputPtr input = v1->input;
        xmlNodePtr v15 = input->cur;
        unsigned int v7 = *v15;
        if (*v15) {
          BOOL v16 = v7 == v2;
        }
        else {
          BOOL v16 = 1;
        }
      }

      while (!v16);
      if (v7 == v2)
      {
        if (v11)
        {
          uint64_t v17 = 0LL;
LABEL_33:
          xmlNextChar(v1);
          return v17;
        }

xmlChar *htmlParsePubidLiteral(xmlParserCtxtPtr ctxt)
{
  xmlParserCtxtPtr v1 = ctxt;
  int v2 = *ctxt->input->cur;
  if (v2 != 34 && v2 != 39)
  {
    __int128 v9 = "PubidLiteral  or ' expected\n";
    int v10 = 43;
LABEL_23:
    htmlParseErr(ctxt, v10, v9, 0LL, 0LL);
    return 0LL;
  }

  xmlNextChar(ctxt);
  xmlParserInputPtr input = v1->input;
  unint64_t base = (unint64_t)input->base;
  cur = input->cur;
  unint64_t v6 = (unint64_t)&cur[-base];
  if ((unint64_t)cur >= base)
  {
    int v7 = *cur;
    if (*cur) {
      BOOL v8 = v7 == v2;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8)
    {
      if (v7 == v2)
      {
        int v12 = 0;
        goto LABEL_26;
      }
    }

    else
    {
      int v11 = 0;
      int v12 = 0;
      do
      {
        if (!xmlIsPubidChar_tab[v7])
        {
          htmlParseErrInt(v1, "Invalid char in PubidLiteral 0x%X\n", v7);
          int v11 = 1;
        }

        ++v12;
        xmlNextChar(v1);
        xmlParserInputPtr input = v1->input;
        uint64_t v13 = input->cur;
        int v7 = *v13;
        if (*v13) {
          BOOL v14 = v7 == v2;
        }
        else {
          BOOL v14 = 1;
        }
      }

      while (!v14);
      if (v7 == v2)
      {
        if (v11)
        {
          xmlNodePtr v15 = 0LL;
LABEL_27:
          xmlNextChar(v1);
          return v15;
        }

uint64_t htmlParseLookupSequence(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(xmlChar **)(v4 + 24);
  LODWORD(v6) = *(void *)(v4 + 32) - (_DWORD)v5;
  if ((v6 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 320) <= (uint64_t)v6)
  {
    int v11 = 0;
  }

  else
  {
    int v11 = *(_DWORD *)(a1 + 144) & 1;
    uint64_t v6 = *(void *)(a1 + 320);
  }

  if (*(void *)v4)
  {
    int v5 = xmlBufContent(*(const xmlBuf **)(*(void *)v4 + 32LL));
    int v12 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v4 + 32LL));
  }

  else
  {
    int v12 = *(_DWORD *)(v4 + 48);
  }

  LODWORD(v13) = v12 - (a3 != 0);
  if ((int)v6 >= (int)v13)
  {
    uint64_t v13 = (int)v6;
LABEL_26:
    *(void *)(a1 + 320) = v13;
    int v19 = *(_DWORD *)(a1 + 144);
    if (v11) {
      unsigned int v20 = v19 | 1;
    }
    else {
      unsigned int v20 = v19 & 0xFFFFFFFE;
    }
    *(_DWORD *)(a1 + 144) = v20;
    return 0xFFFFFFFFLL;
  }

  char v14 = 0;
  uint64_t v13 = (int)v13;
  int v15 = -(int)v6;
  BOOL v16 = &v5[(int)v6 + 1];
  unint64_t v17 = v12 - (unint64_t)(a3 != 0) - (int)v6;
  while (1)
  {
    int v18 = *(v16 - 1);
    if (!a4) {
      break;
    }
    if (v18 == 39 || v18 == 34)
    {
      if (v11)
      {
        if (v18 != v14) {
          break;
        }
        int v11 = 0;
      }

      else
      {
        int v11 = 1;
        char v14 = *(v16 - 1);
      }
    }

    else
    {
      if (!v11) {
        break;
      }
      int v11 = 1;
    }

uint64_t htmlParseLookupCommentEnd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(v2 + 24);
  uint64_t v3 = *(void *)(v2 + 32);
  uint64_t result = htmlParseLookupSequence(a1, 45, 45, 0);
  if ((result & 0x80000000) == 0)
  {
    int v6 = v3 - v4 + 1;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 32LL) + result;
      int v8 = *(unsigned __int8 *)(v7 + 2);
      if (v8 == 33)
      {
        if (*(_BYTE *)(v7 + 3) == 62) {
          return result;
        }
      }

      else if (v8 == 62)
      {
        return result;
      }

      *(void *)(a1 + 320) = v6 + (int)result;
      uint64_t result = htmlParseLookupSequence(a1, 45, 45, 0);
    }

    while ((result & 0x80000000) == 0);
  }

  return result;
}

uint64_t __htmlParserNeedsNoBlankQuirk_block_invoke()
{
  uint64_t result = (uint64_t)_dyld_get_image_name(0);
  if (result
    && (uint64_t result = (uint64_t)strrchr((const char *)result, 47)) != 0
    && (uint64_t result = strcmp((const char *)(result + 1), "TaxCut.real"), !(_DWORD)result))
  {
    uint64_t result = dyld_get_program_sdk_version();
    BOOL v1 = result >> 8 < 0xA09;
  }

  else
  {
    BOOL v1 = 0;
  }

  htmlParserNeedsNoBlankQuirk_needsQuiruint64_t k = v1;
  return result;
}

const xmlChar *__cdecl htmlGetMetaEncoding(const xmlChar *doc)
{
  if (!doc) {
    return doc;
  }
  uint64_t v1 = *((void *)doc + 3);
  if (!v1) {
    return 0LL;
  }
  while (1)
  {
    if (*(_DWORD *)(v1 + 8) != 1) {
      goto LABEL_8;
    }
    uint64_t v2 = *(const xmlChar **)(v1 + 16);
    if (!v2) {
      goto LABEL_8;
    }
    if (xmlStrEqual(v2, (const xmlChar *)"html"))
    {
      uint64_t v1 = *(void *)(v1 + 24);
      if (v1)
      {
        while (1)
        {
          if (*(_DWORD *)(v1 + 8) == 1)
          {
            uint64_t v3 = *(const xmlChar **)(v1 + 16);
            if (v3)
            {
              if (xmlStrEqual(v3, (const xmlChar *)"head")) {
                goto LABEL_17;
              }
              if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"meta")) {
                goto LABEL_18;
              }
            }
          }

          xmlDocPtr doc = 0LL;
          uint64_t v1 = *(void *)(v1 + 48);
          if (!v1) {
            return doc;
          }
        }
      }

      return 0LL;
    }

    if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"head"))
    {
LABEL_17:
      uint64_t v1 = *(void *)(v1 + 24);
      if (v1) {
        break;
      }
      return 0LL;
    }

    if (xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"meta")) {
      break;
    }
LABEL_8:
    uint64_t v1 = *(void *)(v1 + 48);
    if (!v1) {
      return 0LL;
    }
  }

LABEL_18:
  while (1)
  {
    if (*(_DWORD *)(v1 + 8) == 1)
    {
      uint64_t v4 = *(const xmlChar **)(v1 + 16);
      if (v4)
      {
        if (xmlStrEqual(v4, (const xmlChar *)"meta"))
        {
          uint64_t v5 = *(void *)(v1 + 88);
          if (v5) {
            break;
          }
        }
      }
    }

  uint64_t v13 = *(void *)(a1 + 48);
  BOOL v16 = *(void *)(v13 + 24);
  char v14 = (uint64_t **)(v13 + 24);
  int v15 = v16;
  if (v16)
  {
    do
    {
      unint64_t v17 = v15;
      int v15 = *(void *)(v15 + 64);
    }

    while (v15);
    char v14 = (uint64_t **)(v17 + 64);
  }

  *char v14 = v7;
  int v18 = *(void *)(a2 + 48);
  if (v18)
  {
    xmlRngPErr(a1, v18, 1105, "start more than one children\n", 0LL, 0LL);
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

  __int16 v21 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v21) {
    return v21;
  }
  unint64_t v17 = URI;
LABEL_20:
  __int16 v21 = xmlSchemaAddSchemaDoc(a1, a4, v17, 0LL, 0LL, 0, (uint64_t)a3, *(void *)(a1 + 200), 0LL, &v30);
  if ((_DWORD)v21) {
    return v21;
  }
  if (v30 && v30[4])
  {
    int v22 = v30[2];
    uint64_t v23 = *(const xmlChar **)(a1 + 200);
    if (v22)
    {
      if (!v23)
      {
        xmlSchemaCustomErr4( (_DWORD *)a1,  3050,  (uint64_t)a3,  0LL,  (const xmlChar *)"The target namespace of the included/redefined schema '%s' has to be absent, since the includ ing/redefining schema has no target namespace",  URI,  0LL,  0LL,  0LL);
        return *(unsigned int *)(a1 + 32);
      }

      if (!xmlStrEqual(v22, v23))
      {
        xmlSchemaPCustomErrExt( a1,  3050,  0LL,  (uint64_t)a3,  (const xmlChar *)"The target namespace '%s' of the included/redefined schema '%s' differs from '%s' of the incl uding/redefining schema");
        return *(unsigned int *)(a1 + 32);
      }
    }

    else if (v23)
    {
      __int16 v21 = 0LL;
      int v24 = 0;
      v30[3] = v23;
      goto LABEL_35;
    }

    __int16 v21 = 0LL;
  }

  else if (a4 == 2)
  {
    __int16 v21 = 3050LL;
    xmlSchemaCustomErr4( (_DWORD *)a1,  3050,  (uint64_t)a3,  0LL,  (const xmlChar *)"Failed to load the document '%s' for inclusion",  URI,  0LL,  0LL,  0LL);
  }

  else
  {
    __int16 v21 = 3081LL;
    xmlSchemaCustomErr4( (_DWORD *)a1,  3081,  (uint64_t)a3,  0LL,  (const xmlChar *)"Failed to load the document '%s' for redefinition",  URI,  0LL,  0LL,  0LL);
  }

  int v24 = 1;
LABEL_35:
  BOOL v25 = v30;
  if (v30 && !*((_DWORD *)v30 + 13) && v30[4])
  {
    if ((v24 & 1) != 0 || (int v26 = *(_DWORD *)(a2 + 48), (v26 & 0x200) != 0))
    {
      xmlSchemaParseNewDoc(a1, a2, (uint64_t)v30);
    }

    else
    {
      *(_DWORD *)(a2 + 48) = v26 | 0x200;
      xmlSchemaParseNewDoc(a1, a2, (uint64_t)v25);
      *(_DWORD *)(a2 + 48) ^= 0x200u;
    }
  }

  children = a3->children;
  if (a4 == 3)
  {
    *(void *)(a1 + 208) = v30;
    *(_DWORD *)(a1 + 188) = 1;
    if (children)
    {
      while (children->ns
           && (xmlStrEqual(children->name, (const xmlChar *)"annotation")
            && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
            || children->ns
            && (xmlStrEqual(children->name, (const xmlChar *)"simpleType")
             && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
             || children->ns
             && (xmlStrEqual(children->name, (const xmlChar *)"complexType")
              && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
              || children->ns
              && (xmlStrEqual(children->name, (const xmlChar *)"group")
               && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
               || children->ns
               && xmlStrEqual(children->name, (const xmlChar *)"attributeGroup")
               && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))))))
      {
        if (children->ns
          && (!xmlStrEqual(children->name, (const xmlChar *)"annotation")
           || !xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
          && children->ns)
        {
          if (xmlStrEqual(children->name, (const xmlChar *)"simpleType")
            && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
          {
            xmlSchemaParseSimpleType(a1, a2, children, 1);
          }

          else if (children->ns)
          {
            if (xmlStrEqual(children->name, (const xmlChar *)"complexType")
              && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
            {
              xmlSchemaParseComplexType(a1, a2, (uint64_t)children, 1);
            }

            else if (children->ns)
            {
              if (xmlStrEqual(children->name, (const xmlChar *)"group")
                && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
              {
                xmlSchemaParseModelGroupDefinition(a1, a2, (uint64_t)children);
              }

              else if (children->ns {
                     && xmlStrEqual(children->name, (const xmlChar *)"attributeGroup")
              }
                     && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
              {
                xmlSchemaParseAttributeGroupDefinition(a1, a2, (uint64_t)children);
              }
            }
          }
        }

        children = children->next;
        if (!children) {
          goto LABEL_82;
        }
      }

      *(void *)(a1 + 208) = 0LL;
      *(_DWORD *)(a1 + 188) = 0;
      int v28 = "(annotation | (simpleType | complexType | group | attributeGroup))*";
      goto LABEL_90;
    }

  cur = xmlStrcat(v13, (const xmlChar *)".\n");
  xmlSchemaErr4Line(a1, 2, a2, a3, 0, (const char *)cur, a4, 0LL, 0LL, 0LL);
  if (cur) {
    xmlFree(cur);
  }
}

int htmlSetMetaEncoding(htmlDocPtr doc, const xmlChar *encoding)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v23 = 0;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v18 = 0u;
  if (!doc || !xmlStrcasecmp(encoding, (const xmlChar *)"html")) {
    return -1;
  }
  if (encoding)
  {
    snprintf(__str, 0x64uLL, "text/html; charset=%s", (const char *)encoding);
    HIBYTE(v23) = 0;
  }

  children = doc->children;
  if (!children) {
    return -1;
  }
  while (1)
  {
    if (children->type == XML_ELEMENT_NODE)
    {
      name = children->name;
      if (name) {
        break;
      }
    }

LABEL_11:
    children = children->next;
    if (!children) {
      return -1;
    }
  }

  if (!xmlStrcasecmp(name, (const xmlChar *)"html"))
  {
    children = children->children;
    if (children)
    {
      while (1)
      {
        if (children->type == XML_ELEMENT_NODE)
        {
          uint64_t v7 = children->name;
          if (v7)
          {
            if (!xmlStrcasecmp(v7, (const xmlChar *)"head")) {
              goto LABEL_21;
            }
            if (!xmlStrcasecmp(children->name, (const xmlChar *)"meta"))
            {
              parent = children->parent;
              goto LABEL_27;
            }
          }
        }

        children = children->next;
        int result = -1;
        if (!children) {
          return result;
        }
      }
    }

    return -1;
  }

  if (xmlStrcasecmp(children->name, (const xmlChar *)"head"))
  {
    if (!xmlStrcasecmp(children->name, (const xmlChar *)"meta"))
    {
      parent = 0LL;
      goto LABEL_27;
    }

    goto LABEL_11;
  }

  int v11 = (xmlOutputBuffer *)xmlAllocOutputBufferInternal((uint64_t)CharEncodingHandler);
  if (!v11) {
    goto LABEL_15;
  }
  int v12 = v11;
  xmlElementType type = cur->type;
  cur->xmlElementType type = XML_HTML_DOCUMENT_NODE;
  htmlNodeDumpFormatOutput(v11, cur, (xmlNodePtr)cur, 0LL, format);
  cur->xmlElementType type = type;
  xmlOutputBufferFlush(v12);
  p_conv = &v12->conv;
  conv = v12->conv;
  if (!conv)
  {
    p_conv = &v12->buffer;
    conv = v12->buffer;
  }

  *unsigned int size = xmlBufUse(conv);
  BOOL v16 = xmlBufContent(*p_conv);
  *mem = xmlStrndup(v16, *size);
  xmlOutputBufferClose(v12);
}

    __int128 v9 = (void *)*i;
    uint64_t v3 = v9;
    if (!v9) {
      return 0LL;
    }
  }

  uint64_t v8 = *(_DWORD *)v3 - 3;
  if (v8 >= 6 || ((0x35u >> v8) & 1) == 0) {
    goto LABEL_11;
  }
  return 1LL;
}

    uint64_t v5 = 0LL;
    *a1 = v3;
    return v5;
  }

  return 1LL;
}

    LODWORD(DtdAttrDesc) = 0;
  }

  return (int)DtdAttrDesc;
}

      for (uint64_t i = v9[11]; i; uint64_t i = *(void *)(i + 72))
      {
        int v11 = *(_DWORD *)(i + 84);
        if (v11 == 4)
        {
          char v14 = *(const xmlChar **)(i + 104);
          if (!v14)
          {
            uint64_t v24 = xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"xmlns");
            p_nsDef = &elem->nsDef;
            if (v24)
            {
              while (1)
              {
                p_nsDef = (xmlNs **)*p_nsDef;
                if (!p_nsDef) {
                  break;
                }
                if (!p_nsDef[3])
                {
                  if (xmlStrEqual(*(const xmlChar **)(i + 88), (const xmlChar *)p_nsDef[2])) {
                    goto LABEL_56;
                  }
                  BOOL v16 = elem->name;
                  __int128 v18 = (uint64_t *)v5;
                  __int128 v19 = (int)elem;
                  __int128 v20 = 507;
                  __int128 v21 = "Element %s namespace name for default namespace does not match the DTD\n";
                  unint64_t v17 = 0LL;
                  goto LABEL_54;
                }
              }

              continue;
            }

            char v14 = *(const xmlChar **)(i + 104);
          }

          if (xmlStrEqual(v14, (const xmlChar *)"xmlns"))
          {
            int v15 = &elem->nsDef;
            while (1)
            {
              int v15 = (xmlNs **)*v15;
              if (!v15) {
                break;
              }
              if (xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)v15[3]))
              {
                if (xmlStrEqual(*(const xmlChar **)(i + 88), (const xmlChar *)v15[2])) {
                  break;
                }
                BOOL v16 = elem->name;
                unint64_t v17 = (xmlChar *)v15[3];
                __int128 v18 = (uint64_t *)v5;
                __int128 v19 = (int)elem;
                __int128 v20 = 508;
                __int128 v21 = "Element %s namespace name for %s does not match the DTD\n";
                goto LABEL_54;
              }
            }
          }
        }

        else if (v11 == 2)
        {
          int v12 = *(const xmlChar **)(i + 104);
          if (!v12)
          {
            __int128 v22 = xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)"xmlns");
            int v23 = &elem->nsDef;
            if (v22)
            {
              while (1)
              {
                int v23 = (xmlNs **)*v23;
                if (!v23) {
                  goto LABEL_51;
                }
                if (!v23[3]) {
                  goto LABEL_56;
                }
              }
            }

            int v12 = *(const xmlChar **)(i + 104);
          }

          if (xmlStrEqual(v12, (const xmlChar *)"xmlns"))
          {
            int v13 = &elem->nsDef;
            while (1)
            {
              int v13 = (xmlNs **)*v13;
              if (!v13) {
                break;
              }
              if (xmlStrEqual(*(const xmlChar **)(i + 16), (const xmlChar *)v13[3])) {
                goto LABEL_56;
              }
            }

  BOOL v16 = *(void **)(a1 + 128);
  if (v16) {
    xmlFree(v16);
  }
  *(void *)(a1 + 128) = xmlStrdup(cur);
  *(_DWORD *)(a1 + 112) = v23;
  int result = 0xFFFFFFFFLL;
  *(_DWORD *)a1 = -1;
  return result;
}

      fwrite("[nillable] ", 0xBuLL, 1uLL, __stream);
      goto LABEL_12;
    }

        int v10 = xmlStrcat(v15, (const xmlChar *)v16);
LABEL_12:
        *a1 = v10;
LABEL_13:
        if (!a3) {
          goto LABEL_63;
        }
        goto LABEL_57;
      default:
        int v11 = xmlStrdup((const xmlChar *)"facet '");
        *a1 = v11;
        int v12 = (const xmlChar *)xmlSchemaFacetTypeToString(*(_DWORD *)a2);
LABEL_8:
        int v13 = v12;
        char v14 = v11;
LABEL_9:
        int v15 = xmlStrcat(v14, v13);
        *a1 = v15;
        goto LABEL_10;
    }
  }

  if (a3)
  {
    uint64_t v44 = a3;
    if (*(_DWORD *)(a3 + 8) == 2) {
      uint64_t v44 = *(void *)(a3 + 40);
    }
    int v45 = xmlStrdup((const xmlChar *)"Element '");
    int v46 = v45;
    *a1 = v45;
    int v47 = *(void *)(v44 + 72);
    if (v47)
    {
      int v48 = xmlSchemaFormatQName(&v56, *(const xmlChar **)(v47 + 16), *(xmlChar **)(v44 + 16));
      int v49 = xmlStrcat(v46, v48);
      *a1 = v49;
      if (v56)
      {
        xmlFree(v56);
        uint64_t v56 = 0LL;
        int v49 = *a1;
      }
    }

    else
    {
      int v49 = xmlStrcat(v45, *(const xmlChar **)(v44 + 16));
      *a1 = v49;
    }

    *a1 = xmlStrcat(v49, (const xmlChar *)"'");
LABEL_57:
    if (*(_DWORD *)(a3 + 8) == 2)
    {
      int v50 = xmlStrcat(*a1, (const xmlChar *)", attribute '");
      int v51 = v50;
      *a1 = v50;
      unsigned int v52 = *(void *)(a3 + 72);
      if (v52)
      {
        int v53 = xmlSchemaFormatQName(&v56, *(const xmlChar **)(v52 + 16), *(xmlChar **)(a3 + 16));
        int v54 = xmlStrcat(v51, v53);
        *a1 = v54;
        if (v56)
        {
          xmlFree(v56);
          uint64_t v56 = 0LL;
          int v54 = *a1;
        }
      }

      else
      {
        int v54 = xmlStrcat(v50, *(const xmlChar **)(a3 + 16));
        *a1 = v54;
      }

      *a1 = xmlStrcat(v54, (const xmlChar *)"'");
    }
  }

    PropNode = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"id");
    if (PropNode) {
      xmlSchemaPValAttrNodeID((uint64_t)a1, PropNode);
    }
    children = (uint64_t)a3->children;
    if (children)
    {
      if (!*(void *)(children + 72)
        || !xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"annotation")
        || !xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
        || (*((void *)v5 + 2) = xmlSchemaParseAnnotation(a1, children, 1), (children = *(void *)(children + 48)) != 0))
      {
        xmlSchemaPContentErr((uint64_t)a1, 3033, (uint64_t)a3, children, 0LL, (xmlChar *)"(annotation?)");
      }
    }
  }

  return v5;
}

  int v13 = *(xmlNode **)(a3 + 24);
  unsigned int v73 = v13;
  if (v13
    && v13->ns
    && xmlStrEqual(v13->name, (const xmlChar *)"annotation")
    && xmlStrEqual(v13->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    char v14 = xmlSchemaParseAnnotation((_DWORD *)a1, (uint64_t)v13, 1);
    xmlSchemaAddAnnotation(v8, (uint64_t)v14);
    int v13 = v13->next;
    unsigned int v73 = v13;
  }

  if (a4 == 10)
  {
    if (!v13 || !v13->ns) {
      goto LABEL_200;
    }
    BOOL v16 = xmlStrEqual(v13->name, (const xmlChar *)"all");
    ns = v13->ns;
    if (v16)
    {
      if (xmlStrEqual(ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        __int128 v18 = a1;
        __int128 v19 = a2;
        __int128 v20 = v13;
        __int128 v21 = 8LL;
LABEL_198:
        xmlParserInputPtr v68 = (void *)xmlSchemaParseModelGroup(v18, v19, v20, v21, 1LL);
        goto LABEL_199;
      }

      ns = v13->ns;
    }

    if (!ns) {
      goto LABEL_200;
    }
    int v23 = xmlStrEqual(v13->name, (const xmlChar *)"choice");
    uint64_t v24 = v13->ns;
    if (v23)
    {
      if (xmlStrEqual(v24->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        __int128 v18 = a1;
        __int128 v19 = a2;
        __int128 v20 = v13;
        __int128 v21 = 7LL;
        goto LABEL_198;
      }

      uint64_t v24 = v13->ns;
    }

    if (!v24) {
      goto LABEL_200;
    }
    xmlXPathObjectPtr v66 = xmlStrEqual(v13->name, (const xmlChar *)"sequence");
    xmlAttrPtr v67 = v13->ns;
    if (v66)
    {
      if (xmlStrEqual(v67->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        __int128 v18 = a1;
        __int128 v19 = a2;
        __int128 v20 = v13;
        __int128 v21 = 6LL;
        goto LABEL_198;
      }

      xmlAttrPtr v67 = v13->ns;
    }

    if (!v67
      || !xmlStrEqual(v13->name, (const xmlChar *)"group")
      || !xmlStrEqual(v13->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      goto LABEL_200;
    }

    xmlParserInputPtr v68 = xmlSchemaParseModelGroupDefRef((_DWORD *)a1, a2, (uint64_t)v13);
LABEL_199:
    *(void *)(v8 + 56) = v68;
    int v13 = v13->next;
    unsigned int v73 = v13;
    goto LABEL_200;
  }

  if (a4 == 4)
  {
    if (!v13
      || !v13->ns
      || !xmlStrEqual(v13->name, (const xmlChar *)"simpleType")
      || !xmlStrEqual(v13->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      if (!*v12) {
        xmlSchemaPContentErr( a1,  3005,  a3,  (uint64_t)v13,  (xmlChar *)"Either the attribute 'base' or a <simpleType> child must be present",  0LL);
      }
LABEL_60:
      if (!v13) {
        goto LABEL_182;
      }
      goto LABEL_61;
    }

    if (*v12) {
      xmlSchemaPContentErr( a1,  3005,  a3,  (uint64_t)v13,  (xmlChar *)"The attribute 'base' and the <simpleType> child are mutually exclusive",  0LL);
    }
    else {
      *(void *)(v8 + 112) = xmlSchemaParseSimpleType(a1, a2, v13, 0LL);
    }
LABEL_59:
    int v13 = v13->next;
    unsigned int v73 = v13;
    goto LABEL_60;
  }

  if (a4 != 9 || !v13)
  {
    if (a4 != 9) {
      goto LABEL_200;
    }
    goto LABEL_60;
  }

  if (v13->ns
    && xmlStrEqual(v13->name, (const xmlChar *)"simpleType")
    && xmlStrEqual(v13->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    __int128 v22 = xmlSchemaParseSimpleType(a1, a2, v13, 0LL);
    *(void *)(v8 + 192) = v22;
    if (!v22) {
      return;
    }
    goto LABEL_59;
  }

  __int128 v89 = 0LL;
  uint64_t v8 = 0LL;
  __int128 v9 = *(const xmlChar **)(v7 + 40);
  while (1)
  {
    if (*(_DWORD *)(v7 + 92) == 3)
    {
      for (uint64_t i = v9; ; ++i)
      {
        int v11 = *v9;
        if (v11 > 0x20 || ((1LL << v11) & 0x100002600LL) == 0) {
          break;
        }
        ++v9;
      }

      int v13 = 0LL;
      for (uint64_t j = *v9; j > 0x20u || ((1LL << j) & 0x100002601LL) == 0; uint64_t j = v9[++v13])
        ;
      if (!v13) {
        goto LABEL_66;
      }
      int v15 = &v9[v13];
      __int128 v89 = (xmlChar *)xmlDictLookup(*(xmlDictPtr *)(*((void *)v1 + 5) + 120LL), v9, v13);
      __int128 v9 = v15;
    }

    for (uint64_t k = v9; ; ++k)
    {
      unint64_t v17 = *k;
      if (v17 > 0x20 || ((1LL << v17) & 0x100002600LL) == 0) {
        break;
      }
      ++v9;
    }

    __int128 v19 = 0LL;
    if (!v19) {
      break;
    }
    __int128 v20 = (xmlChar *)xmlDictLookup(*(xmlDictPtr *)(*((void *)v1 + 5) + 120LL), k, v19);
    __int128 v21 = *((void *)v1 + 5);
    __int128 v22 = *(xmlNode **)(v7 + 8);
    values[0] = 0LL;
    if (!v1 || !v21) {
      goto LABEL_99;
    }
    int v23 = *((void *)v1 + 20);
    if (!v23)
    {
      int v54 = "no parser context available";
      BOOL v55 = v1;
      goto LABEL_98;
    }

    if (!*(void *)(v23 + 48))
    {
      int v54 = "no constructor";
      BOOL v55 = (_DWORD *)*((void *)v1 + 20);
LABEL_98:
      xmlSchemaInternalErr2(v55, (const xmlChar *)"xmlSchemaAssembleByLocation", (const xmlChar *)v54, 0LL);
LABEL_99:
      xmlChar v32 = "xmlSchemaAssembleByXSI";
      int v33 = "assembling schemata";
      goto LABEL_227;
    }

    uint64_t v24 = v1;
    BOOL v25 = xmlSchemaBuildAbsoluteURI(*(xmlDict **)(v23 + 152), v20, v22);
    int v26 = xmlSchemaAddSchemaDoc(v23, 1u, v25, 0LL, 0LL, 0, (uint64_t)v22, 0LL, v89, (const xmlChar ***)values);
    if ((_DWORD)v26) {
      goto LABEL_41;
    }
    uint64_t v27 = values[0];
    if (values[0])
    {
      int v28 = *(void *)(v23 + 48);
      if (!*(void *)(v28 + 32)) {
        *(xmlChar **)(v28 + 32) = values[0];
      }
      unsigned int v29 = *((void *)v27 + 4);
      uint64_t v1 = v24;
      if (v29 && !*((_DWORD *)v27 + 13))
      {
        *(void *)(v23 + 32) = 0LL;
        *(void *)(v23 + 88) = v29;
        int v26 = xmlSchemaParseNewDocWithContext(v23, v21, (uint64_t)v27);
        if ((_DWORD)v26)
        {
          if ((_DWORD)v26 == -1)
          {
            *(void *)(v23 + 88) = 0LL;
            goto LABEL_99;
          }

          unsigned int v30 = *(_DWORD *)(v23 + 36);
          if (!v30)
          {
LABEL_58:
            xmlSchemaFixupComponents(v23, (uint64_t)values[0]);
            int v26 = *(unsigned int *)(v23 + 32);
            if ((_DWORD)v26 && !v24[26]) {
              v24[26] = v26;
            }
            unsigned int v30 = *(_DWORD *)(v23 + 36);
          }
        }

        else
        {
          unsigned int v30 = *(_DWORD *)(v23 + 36);
          if (!v30) {
            goto LABEL_58;
          }
          int v26 = *(unsigned int *)(v23 + 32);
        }

        v24[27] += v30;
        *(void *)(v23 + 88) = 0LL;
LABEL_41:
        uint64_t v1 = v24;
        uint64_t v8 = v26;
        if ((_DWORD)v26 == -1) {
          goto LABEL_99;
        }
        goto LABEL_54;
      }
    }

    else
    {
      uint64_t v31 = v25;
      uint64_t v1 = v24;
      xmlSchemaCustomWarning( v24,  1879,  (uint64_t)v22,  (const xmlChar *)"The document at location '%s' could not be acquired",  v31,  0LL,  0LL);
    }

    uint64_t v8 = 0LL;
LABEL_54:
    __int128 v9 = &k[v19];
    if (!k[v19]) {
      goto LABEL_66;
    }
  }

  if (*(_DWORD *)(v7 + 92) == 3) {
    xmlSchemaCustomWarning( v1,  1879,  *(void *)(v7 + 8),  (const xmlChar *)"The value must consist of tuples: the target namespace name and the document's URI",  0LL,  0LL,  0LL);
  }
LABEL_66:
  if ((_DWORD)v8 == -1) {
    return v8;
  }
  if ((_DWORD)v8)
  {
    v1[76] = 0;
    return v8;
  }

    if (!v2[17])
    {
      uint64_t v3 = v1[7];
      if (v3)
      {
        int result = (const xmlChar **)*((void *)v3 + 1);
        if (result)
        {
          int result = (const xmlChar **)xmlCanonicPath((const xmlChar *)result);
          *((void *)v1[2] + 17) = result;
          if (!result)
          {
            int result = (const xmlChar **)xmlStrdup(*((const xmlChar **)v1[7] + 1));
            *((void *)v1[2] + 17) = result;
          }
        }
      }
    }

    return result;
  }

  if (!v2)
  {
    int result = (const xmlChar **)xmlNewDoc(result[4]);
    uint64_t v2 = result;
    v1[2] = (const xmlChar *)result;
    if (!result) {
      goto LABEL_16;
    }
  }

  if (v2[3]) {
    goto LABEL_11;
  }
  int result = (const xmlChar **)v1[5];
  if (result) {
    int result = (const xmlChar **)xmlStrdup((const xmlChar *)result);
  }
  v2[14] = (const xmlChar *)result;
  *((_DWORD *)v2 + 19) = *((_DWORD *)v1 + 12);
  uint64_t v2 = (const xmlChar **)v1[2];
  if (v2) {
    goto LABEL_11;
  }
  return result;
}

    uint64_t v8 = valueTab[valueNr - 2];
LABEL_12:
    ctxt->unsigned int value = v8;
    __int128 v9 = valueTab[v4];
    valueTab[v4] = 0LL;
    valueNr = v4;
    goto LABEL_13;
  }

  __int128 v9 = 0LL;
LABEL_13:
  int v10 = ctxt->value;
  if (v10 && v10->type != XPATH_STRING)
  {
    xmlXPathStringFunction(ctxt, 1);
    valueNr = ctxt->valueNr;
  }

  int v11 = valueNr - 1;
  if (valueNr < 1)
  {
    int v13 = 0LL;
  }

  else
  {
    ctxt->valueNr = v11;
    int v12 = ctxt->valueTab;
    if (valueNr == 1) {
      char v14 = 0LL;
    }
    else {
      char v14 = v12[valueNr - 2];
    }
    ctxt->unsigned int value = v14;
    int v13 = v12[v11];
    v12[v11] = 0LL;
  }

  int v15 = (uint64x2_t *)xmlBufCreate();
  if (v15)
  {
    BOOL v16 = v15;
    unint64_t v17 = xmlStrstr(v13->stringval, v9->stringval);
    if (v17) {
      xmlBufAdd(v16, v13->stringval, v17 - v13->stringval);
    }
    context = ctxt->context;
    __int128 v19 = xmlBufContent((const xmlBuf *)v16);
    __int128 v20 = xmlXPathCacheNewString((uint64_t)context, v19);
    valuePush(ctxt, v20);
    xmlBufFree(v16);
  }

  xmlXPathReleaseObject((uint64_t)ctxt->context, v13);
  xmlXPathReleaseObject((uint64_t)ctxt->context, v9);
}

    uint64_t v8 = valueTab[valueNr - 2];
LABEL_12:
    ctxt->unsigned int value = v8;
    __int128 v9 = valueTab[v4];
    valueTab[v4] = 0LL;
    valueNr = v4;
    goto LABEL_13;
  }

  __int128 v9 = 0LL;
LABEL_13:
  int v10 = ctxt->value;
  if (v10 && v10->type != XPATH_STRING)
  {
    xmlXPathStringFunction(ctxt, 1);
    valueNr = ctxt->valueNr;
  }

  int v11 = valueNr - 1;
  if (valueNr < 1)
  {
    int v13 = 0LL;
  }

  else
  {
    ctxt->valueNr = v11;
    int v12 = ctxt->valueTab;
    if (valueNr == 1) {
      char v14 = 0LL;
    }
    else {
      char v14 = v12[valueNr - 2];
    }
    ctxt->unsigned int value = v14;
    int v13 = v12[v11];
    v12[v11] = 0LL;
  }

  int v15 = (uint64x2_t *)xmlBufCreate();
  if (v15)
  {
    BOOL v16 = v15;
    unint64_t v17 = xmlStrstr(v13->stringval, v9->stringval);
    if (v17)
    {
      __int128 v18 = (_DWORD)v17 - LODWORD(v13->stringval);
      __int128 v19 = xmlStrlen(v9->stringval) + v18;
      stringval = v13->stringval;
      __int128 v21 = &stringval[v19];
      __int128 v22 = xmlStrlen(stringval);
      xmlBufAdd(v16, v21, (v22 - v19));
    }

    context = ctxt->context;
    uint64_t v24 = xmlBufContent((const xmlBuf *)v16);
    BOOL v25 = xmlXPathCacheNewString((uint64_t)context, v24);
    valuePush(ctxt, v25);
    xmlBufFree(v16);
  }

  xmlXPathReleaseObject((uint64_t)ctxt->context, v13);
  xmlXPathReleaseObject((uint64_t)ctxt->context, v9);
}

    uint64_t v8 = valueTab[valueNr - 2];
LABEL_12:
    ctxt->unsigned int value = v8;
    __int128 v9 = valueTab[v6];
    valueTab[v6] = 0LL;
    valueNr = v6;
    goto LABEL_13;
  }

  __int128 v9 = 0LL;
LABEL_13:
  int v10 = ctxt->value;
  if (v10 && v10->type != XPATH_STRING)
  {
    xmlXPathStringFunction(ctxt, 1);
    valueNr = ctxt->valueNr;
  }

  int v11 = valueNr - 1;
  if (valueNr < 1)
  {
    int v13 = 0LL;
    int v11 = valueNr;
  }

  else
  {
    ctxt->valueNr = v11;
    int v12 = ctxt->valueTab;
    if (valueNr == 1) {
      char v14 = 0LL;
    }
    else {
      char v14 = v12[valueNr - 2];
    }
    ctxt->unsigned int value = v14;
    int v13 = v12[v11];
    v12[v11] = 0LL;
  }

  int v15 = ctxt->value;
  if (v15 && v15->type != XPATH_STRING)
  {
    xmlXPathStringFunction(ctxt, 1);
    int v11 = ctxt->valueNr;
  }

  BOOL v16 = v11 - 1;
  if (v11 < 1)
  {
    __int128 v18 = 0LL;
  }

  else
  {
    ctxt->valueNr = v16;
    unint64_t v17 = ctxt->valueTab;
    if (v11 == 1) {
      __int128 v19 = 0LL;
    }
    else {
      __int128 v19 = v17[v11 - 2];
    }
    ctxt->unsigned int value = v19;
    __int128 v18 = v17[v16];
    v17[v16] = 0LL;
  }

  __int128 v20 = (uint64x2_t *)xmlBufCreate();
  if (v20)
  {
    __int128 v21 = xmlUTF8Strlen(v9->stringval);
    stringval = v18->stringval;
    int v23 = *stringval;
    if (*stringval)
    {
      uint64_t v24 = v21;
      do
      {
        BOOL v25 = xmlUTF8Strloc(v13->stringval, stringval);
        int v26 = stringval;
        if (v25 < 0 || v25 < v24 && (int v26 = xmlUTF8Strpos(v9->stringval, v25)) != 0LL)
        {
          uint64_t v27 = xmlUTF8Strsize(v26, 1);
          xmlBufAdd(v20, v26, v27);
        }

        ++stringval;
        if ((v23 & 0x80) != 0)
        {
          if ((~v23 & 0xC0) != 0)
          {
LABEL_47:
            unsigned int v29 = *__xmlGenericError();
            unsigned int v30 = __xmlGenericErrorContext();
            v29(*v30, "xmlXPathTranslateFunction: Invalid UTF8 string\n");
            break;
          }

          while ((v23 & 0x40) != 0)
          {
            LOBYTE(v23) = 2 * v23;
            int v28 = *stringval++;
            if ((v28 & 0xC0) != 0x80) {
              goto LABEL_47;
            }
          }
        }

        int v23 = *stringval;
      }

      while (*stringval);
    }
  }

  context = ctxt->context;
  xmlChar v32 = xmlBufContent((const xmlBuf *)v20);
  int v33 = xmlXPathCacheNewString((uint64_t)context, v32);
  valuePush(ctxt, v33);
  xmlBufFree(v20);
  xmlXPathReleaseObject((uint64_t)ctxt->context, v18);
  xmlXPathReleaseObject((uint64_t)ctxt->context, v13);
  xmlXPathReleaseObject((uint64_t)ctxt->context, v9);
}

LABEL_22:
  int result = 0;
  if (encoding && parent)
  {
    __int128 v9 = xmlNewDocNode(doc, 0LL, (const xmlChar *)"meta", 0LL);
    int v10 = parent->children;
    if (v10) {
      xmlAddPrevSibling(v10, v9);
    }
    else {
      xmlAddChild(parent, v9);
    }
    xmlNewProp(v9, (const xmlChar *)"http-equiv", (const xmlChar *)"Content-Type");
    xmlNewProp(v9, (const xmlChar *)"content", (const xmlChar *)__str);
    return 0;
  }

  return result;
}

  if (!*(void *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_83;
  }
  int v13 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"name");
  char v14 = *(void *)(a2 + 72);
  if (!v13) {
    goto LABEL_30;
  }
  if (!xmlStrEqual(*(const xmlChar **)(v14 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    char v14 = *(void *)(a2 + 72);
LABEL_30:
    if (v14 && *(_DWORD *)(a2 + 8) == 1)
    {
      __int128 v22 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"anyName");
      int v23 = *(void *)(a2 + 72);
      if (v22)
      {
        if (xmlStrEqual(*(const xmlChar **)(v23 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          *((void *)v6 + 2) = 0LL;
          *((void *)v6 + 3) = 0LL;
LABEL_35:
          uint64_t v24 = *(void *)(a2 + 24);
          if (v24) {
            *((void *)v6 + 10) = xmlRelaxNGParseExceptNameClass(a1, v24, *(_DWORD *)a3 == 9);
          }
          goto LABEL_49;
        }

        int v23 = *(void *)(a2 + 72);
      }

      if (v23 && *(_DWORD *)(a2 + 8) == 1)
      {
        size_t v34 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"nsName");
        int v35 = *(void *)(a2 + 72);
        if (v34)
        {
          if (xmlStrEqual(*(const xmlChar **)(v35 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            *((void *)v6 + 2) = 0LL;
            Prop = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"ns");
            *((void *)v6 + 3) = Prop;
            if (!Prop) {
              xmlRngPErr(a1, a2, 1057, "nsName has no ns attribute\n", 0LL, 0LL);
            }
            if ((*(_BYTE *)(a1 + 64) & 1) != 0)
            {
              __int128 v37 = (const xmlChar *)*((void *)v6 + 3);
              if (v37)
              {
                if (xmlStrEqual(v37, (const xmlChar *)"http://www.w3.org/2000/xmlns")) {
                  xmlRngPErr( a1,  a2,  1122,  "Attribute with namespace '%s' is not allowed\n",  *((const xmlChar **)v6 + 3),  0LL);
                }
              }
            }

            goto LABEL_35;
          }

          int v35 = *(void *)(a2 + 72);
        }

        if (v35
          && *(_DWORD *)(a2 + 8) == 1
          && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"choice")
          && xmlStrEqual( *(const xmlChar **)(*(void *)(a2 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          int v6 = (_OWORD *)a3;
          if (*(_DWORD *)a3 != 17)
          {
            int v38 = xmlRelaxNGNewDefine(a1, a2);
            int v6 = v38;
            if (!v38) {
              return v6;
            }
            *((void *)v38 + 7) = a3;
            *(_DWORD *)int v38 = 17;
          }

          __int128 v39 = *(void *)(a2 + 24);
          if (!v39)
          {
            uint64_t v27 = "Element choice is empty\n";
            int v28 = a1;
            unsigned int v29 = a2;
            unsigned int v30 = 1007;
            uint64_t v31 = 0LL;
            goto LABEL_48;
          }

          __int128 v40 = 0LL;
          while (1)
          {
            __int128 v41 = xmlRelaxNGParseNameClass(a1, v39, v6);
            if (!v41) {
              break;
            }
            if (v40)
            {
              if ((_OWORD *)v41 == v6) {
                break;
              }
              *(void *)(v40 + 64) = v41;
            }

  if (*((_DWORD *)v13 + 15))
  {
    *((void *)v13 + 2) = v4;
    if ((v9 & 1) == 0) {
      *((_DWORD *)v13 + 2) = 1;
    }
    goto LABEL_29;
  }

  xmlSchematronPErr( (uint64_t)ctxt,  v11,  1759,  "The schematron document '%s' has no pattern",  *((const xmlChar **)ctxt + 1));
LABEL_26:
  if (v9) {
    xmlFreeDoc(v4);
  }
  if (v13)
  {
LABEL_29:
    if (*((_DWORD *)ctxt + 14))
    {
      xmlSchematronFree((xmlSchematronPtr)v13);
      return 0LL;
    }

    *((void *)v13 + 11) = *((void *)ctxt + 11);
    *((_DWORD *)v13 + 20) = *((_DWORD *)ctxt + 20);
    *((void *)ctxt + 11) = 0LL;
  }

  return (xmlSchematronPtr)v13;
}

  SystemID = (xmlChar *)cur->SystemID;
  if (!SystemID) {
    goto LABEL_27;
  }
  if (dict)
  {
    if (xmlDictOwns(dict, SystemID)) {
      goto LABEL_27;
    }
    SystemID = (xmlChar *)cur->SystemID;
  }

  xmlFree(SystemID);
LABEL_27:
  ExternalID = (xmlChar *)cur->ExternalID;
  if (ExternalID)
  {
    if (!dict)
    {
LABEL_31:
      xmlFree(ExternalID);
      goto LABEL_32;
    }

    if (!xmlDictOwns(dict, ExternalID))
    {
      ExternalID = (xmlChar *)cur->ExternalID;
      goto LABEL_31;
    }
  }

        children = tree->children;
        if (children && children->type != XML_NAMESPACE_DECL)
        {
          do
          {
            if (children->doc != doc) {
              xmlSetTreeDoc(children, doc);
            }
            children = children->next;
          }

          while (children);
        }

        goto LABEL_27;
      }
    }
  }

    int v51 = 0;
    int v49 = 0u;
    int v50 = 0u;
    int v47 = 0u;
    int v48 = 0u;
    int v45 = 0u;
    int v46 = 0u;
    int v43 = 0u;
    uint64_t v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    int v38 = 0u;
    int v35 = 0u;
    BOOL v36 = 0u;
    int v33 = 0u;
    size_t v34 = 0u;
    uint64_t v31 = 0u;
    xmlChar v32 = 0u;
    unsigned int v29 = 0u;
    unsigned int v30 = 0u;
    int v28 = 0u;
    int v26 = 0u;
    uint64_t v27 = 0u;
    uint64_t v24 = 0u;
    BOOL v25 = 0u;
    __int128 v22 = 0u;
    int v23 = 0u;
    *(_OWORD *)uint64_t buf = 0u;
    __int128 v21 = 0u;
    xmlStrPrintf( buf,  500,  "xmlIOHTTPCloseWrite:  %s '%s' %s '%s'.\n",  "Error retrieving content.\nUnable to",  a2,  "data to URI",  *((const char **)a1 + 1));
    __xmlSimpleError(8, 1546, 0, (uint64_t)"write error", (uint64_t)buf);
    goto LABEL_23;
  }

  return v2;
}

    uint64_t v2 = 0LL;
    goto LABEL_27;
  }

  int v12 = xmlStrEqual(name, (const xmlChar *)"xmlns");
  int v13 = (const xmlNode *)*((void *)reader + 14);
  if (v12)
  {
    p_nsDef = &v13->nsDef;
    while (1)
    {
      p_nsDef = (xmlNs **)*p_nsDef;
      if (!p_nsDef) {
        break;
      }
      if (!p_nsDef[3]) {
        return xmlStrdup((const xmlChar *)p_nsDef[2]);
      }
    }

    return 0LL;
  }

  return xmlGetNoNsProp(v13, name);
}

        xmlFree(v7);
        int result = (int)prefix;
        if (prefix)
        {
          xmlFree(prefix);
          return 0;
        }
      }
    }
  }

  return result;
}

    fwrite("[abstract] ", 0xBuLL, 1uLL, __stream);
    if ((*(_DWORD *)(a1 + 88) & 1) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

    int v13 = v13->next;
  }

  while (v13);
  uint64_t v8 = v58;
  if (!v56)
  {
LABEL_40:
    __int128 v22 = *(_DWORD *)(a2 + 48);
    if ((v22 & 0x80) != 0) {
      *(_DWORD *)(PropNode + 88) |= 0x80000u;
    }
    if ((v22 & 0x40) != 0) {
      *(_DWORD *)(PropNode + 88) |= 0x40000u;
    }
  }

  if (!v14)
  {
    int v23 = *(_DWORD *)(a2 + 48);
    if ((v23 & 8) != 0) {
      *(_DWORD *)(PropNode + 88) |= 0x400u;
    }
    if ((v23 & 4) != 0) {
      *(_DWORD *)(PropNode + 88) |= 0x200u;
    }
  }

  uint64_t v24 = *(xmlNode **)(a3 + 24);
  next = v24;
  if (v24)
  {
    if (v24->ns
      && xmlStrEqual(v24->name, (const xmlChar *)"annotation")
      && xmlStrEqual(v24->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      BOOL v25 = 1;
      *(void *)(PropNode + 48) = xmlSchemaParseAnnotation((_DWORD *)a1, (uint64_t)v24, 1);
      uint64_t v24 = v24->next;
      next = v24;
      *(void *)(a1 + 160) = PropNode;
      if (!v24) {
        goto LABEL_107;
      }
    }

    else
    {
      *(void *)(a1 + 160) = PropNode;
    }

    if (v24->ns)
    {
      int v26 = xmlStrEqual(v24->name, (const xmlChar *)"simpleContent");
      uint64_t v27 = v24->ns;
      if (v26)
      {
        if (xmlStrEqual(v27->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          uint64_t v57 = v4;
          uint64_t v59 = v8;
          int v28 = *(_DWORD *)(PropNode + 88);
          if ((v28 & 1) != 0) {
            *(_DWORD *)(PropNode + 88) = v28 ^ 1;
          }
          unsigned int v29 = *(void *)(a1 + 160);
          *(_DWORD *)(v29 + 92) = 4;
          properties = (uint64_t)v24->properties;
          if (properties)
          {
            while (1)
            {
              uint64_t v31 = *(void *)(properties + 72);
              if (!v31) {
                break;
              }
              if (xmlStrEqual(*(const xmlChar **)(v31 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
                goto LABEL_64;
              }
LABEL_65:
              properties = *(void *)(properties + 48);
              if (!properties) {
                goto LABEL_70;
              }
            }

            if (xmlStrEqual(*(const xmlChar **)(properties + 16), (const xmlChar *)"id")) {
              goto LABEL_65;
            }
LABEL_64:
            xmlSchemaPIllegalAttrErr((_DWORD *)a1, properties);
            goto LABEL_65;
          }

      int v33 = v21 - 1;
      a4 = v44;
      if (v21 - 1 > v12)
      {
        size_t v34 = v12;
        do
        {
          int v35 = *(void *)(a1 + 8 * v34);
          *(void *)(a1 + 8 * v34) = *(void *)(a1 + 8 * v33);
          *(void *)(a1 + 8 * v33) = v35;
          ++v34;
          --v33;
        }

        while (v34 < v33);
      }

      char v14 = v21 - v12;
      goto LABEL_29;
    }

    if (v17 != v21)
    {
      __int128 v42 = v7;
      unsigned int v30 = v12;
      while (1)
      {
        uint64_t v31 = *(void *)(a1 + 16 + 8 * v30);
        xmlChar v32 = xmlXPathCmpNodesExt(v19, v31);
        if (v32 != -2 && v32 < 0) {
          break;
        }
        ++v30;
        __int128 v19 = v31;
        if (a2 - 3 == v30)
        {
          __int128 v21 = a2 - 1;
          uint64_t v7 = v42;
          goto LABEL_27;
        }
      }

      __int128 v21 = v30 + 2;
      uint64_t v7 = v42;
    }

    int v13 = (xmlNode *)xmlXPathNodeSetDupNs((uint64_t)node, (uint64_t)ns);
    int result = 0;
    nodeTab = cur->nodeTab;
    int v15 = cur->nodeNr;
    cur->nodeNr = v15 + 1;
    nodeTab[v15] = v13;
  }

  return result;
}

          BOOL v16 = (uint64x2_t *)v12;
          unint64_t v17 = stringval;
          __int128 v18 = 1LL;
LABEL_23:
          xmlBufAdd(v16, v17, v18);
          __int128 v19 = *++stringval;
          char v14 = v19;
        }

        while (v19);
      }
    }

    context = ctxt->context;
    BOOL v25 = xmlBufContent(v12);
    int v26 = xmlXPathCacheNewString((uint64_t)context, v25);
    valuePush(ctxt, v26);
    xmlBufFree(v12);
    return xmlXPathReleaseObject((uint64_t)ctxt->context, v10);
  }

  return result;
}

int htmlIsBooleanAttr(const xmlChar *name)
{
  uint64_t v2 = 0LL;
  while (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[v2], name))
  {
    if (++v2 == 13) {
      return 0;
    }
  }

  return 1;
}

int htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur)
{
  LODWORD(v3) = -1;
  if (buf && cur)
  {
    xmlInitParser();
    uint64_t v7 = xmlBufFromBuffer((uint32x2_t *)buf);
    if (v7)
    {
      uint64_t v8 = (xmlBuf *)v7;
      __int128 v9 = (xmlOutputBuffer *)xmlMalloc(0x38uLL);
      if (v9)
      {
        int v10 = v9;
        *(_OWORD *)&v9->closecallbacuint64_t k = 0u;
        *(_OWORD *)&v9->buffer = 0u;
        *(void *)&v9->written = 0LL;
        *(_OWORD *)&v9->context = 0u;
        v9->buffer = v8;
        v9->written = 0;
        size_t v11 = xmlBufUse(v8);
        htmlNodeDumpFormatOutput(v10, doc, cur, 0LL, 1);
        xmlFree(v10);
        size_t v3 = xmlBufUse(v8) - v11;
        xmlBufBackToBuffer((uint64_t)v8);
        if ((v3 & 0x80000000) == 0) {
          return v3;
        }
      }

      else
      {
        __xmlSimpleError(7, 2, 0, 0LL, (uint64_t)"allocating HTML output buffer");
        xmlBufBackToBuffer((uint64_t)v8);
      }
    }

    LODWORD(v3) = -1;
  }

  return v3;
}

int htmlNodeDumpFileFormat(FILE *out, xmlDocPtr doc, xmlNodePtr cur, const char *encoding, int format)
{
  if (encoding)
  {
    if (xmlParseCharEncoding(encoding) != XML_CHAR_ENCODING_UTF8)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
      if (CharEncodingHandler) {
        goto LABEL_8;
      }
      __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)encoding);
    }

    xmlCharEncodingHandlerPtr CharEncodingHandler = 0LL;
  }

  else
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
  }

LABEL_8:
  htmlDocPtr File = xmlOutputBufferCreateFile(out, CharEncodingHandler);
  if (File)
  {
    int v12 = File;
    htmlNodeDumpFormatOutput(File, doc, cur, 0LL, format);
    LODWORD(File) = xmlOutputBufferClose(v12);
  }

  return (int)File;
}

  input->unint64_t line = line;
  input->col = col;
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  if (!ctxt->progressive)
  {
    uint64_t v8 = input->cur;
    if (v8 - input->base < 501 || input->end - v8 > 499)
    {
LABEL_13:
      if (input->end - v8 <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      goto LABEL_15;
    }

    xmlSHRINK((uint64_t)ctxt);
    if (!ctxt->progressive)
    {
      xmlParserInputPtr input = ctxt->input;
      uint64_t v8 = input->cur;
      goto LABEL_13;
    }
  }

    char v14 = (int)v11[74];
    *(void *)(*((void *)v11 + 38) + 8 * v14) = a2;
    *((void *)v11 + 36) = a2;
    int v15 = *((void *)v11 + 67) + 24LL * (int)v14;
    *(void *)int v15 = a3;
    *(void *)(v15 + 8) = a4;
    *(_DWORD *)(v15 + 16) = a5;
    *(_DWORD *)(v15 + 20) = a6;
    v11[74] = v14 + 1;
    return result;
  }

  result[75] = 2 * v12;
  int v13 = xmlRealloc(*((void **)result + 38), 16 * v12);
  if (v13)
  {
    *((void *)v11 + 38) = v13;
    int result = xmlRealloc(*((void **)v11 + 67), 24LL * (int)v11[75]);
    if (result)
    {
      *((void *)v11 + 67) = result;
      goto LABEL_8;
    }
  }

  v11[75] /= 2;
  return htmlErrMemory(v11, 0LL);
}

  xmlRngPErrMemory(a1, (const xmlChar *)"allocating define\n");
  return 0LL;
}

    int v10 = (const xmlChar *)"(NULL)";
    goto LABEL_9;
  }

  if (!a3)
  {
    __int128 v9 = 0LL;
    goto LABEL_8;
  }

  return a3;
}

  PropNode = (xmlNode *)xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"id");
  if (PropNode) {
    xmlSchemaPValAttrNodeID(a1, PropNode);
  }
  size_t v11 = xmlSchemaGetPropNode((uint64_t)a3, (xmlChar *)"schemaLocation");
  if (!v11)
  {
    xmlSchemaPMissingAttrErr(a1, (uint64_t)a3, (xmlChar *)"schemaLocation");
    goto LABEL_18;
  }

  int v12 = (xmlNode *)v11;
  BuiltInType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI);
  if (!xmlSchemaPValAttrNode((_DWORD *)a1, v12, BuiltInType, &URI))
  {
    Base = xmlNodeGetBase(a3->doc, a3);
    if (Base)
    {
      int v15 = xmlBuildURI(URI, Base);
      xmlFree(Base);
      if (v15)
      {
LABEL_14:
        URI = (xmlChar *)xmlDictLookup(*(xmlDictPtr *)(a1 + 152), v15, -1);
        xmlFree(v15);
        BOOL v16 = xmlStrEqual(URI, *(const xmlChar **)(a1 + 80));
        unint64_t v17 = URI;
        if (!v16) {
          goto LABEL_20;
        }
        if (a4 == 3)
        {
          __int128 v18 = "The schema document '%s' cannot redefine itself.";
          __int128 v19 = a1;
          __int128 v20 = 3081;
        }

        else
        {
          __int128 v18 = "The schema document '%s' cannot include itself.";
          __int128 v19 = a1;
          __int128 v20 = 3050;
        }

        xmlSchemaPCustomErrExt(v19, v20, 0LL, (uint64_t)a3, (const xmlChar *)v18);
        goto LABEL_18;
      }
    }

    else
    {
      int v15 = xmlBuildURI(URI, a3->doc->URL);
      if (v15) {
        goto LABEL_14;
      }
    }

    xmlSchemaInternalErr2( (_DWORD *)a1,  (const xmlChar *)"xmlSchemaParseIncludeOrRedefine",  (const xmlChar *)"could not build an URI from the schemaLocation",  0LL);
    return 0xFFFFFFFFLL;
  }

  PropNode = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
  if (PropNode) {
    xmlSchemaPValAttrNodeID(a1, PropNode);
  }
  int v12 = (const xmlChar **)(v8 + 96);
  if (!xmlSchemaPValAttrQName( a1,  a2,  a3,  (xmlChar *)"base",  (const xmlChar **)(v8 + 104),  (const xmlChar **)(v8 + 96)))
  {
    int v15 = *v12;
    if (!*v12 && *(_DWORD *)v8 == 5) {
      goto LABEL_52;
    }
    if (!*(_DWORD *)(a1 + 188) || (*(_BYTE *)(v8 + 88) & 8) == 0) {
      goto LABEL_11;
    }
    if (!v15)
    {
LABEL_52:
      xmlSchemaPMissingAttrErr(a1, a3, (xmlChar *)"base");
      goto LABEL_11;
    }

    if (!xmlStrEqual(v15, *(const xmlChar **)(v8 + 16))
      || !xmlStrEqual(*(const xmlChar **)(v8 + 104), *(const xmlChar **)(v8 + 208)))
    {
      __int128 v71 = 0LL;
      __int128 v72 = 0LL;
      xmlSchemaFormatQName(&v72, *(const xmlChar **)(v8 + 104), *(xmlChar **)(v8 + 96));
      xmlSchemaFormatQName(&v71, *(const xmlChar **)(v8 + 208), *(xmlChar **)(v8 + 16));
      xmlSchemaPCustomErrExt( a1,  3081,  0LL,  a3,  (const xmlChar *)"This is a redefinition, but the QName value '%s' of the 'base' attribute does not match the typ e's designation '%s'");
      if (v72) {
        xmlFree(v72);
      }
      if (v71) {
        xmlFree(v71);
      }
      xmlOutputBuffer *v12 = 0LL;
      *(void *)(v8 + 104) = 0LL;
    }
  }

  PropNode = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
  if (PropNode) {
    xmlSchemaPValAttrNodeID(a1, PropNode);
  }
  if (!xmlSchemaPValAttrQName( a1,  a2,  a3,  (xmlChar *)"base",  (const xmlChar **)(v8 + 104),  (const xmlChar **)(v8 + 96))
    && !*(void *)(v8 + 96))
  {
    xmlSchemaPMissingAttrErr(a1, a3, (xmlChar *)"base");
  }

  int v12 = *(void *)(a3 + 24);
  unsigned int v29 = (xmlNode *)v12;
  if (!v12) {
    return;
  }
  if (*(void *)(v12 + 72)
    && xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"annotation")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(v12 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    int v13 = xmlSchemaParseAnnotation((_DWORD *)a1, v12, 1);
    xmlSchemaAddAnnotation(v8, (uint64_t)v13);
    int v12 = *(void *)(v12 + 48);
    unsigned int v29 = (xmlNode *)v12;
  }

  char v14 = a4 == 10;
  int v15 = a4 == 10;
  if (!v14) {
    goto LABEL_37;
  }
  if (!v12) {
    return;
  }
  if (!*(void *)(v12 + 72)) {
    goto LABEL_44;
  }
  BOOL v16 = xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"all");
  unint64_t v17 = *(void *)(v12 + 72);
  if (!v16)
  {
LABEL_26:
    if (v17)
    {
      __int128 v22 = xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"choice");
      int v23 = *(void *)(v12 + 72);
      if (v22)
      {
        if (xmlStrEqual(*(const xmlChar **)(v23 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          __int128 v18 = a1;
          __int128 v19 = a2;
          __int128 v20 = v12;
          __int128 v21 = 7;
          goto LABEL_35;
        }

        int v23 = *(void *)(v12 + 72);
      }

      if (v23)
      {
        uint64_t v24 = xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"sequence");
        BOOL v25 = *(void *)(v12 + 72);
        if (v24)
        {
          if (xmlStrEqual(*(const xmlChar **)(v25 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
          {
            __int128 v18 = a1;
            __int128 v19 = a2;
            __int128 v20 = v12;
            __int128 v21 = 6;
            goto LABEL_35;
          }

          BOOL v25 = *(void *)(v12 + 72);
        }

        if (v25
          && xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"group")
          && xmlStrEqual( *(const xmlChar **)(*(void *)(v12 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          int v26 = xmlSchemaParseModelGroupDefRef((_DWORD *)a1, a2, v12);
          goto LABEL_36;
        }
      }
    }

  PropNode = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
  if (PropNode) {
    xmlSchemaPValAttrNodeID(a1, PropNode);
  }
  __int128 v9 = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"memberTypes");
  if (v9)
  {
    int v28 = a3;
    uint64_t v31 = 0LL;
    xmlChar v32 = 0LL;
    NodeContent = xmlSchemaGetNodeContent(a1, v9);
    size_t v11 = 0LL;
    *(void *)(v5 + 96) = NodeContent;
    uint64_t v27 = v5;
    unsigned int v29 = (void *)(v5 + 168);
    int v12 = a2;
    while (1)
    {
      for (uint64_t i = NodeContent; ; ++i)
      {
        char v14 = *i;
        if (v14 > 0x20 || ((1LL << v14) & 0x100002600LL) == 0) {
          break;
        }
        ++NodeContent;
      }

      BOOL v16 = 0LL;
      if (!v16)
      {
LABEL_34:
        uint64_t v5 = v27;
        a3 = v28;
        break;
      }

      unint64_t v17 = xmlStrndup(i, v16);
      if (xmlSchemaPValAttrNodeQNameValue(a1, v12, (uint64_t)v9, v17, &v31, &v32))
      {
        if (v17) {
          goto LABEL_25;
        }
      }

      else
      {
        __int128 v18 = xmlMalloc(0x10uLL);
        if (!v18)
        {
          if (a1) {
            ++*(_DWORD *)(a1 + 36);
          }
          __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"xmlSchemaParseUnion, allocating a type link");
          return;
        }

        __int128 v19 = v18;
        xmlParserInput *v18 = 0LL;
        v18[1] = 0LL;
        __int128 v20 = v29;
        if (v11) {
          __int128 v20 = v11;
        }
        *__int128 v20 = v18;
        __int128 v21 = xmlSchemaNewQNameRef(a1, 4, (uint64_t)v32, (uint64_t)v31);
        if (!v21)
        {
          if (v17) {
            xmlFree(v17);
          }
          return;
        }

        v19[1] = v21;
        size_t v11 = v19;
        int v12 = a2;
        if (v17) {
LABEL_25:
        }
          xmlFree(v17);
      }

      NodeContent = &i[v16];
      if (!i[v16]) {
        goto LABEL_34;
      }
    }
  }

  __int128 v22 = *(void *)(a3 + 24);
  if (v22)
  {
    if (!*(void *)(v22 + 72)
      || !xmlStrEqual(*(const xmlChar **)(v22 + 16), (const xmlChar *)"annotation")
      || !xmlStrEqual( *(const xmlChar **)(*(void *)(v22 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
      || (int v23 = xmlSchemaParseAnnotation((_DWORD *)a1, v22, 1),
          xmlSchemaAddAnnotation(v5, (uint64_t)v23),
          (__int128 v22 = *(void *)(v22 + 48)) != 0))
    {
      if (*(void *)(v22 + 72)
        && xmlStrEqual(*(const xmlChar **)(v22 + 16), (const xmlChar *)"simpleType")
        && xmlStrEqual( *(const xmlChar **)(*(void *)(v22 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        uint64_t v24 = 0LL;
        while (*(void *)(v22 + 72)
             && xmlStrEqual(*(const xmlChar **)(v22 + 16), (const xmlChar *)"simpleType")
             && xmlStrEqual( *(const xmlChar **)(*(void *)(v22 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          BOOL v25 = xmlSchemaParseSimpleType(a1, a2, v22, 0LL);
          if (v25)
          {
            int v26 = (uint64_t *)(v24 + 8);
            if (!v24) {
              int v26 = (uint64_t *)(v5 + 56);
            }
            xmlParserInput *v26 = v25;
            *(void *)(v25 + 8) = 0LL;
            uint64_t v24 = v25;
          }

          __int128 v22 = *(void *)(v22 + 48);
          if (!v22) {
            goto LABEL_54;
          }
        }
      }

      xmlSchemaPContentErr(a1, 3033, a3, v22, 0LL, (xmlChar *)"(annotation?, simpleType*)");
    }
  }

  int v10 = xmlMalloc(0x28uLL);
  size_t v11 = v10;
  if (v10)
  {
    v10[4] = 0LL;
    *(_OWORD *)int v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    PropNode = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"xpath");
    if (PropNode)
    {
      int v13 = (uint64_t)PropNode;
      NodeContent = xmlSchemaGetNodeContent((uint64_t)a1, PropNode);
      v11[3] = NodeContent;
      if (!NodeContent)
      {
        __int128 v19 = "The XPath expression of the selector is not valid";
        __int128 v20 = (uint64_t)a1;
        __int128 v21 = v13;
LABEL_35:
        xmlSchemaPCustomErrExt(v20, 3037, 0LL, v21, (const xmlChar *)v19);
        goto LABEL_39;
      }

      NsList = xmlGetNsList(*(const xmlDoc **)(v13 + 64), *(const xmlNode **)(v13 + 40));
      if (NsList)
      {
        BOOL v16 = NsList;
        if (*NsList)
        {
          unint64_t v17 = 0LL;
          while (NsList[++v17])
            ;
        }

        else
        {
          LODWORD(v17) = 0;
        }

        int v23 = (char *)xmlMalloc(8LL * ((2 * (_DWORD)v17) | 1u));
        if (!v23)
        {
          if (a1) {
            ++a1[9];
          }
          __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"allocating a namespace array");
          xmlFree(v16);
          xmlSchemaPErr( (uint64_t)a1,  v13,  3069,  "Internal error: xmlSchemaParseIDCSelectorAndField, validating the XPath expression of a IDC selector.\n",  0LL,  0LL);
          goto LABEL_39;
        }

        __int128 v22 = (const xmlChar **)v23;
        if ((_DWORD)v17)
        {
          uint64_t v24 = v17;
          BOOL v25 = v23 + 8;
          int v26 = v16;
          do
          {
            *(v25 - 1) = (*v26)->href;
            uint64_t v27 = (uint64_t)*v26++;
            xmlChar *v25 = *(void *)(v27 + 24);
            v25 += 2;
            --v24;
          }

          while (v24);
        }

        *(void *)&v23[8 * (2 * v17)] = 0LL;
        xmlFree(v16);
      }

      else
      {
        __int128 v22 = 0LL;
      }

      if (a4) {
        int v28 = 4;
      }
      else {
        int v28 = 2;
      }
      unsigned int v29 = xmlPatterncompile((const xmlChar *)v11[3], 0LL, v28, v22);
      v11[4] = v29;
      if (v22)
      {
        xmlFree(v22);
        unsigned int v29 = (xmlPatternPtr)v11[4];
      }

      if (!v29)
      {
        __int128 v19 = "The XPath expression '%s' could not be compiled";
        __int128 v20 = (uint64_t)a1;
        __int128 v21 = v13;
        goto LABEL_35;
      }
    }

    else
    {
      xmlSchemaPMissingAttrErr((uint64_t)a1, a3, (xmlChar *)"name");
    }

    __int128 v9 = v7;
LABEL_9:
    xmlXPathReleaseObject((uint64_t)context, v9);
LABEL_10:
    xmlXPathErr(ctxt, 10);
    return 0;
  }

  xmlElementType type = v7->type;
  if ((v7->type | 8) != 9)
  {
    __int128 v20 = v17->type;
    if (v17->type == XPATH_XSLT_TREE) {
      goto LABEL_28;
    }
    if (v20 != XPATH_NUMBER)
    {
      if (v20 == XPATH_NODESET)
      {
LABEL_28:
        if (type != XPATH_NODESET) {
          goto LABEL_29;
        }
        goto LABEL_23;
      }

      valuePush(ctxt, v17);
      xmlXPathNumberFunction(ctxt, 1);
      int v23 = ctxt->valueNr;
      uint64_t v24 = v23 - 1;
      if (v23 < 1)
      {
        unint64_t v17 = 0LL;
      }

      else
      {
        ctxt->valueNr = v24;
        BOOL v25 = ctxt->valueTab;
        if (v23 == 1) {
          int v26 = 0LL;
        }
        else {
          int v26 = v25[v23 - 2];
        }
        ctxt->unsigned int value = v26;
        unint64_t v17 = v25[v24];
        v25[v24] = 0LL;
      }

      if (v17->type != XPATH_NUMBER)
      {
        xmlXPathFreeObject(v17);
        xmlXPathFreeObject(v7);
        goto LABEL_10;
      }

      xmlElementType type = v7->type;
    }

    if (type != XPATH_NUMBER)
    {
      valuePush(ctxt, v7);
      xmlXPathNumberFunction(ctxt, 1);
      uint64_t v27 = ctxt->valueNr;
      int v28 = ctxt->valueTab;
      unsigned int v29 = v27 - 1;
      ctxt->valueNr = v27 - 1;
      unsigned int v30 = v27 == 1 ? 0LL : v28[v27 - 2];
      ctxt->unsigned int value = v30;
      uint64_t v7 = v28[v29];
      v28[v29] = 0LL;
      if (v7->type != XPATH_NUMBER)
      {
        xmlXPathReleaseObject((uint64_t)ctxt->context, v17);
        goto LABEL_7;
      }
    }

    floatval = v17->floatval;
    xmlChar v32 = v7->floatval;
    int v33 = fabs(floatval);
    else {
      size_t v34 = -1;
    }
    if (v33 != INFINITY) {
      size_t v34 = 0;
    }
    int v35 = fabs(v32);
    if (v32 > 0.0) {
      BOOL v36 = 1;
    }
    else {
      BOOL v36 = -1;
    }
    if (v35 != INFINITY) {
      BOOL v36 = 0;
    }
    if (v13 && strict)
    {
      __int128 v37 = v32 > 0.0;
      if (v35 != INFINITY) {
        __int128 v37 = 1;
      }
      if (v34 != -1 || !v37)
      {
        int v38 = v32 <= 0.0 || v34 == 1;
        if (v38 || v35 != INFINITY)
        {
          __int128 v40 = floatval < v32;
LABEL_71:
          if (v35 == INFINITY) {
            __int128 v40 = 0;
          }
          int v10 = v33 != INFINITY && v40;
          goto LABEL_117;
        }
      }
    }

    else
    {
      if (v13 && !strict)
      {
        __int128 v41 = v32 > 0.0;
        if (v35 != INFINITY) {
          __int128 v41 = 0;
        }
        int v10 = 1;
        if (v34 != -1)
        {
          __int128 v42 = floatval <= v32;
          if (v35 == INFINITY) {
            __int128 v42 = 0;
          }
          if (v33 == INFINITY) {
            __int128 v42 = 0;
          }
          int v10 = v41 || v42;
        }

        goto LABEL_117;
      }

      if (v13 || !strict)
      {
        if (strict | v13)
        {
          int v10 = 0;
LABEL_117:
          xmlXPathReleaseObject((uint64_t)ctxt->context, v17);
          xmlXPathReleaseObject((uint64_t)ctxt->context, v7);
          return v10;
        }

        if ((v33 != INFINITY || floatval <= 0.0) && v36 != -1)
        {
          __int128 v40 = floatval >= v32;
          goto LABEL_71;
        }
      }

      else if (floatval <= 0.0 || v36 == 1 || v33 != INFINITY)
      {
        int v45 = v33 == INFINITY && floatval <= 0.0;
        if (v45 || v36 != -1)
        {
          __int128 v40 = floatval > v32;
          goto LABEL_71;
        }
      }
    }

    int v10 = 1;
    goto LABEL_117;
  }

void htmlNodeDumpFormatOutput( xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, const char *encoding, int format)
{
  if (buf && cur)
  {
    parent = cur->parent;
    xmlNodePtr children = cur;
LABEL_4:
    while (2)
    {
      int v10 = parent;
      parent = children;
      switch(children->type)
      {
        case XML_ELEMENT_NODE:
          if (children->parent != v10 && children->children)
          {
            htmlNodeDumpFormatOutput(buf, doc, children, encoding, format);
            goto LABEL_87;
          }

          if (children->ns) {
            __int128 v22 = 0LL;
          }
          else {
            __int128 v22 = htmlTagLookup(children->name);
          }
          xmlOutputBufferWriteString(buf, "<");
          ns = parent->ns;
          if (ns)
          {
            prefix = (const char *)ns->prefix;
            if (prefix)
            {
              xmlOutputBufferWriteString(buf, prefix);
              xmlOutputBufferWriteString(buf, ":");
            }
          }

          int v48 = v22;
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          nsDef = parent->nsDef;
          if (nsDef) {
            xmlNsListDumpOutput((uint64_t)buf, nsDef);
          }
          if (!v48)
          {
            p_xmlNodePtr children = &parent->children;
            if (parent->children)
            {
              int v33 = ">";
LABEL_66:
              xmlOutputBufferWriteString(buf, v33);
LABEL_67:
              xmlNodePtr children = *p_children;
              continue;
            }

            goto LABEL_72;
          }

          if (!v48->empty)
          {
            p_xmlNodePtr children = &parent->children;
            if (parent->children)
            {
              xmlOutputBufferWriteString(buf, ">");
              if (!format || v48->isinline) {
                goto LABEL_67;
              }
              xmlElementType type = (*p_children)->type;
              if (type == XML_TEXT_NODE || type == XML_ENTITY_REF_NODE) {
                goto LABEL_67;
              }
              if (*p_children == parent->last) {
                goto LABEL_67;
              }
              name = parent->name;
              if (!name) {
                goto LABEL_67;
              }
              int v33 = "\n";
              if (*name == 112) {
                goto LABEL_67;
              }
              goto LABEL_66;
            }

            if (!v48->saveEndTag
              || !xmlStrcmp((const xmlChar *)v48->name, (const xmlChar *)"html")
              || !xmlStrcmp((const xmlChar *)v48->name, (const xmlChar *)"body"))
            {
LABEL_72:
              xmlOutputBufferWriteString(buf, "></");
              size_t v34 = parent->ns;
              if (v34)
              {
                int v35 = (const char *)v34->prefix;
                if (v35)
                {
                  xmlOutputBufferWriteString(buf, v35);
                  xmlOutputBufferWriteString(buf, ":");
                }
              }

              xmlOutputBufferWriteString(buf, (const char *)parent->name);
            }
          }

          xmlOutputBufferWriteString(buf, ">");
          if (!format) {
            goto LABEL_87;
          }
          if (!v48) {
            goto LABEL_87;
          }
          next = parent->next;
          if (!next || v48->isinline) {
            goto LABEL_87;
          }
LABEL_80:
          xmlElementType v37 = next->type;
          if (v37 == XML_TEXT_NODE) {
            goto LABEL_87;
          }
          if (v37 == XML_ENTITY_REF_NODE) {
            goto LABEL_87;
          }
          if (!v10) {
            goto LABEL_87;
          }
          int v38 = v10->name;
          if (!v38 || *v38 == 112) {
            goto LABEL_87;
          }
LABEL_85:
          __int128 v21 = buf;
          content = "\n";
LABEL_86:
          xmlOutputBufferWriteString(v21, content);
LABEL_87:
          while (parent != cur)
          {
            xmlNodePtr children = parent->next;
            parent = v10;
            if (children) {
              goto LABEL_4;
            }
            int v10 = v10->parent;
            if ((parent->type | 4) == 0xD) {
              goto LABEL_85;
            }
            if (format && !parent->ns)
            {
              int v43 = htmlTagLookup(parent->name);
              __int128 v40 = v43;
              if (v43)
              {
                if (!v43->isinline)
                {
                  last = parent->last;
                  xmlElementType v45 = last->type;
                  if (v45 != XML_TEXT_NODE && v45 != XML_ENTITY_REF_NODE && parent->children != last)
                  {
                    int v47 = parent->name;
                    if (v47)
                    {
                      if (*v47 != 112) {
                        xmlOutputBufferWriteString(buf, "\n");
                      }
                    }
                  }
                }

                int v39 = 1;
              }

              else
              {
                int v39 = 0;
              }
            }

            else
            {
              int v39 = 0;
              __int128 v40 = 0LL;
            }

            xmlOutputBufferWriteString(buf, "</");
            __int128 v41 = parent->ns;
            if (v41)
            {
              __int128 v42 = (const char *)v41->prefix;
              if (v42)
              {
                xmlOutputBufferWriteString(buf, v42);
                xmlOutputBufferWriteString(buf, ":");
              }
            }

            xmlOutputBufferWriteString(buf, (const char *)parent->name);
            xmlOutputBufferWriteString(buf, ">");
            if (v39)
            {
              if (!v40->isinline)
              {
                next = parent->next;
                if (next) {
                  goto LABEL_80;
                }
              }
            }
          }

          break;
        case XML_ATTRIBUTE_NODE:
          htmlAttrDumpOutput(buf, doc, (uint64_t)children);
          goto LABEL_87;
        case XML_TEXT_NODE:
          content = (const char *)children->content;
          if (!content) {
            goto LABEL_87;
          }
          if (children->name == "textnoenc" && "text" != "textnoenc") {
            goto LABEL_25;
          }
          if (!v10) {
            goto LABEL_22;
          }
          if (xmlStrcasecmp(v10->name, (const xmlChar *)"script"))
          {
            int v18 = xmlStrcasecmp(v10->name, (const xmlChar *)"style");
            content = (const char *)parent->content;
            if (v18)
            {
LABEL_22:
              __int128 v19 = xmlEncodeEntitiesReentrant(doc, (const xmlChar *)content);
              if (v19)
              {
                __int128 v20 = v19;
                xmlOutputBufferWriteString(buf, (const char *)v19);
                xmlFree(v20);
              }

              goto LABEL_87;
            }
          }

          else
          {
            content = (const char *)parent->content;
          }

LABEL_25:
          __int128 v21 = buf;
          goto LABEL_86;
        case XML_CDATA_SECTION_NODE:
          content = (const char *)children->content;
          if (content) {
            goto LABEL_25;
          }
          goto LABEL_87;
        case XML_ENTITY_REF_NODE:
          xmlOutputBufferWriteString(buf, "&");
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          __int128 v21 = buf;
          content = ";";
          goto LABEL_86;
        case XML_PI_NODE:
          if (!children->name) {
            goto LABEL_87;
          }
          xmlOutputBufferWriteString(buf, "<?");
          xmlOutputBufferWriteString(buf, (const char *)parent->name);
          if (parent->content)
          {
            xmlOutputBufferWriteString(buf, " ");
            xmlOutputBufferWriteString(buf, (const char *)parent->content);
          }

          __int128 v21 = buf;
          content = ">";
          goto LABEL_86;
        case XML_COMMENT_NODE:
          if (!children->content) {
            goto LABEL_87;
          }
          xmlOutputBufferWriteString(buf, "<!--");
          xmlOutputBufferWriteString(buf, (const char *)parent->content);
          __int128 v21 = buf;
          content = "-->";
          goto LABEL_86;
        case XML_DOCUMENT_NODE:
        case XML_HTML_DOCUMENT_NODE:
          size_t v11 = children->content;
          if (!v11) {
            goto LABEL_40;
          }
          xmlOutputBufferWriteString(buf, "<!DOCTYPE ");
          xmlOutputBufferWriteString(buf, *((const char **)v11 + 2));
          if (*((void *)v11 + 13))
          {
            xmlOutputBufferWriteString(buf, " PUBLIC ");
            xmlBufWriteQuotedString((uint64x2_t *)buf->buffer, *((xmlChar **)v11 + 13));
            uint64_t v13 = *((void *)v11 + 14);
            int v12 = (xmlChar **)(v11 + 112);
            if (!v13) {
              goto LABEL_39;
            }
            char v14 = buf;
            int v15 = " ";
            goto LABEL_38;
          }

          uint64_t v24 = (const xmlChar *)*((void *)v11 + 14);
          int v12 = (xmlChar **)(v11 + 112);
          int v23 = v24;
          if (v24 && xmlStrcmp(v23, (const xmlChar *)"about:legacy-compat"))
          {
            char v14 = buf;
            int v15 = " SYSTEM ";
LABEL_38:
            xmlOutputBufferWriteString(v14, v15);
            xmlBufWriteQuotedString((uint64x2_t *)buf->buffer, *v12);
          }

  xmlParserInputState instate = ctxt->instate;
  if (instate == XML_PARSER_EOF) {
    return 0LL;
  }
  if (PredefinedEntity)
  {
    exmlElementType type = PredefinedEntity->etype;
    if (etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)
    {
      __int128 v9 = "Entity reference to unparsed entity %s\n";
      int v10 = ctxt;
      size_t v11 = 28;
LABEL_36:
      xmlFatalErrMsgStr(v10, v11, (uint64_t)v9, (uint64_t)v3);
      return PredefinedEntity;
    }

    if (instate == XML_PARSER_ATTRIBUTE_VALUE && etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
    {
      __int128 v9 = "Attribute references external entity '%s'\n";
      int v10 = ctxt;
      size_t v11 = 29;
      goto LABEL_36;
    }

    if (instate != XML_PARSER_ATTRIBUTE_VALUE)
    {
      if ((etype & 0xFFFFFFFE) != 4) {
        return PredefinedEntity;
      }
      __int128 v9 = "Attempt to reference the parameter entity '%s'\n";
      int v10 = ctxt;
      size_t v11 = 30;
      goto LABEL_36;
    }

    if (etype != XML_INTERNAL_PREDEFINED_ENTITY)
    {
      checked = PredefinedEntity->checked;
      if (!checked || (checked & 1) != 0)
      {
        content = PredefinedEntity->content;
        if (content)
        {
          if (xmlStrchr(content, 0x3Cu))
          {
            __int128 v9 = "'<' in entity '%s' is not allowed in attributes values\n";
            int v10 = ctxt;
            size_t v11 = 38;
            goto LABEL_36;
          }
        }
      }
    }
  }

  else
  {
    if (ctxt->standalone != 1 && (ctxt->hasExternalSubset || ctxt->hasPErefs))
    {
      xmlErrMsgStr(ctxt, 27, (uint64_t)"Entity '%s' not defined\n", (uint64_t)v3);
      if (!ctxt->inSubset)
      {
        if (ctxt->sax)
        {
          reference = ctxt->sax->reference;
          if (reference) {
            ((void (*)(void *, const xmlChar *))reference)(ctxt->userData, v3);
          }
        }
      }
    }

    else
    {
      xmlFatalErrMsgStr(ctxt, 26, (uint64_t)"Entity '%s' not defined\n", (uint64_t)v3);
    }

    xmlParserEntityCheck((uint64_t)ctxt, 0LL, 0LL, 0LL);
    xmlEntityPtr PredefinedEntity = 0LL;
    ctxt->valid = 0;
  }

  return PredefinedEntity;
}

  xmlParseEncodingDecl(ctxt);
  if (ctxt->errNo != 32 && ctxt->instate != XML_PARSER_EOF)
  {
    size_t v11 = ctxt->input;
    if (v11->encoding)
    {
      int v12 = v11->cur;
      char v14 = *v12;
      if (v14 > 0x3F)
      {
LABEL_32:
        xmlFatalErrMsg(ctxt, 65);
        goto LABEL_33;
      }

      if (((1LL << v14) & 0x100002600LL) == 0)
      {
        if (v14 == 63 && v12[1] == 62) {
          goto LABEL_39;
        }
        goto LABEL_32;
      }
    }

    int v12 = 0LL;
    goto LABEL_26;
  }

  if (v5 != 58) {
    return 0LL;
  }
  int v6 = xmlParseName((xmlParserCtxtPtr)a1);
  if (v6)
  {
    xmlNsErr((_DWORD *)a1, 202, (uint64_t)"Failed to parse QName '%s'\n", (uint64_t)v6, 0LL, 0LL);
    goto LABEL_25;
  }

  return v6;
}

    xmlRngVErrMemory(a1, (const xmlChar *)"pushing error\n");
    return;
  }

  if (*(_DWORD *)(a1 + 80)) {
    xmlRelaxNGDumpValidError(a1);
  }
  int v15 = *(uint64_t **)(a1 + 96);
  if (v15)
  {
    BOOL v16 = *v15;
    unint64_t v17 = v15[1];
  }

  else
  {
    BOOL v16 = 0LL;
    unint64_t v17 = 0LL;
  }

  if (!(v16 | v17)) {
    BOOL v16 = *(void *)(a1 + 168);
  }
  xmlRelaxNGShowValidError(a1, a2, v16, v17, cur, a4);
}

    size_t v11 = cur->nsDef;
    if (v11)
    {
      if (!dict)
      {
LABEL_29:
        xmlFree(v11);
        goto LABEL_30;
      }

      if (!xmlDictOwns(dict, (const xmlChar *)v11))
      {
        size_t v11 = cur->nsDef;
        goto LABEL_29;
      }
    }

          if (!v2->content)
          {
            int v10 = (xmlChar *)xmlMallocAtomic(v6);
LABEL_29:
            __int128 v9 = v10;
            if (!v10) {
              goto LABEL_37;
            }
LABEL_35:
            v2->content = v9;
            v2->unsigned int size = v6;
            v9[v2->use] = 0;
            break;
          }

          if (v4 - v2->use <= 0x63)
          {
            int v10 = (xmlChar *)xmlRealloc(v2->content, v6);
            goto LABEL_29;
          }

          size_t v11 = (xmlChar *)xmlMallocAtomic(v6);
          if (v11)
          {
            __int128 v9 = v11;
            memcpy(v11, v2->content, v2->use);
            xmlFree(v2->content);
            goto LABEL_35;
          }

      if (ctxt)
      {
        BOOL v16 = 0LL;
      }

      else
      {
        BOOL v16 = xmlDOMWrapStoreNs((uint64_t)doc, ns->href, ns->prefix);
        if (v16)
        {
          if (xmlDOMWrapNSNormAddNsMapItem2( (void **)&v18,  (int *)&v17 + 1,  (int *)&v17,  (uint64_t)v10->ns,  (uint64_t)v16) == -1) {
            uint64_t v4 = -1;
          }
        }

        else
        {
          uint64_t v4 = -1;
        }
      }

      v10->ns = v16;
LABEL_35:
      if (v10->type != XML_ELEMENT_NODE) {
        goto LABEL_38;
      }
      properties = (xmlNodePtr)v10->properties;
      if (!properties) {
        goto LABEL_37;
      }
    }

    int v15 = v18 + 1;
    while (ns != *(v15 - 1))
    {
      v15 += 2;
      if (!--v14) {
        goto LABEL_25;
      }
    }

    v10->ns = *v15;
    if (v10->type != XML_ELEMENT_NODE) {
      break;
    }
LABEL_37:
    properties = v10->children;
    if (!properties)
    {
LABEL_38:
      while (1)
      {
        properties = v10->next;
        if (properties) {
          break;
        }
        int v10 = v10->parent;
        if (!v10) {
          goto LABEL_40;
        }
      }
    }
  }

  if (v10) {
    goto LABEL_38;
  }
LABEL_40:
  if (v18) {
    xmlFree(v18);
  }
  return v4;
}

    if (v13 != (xmlChar *)v39 && v13 != elem->name) {
      xmlFree(v13);
    }
    if (DtdAttrDesc) {
      goto LABEL_40;
    }
  }

  __int128 v22 = attr->ns;
  int v23 = doc->intSubset;
  if (v22)
  {
    if (!v23
      || (uint64_t v24 = (xmlHashTable *)v23->attributes) == 0LL
      || (DtdAttrDesc = (char *)xmlHashLookup3(v24, attr->name, v22->prefix, elem->name)) == 0LL)
    {
      BOOL v25 = doc->extSubset;
      if (v25)
      {
        int v26 = (xmlHashTable *)v25->attributes;
        if (v26)
        {
          uint64_t v27 = (char *)xmlHashLookup3(v26, attr->name, attr->ns->prefix, elem->name);
          goto LABEL_39;
        }
      }

      goto LABEL_42;
    }
  }

  else
  {
    DtdAttrDesc = (char *)xmlGetDtdAttrDesc(v23, elem->name, attr->name);
    if (!DtdAttrDesc)
    {
      int v28 = doc->extSubset;
      if (v28)
      {
        uint64_t v27 = (char *)xmlGetDtdAttrDesc(v28, elem->name, attr->name);
LABEL_39:
        DtdAttrDesc = v27;
        if (v27) {
          goto LABEL_40;
        }
      }

  if (v14 != (xmlChar *)v79 && v14 != elem->name) {
    xmlFree(v14);
  }
  if (DtdAttrDesc) {
    goto LABEL_40;
  }
LABEL_29:
  int v23 = ns->prefix;
  uint64_t v24 = doc->intSubset;
  if (v23)
  {
    if (v24)
    {
      BOOL v25 = (xmlHashTable *)v24->attributes;
      if (v25)
      {
        DtdAttrDesc = (char *)xmlHashLookup3(v25, v23, (const xmlChar *)"xmlns", elem->name);
        if (DtdAttrDesc) {
          goto LABEL_40;
        }
      }
    }

    int v26 = doc->extSubset;
    if (!v26) {
      goto LABEL_42;
    }
    uint64_t v27 = (xmlHashTable *)v26->attributes;
    if (!v27) {
      goto LABEL_42;
    }
    int v28 = (char *)xmlHashLookup3(v27, ns->prefix, (const xmlChar *)"xmlns", elem->name);
LABEL_39:
    DtdAttrDesc = v28;
    if (v28) {
      goto LABEL_40;
    }
LABEL_42:
    uint64_t v31 = ns->prefix;
    xmlChar v32 = (xmlChar *)elem->name;
    if (v31)
    {
      int v33 = "No declaration for attribute xmlns:%s of element %s\n";
      size_t v34 = (uint64_t *)ctxt;
      int v35 = (int)elem;
    }

    else
    {
      int v33 = "No declaration for attribute xmlns of element %s\n";
      size_t v34 = (uint64_t *)ctxt;
      int v35 = (int)elem;
      uint64_t v31 = elem->name;
      xmlChar v32 = 0LL;
    }

    xmlErrValidNode(v34, v35, 533, (uint64_t)v33, (uint64_t)v31, v32, 0LL);
    return 0;
  }

  DtdAttrDesc = (char *)xmlGetDtdAttrDesc(v24, elem->name, (const xmlChar *)"xmlns");
  if (!DtdAttrDesc)
  {
    unsigned int v29 = doc->extSubset;
    if (!v29) {
      goto LABEL_42;
    }
    int v28 = (char *)xmlGetDtdAttrDesc(v29, elem->name, (const xmlChar *)"xmlns");
    goto LABEL_39;
  }

    xmlSchemaPSimpleTypeErr(a1, 3037, v8, 0LL, a4, NodeContent, 0LL, 0);
  }

  return 1LL;
}

        int v18 = v7;
        __int128 v19 = v6;
        __int128 v20 = v7;
        do
        {
          __int128 v21 = *--v20;
          xmlParserInput *v18 = v21;
          if (v19 == -1LL) {
            break;
          }
          int v18 = v20;
          unint64_t v17 = v19-- >= v8;
        }

        while (v17);
        goto LABEL_28;
      }

  BOOL v16 = *(void *)(a1 + 8);
  if (!v16) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  HIDWORD(v20) = *(_DWORD *)(v16 + 8) - 1;
  LODWORD(v20) = HIDWORD(v20);
  __int128 v19 = v20 >> 1;
  if (v19 > 0xA) {
    return v4;
  }
  unint64_t v17 = 1;
  int v15 = *(xmlNodePtr *)(a1 + 8);
  if (((1 << v19) & 0x471) == 0) {
    return v4;
  }
LABEL_28:
  StreamCtxt = xmlPatternGetStreamCtxt(comp);
  if (!StreamCtxt) {
    return 0LL;
  }
  __int128 v22 = StreamCtxt;
  int v23 = xmlStreamWantsAnyNode(StreamCtxt);
  if ((v17 & 1) == 0 && xmlStreamPush(v22, 0LL, 0LL) == 1)
  {
    if (a4)
    {
LABEL_32:
      uint64_t v4 = 1LL;
      goto LABEL_37;
    }

    xmlXPathNodeSetAddUnique(*(xmlNodeSetPtr *)(*(void *)a3 + 8LL), v15);
  }

  if (v15->type == XML_NAMESPACE_DECL) {
    goto LABEL_36;
  }
  BOOL v25 = 0;
  while (1)
  {
    xmlNodePtr children = v15->children;
    uint64_t v27 = children && v25 < v10;
    if (!v27) {
      break;
    }
    xmlElementType type = children->type;
    if (type == XML_ENTITY_DECL) {
      break;
    }
    ++v25;
    if (type == XML_DTD_NODE) {
      goto LABEL_47;
    }
LABEL_69:
    if (v25 < 0) {
      goto LABEL_36;
    }
LABEL_70:
    int v15 = children;
LABEL_71:
    if (linkedOnOrAfterFall2022OSVersions())
    {
      BOOL v36 = *(void *)(a1 + 352);
      if (v36)
      {
        xmlElementType v37 = *(void *)(a1 + 360);
        if (v37 >= v36)
        {
          xmlElementType v45 = *__xmlGenericError();
          int v46 = __xmlGenericErrorContext();
          v45(*v46, "XPath operation limit exceeded\n");
          uint64_t v4 = 0xFFFFFFFFLL;
          goto LABEL_37;
        }

        *(void *)(a1 + 360) = v37 + 1;
      }
    }

    int v38 = v15->type;
    if (v38 <= 8)
    {
      if (((1 << v38) & 0x198) != 0)
      {
        if (v23)
        {
          int v39 = xmlStreamPushNode(v22, 0LL, 0LL, v38);
LABEL_84:
          if (v39 == 1)
          {
            if (a4) {
              goto LABEL_32;
            }
            if (xmlXPathNodeSetAddUnique(*(xmlNodeSetPtr *)(*(void *)a3 + 8LL), v15) < 0) {
              *(void *)(a1 + 232) = 0x20000000CLL;
            }
          }

          if (!v15->children || v25 >= v10)
          {
            xmlStreamPop(v22);
            while (1)
            {
              next = v15->next;
              if (!next) {
                break;
              }
              int v15 = v15->next;
              int v43 = next->type;
              if (v43 != XML_ENTITY_DECL && v43 != XML_DTD_NODE) {
                goto LABEL_71;
              }
            }
          }
        }
      }

      else if (v38 == 1)
      {
        ns = v15->ns;
        if (ns) {
          href = ns->href;
        }
        else {
          href = 0LL;
        }
        int v39 = xmlStreamPush(v22, v15->name, href);
        goto LABEL_84;
      }
    }

    uint64_t v4 = 0LL;
    if (v15->type == XML_NAMESPACE_DECL) {
      goto LABEL_37;
    }
  }

  xmlNodePtr children = v15;
LABEL_47:
  if (children != (_xmlNode *)v16)
  {
    while (1)
    {
      unsigned int v29 = children->next;
      if (!v29) {
        break;
      }
      xmlNodePtr children = children->next;
      unsigned int v30 = v29->type;
      if (v30 != XML_DTD_NODE && v30 != XML_ENTITY_DECL) {
        goto LABEL_70;
      }
    }

    while (1)
    {
      xmlNodePtr children = children->parent;
      if (!children || children == (_xmlNode *)v16) {
        break;
      }
      int v33 = children->type;
      if (v33 == 1) {
        goto LABEL_65;
      }
      if (v33 == 9) {
        break;
      }
      if (v23)
      {
        uint64_t v27 = v33 > 8;
        size_t v34 = (1 << v33) & 0x198;
        if (!v27 && v34 != 0) {
LABEL_65:
        }
          xmlStreamPop(v22);
      }

      --v25;
      if (children->next)
      {
        xmlNodePtr children = children->next;
        goto LABEL_69;
      }
    }
  }

    if (++v12 >= *user) {
      goto LABEL_26;
    }
  }

  char v14 = *(void *)(v13 + 56);
  if (!v14) {
    goto LABEL_25;
  }
  if ((*(_DWORD *)(v14 + 8) | 0x10) != 0x12)
  {
    int v15 = *(_DWORD *)(v13 + 64);
LABEL_23:
    BOOL v16 = (xmlXPathObject *)xmlXPtrNewPoint(v14, v15);
    if (v16) {
      xmlXPtrLocationSetAdd(v10, v16);
    }
    goto LABEL_25;
  }

  xmlXPathFreeObject(v7);
  xmlXPtrFreeLocationSet(v10);
  ctxt = v2;
  int v18 = 16;
LABEL_33:
  xmlXPathErr(ctxt, v18);
}

LABEL_39:
          xmlOutputBufferWriteString(buf, ">\n");
LABEL_40:
          xmlNodePtr children = parent->children;
          if (!children) {
            goto LABEL_85;
          }
          if (parent->parent != v10) {
            goto LABEL_87;
          }
          continue;
        default:
          goto LABEL_87;
      }

      break;
    }
  }

      xmlFatalErrMsg(ctxt, ctxt->errNo);
      return v7;
    }

    goto LABEL_34;
  }

  if (v6 != 73)
  {
    if (v6 == 82
      && cur[2] == 69
      && cur[3] == 81
      && cur[4] == 85
      && cur[5] == 73
      && cur[6] == 82
      && cur[7] == 69
      && cur[8] == 68)
    {
      input->cur = cur + 9;
      input->col += 9;
      if (!cur[9]) {
        xmlParserInputGrow(input, 250);
      }
      return 2;
    }

    goto LABEL_34;
  }

  if (cur[2] != 77 || cur[3] != 80 || cur[4] != 76 || cur[5] != 73 || cur[6] != 69 || cur[7] != 68)
  {
LABEL_34:
    uint64_t v7 = 1;
    goto LABEL_35;
  }

  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8]) {
    xmlParserInputGrow(input, 250);
  }
  return 3;
}

            int v12 = 0;
            a2 = (a2 - 4096);
            *((_DWORD *)a1 + 141) |= 0x1000u;
LABEL_40:
            *((_DWORD *)a1 + 142) = v12;
            if ((a2 & 0x4000) != 0)
            {
              *(void *)(*a1 + 200) = 0LL;
              a2 = (a2 - 0x4000);
              *((_DWORD *)a1 + 141) |= 0x4000u;
              if ((a2 & 0x2000) == 0)
              {
LABEL_42:
                if ((a2 & 0x800) == 0) {
                  goto LABEL_43;
                }
                goto LABEL_50;
              }
            }

            else if ((a2 & 0x2000) == 0)
            {
              goto LABEL_42;
            }

            *((_DWORD *)a1 + 141) |= 0x2000u;
            a2 = (a2 - 0x2000);
            if ((a2 & 0x800) == 0)
            {
LABEL_43:
              if ((a2 & 0x10000) == 0) {
                goto LABEL_44;
              }
              goto LABEL_51;
            }

        ((void (*)(xmlChar *))xmlFree)(v15);
      }

      else if (v6 == 3 && !xmlGetID(*(xmlDocPtr *)(v3 + 56), (const xmlChar *)a2[1]))
      {
        xmlErrValidNode( (uint64_t *)v3,  *(void *)(v5 + 40),  536,  (uint64_t)"IDREF attribute %s references an unknown ID %s\n",  *(void *)(v5 + 16),  v4,  0LL);
LABEL_41:
        *(_DWORD *)(v3 + 64) = 0;
      }
    }

    else if (*(void *)(a1 + 24))
    {
      uint64_t v7 = xmlStrdup((const xmlChar *)a2[1]);
      if (!v7) {
        goto LABEL_41;
      }
      uint64_t v8 = v7;
      __int128 v9 = *v7;
      if (*v7)
      {
        int v10 = v7;
        while (1)
        {
LABEL_11:
          size_t v11 = v10;
          while (v9 > 0x20 || ((1LL << v9) & 0x100002601LL) == 0)
          {
            int v12 = *++v11;
            __int128 v9 = v12;
          }

          *size_t v11 = 0;
          if (!xmlGetID(*(xmlDocPtr *)(v3 + 56), v10))
          {
            xmlErrValidNodeNr( (uint64_t *)v3,  0,  536,  (uint64_t)"attribute %s line %d references an unknown ID %s\n",  *(void *)(a1 + 24),  *(_DWORD *)(a1 + 32),  v10);
            *(_DWORD *)(v3 + 64) = 0;
          }

          if (!v9) {
            break;
          }
          *size_t v11 = v9;
          int v10 = v11;
          while (v9 <= 0x20)
          {
            if (((1LL << v9) & 0x100002600LL) == 0)
            {
              if (v9) {
                goto LABEL_11;
              }
              goto LABEL_23;
            }

            uint64_t v13 = *++v10;
            __int128 v9 = v13;
          }
        }
      }

        xmlAttrDumpOutput(v3, v17);
        unint64_t v17 = *(void *)(v17 + 48);
        if (!v17)
        {
          if (str)
          {
            if (!v18)
            {
              if (v77)
              {
                int v38 = *(const xmlChar **)(v77 + 16);
                if (v38)
                {
                  if (xmlStrEqual(v38, (const xmlChar *)"a")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"p")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"div")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"img")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"map")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"applet")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"form")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"frame")
                    || xmlStrEqual(*(const xmlChar **)(v77 + 16), (const xmlChar *)"iframe"))
                  {
                    xmlOutputBufferWrite(out, 5, " id=");
                    xmlAttrSerializeContent((uint64_t)out, (uint64_t)str);
                    xmlOutputBufferWrite(out, 1, "");
                  }
                }
              }
            }
          }

          int v39 = v76;
          if (v76 && !v19)
          {
            xmlOutputBufferWrite(out, 11, " xml:lang=");
            goto LABEL_102;
          }

          if (v19 && !v76)
          {
            xmlOutputBufferWrite(out, 7, " lang=");
            int v39 = v19;
LABEL_102:
            xmlAttrSerializeContent((uint64_t)out, v39);
            xmlOutputBufferWrite(out, 1, "");
          }

    unsigned int v30 = (xmlNode *)xmlSchemaGetPropNode(a3, (xmlChar *)"id");
    if (v30) {
      xmlSchemaPValAttrNodeID((uint64_t)a1, v30);
    }
    uint64_t v31 = *(void *)(a3 + 24);
    if (v31)
    {
      if (!*(void *)(v31 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v31 + 16), (const xmlChar *)"annotation")
        || !xmlStrEqual( *(const xmlChar **)(*(void *)(v31 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
        || (xmlChar v32 = xmlSchemaParseAnnotation(a1, v31, 1),
            xmlSchemaAddAnnotation(a2, (uint64_t)v32),
            (uint64_t v31 = *(void *)(v31 + 48)) != 0))
      {
        xmlSchemaPContentErr((uint64_t)a1, 3033, a3, v31, 0LL, (xmlChar *)"(annotation?)");
      }
    }

    return v11;
  }

  if (a1) {
    ++a1[9];
  }
  __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"allocating a 'selector' of an identity-constraint definition");
  return v11;
}

      valueTab[v23] = 0LL;
LABEL_40:
      int v28 = v4->floatval;
      unsigned int v29 = v3->floatval;
      unsigned int v30 = fabs(v28);
      if (v28 > 0.0) {
        uint64_t v31 = 1;
      }
      else {
        uint64_t v31 = -1;
      }
      if (v30 != INFINITY) {
        uint64_t v31 = 0;
      }
      if (v31 == -1)
      {
        xmlChar v32 = -INFINITY;
        goto LABEL_49;
      }

      if (v31 == 1)
      {
        xmlChar v32 = INFINITY;
LABEL_49:
        __int128 v21 = v29 == v32;
        goto LABEL_50;
      }

      int v33 = fabs(v29);
      if (v29 > 0.0) {
        size_t v34 = 1;
      }
      else {
        size_t v34 = -1;
      }
      if (v33 != INFINITY) {
        size_t v34 = 0;
      }
      if (v34 == -1 || v34 == 1)
      {
LABEL_3:
        uint64_t v8 = 0LL;
        goto LABEL_4;
      }

      __int128 v21 = v28 == v29;
LABEL_50:
      uint64_t v8 = v21;
LABEL_4:
      xmlXPathReleaseObject((uint64_t)ctxt->context, v4);
      xmlXPathReleaseObject((uint64_t)ctxt->context, v3);
      return v8;
    case XPATH_POINT:
    case XPATH_RANGE:
    case XPATH_LOCATIONSET:
    case XPATH_USERS:
      int v6 = *__xmlGenericError();
      uint64_t v7 = *__xmlGenericErrorContext();
      v6(v7, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xpath.c", 7071);
      goto LABEL_3;
    default:
      goto LABEL_3;
  }

void htmlNodeDumpFile(FILE *out, xmlDocPtr doc, xmlNodePtr cur)
{
}

void htmlDocDumpMemoryFormat(xmlDocPtr cur, xmlChar **mem, int *size, int format)
{
  if (!mem || !size) {
    return;
  }
  if (!cur)
  {
LABEL_15:
    *mem = 0LL;
    *unsigned int size = 0;
    return;
  }

  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (MetaEncoding)
  {
    __int128 v9 = MetaEncoding;
    if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v9);
      if (CharEncodingHandler) {
        goto LABEL_11;
      }
      __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)v9);
    }

    xmlCharEncodingHandlerPtr CharEncodingHandler = 0LL;
  }

  else
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
  }

void htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding, int format)
{
  if (cur)
  {
    xmlElementType type = cur->type;
    cur->xmlElementType type = XML_HTML_DOCUMENT_NODE;
    htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, format);
    cur->xmlElementType type = type;
  }

  else
  {
    htmlNodeDumpFormatOutput(buf, 0LL, 0LL, 0LL, format);
  }

void htmlDocDumpMemory(xmlDocPtr cur, xmlChar **mem, int *size)
{
}

void htmlAttrDumpOutput(xmlOutputBuffer *a1, xmlDoc *a2, uint64_t a3)
{
  if (a3)
  {
    xmlOutputBufferWriteString(a1, " ");
    uint64_t v6 = *(void *)(a3 + 72);
    if (v6)
    {
      uint64_t v7 = *(const char **)(v6 + 24);
      if (v7)
      {
        xmlOutputBufferWriteString(a1, v7);
        xmlOutputBufferWriteString(a1, ":");
      }
    }

    xmlOutputBufferWriteString(a1, *(const char **)(a3 + 16));
    if (*(void *)(a3 + 24))
    {
      uint64_t v8 = 0LL;
      __int128 v9 = *(const xmlChar **)(a3 + 16);
      do
      {
        if (!xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[v8], v9)) {
          return;
        }
        ++v8;
      }

      while (v8 != 13);
      String = xmlNodeListGetString(a2, *(const xmlNode **)(a3 + 24), 0);
      if (String)
      {
        size_t v11 = String;
        xmlOutputBufferWriteString(a1, "=");
        if (*(void *)(a3 + 72)
          || (uint64_t v13 = *(void *)(a3 + 40)) == 0
          || *(void *)(v13 + 72)
          || xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"href")
          && xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"action")
          && xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"src")
          && (xmlStrcasecmp(*(const xmlChar **)(a3 + 16), (const xmlChar *)"name")
           || xmlStrcasecmp(*(const xmlChar **)(*(void *)(a3 + 40) + 16LL), (const xmlChar *)"a")))
        {
          buffer = (uint64x2_t *)a1->buffer;
        }

        else
        {
          for (uint64_t i = v11; ; ++i)
          {
            unsigned int v15 = *i;
            BOOL v16 = v15 > 0x20;
            uint64_t v17 = (1LL << v15) & 0x100002600LL;
            if (v16 || v17 == 0) {
              break;
            }
          }

          __int128 v19 = xmlURIEscapeStr(i, (const xmlChar *)"@/:=?;#%&,+<>");
          buffer = (uint64x2_t *)a1->buffer;
          if (v19)
          {
            xmlBufWriteQuotedString(buffer, v19);
            xmlFree(v19);
            goto LABEL_13;
          }
        }

        xmlBufWriteQuotedString(buffer, v11);
LABEL_13:
        xmlFree(v11);
        return;
      }

      xmlOutputBufferWriteString(a1, "=");
    }
  }

void htmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, const char *encoding)
{
}

void htmlDocContentDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding)
{
}

int htmlDocDump(FILE *f, xmlDocPtr cur)
{
  if (!f || !cur) {
    return -1;
  }
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (MetaEncoding)
  {
    uint64_t v5 = MetaEncoding;
    if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
    {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v5);
      if (CharEncodingHandler) {
        goto LABEL_10;
      }
      __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)v5);
    }

    xmlCharEncodingHandlerPtr CharEncodingHandler = 0LL;
  }

  else
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
  }

LABEL_10:
  htmlDocPtr File = xmlOutputBufferCreateFile(f, CharEncodingHandler);
  if (File)
  {
    uint64_t v8 = File;
    htmlNodeDumpFormatOutput(File, cur, (xmlNodePtr)cur, 0LL, 1);
    return xmlOutputBufferClose(v8);
  }

  return -1;
}

    size_t v3 = *v2;
  }

  if (v3)
  {
    ++v2;
LABEL_9:
    *a2++ = v3;
    goto LABEL_10;
  }

  *a2 = 0;
  return result;
}

  while (1)
  {
    Prop = xmlGetProp((const xmlNode *)v1, (const xmlChar *)"datatypeLibrary");
    if (Prop) {
      break;
    }
LABEL_11:
    uint64_t v1 = *(void *)(v1 + 40);
    if (!v1 || *(_DWORD *)(v1 + 8) != 1) {
      return 0LL;
    }
  }

  uint64_t v5 = Prop;
  if (*Prop)
  {
    uint64_t v6 = xmlURIEscapeStr(Prop, (const xmlChar *)":/#?");
    if (!v6) {
      return v5;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  xmlFree(v5);
  return v6;
}

    if (systemId && !v8->URI)
    {
      int v12 = *((void *)ctx + 7);
      if (!v12 || (uint64_t v13 = *(const xmlChar **)(v12 + 8)) == 0LL) {
        uint64_t v13 = (const xmlChar *)*((void *)ctx + 35);
      }
      v8->URI = xmlBuildURI(systemId, v13);
    }

    return;
  }

  uint64_t v8 = xmlAddDtdEntity(*((xmlDocPtr *)ctx + 2), name, 3, publicId, systemId, notationName);
  if (v8) {
    goto LABEL_10;
  }
  if (*((_DWORD *)ctx + 105))
  {
    if (*(void *)ctx)
    {
      __int128 v9 = *(void (**)(uint64_t, const char *))(*(void *)ctx + 168LL);
      if (v9)
      {
        int v10 = *((void *)ctx + 1);
        size_t v11 = "Entity(%s) already defined in the external subset\n";
        goto LABEL_21;
      }
    }
  }

    uint64_t v13 = xmlStrcat(v4, v12);
LABEL_19:
    uint64_t v4 = v13;
    goto LABEL_23;
  }

  return v4;
}

    if (v7 != v10)
    {
      *(void *)(v7 + 48) = v10;
      goto LABEL_16;
    }

    if (v5 == 37) {
      v4 += 3;
    }
    else {
      ++v4;
    }
  }

  size_t v11 = *(void **)(a1 + 56);
  if (v11)
  {
    xmlFree(v11);
    int v10 = *(_DWORD *)(a1 + 72);
  }

  int v12 = *a2;
  uint64_t v13 = (_DWORD)v4 - *a2;
  if ((v10 & 2) != 0) {
    char v14 = xmlStrndup(v12, v13);
  }
  else {
    char v14 = xmlURIUnescapeString((const char *)v12, v13, 0LL);
  }
  *(void *)(a1 + 56) = v14;
  BOOL v16 = *(void **)(a1 + 80);
  if (v16) {
    xmlFree(v16);
  }
  *(void *)(a1 + 80) = xmlStrndup(*a2, v4 - *a2);
LABEL_35:
  int result = 0LL;
  *a2 = v4;
  return result;
}

    if (v5 == 37) {
      v4 += 3;
    }
    else {
      ++v4;
    }
  }

  size_t v11 = *(void **)(a1 + 64);
  if (v11)
  {
    xmlFree(v11);
    int v10 = *(_DWORD *)(a1 + 72);
  }

  int v12 = *a2;
  uint64_t v13 = (_DWORD)v4 - *a2;
  if ((v10 & 2) != 0) {
    char v14 = xmlStrndup(v12, v13);
  }
  else {
    char v14 = xmlURIUnescapeString((const char *)v12, v13, 0LL);
  }
  *(void *)(a1 + 64) = v14;
LABEL_33:
  int result = 0LL;
  *a2 = v4;
  return result;
}

    uint64_t v2 = *v1;
  }

  if (v2)
  {
    ++v1;
LABEL_9:
    *result++ = v2;
    goto LABEL_10;
  }

  *int result = 0;
  return result;
}

        *(_DWORD *)(v1 + 16) = 1450;
        uint64_t v7 = v1;
        uint64_t v8 = "Expecting a char range";
      }

      else
      {
        if (*v2)
        {
          if (v4 == 91) {
            goto LABEL_10;
          }
          goto LABEL_7;
        }

        *(_DWORD *)(v1 + 16) = 1450;
        uint64_t v7 = v1;
        uint64_t v8 = "Expecting ']'";
      }

          BOOL v16 = "'";
        }

        else
        {
          BOOL v16 = "(unknown)";
        }

    xmlSchemaPSimpleTypeErr(a1, 3037, v10, 0LL, a5, NodeContent, 0LL, 0);
  }

  return 1LL;
}

  uint64_t v7 = data[43];
  if (v7 < 0) {
    return 0LL;
  }
  __int128 v168 = v4;
  if (v7 == data[76]) {
    data[76] = -1;
  }
  __int128 v175 = v2;
  uint64_t v8 = data;
  __int128 v9 = *(void *)(v2 + 104);
  if (v9 && (data[80] || data[81]))
  {
    while (1)
    {
      int v10 = *(void *)(v9 + 24);
      size_t v11 = *(_DWORD **)(v10 + 8);
      if (*v11 == 24) {
        goto LABEL_90;
      }
      int v12 = *(void *)(v9 + 56);
      if (!v12) {
        goto LABEL_90;
      }
      if (!*(_DWORD *)(v12 + 8)) {
        goto LABEL_90;
      }
      if (!v8[81])
      {
        uint64_t v17 = *(_DWORD *)(v10 + 16);
        if (v17 == -1 || v17 > v8[43]) {
          goto LABEL_90;
        }
      }

      uint64_t v13 = *(void *)(*((void *)v8 + 22) + 8LL * *(int *)(v9 + 4));
      char v14 = *(void **)(v13 + 96);
      if (v14)
      {
        do
        {
          unsigned int v15 = v14;
          if ((_DWORD *)v14[1] == v11) {
            goto LABEL_31;
          }
          char v14 = (void *)*v14;
        }

        while (*v15);
        BOOL v16 = xmlSchemaIDCNewBinding((uint64_t)v11);
        *unsigned int v15 = v16;
        unsigned int v15 = v16;
      }

      else
      {
        unsigned int v15 = xmlSchemaIDCNewBinding((uint64_t)v11);
        *(void *)(v13 + 96) = v15;
      }

      if (!v15) {
        goto LABEL_304;
      }
LABEL_31:
      int v18 = (uint64_t *)v15[4];
      if (!v18) {
        break;
      }
      __int128 v19 = *((_DWORD *)v18 + 2);
      if (!v19) {
        goto LABEL_35;
      }
      __int128 v172 = *v18;
LABEL_36:
      if (v15[2]) {
        __int128 v20 = *((_DWORD *)v15 + 6);
      }
      else {
        __int128 v20 = 0;
      }
      uint64_t v8 = v176;
      __int128 v21 = *(void **)(v9 + 56);
      if (!(v20 | v19))
      {
        v15[2] = *v21;
        v15[3] = v21[1];
        *__int128 v21 = 0LL;
        v21[1] = 0LL;
        int v48 = *(xmlHashTable **)(v9 + 64);
        if (v48)
        {
          xmlHashFree(v48, (xmlHashDeallocator)xmlFreeIDCHashEntry);
          *(void *)(v9 + 64) = 0LL;
        }

        goto LABEL_90;
      }

      __int128 v22 = 0LL;
      int v23 = *((_DWORD *)v21 + 2);
      uint64_t v24 = *v21;
      BOOL v25 = *(unsigned int *)(*(void *)(*(void *)(v9 + 24) + 8LL) + 64LL);
      if (v19 <= 1) {
        int v26 = 1LL;
      }
      else {
        int v26 = v19;
      }
      int v169 = v26;
      __int128 v160 = v20;
      if (v20 <= 1) {
        uint64_t v27 = 1LL;
      }
      else {
        uint64_t v27 = v20;
      }
      __int128 v162 = v27;
      if (v23 <= 1) {
        int v28 = 1LL;
      }
      else {
        int v28 = v23;
      }
      __int128 v164 = v28;
      __int128 v166 = v24;
      do
      {
        unsigned int v29 = *(void *)(*(void *)(v24 + 8 * v22) + 8LL);
        if (v19)
        {
          for (uint64_t i = 0LL; i != v169; ++i)
          {
            if ((_DWORD)v25 == 1)
            {
              uint64_t v31 = xmlSchemaAreValuesEqual( *(xmlSchemaValPtr *)(*(void *)v29 + 8LL),  *(xmlSchemaVal **)(**(void **)(*(void *)(v172 + 8 * i) + 8LL) + 8LL));
              if (v31 == -1) {
                goto LABEL_304;
              }
              if (v31 == 1) {
                goto LABEL_84;
              }
            }

            else if ((int)v25 >= 1)
            {
              xmlChar v32 = *(void *)(*(void *)(v172 + 8 * i) + 8LL);
              int v33 = v29;
              size_t v34 = v25;
              while (1)
              {
                int v35 = xmlSchemaAreValuesEqual( *(xmlSchemaValPtr *)(*(void *)v33 + 8LL),  *(xmlSchemaVal **)(*(void *)v32 + 8LL));
                if (v35 == -1) {
                  goto LABEL_304;
                }
                if (!v35) {
                  break;
                }
                v32 += 8LL;
                v33 += 8LL;
                if (!--v34) {
                  goto LABEL_84;
                }
              }
            }
          }
        }

        if (!v160)
        {
LABEL_78:
          uint64_t v44 = *(void *)(v166 + 8 * v22);
          xmlElementType v45 = (void *)v15[2];
          if (v45)
          {
            int v46 = *((int *)v15 + 7);
            if ((int)v46 <= *((_DWORD *)v15 + 6))
            {
              *((_DWORD *)v15 + 7) = 2 * v46;
              xmlElementType v45 = xmlRealloc(v45, 16 * v46);
              v15[2] = v45;
              if (!v45)
              {
                __int128 v155 = "re-allocating an array of IDC node-table items";
LABEL_336:
                __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)v155);
                goto LABEL_304;
              }
            }
          }

          else
          {
            *((_DWORD *)v15 + 7) = 10;
            xmlElementType v45 = xmlMalloc(0x50uLL);
            v15[2] = v45;
            if (!v45)
            {
              __int128 v155 = "allocating an array of IDC node-table items";
              goto LABEL_336;
            }
          }

          int v47 = *((int *)v15 + 6);
          *((_DWORD *)v15 + 6) = v47 + 1;
          *((void *)v45 + v47) = v44;
          goto LABEL_84;
        }

        BOOL v36 = 0LL;
        while ((_DWORD)v25 != 1)
        {
          int v38 = *(void *)(*(void *)(v15[2] + 8 * v36) + 8LL);
          int v39 = v29;
          __int128 v40 = v25;
          while (1)
          {
            __int128 v41 = xmlSchemaAreValuesEqual( *(xmlSchemaValPtr *)(*(void *)v39 + 8LL),  *(xmlSchemaVal **)(*(void *)v38 + 8LL));
            if (v41 == -1) {
              goto LABEL_304;
            }
            if (!v41) {
              break;
            }
            v38 += 8LL;
            v39 += 8LL;
            if (!--v40) {
              goto LABEL_74;
            }
          }

  int v10 = xmlMalloc(0x10uLL);
  if (!v10)
  {
    uint64_t v13 = "xmlTextWriterStartCDATA : out of memory!\n";
    char v14 = writer;
    unsigned int v15 = 2;
LABEL_16:
    xmlWriterErrMsg((uint64_t)v14, v15, (char)v13);
    return -1;
  }

  *(void *)int v10 = 0LL;
  void v10[2] = 6;
  xmlListPushFront(*((xmlListPtr *)writer + 1), v10);
  size_t v11 = xmlOutputBufferWriteString(*(xmlOutputBufferPtr *)writer, "<![CDATA[");
  if (v11 < 0) {
    return -1;
  }
  else {
    return v11 + v6;
  }
}

  size_t v3 = (_DWORD)v1 == 45;
  if ((_DWORD)v1 == 45) {
    uint64_t v4 = str + 1;
  }
  else {
    uint64_t v4 = str;
  }
  uint64_t v5 = *v4;
  uint64_t v6 = v5 - 48;
  uint64_t v7 = 0.0;
  if (v5 - 48 <= 9)
  {
    do
    {
      uint64_t v7 = v7 * 10.0 + (double)(v5 - 48);
      uint64_t v5 = str[++v3];
    }

    while (v5 - 48 < 0xA);
    uint64_t v4 = &str[v3];
  }

  if (v5 == 46)
  {
    __int128 v9 = (uint64_t)(v4 + 1);
    uint64_t v8 = v4[1];
    if (v8 >= 0x30)
    {
      if (v6 >= 0xA && v8 >= 0x3A) {
        return xmlXPathNAN;
      }
      if (v8 == 48)
      {
        size_t v11 = 0LL;
        do
          uint64_t v8 = v4[v11++ + 2];
        while (v8 == 48);
        __int128 v9 = (uint64_t)&v4[v11 + 1];
        goto LABEL_28;
      }
    }

    else if (v6 >= 0xA)
    {
      return xmlXPathNAN;
    }

    LODWORD(v1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0;
LABEL_28:
    int v12 = 0.0;
    if (v8 - 48 <= 9)
    {
      uint64_t v13 = v11 + 20;
      do
      {
        int v12 = (double)(int)(v8 - 48) + v12 * 10.0;
        LODWORD(v1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v11 + 1;
        char v14 = *(unsigned __int8 *)++v9;
        uint64_t v8 = v14;
      }

      while (v14 - 48 <= 9 && v11 < v13);
    }

    BOOL v16 = __exp10((double)(int)v11);
    uint64_t v4 = (const xmlChar *)(v9 - 1);
    uint64_t v17 = v12 / v16;
    do
    {
      int v18 = *++v4;
      uint64_t v5 = v18;
    }

    while (v18 - 48 < 0xA);
    uint64_t v7 = v7 + v17;
  }

  if ((v5 | 0x20) == 0x65)
  {
    __int128 v19 = v4 + 2;
    __int128 v21 = *++v4;
    __int128 v20 = v21;
    if (v21 == 45)
    {
      uint64_t v4 = v19;
      __int128 v22 = 1;
    }

    else
    {
      __int128 v22 = 0;
    }

    if (v20 == 43)
    {
      uint64_t v4 = v19;
      int v23 = 0;
    }

    else
    {
      int v23 = v22;
    }

    uint64_t v5 = *v4;
    if (v5 - 48 > 9)
    {
      uint64_t v24 = 0;
    }

    else
    {
      uint64_t v24 = 0;
      do
      {
        BOOL v25 = v5 + 10 * v24 - 48;
        if (v24 < 1000000) {
          uint64_t v24 = v25;
        }
        int v26 = *++v4;
        uint64_t v5 = v26;
      }

      while (v26 - 48 < 0xA);
    }
  }

  else
  {
    uint64_t v24 = 0;
    int v23 = 0;
  }

  uint64_t v27 = (unsigned __int8 *)(v4 + 1);
  while (v5 <= 0x20)
  {
    if (((1LL << v5) & 0x100002600LL) == 0)
    {
      if (v5) {
        return xmlXPathNAN;
      }
      if ((_DWORD)v1 == 45) {
        uint64_t v7 = -v7;
      }
      if (v23) {
        unsigned int v29 = -v24;
      }
      else {
        unsigned int v29 = v24;
      }
      return v7 * __exp10((double)v29);
    }

    int v28 = *v27++;
    uint64_t v5 = v28;
  }

  return xmlXPathNAN;
}

int htmlSaveFile(const char *filename, xmlDocPtr cur)
{
  uint64_t v2 = filename;
  LODWORD(filename) = -1;
  if (!v2 || !cur) {
    return (int)filename;
  }
  xmlInitParser();
  MetaEncoding = (const char *)htmlGetMetaEncoding(cur);
  if (!MetaEncoding)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
    if (!CharEncodingHandler) {
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
    }
    goto LABEL_10;
  }

  uint64_t v5 = MetaEncoding;
  if (xmlParseCharEncoding(MetaEncoding) != XML_CHAR_ENCODING_UTF8)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(v5);
    if (CharEncodingHandler) {
      goto LABEL_10;
    }
    __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)v5);
  }

  xmlCharEncodingHandlerPtr CharEncodingHandler = 0LL;
LABEL_10:
  filename = (const char *)xmlOutputBufferCreateFilename(v2, CharEncodingHandler, cur->compression);
  if (filename)
  {
    uint64_t v7 = (xmlOutputBuffer *)filename;
    htmlNodeDumpFormatOutput((xmlOutputBufferPtr)filename, cur, (xmlNodePtr)cur, 0LL, 1);
    LODWORD(filename) = xmlOutputBufferClose(v7);
  }

  return (int)filename;
}

int htmlSaveFileFormat(const char *filename, xmlDocPtr cur, const char *encoding, int format)
{
  uint64_t v4 = filename;
  LODWORD(filename) = -1;
  if (v4 && cur)
  {
    xmlInitParser();
    if (encoding)
    {
      if (xmlParseCharEncoding(encoding) == XML_CHAR_ENCODING_UTF8)
      {
        xmlCharEncodingHandlerPtr CharEncodingHandler = 0LL;
      }

      else
      {
        xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
        if (!CharEncodingHandler) {
          __xmlSimpleError(7, 1403, 0, (uint64_t)"unknown encoding %s\n", (uint64_t)encoding);
        }
      }

      htmlSetMetaEncoding(cur, (const xmlChar *)encoding);
    }

    else
    {
      htmlSetMetaEncoding(cur, (const xmlChar *)"UTF-8");
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("HTML");
      if (!CharEncodingHandler) {
        xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler("ascii");
      }
    }

    filename = (const char *)xmlOutputBufferCreateFilename(v4, CharEncodingHandler, 0);
    if (filename)
    {
      int v10 = (xmlOutputBuffer *)filename;
      htmlDocContentDumpFormatOutput((xmlOutputBufferPtr)filename, cur, v9, format);
      LODWORD(filename) = xmlOutputBufferClose(v10);
    }
  }

  return (int)filename;
}

int htmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding)
{
  return htmlSaveFileFormat(filename, cur, encoding, 1);
}

int xmlGetFeaturesList(int *len, const char **result)
{
  int v3 = 42;
  if (len && result)
  {
    unsigned int v4 = *len;
    if (v4 < 0x2B)
    {
      if (!v4) {
        return 42;
      }
    }

    else
    {
      unsigned int v4 = 42;
      *int len = 42;
    }

    memcpy(result, xmlFeaturesList, 8 * v4);
    return 42;
  }

  return v3;
}

int xmlGetFeature(xmlParserCtxtPtr ctxt, const char *name, void *result)
{
  int v4 = -1;
  if (ctxt && name && result)
  {
    int v4 = strcmp(name, "validate");
    if (v4)
    {
      int v4 = strcmp(name, "keep blanks");
      if (v4)
      {
        int v4 = strcmp(name, "disable SAX");
        if (v4)
        {
          int v4 = strcmp(name, "fetch external entities");
          if (v4)
          {
            int v4 = strcmp(name, "substitute entities");
            if (v4)
            {
              int v4 = strcmp(name, "gather line info");
              if (v4)
              {
                int v4 = strcmp(name, "user data");
                if (!v4)
                {
                  userData = ctxt->userData;
                  goto LABEL_52;
                }

                int v4 = strcmp(name, "is html");
                if (v4)
                {
                  int v4 = strcmp(name, "is standalone");
                  if (v4)
                  {
                    int v4 = strcmp(name, "document");
                    if (v4)
                    {
                      int v4 = strcmp(name, "is well formed");
                      if (v4)
                      {
                        int v4 = strcmp(name, "is valid");
                        if (v4)
                        {
                          int v4 = strcmp(name, "SAX block");
                          if (v4)
                          {
                            int v4 = strcmp(name, "SAX function internalSubset");
                            if (v4)
                            {
                              int v4 = strcmp(name, "SAX function isStandalone");
                              if (v4)
                              {
                                int v4 = strcmp(name, "SAX function hasInternalSubset");
                                if (v4)
                                {
                                  int v4 = strcmp(name, "SAX function hasExternalSubset");
                                  if (v4)
                                  {
                                    int v4 = strcmp(name, "SAX function resolveEntity");
                                    if (v4)
                                    {
                                      int v4 = strcmp(name, "SAX function getEntity");
                                      if (v4)
                                      {
                                        int v4 = strcmp(name, "SAX function entityDecl");
                                        if (v4)
                                        {
                                          int v4 = strcmp(name, "SAX function notationDecl");
                                          if (v4)
                                          {
                                            int v4 = strcmp(name, "SAX function attributeDecl");
                                            if (v4)
                                            {
                                              int v4 = strcmp(name, "SAX function elementDecl");
                                              if (v4)
                                              {
                                                int v4 = strcmp(name, "SAX function unparsedEntityDecl");
                                                if (v4)
                                                {
                                                  int v4 = strcmp(name, "SAX function setDocumentLocator");
                                                  if (v4)
                                                  {
                                                    int v4 = strcmp(name, "SAX function startDocument");
                                                    if (v4)
                                                    {
                                                      int v4 = strcmp(name, "SAX function endDocument");
                                                      if (v4)
                                                      {
                                                        int v4 = strcmp(name, "SAX function startElement");
                                                        if (v4)
                                                        {
                                                          int v4 = strcmp(name, "SAX function endElement");
                                                          if (v4)
                                                          {
                                                            int v4 = strcmp(name, "SAX function reference");
                                                            if (v4)
                                                            {
                                                              int v4 = strcmp(name, "SAX function characters");
                                                              if (v4)
                                                              {
                                                                int v4 = strcmp(name, "SAX function ignorableWhitespace");
                                                                if (v4)
                                                                {
                                                                  int v4 = strcmp( name,  "SAX function processingInstruction");
                                                                  if (v4)
                                                                  {
                                                                    int v4 = strcmp(name, "SAX function comment");
                                                                    if (v4)
                                                                    {
                                                                      int v4 = strcmp(name, "SAX function warning");
                                                                      if (v4)
                                                                      {
                                                                        int v4 = strcmp(name, "SAX function error");
                                                                        if (v4)
                                                                        {
                                                                          int v4 = strcmp(name, "SAX function fatalError");
                                                                          if (v4)
                                                                          {
                                                                            int v4 = strcmp( name,  "SAX function getParameterEntity");
                                                                            if (v4)
                                                                            {
                                                                              int v4 = strcmp( name,  "SAX function cdataBlock");
                                                                              if (v4)
                                                                              {
                                                                                int v4 = strcmp( name,  "SAX function externalSubset");
                                                                                if (v4) {
                                                                                  return -1;
                                                                                }
                                                                                userData = ctxt->sax->externalSubset;
                                                                              }

                                                                              else
                                                                              {
                                                                                userData = ctxt->sax->cdataBlock;
                                                                              }
                                                                            }

                                                                            else
                                                                            {
                                                                              userData = ctxt->sax->getParameterEntity;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            userData = ctxt->sax->fatalError;
                                                                          }
                                                                        }

                                                                        else
                                                                        {
                                                                          userData = ctxt->sax->error;
                                                                        }
                                                                      }

                                                                      else
                                                                      {
                                                                        userData = ctxt->sax->warning;
                                                                      }
                                                                    }

                                                                    else
                                                                    {
                                                                      userData = ctxt->sax->comment;
                                                                    }
                                                                  }

                                                                  else
                                                                  {
                                                                    userData = ctxt->sax->processingInstruction;
                                                                  }
                                                                }

                                                                else
                                                                {
                                                                  userData = ctxt->sax->ignorableWhitespace;
                                                                }
                                                              }

                                                              else
                                                              {
                                                                userData = ctxt->sax->characters;
                                                              }
                                                            }

                                                            else
                                                            {
                                                              userData = ctxt->sax->reference;
                                                            }
                                                          }

                                                          else
                                                          {
                                                            userData = ctxt->sax->endElement;
                                                          }
                                                        }

                                                        else
                                                        {
                                                          userData = ctxt->sax->startElement;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        userData = ctxt->sax->endDocument;
                                                      }
                                                    }

                                                    else
                                                    {
                                                      userData = ctxt->sax->startDocument;
                                                    }
                                                  }

                                                  else
                                                  {
                                                    userData = ctxt->sax->setDocumentLocator;
                                                  }
                                                }

                                                else
                                                {
                                                  userData = ctxt->sax->unparsedEntityDecl;
                                                }
                                              }

                                              else
                                              {
                                                userData = ctxt->sax->elementDecl;
                                              }
                                            }

                                            else
                                            {
                                              userData = ctxt->sax->attributeDecl;
                                            }
                                          }

                                          else
                                          {
                                            userData = ctxt->sax->notationDecl;
                                          }
                                        }

                                        else
                                        {
                                          userData = ctxt->sax->entityDecl;
                                        }
                                      }

                                      else
                                      {
                                        userData = ctxt->sax->getEntity;
                                      }
                                    }

                                    else
                                    {
                                      userData = ctxt->sax->resolveEntity;
                                    }
                                  }

                                  else
                                  {
                                    userData = ctxt->sax->hasExternalSubset;
                                  }
                                }

                                else
                                {
                                  userData = ctxt->sax->hasInternalSubset;
                                }
                              }

                              else
                              {
                                userData = ctxt->sax->isStandalone;
                              }
                            }

                            else
                            {
                              userData = ctxt->sax->internalSubset;
                            }
                          }

                          else
                          {
                            userData = ctxt->sax;
                          }

                          goto LABEL_52;
                        }

                        int valid = ctxt->valid;
                      }

                      else
                      {
                        int valid = ctxt->wellFormed;
                      }

                      goto LABEL_58;
                    }

                    userData = ctxt->myDoc;
LABEL_52:
                    *(void *)int result = userData;
                    return v4;
                  }

                  int valid = ctxt->standalone;
                }

                else
                {
                  int valid = ctxt->html;
                }
              }

              else
              {
                int valid = ctxt->record_info;
              }
            }

            else
            {
              int valid = ctxt->replaceEntities;
            }
          }

          else
          {
            int valid = ctxt->loadsubset;
          }
        }

        else
        {
          int valid = ctxt->disableSAX;
        }
      }

      else
      {
        int valid = ctxt->keepBlanks;
      }
    }

    else
    {
      int valid = ctxt->validate;
    }

LABEL_58:
    *(_DWORD *)int result = valid;
  }

  return v4;
}

      LODWORD(lang) = 0;
      return (int)lang;
    }

    if (lang[1] == 45)
    {
      uint64_t v2 = lang + 2;
      do
      {
        int v4 = *v2++;
        int v3 = v4;
      }

      while ((v4 & 0xFFFFFFDF) - 65 < 0x1A);
      uint64_t v5 = v3 == 0;
      goto LABEL_18;
    }

    goto LABEL_12;
  }

  return (int)lang;
}

          uint64_t v5 = *(unsigned __int8 **)(v4 + 32);
        }

        while (v5);
        *(_DWORD *)(v3 + 56) = v30;
        goto LABEL_79;
      case 0x11:
        xmlChar v32 = *(void *)(a2 + 48);
        int v33 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v33 | 1;
        if (!v32) {
          goto LABEL_76;
        }
        while (1)
        {
          size_t v34 = xmlRelaxNGValidateValue(v3);
          if (!(_DWORD)v34) {
            break;
          }
          *(void *)(*(void *)(v3 + 96) + 32LL) = v5;
          xmlChar v32 = *(void *)(v32 + 64);
          if (!v32)
          {
            char v14 = v34;
            *(_DWORD *)(v3 + 56) = v33;
            if ((v33 & 1) == 0) {
              xmlRelaxNGDumpValidError(v3);
            }
            return v14;
          }
        }

  uint64_t v27 = (xmlNode *)xmlSchemaGetPropNode(children, (xmlChar *)"id");
  if (v27) {
    xmlSchemaPValAttrNodeID(a1, v27);
  }
  int v28 = (void *)(v24 + 96);
  xmlSchemaPValAttrQName( a1,  a2,  children,  (xmlChar *)"itemType",  (const xmlChar **)(v24 + 104),  (const xmlChar **)(v24 + 96));
  unsigned int v29 = *(void *)(children + 24);
  if (v29
    && (!*(void *)(v29 + 72)
     || !xmlStrEqual(*(const xmlChar **)(v29 + 16), (const xmlChar *)"annotation")
     || !xmlStrEqual( *(const xmlChar **)(*(void *)(v29 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
     || (unsigned int v30 = xmlSchemaParseAnnotation((_DWORD *)a1, v29, 1),
         xmlSchemaAddAnnotation(v24, (uint64_t)v30),
         (unsigned int v29 = *(void *)(v29 + 48)) != 0))
    && *(void *)(v29 + 72)
    && xmlStrEqual(*(const xmlChar **)(v29 + 16), (const xmlChar *)"simpleType")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(v29 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    if (*v28) {
      xmlSchemaPCustomErrExt( a1,  3000,  0LL,  children,  (const xmlChar *)"The attribute 'itemType' and the <simpleType> child are mutually exclusive");
    }
    else {
      *(void *)(v24 + 56) = xmlSchemaParseSimpleType(a1, a2, v29, 0LL);
    }
    unsigned int v29 = *(void *)(v29 + 48);
  }

  else if (!*v28)
  {
    xmlSchemaPCustomErrExt( a1,  3000,  0LL,  children,  (const xmlChar *)"Either the attribute 'itemType' or the <simpleType> child must be present");
  }

  if (v29) {
    xmlSchemaPContentErr(a1, 3033, children, v29, 0LL, (xmlChar *)"(annotation?, simpleType?)");
  }
  if (!*v28 && !*(void *)(v24 + 56) && !xmlSchemaGetPropNode(children, (xmlChar *)"itemType")) {
    xmlSchemaPCustomErrExt( a1,  3000,  0LL,  children,  (const xmlChar *)"Either the attribute 'itemType' or the <simpleType> child must be present");
  }
LABEL_88:
  int v23 = 0;
LABEL_89:
  xmlNodePtr children = *(void *)(children + 48);
  if (children) {
    goto LABEL_90;
  }
LABEL_91:
  if (a4)
  {
    if (*(_DWORD *)(a1 + 188)) {
      uint64_t v31 = v23;
    }
    else {
      uint64_t v31 = 1;
    }
    if ((v31 & 1) == 0) {
      xmlSchemaPCustomErrExt( a1,  3081,  0LL,  (uint64_t)a3,  (const xmlChar *)"This is a redefinition, thus the <simpleType> must have a <restriction> child");
    }
  }

  *(void *)(a1 + 160) = v21;
  return PropNode;
}

    if (v7) {
      return;
    }
    goto LABEL_63;
  }

  __int128 v19 = a2;
  __int128 v20 = (xmlNode *)v14;
  int v18 = v5;
LABEL_61:
  __int128 v21 = xmlSchemaVCheckCVCSimpleType(v19, v20, v18, v15, (xmlSchemaValPtr *)(a1 + 184), 1u, 1, 0);
  if (v21 < 0)
  {
    xmlSchemaInternalErr2( (_DWORD *)a2,  (const xmlChar *)"xmlSchemaParseCheckCOSValidDefault",  (const xmlChar *)"calling xmlSchemaVCheckCVCSimpleType()",  0LL);
    xmlSchemaInternalErr2( (_DWORD *)a2,  (const xmlChar *)"xmlSchemaElemCheckValConstr",  (const xmlChar *)"failed to validate the value constraint of an element declaration",  0LL);
    return;
  }

  if (!(v21 | v7))
  {
LABEL_63:
    __int128 v22 = *(void *)(a1 + 152);
    if (v22 && (*(_BYTE *)(a1 + 88) & 0x10) == 0)
    {
      while (1)
      {
        int v23 = *(_DWORD *)(v22 + 88);
        if ((v23 & 0x2000) != 0) {
          goto LABEL_105;
        }
        uint64_t v24 = *(void *)(v22 + 56);
        BOOL v25 = *(void *)(a1 + 56);
        if (v24 != v25)
        {
          int v26 = 0;
          if (v25)
          {
            uint64_t v27 = *(void *)(a1 + 56);
            do
            {
              int v28 = *(_DWORD *)(v27 + 88);
              if ((((v26 & 0x80000) == 0) & (v28 >> 1)) != 0) {
                v26 |= 0x40000u;
              }
              if ((((v26 & 0x80000) == 0) & (v28 >> 2)) != 0) {
                v26 |= 0x80000u;
              }
              uint64_t v27 = *(void *)(v27 + 112);
            }

            while (v27 && v27 != v24);
          }

          unsigned int v29 = (v23 << 7) & 0xC0000;
          do
          {
            BOOL v25 = *(void *)(v25 + 112);
            if (!v25 || *(_DWORD *)v25 != 5 && *(_DWORD *)(v25 + 160) != 45) {
              break;
            }
            unsigned int v30 = *(_DWORD *)(v25 + 88);
            if ((((v29 & 0x40000) == 0) & (v30 >> 18)) != 0) {
              v29 |= 0x40000u;
            }
            if ((((v29 & 0x80000) == 0) & (v30 >> 19)) != 0) {
              v29 |= 0x80000u;
            }
          }

          while (v25 != v24);
          if (v29 && ((v29 & 0x40000) != 0 && (v26 & 0x40000) != 0 || (v29 & 0x80000) != 0 && (v26 & 0x80000) != 0)) {
            goto LABEL_105;
          }
        }

        uint64_t v31 = *(xmlHashTable **)(*(void *)(a2 + 48) + 48LL);
        if (v31)
        {
          xmlChar v32 = (uint64_t *)xmlHashLookup2(v31, *(const xmlChar **)(v22 + 16), *(const xmlChar **)(v22 + 96));
          if (v32) {
            goto LABEL_91;
          }
          if (*(void *)(*(void *)(a2 + 48) + 48LL)) {
            goto LABEL_94;
          }
        }

        Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a2 + 152));
        *(void *)(*(void *)(a2 + 48) + 48LL) = Dict;
        if (Dict)
        {
LABEL_94:
          size_t v34 = (uint64_t *)xmlMalloc(0x10uLL);
          if (v34)
          {
            xmlChar v32 = v34;
            *size_t v34 = v22;
            v34[1] = 0LL;
            int v35 = xmlSchemaItemListCreate();
            v32[1] = (uint64_t)v35;
            if (v35)
            {
              if (!xmlHashAddEntry2( *(xmlHashTablePtr *)(*(void *)(a2 + 48) + 48LL),  *(const xmlChar **)(v22 + 16),  *(const xmlChar **)(v22 + 96),  v32))
              {
LABEL_91:
                xmlSchemaItemListAdd(v32[1], a1);
                goto LABEL_103;
              }

              xmlSchemaInternalErr2( (_DWORD *)a2,  (const xmlChar *)"xmlSchemaSubstGroupAdd",  (const xmlChar *)"failed to add a new substitution container",  0LL);
              BOOL v36 = (void **)v32[1];
              if (v36)
              {
                if (*v36) {
                  xmlFree(*v36);
                }
                xmlFree(v36);
              }
            }

            xmlFree(v32);
          }

          else
          {
            __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"allocating a substitution group container");
          }
        }

    name = 0LL;
    BOOL v36 = xmlSchemaGetComponentDesignation(&name, (int *)v17);
    xmlSchemaCustomErr4( (_DWORD *)a1,  1877,  0LL,  (_DWORD *)v17,  (const xmlChar *)"Not all fields of %s evaluate to a node",  v36,  0LL,  0LL,  0LL);
    if (name) {
      xmlFree(name);
    }
    goto LABEL_60;
  }

int xmlSetFeature(xmlParserCtxtPtr ctxt, const char *name, void *value)
{
  int result = -1;
  if (ctxt && name && value)
  {
    if (!strcmp(name, "validate"))
    {
      int v7 = *(_DWORD *)value;
      if (!ctxt->validate && v7)
      {
        if (!ctxt->vctxt.warning) {
          ctxt->vctxt.warning = xmlParserValidityWarning;
        }
        if (!ctxt->vctxt.error) {
          ctxt->vctxt.error = xmlParserValidityError;
        }
        ctxt->vctxt.nodeMax = 0;
      }

      int result = 0;
      ctxt->validate = v7;
    }

    else
    {
      int result = strcmp(name, "keep blanks");
      if (result)
      {
        int result = strcmp(name, "disable SAX");
        if (result)
        {
          int result = strcmp(name, "fetch external entities");
          if (result)
          {
            int result = strcmp(name, "substitute entities");
            if (result)
            {
              int result = strcmp(name, "gather line info");
              if (result)
              {
                int result = strcmp(name, "user data");
                if (result)
                {
                  int result = strcmp(name, "is html");
                  if (result)
                  {
                    int result = strcmp(name, "is standalone");
                    if (result)
                    {
                      int result = strcmp(name, "document");
                      if (result)
                      {
                        int result = strcmp(name, "is well formed");
                        if (result)
                        {
                          int result = strcmp(name, "is valid");
                          if (result)
                          {
                            int result = strcmp(name, "SAX block");
                            if (result)
                            {
                              int result = strcmp(name, "SAX function internalSubset");
                              if (result)
                              {
                                int result = strcmp(name, "SAX function isStandalone");
                                if (result)
                                {
                                  int result = strcmp(name, "SAX function hasInternalSubset");
                                  if (result)
                                  {
                                    int result = strcmp(name, "SAX function hasExternalSubset");
                                    if (result)
                                    {
                                      int result = strcmp(name, "SAX function resolveEntity");
                                      if (result)
                                      {
                                        int result = strcmp(name, "SAX function getEntity");
                                        if (result)
                                        {
                                          int result = strcmp(name, "SAX function entityDecl");
                                          if (result)
                                          {
                                            int result = strcmp(name, "SAX function notationDecl");
                                            if (result)
                                            {
                                              int result = strcmp(name, "SAX function attributeDecl");
                                              if (result)
                                              {
                                                int result = strcmp(name, "SAX function elementDecl");
                                                if (result)
                                                {
                                                  int result = strcmp(name, "SAX function unparsedEntityDecl");
                                                  if (result)
                                                  {
                                                    int result = strcmp(name, "SAX function setDocumentLocator");
                                                    if (result)
                                                    {
                                                      int result = strcmp(name, "SAX function startDocument");
                                                      if (result)
                                                      {
                                                        int result = strcmp(name, "SAX function endDocument");
                                                        if (result)
                                                        {
                                                          int result = strcmp(name, "SAX function startElement");
                                                          if (result)
                                                          {
                                                            int result = strcmp(name, "SAX function endElement");
                                                            if (result)
                                                            {
                                                              int result = strcmp(name, "SAX function reference");
                                                              if (result)
                                                              {
                                                                int result = strcmp(name, "SAX function characters");
                                                                if (result)
                                                                {
                                                                  int result = strcmp( name,  "SAX function ignorableWhitespace");
                                                                  if (result)
                                                                  {
                                                                    int result = strcmp( name,  "SAX function processingInstruction");
                                                                    if (result)
                                                                    {
                                                                      int result = strcmp(name, "SAX function comment");
                                                                      if (result)
                                                                      {
                                                                        int result = strcmp(name, "SAX function warning");
                                                                        if (result)
                                                                        {
                                                                          int result = strcmp(name, "SAX function error");
                                                                          if (result)
                                                                          {
                                                                            int result = strcmp( name,  "SAX function fatalError");
                                                                            if (result)
                                                                            {
                                                                              int result = strcmp( name,  "SAX function getParameterEntity");
                                                                              if (result)
                                                                              {
                                                                                int result = strcmp( name,  "SAX function cdataBlock");
                                                                                if (result)
                                                                                {
                                                                                  int result = strcmp( name,  "SAX function externalSubset");
                                                                                  if (result) {
                                                                                    return -1;
                                                                                  }
                                                                                  else {
                                                                                    ctxt->sax->externalSubset = *(externalSubsetSAXFunc *)value;
                                                                                  }
                                                                                }

                                                                                else
                                                                                {
                                                                                  ctxt->sax->cdataBlocuint64_t k = *(cdataBlockSAXFunc *)value;
                                                                                }
                                                                              }

                                                                              else
                                                                              {
                                                                                ctxt->sax->getParameterEntity = *(getParameterEntitySAXFunc *)value;
                                                                              }
                                                                            }

                                                                            else
                                                                            {
                                                                              ctxt->sax->fatalError = *(fatalErrorSAXFunc *)value;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            ctxt->sax->error = *(errorSAXFunc *)value;
                                                                          }
                                                                        }

                                                                        else
                                                                        {
                                                                          ctxt->sax->warning = *(warningSAXFunc *)value;
                                                                        }
                                                                      }

                                                                      else
                                                                      {
                                                                        ctxt->sax->comment = *(commentSAXFunc *)value;
                                                                      }
                                                                    }

                                                                    else
                                                                    {
                                                                      ctxt->sax->processingInstruction = *(processingInstructionSAXFunc *)value;
                                                                    }
                                                                  }

                                                                  else
                                                                  {
                                                                    ctxt->sax->ignorableWhitespace = *(ignorableWhitespaceSAXFunc *)value;
                                                                  }
                                                                }

                                                                else
                                                                {
                                                                  ctxt->sax->characters = *(charactersSAXFunc *)value;
                                                                }
                                                              }

                                                              else
                                                              {
                                                                ctxt->sax->reference = *(referenceSAXFunc *)value;
                                                              }
                                                            }

                                                            else
                                                            {
                                                              ctxt->sax->endElementSAXFunc endElement = *(endElementSAXFunc *)value;
                                                            }
                                                          }

                                                          else
                                                          {
                                                            ctxt->sax->startElement = *(startElementSAXFunc *)value;
                                                          }
                                                        }

                                                        else
                                                        {
                                                          ctxt->sax->endDocumentSAXFunc endDocument = *(endDocumentSAXFunc *)value;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        ctxt->sax->startDocumentSAXFunc startDocument = *(startDocumentSAXFunc *)value;
                                                      }
                                                    }

                                                    else
                                                    {
                                                      ctxt->sax->setDocumentLocatorSAXFunc setDocumentLocator = *(setDocumentLocatorSAXFunc *)value;
                                                    }
                                                  }

                                                  else
                                                  {
                                                    ctxt->sax->unparsedEntityDecl = *(unparsedEntityDeclSAXFunc *)value;
                                                  }
                                                }

                                                else
                                                {
                                                  ctxt->sax->elementDecl = *(elementDeclSAXFunc *)value;
                                                }
                                              }

                                              else
                                              {
                                                ctxt->sax->attributeDecl = *(attributeDeclSAXFunc *)value;
                                              }
                                            }

                                            else
                                            {
                                              ctxt->sax->notationDecl = *(notationDeclSAXFunc *)value;
                                            }
                                          }

                                          else
                                          {
                                            ctxt->sax->entityDecl = *(entityDeclSAXFunc *)value;
                                          }
                                        }

                                        else
                                        {
                                          ctxt->sax->getEntity = *(getEntitySAXFunc *)value;
                                        }
                                      }

                                      else
                                      {
                                        ctxt->sax->resolveEntity = *(resolveEntitySAXFunc *)value;
                                      }
                                    }

                                    else
                                    {
                                      ctxt->sax->hasExternalSubset = *(hasExternalSubsetSAXFunc *)value;
                                    }
                                  }

                                  else
                                  {
                                    ctxt->sax->hasInternalSubset = *(hasInternalSubsetSAXFunc *)value;
                                  }
                                }

                                else
                                {
                                  ctxt->sax->isStandalone = *(isStandaloneSAXFunc *)value;
                                }
                              }

                              else
                              {
                                ctxt->sax->internalSubset = *(internalSubsetSAXFunc *)value;
                              }
                            }

                            else
                            {
                              ctxt->sax = *(_xmlSAXHandler **)value;
                            }
                          }

                          else
                          {
                            ctxt->int valid = *(_DWORD *)value;
                          }
                        }

                        else
                        {
                          ctxt->wellFormed = *(_DWORD *)value;
                        }
                      }

                      else
                      {
                        ctxt->xmlDocPtr myDoc = *(xmlDocPtr *)value;
                      }
                    }

                    else
                    {
                      ctxt->standalone = *(_DWORD *)value;
                    }
                  }

                  else
                  {
                    ctxt->html = *(_DWORD *)value;
                  }
                }

                else
                {
                  ctxt->userData = *(void **)value;
                }
              }

              else
              {
                ctxt->record_xmlParserNodeInfo info = *(_DWORD *)value;
              }
            }

            else
            {
              ctxt->replaceEntities = *(_DWORD *)value;
            }
          }

          else
          {
            ctxt->loadsubset = *(_DWORD *)value;
          }
        }

        else
        {
          ctxt->disableSAX = *(_DWORD *)value;
        }
      }

      else
      {
        ctxt->keepBlanks = *(_DWORD *)value;
      }
    }
  }

  return result;
}

xmlChar *__cdecl xmlDecodeEntities(xmlParserCtxtPtr ctxt, int len, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  if ((xmlDecodeEntities_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v6 = *__xmlGenericError();
    int v7 = __xmlGenericErrorContext();
    v6(*v7, "xmlDecodeEntities() deprecated function reached\n");
    xmlDecodeEntities_deprecated = 1;
  }

  return 0LL;
}

xmlChar *__cdecl xmlNamespaceParseNCName(xmlParserCtxtPtr ctxt)
{
  if ((xmlNamespaceParseNCName_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    uint64_t v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlNamespaceParseNCName() deprecated function reached\n");
    xmlNamespaceParseNCName_deprecated = 1;
  }

  return 0LL;
}

xmlChar *__cdecl xmlNamespaceParseQName(xmlParserCtxtPtr ctxt, xmlChar **prefix)
{
  if ((xmlNamespaceParseQName_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "xmlNamespaceParseQName() deprecated function reached\n");
    xmlNamespaceParseQName_deprecated = 1;
  }

  return 0LL;
}

xmlChar *__cdecl xmlNamespaceParseNSDef(xmlParserCtxtPtr ctxt)
{
  if ((xmlNamespaceParseNSDef_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlNamespaceParseNSDef() deprecated function reached\n");
    xmlNamespaceParseNSDef_deprecated = 1;
  }

  return 0LL;
}

xmlChar *__cdecl xmlParseQuotedString(xmlParserCtxtPtr ctxt)
{
  if ((xmlParseQuotedString_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParseQuotedString() deprecated function reached\n");
    xmlParseQuotedString_deprecated = 1;
  }

  return 0LL;
}

void xmlParseNamespace(xmlParserCtxtPtr ctxt)
{
  if ((xmlParseNamespace_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParseNamespace() deprecated function reached\n");
    xmlParseNamespace_deprecated = 1;
  }

xmlChar *__cdecl xmlScanName(xmlParserCtxtPtr ctxt)
{
  if ((xmlScanName_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlScanName() deprecated function reached\n");
    xmlScanName_deprecated = 1;
  }

  return 0LL;
}

void xmlParserHandleReference(xmlParserCtxtPtr ctxt)
{
  if ((xmlParserHandleReference_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    xmlGenericErrorFunc v2 = __xmlGenericErrorContext();
    v1(*v2, "xmlParserHandleReference() deprecated function reached\n");
    xmlParserHandleReference_deprecated = 1;
  }

void xmlHandleEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr entity)
{
  if ((xmlHandleEntity_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    int v3 = __xmlGenericErrorContext();
    v2(*v3, "xmlHandleEntity() deprecated function reached\n");
    xmlHandleEntity_deprecated = 1;
  }

xmlNsPtr xmlNewGlobalNs(xmlDocPtr doc, const xmlChar *href, const xmlChar *prefix)
{
  if ((xmlNewGlobalNs_deprecated & 1) == 0)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    int v4 = __xmlGenericErrorContext();
    v3(*v4, "xmlNewGlobalNs() deprecated function reached\n");
    xmlNewGlobalNs_deprecated = 1;
  }

  return 0LL;
}

const xmlChar *__cdecl xmlEncodeEntities(xmlDocPtr doc, const xmlChar *input)
{
  if ((xmlEncodeEntities_warning & 1) == 0)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    xmlGenericErrorFunc v3 = __xmlGenericErrorContext();
    v2(*v3, "Deprecated API xmlEncodeEntities() used\n");
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "   change code to use xmlEncodeEntitiesReentrant()\n");
    xmlEncodeEntities_warning = 1;
  }

  return 0LL;
}

const xmlChar *__cdecl getPublicId(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getPublicId");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetPublicId(ctx);
}

const xmlChar *__cdecl getSystemId(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getSystemId");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetSystemId(ctx);
}

int getLineNumber(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getLineNumber");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetLineNumber(ctx);
}

int getColumnNumber(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "getColumnNumber");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2GetColumnNumber(ctx);
}

int isStandalone(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "isStandalone");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2IsStandalone(ctx);
}

int hasInternalSubset(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "hasInternalSubset");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2HasInternalSubset(ctx);
}

int hasExternalSubset(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "hasExternalSubset");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return xmlSAX2HasExternalSubset(ctx);
}

void internalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "internalSubset");
    int v8 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v8 + 1;
  xmlSAX2InternalSubset(ctx, name, ExternalID, SystemID);
}

void externalSubset(void *ctx, const xmlChar *name, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "externalSubset");
    int v8 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v8 + 1;
  xmlSAX2ExternalSubset(ctx, name, ExternalID, SystemID);
}

xmlParserInputPtr resolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "resolveEntity");
    int v6 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v6 + 1;
  return xmlSAX2ResolveEntity(ctx, publicId, systemId);
}

xmlEntityPtr getEntity(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "getEntity");
    int v4 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v4 + 1;
  return xmlSAX2GetEntity(ctx, name);
}

xmlEntityPtr getParameterEntity(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "getParameterEntity");
    int v4 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v4 + 1;
  return xmlSAX2GetParameterEntity(ctx, name);
}

void entityDecl( void *ctx, const xmlChar *name, int type, const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
{
  int v12 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v13 = *__xmlGenericError();
    char v14 = __xmlGenericErrorContext();
    v13(*v14, "Use of deprecated SAXv1 function %s\n", "entityDecl");
    int v12 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v12 + 1;
  xmlSAX2EntityDecl(ctx, name, type, publicId, systemId, content);
}

void attributeDecl( void *ctx, const xmlChar *elem, const xmlChar *fullname, int type, int def, const xmlChar *defaultValue, xmlEnumerationPtr tree)
{
  int v14 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v15 = *__xmlGenericError();
    BOOL v16 = __xmlGenericErrorContext();
    v15(*v16, "Use of deprecated SAXv1 function %s\n", "attributeDecl");
    int v14 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v14 + 1;
  xmlSAX2AttributeDecl(ctx, elem, fullname, type, def, defaultValue, tree);
}

void elementDecl(void *ctx, const xmlChar *name, int type, xmlElementContentPtr content)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "elementDecl");
    int v8 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v8 + 1;
  xmlSAX2ElementDecl(ctx, name, type, content);
}

void notationDecl(void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId)
{
  int v8 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Use of deprecated SAXv1 function %s\n", "notationDecl");
    int v8 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v8 + 1;
  xmlSAX2NotationDecl(ctx, name, publicId, systemId);
}

void unparsedEntityDecl( void *ctx, const xmlChar *name, const xmlChar *publicId, const xmlChar *systemId, const xmlChar *notationName)
{
  int v10 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v11 = *__xmlGenericError();
    int v12 = __xmlGenericErrorContext();
    v11(*v12, "Use of deprecated SAXv1 function %s\n", "unparsedEntityDecl");
    int v10 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v10 + 1;
  xmlSAX2UnparsedEntityDecl(ctx, name, publicId, systemId, notationName);
}

void setDocumentLocator(void *ctx, xmlSAXLocatorPtr loc)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    int v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "setDocumentLocator");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
}

void endDocument(void *ctx)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    int v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "endDocument");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  xmlSAX2EndDocument(ctx);
}

void attribute(void *ctx, const xmlChar *fullname, const xmlChar *value)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "attribute");
    int v3 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v3 + 1;
}

void endElement(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "endElement");
    int v4 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v4 + 1;
  xmlSAX2EndElement(ctx, name);
}

void reference(void *ctx, const xmlChar *name)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "reference");
    int v4 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v4 + 1;
  xmlSAX2Reference(ctx, name);
}

void characters(void *ctx, const xmlChar *ch, int len)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "characters");
    int v6 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v6 + 1;
  xmlSAX2Characters(ctx, ch, len);
}

void ignorableWhitespace(void *ctx, const xmlChar *ch, int len)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "ignorableWhitespace");
    int v3 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v3 + 1;
}

void processingInstruction(void *ctx, const xmlChar *target, const xmlChar *data)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "processingInstruction");
    int v6 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v6 + 1;
  xmlSAX2ProcessingInstruction(ctx, target, data);
}

void globalNamespace(void *ctx, const xmlChar *href, const xmlChar *prefix)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "globalNamespace");
    int v3 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v3 + 1;
}

void setNamespace(void *ctx, const xmlChar *name)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "setNamespace");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
}

xmlNsPtr getNamespace(void *ctx)
{
  int v1 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    xmlGenericErrorFunc v3 = __xmlGenericErrorContext();
    v2(*v3, "Use of deprecated SAXv1 function %s\n", "getNamespace");
    int v1 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v1 + 1;
  return 0LL;
}

int checkNamespace(void *ctx, xmlChar *nameSpace)
{
  int v2 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v3 = *__xmlGenericError();
    xmlGenericErrorFunc v4 = __xmlGenericErrorContext();
    v3(*v4, "Use of deprecated SAXv1 function %s\n", "checkNamespace");
    int v2 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v2 + 1;
  return 0;
}

void namespaceDecl(void *ctx, const xmlChar *href, const xmlChar *prefix)
{
  int v3 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
    v4(*v5, "Use of deprecated SAXv1 function %s\n", "namespaceDecl");
    int v3 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v3 + 1;
}

void comment(void *ctx, const xmlChar *value)
{
  int v4 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    int v6 = __xmlGenericErrorContext();
    v5(*v6, "Use of deprecated SAXv1 function %s\n", "comment");
    int v4 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v4 + 1;
  xmlSAX2Comment(ctx, value);
}

void cdataBlock(void *ctx, const xmlChar *value, int len)
{
  int v6 = deprecated_v1_msg;
  if (!deprecated_v1_msg)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Use of deprecated SAXv1 function %s\n", "cdataBlock");
    int v6 = deprecated_v1_msg;
  }

  deprecated_v1_msg = v6 + 1;
  xmlSAX2CDataBlock(ctx, value, len);
}

xmlListPtr xmlListCreate(xmlListDeallocator deallocator, xmlListDataCompare compare)
{
  int v4 = xmlMalloc(0x18uLL);
  if (!v4)
  {
    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Cannot initialize memory for list");
    return 0LL;
  }

  xmlGenericErrorFunc v5 = v4;
  *int v4 = 0LL;
  v4[1] = 0LL;
  v4[2] = 0LL;
  int v6 = xmlMalloc(0x18uLL);
  *xmlGenericErrorFunc v5 = v6;
  if (!v6)
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Cannot initialize memory for sentinel");
    xmlFree(v5);
    return 0LL;
  }

  *int v6 = v6;
  v6[1] = v6;
  void v6[2] = 0LL;
  if (deallocator) {
    v5[1] = deallocator;
  }
  if (compare) {
    v5[2] = compare;
  }
  else {
    v5[2] = xmlLinkCompare;
  }
  return (xmlListPtr)v5;
}

uint64_t xmlLinkCompare(unint64_t a1, unint64_t a2)
{
  if (a1 < a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a1 != a2;
  }
}

void *__cdecl xmlListSearch(void *l, void *data)
{
  if (l)
  {
    l = xmlListLinkSearch((uint64_t)l, (uint64_t)data);
    if (l) {
      return (void *)*((void *)l + 2);
    }
  }

  return l;
}

void *xmlListLinkSearch(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)a1;
  do
  {
    int v4 = (void *)*v4;
    if (v4 == *(void **)a1) {
      return 0LL;
    }
  }

  while (((*(uint64_t (**)(void, uint64_t))(a1 + 16))(v4[2], a2) & 0x80000000) != 0);
  if (v4 == *(void **)a1) {
    return 0LL;
  }
  else {
    return v4;
  }
}

void *__cdecl xmlListReverseSearch(void *l, void *data)
{
  if (l)
  {
    l = (void *)xmlListLinkReverseSearch((uint64_t *)l, (uint64_t)data);
    if (l) {
      return (void *)*((void *)l + 2);
    }
  }

  return l;
}

uint64_t xmlListLinkReverseSearch(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  do
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == *a1) {
      return 0LL;
    }
  }

  while (((int (*)(void, uint64_t))a1[2])(*(void *)(v4 + 16), a2) > 0);
  if (v4 == *a1) {
    return 0LL;
  }
  else {
    return v4;
  }
}

int xmlListInsert(xmlListPtr l, void *data)
{
  if (!l) {
    return 1;
  }
  uint64_t v4 = *(void **)l;
  do
    uint64_t v4 = (void *)*v4;
  while (v4 != *(void **)l && ((*((uint64_t (**)(void, void *))l + 2))(v4[2], data) & 0x80000000) != 0);
  xmlGenericErrorFunc v5 = xmlMalloc(0x18uLL);
  if (v5)
  {
    int v6 = v5;
    int result = 0;
    uint64_t v8 = v4[1];
    *int v6 = *(void *)v8;
    *(void *)(*(void *)v8 + 8LL) = v6;
    *(void *)uint64_t v8 = v6;
    v6[1] = v8;
    void v6[2] = data;
  }

  else
  {
    xmlGenericErrorFunc v9 = *__xmlGenericError();
    int v10 = __xmlGenericErrorContext();
    v9(*v10, "Cannot initialize memory for new link");
    return 1;
  }

  return result;
}

int xmlListAppend(xmlListPtr l, void *data)
{
  if (!l) {
    return 1;
  }
  uint64_t v4 = *(void **)l;
  do
    uint64_t v4 = (void *)v4[1];
  while (v4 != *(void **)l && (*((int (**)(void, void *))l + 2))(v4[2], data) > 0);
  xmlGenericErrorFunc v5 = xmlMalloc(0x18uLL);
  if (v5)
  {
    int v6 = v5;
    int result = 0;
    *int v6 = *v4;
    *(void *)(*v4 + 8LL) = v6;
    *uint64_t v4 = v6;
    v6[1] = v4;
    void v6[2] = data;
  }

  else
  {
    xmlGenericErrorFunc v8 = *__xmlGenericError();
    xmlGenericErrorFunc v9 = __xmlGenericErrorContext();
    v8(*v9, "Cannot initialize memory for new link");
    return 1;
  }

  return result;
}

void xmlListDelete(xmlListPtr l)
{
  if (l)
  {
    xmlListClear(l);
    xmlFree(*(void **)l);
    xmlFree(l);
  }

void xmlListClear(xmlListPtr l)
{
  if (l)
  {
    int v2 = **(void ***)l;
    if (v2 != *(void **)l)
    {
      do
      {
        uint64_t v4 = (void *)*v2;
        int v3 = (void *)v2[1];
        void *v3 = *v2;
        *(void *)(*v2 + 8LL) = v3;
        xmlGenericErrorFunc v5 = (void (*)(void *))*((void *)l + 1);
        if (v5) {
          v5(v2);
        }
        xmlFree(v2);
        int v2 = v4;
      }

      while (v4 != *(void **)l);
    }
  }

int xmlListRemoveFirst(xmlListPtr l, void *data)
{
  if (l)
  {
    xmlListPtr v2 = l;
    l = (xmlListPtr)xmlListLinkSearch((uint64_t)l, (uint64_t)data);
    if (l)
    {
      xmlListPtr v3 = l;
      uint64_t v4 = (void *)*((void *)l + 1);
      *uint64_t v4 = *(void *)l;
      *(void *)(*(void *)l + 8LL) = v4;
      xmlGenericErrorFunc v5 = (void (*)(xmlListPtr))*((void *)v2 + 1);
      if (v5) {
        v5(l);
      }
      xmlFree(v3);
      LODWORD(l) = 1;
    }
  }

  return (int)l;
}

int xmlListRemoveLast(xmlListPtr l, void *data)
{
  if (l)
  {
    xmlListPtr v2 = l;
    l = (xmlListPtr)xmlListLinkReverseSearch((uint64_t *)l, (uint64_t)data);
    if (l)
    {
      xmlListPtr v3 = l;
      uint64_t v4 = (void *)*((void *)l + 1);
      *uint64_t v4 = *(void *)l;
      *(void *)(*(void *)l + 8LL) = v4;
      xmlGenericErrorFunc v5 = (void (*)(xmlListPtr))*((void *)v2 + 1);
      if (v5) {
        v5(l);
      }
      xmlFree(v3);
      LODWORD(l) = 1;
    }
  }

  return (int)l;
}

int xmlListRemoveAll(xmlListPtr l, void *data)
{
  if (!l) {
    return 0;
  }
  int v4 = -1;
  do
    ++v4;
  while (xmlListRemoveFirst(l, data));
  return v4;
}

int xmlListEmpty(xmlListPtr l)
{
  if (l) {
    return **(void **)l == *(void *)l;
  }
  else {
    return -1;
  }
}

xmlLinkPtr xmlListFront(xmlLinkPtr l)
{
  if (l) {
    return **(xmlLinkPtr **)l;
  }
  return l;
}

xmlLinkPtr xmlListEnd(xmlLinkPtr l)
{
  if (l) {
    return *(xmlLinkPtr *)(*(void *)l + 8LL);
  }
  return l;
}

int xmlListSize(xmlListPtr l)
{
  if (!l) {
    return -1;
  }
  int v1 = *(void **)l;
  int result = -1;
  xmlListPtr v3 = v1;
  do
  {
    xmlListPtr v3 = (void *)*v3;
    ++result;
  }

  while (v3 != v1);
  return result;
}

void xmlListPopFront(xmlListPtr l)
{
  if (l)
  {
    int v1 = **(void ***)l;
    if (v1 != *(void **)l)
    {
      xmlListPtr v2 = (void *)v1[1];
      void *v2 = *v1;
      *(void *)(*v1 + 8LL) = v2;
      xmlListPtr v3 = (void (*)(void *))*((void *)l + 1);
      if (v3) {
        v3(v1);
      }
      xmlFree(v1);
    }
  }

void xmlListPopBack(xmlListPtr l)
{
  if (l && **(void **)l != *(void *)l)
  {
    int v1 = *(void **)(*(void *)l + 8LL);
    xmlListPtr v2 = (void *)v1[1];
    void *v2 = *v1;
    *(void *)(*v1 + 8LL) = v2;
    xmlListPtr v3 = (void (*)(void *))*((void *)l + 1);
    if (v3) {
      v3(v1);
    }
    xmlFree(v1);
  }

int xmlListPushFront(xmlListPtr l, void *data)
{
  if (l)
  {
    uint64_t v3 = *(void *)l;
    l = (xmlListPtr)xmlMalloc(0x18uLL);
    if (l)
    {
      *(void *)l = *(void *)v3;
      *(void *)(*(void *)v3 + 8LL) = l;
      *(void *)uint64_t v3 = l;
      *((void *)l + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v3;
      *((void *)l + 2) = data;
      LODWORD(l) = 1;
    }

    else
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
      v4(*v5, "Cannot initialize memory for new link");
      LODWORD(l) = 0;
    }
  }

  return (int)l;
}

int xmlListPushBack(xmlListPtr l, void *data)
{
  if (l)
  {
    uint64_t v3 = *(void *)(*(void *)l + 8LL);
    l = (xmlListPtr)xmlMalloc(0x18uLL);
    if (l)
    {
      *(void *)l = *(void *)v3;
      *(void *)(*(void *)v3 + 8LL) = l;
      *(void *)uint64_t v3 = l;
      *((void *)l + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v3;
      *((void *)l + 2) = data;
      LODWORD(l) = 1;
    }

    else
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      xmlGenericErrorFunc v5 = __xmlGenericErrorContext();
      v4(*v5, "Cannot initialize memory for new link");
      LODWORD(l) = 0;
    }
  }

  return (int)l;
}

void *__cdecl xmlLinkGetData(void *lk)
{
  if (lk) {
    return (void *)*((void *)lk + 2);
  }
  return lk;
}

void xmlListReverse(xmlListPtr l)
{
  if (l)
  {
    int v1 = *(void ***)l;
    xmlListPtr v2 = **(void ***)l;
    uint64_t v3 = *(void **)l;
    if (v2 != *(void **)l)
    {
      xmlGenericErrorFunc v4 = *(void **)l;
      do
      {
        uint64_t v3 = v2;
        *xmlGenericErrorFunc v4 = v4[1];
        v4[1] = v2;
        xmlListPtr v2 = (void *)*v2;
        xmlGenericErrorFunc v4 = v3;
      }

      while (v2 != v1);
    }

    void *v3 = v3[1];
    v3[1] = v1;
  }

void xmlListSort(xmlListPtr l)
{
  if (l && **(void **)l != *(void *)l)
  {
    xmlListPtr v2 = xmlListDup(l);
    if (v2)
    {
      uint64_t v3 = v2;
      xmlListClear(l);
      xmlListCopy(l, v3);
      xmlListClear(v3);
      xmlListClear(v3);
      xmlFree(*(void **)v3);
      xmlFree(v3);
    }
  }

xmlListPtr xmlListDup(xmlListPtr old)
{
  if (old)
  {
    int v1 = old;
    old = xmlListCreate(0LL, *((xmlListDataCompare *)old + 2));
    if (old)
    {
      xmlListPtr v2 = old;
      if (xmlListCopy(old, v1)) {
        return 0LL;
      }
      else {
        return v2;
      }
    }
  }

  return old;
}

void xmlListMerge(xmlListPtr l1, xmlListPtr l2)
{
}

void xmlListWalk(xmlListPtr l, xmlListWalker walker, const void *user)
{
  if (l && walker)
  {
    int v6 = *(void **)l;
    do
      int v6 = (void *)*v6;
    while (v6 != *(void **)l && ((unsigned int (*)(void, const void *))walker)(v6[2], user));
  }

void xmlListReverseWalk(xmlListPtr l, xmlListWalker walker, const void *user)
{
  if (l && walker)
  {
    uint64_t v6 = *(void *)l;
    do
      uint64_t v6 = *(void *)(v6 + 8);
    while (v6 != *(void *)l
         && ((unsigned int (*)(void, const void *))walker)(*(void *)(v6 + 16), user));
  }

int xmlListCopy(xmlListPtr cur, const xmlListPtr old)
{
  int result = 1;
  if (cur && old)
  {
    xmlGenericErrorFunc v5 = *(uint64_t **)old;
    while (1)
    {
      xmlGenericErrorFunc v5 = (uint64_t *)*v5;
      if (xmlListInsert(cur, (void *)v5[2]))
      {
        xmlListClear(cur);
        xmlFree(*(void **)cur);
        xmlFree(cur);
        return 1;
      }
    }

    return 0;
  }

  return result;
}

void xmlNanoFTPInit(void)
{
  if ((initialized & 1) == 0)
  {
    proxyPort = 21;
    xmlGenericErrorFunc v0 = getenv("no_proxy");
    if (!v0 || *v0 != 42 || v0[1])
    {
      int v1 = getenv("ftp_proxy");
      if (v1 || (int v1 = getenv("FTP_PROXY")) != 0LL) {
        xmlNanoFTPScanProxy(v1);
      }
      xmlListPtr v2 = getenv("ftp_proxy_user");
      if (v2) {
        proxyUser = (uint64_t)xmlMemStrdup(v2);
      }
      uint64_t v3 = getenv("ftp_proxy_password");
      if (v3) {
        proxyPasswd = (uint64_t)xmlMemStrdup(v3);
      }
      initialized = 1;
    }
  }

void xmlNanoFTPScanProxy(const char *URL)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0LL;
  }

  proxyPort = 0;
  if (URL)
  {
    xmlURIPtr v2 = xmlParseURIRaw(URL, 1);
    if (v2)
    {
      uint64_t v3 = v2;
      scheme = v2->scheme;
      if (scheme && !strcmp(scheme, "ftp") && (server = v3->server) != 0LL)
      {
        proxy = (uint64_t)xmlMemStrdup(server);
        if (v3->port) {
          proxyPort = v3->port;
        }
      }

      else
      {
        __xmlIOErr(9, 2003, (uint64_t)"Syntax Error\n");
      }

      xmlFreeURI(v3);
    }

    else
    {
      __xmlIOErr(9, 2003, (uint64_t)"Syntax Error\n");
    }
  }

void xmlNanoFTPCleanup(void)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0LL;
  }

  if (proxyUser)
  {
    xmlFree((void *)proxyUser);
    proxyUser = 0LL;
  }

  if (proxyPasswd)
  {
    xmlFree((void *)proxyPasswd);
    proxyPasswd = 0LL;
  }

  initialized = 0;
}

void xmlNanoFTPProxy(const char *host, int port, const char *user, const char *passwd, int type)
{
  if (proxy)
  {
    xmlFree((void *)proxy);
    proxy = 0LL;
  }

  if (proxyUser)
  {
    xmlFree((void *)proxyUser);
    proxyUser = 0LL;
  }

  if (proxyPasswd)
  {
    xmlFree((void *)proxyPasswd);
    proxyPasswd = 0LL;
  }

  if (host) {
    proxy = (uint64_t)xmlMemStrdup(host);
  }
  if (user) {
    proxyUser = (uint64_t)xmlMemStrdup(user);
  }
  if (passwd) {
    proxyPasswd = (uint64_t)xmlMemStrdup(passwd);
  }
  proxyPort = port;
  proxyType = type;
}

int xmlNanoFTPUpdateURL(void *ctx, const char *URL)
{
  int v2 = -1;
  if (ctx)
  {
    if (URL)
    {
      if (*(void *)ctx)
      {
        if (*((void *)ctx + 1))
        {
          xmlURIPtr v4 = xmlParseURIRaw(URL, 1);
          if (v4)
          {
            xmlGenericErrorFunc v5 = v4;
            if (!v4->scheme)
            {
LABEL_11:
              xmlFreeURI(v5);
              return v2;
            }

            server = v4->server;
            if (!server || strcmp(*(const char **)ctx, v4->scheme) || strcmp(*((const char **)ctx + 1), server))
            {
LABEL_10:
              int v2 = -1;
              goto LABEL_11;
            }

            int port = v5->port;
            if (port)
            {
              if (*((_DWORD *)ctx + 4) != port) {
                goto LABEL_10;
              }
              *((_DWORD *)ctx + 4) = port;
            }

            xmlGenericErrorFunc v9 = (void *)*((void *)ctx + 3);
            if (v9)
            {
              xmlFree(v9);
              *((void *)ctx + 3) = 0LL;
            }

            if (v5->path) {
              path = v5->path;
            }
            else {
              path = "/";
            }
            int v2 = 0;
            *((void *)ctx + 3) = xmlMemStrdup(path);
            goto LABEL_11;
          }
        }
      }
    }
  }

  return v2;
}

void *__cdecl xmlNanoFTPNewCtxt(const char *URL)
{
  int v2 = xmlMalloc(0x4D8uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    bzero(v2, 0x4D8uLL);
    *(_DWORD *)(v3 + 16) = 21;
    *(_DWORD *)(v3 + 192) = 0;
    *(void *)(v3 + 1224) = 0LL;
    *(void *)(v3 + 176) = 0xFFFFFFFF00000001LL;
    xmlURIPtr v4 = xmlURIUnescapeString(URL, 0, 0LL);
    if (v4)
    {
      xmlGenericErrorFunc v5 = v4;
      xmlNanoFTPScanURL(v3, v4);
      xmlFree(v5);
    }

    else if (URL)
    {
      xmlNanoFTPScanURL(v3, (char *)URL);
    }
  }

  else
  {
    __xmlSimpleError(9, 2, 0, 0LL, (uint64_t)"allocating FTP context");
  }

  return (void *)v3;
}

void xmlNanoFTPScanURL(uint64_t a1, char *str)
{
  xmlURIPtr v4 = *(void **)a1;
  if (v4)
  {
    xmlFree(v4);
    *(void *)a1 = 0LL;
  }

  xmlGenericErrorFunc v5 = *(void **)(a1 + 8);
  if (v5)
  {
    xmlFree(v5);
    *(void *)(a1 + 8) = 0LL;
  }

  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    xmlFree(v6);
    *(void *)(a1 + 24) = 0LL;
  }

  xmlURIPtr v7 = xmlParseURIRaw(str, 1);
  if (v7)
  {
    xmlGenericErrorFunc v8 = v7;
    scheme = v7->scheme;
    if (scheme && v8->server)
    {
      *(void *)a1 = xmlMemStrdup(scheme);
      *(void *)(a1 + 8) = xmlMemStrdup(v8->server);
      if (v8->path) {
        path = v8->path;
      }
      else {
        path = "/";
      }
      *(void *)(a1 + 24) = xmlMemStrdup(path);
      int port = v8->port;
      if (port) {
        *(_DWORD *)(a1 + 16) = port;
      }
      user = (const xmlChar *)v8->user;
      if (user)
      {
        xmlGenericErrorFunc v13 = strchr(v8->user, 58);
        if (v13)
        {
          int v14 = v13;
          *(void *)(a1 + 32) = xmlStrndup(user, (int)v13 - (int)user);
          *(void *)(a1 + 40) = xmlMemStrdup(v14 + 1);
        }

        else
        {
          *(void *)(a1 + 32) = xmlMemStrdup((const char *)user);
        }
      }
    }

    xmlFreeURI(v8);
  }

void xmlNanoFTPFreeCtxt(void *ctx)
{
  if (ctx)
  {
    int v2 = (void *)*((void *)ctx + 1);
    if (v2) {
      xmlFree(v2);
    }
    if (*(void *)ctx) {
      xmlFree(*(void **)ctx);
    }
    uint64_t v3 = (void *)*((void *)ctx + 3);
    if (v3) {
      xmlFree(v3);
    }
    xmlURIPtr v4 = (void *)*((void *)ctx + 4);
    if (v4) {
      xmlFree(v4);
    }
    xmlGenericErrorFunc v5 = (void *)*((void *)ctx + 5);
    if (v5) {
      xmlFree(v5);
    }
    *((_DWORD *)ctx + 44) = 1;
    int v6 = *((_DWORD *)ctx + 45);
    if (v6 != -1) {
      close(v6);
    }
    *((_DWORD *)ctx + 45) = -1;
    *((void *)ctx + 153) = -1LL;
    xmlFree(ctx);
  }

unint64_t xmlNanoFTPReadResponse(int *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (a1[45] != -1)
  {
    int v2 = (_DWORD)a1 + 196;
    signed int v3 = a1[306];
    do
    {
      int v4 = a1[307];
      if (v3)
      {
        memmove(a1 + 49, (char *)a1 + v3 + 196, v4 - v3);
        int v4 = a1[307] - a1[306];
        a1[307] = v4;
        a1[306] = 0;
      }

      if (v4 == 1024)
      {
        int v6 = 0;
        signed int v3 = 1024;
      }

      else
      {
        int v6 = recv(a1[45], a1 + 49, 1024 - v4, 0);
        if (v6 < 0)
        {
          __xmlIOErr(9, 0, (uint64_t)"recv failed");
          close(a1[45]);
          unint64_t result = 0xFFFFFFFFLL;
          a1[45] = -1;
          return result;
        }

        uint64_t v7 = a1[307] + (uint64_t)v6;
        a1[307] = v7;
        *((_BYTE *)a1 + v7 + 196) = 0;
        signed int v3 = a1[307];
      }

      if (!(v3 | v6)) {
        return 0xFFFFFFFFLL;
      }
      signed int v8 = a1[306];
      if (v8 < v3)
      {
        unint64_t v9 = (unint64_t)a1 + v3 + 196;
        int v10 = (unsigned __int8 *)a1 + v8 + 196;
        while (1)
        {
          unint64_t v11 = v9 - (void)v10;
          if ((int)v9 - (int)v10 >= 3)
          {
            int v12 = (char)*v10;
            if ((v12 - 48) <= 9)
            {
              int v13 = v10[1];
              if ((v13 - 48) <= 9)
              {
                int v14 = v10[2];
                if ((v14 - 48) <= 9)
                {
                  int v15 = v14 + 10 * (v13 + 10 * v12);
                  int v16 = 5328 - v15;
                  int v17 = v15 - 5328;
                  if (v10[3] == 45) {
                    int v17 = v16;
                  }
                  if (v17 > 0) {
                    break;
                  }
                }
              }
            }
          }

          if ((unint64_t)v10 >= v9)
          {
LABEL_32:
            a1[306] = v3;
            goto LABEL_33;
          }

          ++v10;
          while (*(v10 - 1) != 10)
          {
            ++v10;
            if (!--v11) {
              goto LABEL_32;
            }
          }
        }

        __int128 v19 = v10 + 3;
        a1[308] = (_DWORD)v10 + 3 - v2;
        if (*v19 == 10) {
          ++v19;
        }
        if (*v19 == 13) {
          LODWORD(v19) = (_DWORD)v19 + 1;
        }
        a1[306] = (_DWORD)v19 - v2;
        return v17 / 0x64uLL;
      }

int xmlNanoFTPCheckResponse(void *ctx)
{
  if (!ctx) {
    return -1;
  }
  unint64_t v2 = *((int *)ctx + 45);
  if ((_DWORD)v2 == -1) {
    return -1;
  }
  v4.tv_sec = 0LL;
  *(void *)&v4.tv_usec = 0LL;
  memset(&v5, 0, sizeof(v5));
  if (__darwin_check_fd_set_overflow(v2, &v5, 0)) {
    *(__int32_t *)((char *)v5.fds_bits + ((v2 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v2;
  }
  int result = select(*((_DWORD *)ctx + 45) + 1, &v5, 0LL, 0LL, &v4);
  if (result)
  {
    if (result == -1)
    {
      __xmlIOErr(9, 0, (uint64_t)"select");
      return -1;
    }

    return xmlNanoFTPReadResponse((int *)ctx);
  }

  return result;
}

int xmlNanoFTPQuit(void *ctx)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!ctx) {
    return -1;
  }
  int v1 = *((_DWORD *)ctx + 45);
  if (v1 == -1) {
    return -1;
  }
  char v17 = 0;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  *(_OWORD *)&v5[7] = 0u;
  __int128 v6 = 0u;
  strcpy(v5, "QUIT\r\n");
  int v2 = strlen(v5);
  int v3 = send(v1, v5, v2, 0);
  int result = 0;
  if (v3 < 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    return v3;
  }

  return result;
}

int xmlNanoFTPConnect(void *ctx)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (!ctx || !*((void *)ctx + 1)) {
    return -1;
  }
  uint64_t v2 = proxy;
  *((_OWORD *)ctx + 3) = 0u;
  if (v2) {
    int v3 = &proxyPort;
  }
  else {
    int v3 = (int *)((char *)ctx + 16);
  }
  unsigned int v4 = *v3;
  *((_OWORD *)ctx + 4) = 0uLL;
  *((_OWORD *)ctx + 5) = 0uLL;
  if (v4) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 21;
  }
  *((_OWORD *)ctx + 6) = 0uLL;
  *((_OWORD *)ctx + 7) = 0uLL;
  *((_OWORD *)ctx + 8) = 0uLL;
  *((_OWORD *)ctx + 9) = 0uLL;
  *((_OWORD *)ctx + 10) = 0uLL;
  int v6 = socket(30, 1, 0);
  if (v6 == -1)
  {
    __int128 v10 = (const char *)proxy;
    if (!proxy) {
      __int128 v10 = (const char *)*((void *)ctx + 1);
    }
    __int128 v11 = gethostbyname(v10);
    if (v11)
    {
      h_size_t length = v11->h_length;
      if (h_length < 5)
      {
        *((_BYTE *)ctx + 49) = 2;
        memcpy((char *)ctx + 52, *(const void **)v11->h_addr_list, h_length);
        *((_WORD *)ctx + 25) = bswap32(v5) >> 16;
        int v16 = socket(2, 1, 0);
        *((_DWORD *)ctx + 45) = v16;
        socklen_t v17 = 16;
LABEL_37:
        if (v16 != -1)
        {
          if (connect(v16, (const sockaddr *)ctx + 3, v17) < 0)
          {
            BOOL v25 = "Failed to create a connection";
            goto LABEL_53;
          }

          if (!proxy)
          {
LABEL_66:
            __int128 v43 = 0u;
            memset(v44, 0, 23);
            __int128 v41 = 0u;
            __int128 v42 = 0u;
            __int128 v39 = 0u;
            __int128 v40 = 0u;
            __int128 v37 = 0u;
            __int128 v38 = 0u;
            __int128 v36 = 0u;
            memset(&v35, 0, sizeof(v35));
            if (*((void *)ctx + 4)) {
              snprintf((char *)&v35, 0xC8uLL, "USER %s\r\n", *((const char **)ctx + 4));
            }
            else {
              strcpy((char *)&v35, "USER anonymous\r\n");
            }
            v44[23] = 0;
            int v29 = strlen((const char *)&v35);
            if ((send(*((_DWORD *)ctx + 45), &v35, v29, 0) & 0x80000000) == 0)
            {
              int v30 = xmlNanoFTPReadResponse((int *)ctx);
              if (v30 == 2) {
                return 0;
              }
              int v31 = xmlNanoFTPReadResponse((int *)ctx);
              if (v31 == 2) {
                return 0;
              }
              if (v31 == 3)
              {
                BOOL v25 = "FTP server asking for ACCNT on anonymous\n";
                int v26 = 2002;
                goto LABEL_54;
              }

LABEL_56:
              __xmlIOErr(9, 0, (uint64_t)"send failed");
              close(*((_DWORD *)ctx + 45));
              *((_DWORD *)ctx + 45) = -1;
              return v21;
            case 3:
              int v23 = (const char *)proxyPasswd;
              if (!proxyPasswd)
              {
                strcpy((char *)&v35, "PASS anonymous@\r\n");
                goto LABEL_60;
              }

              break;
            case 2:
              int v23 = (const char *)proxyPasswd;
              if (!proxyPasswd) {
                goto LABEL_62;
              }
              break;
            default:
              goto LABEL_55;
          }

          snprintf((char *)&v35, 0x190uLL, "PASS %s\r\n", v23);
LABEL_60:
          HIBYTE(v56) = 0;
          int v27 = strlen((const char *)&v35);
          int v21 = send(*((_DWORD *)ctx + 45), &v35, v27, 0);
          if (v21 < 0) {
            goto LABEL_56;
          }
          goto LABEL_62;
        }

        __int128 v9 = "socket failed";
        goto LABEL_49;
      }

      __int128 v9 = "gethostbyname address mismatch";
    }

    else
    {
      __int128 v9 = "gethostbyname failed";
    }
  }

  else
  {
    close(v6);
    size_t v34 = 0LL;
    memset(&v35, 0, sizeof(v35));
    v35.ai_sockxmlElementType type = 1;
    __int128 v7 = (const char *)proxy;
    if (!proxy) {
      __int128 v7 = (const char *)*((void *)ctx + 1);
    }
    if (!getaddrinfo(v7, 0LL, &v35, &v34) && v34)
    {
      __int128 v13 = v34;
      while (1)
      {
        int ai_family = v13->ai_family;
        if (ai_family == 2 || ai_family == 30) {
          break;
        }
        __int128 v13 = v13->ai_next;
        if (!v13)
        {
          __int128 v8 = "getaddrinfo failed";
LABEL_32:
          freeaddrinfo(v34);
          goto LABEL_14;
        }
      }

      ai_addrint len = v13->ai_addrlen;
      if (ai_addrlen > 0x80)
      {
        __int128 v8 = "gethostbyname address mismatch";
        goto LABEL_32;
      }

      memcpy((char *)ctx + 48, v13->ai_addr, ai_addrlen);
      *((_WORD *)ctx + 25) = bswap32(v5) >> 16;
      if (ai_family == 30) {
        int v19 = 30;
      }
      else {
        int v19 = 2;
      }
      *((_DWORD *)ctx + 45) = socket(v19, 1, 0);
      socklen_t v17 = v13->ai_addrlen;
      freeaddrinfo(v34);
      int v16 = *((_DWORD *)ctx + 45);
      goto LABEL_37;
    }

    __int128 v8 = "getaddrinfo failed";
LABEL_14:
    __int128 v9 = v8;
  }

      int v6 = xmlParseEnumeratedType(ctxt, tree);
      goto LABEL_57;
    }

    if (cur[1] != 68 || cur[2] != 65 || cur[3] != 84 || cur[4] != 65) {
      goto LABEL_56;
    }
    input->cur = cur + 5;
    input->col += 5;
    if (!cur[5]) {
      xmlParserInputGrow(input, 250);
    }
    int v6 = 1;
  }

      if (i->ns)
      {
        if (!v7)
        {
          int v30 = elem->parent;
          if (v30
            && (_xmlNode *)v30->doc != v30
            && xmlDOMWrapNSNormGatherInScopeNs(&v50, (uint64_t)v30) == -1)
          {
            unsigned int v5 = -1;
          }

          __int128 v7 = 1;
        }

        if (v49)
        {
          int v31 = v48;
          if ((int)v48 >= 1)
          {
            int v32 = v49 + 1;
            while (i->ns != *(v32 - 1))
            {
              v32 += 2;
              if (!--v31) {
                goto LABEL_70;
              }
            }

            i->ns = *v32;
          }
        }

        ;
      }

      return v6;
    case 4:
      if (doc->standalone != 1) {
        goto LABEL_133;
      }
      if (v64 != 1) {
        goto LABEL_133;
      }
      __int128 v48 = elem->children;
      if (!v48) {
        goto LABEL_133;
      }
      do
      {
        if (v48->type == XML_TEXT_NODE)
        {
          for (uint64_t j = v48->content; ; ++j)
          {
            __int128 v50 = *j;
            if (v50 > 0x20) {
              break;
            }
            if (((1LL << v50) & 0x100002600LL) == 0)
            {
              if (*j) {
                break;
              }
              xmlErrValidNode( (uint64_t *)v5,  (int)elem,  532,  (uint64_t)"standalone: %s declared in the external subset contains white spaces nodes\n",  (uint64_t)elem->name,  0LL,  0LL);
              int v6 = 0;
              goto LABEL_133;
            }
          }
        }

        __int128 v48 = v48->next;
      }

      while (v48);
      int v6 = 1;
LABEL_133:
      int64_t v63 = xmlValidateElementContent((uint64_t)v5, (uint64_t)elem->children);
      if (v63 < 1) {
        int v6 = v63;
      }
      goto LABEL_11;
    default:
      goto LABEL_11;
  }

LABEL_49:
  __xmlIOErr(9, 0, (uint64_t)v9);
  return -1;
}

      if (*(_DWORD *)(v10 + 24LL * v13 + 20) == 1
        || !v22 && (*v16 & 0x80000000) == 0 && *(_DWORD *)(v62 + 24) > DWORD2(v62) + 1)
      {
        xmlFARegExecSave((uint64_t)&v59);
      }

      __int128 v41 = *(unsigned int *)(v10 + 24LL * v13 + 12);
      if ((v41 & 0x80000000) != 0) {
        goto LABEL_86;
      }
      if (!(void)v64) {
        goto LABEL_91;
      }
      if (!v60) {
        goto LABEL_91;
      }
      __int128 v42 = *((void *)v60 + 6);
      if (!v42) {
        goto LABEL_91;
      }
      __int128 v43 = *(_DWORD *)(v64 + 4 * v41);
      if (v43 < *(_DWORD *)(v42 + 8 * v41 + 4)) {
        break;
      }
LABEL_59:
      __int128 v7 = DWORD2(v62) + 1;
      DWORD2(v62) = v7;
      int v6 = v62;
      if (v7 >= *(_DWORD *)(v62 + 24)) {
        goto LABEL_77;
      }
    }

    *(_DWORD *)(v64 + 4 * v4htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v43 + 1;
LABEL_86:
    __int128 v48 = *v16;
    if (v48 <= 0x123455)
    {
      if (!(void)v64)
      {
LABEL_91:
        LODWORD(v59) = -1;
        break;
      }

      *(_DWORD *)(v64 + 4 * v48) = 0;
    }

    *(void *)&xmlParserInputPtr v62 = *(void *)(*((void *)comp + 2) + 8LL * *v12);
    DWORD2(v62) = 0;
    if (*(void *)v11) {
      LODWORD(v65) = v65 + len;
    }
  }

  while (!(_DWORD)v59);
  __int128 v50 = (void *)*((void *)&v63 + 1);
  if (*((void *)&v63 + 1))
  {
    __int128 v51 = v63;
    if ((void)v64) {
      __int128 v52 = (int)v63 < 1;
    }
    else {
      __int128 v52 = 1;
    }
    if (!v52)
    {
      __int128 v53 = 0LL;
      __int128 v54 = v63;
      __int128 v55 = (void **)(*((void *)&v63 + 1) + 16LL);
      do
      {
        if (*v55)
        {
          xmlFree(*v55);
          __int128 v51 = v54;
        }

        ++v53;
        v55 += 3;
      }

      while (v53 < v51);
      __int128 v50 = (void *)*((void *)&v63 + 1);
    }

    xmlFree(v50);
  }

  if (!(void)v62) {
    return -1;
  }
  if ((void)v64) {
    xmlFree((void *)v64);
  }
  int result = v59;
  if (!(_DWORD)v59) {
    return 1;
  }
  if ((_DWORD)v59 == -1)
  {
    if (v69 <= 10000000) {
      return 0;
    }
    else {
      return -1;
    }
  }

  return result;
}

                  if ((v18 & 0x198) != 0)
                  {
                    addrinfo v35 = *(const xmlChar **)(v16 + 80);
                    if (v35)
                    {
                      int v20 = xmlStrlen(v35);
                      goto LABEL_53;
                    }

                    int v27 = (xmlNode *)v16;
                    int v26 = 0;
                    BOOL v25 = (xmlNode *)v16;
                    int v20 = 0;
LABEL_54:
                    __int128 v15 = xmlXPtrNewRange(v27, v26, v25, v20);
                  }
                }
              }

ssize_t xmlNanoFTPSendPasswd(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  __int128 v14 = 0u;
  memset(v15, 0, 23);
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  memset(__str, 0, sizeof(__str));
  if (*(void *)(a1 + 40)) {
    snprintf(__str, 0xC8uLL, "PASS %s\r\n", *(const char **)(a1 + 40));
  }
  else {
    strcpy(__str, "PASS anonymous@\r\n");
  }
  v15[23] = 0;
  int v2 = strlen(__str);
  ssize_t v3 = send(*(_DWORD *)(a1 + 180), __str, v2, 0);
  ssize_t result = 0LL;
  if ((v3 & 0x80000000) != 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    return v3;
  }

  return result;
}

void *__cdecl xmlNanoFTPConnectTo(const char *server, int port)
{
  unsigned int v4 = 0LL;
  if (server)
  {
    if (port >= 1)
    {
      unsigned int v4 = xmlNanoFTPNewCtxt(0LL);
      if (v4)
      {
        unsigned int v5 = xmlMemStrdup(server);
        v4[1] = v5;
        if (!v5 || (*((_DWORD *)v4 + 4) = port, xmlNanoFTPConnect(v4) < 0))
        {
          xmlNanoFTPFreeCtxt(v4);
          return 0LL;
        }
      }
    }
  }

  return v4;
}

int xmlNanoFTPCwd(void *ctx, const char *directory)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!ctx || *((_DWORD *)ctx + 45) == -1) {
    return -1;
  }
  if (!directory) {
    return 0;
  }
  __int128 v29 = 0u;
  memset(v30, 0, 31);
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v8 = 0u;
  snprintf(__str, 0x190uLL, "CWD %s\r\n", directory);
  v30[31] = 0;
  int v3 = strlen(__str);
  int v4 = send(*((_DWORD *)ctx + 45), __str, v3, 0);
  if (v4 < 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    return v4;
  }

  uint64_t v5 = (int)xmlNanoFTPReadResponse((int *)ctx) - 2LL;
  else {
    return 0;
  }
}

int xmlNanoFTPDele(void *ctx, const char *file)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  int v2 = -1;
  if (ctx && file && *((_DWORD *)ctx + 45) != -1)
  {
    __int128 v29 = 0u;
    memset(v30, 0, 31);
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    *(_OWORD *)__str = 0u;
    __int128 v8 = 0u;
    snprintf(__str, 0x190uLL, "DELE %s\r\n", file);
    v30[31] = 0;
    int v4 = strlen(__str);
    int v2 = send(*((_DWORD *)ctx + 45), __str, v4, 0);
    if (v2 < 0)
    {
      __xmlIOErr(9, 0, (uint64_t)"send failed");
    }

    else
    {
      uint64_t v5 = (int)xmlNanoFTPReadResponse((int *)ctx) - 2LL;
      else {
        return dword_181A37160[v5];
      }
    }
  }

  return v2;
}

int xmlNanoFTPGetConnection(void *ctx)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (ctx)
  {
    memset(v23, 0, sizeof(v23));
    if (*((_BYTE *)ctx + 49) == 30)
    {
      int v2 = socket(30, 1, 6);
      *((_DWORD *)ctx + 46) = v2;
      v23[0].sa_family = 30;
      socklen_t v3 = 28;
    }

    else
    {
      int v2 = socket(2, 1, 6);
      *((_DWORD *)ctx + 46) = v2;
      v23[0].sa_family = 2;
      socklen_t v3 = 16;
    }

    socklen_t v20 = v3;
    if (v2 != -1)
    {
      uint64_t v28 = 0LL;
      memset(__s, 0, sizeof(__s));
      uint64_t v25 = 0LL;
      uint64_t v26 = 0LL;
      uint64_t v24 = 0LL;
      if (*((_DWORD *)ctx + 44))
      {
        if (*((_BYTE *)ctx + 49) == 30)
        {
          *(_DWORD *)((char *)__s + 3) = 658774;
          unsigned __int16 v4 = 20549;
        }

        else
        {
          *(_DWORD *)((char *)__s + 3) = 658774;
          unsigned __int16 v4 = 16720;
        }

        LODWORD(__s[0]) = v4 | 0x56530000;
        int v6 = strlen((const char *)__s);
        if ((send(*((_DWORD *)ctx + 45), __s, v6, 0) & 0x80000000) == 0)
        {
          int v7 = xmlNanoFTPReadResponse((int *)ctx);
          if (v7 == 2)
          {
LABEL_20:
            __int128 v8 = (char *)ctx + *((int *)ctx + 308) + 195;
            do
            {
              int v9 = *(unsigned __int8 *)++v8;
              unsigned int v10 = v9 - 48;
              if (v9) {
                BOOL v11 = v10 > 9;
              }
              else {
                BOOL v11 = 0;
              }
            }

            while (v11);
            if (*((_BYTE *)ctx + 49) == 30)
            {
              if (sscanf(v8, "%u", &v24) == 1)
              {
                *(sockaddr *)&v23[0].sa_data[6] = *(sockaddr *)((char *)ctx + 56);
                unsigned int v12 = bswap32((unsigned __int16)v24) >> 16;
                goto LABEL_33;
              }

              __int128 v17 = "Invalid answer to EPSV\n";
              int v18 = 2001;
            }

            else
            {
              if (sscanf( v8,  "%u,%u,%u,%u,%u,%u",  &v24,  (char *)&v24 + 4,  &v25,  (char *)&v25 + 4,  &v26,  (char *)&v26 + 4) == 6)
              {
                uint64_t v14 = 0LL;
                *(_WORD *)&v21[4] = 0;
                *(_DWORD *)__int128 v21 = 0;
                do
                {
                  v21[v14] = *((_DWORD *)&v24 + v14);
                  ++v14;
                }

                while (v14 != 6);
                *(_DWORD *)&v23[0].sa_data[2] = *(_DWORD *)v21;
                LOWORD(v12) = *(_WORD *)&v21[4];
LABEL_33:
                *(_WORD *)v23[0].sa_xmlCatalogPtr data = v12;
                if (connect(*((_DWORD *)ctx + 46), v23, v3) < 0)
                {
                  __int128 v13 = "Failed to create a data connection";
                  goto LABEL_41;
                }

                return *((_DWORD *)ctx + 46);
              }

              __int128 v17 = "Invalid answer to PASV\n";
              int v18 = 2000;
            }

            __xmlIOErr(9, v18, (uint64_t)v17);
            int v19 = *((_DWORD *)ctx + 46);
            int v5 = -1;
            if (v19 == -1) {
              return v5;
            }
            close(v19);
            goto LABEL_43;
          }

          if (v7 != 5)
          {
            close(*((_DWORD *)ctx + 46));
            *((_DWORD *)ctx + 46) = -1;
            *((_DWORD *)ctx + 44) = 0;
            goto LABEL_20;
          }

int xmlNanoFTPCloseConnection(void *ctx)
{
  if (!ctx) {
    return -1;
  }
  int v2 = -1;
  if (*((_DWORD *)ctx + 45) != -1)
  {
    close(*((_DWORD *)ctx + 46));
    *((_DWORD *)ctx + 46) = -1;
    __int128 v7 = xmmword_181A37150;
    DWORD2(v7) = 0;
    memset(&v9, 0, sizeof(v9));
    int v3 = *((_DWORD *)ctx + 45);
    if (__darwin_check_fd_set_overflow(v3, &v9, 0)) {
      *(__int32_t *)((char *)v9.fds_bits + (((unint64_t)v3 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v3;
    }
    memset(&v8, 0, sizeof(v8));
    int v4 = *((_DWORD *)ctx + 45);
    if (__darwin_check_fd_set_overflow(v4, &v8, 0)) {
      *(__int32_t *)((char *)v8.fds_bits + (((unint64_t)v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v4;
    }
    int v5 = select(*((_DWORD *)ctx + 45) + 1, &v9, 0LL, &v8, (timeval *)&v7);
    if ((v5 & 0x80000000) == 0)
    {
      if (!v5)
      {
        int v2 = 0;
        goto LABEL_14;
      }
    }

    int v2 = -1;
LABEL_14:
    close(*((_DWORD *)ctx + 45));
    *((_DWORD *)ctx + 45) = -1;
  }

  return v2;
}

int xmlNanoFTPList(void *ctx, ftpListCallback callback, void *userData, const char *filename)
{
  uint64_t v4 = MEMORY[0x1895F8858](ctx, callback);
  uint64_t v85 = *MEMORY[0x1895F89C0];
  if (!v4) {
    return -1;
  }
  fd_set v8 = v7;
  uint64_t v9 = v6;
  unsigned int v10 = v5;
  uint64_t v11 = v4;
  bzero(__str, 0x1001uLL);
  memset(&v77, 0, sizeof(v77));
  *(void *)&v76.tv_usec = 0LL;
  if (v8)
  {
    if (*v8 == 47 || xmlNanoFTPCwd((void *)v11, *(const char **)(v11 + 24)) >= 1)
    {
      int v12 = xmlNanoFTPGetConnection((void *)v11);
      *(_DWORD *)(v11 + 184) = v12;
      if (v12 != -1)
      {
        snprintf(__str, 0x1001uLL, "LIST -L %s\r\n", v8);
        goto LABEL_10;
      }
    }

    return -1;
  }

  int v13 = xmlNanoFTPGetConnection((void *)v11);
  *(_DWORD *)(v11 + 184) = v13;
  if (v13 == -1) {
    return -1;
  }
  strcpy(__str, "LIST -L\r\n");
LABEL_10:
  __str[4096] = 0;
  int v14 = strlen(__str);
  int v15 = send(*(_DWORD *)(v11 + 180), __str, v14, 0);
  if (v15 < 0)
  {
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    close(*(_DWORD *)(v11 + 184));
    goto LABEL_156;
  }

  int v16 = xmlNanoFTPReadResponse((int *)v11);
  if (v16 != 1)
  {
    int v73 = v16;
    close(*(_DWORD *)(v11 + 184));
    *(_DWORD *)(v11 + 184) = -1;
    return -v73;
  }

  uint64_t v74 = v9;
  int v75 = v10;
  int v17 = 0;
  do
  {
    v76.tv_sec = 1LL;
    v76.tv_usec = 0;
    memset(&v78, 0, sizeof(v78));
    int v18 = *(_DWORD *)(v11 + 184);
    if (__darwin_check_fd_set_overflow(v18, &v78, 0)) {
      *(__int32_t *)((char *)v78.fds_bits + (((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v18;
    }
    memset(&v77, 0, sizeof(v77));
    int v19 = *(_DWORD *)(v11 + 184);
    if (__darwin_check_fd_set_overflow(v19, &v77, 0)) {
      *(__int32_t *)((char *)v77.fds_bits + (((unint64_t)v19 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v19;
    }
    int v20 = select(*(_DWORD *)(v11 + 184) + 1, &v78, 0LL, &v77, &v76);
    if (v20 < 0) {
      goto LABEL_159;
    }
    if (!v20)
    {
      int v71 = xmlNanoFTPCheckResponse((void *)v11);
      if (v71 < 0)
      {
LABEL_159:
        close(*(_DWORD *)(v11 + 184));
        int v15 = -1;
        *(_DWORD *)(v11 + 184) = -1;
        return v15;
      }

      if (v71 != 2) {
        continue;
      }
      close(*(_DWORD *)(v11 + 184));
      int v15 = 0;
LABEL_156:
      *(_DWORD *)(v11 + 184) = -1;
      return v15;
    }

    int v21 = recv(*(_DWORD *)(v11 + 184), &__str[v17], 4097LL - (v17 + 1), 0);
    int v14 = v21;
    if (v21 < 0)
    {
      __xmlIOErr(9, 0, (uint64_t)"recv");
      goto LABEL_159;
    }

    int v22 = 0;
    uint64_t v23 = v17 + (uint64_t)v21;
    __str[v23] = 0;
    while (1)
    {
      uint64_t v24 = &__str[v22];
      memset(v84, 0, sizeof(v84));
      memset(v83, 0, 11);
      memset(v82, 0, 11);
      memset(v81, 0, 11);
      int v79 = 0;
      if (strncmp(v24, "total", 5uLL)) {
        break;
      }
      uint64_t v26 = &__str[v22 + 4];
      do
      {
        unsigned int v31 = *++v26;
        unsigned int v30 = v31;
      }

      while (v31 == 32);
      if (v30 - 48 <= 9)
      {
        do
        {
          unsigned int v32 = *++v26;
          unsigned int v30 = v32;
        }

        while (v32 - 48 < 0xA);
      }

      while (v30 <= 0x20 && ((1LL << v30) & 0x100002400LL) != 0)
      {
        unsigned int v33 = *++v26;
        unsigned int v30 = v33;
      }

LABEL_147:
      v22 += (_DWORD)v26 - (_DWORD)v24;
    }

    int v25 = *(unsigned __int8 *)v24;
    if (v25 == 43) {
      goto LABEL_148;
    }
    uint64_t v26 = &__str[v22];
    while (v25 > 12)
    {
      if (v25 != 13 && v25 != 32) {
        goto LABEL_31;
      }
LABEL_29:
      int v27 = *++v26;
      int v25 = v27;
    }

    if (v25 == 10) {
      goto LABEL_29;
    }
    if (!v25) {
      goto LABEL_148;
    }
LABEL_31:
    int v28 = 0;
    while (v25 != 32)
    {
      if (v28 <= 9) {
        v83[v28++] = v25;
      }
      int v29 = *++v26;
      int v25 = v29;
      if (!v29) {
        goto LABEL_148;
      }
    }

    v83[10] = 0;
    while (v25 == 32)
    {
      int v34 = *++v26;
      int v25 = v34;
    }

    if (v25)
    {
      if ((v25 - 48) > 9)
      {
        uint64_t v35 = 0LL;
      }

      else
      {
        LODWORD(v35) = 0;
        int v36 = v25;
        do
        {
          int v37 = *++v26;
          int v25 = v37;
          uint64_t v35 = (v36 + 10 * v35 - 48);
          int v36 = v37;
        }

        while ((v37 - 48) < 0xA);
      }

      while (v25 == 32)
      {
        int v38 = *++v26;
        int v25 = v38;
      }

      if (v25)
      {
        int v39 = 0;
        while (v25 != 32)
        {
          if (v39 <= 9) {
            v82[v39++] = v25;
          }
          int v40 = *++v26;
          int v25 = v40;
          if (!v40) {
            goto LABEL_148;
          }
        }

        v82[v39] = 0;
        while (1)
        {
          int v41 = *v26;
          if (v41 != 32) {
            break;
          }
          ++v26;
        }

        if (*v26)
        {
          int v42 = 0;
          while (v41 != 32)
          {
            if (v42 <= 9) {
              v81[v42++] = v41;
            }
            int v43 = *++v26;
            int v41 = v43;
            if (!v43) {
              goto LABEL_148;
            }
          }

          v81[v42] = 0;
          while (1)
          {
            int v44 = *v26;
            if (v44 != 32) {
              break;
            }
            ++v26;
          }

          if (*v26)
          {
            if ((v44 - 48) > 9)
            {
              uint64_t v45 = 0LL;
            }

            else
            {
              uint64_t v45 = 0LL;
              int v46 = *v26;
              do
              {
                int v47 = *++v26;
                int v44 = v47;
                uint64_t v45 = (v46 - 48) + 10 * v45;
                int v46 = v47;
              }

              while ((v47 - 48) < 0xA);
            }

            while (v44 == 32)
            {
              int v48 = *++v26;
              int v44 = v48;
            }

            if (v44)
            {
              int v49 = 0;
              while (v44 != 32)
              {
                if (v49 <= 2) {
                  __str[v49++ - 4] = v44;
                }
                int v50 = *++v26;
                int v44 = v50;
                if (!v50) {
                  goto LABEL_148;
                }
              }

              __str[v49 - 4] = 0;
              while (1)
              {
                int v51 = *v26;
                if (v51 != 32) {
                  break;
                }
                ++v26;
              }

              if (*v26)
              {
                if ((v51 - 48) > 9)
                {
                  int v52 = 0;
                }

                else
                {
                  int v52 = 0;
                  int v53 = *v26;
                  do
                  {
                    int v54 = *++v26;
                    int v51 = v54;
                    int v52 = v53 + 10 * v52 - 48;
                    int v53 = v54;
                  }

                  while ((v54 - 48) < 0xA);
                }

                while (v51 == 32)
                {
                  int v55 = *++v26;
                  int v51 = v55;
                }

                if (v51 && v26[1] && v26[2])
                {
                  unsigned int v56 = v51 - 48;
                  if (v26[1] == 58 || v26[2] == 58)
                  {
                    if (v56 > 9)
                    {
                      int v59 = 0;
                    }

                    else
                    {
                      int v59 = 0;
                      int v60 = v51;
                      do
                      {
                        int v61 = *++v26;
                        int v51 = v61;
                        int v59 = v60 + 10 * v59 - 48;
                        int v60 = v61;
                      }

                      while ((v61 - 48) < 0xA);
                    }

                    if (v51 == 58) {
                      ++v26;
                    }
                    int v51 = *v26;
                    if ((v51 - 48) > 9)
                    {
                      uint64_t v57 = 0LL;
                      int v62 = 0;
                    }

                    else
                    {
                      int v62 = 0;
                      do
                      {
                        int v63 = *++v26;
                        int v62 = v51 + 10 * v62 - 48;
                        int v51 = v63;
                      }

                      while ((v63 - 48) < 0xA);
                      uint64_t v57 = 0LL;
                    }
                  }

                  else
                  {
                    if (v56 > 9)
                    {
                      uint64_t v57 = 0LL;
                    }

                    else
                    {
                      LODWORD(v57) = 0;
                      do
                      {
                        int v58 = *++v26;
                        uint64_t v57 = (v51 + 10 * v57 - 48);
                        int v51 = v58;
                      }

                      while ((v58 - 48) < 0xA);
                    }

                    int v62 = 0;
                    int v59 = 0;
                  }

                  while (v51 == 32)
                  {
                    int v64 = *++v26;
                    int v51 = v64;
                  }

                  if (v51)
                  {
                    int v65 = 0;
                    while (v51 != 10 && v51 != 13)
                    {
                      if (v65 <= 149) {
                        v84[v65++] = v51;
                      }
                      int v66 = *++v26;
                      int v51 = v66;
                      if (!v66) {
                        goto LABEL_148;
                      }
                    }

                    v84[v65] = 0;
                    int v67 = *v26;
                    if (v67 == 13 || v67 == 10)
                    {
                      while (v67 == 13 || v67 == 10)
                      {
                        char v70 = *++v26;
                        LOBYTE(v67) = v70;
                      }

                      if (v75) {
                        v75(v74, v84, v83, v82, v81, v45, v35, v57, &v79, __PAIR64__(v59, v52), v62);
                      }
                      goto LABEL_147;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

LABEL_148:
    int v17 = v23 - v22;
    __memmove_chk();
  }

  while (v14);
  xmlNanoFTPCloseConnection((void *)v11);
  return 0;
}

        cura = xmlReadFile((const char *)doc, 0LL, 0);
        if (!cura)
        {
          __int128 v84 = a1;
          uint64_t v85 = v6;
          __int128 v86 = 1065;
          __int128 v87 = "xmlRelaxNG: could not load %s\n";
          goto LABEL_220;
        }

        timeval v76 = xmlMalloc(0x28uLL);
        fd_set v77 = v76;
        if (!v76)
        {
          xmlRngPErrMemory(a1, (const xmlChar *)"allocating include\n");
          xmlFreeDoc(cura);
          goto LABEL_221;
        }

        v76[4] = 0LL;
        *(_OWORD *)timeval v76 = 0u;
        *((_OWORD *)v76 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
        v76[2] = cura;
        fd_set v78 = xmlStrdup((const xmlChar *)doc);
        xmlChar *v77 = *(void *)(a1 + 120);
        v77[1] = v78;
        __int128 v140 = v77;
        *(void *)(a1 + 120) = v77;
        if (v45)
        {
          xmlNodePtr RootElement = xmlDocGetRootElement(cura);
          if (RootElement)
          {
            int v80 = (xmlNode *)RootElement;
            if (!xmlHasProp(RootElement, (const xmlChar *)"ns")) {
              xmlSetProp(v80, (const xmlChar *)"ns", v45);
            }
          }
        }

        unsigned int v81 = *(void **)(a1 + 216);
        if (v81
          || (*(void *)(a1 + 208) = 0x400000000LL, unsigned int v81 = xmlMalloc(0x20uLL), (*(void *)(a1 + 216) = v81) != 0LL))
        {
          __int128 v82 = *(_DWORD *)(a1 + 208);
          xmlGenericErrorFunc v83 = *(int *)(a1 + 212);
          *(_DWORD *)(a1 + 212) = 2 * v83;
          unsigned int v81 = xmlRealloc(v81, 16 * v83);
          *(void *)(a1 + 216) = v81;
          if (v81)
          {
            __int128 v82 = *(_DWORD *)(a1 + 208);
LABEL_175:
            *((void *)v81 + v82) = v140;
            *(void *)(a1 + 200) = v140;
            *(_DWORD *)(a1 + 208) = v82 + 1;
            goto LABEL_176;
          }
        }

        xmlRngPErrMemory(a1, (const xmlChar *)"allocating include\n");
LABEL_176:
        uint64_t v94 = (const xmlDoc *)xmlRelaxNGCleanupDoc(a1, cura);
        if (!v94)
        {
          fd_set v77 = 0LL;
          *(void *)(a1 + 200) = 0LL;
          goto LABEL_221;
        }

        int v95 = *(_DWORD *)(a1 + 208);
        __int16 v96 = v95 - 1;
        if (v95 >= 1)
        {
          *(_DWORD *)(a1 + 208) = v96;
          __int128 v97 = *(void *)(a1 + 216);
          if (v95 == 1) {
            __int128 v98 = 0LL;
          }
          else {
            __int128 v98 = *(void *)(v97 + 8LL * (v95 - 2));
          }
          *(void *)(a1 + 200) = v98;
          *(void *)(v97 + 8LL * v96) = 0LL;
        }

        uint64_t v99 = xmlDocGetRootElement(v94);
        if (v99)
        {
          if (v99->ns)
          {
            if (v99->type == XML_ELEMENT_NODE)
            {
              curb = (xmlDocPtr)v99;
              if (xmlStrEqual(v99->name, (const xmlChar *)"grammar"))
              {
                if (xmlStrEqual( *(const xmlChar **)(*(void *)&curb->compression + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                {
                  xmlNodePtr children = *(_xmlNode **)(v6 + 24);
                  if (children)
                  {
                    while (1)
                    {
                      v101 = children;
                      if (!children->ns) {
                        goto LABEL_215;
                      }
                      xmlNodePtr node = children;
                      if (children->type != XML_ELEMENT_NODE) {
                        goto LABEL_210;
                      }
                      xmlGenericErrorFunc v102 = xmlStrEqual(children->name, (const xmlChar *)"start");
                      v101 = node;
                      ns = node->ns;
                      if (!v102) {
                        goto LABEL_200;
                      }
                      v104 = xmlRelaxNGRemoveRedefine((uint64_t)curb->children, 0LL);
                      v101 = node;
                      if (v104) {
                        goto LABEL_210;
                      }
                      xmlRngPErr( a1,  v6,  1107,  "xmlRelaxNG: include %s has a start but not the included grammar\n",  v46,  0LL);
LABEL_209:
                      v101 = node;
LABEL_210:
                      if (v101->ns)
                      {
                        if (v101->type == XML_ELEMENT_NODE)
                        {
                          xmlGenericErrorFunc v109 = xmlStrEqual(v101->name, (const xmlChar *)"div");
                          v101 = node;
                          if (v109)
                          {
                            v110 = xmlStrEqual(node->ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                            v101 = node;
                            if (v110)
                            {
                              xmlNodePtr children = node->children;
                              if (children) {
                                continue;
                              }
                            }
                          }
                        }
                      }

          if (*(_DWORD *)(a1 + 32) == 3069) {
            goto LABEL_159;
          }
LABEL_149:
          if (++v28 != v27) {
            continue;
          }
          xmlXPathObjectPtr v106 = (_DWORD *)(a1 + 36);
          if (*v147) {
            goto LABEL_183;
          }
          xmlGenericErrorFunc v111 = v27;
          v112 = v29;
          break;
      }

      break;
    }

    while (1)
    {
      v113 = (_DWORD *)*v112;
      xmlGenericErrorFunc v114 = *(_DWORD *)*v112;
      if ((v114 - 4) < 2)
      {
        uint64_t v24 = (_DWORD *)*((void *)v113 + 14);
        if (v24) {
          xmlSchemaCheckTypeDefCircularInternal(a1, (_DWORD *)*v112, v24);
        }
        goto LABEL_209;
      }

      if (v114 == 16) {
        break;
      }
      if (v114 == 17)
      {
        v115 = *((void *)v113 + 3);
        if (v115)
        {
          CircModelGrDefRef = (_DWORD *)xmlSchemaGetCircModelGrDefRef(*v112, *(void *)(v115 + 24));
          if (CircModelGrDefRef)
          {
            xmlNodePtr v117 = CircModelGrDefRef;
            __int128 v150 = 0LL;
            xmlGenericErrorFunc v118 = xmlSchemaGetComponentNode(CircModelGrDefRef);
            xmlSchemaFormatQName(&v150, *((const xmlChar **)v113 + 5), *((xmlChar **)v113 + 4));
            xmlSchemaPCustomErrExt( a1,  3075,  0LL,  v118,  (const xmlChar *)"Circular reference to the model group definition '%s' defined");
            if (v150) {
              xmlFree(v150);
            }
            *((void *)v117 + 3) = 0LL;
            goto LABEL_208;
          }
        }

        goto LABEL_209;
      }

  if (v4 && !v48 && *(_DWORD *)(a1 + 188)) {
    xmlSchemaPCustomErrExt( a1,  3081,  0LL,  a3,  (const xmlChar *)"This is a redefinition, thus the <complexType> must have a <restriction> or <extension> grand-child");
  }
  *(void *)(a1 + 160) = v8;
  return PropNode;
}

int xmlNanoFTPGetSocket(void *ctx, const char *filename)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!ctx || !filename && !*((void *)ctx + 3)) {
    return -1;
  }
  int result = xmlNanoFTPGetConnection(ctx);
  *((_DWORD *)ctx + 46) = result;
  if (result == -1) {
    return result;
  }
  __int128 v25 = 0u;
  memset(v26, 0, sizeof(v26));
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  strcpy(__s, "TYPE I\r\n");
  int v5 = strlen(__s);
  if ((send(*((_DWORD *)ctx + 45), __s, v5, 0) & 0x80000000) != 0) {
    goto LABEL_14;
  }
  if (xmlNanoFTPReadResponse((int *)ctx) != 2)
  {
LABEL_15:
    int result = *((_DWORD *)ctx + 46);
    goto LABEL_16;
  }

  if (filename) {
    snprintf(__s, 0x12CuLL, "RETR %s\r\n", filename);
  }
  else {
    snprintf(__s, 0x12CuLL, "RETR %s\r\n", *((const char **)ctx + 3));
  }
  v26[18] = 0;
  int v6 = strlen(__s);
  if ((send(*((_DWORD *)ctx + 45), __s, v6, 0) & 0x80000000) != 0)
  {
LABEL_14:
    __xmlIOErr(9, 0, (uint64_t)"send failed");
    goto LABEL_15;
  }

  int v7 = xmlNanoFTPReadResponse((int *)ctx);
  int result = *((_DWORD *)ctx + 46);
  if (v7 != 1)
  {
LABEL_16:
    close(result);
    int result = -1;
    *((_DWORD *)ctx + 46) = -1;
  }

  return result;
}

int xmlNanoFTPGet(void *ctx, ftpDataCallback callback, void *userData, const char *filename)
{
  uint64_t v4 = MEMORY[0x1895F8858](ctx, callback);
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!v4) {
    return -1;
  }
  uint64_t v8 = v6;
  __int128 v9 = v5;
  uint64_t v10 = v4;
  if (v7)
  {
    if (!v5) {
      return -1;
    }
  }

  else
  {
    int result = -1;
    if (!v5 || !*(void *)(v10 + 24)) {
      return result;
    }
  }

  int result = xmlNanoFTPGetSocket((void *)v10, v7);
  if (result != -1)
  {
    bzero(v18, 0x1000uLL);
    LODWORD(v12) = 0;
    *(void *)&v16.tv_usec = 0LL;
    while (1)
    {
      v16.tv_sec = 1LL;
      v16.tv_usec = 0;
      memset(&v17, 0, sizeof(v17));
      int v13 = *(_DWORD *)(v10 + 184);
      if (__darwin_check_fd_set_overflow(v13, &v17, 0)) {
        *(__int32_t *)((char *)v17.fds_bits + (((unint64_t)v13 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v13;
      }
      int v14 = select(*(_DWORD *)(v10 + 184) + 1, &v17, 0LL, 0LL, &v16);
      if (v14 < 0) {
        goto LABEL_20;
      }
      if (v14)
      {
        ssize_t v12 = recv(*(_DWORD *)(v10 + 184), v18, 0x1000uLL, 0);
        if ((v12 & 0x80000000) != 0)
        {
          __xmlIOErr(9, 0, (uint64_t)"recv failed");
          v9(v8, v18, v12);
LABEL_20:
          close(*(_DWORD *)(v10 + 184));
          int result = -1;
          *(_DWORD *)(v10 + 184) = -1;
          return result;
        }

        v9(v8, v18, v12);
      }

      else
      {
        int v15 = xmlNanoFTPCheckResponse((void *)v10);
        if (v15 < 0) {
          goto LABEL_20;
        }
        if (v15 == 2)
        {
          close(*(_DWORD *)(v10 + 184));
          int result = 0;
          *(_DWORD *)(v10 + 184) = -1;
          return result;
        }
      }

      if (!(_DWORD)v12) {
        return xmlNanoFTPCloseConnection((void *)v10);
      }
    }
  }

  return result;
}

int xmlNanoFTPRead(void *ctx, void *dest, int len)
{
  if (!ctx) {
    return -1;
  }
  int v4 = *((_DWORD *)ctx + 46);
  if (v4 == -1) {
    return 0;
  }
  if (!dest) {
    return -1;
  }
  if (len < 1) {
    return 0;
  }
  int v5 = recv(v4, dest, len, 0);
  int v6 = v5;
  if (v5 <= 0)
  {
    if (v5 < 0) {
      __xmlIOErr(9, 0, (uint64_t)"recv failed");
    }
    xmlNanoFTPCloseConnection(ctx);
  }

  return v6;
}

void *__cdecl xmlNanoFTPOpen(const char *URL)
{
  if (URL)
  {
    if (strncmp("ftp://", URL, 6uLL)) {
      return 0LL;
    }
    int v3 = (char *)xmlNanoFTPNewCtxt(URL);
    URL = v3;
    if (v3 && (xmlNanoFTPConnect(v3) < 0 || xmlNanoFTPGetSocket((void *)URL, *((const char **)URL + 3)) == -1))
    {
      xmlNanoFTPFreeCtxt((void *)URL);
      return 0LL;
    }
  }

  return (void *)URL;
}

int xmlNanoFTPClose(void *ctx)
{
  if (!ctx) {
    return -1;
  }
  int v2 = *((_DWORD *)ctx + 46);
  if (v2 != -1)
  {
    close(v2);
    *((_DWORD *)ctx + 46) = -1;
  }

  if (*((_DWORD *)ctx + 45) != -1)
  {
    xmlNanoFTPQuit(ctx);
    close(*((_DWORD *)ctx + 45));
    *((_DWORD *)ctx + 45) = -1;
  }

  xmlNanoFTPFreeCtxt(ctx);
  return 0;
}

void xmlNanoHTTPInit(void)
{
  if ((initialized_0 & 1) == 0)
  {
    if (!proxy_0)
    {
      proxyPort_0 = 80;
      xmlGenericErrorFunc v0 = getenv("no_proxy");
      if (!v0 || *v0 != 42 || v0[1])
      {
        int v1 = getenv("http_proxy");
        if (v1 || (int v1 = getenv("HTTP_PROXY")) != 0LL) {
          xmlNanoHTTPScanProxy(v1);
        }
      }
    }

    initialized_0 = 1;
  }

void xmlNanoHTTPScanProxy(const char *URL)
{
  if (proxy_0)
  {
    xmlFree((void *)proxy_0);
    proxy_0 = 0LL;
  }

  proxyPort_0 = 0;
  if (URL)
  {
    xmlURIPtr v2 = xmlParseURIRaw(URL, 1);
    if (v2)
    {
      int v3 = v2;
      scheme = v2->scheme;
      if (scheme && !strcmp(scheme, "http") && (server = v3->server) != 0LL)
      {
        proxy_0 = (uint64_t)xmlMemStrdup(server);
        if (v3->port) {
          proxyPort_0 = v3->port;
        }
      }

      else
      {
        __xmlIOErr(10, 2020, (uint64_t)"Syntax Error\n");
      }

      xmlFreeURI(v3);
    }

    else
    {
      __xmlIOErr(10, 2020, (uint64_t)"Syntax Error\n");
    }
  }

void xmlNanoHTTPCleanup(void)
{
  if (proxy_0)
  {
    xmlFree((void *)proxy_0);
    proxy_0 = 0LL;
  }

  initialized_0 = 0;
}

void *__cdecl xmlNanoHTTPOpen(const char *URL, char **contentType)
{
  if (contentType) {
    *contentType = 0LL;
  }
  return xmlNanoHTTPMethodRedir(URL, 0LL, 0LL, contentType, 0LL, 0LL, 0);
}

void *__cdecl xmlNanoHTTPMethod( const char *URL, const char *method, const char *input, char **contentType, const char *headers, int ilen)
{
  return xmlNanoHTTPMethodRedir(URL, method, input, contentType, 0LL, headers, ilen);
}

void *__cdecl xmlNanoHTTPOpenRedir(const char *URL, char **contentType, char **redir)
{
  if (contentType) {
    *contentType = 0LL;
  }
  if (redir) {
    *redir = 0LL;
  }
  return xmlNanoHTTPMethodRedir(URL, 0LL, 0LL, contentType, redir, 0LL, 0);
}

void *__cdecl xmlNanoHTTPMethodRedir( const char *URL, const char *method, const char *input, char **contentType, char **redir, const char *headers, int ilen)
{
  uint64_t v7 = MEMORY[0x1895F8858](URL, method);
  xmlGenericErrorFunc v124 = v13;
  *(void *)&v127[1] = *MEMORY[0x1895F89C0];
  v119 = (const char *)v7;
  if (!v7) {
    return 0LL;
  }
  int v14 = v12;
  uint64_t v125 = v9;
  xmlGenericErrorFunc v118 = v10;
  int v15 = "GET";
  if (v8) {
    int v15 = v8;
  }
  xmlGenericErrorFunc v122 = (char *)v15;
  __s = v11;
  xmlNanoHTTPInit();
  int v16 = 0;
  fd_set v17 = 0LL;
  __int128 v18 = &xmlMemStrdup;
  uint64_t v19 = &xmlFree;
  while (2)
  {
    __int128 v20 = xmlNanoHTTPNewCtxt(v119);
    if (!v20) {
      return v20;
    }
LABEL_8:
    if (!*(void *)v20 || strcmp(*(const char **)v20, "http"))
    {
      v113 = "Not a valid HTTP URI";
      int v114 = 2020;
LABEL_218:
      __xmlIOErr(10, v114, (uint64_t)v113);
LABEL_219:
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      if (v17) {
        ((void (*)(const char *))*v19)(v17);
      }
      return 0LL;
    }

    __int128 v21 = v18;
    __int128 v22 = (const char *)*((void *)v20 + 1);
    if (!v22)
    {
      v113 = "Failed to identify host in URI";
      int v114 = 2022;
      goto LABEL_218;
    }

    int v121 = v16;
    __int128 v23 = v17;
    __int128 v24 = v19;
    int v25 = strlen(v22);
    int v26 = v25;
    if (proxy_0)
    {
      int v26 = 2 * v25 + 16;
      unsigned int v27 = proxyPort_0;
      int v28 = (const char *)proxy_0;
    }

    else
    {
      unsigned int v27 = *((_DWORD *)v20 + 4);
      int v28 = (const char *)*((void *)v20 + 1);
    }

    int v29 = xmlNanoHTTPConnectHost(v28, v27);
    if (v29 == -1)
    {
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      if (v23) {
        ((void (*)(const char *))*v19)(v23);
      }
      return 0LL;
    }

    *((_DWORD *)v20 + 10) = v29;
    if (v125) {
      int v30 = v14;
    }
    else {
      int v30 = 0;
    }
    if (v125) {
      int v31 = v26 + 36;
    }
    else {
      int v31 = v26;
    }
    if (__s) {
      v31 += strlen(__s) + 2;
    }
    if (v124 && *v124) {
      v31 += strlen(*v124) + 16;
    }
    unsigned int v32 = (const char *)*((void *)v20 + 4);
    if (v32) {
      v31 += strlen(v32) + 1;
    }
    int v33 = strlen(v122);
    int v34 = v31 + v33 + strlen(*((const char **)v20 + 3));
    int v120 = v30;
    if (*((_DWORD *)v20 + 4) == 80)
    {
      int v35 = v34 + 47;
    }

    else
    {
      int v36 = v34 + 24;
      int v37 = v36 + 34;
      int v35 = v36 + 40;
      if (!proxy_0) {
        int v35 = v37;
      }
    }

    size_t v38 = v35;
    int v39 = (char *)xmlMallocAtomic(v35);
    if (!v39)
    {
      xmlNanoHTTPFreeCtxt((uint64_t)v20);
      __xmlSimpleError(10, 2, 0, 0LL, (uint64_t)"allocating header buffer");
      return 0LL;
    }

    int v40 = v39;
    if (proxy_0)
    {
      if (*((_DWORD *)v20 + 4) == 80) {
        int v41 = snprintf(v39, v38, "%s http://%s%s");
      }
      else {
        int v41 = snprintf(v39, v38, "%s http://%s:%d%s");
      }
    }

    else
    {
      int v41 = snprintf(v39, v38, "%s %s");
    }

    int v42 = (char *)&v40[v41];
    if (*((void *)v20 + 4)) {
      v42 += snprintf((char *)&v40[v41], v38 - v41, "?%s", *((const char **)v20 + 4));
    }
    int v43 = &v40[v38];
    size_t v44 = v43 - v42;
    if (*((_DWORD *)v20 + 4) == 80) {
      int v45 = snprintf(v42, v44, " HTTP/1.0\r\nHost: %s\r\n");
    }
    else {
      int v45 = snprintf(v42, v44, " HTTP/1.0\r\nHost: %s:%d\r\n");
    }
    int v46 = &v42[v45 + snprintf(&v42[v45], v43 - &v42[v45], "Accept-Encoding: gzip\r\n")];
    if (v124 && *v124) {
      v46 += snprintf(v46, v43 - v46, "Content-Type: %s\r\n", *v124);
    }
    if (__s) {
      v46 += snprintf(v46, v43 - v46, "%s", __s);
    }
    size_t v47 = v43 - v46;
    if (v125) {
      snprintf(v46, v47, "Content-Length: %d\r\n\r\n");
    }
    else {
      snprintf(v46, v47, "\r\n");
    }
    __int128 v18 = v21;
    *((void *)v20 + 6) = v40;
    *((void *)v20 + 7) = v40;
    *((_DWORD *)v20 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 1;
    int v48 = strlen(v40);
    xmlNanoHTTPSend((uint64_t)v20, (uint64_t)v40, v48);
    if (v125) {
      xmlNanoHTTPSend((uint64_t)v20, v125, v14);
    }
    *((_DWORD *)v20 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 2;
    uint64_t v19 = v24;
    fd_set v17 = v23;
    while (2)
    {
      int v49 = cur;
      bzero(cur, 0x1000uLL);
      while (1)
      {
        int v50 = (unsigned __int8 *)*((void *)v20 + 11);
LABEL_59:
        *((void *)v20 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v50 + 1;
        int v52 = *v50;
        *int v49 = v52;
        if (v52 != 13)
        {
          if (v52 == 10) {
            goto LABEL_65;
          }
          ++v49;
        }

        if (v49 - cur >= 4095)
        {
          int v49 = v127;
          goto LABEL_65;
        }
      }

      int v51 = xmlNanoHTTPRecv((uint64_t)v20);
      if (v51 == -1) {
        break;
      }
      if (v51)
      {
        int v50 = (unsigned __int8 *)*((void *)v20 + 11);
        goto LABEL_59;
      }

      if (v49 == cur) {
        break;
      }
LABEL_65:
      *int v49 = 0;
      int v53 = (const char *)((uint64_t (*)(char *))*v18)(cur);
      if (v53)
      {
        int v54 = v53;
        if (*v53)
        {
          if (!strncmp(v53, "HTTP/", 5uLL))
          {
            int v55 = v54 + 5;
            unsigned int v56 = *((unsigned __int8 *)v54 + 5);
            if (v56 - 48 > 9)
            {
              int v57 = 0;
            }

            else
            {
              int v57 = 0;
              do
              {
                int v57 = v56 + 10 * v57 - 48;
                unsigned int v58 = *(unsigned __int8 *)++v55;
                unsigned int v56 = v58;
              }

              while (v58 - 48 < 0xA);
            }

            if (v56 == 46)
            {
              int v76 = v55[1];
              uint64_t v74 = v55 + 1;
              int v75 = v76;
              unsigned __int8 v77 = v76 - 48;
              int v55 = v74 - 1;
              do
              {
                unsigned int v78 = *(unsigned __int8 *)++v55;
                unsigned int v56 = v78;
              }

              while (v78 - 48 < 0xA);
              int v79 = 10 * v57 + v75 - 48;
              if (v77 < 0xAu) {
                int v57 = v79;
              }
            }

            else
            {
              v57 *= 10;
            }

            if (v56 == 32 || v56 == 9)
            {
              while (v56 == 32 || v56 == 9)
              {
                unsigned int v81 = *(unsigned __int8 *)++v55;
                unsigned int v56 = v81;
              }

              if (v56 - 58 >= 0xFFFFFFF6)
              {
                int v82 = 0;
                uint64_t v83 = 1LL;
                do
                {
                  int v82 = v56 + 10 * v82 - 48;
                  unsigned int v56 = v55[v83++];
                }

                while (v56 - 48 < 0xA);
                if (v56 <= 0x20 && ((1LL << v56) & 0x100000201LL) != 0)
                {
                  *((_DWORD *)v20 + 26) = v82;
                  *((_DWORD *)v20 + 27) = v57;
                }
              }
            }

            goto LABEL_189;
          }

          if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Type:", 13))
          {
            if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"ContentType:", 12))
            {
              if (!xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Location:", 9))
              {
                for (uint64_t i = (const xmlChar *)(v54 + 9); ; ++i)
                {
                  int v90 = *i;
                  if (v90 != 32 && v90 != 9) {
                    break;
                  }
                }

                if (*((void *)v20 + 16))
                {
                  ((void (*)(void))*v19)();
                  int v90 = *i;
                }

                if (v90 == 47)
                {
                  __int128 v92 = xmlStrdup((const xmlChar *)"http://");
                  xmlXPathObjectPtr v93 = xmlStrcat(v92, *((const xmlChar **)v20 + 1));
                  uint64_t v94 = xmlStrcat(v93, i);
                }

                else
                {
                  uint64_t v94 = (xmlChar *)((uint64_t (*)(const xmlChar *))*v18)(i);
                }

                *((void *)v20 + 16) = v94;
                goto LABEL_189;
              }

              if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"WWW-Authenticate:", 17))
              {
                if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Proxy-Authenticate:", 19))
                {
                  if (xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Encoding:", 17))
                  {
                    if (!xmlStrncasecmp((const xmlChar *)v54, (const xmlChar *)"Content-Length:", 15)) {
                      *((_DWORD *)v20 + 28) = strtol(v54 + 15, 0LL, 10);
                    }
                  }

                  else
                  {
                    for (uint64_t j = (const xmlChar *)(v54 + 17); ; ++j)
                    {
                      int v110 = *j;
                      if (v110 != 32 && v110 != 9) {
                        break;
                      }
                    }

                    if (!xmlStrncasecmp(j, (const xmlChar *)"gzip", 4))
                    {
                      *((_DWORD *)v20 + 42) = 1;
                      v112 = (z_stream *)xmlMalloc(0x70uLL);
                      *((void *)v20 + 20) = v112;
                      if (v112)
                      {
                        v112->avail_in = 0;
                        v112->next_in = 0LL;
                        v112->zfree = 0LL;
                        v112->opaque = 0LL;
                        v112->zalloc = 0LL;
                        inflateInit2_(v112, 31, "1.2.12", 112);
                      }
                    }
                  }

LABEL_189:
                  ((void (*)(const char *))*v19)(v54);
                  continue;
                }

                for (uint64_t k = (unsigned __int8 *)(v54 + 19); ; ++k)
                {
                  int v107 = *k;
                  if (v107 != 32 && v107 != 9) {
                    break;
                  }
                }
              }

              else
              {
                for (uint64_t k = (unsigned __int8 *)(v54 + 17); ; ++k)
                {
                  int v96 = *k;
                  if (v96 != 32 && v96 != 9) {
                    break;
                  }
                }
              }

              if (*((void *)v20 + 17)) {
                ((void (*)(void))*v19)();
              }
              *((void *)v20 + 17) = ((uint64_t (*)(unsigned __int8 *))*v18)(k);
              goto LABEL_189;
            }

            if (*((void *)v20 + 15)) {
              goto LABEL_189;
            }
            uint64_t v85 = v54 + 12;
            for (m = (const xmlChar *)(v54 + 12); ; ++m)
            {
              int v87 = *m;
              if (v87 != 32 && v87 != 9) {
                break;
              }
              ++v85;
            }

            uint64_t v98 = ((uint64_t (*)(const xmlChar *))*v18)(m);
            uint64_t v99 = 0LL;
            *((void *)v20 + 15) = v98;
            while (1)
            {
              unsigned int v100 = m[v99];
              BOOL v65 = v100 > 0x3B;
              uint64_t v101 = (1LL << v100) & 0x800100100000201LL;
              if (!v65 && v101 != 0) {
                break;
              }
              ++v99;
            }

            if (*((void *)v20 + 19)) {
              ((void (*)(void))*v19)();
            }
            *((void *)v20 + 19) = xmlStrndup(m, v99);
            v103 = xmlStrstr(*((const xmlChar **)v20 + 15), (const xmlChar *)"charset=");
            __int128 v18 = v21;
            if (!v103) {
              goto LABEL_189;
            }
            uint64_t v69 = 0LL;
            char v70 = v103 + 8;
            while (1)
            {
              unsigned int v104 = v70[v69];
              BOOL v65 = v104 > 0x3B;
              uint64_t v105 = (1LL << v104) & 0x800100100000201LL;
              if (!v65 && v105 != 0) {
                break;
              }
              ++v69;
            }
          }

          else
          {
            int v59 = v54 + 13;
            for (n = (const xmlChar *)(v54 + 13); ; ++n)
            {
              int v61 = *n;
              if (v61 != 32 && v61 != 9) {
                break;
              }
              ++v59;
            }

            if (*((void *)v20 + 15)) {
              ((void (*)(void))*v19)();
            }
            uint64_t v63 = 0LL;
            *((void *)v20 + 15) = ((uint64_t (*)(const xmlChar *))*v21)(n);
            while (1)
            {
              unsigned int v64 = n[v63];
              BOOL v65 = v64 > 0x3B;
              uint64_t v66 = (1LL << v64) & 0x800100100000201LL;
              if (!v65 && v66 != 0) {
                break;
              }
              ++v63;
            }

            if (*((void *)v20 + 19)) {
              ((void (*)(void))*v19)();
            }
            *((void *)v20 + 19) = xmlStrndup(n, v63);
            xmlParserInputPtr v68 = xmlStrstr(*((const xmlChar **)v20 + 15), (const xmlChar *)"charset=");
            __int128 v18 = v21;
            if (!v68) {
              goto LABEL_189;
            }
            uint64_t v69 = 0LL;
            char v70 = v68 + 8;
            while (1)
            {
              unsigned int v71 = v70[v69];
              BOOL v65 = v71 > 0x3B;
              uint64_t v72 = (1LL << v71) & 0x800100100000201LL;
              if (!v65 && v72 != 0) {
                break;
              }
              ++v69;
            }
          }

          if (*((void *)v20 + 18)) {
            ((void (*)(void))*v19)();
          }
          *((void *)v20 + 18) = xmlStrndup(v70, v69);
          __int128 v18 = v21;
          goto LABEL_189;
        }

        *((void *)v20 + 9) = *((void *)v20 + 11);
        ((void (*)(const char *))*v19)(v53);
      }

      break;
    }

    if (!*((void *)v20 + 16) || (*((_DWORD *)v20 + 26) - 300) > 0x63)
    {
      v115 = v124;
      if (v124)
      {
        uint64_t v116 = *((void *)v20 + 15);
        if (v116)
        {
          uint64_t v116 = ((uint64_t (*)(void))*v18)();
          v115 = v124;
        }

        void *v115 = v116;
      }

      if (v118 && v23)
      {
        *xmlGenericErrorFunc v118 = v23;
      }

      else
      {
        if (v23) {
          ((void (*)(const char *))*v19)(v23);
        }
        if (v118) {
          *xmlGenericErrorFunc v118 = 0LL;
        }
      }

      return v20;
    }

    if (v121 == 10) {
      goto LABEL_219;
    }
    if (v23) {
      ((void (*)(const char *))*v19)(v23);
    }
    int v16 = v121 + 1;
    fd_set v17 = (const char *)((uint64_t (*)(void))*v18)(*((void *)v20 + 16));
    xmlNanoHTTPFreeCtxt((uint64_t)v20);
    int v14 = v120;
    if (!v17) {
      continue;
    }
    break;
  }

  __int128 v20 = xmlNanoHTTPNewCtxt(v17);
  if (v20)
  {
    *((void *)v20 + 16) = ((uint64_t (*)(const char *))*v18)(v17);
    goto LABEL_8;
  }

  return v20;
}

      if (++v40 == v33)
      {
        unsigned int v32 = *(_DWORD *)(v31 + 24);
        goto LABEL_234;
      }
    }
  }

  return v1;
}

int xmlNanoHTTPRead(void *ctx, void *dest, int len)
{
  int v3 = -1;
  if (!ctx || !dest) {
    return v3;
  }
  if (len < 1) {
    return 0;
  }
  if (*((_DWORD *)ctx + 42) == 1)
  {
    uint64_t v7 = (z_stream *)*((void *)ctx + 20);
    if (v7)
    {
      int v8 = 0;
      v7->next_out = (Bytef *)dest;
      v7->avail_out = len;
      int avail_in = *((_DWORD *)ctx + 20) - *((_DWORD *)ctx + 22);
      v7->int avail_in = avail_in;
      do
      {
        if (!v7->avail_out) {
          break;
        }
        if (!avail_in)
        {
          int v10 = xmlNanoHTTPRecv((uint64_t)ctx);
          uint64_t v7 = (z_stream *)*((void *)ctx + 20);
          if (v10 < 1) {
            break;
          }
        }

        uint64_t v11 = *((void *)ctx + 11);
        uInt v12 = *((_DWORD *)ctx + 20) - (v8 + v11);
        v7->int avail_in = v12;
        v7->next_in = (Bytef *)(v11 + v8);
        int v13 = inflate(v7, 0);
        uint64_t v7 = (z_stream *)*((void *)ctx + 20);
        int avail_in = v7->avail_in;
        v8 += v12 - avail_in;
      }

      while (!v13);
      *((void *)ctx + 11) += v8;
      return len - v7->avail_out;
    }

    return 0;
  }

  while (1)
  {
    int v14 = (const void *)*((void *)ctx + 11);
    uint64_t v15 = *((void *)ctx + 10) - (void)v14;
    if ((int)xmlNanoHTTPRecv((uint64_t)ctx) <= 0)
    {
      int v14 = (const void *)*((void *)ctx + 11);
      uint64_t v15 = *((void *)ctx + 10) - (void)v14;
      break;
    }
  }

  else {
    int v3 = v15;
  }
  memcpy(dest, v14, v3);
  *((void *)ctx + 11) += v3;
  return v3;
}

ssize_t xmlNanoHTTPRecv(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 44) & 2) == 0) {
    return 0LL;
  }
  pollfd v12 = 0LL;
  while (1)
  {
    int v3 = *(char **)(a1 + 64);
    if (v3)
    {
      int v4 = *(char **)(a1 + 80);
      int v5 = *(char **)(a1 + 88);
    }

    else
    {
      int v6 = (char *)xmlMallocAtomic(0xFDE8uLL);
      *(void *)(a1 + 64) = v6;
      if (!v6)
      {
        __xmlSimpleError(10, 2, 0, 0LL, (uint64_t)"allocating input");
        goto LABEL_29;
      }

      int v4 = v6;
      *(_DWORD *)(a1 + 96) = 65000;
      *(void *)(a1 + 80) = v6;
      *(void *)(a1 + 88) = v6;
      int v3 = v6;
      int v5 = v6;
      *(void *)(a1 + 72) = v6;
    }

    if (v5 > v3 + 4096)
    {
      int v7 = (_DWORD)v5 - (_DWORD)v3;
      memmove(v3, v5, (int)v4 - (int)v5);
      int v5 = (char *)(*(void *)(a1 + 88) - ((int)v5 - (int)v3));
      int v3 = *(char **)(a1 + 64);
      int v4 = (char *)(*(void *)(a1 + 80) - v7);
      *(void *)(a1 + 72) -= v7;
      *(void *)(a1 + 80) = v4;
      *(void *)(a1 + 88) = v5;
    }

    uint64_t v8 = *(int *)(a1 + 96);
    if (&v3[v8] < v4 + 4096)
    {
      uint64_t v9 = *(void *)(a1 + 72);
      *(_DWORD *)(a1 + 96) = 2 * v8;
      int v10 = (char *)xmlRealloc(v3, 2 * v8);
      *(void *)(a1 + 64) = v10;
      if (v10)
      {
        int v4 = &v10[(int)v4 - (int)v3];
        *(void *)(a1 + 72) = &v10[(int)v9 - (int)v3];
        *(void *)(a1 + 80) = v4;
        *(void *)(a1 + 88) = &v10[(int)v5 - (int)v3];
        goto LABEL_14;
      }

      __xmlSimpleError(10, 2, 0, 0LL, (uint64_t)"allocating input buffer");
      xmlFree(v3);
LABEL_29:
      ssize_t result = 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 100) = -1;
      return result;
    }

void xmlNanoHTTPClose(void *ctx)
{
  if (ctx) {
    xmlNanoHTTPFreeCtxt((uint64_t)ctx);
  }
}

void xmlNanoHTTPFreeCtxt(uint64_t a1)
{
  xmlURIPtr v2 = *(void **)(a1 + 8);
  if (v2) {
    xmlFree(v2);
  }
  if (*(void *)a1) {
    xmlFree(*(void **)a1);
  }
  int v3 = *(void **)(a1 + 24);
  if (v3) {
    xmlFree(v3);
  }
  int v4 = *(void **)(a1 + 32);
  if (v4) {
    xmlFree(v4);
  }
  int v5 = *(void **)(a1 + 48);
  if (v5) {
    xmlFree(v5);
  }
  int v6 = *(void **)(a1 + 64);
  if (v6) {
    xmlFree(v6);
  }
  int v7 = *(void **)(a1 + 120);
  if (v7) {
    xmlFree(v7);
  }
  uint64_t v8 = *(void **)(a1 + 144);
  if (v8) {
    xmlFree(v8);
  }
  uint64_t v9 = *(void **)(a1 + 152);
  if (v9) {
    xmlFree(v9);
  }
  int v10 = *(void **)(a1 + 128);
  if (v10) {
    xmlFree(v10);
  }
  int v11 = *(void **)(a1 + 136);
  if (v11) {
    xmlFree(v11);
  }
  pollfd v12 = *(z_stream **)(a1 + 160);
  if (v12)
  {
    inflateEnd(v12);
    xmlFree(*(void **)(a1 + 160));
  }

  *(_DWORD *)(a1 + 44) = 4;
  int v13 = *(_DWORD *)(a1 + 40);
  if (v13 != -1) {
    close(v13);
  }
  *(_DWORD *)(a1 + 40) = -1;
  xmlFree((void *)a1);
}

_OWORD *xmlNanoHTTPNewCtxt(const char *a1)
{
  xmlURIPtr v2 = xmlMalloc(0xB0uLL);
  int v3 = v2;
  if (v2)
  {
    v2[6] = 0u;
    v2[7] = 0u;
    _OWORD *v2 = 0u;
    v2[1] = 0u;
    v2[9] = 0u;
    v2[10] = 0u;
    v2[8] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *((_DWORD *)v2 + 4) = 80;
    *((_DWORD *)v2 + 26) = 0;
    *((_DWORD *)v2 + 10) = -1;
    *((_DWORD *)v2 + 28) = -1;
    int v4 = *(void **)v2;
    if (*(void *)v3)
    {
      xmlFree(v4);
      *(void *)int v3 = 0LL;
    }

    int v5 = (void *)*((void *)v3 + 1);
    if (v5)
    {
      xmlFree(v5);
      *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0LL;
    }

    int v6 = (void *)*((void *)v3 + 3);
    if (v6)
    {
      xmlFree(v6);
      *((void *)v3 + 3) = 0LL;
    }

    int v7 = (void *)*((void *)v3 + 4);
    if (v7)
    {
      xmlFree(v7);
      *((void *)v3 + 4) = 0LL;
    }

    xmlURIPtr v8 = xmlParseURIRaw(a1, 1);
    if (v8)
    {
      uint64_t v9 = v8;
      scheme = v8->scheme;
      if (scheme && v9->server)
      {
        *(void *)int v3 = xmlMemStrdup(scheme);
        server = v9->server;
        if (server && *server == 91 && (int v12 = strlen(v9->server), v12 >= 3) && server[v12 - 1] == 93) {
          int v13 = xmlCharStrndup(server + 1, v12 - 2);
        }
        else {
          int v13 = xmlMemStrdup(server);
        }
        *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v13;
        if (v9->path) {
          path = v9->path;
        }
        else {
          path = "/";
        }
        *((void *)v3 + 3) = xmlMemStrdup(path);
        query = v9->query;
        if (query) {
          *((void *)v3 + 4) = xmlMemStrdup(query);
        }
        int port = v9->port;
        if (port) {
          *((_DWORD *)v3 + 4) = port;
        }
      }

      xmlFreeURI(v9);
    }
  }

  else
  {
    __xmlSimpleError(10, 2, 0, 0LL, (uint64_t)"allocating context");
  }

  return v3;
}

uint64_t xmlNanoHTTPConnectHost(const char *a1, unsigned int a2)
{
  v25[2] = *MEMORY[0x1895F89C0];
  __int128 v24 = 0uLL;
  v25[0] = 0LL;
  v25[1] = 0LL;
  __int128 v22 = 0uLL;
  uint64_t v21 = 0LL;
  int v23 = 0;
  if (!have_ipv6())
  {
    v20.ai_flags = 0;
    int v5 = gethostbyname(a1);
    if (!v5)
    {
      int v4 = "Failed to resolve host";
      goto LABEL_35;
    }

    int v6 = v5;
    if (*v5->h_addr_list)
    {
      uint64_t v7 = 0LL;
      unsigned int v8 = bswap32(a2) >> 16;
      do
      {
        if (v6->h_addrtype == 2)
        {
          if (v6->h_length >= 5u) {
            goto LABEL_34;
          }
          __memcpy_chk();
          BYTE1(v25[0]) = 2;
          HIDWORD(v25[0]) = v20.ai_flags;
          uint64_t v9 = v25;
        }

        else
        {
          if (v6->h_length >= 0x11u)
          {
LABEL_34:
            int v4 = "address size mismatch\n";
LABEL_35:
            __xmlIOErr(10, 0, (uint64_t)v4);
            return 0xFFFFFFFFLL;
          }

          __memcpy_chk();
          BYTE1(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 30;
          __int128 v22 = v24;
          uint64_t v9 = &v21;
        }

        *((_WORD *)v9 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v8;
        uint64_t v10 = xmlNanoHTTPConnectAttempt((const sockaddr *)v9);
        if ((_DWORD)v10 != -1) {
          return v10;
        }
      }

      while (v6->h_addr_list[++v7]);
    }

    return 0xFFFFFFFFLL;
  }

  uint64_t v19 = 0LL;
  memset(&v20, 0, sizeof(v20));
  v20.ai_sockxmlElementType type = 1;
  if (getaddrinfo(a1, 0LL, &v20, &v19))
  {
    int v4 = "getaddrinfo failed\n";
    goto LABEL_35;
  }

  int v12 = v19;
  if (!v19) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v13 = bswap32(a2) >> 16;
  while (1)
  {
    if (v12->ai_family == 2)
    {
      if (v12->ai_addrlen >= 0x11) {
        goto LABEL_31;
      }
      int v14 = v25;
    }

    else
    {
      if (v12->ai_addrlen >= 0x1D)
      {
LABEL_31:
        __xmlIOErr(10, 0, (uint64_t)"address size mismatch\n");
        int v16 = v19;
LABEL_32:
        freeaddrinfo(v16);
        return 0xFFFFFFFFLL;
      }

      int v14 = &v21;
    }

    __memcpy_chk();
    *((_WORD *)v14 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v13;
    uint64_t v15 = xmlNanoHTTPConnectAttempt((const sockaddr *)v14);
    if ((_DWORD)v15 != -1) {
      break;
    }
LABEL_27:
    int v12 = v12->ai_next;
    if (!v12)
    {
      int v16 = v19;
      if (!v19) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_32;
    }
  }

  uint64_t v17 = v15;
  freeaddrinfo(v19);
  return v17;
}

uint64_t xmlNanoHTTPSend(uint64_t result, uint64_t a2, int a3)
{
  if (a2)
  {
    uint64_t v4 = result;
    if ((*(_DWORD *)(result + 44) & 1) != 0 && a3 >= 1)
    {
      int v7 = 0;
      pollfd v8 = 0LL;
      do
      {
        ssize_t result = send(*(_DWORD *)(v4 + 40), (const void *)(a2 + v7), a3 - v7, 0);
        if ((int)result < 1)
        {
          if ((_DWORD)result == -1 && *__error() != 35) {
            return __xmlIOErr(10, 0, (uint64_t)"send failed\n");
          }
          v8.fd = *(_DWORD *)(v4 + 40);
          v8.events = 4;
          ssize_t result = poll(&v8, 1u, 60000);
        }

        else
        {
          v7 += result;
        }
      }

      while (v7 < a3);
    }
  }

  return result;
}

int xmlNanoHTTPFetch(const char *URL, const char *filename, char **contentType)
{
  *(void *)&__nbyte[1] = 0LL;
  if (!filename) {
    return -1;
  }
  if (contentType) {
    *contentType = 0LL;
  }
  int v5 = xmlNanoHTTPMethodRedir(URL, 0LL, 0LL, contentType, 0LL, 0LL, 0);
  if (!v5) {
    return -1;
  }
  uint64_t v6 = (uint64_t)v5;
  if (!strcmp(filename, "-"))
  {
    int v7 = 0;
  }

  else
  {
    int v7 = open(filename, 513, 420LL);
    if (v7 < 0)
    {
      xmlNanoHTTPFreeCtxt(v6);
      if (contentType && *contentType)
      {
        xmlFree(*contentType);
        *contentType = 0LL;
      }

      return -1;
    }
  }

  __nbyte[0] = 0;
  xmlNanoHTTPFetchContent(v6, &__nbyte[1], __nbyte);
  if (__nbyte[0] < 1)
  {
    int v8 = 0;
  }

  else if (write(v7, *(const void **)&__nbyte[1], __nbyte[0]) == -1)
  {
    int v8 = -1;
  }

  else
  {
    int v8 = 0;
  }

  xmlNanoHTTPFreeCtxt(v6);
  close(v7);
  return v8;
}

ssize_t xmlNanoHTTPFetchContent(ssize_t result, void *a2, int *a3)
{
  uint64_t v5 = *(void *)(result + 72);
  if (v5)
  {
    uint64_t v6 = result;
    int v7 = *(_DWORD *)(result + 80) - v5;
    do
    {
      ssize_t result = xmlNanoHTTPRecv(v6);
      v7 += result;
      int v8 = *(_DWORD *)(v6 + 112);
    }

    while (v8 < 1 || v7 < v8);
    if (a2) {
      *a2 = *(void *)(v6 + 72);
    }
    if (a3) {
      *a3 = v7;
    }
  }

  else
  {
    if (a3) {
      *a3 = 0;
    }
    if (a2) {
      *a2 = 0LL;
    }
  }

  return result;
}

int xmlNanoHTTPSave(void *ctxt, const char *filename)
{
  *(void *)&__nbyte[1] = 0LL;
  int v2 = -1;
  if (ctxt && filename)
  {
    if (!strcmp(filename, "-"))
    {
      int v5 = 0;
    }

    else
    {
      int v5 = open(filename, 513, 438LL);
      if (v5 < 0)
      {
        xmlNanoHTTPFreeCtxt((uint64_t)ctxt);
        return v2;
      }
    }

    __nbyte[0] = 0;
    xmlNanoHTTPFetchContent((ssize_t)ctxt, &__nbyte[1], __nbyte);
    if (__nbyte[0] < 1)
    {
      int v2 = 0;
    }

    else if (write(v5, *(const void **)&__nbyte[1], __nbyte[0]) == -1)
    {
      int v2 = -1;
    }

    else
    {
      int v2 = 0;
    }

    xmlNanoHTTPFreeCtxt((uint64_t)ctxt);
    close(v5);
  }

  return v2;
}

int xmlNanoHTTPReturnCode(void *ctx)
{
  if (ctx) {
    return *((_DWORD *)ctx + 26);
  }
  else {
    return -1;
  }
}

const char *__cdecl xmlNanoHTTPAuthHeader(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 17);
  }
  return ctx;
}

int xmlNanoHTTPContentLength(void *ctx)
{
  if (ctx) {
    return *((_DWORD *)ctx + 28);
  }
  else {
    return -1;
  }
}

const char *__cdecl xmlNanoHTTPRedir(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 16);
  }
  return ctx;
}

const char *__cdecl xmlNanoHTTPEncoding(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 18);
  }
  return ctx;
}

const char *__cdecl xmlNanoHTTPMimeType(const char *ctx)
{
  if (ctx) {
    return (const char *)*((void *)ctx + 19);
  }
  return ctx;
}

uint64_t have_ipv6()
{
  int v0 = socket(30, 1, 0);
  if (v0 == -1) {
    return 0LL;
  }
  close(v0);
  return 1LL;
}

uint64_t xmlNanoHTTPConnectAttempt(const sockaddr *a1)
{
  int sa_family = a1->sa_family;
  if (sa_family == 30) {
    int v3 = 30;
  }
  else {
    int v3 = 2;
  }
  if (sa_family == 30) {
    socklen_t v4 = 28;
  }
  else {
    socklen_t v4 = 16;
  }
  uint64_t v5 = socket(v3, 1, 6);
  uint64_t v6 = v5;
  if ((_DWORD)v5 == -1)
  {
    __xmlIOErr(10, 0, (uint64_t)"socket failed\n");
    return v6;
  }

  int v7 = fcntl(v5, 3, 0LL);
  if (v7 == -1 || (int v13 = fcntl(v6, 4, v7 | 4u), v13 < 0))
  {
    uint64_t v9 = "error setting non-blocking IO\n";
  }

  else
  {
    pollfd v14 = 0LL;
    if (connect(v6, a1, v4) == -1 && (*__error() - 35) >= 2)
    {
      uint64_t v9 = "error connecting to HTTP server";
    }

    else
    {
      v14.fd = v6;
      v14.events = 4;
      int v8 = poll(&v14, 1u, 60000);
      if (v8 == -1)
      {
        uint64_t v9 = "Connect failed";
      }

      else if (v8)
      {
        if (v14.revents == 4)
        {
          socklen_t revents = (unsigned __int16)v14.revents;
          if ((getsockopt(v6, 0xFFFF, 4103, &v13, &revents) & 0x80000000) == 0)
          {
            if (!v13) {
              return v6;
            }
            __xmlIOErr(10, 0, (uint64_t)"Error connecting to remote host");
            close(v6);
            int v11 = v13;
            *__error() = v11;
            return 0xFFFFFFFFLL;
          }

          uint64_t v9 = "getsockopt failed\n";
        }

        else
        {
          uint64_t v9 = "select failed\n";
        }
      }

      else
      {
        uint64_t v9 = "Connect attempt timed out";
      }
    }
  }

  __xmlIOErr(10, 0, (uint64_t)v9);
  close(v6);
  return 0xFFFFFFFFLL;
}

int xmlHasFeature(xmlFeature feature)
{
  if (feature - 1 > 0x20) {
    return 0;
  }
  else {
    return dword_181A372AC[feature - 1];
  }
}

int xmlCheckLanguageID(const xmlChar *lang)
{
  if (lang)
  {
    unsigned int v1 = *lang;
    if (v1 > 0x68)
    {
      if (v1 != 120 && v1 != 105) {
        goto LABEL_12;
      }
    }

    else if (v1 != 73 && v1 != 88)
    {
LABEL_12:
      uint64_t v6 = 0LL;
      do
        int v7 = lang[v6++];
      while ((v7 & 0xFFFFFFDF) - 65 < 0x1A);
      uint64_t v8 = v6 - 1;
      if (v6 - 1 >= 4)
      {
        BOOL v5 = (unint64_t)v8 < 9 && v7 == 0;
LABEL_18:
        LODWORD(lang) = v5;
        return (int)lang;
      }

      if (v8 >= 2)
      {
        if (!v7) {
          goto LABEL_59;
        }
        if (v7 == 45)
        {
          uint64_t v9 = &lang[v6];
          int v10 = lang[v6];
          if ((v10 & 0xFFFFFFDF) - 65 <= 0x19)
          {
            do
            {
              int v12 = *++v9;
              int v10 = v12;
            }

            while ((v12 & 0xFFFFFFDF) - 65 < 0x1A);
          }

          uint64_t v13 = v9 - lang - v6;
          if (v13 == 2) {
            goto LABEL_53;
          }
          if (v13 == 4) {
            goto LABEL_33;
          }
          if (v9 - lang - 3 == v6)
          {
            if (!v10) {
              goto LABEL_59;
            }
            if (v10 == 45)
            {
              pollfd v14 = v9 + 1;
              uint64_t v15 = 0LL;
              do
                int v10 = v9[++v15];
              while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
              v9 += v15;
              if (v15 == 3) {
                goto LABEL_53;
              }
              if (v15 == 5)
              {
LABEL_33:
                if (!v10) {
                  goto LABEL_59;
                }
                if (v10 == 45)
                {
                  pollfd v14 = v9 + 1;
                  if (v9[1] - 48 < 0xA)
                  {
LABEL_36:
                    uint64_t v9 = v14;
LABEL_26:
                    int v11 = v9[3];
                    v9 += 3;
                    int v10 = v11;
LABEL_53:
                    if (v10)
                    {
                      if (v10 != 45) {
                        goto LABEL_58;
                      }
                      uint64_t v17 = 1LL;
                      do
                        int v10 = v9[v17++];
                      while ((v10 & 0xFFFFFFDF) - 65 < 0x1A);
LABEL_60:
                      if (v10) {
                        BOOL v5 = v10 == 45;
                      }
                      else {
                        BOOL v5 = 1;
                      }
                      goto LABEL_18;
                    }

int inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
{
  int result = -1;
  if (ctxt && value)
  {
    int result = ctxt->inputNr;
    uint64_t inputMax = ctxt->inputMax;
    if (result < (int)inputMax)
    {
      inputTab = ctxt->inputTab;
LABEL_7:
      inputTab[result] = value;
      ctxt->xmlParserInputPtr input = value;
      ctxt->inputNr = result + 1;
      return result;
    }

    int v7 = (xmlParserInputPtr *)xmlRealloc(ctxt->inputTab, 16 * inputMax);
    if (v7)
    {
      inputTab = v7;
      ctxt->inputTab = v7;
      ctxt->uint64_t inputMax = 2 * inputMax;
      int result = ctxt->inputNr;
      goto LABEL_7;
    }

    htmlErrMemory(ctxt, 0LL);
    return -1;
  }

  return result;
}

xmlParserInputPtr inputPop(xmlParserInputPtr ctxt)
{
  if (ctxt)
  {
    int consumed = ctxt->consumed;
    unsigned int v2 = consumed - 1;
    if (consumed < 1)
    {
      return 0LL;
    }

    else
    {
      LODWORD(ctxt->consumed) = v2;
      xmlParserInputDeallocate free = ctxt->free;
      if (consumed == 1) {
        uint64_t v4 = 0LL;
      }
      else {
        uint64_t v4 = *((void *)free + (consumed - 2));
      }
      *(void *)&ctxt->col = v4;
      ctxt = (xmlParserInputPtr)*((void *)free + v2);
      *((void *)free + v2) = 0LL;
    }
  }

  return ctxt;
}

int nodePush(xmlParserCtxtPtr ctxt, xmlNodePtr value)
{
  if (ctxt)
  {
    xmlParserCtxtPtr v3 = ctxt;
    LODWORD(ctxt) = ctxt->nodeNr;
    uint64_t nodeMax = v3->nodeMax;
    if ((int)ctxt >= (int)nodeMax)
    {
      ctxt = (xmlParserCtxtPtr)xmlRealloc(v3->nodeTab, 16 * nodeMax);
      if (!ctxt)
      {
        htmlErrMemory(v3, 0LL);
        goto LABEL_10;
      }

      v3->nodeTab = (xmlNodePtr *)ctxt;
      LODWORD(ctxt) = v3->nodeNr;
      v3->nodeMax *= 2;
    }

    if (ctxt > xmlParserMaxDepth && (v3->options & 0x80000) == 0)
    {
      xmlFatalErrMsgInt( v3,  1,  (uint64_t)"Excessive depth in document: %d use XML_PARSE_HUGE option\n",  xmlParserMaxDepth);
      xmlHaltParser(v3);
LABEL_10:
      LODWORD(ctxt) = -1;
      return (int)ctxt;
    }

    v3->nodeTab[(int)ctxt] = value;
    v3->xmlNodePtr node = value;
    v3->nodeNr = (_DWORD)ctxt + 1;
  }

  return (int)ctxt;
}

_DWORD *xmlFatalErrMsgInt(_DWORD *result, int a2, uint64_t a3, int a4)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 1, a2, 3, 0LL, 0, 0LL, 0LL, 0LL, a4, 0, a3);
  }
  uint64_t v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    int result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 3, 0LL, 0, 0LL, 0LL, 0LL, a4, 0, a3);
    v4[6] = 0;
    if (!v4[112]) {
      v4[83] = 1;
    }
  }

  return result;
}

xmlNodePtr nodePop(xmlNodePtr ctxt)
{
  if (ctxt)
  {
    int properties = (int)ctxt->properties;
    unsigned int v2 = properties - 1;
    if (properties < 1)
    {
      return 0LL;
    }

    else
    {
      LODWORD(ctxt->properties) = v2;
      nsDef = ctxt->nsDef;
      if (properties == 1) {
        uint64_t v4 = 0LL;
      }
      else {
        uint64_t v4 = (xmlChar *)*((void *)&nsDef->next + (properties - 2));
      }
      ctxt->content = v4;
      ctxt = (xmlNodePtr)*((void *)&nsDef->next + v2);
      *((void *)&nsDef->next + v2) = 0LL;
    }
  }

  return ctxt;
}

int namePush(xmlParserCtxtPtr ctxt, const xmlChar *value)
{
  if (!ctxt) {
    return -1;
  }
  int result = ctxt->nameNr;
  uint64_t nameMax = ctxt->nameMax;
  if (result < (int)nameMax)
  {
    nameTab = ctxt->nameTab;
LABEL_7:
    nameTab[result] = value;
    ctxt->name = value;
    ctxt->uint64_t nameNr = result + 1;
    return result;
  }

  int v7 = (const xmlChar **)xmlRealloc(ctxt->nameTab, 16 * nameMax);
  if (v7)
  {
    nameTab = v7;
    ctxt->nameTab = v7;
    ctxt->nameMax *= 2;
    int result = ctxt->nameNr;
    goto LABEL_7;
  }

  htmlErrMemory(ctxt, 0LL);
  return -1;
}

const xmlChar *__cdecl namePop(const xmlChar *ctxt)
{
  if (ctxt)
  {
    int v1 = *((_DWORD *)ctxt + 74);
    unsigned int v2 = v1 - 1;
    if (v1 < 1)
    {
      return 0LL;
    }

    else
    {
      *((_DWORD *)ctxt + 74) = v2;
      uint64_t v3 = *((void *)ctxt + 38);
      if (v1 == 1) {
        uint64_t v4 = 0LL;
      }
      else {
        uint64_t v4 = *(void *)(v3 + 8LL * (v1 - 2));
      }
      *((void *)ctxt + 36) = v4;
      ctxt = *(const xmlChar **)(v3 + 8LL * v2);
      *(void *)(v3 + 8LL * v2) = 0LL;
    }
  }

  return ctxt;
}

int xmlSkipBlankChars(xmlParserCtxtPtr ctxt)
{
  xmlParserInputState instate = ctxt->instate;
  if (ctxt->inputNr == 1)
  {
    if (instate == XML_PARSER_DTD)
    {
      BOOL v3 = ctxt->external == 0;
      goto LABEL_22;
    }

    goto LABEL_6;
  }

  if (instate == XML_PARSER_EOF)
  {
    unint64_t v4 = 0LL;
    goto LABEL_18;
  }

  if (instate == XML_PARSER_START)
  {
LABEL_6:
    unint64_t v4 = 0LL;
LABEL_7:
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    while (1)
    {
      int v7 = *cur;
      if (v7 == 32) {
        goto LABEL_13;
      }
      if (v7 != 10) {
        goto LABEL_13;
      }
      ++input->line;
      input->col = 1;
LABEL_14:
      int v8 = *++cur;
      ++v4;
      if (!v8)
      {
        input->cur = cur;
        xmlParserInputGrow(input, 250);
        goto LABEL_7;
      }
    }

    if (v7 != 13)
    {
      input->cur = cur;
      goto LABEL_18;
    }

void xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
  if (*ctxt->input->cur == 37)
  {
    xmlNextChar(ctxt);
    unsigned int v2 = xmlParseName(ctxt);
    if (!v2)
    {
      xmlFatalErrMsg(ctxt, 24);
      return;
    }

    BOOL v3 = (const char *)v2;
    if (*__xmlParserDebugEntities())
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      BOOL v5 = __xmlGenericErrorContext();
      v4(*v5, "PEReference: %s\n", v3);
    }

    if (*ctxt->input->cur != 59)
    {
      xmlFatalErr(ctxt, 25, 0LL);
      return;
    }

    xmlNextChar(ctxt);
    ++ctxt->nbentities;
    if (ctxt->sax && (getParameterEntitySAXFunc getParameterEntity = ctxt->sax->getParameterEntity) != 0LL) {
      uint64_t v7 = ((uint64_t (*)(void *, const char *))getParameterEntity)(ctxt->userData, v3);
    }
    else {
      uint64_t v7 = 0LL;
    }
    if (ctxt->instate != XML_PARSER_EOF)
    {
      if (!v7)
      {
        if (ctxt->standalone != 1 && (ctxt->hasExternalSubset || ctxt->hasPErefs))
        {
          if (ctxt->validate && ctxt->vctxt.error) {
            xmlValidityError((uint64_t *)ctxt, 27, (uint64_t)"PEReference: %%%s; not found\n", (uint64_t)v3, 0LL);
          }
          else {
            xmlWarningMsg((uint64_t *)ctxt, 27, (uint64_t)"PEReference: %%%s; not found\n", (uint64_t)v3);
          }
          ctxt->int valid = 0;
        }

        else
        {
          xmlFatalErrMsgStr(ctxt, 26, (uint64_t)"PEReference: %%%s; not found\n", (uint64_t)v3);
        }

        xmlParserEntityCheck((uint64_t)ctxt, 0LL, 0LL, 0LL);
        goto LABEL_48;
      }

      if ((*(_DWORD *)(v7 + 92) & 0xFFFFFFFE) != 4)
      {
        xmlWarningMsg((uint64_t *)ctxt, 27, (uint64_t)"Internal: %%%s; is not a parameter entity\n", (uint64_t)v3);
LABEL_48:
        ctxt->hasPErefs = 1;
        return;
      }

      *(_DWORD *)in = 0;
      if (!xmlParserEntityCheck((uint64_t)ctxt, 0LL, v7, 0LL)
        && (*(_DWORD *)(v7 + 92) != 5 || (ctxt->options & 0x1E) != 0 || ctxt->replaceEntities || ctxt->validate))
      {
        int v8 = xmlNewEntityInputStream(ctxt, (xmlEntityPtr)v7);
        if (xmlPushInput(ctxt, v8) < 0)
        {
          xmlFreeInputStream(v8);
          return;
        }

        if (*(_DWORD *)(v7 + 92) != 5) {
          goto LABEL_48;
        }
        if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
        if (ctxt->instate != XML_PARSER_EOF)
        {
          cur = ctxt->input->cur;
          if (ctxt->input->end - cur >= 4)
          {
            *(_DWORD *)in = *(_DWORD *)cur;
            xmlCharEncoding v10 = xmlDetectCharEncoding(in, 4);
            if (v10) {
              xmlSwitchEncoding(ctxt, v10);
            }
          }

          uint64_t v11 = ctxt->input->cur;
          if (*v11 == 60 && v11[1] == 63 && v11[2] == 120 && v11[3] == 109 && v11[4] == 108)
          {
            unsigned int v12 = v11[5];
            if (v12 <= 0x20 && ((1LL << v12) & 0x100002600LL) != 0) {
              xmlParseTextDecl(ctxt);
            }
          }

          goto LABEL_48;
        }
      }
    }
  }

xmlChar xmlPopInput(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return ctxt;
  }
  xmlParserCtxtPtr v1 = ctxt;
  if (ctxt->inputNr < 2)
  {
    LOBYTE(ctxt) = 0;
    return ctxt;
  }

  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    BOOL v3 = __xmlGenericErrorContext();
    v2(*v3, "Popping input %d\n", v1->inputNr);
  }

  int inputNr = v1->inputNr;
  unsigned int v5 = inputNr - 1;
  if (inputNr > 1)
  {
    if (v1->inSubset || v1->instate == XML_PARSER_EOF)
    {
      v1->int inputNr = v5;
      inputTab = v1->inputTab;
      goto LABEL_14;
    }

    xmlFatalErr(v1, 1, (uint64_t)"Unfinished entity outside the DTD");
    int inputNr = v1->inputNr;
  }

  unsigned int v5 = inputNr - 1;
  if (inputNr >= 1)
  {
    v1->int inputNr = v5;
    inputTab = v1->inputTab;
    if (inputNr == 1)
    {
      unsigned int v5 = 0;
      uint64_t v7 = 0LL;
LABEL_15:
      v1->xmlParserInputPtr input = v7;
      int v8 = inputTab[v5];
      inputTab[v5] = 0LL;
      goto LABEL_17;
    }

_DWORD *xmlFatalErr(_DWORD *result, int a2, uint64_t a3)
{
  BOOL v3 = result;
  if (result && result[83] && result[68] == -1) {
    return result;
  }
  if ((a2 - 1) <= 0x6D)
  {
    if (!result) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  if (result) {
LABEL_8:
  }
    result[34] = a2;
LABEL_9:
  if (a3) {
    int result = (_DWORD *)__xmlRaiseError( 0,  0,  0,  (int)result,  0,  1,  a2,  3,  0LL,  0,  a3,  0LL,  0LL,  0,  (unsigned __int128)0LL >> 96,  (uint64_t)"%s: %s\n");
  }
  else {
    int result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 3, 0LL, 0, 0LL, 0LL, 0LL, 0, 0, (uint64_t)"%s\n");
  }
  if (v3)
  {
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }

  return result;
}

int xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input)
{
  if (!input) {
    return -1;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlParserInputPtr v4 = ctxt->input;
    if (v4 && v4->filename)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      uint64_t v6 = __xmlGenericErrorContext();
      v5(*v6, "%s(%d): ", ctxt->input->filename, ctxt->input->line);
    }

    xmlGenericErrorFunc v7 = *__xmlGenericError();
    int v8 = __xmlGenericErrorContext();
    v7(*v8, "Pushing input %d : %.30s\n", ctxt->inputNr + 1, (const char *)input->cur);
  }

  int inputNr = ctxt->inputNr;
  if (inputNr >= 41 && (inputNr > 0x400 || (ctxt->options & 0x80000) == 0))
  {
    xmlFatalErr(ctxt, 89, 0LL);
    int v11 = ctxt->inputNr;
    if (v11 >= 2)
    {
      do
      {
        unsigned int v12 = v11 - 1;
        inputTab = ctxt->inputTab;
        uint64_t v14 = inputTab[v11 - 2];
        ctxt->int inputNr = v12;
        ctxt->xmlParserInputPtr input = v14;
        uint64_t v15 = inputTab[v12];
        inputTab[v12] = 0LL;
        xmlFreeInputStream(v15);
        int v11 = ctxt->inputNr;
      }

      while (v11 > 1);
    }

    return -1;
  }

  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  int v10 = inputPush(ctxt, input);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  return v10;
}

void xmlGROW(uint64_t a1)
{
  xmlGenericErrorFunc v2 = *(xmlParserInput **)(a1 + 56);
  cur = v2->cur;
  uint64_t v4 = v2->end - cur;
  uint64_t v5 = cur - v2->base;
  BOOL v6 = v4 <= 10000000 && v5 <= 10000000;
  if (v6
    || !v2->buf
    || (uint64_t (*)())v2->buf->readcallback == xmlInputReadCallbackNop
    || (*(_BYTE *)(a1 + 566) & 8) != 0)
  {
    xmlParserInputGrow(v2, 250);
    xmlGenericErrorFunc v7 = *(xmlParserInput **)(a1 + 56);
    int v8 = v7->cur;
    if (v8 <= v7->end && v8 >= v7->base)
    {
      if (v8)
      {
        if (!*v8) {
          xmlParserInputGrow(v7, 250);
        }
      }
    }

    else
    {
      xmlHaltParser((xmlParserCtxtPtr)a1);
      xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"cur index out of bound");
    }
  }

  else
  {
    xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"Huge input lookup");
    xmlHaltParser((xmlParserCtxtPtr)a1);
  }

int xmlParseCharRef(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 38 || cur[1] != 35)
  {
    xmlFatalErr(ctxt, 8, 0LL);
    int v7 = 0;
    goto LABEL_40;
  }

  uint64_t v4 = cur + 2;
  if (cur[2] == 120)
  {
    input->cur = cur + 3;
    input->col += 3;
    if (!cur[3])
    {
      xmlParserInputGrow(input, 250);
      xmlParserInputPtr input = ctxt->input;
    }

    if (!ctxt->progressive && input->end - input->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      xmlParserInputPtr input = ctxt->input;
    }

    uint64_t v5 = input->cur;
    if (*v5 != 59)
    {
      int v6 = 0;
      int v7 = 0;
      while (1)
      {
        if (v6 < 21)
        {
          int v8 = v6 + 1;
        }

        else
        {
          if (!ctxt->progressive && input->end - v5 <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (ctxt->instate == XML_PARSER_EOF) {
            return 0;
          }
          int v8 = 0;
          xmlParserInputPtr input = ctxt->input;
        }

        unsigned int v9 = *input->cur;
        if (v9 - 48 >= 0xA)
        {
          if (v9 < 0x61)
          {
            if (v9 < 0x41 || (v9 <= 0x46 ? (BOOL v12 = v8 <= 19) : (BOOL v12 = 0), !v12))
            {
LABEL_76:
              xmlParserCtxtPtr v20 = ctxt;
              int v21 = 6;
LABEL_77:
              xmlFatalErr(v20, v21, 0LL);
              int v7 = 0;
              xmlParserInputPtr input = ctxt->input;
              uint64_t v5 = input->cur;
              if (*v5 == 59) {
                goto LABEL_51;
              }
LABEL_40:
              uint64_t v14 = "xmlParseCharRef: invalid xmlChar value %d\n";
LABEL_41:
              xmlFatalErrMsgInt(ctxt, 9, (uint64_t)v14, v7);
              return 0;
            }

            int v10 = -55;
          }

          else
          {
            if (v9 > 0x66 || v8 >= 20) {
              goto LABEL_76;
            }
            int v10 = -87;
          }
        }

        else
        {
          int v10 = -48;
        }

        int v13 = v10 + 16 * v7 + v9;
        if (v13 >= 1114112) {
          int v7 = 1114112;
        }
        else {
          int v7 = v13;
        }
        xmlNextChar(ctxt);
        int v6 = v8 + 1;
        xmlParserInputPtr input = ctxt->input;
        uint64_t v5 = input->cur;
        if (*v5 == 59) {
          goto LABEL_51;
        }
      }
    }

void xmlParserHandlePEReference(xmlParserCtxtPtr ctxt)
{
  switch(ctxt->instate)
  {
    case XML_PARSER_EOF:
      int v1 = 18;
      goto LABEL_14;
    case XML_PARSER_START:
    case XML_PARSER_MISC:
    case XML_PARSER_PROLOG:
      int v1 = 19;
      goto LABEL_14;
    case XML_PARSER_PI:
    case XML_PARSER_COMMENT:
    case XML_PARSER_START_TAG:
    case XML_PARSER_CONTENT:
    case XML_PARSER_CDATA_SECTION:
    case XML_PARSER_END_TAG:
    case XML_PARSER_ENTITY_DECL:
    case XML_PARSER_ENTITY_VALUE:
    case XML_PARSER_ATTRIBUTE_VALUE:
    case XML_PARSER_SYSTEM_LITERAL:
    case XML_PARSER_IGNORE:
    case XML_PARSER_PUBLIC_LITERAL:
      return;
    case XML_PARSER_DTD:
      if (!ctxt->external && ctxt->inputNr == 1) {
        return;
      }
      unsigned int v2 = *((unsigned __int8 *)ctxt->input->cur + 1);
      BOOL v3 = v2 > 0x20;
      uint64_t v4 = (1LL << v2) & 0x100002601LL;
      if (!v3 && v4 != 0) {
        return;
      }
      goto LABEL_12;
    case XML_PARSER_EPILOG:
      int v1 = 20;
LABEL_14:
      xmlFatalErr(ctxt, v1, 0LL);
      break;
    default:
LABEL_12:
      xmlParsePEReference(ctxt);
      break;
  }

xmlChar *__cdecl xmlStringLenDecodeEntities( xmlParserCtxtPtr ctxt, const xmlChar *str, int len, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  int v7 = 0LL;
  int lena = 0;
  if (!ctxt) {
    return v7;
  }
  int v8 = str;
  if (!str || len < 0) {
    return v7;
  }
  int v10 = end3;
  int v11 = end2;
  int v12 = end;
  xmlParserCtxtPtr v14 = ctxt;
  int depth = ctxt->depth;
  if (depth >= 41 && (depth > 0x400 || (ctxt->options & 0x80000) == 0))
  {
    xmlFatalErr(ctxt, 89, 0LL);
    return 0LL;
  }

  int v16 = (xmlChar *)xmlMallocAtomic(0x12CuLL);
  if (!v16) {
    goto LABEL_252;
  }
  if (len) {
    int v17 = xmlStringCurrentChar(v14, v8, &lena);
  }
  else {
    int v17 = 0;
  }
  uint64_t v18 = 0LL;
  if (v17 == v10 || v17 == v11 || !v17 || v17 == v12)
  {
LABEL_259:
    int v7 = v16;
    goto LABEL_260;
  }

  uint64_t v18 = 0LL;
  int v96 = &v8[len];
  unint64_t v97 = 300LL;
  int v95 = what;
LABEL_17:
  if (v14->instate == XML_PARSER_EOF) {
    goto LABEL_259;
  }
  uint64_t v98 = v18;
  if (v17 == 38)
  {
    if (v8[1] == 35)
    {
      if (*v8 != 38)
      {
        xmlFatalErr(v14, 8, 0LL);
        goto LABEL_256;
      }

      xmlParserCtxtPtr v20 = v8 + 2;
      int v19 = v8[2];
      if (v19 == 59)
      {
        int v24 = 0;
        uint64_t v42 = 1LL;
      }

      else
      {
        if (v19 == 120)
        {
          int v23 = v8[3];
          __int128 v22 = v8 + 3;
          int v21 = v23;
          if (v23 == 59)
          {
            int v24 = 0;
            uint64_t v25 = 1LL;
            unint64_t v26 = v97;
            goto LABEL_98;
          }

          int v24 = 0;
          unint64_t v26 = v97;
          while (1)
          {
            if ((v21 - 48) >= 0xA)
            {
              if ((v21 - 97) >= 6)
              {
                if ((v21 - 65) >= 6)
                {
                  xmlFatalErr(v14, 6, 0LL);
                  uint64_t v25 = 0LL;
                  int v24 = 0;
LABEL_98:
                  int v31 = &v22[v25];
LABEL_99:
                  if (v24 >= 1114112)
                  {
                    __int128 v89 = "xmlParseStringCharRef: character reference out of bounds\n";
                  }

                  else
                  {
                    if (v24 <= 255)
                    {
LABEL_107:
                      v18 += xmlCopyCharMultiByte(&v16[v18], v24);
LABEL_108:
                      if (v18 + 100 > v26)
                      {
                        size_t v55 = 2 * v26 + 100;
                        if (v55 >= v26) {
                          goto LABEL_110;
                        }
LABEL_252:
                        uint64_t v74 = 0LL;
                        goto LABEL_253;
                      }

LABEL_264:
                    __int128 v89 = "xmlParseStringCharRef: invalid xmlChar value %d\n";
                  }

                  xmlFatalErrMsgInt(v14, 9, (uint64_t)v89, v24);
                  goto LABEL_256;
                }

                int v45 = -55;
              }

              else
              {
                int v45 = -87;
              }
            }

            else
            {
              int v45 = -48;
            }

            int v46 = v21 + 16 * v24 + v45;
            if (v46 >= 1114112) {
              int v24 = 1114112;
            }
            else {
              int v24 = v46;
            }
            int v47 = *++v22;
            int v21 = v47;
            if (v47 == 59)
            {
              uint64_t v25 = 1LL;
              goto LABEL_98;
            }
          }
        }

        int v24 = 0;
        do
        {
          if ((v19 - 48) > 9)
          {
            xmlFatalErr(v14, 7, 0LL);
            uint64_t v42 = 0LL;
            int v24 = 0;
            goto LABEL_60;
          }

          int v43 = v19 + 10 * v24 - 48;
          if (v43 >= 1114112) {
            int v24 = 1114112;
          }
          else {
            int v24 = v43;
          }
          int v44 = *++v20;
          int v19 = v44;
        }

        while (v44 != 59);
        uint64_t v42 = 1LL;
      }

LABEL_60:
      int v31 = &v20[v42];
      unint64_t v26 = v97;
      goto LABEL_99;
    }

    if ((what & 1) == 0)
    {
LABEL_37:
      unint64_t v26 = v97;
      if (lena == 1)
      {
        v16[v18++] = v17;
        what = v95;
      }

      else
      {
        v18 += xmlCopyCharMultiByte(&v16[v18], v17);
      }

      int v31 = &v8[lena];
      goto LABEL_108;
    }

    if (*__xmlParserDebugEntities())
    {
      xmlGenericErrorFunc v34 = *__xmlGenericError();
      int v35 = __xmlGenericErrorContext();
      v34(*v35, "String decoding Entity Reference: %.30s\n", (const char *)v8);
    }

    *(void *)uint64_t v101 = v8;
    if (*v8 == 38)
    {
      *(void *)uint64_t v101 = v8 + 1;
      int v36 = xmlParseStringName(v14, (const xmlChar **)v101);
      if (v36)
      {
        int v37 = v36;
        size_t v38 = *(const xmlChar **)v101;
        if (**(_BYTE **)v101 == 59)
        {
          int v31 = (const xmlChar *)(*(void *)v101 + 1LL);
          if ((v14->options & 0x100000) == 0)
          {
            xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(v36);
            if (PredefinedEntity)
            {
              xmlEntityPtr v40 = PredefinedEntity;
              xmlFree(v37);
              xmlParserEntityCheck((int)v14);
              xmlEntityPtr v41 = v40;
              uint64_t v18 = v98;
LABEL_199:
              v14->nbentities += v41->checked / 2;
              content = v41->content;
              if (v41->etype == XML_INTERNAL_PREDEFINED_ENTITY)
              {
                if (content)
                {
                  v18 += xmlCopyCharMultiByte(&v16[v18], *content);
                  if (v18 + 100 <= v97) {
                    goto LABEL_204;
                  }
                  size_t v55 = 2 * v97 + 100;
                  if (v55 < v97) {
                    goto LABEL_252;
                  }
LABEL_110:
                  int v7 = (xmlChar *)xmlRealloc(v16, v55);
                  unint64_t v97 = v55;
                  if (!v7) {
                    goto LABEL_252;
                  }
                  goto LABEL_205;
                }

                xmlFatalErrMsg(v14, 1);
                goto LABEL_256;
              }

              if (!content)
              {
                int v99 = v11;
                int v77 = xmlStrlen(v41->name);
                uint64_t v78 = v18;
                name = v41->name;
                uint64_t v80 = v78 + 1;
                v16[v78] = 38;
                int v81 = v77;
                if (v78 + 1 + v77 + 100 <= v97)
                {
                  int v7 = v16;
                }

                else
                {
                  size_t v82 = v77 + 2 * v97 + 100;
                  if (v82 < v97) {
                    goto LABEL_252;
                  }
                  int v7 = (xmlChar *)xmlRealloc(v16, v82);
                  unint64_t v97 = v82;
                  if (!v7) {
                    goto LABEL_252;
                  }
                }

                if (v81 < 1)
                {
                  uint64_t v85 = v80;
                  what = v95;
                }

                else
                {
                  unsigned int v83 = v81 + 1;
                  what = v95;
                  do
                  {
                    xmlChar v84 = *name++;
                    uint64_t v85 = v80 + 1;
                    v7[v80] = v84;
                    --v83;
                    ++v80;
                  }

                  while (v83 > 1);
                }

                uint64_t v18 = v85 + 1;
                v7[v85] = 59;
                int v11 = v99;
                goto LABEL_205;
              }

              ++v14->depth;
              int v72 = xmlStrlen(content);
              int v73 = xmlStringLenDecodeEntities(v14, content, v72, what, 0, 0, 0);
              --v14->depth;
              if (v73)
              {
                uint64_t v74 = v73;
                LOBYTE(v75) = *v73;
                if (*v73)
                {
                  uint64_t v76 = 0LL;
                  int v93 = v10;
                  do
                  {
                    v16[v98 + v76] = v75;
                    if (v98 + v76 + 101 <= v97)
                    {
                      int v7 = v16;
                    }

                    else
                    {
                      if (2 * v97 + 100 < v97) {
                        goto LABEL_253;
                      }
                      int v7 = (xmlChar *)xmlRealloc(v16, 2 * v97 + 100);
                      unint64_t v97 = 2 * v97 + 100;
                      int v10 = v93;
                      if (!v7) {
                        goto LABEL_253;
                      }
                    }

                    int v75 = v74[++v76];
                    int v16 = v7;
                  }

                  while (v75);
LABEL_249:
                  uint64_t v18 = v98 + v76;
LABEL_251:
                  xmlFree(v74);
                  what = v95;
                  goto LABEL_205;
                }

    ;
  }

  if (v19 == 38)
  {
    if (i[1] == 35) {
      goto LABEL_60;
    }
    goto LABEL_55;
  }

  if (*i) {
    goto LABEL_60;
  }
  ++ctxt->depth;
  int v17 = xmlStringDecodeEntities(ctxt, (const xmlChar *)v7, 2, 0, 0, 0);
  --ctxt->depth;
  if (orig)
  {
    xmlChar *orig = (xmlChar *)v7;
    return v17;
  }

              int v21 = *(_DWORD *)(v17 + 24);
              if ((v21 & 0x10000) == 0)
              {
                if ((_DWORD)v14) {
                  unsigned int v32 = 1;
                }
                if (v32 != 1)
                {
                  xmlParserCtxtPtr v14 = 0LL;
                  goto LABEL_67;
                }

                int v24 = *(_DWORD *)(v16 + 24);
                goto LABEL_65;
              }

  xmlRngPErrMemory(a2, (const xmlChar *)"in interleave computation\n");
  if ((_DWORD)v9)
  {
    int v31 = v9;
    unsigned int v32 = (void ***)v7;
    do
    {
      uint64_t v33 = *v32;
      if (*v32)
      {
        if (v33[1])
        {
          xmlFree(v33[1]);
          uint64_t v33 = *v32;
        }

        xmlFree(v33);
      }

      ++v32;
      --v31;
    }

    while (v31);
  }

  xmlFree(v7);
}

          if (v8) {
            xmlFree(v8);
          }
          if (v7) {
            xmlFree(v7);
          }
          return 0;
        }
      }

          int v36 = v10;
          xmlParserCtxtPtr v20 = *v10;
          if (v20 == 63)
          {
            int v36 = v10 + 1;
            int v10 = v36;
            xmlParserCtxtPtr v20 = *v36;
          }

          if (v20 == 35)
          {
            int v36 = v10 + 1;
            xmlParserCtxtPtr v20 = *v36;
          }

          if (!v20) {
            return 0LL;
          }
          xmlCleanURI(a1);
LABEL_68:
          xmlCleanURI(a1);
          int v37 = a2;
          int v21 = *a2;
          if (v21 == 47)
          {
            if (a2[1] == 47)
            {
              int v37 = a2 + 2;
              int v8 = xmlParse3986Authority(a1, (const xmlChar **)&v37);
              if ((_DWORD)v8)
              {
LABEL_119:
                xmlCleanURI(a1);
                return v8;
              }

              if (!xmlParse3986PathAbEmpty(a1, (const xmlChar **)&v37))
              {
LABEL_109:
                uint64_t v33 = v37;
                xmlGenericErrorFunc v34 = *v37;
                if (v34 == 63)
                {
                  ++v37;
                  if (xmlParse3986Query(a1, (const xmlChar **)&v37))
                  {
LABEL_114:
                    int v8 = 0xFFFFFFFFLL;
                    goto LABEL_119;
                  }

                  uint64_t v33 = v37;
                  xmlGenericErrorFunc v34 = *v37;
                }

                if (v34 == 35)
                {
                  int v37 = v33 + 1;
                  xmlGenericErrorFunc v34 = *v37;
                }

                if (v34)
                {
                  xmlCleanURI(a1);
                  goto LABEL_118;
                }

                return 0LL;
              }
            }

            else if (!xmlParse3986PathAbsolute(a1, &v37))
            {
              goto LABEL_109;
            }

  if (!v41)
  {
    if ((*(_BYTE *)(a3 + 91) & 8) == 0) {
      goto LABEL_151;
    }
    int v48 = xmlSchemaValidateFacets( (_DWORD *)a1,  (uint64_t)a2,  (int *)a3,  (xmlSchemaValType)v28->builtInType,  v15,  val,  0LL,  a6);
    if (!v48) {
      goto LABEL_151;
    }
    if ((v48 & 0x80000000) == 0)
    {
      if ((*(_BYTE *)(a3 + 88) & 0x40) != 0) {
        uint64_t v42 = 1825LL;
      }
      else {
        uint64_t v42 = 1824LL;
      }
      goto LABEL_152;
    }

    uint64_t v33 = "validating facets of atomic simple type";
LABEL_75:
    int v49 = (_DWORD *)a1;
LABEL_76:
    xmlSchemaInternalErr2(v49, (const xmlChar *)"xmlSchemaVCheckCVCSimpleType", (const xmlChar *)v33, 0LL);
    if (!v21) {
      goto LABEL_78;
    }
LABEL_77:
    xmlFree(v21);
LABEL_78:
    if (val) {
      xmlSchemaFreeValue(val);
    }
    return 0xFFFFFFFFLL;
  }

  if (v41 < 0)
  {
    uint64_t v33 = "validating against a built-in type";
    goto LABEL_75;
  }

  if ((*(_BYTE *)(a3 + 88) & 0x40) != 0) {
    uint64_t v42 = 1825LL;
  }
  else {
    uint64_t v42 = 1824LL;
  }
  if (a6)
  {
    int v43 = (_DWORD *)a1;
    int v44 = v42;
LABEL_67:
    int v45 = (uint64_t)a2;
    int v46 = v15;
    int v47 = a3;
    goto LABEL_120;
  }

LABEL_250:
                int v7 = v16;
                goto LABEL_251;
              }

              int v90 = v41->content;
LABEL_271:
              xmlChar *v90 = 0;
              goto LABEL_256;
            }
          }

          ++v14->nbentities;
          uint64_t v18 = v98;
          if (!v14->sax) {
            goto LABEL_92;
          }
          getxmlEntityPtr Entity = (uint64_t (*)(void *, xmlChar *))v14->sax->getEntity;
          if (getEntity)
          {
            xmlEntityPtr Entity = (xmlEntityPtr)getEntity(v14->userData, v37);
            if (Entity) {
              goto LABEL_93;
            }
          }

          if ((v14->options & 0x100000) != 0)
          {
            xmlEntityPtr Entity = xmlGetPredefinedEntity(v37);
            if (Entity) {
              goto LABEL_93;
            }
          }

          if (v14->userData == v14) {
            xmlEntityPtr Entity = xmlSAX2GetEntity(v14, v37);
          }
          else {
LABEL_92:
          }
            xmlEntityPtr Entity = 0LL;
LABEL_93:
          xmlParserInputState instate = v14->instate;
          if (instate != XML_PARSER_EOF)
          {
            xmlEntityPtr v41 = Entity;
            if (!Entity)
            {
              if (v14->standalone != 1 && (v14->hasExternalSubset || v14->hasPErefs)) {
                xmlErrMsgStr(v14, 27, (uint64_t)"Entity '%s' not defined\n", (uint64_t)v37);
              }
              else {
                xmlFatalErrMsgStr(v14, 26, (uint64_t)"Entity '%s' not defined\n", (uint64_t)v37);
              }
              xmlParserEntityCheck((int)v14);
LABEL_198:
              xmlFree(v37);
              xmlParserEntityCheck((int)v14);
              if (!v41) {
                goto LABEL_204;
              }
              goto LABEL_199;
            }

            exmlElementType type = Entity->etype;
            if (etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY)
            {
              int v52 = v14;
              int v53 = 28;
              int v54 = "Entity reference to unparsed entity %s\n";
            }

            else
            {
              if (instate != XML_PARSER_ATTRIBUTE_VALUE || etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)
              {
                if (instate == XML_PARSER_ATTRIBUTE_VALUE && etype != XML_INTERNAL_PREDEFINED_ENTITY)
                {
                  int v62 = Entity->content;
                  if (v62)
                  {
                    if (xmlStrchr(v62, 0x3Cu))
                    {
                      int v52 = v14;
                      int v53 = 38;
                      int v54 = "'<' in entity '%s' is not allowed in attributes values\n";
                      goto LABEL_197;
                    }

                    exmlElementType type = v41->etype;
                  }
                }

                if ((etype & 0xFFFFFFFE) != 4) {
                  goto LABEL_198;
                }
                int v52 = v14;
                int v53 = 30;
                int v54 = "Attempt to reference the parameter entity '%s'\n";
                goto LABEL_197;
              }

              int v52 = v14;
              int v53 = 29;
              int v54 = "Attribute references external entity '%s'\n";
            }

LABEL_197:
            xmlFatalErrMsgStr(v52, v53, (uint64_t)v54, (uint64_t)v37);
            goto LABEL_198;
          }

          xmlFree(v37);
LABEL_78:
          xmlParserEntityCheck((int)v14);
          int v31 = v8;
          goto LABEL_204;
        }

        xmlFatalErr(v14, 23, 0LL);
        xmlFree(v37);
        int v8 = v38;
      }

      else
      {
        xmlFatalErrMsg(v14, 68);
        int v8 = *(const xmlChar **)v101;
      }
    }

    uint64_t v18 = v98;
    goto LABEL_78;
  }

  if ((what & 2) == 0 || v17 != 37) {
    goto LABEL_37;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v27 = *__xmlGenericError();
    int v28 = __xmlGenericErrorContext();
    v27(*v28, "String decoding PE Reference: %.30s\n", (const char *)v8);
  }

  if (!v8)
  {
    int v31 = 0LL;
    uint64_t v18 = v98;
LABEL_85:
    xmlParserEntityCheck((int)v14);
    goto LABEL_204;
  }

  *(void *)uint64_t v101 = v8;
  uint64_t v18 = v98;
  if (*v8 != 37)
  {
    int v31 = v8;
    goto LABEL_85;
  }

  *(void *)uint64_t v101 = v8 + 1;
  int v29 = xmlParseStringName(v14, (const xmlChar **)v101);
  if (!v29)
  {
    xmlFatalErrMsg(v14, 68);
    int v31 = *(const xmlChar **)v101;
    goto LABEL_85;
  }

  int v30 = v29;
  int v31 = *(const xmlChar **)v101;
  if (**(_BYTE **)v101 != 59)
  {
    xmlFatalErr(v14, 23, 0LL);
LABEL_84:
    xmlFree(v30);
    goto LABEL_85;
  }

  ++v14->nbentities;
  else {
    uint64_t v33 = 0LL;
  }
  ++v31;
  if (v14->instate == XML_PARSER_EOF) {
    goto LABEL_84;
  }
  if (v33)
  {
    if ((*(_DWORD *)(v33 + 92) & 0xFFFFFFFE) != 4) {
      xmlWarningMsg((uint64_t *)v14, 27, (uint64_t)"%%%s; is not a parameter entity\n", (uint64_t)v30);
    }
  }

  else
  {
    if (v14->standalone != 1 && (v14->hasExternalSubset || v14->hasPErefs))
    {
      xmlWarningMsg((uint64_t *)v14, 27, (uint64_t)"PEReference: %%%s; not found\n", (uint64_t)v30);
      v14->int valid = 0;
    }

    else
    {
      xmlFatalErrMsgStr(v14, 26, (uint64_t)"PEReference: %%%s; not found\n", (uint64_t)v30);
    }

    xmlParserEntityCheck((int)v14);
  }

  v14->hasPErefs = 1;
  xmlFree(v30);
  xmlParserEntityCheck((int)v14);
  if (!v33) {
    goto LABEL_204;
  }
  v14->nbentities += *(_DWORD *)(v33 + 132) / 2;
  if (*(void *)(v33 + 80)) {
    goto LABEL_239;
  }
  if ((v14->options & 0x12) != 0 || v14->validate)
  {
    int v56 = *(_DWORD *)(v33 + 92);
    if (v56 == 2 || v56 == 5)
    {
      v101[0] = 0;
      if (*__xmlParserDebugEntities())
      {
        xmlGenericErrorFunc v57 = *__xmlGenericError();
        unsigned int v58 = __xmlGenericErrorContext();
        v57(*v58, "Reading %s entity content input\n", *(const char **)(v33 + 16));
        uint64_t v18 = v98;
      }

      uint64_t buf = xmlBufferCreate();
      if (buf)
      {
        int v59 = xmlNewEntityInputStream(v14, (xmlEntityPtr)v33);
        if (v59)
        {
          int v60 = v59;
          if ((xmlPushInput(v14, v59) & 0x80000000) == 0)
          {
            if (!v14->progressive && v14->input->end - v14->input->cur <= 249) {
              xmlGROW((uint64_t)v14);
            }
            uint64_t v91 = v33;
            int v61 = xmlCurrentChar(v14, v101);
            if (v14->input == v60)
            {
              int v64 = 0;
              while (1)
              {
                cur = v60->cur;
                if (cur >= v60->end) {
                  break;
                }
                if (v61 > 255)
                {
                  if (v61 >> 11 >= 0x1B)
                  {
                    unsigned int v66 = v61 - 57344;
                    if ((v61 - 57344) >> 1 >= 0xFFF)
                    {
                      unsigned int v67 = v61 - 0x10000;
                    }
                  }
                }

                else if ((v61 > 0xD || ((1 << v61) & 0x2600) == 0) && v61 <= 31)
                {
                  goto LABEL_138;
                }

                xmlBufferAdd(buf, cur, v101[0]);
                if (v64 < 101)
                {
                  ++v64;
                }

                else
                {
                  if (!v14->progressive && v14->input->end - v14->input->cur <= 249) {
                    xmlGROW((uint64_t)v14);
                  }
                  if (v14->instate == XML_PARSER_EOF) {
                    goto LABEL_193;
                  }
                  int v64 = 0;
                }

                xmlParserInputPtr input = v14->input;
                uint64_t v69 = input->cur;
                char v70 = &v69[v101[0]];
                if (v70 <= input->end)
                {
                  if (*v69 == 10)
                  {
                    ++input->line;
                    input->col = 1;
                  }

                  else
                  {
                    ++input->col;
                  }

                  input->cur = v70;
                }

                int v61 = xmlCurrentChar(v14, v101);
                if (!v61)
                {
                  if (!v14->progressive && v14->input->end - v14->input->cur <= 249) {
                    xmlGROW((uint64_t)v14);
                  }
                  if (v14->instate == XML_PARSER_EOF) {
                    goto LABEL_193;
                  }
                  int v61 = xmlCurrentChar(v14, v101);
                  int v64 = 0;
                }

                if (v14->input != v60) {
                  goto LABEL_136;
                }
              }

              xmlPopInput(v14);
            }

            else
            {
LABEL_136:
              if (v61 >= 256)
              {
                unsigned int v66 = v61 - 57344;
                unsigned int v67 = v61 - 0x10000;
LABEL_189:
                if (v67 >= 0x100000 && v66 >> 1 >= 0xFFF && v61 >> 11 >= 0x1B)
                {
LABEL_192:
                  xmlFatalErrMsgInt(v14, 9, (uint64_t)"xmlLoadEntityContent: invalid char value %d\n", v61);
LABEL_193:
                  xmlBufferFree(buf);
                  uint64_t v33 = v91;
                  goto LABEL_239;
                }
              }

              else if (v61 <= 31)
              {
LABEL_138:
              }
            }

            uint64_t v33 = v91;
            uint64_t v63 = buf;
            *(void *)(v91 + 80) = buf->content;
            buf->content = 0LL;
            goto LABEL_238;
          }
        }

        else
        {
          xmlFatalErr(v14, 1, (uint64_t)"xmlLoadEntityContent input error");
        }

        uint64_t v63 = buf;
LABEL_238:
        xmlBufferFree(v63);
        goto LABEL_239;
      }
    }

    xmlFatalErr(v14, 1, (uint64_t)"xmlLoadEntityContent parameter error");
  }

  else
  {
    xmlWarningMsg( (uint64_t *)v14,  104,  (uint64_t)"not validating will not read content for PE entity %s\n",  *(void *)(v33 + 16));
  }

          if (*(void *)(a1 + 480))
          {
            uint64_t v98 = *(_DWORD *)(a1 + 508);
            while (1)
            {
              uint64_t v94 = __OFSUB__(v98, 2);
              v98 -= 2;
              if (v98 < 0 != v94) {
                break;
              }
              int v99 = *(void *)(a1 + 520);
              if (!*(void *)(v99 + 8LL * v98))
              {
                unsigned int v100 = *(const xmlChar **)(v99 + 8LL * (v98 + 1));
                if (*v100) {
                  goto LABEL_210;
                }
                break;
              }
            }

            unsigned int v100 = 0LL;
          }

          else
          {
            unsigned int v100 = *v135;
          }

LABEL_239:
  ++v14->depth;
  __int128 v86 = xmlStringDecodeEntities(v14, *(const xmlChar **)(v33 + 80), what, 0, 0, 0);
  --v14->depth;
  if (!v86)
  {
    int v90 = *(xmlChar **)(v33 + 80);
    if (!v90) {
      goto LABEL_256;
    }
    goto LABEL_271;
  }

  uint64_t v74 = v86;
  LOBYTE(v87) = *v86;
  if (!*v86) {
    goto LABEL_250;
  }
  uint64_t v76 = 0LL;
  uint64_t v94 = v14;
  while (1)
  {
    v16[v98 + v76] = v87;
    if (v98 + v76 + 101 > v97) {
      break;
    }
    int v7 = v16;
LABEL_248:
    int v87 = v74[++v76];
    int v16 = v7;
    if (!v87) {
      goto LABEL_249;
    }
  }

  if (2 * v97 + 100 < v97)
  {
    xmlParserCtxtPtr v14 = v94;
    goto LABEL_253;
  }

  int v7 = (xmlChar *)xmlRealloc(v16, 2 * v97 + 100);
  unint64_t v97 = 2 * v97 + 100;
  xmlParserCtxtPtr v14 = v94;
  if (v7) {
    goto LABEL_248;
  }
LABEL_253:
  htmlErrMemory(v14, 0LL);
LABEL_254:
  if (v74) {
    xmlFree(v74);
  }
LABEL_256:
  if (v16) {
    xmlFree(v16);
  }
  return 0LL;
}

uint64_t xmlParserEntityCheck(uint64_t result, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (result)
  {
    uint64_t v4 = result;
    if ((*(_BYTE *)(result + 566) & 8) == 0)
    {
      if (*(_DWORD *)(result + 604) == 89) {
        return 1LL;
      }
      if (a3)
      {
        if (*(_DWORD *)(a3 + 92) != 6)
        {
          int v8 = *(const xmlChar **)(a3 + 80);
          if (v8)
          {
            if (!*(_DWORD *)(a3 + 132) && *(_DWORD *)(result + 136) != 89)
            {
              uint64_t v9 = *(void *)(result + 696);
              *(_DWORD *)(a3 + 132) = 1;
              ++*(_DWORD *)(result + 392);
              int v10 = xmlStrlen(v8);
              int v11 = xmlStringLenDecodeEntities((xmlParserCtxtPtr)v4, v8, v10, 1, 0, 0, 0);
              int v12 = v11;
              --*(_DWORD *)(v4 + 392);
              if (!v11 || *(_DWORD *)(v4 + 136) == 89) {
                **(_BYTE **)(a3 + 80) = 0;
              }
              uint64_t v13 = *(void *)(v4 + 696) - v9;
              else {
                int v14 = 0x3FFFFFFF;
              }
              *(_DWORD *)(a3 + 132) = 2 * v14;
              if (v11)
              {
                if (xmlStrchr(v11, 0x3Cu)) {
                  *(_DWORD *)(a3 + 132) |= 1u;
                }
                xmlFree(v12);
              }
            }
          }
        }
      }

      if (*(_DWORD *)(v4 + 272) == 3)
      {
        unint64_t v15 = *(void *)(v4 + 696);
        if (v15 >= 0x2711 && (v15 & 0x3FF) == 0)
        {
          uint64_t v16 = *(unsigned int *)(v4 + 64);
          uint64_t v17 = 0LL;
          uint64_t v18 = *(void **)(v4 + 72);
          do
          {
            int v19 = (void *)*v18++;
            uint64_t v17 = v19[8] + v17 + v19[4] - v19[3];
            --v16;
          }

          while (v16);
          if (v15 > 10 * v17)
          {
LABEL_26:
            xmlFatalErr((_DWORD *)v4, 89, 0LL);
            *(_DWORD *)(v4 + 272) = -1;
            return 1LL;
          }
        }
      }

      if (a4)
      {
        if (a4 >= 0x989680)
        {
          xmlParserCtxtPtr v20 = *(void **)(v4 + 56);
          if (v20) {
            xmlParserCtxtPtr v20 = (void *)(v20[8] + v20[4] - v20[3]);
          }
        }
      }

      else if (a2)
      {
        if (a2 >= 0x3E8)
        {
          int v21 = *(void **)(v4 + 56);
          if (v21) {
            int v21 = (void *)(v21[8] + v21[4] - v21[3]);
          }
          unint64_t v22 = 10LL * ((void)v21 + *(void *)(v4 + 704));
          if (v22 <= a2 || 3LL * *(void *)(v4 + 696) >= v22) {
            goto LABEL_48;
          }
        }
      }

      else if (a3)
      {
        int v23 = *(void **)(v4 + 56);
        if (v23) {
          int v23 = (void *)(v23[8] + v23[4] - v23[3]);
        }
      }

      else if ((*(_DWORD *)(v4 + 604) & 0xFFFFFFFE) == 0x1A && *(void *)(v4 + 696) >= 0x2711uLL)
      {
LABEL_48:
        xmlFatalErr((_DWORD *)v4, 89, 0LL);
        return 1LL;
      }
    }

    return 0LL;
  }

  return result;
}

_DWORD *xmlFatalErrMsg(_DWORD *result, int a2)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 1, a2, 3, 0LL, 0, 0LL, 0LL, 0LL, 0, 0, (uint64_t)"%s");
  }
  unsigned int v2 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    int result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 3, 0LL, 0, 0LL, 0LL, 0LL, 0, 0, (uint64_t)"%s");
    v2[6] = 0;
    if (!v2[112]) {
      v2[83] = 1;
    }
  }

  return result;
}

xmlChar *__cdecl xmlStringDecodeEntities( xmlParserCtxtPtr ctxt, const xmlChar *str, int what, xmlChar end, xmlChar end2, xmlChar end3)
{
  if (!ctxt || !str) {
    return 0LL;
  }
  int v12 = xmlStrlen(str);
  return xmlStringLenDecodeEntities(ctxt, str, v12, what, end, end2, end3);
}

uint64_t *xmlWarningMsg(uint64_t *result, int a2, uint64_t a3, uint64_t a4)
{
  if (!result) {
    return (uint64_t *)__xmlRaiseError(0, 0, 0, 0, 0, 1, a2, 1, 0LL, 0, a4, 0LL, 0LL, 0, 0, a3);
  }
  uint64_t v5 = (uint64_t)result;
  if (!*((_DWORD *)result + 83) || *((_DWORD *)result + 68) != -1)
  {
    uint64_t v6 = *result;
    if (*result)
    {
      if (*(_DWORD *)(v6 + 216) == -554844497) {
        uint64_t v7 = *(void *)(v6 + 248);
      }
      else {
        LODWORD(v7) = 0;
      }
      uint64_t v8 = *(void *)(v6 + 168);
    }

    else
    {
      LODWORD(v7) = 0;
      LODWORD(v8) = 0;
    }

    return (uint64_t *)__xmlRaiseError(v7, v8, *(void *)(v5 + 8), v5, 0, 1, a2, 1, 0LL, 0, a4, 0LL, 0LL, 0, 0, a3);
  }

  return result;
}

xmlChar *__cdecl xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!prefix) {
    return 0LL;
  }
  const char *prefix = 0LL;
  if (!name) {
    return 0LL;
  }
  int v5 = *name;
  if (v5 == 58) {
    return xmlStrdup(name);
  }
  uint64_t v8 = 0LL;
  memset(__src, 0, 105);
  if (v5)
  {
    while (v5 != 58)
    {
      if (v8 == 100)
      {
        unsigned int v9 = 100;
        goto LABEL_13;
      }

      *((_BYTE *)__src + v8) = v5;
      int v5 = name[++v8];
      if (!v5) {
        break;
      }
    }
  }

  if (v8 <= 0x63)
  {
    int v10 = 0LL;
    int v11 = &name[v8 + 1];
    int v12 = 100;
    int v13 = v8;
  }

  else
  {
    unsigned int v9 = v8;
LABEL_13:
    int v14 = (xmlChar *)xmlMallocAtomic(2 * v9);
    int v10 = v14;
    if (!v14) {
      goto LABEL_71;
    }
    xmlParserCtxtPtr v30 = ctxt;
    memcpy(v14, __src, v9);
    uint64_t v15 = 0LL;
    int v12 = 2 * v9;
    while ((_BYTE)v5 && v5 != 58)
    {
      if ((int)(v9 + v15 + 10) > v12)
      {
        v12 *= 2;
        uint64_t v16 = (xmlChar *)xmlRealloc(v10, v12);
        if (!v16)
        {
          xmlFree(v10);
          htmlErrMemory(v30, 0LL);
          return 0LL;
        }

        int v10 = v16;
      }

      v10[v9 + v15] = v5;
      int v5 = name[++v15 + v8];
    }

    int v13 = v9 + v15;
    v10[v9 + v15] = 0;
    int v11 = &name[v8 + 1 + v15];
    ctxt = v30;
  }

  if (v5 == 58 && !*v11)
  {
    if (v10) {
      xmlFree(v10);
    }
    const char *prefix = 0LL;
    return xmlStrdup(name);
  }

  if (v10) {
    int v12 = 100;
  }
  else {
    int v10 = xmlStrndup((const xmlChar *)__src, v13);
  }
  if (v5 == 58)
  {
    LOBYTE(v17) = *v11;
    const char *prefix = v10;
    if (!(_BYTE)v17)
    {
      xmlParserCtxtPtr v20 = (const xmlChar *)&byte_181A3ACBA;
      int v21 = 0;
      return xmlStrndup(v20, v21);
    }

    int len = 0;
    signed int v18 = xmlStringCurrentChar(ctxt, v11, &len);
    signed int v19 = v18;
    if (v18 > 255)
    {
      if (xmlCharInRange(v18, &xmlIsBaseCharGroup)
        || (v19 - 12330) > 0xFFFFFFF6
        || v19 == 12295
        || (v19 - 40870) > 0xFFFFAE59)
      {
        goto LABEL_51;
      }
    }

    else if ((v18 - 192) < 0x17 {
           || (v18 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || v18 == 95
           || v18 > 247
           || (v18 - 216) < 0x1F)
    {
      goto LABEL_51;
    }

    xmlFatalErrMsgStr(ctxt, 202, (uint64_t)"Name %s is not XML Namespace compliant\n", (uint64_t)name);
LABEL_51:
    unint64_t v22 = (unsigned __int8 *)(v11 + 1);
    if (v12 < 1)
    {
      LODWORD(v23) = 0;
    }

    else
    {
      unint64_t v23 = 0LL;
      do
      {
        *((_BYTE *)__src + v23) = v17;
        int v17 = v22[v23++];
        if (v17) {
          BOOL v24 = v23 >= v12;
        }
        else {
          BOOL v24 = 1;
        }
      }

      while (!v24);
      if (v23 < v12)
      {
        xmlParserCtxtPtr v20 = (const xmlChar *)__src;
        int v21 = v23;
        return xmlStrndup(v20, v21);
      }

      v22 += v23;
    }

    int v25 = 2 * v23;
    unint64_t v26 = (xmlChar *)xmlMallocAtomic((2 * v23));
    int v10 = v26;
    if (v26)
    {
      unint64_t v23 = v23;
      memcpy(v26, __src, v23);
      if ((_BYTE)v17)
      {
        while (1)
        {
          if ((int)v23 + 10 > v25)
          {
            v25 *= 2;
            xmlGenericErrorFunc v27 = (xmlChar *)xmlRealloc(v10, v25);
            if (!v27)
            {
              htmlErrMemory(ctxt, 0LL);
              xmlFree(v10);
              return 0LL;
            }

            int v10 = v27;
          }

          unsigned int v28 = v23 + 1;
          v10[v23] = v17;
          int v29 = *v22++;
          LOBYTE(v17) = v29;
          ++v23;
          if (!v29)
          {
            unint64_t v23 = v28;
            break;
          }
        }
      }

      v10[v23] = 0;
      return v10;
    }

LABEL_71:
    htmlErrMemory(ctxt, 0LL);
  }

  return v10;
}

      if (*v7->cur == 62)
      {
        if (id != v7->id) {
          xmlFatalErrMsg(ctxt, 90);
        }
        xmlNextChar(ctxt);
      }
    }

    else
    {
      xmlFatalErrMsg(ctxt, 68);
    }
  }

        uint64_t v16 = *(void *)(v1 + 48);
        if (v16)
        {
          if (*(_DWORD *)(v16 + 4) == 3) {
            return (void *)xmlRegAtomAddRange(v1, v16, *(_DWORD *)(v1 + 20), v5, 0, 0, v3);
          }
        }

        else
        {
          int result = xmlRegNewAtom(v1, v5);
          *(void *)(v1 + 48) = result;
          if (result) {
            result[3] = v3;
          }
        }
      }

      else
      {
LABEL_11:
        *((_DWORD *)result + 4) = 1450;
        uint64_t v7 = "Unknown char property";
        return (void *)xmlRegexpErrCompile((uint64_t)result, (uint64_t)v7);
      }

      return result;
  }

_DWORD *xmlFatalErrMsgStr(_DWORD *result, int a2, uint64_t a3, uint64_t a4)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 1, a2, 3, 0LL, 0, a4, 0LL, 0LL, 0, 0, a3);
  }
  uint64_t v4 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    int result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 3, 0LL, 0, a4, 0LL, 0LL, 0, 0, a3);
    v4[6] = 0;
    if (!v4[112]) {
      v4[83] = 1;
    }
  }

  return result;
}

const xmlChar *__cdecl xmlParseName(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    unint64_t v2 = 10000000LL;
  }
  else {
    unint64_t v2 = 50000LL;
  }
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  int v5 = *cur;
  if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A && v5 != 95 && v5 != 58) {
    goto LABEL_26;
  }
  for (unint64_t i = 1LL; ; ++i)
  {
    int v7 = cur[i];
    if ((v7 - 48) >= 0xA
      && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v7 - 45) > 0x32 || ((1LL << (v7 - 45)) & 0x4000000002003LL) == 0))
    {
      break;
    }
  }

  if (!cur[i] || (v7 & 0x80) != 0)
  {
LABEL_26:
    if ((ctxt->options & 0x80000) != 0) {
      int v13 = 10000000;
    }
    else {
      int v13 = 50000;
    }
    if (!ctxt->progressive && input->end - cur <= 249) {
      xmlGROW((uint64_t)ctxt);
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      return 0LL;
    }
    int len = 0;
    signed int v14 = xmlCurrentChar(ctxt, &len);
    signed int v15 = v14;
    if ((ctxt->options & 0x20000) == 0)
    {
      if ((v14 & 0xFFFFFFDF) - 65 >= 0x1A && v14 != 58 && v14 != 95)
      {
        int32x4_t v16 = vdupq_n_s32(v14);
        unsigned __int8 v17 = vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A37350,  (uint32x4_t)vaddq_s32(v16, (int32x4_t)xmmword_181A37330)),  (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A37360,  (uint32x4_t)vaddq_s32(v16, (int32x4_t)xmmword_181A37340)))));
        BOOL v18 = (v14 - 65008) >= 0x20E && (v14 - 0x10000) >= 0xE0000;
        BOOL v19 = !v18;
      }

      int v20 = len;
      xmlParserInputPtr v21 = ctxt->input;
      unint64_t v22 = v21->cur;
      unint64_t v23 = &v22[len];
      if (v23 <= v21->end)
      {
        if (*v22 == 10)
        {
          ++v21->line;
          v21->col = 1;
        }

        else
        {
          ++v21->col;
        }

        v21->cur = v23;
      }

      unsigned int v27 = xmlCurrentChar(ctxt, &len);
      int v28 = 0;
      while (v27 > 0x3E || ((1LL << v27) & 0x4000800100000000LL) == 0)
      {
        if (v27 - 48 >= 0xB
          && (v27 & 0xFFFFFFDF) - 65 >= 0x1A
          && (v27 - 45 > 0x32 || ((1LL << (v27 - 45)) & 0x4000000000003LL) == 0)
          && v27 != 183)
        {
          int32x4_t v29 = vdupq_n_s32(v27);
          if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A37390,  (uint32x4_t)vaddq_s32(v29, (int32x4_t)xmmword_181A37370)),  (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A373A0,  (uint32x4_t)vaddq_s32(v29, (int32x4_t)xmmword_181A37380))))) & 1) == 0 && v27 - 63744 >= 0x4D0 && v27 - 65008 >= 0x20E && v27 - 0x10000 >= 0xE0000 && (v27 & 0xFFFFFFFE) != 0x200C)
          {
            break;
          }
        }

        if (v28 < 101)
        {
          ++v28;
        }

        else
        {
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (ctxt->instate == XML_PARSER_EOF) {
            return 0LL;
          }
          int v28 = 0;
        }

        if (v20 <= (len ^ 0x7FFFFFFF)) {
          int v30 = len;
        }
        else {
          int v30 = 0;
        }
        xmlParserInputPtr v31 = ctxt->input;
        unsigned int v32 = v31->cur;
        uint64_t v33 = &v32[len];
        if (v33 <= v31->end)
        {
          if (*v32 == 10)
          {
            ++v31->line;
            v31->col = 1;
          }

          else
          {
            ++v31->col;
          }

          v31->cur = v33;
        }

        v20 += v30;
        unsigned int v27 = xmlCurrentChar(ctxt, &len);
        if (!v27)
        {
          int v11 = 0LL;
          if (ctxt->instate == XML_PARSER_EOF) {
            return v11;
          }
        }
      }

LABEL_139:
      if (v20 <= v13)
      {
        int v47 = ctxt->input->cur;
        if (v47 - ctxt->input->base >= v20)
        {
          if (*v47 == 10 && *(v47 - 1) == 13)
          {
            dict = ctxt->dict;
            int v49 = &v47[~v20];
          }

          else
          {
            dict = ctxt->dict;
            int v49 = &v47[-v20];
          }

          return xmlDictLookup(dict, v49, v20);
        }

        int v43 = "unexpected change of input buffer";
        xmlParserCtxtPtr v44 = ctxt;
        int v45 = 1;
LABEL_141:
        xmlFatalErr(v44, v45, (uint64_t)v43);
        return 0LL;
      }

      if ((int)v83 < (int)v60)
      {
        uint64_t v91 = v202[(int)v83];
        __int128 v92 = v91 ? (uint64_t *)(v91 + 48) : &v78[(int)v83];
        xmlChar *v92 = v79;
        v202[(int)v83] = v79;
        int v93 = *(void *)(v79 + 48);
        uint64_t v94 = v93 ? *(void *)(v79 + 48) : v79;
        __int128 v200 = v94;
        int v79 = xmlRelaxNGSkipIgnored(v2, v93);
        if (v79) {
          continue;
        }
      }

LABEL_119:
      if (v34 < 101)
      {
        ++v34;
      }

      else
      {
        if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
        if (ctxt->instate == XML_PARSER_EOF) {
          return 0LL;
        }
        int v34 = 0;
      }

      if (v20 <= (len ^ 0x7FFFFFFF)) {
        int v38 = len;
      }
      else {
        int v38 = 0;
      }
      v20 += v38;
      xmlParserInputPtr v39 = ctxt->input;
      xmlEntityPtr v40 = v39->cur;
      xmlEntityPtr v41 = &v40[len];
      if (v41 <= v39->end)
      {
        if (*v40 == 10)
        {
          ++v39->line;
          v39->col = 1;
        }

        else
        {
          ++v39->col;
        }

        v39->cur = v41;
      }
    }
  }

  if (i > v2) {
    goto LABEL_140;
  }
  int v10 = &cur[i];
  int v11 = xmlDictLookup(ctxt->dict, cur, i);
  xmlParserInputPtr v12 = ctxt->input;
  v12->cur = v10;
  v12->col += i;
  if (!v11)
  {
    htmlErrMemory(ctxt, 0LL);
    return 0LL;
  }

  return v11;
}

        int v53 = (unsigned __int8 *)*((void *)v1 + 6);
        if (!v53)
        {
          int v56 = v10;
          BOOL v3 = v43;
          goto LABEL_176;
        }

        if (*(void *)v1)
        {
          int v54 = *v53;
          if (v54 != 47) {
            goto LABEL_155;
          }
          if ((v53[1] & 0xDFu) - 65 <= 0x19
            && v53[2] == 58
            && xmlStrEqual(*(const xmlChar **)v1, (const xmlChar *)"file"))
          {
            if (v10 + 3 >= v93)
            {
              size_t v55 = (char *)xmlSaveUriRealloc(v43, &v93);
              BOOL v3 = v43;
              if (!v55) {
                goto LABEL_212;
              }
            }

            else
            {
              size_t v55 = v43;
            }

            unsigned int v67 = &v55[v10];
            *unsigned int v67 = *v53;
            v67[1] = v53[1];
            xmlParserInputPtr v68 = v53[2];
            v53 += 3;
            v67[2] = v68;
            v10 += 3;
            int v43 = v55;
          }
        }

        int v54 = *v53;
LABEL_155:
        BOOL v3 = v43;
        if (v54)
        {
          uint64_t v69 = v53 + 1;
          do
          {
            int v56 = v10 + 3;
            if (v10 + 3 >= v93)
            {
              char v70 = (char *)xmlSaveUriRealloc(v3, &v93);
              if (!v70) {
                goto LABEL_212;
              }
              int v54 = *(v69 - 1);
              BOOL v3 = v70;
            }

            if (v54 - 48 < 0xA
              || (v54 & 0xDF) - 65 < 0x1A
              || v54 - 33 <= 0x3E && ((1LL << (v54 - 33)) & 0x4000000094007FE9LL) != 0
              || v54 == 126)
            {
              int v56 = v10 + 1;
            }

            else
            {
              int v72 = v54 & 0xF;
              int v73 = &v3[v10];
              *int v73 = 37;
              if (v54 <= 0x9F) {
                uint64_t v74 = 48;
              }
              else {
                uint64_t v74 = 55;
              }
              v10 += 2;
              v73[1] = v74 + (v54 >> 4);
              if (v72 <= 9) {
                int v75 = 48;
              }
              else {
                int v75 = 55;
              }
              LOBYTE(v54) = v75 + v72;
            }

            v3[v10] = v54;
            unsigned int v71 = *v69++;
            int v54 = v71;
            int v10 = v56;
          }

          while (v71);
        }

        else
        {
          int v56 = v10;
        }

xmlChar *__cdecl xmlParseNmtoken(xmlParserCtxtPtr ctxt)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  memset(__src, 0, 105);
  if ((ctxt->options & 0x80000) != 0) {
    int v2 = 10000000;
  }
  else {
    int v2 = 50000;
  }
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return 0LL;
  }
  int len = 0;
  signed int v3 = xmlCurrentChar(ctxt, &len);
  int v4 = 0;
  int v5 = 0;
  do
  {
    xmlIsNameChar((uint64_t)ctxt, v3);
    if (!v6)
    {
      if (!v4) {
        return 0LL;
      }
      return xmlStrndup((const xmlChar *)__src, v4);
    }

    if (v5 >= 101)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      int v5 = 0;
    }

    else
    {
      ++v5;
    }

    if (len == 1)
    {
      *((_BYTE *)__src + v4++) = v3;
      int v7 = 1;
    }

    else
    {
      v4 += xmlCopyCharMultiByte((xmlChar *)__src + v4, v3);
      int v7 = len;
    }

    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    int v10 = &cur[v7];
    if (v10 <= input->end)
    {
      if (*cur == 10)
      {
        ++input->line;
        input->col = 1;
      }

      else
      {
        ++input->col;
      }

      input->cur = v10;
    }

    signed int v3 = xmlCurrentChar(ctxt, &len);
    if (!v3)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        return 0LL;
      }
      signed int v3 = xmlCurrentChar(ctxt, &len);
      int v5 = 0;
    }
  }

  while (v4 < 100);
  int v11 = 2 * v4;
  xmlParserInputPtr v12 = (xmlChar *)xmlMallocAtomic((2 * v4));
  int v13 = v12;
  if (!v12)
  {
    htmlErrMemory(ctxt, 0LL);
    return v13;
  }

  memcpy(v12, __src, v4);
  while (1)
  {
    xmlIsNameChar((uint64_t)ctxt, v3);
    if (!v14)
    {
      v13[v4] = 0;
      return v13;
    }

    if (v5 < 101)
    {
      ++v5;
    }

    else
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      if (ctxt->instate == XML_PARSER_EOF) {
        goto LABEL_59;
      }
      int v5 = 0;
    }

    if (v4 + 10 <= v11) {
      goto LABEL_44;
    }
    v11 *= 2;
    signed int v15 = (xmlChar *)xmlRealloc(v13, v11);
    if (!v15) {
      break;
    }
    int v13 = v15;
LABEL_44:
    if (len == 1) {
      v13[v4++] = v3;
    }
    else {
      v4 += xmlCopyCharMultiByte(&v13[v4], v3);
    }
    xmlParserInputPtr v16 = ctxt->input;
    unsigned __int8 v17 = v16->cur;
    BOOL v18 = &v17[len];
    if (v18 <= v16->end)
    {
      if (*v17 == 10)
      {
        ++v16->line;
        v16->col = 1;
      }

      else
      {
        ++v16->col;
      }

      v16->cur = v18;
    }

    signed int v3 = xmlCurrentChar(ctxt, &len);
    if (v4 > v2)
    {
      xmlFatalErr(ctxt, 110, (uint64_t)"NmToken");
      goto LABEL_59;
    }
  }

  htmlErrMemory(ctxt, 0LL);
LABEL_59:
  xmlFree(v13);
  return 0LL;
}

__n128 xmlIsNameChar(uint64_t a1, signed int val)
{
  if ((*(_BYTE *)(a1 + 566) & 2) != 0)
  {
    if (val > 255)
    {
      if (xmlCharInRange(val, &xmlIsBaseCharGroup)
        || (val - 12321) < 9
        || val == 12295
        || (val - 19968) < 0x51A6
        || xmlCharInRange(val, &xmlIsDigitGroup))
      {
        return result;
      }
    }

    else if ((val - 192) < 0x17 {
           || (val & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (val - 48) < 0xA
           || val > 247
           || (val - 216) < 0x1F)
    {
      return result;
    }

    if (((val - 45) > 0x32 || ((1LL << (val - 45)) & 0x4000000002003LL) == 0)
      && val >= 256
      && !xmlCharInRange(val, &xmlIsCombiningGroup))
    {
      xmlCharInRange(val, &xmlIsExtenderGroup);
    }
  }

  else if ((val > 0x3E || ((1LL << val) & 0x4000800100000000LL) == 0) {
         && (val - 48) >= 0xB
  }
         && (val & 0xFFFFFFDF) - 65 >= 0x1A
         && ((val - 45) > 0x32 || ((1LL << (val - 45)) & 0x4000000000003LL) == 0)
         && val != 183)
  {
    int32x4_t v4 = vdupq_n_s32(val);
    result.n128_u8[0] = vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A37390,  (uint32x4_t)vaddq_s32(v4, (int32x4_t)xmmword_181A37370)),  (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A373A0,  (uint32x4_t)vaddq_s32(v4, (int32x4_t)xmmword_181A37380)))));
  }

  return result;
}

xmlChar *__cdecl xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig)
{
  int len = 0;
  if ((ctxt->options & 0x80000) != 0) {
    int v4 = 1000000000;
  }
  else {
    int v4 = 10000000;
  }
  uint64_t v22 = 0LL;
  int v5 = *ctxt->input->cur;
  if (v5 != 34 && v5 != 39)
  {
    xmlFatalErr(ctxt, 36, 0LL);
    return 0LL;
  }

  int v6 = xmlMallocAtomic(0x64uLL);
  if (!v6)
  {
    htmlErrMemory(ctxt, 0LL);
    return 0LL;
  }

  int v7 = v6;
  ctxt->xmlParserInputState instate = XML_PARSER_ENTITY_VALUE;
  xmlParserInputPtr input = ctxt->input;
  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_62;
    }
  }

  xmlNextChar(ctxt);
  int v9 = xmlCurrentChar(ctxt, &len);
  int v10 = 0;
  int v11 = 100;
  while (1)
  {
    if (v9 > 255)
    {
      if ((v9 - 0x10000) >= 0x100000
        && v9 >> 11 >= 0x1B
        && (v9 - 57344) >> 1 > 0xFFE)
      {
        goto LABEL_47;
      }
    }

    else if (v9 <= 31 && (v9 > 0xD || ((1 << v9) & 0x2600) == 0))
    {
      goto LABEL_47;
    }

    if (v9 == v5 && ctxt->input == input) {
      break;
    }
    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_47;
    }
    if (v10 + 5 >= v11)
    {
      v11 *= 2;
      xmlParserInputPtr v12 = xmlRealloc(v7, v11);
      if (!v12)
      {
        htmlErrMemory(ctxt, 0LL);
        goto LABEL_65;
      }

      int v7 = v12;
    }

    if (len == 1) {
      *((_BYTE *)v7 + v10++) = v9;
    }
    else {
      v10 += xmlCopyCharMultiByte((xmlChar *)v7 + v10, v9);
    }
    xmlParserInputPtr v13 = ctxt->input;
    cur = v13->cur;
    end = v13->end;
    xmlParserInputPtr v16 = &cur[len];
    if (v16 <= end)
    {
      if (*cur == 10)
      {
        ++v13->line;
        v13->col = 1;
      }

      else
      {
        ++v13->col;
      }

      v13->cur = v16;
      cur = v16;
    }

    if (!ctxt->progressive && end - cur <= 249) {
      xmlGROW((uint64_t)ctxt);
    }
    int v9 = xmlCurrentChar(ctxt, &len);
    if (!v9)
    {
      if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
        xmlGROW((uint64_t)ctxt);
      }
      int v9 = xmlCurrentChar(ctxt, &len);
    }

    if (v10 > v4)
    {
      xmlFatalErrMsg(ctxt, 37);
LABEL_65:
      unsigned __int8 v17 = 0LL;
      goto LABEL_66;
    }
  }

  int v9 = v5;
LABEL_47:
  *((_BYTE *)v7 + v10) = 0;
  if (ctxt->instate == XML_PARSER_EOF)
  {
LABEL_62:
    unsigned __int8 v17 = 0LL;
    goto LABEL_66;
  }

  if (v9 != v5)
  {
    xmlFatalErr(ctxt, 37, 0LL);
    goto LABEL_62;
  }

  xmlNextChar(ctxt);
  for (unint64_t i = (const xmlChar *)v7; ; ++i)
  {
    uint64_t v22 = i;
    int v19 = *i;
    if (v19 != 37) {
      break;
    }
LABEL_55:
    uint64_t v22 = i + 1;
    int v20 = xmlParseStringName(ctxt, &v22);
    if (!v20 || (xmlFree(v20), unint64_t i = v22, *v22 != 59))
    {
      xmlFatalErrMsgInt(ctxt, 87, (uint64_t)"EntityValue: '%c' forbidden except for entities references\n", v19);
      goto LABEL_65;
    }

    if (v19 == 37 && ctxt->inSubset == 1 && ctxt->inputNr == 1)
    {
      xmlFatalErr(ctxt, 88, 0LL);
      goto LABEL_65;
    }

LABEL_66:
  xmlFree(v7);
  return v17;
}

                switch(v49)
                {
                  case 2u:
                    v112 = v37;
                    int v61 = *(_DWORD *)(v48 + 44);
                    if (v50 == 2)
                    {
                      int v54 = v61 == *(_DWORD *)(v47 + 44);
                    }

                    else
                    {
                      __int128 v86 = v47;
                      int v87 = v1;
                      uint64_t v88 = v47;
                      __int128 v89 = v41;
                      int v90 = v48;
                      int v54 = xmlRegCheckCharacter(v86, v61);
                      int v48 = v90;
                      xmlEntityPtr v41 = v89;
                      int v47 = v88;
                      int v1 = v87;
                      if (v54 < 0) {
                        int v54 = 1;
                      }
                    }

      if (v36 != v21 || v34 < v74)
      {
        int v36 = xmlXPtrAdvanceNode(v36, 0LL);
        int v34 = 1;
        if (v36) {
          continue;
        }
      }

      goto LABEL_115;
    }
  }

  xmlXPathErr(v2, 15);
LABEL_120:
  xmlXPathFreeObject(v16);
  xmlXPathFreeObject(v12);
  if (v9) {
    xmlXPathFreeObject(v9);
  }
  if (v5) {
    xmlXPathFreeObject(v5);
  }
}

xmlChar *xmlParseStringName(xmlParserCtxt *a1, const xmlChar **a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  __int128 v25 = 0u;
  memset(v26, 0, sizeof(v26));
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  *(_OWORD *)out = 0u;
  __int128 v22 = 0u;
  int v4 = *a2;
  int len = 0;
  if ((a1->options & 0x80000) != 0) {
    int v5 = 10000000;
  }
  else {
    int v5 = 50000;
  }
  signed int v6 = xmlStringCurrentChar(a1, v4, &len);
  xmlIsNameStartChar((uint64_t)a1, v6);
  if (!v7) {
    return 0LL;
  }
  if (len == 1)
  {
    out[0] = v6;
    uint64_t v8 = 1LL;
    int v9 = 1;
  }

  else
  {
    int v9 = xmlCopyCharMultiByte(out, v6);
    uint64_t v8 = len;
  }

  int v10 = &v4[v8];
  signed int v11 = xmlStringCurrentChar(a1, v10, &len);
  do
  {
    xmlIsNameChar((uint64_t)a1, v11);
    if (!v12)
    {
      if (v9 > v5)
      {
        xmlFatalErr(a1, 110, (uint64_t)"NCName");
        return 0LL;
      }

      *a2 = v10;
      return xmlStrndup(out, v9);
    }

    int v13 = len;
    if (len == 1)
    {
      out[v9++] = v11;
    }

    else
    {
      v9 += xmlCopyCharMultiByte(&out[v9], v11);
      int v13 = len;
    }

    v10 += v13;
    signed int v11 = xmlStringCurrentChar(a1, v10, &len);
  }

  while (v9 < 100);
  int v14 = 2 * v9;
  signed int v15 = xmlMallocAtomic((2 * v9));
  xmlParserInputPtr v16 = v15;
  if (!v15)
  {
    htmlErrMemory(a1, 0LL);
    return v16;
  }

  memcpy(v15, out, v9);
  while (1)
  {
    xmlIsNameChar((uint64_t)a1, v11);
    if (!v17)
    {
      v16[v9] = 0;
      *a2 = v10;
      return v16;
    }

    if (v9 + 10 <= v14) {
      goto LABEL_20;
    }
    v14 *= 2;
    BOOL v18 = xmlRealloc(v16, v14);
    if (!v18) {
      break;
    }
    xmlParserInputPtr v16 = v18;
LABEL_20:
    if (len == 1) {
      v16[v9++] = v11;
    }
    else {
      v9 += xmlCopyCharMultiByte(&v16[v9], v11);
    }
    v10 += len;
    signed int v11 = xmlStringCurrentChar(a1, v10, &len);
    if (v9 > v5)
    {
      xmlFatalErr(a1, 110, (uint64_t)"NCName");
      goto LABEL_31;
    }
  }

  htmlErrMemory(a1, 0LL);
LABEL_31:
  xmlFree(v16);
  return 0LL;
}

xmlChar *__cdecl xmlParseAttValue(xmlParserCtxtPtr ctxt)
{
  if (ctxt && ctxt->input) {
    return xmlParseAttValueInternal((uint64_t)ctxt, 0LL, 0LL, 0LL);
  }
  else {
    return 0LL;
  }
}

xmlChar *xmlParseAttValueInternal(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v7 = a1;
  if ((*(_BYTE *)(a1 + 566) & 8) != 0) {
    uint64_t v8 = 1000000000LL;
  }
  else {
    uint64_t v8 = 10000000LL;
  }
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    uint64_t v9 = v8;
    xmlGROW(a1);
    uint64_t v8 = v9;
  }

  uint64_t v10 = *(void *)(v7 + 56);
  signed int v11 = *(unsigned __int8 **)(v10 + 32);
  int v12 = *(_DWORD *)(v10 + 52);
  int v13 = *v11;
  if (v13 != 34 && v13 != 39) {
    goto LABEL_236;
  }
  int v14 = *(_DWORD *)(v10 + 56);
  int v15 = 12;
  *(_DWORD *)(v7 + 272) = 12;
  xmlParserInputPtr v16 = v11 + 1;
  uint64_t v17 = *v11;
  unint64_t v18 = *(void *)(v10 + 40);
  v113 = a3;
  if ((unint64_t)(v11 + 1) >= v18)
  {
    uint64_t v19 = *(void *)(v10 + 24);
    if ((uint64_t)(v18 - (void)v11) <= 249 && *(_DWORD *)(v7 + 452) == 0)
    {
      uint64_t v21 = v8;
      xmlGROW(v7);
      uint64_t v8 = v21;
      int v15 = *(_DWORD *)(v7 + 272);
      if (v15 == -1) {
        return 0LL;
      }
    }

    else
    {
      int v15 = 12;
    }

    uint64_t v10 = *(void *)(v7 + 56);
    uint64_t v22 = *(void *)(v10 + 24) - v19;
    if (!v22) {
      uint64_t v22 = 0LL;
    }
    v16 += v22;
    unint64_t v18 = *(void *)(v10 + 40);
  }

  int v23 = v14 + 1;
  if ((_DWORD)a4)
  {
    while ((unint64_t)v16 < v18)
    {
      unsigned int v24 = *v16;
      if (v24 == (_DWORD)v17) {
        break;
      }
      if (v24 > 0x20 || ((1LL << v24) & 0x100002600LL) == 0) {
        break;
      }
      if (v24 == 10)
      {
        ++v12;
        int v23 = 1;
      }

      else
      {
        ++v23;
      }

      if ((unint64_t)++v16 >= v18)
      {
        uint64_t v26 = *(void *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
        {
          uint64_t v27 = v7;
          uint64_t v28 = v17;
          uint64_t v29 = v7;
          uint64_t v30 = a4;
          xmlParserInputPtr v31 = a2;
          uint64_t v32 = v8;
          xmlGROW(v27);
          uint64_t v8 = v32;
          a2 = v31;
          a4 = v30;
          uint64_t v7 = v29;
          uint64_t v17 = v28;
          int v15 = *(_DWORD *)(v7 + 272);
        }

        if (v15 == -1) {
          return 0LL;
        }
        uint64_t v10 = *(void *)(v7 + 56);
        uint64_t v33 = *(void *)(v10 + 24) - v26;
        if (!v33) {
          uint64_t v33 = 0LL;
        }
        v16 += v33;
        unint64_t v18 = *(void *)(v10 + 40);
      }
    }

    xmlGenericErrorFunc v111 = a2;
    int v112 = a4;
    unint64_t i = v16;
    if ((unint64_t)v16 < v18)
    {
      while (1)
      {
        int v35 = v23;
        int v36 = *v16;
        if (v36 == 38) {
          break;
        }
        if (v36 == 60) {
          break;
        }
        ++v23;
        ++v16;
        if (v36 == 32 && *v16 == 32) {
          break;
        }
        if ((unint64_t)v16 >= v18)
        {
          uint64_t v38 = *(void *)(v10 + 24);
          if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
          {
            uint64_t v39 = v7;
            int v109 = v17;
            uint64_t v17 = v7;
            uint64_t v40 = a4;
            xmlEntityPtr v41 = a2;
            uint64_t v42 = v8;
            xmlGROW(v39);
            uint64_t v8 = v42;
            a2 = v41;
            a4 = v40;
            uint64_t v7 = v17;
            LODWORD(v17) = v109;
            int v15 = *(_DWORD *)(v7 + 272);
          }

          if (v15 == -1) {
            return 0LL;
          }
          uint64_t v10 = *(void *)(v7 + 56);
          uint64_t v43 = *(void *)(v10 + 24) - v38;
          if (!v43) {
            uint64_t v43 = 0LL;
          }
          i += v43;
          v16 += v43;
          if (v16 - i > v8) {
            goto LABEL_102;
          }
          unint64_t v18 = *(void *)(v10 + 40);
        }

        if ((unint64_t)v16 >= v18)
        {
          int v23 = v35 + 1;
          break;
        }
      }
    }

    int v50 = v16;
    int v51 = v16;
    int v52 = v16;
    do
    {
      int v53 = *--v52;
      BOOL v54 = v53 == 32 && v51 > i;
      int v51 = v52;
    }

    while (v54);
    LODWORD(v16) = (_DWORD)v52 + 1;
    while ((unint64_t)v50 < v18)
    {
      unsigned int v55 = *v50;
      if (v55 == (_DWORD)v17) {
        break;
      }
      if (v55 > 0x20 || ((1LL << v55) & 0x100002600LL) == 0) {
        break;
      }
      if (v55 == 10)
      {
        ++v12;
        int v23 = 1;
      }

      else
      {
        ++v23;
      }

      if ((unint64_t)++v50 >= v18)
      {
        uint64_t v57 = *(void *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
        {
          uint64_t v58 = v8;
          xmlGROW(v7);
          uint64_t v8 = v58;
          int v15 = *(_DWORD *)(v7 + 272);
        }

        if (v15 == -1) {
          return 0LL;
        }
        uint64_t v10 = *(void *)(v7 + 56);
        uint64_t v59 = *(void *)(v10 + 24) - v57;
        if (!v59) {
          uint64_t v59 = 0LL;
        }
        i += v59;
        v50 += v59;
        if (v50 - i > v8) {
          goto LABEL_102;
        }
        LODWORD(v16) = (_DWORD)v16 + v59;
        unint64_t v18 = *(void *)(v10 + 40);
      }
    }

    if (v50 - i > v8) {
      goto LABEL_102;
    }
    int v49 = *v50;
  }

  else
  {
    for (unint64_t i = v16; (unint64_t)v16 < v18; ++v23)
    {
      int v44 = *v16;
      BOOL v45 = (char)*v16 < 32 || v44 == (_DWORD)v17;
      if (v45 || v44 == 38 || v44 == 60) {
        break;
      }
      if ((unint64_t)++v16 >= v18)
      {
        uint64_t v46 = *(void *)(v10 + 24);
        if (!*(_DWORD *)(v7 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
        {
          uint64_t v47 = v8;
          xmlGROW(v7);
          uint64_t v8 = v47;
          int v15 = *(_DWORD *)(v7 + 272);
        }

        if (v15 == -1) {
          return 0LL;
        }
        uint64_t v10 = *(void *)(v7 + 56);
        uint64_t v48 = *(void *)(v10 + 24) - v46;
        if (!v48) {
          uint64_t v48 = 0LL;
        }
        i += v48;
        v16 += v48;
        if (v16 - i > v8) {
          goto LABEL_102;
        }
        unint64_t v18 = *(void *)(v10 + 40);
      }
    }

    if (v16 - i > v8)
    {
LABEL_102:
      xmlFatalErrMsg((_DWORD *)v7, 40);
      return 0LL;
    }

    int v112 = 0;
    xmlGenericErrorFunc v111 = a2;
    int v49 = *v16;
    int v50 = v16;
  }

  if (v49 == (_DWORD)v17)
  {
    if (v111)
    {
      *xmlGenericErrorFunc v111 = (_DWORD)v16 - (_DWORD)i;
      int v60 = v113;
    }

    else
    {
      int v60 = v113;
      if (v113) {
        _DWORD *v113 = 1;
      }
      unint64_t i = xmlStrndup(i, (int)v16 - (int)i);
      uint64_t v10 = *(void *)(v7 + 56);
    }

    *(void *)(v10 + 32) = v50 + 1;
    *(_DWORD *)(v10 + 52) = v12;
    *(_DWORD *)(v10 + 56) = v23 + 1;
    if (v60) {
      _DWORD *v60 = 0;
    }
    return i;
  }

  if (v113) {
    _DWORD *v113 = 1;
  }
  unint64_t v61 = (*(_DWORD *)(v7 + 564) & 0x80000) != 0 ? 1000000000LL : 10000000LL;
  int len = 0;
  int v62 = **(unsigned __int8 **)(v10 + 32);
  if (v62 != 34 && v62 != 39)
  {
LABEL_236:
    xmlFatalErr((_DWORD *)v7, 39, 0LL);
    return 0LL;
  }

  *(_DWORD *)(v7 + 272) = 12;
  xmlNextChar((xmlParserCtxtPtr)v7);
  uint64_t v63 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v63)
  {
    int v72 = 0LL;
LABEL_245:
    unsigned int v66 = 0LL;
    goto LABEL_246;
  }

  unint64_t i = v63;
  int v64 = xmlCurrentChar((xmlParserCtxtPtr)v7, &len);
  unint64_t v65 = 0LL;
  LODWORD(v66) = 0;
  unint64_t v67 = 100LL;
  while (1)
  {
    xmlParserInputPtr v68 = *(unsigned __int8 **)(*(void *)(v7 + 56) + 32LL);
    if (v62 == *v68)
    {
LABEL_250:
      if (*(_DWORD *)(v7 + 272) == -1)
      {
LABEL_257:
        unsigned int v66 = 0LL;
        goto LABEL_247;
      }

      if (v112)
      {
        xmlGenericErrorFunc v102 = v111;
        if ((_DWORD)v66 && v65)
        {
          do
          {
            if (i[v65 - 1] != 32) {
              break;
            }
            --v65;
          }

          while (v65);
        }
      }

      else
      {
        xmlGenericErrorFunc v102 = v111;
      }

      i[v65] = 0;
      int v103 = **(unsigned __int8 **)(*(void *)(v7 + 56) + 32LL);
      if (v103 == 60)
      {
        xmlFatalErr((_DWORD *)v7, 38, 0LL);
        goto LABEL_277;
      }

      if (v62 == v103)
      {
        xmlNextChar((xmlParserCtxtPtr)v7);
        goto LABEL_277;
      }

      if (v64)
      {
        if (v64 > 255)
        {
          if ((v64 - 0x10000) >= 0x100000
            && v64 >> 11 >= 0x1B
            && (v64 - 57344) >> 1 >= 0xFFF)
          {
            goto LABEL_274;
          }
        }

        else if (v64 <= 31 && (v64 > 0xD || ((1 << v64) & 0x2600) == 0))
        {
LABEL_274:
          unsigned int v104 = (_DWORD *)v7;
          int v105 = 9;
LABEL_276:
          xmlFatalErrMsg(v104, v105);
LABEL_277:
          if (v102) {
            *xmlGenericErrorFunc v102 = v65;
          }
          return i;
        }
      }

      unsigned int v104 = (_DWORD *)v7;
      int v105 = 40;
      goto LABEL_276;
    }

    if (v64 > 255)
    {
      if ((v64 - 0x10000) >= 0x100000
        && v64 >> 11 >= 0x1B
        && (v64 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_250;
      }
    }

    else if (v64 <= 31)
    {
    }

    else if (v64 == 60)
    {
      goto LABEL_250;
    }

    if (*(_DWORD *)(v7 + 272) == -1) {
      goto LABEL_257;
    }
    if (v64 > 0x26)
    {
LABEL_147:
      if (len == 1) {
        i[v65++] = v64;
      }
      else {
        v65 += xmlCopyCharMultiByte(&i[v65], v64);
      }
      if (v65 + 10 <= v67)
      {
        LODWORD(v66) = 0;
      }

      else
      {
        if (2 * v67 + 10 < v67) {
          goto LABEL_258;
        }
        int v73 = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
        if (!v73) {
          goto LABEL_258;
        }
        LODWORD(v66) = 0;
        unint64_t i = v73;
        unint64_t v67 = 2 * v67 + 10;
      }

      goto LABEL_167;
    }

    if (((1LL << v64) & 0x100002600LL) != 0)
    {
      if (!v112 || v65)
      {
        if (v112 && (_DWORD)v66)
        {
          LODWORD(v66) = 1;
        }

        else
        {
          if (len == 1) {
            i[v65++] = 32;
          }
          else {
            v65 += xmlCopyCharMultiByte(&i[v65], 32);
          }
          while (1)
          {
            int v72 = i;
            if (v65 + 10 <= v67) {
              break;
            }
            if (2 * v67 + 10 >= v67)
            {
              unint64_t i = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
              unint64_t v67 = 2 * v67 + 10;
              if (i) {
                continue;
              }
            }

            goto LABEL_245;
          }

          LODWORD(v66) = 1;
        }
      }

LABEL_220:
      LODWORD(v66) = 0;
      int v96 = &v95[v65];
      *(_DWORD *)int v96 = 942875430;
      v65 += 5LL;
      v96[4] = 59;
      goto LABEL_221;
    }

    if (!*(_DWORD *)(v7 + 28))
    {
      unint64_t v107 = v61;
      int v86 = xmlStrlen(v70->name);
      int v87 = v66[2];
      int v106 = v86;
      if (*((_DWORD *)v66 + 23) != 6)
      {
        uint64_t v88 = v66[10];
        if (v88)
        {
          if (!*((_DWORD *)v66 + 33))
          {
            uint64_t v89 = *(void *)(v7 + 696);
            ++*(_DWORD *)(v7 + 392);
            int v90 = xmlStrlen(v88);
            uint64_t v91 = xmlStringLenDecodeEntities((xmlParserCtxtPtr)v7, v88, v90, 1, 0, 0, 0);
            --*(_DWORD *)(v7 + 392);
            uint64_t v92 = *(void *)(v7 + 696) - v89;
            else {
              int v93 = 0x3FFFFFFF;
            }
            *((_DWORD *)v66 + 33) = 2 * v93;
            if (v91)
            {
              uint64_t v94 = v91;
              if (xmlStrchr(v91, 0x3Cu)) {
                *((_DWORD *)v66 + 33) |= 1u;
              }
              ((void (*)(xmlChar *))xmlFree)(v94);
            }

            else
            {
              *v66[10] = 0;
            }

            int v86 = v106;
          }
        }
      }

      unint64_t v97 = v65 + 1;
      i[v65] = 38;
      uint64_t v108 = v86 + 10LL;
      unint64_t v110 = v65 + v86 + 11;
      while (1)
      {
        int v72 = i;
        if (v110 <= v67) {
          break;
        }
        if (v108 + 2 * v67 < v67)
        {
          unsigned int v66 = 0LL;
          goto LABEL_246;
        }

        unint64_t i = (xmlChar *)xmlRealloc(i, v108 + 2 * v67);
        unsigned int v66 = 0LL;
        unint64_t v67 = v108 + 2 * v67;
        if (!i) {
          goto LABEL_246;
        }
      }

      if (v106 < 1)
      {
        unint64_t v100 = v65 + 1;
      }

      else
      {
        unsigned int v98 = v106 + 1;
        do
        {
          xmlChar v99 = *v87++;
          unint64_t v100 = v97 + 1;
          i[v97] = v99;
          --v98;
          ++v97;
        }

        while (v98 > 1);
      }

      LODWORD(v66) = 0;
      unint64_t v65 = v100 + 1;
      i[v100] = 59;
LABEL_235:
      unint64_t v61 = v107;
      goto LABEL_172;
    }

    ++*(_DWORD *)(v7 + 392);
    uint64_t v78 = xmlStringDecodeEntities((xmlParserCtxtPtr)v7, v70->content, 1, 0, 0, 0);
    unsigned int v66 = (unsigned __int8 **)v78;
    --*(_DWORD *)(v7 + 392);
    if (v78) {
      break;
    }
LABEL_172:
    if (!*(_DWORD *)(v7 + 452)
      && (uint64_t)(*(void *)(*(void *)(v7 + 56) + 40LL) - *(void *)(*(void *)(v7 + 56) + 32LL)) <= 249)
    {
      xmlGROW(v7);
    }

    int v64 = xmlCurrentChar((xmlParserCtxtPtr)v7, &len);
    if (v65 > v61)
    {
      xmlFatalErrMsg((_DWORD *)v7, 40);
LABEL_258:
      unsigned int v66 = 0LL;
      int v72 = i;
      goto LABEL_246;
    }
  }

  unint64_t v107 = v61;
  int v79 = v78;
  do
  {
    int v72 = i;
    unint64_t v80 = v65;
    do
    {
      int v81 = *v79;
      if ((v81 - 9) < 2 || v81 == 13)
      {
        LOBYTE(v8htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 32;
      }

      else if (!*v79)
      {
        ((void (*)(unsigned __int8 **))xmlFree)(v66);
        LODWORD(v66) = 0;
        unint64_t v65 = v80;
        goto LABEL_235;
      }

      i[v80] = v81;
      ++v79;
      unint64_t v65 = v80 + 1;
      unint64_t v83 = v80 + 11;
      ++v80;
    }

    while (v83 <= v67);
    if (2 * v67 + 10 < v67) {
      break;
    }
    unint64_t i = (xmlChar *)xmlRealloc(i, 2 * v67 + 10);
    unint64_t v67 = 2 * v67 + 10;
  }

  while (i);
LABEL_246:
  htmlErrMemory((_DWORD *)v7, 0LL);
  unint64_t i = v72;
  if (v72) {
LABEL_247:
  }
    ((void (*)(xmlChar *))xmlFree)(i);
  if (v66) {
    ((void (*)(unsigned __int8 **))xmlFree)(v66);
  }
  return 0LL;
}

        xmlRngPErr(v84, v85, v86, v87, (const xmlChar *)doc, 0LL);
        int v77 = 0LL;
        goto LABEL_221;
      }

      int v35 = a1;
      int v36 = v6;
      signed int v37 = 1052;
      uint64_t v38 = "xmlRelaxNGParse: include has no href attribute\n";
      int v34 = 0LL;
LABEL_68:
      xmlRngPErr(v35, v36, v37, v38, v34, 0LL);
      int v4 = (xmlNode *)v6;
      goto LABEL_257;
    }

    if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"element")
      && !xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute"))
    {
      if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"name")
        || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"nsName")
        || xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"value"))
      {
        if (!xmlHasProp((const xmlNode *)v6, (const xmlChar *)"ns"))
        {
          uint64_t v88 = v6;
          while (1)
          {
            uint64_t v88 = *(void *)(v88 + 40);
            if (!v88 || *(_DWORD *)(v88 + 8) != 1) {
              break;
            }
            uint64_t v89 = xmlGetProp((const xmlNode *)v88, (const xmlChar *)"ns");
            if (v89)
            {
              int v90 = v89;
              xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", v89);
              xmlFree(v90);
              goto LABEL_241;
            }
          }

          xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", (const xmlChar *)&byte_181A3ACBA);
        }

xmlChar *__cdecl xmlParseSystemLiteral(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    int v2 = 10000000;
  }
  else {
    int v2 = 50000;
  }
  xmlParserInputState instate = ctxt->instate;
  if (!ctxt->progressive)
  {
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }

  int len = 0;
  int v6 = *ctxt->input->cur;
  if (v6 != 34 && v6 != 39)
  {
    xmlFatalErr(ctxt, 43, 0LL);
    return 0LL;
  }

  xmlNextChar(ctxt);
  uint64_t v7 = (xmlChar *)xmlMallocAtomic(0x64uLL);
  if (!v7)
  {
    htmlErrMemory(ctxt, 0LL);
    return v7;
  }

  xmlParserInputState v25 = instate;
  ctxt->xmlParserInputState instate = XML_PARSER_SYSTEM_LITERAL;
  int v8 = xmlCurrentChar(ctxt, &len);
  int v9 = 0;
  int v10 = 0;
  int v11 = 100;
  while (1)
  {
    if (v8 > 255)
    {
      BOOL v14 = v8 >> 11 < 0x1B
         || (v8 - 57344) >> 1 < 0xFFF
         || (v8 - 0x10000) < 0x100000;
      if (v8 != v6 && v14) {
        goto LABEL_29;
      }
      v7[v9] = 0;
      ctxt->xmlParserInputState instate = v25;
      if (v14) {
        goto LABEL_64;
      }
LABEL_70:
      xmlFatalErr(ctxt, 44, 0LL);
      return v7;
    }

    if (v8 <= 31 && (v8 > 0xD || ((1 << v8) & 0x2600) == 0))
    {
      v7[v9] = 0;
      ctxt->xmlParserInputState instate = v25;
      goto LABEL_70;
    }

    if (v8 == v6)
    {
      v7[v9] = 0;
      ctxt->xmlParserInputState instate = v25;
LABEL_64:
      xmlNextChar(ctxt);
      return v7;
    }

xmlParserInput *xmlSHRINK(uint64_t a1)
{
  __n128 result = *(xmlParserInput **)(a1 + 56);
  if (!*result->cur) {
    return (xmlParserInput *)xmlParserInputGrow(result, 250);
  }
  return result;
}

xmlChar *__cdecl xmlParsePubidLiteral(xmlParserCtxtPtr ctxt)
{
  int options = ctxt->options;
  xmlParserInputState instate = ctxt->instate;
  if (!ctxt->progressive)
  {
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }

  int v6 = *ctxt->input->cur;
  if (v6 == 34 || v6 == 39)
  {
    xmlNextChar(ctxt);
    uint64_t v7 = xmlMallocAtomic(0x64uLL);
    if (v7)
    {
      xmlParserInputState v21 = instate;
      uint64_t v8 = 0LL;
      int v9 = 0;
      ctxt->xmlParserInputState instate = XML_PARSER_PUBLIC_LITERAL;
      uint64_t v10 = *ctxt->input->cur;
      if ((options & 0x80000) != 0) {
        uint64_t v11 = 10000001LL;
      }
      else {
        uint64_t v11 = 50001LL;
      }
      int v12 = 100;
      while (v6 != v10 && xmlIsPubidChar_tab[v10])
      {
        uint64_t v13 = v8 + 1;
        if (v8 + 1 >= v12)
        {
          v12 *= 2;
          BOOL v14 = xmlRealloc(v7, v12);
          if (!v14)
          {
            htmlErrMemory(ctxt, 0LL);
            goto LABEL_42;
          }

          uint64_t v7 = v14;
        }

        *((_BYTE *)v7 + v8) = v10;
        if (v9 < 50)
        {
          ++v9;
        }

        else
        {
          if (!ctxt->progressive)
          {
            xmlParserInputPtr v15 = ctxt->input;
            xmlParserInputPtr v16 = v15->cur;
            if (v16 - v15->base < 501 || v15->end - v16 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
            {
              if (ctxt->input->end - ctxt->input->cur <= 249) {
                xmlGROW((uint64_t)ctxt);
              }
            }
          }

          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_42;
          }
          int v9 = 0;
        }

        xmlNextChar(ctxt);
        xmlParserInputPtr v17 = ctxt->input;
        xmlParserInputPtr v18 = v17->cur;
        uint64_t v10 = *v18;
        if (!*v18)
        {
          if (!ctxt->progressive)
          {
            if (v17->end - v18 > 249 || (xmlGROW((uint64_t)ctxt), xmlParserInputPtr v17 = ctxt->input, !ctxt->progressive))
            {
              uint64_t v19 = v17->cur;
              if (v19 - v17->base >= 501 && v17->end - v19 <= 499)
              {
                xmlSHRINK((uint64_t)ctxt);
                xmlParserInputPtr v17 = ctxt->input;
              }
            }
          }

          uint64_t v10 = *v17->cur;
        }

        ++v8;
        if (v11 == v13)
        {
          xmlFatalErr(ctxt, 110, (uint64_t)"Public ID");
LABEL_42:
          xmlFree(v7);
          return 0LL;
        }
      }

      *((_BYTE *)v7 + v8) = 0;
      else {
        xmlFatalErr(ctxt, 44, 0LL);
      }
      ctxt->xmlParserInputState instate = v21;
    }

    else
    {
      htmlErrMemory(ctxt, 0LL);
    }
  }

  else
  {
    xmlFatalErr(ctxt, 43, 0LL);
    return 0LL;
  }

  return (xmlChar *)v7;
}

void xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  xmlParserInputPtr input = ctxt->input;
  int line = input->line;
  int col = input->col;
  if (!ctxt->progressive)
  {
    cur = input->cur;
    if (cur - input->base < 501
      || input->end - cur > 499
      || (xmlSHRINK((uint64_t)ctxt), xmlParserInputPtr input = ctxt->input, !ctxt->progressive))
    {
      if (input->end - input->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        xmlParserInputPtr input = ctxt->input;
      }
    }
  }

  if (!cdata)
  {
    xmlParserInputState v25 = input->cur;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v26 = *v25;
          if ((_DWORD)v26 != 10) {
            break;
          }
          int v27 = input->line + 1;
          do
          {
            input->int line = v27;
            input->int col = 1;
            int v28 = *++v25;
            ++v27;
          }

          while (v28 == 10);
        }

        if (v26 != 32) {
          break;
        }
        ++v25;
        ++input->col;
      }

      if (v26 == 60)
      {
        uint64_t v48 = (unsigned __int8 *)input->cur;
        input->cur = v25;
        sax = ctxt->sax;
        if (!ctxt->sax) {
          return;
        }
        ignorableWhitespace = (void (*)(void, void, void))sax->ignorableWhitespace;
        if (ignorableWhitespace != (void (*)(void, void, void))sax->characters)
        {
          int v51 = areBlanks_0(ctxt, v48, (int)v25 - (int)v48, 1);
          int v52 = ctxt->sax;
          if (!v51)
          {
            characters = (void (*)(void, void, void))v52->characters;
            space = ctxt->space;
            if (*space == -1) {
              int *space = -2;
            }
            return;
          }

          ignorableWhitespace = (void (*)(void, void, void))v52->ignorableWhitespace;
        }

        if (ignorableWhitespace) {
          ignorableWhitespace(ctxt->userData, v48, ((_DWORD)v25 - (_DWORD)v48));
        }
        return;
      }

      int v29 = input->col;
      while (1)
      {
        while (1)
        {
          if (test_char_data[v26])
          {
            uint64_t v30 = v25;
            do
            {
              int v31 = *++v30;
              ++v29;
            }

            while (test_char_data[v31]);
          }

          else
          {
            uint64_t v30 = v25;
          }

          input->int col = v29;
          int v32 = *v30;
          if (v32 != 93) {
            break;
          }
          xmlParserInputState v25 = v30 + 1;
          if (v30[1] == 93 && v30[2] == 62)
          {
            xmlFatalErr(ctxt, 62, 0LL);
            if (ctxt->instate != XML_PARSER_EOF) {
              ctxt->input->cur = v25;
            }
            return;
          }

          input->int col = ++v29;
          uint64_t v26 = *v25;
        }

        if (v32 != 10) {
          break;
        }
        int v33 = input->line + 1;
        do
        {
          int v29 = 1;
          input->int line = v33;
          input->int col = 1;
          unsigned int v34 = *++v30;
          uint64_t v26 = v34;
          ++v33;
        }

        while (v34 == 10);
        xmlParserInputState v25 = v30;
      }

      int v35 = (unsigned __int8 *)input->cur;
      if ((int)v30 - (int)v35 >= 1)
      {
        int v36 = ctxt->sax;
        if (ctxt->sax)
        {
          p_characters = &v36->characters;
          signed int v37 = (void (*)(void, void, void))v36->characters;
          if ((char *)p_characters[1] == (char *)v37
            || ((v39 = *v35, BOOL v17 = v39 > 0x20, v40 = (1LL << v39) & 0x100002600LL, !v17) ? (v41 = v40 == 0) : (v41 = 1),
                v41))
          {
            if (v37)
            {
              v37(ctxt->userData, input->cur, ((_DWORD)v30 - (_DWORD)v35));
              xmlParserInputPtr input = ctxt->input;
              int v29 = input->col;
            }

            int line = input->line;
            int col = v29;
          }

          else
          {
            input->cur = v30;
            int v42 = areBlanks_0(ctxt, v35, (int)v30 - (int)v35, 0);
            uint64_t v43 = ctxt->sax;
            if (v42)
            {
              int v44 = (void (*)(void, void, void))v43->ignorableWhitespace;
              if (v44) {
                v44(ctxt->userData, v35, ((_DWORD)v30 - (_DWORD)v35));
              }
            }

            else
            {
              BOOL v45 = (void (*)(void, void, void))v43->characters;
              if (v45) {
                v45(ctxt->userData, v35, ((_DWORD)v30 - (_DWORD)v35));
              }
              uint64_t v46 = ctxt->space;
              if (*v46 == -1) {
                int *v46 = -2;
              }
            }

            xmlParserInputPtr input = ctxt->input;
            int line = input->line;
            int col = input->col;
          }
        }

        if (ctxt->instate == XML_PARSER_EOF) {
          return;
        }
      }

      input->cur = v30;
      int v47 = *v30;
      if (v47 != 13) {
        break;
      }
      if (v30[1] != 10) {
        goto LABEL_117;
      }
      input->cur = v30 + 1;
      xmlParserInputState v25 = v30 + 2;
      ++input->line;
      input->int col = 1;
LABEL_125:
    }

    if (v47 == 38 || v47 == 60) {
      return;
    }
LABEL_117:
    if (!ctxt->progressive)
    {
      if (v30 - input->base < 501 || input->end - v30 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }

    if (ctxt->instate == XML_PARSER_EOF) {
      return;
    }
    xmlParserInputPtr input = ctxt->input;
    xmlParserInputState v25 = input->cur;
    goto LABEL_125;
  }

uint64_t areBlanks_0(void *a1, unsigned __int8 *a2, int a3, int a4)
{
  if (*(void *)(*a1 + 144LL) == *(void *)(*a1 + 136LL)) {
    return 0LL;
  }
  int v5 = (int *)a1[46];
  if (!v5) {
    return 0LL;
  }
  int v6 = *v5;
  if (v6 == -2 || v6 == 1) {
    return 0LL;
  }
  if (!a4 && a3 >= 1)
  {
    uint64_t v9 = a3;
    do
    {
      unsigned int v10 = *a2++;
      uint64_t v11 = (1LL << v10) & 0x100002600LL;
      if (v10 > 0x20 || v11 == 0) {
        return 0LL;
      }
    }

    while (--v9);
  }

  uint64_t v13 = a1[10];
  if (!v13) {
    return 0LL;
  }
  xmlParserInputPtr v14 = (xmlDoc *)a1[2];
  if (!v14)
  {
LABEL_21:
    xmlParserInputPtr v16 = *(unsigned __int8 **)(a1[7] + 32LL);
    int v17 = *v16;
    if (v17 == 60 || v17 == 13)
    {
      uint64_t v19 = (const xmlNode *)a1[10];
      BOOL v20 = v17 == 60 && v19->children == 0LL;
      if (!v20 || v16[1] != 47)
      {
        xmlNodePtr LastChild = xmlGetLastChild(v19);
        if (LastChild)
        {
          if (!xmlNodeIsText(LastChild))
          {
            xmlParserInputPtr v22 = *(const xmlNode **)(a1[10] + 24LL);
            if (!v22 || !xmlNodeIsText(v22)) {
              return 1LL;
            }
          }
        }

        else
        {
          uint64_t v23 = a1[10];
          if (*(_DWORD *)(v23 + 8) == 1 || !*(void *)(v23 + 80)) {
            return 1LL;
          }
        }
      }
    }

    return 0LL;
  }

  int IsMixedElement = xmlIsMixedElement(v14, *(const xmlChar **)(v13 + 16));
  if (IsMixedElement)
  {
    if (IsMixedElement == 1) {
      return 0LL;
    }
    goto LABEL_21;
  }

  return 1LL;
}

xmlChar *__cdecl xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict)
{
  if (!ctxt->progressive)
  {
    xmlParserInputPtr input = ctxt->input;
    cur = input->cur;
    if (cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }

  *publicID = 0LL;
  xmlParserInputPtr v8 = ctxt->input;
  uint64_t v9 = v8->cur;
  int v10 = *v9;
  if (v10 == 80)
  {
    if (v9[1] != 85 || v9[2] != 66 || v9[3] != 76 || v9[4] != 73 || v9[5] != 67) {
      return 0LL;
    }
    v8->cur = v9 + 6;
    v8->col += 6;
    if (!v9[6]) {
      xmlParserInputGrow(v8, 250);
    }
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65);
    }
    int v12 = xmlParsePubidLiteral(ctxt);
    *publicID = v12;
    if (!v12) {
      xmlFatalErr(ctxt, 71, 0LL);
    }
    int v13 = xmlSkipBlankChars(ctxt);
    if (strict)
    {
      if (v13) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }

    if (!v13) {
      return 0LL;
    }
    int v15 = *ctxt->input->cur;
    if (v15 != 39 && v15 != 34) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    if (v10 != 83) {
      return v11;
    }
    if (v9[1] != 89 || v9[2] != 83 || v9[3] != 84 || v9[4] != 69 || v9[5] != 77) {
      return 0LL;
    }
    v8->cur = v9 + 6;
    v8->col += 6;
    if (!v9[6]) {
      xmlParserInputGrow(v8, 250);
    }
    if (!xmlSkipBlankChars(ctxt)) {
LABEL_29:
    }
      xmlFatalErrMsg(ctxt, 65);
  }

void xmlParseComment(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    unint64_t v2 = 1000000000LL;
  }
  else {
    unint64_t v2 = 10000000LL;
  }
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60 || cur[1] != 33 || cur[2] != 45 || cur[3] != 45) {
    return;
  }
  xmlParserInputState instate = ctxt->instate;
  ctxt->xmlParserInputState instate = XML_PARSER_COMMENT;
  int id = input->id;
  input->cur = cur + 4;
  input->col += 4;
  if (!cur[4])
  {
    xmlParserInputGrow(input, 250);
    xmlParserInputPtr input = ctxt->input;
  }

  xmlParserInputState v34 = instate;
  if (!ctxt->progressive)
  {
    uint64_t v7 = input->cur;
    if (v7 - input->base < 501
      || input->end - v7 > 499
      || (xmlSHRINK((uint64_t)ctxt), xmlParserInputPtr input = ctxt->input, !ctxt->progressive))
    {
      if (input->end - input->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        xmlParserInputPtr input = ctxt->input;
      }
    }
  }

  xmlParserInputPtr v8 = 0LL;
  unint64_t v9 = 0LL;
  int v10 = input->cur;
  int v11 = *v10;
  size_t v12 = 100LL;
LABEL_17:
  if (v11 == 10)
  {
    int v13 = input->line + 1;
    do
    {
      input->int line = v13;
      input->int col = 1;
      int v14 = *++v10;
      ++v13;
    }

    while (v14 == 10);
  }

  while (1)
  {
    while (1)
    {
      int col = input->col;
      while (1)
      {
        while (1)
        {
          if (*(char *)v10 <= 45)
          {
            int v16 = *v10;
          }

          ++v10;
          ++col;
        }

        input->int col = col;
        int v18 = *v10;
        if (v18 != 10) {
          break;
        }
        int v19 = input->line + 1;
        do
        {
          int col = 1;
          input->int line = v19;
          input->int col = 1;
          int v20 = *++v10;
          ++v19;
        }

        while (v20 == 10);
      }

      xmlParserInputState v21 = (unsigned __int8 *)input->cur;
      size_t v22 = v10 - v21;
      if (v10 != v21 && ctxt->sax && ctxt->sax->comment)
      {
        if (v8)
        {
          if (v22 + v9 + 1 >= v12)
          {
            v12 += v22 + v9 + 100;
            uint64_t v23 = (char *)xmlRealloc(v8, v12);
            if (!v23)
            {
              xmlFree(v8);
LABEL_88:
              htmlErrMemory(ctxt, 0LL);
              goto LABEL_89;
            }

            xmlParserInputPtr v8 = v23;
          }
        }

        else
        {
          if (v18 == 45 && v10[1] == 45) {
            uint64_t v24 = 1LL;
          }
          else {
            uint64_t v24 = 100LL;
          }
          size_t v12 = v22 + v24;
          xmlParserInputState v25 = (char *)xmlMallocAtomic(v22 + v24);
          if (!v25) {
            goto LABEL_88;
          }
          xmlParserInputPtr v8 = v25;
          unint64_t v9 = 0LL;
        }

        memcpy(&v8[v9], ctxt->input->cur, v22);
        v9 += v22;
        v8[v9] = 0;
      }

      if (v9 > v2)
      {
        xmlFatalErrMsgStr(ctxt, 45, (uint64_t)"Comment too big found", 0LL);
LABEL_75:
        xmlFree(v8);
        return;
      }

      xmlParserInputPtr input = ctxt->input;
      input->cur = v10;
      int v26 = *v10;
      int v27 = (unsigned __int8 *)v10;
      if (v26 == 10)
      {
        ++input->line;
        input->int col = 1;
        int v27 = (unsigned __int8 *)(v10 + 1);
        int v26 = v10[1];
      }

      if (v26 != 13 || v27[1] != 10) {
        break;
      }
      input->cur = v27 + 1;
      int v10 = v27 + 2;
      ++input->line;
      input->int col = 1;
    }

    if (!ctxt->progressive)
    {
      if (v10 - input->base < 501 || input->end - v10 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
      {
        if (ctxt->input->end - ctxt->input->cur <= 249) {
          xmlGROW((uint64_t)ctxt);
        }
      }
    }

    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_75;
    }
    xmlParserInputPtr input = ctxt->input;
    int v10 = input->cur;
    int v11 = *v10;
    if (v11 != 45)
    {
      xmlParseCommentComplex((uint64_t)ctxt, v8, v9, v12);
      goto LABEL_85;
    }

    if (v10[1] != 45)
    {
      int v30 = input->col;
      goto LABEL_67;
    }

    if (v10[2] == 62) {
      break;
    }
    if (v8)
    {
      int v28 = "Double hyphen within comment: <!--%.50s\n";
      uint64_t v29 = (uint64_t)v8;
    }

    else
    {
      int v28 = "Double hyphen within comment\n";
      uint64_t v29 = 0LL;
    }

    xmlFatalErrMsgStr(ctxt, 80, (uint64_t)v28, v29);
    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_75;
    }
    xmlParserInputPtr input = ctxt->input;
    int v30 = input->col + 1;
    input->int col = v30;
    ++v10;
LABEL_67:
    ++v10;
    input->int col = v30 + 1;
  }

  if (input->id != id)
  {
    xmlFatalErrMsg(ctxt, 90);
    xmlParserInputPtr input = ctxt->input;
    int v10 = input->cur;
  }

  input->cur = v10 + 3;
  input->col += 3;
  if (!v10[3]) {
    xmlParserInputGrow(input, 250);
  }
  if (!ctxt->sax || (commentSAXFunc comment = ctxt->sax->comment) == 0LL || ctxt->disableSAX)
  {
    if (!v8) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }

  userData = ctxt->userData;
  if (v8)
  {
    ((void (*)(void *, char *))comment)(userData, v8);
LABEL_84:
    xmlFree(v8);
    goto LABEL_85;
  }

  ((void (*)(void *, char *))comment)(userData, &byte_181A3ACBA);
LABEL_85:
  if (ctxt->instate == XML_PARSER_EOF) {
    return;
  }
LABEL_89:
  ctxt->xmlParserInputState instate = v34;
}

void xmlParseCommentComplex(uint64_t a1, _BYTE *a2, unint64_t a3, size_t a4)
{
  int v6 = a2;
  if ((*(_BYTE *)(a1 + 566) & 8) != 0) {
    unint64_t v8 = 1000000000LL;
  }
  else {
    unint64_t v8 = 10000000LL;
  }
  int v9 = *(_DWORD *)(*(void *)(a1 + 56) + 100LL);
  if (!a2)
  {
    a4 = 100LL;
    int v10 = xmlMallocAtomic(0x64uLL);
    if (!v10)
    {
      htmlErrMemory((_DWORD *)a1, 0LL);
      return;
    }

    int v6 = v10;
    a3 = 0LL;
  }

  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  *(void *)int len = 0LL;
  int v42 = 0;
  int v11 = xmlCurrentChar((xmlParserCtxtPtr)a1, &len[1]);
  if (!v11) {
    goto LABEL_89;
  }
  int v12 = v11;
  if (v11 > 255)
  {
    if ((v11 - 0x10000) >= 0x100000
      && v11 >> 11 >= 0x1B
      && (v11 - 57344) >> 1 >= 0xFFF)
    {
LABEL_34:
      int v18 = (_DWORD *)a1;
      int v19 = v12;
LABEL_35:
      xmlFatalErrMsgInt(v18, 9, (uint64_t)"xmlParseComment: invalid xmlChar value %d\n", v19);
      goto LABEL_92;
    }
  }

  else if (v11 <= 31 && (v11 > 0xD || ((1 << v11) & 0x2600) == 0))
  {
    goto LABEL_34;
  }

  uint64_t v13 = *(void *)(a1 + 56);
  int v14 = *(_BYTE **)(v13 + 32);
  int v15 = &v14[len[1]];
  if ((unint64_t)v15 <= *(void *)(v13 + 40))
  {
    if (*v14 == 10)
    {
      ++*(_DWORD *)(v13 + 52);
      *(_DWORD *)(v13 + 56) = 1;
    }

    else
    {
      ++*(_DWORD *)(v13 + 56);
    }

    *(void *)(v13 + 32) = v15;
  }

  int v16 = xmlCurrentChar((xmlParserCtxtPtr)a1, len);
  if (!v16) {
    goto LABEL_89;
  }
  int v17 = v16;
  if (v16 > 255)
  {
    if ((v16 - 0x10000) >= 0x100000
      && v16 >> 11 >= 0x1B
      && (v16 - 57344) >> 1 >= 0xFFF)
    {
      goto LABEL_34;
    }
  }

  else if (v16 <= 31 && (v16 > 0xD || ((1 << v16) & 0x2600) == 0))
  {
    goto LABEL_34;
  }

  uint64_t v20 = *(void *)(a1 + 56);
  xmlParserInputState v21 = *(_BYTE **)(v20 + 32);
  size_t v22 = &v21[len[0]];
  if ((unint64_t)v22 <= *(void *)(v20 + 40))
  {
    if (*v21 == 10)
    {
      ++*(_DWORD *)(v20 + 52);
      *(_DWORD *)(v20 + 56) = 1;
    }

    else
    {
      ++*(_DWORD *)(v20 + 56);
    }

    *(void *)(v20 + 32) = v22;
  }

  int v23 = xmlCurrentChar((xmlParserCtxtPtr)a1, &v42);
  if (!v23)
  {
LABEL_89:
    uint64_t v38 = "Comment not terminated\n";
LABEL_90:
    unsigned int v39 = (_DWORD *)a1;
    uint64_t v40 = 0LL;
    goto LABEL_91;
  }

  int v24 = v23;
  unint64_t v25 = 0LL;
  while (1)
  {
    if (v24 > 255)
    {
      if ((v24 - 0x10000) >= 0x100000
        && v24 >> 11 >= 0x1B
        && (v24 - 57344) >> 1 >= 0xFFF)
      {
        v6[a3] = 0;
LABEL_93:
        int v18 = (_DWORD *)a1;
        int v19 = v24;
        goto LABEL_35;
      }

      goto LABEL_55;
    }

    if (v24 <= 31) {
      break;
    }
    if (v12 == 45 && v17 == 45 && v24 == 62)
    {
      v6[a3] = 0;
      if (v9 != *(_DWORD *)(*(void *)(a1 + 56) + 100LL)) {
        xmlFatalErrMsg((_DWORD *)a1, 90);
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
      if (*(void *)a1)
      {
        BOOL v41 = *(void (**)(void, _BYTE *))(*(void *)a1 + 160LL);
        if (v41)
        {
          if (!*(_DWORD *)(a1 + 332)) {
            v41(*(void *)(a1 + 8), v6);
          }
        }
      }

      goto LABEL_92;
    }

const xmlChar *__cdecl xmlParsePITarget(xmlParserCtxtPtr ctxt)
{
  unint64_t v2 = xmlParseName(ctxt);
  signed int v3 = v2;
  if (v2)
  {
    int v4 = *v2;
    if ((v4 | 0x20) == 0x78 && (int v5 = v2[1], (v5 | 0x20) == 0x6D) && (v6 = v2[2], (v6 | 0x20) == 0x6C))
    {
      if (v4 == 120 && v5 == 109 && v6 == 108)
      {
        if (!v2[3])
        {
          xmlFatalErrMsg(ctxt, 64);
          return v3;
        }
      }

      else if (!v2[3])
      {
        xmlFatalErr(ctxt, 64, 0LL);
        return v3;
      }

      uint64_t v7 = 0LL;
      while (!xmlStrEqual(v3, (const xmlChar *)xmlW3CPIs[v7]))
      {
        if (++v7 == 2)
        {
          xmlWarningMsg((uint64_t *)ctxt, 64, (uint64_t)"xmlParsePITarget: invalid name prefix 'xml'\n", 0LL);
          goto LABEL_15;
        }
      }
    }

    else
    {
LABEL_15:
      if (xmlStrchr(v3, 0x3Au)) {
        xmlNsErr(ctxt, 205, (uint64_t)"colons are forbidden from PI names '%s'\n", (uint64_t)v3, 0LL, 0LL);
      }
    }
  }

  return v3;
}

_DWORD *xmlNsErr(_DWORD *result, int a2, uint64_t a3, uint64_t a4, xmlChar *a5, xmlChar *a6)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 3, a2, 2, 0LL, 0, a4, a5, a6, 0, 0, a3);
  }
  int v6 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    __n128 result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 3, a2, 2, 0LL, 0, a4, a5, a6, 0, 0, a3);
    v6[140] = 0;
  }

  return result;
}

void xmlParsePI(xmlParserCtxtPtr ctxt)
{
  if ((ctxt->options & 0x80000) != 0) {
    unint64_t v2 = 1000000000LL;
  }
  else {
    unint64_t v2 = 10000000LL;
  }
  int len = 0;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60 && cur[1] == 63)
  {
    int id = input->id;
    xmlParserInputState instate = ctxt->instate;
    ctxt->xmlParserInputState instate = XML_PARSER_PI;
    input->cur = cur + 2;
    input->col += 2;
    if (!cur[2]) {
      xmlParserInputGrow(input, 250);
    }
    if (!ctxt->progressive)
    {
      xmlParserInputPtr v7 = ctxt->input;
      unint64_t v8 = v7->cur;
      if (v8 - v7->base >= 501 && v7->end - v8 <= 499) {
        xmlSHRINK((uint64_t)ctxt);
      }
    }

    int v9 = xmlParsePITarget(ctxt);
    if (v9)
    {
      int v10 = v9;
      xmlParserInputPtr v11 = ctxt->input;
      int v12 = v11->cur;
      if (*v12 != 63 || v12[1] != 62)
      {
        int v14 = xmlMallocAtomic(0x64uLL);
        if (v14)
        {
          int v15 = v14;
          int v31 = id;
          xmlParserInputState v32 = instate;
          if (!xmlSkipBlankChars(ctxt)) {
            xmlFatalErrMsgStr(ctxt, 65, (uint64_t)"ParsePI: PI %s space expected\n", (uint64_t)v10);
          }
          int v16 = xmlCurrentChar(ctxt, &len);
          unint64_t v17 = 0LL;
          int v18 = 0;
          size_t v19 = 100LL;
          while (1)
          {
            if (v16 > 255)
            {
              if ((v16 - 0x10000) >= 0x100000
                && v16 >> 11 >= 0x1B
                && (v16 - 57344) >> 1 >= 0xFFF)
              {
LABEL_74:
                v15[v17] = 0;
                xmlFatalErrMsgStr(ctxt, 47, (uint64_t)"ParsePI: PI %s never end ...\n", (uint64_t)v10);
                xmlParserInputState instate = v32;
LABEL_75:
                xmlFree(v15);
                goto LABEL_70;
              }
            }

            else if (v16 <= 31)
            {
            }

            else if (v16 == 63 && *((_BYTE *)ctxt->input->cur + 1) == 62)
            {
              v15[v17] = 0;
              xmlParserInputPtr v28 = ctxt->input;
              if (v31 != v28->id)
              {
                xmlFatalErrMsg(ctxt, 90);
                xmlParserInputPtr v28 = ctxt->input;
              }

              uint64_t v29 = v28->cur;
              v28->cur = v29 + 2;
              v28->col += 2;
              xmlParserInputState instate = v32;
              if (!v29[2]) {
                xmlParserInputGrow(v28, 250);
              }
              if (v32 <= XML_PARSER_MISC
                && xmlStrEqual(v10, (const xmlChar *)"oasis-xml-catalog")
                && (xmlCatalogGetDefaults() & 0xFFFFFFFE) == 2)
              {
                xmlParseCatalogPI((uint64_t)ctxt, v15);
              }

              if (ctxt->sax)
              {
                if (!ctxt->disableSAX)
                {
                  processingInstructionSAXFunc processingInstruction = ctxt->sax->processingInstruction;
                  if (processingInstruction) {
                    ((void (*)(void *, const xmlChar *, _BYTE *))processingInstruction)( ctxt->userData,  v10,  v15);
                  }
                }
              }

              goto LABEL_75;
            }

            if (v17 + 5 >= v19)
            {
              v19 *= 2LL;
              uint64_t v20 = xmlRealloc(v15, v19);
              if (!v20)
              {
                htmlErrMemory(ctxt, 0LL);
                goto LABEL_77;
              }

              int v15 = v20;
            }

            if (v18 < 50)
            {
              ++v18;
            }

            else
            {
              if (!ctxt->progressive)
              {
                xmlParserInputPtr v21 = ctxt->input;
                size_t v22 = v21->cur;
                if (v22 - v21->base < 501 || v21->end - v22 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
                {
                  if (ctxt->input->end - ctxt->input->cur <= 249) {
                    xmlGROW((uint64_t)ctxt);
                  }
                }
              }

              if (ctxt->instate == XML_PARSER_EOF)
              {
                xmlFree(v15);
                return;
              }

              int v18 = 0;
            }

            if (len == 1) {
              v15[v17++] = v16;
            }
            else {
              v17 += xmlCopyCharMultiByte(&v15[v17], v16);
            }
            xmlParserInputPtr v23 = ctxt->input;
            int v24 = v23->cur;
            unint64_t v25 = &v24[len];
            if (v25 <= v23->end)
            {
              if (*v24 == 10)
              {
                ++v23->line;
                v23->int col = 1;
              }

              else
              {
                ++v23->col;
              }

              v23->cur = v25;
            }

            int v16 = xmlCurrentChar(ctxt, &len);
            if (!v16)
            {
              if (!ctxt->progressive)
              {
                xmlParserInputPtr v26 = ctxt->input;
                int v27 = v26->cur;
                if (v27 - v26->base < 501 || v26->end - v27 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
                {
                  if (ctxt->input->end - ctxt->input->cur <= 249) {
                    xmlGROW((uint64_t)ctxt);
                  }
                }
              }

              int v16 = xmlCurrentChar(ctxt, &len);
            }

            if (v17 > v2)
            {
              xmlFatalErrMsgStr(ctxt, 47, (uint64_t)"PI %s too big found", (uint64_t)v10);
LABEL_77:
              xmlFree(v15);
              ctxt->xmlParserInputState instate = v32;
              return;
            }
          }
        }

        htmlErrMemory(ctxt, 0LL);
LABEL_73:
        ctxt->xmlParserInputState instate = instate;
        return;
      }

      if (id != v11->id)
      {
        xmlFatalErrMsg(ctxt, 90);
        xmlParserInputPtr v11 = ctxt->input;
        int v12 = v11->cur;
      }

      v11->cur = v12 + 2;
      v11->col += 2;
      if (!v12[2]) {
        xmlParserInputGrow(v11, 250);
      }
      if (ctxt->sax && !ctxt->disableSAX)
      {
        processingInstructionSAXFunc v13 = ctxt->sax->processingInstruction;
        if (v13) {
          ((void (*)(void *, const xmlChar *, void))v13)(ctxt->userData, v10, 0LL);
        }
      }
    }

    else
    {
      xmlFatalErr(ctxt, 46, 0LL);
    }

LABEL_70:
    if (ctxt->instate == XML_PARSER_EOF) {
      return;
    }
    goto LABEL_73;
  }

    *(_DWORD *)(a1 + 272) = 7;
    if (name2 == *(xmlChar **)(a1 + 480))
    {
      if (*(_DWORD *)(a1 + 420) && xmlStrEqual(v26, (const xmlChar *)"lang"))
      {
        int v44 = xmlStrndup(v30, len);
        if (!xmlCheckLanguageID(v44)) {
          xmlWarningMsg((uint64_t *)a1, 98, (uint64_t)"Malformed value for xml:lang : %s\n", (uint64_t)v44);
        }
      }

      else
      {
        int v44 = 0LL;
      }

      if (xmlStrEqual(v26, (const xmlChar *)"space"))
      {
        int v44 = xmlStrndup(v30, len);
        if (xmlStrEqual(v44, (const xmlChar *)"default"))
        {
          **(_DWORD **)(a1 + 368) = 0;
        }

        else if (xmlStrEqual(v44, (const xmlChar *)"preserve"))
        {
          **(_DWORD **)(a1 + 368) = 1;
        }

        else
        {
          xmlWarningMsg( (uint64_t *)a1,  102,  (uint64_t)"Invalid value %s for xml:space : default or preserve expected\n",  (uint64_t)v44);
        }
      }

      if (v44) {
        ((void (*)(xmlChar *))*v18)(v44);
      }
    }

    if (v30)
    {
      BOOL v45 = v18;
      uint64_t v46 = len;
      if (len < 0)
      {
        uint64_t v46 = xmlStrlen(v30);
        int len = v46;
      }

      int v47 = *(xmlChar **)(a1 + 488);
      if (v26 == v47 && !name2)
      {
        uint64_t v48 = (const char *)xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v30, v46);
        if (!v48)
        {
          htmlErrMemory((_DWORD *)a1, (uint64_t)"dictionary allocation failure");
          int v18 = v45;
          if (v136) {
            ((void (*)(const xmlChar *))*v45)(v30);
          }
          int v16 = 0LL;
LABEL_270:
          int v73 = v133;
          goto LABEL_258;
        }

        int v49 = (const xmlChar *)v48;
        int v18 = v45;
        if (!*v48) {
          goto LABEL_115;
        }
        int v50 = xmlParseURI(v48);
        if (v50)
        {
          int v51 = v50;
          if (!v50->scheme) {
            xmlNsWarn((_DWORD *)a1, "xmlns: URI %s is not absolute\n", v49, 0LL);
          }
          xmlFreeURI(v51);
        }

        else
        {
          xmlNsErr((_DWORD *)a1, 99, (uint64_t)"xmlns: '%s' is not a valid URI\n", (uint64_t)v49, 0LL, 0LL);
        }

        int v18 = v45;
        if (v49 != *v135)
        {
          if (len == 29 && xmlStrEqual(v49, (const xmlChar *)"http://www.w3.org/2000/xmlns/"))
          {
            charactersSAXFunc v59 = (_DWORD *)a1;
            int v60 = "reuse of the xmlns namespace name is forbidden\n";
LABEL_129:
            xmlNsErr(v59, 200, (uint64_t)v60, 0LL, 0LL, 0LL);
            goto LABEL_142;
          }

        int v33 = v50;
        if (v50)
        {
          while (1)
          {
            int v33 = (uint64_t *)*v33;
            if (!v33) {
              break;
            }
            if (*((_DWORD *)v33 + 8) == -1 && i->ns == (xmlNs *)v33[2])
            {
              p_nsDef = (xmlNs **)(v33 + 3);
              goto LABEL_77;
            }
          }
        }

        p_nsDef = &nsDef;
        if (xmlDOMWrapNSNormAcquireNormalizedNs( (uint64_t)doc,  v8,  (uint64_t)i->ns,  (uint64_t *)&nsDef,  &v50,  v9,  i->type == XML_ATTRIBUTE_NODE) == -1) {
          int v5 = -1;
        }
LABEL_77:
        i->ns = *p_nsDef;
      }

        if (*((_DWORD *)reader + 4) && *(_DWORD *)(v8 + 8) == 1)
        {
          xmlTextReaderValidatePop((uint64_t)reader);
          unint64_t v8 = *((void *)reader + 14);
        }

        xmlParserInputPtr v26 = *((_DWORD *)reader + 80);
        int v27 = v26 - 1;
        if (v26 >= 1)
        {
          xmlParserInputPtr v26 = 1;
          if ((*(_WORD *)(v8 + 114) & 4) != 0)
          {
            *((_DWORD *)reader + 80) = v27;
            xmlParserInputPtr v26 = v27;
          }
        }

        xmlParserInputPtr v28 = *(void *)(v8 + 40);
        *((void *)reader + 14) = v28;
        if (!v28
          || ((uint64_t v29 = *(_DWORD *)(v28 + 8), v30 = v29 > 0x15, v31 = (1 << v29) & 0x202200, !v30)
            ? (xmlParserInputState v32 = v31 == 0)
            : (xmlParserInputState v32 = 1),
              !v32))
        {
          if (*(_DWORD *)reader != 3)
          {
            int v56 = xmlParseChunk(*((xmlParserCtxtPtr *)reader + 4), &byte_181A3ACBA, 0, 1);
            *((_DWORD *)reader + 6) = 5;
            if (v56) {
              return -1;
            }
          }

          *((void *)reader + 14) = 0LL;
          *((_DWORD *)reader + 32) = -1;
          if (v9
            && !*((_DWORD *)reader + 80)
            && !*((_DWORD *)reader + 74)
            && !*((_DWORD *)reader + 44)
            && *(_DWORD *)(v9 + 8) != 14
            && (*(_WORD *)(v9 + 114) & 2) == 0)
          {
            xmlUnlinkNode((xmlNodePtr)v9);
            xmlTextReaderFreeNode((uint64_t)reader, (xmlAttr *)v9);
          }

          xmlParserInputState v32 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)v24, (xmlChar *)"id");
          if (v32) {
            xmlSchemaPValAttrNodeID(a1, v32);
          }
          xmlNodePtr children = (uint64_t)v24->children;
          if (!children
            || *(void *)(children + 72)
            && xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"annotation")
            && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
            && (int v34 = xmlSchemaParseAnnotation((_DWORD *)a1, children, 1),
                xmlSchemaAddAnnotation(v29, (uint64_t)v34),
                (xmlNodePtr children = *(void *)(children + 48)) == 0))
          {
            xmlSchemaPContentErr( a1,  3034,  (uint64_t)v24,  0LL,  0LL,  (xmlChar *)"(annotation?, (restriction | extension))");
            xmlSchemaPContentErr( a1,  3034,  (uint64_t)v24,  0LL,  0LL,  (xmlChar *)"(annotation?, (restriction | extension))");
            uint64_t v48 = 0;
            unint64_t v8 = v59;
            int v4 = v57;
            goto LABEL_142;
          }

          if (*(void *)(children + 72))
          {
            if (xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"restriction")
              && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
            {
              xmlSchemaParseRestriction(a1, a2, children, 9);
              int v4 = v57;
              goto LABEL_122;
            }

            int v4 = v57;
            if (*(void *)(children + 72)
              && xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"extension")
              && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
            {
              xmlSchemaParseExtension(a1, a2, children, 9);
LABEL_122:
              xmlNodePtr children = *(void *)(children + 48);
              uint64_t v48 = 1;
              if (!children)
              {
LABEL_128:
                unint64_t v8 = v59;
                goto LABEL_142;
              }
            }

            else
            {
              uint64_t v48 = 0;
            }
          }

          else
          {
            uint64_t v48 = 0;
            int v4 = v57;
          }

          xmlSchemaPContentErr( a1,  3033,  (uint64_t)v24,  children,  0LL,  (xmlChar *)"(annotation?, (restriction | extension))");
          int v24 = next;
          goto LABEL_128;
        }

        int v27 = v24->ns;
      }

      if (v27
        && xmlStrEqual(v24->name, (const xmlChar *)"complexContent")
        && xmlStrEqual(v24->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        int v60 = v8;
        *(_DWORD *)(PropNode + 92) = 1;
        int v35 = *(void *)(a1 + 160);
        int v36 = (uint64_t)v24->properties;
        if (v36)
        {
          while (1)
          {
            uint64_t v37 = *(void *)(v36 + 72);
            if (!v37) {
              break;
            }
            if (xmlStrEqual(*(const xmlChar **)(v37 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
              goto LABEL_88;
            }
LABEL_91:
            int v36 = *(void *)(v36 + 48);
            if (!v36) {
              goto LABEL_92;
            }
          }

          if (xmlStrEqual(*(const xmlChar **)(v36 + 16), (const xmlChar *)"id")
            || xmlStrEqual(*(const xmlChar **)(v36 + 16), (const xmlChar *)"mixed"))
          {
            goto LABEL_91;
          }

    xmlParserInputPtr v21 = "failed to evaluate the item type";
LABEL_76:
    uint64_t v20 = "xmlSchemaCheckCOSSTRestricts";
    goto LABEL_27;
  }

  if ((v26 & 0x80) == 0) {
    goto LABEL_84;
  }
  xmlParserInputPtr v28 = &typeDecl->memberTypes;
  while (1)
  {
    xmlParserInputPtr v28 = (xmlSchemaTypeLinkPtr *)*v28;
    if (!v28) {
      break;
    }
    uint64_t v29 = v28[1];
    if (LODWORD(v29->next) != 1 && (BYTE2(v29[5].type) & 0x40) == 0)
    {
      xmlSchemaTypeFixup((uint64_t)v28[1], ctxt);
      uint64_t v29 = v28[1];
    }

    if (((uint64_t)v29[5].type & 0x140) == 0)
    {
      xmlSchemaGetComponentQName(&v58, (int *)v29);
      size_t v19 = "The member type '%s' is neither an atomic, nor a list type";
      uint64_t v30 = ctxt;
      int v31 = 3023;
      goto LABEL_56;
    }
  }

  uint64_t v37 = typeDecl->baseType;
  if (v37->builtInType != 46)
  {
    int v42 = v37->flags;
    if ((v42 & 0x80) != 0)
    {
      if ((v42 & 0x400) == 0)
      {
        uint64_t v46 = *p_memberTypes;
        if (*p_memberTypes)
        {
          do
          {
            if (v37->type != XML_SCHEMA_TYPE_SIMPLE) {
              break;
            }
            int v47 = v37->memberTypes;
            if (v47) {
              goto LABEL_129;
            }
            uint64_t v37 = v37->baseType;
          }

          while (v37);
          int v47 = 0LL;
          do
          {
LABEL_129:
            if (v47)
            {
              uint64_t v48 = (uint64_t)v46->type;
              a3 = (uint64_t)v47->type;
              if (v48 != a3 && xmlSchemaCheckCOSSTDerivedOK(ctxt, v48, a3, 0))
              {
                int v56 = 0LL;
                uint64_t v57 = 0LL;
                xmlSchemaGetComponentQName(&v58, (int *)v46->type);
                xmlSchemaGetComponentQName(&v57, (int *)v47->type);
                xmlSchemaGetComponentQName(&v56, (int *)typeDecl->baseType);
                int v52 = "The member type %s is not validly derived from its corresponding member type %s of the base type %s";
                xmlParserInputPtr v53 = ctxt;
                BOOL v54 = 3028;
LABEL_156:
                xmlSchemaPCustomErrExt((uint64_t)v53, v54, typeDecl, 0LL, (const xmlChar *)v52);
                if (v58) {
                  xmlFree(v58);
                }
                if (v57) {
                  xmlFree(v57);
                }
                xmlParserInputState v32 = v56;
                if (!v56)
                {
LABEL_58:
                  if (v7 == *((_DWORD *)ctxt + 9)) {
                    return 0LL;
                  }
                  else {
                    return *((unsigned int *)ctxt + 8);
                  }
                }

void xmlParseCatalogPI(uint64_t a1, xmlChar *str1)
{
  for (unint64_t i = str1; ; ++i)
  {
    unsigned int v5 = *i;
    BOOL v6 = v5 > 0x20;
    uint64_t v7 = (1LL << v5) & 0x100002600LL;
    if (v6 || v7 == 0) {
      break;
    }
  }

  if (xmlStrncmp(i, (const xmlChar *)"catalog", 7))
  {
LABEL_8:
    xmlWarningMsg((uint64_t *)a1, 93, (uint64_t)"Catalog PI syntax error: %s\n", (uint64_t)str1);
  }

  else
  {
    for (uint64_t j = i + 9; ; ++j)
    {
      uint64_t v10 = *(j - 2);
      if (((1LL << v10) & 0x100002600LL) == 0)
      {
        if (v10 != 61) {
          return;
        }
        while (1)
        {
          unsigned int v11 = *(j - 1);
          if (v11 > 0x27) {
            goto LABEL_8;
          }
          if (((1LL << v11) & 0x100002600LL) == 0)
          {
            if (((1LL << v11) & 0x8400000000LL) == 0) {
              goto LABEL_8;
            }
            int v12 = -1;
            processingInstructionSAXFunc v13 = j;
            do
            {
              int v15 = *v13++;
              int v14 = v15;
              ++v12;
              if (v15) {
                BOOL v16 = v14 == v11;
              }
              else {
                BOOL v16 = 1;
              }
            }

            while (!v16);
            if (!v14) {
              goto LABEL_8;
            }
            unint64_t v17 = xmlStrndup(j, v12);
            int v18 = v17;
            for (uint64_t k = 0LL; ; ++k)
            {
              unsigned int v20 = v13[k];
              if (v20 > 0x20) {
                break;
              }
              if (((1LL << v20) & 0x100002600LL) == 0)
              {
                if (!v13[k])
                {
                  if (!v17) {
                    return;
                  }
                  *(void *)(a1 + 440) = xmlCatalogAddLocal(*(void **)(a1 + 440), v17);
                  goto LABEL_33;
                }

                break;
              }
            }

            xmlWarningMsg((uint64_t *)a1, 93, (uint64_t)"Catalog PI syntax error: %s\n", (uint64_t)str1);
            if (!v18) {
              return;
            }
LABEL_33:
            xmlFree(v18);
            return;
          }

          ++j;
        }
      }
    }
  }

void xmlParseNotationDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 78
    && cur[3] == 79
    && cur[4] == 84
    && cur[5] == 65
    && cur[6] == 84
    && cur[7] == 73
    && cur[8] == 79
    && cur[9] == 78)
  {
    int id = input->id;
    input->cur = cur + 10;
    input->col += 10;
    if (!cur[10]) {
      xmlParserInputGrow(input, 250);
    }
    if (!ctxt->progressive)
    {
      xmlParserInputPtr v5 = ctxt->input;
      BOOL v6 = v5->cur;
      if (v6 - v5->base >= 501 && v5->end - v6 <= 499) {
        xmlSHRINK((uint64_t)ctxt);
      }
    }

    if (!xmlSkipBlankChars(ctxt)) {
      goto LABEL_31;
    }
    uint64_t v7 = xmlParseName(ctxt);
    if (!v7)
    {
      xmlFatalErr(ctxt, 48, 0LL);
      return;
    }

    uint64_t v8 = (uint64_t)v7;
    if (xmlStrchr(v7, 0x3Au)) {
      xmlNsErr(ctxt, 205, (uint64_t)"colons are forbidden from notation names '%s'\n", v8, 0LL, 0LL);
    }
    if (xmlSkipBlankChars(ctxt))
    {
      publicID = 0LL;
      int v9 = xmlParseExternalID(ctxt, &publicID, 0);
      xmlSkipBlankChars(ctxt);
      xmlParserInputPtr v10 = ctxt->input;
      if (*v10->cur == 62)
      {
        if (id != v10->id) {
          xmlFatalErrMsg(ctxt, 90);
        }
        xmlNextChar(ctxt);
        if (ctxt->sax)
        {
          if (!ctxt->disableSAX)
          {
            notationDeclSAXFunc notationDecl = ctxt->sax->notationDecl;
            if (notationDecl) {
              ((void (*)(void *, uint64_t, xmlChar *, xmlChar *))notationDecl)( ctxt->userData,  v8,  publicID,  v9);
            }
          }
        }
      }

      else
      {
        xmlFatalErr(ctxt, 49, 0LL);
      }

      if (v9) {
        xmlFree(v9);
      }
      if (publicID) {
        xmlFree(publicID);
      }
    }

    else
    {
LABEL_31:
      xmlFatalErrMsg(ctxt, 65);
    }
  }

void xmlParseEntityDecl(xmlParserCtxtPtr ctxt)
{
  int v36 = 0LL;
  publicID = 0LL;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 69
    || cur[3] != 78
    || cur[4] != 84
    || cur[5] != 73
    || cur[6] != 84
    || cur[7] != 89)
  {
    return;
  }

  int id = input->id;
  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8]) {
    xmlParserInputGrow(input, 250);
  }
  if (!ctxt->progressive)
  {
    xmlParserInputPtr v5 = ctxt->input;
    BOOL v6 = v5->cur;
    if (v6 - v5->base >= 501 && v5->end - v6 <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }

  if (!xmlSkipBlankChars(ctxt)) {
    xmlFatalErrMsg(ctxt, 65);
  }
  int v7 = *ctxt->input->cur;
  if (v7 == 37)
  {
    xmlNextChar(ctxt);
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65);
    }
  }

  uint64_t v8 = xmlParseName(ctxt);
  if (!v8)
  {
    xmlFatalErrMsg(ctxt, 68);
    return;
  }

  int v9 = v8;
  if (xmlStrchr(v8, 0x3Au)) {
    xmlNsErr(ctxt, 205, (uint64_t)"colons are forbidden from entities names '%s'\n", (uint64_t)v9, 0LL, 0LL);
  }
  if (!xmlSkipBlankChars(ctxt)) {
    xmlFatalErrMsg(ctxt, 65);
  }
  ctxt->xmlParserInputState instate = XML_PARSER_ENTITY_DECL;
  int v10 = *ctxt->input->cur;
  if (v7 == 37)
  {
    if (v10 == 39 || v10 == 34)
    {
      unsigned int v11 = xmlParseEntityValue(ctxt, &v36);
      if (v11)
      {
        if (ctxt->sax)
        {
          if (!ctxt->disableSAX)
          {
            entityDeclSAXFunc entityDecl = ctxt->sax->entityDecl;
            if (entityDecl) {
              ((void (*)(void *, const xmlChar *, uint64_t, void, void, xmlChar *))entityDecl)( ctxt->userData,  v9,  4LL,  0LL,  0LL,  v11);
            }
          }
        }
      }

      goto LABEL_48;
    }

    int v18 = xmlParseExternalID(ctxt, &publicID, 1);
    BOOL v16 = publicID;
    if (!((unint64_t)v18 | (unint64_t)publicID))
    {
      xmlFatalErr(ctxt, 84, 0LL);
      BOOL v16 = 0LL;
      unsigned int v11 = 0LL;
      goto LABEL_49;
    }

    unint64_t v17 = v18;
    if (v18)
    {
      xmlURIPtr v20 = xmlParseURI((const char *)v18);
      unsigned int v11 = (xmlChar *)v20;
      if (!v20)
      {
        xmlErrMsgStr(ctxt, 91, (uint64_t)"Invalid URI: %s\n", (uint64_t)v17);
        goto LABEL_97;
      }

      if (v20->fragment)
      {
        xmlFatalErr(ctxt, 92, 0LL);
      }

      else if (ctxt->sax)
      {
        if (!ctxt->disableSAX)
        {
          entityDeclSAXFunc v35 = ctxt->sax->entityDecl;
          if (v35) {
            ((void (*)(void *, const xmlChar *, uint64_t, xmlChar *, xmlChar *, void))v35)( ctxt->userData,  v9,  5LL,  v16,  v17,  0LL);
          }
        }
      }

      xmlFreeURI((xmlURIPtr)v11);
    }

LABEL_96:
    unsigned int v11 = 0LL;
    goto LABEL_97;
  }

  if (v10 != 39 && v10 != 34)
  {
    size_t v19 = xmlParseExternalID(ctxt, &publicID, 1);
    unint64_t v17 = v19;
    BOOL v16 = publicID;
    if ((unint64_t)v19 | (unint64_t)publicID)
    {
      if (v19)
      {
        xmlURIPtr v21 = xmlParseURI((const char *)v19);
        if (v21)
        {
          size_t v22 = v21;
          if (v21->fragment) {
            xmlFatalErr(ctxt, 92, 0LL);
          }
          xmlFreeURI(v22);
        }

        else
        {
          xmlErrMsgStr(ctxt, 91, (uint64_t)"Invalid URI: %s\n", (uint64_t)v17);
        }
      }
    }

    else
    {
      xmlFatalErr(ctxt, 84, 0LL);
    }

    if (*ctxt->input->cur != 62 && !xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65);
    }
    xmlParserInputPtr v23 = ctxt->input;
    int v24 = v23->cur;
    if (*v24 == 78 && v24[1] == 68 && v24[2] == 65 && v24[3] == 84 && v24[4] == 65)
    {
      v23->cur = v24 + 5;
      v23->col += 5;
      if (!v24[5]) {
        xmlParserInputGrow(v23, 250);
      }
      if (!xmlSkipBlankChars(ctxt)) {
        xmlFatalErrMsg(ctxt, 65);
      }
      unint64_t v25 = xmlParseName(ctxt);
      if (ctxt->sax)
      {
        if (!ctxt->disableSAX)
        {
          unparsedEntityDeclSAXFunc unparsedEntityDecl = ctxt->sax->unparsedEntityDecl;
          if (unparsedEntityDecl) {
            ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *, const xmlChar *))unparsedEntityDecl)( ctxt->userData,  v9,  v16,  v17,  v25);
          }
        }
      }

      goto LABEL_96;
    }

    if (ctxt->sax)
    {
      if (!ctxt->disableSAX)
      {
        entityDeclSAXFunc v27 = ctxt->sax->entityDecl;
        if (v27) {
          ((void (*)(void *, const xmlChar *, uint64_t, xmlChar *, xmlChar *, void))v27)( ctxt->userData,  v9,  2LL,  v16,  v17,  0LL);
        }
      }
    }

    if (!ctxt->replaceEntities) {
      goto LABEL_96;
    }
    xmlDocPtr myDoc = ctxt->myDoc;
    if (!myDoc) {
      goto LABEL_91;
    }
    if (!xmlStrEqual(myDoc->version, (const xmlChar *)"SAX compatibility mode document")) {
      goto LABEL_96;
    }
    xmlDocPtr v29 = ctxt->myDoc;
    if (!v29)
    {
LABEL_91:
      xmlDocPtr v29 = xmlNewDoc((const xmlChar *)"SAX compatibility mode document");
      ctxt->xmlDocPtr myDoc = v29;
      if (!v29)
      {
        htmlErrMemory(ctxt, (uint64_t)"New Doc failed");
        return;
      }

      v29->int properties = 64;
    }

    xmlSAX2EntityDecl(ctxt, v9, 2, v16, v17, 0LL);
    goto LABEL_96;
  }

  unsigned int v11 = xmlParseEntityValue(ctxt, &v36);
  if (ctxt->sax)
  {
    if (!ctxt->disableSAX)
    {
      entityDeclSAXFunc v13 = ctxt->sax->entityDecl;
      if (v13) {
        ((void (*)(void *, const xmlChar *, uint64_t, void, void, xmlChar *))v13)( ctxt->userData,  v9,  1LL,  0LL,  0LL,  v11);
      }
    }
  }

  xmlDocPtr v14 = ctxt->myDoc;
  if (!v14) {
    goto LABEL_43;
  }
  if (xmlStrEqual(v14->version, (const xmlChar *)"SAX compatibility mode document"))
  {
    xmlDocPtr v15 = ctxt->myDoc;
    if (v15)
    {
LABEL_45:
      xmlSAX2EntityDecl(ctxt, v9, 1, 0LL, 0LL, v11);
      goto LABEL_48;
    }

        xmlRngPErr(a1, *((void *)v6 + 1), 1088, "Found forbidden pattern start//attribute\n", 0LL, 0LL);
        if ((a3 & 2) != 0) {
          goto LABEL_170;
        }
LABEL_97:
        if (!*((void *)v6 + 2) && !*((void *)v6 + 10))
        {
          if (*((void *)v6 + 3))
          {
            int v34 = 1056;
            entityDeclSAXFunc v35 = "Found nsName attribute without oneOrMore ancestor\n";
          }

          else
          {
            int v34 = 1000;
            entityDeclSAXFunc v35 = "Found anyName attribute without oneOrMore ancestor\n";
          }

          xmlRngPErr(a1, *((void *)v6 + 1), v34, v35, 0LL, 0LL);
        }

            v7->path[v32] = 0;
            uint64_t v38 = v6->path;
            if (v38)
            {
              unsigned int v39 = *v38;
              if (v39)
              {
                if (v32) {
                  goto LABEL_99;
                }
                if (v8->server)
                {
                  *v7->path = 47;
                  LOBYTE(v39) = *v6->path;
                  xmlParserInputState v32 = 1;
                  if (!(_BYTE)v39) {
                    goto LABEL_102;
                  }
                }

                else
                {
                  xmlParserInputState v32 = 0;
                }

    if (v29 != *(_DWORD *)(a1 + 36)) {
      goto LABEL_157;
    }
    if (!v17) {
      break;
    }
    if (!v80) {
      goto LABEL_146;
    }
    uint64_t v46 = xmlSchemaAddAttributeUse(a1, v13);
    if (v46)
    {
      int v44 = (uint64_t)v46;
      xmlSchemaAddItemSize((void **)(*(void *)(a1 + 48) + 40LL), 10, (uint64_t)v46);
      *(_DWORD *)(v44 + 48) = v80;
      int v47 = xmlSchemaNewQNameRef(a1, 15, (uint64_t)v86, (uint64_t)str2);
      if (v47)
      {
        *(void *)(v44 + 24) = v47;
        if (v77) {
          *(void *)(v44 + 56) = v77;
        }
        if (v79 == 2)
        {
          uint64_t v48 = (_DWORD *)(v44 + 32);
          int v49 = 1;
          goto LABEL_105;
        }

        goto LABEL_106;
      }
    }

LABEL_116:
  if (v11) {
    xmlFree(v11);
  }
  if (v17) {
    xmlFree(v17);
  }
  if (v16) {
    xmlFree(v16);
  }
  if (v36) {
    xmlFree(v36);
  }
}

        uint64_t v48 = *(int *)(v10 + 88) + ctxt->sizeentcopy + 5;
        ctxt->sizeentcopy = v48;
        int v49 = *(xmlNode **)(v10 + 24);
        int v50 = *(xmlNode **)(v10 + 32);
        *(void *)(v10 + 24) = 0LL;
        *(void *)(v10 + 32) = 0LL;
        if (v49)
        {
          int v51 = 0LL;
          do
          {
            int v52 = v49->next;
            v49->parent = 0LL;
            v49->next = 0LL;
            xmlParserInputPtr v53 = xmlDocCopyNode(v49, ctxt->myDoc, 1);
            BOOL v54 = v53;
            if (v53)
            {
              if (!v53->_private) {
                v53->_private = v49->_private;
              }
              if (!v51) {
                int v51 = v49;
              }
              xmlAddChild((xmlNodePtr)v10, v53);
              xmlAddChild(ctxt->node, v49);
            }

            if (v49 == v50) {
              break;
            }
            int v49 = v52;
          }

          while (v52);
        }

        else
        {
          BOOL v54 = 0LL;
          int v51 = 0LL;
        }

        if (!*(_DWORD *)(v10 + 128)) {
          *(_DWORD *)(v10 + 128) = 1;
        }
        if (*(_DWORD *)(v10 + 92) == 2)
        {
          int v56 = (void (*)(uint64_t, xmlNode *, xmlNodePtr))xmlEntityRefFunc;
          if (xmlEntityRefFunc)
          {
            uint64_t v57 = v10;
            uint64_t v58 = v51;
            int v42 = v54;
            goto LABEL_161;
          }
        }

        goto LABEL_162;
      }
    }

    else if (*(_DWORD *)(v10 + 128) && ctxt->parseMode != XML_PARSE_READER)
    {
      goto LABEL_116;
    }

    uint64_t v38 = *(int *)(v10 + 88) + ctxt->sizeentcopy + 5;
    ctxt->sizeentcopy = v38;
    unsigned int v39 = *p_children;
    if (*p_children)
    {
      uint64_t v40 = 0LL;
      while (1)
      {
        BOOL v41 = xmlDocCopyNode(v39, ctxt->myDoc, 1);
        if (v41)
        {
          if (!v41->_private) {
            v41->_private = v39->_private;
          }
          if (!v40) {
            uint64_t v40 = v41;
          }
          int v42 = xmlAddChild(ctxt->node, v41);
        }

        else
        {
          int v42 = 0LL;
        }

        if (v39 == *(xmlNode **)(v10 + 32)) {
          break;
        }
        unsigned int v39 = v39->next;
        if (!v39) {
          goto LABEL_149;
        }
      }

      unsigned int v55 = ctxt->parseMode != XML_PARSE_READER || v42 == 0LL;
      if (!v55 && v42->type == XML_ELEMENT_NODE && !v42->children) {
        v42->extra = 1;
      }
    }

    else
    {
      int v42 = 0LL;
      uint64_t v40 = 0LL;
    }

    doca = xmlReadFile((const char *)v60, 0LL, 0);
    if (!doca)
    {
      uint64_t v91 = a1;
      uint64_t v92 = 1065;
      int v93 = "xmlRelaxNG: could not load %s\n";
LABEL_171:
      xmlRngPErr(v91, 0LL, v92, v93, v60, 0LL);
LABEL_253:
      xmlRngPErr(a1, v6, 1032, "Failed to load externalRef %s\n", v60, 0LL);
      if (Base) {
        xmlFree(Base);
      }
      ((void (*)(xmlChar *))xmlFree)(v60);
      goto LABEL_256;
    }

    int v62 = (xmlDoc *)xmlMalloc(0x30uLL);
    if (!v62)
    {
      xmlRngPErr(a1, (uint64_t)doca, 2, "xmlRelaxNG: allocate memory for doc %s\n", v60, 0LL);
      xmlFreeDoc(doca);
      goto LABEL_253;
    }

    uint64_t v63 = v62;
    *(_OWORD *)&v62->name = 0u;
    *(_OWORD *)&v62->last = 0u;
    *(_OWORD *)&v62->_private = 0u;
    v62->name = (char *)doca;
    int v64 = xmlStrdup(v60);
    v63->_private = *(void **)(a1 + 112);
    *(void *)&v63->xmlElementType type = v64;
    LODWORD(v63->parxmlDumpEntityDecl(buf, ent) = 1;
    cur = v63;
    *(void *)(a1 + 112) = v63;
    if (Base)
    {
      char v65 = xmlDocGetRootElement(doca);
      if (v65)
      {
        uint64_t v66 = (xmlNode *)v65;
        if (!xmlHasProp(v65, (const xmlChar *)"ns")) {
          xmlSetProp(v66, (const xmlChar *)"ns", Base);
        }
      }
    }

    unint64_t v67 = *(void **)(a1 + 192);
    if (v67 || (*(void *)(a1 + 184) = 0x400000000LL, unint64_t v67 = xmlMalloc(0x20uLL), (*(void *)(a1 + 192) = v67) != 0LL))
    {
      xmlParserInputPtr v68 = *(_DWORD *)(a1 + 184);
      int v69 = *(int *)(a1 + 188);
      if (v68 < (int)v69)
      {
        xmlEntityPtr v70 = cur;
LABEL_185:
        v67[v68] = v70;
        *(void *)(a1 + 176) = v70;
        *(_DWORD *)(a1 + 184) = v68 + 1;
LABEL_247:
        if (!xmlRelaxNGCleanupDoc(a1, doca))
        {
          *(void *)(a1 + 176) = 0LL;
          goto LABEL_253;
        }

        xmlGenericErrorFunc v124 = *(_DWORD *)(a1 + 184);
        uint64_t v125 = v124 - 1;
        if (v124 >= 1)
        {
          *(_DWORD *)(a1 + 184) = v125;
          xmlGenericErrorFunc v126 = *(void *)(a1 + 192);
          if (v124 == 1) {
            xmlGenericErrorFunc v128 = 0LL;
          }
          else {
            xmlGenericErrorFunc v128 = *(void *)(v126 + 8LL * (v124 - 2));
          }
          *(void *)(a1 + 176) = v128;
          *(void *)(v126 + 8LL * v125) = 0LL;
        }

        if (Base) {
          xmlFree(Base);
        }
        xmlFree(v60);
        *(void *)(v6 + 104) = cur;
LABEL_225:
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"div"))
        {
          xmlGenericErrorFunc v111 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
          int v112 = *(xmlNode **)(v6 + 24);
          if (v112)
          {
            Sibling = (xmlNode *)v6;
            do
            {
              if (v111 && !xmlHasProp(v112, (const xmlChar *)"ns")) {
                xmlSetProp(v112, (const xmlChar *)"ns", v111);
              }
              next = v112->next;
              xmlUnlinkNode(v112);
              Sibling = xmlAddNextSibling(Sibling, v112);
              int v112 = next;
            }

            while (next);
          }

          if (v111) {
            xmlFree(v111);
          }
          v115 = *(void *)(v6 + 96);
          int v4 = (xmlNode *)v6;
          if (v115)
          {
            uint64_t v116 = *(void *)(v6 + 40);
            int v4 = (xmlNode *)v6;
            if (v116)
            {
              xmlNodePtr v117 = (void *)(v116 + 96);
              do
              {
                xmlGenericErrorFunc v118 = v117;
                xmlNodePtr v117 = (void *)*v117;
              }

              while (v117);
              *xmlGenericErrorFunc v118 = v115;
              *(void *)(v6 + 96) = 0LL;
              int v4 = (xmlNode *)v6;
            }
          }

          goto LABEL_257;
        }

        goto LABEL_54;
      }

      *(_DWORD *)(a1 + 188) = 2 * v69;
      unint64_t v67 = xmlRealloc(v67, 16 * v69);
      *(void *)(a1 + 192) = v67;
      xmlEntityPtr v70 = cur;
      if (v67)
      {
        xmlParserInputPtr v68 = *(_DWORD *)(a1 + 184);
        goto LABEL_185;
      }
    }

    xmlRngPErrMemory(a1, (const xmlChar *)"adding document\n");
    goto LABEL_247;
  }

  xmlRngPErr(a1, v6, 1041, "Failed to compute URL for externalRef %s\n", v50, 0LL);
  if (Base) {
    xmlFree(Base);
  }
  xmlFree(v50);
  int v4 = (xmlNode *)v6;
  if (v58)
  {
    ((void (*)(xmlChar *))xmlFree)(v58);
    goto LABEL_256;
  }

  do
  {
LABEL_257:
    xmlParserInputPtr v5 = *(void *)(v6 + 48);
    if (v5) {
      goto LABEL_3;
    }
    BOOL v6 = *(void *)(v6 + 40);
    if (v6) {
      v127 = v6 == a2;
    }
    else {
      v127 = 1;
    }
  }

  while (!v127);
  if (v4)
  {
    xmlUnlinkNode(v4);
    xmlFreeNode(v4);
  }

                *((void *)v19 + 9) = *p_nsDef;
                goto LABEL_117;
              }

              int v47 = v74;
LABEL_117:
              if (*((_DWORD *)v19 + 2) == 2)
              {
                xmlParserInputPtr v53 = (xmlNode *)*((void *)v19 + 5);
                if (v53)
                {
                  if (xmlIsID(destDoc, v53, (xmlAttrPtr)v19))
                  {
                    StringInternal = xmlNodeListGetStringInternal(*p_doc, (uint64_t)v23->children, 1, 0);
                    if (StringInternal)
                    {
                      unsigned int v55 = StringInternal;
                      int v56 = xmlAddID(0LL, destDoc, StringInternal, (xmlAttrPtr)v23);
                      xmlFree(v55);
                      if (!v56) {
                        goto LABEL_171;
                      }
                    }
                  }
                }
              }

              if (v23->type == XML_ELEMENT_NODE)
              {
                int properties = (xmlNode *)v23->properties;
                entityDeclSAXFunc v27 = v75;
                if (!properties) {
                  goto LABEL_126;
                }
LABEL_129:
                int v18 = 0LL;
                goto LABEL_156;
              }

              entityDeclSAXFunc v27 = v75;
LABEL_126:
              int properties = v23->children;
              if (properties && (deep || v23->type == XML_ATTRIBUTE_NODE)) {
                goto LABEL_129;
              }
              uint64_t v74 = v47;
LABEL_131:
              if (v23 == node)
              {
LABEL_159:
                uint64_t v8 = 0;
                goto LABEL_160;
              }

              int v18 = v19;
              while (1)
              {
                uint64_t v58 = v23->type;
                if (v58 <= 0x14 && ((1 << v58) & 0x180002) != 0)
                {
                  int v60 = namespaceMap;
                  if (namespaceMap)
                  {
                    unint64_t v61 = *namespaceMap;
                    if (*namespaceMap)
                    {
                      uint64_t v63 = namespaceMap + 1;
                      int v62 = namespaceMap[1];
                      if (!v62) {
                        goto LABEL_178;
                      }
                      do
                      {
                        if (*(_DWORD *)(v62 + 36) < v22) {
                          break;
                        }
                        int v64 = *(uint64_t **)(v62 + 8);
                        xmlChar *v63 = (uint64_t)v64;
                        if (v64) {
                          int v60 = v64;
                        }
                        int *v60 = 0LL;
                        *(void *)int v62 = namespaceMap[2];
                        int v60 = namespaceMap;
                        namespaceMap[2] = v62;
                        uint64_t v63 = v60 + 1;
                        int v62 = v60[1];
                      }

                      while (v62);
                      unint64_t v61 = *v60;
                      if (*v60)
                      {
LABEL_178:
                        do
                        {
                          if (*(_DWORD *)(v61 + 32) >= v22) {
                            *(_DWORD *)(v61 + 32) = -1;
                          }
                          unint64_t v61 = *(void *)v61;
                        }

                        while (v61);
                      }
                    }
                  }

                  --v22;
                }

                int properties = v23->next;
                if (properties) {
                  break;
                }
                size_t v19 = (_OWORD *)*((void *)v18 + 5);
                if (v58 == 2)
                {
                  entityDeclSAXFunc v27 = (_OWORD *)*((void *)v19 + 5);
                  xmlParserInputPtr v23 = v23->parent;
                  int v47 = v74;
                  goto LABEL_126;
                }

                if (v19)
                {
                  *((void *)v19 + 4) = v18;
                  entityDeclSAXFunc v27 = (_OWORD *)*((void *)v19 + 5);
                }

                xmlParserInputPtr v23 = v23->parent;
                int v18 = v19;
                if (v23 == node) {
                  goto LABEL_159;
                }
              }

              int v47 = v74;
              size_t v19 = v27;
LABEL_156:
              p_xmlDocPtr doc = &properties->doc;
              xmlURIPtr v21 = v47;
              xmlParserInputPtr v23 = properties;
              xmlURIPtr v20 = v77;
              if (properties->doc != v73) {
                goto LABEL_171;
              }
              break;
            case XML_ATTRIBUTE_NODE:
              goto LABEL_95;
            case XML_TEXT_NODE:
            case XML_CDATA_SECTION_NODE:
            case XML_PI_NODE:
            case XML_COMMENT_NODE:
              content = v23->content;
              if (!content) {
                goto LABEL_131;
              }
              if (dict)
              {
                int v34 = xmlDictOwns(dict, content);
                entityDeclSAXFunc v35 = v23->content;
                if (v34)
                {
                  *((void *)v19 + 10) = v35;
                  goto LABEL_73;
                }

                uint64_t v37 = (void *)xmlDictLookup(dict, v35, -1);
              }

              else
              {
                uint64_t v37 = xmlStrdup(content);
              }

              *((void *)v19 + 10) = v37;
              goto LABEL_73;
            case XML_ENTITY_REF_NODE:
              if (v73 == destDoc)
              {
                *((void *)v19 + 10) = v23->content;
                *(_OWORD *)((char *)v19 + 24) = *(_OWORD *)&v23->children;
              }

              else if (destDoc->intSubset || destDoc->extSubset)
              {
                xmlEntityPtr DocEntity = xmlGetDocEntity(destDoc, v23->name);
                if (DocEntity)
                {
                  *((void *)v19 + 10) = DocEntity->content;
                  *((void *)v19 + 3) = DocEntity;
                  *((void *)v19 + 4) = DocEntity;
                }

_DWORD *xmlErrMsgStr(_DWORD *result, int a2, uint64_t a3, uint64_t a4)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 2, 0LL, 0, a4, 0LL, 0LL, 0, 0, a3);
  }
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    return (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 2, 0LL, 0, a4, 0LL, 0LL, 0, 0, a3);
  }

  return result;
}

int xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value)
{
  *unsigned int value = 0LL;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 35)
  {
    int v7 = 1;
    goto LABEL_36;
  }

  int v6 = cur[1];
  if (v6 == 70)
  {
    if (cur[2] == 73 && cur[3] == 88 && cur[4] == 69 && cur[5] == 68)
    {
      input->cur = cur + 6;
      input->col += 6;
      if (!cur[6]) {
        xmlParserInputGrow(input, 250);
      }
      if (!xmlSkipBlankChars(ctxt)) {
        xmlFatalErrMsg(ctxt, 65);
      }
      int v7 = 4;
LABEL_35:
      if (!ctxt->input)
      {
        ctxt->xmlParserInputState instate = XML_PARSER_DTD;
        goto LABEL_39;
      }

xmlEnumerationPtr xmlParseNotationType(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 40)
  {
    if (!ctxt->progressive && cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
    int v4 = 0LL;
    p_next = 0LL;
    do
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      int v6 = xmlParseName(ctxt);
      if (!v6)
      {
        xmlFatalErrMsg(ctxt, 68);
        goto LABEL_24;
      }

      int v7 = (xmlChar *)v6;
      uint64_t v8 = v4;
      if (v4)
      {
        while (!xmlStrEqual(v7, v8->name))
        {
          uint64_t v8 = v8->next;
          if (!v8) {
            goto LABEL_11;
          }
        }

        xmlValidityError( (uint64_t *)ctxt,  541,  (uint64_t)"standalone: attribute notation value token %s duplicated\n",  (uint64_t)v7,  0LL);
        if (!xmlDictOwns(ctxt->dict, v7)) {
          xmlFree(v7);
        }
      }

      else
      {
LABEL_11:
        xmlEnumerationPtr Enumeration = xmlCreateEnumeration(v7);
        if (!Enumeration) {
          goto LABEL_24;
        }
        if (p_next) {
          void *p_next = Enumeration;
        }
        else {
          int v4 = Enumeration;
        }
        p_next = &Enumeration->next;
      }

      xmlSkipBlankChars(ctxt);
      int v10 = *ctxt->input->cur;
    }

    while (v10 == 124);
    if (v10 == 41)
    {
      xmlNextChar(ctxt);
      return v4;
    }

    xmlFatalErr(ctxt, 49, 0LL);
LABEL_24:
    xmlFreeEnumeration(v4);
  }

  else
  {
    xmlFatalErr(ctxt, 48, 0LL);
  }

  return 0LL;
}

uint64_t *xmlValidityError(uint64_t *result, int a2, uint64_t a3, uint64_t a4, xmlChar *a5)
{
  if (!result) {
    return (uint64_t *)__xmlRaiseError(0, 0, 0, 0, 0, 4, a2, 2, 0LL, 0, a4, a5, 0LL, 0, 0, a3);
  }
  uint64_t v5 = (uint64_t)result;
  if (!*((_DWORD *)result + 83) || *((_DWORD *)result + 68) != -1)
  {
    *((_DWORD *)result + 34) = a2;
    uint64_t v6 = *result;
    if (*result && *(_DWORD *)(v6 + 216) == -554844497) {
      uint64_t v7 = *(void *)(v6 + 248);
    }
    else {
      LODWORD(v7) = 0;
    }
    __n128 result = (uint64_t *)__xmlRaiseError( v7,  *(void *)(v5 + 168),  *(void *)(v5 + 160),  v5,  0,  4,  a2,  2,  0LL,  0,  a4,  a5,  0LL,  0,  0,  a3);
    *(_DWORD *)(v5 + 152) = 0;
  }

  return result;
}

xmlEnumerationPtr xmlParseEnumerationType(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 40)
  {
    if (!ctxt->progressive && cur - input->base >= 501 && input->end - cur <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
    int v4 = 0LL;
    p_next = 0LL;
    while (1)
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      uint64_t v6 = xmlParseNmtoken(ctxt);
      if (!v6) {
        break;
      }
      uint64_t v7 = v6;
      uint64_t v8 = v4;
      if (v4)
      {
        while (!xmlStrEqual(v7, v8->name))
        {
          uint64_t v8 = v8->next;
          if (!v8) {
            goto LABEL_11;
          }
        }

        xmlValidityError( (uint64_t *)ctxt,  541,  (uint64_t)"standalone: attribute enumeration value token %s duplicated\n",  (uint64_t)v7,  0LL);
        if (!xmlDictOwns(ctxt->dict, v7)) {
          xmlFree(v7);
        }
      }

      else
      {
LABEL_11:
        xmlEnumerationPtr Enumeration = xmlCreateEnumeration(v7);
        if (!xmlDictOwns(ctxt->dict, v7)) {
          xmlFree(v7);
        }
        if (!Enumeration)
        {
          xmlFreeEnumeration(v4);
          return 0LL;
        }

        if (p_next) {
          void *p_next = Enumeration;
        }
        else {
          int v4 = Enumeration;
        }
        p_next = &Enumeration->next;
      }

      xmlSkipBlankChars(ctxt);
      int v10 = *ctxt->input->cur;
      if (v10 != 124)
      {
        xmlParserCtxtPtr v11 = ctxt;
        if (v10 == 41)
        {
          xmlNextChar(ctxt);
          return v4;
        }

        int v12 = 51;
        goto LABEL_27;
      }
    }

    xmlParserCtxtPtr v11 = ctxt;
    int v12 = 67;
LABEL_27:
    xmlFatalErr(v11, v12, 0LL);
    return v4;
  }

  xmlFatalErr(ctxt, 50, 0LL);
  return 0LL;
}

int xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree)
{
  xmlParserInputPtr input = ctxt->input;
  cur = (unsigned __int8 *)input->cur;
  if (__PAIR64__(cur[1], *cur) == 0x4F0000004ELL
    && cur[2] == 84
    && cur[3] == 65
    && cur[4] == 84
    && cur[5] == 73
    && cur[6] == 79
    && cur[7] == 78)
  {
    input->cur = cur + 8;
    input->col += 8;
    if (!cur[8]) {
      xmlParserInputGrow(input, 250);
    }
    if (!xmlSkipBlankChars(ctxt))
    {
      xmlFatalErrMsg(ctxt, 65);
      return 0;
    }

    uint64_t v6 = xmlParseNotationType(ctxt);
    *tree = v6;
    BOOL v7 = v6 == 0LL;
    int v8 = 10;
  }

  else
  {
    int v9 = xmlParseEnumerationType(ctxt);
    *tree = v9;
    BOOL v7 = v9 == 0LL;
    int v8 = 9;
  }

  if (v7) {
    return 0;
  }
  else {
    return v8;
  }
}

int xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  unsigned int v5 = *cur;
  if (v5 > 0x48)
  {
    if (v5 == 73)
    {
      if (cur[1] != 68) {
        goto LABEL_56;
      }
      BOOL v7 = cur + 2;
      if (cur[2] == 82 && cur[3] == 69 && cur[4] == 70 && cur[5] == 83)
      {
        input->cur = cur + 6;
        input->col += 6;
        if (!cur[6]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 4;
      }

      else if (*v7 == 82 && cur[3] == 69 && cur[4] == 70)
      {
        input->cur = cur + 5;
        input->col += 5;
        if (!cur[5]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 3;
      }

      else
      {
        input->cur = v7;
        input->col += 2;
        if (!*v7) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 2;
      }
    }

    else
    {
      if (v5 != 78 || cur[1] != 77) {
        goto LABEL_56;
      }
      if (cur[2] == 84 && cur[3] == 79 && cur[4] == 75 && cur[5] == 69 && cur[6] == 78 && cur[7] == 83)
      {
        input->cur = cur + 8;
        input->col += 8;
        if (!cur[8]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 8;
      }

      else
      {
        if (cur[2] != 84 || cur[3] != 79 || cur[4] != 75 || cur[5] != 69 || cur[6] != 78) {
          goto LABEL_56;
        }
        input->cur = cur + 7;
        input->col += 7;
        if (!cur[7]) {
          xmlParserInputGrow(input, 250);
        }
        int v6 = 7;
      }
    }
  }

  else
  {
    if (v5 != 67)
    {
      if (v5 == 69 && cur[1] == 78)
      {
        if (cur[2] == 84 && cur[3] == 73 && cur[4] == 84 && cur[5] == 89)
        {
          input->cur = cur + 6;
          input->col += 6;
          if (!cur[6]) {
            xmlParserInputGrow(input, 250);
          }
          int v6 = 5;
          goto LABEL_57;
        }

        if (cur[2] == 84 && cur[3] == 73 && cur[4] == 84 && cur[5] == 73 && cur[6] == 69 && cur[7] == 83)
        {
          input->cur = cur + 8;
          input->col += 8;
          if (!cur[8]) {
            xmlParserInputGrow(input, 250);
          }
          int v6 = 6;
          goto LABEL_57;
        }
      }

LABEL_57:
  if (!ctxt->progressive)
  {
    xmlParserInputPtr v8 = ctxt->input;
    int v9 = v8->cur;
    if (v9 - v8->base >= 501 && v8->end - v9 <= 499) {
      xmlSHRINK((uint64_t)ctxt);
    }
  }

  return v6;
}

    int v31 = *(void *)(v16 + 24);
    if (!v31 || (*(_DWORD *)(v16 + 8) | 8) != 9) {
      goto LABEL_123;
    }
LABEL_59:
    BOOL v16 = v31;
    if (v31 == a3) {
      goto LABEL_126;
    }
  }

  if (xmlStrEqual( *(const xmlChar **)(*(void *)(v16 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XInclude")
    && !*((_DWORD *)v9 + 21))
  {
    *((_DWORD *)v9 + 2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 1;
  }

  if (!xmlStrEqual(*(const xmlChar **)(v16 + 16), (const xmlChar *)"include"))
  {
    if (xmlStrEqual(*(const xmlChar **)(v16 + 16), (const xmlChar *)"fallback"))
    {
      if ((xmlDocPtr v29 = *(void *)(v16 + 40)) == 0
        || *(_DWORD *)(v29 + 8) != 1
        || (xmlParserInputPtr v30 = *(void *)(v29 + 72)) == 0
        || !xmlStrEqual(*(const xmlChar **)(v30 + 16), (const xmlChar *)"http://www.w3.org/2003/XInclude")
        && !xmlStrEqual( *(const xmlChar **)(*(void *)(*(void *)(v16 + 40) + 72LL) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XInclude")
        || !xmlStrEqual(*(const xmlChar **)(*(void *)(v16 + 40) + 16LL), (const xmlChar *)"include"))
      {
        xmlURIPtr v21 = (uint64_t)v9;
        size_t v22 = v16;
        xmlParserInputPtr v23 = 1616;
        int v24 = "%s is not the child of an 'include'\n";
        unint64_t v25 = "fallback";
LABEL_56:
        xmlXIncludeErr(v21, v22, v23, v24, (const xmlChar *)v25);
      }
    }

    goto LABEL_57;
  }

  int v18 = *(void *)(v16 + 24);
  if (!v18) {
    goto LABEL_40;
  }
  size_t v19 = 0;
  do
  {
    if (*(_DWORD *)(v18 + 8) == 1)
    {
      xmlURIPtr v20 = *(void *)(v18 + 72);
      if (v20)
      {
        if (xmlStrEqual(*(const xmlChar **)(v20 + 16), (const xmlChar *)"http://www.w3.org/2003/XInclude")
          || xmlStrEqual( *(const xmlChar **)(*(void *)(v18 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XInclude"))
        {
          if (xmlStrEqual(*(const xmlChar **)(v18 + 16), (const xmlChar *)"include"))
          {
            xmlXIncludeErr((uint64_t)v9, v16, 1614, "%s has an 'include' child\n", (const xmlChar *)"include");
            goto LABEL_57;
          }

          if (xmlStrEqual(*(const xmlChar **)(v18 + 16), (const xmlChar *)"fallback")) {
            ++v19;
          }
        }
      }
    }

    int v18 = *(void *)(v18 + 48);
  }

  while (v18);
  if (v19 >= 2)
  {
    xmlURIPtr v21 = (uint64_t)v9;
    size_t v22 = v16;
    xmlParserInputPtr v23 = 1615;
    int v24 = "%s has multiple fallback children\n";
    unint64_t v25 = "include";
    goto LABEL_56;
  }

      int v10 = *(void *)(v10 + 48);
      if (!v10) {
        return v22;
      }
    }
  }

  return v6;
}

                xmlFree(v32);
                goto LABEL_58;
              }

              int v47 = v47->next;
            }

            else
            {
              xmlSchemaInternalErr2( ctxt,  (const xmlChar *)"xmlSchemaCheckCOSSTRestricts",  (const xmlChar *)"different number of member types in base",  0LL);
            }

            uint64_t v46 = v46->next;
          }

          while (v46);
        }

        int v49 = typeDecl->facets;
        if (v49)
        {
          int v50 = 0;
          do
          {
            while ((v49->type & 0xFFFFFFFE) == 0x3EE)
            {
              int v49 = v49->next;
              if (!v49) {
                goto LABEL_169;
              }
            }

            xmlSchemaPIllegalFacetListUnionErr((uint64_t)ctxt, 3029, (uint64_t)typeDecl, (int *)v49);
            int v49 = v49->next;
            int v50 = 1;
          }

          while (v49);
          goto LABEL_58;
        }

        goto LABEL_84;
      }

      xmlSchemaGetComponentQName(&v58, (int *)v37);
      size_t v19 = "The 'final' of its base type '%s' must not contain 'restriction'";
      xmlParserInputPtr v30 = ctxt;
      int v31 = 3026;
    }

    else
    {
      xmlSchemaGetComponentQName(&v58, (int *)v37);
      size_t v19 = "The base type '%s' is not a union type";
      xmlParserInputPtr v30 = ctxt;
      int v31 = 3027;
    }

    goto LABEL_56;
  }

  while (1)
  {
    p_memberTypes = (xmlSchemaTypeLinkPtr *)*p_memberTypes;
    if (!p_memberTypes) {
      break;
    }
    uint64_t v38 = (int *)p_memberTypes[1];
    if (v38) {
      unsigned int v39 = (v38[22] >> 12) & 1;
    }
    else {
      unsigned int v39 = 0;
    }
    if (v39)
    {
      xmlSchemaGetComponentQName(&v58, v38);
      size_t v19 = "The 'final' of member type '%s' contains 'union'";
      xmlParserInputPtr v30 = ctxt;
      int v31 = 3024;
      goto LABEL_56;
    }
  }

  if (typeDecl->facetSet)
  {
    xmlParserInputPtr v23 = "No facets allowed";
    int v24 = ctxt;
    unint64_t v25 = 3025;
    goto LABEL_34;
  }

void xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 65
    && cur[3] == 84
    && cur[4] == 84
    && cur[5] == 76
    && cur[6] == 73
    && cur[7] == 83
    && cur[8] == 84)
  {
    int id = input->id;
    input->cur = cur + 9;
    input->col += 9;
    if (!cur[9]) {
      xmlParserInputGrow(input, 250);
    }
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65);
    }
    unsigned int v5 = xmlParseName(ctxt);
    if (v5)
    {
      int v6 = (xmlChar *)v5;
      xmlSkipBlankChars(ctxt);
      xmlParserInputPtr v7 = ctxt->input;
      if (!ctxt->progressive && v7->end - v7->cur <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        xmlParserInputPtr v7 = ctxt->input;
      }

      xmlParserInputPtr v8 = v7->cur;
      if (*v8 != 62)
      {
        while (1)
        {
          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_71;
          }
          xmlURIPtr v20 = 0LL;
          if (!ctxt->progressive && v7->end - v8 <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          xmlEnumerationPtr tree = 0LL;
          int v9 = xmlParseName(ctxt);
          if (!v9) {
            break;
          }
          int v10 = (xmlChar *)v9;
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (!xmlSkipBlankChars(ctxt))
          {
            xmlParserCtxtPtr v18 = ctxt;
            int v19 = 65;
            goto LABEL_64;
          }

          uint64_t v11 = xmlParseAttributeType(ctxt, &tree);
          uint64_t v12 = v11;
          if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
            xmlGROW((uint64_t)ctxt);
          }
          if (!xmlSkipBlankChars(ctxt))
          {
            xmlFatalErrMsg(ctxt, 65);
            goto LABEL_68;
          }

          uint64_t v13 = xmlParseDefaultDecl(ctxt, &v20);
          xmlDocPtr v14 = v20;
          if ((_DWORD)v12 != 1 && v20) {
            xmlAttrNormalizeSpace((uint64_t)v20, v20);
          }
          xmlParserInputPtr v15 = ctxt->input;
          if (!ctxt->progressive && v15->end - v15->cur <= 249)
          {
            xmlGROW((uint64_t)ctxt);
            xmlParserInputPtr v15 = ctxt->input;
          }

          if (*v15->cur != 62 && !xmlSkipBlankChars(ctxt))
          {
            xmlFatalErrMsg(ctxt, 65);
            if (v14) {
              xmlFree(v14);
            }
LABEL_68:
            if (tree) {
              xmlFreeEnumeration(tree);
            }
LABEL_70:
            xmlParserInputPtr v7 = ctxt->input;
            goto LABEL_71;
          }

          if (ctxt->sax && !ctxt->disableSAX && (attributeDeclSAXFunc attributeDecl = ctxt->sax->attributeDecl) != 0LL)
          {
            ((void (*)(void *, xmlChar *, xmlChar *, uint64_t, uint64_t, xmlChar *, xmlEnumerationPtr))attributeDecl)( ctxt->userData,  v6,  v10,  v12,  v13,  v14,  tree);
          }

          else if (tree)
          {
            xmlFreeEnumeration(tree);
          }

          int sax2 = ctxt->sax2;
          if (sax2 && v14 && (_DWORD)v13 != 3 && (_DWORD)v13 != 2)
          {
            xmlAddDefAttrs((uint64_t)ctxt, v6, v10, v14);
            int sax2 = ctxt->sax2;
          }

          if (sax2) {
            xmlAddSpecialAttr((uint64_t)ctxt, v6, v10, v12);
          }
          if (v14) {
            xmlFree(v14);
          }
          xmlParserInputPtr v7 = ctxt->input;
          if (!ctxt->progressive && v7->end - v7->cur <= 249)
          {
            xmlGROW((uint64_t)ctxt);
            xmlParserInputPtr v7 = ctxt->input;
          }

          xmlParserInputPtr v8 = v7->cur;
          if (*v8 == 62) {
            goto LABEL_71;
          }
        }

        xmlParserCtxtPtr v18 = ctxt;
        int v19 = 68;
LABEL_64:
        xmlFatalErrMsg(v18, v19);
        goto LABEL_70;
      }

uint64_t xmlAttrNormalizeSpace(uint64_t result, _BYTE *a2)
{
  unint64_t v2 = (unsigned __int8 *)(result - 1);
  do
  {
    int v4 = *++v2;
    int v3 = v4;
  }

  while (v4 == 32);
  while (v3 == 32)
  {
    while (v3 == 32)
    {
      int v5 = *++v2;
      int v3 = v5;
    }

    if (v3)
    {
      LOBYTE(v3) = 32;
      goto LABEL_9;
    }

_DWORD *xmlAddDefAttrs(uint64_t a1, xmlChar *name, xmlChar *name2, const xmlChar *a4)
{
  xmlParserInputPtr v8 = *(xmlHashTable **)(a1 + 552);
  if (v8)
  {
    __n128 result = xmlHashLookup2(v8, name, name2);
    if (result) {
      return result;
    }
  }

  int len = 0;
  if (!*(void *)(a1 + 544))
  {
    xmlHashTablePtr Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a1 + 456));
    *(void *)(a1 + 544) = Dict;
    if (!Dict) {
      return htmlErrMemory((_DWORD *)a1, 0LL);
    }
  }

  uint64_t v11 = xmlSplitQName3(name, &len);
  uint64_t v12 = *(xmlDict **)(a1 + 456);
  if (v11)
  {
    uint64_t v13 = xmlDictLookup(v12, v11, -1);
    xmlDocPtr v14 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), name, len);
  }

  else
  {
    uint64_t v13 = xmlDictLookup(v12, name, -1);
    xmlDocPtr v14 = 0LL;
  }

  xmlParserInputPtr v15 = (int *)xmlHashLookup2(*(xmlHashTablePtr *)(a1 + 544), v13, v14);
  if (!v15)
  {
    int v19 = (int *)xmlMalloc(0xA8uLL);
    if (!v19) {
      return htmlErrMemory((_DWORD *)a1, 0LL);
    }
    BOOL v16 = v19;
    *(void *)int v19 = 0x400000000LL;
LABEL_14:
    if ((xmlHashUpdateEntry2(*(xmlHashTablePtr *)(a1 + 544), v13, v14, v16, 0LL) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    xmlFree(v16);
    return htmlErrMemory((_DWORD *)a1, 0LL);
  }

  BOOL v16 = v15;
  int v17 = v15[1];
  if (*v15 >= v17)
  {
    xmlParserCtxtPtr v18 = (int *)xmlRealloc(v15, (16 * ((unint64_t)(10 * v17) >> 1)) | 8);
    if (!v18) {
      return htmlErrMemory((_DWORD *)a1, 0LL);
    }
    BOOL v16 = v18;
    v18[1] *= 2;
    goto LABEL_14;
  }

_DWORD *xmlAddSpecialAttr(uint64_t a1, xmlChar *name, xmlChar *name2, unsigned int a4)
{
  xmlHashTablePtr Dict = *(xmlHashTable **)(a1 + 552);
  if (!Dict)
  {
    xmlHashTablePtr Dict = xmlHashCreateDict(10, *(xmlDictPtr *)(a1 + 456));
    *(void *)(a1 + 552) = Dict;
    if (!Dict) {
      return htmlErrMemory((_DWORD *)a1, 0LL);
    }
  }

  __n128 result = xmlHashLookup2(Dict, name, name2);
  if (!result) {
    return (_DWORD *)xmlHashAddEntry2(*(xmlHashTablePtr *)(a1 + 552), name, name2, (void *)a4);
  }
  return result;
}

xmlElementContentPtr xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur == 35 && cur[1] == 80 && cur[2] == 67 && cur[3] == 68 && cur[4] == 65 && cur[5] == 84 && cur[6] == 65)
  {
    input->cur = cur + 7;
    input->col += 7;
    if (!cur[7]) {
      xmlParserInputGrow(input, 250);
    }
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr v6 = ctxt->input;
    if (!ctxt->progressive)
    {
      xmlParserInputPtr v7 = v6->cur;
      if (v7 - v6->base >= 501 && v6->end - v7 <= 499)
      {
        xmlSHRINK((uint64_t)ctxt);
        xmlParserInputPtr v6 = ctxt->input;
      }
    }

    int v8 = *v6->cur;
    if (v8 == 40 || v8 == 124)
    {
      xmlElementContentPtr v10 = xmlNewDocElementContent(ctxt->myDoc, 0LL, XML_ELEMENT_CONTENT_PCDATA);
      if (!v10) {
        return v10;
      }
    }

    else
    {
      if (v8 == 41)
      {
        if (v6->id != inputchk) {
          xmlFatalErrMsg(ctxt, 90);
        }
        xmlNextChar(ctxt);
        xmlElementContentPtr v9 = xmlNewDocElementContent(ctxt->myDoc, 0LL, XML_ELEMENT_CONTENT_PCDATA);
        xmlElementContentPtr v10 = v9;
        if (v9 && *ctxt->input->cur == 42)
        {
          v9->ocur = XML_ELEMENT_CONTENT_MULT;
          xmlNextChar(ctxt);
        }

        return v10;
      }

      xmlElementContentPtr v10 = 0LL;
    }

    xmlDocPtr v14 = 0LL;
    xmlElementContentPtr v15 = v10;
    while (1)
    {
      BOOL v16 = ctxt->input->cur;
      int v17 = *v16;
      if (v17 != 124)
      {
        if (v17 != 41 || v16[1] != 42)
        {
LABEL_58:
          xmlFreeDocElementContent(ctxt->myDoc, v10);
          xmlParserCtxtPtr v11 = ctxt;
          int v12 = 52;
          goto LABEL_26;
        }

        if (v14)
        {
          xmlElementContentPtr v25 = xmlNewDocElementContent(ctxt->myDoc, v14, XML_ELEMENT_CONTENT_ELEMENT);
          v15->c2 = v25;
          if (v25) {
            v25->parent = v15;
          }
        }

        if (v10) {
          v10->ocur = XML_ELEMENT_CONTENT_MULT;
        }
        xmlParserInputPtr v26 = ctxt->input;
        if (v26->id != inputchk)
        {
          xmlFatalErrMsg(ctxt, 90);
          xmlParserInputPtr v26 = ctxt->input;
        }

        entityDeclSAXFunc v27 = v26->cur;
        v26->cur = v27 + 2;
        v26->col += 2;
        if (!v27[2]) {
          xmlParserInputGrow(v26, 250);
        }
        return v10;
      }

      if (ctxt->instate == XML_PARSER_EOF) {
        goto LABEL_58;
      }
      xmlNextChar(ctxt);
      xmlElementContentPtr v18 = xmlNewDocElementContent(ctxt->myDoc, 0LL, XML_ELEMENT_CONTENT_OR);
      xmlElementContentPtr v19 = v18;
      if (v14) {
        break;
      }
      if (!v18)
      {
        xmlDocPtr myDoc = ctxt->myDoc;
        xmlParserInputPtr v28 = v15;
        goto LABEL_61;
      }

      v18->c1 = v15;
      xmlElementContentPtr v22 = v15;
      xmlElementContentPtr v23 = v18;
      xmlElementContentPtr v10 = v18;
      if (v15) {
        goto LABEL_42;
      }
LABEL_43:
      xmlSkipBlankChars(ctxt);
      int v24 = xmlParseName(ctxt);
      if (!v24)
      {
        xmlFatalErrMsg(ctxt, 68);
        xmlDocPtr myDoc = ctxt->myDoc;
LABEL_60:
        xmlParserInputPtr v28 = v10;
LABEL_61:
        xmlFreeDocElementContent(myDoc, v28);
        return 0LL;
      }

      xmlDocPtr v14 = v24;
      xmlSkipBlankChars(ctxt);
      xmlElementContentPtr v15 = v19;
      if (!ctxt->progressive)
      {
        xmlElementContentPtr v15 = v19;
        if (ctxt->input->end - ctxt->input->cur <= 249)
        {
          xmlGROW((uint64_t)ctxt);
          xmlElementContentPtr v15 = v19;
        }
      }
    }

    xmlDocPtr myDoc = ctxt->myDoc;
    if (!v19) {
      goto LABEL_60;
    }
    xmlElementContentPtr v21 = xmlNewDocElementContent(myDoc, v14, XML_ELEMENT_CONTENT_ELEMENT);
    v19->c1 = v21;
    if (v21) {
      v21->parent = v19;
    }
    v15->c2 = v19;
    xmlElementContentPtr v22 = v19;
    xmlElementContentPtr v23 = v15;
LABEL_42:
    v22->parent = v23;
    goto LABEL_43;
  }

  xmlParserCtxtPtr v11 = ctxt;
  int v12 = 69;
LABEL_26:
  xmlFatalErr(v11, v12, 0LL);
  return 0LL;
}

xmlElementContentPtr xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk)
{
  return xmlParseElementChildrenContentDeclPriv((uint64_t)ctxt, inputchk, 1);
}

xmlElementContentPtr xmlParseElementChildrenContentDeclPriv(uint64_t a1, int a2, int a3)
{
  if (a3 >= 129 && (a3 > 0x800 || (*(_DWORD *)(a1 + 564) & 0x80000) == 0))
  {
    xmlFatalErrMsgInt( (_DWORD *)a1,  55,  (uint64_t)"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",  a3);
    return 0LL;
  }

  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  uint64_t v6 = *(void *)(a1 + 56);
  if (**(_BYTE **)(v6 + 32) != 40)
  {
    xmlElementContentPtr v9 = xmlParseName((xmlParserCtxtPtr)a1);
    if (!v9)
    {
      xmlFatalErr((_DWORD *)a1, 54, 0LL);
      return 0LL;
    }

    xmlElementContentPtr v8 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), v9, XML_ELEMENT_CONTENT_ELEMENT);
    if (!v8)
    {
      htmlErrMemory((_DWORD *)a1, 0LL);
      return v8;
    }

    uint64_t v10 = *(void *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v10 + 40) - *(void *)(v10 + 32)) <= 249)
    {
      xmlGROW(a1);
      uint64_t v10 = *(void *)(a1 + 56);
    }

    int v11 = **(unsigned __int8 **)(v10 + 32);
    switch(v11)
    {
      case '*':
        int v12 = 3;
        break;
      case '+':
        int v12 = 4;
        break;
      case '?':
        int v12 = 2;
        break;
      default:
        v8->ocur = XML_ELEMENT_CONTENT_ONCE;
        goto LABEL_28;
    }

    v8->ocur = v12;
    xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_28:
    if (*(_DWORD *)(a1 + 452)
      || (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) > 249)
    {
      goto LABEL_31;
    }

    goto LABEL_30;
  }

  uint64_t v7 = *(unsigned int *)(v6 + 100);
  xmlNextChar((xmlParserCtxtPtr)a1);
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  xmlElementContentPtr v8 = (xmlElementContentPtr)xmlParseElementChildrenContentDeclPriv(a1, v7, (a3 + 1));
  if (!v8) {
    return v8;
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (*(_DWORD *)(a1 + 452)
    || (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) >= 250)
  {
    goto LABEL_31;
  }

LABEL_80:
    if (*(_DWORD *)(v13 + 100) != a2) {
      xmlFatalErrMsg((_DWORD *)a1, 90);
    }
    xmlNextChar((xmlParserCtxtPtr)a1);
    int v30 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
    switch(v30)
    {
      case '*':
        v8->ocur = XML_ELEMENT_CONTENT_MULT;
        if (v8->type == XML_ELEMENT_CONTENT_OR)
        {
          xmlElementContentPtr v32 = v8;
          do
          {
            c1 = v32->c1;
            if (c1 && (c1->ocur & 0xFFFFFFFE) == 2) {
              c1->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
            xmlElementContentPtr v32 = v32->c2;
            if (!v32) {
              break;
            }
            if ((v32->ocur & 0xFFFFFFFE) == 2) {
              v32->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
          }

          while (v32->type == XML_ELEMENT_CONTENT_OR);
        }

        goto LABEL_115;
      case '+':
        if ((v8->ocur & 0xFFFFFFFE) == 2) {
          int v34 = 3;
        }
        else {
          int v34 = 4;
        }
        v8->ocur = v34;
        if (v16->type == XML_ELEMENT_CONTENT_OR)
        {
          int v35 = 0;
          do
          {
            int v36 = v16->c1;
            if (v36 && (v36->ocur & 0xFFFFFFFE) == 2)
            {
              int v35 = 1;
              v36->ocur = XML_ELEMENT_CONTENT_ONCE;
            }

            xmlElementContentPtr v16 = v16->c2;
            if (!v16) {
              break;
            }
            if ((v16->ocur & 0xFFFFFFFE) == 2)
            {
              int v35 = 1;
              v16->ocur = XML_ELEMENT_CONTENT_ONCE;
            }
          }

          while (v16->type == XML_ELEMENT_CONTENT_OR);
        }

        else
        {
          int v35 = 0;
        }

        if (!v35) {
          goto LABEL_115;
        }
        int v31 = 3;
        break;
      case '?':
        if (v8->ocur - 3 >= 2) {
          int v31 = 2;
        }
        else {
          int v31 = 3;
        }
        break;
      default:
        return v8;
    }

    v8->ocur = v31;
LABEL_115:
    xmlNextChar((xmlParserCtxtPtr)a1);
    return v8;
  }

  int v17 = 0LL;
  int v18 = 0;
  uint64_t v19 = (a3 + 1);
  xmlElementContentPtr v16 = v8;
  xmlElementContentPtr v20 = v8;
  while (1)
  {
    if (v15 == 124)
    {
      if (v18 && v18 != 124)
      {
LABEL_120:
        xmlFatalErrMsgInt((_DWORD *)a1, 66, (uint64_t)"xmlParseElementChildrenContentDecl : '%c' expected\n", v18);
        goto LABEL_121;
      }

      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlElementContentPtr v21 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), 0LL, XML_ELEMENT_CONTENT_OR);
      if (!v21) {
        goto LABEL_121;
      }
    }

    else
    {
      if (v15 != 44)
      {
        xmlFatalErr((_DWORD *)a1, 55, 0LL);
LABEL_121:
        if (v17 && v17 != v20) {
LABEL_123:
        }
          xmlFreeDocElementContent(*(xmlDocPtr *)(a1 + 16), v17);
LABEL_124:
        uint64_t v37 = *(xmlDoc **)(a1 + 16);
        uint64_t v38 = v20;
        goto LABEL_127;
      }

      if (v18 && v18 != 44) {
        goto LABEL_120;
      }
      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlElementContentPtr v21 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), 0LL, XML_ELEMENT_CONTENT_SEQ);
      if (!v21)
      {
        if (v17 && v17 != v20) {
          goto LABEL_123;
        }
        goto LABEL_124;
      }
    }

    xmlElementContentPtr v22 = v21;
    if (v17)
    {
      v16->c2 = v21;
      v21->parent = v16;
      xmlElementContentPtr v21 = v20;
      v22->c1 = v17;
    }

    else
    {
      v21->c1 = v20;
      int v17 = v20;
    }

    v17->parent = v22;
    xmlElementContentPtr v16 = v22;
    xmlElementContentPtr v8 = v21;
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
    {
      xmlGROW(a1);
    }

    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    uint64_t v23 = *(void *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v23 + 40) - *(void *)(v23 + 32)) <= 249)
    {
      xmlGROW(a1);
      uint64_t v23 = *(void *)(a1 + 56);
    }

    if (**(_BYTE **)(v23 + 32) == 40)
    {
      uint64_t v24 = *(unsigned int *)(v23 + 100);
      xmlNextChar((xmlParserCtxtPtr)a1);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      uint64_t v25 = xmlParseElementChildrenContentDeclPriv(a1, v24, v19);
      if (!v25) {
        goto LABEL_126;
      }
      int v17 = (xmlElementContent *)v25;
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      goto LABEL_71;
    }

    xmlParserInputPtr v26 = xmlParseName((xmlParserCtxtPtr)a1);
    if (!v26) {
      break;
    }
    xmlElementContentPtr v27 = xmlNewDocElementContent(*(xmlDocPtr *)(a1 + 16), v26, XML_ELEMENT_CONTENT_ELEMENT);
    if (!v27) {
      goto LABEL_126;
    }
    int v17 = v27;
    int v28 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
    if (v28 == 42)
    {
      v27->ocur = XML_ELEMENT_CONTENT_MULT;
    }

    else
    {
      if (v28 == 43)
      {
        int v29 = 4;
      }

      else
      {
        if (v28 != 63)
        {
          v27->ocur = XML_ELEMENT_CONTENT_ONCE;
          goto LABEL_71;
        }

        int v29 = 2;
      }

      v27->ocur = v29;
    }

    xmlNextChar((xmlParserCtxtPtr)a1);
LABEL_71:
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    uint64_t v13 = *(void *)(a1 + 56);
    if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v13 + 40) - *(void *)(v13 + 32)) <= 249)
    {
      xmlGROW(a1);
      uint64_t v13 = *(void *)(a1 + 56);
    }

    if (**(_BYTE **)(v13 + 32) == 41) {
      goto LABEL_79;
    }
    int v18 = v15;
    xmlElementContentPtr v20 = v8;
    int v15 = **(unsigned __int8 **)(v13 + 32);
    if (*(_DWORD *)(a1 + 272) == -1) {
      goto LABEL_78;
    }
  }

  xmlFatalErr((_DWORD *)a1, 54, 0LL);
LABEL_126:
  uint64_t v37 = *(xmlDoc **)(a1 + 16);
  uint64_t v38 = v8;
LABEL_127:
  xmlFreeDocElementContent(v37, v38);
  return 0LL;
}

    uint64_t v23 = (_DWORD *)a1;
    uint64_t v24 = 95;
LABEL_83:
    xmlFatalErr(v23, v24, 0LL);
    xmlHaltParser((xmlParserCtxtPtr)a1);
    goto LABEL_84;
  }

  if (cur[2] != 78 || cur[3] != 79 || cur[4] != 82 || cur[5] != 69) {
    goto LABEL_80;
  }
  v9->cur = cur + 6;
  v9->col += 6;
  if (!cur[6]) {
    xmlParserInputGrow(v9, 250);
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  xmlElementContentPtr v16 = *(void *)(a1 + 56);
  if (**(_BYTE **)(v16 + 32) != 91)
  {
LABEL_82:
    uint64_t v23 = (_DWORD *)a1;
    uint64_t v24 = 83;
    goto LABEL_83;
  }

  if (*(_DWORD *)(v16 + 100) != v8) {
    xmlFatalErrMsg((_DWORD *)a1, 90);
  }
  xmlNextChar((xmlParserCtxtPtr)a1);
  int v17 = *(_DWORD *)(a1 + 332);
  int v18 = *(_DWORD *)(a1 + 272);
  if (!*(_DWORD *)(a1 + 448)) {
    *(_DWORD *)(a1 + 332) = 1;
  }
  uint64_t v19 = 0LL;
  *(_DWORD *)(a1 + 272) = 15;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v5 = *(void *)(a1 + 56);
        xmlElementContentPtr v20 = *(unsigned __int8 **)(v5 + 32);
        xmlElementContentPtr v21 = *v20;
        if (v21 != 60) {
          break;
        }
        if (v20[1] != 33 || v20[2] != 91) {
          goto LABEL_69;
        }
        *(void *)(v5 + 32) = v20 + 3;
        *(_DWORD *)(v5 + 56) += 3;
        if (!v20[3]) {
          xmlParserInputGrow((xmlParserInputPtr)v5, 250);
        }
        if (__CFADD__(v19++, 1LL)) {
          goto LABEL_85;
        }
      }

      if (v21 == 93) {
        break;
      }
      if (!*v20) {
        goto LABEL_74;
      }
LABEL_69:
      xmlNextChar((xmlParserCtxtPtr)a1);
    }

    if (v20[1] != 93 || v20[2] != 62) {
      goto LABEL_69;
    }
    if (!v19) {
      break;
    }
    *(void *)(v5 + 32) = v20 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v20[3]) {
      xmlParserInputGrow((xmlParserInputPtr)v5, 250);
    }
    --v19;
  }

          int v18 = 2;
          goto LABEL_172;
        }

                    name = *(const xmlChar **)(a2 + 16);
                    uint64_t v19 = "Element %s is empty\n";
                    xmlElementContentPtr v20 = a1;
                    xmlElementContentPtr v21 = a2;
                    xmlElementContentPtr v22 = 1023;
                    goto LABEL_32;
                  }

                  int v42 = *(void *)(a2 + 72);
                }

                if (v42 && *(_DWORD *)(a2 + 8) == 1)
                {
                  int v44 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"group");
                  BOOL v45 = *(void *)(a2 + 72);
                  if (v44)
                  {
                    if (xmlStrEqual( *(const xmlChar **)(v45 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                    {
                      uint64_t v10 = xmlRelaxNGNewDefine(a1, a2);
                      if (!v10) {
                        return (uint64_t *)v10;
                      }
                      uint64_t v43 = 18;
                      goto LABEL_78;
                    }

                    BOOL v45 = *(void *)(a2 + 72);
                  }

                  if (v45 && *(_DWORD *)(a2 + 8) == 1)
                  {
                    uint64_t v46 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"ref");
                    int v47 = *(void *)(a2 + 72);
                    if (v46)
                    {
                      if (xmlStrEqual( *(const xmlChar **)(v47 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                      {
                        uint64_t v48 = xmlRelaxNGNewDefine(a1, a2);
                        uint64_t v10 = v48;
                        if (!v48) {
                          return (uint64_t *)v10;
                        }
                        *(_DWORD *)uint64_t v48 = 11;
                        Prop = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"name");
                        *((void *)v10 + 2) = Prop;
                        if (Prop)
                        {
                          xmlRelaxNGNormExtSpace(Prop);
                          if (!xmlValidateNCName(*((const xmlChar **)v10 + 2), 0))
                          {
LABEL_117:
                            if (*(void *)(a2 + 24)) {
                              xmlRngPErr(a1, a2, 1103, "ref is not empty\n", 0LL, 0LL);
                            }
                            uint64_t v63 = *(xmlHashTable **)(*(void *)(a1 + 48) + 56LL);
                            if (v63
                              || (uint64_t v63 = xmlHashCreate(10), (*(void *)(*(void *)(a1 + 48) + 56LL) = v63) != 0LL))
                            {
                              if ((xmlHashAddEntry(v63, *((const xmlChar **)v10 + 2), v10) & 0x80000000) == 0) {
                                return (uint64_t *)v10;
                              }
                              int v64 = xmlHashLookup( *(xmlHashTablePtr *)(*(void *)(a1 + 48) + 56LL),  *((const xmlChar **)v10 + 2));
                              if (v64)
                              {
LABEL_123:
                                *((void *)v10 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v64[11];
                                v64[11] = v10;
                                return (uint64_t *)v10;
                              }

                              uint64_t v78 = (const xmlChar *)*((void *)v10 + 2);
                              if (v78) {
                                uint64_t v74 = "Error refs definitions '%s'\n";
                              }
                              else {
                                uint64_t v74 = "Error refs definitions\n";
                              }
                              int v75 = a1;
                              uint64_t v76 = a2;
                              int v77 = 1098;
                              goto LABEL_258;
                            }

                            uint64_t v74 = "Could not create references hash\n";
                            int v75 = a1;
                            uint64_t v76 = a2;
                            int v77 = 1098;
                            goto LABEL_143;
                          }

                          int v50 = (const xmlChar *)*((void *)v10 + 2);
                          int v51 = "ref name '%s' is not an NCName\n";
                          int v52 = a1;
                          xmlParserInputPtr v53 = a2;
                          BOOL v54 = 1100;
                        }

                        else
                        {
                          int v51 = "ref has no name\n";
                          int v52 = a1;
                          xmlParserInputPtr v53 = a2;
                          BOOL v54 = 1102;
                          int v50 = 0LL;
                        }

                        xmlRngPErr(v52, v53, v54, v51, v50, 0LL);
                        goto LABEL_117;
                      }

                      int v47 = *(void *)(a2 + 72);
                    }

                    if (v47 && *(_DWORD *)(a2 + 8) == 1)
                    {
                      unsigned int v55 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"data");
                      int v56 = *(void *)(a2 + 72);
                      if (v55)
                      {
                        if (xmlStrEqual( *(const xmlChar **)(v56 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                        {
                          uint64_t v57 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"type");
                          if (v57)
                          {
                            uint64_t v58 = v57;
                            xmlRelaxNGNormExtSpace(v57);
                            if (xmlValidateNCName(v58, 0)) {
                              xmlRngPErr(a1, a2, 1112, "data type '%s' is not an NCName\n", v58, 0LL);
                            }
                            charactersSAXFunc v59 = xmlRelaxNGGetDataTypeLibrary(a2);
                            if (!v59) {
                              charactersSAXFunc v59 = xmlStrdup((const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                            }
                            int v60 = xmlRelaxNGNewDefine(a1, a2);
                            uint64_t v10 = v60;
                            if (!v60)
                            {
                              xmlFree(v59);
                              xmlFree(v58);
                              return (uint64_t *)v10;
                            }

                            *(_DWORD *)int v60 = 5;
                            *((void *)v60 + 2) = v58;
                            *((void *)v60 + 3) = v59;
                            unint64_t v61 = xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, v59);
                            if (!v61)
                            {
                              xmlRngPErr(a1, a2, 1116, "Use of unregistered type library '%s'\n", v59, 0LL);
                              *((void *)v10 + 5) = 0LL;
                              goto LABEL_158;
                            }

                            *((void *)v10 + 5) = v61;
                            int v62 = (unsigned int (*)(void, void))v61[2];
                            if (v62)
                            {
                              if (v62(v61[1], *((void *)v10 + 2)) == 1)
                              {
                                if (xmlStrEqual(v59, (const xmlChar *)"http://www.w3.org/2001/XMLSchema-datatypes")
                                  && (xmlStrEqual(*((const xmlChar **)v10 + 2), (const xmlChar *)"IDREF")
                                   || xmlStrEqual(*((const xmlChar **)v10 + 2), (const xmlChar *)"IDREFS")))
                                {
                                  *(_DWORD *)(a1 + 224) = 1;
                                }

      xmlElementType type = properties->type;
    }
  }

  return v5;
}

    if (v57 >= *(_DWORD *)(v50 + 12)) {
      uint64_t v66 = v58;
    }
    else {
      uint64_t v66 = 0;
    }
    if (v66 >= 1)
    {
      BOOL v45 = v66 & ~(v66 >> 31);
      xmlElementContentPtr v21 = v97;
      uint64_t v25 = v99;
      xmlElementContentPtr v22 = v50;
      a4 = v53;
      goto LABEL_85;
    }

    int v12 = v100;
    a4 = v53;
    if ((_DWORD)v100) {
      goto LABEL_124;
    }
LABEL_136:
    xmlEntityPtr v70 = v11;
LABEL_137:
    a1[1] = 0;
    xmlFARegExecRollBack((int *)a1);
    int v90 = *((void *)a1 + 13);
    if (!v90)
    {
LABEL_141:
      int v11 = v70;
      goto LABEL_142;
    }

    __n128 result = *a1;
    if ((_DWORD)result) {
      break;
    }
    unint64_t v83 = (xmlChar **)(v90 + 16LL * (int)a1[20]);
    int v84 = (uint64_t *)(v83 + 1);
LABEL_140:
    int v11 = *v83;
    xmlElementContentPtr v8 = *v84;
LABEL_142:
    __n128 result = *a1;
  }

  while (!(_DWORD)result);
  return result;
}

int xmlParseElementContentDecl(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlElementContentPtr *result)
{
  int id = ctxt->input->id;
  *__n128 result = 0LL;
  if (*ctxt->input->cur != 40)
  {
    xmlFatalErrMsgStr(ctxt, 54, (uint64_t)"xmlParseElementContentDecl : %s '(' expected\n", (uint64_t)name);
    return -1;
  }

  xmlNextChar(ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  xmlSkipBlankChars(ctxt);
  cur = ctxt->input->cur;
  if (*cur == 35 && cur[1] == 80 && cur[2] == 67 && cur[3] == 68 && cur[4] == 65 && cur[5] == 84 && cur[6] == 65)
  {
    uint64_t v7 = xmlParseElementMixedContentDecl(ctxt, id);
    int v8 = 3;
  }

  else
  {
    uint64_t v7 = xmlParseElementChildrenContentDeclPriv((uint64_t)ctxt, id, 1);
    int v8 = 4;
  }

  xmlSkipBlankChars(ctxt);
  *__n128 result = v7;
  return v8;
}

int xmlParseElementDecl(xmlParserCtxtPtr ctxt)
{
  xmlElementContentPtr result = 0LL;
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 33
    || cur[2] != 69
    || cur[3] != 76
    || cur[4] != 69
    || cur[5] != 77
    || cur[6] != 69
    || cur[7] != 78
    || cur[8] != 84)
  {
    goto LABEL_50;
  }

  int id = input->id;
  input->cur = cur + 9;
  input->col += 9;
  if (!cur[9]) {
    xmlParserInputGrow(input, 250);
  }
  if (!xmlSkipBlankChars(ctxt))
  {
    xmlParserCtxtPtr v16 = ctxt;
    int v17 = 65;
LABEL_49:
    xmlFatalErrMsg(v16, v17);
LABEL_50:
    LODWORD(v10) = -1;
    return v10;
  }

  int v5 = xmlParseName(ctxt);
  if (!v5)
  {
    xmlParserCtxtPtr v16 = ctxt;
    int v17 = 68;
    goto LABEL_49;
  }

  uint64_t v6 = v5;
  if (!xmlSkipBlankChars(ctxt)) {
    xmlFatalErrMsg(ctxt, 65);
  }
  xmlParserInputPtr v7 = ctxt->input;
  int v8 = v7->cur;
  unsigned int v9 = *v8;
  if (v9 <= 0x40)
  {
    if (v9 != 37)
    {
      if (v9 == 40)
      {
        uint64_t v19 = v6;
        uint64_t v10 = xmlParseElementContentDecl(ctxt, v6, &result);
        goto LABEL_20;
      }

      goto LABEL_48;
    }

    if (!ctxt->external && ctxt->inputNr == 1)
    {
      xmlParserCtxtPtr v16 = ctxt;
      int v17 = 21;
      goto LABEL_49;
    }

void xmlParseMarkupDecl(xmlParserCtxtPtr ctxt)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  cur = ctxt->input->cur;
  if (*cur == 60)
  {
    int v3 = cur[1];
    if (v3 == 63)
    {
      xmlParsePI(ctxt);
    }

    else if (v3 == 33)
    {
      unsigned int v4 = cur[2];
      if (v4 > 0x44)
      {
        if (v4 == 78)
        {
          xmlParseNotationDecl(ctxt);
        }

        else if (v4 == 69)
        {
          int v5 = cur[3];
          if (v5 == 78)
          {
            xmlParseEntityDecl(ctxt);
          }

          else if (v5 == 76)
          {
            xmlParseElementDecl(ctxt);
          }
        }
      }

      else if (v4 == 45)
      {
        xmlParseComment(ctxt);
      }

      else if (v4 == 65)
      {
        xmlParseAttributeListDecl(ctxt);
      }
    }
  }

  if (ctxt->instate != XML_PARSER_EOF) {
    ctxt->xmlParserInputState instate = XML_PARSER_DTD;
  }
}

void xmlParseTextDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 60
    || cur[1] != 63
    || cur[2] != 120
    || cur[3] != 109
    || cur[4] != 108
    || ((v5 = cur[5], unsigned int v4 = cur + 5, v6 = (1LL << v5) & 0x100002600LL, v5 <= 0x20) ? (v7 = v6 == 0) : (v7 = 1), v7))
  {
    xmlFatalErr(ctxt, 56, 0LL);
    return;
  }

  input->cur = v4;
  input->col += 5;
  if (!*v4) {
    xmlParserInputGrow(input, 250);
  }
  xmlParserInputState instate = ctxt->instate;
  ctxt->xmlParserInputState instate = XML_PARSER_START;
  if (!xmlSkipBlankChars(ctxt)) {
    xmlFatalErrMsg(ctxt, 65);
  }
  unsigned int v9 = xmlParseVersionInfo(ctxt);
  if (v9)
  {
    uint64_t v10 = v9;
    if (!xmlSkipBlankChars(ctxt)) {
      xmlFatalErrMsg(ctxt, 65);
    }
  }

  else
  {
    uint64_t v10 = xmlCharStrdup("1.0");
  }

  ctxt->input->version = v10;
  xmlParserInputPtr v11 = xmlParseEncodingDecl(ctxt);
  int errNo = ctxt->errNo;
  if (errNo != 32)
  {
    if (!v11 && !errNo) {
      xmlFatalErrMsg(ctxt, 101);
    }
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr v13 = ctxt->input;
    uint64_t v14 = v13->cur;
    int v15 = *v14;
    if (v15 == 62)
    {
      xmlFatalErr(ctxt, 57, 0LL);
    }

    else
    {
      if (v15 == 63 && v14[1] == 62)
      {
        v13->cur = v14 + 2;
        v13->col += 2;
        if (!v14[2]) {
          xmlParserInputGrow(v13, 250);
        }
        goto LABEL_34;
      }

      xmlFatalErr(ctxt, 57, 0LL);
      xmlParserInputPtr v16 = ctxt->input;
      for (unint64_t i = v16->cur; *i++ && *(i - 1) != 62; v16->cur = i)
        ;
    }

    xmlNextChar(ctxt);
  }

xmlChar *__cdecl xmlParseVersionInfo(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 118 || cur[1] != 101 || cur[2] != 114 || cur[3] != 115 || cur[4] != 105 || cur[5] != 111 || cur[6] != 110) {
    return 0LL;
  }
  input->cur = cur + 7;
  input->col += 7;
  if (!cur[7]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur != 61)
  {
    xmlParserCtxtPtr v6 = ctxt;
    int v7 = 75;
LABEL_19:
    xmlFatalErr(v6, v7, 0LL);
    return 0LL;
  }

  xmlNextChar(ctxt);
  xmlSkipBlankChars(ctxt);
  int v4 = *ctxt->input->cur;
  if (v4 == 39)
  {
    xmlNextChar(ctxt);
    unsigned int v5 = xmlParseVersionNum(ctxt);
    if (*ctxt->input->cur == 39) {
      goto LABEL_14;
    }
LABEL_17:
    xmlFatalErr(ctxt, 34, 0LL);
    return v5;
  }

  if (v4 != 34)
  {
    xmlParserCtxtPtr v6 = ctxt;
    int v7 = 33;
    goto LABEL_19;
  }

  xmlNextChar(ctxt);
  unsigned int v5 = xmlParseVersionNum(ctxt);
  if (*ctxt->input->cur != 34) {
    goto LABEL_17;
  }
LABEL_14:
  xmlNextChar(ctxt);
  return v5;
}

const xmlChar *__cdecl xmlParseEncodingDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  cur = input->cur;
  if (*cur != 101
    || cur[1] != 110
    || cur[2] != 99
    || cur[3] != 111
    || cur[4] != 100
    || cur[5] != 105
    || cur[6] != 110
    || cur[7] != 103)
  {
    return 0LL;
  }

  input->cur = cur + 8;
  input->col += 8;
  if (!cur[8]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur != 61)
  {
    xmlFatalErr(ctxt, 75, 0LL);
    return 0LL;
  }

  xmlNextChar(ctxt);
  xmlSkipBlankChars(ctxt);
  int v4 = *ctxt->input->cur;
  if (v4 == 39)
  {
    xmlNextChar(ctxt);
    unsigned int v5 = xmlParseEncName(ctxt);
    if (*ctxt->input->cur == 39) {
      goto LABEL_15;
    }
LABEL_28:
    xmlFatalErr(ctxt, 34, 0LL);
    goto LABEL_30;
  }

  if (v4 != 34)
  {
    xmlFatalErr(ctxt, 33, 0LL);
    unsigned int v5 = 0LL;
    if ((ctxt->options & 0x200000) == 0) {
      return v5;
    }
    goto LABEL_30;
  }

  xmlNextChar(ctxt);
  unsigned int v5 = xmlParseEncName(ctxt);
  if (*ctxt->input->cur != 34) {
    goto LABEL_28;
  }
LABEL_15:
  xmlNextChar(ctxt);
  if ((ctxt->options & 0x200000) != 0)
  {
LABEL_30:
    xmlFree(v5);
    return 0LL;
  }

  if (!v5) {
    return v5;
  }
  if (!xmlStrcasecmp(v5, (const xmlChar *)"UTF-16") || !xmlStrcasecmp(v5, (const xmlChar *)"UTF16"))
  {
    encoding = (xmlChar *)ctxt->encoding;
    if (encoding) {
      goto LABEL_38;
    }
    xmlParserInputBufferPtr buf = ctxt->input->buf;
    if (!buf || buf->encoder) {
      goto LABEL_39;
    }
    xmlFatalErrMsg(ctxt, 81);
LABEL_37:
    encoding = (xmlChar *)ctxt->encoding;
    if (!encoding)
    {
LABEL_39:
      ctxt->encoding = v5;
      return v5;
    }

LABEL_38:
    xmlFree(encoding);
    goto LABEL_39;
  }

  if (!xmlStrcasecmp(v5, (const xmlChar *)"UTF-8") || !xmlStrcasecmp(v5, (const xmlChar *)"UTF8")) {
    goto LABEL_37;
  }
  xmlParserInputPtr v6 = ctxt->input;
  int v7 = (xmlChar *)v6->encoding;
  if (v7)
  {
    xmlFree(v7);
    xmlParserInputPtr v6 = ctxt->input;
  }

  v6->encoding = v5;
  xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)v5);
  if (!CharEncodingHandler)
  {
    xmlFatalErrMsgStr(ctxt, 32, (uint64_t)"Unsupported encoding %s\n", (uint64_t)v5);
    return 0LL;
  }

  if (xmlSwitchToEncoding(ctxt, CharEncodingHandler) < 0)
  {
    unsigned int v5 = 0LL;
    ctxt->int errNo = 32;
  }

  return v5;
}

        xmlRngPErr(a1, *((void *)v6 + 1), 1068, "Found forbidden pattern attribute//element(ref)\n", 0LL, 0LL);
        xmlRngPErr(a1, *((void *)v6 + 1), 1068, "Found forbidden pattern attribute//element(ref)\n", 0LL, 0LL);
        goto LABEL_39;
      case 5:
        if ((a3 & 0x10) == 0)
        {
          uint64_t v23 = 5LL;
          goto LABEL_87;
        }

        int v30 = *((void *)v6 + 1);
        int v31 = a1;
        xmlElementContentPtr v32 = 1089;
        int v33 = "Found forbidden pattern start//data\n";
        goto LABEL_86;
      case 7:
        if ((a3 & 0x10) != 0)
        {
          int v30 = *((void *)v6 + 1);
          int v31 = a1;
          xmlElementContentPtr v32 = 1096;
          int v33 = "Found forbidden pattern start//value\n";
LABEL_86:
          xmlRngPErr(v31, v30, v32, v33, 0LL, 0LL);
          uint64_t v23 = *v6;
        }

        else
        {
          uint64_t v23 = 7LL;
        }

    xmlURIErrMemory((uint64_t)"escaping URI value\n");
    xmlFreeURI(v3);
    ((void (*)(unsigned __int8 *))xmlFree)(v1);
    return 0LL;
  }

  return v1;
}

  *(void *)(a1 + 112) = v2;
}

      if (((char)v6 & 0x80000000) == 0 || (uint64_t v10 = (xmlChar *)(v5 + 1), !v5[1]) || a2 && *(void *)(a2 + 112))
      {
        ++v5;
      }

      else
      {
        uint64_t v23 = 0;
        __srca = 0LL;
        if (__src != v5) {
          xmlBufAdd(v4, __src, ((_DWORD)v5 - (_DWORD)__src));
        }
        xmlParserInputPtr v11 = *v5;
        if (v11 <= 0xBF)
        {
          int v12 = 1400;
          xmlParserInputPtr v13 = a3;
          uint64_t v14 = "string is not in UTF-8\n";
          goto LABEL_65;
        }

        if (v11 <= 0xDF)
        {
          int v15 = (v11 & 0x1F) << 6;
          xmlParserInputPtr v16 = *v10;
          int v17 = 2LL;
          goto LABEL_56;
        }

        if (v11 > 0xEF)
        {
          if (v11 > 0xF7) {
            goto LABEL_64;
          }
          if (!v5[2]) {
            goto LABEL_64;
          }
          xmlParserInputPtr v16 = v5[3];
          if (!v16) {
            goto LABEL_64;
          }
          int v15 = (((v11 & 7) << 12) | ((*v10 & 0x3F) << 6) | v5[2] & 0x3F) << 6;
          int v17 = 4LL;
LABEL_56:
          int v18 = v15 | v16 & 0x3F;
          if (v18 > 0xFF)
          {
            if (v18 - 0x10000 >= 0x100000 && v18 >> 11 >= 0x1B && (v18 - 57344) >> 1 >= 0xFFF) {
              goto LABEL_64;
            }
          }

          else if (v18 <= 0x1F && (v18 > 0xD || ((1 << v18) & 0x2600) == 0))
          {
            goto LABEL_64;
          }

          uint64_t v19 = v17;
          xmlSerializeHexCharRef((uint64_t)&__srca, v18);
          xmlElementContentPtr result = (uint64x2_t *)xmlBufAdd(v4, (const xmlChar *)&__srca, 0xFFFFFFFFuLL);
          __src = &v5[v19];
          v5 += v19;
        }

        else
        {
          xmlParserInputPtr v16 = v5[2];
          if (v16)
          {
            int v15 = (*v10 & 0x3F | ((v11 & 0xF) << 6)) << 6;
            int v17 = 3LL;
            goto LABEL_56;
          }

  if (*(_DWORD *)a1 == 1)
  {
    if (v28->builtInType == 28)
    {
      int v30 = *(void *)(a1 + 64);
      int v31 = 0LL;
      xmlElementContentPtr v32 = a2;
      goto LABEL_48;
    }

  v12[3] = xmlSchemaParseModelGroup(a1, a2, v17, v18, 0);
  int v17 = *(void *)(v17 + 48);
  if (v17) {
    goto LABEL_39;
  }
}

  if (v8 != 4)
  {
    xmlElementContentPtr v22 = *(void **)(a2 + 56);
    if (v22)
    {
      if (*(_DWORD *)v22 != 25
        || ((uint64_t v23 = (int *)v22[3], v24 = *v23, *v23 != 6) ? (v25 = v24 == 8) : (v25 = 1),
            !v25 && (v24 != 7 || *((_DWORD *)v22 + 8)) || *((void *)v23 + 3)))
      {
        int v34 = 0;
        goto LABEL_88;
      }

      xmlParserInputPtr v26 = *(_DWORD *)(a2 + 88);
      if ((v26 & 1) != 0)
      {
        if (v24 == 6)
        {
LABEL_84:
          int v34 = 1;
LABEL_88:
          *(_DWORD *)(a2 + 92) = 2;
          int v35 = *(_DWORD *)(a2 + 88);
          if ((v35 & 4) != 0 || v6->contentType == XML_SCHEMA_CONTENT_EMPTY)
          {
            if ((v35 & 1) != 0) {
              *(_DWORD *)(a2 + 92) = 3;
            }
          }

          else
          {
            if ((v35 & 1) != 0) {
              *(_DWORD *)(a2 + 92) = 3;
            }
            int v36 = v22[3];
            if (v36 && *(_DWORD *)v36 == 8)
            {
              ComponentNode = xmlSchemaGetComponentNode((_DWORD *)a2);
              xmlSchemaCustomErr4( (_DWORD *)a1,  3091,  ComponentNode,  0LL,  (const xmlChar *)"The type has an 'all' model group in its {content type} and thus cannot be derived from a non-empty type, since this would produce a 'sequence' model group containing the 'al l' model group; 'all' model groups are not allowed to appear inside other model groups",
                0LL,
                0LL,
                0LL,
                0LL);
              goto LABEL_110;
            }

            subtypes = v6->subtypes;
            if (!subtypes) {
              goto LABEL_109;
            }
            int id = subtypes->id;
            if (id && *(_DWORD *)id == 8)
            {
              uint64_t v40 = xmlSchemaGetComponentNode((_DWORD *)a2);
              xmlSchemaCustomErr4( (_DWORD *)a1,  3091,  v40,  0LL,  (const xmlChar *)"A type cannot be derived by extension from a type which has an 'all' model group in its {content type}, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups",
                0LL,
                0LL,
                0LL,
                0LL);
              goto LABEL_110;
            }

            if ((v34 & 1) == 0)
            {
              uint64_t v74 = xmlSchemaAddParticle(a1, *(void *)(a2 + 72), 1, 1);
              if (!v74) {
                goto LABEL_19;
              }
              int v75 = v74;
              uint64_t v76 = xmlSchemaAddModelGroup(a1, *(void *)(a1 + 64), 6, *(void *)(a2 + 72));
              v75[3] = v76;
              if (!v76) {
                goto LABEL_19;
              }
              *(void *)(a2 + 56) = v75;
              int v77 = xmlSchemaAddParticle(a1, *(void *)(a2 + 72), (int)v6->subtypes->ref, HIDWORD(v6->subtypes->ref));
              *(void *)(v75[3] + 24LL) = v77;
              if (!v77) {
                goto LABEL_19;
              }
              uint64_t v78 = v6->subtypes->id;
              v77[2] = v22;
              v77[3] = v78;
            }

            else
            {
LABEL_109:
              *(void *)(v36 + 24) = subtypes;
            }
          }

          goto LABEL_110;
        }

void xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (!ctxt->encoding)
  {
    cur = ctxt->input->cur;
    if (ctxt->input->end - cur >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)cur;
      xmlCharEncoding v7 = xmlDetectCharEncoding(in, 4);
      if (v7) {
        xmlSwitchEncoding(ctxt, v7);
      }
    }
  }

  int v8 = ctxt->input->cur;
  if (*v8 == 60 && v8[1] == 63 && v8[2] == 120 && v8[3] == 109 && v8[4] == 108)
  {
    xmlParseTextDecl(ctxt);
    if (ctxt->errNo == 32)
    {
      xmlHaltParser(ctxt);
      return;
    }
  }

  xmlDocPtr myDoc = ctxt->myDoc;
  if (!myDoc)
  {
    xmlDocPtr myDoc = xmlNewDoc((const xmlChar *)"1.0");
    ctxt->xmlDocPtr myDoc = myDoc;
    if (!myDoc)
    {
      htmlErrMemory(ctxt, (uint64_t)"New Doc failed");
      return;
    }

    myDoc->int properties = 64;
  }

  ctxt->xmlParserInputState instate = XML_PARSER_DTD;
  ctxt->external = 1;
  xmlSkipBlankChars(ctxt);
  xmlParserInputPtr input = ctxt->input;
  xmlParserInputPtr v11 = input->cur;
  while (1)
  {
    int v12 = *v11;
    if (v12 != 37)
    {
      if (v12 != 60) {
        goto LABEL_38;
      }
      int v13 = v11[1];
      if (v13 != 63 && v13 != 33) {
        goto LABEL_39;
      }
    }

    uint64_t consumed_low = LODWORD(input->consumed);
    if (ctxt->progressive)
    {
      int v15 = v11;
    }

    else
    {
      uint64_t v16 = input->end - v11;
      int v15 = v11;
      if (v16 <= 249)
      {
        xmlGROW((uint64_t)ctxt);
        int v15 = ctxt->input->cur;
        int v12 = *v15;
      }
    }

    if (v12 == 60 && v15[1] == 33 && v15[2] == 91) {
      xmlParseConditionalSections((uint64_t)ctxt);
    }
    else {
      xmlParseMarkupDecl(ctxt);
    }
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr input = ctxt->input;
    BOOL v17 = input->cur == v11;
    xmlParserInputPtr v11 = input->cur;
    if (v17)
    {
      xmlParserInputPtr v11 = input->cur;
      if (consumed_low == input->consumed) {
        break;
      }
    }
  }

  xmlFatalErr(ctxt, 60, 0LL);
  int v12 = *ctxt->input->cur;
LABEL_38:
  if (!v12) {
    return;
  }
LABEL_39:
  xmlFatalErr(ctxt, 60, 0LL);
}

const xmlChar *xmlDetectSAX2(const xmlChar *result)
{
  if (result)
  {
    int v1 = (xmlChar *)result;
    uint64_t v2 = *(void *)result;
    if (*(void *)result
      && *(_DWORD *)(v2 + 216) == -554844497
      && ((*(void *)(v2 + 232) || !*(void *)(v2 + 112)) && (*(void *)(v2 + 240) || !*(void *)(v2 + 120))
       || *((_DWORD *)result + 13)
       || !os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
       || xmlDetectSAX2_cold_1((_DWORD *)(v2 + 216)))
      && (*(void *)(v2 + 232) || *(void *)(v2 + 240) || !*(void *)(v2 + 112) && !*(void *)(v2 + 120)))
    {
      *((_DWORD *)v1 + 126) = 1;
    }

    *((void *)v1 + 60) = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"xml", 3);
    *((void *)v1 + 6htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"xmlns", 5);
    xmlElementContentPtr result = xmlDictLookup(*((xmlDictPtr *)v1 + 57), (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
    *((void *)v1 + 62) = result;
    if (!*((void *)v1 + 60) || !*((void *)v1 + 61) || !result) {
      return (const xmlChar *)htmlErrMemory(v1, 0LL);
    }
  }

  return result;
}

void xmlParseConditionalSections(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 272) == -1)
  {
    uint64_t v2 = 0LL;
    goto LABEL_84;
  }

  uint64_t v2 = 0LL;
  unint64_t v3 = 0LL;
  unint64_t v4 = 0LL;
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 56);
    xmlParserInputPtr v6 = *(unsigned __int8 **)(v5 + 32);
    int v7 = *v6;
    if (v7 == 60) {
      break;
    }
    if (!v3 || v7 != 93 || v6[1] != 93 || v6[2] != 62) {
      goto LABEL_36;
    }
    if (*(_DWORD *)(v5 + 100) != v2[--v3])
    {
      xmlFatalErrMsg((_DWORD *)a1, 90);
      uint64_t v5 = *(void *)(a1 + 56);
      xmlParserInputPtr v6 = *(unsigned __int8 **)(v5 + 32);
    }

    *(void *)(v5 + 32) = v6 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v6[3]) {
LABEL_78:
    }
      xmlParserInputGrow((xmlParserInputPtr)v5, 250);
LABEL_38:
    if (v3)
    {
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      if (!*(_DWORD *)(a1 + 452)
        && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
      {
        xmlGROW(a1);
      }

      if (*(_DWORD *)(a1 + 272) != -1) {
        continue;
      }
    }

    goto LABEL_84;
  }

  if (v6[1] != 33 || v6[2] != 91)
  {
LABEL_36:
    uint64_t v14 = *(unsigned int *)(v5 + 64);
    xmlParseMarkupDecl((xmlParserCtxtPtr)a1);
    uint64_t v15 = *(void *)(a1 + 56);
    uint64_t v23 = (_DWORD *)a1;
    int v24 = 60;
    goto LABEL_83;
  }

  int v8 = *(_DWORD *)(v5 + 100);
  *(void *)(v5 + 32) = v6 + 3;
  *(_DWORD *)(v5 + 56) += 3;
  if (!v6[3]) {
    xmlParserInputGrow((xmlParserInputPtr)v5, 250);
  }
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  unsigned int v9 = *(xmlParserInput **)(a1 + 56);
  cur = v9->cur;
  if (*cur != 73) {
    goto LABEL_80;
  }
  int v11 = cur[1];
  if (v11 != 71)
  {
    if (v11 == 78 && cur[2] == 67 && cur[3] == 76 && cur[4] == 85 && cur[5] == 68 && cur[6] == 69)
    {
      v9->cur = cur + 7;
      v9->col += 7;
      if (!cur[7]) {
        xmlParserInputGrow(v9, 250);
      }
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      uint64_t v12 = *(void *)(a1 + 56);
      if (**(_BYTE **)(v12 + 32) == 91)
      {
        if (*(_DWORD *)(v12 + 100) != v8) {
          xmlFatalErrMsg((_DWORD *)a1, 90);
        }
        xmlNextChar((xmlParserCtxtPtr)a1);
        if (v4 <= v3)
        {
          if (v4) {
            v4 *= 2LL;
          }
          else {
            unint64_t v4 = 4LL;
          }
          int v13 = xmlRealloc(v2, 4 * v4);
          if (!v13)
          {
LABEL_85:
            htmlErrMemory((_DWORD *)a1, 0LL);
            goto LABEL_84;
          }

          uint64_t v2 = v13;
        }

        v2[v3++] = v8;
        goto LABEL_38;
      }

      goto LABEL_82;
    }

LABEL_74:
  *(_DWORD *)(a1 + 332) = v17;
  *(_DWORD *)(a1 + 272) = v18;
  if (*v20)
  {
    if (*(_DWORD *)(v5 + 100) != v8)
    {
      xmlFatalErrMsg((_DWORD *)a1, 90);
      uint64_t v5 = *(void *)(a1 + 56);
      xmlElementContentPtr v20 = *(unsigned __int8 **)(v5 + 32);
    }

    *(void *)(v5 + 32) = v20 + 3;
    *(_DWORD *)(v5 + 56) += 3;
    if (!v20[3]) {
      goto LABEL_78;
    }
    goto LABEL_38;
  }

  xmlFatalErr((_DWORD *)a1, 59, 0LL);
LABEL_84:
  xmlFree(v2);
}

    uint64_t v23 = 0;
LABEL_90:
    xmlSchemaPContentErr(a1, 3033, (uint64_t)a3, children, 0LL, (xmlChar *)"(annotation?, (restriction | list | union))");
    goto LABEL_91;
  }

  int v24 = *(void *)(a1 + 160);
  *(_DWORD *)(v24 + 88) |= 0x40u;
  *(void *)(v24 + 112) = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
  uint64_t v25 = *(void *)(children + 88);
  if (v25)
  {
    while (1)
    {
      xmlParserInputPtr v26 = *(void *)(v25 + 72);
      if (!v26) {
        break;
      }
      if (xmlStrEqual(*(const xmlChar **)(v26 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
        goto LABEL_54;
      }
LABEL_57:
      uint64_t v25 = *(void *)(v25 + 48);
      if (!v25) {
        goto LABEL_58;
      }
    }

    if (xmlStrEqual(*(const xmlChar **)(v25 + 16), (const xmlChar *)"id")
      || xmlStrEqual(*(const xmlChar **)(v25 + 16), (const xmlChar *)"itemType"))
    {
      goto LABEL_57;
    }

void xmlParseReference(xmlParserCtxtPtr ctxt)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  xmlNodePtr cur = 0LL;
  int v1 = ctxt->input->cur;
  if (*v1 != 38) {
    return;
  }
  if (v1[1] != 35)
  {
    xmlEntityPtr v9 = xmlParseEntityRef(ctxt);
    if (!v9 || !ctxt->wellFormed) {
      return;
    }
    uint64_t v10 = (uint64_t)v9;
    if (!v9->name || (exmlElementType type = v9->etype, etype == XML_INTERNAL_PREDEFINED_ENTITY))
    {
      content = v9->content;
      if (content && ctxt->sax && ctxt->sax->characters && !ctxt->disableSAX)
      {
        charactersSAXFunc characters = ctxt->sax->characters;
        userData = ctxt->userData;
        uint64_t v14 = xmlStrlen(content);
        ((void (*)(void *, const xmlChar *, uint64_t))characters)(userData, content, v14);
      }

      return;
    }

    int checked = v9->checked;
    if (!checked || !v9->children && (ctxt->options & 2) != 0)
    {
      if (etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)
      {
        p_unint64_t nbentities = &ctxt->nbentities;
        unint64_t nbentities = ctxt->nbentities;
        if (etype != XML_INTERNAL_GENERAL_ENTITY)
        {
          xmlErrMsgStr(ctxt, 1, (uint64_t)"invalid entity type found\n", 0LL);
          int v31 = 88;
LABEL_76:
          unint64_t v35 = *p_nbentities - nbentities;
          if (v35 + 1 < 0x3FFFFFFF) {
            int v36 = v35 + 1;
          }
          else {
            int v36 = 0x3FFFFFFF;
          }
          *(_DWORD *)(v10 + 132) = 2 * v36;
          uint64_t v37 = *(const xmlChar **)(v10 + 80);
          if (v37 && xmlStrchr(v37, 0x3Cu)) {
            *(_DWORD *)(v10 + 132) |= 1u;
          }
          if (v31 == 111 || v31 == 89)
          {
            xmlFatalErr(ctxt, v31, 0LL);
            xmlHaltParser(ctxt);
LABEL_86:
            xmlFreeNodeList(cur);
            return;
          }

          xmlNodePtr v43 = cur;
          if (v31 || !cur)
          {
            if (v31 && v31 != 27)
            {
              xmlFatalErrMsgStr(ctxt, 26, (uint64_t)"Entity '%s' failed to parse\n", *(void *)(v10 + 16));
              charactersSAXFunc v59 = *(_BYTE **)(v10 + 80);
              if (v59) {
                *charactersSAXFunc v59 = 0;
              }
              xmlParserEntityCheck((uint64_t)ctxt, 0LL, v10, 0LL);
LABEL_133:
              if (!*(_DWORD *)(v10 + 132)) {
                *(_DWORD *)(v10 + 132) = 2;
              }
              p_xmlNodePtr children = (xmlNode **)(v10 + 24);
              if (!*(void *)(v10 + 24)) {
                goto LABEL_136;
              }
              goto LABEL_47;
            }

            if (!cur) {
              goto LABEL_133;
            }
          }

          else
          {
            int v44 = *(_DWORD *)(v10 + 92);
            if ((v44 - 1) <= 1 && !*(void *)(v10 + 24))
            {
              *(void *)(v10 + 24) = cur;
              if (ctxt->replaceEntities
                && ctxt->parseMode != XML_PARSE_READER
                && (v43->type != XML_TEXT_NODE || v43->next))
              {
                *(_DWORD *)(v10 + 128) = 0;
                xmlNodePtr node = ctxt->node;
                xmlDocPtr myDoc = ctxt->myDoc;
                p_private = &v43->_private;
                do
                {
                  uint64_t v63 = p_private;
                  p_private[5] = node;
                  p_private[8] = myDoc;
                  p_private = (void *)p_private[6];
                }

                while (p_private);
                *(void *)(v10 + 32) = v63;
                if (v44 == 2 && xmlEntityRefFunc) {
                  xmlEntityRefFunc(v10, v43, 0LL);
                }
                goto LABEL_133;
              }

              *(_DWORD *)(v10 + 128) = 1;
              v43->parent = (_xmlNode *)v10;
              BOOL v45 = *(xmlDoc **)(v10 + 64);
              next = v43;
              while (1)
              {
                xmlSetTreeDoc(next, v45);
                next = cur->next;
                if (!next) {
                  break;
                }
                xmlNodePtr cur = cur->next;
                next->parent = (_xmlNode *)v10;
                BOOL v45 = *(xmlDoc **)(v10 + 64);
              }

              *(void *)(v10 + 32) = cur;
LABEL_132:
              xmlNodePtr cur = 0LL;
              goto LABEL_133;
            }
          }

          xmlFreeNodeList(cur);
          goto LABEL_132;
        }

        if (ctxt->userData == ctxt) {
          int v30 = 0LL;
        }
        else {
          int v30 = (xmlParserCtxt *)ctxt->userData;
        }
        ++ctxt->depth;
        int v24 = xmlParseBalancedChunkMemoryInternal((uint64_t)ctxt, v9->content, v30, &cur);
LABEL_67:
        int v31 = v24;
        --ctxt->depth;
        goto LABEL_76;
      }

      if ((ctxt->options & 0x12) != 0)
      {
        p_unint64_t nbentities = &ctxt->nbentities;
        unint64_t nbentities = ctxt->nbentities;
        sax = ctxt->sax;
        if (ctxt->userData == ctxt) {
          xmlElementContentPtr v22 = 0LL;
        }
        else {
          xmlElementContentPtr v22 = ctxt->userData;
        }
        int v23 = ctxt->depth + 1;
        ctxt->int depth = v23;
        int v24 = xmlParseExternalEntityPrivate( (uint64_t)ctxt->myDoc,  (uint64_t)ctxt,  sax,  v22,  v23,  v9->URI,  (const char *)v9->ExternalID,  &cur);
        goto LABEL_67;
      }
    }

    if (checked != 1)
    {
      if (checked >= 0) {
        int v25 = v9->checked;
      }
      else {
        int v25 = checked + 1;
      }
      ctxt->nbentities += v25 >> 1;
    }

    p_xmlNodePtr children = &v9->children;
    if (!v9->children)
    {
      if (checked)
      {
        if (ctxt->userData == ctxt) {
          xmlElementContentPtr v32 = 0LL;
        }
        else {
          xmlElementContentPtr v32 = (xmlParserCtxt *)ctxt->userData;
        }
        if (etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
        {
          p_int depth = &ctxt->depth;
          int v47 = ctxt->depth + 1;
          ctxt->int depth = v47;
          int v34 = xmlParseExternalEntityPrivate( (uint64_t)ctxt->myDoc,  (uint64_t)ctxt,  ctxt->sax,  v32,  v47,  v9->URI,  (const char *)v9->ExternalID,  0LL);
        }

        else
        {
          if (etype != XML_INTERNAL_GENERAL_ENTITY)
          {
            xmlErrMsgStr(ctxt, 1, (uint64_t)"invalid entity type found\n", 0LL);
            goto LABEL_136;
          }

          p_int depth = &ctxt->depth;
          ++ctxt->depth;
          int v34 = xmlParseBalancedChunkMemoryInternal((uint64_t)ctxt, v9->content, v32, 0LL);
        }

        --*p_depth;
        if (v34 == 89)
        {
          xmlFatalErr(ctxt, 89, 0LL);
          return;
        }
      }

LABEL_136:
      if (!ctxt->sax) {
        return;
      }
      referenceSAXFunc reference = ctxt->sax->reference;
      if (!reference || ctxt->replaceEntities || ctxt->disableSAX) {
        return;
      }
      goto LABEL_140;
    }

  int v24 = next;
  if (next)
  {
    if (!next->ns
      || !xmlStrEqual(next->name, (const xmlChar *)"anyAttribute")
      || !xmlStrEqual(v24->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      unint64_t v48 = 0;
      goto LABEL_146;
    }

    unint64_t v48 = 0;
    *(void *)(PropNode + 152) = xmlSchemaParseAnyAttribute((_DWORD *)a1, a2, v24);
LABEL_142:
    int v24 = v24->next;
    next = v24;
    if (v24) {
LABEL_146:
    }
      xmlSchemaPContentErr( a1,  3033,  a3,  (uint64_t)v24,  0LL,  (xmlChar *)"(annotation?, (simpleContent | complexContent | ((group | all | choice | sequence)?, ((attribute | at tributeGroup)*, anyAttribute?))))");
  }

  else
  {
    unint64_t v48 = 0;
  }

LABEL_47:
    if (ctxt->sax)
    {
      referenceSAXFunc reference = ctxt->sax->reference;
      if (reference)
      {
        if (!ctxt->replaceEntities && !ctxt->disableSAX)
        {
LABEL_140:
          uint64_t v16 = ctxt->userData;
          int v17 = *(xmlChar **)(v10 + 16);
          goto LABEL_31;
        }
      }
    }

    if (!ctxt->replaceEntities || !ctxt->node) {
      return;
    }
    if (cur)
    {
      if (ctxt->parseMode != XML_PARSE_READER)
      {
        if (ctxt->inputNr < 1)
        {
          xmlElementContentPtr v27 = xmlDictLookup(ctxt->dict, (const xmlChar *)"nbktext", -1);
          int v28 = *p_children;
          if ((*p_children)->type == XML_TEXT_NODE) {
            v28->name = v27;
          }
          uint64_t v29 = *(void *)(v10 + 32);
          if ((xmlNode *)v29 != v28 && *(_DWORD *)(v29 + 8) == 3) {
            *(void *)(v29 + 16) = v27;
          }
          xmlAddChildList(ctxt->node, v28);
          goto LABEL_162;
        }

        xmlRelaxNGFreeStates(a1, (void **)v7);
        uint64_t v29 = *(void ***)(a1 + 104);
        if (v29)
        {
          xmlRelaxNGFreeStates(a1, v29);
          *(void *)(a1 + 104) = 0LL;
        }

        uint64_t v10 = 0xFFFFFFFFLL;
LABEL_54:
        if (*v4 && *v8)
        {
          int v30 = *__xmlGenericError();
          int v31 = __xmlGenericErrorContext();
          v30( *v31,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c",  10770);
          xmlRelaxNGFreeValidState(a1, *(void **)(a1 + 96));
          int v8 = v4;
LABEL_57:
          *int v8 = 0LL;
        }

        return v10;
      }
    }

    int v23 = *v8;
    if (*v8)
    {
      if (!v17)
      {
        *int v8 = 0LL;
        if (v16 >= 1)
        {
          int v28 = 0LL;
          do
          {
            xmlRelaxNGAddStates(a1, v23, *(void *)(*((void *)v7 + 1) + v28));
            v28 += 8LL;
          }

          while (8LL * v16 != v28);
        }

        int v17 = v23;
        goto LABEL_35;
      }

      if (*v23 >= 1)
      {
        int v24 = 0LL;
        do
        {
          xmlRelaxNGAddStates(a1, v17, *(void *)(*((void *)v23 + 1) + 8 * v24++));
          int v23 = *(int **)(a1 + 104);
        }

        while (v24 < *v23);
      }

      int v25 = a1;
      xmlParserInputPtr v26 = v23;
LABEL_33:
      xmlRelaxNGFreeStates(v25, (void **)v26);
      xmlElementContentPtr v22 = (int **)(a1 + 104);
    }

    else if (v17)
    {
      xmlRelaxNGAddStates(a1, v17, (uint64_t)v19);
LABEL_21:
      xmlElementContentPtr v22 = v4;
    }

    else
    {
      *(void *)(*((void *)v7 + 1) + 8LL * v16) = v19;
      xmlElementContentPtr v22 = v4;
      ++v16;
    }

    *xmlElementContentPtr v22 = 0LL;
    goto LABEL_35;
  }

  *(void *)(a1 + 96) = **((void **)v7 + 1);
  xmlRelaxNGFreeStates(a1, (void **)v7);
  *(void *)(a1 + 104) = 0LL;
LABEL_7:
  uint64_t v10 = xmlRelaxNGValidateState(a1, a2);
  if (*(void *)(a1 + 96))
  {
    if (!*v8) {
      return v10;
    }
    int v11 = *__xmlGenericError();
    uint64_t v12 = __xmlGenericErrorContext();
    v11( *v12,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c",  10679);
    xmlRelaxNGFreeValidState(a1, *(void **)(a1 + 96));
    *(void *)(a1 + 96) = 0LL;
  }

  int v13 = *v8;
  if (*v8 && *v13 == 1)
  {
    *(void *)(a1 + 96) = **((void **)v13 + 1);
    xmlRelaxNGFreeStates(a1, (void **)v13);
    goto LABEL_57;
  }

  return v10;
}

      if ((v18 - 192) < 0x17
        || (v18 & 0xFFFFFFDF) - 65 < 0x1A
        || v18 > 247
        || (v18 - 216) < 0x1F
        || v18 == 95)
      {
        goto LABEL_64;
      }

      return 1;
    }
  }

  else if (v17 < 256)
  {
    goto LABEL_47;
  }

LABEL_149:
    if (*(_DWORD *)(v10 + 92) == 2)
    {
      int v56 = (void (*)(uint64_t, xmlNode *, xmlNodePtr))xmlEntityRefFunc;
      if (xmlEntityRefFunc)
      {
        uint64_t v57 = v10;
        uint64_t v58 = v40;
LABEL_161:
        v56(v57, v58, v42);
      }
    }

  xmlElementContentPtr result = 0LL;
  *(void *)(a1 + 192) = *(void *)(*(void *)(a1 + 176) + 8LL * *(int *)(a1 + 172));
  return result;
}

LABEL_162:
    *(void *)&ctxt->nodeint len = 0LL;
    return;
  }

  *(void *)out = 0LL;
  uint64_t v67 = 0LL;
  int v3 = v1[2];
  int v4 = xmlParseCharRef(ctxt);
  if (!v4) {
    return;
  }
  if (ctxt->charset == 1)
  {
    uint64_t v5 = xmlCopyCharMultiByte(out, v4);
    out[(int)v5] = 0;
    if (ctxt->sax)
    {
      charactersSAXFunc v6 = ctxt->sax->characters;
      if (v6)
      {
        if (!ctxt->disableSAX)
        {
          uint64_t v7 = v5;
          int v8 = ctxt->userData;
LABEL_23:
          ((void (*)(void *, xmlChar *, uint64_t))v6)(v8, out, v7);
          return;
        }
      }
    }

    return;
  }

  if (v4 > 255)
  {
    if ((v3 & 0xFFFFFFDF) == 0x58) {
      snprintf((char *)out, 0x10uLL, "#x%X");
    }
    else {
      snprintf((char *)out, 0x10uLL, "#%d");
    }
    if (!ctxt->sax) {
      return;
    }
    referenceSAXFunc reference = ctxt->sax->reference;
    if (!reference || ctxt->disableSAX) {
      return;
    }
    uint64_t v16 = ctxt->userData;
    int v17 = out;
LABEL_31:
    ((void (*)(void *, xmlChar *))reference)(v16, v17);
    return;
  }

  out[0] = v4;
  out[1] = 0;
  if (ctxt->sax)
  {
    charactersSAXFunc v6 = ctxt->sax->characters;
    if (v6)
    {
      if (!ctxt->disableSAX)
      {
        int v8 = ctxt->userData;
        uint64_t v7 = 1LL;
        goto LABEL_23;
      }
    }
  }

        uint64_t v68 = v1[74];
        if ((int)v68 >= 1)
        {
          int v69 = (uint64_t *)*((void *)v1 + 36);
          while (1)
          {
            xmlEntityPtr v70 = *v69;
            if (*(_DWORD *)(*v69 + 92) == 1) {
              break;
            }
            ++v69;
            if (!--v68) {
              goto LABEL_170;
            }
          }

          values[0] = 0LL;
          if (xmlSchemaProcessXSIType((uint64_t)v1, v70, (uint64_t)values, v46) == -1)
          {
            uint64_t v66 = "xmlSchemaValidateElemDecl";
            uint64_t v67 = "calling xmlSchemaProcessXSIType() to process the attribute 'xsi:type'";
LABEL_225:
            xmlSchemaInternalErr2(v1, (const xmlChar *)v66, (const xmlChar *)v67, 0LL);
            goto LABEL_226;
          }

          uint64_t v71 = values[0];
          if (values[0])
          {
            *(_DWORD *)(*((void *)v1 + 24) + 64LL) |= 8u;
            uint64_t v58 = v71;
          }
        }
      }

xmlEntityPtr xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->instate == XML_PARSER_EOF || *ctxt->input->cur != 38) {
    return 0LL;
  }
  xmlNextChar(ctxt);
  uint64_t v2 = xmlParseName(ctxt);
  if (!v2)
  {
    xmlFatalErrMsg(ctxt, 68);
    return 0LL;
  }

  if (*ctxt->input->cur != 59)
  {
    xmlFatalErr(ctxt, 23, 0LL);
    return 0LL;
  }

  int v3 = v2;
  xmlNextChar(ctxt);
  if ((ctxt->options & 0x100000) == 0)
  {
    xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(v3);
    if (PredefinedEntity) {
      return PredefinedEntity;
    }
  }

  ++ctxt->nbentities;
  if (!ctxt->sax) {
    goto LABEL_24;
  }
  getxmlEntityPtr Entity = ctxt->sax->getEntity;
  if (getEntity) {
    xmlEntityPtr PredefinedEntity = (xmlEntityPtr)((uint64_t (*)(void *, const xmlChar *))getEntity)(ctxt->userData, v3);
  }
  else {
    xmlEntityPtr PredefinedEntity = 0LL;
  }
  int wellFormed = ctxt->wellFormed;
  if (wellFormed == 1 && !PredefinedEntity)
  {
    if ((ctxt->options & 0x100000) != 0)
    {
      xmlEntityPtr PredefinedEntity = xmlGetPredefinedEntity(v3);
      int wellFormed = ctxt->wellFormed;
    }

    else
    {
      xmlEntityPtr PredefinedEntity = 0LL;
      int wellFormed = 1;
    }
  }

  if (wellFormed == 1 && !PredefinedEntity)
  {
    if (ctxt->userData != ctxt)
    {
LABEL_24:
      xmlEntityPtr PredefinedEntity = 0LL;
      goto LABEL_25;
    }

    xmlEntityPtr PredefinedEntity = xmlSAX2GetEntity(ctxt, v3);
  }

uint64_t xmlParseBalancedChunkMemoryInternal(uint64_t a1, xmlChar *str, xmlParserCtxt *a3, void *a4)
{
  uint64_t v4 = (uint64_t)a4;
  int v8 = *(_DWORD *)(a1 + 392);
  if (a4) {
    *a4 = 0LL;
  }
  if (!str) {
    return 1LL;
  }
  int v10 = xmlStrlen(str);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)str, v10);
  if (!MemoryParserCtxt) {
    return 27LL;
  }
  uint64_t v12 = (uint64_t)MemoryParserCtxt;
  if (a3) {
    xmlParserCtxtPtr v13 = a3;
  }
  else {
    xmlParserCtxtPtr v13 = MemoryParserCtxt;
  }
  MemoryParserCtxt->userData = v13;
  dict = MemoryParserCtxt->dict;
  if (dict) {
    xmlDictFree(dict);
  }
  uint64_t v15 = *(xmlDict **)(a1 + 456);
  *(void *)(v12 + 456) = v15;
  *(_DWORD *)(v12 + 736) = *(_DWORD *)(a1 + 736) + 1;
  *(void *)(v12 + 480) = xmlDictLookup(v15, (const xmlChar *)"xml", 3);
  *(void *)(v12 + 488) = xmlDictLookup(*(xmlDictPtr *)(v12 + 456), (const xmlChar *)"xmlns", 5);
  *(void *)(v12 + 496) = xmlDictLookup( *(xmlDictPtr *)(v12 + 456),  (const xmlChar *)"http://www.w3.org/XML/1998/namespace",  36);
  if (*(int *)(a1 + 508) >= 1)
  {
    uint64_t v16 = 0LL;
    do
    {
      nsPush(v12, *(void *)(*(void *)(a1 + 520) + 8 * v16), *(void *)(*(void *)(a1 + 520) + 8 * v16 + 8));
      v16 += 2LL;
    }

    while (*(_DWORD *)(a1 + 508) > (int)v16);
  }

  uint64_t v17 = *(void *)v12;
  *(void *)uint64_t v12 = *(void *)a1;
  xmlDetectSAX2((const xmlChar *)v12);
  *(_DWORD *)(v12 + 28) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(v12 + 564) = *(_DWORD *)(a1 + 564);
  *(void *)(v12 + 424) = *(void *)(a1 + 424);
  xmlDocPtr v18 = *(xmlDocPtr *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 0LL;
    *(void *)(v12 + 16) = v18;
    __int128 v34 = *(_OWORD *)&v18->children;
    goto LABEL_25;
  }

  xmlDocPtr v20 = xmlNewDoc((const xmlChar *)"1.0");
  if (!v20)
  {
    *(void *)uint64_t v12 = v17;
    *(void *)(v12 + 456) = 0LL;
    xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
    return 1LL;
  }

  xmlDocPtr v18 = v20;
  v20->int properties = 64;
  int v21 = *(xmlDict **)(v12 + 456);
  v18->dict = v21;
  xmlDictReference(v21);
  *(void *)(v12 + 16) = v18;
  __int128 v34 = 0u;
  uint64_t v19 = v18;
LABEL_25:
  xmlNodePtr v22 = xmlNewDocNode(v18, 0LL, (const xmlChar *)"pseudoroot", 0LL);
  if (!v22)
  {
    *(void *)uint64_t v12 = v17;
    *(void *)(v12 + 456) = 0LL;
    xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
    if (v19) {
      xmlFreeDoc(v19);
    }
    return 1LL;
  }

  int v23 = v22;
  int v24 = *(xmlNode **)(v12 + 16);
  v24->xmlNodePtr children = 0LL;
  v24->last = 0LL;
  xmlAddChild(v24, v23);
  nodePush((xmlParserCtxtPtr)v12, *(xmlNodePtr *)(*(void *)(v12 + 16) + 24LL));
  *(_DWORD *)(v12 + 272) = 7;
  *(_DWORD *)(v12 + 392) = *(_DWORD *)(a1 + 392) + 1;
  *(_DWORD *)(v12 + 156) = 0;
  int v25 = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(v12 + 432) = v25;
  if (*(_DWORD *)(a1 + 156) || *(_DWORD *)(a1 + 28)) {
    *(_DWORD *)(v12 + 432) = v25 | 8;
  }
  *(_DWORD *)(v12 + 568) = *(_DWORD *)(a1 + 568);
  *(_OWORD *)(v12 + 544) = *(_OWORD *)(a1 + 544);
  xmlParseContent((xmlParserCtxtPtr)v12);
  xmlParserInputPtr v26 = *(_BYTE **)(*(void *)(v12 + 56) + 32LL);
  if (*v26)
  {
    if (*v26 == 60 && v26[1] == 47) {
      int v27 = 85;
    }
    else {
      int v27 = 86;
    }
    xmlFatalErr((_DWORD *)v12, v27, 0LL);
  }

  if (*(void *)(v12 + 80) != *(void *)(*(void *)(v12 + 16) + 24LL)) {
    xmlFatalErr((_DWORD *)v12, 85, 0LL);
  }
  if (*(_DWORD *)(v12 + 24))
  {
    uint64_t v28 = *(void *)(v12 + 16);
    if (v4)
    {
      uint64_t v29 = *(void *)(*(void *)(v28 + 24) + 24LL);
      for (*(void *)uint64_t v4 = v29; v29; v29 = *(void *)(v29 + 48))
      {
        if (*(_DWORD *)(a1 + 156))
        {
          if (*(_DWORD *)(a1 + 24))
          {
            int v30 = *(xmlDoc **)(a1 + 16);
            if (v30)
            {
            }
          }
        }

        *(void *)(v29 + 40) = 0LL;
      }

      uint64_t v4 = 0LL;
      int v31 = *(xmlNode **)(*(void *)(v12 + 16) + 24LL);
      v31->xmlNodePtr children = 0LL;
      goto LABEL_56;
    }
  }

  else
  {
    unsigned int v32 = *(_DWORD *)(v12 + 136);
    if (v32 <= 1) {
      uint64_t v4 = 1LL;
    }
    else {
      uint64_t v4 = v32;
    }
    uint64_t v28 = *(void *)(v12 + 16);
  }

  if (v28)
  {
    int v31 = *(xmlNode **)(v28 + 24);
LABEL_56:
    xmlFreeNode(v31);
    *(_OWORD *)(*(void *)(v12 + 16) + 24LL) = v34;
  }

  *(void *)(a1 + 696) += *(void *)(v12 + 696);
  if (*(_DWORD *)(v12 + 604)) {
    xmlCopyError((xmlErrorPtr)(v12 + 600), (xmlErrorPtr)(a1 + 600));
  }
  *(void *)uint64_t v12 = v17;
  *(void *)(v12 + 456) = 0LL;
  *(void *)(v12 + 544) = 0LL;
  *(void *)(v12 + 552) = 0LL;
  xmlFreeParserCtxt((xmlParserCtxtPtr)v12);
  if (v19) {
    xmlFreeDoc(v19);
  }
  return v4;
}

uint64_t xmlParseExternalEntityPrivate( uint64_t a1, uint64_t a2, _xmlSAXHandler *a3, void *a4, int a5, const xmlChar *a6, const char *a7, _xmlNode **a8)
{
  if (a5 < 41 || (uint64_t v14 = 89LL, a2) && a5 <= 0x400 && (*(_DWORD *)(a2 + 564) & 0x80000) != 0)
  {
    if (a8) {
      *a8 = 0LL;
    }
    uint64_t v14 = 1LL;
    if (a1)
    {
      if ((unint64_t)a6 | (unint64_t)a7)
      {
        EntityParserCtxtInternal = xmlCreateEntityParserCtxtInternal(a6, a7, 0LL, a2);
        if (EntityParserCtxtInternal)
        {
          uint64_t v16 = (uint64_t)EntityParserCtxtInternal;
          EntityParserCtxtInternal->userData = EntityParserCtxtInternal;
          if (a3)
          {
            sax = EntityParserCtxtInternal->sax;
            EntityParserCtxtInternal->sax = a3;
            if (a4) {
              EntityParserCtxtInternal->userData = a4;
            }
          }

          else
          {
            sax = 0LL;
          }

          xmlDetectSAX2((const xmlChar *)EntityParserCtxtInternal);
          xmlDocPtr v18 = xmlNewDoc((const xmlChar *)"1.0");
          if (v18)
          {
            uint64_t v19 = v18;
            *(_OWORD *)&v18->intSubset = *(_OWORD *)(a1 + 80);
            p_intSubset = &v18->intSubset;
            v18->int properties = 64;
            int v21 = *(xmlDict **)(a1 + 152);
            if (v21)
            {
              v19->dict = v21;
              xmlDictReference(v21);
            }

            xmlNodePtr v22 = *(const xmlChar **)(a1 + 136);
            if (v22) {
              v19->URL = xmlStrdup(v22);
            }
            int v23 = xmlNewDocNode(v19, 0LL, (const xmlChar *)"pseudoroot", 0LL);
            if (!v23)
            {
              if (a3) {
                *(void *)uint64_t v16 = sax;
              }
              goto LABEL_77;
            }

            int v24 = v23;
            xmlAddChild((xmlNodePtr)v19, v23);
            nodePush((xmlParserCtxtPtr)v16, v19->children);
            *(void *)(v16 + 16) = a1;
            v24->xmlDocPtr doc = (_xmlDoc *)a1;
            if (!*(_DWORD *)(v16 + 452)
              && (uint64_t)(*(void *)(*(void *)(v16 + 56) + 40LL) - *(void *)(*(void *)(v16 + 56) + 32LL)) <= 249)
            {
              xmlGROW(v16);
            }

            *(_DWORD *)in = 0;
            int v25 = *(_DWORD **)(*(void *)(v16 + 56) + 32LL);
            if ((uint64_t)(*(void *)(*(void *)(v16 + 56) + 40LL) - (void)v25) >= 4)
            {
              *(_DWORD *)in = *v25;
              xmlCharEncoding v26 = xmlDetectCharEncoding(in, 4);
              if (v26) {
                xmlSwitchEncoding((xmlParserCtxtPtr)v16, v26);
              }
            }

            int v27 = *(_BYTE **)(*(void *)(v16 + 56) + 32LL);
            if (*v27 == 60
              && v27[1] == 63
              && v27[2] == 120
              && v27[3] == 109
              && v27[4] == 108
              && (unsigned int v28 = v27[5], v28 <= 0x20)
              && ((1LL << v28) & 0x100002600LL) != 0)
            {
              xmlParseTextDecl((xmlParserCtxtPtr)v16);
              if (xmlStrEqual(*(const xmlChar **)(a2 + 32), (const xmlChar *)"1.0")
                && !xmlStrEqual(*(const xmlChar **)(*(void *)(v16 + 56) + 88LL), (const xmlChar *)"1.0"))
              {
                xmlFatalErrMsg((_DWORD *)v16, 109);
              }

              *(_DWORD *)(v16 + 272) = 7;
              *(_DWORD *)(v16 + 392) = a5;
            }

            else
            {
              *(_DWORD *)(v16 + 272) = 7;
              *(_DWORD *)(v16 + 392) = a5;
              if (!a2)
              {
                int v31 = 0;
                *(void *)(v16 + 424) = 0LL;
                *(_DWORD *)(v16 + 156) = 0;
                *(_DWORD *)(v16 + 148) = 2;
                *(_DWORD *)(v16 + 432) = 0;
                goto LABEL_48;
              }
            }

            *(void *)(v16 + 424) = *(void *)(a2 + 424);
            *(_DWORD *)(v16 + 432) = *(_DWORD *)(a2 + 432);
            *(void *)(v16 + 152) = *(void *)(a2 + 152);
            *(_DWORD *)(v16 + 28) = *(_DWORD *)(a2 + 28);
            if (*(_DWORD *)(a2 + 156))
            {
              *(void *)(v16 + 176) = *(void *)(a2 + 176);
              *(_OWORD *)(v16 + 160) = *(_OWORD *)(a2 + 160);
              *(_DWORD *)(v16 + 208) = *(_DWORD *)(a2 + 208);
            }

            *(_DWORD *)(v16 + 148) = *(_DWORD *)(a2 + 148);
            uint64_t v29 = *(xmlDict **)(v16 + 456);
            if (v29) {
              xmlDictFree(v29);
            }
            int v30 = *(xmlDict **)(a2 + 456);
            *(void *)(v16 + 456) = v30;
            *(void *)(v16 + 480) = xmlDictLookup(v30, (const xmlChar *)"xml", 3);
            *(void *)(v16 + 488) = xmlDictLookup(*(xmlDictPtr *)(v16 + 456), (const xmlChar *)"xmlns", 5);
            *(void *)(v16 + 496) = xmlDictLookup( *(xmlDictPtr *)(v16 + 456),  (const xmlChar *)"http://www.w3.org/XML/1998/namespace",  36);
            *(_DWORD *)(v16 + 568) = *(_DWORD *)(a2 + 568);
            *(_OWORD *)(v16 + 544) = *(_OWORD *)(a2 + 544);
            *(_DWORD *)(v16 + 436) = *(_DWORD *)(a2 + 436);
            *(_DWORD *)(v16 + 104) = *(_DWORD *)(a2 + 104);
            *(_OWORD *)(v16 + 112) = *(_OWORD *)(a2 + 112);
            *(void *)(v16 + 128) = *(void *)(a2 + 128);
            int v31 = 1;
LABEL_48:
            xmlParseContent((xmlParserCtxtPtr)v16);
            unsigned int v32 = *(_BYTE **)(*(void *)(v16 + 56) + 32LL);
            if (*v32)
            {
              if (*v32 == 60 && v32[1] == 47) {
                int v33 = 85;
              }
              else {
                int v33 = 86;
              }
              xmlFatalErr((_DWORD *)v16, v33, 0LL);
            }

            if (*(_xmlNode **)(v16 + 80) != v19->children) {
              xmlFatalErr((_DWORD *)v16, 85, 0LL);
            }
            if (*(_DWORD *)(v16 + 24))
            {
              if (a8)
              {
                xmlNodePtr children = v19->children->children;
                for (*a8 = children; children; xmlNodePtr children = children->next)
                  children->parent = 0LL;
                uint64_t v14 = 0LL;
                v19->children->xmlNodePtr children = 0LL;
                if (!v31) {
                  goto LABEL_72;
                }
                goto LABEL_68;
              }

              uint64_t v14 = 0LL;
              if (v31)
              {
LABEL_68:
                *(void *)(a2 + 696) += *(void *)(v16 + 696);
                int v36 = *(void **)(v16 + 56);
                if (v36) {
                  *(void *)(a2 + 704) = *(void *)(a2 + 704) + v36[8] + v36[4] - v36[3];
                }
                if (*(_DWORD *)(v16 + 604)) {
                  xmlCopyError((xmlErrorPtr)(v16 + 600), (xmlErrorPtr)(a2 + 600));
                }
              }
            }

            else
            {
              unsigned int v35 = *(_DWORD *)(v16 + 136);
              if (v35 <= 1) {
                uint64_t v14 = 1LL;
              }
              else {
                uint64_t v14 = v35;
              }
              if (v31) {
                goto LABEL_68;
              }
            }

void xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt)
{
  publicID = 0LL;
  xmlParserInputPtr input = ctxt->input;
  xmlNodePtr cur = input->cur;
  input->xmlNodePtr cur = cur + 9;
  input->col += 9;
  if (!cur[9]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  uint64_t v4 = xmlParseName(ctxt);
  if (!v4) {
    xmlFatalErrMsg(ctxt, 68);
  }
  ctxt->intSubName = v4;
  xmlSkipBlankChars(ctxt);
  uint64_t v5 = xmlParseExternalID(ctxt, &publicID, 1);
  charactersSAXFunc v6 = v5;
  uint64_t v7 = publicID;
  ctxt->extSubURI = v5;
  ctxt->extSubSystem = v7;
  xmlSkipBlankChars(ctxt);
  if (ctxt->sax)
  {
    internalSubsetSAXFunc internalSubset = ctxt->sax->internalSubset;
    if (internalSubset)
    {
      if (!ctxt->disableSAX) {
        ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))internalSubset)(ctxt->userData, v4, v7, v6);
      }
    }
  }

  if (ctxt->instate != XML_PARSER_EOF)
  {
    int v9 = *ctxt->input->cur;
    if (v9 != 62)
    {
      if (v9 == 91) {
        return;
      }
      xmlFatalErr(ctxt, 61, 0LL);
    }

    xmlNextChar(ctxt);
  }

const xmlChar *__cdecl xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value)
{
  *unsigned int value = 0LL;
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  uint64_t v4 = xmlParseName(ctxt);
  if (v4)
  {
    xmlSkipBlankChars(ctxt);
    if (*ctxt->input->cur == 61)
    {
      xmlNextChar(ctxt);
      xmlSkipBlankChars(ctxt);
      if (ctxt->input) {
        uint64_t v5 = xmlParseAttValueInternal((uint64_t)ctxt, 0LL, 0LL, 0LL);
      }
      else {
        uint64_t v5 = 0LL;
      }
      ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
      if (ctxt->pedantic && xmlStrEqual(v4, (const xmlChar *)"xml:lang") && !xmlCheckLanguageID(v5)) {
        xmlWarningMsg((uint64_t *)ctxt, 98, (uint64_t)"Malformed value for xml:lang : %s\n", (uint64_t)v5);
      }
      if (xmlStrEqual(v4, (const xmlChar *)"xml:space"))
      {
        if (xmlStrEqual(v5, (const xmlChar *)"default"))
        {
          *ctxt->space = 0;
        }

        else if (xmlStrEqual(v5, (const xmlChar *)"preserve"))
        {
          *ctxt->space = 1;
        }

        else
        {
          xmlWarningMsg( (uint64_t *)ctxt,  102,  (uint64_t)"Invalid value %s for xml:space : default or preserve expected\n",  (uint64_t)v5);
        }
      }

      *unsigned int value = v5;
    }

    else
    {
      xmlFatalErrMsgStr(ctxt, 41, (uint64_t)"Specification mandates value for attribute %s\n", (uint64_t)v4);
      return 0LL;
    }
  }

  else
  {
    xmlFatalErrMsg(ctxt, 68);
  }

  return v4;
}

const xmlChar *__cdecl xmlParseStartTag(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  xmlNodePtr cur = input->cur;
  if (*cur != 60) {
    return 0LL;
  }
  atts = ctxt->atts;
  int maxatts = ctxt->maxatts;
  ++input->col;
  input->xmlNodePtr cur = cur + 1;
  if (!cur[1]) {
    xmlParserInputGrow(input, 250);
  }
  charactersSAXFunc v6 = xmlParseName(ctxt);
  if (!v6)
  {
    xmlFatalErrMsg(ctxt, 68);
    return v6;
  }

  xmlSkipBlankChars(ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  LODWORD(v7) = 0;
  unsigned int value = 0LL;
  while (1)
  {
    xmlParserInputPtr v8 = ctxt->input;
    int v9 = v8->cur;
    unsigned int v10 = *v9;
    if (v10 == 47)
    {
      if (v9[1] == 62) {
        goto LABEL_62;
      }
    }

    else
    {
      if (v10 == 62) {
        goto LABEL_62;
      }
      BOOL v11 = v10 - 9 < 2 || v10 == 13;
      if (!v11 && v10 < 0x20) {
        goto LABEL_62;
      }
    }

    if (ctxt->instate == XML_PARSER_EOF) {
      goto LABEL_62;
    }
    uint64_t consumed_low = LODWORD(v8->consumed);
    xmlParserCtxtPtr v13 = (xmlChar *)xmlParseAttribute(ctxt, &value);
    uint64_t v14 = value;
    if (v13 && value)
    {
      if ((int)v7 < 1)
      {
        if (!atts)
        {
          uint64_t v16 = (const xmlChar **)xmlMalloc(0xB0uLL);
          if (!v16)
          {
            htmlErrMemory(ctxt, 0LL);
            xmlFree(v14);
            atts = 0LL;
            int maxatts = 22;
            goto LABEL_39;
          }

          int maxatts = 22;
LABEL_37:
          ctxt->atts = v16;
          ctxt->int maxatts = maxatts;
          atts = v16;
LABEL_38:
          uint64_t v17 = (xmlChar **)&atts[(int)v7];
          *uint64_t v17 = v13;
          v17[1] = value;
          uint64_t v7 = (int)v7 + 2LL;
          atts[v7] = 0LL;
          v17[3] = 0LL;
          goto LABEL_39;
        }

_DWORD *xmlErrAttributeDup(_DWORD *result, const xmlChar *a2, xmlChar *a3)
{
  int v3 = result;
  if (result)
  {
    if (result[83] && result[68] == -1) {
      return result;
    }
    result[34] = 42;
  }

  if (a2) {
    xmlElementContentPtr result = __xmlRaiseError( 0LL,  0LL,  0LL,  result,  0LL,  1u,  42,  3,  0LL,  0,  a2,  a3,  0LL,  0,  0,  "Attribute %s:%s redefined\n",  (char)a2);
  }
  else {
    xmlElementContentPtr result = __xmlRaiseError( 0LL,  0LL,  0LL,  result,  0LL,  1u,  42,  3,  0LL,  0,  a3,  0LL,  0LL,  0,  0,  "Attribute %s redefined\n",  (char)a3);
  }
  if (v3)
  {
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }

  return result;
}

xmlParserInput *xmlParseEndTag1(xmlParserCtxt *a1)
{
  if (!a1->progressive && a1->input->end - a1->input->cur <= 249) {
    xmlGROW((uint64_t)a1);
  }
  xmlParserInputPtr input = a1->input;
  xmlNodePtr cur = input->cur;
  if (*cur != 60 || cur[1] != 47) {
    return (xmlParserInput *)xmlFatalErrMsg(a1, 74);
  }
  input->xmlNodePtr cur = cur + 2;
  input->col += 2;
  if (!cur[2]) {
    xmlParserInputGrow(input, 250);
  }
  uint64_t v4 = xmlParseNameAndCompare((uint64_t)a1, (unsigned __int8 *)a1->name);
  if (!a1->progressive && a1->input->end - a1->input->cur <= 249) {
    xmlGROW((uint64_t)a1);
  }
  xmlSkipBlankChars(a1);
  xmlElementContentPtr result = a1->input;
  charactersSAXFunc v6 = result->cur;
  if (*v6 == 62)
  {
    ++result->col;
    result->xmlNodePtr cur = v6 + 1;
    if (!v6[1]) {
      xmlElementContentPtr result = (xmlParserInput *)xmlParserInputGrow(result, 250);
    }
  }

  else
  {
    xmlElementContentPtr result = (xmlParserInput *)xmlFatalErr(a1, 73, 0LL);
  }

  if (v4 != 1)
  {
    if (v4) {
      uint64_t v7 = (xmlChar *)v4;
    }
    else {
      uint64_t v7 = (xmlChar *)"unparsable";
    }
    xmlElementContentPtr result = (xmlParserInput *)xmlFatalErrMsgStrIntStr( a1,  76,  "Opening and ending tag mismatch: %s line %d and %s\n",  a1->name,  0,  v7);
  }

  if (a1->sax)
  {
    endElementSAXFunc endElement = (uint64_t (*)(void *, const xmlChar *))a1->sax->endElement;
    if (endElement)
    {
      if (!a1->disableSAX) {
        xmlElementContentPtr result = (xmlParserInput *)endElement(a1->userData, a1->name);
      }
    }
  }

  int nameNr = a1->nameNr;
  unsigned int v10 = nameNr - 1;
  if (nameNr >= 1)
  {
    a1->int nameNr = v10;
    nameTab = a1->nameTab;
    if (nameNr == 1) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = nameTab[nameNr - 2];
    }
    a1->name = v12;
    nameTab[v10] = 0LL;
  }

  int spaceNr = a1->spaceNr;
  if (spaceNr >= 1)
  {
    unsigned int v14 = spaceNr - 2;
    unsigned int v15 = spaceNr - 1;
    a1->int spaceNr = v15;
    spaceTab = a1->spaceTab;
    if (!v15) {
      unsigned int v14 = 0;
    }
    a1->space = &spaceTab[v14];
    spaceTab[v15] = -1;
  }

  return result;
}

void xmlParseCDSect(xmlParserCtxtPtr ctxt)
{
  *(void *)int len = 0LL;
  int v35 = 0;
  if ((ctxt->options & 0x80000) != 0) {
    int v2 = 1000000000;
  }
  else {
    int v2 = 10000000;
  }
  xmlParserInputPtr input = ctxt->input;
  xmlNodePtr cur = input->cur;
  if (*cur == 60
    && cur[1] == 33
    && cur[2] == 91
    && cur[3] == 67
    && cur[4] == 68
    && cur[5] == 65
    && cur[6] == 84
    && cur[7] == 65
    && cur[8] == 91)
  {
    input->xmlNodePtr cur = cur + 9;
    input->col += 9;
    if (!cur[9]) {
      xmlParserInputGrow(input, 250);
    }
    ctxt->xmlParserInputState instate = XML_PARSER_CDATA_SECTION;
    int v5 = xmlCurrentChar(ctxt, &len[1]);
    int v6 = v5;
    if (v5 > 255)
    {
      if ((v5 - 0x10000) >= 0x100000
        && v5 >> 11 >= 0x1B
        && (v5 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_36;
      }
    }

    else if (v5 <= 31 && (v5 > 0xD || ((1 << v5) & 0x2600) == 0))
    {
      goto LABEL_36;
    }

    xmlParserInputPtr v7 = ctxt->input;
    xmlParserInputPtr v8 = v7->cur;
    int v9 = &v8[len[1]];
    if (v9 <= v7->end)
    {
      if (*v8 == 10)
      {
        ++v7->line;
        v7->int col = 1;
      }

      else
      {
        ++v7->col;
      }

      v7->xmlNodePtr cur = v9;
    }

    int v10 = xmlCurrentChar(ctxt, len);
    int v11 = v10;
    if (v10 > 255)
    {
      if ((v10 - 0x10000) >= 0x100000
        && v10 >> 11 >= 0x1B
        && (v10 - 57344) >> 1 >= 0xFFF)
      {
        goto LABEL_36;
      }
    }

    else if (v10 <= 31 && (v10 > 0xD || ((1 << v10) & 0x2600) == 0))
    {
LABEL_36:
      xmlFatalErr(ctxt, 63, 0LL);
      ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
      return;
    }

    xmlParserInputPtr v12 = ctxt->input;
    xmlParserCtxtPtr v13 = v12->cur;
    unsigned int v14 = &v13[len[0]];
    if (v14 <= v12->end)
    {
      if (*v13 == 10)
      {
        ++v12->line;
        v12->int col = 1;
      }

      else
      {
        ++v12->col;
      }

      v12->xmlNodePtr cur = v14;
    }

    int v15 = xmlCurrentChar(ctxt, &v35);
    uint64_t v16 = xmlMallocAtomic(0x64uLL);
    if (v16)
    {
      uint64_t v17 = v16;
      uint64_t v18 = 0LL;
      int v19 = 0;
      int v20 = 100;
      while (1)
      {
        if (v15 > 255)
        {
          if ((v15 - 0x10000) >= 0x100000
            && v15 >> 11 >= 0x1B
            && (v15 - 57344) >> 1 >= 0xFFF)
          {
LABEL_79:
            v17[(int)v18] = 0;
            ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
            xmlFatalErrMsgStr(ctxt, 63, (uint64_t)"CData section not finished\n%.50s\n", (uint64_t)v17);
            goto LABEL_80;
          }
        }

        else if (v15 <= 31)
        {
        }

        else if (v6 == 93 && v11 == 93 && v15 == 62)
        {
          v17[(int)v18] = 0;
          ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
          xmlParserInputPtr v30 = ctxt->input;
          int v31 = v30->cur;
          unsigned int v32 = &v31[v35];
          if (v32 <= v30->end)
          {
            if (*v31 == 10)
            {
              ++v30->line;
              v30->int col = 1;
            }

            else
            {
              ++v30->col;
            }

            v30->xmlNodePtr cur = v32;
          }

          sax = ctxt->sax;
          if (ctxt->sax)
          {
            if (!ctxt->disableSAX)
            {
              cdataBlocuint64_t k = (void (*)(void, void, void))sax->cdataBlock;
            }
          }

          goto LABEL_80;
        }

        if ((int)v18 + 5 >= v20)
        {
          v20 *= 2;
          xmlParserInputPtr v21 = xmlRealloc(v17, v20);
          if (!v21)
          {
            xmlFree(v17);
            break;
          }

          uint64_t v17 = v21;
        }

        if (len[1] == 1)
        {
          v17[(int)v18] = v6;
          uint64_t v18 = (v18 + 1);
        }

        else
        {
          uint64_t v18 = (xmlCopyCharMultiByte(&v17[(int)v18], v6) + v18);
        }

        int v23 = v35;
        int v22 = len[0];
        len[0] = v35;
        len[1] = v22;
        if (v19 < 50)
        {
          ++v19;
        }

        else
        {
          if (!ctxt->progressive)
          {
            xmlParserInputPtr v24 = ctxt->input;
            uint64_t v25 = v24->cur;
            if (v25 - v24->base < 501 || v24->end - v25 > 499 || (xmlSHRINK((uint64_t)ctxt), !ctxt->progressive))
            {
              if (ctxt->input->end - ctxt->input->cur <= 249) {
                xmlGROW((uint64_t)ctxt);
              }
            }
          }

          if (ctxt->instate == XML_PARSER_EOF) {
            goto LABEL_80;
          }
          int v19 = 0;
          int v23 = v35;
        }

        xmlParserInputPtr v26 = ctxt->input;
        int v27 = v26->cur;
        unsigned int v28 = &v27[v23];
        if (v28 <= v26->end)
        {
          if (*v27 == 10)
          {
            ++v26->line;
            int v29 = 1;
          }

          else
          {
            int v29 = v26->col + 1;
          }

          v26->int col = v29;
          v26->xmlNodePtr cur = v28;
        }

        int v6 = v11;
        int v11 = v15;
        int v15 = xmlCurrentChar(ctxt, &v35);
        if ((int)v18 > v2)
        {
          xmlFatalErrMsg(ctxt, 63);
LABEL_80:
          xmlFree(v17);
          return;
        }
      }
    }

    htmlErrMemory(ctxt, 0LL);
  }

void xmlParseContent(xmlParserCtxtPtr ctxt)
{
  int nameNr = ctxt->nameNr;
  xmlParseContentInternal((int)ctxt);
  if (ctxt->instate != XML_PARSER_EOF)
  {
    int v3 = ctxt->nameNr;
    if (v3 > nameNr) {
      xmlFatalErrMsgStrIntStr( ctxt,  77,  "Premature end of data in tag %s line %d\n",  ctxt->nameTab[v3 - 1],  (int)ctxt->pushTab[3 * v3 - 1],  0LL);
    }
  }

void xmlParseContentInternal(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 296);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(unsigned __int8 **)(v3 + 32);
  int v5 = *v4;
  if (*v4)
  {
    do
    {
      if (*(_DWORD *)(a1 + 272) == -1) {
        return;
      }
      uint64_t v6 = *(unsigned int *)(v3 + 64);
      if (v5 == 38)
      {
        xmlParseReference((xmlParserCtxtPtr)a1);
        goto LABEL_29;
      }

      if (v5 != 60)
      {
        xmlParseCharData((xmlParserCtxtPtr)a1, 0);
        goto LABEL_29;
      }

      int v7 = v4[1];
      switch(v7)
      {
        case '!':
          if (v4[2] == 91 && v4[3] == 67 && v4[4] == 68 && v4[5] == 65 && v4[6] == 84 && v4[7] == 65 && v4[8] == 91)
          {
            xmlParseCDSect((xmlParserCtxtPtr)a1);
            break;
          }

          if (v4[2] != 45 || v4[3] != 45) {
            goto LABEL_28;
          }
          xmlParseComment((xmlParserCtxtPtr)a1);
          if (*(_DWORD *)(a1 + 272) != -1) {
            *(_DWORD *)(a1 + 272) = 7;
          }
          break;
        case '/':
          if (*(_DWORD *)(a1 + 296) <= v2) {
            return;
          }
          xmlParseElementEnd((xmlParserCtxt *)a1);
          break;
        case '?':
          xmlParsePI((xmlParserCtxtPtr)a1);
          break;
        default:
LABEL_28:
          xmlParseElementStart(a1);
          break;
      }

_DWORD *xmlFatalErrMsgStrIntStr( _DWORD *result, int a2, const char *a3, const xmlChar *a4, int a5, xmlChar *cur)
{
  if (!result) {
    return __xmlRaiseError(0LL, 0LL, 0LL, 0LL, 0LL, 1u, a2, 3, 0LL, 0, a4, cur, 0LL, a5, 0, a3, (char)a4);
  }
  uint64_t v6 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    xmlElementContentPtr result = __xmlRaiseError(0LL, 0LL, 0LL, result, 0LL, 1u, a2, 3, 0LL, 0, a4, cur, 0LL, a5, 0, a3, (char)a4);
    v6[6] = 0;
    if (!v6[112]) {
      v6[83] = 1;
    }
  }

  return result;
}

void xmlParseElement(xmlParserCtxtPtr ctxt)
{
  if (!xmlParseElementStart((uint64_t)ctxt))
  {
    xmlParseContentInternal((uint64_t)ctxt);
    if (ctxt->instate != XML_PARSER_EOF)
    {
      if (*ctxt->input->cur) {
        xmlParseElementEnd(ctxt);
      }
      else {
        xmlFatalErrMsgStrIntStr( ctxt,  77,  "Premature end of data in tag %s line %d\n",  ctxt->nameTab[ctxt->nameNr - 1],  (int)ctxt->pushTab[3 * ctxt->nameNr - 1],  0LL);
      }
    }
  }

uint64_t xmlParseElementStart(uint64_t a1)
{
  uint64_t v52 = 0LL;
  xmlNodePtr v53 = 0LL;
  int v2 = *(_DWORD *)(a1 + 508);
  if (*(_DWORD *)(a1 + 296) > xmlParserMaxDepth && (*(_BYTE *)(a1 + 566) & 8) == 0)
  {
    xmlFatalErrMsgInt( (_DWORD *)a1,  1,  (uint64_t)"Excessive depth in document: %d use XML_PARSE_HUGE option\n",  xmlParserMaxDepth);
    xmlHaltParser((xmlParserCtxtPtr)a1);
    return 0xFFFFFFFFLL;
  }

  memset(&info, 0, sizeof(info));
  if (*(_DWORD *)(a1 + 104))
  {
    uint64_t v3 = *(void *)(a1 + 56);
    unint64_t v4 = *(void *)(v3 + 64) + *(void *)(v3 + 32) - *(void *)(v3 + 24);
    unint64_t v5 = *(int *)(v3 + 52);
    info.begin_pos = v4;
    info.begin_int line = v5;
  }

  if (*(_DWORD *)(a1 + 376))
  {
    if (**(_DWORD **)(a1 + 368) == -2) {
      int v6 = -1;
    }
    else {
      int v6 = **(_DWORD **)(a1 + 368);
    }
  }

  else
  {
    int v6 = -1;
  }

  spacePush(a1, v6);
  int v7 = *(_DWORD *)(*(void *)(a1 + 56) + 52LL);
  if (*(_DWORD *)(a1 + 504)) {
    int started = xmlParseStartTag2(a1, &v53, &v52, &v50);
  }
  else {
    int started = xmlParseStartTag((xmlParserCtxtPtr)a1);
  }
  int v9 = started;
  if (*(_DWORD *)(a1 + 272) == -1) {
    return 0xFFFFFFFFLL;
  }
  if (started)
  {
    uint64_t v11 = v52;
    uint64_t v10 = v53;
    nameNsPush((_DWORD *)a1, (uint64_t)started, (uint64_t)v53, v52, v7, *(_DWORD *)(a1 + 508) - v2);
    xmlParserInputPtr v12 = *(const _xmlNode **)(a1 + 80);
    if (*(_DWORD *)(a1 + 156))
    {
      if (*(_DWORD *)(a1 + 24))
      {
        xmlParserCtxtPtr v13 = *(xmlDoc **)(a1 + 16);
        if (v13)
        {
          if (v12 && v12 == v13->children) {
            *(_DWORD *)(a1 + 152) &= xmlValidateRoot((xmlValidCtxtPtr)(a1 + 160), v13);
          }
        }
      }
    }

    unsigned int v14 = *(xmlParserInput **)(a1 + 56);
    xmlNodePtr cur = v14->cur;
    int v16 = *cur;
    if (v16 == 62)
    {
      ++v14->col;
      v14->xmlNodePtr cur = cur + 1;
      if (!cur[1]) {
        xmlParserInputGrow(v14, 250);
      }
      if (v12 && *(_DWORD *)(a1 + 104))
      {
        info.end_pos = 0LL;
        info.end_int line = 0LL;
        info.xmlNodePtr node = v12;
        xmlParserAddNodeInfo((xmlParserCtxtPtr)a1, &info);
      }

      return 0LL;
    }

    else
    {
      if (v16 != 47 || cur[1] != 62)
      {
        xmlFatalErrMsgStrIntStr((_DWORD *)a1, 73, "Couldn't find end of Start Tag %s line %d\n", v9, v7, 0LL);
        int v24 = *(_DWORD *)(a1 + 88);
        unsigned int v25 = v24 - 1;
        if (v24 >= 1)
        {
          *(_DWORD *)(a1 + 88) = v25;
          uint64_t v26 = *(void *)(a1 + 96);
          if (v24 == 1) {
            uint64_t v27 = 0LL;
          }
          else {
            uint64_t v27 = *(void *)(v26 + 8LL * (v24 - 2));
          }
          *(void *)(a1 + 80) = v27;
          *(void *)(v26 + 8LL * v25) = 0LL;
        }

        int v28 = *(_DWORD *)(a1 + 296);
        unsigned int v29 = v28 - 1;
        if (v28 >= 1)
        {
          *(_DWORD *)(a1 + 296) = v29;
          uint64_t v30 = *(void *)(a1 + 304);
          if (v28 == 1) {
            uint64_t v31 = 0LL;
          }
          else {
            uint64_t v31 = *(void *)(v30 + 8LL * (v28 - 2));
          }
          *(void *)(a1 + 288) = v31;
          *(void *)(v30 + 8LL * v29) = 0LL;
        }

        int v32 = *(_DWORD *)(a1 + 376);
        if (v32 >= 1)
        {
          unsigned int v33 = v32 - 2;
          unsigned int v34 = v32 - 1;
          *(_DWORD *)(a1 + 376) = v34;
          uint64_t v35 = *(void *)(a1 + 384);
          if (!v34) {
            unsigned int v33 = 0;
          }
          *(void *)(a1 + 368) = v35 + 4LL * v33;
          *(_DWORD *)(v35 + 4LL * v34) = -1;
        }

        int v36 = *(_DWORD *)(a1 + 508);
        if (v36 != v2) {
          nsPop(a1, v36 - v2);
        }
        return 0xFFFFFFFFLL;
      }

      v14->xmlNodePtr cur = cur + 2;
      v14->col += 2;
      if (!cur[2]) {
        xmlParserInputGrow(v14, 250);
      }
      uint64_t v17 = *(void *)a1;
      if (*(_DWORD *)(a1 + 504))
      {
        if (v17)
        {
          uint64_t v18 = *(void (**)(void, const xmlChar *, const xmlChar *, uint64_t))(v17 + 240);
          if (v18)
          {
            if (!*(_DWORD *)(a1 + 332)) {
              v18(*(void *)(a1 + 8), v9, v10, v11);
            }
          }
        }
      }

      else if (v17)
      {
        uint64_t v37 = *(void (**)(void, const xmlChar *))(v17 + 120);
        if (v37)
        {
          if (!*(_DWORD *)(a1 + 332)) {
            v37(*(void *)(a1 + 8), v9);
          }
        }
      }

      int v38 = *(_DWORD *)(a1 + 296);
      unsigned int v39 = v38 - 1;
      if (v38 >= 1)
      {
        *(_DWORD *)(a1 + 296) = v39;
        uint64_t v40 = *(void *)(a1 + 304);
        if (v38 == 1) {
          uint64_t v41 = 0LL;
        }
        else {
          uint64_t v41 = *(void *)(v40 + 8LL * (v38 - 2));
        }
        *(void *)(a1 + 288) = v41;
        *(void *)(v40 + 8LL * v39) = 0LL;
      }

      int v42 = *(_DWORD *)(a1 + 376);
      if (v42 >= 1)
      {
        unsigned int v43 = v42 - 2;
        unsigned int v44 = v42 - 1;
        *(_DWORD *)(a1 + 376) = v44;
        uint64_t v45 = *(void *)(a1 + 384);
        if (!v44) {
          unsigned int v43 = 0;
        }
        *(void *)(a1 + 368) = v45 + 4LL * v43;
        *(_DWORD *)(v45 + 4LL * v44) = -1;
      }

      int v46 = *(_DWORD *)(a1 + 508);
      if (v46 != v2) {
        nsPop(a1, v46 - v2);
      }
      if (v12)
      {
        if (*(_DWORD *)(a1 + 104))
        {
          uint64_t v47 = *(void *)(a1 + 56);
          unint64_t v48 = *(void *)(v47 + 64) + *(void *)(v47 + 32) - *(void *)(v47 + 24);
          info.xmlNodePtr node = v12;
          unint64_t v49 = *(int *)(v47 + 52);
          info.end_pos = v48;
          info.end_int line = v49;
          xmlParserAddNodeInfo((xmlParserCtxtPtr)a1, &info);
        }
      }

      return 1LL;
    }
  }

  else
  {
    int v19 = *(_DWORD *)(a1 + 376);
    uint64_t result = 0xFFFFFFFFLL;
    if (v19 >= 1)
    {
      unsigned int v21 = v19 - 2;
      unsigned int v22 = v19 - 1;
      *(_DWORD *)(a1 + 376) = v22;
      uint64_t v23 = *(void *)(a1 + 384);
      if (!v22) {
        unsigned int v21 = 0;
      }
      *(void *)(a1 + 368) = v23 + 4LL * v21;
      *(_DWORD *)(v23 + 4LL * v22) = -1;
    }
  }

  return result;
}

void xmlParseElementEnd(xmlParserCtxt *a1)
{
  int nameNr = a1->nameNr;
  BOOL v2 = __OFSUB__(nameNr, 1);
  int v3 = nameNr - 1;
  if (v3 < 0 != v2) {
    return;
  }
  xmlNodePtr node = a1->node;
  if (!a1->sax2)
  {
    xmlParseEndTag1(a1);
LABEL_8:
    if (!node) {
      return;
    }
    goto LABEL_11;
  }

  xmlParseEndTag2((uint64_t)a1, &a1->pushTab[3 * v3]);
  int v6 = a1->nameNr;
  unsigned int v7 = v6 - 1;
  if (v6 < 1) {
    goto LABEL_8;
  }
  a1->int nameNr = v7;
  nameTab = a1->nameTab;
  if (v6 == 1) {
    int v9 = 0LL;
  }
  else {
    int v9 = nameTab[v6 - 2];
  }
  a1->name = v9;
  nameTab[v7] = 0LL;
  if (node)
  {
LABEL_11:
    if (a1->record_info)
    {
      NodeInfo = xmlParserFindNodeInfo(a1, node);
      if (NodeInfo)
      {
        xmlParserInputPtr input = a1->input;
        unint64_t v12 = &input->cur[input->consumed] - input->base;
        unint64_t line = input->line;
        NodeInfo->end_pos = v12;
        NodeInfo->end_unint64_t line = line;
      }
    }
  }

xmlChar *__cdecl xmlParseVersionNum(xmlParserCtxtPtr ctxt)
{
  BOOL v2 = (xmlChar *)xmlMallocAtomic(0xAuLL);
  int v3 = v2;
  if (!v2)
  {
    htmlErrMemory(ctxt, 0LL);
    return v3;
  }

  int v4 = *ctxt->input->cur;
  if ((v4 - 48) >= 0xA || (xmlChar *v2 = v4, xmlNextChar(ctxt), *ctxt->input->cur != 46))
  {
    xmlFree(v3);
    return 0LL;
  }

  v3[1] = 46;
  xmlNextChar(ctxt);
  int v5 = *ctxt->input->cur;
  if ((v5 - 48) > 9)
  {
    uint64_t v10 = 2LL;
LABEL_15:
    v3[v10] = 0;
    return v3;
  }

  int v6 = 10;
  uint64_t v7 = 2LL;
  while (1)
  {
    unsigned int v8 = v7 + 1;
    if (v7 + 1 >= v6) {
      break;
    }
LABEL_9:
    v3[v7] = v5;
    xmlNextChar(ctxt);
    int v5 = *ctxt->input->cur;
    ++v7;
    if ((v5 - 48) >= 0xA)
    {
      uint64_t v10 = v8;
      goto LABEL_15;
    }
  }

  v6 *= 2;
  int v9 = (xmlChar *)xmlRealloc(v3, v6);
  if (v9)
  {
    int v3 = v9;
    goto LABEL_9;
  }

  xmlFree(v3);
  htmlErrMemory(ctxt, 0LL);
  return 0LL;
}

xmlChar *__cdecl xmlParseEncName(xmlParserCtxtPtr ctxt)
{
  int v2 = *ctxt->input->cur;
  if ((v2 & 0xFFFFFFDF) - 65 > 0x19)
  {
    xmlFatalErr(ctxt, 79, 0LL);
    return 0LL;
  }

  else
  {
    int v3 = xmlMallocAtomic(0xAuLL);
    int v4 = v3;
    if (v3)
    {
      _BYTE *v3 = v2;
      xmlNextChar(ctxt);
      xmlChar v5 = *ctxt->input->cur;
      int v6 = 10;
      for (uint64_t i = 1LL; ; ++i)
      {
        BOOL v8 = (v5 - 48) >= 0xAu && ((v5 & 0xDF) - 65) >= 0x1Au;
        if (v6 <= (int)i + 1)
        {
          v6 *= 2;
          int v9 = xmlRealloc(v4, v6);
          if (!v9)
          {
            htmlErrMemory(ctxt, 0LL);
            xmlFree(v4);
            return 0LL;
          }

          int v4 = v9;
        }

        *((_BYTE *)v4 + i) = v5;
        xmlNextChar(ctxt);
        xmlParserInputPtr input = ctxt->input;
        xmlNodePtr cur = (xmlChar *)input->cur;
        xmlChar v5 = *cur;
        if (!*cur)
        {
          if (!ctxt->progressive)
          {
            if (cur - input->base < 501
              || input->end - (const xmlChar *)cur > 499
              || (xmlSHRINK((uint64_t)ctxt), xmlParserInputPtr input = ctxt->input, !ctxt->progressive))
            {
              if (input->end - input->cur <= 249)
              {
                xmlGROW((uint64_t)ctxt);
                xmlParserInputPtr input = ctxt->input;
              }
            }
          }

          xmlChar v5 = *input->cur;
        }
      }

      *((_BYTE *)v4 + i) = 0;
    }

    else
    {
      htmlErrMemory(ctxt, 0LL);
    }
  }

  return (xmlChar *)v4;
}

int xmlParseSDDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  xmlNodePtr cur = input->cur;
  if (*cur != 115
    || cur[1] != 116
    || cur[2] != 97
    || cur[3] != 110
    || cur[4] != 100
    || cur[5] != 97
    || cur[6] != 108
    || cur[7] != 111
    || cur[8] != 110
    || cur[9] != 101)
  {
    return -2;
  }

  input->xmlNodePtr cur = cur + 10;
  input->col += 10;
  if (!cur[10]) {
    xmlParserInputGrow(input, 250);
  }
  xmlSkipBlankChars(ctxt);
  if (*ctxt->input->cur == 61)
  {
    xmlNextChar(ctxt);
    xmlSkipBlankChars(ctxt);
    int v4 = *ctxt->input->cur;
    if (v4 != 34)
    {
      if (v4 == 39)
      {
        xmlNextChar(ctxt);
        xmlParserInputPtr v5 = ctxt->input;
        int v6 = v5->cur;
        int v7 = *v6;
        if (v7 == 121)
        {
          if (v6[1] == 101 && v6[2] == 115)
          {
            v5->xmlNodePtr cur = v6 + 3;
            v5->col += 3;
            if (!v6[3]) {
              xmlParserInputGrow(v5, 250);
            }
            int v8 = 1;
LABEL_39:
            if (*ctxt->input->cur == 39)
            {
LABEL_40:
              xmlNextChar(ctxt);
              return v8;
            }

void xmlParseXMLDecl(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr input = ctxt->input;
  input->standalone = -2;
  xmlNodePtr cur = input->cur;
  input->xmlNodePtr cur = cur + 5;
  input->col += 5;
  unsigned int v4 = cur[5];
  if (!v4)
  {
    xmlParserInputGrow(input, 250);
    unsigned int v4 = *ctxt->input->cur;
  }

  BOOL v5 = v4 > 0x20;
  uint64_t v6 = (1LL << v4) & 0x100002600LL;
  if (v5 || v6 == 0) {
    xmlFatalErrMsg(ctxt, 65);
  }
  xmlSkipBlankChars(ctxt);
  int v8 = xmlParseVersionInfo(ctxt);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    if (!xmlStrEqual(v8, (const xmlChar *)"1.0"))
    {
      if ((ctxt->options & 0x20000) == 0 && *(_BYTE *)v9 == 49 && *(_BYTE *)(v9 + 1) == 46) {
        xmlWarningMsg((uint64_t *)ctxt, 97, (uint64_t)"Unsupported version '%s'\n", v9);
      }
      else {
        xmlFatalErrMsgStr(ctxt, 108, (uint64_t)"Unsupported version '%s'\n", v9);
      }
    }

    version = (xmlChar *)ctxt->version;
    if (version) {
      xmlFree(version);
    }
    ctxt->version = (const xmlChar *)v9;
  }

  else
  {
    xmlFatalErr(ctxt, 96, 0LL);
  }

  xmlParserInputPtr v11 = ctxt->input;
  unint64_t v12 = v11->cur;
  uint64_t v13 = *v12;
  if (v13 > 0x3F)
  {
LABEL_24:
    xmlFatalErrMsg(ctxt, 65);
    goto LABEL_25;
  }

  if (((1LL << v13) & 0x100002600LL) == 0)
  {
    if (v13 == 63 && v12[1] == 62) {
      goto LABEL_39;
    }
    goto LABEL_24;
  }

void xmlParseMisc(xmlParserCtxtPtr ctxt)
{
  while (ctxt->instate != XML_PARSER_EOF)
  {
    xmlSkipBlankChars(ctxt);
    xmlParserInputPtr input = ctxt->input;
    if (!ctxt->progressive && input->end - input->cur <= 249)
    {
      xmlGROW((uint64_t)ctxt);
      xmlParserInputPtr input = ctxt->input;
    }

    xmlNodePtr cur = input->cur;
    if (*cur != 60) {
      break;
    }
    int v4 = cur[1];
    if (v4 == 33)
    {
      if (cur[2] != 45 || cur[3] != 45) {
        return;
      }
      xmlParseComment(ctxt);
    }

    else
    {
      if (v4 != 63) {
        return;
      }
      xmlParsePI(ctxt);
    }
  }

int xmlParseDocument(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return -1;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input) {
    return -1;
  }
  if (!ctxt->progressive && input->end - input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (ctxt->sax)
  {
    setDocumentLocatorSAXFunc setDocumentLocator = ctxt->sax->setDocumentLocator;
    if (setDocumentLocator)
    {
      userData = ctxt->userData;
      BOOL v5 = __xmlDefaultSAXLocator();
      ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v5);
    }
  }

  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  *(_DWORD *)in = 0;
  if (!ctxt->encoding)
  {
    xmlNodePtr cur = ctxt->input->cur;
    if (ctxt->input->end - cur >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)cur;
      xmlCharEncoding v7 = xmlDetectCharEncoding(in, 4);
      if (v7) {
        xmlSwitchEncoding(ctxt, v7);
      }
    }
  }

  xmlParserInputPtr v8 = ctxt->input;
  uint64_t v9 = v8->cur;
  int v10 = *v9;
  if (!*v9)
  {
    xmlFatalErr(ctxt, 4, 0LL);
    return -1;
  }

  if (v8->end - v9 <= 34 && !ctxt->progressive)
  {
    xmlGROW((uint64_t)ctxt);
    uint64_t v9 = ctxt->input->cur;
    int v10 = *v9;
  }

  if (v10 == 60
    && v9[1] == 63
    && v9[2] == 120
    && v9[3] == 109
    && v9[4] == 108
    && (unsigned int v11 = v9[5], v11 <= 0x20)
    && ((1LL << v11) & 0x100002600LL) != 0)
  {
    xmlParseXMLDecl(ctxt);
    if (ctxt->errNo == 32 || ctxt->instate == XML_PARSER_EOF) {
      return -1;
    }
    ctxt->standalone = ctxt->input->standalone;
    xmlSkipBlankChars(ctxt);
  }

  else
  {
    ctxt->version = xmlCharStrdup("1.0");
  }

  if (ctxt->sax)
  {
    startDocumentSAXFunc startDocument = ctxt->sax->startDocument;
    if (startDocument)
    {
      if (!ctxt->disableSAX) {
        ((void (*)(void *))startDocument)(ctxt->userData);
      }
    }
  }

  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  xmlDocPtr myDoc = ctxt->myDoc;
  if (myDoc)
  {
    xmlParserInputPtr v14 = ctxt->input;
    if (v14)
    {
      xmlParserInputBufferPtr buf = v14->buf;
      if (buf)
      {
        int compressed = buf->compressed;
        if ((compressed & 0x80000000) == 0) {
          myDoc->compression = compressed;
        }
      }
    }
  }

  xmlParseMisc(ctxt);
  xmlParserInputPtr v17 = ctxt->input;
  if (!ctxt->progressive && v17->end - v17->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr v17 = ctxt->input;
  }

  uint64_t v18 = v17->cur;
  if (*v18 == 60
    && v18[1] == 33
    && v18[2] == 68
    && v18[3] == 79
    && v18[4] == 67
    && v18[5] == 84
    && v18[6] == 89
    && v18[7] == 80
    && v18[8] == 69)
  {
    ctxt->inSubset = 1;
    xmlParseDocTypeDecl(ctxt);
    if (*ctxt->input->cur == 91)
    {
      ctxt->xmlParserInputState instate = XML_PARSER_DTD;
      xmlParseInternalSubset((uint64_t)ctxt);
      if (ctxt->instate == XML_PARSER_EOF) {
        return -1;
      }
    }

    ctxt->inSubset = 2;
    if (ctxt->sax)
    {
      externalSubsetSAXFunc externalSubset = ctxt->sax->externalSubset;
      if (externalSubset)
      {
        if (!ctxt->disableSAX) {
          ((void (*)(void *, const xmlChar *, xmlChar *, xmlChar *))externalSubset)( ctxt->userData,  ctxt->intSubName,  ctxt->extSubSystem,  ctxt->extSubURI);
        }
      }
    }

    if (ctxt->instate == XML_PARSER_EOF) {
      return -1;
    }
    ctxt->inSubset = 0;
    xmlCleanSpecialAttr(ctxt);
    ctxt->xmlParserInputState instate = XML_PARSER_PROLOG;
    xmlParseMisc(ctxt);
    xmlParserInputPtr v17 = ctxt->input;
  }

  if (!ctxt->progressive && v17->end - v17->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr v17 = ctxt->input;
  }

  if (*v17->cur == 60)
  {
    ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
    xmlParseElement(ctxt);
    ctxt->xmlParserInputState instate = XML_PARSER_EPILOG;
    xmlParseMisc(ctxt);
    if (*ctxt->input->cur) {
      xmlFatalErr(ctxt, 5, 0LL);
    }
    ctxt->xmlParserInputState instate = XML_PARSER_EOF;
  }

  else
  {
    xmlFatalErrMsg(ctxt, 4);
  }

  if (ctxt->sax)
  {
    endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
    if (endDocument) {
      ((void (*)(void *))endDocument)(ctxt->userData);
    }
  }

  xmlDocPtr v21 = ctxt->myDoc;
  if (v21 && xmlStrEqual(v21->version, (const xmlChar *)"SAX compatibility mode document"))
  {
    xmlFreeDoc(ctxt->myDoc);
    ctxt->xmlDocPtr myDoc = 0LL;
  }

  if (!ctxt->wellFormed)
  {
    ctxt->int valid = 0;
    return -1;
  }

  xmlDocPtr v22 = ctxt->myDoc;
  if (!v22) {
    return 0;
  }
  int properties = v22->properties;
  int v24 = properties | 1;
  v22->int properties = properties | 1;
  if (ctxt->valid)
  {
    int v24 = properties | 9;
    v22->int properties = properties | 9;
  }

  if (ctxt->nsWellFormed)
  {
    v24 |= 2u;
    v22->int properties = v24;
  }

  if ((ctxt->options & 0x20000) == 0) {
    return 0;
  }
  int result = 0;
  v22->int properties = v24 | 4;
  return result;
}

void xmlInitParser(void)
{
  if ((xmlParserInitialized & 1) == 0)
  {
    __xmlGlobalInitMutexLock();
    if ((xmlParserInitialized & 1) == 0)
    {
      xmlInitThreads();
      xmlInitGlobals();
      xmlInitMemory();
      xmlInitializeDict();
      xmlInitCharEncodingHandlers();
      xmlDefaultSAXHandlerInit();
      xmlRegisterDefaultInputCallbacks();
      xmlRegisterDefaultOutputCallbacks();
      htmlInitAutoClose();
      htmlDefaultSAXHandlerInit();
      xmlXPathInit();
      xmlParserInitialized = 1;
    }

    __xmlGlobalInitMutexUnlock();
  }

void xmlParseInternalSubset(uint64_t a1)
{
  int v2 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
  if (v2 == 91)
  {
    int v3 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 272) = 3;
    xmlNextChar((xmlParserCtxtPtr)a1);
    while (1)
    {
      uint64_t v4 = *(void *)(a1 + 56);
      BOOL v5 = *(unsigned __int8 **)(v4 + 32);
      int v2 = *v5;
      if (v2 == 93 && *(_DWORD *)(a1 + 64) <= v3) {
        break;
      }
      if (*(_DWORD *)(a1 + 272) == -1) {
        goto LABEL_17;
      }
      uint64_t v6 = *(unsigned int *)(v4 + 64);
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      xmlParseMarkupDecl((xmlParserCtxtPtr)a1);
      xmlParsePEReference((xmlParserCtxtPtr)a1);
      xmlCharEncoding v7 = *(void **)(a1 + 56);
      if (*(int *)(a1 + 64) >= 2)
      {
        if (v7[1])
        {
          xmlParserInputPtr v8 = (_BYTE *)v7[4];
          if (*v8 == 60 && v8[1] == 33 && v8[2] == 91)
          {
            xmlParseConditionalSections(a1);
            xmlCharEncoding v7 = *(void **)(a1 + 56);
          }
        }
      }

      if ((unsigned __int8 *)v7[4] == v5 && v6 == v7[8])
      {
        xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"xmlParseInternalSubset: error detected in Markup declaration\n");
        if (*(_DWORD *)(a1 + 64) <= v3)
        {
          int v2 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
LABEL_17:
          if (v2 != 93) {
            goto LABEL_19;
          }
          break;
        }

        xmlPopInput((xmlParserCtxtPtr)a1);
      }
    }

    xmlNextChar((xmlParserCtxtPtr)a1);
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    int v2 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
  }

LABEL_19:
  if (v2 == 62) {
    xmlNextChar((xmlParserCtxtPtr)a1);
  }
  else {
    xmlFatalErr((_DWORD *)a1, 61, 0LL);
  }
}

    ++v2;
    goto LABEL_20;
  }

  xmlRngVErrMemory(a1, (const xmlChar *)"validating\n");
  return 0LL;
}

      memmove(&buf->content[v3], buf->content, use);
      memmove(buf->content, str, v3);
      uint64_t v4 = 0;
      unsigned int v11 = buf->use + v3;
      buf->uint64_t use = v11;
      buf->content[v11] = 0;
    }
  }

  return v4;
}

      int v3 = 0LL;
      int v2 = *(void *)(v2 + 40);
      if (!v2) {
        return v3;
      }
    }

    while (1)
    {
      uint64_t v6 = *a1;
      if (*a1 && (xmlCharEncoding v7 = (void *)*v6) != 0LL)
      {
        while (1)
        {
          xmlParserInputPtr v8 = (const xmlChar *)v5[3];
          uint64_t v9 = *(const xmlChar **)(v7[3] + 24LL);
          if (v8 == v9 || xmlStrEqual(v8, v9)) {
            break;
          }
          xmlCharEncoding v7 = (void *)*v7;
          if (!v7) {
            goto LABEL_13;
          }
        }

        int v10 = 0;
      }

      else
      {
LABEL_13:
        int v10 = 1;
      }

      int v3 = 0xFFFFFFFFLL;
      unsigned int v11 = xmlDOMWrapNsMapAddItem(a1, 0, 0LL, (uint64_t)v5, -1);
      if (!v11) {
        break;
      }
      if ((v10 & 1) == 0) {
        *((_DWORD *)v11 + 8) = 0;
      }
      BOOL v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_19;
      }
    }
  }

  return v3;
}

  PropNode = (xmlNode *)xmlSchemaGetPropNode(a2, (xmlChar *)"id");
  if (PropNode) {
    xmlSchemaPValAttrNodeID((uint64_t)a1, PropNode);
  }
  int v10 = *(void *)(a2 + 24);
  if (v10)
  {
    xmlDocPtr v22 = v6;
    unsigned int v11 = 0;
    while (1)
    {
      if (!*(void *)(v10 + 72))
      {
LABEL_54:
        if (!v11) {
          xmlSchemaPContentErr((uint64_t)a1, 3033, a2, v10, 0LL, (xmlChar *)"(appinfo | documentation)*");
        }
        unsigned int v11 = 1;
        goto LABEL_57;
      }

      if (xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"appinfo")
        && xmlStrEqual( *(const xmlChar **)(*(void *)(v10 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        unint64_t v12 = *(void *)(v10 + 88);
        if (!v12)
        {
LABEL_35:
          BuiltInType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI);
          xmlSchemaPValAttr(a1, v10, (xmlChar *)"source", BuiltInType, 0LL);
          goto LABEL_57;
        }

        while (2)
        {
          uint64_t v13 = *(void *)(v12 + 72);
          if (v13)
          {
LABEL_28:
            if (!xmlStrEqual(*(const xmlChar **)(v13 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema")) {
              goto LABEL_34;
            }
          }

          else if (xmlStrEqual(*(const xmlChar **)(v12 + 16), (const xmlChar *)"source"))
          {
            uint64_t v13 = *(void *)(v12 + 72);
            if (v13) {
              goto LABEL_28;
            }
LABEL_34:
            unint64_t v12 = *(void *)(v12 + 48);
            if (!v12) {
              goto LABEL_35;
            }
            continue;
          }

          break;
        }

        xmlSchemaPIllegalAttrErr(a1, v12);
        goto LABEL_34;
      }

      if (!*(void *)(v10 + 72)
        || !xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"documentation")
        || !xmlStrEqual( *(const xmlChar **)(*(void *)(v10 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        goto LABEL_54;
      }

      int v15 = *(void *)(v10 + 88);
      if (!v15) {
        goto LABEL_57;
      }
      do
      {
        xmlParserInputPtr v16 = *(void *)(v15 + 72);
        if (!v16)
        {
          xmlParserInputPtr v17 = *(const xmlChar **)(v15 + 16);
          uint64_t v18 = "source";
          goto LABEL_45;
        }

        if (!xmlStrEqual(*(const xmlChar **)(v16 + 16), (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
        {
          if (!xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"lang")) {
            goto LABEL_47;
          }
          xmlParserInputPtr v17 = *(const xmlChar **)(*(void *)(v15 + 72) + 16LL);
          uint64_t v18 = "http://www.w3.org/XML/1998/namespace";
LABEL_45:
          if (xmlStrEqual(v17, (const xmlChar *)v18)) {
            goto LABEL_47;
          }
        }

        xmlSchemaPIllegalAttrErr(a1, v15);
LABEL_47:
        int v15 = *(void *)(v15 + 48);
      }

      while (v15);
      int v19 = *(xmlNode **)(v10 + 88);
      if (v19)
      {
        while (!v19->ns
             || !xmlStrEqual(v19->name, (const xmlChar *)"lang")
             || !xmlStrEqual(v19->ns->href, (const xmlChar *)"http://www.w3.org/XML/1998/namespace"))
        {
          int v19 = v19->next;
          if (!v19) {
            goto LABEL_57;
          }
        }

        int v20 = xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE);
        xmlSchemaPValAttrNode(a1, v19, v20, 0LL);
      }

  v13[5] = a6;
  *((_DWORD *)v13 + 16) |= 2u;
  int result = 0LL;
  if (*((_DWORD *)v13 + 23)) {
    *((_DWORD *)v13 + 22) = 17;
  }
  return result;
}

      if (v7 >> 31) {
        return 0;
      }
      else {
        return v7;
      }
    }

    else
    {
      return -1;
    }
  }

  return v2;
}

    xmlNodePtr cur = cur->parent;
    if (!cur) {
      return cur;
    }
    if (cur == context->doc->children) {
      return 0LL;
    }
    xmlNodePtr node = context->node;
    if (node)
    {
      if (node->type != XML_NAMESPACE_DECL && cur->type != XML_NAMESPACE_DECL)
      {
        xmlDocPtr doc = (xmlNode *)cur->doc;
        if (doc == (xmlNode *)node->doc) {
          continue;
        }
      }
    }

    return cur;
  }

  while (doc == cur);
  if (doc != node)
  {
    while (1)
    {
      xmlNodePtr node = node->parent;
      if (!node) {
        break;
      }
      if (node == cur) {
        goto LABEL_18;
      }
    }
  }

  return cur;
}

    unint64_t v12 = *((void *)v3 + 1);
    uint64_t v13 = *v3;
    _BYTE *v3 = v13 + 1;
    *(void *)(v12 + 8 * v13) = v6;
LABEL_20:
    if (++v4 >= *a2) {
      goto LABEL_23;
    }
  }

  if ((int)v9 < 10000000)
  {
    int v10 = xmlRealloc(*((void **)v3 + 1), 16 * v9);
    if (!v10) {
      goto LABEL_24;
    }
    *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v10;
    unsigned int v11 = 2 * v3[1];
LABEL_18:
    v3[1] = v11;
    goto LABEL_19;
  }

  xmlParserInputPtr v14 = "merging nodeset hit limit\n";
  int v10 = 0LL;
LABEL_26:
  xmlXPathErrMemory((uint64_t)v10, v14);
  return 0LL;
}

void xmlCleanSpecialAttr(void *data)
{
  int v2 = (xmlHashTable *)*((void *)data + 69);
  if (v2)
  {
    xmlHashScanFull(v2, (xmlHashScannerFull)xmlCleanSpecialAttrCallback, data);
    if (!xmlHashSize(*((xmlHashTablePtr *)data + 69)))
    {
      xmlHashFree(*((xmlHashTablePtr *)data + 69), 0LL);
      *((void *)data + 69) = 0LL;
    }
  }

int xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return -1;
  }
  if (!ctxt->input) {
    return -1;
  }
  xmlDefaultSAXHandlerInit();
  xmlDetectSAX2((const xmlChar *)ctxt);
  if (!ctxt->progressive && ctxt->input->end - ctxt->input->cur <= 249) {
    xmlGROW((uint64_t)ctxt);
  }
  if (ctxt->sax)
  {
    setDocumentLocatorSAXFunc setDocumentLocator = ctxt->sax->setDocumentLocator;
    if (setDocumentLocator)
    {
      userData = ctxt->userData;
      uint64_t v4 = __xmlDefaultSAXLocator();
      ((void (*)(void *, xmlSAXLocator *))setDocumentLocator)(userData, v4);
    }
  }

  *(_DWORD *)in = 0;
  xmlNodePtr cur = ctxt->input->cur;
  if (ctxt->input->end - cur >= 4)
  {
    *(_DWORD *)in = *(_DWORD *)cur;
    xmlCharEncoding v6 = xmlDetectCharEncoding(in, 4);
    if (v6) {
      xmlSwitchEncoding(ctxt, v6);
    }
  }

  xmlParserInputPtr input = ctxt->input;
  if (!*input->cur)
  {
    xmlFatalErr(ctxt, 4, 0LL);
    xmlParserInputPtr input = ctxt->input;
  }

  if (!ctxt->progressive && input->end - input->cur <= 249)
  {
    xmlGROW((uint64_t)ctxt);
    xmlParserInputPtr input = ctxt->input;
  }

  xmlParserInputPtr v8 = input->cur;
  if (*v8 != 60
    || v8[1] != 63
    || v8[2] != 120
    || v8[3] != 109
    || v8[4] != 108
    || (unsigned int v9 = v8[5], v9 > 0x20)
    || ((1LL << v9) & 0x100002600LL) == 0)
  {
    ctxt->version = xmlCharStrdup("1.0");
    goto LABEL_27;
  }

  xmlParseXMLDecl(ctxt);
  if (ctxt->errNo == 32) {
    return -1;
  }
  xmlSkipBlankChars(ctxt);
LABEL_27:
  if (ctxt->sax)
  {
    startDocumentSAXFunc startDocument = ctxt->sax->startDocument;
    if (startDocument)
    {
      if (!ctxt->disableSAX) {
        ((void (*)(void *))startDocument)(ctxt->userData);
      }
    }
  }

  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  ctxt->xmlParserInputState instate = XML_PARSER_CONTENT;
  ctxt->validate = 0;
  ctxt->loadsubset = 0;
  ctxt->int depth = 0;
  xmlParseContent(ctxt);
  if (ctxt->instate == XML_PARSER_EOF) {
    return -1;
  }
  unsigned int v11 = ctxt->input->cur;
  if (*v11)
  {
    if (*v11 == 60 && v11[1] == 47) {
      int v12 = 85;
    }
    else {
      int v12 = 86;
    }
    xmlFatalErr(ctxt, v12, 0LL);
  }

  if (ctxt->sax)
  {
    endDocumentSAXFunc endDocument = ctxt->sax->endDocument;
    if (endDocument) {
      ((void (*)(void *))endDocument)(ctxt->userData);
    }
  }

  if (ctxt->wellFormed) {
    return 0;
  }
  else {
    return -1;
  }
}

int xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  if (!ctxt) {
    return 1;
  }
  if (ctxt->wellFormed != 1 && ctxt->disableSAX == 1) {
    return ctxt->errNo;
  }
  xmlParserInputState instate = ctxt->instate;
  if (instate != XML_PARSER_EOF)
  {
    if (instate == XML_PARSER_START) {
      xmlDetectSAX2((const xmlChar *)ctxt);
    }
    if (!chunk || (int v9 = size - 1, size < 1) || terminate)
    {
      BOOL v55 = 0;
    }

    else
    {
      BOOL v55 = chunk[v9] == 13;
      if (chunk[v9] == 13) {
        --size;
      }
    }

    size_t v10 = 0LL;
    size_t v11 = 0LL;
    while (1)
    {
      if (size >= 1)
      {
        if (chunk)
        {
          xmlParserInputPtr input = ctxt->input;
          if (input)
          {
            if (input->buf) {
              break;
            }
          }
        }
      }

      if (ctxt->instate == XML_PARSER_EOF) {
        goto LABEL_46;
      }
      xmlParserInputPtr v22 = ctxt->input;
      if (v22)
      {
        uint64_t buf = (uint64_t)v22->buf;
        if (v22->buf)
        {
          if (*(void *)(buf + 24))
          {
            uint64_t v24 = *(void *)(buf + 32);
            if (v24)
            {
              if (*(void *)(buf + 40))
              {
                unint64_t InputBase = xmlBufGetInputBase(v24, (uint64_t)v22);
                uint64_t v26 = ctxt->input->cur - ctxt->input->base;
                int v27 = xmlCharEncInput(buf, terminate);
                xmlBufSetInputBaseCur(*(uint64_t **)(buf + 32), &ctxt->input->buf, InputBase, v26);
                if (v27 < 0)
                {
                  xmlGenericErrorFunc v53 = *__xmlGenericError();
                  BOOL v54 = __xmlGenericErrorContext();
                  v53(*v54, "xmlParseChunk: encoder error\n");
                  xmlHaltParser(ctxt);
                  return 81;
                }
              }
            }
          }

void xmlParseTryOrFinish(uint64_t a1, int a2)
{
  uint64_t v171 = *MEMORY[0x1895F89C0];
  int v161 = 0;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return;
  }
  if ((uint64_t)(*(void *)(v2 + 32) - *(void *)(v2 + 24)) > 4096)
  {
    xmlSHRINK(a1);
    *(void *)(a1 + 320) = 0LL;
  }

  unint64_t v159 = 0LL;
  unint64_t v160 = 0LL;
  xmlParseGetLasts(a1, &v160, &v159);
  int v5 = *(_DWORD *)(a1 + 272);
  if (v5 == -1) {
    return;
  }
  int v157 = 0;
  xmlCharEncoding v6 = "1.0";
  while (2)
  {
    if (*(_DWORD *)(a1 + 24) != 1 && *(_DWORD *)(a1 + 332) == 1) {
      return;
    }
    xmlCharEncoding v7 = *(xmlParserInput **)(a1 + 56);
    if (!v7) {
      return;
    }
    if (v7->buf)
    {
      if (v5)
      {
        uint64_t raw = (uint64_t)v7->buf->raw;
        if (raw)
        {
          int IsEmpty = xmlBufIsEmpty(raw);
          xmlCharEncoding v7 = *(xmlParserInput **)(a1 + 56);
          if (!IsEmpty)
          {
            unint64_t InputBase = xmlBufGetInputBase((uint64_t)v7->buf->buffer, (uint64_t)v7);
            uint64_t v11 = *(void *)(a1 + 56);
            uint64_t v12 = *(void *)(v11 + 32) - *(void *)(v11 + 24);
            xmlParserInputBufferPush(*(xmlParserInputBufferPtr *)v11, 0, &byte_181A3ACBA);
            xmlBufSetInputBaseCur(*(uint64_t **)(**(void **)(a1 + 56) + 32LL), *(void **)(a1 + 56), InputBase, v12);
            xmlCharEncoding v7 = *(xmlParserInput **)(a1 + 56);
          }
        }
      }

      size_t length = xmlBufUse(v7->buf->buffer);
      xmlCharEncoding v7 = *(xmlParserInput **)(a1 + 56);
    }

    else
    {
      size_t length = v7->length;
    }

    unint64_t base = v7->base;
    xmlNodePtr cur = v7->cur;
    unint64_t v16 = (unint64_t)&base[length - (void)cur];
    if (!v16) {
      return;
    }
    int v5 = *(_DWORD *)(a1 + 272);
    switch(v5)
    {
      case -1:
        return;
      case 0:
        if (!*(_DWORD *)(a1 + 408))
        {
          *(_DWORD *)in = 0;
          if (v16 >= 4)
          {
            *(_DWORD *)in = *(_DWORD *)cur;
            xmlCharEncoding v74 = xmlDetectCharEncoding(in, 4);
            xmlSwitchEncoding((xmlParserCtxtPtr)a1, v74);
            goto LABEL_291;
          }

          return;
        }

        if (v16 < 2) {
          return;
        }
        if (*cur)
        {
          if (*cur == 60 && cur[1] == 63)
          {
            if (v16 < 5 || !a2 && (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) != 0) {
              return;
            }
            if (*(void *)a1)
            {
              xmlParserInputPtr v17 = *(void (**)(uint64_t, xmlSAXLocator *))(*(void *)a1 + 88LL);
              if (v17)
              {
                uint64_t v18 = *(void *)(a1 + 8);
                uint64_t v19 = __xmlDefaultSAXLocator();
                v17(v18, v19);
              }
            }

            int v20 = *(_BYTE **)(*(void *)(a1 + 56) + 32LL);
            if (v20[2] == 120 && v20[3] == 109 && v20[4] == 108)
            {
              unsigned int v21 = v20[5];
              if (v21 <= 0x20 && ((1LL << v21) & 0x100002600LL) != 0)
              {
                xmlParseXMLDecl((xmlParserCtxtPtr)a1);
                if (*(_DWORD *)(a1 + 136) == 32)
                {
                  xmlHaltParser((xmlParserCtxtPtr)a1);
                  return;
                }

                uint64_t v22 = *(void *)(a1 + 56);
                *(_DWORD *)(a1 + 48) = *(_DWORD *)(v22 + 96);
                if (!*(void *)(a1 + 40))
                {
                  uint64_t v23 = *(const xmlChar **)(v22 + 80);
                  if (v23) {
                    *(void *)(a1 + 40) = xmlStrdup(v23);
                  }
                }

                if (*(void *)a1)
                {
                  uint64_t v24 = *(void (**)(void))(*(void *)a1 + 96LL);
                  if (v24)
                  {
                    if (!*(_DWORD *)(a1 + 332)) {
                      v24(*(void *)(a1 + 8));
                    }
                  }
                }

                v157 += 5;
LABEL_200:
                int v5 = 1;
                goto LABEL_340;
              }
            }

            *(void *)(a1 + 32) = xmlCharStrdup(v6);
          }

          else
          {
            if (*(void *)a1)
            {
              uint64_t v88 = *(void (**)(uint64_t, xmlSAXLocator *))(*(void *)a1 + 88LL);
              if (v88)
              {
                uint64_t v89 = *(void *)(a1 + 8);
                int v90 = __xmlDefaultSAXLocator();
                v88(v89, v90);
              }
            }

            uint64_t v91 = xmlCharStrdup(v6);
            *(void *)(a1 + 32) = v91;
            if (!v91)
            {
              htmlErrMemory((_DWORD *)a1, 0LL);
              goto LABEL_291;
            }
          }

          if (*(void *)a1)
          {
            uint64_t v92 = *(void (**)(void))(*(void *)a1 + 96LL);
            if (v92)
            {
              if (!*(_DWORD *)(a1 + 332)) {
                v92(*(void *)(a1 + 8));
              }
            }
          }

          goto LABEL_200;
        }

        if (*(void *)a1)
        {
          __int128 v153 = *(void (**)(uint64_t, xmlSAXLocator *))(*(void *)a1 + 88LL);
          if (v153)
          {
            uint64_t v154 = *(void *)(a1 + 8);
            __int128 v155 = __xmlDefaultSAXLocator();
            v153(v154, v155);
          }
        }

LABEL_391:
        __int128 v146 = (_DWORD *)a1;
        int v147 = 4;
        goto LABEL_392;
      case 1:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        uint64_t v25 = *(void *)(a1 + 56);
        if (*(void *)v25)
        {
          size_t v26 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v25 + 32LL));
          uint64_t v25 = *(void *)(a1 + 56);
        }

        else
        {
          size_t v26 = *(int *)(v25 + 48);
        }

        int v75 = *(unsigned __int8 **)(v25 + 32);
        unint64_t v76 = v26 - (void)v75 + *(void *)(v25 + 24);
        if (v76 < 2) {
          return;
        }
        int v77 = *v75;
        int v78 = v75[1];
        if (v77 == 60 && v78 == 63)
        {
          if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
          {
            xmlParsePI((xmlParserCtxtPtr)a1);
            goto LABEL_146;
          }

          goto LABEL_387;
        }

        if (v77 != 60 || v78 != 33) {
          goto LABEL_288;
        }
        int v79 = v75[2];
        if (v79 == 68)
        {
          if (v75[3] != 79 || v75[4] != 67 || v75[5] != 84 || v75[6] != 89 || v75[7] != 80 || v75[8] != 69) {
            goto LABEL_287;
          }
          if (!a2 && (xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
          {
            int v152 = 3;
            goto LABEL_399;
          }

          *(_DWORD *)(a1 + 336) = 1;
          *(_DWORD *)(a1 + 452) = 0;
          *(void *)(a1 + 320) = 0LL;
          xmlParseDocTypeDecl((xmlParserCtxtPtr)a1);
          if (*(_DWORD *)(a1 + 272) == -1) {
            return;
          }
          if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) == 91)
          {
LABEL_123:
            int v5 = 3;
          }

          else
          {
            *(_DWORD *)(a1 + 336) = 2;
            if (*(void *)a1)
            {
              if (!*(_DWORD *)(a1 + 332))
              {
                int v120 = *(void (**)(void, void, void, void))(*(void *)a1 + 208LL);
                if (v120) {
                  v120(*(void *)(a1 + 8), *(void *)(a1 + 344), *(void *)(a1 + 360), *(void *)(a1 + 352));
                }
              }
            }

            *(_DWORD *)(a1 + 336) = 0;
            xmlCleanSpecialAttr((void *)a1);
            int v5 = 4;
          }

LABEL_340:
          *(_DWORD *)(a1 + 272) = v5;
          goto LABEL_341;
        }

        if (v79 != 45 || v75[3] != 45)
        {
LABEL_287:
          if (v76 < 9) {
            return;
          }
LABEL_288:
          *(_DWORD *)(a1 + 272) = 6;
          goto LABEL_289;
        }

        if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0)
        {
LABEL_398:
          int v152 = 5;
          goto LABEL_399;
        }

        xmlParseComment((xmlParserCtxtPtr)a1);
LABEL_146:
        if (*(_DWORD *)(a1 + 272) != -1)
        {
          int v5 = 1;
          *(_DWORD *)(a1 + 272) = 1;
          *(_DWORD *)(a1 + 452) = 1;
          goto LABEL_148;
        }

        return;
      case 2:
        xmlGenericErrorFunc v27 = *__xmlGenericError();
        int v28 = *__xmlGenericErrorContext();
        unsigned int v29 = "PP: internal error, state == PI\n";
        goto LABEL_117;
      case 3:
        unsigned int v30 = (_DWORD)cur - (_DWORD)base;
        if ((_DWORD)cur - (_DWORD)base < 0) {
          return;
        }
        uint64_t v31 = *(void *)(a1 + 320);
        if (v31 <= v30) {
          size_t v32 = v30;
        }
        else {
          size_t v32 = v31;
        }
        LODWORD(v33) = v32;
        unsigned int v34 = xmlBufContent(v7->buf->buffer);
        size_t v35 = xmlBufUse(*(const xmlBufPtr *)(**(void **)(a1 + 56) + 32LL));
        if (v35 <= v32) {
          goto LABEL_360;
        }
        unsigned __int8 v36 = 0;
        uint64_t v37 = v34 + 1;
        while (2)
        {
          int v38 = v34[(int)v33];
          if (v36)
          {
            if (v38 == v36) {
              unsigned __int8 v36 = 0;
            }
            goto LABEL_82;
          }

          if (v35 > (v33 + 4) && v38 == 60)
          {
            uint64_t v39 = (int)v33;
            unint64_t v40 = &v34[(int)v33];
            while (v34[v39] != 45 || v37[v39] != 45 || v37[v39 + 1] != 62)
            {
              size_t v41 = (v39++ + 4);
              if (v35 <= v41)
              {
                LODWORD(v33) = v39;
                goto LABEL_360;
              }
            }

            unsigned __int8 v36 = 0;
            LODWORD(v33) = v39 + 2;
            goto LABEL_82;
          }

          if (v38 == 34)
          {
            unsigned __int8 v36 = 34;
            goto LABEL_82;
          }

          if (v38 != 93)
          {
            if (v38 == 39)
            {
              unsigned __int8 v36 = 39;
              goto LABEL_82;
            }

LABEL_81:
            unsigned __int8 v36 = 0;
LABEL_82:
            size_t v33 = (v33 + 1);
            if (v35 <= v33)
            {
              if (v36) {
                uint64_t v133 = 0LL;
              }
              else {
LABEL_360:
              }
                uint64_t v133 = (int)v33;
              *(void *)(a1 + 320) = v133;
              return;
            }

            continue;
          }

          break;
        }

        size_t v42 = (v33 + 1);
        if (v35 <= v42) {
          goto LABEL_360;
        }
        if (v34[(int)v42] == 93)
        {
          unsigned __int8 v36 = 0;
          LODWORD(v33) = v33 + 1;
          goto LABEL_82;
        }

        LODWORD(v43) = v33 + 1;
        while (1)
        {
          uint64_t v44 = v34[(int)v43];
          if (((1LL << v44) & 0x100002600LL) == 0) {
            break;
          }
          size_t v43 = (v43 + 1);
          if (v35 <= v43) {
            goto LABEL_360;
          }
        }

        if (v44 != 62) {
          goto LABEL_81;
        }
        *(void *)(a1 + 320) = 0LL;
        xmlParseInternalSubset(a1);
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        *(_DWORD *)(a1 + 336) = 2;
        if (*(void *)a1)
        {
          if (!*(_DWORD *)(a1 + 332))
          {
            xmlGenericErrorFunc v126 = *(void (**)(void, void, void, void))(*(void *)a1 + 208LL);
            if (v126) {
              v126(*(void *)(a1 + 8), *(void *)(a1 + 344), *(void *)(a1 + 360), *(void *)(a1 + 352));
            }
          }
        }

        *(_DWORD *)(a1 + 336) = 0;
        xmlCleanSpecialAttr((void *)a1);
        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        int v5 = 4;
        *(_DWORD *)(a1 + 272) = 4;
LABEL_148:
        *(void *)(a1 + 320) = 0LL;
LABEL_341:
        if (v5 == -1) {
          return;
        }
        continue;
      case 4:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        uint64_t v45 = *(void *)(a1 + 56);
        if (*(void *)v45)
        {
          size_t v46 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v45 + 32LL));
          uint64_t v45 = *(void *)(a1 + 56);
        }

        else
        {
          size_t v46 = *(int *)(v45 + 48);
        }

        unint64_t v80 = *(unsigned __int8 **)(v45 + 32);
        unint64_t v81 = v46 - (void)v80 + *(void *)(v45 + 24);
        if (v81 < 2) {
          return;
        }
        int v82 = *v80;
        int v83 = v80[1];
        if (v82 != 60 || v83 != 63)
        {
          if (v82 == 60 && v83 == 33)
          {
            if (v80[2] == 45 && v80[3] == 45)
            {
              if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0) {
                goto LABEL_398;
              }
              xmlParseComment((xmlParserCtxtPtr)a1);
              goto LABEL_164;
            }

            if (v81 < 4) {
              return;
            }
          }

          *(_DWORD *)(a1 + 272) = 6;
          if (*(_DWORD *)(a1 + 452))
          {
LABEL_290:
            xmlParseGetLasts(a1, &v160, &v159);
LABEL_291:
            int v5 = *(_DWORD *)(a1 + 272);
            goto LABEL_341;
          }

            uint64_t v39 = *(void *)(v39 + 48);
            unint64_t v40 = v41;
            if (!v39) {
              goto LABEL_49;
            }
          }

          size_t v41 = v40;
          goto LABEL_81;
        }
      }
    }

          int v57 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI);
          uint64_t v58 = xmlSchemaPValAttr((_DWORD *)a1, (uint64_t)children, (xmlChar *)"namespace", v57, &str2);
          uint64_t v59 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI);
          if (v58)
          {
            int v60 = str2;
LABEL_96:
            xmlSchemaPSimpleTypeErr(a1, 3037, (uint64_t)children, (uint64_t)v59, 0LL, v60, 0LL, 0);
LABEL_97:
            uint64_t v24 = *(unsigned int *)(a1 + 32);
            goto LABEL_98;
          }

          if (xmlSchemaPValAttr( (_DWORD *)a1,  (uint64_t)children,  (xmlChar *)"schemaLocation",  v59,  (xmlChar **)v105))
          {
            uint64_t v59 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI);
            int v60 = *(const xmlChar **)v105;
            goto LABEL_96;
          }

          xmlGenericErrorFunc v65 = (uint64_t)children->children;
          if (v65)
          {
            if (!*(void *)(v65 + 72)
              || !xmlStrEqual(*(const xmlChar **)(v65 + 16), (const xmlChar *)"annotation")
              || !xmlStrEqual( *(const xmlChar **)(*(void *)(v65 + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema")
              || (xmlGenericErrorFunc v65 = *(void *)(v65 + 48)) != 0)
            {
              xmlSchemaPContentErr(a1, 3033, (uint64_t)children, v65, 0LL, (xmlChar *)"(annotation?)");
            }
          }

          uint64_t v66 = *(void *)(*(void *)(a1 + 48) + 32LL);
          uint64_t v67 = *(void *)(v66 + 16);
          if (str2)
          {
            if (xmlStrEqual(*(const xmlChar **)(v66 + 16), str2))
            {
              size_t v68 = a1;
              xmlGenericErrorFunc v69 = 3064;
              xmlEntityPtr v70 = (uint64_t)children;
              xmlGenericErrorFunc v71 = "The value of the attribute 'namespace' must not match the target namespace '%s' of the importing schema";
LABEL_125:
              xmlSchemaPCustomErrExt(v68, v69, 0LL, v70, (const xmlChar *)v71);
              goto LABEL_97;
            }
          }

          else if (!v67)
          {
            size_t v68 = a1;
            xmlGenericErrorFunc v69 = 3065;
            xmlEntityPtr v70 = (uint64_t)children;
            xmlGenericErrorFunc v71 = "The attribute 'namespace' must be existent if the importing schema has no target namespace";
            goto LABEL_125;
          }

          if (*(void *)v105)
          {
            int v72 = xmlSchemaBuildAbsoluteURI(*(xmlDict **)(a1 + 152), *(xmlChar **)v105, children);
            *(void *)int v105 = v72;
          }

          else
          {
            int v72 = 0LL;
          }

          uint64_t v24 = xmlSchemaAddSchemaDoc(a1, 1u, v72, 0LL, 0LL, 0, (uint64_t)children, v67, str2, &v104);
          if (!(_DWORD)v24)
          {
            int v73 = v104;
            if (!v104 && *(void *)v105)
            {
              xmlSchemaCustomWarning( (_DWORD *)a1,  3084,  (uint64_t)children,  (const xmlChar *)"Failed to locate a schema at location '%s'. Skipping the import",  *(const xmlChar **)v105,  0LL,  0LL);
              int v73 = v104;
            }

            if (!v73 || !v73[4] || *((_DWORD *)v73 + 13))
            {
              uint64_t v24 = 0LL;
LABEL_99:
              if (*(_DWORD *)(a1 + 196) || v54 != *(_DWORD *)(a1 + 36))
              {
LABEL_218:
                *(void *)(a1 + 160) = 0LL;
                xmlCharEncoding v7 = v102;
                if (v101 != *(_DWORD *)(a1 + 36)) {
                  uint64_t v24 = *(unsigned int *)(a1 + 32);
                }
                goto LABEL_45;
              }

              goto LABEL_101;
            }

            uint64_t v24 = xmlSchemaParseNewDoc(a1, a2, (uint64_t)v73);
          }

        size_t v32 = xmlSchemaAddParticle(a1, *(void *)(a2 + 72), 1, 1);
        if (!v32) {
          goto LABEL_19;
        }
        uint64_t v22 = v32;
        size_t v33 = xmlSchemaAddModelGroup(a1, *(void *)(a1 + 64), 6, *(void *)(a2 + 72));
        v22[3] = v33;
        if (!v33) {
          goto LABEL_19;
        }
        *(void *)(a2 + 56) = v22;
        goto LABEL_84;
      }
    }

    else
    {
      size_t v26 = *(_DWORD *)(a2 + 88);
      if ((v26 & 1) != 0) {
        goto LABEL_81;
      }
    }

    *(_DWORD *)(a2 + 92) = 1;
    if ((v26 & 4) == 0)
    {
      *(_DWORD *)(a2 + 92) = v6->contentType;
      *(void *)(a2 + 56) = v6->subtypes;
      *(void *)(a2 + 192) = v6->contentTypeDef;
    }

    goto LABEL_110;
  }

  xmlElementType type = v6->type;
  if (v6->type != XML_SCHEMA_TYPE_COMPLEX && v6->builtInType != 45)
  {
LABEL_50:
    if (type != XML_SCHEMA_TYPE_SIMPLE && (type != XML_SCHEMA_TYPE_BASIC || v6->builtInType == 45)
      || (*(_BYTE *)(a2 + 88) & 2) == 0)
    {
      size_t v10 = "Internal error: xmlSchemaTypeFixup, complex type '%s' with <simpleContent>: unhandled derivation case";
      goto LABEL_55;
    }

    *(void *)(a2 + 192) = v6;
    goto LABEL_110;
  }

  contentTypeDef = v6->contentTypeDef;
  if (!contentTypeDef || (*(_BYTE *)(a2 + 88) & 4) == 0)
  {
    if (type == XML_SCHEMA_TYPE_COMPLEX || v6->builtInType == 45)
    {
      if (v6->contentType == XML_SCHEMA_CONTENT_MIXED && (*(_BYTE *)(a2 + 88) & 4) != 0)
      {
        size_t v41 = *(void *)(a2 + 192);
        if (!v41 || !*(void *)(v41 + 112))
        {
          size_t v10 = "Internal error: xmlSchemaTypeFixup, complex type '%s': the <simpleContent><restriction> is missing a <si"
                "mpleType> child, but was not caught by xmlSchemaCheckSRCCT()";
          goto LABEL_55;
        }

        goto LABEL_110;
      }

      if ((type == XML_SCHEMA_TYPE_COMPLEX || v6->builtInType == 45) && (*(_BYTE *)(a2 + 88) & 2) != 0)
      {
        if (!contentTypeDef)
        {
          size_t v10 = "Internal error: xmlSchemaTypeFixup, complex type '%s': the <extension>ed base type is a complex type wit"
                "h no simple content type";
          goto LABEL_55;
        }

        *(void *)(a2 + 192) = contentTypeDef;
        goto LABEL_110;
      }
    }

    goto LABEL_50;
  }

  xmlGenericErrorFunc v27 = *(xmlSchemaTypePtr *)(a2 + 192);
  if (v27)
  {
    *(void *)(a2 + 192) = 0LL;
    contentTypeDef = v27;
  }

  int v28 = (xmlSchemaType *)xmlSchemaAddType( a1,  *(void *)(a1 + 64),  4,  0LL,  *(void *)(a2 + 208),  *(void *)(a2 + 72),  0);
  if (!v28) {
    goto LABEL_19;
  }
  unsigned int v29 = v28;
  v28->xmlElementType type = XML_SCHEMA_TYPE_SIMPLE;
  v28->baseType = contentTypeDef;
  v28->facets = *(xmlSchemaFacetPtr *)(a2 + 120);
  *(void *)(a2 + 120) = 0LL;
  v28->facetSet = *(xmlSchemaFacetLinkPtr *)(a2 + 176);
  *(void *)(a2 + 176) = 0LL;
  *(void *)(a2 + 192) = v28;
  if (contentTypeDef->type != XML_SCHEMA_TYPE_BASIC && (contentTypeDef->flags & 0x400000) == 0) {
    xmlSchemaTypeFixup(contentTypeDef, (xmlSchemaParserCtxtPtr)a1);
  }
  unsigned int v30 = xmlSchemaFixupSimpleTypeStageOne((_DWORD *)a1, (uint64_t)v29);
  if (v30 == -1) {
    goto LABEL_19;
  }
  if (v30) {
    goto LABEL_34;
  }
  uint64_t v31 = xmlSchemaFixupSimpleTypeStageTwo((xmlSchemaParserCtxtPtr)a1, v29);
  if (v31 == -1) {
    goto LABEL_19;
  }
  if (v31) {
    goto LABEL_34;
  }
LABEL_110:
  size_t v42 = *(void *)(a2 + 112);
  if (!v42)
  {
    uint64_t v11 = "xmlSchemaFixupTypeAttributeUses";
    uint64_t v12 = "no base type";
    goto LABEL_18;
  }

  int v96 = v5;
  if (*(_DWORD *)v42 != 1
    && (*(_BYTE *)(v42 + 90) & 0x40) == 0
    && xmlSchemaTypeFixup((xmlSchemaTypePtr)v42, (xmlSchemaParserCtxtPtr)a1) == -1)
  {
    goto LABEL_19;
  }

  size_t v43 = *(void **)(a2 + 216);
  uint64_t v44 = *(void *)(v42 + 216);
  if (v43)
  {
    uint64_t v45 = (uint64_t *)(a2 + 152);
    if ((*(_BYTE *)(a2 + 88) & 4) != 0)
    {
      if (xmlSchemaExpandAttributeGroupRefs( a1,  (_DWORD *)a2,  v45,  *(void *)(a2 + 216),  *(void *)(a1 + 232)) == -1)
      {
LABEL_135:
        uint64_t v11 = "xmlSchemaFixupTypeAttributeUses";
        uint64_t v12 = "failed to expand attributes";
        goto LABEL_18;
      }

      if (*(_DWORD *)(*(void *)(a1 + 232) + 8LL)) {
        size_t v46 = *(uint64_t **)(a1 + 232);
      }
      else {
        size_t v46 = 0LL;
      }
    }

    else
    {
      size_t v46 = 0LL;
    }
  }

  else
  {
    size_t v46 = 0LL;
  }

  if (!v44)
  {
LABEL_154:
    if (!v43) {
      goto LABEL_159;
    }
    goto LABEL_155;
  }

  if ((*(_BYTE *)(a2 + 88) & 4) != 0)
  {
    if (v43) {
      int v51 = *((_DWORD *)v43 + 2);
    }
    else {
      int v51 = 0;
    }
    uint64_t v52 = *(_DWORD *)(v44 + 8);
    if (v52 >= 1)
    {
      uint64_t v53 = 0LL;
      while (1)
      {
        uint64_t v54 = *(void *)(*(void *)v44 + 8 * v53);
        if (v46 && (BOOL v55 = *((unsigned int *)v46 + 2), (int)v55 >= 1))
        {
          uint64_t v56 = *v46;
          int v57 = *(void *)(v54 + 24);
          while (*(void *)(v57 + 16) != *(void *)(*(void *)v56 + 16LL)
               || *(void *)(v57 + 112) != *(void *)(*(void *)v56 + 24LL))
          {
            v56 += 8LL;
            if (!--v55) {
              goto LABEL_145;
            }
          }
        }

        else
        {
LABEL_145:
          if (v51 < 1)
          {
LABEL_150:
            if (!v43)
            {
              size_t v43 = xmlSchemaItemListCreate();
              *(void *)(a2 + 216) = v43;
              if (!v43) {
                goto LABEL_19;
              }
            }

            xmlSchemaItemListAddSize((uint64_t)v43, 2, v54);
            uint64_t v52 = *(_DWORD *)(v44 + 8);
          }

          else
          {
            uint64_t v58 = (char *)*v43;
            uint64_t v59 = *(void *)(v54 + 24);
            int v60 = v51;
            while (1)
            {
              xmlGenericErrorFunc v61 = *(void *)(*(void *)v58 + 24LL);
              if (*(void *)(v59 + 16) == *(void *)(v61 + 16) && *(void *)(v59 + 112) == *(void *)(v61 + 112)) {
                break;
              }
              v58 += 8;
              if (!--v60) {
                goto LABEL_150;
              }
            }
          }
        }

        if (++v53 >= v52) {
          goto LABEL_154;
        }
      }
    }

    goto LABEL_154;
  }

  LODWORD(v47) = *(_DWORD *)(v44 + 8);
  unint64_t v48 = 0LL;
  do
  {
    int v49 = *(void *)(*(void *)v44 + 8 * v48);
    if (!v43)
    {
      int v50 = xmlSchemaItemListCreate();
      *(void *)(a2 + 216) = v50;
      if (!v50) {
        goto LABEL_19;
      }
      size_t v43 = v50;
      LODWORD(v47) = *(_DWORD *)(v44 + 8);
    }

    xmlSchemaItemListAddSize((uint64_t)v43, v47, v49);
    ++v48;
    int v47 = *(int *)(v44 + 8);
  }

  while (v48 < v47);
LABEL_155:
  if (!*((_DWORD *)v43 + 2))
  {
    if (*v43) {
      xmlFree((void *)*v43);
    }
    xmlFree(v43);
    *(void *)(a2 + 216) = 0LL;
  }

LABEL_289:
          *(_DWORD *)(a1 + 452) = 6;
          goto LABEL_290;
        }

        if (a2 || (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) == 0)
        {
          xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_164:
          if (*(_DWORD *)(a1 + 272) == -1) {
            return;
          }
          int v5 = 4;
          goto LABEL_189;
        }

        goto LABEL_387;
      case 5:
        xmlGenericErrorFunc v27 = *__xmlGenericError();
        int v28 = *__xmlGenericErrorContext();
        unsigned int v29 = "PP: internal error, state == COMMENT\n";
        goto LABEL_117;
      case 6:
        int v47 = v6;
        *(void *)in = 0LL;
        uint64_t v158 = 0LL;
        int line = v7->line;
        int v49 = *(_DWORD *)(a1 + 508);
        if (v16 <= 1 && *(_DWORD *)(a1 + 64) == 1) {
          return;
        }
        if (*cur != 60) {
          goto LABEL_391;
        }
        if (a2) {
          goto LABEL_232;
        }
        if (*(_DWORD *)(a1 + 452))
        {
        }

        else if ((xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
        {
          return;
        }

LABEL_387:
          int v152 = 2;
LABEL_399:
          *(_DWORD *)(a1 + 452) = v152;
          return;
        }

        if (v50 == 60 && v51 != 33)
        {
LABEL_125:
          int v5 = 6;
          goto LABEL_340;
        }

        BOOL v93 = v50 == 60 && v51 == 33;
        char v94 = v93;
        if (v93)
        {
          int v95 = cur[2];
          if (v95 == 45)
          {
            if (cur[3] == 45)
            {
              if (v16 < 4) {
                return;
              }
              v7->xmlNodePtr cur = cur + 4;
              int v96 = xmlParseLookupSequence(a1, 45, 45, 62);
              *(void *)(*(void *)(a1 + 56) + 32LL) -= 4LL;
              if (!a2 && v96 < 0) {
                goto LABEL_398;
              }
              xmlParseComment((xmlParserCtxtPtr)a1);
              goto LABEL_131;
            }

            goto LABEL_305;
          }
        }

        else
        {
          if (v50 != 60)
          {
            if (v50 == 38)
            {
              if (!a2 && (xmlParseLookupSequence(a1, 59, 0, 0) & 0x80000000) != 0) {
                return;
              }
              xmlParseReference((xmlParserCtxtPtr)a1);
              goto LABEL_355;
            }

            goto LABEL_347;
          }

          if (v51 != 33)
          {
LABEL_347:
            if (!a2 && v16 <= 0x12B && *(_DWORD *)(a1 + 64) == 1)
            {
              if (*(_DWORD *)(a1 + 452))
              {
              }

              else if ((xmlParseLookupSequence(a1, 60, 0, 0) & 0x80000000) != 0)
              {
                return;
              }
            }

            *(void *)(a1 + 320) = 0LL;
            xmlParseCharData((xmlParserCtxtPtr)a1, 0);
            goto LABEL_355;
          }

          int v95 = cur[2];
        }

        if (v95 == 91 && cur[3] == 67 && cur[4] == 68 && cur[5] == 65 && cur[6] == 84 && cur[7] == 65 && cur[8] == 91)
        {
          v7->xmlNodePtr cur = cur + 9;
          v7->col += 9;
          if (!cur[9]) {
            xmlParserInputGrow(v7, 250);
          }
          int v5 = 8;
          *(_DWORD *)(a1 + 272) = 8;
          goto LABEL_341;
        }

LABEL_305:
        if (v16 >= 9) {
          char v94 = 0;
        }
        if ((v94 & 1) != 0) {
          return;
        }
        goto LABEL_347;
      case 8:
        uint64_t v53 = xmlParseLookupSequence(a1, 93, 93, 62);
        if ((v53 & 0x80000000) != 0)
        {
          if (v16 < 0x12E) {
            return;
          }
          BOOL v55 = *(void **)(a1 + 56);
          uint64_t v134 = v55[4];
          uint64_t v135 = xmlCheckCdataPush(v134, 300, 0);
          int v136 = v135;
          if ((v135 & 0x80000000) == 0)
          {
            uint64_t v137 = *(void *)a1;
            if (*(void *)a1)
            {
              if (!*(_DWORD *)(a1 + 332))
              {
                v138 = *(void (**)(void, uint64_t, uint64_t))(v137 + 200);
              }
            }

            if (*(_DWORD *)(a1 + 272) != -1)
            {
              __int128 v139 = *(xmlParserInput **)(a1 + 56);
              if (v136)
              {
                __int128 v140 = v139->cur;
                int col = v139->col;
                do
                {
                  if (*v140 == 10)
                  {
                    ++v139->line;
                    int col = 1;
                  }

                  else
                  {
                    ++col;
                  }

                  v139->int col = col;
                  v139->xmlNodePtr cur = ++v140;
                  --v136;
                }

                while (v136);
              }

              else
              {
                __int128 v140 = v139->cur;
              }

              if (!*v140) {
                xmlParserInputGrow(v139, 250);
              }
              *(void *)(a1 + 320) = 0LL;
            }

            return;
          }

          __int128 v142 = (unsigned __int8 *)(v134 + -(int)v135);
        }

        else
        {
          uint64_t v54 = v53;
          BOOL v55 = *(void **)(a1 + 56);
          uint64_t v56 = v55[4];
          int v57 = xmlCheckCdataPush(v56, v53, 1);
          if ((v57 & 0x80000000) == 0 && v57 == (_DWORD)v54)
          {
            uint64_t v58 = v6;
            uint64_t v59 = *(void *)a1;
            if ((_DWORD)v54 || !v59)
            {
              if ((_DWORD)v54 && v59 && !*(_DWORD *)(a1 + 332))
              {
                int v73 = *(void (**)(void, uint64_t, uint64_t))(v59 + 200);
                if (v73)
                {
                  v73(*(void *)(a1 + 8), v56, v54);
                }

                else
                {
                  v127 = *(void (**)(void, uint64_t, uint64_t))(v59 + 136);
                  if (v127) {
                    v127(*(void *)(a1 + 8), v56, v54);
                  }
                }
              }
            }

            else
            {
              int v60 = *(void (**)(void, char *, void))(v59 + 200);
              if (v60
                && !*(_DWORD *)(a1 + 332)
                && v56 - v55[3] >= 9
                && !strncmp((const char *)(v56 - 9), "<![CDATA[", 9uLL))
              {
                v60(*(void *)(a1 + 8), &byte_181A3ACBA, 0LL);
              }
            }

            xmlCharEncoding v6 = v58;
            if (*(_DWORD *)(a1 + 272) == -1) {
              return;
            }
            xmlGenericErrorFunc v128 = *(xmlParserInput **)(a1 + 56);
            int v129 = v128->col;
            uint64_t v130 = (uint64_t)(v128->cur + 1);
            int v131 = ((v54 + 2) & ~(((int)v54 + 2) >> 31)) + 1;
            do
            {
              if (*(_BYTE *)(v130 - 1) == 10)
              {
                ++v128->line;
                int v129 = 1;
              }

              else
              {
                ++v129;
              }

              v128->int col = v129;
              v128->xmlNodePtr cur = (const xmlChar *)v130++;
              --v131;
            }

            while (v131);
            if (!*(_BYTE *)(v130 - 1)) {
              xmlParserInputGrow(v128, 250);
            }
            *(void *)(a1 + 320) = 0LL;
LABEL_339:
            int v5 = 7;
            goto LABEL_340;
          }

          __int128 v142 = (unsigned __int8 *)(v56 + -v57);
        }

        v55[4] = v142;
        if ((uint64_t)(v55[5] - (void)v142) > 3)
        {
          __int128 v169 = 0u;
          memset(v170, 0, sizeof(v170));
          __int128 v167 = 0u;
          __int128 v168 = 0u;
          __int128 v165 = 0u;
          __int128 v166 = 0u;
          __int128 v163 = 0u;
          __int128 v164 = 0u;
          *(_OWORD *)in = 0u;
          snprintf((char *)in, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v142, v142[1], v142[2], v142[3]);
          __int128 v143 = "Input is not proper UTF-8, indicate encoding !\n%s";
          __int128 v145 = in;
          __int128 v144 = (_DWORD *)a1;
        }

        else
        {
          __int128 v143 = "Input is not proper UTF-8, indicate encoding !\n";
          __int128 v144 = (_DWORD *)a1;
          __int128 v145 = 0LL;
        }

        __xmlErrEncoding(v144, 9, (uint64_t)v143, (uint64_t)v145, 0LL);
        return;
      case 9:
        if (v16 < 2) {
          return;
        }
        if (a2) {
          goto LABEL_221;
        }
        if (*(_DWORD *)(a1 + 452))
        {
        }

        else if ((xmlParseLookupSequence(a1, 62, 0, 0) & 0x80000000) != 0)
        {
          return;
        }

LABEL_221:
        if (*(_DWORD *)(a1 + 504))
        {
          xmlParseEndTag2(a1, (void *)(*(void *)(a1 + 536) + 24LL * *(int *)(a1 + 296) - 24));
          int v97 = *(_DWORD *)(a1 + 296);
          unsigned int v98 = v97 - 1;
          if (v97 >= 1)
          {
            *(_DWORD *)(a1 + 296) = v98;
            uint64_t v99 = *(void *)(a1 + 304);
            if (v97 == 1) {
              uint64_t v100 = 0LL;
            }
            else {
              uint64_t v100 = *(void *)(v99 + 8LL * (v97 - 2));
            }
            *(void *)(a1 + 288) = v100;
            *(void *)(v99 + 8LL * v98) = 0LL;
          }
        }

        else
        {
          xmlParseEndTag1((xmlParserCtxt *)a1);
        }

        if (*(_DWORD *)(a1 + 272) == -1) {
          return;
        }
        if (*(_DWORD *)(a1 + 296)) {
          goto LABEL_339;
        }
        int v5 = 14;
        goto LABEL_340;
      case 10:
        xmlGenericErrorFunc v61 = *__xmlGenericError();
        int v62 = *__xmlGenericErrorContext();
        v61(v62, "PP: internal error, state == ENTITY_DECL\n");
        goto LABEL_123;
      case 11:
        xmlGenericErrorFunc v27 = *__xmlGenericError();
        int v28 = *__xmlGenericErrorContext();
        unsigned int v29 = "PP: internal error, state == ENTITY_VALUE\n";
LABEL_117:
        v27(v28, v29);
        goto LABEL_339;
      case 12:
        xmlGenericErrorFunc v63 = *__xmlGenericError();
        int v64 = *__xmlGenericErrorContext();
        v63(v64, "PP: internal error, state == ATTRIBUTE_VALUE\n");
        goto LABEL_125;
      case 13:
        xmlGenericErrorFunc v65 = *__xmlGenericError();
        uint64_t v66 = *__xmlGenericErrorContext();
        v65(v66, "PP: internal error, state == SYSTEM_LITERAL\n");
        goto LABEL_125;
      case 14:
        xmlSkipBlankChars((xmlParserCtxtPtr)a1);
        uint64_t v67 = *(void *)(a1 + 56);
        if (*(void *)v67)
        {
          size_t v68 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v67 + 32LL));
          uint64_t v67 = *(void *)(a1 + 56);
        }

        else
        {
          size_t v68 = *(int *)(v67 + 48);
        }

        int v84 = *(unsigned __int8 **)(v67 + 32);
        unint64_t v85 = v68 - (void)v84 + *(void *)(v67 + 24);
        if (v85 < 2) {
          return;
        }
        int v86 = *v84;
        int v87 = v84[1];
        if (v86 == 60 && v87 == 63)
        {
          if (!a2 && (xmlParseLookupSequence(a1, 63, 62, 0) & 0x80000000) != 0) {
            goto LABEL_387;
          }
          xmlParsePI((xmlParserCtxtPtr)a1);
LABEL_187:
          if (*(_DWORD *)(a1 + 272) == -1) {
            return;
          }
          int v5 = 14;
LABEL_189:
          *(_DWORD *)(a1 + 272) = v5;
          *(_DWORD *)(a1 + 452) = 1;
          goto LABEL_341;
        }

        if (v86 == 60 && v87 == 33)
        {
          if (v84[2] == 45 && v84[3] == 45)
          {
            if (!a2 && (xmlParseLookupSequence(a1, 45, 45, 62) & 0x80000000) != 0) {
              goto LABEL_398;
            }
            xmlParseComment((xmlParserCtxtPtr)a1);
            goto LABEL_187;
          }

          if (v85 < 4) {
            return;
          }
        }

        __int128 v146 = (_DWORD *)a1;
        int v147 = 5;
LABEL_392:
        xmlFatalErr(v146, v147, 0LL);
LABEL_393:
        xmlHaltParser((xmlParserCtxtPtr)a1);
        if (*(void *)a1)
        {
          __int128 v156 = *(void (**)(void))(*(void *)a1 + 104LL);
          if (v156) {
            v156(*(void *)(a1 + 8));
          }
        }

        return;
      case 15:
        xmlGenericErrorFunc v69 = *__xmlGenericError();
        xmlEntityPtr v70 = *__xmlGenericErrorContext();
        v69(v70, "PP: internal error, state == IGNORE");
        goto LABEL_123;
      case 16:
        xmlGenericErrorFunc v71 = *__xmlGenericError();
        int v72 = *__xmlGenericErrorContext();
        v71(v72, "PP: internal error, state == PUBLIC_LITERAL\n");
        goto LABEL_125;
      default:
        goto LABEL_341;
    }
  }

      int v121 = *(void *)(a1 + 24);
      int v122 = v105;
      goto LABEL_222;
    case 3:
      unsigned int v29 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[1]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      unsigned int v30 = v29;
      uint64_t v31 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[2]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v2 = (v31 + v30);
      if (a2[3]) {
        size_t v32 = xmlXPathEqualValues((xmlXPathParserContextPtr)a1);
      }
      else {
        size_t v32 = xmlXPathNotEqualValues((xmlXPathParserContextPtr)a1);
      }
      goto LABEL_145;
    case 4:
      size_t v33 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[1]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      unsigned int v34 = v33;
      size_t v35 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[2]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v2 = (v35 + v34);
      size_t v32 = xmlXPathCompareValues((xmlXPathParserContextPtr)a1, a2[3], a2[4]);
LABEL_145:
      xmlGenericErrorFunc v71 = xmlXPathCacheNewBoolean(*(void *)(a1 + 24), v32);
      goto LABEL_146;
    case 5:
      unsigned __int8 v36 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[1]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v2 = v36;
      uint64_t v37 = a2[2];
      if (v37 == -1) {
        goto LABEL_48;
      }
      int v38 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * v37);
      if (!*(_DWORD *)(a1 + 16))
      {
        uint64_t v2 = (v38 + v2);
LABEL_48:
        switch(a2[3])
        {
          case 0u:
            xmlXPathSubValues((xmlXPathParserContextPtr)a1);
            goto LABEL_287;
          case 1u:
            xmlXPathAddValues((xmlXPathParserContextPtr)a1);
            goto LABEL_287;
          case 2u:
            xmlXPathValueFlipSign((xmlXPathParserContextPtr)a1);
            goto LABEL_287;
          case 3u:
            int v111 = *(_DWORD **)(a1 + 32);
            if (!v111) {
              goto LABEL_289;
            }
            if (*v111 != 3)
            {
              xmlXPathNumberFunction((xmlXPathParserContextPtr)a1, 1);
              int v112 = *(_DWORD **)(a1 + 32);
              if (!v112 || *v112 != 3) {
                goto LABEL_289;
              }
            }

            goto LABEL_287;
          default:
            goto LABEL_287;
        }
      }

      return 0LL;
    case 6:
      uint64_t v39 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[1]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      unint64_t v40 = v39;
      size_t v41 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[2]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v2 = (v41 + v40);
      size_t v42 = a2[3];
      switch(v42)
      {
        case 2u:
          xmlXPathModValues((xmlXPathParserContextPtr)a1);
          break;
        case 1u:
          xmlXPathDivValues((xmlXPathParserContextPtr)a1);
          break;
        case 0u:
          xmlXPathMultValues((xmlXPathParserContextPtr)a1);
          break;
      }

      goto LABEL_287;
    case 7:
      size_t v43 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[1]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v44 = v43;
      uint64_t v45 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * (int)a2[2]);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      size_t v46 = *(_DWORD *)(a1 + 40);
      int v47 = v46 - 1;
      if (v46 < 1)
      {
        int v50 = 0LL;
        int v49 = 0LL;
        goto LABEL_181;
      }

      *(_DWORD *)(a1 + 40) = v47;
      unint64_t v48 = *(void *)(a1 + 48);
      if (v46 == 1)
      {
        int v49 = 0LL;
        *(void *)(a1 + 32) = 0LL;
        int v50 = *(xmlXPathObject **)(v48 + 8LL * v47);
        *(void *)(v48 + 8LL * v47) = 0LL;
LABEL_181:
        xmlXPathReleaseObject(*(void *)(a1 + 24), v49);
        xmlXPathReleaseObject(*(void *)(a1 + 24), v50);
        goto LABEL_289;
      }

      unsigned int v113 = 0LL;
      uint64_t v114 = (v46 - 2);
      *(void *)(a1 + 32) = *(void *)(v48 + 8LL * v114);
      int v50 = *(xmlXPathObject **)(v48 + 8LL * v47);
      *(void *)(v48 + 8LL * v47) = 0LL;
      *(_DWORD *)(a1 + 40) = v114;
      uint64_t v115 = *(void *)(a1 + 48);
      if (v46 != 2) {
        unsigned int v113 = *(void *)(v115 + 8LL * (v46 - 3));
      }
      *(void *)(a1 + 32) = v113;
      int v49 = *(xmlXPathObject **)(v115 + 8 * v114);
      *(void *)(v115 + 8 * v114) = 0LL;
      if (!v49) {
        goto LABEL_181;
      }
      int v116 = v49->type != XPATH_NODESET || v50 == 0LL;
      if (v116 || v50->type != XPATH_NODESET) {
        goto LABEL_181;
      }
      uint64_t v2 = (v45 + v44);
      if (linkedOnOrAfterFall2022OSVersions()
        && *(void *)(*(void *)(a1 + 24) + 352LL)
        && ((p_nodeNr = &v49->nodesetval->nodeNr) != 0LL
         && (xmlXPathCheckOpLimit((xmlXPathParserContext *)a1, *p_nodeNr) & 0x80000000) != 0
         || (unsigned int v118 = &v50->nodesetval->nodeNr) != 0LL
         && (xmlXPathCheckOpLimit((xmlXPathParserContext *)a1, *v118) & 0x80000000) != 0))
      {
        xmlXPathReleaseObject(*(void *)(a1 + 24), v49);
      }

      else
      {
        xmlNodeSetPtr nodesetval = v49->nodesetval;
        int v120 = v50->nodesetval;
        if (!nodesetval || v120 && v120->nodeNr) {
          v49->xmlNodeSetPtr nodesetval = xmlXPathNodeSetMerge(nodesetval, v120);
        }
        valuePush((xmlXPathParserContextPtr)a1, v49);
      }

      int v121 = *(void *)(a1 + 24);
      int v122 = v50;
LABEL_222:
      xmlXPathReleaseObject(v121, v122);
      goto LABEL_287;
    case 8:
      xmlXPathRoot((xmlXPathParserContextPtr)a1);
      goto LABEL_68;
    case 9:
      int v51 = a2[1];
      if (v51 == -1) {
        uint64_t v2 = 0LL;
      }
      else {
        uint64_t v2 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * v51);
      }
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      xmlGenericErrorFunc v69 = a2[2];
      if (v69 == -1) {
        goto LABEL_94;
      }
      xmlEntityPtr v70 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * v69);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v2 = (v70 + v2);
LABEL_94:
      xmlGenericErrorFunc v71 = xmlXPathCacheNewNodeSet(*(void *)(a1 + 24), *(xmlNodePtr *)(*(void *)(a1 + 24) + 8LL));
      goto LABEL_146;
    case 10:
      uint64_t v52 = a2[1];
      if (v52 == -1) {
        goto LABEL_68;
      }
      uint64_t v53 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * v52);
      if (*(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
      uint64_t v2 = xmlXPathNodeCollectAndTest((xmlXPathParserContextPtr)a1, (uint64_t)a2, 0LL, 0LL, 0) + v53;
      goto LABEL_287;
    case 11:
      uint64_t v54 = xmlXPathCacheObjectCopy(*(void *)(a1 + 24), *((xmlXPathObjectPtr *)a2 + 3));
      valuePush((xmlXPathParserContextPtr)a1, v54);
LABEL_68:
      uint64_t v2 = 0LL;
      goto LABEL_287;
    case 12:
      BOOL v55 = a2[1];
      if (v55 == -1) {
        uint64_t v2 = 0LL;
      }
      else {
        uint64_t v2 = xmlXPathCompOpEval(a1, *(void *)(v10 + 8) + 56LL * v55);
      }
      int v72 = (const xmlChar *)*((void *)a2 + 4);
      int v73 = *(xmlXPathContext **)(a1 + 24);
      if (v72)
      {
        xmlCharEncoding v74 = xmlXPathNsLookup(v73, v72);
        if (!v74)
        {
          uint64_t v91 = *__xmlGenericError();
          uint64_t v92 = *__xmlGenericErrorContext();
          BOOL v93 = "xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n";
LABEL_133:
          v91(v92, v93);
          int v78 = 19;
LABEL_104:
          *(_DWORD *)(a1 + 16) = v78;
          goto LABEL_287;
        }

        xmlGenericErrorFunc v71 = xmlXPathVariableLookupNS(*(xmlXPathContextPtr *)(a1 + 24), *((const xmlChar **)a2 + 3), v74);
        if (!v71) {
          goto LABEL_126;
        }
      }

      else
      {
        xmlGenericErrorFunc v71 = xmlXPathVariableLookup(v73, *((const xmlChar **)a2 + 3));
        if (!v71)
        {
LABEL_126:
          xmlParserInputPtr v8 = (xmlXPathParserContext *)a1;
          int v9 = 5;
          goto LABEL_10;
        }
      }

xmlParserCtxtPtr xmlCreatePushParserCtxt( xmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename)
{
  xmlCharEncoding v10 = XML_CHAR_ENCODING_NONE;
  if (chunk && size >= 4) {
    xmlCharEncoding v10 = xmlDetectCharEncoding((const unsigned __int8 *)chunk, size);
  }
  xmlParserInputBufferPtr v11 = xmlAllocParserInputBuffer(v10);
  if (!v11) {
    return 0LL;
  }
  xmlParserInputBufferPtr v12 = v11;
  xmlParserCtxtPtr v13 = xmlNewParserCtxt();
  xmlParserInputPtr v14 = v13;
  if (v13)
  {
    v13->dictNames = 1;
    if (sax)
    {
      int v15 = (xmlSAXHandlerV1 *)v13->sax;
      if (v15 != __xmlDefaultSAXHandler()) {
        xmlFree(v14->sax);
      }
      unint64_t v16 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
      v14->sax = v16;
      if (!v16)
      {
        htmlErrMemory(v14, 0LL);
        xmlFreeParserInputBuffer(v12);
        xmlFreeParserCtxt(v14);
        return 0LL;
      }

      *(_OWORD *)&v16->_private = 0u;
      *(_OWORD *)&v16->endElementNs = 0u;
      *(_OWORD *)&v16->getParameterEntitySAXFunc getParameterEntity = 0u;
      *(_OWORD *)&v16->externalSubsetSAXFunc externalSubset = 0u;
      *(_OWORD *)&v16->commentSAXFunc comment = 0u;
      *(_OWORD *)&v16->error = 0u;
      *(_OWORD *)&v16->referenceSAXFunc reference = 0u;
      *(_OWORD *)&v16->ignorableWhitespace = 0u;
      *(_OWORD *)&v16->startDocumentSAXFunc startDocument = 0u;
      *(_OWORD *)&v16->startElementSAXFunc startElement = 0u;
      *(_OWORD *)&v16->attributeDeclSAXFunc attributeDecl = 0u;
      *(_OWORD *)&v16->unparsedEntityDeclSAXFunc unparsedEntityDecl = 0u;
      *(_OWORD *)&v16->resolvexmlEntityPtr Entity = 0u;
      *(_OWORD *)&v16->entityDeclSAXFunc entityDecl = 0u;
      *(_OWORD *)&v16->internalSubsetSAXFunc internalSubset = 0u;
      *(_OWORD *)&v16->hasInternalSubset = 0u;
      if (sax->initialized == -554844497) {
        size_t v17 = 256LL;
      }
      else {
        size_t v17 = 224LL;
      }
      memcpy(v14->sax, sax, v17);
      if (user_data) {
        v14->userData = user_data;
      }
    }

    if (filename)
    {
      v14->directory = xmlParserGetDirectory(filename);
      xmlParserInputPtr v18 = xmlNewInputStream(v14);
      if (!v18) {
        goto LABEL_27;
      }
      uint64_t v19 = v18;
      int v20 = xmlCanonicPath((const xmlChar *)filename);
      v19->filename = (const char *)v20;
      if (!v20) {
        goto LABEL_27;
      }
    }

    else
    {
      v14->directory = 0LL;
      xmlParserInputPtr v21 = xmlNewInputStream(v14);
      if (!v21)
      {
LABEL_27:
        xmlFreeParserCtxt(v14);
        xmlFreeParserInputBuffer(v12);
        return 0LL;
      }

      uint64_t v19 = v21;
      v21->filename = 0LL;
    }

    v19->uint64_t buf = v12;
    xmlBufResetInput((uint64_t *)v12->buffer, v19);
    inputPush(v14, v19);
    if (chunk && size)
    {
      uint64_t input = (uint64_t)v14->input;
      if (input && *(void *)input)
      {
        unint64_t InputBase = xmlBufGetInputBase(*(void *)(*(void *)input + 32LL), input);
        xmlParserInputPtr v24 = v14->input;
        uint64_t v25 = v24->cur - v24->base;
        xmlParserInputBufferPush(v24->buf, size, chunk);
        xmlBufSetInputBaseCur((uint64_t *)v14->input->buf->buffer, &v14->input->buf, InputBase, v25);
      }
    }

    else
    {
      v14->charset = 0;
    }

    if (v10) {
      xmlSwitchEncoding(v14, v10);
    }
  }

  else
  {
    htmlErrMemory(0LL, (uint64_t)"creating parser: out of memory\n");
    xmlFreeParserInputBuffer(v12);
  }

  return v14;
}

void xmlStopParser(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    xmlHaltParser(ctxt);
    ctxt->int errNo = 111;
  }

xmlParserCtxtPtr xmlCreateIOParserCtxt( xmlSAXHandlerPtr sax, void *user_data, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, xmlCharEncoding enc)
{
  if (!ioread) {
    return 0LL;
  }
  xmlParserInputPtr v8 = (xmlParserCtxt *)ioclose;
  xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
  if (!IO)
  {
    if (!v8) {
      return v8;
    }
    ((void (*)(void *))v8)(ioctx);
    return 0LL;
  }

  xmlParserInputBufferPtr v12 = IO;
  xmlParserCtxtPtr v13 = xmlNewParserCtxt();
  xmlParserInputPtr v8 = v13;
  if (!v13)
  {
    xmlFreeParserInputBuffer(v12);
    return v8;
  }

  if (sax)
  {
    xmlParserInputPtr v14 = (xmlSAXHandlerV1 *)v13->sax;
    if (v14 != __xmlDefaultSAXHandler()) {
      xmlFree(v8->sax);
    }
    int v15 = (_xmlSAXHandler *)xmlMalloc(0x100uLL);
    v8->sax = v15;
    if (!v15)
    {
      xmlFreeParserInputBuffer(v12);
      htmlErrMemory(v8, 0LL);
      goto LABEL_19;
    }

    *(_OWORD *)&v15->_private = 0u;
    *(_OWORD *)&v15->endElementNs = 0u;
    *(_OWORD *)&v15->getParameterEntitySAXFunc getParameterEntity = 0u;
    *(_OWORD *)&v15->externalSubsetSAXFunc externalSubset = 0u;
    *(_OWORD *)&v15->commentSAXFunc comment = 0u;
    *(_OWORD *)&v15->error = 0u;
    *(_OWORD *)&v15->referenceSAXFunc reference = 0u;
    *(_OWORD *)&v15->ignorableWhitespace = 0u;
    *(_OWORD *)&v15->startDocumentSAXFunc startDocument = 0u;
    *(_OWORD *)&v15->startElementSAXFunc startElement = 0u;
    *(_OWORD *)&v15->attributeDeclSAXFunc attributeDecl = 0u;
    *(_OWORD *)&v15->unparsedEntityDeclSAXFunc unparsedEntityDecl = 0u;
    *(_OWORD *)&v15->resolvexmlEntityPtr Entity = 0u;
    *(_OWORD *)&v15->entityDeclSAXFunc entityDecl = 0u;
    *(_OWORD *)&v15->internalSubsetSAXFunc internalSubset = 0u;
    *(_OWORD *)&v15->hasInternalSubset = 0u;
    if (sax->initialized == -554844497) {
      size_t v16 = 256LL;
    }
    else {
      size_t v16 = 224LL;
    }
    memcpy(v8->sax, sax, v16);
    if (user_data) {
      v8->userData = user_data;
    }
  }

  size_t v17 = xmlNewIOInputStream(v8, v12, enc);
  if (!v17)
  {
LABEL_19:
    xmlFreeParserCtxt(v8);
    return 0LL;
  }

  inputPush(v8, v17);
  return v8;
}

xmlDtdPtr xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input, xmlCharEncoding enc)
{
  if (!input) {
    return 0LL;
  }
  xmlParserCtxtPtr v6 = xmlNewParserCtxt();
  if (!v6)
  {
    xmlFreeParserInputBuffer(input);
    return 0LL;
  }

  xmlParserCtxtPtr v7 = v6;
  v6->options |= 4u;
  if (sax)
  {
    xmlParserInputPtr v8 = v6->sax;
    if (v7->sax) {
      xmlFree(v8);
    }
    v7->sax = sax;
    v7->userData = v7;
  }

  xmlDetectSAX2((const xmlChar *)v7);
  int v9 = xmlNewIOInputStream(v7, input, XML_CHAR_ENCODING_NONE);
  if (!v9)
  {
    if (sax) {
      v7->sax = 0LL;
    }
    xmlFreeParserInputBuffer(input);
    goto LABEL_28;
  }

  xmlCharEncoding v10 = v9;
  if (xmlPushInput(v7, v9) < 0)
  {
    if (sax) {
      v7->sax = 0LL;
    }
LABEL_28:
    xmlFreeParserCtxt(v7);
    return 0LL;
  }

  if (enc) {
    xmlSwitchEncoding(v7, enc);
  }
  v10->filename = 0LL;
  *(void *)&v10->int line = 0x100000001LL;
  xmlNodePtr cur = v7->input->cur;
  v10->unint64_t base = cur;
  v10->xmlNodePtr cur = cur;
  v10->xmlParserInputDeallocate free = 0LL;
  v7->inSubset = 2;
  xmlDocPtr v12 = xmlNewDoc((const xmlChar *)"1.0");
  v7->xmlDocPtr myDoc = v12;
  if (!v12)
  {
    htmlErrMemory(v7, (uint64_t)"New Doc failed");
    return 0LL;
  }

  *(_DWORD *)in = 0;
  v12->int properties = 64;
  v7->myDoc->extSubset = xmlNewDtd(v12, (const xmlChar *)"none", (const xmlChar *)"none", (const xmlChar *)"none");
  if (enc == XML_CHAR_ENCODING_NONE)
  {
    xmlParserCtxtPtr v13 = v7->input->cur;
    if (v7->input->end - v13 >= 4)
    {
      *(_DWORD *)in = *(_DWORD *)v13;
      xmlCharEncoding v14 = xmlDetectCharEncoding(in, 4);
      if (v14) {
        xmlSwitchEncoding(v7, v14);
      }
    }
  }

  xmlParseExternalSubset(v7, (const xmlChar *)"none", (const xmlChar *)"none");
  xmlDocPtr myDoc = v7->myDoc;
  if (myDoc)
  {
    if (v7->wellFormed)
    {
      extSubset = myDoc->extSubset;
      myDoc->extSubset = 0LL;
      if (extSubset)
      {
        extSubset->xmlDocPtr doc = 0LL;
        for (uint64_t i = extSubset->children; i; uint64_t i = i->next)
          i->xmlDocPtr doc = 0LL;
      }
    }

    else
    {
      extSubset = 0LL;
    }

    xmlFreeDoc(myDoc);
    v7->xmlDocPtr myDoc = 0LL;
  }

  else
  {
    extSubset = 0LL;
  }

  if (sax) {
    v7->sax = 0LL;
  }
  xmlFreeParserCtxt(v7);
  return extSubset;
}

xmlDtdPtr xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID, const xmlChar *SystemID)
{
  xmlParserCtxtPtr v6 = xmlNewParserCtxt();
  if (!v6) {
    return 0LL;
  }
  xmlParserCtxtPtr v7 = v6;
  v6->options |= 4u;
  if (sax)
  {
    xmlParserInputPtr v8 = v6->sax;
    if (v7->sax) {
      xmlFree(v8);
    }
    v7->sax = sax;
    v7->userData = v7;
  }

  int v9 = xmlCanonicPath(SystemID);
  xmlCharEncoding v10 = v9;
  if (SystemID && !v9)
  {
LABEL_9:
    xmlFreeParserCtxt(v7);
    return 0LL;
  }

  if (!v7->sax
    || (resolvexmlEntityPtr Entity = (uint64_t (*)(void *, const xmlChar *, xmlChar *))v7->sax->resolveEntity) == 0LL
    || (xmlDocPtr v12 = (xmlParserInput *)resolveEntity(v7->userData, ExternalID, v9)) == 0LL
    || (xmlParserCtxtPtr v13 = v12, xmlPushInput(v7, v12) < 0))
  {
    if (sax) {
      v7->sax = 0LL;
    }
    xmlFreeParserCtxt(v7);
    if (v10) {
      xmlFree(v10);
    }
    return 0LL;
  }

  xmlParserInputPtr input = v7->input;
  xmlNodePtr cur = input->cur;
  if (input->end - cur >= 4)
  {
    xmlCharEncoding v16 = xmlDetectCharEncoding(cur, 4);
    xmlSwitchEncoding(v7, v16);
  }

  if (v13->filename) {
    xmlFree(v10);
  }
  else {
    v13->filename = (const char *)v10;
  }
  *(void *)&v13->int line = 0x100000001LL;
  uint64_t v19 = v7->input->cur;
  v13->unint64_t base = v19;
  v13->xmlNodePtr cur = v19;
  v13->xmlParserInputDeallocate free = 0LL;
  v7->inSubset = 2;
  xmlDocPtr v20 = xmlNewDoc((const xmlChar *)"1.0");
  v7->xmlDocPtr myDoc = v20;
  if (!v20)
  {
    htmlErrMemory(v7, (uint64_t)"New Doc failed");
    if (sax) {
      v7->sax = 0LL;
    }
    goto LABEL_9;
  }

  v20->int properties = 64;
  v7->myDoc->extSubset = xmlNewDtd(v20, (const xmlChar *)"none", ExternalID, SystemID);
  xmlParseExternalSubset(v7, ExternalID, SystemID);
  xmlDocPtr myDoc = v7->myDoc;
  if (myDoc)
  {
    if (v7->wellFormed)
    {
      extSubset = myDoc->extSubset;
      myDoc->extSubset = 0LL;
      if (extSubset)
      {
        extSubset->xmlDocPtr doc = 0LL;
        for (uint64_t i = extSubset->children; i; uint64_t i = i->next)
          i->xmlDocPtr doc = 0LL;
      }
    }

    else
    {
      extSubset = 0LL;
    }

    xmlFreeDoc(myDoc);
    v7->xmlDocPtr myDoc = 0LL;
  }

  else
  {
    extSubset = 0LL;
  }

  if (sax) {
    v7->sax = 0LL;
  }
  xmlFreeParserCtxt(v7);
  return extSubset;
}

xmlDtdPtr xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID)
{
  return xmlSAXParseDTD(0LL, ExternalID, SystemID);
}

int xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst)
{
  if (!ctx) {
    return -1;
  }
  if (ctx->userData == ctx) {
    userData = 0LL;
  }
  else {
    userData = ctx->userData;
  }
  return xmlParseExternalEntityPrivate( (uint64_t)ctx->myDoc,  (uint64_t)ctx,  ctx->sax,  userData,  ctx->depth + 1,  URL,  (const char *)ID,  lst);
}

int xmlParseExternalEntity( xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst)
{
  return xmlParseExternalEntityPrivate((uint64_t)doc, 0LL, sax, user_data, depth, URL, (const char *)ID, lst);
}

int xmlParseBalancedChunkMemory( xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst)
{
  return xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth, string, lst, 0);
}

int xmlParseBalancedChunkMemoryRecover( xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst, int recover)
{
  if (depth > 40) {
    return 89;
  }
  if (lst) {
    *xmlNodePtr lst = 0LL;
  }
  if (!string) {
    return -1;
  }
  int v15 = xmlStrlen(string);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)string, v15);
  if (!MemoryParserCtxt) {
    return -1;
  }
  xmlParserCtxtPtr v17 = MemoryParserCtxt;
  MemoryParserCtxt->userData = MemoryParserCtxt;
  if (sax)
  {
    xmlParserInputPtr v18 = MemoryParserCtxt->sax;
    MemoryParserCtxt->sax = sax;
    if (user_data) {
      MemoryParserCtxt->userData = user_data;
    }
  }

  else
  {
    xmlParserInputPtr v18 = 0LL;
  }

  xmlDocPtr v19 = xmlNewDoc((const xmlChar *)"1.0");
  if (!v19)
  {
    xmlFreeParserCtxt(v17);
    return -1;
  }

  xmlDocPtr v20 = v19;
  v19->int properties = 64;
  if (doc && doc->dict)
  {
    xmlDictFree(v17->dict);
    dict = doc->dict;
    v17->dict = dict;
    xmlDictReference(dict);
    v17->str_xml = xmlDictLookup(v17->dict, (const xmlChar *)"xml", 3);
    v17->str_xmlns = xmlDictLookup(v17->dict, (const xmlChar *)"xmlns", 5);
    v17->str_xml_ns = xmlDictLookup(v17->dict, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", 36);
    v17->dictNames = 1;
  }

  else
  {
    v17->recovery = 0;
    v17->replaceEntities = 0;
    v17->pedantic = 0;
    v17->keepBlanks = 1;
    v17->validate = 0;
    v17->options |= 0x1000u;
    v17->dictNames = 0;
    *(void *)&v17->loadsubset = 0x100000000LL;
    if (!doc) {
      goto LABEL_18;
    }
  }

  *(_OWORD *)&v20->intSubset = *(_OWORD *)&doc->intSubset;
LABEL_18:
  uint64_t v22 = xmlNewDocNode(v20, 0LL, (const xmlChar *)"pseudoroot", 0LL);
  if (!v22)
  {
    if (sax) {
      v17->sax = v18;
    }
    xmlFreeParserCtxt(v17);
    v20->intSubset = 0LL;
    v20->extSubset = 0LL;
    xmlFreeDoc(v20);
    return -1;
  }

  uint64_t v23 = v22;
  xmlAddChild((xmlNodePtr)v20, v22);
  nodePush(v17, v23);
  v17->xmlDocPtr myDoc = v20;
  if (doc)
  {
    v20->children->xmlDocPtr doc = doc;
    xmlSearchNsByHref(doc, (xmlNodePtr)doc, (const xmlChar *)"http://www.w3.org/XML/1998/namespace");
    v20->oldNs = doc->oldNs;
  }

  v17->xmlParserInputState instate = XML_PARSER_CONTENT;
  v17->input_int id = 2;
  v17->int depth = depth;
  v17->validate = 0;
  v17->loadsubset = 0;
  xmlDetectSAX2((const xmlChar *)v17);
  if (doc)
  {
    xmlNodePtr children = doc->children;
    doc->xmlNodePtr children = 0LL;
    xmlParseContent(v17);
    doc->xmlNodePtr children = children;
  }

  else
  {
    xmlParseContent(v17);
  }

  xmlNodePtr cur = v17->input->cur;
  if (*cur)
  {
    if (*cur == 60 && cur[1] == 47) {
      int v27 = 85;
    }
    else {
      int v27 = 86;
    }
    xmlFatalErr(v17, v27, 0LL);
  }

  if (v17->node != v20->children) {
    xmlFatalErr(v17, 85, 0LL);
  }
  if (v17->wellFormed)
  {
    int errNo = 0;
    if (!lst) {
      goto LABEL_49;
    }
LABEL_44:
    if (recover == 1 || !errNo)
    {
      int v28 = v20->children->children;
      for (*lst = v28; v28; int v28 = v28->next)
      {
        xmlSetTreeDoc(v28, doc);
        v28->parent = 0LL;
      }

      v20->children->xmlNodePtr children = 0LL;
    }

    goto LABEL_49;
  }

  if (v17->errNo <= 1u) {
    int errNo = 1;
  }
  else {
    int errNo = v17->errNo;
  }
  if (lst) {
    goto LABEL_44;
  }
LABEL_49:
  if (sax) {
    v17->sax = v18;
  }
  xmlFreeParserCtxt(v17);
  v20->intSubset = 0LL;
  v20->extSubset = 0LL;
  v20->oldNs = 0LL;
  xmlFreeDoc(v20);
  return errNo;
}

xmlParserErrors xmlParseInNodeContext( xmlNodePtr node, const char *data, int datalen, int options, xmlNodePtr *lst)
{
  xmlParserErrors errNo = XML_ERR_INTERNAL_ERROR;
  if (datalen < 0) {
    return errNo;
  }
  if (!data) {
    return errNo;
  }
  xmlNodePtr v6 = node;
  if (!node) {
    return errNo;
  }
  if (!lst) {
    return errNo;
  }
  xmlElementType type = node->type;
  if (type > XML_HTML_DOCUMENT_NODE || ((1 << type) & 0x23BE) == 0) {
    return errNo;
  }
  uint64_t v9 = *(void *)&options;
  while (1)
  {
    xmlElementType v10 = v6->type;
    if (v10 == XML_ELEMENT_NODE) {
      break;
    }
    if (v10 == XML_DOCUMENT_NODE || v10 == XML_HTML_DOCUMENT_NODE)
    {
      xmlDocPtr doc = (xmlDoc *)v6;
      goto LABEL_17;
    }

    xmlNodePtr v6 = v6->parent;
    if (!v6) {
      return 1;
    }
  }

  xmlDocPtr doc = v6->doc;
  if (!doc) {
    return 1;
  }
LABEL_17:
  xmlElementType v13 = doc->type;
  if (v13 != XML_HTML_DOCUMENT_NODE)
  {
    if (v13 == XML_DOCUMENT_NODE)
    {
      xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt(data, datalen);
      if (!MemoryParserCtxt) {
        return 2;
      }
      goto LABEL_23;
    }

    return 1;
  }

  xmlParserCtxtPtr MemoryParserCtxt = htmlCreateMemoryParserCtxt(data, datalen);
  uint64_t v9 = v9 | 0x2000;
  if (!MemoryParserCtxt) {
    return 2;
  }
LABEL_23:
  dict = doc->dict;
  if (dict)
  {
    xmlCharEncoding v16 = MemoryParserCtxt->dict;
    if (v16)
    {
      xmlDictFree(v16);
      dict = doc->dict;
    }

    MemoryParserCtxt->dict = dict;
  }

  else
  {
    uint64_t v9 = v9 | 0x1000;
  }

  encoding = doc->encoding;
  if (encoding)
  {
    if (MemoryParserCtxt->encoding)
    {
      xmlFree((void *)MemoryParserCtxt->encoding);
      encoding = doc->encoding;
    }

    MemoryParserCtxt->encoding = xmlStrdup(encoding);
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)doc->encoding);
    if (!CharEncodingHandler) {
      return 32;
    }
    xmlSwitchToEncoding(MemoryParserCtxt, CharEncodingHandler);
  }

  xmlCtxtUseOptionsInternal((uint64_t *)MemoryParserCtxt, v9, 0LL);
  xmlDetectSAX2((const xmlChar *)MemoryParserCtxt);
  MemoryParserCtxt->xmlDocPtr myDoc = doc;
  MemoryParserCtxt->input_int id = 2;
  MemoryParserCtxt->xmlParserInputState instate = XML_PARSER_CONTENT;
  xmlDocPtr v19 = xmlNewComment(0LL);
  if (!v19)
  {
    xmlFreeParserCtxt(MemoryParserCtxt);
    return 2;
  }

  xmlDocPtr v20 = v19;
  xmlAddChild(v6, v19);
  if (v6->type == XML_ELEMENT_NODE)
  {
    nodePush(MemoryParserCtxt, v6);
    int v21 = 0;
    xmlNodePtr v22 = v6;
    do
    {
      if (v22->type != XML_ELEMENT_NODE) {
        break;
      }
      for (uint64_t i = v22->nsDef; i; uint64_t i = i->next)
      {
        xmlParserInputPtr v24 = MemoryParserCtxt->dict;
        prefix = i->prefix;
        if (v24)
        {
          prefix = xmlDictLookup(v24, i->prefix, -1);
          href = xmlDictLookup(MemoryParserCtxt->dict, i->href, -1);
        }

        else
        {
          href = i->href;
        }

        if (!xmlGetNamespace((uint64_t)MemoryParserCtxt, (uint64_t)prefix))
        {
          nsPush((uint64_t)MemoryParserCtxt, (uint64_t)prefix, (uint64_t)href);
          ++v21;
        }
      }

      xmlNodePtr v22 = v22->parent;
    }

    while (v22);
  }

  else
  {
    int v21 = 0;
  }

  if (MemoryParserCtxt->validate || MemoryParserCtxt->replaceEntities) {
    MemoryParserCtxt->loadsubset |= 8u;
  }
  if (doc->type == XML_HTML_DOCUMENT_NODE) {
    __htmlParseContent((uint64_t)MemoryParserCtxt);
  }
  else {
    xmlParseContent(MemoryParserCtxt);
  }
  nsPop((uint64_t)MemoryParserCtxt, v21);
  xmlNodePtr cur = MemoryParserCtxt->input->cur;
  if (*cur)
  {
    if (*cur == 60 && cur[1] == 47) {
      int v28 = 85;
    }
    else {
      int v28 = 86;
    }
    xmlFatalErr(MemoryParserCtxt, v28, 0LL);
  }

  unsigned int v29 = MemoryParserCtxt->node;
  if (!v29 || v29 == v6)
  {
    if (MemoryParserCtxt->wellFormed)
    {
      xmlParserErrors errNo = XML_ERR_OK;
      goto LABEL_70;
    }
  }

  else
  {
    xmlFatalErr(MemoryParserCtxt, 85, 0LL);
    MemoryParserCtxt->int wellFormed = 0;
  }

  if (MemoryParserCtxt->errNo <= 1u) {
    xmlParserErrors errNo = XML_ERR_INTERNAL_ERROR;
  }
  else {
    xmlParserErrors errNo = MemoryParserCtxt->errNo;
  }
LABEL_70:
  next = v20->next;
  v20->next = 0LL;
  v6->last = v20;
  if (next)
  {
    next->int prev = 0LL;
    *xmlNodePtr lst = next;
    do
    {
      next->parent = 0LL;
      next = next->next;
    }

    while (next);
  }

  else
  {
    *xmlNodePtr lst = 0LL;
  }

  xmlUnlinkNode(v20);
  xmlFreeNode(v20);
  if (errNo)
  {
    xmlFreeNodeList(*lst);
    *xmlNodePtr lst = 0LL;
  }

  if (doc->dict) {
    MemoryParserCtxt->dict = 0LL;
  }
  xmlFreeParserCtxt(MemoryParserCtxt);
  return errNo;
}

xmlParserCtxtPtr xmlCreateMemoryParserCtxt(const char *buffer, int size)
{
  uint64_t v2 = 0LL;
  if (buffer)
  {
    if (size >= 1)
    {
      uint64_t v2 = xmlNewParserCtxt();
      if (v2)
      {
        xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
        if (Mem)
        {
          xmlParserInputBufferPtr v6 = Mem;
          xmlParserInputPtr v7 = xmlNewInputStream(v2);
          if (v7)
          {
            xmlParserInputPtr v8 = v7;
            v7->uint64_t buf = v6;
            v7->filename = 0LL;
            xmlBufResetInput((uint64_t *)v6->buffer, v7);
            inputPush(v2, v8);
            return v2;
          }

          xmlFreeParserInputBuffer(v6);
        }

        xmlFreeParserCtxt(v2);
        return 0LL;
      }
    }
  }

  return v2;
}

uint64_t xmlCtxtUseOptionsInternal(uint64_t *a1, uint64_t a2, xmlChar *cur)
{
  if (a1)
  {
    if (cur)
    {
      xmlParserInputBufferPtr v6 = (void *)a1[5];
      if (v6) {
        xmlFree(v6);
      }
      a1[5] = (uint64_t)xmlStrdup(cur);
    }

    if ((a2 & 1) != 0)
    {
      a2 = (a2 - 1);
      *((_DWORD *)a1 + 141) |= 1u;
      int v7 = 1;
    }

    else
    {
      int v7 = 0;
    }

    *((_DWORD *)a1 + 112) = v7;
    if ((a2 & 4) != 0)
    {
      a2 = (a2 - 4);
      *((_DWORD *)a1 + 141) |= 4u;
      int v8 = 2;
    }

    else
    {
      int v8 = 0;
    }

    *((_DWORD *)a1 + 108) = v8;
    if ((a2 & 8) != 0)
    {
      *((_DWORD *)a1 + 108) = v8 | 4;
      a2 = (a2 - 8);
      *((_DWORD *)a1 + 141) |= 8u;
    }

    if ((a2 & 2) != 0)
    {
      a2 = (a2 - 2);
      *((_DWORD *)a1 + 141) |= 2u;
      int v9 = 1;
    }

    else
    {
      int v9 = 0;
    }

    *((_DWORD *)a1 + 7) = v9;
    if ((a2 & 0x80) != 0)
    {
      a2 = (a2 - 128);
      *((_DWORD *)a1 + 141) |= 0x80u;
      int v10 = 1;
    }

    else
    {
      int v10 = 0;
    }

    *((_DWORD *)a1 + 105) = v10;
    if ((a2 & 0x100) != 0)
    {
      int v11 = 0;
      *(void *)(*a1 + 144) = xmlSAX2IgnorableWhitespace;
      a2 = (a2 - 256);
      *((_DWORD *)a1 + 141) |= 0x100u;
    }

    else
    {
      int v11 = 1;
    }

    *((_DWORD *)a1 + 82) = v11;
    if ((a2 & 0x10) != 0)
    {
      *((_DWORD *)a1 + 39) = 1;
      if ((a2 & 0x40) != 0) {
        a1[22] = 0LL;
      }
      if ((a2 & 0x20) != 0) {
        a1[21] = 0LL;
      }
      a2 = (a2 - 16);
      *((_DWORD *)a1 + 141) |= 0x10u;
      if ((a2 & 0x40) == 0)
      {
LABEL_33:
        if ((a2 & 0x20) != 0)
        {
          uint64_t v13 = *a1;
          a2 = (a2 - 32);
          *(void *)(v13 + 176) = 0LL;
          *(void *)(v13 + 184) = 0LL;
          if ((a2 & 0x200) == 0)
          {
LABEL_35:
            if ((a2 & 0x1000) == 0)
            {
LABEL_36:
              int v12 = 1;
              goto LABEL_40;
            }

LABEL_52:
            *((_DWORD *)a1 + 141) |= 0x20000u;
            a2 = (a2 - 0x20000);
            if ((a2 & 0x40000) == 0)
            {
LABEL_46:
              if ((a2 & 0x80000) == 0) {
                goto LABEL_56;
              }
              goto LABEL_54;
            }

              v7->path = xmlMemStrdup(path);
              goto LABEL_53;
            }

            xmlNodePtr v22 = v8->authority;
            if (v22)
            {
              v7->authority = xmlMemStrdup(v22);
              goto LABEL_72;
            }

            xmlParserInputPtr v24 = v8->server;
            if (v24)
            {
              v7->server = xmlMemStrdup(v24);
            }

            else if (v8->port != -1)
            {
              goto LABEL_72;
            }

            uint64_t v25 = v8->user;
            if (v25) {
              v7->user = xmlMemStrdup(v25);
            }
            v7->int port = v8->port;
LABEL_72:
            path = v6->path;
            if (path)
            {
              if (*path == 47) {
                goto LABEL_52;
              }
              int v28 = strlen(path) + 2;
            }

            else
            {
              int v28 = 2;
            }

            unsigned int v29 = v8->path;
            if (v29) {
              v28 += strlen(v29);
            }
            unsigned int v30 = (char *)xmlMallocAtomic(v28);
            v7->path = v30;
            if (!v30)
            {
              xmlURIErrMemory((uint64_t)"resolving URI against base\n");
              goto LABEL_6;
            }

            *unsigned int v30 = 0;
            uint64_t v31 = v8->path;
            if (v31)
            {
              size_t v32 = *v31;
              if (*v31)
              {
                size_t v33 = 0;
                unsigned int v34 = 0;
                do
                {
                  size_t v35 = v34;
                  for (uint64_t i = v34 - v33 + 1; ; ++i)
                  {
                    if (!v31[v35])
                    {
                      size_t v32 = v33;
                      goto LABEL_96;
                    }

                    if (v31[v35] == 47) {
                      break;
                    }
                    ++v35;
                  }

                  unsigned int v34 = v35 + 1;
                  if (v33 <= (int)v35)
                  {
                    size_t v32 = v35 + 1;
                    uint64_t v37 = v33;
                    do
                    {
                      v7->path[v37] = v8->path[v37];
                      ++v37;
                      --i;
                    }

                    while (i);
                    uint64_t v31 = v8->path;
                    size_t v33 = v34;
                  }

                  else
                  {
                    size_t v32 = v33;
                  }
                }

                while (v31[v34]);
              }
            }

            else
            {
              size_t v32 = 0;
            }

    xmlCharEncoding v16 = len;
    if (len == 1) {
      cur[v12++] = v5;
    }
    else {
      v12 += xmlCopyChar(len, &cur[v12], v5);
    }
    a1->cur += v16;
    int v5 = xmlXPathCurrentChar(a1, &len);
  }

  while (v12 < 100);
  if (v12 >= 0xC351)
  {
LABEL_111:
    size_t v26 = a1;
    int v27 = 7;
    goto LABEL_112;
  }

  xmlParserInputPtr v18 = 2 * v12;
  xmlDocPtr v19 = xmlMallocAtomic((2 * v12));
  xmlParserInputBufferPtr v6 = v19;
  if (!v19)
  {
    xmlXPathErr(a1, 15);
    return v6;
  }

  memcpy(v19, cur, v12);
  while (2)
  {
    if (v5 > 0xFF)
    {
      if (xmlCharInRange(v5, &xmlIsBaseCharGroup)) {
        int v21 = 1;
      }
      else {
        int v21 = v5 == 12295;
      }
      uint64_t v23 = !v21 && v5 - 19968 >= 0x51A6 && v5 - 12321 >= 9;
      if (v23 && !xmlCharInRange(v5, &xmlIsDigitGroup)) {
        goto LABEL_91;
      }
    }

    else
    {
      xmlDocPtr v20 = (v5 & 0x1FFFDF) - 65 >= 0x1A && v5 - 192 >= 0x17;
      if (!v20 || v5 > 0xF7 || v5 - 216 < 0x1F || v5 - 48 < 0xA) {
        goto LABEL_93;
      }
LABEL_91:
      if ((v5 - 45 > 0x32 || ((1LL << (v5 - 45)) & 0x4000000000003LL) == 0) && (!a2 || v5 != 58))
      {
        if (v5 >= 0x100)
        {
          if (xmlCharInRange(v5, &xmlIsCombiningGroup)) {
            goto LABEL_93;
          }
          uint64_t v25 = xmlCharInRange(v5, &xmlIsExtenderGroup);
        }

        else
        {
          uint64_t v25 = v5 == 183;
        }

        if (!v25)
        {
          v6[v12] = 0;
          return v6;
        }
      }
    }

    if (*(_DWORD *)(v9 + 8) == 1 && *(_DWORD *)(a2 + 8) == 1)
    {
      xmlParserInputPtr v18 = *(void *)(v9 + 80);
      if (v18 < 0)
      {
        xmlDocPtr v19 = *(void *)(a2 + 80);
        if (v19 < 0 && *(void *)(v9 + 64) == *(void *)(a2 + 64))
        {
          if (v19 < v18) {
            return 1LL;
          }
          if (v19 > v18) {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }

    goto LABEL_57;
  }

  if (v6 == v17)
  {
    uint64_t v2 = 0xFFFFFFFFLL;
    while (1)
    {
      uint64_t v13 = *(void *)(v13 + 56);
      if (!v13) {
        break;
      }
      if (v13 == a1) {
        return 1LL;
      }
      if (*(_DWORD *)(v13 + 8) == 1) {
        return v2;
      }
    }

    return 0xFFFFFFFFLL;
  }

  if (v6 < v17) {
    return 1LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

                    xmlDocPtr v20 = 0;
LABEL_53:
                    int v27 = (xmlNode *)v16;
                    size_t v26 = 0;
                    uint64_t v25 = (xmlNode *)v16;
                    goto LABEL_54;
                  }

                  goto LABEL_49;
                }
              }

              else
              {
                if (*(_DWORD *)v13 != 5)
                {
                  int v28 = *__xmlGenericError();
                  unsigned int v29 = __xmlGenericErrorContext();
                  v28( *v29,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xpointer.c",  2252);
LABEL_35:
                  int v15 = 0LL;
                  goto LABEL_36;
                }

                int v15 = 0LL;
                xmlCharEncoding v16 = *(void *)(v13 + 40);
                xmlParserCtxtPtr v17 = *(_DWORD *)(v16 + 8);
                if (v17 <= 0xD)
                {
                  xmlParserInputPtr v18 = 1 << v17;
                  if ((v18 & 0x3226) != 0)
                  {
                    xmlDocPtr v19 = *(void *)(v16 + 24);
                    if (!v19) {
                      goto LABEL_52;
                    }
                    xmlDocPtr v20 = 0;
                    do
                    {
                      int v21 = *(_DWORD *)(v19 + 8);
                      xmlNodePtr v22 = v21 > 0xD;
                      uint64_t v23 = (1 << v21) & 0x2202;
                      if (!v22 && v23 != 0) {
                        ++v20;
                      }
                      xmlDocPtr v19 = *(void *)(v19 + 48);
                    }

                    while (v19);
                    goto LABEL_53;
                  }

LABEL_53:
            *((_DWORD *)a1 + 141) |= 0x40000u;
            a2 = (a2 - 0x40000);
            if ((a2 & 0x80000) == 0) {
              goto LABEL_56;
            }
LABEL_54:
            *((_DWORD *)a1 + 141) |= 0x80000u;
            a2 = (a2 - 0x80000);
            int v15 = (xmlDict *)a1[57];
            if (v15) {
              xmlDictSetLimit(v15, 0LL);
            }
LABEL_56:
            if ((a2 & 0x100000) != 0)
            {
              *((_DWORD *)a1 + 141) |= 0x100000u;
              a2 = (a2 - 0x100000);
              if ((a2 & 0x200000) == 0)
              {
LABEL_58:
                if ((a2 & 0x400000) == 0)
                {
LABEL_60:
                  *((_DWORD *)a1 + 109) = 1;
                  return a2;
                }

  if (xmlCharInRange(v18, &xmlIsBaseCharGroup)) {
    xmlDocPtr v19 = 1;
  }
  else {
    xmlDocPtr v19 = (v18 - 12330) > 0xFFFFFFF6;
  }
  do
  {
    while (1)
    {
      do
      {
        do
        {
LABEL_64:
          while (1)
          {
            v3 += len;
            xmlNodePtr v22 = xmlStringCurrentChar(0LL, v3, &len);
            uint64_t v23 = v22;
            if (v22 > 255) {
              break;
            }
            xmlParserInputPtr v24 = (v22 - 192) >= 0x17 && (v22 & 0xFFFFFFDF) - 65 >= 0x1A;
          }

          if (xmlCharInRange(v22, &xmlIsBaseCharGroup)) {
            size_t v26 = 0;
          }
          else {
            size_t v26 = (v23 - 12321) >= 9;
          }
          int v28 = v26 && v23 != 12295 && (v23 - 19968) >= 0x51A6;
        }

        while (!v28 || xmlCharInRange(v23, &xmlIsDigitGroup));
LABEL_88:
        ;
      }

      while ((v23 - 45) <= 0x32 && ((1LL << (v23 - 45)) & 0x4000000000003LL) != 0);
      if (v23 >= 256) {
        break;
      }
      if (v23 != 183) {
        goto LABEL_98;
      }
    }
  }

  while (xmlCharInRange(v23, &xmlIsCombiningGroup) || xmlCharInRange(v23, &xmlIsExtenderGroup));
LABEL_98:
  if (v23 == 58)
  {
    v3 += len;
    unsigned int v30 = xmlStringCurrentChar(0LL, v3, &len);
    uint64_t v31 = v30;
    if (v30 <= 255)
    {
      if ((v30 - 192) < 0x17
        || (v30 & 0xFFFFFFDF) - 65 < 0x1A
        || v30 == 95
        || v30 > 247
        || (v30 - 216) < 0x1F)
      {
        goto LABEL_111;
      }

      return 1;
    }

    if (!xmlCharInRange(v30, &xmlIsBaseCharGroup)
      && (v31 - 12330) <= 0xFFFFFFF6
      && v31 != 12295
      && (v31 - 40870) < 0xFFFFAE5A)
    {
      return 1;
    }

    while (1)
    {
LABEL_111:
      v3 += len;
      size_t v32 = xmlStringCurrentChar(0LL, v3, &len);
      uint64_t v23 = v32;
      if (v32 > 255)
      {
        if (xmlCharInRange(v32, &xmlIsBaseCharGroup)) {
          size_t v35 = 0;
        }
        else {
          size_t v35 = (v23 - 12321) >= 9;
        }
        uint64_t v37 = v35 && v23 != 12295 && (v23 - 19968) >= 0x51A6;
        if (!v37 || xmlCharInRange(v23, &xmlIsDigitGroup)) {
          continue;
        }
      }

      else
      {
        size_t v33 = (v32 - 192) >= 0x17 && (v32 & 0xFFFFFFDF) - 65 >= 0x1A;
      }

      if ((v23 - 45) > 0x32 || ((1LL << (v23 - 45)) & 0x4000000000003LL) == 0)
      {
        if (v23 >= 256)
        {
          if (!xmlCharInRange(v23, &xmlIsCombiningGroup) && !xmlCharInRange(v23, &xmlIsExtenderGroup)) {
            break;
          }
        }

        else if (v23 != 183)
        {
          break;
        }
      }
    }
  }

  if (space && v23 <= 255)
  {
    do
    {
      if (((1LL << v23) & 0x100002600LL) == 0) {
        break;
      }
      v3 += len;
      uint64_t v23 = xmlStringCurrentChar(0LL, v3, &len);
    }

    while (v23 < 256);
  }

  return v23 != 0;
}

uint64_t xmlGetNamespace(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 480) == a2)
  {
    uint64_t v6 = a1 + 496;
    return *(void *)v6;
  }

  else
  {
    int v2 = *(_DWORD *)(a1 + 508);
    while (1)
    {
      BOOL v3 = __OFSUB__(v2, 2);
      v2 -= 2;
      if (v2 < 0 != v3) {
        break;
      }
      uint64_t v4 = *(void *)(a1 + 520);
      if (*(void *)(v4 + 8LL * v2) == a2)
      {
        uint64_t v5 = (v2 + 1);
        if (a2 || **(_BYTE **)(v4 + 8 * v5))
        {
          uint64_t v6 = v4 + 8 * v5;
          return *(void *)v6;
        }

        return 0LL;
      }
    }

    return 0LL;
  }

uint64_t nsPush(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_BYTE *)(a1 + 565) & 0x20) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 508);
    while (1)
    {
      BOOL v7 = __OFSUB__(v6, 2);
      v6 -= 2;
      if (v6 < 0 != v7) {
        break;
      }
      uint64_t v8 = *(void *)(a1 + 520);
      if (*(void *)(v8 + 8LL * v6) == a2)
      {
        return 4294967294LL;
      }
    }
  }

  uint64_t v9 = *(int *)(a1 + 512);
  if ((_DWORD)v9 && (int v10 = *(void **)(a1 + 520)) != 0LL)
  {
    if (*(_DWORD *)(a1 + 508) < (int)v9)
    {
LABEL_12:
      uint64_t v11 = *(int *)(a1 + 508);
      v10[v11] = a2;
      uint64_t v12 = *(void *)(a1 + 520);
      uint64_t result = (v11 + 2);
      *(_DWORD *)(a1 + 508) = result;
      *(void *)(v12 + 8LL * ((int)v11 + 1)) = a3;
      return result;
    }

    *(_DWORD *)(a1 + 512) = 2 * v9;
    int v10 = xmlRealloc(v10, 16 * v9);
    if (v10)
    {
      *(void *)(a1 + 520) = v10;
      goto LABEL_12;
    }

    htmlErrMemory((_DWORD *)a1, 0LL);
    *(int *)(a1 + 512) /= 2;
  }

  else
  {
    *(void *)(a1 + 508) = 0xA00000000LL;
    int v10 = xmlMalloc(0x50uLL);
    *(void *)(a1 + 520) = v10;
    if (v10) {
      goto LABEL_12;
    }
    htmlErrMemory((_DWORD *)a1, 0LL);
    *(_DWORD *)(a1 + 512) = 0;
  }

  return 0xFFFFFFFFLL;
}

uint64_t nsPop(uint64_t result, int a2)
{
  if (*(void *)(result + 520))
  {
    int v2 = a2;
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(result + 508);
    if (v4 < a2)
    {
      xmlGenericErrorFunc v5 = *__xmlGenericError();
      int v6 = __xmlGenericErrorContext();
      uint64_t result = ((uint64_t (*)(void *, const char *, ...))v5)(*v6, "Pbm popping %d NS\n", v2);
      int v4 = *(_DWORD *)(v3 + 508);
      int v2 = v4;
    }

    if (v4 >= 1 && v2 >= 1)
    {
      uint64_t v8 = 8LL * v4 - 8;
      do
      {
        *(void *)(*(void *)(v3 + 520) + v8) = 0LL;
        --v4;
        v8 -= 8LL;
        --v2;
      }

      while (v2);
      *(_DWORD *)(v3 + 508) = v4;
    }
  }

  return result;
}

xmlDocPtr xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename)
{
  xmlParserCtxtPtr URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt) {
    return 0LL;
  }
  int v4 = URLParserCtxt;
  if (sax)
  {
    xmlGenericErrorFunc v5 = URLParserCtxt->sax;
    if (v4->sax) {
      xmlFree(v5);
    }
    v4->sax = sax;
    v4->userData = 0LL;
  }

  xmlParseExtParsedEnt(v4);
  xmlDocPtr myDoc = v4->myDoc;
  if (!v4->wellFormed)
  {
    xmlFreeDoc(v4->myDoc);
    xmlDocPtr myDoc = 0LL;
    v4->xmlDocPtr myDoc = 0LL;
    if (!sax) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  if (sax) {
LABEL_8:
  }
    v4->sax = 0LL;
LABEL_9:
  xmlFreeParserCtxt(v4);
  return myDoc;
}

xmlParserCtxtPtr xmlCreateFileParserCtxt(const char *filename)
{
  return xmlCreateURLParserCtxt(filename, 0);
}

xmlDocPtr xmlParseEntity(const char *filename)
{
  return xmlSAXParseEntity(0LL, filename);
}

xmlParserCtxtPtr xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID, const xmlChar *base)
{
  return xmlCreateEntityParserCtxtInternal(URL, (const char *)ID, base, 0LL);
}

xmlParserCtxt *xmlCreateEntityParserCtxtInternal( const xmlChar *a1, const char *a2, const xmlChar *a3, uint64_t a4)
{
  xmlParserCtxtPtr v8 = xmlNewParserCtxt();
  uint64_t v9 = v8;
  if (!v8) {
    return v9;
  }
  if (a4)
  {
    v8->int options = *(_DWORD *)(a4 + 564);
    v8->_private = *(void **)(a4 + 424);
    v8->input_int id = *(_DWORD *)(a4 + 736) + 1;
  }

  if (!xmlStrcmp(a1, (const xmlChar *)"-")) {
    a1 = (const xmlChar *)"./-";
  }
  int v10 = xmlBuildURI(a1, a3);
  if (v10)
  {
    uint64_t v11 = (char *)v10;
    ExternalxmlEntityPtr Entity = xmlLoadExternalEntity((const char *)v10, a2, v9);
    if (ExternalEntity)
    {
      inputPush(v9, ExternalEntity);
      if (!v9->directory)
      {
        Directory = xmlParserGetDirectory(v11);
        if (!v9->directory)
        {
          if (Directory) {
            v9->directory = Directory;
          }
        }
      }

      xmlFree(v11);
      return v9;
    }

    xmlFree(v11);
LABEL_19:
    xmlFreeParserCtxt(v9);
    return 0LL;
  }

  uint64_t v14 = xmlLoadExternalEntity((const char *)a1, a2, v9);
  if (!v14) {
    goto LABEL_19;
  }
  inputPush(v9, v14);
  if (!v9->directory)
  {
    int v15 = xmlParserGetDirectory((const char *)a1);
    if (!v9->directory)
    {
      if (v15) {
        v9->directory = v15;
      }
    }
  }

  return v9;
}

xmlParserCtxtPtr xmlCreateURLParserCtxt(const char *filename, int options)
{
  uint64_t v2 = *(void *)&options;
  int v4 = (uint64_t *)xmlNewParserCtxt();
  xmlGenericErrorFunc v5 = (xmlParserCtxt *)v4;
  if (v4)
  {
    if ((_DWORD)v2) {
      xmlCtxtUseOptionsInternal(v4, v2, 0LL);
    }
    v5->linenumbers = 1;
    ExternalxmlEntityPtr Entity = xmlLoadExternalEntity(filename, 0LL, v5);
    if (ExternalEntity)
    {
      inputPush(v5, ExternalEntity);
      if (!v5->directory)
      {
        Directory = xmlParserGetDirectory(filename);
        if (!v5->directory)
        {
          if (Directory) {
            v5->directory = Directory;
          }
        }
      }
    }

    else
    {
      xmlFreeParserCtxt(v5);
      return 0LL;
    }
  }

  else
  {
    htmlErrMemory(0LL, (uint64_t)"cannot allocate parser context");
  }

  return v5;
}

xmlDocPtr xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename, int recovery, void *data)
{
  xmlParserCtxtPtr URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt) {
    return 0LL;
  }
  xmlParserCtxtPtr v9 = URLParserCtxt;
  if (sax)
  {
    int v10 = URLParserCtxt->sax;
    if (v9->sax) {
      xmlFree(v10);
    }
    v9->sax = sax;
  }

  xmlDetectSAX2((const xmlChar *)v9);
  if (data) {
    v9->_private = data;
  }
  if (!v9->directory) {
    v9->directory = xmlParserGetDirectory(filename);
  }
  v9->recovery = recovery;
  xmlParseDocument(v9);
  xmlDocPtr myDoc = v9->myDoc;
  if (v9->wellFormed | recovery)
  {
    if (myDoc)
    {
      xmlParserInputBufferPtr buf = v9->input->buf;
      if (buf)
      {
        int compressed = buf->compressed;
        if (compressed >= 1) {
          int compressed = 9;
        }
        myDoc->compression = compressed;
      }
    }
  }

  else
  {
    xmlFreeDoc(v9->myDoc);
    xmlDocPtr myDoc = 0LL;
    v9->xmlDocPtr myDoc = 0LL;
  }

  if (sax) {
    v9->sax = 0LL;
  }
  xmlFreeParserCtxt(v9);
  return myDoc;
}

xmlDocPtr xmlSAXParseFile(xmlSAXHandlerPtr sax, const char *filename, int recovery)
{
  return xmlSAXParseFileWithData(sax, filename, recovery, 0LL);
}

xmlDocPtr xmlRecoverDoc(const xmlChar *cur)
{
  return xmlSAXParseDoc(0LL, cur, 1);
}

xmlDocPtr xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery)
{
  if (!cur) {
    return 0LL;
  }
  int v6 = xmlStrlen(cur);
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)cur, v6);
  if (!MemoryParserCtxt) {
    return 0LL;
  }
  xmlParserCtxtPtr v8 = MemoryParserCtxt;
  if (sax)
  {
    xmlParserCtxtPtr v9 = MemoryParserCtxt->sax;
    MemoryParserCtxt->sax = sax;
    MemoryParserCtxt->userData = 0LL;
  }

  else
  {
    xmlParserCtxtPtr v9 = 0LL;
  }

  xmlDetectSAX2((const xmlChar *)MemoryParserCtxt);
  xmlParseDocument(v8);
  xmlDocPtr myDoc = v8->myDoc;
  if (!(v8->wellFormed | recovery))
  {
    xmlFreeDoc(v8->myDoc);
    xmlDocPtr myDoc = 0LL;
    v8->xmlDocPtr myDoc = 0LL;
  }

  if (sax) {
    v8->sax = v9;
  }
  xmlFreeParserCtxt(v8);
  return myDoc;
}

xmlDocPtr xmlParseFile(const char *filename)
{
  return xmlSAXParseFileWithData(0LL, filename, 0, 0LL);
}

xmlDocPtr xmlRecoverFile(const char *filename)
{
  return xmlSAXParseFileWithData(0LL, filename, 1, 0LL);
}

void xmlSetupParserForBuffer(xmlParserCtxtPtr ctxt, const xmlChar *buffer, const char *filename)
{
  if (ctxt && buffer)
  {
    xmlParserInputPtr v6 = xmlNewInputStream(ctxt);
    if (v6)
    {
      BOOL v7 = v6;
      xmlClearParserCtxt(ctxt);
      if (filename) {
        v7->filename = (const char *)xmlCanonicPath((const xmlChar *)filename);
      }
      v7->unint64_t base = buffer;
      v7->xmlNodePtr cur = buffer;
      v7->end = &buffer[xmlStrlen(buffer)];
      inputPush(ctxt, v7);
    }

    else
    {
      htmlErrMemory(0LL, (uint64_t)"parsing new buffer: out of memory\n");
      xmlClearParserCtxt(ctxt);
    }
  }

int xmlSAXUserParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)
{
  xmlParserCtxtPtr URLParserCtxt = xmlCreateURLParserCtxt(filename, 0);
  if (!URLParserCtxt) {
    return -1;
  }
  xmlParserInputPtr v6 = URLParserCtxt;
  BOOL v7 = (xmlSAXHandlerV1 *)URLParserCtxt->sax;
  if (v7 != __xmlDefaultSAXHandler()) {
    xmlFree(v6->sax);
  }
  v6->sax = sax;
  xmlDetectSAX2((const xmlChar *)v6);
  if (user_data) {
    v6->userData = user_data;
  }
  xmlParseDocument(v6);
  if (v6->wellFormed)
  {
    int errNo = 0;
    if (sax) {
LABEL_8:
    }
      v6->sax = 0LL;
  }

  else
  {
    if (v6->errNo) {
      int errNo = v6->errNo;
    }
    else {
      int errNo = -1;
    }
    if (sax) {
      goto LABEL_8;
    }
  }

  xmlDocPtr myDoc = v6->myDoc;
  if (myDoc)
  {
    xmlFreeDoc(myDoc);
    v6->xmlDocPtr myDoc = 0LL;
  }

  xmlFreeParserCtxt(v6);
  return errNo;
}

xmlDocPtr xmlSAXParseMemoryWithData( xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery, void *data)
{
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt(buffer, size);
  if (!MemoryParserCtxt) {
    return 0LL;
  }
  xmlParserCtxtPtr v11 = MemoryParserCtxt;
  if (sax)
  {
    uint64_t v12 = MemoryParserCtxt->sax;
    if (v11->sax) {
      xmlFree(v12);
    }
    v11->sax = sax;
  }

  xmlDetectSAX2((const xmlChar *)v11);
  if (data) {
    v11->_private = data;
  }
  v11->recovery = recovery;
  xmlParseDocument(v11);
  xmlDocPtr myDoc = v11->myDoc;
  if (!(v11->wellFormed | recovery))
  {
    xmlFreeDoc(v11->myDoc);
    xmlDocPtr myDoc = 0LL;
    v11->xmlDocPtr myDoc = 0LL;
    if (!sax) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

  if (sax) {
LABEL_10:
  }
    v11->sax = 0LL;
LABEL_11:
  xmlFreeParserCtxt(v11);
  return myDoc;
}

xmlDocPtr xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery)
{
  return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, 0LL);
}

xmlDocPtr xmlParseMemory(const char *buffer, int size)
{
  return xmlSAXParseMemoryWithData(0LL, buffer, size, 0, 0LL);
}

xmlDocPtr xmlRecoverMemory(const char *buffer, int size)
{
  return xmlSAXParseMemoryWithData(0LL, buffer, size, 1, 0LL);
}

int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data, const char *buffer, int size)
{
  xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt(buffer, size);
  if (!MemoryParserCtxt) {
    return -1;
  }
  xmlParserCtxtPtr v9 = MemoryParserCtxt;
  int v10 = (xmlSAXHandlerV1 *)MemoryParserCtxt->sax;
  if (v10 != __xmlDefaultSAXHandler()) {
    xmlFree(v9->sax);
  }
  v9->sax = sax;
  xmlDetectSAX2((const xmlChar *)v9);
  if (user_data) {
    v9->userData = user_data;
  }
  xmlParseDocument(v9);
  if (v9->wellFormed)
  {
    int errNo = 0;
    if (sax) {
LABEL_8:
    }
      v9->sax = 0LL;
  }

  else
  {
    if (v9->errNo) {
      int errNo = v9->errNo;
    }
    else {
      int errNo = -1;
    }
    if (sax) {
      goto LABEL_8;
    }
  }

  xmlDocPtr myDoc = v9->myDoc;
  if (myDoc)
  {
    xmlFreeDoc(myDoc);
    v9->xmlDocPtr myDoc = 0LL;
  }

  xmlFreeParserCtxt(v9);
  return errNo;
}

xmlParserCtxtPtr xmlCreateDocParserCtxt(xmlParserCtxtPtr cur)
{
  if (cur)
  {
    int v1 = (const char *)cur;
    int v2 = xmlStrlen((const xmlChar *)cur);
    return xmlCreateMemoryParserCtxt(v1, v2);
  }

  return cur;
}

xmlDocPtr xmlParseDoc(const xmlChar *cur)
{
  return xmlSAXParseDoc(0LL, cur, 0);
}

void xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func)
{
  xmlEntityRefFunc = func;
}

void xmlCleanupParser(void)
{
  if (xmlParserInitialized == 1)
  {
    xmlCleanupCharEncodingHandlers();
    xmlCatalogCleanup();
    xmlDictCleanup();
    xmlCleanupInputCallbacks();
    xmlCleanupOutputCallbacks();
    xmlSchemaCleanupTypes();
    xmlRelaxNGCleanupTypes();
    xmlResetLastError();
    xmlCleanupGlobals();
    xmlCleanupThreads();
    xmlCleanupMemory();
    xmlParserInitialized = 0;
  }

void xmlCtxtReset(xmlParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return;
  }
  dict = ctxt->dict;
  int inputNr = ctxt->inputNr;
  if (inputNr >= 1)
  {
    do
    {
      inputTab = ctxt->inputTab;
      int v5 = inputNr - 1;
      ctxt->int inputNr = inputNr - 1;
      if (inputNr == 1) {
        xmlParserInputPtr v6 = 0LL;
      }
      else {
        xmlParserInputPtr v6 = inputTab[inputNr - 2];
      }
      ctxt->xmlParserInputPtr input = v6;
      BOOL v7 = inputTab[v5];
      inputTab[v5] = 0LL;
      if (!v7) {
        break;
      }
      xmlFreeInputStream(v7);
      int inputNr = ctxt->inputNr;
    }

    while (inputNr > 0);
  }

  ctxt->int inputNr = 0;
  ctxt->xmlParserInputPtr input = 0LL;
  ctxt->int spaceNr = 0;
  spaceTab = ctxt->spaceTab;
  if (spaceTab) {
    int *spaceTab = -1;
  }
  ctxt->space = spaceTab;
  ctxt->nodeNr = 0;
  ctxt->xmlNodePtr node = 0LL;
  ctxt->int nameNr = 0;
  ctxt->name = 0LL;
  ctxt->nsNr = 0;
  version = (xmlChar *)ctxt->version;
  if (version)
  {
    if (dict)
    {
      if (xmlDictOwns(dict, version)) {
        goto LABEL_15;
      }
      version = (xmlChar *)ctxt->version;
    }

    xmlFree(version);
  }

int xmlCtxtResetPush( xmlParserCtxtPtr ctxt, const char *chunk, int size, const char *filename, const char *encoding)
{
  if (!ctxt) {
    return 1;
  }
  xmlCharEncoding v10 = XML_CHAR_ENCODING_NONE;
  if (chunk && size >= 4 && !encoding) {
    xmlCharEncoding v10 = xmlDetectCharEncoding((const unsigned __int8 *)chunk, size);
  }
  xmlParserInputBufferPtr v11 = xmlAllocParserInputBuffer(v10);
  if (!v11) {
    return 1;
  }
  xmlParserInputBufferPtr v12 = v11;
  xmlCtxtReset(ctxt);
  if (filename)
  {
    ctxt->directory = xmlParserGetDirectory(filename);
    xmlParserInputPtr v13 = xmlNewInputStream(ctxt);
    if (v13)
    {
      uint64_t v14 = v13;
      int v15 = xmlCanonicPath((const xmlChar *)filename);
      goto LABEL_13;
    }

    goto LABEL_23;
  }

  ctxt->directory = 0LL;
  xmlParserInputPtr v17 = xmlNewInputStream(ctxt);
  if (!v17)
  {
LABEL_23:
    xmlFreeParserInputBuffer(v12);
    return 1;
  }

  uint64_t v14 = v17;
  int v15 = 0LL;
LABEL_13:
  v14->xmlParserInputBufferPtr buf = v12;
  v14->filename = (const char *)v15;
  xmlBufResetInput((uint64_t *)v12->buffer, v14);
  inputPush(ctxt, v14);
  if (chunk)
  {
    if (size >= 1)
    {
      xmlParserInputPtr input = ctxt->input;
      if (input)
      {
        if (input->buf)
        {
          unint64_t InputBase = xmlBufGetInputBase((uint64_t)input->buf->buffer, (uint64_t)input);
          xmlParserInputPtr v20 = ctxt->input;
          uint64_t v21 = v20->cur - v20->base;
          xmlParserInputBufferPush(v20->buf, size, chunk);
          xmlBufSetInputBaseCur((uint64_t *)ctxt->input->buf->buffer, &ctxt->input->buf, InputBase, v21);
        }
      }
    }
  }

  if (encoding)
  {
    xmlNodePtr v22 = (xmlChar *)ctxt->encoding;
    if (v22) {
      xmlFree(v22);
    }
    ctxt->encoding = xmlStrdup((const xmlChar *)encoding);
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler(encoding);
    if (CharEncodingHandler) {
      xmlSwitchToEncoding(ctxt, CharEncodingHandler);
    }
    else {
      xmlFatalErrMsgStr(ctxt, 32, (uint64_t)"Unsupported encoding %s\n", (uint64_t)encoding);
    }
  }

  else if (v10)
  {
    xmlSwitchEncoding(ctxt, v10);
  }

  return 0;
}

int xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
{
  return xmlCtxtUseOptionsInternal((uint64_t *)ctxt, *(uint64_t *)&options, 0LL);
}

xmlDocPtr xmlReadDoc(const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (cur
    && (uint64_t v4 = *(void *)&options,
        xmlInitParser(),
        int v8 = xmlStrlen(cur),
        (xmlParserCtxtPtr MemoryParserCtxt = xmlCreateMemoryParserCtxt((const char *)cur, v8)) != 0LL))
  {
    return xmlDoRead(MemoryParserCtxt, (const xmlChar *)URL, (xmlChar *)encoding, v4, 0);
  }

  else
  {
    return 0LL;
  }

xmlDocPtr xmlDoRead(xmlParserCtxt *a1, const xmlChar *a2, xmlChar *a3, uint64_t a4, int a5)
{
  if (a3)
  {
    xmlCharEncodingHandlerPtr CharEncodingHandler = xmlFindCharEncodingHandler((const char *)a3);
    if (CharEncodingHandler) {
      xmlSwitchToEncoding(a1, CharEncodingHandler);
    }
  }

  if (a2)
  {
    xmlParserInputPtr input = a1->input;
    if (input)
    {
      if (!input->filename) {
        a1->input->filename = (const char *)xmlStrdup(a2);
      }
    }
  }

  xmlParseDocument(a1);
  if (a1->wellFormed || a1->recovery)
  {
    xmlDocPtr myDoc = a1->myDoc;
  }

  else
  {
    xmlParserInputPtr v13 = a1->myDoc;
    if (v13) {
      xmlFreeDoc(v13);
    }
    xmlDocPtr myDoc = 0LL;
  }

  a1->xmlDocPtr myDoc = 0LL;
  if (!a5) {
    xmlFreeParserCtxt(a1);
  }
  return myDoc;
}

xmlDocPtr xmlReadFile(const char *URL, const char *encoding, int options)
{
  uint64_t v3 = *(void *)&options;
  xmlInitParser();
  xmlDocPtr result = (xmlDocPtr)xmlCreateURLParserCtxt(URL, v3);
  if (result) {
    return xmlDoRead((xmlParserCtxt *)result, 0LL, (xmlChar *)encoding, v3, 0);
  }
  return result;
}

xmlDocPtr xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  uint64_t v5 = *(void *)&options;
  xmlInitParser();
  xmlDocPtr result = (xmlDocPtr)xmlCreateMemoryParserCtxt(buffer, size);
  if (result) {
    return xmlDoRead((xmlParserCtxt *)result, (const xmlChar *)URL, (xmlChar *)encoding, v5, 0);
  }
  return result;
}

xmlDocPtr xmlReadFd(int fd, const char *URL, const char *encoding, int options)
{
  if ((fd & 0x80000000) == 0)
  {
    uint64_t v4 = *(void *)&options;
    xmlInitParser();
    xmlParserInputBufferPtr v8 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if (v8)
    {
      xmlParserCtxtPtr v9 = v8;
      v8->closecallbacuint64_t k = 0LL;
      xmlCharEncoding v10 = xmlNewParserCtxt();
      if (v10)
      {
        xmlParserInputBufferPtr v11 = v10;
        xmlParserInputBufferPtr v12 = xmlNewIOInputStream(v10, v9, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(v11, v12);
          return xmlDoRead(v11, (const xmlChar *)URL, (xmlChar *)encoding, v4, 0);
        }

        xmlFreeParserInputBuffer(v9);
        xmlFreeParserCtxt(v11);
      }

      else
      {
        xmlFreeParserInputBuffer(v9);
      }
    }
  }

  return 0LL;
}

xmlDocPtr xmlReadIO( xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (ioread)
  {
    uint64_t v6 = *(void *)&options;
    xmlInitParser();
    xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      xmlParserInputPtr v13 = IO;
      uint64_t v14 = xmlNewParserCtxt();
      if (v14)
      {
        int v15 = v14;
        xmlCharEncoding v16 = xmlNewIOInputStream(v14, v13, XML_CHAR_ENCODING_NONE);
        if (v16)
        {
          inputPush(v15, v16);
          return xmlDoRead(v15, (const xmlChar *)URL, (xmlChar *)encoding, v6, 0);
        }

        xmlFreeParserInputBuffer(v13);
        xmlFreeParserCtxt(v15);
      }

      else
      {
        xmlFreeParserInputBuffer(v13);
      }
    }

    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }

  return 0LL;
}

xmlDocPtr xmlCtxtReadDoc( xmlParserCtxtPtr ctxt, const xmlChar *cur, const char *URL, const char *encoding, int options)
{
  if (!ctxt) {
    return 0LL;
  }
  if (!cur) {
    return 0LL;
  }
  uint64_t v6 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  xmlCharEncoding v10 = xmlNewStringInputStream(ctxt, cur);
  if (!v10) {
    return 0LL;
  }
  inputPush(ctxt, v10);
  return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v6, 1);
}

xmlDocPtr xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename, const char *encoding, int options)
{
  if (!ctxt) {
    return 0LL;
  }
  if (!filename) {
    return 0LL;
  }
  uint64_t v5 = *(void *)&options;
  xmlInitParser();
  xmlCtxtReset(ctxt);
  ExternalxmlEntityPtr Entity = xmlLoadExternalEntity(filename, 0LL, ctxt);
  if (!ExternalEntity) {
    return 0LL;
  }
  inputPush(ctxt, ExternalEntity);
  return xmlDoRead(ctxt, 0LL, (xmlChar *)encoding, v5, 1);
}

xmlDocPtr xmlCtxtReadMemory( xmlParserCtxtPtr ctxt, const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  if (ctxt)
  {
    if (buffer)
    {
      uint64_t v7 = *(void *)&options;
      xmlInitParser();
      xmlCtxtReset(ctxt);
      xmlParserInputBufferPtr Mem = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
      if (Mem)
      {
        xmlParserInputPtr v13 = Mem;
        uint64_t v14 = xmlNewIOInputStream(ctxt, Mem, XML_CHAR_ENCODING_NONE);
        if (v14)
        {
          inputPush(ctxt, v14);
          return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v7, 1);
        }

        xmlFreeParserInputBuffer(v13);
      }
    }
  }

  return 0LL;
}

xmlDocPtr xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd, const char *URL, const char *encoding, int options)
{
  if (ctxt)
  {
    if ((fd & 0x80000000) == 0)
    {
      uint64_t v6 = *(void *)&options;
      xmlInitParser();
      xmlCtxtReset(ctxt);
      xmlParserInputBufferPtr v10 = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
      if (v10)
      {
        xmlParserInputBufferPtr v11 = v10;
        v10->closecallbacuint64_t k = 0LL;
        xmlParserInputBufferPtr v12 = xmlNewIOInputStream(ctxt, v10, XML_CHAR_ENCODING_NONE);
        if (v12)
        {
          inputPush(ctxt, v12);
          return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v6, 1);
        }

        xmlFreeParserInputBuffer(v11);
      }
    }
  }

  return 0LL;
}

xmlDocPtr xmlCtxtReadIO( xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread, xmlInputCloseCallback ioclose, void *ioctx, const char *URL, const char *encoding, int options)
{
  if (ctxt && ioread)
  {
    uint64_t v8 = *(void *)&options;
    xmlInitParser();
    xmlCtxtReset(ctxt);
    xmlParserInputBufferPtr IO = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, XML_CHAR_ENCODING_NONE);
    if (IO)
    {
      int v15 = IO;
      xmlCharEncoding v16 = xmlNewIOInputStream(ctxt, IO, XML_CHAR_ENCODING_NONE);
      if (v16)
      {
        inputPush(ctxt, v16);
        return xmlDoRead(ctxt, (const xmlChar *)URL, (xmlChar *)encoding, v8, 1);
      }

      xmlFreeParserInputBuffer(v15);
    }

    else if (ioclose)
    {
      ((void (*)(void *))ioclose)(ioctx);
    }
  }

  return 0LL;
}

__n128 xmlIsNameStartChar(uint64_t a1, signed int val)
{
  if ((*(_BYTE *)(a1 + 566) & 2) != 0)
  {
    if (val > 255) {
      xmlCharInRange(val, &xmlIsBaseCharGroup);
    }
  }

  else if ((val > 0x3E || ((1LL << val) & 0x4000800100000000LL) == 0) {
         && (val & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && val != 58
         && val != 95)
  {
    int32x4_t v3 = vdupq_n_s32(val);
    result.n128_u8[0] = vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A37350,  (uint32x4_t)vaddq_s32(v3, (int32x4_t)xmmword_181A37330)),  (int16x8_t)vcgtq_u32( (uint32x4_t)xmmword_181A37360,  (uint32x4_t)vaddq_s32(v3, (int32x4_t)xmmword_181A37340)))));
  }

  return result;
}

uint64_t xmlParseNameAndCompare(uint64_t a1, unsigned __int8 *a2)
{
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  if (*(_DWORD *)(a1 + 272) == -1) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(_BYTE **)(v4 + 32);
  unsigned int v6 = *v5;
  uint64_t v7 = a2;
  uint64_t v8 = v5;
  if (*v5)
  {
    uint64_t v8 = *(_BYTE **)(v4 + 32);
    uint64_t v7 = a2;
    while (1)
    {
      int v9 = *v7;
      if (v6 != v9) {
        break;
      }
      unsigned int v10 = *++v8;
      unsigned int v6 = v10;
      ++v7;
      if (!v10) {
        goto LABEL_9;
      }
    }
  }

  else
  {
LABEL_9:
    unsigned int v6 = 0;
    int v9 = *v7;
  }

  if (v9 || v6 > 0x3E || ((1LL << v6) & 0x4000000100002600LL) == 0)
  {
    uint64_t result = (uint64_t)xmlParseName((xmlParserCtxtPtr)a1);
  }

  else
  {
    *(_DWORD *)(v4 + 56) += (_DWORD)v8 - (_DWORD)v5;
    *(void *)(v4 + 32) = v8;
    return 1LL;
  }

  return result;
}

_DWORD *spacePush(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 376);
  uint64_t v5 = *(int *)(a1 + 380);
  if (v4 < (int)v5)
  {
    uint64_t result = *(_DWORD **)(a1 + 384);
LABEL_5:
    result[v4] = a2;
    uint64_t v7 = *(int *)(a1 + 376);
    *(void *)(a1 + 368) = &result[v7];
    *(_DWORD *)(a1 + 376) = v7 + 1;
    return result;
  }

  *(_DWORD *)(a1 + 380) = 2 * v5;
  uint64_t result = xmlRealloc(*(void **)(a1 + 384), 8 * v5);
  if (result)
  {
    *(void *)(a1 + 384) = result;
    int v4 = *(_DWORD *)(a1 + 376);
    goto LABEL_5;
  }

  uint64_t result = htmlErrMemory((_DWORD *)a1, 0LL);
  *(int *)(a1 + 380) /= 2;
  return result;
}

xmlChar *xmlParseStartTag2(uint64_t a1, const xmlChar **a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v5 = *(xmlParserInput **)(a1 + 56);
  xmlNodePtr cur = v5->cur;
  if (*cur != 60) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(a1 + 464);
  int v132 = *(_DWORD *)(a1 + 472);
  int v11 = *(_DWORD *)(a1 + 508);
  ++v5->col;
  v5->xmlNodePtr cur = cur + 1;
  if (!cur[1])
  {
    xmlParserInputGrow(v5, 250);
    uint64_t v5 = *(xmlParserInput **)(a1 + 56);
  }

  if (!*(_DWORD *)(a1 + 452))
  {
    xmlParserInputBufferPtr v12 = v5->cur;
    if (v12 - v5->base >= 501 && v5->end - v12 <= 499)
    {
      xmlSHRINK(a1);
      uint64_t v5 = *(xmlParserInput **)(a1 + 56);
    }
  }

  __int128 v139 = 0LL;
  unint64_t base = v5->base;
  xmlParserInputPtr v13 = v5->cur;
  int id = v5->id;
  *(_DWORD *)(a1 + 508) = v11;
  xmlCharEncoding v16 = (xmlChar *)xmlParseQName(a1, &v139);
  if (!v16)
  {
    xmlFatalErrMsg((_DWORD *)a1, 68);
    return v16;
  }

  int v129 = id;
  v127 = a2;
  xmlGenericErrorFunc v128 = a3;
  *a4 = (_DWORD)base
      + *(_DWORD *)(*(void *)(a1 + 56) + 32LL)
      - ((_DWORD)v13
       + *(_DWORD *)(*(void *)(a1 + 56) + 24LL));
  xmlSkipBlankChars((xmlParserCtxtPtr)a1);
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  int v133 = 0;
  uint64_t v17 = 0LL;
  int v134 = 0;
  int v130 = 0;
  name2 = 0LL;
  uint64_t v135 = (const xmlChar **)(a1 + 496);
  xmlParserInputPtr v18 = &xmlFree;
  int v131 = v16;
  while (1)
  {
    uint64_t v19 = *(void *)(a1 + 56);
    xmlParserInputPtr v20 = *(unsigned __int8 **)(v19 + 32);
    unsigned int v21 = *v20;
    if (v21 == 47)
    {
      if (v20[1] == 62) {
        goto LABEL_162;
      }
    }

    else
    {
      if (v21 == 62) {
        goto LABEL_162;
      }
      BOOL v22 = v21 - 9 < 2 || v21 == 13;
      if (!v22 && v21 < 0x20) {
        goto LABEL_162;
      }
    }

    if (*(_DWORD *)(a1 + 272) == -1) {
      goto LABEL_162;
    }
    uint64_t v23 = *(unsigned int *)(v19 + 64);
    int v136 = 0;
    int len = -1;
    xmlParserInputPtr v24 = v139;
    uint64_t v25 = xmlParseQName(a1, (const xmlChar **)&name2);
    if (!v25)
    {
      xmlFatalErrMsg((_DWORD *)a1, 68);
LABEL_41:
      unsigned int v30 = 0LL;
      char v35 = 1;
      goto LABEL_42;
    }

    size_t v26 = (xmlChar *)v25;
    int v27 = *(xmlHashTable **)(a1 + 552);
    if (v27) {
      BOOL v28 = xmlHashQLookup2(v27, v24, v16, name2, v26) != 0;
    }
    else {
      BOOL v28 = 0LL;
    }
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) != 61)
    {
      xmlFatalErrMsgStr((_DWORD *)a1, 41, (uint64_t)"Specification mandates value for attribute %s\n", (uint64_t)v26);
      goto LABEL_41;
    }

    xmlNextChar((xmlParserCtxtPtr)a1);
    xmlSkipBlankChars((xmlParserCtxtPtr)a1);
    unsigned int v29 = xmlParseAttValueInternal(a1, &len, &v136, v28);
    unsigned int v30 = v29;
    if (v28)
    {
      if (v136)
      {
        if (v29)
        {
          int v31 = len;
          if (len >= 1)
          {
            int v32 = *v29;
            if (v32 == 32)
            {
              uint64_t v33 = 0LL;
              do
                int v32 = v29[++v33];
              while (v32 == 32);
              unsigned int v34 = &v29[v33];
            }

            else
            {
              LODWORD(v33) = 0;
              unsigned int v34 = v29;
            }

            do
            {
              while (v32 != 32)
              {
                if (!v32)
                {
                  if ((_DWORD)v33)
                  {
                    len -= v33;
                    memmove(v29, &v29[v33], v31 - (int)v33 + 1);
                  }

                  goto LABEL_70;
                }

                int v40 = *++v34;
                int v32 = v40;
              }

              int v41 = *++v34;
              int v32 = v41;
            }

            while ((v41 | 0x20) != 0x20);
            size_t v42 = xmlStrndup(&v29[v33], len - (int)v33 + 1);
            if (v42)
            {
              size_t v43 = (const char *)v42;
              xmlAttrNormalizeSpace((uint64_t)v42, v42);
              int len = strlen(v43);
              if (v43 != (const char *)v30)
              {
                ((void (*)(const xmlChar *))*v18)(v30);
                unsigned int v30 = (const xmlChar *)v43;
              }
            }

            else
            {
              htmlErrMemory((_DWORD *)a1, 0LL);
            }
          }
        }
      }
    }

LABEL_115:
          xmlCharEncoding v16 = v131;
          if (v134 < 1)
          {
LABEL_119:
            int v63 = nsPush(a1, 0LL, (uint64_t)v49);
            int v64 = v134;
            if (v63 > 0) {
              int v64 = v134 + 1;
            }
            int v134 = v64;
          }

          else
          {
            xmlGenericErrorFunc v61 = (void *)(*(void *)(a1 + 520) + 8LL * *(int *)(a1 + 508) - 16);
            uint64_t v62 = (v134 + 1) - 1LL;
            while (*v61)
            {
              v61 -= 2;
              if (!--v62) {
                goto LABEL_119;
              }
            }

            xmlErrAttributeDup((_DWORD *)a1, 0LL, v26);
          }

          goto LABEL_143;
        }

        if (v26 != *(xmlChar **)(a1 + 480))
        {
          uint64_t v59 = (_DWORD *)a1;
          int v60 = "xml namespace URI cannot be the default namespace\n";
          goto LABEL_129;
        }

          if (v55-- <= 1) {
            return 0LL;
          }
        }
      }
    }

    return result;
  }

  int v11 = 0;
  while (1)
  {
    xmlParserInputBufferPtr v12 = *(void *)(*(void *)a4 + 8LL * v11);
    if (*(_DWORD *)v12 == 2000)
    {
      if (*(_DWORD *)(v12 + 16) != 16) {
        goto LABEL_102;
      }
      uint64_t v14 = *(void *)(v12 + 8);
      if (!v14) {
        return 0xFFFFFFFFLL;
      }
      if ((*(_BYTE *)(v14 + 72) & 1) == 0)
      {
        uint64_t result = xmlSchemaAttributeGroupExpandRefs(v8, v14);
        if ((_DWORD)result == -1) {
          return result;
        }
      }

      int v15 = *(void *)(v14 + 80);
      if (!v15)
      {
LABEL_83:
        int v46 = *(void *)(v14 + 112);
        if (v46 && (int v47 = *(_DWORD *)(v46 + 8)) != 0)
        {
          unint64_t v48 = v11;
          *(void *)(*(void *)a4 + 8LL * v1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = **(void **)v46;
          if (v47 >= 2)
          {
            int v49 = 1LL;
            uint64_t v8 = a1;
            while (1)
            {
              xmlURIPtr v50 = *(void *)(*(void *)v46 + 8 * v49);
              int v51 = *(char **)a4;
              if (*(void *)a4)
              {
                uint64_t v52 = *(int *)(a4 + 12);
                if ((int)v52 <= *(_DWORD *)(a4 + 8))
                {
                  *(_DWORD *)(a4 + 12) = 2 * v52;
                  int v51 = (char *)xmlRealloc(v51, 16 * v52);
                  *(void *)a4 = v51;
                  if (!v51)
                  {
                    __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"growing item list");
                    *(_DWORD *)(a4 + 12) = 0;
                    return 0xFFFFFFFFLL;
                  }
                }
              }

              else
              {
                int v51 = (char *)xmlMalloc(0xA0uLL);
                *(void *)a4 = v51;
                if (!v51)
                {
                  __xmlSimpleError(16, 2, 0, 0LL, (uint64_t)"allocating new item list");
                  return 0xFFFFFFFFLL;
                }

                *(_DWORD *)(a4 + 12) = 20;
              }

              ++v48;
              uint64_t v53 = *(int *)(a4 + 8);
              uint64_t v54 = v53;
              if (v48 >= v53)
              {
                *(_DWORD *)(a4 + 8) = v53 + 1;
                *(void *)&v51[8 * v53] = v50;
              }

              else
              {
                do
                {
                  *(void *)(*(void *)a4 + 8 * v54) = *(void *)(*(void *)a4 + 8 * v54 - 8);
                  --v54;
                }

                while (v54 > v48);
                *(void *)(*(void *)a4 + 8 * v48) = v50;
                *(_DWORD *)(a4 + 8) = v53 + 1;
              }

              if (++v49 >= *(int *)(v46 + 8))
              {
                int v11 = v48;
                goto LABEL_102;
              }
            }
          }
        }

        else
        {
          uint64_t result = xmlSchemaItemListRemove(a4, v11);
          if ((_DWORD)result == -1) {
            return result;
          }
          --v11;
        }

        uint64_t v8 = a1;
        goto LABEL_102;
      }

      xmlCharEncoding v16 = *a3;
      if (!*a3)
      {
        *a3 = v15;
        goto LABEL_83;
      }

      if (!v9)
      {
        uint64_t v17 = *(void *)(v8 + 64);
        ComponentNode = xmlSchemaGetComponentNode(a2);
        uint64_t v19 = xmlSchemaAddWildcard(v8, v17, 21, ComponentNode);
        if (!v19) {
          return 0xFFFFFFFFLL;
        }
        xmlCharEncoding v16 = (uint64_t)v19;
        uint64_t result = xmlSchemaCloneWildcardNsConstraints(v8, (uint64_t)v19, *a3);
        if ((_DWORD)result == -1) {
          return result;
        }
        *(_DWORD *)(v16 + 40) = *(_DWORD *)(*a3 + 40);
        *a3 = v16;
        int v15 = *(void *)(v14 + 80);
      }

      xmlParserInputPtr v20 = *(_DWORD *)(v16 + 44);
      unsigned int v21 = *(_DWORD *)(v15 + 44);
      if (v20 == v21)
      {
        BOOL v22 = *(void **)(v16 + 48);
        if ((v22 != 0LL) == (*(void *)(v15 + 48) == 0LL)) {
          goto LABEL_36;
        }
        uint64_t v23 = *(void *)(v16 + 56);
        xmlParserInputPtr v24 = *(void *)(v15 + 56);
        if ((v23 == 0) == (v24 != 0) || v23 && *(void *)(v23 + 8) != *(void *)(v24 + 8)) {
          goto LABEL_36;
        }
        if (!v22)
        {
LABEL_82:
          int v9 = 1;
          goto LABEL_83;
        }

              if ((v82 & 1) != 0) {
                goto LABEL_127;
              }
              if (++v44 == v79) {
                goto LABEL_175;
              }
            }

            goto LABEL_97;
          }

          goto LABEL_138;
        case 2:
          if (*(_DWORD *)(v43 + 8) != 7) {
            goto LABEL_96;
          }
          int v51 = str1;
          if (!str1) {
            goto LABEL_138;
          }
          uint64_t v52 = *(const xmlChar **)(v43 + 16);
          goto LABEL_137;
        case 3:
          if (v40 == 9)
          {
            uint64_t v45 = v46;
            if (*(_DWORD *)(v43 + 8) != 18) {
              goto LABEL_97;
            }
            goto LABEL_115;
          }

          uint64_t v45 = v46;
          if (v40 == 3)
          {
            if (*(_DWORD *)(v43 + 8) != 2) {
              goto LABEL_97;
            }
          }

          else if (*(_DWORD *)(v43 + 8) != 1)
          {
            goto LABEL_97;
          }

          if (!v73) {
            goto LABEL_143;
          }
          int v57 = *(void *)(v43 + 72);
          if (v57) {
            goto LABEL_136;
          }
          goto LABEL_97;
        case 4:
          uint64_t v53 = v20;
          uint64_t v54 = context;
          BOOL v55 = *__xmlGenericError();
          uint64_t v56 = __xmlGenericErrorContext();
          v55( *v56,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xpath.c",  12330);
          context = v54;
          xmlParserInputPtr v20 = v53;
          int v40 = v85;
          goto LABEL_96;
        case 5:
          if (v40 != 9)
          {
            uint64_t v45 = v46;
            if (v40 == 3)
            {
              if (*(_DWORD *)(v43 + 8) != 2) {
                goto LABEL_97;
              }
              if (!xmlStrEqual(str1, *(const xmlChar **)(v43 + 16))) {
                goto LABEL_96;
              }
              int v57 = *(void *)(v43 + 72);
              if (v73)
              {
LABEL_135:
                if (!v57) {
                  goto LABEL_96;
                }
LABEL_136:
                uint64_t v52 = *(const xmlChar **)(v57 + 16);
                int v51 = v78;
LABEL_137:
                if (!xmlStrEqual(v51, v52)) {
                  goto LABEL_96;
                }
LABEL_138:
                if ((v82 & 1) == 0)
                {
                  ++v44;
                  uint64_t v45 = v46;
                  if (v44 == v79) {
                    goto LABEL_155;
                  }
                  goto LABEL_97;
                }

                goto LABEL_144;
              }

              uint64_t v45 = v46;
              if (v57 && *(void *)(v57 + 24)) {
                goto LABEL_97;
              }
            }

            else
            {
              if (*(_DWORD *)(v43 + 8) != 1) {
                goto LABEL_97;
              }
              if (!xmlStrEqual(str1, *(const xmlChar **)(v43 + 16))) {
                goto LABEL_96;
              }
              int v57 = *(void *)(v43 + 72);
              if (v73) {
                goto LABEL_135;
              }
              uint64_t v45 = v46;
              if (v57) {
                goto LABEL_97;
              }
            }

LABEL_142:
        xmlCharEncoding v16 = v131;
LABEL_143:
        if (!v136)
        {
          char v35 = 0;
          goto LABEL_42;
        }

        ((void (*)(const xmlChar *))*v18)(v30);
        char v35 = 0;
        goto LABEL_145;
      }

      if (name2 != v47)
      {
        if (v10 && (int)v17 + 5 <= v132)
        {
          xmlParserInputPtr v18 = v45;
        }

        else
        {
          xmlParserInputPtr v18 = v45;
          int v132 = *(_DWORD *)(a1 + 472);
          uint64_t v10 = *(void *)(a1 + 464);
        }

        xmlCharEncoding v16 = v131;
        *(_DWORD *)(*(void *)(a1 + 528) + 4LL * v133) = v136;
        int v57 = (xmlChar **)(v10 + 8LL * (int)v17);
        *int v57 = v26;
        v57[1] = name2;
        if (v136)
        {
          uint64_t v58 = 0LL;
          int v130 = 1;
        }

        else
        {
          uint64_t v58 = *(void *)(*(void *)(a1 + 56) + 24LL);
        }

        char v35 = 0;
        ++v133;
        *(void *)(v10 + 8 * ((int)v17 + 2LL)) = v58;
        uint64_t v65 = v10 + 8LL * (int)v17;
        uint64_t v66 = &v30[len];
        *(void *)(v65 + 24) = v30;
        *(void *)(v65 + 32) = v66;
        uint64_t v17 = (v17 + 5);
LABEL_145:
        unsigned int v30 = 0LL;
        goto LABEL_42;
      }

      uint64_t v52 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v30, v46);
      uint64_t v53 = (char *)v52;
      uint64_t v54 = *(const xmlChar **)(a1 + 496);
      if (v26 == *(xmlChar **)(a1 + 480))
      {
        xmlParserInputPtr v18 = v45;
        if (v52 != v54)
        {
          uint64_t v59 = (_DWORD *)a1;
          int v60 = "xml namespace prefix mapped to wrong URI\n";
          goto LABEL_129;
        }

        goto LABEL_142;
      }

      if (v52 == v54)
      {
        BOOL v55 = (_DWORD *)a1;
        uint64_t v56 = "xml namespace URI mapped to wrong prefix\n";
      }

      else if (v26 == *(xmlChar **)(a1 + 488))
      {
        BOOL v55 = (_DWORD *)a1;
        uint64_t v56 = "redefinition of the xmlns prefix is forbidden\n";
      }

      else
      {
        if (len != 29 || !xmlStrEqual(v52, (const xmlChar *)"http://www.w3.org/2000/xmlns/"))
        {
          if (v53 && *v53)
          {
            xmlURIPtr v67 = xmlParseURI(v53);
            if (v67)
            {
              if (*(_DWORD *)(a1 + 420) && !v67->scheme)
              {
                uruint64_t i = v67;
                xmlNsWarn((_DWORD *)a1, "xmlns:%s: URI %s is not absolute\n", v26, (xmlChar *)v53);
                xmlURIPtr v67 = uri;
              }

              xmlFreeURI(v67);
            }

            else
            {
              xmlNsErr( (_DWORD *)a1,  99,  (uint64_t)"xmlns:%s: '%s' is not a valid URI\n",  (uint64_t)v26,  (xmlChar *)v53,  0LL);
            }

            if (v134 < 1)
            {
LABEL_153:
              int v71 = nsPush(a1, (uint64_t)v26, (uint64_t)v53);
              int v72 = v134;
              if (v71 > 0) {
                int v72 = v134 + 1;
              }
              int v134 = v72;
            }

            else
            {
              xmlGenericErrorFunc v69 = (xmlChar **)(*(void *)(a1 + 520) + 8LL * *(int *)(a1 + 508) - 16);
              uint64_t v70 = (v134 + 1) - 1LL;
              while (*v69 != v26)
              {
                v69 -= 2;
                if (!--v70) {
                  goto LABEL_153;
                }
              }

              xmlErrAttributeDup((_DWORD *)a1, v47, v26);
            }

            goto LABEL_141;
          }

          BOOL v55 = (_DWORD *)a1;
          uint64_t v56 = "xmlns:%s: Empty XML namespace is not allowed\n";
          uint64_t v68 = (uint64_t)v26;
LABEL_140:
          xmlNsErr(v55, 200, (uint64_t)v56, v68, 0LL, 0LL);
LABEL_141:
          xmlParserInputPtr v18 = v45;
          goto LABEL_142;
        }

        BOOL v55 = (_DWORD *)a1;
        uint64_t v56 = "reuse of the xmlns namespace name is forbidden\n";
      }

      uint64_t v68 = 0LL;
      goto LABEL_140;
    }

    char v35 = 0;
    xmlCharEncoding v16 = v131;
LABEL_42:
    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
    {
      xmlGROW(a1);
    }

    if (*(_DWORD *)(a1 + 272) == -1) {
      goto LABEL_161;
    }
    unsigned __int8 v36 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
    int v37 = *v36;
    if (v37 == 47)
    {
      if (v36[1] == 62) {
        goto LABEL_161;
      }
    }

    else if (v37 == 62)
    {
      goto LABEL_161;
    }

    if (!xmlSkipBlankChars((xmlParserCtxtPtr)a1)) {
      break;
    }
    int v38 = *(void **)(a1 + 56);
    if (v23 == v38[8])
    {
      char v39 = v35 ^ 1;
      if ((v39 & 1) == 0 && !v30)
      {
        xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"xmlParseStartTag: problem parsing attributes\n");
        goto LABEL_161;
      }
    }
  }

  xmlFatalErrMsg((_DWORD *)a1, 65);
LABEL_161:
  uint64_t v19 = *(void *)(a1 + 56);
LABEL_162:
  int v73 = v133;
  if (*(_DWORD *)(v19 + 100) == v129)
  {
    if (v133 >= 1)
    {
      xmlCharEncoding v74 = (void *)(v10 + 32);
      int v75 = v133;
      do
      {
        uint64_t v76 = *(v74 - 2);
        if (v76)
        {
          *(v74 - 2) = 0LL;
          *(v74 - htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *(void *)(*(void *)(a1 + 56) + 24LL) + *(v74 - 1) - v76;
          *xmlCharEncoding v74 = *(void *)(*(void *)(a1 + 56) + 24LL) + *v74 - v76;
        }

        v74 += 5;
        --v75;
      }

      while (v75);
    }

    int v77 = *(xmlHashTable **)(a1 + 544);
    if (v77)
    {
      int v78 = (int *)xmlHashLookup2(v77, v16, v139);
      if (v78)
      {
        int v79 = v78;
        if (*v78 >= 1)
        {
          uint64_t v80 = 0LL;
          uint64_t v81 = 0LL;
          uint64_t v82 = v17;
          while (1)
          {
            int v83 = &v79[10 * v80];
            uint64_t v85 = *((void *)v83 + 1);
            int v84 = (xmlChar *)*((void *)v83 + 2);
            name2 = v84;
            int v86 = *(xmlChar **)(a1 + 488);
            if ((xmlChar *)v85 == v86 && v84 == 0LL) {
              break;
            }
            int v88 = v134;
            if (v84 == v86)
            {
              if (v134 >= 1)
              {
                int v101 = (void *)(*(void *)(a1 + 520) + 8LL * *(int *)(a1 + 508) - 16);
                uint64_t v102 = (v134 + 1) - 1LL;
                while (*v101 != v85)
                {
                  v101 -= 2;
                  if (!--v102) {
                    goto LABEL_207;
                  }
                }

                goto LABEL_215;
              }

LABEL_207:
              if (xmlGetNamespace(a1, v85) != *((void *)v79 + 3))
              {
                uint64_t v103 = *(void *)&v79[10 * v80 + 6];
                uint64_t v104 = a1;
                uint64_t v105 = v85;
                goto LABEL_212;
              }

              goto LABEL_215;
            }

            if ((int)v82 >= 1)
            {
              uint64_t v89 = 0LL;
              while (v85 != *(void *)(v10 + 8 * v89) || v84 != *(xmlChar **)(v10 + 8 * v89 + 8))
              {
                v89 += 5LL;
              }

              goto LABEL_215;
            }

      xmlCompileStepPattern((uint64_t *)v10);
      unsigned __int8 v36 = v10 + 1;
      if (*((_DWORD *)v10 + 4)) {
        goto LABEL_109;
      }
      for (m = *(unsigned __int8 **)v10; ; *(void *)uint64_t v10 = m)
      {
        char v35 = *m;
        if (((1LL << v35) & 0x100002600LL) == 0) {
          break;
        }
        ++m;
      }

      if (v35 == 47)
      {
        while (1)
        {
          uint64_t v82 = *((void *)v10 + 4);
          if (m[1] == 47)
          {
            int v83 = *(unsigned __int8 **)v10;
            if (**(_BYTE **)v10)
            {
              *(void *)uint64_t v10 = v83 + 1;
              if (v83[1])
              {
                v83 += 2;
                goto LABEL_222;
              }

              ++v83;
            }

            while (1)
            {
              uint64_t v85 = *v83;
              uint64_t v25 = v85 > 0x20;
              int v86 = (1LL << v85) & 0x100002600LL;
              if (v25 || v86 == 0) {
                break;
              }
              ++v83;
LABEL_222:
              *(void *)uint64_t v10 = v83;
            }

            goto LABEL_232;
          }

          int v84 = *(_BYTE **)v10;
          if (**(_BYTE **)v10) {
LABEL_228:
          }
            *(void *)uint64_t v10 = ++v84;
          int v88 = *v84;
          if (v88 <= 0x20)
          {
            if (((1LL << v88) & 0x100002600LL) == 0)
            {
              if (!*v84) {
                goto LABEL_108;
              }
              goto LABEL_232;
            }

            goto LABEL_228;
          }

LABEL_210:
          uint64_t v103 = *(void *)&v79[10 * v80 + 6];
          if (v100 != (const xmlChar *)v103)
          {
            uint64_t v104 = a1;
            uint64_t v105 = 0LL;
LABEL_212:
            int v134 = v88;
          }

LABEL_215:
          uint64_t v17 = v82;
          goto LABEL_221;
        }
      }
    }

    uint64_t v81 = 0LL;
LABEL_225:
    if ((int)v17 >= 1)
    {
      unint64_t v108 = 0LL;
      while (1)
      {
        uint64_t v109 = *(void *)(v10 + 8 * (v108 + 1));
        if (v109) {
          break;
        }
        unsigned int v113 = 0LL;
        if (v108)
        {
LABEL_238:
          unint64_t v114 = 0LL;
          uint64_t v115 = *(void *)(v10 + 8 * v108);
          while (1)
          {
            if (v115 == *(void *)(v10 + 8 * v114))
            {
              int v116 = *(const xmlChar **)(v10 + 8 * (v108 + 1));
              if (v116 == *(const xmlChar **)(v10 + 8 * v114 + 8))
              {
                xmlErrAttributeDup((_DWORD *)a1, v116, *(xmlChar **)(v10 + 8 * v108));
                goto LABEL_247;
              }

              if (v113 && *(xmlChar **)(v10 + 8 * v114 + 16) == v113) {
                break;
              }
            }

            v114 += 5LL;
            if (v114 >= v108) {
              goto LABEL_247;
            }
          }

          xmlNsErr((_DWORD *)a1, 203, (uint64_t)"Namespaced Attribute %s in '%s' redefined\n", v115, v113, 0LL);
        }

                      while (1)
                      {
                        xmlNodePtr children = v101->next;
                        if (children) {
                          break;
                        }
                        int v101 = v101->parent;
                        if (v101 == (xmlNode *)v6) {
                          goto LABEL_217;
                        }
                      }
                    }

                    int v101 = node;
                    ns = node->ns;
LABEL_200:
                    if (!ns) {
                      goto LABEL_215;
                    }
                    if (v101->type != XML_ELEMENT_NODE) {
                      goto LABEL_210;
                    }
                    uint64_t v105 = xmlStrEqual(v101->name, (const xmlChar *)"define");
                    int v101 = node;
                    if (!v105) {
                      goto LABEL_210;
                    }
                    int v106 = xmlStrEqual(node->ns->href, (const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                    int v101 = node;
                    if (!v106) {
                      goto LABEL_210;
                    }
                    uint64_t v107 = xmlGetProp(node, (const xmlChar *)"name");
                    if (v107)
                    {
                      unint64_t v108 = v107;
                      xmlRelaxNGNormExtSpace(v107);
                      if (!xmlRelaxNGRemoveRedefine((uint64_t)curb->children, v108)) {
                        xmlRngPErr( a1,  v6,  1013,  "xmlRelaxNG: include %s has a define %s but not the included grammar\n",  (const xmlChar *)doc,  v108);
                      }
                      xmlFree(v108);
                      int v46 = (xmlChar *)doc;
                    }

                    else
                    {
                      int v46 = (xmlChar *)doc;
                      xmlRngPErr( a1,  v6,  1053,  "xmlRelaxNG: include %s has define without name\n",  (const xmlChar *)doc,  0LL);
                    }

                    goto LABEL_209;
                  }

LABEL_247:
        v108 += 5LL;
      }

      unint64_t v110 = (xmlChar **)(a1 + 496);
      if (*(void *)(a1 + 480) == v109)
      {
LABEL_233:
        unsigned int v113 = *v110;
        if (!*v110) {
          goto LABEL_234;
        }
      }

      else
      {
        int v111 = *(_DWORD *)(a1 + 508);
        while (1)
        {
          BOOL v94 = __OFSUB__(v111, 2);
          v111 -= 2;
          if (v111 < 0 != v94) {
            break;
          }
          uint64_t v112 = *(void *)(a1 + 520);
          if (*(void *)(v112 + 8LL * v111) == v109)
          {
            unint64_t v110 = (xmlChar **)(v112 + 8LL * (v111 + 1));
            goto LABEL_233;
          }
        }

              xmlRelaxNGValidErrorPop(v2);
              uint64_t v7 = 0LL;
              int v136 = *(const xmlChar ***)(v2 + 72);
              if (!v136) {
                goto LABEL_252;
              }
            }
          }

          uint64_t v99 = v2;
          uint64_t v100 = 23;
          int v98 = 0LL;
        }

        else
        {
          int v98 = *(xmlChar **)(a2 + 16);
          uint64_t v99 = v2;
          uint64_t v100 = 22;
        }

        xmlRelaxNGAddValidError(v99, v100, v98, 0LL, 0);
LABEL_209:
        if ((*(_BYTE *)(v2 + 56) & 1) == 0) {
          xmlRelaxNGDumpValidError(v2);
        }
LABEL_251:
        uint64_t v7 = 0xFFFFFFFFLL;
        goto LABEL_252;
      case 5:
        if (!v6) {
          goto LABEL_47;
        }
        size_t v26 = 0LL;
        int v27 = v6;
        do
        {
          BOOL v28 = *(_DWORD *)(v27 + 8);
          if ((v28 - 3) >= 2)
          {
            if (v28 == 1)
            {
              xmlGenericErrorFunc v128 = *(xmlChar **)(*(void *)(v6 + 40) + 16LL);
              int v129 = v2;
              int v130 = 28;
              goto LABEL_226;
            }
          }

          else
          {
            size_t v26 = xmlStrcat(v26, *(const xmlChar **)(v27 + 80));
          }

          int v27 = *(void *)(v27 + 48);
        }

        while (v27);
        if (!v26)
        {
LABEL_47:
          size_t v26 = xmlStrdup((const xmlChar *)&byte_181A3ACBA);
          if (!v26) {
            goto LABEL_155;
          }
        }

        unsigned int v29 = xmlRelaxNGValidateDatatype(v2, v26, a2, *(void *)(*(void *)(v2 + 96) + 8LL));
        uint64_t v7 = v29;
        if (!(_DWORD)v29)
        {
          int v38 = *v5;
          goto LABEL_218;
        }

        if ((_DWORD)v29 != -1) {
          goto LABEL_219;
        }
        unsigned int v30 = *(xmlChar **)(a2 + 16);
        int v31 = v2;
        int v32 = 31;
        goto LABEL_216;
      case 7:
        if (!v6) {
          goto LABEL_58;
        }
        size_t v26 = 0LL;
        uint64_t v33 = v6;
        do
        {
          unsigned int v34 = *(_DWORD *)(v33 + 8);
          if ((v34 - 3) >= 2)
          {
            if (v34 == 1)
            {
              xmlGenericErrorFunc v128 = *(xmlChar **)(*(void *)(v6 + 40) + 16LL);
              int v129 = v2;
              int v130 = 29;
              goto LABEL_226;
            }
          }

          else
          {
            size_t v26 = xmlStrcat(v26, *(const xmlChar **)(v33 + 80));
          }

          uint64_t v33 = *(void *)(v33 + 48);
        }

        while (v33);
        if (!v26)
        {
LABEL_58:
          size_t v26 = xmlStrdup((const xmlChar *)&byte_181A3ACBA);
          if (!v26) {
            goto LABEL_155;
          }
        }

        char v35 = *(void *)(v2 + 96);
        unsigned __int8 v36 = *(void *)(v35 + 32);
        *(void *)(v35 + 32) = v26;
        int v37 = xmlRelaxNGValidateValue(v2, a2);
        uint64_t v7 = v37;
        int v38 = *(__int128 **)(v2 + 96);
        *((void *)v38 + 4) = v36;
        if (!(_DWORD)v37)
        {
LABEL_218:
          *((void *)v38 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0LL;
          goto LABEL_219;
        }

        if ((_DWORD)v37 != -1) {
          goto LABEL_219;
        }
        unsigned int v30 = *(xmlChar **)(a2 + 16);
        int v31 = v2;
        int v32 = 32;
        goto LABEL_216;
      case 8:
        if (!v6) {
          goto LABEL_69;
        }
        size_t v26 = 0LL;
        char v39 = v6;
        do
        {
          int v40 = *(_DWORD *)(v39 + 8);
          if ((v40 - 3) >= 2)
          {
            if (v40 == 1)
            {
              xmlGenericErrorFunc v128 = *(xmlChar **)(*(void *)(v6 + 40) + 16LL);
              int v129 = v2;
              int v130 = 30;
LABEL_226:
              xmlRelaxNGAddValidError(v129, v130, v128, 0LL, 0);
              if (v26) {
                xmlFree(v26);
              }
              goto LABEL_251;
            }
          }

          else
          {
            size_t v26 = xmlStrcat(v26, *(const xmlChar **)(v39 + 80));
          }

          char v39 = *(void *)(v39 + 48);
        }

        while (v39);
        if (!v26)
        {
LABEL_69:
          size_t v26 = xmlStrdup((const xmlChar *)&byte_181A3ACBA);
          if (!v26)
          {
LABEL_155:
            xmlRngVErrMemory(v2, (const xmlChar *)"validating\n");
            goto LABEL_251;
          }
        }

        int v41 = xmlStrlen(v26);
        size_t v42 = *(void *)(v2 + 96);
        __int128 v205 = *(_OWORD *)(v42 + 32);
        *(void *)(v42 + 32) = v26;
        *(void *)(v42 + 40) = &v26[v41];
        size_t v43 = xmlRelaxNGValidateValue(v2, a2);
        uint64_t v7 = v43;
        uint64_t v44 = *(void *)(v2 + 96);
        *(_OWORD *)(v44 + 32) = v205;
        if ((_DWORD)v43 == -1)
        {
          int v31 = v2;
          int v32 = 33;
          unsigned int v30 = 0LL;
LABEL_216:
          xmlRelaxNGAddValidError(v31, v32, v30, 0LL, 0);
        }

        else if (!(_DWORD)v43 && v6)
        {
          *(void *)(v44 + 8) = *(void *)(v6 + 48);
        }

LABEL_234:
        xmlNsErr( (_DWORD *)a1,  201,  (uint64_t)"Namespace prefix %s for %s on %s is not defined\n",  v109,  *(xmlChar **)(v10 + 8 * v108),  v16);
        unsigned int v113 = 0LL;
      }

      *(void *)(v10 + 8 * v108 + 16) = v113;
      if (v108) {
        goto LABEL_238;
      }
      goto LABEL_247;
    }

      if (++v33 >= v32)
      {
        unsigned int v30 = v98;
        if (v114) {
          *((_DWORD *)v114 + 5) = 2;
        }
LABEL_237:
        if (++v30 >= *(int *)(v2 + 76))
        {
LABEL_240:
          *(_DWORD *)(v2 + 104) = v1;
          return v1;
        }

        goto LABEL_40;
      }
    }

    int v40 = 0LL;
    int v41 = (_DWORD *)(v34 + 24 * v33 + 20);
    while (1)
    {
      size_t v42 = *(void *)(v31 + 32);
      if (*(_DWORD *)(v42 + 24 * v40 + 8) != -1)
      {
        size_t v43 = *(void *)(v42 + 24 * v40);
        if (v43)
        {
          uint64_t v44 = *v35;
          if (*v35 == v43) {
            goto LABEL_187;
          }
          if (v44)
          {
            uint64_t v45 = *(_DWORD *)(v44 + 4);
            if (v45 != 6)
            {
              int v46 = *(_DWORD *)(v43 + 4);
              if (v46 != 6)
              {
                if (v45 <= v46) {
                  int v47 = *(void *)(v42 + 24 * v40);
                }
                else {
                  int v47 = *v35;
                }
                if (v45 <= v46) {
                  unint64_t v48 = *v35;
                }
                else {
                  unint64_t v48 = *(void *)(v42 + 24 * v40);
                }
                int v49 = *(_DWORD *)(v48 + 4);
                xmlURIPtr v50 = *(_DWORD *)(v47 + 4);
                if (v49 != v50 && v49 - 1 >= 6 && v50 - 1 >= 6)
                {
                  if (v49 >= v50) {
                    uint64_t v59 = *(_DWORD *)(v47 + 4);
                  }
                  else {
                    uint64_t v59 = *(_DWORD *)(v48 + 4);
                  }
                  if (v49 <= v50) {
                    int v60 = *(_DWORD *)(v47 + 4);
                  }
                  else {
                    int v60 = *(_DWORD *)(v48 + 4);
                  }
                  switch(v59)
                  {
                    case 100:
                      if (v60 < 0x6A) {
                        goto LABEL_66;
                      }
                      break;
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 107:
                    case 108:
                    case 109:
                    case 111:
                    case 112:
                    case 113:
                    case 115:
                    case 116:
                    case 117:
                    case 118:
                    case 119:
                    case 120:
                    case 121:
                    case 123:
                    case 124:
                    case 125:
                    case 127:
                    case 128:
                    case 129:
                    case 130:
                    case 132:
                    case 133:
                    case 134:
                    case 135:
                      goto LABEL_189;
                    case 106:
                      if (v60 < 0x6E) {
                        goto LABEL_66;
                      }
                      break;
                    case 110:
                      if (v60 < 0x72) {
                        goto LABEL_66;
                      }
                      break;
                    case 114:
                      if (v60 < 0x7A) {
                        goto LABEL_66;
                      }
                      break;
                    case 122:
                      if (v60 < 0x7E) {
                        goto LABEL_66;
                      }
                      break;
                    case 126:
                      if (v60 < 0x83) {
                        goto LABEL_66;
                      }
                      break;
                    case 131:
                      if (v60 <= 0x87) {
                        goto LABEL_66;
                      }
                      break;
                    default:
                      switch(v59)
                      {
                        case 7:
                          if (v60 - 100 >= 0x16 && v60 - 126 >= 5 && v60 != 8) {
                            goto LABEL_66;
                          }
                          break;
                        case 9:
                          if (v60 - 106 >= 0x1E && v60 != 10) {
                            goto LABEL_66;
                          }
                          break;
                        case 11:
                          if (v60 - 114 >= 0x16 && v60 - 106 >= 4 && v60 != 12) {
                            goto LABEL_66;
                          }
                          break;
                        case 13:
                          uint64_t v95 = v60 - 100 > 0x23 || ((1LL << (v60 - 100)) & 0xFFFFFC3FFLL) == 0;
                          if (v95 && v60 - 14 >= 2) {
                            goto LABEL_66;
                          }
                          break;
                        case 15:
                          if (v60 - 114 >= 0x16 && v60 - 106 >= 4 && v60 != 14) {
                            goto LABEL_66;
                          }
                          break;
                        default:
                          goto LABEL_66;
                      }

                      break;
                  }

                  goto LABEL_189;
                }

LABEL_248:
    unsigned int v117 = v139;
    uint64_t Namespace = xmlGetNamespace(a1, (uint64_t)v139);
    uint64_t v119 = Namespace;
    if (v117 && !Namespace) {
      xmlNsErr((_DWORD *)a1, 201, (uint64_t)"Namespace prefix %s on %s is not defined\n", (uint64_t)v117, v16, 0LL);
    }
    void *v127 = v117;
    *xmlGenericErrorFunc v128 = v119;
    int v73 = v133;
    if (*(void *)a1)
    {
      int v120 = *(void (**)(uint64_t, xmlChar *, const xmlChar *, uint64_t, void, uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 232LL);
      if (v120)
      {
        if (!*(_DWORD *)(a1 + 332))
        {
          uint64_t v121 = *(void *)(a1 + 8);
          if (v134 < 1) {
            v120(v121, v16, v117, v119, 0LL, 0LL, ((int)v17 / 5), v81, v10);
          }
          else {
            v120( v121,  v16,  v117,  v119,  v134,  *(void *)(a1 + 520) + 8LL * (*(_DWORD *)(a1 + 508) - 2 * v134),  ((int)v17 / 5),  v81,  v10);
          }
        }
      }
    }

    xmlParserInputPtr v18 = &xmlFree;
  }

  else
  {
    xmlFatalErr((_DWORD *)a1, 1, (uint64_t)"Unexpected change of input\n");
    xmlCharEncoding v16 = 0LL;
  }

LABEL_258:
  if (v130 && v73 >= 1)
  {
    uint64_t v122 = 0LL;
    unsigned int v123 = (void *)(v10 + 24);
    uint64_t v124 = 4LL * v73;
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 528) + v122) && *v123) {
        ((void (*)(void))*v18)();
      }
      v122 += 4LL;
      v123 += 5;
    }

    while (v124 != v122);
  }

  return v16;
}

            uint64_t v7 = 0LL;
            *(void *)(v2 + 104) = v50;
LABEL_259:
            *(_DWORD *)(v2 + 56) = v61;
            goto LABEL_252;
          }

          break;
        }

        unsigned int v117 = xmlRelaxNGValidateDefinitionList(v2, *(void *)(a2 + 48));
        unsigned int v118 = *(void *)(v2 + 96);
        if (v117)
        {
          xmlRelaxNGFreeValidState(v2, *(void **)(v2 + 96));
          *(void *)(v2 + 96) = 0LL;
        }

        else
        {
          int v111 = *v50;
          if (v118)
          {
            uint64_t v119 = xmlRelaxNGAddStates(v2, v50, v118);
            *(void *)(v2 + 96) = 0LL;
            if (v119 == 1) {
              goto LABEL_199;
            }
          }

          else
          {
            int v120 = *(int **)(v2 + 104);
            if (v120)
            {
              if (*v120 < 1)
              {
                uint64_t v122 = 0;
              }

              else
              {
                uint64_t v121 = 0LL;
                uint64_t v122 = 0;
                do
                {
                  ++v121;
                  int v120 = *(int **)(v2 + 104);
                }

                while (v121 < *v120);
              }

              if (v107) {
                xmlRelaxNGFreeStates(v2, (void **)v120);
              }
              else {
                uint64_t v107 = v120;
              }
              *(void *)(v2 + 104) = 0LL;
              unint64_t v108 = v107;
              if (!v122) {
                goto LABEL_257;
              }
              goto LABEL_199;
            }
          }
        }

        unint64_t v108 = v107;
        if (!v107) {
          goto LABEL_258;
        }
        goto LABEL_257;
      case 0x11:
        uint64_t v52 = xmlRelaxNGSkipIgnored(a1, v6);
        uint64_t v53 = *(_DWORD *)(v2 + 80);
        if ((*(_WORD *)(a2 + 98) & 0x10) != 0)
        {
          uint64_t v54 = *(xmlHashTable **)(a2 + 40);
          if (v54)
          {
            BOOL v55 = v52;
            if (v52)
            {
              uint64_t v56 = *(_DWORD *)(v52 + 8);
              if ((v56 - 3) >= 2)
              {
                if (v56 != 1)
                {
LABEL_249:
                  uint64_t v103 = *(xmlChar **)(v55 + 16);
                  a1 = v2;
                  uint64_t v102 = 38;
                  goto LABEL_250;
                }

                int v132 = *(void *)(v52 + 72);
                int v133 = *(const xmlChar **)(v52 + 16);
                if (v132)
                {
                  uint64_t v8 = xmlHashLookup2(*(xmlHashTablePtr *)(a2 + 40), v133, *(const xmlChar **)(v132 + 16));
                  if (v8) {
                    goto LABEL_8;
                  }
                  int v134 = *(const xmlChar **)(*(void *)(v55 + 72) + 16LL);
                  int v133 = (const xmlChar *)"#any";
                  uint64_t v135 = v54;
                }

                else
                {
                  uint64_t v135 = *(xmlHashTable **)(a2 + 40);
                  int v134 = 0LL;
                }

                uint64_t v8 = xmlHashLookup2(v135, v133, v134);
                if (v8)
                {
LABEL_8:
                  int v9 = xmlRelaxNGValidateDefinition(v2, v8);
LABEL_75:
                  uint64_t v7 = v9;
                  goto LABEL_252;
                }

                int v57 = "#any";
              }

              else
              {
                int v57 = "#text";
              }

              uint64_t v8 = xmlHashLookup2(v54, (const xmlChar *)v57, 0LL);
              if (!v8) {
                goto LABEL_249;
              }
              goto LABEL_8;
            }
          }
        }

        uint64_t v66 = *(void *)(a2 + 48);
        xmlURIPtr v67 = *(_DWORD *)(v2 + 56);
        *(_DWORD *)(v2 + 56) = v67 | 1;
        uint64_t v68 = (int **)(v2 + 104);
        if (v66)
        {
          xmlGenericErrorFunc v69 = 0LL;
          do
          {
            int v4 = (__int128 *)xmlRelaxNGCopyValidState(v2, v4);
            uint64_t v7 = xmlRelaxNGValidateDefinition(v2, v66);
            if ((_DWORD)v7)
            {
              xmlRelaxNGFreeValidState(v2, *(void **)(v2 + 96));
            }

            else
            {
              if (!v69) {
                xmlGenericErrorFunc v69 = (int *)xmlRelaxNGNewStates(v2, 1);
              }
              if (*v5)
              {
                xmlRelaxNGAddStates(v2, v69, (uint64_t)*v5);
              }

              else
              {
                uint64_t v70 = *v68;
                if (*v68)
                {
                  if (*v70 >= 1)
                  {
                    int v71 = 0LL;
                    do
                    {
                      xmlRelaxNGAddStates(v2, v69, *(void *)(*((void *)v70 + 1) + 8 * v71++));
                      uint64_t v70 = *(int **)(v2 + 104);
                    }

                    while (v71 < *v70);
                  }

                  xmlRelaxNGFreeStates(v2, (void **)v70);
                  *(void *)(v2 + 104) = 0LL;
                }
              }
            }

            *uint64_t v5 = v4;
            uint64_t v66 = *(void *)(v66 + 64);
          }

          while (v66);
          if (!v69)
          {
            *(void *)(v2 + 104) = 0LL;
            *(_DWORD *)(v2 + 56) = v67;
            if ((_DWORD)v7)
            {
              if ((v67 & 1) == 0) {
                xmlRelaxNGDumpValidError(v2);
              }
              goto LABEL_252;
            }

            goto LABEL_213;
          }

          xmlRelaxNGFreeValidState(v2, v4);
          *(void *)(v2 + 104) = v69;
        }

        else
        {
          uint64_t v5 = (__int128 **)(v2 + 104);
        }

        *uint64_t v5 = 0LL;
        *(_DWORD *)(v2 + 56) = v67;
LABEL_213:
        if (*(_DWORD *)(v2 + 80) <= v53) {
          goto LABEL_233;
        }
        xmlGenericErrorFunc v126 = v2;
        v127 = v53;
        goto LABEL_232;
      case 0x13:
        uint64_t v58 = *(int **)(a2 + 40);
        if (!v58)
        {
          uint64_t v102 = 10;
          uint64_t v103 = 0LL;
LABEL_250:
          xmlRelaxNGAddValidError(a1, v102, v103, 0LL, 0);
          goto LABEL_251;
        }

        uint64_t v59 = *(_DWORD *)(a1 + 80);
        int v60 = *v58;
        xmlGenericErrorFunc v61 = *(_DWORD *)(a1 + 56);
        __int128 v206 = *(int **)(a2 + 40);
        if ((*(_WORD *)(a2 + 98) & 8) != 0)
        {
          *(_DWORD *)(a1 + 56) = v61 | 4;
          if ((_DWORD)v60 == 2)
          {
            if (v4)
            {
              uint64_t v62 = xmlRelaxNGSkipIgnored(a1, *((void *)v4 + 1));
              uint64_t v58 = v206;
              *((void *)v4 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v62;
            }

            int v63 = (void **)*((void *)v58 + 3);
            int v64 = (_DWORD *)**v63;
            if (*v64 == 3) {
              int v64 = (_DWORD *)*v63[1];
            }
            uint64_t v7 = xmlRelaxNGValidateDefinition(v2, v64);
            if (!(_DWORD)v7 && *v5)
            {
              uint64_t v65 = *v5;
              *((void *)v65 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = xmlRelaxNGSkipIgnored(v2, *((void *)v65 + 1));
            }

            goto LABEL_259;
          }
        }

        __int128 v201 = v59;
        int v72 = xmlMalloc(8 * v60);
        if (!v72) {
          goto LABEL_155;
        }
        int v73 = v72;
        bzero(v72, 8 * v60);
        xmlCharEncoding v74 = xmlMalloc(8 * v60);
        if (!v74) {
          goto LABEL_155;
        }
        int v75 = v74;
        bzero(v74, 8 * v60);
        uint64_t v76 = *(__int128 **)(v2 + 96);
        int v77 = xmlRelaxNGSkipIgnored(v2, *((void *)v76 + 1));
        __int128 v202 = v75;
        v195 = v77;
        if (!v77)
        {
          int v79 = 0LL;
          __int128 v200 = 0LL;
          goto LABEL_261;
        }

        int v78 = v73;
        __int128 v200 = 0LL;
        int v79 = v77;
        break;
      default:
        goto LABEL_252;
    }

    while (1)
    {
      *((void *)*v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v79;
      uint64_t v80 = v206;
      uint64_t v81 = (xmlHashTable *)*((void *)v206 + 1);
      uint64_t v82 = v79;
      if (!v81 || (v206[4] & 1) == 0)
      {
        if ((int)v60 < 1)
        {
          LODWORD(v83) = 0;
        }

        else
        {
          int v83 = 0LL;
          while (1)
          {
            int v84 = *(void *)(*((void *)v80 + 3) + 8 * v83);
            if (v84)
            {
              uint64_t v85 = xmlRelaxNGNodeMatchesList(v79, *(void ***)(v84 + 8));
              int v79 = v82;
              uint64_t v80 = v206;
              if (v85) {
                break;
              }
            }
          }
        }

        goto LABEL_139;
      }

      int v86 = *(_DWORD *)(v79 + 8);
      if ((v86 - 3) < 2)
      {
        int v87 = "#text";
        goto LABEL_133;
      }

      if (v86 != 1) {
        goto LABEL_254;
      }
      uint64_t v95 = *(void *)(v79 + 72);
      int v96 = *(const xmlChar **)(v79 + 16);
      if (v95)
      {
        int v88 = xmlHashLookup2(v81, v96, *(const xmlChar **)(v95 + 16));
        uint64_t v89 = v206;
        int v79 = v82;
        if (v88) {
          goto LABEL_134;
        }
        uint64_t v81 = (xmlHashTable *)*((void *)v206 + 1);
        uint64_t v97 = *(const xmlChar **)(*(void *)(v82 + 72) + 16LL);
        int v96 = (const xmlChar *)"#any";
      }

      else
      {
        uint64_t v97 = 0LL;
      }

      int v88 = xmlHashLookup2(v81, v96, v97);
      uint64_t v89 = v206;
      int v79 = v82;
      if (!v88)
      {
        uint64_t v81 = (xmlHashTable *)*((void *)v206 + 1);
        int v87 = "#any";
LABEL_133:
        int v88 = xmlHashLookup2(v81, (const xmlChar *)v87, 0LL);
        uint64_t v89 = v206;
        int v79 = v82;
        if (!v88) {
          goto LABEL_254;
        }
      }

        uint64_t v125 = v190;
        int v63 = v191;
        goto LABEL_259;
      }

_DWORD *nameNsPush(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v11 = result;
  uint64_t v12 = (int)result[75];
  if (result[74] < (int)v12)
  {
    if (!*((void *)result + 67))
    {
      uint64_t result = xmlMalloc(24 * v12);
      *((void *)v11 + 67) = result;
      if (!result) {
        return htmlErrMemory(v11, 0LL);
      }
    }

const xmlChar *xmlParseQName(uint64_t a1, const xmlChar **a2)
{
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  int v4 = xmlParseNCName(a1);
  int v5 = **(unsigned __int8 **)(*(void *)(a1 + 56) + 32LL);
  if (v4)
  {
    unsigned int v6 = v4;
    if (v5 == 58)
    {
      xmlNextChar((xmlParserCtxtPtr)a1);
      uint64_t v7 = (xmlChar *)xmlParseNCName(a1);
      if (v7)
      {
        uint64_t v8 = v7;
        if (**(_BYTE **)(*(void *)(a1 + 56) + 32LL) == 58)
        {
          xmlNsErr((_DWORD *)a1, 202, (uint64_t)"Failed to parse QName '%s:%s:'\n", (uint64_t)v6, v7, 0LL);
          xmlNextChar((xmlParserCtxtPtr)a1);
          int v9 = xmlParseName((xmlParserCtxtPtr)a1);
          if (v9)
          {
LABEL_11:
            uint64_t v10 = xmlBuildQName(v9, v8, 0LL, 0);
            int v11 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v10, -1);
            if (v10) {
              xmlFree(v10);
            }
            uint64_t v12 = v6;
            unsigned int v6 = v11;
            goto LABEL_26;
          }

          if (*(_DWORD *)(a1 + 272) != -1)
          {
            int v9 = (const xmlChar *)&byte_181A3ACBA;
            goto LABEL_11;
          }

          return 0LL;
        }

        uint64_t v12 = v6;
        unsigned int v6 = v7;
LABEL_26:
        *a2 = v12;
        return v6;
      }

      if (*(_DWORD *)(a1 + 272) == -1) {
        return 0LL;
      }
      xmlNsErr((_DWORD *)a1, 202, (uint64_t)"Failed to parse QName '%s:'\n", (uint64_t)v6, 0LL, 0LL);
      xmlParserInputPtr v13 = xmlParseNmtoken((xmlParserCtxtPtr)a1);
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t v15 = xmlBuildQName(v13, v6, 0LL, 0);
        xmlFree(v14);
      }

      else
      {
        if (*(_DWORD *)(a1 + 272) == -1) {
          return 0LL;
        }
        uint64_t v15 = xmlBuildQName((const xmlChar *)&byte_181A3ACBA, v6, 0LL, 0);
      }

      unsigned int v6 = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v15, -1);
      if (v15) {
        xmlFree(v15);
      }
    }

_DWORD *xmlNsWarn(_DWORD *result, const char *a2, const xmlChar *a3, xmlChar *a4)
{
  if (!result || !result[83] || result[68] != -1) {
    return __xmlRaiseError(0LL, 0LL, 0LL, result, 0LL, 3u, 100, 1, 0LL, 0, a3, a4, 0LL, 0, 0, a2, (char)a3);
  }
  return result;
}

uint64_t xmlCtxtGrowAttrs(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 472);
  if ((_DWORD)v2) {
    uint64_t v2 = (2 * (a2 + 5));
  }
  else {
    uint64_t v2 = 55LL;
  }
  int v4 = xmlMalloc(8LL * (int)v2);
  if (!v4)
  {
LABEL_14:
    htmlErrMemory((_DWORD *)a1, 0LL);
    return 0xFFFFFFFFLL;
  }

  int v5 = v4;
  unsigned int v6 = *(void **)(a1 + 528);
  size_t v7 = 4LL * ((int)v2 / 5);
  if (v6) {
    uint64_t v8 = xmlRealloc(v6, v7);
  }
  else {
    uint64_t v8 = xmlMalloc(v7);
  }
  int v9 = v8;
  if (!v8)
  {
    xmlFree(v5);
    goto LABEL_14;
  }

  uint64_t v10 = *(unsigned int *)(a1 + 472);
  xmlFree(*(void **)(a1 + 464));
  *(void *)(a1 + 464) = v5;
  *(void *)(a1 + 528) = v9;
  *(_DWORD *)(a1 + 472) = v2;
  return v2;
}

const xmlChar *xmlParseNCName(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 564);
  if ((v2 & 0x80000) != 0) {
    unint64_t v3 = 10000000LL;
  }
  else {
    unint64_t v3 = 50000LL;
  }
  int v4 = *(void **)(a1 + 56);
  unsigned int v6 = (const xmlChar *)v4[4];
  unint64_t v5 = v4[5];
  int v7 = *v6;
  if ((v7 & 0xFFFFFFDF) - 65 >= 0x1A)
  {
  }

  else if ((unint64_t)v6 >= v5)
  {
    goto LABEL_27;
  }

  uint64_t v9 = 0LL;
  do
  {
    uint64_t v10 = v9;
    int v11 = v6[v9 + 1];
    if ((v11 - 48) >= 0xA
      && (v11 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v11 - 45) > 0x32 || ((1LL << (v11 - 45)) & 0x4000000000003LL) == 0))
    {
      break;
    }

    ++v9;
  }

  while ((unint64_t)&v6[v10 + 1] < v5);
  unint64_t v14 = (unint64_t)&v6[v10 + 1];
  if (v14 < v5 && (char)v11 >= 1)
  {
    if (v10 + 1 <= v3)
    {
      uint64_t result = xmlDictLookup(*(xmlDictPtr *)(a1 + 456), v6, (int)v10 + 1);
      uint64_t v16 = *(void *)(a1 + 56);
      *(void *)(v16 + 32) = v14;
      *(_DWORD *)(v16 + 56) += v10 + 1;
      if (result) {
        return result;
      }
      htmlErrMemory((_DWORD *)a1, 0LL);
      return 0LL;
    }

    goto LABEL_65;
  }

void xmlParseEndTag2(uint64_t a1, void *a2)
{
  if (!*(_DWORD *)(a1 + 452)
    && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
  {
    xmlGROW(a1);
  }

  int v4 = *(xmlParserInput **)(a1 + 56);
  xmlNodePtr cur = v4->cur;
  if (*cur == 60 && cur[1] == 47)
  {
    v4->xmlNodePtr cur = cur + 2;
    v4->col += 2;
    if (!cur[2]) {
      xmlParserInputGrow(v4, 250);
    }
    unsigned int v6 = (const xmlChar *)*a2;
    int v7 = *(const xmlChar **)(a1 + 288);
    if (*a2)
    {
      uint64_t v8 = *(void *)(a1 + 56);
      if (!*(_DWORD *)(a1 + 452) && (uint64_t)(*(void *)(v8 + 40) - *(void *)(v8 + 32)) <= 249)
      {
        xmlGROW(a1);
        uint64_t v8 = *(void *)(a1 + 56);
      }

      unsigned int v30 = 0LL;
      uint64_t v9 = *(_BYTE **)(v8 + 32);
      int v10 = *v9;
      if (!*v9) {
        goto LABEL_30;
      }
      int v11 = v9 + 2;
      uint64_t v12 = v6;
      while (v10 == *v12)
      {
        ++v12;
        int v10 = *(v11++ - 1);
        if (!v10) {
          goto LABEL_30;
        }
      }

      if (v10 != 58 || *v12) {
        goto LABEL_30;
      }
      uint64_t v14 = (uint64_t)(v11 - 1);
      unsigned int v15 = *(v11 - 1);
      if (*(v11 - 1))
      {
        uint64_t v16 = 0LL;
        while (1)
        {
          int v17 = v7[v16];
          if (v15 != v17) {
            break;
          }
          unsigned int v15 = v11[v16++];
          if (!v15)
          {
            uint64_t v14 = (uint64_t)&v11[v16 - 1];
            uint64_t v18 = &v7[v16];
            goto LABEL_27;
          }
        }

        uint64_t v14 = (uint64_t)&v11[v16 - 1];
      }

      else
      {
        uint64_t v18 = v7;
LABEL_27:
        unsigned int v15 = 0;
        int v17 = *v18;
      }

      if (!v17 && v15 <= 0x3E && ((1LL << v15) & 0x4000000100002600LL) != 0)
      {
        *(_DWORD *)(v8 + 56) += v14 - (_DWORD)v9;
        *(void *)(v8 + 32) = v14;
        uint64_t v13 = 1LL;
      }

      else
      {
LABEL_30:
        unsigned int v19 = xmlParseQName(a1, &v30);
        if (v30 == v6 && v19 == v7) {
          uint64_t v13 = 1LL;
        }
        else {
          uint64_t v13 = (uint64_t)v19;
        }
      }
    }

    else
    {
      uint64_t v13 = xmlParseNameAndCompare(a1, *(unsigned __int8 **)(a1 + 288));
    }

    if (!*(_DWORD *)(a1 + 452)
      && (uint64_t)(*(void *)(*(void *)(a1 + 56) + 40LL) - *(void *)(*(void *)(a1 + 56) + 32LL)) <= 249)
    {
      xmlGROW(a1);
    }

    if (*(_DWORD *)(a1 + 272) != -1)
    {
      xmlSkipBlankChars((xmlParserCtxtPtr)a1);
      int v21 = *(xmlParserInput **)(a1 + 56);
      int v22 = v21->cur;
      if (*v22 == 62)
      {
        ++v21->col;
        v21->xmlNodePtr cur = v22 + 1;
        if (!v22[1]) {
          xmlParserInputGrow(v21, 250);
        }
      }

      else
      {
        xmlFatalErr((_DWORD *)a1, 73, 0LL);
      }

      if (v13 != 1)
      {
        if (v13) {
          int v23 = (xmlChar *)v13;
        }
        else {
          int v23 = (xmlChar *)"unparsable";
        }
        xmlFatalErrMsgStrIntStr( (_DWORD *)a1,  76,  "Opening and ending tag mismatch: %s line %d and %s\n",  *(const xmlChar **)(a1 + 288),  *((_DWORD *)a2 + 4),  v23);
      }

      if (*(void *)a1)
      {
        int v24 = *(void (**)(void, void, void, void))(*(void *)a1 + 240LL);
        if (v24)
        {
          if (!*(_DWORD *)(a1 + 332)) {
            v24(*(void *)(a1 + 8), *(void *)(a1 + 288), *a2, a2[1]);
          }
        }
      }

      int v25 = *(_DWORD *)(a1 + 376);
      if (v25 >= 1)
      {
        unsigned int v26 = v25 - 2;
        unsigned int v27 = v25 - 1;
        *(_DWORD *)(a1 + 376) = v27;
        uint64_t v28 = *(void *)(a1 + 384);
        if (!v27) {
          unsigned int v26 = 0;
        }
        *(void *)(a1 + 368) = v28 + 4LL * v26;
        *(_DWORD *)(v28 + 4LL * v27) = -1;
      }

      int v29 = *((_DWORD *)a2 + 5);
      if (v29) {
        nsPop(a1, v29);
      }
    }
  }

  else
  {
    xmlFatalErr((_DWORD *)a1, 74, 0LL);
  }

uint64_t xmlCleanSpecialAttrCallback(uint64_t result, uint64_t a2, xmlChar *name, xmlChar *name2)
{
  if (result == 1) {
    return xmlHashRemoveEntry2(*(xmlHashTablePtr *)(a2 + 552), name, name2, 0LL);
  }
  return result;
}

uint64_t xmlParseGetLasts(uint64_t result, void *a2, void *a3)
{
  if (!a2 || !a3)
  {
    xmlGenericErrorFunc v16 = *__xmlGenericError();
    uint64_t v13 = __xmlGenericErrorContext();
    return ((uint64_t (*)(void *, const char *))v16)(*v13, "Internal error: xmlParseGetLasts\n");
  }

  if (!*(_DWORD *)(result + 452) || *(_DWORD *)(result + 64) != 1)
  {
LABEL_25:
    *a2 = 0LL;
    goto LABEL_26;
  }

  uint64_t v3 = *(void *)(result + 56);
  unint64_t v4 = *(void *)(v3 + 24);
  unint64_t v5 = (unsigned __int8 *)(*(void *)(v3 + 40) - 1LL);
  do
  {
    int v6 = *v5--;
  }

  while (v6 != 60);
  *a2 = v5 + 1;
  uint64_t v7 = *(void *)(result + 56);
  unint64_t v8 = *(void *)(v7 + 40);
  uint64_t v9 = v5 + 2;
  while ((unint64_t)v9 < v8)
  {
    int v10 = *v9;
    switch(v10)
    {
      case '""':
        int v11 = v9 + 1;
        do
        {
          uint64_t v9 = v11;
          ++v11;
        }

        while (*v9 != 34);
LABEL_21:
        break;
      case '\'':
        uint64_t v12 = v9 + 1;
        do
        {
          uint64_t v9 = v12;
          ++v12;
        }

        while (*v9 != 39);
        goto LABEL_21;
      case '>':
        *a3 = v9;
        return result;
      default:
        ++v9;
        break;
    }
  }

  unint64_t v14 = *(void *)(v7 + 24);
  while ((unint64_t)v5 >= v14)
  {
    int v15 = *v5--;
    if (v15 == 62)
    {
      *a3 = v5 + 1;
      return result;
    }
  }

uint64_t xmlParseLookupSequence(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v5 = *(xmlChar **)(v4 + 24);
  uint64_t v6 = *(void *)(v4 + 32) - (void)v5;
  if ((v6 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    int v11 = *(void *)(a1 + 320);
  }
  if (*(void *)v4)
  {
    unint64_t v5 = xmlBufContent(*(const xmlBuf **)(*(void *)v4 + 32LL));
    int v12 = xmlBufUse(*(const xmlBufPtr *)(*(void *)v4 + 32LL));
  }

  else
  {
    int v12 = *(_DWORD *)(v4 + 48);
  }

  if (a3) {
    int v13 = -1;
  }
  else {
    int v13 = 0;
  }
  if (a4) {
    int v13 = -2;
  }
  int v14 = v12 + v13;
  uint64_t v15 = v11;
  if (v11 >= v14)
  {
LABEL_25:
    *(void *)(a1 + 320) = v15;
    return 0xFFFFFFFFLL;
  }

  while (1)
  {
    if (v5[v15] != a2)
    {
      uint64_t v16 = v15 + 1;
      goto LABEL_23;
    }

    if (!a4) {
      break;
    }
    uint64_t v16 = v15 + 1;
    if (v5[v15 + 1] == a3 && v5[v15 + 2] == a4) {
      goto LABEL_27;
    }
LABEL_23:
    uint64_t v15 = v16;
    if (v16 == v14)
    {
      uint64_t v15 = v14;
      goto LABEL_25;
    }
  }

  if (a3)
  {
    uint64_t v16 = v15 + 1;
    if (v5[v15 + 1] != a3) {
      goto LABEL_23;
    }
  }

uint64_t xmlCheckCdataPush(uint64_t a1, int a2, int a3)
{
  uint64_t result = 0LL;
  if (a1 && a2 >= 1)
  {
    LODWORD(result) = 0;
    do
    {
      uint64_t v5 = (int)result;
      unsigned int v6 = *(unsigned __int8 *)(a1 + (int)result);
      if (*(char *)(a1 + (int)result) < 0)
      {
        if ((v6 & 0xE0) == 0xC0)
        {
          uint64_t result = (result + 2);
          char v10 = *(_BYTE *)(v5 + a1 + 1);
          if ((v10 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          unsigned int v11 = v10 & 0x3F | ((v6 & 0x1F) << 6);
          if (v11 <= 0x1F && (v11 > 0xD || ((1 << v11) & 0x2600) == 0)) {
            return -(int)v5;
          }
        }

        else if ((v6 & 0xF0) == 0xE0)
        {
          uint64_t result = (result + 3);
          char v13 = *(_BYTE *)(v5 + a1 + 1);
          if ((v13 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          char v14 = *(_BYTE *)(v5 + a1 + 2);
          if ((v14 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          unsigned int v15 = ((v6 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F;
          if (v15 <= 0xFF)
          {
            if (v15 > 0x1F) {
              continue;
            }
            if (v15 > 0xD) {
              return -(int)v5;
            }
            int v16 = 1 << v15;
            goto LABEL_40;
          }

          if (v15 >> 11 >= 0x1B && (v15 - 57344) >> 1 >= 0xFFF) {
            return -(int)v5;
          }
        }

        else
        {
          if ((v6 & 0xF8) != 0xF0) {
            return -(int)v5;
          }
          uint64_t result = (result + 4);
          if ((int)result > a2)
          {
LABEL_50:
            if (a3) {
              return -(int)v5;
            }
            else {
              return v5;
            }
          }

          char v17 = *(_BYTE *)(v5 + a1 + 1);
          if ((v17 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          char v18 = *(_BYTE *)(v5 + a1 + 2);
          if ((v18 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          char v19 = *(_BYTE *)(v5 + a1 + 3);
          if ((v19 & 0xC0) != 0x80) {
            return -(int)v5;
          }
          int v20 = ((v6 & 7) << 18) | ((v17 & 0x3F) << 12);
          unsigned int v21 = v19 & 0x3F | ((v18 & 0x3F) << 6) | v20;
          if (v21 <= 0xFF)
          {
            if (v21 > 0x1F) {
              continue;
            }
            if (v21 > 0xD) {
              return -(int)v5;
            }
            int v16 = 1 << v21;
LABEL_40:
            if ((v16 & 0x2600) == 0) {
              return -(int)v5;
            }
            continue;
          }
        }
      }

      else
      {
        if (v6 < 0x20)
        {
          BOOL v7 = v6 > 0xD;
          int v8 = (1 << v6) & 0x2600;
          if (v7 || v8 == 0) {
            return -(int)v5;
          }
        }

        uint64_t result = (result + 1);
      }
    }

    while ((int)result < a2);
  }

  return result;
}

void xmlCheckVersion(int version)
{
  if ((version - 20000) >> 4 >= 0x271)
  {
    xmlGenericErrorFunc v2 = *__xmlGenericError();
    uint64_t v3 = __xmlGenericErrorContext();
    v2(*v3, "Fatal: program compiled against libxml %d using libxml %d\n", version / 10000, 2);
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Fatal: program compiled against libxml %d using libxml %d\n",  version / 10000,  2);
  }

  if (version >= 21000)
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    uint64_t v5 = __xmlGenericErrorContext();
    v4(*v5, "Warning: program compiled against libxml %d using older %d\n", version / 0x64u, 209);
  }

_DWORD *__xmlErrEncoding(_DWORD *result, int a2, uint64_t a3, uint64_t a4, xmlChar *a5)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 1, a2, 3, 0LL, 0, a4, a5, 0LL, 0, 0, a3);
  }
  uint64_t v5 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = a2;
    uint64_t result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, a2, 3, 0LL, 0, a4, a5, 0LL, 0, 0, a3);
    v5[6] = 0;
    if (!v5[112]) {
      v5[83] = 1;
    }
  }

  return result;
}

int xmlIsLetter(int c)
{
  if (c > 255)
  {
    return xmlCharInRange(c, &xmlIsBaseCharGroup)
        || c == 12295
        || (c - 19968) < 0x51A6
        || (c - 12321) < 9;
  }

  else
  {
    unsigned int v2 = c - 192;
    int result = 1;
    if (v2 >= 0x17 && (c & 0xFFFFFFDF) - 65 >= 0x1A && c <= 247) {
      return (c - 216) < 0x1F;
    }
  }

  return result;
}

void xmlHaltParser(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    ctxt->xmlParserInputState instate = XML_PARSER_EOF;
    ctxt->disableSAX = 1;
    if (ctxt->inputNr >= 2)
    {
      do
      {
        unsigned int v2 = inputPop(ctxt);
        xmlFreeInputStream(v2);
      }

      while (ctxt->inputNr > 1);
    }

    xmlParserInputPtr input = ctxt->input;
    if (input)
    {
      xmlParserInputDeallocate free = (void (*)(const xmlChar *))input->free;
      if (free)
      {
        free(input->base);
        xmlParserInputPtr input = ctxt->input;
        input->xmlParserInputDeallocate free = 0LL;
      }

      if (input->buf)
      {
        xmlFreeParserInputBuffer(input->buf);
        xmlParserInputPtr input = ctxt->input;
        input->xmlParserInputBufferPtr buf = 0LL;
      }

      input->size_t length = 0;
      input->unint64_t base = (const xmlChar *)&byte_181A3ACBA;
      input->xmlNodePtr cur = (const xmlChar *)&byte_181A3ACBA;
      input->end = (const xmlChar *)&byte_181A3ACBA;
    }
  }

void xmlFreeInputStream(xmlParserInputPtr input)
{
  if (input)
  {
    filename = (char *)input->filename;
    if (filename) {
      xmlFree(filename);
    }
    directory = (char *)input->directory;
    if (directory) {
      xmlFree(directory);
    }
    encoding = (xmlChar *)input->encoding;
    if (encoding) {
      xmlFree(encoding);
    }
    version = (xmlChar *)input->version;
    if (version) {
      xmlFree(version);
    }
    xmlParserInputDeallocate free = (void (*)(void))input->free;
    if (free && input->base) {
      free();
    }
    if (input->buf) {
      xmlFreeParserInputBuffer(input->buf);
    }
    xmlFree(input);
  }

int xmlParserInputRead(xmlParserInputPtr in, int len)
{
  return -1;
}

int xmlParserInputGrow(xmlParserInputPtr in, int len)
{
  int result = -1;
  if (in)
  {
    if ((len & 0x80000000) == 0)
    {
      if (in->buf)
      {
        unint64_t base = in->base;
        if (base)
        {
          xmlNodePtr cur = in->cur;
          if (cur)
          {
            buffer = in->buf->buffer;
            if (buffer)
            {
              int64_t v8 = cur - base;
              if (xmlBufUse(buffer) <= ((_DWORD)cur - (_DWORD)base + 250) && in->buf->readcallback)
              {
                int v9 = xmlParserInputBufferGrow(in->buf, len);
                char v10 = xmlBufContent(in->buf->buffer);
                in->unint64_t base = v10;
                in->xmlNodePtr cur = &v10[v8];
                in->end = xmlBufEnd(in->buf->buffer);
                return v9;
              }

              else
              {
                return 0;
              }
            }

            else
            {
              return -1;
            }
          }
        }
      }
    }
  }

  return result;
}

void xmlParserInputShrink(xmlParserInputPtr in)
{
  if (in)
  {
    if (in->buf)
    {
      unint64_t base = in->base;
      if (base)
      {
        xmlNodePtr cur = in->cur;
        if (cur)
        {
          buffer = in->buf->buffer;
          if (buffer)
          {
            int64_t v5 = cur - base;
            if ((unint64_t)(cur - base) >= 0xFB)
            {
              size_t v6 = xmlBufShrink(buffer, v5 - 80);
              if (v6)
              {
                v5 -= v6;
                in->consumed += v6;
              }
            }

            if (xmlBufUse(in->buf->buffer) <= 0xFA) {
              xmlParserInputBufferRead(in->buf, 500);
            }
            BOOL v7 = xmlBufContent(in->buf->buffer);
            in->unint64_t base = v7;
            in->xmlNodePtr cur = &v7[v5];
            in->end = xmlBufEnd(in->buf->buffer);
          }
        }
      }
    }
  }

void xmlNextChar(xmlParserCtxtPtr ctxt)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (ctxt)
  {
    if (ctxt->instate != XML_PARSER_EOF)
    {
      xmlParserInputPtr input = ctxt->input;
      if (input)
      {
        xmlNodePtr cur = input->cur;
        end = input->end;
        if (cur > end)
        {
          xmlErrInternal(ctxt, (uint64_t)"Parser input data memory error\n", 0LL);
          ctxt->int errNo = 1;
          xmlStopParser(ctxt);
          return;
        }

        if (end - cur > 0 || xmlParserInputGrow(input, 250) >= 1)
        {
          xmlParserInputPtr v5 = ctxt->input;
          size_t v6 = v5->cur;
          int v7 = *v6;
          if (ctxt->charset == 1)
          {
            if (v7 == 10)
            {
              ++v5->line;
              v5->int col = 1;
            }

            else
            {
              ++v5->col;
            }

            if (*(char *)v6 < 0)
            {
              int v8 = *v6;
              if (v8 == 192
                || (unint64_t v9 = v5->end - v6, v9 <= 1)
                && (xmlParserInputGrow(v5, 250), xmlParserInputPtr v5 = ctxt->input, v6 = v5->cur, v9 = v5->end - v6, v9 < 2)
                || (v6[1] & 0xC0) != 0x80)
              {
LABEL_35:
                if (v5->end - v5->cur > 3)
                {
                  __int128 v27 = 0u;
                  memset(v28, 0, sizeof(v28));
                  __int128 v25 = 0u;
                  __int128 v26 = 0u;
                  __int128 v23 = 0u;
                  __int128 v24 = 0u;
                  __int128 v21 = 0u;
                  __int128 v22 = 0u;
                  *(_OWORD *)__str = 0u;
                  snprintf( __str,  0x95uLL,  "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",  *v5->cur,  *((unsigned __int8 *)v5->cur + 1),  *((unsigned __int8 *)v5->cur + 2),  *((unsigned __int8 *)v5->cur + 3));
                  char v14 = "Input is not proper UTF-8, indicate encoding !\n%s";
                  int v16 = __str;
                  xmlParserCtxtPtr v15 = ctxt;
                }

                else
                {
                  char v14 = "Input is not proper UTF-8, indicate encoding !\n";
                  xmlParserCtxtPtr v15 = ctxt;
                  int v16 = 0LL;
                }

                __xmlErrEncoding(v15, 9, (uint64_t)v14, (uint64_t)v16, 0LL);
                ctxt->charset = 10;
                ++ctxt->input->cur;
                return;
              }

              if ((~v8 & 0xE0) == 0)
              {
                if (v9 > 2 || (xmlParserInputGrow(v5, 250), xmlParserInputPtr v5 = ctxt->input, v6 = v5->cur, v9 = v5->end - v6, v9 >= 3))
                {
                  char v10 = v6 + 2;
                  if ((v6[2] & 0xC0) == 0x80)
                  {
                    if ((~v8 & 0xF0) != 0)
                    {
                      v5->cur += 3;
                      int v12 = (*v6 & 0xF) << 12;
                      int v11 = (v6[1] & 0x3F) << 6;
                      goto LABEL_42;
                    }

                    if (v9 <= 3)
                    {
                      xmlParserInputGrow(v5, 250);
                      xmlParserInputPtr v5 = ctxt->input;
                      size_t v6 = v5->cur;
                      unint64_t v9 = v5->end - v6;
                    }

                    if ((v8 & 0xF8) == 0xF0 && v9 >= 4)
                    {
                      char v10 = v6 + 3;
                      if ((v6[3] & 0xC0) == 0x80)
                      {
                        v5->cur += 4;
                        int v11 = ((*v6 & 7) << 18) | ((v6[1] & 0x3F) << 12);
                        int v12 = (v6[2] & 0x3F) << 6;
LABEL_42:
                        unsigned int v17 = v11 | v12 | *v10 & 0x3F;
                        if ((v11 | v12) >> 11 == 27
                          || HIWORD(v17) > 0x10u
                          || ((v11 | v12) & 0x1FFFFE | *v10 & 0x3E) == 65534)
                        {
                          xmlErrEncodingInt(ctxt, (uint64_t)"Char 0x%X out of allowed range\n", v17);
                          xmlParserInputPtr v5 = ctxt->input;
                        }

                        goto LABEL_33;
                      }
                    }
                  }
                }

                goto LABEL_35;
              }

              char v13 = v6 + 2;
LABEL_32:
              v5->xmlNodePtr cur = v13;
LABEL_33:
              if (v5->end - v5->cur <= 0) {
                xmlParserInputGrow(v5, 250);
              }
              return;
            }
          }

          else if (v7 == 10)
          {
            ++v5->line;
            v5->int col = 1;
          }

          else
          {
            ++v5->col;
          }

          char v13 = v6 + 1;
          goto LABEL_32;
        }
      }
    }
  }

_DWORD *xmlErrInternal(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 1, 1, 3, 0LL, 0, a3, 0LL, 0LL, 0, 0, a2);
  }
  uint64_t v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 1;
    int result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, 1, 3, 0LL, 0, a3, 0LL, 0LL, 0, 0, a2);
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }

  return result;
}

_DWORD *xmlErrEncodingInt(_DWORD *result, uint64_t a2, int a3)
{
  if (!result) {
    return (_DWORD *)__xmlRaiseError(0, 0, 0, 0, 0, 1, 9, 3, 0LL, 0, 0LL, 0LL, 0LL, a3, 0, a2);
  }
  uint64_t v3 = result;
  if (!result[83] || result[68] != -1)
  {
    result[34] = 9;
    int result = (_DWORD *)__xmlRaiseError(0, 0, 0, (int)result, 0, 1, 9, 3, 0LL, 0, 0LL, 0LL, 0LL, a3, 0, a2);
    v3[6] = 0;
    if (!v3[112]) {
      v3[83] = 1;
    }
  }

  return result;
}

int xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len)
{
  unsigned int v2 = 0;
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!ctxt || !len) {
    return v2;
  }
  xmlParserInputPtr input = ctxt->input;
  if (!input || ctxt->instate == XML_PARSER_EOF) {
    return 0;
  }
  xmlNodePtr cur = input->cur;
  int v7 = *(char *)cur;
  if (v7 >= 32)
  {
    *int len = 1;
    return *cur;
  }

  if (ctxt->charset != 1)
  {
    *int len = 1;
    goto LABEL_19;
  }

  int v8 = *cur;
  if ((v7 & 0x80) != 0)
  {
    if (v8 == 192 || (v7 & 0x40) == 0) {
      goto LABEL_44;
    }
    unint64_t v13 = input->end - cur;
    if (v13 <= 1)
    {
      xmlParserInputGrow(input, 250);
      xmlParserInputPtr input = ctxt->input;
      xmlNodePtr cur = input->cur;
      unint64_t v13 = input->end - cur;
      if (v13 < 2) {
        goto LABEL_44;
      }
    }

    if ((cur[1] & 0xC0) != 0x80) {
      goto LABEL_44;
    }
    if ((~v8 & 0xE0) != 0)
    {
      *int len = 2;
      unsigned int v2 = cur[1] & 0x3F | ((*cur & 0x1F) << 6);
      if (v2 < 0x80) {
        goto LABEL_44;
      }
    }

    else
    {
      if (v13 <= 2)
      {
        xmlParserInputGrow(input, 250);
        xmlParserInputPtr input = ctxt->input;
        xmlNodePtr cur = input->cur;
        unint64_t v13 = input->end - cur;
        if (v13 < 3) {
          goto LABEL_44;
        }
      }

      if ((cur[2] & 0xC0) != 0x80) {
        goto LABEL_44;
      }
      if ((~v8 & 0xF0) != 0)
      {
        *int len = 3;
        unsigned int v2 = ((*cur & 0xF) << 12) | ((cur[1] & 0x3F) << 6) | cur[2] & 0x3F;
        if (v2 < 0x800) {
          goto LABEL_44;
        }
      }

      else
      {
        if (v13 <= 3)
        {
          xmlParserInputGrow(input, 250);
          xmlParserInputPtr input = ctxt->input;
          xmlNodePtr cur = input->cur;
          unint64_t v13 = input->end - cur;
        }

        if ((v8 & 0xF8) != 0xF0) {
          goto LABEL_44;
        }
        if (v13 < 4) {
          goto LABEL_44;
        }
        if ((cur[3] & 0xC0) != 0x80) {
          goto LABEL_44;
        }
        *int len = 4;
        unsigned int v2 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12) | ((cur[2] & 0x3F) << 6) | cur[3] & 0x3F;
        if (v2 < 0x10000) {
          goto LABEL_44;
        }
      }
    }

    if (v2 >> 11 < 0x1B) {
      return v2;
    }
    if ((v2 - 57344) >> 1 < 0xFFF) {
      return v2;
    }
    if (v2 - 0x10000 < 0x100000) {
      return v2;
    }
    xmlErrEncodingInt(ctxt, (uint64_t)"Char 0x%X out of allowed range\n", v2);
    if (ctxt->instate != XML_PARSER_EOF) {
      return v2;
    }
    xmlParserInputPtr input = ctxt->input;
LABEL_44:
    if (input->end - input->cur <= 3)
    {
      unsigned int v2 = 0;
      *int len = 0;
      return v2;
    }

    __int128 v21 = 0u;
    memset(v22, 0, sizeof(v22));
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf( __str,  0x95uLL,  "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",  *input->cur,  *((unsigned __int8 *)input->cur + 1),  *((unsigned __int8 *)input->cur + 2),  *((unsigned __int8 *)input->cur + 3));
    __xmlErrEncoding(ctxt, 9, (uint64_t)"Input is not proper UTF-8, indicate encoding !\n%s", (uint64_t)__str, 0LL);
    ctxt->charset = 10;
    *int len = 1;
    xmlNodePtr cur = ctxt->input->cur;
    return *cur;
  }

  *int len = 1;
  if (input->end - cur <= 0)
  {
    xmlParserInputGrow(input, 250);
    xmlParserInputPtr input = ctxt->input;
    xmlNodePtr cur = input->cur;
  }

  unsigned int v2 = *cur;
  if (*cur) {
    goto LABEL_20;
  }
  if (input->end <= cur) {
    return 0;
  }
  xmlErrEncodingInt(ctxt, (uint64_t)"Char 0x0 out of allowed range\n", 0);
  xmlParserInputPtr input = ctxt->input;
  if (ctxt->instate == XML_PARSER_EOF) {
    goto LABEL_44;
  }
  xmlNodePtr cur = input->cur;
LABEL_19:
  unsigned int v2 = *cur;
LABEL_20:
  if (v2 == 13)
  {
    int v11 = cur[1];
    char v10 = cur + 1;
    if (v11 == 10) {
      input->xmlNodePtr cur = v10;
    }
    return 10;
  }

  return v2;
}

int xmlStringCurrentChar(xmlParserCtxtPtr ctxt, const xmlChar *cur, int *len)
{
  unsigned int v3 = 0;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!cur || !len) {
    return v3;
  }
  if (ctxt && ctxt->charset != 1 || (*(char *)cur & 0x80000000) == 0)
  {
LABEL_6:
    *int len = 1;
    return *cur;
  }

  int v8 = cur + 1;
  if ((cur[1] & 0xC0) != 0x80) {
    goto LABEL_34;
  }
  int v9 = *cur;
  if ((~v9 & 0xE0) != 0)
  {
    *int len = 2;
    unsigned int v15 = (*cur & 0x1F) << 6;
    goto LABEL_23;
  }

  int v8 = cur + 2;
  if ((cur[2] & 0xC0) != 0x80) {
    goto LABEL_34;
  }
  if ((~v9 & 0xF0) != 0)
  {
    *int len = 3;
    int v10 = (*cur & 0xF) << 12;
    xmlChar v11 = cur[1];
    goto LABEL_22;
  }

  if ((v9 & 0xF8) != 0xF0 || (int v8 = cur + 3, (cur[3] & 0xC0) != 0x80))
  {
LABEL_34:
    if (!ctxt
      || (xmlParserInputPtr input = ctxt->input) == 0LL
      || (p_cur = &input->cur, unint64_t v13 = (unsigned __int8 *)input->cur, p_cur[1] - v13 <= 3))
    {
      unsigned int v3 = 0;
      *int len = 0;
      return v3;
    }

    __int128 v23 = 0u;
    memset(v24, 0, sizeof(v24));
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf(__str, 0x95uLL, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n", *v13, v13[1], v13[2], v13[3]);
    __xmlErrEncoding(ctxt, 9, (uint64_t)"Input is not proper UTF-8, indicate encoding !\n%s", (uint64_t)__str, 0LL);
    goto LABEL_6;
  }

  *int len = 4;
  int v10 = ((*cur & 7) << 18) | ((cur[1] & 0x3F) << 12);
  xmlChar v11 = cur[2];
LABEL_22:
  unsigned int v15 = v10 & 0xFFFFF03F | ((v11 & 0x3F) << 6);
LABEL_23:
  unsigned int v3 = v15 | *v8 & 0x3F;
  if (v3 > 0xFF)
  {
    if (v3 >> 11 >= 0x1B && (v3 - 57344) >> 1 >= 0xFFF && v3 - 0x10000 >= 0x100000) {
      goto LABEL_31;
    }
  }

  else if (v3 <= 0x1F && (v3 > 0xD || ((1 << v3) & 0x2600) == 0))
  {
LABEL_31:
    xmlErrEncodingInt(ctxt, (uint64_t)"Char 0x%X out of allowed range\n", v3);
  }

  return v3;
}

int xmlCopyCharMultiByte(xmlChar *out, int val)
{
  if (out)
  {
    if (val < 128)
    {
      *out = val;
      LODWORD(v5) = 1;
    }

    else
    {
      if (val >= 0x800)
      {
        if (val >= 0x10000)
        {
          if (val >= 0x110000)
          {
            __xmlRaiseError( 0,  0,  0,  0,  0,  1,  9,  3,  0LL,  0,  0LL,  0LL,  0LL,  val,  0,  (uint64_t)"Internal error, xmlCopyCharMultiByte 0x%X out of bound\n");
            LODWORD(v5) = 0;
            return v5;
          }

          unsigned int v2 = 12;
          char v3 = -16;
          char v4 = 18;
        }

        else
        {
          unsigned int v2 = 6;
          char v3 = -32;
          char v4 = 12;
        }
      }

      else
      {
        unsigned int v2 = 0;
        char v3 = -64;
        char v4 = 6;
      }

      *out = v3 | (val >> v4);
      uint64_t v5 = 1LL;
      do
      {
        out[v5++] = (val >> v2) & 0x3F | 0x80;
        BOOL v6 = v2 > 5;
        v2 -= 6;
      }

      while (v6);
    }
  }

  else
  {
    LODWORD(v5) = 0;
  }

  return v5;
}

int xmlCopyChar(int len, xmlChar *out, int val)
{
  if (!out) {
    return 0;
  }
  if (val >= 128) {
    return xmlCopyCharMultiByte(out, val);
  }
  *out = val;
  return 1;
}

int xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc)
{
  if (!ctxt) {
    return -1;
  }
  switch(enc)
  {
    case XML_CHAR_ENCODING_ERROR:
      __xmlErrEncoding(ctxt, 31, (uint64_t)"encoding unknown\n", 0LL, 0LL);
      return -1;
    case XML_CHAR_ENCODING_NONE:
LABEL_22:
      int v8 = 0;
      ctxt->charset = 1;
      return v8;
    case XML_CHAR_ENCODING_UTF8:
      ctxt->charset = 1;
      xmlParserInputPtr input = ctxt->input;
      if (!input) {
        goto LABEL_29;
      }
      xmlNodePtr cur = input->cur;
      if (*cur != 239 || cur[1] != 187 || cur[2] != 191) {
        goto LABEL_29;
      }
      int v8 = 0;
      input->xmlNodePtr cur = cur + 3;
      return v8;
    case XML_CHAR_ENCODING_UTF16LE:
    case XML_CHAR_ENCODING_UTF16BE:
      xmlParserInputPtr v5 = ctxt->input;
      if (v5)
      {
        BOOL v6 = v5->cur;
        if (v6)
        {
          if (*v6 == 239 && v6[1] == 187 && v6[2] == 191) {
            v5->xmlNodePtr cur = v6 + 3;
          }
        }
      }

      goto LABEL_11;
    case XML_CHAR_ENCODING_UCS4LE:
    case XML_CHAR_ENCODING_UCS4BE:
    case XML_CHAR_ENCODING_UCS4_2143:
    case XML_CHAR_ENCODING_UCS4_3412:
      int v4 = 180;
      goto LABEL_13;
    case XML_CHAR_ENCODING_EBCDIC:
    case XML_CHAR_ENCODING_8859_1:
    case XML_CHAR_ENCODING_8859_2:
    case XML_CHAR_ENCODING_8859_3:
    case XML_CHAR_ENCODING_8859_4:
    case XML_CHAR_ENCODING_8859_5:
    case XML_CHAR_ENCODING_8859_6:
    case XML_CHAR_ENCODING_8859_7:
    case XML_CHAR_ENCODING_8859_8:
    case XML_CHAR_ENCODING_8859_9:
    case XML_CHAR_ENCODING_2022_JP:
    case XML_CHAR_ENCODING_SHIFT_JIS:
    case XML_CHAR_ENCODING_EUC_JP:
    case XML_CHAR_ENCODING_ASCII:
      int v4 = 45;
      goto LABEL_13;
    case XML_CHAR_ENCODING_UCS2:
LABEL_11:
      int v4 = 90;
      goto LABEL_13;
    default:
      int v4 = -1;
LABEL_13:
      xmlCharEncodingHandlerPtr CharEncodingHandler = xmlGetCharEncodingHandler(enc);
      if (!CharEncodingHandler)
      {
        int v9 = "USC4 little endian";
        switch(enc)
        {
          case XML_CHAR_ENCODING_UCS4LE:
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4BE:
            int v9 = "USC4 big endian";
            goto LABEL_41;
          case XML_CHAR_ENCODING_EBCDIC:
            int v9 = "EBCDIC";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4_2143:
            int v9 = "UCS4 2143";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS4_3412:
            int v9 = "UCS4 3412";
            goto LABEL_41;
          case XML_CHAR_ENCODING_UCS2:
            int v9 = "UCS2";
            goto LABEL_41;
          case XML_CHAR_ENCODING_8859_1:
          case XML_CHAR_ENCODING_8859_2:
          case XML_CHAR_ENCODING_8859_3:
          case XML_CHAR_ENCODING_8859_4:
          case XML_CHAR_ENCODING_8859_5:
          case XML_CHAR_ENCODING_8859_6:
          case XML_CHAR_ENCODING_8859_7:
          case XML_CHAR_ENCODING_8859_8:
          case XML_CHAR_ENCODING_8859_9:
            if (ctxt->inputNr == 1 && !ctxt->encoding)
            {
              xmlParserInputPtr v12 = ctxt->input;
              if (v12)
              {
                encoding = v12->encoding;
                if (encoding) {
                  ctxt->encoding = xmlStrdup(encoding);
                }
              }
            }

            int v8 = 0;
            ctxt->charset = enc;
            return v8;
          case XML_CHAR_ENCODING_2022_JP:
            int v9 = "ISO-2022-JP";
            goto LABEL_41;
          case XML_CHAR_ENCODING_SHIFT_JIS:
            int v9 = "Shift_JIS";
            goto LABEL_41;
          case XML_CHAR_ENCODING_EUC_JP:
            int v9 = "EUC-JP";
LABEL_41:
            __xmlErrEncoding(ctxt, 32, (uint64_t)"encoding not supported %s\n", (uint64_t)v9, 0LL);
            break;
          case XML_CHAR_ENCODING_ASCII:
            goto LABEL_22;
          default:
            break;
        }

        xmlStopParser(ctxt);
        return -1;
      }

      ctxt->charset = 1;
      int v8 = xmlSwitchToEncodingInt(ctxt, CharEncodingHandler, v4);
      if (v8 < 0 || ctxt->errNo == 6003)
      {
        if (!ctxt->html)
        {
          xmlStopParser(ctxt);
          ctxt->int errNo = 6003;
        }
      }

      else
      {
LABEL_29:
        int v8 = 0;
      }

      break;
  }

  return v8;
}

uint64_t xmlSwitchToEncodingInt(xmlParserCtxt *a1, xmlCharEncodingHandler *handler, int a3)
{
  if (handler)
  {
    xmlParserInputPtr input = (uint64_t *)a1->input;
    if (input)
    {
      uint64_t result = xmlSwitchInputEncodingInt(a1, input, handler, a3);
      a1->charset = 1;
      return result;
    }

    xmlErrInternal(a1, (uint64_t)"xmlSwitchToEncoding : no input\n", 0LL);
  }

  return 0xFFFFFFFFLL;
}

int xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input, xmlCharEncodingHandlerPtr handler)
{
  return xmlSwitchInputEncodingInt(ctxt, (uint64_t *)input, handler, -1);
}

uint64_t xmlSwitchInputEncodingInt(xmlParserCtxt *a1, uint64_t *a2, xmlCharEncodingHandler *handler, int a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && handler)
  {
    uint64_t v8 = *a2;
    if (*a2)
    {
      int v9 = *(xmlCharEncodingHandler **)(v8 + 24);
      if (v9)
      {
        if (v9 != handler)
        {
          xmlCharEncCloseFunc(v9);
          uint64_t result = 0LL;
          *(void *)(*a2 + 24) = handler;
          return result;
        }

        return 0LL;
      }

      *(void *)(v8 + 24) = handler;
      xmlChar v11 = xmlBufCreate();
      if (v11)
      {
        xmlParserInputPtr v12 = v11;
        name = handler->name;
        if (name)
        {
          if (!strcmp(name, "UTF-16LE") || !strcmp(name, "UTF-16"))
          {
            char v14 = (unsigned __int8 *)a2[4];
            if (*v14 == 255 && v14[1] == 254) {
              a2[4] = (uint64_t)(v14 + 2);
            }
          }

          if (!strcmp(name, "UTF-16BE"))
          {
            unsigned int v15 = (unsigned __int8 *)a2[4];
            if (*v15 == 254 && v15[1] == 255) {
              a2[4] = (uint64_t)(v15 + 2);
            }
          }

          if (!strcmp(name, "UTF-8"))
          {
            __int128 v16 = (unsigned __int8 *)a2[4];
            if (*v16 == 239 && v16[1] == 187 && v16[2] == 191) {
              a2[4] = (uint64_t)(v16 + 3);
            }
          }
        }

        size_t v17 = *((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6);
        xmlBufShrink(*(xmlBufPtr *)(*a2 + 32), v17);
        __int128 v18 = (void *)*a2;
        __int128 v19 = *(xmlBuf **)(*a2 + 32);
        v18[4] = v12;
        v18[5] = v19;
        v18[7] = v17;
        unsigned int v20 = xmlBufUse(v19);
        uint64_t v21 = *a2;
        if (a1->html) {
          int LineInput = xmlCharEncInput(v21, 1);
        }
        else {
          int LineInput = xmlCharEncFirstLineInput(v21, a4);
        }
        int v23 = LineInput;
        xmlBufResetInput(*(uint64_t **)(*a2 + 32), a2);
        if ((v23 & 0x80000000) == 0)
        {
          size_t v24 = xmlBufUse(*(const xmlBufPtr *)(*a2 + 40));
          uint64_t result = 0LL;
          *(void *)(*a2 + 56) = *(void *)(*a2 + 56) - v24 + v20;
          return result;
        }

        if (!a1->html)
        {
          xmlErrInternal(a1, (uint64_t)"switching encoding: encoder error\n", 0LL);
          xmlHaltParser(a1);
        }
      }

      else
      {
        htmlErrMemory(a1, 0LL);
      }
    }

    else
    {
      if (*((_DWORD *)a2 + 12))
      {
        xmlCharEncCloseFunc(handler);
        return 0LL;
      }

      xmlErrInternal(a1, (uint64_t)"switching encoding : no input\n", 0LL);
      xmlCharEncCloseFunc(handler);
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

int xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)
{
  return xmlSwitchToEncodingInt(ctxt, handler, -1);
}

xmlParserInputPtr xmlNewInputStream(xmlParserCtxtPtr ctxt)
{
  xmlParserInputPtr result = (xmlParserInputPtr)xmlMalloc(0x68uLL);
  if (!result)
  {
    char v3 = "couldn't allocate a new input stream\n";
    goto LABEL_6;
  }

  *(void *)&result->standalone = 0LL;
  *(_OWORD *)&result->int consumed = 0u;
  *(_OWORD *)&result->encoding = 0u;
  *(_OWORD *)&result->xmlNodePtr cur = 0u;
  *(_OWORD *)&result->size_t length = 0u;
  *(_OWORD *)&result->xmlParserInputBufferPtr buf = 0u;
  *(_OWORD *)&result->directory = 0u;
  *(void *)&result->int line = 0x100000001LL;
  result->standalone = -1;
  if (!ctxt) {
    return result;
  }
  if (result->id == 0x7FFFFFFF)
  {
    char v3 = "Input ID overflow\n";
LABEL_6:
    htmlErrMemory(ctxt, (uint64_t)v3);
    return 0LL;
  }

  input_int id = ctxt->input_id;
  ctxt->input_int id = input_id + 1;
  result->int id = input_id;
  return result;
}

xmlParserInputPtr xmlNewIOInputStream( xmlParserCtxtPtr ctxt, xmlParserInputBufferPtr input, xmlCharEncoding enc)
{
  if (!input) {
    return 0LL;
  }
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v6 = *__xmlGenericError();
    int v7 = __xmlGenericErrorContext();
    v6(*v7, "new input from I/O\n");
  }

  xmlParserInputPtr v8 = xmlNewInputStream(ctxt);
  int v9 = v8;
  if (v8)
  {
    v8->xmlParserInputBufferPtr buf = input;
    v8->filename = 0LL;
    xmlBufResetInput((uint64_t *)input->buffer, v8);
    if (enc) {
      xmlSwitchEncoding(ctxt, enc);
    }
  }

  return v9;
}

xmlParserInputPtr xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity)
{
  unsigned int v2 = ctxt;
  if (!entity)
  {
    int v10 = "xmlNewEntityInputStream entity = NULL\n";
    name = 0LL;
LABEL_19:
    xmlErrInternal(ctxt, (uint64_t)v10, (uint64_t)name);
    return 0LL;
  }

  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlParserInputPtr v5 = __xmlGenericErrorContext();
    v4(*v5, "new input from entity: %s\n", (const char *)entity->name);
  }

  if (!entity->content)
  {
    switch(entity->etype)
    {
      case XML_INTERNAL_GENERAL_ENTITY:
        name = entity->name;
        int v10 = "Internal entity %s without content !\n";
        goto LABEL_18;
      case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
      case XML_EXTERNAL_PARAMETER_ENTITY:
        return xmlLoadExternalEntity((const char *)entity->URI, (const char *)entity->ExternalID, v2);
      case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
        name = entity->name;
        int v10 = "Cannot parse entity %s\n";
        goto LABEL_18;
      case XML_INTERNAL_PARAMETER_ENTITY:
        name = entity->name;
        int v10 = "Internal parameter entity %s without content !\n";
        goto LABEL_18;
      case XML_INTERNAL_PREDEFINED_ENTITY:
        name = entity->name;
        int v10 = "Predefined entity %s without content !\n";
LABEL_18:
        ctxt = v2;
        break;
      default:
        return 0LL;
    }

    goto LABEL_19;
  }

  xmlParserInputPtr v6 = xmlNewInputStream(v2);
  if (v6)
  {
    URI = entity->URI;
    if (URI) {
      v6->filename = (const char *)xmlStrdup(URI);
    }
    content = entity->content;
    v6->unint64_t base = content;
    int length = entity->length;
    if (!length)
    {
      int length = xmlStrlen(content);
      entity->int length = length;
      content = entity->content;
    }

    v6->int length = length;
    v6->xmlNodePtr cur = content;
    v6->end = &content[length];
  }

  return v6;
}

xmlParserInputPtr xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer)
{
  if (buffer)
  {
    if (*__xmlParserDebugEntities())
    {
      xmlGenericErrorFunc v4 = *__xmlGenericError();
      xmlParserInputPtr v5 = __xmlGenericErrorContext();
      v4(*v5, "new fixed input: %.30s\n", (const char *)buffer);
    }

    xmlParserInputPtr v6 = xmlNewInputStream(ctxt);
    int v7 = v6;
    if (v6)
    {
      v6->unint64_t base = buffer;
      v6->xmlNodePtr cur = buffer;
      int v8 = xmlStrlen(buffer);
      v7->int length = v8;
      v7->end = &buffer[v8];
    }

    else
    {
      htmlErrMemory(ctxt, (uint64_t)"couldn't allocate a new input stream\n");
    }
  }

  else
  {
    xmlErrInternal(ctxt, (uint64_t)"xmlNewStringInputStream string = NULL\n", 0LL);
    return 0LL;
  }

  return v7;
}

xmlParserInputPtr xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename)
{
  if (*__xmlParserDebugEntities())
  {
    xmlGenericErrorFunc v4 = *__xmlGenericError();
    xmlParserInputPtr v5 = __xmlGenericErrorContext();
    v4(*v5, "new input from file: %s\n", filename);
  }

  if (!ctxt) {
    return 0LL;
  }
  xmlParserInputBufferPtr v6 = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
  if (!v6)
  {
    if (filename)
    {
      unsigned int v15 = "failed to load external entity %s\n";
      xmlParserCtxtPtr v16 = ctxt;
      size_t v17 = filename;
    }

    else
    {
      unsigned int v15 = "failed to load external entity: NULL filename \n";
      xmlParserCtxtPtr v16 = ctxt;
      size_t v17 = 0LL;
    }

    __xmlLoaderErr(v16, v15, (const xmlChar *)v17);
    return 0LL;
  }

  int v7 = v6;
  xmlParserInputPtr v8 = xmlNewInputStream(ctxt);
  if (!v8)
  {
    xmlFreeParserInputBuffer(v7);
    return 0LL;
  }

  v8->xmlParserInputBufferPtr buf = v7;
  xmlParserInputPtr v9 = xmlCheckHTTPInput(ctxt, v8);
  int v10 = v9;
  if (v9)
  {
    xmlChar v11 = v9->filename;
    if (!v11) {
      xmlChar v11 = filename;
    }
    xmlParserInputPtr v12 = xmlStrdup((const xmlChar *)v11);
    Directory = xmlParserGetDirectory((const char *)v12);
    char v14 = (char *)v10->filename;
    if (v14) {
      xmlFree(v14);
    }
    v10->filename = (const char *)xmlCanonicPath(v12);
    if (v12) {
      xmlFree(v12);
    }
    v10->directory = Directory;
    xmlBufResetInput((uint64_t *)v10->buf->buffer, v10);
    if (!ctxt->directory && Directory) {
      ctxt->directory = (char *)xmlStrdup((const xmlChar *)Directory);
    }
  }

  return v10;
}

int xmlInitParserCtxt(xmlParserCtxtPtr ctxt)
{
  if (!ctxt)
  {
    __xmlRaiseError(0LL, 0LL, 0LL, 0LL, 0LL, 1u, 1, 3, 0LL, 0, 0LL, 0LL, 0LL, 0, 0, "Got NULL parser context\n", 0);
    return -1;
  }

  xmlDefaultSAXHandlerInit();
  dict = ctxt->dict;
  if (!dict && (dict = xmlDictCreate(), (ctxt->dict = dict) == 0LL)
    || (xmlDictSetLimit(dict, 0x989680uLL), (dict = (xmlDict *)ctxt->sax) == 0LL)
    && (dict = (xmlDict *)xmlMalloc(0x100uLL), (ctxt->sax = (_xmlSAXHandler *)dict) == 0LL))
  {
    htmlErrMemory(dict, (uint64_t)"cannot initialize parser context\n");
    return -1;
  }

  xmlSAXVersion((xmlSAXHandler *)dict, 2);
  ctxt->int maxatts = 0;
  ctxt->atts = 0LL;
  if (!ctxt->inputTab)
  {
    char v3 = (xmlParserInputPtr *)xmlMalloc(0x28uLL);
    ctxt->inputTab = v3;
    ctxt->uint64_t inputMax = 5;
    if (!v3)
    {
      htmlErrMemory(0LL, (uint64_t)"cannot initialize parser context\n");
      ctxt->xmlParserInputPtr input = 0LL;
      *(void *)&ctxt->int inputNr = 0LL;
      return -1;
    }
  }

  while (1)
  {
    xmlGenericErrorFunc v4 = inputPop(ctxt);
    if (!v4) {
      break;
    }
    xmlFreeInputStream(v4);
  }

  ctxt->xmlParserInputPtr input = 0LL;
  p_xmlParserInputPtr input = &ctxt->input;
  ctxt->int inputNr = 0;
  ctxt->version = 0LL;
  ctxt->encoding = 0LL;
  *(void *)&ctxt->hasPErefs = 0LL;
  ctxt->hasExternalSubset = 0;
  *(void *)&ctxt->standalone = 0xFFFFFFFFLL;
  *(void *)&ctxt->xmlParserInputState instate = 0LL;
  ctxt->directory = 0LL;
  if (ctxt->nodeTab || (xmlParserInputBufferPtr v6 = (xmlNodePtr *)xmlMalloc(0x50uLL), ctxt->nodeTab = v6, ctxt->nodeMax = 10, v6))
  {
    ctxt->xmlNodePtr node = 0LL;
    p_xmlNodePtr node = &ctxt->node;
    ctxt->nodeNr = 0;
    if (ctxt->nameTab || (xmlParserInputPtr v8 = (const xmlChar **)xmlMalloc(0x50uLL), ctxt->nameTab = v8, ctxt->nameMax = 10, v8))
    {
      ctxt->int nameNr = 0;
      ctxt->name = 0LL;
      spaceTab = ctxt->spaceTab;
      if (spaceTab || (spaceTab = (int *)xmlMalloc(0x28uLL), ctxt->spaceTab = spaceTab, ctxt->spaceMax = 10, spaceTab))
      {
        *(void *)&ctxt->int spaceNr = 0xA00000001LL;
        int *spaceTab = -1;
        ctxt->space = spaceTab;
        ctxt->userData = ctxt;
        ctxt->xmlDocPtr myDoc = 0LL;
        ctxt->int wellFormed = 1;
        ctxt->nsWellFormed = 1;
        ctxt->int valid = 1;
        ExtDtdDefaultValue = __xmlLoadExtDtdDefaultValue();
        int v11 = *ExtDtdDefaultValue;
        ctxt->loadsubset = *ExtDtdDefaultValue;
        if (v11) {
          ctxt->options |= 4u;
        }
        ctxt->validate = *__xmlDoValidityCheckingDefaultValue();
        xmlParserInputPtr v12 = __xmlPedanticParserDefaultValue();
        int v13 = *v12;
        ctxt->pedantic = *v12;
        if (v13) {
          ctxt->options |= 0x80u;
        }
        ctxt->linenumbers = *__xmlLineNumbersDefaultValue();
        char v14 = __xmlKeepBlanksDefaultValue();
        int v15 = *v14;
        ctxt->keepBlanks = *v14;
        if (!v15)
        {
          ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
          ctxt->options |= 0x100u;
        }

        ctxt->vctxt.finishDtd = -1412623820;
        ctxt->vctxt.userData = ctxt;
        ctxt->vctxt.error = xmlParserValidityError;
        ctxt->vctxt.warning = xmlParserValidityWarning;
        if (ctxt->validate)
        {
          if (*__xmlGetWarningsDefaultValue()) {
            xmlParserCtxtPtr v16 = xmlParserValidityWarning;
          }
          else {
            xmlParserCtxtPtr v16 = 0LL;
          }
          ctxt->vctxt.warning = v16;
          ctxt->vctxt.uint64_t nodeMax = 0;
          ctxt->options |= 0x10u;
        }

        size_t v17 = __xmlSubstituteEntitiesDefaultValue();
        int v18 = *v17;
        ctxt->replaceEntities = *v17;
        if (v18) {
          ctxt->options |= 2u;
        }
        int result = 0;
        ctxt->record_xmlParserNodeInfo info = 0;
        ctxt->checkIndex = 0LL;
        ctxt->inSubset = 0;
        ctxt->int errNo = 0;
        ctxt->int depth = 0;
        *(_OWORD *)&ctxt->unint64_t nbentities = 0u;
        ctxt->charset = 1;
        ctxt->catalogs = 0LL;
        ctxt->sizeentcopy = 0LL;
        ctxt->input_int id = 1;
        ctxt->node_seq.int length = 0LL;
        ctxt->node_seq.buffer = 0LL;
        ctxt->node_seq.maximum = 0LL;
      }

      else
      {
        htmlErrMemory(0LL, (uint64_t)"cannot initialize parser context\n");
        *p_xmlParserInputPtr input = 0LL;
        *(void *)&ctxt->int inputNr = 0LL;
        *p_xmlNodePtr node = 0LL;
        *(void *)&ctxt->nodeNr = 0LL;
        ctxt->name = 0LL;
        *(void *)&ctxt->int nameNr = 0LL;
        int result = -1;
        ctxt->space = 0LL;
        *(void *)&ctxt->int spaceNr = 0LL;
      }
    }

    else
    {
      htmlErrMemory(0LL, (uint64_t)"cannot initialize parser context\n");
      *p_xmlParserInputPtr input = 0LL;
      *(void *)&ctxt->int inputNr = 0LL;
      *p_xmlNodePtr node = 0LL;
      *(void *)&ctxt->nodeNr = 0LL;
      int result = -1;
      ctxt->name = 0LL;
      *(void *)&ctxt->int nameNr = 0LL;
    }
  }

  else
  {
    htmlErrMemory(0LL, (uint64_t)"cannot initialize parser context\n");
    *p_xmlParserInputPtr input = 0LL;
    *(void *)&ctxt->int inputNr = 0LL;
    int result = -1;
    ctxt->xmlNodePtr node = 0LL;
    *(void *)&ctxt->nodeNr = 0LL;
  }

  return result;
}

void xmlInitNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
{
  if (seq)
  {
    seq->maximum = 0LL;
    seq->int length = 0LL;
    seq->buffer = 0LL;
  }

void xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    while (1)
    {
      unsigned int v2 = inputPop(ctxt);
      if (!v2) {
        break;
      }
      xmlFreeInputStream(v2);
    }

    spaceTab = ctxt->spaceTab;
    if (spaceTab) {
      xmlFree(spaceTab);
    }
    nameTab = ctxt->nameTab;
    if (nameTab) {
      xmlFree(nameTab);
    }
    nodeTab = ctxt->nodeTab;
    if (nodeTab) {
      xmlFree(nodeTab);
    }
    nodeInfoTab = ctxt->nodeInfoTab;
    if (nodeInfoTab) {
      xmlFree(nodeInfoTab);
    }
    inputTab = ctxt->inputTab;
    if (inputTab) {
      xmlFree(inputTab);
    }
    version = (xmlChar *)ctxt->version;
    if (version) {
      xmlFree(version);
    }
    encoding = (xmlChar *)ctxt->encoding;
    if (encoding) {
      xmlFree(encoding);
    }
    extSubURI = ctxt->extSubURI;
    if (extSubURI) {
      xmlFree(extSubURI);
    }
    extSubSystem = ctxt->extSubSystem;
    if (extSubSystem) {
      xmlFree(extSubSystem);
    }
    if (ctxt->sax)
    {
      sax = ctxt->sax;
      if (sax != (_xmlSAXHandler *)__xmlDefaultSAXHandler()) {
        xmlFree(ctxt->sax);
      }
    }

    directory = ctxt->directory;
    if (directory) {
      xmlFree(directory);
    }
    char v14 = ctxt->vctxt.nodeTab;
    if (v14) {
      xmlFree(v14);
    }
    atts = ctxt->atts;
    if (atts) {
      xmlFree(atts);
    }
    dict = ctxt->dict;
    if (dict) {
      xmlDictFree(dict);
    }
    nsTab = ctxt->nsTab;
    if (nsTab) {
      xmlFree(nsTab);
    }
    pushTab = ctxt->pushTab;
    if (pushTab) {
      xmlFree(pushTab);
    }
    attallocs = ctxt->attallocs;
    if (attallocs) {
      xmlFree(attallocs);
    }
    attsDefault = ctxt->attsDefault;
    if (attsDefault) {
      xmlHashFree(attsDefault, (xmlHashDeallocator)xmlHashDefaultDeallocator);
    }
    attsSpecial = ctxt->attsSpecial;
    if (attsSpecial) {
      xmlHashFree(attsSpecial, 0LL);
    }
    xmlNodePtr freeElems = ctxt->freeElems;
    if (freeElems)
    {
      do
      {
        next = freeElems->next;
        xmlFree(freeElems);
        xmlNodePtr freeElems = next;
      }

      while (next);
    }

    xmlAttrPtr freeAttrs = ctxt->freeAttrs;
    if (freeAttrs)
    {
      do
      {
        uint64_t v25 = freeAttrs->next;
        xmlFree(freeAttrs);
        xmlAttrPtr freeAttrs = v25;
      }

      while (v25);
    }

    message = ctxt->lastError.message;
    if (message) {
      xmlFree(message);
    }
    file = ctxt->lastError.file;
    if (file) {
      xmlFree(file);
    }
    str1 = ctxt->lastError.str1;
    if (str1) {
      xmlFree(str1);
    }
    str2 = ctxt->lastError.str2;
    if (str2) {
      xmlFree(str2);
    }
    str3 = ctxt->lastError.str3;
    if (str3) {
      xmlFree(str3);
    }
    catalogs = ctxt->catalogs;
    if (catalogs) {
      xmlCatalogFreeLocal(catalogs);
    }
    xmlFree(ctxt);
  }

xmlParserCtxtPtr xmlNewParserCtxt(void)
{
  int v0 = (xmlParserCtxt *)xmlMalloc(0x2F0uLL);
  int v1 = v0;
  if (v0)
  {
    bzero(v0, 0x2F0uLL);
    if (xmlInitParserCtxt(v1) < 0)
    {
      xmlFreeParserCtxt(v1);
      return 0LL;
    }
  }

  else
  {
    htmlErrMemory(0LL, (uint64_t)"cannot allocate parser context\n");
  }

  return v1;
}

void xmlClearParserCtxt(xmlParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    p_node_seq = &ctxt->node_seq;
    buffer = ctxt->node_seq.buffer;
    if (buffer) {
      xmlFree(buffer);
    }
    p_node_seq->maximum = 0LL;
    p_node_seq->int length = 0LL;
    p_node_seq->buffer = 0LL;
    xmlCtxtReset(ctxt);
  }

void xmlClearNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
{
  if (seq)
  {
    buffer = seq->buffer;
    if (buffer) {
      xmlFree(buffer);
    }
    seq->maximum = 0LL;
    seq->int length = 0LL;
    seq->buffer = 0LL;
  }

const xmlParserNodeInfo *__cdecl xmlParserFindNodeInfo(const xmlParserCtxtPtr ctxt, const xmlNodePtr node)
{
  int result = 0LL;
  if (ctxt)
  {
    if (node)
    {
      unint64_t NodeInfoIndex = xmlParserFindNodeInfoIndex(&ctxt->node_seq, node);
      if (NodeInfoIndex >= ctxt->node_seq.length) {
        return 0LL;
      }
      int result = &ctxt->node_seq.buffer[NodeInfoIndex];
      if (result->node != node) {
        return 0LL;
      }
    }
  }

  return result;
}

unint64_t xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq, const xmlNodePtr node)
{
  unint64_t length = -1LL;
  if (seq)
  {
    if (node)
    {
      unint64_t length = seq->length;
      if (length)
      {
        unint64_t v3 = 1LL;
        do
        {
          unint64_t v4 = v3 + ((length - v3) >> 1);
          xmlParserInputPtr v5 = seq->buffer[v4 - 1].node;
          if (v5 > node) {
            unint64_t length = v4 - 1;
          }
          if (v5 < node) {
            unint64_t v3 = v4 + 1;
          }
        }

        while (v3 <= length && v5 != node);
        if (v4)
        {
          if (seq->buffer[v4 - 1].node >= node) {
            return v4 - 1;
          }
          else {
            return v4;
          }
        }

        else
        {
          return 0LL;
        }
      }
    }
  }

  return length;
}

void xmlParserAddNodeInfo(xmlParserCtxtPtr ctxt, const xmlParserNodeInfoPtr info)
{
  if (!ctxt || !info) {
    return;
  }
  p_node_seq = &ctxt->node_seq;
  xmlNodePtr node = info->node;
  unint64_t NodeInfoIndex = xmlParserFindNodeInfoIndex(&ctxt->node_seq, (const xmlNodePtr)info->node);
  unint64_t v7 = NodeInfoIndex;
  unint64_t length = ctxt->node_seq.length;
  if (NodeInfoIndex < length)
  {
    buffer = ctxt->node_seq.buffer;
    if (buffer)
    {
      int v10 = &buffer[NodeInfoIndex];
      if (v10->node == node)
      {
        __int128 v20 = *(_OWORD *)&info->node;
        __int128 v21 = *(_OWORD *)&info->begin_line;
        v10->end_int line = info->end_line;
        *(_OWORD *)&v10->xmlNodePtr node = v20;
        *(_OWORD *)&v10->begin_int line = v21;
        return;
      }
    }
  }

  unint64_t maximum = p_node_seq->maximum;
  if (length + 1 > p_node_seq->maximum || (xmlParserInputPtr v12 = ctxt->node_seq.buffer) == 0LL)
  {
    if (!maximum)
    {
      LODWORD(maximum) = 2;
      p_node_seq->unint64_t maximum = 2LL;
    }

    int v13 = ctxt->node_seq.buffer;
    if (v13)
    {
      xmlParserInputPtr v12 = (xmlParserNodeInfo *)xmlRealloc(v13, (80 * maximum));
      if (v12)
      {
LABEL_12:
        ctxt->node_seq.buffer = v12;
        unint64_t length = ctxt->node_seq.length;
        ctxt->node_seq.maximum *= 2LL;
        goto LABEL_13;
      }
    }

    else
    {
      xmlParserInputPtr v12 = (xmlParserNodeInfo *)xmlMalloc((80 * maximum));
      if (v12) {
        goto LABEL_12;
      }
    }

    htmlErrMemory(ctxt, (uint64_t)"failed to allocate buffer\n");
    return;
  }

int xmlPedanticParserDefault(int val)
{
  int v2 = *__xmlPedanticParserDefaultValue();
  *__xmlPedanticParserDefaultValue() = val;
  return v2;
}

int xmlLineNumbersDefault(int val)
{
  int v2 = *__xmlLineNumbersDefaultValue();
  *__xmlLineNumbersDefaultValue() = val;
  return v2;
}

int xmlSubstituteEntitiesDefault(int val)
{
  int v2 = *__xmlSubstituteEntitiesDefaultValue();
  *__xmlSubstituteEntitiesDefaultValue() = val;
  return v2;
}

int xmlKeepBlanksDefault(int val)
{
  int v2 = *__xmlKeepBlanksDefaultValue();
  *__xmlKeepBlanksDefaultValue() = val;
  if (!val) {
    *__xmlIndentTreeOutput() = 1;
  }
  return v2;
}

void xmlFreePatternList(xmlPatternPtr comp)
{
  if (comp)
  {
    xmlPatternPtr v1 = comp;
    do
    {
      int v2 = (xmlPattern *)*((void *)v1 + 2);
      *((void *)v1 + 2) = 0LL;
      uint64_t v3 = *((void *)v1 + 7);
      if (v3) {
        xmlFreeStreamComp(v3);
      }
      unint64_t v4 = (void *)*((void *)v1 + 3);
      if (v4) {
        xmlFree(v4);
      }
      xmlParserInputPtr v5 = (void *)*((void *)v1 + 6);
      if (v5)
      {
        if (!*((void *)v1 + 1) && *((int *)v1 + 9) >= 1)
        {
          uint64_t v6 = 0LL;
          uint64_t v7 = 0LL;
          do
          {
            uint64_t v8 = *((void *)v1 + 6) + v6;
            xmlParserInputPtr v9 = *(void **)(v8 + 8);
            if (v9) {
              xmlFree(v9);
            }
            int v10 = *(void **)(v8 + 16);
            if (v10) {
              xmlFree(v10);
            }
            ++v7;
            v6 += 24LL;
          }

          while (v7 < *((int *)v1 + 9));
          xmlParserInputPtr v5 = (void *)*((void *)v1 + 6);
        }

        xmlFree(v5);
      }

      int v11 = (xmlDict *)*((void *)v1 + 1);
      if (v11) {
        xmlDictFree(v11);
      }
      *(void *)&__int128 v12 = -1LL;
      *((void *)&v12 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = -1LL;
      *((_OWORD *)v1 + 2) = v12;
      *((_OWORD *)v1 + 3) = v12;
      *(_OWORD *)xmlPatternPtr v1 = v12;
      *((_OWORD *)v1 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v12;
      xmlFree(v1);
      xmlPatternPtr v1 = v2;
    }

    while (v2);
  }

void xmlFreeStreamCtxt(xmlStreamCtxtPtr stream)
{
  if (stream)
  {
    xmlStreamCtxtPtr v1 = stream;
    do
    {
      int v2 = *(xmlStreamCtxt **)v1;
      uint64_t v3 = (void *)*((void *)v1 + 4);
      if (v3) {
        xmlFree(v3);
      }
      xmlFree(v1);
      xmlStreamCtxtPtr v1 = v2;
    }

    while (v2);
  }

int xmlStreamPush(xmlStreamCtxtPtr stream, const xmlChar *name, const xmlChar *ns)
{
  return xmlStreamPushInternal((uint64_t)stream, (xmlChar *)name, (xmlChar *)ns, 1);
}

uint64_t xmlStreamPushInternal(uint64_t a1, xmlChar *a2, xmlChar *a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a1;
  uint64_t v5 = 0xFFFFFFFFLL;
  if ((*(_DWORD *)(a1 + 16) & 0x80000000) == 0)
  {
    uint64_t v7 = a3;
    uint64_t v8 = a2;
    int v9 = 0;
    uint64_t v10 = 0LL;
    if (a2) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = a4 == 1;
    }
    int v13 = v11 && a3 == 0LL;
    unsigned int v64 = a4 - 3;
    while (1)
    {
      uint64_t v14 = 0LL;
      uint64_t v15 = v10;
      uint64_t v16 = v4;
      while (1)
      {
        uint64_t v17 = *(void *)(v16 + 8);
        if (v13) {
          break;
        }
        if (*(_DWORD *)(v17 + 8))
        {
          if (*(_DWORD *)(v16 + 44) != -1 || v64 <= 0xFFFFFFFD && (*(_BYTE *)(v17 + 25) & 0x40) == 0)
          {
LABEL_79:
            ++*(_DWORD *)(v16 + 24);
            goto LABEL_17;
          }

          unsigned int v60 = v10;
          int v61 = v9;
          str2 = v8;
          int v63 = v7;
          int v19 = *(_DWORD *)(v16 + 16);
          if (v19 >= 1)
          {
            int v20 = 0;
            int v21 = *(_DWORD *)(v17 + 24);
            do
            {
              uint64_t v22 = *(void *)(v16 + 32);
              if ((v21 & 0x10000) != 0)
              {
                uint64_t v25 = *(unsigned int *)(v22 + 8LL * v20);
                if ((v25 & 0x80000000) != 0) {
                  goto LABEL_67;
                }
                int v34 = *(_DWORD *)(v22 + ((8LL * v20) | 4));
                int v24 = *(_DWORD *)(v16 + 24);
                if (v34 > v24) {
                  goto LABEL_67;
                }
                uint64_t v26 = *(void *)(v17 + 16);
                if (v34 < v24 && (*(_DWORD *)(v26 + 32 * v25) & 1) == 0) {
                  goto LABEL_67;
                }
              }

              else
              {
                int v23 = 2 * *(_DWORD *)(v16 + 16);
                int v24 = *(_DWORD *)(v16 + 24);
                if (*(_DWORD *)(v22 + 4LL * (v23 - 1)) < v24) {
                  return 0xFFFFFFFFLL;
                }
                LODWORD(v25) = *(_DWORD *)(v22 + 4LL * (v23 - 2));
                uint64_t v26 = *(void *)(v17 + 16);
                int v20 = v19;
              }

              __int128 v27 = (int *)(v26 + 32LL * (int)v25);
              unsigned int v28 = *v27;
              int v29 = v27[6];
              if (v29 == a4)
              {
                if (a4 != 100)
                {
                  unsigned int v30 = (const xmlChar *)*((void *)v27 + 1);
                  uint64_t v31 = (const xmlChar *)*((void *)v27 + 2);
                  if (v30)
                  {
                    int v32 = 1;
                    if (!str2 || (v63 != 0LL) == (v31 == 0LL)) {
                      goto LABEL_60;
                    }
                    if (*v30 != *str2) {
                      goto LABEL_59;
                    }
                    unsigned int v56 = v14;
                    unsigned int v57 = v15;
                    if (!xmlStrEqual(v30, str2))
                    {
                      int v32 = 1;
                      uint64_t v14 = v56;
                      uint64_t v15 = v57;
                      goto LABEL_60;
                    }

                    LODWORD(v15) = v57;
                    if (v31 != v63)
                    {
                      int v33 = xmlStrEqual(v31, v63);
                      uint64_t v14 = v56;
                      uint64_t v15 = v57;
                      if (!v33) {
                        goto LABEL_59;
                      }
                    }
                  }

                  else if (v31)
                  {
                    if (!v63) {
                      goto LABEL_59;
                    }
                    unsigned int v58 = v15;
                    uint64_t v36 = v14;
                    int v37 = xmlStrEqual(*((const xmlChar **)v27 + 2), v63);
                    uint64_t v15 = v58;
                    if (!v37)
                    {
                      uint64_t v14 = v36;
LABEL_59:
                      int v32 = 1;
                      goto LABEL_60;
                    }
                  }
                }
              }

              else if (v29 != 100)
              {
                if (v29 != 2 || (v21 & 0x10000) != 0) {
                  goto LABEL_67;
                }
LABEL_65:
                *(_DWORD *)(v16 + 44) = v24 + 1;
                goto LABEL_67;
              }

              if ((v28 & 2) != 0)
              {
                int v32 = 0;
                uint64_t v14 = v28 & 2;
                uint64_t v15 = 1LL;
              }

              else
              {
                int v38 = v25 + 1;
                int v39 = v15;
                xmlStreamCtxtAddState(v16, v38, *(_DWORD *)(v16 + 24) + 1);
                int v32 = 0;
                if (v39 == 1) {
                  uint64_t v15 = 1LL;
                }
                else {
                  uint64_t v15 = (v28 >> 5) & 1;
                }
                uint64_t v14 = 0LL;
              }

LABEL_94:
                uint64_t v14 = v42 & 2;
                if ((v42 & 2) != 0)
                {
LABEL_95:
                  int v50 = 0;
                  uint64_t v15 = 1LL;
                  goto LABEL_106;
                }

        xmlRngPErr( a1,  *((void *)v6 + 1),  1087,  "Found forbidden pattern oneOrMore//interleave//attribute\n",  0LL,  0LL);
        if ((a3 & 8) == 0)
        {
LABEL_57:
          if ((a3 & 0x10) == 0) {
            goto LABEL_58;
          }
          goto LABEL_96;
        }

                xmlFree(v18);
                int v46 = *(void *)(v3 + 96);
                *(void *)(v46 + 32) = v5;
                *(void *)(v46 + 40) = v17;
                return v14;
              }

        xmlURIPtr v67 = (void (*)(void, void, void, uint64_t))*((void *)a1 + 2);
        if (v67) {
          uint64_t v68 = v22 == 0;
        }
        else {
          uint64_t v68 = 1;
        }
        xmlGenericErrorFunc v69 = v68 || v8 == 0;
        uint64_t v70 = v11;
        if (!v69)
        {
          int v71 = v25;
          int v72 = v21;
          v67(*((void *)a1 + 3), *(void *)(v22 + 24), *(void *)(v22 + 88), v8);
          int v21 = v72;
          uint64_t v25 = v71;
        }

        if (*(_DWORD *)(*((void *)a1 + 4) + 24LL) > (signed int)(a1[10] + 1))
        {
          int v73 = v21;
          xmlCharEncoding v74 = v25;
          xmlFARegExecSave((uint64_t)a1);
          uint64_t v25 = v74;
          int v21 = v73;
        }

        int v75 = *(unsigned int *)(v17 + 24LL * v21 + 12);
        if ((v75 & 0x80000000) == 0) {
          ++*(_DWORD *)(*((void *)a1 + 8) + 4 * v75);
        }
        uint64_t v76 = *v25;
        int v77 = *(_DWORD **)(*(void *)(*((void *)a1 + 1) + 16LL) + 8LL * *v19);
        if (v77 && *v77 == 4)
        {
          int v78 = (void *)*((void *)a1 + 16);
          if (v78) {
            xmlFree(v78);
          }
          int v79 = xmlStrdup(v70);
          *((void *)a1 + 15) = *((void *)a1 + 4);
          *((void *)a1 + 16) = v79;
          memcpy(*((void **)a1 + 17), *((const void **)a1 + 8), 4LL * *(int *)(*((void *)a1 + 1) + 40LL));
          int v77 = *(_DWORD **)(*(void *)(*((void *)a1 + 1) + 16LL) + 8LL * *v19);
        }

        *((void *)a1 + 4) = v77;
        a1[10] = 0;
        if (!*(void *)v18)
        {
          __int128 v12 = 1LL;
          goto LABEL_141;
        }

        uint64_t v80 = *((void *)a1 + 13);
        if (v80)
        {
          uint64_t v81 = a1[19];
          uint64_t v82 = (int)a1[20] + 1LL;
          a1[20] = v82;
          if ((int)v82 < v81)
          {
            int v83 = (xmlChar **)(v80 + 16 * v82);
            int v84 = (uint64_t *)(v83 + 1);
            __int128 v12 = 1LL;
            goto LABEL_140;
          }
        }

        uint64_t v8 = 0LL;
        BOOL v11 = 0LL;
        __int128 v12 = 1LL;
        goto LABEL_142;
      }

      if ((_DWORD)v24 == 1193046)
      {
        __int128 v27 = v21;
        unsigned int v28 = (unsigned int *)(v17 + 12);
        while (1)
        {
          unsigned int v30 = *v28;
          v28 += 6;
          int v29 = v30;
          if (v27)
          {
            if ((v29 & 0x80000000) == 0)
            {
              uint64_t v31 = *(void *)(*((void *)a1 + 1) + 48LL);
              int v32 = *(_DWORD *)(*((void *)a1 + 8) + 4 * v29);
              if (v32 < *(_DWORD *)(v31 + 8 * v29) || v32 > *(_DWORD *)(v31 + 8 * v29 + 4)) {
                goto LABEL_86;
              }
            }
          }

          --v27;
          if (!--v16) {
            goto LABEL_94;
          }
        }
      }

      if ((v24 & 0x80000000) != 0) {
        break;
      }
      size_t v43 = *(_DWORD *)(*((void *)a1 + 8) + 4 * v24);
      uint64_t v44 = *(void *)(*((void *)a1 + 1) + 48LL);
      int v45 = v43 >= *(_DWORD *)(v44 + 8 * v24) && v43 <= *(_DWORD *)(v44 + 8 * v24 + 4);
LABEL_85:
      if (v45 == 1) {
        goto LABEL_94;
      }
LABEL_86:
      uint64_t v15 = a1[10] + 1;
      a1[10] = v15;
      int v13 = (int *)*((void *)a1 + 4);
      uint64_t v16 = v13[6];
    }

    if (!v22)
    {
      uint64_t v85 = v11;
      fwrite("epsilon transition left at runtime\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      BOOL v11 = v85;
      *a1 = -2;
      if (a1[10]) {
        goto LABEL_88;
      }
LABEL_122:
      __int128 v12 = v100;
      if (*(_DWORD *)(*((void *)a1 + 4) + 24LL)) {
        goto LABEL_142;
      }
      if (!(_DWORD)v100) {
        goto LABEL_136;
      }
LABEL_124:
      int v86 = (_DWORD *)*((void *)a1 + 4);
      if (v86)
      {
        uint64_t v70 = v11;
        if (*v86 != 4)
        {
          int v87 = (void *)*((void *)a1 + 16);
          if (v87) {
            xmlFree(v87);
          }
          int v88 = xmlStrdup(v70);
          *((void *)a1 + 15) = *((void *)a1 + 4);
          *((void *)a1 + 16) = v88;
          uint64_t v89 = *(int *)(*((void *)a1 + 1) + 40LL);
          if ((_DWORD)v89) {
            memcpy(*((void **)a1 + 17), *((const void **)a1 + 8), 4 * v89);
          }
          __int128 v12 = 0LL;
          goto LABEL_137;
        }
      }

      else
      {
        uint64_t v70 = v11;
      }

      __int128 v12 = 1LL;
      goto LABEL_137;
    }

    if (!v11) {
      goto LABEL_86;
    }
    uint64_t v97 = v21;
    uint64_t v99 = v25;
    int v46 = *(void *)v18;
    uint64_t v47 = v11;
    int v48 = xmlRegStrEqualWildcard(*(_BYTE **)(v22 + 24), v11);
    int v49 = a4;
    int v50 = v46;
    int v51 = *(_DWORD *)(v46 + 40);
    int v52 = v48 ^ 1;
    int v53 = v49;
    if (!(_DWORD)v49) {
      int v52 = 0;
    }
    if (v51) {
      uint64_t v54 = v52;
    }
    else {
      uint64_t v54 = v48;
    }
    if (!v54
      || (int v21 = v97, v25 = v99, v55 = *(unsigned int *)(v17 + 24LL * v97 + 12), (v55 & 0x80000000) == 0)
      && *(_DWORD *)(*((void *)a1 + 8) + 4 * v55) >= *(_DWORD *)(*(void *)(*((void *)a1 + 1) + 48LL) + 8 * v55 + 4))
    {
      BOOL v11 = v47;
      a4 = v49;
      goto LABEL_86;
    }

    uint64_t v22 = v50;
    if (*(int *)(v50 + 12) < 1)
    {
      BOOL v11 = v47;
LABEL_134:
      int v19 = (int *)(v18 + 2);
      a4 = v49;
      goto LABEL_94;
    }

    unsigned int v56 = *(_DWORD *)(v50 + 16);
    BOOL v11 = v47;
    if (v56 < 1) {
      goto LABEL_134;
    }
    uint64_t v95 = *(void *)(*(void *)(*((void *)a1 + 1) + 16LL) + 8 * v20);
    if ((int)v16 > v97 + 1)
    {
      xmlFARegExecSave((uint64_t)a1);
      unsigned int v56 = *(_DWORD *)(v50 + 16);
      BOOL v11 = v47;
    }

    unsigned int v57 = 1;
    a1[11] = 1;
    unsigned int v58 = 1;
    int v19 = (int *)(v18 + 2);
    if (v56 != 1)
    {
      while (1)
      {
        unsigned int v59 = a1[20];
        a1[20] = v59 + 1;
        unsigned int v60 = *((void *)a1 + 13) + 16LL * (int)(v59 + 1);
        int v61 = *(const xmlChar **)v60;
        uint64_t v8 = *(void *)(v60 + 8);
        if (!*(void *)v60) {
          break;
        }
        if (v57 >= *(_DWORD *)(v50 + 12))
        {
          uint64_t v62 = *(xmlChar **)v60;
          int v63 = a1[10];
          unsigned int v64 = *((void *)a1 + 4);
          a1[10] = -1;
          *((void *)a1 + 4) = v95;
          xmlFARegExecSave((uint64_t)a1);
          a1[10] = v63;
          *((void *)a1 + 4) = v64;
          int v61 = v62;
          int v19 = (int *)(v18 + 2);
        }

        uint64_t v65 = (xmlChar *)v61;
        unsigned int v58 = xmlStrEqual(v61, *(const xmlChar **)(v50 + 24));
        unsigned int v57 = a1[11] + 1;
        a1[11] = v57;
        if (v58 != 1) {
          goto LABEL_76;
        }
        if (v57 == *(_DWORD *)(v50 + 16))
        {
          unsigned int v58 = 1;
LABEL_76:
          BOOL v11 = v65;
          goto LABEL_80;
        }
      }

      BOOL v11 = 0LL;
      a1[20] = v59;
      unsigned int v58 = 1;
    }

              int v77 = (xmlNode *)v36;
LABEL_95:
              int v78 = v34;
              if (v67)
              {
                int v51 = v70;
                if (!xmlXPtrAdvanceChar((uint64_t *)&v77, &v78, v65))
                {
                  if (v64)
                  {
                    int v75 = v77;
                    uint64_t v76 = v78 - 1;
                    if (!xmlXPtrAdvanceChar((uint64_t *)&v75, &v76, v63))
                    {
                      int v52 = v77;
                      int v53 = v78;
                      uint64_t v54 = v75;
                      BOOL v55 = v76;
                      goto LABEL_108;
                    }
                  }

                  else
                  {
                    int v52 = v77;
                    int v53 = v78;
                    if (v62)
                    {
                      uint64_t v54 = v77;
                      BOOL v55 = v78;
                    }

                    else
                    {
                      uint64_t v54 = (xmlNode *)v33;
                      BOOL v55 = v47;
                    }

LABEL_102:
                int v52 = v15;
                xmlStreamCtxtAddState(v16, 1, *(_DWORD *)(v16 + 24));
                int v50 = 0;
                uint64_t v14 = 0LL;
                if (v52 == 1) {
                  uint64_t v15 = 1LL;
                }
                else {
                  uint64_t v15 = (v42 >> 5) & 1;
                }
LABEL_106:
                uint64_t v10 = v60;
                int v9 = v61;
                uint64_t v8 = str2;
              }

              else
              {
                if (!v44) {
                  goto LABEL_94;
                }
                if (!v63) {
                  goto LABEL_105;
                }
                unsigned int v59 = v15;
                int v51 = xmlStrEqual(v44, v63);
                uint64_t v14 = v42 & 2;
                if (v51)
                {
                  LODWORD(v15) = v59;
                  if ((v42 & 2) != 0) {
                    goto LABEL_95;
                  }
                  goto LABEL_102;
                }

                int v50 = 1;
                uint64_t v10 = v60;
                int v9 = v61;
                uint64_t v8 = str2;
                uint64_t v15 = v59;
              }

              if ((*(_BYTE *)(v17 + 26) & 1) == 0)
              {
                if ((((_DWORD)v14 == 0) & ~v50) != 0) {
                  uint64_t v14 = 0LL;
                }
                else {
                  *(_DWORD *)(v16 + 44) = *(_DWORD *)(v16 + 24);
                }
              }

              goto LABEL_17;
            }

            if (a4 != 2 && v45 == 100) {
              goto LABEL_94;
            }
LABEL_96:
            int v9 = v61;
          }

          uint64_t v8 = str2;
          uint64_t v10 = v60;
          goto LABEL_17;
        }

        int v18 = *(_DWORD *)(v16 + 40);
        if ((v18 & 1) == 0)
        {
          if (a4 != 2 && ((v18 & 7) == 0 || !*(_DWORD *)(v16 + 24))) {
            uint64_t v15 = 1LL;
          }
          goto LABEL_79;
        }

    if (v10) {
      xmlFree(v10);
    }
LABEL_104:
    int v13 = prefix;
    if (!prefix) {
      return;
    }
    goto LABEL_105;
  }

  if (*prefix != 120 || prefix[1] != 109 || prefix[2] != 108 || prefix[3] != 110 || prefix[4] != 115 || prefix[5]) {
    goto LABEL_62;
  }
  int v13 = a3;
  if (*((_DWORD *)ctxt + 7)
    || (++*((_DWORD *)ctxt + 98),
        int v13 = xmlStringDecodeEntities((xmlParserCtxtPtr)ctxt, a3, 1, 0, 0, 0),
        --*((_DWORD *)ctxt + 98),
        v13))
  {
    if (!*v13) {
      xmlNsErrMsg(ctxt, 204, (uint64_t)"Empty namespace name for prefix %s\n", (uint64_t)v8, 0LL);
    }
    if (*((_DWORD *)ctxt + 105) && *v13)
    {
      int v18 = xmlParseURI((const char *)v13);
      if (v18)
      {
        int v19 = v18;
        if (!v18->scheme) {
          xmlNsWarnMsg(ctxt, 100, (uint64_t)"xmlns:%s: URI %s is not absolute\n", (uint64_t)v8, a3);
        }
        xmlFreeURI(v19);
      }

      else
      {
        xmlNsWarnMsg(ctxt, 99, (uint64_t)"xmlns:%s: %s not a valid URI\n", (uint64_t)v8, a3);
      }
    }

    char v35 = xmlNewNs((xmlNodePtr)ctxt[10], v13, v8);
    xmlFree(prefix);
    if (v35)
    {
      if (*((_DWORD *)ctxt + 39))
      {
        if (*((_DWORD *)ctxt + 6))
        {
          uint64_t v36 = (xmlDocPtr)ctxt[2];
          if (v36)
          {
            if (v36->intSubset) {
              *((_DWORD *)ctxt + 38) &= xmlValidateOneNamespace( (xmlValidCtxtPtr)(ctxt + 20),  v36,  (xmlNodePtr)ctxt[10],  a4,  v35,  a3);
            }
          }
        }
      }
    }

    xmlFree(v8);
    if (v10) {
      goto LABEL_132;
    }
    goto LABEL_133;
  }

  xmlSAX2ErrMemory(ctxt, (uint64_t)"xmlSAX2StartElement");
  xmlFree(prefix);
  ((void (*)(xmlChar *))xmlFree)(v8);
LABEL_122:
  int v13 = v10;
  if (v10) {
LABEL_105:
  }
    xmlFree(v13);
}

            v7->path[v32] = 0;
            xmlNormalizeURIPath(v7->path);
            goto LABEL_53;
          }

          if (v8->scheme) {
            v11->scheme = xmlMemStrdup(v8->scheme);
          }
          int v23 = v8->authority;
          if (v23)
          {
            v7->authority = xmlMemStrdup(v23);
LABEL_107:
            unsigned int v42 = v8->path;
            if (v42) {
              v7->path = xmlMemStrdup(v42);
            }
            size_t v43 = v6->query_raw;
            if (v43) {
              goto LABEL_110;
            }
            uint64_t v44 = v6->query;
            if (v44) {
              goto LABEL_112;
            }
            size_t v43 = v8->query_raw;
            if (v43)
            {
LABEL_110:
              v7->query_uint64_t raw = xmlMemStrdup(v43);
              goto LABEL_113;
            }

            uint64_t v44 = v8->query;
            if (v44) {
LABEL_112:
            }
              v7->query = xmlMemStrdup(v44);
LABEL_113:
            int v45 = v6->fragment;
            if (v45) {
              v7->fragment = xmlMemStrdup(v45);
            }
            goto LABEL_53;
          }

          uint64_t v26 = v8->server;
          if (v26)
          {
            v7->server = xmlMemStrdup(v26);
          }

          else if (v8->port != -1)
          {
            goto LABEL_107;
          }

          __int128 v27 = v8->user;
          if (v27) {
            v7->user = xmlMemStrdup(v27);
          }
          v7->int port = v8->port;
          goto LABEL_107;
        }

        goto LABEL_21;
      }

      uint64_t v14 = v8->fragment;
      if (v14)
      {
        xmlFree(v14);
        v8->fragment = 0LL;
      }

      int v9 = xmlSaveUri(v8);
      uint64_t v7 = 0LL;
LABEL_25:
      xmlFreeURI(v8);
      goto LABEL_26;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  if (v4)
  {
    int v9 = xmlSaveUri(v6);
    goto LABEL_22;
  }

  uint64_t v7 = 0LL;
  int v9 = 0LL;
  if (v8) {
    goto LABEL_25;
  }
LABEL_26:
  if (v7) {
    xmlFreeURI(v7);
  }
  return v9;
}

LABEL_121:
      uint64_t v4 = *(void *)v4;
      if (!v4) {
        goto LABEL_124;
      }
    }
  }

  return v5;
}

        if (v41)
        {
          if (xmlSchemaXPathProcessHistory(a1, *(_DWORD *)(a1 + 172) + 1) == -1)
          {
LABEL_151:
            uint64_t v82 = "calling xmlSchemaXPathEvaluate()";
            goto LABEL_152;
          }

          goto LABEL_127;
        }

int xmlStreamPushAttr(xmlStreamCtxtPtr stream, const xmlChar *name, const xmlChar *ns)
{
  return xmlStreamPushInternal((uint64_t)stream, (xmlChar *)name, (xmlChar *)ns, 2);
}

int xmlStreamPop(xmlStreamCtxtPtr stream)
{
  int result = -1;
  if (stream)
  {
    do
    {
      int v3 = *((_DWORD *)stream + 6);
      if (*((_DWORD *)stream + 11) == v3) {
        *((_DWORD *)stream + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = -1;
      }
      if (v3) {
        *((_DWORD *)stream + 6) = --v3;
      }
      uint64_t v4 = *((unsigned int *)stream + 4);
      if ((int)v4 >= 1)
      {
        uint64_t v5 = *((void *)stream + 4);
        int v6 = v4 - 1;
        unint64_t v7 = v4 + 1;
        int v8 = 2 * v4 - 2;
        do
        {
          if (*(_DWORD *)(v5 + 4LL * (v8 & 0xFFFFFFFE) + 4) <= v3) {
            break;
          }
          *((_DWORD *)stream + 4) = v6--;
          --v7;
          v8 -= 2;
        }

        while (v7 > 1);
      }

      stream = *(xmlStreamCtxtPtr *)stream;
    }

    while (stream);
    return 0;
  }

  return result;
}

int xmlStreamWantsAnyNode(xmlStreamCtxtPtr stream)
{
  if (stream)
  {
    while ((*(_BYTE *)(*((void *)stream + 1) + 25LL) & 0x40) == 0)
    {
      stream = *(xmlStreamCtxtPtr *)stream;
      if (!stream) {
        return (int)stream;
      }
    }

    LODWORD(stream) = 1;
  }

  else
  {
    LODWORD(stream) = -1;
  }

  return (int)stream;
}

xmlPatternPtr xmlPatterncompile(const xmlChar *pattern, xmlDict *dict, int flags, const xmlChar **namespaces)
{
  if (!pattern) {
    return 0LL;
  }
  uint64_t v4 = (xmlChar *)pattern;
  unsigned int v5 = *pattern;
  if (!*pattern) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  int v97 = flags & 6;
  int v98 = 0;
  int v95 = flags | 0x100;
  int v96 = flags | 0x200;
  int v94 = flags & 7;
  BOOL v101 = 1;
  do
  {
    uint64_t v8 = 0LL;
    int v9 = v7;
    if (v5)
    {
      while (v5 != 124)
      {
        unsigned int v5 = v4[++v8];
        if (!v5) {
          goto LABEL_7;
        }
      }

      __int128 v12 = xmlStrndup(v4, v8);
      BOOL v11 = v12;
      if (v12) {
        uint64_t v10 = xmlNewPatParserContext(v12, (uint64_t)dict, (uint64_t *)namespaces);
      }
      else {
        uint64_t v10 = 0LL;
      }
      v4 += v8 + 1;
      if (!v10) {
        goto LABEL_239;
      }
    }

    else
    {
LABEL_7:
      uint64_t v10 = xmlNewPatParserContext(v4, (uint64_t)dict, (uint64_t *)namespaces);
      BOOL v11 = 0LL;
      v4 += v8;
      if (!v10) {
        goto LABEL_239;
      }
    }

    int v13 = xmlMalloc(0x40uLL);
    if (!v13) {
      goto LABEL_238;
    }
    uint64_t v14 = (uint64_t)v13;
    v13[2] = 0u;
    v13[3] = 0u;
    _OWORD *v13 = 0u;
    v13[1] = 0u;
    *((_DWORD *)v13 + 10) = 10;
    uint64_t v15 = xmlMalloc(0xF0uLL);
    *(void *)(v14 + 48) = v15;
    if (!v15)
    {
      xmlFree((void *)v14);
      goto LABEL_238;
    }

    if (dict)
    {
      *(void *)(v14 + 8) = dict;
      xmlDictReference(dict);
    }

    unint64_t v7 = (xmlPattern *)v14;
    if (v9)
    {
      *(void *)(v14 + 16) = *((void *)v9 + 2);
      *((void *)v9 + 2) = v14;
      unint64_t v7 = v9;
    }

    *(_DWORD *)(v14 + 32) = flags;
    *((void *)v10 + 4) = v14;
    uint64_t v16 = *(_BYTE **)v10;
    if (v97)
    {
      for (uint64_t i = v16 + 1; ; ++i)
      {
        uint64_t v18 = *v16;
        if (((1LL << v18) & 0x100002600LL) == 0)
        {
          if (v18 == 47) {
            goto LABEL_107;
          }
          break;
        }

        *(void *)uint64_t v10 = ++v16;
      }

      *(_DWORD *)(v14 + 32) = v96;
      if (*v16 == 46)
      {
        while (1)
        {
          *(void *)uint64_t v10 = i;
          uint64_t v19 = *i;
          if (((1LL << v19) & 0x100002600LL) == 0)
          {
            if (*i)
            {
              if (v19 != 47) {
                break;
              }
              while (1)
              {
                *(void *)uint64_t v10 = ++i;
                uint64_t v23 = *i;
                if (((1LL << v23) & 0x100002600LL) == 0)
                {
                  if (v23 != 47) {
                    break;
                  }
                  unsigned int v24 = *(i - 1);
                  BOOL v25 = v24 > 0x20;
                  uint64_t v26 = (1LL << v24) & 0x100002600LL;
                  BOOL v27 = v25 || v26 == 0;
                  unsigned int v28 = *(unsigned __int8 **)v10;
                  if (**(_BYTE **)v10) {
                    goto LABEL_103;
                  }
                  while (1)
                  {
                    LODWORD(v23) = *v28;
LABEL_103:
                    *(void *)uint64_t v10 = ++v28;
                  }
                }
              }

LABEL_107:
      uint64_t v36 = v10 + 1;
LABEL_108:
      _DWORD *v36 = 1;
      goto LABEL_109;
    }

    for (uint64_t k = v16 + 1; ; ++k)
    {
      uint64_t v21 = *(k - 1);
      if (((1LL << v21) & 0x100002600LL) == 0)
      {
        if (v21 == 46)
        {
          int v22 = v96;
          goto LABEL_51;
        }

        int v22 = v95;
        if (v21 == 47) {
          goto LABEL_51;
        }
        break;
      }

      *(void *)uint64_t v10 = k;
    }

    int v22 = v96;
    if (!v94) {
      goto LABEL_52;
    }
LABEL_51:
    *(_DWORD *)(v14 + 32) = v22;
    LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *(k - 1);
LABEL_52:
    if ((_DWORD)v21 == 46)
    {
      if (*k != 47 || k[1] != 47) {
        goto LABEL_207;
      }
      unsigned int v30 = *(unsigned __int8 **)v10;
      if (**(_BYTE **)v10)
      {
        uint64_t v31 = v30 + 1;
        *(void *)uint64_t v10 = v30 + 1;
        if (v30[1])
        {
          uint64_t v31 = v30 + 2;
          *(void *)uint64_t v10 = v30 + 2;
          if (v30[2])
          {
            v30 += 3;
            goto LABEL_197;
          }
        }

        unsigned int v30 = v31;
      }

      while (1)
      {
        LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *v30;
        if (((1LL << v21) & 0x100002600LL) == 0) {
          break;
        }
        ++v30;
LABEL_197:
        *(void *)uint64_t v10 = v30;
      }

      if (!*v30) {
        goto LABEL_107;
      }
    }

    else if ((_DWORD)v21 == 47)
    {
      uint64_t v29 = v14;
      if (*k != 47) {
        goto LABEL_70;
      }
      uint64_t v21 = *(void *)v10;
      if (!**(_BYTE **)v10) {
        goto LABEL_207;
      }
      *(void *)uint64_t v10 = v21 + 1;
      if (!*(_BYTE *)(v21 + 1)) {
        goto LABEL_207;
      }
      unsigned int v30 = (unsigned __int8 *)(v21 + 2);
      *(void *)uint64_t v10 = v21 + 2;
      LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *(unsigned __int8 *)(v21 + 2);
    }

    else
    {
      unsigned int v30 = k - 1;
    }

  *(void *)(PropNode + 112) = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
  *(_DWORD *)(PropNode + 88) |= 4u;
  if ((v25 & 1) != 0 || !v24->ns) {
    goto LABEL_136;
  }
  uint64_t v42 = xmlStrEqual(v24->name, (const xmlChar *)"all");
  int v43 = v24->ns;
  if (v42)
  {
    if (xmlStrEqual(v43->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      uint64_t v44 = a1;
      uint64_t v45 = a2;
      int v46 = (uint64_t)v24;
      int v47 = 8;
      goto LABEL_134;
    }

    int v43 = v24->ns;
  }

  if (!v43) {
    goto LABEL_136;
  }
  uint64_t v49 = xmlStrEqual(v24->name, (const xmlChar *)"choice");
  int v50 = v24->ns;
  if (v49)
  {
    if (xmlStrEqual(v50->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      uint64_t v44 = a1;
      uint64_t v45 = a2;
      int v46 = (uint64_t)v24;
      int v47 = 7;
      goto LABEL_134;
    }

    int v50 = v24->ns;
  }

  if (!v50) {
    goto LABEL_136;
  }
  int v51 = xmlStrEqual(v24->name, (const xmlChar *)"sequence");
  int v52 = v24->ns;
  if (v51)
  {
    if (xmlStrEqual(v52->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
    {
      uint64_t v44 = a1;
      uint64_t v45 = a2;
      int v46 = (uint64_t)v24;
      int v47 = 6;
LABEL_134:
      int v53 = xmlSchemaParseModelGroup(v44, v45, v46, v47, 1);
LABEL_135:
      *(void *)(PropNode + 56) = v53;
      next = v24->next;
      goto LABEL_136;
    }

    int v52 = v24->ns;
  }

  if (v52
    && xmlStrEqual(v24->name, (const xmlChar *)"group")
    && xmlStrEqual(v24->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
  {
    int v53 = xmlSchemaParseModelGroupDefRef((_DWORD *)a1, a2, (uint64_t)v24);
    goto LABEL_135;
  }

LABEL_168:
    int v63 = *(_DWORD *)(v14 + 36);
    unsigned int v64 = *(_DWORD **)(v14 + 48);
    uint64_t v65 = (v63 - 1);
    if (v63 >= 1 && *v64 == 6)
    {
      if (v63 < 2)
      {
        LODWORD(v65) = 0;
      }

      else
      {
        uint64_t v66 = v64 + 6;
        uint64_t v67 = v65;
        do
        {
          *((_OWORD *)v66 - htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *(_OWORD *)(v66 + 2);
          *(v66 - 6) = *v66;
          v66 += 6;
          --v67;
        }

        while (v67);
      }

      *(_DWORD *)(v14 + 36) = v65;
      int v63 = v65;
    }

    uint64_t v68 = *(int *)(v14 + 40);
    if (v63 >= (int)v68)
    {
      unsigned int v64 = xmlRealloc(v64, 48 * v68);
      if (!v64) {
        goto LABEL_240;
      }
      *(void *)(v14 + 48) = v64;
      int v63 = *(_DWORD *)(v14 + 36);
      *(_DWORD *)(v14 + 40) *= 2;
    }

    if (v63 <= 1)
    {
      uint64_t v70 = v63;
    }

    else
    {
      uint64_t v69 = 0LL;
      uint64_t v70 = v63;
      int v71 = v64 + 2;
      uint64_t v72 = v63 - 2LL;
      uint64_t v73 = (uint64_t)&v64[6 * v63 - 6];
      do
      {
        __int128 v74 = *v71;
        *int v71 = *(_OWORD *)(v73 + 8);
        *(_OWORD *)(v73 + 8) = v74;
        int v75 = *((_DWORD *)v71 - 2);
        *((_DWORD *)v71 - 2) = *(_DWORD *)v73;
        *(_DWORD *)uint64_t v73 = v75;
        v73 -= 24LL;
        ++v69;
        int v71 = (_OWORD *)((char *)v71 + 24);
        BOOL v25 = v72-- <= v69;
      }

      while (!v25);
    }

    uint64_t v76 = &v64[6 * v70];
    *((void *)v76 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0LL;
    *((void *)v76 + 2) = 0LL;
    *(_DWORD *)(v14 + 36) = v63 + 1;
    *uint64_t v76 = 0;
    if (v11) {
      xmlFree(v11);
    }
    unsigned int v5 = *v4;
  }

  while (*v4);
  if (!v101)
  {
    uint64_t v91 = v7;
    do
    {
      uint64_t v92 = *((void *)v91 + 7);
      if (v92)
      {
        xmlFreeStreamComp(v92);
        *((void *)v91 + 7) = 0LL;
      }

      uint64_t v91 = (xmlPattern *)*((void *)v91 + 2);
    }

    while (v91);
  }

  return v7;
}

_OWORD *xmlNewPatParserContext(_OWORD *result, uint64_t a2, uint64_t *a3)
{
  if (result)
  {
    unsigned int v5 = result;
    int result = xmlMalloc(0x40uLL);
    if (result)
    {
      *int result = 0u;
      result[1] = 0u;
      result[2] = 0u;
      result[3] = 0u;
      *((void *)result + 3) = a2;
      *(void *)int result = v5;
      *((void *)result + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v5;
      if (a3)
      {
        int v6 = -1;
        unint64_t v7 = a3;
        do
        {
          uint64_t v8 = *v7;
          v7 += 2;
          ++v6;
        }

        while (v8);
      }

      else
      {
        int v6 = 0;
      }

      *((_DWORD *)result + 14) = v6;
      *((void *)result + 6) = a3;
    }
  }

  return result;
}

void xmlFreeStreamComp(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  if (v2) {
    xmlFree(v2);
  }
  if (*(void *)a1) {
    xmlDictFree(*(xmlDictPtr *)a1);
  }
  xmlFree((void *)a1);
}

int xmlPatternMatch(xmlPatternPtr comp, xmlNodePtr node)
{
  int result = -1;
  if (!comp) {
    return result;
  }
  xmlNodePtr v4 = node;
  if (!node) {
    return result;
  }
  while (2)
  {
    int v5 = 0;
    int v47 = 0;
    int v6 = 0LL;
    LODWORD(v7) = 0;
LABEL_5:
    uint64_t v8 = *((void *)comp + 6);
    uint64_t v9 = v8 + 24LL * (int)v7;
    uint64_t v10 = (int)v7;
    switch(*(_DWORD *)v9)
    {
      case 0:
        goto LABEL_94;
      case 1:
        if (v4->type != XML_NAMESPACE_DECL)
        {
          xmlNodePtr v4 = v4->parent;
          unsigned int type = v4->type;
          BOOL v12 = type > 0x15;
          int v13 = (1 << type) & 0x202200;
          if (!v12 && v13 != 0) {
            goto LABEL_89;
          }
        }

        goto LABEL_71;
      case 2:
        if (v4->type == XML_ELEMENT_NODE) {
          goto LABEL_13;
        }
        goto LABEL_71;
      case 3:
        HIDWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v4->type - 1;
        LODWORD(v2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = HIDWORD(v21);
        unsigned int v20 = v21 >> 2;
        BOOL v12 = v20 > 5;
        int v22 = (1 << v20) & 0x2D;
        if (v12 || v22 == 0) {
          goto LABEL_71;
        }
        uint64_t v24 = v8 + 24LL * (int)v7;
        uint64_t v26 = *(void *)(v24 + 8);
        BOOL v25 = (const xmlChar **)(v24 + 8);
        if (!v26) {
          goto LABEL_71;
        }
        xmlNodePtr children = v4->children;
        if (!children) {
          goto LABEL_71;
        }
        while (1)
        {
          if (children->type == XML_ELEMENT_NODE)
          {
            name = children->name;
            if (**v25 == *name)
            {
              if (xmlStrEqual(*v25, name)) {
                goto LABEL_89;
              }
            }
          }

          xmlNodePtr children = children->next;
          if (!children) {
            goto LABEL_71;
          }
        }

      case 4:
        if (v4->type != XML_ATTRIBUTE_NODE) {
          goto LABEL_71;
        }
        uint64_t v29 = *(const xmlChar **)(v8 + 24LL * (int)v7 + 8);
        if (v29)
        {
          unsigned int v30 = v4->name;
          if (*v29 != *v30 || !xmlStrEqual(v29, v30)) {
            goto LABEL_71;
          }
        }

        ns = v4->ns;
        uint64_t v19 = *(const xmlChar **)(v8 + 24LL * (int)v7 + 16);
        if (ns)
        {
          if (!v19) {
            goto LABEL_89;
          }
          href = ns->href;
LABEL_68:
          if (xmlStrEqual(v19, href)) {
            goto LABEL_89;
          }
          goto LABEL_71;
        }

        if (v19) {
          goto LABEL_71;
        }
        goto LABEL_89;
      case 5:
        unsigned int v32 = v4->type;
        BOOL v12 = v32 > 0x15;
        int v33 = (1 << v32) & 0x242200;
        if (!v12 && v33 != 0) {
          goto LABEL_71;
        }
        xmlNodePtr v4 = v4->parent;
        if (!v4) {
          goto LABEL_71;
        }
LABEL_13:
        uint64_t v15 = *(const xmlChar **)(v8 + 24LL * (int)v7 + 8);
        if (!v15) {
          goto LABEL_89;
        }
        uint64_t v16 = v4->name;
        if (*v15 != *v16 || !xmlStrEqual(v15, v16)) {
          goto LABEL_71;
        }
        uint64_t v17 = v4->ns;
        if (v17)
        {
          href = v17->href;
          if (!href) {
            goto LABEL_89;
          }
          uint64_t v19 = *(const xmlChar **)(v8 + 24LL * (int)v7 + 16);
          if (!v19) {
            goto LABEL_71;
          }
          goto LABEL_68;
        }

        goto LABEL_89;
      case 6:
        if (!*(void *)(v8 + 24LL * (int)v7 + 8))
        {
          uint64_t v7 = (int)v7 + 1LL;
          uint64_t v9 = v8 + 24 * (v10 + 1);
          if (*(_DWORD *)v9 != 2)
          {
            if (*(_DWORD *)v9 == 1) {
              goto LABEL_94;
            }
            goto LABEL_71;
          }

          if (!*(void *)(v8 + 24 * v7 + 8)) {
            return -1;
          }
          if (v4) {
            goto LABEL_47;
          }
LABEL_71:
          if (!v6) {
            goto LABEL_92;
          }
          BOOL v44 = __OFSUB__(v5--, 1);
          if (v5 < 0 != v44)
          {
            xmlFree(v6);
LABEL_92:
            comp = (xmlPatternPtr)*((void *)comp + 2);
            xmlNodePtr v4 = node;
            if (!comp) {
              return 0;
            }
            continue;
          }

          uint64_t v45 = &v6[16 * v5];
          LODWORD(v7) = *(_DWORD *)v45;
          xmlNodePtr v4 = (xmlNodePtr)*((void *)v45 + 1);
          if (*(_DWORD *)v45 >= *((_DWORD *)comp + 9)) {
            goto LABEL_95;
          }
          goto LABEL_5;
        }

        if (!v4) {
          goto LABEL_71;
        }
LABEL_47:
        unsigned int v35 = v4->type;
        if (v35 <= 0x15 && ((1 << v35) & 0x242200) != 0) {
          goto LABEL_71;
        }
        while (1)
        {
          while (1)
          {
            while (1)
            {
              xmlNodePtr v4 = v4->parent;
              if (!v4) {
                goto LABEL_71;
              }
              if (v4->type == XML_ELEMENT_NODE)
              {
                uint64_t v36 = *(const xmlChar **)(v9 + 8);
                int v37 = v4->name;
                if (*v36 == *v37)
                {
                  if (xmlStrEqual(v36, v37)) {
                    break;
                  }
                }
              }
            }

            uint64_t v38 = v4->ns;
            if (v38) {
              break;
            }
            if (!*(void *)(v9 + 16)) {
              goto LABEL_59;
            }
          }

          int v39 = v38->href;
          if (v39)
          {
            uint64_t v40 = *(const xmlChar **)(v9 + 16);
            if (v40)
            {
              if (xmlStrEqual(v40, v39)) {
                break;
              }
            }
          }
        }

xmlStreamCtxtPtr xmlPatternGetStreamCtxt(xmlStreamCtxtPtr comp)
{
  if (comp)
  {
    xmlStreamCtxtPtr v1 = comp;
    if (*((void *)comp + 7))
    {
      xmlStreamCtxtPtr v2 = 0LL;
      while (1)
      {
        uint64_t v3 = *((void *)v1 + 7);
        if (!v3) {
          break;
        }
        xmlNodePtr v4 = xmlMalloc(0x30uLL);
        if (!v4) {
          break;
        }
        int v5 = v4;
        v4[1] = 0u;
        v4[2] = 0u;
        *xmlNodePtr v4 = 0u;
        int v6 = xmlMalloc(0x20uLL);
        v5[4] = v6;
        if (!v6)
        {
          xmlFree(v5);
          break;
        }

        v5[2] = 0x400000000LL;
        *((_DWORD *)v5 + 6) = 0;
        v5[1] = v3;
        comp = (xmlStreamCtxtPtr)v5;
        *((_DWORD *)v5 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = -1;
        if (v2)
        {
          *int v5 = *(void *)v2;
          *(void *)xmlStreamCtxtPtr v2 = v5;
          comp = v2;
        }

        *((_DWORD *)v5 + 10) = *((_DWORD *)v1 + 8);
        xmlStreamCtxtPtr v1 = (xmlStreamCtxtPtr)*((void *)v1 + 2);
        xmlStreamCtxtPtr v2 = comp;
        if (!v1) {
          return comp;
        }
      }

      if (v2)
      {
        do
        {
          uint64_t v7 = *(xmlStreamCtxt **)v2;
          uint64_t v8 = (void *)*((void *)v2 + 4);
          if (v8) {
            xmlFree(v8);
          }
          xmlFree(v2);
          xmlStreamCtxtPtr v2 = v7;
        }

        while (v7);
      }
    }

    return 0LL;
  }

  return comp;
}

int xmlPatternStreamable(xmlPatternPtr comp)
{
  if (!comp) {
    return -1;
  }
  while (*((void *)comp + 7))
  {
    comp = (xmlPatternPtr)*((void *)comp + 2);
    if (!comp) {
      return 1;
    }
  }

  return 0;
}

int xmlPatternMaxDepth(xmlPatternPtr comp)
{
  if (comp)
  {
    xmlPatternPtr v1 = comp;
    int result = 0;
    while (1)
    {
      uint64_t v3 = *((void *)v1 + 7);
      if (!v3) {
        break;
      }
      uint64_t v4 = *(unsigned int *)(v3 + 8);
      if ((int)v4 >= 1)
      {
        int v5 = *(char **)(v3 + 16);
        uint64_t v6 = v4;
        do
        {
          char v7 = *v5;
          v5 += 32;
          if ((v7 & 1) != 0) {
            return -2;
          }
        }

        while (--v6);
      }

      xmlPatternPtr v1 = (xmlPatternPtr)*((void *)v1 + 2);
      if (!v1) {
        return result;
      }
    }
  }

  return -1;
}

int xmlPatternMinDepth(xmlPatternPtr comp)
{
  if (comp)
  {
    xmlPatternPtr v1 = comp;
    int result = 12345678;
    while (1)
    {
      uint64_t v3 = *((void *)v1 + 7);
      if (!v3) {
        break;
      }
      int v4 = *(_DWORD *)(v3 + 8);
      if (v4 < result) {
        int result = v4;
      }
      if (result)
      {
        xmlPatternPtr v1 = (xmlPatternPtr)*((void *)v1 + 2);
        if (v1) {
          continue;
        }
      }

      return result;
    }
  }

  return -1;
}

int xmlPatternFromRoot(xmlPatternPtr comp)
{
  if (comp)
  {
    while (*((void *)comp + 7))
    {
      if ((*((_BYTE *)comp + 33) & 1) != 0)
      {
        LODWORD(comp) = 1;
        return (int)comp;
      }

      comp = (xmlPatternPtr)*((void *)comp + 2);
      if (!comp) {
        return (int)comp;
      }
    }
  }

  LODWORD(comp) = -1;
  return (int)comp;
}

uint64_t xmlStreamCtxtAddState(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if ((int)v6 < 1)
  {
LABEL_5:
    uint64_t v9 = *(int *)(a1 + 20);
    if ((int)v6 >= (int)v9)
    {
      uint64_t v10 = xmlRealloc(*(void **)(a1 + 32), 16 * v9);
      if (!v10) {
        return 0xFFFFFFFFLL;
      }
      *(void *)(a1 + 32) = v10;
      LODWORD(v6) = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) *= 2;
    }

    else
    {
      uint64_t v10 = *(_DWORD **)(a1 + 32);
    }

    v10[2 * (_DWORD)v6] = a2;
    int v11 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v11 + 1;
    v10[(2 * v11) | 1] = a3;
    return (*(_DWORD *)(a1 + 16) - 1);
  }

  uint64_t result = 0LL;
  uint64_t v8 = *(_DWORD **)(a1 + 32);
  while ((*v8 & 0x80000000) == 0)
  {
    ++result;
    v8 += 2;
    if (v6 == result) {
      goto LABEL_5;
    }
  }

  *uint64_t v8 = a2;
  v8[1] = a3;
  return result;
}

uint64_t xmlPatternAdd(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 + 36);
  uint64_t v9 = *(int *)(a1 + 40);
  if (v8 >= (int)v9)
  {
    uint64_t v10 = (char *)xmlRealloc(*(void **)(a1 + 48), 48 * v9);
    if (!v10) {
      return 0xFFFFFFFFLL;
    }
    *(void *)(a1 + 48) = v10;
    int v8 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 40) *= 2;
  }

  else
  {
    uint64_t v10 = *(char **)(a1 + 48);
  }

  uint64_t v11 = 0LL;
  BOOL v12 = &v10[24 * v8];
  *(_DWORD *)BOOL v12 = a2;
  *((void *)v12 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = a3;
  *((void *)v12 + 2) = a4;
  *(_DWORD *)(a1 + 36) = v8 + 1;
  return v11;
}

void xmlCompileStepPattern(uint64_t *a1)
{
  for (uint64_t i = *a1 + 1; ; ++i)
  {
    uint64_t v3 = *(unsigned __int8 *)(i - 1) - 9;
    if (((1LL << (*(_BYTE *)(i - 1) - 9)) & 0x800013) == 0) {
      break;
    }
    *a1 = i;
  }

  if (v3 == 37)
  {
    *a1 = i;
    uint64_t v4 = a1[4];
    int v5 = 2;
LABEL_11:
    xmlPatternAdd(v4, v5, 0LL, 0LL);
    return;
  }

  if (v3 == 55)
  {
    if ((*(_BYTE *)(a1[4] + 32) & 2) == 0)
    {
      *a1 = i;
LABEL_9:
      xmlCompileAttributeTest(a1);
      return;
    }

    goto LABEL_65;
  }

LABEL_65:
    *((_DWORD *)a1 + 4) = 1;
    return;
  }

  uint64_t v9 = (xmlChar *)v6;
  if (v8 > 0x20 || ((1LL << v8) & 0x100002600LL) == 0)
  {
    char v13 = 0;
  }

  else
  {
    uint64_t v11 = (unsigned __int8 *)(v7 + 1);
    while (v8 <= 0x20 && ((1LL << v8) & 0x100002600LL) != 0)
    {
      *a1 = (uint64_t)v11;
      unsigned int v12 = *v11++;
      unsigned int v8 = v12;
    }

    uint64_t v7 = (uint64_t)(v11 - 1);
    char v13 = 1;
  }

  if (v8 == 42)
  {
LABEL_59:
    *((_DWORD *)a1 + 4) = 1;
    goto LABEL_60;
  }

  if (v8 != 58)
  {
LABEL_60:
    if (!v9) {
      return;
    }
    goto LABEL_61;
  }

  *a1 = v7 + 1;
  unsigned int v15 = *(unsigned __int8 *)(v7 + 1);
  if (v15 != 58)
  {
    if (v15 == 32) {
      char v20 = 1;
    }
    else {
      char v20 = v13;
    }
    if ((v20 & 1) == 0 && (v15 > 0xD || ((1 << v15) & 0x2600) == 0))
    {
      unint64_t v21 = xmlPatScanName((const xmlChar **)a1);
      if (*v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3])
      {
        uint64_t v36 = *(xmlDict **)(a1[4] + 8);
        if (v36) {
          int v37 = (void *)xmlDictLookup(v36, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
        }
        else {
          int v37 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
        }
        BOOL v25 = v37;
      }

      else
      {
        if (*((int *)a1 + 14) < 1)
        {
          LODWORD(v23) = 0;
LABEL_70:
          BOOL v25 = 0LL;
        }

        else
        {
          uint64_t v22 = 0LL;
          uint64_t v23 = 0LL;
          while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v22 + 8), v9))
          {
            ++v23;
            v22 += 16LL;
          }

          unsigned int v28 = *(xmlDict **)(a1[4] + 8);
          uint64_t v29 = (unsigned __int8 *)a1[6];
          if (v28) {
            unsigned int v30 = (void *)xmlDictLookup(v28, *(const xmlChar **)&v29[v22], -1);
          }
          else {
            unsigned int v30 = xmlStrdup(*(const xmlChar **)&v29[v22]);
          }
          BOOL v25 = v30;
        }
      }

      if (!*(void *)(a1[4] + 8)) {
        xmlFree(v9);
      }
      if (v21)
      {
        uint64_t v31 = a1[4];
        int v32 = 2;
LABEL_102:
        uint64_t v9 = 0LL;
        goto LABEL_109;
      }

      goto LABEL_104;
    }

    goto LABEL_59;
  }

  *a1 = v7 + 2;
  if (!xmlStrEqual(v6, (const xmlChar *)"child"))
  {
    if (xmlStrEqual(v9, (const xmlChar *)"attribute"))
    {
      uint64_t v24 = (unsigned __int8 *)a1[4];
      if (!*((void *)v24 + 1))
      {
        xmlFree(v9);
        uint64_t v24 = (unsigned __int8 *)a1[4];
      }

      if ((v24[32] & 2) == 0) {
        goto LABEL_9;
      }
      goto LABEL_65;
    }

    goto LABEL_59;
  }

  if (!*(void *)(a1[4] + 8)) {
    xmlFree(v9);
  }
  uint64_t v16 = (xmlChar *)xmlPatScanName((const xmlChar **)a1);
  uint64_t v17 = *a1;
  int v18 = *(unsigned __int8 *)*a1;
  if (!v16)
  {
    if (v18 == 42)
    {
      uint64_t v14 = (unsigned __int8 *)(v17 + 1);
      goto LABEL_24;
    }

    goto LABEL_65;
  }

  uint64_t v9 = v16;
  if (v18 != 58)
  {
    goto LABEL_61;
  }

  *a1 = v17 + 1;
  unsigned int v19 = *(unsigned __int8 *)(v17 + 1);
  if (v19 > 0x20 || ((1LL << v19) & 0x100002600LL) == 0)
  {
    unint64_t v21 = xmlPatScanName((const xmlChar **)a1);
    if (*v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3])
    {
      uint64_t v38 = *(xmlDict **)(a1[4] + 8);
      if (v38) {
        int v39 = (void *)xmlDictLookup(v38, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
      }
      else {
        int v39 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      }
      BOOL v25 = v39;
      goto LABEL_98;
    }

    if (*((int *)a1 + 14) < 1)
    {
      LODWORD(v27) = 0;
LABEL_90:
      BOOL v25 = 0LL;
    }

    else
    {
      uint64_t v26 = 0LL;
      uint64_t v27 = 0LL;
      while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v26 + 8), v9))
      {
        ++v27;
        v26 += 16LL;
      }

      int v33 = *(xmlDict **)(a1[4] + 8);
      unsigned int v34 = (unsigned __int8 *)a1[6];
      if (v33) {
        unsigned int v35 = (void *)xmlDictLookup(v33, *(const xmlChar **)&v34[v26], -1);
      }
      else {
        unsigned int v35 = xmlStrdup(*(const xmlChar **)&v34[v26]);
      }
      BOOL v25 = v35;
    }

    if ((int)v27 < *((_DWORD *)a1 + 14))
    {
LABEL_98:
      if (!*(void *)(a1[4] + 8)) {
        xmlFree(v9);
      }
      if (v21)
      {
        uint64_t v31 = a1[4];
        int v32 = 3;
        goto LABEL_102;
      }

LABEL_104:
      if (*(_BYTE *)*a1 == 42)
      {
        ++*a1;
        unint64_t v21 = 0LL;
        uint64_t v9 = 0LL;
        goto LABEL_109;
      }

      unint64_t v21 = 0LL;
      uint64_t v9 = 0LL;
    }

                int v47 = (xmlNode *)xmlSchemaGetPropNode((uint64_t)v26, (xmlChar *)"id");
                if (v47) {
                  xmlSchemaPValAttrNodeID(a1, v47);
                }
                MaxOccurs = xmlGetMaxOccurs(a1, (uint64_t)v26, 0, 0x40000000, "(xs:nonNegativeInteger | unbounded)");
                HIDWORD(v62) = xmlGetMinOccurs(a1, (uint64_t)v26, -1, "xs:nonNegativeInteger");
                xmlSchemaPCheckParticleCorrect_2(a1, (uint64_t)v26, SHIDWORD(v62), MaxOccurs);
                uint64_t v49 = xmlSchemaAddWildcard(a1, a2, 2, (uint64_t)v26);
                if (v49)
                {
                  LODWORD(v62) = MaxOccurs;
                  int v61 = v49;
                  xmlSchemaParseWildcardNs(a1, (uint64_t)v49, v26);
                  xmlNodePtr children = (uint64_t)v26->children;
                  if (children)
                  {
                    if (*(void *)(children + 72)
                      && xmlStrEqual(*(const xmlChar **)(children + 16), (const xmlChar *)"annotation")
                      && xmlStrEqual( *(const xmlChar **)(*(void *)(children + 72) + 16LL),  (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
                    {
                      int v60 = xmlSchemaParseAnnotation((_DWORD *)a1, children, 1);
                      xmlNodePtr children = *(void *)(children + 48);
                      if (!children) {
                        goto LABEL_131;
                      }
                    }

                    else
                    {
                      int v60 = 0LL;
                    }

                    xmlSchemaPContentErr(a1, 3033, (uint64_t)v26, children, 0LL, (xmlChar *)"(annotation?)");
                  }

                  else
                  {
                    int v60 = 0LL;
                  }

LABEL_108:
    *((_DWORD *)a1 + 4) = 1;
LABEL_109:
    if (v25 && !*(void *)(a1[4] + 8)) {
      xmlFree(v25);
    }
    if (v21 && !*(void *)(a1[4] + 8)) {
      xmlFree(v21);
    }
    goto LABEL_60;
  }

  *((_DWORD *)a1 + 4) = 1;
LABEL_61:
  if (!*(void *)(a1[4] + 8)) {
    xmlFree(v9);
  }
}

          int v37 = (void **)v81;
          goto LABEL_109;
        }
      }

      uint64_t v27 = (uint64_t)v76;
      *((_DWORD *)v76 + 5) = -1;
LABEL_137:
      ((void (*)(uint64_t))xmlFree)(v27);
    }

    else
    {
      __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)"allocating an IDC node-table item");
    }

                    uint64_t v57 = xmlXPtrNewRange(v52, v53, v54, v55);
                    xmlXPtrLocationSetAdd(cur, v57);
                  }
                }
              }

              else
              {
                uint64_t v56 = xmlXPtrNewRange((xmlNodePtr)v36, v34, (xmlNodePtr)v33, v47);
                xmlXPtrLocationSetAdd(cur, v56);
                int v51 = v70;
              }

              int v77 = (xmlNode *)v33;
              int v78 = v47;
              stringval = v51->stringval;
              if (*stringval)
              {
                if (!v33) {
                  goto LABEL_115;
                }
                goto LABEL_61;
              }

              int v78 = v47 + 1;
              if (!v33)
              {
LABEL_115:
                char v20 = v71 + 1;
                user = v69;
                if (v71 + 1 >= *v69)
                {
                  xmlStreamCtxtPtr v2 = v60;
                  int v5 = v61;
                  uint64_t v9 = v67;
                  unsigned int v12 = v70;
                  uint64_t v16 = v59;
                  goto LABEL_130;
                }

                goto LABEL_36;
              }

              goto LABEL_61;
            }

            unsigned int v34 = v68;
          }
        }
      }

void xmlCompileAttributeTest(uint64_t *a1)
{
  for (uint64_t i = *a1 + 1; ; ++i)
  {
    unsigned int v3 = *(unsigned __int8 *)(i - 1);
    BOOL v4 = v3 > 0x20;
    uint64_t v5 = (1LL << v3) & 0x100002600LL;
    if (v4 || v5 == 0) {
      break;
    }
    *a1 = i;
  }

  uint64_t v7 = (xmlChar *)xmlPatScanNCName((const xmlChar **)a1);
  unsigned int v8 = (const xmlChar *)*a1;
  int v9 = *(unsigned __int8 *)*a1;
  if (v7)
  {
    uint64_t v10 = v7;
    if (v9 != 58)
    {
      xmlPatternAdd(a1[4], 4, (uint64_t)v7, 0LL);
      return;
    }

    *a1 = (uint64_t)(v8 + 1);
    unsigned int v11 = v8[1];
    BOOL v4 = v11 > 0x20;
    uint64_t v12 = (1LL << v11) & 0x100002600LL;
    if (!v4 && v12 != 0)
    {
      if (!*(void *)(a1[4] + 8)) {
        xmlFree(v7);
      }
      goto LABEL_19;
    }

    uint64_t v14 = xmlPatScanName((const xmlChar **)a1);
    if (*v10 == 120 && v10[1] == 109 && v10[2] == 108 && !v10[3])
    {
      unint64_t v21 = *(xmlDict **)(a1[4] + 8);
      if (v21) {
        uint64_t v22 = (void *)xmlDictLookup(v21, (const xmlChar *)"http://www.w3.org/XML/1998/namespace", -1);
      }
      else {
        uint64_t v22 = xmlStrdup((const xmlChar *)"http://www.w3.org/XML/1998/namespace");
      }
      uint64_t v17 = v22;
    }

    else
    {
      if (*((int *)a1 + 14) < 1)
      {
        LODWORD(v16) = 0;
LABEL_32:
        uint64_t v17 = 0LL;
      }

      else
      {
        uint64_t v15 = 0LL;
        uint64_t v16 = 0LL;
        while (!xmlStrEqual(*(const xmlChar **)(a1[6] + v15 + 8), v10))
        {
          ++v16;
          v15 += 16LL;
        }

        int v18 = *(xmlDict **)(a1[4] + 8);
        unsigned int v19 = (unsigned __int8 *)a1[6];
        if (v18) {
          char v20 = (void *)xmlDictLookup(v18, *(const xmlChar **)&v19[v15], -1);
        }
        else {
          char v20 = xmlStrdup(*(const xmlChar **)&v19[v15]);
        }
        uint64_t v17 = v20;
      }

      if ((int)v16 >= *((_DWORD *)a1 + 14))
      {
        if (!*(void *)(a1[4] + 8)) {
          xmlFree(v10);
        }
        goto LABEL_49;
      }
    }

    if (!*(void *)(a1[4] + 8)) {
      xmlFree(v10);
    }
    if (v14)
    {
      goto LABEL_50;
    }

    if (*(_BYTE *)*a1 == 42)
    {
      ++*a1;
      uint64_t v14 = 0LL;
      goto LABEL_50;
    }

    uint64_t v14 = 0LL;
LABEL_49:
    *((_DWORD *)a1 + 4) = 1;
LABEL_50:
    if (v17 && !*(void *)(a1[4] + 8)) {
      xmlFree(v17);
    }
    if (v14 && !*(void *)(a1[4] + 8)) {
      xmlFree(v14);
    }
    return;
  }

  if (v9 != 42)
  {
LABEL_19:
    *((_DWORD *)a1 + 4) = 1;
    return;
  }

void *xmlPatScanNCName(const xmlChar **a1)
{
  int len = 0;
  xmlStreamCtxtPtr v2 = *a1;
  unsigned int v3 = *a1;
  while (1)
  {
    unsigned int v4 = *v3;
    BOOL v10 = v4 > 0x20;
    uint64_t v5 = (1LL << v4) & 0x100002600LL;
    if (v10 || v5 == 0) {
      break;
    }
    *a1 = ++v3;
    LODWORD(v2) = (_DWORD)v2 + 1;
  }

  signed int v7 = xmlStringCurrentChar(0LL, v3, &len);
  signed int v8 = v7;
  if (v7 > 255)
  {
    if (xmlCharInRange(v7, &xmlIsBaseCharGroup)) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = (v8 - 12330) > 0xFFFFFFF6;
    }
  }

  else if ((v7 - 192) >= 0x17 {
         && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && v7 != 95
         && v7 <= 247
         && (v7 - 216) >= 0x1F)
  {
    return 0LL;
  }

  for (i = v3; ; signed int v8 = xmlStringCurrentChar(0LL, i, &len))
  {
    if (v8 > 255)
    {
      if (xmlCharInRange(v8, &xmlIsBaseCharGroup)) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = (v8 - 12321) >= 9;
      }
      BOOL v16 = v14 && v8 != 12295 && (v8 - 19968) >= 0x51A6;
      if (!v16 || xmlCharInRange(v8, &xmlIsDigitGroup)) {
        goto LABEL_47;
      }
    }

    else if ((v8 - 192) < 0x17 {
           || (v8 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (v8 - 48) < 0xA
           || v8 > 247
           || (v8 - 216) < 0x1F)
    {
      goto LABEL_47;
    }

    if (v8 >= 256) {
      break;
    }
    if (v8 != 183) {
      goto LABEL_53;
    }
LABEL_47:
    i += len;
  }

  if (xmlCharInRange(v8, &xmlIsCombiningGroup) || xmlCharInRange(v8, &xmlIsExtenderGroup)) {
    goto LABEL_47;
  }
LABEL_53:
  uint64_t v17 = (xmlDict *)a1[3];
  if (v17) {
    uint64_t result = (void *)xmlDictLookup(v17, v3, (int)i - (int)v2);
  }
  else {
    uint64_t result = xmlStrndup(v3, (int)i - (int)v2);
  }
  *a1 = i;
  return result;
}

void *xmlPatScanName(const xmlChar **a1)
{
  int len = 0;
  xmlStreamCtxtPtr v2 = *a1;
  unsigned int v3 = *a1;
  while (1)
  {
    unsigned int v4 = *v3;
    BOOL v10 = v4 > 0x20;
    uint64_t v5 = (1LL << v4) & 0x100002600LL;
    if (v10 || v5 == 0) {
      break;
    }
    *a1 = ++v3;
    LODWORD(v2) = (_DWORD)v2 + 1;
  }

  signed int v7 = xmlStringCurrentChar(0LL, v3, &len);
  signed int v8 = v7;
  if (v7 > 255)
  {
    if (xmlCharInRange(v7, &xmlIsBaseCharGroup)) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = (v8 - 12330) > 0xFFFFFFF6;
    }
  }

  else if ((v7 - 192) >= 0x17 {
         && (v7 & 0xFFFFFFDF) - 65 >= 0x1A
  }
         && v7 <= 247
         && (v7 - 216) >= 0x1F
         && v7 != 95
         && v7 != 58)
  {
    return 0LL;
  }

  for (i = v3; ; signed int v8 = xmlStringCurrentChar(0LL, i, &len))
  {
    if (v8 > 255)
    {
      if (xmlCharInRange(v8, &xmlIsBaseCharGroup)) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = (v8 - 12321) >= 9;
      }
      BOOL v16 = v14 && v8 != 12295 && (v8 - 19968) >= 0x51A6;
      if (!v16 || xmlCharInRange(v8, &xmlIsDigitGroup)) {
        goto LABEL_48;
      }
    }

    else if ((v8 - 192) < 0x17 {
           || (v8 & 0xFFFFFFDF) - 65 < 0x1A
    }
           || (v8 - 48) < 0xA
           || v8 > 247
           || (v8 - 216) < 0x1F)
    {
      goto LABEL_48;
    }

    if (v8 >= 256) {
      break;
    }
    if (v8 != 183) {
      goto LABEL_54;
    }
LABEL_48:
    i += len;
  }

  if (xmlCharInRange(v8, &xmlIsCombiningGroup) || xmlCharInRange(v8, &xmlIsExtenderGroup)) {
    goto LABEL_48;
  }
LABEL_54:
  uint64_t v17 = (xmlDict *)a1[3];
  if (v17) {
    uint64_t result = (void *)xmlDictLookup(v17, v3, (int)i - (int)v2);
  }
  else {
    uint64_t result = xmlStrndup(v3, (int)i - (int)v2);
  }
  *a1 = i;
  return result;
}

_OWORD *xmlNewStreamComp(int a1)
{
  if (a1 <= 4) {
    unsigned int v1 = 4;
  }
  else {
    unsigned int v1 = a1;
  }
  xmlStreamCtxtPtr v2 = xmlMalloc(0x20uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    _OWORD *v2 = 0u;
    v2[1] = 0u;
    unsigned int v4 = xmlMalloc(32LL * v1);
    *((void *)v3 + 2) = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 2) = 0;
      *((_DWORD *)v3 + 3) = v1;
    }

    else
    {
      xmlFree(v3);
      return 0LL;
    }
  }

  return v3;
}

uint64_t xmlStreamCompAddStep(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = *(unsigned int *)(a1 + 8);
  uint64_t v11 = *(int *)(a1 + 12);
  if ((int)result < (int)v11)
  {
    uint64_t v12 = *(char **)(a1 + 16);
LABEL_5:
    *(_DWORD *)(a1 + 8) = result + 1;
    BOOL v14 = &v12[32 * (int)result];
    *(_DWORD *)BOOL v14 = a5;
    *((void *)v14 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = a2;
    *((void *)v14 + 2) = a3;
    *((_DWORD *)v14 + 6) = a4;
    return result;
  }

  char v13 = (char *)xmlRealloc(*(void **)(a1 + 16), v11 << 6);
  if (v13)
  {
    uint64_t v12 = v13;
    *(void *)(a1 + 16) = v13;
    uint64_t result = *(unsigned int *)(a1 + 8);
    *(_DWORD *)(a1 + 12) *= 2;
    goto LABEL_5;
  }

  return 0xFFFFFFFFLL;
}

void xmlRelaxNGFree(xmlRelaxNGPtr schema)
{
  if (schema)
  {
    xmlStreamCtxtPtr v2 = (void *)*((void *)schema + 1);
    if (v2) {
      xmlRelaxNGFreeGrammar(v2);
    }
    unsigned int v3 = (xmlDoc *)*((void *)schema + 2);
    if (v3) {
      xmlFreeDoc(v3);
    }
    unsigned int v4 = (void *)*((void *)schema + 6);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        xmlRelaxNGFreeDocument(v4);
        unsigned int v4 = v5;
      }

      while (v5);
    }

    uint64_t v6 = (void *)*((void *)schema + 7);
    if (v6)
    {
      do
      {
        signed int v7 = (void *)*v6;
        xmlRelaxNGFreeInclude(v6);
        uint64_t v6 = v7;
      }

      while (v7);
    }

    signed int v8 = (void *)*((void *)schema + 9);
    if (v8)
    {
      if (*((int *)schema + 16) >= 1)
      {
        uint64_t v9 = 0LL;
        do
          xmlRelaxNGFreeDefine(*(int **)(*((void *)schema + 9) + 8 * v9++));
        while (v9 < *((int *)schema + 16));
        signed int v8 = (void *)*((void *)schema + 9);
      }

      xmlFree(v8);
    }

    xmlFree(schema);
  }

void xmlRelaxNGFreeGrammar(void *a1)
{
  if (a1[1]) {
    xmlRelaxNGFreeGrammar();
  }
  if (a1[2]) {
    xmlRelaxNGFreeGrammar();
  }
  xmlStreamCtxtPtr v2 = (xmlHashTable *)a1[7];
  if (v2) {
    xmlHashFree(v2, 0LL);
  }
  unsigned int v3 = (xmlHashTable *)a1[6];
  if (v3) {
    xmlHashFree(v3, 0LL);
  }
  xmlFree(a1);
}

void xmlRelaxNGFreeDefine(int *a1)
{
  if (!a1) {
    return;
  }
  if (*a1 == 7)
  {
    if (*((void *)a1 + 9))
    {
      uint64_t v2 = *((void *)a1 + 5);
      if (v2)
      {
        unsigned int v3 = *(void (**)(void))(v2 + 48);
        if (v3) {
          v3(*(void *)(v2 + 8));
        }
      }
    }
  }

  unsigned int v4 = (void *)*((void *)a1 + 5);
  if (v4)
  {
    int v5 = *a1;
    if (*a1 != 19) {
      goto LABEL_11;
    }
    xmlRelaxNGFreePartition(v4);
    unsigned int v4 = (void *)*((void *)a1 + 5);
    if (v4)
    {
      int v5 = *a1;
LABEL_11:
      if (v5 == 17) {
        xmlHashFree((xmlHashTablePtr)v4, 0LL);
      }
    }
  }

  uint64_t v6 = (void *)*((void *)a1 + 2);
  if (v6) {
    xmlFree(v6);
  }
  signed int v7 = (void *)*((void *)a1 + 3);
  if (v7) {
    xmlFree(v7);
  }
  signed int v8 = (void *)*((void *)a1 + 4);
  if (v8) {
    xmlFree(v8);
  }
  uint64_t v9 = (xmlRegexp *)*((void *)a1 + 13);
  if (v9) {
    xmlRegFreeRegexp(v9);
  }
  xmlFree(a1);
}

int xmlRelaxParserSetFlag(xmlRelaxNGParserCtxtPtr ctxt, int flag)
{
  if (!ctxt) {
    return -1;
  }
  if ((flag & 1) != 0)
  {
    *((_DWORD *)ctxt + 62) |= 1u;
    --flag;
  }

  if ((flag & 2) != 0)
  {
    *((_DWORD *)ctxt + 62) |= 2u;
    flag -= 2;
  }

  if (flag) {
    return -1;
  }
  else {
    return 0;
  }
}

int xmlRelaxNGInitTypes(void)
{
  if ((xmlRelaxNGTypeInitialized & 1) != 0) {
    return 0;
  }
  xmlRelaxNGRegisteredTypes = (uint64_t)xmlHashCreate(10);
  if (xmlRelaxNGRegisteredTypes)
  {
    xmlRelaxNGRegisterTypeLibrary( (xmlChar *)"http://www.w3.org/2001/XMLSchema-datatypes",  xmlRelaxNGSchemaTypeHave,  xmlRelaxNGSchemaTypeCheck,  xmlRelaxNGSchemaTypeCompare,  xmlRelaxNGSchemaFacetCheck,  xmlRelaxNGSchemaFreeValue);
    xmlRelaxNGRegisterTypeLibrary( (xmlChar *)"http://relaxng.org/ns/structure/1.0",  xmlRelaxNGDefaultTypeHave,  xmlRelaxNGDefaultTypeCheck,  xmlRelaxNGDefaultTypeCompare,  0LL,  0LL);
    int result = 0;
    xmlRelaxNGTypeInitialized = 1;
  }

  else
  {
    xmlGenericErrorFunc v1 = *__xmlGenericError();
    uint64_t v2 = __xmlGenericErrorContext();
    v1(*v2, "Failed to allocate sh table for Relax-NG types\n");
    return -1;
  }

  return result;
}

void xmlRelaxNGRegisterTypeLibrary(xmlChar *name, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  if (a4 && a3 && name && xmlRelaxNGRegisteredTypes)
  {
    if (xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, name))
    {
      xmlGenericErrorFunc v12 = *__xmlGenericError();
      char v13 = __xmlGenericErrorContext();
      v12(*v13, "Relax-NG types library '%s' already registered\n", (const char *)name);
    }

    else
    {
      BOOL v14 = (void **)xmlMalloc(0x38uLL);
      if (v14)
      {
        uint64_t v15 = v14;
        v14[6] = 0LL;
        *((_OWORD *)v14 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
        *((_OWORD *)v14 + 2) = 0u;
        *(_OWORD *)BOOL v14 = 0u;
        *BOOL v14 = xmlStrdup(name);
        v15[1] = 0LL;
        v15[2] = a2;
        v15[3] = a3;
        v15[4] = a4;
        v15[5] = a5;
        _OWORD v15[6] = a6;
        if (xmlHashAddEntry((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, name, v15) < 0)
        {
          xmlGenericErrorFunc v16 = *__xmlGenericError();
          uint64_t v17 = __xmlGenericErrorContext();
          v16(*v17, "Relax-NG types library failed to register '%s'\n", (const char *)name);
          if (*v15) {
            xmlFree(*v15);
          }
          xmlFree(v15);
        }
      }

      else
      {
        xmlRngVErrMemory(0LL, (const xmlChar *)"adding types library\n");
      }
    }
  }

uint64_t xmlRelaxNGSchemaTypeHave(int a1, xmlChar *name)
{
  if (name) {
    return xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema") != 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t xmlRelaxNGSchemaTypeCheck( int a1, xmlChar *name, const xmlChar *a3, xmlSchemaValPtr *a4, xmlNode *a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (name && a3)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (PredefinedType)
    {
      int v10 = xmlSchemaValPredefTypeNode(PredefinedType, a3, a4, a5);
      if (v10 >= 1) {
        unsigned int v11 = 0;
      }
      else {
        unsigned int v11 = -1;
      }
      if (!v10) {
        unsigned int v11 = 1;
      }
      if (v10 == 2) {
        return 2LL;
      }
      else {
        return v11;
      }
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t xmlRelaxNGSchemaTypeCompare( int a1, xmlChar *name, const xmlChar *a3, xmlNode *a4, xmlSchemaVal *a5, const xmlChar *a6, xmlNode *a7)
{
  xmlSchemaValPtr y = 0LL;
  xmlSchemaValPtr val = 0LL;
  uint64_t result = 0xFFFFFFFFLL;
  if (name && a3 && a6)
  {
    PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (!PredefinedType) {
      return 0xFFFFFFFFLL;
    }
    BOOL v14 = PredefinedType;
    if (a5)
    {
      xmlSchemaValPtr val = a5;
    }

    else
    {
      int v15 = xmlSchemaValPredefTypeNode(PredefinedType, a3, &val, a4);
      uint64_t result = 0xFFFFFFFFLL;
      if (v15 || !val) {
        return result;
      }
    }

    if (xmlSchemaValPredefTypeNode(v14, a6, &y, a7))
    {
      if (val != a5) {
        xmlSchemaFreeValue(val);
      }
      return 0xFFFFFFFFLL;
    }

    int v16 = xmlSchemaCompareValues(val, y);
    if (val != a5) {
      xmlSchemaFreeValue(val);
    }
    xmlSchemaFreeValue(y);
    if (v16 == -2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v16 == 0;
    }
  }

  return result;
}

uint64_t xmlRelaxNGSchemaFacetCheck( int a1, xmlChar *name, const xmlChar *a3, const xmlChar *a4, const xmlChar *a5, xmlSchemaVal *a6)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (name && a5)
  {
    xmlSchemaTypePtr PredefinedType = xmlSchemaGetPredefinedType(name, (const xmlChar *)"http://www.w3.org/2001/XMLSchema");
    if (!PredefinedType) {
      return 0xFFFFFFFFLL;
    }
    char v13 = PredefinedType;
    xmlSchemaFacetPtr v14 = xmlSchemaNewFacet();
    if (!v14) {
      return 0xFFFFFFFFLL;
    }
    int v15 = v14;
    if (xmlStrEqual(a3, (const xmlChar *)"minInclusive"))
    {
      int v16 = 1000;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"minExclusive"))
    {
      int v16 = 1001;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"maxInclusive"))
    {
      int v16 = 1002;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"maxExclusive"))
    {
      int v16 = 1003;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"totalDigits"))
    {
      int v16 = 1004;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"fractionDigits"))
    {
      int v16 = 1005;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"pattern"))
    {
      int v16 = 1006;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"enumeration"))
    {
      int v16 = 1007;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"whiteSpace"))
    {
      int v16 = 1008;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"length"))
    {
      int v16 = 1009;
    }

    else if (xmlStrEqual(a3, (const xmlChar *)"maxLength"))
    {
      int v16 = 1010;
    }

    else
    {
      if (!xmlStrEqual(a3, (const xmlChar *)"minLength"))
      {
LABEL_30:
        xmlSchemaFreeFacet(v15);
        return 0xFFFFFFFFLL;
      }

      int v16 = 1011;
    }

    v15->unsigned int type = v16;
    v15->unsigned int value = a4;
    if (xmlSchemaCheckFacet(v15, v13, 0LL, name)) {
      goto LABEL_30;
    }
    int v17 = xmlSchemaValidateFacet(v13, v15, a5, a6);
    xmlSchemaFreeFacet(v15);
    if (v17) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void xmlRelaxNGSchemaFreeValue(int a1, xmlSchemaValPtr val)
{
}

uint64_t xmlRelaxNGDefaultTypeHave(int a1, xmlChar *str1)
{
  if (!str1) {
    return 0xFFFFFFFFLL;
  }
  if (xmlStrEqual(str1, (const xmlChar *)"string")) {
    return 1LL;
  }
  return xmlStrEqual(str1, (const xmlChar *)"token") != 0;
}

uint64_t xmlRelaxNGDefaultTypeCheck(int a1, xmlChar *str1, uint64_t a3)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  if (xmlStrEqual(str1, (const xmlChar *)"string")) {
    return 1LL;
  }
  return xmlStrEqual(str1, (const xmlChar *)"token") != 0;
}

uint64_t xmlRelaxNGDefaultTypeCompare( int a1, xmlChar *str1, xmlChar *a3, uint64_t a4, uint64_t a5, xmlChar *a6)
{
  if (xmlStrEqual(str1, (const xmlChar *)"string")) {
    return xmlStrEqual(a3, a6);
  }
  if (!xmlStrEqual(str1, (const xmlChar *)"token")) {
    return 0xFFFFFFFFLL;
  }
  if (!xmlStrEqual(a3, a6))
  {
    unsigned int v11 = xmlRelaxNGNormalize(0LL, a3);
    xmlGenericErrorFunc v12 = xmlRelaxNGNormalize(0LL, a6);
    char v13 = (xmlChar *)v12;
    if (v11 && v12)
    {
      uint64_t v10 = xmlStrEqual(v11, v12) != 0;
    }

    else
    {
      uint64_t v10 = 0xFFFFFFFFLL;
      if (!v11) {
        goto LABEL_12;
      }
    }

    xmlFree(v11);
LABEL_12:
    if (v13) {
      xmlFree(v13);
    }
    return v10;
  }

  return 1LL;
}

void xmlRelaxNGCleanupTypes(void)
{
  if (xmlRelaxNGTypeInitialized == 1)
  {
    xmlHashFree((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, (xmlHashDeallocator)xmlRelaxNGFreeTypeLibrary);
    xmlRelaxNGTypeInitialized = 0;
  }

void xmlRelaxNGFreeTypeLibrary(void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      xmlFree(v2);
    }
    xmlFree(a1);
  }

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewParserCtxt(const char *URL)
{
  if (!URL) {
    return 0LL;
  }
  uint64_t v2 = xmlMalloc(0x100uLL);
  unsigned int v3 = v2;
  if (v2)
  {
    v2[14] = 0u;
    v2[15] = 0u;
    v2[12] = 0u;
    v2[13] = 0u;
    v2[10] = 0u;
    v2[11] = 0u;
    v2[8] = 0u;
    v2[9] = 0u;
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    _OWORD *v2 = 0u;
    v2[1] = 0u;
    *((void *)v2 + 16) = xmlStrdup((const xmlChar *)URL);
    *((void *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *__xmlGenericError();
    *(void *)unsigned int v3 = *__xmlGenericErrorContext();
  }

  else
  {
    xmlRngPErrMemory(0LL, (const xmlChar *)"building parser\n");
  }

  return (xmlRelaxNGParserCtxtPtr)v3;
}

_DWORD *xmlRngPErrMemory(uint64_t a1, const xmlChar *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    a1 = *(void *)(a1 + 24);
    if (a1) {
      unsigned int v4 = 0LL;
    }
    else {
      unsigned int v4 = *(void (**)(void *, const char *, ...))(v3 + 8);
    }
    int v5 = *(void **)v3;
    ++*(_DWORD *)(v3 + 68);
    if (a2) {
      return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x12u,  2,  3,  0LL,  0,  a2,  0LL,  0LL,  0,  0,  "Memory allocation failed : %s\n",  (char)a2);
    }
    return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x12u,  2,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "Memory allocation failed\n",  v7);
  }

  unsigned int v4 = 0LL;
  int v5 = 0LL;
  if (!a2) {
    return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x12u,  2,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "Memory allocation failed\n",  v7);
  }
  return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x12u,  2,  3,  0LL,  0,  a2,  0LL,  0LL,  0,  0,  "Memory allocation failed : %s\n",  (char)a2);
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewMemParserCtxt(const char *buffer, int size)
{
  uint64_t v2 = 0LL;
  if (buffer && size >= 1)
  {
    int v5 = (xmlRelaxNGParserCtxt *)xmlMalloc(0x100uLL);
    uint64_t v2 = v5;
    if (v5)
    {
      *((_OWORD *)v5 + 14) = 0u;
      *((_OWORD *)v5 + 15) = 0u;
      *((_OWORD *)v5 + 12) = 0u;
      *((_OWORD *)v5 + 13) = 0u;
      *((_OWORD *)v5 + 10) = 0u;
      *((_OWORD *)v5 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
      *((_OWORD *)v5 + 8) = 0u;
      *((_OWORD *)v5 + 9) = 0u;
      *((_OWORD *)v5 + 6) = 0u;
      *((_OWORD *)v5 + 7) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      *((_OWORD *)v5 + 5) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *((_OWORD *)v5 + 3) = 0u;
      *(_OWORD *)int v5 = 0u;
      *((_OWORD *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
      *((void *)v5 + 20) = buffer;
      *((_DWORD *)v5 + 42) = size;
      *((void *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *__xmlGenericError();
      *(void *)uint64_t v2 = *__xmlGenericErrorContext();
    }

    else
    {
      xmlRngPErrMemory(0LL, (const xmlChar *)"building parser\n");
    }
  }

  return v2;
}

xmlRelaxNGParserCtxtPtr xmlRelaxNGNewDocParserCtxt(xmlDocPtr doc)
{
  if (!doc) {
    return 0LL;
  }
  xmlDocPtr v1 = xmlCopyDoc(doc, 1);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1;
  uint64_t v3 = (xmlRelaxNGParserCtxt *)xmlMalloc(0x100uLL);
  unsigned int v4 = v3;
  if (v3)
  {
    *((_OWORD *)v3 + 14) = 0u;
    *((_OWORD *)v3 + 15) = 0u;
    *((_OWORD *)v3 + 12) = 0u;
    *((_OWORD *)v3 + 13) = 0u;
    *((_OWORD *)v3 + 10) = 0u;
    *((_OWORD *)v3 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 9) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *(_OWORD *)uint64_t v3 = 0u;
    *((_OWORD *)v3 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
    *((void *)v3 + 17) = v2;
    *((_DWORD *)v3 + 63) = 1;
    *(void *)uint64_t v3 = *__xmlGenericErrorContext();
  }

  else
  {
    xmlRngPErrMemory(0LL, (const xmlChar *)"building parser\n");
    xmlFreeDoc(v2);
  }

  return v4;
}

void xmlRelaxNGFreeParserCtxt(xmlRelaxNGParserCtxtPtr ctxt)
{
  if (ctxt)
  {
    uint64_t v2 = (void *)*((void *)ctxt + 16);
    if (v2) {
      xmlFree(v2);
    }
    uint64_t v3 = (void *)*((void *)ctxt + 22);
    if (v3) {
      xmlRelaxNGFreeDocument(v3);
    }
    unsigned int v4 = (xmlHashTable *)*((void *)ctxt + 13);
    if (v4) {
      xmlHashFree(v4, 0LL);
    }
    int v5 = (void *)*((void *)ctxt + 14);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        xmlRelaxNGFreeDocument(v5);
        int v5 = v6;
      }

      while (v6);
    }

    char v7 = (void *)*((void *)ctxt + 15);
    if (v7)
    {
      do
      {
        signed int v8 = (void *)*v7;
        xmlRelaxNGFreeInclude(v7);
        char v7 = v8;
      }

      while (v8);
    }

    uint64_t v9 = (void *)*((void *)ctxt + 24);
    if (v9) {
      xmlFree(v9);
    }
    uint64_t v10 = (void *)*((void *)ctxt + 27);
    if (v10) {
      xmlFree(v10);
    }
    unsigned int v11 = (void *)*((void *)ctxt + 19);
    if (v11)
    {
      if (*((int *)ctxt + 36) >= 1)
      {
        uint64_t v12 = 0LL;
        do
          xmlRelaxNGFreeDefine(*(int **)(*((void *)ctxt + 19) + 8 * v12++));
        while (v12 < *((int *)ctxt + 36));
        unsigned int v11 = (void *)*((void *)ctxt + 19);
      }

      xmlFree(v11);
    }

    char v13 = (xmlDoc *)*((void *)ctxt + 17);
    if (v13)
    {
      if (*((_DWORD *)ctxt + 63)) {
        xmlFreeDoc(v13);
      }
    }

    xmlFree(ctxt);
  }

void xmlRelaxNGFreeDocument(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    xmlFree(v2);
  }
  uint64_t v3 = (xmlDoc *)a1[2];
  if (v3) {
    xmlFreeDoc(v3);
  }
  uint64_t v4 = a1[4];
  if (v4)
  {
    int v5 = *(xmlDoc **)(v4 + 16);
    if (v5) {
      xmlFreeDoc(v5);
    }
    uint64_t v6 = *(void **)(v4 + 72);
    if (v6)
    {
      if (*(int *)(v4 + 64) >= 1)
      {
        uint64_t v7 = 0LL;
        do
          xmlRelaxNGFreeDefine(*(int **)(*(void *)(v4 + 72) + 8 * v7++));
        while (v7 < *(int *)(v4 + 64));
        uint64_t v6 = *(void **)(v4 + 72);
      }

      xmlFree(v6);
    }

    xmlFree((void *)v4);
  }

  xmlFree(a1);
}

xmlRelaxNGPtr xmlRelaxNGParse(xmlRelaxNGParserCtxtPtr ctxt)
{
  if (!ctxt) {
    return 0LL;
  }
  uint64_t v2 = (const char *)*((void *)ctxt + 16);
  if (!v2)
  {
    signed int v8 = (const char *)*((void *)ctxt + 20);
    if (v8)
    {
      MemorxmlSchemaValPtr y = xmlReadMemory(v8, *((_DWORD *)ctxt + 42), 0LL, 0LL, 0);
      if (Memory)
      {
        Memory->URL = xmlStrdup((const xmlChar *)"in_memory_buffer");
        *((void *)ctxt + 16) = xmlStrdup((const xmlChar *)"in_memory_buffer");
        goto LABEL_9;
      }

      int v5 = "xmlRelaxNGParse: could not parse schemas\n";
      xmlRelaxNGParserCtxtPtr v6 = ctxt;
      int v7 = 1065;
    }

    else
    {
      MemorxmlSchemaValPtr y = (xmlDoc *)*((void *)ctxt + 17);
      if (Memory) {
        goto LABEL_9;
      }
      int v5 = "xmlRelaxNGParse: nothing to parse\n";
      xmlRelaxNGParserCtxtPtr v6 = ctxt;
      int v7 = 1022;
    }

    uint64_t v4 = 0LL;
    goto LABEL_32;
  }

  MemorxmlSchemaValPtr y = xmlReadFile(v2, 0LL, 0);
  if (!Memory)
  {
    uint64_t v4 = (const xmlChar *)*((void *)ctxt + 16);
    int v5 = "xmlRelaxNGParse: could not load %s\n";
    xmlRelaxNGParserCtxtPtr v6 = ctxt;
    int v7 = 1065;
LABEL_32:
    xmlRngPErr((uint64_t)v6, 0LL, v7, v5, v4, 0LL);
    return (xmlRelaxNGPtr)Memory;
  }

LABEL_9:
  *((void *)ctxt + 17) = Memory;
  uint64_t v9 = xmlRelaxNGCleanupDoc((uint64_t)ctxt, Memory);
  if (!v9)
  {
LABEL_21:
    xmlFreeDoc(*((xmlDocPtr *)ctxt + 17));
    MemorxmlSchemaValPtr y = 0LL;
LABEL_22:
    *((void *)ctxt + 17) = 0LL;
    return (xmlRelaxNGPtr)Memory;
  }

  uint64_t v10 = v9;
  xmlNodePtr RootElement = xmlDocGetRootElement(v9);
  if (!RootElement)
  {
    if (*((void *)ctxt + 16)) {
      char v13 = (const xmlChar *)*((void *)ctxt + 16);
    }
    else {
      char v13 = (const xmlChar *)"schemas";
    }
    xmlRngPErr((uint64_t)ctxt, (uint64_t)v10, 1022, "xmlRelaxNGParse: %s is empty\n", v13, 0LL);
    goto LABEL_21;
  }

  MemorxmlSchemaValPtr y = (xmlDoc *)xmlRelaxNGParseDocument((uint64_t)ctxt, (uint64_t)RootElement);
  if (!Memory)
  {
    xmlFreeDoc(*((xmlDocPtr *)ctxt + 17));
    goto LABEL_22;
  }

  uint64_t v12 = (xmlHashTable *)*((void *)ctxt + 13);
  if (v12) {
    xmlHashScan(v12, (xmlHashScanner)xmlRelaxNGComputeInterleaves, ctxt);
  }
  if (*((int *)ctxt + 17) >= 1)
  {
    xmlRelaxNGFree((xmlRelaxNGPtr)Memory);
    *((void *)ctxt + 17) = 0LL;
    xmlFreeDoc(v10);
    return 0LL;
  }

  uint64_t v14 = *(void *)&Memory->type;
  if (v14)
  {
    int v15 = *(_DWORD **)(v14 + 24);
    if (v15)
    {
      if (*v15 != 20)
      {
        int v16 = xmlRelaxNGNewDefine((uint64_t)ctxt, 0LL);
        uint64_t v17 = *(void *)&Memory->type;
        if (v16)
        {
          int v15 = v16;
          *(_DWORD *)int v16 = 20;
          *((void *)v16 + 6) = *(void *)(v17 + 24);
          *(void *)(v17 + 24) = v16;
        }

        else
        {
          int v15 = *(_DWORD **)(v17 + 24);
        }
      }

      xmlRelaxNGTryCompile((uint64_t)ctxt, (uint64_t)v15);
    }
  }

  Memory->name = (char *)v10;
  *((void *)ctxt + 17) = 0LL;
  __int128 v19 = *((_OWORD *)ctxt + 7);
  *((void *)ctxt + 14) = 0LL;
  *(_OWORD *)&Memory->next = v19;
  *((void *)ctxt + 15) = 0LL;
  LODWORD(Memory->doc) = *((_DWORD *)ctxt + 36);
  *(void *)&Memory->compression = *((void *)ctxt + 19);
  *((void *)ctxt + 19) = 0LL;
  if (*((_DWORD *)ctxt + 56) == 1) {
    LODWORD(Memory->children) = 1;
  }
  return (xmlRelaxNGPtr)Memory;
}

        if (!v8) {
          goto LABEL_15;
        }
        goto LABEL_10;
      }

      if (a2) {
        break;
      }
      uint64_t v9 = (xmlDtdPtr)v9->next;
      if (!v9) {
        return v8;
      }
    }

    uint64_t v10 = *(void *)(a2 + 80);
    if (v10 | v6)
    {
      xmlAddChild(parent, *(xmlNodePtr *)(a2 + 80));
      if (!v10) {
        goto LABEL_20;
      }
      goto LABEL_9;
    }

    unsigned int v11 = (xmlNode *)xmlCopyDtd(v5);
    if (!v11) {
      goto LABEL_20;
    }
    xmlRelaxNGParserCtxtPtr v6 = (uint64_t)v11;
    v11->xmlDocPtr doc = (_xmlDoc *)a2;
    v11->parent = parent;
    xmlAddChild(parent, v11);
    uint64_t v10 = v6;
    if (!v8)
    {
LABEL_15:
      int v7 = 0LL;
      signed int v8 = (xmlNode *)v10;
LABEL_16:
      *(void *)(v10 + 56) = v7;
      int v7 = v10;
      goto LABEL_17;
    }

  if (base)
  {
    uint64_t v10 = xmlCreateURI();
    signed int v8 = v10;
    if (!v10)
    {
LABEL_21:
      uint64_t v9 = 0LL;
LABEL_22:
      int v7 = 0LL;
      if (!v6) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }

    if (!xmlParse3986URIReference((uint64_t)v10, (unsigned __int8 *)base))
    {
      if (v4)
      {
        unsigned int v11 = xmlCreateURI();
        if (v11)
        {
          int v7 = v11;
          if (v6->scheme)
          {
            uint64_t v12 = v6;
LABEL_54:
            uint64_t v9 = xmlSaveUri(v12);
            goto LABEL_23;
          }

          if (v6->path || v6->authority || v6->server)
          {
            if (v8->scheme) {
              v11->scheme = xmlMemStrdup(v8->scheme);
            }
            query_uint64_t raw = v6->query_raw;
            if (query_raw)
            {
              v7->query_uint64_t raw = xmlMemStrdup(query_raw);
            }

            else
            {
              querxmlSchemaValPtr y = v6->query;
              if (query) {
                v7->querxmlSchemaValPtr y = xmlMemStrdup(query);
              }
            }

            fragment = v6->fragment;
            if (fragment) {
              v7->fragment = xmlMemStrdup(fragment);
            }
            authoritxmlSchemaValPtr y = v6->authority;
            if (authority)
            {
              v7->authoritxmlSchemaValPtr y = xmlMemStrdup(authority);
              goto LABEL_51;
            }

            server = v6->server;
            if (server)
            {
              v7->server = xmlMemStrdup(server);
              user = v6->user;
              if (user) {
                v7->user = xmlMemStrdup(user);
              }
              v7->int port = v6->port;
LABEL_51:
              path = v6->path;
              if (!path)
              {
LABEL_53:
                uint64_t v12 = v7;
                goto LABEL_54;
              }

    if (v6 == 37) {
      v5 += 3;
    }
    else {
      ++v5;
    }
  }

  if (v8 != 31)
  {
LABEL_21:
    if (v6 != 126) {
      goto LABEL_32;
    }
    goto LABEL_9;
  }

  if (!a1) {
    goto LABEL_30;
  }
  unsigned int v11 = *(void **)(a1 + 32);
  if (v11) {
    xmlFree(v11);
  }
  uint64_t v12 = (_DWORD)v5 - (_DWORD)v4;
  char v13 = (*(_BYTE *)(a1 + 72) & 2) != 0
      ? xmlStrndup(v4, v12)
      : (xmlChar *)xmlURIUnescapeString((const char *)v4, v12, 0LL);
  *(void *)(a1 + 32) = v13;
  if (*v5 != 64) {
    uint64_t v4 = *a2;
  }
  else {
LABEL_30:
  }
    uint64_t v4 = v5 + 1;
LABEL_32:
  int v33 = (unsigned __int8 *)v4;
  uint64_t v14 = *v4;
  if (v14 == 91)
  {
    int v15 = (unsigned __int8 *)(v4 + 1);
    while (1)
    {
      uint64_t v17 = *v15++;
      int v16 = v17;
      if (!v17) {
        return 1LL;
      }
      if (v16 == 93)
      {
        int v33 = v15;
        goto LABEL_64;
      }
    }
  }

  if (v14 - 48 > 9
    || xmlParse3986DecOctet(&v33)
    || *v33 != 46
    || (++v33, xmlParse3986DecOctet(&v33))
    || *v33 != 46
    || xmlParse3986DecOctet(&v33)
    || *v33 != 46
    || xmlParse3986DecOctet(&v33))
  {
    for (i = (unsigned __int8 *)v4; ; uint64_t v14 = *i)
    {
      if (v14 - 48 < 0xA || (v14 & 0xDF) - 65 < 0x1A) {
        goto LABEL_50;
      }
      __int128 v19 = v14 - 33;
      if (v19 == 4)
      {
        if ((i[1] - 48) >= 0xAu
          && ((char v20 = i[1] - 65, v20 > 0x25) || ((1LL << v20) & 0x3F0000003FLL) == 0)
          || (i[2] - 48) >= 0xAu
          && ((unint64_t v21 = i[2] - 65, v21 > 0x25) || ((1LL << v21) & 0x3F0000003FLL) == 0))
        {
LABEL_63:
          int v33 = i;
          break;
        }
      }

      else
      {
LABEL_62:
        if (v14 != 126) {
          goto LABEL_63;
        }
      }

  int v7 = *(void *)(a1 + 56);
  signed int v8 = *(_DWORD *)(a1 + 52);
  uint64_t v9 = v7 + 24LL * v8;
  *(void *)uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(_DWORD *)(a1 + 40) + 1;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(v9 + 12) = v10;
  unsigned int v11 = *(unsigned int *)(*(void *)(a1 + 8) + 40LL);
  if ((int)v11 >= 1)
  {
    uint64_t v12 = *(void **)(v7 + 24LL * v8 + 16);
    if (!v12)
    {
      uint64_t v12 = xmlMalloc(4 * v11);
      *(void *)(*(void *)(a1 + 56) + 24LL * *(int *)(a1 + 52) + 16) = v12;
      if (!v12)
      {
        xmlRegexpErrMemory(0LL, (uint64_t)"saving regexp");
        *(_DWORD *)a1 = -5;
        return;
      }

      LODWORD(v1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *(_DWORD *)(*(void *)(a1 + 8) + 40LL);
    }

    memcpy(v12, *(const void **)(a1 + 64), 4LL * (int)v11);
    signed int v8 = *(_DWORD *)(a1 + 52);
  }

  *(_DWORD *)(a1 + 52) = v8 + 1;
}

  if (a3) {
    unsigned int v11 = a3;
  }
  else {
    unsigned int v11 = a2;
  }
  if (str2)
  {
    signed int v8 = 3004LL;
    xmlSchemaCustomErr4( (_DWORD *)a1,  3004,  v11,  0LL,  (const xmlChar *)"References from this schema to components in the namespace '%s' are not allowed, since not indica ted by an import statement",  str2,  0LL,  0LL,  0LL);
  }

  else
  {
    signed int v8 = 3004LL;
    xmlSchemaCustomErr4( (_DWORD *)a1,  3004,  v11,  0LL,  (const xmlChar *)"References from this schema to components in no namespace are not allowed, since not indicated by an import statement",  0LL,  0LL,  0LL,  0LL);
  }

  return v8;
}

  xmlListPopFront(*((xmlListPtr *)writer + 1));
  return v5;
}

  xmlListPopFront(*((xmlListPtr *)writer + 1));
  return v5;
}

  xmlListPopFront(*((xmlListPtr *)writer + 1));
  return v5;
}

  xmlListPopFront(*((xmlListPtr *)writer + 1));
  return v5;
}

_DWORD *xmlRngPErr(uint64_t a1, uint64_t a2, int a3, const char *a4, const xmlChar *a5, xmlChar *a6)
{
  if (a1)
  {
    uint64_t v8 = a1;
    a1 = *(void *)(a1 + 24);
    if (a1) {
      uint64_t v9 = 0LL;
    }
    else {
      uint64_t v9 = *(void (**)(void *, const char *, ...))(v8 + 8);
    }
    uint64_t v10 = *(void **)v8;
    ++*(_DWORD *)(v8 + 68);
  }

  else
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
  }

  return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v9,  v10,  0LL,  a2,  0x12u,  a3,  2,  0LL,  0,  a5,  a6,  0LL,  0,  0,  a4,  (char)a5);
}

xmlDoc *xmlRelaxNGCleanupDoc(uint64_t a1, xmlDoc *doc)
{
  uint64_t v2 = doc;
  xmlNodePtr RootElement = xmlDocGetRootElement(doc);
  if (RootElement)
  {
    xmlRelaxNGCleanupTree(a1, (uint64_t)RootElement);
  }

  else
  {
    xmlRngPErr(a1, (uint64_t)v2, 1022, "xmlRelaxNGParse: %s is empty\n", *(const xmlChar **)(a1 + 128), 0LL);
    return 0LL;
  }

  return v2;
}

_OWORD *xmlRelaxNGParseDocument(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = xmlMalloc(0x50uLL);
  int v5 = v4;
  if (v4)
  {
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    *uint64_t v4 = 0u;
    uint64_t v6 = *(void *)(a1 + 80);
    *(void *)(a1 + 80) = 0LL;
    if (*(void *)(a2 + 72)
      && *(_DWORD *)(a2 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"grammar")
      && xmlStrEqual( *(const xmlChar **)(*(void *)(a2 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      int v7 = xmlRelaxNGParseGrammar(a1, *(void *)(a2 + 24));
      *((void *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v7;
      if (!v7) {
        goto LABEL_14;
      }
    }

    else
    {
      uint64_t v8 = xmlRelaxNGNewGrammar(a1);
      *((void *)v5 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v8;
      if (!v8)
      {
LABEL_14:
        xmlRelaxNGFree((xmlRelaxNGPtr)v5);
        return 0LL;
      }

      uint64_t v9 = *(void *)(a1 + 48);
      *(void *)uint64_t v8 = v9;
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 8);
        if (v10)
        {
          do
          {
            uint64_t v11 = v10;
            uint64_t v10 = *(void *)(v10 + 16);
          }

          while (v10);
          *(void *)(v11 + 16) = v8;
        }

        else
        {
          *(void *)(v9 + 8) = v8;
        }

        *(void *)(a1 + 48) = v8;
        xmlRelaxNGParseStart(a1, a2);
        *(void *)(a1 + 48) = v9;
      }

      else
      {
        *(void *)(a1 + 48) = v8;
        xmlRelaxNGParseStart(a1, a2);
      }
    }

    *(void *)(a1 + 80) = v6;
    uint64_t v12 = *(int **)(*((void *)v5 + 1) + 24LL);
    if (v12)
    {
      xmlRelaxNGCheckCycles(a1, v12, 0LL);
      if ((*(_BYTE *)(a1 + 64) & 0x80) == 0)
      {
        xmlRelaxNGSimplify(a1, *(void *)(*((void *)v5 + 1) + 24LL), 0LL);
        uint64_t v13 = *((void *)v5 + 1);
        for (uint64_t i = *(void *)(v13 + 24); i; *(void *)(v13 + 24) = i)
        {
          if (*(_DWORD *)i != -1) {
            break;
          }
          if (!*(void *)(i + 64)) {
            break;
          }
          uint64_t i = *(void *)(i + 48);
        }

        xmlRelaxNGCheckRules(a1, (unsigned int *)i, 16LL, -1);
      }
    }
  }

  else
  {
    xmlRngPErrMemory(a1, 0LL);
  }

  return v5;
}

void xmlRelaxNGComputeInterleaves(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 68)) {
    return;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    size_t v5 = 0LL;
    do
    {
      uint64_t v4 = *(void *)(v4 + 64);
      v5 += 8LL;
    }

    while (v4);
  }

  else
  {
    size_t v5 = 0LL;
  }

  uint64_t v6 = (char *)xmlMalloc(v5);
  if (!v6)
  {
    xmlRngPErrMemory(a2, (const xmlChar *)"in interleave computation\n");
    return;
  }

  int v7 = v6;
  uint64_t v8 = *(void *)(a1 + 48);
  if (!v8)
  {
    LODWORD(v9) = 0;
    int v10 = 0;
LABEL_18:
    uint64_t v12 = xmlMalloc(0x20uLL);
    if (!v12) {
      goto LABEL_60;
    }
    uint64_t v13 = v12;
    _OWORD *v12 = 0u;
    v12[1] = 0u;
    *(_DWORD *)uint64_t v12 = v9;
    *((void *)v12 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = xmlHashCreate(v9);
    int v35 = v10;
    if (!(_DWORD)v9)
    {
      int v17 = 1;
LABEL_69:
      *((void *)v13 + 3) = v7;
      *(void *)(a1 + 40) = v13;
      if (v35) {
        *(_WORD *)(a1 + 98) |= 8u;
      }
      if (v17 == 2)
      {
        int v34 = 3;
      }

      else
      {
        if (v17 != 1) {
          return;
        }
        int v34 = 1;
      }

      *((_DWORD *)v13 + 4) = v34;
      return;
    }

    unint64_t v14 = 0LL;
    unint64_t v15 = v9;
    uint64_t v36 = v7;
    int v37 = v7 + 8;
    uint64_t v16 = 1LL;
    int v17 = 1;
    while (1)
    {
      uint64_t v18 = *(void *)&v7[8 * v14++];
      unint64_t v19 = v15;
      if (v14 < v15)
      {
        char v20 = v37;
        do
        {
          if (*(void *)v20)
          {
            if (!xmlRelaxNGCompareElemDefLists( *(void *)(v18 + 16),  *(void ***)(*(void *)v20 + 16LL))) {
              xmlRngPErr(a2, *(void *)(a1 + 8), 1001, "Attributes conflicts in interleave\n", 0LL, 0LL);
            }
          }

          v20 += 8;
          --v15;
        }

        while (v16 != v15);
      }

      unint64_t v21 = *(uint64_t **)(v18 + 8);
      if (v21)
      {
        uint64_t v22 = *v21;
        if (*v21) {
          break;
        }
      }

      int v17 = 0;
      unint64_t v15 = v19;
LABEL_58:
      ++v16;
      int v7 = v36;
      v37 += 8;
      if (v14 == v15) {
        goto LABEL_69;
      }
    }

    uint64_t v23 = v21 + 1;
    unint64_t v15 = v19;
    while (*(_DWORD *)v22 != 4)
    {
      if (*(_DWORD *)v22 == 3)
      {
        uint64_t v24 = (xmlHashTable *)*((void *)v13 + 1);
        BOOL v25 = (const xmlChar *)"#text";
        goto LABEL_35;
      }

      int v17 = -1;
LABEL_55:
      uint64_t v30 = *v23++;
      uint64_t v22 = v30;
      if (!v30) {
        goto LABEL_58;
      }
    }

    BOOL v25 = *(const xmlChar **)(v22 + 16);
    uint64_t v26 = *(const xmlChar **)(v22 + 24);
    if (v25)
    {
      if (v26)
      {
        uint64_t v24 = (xmlHashTable *)*((void *)v13 + 1);
        if (!*v26) {
LABEL_35:
        }
          uint64_t v26 = 0LL;
        goto LABEL_55;
      }

      uint64_t v24 = (xmlHashTable *)*((void *)v13 + 1);
      goto LABEL_35;
    }

    if (v26)
    {
      uint64_t v27 = (xmlHashTable *)*((void *)v13 + 1);
      if (*v26) {
        goto LABEL_49;
      }
    }

    else
    {
      uint64_t v27 = (xmlHashTable *)*((void *)v13 + 1);
    }

    uint64_t v26 = 0LL;
LABEL_49:
    int v28 = xmlHashAddEntry2(v27, (const xmlChar *)"#any", v26, (void *)v14);
    if (*(void *)(*(v23 - 1) + 80)) {
      int v29 = 2;
    }
    else {
      int v29 = v17;
    }
    if (v28) {
      int v17 = -1;
    }
    else {
      int v17 = v29;
    }
    goto LABEL_55;
  }

  uint64_t v9 = 0LL;
  int v10 = 0;
  while (1)
  {
    uint64_t v11 = xmlMalloc(0x18uLL);
    *(void *)&v7[8 * v9] = v11;
    if (!v11) {
      break;
    }
    if (*(_DWORD *)v8 == 3) {
      ++v10;
    }
    *uint64_t v11 = v8;
    *(void *)(*(void *)&v7[8 * v9] + 8LL) = xmlRelaxNGGetElements(a2, (_DWORD *)v8, 2);
    *(void *)(*(void *)&v7[8 * v9++] + 16LL) = xmlRelaxNGGetElements(a2, (_DWORD *)v8, 1);
    uint64_t v8 = *(void *)(v8 + 64);
    if (!v8) {
      goto LABEL_18;
    }
  }

_OWORD *xmlRelaxNGNewDefine(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a1 + 148);
  if ((_DWORD)v4)
  {
    if ((int)v4 <= *(_DWORD *)(a1 + 144))
    {
      *(_DWORD *)(a1 + 148) = 2 * v4;
      size_t v5 = xmlRealloc(*(void **)(a1 + 152), 16 * v4);
      if (!v5) {
        goto LABEL_8;
      }
      *(void *)(a1 + 152) = v5;
    }
  }

  else
  {
    *(void *)(a1 + 144) = 0x1000000000LL;
    uint64_t v6 = xmlMalloc(0x80uLL);
    *(void *)(a1 + 152) = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  uint64_t result = xmlMalloc(0x70uLL);
  if (result)
  {
    result[5] = 0u;
    result[6] = 0u;
    result[3] = 0u;
    result[4] = 0u;
    result[1] = 0u;
    result[2] = 0u;
    *uint64_t result = 0u;
    uint64_t v8 = *(void *)(a1 + 152);
    uint64_t v9 = *(int *)(a1 + 144);
    *(_DWORD *)(a1 + 144) = v9 + 1;
    *(void *)(v8 + 8 * v9) = result;
    *((void *)result + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = a2;
    *((_WORD *)result + 48) = -1;
    return result;
  }

uint64_t xmlRelaxNGTryCompile(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a2;
  while (1)
  {
    int v4 = *(_DWORD *)v2;
    if ((*(_DWORD *)v2 | 0x10) == 0x14)
    {
      uint64_t result = xmlRelaxNGIsCompilable((int *)v2);
      if ((*(_WORD *)(v2 + 98) & 0x40) != 0 && *(__int16 *)(v2 + 96) != -25)
      {
        *(void *)(a1 + 232) = 0LL;
        return xmlRelaxNGCompile(a1, (int *)v2);
      }

      int v4 = *(_DWORD *)v2;
    }

    else
    {
      uint64_t result = 0LL;
    }

    unsigned int v6 = v4 + 1;
    if (v6 > 0x15) {
      return result;
    }
    if (v6) {
      break;
    }
    uint64_t v2 = *(void *)(v2 + 48);
    if (!v2) {
      return 0xFFFFFFFFLL;
    }
  }

  if (((1 << v6) & 0x1007FE) != 0) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(v2 + 48);
  if (v7)
  {
    while (1)
    {
      uint64_t result = xmlRelaxNGTryCompile(a1, v7);
      if ((_DWORD)result) {
        break;
      }
      uint64_t v7 = *(void *)(v7 + 64);
      if (!v7) {
        return 0LL;
      }
    }
  }

  return result;
}

void xmlRelaxNGSetParserErrors( xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc err, xmlRelaxNGValidityWarningFunc warn, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 2) = warn;
    *((void *)ctxt + 3) = 0LL;
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = err;
  }

int xmlRelaxNGGetParserErrors( xmlRelaxNGParserCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc *err, xmlRelaxNGValidityWarningFunc *warn, void **ctx)
{
  if (!ctxt) {
    return -1;
  }
  if (err) {
    *err = (xmlRelaxNGValidityErrorFunc)*((void *)ctxt + 1);
  }
  if (warn) {
    *warn = (xmlRelaxNGValidityWarningFunc)*((void *)ctxt + 2);
  }
  int v4 = 0;
  if (ctx) {
    *ctx = *(void **)ctxt;
  }
  return v4;
}

void xmlRelaxNGSetParserStructuredErrors( xmlRelaxNGParserCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 2) = 0LL;
    *((void *)ctxt + 3) = serror;
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0LL;
  }

void xmlRelaxNGDump(FILE *output, xmlRelaxNGPtr schema)
{
  if (output)
  {
    if (schema)
    {
      fwrite("RelaxNG: ", 9uLL, 1uLL, output);
      uint64_t v4 = *((void *)schema + 2);
      if (v4)
      {
        size_t v5 = *(const char **)(v4 + 136);
        if (v5) {
          fprintf(output, "%s\n", v5);
        }
        else {
          fputc(10, output);
        }
      }

      else
      {
        fwrite("no document\n", 0xCuLL, 1uLL, output);
      }

      uint64_t v8 = *((void *)schema + 1);
      if (v8)
      {
        fwrite("<grammar", 8uLL, 1uLL, output);
        fwrite(" xmlns=http://relaxng.org/ns/structure/1.0", 0x2CuLL, 1uLL, output);
        int v9 = *(_DWORD *)(v8 + 32);
        if (v9)
        {
          if (v9 == 2)
          {
            int v10 = " combine=interleave";
            size_t v11 = 21LL;
          }

          else if (v9 == 1)
          {
            int v10 = " combine=choice";
            size_t v11 = 17LL;
          }

          else
          {
            int v10 = " <!-- invalid combine value -->";
            size_t v11 = 31LL;
          }

          fwrite(v10, v11, 1uLL, output);
        }

        fwrite(">\n", 2uLL, 1uLL, output);
        if (*(void *)(v8 + 24))
        {
          fwrite("<start>\n", 8uLL, 1uLL, output);
          xmlRelaxNGDumpDefine(output, *(void *)(v8 + 24));
          uint64_t v12 = "</start>\n";
          size_t v13 = 9LL;
        }

        else
        {
          uint64_t v12 = " <!-- grammar had no start -->";
          size_t v13 = 30LL;
        }

        fwrite(v12, v13, 1uLL, output);
        unsigned int v6 = "</grammar>\n";
        size_t v7 = 11LL;
      }

      else
      {
        unsigned int v6 = "RelaxNG has no top grammar\n";
        size_t v7 = 27LL;
      }
    }

    else
    {
      unsigned int v6 = "RelaxNG empty or failed to compile\n";
      size_t v7 = 35LL;
    }

    fwrite(v6, v7, 1uLL, output);
  }

void xmlRelaxNGDumpTree(FILE *output, xmlRelaxNGPtr schema)
{
  if (output)
  {
    if (schema)
    {
      uint64_t v3 = (xmlDoc *)*((void *)schema + 2);
      if (v3)
      {
        xmlDocDump(output, v3);
        return;
      }

      uint64_t v4 = "no document\n";
      size_t v5 = 12LL;
    }

    else
    {
      uint64_t v4 = "RelaxNG empty or failed to compile\n";
      size_t v5 = 35LL;
    }

    fwrite(v4, v5, 1uLL, output);
  }

int xmlRelaxNGValidatePushElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v3 = -1;
  if (ctxt && elem)
  {
    xmlRelaxNGValidCtxtPtr v5 = ctxt;
    if (*((void *)ctxt + 17))
    {
LABEL_4:
      *((void *)v5 + 2htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = elem;
      *((_DWORD *)v5 + 40) = 0;
      ns = elem->ns;
      size_t v7 = (xmlRegExecCtxt *)*((void *)v5 + 17);
      name = elem->name;
      if (ns) {
        int v9 = xmlRegExecPushString2(v7, name, ns->href, v5);
      }
      else {
        int v9 = xmlRegExecPushString(v7, name, v5);
      }
      int v3 = v9;
      if ((v9 & 0x80000000) == 0)
      {
        int v17 = *((_DWORD *)v5 + 40);
        if (v17) {
          return (v17 >> 31) | 1;
        }
        else {
          return 0;
        }
      }

      uint64_t v16 = (xmlChar *)elem->name;
      ctxt = v5;
      int v15 = 38;
LABEL_19:
      xmlRelaxNGAddValidError((uint64_t)ctxt, v15, v16, 0LL, 0);
      return v3;
    }

    uint64_t v10 = *((void *)ctxt + 5);
    if (!v10 || (uint64_t v11 = *(void *)(v10 + 8)) == 0 || (v12 = *(void *)(v11 + 24)) == 0)
    {
      int v15 = 34;
      uint64_t v16 = 0LL;
      goto LABEL_19;
    }

    size_t v13 = *(xmlRegexp **)(v12 + 104);
    if (!v13)
    {
      int v3 = 0;
      *((void *)v5 + 22) = v12;
      return v3;
    }

    xmlRegExecCtxtPtr v14 = xmlRegNewExecCtxt(v13, (xmlRegExecCallbacks)xmlRelaxNGValidateProgressiveCallback, v5);
    if (v14)
    {
      xmlRelaxNGElemPush((uint64_t)v5, (uint64_t)v14);
      goto LABEL_4;
    }
  }

  return v3;
}

void xmlRelaxNGAddValidError(uint64_t a1, int a2, xmlChar *cur, xmlChar *a4, int a5)
{
  if (!a1 || (*(_DWORD *)(a1 + 56) & 8) != 0) {
    return;
  }
  if ((*(_DWORD *)(a1 + 56) & 3) == 1)
  {
    uint64_t v10 = *(char **)(a1 + 88);
    if (!v10)
    {
      *(void *)(a1 + 80) = 0x800000000LL;
      uint64_t v11 = (char *)xmlMalloc(0x140uLL);
      *(void *)(a1 + 88) = v11;
      if (!v11) {
        goto LABEL_25;
      }
      uint64_t v10 = v11;
      *(void *)(a1 + 72) = 0LL;
    }

    int v12 = *(_DWORD *)(a1 + 80);
    uint64_t v13 = *(int *)(a1 + 84);
    if (v12 < (int)v13)
    {
      xmlRegExecCtxtPtr v14 = *(char **)(a1 + 72);
      if (!v14) {
        goto LABEL_19;
      }
      goto LABEL_16;
    }

    *(_DWORD *)(a1 + 84) = 2 * v13;
    uint64_t v18 = (char *)xmlRealloc(v10, 80 * v13);
    *(void *)(a1 + 88) = v18;
    if (v18)
    {
      uint64_t v10 = v18;
      int v12 = *(_DWORD *)(a1 + 80);
      xmlRegExecCtxtPtr v14 = &v18[40 * v12 - 40];
      *(void *)(a1 + 72) = v14;
      if (!v14)
      {
LABEL_19:
        int v20 = v12;
        unint64_t v21 = (int *)&v10[40 * v12];
        *unint64_t v21 = a2;
        if (a5)
        {
          *(void *)&v10[40 * v12 + 24] = xmlStrdup(cur);
          a4 = xmlStrdup(a4);
          int v22 = 1;
        }

        else
        {
          int v22 = 0;
          *(void *)&v10[40 * v20 + 24] = cur;
        }

        uint64_t v23 = &v10[40 * v20];
        *((void *)v23 + 4) = a4;
        *((_DWORD *)v23 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = v22;
        uint64_t v24 = *(__int128 **)(a1 + 96);
        if (v24) {
          __int128 v25 = *v24;
        }
        else {
          __int128 v25 = 0uLL;
        }
        *(_OWORD *)&v10[40 * v20 + 8] = v25;
        *(void *)(a1 + 72) = v21;
        ++*(_DWORD *)(a1 + 80);
        return;
      }

void xmlRelaxNGValidateProgressiveCallback(int a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (!a4)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "callback on %s missing context\n", a2);
    return;
  }

  uint64_t v6 = *(void *)(a4 + 168);
  *(_DWORD *)(a4 + 160) = 1;
  if (!a3)
  {
    if (*a2 == 35) {
      return;
    }
    fprintf((FILE *)*MEMORY[0x1895F89D0], "callback on %s missing define\n");
    goto LABEL_23;
  }

  if (*(_DWORD *)a3 != 4)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "callback on %s define is not element\n");
LABEL_23:
    if (!*(_DWORD *)(a4 + 68)) {
      *(_DWORD *)(a4 + 68) = 37;
    }
    goto LABEL_27;
  }

  if (*(_DWORD *)(v6 + 8) != 1)
  {
    xmlRelaxNGAddValidError(a4, 23, 0LL, 0LL, 0);
    if ((*(_BYTE *)(a4 + 56) & 1) == 0) {
      xmlRelaxNGDumpValidError(a4);
    }
LABEL_27:
    *(_DWORD *)(a4 + 160) = -1;
    return;
  }

  size_t v7 = *(xmlRegexp **)(a3 + 104);
  if (!v7)
  {
    *(_DWORD *)(a4 + 160) = 0;
    *(void *)(a4 + 176) = a3;
    return;
  }

  xmlRegExecCtxtPtr v8 = xmlRegNewExecCtxt(v7, (xmlRegExecCallbacks)xmlRelaxNGValidateProgressiveCallback, (void *)a4);
  if (!v8) {
    goto LABEL_27;
  }
  xmlRelaxNGElemPush(a4, (uint64_t)v8);
  int v9 = xmlRelaxNGNewValidState(a4, v6);
  if (!v9) {
    goto LABEL_27;
  }
  uint64_t v10 = *(void *)(a4 + 96);
  *(void *)(a4 + 96) = v9;
  uint64_t v11 = *(void *)(a3 + 72);
  if (!v11) {
    goto LABEL_12;
  }
  int v12 = xmlRelaxNGValidateAttributeList(a4, v11);
  if (v12)
  {
    *(_DWORD *)(a4 + 160) = -1;
    xmlRelaxNGAddValidError(a4, 24, *(xmlChar **)(v6 + 16), 0LL, 0);
  }

  int v9 = *(void **)(a4 + 96);
  if (!v9)
  {
    uint64_t v13 = *(int **)(a4 + 104);
    if (v13)
    {
      int v14 = *(_DWORD *)(a4 + 56);
      int v15 = v14;
      if (*v13 < 1)
      {
LABEL_36:
        *(_DWORD *)(a4 + 56) = v15 | 1;
        xmlRelaxNGLogBestError(a4);
        char v18 = 1;
      }

      else
      {
        uint64_t v16 = 0LL;
        while (1)
        {
          uint64_t v17 = *(void *)(*((void *)v13 + 1) + 8 * v16);
          *(void *)(a4 + 96) = v17;
          *(void *)(v17 + 8) = 0LL;
          ++v16;
          uint64_t v13 = *(int **)(a4 + 104);
          if (v16 >= *v13)
          {
            int v15 = *(_DWORD *)(a4 + 56);
            goto LABEL_36;
          }
        }

        char v18 = 0;
      }

      unint64_t v19 = *(int **)(a4 + 104);
      if (*v19 >= 1)
      {
        uint64_t v20 = 0LL;
        do
        {
          xmlRelaxNGFreeValidState(a4, *(void **)(*((void *)v19 + 1) + 8 * v20++));
          unint64_t v19 = *(int **)(a4 + 104);
        }

        while (v20 < *v19);
      }

      xmlRelaxNGFreeStates(a4, (void **)v19);
      *(void *)(a4 + 104) = 0LL;
      char v21 = v18 ^ 1;
      if (v12) {
        char v21 = 1;
      }
      if ((v21 & 1) == 0) {
        *(_DWORD *)(a4 + 160) = -1;
      }
      *(_DWORD *)(a4 + 56) = v14;
    }
  }

  else
  {
LABEL_12:
    v9[1] = 0LL;
    xmlRelaxNGFreeValidState(a4, *(void **)(a4 + 96));
  }

  if (*(_DWORD *)(a4 + 160) == -1 && (*(_BYTE *)(a4 + 56) & 1) == 0) {
    xmlRelaxNGDumpValidError(a4);
  }
  *(void *)(a4 + 96) = v10;
}

_DWORD *xmlRelaxNGElemPush(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(_DWORD **)(a1 + 152);
  if (result || (*(_DWORD *)(a1 + 148) = 10, uint64_t result = xmlMalloc(0x50uLL), (*(void *)(a1 + 152) = result) != 0LL))
  {
    int v5 = *(_DWORD *)(a1 + 144);
    uint64_t v6 = *(int *)(a1 + 148);
    if (v5 < (int)v6)
    {
LABEL_6:
      *(_DWORD *)(a1 + 144) = v5 + 1;
      *(void *)&result[2 * v5] = a2;
      *(void *)(a1 + 136) = a2;
      return result;
    }

    *(_DWORD *)(a1 + 148) = 2 * v6;
    uint64_t result = xmlRealloc(result, 16 * v6);
    *(void *)(a1 + 152) = result;
    if (result)
    {
      int v5 = *(_DWORD *)(a1 + 144);
      goto LABEL_6;
    }
  }

  return xmlRngVErrMemory(a1, (const xmlChar *)"validating\n");
}

int xmlRelaxNGValidatePushCData(xmlRelaxNGValidCtxtPtr ctxt, const xmlChar *data, int len)
{
  int v3 = -1;
  if (ctxt)
  {
    if (data)
    {
      int v5 = (xmlRegExecCtxt *)*((void *)ctxt + 17);
      if (v5)
      {
        while (1)
        {
          unsigned int v6 = *data;
          if (v6 > 0x20) {
            goto LABEL_8;
          }
          if (((1LL << v6) & 0x100002600LL) == 0) {
            break;
          }
          ++data;
        }

        if (!*data) {
          return 1;
        }
LABEL_8:
        if ((xmlRegExecPushString(v5, (const xmlChar *)"#text", ctxt) & 0x80000000) == 0) {
          return 1;
        }
        xmlRelaxNGAddValidError((uint64_t)ctxt, 39, (xmlChar *)" TODO ", 0LL, 0);
        return -1;
      }
    }
  }

  return v3;
}

int xmlRelaxNGValidatePopElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  int v3 = -1;
  if (ctxt && elem && *((void *)ctxt + 17))
  {
    int v5 = *((_DWORD *)ctxt + 36);
    unsigned int v6 = v5 - 1;
    if (v5 < 1)
    {
      xmlRegExecCtxtPtr v8 = 0LL;
    }

    else
    {
      *((_DWORD *)ctxt + 36) = v6;
      uint64_t v7 = *((void *)ctxt + 19);
      xmlRegExecCtxtPtr v8 = *(xmlRegExecCtxt **)(v7 + 8LL * v6);
      *(void *)(v7 + 8LL * v6) = 0LL;
      if (v5 == 1) {
        uint64_t v9 = 0LL;
      }
      else {
        uint64_t v9 = *(void *)(*((void *)ctxt + 19) + 8LL * (v5 - 2));
      }
      *((void *)ctxt + 17) = v9;
    }

    int v10 = xmlRegExecPushString(v8, 0LL, 0LL);
    if (v10) {
      int v3 = (v10 >> 31) | 1;
    }
    else {
      xmlRelaxNGAddValidError((uint64_t)ctxt, 22, (xmlChar *)&byte_181A3ACBA, 0LL, 0);
    }
    xmlRegFreeExecCtxt(v8);
  }

  return v3;
}

int xmlRelaxNGValidateFullElement(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem)
{
  if (!ctxt) {
    return -1;
  }
  int v4 = -1;
  if (elem)
  {
    if (*((void *)ctxt + 22))
    {
      unsigned int v6 = xmlRelaxNGNewValidState((uint64_t)ctxt, (uint64_t)elem->parent);
      if (v6)
      {
        v6[1] = elem;
        *((void *)ctxt + 12) = v6;
        *((_DWORD *)ctxt + 17) = 0;
        if (!xmlRelaxNGValidateDefinition((uint64_t)ctxt, *((void *)ctxt + 22)))
        {
          if (*((_DWORD *)ctxt + 17)) {
            int v4 = -1;
          }
          else {
            int v4 = 1;
          }
        }

        xmlRelaxNGFreeValidState((uint64_t)ctxt, *((void **)ctxt + 12));
        *((void *)ctxt + 12) = 0LL;
      }
    }
  }

  return v4;
}

void *xmlRelaxNGNewValidState(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  memset(v18, 0, sizeof(v18));
  if (a2)
  {
    uint64_t v4 = *(void *)(a2 + 88);
    if (v4)
    {
      unint64_t v5 = 0LL;
      do
      {
        if (v5 <= 0x13) {
          *((void *)v18 + v5) = v4;
        }
        ++v5;
        uint64_t v4 = *(void *)(v4 + 48);
      }

      while (v4);
      xmlNodePtr v6 = 0LL;
    }

    else
    {
      LODWORD(v5) = 0;
      xmlNodePtr v6 = 0LL;
    }
  }

  else
  {
    xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(a1 + 48));
    if (!RootElement) {
      return 0LL;
    }
    xmlNodePtr v6 = RootElement;
    LODWORD(v5) = 0;
  }

  uint64_t v8 = *(void *)(a1 + 112);
  if (v8 && (unsigned int v9 = *(_DWORD *)v8 - 1, *(int *)v8 >= 1))
  {
    *(_DWORD *)uint64_t v8 = v9;
    int v10 = *(void **)(*(void *)(v8 + 8) + 8LL * v9);
  }

  else
  {
    uint64_t v11 = xmlMalloc(0x38uLL);
    int v10 = v11;
    if (!v11) {
      goto LABEL_30;
    }
    v11[6] = 0LL;
    *((_OWORD *)v11 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *(_OWORD *)uint64_t v11 = 0u;
  }

  v10[4] = 0LL;
  v10[5] = 0LL;
  if (a2)
  {
    xmlNodePtr v6 = *(xmlNodePtr *)(a2 + 24);
    uint64_t v12 = a2;
  }

  else
  {
    uint64_t v12 = *(void *)(a1 + 48);
  }

  *int v10 = v12;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = 0;
  if (!(_DWORD)v5) {
    goto LABEL_34;
  }
  uint64_t v13 = (void *)v10[6];
  if (v13)
  {
    uint64_t v13 = xmlRealloc(v13, 8LL * v5);
    if (v13)
    {
      v10[6] = v13;
      *((_DWORD *)v10 + 5) = v5;
LABEL_28:
      *((_DWORD *)v10 + 4) = v5;
      if (v5 > 0x13)
      {
        uint64_t v15 = *(void *)(a2 + 88);
        if (v15)
        {
          uint64_t v16 = 0LL;
          do
          {
            *(void *)(v10[6] + v16) = v15;
            uint64_t v15 = *(void *)(v15 + 48);
            v16 += 8LL;
          }

          while (v15);
        }
      }

      else
      {
        memcpy(v13, v18, 8LL * v5);
        LODWORD(v5) = *((_DWORD *)v10 + 4);
      }

uint64_t xmlRelaxNGValidateDefinition(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (int **)(a1 + 96);
  if (*(void *)(a1 + 96) && *(void *)(a1 + 104))
  {
    xmlGenericErrorFunc v5 = *__xmlGenericError();
    xmlNodePtr v6 = __xmlGenericErrorContext();
    v5(*v6, "Unimplemented block at %s:%d\n", "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c", 10667);
    xmlRelaxNGFreeValidState(a1, *(void **)(a1 + 96));
    *(void *)(a1 + 96) = 0LL;
  }

  uint64_t v8 = (int **)(a1 + 104);
  uint64_t v7 = *(int **)(a1 + 104);
  if (!v7) {
    goto LABEL_7;
  }
  int v9 = *v7;
  if (*v7 != 1)
  {
    *(void *)(a1 + 104) = 0LL;
    int v14 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = v14 | 1;
    if (v9 <= 0)
    {
      *(_DWORD *)(a1 + 56) = v14;
      goto LABEL_47;
    }

    int v33 = v14;
    uint64_t v15 = 0LL;
    int v16 = 0;
    uint64_t v17 = 0LL;
    while (1)
    {
      *(void *)(a1 + 96) = *(void *)(*((void *)v7 + 1) + 8 * v15);
      *(void *)(a1 + 104) = 0LL;
      int v18 = xmlRelaxNGValidateState(a1, a2);
      uint64_t v19 = *(void **)(a1 + 96);
      if (v19 && *v8)
      {
        xmlGenericErrorFunc v20 = *__xmlGenericError();
        char v21 = __xmlGenericErrorContext();
        v20( *v21,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/relaxng.c",  10704);
        xmlRelaxNGFreeValidState(a1, *(void **)(a1 + 96));
        uint64_t v19 = 0LL;
        *(void *)(a1 + 96) = 0LL;
      }

      if (!v18) {
        break;
      }
      if (v19)
      {
        xmlRelaxNGFreeValidState(a1, v19);
        goto LABEL_21;
      }

      uint64_t v26 = *v8;
      if (*v8)
      {
        if (*v26 >= 1)
        {
          uint64_t v27 = 0LL;
          do
          {
            xmlRelaxNGFreeValidState(a1, *(void **)(*((void *)v26 + 1) + 8 * v27++));
            uint64_t v26 = *(int **)(a1 + 104);
          }

          while (v27 < *v26);
        }

        uint64_t v25 = a1;
        goto LABEL_33;
      }

void xmlRelaxNGFreeValidState(uint64_t a1, void *a2)
{
  if (a2)
  {
    if (a1
      && ((uint64_t v4 = *(void **)(a1 + 112)) != 0LL || (uint64_t v4 = xmlRelaxNGNewStates(a1, 40), (*(void *)(a1 + 112) = v4) != 0LL)))
    {
      int v5 = *(_DWORD *)v4;
      uint64_t v6 = *((int *)v4 + 1);
      if (*(_DWORD *)v4 >= (int)v6)
      {
        uint64_t v7 = xmlRealloc((void *)v4[1], 16 * v6);
        if (!v7)
        {
          xmlRngVErrMemory(a1, (const xmlChar *)"adding states\n");
          return;
        }

        v4[1] = v7;
        *((_DWORD *)v4 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 2 * v6;
        int v5 = *(_DWORD *)v4;
      }

      else
      {
        uint64_t v7 = (void *)v4[1];
      }

      *(_DWORD *)uint64_t v4 = v5 + 1;
      v7[v5] = a2;
    }

    else
    {
      uint64_t v8 = (void *)a2[6];
      if (v8) {
        xmlFree(v8);
      }
      xmlFree(a2);
    }
  }

xmlRelaxNGValidCtxtPtr xmlRelaxNGNewValidCtxt(xmlRelaxNGPtr schema)
{
  uint64_t v2 = xmlMalloc(0xC0uLL);
  int v3 = v2;
  if (v2)
  {
    v2[10] = 0u;
    v2[11] = 0u;
    v2[8] = 0u;
    v2[9] = 0u;
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    _OWORD *v2 = 0u;
    v2[1] = 0u;
    *((void *)v2 + 5) = schema;
    *((void *)v2 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *__xmlGenericError();
    *(void *)int v3 = *__xmlGenericErrorContext();
    *((void *)v3 + 10) = 0LL;
    *((void *)v3 + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0LL;
    *((void *)v3 + 9) = 0LL;
    if (schema) {
      *((_DWORD *)v3 + 16) = *((_DWORD *)schema + 6);
    }
    *((void *)v3 + 16) = 0LL;
    *((_DWORD *)v3 + 17) = 0;
    *((void *)v3 + 13) = 0LL;
    *((void *)v3 + 14) = 0LL;
  }

  else
  {
    xmlRngVErrMemory(0LL, (const xmlChar *)"building context\n");
  }

  return (xmlRelaxNGValidCtxtPtr)v3;
}

_DWORD *xmlRngVErrMemory(uint64_t a1, const xmlChar *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    a1 = *(void *)(a1 + 24);
    if (a1) {
      uint64_t v4 = 0LL;
    }
    else {
      uint64_t v4 = *(void (**)(void *, const char *, ...))(v3 + 8);
    }
    int v5 = *(void **)v3;
    ++*(_DWORD *)(v3 + 32);
    if (a2) {
      return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x13u,  2,  3,  0LL,  0,  a2,  0LL,  0LL,  0,  0,  "Memory allocation failed : %s\n",  (char)a2);
    }
    return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x13u,  2,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "Memory allocation failed\n",  v7);
  }

  uint64_t v4 = 0LL;
  int v5 = 0LL;
  if (!a2) {
    return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x13u,  2,  3,  0LL,  0,  0LL,  0LL,  0LL,  0,  0,  "Memory allocation failed\n",  v7);
  }
  return __xmlRaiseError( (xmlStructuredErrorFunc)a1,  v4,  v5,  0LL,  0LL,  0x13u,  2,  3,  0LL,  0,  a2,  0LL,  0LL,  0,  0,  "Memory allocation failed : %s\n",  (char)a2);
}

void xmlRelaxNGFreeValidCtxt(xmlRelaxNGValidCtxtPtr ctxt)
{
  if (ctxt)
  {
    uint64_t v2 = (void **)*((void *)ctxt + 13);
    if (v2)
    {
      xmlFree(v2[1]);
      xmlFree(v2);
    }

    uint64_t v3 = (void *)*((void *)ctxt + 14);
    if (v3)
    {
      int v4 = *(_DWORD *)v3;
      if (*(int *)v3 >= 1)
      {
        uint64_t v5 = 0LL;
        do
        {
          uint64_t v6 = *(void **)(*((void *)v3 + 1) + 8 * v5);
          if (v6)
          {
            char v7 = (void *)v6[6];
            if (v7) {
              xmlFree(v7);
            }
            xmlFree(v6);
            uint64_t v3 = (void *)*((void *)ctxt + 14);
            int v4 = *(_DWORD *)v3;
          }

          ++v5;
        }

        while (v5 < v4);
      }

      xmlFree(*((void **)v3 + 1));
      xmlFree(v3);
    }

    uint64_t v8 = (void *)*((void *)ctxt + 16);
    if (v8)
    {
      int v9 = *((_DWORD *)ctxt + 30);
      if (v9 >= 1)
      {
        for (uint64_t i = 0LL; i < v9; ++i)
        {
          xmlGenericErrorFunc v11 = *(void ***)(*((void *)ctxt + 16) + 8 * i);
          if (v11)
          {
            xmlFree(v11[1]);
            xmlFree(v11);
            int v9 = *((_DWORD *)ctxt + 30);
          }
        }

        uint64_t v8 = (void *)*((void *)ctxt + 16);
      }

      xmlFree(v8);
    }

    uint64_t v12 = (void *)*((void *)ctxt + 11);
    if (v12) {
      xmlFree(v12);
    }
    uint64_t v13 = *((void *)ctxt + 19);
    if (v13)
    {
      int v14 = *((_DWORD *)ctxt + 36);
      unsigned int v15 = v14 - 1;
      if (v14 >= 1)
      {
        *((_DWORD *)ctxt + 36) = v15;
        int v16 = *(xmlRegExecCtxt **)(v13 + 8LL * v15);
        *(void *)(v13 + 8LL * v15) = 0LL;
        if (v14 == 1) {
          goto LABEL_28;
        }
        uint64_t v17 = *(void *)(*((void *)ctxt + 19) + 8LL * (v14 - 2));
        while (1)
        {
          *((void *)ctxt + 17) = v17;
          if (!v16) {
            break;
          }
          xmlRegFreeExecCtxt(v16);
          int v18 = *((_DWORD *)ctxt + 36);
          unsigned int v19 = v18 - 1;
          if (v18 < 1) {
            break;
          }
          *((_DWORD *)ctxt + 36) = v19;
          uint64_t v20 = *((void *)ctxt + 19);
          int v16 = *(xmlRegExecCtxt **)(v20 + 8LL * v19);
          *(void *)(v20 + 8LL * v19) = 0LL;
          if (v18 == 1) {
LABEL_28:
          }
            uint64_t v17 = 0LL;
          else {
            uint64_t v17 = *(void *)(*((void *)ctxt + 19) + 8LL * (v18 - 2));
          }
        }
      }

      xmlFree(*((void **)ctxt + 19));
    }

    xmlFree(ctxt);
  }

void xmlRelaxNGFreeStates(uint64_t a1, void **a2)
{
  if (a2)
  {
    if (a1)
    {
      int v4 = *(void **)(a1 + 128);
      if (v4)
      {
        uint64_t v5 = *(int *)(a1 + 124);
        if (*(_DWORD *)(a1 + 120) < (int)v5)
        {
LABEL_9:
          uint64_t v6 = *(int *)(a1 + 120);
          *(_DWORD *)(a1 + 120) = v6 + 1;
          v4[v6] = a2;
          return;
        }

        int v4 = xmlRealloc(v4, 16 * v5);
        if (v4)
        {
          *(void *)(a1 + 128) = v4;
          *(_DWORD *)(a1 + 124) *= 2;
          goto LABEL_9;
        }

        xmlRngVErrMemory(a1, (const xmlChar *)"storing states\n");
      }

      else
      {
        *(void *)(a1 + 120) = 0x2800000000LL;
        int v4 = xmlMalloc(0x140uLL);
        *(void *)(a1 + 128) = v4;
        if (v4) {
          goto LABEL_9;
        }
        xmlRngVErrMemory(a1, (const xmlChar *)"storing states\n");
        int v4 = *(void **)(a1 + 128);
        if (v4) {
          goto LABEL_9;
        }
      }
    }

    xmlFree(a2[1]);
    xmlFree(a2);
  }

void xmlRelaxNGSetValidErrors( xmlRelaxNGValidCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc err, xmlRelaxNGValidityWarningFunc warn, void *ctx)
{
  if (ctxt)
  {
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = err;
    *((void *)ctxt + 2) = warn;
    *((void *)ctxt + 3) = 0LL;
  }

void xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt, xmlStructuredErrorFunc serror, void *ctx)
{
  if (ctxt)
  {
    *((void *)ctxt + 2) = 0LL;
    *((void *)ctxt + 3) = serror;
    *(void *)ctxt = ctx;
    *((void *)ctxt + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0LL;
  }

int xmlRelaxNGGetValidErrors( xmlRelaxNGValidCtxtPtr ctxt, xmlRelaxNGValidityErrorFunc *err, xmlRelaxNGValidityWarningFunc *warn, void **ctx)
{
  if (!ctxt) {
    return -1;
  }
  if (err) {
    *err = (xmlRelaxNGValidityErrorFunc)*((void *)ctxt + 1);
  }
  if (warn) {
    *warn = (xmlRelaxNGValidityWarningFunc)*((void *)ctxt + 2);
  }
  int v4 = 0;
  if (ctx) {
    *ctx = *(void **)ctxt;
  }
  return v4;
}

int xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
  int result = -1;
  if (ctxt && doc)
  {
    *((void *)ctxt + 6) = doc;
    uint64_t v5 = *((void *)ctxt + 5);
    if (v5)
    {
      *((_DWORD *)ctxt + 17) = 0;
      uint64_t v6 = *(void *)(v5 + 8);
      if (v6)
      {
        char v7 = xmlRelaxNGNewValidState((uint64_t)ctxt, 0LL);
        *((void *)ctxt + 12) = v7;
        int v8 = xmlRelaxNGValidateDefinition((uint64_t)ctxt, *(void *)(v6 + 24));
        uint64_t v9 = *((void *)ctxt + 12);
        if (v9 && v7[1])
        {
        }

        else
        {
          uint64_t v10 = (int *)*((void *)ctxt + 13);
          if (!v10) {
            goto LABEL_25;
          }
          if (*v10 < 1)
          {
            BOOL v14 = 1;
          }

          else
          {
            uint64_t v11 = 0LL;
            int v12 = -1;
            do
            {
              uint64_t v13 = *(void **)(*((void *)v10 + 1) + 8 * v11);
              xmlRelaxNGFreeValidState((uint64_t)ctxt, v13);
              ++v11;
              uint64_t v10 = (int *)*((void *)ctxt + 13);
            }

            while (v11 < *v10);
            BOOL v14 = v12 == -1;
          }

          if (!v14 || v8 == -1)
          {
LABEL_25:
            uint64_t v17 = (void *)*((void *)ctxt + 12);
            if (v17)
            {
              xmlRelaxNGFreeValidState((uint64_t)ctxt, v17);
              *((void *)ctxt + 12) = 0LL;
            }

            if (v8)
            {
              xmlRelaxNGDumpValidError((uint64_t)ctxt);
              if (*((_DWORD *)ctxt + 16) != 1)
              {
                int v15 = v8;
                goto LABEL_39;
              }
            }

            else if (*((_DWORD *)ctxt + 16) != 1)
            {
              goto LABEL_36;
            }

            memset(&v24.node, 0, 88);
            v24.int valid = 1;
            v24.warning = (xmlValidityWarningFunc)*((void *)ctxt + 2);
            *(_OWORD *)&v24.userData = *(_OWORD *)ctxt;
            int v18 = xmlValidateDocumentFinal(&v24, doc);
            if (v18 == 1) {
              int v15 = v8;
            }
            else {
              int v15 = -1;
            }
            if (v8 || v18 != 1)
            {
LABEL_39:
              xmlElementType type = doc->type;
              if (type != XML_HTML_DOCUMENT_NODE && type != XML_DOCUMENT_NODE)
              {
                if (type != XML_ELEMENT_NODE)
                {
LABEL_54:
                  if (v15 == -1) {
                    return 1;
                  }
                  else {
                    return v15;
                  }
                }

                doc->version = 0LL;
              }

              xmlNodePtr children = doc->children;
              if (children)
              {
                while (1)
                {
                  do
                  {
                    xmlDocPtr v22 = (xmlDocPtr)children;
                    if (children->type != XML_ELEMENT_NODE) {
                      break;
                    }
                    children->psvuint64_t i = 0LL;
                    xmlNodePtr children = children->children;
                  }

                  while (children);
                  while (1)
                  {
                    xmlNodePtr children = v22->next;
                    if (children) {
                      break;
                    }
                    xmlDocPtr v22 = (xmlDocPtr)v22->parent;
                    if (v22) {
                      BOOL v23 = v22 == doc;
                    }
                    else {
                      BOOL v23 = 1;
                    }
                    if (v23) {
                      goto LABEL_54;
                    }
                  }
                }
              }

              goto LABEL_54;
            }

void xmlRelaxNGFreeInclude(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    xmlFree(v2);
  }
  uint64_t v3 = (xmlDoc *)a1[2];
  if (v3) {
    xmlFreeDoc(v3);
  }
  int v4 = (xmlRelaxNG *)a1[4];
  if (v4) {
    xmlRelaxNGFree(v4);
  }
  xmlFree(a1);
}

void xmlRelaxNGFreePartition(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)*((void *)a1 + 3);
    if (v2)
    {
      int v3 = *(_DWORD *)a1;
      if (*(int *)a1 >= 1)
      {
        uint64_t v4 = 0LL;
        do
        {
          uint64_t v5 = *(void **)(*((void *)a1 + 3) + 8 * v4);
          if (v5)
          {
            uint64_t v6 = (void *)v5[1];
            if (v6) {
              xmlFree(v6);
            }
            char v7 = (void *)v5[2];
            if (v7) {
              xmlFree(v7);
            }
            xmlFree(v5);
            int v3 = *(_DWORD *)a1;
          }

          ++v4;
        }

        while (v4 < v3);
        uint64_t v2 = (void *)*((void *)a1 + 3);
      }

      xmlFree(v2);
    }

    int v8 = (xmlHashTable *)*((void *)a1 + 1);
    if (v8) {
      xmlHashFree(v8, 0LL);
    }
    xmlFree(a1);
  }

_BYTE *xmlRelaxNGNormalize(uint64_t a1, _BYTE *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = a2;
  uint64_t v4 = 0LL;
  uint64_t v5 = a2;
  do
  {
    int v6 = *v5++;
    v4 += 0x100000000LL;
  }

  while (v6);
  int result = xmlMallocAtomic(v4 >> 32);
  if (result)
  {
    while (1)
    {
      unsigned int v8 = *v2;
      if (v8 > 0x20 || ((1LL << v8) & 0x100002600LL) == 0) {
        break;
      }
      ++v2;
    }

    for (uint64_t i = result; ; ++i)
    {
      if (((1LL << v8) & 0x100002600LL) == 0) {
        break;
      }
      while (v8 <= 0x20u)
      {
        if (((1LL << v8) & 0x100002600LL) == 0)
        {
          if (!(_BYTE)v8) {
            goto LABEL_21;
          }
          break;
        }

        char v11 = *++v2;
        LOBYTE(v8) = v11;
      }

      LOBYTE(v8) = 32;
LABEL_20:
      *uint64_t i = v8;
      LOBYTE(v8) = *v2;
    }

    if (!(_BYTE)v8)
    {
LABEL_21:
      *uint64_t i = 0;
      return result;
    }

void xmlRelaxNGCleanupTree(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = a2;
  while (1)
  {
LABEL_3:
    uint64_t v6 = v5;
    if (v4)
    {
      xmlUnlinkNode(v4);
      xmlFreeNode(v4);
    }

    int v7 = *(_DWORD *)(v6 + 8);
    unsigned int v8 = *(_BYTE **)(v6 + 80);
    if (v8)
    {
      while (1)
      {
        unsigned int v9 = *v8;
        if (v9 > 0x20) {
          break;
        }
        if (((1LL << v9) & 0x100002600LL) == 0)
        {
          if (*v8) {
            break;
          }
          goto LABEL_51;
        }

        ++v8;
      }

LABEL_69:
  if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"externalRef"))
  {
    if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"include"))
    {
      Prop = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"href");
      if (Prop)
      {
        int v43 = Prop;
        Base = xmlNodeGetBase(*(const xmlDoc **)(v6 + 64), (const xmlNode *)v6);
        BOOL v44 = xmlBuildURI(v43, Base);
        if (!v44)
        {
          xmlRngPErr(a1, v6, 1041, "Failed to compute URL for include %s\n", v43, 0LL);
          xmlFree(v43);
          uint64_t v4 = (xmlNode *)v6;
          if (!Base) {
            goto LABEL_257;
          }
          goto LABEL_98;
        }

        xmlDocPtr doc = (xmlDoc *)v44;
        xmlFree(v43);
        if (Base) {
          xmlFree(Base);
        }
        uint64_t v45 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
        int v46 = (xmlChar *)doc;
        if (!v45)
        {
          uint64_t v47 = v6;
          while (1)
          {
            uint64_t v47 = *(void *)(v47 + 40);
            if (!v47 || *(_DWORD *)(v47 + 8) != 1) {
              break;
            }
            uint64_t v48 = xmlGetProp((const xmlNode *)v47, (const xmlChar *)"ns");
            if (v48)
            {
              uint64_t v45 = v48;
              goto LABEL_144;
            }
          }

          uint64_t v45 = 0LL;
        }

LABEL_144:
        if (*(int *)(a1 + 208) >= 1)
        {
          uint64_t v75 = 0LL;
          while (!xmlStrEqual( *(const xmlChar **)(*(void *)(*(void *)(a1 + 216) + 8 * v75) + 8LL),  (const xmlChar *)doc))
          {
          }

          uint64_t v84 = a1;
          uint64_t v85 = 0LL;
          int v86 = 1044;
          int v87 = "Detected an Include recursion for %s\n";
          goto LABEL_220;
        }

            xmlSchemaPIllegalAttrErr((_DWORD *)a1, v79);
            goto LABEL_150;
          }

    xmlFree((void *)*v81);
    void *v81 = 0LL;
    return 0xFFFFFFFFLL;
  }

  while ((int)v79 < 1)
  {
LABEL_43:
    uint64_t v75 = (void **)*v75;
    if (!v75) {
      goto LABEL_44;
    }
  }

  BOOL v23 = 0LL;
  xmlValidCtxt v24 = *(void *)(*(void *)(*v80 + 8LL * *((int *)v75 + 2)) + 8LL);
  while (1)
  {
    int result = xmlSchemaAreValuesEqual( *(xmlSchemaValPtr *)(*(void *)(*v81 + v23) + 8LL),  *(xmlSchemaVal **)(*(void *)(v24 + v23) + 8LL));
    if ((_DWORD)result == -1) {
      return result;
    }
    if (!(_DWORD)result) {
      goto LABEL_43;
    }
    v23 += 8LL;
    if (8 * v79 == v23)
    {
      uint64_t v83 = 0LL;
      name = 0LL;
      uint64_t v67 = xmlSchemaFormatIDCKeySequence_1((_DWORD *)a1, &name, *v81, v79, 0);
      int v68 = xmlSchemaGetComponentDesignation(&v83, (int *)v17);
      xmlSchemaCustomErr4( (_DWORD *)a1,  1877,  0LL,  (_DWORD *)v17,  (const xmlChar *)"Duplicate key-sequence %s in %s",  v67,  v68,  0LL,  0LL);
      if (name) {
        xmlFree(name);
      }
      if (v83) {
        xmlFree(v83);
      }
      goto LABEL_108;
    }
  }

            if (xmlXPathNodeSetAddUnique(cur, (xmlNodePtr)v43) < 0) {
              v5->error = 15;
            }
            uint64_t v45 = v46;
            if ((v76 & 1) != 0)
            {
LABEL_179:
              if (val)
              {
                xmlSchemaValPtr val = (xmlNodeSetPtr)v81((unsigned int *)val, &cur->nodeNr);
                goto LABEL_184;
              }

              xmlSchemaValPtr val = cur;
LABEL_183:
              xmlDocPtr cur = 0LL;
              goto LABEL_184;
            }

LABEL_217:
                  int v77 = v140;
LABEL_221:
                  if (v45) {
                    xmlFree(v45);
                  }
                  if (v77)
                  {
                    xmlFree(v46);
                    *(void *)(v6 + 104) = v77;
                    goto LABEL_225;
                  }

                  xmlRngPErr(a1, v6, 1043, "Failed to load include %s\n", v46, 0LL);
                  ((void (*)(xmlChar *))xmlFree)(v46);
LABEL_256:
                  uint64_t v4 = (xmlNode *)v6;
                  goto LABEL_257;
                }
              }
            }
          }

          uint64_t v84 = a1;
          uint64_t v85 = v6;
          int v86 = 1038;
          int v87 = "xmlRelaxNG: included document %s root is not a grammar\n";
        }

        else
        {
          uint64_t v84 = a1;
          uint64_t v85 = v6;
          int v86 = 1022;
          int v87 = "xmlRelaxNG: included document is empty %s\n";
        }

      xmlNodePtr children = children->next;
      if (!children) {
        goto LABEL_218;
      }
      while (children->ns
           && xmlStrEqual(children->name, (const xmlChar *)"annotation")
           && xmlStrEqual(children->ns->href, (const xmlChar *)"http://www.w3.org/2001/XMLSchema"))
      {
        __int128 v74 = xmlSchemaParseAnnotation((_DWORD *)a1, (uint64_t)children, 1);
        if (*(void *)(a2 + 40))
        {
          if (v74)
          {
            uint64_t v75 = (void *)*v74;
            xmlFree(v74);
            if (v75)
            {
              do
              {
                uint64_t v76 = (void *)*v75;
                xmlFree(v75);
                uint64_t v75 = v76;
              }

              while (v76);
            }
          }
        }

        else
        {
          *(void *)(a2 + 40) = v74;
        }

        xmlNodePtr children = children->next;
        if (!children) {
          goto LABEL_218;
        }
      }
    }
  }

LABEL_241:
        if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"name"))
        {
          prefix = 0LL;
          Content = xmlNodeGetContent((const xmlNode *)v6);
          if (Content)
          {
            int v120 = Content;
            uint64_t v121 = xmlSplitQName2(Content, &prefix);
            if (v121)
            {
              uint64_t v122 = v121;
              xmlNsPtr v123 = xmlSearchNs(*(xmlDocPtr *)(v6 + 64), (xmlNodePtr)v6, prefix);
              if (v123)
              {
                xmlSetProp((xmlNodePtr)v6, (const xmlChar *)"ns", v123->href);
                xmlNodeSetContent((xmlNodePtr)v6, v122);
              }

              else
              {
                xmlRngPErr(a1, v6, 1097, "xmlRelaxNGParse: no namespace for prefix %s\n", prefix, 0LL);
              }

              xmlFree(v122);
              xmlFree(prefix);
            }

            xmlFree(v120);
          }
        }

        if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"nsName") || (*(_BYTE *)(a1 + 65) & 2) == 0) {
          goto LABEL_225;
        }
        uint64_t v129 = a1;
        uint64_t v130 = v6;
        int v131 = 1085;
        int v132 = "Found nsName/except//nsName forbidden construct\n";
      }

      else
      {
        int v133 = xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"except");
        if (v6 != a2 && v133)
        {
          uint64_t v134 = *(void *)(v6 + 40);
          if (!v134) {
            goto LABEL_225;
          }
          int v135 = *(_DWORD *)(a1 + 64);
          if (xmlStrEqual(*(const xmlChar **)(v134 + 16), (const xmlChar *)"anyName"))
          {
            int v136 = *(_DWORD *)(a1 + 64) | 0x100;
          }

          else
          {
            uint64_t v138 = *(void *)(v6 + 40);
            if (!v138 || !xmlStrEqual(*(const xmlChar **)(v138 + 16), (const xmlChar *)"nsName")) {
              goto LABEL_225;
            }
            int v136 = *(_DWORD *)(a1 + 64) | 0x200;
          }

          *(_DWORD *)(a1 + 64) = v136;
          xmlRelaxNGCleanupTree(a1, v6);
          uint64_t v4 = 0LL;
          *(_DWORD *)(a1 + 64) = v135;
          goto LABEL_257;
        }

        if (!xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"anyName")) {
          goto LABEL_225;
        }
        int v137 = *(_DWORD *)(a1 + 64);
        if ((v137 & 0x100) != 0)
        {
          uint64_t v129 = a1;
          uint64_t v130 = v6;
          int v131 = 1066;
          int v132 = "Found anyName/except//anyName forbidden construct\n";
        }

        else
        {
          if ((v137 & 0x200) == 0) {
            goto LABEL_225;
          }
          uint64_t v129 = a1;
          uint64_t v130 = v6;
          int v131 = 1084;
          int v132 = "Found nsName/except//anyName forbidden construct\n";
        }
      }

      xmlRngPErr(v129, v130, v131, v132, 0LL, 0LL);
      goto LABEL_225;
    }

    int v53 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"name");
    if (!v53) {
      goto LABEL_225;
    }
    uint64_t v54 = v53;
    if (*(void *)(v6 + 24))
    {
      uint64_t v55 = xmlNewDocNode(*(xmlDocPtr *)(v6 + 64), *(xmlNsPtr *)(v6 + 72), (const xmlChar *)"name", 0LL);
      if (v55)
      {
        uint64_t v56 = v55;
        xmlAddPrevSibling(*(xmlNodePtr *)(v6 + 24), v55);
        uint64_t v57 = xmlNewText(v54);
        xmlAddChild(v56, v57);
LABEL_135:
        char v72 = 0;
        goto LABEL_137;
      }
    }

    else
    {
      xmlNodePtr v71 = xmlNewChild((xmlNodePtr)v6, *(xmlNsPtr *)(v6 + 72), (const xmlChar *)"name", v53);
      if (v71)
      {
        uint64_t v56 = v71;
        goto LABEL_135;
      }
    }

    xmlRngPErr(a1, v6, 1008, "Failed to create a name %s element\n", v54, 0LL);
    uint64_t v56 = 0LL;
    char v72 = 1;
LABEL_137:
    xmlUnsetProp((xmlNodePtr)v6, (const xmlChar *)"name");
    xmlFree(v54);
    uint64_t v73 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
    if (v73)
    {
      __int128 v74 = v73;
      if ((v72 & 1) == 0) {
        xmlSetProp(v56, (const xmlChar *)"ns", v73);
      }
      xmlFree(v74);
    }

    else if (xmlStrEqual(*(const xmlChar **)(v6 + 16), (const xmlChar *)"attribute"))
    {
      xmlSetProp(v56, (const xmlChar *)"ns", (const xmlChar *)&byte_181A3ACBA);
    }

    goto LABEL_225;
  }

  Base = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"ns");
  if (!Base)
  {
    uint64_t v40 = v6;
    while (1)
    {
      uint64_t v40 = *(void *)(v40 + 40);
      if (!v40 || *(_DWORD *)(v40 + 8) != 1) {
        break;
      }
      BOOL v41 = xmlGetProp((const xmlNode *)v40, (const xmlChar *)"ns");
      if (v41)
      {
        Base = v41;
        goto LABEL_91;
      }
    }

    Base = 0LL;
  }
  }

  int v157 = v107 - 1;
  unsigned int v113 = 0LL;
  unint64_t v114 = v107;
  while (1)
  {
    uint64_t v85 = *((void *)v167 + v113);
    if (v171 != 1) {
      break;
    }
    uint64_t v115 = xmlSchemaAreValuesEqual( *(xmlSchemaValPtr *)(**(void **)(v104 + 8) + 8LL),  *(xmlSchemaVal **)(**(void **)(v85 + 8) + 8LL));
    uint64_t v84 = v115;
    if (v115)
    {
      if (v115 == -1) {
        goto LABEL_304;
      }
LABEL_227:
      uint64_t v84 = 1;
      uint64_t v107 = v165;
      uint64_t v112 = v157;
      goto LABEL_228;
    }

LABEL_91:
  uint64_t v49 = xmlGetProp((const xmlNode *)v6, (const xmlChar *)"href");
  if (!v49)
  {
    xmlRngPErr(a1, v6, 1052, "xmlRelaxNGParse: externalRef has no href attribute\n", 0LL, 0LL);
    uint64_t v4 = (xmlNode *)v6;
    if (!Base) {
      goto LABEL_257;
    }
LABEL_98:
    ((void (*)(xmlChar *))xmlFree)(Base);
    goto LABEL_256;
  }

  int v50 = v49;
  xmlURIPtr v51 = xmlParseURI((const char *)v49);
  if (!v51)
  {
    xmlRngPErr(a1, v6, 1041, "Incorrect URI for externalRef %s\n", v50, 0LL);
    if (Base) {
      xmlFree(Base);
    }
    ((void (*)(xmlChar *))xmlFree)(v50);
    goto LABEL_102;
  }

  int v52 = v51;
  if (v51->fragment)
  {
    xmlRngPErr(a1, v6, 1041, "Fragment forbidden in URI for externalRef %s\n", v50, 0LL);
    if (Base) {
      xmlFree(Base);
    }
    xmlFreeURI(v52);
    ((void (*)(xmlChar *))xmlFree)(v50);
LABEL_102:
    uint64_t v4 = (xmlNode *)v6;
    goto LABEL_257;
  }

  xmlFreeURI(v51);
  int v58 = xmlNodeGetBase(*(const xmlDoc **)(v6 + 64), (const xmlNode *)v6);
  unsigned int v59 = xmlBuildURI(v50, v58);
  if (v59)
  {
    int v60 = v59;
    xmlFree(v50);
    if (v58) {
      xmlFree(v58);
    }
    if (*(int *)(a1 + 184) >= 1)
    {
      uint64_t v61 = 0LL;
      while (!xmlStrEqual(*(const xmlChar **)(*(void *)(*(void *)(a1 + 192) + 8 * v61) + 8LL), v60))
      {
      }

      uint64_t v91 = a1;
      int v92 = 1033;
      unsigned int v93 = "Detected an externalRef recursion for %s\n";
      goto LABEL_171;
    }

  uint64_t v49 = *((void *)v8 + 24);
  if (*(_DWORD *)(v49 + 136))
  {
    for (uint64_t j = *(void *)(v49 + 104); j; uint64_t j = *(void *)(j + 8))
    {
      if (*(_DWORD *)(j + 32) == 24)
      {
        xmlURIPtr v51 = *(void *)(j + 56);
        if (v51)
        {
          if (*(_DWORD *)(v51 + 8))
          {
            int v52 = *(void *)(*(void *)(j + 24) + 8LL);
            int v53 = *(unsigned int *)(v52 + 64);
            uint64_t v54 = *((void *)v8 + 24) + 96LL;
            do
            {
              uint64_t v54 = *(void *)v54;
              if (!v54)
              {
                v170 = 0;
                uint64_t v56 = 0LL;
                goto LABEL_112;
              }
            }

            while (*(void *)(*(void *)(v52 + 72) + 8LL) != *(void *)(v54 + 8));
            uint64_t v55 = *(void *)(v54 + 32);
            if (v55) {
              v170 = *(_DWORD *)(v55 + 8) != 0;
            }
            else {
              v170 = 0;
            }
            uint64_t v56 = xmlHashCreate(2 * *(_DWORD *)(v54 + 24));
            if (*(int *)(v54 + 24) >= 1)
            {
              uint64_t v57 = 0LL;
              while (1)
              {
                name[0] = 0LL;
                xmlSchemaFormatIDCKeySequence_1( v8,  name,  *(void *)(*(void *)(*(void *)(v54 + 16) + 8 * v57) + 8LL),  v53,  1);
                int v58 = xmlMalloc(0x10uLL);
                v58[2] = v57;
                unsigned int v59 = name[0];
                int v60 = xmlHashLookup(v56, name[0]);
                if (!v60) {
                  break;
                }
                *(void *)int v58 = *v60;
                xmlChar *v60 = v58;
                if (v59) {
                  goto LABEL_107;
                }
LABEL_108:
              }

              *(void *)int v58 = 0LL;
              xmlHashAddEntry(v56, v59, v58);
              if (!v59) {
                goto LABEL_108;
              }
LABEL_107:
              xmlFree(v59);
              goto LABEL_108;
            }

        int v3 = 0LL;
        goto LABEL_92;
      }

      uint64_t v27 = a2[1];
      if (v48 == -1) {
LABEL_89:
      }
        int v3 = 0LL;
      else {
LABEL_42:
      }
        int v3 = xmlXPathCompOpEval(a1, *(void *)(v12 + 8) + 56LL * v27);
      if (*(_DWORD *)(a1 + 16)) {
        goto LABEL_91;
      }
      int v53 = a2[2];
      if (v53 == -1) {
        goto LABEL_92;
      }
      uint64_t v54 = *(void *)(a1 + 32);
      if (!v54) {
        goto LABEL_92;
      }
      if (*(_DWORD *)v54 == 1)
      {
        uint64_t v56 = *(_DWORD *)(a1 + 40);
        uint64_t v57 = *(void *)(a1 + 48);
        int v58 = v56 - 1;
        *(_DWORD *)(a1 + 40) = v56 - 1;
        if (v56 == 1) {
          unsigned int v59 = 0LL;
        }
        else {
          unsigned int v59 = *(void *)(v57 + 8LL * (v56 - 2));
        }
        *(void *)(a1 + 32) = v59;
        int v60 = *(xmlXPathObject **)(v57 + 8LL * v58);
        *(void *)(v57 + 8LL * v58) = 0LL;
        xmlNodeSetPtr nodesetval = v60->nodesetval;
        if (nodesetval)
        {
          xmlXPathNodeSetFilter((xmlXPathParserContext *)a1, &v60->nodesetval->nodeNr, a2[2], 1, 1, 1);
          if (nodesetval->nodeNr >= 1) {
            *a3 = (uint64_t)*nodesetval->nodeTab;
          }
        }

        uint64_t v35 = (xmlXPathParserContext *)a1;
        int v34 = v60;
LABEL_51:
        valuePush(v35, v34);
        goto LABEL_92;
      }

      if (*(_DWORD *)v54 != 7)
      {
        xmlXPathErr((xmlXPathParserContextPtr)a1, 11);
        goto LABEL_91;
      }

      uint64_t v55 = *(void *)(v54 + 40);
      if (v55)
      {
        xmlXPathLocationSetFilter((xmlXPathParserContext *)a1, *(int **)(v54 + 40), v53, 1);
        if (*(int *)v55 >= 1)
        {
          int v52 = *(void *)(**(void **)(v55 + 8) + 40LL);
          goto LABEL_101;
        }
      }

uint64_t xmlRelaxNGRemoveRedefine(uint64_t a1, const xmlChar *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    uint64_t v4 = 0LL;
    while (1)
    {
      uint64_t v5 = v3;
      uint64_t v3 = *(void *)(v3 + 48);
      uint64_t v6 = *(void *)(v5 + 72);
      if (a2)
      {
        if (!v6
          || *(_DWORD *)(v5 + 8) != 1
          || !xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"define")
          || !xmlStrEqual( *(const xmlChar **)(*(void *)(v5 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          goto LABEL_17;
        }

        Prop = xmlGetProp((const xmlNode *)v5, (const xmlChar *)"name");
        xmlRelaxNGNormExtSpace(Prop);
        if (Prop)
        {
          if (xmlStrEqual(a2, Prop))
          {
            xmlUnlinkNode((xmlNodePtr)v5);
            xmlFreeNode((xmlNodePtr)v5);
            uint64_t v4 = 1LL;
          }

          xmlFree(Prop);
        }
      }

      else
      {
        if (!v6
          || *(_DWORD *)(v5 + 8) != 1
          || !xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"start")
          || !xmlStrEqual( *(const xmlChar **)(*(void *)(v5 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
LABEL_17:
          if (*(void *)(v5 + 72)
            && *(_DWORD *)(v5 + 8) == 1
            && xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"include")
            && xmlStrEqual( *(const xmlChar **)(*(void *)(v5 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            uint64_t v8 = *(void *)(v5 + 104);
            if (v8)
            {
              uint64_t v9 = *(void *)(v8 + 16);
              if (v9)
              {
                uint64_t v10 = *(void *)(v9 + 24);
                if (v10)
                {
                  if (xmlStrEqual(*(const xmlChar **)(v10 + 16), (const xmlChar *)"grammar"))
                  {
                    xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v8 + 16));
                  }
                }
              }
            }

            else {
              uint64_t v4 = v4;
            }
          }

          goto LABEL_30;
        }

        xmlUnlinkNode((xmlNodePtr)v5);
        xmlFreeNode((xmlNodePtr)v5);
        uint64_t v4 = 1LL;
      }

unsigned __int8 *xmlRelaxNGNormExtSpace(unsigned __int8 *result)
{
  if (!result) {
    return result;
  }
  for (uint64_t i = 0LL; ; ++i)
  {
    unsigned int v2 = result[i];
    BOOL v3 = v2 > 0x20;
    uint64_t v4 = (1LL << v2) & 0x100002600LL;
    if (v3 || v4 == 0) {
      break;
    }
  }

  if (i)
  {
    for (uint64_t j = &result[i]; ; ++j)
    {
      uint64_t v7 = *j;
      if (v7 > 0x20)
      {
        unsigned __int8 k = *j;
      }

      else if (((1LL << v7) & 0x100002600LL) != 0)
      {
        for (unsigned __int8 k = *j; k <= 0x20u; unsigned __int8 k = v9)
        {
          uint64_t v7 = k;
          if (((1LL << k) & 0x100002600LL) == 0) {
            goto LABEL_17;
          }
          unsigned __int8 v9 = *++j;
        }
      }

      else
      {
        unsigned __int8 k = *j;
LABEL_17:
        if (!v7) {
          goto LABEL_30;
        }
      }

      *result++ = k;
    }
  }

  while (1)
  {
LABEL_21:
    unsigned int v10 = *result;
    if (v10 > 0x20) {
      goto LABEL_29;
    }
    unsigned __int8 v11 = *result;
    uint64_t v12 = result;
    if (((1LL << v10) & 0x100002600LL) != 0) {
      break;
    }
    if (!*result) {
      return result;
    }
LABEL_29:
    ++result;
  }

  while (1)
  {
    if (v11 > 0x20u) {
      goto LABEL_27;
    }
    if (((1LL << v11) & 0x100002600LL) == 0) {
      break;
    }
    unsigned __int8 v13 = *++v12;
    unsigned __int8 v11 = v13;
  }

  if (v11)
  {
LABEL_27:
    int result = v12;
    goto LABEL_21;
  }

void *xmlRelaxNGParseGrammar(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v4 = xmlRelaxNGNewGrammar(a1);
  uint64_t v5 = v4;
  if (!v4) {
    return v5;
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)uint64_t v4 = v6;
  if (v6)
  {
    uint64_t v7 = (void *)(v6 + 8);
    uint64_t v8 = *(void *)(v6 + 8);
    if (v8)
    {
      do
      {
        uint64_t v9 = v8;
        uint64_t v8 = *(void *)(v8 + 16);
      }

      while (v8);
      uint64_t v7 = (void *)(v9 + 16);
    }

    void *v7 = v4;
  }

  *(void *)(a1 + 48) = v4;
  xmlRelaxNGParseGrammarContent(a1, a2);
  *(void *)(a1 + 48) = v5;
  uint64_t v10 = v5[3];
  if (!v10)
  {
    xmlRngPErr(a1, a2, 1039, "Element <grammar> has no <start>\n", 0LL, 0LL);
    uint64_t v10 = v5[3];
    if (!v10) {
      goto LABEL_42;
    }
  }

  if (!*(void *)(v10 + 64)) {
    goto LABEL_42;
  }
  int v11 = 0;
  int v12 = -1;
  uint64_t v13 = v10;
  do
  {
    uint64_t v14 = *(void *)(v13 + 8);
    if (v14
      && (uint64_t v15 = *(void *)(v14 + 40)) != 0
      && (v16 = xmlStrEqual(*(const xmlChar **)(v15 + 16), (const xmlChar *)"start"), uint64_t v14 = *(void *)(v13 + 8), v16))
    {
      Prop = xmlGetProp(*(const xmlNode **)(v14 + 40), (const xmlChar *)"combine");
      if (Prop)
      {
        int v18 = Prop;
        if (xmlStrEqual(Prop, (const xmlChar *)"choice"))
        {
          if (v12)
          {
            int v12 = 1;
LABEL_29:
            xmlFree(v18);
            goto LABEL_22;
          }
        }

        else
        {
          if (!xmlStrEqual(v18, (const xmlChar *)"interleave"))
          {
            uint64_t v19 = *(void *)(v13 + 8);
            uint64_t v20 = a1;
            int v21 = 1114;
            int v22 = "<start> uses unknown combine value '%s''\n";
            BOOL v23 = v18;
            goto LABEL_28;
          }

          if (v12 != 1)
          {
            int v12 = 0;
            goto LABEL_29;
          }
        }

        uint64_t v19 = *(void *)(v13 + 8);
        uint64_t v20 = a1;
        int v21 = 1104;
        int v22 = "<start> use both 'choice' and 'interleave'\n";
        BOOL v23 = 0LL;
LABEL_28:
        xmlRngPErr(v20, v19, v21, v22, v23, 0LL);
        goto LABEL_29;
      }
    }

    else
    {
      xmlRngPErr(a1, v14, 1107, "Internal error: start element not found\n", 0LL, 0LL);
    }

    if (v11) {
      xmlRngPErr(a1, *(void *)(v13 + 8), 1054, "Some <start> element miss the combine attribute\n", 0LL, 0LL);
    }
    int v11 = 1;
LABEL_22:
    uint64_t v13 = *(void *)(v13 + 64);
  }

  while (v13);
  xmlValidCtxt v24 = xmlRelaxNGNewDefine(a1, *(void *)(v10 + 8));
  if (v24)
  {
    uint64_t v25 = v24;
    int v26 = (v12 + 1) >= 2 ? 17 : 19;
    *(_DWORD *)xmlValidCtxt v24 = v26;
    *((void *)v24 + 6) = v5[3];
    v5[3] = v24;
    if ((v12 + 1) <= 1)
    {
      if (*(void *)(a1 + 104) || (xmlHashTablePtr v27 = xmlHashCreate(10), (*(void *)(a1 + 104) = v27) != 0LL))
      {
        *(_OWORD *)__str = 0u;
        __int128 v37 = 0u;
        int v28 = *(_DWORD *)(a1 + 96);
        *(_DWORD *)(a1 + 96) = v28 + 1;
        snprintf(__str, 0x20uLL, "interleave%d", v28);
        if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 104), (const xmlChar *)__str, v25) < 0)
        {
          uint64_t v29 = v25[1];
          BOOL v30 = "Failed to add %s to hash table\n";
          int v31 = __str;
          uint64_t v32 = a1;
          goto LABEL_41;
        }
      }

      else
      {
        uint64_t v29 = v25[1];
        BOOL v30 = "Failed to create interleaves hash table\n";
        uint64_t v32 = a1;
        int v31 = 0LL;
LABEL_41:
        xmlRngPErr(v32, v29, 1046, v30, (const xmlChar *)v31, 0LL);
      }
    }
  }

_OWORD *xmlRelaxNGNewGrammar(uint64_t a1)
{
  unsigned int v2 = xmlMalloc(0x40uLL);
  BOOL v3 = v2;
  if (v2)
  {
    v2[2] = 0u;
    v2[3] = 0u;
    _OWORD *v2 = 0u;
    v2[1] = 0u;
  }

  else
  {
    xmlRngPErrMemory(a1, 0LL);
  }

  return v3;
}

uint64_t xmlRelaxNGParseStart(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_17;
  }
  int v4 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"empty");
  uint64_t v5 = *(void *)(a2 + 72);
  if (v4)
  {
    if (xmlStrEqual(*(const xmlChar **)(v5 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v6 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
      if (v6)
      {
        uint64_t v7 = v6;
        *(_DWORD *)uint64_t v6 = 0;
        if (!*(void *)(a2 + 24)) {
          goto LABEL_18;
        }
        uint64_t v8 = "element empty is not empty\n";
        uint64_t v9 = a1;
        uint64_t v10 = a2;
        int v11 = 1024;
        goto LABEL_8;
      }

      return 0xFFFFFFFFLL;
    }

    uint64_t v5 = *(void *)(a2 + 72);
  }

  if (v5
    && *(_DWORD *)(a2 + 8) == 1
    && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"notAllowed")
    && xmlStrEqual( *(const xmlChar **)(*(void *)(a2 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    int v12 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
    if (!v12) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = v12;
    *(_DWORD *)int v12 = 1;
    if (*(void *)(a2 + 24))
    {
      uint64_t v8 = "element notAllowed is not empty\n";
      uint64_t v9 = a1;
      uint64_t v10 = a2;
      int v11 = 1055;
LABEL_8:
      xmlRngPErr(v9, v10, v11, v8, 0LL, 0LL);
    }
  }

  else
  {
LABEL_17:
    uint64_t v7 = xmlRelaxNGParsePatterns(a1, a2, 1);
  }

uint64_t xmlRelaxNGCheckCycles(uint64_t a1, int *a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  int v4 = a2;
  uint64_t v6 = (a3 + 1);
  while (1)
  {
    int v7 = *v4;
    if (*v4 == 4)
    {
      uint64_t v11 = *((void *)v4 + 6);
      uint64_t v12 = a1;
      uint64_t v13 = v6;
      goto LABEL_13;
    }

    if (v7 != 13 && v7 != 11)
    {
      uint64_t v11 = *((void *)v4 + 6);
      uint64_t v12 = a1;
      uint64_t v13 = a3;
LABEL_13:
      uint64_t result = xmlRelaxNGCheckCycles(v12, v11, v13);
      goto LABEL_15;
    }

    int v9 = *((__int16 *)v4 + 48);
    if (v9 == -1)
    {
      *((_WORD *)v4 + 48) = a3;
      uint64_t result = xmlRelaxNGCheckCycles(a1, *((void *)v4 + 6), a3);
      *((_WORD *)v4 + 48) = -2;
      goto LABEL_15;
    }

    if (v9 == (_DWORD)a3) {
      break;
    }
    uint64_t result = 0LL;
LABEL_15:
    int v4 = (int *)*((void *)v4 + 8);
    if ((_DWORD)result) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = v4 == 0LL;
    }
    if (v14) {
      return result;
    }
  }

  xmlRngPErr(a1, *((void *)v4 + 1), 1099, "Detected a cycle in %s references\n", *((const xmlChar **)v4 + 2), 0LL);
  return 0xFFFFFFFFLL;
}

uint64_t xmlRelaxNGSimplify(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (!a2) {
    return result;
  }
  uint64_t v4 = a2;
  uint64_t v5 = result;
  uint64_t v6 = 0LL;
  while (1)
  {
    int v7 = *(_DWORD *)v4;
    if (*(int *)v4 > 10)
    {
      if (v7 == 13 || v7 == 11)
      {
        if (*(__int16 *)(v4 + 96) != -3)
        {
          *(_WORD *)(v4 + 96) = -3;
          uint64_t result = xmlRelaxNGSimplify(v5, *(void *)(v4 + 48), v4);
        }

        goto LABEL_64;
      }
    }

    else
    {
      if (!v7)
      {
        *(void *)(v4 + 56) = a3;
        if (a3)
        {
          if ((*(_DWORD *)a3 & 0xFFFFFFFE) == 0x12)
          {
LABEL_61:
            if (v6)
            {
              *(void *)(v6 + 64) = *(void *)(v4 + 64);
            }

            else if (*(void *)(a3 + 48) == v4)
            {
              uint64_t v6 = 0LL;
              *(void *)(a3 + 48) = *(void *)(v4 + 64);
            }

            else if (*(void *)(a3 + 72) == v4)
            {
              uint64_t v6 = 0LL;
              *(void *)(a3 + 72) = *(void *)(v4 + 64);
            }

            else
            {
              uint64_t v6 = 0LL;
              if (*(void *)(a3 + 80) == v4) {
                *(void *)(a3 + 80) = *(void *)(v4 + 64);
              }
            }

            goto LABEL_64;
          }
        }

        goto LABEL_63;
      }

      if (v7 == 1)
      {
        *(void *)(v4 + 56) = a3;
LABEL_7:
        if (!a3) {
          goto LABEL_63;
        }
        int v8 = *(_DWORD *)a3;
        if (*(_DWORD *)a3 > 0x13u) {
          goto LABEL_63;
        }
        if (v8 == 17) {
          goto LABEL_61;
        }
        uint64_t v6 = v4;
        if (((1 << v8) & 0xD8300) != 0)
        {
          int v20 = 1;
          goto LABEL_74;
        }

        goto LABEL_64;
      }
    }

    *(void *)(v4 + 56) = a3;
    uint64_t v10 = *(void *)(v4 + 48);
    if (v10)
    {
      uint64_t result = xmlRelaxNGSimplify(v5, v10, v4);
      int v7 = *(_DWORD *)v4;
    }

    if (v7 != 7)
    {
      uint64_t v11 = *(void *)(v4 + 72);
      if (v11) {
        uint64_t result = xmlRelaxNGSimplify(v5, v11, v4);
      }
    }

    uint64_t v12 = *(void *)(v4 + 80);
    if (v12) {
      uint64_t result = xmlRelaxNGSimplify(v5, v12, v4);
    }
    if (*(_DWORD *)v4 == 4)
    {
      uint64_t v13 = *(void *)(v4 + 48);
      if (v13)
      {
        while (1)
        {
          uint64_t result = xmlRelaxNGGenerateAttributes(v5, v13);
          uint64_t v14 = *(void *)(v4 + 48);
          if ((_DWORD)result != 1) {
            break;
          }
          uint64_t v13 = *(void *)(v14 + 64);
          *(void *)(v4 + 48) = v13;
          *(void *)(v14 + 64) = *(void *)(v4 + 72);
          *(void *)(v4 + 72) = v14;
          if (!v13) {
            goto LABEL_41;
          }
        }

        if (v14)
        {
          while (1)
          {
            uint64_t v15 = *(void *)(v14 + 64);
            if (!v15) {
              break;
            }
            uint64_t result = xmlRelaxNGGenerateAttributes(v5, *(void *)(v14 + 64));
            if ((_DWORD)result == 1)
            {
              *(void *)(v14 + 64) = *(void *)(v15 + 64);
              *(void *)(v15 + 64) = *(void *)(v4 + 72);
              *(void *)(v4 + 72) = v15;
            }

            else
            {
              uint64_t v14 = v15;
            }
          }
        }
      }
    }

LABEL_41:
    int v16 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0xFFFFFFFE) == 0x12) {
      break;
    }
LABEL_52:
    if (!v16) {
      goto LABEL_58;
    }
    if (v16 == 1) {
      goto LABEL_7;
    }
    if (v16 != 2) {
      goto LABEL_63;
    }
    uint64_t v19 = *(_DWORD **)(v4 + 48);
    if (!v19 || *v19 != 1) {
      goto LABEL_63;
    }
    uint64_t result = xmlRelaxNGTryUnlink(v4, (void *)a3, v6);
    uint64_t v6 = result;
LABEL_64:
    uint64_t v4 = *(void *)(v4 + 64);
    if (!v4) {
      return result;
    }
  }

  uint64_t v17 = *(void *)(v4 + 48);
  if (v17)
  {
    if (!*(void *)(v17 + 64))
    {
      if (!(a3 | v6))
      {
        *(_DWORD *)uint64_t v4 = -1;
        goto LABEL_63;
      }

      if (v6)
      {
        *(void *)(v17 + 64) = *(void *)(v4 + 64);
        uint64_t v18 = v6;
        uint64_t v4 = v17;
      }

      else
      {
        *(void *)(a3 + 48) = v17;
        uint64_t v17 = *(void *)(v4 + 64);
        uint64_t v18 = *(void *)(v4 + 48);
        uint64_t v4 = v18;
      }

      *(void *)(v18 + 64) = v17;
    }

    int v16 = *(_DWORD *)v4;
    goto LABEL_52;
  }

  *(_DWORD *)uint64_t v4 = 0;
LABEL_58:
  if (!a3)
  {
LABEL_63:
    uint64_t v6 = v4;
    goto LABEL_64;
  }

  if ((*(_DWORD *)a3 - 15) >= 2)
  {
    goto LABEL_63;
  }

    LODWORD(ctxt) = 0;
    if (v12)
    {
      content = node->content;
      if (content)
      {
        ctxt = (xmlDOMWrapCtxtPtr)v12->dict;
        if (ctxt)
        {
          LODWORD(ctxt) = xmlDictOwns((xmlDictPtr)ctxt, content);
          if ((_DWORD)ctxt)
          {
            uint64_t v19 = destDoc->dict;
            if (v19) {
              ctxt = (xmlDOMWrapCtxtPtr)xmlDictLookup(v19, node->content, -1);
            }
            else {
              ctxt = (xmlDOMWrapCtxtPtr)xmlStrdup(node->content);
            }
            int v26 = (xmlChar *)ctxt;
            LODWORD(ctxt) = 0;
            node->content = v26;
          }
        }
      }
    }

    return (int)ctxt;
  }

  node->content = 0LL;
  node->xmlNodePtr children = 0LL;
  node->last = 0LL;
  if (destDoc->intSubset || destDoc->extSubset)
  {
    xmlEntityPtr DocEntity = (_xmlNode *)xmlGetDocEntity(destDoc, node->name);
    if (DocEntity)
    {
      node->content = DocEntity->content;
      node->xmlNodePtr children = DocEntity;
      node->last = DocEntity;
    }
  }

  if (v14) {
    goto LABEL_66;
  }
  int v21 = (xmlChar *)node->name;
  if (!v21) {
    goto LABEL_66;
  }
  int v22 = destDoc->dict;
  if (v22)
  {
    node->name = xmlDictLookup(v22, node->name, -1);
    if (!v12 || (BOOL v23 = v12->dict) == 0LL || !xmlDictOwns(v23, v21)) {
      xmlFree(v21);
    }
    goto LABEL_66;
  }

  if (!v12)
  {
LABEL_66:
    LODWORD(ctxt) = 0;
    return (int)ctxt;
  }

  ctxt = (xmlDOMWrapCtxtPtr)v12->dict;
  if (ctxt)
  {
    LODWORD(ctxt) = xmlDictOwns((xmlDictPtr)ctxt, node->name);
    if ((_DWORD)ctxt)
    {
      uint64_t v25 = xmlStrdup(node->name);
      LODWORD(ctxt) = 0;
      node->name = v25;
    }
  }

  return (int)ctxt;
}

  xmlValidCtxt v24 = 1546;
  __xmlSimpleError(8, 1546, 0, (uint64_t)"write error", 0LL);
LABEL_42:
  out->error = v24;
  return v19;
}

    ++v6;
    uint64_t v5 = *(void *)(a2 + 64);
  }

  xmlSchemaInternalErr2( (_DWORD *)a1,  (const xmlChar *)"xmlSchemaAddComponents",  (const xmlChar *)"failed to create a component hash table",  0LL);
  return 0xFFFFFFFFLL;
}

LABEL_73:
  int v20 = 0;
LABEL_74:
  *(_DWORD *)a3 = v20;
  return result;
}

  xmlBufFree(v5);
  return v6;
}

                xmlHashTablePtr v27 = v75;
              }

              goto LABEL_131;
            case XML_ENTITY_NODE:
              goto LABEL_131;
            case XML_XINCLUDE_START:
            case XML_XINCLUDE_END:
              return v8;
            default:
              goto LABEL_160;
          }
        }

        if (type != XML_ELEMENT_NODE)
        {
          int v77 = v20;
LABEL_171:
          int v8 = -1;
LABEL_160:
          uint64_t v65 = namespaceMap;
          if (!namespaceMap) {
            goto LABEL_164;
          }
          uint64_t v66 = ctxt;
          if (ctxt) {
            goto LABEL_162;
          }
          goto LABEL_163;
        }

    xmlXPathErr(ctxt, v38);
  }

uint64_t xmlRelaxNGCheckRules(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v6 = a2;
  uint64_t v8 = 0LL;
  unsigned int v9 = a3 | 8;
  uint64_t v10 = (32 * (_DWORD)a3) & 0x40 | a3;
  uint64_t v11 = (16 * (_DWORD)a3) & 0x20 | a3;
  unsigned int v63 = a3 | 4;
  unsigned int v64 = a3 | 2;
  unsigned int v62 = a3 | 1;
  while (2)
  {
    uint64_t v12 = *v6;
    switch((int)v12)
    {
      case 0:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1071, "Found forbidden pattern data/except//empty\n", 0LL, 0LL);
        }
        if ((a3 & 0x10) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1090, "Found forbidden pattern start//empty\n", 0LL, 0LL);
        }
        goto LABEL_171;
      case 2:
        int v22 = (_DWORD *)*((void *)v6 + 7);
        uint64_t v21 = a3;
        if (v22)
        {
          if (*v22 == 5) {
            uint64_t v21 = v9;
          }
          else {
            uint64_t v21 = a3;
          }
        }

        uint64_t v19 = *((void *)v6 + 6);
        uint64_t v20 = a1;
        uint64_t v12 = 2LL;
        goto LABEL_167;
      case 3:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1083, "Found forbidden pattern list//text\n", 0LL, 0LL);
          if ((a3 & 8) == 0)
          {
LABEL_33:
            if ((a3 & 0x10) == 0) {
              goto LABEL_80;
            }
            goto LABEL_79;
          }
        }

        else if ((a3 & 8) == 0)
        {
          goto LABEL_33;
        }

        xmlRngPErr(a1, *((void *)v6 + 1), 1077, "Found forbidden pattern data/except//text\n", 0LL, 0LL);
        if ((a3 & 0x10) == 0) {
          goto LABEL_80;
        }
LABEL_79:
        xmlRngPErr(a1, *((void *)v6 + 1), 1095, "Found forbidden pattern start//text\n", 0LL, 0LL);
        goto LABEL_80;
      case 4:
        xmlRelaxNGCheckGroupAttrs(a1, (uint64_t)v6);
        if ((a3 & 8) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1070, "Found forbidden pattern data/except//element(ref)\n", 0LL, 0LL);
          if ((a3 & 4) == 0)
          {
LABEL_37:
            if ((a3 & 1) == 0) {
              goto LABEL_39;
            }
            goto LABEL_38;
          }
        }

        else if ((a3 & 4) == 0)
        {
          goto LABEL_37;
        }

        xmlRngPErr(a1, *((void *)v6 + 1), 1079, "Found forbidden pattern list//element(ref)\n", 0LL, 0LL);
        if ((a3 & 1) == 0)
        {
LABEL_39:
          if (xmlRelaxNGCheckRules(a1, *((void *)v6 + 9), 0LL, *v6)) {
            xmlRngPErr( a1,  *((void *)v6 + 1),  1015,  "Element %s attributes have a content type error\n",  *((const xmlChar **)v6 + 2),  0LL);
          }
          if (xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), 0LL, *v6) == -1)
          {
            xmlRngPErr( a1,  *((void *)v6 + 1),  1016,  "Element %s has a content type error\n",  *((const xmlChar **)v6 + 2),  0LL);
            int v18 = -1;
            goto LABEL_172;
          }

LABEL_87:
        xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), a3, v23);
        int v18 = 1;
        goto LABEL_172;
      case 8:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1081, "Found forbidden pattern list//list\n", 0LL, 0LL);
          if ((a3 & 8) == 0)
          {
LABEL_49:
            if ((a3 & 0x10) == 0) {
              goto LABEL_51;
            }
            goto LABEL_50;
          }
        }

        else if ((a3 & 8) == 0)
        {
          goto LABEL_49;
        }

        xmlRngPErr(a1, *((void *)v6 + 1), 1074, "Found forbidden pattern data/except//list\n", 0LL, 0LL);
        if ((a3 & 0x10) == 0)
        {
LABEL_51:
          uint64_t v19 = *((void *)v6 + 6);
          uint64_t v12 = *v6;
          uint64_t v20 = a1;
          uint64_t v21 = v63;
          goto LABEL_167;
        }

LABEL_95:
        xmlRngPErr(a1, *((void *)v6 + 1), 1069, "Found forbidden pattern data/except//attribute\n", 0LL, 0LL);
        if ((a3 & 0x10) == 0)
        {
LABEL_58:
          if ((a3 & 2) != 0) {
            goto LABEL_170;
          }
          goto LABEL_97;
        }

LABEL_170:
        xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), v62, *v6);
LABEL_171:
        int v18 = 0;
        goto LABEL_172;
      case 11:
      case 13:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1076, "Found forbidden pattern data/except//ref\n", 0LL, 0LL);
        }
        if (!*((void *)v6 + 6))
        {
          if (*v6 == 13)
          {
            uint64_t v13 = a1;
            uint64_t v14 = "Internal found no define for parent refs\n";
            uint64_t v15 = 0LL;
          }

          else
          {
            if (*((void *)v6 + 2)) {
              uint64_t v15 = (const xmlChar *)*((void *)v6 + 2);
            }
            else {
              uint64_t v15 = (const xmlChar *)"null";
            }
            uint64_t v13 = a1;
            uint64_t v14 = "Internal found no define for ref %s\n";
          }

          xmlRngPErr(v13, *((void *)v6 + 1), 1101, v14, v15, 0LL);
        }

        int v36 = *((__int16 *)v6 + 48);
        if (v36 < -3)
        {
          if (v36 == -4) {
            int v18 = 2;
          }
          else {
            int v18 = v36 + 15;
          }
        }

        else
        {
          *((_WORD *)v6 + 48) = -4;
          int v18 = xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), a3, *v6);
          *((_WORD *)v6 + 48) = v18 - 15;
        }

        goto LABEL_172;
      case 15:
      case 16:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1075, "Found forbidden pattern data/except//oneOrMore\n", 0LL, 0LL);
        }
        if ((a3 & 0x10) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1094, "Found forbidden pattern start//oneOrMore\n", 0LL, 0LL);
        }
        int v16 = xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), v64, *v6);
        if (v16 == 2) {
          int v17 = 2;
        }
        else {
          int v17 = -1;
        }
        if (!v16) {
          int v17 = 0;
        }
        if (v16 == -1) {
          int v18 = -1;
        }
        else {
          int v18 = v17;
        }
        goto LABEL_172;
      case 17:
        if ((*((_WORD *)v6 + 49) & 0x20) != 0 || *(_DWORD *)(a1 + 68)) {
          goto LABEL_166;
        }
        unsigned int v60 = v10;
        int v24 = xmlRelaxNGIsNullable((uint64_t)v6);
        uint64_t v25 = *((void *)v6 + 6);
        unsigned int v59 = v11;
        for (uint64_t i = 0LL; v25; v25 = *(void *)(v25 + 64))
          ++i;
        uint64_t v65 = 8 * i;
        xmlHashTablePtr v27 = xmlMalloc(8 * i);
        if (!v27)
        {
          xmlRngPErrMemory(a1, (const xmlChar *)"building choice\n");
          uint64_t v11 = v11;
          uint64_t v10 = v60;
          goto LABEL_166;
        }

        int v28 = v27;
        unsigned int v58 = v9;
        if (v24)
        {
          uint64_t v29 = 0LL;
          int v66 = 0;
        }

        else
        {
          uint64_t v29 = xmlHashCreate(10);
          int v66 = 1;
        }

        uint64_t v37 = *((void *)v6 + 6);
        uint64_t v61 = a1;
        if (!v37) {
          goto LABEL_144;
        }
        uint64_t v38 = 0LL;
        do
        {
          int v39 = xmlRelaxNGGetElements(a1, (_DWORD *)v37, 0);
          v28[v38] = v39;
          if (!v39 || (uint64_t v40 = *v39) == 0)
          {
            int v66 = 0;
            goto LABEL_143;
          }

          if (v66 != 1) {
            goto LABEL_143;
          }
          BOOL v41 = v39 + 1;
          do
          {
            if (*(_DWORD *)v40 != 4)
            {
              if (*(_DWORD *)v40 != 3)
              {
                int v47 = -1;
                goto LABEL_142;
              }

              uint64_t v42 = v29;
              int v43 = "#text";
              goto LABEL_134;
            }

            int v43 = *(const char **)(v40 + 16);
            BOOL v44 = *(const xmlChar **)(v40 + 24);
            if (v43)
            {
              if (!v44 || !*v44)
              {
                uint64_t v42 = v29;
LABEL_134:
                BOOL v44 = 0LL;
                goto LABEL_135;
              }

              uint64_t v42 = v29;
            }

            else
            {
              if (!v44 || !*v44)
              {
                uint64_t v42 = v29;
                int v43 = "#any";
                goto LABEL_134;
              }

              uint64_t v42 = v29;
              int v43 = "#any";
            }

      char v72 = *(void *)(v46 + 192);
      int v45 = *((void *)v1 + 24);
      if (v72)
      {
        if (*(void *)(v45 + 104))
        {
          int v66 = "xmlSchemaIDCRegisterMatchers";
          uint64_t v67 = "The chain of IDC matchers is expected to be empty";
        }

        else
        {
          uint64_t v73 = 0LL;
LABEL_174:
          if (*(_DWORD *)v72 == 24 && (__int128 v74 = *(void *)(*(void *)(v72 + 72) + 8LL)) != 0)
          {
            *(_DWORD *)(*((void *)v1 + 24) + 136LL) = 1;
            uint64_t v75 = (char *)(v1 + 50);
            while (1)
            {
              uint64_t v75 = *(char **)v75;
              if (!v75) {
                break;
              }
              if (*((void *)v75 + 1) == v74)
              {
                uint64_t v76 = *((_DWORD *)v75 + 4);
                int v77 = v1[43];
                if (v76 == -1 || v77 < v76) {
                  *((_DWORD *)v75 + 4) = v77;
                }
                goto LABEL_185;
              }
            }
          }

          else
          {
LABEL_185:
            int v79 = (char *)(v1 + 50);
            while (1)
            {
              int v79 = *(char **)v79;
              if (!v79) {
                break;
              }
              if (*((void *)v79 + 1) == v72)
              {
                unsigned int v80 = *((void *)v1 + 28);
                if (v80)
                {
                  *((void *)v1 + 28) = *(void *)(v80 + 16);
                  *(void *)(v80 + 16) = 0LL;
                }

                else
                {
                  uint64_t v81 = xmlMalloc(0x48uLL);
                  if (!v81)
                  {
                    uint64_t v88 = v1[27] + 1;
                    v1[26] = 1818;
                    v1[27] = v88;
                    __xmlSimpleError(17, 2, 0, 0LL, (uint64_t)"allocating an IDC matcher");
                    goto LABEL_226;
                  }

                  unsigned int v80 = (uint64_t)v81;
                  v81[8] = 0LL;
                  *((_OWORD *)v81 + 2) = 0u;
                  *((_OWORD *)v81 + 3) = 0u;
                  *(_OWORD *)uint64_t v81 = 0u;
                  *((_OWORD *)v81 + htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = 0u;
                }

                if (v73) {
                  int v82 = (uint64_t *)(v73 + 8);
                }
                else {
                  int v82 = (uint64_t *)(*((void *)v1 + 24) + 104LL);
                }
                xmlNode *v82 = v80;
                *(_DWORD *)unsigned int v80 = 0;
                *(_DWORD *)(v80 + 4) = v1[43];
                *(void *)(v80 + 24) = v79;
                *(_DWORD *)(v80 + 32) = **((_DWORD **)v79 + 1);
                if (xmlSchemaIDCAddStateObject((uint64_t)v1, v80, *(void *)(v72 + 48), 1) != -1)
                {
                  char v72 = *(void *)(v72 + 16);
                  uint64_t v73 = v80;
                  if (v72) {
                    goto LABEL_174;
                  }
                  int v45 = *((void *)v1 + 24);
                  goto LABEL_198;
                }

                goto LABEL_226;
              }
            }
          }

          int v66 = "xmlSchemaIDCRegisterMatchers";
          uint64_t v67 = "Could not find an augmented IDC item for an IDC definition";
        }

        goto LABEL_225;
      }

LABEL_135:
            int v45 = xmlHashAddEntry2(v42, (const xmlChar *)v43, v44, (void *)v37);
            if (v45) {
              break;
            }
            uint64_t v46 = *v41++;
            uint64_t v40 = v46;
          }

          while (v46);
          if (v45) {
            int v47 = -1;
          }
          else {
            int v47 = 1;
          }
LABEL_142:
          int v66 = v47;
          a1 = v61;
LABEL_143:
          ++v38;
          uint64_t v37 = *(void *)(v37 + 64);
        }

        while (v37);
LABEL_144:
        if (i)
        {
          uint64_t v48 = 0LL;
          int v49 = 0;
          do
          {
            if (v48 && v28[v48])
            {
              for (uint64_t j = 0LL; j != v48; ++j)
              {
                xmlURIPtr v51 = (void **)v28[j];
              }
            }

            ++v48;
          }

          while (v48 != i);
          unint64_t v52 = 0LL;
          unsigned int v9 = v58;
          do
          {
            int v53 = (void *)v28[v52 / 8];
            if (v53) {
              xmlFree(v53);
            }
            v52 += 8LL;
          }

          while (v65 != v52);
          xmlFree(v28);
          if (v49) {
            *((_WORD *)v6 + 49) |= 4u;
          }
        }

        else
        {
          xmlFree(v28);
          unsigned int v9 = v58;
        }

        uint64_t v11 = v59;
        uint64_t v10 = v60;
        if (v66 == 1)
        {
          *((_WORD *)v6 + 49) |= 0x10u;
          *((void *)v6 + 5) = v29;
          a1 = v61;
        }

        else
        {
          a1 = v61;
          if (v29) {
            xmlHashFree(v29, 0LL);
          }
        }

        *((_WORD *)v6 + 49) |= 0x20u;
LABEL_166:
        uint64_t v19 = *((void *)v6 + 6);
        uint64_t v12 = *v6;
        uint64_t v20 = a1;
        uint64_t v21 = a3;
LABEL_167:
        int v18 = xmlRelaxNGCheckRules(v20, v19, v21, v12);
LABEL_172:
        uint64_t v6 = (unsigned int *)*((void *)v6 + 8);
        if (a4 <= 16)
        {
          if (a4 == 2)
          {
            if (v18 == -1) {
              uint64_t v8 = 0xFFFFFFFFLL;
            }
            else {
              uint64_t v8 = 1LL;
            }
            if (!v6) {
              return v8;
            }
          }

          else
          {
            if (a4 != 8) {
              goto LABEL_180;
            }
            uint64_t v8 = 1LL;
            if (!v6) {
              return v8;
            }
          }

          continue;
        }

        if (a4 == 17)
        {
          if (v18 == 2 || (_DWORD)v8 == 2) {
            unsigned int v55 = 2;
          }
          else {
            unsigned int v55 = 0;
          }
          if (v18 == 1) {
            unsigned int v55 = 1;
          }
          if ((_DWORD)v8 == 1) {
            unsigned int v55 = 1;
          }
LABEL_201:
          if (v18 == -1) {
            unsigned int v55 = -1;
          }
          if ((_DWORD)v8 == -1) {
            uint64_t v8 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v8 = v55;
          }
        }

        else if (a4 != 19)
        {
LABEL_180:
          if (v18 == 2 && (_DWORD)v8 == 2) {
            unsigned int v55 = 2;
          }
          else {
            unsigned int v55 = -1;
          }
          if (!v18) {
            unsigned int v55 = v8;
          }
          if (!(_DWORD)v8) {
            unsigned int v55 = v18;
          }
          goto LABEL_201;
        }

        if (v6) {
          continue;
        }
        return v8;
      case 18:
        if ((a3 & 8) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1072, "Found forbidden pattern data/except//group\n", 0LL, 0LL);
        }
        if ((a3 & 0x10) != 0) {
          xmlRngPErr(a1, *((void *)v6 + 1), 1091, "Found forbidden pattern start//group\n", 0LL, 0LL);
        }
        int v18 = xmlRelaxNGCheckRules(a1, *((void *)v6 + 6), v11, *v6);
        xmlRelaxNGCheckGroupAttrs(a1, (uint64_t)v6);
        goto LABEL_172;
      case 19:
        if ((a3 & 4) != 0)
        {
          xmlRngPErr(a1, *((void *)v6 + 1), 1080, "Found forbidden pattern list//interleave\n", 0LL, 0LL);
          if ((a3 & 8) == 0)
          {
LABEL_74:
            if ((a3 & 0x10) == 0) {
              goto LABEL_76;
            }
            goto LABEL_75;
          }
        }

        else if ((a3 & 8) == 0)
        {
          goto LABEL_74;
        }

        xmlRngPErr(a1, *((void *)v6 + 1), 1073, "Found forbidden pattern data/except//interleave\n", 0LL, 0LL);
        if ((a3 & 0x10) == 0)
        {
LABEL_76:
          uint64_t v19 = *((void *)v6 + 6);
          uint64_t v12 = *v6;
          uint64_t v20 = a1;
          uint64_t v21 = v10;
          goto LABEL_167;
        }

LABEL_75:
        xmlRngPErr(a1, *((void *)v6 + 1), 1073, "Found forbidden pattern start//interleave\n", 0LL, 0LL);
        goto LABEL_76;
      default:
        uint64_t v19 = *((void *)v6 + 6);
        uint64_t v20 = a1;
        uint64_t v21 = a3;
        goto LABEL_167;
    }
  }

  if (*((_DWORD *)DtdAttrDesc + 21) == 4 && !xmlStrEqual(*((const xmlChar **)DtdAttrDesc + 11), value))
  {
    xmlErrValidNode( (uint64_t *)ctxt,  (int)elem,  502,  (uint64_t)"Value for attribute %s of %s must be %s\n",  (uint64_t)attr->name,  (xmlChar *)elem->name,  *((xmlChar **)DtdAttrDesc + 11));
    uint64_t v30 = 0;
  }

  LODWORD(v10) = xmlValidateAttributeValue2( (uint64_t *)ctxt,  doc,  (uint64_t)attr->name,  *((_DWORD *)DtdAttrDesc + 20),  (xmlChar *)value) & v30;
  return (int)v10;
}

        uint64_t v12 = 0;
        goto LABEL_76;
      }

      if (a3 != 1) {
        goto LABEL_66;
      }
LABEL_85:
      uint64_t v12 = xmlUTF8Strlen(str2);
LABEL_76:
      if (*a1 == 1011)
      {
        return 1831LL;
      }

      else
      {
        if (*a1 == 1009)
        {
          if (*(void *)(*((void *)a1 + 7) + 16LL) != v12) {
            return 1830LL;
          }
          return 0LL;
        }

        return 1832LL;
      }

    default:
      uint64_t v14 = *__xmlGenericError();
      uint64_t v15 = __xmlGenericErrorContext();
      v14( *v15,  "Unimplemented block at %s:%d\n",  "/Library/Caches/com.apple.xbs/Sources/libxml2/libxml2/xmlschemastypes.c",  5640);
      return 0LL;
  }

uint64_t xmlRelaxNGParseGrammarContent(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    uint64_t v4 = 0LL;
    uint64_t v5 = (const xmlChar *)"define";
    uint64_t v6 = (const xmlChar *)"include";
    while (1)
    {
      if (!*(void *)(v3 + 72) || *(_DWORD *)(v3 + 8) != 1) {
        goto LABEL_35;
      }
      int v7 = xmlStrEqual(*(const xmlChar **)(v3 + 16), (const xmlChar *)"start");
      uint64_t v8 = *(void *)(v3 + 72);
      if (v7)
      {
        if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          uint64_t v9 = *(void *)(v3 + 24);
          if (v9)
          {
            else {
              uint64_t v4 = v4;
            }
          }

          else
          {
            xmlRngPErr(a1, v3, 1106, "start has no children\n", 0LL, 0LL);
          }

          goto LABEL_37;
        }

        uint64_t v8 = *(void *)(v3 + 72);
      }

      if (!v8 || *(_DWORD *)(v3 + 8) != 1) {
        goto LABEL_35;
      }
      int v10 = xmlStrEqual(*(const xmlChar **)(v3 + 16), v5);
      uint64_t v11 = *(void *)(v3 + 72);
      if (!v10) {
        goto LABEL_24;
      }
      Prop = xmlGetProp((const xmlNode *)v3, (const xmlChar *)"name");
      if (Prop)
      {
        uint64_t v13 = Prop;
        xmlRelaxNGNormExtSpace(Prop);
        if (xmlValidateNCName(v13, 0)) {
          xmlRngPErr(a1, v3, 1049, "define name '%s' is not an NCName\n", v13, 0LL);
        }
        uint64_t v14 = xmlRelaxNGNewDefine(a1, v3);
        if (!v14)
        {
          xmlFree(v13);
LABEL_52:
          uint64_t v4 = 0xFFFFFFFFLL;
          goto LABEL_37;
        }

        uint64_t v15 = v14;
        *(_DWORD *)uint64_t v14 = 10;
        *((void *)v14 + 2) = v13;
        uint64_t v16 = *(void *)(v3 + 24);
        if (v16)
        {
          int v17 = v5;
          int v18 = v6;
          uint64_t v19 = *(void *)(a1 + 80);
          *(void *)(a1 + 80) = v13;
          *((void *)v14 + 6) = xmlRelaxNGParsePatterns(a1, v16, 0);
          *(void *)(a1 + 80) = v19;
          uint64_t v6 = v18;
          uint64_t v5 = v17;
        }

        else
        {
          xmlRngPErr(a1, v3, 1012, "define has no children\n", 0LL, 0LL);
        }

        uint64_t v29 = *(xmlHashTable **)(*(void *)(a1 + 48) + 48LL);
        if (!v29)
        {
          uint64_t v29 = xmlHashCreate(10);
          *(void *)(*(void *)(a1 + 48) + 48LL) = v29;
          if (!v29)
          {
            uint64_t v32 = a1;
            uint64_t v33 = v3;
            int v34 = "Could not create definition hash\n";
            uint64_t v35 = 0LL;
LABEL_51:
            xmlRngPErr(v32, v33, 1011, v34, v35, 0LL);
            goto LABEL_52;
          }
        }

        if (xmlHashAddEntry(v29, v13, v15) < 0)
        {
          uint64_t v30 = xmlHashLookup(*(xmlHashTablePtr *)(*(void *)(a1 + 48) + 48LL), v13);
          if (v30)
          {
            do
            {
              uint64_t v31 = v30;
              uint64_t v30 = (void *)v30[11];
            }

            while (v30);
            v31[11] = v15;
            goto LABEL_37;
          }

          uint64_t v32 = a1;
          uint64_t v33 = v3;
          int v34 = "Internal error on define aggregation of %s\n";
          uint64_t v35 = v13;
          goto LABEL_51;
        }
      }

      else
      {
        xmlRngPErr(a1, v3, 1014, "define has no name\n", 0LL, 0LL);
      }

_OWORD *xmlRelaxNGCheckCombine(_OWORD *result, uint64_t a2, const xmlChar *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!*((void *)result + 11)) {
    return result;
  }
  uint64_t v5 = result;
  int v6 = 0;
  int v7 = -1;
  uint64_t v8 = (const xmlNode **)result;
  do
  {
    Prop = xmlGetProp(v8[1], (const xmlChar *)"combine");
    if (Prop)
    {
      int v10 = Prop;
      if (xmlStrEqual(Prop, (const xmlChar *)"choice"))
      {
        if (v7)
        {
          int v7 = 1;
LABEL_15:
          xmlFree(v10);
          goto LABEL_16;
        }
      }

      else
      {
        if (!xmlStrEqual(v10, (const xmlChar *)"interleave"))
        {
          uint64_t v11 = *((void *)v5 + 1);
          uint64_t v12 = a2;
          int v13 = 1114;
          uint64_t v14 = "Defines for %s use unknown combine value '%s''\n";
          uint64_t v15 = a3;
          uint64_t v16 = v10;
          goto LABEL_14;
        }

        if (v7 != 1)
        {
          int v7 = 0;
          goto LABEL_15;
        }
      }

      uint64_t v11 = *((void *)v5 + 1);
      uint64_t v12 = a2;
      int v13 = 1010;
      uint64_t v14 = "Defines for %s use both 'choice' and 'interleave'\n";
      uint64_t v15 = a3;
      uint64_t v16 = 0LL;
LABEL_14:
      xmlRngPErr(v12, v11, v13, v14, v15, v16);
      goto LABEL_15;
    }

    if (v6) {
      xmlRngPErr(a2, *((void *)v5 + 1), 1054, "Some defines for %s needs the combine attribute\n", a3, 0LL);
    }
    int v6 = 1;
LABEL_16:
    uint64_t v8 = (const xmlNode **)v8[11];
  }

  while (v8);
  uint64_t result = xmlRelaxNGNewDefine(a2, *((void *)v5 + 1));
  if (result)
  {
    int v17 = result;
    int v18 = 0LL;
    unsigned int v19 = v7 + 1;
    else {
      int v20 = 19;
    }
    *(_DWORD *)uint64_t result = v20;
    uint64_t v21 = result + 3;
    xmlNodePtr v22 = v5;
    do
    {
      uint64_t result = (_OWORD *)*((void *)v22 + 6);
      if (result)
      {
        if (*((void *)result + 8))
        {
          uint64_t result = xmlRelaxNGNewDefine(a2, *((void *)result + 1));
          if (!result) {
            break;
          }
          *(_DWORD *)uint64_t result = 18;
          *((void *)result + 6) = *((void *)v22 + 6);
        }

        int v23 = v18 + 4;
        if (!v18) {
          int v23 = v21;
        }
        *int v23 = result;
        int v18 = result;
      }

      *((void *)v22 + 6) = v17;
      xmlNodePtr v22 = (_OWORD *)*((void *)v22 + 11);
    }

    while (v22);
    *((void *)v5 + 6) = v17;
    if (v19 <= 1)
    {
      if (*(void *)(a2 + 104) || (xmlHashTablePtr v24 = xmlHashCreate(10), (*(void *)(a2 + 104) = v24) != 0LL))
      {
        *(_OWORD *)__str = 0u;
        __int128 v27 = 0u;
        int v25 = *(_DWORD *)(a2 + 96);
        *(_DWORD *)(a2 + 96) = v25 + 1;
        snprintf(__str, 0x20uLL, "interleave%d", v25);
        uint64_t result = (_OWORD *)xmlHashAddEntry(*(xmlHashTablePtr *)(a2 + 104), (const xmlChar *)__str, v17);
        if ((result & 0x80000000) != 0) {
          return xmlRngPErr( a2,  *((void *)v5 + 1),  1046,  "Failed to add %s to hash table\n",  (const xmlChar *)__str,  0LL);
        }
      }

      else
      {
        return xmlRngPErr(a2, *((void *)v5 + 1), 1046, "Failed to create interleaves hash table\n", 0LL, 0LL);
      }
    }
  }

  return result;
}

_DWORD *xmlRelaxNGCheckReference(_DWORD *result, uint64_t a2, const xmlChar *a3)
{
  if ((*((_WORD *)result + 49) & 0x100) == 0)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(a2 + 48);
    if (!v6)
    {
      uint64_t v7 = *((void *)result + 1);
      uint64_t v8 = "Internal error: no grammar in CheckReference %s\n";
      goto LABEL_6;
    }

    if (*((void *)result + 6))
    {
      uint64_t v7 = *((void *)result + 1);
      uint64_t v8 = "Internal error: reference has content in CheckReference %s\n";
LABEL_6:
      uint64_t v9 = a2;
      int v10 = 1;
      return xmlRngPErr(v9, v7, v10, v8, a3, 0LL);
    }

    uint64_t v11 = *(xmlHashTable **)(v6 + 48);
    if (!v11 || (uint64_t result = xmlHashLookup(v11, a3)) == 0LL)
    {
      uint64_t v7 = v5[1];
      uint64_t v8 = "Reference %s has no matching definition\n";
      uint64_t v9 = a2;
      int v10 = 1101;
      return xmlRngPErr(v9, v7, v10, v8, a3, 0LL);
    }

    do
    {
      v5[6] = result;
      uint64_t v5 = (void *)v5[11];
    }

    while (v5);
  }

  return result;
}

uint64_t *xmlRelaxNGParsePatterns(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = a2;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  uint64_t v8 = *(void *)(a1 + 88);
  do
  {
    if (*(void *)(v4 + 72)
      && *(_DWORD *)(v4 + 8) == 1
      && xmlStrEqual(*(const xmlChar **)(v4 + 16), (const xmlChar *)"element")
      && xmlStrEqual( *(const xmlChar **)(*(void *)(v4 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
    {
      uint64_t v9 = (uint64_t *)xmlRelaxNGParseElement(a1, v4);
      if (!v9) {
        return 0LL;
      }
      int v10 = v9;
      if (v7)
      {
        if (a3 == 1 && *(_DWORD *)v7 == 4 && v7 == v6)
        {
          uint64_t v11 = (uint64_t *)xmlRelaxNGNewDefine(a1, v4);
          uint64_t v7 = v11;
          if (!v11) {
            return v7;
          }
          *(_DWORD *)uint64_t v11 = 18;
          v11[6] = (uint64_t)v6;
        }

        v6[8] = (uint64_t)v10;
        uint64_t v9 = v7;
      }

      _OWORD v10[7] = v8;
      uint64_t v7 = v9;
    }

    else
    {
      uint64_t v12 = xmlRelaxNGParsePattern(a1, v4);
      if (v12)
      {
        int v10 = v12;
        if (v7) {
          v6[8] = (uint64_t)v12;
        }
        else {
          uint64_t v7 = v12;
        }
      }

      else
      {
        int v10 = v6;
      }
    }

    uint64_t v4 = *(void *)(v4 + 48);
    uint64_t v6 = v10;
  }

  while (v4);
  return v7;
}

_OWORD *xmlRelaxNGParseElement(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = xmlRelaxNGNewDefine(a1, a2);
  uint64_t v5 = v4;
  if (!v4) {
    return v5;
  }
  *(_DWORD *)uint64_t v4 = 4;
  *((void *)v4 + 7) = *(void *)(a1 + 88);
  uint64_t v6 = *(void *)(a2 + 24);
  if (!v6)
  {
    int v17 = "xmlRelaxNGParseElement: element has no children\n";
    uint64_t v18 = a1;
    uint64_t v19 = a2;
    int v20 = 1017;
LABEL_27:
    xmlRngPErr(v18, v19, v20, v17, 0LL, 0LL);
    return v5;
  }

  if (xmlRelaxNGParseNameClass(a1, *(void *)(a2 + 24), (uint64_t)v4))
  {
    uint64_t v6 = *(void *)(v6 + 48);
    if (!v6)
    {
      int v17 = "xmlRelaxNGParseElement: element has no content\n";
      uint64_t v18 = a1;
      uint64_t v19 = a2;
      int v20 = 1020;
      goto LABEL_27;
    }
  }

  uint64_t v7 = 0LL;
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = (uint64_t **)(v5 + 3);
  *(void *)(a1 + 80) = 0LL;
  do
  {
    int v10 = xmlRelaxNGParsePattern(a1, v6);
    if (v10)
    {
      uint64_t v11 = v10;
      _OWORD v10[7] = (uint64_t)v5;
      switch(*(_DWORD *)v10)
      {
        case 0xFFFFFFFF:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, noop found in element\n";
          goto LABEL_21;
        case 0:
        case 1:
        case 3:
        case 4:
        case 5:
        case 7:
        case 8:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
          if (v7)
          {
            if (*(_DWORD *)v7 == 4 && *v9 == v7)
            {
              uint64_t v12 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
              *uint64_t v9 = v12;
              int v13 = (uint64_t **)(v5 + 3);
              if (v12)
              {
                *(_DWORD *)uint64_t v12 = 18;
                int v13 = (uint64_t **)(v12 + 6);
              }

              xmlChar *v13 = v7;
            }

            v7[8] = (uint64_t)v11;
          }

          else
          {
            *uint64_t v9 = v10;
          }

          goto LABEL_23;
        case 2:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, except found in element\n";
          goto LABEL_21;
        case 6:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, param found in element\n";
          goto LABEL_21;
        case 9:
          v10[8] = *((void *)v5 + 9);
          *((void *)v5 + 9) = v10;
          break;
        case 0x14:
          uint64_t v14 = a1;
          uint64_t v15 = a2;
          uint64_t v16 = "RNG Internal error, start found in element\n";
LABEL_21:
          xmlRngPErr(v14, v15, 1018, v16, 0LL, 0LL);
          break;
        default:
          break;
      }
    }

    uint64_t v11 = v7;
LABEL_23:
    uint64_t v6 = *(void *)(v6 + 48);
    uint64_t v7 = v11;
  }

  while (v6);
  *(void *)(a1 + 80) = v8;
  return v5;
}

uint64_t *xmlRelaxNGParsePattern(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 72) || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_257;
  }
  int v4 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"element");
  uint64_t v5 = *(void *)(a2 + 72);
  if (v4)
  {
    uint64_t v5 = *(void *)(a2 + 72);
  }

  if (!v5 || *(_DWORD *)(a2 + 8) != 1) {
    goto LABEL_257;
  }
  int v7 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"attribute");
  uint64_t v8 = *(void *)(a2 + 72);
  if (!v7)
  {
LABEL_23:
    if (v8 && *(_DWORD *)(a2 + 8) == 1)
    {
      int v16 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"empty");
      uint64_t v17 = *(void *)(a2 + 72);
      if (v16)
      {
        if (xmlStrEqual(*(const xmlChar **)(v17 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          uint64_t v18 = xmlRelaxNGNewDefine(a1, a2);
          int v10 = v18;
          if (!v18) {
            return (uint64_t *)v10;
          }
          *(_DWORD *)uint64_t v18 = 0;
          if (!*(void *)(a2 + 24)) {
            return (uint64_t *)v10;
          }
          uint64_t v19 = "empty: had a child node\n";
          uint64_t v20 = a1;
          uint64_t v21 = a2;
          int v22 = 1025;
          goto LABEL_31;
        }

        uint64_t v17 = *(void *)(a2 + 72);
      }

      if (v17 && *(_DWORD *)(a2 + 8) == 1)
      {
        int v25 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"text");
        uint64_t v26 = *(void *)(a2 + 72);
        if (v25)
        {
          if (xmlStrEqual(*(const xmlChar **)(v26 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            __int128 v27 = xmlRelaxNGNewDefine(a1, a2);
            int v10 = v27;
            if (!v27) {
              return (uint64_t *)v10;
            }
            *(_DWORD *)__int128 v27 = 3;
            if (!*(void *)(a2 + 24)) {
              return (uint64_t *)v10;
            }
            uint64_t v19 = "text: had a child node\n";
            uint64_t v20 = a1;
            uint64_t v21 = a2;
            int v22 = 1109;
            goto LABEL_31;
          }

          uint64_t v26 = *(void *)(a2 + 72);
        }

        if (v26 && *(_DWORD *)(a2 + 8) == 1)
        {
          int v32 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"zeroOrMore");
          uint64_t v33 = *(void *)(a2 + 72);
          if (v32)
          {
            if (xmlStrEqual(*(const xmlChar **)(v33 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
            {
              int v10 = xmlRelaxNGNewDefine(a1, a2);
              if (!v10) {
                return (uint64_t *)v10;
              }
              int v34 = 15;
LABEL_51:
              *(_DWORD *)int v10 = v34;
              if (*(void *)(a2 + 24))
              {
                uint64_t v35 = a1;
LABEL_53:
                uint64_t v36 = (_OWORD *)xmlRelaxNGParsePatterns(v35);
LABEL_54:
                *((void *)v10 + 6) = v36;
                return (uint64_t *)v10;
              }

              goto LABEL_80;
            }

            uint64_t v33 = *(void *)(a2 + 72);
          }

          if (v33 && *(_DWORD *)(a2 + 8) == 1)
          {
            int v37 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"oneOrMore");
            uint64_t v38 = *(void *)(a2 + 72);
            if (v37)
            {
              if (xmlStrEqual(*(const xmlChar **)(v38 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
              {
                int v10 = xmlRelaxNGNewDefine(a1, a2);
                if (!v10) {
                  return (uint64_t *)v10;
                }
                int v34 = 16;
                goto LABEL_51;
              }

              uint64_t v38 = *(void *)(a2 + 72);
            }

            if (v38 && *(_DWORD *)(a2 + 8) == 1)
            {
              int v39 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"optional");
              uint64_t v40 = *(void *)(a2 + 72);
              if (v39)
              {
                if (xmlStrEqual(*(const xmlChar **)(v40 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                {
                  int v10 = xmlRelaxNGNewDefine(a1, a2);
                  if (!v10) {
                    return (uint64_t *)v10;
                  }
                  int v34 = 14;
                  goto LABEL_51;
                }

                uint64_t v40 = *(void *)(a2 + 72);
              }

              if (v40 && *(_DWORD *)(a2 + 8) == 1)
              {
                int v41 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"choice");
                uint64_t v42 = *(void *)(a2 + 72);
                if (v41)
                {
                  if (xmlStrEqual( *(const xmlChar **)(v42 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                  {
                    int v10 = xmlRelaxNGNewDefine(a1, a2);
                    if (!v10) {
                      return (uint64_t *)v10;
                    }
                    int v43 = 17;
LABEL_78:
                    *(_DWORD *)int v10 = v43;
                    if (*(void *)(a2 + 24))
                    {
                      uint64_t v35 = a1;
                      goto LABEL_53;
                    }

LABEL_158:
                                int v87 = *(const xmlNode **)(a2 + 24);
                                if (v87)
                                {
                                  uint64_t v88 = 0LL;
                                  while (xmlStrEqual(v87->name, (const xmlChar *)"param"))
                                  {
                                    if (xmlStrEqual(v59, (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                    {
                                      xmlRngPErr( a1,  a2,  1058,  "Type library '%s' does not allow type parameters\n",  v59,  0LL);
                                      while (1)
                                      {
                                        int v87 = v87->next;
                                        if (!v87) {
                                          return (uint64_t *)v10;
                                        }
                                        if (!xmlStrEqual(v87->name, (const xmlChar *)"param")) {
                                          goto LABEL_173;
                                        }
                                      }
                                    }

                                    __int128 v89 = xmlRelaxNGNewDefine(a1, a2);
                                    if (v89)
                                    {
                                      int v90 = v89;
                                      *(_DWORD *)__int128 v89 = 6;
                                      uint64_t v91 = xmlGetProp(v87, (const xmlChar *)"name");
                                      *((void *)v90 + 2) = v91;
                                      if (!v91) {
                                        xmlRngPErr(a1, a2, 1059, "param has no name\n", 0LL, 0LL);
                                      }
                                      *((void *)v90 + 4) = xmlNodeGetContent(v87);
                                      int v92 = v88 + 4;
                                      if (!v88) {
                                        int v92 = (void *)v10 + 9;
                                      }
                                      void *v92 = v90;
                                      uint64_t v88 = v90;
                                    }

                                    int v87 = v87->next;
LABEL_173:
                                    if (!v87) {
                                      return (uint64_t *)v10;
                                    }
                                  }

                                  if (!xmlStrEqual(v87->name, (const xmlChar *)"except")) {
                                    goto LABEL_215;
                                  }
                                  int v95 = xmlRelaxNGNewDefine(a1, a2);
                                  if (v95)
                                  {
                                    *(_DWORD *)int v95 = 2;
                                    xmlNodePtr children = v87->children;
                                    *((void *)v10 + 6) = v95;
                                    if (children)
                                    {
                                      uint64_t v97 = 0LL;
                                      uint64_t v98 = (uint64_t *)(v95 + 3);
                                      do
                                      {
                                        uint64_t v99 = xmlRelaxNGParsePattern(a1, children);
                                        if (v99)
                                        {
                                          uint64_t v100 = (uint64_t *)(v97 + 64);
                                          if (!v97) {
                                            uint64_t v100 = v98;
                                          }
                                          *uint64_t v100 = v99;
                                          uint64_t v97 = v99;
                                        }

                                        xmlNodePtr children = children->next;
                                      }

                                      while (children);
                                    }

                                    else
                                    {
                                      xmlRngPErr(a1, (uint64_t)v87, 1030, "except has no content\n", 0LL, 0LL);
                                    }

                                    int v87 = v87->next;
                                    if (v87)
                                    {
LABEL_215:
                                      name = v87->name;
                                      uint64_t v19 = "Element data has unexpected content %s\n";
                                      uint64_t v20 = a1;
                                      uint64_t v21 = (uint64_t)v87;
                                      int v22 = 1009;
                                      goto LABEL_32;
                                    }
                                  }
                                }

                                return (uint64_t *)v10;
                              }

                              uint64_t v85 = (const xmlChar *)*((void *)v10 + 2);
                              uint64_t v81 = "Error type '%s' is not exported by type library '%s'\n";
                              uint64_t v82 = a1;
                              uint64_t v83 = a2;
                              int v84 = 1111;
                              int v86 = v59;
                            }

                            else
                            {
                              uint64_t v81 = "Internal error with type library '%s': no 'have'\n";
                              uint64_t v82 = a1;
                              uint64_t v83 = a2;
                              int v84 = 1026;
                              uint64_t v85 = v59;
                              int v86 = 0LL;
                            }

                            xmlRngPErr(v82, v83, v84, v81, v85, v86);
                            goto LABEL_158;
                          }

                          __int128 v74 = "data has no type\n";
                          uint64_t v75 = a1;
                          uint64_t v76 = a2;
                          int v77 = 1110;
LABEL_143:
                          int v78 = 0LL;
LABEL_258:
                          xmlRngPErr(v75, v76, v77, v74, v78, 0LL);
                          return 0LL;
                        }

                        uint64_t v56 = *(void *)(a2 + 72);
                      }

                      if (v56 && *(_DWORD *)(a2 + 8) == 1)
                      {
                        int v65 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"value");
                        uint64_t v66 = *(void *)(a2 + 72);
                        if (v65)
                        {
                          if (xmlStrEqual( *(const xmlChar **)(v66 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                          {
                            uint64_t v67 = xmlRelaxNGNewDefine(a1, a2);
                            int v10 = v67;
                            if (!v67) {
                              return (uint64_t *)v10;
                            }
                            *(_DWORD *)uint64_t v67 = 7;
                            int v68 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"type");
                            uint64_t v69 = v68;
                            if (v68)
                            {
                              xmlRelaxNGNormExtSpace(v68);
                              if (xmlValidateNCName(v69, 0)) {
                                xmlRngPErr(a1, a2, 1112, "value type '%s' is not an NCName\n", v69, 0LL);
                              }
                              xmlDocPtr v70 = xmlRelaxNGGetDataTypeLibrary(a2);
                              if (!v70) {
                                xmlDocPtr v70 = xmlStrdup((const xmlChar *)"http://relaxng.org/ns/structure/1.0");
                              }
                              *((void *)v10 + 2) = v69;
                              *((void *)v10 + 3) = v70;
                              xmlNodePtr v71 = (unsigned __int8 *)xmlHashLookup((xmlHashTablePtr)xmlRelaxNGRegisteredTypes, v70);
                              uint64_t v69 = v71;
                              if (!v71)
                              {
                                xmlRngPErr(a1, a2, 1116, "Use of unregistered type library '%s'\n", v70, 0LL);
                                int v73 = 0;
                                *((void *)v10 + 5) = 0LL;
                                goto LABEL_194;
                              }

                              *((void *)v10 + 5) = v71;
                              char v72 = (uint64_t (*)(void, void))*((void *)v71 + 2);
                              if (v72)
                              {
                                int v73 = v72(*((void *)v71 + 1), *((void *)v10 + 2));
                                if (v73 != 1) {
                                  xmlRngPErr( a1,  a2,  1111,  "Error type '%s' is not exported by type library '%s'\n",  *((const xmlChar **)v10 + 2),  v70);
                                }
LABEL_194:
                                uint64_t v101 = *(void *)(a2 + 24);
                                if (!v101)
                                {
                                  *((void *)v10 + 4) = xmlStrdup((const xmlChar *)&byte_181A3ACBA);
                                  return (uint64_t *)v10;
                                }

                                if ((*(_DWORD *)(v101 + 8) - 3) > 1 || *(void *)(v101 + 48))
                                {
                                  uint64_t v19 = "Expecting a single text value for <value>content\n";
                                  uint64_t v20 = a1;
                                  uint64_t v21 = a2;
                                  int v22 = 1108;
                                }

                                else
                                {
                                  Content = xmlNodeGetContent((const xmlNode *)a2);
                                  *((void *)v10 + 4) = Content;
                                  if (Content)
                                  {
                                    if (!v69) {
                                      return (uint64_t *)v10;
                                    }
                                    if (v73 != 1) {
                                      return (uint64_t *)v10;
                                    }
                                    uint64_t v103 = (unsigned int (*)(void, void, xmlChar *, uint64_t *, uint64_t))*((void *)v69 + 3);
                                    if (!v103) {
                                      return (uint64_t *)v10;
                                    }
                                    uint64_t v128 = 0LL;
                                    if (v103(*((void *)v69 + 1), *((void *)v10 + 2), Content, &v128, a2) == 1)
                                    {
                                      if (v128) {
                                        *((void *)v10 + 9) = v128;
                                      }
                                      return (uint64_t *)v10;
                                    }

                                    name = (const xmlChar *)*((void *)v10 + 4);
                                    xmlHashTablePtr v24 = (xmlChar *)*((void *)v10 + 2);
                                    uint64_t v19 = "Value '%s' is not acceptable for type '%s'\n";
                                    uint64_t v20 = a1;
                                    uint64_t v21 = a2;
                                    int v22 = 1051;
                                    goto LABEL_33;
                                  }

                                  uint64_t v19 = "Element <value> has no content\n";
                                  uint64_t v20 = a1;
                                  uint64_t v21 = a2;
                                  int v22 = 1120;
                                }

                                goto LABEL_31;
                              }

                              xmlRngPErr(a1, a2, 1026, "Internal error with type library '%s': no 'have'\n", v70, 0LL);
                            }

                            int v73 = 0;
                            goto LABEL_194;
                          }

                          uint64_t v66 = *(void *)(a2 + 72);
                        }

                        if (v66 && *(_DWORD *)(a2 + 8) == 1)
                        {
                          int v79 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"list");
                          uint64_t v80 = *(void *)(a2 + 72);
                          if (v79)
                          {
                            if (xmlStrEqual( *(const xmlChar **)(v80 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                            {
                              int v10 = xmlRelaxNGNewDefine(a1, a2);
                              if (!v10) {
                                return (uint64_t *)v10;
                              }
                              int v43 = 8;
                              goto LABEL_78;
                            }

                            uint64_t v80 = *(void *)(a2 + 72);
                          }

                          if (v80 && *(_DWORD *)(a2 + 8) == 1)
                          {
                            int v93 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"interleave");
                            uint64_t v94 = *(void *)(a2 + 72);
                            if (v93)
                            {
                              if (xmlStrEqual( *(const xmlChar **)(v94 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                              {
                                return xmlRelaxNGParseInterleave(a1, a2);
                              }

                              uint64_t v94 = *(void *)(a2 + 72);
                            }

                            if (v94 && *(_DWORD *)(a2 + 8) == 1)
                            {
                              int v104 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"externalRef");
                              uint64_t v105 = *(void *)(a2 + 72);
                              if (v104)
                              {
                                if (xmlStrEqual( *(const xmlChar **)(v105 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                {
                                  return (uint64_t *)xmlRelaxNGProcessExternalRef(a1, a2);
                                }

                                uint64_t v105 = *(void *)(a2 + 72);
                              }

                              if (v105 && *(_DWORD *)(a2 + 8) == 1)
                              {
                                int v106 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"notAllowed");
                                uint64_t v107 = *(void *)(a2 + 72);
                                if (v106)
                                {
                                  if (xmlStrEqual( *(const xmlChar **)(v107 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                  {
                                    unint64_t v108 = xmlRelaxNGNewDefine(a1, a2);
                                    int v10 = v108;
                                    if (!v108) {
                                      return (uint64_t *)v10;
                                    }
                                    *(_DWORD *)unint64_t v108 = 1;
                                    if (!*(void *)(a2 + 24)) {
                                      return (uint64_t *)v10;
                                    }
                                    uint64_t v19 = "xmlRelaxNGParse: notAllowed element is not empty\n";
                                    uint64_t v20 = a1;
                                    uint64_t v21 = a2;
                                    int v22 = 1055;
                                    goto LABEL_31;
                                  }

                                  uint64_t v107 = *(void *)(a2 + 72);
                                }

                                if (v107 && *(_DWORD *)(a2 + 8) == 1)
                                {
                                  int v109 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"grammar");
                                  uint64_t v110 = *(void *)(a2 + 72);
                                  if (v109)
                                  {
                                    if (xmlStrEqual( *(const xmlChar **)(v110 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                    {
                                      uint64_t v111 = *(void *)(a1 + 48);
                                      __int128 v127 = *(_OWORD *)(a1 + 48);
                                      *(void *)(a1 + 56) = v127;
                                      uint64_t v112 = xmlRelaxNGParseGrammar(a1, *(void *)(a2 + 24));
                                      if (v111) {
                                        *(_OWORD *)(a1 + 48) = v127;
                                      }
                                      if (v112) {
                                        return *(uint64_t **)(v112 + 24);
                                      }
                                      return 0LL;
                                    }

                                    uint64_t v110 = *(void *)(a2 + 72);
                                  }

                                  if (v110 && *(_DWORD *)(a2 + 8) == 1)
                                  {
                                    int v113 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"parentRef");
                                    uint64_t v114 = *(void *)(a2 + 72);
                                    if (v113)
                                    {
                                      if (xmlStrEqual( *(const xmlChar **)(v114 + 16),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                      {
                                        if (!*(void *)(a1 + 56))
                                        {
                                          __int128 v74 = "Use of parentRef without a parent grammar\n";
                                          uint64_t v75 = a1;
                                          uint64_t v76 = a2;
                                          int v77 = 1063;
                                          goto LABEL_143;
                                        }

                                        uint64_t v115 = xmlRelaxNGNewDefine(a1, a2);
                                        int v10 = v115;
                                        if (!v115) {
                                          return (uint64_t *)v10;
                                        }
                                        *(_DWORD *)uint64_t v115 = 13;
                                        uint64_t v116 = xmlGetProp((const xmlNode *)a2, (const xmlChar *)"name");
                                        *((void *)v10 + 2) = v116;
                                        if (v116)
                                        {
                                          xmlRelaxNGNormExtSpace(v116);
                                          if (!xmlValidateNCName(*((const xmlChar **)v10 + 2), 0))
                                          {
LABEL_264:
                                            if (*(void *)(a2 + 24)) {
                                              xmlRngPErr(a1, a2, 1064, "parentRef is not empty\n", 0LL, 0LL);
                                            }
                                            unsigned int v125 = *(xmlHashTable **)(*(void *)(a1 + 56) + 56LL);
                                            if (v125
                                              || (unsigned int v125 = xmlHashCreate(10),
                                                  (*(void *)(*(void *)(a1 + 56) + 56LL) = v125) != 0LL))
                                            {
                                              uint64_t v126 = (const xmlChar *)*((void *)v10 + 2);
                                              if (!v126 || (xmlHashAddEntry(v125, v126, v10) & 0x80000000) == 0) {
                                                return (uint64_t *)v10;
                                              }
                                              unsigned int v64 = xmlHashLookup( *(xmlHashTablePtr *)(*(void *)(a1 + 56) + 56LL),  *((const xmlChar **)v10 + 2));
                                              if (v64) {
                                                goto LABEL_123;
                                              }
                                              int v78 = (const xmlChar *)*((void *)v10 + 2);
                                              __int128 v74 = "Internal error parentRef definitions '%s'\n";
                                              uint64_t v75 = a1;
                                              uint64_t v76 = a2;
                                              int v77 = 1060;
                                              goto LABEL_258;
                                            }

                                            __int128 v74 = "Could not create references hash\n";
                                            uint64_t v75 = a1;
                                            uint64_t v76 = a2;
                                            int v77 = 1060;
                                            goto LABEL_143;
                                          }

                                          unsigned int v117 = (const xmlChar *)*((void *)v10 + 2);
                                          unsigned int v118 = "parentRef name '%s' is not an NCName\n";
                                          uint64_t v119 = a1;
                                          uint64_t v120 = a2;
                                          int v121 = 1061;
                                        }

                                        else
                                        {
                                          unsigned int v118 = "parentRef has no name\n";
                                          uint64_t v119 = a1;
                                          uint64_t v120 = a2;
                                          int v121 = 1062;
                                          unsigned int v117 = 0LL;
                                        }

                                        xmlRngPErr(v119, v120, v121, v118, v117, 0LL);
                                        goto LABEL_264;
                                      }

                                      uint64_t v114 = *(void *)(a2 + 72);
                                    }

                                    if (v114
                                      && *(_DWORD *)(a2 + 8) == 1
                                      && xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"mixed")
                                      && xmlStrEqual( *(const xmlChar **)(*(void *)(a2 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
                                    {
                                      if (*(void *)(a2 + 24))
                                      {
                                        uint64_t v122 = xmlRelaxNGParseInterleave(a1, a2);
                                        int v10 = v122;
                                        if (!v122) {
                                          return (uint64_t *)v10;
                                        }
                                        uint64_t v123 = v122[6];
                                        if (v123)
                                        {
                                          if (*(void *)(v123 + 64))
                                          {
                                            int v124 = xmlRelaxNGNewDefine(a1, a2);
                                            if (v124)
                                            {
                                              *(_DWORD *)int v124 = 18;
                                              *((void *)v124 + 6) = *((void *)v10 + 6);
                                              *((void *)v10 + 6) = v124;
                                            }
                                          }
                                        }

                                        uint64_t v36 = xmlRelaxNGNewDefine(a1, a2);
                                        if (!v36) {
                                          return (uint64_t *)v10;
                                        }
                                        *(_DWORD *)uint64_t v36 = 3;
                                        *((void *)v36 + 8) = *((void *)v10 + 6);
                                        goto LABEL_54;
                                      }

                                      __int128 v74 = "Mixed is empty\n";
                                      uint64_t v75 = a1;
                                      uint64_t v76 = a2;
                                      int v77 = 1023;
                                      goto LABEL_143;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

              if (*(_DWORD *)(a1 + 32) != 3069) {
                goto LABEL_149;
              }
              goto LABEL_159;
            }

            if ((v62 & 0x40) == 0) {
              goto LABEL_158;
            }
            if (*(void *)(v30 + 56)) {
              goto LABEL_158;
            }
            unsigned int v63 = *(const xmlChar **)(v30 + 96);
            if (!v63) {
              goto LABEL_158;
            }
            unsigned int v64 = xmlSchemaGetType(*(void *)(a1 + 64), v63, *(xmlChar **)(v30 + 104));
            *(void *)(v30 + 56) = v64;
            if (v64)
            {
              if (*v64 == 4 || *v64 == 1 && v64[40] != 45) {
                goto LABEL_158;
              }
            }

            *(void *)(v30 + 56) = 0LL;
            int v65 = *(void *)(v30 + 72);
            uint64_t v66 = *(xmlChar **)(v30 + 96);
            uint64_t v67 = *(const xmlChar **)(v30 + 104);
            int v68 = a1;
            uint64_t v69 = v30;
            xmlDocPtr v70 = "itemType";
          }

          else
          {
            int v65 = *(void *)(v30 + 72);
            uint64_t v66 = *(xmlChar **)(v30 + 96);
            uint64_t v67 = *(const xmlChar **)(v30 + 104);
            int v68 = a1;
            uint64_t v69 = v30;
            xmlDocPtr v70 = "base";
          }

          xmlSchemaPResCompAttrErr(v68, v69, v65, (uint64_t)v70, v66, v67, 4, 0LL);
          goto LABEL_158;
        case 6:
        case 7:
        case 8:
          int v32 = *(void *)(v30 + 24);
          if (!v32) {
            goto LABEL_148;
          }
          while (1)
          {
            uint64_t v33 = *(void *)(v32 + 24);
            if (!v33 || *(_DWORD *)v33 != 2000) {
              goto LABEL_50;
            }
            *(void *)(v32 + 24) = 0LL;
            int v34 = xmlSchemaGetNamedComponent( *(void *)(a1 + 64),  *(_DWORD *)(v33 + 16),  *(const xmlChar **)(v33 + 24),  *(xmlChar **)(v33 + 32));
            if (!v34)
            {
              int v37 = xmlSchemaGetComponentNode((_DWORD *)v32);
              xmlSchemaPResCompAttrErr( a1,  0LL,  v37,  (uint64_t)"ref",  *(xmlChar **)(v33 + 24),  *(const xmlChar **)(v33 + 32),  *(_DWORD *)(v33 + 16),  0LL);
              goto LABEL_50;
            }

            if (*(_DWORD *)v34 != 17) {
              break;
            }
            uint64_t v35 = (_DWORD *)v34[3];
            if (v35)
            {
              if (*v35 != 8) {
                break;
              }
              uint64_t v36 = xmlSchemaGetComponentNode((_DWORD *)v32);
              xmlSchemaCustomErr4( (_DWORD *)a1,  3091,  v36,  0LL,  (const xmlChar *)"A model group definition is referenced, but it contains an 'all' model group, which can not be contained by model groups",  0LL,  0LL,  0LL,  0LL);
            }

          int v23 = 0LL;
          ctxt->xmlDocPtr cur = jj + 1;
LABEL_160:
          uint64_t v11 = -1;
LABEL_161:
          int v25 = 1;
          goto LABEL_162;
        }

        if (xmlStrEqual(v10, (const xmlChar *)"node"))
        {
          int v37 = 0;
          xmlHashTablePtr v24 = 0;
          goto LABEL_139;
        }

        if (xmlStrEqual(v10, (const xmlChar *)"processing-instruction"))
        {
          xmlHashTablePtr v24 = 7;
          int v37 = 1;
          goto LABEL_139;
        }

        if (xmlStrEqual(v10, (const xmlChar *)"text"))
        {
          int v37 = 0;
          xmlHashTablePtr v24 = 3;
          goto LABEL_139;
        }

        xmlFree(v10);
LABEL_177:
        xmlXPathErr(ctxt, 7);
        return;
      }

      if (v19 == 110)
      {
        if (!xmlStrEqual(v10, (const xmlChar *)"namespace")) {
          goto LABEL_30;
        }
        uint64_t v17 = 9;
        goto LABEL_113;
      }

      if (v19 != 112)
      {
        if (v19 != 115 || !xmlStrEqual(v10, (const xmlChar *)"self")) {
          goto LABEL_30;
        }
        uint64_t v17 = 13;
        goto LABEL_113;
      }

      if (xmlStrEqual(v10, (const xmlChar *)"parent")) {
        uint64_t v17 = 10;
      }
      else {
        uint64_t v17 = 0;
      }
      if (xmlStrEqual(v10, (const xmlChar *)"preceding")) {
        uint64_t v17 = 11;
      }
      if (xmlStrEqual(v10, (const xmlChar *)"preceding-sibling"))
      {
        uint64_t v17 = 12;
        goto LABEL_113;
      }

LABEL_257:
    int v78 = *(const xmlChar **)(a2 + 16);
    __int128 v74 = "Unexpected node %s is not a pattern\n";
    uint64_t v75 = a1;
    uint64_t v76 = a2;
    int v77 = 1115;
    goto LABEL_258;
  }

  if (!xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v8 = *(void *)(a2 + 72);
    goto LABEL_23;
  }

  uint64_t v9 = xmlRelaxNGNewDefine(a1, a2);
  int v10 = v9;
  if (v9)
  {
    *(_DWORD *)uint64_t v9 = 9;
    *((void *)v9 + 7) = *(void *)(a1 + 88);
    uint64_t v11 = *(void *)(a2 + 24);
    if (v11)
    {
      int v12 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 64) = v12 | 1;
      if (!xmlRelaxNGParseNameClass(a1, v11, (uint64_t)v9) || (uint64_t v11 = *(void *)(v11 + 48)) != 0)
      {
        uint64_t v13 = xmlRelaxNGParsePattern(a1, v11);
        if (v13)
        {
          unsigned int v14 = *(_DWORD *)v13 + 1;
          if (v14 <= 0x15)
          {
            int v15 = 1 << v14;
            if ((v15 & 0x1FFF76) != 0)
            {
              *((void *)v10 + 6) = v13;
              *(void *)(v13 + 56) = v10;
            }

            else
            {
              if ((v15 & 0x200088) != 0)
              {
                uint64_t v28 = "attribute has invalid content\n";
                uint64_t v29 = a1;
                uint64_t v30 = a2;
                int v31 = 1003;
              }

              else
              {
                uint64_t v28 = "RNG Internal error, noop found in attribute\n";
                uint64_t v29 = a1;
                uint64_t v30 = a2;
                int v31 = 1005;
              }

              xmlRngPErr(v29, v30, v31, v28, 0LL, 0LL);
            }
          }
        }

        if (*(void *)(v11 + 48)) {
          xmlRngPErr(a1, a2, 1002, "attribute has multiple children\n", 0LL, 0LL);
        }
      }

      *(_DWORD *)(a1 + 64) = v12;
      return (uint64_t *)v10;
    }

    uint64_t v19 = "xmlRelaxNGParseattribute: attribute has no children\n";
    uint64_t v20 = a1;
    uint64_t v21 = a2;
    int v22 = 1004;
LABEL_31:
    name = 0LL;
LABEL_32:
    xmlHashTablePtr v24 = 0LL;
LABEL_33:
    xmlRngPErr(v20, v21, v22, v19, name, v24);
  }

  return (uint64_t *)v10;
}

_OWORD *xmlRelaxNGParseNameClass(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a2 + 72)) {
    goto LABEL_83;
  }
  uint64_t v6 = (_OWORD *)a3;
  if (*(_DWORD *)(a2 + 8) == 1)
  {
    int v7 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"name");
    uint64_t v8 = *(void *)(a2 + 72);
    if (v7)
    {
      if (xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
      {
LABEL_5:
        uint64_t v6 = (_OWORD *)a3;
        if (*(_DWORD *)a3 != 4)
        {
          uint64_t v6 = (_OWORD *)a3;
          if (*(_DWORD *)a3 != 9)
          {
            uint64_t v9 = xmlRelaxNGNewDefine(a1, a2);
            uint64_t v6 = v9;
            if (!v9) {
              return v6;
            }
            *((void *)v9 + 7) = a3;
            if ((*(_DWORD *)(a1 + 64) & 1) != 0) {
              int v10 = 9;
            }
            else {
              int v10 = 4;
            }
            *(_DWORD *)uint64_t v9 = v10;
          }
        }

        goto LABEL_22;
      }

      uint64_t v8 = *(void *)(a2 + 72);
    }

    if (!v8) {
      goto LABEL_83;
    }
    uint64_t v6 = (_OWORD *)a3;
    if (*(_DWORD *)(a2 + 8) == 1)
    {
      int v11 = xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"anyName");
      uint64_t v12 = *(void *)(a2 + 72);
      if (v11)
      {
        uint64_t v12 = *(void *)(a2 + 72);
      }

      if (!v12) {
        goto LABEL_83;
      }
      uint64_t v6 = (_OWORD *)a3;
      if (*(_DWORD *)(a2 + 8) == 1)
      {
        uint64_t v6 = (_OWORD *)a3;
        if (xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"nsName"))
        {
          uint64_t v6 = (_OWORD *)a3;
          if (xmlStrEqual( *(const xmlChar **)(*(void *)(a2 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
          {
            goto LABEL_5;
          }
        }
      }
    }
  }

_OWORD *xmlRelaxNGParseExceptNameClass(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(void *)(a2 + 72)
    || *(_DWORD *)(a2 + 8) != 1
    || !xmlStrEqual(*(const xmlChar **)(a2 + 16), (const xmlChar *)"except")
    || !xmlStrEqual( *(const xmlChar **)(*(void *)(a2 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    uint64_t v14 = "Expecting an except node\n";
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    int v17 = 1028;
LABEL_21:
    xmlRngPErr(v15, v16, v17, v14, 0LL, 0LL);
    return 0LL;
  }

  if (*(void *)(a2 + 48)) {
    xmlRngPErr(a1, a2, 1029, "exceptNameClass allows only a single except node\n", 0LL, 0LL);
  }
  if (!*(void *)(a2 + 24))
  {
    uint64_t v14 = "except has no content\n";
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    int v17 = 1027;
    goto LABEL_21;
  }

  uint64_t v6 = xmlRelaxNGNewDefine(a1, a2);
  int v7 = v6;
  if (v6)
  {
    *(_DWORD *)uint64_t v6 = 2;
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      uint64_t v9 = 0LL;
      if (a3) {
        int v10 = 9;
      }
      else {
        int v10 = 4;
      }
      do
      {
        int v11 = xmlRelaxNGNewDefine(a1, v8);
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        *(_DWORD *)int v11 = v10;
        if (xmlRelaxNGParseNameClass(a1, v8, v11))
        {
          int v13 = v9 + 4;
          if (!v9) {
            int v13 = v7 + 3;
          }
          void *v13 = v12;
          uint64_t v9 = v12;
        }

        uint64_t v8 = *(void *)(v8 + 48);
      }

      while (v8);
    }
  }

  return v7;
}

uint64_t *xmlRelaxNGParseInterleave(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  int v4 = (uint64_t *)xmlRelaxNGNewDefine(a1, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    *(_DWORD *)int v4 = 19;
    if (*(void *)(a1 + 104) || (xmlHashTablePtr v6 = xmlHashCreate(10), (*(void *)(a1 + 104) = v6) != 0LL))
    {
      *(_OWORD *)__str = 0u;
      __int128 v14 = 0u;
      int v7 = *(_DWORD *)(a1 + 96);
      *(_DWORD *)(a1 + 96) = v7 + 1;
      snprintf(__str, 0x20uLL, "interleave%d", v7);
      if (xmlHashAddEntry(*(xmlHashTablePtr *)(a1 + 104), (const xmlChar *)__str, v5) < 0) {
        xmlRngPErr(a1, a2, 1045, "Failed to add %s to hash table\n", (const xmlChar *)__str, 0LL);
      }
    }

    else
    {
      xmlRngPErrMemory(a1, (const xmlChar *)"create interleaves\n");
    }

    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      uint64_t v9 = 0LL;
      while (1)
      {
        if (*(void *)(v8 + 72)
          && *(_DWORD *)(v8 + 8) == 1
          && xmlStrEqual(*(const xmlChar **)(v8 + 16), (const xmlChar *)"element")
          && xmlStrEqual( *(const xmlChar **)(*(void *)(v8 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
        {
          uint64_t v10 = xmlRelaxNGParseElement(a1, v8);
          if (v10) {
            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v10 = xmlRelaxNGParsePattern(a1, v8);
          if (v10)
          {
LABEL_16:
            *(void *)(v10 + 56) = v5;
            int v11 = (uint64_t *)(v9 + 64);
            if (!v9) {
              int v11 = v5 + 6;
            }
            *int v11 = v10;
            uint64_t v9 = v10;
          }
        }

        uint64_t v8 = *(void *)(v8 + 48);
        if (!v8) {
          return v5;
        }
      }
    }

    xmlRngPErr(a1, a2, 1048, "Element interleave is empty\n", 0LL, 0LL);
  }

  return v5;
}

_OWORD *xmlRelaxNGProcessExternalRef(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 104);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = a2;
  uint64_t v5 = xmlRelaxNGNewDefine(a1, a2);
  xmlHashTablePtr v6 = v5;
  if (v5)
  {
    *(_DWORD *)uint64_t v5 = 12;
    if (*(void *)(v2 + 24))
    {
LABEL_4:
      *((void *)v6 + 6) = *(void *)(v2 + 24);
      return v6;
    }

    xmlNodePtr RootElement = xmlDocGetRootElement(*(const xmlDoc **)(v2 + 16));
    if (RootElement)
    {
      uint64_t v8 = (xmlNode *)RootElement;
      Prop = xmlGetProp(RootElement, (const xmlChar *)"ns");
      BOOL v10 = Prop == 0LL;
      if (!Prop)
      {
        while (1)
        {
          if (*(_DWORD *)(v3 + 8) != 1)
          {
LABEL_14:
            BOOL v10 = 0;
            goto LABEL_15;
          }

          uint64_t v12 = xmlGetProp((const xmlNode *)v3, (const xmlChar *)"ns");
          if (v12) {
            break;
          }
          uint64_t v3 = *(void *)(v3 + 40);
          if (!v3) {
            goto LABEL_14;
          }
        }

        Prop = v12;
        xmlSetProp(v8, (const xmlChar *)"ns", v12);
      }

      xmlFree(Prop);
LABEL_15:
      int v13 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 64) = v13 | 0x80;
      uint64_t v14 = xmlRelaxNGParseDocument(a1, v8);
      *(void *)(v2 + 32) = v14;
      *(_DWORD *)(a1 + 64) = v13;
      if (v14)
      {
        uint64_t v15 = *(void *)(v14 + 8);
        if (v15)
        {
          *(void *)(v2 + 24) = *(void *)(v15 + 24);
          uint64_t v16 = *(xmlHashTable **)(v15 + 56);
          if (v16)
          {
            uint64_t v17 = *(void *)(a1 + 48);
            if (v17)
            {
              if (!*(void *)(v17 + 56))
              {
                xmlHashTablePtr v18 = xmlHashCreate(10);
                *(void *)(*(void *)(a1 + 48) + 56LL) = v18;
                if (!v18)
                {
                  xmlRngPErr(a1, 0LL, 1098, "Could not create references hash\n", 0LL, 0LL);
                  if (!v10) {
                    goto LABEL_4;
                  }
                  goto LABEL_24;
                }

                uint64_t v16 = *(xmlHashTable **)(v15 + 56);
              }

              xmlHashScan(v16, (xmlHashScanner)xmlRelaxNGParseImportRef, (void *)a1);
            }
          }
        }
      }

      if (!v10) {
        goto LABEL_4;
      }
LABEL_24:
      xmlUnsetProp(v8, (const xmlChar *)"ns");
      goto LABEL_4;
    }

    xmlRngPErr(a1, v3, 1031, "xmlRelaxNGParse: %s is empty\n", *(const xmlChar **)(a1 + 128), 0LL);
    return 0LL;
  }

  return v6;
}

xmlChar *xmlRelaxNGGetDataTypeLibrary(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!*(void *)(a1 + 72) || *(_DWORD *)(a1 + 8) != 1) {
    goto LABEL_11;
  }
  int v2 = xmlStrEqual(*(const xmlChar **)(a1 + 16), (const xmlChar *)"data");
  uint64_t v3 = *(void *)(v1 + 72);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 72);
  }

  if (!v3
    || *(_DWORD *)(v1 + 8) != 1
    || !xmlStrEqual(*(const xmlChar **)(v1 + 16), (const xmlChar *)"value")
    || !xmlStrEqual( *(const xmlChar **)(*(void *)(v1 + 72) + 16LL),  (const xmlChar *)"http://relaxng.org/ns/structure/1.0"))
  {
    goto LABEL_11;
  }

uint64_t xmlRelaxNGParseImportRef(void *userdata, uint64_t a2, xmlChar *name)
{
  *((_WORD *)userdata + 49) |= 0x100u;
  uint64_t result = xmlHashAddEntry(*(xmlHashTablePtr *)(*(void *)(a2 + 48) + 56LL), name, userdata);
  if ((result & 0x80000000) != 0)
  {
    uint64_t result = (uint64_t)xmlHashLookup( *(xmlHashTablePtr *)(*(void *)(a2 + 48) + 56LL),  *((const xmlChar **)userdata + 2));
    if (result)
    {
      *((void *)userdata + 1htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr)cur, 0LL, 1) = *(void *)(result + 88);
      *(void *)(result + 88) = userdata;
    }

    else
    {
      xmlHashTablePtr v6 = (const xmlChar *)*((void *)userdata + 2);
      if (v6) {
        int v7 = "Error refs definitions '%s'\n";
      }
      else {
        int v7 = "Error refs definitions\n";
      }
      return (uint64_t)xmlRngPErr(a2, 0LL, 1098, v7, v6, 0LL);
    }
  }

  return result;
}

uint64_t xmlRelaxNGTryUnlink(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    *(void *)(a3 + 64) = *(void *)(a1 + 64);
  }

  else if (a2)
  {
    if (a2[6] == a1)
    {
      a3 = 0LL;
      a2[6] = *(void *)(a1 + 64);
    }

    else if (a2[9] == a1)
    {
      a3 = 0LL;
      a2[9] = *(void *)(a1 + 64);
    }

    else
    {
      a3 = 0LL;
      if (a2[10] == a1) {
        a2[10] = *(void *)(a1 + 64);
      }
    }
  }

  else
  {
    *(_DWORD *)a1 = -1;
    return a1;
  }

  return a3;
}

uint64_t xmlRelaxNGGenerateAttributes(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 68)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 1LL;
  if (a2)
  {
    for (uint64_t i = a2; ; uint64_t i = v5)
    {
      unsigned int v4 = *(_DWORD *)i;
      if ((*(_DWORD *)i - 10) >= 0xA)
      {
        BOOL v7 = v4 > 8;
        int v8 = (1 << v4) & 0x1F9;
        if (!v7 && v8 != 0) {
          return 0LL;
        }
      }

      else
      {
        uint64_t v5 = *(void *)(i + 48);
        if (v5)
        {
          uint64_t v6 = *(void *)(i + 48);
          do
          {
            *(void *)(v6 + 56) = i;
            uint64_t v6 = *(void *)(v6 + 64);
          }

          while (v6);
          continue;
        }
      }

      if (i == a2) {
        return 1LL;
      }
      while (1)
      {
        uint64_t v5 = *(void *)(i + 64);
        if (v5) {
          break;
        }
        uint64_t i = *(void *)(i + 56);
        if (i) {
          BOOL v10 = i == a2;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10) {
          return 1LL;
        }
      }
    }
  }

  return result;
}